{
  "metadata": {
    "timestamp": 1736567301060,
    "page": 901,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lesismal/nbio",
      "stars": 2273,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.015625,
          "content": "*.go text eol=lf"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0029296875,
          "content": "bin"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 24.017578125,
          "content": "# This file contains all available configuration options\n# with their default values.\n\n# options for analysis running\nrun:\n  # default concurrency is a available CPU number\n  concurrency: 4\n\n  # timeout for analysis, e.g. 30s, 5m, default is 1m\n  timeout: 1m\n\n  # exit code when at least one issue was found, default is 1\n  issues-exit-code: 1\n\n  # include test files or not, default is true\n  tests: true\n\n  # list of build tags, all linters use it. Default is empty list.\n  build-tags:\n    - mytag\n\n  # which dirs to skip: issues from them won't be reported;\n  # can use regexp here: generated.*, regexp is applied on full path;\n  # default value is empty list, but default dirs are skipped independently\n  # from this option's value (see skip-dirs-use-default).\n  # \"/\" will be replaced by current OS file path separator to properly work\n  # on Windows.\n  skip-dirs:\n    - src/external_libs\n    - autogenerated_by_my_lib\n\n  # default is true. Enables skipping of directories:\n  #   vendor$, third_party$, testdata$, examples$, Godeps$, builtin$\n  skip-dirs-use-default: true\n\n  # which files to skip: they will be analyzed, but issues from them\n  # won't be reported. Default value is empty list, but there is\n  # no need to include all autogenerated files, we confidently recognize\n  # autogenerated files. If it's not please let us know.\n  # \"/\" will be replaced by current OS file path separator to properly work\n  # on Windows.\n  skip-files:\n    - \".*\\\\.my\\\\.go$\"\n    - lib/bad.go\n\n  # by default isn't set. If set we pass it to \"go list -mod={option}\". From \"go help modules\":\n  # If invoked with -mod=readonly, the go command is disallowed from the implicit\n  # automatic updating of go.mod described above. Instead, it fails when any changes\n  # to go.mod are needed. This setting is most useful to check that go.mod does\n  # not need updates, such as in a continuous integration and testing system.\n  # If invoked with -mod=vendor, the go command assumes that the vendor\n  # directory holds the correct copies of dependencies and ignores\n  # the dependency descriptions in go.mod.\n  ## modules-download-mode: readonly|vendor|mod\n\n  # Allow multiple parallel golangci-lint instances running.\n  # If false (default) - golangci-lint acquires file lock on start.\n  allow-parallel-runners: false\n\n\n# output configuration options\noutput:\n  # colored-line-number|line-number|json|tab|checkstyle|code-climate|junit-xml|github-actions\n  # default is \"colored-line-number\"\n  format: colored-line-number\n\n  # print lines of code with issue, default is true\n  print-issued-lines: true\n\n  # print linter name in the end of issue text, default is true\n  print-linter-name: true\n\n  # make issues output unique by line, default is true\n  uniq-by-line: true\n\n  # add a prefix to the output file references; default is no prefix\n  path-prefix: \"\"\n\n  # sorts results by: filepath, line and column\n  sort-results: false\n\n\n# all available settings of specific linters\nlinters-settings:\n\n  cyclop:\n    # the maximal code complexity to report\n    max-complexity: 10\n    # the maximal average package complexity. If it's higher than 0.0 (float) the check is enabled (default 0.0)\n    package-average: 0.0\n    # should ignore tests (default false)\n    skip-tests: false\n\n  dogsled:\n    # checks assignments with too many blank identifiers; default is 2\n    max-blank-identifiers: 2\n\n  dupl:\n    # tokens count to trigger issue, 150 by default\n    threshold: 100\n\n  # errcheck:\n  #   # report about not checking of errors in type assertions: `a := b.(MyStruct)`;\n  #   # default is false: such cases aren't reported by default.\n  #   check-type-assertions: false\n\n  #   # report about assignment of errors to blank identifier: `num, _ := strconv.Atoi(numStr)`;\n  #   # default is false: such cases aren't reported by default.\n  #   check-blank: false\n\n  #   # [deprecated] comma-separated list of pairs of the form pkg:regex\n  #   # the regex is used to ignore names within pkg. (default \"fmt:.*\").\n  #   # see https://github.com/kisielk/errcheck#the-deprecated-method for details\n  #   ignore: fmt:.*,io/ioutil:^Read.*\n\n  #   # list of functions to exclude from checking, where each entry is a single function to exclude.\n  #   # see https://github.com/kisielk/errcheck#excluding-functions for details\n  #   exclude-functions:\n  #     - io/ioutil.ReadFile\n  #     - io.Copy(*bytes.Buffer)\n  #     - io.Copy(os.Stdout)\n\n  errorlint:\n    # Check whether fmt.Errorf uses the %w verb for formatting errors. See the readme for caveats\n    errorf: true\n    # Check for plain type assertions and type switches\n    asserts: true\n    # Check for plain error comparisons\n    comparison: true\n\n  exhaustive:\n    # check switch statements in generated files also\n    check-generated: false\n    # indicates that switch statements are to be considered exhaustive if a\n    # 'default' case is present, even if all enum members aren't listed in the\n    # switch\n    default-signifies-exhaustive: false\n\n  exhaustivestruct:\n    # Struct Patterns is list of expressions to match struct packages and names\n    # The struct packages have the form example.com/package.ExampleStruct\n    # The matching patterns can use matching syntax from https://pkg.go.dev/path#Match\n    # If this list is empty, all structs are tested.\n    struct-patterns:\n      - '*.Test'\n      - 'example.com/package.ExampleStruct'\n\n  forbidigo:\n    # Forbid the following identifiers (identifiers are written using regexp):\n    forbid:\n      - ^print.*$\n      - 'fmt\\.Print.*'\n    # Exclude godoc examples from forbidigo checks.  Default is true.\n    exclude_godoc_examples: false\n\n  funlen:\n    lines: 60\n    statements: 40\n\n  gci:\n    # put imports beginning with prefix after 3rd-party packages;\n    # only support one prefix\n    # if not set, use goimports.local-prefixes\n    local-prefixes: github.com/org/project\n\n  gocognit:\n    # minimal code complexity to report, 30 by default (but we recommend 10-20)\n    min-complexity: 10\n\n  nestif:\n    # minimal complexity of if statements to report, 5 by default\n    min-complexity: 4\n\n  goconst:\n    # minimal length of string constant, 3 by default\n    min-len: 3\n    # minimum occurrences of constant string count to trigger issue, 3 by default\n    min-occurrences: 3\n    # ignore test files, false by default\n    ignore-tests: false\n    # look for existing constants matching the values, true by default\n    match-constant: true\n    # search also for duplicated numbers, false by default\n    numbers: false\n    # minimum value, only works with goconst.numbers, 3 by default\n    min: 3\n    # maximum value, only works with goconst.numbers, 3 by default\n    max: 3\n    # ignore when constant is not used as function argument, true by default\n    ignore-calls: true\n\n  gocritic:\n    # Which checks should be enabled; can't be combined with 'disabled-checks';\n    # See https://go-critic.github.io/overview#checks-overview\n    # To check which checks are enabled run `GL_DEBUG=gocritic golangci-lint run`\n    # By default list of stable checks is used.\n    enabled-checks:\n     # - rangeValCopy enabled by default\n\n    # Which checks should be disabled; can't be combined with 'enabled-checks'; default is empty\n    disabled-checks:\n      - regexpMust\n\n    # Enable multiple checks by tags, run `GL_DEBUG=gocritic golangci-lint run` to see all tags and checks.\n    # Empty list by default. See https://github.com/go-critic/go-critic#usage -> section \"Tags\".\n    enabled-tags:\n      - performance\n    disabled-tags:\n      - experimental\n\n    # Settings passed to gocritic.\n    # The settings key is the name of a supported gocritic checker.\n    # The list of supported checkers can be find in https://go-critic.github.io/overview.\n    settings:\n      captLocal: # must be valid enabled check name\n        # whether to restrict checker to params only (default true)\n        paramsOnly: true\n      elseif:\n        # whether to skip balanced if-else pairs (default true)\n        skipBalanced: true\n      hugeParam:\n        # size in bytes that makes the warning trigger (default 80)\n        sizeThreshold: 80\n      rangeExprCopy:\n        # size in bytes that makes the warning trigger (default 512)\n        sizeThreshold: 512\n        # whether to check test functions (default true)\n        skipTestFuncs: true\n      rangeValCopy:\n        # size in bytes that makes the warning trigger (default 128)\n        sizeThreshold: 32\n        # whether to check test functions (default true)\n        skipTestFuncs: true\n      underef:\n        # whether to skip (*x).method() calls where x is a pointer receiver (default true)\n        skipRecvDeref: true\n\n  gocyclo:\n    # minimal code complexity to report, 30 by default (but we recommend 10-20)\n    min-complexity: 10\n\n  godot:\n    # comments to be checked: `declarations`, `toplevel`, or `all`\n    scope: declarations\n    # list of regexps for excluding particular comment lines from check\n    exclude:\n      # example: exclude comments which contain numbers\n      # - '[0-9]+'\n    # check that each sentence starts with a capital letter\n    capital: false\n\n  godox:\n    # report any comments starting with keywords, this is useful for TODO or FIXME comments that\n    # might be left in the code accidentally and should be resolved before merging\n    keywords: # default keywords are TODO, BUG, and FIXME, these can be overwritten by this setting\n      - NOTE\n      - OPTIMIZE # marks code that should be optimized before merging\n      - HACK # marks hack-arounds that should be removed before merging\n\n  gofmt:\n    # simplify code: gofmt with `-s` option, true by default\n    simplify: true\n\n  gofumpt:\n    # Select the Go version to target. The default is `1.15`.\n    lang-version: \"1.15\"\n\n    # Choose whether or not to use the extra rules that are disabled\n    # by default\n    extra-rules: false\n\n  goheader:\n    values:\n      const:\n        # define here const type values in format k:v, for example:\n        # COMPANY: MY COMPANY\n      regexp:\n        # define here regexp type values, for example\n        # AUTHOR: .*@mycompany\\.com\n    template: # |-\n      # put here copyright header template for source code files, for example:\n      # Note: {{ YEAR }} is a builtin value that returns the year relative to the current machine time.\n      #\n      # {{ AUTHOR }} {{ COMPANY }} {{ YEAR }}\n      # SPDX-License-Identifier: Apache-2.0\n\n      # Licensed under the Apache License, Version 2.0 (the \"License\");\n      # you may not use this file except in compliance with the License.\n      # You may obtain a copy of the License at:\n\n      #   http://www.apache.org/licenses/LICENSE-2.0\n\n      # Unless required by applicable law or agreed to in writing, software\n      # distributed under the License is distributed on an \"AS IS\" BASIS,\n      # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n      # See the License for the specific language governing permissions and\n      # limitations under the License.\n    template-path:\n      # also as alternative of directive 'template' you may put the path to file with the template source\n\n  goimports:\n    # put imports beginning with prefix after 3rd-party packages;\n    # it's a comma-separated list of prefixes\n    local-prefixes: github.com/org/project\n\n  golint:\n    # minimal confidence for issues, default is 0.8\n    min-confidence: 0.8\n\n  gomnd:\n    settings:\n      mnd:\n        # the list of enabled checks, see https://github.com/tommy-muehle/go-mnd/#checks for description.\n        checks: argument,case,condition,operation,return,assign\n        # ignored-numbers: 1000\n        # ignored-files: magic_.*.go\n        # ignored-functions: math.*\n\n  gomoddirectives:\n    # Allow local `replace` directives. Default is false.\n    replace-local: false\n    # List of allowed `replace` directives. Default is empty.\n    replace-allow-list:\n      - launchpad.net/gocheck\n    # Allow to not explain why the version has been retracted in the `retract` directives. Default is false.\n    retract-allow-no-explanation: false\n    # Forbid the use of the `exclude` directives. Default is false.\n    exclude-forbidden: false\n\n  gomodguard:\n    allowed:\n      modules:                                                        # List of allowed modules\n        # - gopkg.in/yaml.v2\n      domains:                                                        # List of allowed module domains\n        # - golang.org\n    blocked:\n      modules:                                                        # List of blocked modules\n        # - github.com/uudashr/go-module:                             # Blocked module\n        #     recommendations:                                        # Recommended modules that should be used instead (Optional)\n        #       - golang.org/x/mod\n        #     reason: \"`mod` is the official go.mod parser library.\"  # Reason why the recommended module should be used (Optional)\n      versions:                                                       # List of blocked module version constraints\n        # - github.com/mitchellh/go-homedir:                          # Blocked module with version constraint\n        #     version: \"< 1.1.0\"                                      # Version constraint, see https://github.com/Masterminds/semver#basic-comparisons\n        #     reason: \"testing if blocked version constraint works.\"  # Reason why the version constraint exists. (Optional)\n      local_replace_directives: false                                 # Set to true to raise lint issues for packages that are loaded from a local path via replace directive\n\n  gosec:\n    # To select a subset of rules to run.\n    # Available rules: https://github.com/securego/gosec#available-rules\n    includes:\n      - G401\n      - G306\n      - G101\n    # To specify a set of rules to explicitly exclude.\n    # Available rules: https://github.com/securego/gosec#available-rules\n    excludes:\n      - G204\n    # To specify the configuration of rules.\n    # The configuration of rules is not fully documented by gosec:\n    # https://github.com/securego/gosec#configuration\n    # https://github.com/securego/gosec/blob/569328eade2ccbad4ce2d0f21ee158ab5356a5cf/rules/rulelist.go#L60-L102\n    config:\n      G306: \"0600\"\n      G101:\n        pattern: \"(?i)example\"\n        ignore_entropy: false\n        entropy_threshold: \"80.0\"\n        per_char_threshold: \"3.0\"\n        truncate: \"32\"\n\n  gosimple:\n    # Select the Go version to target. The default is '1.13'.\n    go: \"1.15\"\n    # https://staticcheck.io/docs/options#checks\n    checks: [ \"all\" ]\n\n  govet:\n    # report about shadowed variables\n    check-shadowing: true\n\n    # settings per analyzer\n    settings:\n      printf: # analyzer name, run `go tool vet help` to see all analyzers\n        funcs: # run `go tool vet help printf` to see available settings for `printf` analyzer\n          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Infof\n          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Warnf\n          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Errorf\n          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Fatalf\n\n    # enable or disable analyzers by name\n    # run `go tool vet help` to see all analyzers\n    enable:\n      - atomicalign\n    enable-all: false\n    disable:\n      - shadow\n    disable-all: false\n\n  depguard:\n    list-type: blacklist\n    include-go-root: false\n    packages:\n      - github.com/sirupsen/logrus\n    packages-with-error-message:\n      # specify an error message to output when a blacklisted package is used\n      - github.com/sirupsen/logrus: \"logging is allowed only by logutils.Log\"\n\n  ifshort:\n    # Maximum length of variable declaration measured in number of lines, after which linter won't suggest using short syntax.\n    # Has higher priority than max-decl-chars.\n    max-decl-lines: 1\n    # Maximum length of variable declaration measured in number of characters, after which linter won't suggest using short syntax.\n    max-decl-chars: 30\n\n  importas:\n    # if set to `true`, force to use alias.\n    no-unaliased: true\n    # List of aliases\n    alias:\n      # using `servingv1` alias for `knative.dev/serving/pkg/apis/serving/v1` package\n      - pkg: knative.dev/serving/pkg/apis/serving/v1\n        alias: servingv1\n      # using `autoscalingv1alpha1` alias for `knative.dev/serving/pkg/apis/autoscaling/v1alpha1` package\n      - pkg: knative.dev/serving/pkg/apis/autoscaling/v1alpha1\n        alias: autoscalingv1alpha1\n      # You can specify the package path by regular expression,\n      # and alias by regular expression expansion syntax like below.\n      # see https://github.com/julz/importas#use-regular-expression for details\n      - pkg: knative.dev/serving/pkg/apis/(\\w+)/(v[\\w\\d]+)\n        alias: $1$2\n\n  lll:\n    # max line length, lines longer will be reported. Default is 120.\n    # '\\t' is counted as 1 character by default, and can be changed with the tab-width option\n    line-length: 120\n    # tab width in spaces. Default to 1.\n    tab-width: 1\n\n  makezero:\n    # Allow only slices initialized with a length of zero. Default is false.\n    always: false\n\n  maligned:\n    # print struct with more effective memory layout or not, false by default\n    suggest-new: true\n\n  misspell:\n    # Correct spellings using locale preferences for US or UK.\n    # Default is to use a neutral variety of English.\n    # Setting locale to US will correct the British spelling of 'colour' to 'color'.\n    locale: US\n    ignore-words:\n      - someword\n\n  nakedret:\n    # make an issue if func has more lines of code than this setting and it has naked returns; default is 30\n    max-func-lines: 30\n\n  prealloc:\n    # XXX: we don't recommend using this linter before doing performance profiling.\n    # For most programs usage of prealloc will be a premature optimization.\n\n    # Report preallocation suggestions only on simple loops that have no returns/breaks/continues/gotos in them.\n    # True by default.\n    simple: true\n    range-loops: true # Report preallocation suggestions on range loops, true by default\n    for-loops: false # Report preallocation suggestions on for loops, false by default\n\n  promlinter:\n    # Promlinter cannot infer all metrics name in static analysis.\n    # Enable strict mode will also include the errors caused by failing to parse the args.\n    strict: false\n    # Please refer to https://github.com/yeya24/promlinter#usage for detailed usage.\n    disabled-linters:\n    #  - \"Help\"\n    #  - \"MetricUnits\"\n    #  - \"Counter\"\n    #  - \"HistogramSummaryReserved\"\n    #  - \"MetricTypeInName\"\n    #  - \"ReservedChars\"\n    #  - \"CamelCase\"\n    #  - \"lintUnitAbbreviations\"\n\n  predeclared:\n    # comma-separated list of predeclared identifiers to not report on\n    ignore: \"\"\n    # include method names and field names (i.e., qualified names) in checks\n    q: false\n\n  nolintlint:\n    # Enable to ensure that nolint directives are all used. Default is true.\n    allow-unused: false\n    # Disable to ensure that nolint directives don't have a leading space. Default is true.\n    allow-leading-space: true\n    # Exclude following linters from requiring an explanation.  Default is [].\n    allow-no-explanation: []\n    # Enable to require an explanation of nonzero length after each nolint directive. Default is false.\n    require-explanation: true\n    # Enable to require nolint directives to mention the specific linter being suppressed. Default is false.\n    require-specific: true\n\n  rowserrcheck:\n    packages:\n      - github.com/jmoiron/sqlx\n\n  revive:\n    # see https://github.com/mgechev/revive#available-rules for details.\n    ignore-generated-header: true\n    severity: warning\n    rules:\n      - name: indent-error-flow\n        severity: warning\n      - name: add-constant\n        severity: warning\n        arguments:\n          - maxLitCount: \"3\"\n            allowStrs: '\"\"'\n            allowInts: \"0,1,2\"\n            allowFloats: \"0.0,0.,1.0,1.,2.0,2.\"\n\n  staticcheck:\n    # Select the Go version to target. The default is '1.13'.\n    go: \"1.15\"\n    # https://staticcheck.io/docs/options#checks\n    checks: [ \"all\" ]\n\n  stylecheck:\n    # Select the Go version to target. The default is '1.13'.\n    go: \"1.15\"\n    # https://staticcheck.io/docs/options#checks\n    checks: [ \"all\", \"-ST1000\", \"-ST1003\", \"-ST1016\", \"-ST1020\", \"-ST1021\", \"-ST1022\" ]\n    # https://staticcheck.io/docs/options#dot_import_whitelist\n    dot-import-whitelist:\n      - fmt\n    # https://staticcheck.io/docs/options#initialisms\n    initialisms: [ \"ACL\", \"API\", \"ASCII\", \"CPU\", \"CSS\", \"DNS\", \"EOF\", \"GUID\", \"HTML\", \"HTTP\", \"HTTPS\", \"ID\", \"IP\", \"JSON\", \"QPS\", \"RAM\", \"RPC\", \"SLA\", \"SMTP\", \"SQL\", \"SSH\", \"TCP\", \"TLS\", \"TTL\", \"UDP\", \"UI\", \"GID\", \"UID\", \"UUID\", \"URI\", \"URL\", \"UTF8\", \"VM\", \"XML\", \"XMPP\", \"XSRF\", \"XSS\" ]\n    # https://staticcheck.io/docs/options#http_status_code_whitelist\n    http-status-code-whitelist: [ \"200\", \"400\", \"404\", \"500\" ]\n\n  tagliatelle:\n    # check the struck tag name case\n    case:\n      # use the struct field name to check the name of the struct tag\n      use-field-name: true\n      rules:\n        # any struct tag type can be used.\n        # support string case: `camel`, `pascal`, `kebab`, `snake`, `goCamel`, `goPascal`, `goKebab`, `goSnake`, `upper`, `lower`\n        json: camel\n        yaml: camel\n        xml: camel\n        bson: camel\n        avro: snake\n        mapstructure: kebab\n\n  testpackage:\n    # regexp pattern to skip files\n    skip-regexp: (export|internal)_test\\.go\n\n  thelper:\n    # The following configurations enable all checks. It can be omitted because all checks are enabled by default.\n    # You can enable only required checks deleting unnecessary checks.\n    test:\n      first: true\n      name: true\n      begin: true\n    benchmark:\n      first: true\n      name: true\n      begin: true\n    tb:\n      first: true\n      name: true\n      begin: true\n\n  unparam:\n    # Inspect exported functions, default is false. Set to true if no external program/library imports your code.\n    # XXX: if you enable this setting, unparam will report a lot of false-positives in text editors:\n    # if it's called for subdir of a project it can't find external interfaces. All text editor integrations\n    # with golangci-lint call it on a directory with the changed file.\n    check-exported: false\n\n  unused:\n    # Select the Go version to target. The default is '1.13'.\n    go: \"1.15\"\n\n  whitespace:\n    multi-if: false   # Enforces newlines (or comments) after every multi-line if statement\n    multi-func: false # Enforces newlines (or comments) after every multi-line function signature\n\n  wrapcheck:\n    # An array of strings that specify substrings of signatures to ignore.\n    # If this set, it will override the default set of ignored signatures.\n    # See https://github.com/tomarrell/wrapcheck#configuration for more information.\n    ignoreSigs:\n      - .Errorf(\n      - errors.New(\n      - errors.Unwrap(\n      - .Wrap(\n      - .Wrapf(\n      - .WithMessage(\n      - .WithMessagef(\n      - .WithStack(\n    ignorePackageGlobs:\n        - encoding/*\n        - github.com/pkg/*\n\n  wsl:\n    # See https://github.com/bombsimon/wsl/blob/master/doc/configuration.md for\n    # documentation of available settings. These are the defaults for\n    # `golangci-lint`.\n    allow-assign-and-anything: false\n    allow-assign-and-call: true\n    allow-cuddle-declarations: false\n    allow-multiline-assign: true\n    allow-separated-leading-comment: false\n    allow-trailing-comment: false\n    force-case-trailing-whitespace: 0\n    force-err-cuddling: false\n    force-short-decl-cuddling: false\n    strict-append: true\n\n#  # The custom section can be used to define linter plugins to be loaded at runtime.\n#  # See README doc for more info.\n#  custom:\n#    # Each custom linter should have a unique name.\n#     example:\n#      # The path to the plugin *.so. Can be absolute or local. Required for each custom linter\n#      path: /path/to/example.so\n#      # The description of the linter. Optional, just for documentation purposes.\n#      description: This is an example usage of a plugin linter.\n#      # Intended to point to the repo location of the linter. Optional, just for documentation purposes.\n#      original-url: github.com/golangci/example-linter\n\nlinters:\n  disable-all: false\n  enable:\n    - dogsled\n    - dupl\n    - importas\n    - gci\n    - goconst\n    - godot\n    - godox\n    - govet\n    - megacheck\n    - misspell\n    - nolintlint\n    - wastedassign\n    - unconvert\n  enable-all: false\n  disable:\n    - maligned\n    - prealloc\n    - scopelint\n    - errcheck\n  presets:\n    - bugs\n    - unused\n  fast: false"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.060546875,
          "content": "MIT License\r\n\r\nCopyright (c) 2020 lesismal\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.4931640625,
          "content": "GO?=go\nPACKAGE_DIRS=       $(shell $(GO) list -f '{{ .Dir }}' ./...|grep -v 'lesismal/nbio/examples')\nPACKAGES=           $(shell $(GO) list ./...|grep -v 'lesismal/nbio/examples')\n.PHONY: all vet lint\n\nall: vet lint test\n\nvet:\n\t$(GO) vet $(PACKAGES)\n\nlint:\n\tgolangci-lint run $(PACKAGE_DIRS)\n\ntest:\n\t$(GO) test -v $(PACKAGES)\n\nclean:\n\trm -rf ./autobahn/bin/*\n\trm -rf ./autobahn/report/*\n\nautobahn:\n\tchmod +x ./autobahn/script/run.sh & ./autobahn/script/run.sh\n\n.PHONY: all vet lint test clean  autobahn\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.2587890625,
          "content": "# NBIO - NON-BLOCKING IO\r\n\r\n\r\n<!-- [![Slack][1]][2] -->\r\n\r\n[![Mentioned in Awesome Go][3]][4] [![MIT licensed][5]][6] [![Go Version][7]][8] [![Build Status][9]][10] [![Go Report Card][11]][12]\r\n\r\n[1]: https://img.shields.io/badge/join-us%20on%20slack-gray.svg?longCache=true&logo=slack&colorB=green\r\n[2]: https://join.slack.com/t/arpcnbio/shared_invite/zt-vh3g1z2v-qqoDp1hQ45fJZqwPrSz4~Q\r\n[3]: https://awesome.re/mentioned-badge-flat.svg\r\n[4]: https://github.com/avelino/awesome-go#networking\r\n[5]: https://img.shields.io/badge/license-MIT-blue.svg\r\n[6]: LICENSE\r\n[7]: https://img.shields.io/badge/go-%3E%3D1.16-30dff3?style=flat-square&logo=go\r\n[8]: https://github.com/lesismal/nbio\r\n[9]: https://img.shields.io/github/actions/workflow/status/lesismal/nbio/autobahn.yml?branch=master&style=flat-square&logo=github-actions\r\n[10]: https://github.com/lesismal/nbio/actions?query=workflow%3autobahn\r\n[11]: https://goreportcard.com/badge/github.com/lesismal/nbio\r\n[12]: https://goreportcard.com/report/github.com/lesismal/nbio\r\n[13]: https://codecov.io/gh/lesismal/nbio/branch/master/graph/badge.svg\r\n[14]: https://codecov.io/gh/lesismal/nbio\r\n[15]: https://godoc.org/github.com/lesismal/nbio?status.svg\r\n[16]: https://godoc.org/github.com/lesismal/nbio\r\n\r\n\r\n## Contents\r\n\r\n- [NBIO - NON-BLOCKING IO](#nbio---non-blocking-io)\r\n\t- [Contents](#contents)\r\n\t- [Features](#features)\r\n\t\t- [Cross Platform](#cross-platform)\r\n\t\t- [Protocols Supported](#protocols-supported)\r\n\t\t- [Interfaces](#interfaces)\r\n\t- [Quick Start](#quick-start)\r\n\t- [Examples](#examples)\r\n\t\t- [TCP Echo Examples](#tcp-echo-examples)\r\n\t\t- [UDP Echo Examples](#udp-echo-examples)\r\n\t\t- [TLS Examples](#tls-examples)\r\n\t\t- [HTTP Examples](#http-examples)\r\n\t\t- [HTTPS Examples](#https-examples)\r\n\t\t- [Websocket Examples](#websocket-examples)\r\n\t\t- [Websocket TLS Examples](#websocket-tls-examples)\r\n\t\t- [Use With Other STD Based Frameworkds](#use-with-other-std-based-frameworkds)\r\n\t\t- [More Examples](#more-examples)\r\n\t- [1M Websocket Connections Benchmark](#1m-websocket-connections-benchmark)\r\n\t- [Magics For HTTP and Websocket](#magics-for-http-and-websocket)\r\n\t\t- [Different IOMod](#different-iomod)\r\n\t\t- [Using Websocket With Std Server](#using-websocket-with-std-server)\r\n\t- [Credits](#credits)\r\n\t- [Contributors](#contributors)\r\n\t- [Star History](#star-history)\r\n\r\n## Features\r\n### Cross Platform\r\n- [x] Linux: Epoll with LT/ET/ET+ONESHOT supported, LT as default\r\n- [x] BSD(MacOS): Kqueue\r\n- [x] Windows: Based on std net, for debugging only\r\n\r\n### Protocols Supported\r\n- [x] TCP/UDP/Unix Socket supported\r\n- [x] TLS supported\r\n- [x] HTTP/HTTPS 1.x supported\r\n- [x] Websocket supported, [Passes the Autobahn Test Suite](https://lesismal.github.io/nbio/websocket/autobahn), `OnOpen/OnMessage/OnClose` order guaranteed\r\n\r\n### Interfaces\r\n- [x] Implements a non-blocking net.Conn(except windows)\r\n- [x] SetDeadline/SetReadDeadline/SetWriteDeadline supported\r\n- [x] Concurrent Write/Close supported(both nbio.Conn and nbio/nbhttp/websocket.Conn)\r\n\r\n\r\n## Quick Start\r\n\r\n```golang\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\r\n\t\"github.com/lesismal/nbio\"\r\n)\r\n\r\nfunc main() {\r\n\tengine := nbio.NewEngine(nbio.Config{\r\n\t\tNetwork:            \"tcp\",//\"udp\", \"unix\"\r\n\t\tAddrs:              []string{\":8888\"},\r\n\t\tMaxWriteBufferSize: 6 * 1024 * 1024,\r\n\t})\r\n\r\n\t// hanlde new connection\r\n\tengine.OnOpen(func(c *nbio.Conn) {\r\n\t\tlog.Println(\"OnOpen:\", c.RemoteAddr().String())\r\n\t})\r\n\t// hanlde connection closed\r\n\tengine.OnClose(func(c *nbio.Conn, err error) {\r\n\t\tlog.Println(\"OnClose:\", c.RemoteAddr().String(), err)\r\n\t})\r\n\t// handle data\r\n\tengine.OnData(func(c *nbio.Conn, data []byte) {\r\n\t\tc.Write(append([]byte{}, data...))\r\n\t})\r\n\r\n\terr := engine.Start()\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"nbio.Start failed: %v\\n\", err)\r\n\t\treturn\r\n\t}\r\n\tdefer engine.Stop()\r\n\r\n\t<-make(chan int)\r\n}\r\n```\r\n\r\n## Examples\r\n### TCP Echo Examples\r\n\r\n- [echo-server](https://github.com/lesismal/nbio_examples/blob/master/echo/server/server.go)\r\n- [echo-client](https://github.com/lesismal/nbio_examples/blob/master/echo/client/client.go)\r\n\r\n### UDP Echo Examples\r\n\r\n- [udp-server](https://github.com/lesismal/nbio-examples/blob/master/udp/server/server.go)\r\n- [udp-client](https://github.com/lesismal/nbio-examples/blob/master/udp/client/client.go)\r\n\r\n### TLS Examples\r\n\r\n- [tls-server](https://github.com/lesismal/nbio_examples/blob/master/tls/server/server.go)\r\n- [tls-client](https://github.com/lesismal/nbio_examples/blob/master/tls/client/client.go)\r\n\r\n### HTTP Examples\r\n\r\n- [http-server](https://github.com/lesismal/nbio_examples/blob/master/http/server/server.go)\r\n- [http-client](https://github.com/lesismal/nbio_examples/blob/master/http/client/client.go)\r\n\r\n### HTTPS Examples\r\n\r\n- [http-tls_server](https://github.com/lesismal/nbio_examples/blob/master/http/server_tls/server.go)\r\n- visit: https://localhost:8888/echo\r\n\r\n### Websocket Examples\r\n\r\n- [websocket-server](https://github.com/lesismal/nbio_examples/blob/master/websocket/server/server.go)\r\n- [websocket-client](https://github.com/lesismal/nbio_examples/blob/master/websocket/client/client.go)\r\n\r\n### Websocket TLS Examples\r\n\r\n- [websocket-tls-server](https://github.com/lesismal/nbio_examples/blob/master/websocket_tls/server/server.go)\r\n- [websocket-tls-client](https://github.com/lesismal/nbio_examples/blob/master/websocket_tls/client/client.go)\r\n\r\n### Use With Other STD Based Frameworkds\r\n\r\n- [echo-http-and-websocket-server](https://github.com/lesismal/nbio_examples/blob/master/http_with_other_frameworks/echo_server/echo_server.go)\r\n- [gin-http-and-websocket-server](https://github.com/lesismal/nbio_examples/blob/master/http_with_other_frameworks/gin_server/gin_server.go)\r\n- [go-chi-http-and-websocket-server](https://github.com/lesismal/nbio_examples/blob/master/http_with_other_frameworks/go-chi_server/go-chi_server.go)\r\n\r\n### More Examples\r\n\r\n- [nbio-examples](https://github.com/lesismal/nbio-examples)\r\n\r\n\r\n\r\n## 1M Websocket Connections Benchmark\r\n\r\nFor more details: [go-websocket-benchmark](https://github.com/lesismal/go-websocket-benchmark)\r\n\r\n```sh\r\n# lsb_release -a\r\nLSB Version:    core-11.1.0ubuntu2-noarch:security-11.1.0ubuntu2-noarch\r\nDistributor ID: Ubuntu\r\nDescription:    Ubuntu 20.04.6 LTS\r\nRelease:        20.04\r\nCodename:       focal\r\n\r\n# free\r\n              total        used        free      shared  buff/cache   available\r\nMem:       24969564    15656352     3422212        1880     5891000     8899604\r\nSwap:             0           0           0\r\n\r\n# cat /proc/cpuinfo | grep processor\r\nprocessor       : 0\r\nprocessor       : 1\r\nprocessor       : 2\r\nprocessor       : 3\r\nprocessor       : 4\r\nprocessor       : 5\r\nprocessor       : 6\r\nprocessor       : 7\r\nprocessor       : 8\r\nprocessor       : 9\r\nprocessor       : 10\r\nprocessor       : 11\r\nprocessor       : 12\r\nprocessor       : 13\r\nprocessor       : 14\r\nprocessor       : 15\r\n\r\n\r\n# taskset\r\nrun nbio_nonblocking server on cpu 0-7\r\n\r\n--------------------------------------------------------------\r\nBenchType  : BenchEcho\r\nFramework  : nbio_nonblocking\r\nTPS        : 104713\r\nEER        : 280.33\r\nMin        : 56.90us\r\nAvg        : 95.36ms\r\nMax        : 2.29s\r\nTP50       : 62.82ms\r\nTP75       : 65.38ms\r\nTP90       : 89.38ms\r\nTP95       : 409.55ms\r\nTP99       : 637.95ms\r\nUsed       : 47.75s\r\nTotal      : 5000000\r\nSuccess    : 5000000\r\nFailed     : 0\r\nConns      : 1000000\r\nConcurrency: 10000\r\nPayload    : 1024\r\nCPU Min    : 0.00%\r\nCPU Avg    : 373.53%\r\nCPU Max    : 602.33%\r\nMEM Min    : 978.70M\r\nMEM Avg    : 979.88M\r\nMEM Max    : 981.14M\r\n--------------------------------------------------------------\r\n```\r\n\r\n\r\n## Magics For HTTP and Websocket\r\n\r\n### Different IOMod\r\n\r\n| IOMod            |                                                                                                                  Remarks                                                                                                                  |\r\n| ---------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |\r\n| IOModNonBlocking |                                                        There's no difference between this IOMod and the old version with no IOMod. All the connections will be handled by poller.                                                         |\r\n| IOModBlocking    | All the connections will be handled by at least one goroutine, for websocket, we can set Upgrader.BlockingModAsyncWrite=true to handle writing with a separated goroutine and then avoid Head-of-line blocking on broadcasting scenarios. |\r\n| IOModMixed       |                  We set the Engine.MaxBlockingOnline, if the online num is smaller than it, the new connection will be handled by single goroutine as IOModBlocking, else the new connection will be handled by poller.                   |\r\n\r\nThe `IOModBlocking` aims to improve the performance for low online service, it runs faster than std. \r\nThe `IOModMixed` aims to keep a balance between performance and cpu/mem cost in different scenarios: when there are not too many online connections, it performs better than std, or else it can serve lots of online connections and keep healthy.\r\n\r\n### Using Websocket With Std Server\r\n\r\n```golang\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/lesismal/nbio/nbhttp/websocket\"\r\n)\r\n\r\nvar (\r\n\tupgrader = newUpgrader()\r\n)\r\n\r\nfunc newUpgrader() *websocket.Upgrader {\r\n\tu := websocket.NewUpgrader()\r\n\tu.OnOpen(func(c *websocket.Conn) {\r\n\t\t// echo\r\n\t\tfmt.Println(\"OnOpen:\", c.RemoteAddr().String())\r\n\t})\r\n\tu.OnMessage(func(c *websocket.Conn, messageType websocket.MessageType, data []byte) {\r\n\t\t// echo\r\n\t\tfmt.Println(\"OnMessage:\", messageType, string(data))\r\n\t\tc.WriteMessage(messageType, data)\r\n\t})\r\n\tu.OnClose(func(c *websocket.Conn, err error) {\r\n\t\tfmt.Println(\"OnClose:\", c.RemoteAddr().String(), err)\r\n\t})\r\n\treturn u\r\n}\r\n\r\nfunc onWebsocket(w http.ResponseWriter, r *http.Request) {\r\n\tconn, err := upgrader.Upgrade(w, r, nil)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\tfmt.Println(\"Upgraded:\", conn.RemoteAddr().String())\r\n}\r\n\r\nfunc main() {\r\n\tmux := &http.ServeMux{}\r\n\tmux.HandleFunc(\"/ws\", onWebsocket)\r\n\tserver := http.Server{\r\n\t\tAddr:    \"localhost:8080\",\r\n\t\tHandler: mux,\r\n\t}\r\n\tfmt.Println(\"server exit:\", server.ListenAndServe())\r\n}\r\n```\r\n\r\n\r\n## Credits\r\n- [xtaci/gaio](https://github.com/xtaci/gaio)\r\n- [gorilla/websocket](https://github.com/gorilla/websocket)\r\n- [crossbario/autobahn](https://github.com/crossbario)\r\n\r\n\r\n## Contributors\r\nThanks Everyone:\r\n- [acgreek](https://github.com/acgreek)\r\n- [acsecureworks](https://github.com/acsecureworks)\r\n- [arunsathiya](https://github.com/arunsathiya)\r\n- [guonaihong](https://github.com/guonaihong)\r\n- [isletnet](https://github.com/isletnet)\r\n- [liwnn](https://github.com/liwnn)\r\n- [manjun21](https://github.com/manjun21)\r\n- [om26er](https://github.com/om26er)\r\n- [rfyiamcool](https://github.com/rfyiamcool)\r\n- [sunny352](https://github.com/sunny352)\r\n- [sunvim](https://github.com/sunvim)\r\n- [wuqinqiang](https://github.com/wuqinqiang)\r\n- [wziww](https://github.com/wziww)\r\n- [youzhixiaomutou](https://github.com/youzhixiaomutou)\r\n- [zbh255](https://github.com/zbh255)\r\n- [IceflowRE](https://github.com/IceflowRE)\r\n- [YanKawaYu](https://github.com/YanKawaYu)\r\n\r\n\r\n## Star History\r\n\r\n[![Star History Chart](https://api.star-history.com/svg?repos=lesismal/nbio&type=Date)](https://star-history.com/#lesismal/nbio&Date)\r\n"
        },
        {
          "name": "autobahn",
          "type": "tree",
          "content": null
        },
        {
          "name": "conn.go",
          "type": "blob",
          "size": 5.990234375,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage nbio\n\nimport (\n\t\"net\"\n\t\"runtime\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/lesismal/nbio/logging\"\n)\n\n// ConnType is used to identify different types of Conn.\ntype ConnType = int8\n\nconst (\n\t// ConnTypeTCP represents TCP Conn.\n\tConnTypeTCP ConnType = iota + 1\n\t// ConnTypeUDPServer represents UDP Conn used as a listener.\n\tConnTypeUDPServer\n\t// ConnTypeUDPClientFromRead represents UDP connection that\n\t// is sending data to our UDP Server from peer.\n\tConnTypeUDPClientFromRead\n\t// ConnTypeUDPClientFromDial represents UDP Conn that is sending\n\t// data to other UDP Server from ourselves.\n\tConnTypeUDPClientFromDial\n\t// ConnTypeUnix represents Unix Conn.\n\tConnTypeUnix\n)\n\n// Type .\n//\n//go:norace\nfunc (c *Conn) Type() ConnType {\n\treturn c.typ\n}\n\n// IsTCP returns whether this Conn is a TCP Conn.\n//\n//go:norace\nfunc (c *Conn) IsTCP() bool {\n\treturn c.typ == ConnTypeTCP\n}\n\n// IsUDP returns whether this Conn is a UDP Conn.\n//\n//go:norace\nfunc (c *Conn) IsUDP() bool {\n\tswitch c.typ {\n\tcase ConnTypeUDPServer, ConnTypeUDPClientFromDial, ConnTypeUDPClientFromRead:\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsUnix  returns whether this Conn is a Unix Conn.\n//\n//go:norace\nfunc (c *Conn) IsUnix() bool {\n\treturn c.typ == ConnTypeUnix\n}\n\n// Session returns user session.\n//\n//go:norace\nfunc (c *Conn) Session() interface{} {\n\treturn c.session\n}\n\n// SetSession sets user session.\n//\n//go:norace\nfunc (c *Conn) SetSession(session interface{}) {\n\tc.session = session\n}\n\n// OnData registers Conn's data handler.\n// Notice:\n//  1. The data readed by the poller is not handled by this Conn's data\n//     handler by default.\n//  2. The data readed by the poller is handled by nbio.Engine's data\n//     handler which is registered by nbio.Engine.OnData by default.\n//  3. This Conn's data handler is used to customize your implementation,\n//     you can set different data handler for different Conns,\n//     and call Conn's data handler in nbio.Engine's data handler.\n//     For example:\n//     engine.OnData(func(c *nbio.Conn, data byte){\n//     c.DataHandler()(c, data)\n//     })\n//     conn1.OnData(yourDatahandler1)\n//     conn2.OnData(yourDatahandler2)\n//\n//go:norace\nfunc (c *Conn) OnData(h func(conn *Conn, data []byte)) {\n\tc.dataHandler = h\n}\n\n// DataHandler returns Conn's data handler.\n//\n//go:norace\nfunc (c *Conn) DataHandler() func(conn *Conn, data []byte) {\n\treturn c.dataHandler\n}\n\n// Dial calls net.Dial to make a net.Conn and convert it to *nbio.Conn.\n//\n//go:norace\nfunc Dial(network string, address string) (*Conn, error) {\n\tconn, err := net.Dial(network, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NBConn(conn)\n}\n\n// Dial calls net.DialTimeout to make a net.Conn and convert it to *nbio.Conn.\n//\n//go:norace\nfunc DialTimeout(network string, address string, timeout time.Duration) (*Conn, error) {\n\tconn, err := net.DialTimeout(network, address, timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NBConn(conn)\n}\n\n// Lock .\n//\n//go:norace\nfunc (c *Conn) Lock() {\n\tc.mux.Lock()\n}\n\n// Unlock .\n//\n//go:norace\nfunc (c *Conn) Unlock() {\n\tc.mux.Unlock()\n}\n\n// IsClosed returns whether the Conn is closed.\n//\n//go:norace\nfunc (c *Conn) IsClosed() (bool, error) {\n\treturn c.closed, c.closeErr\n}\n\n// ExecuteLen returns the length of the Conn's job list.\n//\n//go:norace\nfunc (c *Conn) ExecuteLen() int {\n\tc.mux.Lock()\n\tn := len(c.jobList)\n\tc.mux.Unlock()\n\treturn n\n}\n\n// Execute is used to run the job.\n//\n// How it works:\n// If the job is the head/first of the Conn's job list, it will call the\n// nbio.Engine.Execute to run all the jobs in the job list that include:\n//  1. This job\n//  2. New jobs that are pushed to the back of the list before this job\n//     is done.\n//  3. nbio.Engine.Execute returns until there's no more jobs in the job\n//     list.\n//\n// Else if the job is not the head/first of the job list, it will push the\n// job to the back of the job list and wait to be called.\n// This guarantees there's at most one flow or goroutine running job/jobs\n// for each Conn.\n// This guarantees all the jobs are executed in order.\n//\n// Notice:\n//  1. The job wouldn't run or pushed to the back of the job list if the\n//     connection is closed.\n//  2. nbio.Engine.Execute is handled by a goroutine pool by default, users\n//     can customize it.\n//\n//go:norace\nfunc (c *Conn) Execute(job func()) bool {\n\tc.mux.Lock()\n\tif c.closed {\n\t\tc.mux.Unlock()\n\t\treturn false\n\t}\n\n\tisHead := (len(c.jobList) == 0)\n\tc.jobList = append(c.jobList, job)\n\tc.mux.Unlock()\n\n\t// If there's no job running, run Engine.Execute to run this job\n\t// and new jobs appended before this head job is done.\n\tif isHead {\n\t\tc.execute(job)\n\t}\n\treturn true\n}\n\n// MustExecute implements a similar function as Execute did,\n// but will still execute or push the job to the\n// back of the job list no matter whether Conn has been closed,\n// it guarantees the job to be executed.\n// This is used to handle the close event in nbio/nbhttp.\n//\n//go:norace\nfunc (c *Conn) MustExecute(job func()) {\n\tc.mux.Lock()\n\tisHead := (len(c.jobList) == 0)\n\tc.jobList = append(c.jobList, job)\n\tc.mux.Unlock()\n\n\t// If there's no job running, run Engine.Execute to run this job\n\t// and new jobs appended before this head job is done.\n\tif isHead {\n\t\tc.execute(job)\n\t}\n}\n\n//go:norace\nfunc (c *Conn) execute(job func()) {\n\tc.p.g.Execute(func() {\n\t\ti := 0\n\t\tfor {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif err := recover(); err != nil {\n\t\t\t\t\t\tconst size = 64 << 10\n\t\t\t\t\t\tbuf := make([]byte, size)\n\t\t\t\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\t\t\t\tlogging.Error(\"conn execute failed: %v\\n%v\\n\",\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t*(*string)(unsafe.Pointer(&buf)),\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tjob()\n\t\t\t}()\n\n\t\t\tc.mux.Lock()\n\t\t\ti++\n\t\t\tif len(c.jobList) == i {\n\t\t\t\t// set nil to release the job and gc\n\t\t\t\tc.jobList[i-1] = nil\n\t\t\t\t// reuse the slice\n\t\t\t\tc.jobList = c.jobList[0:0]\n\t\t\t\tc.mux.Unlock()\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// get next job\n\t\t\tjob = c.jobList[i]\n\t\t\t// set nil to release the job and gc\n\t\t\tc.jobList[i] = nil\n\t\t\tc.mux.Unlock()\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "conn_std.go",
          "type": "blob",
          "size": 10.189453125,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build windows\n// +build windows\n\npackage nbio\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/timer\"\n)\n\n// Conn wraps net.Conn.\ntype Conn struct {\n\tp *poller\n\n\thash int\n\n\tmux sync.Mutex\n\n\tconn    net.Conn\n\tconnUDP *udpConn\n\n\trTimer *time.Timer\n\n\ttyp      ConnType\n\tclosed   bool\n\tcloseErr error\n\n\tReadBuffer []byte\n\n\t// user session.\n\tsession interface{}\n\n\tjobList []func()\n\n\tcache *bytes.Buffer\n\n\tdataHandler func(c *Conn, data []byte)\n\n\tonConnected func(c *Conn, err error)\n}\n\n// Hash returns a hashcode.\n//\n//go:norace\nfunc (c *Conn) Hash() int {\n\treturn c.hash\n}\n\n// Read wraps net.Conn.Read.\n//\n//go:norace\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tif c.closeErr != nil {\n\t\treturn 0, c.closeErr\n\t}\n\n\tvar reader io.Reader = c.conn\n\tif c.cache != nil {\n\t\treader = c.cache\n\t}\n\tnread, err := reader.Read(b)\n\tif c.closeErr == nil {\n\t\tc.closeErr = err\n\t}\n\treturn nread, err\n}\n\n//go:norace\nfunc (c *Conn) read(b []byte) (int, error) {\n\tvar err error\n\tvar nread int\n\tswitch c.typ {\n\tcase ConnTypeTCP:\n\t\tnread, err = c.readTCP(b)\n\tcase ConnTypeUDPServer, ConnTypeUDPClientFromDial:\n\t\tnread, err = c.readUDP(b)\n\tcase ConnTypeUDPClientFromRead:\n\t\terr = errors.New(\"invalid udp conn for reading\")\n\tdefault:\n\t}\n\treturn nread, err\n}\n\n//go:norace\nfunc (c *Conn) readTCP(b []byte) (int, error) {\n\tg := c.p.g\n\t// g.beforeRead(c)\n\tnread, err := c.conn.Read(b)\n\tif c.closeErr == nil {\n\t\tc.closeErr = err\n\t}\n\tif g.onRead != nil {\n\t\tif nread > 0 {\n\t\t\tif c.cache == nil {\n\t\t\t\tc.cache = bytes.NewBuffer(nil)\n\t\t\t}\n\t\t\tc.cache.Write(b[:nread])\n\t\t}\n\t\tg.onRead(c)\n\t\treturn nread, nil\n\t} else if nread > 0 {\n\t\tg.onData(c, b[:nread])\n\t}\n\treturn nread, err\n}\n\n//go:norace\nfunc (c *Conn) readUDP(b []byte) (int, error) {\n\tif c.connUDP == nil {\n\t\treturn 0, errors.New(\"invalid conn\")\n\t}\n\tnread, rAddr, err := c.connUDP.ReadFromUDP(b)\n\tif c.closeErr == nil {\n\t\tc.closeErr = err\n\t}\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar g = c.p.g\n\tvar dstConn = c\n\tif c.typ == ConnTypeUDPServer {\n\t\tuc, ok := c.connUDP.getConn(c.p, rAddr)\n\t\tif g.UDPReadTimeout > 0 {\n\t\t\tuc.SetReadDeadline(time.Now().Add(g.UDPReadTimeout))\n\t\t}\n\t\tif !ok {\n\t\t\tp := g.pollers[c.Hash()%len(g.pollers)]\n\t\t\tp.addConn(uc)\n\t\t}\n\t\tdstConn = uc\n\t}\n\n\tif g.onRead != nil {\n\t\tif nread > 0 {\n\t\t\tif dstConn.cache == nil {\n\t\t\t\tdstConn.cache = bytes.NewBuffer(nil)\n\t\t\t}\n\t\t\tdstConn.cache.Write(b[:nread])\n\t\t}\n\t\tg.onRead(dstConn)\n\t\treturn nread, nil\n\t} else if nread > 0 {\n\t\tg.onData(dstConn, b[:nread])\n\t}\n\n\treturn nread, err\n}\n\n// Write wraps net.Conn.Write.\n//\n//go:norace\nfunc (c *Conn) Write(b []byte) (int, error) {\n\tvar n int\n\tvar err error\n\tswitch c.typ {\n\tcase ConnTypeTCP:\n\t\tn, err = c.writeTCP(b)\n\tcase ConnTypeUDPServer:\n\tcase ConnTypeUDPClientFromDial:\n\t\tn, err = c.writeUDPClientFromDial(b)\n\tcase ConnTypeUDPClientFromRead:\n\t\tn, err = c.writeUDPClientFromRead(b)\n\tdefault:\n\t}\n\tif c.p.g.onWrittenSize != nil && n > 0 {\n\t\tc.p.g.onWrittenSize(c, b[:n], n)\n\t}\n\treturn n, err\n}\n\n//go:norace\nfunc (c *Conn) writeTCP(b []byte) (int, error) {\n\t// c.p.g.beforeWrite(c)\n\tnwrite, err := c.conn.Write(b)\n\tif err != nil {\n\t\tif c.closeErr == nil {\n\t\t\tc.closeErr = err\n\t\t}\n\t\tc.Close()\n\t}\n\n\treturn nwrite, err\n}\n\n//go:norace\nfunc (c *Conn) writeUDPClientFromDial(b []byte) (int, error) {\n\tnwrite, err := c.connUDP.Write(b)\n\tif err != nil {\n\t\tif c.closeErr == nil {\n\t\t\tc.closeErr = err\n\t\t}\n\t\tc.Close()\n\t}\n\treturn nwrite, err\n}\n\n//go:norace\nfunc (c *Conn) writeUDPClientFromRead(b []byte) (int, error) {\n\tnwrite, err := c.connUDP.WriteToUDP(b, c.connUDP.rAddr)\n\tif err != nil {\n\t\tif c.closeErr == nil {\n\t\t\tc.closeErr = err\n\t\t}\n\t\tc.Close()\n\t}\n\treturn nwrite, err\n}\n\n// Writev wraps buffers.WriteTo/syscall.Writev.\n//\n//go:norace\nfunc (c *Conn) Writev(in [][]byte) (int, error) {\n\tif c.connUDP == nil {\n\t\tbuffers := net.Buffers(in)\n\t\tnwrite, err := buffers.WriteTo(c.conn)\n\t\tif err != nil {\n\t\t\tif c.closeErr == nil {\n\t\t\t\tc.closeErr = err\n\t\t\t}\n\t\t\tc.Close()\n\t\t}\n\t\tif c.p.g.onWrittenSize != nil && nwrite > 0 {\n\t\t\ttotal := int(nwrite)\n\t\t\tfor i := 0; total > 0; i++ {\n\t\t\t\tif total <= len(in[i]) {\n\t\t\t\t\tc.p.g.onWrittenSize(c, in[i][:total], total)\n\t\t\t\t\ttotal = 0\n\t\t\t\t} else {\n\t\t\t\t\tc.p.g.onWrittenSize(c, in[i], len(in[i]))\n\t\t\t\t\ttotal -= len(in[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn int(nwrite), err\n\t}\n\n\tvar total = 0\n\tfor _, b := range in {\n\t\tnwrite, err := c.Write(b)\n\t\tif nwrite > 0 {\n\t\t\ttotal += nwrite\n\t\t}\n\t\tif c.p.g.onWrittenSize != nil && nwrite > 0 {\n\t\t\tc.p.g.onWrittenSize(c, b[:nwrite], nwrite)\n\t\t}\n\t\tif err != nil {\n\t\t\tif c.closeErr == nil {\n\t\t\t\tc.closeErr = err\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treturn total, err\n\t\t}\n\t}\n\treturn total, nil\n}\n\n// Close wraps net.Conn.Close.\n//\n//go:norace\nfunc (c *Conn) Close() error {\n\tvar err error\n\tc.mux.Lock()\n\tif !c.closed {\n\t\tc.closed = true\n\n\t\tif c.rTimer != nil {\n\t\t\tc.rTimer.Stop()\n\t\t\tc.rTimer = nil\n\t\t}\n\n\t\tswitch c.typ {\n\t\tcase ConnTypeTCP:\n\t\t\terr = c.conn.Close()\n\t\tcase ConnTypeUDPServer, ConnTypeUDPClientFromDial, ConnTypeUDPClientFromRead:\n\t\t\terr = c.connUDP.Close()\n\t\tdefault:\n\t\t}\n\n\t\tc.mux.Unlock()\n\t\tif c.p.g != nil {\n\t\t\tc.p.deleteConn(c)\n\t\t}\n\t\treturn err\n\t}\n\tc.mux.Unlock()\n\treturn err\n}\n\n// CloseWithError .\n//\n//go:norace\nfunc (c *Conn) CloseWithError(err error) error {\n\tif c.closeErr == nil {\n\t\tc.closeErr = err\n\t}\n\treturn c.Close()\n}\n\n// LocalAddr wraps net.Conn.LocalAddr.\n//\n//go:norace\nfunc (c *Conn) LocalAddr() net.Addr {\n\tswitch c.typ {\n\tcase ConnTypeTCP:\n\t\treturn c.conn.LocalAddr()\n\tcase ConnTypeUDPServer, ConnTypeUDPClientFromDial, ConnTypeUDPClientFromRead:\n\t\treturn c.connUDP.LocalAddr()\n\tdefault:\n\t}\n\treturn nil\n}\n\n// RemoteAddr wraps net.Conn.RemoteAddr.\n//\n//go:norace\nfunc (c *Conn) RemoteAddr() net.Addr {\n\tswitch c.typ {\n\tcase ConnTypeTCP:\n\t\treturn c.conn.RemoteAddr()\n\tcase ConnTypeUDPClientFromDial:\n\t\treturn c.connUDP.RemoteAddr()\n\tcase ConnTypeUDPClientFromRead:\n\t\treturn c.connUDP.rAddr\n\tdefault:\n\t}\n\treturn nil\n}\n\n// SetDeadline wraps net.Conn.SetDeadline.\n//\n//go:norace\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\tif c.typ == ConnTypeTCP {\n\t\treturn c.conn.SetDeadline(t)\n\t}\n\treturn c.SetReadDeadline(t)\n}\n\n// SetReadDeadline wraps net.Conn.SetReadDeadline.\n//\n//go:norace\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\tif t.IsZero() {\n\t\tt = time.Now().Add(timer.TimeForever)\n\t}\n\n\tif c.typ == ConnTypeTCP {\n\t\treturn c.conn.SetReadDeadline(t)\n\t}\n\n\ttimeout := time.Until(t)\n\tif c.rTimer == nil {\n\t\tc.rTimer = c.p.g.AfterFunc(timeout, func() {\n\t\t\tc.CloseWithError(errReadTimeout)\n\t\t})\n\t} else {\n\t\tc.rTimer.Reset(timeout)\n\t}\n\n\treturn nil\n}\n\n// SetWriteDeadline wraps net.Conn.SetWriteDeadline.\n//\n//go:norace\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\tif c.typ != ConnTypeTCP {\n\t\treturn nil\n\t}\n\n\tif t.IsZero() {\n\t\tt = time.Now().Add(timer.TimeForever)\n\t}\n\n\treturn c.conn.SetWriteDeadline(t)\n}\n\n// SetNoDelay wraps net.Conn.SetNoDelay.\n//\n//go:norace\nfunc (c *Conn) SetNoDelay(nodelay bool) error {\n\tif c.typ != ConnTypeTCP {\n\t\treturn nil\n\t}\n\n\tconn, ok := c.conn.(*net.TCPConn)\n\tif ok {\n\t\treturn conn.SetNoDelay(nodelay)\n\t}\n\treturn nil\n}\n\n// SetReadBuffer wraps net.Conn.SetReadBuffer.\n//\n//go:norace\nfunc (c *Conn) SetReadBuffer(bytes int) error {\n\tif c.typ != ConnTypeTCP {\n\t\treturn nil\n\t}\n\n\tconn, ok := c.conn.(*net.TCPConn)\n\tif ok {\n\t\treturn conn.SetReadBuffer(bytes)\n\t}\n\treturn nil\n}\n\n// SetWriteBuffer wraps net.Conn.SetWriteBuffer.\n//\n//go:norace\nfunc (c *Conn) SetWriteBuffer(bytes int) error {\n\tif c.typ != ConnTypeTCP {\n\t\treturn nil\n\t}\n\n\tconn, ok := c.conn.(*net.TCPConn)\n\tif ok {\n\t\treturn conn.SetWriteBuffer(bytes)\n\t}\n\treturn nil\n}\n\n// SetKeepAlive wraps net.Conn.SetKeepAlive.\n//\n//go:norace\nfunc (c *Conn) SetKeepAlive(keepalive bool) error {\n\tif c.typ != ConnTypeTCP {\n\t\treturn nil\n\t}\n\n\tconn, ok := c.conn.(*net.TCPConn)\n\tif ok {\n\t\treturn conn.SetKeepAlive(keepalive)\n\t}\n\treturn nil\n}\n\n// SetKeepAlivePeriod wraps net.Conn.SetKeepAlivePeriod.\n//\n//go:norace\nfunc (c *Conn) SetKeepAlivePeriod(d time.Duration) error {\n\tif c.typ != ConnTypeTCP {\n\t\treturn nil\n\t}\n\n\tconn, ok := c.conn.(*net.TCPConn)\n\tif ok {\n\t\treturn conn.SetKeepAlivePeriod(d)\n\t}\n\treturn nil\n}\n\n// SetLinger wraps net.Conn.SetLinger.\n//\n//go:norace\nfunc (c *Conn) SetLinger(onoff int32, linger int32) error {\n\tif c.typ != ConnTypeTCP {\n\t\treturn nil\n\t}\n\n\tconn, ok := c.conn.(*net.TCPConn)\n\tif ok {\n\t\treturn conn.SetLinger(int(linger))\n\t}\n\treturn nil\n}\n\n//go:norace\nfunc newConn(conn net.Conn) *Conn {\n\tc := &Conn{}\n\taddr := conn.LocalAddr().String()\n\n\tuc, ok := conn.(*net.UDPConn)\n\tif ok {\n\t\trAddr := uc.RemoteAddr()\n\t\tif rAddr == nil {\n\t\t\tc.typ = ConnTypeUDPServer\n\t\t\tc.connUDP = &udpConn{\n\t\t\t\tUDPConn: uc,\n\t\t\t\tconns:   map[string]*Conn{},\n\t\t\t}\n\t\t} else {\n\t\t\tc.typ = ConnTypeUDPClientFromDial\n\t\t\taddr += rAddr.String()\n\t\t\tc.connUDP = &udpConn{\n\t\t\t\tUDPConn: uc,\n\t\t\t}\n\t\t}\n\t} else {\n\t\tc.conn = conn\n\t\tc.typ = ConnTypeTCP\n\t}\n\n\tfor _, ch := range addr {\n\t\tc.hash = 31*c.hash + int(ch)\n\t}\n\tif c.hash < 0 {\n\t\tc.hash = -c.hash\n\t}\n\n\treturn c\n}\n\n// NBConn converts net.Conn to *Conn.\n//\n//go:norace\nfunc NBConn(conn net.Conn) (*Conn, error) {\n\tif conn == nil {\n\t\treturn nil, errors.New(\"invalid conn: nil\")\n\t}\n\tc, ok := conn.(*Conn)\n\tif !ok {\n\t\tc = newConn(conn)\n\t}\n\treturn c, nil\n}\n\ntype udpConn struct {\n\t*net.UDPConn\n\trAddr *net.UDPAddr\n\n\tmux    sync.RWMutex\n\tparent *udpConn\n\tconns  map[string]*Conn\n}\n\n//go:norace\nfunc (u *udpConn) Close() error {\n\tparent := u.parent\n\tif parent != nil {\n\t\tparent.mux.Lock()\n\t\tdelete(parent.conns, u.rAddr.String())\n\t\tparent.mux.Unlock()\n\t} else {\n\t\tu.UDPConn.Close()\n\t\tfor _, c := range u.conns {\n\t\t\tc.Close()\n\t\t}\n\t\tu.conns = nil\n\t}\n\treturn nil\n}\n\n//go:norace\nfunc (u *udpConn) getConn(p *poller, rAddr *net.UDPAddr) (*Conn, bool) {\n\tu.mux.RLock()\n\taddr := rAddr.String()\n\tc, ok := u.conns[addr]\n\tu.mux.RUnlock()\n\n\tif !ok {\n\t\tc = &Conn{\n\t\t\tp:   p,\n\t\t\ttyp: ConnTypeUDPClientFromRead,\n\t\t\tconnUDP: &udpConn{\n\t\t\t\tparent:  u,\n\t\t\t\trAddr:   rAddr,\n\t\t\t\tUDPConn: u.UDPConn,\n\t\t\t},\n\t\t}\n\t\thashAddr := u.LocalAddr().String() + addr\n\t\tfor _, ch := range hashAddr {\n\t\t\tc.hash = 31*c.hash + int(ch)\n\t\t}\n\t\tif c.hash < 0 {\n\t\t\tc.hash = -c.hash\n\t\t}\n\t\tu.mux.Lock()\n\t\tu.conns[addr] = c\n\t\tu.mux.Unlock()\n\t}\n\n\treturn c, ok\n}\n\n//go:norace\nfunc (c *Conn) SyscallConn() (syscall.RawConn, error) {\n\tif rc, ok := c.conn.(interface {\n\t\tSyscallConn() (syscall.RawConn, error)\n\t}); ok {\n\t\treturn rc.SyscallConn()\n\t}\n\treturn nil, ErrUnsupported\n}\n"
        },
        {
          "name": "conn_unix.go",
          "type": "blob",
          "size": 23.580078125,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build linux || darwin || netbsd || freebsd || openbsd || dragonfly\n// +build linux darwin netbsd freebsd openbsd dragonfly\n\npackage nbio\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"net\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n)\n\n// var (\n// used to reset toWrite struct to empty value.\n// emptyToWrite = toWrite{}\n\n//\tpoolToWrite = sync.Pool{\n//\t\tNew: func() interface{} {\n//\t\t\treturn &toWrite{}\n//\t\t},\n//\t}\n// )\n\n//go:norace\nfunc (c *Conn) newToWriteBuf(buf []byte) {\n\tc.left += len(buf)\n\n\tallocator := c.p.g.BodyAllocator\n\tappendBuffer := func() {\n\t\tt := &toWrite{} // poolToWrite.New().(*toWrite)\n\t\tpbuf := allocator.Malloc(len(buf))\n\t\tcopy(*pbuf, buf)\n\t\tt.buf = pbuf\n\t\tc.writeList = append(c.writeList, t)\n\t}\n\n\tif len(c.writeList) == 0 {\n\t\tappendBuffer()\n\t\treturn\n\t}\n\n\ttail := c.writeList[len(c.writeList)-1]\n\tif tail.buf == nil {\n\t\tappendBuffer()\n\t} else {\n\t\tl := len(buf)\n\t\ttailLen := len(*tail.buf)\n\t\tif tailLen+l > maxWriteCacheOrFlushSize {\n\t\t\tappendBuffer()\n\t\t} else {\n\t\t\tif cap(*tail.buf) < tailLen+l {\n\t\t\t\tpbuf := allocator.Malloc(tailLen + l)\n\t\t\t\t*pbuf = (*pbuf)[:tailLen]\n\t\t\t\tcopy(*pbuf, *tail.buf)\n\t\t\t\tallocator.Free(tail.buf)\n\t\t\t\ttail.buf = pbuf\n\t\t\t}\n\t\t\ttail.buf = allocator.Append(tail.buf, buf...)\n\t\t}\n\t}\n}\n\n//go:norace\nfunc (c *Conn) newToWriteFile(fd int, offset, remain int64) {\n\tt := &toWrite{} // poolToWrite.New().(*toWrite)\n\tt.fd = fd\n\tt.offset = offset\n\tt.remain = remain\n\tc.writeList = append(c.writeList, t)\n}\n\n//go:norace\nfunc (c *Conn) releaseToWrite(t *toWrite) {\n\tif t.buf != nil {\n\t\tc.p.g.BodyAllocator.Free(t.buf)\n\t}\n\tif t.fd > 0 {\n\t\tsyscall.Close(t.fd)\n\t}\n\t// *t = emptyToWrite\n\t// poolToWrite.Put(t)\n}\n\nconst maxWriteCacheOrFlushSize = 1024 * 64\n\ntype toWrite struct {\n\tfd     int     // file descriptor, used for sendfile\n\tbuf    *[]byte // buffer to write\n\toffset int64   // buffer or file offset\n\tremain int64   // buffer or file remain bytes\n}\n\n// Conn implements net.Conn with non-blocking interfaces.\ntype Conn struct {\n\tmux sync.Mutex\n\n\t// the poller that handles io events for this connection.\n\tp *poller\n\n\t// file descriptor.\n\tfd int\n\n\tconnUDP *udpConn\n\n\t// used for read deadline.\n\trTimer *time.Timer\n\t// used for write deadline.\n\twTimer *time.Timer\n\n\t// how many bytes are cached and wait to be written.\n\tleft int\n\t// cache for buffers or files to be sent.\n\twriteList []*toWrite\n\n\ttyp    ConnType\n\tclosed bool\n\n\t// whether the writing event has been set in the poller.\n\tisWAdded bool\n\t// the first closing error.\n\tcloseErr error\n\n\t// local addr.\n\tlAddr net.Addr\n\t// remote addr.\n\trAddr net.Addr\n\n\t// user session.\n\tsession interface{}\n\n\t// job list.\n\tjobList []func()\n\n\treadEvents int32\n\n\tdataHandler func(c *Conn, data []byte)\n\n\tonConnected func(c *Conn, err error)\n}\n\n// Hash returns a hash code of this connection.\n//\n//go:norace\nfunc (c *Conn) Hash() int {\n\treturn c.fd\n}\n\n// AsyncReadInPoller is used for reading data async.\n//\n//go:norace\nfunc (c *Conn) AsyncRead() {\n\tg := c.p.g\n\n\t// If is EPOLLONESHOT, run the read job directly, because the reading event wouldn't\n\t// be re-dispatched before this reading event has been handled and set again.\n\tif g.isOneshot {\n\t\tg.IOExecute(func(buffer []byte) {\n\t\t\tfor i := 0; i < g.MaxConnReadTimesPerEventLoop; i++ {\n\t\t\t\trc, n, err := c.ReadAndGetConn(buffer)\n\t\t\t\tif n > 0 {\n\t\t\t\t\tg.onData(rc, buffer[:n])\n\t\t\t\t}\n\t\t\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.closeWithError(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif n < len(buffer) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.ResetPollerEvent()\n\t\t})\n\t\treturn\n\t}\n\n\t// If is not EPOLLONESHOT, the reading event may be re-dispatched for more than\n\t// once, here we reduce the duplicate reading events.\n\tcnt := atomic.AddInt32(&c.readEvents, 1)\n\tif cnt > 2 {\n\t\tatomic.AddInt32(&c.readEvents, -1)\n\t\treturn\n\t}\n\t// Only handle it when it's the first reading event.\n\tif cnt > 1 {\n\t\treturn\n\t}\n\n\tg.IOExecute(func(buffer []byte) {\n\t\tfor {\n\t\t\t// try to read all the data available.\n\t\t\tfor i := 0; i < g.MaxConnReadTimesPerEventLoop; i++ {\n\t\t\t\trc, n, err := c.ReadAndGetConn(buffer)\n\t\t\t\tif n > 0 {\n\t\t\t\t\tg.onData(rc, buffer[:n])\n\t\t\t\t}\n\t\t\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tc.closeWithError(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif n < len(buffer) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif atomic.AddInt32(&c.readEvents, -1) == 0 {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n}\n\n// Read .\n// Depracated .\n// It was used to customize users' reading implementation, but better to use\n// `ReadAndGetConn` instead, which can handle different types of connection and\n// returns the consistent connection instance for UDP.\n// Notice: non-blocking interface, should not be used as you use std.\n//\n//go:norace\nfunc (c *Conn) Read(b []byte) (int, error) {\n\t// When the connection is closed and the fd is reused on Unix,\n\t// new connection maybe hold the same fd.\n\t// Use lock to prevent data confusion.\n\tc.mux.Lock()\n\tif c.closed {\n\t\tc.mux.Unlock()\n\t\treturn 0, net.ErrClosed\n\t}\n\n\t_, n, err := c.doRead(b)\n\tc.mux.Unlock()\n\t// if err == nil {\n\t// \tc.p.g.afterRead(c)\n\t// }\n\n\treturn n, err\n}\n\n// ReadAndGetConn handles reading for different types of connection.\n// It returns the real connection:\n//  1. For Non-UDP connection, it returns the Conn itself.\n//  2. For UDP connection, it may be a UDP Server fd, then it returns consistent\n//     Conn for the same socket which has the same local addr and remote addr.\n//\n// Notice: non-blocking interface, should not be used as you use std.\n//\n//go:norace\nfunc (c *Conn) ReadAndGetConn(b []byte) (*Conn, int, error) {\n\t// When the connection is closed and the fd is reused on Unix,\n\t// new connection maybe hold the same fd.\n\t// Use lock to prevent data confusion.\n\tc.mux.Lock()\n\tif c.closed {\n\t\tc.mux.Unlock()\n\t\treturn c, 0, net.ErrClosed\n\t}\n\n\tdstConn, n, err := c.doRead(b)\n\tc.mux.Unlock()\n\t// if err == nil {\n\t// \tc.p.g.afterRead(c)\n\t// }\n\n\treturn dstConn, n, err\n}\n\n//go:norace\nfunc (c *Conn) doRead(b []byte) (*Conn, int, error) {\n\tswitch c.typ {\n\tcase ConnTypeTCP, ConnTypeUnix:\n\t\treturn c.readStream(b)\n\tcase ConnTypeUDPServer, ConnTypeUDPClientFromDial:\n\t\treturn c.readUDP(b)\n\tcase ConnTypeUDPClientFromRead:\n\t\t// no need to read for this type of connection,\n\t\t// it's handled when reading ConnTypeUDPServer.\n\tdefault:\n\t}\n\treturn c, 0, errors.New(\"invalid udp conn for reading\")\n}\n\n// read from TCP/Unix socket.\n//\n//go:norace\nfunc (c *Conn) readStream(b []byte) (*Conn, int, error) {\n\tnread, err := syscall.Read(c.fd, b)\n\treturn c, nread, err\n}\n\n// read from UDP socket.\n//\n//go:norace\nfunc (c *Conn) readUDP(b []byte) (*Conn, int, error) {\n\tnread, rAddr, err := syscall.Recvfrom(c.fd, b, 0)\n\tif c.closeErr == nil {\n\t\tc.closeErr = err\n\t}\n\tif err != nil {\n\t\treturn c, 0, err\n\t}\n\n\tvar g = c.p.g\n\tvar dstConn = c\n\tif c.typ == ConnTypeUDPServer {\n\t\t// get or create and cache the consistent connection for the socket\n\t\t// that has the same local addr and remote addr.\n\t\tuc, ok := c.connUDP.getConn(c.p, c.fd, rAddr)\n\t\tif g.UDPReadTimeout > 0 {\n\t\t\tuc.SetReadDeadline(time.Now().Add(g.UDPReadTimeout))\n\t\t}\n\t\tif !ok {\n\t\t\tg.onOpen(uc)\n\t\t}\n\t\tdstConn = uc\n\t}\n\n\treturn dstConn, nread, err\n}\n\n// Write writes data to the connection.\n// Notice:\n//  1. This is a non-blocking interface, but you can use it as you use std.\n//  2. When it can't write all the data now, the connection will cache the data\n//     left to be written and wait for the writing event then try to flush it.\n//\n//go:norace\nfunc (c *Conn) Write(b []byte) (int, error) {\n\t// c.p.g.beforeWrite(c)\n\n\tc.mux.Lock()\n\tif c.closed {\n\t\tc.mux.Unlock()\n\t\treturn -1, net.ErrClosed\n\t}\n\n\tn, err := c.write(b)\n\tif err != nil &&\n\t\t!errors.Is(err, syscall.EINTR) &&\n\t\t!errors.Is(err, syscall.EAGAIN) {\n\t\tc.closed = true\n\t\tc.mux.Unlock()\n\t\tc.closeWithErrorWithoutLock(err)\n\t\treturn n, err\n\t}\n\n\tif len(c.writeList) == 0 {\n\t\t// no data left to be written, clear write deadline timer.\n\t\tif c.wTimer != nil {\n\t\t\tc.wTimer.Stop()\n\t\t\tc.wTimer = nil\n\t\t}\n\t} else {\n\t\t// has data left to be written, set writing event.\n\t\tc.modWrite()\n\t}\n\n\tc.mux.Unlock()\n\treturn n, err\n}\n\n// Writev does similar things as Write, but with [][]byte input arg.\n// Notice: doesn't support UDP if more than 1 []byte.\n//\n//go:norace\nfunc (c *Conn) Writev(in [][]byte) (int, error) {\n\t// c.p.g.beforeWrite(c)\n\n\tc.mux.Lock()\n\tif c.closed {\n\t\tc.mux.Unlock()\n\n\t\treturn 0, net.ErrClosed\n\t}\n\n\tvar n int\n\tvar err error\n\tswitch len(in) {\n\tcase 1:\n\t\tn, err = c.write(in[0])\n\tdefault:\n\t\tn, err = c.writev(in)\n\t}\n\tif err != nil &&\n\t\t!errors.Is(err, syscall.EINTR) &&\n\t\t!errors.Is(err, syscall.EAGAIN) {\n\t\tc.closed = true\n\t\tc.mux.Unlock()\n\t\tc.closeWithErrorWithoutLock(err)\n\t\treturn n, err\n\t}\n\tif len(c.writeList) == 0 {\n\t\t// no data left to be written, clear write deadline timer.\n\t\tif c.wTimer != nil {\n\t\t\tc.wTimer.Stop()\n\t\t\tc.wTimer = nil\n\t\t}\n\t} else {\n\t\t// has data left to be written, set writing event.\n\t\tc.modWrite()\n\t}\n\n\tc.mux.Unlock()\n\treturn n, err\n}\n\n// write to TCP/Unix socket.\n//\n//go:norace\nfunc (c *Conn) writeStream(b []byte) (int, error) {\n\treturn syscall.Write(c.fd, b)\n}\n\n// write to UDP dialer.\n//\n//go:norace\nfunc (c *Conn) writeUDPClientFromDial(b []byte) (int, error) {\n\treturn syscall.Write(c.fd, b)\n}\n\n// write to UDP connection which is from server reading.\n//\n//go:norace\nfunc (c *Conn) writeUDPClientFromRead(b []byte) (int, error) {\n\terr := syscall.Sendto(c.fd, b, 0, c.connUDP.rAddr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn len(b), nil\n}\n\n// Close implements closes connection.\n//\n//go:norace\nfunc (c *Conn) Close() error {\n\treturn c.closeWithError(nil)\n}\n\n// CloseWithError closes connection with user specified error.\n//\n//go:norace\nfunc (c *Conn) CloseWithError(err error) error {\n\treturn c.closeWithError(err)\n}\n\n// LocalAddr returns the local network address, if known.\n//\n//go:norace\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.lAddr\n}\n\n// RemoteAddr returns the remote network address, if known.\n//\n//go:norace\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.rAddr\n}\n\n// SetDeadline sets deadline for both read and write.\n// If it is time.Zero, SetDeadline will clear the deadlines.\n//\n//go:norace\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\tc.mux.Lock()\n\tif !c.closed {\n\t\tif !t.IsZero() {\n\t\t\tg := c.p.g\n\t\t\tif c.rTimer == nil {\n\t\t\t\tc.rTimer = g.AfterFunc(time.Until(t), func() {\n\t\t\t\t\tc.closeWithError(errReadTimeout)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tc.rTimer.Reset(time.Until(t))\n\t\t\t}\n\t\t\tif c.wTimer == nil {\n\t\t\t\tc.wTimer = g.AfterFunc(time.Until(t), func() {\n\t\t\t\t\tc.closeWithError(errWriteTimeout)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tc.wTimer.Reset(time.Until(t))\n\t\t\t}\n\t\t} else {\n\t\t\tif c.rTimer != nil {\n\t\t\t\tc.rTimer.Stop()\n\t\t\t\tc.rTimer = nil\n\t\t\t}\n\t\t\tif c.wTimer != nil {\n\t\t\t\tc.wTimer.Stop()\n\t\t\t\tc.wTimer = nil\n\t\t\t}\n\t\t}\n\t}\n\tc.mux.Unlock()\n\treturn nil\n}\n\n//go:norace\nfunc (c *Conn) setDeadline(timer **time.Timer, errClose error, t time.Time) error {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\tif c.closed {\n\t\treturn nil\n\t}\n\tif !t.IsZero() {\n\t\tif *timer == nil {\n\t\t\t*timer = c.p.g.AfterFunc(time.Until(t), func() {\n\t\t\t\tc.closeWithError(errClose)\n\t\t\t})\n\t\t} else {\n\t\t\t(*timer).Reset(time.Until(t))\n\t\t}\n\t} else if *timer != nil {\n\t\t(*timer).Stop()\n\t\t(*timer) = nil\n\t}\n\treturn nil\n}\n\n// SetReadDeadline sets the deadline for future Read calls.\n// When the user doesn't update the deadline and the deadline exceeds,\n// the connection will be closed.\n// If it is time.Zero, SetReadDeadline will clear the deadline.\n//\n// Notice:\n//  1. Users should update the read deadline in time.\n//  2. For example, call SetReadDeadline whenever a new WebSocket message\n//     is received.\n//\n//go:norace\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.setDeadline(&c.rTimer, errReadTimeout, t)\n}\n\n// SetWriteDeadline sets the deadline for future data writing.\n// If it is time.Zero, SetReadDeadline will clear the deadline.\n//\n// If the next Write call writes all the data successfully and there's no data\n// left to bewritten, the deadline timer will be cleared automatically;\n// Else when the user doesn't update the deadline and the deadline exceeds,\n// the connection will be closed.\n//\n//go:norace\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.setDeadline(&c.wTimer, errWriteTimeout, t)\n}\n\n// SetNoDelay controls whether the operating system should delay\n// packet transmission in hopes of sending fewer packets (Nagle's\n// algorithm).  The default is true (no delay), meaning that data is\n// sent as soon as possible after a Write.\n//\n//go:norace\nfunc (c *Conn) SetNoDelay(nodelay bool) error {\n\tif nodelay {\n\t\treturn syscall.SetsockoptInt(\n\t\t\tc.fd,\n\t\t\tsyscall.IPPROTO_TCP,\n\t\t\tsyscall.TCP_NODELAY,\n\t\t\t1,\n\t\t)\n\t}\n\treturn syscall.SetsockoptInt(\n\t\tc.fd,\n\t\tsyscall.IPPROTO_TCP,\n\t\tsyscall.TCP_NODELAY,\n\t\t0,\n\t)\n}\n\n// SetReadBuffer sets the size of the operating system's\n// receive buffer associated with the connection.\n//\n//go:norace\nfunc (c *Conn) SetReadBuffer(bytes int) error {\n\treturn syscall.SetsockoptInt(\n\t\tc.fd,\n\t\tsyscall.SOL_SOCKET,\n\t\tsyscall.SO_RCVBUF,\n\t\tbytes,\n\t)\n}\n\n// SetWriteBuffer sets the size of the operating system's\n// transmit buffer associated with the connection.\n//\n//go:norace\nfunc (c *Conn) SetWriteBuffer(bytes int) error {\n\treturn syscall.SetsockoptInt(\n\t\tc.fd,\n\t\tsyscall.SOL_SOCKET,\n\t\tsyscall.SO_SNDBUF,\n\t\tbytes,\n\t)\n}\n\n// SetKeepAlive sets whether the operating system should send\n// keep-alive messages on the connection.\n//\n//go:norace\nfunc (c *Conn) SetKeepAlive(keepalive bool) error {\n\tif keepalive {\n\t\treturn syscall.SetsockoptInt(\n\t\t\tc.fd,\n\t\t\tsyscall.SOL_SOCKET,\n\t\t\tsyscall.SO_KEEPALIVE,\n\t\t\t1,\n\t\t)\n\t}\n\treturn syscall.SetsockoptInt(\n\t\tc.fd,\n\t\tsyscall.SOL_SOCKET,\n\t\tsyscall.SO_KEEPALIVE,\n\t\t0,\n\t)\n}\n\n// SetKeepAlivePeriod sets period between keep-alives.\n//\n//go:norace\nfunc (c *Conn) SetKeepAlivePeriod(d time.Duration) error {\n\tif runtime.GOOS == \"linux\" {\n\t\td += (time.Second - time.Nanosecond)\n\t\tsecs := int(d.Seconds())\n\t\tif err := syscall.SetsockoptInt(\n\t\t\tc.fd,\n\t\t\tIPPROTO_TCP,\n\t\t\tTCP_KEEPINTVL,\n\t\t\tsecs,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn syscall.SetsockoptInt(\n\t\t\tc.fd,\n\t\t\tIPPROTO_TCP,\n\t\t\tTCP_KEEPIDLE,\n\t\t\tsecs,\n\t\t)\n\t}\n\treturn errors.New(\"not supported\")\n}\n\n// SetLinger .\n//\n//go:norace\nfunc (c *Conn) SetLinger(onoff int32, linger int32) error {\n\treturn syscall.SetsockoptLinger(\n\t\tc.fd,\n\t\tsyscall.SOL_SOCKET,\n\t\tsyscall.SO_LINGER,\n\t\t&syscall.Linger{\n\t\t\tOnoff:  onoff,  // 1\n\t\t\tLinger: linger, // 0\n\t\t},\n\t)\n}\n\n// sets writing event.\n//\n//go:norace\nfunc (c *Conn) modWrite() {\n\tif !c.closed && !c.isWAdded {\n\t\tc.isWAdded = true\n\t\tc.p.modWrite(c.fd)\n\t}\n}\n\n// reset io event to read only.\n//\n//go:norace\nfunc (c *Conn) resetRead() {\n\tif !c.closed && c.isWAdded {\n\t\tc.isWAdded = false\n\t\tp := c.p\n\t\tp.resetRead(c.fd)\n\t}\n}\n\n//go:norace\nfunc (c *Conn) write(b []byte) (int, error) {\n\tif len(b) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tif c.overflow(len(b)) {\n\t\treturn -1, errOverflow\n\t}\n\n\tif len(c.writeList) == 0 {\n\t\tn, err := c.doWrite(b)\n\t\tif err != nil &&\n\t\t\t!errors.Is(err, syscall.EINTR) &&\n\t\t\t!errors.Is(err, syscall.EAGAIN) {\n\t\t\treturn n, err\n\t\t}\n\t\tif n < 0 {\n\t\t\tn = 0\n\t\t}\n\t\tleft := len(b) - n\n\t\tif left > 0 && c.typ == ConnTypeTCP {\n\t\t\tc.newToWriteBuf(b[n:])\n\t\t\t// c.appendWrite(t)\n\t\t}\n\t\treturn len(b), nil\n\t}\n\n\tc.newToWriteBuf(b)\n\t// c.appendWrite(t)\n\n\treturn len(b), nil\n}\n\n//go:norace\nfunc (c *Conn) writev(in [][]byte) (int, error) {\n\tsize := 0\n\tfor _, v := range in {\n\t\tsize += len(v)\n\t}\n\tif c.overflow(size) {\n\t\treturn -1, errOverflow\n\t}\n\tif len(c.writeList) > 0 {\n\t\tfor _, v := range in {\n\t\t\tc.newToWriteBuf(v)\n\t\t\t// c.appendWrite(t)\n\t\t}\n\t\treturn size, nil\n\t}\n\n\tnwrite, err := writev(c, in)\n\tif nwrite > 0 {\n\t\tn := nwrite\n\t\tonWrittenSize := c.p.g.onWrittenSize\n\t\tif n < size {\n\t\t\tfor i := 0; i < len(in) && n > 0; i++ {\n\t\t\t\tb := in[i]\n\t\t\t\tif n == 0 {\n\t\t\t\t\tc.newToWriteBuf(b)\n\t\t\t\t\t// c.appendWrite(t)\n\t\t\t\t} else {\n\t\t\t\t\tif n < len(b) {\n\t\t\t\t\t\tif onWrittenSize != nil {\n\t\t\t\t\t\t\tonWrittenSize(c, b[:n], n)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc.newToWriteBuf(b[n:])\n\t\t\t\t\t\t// c.appendWrite(t)\n\t\t\t\t\t\tn = 0\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif onWrittenSize != nil {\n\t\t\t\t\t\t\tonWrittenSize(c, b, len(b))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn -= len(b)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnwrite = 0\n\t}\n\n\treturn nwrite, err\n}\n\n// func (c *Conn) appendWrite(t *toWrite) {\n// c.writeList = append(c.writeList, t)\n// if t.buf != nil {\n// \tc.left += len(t.buf)\n// }\n// }\n\n// flush cached data to the fd when writing available.\n//\n//go:norace\nfunc (c *Conn) flush() error {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\tif c.closed {\n\t\treturn net.ErrClosed\n\t}\n\n\tif len(c.writeList) == 0 {\n\t\treturn nil\n\t}\n\n\tonWrittenSize := c.p.g.onWrittenSize\n\n\t// iovc := make([][]byte, 4)[0:0]\n\t// writeBuffers := func() error {\n\t// \tvar (\n\t// \t\tn    int\n\t// \t\terr  error\n\t// \t\thead *toWrite\n\t// \t)\n\n\t// \tif len(c.writeList) == 1 {\n\t// \t\thead = c.writeList[0]\n\t// \t\tbuf := head.buf[head.offset:]\n\t// \t\tfor len(buf) > 0 && err == nil {\n\t// \t\t\tn, err = syscall.Write(c.fd, buf)\n\t// \t\t\tif n > 0 {\n\t// \t\t\t\tif c.p.g.onWrittenSize != nil {\n\t// \t\t\t\t\tc.p.g.onWrittenSize(c, buf[:n], n)\n\t// \t\t\t\t}\n\t// \t\t\t\tc.left -= n\n\t// \t\t\t\thead.offset += int64(n)\n\t// \t\t\t\tbuf = buf[n:]\n\t// \t\t\t\tif len(buf) == 0 {\n\t// \t\t\t\t\tc.releaseToWrite(head)\n\t// \t\t\t\t\tc.writeList = nil\n\t// \t\t\t\t}\n\t// \t\t\t} else {\n\t// \t\t\t\tbreak\n\t// \t\t\t}\n\t// \t\t}\n\t// \t\treturn err\n\t// \t}\n\n\t// \twritevSize := maxWriteCacheOrFlushSize\n\t// \tiovc = iovc[0:0]\n\t// \tfor i := 0; i < len(c.writeList) && i < 1024; i++ {\n\t// \t\thead = c.writeList[i]\n\t// \t\tif head.buf != nil {\n\t// \t\t\tb := head.buf[head.offset:]\n\t// \t\t\twritevSize -= len(b)\n\t// \t\t\tif writevSize < 0 {\n\t// \t\t\t\tbreak\n\t// \t\t\t}\n\t// \t\t\tiovc = append(iovc, b)\n\t// \t\t}\n\t// \t}\n\n\t// \tfor len(iovc) > 0 && err == nil {\n\t// \t\tn, err = writev(c, iovc)\n\t// \t\tif n > 0 {\n\t// \t\t\tc.left -= n\n\t// \t\t\tfor n > 0 {\n\t// \t\t\t\thead = c.writeList[0]\n\t// \t\t\t\theadLeft := len(head.buf) - int(head.offset)\n\t// \t\t\t\tif n < headLeft {\n\t// \t\t\t\t\tif onWrittenSize != nil {\n\t// \t\t\t\t\t\tonWrittenSize(c, head.buf[head.offset:head.offset+int64(n)], n)\n\t// \t\t\t\t\t}\n\t// \t\t\t\t\thead.offset += int64(n)\n\t// \t\t\t\t\tiovc[0] = iovc[0][n:]\n\t// \t\t\t\t\tbreak\n\t// \t\t\t\t} else {\n\t// \t\t\t\t\tif onWrittenSize != nil {\n\t// \t\t\t\t\t\tonWrittenSize(c, head.buf[head.offset:], headLeft)\n\t// \t\t\t\t\t}\n\t// \t\t\t\t\tc.releaseToWrite(head)\n\t// \t\t\t\t\tc.writeList = c.writeList[1:]\n\t// \t\t\t\t\tif len(c.writeList) == 0 {\n\t// \t\t\t\t\t\tc.writeList = nil\n\t// \t\t\t\t\t}\n\t// \t\t\t\t\tiovc = iovc[1:]\n\t// \t\t\t\t\tn -= headLeft\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t} else {\n\t// \t\t\tbreak\n\t// \t\t}\n\t// \t}\n\t// \treturn err\n\t// }\n\twriteBuffer := func() error {\n\t\thead := c.writeList[0]\n\t\tbuf := (*head.buf)[head.offset:]\n\t\tn, err := syscall.Write(c.fd, buf)\n\t\tif n > 0 {\n\t\t\tif c.p.g.onWrittenSize != nil {\n\t\t\t\tc.p.g.onWrittenSize(c, buf[:n], n)\n\t\t\t}\n\t\t\tc.left -= n\n\t\t\thead.offset += int64(n)\n\t\t\tif len(buf) == n {\n\t\t\t\tc.releaseToWrite(head)\n\t\t\t\tc.writeList[0] = nil\n\t\t\t\tc.writeList = c.writeList[1:]\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\twriteFile := func() error {\n\t\tv := c.writeList[0]\n\t\tfor v.remain > 0 {\n\t\t\tvar offset = v.offset\n\t\t\tn, err := syscall.Sendfile(c.fd, v.fd, &offset, int(v.remain))\n\t\t\tif n > 0 {\n\t\t\t\tif onWrittenSize != nil {\n\t\t\t\t\tonWrittenSize(c, nil, n)\n\t\t\t\t}\n\t\t\t\tv.remain -= int64(n)\n\t\t\t\tv.offset += int64(n)\n\t\t\t\tif v.remain <= 0 {\n\t\t\t\t\tc.releaseToWrite(c.writeList[0])\n\t\t\t\t\tc.writeList[0] = nil\n\t\t\t\t\tc.writeList = c.writeList[1:]\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\tfor len(c.writeList) > 0 {\n\t\tvar err error\n\t\tif c.writeList[0].fd == 0 {\n\t\t\terr = writeBuffer()\n\t\t} else {\n\t\t\terr = writeFile()\n\t\t}\n\n\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\tcontinue\n\t\t}\n\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t// c.modWrite()\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\tc.closed = true\n\t\t\tc.closeWithErrorWithoutLock(err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tc.resetRead()\n\n\treturn nil\n}\n\n//go:norace\nfunc (c *Conn) doWrite(b []byte) (int, error) {\n\tvar n int\n\tvar err error\n\tswitch c.typ {\n\tcase ConnTypeTCP, ConnTypeUnix:\n\t\tn, err = c.writeStream(b)\n\tcase ConnTypeUDPServer:\n\tcase ConnTypeUDPClientFromDial:\n\t\tn, err = c.writeUDPClientFromDial(b)\n\tcase ConnTypeUDPClientFromRead:\n\t\tn, err = c.writeUDPClientFromRead(b)\n\tdefault:\n\t}\n\tif c.p.g.onWrittenSize != nil && n > 0 {\n\t\tc.p.g.onWrittenSize(c, b[:n], n)\n\t}\n\treturn n, err\n}\n\n//go:norace\nfunc (c *Conn) overflow(n int) bool {\n\tg := c.p.g\n\treturn g.MaxWriteBufferSize > 0 && (c.left+n > g.MaxWriteBufferSize)\n}\n\n//go:norace\nfunc (c *Conn) closeWithError(err error) error {\n\tc.mux.Lock()\n\tif !c.closed {\n\t\tc.closed = true\n\n\t\tif c.wTimer != nil {\n\t\t\tc.wTimer.Stop()\n\t\t\tc.wTimer = nil\n\t\t}\n\t\tif c.rTimer != nil {\n\t\t\tc.rTimer.Stop()\n\t\t\tc.rTimer = nil\n\t\t}\n\n\t\tc.mux.Unlock()\n\t\treturn c.closeWithErrorWithoutLock(err)\n\t}\n\tc.mux.Unlock()\n\treturn nil\n}\n\n//go:norace\nfunc (c *Conn) closeWithErrorWithoutLock(err error) error {\n\tc.closeErr = err\n\n\tif c.writeList != nil {\n\t\tfor _, t := range c.writeList {\n\t\t\tc.releaseToWrite(t)\n\t\t}\n\t\tc.writeList = nil\n\t}\n\n\tif c.p != nil {\n\t\tc.p.deleteConn(c)\n\t}\n\n\tswitch c.typ {\n\tcase ConnTypeTCP, ConnTypeUnix:\n\t\terr = syscall.Close(c.fd)\n\tcase ConnTypeUDPServer, ConnTypeUDPClientFromDial, ConnTypeUDPClientFromRead:\n\t\terr = c.connUDP.Close()\n\tdefault:\n\t}\n\n\treturn err\n}\n\n// NBConn converts net.Conn to *Conn.\n//\n//go:norace\nfunc NBConn(conn net.Conn) (*Conn, error) {\n\tif conn == nil {\n\t\treturn nil, errors.New(\"invalid conn: nil\")\n\t}\n\tc, ok := conn.(*Conn)\n\tif !ok {\n\t\tvar err error\n\t\tc, err = dupStdConn(conn)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn c, nil\n}\n\ntype udpConn struct {\n\tparent *Conn\n\n\trAddr    syscall.Sockaddr\n\trAddrKey udpAddrKey\n\n\tmux   sync.RWMutex\n\tconns map[udpAddrKey]*Conn\n}\n\n//go:norace\nfunc (u *udpConn) Close() error {\n\tparent := u.parent\n\tif parent.connUDP != u {\n\t\t// This connection is created by reading from a UDP server,\n\t\t// need to clear itself from the UDP server.\n\t\tparent.mux.Lock()\n\t\tdelete(parent.connUDP.conns, u.rAddrKey)\n\t\tparent.mux.Unlock()\n\t} else {\n\t\t// This connection is a UDP server or dialer, need to close itself\n\t\t// and close all children if this is a server.\n\t\tsyscall.Close(u.parent.fd)\n\t\tfor _, c := range u.conns {\n\t\t\tc.Close()\n\t\t}\n\t\tu.conns = nil\n\t}\n\treturn nil\n}\n\n//go:norace\nfunc (u *udpConn) getConn(p *poller, fd int, rsa syscall.Sockaddr) (*Conn, bool) {\n\trAddrKey := getUDPNetAddrKey(rsa)\n\tu.mux.RLock()\n\tc, ok := u.conns[rAddrKey]\n\tu.mux.RUnlock()\n\n\t// new connection, create it.\n\tif !ok {\n\t\tc = &Conn{\n\t\t\tp:     p,\n\t\t\tfd:    fd,\n\t\t\tlAddr: u.parent.lAddr,\n\t\t\trAddr: getUDPNetAddr(rsa),\n\t\t\ttyp:   ConnTypeUDPClientFromRead,\n\t\t\tconnUDP: &udpConn{\n\t\t\t\trAddr:    rsa,\n\t\t\t\trAddrKey: rAddrKey,\n\t\t\t\tparent:   u.parent,\n\t\t\t},\n\t\t}\n\n\t\t// storage the consistent connection for the same remote addr.\n\t\tu.mux.Lock()\n\t\tu.conns[rAddrKey] = c\n\t\tu.mux.Unlock()\n\t}\n\n\treturn c, ok\n}\n\ntype udpAddrKey [22]byte\n\n//go:norace\nfunc getUDPNetAddrKey(sa syscall.Sockaddr) udpAddrKey {\n\tvar ret udpAddrKey\n\tif sa == nil {\n\t\treturn ret\n\t}\n\n\tswitch vt := sa.(type) {\n\tcase *syscall.SockaddrInet4:\n\t\tcopy(ret[:], vt.Addr[:])\n\t\tbinary.LittleEndian.PutUint16(ret[16:], uint16(vt.Port))\n\tcase *syscall.SockaddrInet6:\n\t\tcopy(ret[:], vt.Addr[:])\n\t\tbinary.LittleEndian.PutUint16(ret[16:], uint16(vt.Port))\n\t\tbinary.LittleEndian.PutUint32(ret[18:], vt.ZoneId)\n\t}\n\treturn ret\n}\n\n//go:norace\nfunc getUDPNetAddr(sa syscall.Sockaddr) *net.UDPAddr {\n\tret := &net.UDPAddr{}\n\tswitch vt := sa.(type) {\n\tcase *syscall.SockaddrInet4:\n\t\tret.IP = make([]byte, len(vt.Addr))\n\t\tcopy(ret.IP[:], vt.Addr[:])\n\t\tret.Port = vt.Port\n\tcase *syscall.SockaddrInet6:\n\t\tret.IP = make([]byte, len(vt.Addr))\n\t\tcopy(ret.IP[:], vt.Addr[:])\n\t\tret.Port = vt.Port\n\t\ti, err := net.InterfaceByIndex(int(vt.ZoneId))\n\t\tif err == nil && i != nil {\n\t\t\tret.Zone = i.Name\n\t\t}\n\t}\n\treturn ret\n}\n\n//go:norace\nfunc (c *Conn) SyscallConn() (syscall.RawConn, error) {\n\treturn &rawConn{fd: c.fd}, nil\n}\n\ntype rawConn struct {\n\tfd int\n}\n\n//go:norace\nfunc (c *rawConn) Control(f func(fd uintptr)) error {\n\tf(uintptr(c.fd))\n\treturn nil\n}\n\n//go:norace\nfunc (c *rawConn) Read(f func(fd uintptr) (done bool)) error {\n\treturn ErrUnsupported\n}\n\n//go:norace\nfunc (c *rawConn) Write(f func(fd uintptr) (done bool)) error {\n\treturn ErrUnsupported\n}\n"
        },
        {
          "name": "engine.go",
          "type": "blob",
          "size": 10.333984375,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage nbio\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/lesismal/nbio/logging\"\n\t\"github.com/lesismal/nbio/mempool\"\n\t\"github.com/lesismal/nbio/taskpool\"\n\t\"github.com/lesismal/nbio/timer\"\n)\n\nconst (\n\t// DefaultReadBufferSize .\n\tDefaultReadBufferSize = 1024 * 64\n\n\t// DefaultMaxWriteBufferSize .\n\tDefaultMaxWriteBufferSize = 0\n\n\t// DefaultMaxConnReadTimesPerEventLoop .\n\tDefaultMaxConnReadTimesPerEventLoop = 3\n\n\t// DefaultUDPReadTimeout .\n\tDefaultUDPReadTimeout = 120 * time.Second\n)\n\nconst (\n\tNETWORK_TCP        = \"tcp\"\n\tNETWORK_TCP4       = \"tcp4\"\n\tNETWORK_TCP6       = \"tcp6\"\n\tNETWORK_UDP        = \"udp\"\n\tNETWORK_UDP4       = \"udp4\"\n\tNETWORK_UDP6       = \"udp6\"\n\tNETWORK_UNIX       = \"unix\"\n\tNETWORK_UNIXGRAM   = \"unixgram\"\n\tNETWORK_UNIXPACKET = \"unixpacket\"\n)\n\nvar (\n\t// MaxOpenFiles .\n\tMaxOpenFiles = 1024 * 1024 * 2\n)\n\n// Config Of Engine.\ntype Config struct {\n\t// Name describes your gopher name for logging, it's set to \"NB\" by default.\n\tName string\n\n\t// Network is the listening protocol, used with Addrs together.\n\tNetwork string\n\n\t// Addrs is the listening addr list for a nbio server.\n\t// if it is empty, no listener created, then the Engine is used for client by default.\n\tAddrs []string\n\n\t// NPoller represents poller goroutine num.\n\tNPoller int\n\n\t// ReadBufferSize represents buffer size for reading, it's set to 64k by default.\n\tReadBufferSize int\n\n\t// MaxWriteBufferSize represents max write buffer size for Conn, 0 by default, represents no limit for writeBuffer\n\t// if MaxWriteBufferSize is set greater than to 0, and the connection's Send-Q is full and the data cached by nbio is\n\t// more than MaxWriteBufferSize, the connection would be closed by nbio.\n\tMaxWriteBufferSize int\n\n\t// MaxConnReadTimesPerEventLoop represents max read times in one poller loop for one fd\n\tMaxConnReadTimesPerEventLoop int\n\n\t// LockListener represents whether to lock thread for listener's goroutine, false by default.\n\tLockListener bool\n\n\t// LockPoller represents whether to lock thread for poller's goroutine, false by default.\n\tLockPoller bool\n\n\t// EpollMod sets the epoll mod, EPOLLLT by default.\n\tEpollMod uint32\n\n\t// EPOLLONESHOT sets EPOLLONESHOT, 0 by default.\n\tEPOLLONESHOT uint32\n\n\t// UDPReadTimeout sets the timeout for udp sessions.\n\tUDPReadTimeout time.Duration\n\n\t// Listen is used to create listener for Engine.\n\t// Users can set this func to customize listener, such as reuseport.\n\tListen func(network, addr string) (net.Listener, error)\n\n\t// ListenUDP is used to create udp listener for Engine.\n\tListenUDP func(network string, laddr *net.UDPAddr) (*net.UDPConn, error)\n\n\t// AsyncReadInPoller represents how the reading events and reading are handled\n\t// by epoll goroutine:\n\t// true : epoll goroutine handles the reading events only, another goroutine\n\t//        pool will handle the reading.\n\t// false: epoll goroutine handles both the reading events and the reading.\n\tAsyncReadInPoller bool\n\t// IOExecute is used to handle the aysnc reading, users can customize it.\n\tIOExecute func(f func([]byte))\n\n\t// BodyAllocator sets the buffer allocator for write cache.\n\tBodyAllocator mempool.Allocator\n}\n\n// Gopher keeps old type to compatible with new name Engine.\ntype Gopher = Engine\n\n//go:norace\nfunc NewGopher(conf Config) *Gopher {\n\treturn NewEngine(conf)\n}\n\n// Engine is a manager of poller.\ntype Engine struct {\n\tConfig\n\t*timer.Timer\n\tsync.WaitGroup\n\n\tExecute func(f func())\n\tmux     sync.Mutex\n\n\tisOneshot bool\n\n\twgConn sync.WaitGroup\n\n\t// store std connections, for Windows only.\n\tconnsStd map[*Conn]struct{}\n\n\t// store *nix connections.\n\tconnsUnix []*Conn\n\n\t// listeners.\n\tlisteners []*poller\n\tpollers   []*poller\n\n\t// onUDPListen for udp listener created.\n\tonUDPListen func(c *Conn)\n\t// callback for new connection connected.\n\tonOpen func(c *Conn)\n\t// callback for connection closed.\n\tonClose func(c *Conn, err error)\n\t// callback for reading event.\n\tonRead func(c *Conn)\n\t// callback for coming data.\n\tonData func(c *Conn, data []byte)\n\t// callback for writing data size caculation.\n\tonWrittenSize func(c *Conn, b []byte, n int)\n\t// callback for allocationg the reading buffer.\n\tonReadBufferAlloc func(c *Conn) []byte\n\t// callback for freeing the reading buffer.\n\tonReadBufferFree func(c *Conn, buffer []byte)\n\n\t// depreacated.\n\t// beforeRead  func(c *Conn)\n\t// afterRead   func(c *Conn)\n\t// beforeWrite func(c *Conn)\n\n\t// callback for Engine stop.\n\tonStop func()\n\n\tioTaskPool *taskpool.IOTaskPool\n}\n\n// SetETAsyncRead .\n//\n//go:norace\nfunc (e *Engine) SetETAsyncRead() {\n\tif e.NPoller <= 0 {\n\t\te.NPoller = 1\n\t}\n\te.EpollMod = EPOLLET\n\te.AsyncReadInPoller = true\n}\n\n// SetLTSyncRead .\n//\n//go:norace\nfunc (e *Engine) SetLTSyncRead() {\n\tif e.NPoller <= 0 {\n\t\te.NPoller = runtime.NumCPU()\n\t}\n\te.EpollMod = EPOLLLT\n\te.AsyncReadInPoller = false\n}\n\n// Stop closes listeners/pollers/conns/timer.\n//\n//go:norace\nfunc (g *Engine) Stop() {\n\tfor _, l := range g.listeners {\n\t\tl.stop()\n\t}\n\n\tg.mux.Lock()\n\tconns := g.connsStd\n\tg.connsStd = map[*Conn]struct{}{}\n\tconnsUnix := g.connsUnix\n\tg.mux.Unlock()\n\n\tg.wgConn.Done()\n\tfor c := range conns {\n\t\tif c != nil {\n\t\t\tcc := c\n\t\t\tg.Async(func() {\n\t\t\t\tcc.Close()\n\t\t\t})\n\t\t}\n\t}\n\tfor _, c := range connsUnix {\n\t\tif c != nil {\n\t\t\tcc := c\n\t\t\tg.Async(func() {\n\t\t\t\tcc.Close()\n\t\t\t})\n\t\t}\n\t}\n\n\tg.wgConn.Wait()\n\n\tg.onStop()\n\n\tg.Timer.Stop()\n\n\tif g.ioTaskPool != nil {\n\t\tg.ioTaskPool.Stop()\n\t}\n\n\tfor i := 0; i < g.NPoller; i++ {\n\t\tg.pollers[i].stop()\n\t}\n\n\tg.Wait()\n\tlogging.Info(\"NBIO[%v] stop\", g.Name)\n}\n\n// Shutdown stops Engine gracefully with context.\n//\n//go:norace\nfunc (g *Engine) Shutdown(ctx context.Context) error {\n\tch := make(chan struct{})\n\tgo func() {\n\t\tg.Stop()\n\t\tclose(ch)\n\t}()\n\n\tselect {\n\tcase <-ch:\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n\treturn nil\n}\n\n// AddConn adds conn to a poller.\n//\n//go:norace\nfunc (g *Engine) AddConn(conn net.Conn) (*Conn, error) {\n\tc, err := NBConn(conn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := g.pollers[c.Hash()%len(g.pollers)]\n\terr = p.addConn(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\n//go:norace\nfunc (g *Engine) addDialer(c *Conn) (*Conn, error) {\n\tp := g.pollers[c.Hash()%len(g.pollers)]\n\terr := p.addDialer(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\n// OnOpen registers callback for new connection.\n//\n//go:norace\nfunc (g *Engine) OnUDPListen(h func(c *Conn)) {\n\tif h == nil {\n\t\tpanic(\"invalid handler: nil\")\n\t}\n\tg.onUDPListen = h\n}\n\n// OnOpen registers callback for new connection.\n//\n//go:norace\nfunc (g *Engine) OnOpen(h func(c *Conn)) {\n\tif h == nil {\n\t\tpanic(\"invalid handler: nil\")\n\t}\n\tg.onOpen = func(c *Conn) {\n\t\tg.wgConn.Add(1)\n\t\th(c)\n\t}\n}\n\n// OnClose registers callback for disconnected.\n//\n//go:norace\nfunc (g *Engine) OnClose(h func(c *Conn, err error)) {\n\tif h == nil {\n\t\tpanic(\"invalid handler: nil\")\n\t}\n\tg.onClose = func(c *Conn, err error) {\n\t\tg.Async(func() {\n\t\t\tdefer g.wgConn.Done()\n\t\t\th(c, err)\n\t\t})\n\t}\n}\n\n// OnRead registers callback for reading event.\n//\n//go:norace\nfunc (g *Engine) OnRead(h func(c *Conn)) {\n\tg.onRead = h\n}\n\n// OnData registers callback for data.\n//\n//go:norace\nfunc (g *Engine) OnData(h func(c *Conn, data []byte)) {\n\tif h == nil {\n\t\tpanic(\"invalid handler: nil\")\n\t}\n\tg.onData = h\n}\n\n// OnWrittenSize registers callback for written size.\n// If len(b) is bigger than 0, it represents that it's writing a buffer,\n// else it's operating by Sendfile.\n//\n//go:norace\nfunc (g *Engine) OnWrittenSize(h func(c *Conn, b []byte, n int)) {\n\tif h == nil {\n\t\tpanic(\"invalid handler: nil\")\n\t}\n\tg.onWrittenSize = h\n}\n\n// OnReadBufferAlloc registers callback for memory allocating.\n//\n//go:norace\nfunc (g *Engine) OnReadBufferAlloc(h func(c *Conn) []byte) {\n\tif h == nil {\n\t\tpanic(\"invalid handler: nil\")\n\t}\n\tg.onReadBufferAlloc = h\n}\n\n// OnReadBufferFree registers callback for memory release.\n//\n//go:norace\nfunc (g *Engine) OnReadBufferFree(h func(c *Conn, b []byte)) {\n\tif h == nil {\n\t\tpanic(\"invalid handler: nil\")\n\t}\n\tg.onReadBufferFree = h\n}\n\n// Depracated .\n// OnWriteBufferRelease registers callback for write buffer memory release.\n// func (g *Engine) OnWriteBufferRelease(h func(c *Conn, b []byte)) {\n// \tif h == nil {\n// \t\tpanic(\"invalid handler: nil\")\n// \t}\n// \tg.onWriteBufferFree = h\n// }\n\n// BeforeRead registers callback before syscall.Read\n// the handler would be called on windows.\n// func (g *Engine) BeforeRead(h func(c *Conn)) {\n// \tif h == nil {\n// \t\tpanic(\"invalid handler: nil\")\n// \t}\n// \tg.beforeRead = h\n// }\n\n// Depracated .\n// AfterRead registers callback after syscall.Read\n// the handler would be called on *nix.\n// func (g *Engine) AfterRead(h func(c *Conn)) {\n// \tif h == nil {\n// \t\tpanic(\"invalid handler: nil\")\n// \t}\n// \tg.afterRead = h\n// }\n\n// Depracated .\n// BeforeWrite registers callback befor syscall.Write and syscall.Writev\n// the handler would be called on windows.\n// func (g *Engine) BeforeWrite(h func(c *Conn)) {\n// \tif h == nil {\n// \t\tpanic(\"invalid handler: nil\")\n// \t}\n// \tg.beforeWrite = h\n// }\n\n// OnStop registers callback before Engine is stopped.\n//\n//go:norace\nfunc (g *Engine) OnStop(h func()) {\n\tif h == nil {\n\t\tpanic(\"invalid handler: nil\")\n\t}\n\tg.onStop = h\n}\n\n// PollerBuffer returns Poller's buffer by Conn, can be used on linux/bsd.\n//\n//go:norace\nfunc (g *Engine) PollerBuffer(c *Conn) []byte {\n\treturn c.p.ReadBuffer\n}\n\n//go:norace\nfunc (g *Engine) initHandlers() {\n\tg.wgConn.Add(1)\n\tg.OnOpen(func(c *Conn) {})\n\tg.OnClose(func(c *Conn, err error) {})\n\t// g.OnRead(func(c *Conn, b []byte) ([]byte, error) {\n\t// \tn, err := c.Read(b)\n\t// \tif n > 0 {\n\t// \t\treturn b[:n], err\n\t// \t}\n\t// \treturn nil, err\n\t// })\n\tg.OnData(func(c *Conn, data []byte) {})\n\tg.OnReadBufferAlloc(g.PollerBuffer)\n\tg.OnReadBufferFree(func(c *Conn, buffer []byte) {})\n\t// g.OnWriteBufferRelease(func(c *Conn, buffer []byte) {})\n\t// g.BeforeRead(func(c *Conn) {})\n\t// g.AfterRead(func(c *Conn) {})\n\t// g.BeforeWrite(func(c *Conn) {})\n\tg.OnUDPListen(func(*Conn) {})\n\tg.OnStop(func() {})\n\n\tif g.Execute == nil {\n\t\tg.Execute = func(f func()) {\n\t\t\tdefer func() {\n\t\t\t\tif err := recover(); err != nil {\n\t\t\t\t\tconst size = 64 << 10\n\t\t\t\t\tbuf := make([]byte, size)\n\t\t\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\t\t\tlogging.Error(\"execute failed: %v\\n%v\\n\", err, *(*string)(unsafe.Pointer(&buf)))\n\t\t\t\t}\n\t\t\t}()\n\t\t\tf()\n\t\t}\n\t}\n}\n\n//go:norace\nfunc (g *Engine) borrow(c *Conn) []byte {\n\treturn g.onReadBufferAlloc(c)\n}\n\n//go:norace\nfunc (g *Engine) payback(c *Conn, buffer []byte) {\n\tg.onReadBufferFree(c, buffer)\n}\n"
        },
        {
          "name": "engine_std.go",
          "type": "blob",
          "size": 4.4306640625,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build windows\n// +build windows\n\npackage nbio\n\nimport (\n\t\"net\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/logging\"\n\t\"github.com/lesismal/nbio/mempool\"\n\t\"github.com/lesismal/nbio/timer\"\n)\n\n// Start inits and starts pollers.\n//\n//go:norace\nfunc (g *Engine) Start() error {\n\t// Create listener pollers.\n\tudpListeners := make([]*net.UDPConn, len(g.Addrs))[0:0]\n\tswitch g.Network {\n\tcase NETWORK_TCP, NETWORK_TCP4, NETWORK_TCP6:\n\t\tfor i := range g.Addrs {\n\t\t\tln, err := newPoller(g, true, i)\n\t\t\tif err != nil {\n\t\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\t\tg.listeners[j].stop()\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg.Addrs[i] = ln.listener.Addr().String()\n\t\t\tg.listeners = append(g.listeners, ln)\n\t\t}\n\tcase NETWORK_UDP, NETWORK_UDP4, NETWORK_UDP6:\n\t\tfor i, addrStr := range g.Addrs {\n\t\t\taddr, err := net.ResolveUDPAddr(g.Network, addrStr)\n\t\t\tif err != nil {\n\t\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\t\tudpListeners[j].Close()\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tln, err := g.ListenUDP(\"udp\", addr)\n\t\t\tif err != nil {\n\t\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\t\tudpListeners[j].Close()\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg.Addrs[i] = ln.LocalAddr().String()\n\t\t\tudpListeners = append(udpListeners, ln)\n\t\t}\n\t}\n\n\t// Create IO pollers.\n\tfor i := 0; i < g.NPoller; i++ {\n\t\tp, err := newPoller(g, false, i)\n\t\tif err != nil {\n\t\t\tfor j := 0; j < len(g.listeners); j++ {\n\t\t\t\tg.listeners[j].stop()\n\t\t\t}\n\n\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\tg.pollers[j].stop()\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tg.pollers[i] = p\n\t}\n\n\t// Start IO pollers.\n\tfor i := 0; i < g.NPoller; i++ {\n\t\tg.Add(1)\n\t\tgo g.pollers[i].start()\n\t}\n\n\t// Start TCP/Unix listener pollers.\n\tfor _, l := range g.listeners {\n\t\tg.Add(1)\n\t\tgo l.start()\n\t}\n\n\t// Start UDP listener pollers.\n\tfor _, ln := range udpListeners {\n\t\t_, err := g.AddConn(ln)\n\t\tif err != nil {\n\t\t\tfor j := 0; j < len(g.listeners); j++ {\n\t\t\t\tg.listeners[j].stop()\n\t\t\t}\n\n\t\t\tfor j := 0; j < len(g.pollers); j++ {\n\t\t\t\tg.pollers[j].stop()\n\t\t\t}\n\n\t\t\tfor j := 0; j < len(udpListeners); j++ {\n\t\t\t\tudpListeners[j].Close()\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// g.Timer.Start()\n\n\tif len(g.Addrs) == 0 {\n\t\tlogging.Info(\"NBIO Engine[%v] start with [%v eventloop, MaxOpenFiles: %v]\",\n\t\t\tg.Name,\n\t\t\tg.NPoller,\n\t\t\tMaxOpenFiles,\n\t\t)\n\t} else {\n\t\tlogging.Info(\"NBIO Engine[%v] start with [%v eventloop], listen on: [\\\"%v@%v\\\"], MaxOpenFiles: %v\",\n\t\t\tg.Name,\n\t\t\tg.NPoller,\n\t\t\tg.Network,\n\t\t\tstrings.Join(g.Addrs, `\", \"`),\n\t\t\tMaxOpenFiles,\n\t\t)\n\t}\n\n\treturn nil\n}\n\n// NewEngine creates an Engine and init default configurations.\n//\n//go:norace\nfunc NewEngine(conf Config) *Engine {\n\tcpuNum := runtime.NumCPU()\n\tif conf.Name == \"\" {\n\t\tconf.Name = \"NB\"\n\t}\n\tif conf.NPoller <= 0 {\n\t\tconf.NPoller = cpuNum\n\t}\n\tif conf.ReadBufferSize <= 0 {\n\t\tconf.ReadBufferSize = DefaultReadBufferSize\n\t}\n\tif conf.MaxWriteBufferSize <= 0 {\n\t\tconf.MaxWriteBufferSize = DefaultMaxWriteBufferSize\n\t}\n\tif conf.Listen == nil {\n\t\tconf.Listen = net.Listen\n\t}\n\tif conf.ListenUDP == nil {\n\t\tconf.ListenUDP = net.ListenUDP\n\t}\n\tif conf.BodyAllocator == nil {\n\t\tconf.BodyAllocator = mempool.DefaultMemPool\n\t}\n\n\tg := &Engine{\n\t\tConfig:    conf,\n\t\tTimer:     timer.New(conf.Name),\n\t\tlisteners: make([]*poller, len(conf.Addrs))[0:0],\n\t\tpollers:   make([]*poller, conf.NPoller),\n\t\tconnsStd:  map[*Conn]struct{}{},\n\t}\n\n\tg.initHandlers()\n\n\tg.OnReadBufferAlloc(func(c *Conn) []byte {\n\t\tif c.ReadBuffer == nil {\n\t\t\tc.ReadBuffer = make([]byte, g.ReadBufferSize)\n\t\t}\n\t\treturn c.ReadBuffer\n\t})\n\n\treturn g\n}\n\n// DialAsync connects asynchrony to the address on the named network.\n//\n//go:norace\nfunc (engine *Engine) DialAsync(network, addr string, onConnected func(*Conn, error)) error {\n\treturn engine.DialAsyncTimeout(network, addr, 0, onConnected)\n}\n\n// DialAsync connects asynchrony to the address on the named network with timeout.\n//\n//go:norace\nfunc (engine *Engine) DialAsyncTimeout(network, addr string, timeout time.Duration, onConnected func(*Conn, error)) error {\n\tgo func() {\n\t\tvar err error\n\t\tvar conn net.Conn\n\t\tif timeout > 0 {\n\t\t\tconn, err = net.DialTimeout(network, addr, timeout)\n\t\t} else {\n\t\t\tconn, err = net.Dial(network, addr)\n\t\t}\n\t\tif err != nil {\n\t\t\tonConnected(nil, err)\n\t\t\treturn\n\t\t}\n\t\tnbc, err := NBConn(conn)\n\t\tif err != nil {\n\t\t\tonConnected(nil, err)\n\t\t\treturn\n\t\t}\n\t\tengine.wgConn.Add(1)\n\t\tnbc, err = engine.addDialer(nbc)\n\t\tif err == nil {\n\t\t\tnbc.SetWriteDeadline(time.Time{})\n\t\t} else {\n\t\t\tengine.wgConn.Done()\n\t\t}\n\t\tonConnected(nbc, err)\n\t}()\n\treturn nil\n}\n"
        },
        {
          "name": "engine_unix.go",
          "type": "blob",
          "size": 6.41796875,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build linux || darwin || netbsd || freebsd || openbsd || dragonfly\n// +build linux darwin netbsd freebsd openbsd dragonfly\n\npackage nbio\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"runtime\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/logging\"\n\t\"github.com/lesismal/nbio/mempool\"\n\t\"github.com/lesismal/nbio/taskpool\"\n\t\"github.com/lesismal/nbio/timer\"\n)\n\n// Start inits and starts pollers.\n//\n//go:norace\nfunc (g *Engine) Start() error {\n\tg.connsUnix = make([]*Conn, MaxOpenFiles)\n\n\t// Create pollers and listeners.\n\tg.pollers = make([]*poller, g.NPoller)\n\tg.listeners = make([]*poller, len(g.Addrs))[0:0]\n\tudpListeners := make([]*net.UDPConn, len(g.Addrs))[0:0]\n\n\tswitch g.Network {\n\tcase NETWORK_UNIX, NETWORK_TCP, NETWORK_TCP4, NETWORK_TCP6:\n\t\tfor i := range g.Addrs {\n\t\t\tln, err := newPoller(g, true, i)\n\t\t\tif err != nil {\n\t\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\t\tg.listeners[j].stop()\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg.Addrs[i] = ln.listener.Addr().String()\n\t\t\tg.listeners = append(g.listeners, ln)\n\t\t}\n\tcase NETWORK_UDP, NETWORK_UDP4, NETWORK_UDP6:\n\t\tfor i, addrStr := range g.Addrs {\n\t\t\taddr, err := net.ResolveUDPAddr(g.Network, addrStr)\n\t\t\tif err != nil {\n\t\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\t\tudpListeners[j].Close()\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tln, err := g.ListenUDP(\"udp\", addr)\n\t\t\tif err != nil {\n\t\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\t\tudpListeners[j].Close()\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg.Addrs[i] = ln.LocalAddr().String()\n\t\t\tudpListeners = append(udpListeners, ln)\n\t\t}\n\t}\n\n\t// Create IO pollers.\n\tfor i := 0; i < g.NPoller; i++ {\n\t\tp, err := newPoller(g, false, i)\n\t\tif err != nil {\n\t\t\tfor j := 0; j < len(g.listeners); j++ {\n\t\t\t\tg.listeners[j].stop()\n\t\t\t}\n\n\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\tg.pollers[j].stop()\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tg.pollers[i] = p\n\t}\n\n\t// Start IO pollers.\n\tfor i := 0; i < g.NPoller; i++ {\n\t\tg.pollers[i].ReadBuffer = make([]byte, g.ReadBufferSize)\n\t\tg.Add(1)\n\t\tgo g.pollers[i].start()\n\t}\n\n\t// Start TCP/Unix listener pollers.\n\tfor _, l := range g.listeners {\n\t\tg.Add(1)\n\t\tgo l.start()\n\t}\n\n\t// Start UDP listener pollers.\n\tfor _, ln := range udpListeners {\n\t\t_, err := g.AddConn(ln)\n\t\tif err != nil {\n\t\t\tfor j := 0; j < len(g.listeners); j++ {\n\t\t\t\tg.listeners[j].stop()\n\t\t\t}\n\n\t\t\tfor j := 0; j < len(g.pollers); j++ {\n\t\t\t\tg.pollers[j].stop()\n\t\t\t}\n\n\t\t\tfor j := 0; j < len(udpListeners); j++ {\n\t\t\t\tudpListeners[j].Close()\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\t}\n\n\tg.Timer.Start()\n\tg.isOneshot = (g.EpollMod == EPOLLET && g.EPOLLONESHOT == EPOLLONESHOT)\n\n\tif g.AsyncReadInPoller {\n\t\tif g.IOExecute == nil {\n\t\t\tg.ioTaskPool = taskpool.NewIO(0, 0, 0)\n\t\t\tg.IOExecute = g.ioTaskPool.Go\n\t\t}\n\t}\n\n\tif len(g.Addrs) == 0 {\n\t\tlogging.Info(\"NBIO Engine[%v] start with [%v eventloop, MaxOpenFiles: %v]\",\n\t\t\tg.Name,\n\t\t\tg.NPoller,\n\t\t\tMaxOpenFiles,\n\t\t)\n\t} else {\n\t\tlogging.Info(\"NBIO Engine[%v] start with [%v eventloop], listen on: [\\\"%v@%v\\\"], MaxOpenFiles: %v\",\n\t\t\tg.Name,\n\t\t\tg.NPoller,\n\t\t\tg.Network,\n\t\t\tstrings.Join(g.Addrs, `\", \"`),\n\t\t\tMaxOpenFiles,\n\t\t)\n\t}\n\n\treturn nil\n}\n\n// DialAsync connects asynchrony to the address on the named network.\n//\n//go:norace\nfunc (engine *Engine) DialAsync(network, addr string, onConnected func(*Conn, error)) error {\n\treturn engine.DialAsyncTimeout(network, addr, 0, onConnected)\n}\n\n// DialAsync connects asynchrony to the address on the named network with timeout.\n//\n//go:norace\nfunc (engine *Engine) DialAsyncTimeout(network, addr string, timeout time.Duration, onConnected func(*Conn, error)) error {\n\th := func(c *Conn, err error) {\n\t\tif err == nil {\n\t\t\tc.SetWriteDeadline(time.Time{})\n\t\t}\n\t\tonConnected(c, err)\n\t}\n\tdomain, typ, dialaddr, raddr, connType, err := parseDomainAndType(network, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfd, err := syscall.Socket(domain, typ, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = syscall.SetNonblock(fd, true)\n\tif err != nil {\n\t\tsyscall.Close(fd)\n\t\treturn err\n\t}\n\terr = syscall.Connect(fd, dialaddr)\n\tinprogress := false\n\tif err != nil {\n\t\tif errors.Is(err, syscall.EINPROGRESS) {\n\t\t\tinprogress = true\n\t\t} else {\n\t\t\tsyscall.Close(fd)\n\t\t\treturn err\n\t\t}\n\t}\n\tsa, _ := syscall.Getsockname(fd)\n\tc := &Conn{\n\t\tfd:    fd,\n\t\trAddr: raddr,\n\t\ttyp:   connType,\n\t}\n\tif inprogress {\n\t\tc.onConnected = h\n\t}\n\tswitch vt := sa.(type) {\n\tcase *syscall.SockaddrInet4:\n\t\tswitch connType {\n\t\tcase ConnTypeTCP:\n\t\t\tc.lAddr = &net.TCPAddr{\n\t\t\t\tIP:   []byte{vt.Addr[0], vt.Addr[1], vt.Addr[2], vt.Addr[3]},\n\t\t\t\tPort: vt.Port,\n\t\t\t}\n\t\tcase ConnTypeUDPClientFromDial:\n\t\t\tc.lAddr = &net.TCPAddr{\n\t\t\t\tIP:   []byte{vt.Addr[0], vt.Addr[1], vt.Addr[2], vt.Addr[3]},\n\t\t\t\tPort: vt.Port,\n\t\t\t}\n\t\t\tc.connUDP = &udpConn{\n\t\t\t\tparent: c,\n\t\t\t}\n\t\t}\n\tcase *syscall.SockaddrInet6:\n\t\tvar iface *net.Interface\n\t\tiface, err = net.InterfaceByIndex(int(vt.ZoneId))\n\t\tif err != nil {\n\t\t\tsyscall.Close(fd)\n\t\t\treturn err\n\t\t}\n\t\tswitch connType {\n\t\tcase ConnTypeTCP:\n\t\t\tc.lAddr = &net.TCPAddr{\n\t\t\t\tIP:   make([]byte, len(vt.Addr)),\n\t\t\t\tPort: vt.Port,\n\t\t\t\tZone: iface.Name,\n\t\t\t}\n\t\tcase ConnTypeUDPClientFromDial:\n\t\t\tc.lAddr = &net.UDPAddr{\n\t\t\t\tIP:   make([]byte, len(vt.Addr)),\n\t\t\t\tPort: vt.Port,\n\t\t\t\tZone: iface.Name,\n\t\t\t}\n\t\t\tc.connUDP = &udpConn{\n\t\t\t\tparent: c,\n\t\t\t}\n\t\t}\n\tcase *syscall.SockaddrUnix:\n\t\tc.lAddr = &net.UnixAddr{\n\t\t\tNet:  network,\n\t\t\tName: vt.Name,\n\t\t}\n\t}\n\n\tengine.wgConn.Add(1)\n\t_, err = engine.addDialer(c)\n\tif err != nil {\n\t\tengine.wgConn.Done()\n\t\treturn err\n\t}\n\n\tif !inprogress {\n\t\tengine.Async(func() {\n\t\t\th(c, nil)\n\t\t})\n\t} else if timeout > 0 {\n\t\tc.setDeadline(&c.wTimer, ErrDialTimeout, time.Now().Add(timeout))\n\t}\n\n\treturn nil\n}\n\n// NewEngine creates an Engine and init default configurations.\n//\n//go:norace\nfunc NewEngine(conf Config) *Engine {\n\tif conf.Name == \"\" {\n\t\tconf.Name = \"NB\"\n\t}\n\tif conf.NPoller <= 0 {\n\t\tconf.NPoller = runtime.NumCPU() / 4\n\t\tif conf.AsyncReadInPoller && conf.EpollMod == EPOLLET {\n\t\t\tconf.NPoller = 1\n\t\t}\n\t\tif conf.NPoller == 0 {\n\t\t\tconf.NPoller = 1\n\t\t}\n\t}\n\tif conf.ReadBufferSize <= 0 {\n\t\tconf.ReadBufferSize = DefaultReadBufferSize\n\t}\n\tif conf.MaxWriteBufferSize <= 0 {\n\t\tconf.MaxWriteBufferSize = DefaultMaxWriteBufferSize\n\t}\n\tif conf.MaxConnReadTimesPerEventLoop <= 0 {\n\t\tconf.MaxConnReadTimesPerEventLoop = DefaultMaxConnReadTimesPerEventLoop\n\t}\n\tif conf.Listen == nil {\n\t\tconf.Listen = net.Listen\n\t}\n\tif conf.ListenUDP == nil {\n\t\tconf.ListenUDP = net.ListenUDP\n\t}\n\tif conf.BodyAllocator == nil {\n\t\tconf.BodyAllocator = mempool.DefaultMemPool\n\t}\n\n\tg := &Engine{\n\t\tConfig: conf,\n\t\tTimer:  timer.New(conf.Name),\n\t}\n\n\tg.initHandlers()\n\n\treturn g\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 0.5205078125,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage nbio\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\tErrReadTimeout = errors.New(\"read timeout\")\n\terrReadTimeout = ErrReadTimeout\n\n\tErrWriteTimeout = errors.New(\"write timeout\")\n\terrWriteTimeout = ErrWriteTimeout\n\n\tErrOverflow = errors.New(\"write overflow\")\n\terrOverflow = ErrOverflow\n\n\tErrDialTimeout = errors.New(\"dial timeout\")\n\n\tErrUnsupported = errors.New(\"unsupported operation\")\n)\n"
        },
        {
          "name": "extension",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.080078125,
          "content": "module github.com/lesismal/nbio\n\ngo 1.16\n\nrequire github.com/lesismal/llib v1.2.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.2548828125,
          "content": "github.com/lesismal/llib v1.2.0 h1:76mtWL87Y2XTYSoBXNFMBmUZY6igHbQZW48c0gx32Hc=\ngithub.com/lesismal/llib v1.2.0/go.mod h1:70tFXXe7P1FZ02AU9l8LgSOK7d7sRrpnkUr3rd3gKSg=\ngolang.org/x/crypto v0.0.0-20210513122933-cd7d49e622d5 h1:N6Jp/LCiEoIBX56BZSR2bepK5GtbSC2DDOYT742mMfE=\ngolang.org/x/crypto v0.0.0-20210513122933-cd7d49e622d5/go.mod h1:P+XmwS30IXTQdn5tA2iutPOUgjI07+tq3H3K9MVA1s8=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210510120150-4163338589ed/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da h1:b3NXsE2LusjYGGjL5bxEVZZORm/YEFFrWFjR8eFrw/c=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\n"
        },
        {
          "name": "lmux",
          "type": "tree",
          "content": null
        },
        {
          "name": "logging",
          "type": "tree",
          "content": null
        },
        {
          "name": "mempool",
          "type": "tree",
          "content": null
        },
        {
          "name": "nbhttp",
          "type": "tree",
          "content": null
        },
        {
          "name": "nbio_test.go",
          "type": "blob",
          "size": 13.02734375,
          "content": "package nbio\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar addr = \"127.0.0.1:9999\"\nvar testfile = \"test_tmp.file\"\nvar engine *Engine\nvar testFileSize = 1024 * 1024 * 32\n\nconst osWindows = \"windows\"\n\nfunc init() {\n\tif err := os.WriteFile(testfile, make([]byte, testFileSize), 0600); err != nil {\n\t\tlog.Panicf(\"write file failed: %v\", err)\n\t}\n\n\taddrs := []string{addr}\n\tg := NewEngine(Config{\n\t\tNetwork: \"tcp\",\n\t\tAddrs:   addrs,\n\t})\n\n\ttype writtenSizeSession struct {\n\t\tsumRecv int\n\t\tsumSend int\n\t\tisFile  bool\n\t}\n\tg.OnOpen(func(c *Conn) {\n\t\twsess := &writtenSizeSession{}\n\t\tc.SetSession(wsess)\n\t\tc.SetReadDeadline(time.Now().Add(time.Second * 10))\n\t})\n\tg.OnData(func(c *Conn, data []byte) {\n\t\tvar wsess *writtenSizeSession\n\t\tif session := c.Session(); session == nil {\n\t\t\tpanic(\"invalid session nil\")\n\t\t} else {\n\t\t\twsess = session.(*writtenSizeSession)\n\t\t\twsess.sumRecv += len(data)\n\t\t}\n\n\t\tif len(data) == 8 && string(data) == \"sendfile\" {\n\t\t\twsess.isFile = true\n\t\t\tfile, err := os.Open(testfile)\n\t\t\tif err != nil {\n\t\t\t\tlog.Panicf(\"open file failed: %v\", err)\n\t\t\t}\n\n\t\t\tif _, err = c.Sendfile(file, 0); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tif err := file.Close(); err != nil {\n\t\t\t\tlog.Panicf(\"close file failed: %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tc.Write(append([]byte{}, data...))\n\t\t}\n\t})\n\n\tg.OnWrittenSize(func(c *Conn, b []byte, n int) {\n\t\tif session := c.Session(); session == nil {\n\t\t\tpanic(\"invalid session nil\")\n\t\t} else {\n\t\t\twsess := session.(*writtenSizeSession)\n\t\t\twsess.sumSend += n\n\t\t}\n\t})\n\tg.OnClose(func(c *Conn, err error) {\n\t\tsession := c.Session()\n\t\tif session == nil {\n\t\t\tpanic(\"invalid session nil\")\n\t\t}\n\t\twsess := session.(*writtenSizeSession)\n\t\tif wsess.isFile {\n\t\t\tif wsess.sumSend != testFileSize {\n\t\t\t\tpanic(fmt.Errorf(\"invalid send size for sendfile: %v, %v\", wsess.sumSend, testFileSize))\n\t\t\t}\n\t\t} else {\n\t\t\tif wsess.sumSend != wsess.sumRecv {\n\t\t\t\tpanic(\"invalid send size: not equal to recv size\")\n\t\t\t}\n\t\t}\n\t})\n\n\terr := g.Start()\n\tif err != nil {\n\t\tlog.Panicf(\"Start failed: %v\\n\", err)\n\t}\n\n\tengine = g\n}\n\nfunc TestEcho(t *testing.T) {\n\tvar done = make(chan int)\n\tvar clientNum = 2\n\tvar msgSize = 1024\n\tvar total int64 = 0\n\n\tg := NewEngine(Config{})\n\terr := g.Start()\n\tif err != nil {\n\t\tlog.Panicf(\"Start failed: %v\\n\", err)\n\t}\n\tdefer g.Stop()\n\n\tg.OnOpen(func(c *Conn) {\n\t\tc.SetSession(1)\n\t\tif c.Session() != 1 {\n\t\t\tlog.Panicf(\"invalid session: %v\", c.Session())\n\t\t}\n\t\tc.SetLinger(1, 0)\n\t\tc.SetNoDelay(true)\n\t\tc.SetKeepAlive(true)\n\t\tc.SetKeepAlivePeriod(time.Second * 60)\n\t\tc.SetDeadline(time.Now().Add(time.Second * 10))\n\t\tc.SetReadBuffer(1024 * 4)\n\t\tc.SetWriteBuffer(1024 * 4)\n\t\tlog.Printf(\"connected, local addr: %v, remote addr: %v\", c.LocalAddr(), c.RemoteAddr())\n\t})\n\t// g.BeforeWrite(func(c *Conn) {\n\t// \tc.SetWriteDeadline(time.Now().Add(time.Second * 5))\n\t// })\n\tg.OnData(func(c *Conn, data []byte) {\n\t\trecved := atomic.AddInt64(&total, int64(len(data)))\n\t\tif len(data) > 0 && recved >= int64(clientNum*msgSize) {\n\t\t\tclose(done)\n\t\t}\n\t})\n\n\tg.OnReadBufferAlloc(func(c *Conn) []byte {\n\t\treturn make([]byte, 1024)\n\t})\n\tg.OnReadBufferFree(func(c *Conn, b []byte) {\n\n\t})\n\n\tone := func(n int) {\n\t\tc, err := Dial(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\tlog.Panicf(\"Dial failed: %v\", err)\n\t\t}\n\t\tg.AddConn(c)\n\t\tif n%2 == 0 {\n\t\t\tc.Writev([][]byte{make([]byte, msgSize)})\n\t\t} else {\n\t\t\tc.Write(make([]byte, msgSize))\n\t\t}\n\t}\n\n\tfor i := 0; i < clientNum; i++ {\n\t\tif runtime.GOOS != osWindows {\n\t\t\tone(i)\n\t\t} else {\n\t\t\tgo one(i)\n\t\t}\n\t}\n\n\t<-done\n}\n\nfunc TestSendfile(t *testing.T) {\n\tconn, err := net.Dial(\"tcp\", addr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbuf := make([]byte, testFileSize)\n\n\tfor i := 0; i < 3; i++ {\n\t\tif _, err := conn.Write([]byte(\"sendfile\")); err != nil {\n\t\t\tlog.Panicf(\"write 'sendfile' failed: %v\", err)\n\t\t}\n\n\t\tn, err := io.ReadFull(conn, buf)\n\t\tif err != nil {\n\t\t\tlog.Panicf(\"read file failed: %v\", err)\n\t\t}\n\t\tif n != testFileSize {\n\t\t\tlog.Panicf(\"read wrong file size: %v != %v\", n, testFileSize)\n\t\t}\n\t}\n}\n\nfunc TestTimeout(t *testing.T) {\n\tg := NewEngine(Config{})\n\terr := g.Start()\n\tif err != nil {\n\t\tlog.Panicf(\"Start failed: %v\\n\", err)\n\t}\n\tdefer g.Stop()\n\n\tvar done = make(chan int)\n\tvar begin time.Time\n\tvar timeout = time.Second\n\tg.OnOpen(func(c *Conn) {\n\t\tc.IsTCP()\n\t\tc.IsUDP()\n\t\tc.IsUnix()\n\t\tbegin = time.Now()\n\t\tc.SetReadDeadline(begin.Add(timeout))\n\t})\n\tg.OnClose(func(c *Conn, err error) {\n\t\tto := time.Since(begin)\n\t\tif to > timeout*2 {\n\t\t\tlog.Panicf(\"timeout: %v, want: %v\", to, timeout)\n\t\t}\n\t\tclose(done)\n\t})\n\n\tone := func() {\n\t\tc, err := DialTimeout(\"tcp\", addr, time.Second)\n\t\tif err != nil {\n\t\t\tlog.Panicf(\"Dial failed: %v\", err)\n\t\t}\n\t\tg.AddConn(c)\n\t}\n\tone()\n\n\t<-done\n}\n\nfunc TestFuzz(t *testing.T) {\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\t\tgo func(idx int) {\n\t\t\tdefer wg.Done()\n\t\t\tif idx%2 == 0 {\n\t\t\t\tDial(\"tcp4\", addr)\n\t\t\t} else {\n\t\t\t\tDial(\"tcp4\", addr)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\treaded := 0\n\twg2 := sync.WaitGroup{}\n\twg2.Add(1)\n\tg := NewEngine(Config{NPoller: 1})\n\tg.OnData(func(c *Conn, data []byte) {\n\t\treaded += len(data)\n\t\tif readed == 4 {\n\t\t\twg2.Done()\n\t\t}\n\t})\n\terr := g.Start()\n\tif err != nil {\n\t\tlog.Panicf(\"Start failed: %v\", err)\n\t}\n\n\tc, err := Dial(\"tcp\", addr)\n\tif err == nil {\n\t\tlog.Printf(\"Dial tcp4: %v, %v, %v\", c.LocalAddr(), c.RemoteAddr(), err)\n\t\tg.AddConn(c)\n\t\tc.SetWriteDeadline(time.Now().Add(time.Second))\n\t\tc.Write([]byte{1})\n\n\t\ttime.Sleep(time.Second / 10)\n\n\t\tbs := [][]byte{}\n\t\tbs = append(bs, []byte{2})\n\t\tbs = append(bs, []byte{3})\n\t\tbs = append(bs, []byte{4})\n\t\tc.Writev(bs)\n\n\t\ttime.Sleep(time.Second / 10)\n\n\t\tc.Close()\n\t\tc.Write([]byte{1})\n\t} else {\n\t\tlog.Panicf(\"Dial tcp4: %v\", err)\n\t}\n\n\tgErr := NewEngine(Config{\n\t\tNetwork: \"tcp4\",\n\t\tAddrs:   []string{\"127.0.0.1:8889\", \"127.0.0.1:8889\"},\n\t})\n\tgErr.Start()\n}\n\nfunc TestUDP(t *testing.T) {\n\tg := NewEngine(Config{})\n\ttimeout := time.Second / 5\n\tchTimeout := make(chan *Conn, 1)\n\tg.OnOpen(func(c *Conn) {\n\t\tlog.Printf(\"onOpen: %v, %v\", c.LocalAddr().String(), c.RemoteAddr().String())\n\t\tc.SetReadDeadline(time.Now().Add(timeout))\n\t})\n\tg.OnData(func(c *Conn, data []byte) {\n\t\tlog.Println(\"onData:\", c.LocalAddr().String(), c.RemoteAddr().String(), string(data))\n\t\t_, err := c.Write(data)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n\tg.OnClose(func(c *Conn, err error) {\n\t\tlog.Println(\"onClose:\", c.RemoteAddr().String(), err)\n\t\tselect {\n\t\tcase chTimeout <- c:\n\t\tdefault:\n\t\t}\n\t})\n\n\terr := g.Start()\n\tif err != nil {\n\t\tt.Fatalf(\"Start failed: %v\", err)\n\t}\n\tdefer g.Stop()\n\n\taddrstr := fmt.Sprintf(\"127.0.0.1:%d\", 9999)\n\taddr, err := net.ResolveUDPAddr(\"udp\", addrstr)\n\tif err != nil {\n\t\tt.Fatalf(\"ResolveUDPAddr error: %v\", err)\n\t}\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tt.Fatalf(\"listen error: %v\", err)\n\t}\n\n\tlisConn, _ := g.AddConn(conn)\n\n\tnewClientConn := func() *net.UDPConn {\n\t\tconnUDP, errDial := net.DialUDP(\"udp4\", nil, &net.UDPAddr{\n\t\t\tIP:   net.IPv4(127, 0, 0, 1),\n\t\t\tPort: 9999,\n\t\t})\n\t\tif errDial != nil {\n\t\t\tt.Fatalf(\"net.DialUDP failed: %v\", err)\n\t\t}\n\t\treturn connUDP\n\t}\n\n\tconnTimeout := newClientConn()\n\tn, err := connTimeout.Write([]byte(\"test timeout\"))\n\tif err != nil {\n\t\tlog.Fatalf(\"write udp failed: %v, %v\", n, err)\n\t}\n\tdefer connTimeout.Close()\n\tbegin := time.Now()\n\tselect {\n\tcase c := <-chTimeout:\n\t\tif c.RemoteAddr().String() != connTimeout.LocalAddr().String() {\n\t\t\tlog.Fatalf(\"invalid udp conn\")\n\t\t}\n\t\tused := time.Since(begin)\n\t\tif used < timeout {\n\t\t\tlog.Fatalf(\"test timeout failed: %v < %v\", used.Seconds(), timeout.Seconds())\n\t\t}\n\t\tlog.Printf(\"test udp conn timeout success\")\n\tcase <-time.After(timeout + time.Second):\n\t\tlog.Fatalf(\"timeout\")\n\t}\n\n\tclientNum := 2\n\tmsgPerClient := 2\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < clientNum; i++ {\n\t\twg.Add(1)\n\t\tgo func(idx int) {\n\t\t\tdefer wg.Done()\n\t\t\tconn := newClientConn()\n\t\t\tdefer conn.Close()\n\t\t\tfor j := 0; j < msgPerClient; j++ {\n\t\t\t\tstr := fmt.Sprintf(\"message-%d\", clientNum*idx+j)\n\t\t\t\twbuf := []byte(str)\n\t\t\t\trbuf := make([]byte, 1024)\n\t\t\t\tif _, werr := conn.Write(wbuf); werr == nil {\n\t\t\t\t\tlog.Printf(\"send msg success: %v, %s\", conn.LocalAddr().String(), str)\n\t\t\t\t\tif packLen, _, rerr := conn.ReadFromUDP(rbuf); rerr == nil {\n\t\t\t\t\t\tif str != string(wbuf[:packLen]) {\n\t\t\t\t\t\t\tlog.Fatalf(\"recv msg not equal: %v, [%v != %v]\", conn.LocalAddr().String(), str, string(rbuf[:packLen]))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlog.Printf(\"recv msg success: %v, %s\", conn.LocalAddr().String(), str)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.Printf(\"recv msg failed: %v, %v\", conn.LocalAddr().String(), rerr)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlog.Println(\"send msg failed:\", werr)\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\twg.Wait()\n\n\tvar done = make(chan int)\n\tvar cntFromServer int32\n\tvar fromClientStr = \"from client\"\n\tvar fromServerStr = \"from server\"\n\tg.OnOpen(func(c *Conn) {\n\t\tc.IsTCP()\n\t\tc.IsUDP()\n\t\tc.IsUnix()\n\t\tlog.Println(\"onOpen:\", c.LocalAddr().String(), c.RemoteAddr().String())\n\t\tc.SetReadDeadline(time.Now().Add(timeout))\n\t})\n\tg.OnData(func(c *Conn, data []byte) {\n\t\tlog.Println(\"OnData:\", c.LocalAddr().String(), c.RemoteAddr().String(), string(data))\n\t\tif string(data) == fromClientStr {\n\t\t\tc.Write([]byte(fromServerStr))\n\t\t} else {\n\t\t\tif atomic.AddInt32(&cntFromServer, 1) == 3 {\n\t\t\t\tc.Close()\n\t\t\t} else {\n\t\t\t\tc.Write([]byte(fromClientStr))\n\t\t\t}\n\t\t}\n\t})\n\tclientConn := newClientConn()\n\tnbc, err := g.AddConn(clientConn)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tg.OnClose(func(c *Conn, err error) {\n\t\tlog.Println(\"onClose:\", c.LocalAddr().String(), c.RemoteAddr().String(), err)\n\t\tif nbc == c {\n\t\t\tclose(done)\n\t\t}\n\t})\n\tnbc.Write([]byte(fromClientStr))\n\t<-done\n\tlisConn.Close()\n\ttime.Sleep(timeout * 2)\n}\n\nfunc TestDialAsyncTCP(t *testing.T) {\n\tnetwork := \"tcp\"\n\taddr := \"127.0.0.1:10001\"\n\ttestDialAsync(t, network, addr)\n}\n\nfunc TestDialAsyncUDP(t *testing.T) {\n\tnetwork := \"udp\"\n\taddr := \"127.0.0.1:10001\"\n\ttestDialAsync(t, network, addr)\n}\n\nfunc TestDialAsyncUnix(t *testing.T) {\n\tif runtime.GOOS == osWindows {\n\t\treturn\n\t}\n\tnetwork := \"unix\"\n\taddr := \"unix.server\"\n\ttestDialAsync(t, network, addr)\n}\n\nfunc testDialAsync(t *testing.T, network, addr string) {\n\tdone := make(chan error, 1)\n\tengineAsync := NewEngine(Config{\n\t\tName:    \"udp-testing\",\n\t\tNetwork: network,\n\t\tAddrs:   []string{addr},\n\t\tNPoller: 1,\n\t})\n\tengineAsync.OnOpen(func(c *Conn) {\n\t\tlog.Printf(\"TestDialAsync[%v, %v] OnOpen: %v, %v\", network, addr, c.LocalAddr().String(), c.RemoteAddr().String())\n\t})\n\tcnt := 0\n\tengineAsync.OnData(func(c *Conn, data []byte) {\n\t\tcnt++\n\t\tif cnt == 1 {\n\t\t\tc.Write(data)\n\t\t\tlog.Printf(\"TestDialAsync[%v, %v] Server OnData: %v, %v, %v\", network, addr, c.LocalAddr().String(), c.RemoteAddr().String(), string(data))\n\t\t} else {\n\t\t\tlog.Printf(\"TestDialAsync[%v, %v] Client OnData: %v, %v, %v\", network, addr, c.LocalAddr().String(), c.RemoteAddr().String(), string(data))\n\t\t\tclose(done)\n\t\t}\n\t})\n\tengineAsync.OnClose(func(c *Conn, err error) {\n\t\tlog.Printf(\"TestDialAsync[%v, %v] OnClose: %v, %v\", network, addr, c.LocalAddr().String(), c.RemoteAddr().String())\n\t})\n\terr := engineAsync.Start()\n\tif err != nil {\n\t\tt.Fatalf(\"engineAsync  start failed: %v\", err)\n\t}\n\tdefer engineAsync.Stop()\n\n\tonConnected := func(c *Conn, err error) {\n\t\tlog.Printf(\"TestTestDialAsync[%v, %v] OnConnected: %v, %v, %v\", network, addr, c.LocalAddr().String(), c.RemoteAddr().String(), err)\n\t\tif err == nil {\n\t\t\tvar n int\n\t\t\tn, err = c.Write([]byte(\"hello\"))\n\t\t\tif err != nil {\n\t\t\t\tdone <- err\n\t\t\t}\n\t\t\tlog.Printf(\"TestTestDialAsync[%v, %v] OnConnected Write n: %v\", network, addr, n)\n\t\t} else {\n\t\t\tdone <- err\n\t\t}\n\t}\n\n\ttime.Sleep(time.Second / 10)\n\terr = engineAsync.DialAsyncTimeout(network, addr, time.Second*10, onConnected)\n\tif err != nil {\n\t\tt.Fatalf(\"TestTestDialAsync[%v, %v] DialAsyncTimeout failed: %v\", network, addr, err)\n\t}\n\terr = <-done\n\tif err != nil {\n\t\tt.Fatalf(\"TestTestDialAsync[%v, %v] DialAsyncTimeout failed: %v\", network, addr, err)\n\t}\n}\n\nfunc TestUnix(t *testing.T) {\n\tif runtime.GOOS == osWindows {\n\t\treturn\n\t}\n\n\tunixAddr := \"./test.unix\"\n\tdefer os.Remove(unixAddr)\n\tg := NewEngine(Config{\n\t\tNetwork: \"unix\",\n\t\tAddrs:   []string{unixAddr},\n\t})\n\tvar connSvr *Conn\n\tvar connCli *Conn\n\tg.OnOpen(func(c *Conn) {\n\t\tif connSvr == nil {\n\t\t\tconnSvr = c\n\t\t}\n\t\tc.Type()\n\t\tc.IsTCP()\n\t\tc.IsUDP()\n\t\tc.IsUnix()\n\t\tlog.Printf(\"unix onOpen: %v, %v\", c.LocalAddr().String(), c.RemoteAddr().String())\n\t})\n\tg.OnData(func(c *Conn, data []byte) {\n\t\tlog.Println(\"unix onData:\", c.LocalAddr().String(), c.RemoteAddr().String(), string(data))\n\t\tif c == connSvr {\n\t\t\t_, err := c.Write([]byte(\"world\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\tif c == connCli && string(data) == \"world\" {\n\t\t\tc.Close()\n\t\t}\n\t})\n\tchClose := make(chan *Conn, 2)\n\tg.OnClose(func(c *Conn, err error) {\n\t\tlog.Println(\"unix onClose:\", c.LocalAddr().String(), c.RemoteAddr().String(), err)\n\t\tchClose <- c\n\t})\n\n\terr := g.Start()\n\tif err != nil {\n\t\tt.Fatalf(\"Start failed: %v\", err)\n\t}\n\tdefer g.Stop()\n\n\tc, err := net.Dial(\"unix\", unixAddr)\n\tif err != nil {\n\t\tt.Fatalf(\"unix Dial: %v, %v, %v\", c.LocalAddr(), c.RemoteAddr(), err)\n\t}\n\tdefer c.Close()\n\ttime.Sleep(time.Second / 10)\n\tbuf := []byte(\"hello\")\n\tconnCli, err = g.AddConn(c)\n\tif err != nil {\n\t\tt.Fatalf(\"unix AddConn: %v, %v, %v\", c.LocalAddr(), c.RemoteAddr(), err)\n\t}\n\t_, err = connCli.Write(buf)\n\tif err != nil {\n\t\tt.Fatalf(\"unix Write: %v, %v, %v\", c.LocalAddr(), c.RemoteAddr(), err)\n\t}\n\t<-chClose\n\t<-chClose\n}\n\nfunc TestStop(t *testing.T) {\n\tengine.Stop()\n\tos.Remove(testfile)\n}\n"
        },
        {
          "name": "net_unix.go",
          "type": "blob",
          "size": 3.8896484375,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build linux || darwin || netbsd || freebsd || openbsd || dragonfly\n// +build linux darwin netbsd freebsd openbsd dragonfly\n\npackage nbio\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"strings\"\n\t\"syscall\"\n)\n\n//go:norace\nfunc init() {\n\tvar limit syscall.Rlimit\n\tif err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &limit); err == nil {\n\t\tif n := int(limit.Max); n > 0 && n < MaxOpenFiles {\n\t\t\tMaxOpenFiles = n\n\t\t}\n\t}\n}\n\n//go:norace\nfunc dupStdConn(conn net.Conn) (*Conn, error) {\n\tsc, ok := conn.(interface {\n\t\tSyscallConn() (syscall.RawConn, error)\n\t})\n\tif !ok {\n\t\treturn nil, errors.New(\"RawConn Unsupported\")\n\t}\n\trc, err := sc.SyscallConn()\n\tif err != nil {\n\t\treturn nil, errors.New(\"RawConn Unsupported\")\n\t}\n\n\tvar newFd int\n\terrCtrl := rc.Control(func(fd uintptr) {\n\t\tnewFd, err = syscall.Dup(int(fd))\n\t})\n\n\tif errCtrl != nil {\n\t\treturn nil, errCtrl\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlAddr := conn.LocalAddr()\n\trAddr := conn.RemoteAddr()\n\n\tconn.Close()\n\n\t// err = syscall.SetNonblock(newFd, true)\n\t// if err != nil {\n\t// \tsyscall.Close(newFd)\n\t// \treturn nil, err\n\t// }\n\n\tc := &Conn{\n\t\tfd:    newFd,\n\t\tlAddr: lAddr,\n\t\trAddr: rAddr,\n\t}\n\n\tswitch conn.(type) {\n\tcase *net.TCPConn:\n\t\tc.typ = ConnTypeTCP\n\tcase *net.UnixConn:\n\t\tc.typ = ConnTypeUnix\n\tcase *net.UDPConn:\n\t\tlAddrUDP := lAddr.(*net.UDPAddr)\n\t\tnewLAddr := net.UDPAddr{\n\t\t\tIP:   make([]byte, len(lAddrUDP.IP)),\n\t\t\tPort: lAddrUDP.Port,\n\t\t\tZone: lAddrUDP.Zone,\n\t\t}\n\n\t\tcopy(newLAddr.IP, lAddrUDP.IP)\n\n\t\tc.lAddr = &newLAddr\n\n\t\t// no remote addr, this is a listener\n\t\tif rAddr == nil {\n\t\t\tc.typ = ConnTypeUDPServer\n\t\t\tc.connUDP = &udpConn{\n\t\t\t\tparent: c,\n\t\t\t\tconns:  map[udpAddrKey]*Conn{},\n\t\t\t}\n\t\t} else {\n\t\t\t// has remote addr, this is a dialer\n\t\t\tc.typ = ConnTypeUDPClientFromDial\n\t\t\tc.connUDP = &udpConn{\n\t\t\t\tparent: c,\n\t\t\t}\n\t\t}\n\tdefault:\n\t}\n\n\treturn c, nil\n}\n\n//go:norace\nfunc parseDomainAndType(network, addr string) (int, int, syscall.Sockaddr, net.Addr, ConnType, error) {\n\tvar (\n\t\tisIPv4 = len(strings.Split(addr, \":\")) == 2\n\t)\n\n\tsocketResult := func(sockType int, connType ConnType) (int, int, syscall.Sockaddr, net.Addr, ConnType, error) {\n\t\tvar (\n\t\t\tip      net.IP\n\t\t\tport    int\n\t\t\tzone    string\n\t\t\tretAddr net.Addr\n\t\t)\n\t\tif connType == ConnTypeTCP {\n\t\t\tdstAddr, err := net.ResolveTCPAddr(network, addr)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, 0, nil, nil, 0, err\n\t\t\t}\n\t\t\tip, port, zone, retAddr = dstAddr.IP, dstAddr.Port, dstAddr.Zone, dstAddr\n\t\t} else {\n\t\t\tdstAddr, err := net.ResolveUDPAddr(network, addr)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, 0, nil, nil, 0, err\n\t\t\t}\n\t\t\tip, port, zone, retAddr = dstAddr.IP, dstAddr.Port, dstAddr.Zone, dstAddr\n\t\t}\n\n\t\tif isIPv4 {\n\t\t\treturn syscall.AF_INET, sockType, &syscall.SockaddrInet4{\n\t\t\t\tAddr: [4]byte{ip[0], ip[1], ip[2], ip[3]},\n\t\t\t\tPort: port,\n\t\t\t}, retAddr, connType, nil\n\t\t}\n\n\t\tiface, err := net.InterfaceByName(zone)\n\t\tif err != nil {\n\t\t\treturn 0, 0, nil, nil, 0, err\n\t\t}\n\t\taddr6 := &syscall.SockaddrInet6{\n\t\t\tPort:   port,\n\t\t\tZoneId: uint32(iface.Index),\n\t\t}\n\t\tcopy(addr6.Addr[:], ip)\n\t\treturn syscall.AF_INET6, sockType, addr6, retAddr, connType, nil\n\t}\n\n\tswitch network {\n\tcase NETWORK_TCP, NETWORK_TCP4, NETWORK_TCP6:\n\t\treturn socketResult(syscall.SOCK_STREAM, ConnTypeTCP)\n\tcase NETWORK_UDP, NETWORK_UDP4, NETWORK_UDP6:\n\t\treturn socketResult(syscall.SOCK_DGRAM, ConnTypeUDPClientFromDial)\n\tcase NETWORK_UNIX, NETWORK_UNIXGRAM, NETWORK_UNIXPACKET:\n\t\tsotype := syscall.SOCK_STREAM\n\t\tswitch network {\n\t\tcase NETWORK_UNIX:\n\t\t\tsotype = syscall.SOCK_STREAM\n\t\tcase NETWORK_UNIXGRAM:\n\t\t\tsotype = syscall.SOCK_DGRAM\n\t\tcase NETWORK_UNIXPACKET:\n\t\t\tsotype = syscall.SOCK_SEQPACKET\n\t\tdefault:\n\t\t}\n\t\tdstAddr := &net.UnixAddr{\n\t\t\tNet:  network,\n\t\t\tName: addr,\n\t\t}\n\t\treturn syscall.AF_UNIX, sotype, &syscall.SockaddrUnix{Name: addr}, dstAddr, ConnTypeUnix, nil\n\tdefault:\n\t}\n\treturn 0, 0, nil, nil, 0, net.UnknownNetworkError(network)\n}\n"
        },
        {
          "name": "poller_epoll.go",
          "type": "blob",
          "size": 9.697265625,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build linux\n// +build linux\n\npackage nbio\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/lesismal/nbio/logging\"\n)\n\nconst (\n\t// EPOLLLT .\n\tEPOLLLT = 0\n\n\t// EPOLLET .\n\tEPOLLET = 0x80000000\n\n\t// EPOLLONESHOT .\n\tEPOLLONESHOT = syscall.EPOLLONESHOT\n)\n\nconst (\n\tepollEventsRead  = syscall.EPOLLPRI | syscall.EPOLLIN\n\tepollEventsWrite = syscall.EPOLLOUT\n\tepollEventsError = syscall.EPOLLERR | syscall.EPOLLHUP | syscall.EPOLLRDHUP\n)\n\nconst (\n\tIPPROTO_TCP   = syscall.IPPROTO_TCP\n\tTCP_KEEPINTVL = syscall.TCP_KEEPINTVL\n\tTCP_KEEPIDLE  = syscall.TCP_KEEPIDLE\n)\n\ntype poller struct {\n\tg *Engine // parent engine\n\n\tepfd  int // epoll fd\n\tevtfd int // event fd for trigger\n\n\tindex int // poller index in engine\n\n\tpollType string // listener or io poller\n\n\tshutdown bool // state\n\n\t// whether poller is used for listener.\n\tisListener bool\n\t// listener.\n\tlistener net.Listener\n\t// if poller is used as UnixConn listener,\n\t// store the addr and remove it when exit.\n\tunixSockAddr string\n\n\tReadBuffer []byte // default reading buffer\n}\n\n// add the connection to poller and handle its io events.\n//\n//go:norace\nfunc (p *poller) addConn(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix),\n\t\t)\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onOpen(c)\n\t} else {\n\t\tp.g.onUDPListen(c)\n\t}\n\tp.g.connsUnix[fd] = c\n\terr := p.addRead(fd)\n\tif err != nil {\n\t\tp.g.connsUnix[fd] = nil\n\t\tc.closeWithError(err)\n\t}\n\treturn err\n}\n\n// add the connection to poller and handle its io events.\n//\n//go:norace\nfunc (p *poller) addDialer(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix),\n\t\t)\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tp.g.connsUnix[fd] = c\n\tc.isWAdded = true\n\terr := p.addReadWrite(fd)\n\tif err != nil {\n\t\tp.g.connsUnix[fd] = nil\n\t\tc.closeWithError(err)\n\t}\n\treturn err\n}\n\n//go:norace\nfunc (p *poller) getConn(fd int) *Conn {\n\treturn p.g.connsUnix[fd]\n}\n\n//go:norace\nfunc (p *poller) deleteConn(c *Conn) {\n\tif c == nil {\n\t\treturn\n\t}\n\tfd := c.fd\n\n\tif c.typ != ConnTypeUDPClientFromRead {\n\t\tif c == p.g.connsUnix[fd] {\n\t\t\tp.g.connsUnix[fd] = nil\n\t\t}\n\t\t// p.deleteEvent(fd)\n\t}\n\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onClose(c, c.closeErr)\n\t}\n}\n\n//go:norace\nfunc (p *poller) start() {\n\tdefer p.g.Done()\n\n\tlogging.Debug(\"NBIO[%v][%v_%v] start\", p.g.Name, p.pollType, p.index)\n\tdefer logging.Debug(\"NBIO[%v][%v_%v] stopped\", p.g.Name, p.pollType, p.index)\n\n\tif p.isListener {\n\t\tp.acceptorLoop()\n\t} else {\n\t\tdefer func() {\n\t\t\tsyscall.Close(p.epfd)\n\t\t\tsyscall.Close(p.evtfd)\n\t\t}()\n\t\tp.readWriteLoop()\n\t}\n}\n\n//go:norace\nfunc (p *poller) acceptorLoop() {\n\tif p.g.LockListener {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tconn, err := p.listener.Accept()\n\t\tif err == nil {\n\t\t\tvar c *Conn\n\t\t\tc, err = NBConn(conn)\n\t\t\tif err != nil {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr = p.g.pollers[c.Hash()%len(p.g.pollers)].addConn(c)\n\t\t\tif err != nil {\n\t\t\t\tlogging.Error(\"NBIO[%v][%v_%v] addConn [fd: %v] failed: %v\",\n\t\t\t\t\tp.g.Name,\n\t\t\t\t\tp.pollType,\n\t\t\t\t\tp.index,\n\t\t\t\t\tc.fd,\n\t\t\t\t\terr,\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tvar ne net.Error\n\t\t\tif ok := errors.As(err, &ne); ok && ne.Timeout() {\n\t\t\t\tlogging.Error(\"NBIO[%v][%v_%v] Accept failed: timeout error, retrying...\",\n\t\t\t\t\tp.g.Name,\n\t\t\t\t\tp.pollType,\n\t\t\t\t\tp.index,\n\t\t\t\t)\n\t\t\t\ttime.Sleep(time.Second / 20)\n\t\t\t} else {\n\t\t\t\tif !p.shutdown {\n\t\t\t\t\tlogging.Error(\"NBIO[%v][%v_%v] Accept failed: %v, exit...\",\n\t\t\t\t\t\tp.g.Name,\n\t\t\t\t\t\tp.pollType,\n\t\t\t\t\t\tp.index,\n\t\t\t\t\t\terr,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\n//go:norace\nfunc (p *poller) readWriteLoop() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tmsec := -1\n\tevents := make([]syscall.EpollEvent, 1024)\n\n\tif p.g.onRead == nil && p.g.EpollMod == EPOLLET {\n\t\tp.g.MaxConnReadTimesPerEventLoop = 1<<31 - 1\n\t}\n\n\tg := p.g\n\tp.shutdown = false\n\tisOneshot := g.isOneshot\n\tasyncReadEnabled := g.AsyncReadInPoller && (g.EpollMod == EPOLLET)\n\tfor !p.shutdown {\n\t\tn, err := syscall.EpollWait(p.epfd, events, msec)\n\t\tif err != nil && !errors.Is(err, syscall.EINTR) {\n\t\t\tlogging.Error(\"NBIO[%v][%v_%v] EpollWait failed: %v, exit...\",\n\t\t\t\tp.g.Name,\n\t\t\t\tp.pollType,\n\t\t\t\tp.index,\n\t\t\t\terr,\n\t\t\t)\n\t\t\treturn\n\t\t}\n\n\t\tif n <= 0 {\n\t\t\tmsec = -1\n\t\t\t// runtime.Gosched()\n\t\t\tcontinue\n\t\t}\n\t\tmsec = 20\n\n\t\tfor _, ev := range events[:n] {\n\t\t\tfd := int(ev.Fd)\n\t\t\tswitch fd {\n\t\t\tcase p.evtfd: // triggered by stop, exit event loop\n\n\t\t\tdefault: // for socket connections\n\t\t\t\tc := p.getConn(fd)\n\t\t\t\tif c != nil {\n\t\t\t\t\tif ev.Events&epollEventsWrite != 0 {\n\t\t\t\t\t\tif c.onConnected == nil {\n\t\t\t\t\t\t\tc.flush()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc.onConnected(c, nil)\n\t\t\t\t\t\t\tc.onConnected = nil\n\t\t\t\t\t\t\tc.resetRead()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ev.Events&epollEventsRead != 0 {\n\t\t\t\t\t\tif g.onRead == nil {\n\t\t\t\t\t\t\tif asyncReadEnabled {\n\t\t\t\t\t\t\t\tc.AsyncRead()\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor i := 0; i < g.MaxConnReadTimesPerEventLoop; i++ {\n\t\t\t\t\t\t\t\t\tbuffer := g.borrow(c)\n\t\t\t\t\t\t\t\t\trc, n, err := c.ReadAndGetConn(buffer)\n\t\t\t\t\t\t\t\t\tif n > 0 {\n\t\t\t\t\t\t\t\t\t\tg.onData(rc, buffer[:n])\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tg.payback(c, buffer)\n\t\t\t\t\t\t\t\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\t\tc.closeWithError(err)\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif n < len(buffer) {\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif isOneshot {\n\t\t\t\t\t\t\t\t\tc.ResetPollerEvent()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tg.onRead(c)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ev.Events&epollEventsError != 0 {\n\t\t\t\t\t\tc.closeWithError(io.EOF)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n//go:norace\nfunc (p *poller) stop() {\n\tlogging.Debug(\"NBIO[%v][%v_%v] stop...\", p.g.Name, p.pollType, p.index)\n\tp.shutdown = true\n\tif p.listener != nil {\n\t\tp.listener.Close()\n\t\tif p.unixSockAddr != \"\" {\n\t\t\tos.Remove(p.unixSockAddr)\n\t\t}\n\t} else {\n\t\tn := uint64(1)\n\t\tsyscall.Write(p.evtfd, (*(*[8]byte)(unsafe.Pointer(&n)))[:])\n\t}\n}\n\n//go:norace\nfunc (p *poller) addRead(fd int) error {\n\treturn p.setRead(syscall.EPOLL_CTL_ADD, fd)\n}\n\n//go:norace\nfunc (p *poller) resetRead(fd int) error {\n\treturn p.setRead(syscall.EPOLL_CTL_MOD, fd)\n}\n\n//go:norace\nfunc (p *poller) setRead(op int, fd int) error {\n\tswitch p.g.EpollMod {\n\tcase EPOLLET:\n\t\tevents := syscall.EPOLLERR |\n\t\t\tsyscall.EPOLLHUP |\n\t\t\tsyscall.EPOLLRDHUP |\n\t\t\tsyscall.EPOLLPRI |\n\t\t\tsyscall.EPOLLIN |\n\t\t\tEPOLLET |\n\t\t\tp.g.EPOLLONESHOT\n\t\tif p.g.EPOLLONESHOT != EPOLLONESHOT {\n\t\t\tif op == syscall.EPOLL_CTL_ADD {\n\t\t\t\treturn syscall.EpollCtl(p.epfd, op, fd, &syscall.EpollEvent{\n\t\t\t\t\tFd:     int32(fd),\n\t\t\t\t\tEvents: events | syscall.EPOLLOUT,\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treturn syscall.EpollCtl(p.epfd, op, fd, &syscall.EpollEvent{\n\t\t\tFd:     int32(fd),\n\t\t\tEvents: events,\n\t\t})\n\tdefault:\n\t\treturn syscall.EpollCtl(\n\t\t\tp.epfd,\n\t\t\top,\n\t\t\tfd,\n\t\t\t&syscall.EpollEvent{\n\t\t\t\tFd: int32(fd),\n\t\t\t\tEvents: syscall.EPOLLERR |\n\t\t\t\t\tsyscall.EPOLLHUP |\n\t\t\t\t\tsyscall.EPOLLRDHUP |\n\t\t\t\t\tsyscall.EPOLLPRI |\n\t\t\t\t\tsyscall.EPOLLIN,\n\t\t\t},\n\t\t)\n\t}\n}\n\n//go:norace\nfunc (p *poller) modWrite(fd int) error {\n\treturn p.setReadWrite(syscall.EPOLL_CTL_MOD, fd)\n}\n\n//go:norace\nfunc (p *poller) addReadWrite(fd int) error {\n\treturn p.setReadWrite(syscall.EPOLL_CTL_ADD, fd)\n}\n\n//go:norace\nfunc (p *poller) setReadWrite(op int, fd int) error {\n\tswitch p.g.EpollMod {\n\tcase EPOLLET:\n\t\tevents := syscall.EPOLLERR |\n\t\t\tsyscall.EPOLLHUP |\n\t\t\tsyscall.EPOLLRDHUP |\n\t\t\tsyscall.EPOLLPRI |\n\t\t\tsyscall.EPOLLIN |\n\t\t\tsyscall.EPOLLOUT |\n\t\t\tEPOLLET |\n\t\t\tp.g.EPOLLONESHOT\n\t\tif p.g.EPOLLONESHOT != EPOLLONESHOT {\n\t\t\tif op == syscall.EPOLL_CTL_ADD {\n\t\t\t\treturn syscall.EpollCtl(p.epfd, op, fd, &syscall.EpollEvent{\n\t\t\t\t\tFd:     int32(fd),\n\t\t\t\t\tEvents: events,\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treturn syscall.EpollCtl(p.epfd, op, fd, &syscall.EpollEvent{\n\t\t\tFd:     int32(fd),\n\t\t\tEvents: events,\n\t\t})\n\tdefault:\n\t\treturn syscall.EpollCtl(\n\t\t\tp.epfd, op, fd,\n\t\t\t&syscall.EpollEvent{\n\t\t\t\tFd: int32(fd),\n\t\t\t\tEvents: syscall.EPOLLERR |\n\t\t\t\t\tsyscall.EPOLLHUP |\n\t\t\t\t\tsyscall.EPOLLRDHUP |\n\t\t\t\t\tsyscall.EPOLLPRI |\n\t\t\t\t\tsyscall.EPOLLIN |\n\t\t\t\t\tsyscall.EPOLLOUT,\n\t\t\t},\n\t\t)\n\t}\n}\n\n// func (p *poller) deleteEvent(fd int) error {\n// \treturn syscall.EpollCtl(\n// \t\tp.epfd,\n// \t\tsyscall.EPOLL_CTL_DEL,\n// \t\tfd,\n// \t\t&syscall.EpollEvent{Fd: int32(fd)},\n// \t)\n// }\n\n//go:norace\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tif isListener {\n\t\tif len(g.Addrs) == 0 {\n\t\t\tpanic(\"invalid listener num\")\n\t\t}\n\n\t\taddr := g.Addrs[index%len(g.Addrs)]\n\t\tln, err := g.Listen(g.Network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp := &poller{\n\t\t\tg:          g,\n\t\t\tindex:      index,\n\t\t\tlistener:   ln,\n\t\t\tisListener: isListener,\n\t\t\tpollType:   \"LISTENER\",\n\t\t}\n\t\tif g.Network == \"unix\" {\n\t\t\tp.unixSockAddr = addr\n\t\t}\n\n\t\treturn p, nil\n\t}\n\n\tfd, err := syscall.EpollCreate1(0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr0, _, e0 := syscall.Syscall(syscall.SYS_EVENTFD2, 0, syscall.O_NONBLOCK, 0)\n\tif e0 != 0 {\n\t\tsyscall.Close(fd)\n\t\treturn nil, e0\n\t}\n\n\terr = syscall.EpollCtl(fd, syscall.EPOLL_CTL_ADD, int(r0),\n\t\t&syscall.EpollEvent{Fd: int32(r0),\n\t\t\tEvents: syscall.EPOLLIN,\n\t\t},\n\t)\n\tif err != nil {\n\t\tsyscall.Close(fd)\n\t\tsyscall.Close(int(r0))\n\t\treturn nil, err\n\t}\n\n\tp := &poller{\n\t\tg:          g,\n\t\tepfd:       fd,\n\t\tevtfd:      int(r0),\n\t\tindex:      index,\n\t\tisListener: isListener,\n\t\tpollType:   \"POLLER\",\n\t}\n\n\treturn p, nil\n}\n\n//go:norace\nfunc (c *Conn) ResetPollerEvent() {\n\tp := c.p\n\tg := p.g\n\tfd := c.fd\n\tif g.isOneshot && !c.closed {\n\t\tif len(c.writeList) == 0 {\n\t\t\tp.resetRead(fd)\n\t\t} else {\n\t\t\tp.modWrite(fd)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "poller_kqueue.go",
          "type": "blob",
          "size": 7.63671875,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build darwin || netbsd || freebsd || openbsd || dragonfly\n// +build darwin netbsd freebsd openbsd dragonfly\n\npackage nbio\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/logging\"\n)\n\nconst (\n\t// EPOLLLT .\n\tEPOLLLT = 0\n\n\t// EPOLLET .\n\tEPOLLET = 1\n\n\t// EPOLLONESHOT .\n\tEPOLLONESHOT = 0\n)\n\nconst (\n\tIPPROTO_TCP   = 0\n\tTCP_KEEPINTVL = 0\n\tTCP_KEEPIDLE  = 0\n)\n\ntype poller struct {\n\tmux sync.Mutex\n\n\tg *Engine\n\n\tkfd   int\n\tevtfd int\n\n\tindex int\n\n\tshutdown bool\n\n\tlistener     net.Listener\n\tisListener   bool\n\tunixSockAddr string\n\n\tReadBuffer []byte\n\n\tpollType string\n\n\teventList []syscall.Kevent_t\n}\n\n//go:norace\nfunc (p *poller) addConn(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix))\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onOpen(c)\n\t} else {\n\t\tp.g.onUDPListen(c)\n\t}\n\tp.g.connsUnix[fd] = c\n\tp.addRead(fd)\n\treturn nil\n}\n\n//go:norace\nfunc (p *poller) addDialer(c *Conn) error {\n\tfd := c.fd\n\tif fd >= len(p.g.connsUnix) {\n\t\terr := fmt.Errorf(\"too many open files, fd[%d] >= MaxOpenFiles[%d]\",\n\t\t\tfd,\n\t\t\tlen(p.g.connsUnix),\n\t\t)\n\t\tc.closeWithError(err)\n\t\treturn err\n\t}\n\tc.p = p\n\tp.g.connsUnix[fd] = c\n\tc.isWAdded = true\n\tp.addReadWrite(fd)\n\treturn nil\n}\n\n//go:norace\nfunc (p *poller) getConn(fd int) *Conn {\n\treturn p.g.connsUnix[fd]\n}\n\n//go:norace\nfunc (p *poller) deleteConn(c *Conn) {\n\tif c == nil {\n\t\treturn\n\t}\n\tfd := c.fd\n\n\tif c.typ != ConnTypeUDPClientFromRead {\n\t\tif c == p.g.connsUnix[fd] {\n\t\t\tp.g.connsUnix[fd] = nil\n\t\t}\n\t\t// p.deleteEvent(fd)\n\t}\n\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onClose(c, c.closeErr)\n\t}\n}\n\n//go:norace\nfunc (p *poller) trigger() {\n\tsyscall.Kevent(p.kfd, []syscall.Kevent_t{{Ident: 0, Filter: syscall.EVFILT_USER, Fflags: syscall.NOTE_TRIGGER}}, nil, nil)\n}\n\n//go:norace\nfunc (p *poller) addRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\t// p.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\n//go:norace\nfunc (p *poller) resetRead(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_DELETE, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\n//go:norace\nfunc (p *poller) modWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\n//go:norace\nfunc (p *poller) addReadWrite(fd int) {\n\tp.mux.Lock()\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_READ})\n\tp.eventList = append(p.eventList, syscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_ADD, Filter: syscall.EVFILT_WRITE})\n\tp.mux.Unlock()\n\tp.trigger()\n}\n\n// func (p *poller) deleteEvent(fd int) {\n// \tp.mux.Lock()\n// \tp.eventList = append(p.eventList,\n// \t\tsyscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_DELETE, Filter: syscall.EVFILT_READ},\n// \t\tsyscall.Kevent_t{Ident: uint64(fd), Flags: syscall.EV_DELETE, Filter: syscall.EVFILT_WRITE})\n// \tp.mux.Unlock()\n// \tp.trigger()\n// }\n\n//go:norace\nfunc (p *poller) readWrite(ev *syscall.Kevent_t) {\n\tif ev.Flags&syscall.EV_DELETE > 0 {\n\t\treturn\n\t}\n\tfd := int(ev.Ident)\n\tc := p.getConn(fd)\n\tif c != nil {\n\t\tif ev.Filter == syscall.EVFILT_READ {\n\t\t\tif p.g.onRead == nil {\n\t\t\t\tfor {\n\t\t\t\t\tbuffer := p.g.borrow(c)\n\t\t\t\t\trc, n, err := c.ReadAndGetConn(buffer)\n\t\t\t\t\tif n > 0 {\n\t\t\t\t\t\tp.g.onData(rc, buffer[:n])\n\t\t\t\t\t}\n\t\t\t\t\tp.g.payback(c, buffer)\n\t\t\t\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (err != nil || n == 0) && ev.Flags&syscall.EV_DELETE == 0 {\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\terr = io.EOF\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc.closeWithError(err)\n\t\t\t\t\t}\n\t\t\t\t\tif n < len(buffer) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.g.onRead(c)\n\t\t\t}\n\n\t\t\tif ev.Flags&syscall.EV_EOF != 0 {\n\t\t\t\tif c.onConnected == nil {\n\t\t\t\t\tc.flush()\n\t\t\t\t} else {\n\t\t\t\t\tc.onConnected(c, nil)\n\t\t\t\t\tc.onConnected = nil\n\t\t\t\t\tc.resetRead()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ev.Filter == syscall.EVFILT_WRITE {\n\t\t\tif c.onConnected == nil {\n\t\t\t\tc.flush()\n\t\t\t} else {\n\t\t\t\tc.resetRead()\n\t\t\t\tc.onConnected(c, nil)\n\t\t\t\tc.onConnected = nil\n\t\t\t}\n\t\t}\n\t}\n}\n\n//go:norace\nfunc (p *poller) start() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\tdefer p.g.Done()\n\n\tlogging.Debug(\"NBIO[%v][%v_%v] start\", p.g.Name, p.pollType, p.index)\n\tdefer logging.Debug(\"NBIO[%v][%v_%v] stopped\", p.g.Name, p.pollType, p.index)\n\n\tif p.isListener {\n\t\tp.acceptorLoop()\n\t} else {\n\t\tdefer syscall.Close(p.kfd)\n\t\tp.readWriteLoop()\n\t}\n}\n\n//go:norace\nfunc (p *poller) acceptorLoop() {\n\tif p.g.LockListener {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tconn, err := p.listener.Accept()\n\t\tif err == nil {\n\t\t\tvar c *Conn\n\t\t\tc, err = NBConn(conn)\n\t\t\tif err != nil {\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp.g.pollers[c.Hash()%len(p.g.pollers)].addConn(c)\n\t\t} else {\n\t\t\tvar ne net.Error\n\t\t\tif ok := errors.As(err, &ne); ok && ne.Timeout() {\n\t\t\t\tlogging.Error(\"NBIO[%v][%v_%v] Accept failed: timeout error, retrying...\", p.g.Name, p.pollType, p.index)\n\t\t\t\ttime.Sleep(time.Second / 20)\n\t\t\t} else {\n\t\t\t\tif !p.shutdown {\n\t\t\t\t\tlogging.Error(\"NBIO[%v][%v_%v] Accept failed: %v, exit...\", p.g.Name, p.pollType, p.index, err)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\n//go:norace\nfunc (p *poller) readWriteLoop() {\n\tif p.g.LockPoller {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\n\tevents := make([]syscall.Kevent_t, 1024)\n\tvar changes []syscall.Kevent_t\n\n\tp.shutdown = false\n\tfor !p.shutdown {\n\t\tp.mux.Lock()\n\t\tchanges = p.eventList\n\t\tp.eventList = nil\n\t\tp.mux.Unlock()\n\t\tn, err := syscall.Kevent(p.kfd, changes, events, nil)\n\t\tif err != nil && !errors.Is(err, syscall.EINTR) && !errors.Is(err, syscall.EBADF) && !errors.Is(err, syscall.ENOENT) && !errors.Is(err, syscall.EINVAL) {\n\t\t\tlogging.Error(\"NBIO[%v][%v_%v] Kevent failed: %v, exit...\", p.g.Name, p.pollType, p.index, err)\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tswitch int(events[i].Ident) {\n\t\t\tcase p.evtfd:\n\t\t\tdefault:\n\t\t\t\tp.readWrite(&events[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\n//go:norace\nfunc (p *poller) stop() {\n\tlogging.Debug(\"NBIO[%v][%v_%v] stop...\", p.g.Name, p.pollType, p.index)\n\tp.shutdown = true\n\tif p.listener != nil {\n\t\tp.listener.Close()\n\t\tif p.unixSockAddr != \"\" {\n\t\t\tos.Remove(p.unixSockAddr)\n\t\t}\n\t}\n\tp.trigger()\n}\n\n//go:norace\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tif isListener {\n\t\tif len(g.Addrs) == 0 {\n\t\t\tpanic(\"invalid listener num\")\n\t\t}\n\n\t\taddr := g.Addrs[index%len(g.Addrs)]\n\t\tln, err := g.Listen(g.Network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp := &poller{\n\t\t\tg:          g,\n\t\t\tindex:      index,\n\t\t\tlistener:   ln,\n\t\t\tisListener: isListener,\n\t\t\tpollType:   \"LISTENER\",\n\t\t}\n\t\tif g.Network == \"unix\" {\n\t\t\tp.unixSockAddr = addr\n\t\t}\n\n\t\treturn p, nil\n\t}\n\n\tfd, err := syscall.Kqueue()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = syscall.Kevent(fd, []syscall.Kevent_t{{\n\t\tIdent:  0,\n\t\tFilter: syscall.EVFILT_USER,\n\t\tFlags:  syscall.EV_ADD | syscall.EV_CLEAR,\n\t}}, nil, nil)\n\n\tif err != nil {\n\t\tsyscall.Close(fd)\n\t\treturn nil, err\n\t}\n\n\tp := &poller{\n\t\tg:          g,\n\t\tkfd:        fd,\n\t\tindex:      index,\n\t\tisListener: isListener,\n\t\tpollType:   \"POLLER\",\n\t}\n\n\treturn p, nil\n}\n\n//go:norace\nfunc (c *Conn) ResetPollerEvent() {\n}\n"
        },
        {
          "name": "poller_std.go",
          "type": "blob",
          "size": 3.1748046875,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build windows\n// +build windows\n\npackage nbio\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/lesismal/nbio/logging\"\n)\n\nconst (\n\t// EPOLLLT .\n\tEPOLLLT = 0\n\n\t// EPOLLET .\n\tEPOLLET = 1\n\n\t// EPOLLONESHOT .\n\tEPOLLONESHOT = 0\n)\n\ntype poller struct {\n\tg *Engine\n\n\tindex int\n\n\tReadBuffer []byte\n\n\tpollType   string\n\tisListener bool\n\tlistener   net.Listener\n\tshutdown   bool\n\n\tchStop chan struct{}\n}\n\n//go:norace\nfunc (p *poller) accept() error {\n\tconn, err := p.listener.Accept()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc := newConn(conn)\n\to := p.g.pollers[c.Hash()%len(p.g.pollers)]\n\to.addConn(c)\n\n\treturn nil\n}\n\n//go:norace\nfunc (p *poller) readConn(c *Conn) {\n\tfor {\n\t\tbuffer := p.g.borrow(c)\n\t\t_, err := c.read(buffer)\n\t\tp.g.payback(c, buffer)\n\t\tif err != nil {\n\t\t\tc.Close()\n\t\t\treturn\n\t\t}\n\t}\n}\n\n//go:norace\nfunc (p *poller) addConn(c *Conn) error {\n\tc.p = p\n\tp.g.mux.Lock()\n\tp.g.connsStd[c] = struct{}{}\n\tp.g.mux.Unlock()\n\t// should not call onOpen for udp server conn\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onOpen(c)\n\t} else {\n\t\tp.g.onUDPListen(c)\n\t}\n\t// should not read udp client from reading udp server conn\n\tif c.typ != ConnTypeUDPClientFromRead {\n\t\tgo p.readConn(c)\n\t}\n\n\treturn nil\n}\n\n//go:norace\nfunc (p *poller) addDialer(c *Conn) error {\n\tc.p = p\n\tp.g.mux.Lock()\n\tp.g.connsStd[c] = struct{}{}\n\tp.g.mux.Unlock()\n\tgo p.readConn(c)\n\treturn nil\n}\n\n//go:norace\nfunc (p *poller) deleteConn(c *Conn) {\n\tp.g.mux.Lock()\n\tdelete(p.g.connsStd, c)\n\tp.g.mux.Unlock()\n\t// should not call onClose for udp server conn\n\tif c.typ != ConnTypeUDPServer {\n\t\tp.g.onClose(c, c.closeErr)\n\t}\n}\n\n//go:norace\nfunc (p *poller) start() {\n\tif p.g.LockListener {\n\t\truntime.LockOSThread()\n\t\tdefer runtime.UnlockOSThread()\n\t}\n\tdefer p.g.Done()\n\n\tlogging.Debug(\"NBIO[%v][%v_%v] start\", p.g.Name, p.pollType, p.index)\n\tdefer logging.Debug(\"NBIO[%v][%v_%v] stopped\", p.g.Name, p.pollType, p.index)\n\n\tif p.isListener {\n\t\tvar err error\n\t\tp.shutdown = false\n\t\tfor !p.shutdown {\n\t\t\terr = p.accept()\n\t\t\tif err != nil {\n\t\t\t\tvar ne net.Error\n\t\t\t\tif ok := errors.As(err, &ne); ok && ne.Timeout() {\n\t\t\t\t\tlogging.Error(\"NBIO[%v][%v_%v] Accept failed: timeout error, retrying...\", p.g.Name, p.pollType, p.index)\n\t\t\t\t\ttime.Sleep(time.Second / 20)\n\t\t\t\t} else {\n\t\t\t\t\tif !p.shutdown {\n\t\t\t\t\t\tlogging.Error(\"NBIO[%v][%v_%v] Accept failed: %v, exit...\", p.g.Name, p.pollType, p.index, err)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t<-p.chStop\n}\n\n//go:norace\nfunc (p *poller) stop() {\n\tlogging.Debug(\"NBIO[%v][%v_%v] stop...\", p.g.Name, p.pollType, p.index)\n\tp.shutdown = true\n\tif p.isListener {\n\t\tp.listener.Close()\n\t}\n\tclose(p.chStop)\n}\n\n//go:norace\nfunc newPoller(g *Engine, isListener bool, index int) (*poller, error) {\n\tp := &poller{\n\t\tg:          g,\n\t\tindex:      index,\n\t\tisListener: isListener,\n\t\tchStop:     make(chan struct{}),\n\t}\n\n\tif isListener {\n\t\tvar err error\n\t\tvar addr = g.Addrs[index%len(g.Addrs)]\n\t\tp.listener, err = g.Listen(g.Network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tp.pollType = \"LISTENER\"\n\t} else {\n\t\tp.pollType = \"POLLER\"\n\t}\n\n\treturn p, nil\n}\n\n//go:norace\nfunc (c *Conn) ResetPollerEvent() {\n\n}\n"
        },
        {
          "name": "protocol_stack.go",
          "type": "blob",
          "size": 0.9521484375,
          "content": "package nbio\n\nimport (\n\t\"net\"\n)\n\ntype Protocol interface {\n\tParse(c net.Conn, b []byte, ps *ProtocolStack) (net.Conn, []byte, error)\n\tWrite(b []byte) (int, error)\n}\n\ntype ProtocolStack struct {\n\tstack []Protocol\n}\n\n//go:norace\nfunc (ps *ProtocolStack) Add(p Protocol) {\n\tps.stack = append(ps.stack, p)\n}\n\n//go:norace\nfunc (ps *ProtocolStack) Delete(p Protocol) {\n\ti := len(ps.stack) - 1\n\tfor i >= 0 {\n\t\tif ps.stack[i] == p {\n\t\t\tps.stack[i] = nil\n\t\t\tif i+1 > len(ps.stack)-1 {\n\t\t\t\tps.stack = ps.stack[:i]\n\t\t\t} else {\n\t\t\t\tps.stack = append(ps.stack[:i], ps.stack[i+1:]...)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\ti--\n\t}\n}\n\n//go:norace\nfunc (ps *ProtocolStack) Parse(c net.Conn, b []byte, ps_ ProtocolStack) (net.Conn, []byte, error) {\n\tvar err error\n\tfor _, p := range ps.stack {\n\t\tif p == nil {\n\t\t\tcontinue\n\t\t}\n\t\tc, b, err = p.Parse(c, b, ps)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn c, b, err\n}\n\n//go:norace\nfunc (ps *ProtocolStack) Write(b []byte) (int, error) {\n\treturn -1, ErrUnsupported\n}\n"
        },
        {
          "name": "sendfile_std.go",
          "type": "blob",
          "size": 1.080078125,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build windows\n// +build windows\n\npackage nbio\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\n// Sendfile .\n//\n//go:norace\nfunc (c *Conn) Sendfile(f *os.File, remain int64) (written int64, err error) {\n\tif f == nil {\n\t\treturn 0, nil\n\t}\n\n\tif remain <= 0 {\n\t\tstat, e := f.Stat()\n\t\tif e != nil {\n\t\t\treturn 0, e\n\t\t}\n\t\tremain = stat.Size()\n\t}\n\n\tfor remain > 0 {\n\t\tbufLen := 1024 * 32\n\t\tif bufLen > int(remain) {\n\t\t\tbufLen = int(remain)\n\t\t}\n\t\tpbuf := c.p.g.BodyAllocator.Malloc(bufLen)\n\t\tnr, er := f.Read(*pbuf)\n\t\tif nr > 0 {\n\t\t\tnw, ew := c.Write((*pbuf)[0:nr])\n\t\t\tc.p.g.BodyAllocator.Free(pbuf)\n\t\t\tif nw < 0 {\n\t\t\t\tnw = 0\n\t\t\t}\n\t\t\tremain -= int64(nw)\n\t\t\twritten += int64(nw)\n\t\t\tif ew != nil {\n\t\t\t\terr = ew\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif nr != nw {\n\t\t\t\terr = io.ErrShortWrite\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif er != nil {\n\t\t\tif er != io.EOF {\n\t\t\t\terr = er\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif c.p.g.onWrittenSize != nil && written > 0 {\n\t\tc.p.g.onWrittenSize(c, nil, int(written))\n\t}\n\n\treturn written, err\n}\n"
        },
        {
          "name": "sendfile_unix.go",
          "type": "blob",
          "size": 2.2919921875,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build linux || darwin || netbsd || freebsd || openbsd || dragonfly\n// +build linux darwin netbsd freebsd openbsd dragonfly\n\npackage nbio\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"syscall\"\n)\n\nconst maxSendfileSize = 4 << 20\n\n// Sendfile .\n//\n//go:norace\nfunc (c *Conn) Sendfile(f *os.File, remain int64) (int64, error) {\n\tif f == nil {\n\t\treturn 0, nil\n\t}\n\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\tif c.closed {\n\t\treturn 0, net.ErrClosed\n\t}\n\n\toffset, err := f.Seek(0, io.SeekCurrent)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tstat, err := f.Stat()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tsize := stat.Size()\n\tif (remain <= 0) || (remain > size-offset) {\n\t\tremain = size - offset\n\t}\n\n\t// f.Fd() will set the fd to blocking mod.\n\t// We need to set the fd to non-blocking mod again.\n\tsrc := int(f.Fd())\n\terr = syscall.SetNonblock(src, true)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// If c.writeList is not empty, the socket is not writable now.\n\t// We push this File to writeList and wait to send it when writable.\n\tif len(c.writeList) > 0 {\n\t\t// After this Sendfile func returns, fs will be closed by the caller.\n\t\t// So we need to dup the fd and close it when we don't need it any more.\n\t\tsrc, err = syscall.Dup(src)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tc.newToWriteFile(src, offset, remain)\n\t\t// c.appendWrite(t)\n\t\treturn remain, nil\n\t}\n\n\t// c.p.g.beforeWrite(c)\n\n\tvar (\n\t\tn     int\n\t\tdst   = c.fd\n\t\ttotal = remain\n\t)\n\n\tfor remain > 0 {\n\t\tn = maxSendfileSize\n\t\tif int64(n) > remain {\n\t\t\tn = int(remain)\n\t\t}\n\t\tvar tmpOffset = offset\n\t\tn, err = syscall.Sendfile(dst, src, &tmpOffset, n)\n\t\tif n > 0 {\n\t\t\tremain -= int64(n)\n\t\t\toffset += int64(n)\n\t\t} else if n == 0 && err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif errors.Is(err, syscall.EINTR) {\n\t\t\tcontinue\n\t\t}\n\t\tif errors.Is(err, syscall.EAGAIN) {\n\t\t\t// After this Sendfile func returns, fs will be closed by the caller.\n\t\t\t// So we need to dup the fd and close it when we don't need it any more.\n\t\t\tsrc, err = syscall.Dup(src)\n\t\t\tif err == nil {\n\t\t\t\tc.newToWriteFile(src, offset, remain)\n\t\t\t\t// c.appendWrite(t)\n\t\t\t\tc.modWrite()\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tc.closed = true\n\t\t\tc.closeWithErrorWithoutLock(err)\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\treturn total, nil\n}\n"
        },
        {
          "name": "taskpool",
          "type": "tree",
          "content": null
        },
        {
          "name": "timer",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "writev_bsd.go",
          "type": "blob",
          "size": 0.638671875,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build darwin || netbsd || freebsd || openbsd || dragonfly\n// +build darwin netbsd freebsd openbsd dragonfly\n\npackage nbio\n\nimport (\n\t\"syscall\"\n)\n\n//go:norace\nfunc writev(c *Conn, iovs [][]byte) (int, error) {\n\tsize := 0\n\tfor _, v := range iovs {\n\t\tsize += len(v)\n\t}\n\tpbuf := c.p.g.BodyAllocator.Malloc(size)\n\t*pbuf = (*pbuf)[0:0]\n\tfor _, v := range iovs {\n\t\tpbuf = c.p.g.BodyAllocator.Append(pbuf, v...)\n\t}\n\tn, err := syscall.Write(c.fd, *pbuf)\n\tc.p.g.BodyAllocator.Free(pbuf)\n\treturn n, err\n}\n"
        },
        {
          "name": "writev_linux.go",
          "type": "blob",
          "size": 0.7060546875,
          "content": "// Copyright 2020 lesismal. All rights reserved.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build linux\n// +build linux\n\npackage nbio\n\nimport (\n\t\"syscall\"\n\t\"unsafe\"\n)\n\n//go:norace\nfunc writev(c *Conn, bs [][]byte) (int, error) {\n\tiovs := make([]syscall.Iovec, len(bs))[0:0]\n\tfor _, b := range bs {\n\t\tif len(b) > 0 {\n\t\t\tv := syscall.Iovec{}\n\t\t\tv.SetLen(len(b))\n\t\t\tv.Base = &b[0]\n\t\t\tiovs = append(iovs, v)\n\t\t}\n\t}\n\n\tif len(iovs) > 0 {\n\t\tvar _p0 = unsafe.Pointer(&iovs[0])\n\t\tvar n, _, err = syscall.Syscall(syscall.SYS_WRITEV, uintptr(c.fd), uintptr(_p0), uintptr(len(iovs)))\n\t\tif err == 0 {\n\t\t\treturn int(n), nil\n\t\t}\n\t\treturn int(n), err\n\t}\n\treturn 0, nil\n}\n"
        }
      ]
    }
  ]
}