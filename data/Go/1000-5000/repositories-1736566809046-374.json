{
  "metadata": {
    "timestamp": 1736566809046,
    "page": 374,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Jeffail/gabs",
      "stars": 3491,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".errcheck.txt",
          "type": "blob",
          "size": 0.3857421875,
          "content": "(*github.com/Jeffail/gabs/v2.Container).Array\n(*github.com/Jeffail/gabs/v2.Container).ArrayAppend\n(*github.com/Jeffail/gabs/v2.Container).ArrayAppend\n(*github.com/Jeffail/gabs/v2.Container).ArrayConcat\n(*github.com/Jeffail/gabs/v2.Container).ArrayConcatP\n(*github.com/Jeffail/gabs/v2.Container).ArrayP\n(*github.com/Jeffail/gabs/v2.Container).Set\n(*github.com/Jeffail/gabs/v2.Container).SetIndex\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.6552734375,
          "content": "run:\n  timeout: 30s\n\nissues:\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters-settings:\n  errcheck:\n    exclude: .errcheck.txt\n  gocritic:\n    enabled-tags:\n      - diagnostic\n      - experimental\n      - opinionated\n      - performance\n      - style\n\nlinters:\n  disable-all: true\n  enable:\n    # Default linters reported by golangci-lint help linters` in v1.39.0\n    - gosimple\n    - staticcheck\n    - unused\n    - errcheck\n    - govet\n    - ineffassign\n    - typecheck\n    # Extra linters:\n    - wastedassign\n    - stylecheck\n    - gofmt\n    - goimports\n    - gocritic\n    - revive\n    - unconvert\n    - durationcheck\n    - depguard\n    - gosec\n    - bodyclose\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.03125,
          "content": "Copyright (c) 2019 Ashley Jeffs\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.9306640625,
          "content": "![Gabs](gabs_logo.png \"Gabs\")\n\n[![pkg.go for Jeffail/gabs][godoc-badge]][godoc-url]\n\nGabs is a small utility for dealing with dynamic or unknown JSON structures in Go. It's pretty much just a helpful wrapper for navigating hierarchies of `map[string]interface{}` objects provided by the `encoding/json` package. It does nothing spectacular apart from being fabulous.\n\nIf you're migrating from version 1 check out [`migration.md`][migration-doc] for guidance.\n\n## Use\n\n### Import\n\nUsing modules:\n\n```go\nimport (\n\t\"github.com/Jeffail/gabs/v2\"\n)\n```\n\nWithout modules:\n\n```go\nimport (\n\t\"github.com/Jeffail/gabs\"\n)\n```\n\n### Parsing and searching JSON\n\n```go\njsonParsed, err := gabs.ParseJSON([]byte(`{\n\t\"outer\":{\n\t\t\"inner\":{\n\t\t\t\"value1\":10,\n\t\t\t\"value2\":22\n\t\t},\n\t\t\"alsoInner\":{\n\t\t\t\"value1\":20,\n\t\t\t\"array1\":[\n\t\t\t\t30, 40\n\t\t\t]\n\t\t}\n\t}\n}`))\nif err != nil {\n\tpanic(err)\n}\n\nvar value float64\nvar ok bool\n\nvalue, ok = jsonParsed.Path(\"outer.inner.value1\").Data().(float64)\n// value == 10.0, ok == true\n\nvalue, ok = jsonParsed.Search(\"outer\", \"inner\", \"value1\").Data().(float64)\n// value == 10.0, ok == true\n\nvalue, ok = jsonParsed.Search(\"outer\", \"alsoInner\", \"array1\", \"1\").Data().(float64)\n// value == 40.0, ok == true\n\ngObj, err := jsonParsed.JSONPointer(\"/outer/alsoInner/array1/1\")\nif err != nil {\n\tpanic(err)\n}\nvalue, ok = gObj.Data().(float64)\n// value == 40.0, ok == true\n\nvalue, ok = jsonParsed.Path(\"does.not.exist\").Data().(float64)\n// value == 0.0, ok == false\n\nexists := jsonParsed.Exists(\"outer\", \"inner\", \"value1\")\n// exists == true\n\nexists = jsonParsed.ExistsP(\"does.not.exist\")\n// exists == false\n```\n\n### Iterating objects\n\n```go\njsonParsed, err := gabs.ParseJSON([]byte(`{\"object\":{\"first\":1,\"second\":2,\"third\":3}}`))\nif err != nil {\n\tpanic(err)\n}\n\n// S is shorthand for Search\nfor key, child := range jsonParsed.S(\"object\").ChildrenMap() {\n\tfmt.Printf(\"key: %v, value: %v\\n\", key, child.Data().(float64))\n}\n```\n\n### Iterating arrays\n\n```go\njsonParsed, err := gabs.ParseJSON([]byte(`{\"array\":[\"first\",\"second\",\"third\"]}`))\nif err != nil {\n\tpanic(err)\n}\n\nfor _, child := range jsonParsed.S(\"array\").Children() {\n\tfmt.Println(child.Data().(string))\n}\n```\n\nWill print:\n\n```\nfirst\nsecond\nthird\n```\n\nChildren() will return all children of an array in order. This also works on objects, however, the children will be returned in a random order.\n\n### Searching through arrays\n\nIf your structure contains arrays you must target an index in your search.\n\n```go\njsonParsed, err := gabs.ParseJSON([]byte(`{\"array\":[{\"value\":1},{\"value\":2},{\"value\":3}]}`))\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(jsonParsed.Path(\"array.1.value\").String())\n```\n\nWill print `2`.\n\n### Generating JSON\n\n```go\njsonObj := gabs.New()\n// or gabs.Wrap(jsonObject) to work on an existing map[string]interface{}\n\njsonObj.Set(10, \"outer\", \"inner\", \"value\")\njsonObj.SetP(20, \"outer.inner.value2\")\njsonObj.Set(30, \"outer\", \"inner2\", \"value3\")\n\nfmt.Println(jsonObj.String())\n```\n\nWill print:\n\n```\n{\"outer\":{\"inner\":{\"value\":10,\"value2\":20},\"inner2\":{\"value3\":30}}}\n```\n\nTo pretty-print:\n\n```go\nfmt.Println(jsonObj.StringIndent(\"\", \"  \"))\n```\n\nWill print:\n\n```\n{\n  \"outer\": {\n    \"inner\": {\n      \"value\": 10,\n      \"value2\": 20\n    },\n    \"inner2\": {\n      \"value3\": 30\n    }\n  }\n}\n```\n\n### Generating Arrays\n\n```go\njsonObj := gabs.New()\n\njsonObj.Array(\"foo\", \"array\")\n// Or .ArrayP(\"foo.array\")\n\njsonObj.ArrayAppend(10, \"foo\", \"array\")\njsonObj.ArrayAppend(20, \"foo\", \"array\")\njsonObj.ArrayAppend(30, \"foo\", \"array\")\n\nfmt.Println(jsonObj.String())\n```\n\nWill print:\n\n```\n{\"foo\":{\"array\":[10,20,30]}}\n```\n\nWorking with arrays by index:\n\n```go\njsonObj := gabs.New()\n\n// Create an array with the length of 3\njsonObj.ArrayOfSize(3, \"foo\")\n\njsonObj.S(\"foo\").SetIndex(\"test1\", 0)\njsonObj.S(\"foo\").SetIndex(\"test2\", 1)\n\n// Create an embedded array with the length of 3\njsonObj.S(\"foo\").ArrayOfSizeI(3, 2)\n\njsonObj.S(\"foo\").Index(2).SetIndex(1, 0)\njsonObj.S(\"foo\").Index(2).SetIndex(2, 1)\njsonObj.S(\"foo\").Index(2).SetIndex(3, 2)\n\nfmt.Println(jsonObj.String())\n```\n\nWill print:\n\n```\n{\"foo\":[\"test1\",\"test2\",[1,2,3]]}\n```\n\n### Converting back to JSON\n\nThis is the easiest part:\n\n```go\njsonParsedObj, _ := gabs.ParseJSON([]byte(`{\n\t\"outer\":{\n\t\t\"values\":{\n\t\t\t\"first\":10,\n\t\t\t\"second\":11\n\t\t}\n\t},\n\t\"outer2\":\"hello world\"\n}`))\n\njsonOutput := jsonParsedObj.String()\n// Becomes `{\"outer\":{\"values\":{\"first\":10,\"second\":11}},\"outer2\":\"hello world\"}`\n```\n\nAnd to serialize a specific segment is as simple as:\n\n```go\njsonParsedObj := gabs.ParseJSON([]byte(`{\n\t\"outer\":{\n\t\t\"values\":{\n\t\t\t\"first\":10,\n\t\t\t\"second\":11\n\t\t}\n\t},\n\t\"outer2\":\"hello world\"\n}`))\n\njsonOutput := jsonParsedObj.Search(\"outer\").String()\n// Becomes `{\"values\":{\"first\":10,\"second\":11}}`\n```\n\n### Merge two containers\n\nYou can merge a JSON structure into an existing one, where collisions will be converted into a JSON array.\n\n```go\njsonParsed1, _ := ParseJSON([]byte(`{\"outer\":{\"value1\":\"one\"}}`))\njsonParsed2, _ := ParseJSON([]byte(`{\"outer\":{\"inner\":{\"value3\":\"three\"}},\"outer2\":{\"value2\":\"two\"}}`))\n\njsonParsed1.Merge(jsonParsed2)\n// Becomes `{\"outer\":{\"inner\":{\"value3\":\"three\"},\"value1\":\"one\"},\"outer2\":{\"value2\":\"two\"}}`\n```\n\nArrays are merged:\n\n```go\njsonParsed1, _ := ParseJSON([]byte(`{\"array\":[\"one\"]}`))\njsonParsed2, _ := ParseJSON([]byte(`{\"array\":[\"two\"]}`))\n\njsonParsed1.Merge(jsonParsed2)\n// Becomes `{\"array\":[\"one\", \"two\"]}`\n```\n\n### Parsing Numbers\n\nGabs uses the `json` package under the bonnet, which by default will parse all number values into `float64`. If you need to parse `Int` values then you should use a [`json.Decoder`](https://golang.org/pkg/encoding/json/#Decoder):\n\n```go\nsample := []byte(`{\"test\":{\"int\":10,\"float\":6.66}}`)\ndec := json.NewDecoder(bytes.NewReader(sample))\ndec.UseNumber()\n\nval, err := gabs.ParseJSONDecoder(dec)\nif err != nil {\n    t.Errorf(\"Failed to parse: %v\", err)\n    return\n}\n\nintValue, err := val.Path(\"test.int\").Data().(json.Number).Int64()\n```\n\n[godoc-badge]: https://godoc.org/github.com/Jeffail/gabs?status.svg\n[godoc-url]: https://pkg.go.dev/github.com/Jeffail/gabs/v2\n[migration-doc]: ./migration.md\n"
        },
        {
          "name": "gabs.go",
          "type": "blob",
          "size": 30.6943359375,
          "content": "// Copyright (c) 2019 Ashley Jeffs\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Package gabs implements a wrapper around creating and parsing unknown or\n// dynamic map structures resulting from JSON parsing.\npackage gabs\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n//------------------------------------------------------------------------------\n\nvar (\n\t// ErrOutOfBounds indicates an index was out of bounds.\n\tErrOutOfBounds = errors.New(\"out of bounds\")\n\n\t// ErrNotObjOrArray is returned when a target is not an object or array type\n\t// but needs to be for the intended operation.\n\tErrNotObjOrArray = errors.New(\"not an object or array\")\n\n\t// ErrNotObj is returned when a target is not an object but needs to be for\n\t// the intended operation.\n\tErrNotObj = errors.New(\"not an object\")\n\n\t// ErrInvalidQuery is returned when a seach query was not valid.\n\tErrInvalidQuery = errors.New(\"invalid search query\")\n\n\t// ErrNotArray is returned when a target is not an array but needs to be for\n\t// the intended operation.\n\tErrNotArray = errors.New(\"not an array\")\n\n\t// ErrPathCollision is returned when creating a path failed because an\n\t// element collided with an existing value.\n\tErrPathCollision = errors.New(\"encountered value collision whilst building path\")\n\n\t// ErrInvalidInputObj is returned when the input value was not a\n\t// map[string]interface{}.\n\tErrInvalidInputObj = errors.New(\"invalid input object\")\n\n\t// ErrInvalidInputText is returned when the input data could not be parsed.\n\tErrInvalidInputText = errors.New(\"input text could not be parsed\")\n\n\t// ErrNotFound is returned when a query leaf is not found.\n\tErrNotFound = errors.New(\"field not found\")\n\n\t// ErrInvalidPath is returned when the filepath was not valid.\n\tErrInvalidPath = errors.New(\"invalid file path\")\n\n\t// ErrInvalidBuffer is returned when the input buffer contained an invalid\n\t// JSON string.\n\tErrInvalidBuffer = errors.New(\"input buffer contained invalid JSON\")\n)\n\nvar (\n\tr1 *strings.Replacer\n\tr2 *strings.Replacer\n)\n\nfunc init() {\n\tr1 = strings.NewReplacer(\"~1\", \"/\", \"~0\", \"~\")\n\tr2 = strings.NewReplacer(\"~1\", \".\", \"~0\", \"~\")\n}\n\n//------------------------------------------------------------------------------\n\n// JSONPointerToSlice parses a JSON pointer path\n// (https://tools.ietf.org/html/rfc6901) and returns the path segments as a\n// slice.\n//\n// Because the characters '~' (%x7E) and '/' (%x2F) have special meanings in\n// gabs paths, '~' needs to be encoded as '~0' and '/' needs to be encoded as\n// '~1' when these characters appear in a reference key.\nfunc JSONPointerToSlice(path string) ([]string, error) {\n\tif path == \"\" {\n\t\treturn nil, nil\n\t}\n\tif path[0] != '/' {\n\t\treturn nil, errors.New(\"failed to resolve JSON pointer: path must begin with '/'\")\n\t}\n\tif path == \"/\" {\n\t\treturn []string{\"\"}, nil\n\t}\n\thierarchy := strings.Split(path, \"/\")[1:]\n\tfor i, v := range hierarchy {\n\t\thierarchy[i] = r1.Replace(v)\n\t}\n\treturn hierarchy, nil\n}\n\n// DotPathToSlice returns a slice of path segments parsed out of a dot path.\n//\n// Because '.' (%x2E) is the segment separator, it must be encoded as '~1'\n// if it appears in the reference key. Likewise, '~' (%x7E) must be encoded\n// as '~0' since it is the escape character for encoding '.'.\nfunc DotPathToSlice(path string) []string {\n\thierarchy := strings.Split(path, \".\")\n\tfor i, v := range hierarchy {\n\t\thierarchy[i] = r2.Replace(v)\n\t}\n\treturn hierarchy\n}\n\n//------------------------------------------------------------------------------\n\n// Container references a specific element within a wrapped structure.\ntype Container struct {\n\tobject interface{}\n}\n\n// Data returns the underlying value of the target element in the wrapped\n// structure.\nfunc (g *Container) Data() interface{} {\n\tif g == nil {\n\t\treturn nil\n\t}\n\treturn g.object\n}\n\n//------------------------------------------------------------------------------\n\nfunc (g *Container) searchStrict(allowWildcard bool, hierarchy ...string) (*Container, error) {\n\tobject := g.Data()\n\tfor target := 0; target < len(hierarchy); target++ {\n\t\tpathSeg := hierarchy[target]\n\t\tswitch typedObj := object.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tvar ok bool\n\t\t\tif object, ok = typedObj[pathSeg]; !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to resolve path segment '%v': key '%v' was not found\", target, pathSeg)\n\t\t\t}\n\t\tcase []interface{}:\n\t\t\tif allowWildcard && pathSeg == \"*\" {\n\t\t\t\tvar tmpArray []interface{}\n\t\t\t\tif (target + 1) >= len(hierarchy) {\n\t\t\t\t\ttmpArray = typedObj\n\t\t\t\t} else {\n\t\t\t\t\ttmpArray = make([]interface{}, 0, len(typedObj))\n\t\t\t\t\tfor _, val := range typedObj {\n\t\t\t\t\t\tif res := Wrap(val).Search(hierarchy[target+1:]...); res != nil {\n\t\t\t\t\t\t\ttmpArray = append(tmpArray, res.Data())\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif len(tmpArray) == 0 {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t}\n\n\t\t\t\treturn &Container{tmpArray}, nil\n\t\t\t}\n\t\t\tindex, err := strconv.Atoi(pathSeg)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to resolve path segment '%v': found array but segment value '%v' could not be parsed into array index: %v\", target, pathSeg, err)\n\t\t\t}\n\t\t\tif index < 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to resolve path segment '%v': found array but index '%v' is invalid\", target, pathSeg)\n\t\t\t}\n\t\t\tif len(typedObj) <= index {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to resolve path segment '%v': found array but index '%v' exceeded target array size of '%v'\", target, pathSeg, len(typedObj))\n\t\t\t}\n\t\t\tobject = typedObj[index]\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"failed to resolve path segment '%v': field '%v' was not found\", target, pathSeg)\n\t\t}\n\t}\n\treturn &Container{object}, nil\n}\n\n// Search attempts to find and return an object within the wrapped structure by\n// following a provided hierarchy of field names to locate the target.\n//\n// If the search encounters an array then the next hierarchy field name must be\n// either a an integer which is interpreted as the index of the target, or the\n// character '*', in which case all elements are searched with the remaining\n// search hierarchy and the results returned within an array.\nfunc (g *Container) Search(hierarchy ...string) *Container {\n\tc, _ := g.searchStrict(true, hierarchy...)\n\treturn c\n}\n\n// Path searches the wrapped structure following a path in dot notation,\n// segments of this path are searched according to the same rules as Search.\n//\n// Because the characters '~' (%x7E) and '.' (%x2E) have special meanings in\n// gabs paths, '~' needs to be encoded as '~0' and '.' needs to be encoded as\n// '~1' when these characters appear in a reference key.\nfunc (g *Container) Path(path string) *Container {\n\treturn g.Search(DotPathToSlice(path)...)\n}\n\n// JSONPointer parses a JSON pointer path (https://tools.ietf.org/html/rfc6901)\n// and either returns a *gabs.Container containing the result or an error if the\n// referenced item could not be found.\n//\n// Because the characters '~' (%x7E) and '/' (%x2F) have special meanings in\n// gabs paths, '~' needs to be encoded as '~0' and '/' needs to be encoded as\n// '~1' when these characters appear in a reference key.\nfunc (g *Container) JSONPointer(path string) (*Container, error) {\n\thierarchy, err := JSONPointerToSlice(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn g.searchStrict(false, hierarchy...)\n}\n\n// S is a shorthand alias for Search.\nfunc (g *Container) S(hierarchy ...string) *Container {\n\treturn g.Search(hierarchy...)\n}\n\n// Exists checks whether a field exists within the hierarchy.\nfunc (g *Container) Exists(hierarchy ...string) bool {\n\treturn g.Search(hierarchy...) != nil\n}\n\n// ExistsP checks whether a dot notation path exists.\nfunc (g *Container) ExistsP(path string) bool {\n\treturn g.Exists(DotPathToSlice(path)...)\n}\n\n// Index attempts to find and return an element within a JSON array by an index.\nfunc (g *Container) Index(index int) *Container {\n\tif array, ok := g.Data().([]interface{}); ok {\n\t\tif index >= len(array) {\n\t\t\treturn nil\n\t\t}\n\t\treturn &Container{array[index]}\n\t}\n\treturn nil\n}\n\n// Children returns a slice of all children of an array element. This also works\n// for objects, however, the children returned for an object will be in a random\n// order and you lose the names of the returned objects this way. If the\n// underlying container value isn't an array or map nil is returned.\nfunc (g *Container) Children() []*Container {\n\tif array, ok := g.Data().([]interface{}); ok {\n\t\tchildren := make([]*Container, len(array))\n\t\tfor i := 0; i < len(array); i++ {\n\t\t\tchildren[i] = &Container{array[i]}\n\t\t}\n\t\treturn children\n\t}\n\tif mmap, ok := g.Data().(map[string]interface{}); ok {\n\t\tchildren := make([]*Container, 0, len(mmap))\n\t\tfor _, obj := range mmap {\n\t\t\tchildren = append(children, &Container{obj})\n\t\t}\n\t\treturn children\n\t}\n\treturn nil\n}\n\n// ChildrenMap returns a map of all the children of an object element. IF the\n// underlying value isn't a object then an empty map is returned.\nfunc (g *Container) ChildrenMap() map[string]*Container {\n\tif mmap, ok := g.Data().(map[string]interface{}); ok {\n\t\tchildren := make(map[string]*Container, len(mmap))\n\t\tfor name, obj := range mmap {\n\t\t\tchildren[name] = &Container{obj}\n\t\t}\n\t\treturn children\n\t}\n\treturn map[string]*Container{}\n}\n\n//------------------------------------------------------------------------------\n\n// Set attempts to set the value of a field located by a hierarchy of field\n// names. If the search encounters an array then the next hierarchy field name\n// is interpreted as an integer index of an existing element, or the character\n// '-', which indicates a new element appended to the end of the array.\n//\n// Any parts of the hierarchy that do not exist will be constructed as objects.\n// This includes parts that could be interpreted as array indexes.\n//\n// Returns a container of the new value or an error.\nfunc (g *Container) Set(value interface{}, hierarchy ...string) (*Container, error) {\n\tif g == nil {\n\t\treturn nil, errors.New(\"failed to resolve path, container is nil\")\n\t}\n\tif len(hierarchy) == 0 {\n\t\tg.object = value\n\t\treturn g, nil\n\t}\n\tif g.object == nil {\n\t\tg.object = map[string]interface{}{}\n\t}\n\tobject := g.object\n\n\tfor target := 0; target < len(hierarchy); target++ {\n\t\tpathSeg := hierarchy[target]\n\t\tswitch typedObj := object.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tif target == len(hierarchy)-1 {\n\t\t\t\tobject = value\n\t\t\t\ttypedObj[pathSeg] = object\n\t\t\t} else if object = typedObj[pathSeg]; object == nil {\n\t\t\t\ttypedObj[pathSeg] = map[string]interface{}{}\n\t\t\t\tobject = typedObj[pathSeg]\n\t\t\t}\n\t\tcase []interface{}:\n\t\t\tif pathSeg == \"-\" {\n\t\t\t\tif target < 1 {\n\t\t\t\t\treturn nil, errors.New(\"unable to append new array index at root of path\")\n\t\t\t\t}\n\t\t\t\tif target == len(hierarchy)-1 {\n\t\t\t\t\tobject = value\n\t\t\t\t} else {\n\t\t\t\t\tobject = map[string]interface{}{}\n\t\t\t\t}\n\t\t\t\ttypedObj = append(typedObj, object)\n\t\t\t\tif _, err := g.Set(typedObj, hierarchy[:target]...); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tindex, err := strconv.Atoi(pathSeg)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"failed to resolve path segment '%v': found array but segment value '%v' could not be parsed into array index: %v\", target, pathSeg, err)\n\t\t\t\t}\n\t\t\t\tif index < 0 {\n\t\t\t\t\treturn nil, fmt.Errorf(\"failed to resolve path segment '%v': found array but index '%v' is invalid\", target, pathSeg)\n\t\t\t\t}\n\t\t\t\tif len(typedObj) <= index {\n\t\t\t\t\treturn nil, fmt.Errorf(\"failed to resolve path segment '%v': found array but index '%v' exceeded target array size of '%v'\", target, pathSeg, len(typedObj))\n\t\t\t\t}\n\t\t\t\tif target == len(hierarchy)-1 {\n\t\t\t\t\tobject = value\n\t\t\t\t\ttypedObj[index] = object\n\t\t\t\t} else if object = typedObj[index]; object == nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"failed to resolve path segment '%v': field '%v' was not found\", target, pathSeg)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, ErrPathCollision\n\t\t}\n\t}\n\treturn &Container{object}, nil\n}\n\n// SetP sets the value of a field at a path using dot notation, any parts\n// of the path that do not exist will be constructed, and if a collision occurs\n// with a non object type whilst iterating the path an error is returned.\nfunc (g *Container) SetP(value interface{}, path string) (*Container, error) {\n\treturn g.Set(value, DotPathToSlice(path)...)\n}\n\n// SetIndex attempts to set a value of an array element based on an index.\nfunc (g *Container) SetIndex(value interface{}, index int) (*Container, error) {\n\tif array, ok := g.Data().([]interface{}); ok {\n\t\tif index >= len(array) {\n\t\t\treturn nil, ErrOutOfBounds\n\t\t}\n\t\tarray[index] = value\n\t\treturn &Container{array[index]}, nil\n\t}\n\treturn nil, ErrNotArray\n}\n\n// SetJSONPointer parses a JSON pointer path\n// (https://tools.ietf.org/html/rfc6901) and sets the leaf to a value. Returns\n// an error if the pointer could not be resolved due to missing fields.\nfunc (g *Container) SetJSONPointer(value interface{}, path string) (*Container, error) {\n\thierarchy, err := JSONPointerToSlice(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn g.Set(value, hierarchy...)\n}\n\n// Object creates a new JSON object at a target path. Returns an error if the\n// path contains a collision with a non object type.\nfunc (g *Container) Object(hierarchy ...string) (*Container, error) {\n\treturn g.Set(map[string]interface{}{}, hierarchy...)\n}\n\n// ObjectP creates a new JSON object at a target path using dot notation.\n// Returns an error if the path contains a collision with a non object type.\nfunc (g *Container) ObjectP(path string) (*Container, error) {\n\treturn g.Object(DotPathToSlice(path)...)\n}\n\n// ObjectI creates a new JSON object at an array index. Returns an error if the\n// object is not an array or the index is out of bounds.\nfunc (g *Container) ObjectI(index int) (*Container, error) {\n\treturn g.SetIndex(map[string]interface{}{}, index)\n}\n\n// Array creates a new JSON array at a path. Returns an error if the path\n// contains a collision with a non object type.\nfunc (g *Container) Array(hierarchy ...string) (*Container, error) {\n\treturn g.Set([]interface{}{}, hierarchy...)\n}\n\n// ArrayP creates a new JSON array at a path using dot notation. Returns an\n// error if the path contains a collision with a non object type.\nfunc (g *Container) ArrayP(path string) (*Container, error) {\n\treturn g.Array(DotPathToSlice(path)...)\n}\n\n// ArrayI creates a new JSON array within an array at an index. Returns an error\n// if the element is not an array or the index is out of bounds.\nfunc (g *Container) ArrayI(index int) (*Container, error) {\n\treturn g.SetIndex([]interface{}{}, index)\n}\n\n// ArrayOfSize creates a new JSON array of a particular size at a path. Returns\n// an error if the path contains a collision with a non object type.\nfunc (g *Container) ArrayOfSize(size int, hierarchy ...string) (*Container, error) {\n\ta := make([]interface{}, size)\n\treturn g.Set(a, hierarchy...)\n}\n\n// ArrayOfSizeP creates a new JSON array of a particular size at a path using\n// dot notation. Returns an error if the path contains a collision with a non\n// object type.\nfunc (g *Container) ArrayOfSizeP(size int, path string) (*Container, error) {\n\treturn g.ArrayOfSize(size, DotPathToSlice(path)...)\n}\n\n// ArrayOfSizeI create a new JSON array of a particular size within an array at\n// an index. Returns an error if the element is not an array or the index is out\n// of bounds.\nfunc (g *Container) ArrayOfSizeI(size, index int) (*Container, error) {\n\ta := make([]interface{}, size)\n\treturn g.SetIndex(a, index)\n}\n\n// Delete an element at a path, an error is returned if the element does not\n// exist or is not an object. In order to remove an array element please use\n// ArrayRemove.\nfunc (g *Container) Delete(hierarchy ...string) error {\n\tif g == nil || g.object == nil {\n\t\treturn ErrNotObj\n\t}\n\tif len(hierarchy) == 0 {\n\t\treturn ErrInvalidQuery\n\t}\n\n\tobject := g.object\n\ttarget := hierarchy[len(hierarchy)-1]\n\tif len(hierarchy) > 1 {\n\t\tobject = g.Search(hierarchy[:len(hierarchy)-1]...).Data()\n\t}\n\n\tif obj, ok := object.(map[string]interface{}); ok {\n\t\tif _, ok = obj[target]; !ok {\n\t\t\treturn ErrNotFound\n\t\t}\n\t\tdelete(obj, target)\n\t\treturn nil\n\t}\n\tif array, ok := object.([]interface{}); ok {\n\t\tif len(hierarchy) < 2 {\n\t\t\treturn errors.New(\"unable to delete array index at root of path\")\n\t\t}\n\t\tindex, err := strconv.Atoi(target)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to parse array index '%v': %v\", target, err)\n\t\t}\n\t\tif index >= len(array) {\n\t\t\treturn ErrOutOfBounds\n\t\t}\n\t\tif index < 0 {\n\t\t\treturn ErrOutOfBounds\n\t\t}\n\t\tarray = append(array[:index], array[index+1:]...)\n\t\tg.Set(array, hierarchy[:len(hierarchy)-1]...)\n\t\treturn nil\n\t}\n\treturn ErrNotObjOrArray\n}\n\n// DeleteP deletes an element at a path using dot notation, an error is returned\n// if the element does not exist.\nfunc (g *Container) DeleteP(path string) error {\n\treturn g.Delete(DotPathToSlice(path)...)\n}\n\n// MergeFn merges two objects using a provided function to resolve collisions.\n//\n// The collision function receives two interface{} arguments, destination (the\n// original object) and source (the object being merged into the destination).\n// Which ever value is returned becomes the new value in the destination object\n// at the location of the collision.\nfunc (g *Container) MergeFn(source *Container, collisionFn func(destination, source interface{}) interface{}) error {\n\tvar recursiveFnc func(map[string]interface{}, []string) error\n\trecursiveFnc = func(mmap map[string]interface{}, path []string) error {\n\t\tfor key, value := range mmap {\n\t\t\tnewPath := make([]string, len(path))\n\t\t\tcopy(newPath, path)\n\t\t\tnewPath = append(newPath, key)\n\t\t\tif g.Exists(newPath...) {\n\t\t\t\texistingData := g.Search(newPath...).Data()\n\t\t\t\tswitch t := value.(type) {\n\t\t\t\tcase map[string]interface{}:\n\t\t\t\t\tswitch existingVal := existingData.(type) {\n\t\t\t\t\tcase map[string]interface{}:\n\t\t\t\t\t\tif err := recursiveFnc(t, newPath); err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif _, err := g.Set(collisionFn(existingVal, t), newPath...); err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tif _, err := g.Set(collisionFn(existingData, t), newPath...); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if _, err := g.Set(value, newPath...); err != nil {\n\t\t\t\t// path doesn't exist. So set the value\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\tif mmap, ok := source.Data().(map[string]interface{}); ok {\n\t\treturn recursiveFnc(mmap, []string{})\n\t}\n\treturn nil\n}\n\n// Merge a source object into an existing destination object. When a collision\n// is found within the merged structures (both a source and destination object\n// contain the same non-object keys) the result will be an array containing both\n// values, where values that are already arrays will be expanded into the\n// resulting array.\n//\n// It is possible to merge structures will different collision behaviours with\n// MergeFn.\nfunc (g *Container) Merge(source *Container) error {\n\treturn g.MergeFn(source, func(dest, source interface{}) interface{} {\n\t\tdestArr, destIsArray := dest.([]interface{})\n\t\tsourceArr, sourceIsArray := source.([]interface{})\n\t\tif destIsArray {\n\t\t\tif sourceIsArray {\n\t\t\t\treturn append(destArr, sourceArr...)\n\t\t\t}\n\t\t\treturn append(destArr, source)\n\t\t}\n\t\tif sourceIsArray {\n\t\t\treturn append(append([]interface{}{}, dest), sourceArr...)\n\t\t}\n\t\treturn []interface{}{dest, source}\n\t})\n}\n\n//------------------------------------------------------------------------------\n\n/*\nArray modification/search - Keeping these options simple right now, no need for\nanything more complicated since you can just cast to []interface{}, modify and\nthen reassign with Set.\n*/\n\n// ArrayAppend attempts to append a value onto a JSON array at a path. If the\n// target is not a JSON array then it will be converted into one, with its\n// original contents set to the first element of the array.\nfunc (g *Container) ArrayAppend(value interface{}, hierarchy ...string) error {\n\tif array, ok := g.Search(hierarchy...).Data().([]interface{}); ok {\n\t\tarray = append(array, value)\n\t\t_, err := g.Set(array, hierarchy...)\n\t\treturn err\n\t}\n\n\tnewArray := []interface{}{}\n\tif d := g.Search(hierarchy...).Data(); d != nil {\n\t\tnewArray = append(newArray, d)\n\t}\n\tnewArray = append(newArray, value)\n\n\t_, err := g.Set(newArray, hierarchy...)\n\treturn err\n}\n\n// ArrayAppendP attempts to append a value onto a JSON array at a path using dot\n// notation. If the target is not a JSON array then it will be converted into\n// one, with its original contents set to the first element of the array.\nfunc (g *Container) ArrayAppendP(value interface{}, path string) error {\n\treturn g.ArrayAppend(value, DotPathToSlice(path)...)\n}\n\n// ArrayConcat attempts to append a value onto a JSON array at a path. If the\n// target is not a JSON array then it will be converted into one, with its\n// original contents set to the first element of the array.\n//\n// ArrayConcat differs from ArrayAppend in that it will expand a value type\n// []interface{} during the append operation, resulting in concatenation of each\n// element, rather than append as a single element of []interface{}.\nfunc (g *Container) ArrayConcat(value interface{}, hierarchy ...string) error {\n\tvar array []interface{}\n\tif d := g.Search(hierarchy...).Data(); d != nil {\n\t\tif targetArray, ok := d.([]interface{}); !ok {\n\t\t\t// If the data exists, and it is not a slice of interface,\n\t\t\t// append it as the first element of our new array.\n\t\t\tarray = append(array, d)\n\t\t} else {\n\t\t\t// If the data exists, and it is a slice of interface,\n\t\t\t// assign it to our variable.\n\t\t\tarray = targetArray\n\t\t}\n\t}\n\n\tswitch v := value.(type) {\n\tcase []interface{}:\n\t\t// If we have been given a slice of interface, expand it when appending.\n\t\tarray = append(array, v...)\n\tdefault:\n\t\tarray = append(array, v)\n\t}\n\n\t_, err := g.Set(array, hierarchy...)\n\n\treturn err\n}\n\n// ArrayConcatP attempts to append a value onto a JSON array at a path using dot\n// notation. If the target is not a JSON array then it will be converted into one,\n// with its original contents set to the first element of the array.\n//\n// ArrayConcatP differs from ArrayAppendP in that it will expand a value type\n// []interface{} during the append operation, resulting in concatenation of each\n// element, rather than append as a single element of []interface{}.\nfunc (g *Container) ArrayConcatP(value interface{}, path string) error {\n\treturn g.ArrayConcat(value, DotPathToSlice(path)...)\n}\n\n// ArrayRemove attempts to remove an element identified by an index from a JSON\n// array at a path.\nfunc (g *Container) ArrayRemove(index int, hierarchy ...string) error {\n\tif index < 0 {\n\t\treturn ErrOutOfBounds\n\t}\n\tarray, ok := g.Search(hierarchy...).Data().([]interface{})\n\tif !ok {\n\t\treturn ErrNotArray\n\t}\n\tif index < len(array) {\n\t\tarray = append(array[:index], array[index+1:]...)\n\t} else {\n\t\treturn ErrOutOfBounds\n\t}\n\t_, err := g.Set(array, hierarchy...)\n\treturn err\n}\n\n// ArrayRemoveP attempts to remove an element identified by an index from a JSON\n// array at a path using dot notation.\nfunc (g *Container) ArrayRemoveP(index int, path string) error {\n\treturn g.ArrayRemove(index, DotPathToSlice(path)...)\n}\n\n// ArrayElement attempts to access an element by an index from a JSON array at a\n// path.\nfunc (g *Container) ArrayElement(index int, hierarchy ...string) (*Container, error) {\n\tif index < 0 {\n\t\treturn nil, ErrOutOfBounds\n\t}\n\tarray, ok := g.Search(hierarchy...).Data().([]interface{})\n\tif !ok {\n\t\treturn nil, ErrNotArray\n\t}\n\tif index < len(array) {\n\t\treturn &Container{array[index]}, nil\n\t}\n\treturn nil, ErrOutOfBounds\n}\n\n// ArrayElementP attempts to access an element by an index from a JSON array at\n// a path using dot notation.\nfunc (g *Container) ArrayElementP(index int, path string) (*Container, error) {\n\treturn g.ArrayElement(index, DotPathToSlice(path)...)\n}\n\n// ArrayCount counts the number of elements in a JSON array at a path.\nfunc (g *Container) ArrayCount(hierarchy ...string) (int, error) {\n\tif array, ok := g.Search(hierarchy...).Data().([]interface{}); ok {\n\t\treturn len(array), nil\n\t}\n\treturn 0, ErrNotArray\n}\n\n// ArrayCountP counts the number of elements in a JSON array at a path using dot\n// notation.\nfunc (g *Container) ArrayCountP(path string) (int, error) {\n\treturn g.ArrayCount(DotPathToSlice(path)...)\n}\n\n//------------------------------------------------------------------------------\n\nfunc walkObject(path string, obj, flat map[string]interface{}, includeEmpty bool) {\n\tif includeEmpty && len(obj) == 0 {\n\t\tflat[path] = struct{}{}\n\t}\n\tfor elePath, v := range obj {\n\t\tif len(path) > 0 {\n\t\t\telePath = path + \".\" + elePath\n\t\t}\n\t\tswitch t := v.(type) {\n\t\tcase map[string]interface{}:\n\t\t\twalkObject(elePath, t, flat, includeEmpty)\n\t\tcase []interface{}:\n\t\t\twalkArray(elePath, t, flat, includeEmpty)\n\t\tdefault:\n\t\t\tflat[elePath] = t\n\t\t}\n\t}\n}\n\nfunc walkArray(path string, arr []interface{}, flat map[string]interface{}, includeEmpty bool) {\n\tif includeEmpty && len(arr) == 0 {\n\t\tflat[path] = []struct{}{}\n\t}\n\tfor i, ele := range arr {\n\t\telePath := strconv.Itoa(i)\n\t\tif len(path) > 0 {\n\t\t\telePath = path + \".\" + elePath\n\t\t}\n\t\tswitch t := ele.(type) {\n\t\tcase map[string]interface{}:\n\t\t\twalkObject(elePath, t, flat, includeEmpty)\n\t\tcase []interface{}:\n\t\t\twalkArray(elePath, t, flat, includeEmpty)\n\t\tdefault:\n\t\t\tflat[elePath] = t\n\t\t}\n\t}\n}\n\n// Flatten a JSON array or object into an object of key/value pairs for each\n// field, where the key is the full path of the structured field in dot path\n// notation matching the spec for the method Path.\n//\n// E.g. the structure `{\"foo\":[{\"bar\":\"1\"},{\"bar\":\"2\"}]}` would flatten into the\n// object: `{\"foo.0.bar\":\"1\",\"foo.1.bar\":\"2\"}`. `{\"foo\": [{\"bar\":[]},{\"bar\":{}}]}`\n// would flatten into the object `{}`\n//\n// Returns an error if the target is not a JSON object or array.\nfunc (g *Container) Flatten() (map[string]interface{}, error) {\n\treturn g.flatten(false)\n}\n\n// FlattenIncludeEmpty a JSON array or object into an object of key/value pairs\n// for each field, just as Flatten, but includes empty arrays and objects, where\n// the key is the full path of the structured field in dot path notation matching\n// the spec for the method Path.\n//\n// E.g. the structure `{\"foo\": [{\"bar\":[]},{\"bar\":{}}]}` would flatten into the\n// object: `{\"foo.0.bar\":[],\"foo.1.bar\":{}}`.\n//\n// Returns an error if the target is not a JSON object or array.\nfunc (g *Container) FlattenIncludeEmpty() (map[string]interface{}, error) {\n\treturn g.flatten(true)\n}\n\nfunc (g *Container) flatten(includeEmpty bool) (map[string]interface{}, error) {\n\tflattened := map[string]interface{}{}\n\tswitch t := g.Data().(type) {\n\tcase map[string]interface{}:\n\t\twalkObject(\"\", t, flattened, includeEmpty)\n\tcase []interface{}:\n\t\twalkArray(\"\", t, flattened, includeEmpty)\n\tdefault:\n\t\treturn nil, ErrNotObjOrArray\n\t}\n\treturn flattened, nil\n}\n\n//------------------------------------------------------------------------------\n\n// Bytes marshals an element to a JSON []byte blob.\nfunc (g *Container) Bytes() []byte {\n\tif data, err := json.Marshal(g.Data()); err == nil {\n\t\treturn data\n\t}\n\treturn []byte(\"null\")\n}\n\n// BytesIndent marshals an element to a JSON []byte blob formatted with a prefix\n// and indent string.\nfunc (g *Container) BytesIndent(prefix, indent string) []byte {\n\tif g.object != nil {\n\t\tif data, err := json.MarshalIndent(g.Data(), prefix, indent); err == nil {\n\t\t\treturn data\n\t\t}\n\t}\n\treturn []byte(\"null\")\n}\n\n// String marshals an element to a JSON formatted string.\nfunc (g *Container) String() string {\n\treturn string(g.Bytes())\n}\n\n// StringIndent marshals an element to a JSON string formatted with a prefix and\n// indent string.\nfunc (g *Container) StringIndent(prefix, indent string) string {\n\treturn string(g.BytesIndent(prefix, indent))\n}\n\n// EncodeOpt is a functional option for the EncodeJSON method.\ntype EncodeOpt func(e *json.Encoder)\n\n// EncodeOptHTMLEscape sets the encoder to escape the JSON for html.\nfunc EncodeOptHTMLEscape(doEscape bool) EncodeOpt {\n\treturn func(e *json.Encoder) {\n\t\te.SetEscapeHTML(doEscape)\n\t}\n}\n\n// EncodeOptIndent sets the encoder to indent the JSON output.\nfunc EncodeOptIndent(prefix, indent string) EncodeOpt {\n\treturn func(e *json.Encoder) {\n\t\te.SetIndent(prefix, indent)\n\t}\n}\n\n// EncodeJSON marshals an element to a JSON formatted []byte using a variant\n// list of modifier functions for the encoder being used. Functions for\n// modifying the output are prefixed with EncodeOpt, e.g. EncodeOptHTMLEscape.\nfunc (g *Container) EncodeJSON(encodeOpts ...EncodeOpt) []byte {\n\tvar b bytes.Buffer\n\tencoder := json.NewEncoder(&b)\n\tencoder.SetEscapeHTML(false) // Do not escape by default.\n\tfor _, opt := range encodeOpts {\n\t\topt(encoder)\n\t}\n\tif err := encoder.Encode(g.object); err != nil {\n\t\treturn []byte(\"null\")\n\t}\n\tresult := b.Bytes()\n\tif len(result) > 0 {\n\t\tresult = result[:len(result)-1]\n\t}\n\treturn result\n}\n\n// New creates a new gabs JSON object.\nfunc New() *Container {\n\treturn &Container{map[string]interface{}{}}\n}\n\n// Wrap an already unmarshalled JSON object (or a new map[string]interface{})\n// into a *Container.\nfunc Wrap(root interface{}) *Container {\n\treturn &Container{root}\n}\n\n// ParseJSON unmarshals a JSON byte slice into a *Container.\nfunc ParseJSON(sample []byte) (*Container, error) {\n\tvar gabs Container\n\n\tif err := json.Unmarshal(sample, &gabs.object); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &gabs, nil\n}\n\n// ParseJSONDecoder applies a json.Decoder to a *Container.\nfunc ParseJSONDecoder(decoder *json.Decoder) (*Container, error) {\n\tvar gabs Container\n\n\tif err := decoder.Decode(&gabs.object); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &gabs, nil\n}\n\n// ParseJSONFile reads a file and unmarshals the contents into a *Container.\nfunc ParseJSONFile(path string) (*Container, error) {\n\tif len(path) > 0 {\n\t\tcBytes, err := os.ReadFile(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcontainer, err := ParseJSON(cBytes)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn container, nil\n\t}\n\treturn nil, ErrInvalidPath\n}\n\n// ParseJSONBuffer reads a buffer and unmarshals the contents into a *Container.\nfunc ParseJSONBuffer(buffer io.Reader) (*Container, error) {\n\tvar gabs Container\n\tjsonDecoder := json.NewDecoder(buffer)\n\tif err := jsonDecoder.Decode(&gabs.object); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &gabs, nil\n}\n\n// MarshalJSON returns the JSON encoding of this container. This allows\n// structs which contain Container instances to be marshaled using\n// json.Marshal().\nfunc (g *Container) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(g.Data())\n}\n\n//------------------------------------------------------------------------------\n"
        },
        {
          "name": "gabs_logo.png",
          "type": "blob",
          "size": 163.8388671875,
          "content": null
        },
        {
          "name": "gabs_test.go",
          "type": "blob",
          "size": 45.59375,
          "content": "package gabs\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestBasic(t *testing.T) {\n\tsample := []byte(`{\"test\":{\"value\":10},\"test2\":20}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tif result, ok := val.Search([]string{\"test\", \"value\"}...).Data().(float64); ok {\n\t\tif result != 10 {\n\t\t\tt.Errorf(\"Wrong value of result: %v\", result)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Didn't find test.value\")\n\t}\n\n\tif _, ok := val.Search(\"test2\", \"value\").Data().(string); ok {\n\t\tt.Errorf(\"Somehow found a field that shouldn't exist\")\n\t}\n\n\tif result, ok := val.Search(\"test2\").Data().(float64); ok {\n\t\tif result != 20 {\n\t\t\tt.Errorf(\"Wrong value of result: %v\", result)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Didn't find test2\")\n\t}\n\n\tif result := val.Bytes(); !bytes.Equal(result, sample) {\n\t\tt.Errorf(\"Wrong []byte conversion: %s != %s\", result, sample)\n\t}\n}\n\nfunc TestNilMethods(t *testing.T) {\n\tvar n *Container\n\tif exp, act := \"null\", n.String(); exp != act {\n\t\tt.Errorf(\"Unexpected value: %v != %v\", act, exp)\n\t}\n\tif exp, act := \"null\", string(n.Bytes()); exp != act {\n\t\tt.Errorf(\"Unexpected value: %v != %v\", act, exp)\n\t}\n\tif n.Search(\"foo\", \"bar\") != nil {\n\t\tt.Error(\"non nil result\")\n\t}\n\tif n.Path(\"foo.bar\") != nil {\n\t\tt.Error(\"non nil result\")\n\t}\n\tif _, err := n.Array(\"foo\"); err == nil {\n\t\tt.Error(\"expected error\")\n\t}\n\tif err := n.ArrayAppend(\"foo\", \"bar\"); err == nil {\n\t\tt.Error(\"expected error\")\n\t}\n\tif err := n.ArrayRemove(1, \"foo\", \"bar\"); err == nil {\n\t\tt.Error(\"expected error\")\n\t}\n\tif n.Exists(\"foo\", \"bar\") {\n\t\tt.Error(\"expected false\")\n\t}\n\tif n.Index(1) != nil {\n\t\tt.Error(\"non nil result\")\n\t}\n\tif n.Children() != nil {\n\t\tt.Error(\"non nil result\")\n\t}\n\tif len(n.ChildrenMap()) > 0 {\n\t\tt.Error(\"non nil result\")\n\t}\n\tif err := n.Delete(\"foo\"); err == nil {\n\t\tt.Error(\"expected error\")\n\t}\n}\n\nvar bigSample = []byte(`{\n\t\"a\": {\n\t\t\"nested1\": {\n\t\t\t\"value1\": 5\n\t\t}\n\t},\n\t\"\": {\n\t\t\"can we access\": \"this?\"\n\t},\n\t\"what/a/pain\": \"ouch1\",\n\t\"what~a~pain\": \"ouch2\",\n\t\"what~/a/~pain\": \"ouch3\",\n\t\"what.a.pain\": \"ouch4\",\n\t\"what~.a.~pain\": \"ouch5\",\n\t\"b\": 10,\n\t\"c\": [\n\t\t\"first\",\n\t\t\"second\",\n\t\t{\n\t\t\t\"nested2\": {\n\t\t\t\t\"value2\": 15\n\t\t\t}\n\t\t},\n\t\t[\n\t\t\t\"fifth\",\n\t\t\t\"sixth\"\n\t\t],\n\t\t\"fourth\"\n\t],\n\t\"d\": {\n\t\t\"\": {\n\t\t\t\"what about\": \"this?\"\n\t\t}\n\t}\n}`)\n\nfunc TestJSONPointer(t *testing.T) {\n\ttype testCase struct {\n\t\tpath  string\n\t\tvalue string\n\t\terr   string\n\t\tinput string\n\t}\n\ttests := []testCase{\n\t\t{\n\t\t\tpath: \"foo\",\n\t\t\terr:  \"failed to resolve JSON pointer: path must begin with '/'\",\n\t\t},\n\t\t{\n\t\t\tpath:  \"\",\n\t\t\tvalue: `{\"whole\":{\"document\":\"is this\"}}`,\n\t\t\tinput: `{\"whole\":{\"document\":\"is this\"}}`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/\",\n\t\t\tvalue: `{\"\":{\"b\":\"value b\"},\"a\":\"value a\"}`,\n\t\t\tinput: `{\"\":{\"a\":\"value a\",\"\":{\"b\":\"value b\"}}}`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"//\",\n\t\t\tvalue: `{\"b\":\"value b\"}`,\n\t\t\tinput: `{\"\":{\"a\":\"value a\",\"\":{\"b\":\"value b\"}}}`,\n\t\t},\n\t\t{\n\t\t\tpath: \"/a/doesnotexist\",\n\t\t\terr:  \"failed to resolve path segment '1': key 'doesnotexist' was not found\",\n\t\t},\n\t\t{\n\t\t\tpath:  \"/a\",\n\t\t\tvalue: `{\"nested1\":{\"value1\":5}}`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/what~1a~1pain\",\n\t\t\tvalue: `\"ouch1\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/what~0a~0pain\",\n\t\t\tvalue: `\"ouch2\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/what~0~1a~1~0pain\",\n\t\t\tvalue: `\"ouch3\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/what.a.pain\",\n\t\t\tvalue: `\"ouch4\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/what~0.a.~0pain\",\n\t\t\tvalue: `\"ouch5\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"//can we access\",\n\t\t\tvalue: `\"this?\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/d/\",\n\t\t\tvalue: `{\"what about\":\"this?\"}`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/d//what about\",\n\t\t\tvalue: `\"this?\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/c/1\",\n\t\t\tvalue: `\"second\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"/c/2/nested2/value2\",\n\t\t\tvalue: `15`,\n\t\t},\n\t\t{\n\t\t\tpath: \"/c/notindex/value2\",\n\t\t\terr:  `failed to resolve path segment '1': found array but segment value 'notindex' could not be parsed into array index: strconv.Atoi: parsing \"notindex\": invalid syntax`,\n\t\t},\n\t\t{\n\t\t\tpath: \"/c/10/value2\",\n\t\t\terr:  `failed to resolve path segment '1': found array but index '10' exceeded target array size of '5'`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.path, func(tt *testing.T) {\n\t\t\tinput := test.input\n\t\t\tif input == \"\" {\n\t\t\t\tinput = string(bigSample)\n\t\t\t}\n\t\t\troot, err := ParseJSON([]byte(input))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse: %v\", err)\n\t\t\t}\n\n\t\t\tvar result *Container\n\t\t\tresult, err = root.JSONPointer(test.path)\n\t\t\tif len(test.err) > 0 {\n\t\t\t\tif err == nil {\n\t\t\t\t\ttt.Errorf(\"Expected error: %v\", test.err)\n\t\t\t\t} else if exp, act := test.err, err.Error(); exp != act {\n\t\t\t\t\ttt.Errorf(\"Wrong error returned: %v != %v\", act, exp)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if err != nil {\n\t\t\t\ttt.Fatal(err)\n\t\t\t}\n\t\t\tif exp, act := test.value, result.String(); exp != act {\n\t\t\t\ttt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDotPath(t *testing.T) {\n\ttype testCase struct {\n\t\tpath  string\n\t\tvalue string\n\t}\n\ttests := []testCase{\n\t\t{\n\t\t\tpath:  \"foo\",\n\t\t\tvalue: \"null\",\n\t\t},\n\t\t{\n\t\t\tpath:  \"a.doesnotexist\",\n\t\t\tvalue: \"null\",\n\t\t},\n\t\t{\n\t\t\tpath:  \"a\",\n\t\t\tvalue: `{\"nested1\":{\"value1\":5}}`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"what/a/pain\",\n\t\t\tvalue: `\"ouch1\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"what~0a~0pain\",\n\t\t\tvalue: `\"ouch2\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"what~0/a/~0pain\",\n\t\t\tvalue: `\"ouch3\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"what~1a~1pain\",\n\t\t\tvalue: `\"ouch4\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"what~0~1a~1~0pain\",\n\t\t\tvalue: `\"ouch5\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"\",\n\t\t\tvalue: `{\"can we access\":\"this?\"}`,\n\t\t},\n\t\t{\n\t\t\tpath:  \".can we access\",\n\t\t\tvalue: `\"this?\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"d.\",\n\t\t\tvalue: `{\"what about\":\"this?\"}`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"d..what about\",\n\t\t\tvalue: `\"this?\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"c.1\",\n\t\t\tvalue: `\"second\"`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"c.2.nested2.value2\",\n\t\t\tvalue: `15`,\n\t\t},\n\t\t{\n\t\t\tpath:  \"c.notindex.value2\",\n\t\t\tvalue: \"null\",\n\t\t},\n\t\t{\n\t\t\tpath:  \"c.10.value2\",\n\t\t\tvalue: \"null\",\n\t\t},\n\t}\n\n\troot, err := ParseJSON(bigSample)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse: %v\", err)\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.path, func(tt *testing.T) {\n\t\t\tresult := root.Path(test.path)\n\t\t\tif exp, act := test.value, result.String(); exp != act {\n\t\t\t\ttt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestArrayWildcard(t *testing.T) {\n\tsample := []byte(`{\"test\":[{\"value\":10},{\"value\":20}]}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse: %v\", err)\n\t}\n\n\tif act, ok := val.Search([]string{\"test\", \"0\", \"value\"}...).Data().(float64); ok {\n\t\tif exp := float64(10); !reflect.DeepEqual(act, exp) {\n\t\t\tt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Didn't find test.0.value\")\n\t}\n\n\tif act, ok := val.Search([]string{\"test\", \"1\", \"value\"}...).Data().(float64); ok {\n\t\tif exp := float64(20); !reflect.DeepEqual(act, exp) {\n\t\t\tt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Didn't find test.1.value\")\n\t}\n\n\tif act, ok := val.Search([]string{\"test\", \"*\", \"value\"}...).Data().([]interface{}); ok {\n\t\tif exp := []interface{}{float64(10), float64(20)}; !reflect.DeepEqual(act, exp) {\n\t\t\tt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Didn't find test.*.value\")\n\t}\n\n\tif act := val.Search([]string{\"test\", \"*\", \"notmatched\"}...); act != nil {\n\t\tt.Errorf(\"Expected nil result, received: %v\", act)\n\t}\n\n\tif act, ok := val.Search([]string{\"test\", \"*\"}...).Data().([]interface{}); ok {\n\t\tif exp := []interface{}{map[string]interface{}{\"value\": float64(10)}, map[string]interface{}{\"value\": float64(20)}}; !reflect.DeepEqual(act, exp) {\n\t\t\tt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Didn't find test.*.value\")\n\t}\n}\n\nfunc TestArrayAppendWithSet(t *testing.T) {\n\tgObj := New()\n\tif _, err := gObj.Set([]interface{}{}, \"foo\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := gObj.Set(1, \"foo\", \"-\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := gObj.Set([]interface{}{}, \"foo\", \"-\", \"baz\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := gObj.Set(2, \"foo\", \"1\", \"baz\", \"-\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := gObj.Set(3, \"foo\", \"1\", \"baz\", \"-\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := gObj.Set(4, \"foo\", \"-\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texp := `{\"foo\":[1,{\"baz\":[2,3]},4]}`\n\tif act := gObj.String(); act != exp {\n\t\tt.Errorf(\"Unexpected value: %v != %v\", act, exp)\n\t}\n}\n\nfunc TestExists(t *testing.T) {\n\tsample := []byte(`{\"test\":{\"value\":10,\"nullvalue\":null},\"test2\":20,\"testnull\":null}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tpaths := []struct {\n\t\tPath   []string\n\t\tExists bool\n\t}{\n\t\t{[]string{\"one\", \"two\", \"three\"}, false},\n\t\t{[]string{\"test\"}, true},\n\t\t{[]string{\"test\", \"value\"}, true},\n\t\t{[]string{\"test\", \"nullvalue\"}, true},\n\t\t{[]string{\"test2\"}, true},\n\t\t{[]string{\"testnull\"}, true},\n\t\t{[]string{\"test2\", \"value\"}, false},\n\t\t{[]string{\"test\", \"value2\"}, false},\n\t\t{[]string{\"test\", \"VALUE\"}, false},\n\t}\n\n\tfor _, p := range paths {\n\t\tif exp, actual := p.Exists, val.Exists(p.Path...); exp != actual {\n\t\t\tt.Errorf(\"Wrong result from Exists: %v != %v, for path: %v\", exp, actual, p.Path)\n\t\t}\n\t\tif exp, actual := p.Exists, val.ExistsP(strings.Join(p.Path, \".\")); exp != actual {\n\t\t\tt.Errorf(\"Wrong result from ExistsP: %v != %v, for path: %v\", exp, actual, p.Path)\n\t\t}\n\t}\n}\n\nfunc TestExistsWithArrays(t *testing.T) {\n\tsample := []byte(`{\"foo\":{\"bar\":{\"baz\":[10, 2, 3]}}}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tif exp, actual := true, val.Exists(\"foo\", \"bar\", \"baz\"); exp != actual {\n\t\tt.Errorf(\"Wrong result from array based Exists: %v != %v\", exp, actual)\n\t}\n\n\tsample = []byte(`{\"foo\":{\"bar\":[{\"baz\":10},{\"baz\":2},{\"baz\":3}]}}`)\n\n\tif val, err = ParseJSON(sample); err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tif exp, actual := true, val.Exists(\"foo\", \"bar\", \"0\", \"baz\"); exp != actual {\n\t\tt.Errorf(\"Wrong result from array based Exists: %v != %v\", exp, actual)\n\t}\n\tif exp, actual := false, val.Exists(\"foo\", \"bar\", \"1\", \"baz_NOPE\"); exp != actual {\n\t\tt.Errorf(\"Wrong result from array based Exists: %v != %v\", exp, actual)\n\t}\n\n\tsample = []byte(`{\"foo\":[{\"bar\":{\"baz\":10}},{\"bar\":{\"baz\":2}},{\"bar\":{\"baz\":3}}]}`)\n\n\tif val, err = ParseJSON(sample); err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tif exp, actual := true, val.Exists(\"foo\", \"0\", \"bar\", \"baz\"); exp != actual {\n\t\tt.Errorf(\"Wrong result from array based Exists: %v != %v\", exp, actual)\n\t}\n\tif exp, actual := false, val.Exists(\"foo\", \"0\", \"bar\", \"baz_NOPE\"); exp != actual {\n\t\tt.Errorf(\"Wrong result from array based Exists: %v != %v\", exp, actual)\n\t}\n\n\tsample =\n\t\t[]byte(`[{\"foo\":{\"bar\":{\"baz\":10}}},{\"foo\":{\"bar\":{\"baz\":2}}},{\"foo\":{\"bar\":{\"baz\":3}}}]`)\n\n\tif val, err = ParseJSON(sample); err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tif exp, actual := true, val.Exists(\"0\", \"foo\", \"bar\", \"baz\"); exp != actual {\n\t\tt.Errorf(\"Wrong result from array based Exists: %v != %v\", exp, actual)\n\t}\n\tif exp, actual := false, val.Exists(\"0\", \"foo\", \"bar\", \"baz_NOPE\"); exp != actual {\n\t\tt.Errorf(\"Wrong result from array based Exists: %v != %v\", exp, actual)\n\t}\n}\n\nfunc TestBasicWithBuffer(t *testing.T) {\n\tsample := bytes.NewReader([]byte(`{\"test\":{\"value\":10},\"test2\":20}`))\n\n\t_, err := ParseJSONBuffer(sample)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n}\n\nfunc TestBasicWithDecoder(t *testing.T) {\n\tsample := []byte(`{\"test\":{\"int\":10, \"float\":6.66}}`)\n\tdec := json.NewDecoder(bytes.NewReader(sample))\n\tdec.UseNumber()\n\n\tval, err := ParseJSONDecoder(dec)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tcheckNumber := func(path string, expectedVal json.Number) {\n\t\tdata := val.Path(path).Data()\n\t\tasNumber, isNumber := data.(json.Number)\n\t\tif !isNumber {\n\t\t\tt.Error(\"Failed to parse using decoder UseNumber policy\")\n\t\t}\n\t\tif expectedVal != asNumber {\n\t\t\tt.Errorf(\"Expected[%s] but got [%s]\", expectedVal, asNumber)\n\t\t}\n\t}\n\n\tcheckNumber(\"test.int\", \"10\")\n\tcheckNumber(\"test.float\", \"6.66\")\n}\n\nfunc TestFailureWithDecoder(t *testing.T) {\n\tsample := []byte(`{\"test\":{\" \"invalidCrap\":.66}}`)\n\tdec := json.NewDecoder(bytes.NewReader(sample))\n\n\t_, err := ParseJSONDecoder(dec)\n\tif err == nil {\n\t\tt.Fatal(\"Expected parsing error\")\n\t}\n}\n\nfunc TestDeletes(t *testing.T) {\n\tjsonParsed, _ := ParseJSON([]byte(`{\n\t\t\"outter\":{\n\t\t\t\"inner\":{\n\t\t\t\t\"value1\":10,\n\t\t\t\t\"value2\":22,\n\t\t\t\t\"value3\":32\n\t\t\t},\n\t\t\t\"alsoInner\":{\n\t\t\t\t\"value1\":20,\n\t\t\t\t\"value2\":42,\n\t\t\t\t\"value3\":92\n\t\t\t},\n\t\t\t\"another\":{\n\t\t\t\t\"value1\":null,\n\t\t\t\t\"value2\":null,\n\t\t\t\t\"value3\":null\n\t\t\t}\n\t\t}\n\t}`))\n\n\tif err := jsonParsed.Delete(\"outter\", \"inner\", \"value2\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := jsonParsed.Delete(\"outter\", \"inner\", \"value4\"); err == nil {\n\t\tt.Error(\"value4 should not have been found in outter.inner\")\n\t}\n\tif err := jsonParsed.Delete(\"outter\", \"another\", \"value1\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := jsonParsed.Delete(\"outter\", \"another\", \"value4\"); err == nil {\n\t\tt.Error(\"value4 should not have been found in outter.another\")\n\t}\n\tif err := jsonParsed.DeleteP(\"outter.alsoInner.value1\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := jsonParsed.DeleteP(\"outter.alsoInner.value4\"); err == nil {\n\t\tt.Error(\"value4 should not have been found in outter.alsoInner\")\n\t}\n\tif err := jsonParsed.DeleteP(\"outter.another.value2\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := jsonParsed.Delete(\"outter.another.value4\"); err == nil {\n\t\tt.Error(\"value4 should not have been found in outter.another\")\n\t}\n\n\texpected := `{\"outter\":{\"alsoInner\":{\"value2\":42,\"value3\":92},\"another\":{\"value3\":null},\"inner\":{\"value1\":10,\"value3\":32}}}`\n\tif actual := jsonParsed.String(); actual != expected {\n\t\tt.Errorf(\"Unexpected result from deletes: %v != %v\", actual, expected)\n\t}\n}\n\nfunc TestDeletesWithArrays(t *testing.T) {\n\trawJSON := `{\n\t\t\"outter\":[\n\t\t\t{\n\t\t\t\t\"foo\":{\n\t\t\t\t\t\"value1\":10,\n\t\t\t\t\t\"value2\":22,\n\t\t\t\t\t\"value3\":32\n\t\t\t\t},\n\t\t\t\t\"bar\": [\n\t\t\t\t\t20,\n\t\t\t\t\t42,\n\t\t\t\t\t92\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"baz\":{\n\t\t\t\t\t\"value1\":null,\n\t\t\t\t\t\"value2\":null,\n\t\t\t\t\t\"value3\":null\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}`\n\n\tjsonParsed, err := ParseJSON([]byte(rawJSON))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = jsonParsed.Delete(\"outter\", \"1\", \"baz\", \"value1\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\texpected := `{\"outter\":[{\"bar\":[20,42,92],\"foo\":{\"value1\":10,\"value2\":22,\"value3\":32}},{\"baz\":{\"value2\":null,\"value3\":null}}]}`\n\tif actual := jsonParsed.String(); actual != expected {\n\t\tt.Errorf(\"Unexpected result from array deletes: %v != %v\", actual, expected)\n\t}\n\n\tjsonParsed, err = ParseJSON([]byte(rawJSON))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = jsonParsed.Delete(\"outter\", \"1\", \"baz\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\texpected = `{\"outter\":[{\"bar\":[20,42,92],\"foo\":{\"value1\":10,\"value2\":22,\"value3\":32}},{}]}`\n\tif actual := jsonParsed.String(); actual != expected {\n\t\tt.Errorf(\"Unexpected result from array deletes: %v != %v\", actual, expected)\n\t}\n\n\tjsonParsed, err = ParseJSON([]byte(rawJSON))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = jsonParsed.Delete(\"outter\", \"1\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\texpected = `{\"outter\":[{\"bar\":[20,42,92],\"foo\":{\"value1\":10,\"value2\":22,\"value3\":32}}]}`\n\tif actual := jsonParsed.String(); actual != expected {\n\t\tt.Errorf(\"Unexpected result from array deletes: %v != %v\", actual, expected)\n\t}\n\n\tjsonParsed, err = ParseJSON([]byte(rawJSON))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = jsonParsed.Delete(\"outter\", \"0\", \"bar\", \"0\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\texpected = `{\"outter\":[{\"bar\":[42,92],\"foo\":{\"value1\":10,\"value2\":22,\"value3\":32}},{\"baz\":{\"value1\":null,\"value2\":null,\"value3\":null}}]}`\n\tif actual := jsonParsed.String(); actual != expected {\n\t\tt.Errorf(\"Unexpected result from array deletes: %v != %v\", actual, expected)\n\t}\n\n\tjsonParsed, err = ParseJSON([]byte(rawJSON))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = jsonParsed.Delete(\"outter\", \"0\", \"bar\", \"1\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\texpected = `{\"outter\":[{\"bar\":[20,92],\"foo\":{\"value1\":10,\"value2\":22,\"value3\":32}},{\"baz\":{\"value1\":null,\"value2\":null,\"value3\":null}}]}`\n\tif actual := jsonParsed.String(); actual != expected {\n\t\tt.Errorf(\"Unexpected result from array deletes: %v != %v\", actual, expected)\n\t}\n\n\tjsonParsed, err = ParseJSON([]byte(rawJSON))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = jsonParsed.Delete(\"outter\", \"0\", \"bar\", \"2\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\texpected = `{\"outter\":[{\"bar\":[20,42],\"foo\":{\"value1\":10,\"value2\":22,\"value3\":32}},{\"baz\":{\"value1\":null,\"value2\":null,\"value3\":null}}]}`\n\tif actual := jsonParsed.String(); actual != expected {\n\t\tt.Errorf(\"Unexpected result from array deletes: %v != %v\", actual, expected)\n\t}\n}\n\nfunc TestExamples(t *testing.T) {\n\tjsonParsed, err := ParseJSON([]byte(`{\n\t\"outter\":{\n\t\t\"inner\":{\n\t\t\t\"value1\":10,\n\t\t\t\"value2\":22\n\t\t},\n\t\t\"contains.dots.in.key\":{\n\t\t\t\"value1\":11\n\t\t},\n\t\t\"contains~tildes~in~key\":{\n\t\t\t\"value1\":12\n\t\t},\n\t\t\"alsoInner\":{\n\t\t\t\"value1\":20,\n\t\t\t\"array1\":[\n\t\t\t\t30, 40\n\t\t\t]\n\t\t}\n\t}\n}`))\n\tif err != nil {\n\t\tt.Errorf(\"Error: %v\", err)\n\t\treturn\n\t}\n\n\tvar value float64\n\tvar ok bool\n\n\tvalue, ok = jsonParsed.Path(\"outter.inner.value1\").Data().(float64)\n\tif value != 10.0 || !ok {\n\t\tt.Errorf(\"wrong value: %v, %v\", value, ok)\n\t}\n\n\tvalue, ok = jsonParsed.Path(\"outter.contains~1dots~1in~1key.value1\").Data().(float64)\n\tif value != 11.0 || !ok {\n\t\tt.Errorf(\"wrong value: %v, %v\", value, ok)\n\t}\n\n\tvalue, ok = jsonParsed.Path(\"outter.contains~0tildes~0in~0key.value1\").Data().(float64)\n\tif value != 12.0 || !ok {\n\t\tt.Errorf(\"wrong value: %v, %v\", value, ok)\n\t}\n\n\tvalue, ok = jsonParsed.Search(\"outter\", \"inner\", \"value1\").Data().(float64)\n\tif value != 10.0 || !ok {\n\t\tt.Errorf(\"wrong value: %v, %v\", value, ok)\n\t}\n\n\tgObj, err := jsonParsed.JSONPointer(\"/outter/alsoInner/array1/1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvalue, ok = gObj.Data().(float64)\n\tif value != 40.0 || !ok {\n\t\tt.Errorf(\"wrong value: %v, %v\", value, ok)\n\t}\n\n\tvalue, ok = jsonParsed.Path(\"does.not.exist\").Data().(float64)\n\tif value != 0.0 || ok {\n\t\tt.Errorf(\"wrong value: %v, %v\", value, ok)\n\t}\n\n\tjsonParsed, _ = ParseJSON([]byte(`{\"array\":[ \"first\", \"second\", \"third\" ]}`))\n\n\texpected := []string{\"first\", \"second\", \"third\"}\n\n\tchildren := jsonParsed.S(\"array\").Children()\n\tfor i, child := range children {\n\t\tif expected[i] != child.Data().(string) {\n\t\t\tt.Errorf(\"Child unexpected: %v != %v\", expected[i], child.Data().(string))\n\t\t}\n\t}\n}\n\nfunc TestSetAppendArray(t *testing.T) {\n\tcontent := []byte(`{\n\t\"nested\": {\n\t\t\"source\": [\n\t\t\t\"foo\", \"bar\"\n\t\t]\n\t}\n}`)\n\n\tgObj, err := ParseJSON(content)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err = gObj.Set(\"baz\", \"nested\", \"source\", \"-\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texp := `{\"nested\":{\"source\":[\"foo\",\"bar\",\"baz\"]}}`\n\tif act := gObj.String(); act != exp {\n\t\tt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t}\n}\n\nfunc TestExamples2(t *testing.T) {\n\tvar err error\n\n\tjsonObj := New()\n\n\t_, err = jsonObj.Set(10, \"outter\", \"inner\", \"value\")\n\tif err != nil {\n\t\tt.Errorf(\"Error: %v\", err)\n\t\treturn\n\t}\n\t_, err = jsonObj.SetP(20, \"outter.inner.value2\")\n\tif err != nil {\n\t\tt.Errorf(\"Error: %v\", err)\n\t\treturn\n\t}\n\t_, err = jsonObj.Set(30, \"outter\", \"inner2\", \"value3\")\n\tif err != nil {\n\t\tt.Errorf(\"Error: %v\", err)\n\t\treturn\n\t}\n\n\texpected := `{\"outter\":{\"inner\":{\"value\":10,\"value2\":20},\"inner2\":{\"value3\":30}}}`\n\tif jsonObj.String() != expected {\n\t\tt.Errorf(\"Non matched output: %v != %v\", expected, jsonObj.String())\n\t}\n\n\tjsonObj = Wrap(map[string]interface{}{})\n\n\tjsonObj.Array(\"array\")\n\n\tjsonObj.ArrayAppend(10, \"array\")\n\tjsonObj.ArrayAppend(20, \"array\")\n\tjsonObj.ArrayAppend(30, \"array\")\n\n\texpected = `{\n      \"array\": [\n        10,\n        20,\n        30\n      ]\n    }`\n\tresult := jsonObj.StringIndent(\"    \", \"  \")\n\tif result != expected {\n\t\tt.Errorf(\"Non matched output: %v != %v\", expected, result)\n\t}\n}\n\nfunc TestExamples3(t *testing.T) {\n\tjsonObj := New()\n\n\tjsonObj.ArrayP(\"foo.array\")\n\n\tjsonObj.ArrayAppend(10, \"foo\", \"array\")\n\tjsonObj.ArrayAppend(20, \"foo\", \"array\")\n\tjsonObj.ArrayAppend(30, \"foo\", \"array\")\n\n\tresult := jsonObj.String()\n\texpected := `{\"foo\":{\"array\":[10,20,30]}}`\n\n\tif result != expected {\n\t\tt.Errorf(\"Non matched output: %v != %v\", result, expected)\n\t}\n}\n\nfunc TestArrayConcat(t *testing.T) {\n\tjsonObj := New()\n\n\tjsonObj.ArrayP(\"foo.array\")\n\n\tjsonObj.ArrayConcat(10, \"foo\", \"array\")\n\tjsonObj.ArrayConcat([]interface{}{20, 30}, \"foo\", \"array\")\n\n\tresult := jsonObj.String()\n\texpected := `{\"foo\":{\"array\":[10,20,30]}}`\n\n\tif result != expected {\n\t\tt.Errorf(\"Non matched output: %v != %v\", result, expected)\n\t}\n\n\tjsonObj = New()\n\n\tjsonObj.ArrayP(\"foo.array\")\n\n\tjsonObj.ArrayConcat([]interface{}{10, 20}, \"foo\", \"array\")\n\tjsonObj.ArrayConcat(30, \"foo\", \"array\")\n\n\tresult = jsonObj.String()\n\texpected = `{\"foo\":{\"array\":[10,20,30]}}`\n\n\tif result != expected {\n\t\tt.Errorf(\"Non matched output: %v != %v\", result, expected)\n\t}\n\n\tjsonObj = New()\n\n\tjsonObj.ArrayP(\"foo.array\")\n\n\tjsonObj.ArrayConcat([]interface{}{10}, \"foo\", \"array\")\n\tjsonObj.ArrayConcat([]interface{}{20}, \"foo\", \"array\")\n\tjsonObj.ArrayConcat([]interface{}{30}, \"foo\", \"array\")\n\n\tresult = jsonObj.String()\n\texpected = `{\"foo\":{\"array\":[10,20,30]}}`\n\n\tif result != expected {\n\t\tt.Errorf(\"Non matched output: %v != %v\", result, expected)\n\t}\n}\n\nfunc TestArrayConcatP(t *testing.T) {\n\tjsonObj := New()\n\n\tjsonObj.ArrayP(\"foo.array\")\n\n\tjsonObj.ArrayConcatP(10, \"foo.array\")\n\tjsonObj.ArrayConcatP([]interface{}{20, 30}, \"foo.array\")\n\n\tresult := jsonObj.String()\n\texpected := `{\"foo\":{\"array\":[10,20,30]}}`\n\n\tif result != expected {\n\t\tt.Errorf(\"Non matched output: %v != %v\", result, expected)\n\t}\n\n\tjsonObj = New()\n\n\tjsonObj.ArrayP(\"foo.array\")\n\n\tjsonObj.ArrayConcatP([]interface{}{10, 20}, \"foo.array\")\n\tjsonObj.ArrayConcatP(30, \"foo.array\")\n\n\tresult = jsonObj.String()\n\texpected = `{\"foo\":{\"array\":[10,20,30]}}`\n\n\tif result != expected {\n\t\tt.Errorf(\"Non matched output: %v != %v\", result, expected)\n\t}\n\n\tjsonObj = New()\n\n\tjsonObj.ArrayP(\"foo.array\")\n\n\tjsonObj.ArrayConcatP([]interface{}{10}, \"foo.array\")\n\tjsonObj.ArrayConcatP([]interface{}{20}, \"foo.array\")\n\tjsonObj.ArrayConcatP([]interface{}{30}, \"foo.array\")\n\n\tresult = jsonObj.String()\n\texpected = `{\"foo\":{\"array\":[10,20,30]}}`\n\n\tif result != expected {\n\t\tt.Errorf(\"Non matched output: %v != %v\", result, expected)\n\t}\n}\n\nfunc TestDotNotation(t *testing.T) {\n\tsample := []byte(`{\"test\":{\"inner\":{\"value\":10}},\"test2\":20}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tif result, _ := val.Path(\"test.inner.value\").Data().(float64); result != 10 {\n\t\tt.Errorf(\"Expected 10, received: %v\", result)\n\t}\n}\n\nfunc TestModify(t *testing.T) {\n\tsample := []byte(`{\"test\":{\"value\":10},\"test2\":20}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tif _, err := val.S(\"test\").Set(45.0, \"value\"); err != nil {\n\t\tt.Errorf(\"Failed to set field\")\n\t}\n\n\tif result, ok := val.Search([]string{\"test\", \"value\"}...).Data().(float64); ok {\n\t\tif result != 45 {\n\t\t\tt.Errorf(\"Wrong value of result: %v\", result)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Didn't find test.value\")\n\t}\n\n\tif out := val.String(); out != `{\"test\":{\"value\":45},\"test2\":20}` {\n\t\tt.Errorf(\"Incorrectly serialized: %v\", out)\n\t}\n\n\tif out := val.Search(\"test\").String(); out != `{\"value\":45}` {\n\t\tt.Errorf(\"Incorrectly serialized: %v\", out)\n\t}\n}\n\nfunc TestChildren(t *testing.T) {\n\tjson1, _ := ParseJSON([]byte(`{\n\t\t\"objectOne\":{\n\t\t},\n\t\t\"objectTwo\":{\n\t\t},\n\t\t\"objectThree\":{\n\t\t}\n\t}`))\n\n\tobjects := json1.Children()\n\tfor _, object := range objects {\n\t\tobject.Set(\"hello world\", \"child\")\n\t}\n\n\texpected := `{\"objectOne\":{\"child\":\"hello world\"},\"objectThree\":{\"child\":\"hello world\"}` +\n\t\t`,\"objectTwo\":{\"child\":\"hello world\"}}`\n\treceived := json1.String()\n\tif expected != received {\n\t\tt.Errorf(\"json1: expected %v, received %v\", expected, received)\n\t}\n\n\tjson2, _ := ParseJSON([]byte(`{\n\t\t\"values\":[\n\t\t\t{\n\t\t\t\t\"objectOne\":{\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"objectTwo\":{\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"objectThree\":{\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}`))\n\n\tjson3, _ := ParseJSON([]byte(`{\n\t\t\"values\":[\n\t\t]\n\t}`))\n\n\tnumChildren1, _ := json2.ArrayCount(\"values\")\n\tnumChildren2, _ := json3.ArrayCount(\"values\")\n\tif _, err := json3.ArrayCount(\"valuesNOTREAL\"); err == nil {\n\t\tt.Errorf(\"expected numChildren3 to fail\")\n\t}\n\n\tif numChildren1 != 3 || numChildren2 != 0 {\n\t\tt.Errorf(\"CountElements, expected 3 and 0, received %v and %v\",\n\t\t\tnumChildren1, numChildren2)\n\t}\n\n\tobjects = json2.S(\"values\").Children()\n\tfor _, object := range objects {\n\t\tobject.Set(\"hello world\", \"child\")\n\t\tjson3.ArrayAppend(object.Data(), \"values\")\n\t}\n\n\texpected = `{\"values\":[{\"child\":\"hello world\",\"objectOne\":{}},{\"child\":\"hello world\",` +\n\t\t`\"objectTwo\":{}},{\"child\":\"hello world\",\"objectThree\":{}}]}`\n\treceived = json2.String()\n\tif expected != received {\n\t\tt.Errorf(\"json2: expected %v, received %v\", expected, received)\n\t}\n\n\treceived = json3.String()\n\tif expected != received {\n\t\tt.Errorf(\"json3: expected %v, received %v\", expected, received)\n\t}\n}\n\nfunc TestChildrenMap(t *testing.T) {\n\tjson1, _ := ParseJSON([]byte(`{\n\t\t\"objectOne\":{\"num\":1},\n\t\t\"objectTwo\":{\"num\":2},\n\t\t\"objectThree\":{\"num\":3}\n\t}`))\n\n\tobjectMap := json1.ChildrenMap()\n\tif len(objectMap) != 3 {\n\t\tt.Errorf(\"Wrong num of elements in objectMap: %v != %v\", len(objectMap), 3)\n\t\treturn\n\t}\n\n\tfor key, val := range objectMap {\n\t\tswitch key {\n\t\tcase \"objectOne\":\n\t\t\tif val := val.S(\"num\").Data().(float64); val != 1 {\n\t\t\t\tt.Errorf(\"%v != %v\", val, 1)\n\t\t\t}\n\t\tcase \"objectTwo\":\n\t\t\tif val := val.S(\"num\").Data().(float64); val != 2 {\n\t\t\t\tt.Errorf(\"%v != %v\", val, 2)\n\t\t\t}\n\t\tcase \"objectThree\":\n\t\t\tif val := val.S(\"num\").Data().(float64); val != 3 {\n\t\t\t\tt.Errorf(\"%v != %v\", val, 3)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Errorf(\"Unexpected key: %v\", key)\n\t\t}\n\t}\n\n\tobjectMap[\"objectOne\"].Set(500, \"num\")\n\tif val := json1.Path(\"objectOne.num\").Data().(int); val != 500 {\n\t\tt.Errorf(\"set objectOne failed: %v != %v\", val, 500)\n\t}\n}\n\nfunc TestNestedAnonymousArrays(t *testing.T) {\n\tjson1, _ := ParseJSON([]byte(`{\n\t\t\"array\":[\n\t\t\t[ 1, 2, 3 ],\n\t\t\t[ 4, 5, 6 ],\n\t\t\t[ 7, 8, 9 ],\n\t\t\t[{ \"test\" : 50 }]\n\t\t]\n\t}`))\n\n\tchildTest := json1.S(\"array\").Index(0).Children()\n\n\tif val := childTest[0].Data().(float64); val != 1 {\n\t\tt.Errorf(\"child test: %v != %v\", val, 1)\n\t}\n\tif val := childTest[1].Data().(float64); val != 2 {\n\t\tt.Errorf(\"child test: %v != %v\", val, 2)\n\t}\n\tif val := childTest[2].Data().(float64); val != 3 {\n\t\tt.Errorf(\"child test: %v != %v\", val, 3)\n\t}\n\n\tif val := json1.Path(\"array\").Index(1).Index(1).Data().(float64); val != 5 {\n\t\tt.Errorf(\"nested child test: %v != %v\", val, 5)\n\t}\n\n\tif val := json1.Path(\"array\").Index(3).Index(0).S(\"test\").Data().(float64); val != 50 {\n\t\tt.Errorf(\"nested child object test: %v != %v\", val, 50)\n\t}\n\n\tjson1.Path(\"array\").Index(3).Index(0).Set(200, \"test\")\n\n\tif val := json1.Path(\"array\").Index(3).Index(0).S(\"test\").Data().(int); val != 200 {\n\t\tt.Errorf(\"set nested child object: %v != %v\", val, 200)\n\t}\n}\n\nfunc TestArrays(t *testing.T) {\n\tjson1, _ := ParseJSON([]byte(`{\n\t\t\"languages\":{\n\t\t\t\"english\":{\n\t\t\t\t\"places\":0\n\t\t\t},\n\t\t\t\"french\": {\n\t\t\t\t\"places\": [\n\t\t\t\t\t\"france\",\n\t\t\t\t\t\"belgium\"\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t}`))\n\n\tjson2, _ := ParseJSON([]byte(`{\n\t\t\"places\":[\n\t\t\t\"great_britain\",\n\t\t\t\"united_states_of_america\",\n\t\t\t\"the_world\"\n\t\t]\n\t}`))\n\n\tif englishPlaces := json2.Search(\"places\").Data(); englishPlaces != nil {\n\t\tjson1.Path(\"languages.english\").Set(englishPlaces, \"places\")\n\t} else {\n\t\tt.Errorf(\"Didn't find places in json2\")\n\t}\n\n\tif englishPlaces := json1.Search(\"languages\", \"english\", \"places\").Data(); englishPlaces != nil {\n\n\t\tenglishArray, ok := englishPlaces.([]interface{})\n\t\tif !ok {\n\t\t\tt.Errorf(\"places in json1 (%v) was not an array\", englishPlaces)\n\t\t}\n\n\t\tif len(englishArray) != 3 {\n\t\t\tt.Errorf(\"wrong length of array: %v\", len(englishArray))\n\t\t}\n\n\t} else {\n\t\tt.Errorf(\"Didn't find places in json1\")\n\t}\n\n\tfor i := 0; i < 3; i++ {\n\t\tif err := json2.ArrayRemove(0, \"places\"); err != nil {\n\t\t\tt.Errorf(\"Error removing element: %v\", err)\n\t\t}\n\t}\n\n\tjson2.ArrayAppend(map[string]interface{}{}, \"places\")\n\tjson2.ArrayAppend(map[string]interface{}{}, \"places\")\n\tjson2.ArrayAppend(map[string]interface{}{}, \"places\")\n\n\t// Using float64 for this test even though it's completely inappropriate because\n\t// later on the API might do something clever with types, in which case all numbers\n\t// will become float64.\n\tfor i := 0; i < 3; i++ {\n\t\tobj, _ := json2.ArrayElement(i, \"places\")\n\t\tobj2, _ := obj.Object(fmt.Sprintf(\"object%v\", i))\n\t\tobj2.Set(float64(i), \"index\")\n\t}\n\n\tchildren := json2.S(\"places\").Children()\n\tfor i, obj := range children {\n\t\tif id, ok := obj.S(fmt.Sprintf(\"object%v\", i)).S(\"index\").Data().(float64); ok {\n\t\t\tif id != float64(i) {\n\t\t\t\tt.Errorf(\"Wrong index somehow, expected %v, received %v\", i, id)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"Failed to find element %v from %v\", i, obj)\n\t\t}\n\t}\n\n\tif err := json2.ArrayRemove(1, \"places\"); err != nil {\n\t\tt.Errorf(\"Error removing element: %v\", err)\n\t}\n\n\texpected := `{\"places\":[{\"object0\":{\"index\":0}},{\"object2\":{\"index\":2}}]}`\n\treceived := json2.String()\n\n\tif expected != received {\n\t\tt.Errorf(\"Wrong output, expected: %v, received: %v\", expected, received)\n\t}\n}\n\nfunc TestArraysTwo(t *testing.T) {\n\tjson1 := New()\n\n\ttest1, err := json1.ArrayOfSize(4, \"test1\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif _, err = test1.ArrayOfSizeI(2, 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err = test1.ArrayOfSizeI(2, 1); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err = test1.ArrayOfSizeI(2, 2); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err = test1.ArrayOfSizeI(2, 3); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif _, err = test1.ArrayOfSizeI(2, 4); err != ErrOutOfBounds {\n\t\tt.Errorf(\"Index should have been out of bounds\")\n\t}\n\n\tif _, err = json1.S(\"test1\").Index(0).SetIndex(10, 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err = json1.S(\"test1\").Index(0).SetIndex(11, 1); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif _, err = json1.S(\"test1\").Index(1).SetIndex(12, 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err = json1.S(\"test1\").Index(1).SetIndex(13, 1); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif _, err = json1.S(\"test1\").Index(2).SetIndex(14, 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err = json1.S(\"test1\").Index(2).SetIndex(15, 1); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif _, err = json1.S(\"test1\").Index(3).SetIndex(16, 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err = json1.S(\"test1\").Index(3).SetIndex(17, 1); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif val := json1.S(\"test1\").Index(0).Index(0).Data().(int); val != 10 {\n\t\tt.Errorf(\"create array: %v != %v\", val, 10)\n\t}\n\tif val := json1.S(\"test1\").Index(0).Index(1).Data().(int); val != 11 {\n\t\tt.Errorf(\"create array: %v != %v\", val, 11)\n\t}\n\n\tif val := json1.S(\"test1\").Index(1).Index(0).Data().(int); val != 12 {\n\t\tt.Errorf(\"create array: %v != %v\", val, 12)\n\t}\n\tif val := json1.S(\"test1\").Index(1).Index(1).Data().(int); val != 13 {\n\t\tt.Errorf(\"create array: %v != %v\", val, 13)\n\t}\n\n\tif val := json1.S(\"test1\").Index(2).Index(0).Data().(int); val != 14 {\n\t\tt.Errorf(\"create array: %v != %v\", val, 14)\n\t}\n\tif val := json1.S(\"test1\").Index(2).Index(1).Data().(int); val != 15 {\n\t\tt.Errorf(\"create array: %v != %v\", val, 15)\n\t}\n\n\tif val := json1.S(\"test1\").Index(3).Index(0).Data().(int); val != 16 {\n\t\tt.Errorf(\"create array: %v != %v\", val, 16)\n\t}\n\tif val := json1.S(\"test1\").Index(3).Index(1).Data().(int); val != 17 {\n\t\tt.Errorf(\"create array: %v != %v\", val, 17)\n\t}\n}\n\nfunc TestArraysThree(t *testing.T) {\n\tjson1 := New()\n\n\ttest, err := json1.ArrayOfSizeP(1, \"test1.test2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest.SetIndex(10, 0)\n\tif val := json1.S(\"test1\", \"test2\").Index(0).Data().(int); val != 10 {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSetJSONPointer(t *testing.T) {\n\ttype testCase struct {\n\t\tinput   string\n\t\tpointer string\n\t\tvalue   interface{}\n\t\toutput  string\n\t}\n\ttests := []testCase{\n\t\t{\n\t\t\tinput:   `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\tpointer: \"/foo/bar\",\n\t\t\tvalue:   \"qux\",\n\t\t\toutput:  `{\"foo\":{\"bar\":\"qux\"}}`,\n\t\t},\n\t\t{\n\t\t\tinput:   `{\"foo\":[\"bar\",\"ignored\",\"baz\"]}`,\n\t\t\tpointer: \"/foo/2\",\n\t\t\tvalue:   \"qux\",\n\t\t\toutput:  `{\"foo\":[\"bar\",\"ignored\",\"qux\"]}`,\n\t\t},\n\t\t{\n\t\t\tinput:   `{\"foo\":[\"bar\",\"ignored\",{\"bar\":\"baz\"}]}`,\n\t\t\tpointer: \"/foo/2/bar\",\n\t\t\tvalue:   \"qux\",\n\t\t\toutput:  `{\"foo\":[\"bar\",\"ignored\",{\"bar\":\"qux\"}]}`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tgObj, err := ParseJSON([]byte(test.input))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to parse '%v': %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\t\tif _, err = gObj.SetJSONPointer(test.value, test.pointer); err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tif exp, act := test.output, gObj.String(); exp != act {\n\t\t\tt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t\t}\n\t}\n}\n\nfunc TestArrayReplace(t *testing.T) {\n\tjson1 := New()\n\n\tjson1.Set(1, \"first\")\n\tjson1.ArrayAppend(2, \"first\")\n\tjson1.ArrayAppend(3, \"second\")\n\n\texpected := `{\"first\":[1,2],\"second\":[3]}`\n\treceived := json1.String()\n\n\tif expected != received {\n\t\tt.Errorf(\"Wrong output, expected: %v, received: %v\", expected, received)\n\t}\n}\n\nfunc TestArraysRoot(t *testing.T) {\n\tsample := []byte(`[\"test1\"]`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tval.ArrayAppend(\"test2\")\n\tval.ArrayAppend(\"test3\")\n\tif obj, err := val.ObjectI(2); err != nil {\n\t\tt.Error(err)\n\t} else {\n\t\tobj.Set(\"bar\", \"foo\")\n\t}\n\n\tif expected, actual := `[\"test1\",\"test2\",{\"foo\":\"bar\"}]`, val.String(); expected != actual {\n\t\tt.Errorf(\"expected %v, received: %v\", expected, actual)\n\t}\n}\n\nfunc TestLargeSample(t *testing.T) {\n\tsample := []byte(`{\n\t\t\"test\":{\n\t\t\t\"innerTest\":{\n\t\t\t\t\"value\":10,\n\t\t\t\t\"value2\":22,\n\t\t\t\t\"value3\":{\n\t\t\t\t\t\"moreValue\":45\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"test2\":20\n\t}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\tif result, ok := val.Search(\"test\", \"innerTest\", \"value3\", \"moreValue\").Data().(float64); ok {\n\t\tif result != 45 {\n\t\t\tt.Errorf(\"Wrong value of result: %v\", result)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"Didn't find value\")\n\t}\n}\n\nfunc TestShorthand(t *testing.T) {\n\tcontainer, _ := ParseJSON([]byte(`{\n\t\t\"outter\":{\n\t\t\t\"inner\":{\n\t\t\t\t\"value\":5,\n\t\t\t\t\"value2\":10,\n\t\t\t\t\"value3\":11\n\t\t\t},\n\t\t\t\"inner2\":{\n\t\t\t}\n\t\t},\n\t\t\"outter2\":{\n\t\t\t\"inner\":0\n\t\t}\n\t}`))\n\n\tmissingValue := container.S(\"outter\").S(\"doesntexist\").S(\"alsodoesntexist\").S(\"inner\").S(\"value\").Data()\n\tif missingValue != nil {\n\t\tt.Errorf(\"missing value was actually found: %v\\n\", missingValue)\n\t}\n\n\trealValue := container.S(\"outter\").S(\"inner\").S(\"value2\").Data().(float64)\n\tif realValue != 10 {\n\t\tt.Errorf(\"real value was incorrect: %v\\n\", realValue)\n\t}\n\n\t_, err := container.S(\"outter2\").Set(container.S(\"outter\").S(\"inner\").Data(), \"inner\")\n\tif err != nil {\n\t\tt.Errorf(\"error setting outter2: %v\\n\", err)\n\t}\n\n\tcompare := `{\"outter\":{\"inner\":{\"value\":5,\"value2\":10,\"value3\":11},\"inner2\":{}}` +\n\t\t`,\"outter2\":{\"inner\":{\"value\":5,\"value2\":10,\"value3\":11}}}`\n\tout := container.String()\n\tif out != compare {\n\t\tt.Errorf(\"wrong serialized structure: %v\\n\", out)\n\t}\n\n\tcompare2 := `{\"outter\":{\"inner\":{\"value\":6,\"value2\":10,\"value3\":11},\"inner2\":{}}` +\n\t\t`,\"outter2\":{\"inner\":{\"value\":6,\"value2\":10,\"value3\":11}}}`\n\n\tcontainer.S(\"outter\").S(\"inner\").Set(6, \"value\")\n\tout = container.String()\n\tif out != compare2 {\n\t\tt.Errorf(\"wrong serialized structure: %v\\n\", out)\n\t}\n}\n\nfunc TestInvalid(t *testing.T) {\n\tinvalidJSONSamples := []string{\n\t\t`{dfads\"`,\n\t\t``,\n\t\t// `\"\"`,\n\t\t// `\"hello\"`,\n\t\t\"{}\\n{}\",\n\t}\n\n\tfor _, sample := range invalidJSONSamples {\n\t\tif _, err := ParseJSON([]byte(sample)); err == nil {\n\t\t\tt.Errorf(\"parsing invalid JSON '%v' did not return error\", sample)\n\t\t}\n\t}\n\n\tif _, err := ParseJSON(nil); err == nil {\n\t\tt.Errorf(\"parsing nil did not return error\")\n\t}\n\n\tvalidObj, err := ParseJSON([]byte(`{}`))\n\tif err != nil {\n\t\tt.Errorf(\"failed to parse '{}'\")\n\t}\n\n\tinvalidStr := validObj.S(\"Doesn't exist\").String()\n\tif invalidStr != \"null\" {\n\t\tt.Errorf(\"expected 'null', received: %v\", invalidStr)\n\t}\n}\n\nfunc TestCreation(t *testing.T) {\n\tcontainer, _ := ParseJSON([]byte(`{}`))\n\tinner, err := container.ObjectP(\"test.inner\")\n\tif err != nil {\n\t\tt.Errorf(\"Error: %v\", err)\n\t\treturn\n\t}\n\n\tinner.Set(10, \"first\")\n\tinner.Set(20, \"second\")\n\n\tinner.Array(\"array\")\n\tinner.ArrayAppend(\"first element of the array\", \"array\")\n\tinner.ArrayAppend(2, \"array\")\n\tinner.ArrayAppend(\"three\", \"array\")\n\n\texpected := `{\"test\":{\"inner\":{\"array\":[\"first element of the array\",2,\"three\"],` +\n\t\t`\"first\":10,\"second\":20}}}`\n\tactual := container.String()\n\tif actual != expected {\n\t\tt.Errorf(\"received incorrect output from json object: %v\\n\", actual)\n\t}\n}\n\ntype outterJSON struct {\n\tFirstInner  innerJSON\n\tSecondInner innerJSON\n\tThirdInner  innerJSON\n}\n\ntype innerJSON struct {\n\tNumberType float64\n\tStringType string\n}\n\ntype jsonStructure struct {\n\tFirstOutter  outterJSON\n\tSecondOutter outterJSON\n}\n\nvar jsonContent = []byte(`{\n\t\"firstOutter\":{\n\t\t\"firstInner\":{\n\t\t\t\"numberType\":11,\n\t\t\t\"stringType\":\"hello world, first first\"\n\t\t},\n\t\t\"secondInner\":{\n\t\t\t\"numberType\":12,\n\t\t\t\"stringType\":\"hello world, first second\"\n\t\t},\n\t\t\"thirdInner\":{\n\t\t\t\"numberType\":13,\n\t\t\t\"stringType\":\"hello world, first third\"\n\t\t}\n\t},\n\t\"secondOutter\":{\n\t\t\"firstInner\":{\n\t\t\t\"numberType\":21,\n\t\t\t\"stringType\":\"hello world, second first\"\n\t\t},\n\t\t\"secondInner\":{\n\t\t\t\"numberType\":22,\n\t\t\t\"stringType\":\"hello world, second second\"\n\t\t},\n\t\t\"thirdInner\":{\n\t\t\t\"numberType\":23,\n\t\t\t\"stringType\":\"hello world, second third\"\n\t\t}\n\t}\n}`)\n\n/*\nSimple use case, compares unmarshalling declared structs vs dynamically searching for\nthe equivalent hierarchy. Hopefully we won't see too great a performance drop from the\ndynamic approach.\n*/\n\nfunc BenchmarkStatic(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tvar jsonObj jsonStructure\n\t\tif err := json.Unmarshal(jsonContent, &jsonObj); err != nil {\n\t\t\tb.Errorf(\"Error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif val := jsonObj.FirstOutter.SecondInner.NumberType; val != 12 {\n\t\t\tb.Errorf(\"Wrong value of FirstOutter.SecondInner.NumberType: %v\\n\", val)\n\t\t}\n\t\texpected := \"hello world, first second\"\n\t\tif val := jsonObj.FirstOutter.SecondInner.StringType; val != expected {\n\t\t\tb.Errorf(\"Wrong value of FirstOutter.SecondInner.StringType: %v\\n\", val)\n\t\t}\n\t\tif val := jsonObj.SecondOutter.ThirdInner.NumberType; val != 23 {\n\t\t\tb.Errorf(\"Wrong value of SecondOutter.ThirdInner.NumberType: %v\\n\", val)\n\t\t}\n\t\texpected = \"hello world, second second\"\n\t\tif val := jsonObj.SecondOutter.SecondInner.StringType; val != expected {\n\t\t\tb.Errorf(\"Wrong value of SecondOutter.SecondInner.StringType: %v\\n\", val)\n\t\t}\n\t}\n}\n\nfunc BenchmarkDynamic(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tjsonObj, err := ParseJSON(jsonContent)\n\t\tif err != nil {\n\t\t\tb.Errorf(\"Error parsing json: %v\\n\", err)\n\t\t}\n\n\t\tFOSI := jsonObj.S(\"firstOutter\", \"secondInner\")\n\t\tSOSI := jsonObj.S(\"secondOutter\", \"secondInner\")\n\t\tSOTI := jsonObj.S(\"secondOutter\", \"thirdInner\")\n\n\t\tif val := FOSI.S(\"numberType\").Data().(float64); val != 12 {\n\t\t\tb.Errorf(\"Wrong value of FirstOutter.SecondInner.NumberType: %v\\n\", val)\n\t\t}\n\t\texpected := \"hello world, first second\"\n\t\tif val := FOSI.S(\"stringType\").Data().(string); val != expected {\n\t\t\tb.Errorf(\"Wrong value of FirstOutter.SecondInner.StringType: %v\\n\", val)\n\t\t}\n\t\tif val := SOTI.S(\"numberType\").Data().(float64); val != 23 {\n\t\t\tb.Errorf(\"Wrong value of SecondOutter.ThirdInner.NumberType: %v\\n\", val)\n\t\t}\n\t\texpected = \"hello world, second second\"\n\t\tif val := SOSI.S(\"stringType\").Data().(string); val != expected {\n\t\t\tb.Errorf(\"Wrong value of SecondOutter.SecondInner.StringType: %v\\n\", val)\n\t\t}\n\t}\n}\n\nfunc TestBadIndexes(t *testing.T) {\n\tjsonObj, err := ParseJSON([]byte(`{\"array\":[1,2,3]}`))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif act := jsonObj.Index(0).Data(); act != nil {\n\t\tt.Errorf(\"Unexpected value returned: %v != %v\", nil, act)\n\t}\n\tif act := jsonObj.S(\"array\").Index(4).Data(); act != nil {\n\t\tt.Errorf(\"Unexpected value returned: %v != %v\", nil, act)\n\t}\n}\n\nfunc TestNilSet(t *testing.T) {\n\tobj := Container{nil}\n\tif _, err := obj.Set(\"bar\", \"foo\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err := obj.Set(\"new\", \"foo\", \"bar\"); err != ErrPathCollision {\n\t\tt.Errorf(\"Expected ErrPathCollision: %v, %s\", err, obj.Data())\n\t}\n\tif _, err := obj.SetIndex(\"new\", 0); err != ErrNotArray {\n\t\tt.Errorf(\"Expected ErrNotArray: %v, %s\", err, obj.Data())\n\t}\n}\n\nfunc TestLargeSampleWithHtmlEscape(t *testing.T) {\n\tsample := []byte(`{\n\t\"test\": {\n\t\t\"innerTest\": {\n\t\t\t\"value\": 10,\n\t\t\t\"value2\": \"<title>Title</title>\",\n\t\t\t\"value3\": {\n\t\t\t\t\"moreValue\": 45\n\t\t\t}\n\t\t}\n\t},\n\t\"test2\": 20\n}`)\n\n\tsampleWithHTMLEscape := []byte(`{\n\t\"test\": {\n\t\t\"innerTest\": {\n\t\t\t\"value\": 10,\n\t\t\t\"value2\": \"\\u003ctitle\\u003eTitle\\u003c/title\\u003e\",\n\t\t\t\"value3\": {\n\t\t\t\t\"moreValue\": 45\n\t\t\t}\n\t\t}\n\t},\n\t\"test2\": 20\n}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to parse: %v\", err)\n\t\treturn\n\t}\n\n\texp := string(sample)\n\tres := string(val.EncodeJSON(EncodeOptIndent(\"\", \"\\t\")))\n\tif exp != res {\n\t\tt.Errorf(\"Wrong conversion without html escaping: %s != %s\", res, exp)\n\t}\n\n\texp = string(sampleWithHTMLEscape)\n\tres = string(val.EncodeJSON(EncodeOptHTMLEscape(true), EncodeOptIndent(\"\", \"\\t\")))\n\tif exp != res {\n\t\tt.Errorf(\"Wrong conversion with html escaping: %s != %s\", exp, res)\n\t}\n}\n\nfunc TestMergeCases(t *testing.T) {\n\ttype testCase struct {\n\t\tfirst    string\n\t\tsecond   string\n\t\texpected string\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tfirst:    `{\"outter\":{\"value1\":\"one\"}}`,\n\t\t\tsecond:   `{\"outter\":{\"inner\":{\"value3\": \"threre\"}},\"outter2\":{\"value2\": \"two\"}}`,\n\t\t\texpected: `{\"outter\":{\"inner\":{\"value3\":\"threre\"},\"value1\":\"one\"},\"outter2\":{\"value2\":\"two\"}}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":[\"first\"]}`,\n\t\t\tsecond:   `{\"outter\":[\"second\"]}`,\n\t\t\texpected: `{\"outter\":[\"first\",\"second\"]}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":[\"first\",{\"inner\":\"second\"}]}`,\n\t\t\tsecond:   `{\"outter\":[\"third\"]}`,\n\t\t\texpected: `{\"outter\":[\"first\",{\"inner\":\"second\"},\"third\"]}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":[\"first\",{\"inner\":\"second\"}]}`,\n\t\t\tsecond:   `{\"outter\":\"third\"}`,\n\t\t\texpected: `{\"outter\":[\"first\",{\"inner\":\"second\"},\"third\"]}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":\"first\"}`,\n\t\t\tsecond:   `{\"outter\":\"second\"}`,\n\t\t\texpected: `{\"outter\":[\"first\",\"second\"]}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":{\"inner\":\"first\"}}`,\n\t\t\tsecond:   `{\"outter\":{\"inner\":\"second\"}}`,\n\t\t\texpected: `{\"outter\":{\"inner\":[\"first\",\"second\"]}}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":{\"inner\":\"first\"}}`,\n\t\t\tsecond:   `{\"outter\":\"second\"}`,\n\t\t\texpected: `{\"outter\":[{\"inner\":\"first\"},\"second\"]}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":{\"inner\":\"second\"}}`,\n\t\t\tsecond:   `{\"outter\":{\"inner\":{\"inner2\":\"first\"}}}`,\n\t\t\texpected: `{\"outter\":{\"inner\":[\"second\",{\"inner2\":\"first\"}]}}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":{\"inner\":[\"second\"]}}`,\n\t\t\tsecond:   `{\"outter\":{\"inner\":{\"inner2\":\"first\"}}}`,\n\t\t\texpected: `{\"outter\":{\"inner\":[\"second\",{\"inner2\":\"first\"}]}}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":\"second\"}`,\n\t\t\tsecond:   `{\"outter\":{\"inner\":\"first\"}}`,\n\t\t\texpected: `{\"outter\":[\"second\",{\"inner\":\"first\"}]}`,\n\t\t},\n\t\t{\n\t\t\tfirst:    `{\"outter\":\"first\"}`,\n\t\t\tsecond:   `{\"outter\":[\"second\"]}`,\n\t\t\texpected: `{\"outter\":[\"first\",\"second\"]}`,\n\t\t},\n\t}\n\n\tfor i, test := range testCases {\n\t\tvar firstContainer, secondContainer *Container\n\t\tvar err error\n\n\t\tfirstContainer, err = ParseJSON([]byte(test.first))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"[%d] Failed to parse '%v': %v\", i, test.first, err)\n\t\t}\n\n\t\tsecondContainer, err = ParseJSON([]byte(test.second))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"[%d] Failed to parse '%v': %v\", i, test.second, err)\n\t\t}\n\n\t\tif err = firstContainer.Merge(secondContainer); err != nil {\n\t\t\tt.Errorf(\"[%d] Failed to merge: '%v': %v\", i, test.first, err)\n\t\t}\n\n\t\tif exp, act := test.expected, firstContainer.String(); exp != act {\n\t\t\tt.Errorf(\"[%d] Wrong result: %v != %v\", i, act, exp)\n\t\t}\n\t}\n}\n\nfunc TestMarshalsJSON(t *testing.T) {\n\tsample := []byte(`{\"test\":{\"value\":10},\"test2\":20}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmarshaled, err := json.Marshal(val)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif exp, act := string(sample), string(marshaled); exp != act {\n\t\tt.Errorf(\"Unexpected result: %v != %v\", act, exp)\n\t}\n}\n\nfunc TestFlatten(t *testing.T) {\n\ttype testCase struct {\n\t\tinput  string\n\t\toutput string\n\t}\n\ttests := []testCase{\n\t\t{\n\t\t\tinput:  `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\toutput: `{\"foo.bar\":\"baz\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"foo\":[{\"bar\":\"1\"},{\"bar\":\"2\"}]}`,\n\t\t\toutput: `{\"foo.0.bar\":\"1\",\"foo.1.bar\":\"2\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `[{\"bar\":\"1\"},{\"bar\":\"2\"}]`,\n\t\t\toutput: `{\"0.bar\":\"1\",\"1.bar\":\"2\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `[[\"1\"],[\"2\",\"3\"]]`,\n\t\t\toutput: `{\"0.0\":\"1\",\"1.0\":\"2\",\"1.1\":\"3\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"foo\":{\"bar\":null}}`,\n\t\t\toutput: `{\"foo.bar\":null}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"foo\":{\"bar\":{}}}`,\n\t\t\toutput: `{}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"foo\":{\"bar\":[]}}`,\n\t\t\toutput: `{}`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tgObj, err := ParseJSON([]byte(test.input))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to parse '%v': %v\", test.input, err)\n\t\t}\n\t\tvar res map[string]interface{}\n\t\tif res, err = gObj.Flatten(); err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tif exp, act := test.output, Wrap(res).String(); exp != act {\n\t\t\tt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t\t}\n\t}\n}\n\nfunc TestFlattenIncludeEmpty(t *testing.T) {\n\ttype testCase struct {\n\t\tinput  string\n\t\toutput string\n\t}\n\ttests := []testCase{\n\t\t{\n\t\t\tinput:  `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\toutput: `{\"foo.bar\":\"baz\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"foo\":[{\"bar\":\"1\"},{\"bar\":\"2\"}]}`,\n\t\t\toutput: `{\"foo.0.bar\":\"1\",\"foo.1.bar\":\"2\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `[{\"bar\":\"1\"},{\"bar\":\"2\"}]`,\n\t\t\toutput: `{\"0.bar\":\"1\",\"1.bar\":\"2\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `[[\"1\"],[\"2\",\"3\"]]`,\n\t\t\toutput: `{\"0.0\":\"1\",\"1.0\":\"2\",\"1.1\":\"3\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"foo\":{\"bar\":null}}`,\n\t\t\toutput: `{\"foo.bar\":null}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"foo\":{\"bar\":{}}}`,\n\t\t\toutput: `{\"foo.bar\":{}}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"foo\":{\"bar\":[]}}`,\n\t\t\toutput: `{\"foo.bar\":[]}`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tgObj, err := ParseJSON([]byte(test.input))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to parse '%v': %v\", test.input, err)\n\t\t}\n\t\tvar res map[string]interface{}\n\t\tif res, err = gObj.FlattenIncludeEmpty(); err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tif exp, act := test.output, Wrap(res).String(); exp != act {\n\t\t\tt.Errorf(\"Wrong result: %v != %v\", act, exp)\n\t\t}\n\t}\n}\n\nfunc BenchmarkChildren(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tjsonObj, err := ParseJSON(bigSample)\n\t\tif err != nil {\n\t\t\tb.Errorf(\"Error parsing json: %v\\n\", err)\n\t\t}\n\n\t\t_ = jsonObj.Children()\n\n\t\tFOSI := jsonObj.S(\"firstOutter\", \"secondInner\")\n\t\t_ = FOSI.Children()\n\t\tSOSI := jsonObj.S(\"secondOutter\", \"secondInner\")\n\t\t_ = SOSI.Children()\n\t\tSOTI := jsonObj.S(\"secondOutter\", \"thirdInner\")\n\t\t_ = SOTI.Children()\n\t}\n}\n\nfunc BenchmarkWildcardSearch(b *testing.B) {\n\tsample := []byte(`{\"test\":[{\"value\":10},{\"value\":20}]}`)\n\n\tval, err := ParseJSON(sample)\n\tif err != nil {\n\t\tb.Fatalf(\"Failed to parse: %v\", err)\n\t}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tval.Search([]string{\"test\", \"*\"}...)\n\t\tval.Search([]string{\"test\", \"*\", \"value\"}...)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0419921875,
          "content": "module github.com/Jeffail/gabs/v2\n\ngo 1.16\n"
        },
        {
          "name": "migration.md",
          "type": "blob",
          "size": 2.3583984375,
          "content": "Migration Guides\n================\n\n## Migrating to Version 2\n\n### Path\n\nPreviously it was not possible to specify a dot path where a key itself contains a dot. In v2 it is now possible with the escape sequence `~1`. For example, given the JSON doc `{\"foo\":{\"bar.baz\":10}}`, the path `foo.bar~1baz` would return `10`. This escape sequence means the character `~` is also a special case, therefore it must also be escaped to the sequence `~0`.\n\n### Consume\n\nCalls to `Consume(root interface{}) (*Container, error)` should be replaced with `Wrap(root interface{}) *Container`.\n\nThe error response was removed in order to avoid unnecessary duplicate type checks on `root`. This also allows shorthand chained queries like `gabs.Wrap(foo).S(\"bar\",\"baz\").Data()`.\n\n### Search Across Arrays\n\nAll query functions (`Search`, `Path`, `Set`, `SetP`, etc) now attempt to resolve a specific index when they encounter an array. This means path queries must specify an integer index at the level of arrays within the content.\n\nFor example, given the sample document:\n\n``` json\n{\n  \"foo\": [\n    {\n      \"bar\": {\n        \"baz\": 45\n      }\n    }\n  ]\n}\n```\n\nIn v1 the query `Search(\"foo\", \"bar\", \"baz\")` would propagate the array in the result giving us `[45]`. In v2 we can access the field directly with `Search(\"foo\", \"0\", \"bar\", \"baz\")`. The index is _required_, otherwise the query fails.\n\nIn query functions that do not set a value it is possible to specify `*` instead of an index in order to obtain all elements of the array, this produces the equivalent result as the behaviour from v1. For example, in v2 the query `Search(\"foo\", \"*\", \"bar\", \"baz\")` would return `[45]`.\n\n### Children and ChildrenMap\n\nThe `Children` and `ChildrenMap` methods no longer return errors. Instead, in the event of the underlying value being invalid (not an array or object), a `nil` slice and empty map are returned respectively. If explicit type checking is required the recommended approach would be casting on the value, e.g. `foo, ok := obj.Data().([]interface)`.\n\n### Serialising Invalid Types\n\nIn v1 attempting to serialise with `Bytes`, `String`, etc, with an invalid structure would result in an empty object `{}`. This behaviour was unintuitive and in v2 `null` will be returned instead. If explicit marshalling is required with proper error propagation it is still recommended to use the `json` package directly on the underlying value."
        }
      ]
    }
  ]
}