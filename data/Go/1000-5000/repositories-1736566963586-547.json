{
  "metadata": {
    "timestamp": 1736566963586,
    "page": 547,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sony/gobreaker",
      "stars": 2997,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".golangci.yaml",
          "type": "blob",
          "size": 0.1875,
          "content": "linters:\n  enable:\n  - gofmt\n  - goimports\n  - gosec\n  - misspell\nissues:\n  exclude-rules:\n  - path: _test\\.go\n    linters:\n    - gosec\n    - govet\n  - path: example/\n    linters:\n    - gosec\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright 2015 Sony Corporation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.8291015625,
          "content": "gobreaker\n=========\n\n[![GoDoc](https://godoc.org/github.com/sony/gobreaker/v2?status.svg)](https://godoc.org/github.com/sony/gobreaker/v2)\n\n[gobreaker][repo-url] implements the [Circuit Breaker pattern](https://msdn.microsoft.com/en-us/library/dn589784.aspx) in Go.\n\nInstallation\n------------\n\n```\ngo get github.com/sony/gobreaker/v2\n```\n\nUsage\n-----\n\nThe struct `CircuitBreaker` is a state machine to prevent sending requests that are likely to fail.\nThe function `NewCircuitBreaker` creates a new `CircuitBreaker`.\nThe type parameter `T` specifies the return type of requests.\n\n```go\nfunc NewCircuitBreaker[T any](st Settings) *CircuitBreaker[T]\n```\n\nYou can configure `CircuitBreaker` by the struct `Settings`:\n\n```go\ntype Settings struct {\n\tName          string\n\tMaxRequests   uint32\n\tInterval      time.Duration\n\tTimeout       time.Duration\n\tReadyToTrip   func(counts Counts) bool\n\tOnStateChange func(name string, from State, to State)\n\tIsSuccessful  func(err error) bool\n}\n```\n\n- `Name` is the name of the `CircuitBreaker`.\n\n- `MaxRequests` is the maximum number of requests allowed to pass through\n  when the `CircuitBreaker` is half-open.\n  If `MaxRequests` is 0, `CircuitBreaker` allows only 1 request.\n\n- `Interval` is the cyclic period of the closed state\n  for `CircuitBreaker` to clear the internal `Counts`, described later in this section.\n  If `Interval` is 0, `CircuitBreaker` doesn't clear the internal `Counts` during the closed state.\n\n- `Timeout` is the period of the open state,\n  after which the state of `CircuitBreaker` becomes half-open.\n  If `Timeout` is 0, the timeout value of `CircuitBreaker` is set to 60 seconds.\n\n- `ReadyToTrip` is called with a copy of `Counts` whenever a request fails in the closed state.\n  If `ReadyToTrip` returns true, `CircuitBreaker` will be placed into the open state.\n  If `ReadyToTrip` is `nil`, default `ReadyToTrip` is used.\n  Default `ReadyToTrip` returns true when the number of consecutive failures is more than 5.\n\n- `OnStateChange` is called whenever the state of `CircuitBreaker` changes.\n\n- `IsSuccessful` is called with the error returned from a request.\n  If `IsSuccessful` returns true, the error is counted as a success.\n  Otherwise the error is counted as a failure.\n  If `IsSuccessful` is nil, default `IsSuccessful` is used, which returns false for all non-nil errors.\n\nThe struct `Counts` holds the numbers of requests and their successes/failures:\n\n```go\ntype Counts struct {\n\tRequests             uint32\n\tTotalSuccesses       uint32\n\tTotalFailures        uint32\n\tConsecutiveSuccesses uint32\n\tConsecutiveFailures  uint32\n}\n```\n\n`CircuitBreaker` clears the internal `Counts` either\non the change of the state or at the closed-state intervals.\n`Counts` ignores the results of the requests sent before clearing.\n\n`CircuitBreaker` can wrap any function to send a request:\n\n```go\nfunc (cb *CircuitBreaker[T]) Execute(req func() (T, error)) (T, error)\n```\n\nThe method `Execute` runs the given request if `CircuitBreaker` accepts it.\n`Execute` returns an error instantly if `CircuitBreaker` rejects the request.\nOtherwise, `Execute` returns the result of the request.\nIf a panic occurs in the request, `CircuitBreaker` handles it as an error\nand causes the same panic again.\n\nExample\n-------\n\n```go\nvar cb *gobreaker.CircuitBreaker[[]byte]\n\nfunc Get(url string) ([]byte, error) {\n\tbody, err := cb.Execute(func() ([]byte, error) {\n\t\tresp, err := http.Get(url)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn body, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n}\n```\n\nSee [example](https://github.com/sony/gobreaker/blob/master/v2/example) for details.\n\nLicense\n-------\n\nThe MIT License (MIT)\n\nSee [LICENSE](https://github.com/sony/gobreaker/blob/master/LICENSE) for details.\n\n\n[repo-url]: https://github.com/sony/gobreaker\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.083984375,
          "content": "module github.com/sony/gobreaker\n\ngo 1.12\n\nrequire github.com/stretchr/testify v1.3.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.59375,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\n"
        },
        {
          "name": "gobreaker.go",
          "type": "blob",
          "size": 9.3916015625,
          "content": "// Package gobreaker implements the Circuit Breaker pattern.\n// See https://msdn.microsoft.com/en-us/library/dn589784.aspx.\npackage gobreaker\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// State is a type that represents a state of CircuitBreaker.\ntype State int\n\n// These constants are states of CircuitBreaker.\nconst (\n\tStateClosed State = iota\n\tStateHalfOpen\n\tStateOpen\n)\n\nvar (\n\t// ErrTooManyRequests is returned when the CB state is half open and the requests count is over the cb maxRequests\n\tErrTooManyRequests = errors.New(\"too many requests\")\n\t// ErrOpenState is returned when the CB state is open\n\tErrOpenState = errors.New(\"circuit breaker is open\")\n)\n\n// String implements stringer interface.\nfunc (s State) String() string {\n\tswitch s {\n\tcase StateClosed:\n\t\treturn \"closed\"\n\tcase StateHalfOpen:\n\t\treturn \"half-open\"\n\tcase StateOpen:\n\t\treturn \"open\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"unknown state: %d\", s)\n\t}\n}\n\n// Counts holds the numbers of requests and their successes/failures.\n// CircuitBreaker clears the internal Counts either\n// on the change of the state or at the closed-state intervals.\n// Counts ignores the results of the requests sent before clearing.\ntype Counts struct {\n\tRequests             uint32\n\tTotalSuccesses       uint32\n\tTotalFailures        uint32\n\tConsecutiveSuccesses uint32\n\tConsecutiveFailures  uint32\n}\n\nfunc (c *Counts) onRequest() {\n\tc.Requests++\n}\n\nfunc (c *Counts) onSuccess() {\n\tc.TotalSuccesses++\n\tc.ConsecutiveSuccesses++\n\tc.ConsecutiveFailures = 0\n}\n\nfunc (c *Counts) onFailure() {\n\tc.TotalFailures++\n\tc.ConsecutiveFailures++\n\tc.ConsecutiveSuccesses = 0\n}\n\nfunc (c *Counts) clear() {\n\tc.Requests = 0\n\tc.TotalSuccesses = 0\n\tc.TotalFailures = 0\n\tc.ConsecutiveSuccesses = 0\n\tc.ConsecutiveFailures = 0\n}\n\n// Settings configures CircuitBreaker:\n//\n// Name is the name of the CircuitBreaker.\n//\n// MaxRequests is the maximum number of requests allowed to pass through\n// when the CircuitBreaker is half-open.\n// If MaxRequests is 0, the CircuitBreaker allows only 1 request.\n//\n// Interval is the cyclic period of the closed state\n// for the CircuitBreaker to clear the internal Counts.\n// If Interval is less than or equal to 0, the CircuitBreaker doesn't clear internal Counts during the closed state.\n//\n// Timeout is the period of the open state,\n// after which the state of the CircuitBreaker becomes half-open.\n// If Timeout is less than or equal to 0, the timeout value of the CircuitBreaker is set to 60 seconds.\n//\n// ReadyToTrip is called with a copy of Counts whenever a request fails in the closed state.\n// If ReadyToTrip returns true, the CircuitBreaker will be placed into the open state.\n// If ReadyToTrip is nil, default ReadyToTrip is used.\n// Default ReadyToTrip returns true when the number of consecutive failures is more than 5.\n//\n// OnStateChange is called whenever the state of the CircuitBreaker changes.\n//\n// IsSuccessful is called with the error returned from a request.\n// If IsSuccessful returns true, the error is counted as a success.\n// Otherwise the error is counted as a failure.\n// If IsSuccessful is nil, default IsSuccessful is used, which returns false for all non-nil errors.\ntype Settings struct {\n\tName          string\n\tMaxRequests   uint32\n\tInterval      time.Duration\n\tTimeout       time.Duration\n\tReadyToTrip   func(counts Counts) bool\n\tOnStateChange func(name string, from State, to State)\n\tIsSuccessful  func(err error) bool\n}\n\n// CircuitBreaker is a state machine to prevent sending requests that are likely to fail.\ntype CircuitBreaker struct {\n\tname          string\n\tmaxRequests   uint32\n\tinterval      time.Duration\n\ttimeout       time.Duration\n\treadyToTrip   func(counts Counts) bool\n\tisSuccessful  func(err error) bool\n\tonStateChange func(name string, from State, to State)\n\n\tmutex      sync.Mutex\n\tstate      State\n\tgeneration uint64\n\tcounts     Counts\n\texpiry     time.Time\n}\n\n// TwoStepCircuitBreaker is like CircuitBreaker but instead of surrounding a function\n// with the breaker functionality, it only checks whether a request can proceed and\n// expects the caller to report the outcome in a separate step using a callback.\ntype TwoStepCircuitBreaker struct {\n\tcb *CircuitBreaker\n}\n\n// NewCircuitBreaker returns a new CircuitBreaker configured with the given Settings.\nfunc NewCircuitBreaker(st Settings) *CircuitBreaker {\n\tcb := new(CircuitBreaker)\n\n\tcb.name = st.Name\n\tcb.onStateChange = st.OnStateChange\n\n\tif st.MaxRequests == 0 {\n\t\tcb.maxRequests = 1\n\t} else {\n\t\tcb.maxRequests = st.MaxRequests\n\t}\n\n\tif st.Interval <= 0 {\n\t\tcb.interval = defaultInterval\n\t} else {\n\t\tcb.interval = st.Interval\n\t}\n\n\tif st.Timeout <= 0 {\n\t\tcb.timeout = defaultTimeout\n\t} else {\n\t\tcb.timeout = st.Timeout\n\t}\n\n\tif st.ReadyToTrip == nil {\n\t\tcb.readyToTrip = defaultReadyToTrip\n\t} else {\n\t\tcb.readyToTrip = st.ReadyToTrip\n\t}\n\n\tif st.IsSuccessful == nil {\n\t\tcb.isSuccessful = defaultIsSuccessful\n\t} else {\n\t\tcb.isSuccessful = st.IsSuccessful\n\t}\n\n\tcb.toNewGeneration(time.Now())\n\n\treturn cb\n}\n\n// NewTwoStepCircuitBreaker returns a new TwoStepCircuitBreaker configured with the given Settings.\nfunc NewTwoStepCircuitBreaker(st Settings) *TwoStepCircuitBreaker {\n\treturn &TwoStepCircuitBreaker{\n\t\tcb: NewCircuitBreaker(st),\n\t}\n}\n\nconst defaultInterval = time.Duration(0) * time.Second\nconst defaultTimeout = time.Duration(60) * time.Second\n\nfunc defaultReadyToTrip(counts Counts) bool {\n\treturn counts.ConsecutiveFailures > 5\n}\n\nfunc defaultIsSuccessful(err error) bool {\n\treturn err == nil\n}\n\n// Name returns the name of the CircuitBreaker.\nfunc (cb *CircuitBreaker) Name() string {\n\treturn cb.name\n}\n\n// State returns the current state of the CircuitBreaker.\nfunc (cb *CircuitBreaker) State() State {\n\tcb.mutex.Lock()\n\tdefer cb.mutex.Unlock()\n\n\tnow := time.Now()\n\tstate, _ := cb.currentState(now)\n\treturn state\n}\n\n// Counts returns internal counters\nfunc (cb *CircuitBreaker) Counts() Counts {\n\tcb.mutex.Lock()\n\tdefer cb.mutex.Unlock()\n\n\treturn cb.counts\n}\n\n// Execute runs the given request if the CircuitBreaker accepts it.\n// Execute returns an error instantly if the CircuitBreaker rejects the request.\n// Otherwise, Execute returns the result of the request.\n// If a panic occurs in the request, the CircuitBreaker handles it as an error\n// and causes the same panic again.\nfunc (cb *CircuitBreaker) Execute(req func() (interface{}, error)) (interface{}, error) {\n\tgeneration, err := cb.beforeRequest()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer func() {\n\t\te := recover()\n\t\tif e != nil {\n\t\t\tcb.afterRequest(generation, false)\n\t\t\tpanic(e)\n\t\t}\n\t}()\n\n\tresult, err := req()\n\tcb.afterRequest(generation, cb.isSuccessful(err))\n\treturn result, err\n}\n\n// Name returns the name of the TwoStepCircuitBreaker.\nfunc (tscb *TwoStepCircuitBreaker) Name() string {\n\treturn tscb.cb.Name()\n}\n\n// State returns the current state of the TwoStepCircuitBreaker.\nfunc (tscb *TwoStepCircuitBreaker) State() State {\n\treturn tscb.cb.State()\n}\n\n// Counts returns internal counters\nfunc (tscb *TwoStepCircuitBreaker) Counts() Counts {\n\treturn tscb.cb.Counts()\n}\n\n// Allow checks if a new request can proceed. It returns a callback that should be used to\n// register the success or failure in a separate step. If the circuit breaker doesn't allow\n// requests, it returns an error.\nfunc (tscb *TwoStepCircuitBreaker) Allow() (done func(success bool), err error) {\n\tgeneration, err := tscb.cb.beforeRequest()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn func(success bool) {\n\t\ttscb.cb.afterRequest(generation, success)\n\t}, nil\n}\n\nfunc (cb *CircuitBreaker) beforeRequest() (uint64, error) {\n\tcb.mutex.Lock()\n\tdefer cb.mutex.Unlock()\n\n\tnow := time.Now()\n\tstate, generation := cb.currentState(now)\n\n\tif state == StateOpen {\n\t\treturn generation, ErrOpenState\n\t} else if state == StateHalfOpen && cb.counts.Requests >= cb.maxRequests {\n\t\treturn generation, ErrTooManyRequests\n\t}\n\n\tcb.counts.onRequest()\n\treturn generation, nil\n}\n\nfunc (cb *CircuitBreaker) afterRequest(before uint64, success bool) {\n\tcb.mutex.Lock()\n\tdefer cb.mutex.Unlock()\n\n\tnow := time.Now()\n\tstate, generation := cb.currentState(now)\n\tif generation != before {\n\t\treturn\n\t}\n\n\tif success {\n\t\tcb.onSuccess(state, now)\n\t} else {\n\t\tcb.onFailure(state, now)\n\t}\n}\n\nfunc (cb *CircuitBreaker) onSuccess(state State, now time.Time) {\n\tswitch state {\n\tcase StateClosed:\n\t\tcb.counts.onSuccess()\n\tcase StateHalfOpen:\n\t\tcb.counts.onSuccess()\n\t\tif cb.counts.ConsecutiveSuccesses >= cb.maxRequests {\n\t\t\tcb.setState(StateClosed, now)\n\t\t}\n\t}\n}\n\nfunc (cb *CircuitBreaker) onFailure(state State, now time.Time) {\n\tswitch state {\n\tcase StateClosed:\n\t\tcb.counts.onFailure()\n\t\tif cb.readyToTrip(cb.counts) {\n\t\t\tcb.setState(StateOpen, now)\n\t\t}\n\tcase StateHalfOpen:\n\t\tcb.setState(StateOpen, now)\n\t}\n}\n\nfunc (cb *CircuitBreaker) currentState(now time.Time) (State, uint64) {\n\tswitch cb.state {\n\tcase StateClosed:\n\t\tif !cb.expiry.IsZero() && cb.expiry.Before(now) {\n\t\t\tcb.toNewGeneration(now)\n\t\t}\n\tcase StateOpen:\n\t\tif cb.expiry.Before(now) {\n\t\t\tcb.setState(StateHalfOpen, now)\n\t\t}\n\t}\n\treturn cb.state, cb.generation\n}\n\nfunc (cb *CircuitBreaker) setState(state State, now time.Time) {\n\tif cb.state == state {\n\t\treturn\n\t}\n\n\tprev := cb.state\n\tcb.state = state\n\n\tcb.toNewGeneration(now)\n\n\tif cb.onStateChange != nil {\n\t\tcb.onStateChange(cb.name, prev, state)\n\t}\n}\n\nfunc (cb *CircuitBreaker) toNewGeneration(now time.Time) {\n\tcb.generation++\n\tcb.counts.clear()\n\n\tvar zero time.Time\n\tswitch cb.state {\n\tcase StateClosed:\n\t\tif cb.interval == 0 {\n\t\t\tcb.expiry = zero\n\t\t} else {\n\t\t\tcb.expiry = now.Add(cb.interval)\n\t\t}\n\tcase StateOpen:\n\t\tcb.expiry = now.Add(cb.timeout)\n\tdefault: // StateHalfOpen\n\t\tcb.expiry = zero\n\t}\n}\n"
        },
        {
          "name": "gobreaker_test.go",
          "type": "blob",
          "size": 11.470703125,
          "content": "package gobreaker\n\nimport (\n\t\"errors\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar defaultCB *CircuitBreaker\nvar customCB *CircuitBreaker\n\ntype StateChange struct {\n\tname string\n\tfrom State\n\tto   State\n}\n\nvar stateChange StateChange\n\nfunc pseudoSleep(cb *CircuitBreaker, period time.Duration) {\n\tif !cb.expiry.IsZero() {\n\t\tcb.expiry = cb.expiry.Add(-period)\n\t}\n}\n\nfunc succeed(cb *CircuitBreaker) error {\n\t_, err := cb.Execute(func() (interface{}, error) { return nil, nil })\n\treturn err\n}\n\nfunc succeedLater(cb *CircuitBreaker, delay time.Duration) <-chan error {\n\tch := make(chan error)\n\tgo func() {\n\t\t_, err := cb.Execute(func() (interface{}, error) {\n\t\t\ttime.Sleep(delay)\n\t\t\treturn nil, nil\n\t\t})\n\t\tch <- err\n\t}()\n\treturn ch\n}\n\nfunc succeed2Step(cb *TwoStepCircuitBreaker) error {\n\tdone, err := cb.Allow()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdone(true)\n\treturn nil\n}\n\nfunc fail(cb *CircuitBreaker) error {\n\tmsg := \"fail\"\n\t_, err := cb.Execute(func() (interface{}, error) { return nil, errors.New(msg) })\n\tif err.Error() == msg {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc fail2Step(cb *TwoStepCircuitBreaker) error {\n\tdone, err := cb.Allow()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdone(false)\n\treturn nil\n}\n\nfunc causePanic(cb *CircuitBreaker) error {\n\t_, err := cb.Execute(func() (interface{}, error) { panic(\"oops\"); return nil, nil })\n\treturn err\n}\n\nfunc newCustom() *CircuitBreaker {\n\tvar customSt Settings\n\tcustomSt.Name = \"cb\"\n\tcustomSt.MaxRequests = 3\n\tcustomSt.Interval = time.Duration(30) * time.Second\n\tcustomSt.Timeout = time.Duration(90) * time.Second\n\tcustomSt.ReadyToTrip = func(counts Counts) bool {\n\t\tnumReqs := counts.Requests\n\t\tfailureRatio := float64(counts.TotalFailures) / float64(numReqs)\n\n\t\tcounts.clear() // no effect on customCB.counts\n\n\t\treturn numReqs >= 3 && failureRatio >= 0.6\n\t}\n\tcustomSt.OnStateChange = func(name string, from State, to State) {\n\t\tstateChange = StateChange{name, from, to}\n\t}\n\n\treturn NewCircuitBreaker(customSt)\n}\n\nfunc newNegativeDurationCB() *CircuitBreaker {\n\tvar negativeSt Settings\n\tnegativeSt.Name = \"ncb\"\n\tnegativeSt.Interval = time.Duration(-30) * time.Second\n\tnegativeSt.Timeout = time.Duration(-90) * time.Second\n\n\treturn NewCircuitBreaker(negativeSt)\n}\n\nfunc init() {\n\tdefaultCB = NewCircuitBreaker(Settings{})\n\tcustomCB = newCustom()\n}\n\nfunc TestStateConstants(t *testing.T) {\n\tassert.Equal(t, State(0), StateClosed)\n\tassert.Equal(t, State(1), StateHalfOpen)\n\tassert.Equal(t, State(2), StateOpen)\n\n\tassert.Equal(t, StateClosed.String(), \"closed\")\n\tassert.Equal(t, StateHalfOpen.String(), \"half-open\")\n\tassert.Equal(t, StateOpen.String(), \"open\")\n\tassert.Equal(t, State(100).String(), \"unknown state: 100\")\n}\n\nfunc TestNewCircuitBreaker(t *testing.T) {\n\tdefaultCB := NewCircuitBreaker(Settings{})\n\tassert.Equal(t, \"\", defaultCB.name)\n\tassert.Equal(t, uint32(1), defaultCB.maxRequests)\n\tassert.Equal(t, time.Duration(0), defaultCB.interval)\n\tassert.Equal(t, time.Duration(60)*time.Second, defaultCB.timeout)\n\tassert.NotNil(t, defaultCB.readyToTrip)\n\tassert.Nil(t, defaultCB.onStateChange)\n\tassert.Equal(t, StateClosed, defaultCB.state)\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, defaultCB.counts)\n\tassert.True(t, defaultCB.expiry.IsZero())\n\n\tcustomCB := newCustom()\n\tassert.Equal(t, \"cb\", customCB.name)\n\tassert.Equal(t, uint32(3), customCB.maxRequests)\n\tassert.Equal(t, time.Duration(30)*time.Second, customCB.interval)\n\tassert.Equal(t, time.Duration(90)*time.Second, customCB.timeout)\n\tassert.NotNil(t, customCB.readyToTrip)\n\tassert.NotNil(t, customCB.onStateChange)\n\tassert.Equal(t, StateClosed, customCB.state)\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, customCB.counts)\n\tassert.False(t, customCB.expiry.IsZero())\n\n\tnegativeDurationCB := newNegativeDurationCB()\n\tassert.Equal(t, \"ncb\", negativeDurationCB.name)\n\tassert.Equal(t, uint32(1), negativeDurationCB.maxRequests)\n\tassert.Equal(t, time.Duration(0)*time.Second, negativeDurationCB.interval)\n\tassert.Equal(t, time.Duration(60)*time.Second, negativeDurationCB.timeout)\n\tassert.NotNil(t, negativeDurationCB.readyToTrip)\n\tassert.Nil(t, negativeDurationCB.onStateChange)\n\tassert.Equal(t, StateClosed, negativeDurationCB.state)\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, negativeDurationCB.counts)\n\tassert.True(t, negativeDurationCB.expiry.IsZero())\n}\n\nfunc TestDefaultCircuitBreaker(t *testing.T) {\n\tassert.Equal(t, \"\", defaultCB.Name())\n\n\tfor i := 0; i < 5; i++ {\n\t\tassert.Nil(t, fail(defaultCB))\n\t}\n\tassert.Equal(t, StateClosed, defaultCB.State())\n\tassert.Equal(t, Counts{5, 0, 5, 0, 5}, defaultCB.counts)\n\n\tassert.Nil(t, succeed(defaultCB))\n\tassert.Equal(t, StateClosed, defaultCB.State())\n\tassert.Equal(t, Counts{6, 1, 5, 1, 0}, defaultCB.counts)\n\n\tassert.Nil(t, fail(defaultCB))\n\tassert.Equal(t, StateClosed, defaultCB.State())\n\tassert.Equal(t, Counts{7, 1, 6, 0, 1}, defaultCB.counts)\n\n\t// StateClosed to StateOpen\n\tfor i := 0; i < 5; i++ {\n\t\tassert.Nil(t, fail(defaultCB)) // 6 consecutive failures\n\t}\n\tassert.Equal(t, StateOpen, defaultCB.State())\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, defaultCB.counts)\n\tassert.False(t, defaultCB.expiry.IsZero())\n\n\tassert.Error(t, succeed(defaultCB))\n\tassert.Error(t, fail(defaultCB))\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, defaultCB.counts)\n\n\tpseudoSleep(defaultCB, time.Duration(59)*time.Second)\n\tassert.Equal(t, StateOpen, defaultCB.State())\n\n\t// StateOpen to StateHalfOpen\n\tpseudoSleep(defaultCB, time.Duration(1)*time.Second) // over Timeout\n\tassert.Equal(t, StateHalfOpen, defaultCB.State())\n\tassert.True(t, defaultCB.expiry.IsZero())\n\n\t// StateHalfOpen to StateOpen\n\tassert.Nil(t, fail(defaultCB))\n\tassert.Equal(t, StateOpen, defaultCB.State())\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, defaultCB.counts)\n\tassert.False(t, defaultCB.expiry.IsZero())\n\n\t// StateOpen to StateHalfOpen\n\tpseudoSleep(defaultCB, time.Duration(60)*time.Second)\n\tassert.Equal(t, StateHalfOpen, defaultCB.State())\n\tassert.True(t, defaultCB.expiry.IsZero())\n\n\t// StateHalfOpen to StateClosed\n\tassert.Nil(t, succeed(defaultCB))\n\tassert.Equal(t, StateClosed, defaultCB.State())\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, defaultCB.counts)\n\tassert.True(t, defaultCB.expiry.IsZero())\n}\n\nfunc TestCustomCircuitBreaker(t *testing.T) {\n\tassert.Equal(t, \"cb\", customCB.Name())\n\n\tfor i := 0; i < 5; i++ {\n\t\tassert.Nil(t, succeed(customCB))\n\t\tassert.Nil(t, fail(customCB))\n\t}\n\tassert.Equal(t, StateClosed, customCB.State())\n\tassert.Equal(t, Counts{10, 5, 5, 0, 1}, customCB.counts)\n\n\tpseudoSleep(customCB, time.Duration(29)*time.Second)\n\tassert.Nil(t, succeed(customCB))\n\tassert.Equal(t, StateClosed, customCB.State())\n\tassert.Equal(t, Counts{11, 6, 5, 1, 0}, customCB.counts)\n\n\tpseudoSleep(customCB, time.Duration(1)*time.Second) // over Interval\n\tassert.Nil(t, fail(customCB))\n\tassert.Equal(t, StateClosed, customCB.State())\n\tassert.Equal(t, Counts{1, 0, 1, 0, 1}, customCB.counts)\n\n\t// StateClosed to StateOpen\n\tassert.Nil(t, succeed(customCB))\n\tassert.Nil(t, fail(customCB)) // failure ratio: 2/3 >= 0.6\n\tassert.Equal(t, StateOpen, customCB.State())\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, customCB.counts)\n\tassert.False(t, customCB.expiry.IsZero())\n\tassert.Equal(t, StateChange{\"cb\", StateClosed, StateOpen}, stateChange)\n\n\t// StateOpen to StateHalfOpen\n\tpseudoSleep(customCB, time.Duration(90)*time.Second)\n\tassert.Equal(t, StateHalfOpen, customCB.State())\n\tassert.True(t, defaultCB.expiry.IsZero())\n\tassert.Equal(t, StateChange{\"cb\", StateOpen, StateHalfOpen}, stateChange)\n\n\tassert.Nil(t, succeed(customCB))\n\tassert.Nil(t, succeed(customCB))\n\tassert.Equal(t, StateHalfOpen, customCB.State())\n\tassert.Equal(t, Counts{2, 2, 0, 2, 0}, customCB.counts)\n\n\t// StateHalfOpen to StateClosed\n\tch := succeedLater(customCB, time.Duration(100)*time.Millisecond) // 3 consecutive successes\n\ttime.Sleep(time.Duration(50) * time.Millisecond)\n\tassert.Equal(t, Counts{3, 2, 0, 2, 0}, customCB.counts)\n\tassert.Error(t, succeed(customCB)) // over MaxRequests\n\tassert.Nil(t, <-ch)\n\tassert.Equal(t, StateClosed, customCB.State())\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, customCB.counts)\n\tassert.False(t, customCB.expiry.IsZero())\n\tassert.Equal(t, StateChange{\"cb\", StateHalfOpen, StateClosed}, stateChange)\n}\n\nfunc TestTwoStepCircuitBreaker(t *testing.T) {\n\ttscb := NewTwoStepCircuitBreaker(Settings{Name: \"tscb\"})\n\tassert.Equal(t, \"tscb\", tscb.Name())\n\n\tfor i := 0; i < 5; i++ {\n\t\tassert.Nil(t, fail2Step(tscb))\n\t}\n\n\tassert.Equal(t, StateClosed, tscb.State())\n\tassert.Equal(t, Counts{5, 0, 5, 0, 5}, tscb.cb.counts)\n\n\tassert.Nil(t, succeed2Step(tscb))\n\tassert.Equal(t, StateClosed, tscb.State())\n\tassert.Equal(t, Counts{6, 1, 5, 1, 0}, tscb.cb.counts)\n\n\tassert.Nil(t, fail2Step(tscb))\n\tassert.Equal(t, StateClosed, tscb.State())\n\tassert.Equal(t, Counts{7, 1, 6, 0, 1}, tscb.cb.counts)\n\n\t// StateClosed to StateOpen\n\tfor i := 0; i < 5; i++ {\n\t\tassert.Nil(t, fail2Step(tscb)) // 6 consecutive failures\n\t}\n\tassert.Equal(t, StateOpen, tscb.State())\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, tscb.cb.counts)\n\tassert.False(t, tscb.cb.expiry.IsZero())\n\n\tassert.Error(t, succeed2Step(tscb))\n\tassert.Error(t, fail2Step(tscb))\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, tscb.cb.counts)\n\n\tpseudoSleep(tscb.cb, time.Duration(59)*time.Second)\n\tassert.Equal(t, StateOpen, tscb.State())\n\n\t// StateOpen to StateHalfOpen\n\tpseudoSleep(tscb.cb, time.Duration(1)*time.Second) // over Timeout\n\tassert.Equal(t, StateHalfOpen, tscb.State())\n\tassert.True(t, tscb.cb.expiry.IsZero())\n\n\t// StateHalfOpen to StateOpen\n\tassert.Nil(t, fail2Step(tscb))\n\tassert.Equal(t, StateOpen, tscb.State())\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, tscb.cb.counts)\n\tassert.False(t, tscb.cb.expiry.IsZero())\n\n\t// StateOpen to StateHalfOpen\n\tpseudoSleep(tscb.cb, time.Duration(60)*time.Second)\n\tassert.Equal(t, StateHalfOpen, tscb.State())\n\tassert.True(t, tscb.cb.expiry.IsZero())\n\n\t// StateHalfOpen to StateClosed\n\tassert.Nil(t, succeed2Step(tscb))\n\tassert.Equal(t, StateClosed, tscb.State())\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, tscb.cb.counts)\n\tassert.True(t, tscb.cb.expiry.IsZero())\n}\n\nfunc TestPanicInRequest(t *testing.T) {\n\tassert.Panics(t, func() { _ = causePanic(defaultCB) })\n\tassert.Equal(t, Counts{1, 0, 1, 0, 1}, defaultCB.counts)\n}\n\nfunc TestGeneration(t *testing.T) {\n\tpseudoSleep(customCB, time.Duration(29)*time.Second)\n\tassert.Nil(t, succeed(customCB))\n\tch := succeedLater(customCB, time.Duration(1500)*time.Millisecond)\n\ttime.Sleep(time.Duration(500) * time.Millisecond)\n\tassert.Equal(t, Counts{2, 1, 0, 1, 0}, customCB.counts)\n\n\ttime.Sleep(time.Duration(500) * time.Millisecond) // over Interval\n\tassert.Equal(t, StateClosed, customCB.State())\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, customCB.counts)\n\n\t// the request from the previous generation has no effect on customCB.counts\n\tassert.Nil(t, <-ch)\n\tassert.Equal(t, Counts{0, 0, 0, 0, 0}, customCB.counts)\n}\n\nfunc TestCustomIsSuccessful(t *testing.T) {\n\tisSuccessful := func(error) bool {\n\t\treturn true\n\t}\n\tcb := NewCircuitBreaker(Settings{IsSuccessful: isSuccessful})\n\n\tfor i := 0; i < 5; i++ {\n\t\tassert.Nil(t, fail(cb))\n\t}\n\tassert.Equal(t, StateClosed, cb.State())\n\tassert.Equal(t, Counts{5, 5, 0, 5, 0}, cb.counts)\n\n\tcb.counts.clear()\n\n\tcb.isSuccessful = func(err error) bool {\n\t\treturn err == nil\n\t}\n\tfor i := 0; i < 6; i++ {\n\t\tassert.Nil(t, fail(cb))\n\t}\n\tassert.Equal(t, StateOpen, cb.State())\n\n}\n\nfunc TestCircuitBreakerInParallel(t *testing.T) {\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\n\tch := make(chan error)\n\n\tconst numReqs = 10000\n\troutine := func() {\n\t\tfor i := 0; i < numReqs; i++ {\n\t\t\tch <- succeed(customCB)\n\t\t}\n\t}\n\n\tconst numRoutines = 10\n\tfor i := 0; i < numRoutines; i++ {\n\t\tgo routine()\n\t}\n\n\ttotal := uint32(numReqs * numRoutines)\n\tfor i := uint32(0); i < total; i++ {\n\t\terr := <-ch\n\t\tassert.Nil(t, err)\n\t}\n\tassert.Equal(t, Counts{total, total, 0, total, 0}, customCB.counts)\n}\n"
        },
        {
          "name": "v2",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}