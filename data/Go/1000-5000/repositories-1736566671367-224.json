{
  "metadata": {
    "timestamp": 1736566671367,
    "page": 224,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "uber-go/dig",
      "stars": 3986,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.80859375,
          "content": "coverage:\n  range: 70..98\n  round: down\n  precision: 2\n\n  status:\n    project:                   # measuring the overall project coverage\n      default:                 # context, you can create multiple ones with custom titles\n        enabled: yes           # must be yes|true to enable this status\n        target: 97             # specify the target coverage for each commit status\n                               #   option: \"auto\" (must increase from parent commit or pull request base)\n                               #   option: \"X%\" a static target percentage to hit\n        if_not_found: success  # if parent is not found report status as success, error, or failure\n        if_ci_failed: error    # if ci fails report status as success, error, or failure\n\n    patch:\n      default:\n        enabled: yes\n        target: 70\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0927734375,
          "content": "/bin\n/vendor\n/.bench\n*.mem\n*.cpu\n*.test\n*.log\n*.out\n*.html\n*.coverprofile\ncoverage.txt\n*.pprof\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 2.990234375,
          "content": "output:\n  # Make output more digestible with quickfix in vim/emacs/etc.\n  sort-results: true\n  print-issued-lines: false\n\nlinters:\n  # We'll track the golangci-lint default linters manually\n  # instead of letting them change without our control.\n  disable-all: true\n  enable:\n    # golangci-lint defaults:\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n\n    # Our own extras:\n    - gofumpt\n    - nolintlint # lints nolint directives\n    - revive\n    - errorlint\n\n    # License header check\n    - goheader\n\nlinters-settings:\n  govet:\n    # These govet checks are disabled by default, but they're useful.\n    enable:\n      - niliness\n      - reflectvaluecompare\n      - sortslice\n      - unusedwrite\n\n  goheader:\n    values:\n      const:\n        COMPANY: 'Uber Technologies, Inc.'\n      regexp:\n        YEAR_RANGE: '\\d{4}(-\\d{4})?'\n    template: |-\n      Copyright (c) {{ YEAR_RANGE }} {{ COMPANY }}\n\n      Permission is hereby granted, free of charge, to any person obtaining a copy\n      of this software and associated documentation files (the \"Software\"), to deal\n      in the Software without restriction, including without limitation the rights\n      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n      copies of the Software, and to permit persons to whom the Software is\n      furnished to do so, subject to the following conditions:\n\n      The above copyright notice and this permission notice shall be included in\n      all copies or substantial portions of the Software.\n\n      THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n      THE SOFTWARE.\n\nissues:\n  # Print all issues reported by all linters.\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\n  # Don't ignore some of the issues that golangci-lint considers okay.\n  # This includes documenting all exported entities.\n  exclude-use-default: false\n\n  exclude-rules:\n    # Don't warn on unused parameters.\n    # Parameter names are useful; replacing them with '_' is undesirable.\n    - linters: [revive]\n      text: 'unused-parameter: parameter \\S+ seems to be unused, consider removing or renaming it as _'\n\n    # staticcheck already has smarter checks for empty blocks.\n    # revive's empty-block linter has false positives.\n    # For example, as of writing this, the following is not allowed.\n    #   for foo() { }\n    - linters: [revive]\n      text: 'empty-block: this block is empty, you can remove it'\n\n    # It's okay if internal packages and examples in docs/\n    # don't have package comments.\n    - linters: [revive]\n      path: '.+/internal/.+|^internal/.+'\n      text: 'should have a package comment'\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 10.66015625,
          "content": "# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\nand this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\n\n## Unreleased\n- No changes yet.\n\n## [1.18.0] - 2024-08-07\n### Added\n- Child scope constructors are now visualized via `Visualize`\n- `CallbackInfo` now includes constructor/decorator run time.\n\nThanks to @greeflas for their contribution to this release.\n\n[1.18.0]: https://github.com/uber-go/dig/compare/v1.17.1...v1.18.0\n\n## [1.17.1] - 2023-10-19\n### Added\n- Suggestions for value vs. pointer elements for slice and array types.\n\n### Fixed\n- An issue where value group values were not getting decorated\n  by decorators within the same module when using dig.Export(true).\n- A typo in docs.\n- An issue where false positives in cycle detection were occurring\n  when providing to a child scope.\n\nThanks to @paullen and @lcarilla for their contributions to this release.\n\n[1.17.1]: https://github.com/uber-go/dig/compare/v1.17.0...v1.17.1\n\n## [1.17.0] - 2023-05-02\n### Added\n- Allow using `dig.As` with `dig.Group`.\n- Add `FillInvokeInfo` Option and `InvokeInfo` struct to help\n  extract the types requested by an `Invoke` statement.\n- To get visibility into constructor and decorator calls, introduce\n  `WithProviderCallback` and `WithDecoratorCallback` Options to provide callback functions.\n\n[1.17.0]: https://github.com/uber-go/dig/compare/v1.16.1...v1.17.0\n\n## [1.16.1] - 2023-01-10\n### Fixed\n- A panic when `DryRun` was used with `Decorate`.\n\n[1.16.1]: https://github.com/uber-go/dig/compare/v1.16.0...v1.16.1\n\n## [1.16.0] - 2023-01-03\n### Added\n- Add `RecoverFromPanics` option, which provides panic-recovery mechanism for Container.\n- Add `Error` interface which enables distinguishing errors from Dig using standard `errors`\n  package.\n\nThanks to @mie998 for their contribution(s) to this release.\n\n[1.16.0]: https://github.com/uber-go/dig/compare/v1.15.0...v1.16.0\n\n## [1.15.0] - 2022-08-02\n### Added\n- Support for `soft` value groups, which specify a value group that only gets populated\n  with values from already-executed constructors.\n\n### Fixed\n- Fix an issue with invoke order affecting results provided by private provides\n\nThanks to @hbdf for their contributions to this release.\n\n[1.15.0]: https://github.com/uber-go/dig/compare/v1.14.1...v1.15.0\n\n## [1.14.1] - 2022-03-22\n### Fixed\n- Fix an issue where a dependency for a decoration supplied by another decorator in the\n  same scope is ignored.\n- Fix a panic when submitting a single value as a value group in `Scope.Decorate`.\n- Upon a provide error, make the error message contain the function named specified\n  by LocationForPC Option.\n\n[1.14.1]: https://github.com/uber-go/dig/compare/v1.14.0...v1.14.1\n\n## [1.14.0] - 2022-02-23\n### Added\n- Introduce `dig.Scope` which creates a scoped dependency injection\n  container to scope dependencies.\n- Introduce `Scope.Decorate` and `Container.Decorate` which allows a\n  decorator to modify a dependency already provided in the dependency graph.\n- Add `FillDecorateInfo` Option and `DecorateInfo` struct which exposes\n  information on what Dig was able to understand from the decorator provided\n  with `Scope.Decorate` or `Container.Decorate`.\n\n### Changed\n- The error message that appears when a cycle is detected in the dependency graph\n  has been changed slightly.\n\n### Fixed\n- A stack overflow bug that happens when cycles are introduced via self-pointing\n  dependencies with DeferAcyclicVerification.\n\n[1.14.0]: https://github.com/uber-go/dig/compare/v1.13.0...v1.14.0\n\n## [1.13.0] - 2021-09-21\n### Added\n- Introduce `As` option which supports providing a type as interface(s)\n  it implements to the container.\n- Add `LocationForPC` option which overrides the function inspection\n  for a program counter address to a provided function info.\n\n[1.13.0]: https://github.com/uber-go/dig/compare/v1.12.0...v1.13.0\n\n## [1.12.0] - 2021-07-29\n### Added\n- Support for ProvideInfo and FillProvideInfo that allow the caller of\n  `Provide` to get info about what dig understood from the constructor.\n\n[1.12.0]: https://github.com/uber-go/dig/compare/v1.11.0...v1.12.0\n\n## [1.11.0] - 2021-06-09\n### Added\n- Support unexported fields on `dig.In` structs with the\n  `ignore-unexported:\"true` struct tag.\n\n[1.11.0]: https://github.com/uber-go/dig/compare/v1.10.0...v1.11.0\n\n## [1.10.0] - 2020-06-16\n### Added\n- Introduce `DryRun` Option which, when set to true, disables invocation\n  of functions supplied to `Provide` and `Invoke`. This option will be\n  used to build no-op containers, for example for `fx.ValidateApp` method.\n\n[1.10.0]: https://github.com/uber-go/dig/compare/v1.9.0...v1.10.0\n\n## [1.9.0] - 2020-03-31\n### Added\n- GraphViz visualization of the graph now includes names of packages next to\n  constructors.\n- Added a `flatten` modifier to group tags for slices to allow providing\n  individual elements instead of the slice for a group value. See package\n  doucmentation for more information.\n\n### Changed\n- Drop library dependency on `golang.org/x/lint`.\n- Support printing multi-line error messages with `%+v`.\n\n[1.9.0]: https://github.com/uber-go/dig/compare/v1.8.0...v1.9.0\n\n## [1.8.0] - 2019-11-14\n### Changed\n- Migrated to Go modules.\n\n[1.8.0]: https://github.com/uber-go/dig/compare/v1.7.0...v1.8.0\n\n## [1.7.0] - 2019-01-04\n### Added\n- Added `Group` option for `Provide` to add value groups to the container without\nrewriting constructors. See package doucmentation for more information.\n\n[1.7.0]: https://github.com/uber-go/dig/compare/v1.6.0...v1.7.0\n\n## [1.6.0] - 2018-11-06\n### Changed\n- When an error graph is visualized, the graph is pruned so that the graph only\n  contains failure nodes.\n- Container visualization is now oriented from right to left.\n\n[1.6.0]: https://github.com/uber-go/dig/compare/v1.5.1...v1.6.0\n\n## [1.5.1] - 2018-11-01\n### Fixed\n- Fixed a test that was causing Dig to be unusable with Go Modules.\n\n[1.5.1]: https://github.com/uber-go/dig/compare/v1.5.0...v1.5.1\n\n## [1.5.0] - 2018-09-19\n### Added\n- Added a `DeferAcyclicVerification` container option that defers graph cycle\n  detection until the next Invoke.\n\n### Changed\n- Improved cycle-detection performance by 50x in certain degenerative cases.\n\n[1.5.0]: https://github.com/uber-go/dig/compare/v1.4.0...v1.5.0\n\n## [1.4.0] - 2018-08-16\n### Added\n- Added `Visualize` function to visualize the state of the container in the\n  GraphViz DOT format. This allows visualization of error types and the\n  dependency relationships of types in the container.\n- Added `CanVisualizeError` function to determine if an error can be visualized\n  in the graph.\n- Added `Name` option for `Provide` to add named values to the container\n  without rewriting constructors. See package documentation for more\n  information.\n\n### Changed\n- `name:\"...\"` tags on nested Result Objects will now cause errors instead of\n  being ignored.\n\n[1.4.0]: https://github.com/uber-go/dig/compare/v1.3.0...v1.4.0\n\n## [1.3.0] - 2017-12-04\n### Changed\n- Improved messages for errors thrown by Dig under a many scenarios to be more\n  informative.\n\n[1.3.0]: https://github.com/uber-go/dig/compare/v1.2.0...v1.3.0\n\n## [1.2.0] - 2017-11-07\n### Added\n- `dig.In` and `dig.Out` now support value groups, making it possible to\n  produce many values of the same type from different constructors. See package\n  documentation for more information.\n\n[1.2.0]: https://github.com/uber-go/dig/compare/v1.1.0...v1.2.0\n\n## [1.1.0] - 2017-09-15\n### Added\n- Added the `dig.RootCause` function which allows retrieving the original\n  constructor error that caused an `Invoke` failure.\n\n### Changed\n- Errors from `Invoke` now attempt to hint to the user a presence of a similar\n  type, for example a pointer to the requested type and vice versa.\n\n[1.1.0]: https://github.com/uber-go/dig/compare/v1.0.0...v1.1.0\n\n## [1.0.0] - 2017-07-31\n\nFirst stable release: no breaking changes will be made in the 1.x series.\n\n### Changed\n- `Provide` and `Invoke` will now fail if `dig.In` or `dig.Out` structs\n  contain unexported fields. Previously these fields were ignored which often\n  led to confusion.\n\n[1.0.0]: https://github.com/uber-go/dig/compare/v1.0.0-rc2...v1.0.0\n\n## [1.0.0-rc2] - 2017-07-21\n### Added\n- Exported `dig.IsIn` and `dig.IsOut` so that consuming libraries can check if\n  a params or return struct embeds the `dig.In` and `dig.Out` types, respectively.\n\n### Changed\n- Added variadic options to all public APIS so that new functionality can be\n  introduced post v1.0.0 without introducing breaking changes.\n- Functions with variadic arguments can now be passed to `dig.Provide` and\n  `dig.Invoke`. Previously this caused an error, whereas now the args will be ignored.\n\n[1.0.0-rc2]: https://github.com/uber-go/dig/compare/v1.0.0-rc1...v1.0.0-rc2\n\n## [1.0.0-rc1] - 2017-06-21\n\nFirst release candidate.\n\n[1.0.0-rc1]: https://github.com/uber-go/dig/compare/v0.5.0...v1.0.0-rc1\n\n\n## [0.5.0] - 2017-06-19\n### Added\n- `dig.In` and `dig.Out` now support named instances, i.e.:\n\n    ```go\n    type param struct {\n      dig.In\n\n      DB1 DB.Connection `name:\"primary\"`\n      DB2 DB.Connection `name:\"secondary\"`\n    }\n    ```\n\n### Fixed\n- Structs compatible with `dig.In` and `dig.Out` may now be generated using\n  `reflect.StructOf`.\n\n[0.5.0]: https://github.com/uber-go/dig/compare/v0.4.0...v0.5.0\n\n## [0.4.0] - 2017-06-12\n### Added\n- Add `dig.In` embeddable type for advanced use-cases of specifying dependencies.\n- Add `dig.Out` embeddable type for advanced use-cases of constructors\n  inserting types in the container.\n- Add support for optional parameters through `optional:\"true\"` tag on `dig.In` objects.\n- Add support for value types and many built-ins (maps, slices, channels).\n\n### Changed\n- **[Breaking]** Restrict the API surface to only `Provide` and `Invoke`.\n- **[Breaking]** Update `Provide` method to accept variadic arguments.\n\n### Removed\n- **[Breaking]** Remove `Must*` funcs to greatly reduce API surface area.\n- Providing constructors with common returned types results in an error.\n\n[0.4.0]: https://github.com/uber-go/dig/compare/v0.3...v0.4.0\n\n## [0.3] - 2017-05-02\n### Added\n- Add functionality to `Provide` to support constructor with `n` return\n  objects to be resolved into the `dig.Graph`\n- Add `Invoke` function to invoke provided function and insert return\n  objects into the `dig.Graph`\n\n### Changed\n- Rename `RegisterAll` and `MustRegisterAll` to `ProvideAll` and\n  `MustProvideAll`.\n\n[0.3]: https://github.com/uber-go/dig/compare/v0.2...v0.3\n\n## [0.2] - 2017-03-27\n### Changed\n- Rename `Register` to `Provide` for clarity and to recude clash with other\n  Register functions.\n- Rename `dig.Graph` to `dig.Container`.\n\n### Removed\n- Remove the package-level functions and the `DefaultGraph`.\n\n[0.2]: https://github.com/uber-go/dig/compare/v0.1...v0.2\n\n## 0.1 - 2017-03-23\n\nInitial release.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "Copyright (c) 2017-2018 Uber Technologies, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.8994140625,
          "content": "# Directory containing the Makefile.\nPROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))\n\nexport GOBIN ?= $(PROJECT_ROOT)/bin\nexport PATH := $(GOBIN):$(PATH)\n\nBENCH_FLAGS ?= -cpuprofile=cpu.pprof -memprofile=mem.pprof -benchmem\n\nGO_FILES = $(shell \\\n\tfind . '(' -path '*/.*' -o -path './vendor' ')' -prune \\\n\t-o -name '*.go' -print | cut -b3-)\n\n.PHONY: all\nall: build lint test\n\n.PHONY: build\nbuild:\n\tgo build ./...\n\n.PHONY: lint\nlint: golangci-lint tidy-lint\n\n.PHONY: test\ntest:\n\tgo test -race ./...\n\n.PHONY: cover\ncover:\n\tgo test -race -coverprofile=cover.out -coverpkg=./... ./...\n\tgo tool cover -html=cover.out -o cover.html\n\n.PHONY: bench\nBENCH ?= .\nbench:\n\tgo list ./... | xargs -n1 go test -bench=$(BENCH) -run=\"^$$\" $(BENCH_FLAGS)\n\n.PHONY: tidy\ntidy:\n\tgo mod tidy\n\n.PHONY: golangci-lint\ngolangci-lint:\n\tgolangci-lint run\n\n.PHONY: tidy-lint\ntidy-lint:\n\tgo mod tidy\n\tgit diff --exit-code -- go.mod go.sum\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.8193359375,
          "content": "# :hammer_and_pick: dig [![GoDoc][doc-img]][doc] [![GitHub release][release-img]][release] [![Build Status][ci-img]][ci] [![Coverage Status][cov-img]][cov] [![Go Report Card][report-card-img]][report-card]\n\nA reflection based dependency injection toolkit for Go.\n\n### Good for:\n\n* Powering an application framework, e.g. [Fx](https://github.com/uber-go/fx).\n* Resolving the object graph during process startup.\n\n### Bad for:\n\n* Using in place of an application framework, e.g. [Fx](https://github.com/uber-go/fx).\n* Resolving dependencies after the process has already started.\n* Exposing to user-land code as a [Service Locator](https://martinfowler.com/articles/injection.html#UsingAServiceLocator).\n\n## Installation\n\nWe recommend consuming [SemVer](http://semver.org/) major version `1` using\nyour dependency manager of choice.\n\n```\n$ glide get 'go.uber.org/dig#^1'\n$ dep ensure -add \"go.uber.org/dig@v1\"\n$ go get 'go.uber.org/dig@v1'\n```\n\n## Stability\n\nThis library is `v1` and follows [SemVer](http://semver.org/) strictly.\n\nNo breaking changes will be made to exported APIs before `v2.0.0`.\n\n[doc-img]: http://img.shields.io/badge/GoDoc-Reference-blue.svg\n[doc]: https://godoc.org/go.uber.org/dig\n\n[release-img]: https://img.shields.io/github/release/uber-go/dig.svg\n[release]: https://github.com/uber-go/dig/releases\n\n[ci-img]: https://github.com/uber-go/dig/actions/workflows/go.yml/badge.svg\n[ci]: https://github.com/uber-go/dig/actions/workflows/go.yml\n\n[cov-img]: https://codecov.io/gh/uber-go/dig/branch/master/graph/badge.svg\n[cov]: https://codecov.io/gh/uber-go/dig/branch/master\n\n[report-card-img]: https://goreportcard.com/badge/github.com/uber-go/dig\n[report-card]: https://goreportcard.com/report/github.com/uber-go/dig\n\n## Stargazers over time\n\n[![Stargazers over time](https://starchart.cc/uber-go/dig.svg)](https://starchart.cc/uber-go/dig)\n\n"
        },
        {
          "name": "callback.go",
          "type": "blob",
          "size": 3.958984375,
          "content": "// Copyright (c) 2023 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport \"time\"\n\n// CallbackInfo contains information about a provided function or decorator\n// called by Dig, and is passed to a [Callback] registered with\n// [WithProviderCallback] or [WithDecoratorCallback].\ntype CallbackInfo struct {\n\t// Name is the name of the function in the format:\n\t// <package_name>.<function_name>\n\tName string\n\n\t// Error contains the error returned by the [Callback]'s associated\n\t// function, if any. When used in conjunction with [RecoverFromPanics],\n\t// this will be set to a [PanicError] when the function panics.\n\tError error\n\n\t// Runtime contains the duration it took for the associated\n\t// function to run.\n\tRuntime time.Duration\n}\n\n// Callback is a function that can be registered with a provided function\n// or decorator with [WithCallback] to cause it to be called after the\n// provided function or decorator is run.\ntype Callback func(CallbackInfo)\n\n// WithProviderCallback returns a [ProvideOption] which has Dig call\n// the passed in [Callback] after the corresponding constructor finishes running.\n//\n// For example, the following prints a completion message\n// after \"myConstructor\" finishes, including the error if any:\n//\n//\tc := dig.New()\n//\tmyCallback := func(ci CallbackInfo) {\n//\t\tvar errorAdd string\n//\t\tif ci.Error != nil {\n//\t\t\terrorAdd = fmt.Sprintf(\"with error: %v\", ci.Error)\n//\t\t}\n//\t\tfmt.Printf(\"%q finished%v\", ci.Name, errorAdd)\n//\t}\n//\tc.Provide(myConstructor, WithProviderCallback(myCallback)),\n//\n// Callbacks can also be specified for Decorators with [WithDecoratorCallback].\n//\n// See [CallbackInfo] for more info on the information passed to the [Callback].\nfunc WithProviderCallback(callback Callback) ProvideOption {\n\treturn withCallbackOption{\n\t\tcallback: callback,\n\t}\n}\n\n// WithDecoratorCallback returns a [DecorateOption] which has Dig call\n// the passed in [Callback] after the corresponding decorator finishes running.\n//\n// For example, the following prints a completion message\n// after \"myDecorator\" finishes, including the error if any:\n//\n//\tc := dig.New()\n//\tmyCallback := func(ci CallbackInfo) {\n//\t\tvar errorAdd string\n//\t\tif ci.Error != nil {\n//\t\t\terrorAdd = fmt.Sprintf(\"with error: %v\", ci.Error)\n//\t\t}\n//\t\tfmt.Printf(\"%q finished%v\", ci.Name, errorAdd)\n//\t}\n//\tc.Decorate(myDecorator, WithDecoratorCallback(myCallback)),\n//\n// Callbacks can also be specified for Constructors with [WithProviderCallback].\n//\n// See [CallbackInfo] for more info on the information passed to the [Callback].\nfunc WithDecoratorCallback(callback Callback) DecorateOption {\n\treturn withCallbackOption{\n\t\tcallback: callback,\n\t}\n}\n\ntype withCallbackOption struct {\n\tcallback Callback\n}\n\nvar (\n\t_ ProvideOption  = withCallbackOption{}\n\t_ DecorateOption = withCallbackOption{}\n)\n\nfunc (o withCallbackOption) applyProvideOption(po *provideOptions) {\n\tpo.Callback = o.callback\n}\n\nfunc (o withCallbackOption) apply(do *decorateOptions) {\n\tdo.Callback = o.callback\n}\n"
        },
        {
          "name": "constructor.go",
          "type": "blob",
          "size": 7.2255859375,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"go.uber.org/dig/internal/digerror\"\n\t\"go.uber.org/dig/internal/digreflect\"\n\t\"go.uber.org/dig/internal/dot\"\n)\n\n// constructorNode is a node in the dependency graph that represents\n// a constructor provided by the user.\n//\n// constructorNodes can produce zero or more values that they store into the container.\n// For the Provide path, we verify that constructorNodes produce at least one value,\n// otherwise the function will never be called.\ntype constructorNode struct {\n\tctor  interface{}\n\tctype reflect.Type\n\n\t// Location where this function was defined.\n\tlocation *digreflect.Func\n\n\t// id uniquely identifies the constructor that produces a node.\n\tid dot.CtorID\n\n\t// Whether the constructor owned by this node was already called.\n\tcalled bool\n\n\t// Type information about constructor parameters.\n\tparamList paramList\n\n\t// Type information about constructor results.\n\tresultList resultList\n\n\t// Order of this node in each Scopes' graphHolders.\n\torders map[*Scope]int\n\n\t// Scope this node is part of.\n\ts *Scope\n\n\t// Scope this node was originally provided to.\n\t// This is different from s if and only if the constructor was Provided with ExportOption.\n\torigS *Scope\n\n\t// Callback for this provided function, if there is one.\n\tcallback Callback\n}\n\ntype constructorOptions struct {\n\t// If specified, all values produced by this constructor have the provided name\n\t// belong to the specified value group or implement any of the interfaces.\n\tResultName  string\n\tResultGroup string\n\tResultAs    []interface{}\n\tLocation    *digreflect.Func\n\tCallback    Callback\n}\n\nfunc newConstructorNode(ctor interface{}, s *Scope, origS *Scope, opts constructorOptions) (*constructorNode, error) {\n\tcval := reflect.ValueOf(ctor)\n\tctype := cval.Type()\n\tcptr := cval.Pointer()\n\n\tparams, err := newParamList(ctype, s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresults, err := newResultList(\n\t\tctype,\n\t\tresultOptions{\n\t\t\tName:  opts.ResultName,\n\t\t\tGroup: opts.ResultGroup,\n\t\t\tAs:    opts.ResultAs,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlocation := opts.Location\n\tif location == nil {\n\t\tlocation = digreflect.InspectFunc(ctor)\n\t}\n\n\tn := &constructorNode{\n\t\tctor:       ctor,\n\t\tctype:      ctype,\n\t\tlocation:   location,\n\t\tid:         dot.CtorID(cptr),\n\t\tparamList:  params,\n\t\tresultList: results,\n\t\torders:     make(map[*Scope]int),\n\t\ts:          s,\n\t\torigS:      origS,\n\t\tcallback:   opts.Callback,\n\t}\n\ts.newGraphNode(n, n.orders)\n\treturn n, nil\n}\n\nfunc (n *constructorNode) Location() *digreflect.Func { return n.location }\nfunc (n *constructorNode) ParamList() paramList       { return n.paramList }\nfunc (n *constructorNode) ResultList() resultList     { return n.resultList }\nfunc (n *constructorNode) ID() dot.CtorID             { return n.id }\nfunc (n *constructorNode) CType() reflect.Type        { return n.ctype }\nfunc (n *constructorNode) Order(s *Scope) int         { return n.orders[s] }\nfunc (n *constructorNode) OrigScope() *Scope          { return n.origS }\n\n// CopyOrder copies the order for the given parent scope to the given child scope.\nfunc (n *constructorNode) CopyOrder(parent, child *Scope) {\n\tn.orders[child] = n.orders[parent]\n}\n\nfunc (n *constructorNode) String() string {\n\treturn fmt.Sprintf(\"deps: %v, ctor: %v\", n.paramList, n.ctype)\n}\n\n// Call calls this constructor if it hasn't already been called and\n// injects any values produced by it into the provided container.\nfunc (n *constructorNode) Call(c containerStore) (err error) {\n\tif n.called {\n\t\treturn nil\n\t}\n\n\tif err := shallowCheckDependencies(c, n.paramList); err != nil {\n\t\treturn errMissingDependencies{\n\t\t\tFunc:   n.location,\n\t\t\tReason: err,\n\t\t}\n\t}\n\n\targs, err := n.paramList.BuildList(c)\n\tif err != nil {\n\t\treturn errArgumentsFailed{\n\t\t\tFunc:   n.location,\n\t\t\tReason: err,\n\t\t}\n\t}\n\n\tif n.callback != nil {\n\t\tstart := c.clock().Now()\n\t\t// Wrap in separate func to include PanicErrors\n\t\tdefer func() {\n\t\t\tn.callback(CallbackInfo{\n\t\t\t\tName:    fmt.Sprintf(\"%v.%v\", n.location.Package, n.location.Name),\n\t\t\t\tError:   err,\n\t\t\t\tRuntime: c.clock().Since(start),\n\t\t\t})\n\t\t}()\n\t}\n\n\tif n.s.recoverFromPanics {\n\t\tdefer func() {\n\t\t\tif p := recover(); p != nil {\n\t\t\t\terr = PanicError{\n\t\t\t\t\tfn:    n.location,\n\t\t\t\t\tPanic: p,\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\treceiver := newStagingContainerWriter()\n\tresults := c.invoker()(reflect.ValueOf(n.ctor), args)\n\tif err = n.resultList.ExtractList(receiver, false /* decorating */, results); err != nil {\n\t\treturn errConstructorFailed{Func: n.location, Reason: err}\n\t}\n\n\t// Commit the result to the original container that this constructor\n\t// was supplied to. The provided constructor is only used for a view of\n\t// the rest of the graph to instantiate the dependencies of this\n\t// container.\n\treceiver.Commit(n.s)\n\tn.called = true\n\treturn nil\n}\n\n// stagingContainerWriter is a containerWriter that records the changes that\n// would be made to a containerWriter and defers them until Commit is called.\ntype stagingContainerWriter struct {\n\tvalues map[key]reflect.Value\n\tgroups map[key][]reflect.Value\n}\n\nvar _ containerWriter = (*stagingContainerWriter)(nil)\n\nfunc newStagingContainerWriter() *stagingContainerWriter {\n\treturn &stagingContainerWriter{\n\t\tvalues: make(map[key]reflect.Value),\n\t\tgroups: make(map[key][]reflect.Value),\n\t}\n}\n\nfunc (sr *stagingContainerWriter) setValue(name string, t reflect.Type, v reflect.Value) {\n\tsr.values[key{t: t, name: name}] = v\n}\n\nfunc (sr *stagingContainerWriter) setDecoratedValue(_ string, _ reflect.Type, _ reflect.Value) {\n\tdigerror.BugPanicf(\"stagingContainerWriter.setDecoratedValue must never be called\")\n}\n\nfunc (sr *stagingContainerWriter) submitGroupedValue(group string, t reflect.Type, v reflect.Value) {\n\tk := key{t: t, group: group}\n\tsr.groups[k] = append(sr.groups[k], v)\n}\n\nfunc (sr *stagingContainerWriter) submitDecoratedGroupedValue(_ string, _ reflect.Type, _ reflect.Value) {\n\tdigerror.BugPanicf(\"stagingContainerWriter.submitDecoratedGroupedValue must never be called\")\n}\n\n// Commit commits the received results to the provided containerWriter.\nfunc (sr *stagingContainerWriter) Commit(cw containerWriter) {\n\tfor k, v := range sr.values {\n\t\tcw.setValue(k.name, k.t, v)\n\t}\n\n\tfor k, vs := range sr.groups {\n\t\tfor _, v := range vs {\n\t\t\tcw.submitGroupedValue(k.group, k.t, v)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "constructor_test.go",
          "type": "blob",
          "size": 2.2333984375,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/dig/internal/digreflect\"\n)\n\nfunc TestNewDotCtor(t *testing.T) {\n\ttype t1 struct{}\n\ttype t2 struct{}\n\n\ts := newScope()\n\tn, err := newConstructorNode(func(A t1) t2 { return t2{} }, s, s, constructorOptions{})\n\trequire.NoError(t, err)\n\n\tn.location = &digreflect.Func{\n\t\tName:    \"function1\",\n\t\tPackage: \"pkg1\",\n\t\tFile:    \"file1\",\n\t\tLine:    24534,\n\t}\n\n\tctor := newDotCtor(n)\n\tassert.Equal(t, n.id, ctor.ID)\n\tassert.Equal(t, \"function1\", ctor.Name)\n\tassert.Equal(t, \"pkg1\", ctor.Package)\n\tassert.Equal(t, \"file1\", ctor.File)\n\tassert.Equal(t, 24534, ctor.Line)\n}\n\nfunc TestNodeAlreadyCalled(t *testing.T) {\n\ttype type1 struct{}\n\tf := func() type1 { return type1{} }\n\n\ts := newScope()\n\tn, err := newConstructorNode(f, s, s, constructorOptions{})\n\trequire.NoError(t, err, \"failed to build node\")\n\trequire.False(t, n.called, \"node must not have been called\")\n\n\tc := New()\n\trequire.NoError(t, n.Call(c.scope), \"invoke failed\")\n\trequire.True(t, n.called, \"node must be called\")\n\trequire.NoError(t, n.Call(c.scope), \"calling again should be okay\")\n}\n"
        },
        {
          "name": "container.go",
          "type": "blob",
          "size": 8.9296875,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\n\t\"go.uber.org/dig/internal/digclock\"\n\t\"go.uber.org/dig/internal/dot\"\n)\n\nconst (\n\t_optionalTag         = \"optional\"\n\t_nameTag             = \"name\"\n\t_ignoreUnexportedTag = \"ignore-unexported\"\n)\n\n// Unique identification of an object in the graph.\ntype key struct {\n\tt reflect.Type\n\n\t// Only one of name or group will be set.\n\tname  string\n\tgroup string\n}\n\nfunc (k key) String() string {\n\tif k.name != \"\" {\n\t\treturn fmt.Sprintf(\"%v[name=%q]\", k.t, k.name)\n\t}\n\tif k.group != \"\" {\n\t\treturn fmt.Sprintf(\"%v[group=%q]\", k.t, k.group)\n\t}\n\treturn k.t.String()\n}\n\n// Option configures a Container.\ntype Option interface {\n\tapplyOption(*Container)\n}\n\n// Container is a directed acyclic graph of types and their dependencies.\n// A Container is the root Scope that represents the top-level scoped\n// directed acyclic graph of the dependencies.\ntype Container struct {\n\t// this is the \"root\" Scope that represents the\n\t// root of the scope tree.\n\tscope *Scope\n}\n\n// containerWriter provides write access to the Container's underlying data\n// store.\ntype containerWriter interface {\n\t// setValue sets the value with the given name and type in the container.\n\t// If a value with the same name and type already exists, it will be\n\t// overwritten.\n\tsetValue(name string, t reflect.Type, v reflect.Value)\n\n\t// setDecoratedValue sets a decorated value with the given name and type\n\t// in the container. If a decorated value with the same name and type already\n\t// exists, it will be overwritten.\n\tsetDecoratedValue(name string, t reflect.Type, v reflect.Value)\n\n\t// submitGroupedValue submits a value to the value group with the provided\n\t// name.\n\tsubmitGroupedValue(name string, t reflect.Type, v reflect.Value)\n\n\t// submitDecoratedGroupedValue submits a decorated value to the value group\n\t// with the provided name.\n\tsubmitDecoratedGroupedValue(name string, t reflect.Type, v reflect.Value)\n}\n\n// containerStore provides access to the Container's underlying data store.\ntype containerStore interface {\n\tcontainerWriter\n\n\t// Adds a new graph node to the Container\n\tnewGraphNode(w interface{}, orders map[*Scope]int)\n\n\t// Returns a slice containing all known types.\n\tknownTypes() []reflect.Type\n\n\t// Retrieves the value with the provided name and type, if any.\n\tgetValue(name string, t reflect.Type) (v reflect.Value, ok bool)\n\n\t// Retrieves a decorated value with the provided name and type, if any.\n\tgetDecoratedValue(name string, t reflect.Type) (v reflect.Value, ok bool)\n\n\t// Retrieves all values for the provided group and type.\n\t//\n\t// The order in which the values are returned is undefined.\n\tgetValueGroup(name string, t reflect.Type) []reflect.Value\n\n\t// Retrieves all decorated values for the provided group and type, if any.\n\tgetDecoratedValueGroup(name string, t reflect.Type) (reflect.Value, bool)\n\n\t// Returns the providers that can produce a value with the given name and\n\t// type.\n\tgetValueProviders(name string, t reflect.Type) []provider\n\n\t// Returns the providers that can produce values for the given group and\n\t// type.\n\tgetGroupProviders(name string, t reflect.Type) []provider\n\n\t// Returns the providers that can produce a value with the given name and\n\t// type across all the Scopes that are in effect of this containerStore.\n\tgetAllValueProviders(name string, t reflect.Type) []provider\n\n\t// Returns the decorator that can decorate values for the given name and\n\t// type.\n\tgetValueDecorator(name string, t reflect.Type) (decorator, bool)\n\n\t// Reutrns the decorator that can decorate values for the given group and\n\t// type.\n\tgetGroupDecorator(name string, t reflect.Type) (decorator, bool)\n\n\t// Reports a list of stores (starting at this store) up to the root\n\t// store.\n\tstoresToRoot() []containerStore\n\n\tcreateGraph() *dot.Graph\n\n\t// Returns invokerFn function to use when calling arguments.\n\tinvoker() invokerFn\n\n\t// Returns a clock to use\n\tclock() digclock.Clock\n}\n\n// New constructs a Container.\nfunc New(opts ...Option) *Container {\n\ts := newScope()\n\tc := &Container{scope: s}\n\n\tfor _, opt := range opts {\n\t\topt.applyOption(c)\n\t}\n\treturn c\n}\n\n// DeferAcyclicVerification is an Option to override the default behavior\n// of container.Provide, deferring the dependency graph validation to no longer\n// run after each call to container.Provide. The container will instead verify\n// the graph on first `Invoke`.\n//\n// Applications adding providers to a container in a tight loop may experience\n// performance improvements by initializing the container with this option.\nfunc DeferAcyclicVerification() Option {\n\treturn deferAcyclicVerificationOption{}\n}\n\ntype deferAcyclicVerificationOption struct{}\n\nfunc (deferAcyclicVerificationOption) String() string {\n\treturn \"DeferAcyclicVerification()\"\n}\n\nfunc (deferAcyclicVerificationOption) applyOption(c *Container) {\n\tc.scope.deferAcyclicVerification = true\n}\n\n// RecoverFromPanics is an [Option] to recover from panics that occur while\n// running functions given to the container. When set, recovered panics\n// will be placed into a [PanicError], and returned at the invoke callsite.\n// See [PanicError] for an example on how to handle panics with this option\n// enabled, and distinguish them from errors.\nfunc RecoverFromPanics() Option {\n\treturn recoverFromPanicsOption{}\n}\n\ntype recoverFromPanicsOption struct{}\n\nfunc (recoverFromPanicsOption) String() string {\n\treturn \"RecoverFromPanics()\"\n}\n\nfunc (recoverFromPanicsOption) applyOption(c *Container) {\n\tc.scope.recoverFromPanics = true\n}\n\n// Changes the source of randomness for the container.\n//\n// This will help provide determinism during tests.\nfunc setRand(r *rand.Rand) Option {\n\treturn setRandOption{r: r}\n}\n\ntype setRandOption struct{ r *rand.Rand }\n\nfunc (o setRandOption) String() string {\n\treturn fmt.Sprintf(\"setRand(%p)\", o.r)\n}\n\nfunc (o setRandOption) applyOption(c *Container) {\n\tc.scope.rand = o.r\n}\n\n// Changes the source of time for the container.\nfunc setClock(c digclock.Clock) Option {\n\treturn setClockOption{c: c}\n}\n\ntype setClockOption struct{ c digclock.Clock }\n\nfunc (o setClockOption) String() string {\n\treturn fmt.Sprintf(\"setClock(%v)\", o.c)\n}\n\nfunc (o setClockOption) applyOption(c *Container) {\n\tc.scope.clockSrc = o.c\n}\n\n// DryRun is an Option which, when set to true, disables invocation of functions supplied to\n// Provide and Invoke. Use this to build no-op containers.\nfunc DryRun(dry bool) Option {\n\treturn dryRunOption(dry)\n}\n\ntype dryRunOption bool\n\nfunc (o dryRunOption) String() string {\n\treturn fmt.Sprintf(\"DryRun(%v)\", bool(o))\n}\n\nfunc (o dryRunOption) applyOption(c *Container) {\n\tif o {\n\t\tc.scope.invokerFn = dryInvoker\n\t} else {\n\t\tc.scope.invokerFn = defaultInvoker\n\t}\n}\n\n// invokerFn specifies how the container calls user-supplied functions.\ntype invokerFn func(fn reflect.Value, args []reflect.Value) (results []reflect.Value)\n\nfunc defaultInvoker(fn reflect.Value, args []reflect.Value) []reflect.Value {\n\treturn fn.Call(args)\n}\n\n// Generates zero values for results without calling the supplied function.\nfunc dryInvoker(fn reflect.Value, _ []reflect.Value) []reflect.Value {\n\tft := fn.Type()\n\tresults := make([]reflect.Value, ft.NumOut())\n\tfor i := 0; i < ft.NumOut(); i++ {\n\t\tresults[i] = reflect.Zero(fn.Type().Out(i))\n\t}\n\n\treturn results\n}\n\n// String representation of the entire Container\nfunc (c *Container) String() string {\n\treturn c.scope.String()\n}\n\n// Scope creates a child scope of the Container with the given name.\nfunc (c *Container) Scope(name string, opts ...ScopeOption) *Scope {\n\treturn c.scope.Scope(name, opts...)\n}\n\ntype byTypeName []reflect.Type\n\nfunc (bs byTypeName) Len() int {\n\treturn len(bs)\n}\n\nfunc (bs byTypeName) Less(i int, j int) bool {\n\treturn fmt.Sprint(bs[i]) < fmt.Sprint(bs[j])\n}\n\nfunc (bs byTypeName) Swap(i int, j int) {\n\tbs[i], bs[j] = bs[j], bs[i]\n}\n\nfunc shuffledCopy(rand *rand.Rand, items []reflect.Value) []reflect.Value {\n\tnewItems := make([]reflect.Value, len(items))\n\tfor i, j := range rand.Perm(len(items)) {\n\t\tnewItems[i] = items[j]\n\t}\n\treturn newItems\n}\n"
        },
        {
          "name": "container_test.go",
          "type": "blob",
          "size": 2.111328125,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestOptionStrings(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"DeferAcyclicVerification\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tassert.Equal(t, \"DeferAcyclicVerification()\", fmt.Sprint(DeferAcyclicVerification()))\n\t})\n\n\tt.Run(\"setRand\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tt.Run(\"nil\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tassert.Equal(t, \"setRand(0x0)\", fmt.Sprint(setRand(nil)))\n\t\t})\n\n\t\tt.Run(\"non nil\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\topt := setRand(rand.New(rand.NewSource(42)))\n\t\t\tassert.NotEqual(t, \"setRand(0x0)\", fmt.Sprint(opt))\n\t\t\tassert.Contains(t, fmt.Sprint(opt), \"setRand(0x\")\n\t\t})\n\t})\n\n\tt.Run(\"DryRun\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tassert.Equal(t, \"DryRun(true)\", fmt.Sprint(DryRun(true)))\n\t\tassert.Equal(t, \"DryRun(false)\", fmt.Sprint(DryRun(false)))\n\t})\n\n\tt.Run(\"RecoverFromPanics()\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tassert.Equal(t, \"RecoverFromPanics()\", fmt.Sprint(RecoverFromPanics()))\n\t})\n}\n"
        },
        {
          "name": "cycle_error.go",
          "type": "blob",
          "size": 2.44921875,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"go.uber.org/dig/internal/digreflect\"\n)\n\ntype cycleErrPathEntry struct {\n\tKey  key\n\tFunc *digreflect.Func\n}\n\ntype errCycleDetected struct {\n\tPath  []cycleErrPathEntry\n\tscope *Scope\n}\n\nvar _ digError = errCycleDetected{}\n\nfunc (e errCycleDetected) Error() string {\n\t// We get something like,\n\t//\n\t//   [scope \"foo\"]\n\t//   func(*bar) *foo provided by \"path/to/package\".NewFoo (path/to/file.go:42)\n\t//   \tdepends on func(*baz) *bar provided by \"another/package\".NewBar (somefile.go:1)\n\t//   \tdepends on func(*foo) baz provided by \"somepackage\".NewBar (anotherfile.go:2)\n\t//   \tdepends on func(*bar) *foo provided by \"path/to/package\".NewFoo (path/to/file.go:42)\n\t//\n\tb := new(bytes.Buffer)\n\n\tif name := e.scope.name; len(name) > 0 {\n\t\tfmt.Fprintf(b, \"[scope %q]\\n\", name)\n\t}\n\tfor i, entry := range e.Path {\n\t\tif i > 0 {\n\t\t\tb.WriteString(\"\\n\\tdepends on \")\n\t\t}\n\t\tfmt.Fprintf(b, \"%v provided by %v\", entry.Key, entry.Func)\n\t}\n\treturn b.String()\n}\n\nfunc (e errCycleDetected) writeMessage(w io.Writer, v string) {\n\tfmt.Fprint(w, e.Error())\n}\n\nfunc (e errCycleDetected) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\n// IsCycleDetected returns a boolean as to whether the provided error indicates\n// a cycle was detected in the container graph.\nfunc IsCycleDetected(err error) bool {\n\treturn errors.As(err, &errCycleDetected{})\n}\n"
        },
        {
          "name": "decorate.go",
          "type": "blob",
          "size": 8.037109375,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"go.uber.org/dig/internal/digreflect\"\n\t\"go.uber.org/dig/internal/dot\"\n)\n\ntype decoratorState int\n\nconst (\n\tdecoratorReady decoratorState = iota\n\tdecoratorOnStack\n\tdecoratorCalled\n)\n\ntype decorator interface {\n\tCall(c containerStore) error\n\tID() dot.CtorID\n\tState() decoratorState\n}\n\ntype decoratorNode struct {\n\tdcor  interface{}\n\tdtype reflect.Type\n\n\tid dot.CtorID\n\n\t// Location where this function was defined.\n\tlocation *digreflect.Func\n\n\t// Current state of this decorator\n\tstate decoratorState\n\n\t// Parameters of the decorator.\n\tparams paramList\n\n\t// Results of the decorator.\n\tresults resultList\n\n\t// Order of this node in each Scopes' graphHolders.\n\torders map[*Scope]int\n\n\t// Scope this node was originally provided to.\n\ts *Scope\n\n\t// Callback for this decorator, if there is one.\n\tcallback Callback\n}\n\nfunc newDecoratorNode(dcor interface{}, s *Scope, opts decorateOptions) (*decoratorNode, error) {\n\tdval := reflect.ValueOf(dcor)\n\tdtype := dval.Type()\n\tdptr := dval.Pointer()\n\n\tpl, err := newParamList(dtype, s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trl, err := newResultList(dtype, resultOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tn := &decoratorNode{\n\t\tdcor:     dcor,\n\t\tdtype:    dtype,\n\t\tid:       dot.CtorID(dptr),\n\t\tlocation: digreflect.InspectFunc(dcor),\n\t\torders:   make(map[*Scope]int),\n\t\tparams:   pl,\n\t\tresults:  rl,\n\t\ts:        s,\n\t\tcallback: opts.Callback,\n\t}\n\treturn n, nil\n}\n\nfunc (n *decoratorNode) Call(s containerStore) (err error) {\n\tif n.state == decoratorCalled {\n\t\treturn nil\n\t}\n\n\tn.state = decoratorOnStack\n\n\tif err := shallowCheckDependencies(s, n.params); err != nil {\n\t\treturn errMissingDependencies{\n\t\t\tFunc:   n.location,\n\t\t\tReason: err,\n\t\t}\n\t}\n\n\targs, err := n.params.BuildList(n.s)\n\tif err != nil {\n\t\treturn errArgumentsFailed{\n\t\t\tFunc:   n.location,\n\t\t\tReason: err,\n\t\t}\n\t}\n\n\tif n.callback != nil {\n\t\tstart := s.clock().Now()\n\t\t// Wrap in separate func to include PanicErrors\n\t\tdefer func() {\n\t\t\tn.callback(CallbackInfo{\n\t\t\t\tName:    fmt.Sprintf(\"%v.%v\", n.location.Package, n.location.Name),\n\t\t\t\tError:   err,\n\t\t\t\tRuntime: s.clock().Since(start),\n\t\t\t})\n\t\t}()\n\t}\n\n\tif n.s.recoverFromPanics {\n\t\tdefer func() {\n\t\t\tif p := recover(); p != nil {\n\t\t\t\terr = PanicError{\n\t\t\t\t\tfn:    n.location,\n\t\t\t\t\tPanic: p,\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tresults := s.invoker()(reflect.ValueOf(n.dcor), args)\n\tif err = n.results.ExtractList(n.s, true /* decorated */, results); err != nil {\n\t\treturn err\n\t}\n\tn.state = decoratorCalled\n\treturn nil\n}\n\nfunc (n *decoratorNode) ID() dot.CtorID { return n.id }\n\nfunc (n *decoratorNode) State() decoratorState { return n.state }\n\n// DecorateOption modifies the default behavior of Decorate.\ntype DecorateOption interface {\n\tapply(*decorateOptions)\n}\n\ntype decorateOptions struct {\n\tInfo     *DecorateInfo\n\tCallback Callback\n}\n\n// FillDecorateInfo is a DecorateOption that writes info on what Dig was\n// able to get out of the provided decorator into the provided DecorateInfo.\nfunc FillDecorateInfo(info *DecorateInfo) DecorateOption {\n\treturn fillDecorateInfoOption{info: info}\n}\n\ntype fillDecorateInfoOption struct{ info *DecorateInfo }\n\nfunc (o fillDecorateInfoOption) String() string {\n\treturn fmt.Sprintf(\"FillDecorateInfo(%p)\", o.info)\n}\n\nfunc (o fillDecorateInfoOption) apply(opts *decorateOptions) {\n\topts.Info = o.info\n}\n\n// DecorateInfo provides information about the decorator's inputs and outputs\n// types as strings, as well as the ID of the decorator supplied to the Container.\ntype DecorateInfo struct {\n\tID      ID\n\tInputs  []*Input\n\tOutputs []*Output\n}\n\n// Decorate provides a decorator for a type that has already been provided in the Container.\n// Decorations at this level affect all scopes of the container.\n// See Scope.Decorate for information on how to use this method.\nfunc (c *Container) Decorate(decorator interface{}, opts ...DecorateOption) error {\n\treturn c.scope.Decorate(decorator, opts...)\n}\n\n// Decorate provides a decorator for a type that has already been provided in the Scope.\n//\n// Similar to Provide, Decorate takes in a function with zero or more dependencies and one\n// or more results. Decorate can be used to modify a type that was already introduced to the\n// Scope, or completely replace it with a new object.\n//\n// For example,\n//\n//\ts.Decorate(func(log *zap.Logger) *zap.Logger {\n//\t  return log.Named(\"myapp\")\n//\t})\n//\n// This takes in a value, augments it with a name, and returns a replacement for it. Functions\n// in the Scope's dependency graph that use *zap.Logger will now use the *zap.Logger\n// returned by this decorator.\n//\n// A decorator can also take in multiple parameters and replace one of them:\n//\n//\ts.Decorate(func(log *zap.Logger, cfg *Config) *zap.Logger {\n//\t  return log.Named(cfg.Name)\n//\t})\n//\n// Or replace a subset of them:\n//\n//\ts.Decorate(func(\n//\t  log *zap.Logger,\n//\t  cfg *Config,\n//\t  scope metrics.Scope\n//\t) (*zap.Logger, metrics.Scope) {\n//\t  log = log.Named(cfg.Name)\n//\t  scope = scope.With(metrics.Tag(\"service\", cfg.Name))\n//\t  return log, scope\n//\t})\n//\n// Decorating a Scope affects all the child scopes of this Scope.\n//\n// Similar to a provider, the decorator function gets called *at most once*.\nfunc (s *Scope) Decorate(decorator interface{}, opts ...DecorateOption) error {\n\tvar options decorateOptions\n\tfor _, opt := range opts {\n\t\topt.apply(&options)\n\t}\n\n\tdn, err := newDecoratorNode(decorator, s, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkeys, err := findResultKeys(dn.results)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, k := range keys {\n\t\tif _, ok := s.decorators[k]; ok {\n\t\t\treturn newErrInvalidInput(\n\t\t\t\tfmt.Sprintf(\"cannot decorate using function %v: %s already decorated\", dn.dtype, k), nil)\n\t\t}\n\t\ts.decorators[k] = dn\n\t}\n\n\tif info := options.Info; info != nil {\n\t\tparams := dn.params.DotParam()\n\t\tresults := dn.results.DotResult()\n\t\tinfo.ID = (ID)(dn.id)\n\t\tinfo.Inputs = make([]*Input, len(params))\n\t\tinfo.Outputs = make([]*Output, len(results))\n\n\t\tfor i, param := range params {\n\t\t\tinfo.Inputs[i] = &Input{\n\t\t\t\tt:        param.Type,\n\t\t\t\toptional: param.Optional,\n\t\t\t\tname:     param.Name,\n\t\t\t\tgroup:    param.Group,\n\t\t\t}\n\t\t}\n\t\tfor i, res := range results {\n\t\t\tinfo.Outputs[i] = &Output{\n\t\t\t\tt:     res.Type,\n\t\t\t\tname:  res.Name,\n\t\t\t\tgroup: res.Group,\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc findResultKeys(r resultList) ([]key, error) {\n\t// use BFS to search for all keys included in a resultList.\n\tvar (\n\t\tq    []result\n\t\tkeys []key\n\t)\n\tq = append(q, r)\n\n\tfor len(q) > 0 {\n\t\tres := q[0]\n\t\tq = q[1:]\n\n\t\tswitch innerResult := res.(type) {\n\t\tcase resultSingle:\n\t\t\tkeys = append(keys, key{t: innerResult.Type, name: innerResult.Name})\n\t\tcase resultGrouped:\n\t\t\tif innerResult.Type.Kind() != reflect.Slice {\n\t\t\t\treturn nil, newErrInvalidInput(\"decorating a value group requires decorating the entire value group, not a single value\", nil)\n\t\t\t}\n\t\t\tkeys = append(keys, key{t: innerResult.Type.Elem(), group: innerResult.Group})\n\t\tcase resultObject:\n\t\t\tfor _, f := range innerResult.Fields {\n\t\t\t\tq = append(q, f.Result)\n\t\t\t}\n\t\tcase resultList:\n\t\t\tq = append(q, innerResult.Results...)\n\t\t}\n\t}\n\treturn keys, nil\n}\n"
        },
        {
          "name": "decorate_test.go",
          "type": "blob",
          "size": 22.9755859375,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/dig/internal/digtest\"\n)\n\ntype myInt interface {\n\tString() string\n\tIncrement()\n}\ntype someInt int\n\nvar _ myInt = (*someInt)(nil)\n\nfunc newSomeInt(i int) *someInt {\n\tv := someInt(i)\n\treturn &v\n}\n\nfunc (i *someInt) String() string {\n\treturn fmt.Sprintf(\"%d\", i)\n}\n\nfunc (i *someInt) Increment() {\n\t*i++\n}\n\nfunc TestDecorateSuccess(t *testing.T) {\n\tt.Run(\"simple decorate without names or groups\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype A struct {\n\t\t\tname string\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() *A { return &A{name: \"A\"} })\n\n\t\tc.RequireInvoke(func(a *A) {\n\t\t\tassert.Equal(t, \"A\", a.name, \"expected name to not be decorated yet.\")\n\t\t})\n\n\t\tvar info dig.DecorateInfo\n\n\t\tc.RequireDecorate(func(a *A) *A { return &A{name: a.name + \"'\"} }, dig.FillDecorateInfo(&info))\n\t\tc.RequireInvoke(func(a *A) {\n\t\t\tassert.Equal(t, \"A'\", a.name, \"expected name to equal decorated name.\")\n\t\t})\n\n\t\trequire.Equal(t, len(info.Inputs), 1)\n\t\trequire.Equal(t, len(info.Outputs), 1)\n\t\tassert.Equal(t, \"*dig_test.A\", info.Inputs[0].String())\n\t\tassert.Equal(t, \"*dig_test.A\", info.Outputs[0].String())\n\t})\n\n\tt.Run(\"simple decorate a provider from child scope\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype A struct {\n\t\t\tname string\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tchild := c.Scope(\"child\")\n\t\tchild.RequireProvide(func() *A { return &A{name: \"A\"} }, dig.Export(true))\n\n\t\tvar info dig.DecorateInfo\n\t\tchild.RequireDecorate(func(a *A) *A { return &A{name: a.name + \"'\"} }, dig.FillDecorateInfo(&info))\n\t\tc.RequireInvoke(func(a *A) {\n\t\t\tassert.Equal(t, \"A\", a.name, \"expected name to equal original name in parent scope\")\n\t\t})\n\n\t\tchild.RequireInvoke(func(a *A) {\n\t\t\tassert.Equal(t, \"A'\", a.name, \"expected name to equal decorated name in child scope\")\n\t\t})\n\n\t\trequire.Equal(t, len(info.Inputs), 1)\n\t\trequire.Equal(t, len(info.Outputs), 1)\n\t\tassert.Equal(t, \"*dig_test.A\", info.Inputs[0].String())\n\t\tassert.Equal(t, \"*dig_test.A\", info.Outputs[0].String())\n\t})\n\n\tt.Run(\"check parent-provided decorator doesn't need parent to invoke\", func(t *testing.T) {\n\t\ttype A struct {\n\t\t\tName string\n\t\t}\n\n\t\ttype B struct {\n\t\t\tdig.In\n\n\t\t\tValues []string `group:\"values\"`\n\t\t}\n\t\ttype C struct {\n\t\t\tdig.Out\n\n\t\t\tValues []string `group:\"values\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tchild := c.Scope(\"child\")\n\n\t\tc.RequireProvide(func() *A { return &A{Name: \"A\"} })\n\t\tc.RequireProvide(func() string { return \"val1\" }, dig.Group(\"values\"))\n\t\tc.RequireProvide(func() string { return \"val2\" }, dig.Group(\"values\"))\n\t\tc.RequireProvide(func() string { return \"val3\" }, dig.Group(\"values\"))\n\t\tc.RequireDecorate(func(a *A) *A { return &A{Name: a.Name + \"'\"} })\n\t\tc.RequireDecorate(func(b B) C {\n\t\t\tvar val []string\n\t\t\tfor _, v := range b.Values {\n\t\t\t\tval = append(val, v+\"'\")\n\t\t\t}\n\t\t\treturn C{\n\t\t\t\tValues: val,\n\t\t\t}\n\t\t})\n\t\tchild.RequireInvoke(func(a *A, b B) {\n\t\t\tassert.Equal(t, \"A'\", a.Name, \"expected name to equal decorated name in child scope\")\n\t\t\tassert.ElementsMatch(t, []string{\"val1'\", \"val2'\", \"val3'\"}, b.Values)\n\t\t})\n\t})\n\n\tt.Run(\"decorate grouped values provided as\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct {\n\t\t\tdig.In\n\t\t\tValues []myInt `group:\"values\"`\n\t\t}\n\n\t\ttype B struct {\n\t\t\tdig.Out\n\t\t\tValues []myInt `group:\"values\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\n\t\tfor i := range make([]int, 3) {\n\t\t\ti := i\n\t\t\tc.RequireProvide(func() *someInt { return newSomeInt(i) }, dig.Group(\"values\"), dig.As(new(myInt)))\n\t\t}\n\t\tc.Decorate(func(in A) B {\n\t\t\tfor _, v := range in.Values {\n\t\t\t\tv.Increment()\n\t\t\t}\n\t\t\treturn B{Values: in.Values}\n\t\t})\n\t\tc.RequireInvoke(func(a A) {\n\t\t\tassert.ElementsMatch(t, []myInt{newSomeInt(1), newSomeInt(2), newSomeInt(3)}, a.Values)\n\t\t})\n\t})\n\n\tt.Run(\"value groups with multiple decorations\", func(t *testing.T) {\n\t\ttype params struct {\n\t\t\tdig.In\n\n\t\t\tStrings []string `group:\"strings\"`\n\t\t}\n\n\t\ttype childResult struct {\n\t\t\tdig.Out\n\n\t\t\tStrings []string `group:\"strings\"`\n\t\t}\n\n\t\ttype A []string\n\n\t\tparent := digtest.New(t)\n\t\tparent.RequireProvide(func() string { return \"a\" }, dig.Group(\"strings\"))\n\t\tparent.RequireProvide(func() string { return \"b\" }, dig.Group(\"strings\"))\n\t\tparent.RequireProvide(func() string { return \"c\" }, dig.Group(\"strings\"))\n\n\t\tparent.RequireProvide(func(p params) A { return A(p.Strings) })\n\n\t\tchild := parent.Scope(\"child\")\n\n\t\tchild.RequireDecorate(func(p params) childResult {\n\t\t\tres := childResult{Strings: make([]string, len(p.Strings))}\n\t\t\tfor i, s := range p.Strings {\n\t\t\t\tres.Strings[i] = strings.ToUpper(s)\n\t\t\t}\n\t\t\treturn res\n\t\t})\n\t\tchild.RequireDecorate(func(p params) A {\n\t\t\treturn append(A(p.Strings), \"D\")\n\t\t})\n\n\t\trequire.NoError(t, child.Invoke(func(a A) {\n\t\t\tassert.ElementsMatch(t, A{\"A\", \"B\", \"C\", \"D\"}, a)\n\t\t}))\n\t})\n\n\tt.Run(\"decorate values in soft group\", func(t *testing.T) {\n\t\ttype params struct {\n\t\t\tdig.In\n\n\t\t\tStrings []string `group:\"strings,soft\"`\n\t\t\tInts    []int    `group:\"ints\"`\n\t\t}\n\t\ttype result struct {\n\t\t\tdig.Out\n\n\t\t\tString string `group:\"strings\"`\n\t\t\tInt    int    `group:\"ints\"`\n\t\t}\n\t\ttype childResult struct {\n\t\t\tdig.Out\n\n\t\t\tStrings []string `group:\"strings\"`\n\t\t}\n\n\t\ttype A []string\n\n\t\tparent := digtest.New(t)\n\t\tparent.RequireProvide(func() string { return \"a\" }, dig.Group(\"strings\"))\n\t\tparent.RequireProvide(func() string { return \"b\" }, dig.Group(\"strings\"))\n\t\tparent.RequireProvide(func() result { return result{String: \"c\", Int: 10} })\n\t\tparent.RequireProvide(func() result { return result{String: \"d\", Int: 11} })\n\t\tparent.RequireProvide(func() result { return result{String: \"e\", Int: 12} })\n\t\tparent.RequireProvide(func(p params) A {\n\t\t\treturn A(p.Strings)\n\t\t})\n\n\t\tchild := parent.Scope(\"child\")\n\n\t\tchild.RequireDecorate(func(p params) childResult {\n\t\t\tres := childResult{Strings: make([]string, len(p.Strings))}\n\t\t\tfor i, s := range p.Strings {\n\t\t\t\tres.Strings[i] = strings.ToUpper(s)\n\t\t\t}\n\t\t\treturn res\n\t\t})\n\n\t\tchild.RequireDecorate(func(p params) A {\n\t\t\treturn append(A(p.Strings), \"F\")\n\t\t})\n\t\trequire.NoError(t, child.Invoke(func(a A) {\n\t\t\tassert.ElementsMatch(t, A{\"C\", \"D\", \"E\", \"F\"}, a)\n\t\t}))\n\t})\n\n\tt.Run(\"simple decorate a provider to a scope and its descendants\", func(t *testing.T) {\n\t\ttype A struct {\n\t\t\tname string\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tchild := c.Scope(\"child\")\n\t\tc.RequireProvide(func() *A { return &A{name: \"A\"} })\n\n\t\tc.RequireDecorate(func(a *A) *A { return &A{name: a.name + \"'\"} })\n\t\tassertDecoratedName := func(a *A) {\n\t\t\tassert.Equal(t, a.name, \"A'\", \"expected name to equal decorated name\")\n\t\t}\n\t\tc.RequireInvoke(assertDecoratedName)\n\t\tchild.RequireInvoke(assertDecoratedName)\n\t})\n\n\tt.Run(\"modifications compose with descendants\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype A struct {\n\t\t\tname string\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tchild := c.Scope(\"child\")\n\t\tc.RequireProvide(func() *A { return &A{name: \"A\"} })\n\n\t\tc.RequireDecorate(func(a *A) *A { return &A{name: a.name + \"'\"} })\n\t\tchild.RequireDecorate(func(a *A) *A { return &A{name: a.name + \"'\"} })\n\t\tc.RequireInvoke(func(a *A) {\n\t\t\tassert.Equal(t, \"A'\", a.name, \"expected decorated name in parent\")\n\t\t})\n\n\t\tchild.RequireInvoke(func(a *A) {\n\t\t\tassert.Equal(t, \"A''\", a.name, \"expected double-decorated name in child\")\n\t\t})\n\n\t\tsibling := c.Scope(\"sibling\")\n\t\tgrandchild := child.Scope(\"grandchild\")\n\t\trequire.NoError(t, sibling.Invoke(func(a *A) {\n\t\t\tassert.Equal(t, \"A'\", a.name, \"expected single-decorated name in sibling\")\n\t\t}))\n\t\trequire.NoError(t, grandchild.Invoke(func(a *A) {\n\t\t\tassert.Equal(t, \"A''\", a.name, \"expected double-decorated name in grandchild\")\n\t\t}))\n\t})\n\n\tt.Run(\"decorate with In struct\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype A struct {\n\t\t\tName string\n\t\t}\n\t\ttype B struct {\n\t\t\tdig.In\n\n\t\t\tA *A\n\t\t\tB string `name:\"b\"`\n\t\t}\n\n\t\ttype C struct {\n\t\t\tdig.Out\n\n\t\t\tA *A\n\t\t\tB string `name:\"b\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() *A { return &A{Name: \"A\"} })\n\t\tc.RequireProvide(func() string { return \"b\" }, dig.Name(\"b\"))\n\n\t\tvar info dig.DecorateInfo\n\t\tc.RequireDecorate(func(b B) C {\n\t\t\treturn C{\n\t\t\t\tA: &A{\n\t\t\t\t\tName: b.A.Name + \"'\",\n\t\t\t\t},\n\t\t\t\tB: b.B + \"'\",\n\t\t\t}\n\t\t}, dig.FillDecorateInfo(&info))\n\n\t\tc.RequireInvoke(func(b B) {\n\t\t\tassert.Equal(t, \"A'\", b.A.Name)\n\t\t\tassert.Equal(t, \"b'\", b.B)\n\t\t})\n\n\t\trequire.Equal(t, 2, len(info.Inputs))\n\t\trequire.Equal(t, 2, len(info.Outputs))\n\t\tassert.Equal(t, \"*dig_test.A\", info.Inputs[0].String())\n\t\tassert.Equal(t, `string[name = \"b\"]`, info.Inputs[1].String())\n\t})\n\n\tt.Run(\"decorate with value groups\", func(t *testing.T) {\n\t\ttype Params struct {\n\t\t\tdig.In\n\n\t\t\tAnimals []string `group:\"animals\"`\n\t\t}\n\n\t\ttype Result struct {\n\t\t\tdig.Out\n\n\t\t\tAnimals []string `group:\"animals\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() string { return \"dog\" }, dig.Group(\"animals\"))\n\t\tc.RequireProvide(func() string { return \"cat\" }, dig.Group(\"animals\"))\n\t\tc.RequireProvide(func() string { return \"gopher\" }, dig.Group(\"animals\"))\n\n\t\tvar info dig.DecorateInfo\n\t\tc.RequireDecorate(func(p Params) Result {\n\t\t\tanimals := p.Animals\n\t\t\tfor i := 0; i < len(animals); i++ {\n\t\t\t\tanimals[i] = \"good \" + animals[i]\n\t\t\t}\n\t\t\treturn Result{\n\t\t\t\tAnimals: animals,\n\t\t\t}\n\t\t}, dig.FillDecorateInfo(&info))\n\n\t\tc.RequireInvoke(func(p Params) {\n\t\t\tassert.ElementsMatch(t, []string{\"good dog\", \"good cat\", \"good gopher\"}, p.Animals)\n\t\t})\n\n\t\trequire.Equal(t, 1, len(info.Inputs))\n\t\tassert.Equal(t, `[]string[group = \"animals\"]`, info.Inputs[0].String())\n\t})\n\n\tt.Run(\"decorate with optional parameter\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype A struct{}\n\t\ttype Param struct {\n\t\t\tdig.In\n\n\t\t\tValues []string `group:\"values\"`\n\t\t\tA      *A       `optional:\"true\"`\n\t\t}\n\n\t\ttype Result struct {\n\t\t\tdig.Out\n\n\t\t\tValues []string `group:\"values\"`\n\t\t}\n\n\t\tc.RequireProvide(func() string { return \"a\" }, dig.Group(\"values\"))\n\t\tc.RequireProvide(func() string { return \"b\" }, dig.Group(\"values\"))\n\n\t\tc.RequireDecorate(func(p Param) Result {\n\t\t\treturn Result{\n\t\t\t\tValues: append(p.Values, \"c\"),\n\t\t\t}\n\t\t})\n\n\t\tc.RequireInvoke(func(p Param) {\n\t\t\tassert.Equal(t, 3, len(p.Values))\n\t\t\tassert.ElementsMatch(t, []string{\"a\", \"b\", \"c\"}, p.Values)\n\t\t\tassert.Nil(t, p.A)\n\t\t})\n\t})\n\n\tt.Run(\"replace a type completely\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tc := digtest.New(t)\n\t\ttype A struct {\n\t\t\tFrom string\n\t\t}\n\n\t\tc.RequireProvide(func() A {\n\t\t\tassert.Fail(t, \"provider shouldn't be called\")\n\t\t\treturn A{From: \"provider\"}\n\t\t})\n\n\t\tc.RequireDecorate(func() A {\n\t\t\treturn A{From: \"decorator\"}\n\t\t})\n\n\t\tc.RequireInvoke(func(a A) {\n\t\t\tassert.Equal(t, a.From, \"decorator\", \"value should be from decorator\")\n\t\t})\n\t})\n\n\tt.Run(\"group value decorator from parent and child\", func(t *testing.T) {\n\t\ttype DecorateIn struct {\n\t\t\tdig.In\n\n\t\t\tValues []string `group:\"decoratedVals\"`\n\t\t}\n\n\t\ttype DecorateOut struct {\n\t\t\tdig.Out\n\n\t\t\tValues []string `group:\"decoratedVals\"`\n\t\t}\n\n\t\ttype InvokeIn struct {\n\t\t\tdig.In\n\n\t\t\tValues []string `group:\"decoratedVals\"`\n\t\t}\n\n\t\tparent := digtest.New(t)\n\n\t\tparent.RequireProvide(func() string { return \"dog\" }, dig.Group(\"decoratedVals\"))\n\t\tparent.RequireProvide(func() string { return \"cat\" }, dig.Group(\"decoratedVals\"))\n\n\t\tchild := parent.Scope(\"child\")\n\n\t\trequire.NoError(t, parent.Decorate(func(i DecorateIn) DecorateOut {\n\t\t\tvar result []string\n\t\t\tfor _, val := range i.Values {\n\t\t\t\tresult = append(result, \"happy \"+val)\n\t\t\t}\n\t\t\treturn DecorateOut{\n\t\t\t\tValues: result,\n\t\t\t}\n\t\t}))\n\n\t\trequire.NoError(t, child.Decorate(func(i DecorateIn) DecorateOut {\n\t\t\tvar result []string\n\t\t\tfor _, val := range i.Values {\n\t\t\t\tresult = append(result, \"good \"+val)\n\t\t\t}\n\t\t\treturn DecorateOut{\n\t\t\t\tValues: result,\n\t\t\t}\n\t\t}))\n\n\t\trequire.NoError(t, child.Invoke(func(i InvokeIn) {\n\t\t\tassert.ElementsMatch(t, []string{\"good happy dog\", \"good happy cat\"}, i.Values)\n\t\t}))\n\t})\n\n\tt.Run(\"decorate two times within same scope\", func(t *testing.T) {\n\t\ttype A struct {\n\t\t\tname string\n\t\t}\n\t\tparent := digtest.New(t)\n\t\tparent.RequireProvide(func() string { return \"parent\" })\n\t\tparent.RequireProvide(func(n string) A { return A{name: n} })\n\n\t\tchild := parent.Scope(\"child\")\n\n\t\tchild.RequireDecorate(func() string { return \"child\" })\n\t\tchild.RequireDecorate(func(n string) A { return A{name: n + \" decorated\"} })\n\n\t\trequire.NoError(t, child.Invoke(func(a A) {\n\t\t\tassert.Equal(t, \"child decorated\", a.name)\n\t\t}))\n\t})\n\n\tt.Run(\"decorate a value group with an empty slice\", func(t *testing.T) {\n\t\ttype A struct {\n\t\t\tdig.In\n\n\t\t\tValues []string `group:\"decoratedVals\"`\n\t\t}\n\n\t\ttype B struct {\n\t\t\tdig.Out\n\n\t\t\tValues []string `group:\"decoratedVals\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(func() string { return \"v1\" }, dig.Group(\"decoratedVals\"))\n\t\tc.RequireProvide(func() string { return \"v2\" }, dig.Group(\"decoratedVals\"))\n\n\t\tc.RequireInvoke(func(a A) {\n\t\t\tassert.ElementsMatch(t, []string{\"v1\", \"v2\"}, a.Values)\n\t\t})\n\n\t\tc.RequireDecorate(func(a A) B {\n\t\t\treturn B{\n\t\t\t\tValues: nil,\n\t\t\t}\n\t\t})\n\n\t\tc.RequireInvoke(func(a A) {\n\t\t\tassert.Nil(t, a.Values)\n\t\t})\n\t})\n\n\tt.Run(\"invoke with a transitive dependency on child-decorated exported type\", func(t *testing.T) {\n\t\ttype Inner struct {\n\t\t\tInt int\n\t\t}\n\n\t\ttype Next struct {\n\t\t\tMyInner *Inner\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tchild := c.Scope(\"child\")\n\n\t\tchild.RequireProvide(func() *Inner {\n\t\t\treturn &Inner{Int: 42}\n\t\t}, dig.Export(true))\n\t\tchild.RequireProvide(func(i *Inner) *Next {\n\t\t\treturn &Next{MyInner: i}\n\t\t}, dig.Export(true))\n\t\tchild.RequireDecorate(func() *Inner {\n\t\t\treturn &Inner{Int: 5678}\n\t\t})\n\t\tc.RequireInvoke(func(n *Next) {\n\t\t\tassert.Equal(t, 5678, n.MyInner.Int)\n\t\t})\n\t\tchild.RequireInvoke(func(n *Next) {\n\t\t\tassert.Equal(t, 5678, n.MyInner.Int)\n\t\t})\n\t\tc.RequireInvoke(func(i *Inner) {\n\t\t\tassert.Equal(t, 42, i.Int)\n\t\t})\n\t})\n}\n\nfunc TestDecorateFailure(t *testing.T) {\n\tt.Run(\"decorate a type that wasn't provided\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tc := digtest.New(t)\n\t\ttype A struct {\n\t\t\tName string\n\t\t}\n\n\t\tc.RequireDecorate(func(a *A) *A { return &A{Name: a.Name + \"'\"} })\n\t\terr := c.Invoke(func(a *A) string { return a.Name })\n\t\tassert.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"missing type: *dig_test.A\")\n\t})\n\n\tt.Run(\"decorate the same type twice\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tc := digtest.New(t)\n\t\ttype A struct {\n\t\t\tName string\n\t\t}\n\t\tc.RequireProvide(func() *A { return &A{Name: \"A\"} })\n\t\tc.RequireDecorate(func(a *A) *A { return &A{Name: a.Name + \"'\"} })\n\n\t\terr := c.Decorate(func(a *A) *A { return &A{Name: a.Name + \"'\"} })\n\t\trequire.Error(t, err, \"expected second call to decorate to fail.\")\n\t\tassert.Contains(t, err.Error(), \"*dig_test.A already decorated\")\n\t})\n\n\tt.Run(\"decorator returns an error\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tc := digtest.New(t)\n\n\t\ttype A struct {\n\t\t\tName string\n\t\t}\n\n\t\tc.RequireProvide(func() *A { return &A{Name: \"A\"} })\n\t\tc.RequireDecorate(func(a *A) (*A, error) { return a, errors.New(\"great sadness\") })\n\n\t\terr := c.Invoke(func(a *A) {})\n\t\trequire.Error(t, err, \"expected the decorator to error out\")\n\t\tassert.Contains(t, err.Error(), \"failed to build *dig_test.A: great sadness\")\n\t})\n\n\tt.Run(\"missing decorator dependency\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tc := digtest.New(t)\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tc.RequireProvide(func() A { return A{} })\n\t\tc.RequireDecorate(func(A, B) A {\n\t\t\tassert.Fail(t, \"this function must never be called\")\n\t\t\treturn A{}\n\t\t})\n\n\t\terr := c.Invoke(func(A) {\n\t\t\tassert.Fail(t, \"this function must never be called\")\n\t\t})\n\t\trequire.Error(t, err, \"must not invoke if a dependency is missing\")\n\t\tassert.Contains(t, err.Error(), \"missing type: dig_test.B\")\n\t})\n\n\tt.Run(\"one of the decorators dependencies returns an error\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype DecorateIn struct {\n\t\t\tdig.In\n\t\t\tValues []string `group:\"value\"`\n\t\t}\n\t\ttype DecorateOut struct {\n\t\t\tdig.Out\n\t\t\tValues []string `group:\"decoratedVal\"`\n\t\t}\n\t\ttype InvokeIn struct {\n\t\t\tdig.In\n\t\t\tValues []string `group:\"decoratedVal\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() (string, error) {\n\t\t\treturn \"value 1\", nil\n\t\t}, dig.Group(\"value\"))\n\n\t\tc.RequireProvide(func() (string, error) {\n\t\t\treturn \"value 2\", nil\n\t\t}, dig.Group(\"value\"))\n\n\t\tc.RequireProvide(func() (string, error) {\n\t\t\treturn \"value 3\", errors.New(\"sadness\")\n\t\t}, dig.Group(\"value\"))\n\n\t\tc.RequireDecorate(func(i DecorateIn) DecorateOut {\n\t\t\treturn DecorateOut{Values: i.Values}\n\t\t})\n\n\t\terr := c.Invoke(func(c InvokeIn) {})\n\t\trequire.Error(t, err, \"expected one of the group providers for a decorator to fail\")\n\t\tassert.Contains(t, err.Error(), `could not build value group`)\n\t\tassert.Contains(t, err.Error(), `string[group=\"decoratedVal\"]`)\n\t})\n\n\tt.Run(\"use dig.Out parameter for decorator\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype Param struct {\n\t\t\tdig.Out\n\n\t\t\tValue string `name:\"val\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() string { return \"hello\" }, dig.Name(\"val\"))\n\t\terr := c.Decorate(func(p Param) string { return \"fail\" })\n\t\trequire.Error(t, err, \"expected dig.Out struct used as param to fail\")\n\t\tassert.Contains(t, err.Error(), \"cannot depend on result objects\")\n\t})\n\n\tt.Run(\"use dig.In as out parameter for decorator\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype Result struct {\n\t\t\tdig.In\n\n\t\t\tValue string `name:\"val\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\terr := c.Decorate(func() Result { return Result{Value: \"hi\"} })\n\t\trequire.Error(t, err, \"expected dig.In struct used as result to fail\")\n\t\tassert.Contains(t, err.Error(), \"cannot provide parameter object\")\n\t})\n\n\tt.Run(\"missing dependency for a decorator\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype Param struct {\n\t\t\tdig.In\n\n\t\t\tValue string `name:\"val\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireDecorate(func(p Param) string { return p.Value })\n\t\terr := c.Invoke(func(s string) {})\n\t\trequire.Error(t, err, \"expected missing dep check to fail the decorator\")\n\t\tassert.Contains(t, err.Error(), `missing dependencies`)\n\t})\n\n\tt.Run(\"duplicate decoration through value groups\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttype Param struct {\n\t\t\tdig.In\n\n\t\t\tValue string `name:\"val\"`\n\t\t}\n\t\ttype A struct {\n\t\t\tName string\n\t\t}\n\t\ttype Result struct {\n\t\t\tdig.Out\n\n\t\t\tValue *A\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() string { return \"value\" }, dig.Name(\"val\"))\n\t\tc.RequireDecorate(func(p Param) *A {\n\t\t\treturn &A{\n\t\t\t\tName: p.Value,\n\t\t\t}\n\t\t})\n\n\t\terr := c.Decorate(func(p Param) Result {\n\t\t\treturn Result{\n\t\t\t\tValue: &A{\n\t\t\t\t\tName: p.Value,\n\t\t\t\t},\n\t\t\t}\n\t\t})\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"cannot decorate\")\n\t\tassert.Contains(t, err.Error(), \"function func(dig_test.Param) dig_test.Result\")\n\t\tassert.Contains(t, err.Error(), \"*dig_test.A already decorated\")\n\t})\n\n\tt.Run(\"decorate value group with a single value\", func(t *testing.T) {\n\t\ttype A struct {\n\t\t\tdig.Out\n\n\t\t\tValue int `group:\"val\"`\n\t\t}\n\n\t\troot := digtest.New(t)\n\n\t\troot.RequireProvide(func() A { return A{Value: 1} })\n\t\terr := root.Decorate(func() A { return A{Value: 11} })\n\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"decorating a value group requires decorating the entire value group\")\n\t})\n}\n\nfunc TestMultipleDecorates(t *testing.T) {\n\tt.Run(\"decorate same type from parent and child, invoke child first\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype A struct{ value int }\n\t\troot := digtest.New(t)\n\t\tchild := root.Scope(\"child\")\n\n\t\tdecorator := func(a A) A {\n\t\t\treturn A{value: a.value + 1}\n\t\t}\n\t\troot.RequireProvide(func() A { return A{value: 0} })\n\t\troot.RequireDecorate(decorator)\n\t\tchild.RequireDecorate(decorator)\n\n\t\tchild.RequireInvoke(func(a A) {\n\t\t\tassert.Equal(t, 2, a.value)\n\t\t})\n\t\troot.RequireInvoke(func(a A) {\n\t\t\tassert.Equal(t, 1, a.value)\n\t\t})\n\t})\n\n\tt.Run(\"decorate same type from parent and child, invoke parent first\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype A struct{ value int }\n\t\troot := digtest.New(t)\n\t\tchild := root.Scope(\"child\")\n\t\tdecorator := func(a A) A {\n\t\t\treturn A{value: a.value + 1}\n\t\t}\n\t\troot.RequireProvide(func() A { return A{value: 0} })\n\t\troot.RequireDecorate(decorator)\n\t\tchild.RequireDecorate(decorator)\n\n\t\troot.RequireInvoke(func(a A) {\n\t\t\tassert.Equal(t, 1, a.value)\n\t\t})\n\t\tchild.RequireInvoke(func(a A) {\n\t\t\tassert.Equal(t, 2, a.value)\n\t\t})\n\t})\n\n\tt.Run(\"decorate same value group from parent and child, invoke child\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype A struct {\n\t\t\tdig.In\n\n\t\t\tValues []int `group:\"val\"`\n\t\t}\n\t\ttype B struct {\n\t\t\tdig.Out\n\n\t\t\tValues []int `group:\"val\"`\n\t\t}\n\n\t\troot := digtest.New(t)\n\t\tchild := root.Scope(\"child\")\n\t\tdecorator := func(a A) B {\n\t\t\tvar newV []int\n\t\t\tfor _, v := range a.Values {\n\t\t\t\tnewV = append(newV, v+1)\n\t\t\t}\n\t\t\treturn B{Values: newV}\n\t\t}\n\n\t\t// provide {0, 1, 2}\n\t\troot.Provide(func() int { return 0 }, dig.Group(\"val\"))\n\t\troot.Provide(func() int { return 1 }, dig.Group(\"val\"))\n\t\troot.Provide(func() int { return 2 }, dig.Group(\"val\"))\n\n\t\t// decorate +1 to each element in parent\n\t\troot.RequireDecorate(decorator)\n\n\t\t// decorate +1 to each element in child\n\t\tchild.RequireDecorate(decorator)\n\n\t\tchild.RequireInvoke(func(a A) {\n\t\t\tassert.ElementsMatch(t, []int{2, 3, 4}, a.Values)\n\t\t})\n\n\t\troot.RequireInvoke(func(a A) {\n\t\t\tassert.ElementsMatch(t, []int{1, 2, 3}, a.Values)\n\t\t})\n\t})\n\n\tt.Run(\"decorate same value group from parent and child, invoke parent\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttype A struct {\n\t\t\tdig.In\n\n\t\t\tValues []int `group:\"val\"`\n\t\t}\n\t\ttype B struct {\n\t\t\tdig.Out\n\n\t\t\tValues []int `group:\"val\"`\n\t\t}\n\n\t\troot := digtest.New(t)\n\t\tchild := root.Scope(\"child\")\n\t\tdecorator := func(a A) B {\n\t\t\tvar newV []int\n\t\t\tfor _, v := range a.Values {\n\t\t\t\tnewV = append(newV, v+1)\n\t\t\t}\n\t\t\treturn B{Values: newV}\n\t\t}\n\n\t\t// provide {0, 1, 2}\n\t\troot.Provide(func() int { return 0 }, dig.Group(\"val\"))\n\t\troot.Provide(func() int { return 1 }, dig.Group(\"val\"))\n\t\troot.Provide(func() int { return 2 }, dig.Group(\"val\"))\n\n\t\t// decorate +1 to each element in parent\n\t\troot.RequireDecorate(decorator)\n\n\t\t// decorate +1 to each element in child\n\t\tchild.RequireDecorate(decorator)\n\n\t\troot.Invoke(func(a A) {\n\t\t\tassert.ElementsMatch(t, []int{1, 2, 3}, a.Values)\n\t\t})\n\n\t\tchild.Invoke(func(a A) {\n\t\t\tassert.ElementsMatch(t, []int{2, 3, 4}, a.Values)\n\t\t})\n\t})\n}\n\nfunc TestFillDecorateInfoString(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tassert.Equal(t, \"FillDecorateInfo(0x0)\", fmt.Sprint(dig.FillDecorateInfo(nil)))\n\t})\n\n\tt.Run(\"not nil\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\topt := dig.FillDecorateInfo(new(dig.DecorateInfo))\n\t\tassert.NotEqual(t, fmt.Sprint(opt), \"FillDecorateInfo(0x0)\")\n\t\tassert.Contains(t, fmt.Sprint(opt), \"FillDecorateInfo(0x\")\n\t})\n}\n"
        },
        {
          "name": "dig_int_test.go",
          "type": "blob",
          "size": 1.2880859375,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"math/rand\"\n\n\t\"go.uber.org/dig/internal/digclock\"\n)\n\nfunc SetRand(r *rand.Rand) Option {\n\treturn setRand(r)\n}\n\nfunc SetClock(c digclock.Clock) Option {\n\treturn setClock(c)\n}\n"
        },
        {
          "name": "dig_test.go",
          "type": "blob",
          "size": 106.833984375,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/dig/internal/digclock\"\n\t\"go.uber.org/dig/internal/digtest\"\n)\n\nfunc TestValueGroupValuesGetProperlyDecorated(t *testing.T) {\n\ttype Foo struct{}\n\ttype FooResults struct {\n\t\tdig.Out\n\n\t\tFoo Foo `group:\"foos\"`\n\t}\n\ttype Bar struct{}\n\ttype UseBarAndFooParams struct {\n\t\tdig.In\n\n\t\tFoos []Foo `group:\"foos\"`\n\t\tBar  Bar\n\t}\n\n\tvar FooCtrRun, BarCtrRun bool\n\tc := digtest.New(t)\n\tc.RequireProvide(func() string { return \"base\" })\n\n\tchild := c.Scope(\"child\")\n\tchild.RequireDecorate(func(s string) string {\n\t\treturn s + \"-decorated\"\n\t})\n\tchild.RequireProvide(func(s string) FooResults {\n\t\tFooCtrRun = true\n\t\t// Previously, this would have just been \"base\",\n\t\t// because we weren't looking in the constructor's\n\t\t// original scope for decorators to apply\n\t\t// when the value is a value group value.\n\t\tassert.Equal(t, \"base-decorated\", s)\n\t\treturn FooResults{\n\t\t\tFoo: Foo{},\n\t\t}\n\t}, dig.Export(true))\n\tchild.RequireProvide(func(s string) Bar {\n\t\tBarCtrRun = true\n\t\tassert.Equal(t, \"base-decorated\", s)\n\t\treturn Bar{}\n\t}, dig.Export(true))\n\tchild.RequireInvoke(func(UseBarAndFooParams) {})\n\n\tassert.True(t, FooCtrRun)\n\tassert.True(t, BarCtrRun)\n}\n\nfunc TestEndToEndSuccess(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"pointer constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tvar b *bytes.Buffer\n\t\tc.RequireProvide(func() *bytes.Buffer {\n\t\t\tb = &bytes.Buffer{}\n\t\t\treturn b\n\t\t})\n\n\t\tc.RequireInvoke(func(got *bytes.Buffer) {\n\t\t\trequire.NotNil(t, got, \"invoke got nil buffer\")\n\t\t\trequire.True(t, got == b, \"invoke got wrong buffer\")\n\t\t})\n\t})\n\n\tt.Run(\"nil pointer constructor\", func(t *testing.T) {\n\t\t// Dig shouldn't forbid this - it's perfectly reasonable to explicitly\n\t\t// provide a typed nil, since that's often a convenient way to supply a\n\t\t// default no-op implementation.\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() *bytes.Buffer { return nil })\n\t\tc.RequireInvoke(func(b *bytes.Buffer) {\n\t\t\trequire.Nil(t, b, \"expected to get nil buffer\")\n\t\t})\n\t})\n\n\tt.Run(\"struct constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() bytes.Buffer {\n\t\t\tvar buf bytes.Buffer\n\t\t\tbuf.WriteString(\"foo\")\n\t\t\treturn buf\n\t\t})\n\n\t\tc.RequireInvoke(func(b bytes.Buffer) {\n\t\t\t// ensure we're getting back the buffer we put in\n\t\t\trequire.Equal(t, \"foo\", b.String(), \"invoke got new buffer\")\n\t\t})\n\t})\n\n\tt.Run(\"slice constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tb1 := &bytes.Buffer{}\n\t\tb2 := &bytes.Buffer{}\n\t\tc.RequireProvide(func() []*bytes.Buffer {\n\t\t\treturn []*bytes.Buffer{b1, b2}\n\t\t})\n\n\t\tc.RequireInvoke(func(bs []*bytes.Buffer) {\n\t\t\trequire.Equal(t, 2, len(bs), \"invoke got unexpected number of buffers\")\n\t\t\trequire.True(t, b1 == bs[0], \"first item did not match\")\n\t\t\trequire.True(t, b2 == bs[1], \"second item did not match\")\n\t\t})\n\t})\n\n\tt.Run(\"array constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tbufs := [1]*bytes.Buffer{{}}\n\t\tc.RequireProvide(func() [1]*bytes.Buffer { return bufs })\n\t\tc.RequireInvoke(func(bs [1]*bytes.Buffer) {\n\t\t\trequire.NotNil(t, bs[0], \"invoke got new array\")\n\t\t})\n\t})\n\n\tt.Run(\"map constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() map[string]string {\n\t\t\treturn map[string]string{}\n\t\t})\n\n\t\tc.RequireInvoke(func(m map[string]string) {\n\t\t\trequire.NotNil(t, m, \"invoke got zero value map\")\n\t\t})\n\t})\n\n\tt.Run(\"channel constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() chan int {\n\t\t\treturn make(chan int)\n\t\t})\n\n\t\tc.RequireInvoke(func(ch chan int) {\n\t\t\trequire.NotNil(t, ch, \"invoke got nil chan\")\n\t\t})\n\t})\n\n\tt.Run(\"func constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() func(int) {\n\t\t\treturn func(int) {}\n\t\t})\n\n\t\tc.RequireInvoke(func(f func(int)) {\n\t\t\trequire.NotNil(t, f, \"invoke got nil function pointer\")\n\t\t})\n\t})\n\n\tt.Run(\"interface constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() io.Writer {\n\t\t\treturn &bytes.Buffer{}\n\t\t})\n\n\t\tc.RequireInvoke(func(w io.Writer) {\n\t\t\trequire.NotNil(t, w, \"invoke got nil interface\")\n\t\t})\n\t})\n\n\tt.Run(\"param\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype contents string\n\t\ttype Args struct {\n\t\t\tdig.In\n\n\t\t\tContents contents\n\t\t}\n\n\t\tc.RequireProvide(func(args Args) *bytes.Buffer {\n\t\t\trequire.NotEmpty(t, args.Contents, \"contents must not be empty\")\n\t\t\treturn bytes.NewBufferString(string(args.Contents))\n\t\t})\n\n\t\tc.RequireProvide(func() contents { return \"hello world\" })\n\n\t\tc.RequireInvoke(func(buff *bytes.Buffer) {\n\t\t\tout, err := io.ReadAll(buff)\n\t\t\trequire.NoError(t, err, \"read from buffer failed\")\n\t\t\trequire.Equal(t, \"hello world\", string(out), \"contents don't match\")\n\t\t})\n\t})\n\n\tt.Run(\"invoke param\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() *bytes.Buffer {\n\t\t\treturn new(bytes.Buffer)\n\t\t})\n\n\t\ttype Args struct {\n\t\t\tdig.In\n\n\t\t\t*bytes.Buffer\n\t\t}\n\n\t\tc.RequireInvoke(func(args Args) {\n\t\t\trequire.NotNil(t, args.Buffer, \"invoke got nil buffer\")\n\t\t})\n\t})\n\n\tt.Run(\"param wrapper\", func(t *testing.T) {\n\t\tvar (\n\t\t\tbuff   *bytes.Buffer\n\t\t\tcalled bool\n\t\t)\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() *bytes.Buffer {\n\t\t\trequire.False(t, called, \"constructor must be called exactly once\")\n\t\t\tcalled = true\n\t\t\tbuff = new(bytes.Buffer)\n\t\t\treturn buff\n\t\t})\n\n\t\ttype MyParam struct{ dig.In }\n\n\t\ttype Args struct {\n\t\t\tMyParam\n\n\t\t\tBuffer *bytes.Buffer\n\t\t}\n\n\t\tc.RequireInvoke(func(args Args) {\n\t\t\trequire.True(t, called, \"constructor must be called first\")\n\t\t\trequire.NotNil(t, args.Buffer, \"invoke got nil buffer\")\n\t\t\trequire.True(t, args.Buffer == buff, \"buffer must match constructor's return value\")\n\t\t})\n\t})\n\n\tt.Run(\"param recurse\", func(t *testing.T) {\n\t\ttype anotherParam struct {\n\t\t\tdig.In\n\n\t\t\tBuffer *bytes.Buffer\n\t\t}\n\n\t\ttype someParam struct {\n\t\t\tdig.In\n\n\t\t\tBuffer  *bytes.Buffer\n\t\t\tAnother anotherParam\n\t\t}\n\n\t\tvar (\n\t\t\tbuff   *bytes.Buffer\n\t\t\tcalled bool\n\t\t)\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() *bytes.Buffer {\n\t\t\trequire.False(t, called, \"constructor must be called exactly once\")\n\t\t\tcalled = true\n\t\t\tbuff = new(bytes.Buffer)\n\t\t\treturn buff\n\t\t})\n\n\t\tc.RequireInvoke(func(p someParam) {\n\t\t\trequire.True(t, called, \"constructor must be called first\")\n\n\t\t\trequire.NotNil(t, p.Buffer, \"someParam.Buffer must not be nil\")\n\t\t\trequire.NotNil(t, p.Another.Buffer, \"anotherParam.Buffer must not be nil\")\n\n\t\t\trequire.True(t, p.Buffer == p.Another.Buffer, \"buffers fields must match\")\n\t\t\trequire.True(t, p.Buffer == buff, \"buffer must match constructor's return value\")\n\t\t})\n\t})\n\n\tt.Run(\"multiple-type constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tconstructor := func() (*bytes.Buffer, []int, error) {\n\t\t\treturn &bytes.Buffer{}, []int{42}, nil\n\t\t}\n\t\tconsumer := func(b *bytes.Buffer, nums []int) {\n\t\t\tassert.NotNil(t, b, \"invoke got nil buffer\")\n\t\t\tassert.Equal(t, 1, len(nums), \"invoke got empty slice\")\n\t\t}\n\t\tc.RequireProvide(constructor)\n\t\tc.RequireInvoke(consumer)\n\t})\n\n\tt.Run(\"multiple-type constructor is called once\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\tcount := 0\n\t\tconstructor := func() (*A, *B, error) {\n\t\t\tcount++\n\t\t\treturn &A{}, &B{}, nil\n\t\t}\n\t\tgetA := func(a *A) {\n\t\t\tassert.NotNil(t, a, \"got nil A\")\n\t\t}\n\t\tgetB := func(b *B) {\n\t\t\tassert.NotNil(t, b, \"got nil B\")\n\t\t}\n\t\tc.RequireProvide(constructor)\n\t\tc.RequireInvoke(getA)\n\t\tc.RequireInvoke(getB)\n\t\tc.RequireInvoke(func(a *A, b *B) {})\n\t\trequire.Equal(t, 1, count, \"Constructor must be called once\")\n\t})\n\n\tt.Run(\"method invocation inside Invoke\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\tcA := func() (*A, error) {\n\t\t\treturn &A{}, nil\n\t\t}\n\t\tcB := func() (*B, error) {\n\t\t\treturn &B{}, nil\n\t\t}\n\t\tgetA := func(a *A) {\n\t\t\tc.Invoke(func(b *B) {\n\t\t\t\tassert.NotNil(t, b, \"got nil B\")\n\t\t\t})\n\t\t\tassert.NotNil(t, a, \"got nil A\")\n\t\t}\n\n\t\tc.RequireProvide(cA)\n\t\tc.RequireProvide(cB)\n\t\tc.RequireInvoke(getA)\n\t})\n\n\tt.Run(\"collections and instances of same type\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() []*bytes.Buffer {\n\t\t\treturn []*bytes.Buffer{{}}\n\t\t})\n\n\t\tc.RequireProvide(func() *bytes.Buffer {\n\t\t\treturn &bytes.Buffer{}\n\t\t})\n\t})\n\n\tt.Run(\"optional param field\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\t\ttype type4 struct{}\n\t\ttype type5 struct{}\n\t\tconstructor := func() (*type1, *type3, *type4) {\n\t\t\treturn &type1{}, &type3{}, &type4{}\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tT1 *type1 // regular 'ol type\n\t\t\tT2 *type2 `optional:\"true\" useless_tag:\"false\"` // optional type NOT in the graph\n\t\t\tT3 *type3 `unrelated:\"foo=42, optional\"`        // type in the graph with unrelated tag\n\t\t\tT4 *type4 `optional:\"true\"`                     // optional type present in the graph\n\t\t\tT5 *type5 `optional:\"t\"`                        // optional type NOT in the graph with \"yes\"\n\t\t}\n\t\tc.RequireProvide(constructor)\n\t\tc.RequireInvoke(func(p param) {\n\t\t\trequire.NotNil(t, p.T1, \"whole param struct should not be nil\")\n\t\t\tassert.Nil(t, p.T2, \"optional type not in the graph should return nil\")\n\t\t\tassert.NotNil(t, p.T3, \"required type with unrelated tag not in the graph\")\n\t\t\tassert.NotNil(t, p.T4, \"optional type in the graph should not return nil\")\n\t\t\tassert.Nil(t, p.T5, \"optional type not in the graph should return nil\")\n\t\t})\n\t})\n\n\tt.Run(\"ignore unexported fields\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\t\tconstructor := func() (*type1, *type2, *type3) {\n\t\t\treturn &type1{}, &type2{}, &type3{}\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\ttype param struct {\n\t\t\tdig.In `ignore-unexported:\"true\"`\n\n\t\t\tT1 *type1 // regular 'ol type\n\t\t\tT2 *type2 `optional:\"true\"` // optional type present in the graph\n\t\t\tt3 *type3\n\t\t}\n\t\tc.RequireProvide(constructor)\n\t\tc.RequireInvoke(func(p param) {\n\t\t\trequire.NotNil(t, p.T1, \"whole param struct should not be nil\")\n\t\t\tassert.NotNil(t, p.T2, \"optional type in the graph should not return nil\")\n\t\t\tassert.Nil(t, p.t3, \"unexported field should not be set\")\n\t\t})\n\t})\n\n\tt.Run(\"out type inserts multiple objects into the graph\", func(t *testing.T) {\n\t\ttype A struct{ name string }\n\t\ttype B struct{ name string }\n\t\ttype Ret struct {\n\t\t\tdig.Out\n\t\t\tA  // value type A\n\t\t\t*B // pointer type *B\n\t\t}\n\t\tmyA := A{\"string A\"}\n\t\tmyB := &B{\"string B\"}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() Ret {\n\t\t\treturn Ret{A: myA, B: myB}\n\t\t})\n\n\t\tc.RequireInvoke(func(a A, b *B) {\n\t\t\tassert.Equal(t, a.name, \"string A\", \"value type should work for dig.Out\")\n\t\t\tassert.Equal(t, b.name, \"string B\", \"pointer should work for dig.Out\")\n\t\t\tassert.True(t, myA == a, \"should get the same pointer for &A\")\n\t\t\tassert.Equal(t, b, myB, \"b and myB should be equal\")\n\t\t})\n\t})\n\n\tt.Run(\"constructor with optional\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tT1 *type1 `optional:\"true\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\n\t\tvar gave *type2\n\t\tc.RequireProvide(func(p param) *type2 {\n\t\t\trequire.Nil(t, p.T1, \"T1 must be nil\")\n\t\t\tgave = &type2{}\n\t\t\treturn gave\n\t\t})\n\n\t\tc.RequireInvoke(func(got *type2) {\n\t\t\trequire.True(t, got == gave, \"type2 reference must be the same\")\n\t\t})\n\t})\n\n\tt.Run(\"nested dependencies\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype A struct{ name string }\n\t\ttype B struct{ name string }\n\t\ttype C struct{ name string }\n\n\t\tc.RequireProvide(func() A { return A{\"->A\"} })\n\t\tc.RequireProvide(func(A) B { return B{\"A->B\"} })\n\t\tc.RequireProvide(func(A, B) C { return C{\"AB->C\"} })\n\t\tc.RequireInvoke(func(a A, b B, c C) {\n\t\t\tassert.Equal(t, a, A{\"->A\"})\n\t\t\tassert.Equal(t, b, B{\"A->B\"})\n\t\t\tassert.Equal(t, c, C{\"AB->C\"})\n\t\t})\n\t})\n\n\tt.Run(\"primitives\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() string { return \"piper\" })\n\t\tc.RequireProvide(func() int { return 42 })\n\t\tc.RequireProvide(func() int64 { return 24 })\n\t\tc.RequireProvide(func() time.Duration {\n\t\t\treturn 10 * time.Second\n\t\t})\n\n\t\tc.RequireInvoke(func(i64 int64, i int, s string, d time.Duration) {\n\t\t\tassert.Equal(t, 42, i)\n\t\t\tassert.Equal(t, int64(24), i64)\n\t\t\tassert.Equal(t, \"piper\", s)\n\t\t\tassert.Equal(t, 10*time.Second, d)\n\t\t})\n\t})\n\n\tt.Run(\"out types recurse\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\ttype C struct{}\n\t\t// Contains A\n\t\ttype Ret1 struct {\n\t\t\tdig.Out\n\t\t\t*A\n\t\t}\n\t\t// Contains *A (through Ret1), *B and C\n\t\ttype Ret2 struct {\n\t\t\tRet1\n\t\t\t*B\n\t\t\tC\n\t\t}\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(func() Ret2 {\n\t\t\treturn Ret2{\n\t\t\t\tRet1: Ret1{\n\t\t\t\t\tA: &A{},\n\t\t\t\t},\n\t\t\t\tB: &B{},\n\t\t\t\tC: C{},\n\t\t\t}\n\t\t})\n\n\t\tc.RequireInvoke(func(a *A, b *B, c C) {\n\t\t\trequire.NotNil(t, a, \"*A should be part of the container through Ret2->Ret1\")\n\t\t})\n\t})\n\n\tt.Run(\"named instances can be created with tags\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{ idx int }\n\n\t\t// returns three named instances of A\n\t\ttype ret struct {\n\t\t\tdig.Out\n\n\t\t\tA1 A `name:\"first\"`\n\t\t\tA2 A `name:\"second\"`\n\t\t\tA3 A `name:\"third\"`\n\t\t}\n\n\t\t// requires two specific named instances\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tA1 A `name:\"first\"`\n\t\t\tA3 A `name:\"third\"`\n\t\t}\n\t\tc.RequireProvide(func() ret {\n\t\t\treturn ret{A1: A{1}, A2: A{2}, A3: A{3}}\n\t\t})\n\n\t\tc.RequireInvoke(func(p param) {\n\t\t\tassert.Equal(t, 1, p.A1.idx)\n\t\t\tassert.Equal(t, 3, p.A3.idx)\n\t\t})\n\t})\n\n\tt.Run(\"named instances can be created with Name option\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype A struct{ idx int }\n\n\t\tbuildConstructor := func(idx int) func() A {\n\t\t\treturn func() A { return A{idx: idx} }\n\t\t}\n\n\t\tc.RequireProvide(buildConstructor(1), dig.Name(\"first\"))\n\t\tc.RequireProvide(buildConstructor(2), dig.Name(\"second\"))\n\t\tc.RequireProvide(buildConstructor(3), dig.Name(\"third\"))\n\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tA1 A `name:\"first\"`\n\t\t\tA3 A `name:\"third\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(p param) {\n\t\t\tassert.Equal(t, 1, p.A1.idx)\n\t\t\tassert.Equal(t, 3, p.A3.idx)\n\t\t})\n\t})\n\n\tt.Run(\"named and unnamed instances coexist\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{ idx int }\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tA `name:\"foo\"`\n\t\t}\n\n\t\tc.RequireProvide(func() out { return out{A: A{1}} })\n\t\tc.RequireProvide(func() A { return A{2} })\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tA1 A `name:\"foo\"`\n\t\t\tA2 A\n\t\t}\n\t\tc.RequireInvoke(func(i in) {\n\t\t\tassert.Equal(t, 1, i.A1.idx)\n\t\t\tassert.Equal(t, 2, i.A2.idx)\n\t\t})\n\t})\n\n\tt.Run(\"named instances recurse\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{ idx int }\n\n\t\ttype Ret1 struct {\n\t\t\tdig.Out\n\n\t\t\tA1 A `name:\"first\"`\n\t\t}\n\t\ttype Ret2 struct {\n\t\t\tRet1\n\n\t\t\tA2 A `name:\"second\"`\n\t\t}\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tA1 A `name:\"first\"`  // should come from ret1 through ret2\n\t\t\tA2 A `name:\"second\"` // should come from ret2\n\t\t}\n\t\tc.RequireProvide(func() Ret2 {\n\t\t\treturn Ret2{\n\t\t\t\tRet1: Ret1{\n\t\t\t\t\tA1: A{1},\n\t\t\t\t},\n\t\t\t\tA2: A{2},\n\t\t\t}\n\t\t})\n\n\t\tc.RequireInvoke(func(p param) {\n\t\t\tassert.Equal(t, 1, p.A1.idx)\n\t\t\tassert.Equal(t, 2, p.A2.idx)\n\t\t})\n\t})\n\n\tt.Run(\"named instances do not cause cycles\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{ idx int }\n\t\ttype param struct {\n\t\t\tdig.In\n\t\t\tA `name:\"uno\"`\n\t\t}\n\t\ttype paramBoth struct {\n\t\t\tdig.In\n\n\t\t\tA1 A `name:\"uno\"`\n\t\t\tA2 A `name:\"dos\"`\n\t\t}\n\t\ttype retUno struct {\n\t\t\tdig.Out\n\t\t\tA `name:\"uno\"`\n\t\t}\n\t\ttype retDos struct {\n\t\t\tdig.Out\n\t\t\tA `name:\"dos\"`\n\t\t}\n\n\t\tc.RequireProvide(func() retUno {\n\t\t\treturn retUno{A: A{1}}\n\t\t})\n\n\t\tc.RequireProvide(func(p param) retDos {\n\t\t\treturn retDos{A: A{2}}\n\t\t})\n\n\t\tc.RequireInvoke(func(p paramBoth) {\n\t\t\tassert.Equal(t, 1, p.A1.idx)\n\t\t\tassert.Equal(t, 2, p.A2.idx)\n\t\t})\n\t})\n\n\tt.Run(\"struct constructor with as interface option\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(\n\t\t\tfunc() *bytes.Buffer {\n\t\t\t\treturn bytes.NewBufferString(\"foo\")\n\t\t\t},\n\t\t\tdig.As(new(fmt.Stringer), new(io.Reader)),\n\t\t)\n\n\t\tc.RequireInvoke(\n\t\t\tfunc(s fmt.Stringer, r io.Reader) {\n\t\t\t\trequire.Equal(t, \"foo\", s.String(), \"invoke got new buffer\")\n\t\t\t\tgot, err := io.ReadAll(r)\n\t\t\t\tassert.NoError(t, err, \"failed to read from reader\")\n\t\t\t\trequire.Equal(t, \"foo\", string(got), \"invoke got new buffer\")\n\t\t\t})\n\n\t\trequire.Error(t, c.Invoke(func(*bytes.Buffer) {\n\t\t\tt.Fatalf(\"must not be called\")\n\t\t}), \"must not have a *bytes.Buffer in the container\")\n\t})\n\n\tt.Run(\"As with Name\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(\n\t\t\tfunc() *bytes.Buffer {\n\t\t\t\treturn bytes.NewBufferString(\"foo\")\n\t\t\t},\n\t\t\tdig.As(new(io.Reader)),\n\t\t\tdig.Name(\"buff\"))\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tBuffer *bytes.Buffer `name:\"buff\"`\n\t\t\tReader io.Reader     `name:\"buff\"`\n\t\t}\n\n\t\trequire.Error(t, c.Invoke(func(got in) {\n\t\t\tt.Fatal(\"should not be called\")\n\t\t}))\n\t})\n\n\tt.Run(\"As with Group\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\texpectedStrs := []string{\"foo\", \"bar\"}\n\t\tfor _, s := range expectedStrs {\n\t\t\ts := s\n\t\t\tc.RequireProvide(func() *bytes.Buffer {\n\t\t\t\treturn bytes.NewBufferString(s)\n\t\t\t}, dig.Group(\"readers\"), dig.As(new(io.Reader)))\n\t\t}\n\n\t\ttype in struct {\n\t\t\tdig.In\n\t\t\tReaders []io.Reader `group:\"readers\"`\n\t\t}\n\n\t\tvar actualStrs []string\n\n\t\tc.RequireInvoke(func(got in) {\n\t\t\trequire.Len(t, got.Readers, 2)\n\t\t\tfor _, r := range got.Readers {\n\t\t\t\tbuf := make([]byte, 3)\n\t\t\t\t_, err := r.Read(buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tactualStrs = append(actualStrs, string(buf))\n\t\t\t}\n\t\t})\n\n\t\tassert.ElementsMatch(t, actualStrs, expectedStrs, \"list of strings provided must match\")\n\t})\n\n\tt.Run(\"multiple As with Group\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\texpectedStrs := []string{\"foo\", \"bar\"}\n\t\tfor _, s := range expectedStrs {\n\t\t\ts := s\n\t\t\tc.RequireProvide(func() *bytes.Buffer {\n\t\t\t\treturn bytes.NewBufferString(s)\n\t\t\t}, dig.Group(\"buffs\"), dig.As(new(io.Reader), new(io.Writer)))\n\t\t}\n\n\t\ttype in struct {\n\t\t\tdig.In\n\t\t\tReaders []io.Reader `group:\"buffs\"`\n\t\t\tWriters []io.Writer `group:\"buffs\"`\n\t\t}\n\n\t\tvar actualStrs []string\n\n\t\tc.RequireInvoke(func(got in) {\n\t\t\trequire.Len(t, got.Readers, 2)\n\t\t\tfor _, r := range got.Readers {\n\t\t\t\tbuf := make([]byte, 3)\n\t\t\t\t_, err := r.Read(buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tactualStrs = append(actualStrs, string(buf))\n\t\t\t}\n\t\t\trequire.Len(t, got.Writers, 2)\n\t\t})\n\n\t\tassert.ElementsMatch(t, actualStrs, expectedStrs, \"list of strings provided must match\")\n\t})\n\n\tt.Run(\"As same interface\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() io.Reader {\n\t\t\tt.Fatal(\"this function should not be called\")\n\t\t\treturn nil\n\t\t}, dig.As(new(io.Reader)))\n\t})\n\n\tt.Run(\"As same interface with Group\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() io.Reader {\n\t\t\tt.Fatal(\"this function should not be called\")\n\t\t\treturn nil\n\t\t}, dig.As(new(io.Reader)), dig.Group(\"readers\"))\n\t})\n\n\tt.Run(\"As different interface\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() io.ReadCloser {\n\t\t\tt.Fatal(\"this function should not be called\")\n\t\t\treturn nil\n\t\t}, dig.As(new(io.Reader), new(io.Closer)))\n\t})\n\n\tt.Run(\"invoke on a type that depends on named parameters\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{ idx int }\n\t\ttype B struct{ sum int }\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tA1 *A `name:\"foo\"`\n\t\t\tA2 *A `name:\"bar\"`\n\t\t\tA3 *A `name:\"baz\" optional:\"true\"`\n\t\t}\n\t\ttype ret struct {\n\t\t\tdig.Out\n\n\t\t\tA1 *A `name:\"foo\"`\n\t\t\tA2 *A `name:\"bar\"`\n\t\t}\n\t\tc.RequireProvide(func() (ret, error) {\n\t\t\treturn ret{\n\t\t\t\tA1: &A{1},\n\t\t\t\tA2: &A{2},\n\t\t\t}, nil\n\t\t})\n\n\t\tc.RequireProvide(func(p param) *B {\n\t\t\treturn &B{sum: p.A1.idx + p.A2.idx}\n\t\t})\n\n\t\tc.RequireInvoke(func(b *B) {\n\t\t\trequire.Equal(t, 3, b.sum)\n\t\t})\n\t})\n\n\tt.Run(\"optional and named ordering doesn't matter\", func(t *testing.T) {\n\t\ttype param1 struct {\n\t\t\tdig.In\n\n\t\t\tFoo *struct{} `name:\"foo\" optional:\"true\"`\n\t\t}\n\n\t\ttype param2 struct {\n\t\t\tdig.In\n\n\t\t\tFoo *struct{} `optional:\"true\" name:\"foo\"`\n\t\t}\n\n\t\tt.Run(\"optional\", func(t *testing.T) {\n\t\t\tc := digtest.New(t)\n\n\t\t\tcalled1 := false\n\t\t\tc.RequireInvoke(func(p param1) {\n\t\t\t\tcalled1 = true\n\t\t\t\tassert.Nil(t, p.Foo)\n\t\t\t})\n\n\t\t\tcalled2 := false\n\t\t\tc.RequireInvoke(func(p param2) {\n\t\t\t\tcalled2 = true\n\t\t\t\tassert.Nil(t, p.Foo)\n\t\t\t})\n\n\t\t\tassert.True(t, called1)\n\t\t\tassert.True(t, called2)\n\t\t})\n\n\t\tt.Run(\"named\", func(t *testing.T) {\n\t\t\tc := digtest.New(t)\n\n\t\t\tc.RequireProvide(func() *struct{} {\n\t\t\t\treturn &struct{}{}\n\t\t\t}, dig.Name(\"foo\"))\n\n\t\t\tcalled1 := false\n\t\t\tc.RequireInvoke(func(p param1) {\n\t\t\t\tcalled1 = true\n\t\t\t\tassert.NotNil(t, p.Foo)\n\t\t\t})\n\n\t\t\tcalled2 := false\n\t\t\tc.RequireInvoke(func(p param2) {\n\t\t\t\tcalled2 = true\n\t\t\t\tassert.NotNil(t, p.Foo)\n\t\t\t})\n\n\t\t\tassert.True(t, called1)\n\t\t\tassert.True(t, called2)\n\t\t})\n\t})\n\n\tt.Run(\"dynamically generated dig.In\", func(t *testing.T) {\n\t\t// This test verifies that a dig.In generated using reflect.StructOf\n\t\t// works with our dig.In detection logic.\n\t\tc := digtest.New(t)\n\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\n\t\tvar gave *type1\n\t\tnew1 := func() *type1 {\n\t\t\trequire.Nil(t, gave, \"constructor must be called only once\")\n\t\t\tgave = &type1{}\n\t\t\treturn gave\n\t\t}\n\n\t\tc.RequireProvide(new1)\n\n\t\t// We generate a struct that embeds dig.In.\n\t\t//\n\t\t// Note that the fix for https://github.com/golang/go/issues/18780\n\t\t// requires that StructField.Name is always set but versions of Go\n\t\t// older than 1.9 expect Name to be empty for embedded fields.\n\t\t//\n\t\t// We use utils_for_go19_test and utils_for_pre_go19_test with build\n\t\t// tags to implement this behavior differently in the two Go versions.\n\n\t\tinType := reflect.StructOf([]reflect.StructField{\n\t\t\t{\n\t\t\t\tName:      \"In\",\n\t\t\t\tAnonymous: true,\n\t\t\t\tType:      reflect.TypeOf(dig.In{}),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Foo\",\n\t\t\t\tType: reflect.TypeOf(&type1{}),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Bar\",\n\t\t\t\tType: reflect.TypeOf(&type2{}),\n\t\t\t\tTag:  `optional:\"true\"`,\n\t\t\t},\n\t\t})\n\n\t\t// We generate a function that relies on that struct and validates the\n\t\t// result.\n\t\tfn := reflect.MakeFunc(\n\t\t\treflect.FuncOf([]reflect.Type{inType}, nil /* returns */, false /* variadic */),\n\t\t\tfunc(args []reflect.Value) []reflect.Value {\n\t\t\t\trequire.Len(t, args, 1, \"expected only one argument\")\n\t\t\t\trequire.Equal(t, reflect.Struct, args[0].Kind(), \"argument must be a struct\")\n\t\t\t\trequire.Equal(t, 3, args[0].NumField(), \"struct must have two fields\")\n\n\t\t\t\tt1, ok := args[0].Field(1).Interface().(*type1)\n\t\t\t\trequire.True(t, ok, \"field must be a type1\")\n\t\t\t\trequire.NotNil(t, t1, \"value must not be nil\")\n\t\t\t\trequire.True(t, t1 == gave, \"value must match constructor's return value\")\n\n\t\t\t\trequire.True(t, args[0].Field(2).IsNil(), \"type2 must be nil\")\n\t\t\t\treturn nil\n\t\t\t},\n\t\t)\n\n\t\tc.RequireInvoke(fn.Interface())\n\t})\n\n\tt.Run(\"dynamically generated dig.Out\", func(t *testing.T) {\n\t\t// This test verifies that a dig.Out generated using reflect.StructOf\n\t\t// works with our dig.Out detection logic.\n\n\t\tc := digtest.New(t)\n\n\t\ttype A struct{ Value int }\n\n\t\toutType := reflect.StructOf([]reflect.StructField{\n\t\t\t{\n\t\t\t\tName:      \"Out\",\n\t\t\t\tAnonymous: true,\n\t\t\t\tType:      reflect.TypeOf(dig.Out{}),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Foo\",\n\t\t\t\tType: reflect.TypeOf(&A{}),\n\t\t\t\tTag:  `name:\"foo\"`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Bar\",\n\t\t\t\tType: reflect.TypeOf(&A{}),\n\t\t\t\tTag:  `name:\"bar\"`,\n\t\t\t},\n\t\t})\n\n\t\tfn := reflect.MakeFunc(\n\t\t\treflect.FuncOf(nil /* params */, []reflect.Type{outType}, false /* variadic */),\n\t\t\tfunc([]reflect.Value) []reflect.Value {\n\t\t\t\tresult := reflect.New(outType).Elem()\n\t\t\t\tresult.Field(1).Set(reflect.ValueOf(&A{Value: 1}))\n\t\t\t\tresult.Field(2).Set(reflect.ValueOf(&A{Value: 2}))\n\t\t\t\treturn []reflect.Value{result}\n\t\t\t},\n\t\t)\n\t\tc.RequireProvide(fn.Interface())\n\n\t\ttype params struct {\n\t\t\tdig.In\n\n\t\t\tFoo *A `name:\"foo\"`\n\t\t\tBar *A `name:\"bar\"`\n\t\t\tBaz *A `name:\"baz\" optional:\"true\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(p params) {\n\t\t\tassert.Equal(t, &A{Value: 1}, p.Foo, \"Foo must match\")\n\t\t\tassert.Equal(t, &A{Value: 2}, p.Bar, \"Bar must match\")\n\t\t\tassert.Nil(t, p.Baz, \"Baz must be unset\")\n\t\t})\n\t})\n\n\tt.Run(\"variadic arguments invoke\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype A struct{}\n\n\t\tvar gaveA *A\n\t\tc.RequireProvide(func() *A {\n\t\t\tgaveA = &A{}\n\t\t\treturn gaveA\n\t\t})\n\n\t\tc.RequireProvide(func() []*A {\n\t\t\tt.Fatal(\"[]*A constructor must not be called.\")\n\t\t\treturn nil\n\t\t})\n\n\t\tc.RequireInvoke(func(a *A, as ...*A) {\n\t\t\trequire.NotNil(t, a, \"A must not be nil\")\n\t\t\trequire.True(t, a == gaveA, \"A must match\")\n\t\t\trequire.Empty(t, as, \"varargs must be empty\")\n\t\t})\n\t})\n\n\tt.Run(\"variadic arguments dependency\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tvar gaveA *A\n\t\tc.RequireProvide(func() *A {\n\t\t\tgaveA = &A{}\n\t\t\treturn gaveA\n\t\t})\n\n\t\tc.RequireProvide(func() []*A {\n\t\t\tt.Fatal(\"[]*A constructor must not be called.\")\n\t\t\treturn nil\n\t\t})\n\n\t\tvar gaveB *B\n\t\tc.RequireProvide(func(a *A, as ...*A) *B {\n\t\t\trequire.NotNil(t, a, \"A must not be nil\")\n\t\t\trequire.True(t, a == gaveA, \"A must match\")\n\t\t\trequire.Empty(t, as, \"varargs must be empty\")\n\t\t\tgaveB = &B{}\n\t\t\treturn gaveB\n\t\t})\n\n\t\tc.RequireInvoke(func(b *B) {\n\t\t\trequire.NotNil(t, b, \"B must not be nil\")\n\t\t\trequire.True(t, b == gaveB, \"B must match\")\n\t\t})\n\t})\n\n\tt.Run(\"non-error return arguments from invoke are ignored\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tc.RequireProvide(func() A { return A{} })\n\t\tc.RequireInvoke(func(A) B { return B{} })\n\n\t\terr := c.Invoke(func(B) {})\n\t\trequire.Error(t, err, \"invoking with B param should error out\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".TestEndToEndSuccess.func\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"missing type:\",\n\t\t\t\"dig_test.B\",\n\t\t)\n\t})\n}\n\nfunc TestGroups(t *testing.T) {\n\tt.Run(\"empty slice received without provides\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tValues []int `group:\"foo\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(i in) {\n\t\t\trequire.Empty(t, i.Values)\n\t\t})\n\t})\n\n\tt.Run(\"values are provided\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tValue int `group:\"val\"`\n\t\t}\n\n\t\tprovide := func(i int) {\n\t\t\tc.RequireProvide(func() out {\n\t\t\t\treturn out{Value: i}\n\t\t\t})\n\t\t}\n\n\t\tprovide(1)\n\t\tprovide(2)\n\t\tprovide(3)\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tValues []int `group:\"val\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(i in) {\n\t\t\tassert.Equal(t, []int{2, 3, 1}, i.Values)\n\t\t})\n\t})\n\n\tt.Run(\"groups are provided via option\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\tprovide := func(i int) {\n\t\t\tc.RequireProvide(func() int {\n\t\t\t\treturn i\n\t\t\t}, dig.Group(\"val\"))\n\t\t}\n\n\t\tprovide(1)\n\t\tprovide(2)\n\t\tprovide(3)\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tValues []int `group:\"val\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(i in) {\n\t\t\tassert.Equal(t, []int{2, 3, 1}, i.Values)\n\t\t})\n\t})\n\n\tt.Run(\"different types may be grouped\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\tprovide := func(i int, s string) {\n\t\t\tc.RequireProvide(func() (int, string) {\n\t\t\t\treturn i, s\n\t\t\t}, dig.Group(\"val\"))\n\t\t}\n\n\t\tprovide(1, \"a\")\n\t\tprovide(2, \"b\")\n\t\tprovide(3, \"c\")\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tIvalues []int    `group:\"val\"`\n\t\t\tSvalues []string `group:\"val\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(i in) {\n\t\t\tassert.Equal(t, []int{2, 3, 1}, i.Ivalues)\n\t\t\tassert.Equal(t, []string{\"a\", \"c\", \"b\"}, i.Svalues)\n\t\t})\n\t})\n\n\tt.Run(\"group options may not be provided for result structs\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tValue int `group:\"val\"`\n\t\t}\n\n\t\tfunc(i int) {\n\t\t\trequire.Error(t, c.Provide(func() out {\n\t\t\t\tt.Fatal(\"This should not be called\")\n\t\t\t\treturn out{}\n\t\t\t}, dig.Group(\"val\")), \"This Provide should fail\")\n\t\t}(1)\n\t})\n\n\tt.Run(\"constructor is called at most once\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tResult string `group:\"s\"`\n\t\t}\n\n\t\tcalls := make(map[string]int)\n\n\t\tprovide := func(i string) {\n\t\t\tc.RequireProvide(func() out {\n\t\t\t\tcalls[i]++\n\t\t\t\treturn out{Result: i}\n\t\t\t})\n\t\t}\n\n\t\tprovide(\"foo\")\n\t\tprovide(\"bar\")\n\t\tprovide(\"baz\")\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tResults []string `group:\"s\"`\n\t\t}\n\n\t\t// Expected value of in.Results in consecutive calls.\n\t\texpected := [][]string{\n\t\t\t{\"bar\", \"baz\", \"foo\"},\n\t\t\t{\"foo\", \"baz\", \"bar\"},\n\t\t\t{\"baz\", \"bar\", \"foo\"},\n\t\t\t{\"bar\", \"foo\", \"baz\"},\n\t\t}\n\n\t\tfor _, want := range expected {\n\t\t\tc.RequireInvoke(func(i in) {\n\t\t\t\trequire.Equal(t, want, i.Results)\n\t\t\t})\n\t\t}\n\n\t\tfor s, v := range calls {\n\t\t\tassert.Equal(t, 1, v, \"constructor for %q called too many times\", s)\n\t\t}\n\t})\n\n\tt.Run(\"consume groups in constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tResult []string `group:\"hi\"`\n\t\t}\n\n\t\tprovideStrings := func(strings ...string) {\n\t\t\tc.RequireProvide(func() out {\n\t\t\t\treturn out{Result: strings}\n\t\t\t})\n\t\t}\n\n\t\tprovideStrings(\"1\", \"2\")\n\t\tprovideStrings(\"3\", \"4\", \"5\")\n\t\tprovideStrings(\"6\")\n\t\tprovideStrings(\"7\", \"8\", \"9\", \"10\")\n\n\t\ttype setParams struct {\n\t\t\tdig.In\n\n\t\t\tStrings [][]string `group:\"hi\"`\n\t\t}\n\t\tc.RequireProvide(func(p setParams) map[string]struct{} {\n\t\t\tm := make(map[string]struct{})\n\t\t\tfor _, ss := range p.Strings {\n\t\t\t\tfor _, s := range ss {\n\t\t\t\t\tm[s] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m\n\t\t})\n\n\t\tc.RequireInvoke(func(got map[string]struct{}) {\n\t\t\tassert.Equal(t, map[string]struct{}{\n\t\t\t\t\"1\": {}, \"2\": {}, \"3\": {}, \"4\": {}, \"5\": {},\n\t\t\t\t\"6\": {}, \"7\": {}, \"8\": {}, \"9\": {}, \"10\": {},\n\t\t\t}, got)\n\t\t})\n\t})\n\n\tt.Run(\"provide multiple values\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\ttype outInt struct {\n\t\t\tdig.Out\n\t\t\tInt int `group:\"foo\"`\n\t\t}\n\n\t\tprovideInt := func(i int) {\n\t\t\tc.RequireProvide(func() (outInt, error) {\n\t\t\t\treturn outInt{Int: i}, nil\n\t\t\t})\n\t\t}\n\n\t\ttype outString struct {\n\t\t\tdig.Out\n\t\t\tString string `group:\"foo\"`\n\t\t}\n\n\t\tprovideString := func(s string) {\n\t\t\tc.RequireProvide(func() outString {\n\t\t\t\treturn outString{String: s}\n\t\t\t})\n\t\t}\n\n\t\ttype outBoth struct {\n\t\t\tdig.Out\n\n\t\t\tInt    int    `group:\"foo\"`\n\t\t\tString string `group:\"foo\"`\n\t\t}\n\n\t\tprovideBoth := func(i int, s string) {\n\t\t\tc.RequireProvide(func() (outBoth, error) {\n\t\t\t\treturn outBoth{Int: i, String: s}, nil\n\t\t\t})\n\t\t}\n\n\t\tprovideInt(1)\n\t\tprovideString(\"foo\")\n\t\tprovideBoth(2, \"bar\")\n\t\tprovideString(\"baz\")\n\t\tprovideInt(3)\n\t\tprovideBoth(4, \"qux\")\n\t\tprovideBoth(5, \"quux\")\n\t\tprovideInt(6)\n\t\tprovideInt(7)\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tInts    []int    `group:\"foo\"`\n\t\t\tStrings []string `group:\"foo\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(got in) {\n\t\t\tassert.Equal(t, in{\n\t\t\t\tInts:    []int{5, 3, 4, 1, 6, 7, 2},\n\t\t\t\tStrings: []string{\"foo\", \"bar\", \"baz\", \"quux\", \"qux\"},\n\t\t\t}, got)\n\t\t})\n\t})\n\n\tt.Run(\"duplicate values are supported\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tResult string `group:\"s\"`\n\t\t}\n\n\t\tprovide := func(i string) {\n\t\t\tc.RequireProvide(func() out {\n\t\t\t\treturn out{Result: i}\n\t\t\t})\n\t\t}\n\n\t\tprovide(\"a\")\n\t\tprovide(\"b\")\n\t\tprovide(\"c\")\n\t\tprovide(\"a\")\n\t\tprovide(\"d\")\n\t\tprovide(\"d\")\n\t\tprovide(\"a\")\n\t\tprovide(\"e\")\n\n\t\ttype stringSlice []string\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tStrings stringSlice `group:\"s\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(i in) {\n\t\t\tassert.Equal(t,\n\t\t\t\tstringSlice{\"d\", \"c\", \"a\", \"a\", \"d\", \"e\", \"b\", \"a\"},\n\t\t\t\ti.Strings)\n\t\t})\n\t})\n\n\tt.Run(\"failure to build a grouped value fails everything\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tResult string `group:\"x\"`\n\t\t}\n\n\t\tc.RequireProvide(func() (out, error) {\n\t\t\treturn out{Result: \"foo\"}, nil\n\t\t})\n\n\t\tvar gaveErr error\n\t\tc.RequireProvide(func() (out, error) {\n\t\t\tgaveErr = errors.New(\"great sadness\")\n\t\t\treturn out{}, gaveErr\n\t\t})\n\n\t\tc.RequireProvide(func() out {\n\t\t\treturn out{Result: \"bar\"}\n\t\t})\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tStrings []string `group:\"x\"`\n\t\t}\n\n\t\terr := c.Invoke(func(i in) {\n\t\t\trequire.FailNow(t, \"this function must not be called\")\n\t\t})\n\t\trequire.Error(t, err, \"expected failure\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".TestGroups`,\n\t\t\t`could not build value group string\\[group=\"x\"\\]:`,\n\t\t\t`received non-nil error from function \"go.uber.org/dig_test\".TestGroups\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"great sadness\",\n\t\t)\n\t\tassert.Equal(t, gaveErr, dig.RootCause(err))\n\t})\n\n\tt.Run(\"flatten collects slices\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tValue []int `group:\"val,flatten\"`\n\t\t}\n\n\t\tprovide := func(i []int) {\n\t\t\tc.RequireProvide(func() out {\n\t\t\t\treturn out{Value: i}\n\t\t\t})\n\t\t}\n\n\t\tprovide([]int{1, 2})\n\t\tprovide([]int{3, 4})\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tValues []int `group:\"val\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(i in) {\n\t\t\tassert.Equal(t, []int{2, 3, 4, 1}, i.Values)\n\t\t})\n\t})\n\n\tt.Run(\"flatten via option\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\t\tc.RequireProvide(func() []int {\n\t\t\treturn []int{1, 2, 3}\n\t\t}, dig.Group(\"val,flatten\"))\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tValues []int `group:\"val\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(i in) {\n\t\t\tassert.Equal(t, []int{2, 3, 1}, i.Values)\n\t\t})\n\t})\n\n\tt.Run(\"flatten via option error if not a slice\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\t\terr := c.Provide(func() int { return 1 }, dig.Group(\"val,flatten\"))\n\t\trequire.Error(t, err, \"failed to provide\")\n\t\tassert.Contains(t, err.Error(), \"flatten can be applied to slices only\")\n\t})\n\n\tt.Run(\"a soft value group provider is not called when only that value group is consumed\", func(t *testing.T) {\n\t\ttype Param struct {\n\t\t\tdig.In\n\n\t\t\tValues []string `group:\"foo,soft\"`\n\t\t}\n\t\ttype Result struct {\n\t\t\tdig.Out\n\n\t\t\tValue string `group:\"foo\"`\n\t\t}\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(func() (Result, int) {\n\t\t\trequire.FailNow(t, \"this function should not be called\")\n\t\t\treturn Result{Value: \"sad times\"}, 20\n\t\t})\n\n\t\tc.RequireInvoke(func(p Param) {\n\t\t\tassert.ElementsMatch(t, []string{}, p.Values)\n\t\t})\n\t})\n\n\tt.Run(\"soft value group is provided\", func(t *testing.T) {\n\t\ttype Param1 struct {\n\t\t\tdig.In\n\n\t\t\tValues []string `group:\"foo,soft\"`\n\t\t}\n\t\ttype Result struct {\n\t\t\tdig.Out\n\n\t\t\tValue1 string `group:\"foo\"`\n\t\t\tValue2 int\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() Result { return Result{Value1: \"a\", Value2: 2} })\n\t\tc.RequireProvide(func() string { return \"b\" }, dig.Group(\"foo\"))\n\n\t\t// The only value that must be in the group is the one that's provided\n\t\t// because it would be provided anyways by another dependency, in\n\t\t// this case we need an int, so the first constructor is called, and\n\t\t// this provides a string, which is the one in the group\n\t\tc.RequireInvoke(func(p2 int, p1 Param1) {\n\t\t\tassert.ElementsMatch(t, []string{\"a\"}, p1.Values)\n\t\t})\n\t})\n\n\tt.Run(\"two soft group values provided by one constructor\", func(t *testing.T) {\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tValue1 []string `group:\"foo,soft\"`\n\t\t\tValue2 []int    `group:\"bar,soft\"`\n\t\t\tValue3 float32\n\t\t}\n\n\t\ttype result struct {\n\t\t\tdig.Out\n\n\t\t\tResult1 []string `group:\"foo,flatten\"`\n\t\t\tResult2 int      `group:\"bar\"`\n\t\t}\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(func() result {\n\t\t\treturn result{\n\t\t\t\tResult1: []string{\"a\", \"b\", \"c\"},\n\t\t\t\tResult2: 4,\n\t\t\t}\n\t\t})\n\t\tc.RequireProvide(func() float32 { return 3.1416 })\n\n\t\tc.RequireInvoke(func(p param) {\n\t\t\tassert.ElementsMatch(t, []string{}, p.Value1)\n\t\t\tassert.ElementsMatch(t, []int{}, p.Value2)\n\t\t\tassert.Equal(t, float32(3.1416), p.Value3)\n\t\t})\n\t})\n\tt.Run(\"soft in a result value group\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\terr := c.Provide(func() int { return 10 }, dig.Group(\"foo,soft\"))\n\t\trequire.Error(t, err, \"failed to privide\")\n\t\tassert.Contains(t, err.Error(), \"cannot use soft with result value groups\")\n\t})\n\tt.Run(\"value group provided after a hard dependency is provided\", func(t *testing.T) {\n\t\ttype Param struct {\n\t\t\tdig.In\n\n\t\t\tValue []string `group:\"foo,soft\"`\n\t\t}\n\n\t\ttype Result struct {\n\t\t\tdig.Out\n\n\t\t\tValue1 string `group:\"foo\"`\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.Provide(func() (Result, int) { return Result{Value1: \"a\"}, 2 })\n\n\t\tc.RequireInvoke(func(param Param) {\n\t\t\tassert.ElementsMatch(t, []string{}, param.Value)\n\t\t})\n\t\tc.RequireInvoke(func(int) {})\n\t\tc.RequireInvoke(func(param Param) {\n\t\t\tassert.ElementsMatch(t, []string{\"a\"}, param.Value)\n\t\t})\n\t})\n}\n\n// --- END OF END TO END TESTS\n\nfunc TestRecoverFromPanic(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tsetup   func(*digtest.Container)\n\t\tinvoke  interface{}\n\t\twantErr []string\n\t}{\n\t\t{\n\t\t\tname: \"panic in provided function\",\n\t\t\tsetup: func(c *digtest.Container) {\n\t\t\t\tc.RequireProvide(func() int {\n\t\t\t\t\tpanic(\"terrible sadness\")\n\t\t\t\t})\n\t\t\t},\n\t\t\tinvoke: func(i int) {},\n\t\t\twantErr: []string{\n\t\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".TestRecoverFromPanic.\\S+`,\n\t\t\t\t`failed to build int:`,\n\t\t\t\t`panic: \"terrible sadness\" in func: \"go.uber.org/dig_test\".TestRecoverFromPanic.\\S+`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"panic in decorator\",\n\t\t\tsetup: func(c *digtest.Container) {\n\t\t\t\tc.RequireProvide(func() string { return \"\" })\n\t\t\t\tc.RequireDecorate(func(s string) string {\n\t\t\t\t\tpanic(\"great sadness\")\n\t\t\t\t})\n\t\t\t},\n\t\t\tinvoke: func(s string) {},\n\t\t\twantErr: []string{\n\t\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".TestRecoverFromPanic.\\S+`,\n\t\t\t\t`failed to build string:`,\n\t\t\t\t`panic: \"great sadness\" in func: \"go.uber.org/dig_test\".TestRecoverFromPanic.\\S+`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"panic in invoke\",\n\t\t\tsetup:  func(c *digtest.Container) {},\n\t\t\tinvoke: func() { panic(\"terrible woe\") },\n\t\t\twantErr: []string{\n\t\t\t\t`panic: \"terrible woe\" in func: \"go.uber.org/dig_test\".TestRecoverFromPanic.\\S+`,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Run(\"without option\", func(t *testing.T) {\n\t\t\t\tc := digtest.New(t)\n\t\t\t\ttt.setup(c)\n\t\t\t\tassert.Panics(t, func() { c.Container.Invoke(tt.invoke) },\n\t\t\t\t\t\"expected panic without dig.RecoverFromPanics() option\",\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"with option\", func(t *testing.T) {\n\t\t\t\tc := digtest.New(t, dig.RecoverFromPanics())\n\t\t\t\ttt.setup(c)\n\t\t\t\terr := c.Container.Invoke(tt.invoke)\n\t\t\t\trequire.Error(t, err)\n\t\t\t\tdig.AssertErrorMatches(t, err, tt.wantErr[0], tt.wantErr[1:]...)\n\t\t\t\tvar pe dig.PanicError\n\t\t\t\tassert.True(t, errors.As(err, &pe), \"expected error chain to contain a PanicError\")\n\t\t\t\t_, ok := dig.RootCause(err).(dig.PanicError) //nolint:errorlint // want dig.PanicError\n\t\t\t\tassert.True(t, ok, \"expected root cause to be a PanicError\")\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc giveInt() int { return 5 }\n\nfunc TestCallback(t *testing.T) {\n\tt.Run(\"no errors\", func(t *testing.T) {\n\t\tvar (\n\t\t\tprovideCallbackCalled  bool\n\t\t\tdecorateCallbackCalled bool\n\t\t)\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(\n\t\t\tgiveInt,\n\t\t\tdig.WithProviderCallback(func(ci dig.CallbackInfo) {\n\t\t\t\tassert.Equal(t, \"go.uber.org/dig_test.giveInt\", ci.Name)\n\t\t\t\tassert.NoError(t, ci.Error)\n\t\t\t\tprovideCallbackCalled = true\n\t\t\t}),\n\t\t)\n\t\tc.RequireDecorate(\n\t\t\tfunc(a int) int { return a + 5 },\n\t\t\tdig.WithDecoratorCallback(func(ci dig.CallbackInfo) {\n\t\t\t\tassert.Equal(t, \"go.uber.org/dig_test.TestCallback.func1.2\", ci.Name)\n\t\t\t\tassert.NoError(t, ci.Error)\n\t\t\t\tdecorateCallbackCalled = true\n\t\t\t}),\n\t\t)\n\n\t\tc.RequireInvoke(func(a int) {})\n\n\t\tassert.True(t, provideCallbackCalled)\n\t\tassert.True(t, decorateCallbackCalled)\n\t})\n\n\tt.Run(\"provide error\", func(t *testing.T) {\n\t\tvar called bool\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(\n\t\t\tfunc() (int, error) {\n\t\t\t\treturn 0, errors.New(\"terrible callback sadness\")\n\t\t\t},\n\t\t\tdig.WithProviderCallback(func(ci dig.CallbackInfo) {\n\t\t\t\tassert.Equal(t, \"go.uber.org/dig_test.TestCallback.func2.1\", ci.Name)\n\t\t\t\tassert.ErrorContains(t, ci.Error, \"terrible callback sadness\")\n\t\t\t\tcalled = true\n\t\t\t}),\n\t\t)\n\n\t\tc.Invoke(func(a int) {})\n\t\tassert.True(t, called)\n\t})\n\n\tt.Run(\"decorate error\", func(t *testing.T) {\n\t\tvar called bool\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(giveInt)\n\t\tc.RequireDecorate(\n\t\t\tfunc(a int) (int, error) {\n\t\t\t\treturn 0, errors.New(\"terrible callback sadness\")\n\t\t\t},\n\t\t\tdig.WithDecoratorCallback(func(ci dig.CallbackInfo) {\n\t\t\t\tassert.Equal(t, \"go.uber.org/dig_test.TestCallback.func3.1\", ci.Name)\n\t\t\t\tassert.ErrorContains(t, ci.Error, \"terrible callback sadness\")\n\t\t\t\tcalled = true\n\t\t\t}),\n\t\t)\n\n\t\tc.Invoke(func(a int) {})\n\t\tassert.True(t, called)\n\t})\n\n\tt.Run(\"panicky provide with RecoverFromPanics\", func(t *testing.T) {\n\t\tvar called bool\n\n\t\tc := digtest.New(t, dig.RecoverFromPanics())\n\t\tc.RequireProvide(\n\t\t\tfunc() int { panic(\"unreal misfortune\") },\n\t\t\tdig.WithProviderCallback(func(ci dig.CallbackInfo) {\n\t\t\t\tassert.Equal(t, \"go.uber.org/dig_test.TestCallback.func4.1\", ci.Name)\n\t\t\t\tvar pe dig.PanicError\n\t\t\t\tassert.True(t, errors.As(ci.Error, &pe))\n\t\t\t\tassert.ErrorContains(t, ci.Error, \"panic: \\\"unreal misfortune\\\"\")\n\t\t\t\tcalled = true\n\t\t\t}),\n\t\t)\n\n\t\tc.Invoke(func(int) {})\n\t\tassert.True(t, called)\n\t})\n\n\tt.Run(\"panicky decorate with RecoverFromPanics\", func(t *testing.T) {\n\t\tvar called bool\n\n\t\tc := digtest.New(t, dig.RecoverFromPanics())\n\t\tc.RequireProvide(giveInt)\n\t\tc.RequireDecorate(\n\t\t\tfunc(int) int { panic(\"unreal misfortune\") },\n\t\t\tdig.WithDecoratorCallback(func(ci dig.CallbackInfo) {\n\t\t\t\tassert.Equal(t, \"go.uber.org/dig_test.TestCallback.func5.1\", ci.Name)\n\t\t\t\tvar pe dig.PanicError\n\t\t\t\tassert.True(t, errors.As(ci.Error, &pe))\n\t\t\t\tassert.ErrorContains(t, ci.Error, \"panic: \\\"unreal misfortune\\\"\")\n\n\t\t\t\tcalled = true\n\t\t\t}),\n\t\t)\n\n\t\tc.Invoke(func(int) {})\n\t\tassert.True(t, called)\n\t})\n}\n\nfunc TestCallbackRuntime(t *testing.T) {\n\tt.Run(\"constructor runtime\", func(t *testing.T) {\n\t\tvar called bool\n\n\t\tmockClock := digclock.NewMock()\n\t\tc := digtest.New(t, dig.SetClock(mockClock))\n\t\tc.RequireProvide(\n\t\t\tfunc() int {\n\t\t\t\tmockClock.Add(1 * time.Millisecond)\n\t\t\t\treturn 5\n\t\t\t},\n\t\t\tdig.WithProviderCallback(func(ci dig.CallbackInfo) {\n\t\t\t\tassert.Equal(t, \"go.uber.org/dig_test.TestCallbackRuntime.func1.1\", ci.Name)\n\t\t\t\tassert.NoError(t, ci.Error)\n\t\t\t\tassert.Equal(t, ci.Runtime, 1*time.Millisecond)\n\n\t\t\t\tcalled = true\n\t\t\t}),\n\t\t)\n\n\t\tc.Invoke(func(int) {})\n\t\tassert.True(t, called)\n\t})\n\n\tt.Run(\"decorator runtime\", func(t *testing.T) {\n\t\tvar called bool\n\n\t\tmockClock := digclock.NewMock()\n\t\tc := digtest.New(t, dig.SetClock(mockClock))\n\t\tc.RequireProvide(giveInt)\n\t\tc.RequireDecorate(\n\t\t\tfunc(int) int {\n\t\t\t\tmockClock.Add(1 * time.Millisecond)\n\t\t\t\treturn 10\n\t\t\t},\n\t\t\tdig.WithDecoratorCallback(func(ci dig.CallbackInfo) {\n\t\t\t\tassert.Equal(t, \"go.uber.org/dig_test.TestCallbackRuntime.func2.1\", ci.Name)\n\t\t\t\tassert.NoError(t, ci.Error)\n\t\t\t\tassert.Equal(t, ci.Runtime, 1*time.Millisecond)\n\n\t\t\t\tcalled = true\n\t\t\t}),\n\t\t)\n\n\t\tc.Invoke(func(int) {})\n\t\tassert.True(t, called)\n\t})\n}\n\nfunc TestProvideConstructorErrors(t *testing.T) {\n\tt.Run(\"multiple-type constructor returns multiple objects of same type\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{}\n\t\tconstructor := func() (*A, *A, error) {\n\t\t\treturn &A{}, &A{}, nil\n\t\t}\n\t\trequire.Error(t, c.Provide(constructor), \"provide failed\")\n\t})\n\n\tt.Run(\"constructor consumes a dig.Out\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tReader io.Reader\n\t\t}\n\n\t\ttype outPtr struct {\n\t\t\t*dig.Out\n\n\t\t\tReader io.Reader\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tdesc        string\n\t\t\tconstructor interface{}\n\t\t\tmsg         string\n\t\t}{\n\t\t\t{\n\t\t\t\tdesc:        \"dig.Out\",\n\t\t\t\tconstructor: func(out) io.Writer { return nil },\n\t\t\t\tmsg:         `dig_test.out embeds a dig.Out`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc:        \"*dig.Out\",\n\t\t\t\tconstructor: func(*out) io.Writer { return nil },\n\t\t\t\tmsg:         `\\*dig_test.out embeds a dig.Out`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tdesc:        \"embeds *dig.Out\",\n\t\t\t\tconstructor: func(outPtr) io.Writer { return nil },\n\t\t\t\tmsg:         `dig_test.outPtr embeds a dig.Out`,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\t\terr := c.Provide(tt.constructor)\n\t\t\t\trequire.Error(t, err, \"provide should fail\")\n\t\t\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\t\t`cannot provide function \"go.uber.org/dig_test\".TestProvideConstructorErrors\\S+`,\n\t\t\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\t\t`bad argument 1:`,\n\t\t\t\t\t`cannot depend on result objects: `+tt.msg)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"name option cannot be provided for result structs\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{}\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tA A\n\t\t}\n\n\t\terr := c.Provide(func() out {\n\t\t\tpanic(\"this function must never be called\")\n\t\t}, dig.Name(\"second\"))\n\t\trequire.Error(t, err)\n\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".TestProvideConstructorErrors\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`bad result 1:`,\n\t\t\t\"cannot specify a name for result objects: dig_test.out embeds dig.Out\",\n\t\t)\n\t})\n\n\tt.Run(\"name tags on result structs are not allowed\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype Result1 struct {\n\t\t\tdig.Out\n\n\t\t\tA string `name:\"foo\"`\n\t\t}\n\n\t\ttype Result2 struct {\n\t\t\tdig.Out\n\n\t\t\tResult1 Result1 `name:\"bar\"`\n\t\t}\n\n\t\terr := c.Provide(func() Result2 {\n\t\t\tpanic(\"this function should never be called\")\n\t\t})\n\t\trequire.Error(t, err)\n\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".TestProvideConstructorErrors\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`bad field \"Result1\" of dig_test.Result2:`,\n\t\t\t\"cannot specify a name for result objects: dig_test.Result1 embeds dig.Out\",\n\t\t)\n\t})\n}\n\nfunc TestProvideRespectsConstructorErrors(t *testing.T) {\n\tt.Run(\"constructor succeeds\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() (*bytes.Buffer, error) {\n\t\t\treturn &bytes.Buffer{}, nil\n\t\t})\n\n\t\tc.RequireInvoke(func(b *bytes.Buffer) {\n\t\t\trequire.NotNil(t, b, \"invoke got nil buffer\")\n\t\t})\n\t})\n\tt.Run(\"constructor fails\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() (*bytes.Buffer, error) {\n\t\t\treturn nil, errors.New(\"oh no\")\n\t\t})\n\n\t\tvar called bool\n\t\terr := c.Invoke(func(b *bytes.Buffer) { called = true })\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".TestProvideRespectsConstructorErrors\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`failed to build \\*bytes.Buffer:`,\n\t\t\t`received non-nil error from function \"go.uber.org/dig_test\".TestProvideRespectsConstructorErrors\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`oh no`)\n\t\tassert.False(t, called, \"shouldn't call invoked function when deps aren't available\")\n\t})\n}\n\nfunc TestCantProvideObjects(t *testing.T) {\n\tt.Parallel()\n\n\tvar writer io.Writer = &bytes.Buffer{}\n\ttests := []struct {\n\t\tobject   interface{}\n\t\ttypeDesc string\n\t}{\n\t\t{&bytes.Buffer{}, \"pointer\"},\n\t\t{bytes.Buffer{}, \"struct\"},\n\t\t{writer, \"interface\"},\n\t\t{map[string]string{}, \"map\"},\n\t\t{[]string{}, \"slice\"},\n\t\t{[1]string{}, \"array\"},\n\t\t{make(chan struct{}), \"channel\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.typeDesc, func(t *testing.T) {\n\t\t\tc := digtest.New(t)\n\t\t\tassert.Error(t, c.Provide(tt.object))\n\t\t})\n\t}\n}\n\nfunc TestProvideWithWeirdNames(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"name with quotes\", func(t *testing.T) {\n\t\ttype type1 struct{ value int }\n\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(func() *type1 {\n\t\t\treturn &type1{42}\n\t\t}, dig.Name(`foo\"\"\"bar`))\n\n\t\ttype params struct {\n\t\t\tdig.In\n\n\t\t\tT *type1 `name:\"foo\\\"\\\"\\\"bar\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(p params) {\n\t\t\tassert.Equal(t, &type1{value: 42}, p.T)\n\t\t})\n\t})\n\n\tt.Run(\"name with newline\", func(t *testing.T) {\n\t\ttype type1 struct{ value int }\n\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(func() *type1 {\n\t\t\treturn &type1{42}\n\t\t}, dig.Name(\"foo\\nbar\"))\n\n\t\ttype params struct {\n\t\t\tdig.In\n\n\t\t\tT *type1 `name:\"foo\\nbar\"`\n\t\t}\n\n\t\tc.RequireInvoke(func(p params) {\n\t\t\tassert.Equal(t, &type1{value: 42}, p.T)\n\t\t})\n\t})\n}\n\nfunc TestProvideInvalidName(t *testing.T) {\n\tt.Parallel()\n\n\tc := digtest.New(t)\n\terr := c.Provide(func() io.Reader {\n\t\tt.Fatal(\"this function must not be called\")\n\t\treturn nil\n\t}, dig.Name(\"foo`bar\"))\n\trequire.Error(t, err, \"Provide must fail\")\n\tassert.Contains(t, err.Error(), \"invalid dig.Name(\\\"foo`bar\\\"): names cannot contain backquotes\")\n}\n\nfunc TestProvideInvalidGroup(t *testing.T) {\n\tt.Parallel()\n\n\tc := digtest.New(t)\n\terr := c.Provide(func() io.Reader {\n\t\tt.Fatal(\"this function must not be called\")\n\t\treturn nil\n\t}, dig.Group(\"foo`bar\"))\n\trequire.Error(t, err, \"Provide must fail\")\n\tassert.Contains(t, err.Error(), \"invalid dig.Group(\\\"foo`bar\\\"): group names cannot contain backquotes\")\n\n\terr = c.Provide(func() io.Reader {\n\t\tt.Fatal(\"this function must not be called\")\n\t\treturn nil\n\t}, dig.Group(\"foo,bar\"))\n\trequire.Error(t, err, \"Provide must fail\")\n\tassert.Contains(t, err.Error(), `cannot parse group \"foo,bar\": invalid option \"bar\"`)\n}\n\nfunc TestProvideInvalidAs(t *testing.T) {\n\tptrToStruct := &struct {\n\t\tname string\n\t}{\n\t\tname: \"example\",\n\t}\n\ttype out struct {\n\t\tdig.Out\n\n\t\tname string\n\t}\n\tvar nilInterface io.Reader\n\n\ttests := []struct {\n\t\tname        string\n\t\tparam       interface{}\n\t\texpectedErr string\n\t\taddlOption  dig.ProvideOption\n\t}{\n\t\t{\n\t\t\tname:        \"as param is not an type interface\",\n\t\t\tparam:       123,\n\t\t\texpectedErr: \"invalid dig.As(int): argument must be a pointer to an interface\",\n\t\t},\n\t\t{\n\t\t\tname:        \"as param is a pointer to struct\",\n\t\t\tparam:       ptrToStruct,\n\t\t\texpectedErr: \"invalid dig.As(*struct { name string }): argument must be a pointer to an interface\",\n\t\t},\n\t\t{\n\t\t\tname:        \"as param is a nil interface\",\n\t\t\tparam:       nilInterface,\n\t\t\texpectedErr: \"invalid dig.As(nil): argument must be a pointer to an interface\",\n\t\t},\n\t\t{\n\t\t\tname:        \"as param is a nil\",\n\t\t\tparam:       nil,\n\t\t\texpectedErr: \"invalid dig.As(nil): argument must be a pointer to an interface\",\n\t\t},\n\t\t{\n\t\t\tname:        \"as param is a func\",\n\t\t\tparam:       func() {},\n\t\t\texpectedErr: \"invalid dig.As(func()): argument must be a pointer to an interface\",\n\t\t},\n\t\t{\n\t\t\tname:        \"as param is a func returning dig_test.out\",\n\t\t\tparam:       func() *out { return &out{name: \"example\"} },\n\t\t\texpectedErr: \"invalid dig.As(func() *dig_test.out): argument must be a pointer to an interface\",\n\t\t},\n\t\t{\n\t\t\tname:        \"as param is not implemented by provided type\",\n\t\t\tparam:       new(io.ReadCloser),\n\t\t\texpectedErr: \"invalid dig.As: *bytes.Buffer does not implement io.ReadCloser\",\n\t\t},\n\t\t{\n\t\t\tname:        \"as param is not implemented by provided type\",\n\t\t\tparam:       new(io.ReadCloser),\n\t\t\texpectedErr: \"invalid dig.As: *bytes.Buffer does not implement io.ReadCloser\",\n\t\t\taddlOption:  dig.Group(\"readclosers\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tc := digtest.New(t)\n\t\t\tvar err error\n\t\t\tif tt.addlOption == nil {\n\t\t\t\terr = c.Provide(\n\t\t\t\t\tfunc() *bytes.Buffer {\n\t\t\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t\t\treturn &buf\n\t\t\t\t\t},\n\t\t\t\t\tdig.As(tt.param),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\terr = c.Provide(\n\t\t\t\t\tfunc() *bytes.Buffer {\n\t\t\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t\t\treturn &buf\n\t\t\t\t\t},\n\t\t\t\t\tdig.As(tt.param),\n\t\t\t\t\ttt.addlOption,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\trequire.Error(t, err, \"provide must fail\")\n\t\t\tassert.Contains(t, err.Error(), tt.expectedErr)\n\t\t})\n\t}\n}\n\nfunc TestAsExpectingOriginalType(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"fail on expecting original type\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(\n\t\t\tfunc() *bytes.Buffer {\n\t\t\t\treturn bytes.NewBufferString(\"foo\")\n\t\t\t},\n\t\t\tdig.As(new(io.Reader)),\n\t\t\tdig.Name(\"buff\"))\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tBuffer *bytes.Buffer `name:\"buff\"`\n\t\t\tReader io.Reader     `name:\"buff\"`\n\t\t}\n\n\t\trequire.Error(t, c.Invoke(func(got in) {\n\t\t\tt.Fatal(\"*bytes.Buffer with name buff shouldn't be provided\")\n\t\t}))\n\t})\n}\n\nfunc TestProvideIncompatibleOptions(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"group and name\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\terr := c.Provide(func() io.Reader {\n\t\t\tt.Fatal(\"this function must not be called\")\n\t\t\treturn nil\n\t\t}, dig.Group(\"foo\"), dig.Name(\"bar\"))\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(), \"cannot use named values with value groups: \"+\n\t\t\t`name:\"bar\" provided with group:\"foo\"`)\n\t})\n}\n\ntype testStruct struct{}\n\nfunc (testStruct) TestMethod(x int) float64 { return float64(x) }\n\nfunc TestProvideLocation(t *testing.T) {\n\tt.Parallel()\n\n\tc := digtest.New(t)\n\tc.RequireProvide(func(x int) float64 {\n\t\treturn testStruct{}.TestMethod(x)\n\t}, dig.LocationForPC(reflect.TypeOf(testStruct{}).Method(0).Func.Pointer()))\n\n\terr := c.Invoke(func(y float64) {})\n\trequire.Error(t, err)\n\trequire.Contains(t, err.Error(), `\"go.uber.org/dig_test\".testStruct.TestMethod`)\n\trequire.Contains(t, err.Error(), `dig/dig_test.go`)\n}\n\nfunc TestCantProvideUntypedNil(t *testing.T) {\n\tt.Parallel()\n\tc := digtest.New(t)\n\tassert.Error(t, c.Provide(nil))\n}\n\nfunc TestCantProvideErrorLikeType(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []interface{}{\n\t\tfunc() *os.PathError { return &os.PathError{} },\n\t\tfunc() error { return &os.PathError{} },\n\t\tfunc() (*os.PathError, error) { return &os.PathError{}, nil },\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%T\", tt), func(t *testing.T) {\n\t\t\tc := digtest.New(t)\n\t\t\tassert.Error(t, c.Provide(tt), \"providing errors should fail\")\n\t\t})\n\t}\n}\n\nfunc TestCantProvideParameterObjects(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"constructor\", func(t *testing.T) {\n\t\ttype Args struct{ dig.In }\n\n\t\tc := digtest.New(t)\n\t\terr := c.Provide(func() (Args, error) {\n\t\t\tpanic(\"great sadness\")\n\t\t})\n\t\trequire.Error(t, err, \"provide should fail\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".TestCantProvideParameterObjects\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"bad result 1:\",\n\t\t\t\"cannot provide parameter objects: dig_test.Args embeds a dig.In\",\n\t\t)\n\t})\n\n\tt.Run(\"pointer from constructor\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype Args struct{ dig.In }\n\n\t\targs := &Args{}\n\n\t\terr := c.Provide(func() (*Args, error) { return args, nil })\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".TestCantProvideParameterObjects\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"bad result 1:\",\n\t\t\t`cannot provide parameter objects: \\*dig_test.Args embeds a dig.In`,\n\t\t)\n\t})\n}\n\nfunc TestProvideKnownTypesFails(t *testing.T) {\n\tt.Parallel()\n\n\tprovideArgs := []interface{}{\n\t\tfunc() *bytes.Buffer { return nil },\n\t\tfunc() (*bytes.Buffer, error) { return nil, nil },\n\t}\n\n\tfor _, first := range provideArgs {\n\t\tt.Run(fmt.Sprintf(\"%T\", first), func(t *testing.T) {\n\t\t\tc := digtest.New(t)\n\t\t\tc.RequireProvide(first)\n\n\t\t\tfor _, second := range provideArgs {\n\t\t\t\tassert.Error(t, c.Provide(second), \"second provide must fail\")\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"provide constructor twice\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() *bytes.Buffer { return nil })\n\t\tassert.Error(t, c.Provide(func() *bytes.Buffer { return nil }))\n\t})\n}\n\nfunc TestDryModeSuccess(t *testing.T) {\n\tt.Run(\"does not call provides\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\tprovides := func() *type1 {\n\t\t\tt.Fatal(\"must not be called\")\n\t\t\treturn &type1{}\n\t\t}\n\t\tinvokes := func(*type1) {}\n\t\tc := digtest.New(t, dig.DryRun(true))\n\t\tc.RequireProvide(provides)\n\t\tc.RequireInvoke(invokes)\n\t})\n\tt.Run(\"does not call invokes\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\tprovides := func() *type1 {\n\t\t\tt.Fatal(\"must not be called\")\n\t\t\treturn &type1{}\n\t\t}\n\t\tinvokes := func(*type1) {\n\t\t\tt.Fatal(\"must not be called\")\n\t\t}\n\t\tc := digtest.New(t, dig.DryRun(true))\n\t\tc.RequireProvide(provides)\n\t\tc.RequireInvoke(invokes)\n\t})\n\tt.Run(\"does not call decorators\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\tprovides := func() *type1 {\n\t\t\tt.Fatal(\"must not be called\")\n\t\t\treturn &type1{}\n\t\t}\n\t\tdecorates := func(*type1) *type1 {\n\t\t\tt.Fatal(\"must not be called\")\n\t\t\treturn &type1{}\n\t\t}\n\t\tinvokes := func(*type1) {}\n\t\tc := digtest.New(t, dig.DryRun(true))\n\t\tc.RequireProvide(provides)\n\t\tc.RequireDecorate(decorates)\n\t\tc.RequireInvoke(invokes)\n\t})\n}\n\nfunc TestProvideCycleFails(t *testing.T) {\n\tt.Run(\"not dry\", func(t *testing.T) {\n\t\ttestProvideCycleFails(t, false /* dry run */)\n\t})\n\tt.Run(\"dry\", func(t *testing.T) {\n\t\ttestProvideCycleFails(t, true /* dry run */)\n\t})\n}\n\nfunc testProvideCycleFails(t *testing.T, dryRun bool) {\n\tt.Parallel()\n\n\tt.Run(\"parameters only\", func(t *testing.T) {\n\t\t// A <- B <- C\n\t\t// |         ^\n\t\t// |_________|\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\ttype C struct{}\n\t\tnewA := func(*C) *A { return &A{} }\n\t\tnewB := func(*A) *B { return &B{} }\n\t\tnewC := func(*B) *C { return &C{} }\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\tc.RequireProvide(newA)\n\t\tc.RequireProvide(newB)\n\t\terr := c.Provide(newC)\n\t\trequire.Error(t, err, \"expected error when introducing cycle\")\n\t\trequire.True(t, dig.IsCycleDetected(err))\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideCycleFails.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`this function introduces a cycle:`,\n\t\t\t`func\\(\\*dig_test.C\\) \\*dig_test.A provided by \"go.uber.org/dig_test\".testProvideCycleFails\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(\\*dig_test.B\\) \\*dig_test.C provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(\\*dig_test.A\\) \\*dig_test.B provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(\\*dig_test.C\\) \\*dig_test.A provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t)\n\t\tassert.NotContains(t, err.Error(), \"[scope\")\n\t\tassert.Error(t, c.Invoke(func(c *C) {}), \"expected invoking a function that uses a type that failed to provide to fail.\")\n\t})\n\n\tt.Run(\"dig.In based cycle\", func(t *testing.T) {\n\t\t// Same cycle as before but in terms of dig.Ins.\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\ttype C struct{}\n\n\t\ttype AParams struct {\n\t\t\tdig.In\n\n\t\t\tC C\n\t\t}\n\t\tnewA := func(AParams) A { return A{} }\n\n\t\ttype BParams struct {\n\t\t\tdig.In\n\n\t\t\tA A\n\t\t}\n\t\tnewB := func(BParams) B { return B{} }\n\n\t\ttype CParams struct {\n\t\t\tdig.In\n\n\t\t\tB B\n\t\t\tW io.Writer\n\t\t}\n\t\tnewC := func(CParams) C { return C{} }\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\tc.RequireProvide(newA)\n\t\tc.RequireProvide(newB)\n\n\t\terr := c.Provide(newC)\n\t\trequire.Error(t, err, \"expected error when introducing cycle\")\n\t\trequire.True(t, dig.IsCycleDetected(err))\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideCycleFails.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`this function introduces a cycle:`,\n\t\t\t`func\\(dig_test.AParams\\) dig_test.A provided by \"go.uber.org/dig_test\".testProvideCycleFails\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(dig_test.CParams\\) dig_test.C provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(dig_test.BParams\\) dig_test.B provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(dig_test.AParams\\) dig_test.A provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t)\n\t\tassert.Error(t, c.Invoke(func(c C) {}), \"expected invoking a function that uses a type that failed to provide to fail.\")\n\t})\n\n\tt.Run(\"group based cycle\", func(t *testing.T) {\n\t\ttype D struct{}\n\n\t\ttype outA struct {\n\t\t\tdig.Out\n\n\t\t\tFoo string `group:\"foo\"`\n\t\t\tBar int    `group:\"bar\"`\n\t\t}\n\t\tnewA := func() outA {\n\t\t\trequire.FailNow(t, \"must not be called\")\n\t\t\treturn outA{}\n\t\t}\n\n\t\ttype outB struct {\n\t\t\tdig.Out\n\n\t\t\tFoo string `group:\"foo\"`\n\t\t}\n\t\tnewB := func(*D) outB {\n\t\t\trequire.FailNow(t, \"must not be called\")\n\t\t\treturn outB{}\n\t\t}\n\n\t\ttype inC struct {\n\t\t\tdig.In\n\n\t\t\tFoos []string `group:\"foo\"`\n\t\t}\n\n\t\ttype outC struct {\n\t\t\tdig.Out\n\n\t\t\tBar int `group:\"bar\"`\n\t\t}\n\n\t\tnewC := func(i inC) outC {\n\t\t\trequire.FailNow(t, \"must not be called\")\n\t\t\treturn outC{}\n\t\t}\n\n\t\ttype inD struct {\n\t\t\tdig.In\n\n\t\t\tBars []int `group:\"bar\"`\n\t\t}\n\n\t\tnewD := func(inD) *D {\n\t\t\trequire.FailNow(t, \"must not be called\")\n\t\t\treturn nil\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(newA)\n\t\tc.RequireProvide(newB)\n\t\tc.RequireProvide(newC)\n\n\t\terr := c.Provide(newD)\n\t\trequire.Error(t, err)\n\t\trequire.True(t, dig.IsCycleDetected(err))\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideCycleFails.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`this function introduces a cycle:`,\n\t\t\t`func\\(\\*dig_test.D\\) dig_test.outB provided by \"go.uber.org/dig_test\".testProvideCycleFails\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(dig_test.inD\\) \\*dig_test.D provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(dig_test.inC\\) dig_test.outC provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(\\*dig_test.D\\) dig_test.outB provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t)\n\t})\n\n\tt.Run(\"DeferAcyclicVerification bypasses cycle check, VerifyAcyclic catches cycle\", func(t *testing.T) {\n\t\t// A <- B <- C <- D\n\t\t// |         ^\n\t\t// |_________|\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\ttype C struct{}\n\t\ttype D struct{}\n\t\tnewA := func(*C) *A { return &A{} }\n\t\tnewB := func(*A) *B { return &B{} }\n\t\tnewC := func(*B) *C { return &C{} }\n\t\tnewD := func(*C) *D { return &D{} }\n\n\t\tc := digtest.New(t, dig.DeferAcyclicVerification())\n\t\tc.RequireProvide(newA)\n\t\tc.RequireProvide(newB)\n\t\tc.RequireProvide(newC)\n\t\tc.RequireProvide(newD)\n\n\t\terr := c.Invoke(func(*A) {})\n\t\trequire.Error(t, err, \"expected error when introducing cycle\")\n\t\tassert.True(t, dig.IsCycleDetected(err))\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cycle detected in dependency graph:`,\n\t\t\t`func\\(\\*dig_test.C\\) \\*dig_test.A provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(\\*dig_test.B\\) \\*dig_test.C provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(\\*dig_test.A\\) \\*dig_test.B provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(\\*dig_test.C\\) \\*dig_test.A provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t)\n\t})\n\n\tt.Run(\"DeferAcyclicVerification eventually catches cycle with self-cycle\", func(t *testing.T) {\n\t\t// A      <-- C <- D\n\t\t// |      |__^    ^\n\t\t// |______________|\n\t\ttype A struct{}\n\t\ttype C struct{}\n\t\ttype D struct{}\n\t\tnewA := func(*D) *A { return &A{} }\n\t\tnewC := func(*C) *C { return &C{} }\n\t\tnewD := func(*C) *D { return &D{} }\n\n\t\tc := digtest.New(t, dig.DeferAcyclicVerification())\n\t\tc.RequireProvide(newA)\n\t\tc.RequireProvide(newC)\n\t\tc.RequireProvide(newD)\n\n\t\terr := c.Invoke(func(*A) {})\n\t\trequire.Error(t, err, \"expected error when introducing cycle\")\n\t\tassert.True(t, dig.IsCycleDetected(err))\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cycle detected in dependency graph:`,\n\t\t\t`func\\(\\*dig_test.C\\) \\*dig_test.C provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t\t`depends on func\\(\\*dig_test.C\\) \\*dig_test.C provided by \"go.uber.org/dig_test\".testProvideCycleFails.\\S+ \\(\\S+\\)`,\n\t\t)\n\t})\n}\n\nfunc TestProvideErrNonCycle(t *testing.T) {\n\tc := digtest.New(t)\n\ttype A struct{}\n\ttype B struct{}\n\tnewA := func() *A { return &A{} }\n\n\tc.RequireProvide(newA)\n\terr := c.Invoke(func(*B) {})\n\trequire.Error(t, err)\n\tassert.False(t, dig.IsCycleDetected(err))\n}\n\nfunc TestIncompleteGraphIsOkay(t *testing.T) {\n\tt.Parallel()\n\n\t// A <- B <- C\n\t// Even if we don't provide B, we should be able to resolve A.\n\ttype A struct{}\n\ttype B struct{}\n\ttype C struct{}\n\tnewA := func() *A { return &A{} }\n\tnewC := func(*B) *C { return &C{} }\n\n\tc := digtest.New(t)\n\tc.RequireProvide(newA)\n\tc.RequireProvide(newC)\n\tc.RequireInvoke(func(*A) {})\n}\n\nfunc TestProvideFuncsWithoutReturnsFails(t *testing.T) {\n\tt.Parallel()\n\n\tc := digtest.New(t)\n\tassert.Error(t, c.Provide(func(*bytes.Buffer) {}))\n}\n\nfunc TestTypeCheckingEquality(t *testing.T) {\n\ttype A struct{}\n\ttype B struct {\n\t\tdig.Out\n\t\tA\n\t}\n\ttype in struct {\n\t\tdig.In\n\t\tA\n\t}\n\ttype out struct {\n\t\tB\n\t}\n\ttests := []struct {\n\t\titem  interface{}\n\t\tisIn  bool\n\t\tisOut bool\n\t}{\n\t\t{in{}, true, false},\n\t\t{out{}, false, true},\n\t\t{A{}, false, false},\n\t\t{B{}, false, true},\n\t\t{nil, false, false},\n\t}\n\tfor _, tt := range tests {\n\t\trequire.Equal(t, tt.isIn, dig.IsIn(tt.item))\n\t\trequire.Equal(t, tt.isOut, dig.IsOut(tt.item))\n\t}\n}\n\nfunc TestInvokesUseCachedObjects(t *testing.T) {\n\tt.Parallel()\n\n\tc := digtest.New(t)\n\n\tconstructorCalls := 0\n\tbuf := &bytes.Buffer{}\n\tc.RequireProvide(func() *bytes.Buffer {\n\t\tassert.Equal(t, 0, constructorCalls, \"constructor must not have been called before\")\n\t\tconstructorCalls++\n\t\treturn buf\n\t})\n\n\tcalls := 0\n\tfor i := 0; i < 3; i++ {\n\t\tc.RequireInvoke(func(b *bytes.Buffer) {\n\t\t\tcalls++\n\t\t\trequire.Equal(t, 1, constructorCalls, \"constructor must be called exactly once\")\n\t\t\trequire.Equal(t, buf, b, \"invoke got different buffer pointer\")\n\t\t})\n\n\t\trequire.Equal(t, i+1, calls, \"invoked function not called\")\n\t}\n}\n\nfunc TestProvideFailures(t *testing.T) {\n\tt.Run(\"not dry\", func(t *testing.T) {\n\t\ttestProvideFailures(t, false /* dry run */)\n\t})\n\tt.Run(\"dry\", func(t *testing.T) {\n\t\ttestProvideFailures(t, true /* dry run */)\n\t})\n}\n\nfunc testProvideFailures(t *testing.T, dryRun bool) {\n\tt.Run(\"out returning multiple instances of the same type\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype A struct{ idx int }\n\t\ttype ret struct {\n\t\t\tdig.Out\n\n\t\t\tA1 A // sampe type A provided three times\n\t\t\tA2 A\n\t\t\tA3 A\n\t\t}\n\n\t\terr := c.Provide(func() ret {\n\t\t\treturn ret{\n\t\t\t\tA1: A{idx: 1},\n\t\t\t\tA2: A{idx: 2},\n\t\t\t\tA3: A{idx: 3},\n\t\t\t}\n\t\t})\n\t\trequire.Error(t, err, \"provide must return error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`cannot provide dig_test.A from \\[0\\].A2:`,\n\t\t\t`already provided by \\[0\\].A1`,\n\t\t)\n\t})\n\n\tt.Run(\"out returning multiple instances of the same type and As option\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{ idx int }\n\t\ttype ret struct {\n\t\t\tdig.Out\n\n\t\t\tA1 A // same type A provided three times\n\t\t\tA2 A\n\t\t\tA3 A\n\t\t}\n\n\t\terr := c.Provide(func() ret {\n\t\t\treturn ret{\n\t\t\t\tA1: A{idx: 1},\n\t\t\t\tA2: A{idx: 2},\n\t\t\t\tA3: A{idx: 3},\n\t\t\t}\n\t\t}, dig.As(new(interface{})))\n\t\trequire.Error(t, err, \"provide must return error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`cannot provide interface {} from \\[0\\].A2:`,\n\t\t\t`already provided by \\[0\\].A1`,\n\t\t)\n\t})\n\n\tt.Run(\"provide multiple instances with the same name\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype A struct{}\n\t\ttype ret1 struct {\n\t\t\tdig.Out\n\t\t\t*A `name:\"foo\"`\n\t\t}\n\t\ttype ret2 struct {\n\t\t\tdig.Out\n\t\t\t*A `name:\"foo\"`\n\t\t}\n\t\tc.RequireProvide(func() ret1 {\n\t\t\treturn ret1{A: &A{}}\n\t\t})\n\n\t\terr := c.Provide(func() ret2 {\n\t\t\treturn ret2{A: &A{}}\n\t\t})\n\t\trequire.Error(t, err, \"expected error on the second provide\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`cannot provide \\*dig_test.A\\[name=\"foo\"\\] from \\[0\\].A:`,\n\t\t\t`already provided by \"go.uber.org/dig_test\".testProvideFailures\\S+`,\n\t\t)\n\t})\n\n\tt.Run(\"out with unexported field should error\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\ttype A struct{ idx int }\n\t\ttype out1 struct {\n\t\t\tdig.Out\n\n\t\t\tA1 A // should be ok\n\t\t\ta2 A // oops, unexported field. should generate an error\n\t\t}\n\t\terr := c.Provide(func() out1 { return out1{a2: A{77}} })\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"bad result 1:\",\n\t\t\t`bad field \"a2\" of dig_test.out1:`,\n\t\t\t`unexported fields not allowed in dig.Out, did you mean to export \"a2\" \\(dig_test.A\\)\\?`,\n\t\t)\n\t})\n\n\tt.Run(\"providing pointer to out should fail\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tString string\n\t\t}\n\t\terr := c.Provide(func() *out { return &out{String: \"foo\"} })\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"bad result 1:\",\n\t\t\t`cannot return a pointer to a result object, use a value instead: \\*dig_test.out is a pointer to a struct that embeds dig.Out`,\n\t\t)\n\t})\n\n\tt.Run(\"embedding pointer to out should fail\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\ttype out struct {\n\t\t\t*dig.Out\n\n\t\t\tString string\n\t\t}\n\n\t\terr := c.Provide(func() out { return out{String: \"foo\"} })\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"bad result 1:\",\n\t\t\t`cannot build a result object by embedding \\*dig.Out, embed dig.Out instead: dig_test.out embeds \\*dig.Out`,\n\t\t)\n\t})\n\n\tt.Run(\"provide the same implemented interface\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\terr := c.Provide(\n\t\t\tfunc() *bytes.Buffer {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\treturn &buf\n\t\t\t},\n\t\t\tdig.As(new(io.Reader)),\n\t\t\tdig.As(new(io.Reader)),\n\t\t)\n\n\t\trequire.Error(t, err, \"provide must fail\")\n\t\tassert.Contains(t, err.Error(), \"cannot provide io.Reader\")\n\t\tassert.Contains(t, err.Error(), \"already provided\")\n\t})\n\n\tt.Run(\"provide the same implementation with as interface\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(\n\t\t\tfunc() *bytes.Buffer {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\treturn &buf\n\t\t\t},\n\t\t\tdig.As(new(io.Reader)),\n\t\t)\n\n\t\terr := c.Provide(\n\t\t\tfunc() *bytes.Buffer {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\treturn &buf\n\t\t\t},\n\t\t\tdig.As(new(io.Reader)),\n\t\t)\n\n\t\trequire.Error(t, err, \"provide must fail\")\n\t\tassert.Contains(t, err.Error(), \"cannot provide io.Reader\")\n\t\tassert.Contains(t, err.Error(), \"already provided\")\n\t})\n\n\tt.Run(\"error should refer to location given by LocationForPC ProvideOption\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A struct{ idx int }\n\t\ttype ret struct {\n\t\t\tdig.Out\n\n\t\t\tA1 A // same type A provided twice\n\t\t\tA2 A\n\t\t}\n\n\t\tlocationFn := func() {}\n\n\t\terr := c.Provide(func() ret {\n\t\t\treturn ret{\n\t\t\t\tA1: A{idx: 1},\n\t\t\t\tA2: A{idx: 2},\n\t\t\t}\n\t\t}, dig.LocationForPC(reflect.ValueOf(locationFn).Pointer()))\n\t\trequire.Error(t, err, \"provide must return error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testProvideFailures.func\\d+.1`,\n\t\t)\n\t})\n}\n\nfunc TestInvokeFailures(t *testing.T) {\n\tt.Run(\"not dry\", func(t *testing.T) {\n\t\ttestInvokeFailures(t, false /* dry run */)\n\t})\n\tt.Run(\"dry\", func(t *testing.T) {\n\t\ttestInvokeFailures(t, false /* dry run */)\n\t})\n}\n\nfunc testInvokeFailures(t *testing.T, dryRun bool) {\n\tt.Parallel()\n\n\tt.Run(\"invoke a non-function\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\terr := c.Invoke(\"foo\")\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err, `can't invoke non-function foo \\(type string\\)`)\n\t})\n\n\tt.Run(\"untyped nil\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\terr := c.Invoke(nil)\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err, `can't invoke an untyped nil`)\n\t})\n\n\tt.Run(\"unmet dependency\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\terr := c.Invoke(func(*bytes.Buffer) {})\n\t\trequire.Error(t, err, \"expected failure\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`,\n\t\t\t`missing type:`,\n\t\t\t`\\*bytes.Buffer`,\n\t\t)\n\t})\n\n\tt.Run(\"unmet required dependency\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\n\t\ttype args struct {\n\t\t\tdig.In\n\n\t\t\tT1 *type1 `optional:\"true\"`\n\t\t\tT2 *type2 `optional:\"0\"`\n\t\t}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\terr := c.Invoke(func(a args) {\n\t\t\tt.Fatal(\"function must not be called\")\n\t\t})\n\n\t\trequire.Error(t, err, \"expected invoke error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing type:`,\n\t\t\t`\\*dig_test.type2`,\n\t\t)\n\t})\n\n\tt.Run(\"unmet named dependency\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\t*bytes.Buffer `name:\"foo\"`\n\t\t}\n\t\terr := c.Invoke(func(p param) {\n\t\t\tt.Fatal(\"function should not be called\")\n\t\t})\n\t\trequire.Error(t, err, \"invoke should fail\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing type:`,\n\t\t\t`\\*bytes.Buffer\\[name=\"foo\"\\]`,\n\t\t)\n\t})\n\n\tt.Run(\"unmet constructor dependency\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tT1 *type1\n\t\t\tT2 *type2 `optional:\"true\"`\n\t\t}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(func(p param) *type3 {\n\t\t\tt.Fatal(\"function must not be called\")\n\t\t\treturn nil\n\t\t})\n\n\t\terr := c.Invoke(func(*type3) {\n\t\t\tt.Fatal(\"function must not be called\")\n\t\t})\n\t\trequire.Error(t, err, \"invoke must fail\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`failed to build \\*dig_test.type3:`,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing type:`,\n\t\t\t`\\*dig_test.type1`,\n\t\t)\n\t\t// We don't expect type2 to be mentioned in the list because it's\n\t\t// optional\n\t})\n\n\tt.Run(\"multiple unmet constructor dependencies\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(func() type2 {\n\t\t\tt.Fatal(\"function must not be called\")\n\t\t\treturn type2{}\n\t\t})\n\n\t\tc.RequireProvide(func(type1, *type2) type3 {\n\t\t\tt.Fatal(\"function must not be called\")\n\t\t\treturn type3{}\n\t\t})\n\n\t\terr := c.Invoke(func(type3) {\n\t\t\tt.Fatal(\"function must not be called\")\n\t\t})\n\n\t\trequire.Error(t, err, \"invoke must fail\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`failed to build dig_test.type3:`,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing types:`,\n\t\t\t\"dig_test.type1\",\n\t\t\t`\\*dig_test.type2 \\(did you mean (to use )?dig_test.type2\\?\\)`,\n\t\t)\n\t})\n\n\tt.Run(\"invalid optional tag\", func(t *testing.T) {\n\t\ttype args struct {\n\t\t\tdig.In\n\n\t\t\tBuffer *bytes.Buffer `optional:\"no\"`\n\t\t}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\terr := c.Invoke(func(a args) {\n\t\t\tt.Fatal(\"function must not be called\")\n\t\t})\n\n\t\trequire.Error(t, err, \"expected invoke error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`bad field \"Buffer\" of dig_test.args:`,\n\t\t\t`invalid value \"no\" for \"optional\" tag on field Buffer:`,\n\t\t)\n\t})\n\n\tt.Run(\"constructor invalid optional tag\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\n\t\ttype nestedArgs struct {\n\t\t\tdig.In\n\n\t\t\tBuffer *bytes.Buffer `optional:\"no\"`\n\t\t}\n\n\t\ttype args struct {\n\t\t\tdig.In\n\n\t\t\tArgs nestedArgs\n\t\t}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\terr := c.Provide(func(a args) *type1 {\n\t\t\tt.Fatal(\"function must not be called\")\n\t\t\treturn nil\n\t\t})\n\n\t\trequire.Error(t, err, \"expected provide error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"bad argument 1:\",\n\t\t\t`bad field \"Args\" of dig_test.args:`,\n\t\t\t`bad field \"Buffer\" of dig_test.nestedArgs:`,\n\t\t\t`invalid value \"no\" for \"optional\" tag on field Buffer:`,\n\t\t)\n\t})\n\n\tt.Run(\"optional dep with unmet transitive dep\", func(t *testing.T) {\n\t\ttype missing struct{}\n\t\ttype dep struct{}\n\n\t\ttype params struct {\n\t\t\tdig.In\n\n\t\t\tDep *dep `optional:\"true\"`\n\t\t}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\t// Container has a constructor for *dep, but that constructor has unmet\n\t\t// dependencies.\n\t\tc.RequireProvide(func(missing) *dep {\n\t\t\tt.Fatal(\"constructor for *dep should not be called\")\n\t\t\treturn nil\n\t\t})\n\n\t\t// Should still be able to invoke a function that takes params, since *dep\n\t\t// is optional.\n\t\tvar count int\n\t\tc.RequireInvoke(func(p params) {\n\t\t\tcount++\n\t\t\tassert.Nil(t, p.Dep, \"expected optional dependency to be unmet\")\n\t\t})\n\t\tassert.Equal(t, 1, count, \"expected invoke function to be called\")\n\t})\n\n\tt.Run(\"optional dep with failed transitive dep\", func(t *testing.T) {\n\t\ttype failed struct{}\n\t\ttype dep struct{}\n\n\t\ttype params struct {\n\t\t\tdig.In\n\n\t\t\tDep *dep `optional:\"true\"`\n\t\t}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\terrFailed := errors.New(\"failed\")\n\t\tc.RequireProvide(func() (*failed, error) {\n\t\t\treturn nil, errFailed\n\t\t})\n\n\t\tc.RequireProvide(func(*failed) *dep {\n\t\t\tt.Fatal(\"constructor for *dep should not be called\")\n\t\t\treturn nil\n\t\t})\n\n\t\t// Should still be able to invoke a function that takes params, since *dep\n\t\t// is optional.\n\t\terr := c.Invoke(func(p params) {\n\t\t\tt.Fatal(\"shouldn't execute invoked function\")\n\t\t})\n\t\trequire.Error(t, err, \"expected invoke error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`failed to build \\*dig_test.dep:`,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`failed to build \\*dig_test.failed:`,\n\t\t\t`received non-nil error from function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`failed`,\n\t\t)\n\t\tassert.Equal(t, errFailed, dig.RootCause(err), \"root cause must match\")\n\t})\n\n\tt.Run(\"returned error\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\terr := c.Invoke(func() error { return errors.New(\"oh no\") })\n\t\trequire.Equal(t, errors.New(\"oh no\"), err, \"error must match\")\n\t})\n\n\tt.Run(\"many returns\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\terr := c.Invoke(func() (int, error) { return 42, errors.New(\"oh no\") })\n\t\trequire.Equal(t, errors.New(\"oh no\"), err, \"error must match\")\n\t})\n\n\tt.Run(\"named instances are case sensitive\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype A struct{}\n\t\ttype ret struct {\n\t\t\tdig.Out\n\t\t\tA `name:\"CamelCase\"`\n\t\t}\n\t\ttype param1 struct {\n\t\t\tdig.In\n\t\t\tA `name:\"CamelCase\"`\n\t\t}\n\t\ttype param2 struct {\n\t\t\tdig.In\n\t\t\tA `name:\"camelcase\"`\n\t\t}\n\t\tc.RequireProvide(func() ret { return ret{A: A{}} })\n\t\tc.RequireInvoke(func(param1) {})\n\t\terr := c.Invoke(func(param2) {})\n\t\trequire.Error(t, err, \"provide should return error since cases don't match\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing type:`,\n\t\t\t`dig_test.A\\[name=\"camelcase\"\\]`)\n\t})\n\n\tt.Run(\"in unexported member gets an error\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype A struct{}\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tA1 A // all is good\n\t\t\ta2 A // oops, unexported type\n\t\t}\n\n\t\t_ = in{}.a2 // unused but needed for the test\n\n\t\tc.RequireProvide(func() A { return A{} })\n\n\t\terr := c.Invoke(func(i in) { assert.Fail(t, \"should never get in here\") })\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\"bad argument 1:\",\n\t\t\t`bad field \"a2\" of dig_test.in:`,\n\t\t\t`unexported fields not allowed in dig.In, did you mean to export \"a2\" \\(dig_test.A\\)\\?`,\n\t\t)\n\t})\n\n\tt.Run(\"in unexported member gets an error on Provide\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tfoo string\n\t\t}\n\n\t\t_ = in{}.foo // unused but needed for the test\n\n\t\terr := c.Provide(func(in) int { return 0 })\n\t\trequire.Error(t, err, \"Provide must fail\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"bad argument 1:\",\n\t\t\t`bad field \"foo\" of dig_test.in:`,\n\t\t\t`unexported fields not allowed in dig.In, did you mean to export \"foo\" \\(string\\)\\?`,\n\t\t)\n\t})\n\n\tt.Run(\"embedded unexported member gets an error\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype A struct{}\n\t\ttype Embed struct {\n\t\t\tdig.In\n\n\t\t\tA1 A // all is good\n\t\t\ta2 A // oops, unexported type\n\t\t}\n\t\ttype in struct {\n\t\t\tEmbed\n\t\t}\n\n\t\t_ = in{}.a2 // unused but needed for the test\n\n\t\tc.RequireProvide(func() A { return A{} })\n\n\t\terr := c.Invoke(func(i in) { assert.Fail(t, \"should never get in here\") })\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\"bad argument 1:\",\n\t\t\t`bad field \"Embed\" of dig_test.in:`,\n\t\t\t`bad field \"a2\" of dig_test.Embed:`,\n\t\t\t`unexported fields not allowed in dig.In, did you mean to export \"a2\" \\(dig_test.A\\)\\?`,\n\t\t)\n\t})\n\n\tt.Run(\"embedded unexported member gets an error\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tstring // embed an unexported std type\n\t\t}\n\n\t\t_ = param{}.string // unused but needed for the test\n\n\t\terr := c.Invoke(func(p param) { assert.Fail(t, \"should never get here\") })\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\"bad argument 1:\",\n\t\t\t`bad field \"string\" of dig_test.param:`,\n\t\t\t`unexported fields not allowed in dig.In, did you mean to export \"string\" \\(string\\)\\?`,\n\t\t)\n\t})\n\n\tt.Run(\"pointer in dependency is not supported\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tString string\n\t\t\tNum    int\n\t\t}\n\t\terr := c.Invoke(func(i *in) { assert.Fail(t, \"should never get here\") })\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\"bad argument 1:\",\n\t\t\t`cannot depend on a pointer to a parameter object, use a value instead: \\*dig_test.in is a pointer to a struct that embeds dig.In`,\n\t\t)\n\t})\n\n\tt.Run(\"embedding dig.In and dig.Out is not supported\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype in struct {\n\t\t\tdig.In\n\t\t\tdig.Out\n\n\t\t\tString string\n\t\t}\n\n\t\terr := c.Invoke(func(in) {\n\t\t\tassert.Fail(t, \"should never get here\")\n\t\t})\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\"bad argument 1:\",\n\t\t\t\"cannot depend on result objects: dig_test.in embeds a dig.Out\",\n\t\t)\n\t})\n\n\tt.Run(\"embedding in pointer is not supported\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\ttype in struct {\n\t\t\t*dig.In\n\n\t\t\tString string\n\t\t\tNum    int\n\t\t}\n\t\terr := c.Invoke(func(i in) { assert.Fail(t, \"should never get here\") })\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\"bad argument 1:\",\n\t\t\t`cannot build a parameter object by embedding \\*dig.In, embed dig.In instead: dig_test.in embeds \\*dig.In`,\n\t\t)\n\t})\n\n\tt.Run(\"requesting a value or pointer when other is present\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype outA struct {\n\t\t\tdig.Out\n\n\t\t\tA `name:\"hello\"`\n\t\t}\n\t\ttype outPointerA struct {\n\t\t\tdig.Out\n\n\t\t\tA *A `name:\"hello\"`\n\t\t}\n\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\tprovide     interface{}\n\t\t\tinvoke      interface{}\n\t\t\terrContains []string\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"value missing, pointer present\",\n\t\t\t\tprovide: func() *A { return &A{} },\n\t\t\t\tinvoke:  func(A) {},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`dig_test.A \\(did you mean (to use )?\\*dig_test.A\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"pointer missing, value present\",\n\t\t\t\tprovide: func() A { return A{} },\n\t\t\t\tinvoke:  func(*A) {},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\*dig_test.A \\(did you mean (to use )?dig_test.A\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"named pointer missing, value present\",\n\t\t\t\tprovide: func() outA { return outA{A: A{}} },\n\t\t\t\tinvoke: func(struct {\n\t\t\t\t\tdig.In\n\n\t\t\t\t\t*A `name:\"hello\"`\n\t\t\t\t}) {\n\t\t\t\t},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\*dig_test.A\\[name=\"hello\"\\] \\(did you mean (to use )?dig_test.A\\[name=\"hello\"\\]\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"named value missing, pointer present\",\n\t\t\t\tprovide: func() outPointerA { return outPointerA{A: &A{}} },\n\t\t\t\tinvoke: func(struct {\n\t\t\t\t\tdig.In\n\n\t\t\t\t\tA `name:\"hello\"`\n\t\t\t\t}) {\n\t\t\t\t},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`dig_test.A\\[name=\"hello\"\\] \\(did you mean (to use )?\\*dig_test.A\\[name=\"hello\"\\]\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tc.RequireProvide(tc.provide)\n\n\t\t\t\terr := c.Invoke(tc.invoke)\n\t\t\t\trequire.Error(t, err)\n\n\t\t\t\tlines := append([]string{\n\t\t\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\t}, tc.errContains...)\n\t\t\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t\t\tlines...)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"requesting a slice of values or pointers when the other is present\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype outA struct {\n\t\t\tdig.Out\n\n\t\t\tA []A `name:\"hello\"`\n\t\t}\n\t\ttype outPointerA struct {\n\t\t\tdig.Out\n\n\t\t\tA []*A `name:\"hello\"`\n\t\t}\n\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\tprovide     interface{}\n\t\t\tinvoke      interface{}\n\t\t\terrContains []string\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"value slice missing, pointer slice present\",\n\t\t\t\tprovide: func() []*A { return []*A{{}} },\n\t\t\t\tinvoke:  func([]A) {},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\[\\]dig_test.A \\(did you mean (to use )?\\[\\]\\*dig_test.A\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"pointer slice missing, value slice present\",\n\t\t\t\tprovide: func() []A { return []A{{}} },\n\t\t\t\tinvoke:  func([]*A) {},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\[\\]\\*dig_test.A \\(did you mean (to use )?\\[\\]dig_test.A\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"named pointer slice missing, value slice present\",\n\t\t\t\tprovide: func() outA { return outA{A: []A{{}}} },\n\t\t\t\tinvoke: func(struct {\n\t\t\t\t\tdig.In\n\n\t\t\t\t\tA []*A `name:\"hello\"`\n\t\t\t\t}) {\n\t\t\t\t},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\[\\]\\*dig_test.A\\[name=\"hello\"\\] \\(did you mean (to use )?\\[\\]dig_test.A\\[name=\"hello\"\\]\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"named value slice missing, pointer slice present\",\n\t\t\t\tprovide: func() outPointerA { return outPointerA{A: []*A{{}}} },\n\t\t\t\tinvoke: func(struct {\n\t\t\t\t\tdig.In\n\n\t\t\t\t\tA []A `name:\"hello\"`\n\t\t\t\t}) {\n\t\t\t\t},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\[\\]dig_test.A\\[name=\"hello\"\\] \\(did you mean (to use )?\\[\\]\\*dig_test.A\\[name=\"hello\"\\]\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tc.RequireProvide(tc.provide)\n\n\t\t\t\terr := c.Invoke(tc.invoke)\n\t\t\t\trequire.Error(t, err)\n\n\t\t\t\tlines := append([]string{\n\t\t\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\t}, tc.errContains...)\n\t\t\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t\t\tlines...)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"requesting an array of values or pointers when the other is present\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype outA struct {\n\t\t\tdig.Out\n\n\t\t\tA [7]A `name:\"hello\"`\n\t\t}\n\t\ttype outPointerA struct {\n\t\t\tdig.Out\n\n\t\t\tA [7]*A `name:\"hello\"`\n\t\t}\n\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\tprovide     interface{}\n\t\t\tinvoke      interface{}\n\t\t\terrContains []string\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"value slice missing, pointer slice present\",\n\t\t\t\tprovide: func() [7]*A { return [7]*A{{}} },\n\t\t\t\tinvoke:  func([7]A) {},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\[7\\]dig_test.A \\(did you mean (to use )?\\[7\\]\\*dig_test.A\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"pointer slice missing, value slice present\",\n\t\t\t\tprovide: func() [7]A { return [7]A{{}} },\n\t\t\t\tinvoke:  func([7]*A) {},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\[7\\]\\*dig_test.A \\(did you mean (to use )?\\[7\\]dig_test.A\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"named pointer slice missing, value slice present\",\n\t\t\t\tprovide: func() outA { return outA{A: [7]A{{}}} },\n\t\t\t\tinvoke: func(struct {\n\t\t\t\t\tdig.In\n\n\t\t\t\t\tA [7]*A `name:\"hello\"`\n\t\t\t\t}) {\n\t\t\t\t},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\[7\\]\\*dig_test.A\\[name=\"hello\"\\] \\(did you mean (to use )?\\[7\\]dig_test.A\\[name=\"hello\"\\]\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"named value slice missing, pointer slice present\",\n\t\t\t\tprovide: func() outPointerA { return outPointerA{A: [7]*A{{}}} },\n\t\t\t\tinvoke: func(struct {\n\t\t\t\t\tdig.In\n\n\t\t\t\t\tA [7]A `name:\"hello\"`\n\t\t\t\t}) {\n\t\t\t\t},\n\t\t\t\terrContains: []string{\n\t\t\t\t\t`missing type:`,\n\t\t\t\t\t`\\[7\\]dig_test.A\\[name=\"hello\"\\] \\(did you mean (to use )?\\[7\\]\\*dig_test.A\\[name=\"hello\"\\]\\?\\)`,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tc.RequireProvide(tc.provide)\n\n\t\t\t\terr := c.Invoke(tc.invoke)\n\t\t\t\trequire.Error(t, err)\n\n\t\t\t\tlines := append([]string{\n\t\t\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\t}, tc.errContains...)\n\t\t\t\tdig.AssertErrorMatches(t, err,\n\t\t\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t\t\tlines...)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"requesting an interface when an implementation is available\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\t\tc.RequireProvide(bytes.NewReader)\n\t\terr := c.Invoke(func(io.Reader) {\n\t\t\tt.Fatalf(\"this function should not be called\")\n\t\t})\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing type:`,\n\t\t\t`io.Reader \\(did you mean (to use )?\\*bytes.Reader\\?\\)`,\n\t\t)\n\t})\n\n\tt.Run(\"requesting an interface when multiple implementations are available\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(bytes.NewReader)\n\t\tc.RequireProvide(bytes.NewBufferString)\n\n\t\terr := c.Invoke(func(io.Reader) {\n\t\t\tt.Fatalf(\"this function should not be called\")\n\t\t})\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing type:`,\n\t\t\t`io.Reader \\(did you mean (to use one of )?\\*bytes.Buffer, or \\*bytes.Reader\\?\\)`,\n\t\t)\n\t})\n\n\tt.Run(\"requesting multiple interfaces when multiple implementations are available\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(bytes.NewReader)\n\t\tc.RequireProvide(bytes.NewBufferString)\n\n\t\terr := c.Invoke(func(io.Reader, io.Writer) {\n\t\t\tt.Fatalf(\"this function should not be called\")\n\t\t})\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing types:`,\n\t\t\t`io.Writer \\(did you mean (to use )?\\*bytes.Buffer\\?\\)`,\n\t\t)\n\t})\n\n\tt.Run(\"requesting a type when an interface is available\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(func() io.Writer { return nil })\n\t\terr := c.Invoke(func(*bytes.Buffer) {\n\t\t\tt.Fatalf(\"this function should not be called\")\n\t\t})\n\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing type:`,\n\t\t\t`\\*bytes.Buffer \\(did you mean (to use )?io.Writer\\?\\)`,\n\t\t)\n\t})\n\n\tt.Run(\"requesting a type when multiple interfaces are available\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(func() io.Writer { return nil })\n\t\tc.RequireProvide(func() io.Reader { return nil })\n\n\t\terr := c.Invoke(func(*bytes.Buffer) {\n\t\t\tt.Fatalf(\"this function should not be called\")\n\t\t})\n\n\t\trequire.Error(t, err)\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`missing type:`,\n\t\t\t`\\*bytes.Buffer \\(did you mean (to use one of )?io.Reader, or io.Writer\\?\\)`,\n\t\t)\n\t})\n\n\tt.Run(\"direct dependency error\", func(t *testing.T) {\n\t\ttype A struct{}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(func() (A, error) {\n\t\t\treturn A{}, errors.New(\"great sadness\")\n\t\t})\n\n\t\terr := c.Invoke(func(A) { t.Fatal(\"invoke function should not be called\") })\n\n\t\trequire.Error(t, err, \"expected Invoke error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`received non-nil error from function \"go.uber.org/dig_test\".testInvokeFailures.func\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"great sadness\",\n\t\t)\n\t\tassert.Equal(t, errors.New(\"great sadness\"), dig.RootCause(err))\n\t})\n\n\tt.Run(\"transitive dependency error\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(func() (A, error) {\n\t\t\treturn A{}, errors.New(\"great sadness\")\n\t\t})\n\n\t\tc.RequireProvide(func(A) (B, error) {\n\t\t\treturn B{}, nil\n\t\t})\n\n\t\terr := c.Invoke(func(B) { t.Fatal(\"invoke function should not be called\") })\n\n\t\trequire.Error(t, err, \"expected Invoke error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t\"failed to build dig_test.B\",\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures\\S+`,\n\t\t\t\"failed to build dig_test.A\",\n\t\t\t`received non-nil error from function \"go.uber.org/dig_test\".testInvokeFailures.func\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"great sadness\",\n\t\t)\n\t\tassert.Equal(t, errors.New(\"great sadness\"), dig.RootCause(err))\n\t})\n\n\tt.Run(\"direct parameter object error\", func(t *testing.T) {\n\t\ttype A struct{}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(func() (A, error) {\n\t\t\treturn A{}, errors.New(\"great sadness\")\n\t\t})\n\n\t\ttype params struct {\n\t\t\tdig.In\n\n\t\t\tA A\n\t\t}\n\n\t\terr := c.Invoke(func(params) { t.Fatal(\"invoke function should not be called\") })\n\n\t\trequire.Error(t, err, \"expected Invoke error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures.func\\S+`,\n\t\t\t\"failed to build dig_test.A:\",\n\t\t\t`received non-nil error from function \"go.uber.org/dig_test\".testInvokeFailures.func\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"great sadness\",\n\t\t)\n\t\tassert.Equal(t, errors.New(\"great sadness\"), dig.RootCause(err))\n\t})\n\n\tt.Run(\"transitive parameter object error\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\tc.RequireProvide(func() (A, error) {\n\t\t\treturn A{}, errors.New(\"great sadness\")\n\t\t})\n\n\t\ttype params struct {\n\t\t\tdig.In\n\n\t\t\tA A\n\t\t}\n\n\t\tc.RequireProvide(func(params) (B, error) {\n\t\t\treturn B{}, nil\n\t\t})\n\n\t\terr := c.Invoke(func(B) { t.Fatal(\"invoke function should not be called\") })\n\n\t\trequire.Error(t, err, \"expected Invoke error\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures.func\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"failed to build dig_test.B:\",\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures.func\\S+`,\n\t\t\t\"failed to build dig_test.A:\",\n\t\t\t`received non-nil error from function \"go.uber.org/dig_test\".testInvokeFailures.func\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"great sadness\",\n\t\t)\n\t\tassert.Equal(t, errors.New(\"great sadness\"), dig.RootCause(err))\n\t})\n\n\tt.Run(\"unmet dependency of a group value\", func(t *testing.T) {\n\t\tc := digtest.New(t, dig.DryRun(dryRun))\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tB B `group:\"b\"`\n\t\t}\n\n\t\tc.RequireProvide(func(A) out {\n\t\t\trequire.FailNow(t, \"must not be called\")\n\t\t\treturn out{}\n\t\t})\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tBs []B `group:\"b\"`\n\t\t}\n\n\t\terr := c.Invoke(func(in) {\n\t\t\trequire.FailNow(t, \"must not be called\")\n\t\t})\n\t\trequire.Error(t, err, \"expected failure\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`could not build arguments for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`could not build value group dig_test.B\\[group=\"b\"\\]:`,\n\t\t\t`missing dependencies for function \"go.uber.org/dig_test\".testInvokeFailures.\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t\"missing type:\",\n\t\t\t\"dig_test.A\",\n\t\t)\n\t})\n}\n\nfunc TestFailingFunctionDoesNotCreateInvalidState(t *testing.T) {\n\ttype type1 struct{}\n\n\tc := digtest.New(t)\n\tc.RequireProvide(func() (type1, error) {\n\t\treturn type1{}, errors.New(\"great sadness\")\n\t})\n\n\trequire.Error(t, c.Invoke(func(type1) {\n\t\trequire.FailNow(t, \"first invoke must not call the function\")\n\t}), \"first invoke must fail\")\n\n\trequire.Error(t, c.Invoke(func(type1) {\n\t\trequire.FailNow(t, \"second invoke must not call the function\")\n\t}), \"second invoke must fail\")\n}\n\nfunc BenchmarkProvideCycleDetection(b *testing.B) {\n\t// func TestBenchmarkProvideCycleDetection(b *testing.T) {\n\ttype A struct{}\n\n\ttype B struct{}\n\ttype C struct{}\n\ttype D struct{}\n\n\ttype E struct{}\n\ttype F struct{}\n\ttype G struct{}\n\n\ttype H struct{}\n\ttype I struct{}\n\ttype J struct{}\n\n\ttype K struct{}\n\ttype L struct{}\n\ttype M struct{}\n\n\ttype N struct{}\n\ttype O struct{}\n\ttype P struct{}\n\n\ttype Q struct{}\n\ttype R struct{}\n\ttype S struct{}\n\n\ttype T struct{}\n\ttype U struct{}\n\ttype V struct{}\n\n\ttype W struct{}\n\ttype X struct{}\n\ttype Y struct{}\n\n\ttype Z struct{}\n\n\tnewA := func(*B, *C, *D) *A { return &A{} }\n\n\tnewB := func(*E, *F, *G) *B { return &B{} }\n\tnewC := func(*E, *F, *G) *C { return &C{} }\n\tnewD := func(*E, *F, *G) *D { return &D{} }\n\n\tnewE := func(*H, *I, *J) *E { return &E{} }\n\tnewF := func(*H, *I, *J) *F { return &F{} }\n\tnewG := func(*H, *I, *J) *G { return &G{} }\n\n\tnewH := func(*K, *L, *M) *H { return &H{} }\n\tnewI := func(*K, *L, *M) *I { return &I{} }\n\tnewJ := func(*K, *L, *M) *J { return &J{} }\n\n\tnewK := func(*N, *O, *P) *K { return &K{} }\n\tnewL := func(*N, *O, *P) *L { return &L{} }\n\tnewM := func(*N, *O, *P) *M { return &M{} }\n\n\tnewN := func(*Q, *R, *S) *N { return &N{} }\n\tnewO := func(*Q, *R, *S) *O { return &O{} }\n\tnewP := func(*Q, *R, *S) *P { return &P{} }\n\n\tnewQ := func(*T, *U, *V) *Q { return &Q{} }\n\tnewR := func(*T, *U, *V) *R { return &R{} }\n\tnewS := func(*T, *U, *V) *S { return &S{} }\n\n\tnewT := func(*W, *X, *Y) *T { return &T{} }\n\tnewU := func(*W, *X, *Y) *U { return &U{} }\n\tnewV := func(*W, *X, *Y) *V { return &V{} }\n\n\tnewW := func(*Z) *W { return &W{} }\n\tnewX := func(*Z) *X { return &X{} }\n\tnewY := func(*Z) *Y { return &Y{} }\n\tnewZ := func() *Z { return &Z{} }\n\n\tfor n := 0; n < b.N; n++ {\n\t\tc := digtest.New(b)\n\t\tc.Provide(newZ)\n\t\tc.Provide(newY)\n\t\tc.Provide(newX)\n\t\tc.Provide(newW)\n\t\tc.Provide(newV)\n\t\tc.Provide(newU)\n\t\tc.Provide(newT)\n\t\tc.Provide(newS)\n\t\tc.Provide(newR)\n\t\tc.Provide(newQ)\n\t\tc.Provide(newP)\n\t\tc.Provide(newO)\n\t\tc.Provide(newN)\n\t\tc.Provide(newM)\n\t\tc.Provide(newL)\n\t\tc.Provide(newK)\n\t\tc.Provide(newJ)\n\t\tc.Provide(newI)\n\t\tc.Provide(newH)\n\t\tc.Provide(newG)\n\t\tc.Provide(newF)\n\t\tc.Provide(newE)\n\t\tc.Provide(newD)\n\t\tc.Provide(newC)\n\t\tc.Provide(newB)\n\t\tc.Provide(newA)\n\t}\n}\n\nfunc TestUnexportedFieldsFailures(t *testing.T) {\n\tt.Run(\"empty tag value\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\n\t\tconstructor := func() (*type1, *type2) {\n\t\t\treturn &type1{}, &type2{}\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\ttype param struct {\n\t\t\tdig.In `ignore-unexported:\"\"`\n\n\t\t\tT1 *type1 // regular 'ol type\n\t\t\tT2 *type2 `optional:\"true\"` // optional type present in the graph\n\t\t\tt3 *type3\n\t\t}\n\n\t\tc.RequireProvide(constructor)\n\t\terr := c.Invoke(func(p param) {\n\t\t\trequire.NotNil(t, p.T1, \"whole param struct should not be nil\")\n\t\t\tassert.NotNil(t, p.T2, \"optional type in the graph should not return nil\")\n\t\t\t_ = p.t3 // unused\n\t\t})\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(),\n\t\t\t`bad argument 1: bad field \"t3\" of dig_test.param: unexported fields not allowed in dig.In, did you mean to export \"t3\" (*dig_test.type3)`)\n\t})\n\n\tt.Run(\"invalid tag value\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\t\tconstructor := func() (*type1, *type2) {\n\t\t\treturn &type1{}, &type2{}\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\ttype param struct {\n\t\t\tdig.In `ignore-unexported:\"foo\"`\n\n\t\t\tT1 *type1 // regular 'ol type\n\t\t\tT2 *type2 `optional:\"true\"` // optional type present in the graph\n\t\t\tt3 *type3\n\t\t}\n\n\t\tc.RequireProvide(constructor)\n\t\terr := c.Invoke(func(p param) {\n\t\t\trequire.NotNil(t, p.T1, \"whole param struct should not be nil\")\n\t\t\tassert.NotNil(t, p.T2, \"optional type in the graph should not return nil\")\n\t\t\t_ = p.t3\n\t\t})\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(),\n\t\t\t`bad argument 1: invalid value \"foo\" for \"ignore-unexported\" tag on field In: strconv.ParseBool: parsing \"foo\": invalid syntax`)\n\t})\n}\n\nfunc TestProvideInfoOption(t *testing.T) {\n\tt.Parallel()\n\tt.Run(\"two outputs\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\tctor := func() (*type1, *type2) {\n\t\t\treturn &type1{}, &type2{}\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tvar info dig.ProvideInfo\n\t\tc.RequireProvide(ctor, dig.FillProvideInfo(&info))\n\n\t\tassert.Empty(t, info.Inputs)\n\t\tassert.Equal(t, 2, len(info.Outputs))\n\n\t\tassert.Equal(t, \"*dig_test.type1\", info.Outputs[0].String())\n\t\tassert.Equal(t, \"*dig_test.type2\", info.Outputs[1].String())\n\t})\n\n\tt.Run(\"two inputs and one output\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\t\tctor := func(*type1, *type2) *type3 {\n\t\t\treturn &type3{}\n\t\t}\n\t\tc := digtest.New(t)\n\t\tvar info dig.ProvideInfo\n\t\tc.RequireProvide(ctor, dig.Name(\"n\"), dig.FillProvideInfo(&info))\n\n\t\tassert.Equal(t, 2, len(info.Inputs))\n\t\tassert.Equal(t, 1, len(info.Outputs))\n\n\t\tassert.Equal(t, `*dig_test.type3[name = \"n\"]`, info.Outputs[0].String())\n\t\tassert.Equal(t, \"*dig_test.type1\", info.Inputs[0].String())\n\t\tassert.Equal(t, \"*dig_test.type2\", info.Inputs[1].String())\n\t})\n\n\tt.Run(\"two inputs, output and error\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype GatewayParams struct {\n\t\t\tdig.In\n\n\t\t\tWriteToConn  *io.Writer `name:\"rw\" optional:\"true\"`\n\t\t\tReadFromConn *io.Reader `name:\"ro\"`\n\t\t\tConnNames    []string   `group:\"server\"`\n\t\t}\n\n\t\ttype type3 struct{}\n\n\t\tctor := func(*type1, GatewayParams) (*type3, error) {\n\t\t\treturn &type3{}, nil\n\t\t}\n\t\tc := digtest.New(t)\n\t\tvar info dig.ProvideInfo\n\t\tc.RequireProvide(ctor, dig.FillProvideInfo(&info))\n\n\t\tassert.Equal(t, 4, len(info.Inputs))\n\t\tassert.Equal(t, 1, len(info.Outputs))\n\n\t\tassert.Equal(t, \"*dig_test.type3\", info.Outputs[0].String())\n\t\tassert.Equal(t, \"*dig_test.type1\", info.Inputs[0].String())\n\t\tassert.Equal(t, `*io.Writer[optional, name = \"rw\"]`, info.Inputs[1].String())\n\t\tassert.Equal(t, `*io.Reader[name = \"ro\"]`, info.Inputs[2].String())\n\t\tassert.Equal(t, `[]string[group = \"server\"]`, info.Inputs[3].String())\n\t})\n\n\tt.Run(\"two inputs, two outputs\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\t\ttype type4 struct{}\n\t\tctor := func(*type1, *type2) (*type3, *type4) {\n\t\t\treturn &type3{}, &type4{}\n\t\t}\n\t\tc := digtest.New(t)\n\t\tinfo := dig.ProvideInfo{}\n\t\tc.RequireProvide(ctor, dig.Group(\"g\"), dig.FillProvideInfo(&info))\n\n\t\tassert.Equal(t, 2, len(info.Inputs))\n\t\tassert.Equal(t, 2, len(info.Outputs))\n\n\t\tassert.Equal(t, \"*dig_test.type1\", info.Inputs[0].String())\n\t\tassert.Equal(t, \"*dig_test.type2\", info.Inputs[1].String())\n\n\t\tassert.Equal(t, `*dig_test.type3[group = \"g\"]`, info.Outputs[0].String())\n\t\tassert.Equal(t, `*dig_test.type4[group = \"g\"]`, info.Outputs[1].String())\n\t})\n\n\tt.Run(\"two ctors\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\t\ttype type4 struct{}\n\t\tctor1 := func(*type1) *type2 {\n\t\t\treturn &type2{}\n\t\t}\n\t\tctor2 := func(*type3) *type4 {\n\t\t\treturn &type4{}\n\t\t}\n\t\tc := digtest.New(t)\n\t\tinfo1 := dig.ProvideInfo{}\n\t\tinfo2 := dig.ProvideInfo{}\n\t\tc.RequireProvide(ctor1, dig.FillProvideInfo(&info1))\n\t\tc.RequireProvide(ctor2, dig.FillProvideInfo(&info2))\n\n\t\tassert.NotEqual(t, info1.ID, info2.ID)\n\n\t\tassert.Equal(t, 1, len(info1.Inputs))\n\t\tassert.Equal(t, 1, len(info1.Outputs))\n\t\tassert.Equal(t, 1, len(info2.Inputs))\n\t\tassert.Equal(t, 1, len(info2.Outputs))\n\n\t\tassert.Equal(t, \"*dig_test.type1\", info1.Inputs[0].String())\n\t\tassert.Equal(t, \"*dig_test.type2\", info1.Outputs[0].String())\n\n\t\tassert.Equal(t, \"*dig_test.type3\", info2.Inputs[0].String())\n\t\tassert.Equal(t, \"*dig_test.type4\", info2.Outputs[0].String())\n\t})\n}\n\nfunc TestInvokeInfoOption(t *testing.T) {\n\tt.Parallel()\n\n\ttype type1 struct{}\n\ttype params struct {\n\t\tdig.In\n\n\t\tField1 string\n\t\tField2 int\n\t}\n\ttype type2 struct{}\n\tc := digtest.New(t)\n\tc.RequireProvide(func() map[string]string { return map[string]string{} })\n\tc.RequireProvide(func() *type1 { return &type1{} })\n\tc.RequireProvide(func() (string, int) {\n\t\treturn \"hello\", 2023\n\t})\n\tc.RequireProvide(func(s string) *type2 {\n\t\tif s == \"hello\" {\n\t\t\treturn &type2{}\n\t\t}\n\t\treturn nil\n\t})\n\n\ttests := []struct {\n\t\tdesc     string\n\t\tinvokeFn any\n\t\tnumTyps  int\n\t\twantStrs []string\n\t}{\n\t\t{\n\t\t\tdesc:     \"one map type requested\",\n\t\t\tinvokeFn: func(m map[string]string) {},\n\t\t\tnumTyps:  1,\n\t\t\twantStrs: []string{\"map[string]string\"},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"one map type, one struct type requested\",\n\t\t\tinvokeFn: func(m map[string]string, typ1 *type1) {},\n\t\t\tnumTyps:  2,\n\t\t\twantStrs: []string{\"map[string]string\", \"*dig_test.type1\"},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"invoke with param\",\n\t\t\tinvokeFn: func(p params) {},\n\t\t\tnumTyps:  2,\n\t\t\twantStrs: []string{\"string\", \"int\"},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"invoke with dependencies\",\n\t\t\tinvokeFn: func(typ2 *type2) {},\n\t\t\tnumTyps:  1,\n\t\t\twantStrs: []string{\"*dig_test.type2\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tvar info dig.InvokeInfo\n\t\tc.RequireInvoke(tt.invokeFn, dig.FillInvokeInfo(&info))\n\t\trequire.NotNil(t, info)\n\t\trequire.Len(t, info.Inputs, tt.numTyps)\n\t\tfor i := 0; i < tt.numTyps; i++ {\n\t\t\tassert.Equal(t, tt.wantStrs[i], info.Inputs[i].String())\n\t\t}\n\t}\n\n\tt.Run(\"no error on nil InvokeInfo\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() string { return \"\" })\n\t\tc.RequireInvoke(func(s string) {}, dig.FillInvokeInfo(nil))\n\t})\n}\n\nfunc TestFillInvokeInfoString(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tassert.Equal(t, \"FillInvokeInfo(0x0)\", fmt.Sprint(dig.FillInvokeInfo(nil)))\n\t})\n\n\tt.Run(\"not nil\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\topt := dig.FillInvokeInfo(new(dig.InvokeInfo))\n\t\tassert.NotEqual(t, fmt.Sprint(opt), \"FillInvokeInfo(0x0)\")\n\t\tassert.Contains(t, fmt.Sprint(opt), \"FillInvokeInfo(0x\")\n\t})\n}\n\nfunc TestEndToEndSuccessWithAliases(t *testing.T) {\n\tt.Run(\"pointer constructor\", func(t *testing.T) {\n\t\ttype Buffer = *bytes.Buffer\n\n\t\tc := digtest.New(t)\n\n\t\tvar b Buffer\n\t\tc.RequireProvide(func() *bytes.Buffer {\n\t\t\tb = &bytes.Buffer{}\n\t\t\treturn b\n\t\t})\n\n\t\tc.RequireInvoke(func(got Buffer) {\n\t\t\trequire.NotNil(t, got, \"invoke got nil buffer\")\n\t\t\trequire.True(t, got == b, \"invoke got wrong buffer\")\n\t\t})\n\t})\n\n\tt.Run(\"duplicate provide\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype B = A\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() A {\n\t\t\treturn A{}\n\t\t})\n\n\t\terr := c.Provide(func() B { return B{} })\n\t\trequire.Error(t, err, \"B should fail to provide\")\n\t\tdig.AssertErrorMatches(t, err,\n\t\t\t`cannot provide function \"go.uber.org/dig_test\".TestEndToEndSuccessWithAliases\\S+`,\n\t\t\t`dig_test.go:\\d+`, // file:line\n\t\t\t`cannot provide dig_test.A from \\[0\\]:`,\n\t\t\t`already provided by \"go.uber.org/dig_test\".TestEndToEndSuccessWithAliases\\S+`,\n\t\t)\n\t})\n\n\tt.Run(\"duplicate provide with LocationForPC\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(x int) float64 {\n\t\t\treturn testStruct{}.TestMethod(x)\n\t\t}, dig.LocationForPC(reflect.TypeOf(testStruct{}).Method(0).Func.Pointer()))\n\t\terr := c.Provide(func(x int) float64 {\n\t\t\treturn testStruct{}.TestMethod(x)\n\t\t}, dig.LocationForPC(reflect.TypeOf(testStruct{}).Method(0).Func.Pointer()))\n\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), `cannot provide function \"go.uber.org/dig_test\".testStruct.TestMethod`)\n\t\trequire.Contains(t, err.Error(), `already provided by \"go.uber.org/dig_test\".testStruct.TestMethod`)\n\t})\n\n\tt.Run(\"named instances\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ttype A1 struct{ s string }\n\t\ttype A2 = A1\n\t\ttype A3 = A2\n\n\t\ttype ret struct {\n\t\t\tdig.Out\n\n\t\t\tA A1 `name:\"a\"`\n\t\t\tB A2 `name:\"b\"`\n\t\t\tC A3 `name:\"c\"`\n\t\t}\n\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tA1 A1 `name:\"a\"`\n\t\t\tB1 A2 `name:\"b\"`\n\t\t\tC1 A3 `name:\"c\"`\n\n\t\t\tA2 A3 `name:\"a\"`\n\t\t\tB2 A1 `name:\"b\"`\n\t\t\tC2 A2 `name:\"c\"`\n\n\t\t\tA3 A2 `name:\"a\"`\n\t\t\tB3 A3 `name:\"b\"`\n\t\t\tC3 A1 `name:\"c\"`\n\t\t}\n\t\tc.RequireProvide(func() ret {\n\t\t\treturn ret{A: A2{\"a\"}, B: A3{\"b\"}, C: A1{\"c\"}}\n\t\t})\n\n\t\tc.RequireInvoke(func(p param) {\n\t\t\tassert.Equal(t, \"a\", p.A1.s, \"A1 should match\")\n\t\t\tassert.Equal(t, \"b\", p.B1.s, \"B1 should match\")\n\t\t\tassert.Equal(t, \"c\", p.C1.s, \"C1 should match\")\n\n\t\t\tassert.Equal(t, \"a\", p.A2.s, \"A2 should match\")\n\t\t\tassert.Equal(t, \"b\", p.B2.s, \"B2 should match\")\n\t\t\tassert.Equal(t, \"c\", p.C2.s, \"C2 should match\")\n\n\t\t\tassert.Equal(t, \"a\", p.A3.s, \"A3 should match\")\n\t\t\tassert.Equal(t, \"b\", p.B3.s, \"B3 should match\")\n\t\t\tassert.Equal(t, \"c\", p.C3.s, \"C3 should match\")\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 10.5087890625,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Package dig provides an opinionated way of resolving object dependencies.\n//\n// # Status\n//\n// STABLE. No breaking changes will be made in this major version.\n//\n// # Container\n//\n// Dig exposes type Container as an object capable of resolving a directed\n// acyclic dependency graph. Use the New function to create one.\n//\n//\tc := dig.New()\n//\n// # Provide\n//\n// Constructors for different types are added to the container by using the\n// Provide method. A constructor can declare a dependency on another type by\n// simply adding it as a function parameter. Dependencies for a type can be\n// added to the graph both, before and after the type was added.\n//\n//\terr := c.Provide(func(conn *sql.DB) (*UserGateway, error) {\n//\t  // ...\n//\t})\n//\tif err != nil {\n//\t  // ...\n//\t}\n//\n//\tif err := c.Provide(newDBConnection); err != nil {\n//\t  // ...\n//\t}\n//\n// Multiple constructors can rely on the same type. The container creates a\n// singleton for each retained type, instantiating it at most once when\n// requested directly or as a dependency of another type.\n//\n//\terr := c.Provide(func(conn *sql.DB) *CommentGateway {\n//\t  // ...\n//\t})\n//\tif err != nil {\n//\t  // ...\n//\t}\n//\n// Constructors can declare any number of dependencies as parameters and\n// optionally, return errors.\n//\n//\terr := c.Provide(func(u *UserGateway, c *CommentGateway) (*RequestHandler, error) {\n//\t  // ...\n//\t})\n//\tif err != nil {\n//\t  // ...\n//\t}\n//\n//\tif err := c.Provide(newHTTPServer); err != nil {\n//\t  // ...\n//\t}\n//\n// Constructors can also return multiple results to add multiple types to the\n// container.\n//\n//\terr := c.Provide(func(conn *sql.DB) (*UserGateway, *CommentGateway, error) {\n//\t  // ...\n//\t})\n//\tif err != nil {\n//\t  // ...\n//\t}\n//\n// Constructors that accept a variadic number of arguments are treated as if\n// they don't have those arguments. That is,\n//\n//\tfunc NewVoteGateway(db *sql.DB, options ...Option) *VoteGateway\n//\n// Is treated the same as,\n//\n//\tfunc NewVoteGateway(db *sql.DB) *VoteGateway\n//\n// The constructor will be called with all other dependencies and no variadic\n// arguments.\n//\n// # Invoke\n//\n// Types added to the container may be consumed by using the Invoke method.\n// Invoke accepts any function that accepts one or more parameters and\n// optionally, returns an error. Dig calls the function with the requested\n// type, instantiating only those types that were requested by the function.\n// The call fails if any type or its dependencies (both direct and transitive)\n// were not available in the container.\n//\n//\terr := c.Invoke(func(l *log.Logger) {\n//\t  // ...\n//\t})\n//\tif err != nil {\n//\t  // ...\n//\t}\n//\n//\terr := c.Invoke(func(server *http.Server) error {\n//\t  // ...\n//\t})\n//\tif err != nil {\n//\t  // ...\n//\t}\n//\n// Any error returned by the invoked function is propagated back to the\n// caller.\n//\n// # Parameter Objects\n//\n// Constructors declare their dependencies as function parameters. This can\n// very quickly become unreadable if the constructor has a lot of\n// dependencies.\n//\n//\tfunc NewHandler(users *UserGateway, comments *CommentGateway, posts *PostGateway, votes *VoteGateway, authz *AuthZGateway) *Handler {\n//\t  // ...\n//\t}\n//\n// A pattern employed to improve readability in a situation like this is to\n// create a struct that lists all the parameters of the function as fields and\n// changing the function to accept that struct instead. This is referred to as\n// a parameter object.\n//\n// Dig has first class support for parameter objects: any struct embedding\n// dig.In gets treated as a parameter object. The following is equivalent to\n// the constructor above.\n//\n//\ttype HandlerParams struct {\n//\t  dig.In\n//\n//\t  Users    *UserGateway\n//\t  Comments *CommentGateway\n//\t  Posts    *PostGateway\n//\t  Votes    *VoteGateway\n//\t  AuthZ    *AuthZGateway\n//\t}\n//\n//\tfunc NewHandler(p HandlerParams) *Handler {\n//\t  // ...\n//\t}\n//\n// Handlers can receive any combination of parameter objects and parameters.\n//\n//\tfunc NewHandler(p HandlerParams, l *log.Logger) *Handler {\n//\t  // ...\n//\t}\n//\n// # Result Objects\n//\n// Result objects are the flip side of parameter objects. These are structs\n// that represent multiple outputs from a single function as fields in the\n// struct. Structs embedding dig.Out get treated as result objects.\n//\n//\tfunc SetupGateways(conn *sql.DB) (*UserGateway, *CommentGateway, *PostGateway, error) {\n//\t  // ...\n//\t}\n//\n// The above is equivalent to,\n//\n//\ttype Gateways struct {\n//\t  dig.Out\n//\n//\t  Users    *UserGateway\n//\t  Comments *CommentGateway\n//\t  Posts    *PostGateway\n//\t}\n//\n//\tfunc SetupGateways(conn *sql.DB) (Gateways, error) {\n//\t  // ...\n//\t}\n//\n// # Optional Dependencies\n//\n// Constructors often don't have a hard dependency on some types and\n// are able to operate in a degraded state when that dependency is missing.\n// Dig supports declaring dependencies as optional by adding an\n// `optional:\"true\"` tag to fields of a dig.In struct.\n//\n// Fields in a dig.In structs that have the `optional:\"true\"` tag are treated\n// as optional by Dig.\n//\n//\ttype UserGatewayParams struct {\n//\t  dig.In\n//\n//\t  Conn  *sql.DB\n//\t  Cache *redis.Client `optional:\"true\"`\n//\t}\n//\n// If an optional field is not available in the container, the constructor\n// will receive a zero value for the field.\n//\n//\tfunc NewUserGateway(p UserGatewayParams, log *log.Logger) (*UserGateway, error) {\n//\t  if p.Cache == nil {\n//\t    log.Print(\"Caching disabled\")\n//\t  }\n//\t  // ...\n//\t}\n//\n// Constructors that declare dependencies as optional MUST handle the case of\n// those dependencies being absent.\n//\n// The optional tag also allows adding new dependencies without breaking\n// existing consumers of the constructor.\n//\n// # Named Values\n//\n// Some use cases call for multiple values of the same type. Dig allows adding\n// multiple values of the same type to the container with the use of Named\n// Values.\n//\n// Named Values can be produced by passing the dig.Name option when a\n// constructor is provided. All values produced by that constructor will have\n// the given name.\n//\n// Given the following constructors,\n//\n//\tfunc NewReadOnlyConnection(...) (*sql.DB, error)\n//\tfunc NewReadWriteConnection(...) (*sql.DB, error)\n//\n// You can provide *sql.DB into a Container under different names by passing\n// the dig.Name option.\n//\n//\tc.Provide(NewReadOnlyConnection, dig.Name(\"ro\"))\n//\tc.Provide(NewReadWriteConnection, dig.Name(\"rw\"))\n//\n// Alternatively, you can produce a dig.Out struct and tag its fields with\n// `name:\"..\"` to have the corresponding value added to the graph under the\n// specified name.\n//\n//\ttype ConnectionResult struct {\n//\t  dig.Out\n//\n//\t  ReadWrite *sql.DB `name:\"rw\"`\n//\t  ReadOnly  *sql.DB `name:\"ro\"`\n//\t}\n//\n//\tfunc ConnectToDatabase(...) (ConnectionResult, error) {\n//\t  // ...\n//\t  return ConnectionResult{ReadWrite: rw, ReadOnly:  ro}, nil\n//\t}\n//\n// Regardless of how a Named Value was produced, it can be consumed by another\n// constructor by accepting a dig.In struct which has exported fields with the\n// same name AND type that you provided.\n//\n//\ttype GatewayParams struct {\n//\t  dig.In\n//\n//\t  WriteToConn  *sql.DB `name:\"rw\"`\n//\t  ReadFromConn *sql.DB `name:\"ro\"`\n//\t}\n//\n// The name tag may be combined with the optional tag to declare the\n// dependency optional.\n//\n//\ttype GatewayParams struct {\n//\t  dig.In\n//\n//\t  WriteToConn  *sql.DB `name:\"rw\"`\n//\t  ReadFromConn *sql.DB `name:\"ro\" optional:\"true\"`\n//\t}\n//\n//\tfunc NewCommentGateway(p GatewayParams, log *log.Logger) (*CommentGateway, error) {\n//\t  if p.ReadFromConn == nil {\n//\t    log.Print(\"Warning: Using RW connection for reads\")\n//\t    p.ReadFromConn = p.WriteToConn\n//\t  }\n//\t  // ...\n//\t}\n//\n// # Value Groups\n//\n// Added in Dig 1.2.\n//\n// Dig provides value groups to allow producing and consuming many values of\n// the same type. Value groups allow constructors to send values to a named,\n// unordered collection in the container. Other constructors can request all\n// values in this collection as a slice.\n//\n// Constructors can send values into value groups by returning a dig.Out\n// struct tagged with `group:\"..\"`.\n//\n//\ttype HandlerResult struct {\n//\t  dig.Out\n//\n//\t  Handler Handler `group:\"server\"`\n//\t}\n//\n//\tfunc NewHelloHandler() HandlerResult {\n//\t  ..\n//\t}\n//\n//\tfunc NewEchoHandler() HandlerResult {\n//\t  ..\n//\t}\n//\n// Any number of constructors may provide values to this named collection.\n// Other constructors can request all values for this collection by requesting\n// a slice tagged with `group:\"..\"`. This will execute all constructors that\n// provide a value to that group in an unspecified order.\n//\n//\ttype ServerParams struct {\n//\t  dig.In\n//\n//\t  Handlers []Handler `group:\"server\"`\n//\t}\n//\n//\tfunc NewServer(p ServerParams) *Server {\n//\t  server := newServer()\n//\t  for _, h := range p.Handlers {\n//\t    server.Register(h)\n//\t  }\n//\t  return server\n//\t}\n//\n// Note that values in a value group are unordered. Dig makes no guarantees\n// about the order in which these values will be produced.\n//\n// Value groups can be used to provide multiple values for a group from a\n// dig.Out using slices, however considering groups are retrieved by requesting\n// a slice this implies that the values must be retrieved using a slice of\n// slices. As of dig v1.9.0, if you want to provide individual elements to the\n// group instead of the slice itself, you can add the `flatten` modifier to the\n// group from a dig.Out.\n//\n//\ttype IntResult struct {\n//\t  dig.Out\n//\n//\t  Handler []int `group:\"server\"`         // [][]int from dig.In\n//\t  Handler []int `group:\"server,flatten\"` // []int from dig.In\n//\t}\npackage dig // import \"go.uber.org/dig\"\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 14.509765625,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"sort\"\n\n\t\"go.uber.org/dig/internal/digreflect\"\n\t\"go.uber.org/dig/internal/dot\"\n)\n\n// Error is an interface implemented by all Dig errors.\n//\n// Use this interface, in conjunction with [RootCause], in order to\n// determine if errors you encounter come from Dig, or if they come\n// from provided constructors or invoked functions. See [RootCause]\n// for more info.\ntype Error interface {\n\terror\n\n\t// Writes the message or context for this error in the chain.\n\t//\n\t// Note: the Error interface must always have a private function\n\t// such as this one in order to maintain properly sealed.\n\t//\n\t// verb is either %v or %+v.\n\twriteMessage(w io.Writer, v string)\n}\n\n// a digError is a dig.Error with additional functionality for\n// internal use - namely the ability to be formatted.\ntype digError interface {\n\tError\n\tfmt.Formatter\n}\n\n// A PanicError occurs when a panic occurs while running functions given to the container\n// with the [RecoverFromPanic] option being set. It contains the panic message from the\n// original panic. A PanicError does not wrap other errors, and it does not implement\n// dig.Error, meaning it will be returned from [RootCause]. With the [RecoverFromPanic]\n// option set, a panic can be distinguished from dig errors and errors from provided/\n// invoked/decorated functions like so:\n//\n//\trootCause := dig.RootCause(err)\n//\n//\tvar pe dig.PanicError\n//\tvar de dig.Error\n//\tif errors.As(rootCause, &pe) {\n//\t\t// This is caused by a panic\n//\t} else if errors.As(err, &de) {\n//\t\t// This is a dig error\n//\t} else {\n//\t\t// This is an error from one of my provided/invoked functions or decorators\n//\t}\n//\n// Or, if only interested in distinguishing panics from errors:\n//\n//\tvar pe dig.PanicError\n//\tif errors.As(err, &pe) {\n//\t\t// This is caused by a panic\n//\t} else {\n//\t\t// This is an error\n//\t}\ntype PanicError struct {\n\t// The function the panic occurred at\n\tfn *digreflect.Func\n\n\t// The panic that was returned from recover()\n\tPanic any\n}\n\n// Format will format the PanicError, expanding the corresponding function if in +v mode.\nfunc (e PanicError) Format(w fmt.State, c rune) {\n\tif w.Flag('+') && c == 'v' {\n\t\tfmt.Fprintf(w, \"panic: %q in func: %+v\", e.Panic, e.fn)\n\t} else {\n\t\tfmt.Fprintf(w, \"panic: %q in func: %v\", e.Panic, e.fn)\n\t}\n}\n\nfunc (e PanicError) Error() string {\n\treturn fmt.Sprint(e)\n}\n\n// formatError will call a dig.Error's writeMessage() method to print the error message\n// and then will automatically attempt to print errors wrapped underneath (which can create\n// a recursive effect if the wrapped error's Format() method then points back to this function).\nfunc formatError(e digError, w fmt.State, v rune) {\n\tmultiline := w.Flag('+') && v == 'v'\n\tverb := \"%v\"\n\tif multiline {\n\t\tverb = \"%+v\"\n\t}\n\n\t// \"context: \" or \"context:\\n\"\n\te.writeMessage(w, verb)\n\n\t// Will route back to this function recursively if next error\n\t// is also wrapped and points back here\n\twrappedError := errors.Unwrap(e)\n\tif wrappedError == nil {\n\t\treturn\n\t}\n\tio.WriteString(w, \":\")\n\tif multiline {\n\t\tio.WriteString(w, \"\\n\")\n\t} else {\n\t\tio.WriteString(w, \" \")\n\t}\n\tfmt.Fprintf(w, verb, wrappedError)\n}\n\n// RootCause returns the first non-dig.Error in a chain of wrapped\n// errors, if there is one. Otherwise, RootCause returns the error\n// on the bottom of the chain of wrapped errors.\n//\n// Use this function and errors.As to differentiate between Dig errors\n// and errors thrown by provided constructors or invoked functions:\n//\n//\trootCause := dig.RootCause(err)\n//\tvar de dig.Error\n//\tif errors.As(rootCause, &de) {\n//\t    // Is a Dig error\n//\t} else {\n//\t    // Is an error thrown by one of my provided/invoked/decorated functions\n//\t}\n//\n// See [PanicError] for an example showing how to additionally detect\n// and handle panics in provided/invoked/decorated functions.\nfunc RootCause(err error) error {\n\tvar de Error\n\t// Dig down to first non dig.Error, or bottom of chain\n\tfor ; errors.As(err, &de); err = errors.Unwrap(de) {\n\t}\n\n\tif err == nil {\n\t\treturn de\n\t}\n\n\treturn err\n}\n\n// errInvalidInput is returned whenever the user provides bad input when\n// interacting with the container. May optionally have a more detailed\n// error wrapped underneath.\ntype errInvalidInput struct {\n\tMessage string\n\tCause   error\n}\n\nvar _ digError = errInvalidInput{}\n\n// newErrInvalidInput creates a new errInvalidInput, wrapping the given\n// other error that caused this error. If there is no underlying cause,\n// pass in nil. This will cause all attempts to unwrap this error to return\n// nil, replicating errors.Unwrap's behavior when passed an error without\n// an Unwrap() method.\nfunc newErrInvalidInput(msg string, cause error) errInvalidInput {\n\treturn errInvalidInput{msg, cause}\n}\n\nfunc (e errInvalidInput) Error() string { return fmt.Sprint(e) }\n\nfunc (e errInvalidInput) Unwrap() error { return e.Cause }\n\nfunc (e errInvalidInput) writeMessage(w io.Writer, _ string) {\n\tfmt.Fprint(w, e.Message)\n}\n\nfunc (e errInvalidInput) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\n// errProvide is returned when a constructor could not be Provided into the\n// container.\ntype errProvide struct {\n\tFunc   *digreflect.Func\n\tReason error\n}\n\nvar _ digError = errProvide{}\n\nfunc (e errProvide) Error() string { return fmt.Sprint(e) }\n\nfunc (e errProvide) Unwrap() error { return e.Reason }\n\nfunc (e errProvide) writeMessage(w io.Writer, verb string) {\n\tfmt.Fprintf(w, \"cannot provide function \"+verb, e.Func)\n}\n\nfunc (e errProvide) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\n// errConstructorFailed is returned when a user-provided constructor failed\n// with a non-nil error.\ntype errConstructorFailed struct {\n\tFunc   *digreflect.Func\n\tReason error\n}\n\nvar _ digError = errConstructorFailed{}\n\nfunc (e errConstructorFailed) Error() string { return fmt.Sprint(e) }\n\nfunc (e errConstructorFailed) Unwrap() error { return e.Reason }\n\nfunc (e errConstructorFailed) writeMessage(w io.Writer, verb string) {\n\tfmt.Fprintf(w, \"received non-nil error from function \"+verb, e.Func)\n}\n\nfunc (e errConstructorFailed) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\n// errArgumentsFailed is returned when a function could not be run because one\n// of its dependencies failed to build for any reason.\ntype errArgumentsFailed struct {\n\tFunc   *digreflect.Func\n\tReason error\n}\n\nvar _ digError = errArgumentsFailed{}\n\nfunc (e errArgumentsFailed) Error() string { return fmt.Sprint(e) }\n\nfunc (e errArgumentsFailed) Unwrap() error { return e.Reason }\n\nfunc (e errArgumentsFailed) writeMessage(w io.Writer, verb string) {\n\tfmt.Fprintf(w, \"could not build arguments for function \"+verb, e.Func)\n}\n\nfunc (e errArgumentsFailed) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\n// errMissingDependencies is returned when the dependencies of a function are\n// not available in the container.\ntype errMissingDependencies struct {\n\tFunc   *digreflect.Func\n\tReason error\n}\n\nvar _ digError = errMissingDependencies{}\n\nfunc (e errMissingDependencies) Error() string { return fmt.Sprint(e) }\n\nfunc (e errMissingDependencies) Unwrap() error { return e.Reason }\n\nfunc (e errMissingDependencies) writeMessage(w io.Writer, verb string) {\n\tfmt.Fprintf(w, \"missing dependencies for function \"+verb, e.Func)\n}\n\nfunc (e errMissingDependencies) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\n// errParamSingleFailed is returned when a paramSingle could not be built.\ntype errParamSingleFailed struct {\n\tKey    key\n\tReason error\n\tCtorID dot.CtorID\n}\n\nvar _ digError = errParamSingleFailed{}\n\nfunc (e errParamSingleFailed) Error() string { return fmt.Sprint(e) }\n\nfunc (e errParamSingleFailed) Unwrap() error { return e.Reason }\n\nfunc (e errParamSingleFailed) writeMessage(w io.Writer, _ string) {\n\tfmt.Fprintf(w, \"failed to build %v\", e.Key)\n}\n\nfunc (e errParamSingleFailed) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\nfunc (e errParamSingleFailed) updateGraph(g *dot.Graph) {\n\tfailed := &dot.Result{\n\t\tNode: &dot.Node{\n\t\t\tName:  e.Key.name,\n\t\t\tGroup: e.Key.group,\n\t\t\tType:  e.Key.t,\n\t\t},\n\t}\n\tg.FailNodes([]*dot.Result{failed}, e.CtorID)\n}\n\n// errParamGroupFailed is returned when a value group cannot be built because\n// any of the values in the group failed to build.\ntype errParamGroupFailed struct {\n\tKey    key\n\tReason error\n\tCtorID dot.CtorID\n}\n\nvar _ digError = errParamGroupFailed{}\n\nfunc (e errParamGroupFailed) Error() string { return fmt.Sprint(e) }\n\nfunc (e errParamGroupFailed) Unwrap() error { return e.Reason }\n\nfunc (e errParamGroupFailed) writeMessage(w io.Writer, _ string) {\n\tfmt.Fprintf(w, \"could not build value group %v\", e.Key)\n}\n\nfunc (e errParamGroupFailed) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\nfunc (e errParamGroupFailed) updateGraph(g *dot.Graph) {\n\tg.FailGroupNodes(e.Key.group, e.Key.t, e.CtorID)\n}\n\n// missingType holds information about a type that was missing in the\n// container.\ntype missingType struct {\n\tKey key // item that was missing\n\n\t// If non-empty, we will include suggestions for what the user may have\n\t// meant.\n\tsuggestions []key\n}\n\n// Format prints a string representation of missingType.\n//\n// With %v, it prints a short representation ideal for an itemized list.\n//\n//\tio.Writer\n//\tio.Writer: did you mean *bytes.Buffer?\n//\tio.Writer: did you mean *bytes.Buffer, or *os.File?\n//\n// With %+v, it prints a longer representation ideal for standalone output.\n//\n//\tio.Writer: did you mean to Provide it?\n//\tio.Writer: did you mean to use *bytes.Buffer?\n//\tio.Writer: did you mean to use one of *bytes.Buffer, or *os.File?\nfunc (mt missingType) Format(w fmt.State, v rune) {\n\tplusV := w.Flag('+') && v == 'v'\n\n\tfmt.Fprint(w, mt.Key)\n\tswitch len(mt.suggestions) {\n\tcase 0:\n\t\tif plusV {\n\t\t\tio.WriteString(w, \" (did you mean to Provide it?)\")\n\t\t}\n\tcase 1:\n\t\tsug := mt.suggestions[0]\n\t\tif plusV {\n\t\t\tfmt.Fprintf(w, \" (did you mean to use %v?)\", sug)\n\t\t} else {\n\t\t\tfmt.Fprintf(w, \" (did you mean %v?)\", sug)\n\t\t}\n\tdefault:\n\t\tif plusV {\n\t\t\tio.WriteString(w, \" (did you mean to use one of \")\n\t\t} else {\n\t\t\tio.WriteString(w, \" (did you mean \")\n\t\t}\n\n\t\tlastIdx := len(mt.suggestions) - 1\n\t\tfor i, sug := range mt.suggestions {\n\t\t\tif i > 0 {\n\t\t\t\tio.WriteString(w, \", \")\n\t\t\t\tif i == lastIdx {\n\t\t\t\t\tio.WriteString(w, \"or \")\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Fprint(w, sug)\n\t\t}\n\t\tio.WriteString(w, \"?)\")\n\t}\n}\n\n// errMissingType is returned when one or more values that were expected in\n// the container were not available.\n//\n// Multiple instances of this error may be merged together by appending them.\ntype errMissingTypes []missingType // inv: len > 0\n\nvar _ digError = errMissingTypes(nil)\n\nfunc newErrMissingTypes(c containerStore, k key) errMissingTypes {\n\t// Possible types we will look for in the container. We will always look\n\t// for pointers to the requested type and some extras on a per-Kind basis.\n\tsuggestions := []reflect.Type{reflect.PointerTo(k.t)}\n\n\tif k.t.Kind() == reflect.Ptr {\n\t\t// The user requested a pointer but maybe we have a value.\n\t\tsuggestions = append(suggestions, k.t.Elem())\n\t}\n\n\tif k.t.Kind() == reflect.Slice {\n\t\t// Maybe the user meant a slice of pointers while we have the slice of elements\n\t\tsuggestions = append(suggestions, reflect.SliceOf(reflect.PointerTo(k.t.Elem())))\n\n\t\t// Maybe the user meant a slice of elements while we have the slice of pointers\n\t\tsliceElement := k.t.Elem()\n\t\tif sliceElement.Kind() == reflect.Ptr {\n\t\t\tsuggestions = append(suggestions, reflect.SliceOf(sliceElement.Elem()))\n\t\t}\n\t}\n\n\tif k.t.Kind() == reflect.Array {\n\t\t// Maybe the user meant an array of pointers while we have the array of elements\n\t\tsuggestions = append(suggestions, reflect.ArrayOf(k.t.Len(), reflect.PointerTo(k.t.Elem())))\n\n\t\t// Maybe the user meant an array of elements while we have the array of pointers\n\t\tarrayElement := k.t.Elem()\n\t\tif arrayElement.Kind() == reflect.Ptr {\n\t\t\tsuggestions = append(suggestions, reflect.ArrayOf(k.t.Len(), arrayElement.Elem()))\n\t\t}\n\t}\n\n\tknownTypes := c.knownTypes()\n\tif k.t.Kind() == reflect.Interface {\n\t\t// Maybe we have an implementation of the interface.\n\t\tfor _, t := range knownTypes {\n\t\t\tif t.Implements(k.t) {\n\t\t\t\tsuggestions = append(suggestions, t)\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Maybe we have an interface that this type implements.\n\t\tfor _, t := range knownTypes {\n\t\t\tif t.Kind() == reflect.Interface {\n\t\t\t\tif k.t.Implements(t) {\n\t\t\t\t\tsuggestions = append(suggestions, t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// range through c.providers is non-deterministic. Let's sort the list of\n\t// suggestions.\n\tsort.Sort(byTypeName(suggestions))\n\n\tmt := missingType{Key: k}\n\tfor _, t := range suggestions {\n\t\tif len(c.getValueProviders(k.name, t)) > 0 {\n\t\t\tk.t = t\n\t\t\tmt.suggestions = append(mt.suggestions, k)\n\t\t}\n\t}\n\n\treturn errMissingTypes{mt}\n}\n\nfunc (e errMissingTypes) Error() string { return fmt.Sprint(e) }\n\nfunc (e errMissingTypes) writeMessage(w io.Writer, v string) {\n\tmultiline := v == \"%+v\"\n\n\tif len(e) == 1 {\n\t\tio.WriteString(w, \"missing type:\")\n\t} else {\n\t\tio.WriteString(w, \"missing types:\")\n\t}\n\n\tif !multiline {\n\t\t// With %v, we need a space between : since the error\n\t\t// won't be on a new line.\n\t\tio.WriteString(w, \" \")\n\t}\n\n\tfor i, mt := range e {\n\t\tif multiline {\n\t\t\tio.WriteString(w, \"\\n\\t- \")\n\t\t} else if i > 0 {\n\t\t\tio.WriteString(w, \"; \")\n\t\t}\n\n\t\tif multiline {\n\t\t\tfmt.Fprintf(w, \"%+v\", mt)\n\t\t} else {\n\t\t\tfmt.Fprintf(w, \"%v\", mt)\n\t\t}\n\t}\n}\n\nfunc (e errMissingTypes) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\nfunc (e errMissingTypes) updateGraph(g *dot.Graph) {\n\tmissing := make([]*dot.Result, len(e))\n\n\tfor i, mt := range e {\n\t\tmissing[i] = &dot.Result{\n\t\t\tNode: &dot.Node{\n\t\t\t\tName:  mt.Key.name,\n\t\t\t\tGroup: mt.Key.group,\n\t\t\t\tType:  mt.Key.t,\n\t\t\t},\n\t\t}\n\t}\n\tg.AddMissingNodes(missing)\n}\n\ntype errVisualizer interface {\n\tupdateGraph(*dot.Graph)\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 15.5927734375,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/dig/internal/digreflect\"\n)\n\n// assertErrorMatches matches error messages against the provided list of\n// strings.\n//\n// The error must match each string in-order. That is, the following is valid,\n//\n//\tassertErrorMatches(t, errors.New(\"foo bar baz\"), \"foo\", \"baz\")\n//\n// But not,\n//\n//\tassertErrorMatches(t, errors.New(\"foo bar baz\"), \"foo\", \"baz\", \"bar\")\n//\n// Because \"bar\" is not after \"baz\" in the error message.\n//\n// Messages will be treated as regular expressions.\nfunc AssertErrorMatches(t *testing.T, err error, msg string, msgs ...string) {\n\tt.Helper()\n\n\t// We have one positional argument in addition to the variadic argument to\n\t// ensure that there's at least one string to match against.\n\tif err == nil {\n\t\tt.Errorf(\"expected error but got nil\")\n\t\treturn\n\t}\n\n\tvar finders []consumingFinder\n\tfor _, m := range append([]string{msg}, msgs...) {\n\t\tif r, err := regexp.Compile(m); err == nil {\n\t\t\tfinders = append(finders, regexpFinder{r})\n\t\t} else {\n\t\t\tfinders = append(finders, stringFinder(m))\n\t\t}\n\t}\n\n\tt.Run(\"single line\", func(t *testing.T) {\n\t\toriginal := err.Error()\n\t\tassert.NoError(t, runFinders(original, finders))\n\t})\n\n\t// Intersperse \"\\n\" finders between each message for the \"%+v\" check.\n\tplusFinders := make([]consumingFinder, 0, len(finders)*2-1)\n\tfor i, f := range finders {\n\t\tif i > 0 {\n\t\t\tplusFinders = append(plusFinders, stringFinder(\"\\n\"))\n\t\t}\n\t\tplusFinders = append(plusFinders, f)\n\t}\n\n\tt.Run(\"multi line\", func(t *testing.T) {\n\t\toriginal := fmt.Sprintf(\"%+v\", err)\n\t\tassert.NoError(t, runFinders(original, plusFinders))\n\t})\n}\n\n// consumingFinder matches a string and returns the rest of the string *after*\n// the match.\ntype consumingFinder interface {\n\t// Attempt to match against the given string and return false if a match\n\t// could not be found.\n\t//\n\t// If a match was found, return the remaining string after the entire\n\t// match. So if the finder matches \"oo\" in \"foobar\", the returned string\n\t// must be just \"bar\".\n\tFind(got string) (rest string, ok bool)\n}\n\nfunc runFinders(original string, finders []consumingFinder) error {\n\tremaining := original\n\tfor _, f := range finders {\n\t\tif newRemaining, ok := f.Find(remaining); ok {\n\t\t\tremaining = newRemaining\n\t\t\tcontinue\n\t\t}\n\n\t\t// Match not found. Check if the order was wrong.\n\t\tif _, ok := f.Find(original); ok {\n\t\t\t// We won't use %q for the error message itself\n\t\t\t// because we want it to be printed to the console as\n\t\t\t// it would actually show.\n\t\t\treturn fmt.Errorf(`\"%v\" contains %v in the wrong place`, original, f)\n\t\t}\n\t\treturn fmt.Errorf(`\"%v\" does not contain %v`, original, f)\n\t}\n\treturn nil\n}\n\ntype regexpFinder struct{ r *regexp.Regexp }\n\nfunc (r regexpFinder) String() string {\n\treturn \"`\" + r.r.String() + \"`\"\n}\n\nfunc (r regexpFinder) Find(got string) (rest string, ok bool) {\n\tloc := r.r.FindStringIndex(got)\n\tif len(loc) == 0 {\n\t\treturn got, false\n\t}\n\treturn got[loc[1]:], true\n}\n\ntype stringFinder string\n\nfunc (s stringFinder) String() string { return strconv.Quote(string(s)) }\n\nfunc (s stringFinder) Find(got string) (rest string, ok bool) {\n\ti := strings.Index(got, string(s))\n\tif i < 0 {\n\t\treturn got, false\n\t}\n\treturn got[i+len(s):], true\n}\n\nfunc TestRootCause(t *testing.T) {\n\ttests := []struct {\n\t\tdesc                    string\n\t\tgive                    error\n\t\twantAsDigError          bool\n\t\twantRootCause           error\n\t\twantRootCauseAsDigError bool\n\t}{\n\t\t{\n\t\t\tdesc:                    \"random unformatted error\",\n\t\t\tgive:                    errors.New(\"This non-Dig error is not formatted\"),\n\t\t\twantAsDigError:          false,\n\t\t\twantRootCause:           errors.New(\"This non-Dig error is not formatted\"),\n\t\t\twantRootCauseAsDigError: false,\n\t\t},\n\t\t{\n\t\t\tdesc:                    \"random formatted error\",\n\t\t\tgive:                    fmt.Errorf(\"This non-Dig error is %v\", \"formatted\"),\n\t\t\twantAsDigError:          false,\n\t\t\twantRootCause:           fmt.Errorf(\"This non-Dig error is %v\", \"formatted\"),\n\t\t\twantRootCauseAsDigError: false,\n\t\t},\n\t\t{\n\t\t\tdesc:                    \"simple errInvalidInput\",\n\t\t\tgive:                    errInvalidInput{Message: \"baz\", Cause: nil},\n\t\t\twantAsDigError:          true,\n\t\t\twantRootCause:           errInvalidInput{Message: \"baz\", Cause: nil},\n\t\t\twantRootCauseAsDigError: true,\n\t\t},\n\t\t{\n\t\t\tdesc:                    \"errInvalidInput wrapping errInvalidInput\",\n\t\t\tgive:                    errInvalidInput{Message: \"foo\", Cause: errInvalidInput{Message: \"bar\", Cause: nil}},\n\t\t\twantAsDigError:          true,\n\t\t\twantRootCause:           errInvalidInput{Message: \"bar\", Cause: nil},\n\t\t\twantRootCauseAsDigError: true,\n\t\t},\n\t\t{\n\t\t\tdesc:                    \"errInvalidInput wrapping non-dig.Error\",\n\t\t\tgive:                    errInvalidInput{Message: \"foo\", Cause: errors.New(\"bar\")},\n\t\t\twantAsDigError:          true,\n\t\t\twantRootCause:           errors.New(\"bar\"),\n\t\t\twantRootCauseAsDigError: false,\n\t\t},\n\t\t{\n\t\t\tdesc:                    \"nil\",\n\t\t\tgive:                    nil,\n\t\t\twantAsDigError:          false,\n\t\t\twantRootCause:           nil,\n\t\t\twantRootCauseAsDigError: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tvar de Error\n\t\t\tassert.Equal(t, tt.wantAsDigError, errors.As(tt.give, &de))\n\t\t\tgotRootCause := RootCause(tt.give)\n\t\t\tassert.Equal(t, gotRootCause, tt.wantRootCause)\n\t\t\tassert.Equal(t, tt.wantRootCause, gotRootCause, \"incorrect root cause\")\n\t\t\tassert.Equal(t, tt.wantRootCauseAsDigError, errors.As(gotRootCause, &de))\n\t\t})\n\t}\n}\n\ntype MyNonDigError struct {\n\tmsg string\n}\n\nfunc (e MyNonDigError) Error() string {\n\treturn e.msg\n}\n\nfunc TestRootCauseEndToEnd(t *testing.T) {\n\ttests := []struct {\n\t\tdesc                    string\n\t\tsetup                   func(c *Container)\n\t\tinvoke                  interface{}\n\t\twantAsDigError          bool\n\t\twantRootCauseMessage    string\n\t\twantRootCauseAsDigError bool\n\t}{\n\t\t{\n\t\t\tdesc: \"error thrown in constructor\",\n\t\t\tsetup: func(c *Container) {\n\t\t\t\tassert.NoError(t, c.Provide(func() (string, error) {\n\t\t\t\t\treturn \"hello\", MyNonDigError{msg: \"great sadness\"}\n\t\t\t\t}))\n\t\t\t},\n\t\t\tinvoke: func(s string) {\n\t\t\t\tfmt.Println(s)\n\t\t\t},\n\t\t\twantAsDigError:          true,\n\t\t\twantRootCauseMessage:    \"great sadness\",\n\t\t\twantRootCauseAsDigError: false,\n\t\t},\n\t\t{\n\t\t\tdesc: \"parameter not available in container\",\n\t\t\tsetup: func(c *Container) {\n\t\t\t\tassert.NoError(t, c.Provide(func() int { return 5 }))\n\t\t\t},\n\t\t\tinvoke: func(s string) {\n\t\t\t\tfmt.Println(s)\n\t\t\t},\n\t\t\twantAsDigError:          true,\n\t\t\twantRootCauseMessage:    \"missing type: string\",\n\t\t\twantRootCauseAsDigError: true,\n\t\t},\n\t\t{\n\t\t\tdesc: \"error in invoke\",\n\t\t\tsetup: func(c *Container) {\n\t\t\t\tassert.NoError(t, c.Provide(func() (string, error) {\n\t\t\t\t\treturn \"hello\", nil\n\t\t\t\t}))\n\t\t\t},\n\t\t\tinvoke: func(s string) error {\n\t\t\t\treturn errors.New(\"terrible unhappiness\")\n\t\t\t},\n\t\t\twantAsDigError:          false,\n\t\t\twantRootCauseMessage:    \"terrible unhappiness\",\n\t\t\twantRootCauseAsDigError: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc := New()\n\t\ttt.setup(c)\n\t\tvar de Error\n\t\terr := c.Invoke(tt.invoke)\n\t\tassert.Equal(t, tt.wantAsDigError, errors.As(err, &de),\n\t\t\tfmt.Sprintf(\"expected errors.As() to return %v\", tt.wantAsDigError))\n\t\trcErr := RootCause(err)\n\t\tassert.Equal(t, tt.wantRootCauseMessage, rcErr.Error())\n\t\tassert.Equal(t, tt.wantRootCauseAsDigError, errors.As(rcErr, &de),\n\t\t\tfmt.Sprintf(\"expected errors.As() on the root cause to return %v\", tt.wantRootCauseAsDigError))\n\t}\n}\n\nfunc joinLines(ls ...string) string { return strings.Join(ls, \"\\n\") }\n\n// Simple error fake that provides control of %v and %+v representations.\ntype errFormatted struct {\n\tv     string //  output for %v\n\tplusV string // output for %+v\n}\n\nvar (\n\t_ error         = errFormatted{}\n\t_ fmt.Formatter = errFormatted{}\n)\n\nfunc (e errFormatted) Error() string { return e.v }\n\nfunc (e errFormatted) Format(w fmt.State, c rune) {\n\tif w.Flag('+') && c == 'v' {\n\t\tio.WriteString(w, e.plusV)\n\t} else {\n\t\tio.WriteString(w, e.v)\n\t}\n}\n\nfunc TestMissingTypeFormatting(t *testing.T) {\n\ttype type1 struct{}\n\ttype someInterface interface{ stuff() }\n\n\ttests := []struct {\n\t\tdesc      string\n\t\tgive      missingType\n\t\twantV     string\n\t\twantPlusV string\n\t}{\n\t\t{\n\t\t\tdesc: \"no suggestions\",\n\t\t\tgive: missingType{\n\t\t\t\tKey: key{t: reflect.TypeOf(type1{})},\n\t\t\t},\n\t\t\twantV:     \"dig.type1\",\n\t\t\twantPlusV: \"dig.type1 (did you mean to Provide it?)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"one suggestion\",\n\t\t\tgive: missingType{\n\t\t\t\tKey: key{t: reflect.TypeOf(type1{})},\n\t\t\t\tsuggestions: []key{\n\t\t\t\t\t{t: reflect.TypeOf(&type1{})},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantV:     \"dig.type1 (did you mean *dig.type1?)\",\n\t\t\twantPlusV: \"dig.type1 (did you mean to use *dig.type1?)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"many suggestions\",\n\t\t\tgive: missingType{\n\t\t\t\tKey: key{t: reflect.TypeOf(type1{})},\n\t\t\t\tsuggestions: []key{\n\t\t\t\t\t{t: reflect.TypeOf(&type1{})},\n\t\t\t\t\t{t: reflect.TypeOf(new(someInterface)).Elem()},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantV:     \"dig.type1 (did you mean *dig.type1, or dig.someInterface?)\",\n\t\t\twantPlusV: \"dig.type1 (did you mean to use one of *dig.type1, or dig.someInterface?)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"one suggestion for a slice of elements\",\n\t\t\tgive: missingType{\n\t\t\t\tKey: key{t: reflect.TypeOf([]type1{})},\n\t\t\t\tsuggestions: []key{\n\t\t\t\t\t{t: reflect.TypeOf([]*type1{})},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantV:     \"[]dig.type1 (did you mean []*dig.type1?)\",\n\t\t\twantPlusV: \"[]dig.type1 (did you mean to use []*dig.type1?)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"one suggestion for an array of elements\",\n\t\t\tgive: missingType{\n\t\t\t\tKey: key{t: reflect.TypeOf([4]type1{})},\n\t\t\t\tsuggestions: []key{\n\t\t\t\t\t{t: reflect.TypeOf([4]*type1{})},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantV:     \"[4]dig.type1 (did you mean [4]*dig.type1?)\",\n\t\t\twantPlusV: \"[4]dig.type1 (did you mean to use [4]*dig.type1?)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"one suggestion for a slice of pointers\",\n\t\t\tgive: missingType{\n\t\t\t\tKey: key{t: reflect.TypeOf([]*type1{})},\n\t\t\t\tsuggestions: []key{\n\t\t\t\t\t{t: reflect.TypeOf([]type1{})},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantV:     \"[]*dig.type1 (did you mean []dig.type1?)\",\n\t\t\twantPlusV: \"[]*dig.type1 (did you mean to use []dig.type1?)\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"one suggestion for an array of pointers\",\n\t\t\tgive: missingType{\n\t\t\t\tKey: key{t: reflect.TypeOf([4]*type1{})},\n\t\t\t\tsuggestions: []key{\n\t\t\t\t\t{t: reflect.TypeOf([4]type1{})},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantV:     \"[4]*dig.type1 (did you mean [4]dig.type1?)\",\n\t\t\twantPlusV: \"[4]*dig.type1 (did you mean to use [4]dig.type1?)\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tassert.Equal(t, tt.wantV, fmt.Sprint(tt.give), \"%v did not match\")\n\t\t\tassert.Equal(t, tt.wantPlusV, fmt.Sprintf(\"%+v\", tt.give), \"%+v did not match\")\n\t\t})\n\t}\n}\n\nfunc TestErrorFormatting(t *testing.T) {\n\ttype someType struct{}\n\ttype anotherType struct{}\n\n\tsimpleErr := errors.New(\"great sadness\")\n\trichError := errFormatted{\n\t\tv: \"great sadness\",\n\t\tplusV: joinLines(\n\t\t\t\"sadness so great\",\n\t\t\t\"it needs multiple\",\n\t\t\t\"lines\",\n\t\t),\n\t}\n\n\tsomeFunc := &digreflect.Func{\n\t\tPackage: \"foo\",\n\t\tName:    \"Bar\",\n\t\tFile:    \"foo/bar.go\",\n\t\tLine:    42,\n\t}\n\n\ttests := []struct {\n\t\tdesc       string\n\t\tgive       error\n\t\twantString string\n\t\twantPlusV  string\n\t}{\n\t\t{\n\t\t\tdesc: \"wrapped error/simple\",\n\t\t\tgive: errInvalidInput{\n\t\t\t\tMessage: \"something went wrong\",\n\t\t\t\tCause:   simpleErr,\n\t\t\t},\n\t\t\twantString: \"something went wrong: great sadness\",\n\t\t\twantPlusV: joinLines(\n\t\t\t\t\"something went wrong:\",\n\t\t\t\t\"great sadness\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"wrapped error/rich\",\n\t\t\tgive: errInvalidInput{\n\t\t\t\tMessage: \"something went wrong\",\n\t\t\t\tCause:   richError,\n\t\t\t},\n\t\t\twantString: \"something went wrong: great sadness\",\n\t\t\twantPlusV: joinLines(\n\t\t\t\t\"something went wrong:\",\n\t\t\t\t\"sadness so great\",\n\t\t\t\t\"it needs multiple\",\n\t\t\t\t\"lines\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"errProvide\",\n\t\t\tgive: errProvide{\n\t\t\t\tFunc:   someFunc,\n\t\t\t\tReason: simpleErr,\n\t\t\t},\n\t\t\twantString: `cannot provide function \"foo\".Bar (foo/bar.go:42): great sadness`,\n\t\t\twantPlusV: joinLines(\n\t\t\t\t`cannot provide function \"foo\".Bar`,\n\t\t\t\t\"\tfoo/bar.go:42:\",\n\t\t\t\t\"great sadness\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"errConstructorFailed\",\n\t\t\tgive: errConstructorFailed{\n\t\t\t\tFunc:   someFunc,\n\t\t\t\tReason: richError,\n\t\t\t},\n\t\t\twantString: `received non-nil error from function \"foo\".Bar (foo/bar.go:42): great sadness`,\n\t\t\twantPlusV: joinLines(\n\t\t\t\t`received non-nil error from function \"foo\".Bar`,\n\t\t\t\t\"\tfoo/bar.go:42:\",\n\t\t\t\t\"sadness so great\",\n\t\t\t\t\"it needs multiple\",\n\t\t\t\t\"lines\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"errArgumentsFailed\",\n\t\t\tgive: errArgumentsFailed{\n\t\t\t\tFunc:   someFunc,\n\t\t\t\tReason: simpleErr,\n\t\t\t},\n\t\t\twantString: `could not build arguments for function \"foo\".Bar (foo/bar.go:42): great sadness`,\n\t\t\twantPlusV: joinLines(\n\t\t\t\t`could not build arguments for function \"foo\".Bar`,\n\t\t\t\t\"\tfoo/bar.go:42:\",\n\t\t\t\t\"great sadness\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"errMissingDependencies\",\n\t\t\tgive: errMissingDependencies{\n\t\t\t\tFunc:   someFunc,\n\t\t\t\tReason: richError,\n\t\t\t},\n\t\t\twantString: `missing dependencies for function \"foo\".Bar (foo/bar.go:42): great sadness`,\n\t\t\twantPlusV: joinLines(\n\t\t\t\t`missing dependencies for function \"foo\".Bar`,\n\t\t\t\t\"\tfoo/bar.go:42:\",\n\t\t\t\t\"sadness so great\",\n\t\t\t\t\"it needs multiple\",\n\t\t\t\t\"lines\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"errParamSingleFailed\",\n\t\t\tgive: errParamSingleFailed{\n\t\t\t\tKey:    key{t: reflect.TypeOf(someType{})},\n\t\t\t\tReason: richError,\n\t\t\t},\n\t\t\twantString: `failed to build dig.someType: great sadness`,\n\t\t\twantPlusV: joinLines(\n\t\t\t\t`failed to build dig.someType:`,\n\t\t\t\t\"sadness so great\",\n\t\t\t\t\"it needs multiple\",\n\t\t\t\t\"lines\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"errParamGroupFailed\",\n\t\t\tgive: errParamGroupFailed{\n\t\t\t\tKey:    key{t: reflect.TypeOf(someType{}), group: \"items\"},\n\t\t\t\tReason: richError,\n\t\t\t},\n\t\t\twantString: `could not build value group dig.someType[group=\"items\"]: great sadness`,\n\t\t\twantPlusV: joinLines(\n\t\t\t\t`could not build value group dig.someType[group=\"items\"]:`,\n\t\t\t\t\"sadness so great\",\n\t\t\t\t\"it needs multiple\",\n\t\t\t\t\"lines\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"errMissingTypes/single\",\n\t\t\tgive: errMissingTypes{\n\t\t\t\t{Key: key{t: reflect.TypeOf(someType{})}},\n\t\t\t},\n\t\t\twantString: \"missing type: dig.someType\",\n\t\t\twantPlusV: joinLines(\n\t\t\t\t\"missing type:\",\n\t\t\t\t\"\t- dig.someType (did you mean to Provide it?)\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdesc: \"errMissingTypes/multiple\",\n\t\t\tgive: errMissingTypes{\n\t\t\t\t{Key: key{t: reflect.TypeOf(someType{})}},\n\t\t\t\t{Key: key{t: reflect.TypeOf(&anotherType{})}},\n\t\t\t},\n\t\t\twantString: \"missing types: dig.someType; *dig.anotherType\",\n\t\t\twantPlusV: joinLines(\n\t\t\t\t\"missing types:\",\n\t\t\t\t\"\t- dig.someType (did you mean to Provide it?)\",\n\t\t\t\t\"\t- *dig.anotherType (did you mean to Provide it?)\",\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tassert.Equal(t, tt.wantString, tt.give.Error(), \"%v did not match\")\n\t\t\tassert.Equal(t, tt.wantPlusV, fmt.Sprintf(\"%+v\", tt.give), \"%+v did not match\")\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 1.994140625,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig_test\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"os\"\n\n\t\"go.uber.org/dig\"\n)\n\nfunc Example_minimal() {\n\ttype Config struct {\n\t\tPrefix string\n\t}\n\n\tc := dig.New()\n\n\t// Provide a Config object. This can fail to decode.\n\terr := c.Provide(func() (*Config, error) {\n\t\t// In a real program, the configuration will probably be read from a\n\t\t// file.\n\t\tvar cfg Config\n\t\terr := json.Unmarshal([]byte(`{\"prefix\": \"[foo] \"}`), &cfg)\n\t\treturn &cfg, err\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Provide a way to build the logger based on the configuration.\n\terr = c.Provide(func(cfg *Config) *log.Logger {\n\t\treturn log.New(os.Stdout, cfg.Prefix, 0)\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Invoke a function that requires the logger, which in turn builds the\n\t// Config first.\n\terr = c.Invoke(func(l *log.Logger) {\n\t\tl.Print(\"You've been invoked\")\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Output:\n\t// [foo] You've been invoked\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2490234375,
          "content": "module go.uber.org/dig\n\ngo 1.20\n\nrequire github.com/stretchr/testify v1.7.1\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n\nretract v1.16.0 // bad release\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.13671875,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.1 h1:5TQK59W5E3v0r2duFAb7P95B6hEeOyEnHRa8MjYSMTY=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "graph.go",
          "type": "blob",
          "size": 3.7509765625,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport \"go.uber.org/dig/internal/graph\"\n\n// graphNode is a single node in the dependency graph.\ntype graphNode struct {\n\tWrapped interface{}\n}\n\n// graphHolder is the dependency graph of the container.\n// It saves constructorNodes and paramGroupedSlice (value groups)\n// as nodes in the graph.\n// It implements the graph interface defined by internal/graph.\n// It has 1-1 correspondence with the Scope whose graph it represents.\ntype graphHolder struct {\n\t// all the nodes defined in the graph.\n\tnodes []*graphNode\n\n\t// Scope whose graph this holder contains.\n\ts *Scope\n\n\t// Number of nodes in the graph at last snapshot.\n\t// -1 if no snapshot has been taken.\n\tsnap int\n}\n\nvar _ graph.Graph = (*graphHolder)(nil)\n\nfunc newGraphHolder(s *Scope) *graphHolder {\n\treturn &graphHolder{s: s, snap: -1}\n}\n\nfunc (gh *graphHolder) Order() int { return len(gh.nodes) }\n\n// EdgesFrom returns the indices of nodes that are dependencies of node u.\n//\n// To do that, it needs to do one of the following:\n//\n// For constructor nodes, it retrieves the providers of the constructor's\n// parameters from the container and reports their orders.\n//\n// For value group nodes, it retrieves the group providers from the container\n// and reports their orders.\nfunc (gh *graphHolder) EdgesFrom(u int) []int {\n\tvar orders []int\n\tswitch w := gh.Lookup(u).(type) {\n\tcase *constructorNode:\n\t\tfor _, param := range w.paramList.Params {\n\t\t\torders = append(orders, getParamOrder(gh, param)...)\n\t\t}\n\tcase *paramGroupedSlice:\n\t\tproviders := gh.s.getAllGroupProviders(w.Group, w.Type.Elem())\n\t\tfor _, provider := range providers {\n\t\t\torders = append(orders, provider.Order(gh.s))\n\t\t}\n\t}\n\treturn orders\n}\n\n// NewNode adds a new value to the graph and returns its order.\nfunc (gh *graphHolder) NewNode(wrapped interface{}) int {\n\torder := len(gh.nodes)\n\tgh.nodes = append(gh.nodes, &graphNode{\n\t\tWrapped: wrapped,\n\t})\n\treturn order\n}\n\n// Lookup retrieves the value for the node with the given order.\n// Lookup panics if i is invalid.\nfunc (gh *graphHolder) Lookup(i int) interface{} {\n\treturn gh.nodes[i].Wrapped\n}\n\n// Snapshot takes a temporary snapshot of the current state of the graph.\n// Use with Rollback to undo changes to the graph.\n//\n// Only one snapshot is allowed at a time.\n// Multiple calls to snapshot will overwrite prior snapshots.\nfunc (gh *graphHolder) Snapshot() {\n\tgh.snap = len(gh.nodes)\n}\n\n// Rollback rolls back a snapshot to a previously captured state.\n// This is a no-op if no snapshot was captured.\nfunc (gh *graphHolder) Rollback() {\n\tif gh.snap < 0 {\n\t\treturn\n\t}\n\n\t// nodes is an append-only list. To rollback, we just drop the\n\t// extraneous entries from the slice.\n\tgh.nodes = gh.nodes[:gh.snap]\n\tgh.snap = -1\n}\n"
        },
        {
          "name": "group.go",
          "type": "blob",
          "size": 1.9140625,
          "content": "// Copyright (c) 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nconst (\n\t_groupTag = \"group\"\n)\n\ntype group struct {\n\tName    string\n\tFlatten bool\n\tSoft    bool\n}\n\ntype errInvalidGroupOption struct{ Option string }\n\nvar _ digError = errInvalidGroupOption{}\n\nfunc (e errInvalidGroupOption) Error() string { return fmt.Sprint(e) }\n\nfunc (e errInvalidGroupOption) writeMessage(w io.Writer, v string) {\n\tfmt.Fprintf(w, \"invalid option %q\", e.Option)\n}\n\nfunc (e errInvalidGroupOption) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\nfunc parseGroupString(s string) (group, error) {\n\tcomponents := strings.Split(s, \",\")\n\tg := group{Name: components[0]}\n\tfor _, c := range components[1:] {\n\t\tswitch c {\n\t\tcase \"flatten\":\n\t\t\tg.Flatten = true\n\t\tcase \"soft\":\n\t\t\tg.Soft = true\n\t\tdefault:\n\t\t\treturn g, errInvalidGroupOption{Option: c}\n\t\t}\n\t}\n\treturn g, nil\n}\n"
        },
        {
          "name": "group_test.go",
          "type": "blob",
          "size": 1.966796875,
          "content": "// Copyright (c) 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseGroup(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tgroup   string\n\t\twantG   group\n\t\twantErr string\n\t}{\n\t\t{\n\t\t\tname:  \"simple group\",\n\t\t\tgroup: `somegroup`,\n\t\t\twantG: group{Name: \"somegroup\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"flattened group\",\n\t\t\tgroup: `somegroup,flatten`,\n\t\t\twantG: group{Name: \"somegroup\", Flatten: true},\n\t\t},\n\t\t{\n\t\t\tname:  \"soft group\",\n\t\t\tgroup: \"somegroup,soft\",\n\t\t\twantG: group{Name: \"somegroup\", Soft: true},\n\t\t},\n\t\t{\n\t\t\tname:    \"error\",\n\t\t\tgroup:   `somegroup,abc`,\n\t\t\twantErr: `invalid option \"abc\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotG, err := parseGroupString(tt.group)\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tassert.Contains(t, err.Error(), tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Equal(t, tt.wantG, gotG)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "inout.go",
          "type": "blob",
          "size": 6.1884765625,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"container/list\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n)\n\nvar (\n\t_noValue    reflect.Value\n\t_errType    = reflect.TypeOf((*error)(nil)).Elem()\n\t_inPtrType  = reflect.TypeOf((*In)(nil))\n\t_inType     = reflect.TypeOf(In{})\n\t_outPtrType = reflect.TypeOf((*Out)(nil))\n\t_outType    = reflect.TypeOf(Out{})\n)\n\n// Placeholder type placed in dig.In/dig.out to make their special nature\n// obvious in godocs.\n// Otherwise they will appear as plain empty structs.\ntype digSentinel struct{}\n\n// In may be embedded into structs to request dig to treat them as special\n// parameter structs. When a constructor accepts such a struct, instead of the\n// struct becoming a dependency for that constructor, all its fields become\n// dependencies instead. See the section on Parameter Objects in the\n// package-level documentation for more information.\n//\n// Fields of the struct may optionally be tagged to customize the behavior of\n// dig. The following tags are supported,\n//\n//\tname        Requests a value with the same name and type from the\n//\t            container. See Named Values for more information.\n//\toptional    If set to true, indicates that the dependency is optional and\n//\t            the constructor gracefully handles its absence.\n//\tgroup       Name of the Value Group from which this field will be filled.\n//\t            The field must be a slice type. See Value Groups in the\n//\t            package documentation for more information.\ntype In struct{ _ digSentinel }\n\n// Out is an embeddable type that signals to dig that the returned\n// struct should be treated differently. Instead of the struct itself\n// becoming part of the container, all members of the struct will.\n\n// Out may be embedded into structs to request dig to treat them as special\n// result structs. When a constructor returns such a struct, instead of the\n// struct becoming a result of the constructor, all its fields become results\n// of the constructor. See the section on Result Objects in the package-level\n// documentation for more information.\n//\n// Fields of the struct may optionally be tagged to customize the behavior of\n// dig. The following tags are supported,\n//\n//\tname        Specifies the name of the value. Only a field on a dig.In\n//\t            struct with the same 'name' annotation can receive this\n//\t            value. See Named Values for more information.\n//\tgroup       Name of the Value Group to which this field's value is being\n//\t            sent. See Value Groups in the package documentation for more\n//\t            information.\ntype Out struct{ _ digSentinel }\n\nfunc isError(t reflect.Type) bool {\n\treturn t.Implements(_errType)\n}\n\n// IsIn checks whether the given struct is a dig.In struct. A struct qualifies\n// as a dig.In struct if it embeds the dig.In type or if any struct that it\n// embeds is a dig.In struct. The parameter may be the reflect.Type of the\n// struct rather than the struct itself.\n//\n// A struct MUST qualify as a dig.In struct for its fields to be treated\n// specially by dig.\n//\n// See the documentation for dig.In for a comprehensive list of supported\n// tags.\nfunc IsIn(o interface{}) bool {\n\treturn embedsType(o, _inType)\n}\n\n// IsOut checks whether the given struct is a dig.Out struct. A struct\n// qualifies as a dig.Out struct if it embeds the dig.Out type or if any\n// struct that it embeds is a dig.Out struct. The parameter may be the\n// reflect.Type of the struct rather than the struct itself.\n//\n// A struct MUST qualify as a dig.Out struct for its fields to be treated\n// specially by dig.\n//\n// See the documentation for dig.Out for a comprehensive list of supported\n// tags.\nfunc IsOut(o interface{}) bool {\n\treturn embedsType(o, _outType)\n}\n\n// Returns true if t embeds e or if any of the types embedded by t embed e.\nfunc embedsType(i interface{}, e reflect.Type) bool {\n\t// TODO: this function doesn't consider e being a pointer.\n\t// given `type A foo { *In }`, this function would return false for\n\t// embedding dig.In, which makes for some extra error checking in places\n\t// that call this function. Might be worthwhile to consider reflect.Indirect\n\t// usage to clean up the callers.\n\n\tif i == nil {\n\t\treturn false\n\t}\n\n\t// maybe it's already a reflect.Type\n\tt, ok := i.(reflect.Type)\n\tif !ok {\n\t\t// take the type if it's not\n\t\tt = reflect.TypeOf(i)\n\t}\n\n\t// We are going to do a breadth-first search of all embedded fields.\n\ttypes := list.New()\n\ttypes.PushBack(t)\n\tfor types.Len() > 0 {\n\t\tt := types.Remove(types.Front()).(reflect.Type)\n\n\t\tif t == e {\n\t\t\treturn true\n\t\t}\n\n\t\tif t.Kind() != reflect.Struct {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i := 0; i < t.NumField(); i++ {\n\t\t\tf := t.Field(i)\n\t\t\tif f.Anonymous {\n\t\t\t\ttypes.PushBack(f.Type)\n\t\t\t}\n\t\t}\n\t}\n\n\t// If perf is an issue, we can cache known In objects and Out objects in a\n\t// map[reflect.Type]struct{}.\n\treturn false\n}\n\n// Checks if a field of an In struct is optional.\nfunc isFieldOptional(f reflect.StructField) (bool, error) {\n\ttag := f.Tag.Get(_optionalTag)\n\tif tag == \"\" {\n\t\treturn false, nil\n\t}\n\n\toptional, err := strconv.ParseBool(tag)\n\tif err != nil {\n\t\terr = newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"invalid value %q for %q tag on field %v\", tag, _optionalTag, f.Name), err)\n\t}\n\n\treturn optional, err\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "invoke.go",
          "type": "blob",
          "size": 6.2060546875,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"go.uber.org/dig/internal/digreflect\"\n\t\"go.uber.org/dig/internal/graph\"\n)\n\n// An InvokeOption modifies the default behavior of Invoke.\ntype InvokeOption interface {\n\tapplyInvokeOption(*invokeOptions)\n}\n\ntype invokeOptions struct {\n\tInfo *InvokeInfo\n}\n\n// InvokeInfo provides information about an Invoke.\ntype InvokeInfo struct {\n\tInputs []*Input\n}\n\n// FillInvokeInfo is an InvokeOption that writes information on the types\n// accepted by the Invoke function into the specified InvokeInfo.\n// For example:\n//\n//\t\t\tvar info dig.InvokeInfo\n//\t\t\terr := c.Invoke(func(string, int){}, dig.FillInvokeInfo(&info))\n//\n//\t  info.Inputs[0].String() will be string.\n//\t  info.Inputs[1].String() will be int.\nfunc FillInvokeInfo(info *InvokeInfo) InvokeOption {\n\treturn fillInvokeInfoOption{info: info}\n}\n\ntype fillInvokeInfoOption struct {\n\tinfo *InvokeInfo\n}\n\nfunc (o fillInvokeInfoOption) String() string {\n\treturn fmt.Sprintf(\"FillInvokeInfo(%p)\", o.info)\n}\n\nfunc (o fillInvokeInfoOption) applyInvokeOption(opts *invokeOptions) {\n\topts.Info = o.info\n}\n\n// Invoke runs the given function after instantiating its dependencies.\n//\n// Any arguments that the function has are treated as its dependencies. The\n// dependencies are instantiated in an unspecified order along with any\n// dependencies that they might have.\n//\n// The function may return an error to indicate failure. The error will be\n// returned to the caller as-is.\n//\n// If the [RecoverFromPanics] option was given to the container and a panic\n// occurs when invoking, a [PanicError] with the panic contained will be\n// returned. See [PanicError] for more info.\nfunc (c *Container) Invoke(function interface{}, opts ...InvokeOption) error {\n\treturn c.scope.Invoke(function, opts...)\n}\n\n// Invoke runs the given function after instantiating its dependencies.\n//\n// Any arguments that the function has are treated as its dependencies. The\n// dependencies are instantiated in an unspecified order along with any\n// dependencies that they might have.\n//\n// The function may return an error to indicate failure. The error will be\n// returned to the caller as-is.\nfunc (s *Scope) Invoke(function interface{}, opts ...InvokeOption) (err error) {\n\tftype := reflect.TypeOf(function)\n\tif ftype == nil {\n\t\treturn newErrInvalidInput(\"can't invoke an untyped nil\", nil)\n\t}\n\tif ftype.Kind() != reflect.Func {\n\t\treturn newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"can't invoke non-function %v (type %v)\", function, ftype), nil)\n\t}\n\n\tpl, err := newParamList(ftype, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := shallowCheckDependencies(s, pl); err != nil {\n\t\treturn errMissingDependencies{\n\t\t\tFunc:   digreflect.InspectFunc(function),\n\t\t\tReason: err,\n\t\t}\n\t}\n\n\tif !s.isVerifiedAcyclic {\n\t\tif ok, cycle := graph.IsAcyclic(s.gh); !ok {\n\t\t\treturn newErrInvalidInput(\"cycle detected in dependency graph\", s.cycleDetectedError(cycle))\n\t\t}\n\t\ts.isVerifiedAcyclic = true\n\t}\n\n\targs, err := pl.BuildList(s)\n\tif err != nil {\n\t\treturn errArgumentsFailed{\n\t\t\tFunc:   digreflect.InspectFunc(function),\n\t\t\tReason: err,\n\t\t}\n\t}\n\tif s.recoverFromPanics {\n\t\tdefer func() {\n\t\t\tif p := recover(); p != nil {\n\t\t\t\terr = PanicError{\n\t\t\t\t\tfn:    digreflect.InspectFunc(function),\n\t\t\t\t\tPanic: p,\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tvar options invokeOptions\n\tfor _, o := range opts {\n\t\to.applyInvokeOption(&options)\n\t}\n\n\t// Record info for the invoke if requested\n\tif info := options.Info; info != nil {\n\t\tparams := pl.DotParam()\n\t\tinfo.Inputs = make([]*Input, len(params))\n\t\tfor i, p := range params {\n\t\t\tinfo.Inputs[i] = &Input{\n\t\t\t\tt:        p.Type,\n\t\t\t\toptional: p.Optional,\n\t\t\t\tname:     p.Name,\n\t\t\t\tgroup:    p.Group,\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturned := s.invokerFn(reflect.ValueOf(function), args)\n\tif len(returned) == 0 {\n\t\treturn nil\n\t}\n\tif last := returned[len(returned)-1]; isError(last.Type()) {\n\t\tif err, _ := last.Interface().(error); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Checks that all direct dependencies of the provided parameters are present in\n// the container. Returns an error if not.\nfunc shallowCheckDependencies(c containerStore, pl paramList) error {\n\tvar err errMissingTypes\n\n\tmissingDeps := findMissingDependencies(c, pl.Params...)\n\tfor _, dep := range missingDeps {\n\t\terr = append(err, newErrMissingTypes(c, key{name: dep.Name, t: dep.Type})...)\n\t}\n\n\tif len(err) > 0 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc findMissingDependencies(c containerStore, params ...param) []paramSingle {\n\tvar missingDeps []paramSingle\n\n\tfor _, param := range params {\n\t\tswitch p := param.(type) {\n\t\tcase paramSingle:\n\t\t\tallProviders := c.getAllValueProviders(p.Name, p.Type)\n\t\t\t_, hasDecoratedValue := c.getDecoratedValue(p.Name, p.Type)\n\t\t\t// This means that there is no provider that provides this value,\n\t\t\t// and it is NOT being decorated and is NOT optional.\n\t\t\t// In the case that there is no providers but there is a decorated value\n\t\t\t// of this type, it can be provided safely so we can safely skip this.\n\t\t\tif len(allProviders) == 0 && !hasDecoratedValue && !p.Optional {\n\t\t\t\tmissingDeps = append(missingDeps, p)\n\t\t\t}\n\t\tcase paramObject:\n\t\t\tfor _, f := range p.Fields {\n\t\t\t\tmissingDeps = append(missingDeps, findMissingDependencies(c, f.Param)...)\n\t\t\t}\n\t\t}\n\t}\n\treturn missingDeps\n}\n"
        },
        {
          "name": "param.go",
          "type": "blob",
          "size": 18.6103515625,
          "content": "// Copyright (c) 2019-2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"go.uber.org/dig/internal/digerror\"\n\t\"go.uber.org/dig/internal/dot\"\n)\n\n// The param interface represents a dependency for a constructor.\n//\n// The following implementations exist:\n//\n//\tparamList     All arguments of the constructor.\n//\tparamSingle   An explicitly requested type.\n//\tparamObject   dig.In struct where each field in the struct can be another\n//\t              param.\n//\tparamGroupedSlice\n//\t              A slice consuming a value group. This will receive all\n//\t              values produced with a `group:\"..\"` tag with the same name\n//\t              as a slice.\ntype param interface {\n\tfmt.Stringer\n\n\t// Build this dependency and any of its dependencies from the provided\n\t// Container.\n\t//\n\t// This MAY panic if the param does not produce a single value.\n\tBuild(store containerStore) (reflect.Value, error)\n\n\t// DotParam returns a slice of dot.Param(s).\n\tDotParam() []*dot.Param\n}\n\nvar (\n\t_ param = paramSingle{}\n\t_ param = paramObject{}\n\t_ param = paramList{}\n\t_ param = paramGroupedSlice{}\n)\n\n// newParam builds a param from the given type. If the provided type is a\n// dig.In struct, an paramObject will be returned.\nfunc newParam(t reflect.Type, c containerStore) (param, error) {\n\tswitch {\n\tcase IsOut(t) || (t.Kind() == reflect.Ptr && IsOut(t.Elem())) || embedsType(t, _outPtrType):\n\t\treturn nil, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot depend on result objects: %v embeds a dig.Out\", t), nil)\n\tcase IsIn(t):\n\t\treturn newParamObject(t, c)\n\tcase embedsType(t, _inPtrType):\n\t\treturn nil, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot build a parameter object by embedding *dig.In, embed dig.In instead: %v embeds *dig.In\", t), nil)\n\tcase t.Kind() == reflect.Ptr && IsIn(t.Elem()):\n\t\treturn nil, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot depend on a pointer to a parameter object, use a value instead: %v is a pointer to a struct that embeds dig.In\", t), nil)\n\tdefault:\n\t\treturn paramSingle{Type: t}, nil\n\t}\n}\n\n// paramList holds all arguments of the constructor as params.\n//\n// NOTE: Build() MUST NOT be called on paramList. Instead, BuildList\n// must be called.\ntype paramList struct {\n\tctype reflect.Type // type of the constructor\n\n\tParams []param\n}\n\nfunc (pl paramList) DotParam() []*dot.Param {\n\tvar types []*dot.Param\n\tfor _, param := range pl.Params {\n\t\ttypes = append(types, param.DotParam()...)\n\t}\n\treturn types\n}\n\nfunc (pl paramList) String() string {\n\targs := make([]string, len(pl.Params))\n\tfor i, p := range pl.Params {\n\t\targs[i] = p.String()\n\t}\n\treturn fmt.Sprint(args)\n}\n\n// newParamList builds a paramList from the provided constructor type.\n//\n// Variadic arguments of a constructor are ignored and not included as\n// dependencies.\nfunc newParamList(ctype reflect.Type, c containerStore) (paramList, error) {\n\tnumArgs := ctype.NumIn()\n\tif ctype.IsVariadic() {\n\t\t// NOTE: If the function is variadic, we skip the last argument\n\t\t// because we're not filling variadic arguments yet. See #120.\n\t\tnumArgs--\n\t}\n\n\tpl := paramList{\n\t\tctype:  ctype,\n\t\tParams: make([]param, 0, numArgs),\n\t}\n\n\tfor i := 0; i < numArgs; i++ {\n\t\tp, err := newParam(ctype.In(i), c)\n\t\tif err != nil {\n\t\t\treturn pl, newErrInvalidInput(fmt.Sprintf(\"bad argument %d\", i+1), err)\n\t\t}\n\t\tpl.Params = append(pl.Params, p)\n\t}\n\n\treturn pl, nil\n}\n\nfunc (pl paramList) Build(containerStore) (reflect.Value, error) {\n\tdigerror.BugPanicf(\"paramList.Build() must never be called\")\n\tpanic(\"\") // Unreachable, as BugPanicf above will panic.\n}\n\n// BuildList returns an ordered list of values which may be passed directly\n// to the underlying constructor.\nfunc (pl paramList) BuildList(c containerStore) ([]reflect.Value, error) {\n\targs := make([]reflect.Value, len(pl.Params))\n\tfor i, p := range pl.Params {\n\t\tvar err error\n\t\targs[i], err = p.Build(c)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn args, nil\n}\n\n// paramSingle is an explicitly requested type, optionally with a name.\n//\n// This object must be present in the graph as-is unless it's specified as\n// optional.\ntype paramSingle struct {\n\tName     string\n\tOptional bool\n\tType     reflect.Type\n}\n\nfunc (ps paramSingle) DotParam() []*dot.Param {\n\treturn []*dot.Param{\n\t\t{\n\t\t\tNode: &dot.Node{\n\t\t\t\tType: ps.Type,\n\t\t\t\tName: ps.Name,\n\t\t\t},\n\t\t\tOptional: ps.Optional,\n\t\t},\n\t}\n}\n\nfunc (ps paramSingle) String() string {\n\t// tally.Scope[optional] means optional\n\t// tally.Scope[optional, name=\"foo\"] means named optional\n\n\tvar opts []string\n\tif ps.Optional {\n\t\topts = append(opts, \"optional\")\n\t}\n\tif ps.Name != \"\" {\n\t\topts = append(opts, fmt.Sprintf(\"name=%q\", ps.Name))\n\t}\n\n\tif len(opts) == 0 {\n\t\treturn fmt.Sprint(ps.Type)\n\t}\n\n\treturn fmt.Sprintf(\"%v[%v]\", ps.Type, strings.Join(opts, \", \"))\n}\n\n// search the given container and its ancestors for a decorated value.\nfunc (ps paramSingle) getDecoratedValue(c containerStore) (reflect.Value, bool) {\n\tfor _, c := range c.storesToRoot() {\n\t\tif v, ok := c.getDecoratedValue(ps.Name, ps.Type); ok {\n\t\t\treturn v, ok\n\t\t}\n\t}\n\treturn _noValue, false\n}\n\n// builds the parameter using decorators in all scopes that affect the\n// current scope, if there are any. If there are multiple Scopes that decorates\n// this parameter, the closest one to the Scope that invoked this will be used.\n// If there are no decorators associated with this parameter, _noValue is returned.\nfunc (ps paramSingle) buildWithDecorators(c containerStore) (v reflect.Value, found bool, err error) {\n\tvar (\n\t\td               decorator\n\t\tdecoratingScope containerStore\n\t)\n\tstores := c.storesToRoot()\n\n\tfor _, s := range stores {\n\t\tif d, found = s.getValueDecorator(ps.Name, ps.Type); !found {\n\t\t\tcontinue\n\t\t}\n\t\tif d.State() == decoratorOnStack {\n\t\t\t// This decorator is already being run.\n\t\t\t// Avoid a cycle and look further.\n\t\t\td = nil\n\t\t\tcontinue\n\t\t}\n\t\tdecoratingScope = s\n\t\tbreak\n\t}\n\tif !found || d == nil {\n\t\treturn _noValue, false, nil\n\t}\n\tif err = d.Call(decoratingScope); err != nil {\n\t\tv, err = _noValue, errParamSingleFailed{\n\t\t\tCtorID: 1,\n\t\t\tKey:    key{t: ps.Type, name: ps.Name},\n\t\t\tReason: err,\n\t\t}\n\t\treturn v, found, err\n\t}\n\tv, _ = decoratingScope.getDecoratedValue(ps.Name, ps.Type)\n\treturn\n}\n\nfunc (ps paramSingle) Build(c containerStore) (reflect.Value, error) {\n\tv, found, err := ps.buildWithDecorators(c)\n\tif found {\n\t\treturn v, err\n\t}\n\n\t// Check whether the value is a decorated value first.\n\tif v, ok := ps.getDecoratedValue(c); ok {\n\t\treturn v, nil\n\t}\n\n\t// Starting at the given container and working our way up its parents,\n\t// find one that provides this dependency.\n\t//\n\t// Once found, we'll use that container for the rest of the invocation.\n\t// Dependencies of this type will begin searching at that container,\n\t// rather than starting at base.\n\tvar providers []provider\n\tvar providingContainer containerStore\n\tfor _, container := range c.storesToRoot() {\n\t\t// first check if the scope already has cached a value for the type.\n\t\tif v, ok := container.getValue(ps.Name, ps.Type); ok {\n\t\t\treturn v, nil\n\t\t}\n\t\tproviders = container.getValueProviders(ps.Name, ps.Type)\n\t\tif len(providers) > 0 {\n\t\t\tprovidingContainer = container\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif len(providers) == 0 {\n\t\tif ps.Optional {\n\t\t\treturn reflect.Zero(ps.Type), nil\n\t\t}\n\t\treturn _noValue, newErrMissingTypes(c, key{name: ps.Name, t: ps.Type})\n\t}\n\n\tfor _, n := range providers {\n\t\terr := n.Call(n.OrigScope())\n\t\tif err == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If we're missing dependencies but the parameter itself is optional,\n\t\t// we can just move on.\n\t\tif errors.As(err, new(errMissingDependencies)) && ps.Optional {\n\t\t\treturn reflect.Zero(ps.Type), nil\n\t\t}\n\n\t\treturn _noValue, errParamSingleFailed{\n\t\t\tCtorID: n.ID(),\n\t\t\tKey:    key{t: ps.Type, name: ps.Name},\n\t\t\tReason: err,\n\t\t}\n\t}\n\n\t// If we get here, it's impossible for the value to be absent from the\n\t// container.\n\tv, _ = providingContainer.getValue(ps.Name, ps.Type)\n\treturn v, nil\n}\n\n// paramObject is a dig.In struct where each field is another param.\n//\n// This object is not expected in the graph as-is.\ntype paramObject struct {\n\tType        reflect.Type\n\tFields      []paramObjectField\n\tFieldOrders []int\n}\n\nfunc (po paramObject) DotParam() []*dot.Param {\n\tvar types []*dot.Param\n\tfor _, field := range po.Fields {\n\t\ttypes = append(types, field.DotParam()...)\n\t}\n\treturn types\n}\n\nfunc (po paramObject) String() string {\n\tfields := make([]string, len(po.Fields))\n\tfor i, f := range po.Fields {\n\t\tfields[i] = f.Param.String()\n\t}\n\treturn strings.Join(fields, \" \")\n}\n\n// getParamOrder returns the order(s) of a parameter type.\nfunc getParamOrder(gh *graphHolder, param param) []int {\n\tvar orders []int\n\tswitch p := param.(type) {\n\tcase paramSingle:\n\t\tproviders := gh.s.getAllValueProviders(p.Name, p.Type)\n\t\tfor _, provider := range providers {\n\t\t\torders = append(orders, provider.Order(gh.s))\n\t\t}\n\tcase paramGroupedSlice:\n\t\t// value group parameters have nodes of their own.\n\t\t// We can directly return that here.\n\t\torders = append(orders, p.orders[gh.s])\n\tcase paramObject:\n\t\tfor _, pf := range p.Fields {\n\t\t\torders = append(orders, getParamOrder(gh, pf.Param)...)\n\t\t}\n\t}\n\treturn orders\n}\n\n// newParamObject builds an paramObject from the provided type. The type MUST\n// be a dig.In struct.\nfunc newParamObject(t reflect.Type, c containerStore) (paramObject, error) {\n\tpo := paramObject{Type: t}\n\n\t// Check if the In type supports ignoring unexported fields.\n\tvar ignoreUnexported bool\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tf := t.Field(i)\n\t\tif f.Type == _inType {\n\t\t\tvar err error\n\t\t\tignoreUnexported, err = isIgnoreUnexportedSet(f)\n\t\t\tif err != nil {\n\t\t\t\treturn po, err\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tf := t.Field(i)\n\t\tif f.Type == _inType {\n\t\t\t// Skip over the dig.In embed.\n\t\t\tcontinue\n\t\t}\n\t\tif f.PkgPath != \"\" && ignoreUnexported {\n\t\t\t// Skip over an unexported field if it is allowed.\n\t\t\tcontinue\n\t\t}\n\t\tpof, err := newParamObjectField(i, f, c)\n\t\tif err != nil {\n\t\t\treturn po, newErrInvalidInput(\n\t\t\t\tfmt.Sprintf(\"bad field %q of %v\", f.Name, t), err)\n\t\t}\n\t\tpo.Fields = append(po.Fields, pof)\n\t}\n\treturn po, nil\n}\n\nfunc (po paramObject) Build(c containerStore) (reflect.Value, error) {\n\tdest := reflect.New(po.Type).Elem()\n\t// We have to build soft groups after all other fields, to avoid cases\n\t// when a field calls a provider for a soft value group, but the value is\n\t// not provided to it because the value group is declared before the field\n\tvar softGroupsQueue []paramObjectField\n\tvar fields []paramObjectField\n\tfor _, f := range po.Fields {\n\t\tif p, ok := f.Param.(paramGroupedSlice); ok && p.Soft {\n\t\t\tsoftGroupsQueue = append(softGroupsQueue, f)\n\t\t\tcontinue\n\t\t}\n\t\tfields = append(fields, f)\n\t}\n\tfields = append(fields, softGroupsQueue...)\n\tfor _, f := range fields {\n\t\tv, err := f.Build(c)\n\t\tif err != nil {\n\t\t\treturn dest, err\n\t\t}\n\t\tdest.Field(f.FieldIndex).Set(v)\n\t}\n\treturn dest, nil\n}\n\n// paramObjectField is a single field of a dig.In struct.\ntype paramObjectField struct {\n\t// Name of the field in the struct.\n\tFieldName string\n\n\t// Index of this field in the target struct.\n\t//\n\t// We need to track this separately because not all fields of the\n\t// struct map to params.\n\tFieldIndex int\n\n\t// The dependency requested by this field.\n\tParam param\n}\n\nfunc (pof paramObjectField) DotParam() []*dot.Param {\n\treturn pof.Param.DotParam()\n}\n\nfunc newParamObjectField(idx int, f reflect.StructField, c containerStore) (paramObjectField, error) {\n\tpof := paramObjectField{\n\t\tFieldName:  f.Name,\n\t\tFieldIndex: idx,\n\t}\n\n\tvar p param\n\tswitch {\n\tcase f.PkgPath != \"\":\n\t\treturn pof, newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"unexported fields not allowed in dig.In, did you mean to export %q (%v)?\", f.Name, f.Type), nil)\n\n\tcase f.Tag.Get(_groupTag) != \"\":\n\t\tvar err error\n\t\tp, err = newParamGroupedSlice(f, c)\n\t\tif err != nil {\n\t\t\treturn pof, err\n\t\t}\n\n\tdefault:\n\t\tvar err error\n\t\tp, err = newParam(f.Type, c)\n\t\tif err != nil {\n\t\t\treturn pof, err\n\t\t}\n\t}\n\n\tif ps, ok := p.(paramSingle); ok {\n\t\tps.Name = f.Tag.Get(_nameTag)\n\n\t\tvar err error\n\t\tps.Optional, err = isFieldOptional(f)\n\t\tif err != nil {\n\t\t\treturn pof, err\n\t\t}\n\n\t\tp = ps\n\t}\n\n\tpof.Param = p\n\treturn pof, nil\n}\n\nfunc (pof paramObjectField) Build(c containerStore) (reflect.Value, error) {\n\tv, err := pof.Param.Build(c)\n\tif err != nil {\n\t\treturn v, err\n\t}\n\treturn v, nil\n}\n\n// paramGroupedSlice is a param which produces a slice of values with the same\n// group name.\ntype paramGroupedSlice struct {\n\t// Name of the group as specified in the `group:\"..\"` tag.\n\tGroup string\n\n\t// Type of the slice.\n\tType reflect.Type\n\n\t// Soft is used to denote a soft dependency between this param and its\n\t// constructors, if it's true its constructors are only called if they\n\t// provide another value requested in the graph\n\tSoft bool\n\n\torders map[*Scope]int\n}\n\nfunc (pt paramGroupedSlice) String() string {\n\t// io.Reader[group=\"foo\"] refers to a group of io.Readers called 'foo'\n\treturn fmt.Sprintf(\"%v[group=%q]\", pt.Type.Elem(), pt.Group)\n}\n\nfunc (pt paramGroupedSlice) DotParam() []*dot.Param {\n\treturn []*dot.Param{\n\t\t{\n\t\t\tNode: &dot.Node{\n\t\t\t\tType:  pt.Type,\n\t\t\t\tGroup: pt.Group,\n\t\t\t},\n\t\t},\n\t}\n}\n\n// newParamGroupedSlice builds a paramGroupedSlice from the provided type with\n// the given name.\n//\n// The type MUST be a slice type.\nfunc newParamGroupedSlice(f reflect.StructField, c containerStore) (paramGroupedSlice, error) {\n\tg, err := parseGroupString(f.Tag.Get(_groupTag))\n\tif err != nil {\n\t\treturn paramGroupedSlice{}, err\n\t}\n\tpg := paramGroupedSlice{\n\t\tGroup:  g.Name,\n\t\tType:   f.Type,\n\t\torders: make(map[*Scope]int),\n\t\tSoft:   g.Soft,\n\t}\n\n\tname := f.Tag.Get(_nameTag)\n\toptional, _ := isFieldOptional(f)\n\tswitch {\n\tcase f.Type.Kind() != reflect.Slice:\n\t\treturn pg, newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"value groups may be consumed as slices only: field %q (%v) is not a slice\", f.Name, f.Type), nil)\n\tcase g.Flatten:\n\t\treturn pg, newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"cannot use flatten in parameter value groups: field %q (%v) specifies flatten\", f.Name, f.Type), nil)\n\tcase name != \"\":\n\t\treturn pg, newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"cannot use named values with value groups: name:%q requested with group:%q\", name, pg.Group), nil)\n\tcase optional:\n\t\treturn pg, newErrInvalidInput(\"value groups cannot be optional\", nil)\n\t}\n\tc.newGraphNode(&pg, pg.orders)\n\treturn pg, nil\n}\n\n// retrieves any decorated values that may be committed in this scope, or\n// any of the parent Scopes. In the case where there are multiple scopes that\n// are decorating the same type, the closest scope in effect will be replacing\n// any decorated value groups provided in further scopes.\nfunc (pt paramGroupedSlice) getDecoratedValues(c containerStore) (reflect.Value, bool) {\n\tfor _, c := range c.storesToRoot() {\n\t\tif items, ok := c.getDecoratedValueGroup(pt.Group, pt.Type); ok {\n\t\t\treturn items, true\n\t\t}\n\t}\n\treturn _noValue, false\n}\n\n// search the given container and its parents for matching group decorators\n// and call them to commit values. If any decorators return an error,\n// that error is returned immediately. If all decorators succeeds, nil is returned.\n// The order in which the decorators are invoked is from the top level scope to\n// the current scope, to account for decorators that decorate values that were\n// already decorated.\nfunc (pt paramGroupedSlice) callGroupDecorators(c containerStore) error {\n\tstores := c.storesToRoot()\n\tfor i := len(stores) - 1; i >= 0; i-- {\n\t\tc := stores[i]\n\t\tif d, found := c.getGroupDecorator(pt.Group, pt.Type.Elem()); found {\n\t\t\tif d.State() == decoratorOnStack {\n\t\t\t\t// This decorator is already being run. Avoid cycle\n\t\t\t\t// and look further.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err := d.Call(c); err != nil {\n\t\t\t\treturn errParamGroupFailed{\n\t\t\t\t\tCtorID: d.ID(),\n\t\t\t\t\tKey:    key{group: pt.Group, t: pt.Type.Elem()},\n\t\t\t\t\tReason: err,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// search the given container and its parent for matching group providers and\n// call them to commit values. If an error is encountered, return the number\n// of providers called and a non-nil error from the first provided.\nfunc (pt paramGroupedSlice) callGroupProviders(c containerStore) (int, error) {\n\titemCount := 0\n\tfor _, c := range c.storesToRoot() {\n\t\tproviders := c.getGroupProviders(pt.Group, pt.Type.Elem())\n\t\titemCount += len(providers)\n\t\tfor _, n := range providers {\n\t\t\tif err := n.Call(n.OrigScope()); err != nil {\n\t\t\t\treturn 0, errParamGroupFailed{\n\t\t\t\t\tCtorID: n.ID(),\n\t\t\t\t\tKey:    key{group: pt.Group, t: pt.Type.Elem()},\n\t\t\t\t\tReason: err,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn itemCount, nil\n}\n\nfunc (pt paramGroupedSlice) Build(c containerStore) (reflect.Value, error) {\n\t// do not call this if we are already inside a decorator since\n\t// it will result in an infinite recursion. (i.e. decorate -> params.BuildList() -> Decorate -> params.BuildList...)\n\t// this is safe since a value can be decorated at most once in a given scope.\n\tif err := pt.callGroupDecorators(c); err != nil {\n\t\treturn _noValue, err\n\t}\n\n\t// Check if we have decorated values\n\tif decoratedItems, ok := pt.getDecoratedValues(c); ok {\n\t\treturn decoratedItems, nil\n\t}\n\n\t// If we do not have any decorated values and the group isn't soft,\n\t// find the providers and call them.\n\titemCount := 0\n\tif !pt.Soft {\n\t\tvar err error\n\t\titemCount, err = pt.callGroupProviders(c)\n\t\tif err != nil {\n\t\t\treturn _noValue, err\n\t\t}\n\t}\n\n\tstores := c.storesToRoot()\n\tresult := reflect.MakeSlice(pt.Type, 0, itemCount)\n\tfor _, c := range stores {\n\t\tresult = reflect.Append(result, c.getValueGroup(pt.Group, pt.Type.Elem())...)\n\t}\n\treturn result, nil\n}\n\n// Checks if ignoring unexported files in an In struct is allowed.\n// The struct field MUST be an _inType.\nfunc isIgnoreUnexportedSet(f reflect.StructField) (bool, error) {\n\ttag := f.Tag.Get(_ignoreUnexportedTag)\n\tif tag == \"\" {\n\t\treturn false, nil\n\t}\n\n\tallowed, err := strconv.ParseBool(tag)\n\tif err != nil {\n\t\terr = newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"invalid value %q for %q tag on field %v\", tag, _ignoreUnexportedTag, f.Name), err)\n\t}\n\n\treturn allowed, err\n}\n"
        },
        {
          "name": "param_test.go",
          "type": "blob",
          "size": 5.9052734375,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"io\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestParamListBuild(t *testing.T) {\n\tp, err := newParamList(reflect.TypeOf(func() io.Writer { return nil }), newScope())\n\trequire.NoError(t, err)\n\tassert.Panics(t, func() {\n\t\tp.Build(newScope())\n\t})\n}\n\nfunc TestParamObjectSuccess(t *testing.T) {\n\ttype type1 struct{}\n\ttype type2 struct{}\n\ttype type3 struct{}\n\n\ttype in struct {\n\t\tIn\n\n\t\tT1 type1\n\t\tT2 type2 `optional:\"true\"`\n\t\tT3 type3 `name:\"foo\"`\n\n\t\tNested struct {\n\t\t\tIn\n\n\t\t\tA string\n\t\t\tB int32\n\t\t} `name:\"bar\"`\n\t}\n\n\tpo, err := newParamObject(reflect.TypeOf(in{}), newScope())\n\trequire.NoError(t, err)\n\n\trequire.Len(t, po.Fields, 4)\n\n\tt.Run(\"no tags\", func(t *testing.T) {\n\t\trequire.Equal(t, \"T1\", po.Fields[0].FieldName)\n\t\tt1, ok := po.Fields[0].Param.(paramSingle)\n\t\trequire.True(t, ok, \"T1 must be a paramSingle\")\n\t\tassert.Empty(t, t1.Name)\n\t\tassert.False(t, t1.Optional)\n\t})\n\n\tt.Run(\"optional field\", func(t *testing.T) {\n\t\trequire.Equal(t, \"T2\", po.Fields[1].FieldName)\n\n\t\tt2, ok := po.Fields[1].Param.(paramSingle)\n\t\trequire.True(t, ok, \"T2 must be a paramSingle\")\n\t\tassert.Empty(t, t2.Name)\n\t\tassert.True(t, t2.Optional)\n\t})\n\n\tt.Run(\"named value\", func(t *testing.T) {\n\t\trequire.Equal(t, \"T3\", po.Fields[2].FieldName)\n\t\tt3, ok := po.Fields[2].Param.(paramSingle)\n\t\trequire.True(t, ok, \"T3 must be a paramSingle\")\n\t\tassert.Equal(t, \"foo\", t3.Name)\n\t\tassert.False(t, t3.Optional)\n\t})\n\n\tt.Run(\"tags don't apply to nested dig.In\", func(t *testing.T) {\n\t\trequire.Equal(t, \"Nested\", po.Fields[3].FieldName)\n\t\tnested, ok := po.Fields[3].Param.(paramObject)\n\t\trequire.True(t, ok, \"Nested must be a paramObject\")\n\n\t\tassert.Len(t, nested.Fields, 2)\n\t\ta, ok := nested.Fields[0].Param.(paramSingle)\n\t\trequire.True(t, ok, \"Nested.A must be a paramSingle\")\n\t\tassert.Empty(t, a.Name, \"Nested.A must not have a name\")\n\t})\n}\n\nfunc TestParamObjectWithUnexportedFieldsSuccess(t *testing.T) {\n\ttype type1 struct{}\n\ttype type2 struct{}\n\n\ttype in struct {\n\t\tIn `ignore-unexported:\"true\"`\n\n\t\tT1 type1\n\t\tt2 type2\n\t}\n\n\t_ = in{}.t2 // unused\n\n\tpo, err := newParamObject(reflect.TypeOf(in{}), newScope())\n\trequire.NoError(t, err)\n\n\trequire.Len(t, po.Fields, 1)\n\n\trequire.Equal(t, \"T1\", po.Fields[0].FieldName)\n\tt1, ok := po.Fields[0].Param.(paramSingle)\n\trequire.True(t, ok, \"T1 must be a paramSingle\")\n\tassert.Empty(t, t1.Name)\n\tassert.False(t, t1.Optional)\n}\n\nfunc TestParamObjectFailure(t *testing.T) {\n\tt.Run(\"unexported field gets an error\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype in struct {\n\t\t\tIn\n\n\t\t\tA1 A\n\t\t\ta2 A\n\t\t}\n\n\t\t_ = in{}.a2 // unused but needed\n\n\t\t_, err := newParamObject(reflect.TypeOf(in{}), newScope())\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(),\n\t\t\t`bad field \"a2\" of dig.in: unexported fields not allowed in dig.In, did you mean to export \"a2\" (dig.A)`)\n\t})\n\n\tt.Run(\"unexported field with empty tag value gets an error\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype in struct {\n\t\t\tIn `ignore-unexported:\"\"`\n\n\t\t\tA1 A\n\t\t\ta2 A\n\t\t}\n\n\t\t_ = in{}.a2 // unused but needed\n\n\t\t_, err := newParamObject(reflect.TypeOf(in{}), newScope())\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(),\n\t\t\t`bad field \"a2\" of dig.in: unexported fields not allowed in dig.In, did you mean to export \"a2\" (dig.A)`)\n\t})\n\n\tt.Run(\"unexported field with invalid tag value gets an error\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype in struct {\n\t\t\tIn `ignore-unexported:\"foo\"`\n\n\t\t\tA1 A\n\t\t\ta2 A\n\t\t}\n\n\t\t_ = in{}.a2 // unused but needed\n\n\t\t_, err := newParamObject(reflect.TypeOf(in{}), newScope())\n\t\trequire.Error(t, err)\n\t\tassert.Contains(t, err.Error(),\n\t\t\t`invalid value \"foo\" for \"ignore-unexported\" tag on field In: strconv.ParseBool: parsing \"foo\": invalid syntax`)\n\t})\n}\n\nfunc TestParamGroupSliceErrors(t *testing.T) {\n\ttests := []struct {\n\t\tdesc    string\n\t\tshape   interface{}\n\t\twantErr string\n\t}{\n\t\t{\n\t\t\tdesc: \"non-slice type are disallowed\",\n\t\t\tshape: struct {\n\t\t\t\tIn\n\n\t\t\t\tFoo string `group:\"foo\"`\n\t\t\t}{},\n\t\t\twantErr: \"value groups may be consumed as slices only: \" +\n\t\t\t\t`field \"Foo\" (string) is not a slice`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"cannot provide name for a group\",\n\t\t\tshape: struct {\n\t\t\t\tIn\n\n\t\t\t\tFoo []string `group:\"foo\" name:\"bar\"`\n\t\t\t}{},\n\t\t\twantErr: \"cannot use named values with value groups: \" +\n\t\t\t\t`name:\"bar\" requested with group:\"foo\"`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"cannot be optional\",\n\t\t\tshape: struct {\n\t\t\t\tIn\n\n\t\t\t\tFoo []string `group:\"foo\" optional:\"true\"`\n\t\t\t}{},\n\t\t\twantErr: \"value groups cannot be optional\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"no flatten in In\",\n\t\t\tshape: struct {\n\t\t\t\tIn\n\n\t\t\t\tFoo []string `group:\"foo,flatten\"`\n\t\t\t}{},\n\t\t\twantErr: \"cannot use flatten in parameter value groups\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\t_, err := newParamObject(reflect.TypeOf(tt.shape), newScope())\n\t\t\trequire.Error(t, err, \"expected failure\")\n\t\t\tassert.Contains(t, err.Error(), tt.wantErr)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "provide.go",
          "type": "blob",
          "size": 18.9677734375,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"go.uber.org/dig/internal/digreflect\"\n\t\"go.uber.org/dig/internal/dot\"\n\t\"go.uber.org/dig/internal/graph\"\n)\n\n// A ProvideOption modifies the default behavior of Provide.\ntype ProvideOption interface {\n\tapplyProvideOption(*provideOptions)\n}\n\ntype provideOptions struct {\n\tName     string\n\tGroup    string\n\tInfo     *ProvideInfo\n\tAs       []interface{}\n\tLocation *digreflect.Func\n\tExported bool\n\tCallback Callback\n}\n\nfunc (o *provideOptions) Validate() error {\n\tif len(o.Group) > 0 {\n\t\tif len(o.Name) > 0 {\n\t\t\treturn newErrInvalidInput(\n\t\t\t\tfmt.Sprintf(\"cannot use named values with value groups: name:%q provided with group:%q\", o.Name, o.Group), nil)\n\t\t}\n\t}\n\n\t// Names must be representable inside a backquoted string. The only\n\t// limitation for raw string literals as per\n\t// https://golang.org/ref/spec#raw_string_lit is that they cannot contain\n\t// backquotes.\n\tif strings.ContainsRune(o.Name, '`') {\n\t\treturn newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"invalid dig.Name(%q): names cannot contain backquotes\", o.Name), nil)\n\t}\n\tif strings.ContainsRune(o.Group, '`') {\n\t\treturn newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"invalid dig.Group(%q): group names cannot contain backquotes\", o.Group), nil)\n\t}\n\n\tfor _, i := range o.As {\n\t\tt := reflect.TypeOf(i)\n\n\t\tif t == nil {\n\t\t\treturn newErrInvalidInput(\"invalid dig.As(nil): argument must be a pointer to an interface\", nil)\n\t\t}\n\n\t\tif t.Kind() != reflect.Ptr {\n\t\t\treturn newErrInvalidInput(\n\t\t\t\tfmt.Sprintf(\"invalid dig.As(%v): argument must be a pointer to an interface\", t), nil)\n\t\t}\n\n\t\tpointingTo := t.Elem()\n\t\tif pointingTo.Kind() != reflect.Interface {\n\t\t\treturn newErrInvalidInput(\n\t\t\t\tfmt.Sprintf(\"invalid dig.As(*%v): argument must be a pointer to an interface\", pointingTo), nil)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Name is a ProvideOption that specifies that all values produced by a\n// constructor should have the given name. See also the package documentation\n// about Named Values.\n//\n// Given,\n//\n//\tfunc NewReadOnlyConnection(...) (*Connection, error)\n//\tfunc NewReadWriteConnection(...) (*Connection, error)\n//\n// The following will provide two connections to the container: one under the\n// name \"ro\" and the other under the name \"rw\".\n//\n//\tc.Provide(NewReadOnlyConnection, dig.Name(\"ro\"))\n//\tc.Provide(NewReadWriteConnection, dig.Name(\"rw\"))\n//\n// This option cannot be provided for constructors which produce result\n// objects.\nfunc Name(name string) ProvideOption {\n\treturn provideNameOption(name)\n}\n\ntype provideNameOption string\n\nfunc (o provideNameOption) String() string {\n\treturn fmt.Sprintf(\"Name(%q)\", string(o))\n}\n\nfunc (o provideNameOption) applyProvideOption(opt *provideOptions) {\n\topt.Name = string(o)\n}\n\n// Group is a ProvideOption that specifies that all values produced by a\n// constructor should be added to the specified group. See also the package\n// documentation about Value Groups.\n//\n// This option cannot be provided for constructors which produce result\n// objects.\nfunc Group(group string) ProvideOption {\n\treturn provideGroupOption(group)\n}\n\ntype provideGroupOption string\n\nfunc (o provideGroupOption) String() string {\n\treturn fmt.Sprintf(\"Group(%q)\", string(o))\n}\n\nfunc (o provideGroupOption) applyProvideOption(opt *provideOptions) {\n\topt.Group = string(o)\n}\n\n// ID is a unique integer representing the constructor node in the dependency graph.\ntype ID int\n\n// ProvideInfo provides information about the constructor's inputs and outputs\n// types as strings, as well as the ID of the constructor supplied to the Container.\n// It contains ID for the constructor, as well as slices of Input and Output types,\n// which are Stringers that report the types of the parameters and results respectively.\ntype ProvideInfo struct {\n\tID      ID\n\tInputs  []*Input\n\tOutputs []*Output\n}\n\n// Input contains information on an input parameter of a function.\ntype Input struct {\n\tt           reflect.Type\n\toptional    bool\n\tname, group string\n}\n\nfunc (i *Input) String() string {\n\ttoks := make([]string, 0, 3)\n\tt := i.t.String()\n\tif i.optional {\n\t\ttoks = append(toks, \"optional\")\n\t}\n\tif i.name != \"\" {\n\t\ttoks = append(toks, fmt.Sprintf(\"name = %q\", i.name))\n\t}\n\tif i.group != \"\" {\n\t\ttoks = append(toks, fmt.Sprintf(\"group = %q\", i.group))\n\t}\n\n\tif len(toks) == 0 {\n\t\treturn t\n\t}\n\treturn fmt.Sprintf(\"%v[%v]\", t, strings.Join(toks, \", \"))\n}\n\n// Output contains information on an output produced by a function.\ntype Output struct {\n\tt           reflect.Type\n\tname, group string\n}\n\nfunc (o *Output) String() string {\n\ttoks := make([]string, 0, 2)\n\tt := o.t.String()\n\tif o.name != \"\" {\n\t\ttoks = append(toks, fmt.Sprintf(\"name = %q\", o.name))\n\t}\n\tif o.group != \"\" {\n\t\ttoks = append(toks, fmt.Sprintf(\"group = %q\", o.group))\n\t}\n\n\tif len(toks) == 0 {\n\t\treturn t\n\t}\n\treturn fmt.Sprintf(\"%v[%v]\", t, strings.Join(toks, \", \"))\n}\n\n// FillProvideInfo is a ProvideOption that writes info on what Dig was able to get\n// out of the provided constructor into the provided ProvideInfo.\nfunc FillProvideInfo(info *ProvideInfo) ProvideOption {\n\treturn fillProvideInfoOption{info: info}\n}\n\ntype fillProvideInfoOption struct{ info *ProvideInfo }\n\nfunc (o fillProvideInfoOption) String() string {\n\treturn fmt.Sprintf(\"FillProvideInfo(%p)\", o.info)\n}\n\nfunc (o fillProvideInfoOption) applyProvideOption(opts *provideOptions) {\n\topts.Info = o.info\n}\n\n// As is a ProvideOption that specifies that the value produced by the\n// constructor implements one or more other interfaces and is provided\n// to the container as those interfaces.\n//\n// As expects one or more pointers to the implemented interfaces. Values\n// produced by constructors will be then available in the container as\n// implementations of all of those interfaces, but not as the value itself.\n//\n// For example, the following will make io.Reader and io.Writer available\n// in the container, but not buffer.\n//\n//\tc.Provide(newBuffer, dig.As(new(io.Reader), new(io.Writer)))\n//\n// That is, the above is equivalent to the following.\n//\n//\tc.Provide(func(...) (io.Reader, io.Writer) {\n//\t  b := newBuffer(...)\n//\t  return b, b\n//\t})\n//\n// If used with dig.Name, the type produced by the constructor and the types\n// specified with dig.As will all use the same name. For example,\n//\n//\tc.Provide(newFile, dig.As(new(io.Reader)), dig.Name(\"temp\"))\n//\n// The above is equivalent to the following.\n//\n//\ttype Result struct {\n//\t  dig.Out\n//\n//\t  Reader io.Reader `name:\"temp\"`\n//\t}\n//\n//\tc.Provide(func(...) Result {\n//\t  f := newFile(...)\n//\t  return Result{\n//\t    Reader: f,\n//\t  }\n//\t})\n//\n// This option cannot be provided for constructors which produce result\n// objects.\nfunc As(i ...interface{}) ProvideOption {\n\treturn provideAsOption(i)\n}\n\ntype provideAsOption []interface{}\n\nfunc (o provideAsOption) String() string {\n\tbuf := bytes.NewBufferString(\"As(\")\n\tfor i, iface := range o {\n\t\tif i > 0 {\n\t\t\tbuf.WriteString(\", \")\n\t\t}\n\t\tbuf.WriteString(reflect.TypeOf(iface).Elem().String())\n\t}\n\tbuf.WriteString(\")\")\n\treturn buf.String()\n}\n\nfunc (o provideAsOption) applyProvideOption(opts *provideOptions) {\n\topts.As = append(opts.As, o...)\n}\n\n// LocationForPC is a ProvideOption which specifies an alternate function program\n// counter address to be used for debug information. The package, name, file and\n// line number of this alternate function address will be used in error messages\n// and DOT graphs. This option is intended to be used with functions created\n// with the reflect.MakeFunc method whose error messages are otherwise hard to\n// understand\nfunc LocationForPC(pc uintptr) ProvideOption {\n\treturn provideLocationOption{\n\t\tloc: digreflect.InspectFuncPC(pc),\n\t}\n}\n\ntype provideLocationOption struct{ loc *digreflect.Func }\n\nfunc (o provideLocationOption) String() string {\n\treturn fmt.Sprintf(\"LocationForPC(%v)\", o.loc)\n}\n\nfunc (o provideLocationOption) applyProvideOption(opts *provideOptions) {\n\topts.Location = o.loc\n}\n\n// Export is a ProvideOption which specifies that the provided function should\n// be made available to all Scopes available in the application, regardless\n// of which Scope it was provided from. By default, it is false.\n//\n// For example,\n//\n//\tc := New()\n//\ts1 := c.Scope(\"child 1\")\n//\ts2:= c.Scope(\"child 2\")\n//\ts1.Provide(func() *bytes.Buffer { ... })\n//\n// does not allow the constructor returning *bytes.Buffer to be made available to\n// the root Container c or its sibling Scope s2.\n//\n// With Export, you can make this constructor available to all the Scopes:\n//\n//\ts1.Provide(func() *bytes.Buffer { ... }, Export(true))\nfunc Export(export bool) ProvideOption {\n\treturn provideExportOption{exported: export}\n}\n\ntype provideExportOption struct{ exported bool }\n\nfunc (o provideExportOption) String() string {\n\treturn fmt.Sprintf(\"Export(%v)\", o.exported)\n}\n\nfunc (o provideExportOption) applyProvideOption(opts *provideOptions) {\n\topts.Exported = o.exported\n}\n\n// provider encapsulates a user-provided constructor.\ntype provider interface {\n\t// ID is a unique numerical identifier for this provider.\n\tID() dot.CtorID\n\n\t// Order reports the order of this provider in the graphHolder.\n\t// This value is usually returned by the graphHolder.NewNode method.\n\tOrder(*Scope) int\n\n\t// Location returns where this constructor was defined.\n\tLocation() *digreflect.Func\n\n\t// ParamList returns information about the direct dependencies of this\n\t// constructor.\n\tParamList() paramList\n\n\t// ResultList returns information about the values produced by this\n\t// constructor.\n\tResultList() resultList\n\n\t// Calls the underlying constructor, reading values from the\n\t// containerStore as needed.\n\t//\n\t// The values produced by this provider should be submitted into the\n\t// containerStore.\n\tCall(containerStore) error\n\n\tCType() reflect.Type\n\n\tOrigScope() *Scope\n}\n\n// Provide teaches the container how to build values of one or more types and\n// expresses their dependencies.\n//\n// The first argument of Provide is a function that accepts zero or more\n// parameters and returns one or more results. The function may optionally\n// return an error to indicate that it failed to build the value. This\n// function will be treated as the constructor for all the types it returns.\n// This function will be called AT MOST ONCE when a type produced by it, or a\n// type that consumes this function's output, is requested via Invoke. If the\n// same types are requested multiple times, the previously produced value will\n// be reused.\n//\n// Provide accepts argument types or dig.In structs as dependencies, and\n// separate return values or dig.Out structs for results.\nfunc (c *Container) Provide(constructor interface{}, opts ...ProvideOption) error {\n\treturn c.scope.Provide(constructor, opts...)\n}\n\n// Provide teaches the Scope how to build values of one or more types and\n// expresses their dependencies.\n//\n// The first argument of Provide is a function that accepts zero or more\n// parameters and returns one or more results. The function may optionally\n// return an error to indicate that it failed to build the value. This\n// function will be treated as the constructor for all the types it returns.\n// This function will be called AT MOST ONCE when a type produced by it, or a\n// type that consumes this function's output, is requested via Invoke. If the\n// same types are requested multiple times, the previously produced value will\n// be reused.\n//\n// Provide accepts argument types or dig.In structs as dependencies, and\n// separate return values or dig.Out structs for results.\n//\n// When a constructor is Provided to a Scope, it will propagate this to any\n// Scopes that are descendents, but not ancestors of this Scope.\n// To provide a constructor to all the Scopes available, provide it to\n// Container, which is the root Scope.\nfunc (s *Scope) Provide(constructor interface{}, opts ...ProvideOption) error {\n\tctype := reflect.TypeOf(constructor)\n\tif ctype == nil {\n\t\treturn newErrInvalidInput(\"can't provide an untyped nil\", nil)\n\t}\n\tif ctype.Kind() != reflect.Func {\n\t\treturn newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"must provide constructor function, got %v (type %v)\", constructor, ctype), nil)\n\t}\n\n\tvar options provideOptions\n\tfor _, o := range opts {\n\t\to.applyProvideOption(&options)\n\t}\n\tif err := options.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.provide(constructor, options); err != nil {\n\t\tvar errFunc *digreflect.Func\n\t\tif options.Location == nil {\n\t\t\terrFunc = digreflect.InspectFunc(constructor)\n\t\t} else {\n\t\t\terrFunc = options.Location\n\t\t}\n\n\t\treturn errProvide{\n\t\t\tFunc:   errFunc,\n\t\t\tReason: err,\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *Scope) provide(ctor interface{}, opts provideOptions) (err error) {\n\t// If Export option is provided to the constructor, this should be injected to the\n\t// root-level Scope (Container) to allow it to propagate to all other Scopes.\n\torigScope := s\n\tif opts.Exported {\n\t\ts = s.rootScope()\n\t}\n\n\t// For all scopes affected by this change,\n\t// take a snapshot of the current graph state before\n\t// we start making changes to it as we may need to\n\t// undo them upon encountering errors.\n\tallScopes := s.appendSubscopes(nil)\n\tfor _, s := range allScopes {\n\t\ts := s\n\t\ts.gh.Snapshot()\n\t\tdefer func() {\n\t\t\tif err != nil {\n\t\t\t\ts.gh.Rollback()\n\t\t\t}\n\t\t}()\n\t}\n\n\tn, err := newConstructorNode(\n\t\tctor,\n\t\ts,\n\t\torigScope,\n\t\tconstructorOptions{\n\t\t\tResultName:  opts.Name,\n\t\t\tResultGroup: opts.Group,\n\t\t\tResultAs:    opts.As,\n\t\t\tLocation:    opts.Location,\n\t\t\tCallback:    opts.Callback,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkeys, err := s.findAndValidateResults(n.ResultList())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tctype := reflect.TypeOf(ctor)\n\tif len(keys) == 0 {\n\t\treturn newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"%v must provide at least one non-error type\", ctype), nil)\n\t}\n\n\toldProviders := make(map[key][]*constructorNode)\n\tfor k := range keys {\n\t\t// Cache old providers before running cycle detection.\n\t\toldProviders[k] = s.providers[k]\n\t\ts.providers[k] = append(s.providers[k], n)\n\t}\n\n\tfor _, s := range allScopes {\n\t\ts.isVerifiedAcyclic = false\n\t\tif s.deferAcyclicVerification {\n\t\t\tcontinue\n\t\t}\n\t\tif ok, cycle := graph.IsAcyclic(s.gh); !ok {\n\t\t\t// When a cycle is detected, recover the old providers to reset\n\t\t\t// the providers map back to what it was before this node was\n\t\t\t// introduced.\n\t\t\tfor k, ops := range oldProviders {\n\t\t\t\ts.providers[k] = ops\n\t\t\t}\n\n\t\t\treturn newErrInvalidInput(\"this function introduces a cycle\", s.cycleDetectedError(cycle))\n\t\t}\n\t\ts.isVerifiedAcyclic = true\n\t}\n\n\ts.nodes = append(s.nodes, n)\n\n\t// Record introspection info for caller if Info option is specified\n\tif info := opts.Info; info != nil {\n\t\tparams := n.ParamList().DotParam()\n\t\tresults := n.ResultList().DotResult()\n\n\t\tinfo.ID = (ID)(n.id)\n\t\tinfo.Inputs = make([]*Input, len(params))\n\t\tinfo.Outputs = make([]*Output, len(results))\n\n\t\tfor i, param := range params {\n\t\t\tinfo.Inputs[i] = &Input{\n\t\t\t\tt:        param.Type,\n\t\t\t\toptional: param.Optional,\n\t\t\t\tname:     param.Name,\n\t\t\t\tgroup:    param.Group,\n\t\t\t}\n\t\t}\n\n\t\tfor i, res := range results {\n\t\t\tinfo.Outputs[i] = &Output{\n\t\t\t\tt:     res.Type,\n\t\t\t\tname:  res.Name,\n\t\t\t\tgroup: res.Group,\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Builds a collection of all result types produced by this constructor.\nfunc (s *Scope) findAndValidateResults(rl resultList) (map[key]struct{}, error) {\n\tvar err error\n\tkeyPaths := make(map[key]string)\n\twalkResult(rl, connectionVisitor{\n\t\ts:        s,\n\t\terr:      &err,\n\t\tkeyPaths: keyPaths,\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeys := make(map[key]struct{}, len(keyPaths))\n\tfor k := range keyPaths {\n\t\tkeys[k] = struct{}{}\n\t}\n\treturn keys, nil\n}\n\n// Visits the results of a node and compiles a collection of all the keys\n// produced by that node.\ntype connectionVisitor struct {\n\ts *Scope\n\n\t// If this points to a non-nil value, we've already encountered an error\n\t// and should stop traversing.\n\terr *error\n\n\t// Map of keys provided to path that provided this. The path is a string\n\t// documenting which positional return value or dig.Out attribute is\n\t// providing this particular key.\n\t//\n\t// For example, \"[0].Foo\" indicates that the value was provided by the Foo\n\t// attribute of the dig.Out returned as the first result of the\n\t// constructor.\n\tkeyPaths map[key]string\n\n\t// We track the path to the current result here. For example, this will\n\t// be, [\"[1]\", \"Foo\", \"Bar\"] when we're visiting Bar in,\n\t//\n\t//   func() (io.Writer, struct {\n\t//     dig.Out\n\t//\n\t//     Foo struct {\n\t//       dig.Out\n\t//\n\t//       Bar io.Reader\n\t//     }\n\t//   })\n\tcurrentResultPath []string\n}\n\nfunc (cv connectionVisitor) AnnotateWithField(f resultObjectField) resultVisitor {\n\tcv.currentResultPath = append(cv.currentResultPath, f.FieldName)\n\treturn cv\n}\n\nfunc (cv connectionVisitor) AnnotateWithPosition(i int) resultVisitor {\n\tcv.currentResultPath = append(cv.currentResultPath, fmt.Sprintf(\"[%d]\", i))\n\treturn cv\n}\n\nfunc (cv connectionVisitor) Visit(res result) resultVisitor {\n\t// Already failed. Stop looking.\n\tif *cv.err != nil {\n\t\treturn nil\n\t}\n\n\tpath := strings.Join(cv.currentResultPath, \".\")\n\n\tswitch r := res.(type) {\n\n\tcase resultSingle:\n\t\tk := key{name: r.Name, t: r.Type}\n\n\t\tif err := cv.checkKey(k, path); err != nil {\n\t\t\t*cv.err = err\n\t\t\treturn nil\n\t\t}\n\t\tfor _, asType := range r.As {\n\t\t\tk := key{name: r.Name, t: asType}\n\t\t\tif err := cv.checkKey(k, path); err != nil {\n\t\t\t\t*cv.err = err\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\tcase resultGrouped:\n\t\t// we don't really care about the path for this since conflicts are\n\t\t// okay for group results. We'll track it for the sake of having a\n\t\t// value there.\n\t\tk := key{group: r.Group, t: r.Type}\n\t\tcv.keyPaths[k] = path\n\t\tfor _, asType := range r.As {\n\t\t\tk := key{group: r.Group, t: asType}\n\t\t\tcv.keyPaths[k] = path\n\t\t}\n\t}\n\n\treturn cv\n}\n\nfunc (cv connectionVisitor) checkKey(k key, path string) error {\n\tdefer func() { cv.keyPaths[k] = path }()\n\tif conflict, ok := cv.keyPaths[k]; ok {\n\t\treturn newErrInvalidInput(fmt.Sprintf(\"cannot provide %v from %v\", k, path),\n\t\t\tnewErrInvalidInput(fmt.Sprintf(\"already provided by %v\", conflict), nil))\n\t}\n\tif ps := cv.s.providers[k]; len(ps) > 0 {\n\t\tcons := make([]string, len(ps))\n\t\tfor i, p := range ps {\n\t\t\tcons[i] = fmt.Sprint(p.Location())\n\t\t}\n\n\t\treturn newErrInvalidInput(fmt.Sprintf(\"cannot provide %v from %v\", k, path),\n\t\t\tnewErrInvalidInput(fmt.Sprintf(\"already provided by %v\", strings.Join(cons, \"; \")), nil))\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "provide_test.go",
          "type": "blob",
          "size": 2.4990234375,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestProvideOptionStrings(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdesc string\n\t\tgive ProvideOption\n\t\twant string\n\t}{\n\t\t{\n\t\t\tdesc: \"Name\",\n\t\t\tgive: Name(\"foo\"),\n\t\t\twant: `Name(\"foo\")`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"Group\",\n\t\t\tgive: Group(\"bar\"),\n\t\t\twant: `Group(\"bar\")`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"As\",\n\t\t\tgive: As(new(io.Reader), new(io.Writer)),\n\t\t\twant: `As(io.Reader, io.Writer)`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tassert.Equal(t, tt.want, fmt.Sprint(tt.give))\n\t\t})\n\t}\n}\n\nfunc TestFillProvideInfoString(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tassert.Equal(t, \"FillProvideInfo(0x0)\", fmt.Sprint(FillProvideInfo(nil)))\n\t})\n\n\tt.Run(\"not nil\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\topt := FillProvideInfo(new(ProvideInfo))\n\t\tassert.NotEqual(t, fmt.Sprint(opt), \"FillProvideInfo(0x0)\")\n\t\tassert.Contains(t, fmt.Sprint(opt), \"FillProvideInfo(0x\")\n\t})\n}\n\nfunc TestLocationForPCString(t *testing.T) {\n\topt := LocationForPC(reflect.ValueOf(func() {}).Pointer())\n\tassert.Contains(t, fmt.Sprint(opt), `LocationForPC(\"go.uber.org/dig\".TestLocationForPCString.func1 `)\n}\n\nfunc TestExportString(t *testing.T) {\n\tassert.Equal(t, fmt.Sprint(Export(true)), \"Export(true)\")\n\tassert.Equal(t, fmt.Sprint(Export(false)), \"Export(false)\")\n}\n"
        },
        {
          "name": "result.go",
          "type": "blob",
          "size": 14.869140625,
          "content": "// Copyright (c) 2019-2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"go.uber.org/dig/internal/digerror\"\n\t\"go.uber.org/dig/internal/dot\"\n)\n\n// The result interface represents a result produced by a constructor.\n//\n// The following implementations exist:\n//   resultList    All values returned by the constructor.\n//   resultSingle  A single value produced by a constructor.\n//   resultObject  dig.Out struct where each field in the struct can be\n//                 another result.\n//   resultGrouped A value produced by a constructor that is part of a value\n//                 group.\n\ntype result interface {\n\t// Extracts the values for this result from the provided value and\n\t// stores them into the provided containerWriter.\n\t//\n\t// This MAY panic if the result does not consume a single value.\n\tExtract(containerWriter, bool, reflect.Value)\n\n\t// DotResult returns a slice of dot.Result(s).\n\tDotResult() []*dot.Result\n}\n\nvar (\n\t_ result = resultSingle{}\n\t_ result = resultObject{}\n\t_ result = resultList{}\n\t_ result = resultGrouped{}\n)\n\ntype resultOptions struct {\n\t// If set, this is the name of the associated result value.\n\t//\n\t// For Result Objects, name:\"..\" tags on fields override this.\n\tName  string\n\tGroup string\n\tAs    []interface{}\n}\n\n// newResult builds a result from the given type.\nfunc newResult(t reflect.Type, opts resultOptions) (result, error) {\n\tswitch {\n\tcase IsIn(t) || (t.Kind() == reflect.Ptr && IsIn(t.Elem())) || embedsType(t, _inPtrType):\n\t\treturn nil, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot provide parameter objects: %v embeds a dig.In\", t), nil)\n\tcase isError(t):\n\t\treturn nil, newErrInvalidInput(\"cannot return an error here, return it from the constructor instead\", nil)\n\tcase IsOut(t):\n\t\treturn newResultObject(t, opts)\n\tcase embedsType(t, _outPtrType):\n\t\treturn nil, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot build a result object by embedding *dig.Out, embed dig.Out instead: %v embeds *dig.Out\", t), nil)\n\tcase t.Kind() == reflect.Ptr && IsOut(t.Elem()):\n\t\treturn nil, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot return a pointer to a result object, use a value instead: %v is a pointer to a struct that embeds dig.Out\", t), nil)\n\tcase len(opts.Group) > 0:\n\t\tg, err := parseGroupString(opts.Group)\n\t\tif err != nil {\n\t\t\treturn nil, newErrInvalidInput(\n\t\t\t\tfmt.Sprintf(\"cannot parse group %q\", opts.Group), err)\n\t\t}\n\t\trg := resultGrouped{Type: t, Group: g.Name, Flatten: g.Flatten}\n\t\tif len(opts.As) > 0 {\n\t\t\tvar asTypes []reflect.Type\n\t\t\tfor _, as := range opts.As {\n\t\t\t\tifaceType := reflect.TypeOf(as).Elem()\n\t\t\t\tif ifaceType == t {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif !t.Implements(ifaceType) {\n\t\t\t\t\treturn nil, newErrInvalidInput(\n\t\t\t\t\t\tfmt.Sprintf(\"invalid dig.As: %v does not implement %v\", t, ifaceType), nil)\n\t\t\t\t}\n\t\t\t\tasTypes = append(asTypes, ifaceType)\n\t\t\t}\n\t\t\tif len(asTypes) > 0 {\n\t\t\t\trg.Type = asTypes[0]\n\t\t\t\trg.As = asTypes[1:]\n\t\t\t}\n\t\t}\n\t\tif g.Soft {\n\t\t\treturn nil, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\t\"cannot use soft with result value groups: soft was used with group:%q\", g.Name), nil)\n\t\t}\n\t\tif g.Flatten {\n\t\t\tif t.Kind() != reflect.Slice {\n\t\t\t\treturn nil, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\t\t\"flatten can be applied to slices only: %v is not a slice\", t), nil)\n\t\t\t}\n\t\t\trg.Type = rg.Type.Elem()\n\t\t}\n\t\treturn rg, nil\n\tdefault:\n\t\treturn newResultSingle(t, opts)\n\t}\n}\n\n// resultVisitor visits every result in a result tree, allowing tracking state\n// at each level.\ntype resultVisitor interface {\n\t// Visit is called on the result being visited.\n\t//\n\t// If Visit returns a non-nil resultVisitor, that resultVisitor visits all\n\t// the child results of this result.\n\tVisit(result) resultVisitor\n\n\t// AnnotateWithField is called on each field of a resultObject after\n\t// visiting it but before walking its descendants.\n\t//\n\t// The same resultVisitor is used for all fields: the one returned upon\n\t// visiting the resultObject.\n\t//\n\t// For each visited field, if AnnotateWithField returns a non-nil\n\t// resultVisitor, it will be used to walk the result of that field.\n\tAnnotateWithField(resultObjectField) resultVisitor\n\n\t// AnnotateWithPosition is called with the index of each result of a\n\t// resultList after vising it but before walking its descendants.\n\t//\n\t// The same resultVisitor is used for all results: the one returned upon\n\t// visiting the resultList.\n\t//\n\t// For each position, if AnnotateWithPosition returns a non-nil\n\t// resultVisitor, it will be used to walk the result at that index.\n\tAnnotateWithPosition(idx int) resultVisitor\n}\n\n// walkResult walks the result tree for the given result with the provided\n// visitor.\n//\n// resultVisitor.Visit will be called on the provided result and if a non-nil\n// resultVisitor is received, it will be used to walk its descendants. If a\n// resultObject or resultList was visited, AnnotateWithField and\n// AnnotateWithPosition respectively will be called before visiting the\n// descendants of that resultObject/resultList.\n//\n// This is very similar to how go/ast.Walk works.\nfunc walkResult(r result, v resultVisitor) {\n\tv = v.Visit(r)\n\tif v == nil {\n\t\treturn\n\t}\n\n\tswitch res := r.(type) {\n\tcase resultSingle, resultGrouped:\n\t\t// No sub-results\n\tcase resultObject:\n\t\tw := v\n\t\tfor _, f := range res.Fields {\n\t\t\tif v := w.AnnotateWithField(f); v != nil {\n\t\t\t\twalkResult(f.Result, v)\n\t\t\t}\n\t\t}\n\tcase resultList:\n\t\tw := v\n\t\tfor i, r := range res.Results {\n\t\t\tif v := w.AnnotateWithPosition(i); v != nil {\n\t\t\t\twalkResult(r, v)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tdigerror.BugPanicf(\"received unknown result type %T\", res)\n\t}\n}\n\n// resultList holds all values returned by the constructor as results.\ntype resultList struct {\n\tctype reflect.Type\n\n\tResults []result\n\n\t// For each item at index i returned by the constructor, resultIndexes[i]\n\t// is the index in .Results for the corresponding result object.\n\t// resultIndexes[i] is -1 for errors returned by constructors.\n\tresultIndexes []int\n}\n\nfunc (rl resultList) DotResult() []*dot.Result {\n\tvar types []*dot.Result\n\tfor _, result := range rl.Results {\n\t\ttypes = append(types, result.DotResult()...)\n\t}\n\treturn types\n}\n\nfunc newResultList(ctype reflect.Type, opts resultOptions) (resultList, error) {\n\tnumOut := ctype.NumOut()\n\trl := resultList{\n\t\tctype:         ctype,\n\t\tResults:       make([]result, 0, numOut),\n\t\tresultIndexes: make([]int, numOut),\n\t}\n\n\tresultIdx := 0\n\tfor i := 0; i < numOut; i++ {\n\t\tt := ctype.Out(i)\n\t\tif isError(t) {\n\t\t\trl.resultIndexes[i] = -1\n\t\t\tcontinue\n\t\t}\n\n\t\tr, err := newResult(t, opts)\n\t\tif err != nil {\n\t\t\treturn rl, newErrInvalidInput(fmt.Sprintf(\"bad result %d\", i+1), err)\n\t\t}\n\n\t\trl.Results = append(rl.Results, r)\n\t\trl.resultIndexes[i] = resultIdx\n\t\tresultIdx++\n\t}\n\n\treturn rl, nil\n}\n\nfunc (resultList) Extract(containerWriter, bool, reflect.Value) {\n\tdigerror.BugPanicf(\"resultList.Extract() must never be called\")\n}\n\nfunc (rl resultList) ExtractList(cw containerWriter, decorated bool, values []reflect.Value) error {\n\tfor i, v := range values {\n\t\tif resultIdx := rl.resultIndexes[i]; resultIdx >= 0 {\n\t\t\trl.Results[resultIdx].Extract(cw, decorated, v)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err, _ := v.Interface().(error); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// resultSingle is an explicit value produced by a constructor, optionally\n// with a name.\n//\n// This object will be added to the graph as-is.\ntype resultSingle struct {\n\tName string\n\tType reflect.Type\n\n\t// If specified, this is a list of types which the value will be made\n\t// available as, in addition to its own type.\n\tAs []reflect.Type\n}\n\nfunc newResultSingle(t reflect.Type, opts resultOptions) (resultSingle, error) {\n\tr := resultSingle{\n\t\tType: t,\n\t\tName: opts.Name,\n\t}\n\n\tvar asTypes []reflect.Type\n\n\tfor _, as := range opts.As {\n\t\tifaceType := reflect.TypeOf(as).Elem()\n\t\tif ifaceType == t {\n\t\t\t// Special case:\n\t\t\t//   c.Provide(func() io.Reader, As(new(io.Reader)))\n\t\t\t// Ignore instead of erroring out.\n\t\t\tcontinue\n\t\t}\n\t\tif !t.Implements(ifaceType) {\n\t\t\treturn r, newErrInvalidInput(\n\t\t\t\tfmt.Sprintf(\"invalid dig.As: %v does not implement %v\", t, ifaceType), nil)\n\t\t}\n\t\tasTypes = append(asTypes, ifaceType)\n\t}\n\n\tif len(asTypes) == 0 {\n\t\treturn r, nil\n\t}\n\n\treturn resultSingle{\n\t\tType: asTypes[0],\n\t\tName: opts.Name,\n\t\tAs:   asTypes[1:],\n\t}, nil\n}\n\nfunc (rs resultSingle) DotResult() []*dot.Result {\n\tdotResults := make([]*dot.Result, 0, len(rs.As)+1)\n\tdotResults = append(dotResults, &dot.Result{\n\t\tNode: &dot.Node{\n\t\t\tType: rs.Type,\n\t\t\tName: rs.Name,\n\t\t},\n\t})\n\n\tfor _, asType := range rs.As {\n\t\tdotResults = append(dotResults, &dot.Result{\n\t\t\tNode: &dot.Node{Type: asType, Name: rs.Name},\n\t\t})\n\t}\n\n\treturn dotResults\n}\n\nfunc (rs resultSingle) Extract(cw containerWriter, decorated bool, v reflect.Value) {\n\tif decorated {\n\t\tcw.setDecoratedValue(rs.Name, rs.Type, v)\n\t\treturn\n\t}\n\tcw.setValue(rs.Name, rs.Type, v)\n\n\tfor _, asType := range rs.As {\n\t\tcw.setValue(rs.Name, asType, v)\n\t}\n}\n\n// resultObject is a dig.Out struct where each field is another result.\n//\n// This object is not added to the graph. Its fields are interpreted as\n// results and added to the graph if needed.\ntype resultObject struct {\n\tType   reflect.Type\n\tFields []resultObjectField\n}\n\nfunc (ro resultObject) DotResult() []*dot.Result {\n\tvar types []*dot.Result\n\tfor _, field := range ro.Fields {\n\t\ttypes = append(types, field.DotResult()...)\n\t}\n\treturn types\n}\n\nfunc newResultObject(t reflect.Type, opts resultOptions) (resultObject, error) {\n\tro := resultObject{Type: t}\n\tif len(opts.Name) > 0 {\n\t\treturn ro, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot specify a name for result objects: %v embeds dig.Out\", t), nil)\n\t}\n\n\tif len(opts.Group) > 0 {\n\t\treturn ro, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot specify a group for result objects: %v embeds dig.Out\", t), nil)\n\t}\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tf := t.Field(i)\n\t\tif f.Type == _outType {\n\t\t\t// Skip over the dig.Out embed.\n\t\t\tcontinue\n\t\t}\n\n\t\trof, err := newResultObjectField(i, f, opts)\n\t\tif err != nil {\n\t\t\treturn ro, newErrInvalidInput(fmt.Sprintf(\"bad field %q of %v\", f.Name, t), err)\n\t\t}\n\n\t\tro.Fields = append(ro.Fields, rof)\n\t}\n\treturn ro, nil\n}\n\nfunc (ro resultObject) Extract(cw containerWriter, decorated bool, v reflect.Value) {\n\tfor _, f := range ro.Fields {\n\t\tf.Result.Extract(cw, decorated, v.Field(f.FieldIndex))\n\t}\n}\n\n// resultObjectField is a single field inside a dig.Out struct.\ntype resultObjectField struct {\n\t// Name of the field in the struct.\n\tFieldName string\n\n\t// Index of the field in the struct.\n\t//\n\t// We need to track this separately because not all fields of the struct\n\t// map to results.\n\tFieldIndex int\n\n\t// Result produced by this field.\n\tResult result\n}\n\nfunc (rof resultObjectField) DotResult() []*dot.Result {\n\treturn rof.Result.DotResult()\n}\n\n// newResultObjectField(i, f, opts) builds a resultObjectField from the field\n// f at index i.\nfunc newResultObjectField(idx int, f reflect.StructField, opts resultOptions) (resultObjectField, error) {\n\trof := resultObjectField{\n\t\tFieldName:  f.Name,\n\t\tFieldIndex: idx,\n\t}\n\n\tvar r result\n\tswitch {\n\tcase f.PkgPath != \"\":\n\t\treturn rof, newErrInvalidInput(\n\t\t\tfmt.Sprintf(\"unexported fields not allowed in dig.Out, did you mean to export %q (%v)?\", f.Name, f.Type), nil)\n\n\tcase f.Tag.Get(_groupTag) != \"\":\n\t\tvar err error\n\t\tr, err = newResultGrouped(f)\n\t\tif err != nil {\n\t\t\treturn rof, err\n\t\t}\n\n\tdefault:\n\t\tvar err error\n\t\tif name := f.Tag.Get(_nameTag); len(name) > 0 {\n\t\t\t// can modify in-place because options are passed-by-value.\n\t\t\topts.Name = name\n\t\t}\n\t\tr, err = newResult(f.Type, opts)\n\t\tif err != nil {\n\t\t\treturn rof, err\n\t\t}\n\t}\n\n\trof.Result = r\n\treturn rof, nil\n}\n\n// resultGrouped is a value produced by a constructor that is part of a result\n// group.\n//\n// These will be produced as fields of a dig.Out struct.\ntype resultGrouped struct {\n\t// Name of the group as specified in the `group:\"..\"` tag.\n\tGroup string\n\n\t// Type of value produced.\n\tType reflect.Type\n\n\t// Indicates elements of a value are to be injected individually, instead of\n\t// as a group. Requires the value's slice to be a group. If set, Type will be\n\t// the type of individual elements rather than the group.\n\tFlatten bool\n\n\t// If specified, this is a list of types which the value will be made\n\t// available as, in addition to its own type.\n\tAs []reflect.Type\n}\n\nfunc (rt resultGrouped) DotResult() []*dot.Result {\n\tdotResults := make([]*dot.Result, 0, len(rt.As)+1)\n\tdotResults = append(dotResults, &dot.Result{\n\t\tNode: &dot.Node{\n\t\t\tType:  rt.Type,\n\t\t\tGroup: rt.Group,\n\t\t},\n\t})\n\n\tfor _, asType := range rt.As {\n\t\tdotResults = append(dotResults, &dot.Result{\n\t\t\tNode: &dot.Node{Type: asType, Group: rt.Group},\n\t\t})\n\t}\n\treturn dotResults\n}\n\n// newResultGrouped(f) builds a new resultGrouped from the provided field.\nfunc newResultGrouped(f reflect.StructField) (resultGrouped, error) {\n\tg, err := parseGroupString(f.Tag.Get(_groupTag))\n\tif err != nil {\n\t\treturn resultGrouped{}, err\n\t}\n\trg := resultGrouped{\n\t\tGroup:   g.Name,\n\t\tFlatten: g.Flatten,\n\t\tType:    f.Type,\n\t}\n\tname := f.Tag.Get(_nameTag)\n\toptional, _ := isFieldOptional(f)\n\tswitch {\n\tcase g.Flatten && f.Type.Kind() != reflect.Slice:\n\t\treturn rg, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"flatten can be applied to slices only: field %q (%v) is not a slice\", f.Name, f.Type), nil)\n\tcase g.Soft:\n\t\treturn rg, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot use soft with result value groups: soft was used with group %q\", rg.Group), nil)\n\tcase name != \"\":\n\t\treturn rg, newErrInvalidInput(fmt.Sprintf(\n\t\t\t\"cannot use named values with value groups: name:%q provided with group:%q\", name, rg.Group), nil)\n\tcase optional:\n\t\treturn rg, newErrInvalidInput(\"value groups cannot be optional\", nil)\n\t}\n\tif g.Flatten {\n\t\trg.Type = f.Type.Elem()\n\t}\n\n\treturn rg, nil\n}\n\nfunc (rt resultGrouped) Extract(cw containerWriter, decorated bool, v reflect.Value) {\n\t// Decorated values are always flattened.\n\tif !decorated && !rt.Flatten {\n\t\tcw.submitGroupedValue(rt.Group, rt.Type, v)\n\t\tfor _, asType := range rt.As {\n\t\t\tcw.submitGroupedValue(rt.Group, asType, v)\n\t\t}\n\t\treturn\n\t}\n\n\tif decorated {\n\t\tcw.submitDecoratedGroupedValue(rt.Group, rt.Type, v)\n\t\treturn\n\t}\n\tfor i := 0; i < v.Len(); i++ {\n\t\tcw.submitGroupedValue(rt.Group, rt.Type, v.Index(i))\n\t}\n}\n"
        },
        {
          "name": "result_test.go",
          "type": "blob",
          "size": 10.5439453125,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestNewResultListErrors(t *testing.T) {\n\ttests := []struct {\n\t\tdesc      string\n\t\tgive      interface{}\n\t\twantError string\n\t}{\n\t\t{\n\t\t\tdesc:      \"returns dig.In\",\n\t\t\tgive:      func() struct{ In } { panic(\"invalid\") },\n\t\t\twantError: \"struct { dig.In } embeds a dig.In\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"returns dig.Out+dig.In\",\n\t\t\tgive: func() struct {\n\t\t\t\tOut\n\t\t\t\tIn\n\t\t\t} {\n\t\t\t\tpanic(\"invalid\")\n\t\t\t},\n\t\t\twantError: \"struct { dig.Out; dig.In } embeds a dig.In\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\t_, err := newResultList(reflect.TypeOf(tt.give), resultOptions{})\n\t\t\trequire.Error(t, err)\n\t\t\tAssertErrorMatches(t, err,\n\t\t\t\t\"bad result 1:\",\n\t\t\t\t`cannot provide parameter objects: `+tt.wantError)\n\t\t})\n\t}\n}\n\nfunc TestResultListExtractFails(t *testing.T) {\n\trl, err := newResultList(reflect.TypeOf(func() (io.Writer, error) {\n\t\tpanic(\"function should not be called\")\n\t}), resultOptions{})\n\trequire.NoError(t, err)\n\tassert.Panics(t, func() {\n\t\trl.Extract(newStagingContainerWriter(), false, reflect.ValueOf(\"irrelevant\"))\n\t})\n}\n\nfunc TestNewResultErrors(t *testing.T) {\n\ttype outPtr struct{ *Out }\n\ttype out struct{ Out }\n\ttype in struct{ In }\n\ttype inOut struct {\n\t\tIn\n\t\tOut\n\t}\n\n\ttests := []struct {\n\t\tgive interface{}\n\t\terr  string\n\t}{\n\t\t{\n\t\t\tgive: outPtr{},\n\t\t\terr:  \"cannot build a result object by embedding *dig.Out, embed dig.Out instead: dig.outPtr embeds *dig.Out\",\n\t\t},\n\t\t{\n\t\t\tgive: (*out)(nil),\n\t\t\terr:  \"cannot return a pointer to a result object, use a value instead: *dig.out is a pointer to a struct that embeds dig.Out\",\n\t\t},\n\t\t{\n\t\t\tgive: in{},\n\t\t\terr:  \"cannot provide parameter objects: dig.in embeds a dig.In\",\n\t\t},\n\t\t{\n\t\t\tgive: inOut{},\n\t\t\terr:  \"cannot provide parameter objects: dig.inOut embeds a dig.In\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgive := reflect.TypeOf(tt.give)\n\t\tt.Run(fmt.Sprint(give), func(t *testing.T) {\n\t\t\t_, err := newResult(give, resultOptions{})\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), tt.err)\n\t\t})\n\t}\n}\n\nfunc TestNewResultObject(t *testing.T) {\n\ttypeOfReader := reflect.TypeOf((*io.Reader)(nil)).Elem()\n\ttypeOfWriter := reflect.TypeOf((*io.Writer)(nil)).Elem()\n\n\ttests := []struct {\n\t\tdesc string\n\t\tgive interface{}\n\t\topts resultOptions\n\n\t\twantFields []resultObjectField\n\t}{\n\t\t{desc: \"empty\", give: struct{ Out }{}},\n\t\t{\n\t\t\tdesc: \"multiple values\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tReader io.Reader\n\t\t\t\tWriter io.Writer\n\t\t\t}{},\n\t\t\twantFields: []resultObjectField{\n\t\t\t\t{\n\t\t\t\t\tFieldName:  \"Reader\",\n\t\t\t\t\tFieldIndex: 1,\n\t\t\t\t\tResult:     resultSingle{Type: typeOfReader},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tFieldName:  \"Writer\",\n\t\t\t\t\tFieldIndex: 2,\n\t\t\t\t\tResult:     resultSingle{Type: typeOfWriter},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"name tag\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tA io.Writer `name:\"stream-a\"`\n\t\t\t\tB io.Writer `name:\"stream-b\" `\n\t\t\t}{},\n\t\t\twantFields: []resultObjectField{\n\t\t\t\t{\n\t\t\t\t\tFieldName:  \"A\",\n\t\t\t\t\tFieldIndex: 1,\n\t\t\t\t\tResult:     resultSingle{Name: \"stream-a\", Type: typeOfWriter},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tFieldName:  \"B\",\n\t\t\t\t\tFieldIndex: 2,\n\t\t\t\t\tResult:     resultSingle{Name: \"stream-b\", Type: typeOfWriter},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"group tag\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tWriter io.Writer `group:\"writers\"`\n\t\t\t}{},\n\t\t\twantFields: []resultObjectField{\n\t\t\t\t{\n\t\t\t\t\tFieldName:  \"Writer\",\n\t\t\t\t\tFieldIndex: 1,\n\t\t\t\t\tResult:     resultGrouped{Group: \"writers\", Type: typeOfWriter},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tgot, err := newResultObject(reflect.TypeOf(tt.give), tt.opts)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, tt.wantFields, got.Fields)\n\t\t})\n\t}\n}\n\nfunc TestNewResultObjectErrors(t *testing.T) {\n\ttests := []struct {\n\t\tdesc string\n\t\tgive interface{}\n\t\topts resultOptions\n\t\terr  string\n\t}{\n\t\t{\n\t\t\tdesc: \"unexported fields\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\twriter io.Writer\n\t\t\t}{},\n\t\t\terr: `unexported fields not allowed in dig.Out, did you mean to export \"writer\" (io.Writer)`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"error field\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tError error\n\t\t\t}{},\n\t\t\terr: `bad field \"Error\" of struct { dig.Out; Error error }: cannot return an error here, return it from the constructor instead`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"nested dig.In\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tNested struct{ In }\n\t\t\t}{},\n\t\t\terr: `bad field \"Nested\"`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"group with name should fail\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tFoo string `group:\"foo\" name:\"bar\"`\n\t\t\t}{},\n\t\t\terr: \"cannot use named values with value groups: \" +\n\t\t\t\t`name:\"bar\" provided with group:\"foo\"`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"group marked as optional\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tFoo string `group:\"foo\" optional:\"true\"`\n\t\t\t}{},\n\t\t\terr: \"value groups cannot be optional\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"name option\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tReader io.Reader\n\t\t\t}{},\n\t\t\topts: resultOptions{Name: \"foo\"},\n\t\t\terr:  `cannot specify a name for result objects`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"name option with name tag\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tA io.Writer `name:\"stream-a\"`\n\t\t\t\tB io.Writer\n\t\t\t}{},\n\t\t\topts: resultOptions{Name: \"stream\"},\n\t\t\terr:  `cannot specify a name for result objects`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"group tag with name option\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tReader io.Reader\n\t\t\t\tWriter io.Writer `group:\"writers\"`\n\t\t\t}{},\n\t\t\topts: resultOptions{Name: \"foo\"},\n\t\t\terr:  `cannot specify a name for result objects`,\n\t\t},\n\t\t{\n\t\t\tdesc: \"flatten on non-slice\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tWriter io.Writer `group:\"writers,flatten\"`\n\t\t\t}{},\n\t\t\terr: \"flatten can be applied to slices only\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"soft on value group\",\n\t\t\tgive: struct {\n\t\t\t\tOut\n\n\t\t\t\tFries []struct{} `group:\"potato,flatten,soft\"`\n\t\t\t}{},\n\t\t\terr: \"cannot use soft with result value groups\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\t_, err := newResultObject(reflect.TypeOf(tt.give), tt.opts)\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), tt.err)\n\t\t})\n\t}\n}\n\ntype fakeResultVisit struct {\n\tVisit                result\n\tAnnotateWithField    *resultObjectField\n\tAnnotateWithPosition int\n\tReturn               fakeResultVisits\n}\n\nfunc (fv fakeResultVisit) String() string {\n\tswitch {\n\tcase fv.Visit != nil:\n\t\treturn fmt.Sprintf(\"Visit(%#v) -> %v\", fv.Visit, fv.Return)\n\tcase fv.AnnotateWithField != nil:\n\t\treturn fmt.Sprintf(\"AnnotateWithField(%#v) -> %v\", *fv.AnnotateWithField, fv.Return)\n\tdefault:\n\t\treturn fmt.Sprintf(\"AnnotateWithPosition(%v) -> %v\", fv.AnnotateWithPosition, fv.Return)\n\t}\n}\n\ntype fakeResultVisits []fakeResultVisit\n\nfunc (vs fakeResultVisits) Visitor(t *testing.T) resultVisitor {\n\treturn &fakeResultVisitor{t: t, visits: vs}\n}\n\ntype fakeResultVisitor struct {\n\tt      *testing.T\n\tvisits fakeResultVisits\n}\n\nfunc (fv *fakeResultVisitor) popNext(call string) fakeResultVisit {\n\tif len(fv.visits) == 0 {\n\t\tfv.t.Fatalf(\"received unexpected call %v: no more calls were expected\", call)\n\t}\n\n\tvisit := fv.visits[0]\n\tfv.visits = fv.visits[1:]\n\treturn visit\n}\n\nfunc (fv *fakeResultVisitor) Visit(r result) resultVisitor {\n\tv := fv.popNext(fmt.Sprintf(\"Visit(%#v)\", r))\n\tif !reflect.DeepEqual(r, v.Visit) {\n\t\tfv.t.Fatalf(\"received unexpected call Visit(%#v)\\nexpected %v\", r, v)\n\t}\n\treturn &fakeResultVisitor{t: fv.t, visits: v.Return}\n}\n\nfunc (fv *fakeResultVisitor) AnnotateWithField(f resultObjectField) resultVisitor {\n\tv := fv.popNext(fmt.Sprintf(\"AnnotateWithField(%#v)\", f))\n\tif v.AnnotateWithField == nil || !reflect.DeepEqual(f, *v.AnnotateWithField) {\n\t\tfv.t.Fatalf(\"received unexpected call AnnotateWithField(%#v)\\nexpected %v\", f, v)\n\t}\n\treturn &fakeResultVisitor{t: fv.t, visits: v.Return}\n}\n\nfunc (fv *fakeResultVisitor) AnnotateWithPosition(i int) resultVisitor {\n\tv := fv.popNext(fmt.Sprintf(\"AnnotateWithPosition(%v)\", i))\n\tif i != v.AnnotateWithPosition {\n\t\tfv.t.Fatalf(\"received unexpected call AnnotateWithPosition(%v)\\nexpected %v\", i, v)\n\t}\n\treturn &fakeResultVisitor{t: fv.t, visits: v.Return}\n}\n\nfunc TestWalkResult(t *testing.T) {\n\tt.Run(\"invalid result type\", func(t *testing.T) {\n\t\ttype badResult struct{ result }\n\t\tvisitor := fakeResultVisits{\n\t\t\t{Visit: badResult{}, Return: fakeResultVisits{}},\n\t\t}.Visitor(t)\n\t\tassert.Panics(t,\n\t\t\tfunc() {\n\t\t\t\twalkResult(badResult{}, visitor)\n\t\t\t})\n\t})\n\n\tt.Run(\"resultObject ordering\", func(t *testing.T) {\n\t\ttype type1 struct{}\n\t\ttype type2 struct{}\n\t\ttype type3 struct{}\n\t\ttype type4 struct{}\n\n\t\ttyp := reflect.TypeOf(struct {\n\t\t\tOut\n\n\t\t\tT1 type1\n\t\t\tT2 type2\n\n\t\t\tNested struct {\n\t\t\t\tOut\n\n\t\t\t\tT3 type3\n\t\t\t\tT4 type4\n\t\t\t}\n\t\t}{})\n\n\t\tro, err := newResultObject(typ, resultOptions{})\n\t\trequire.NoError(t, err)\n\n\t\tv := fakeResultVisits{\n\t\t\t{\n\t\t\t\tVisit: ro,\n\t\t\t\tReturn: fakeResultVisits{\n\t\t\t\t\t{\n\t\t\t\t\t\tAnnotateWithField: &ro.Fields[0],\n\t\t\t\t\t\tReturn: fakeResultVisits{\n\t\t\t\t\t\t\t{Visit: ro.Fields[0].Result},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAnnotateWithField: &ro.Fields[1],\n\t\t\t\t\t\tReturn: fakeResultVisits{\n\t\t\t\t\t\t\t{Visit: ro.Fields[1].Result},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAnnotateWithField: &ro.Fields[2],\n\t\t\t\t\t\tReturn: fakeResultVisits{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tVisit: ro.Fields[2].Result,\n\t\t\t\t\t\t\t\tReturn: fakeResultVisits{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAnnotateWithField: &ro.Fields[2].Result.(resultObject).Fields[0],\n\t\t\t\t\t\t\t\t\t\tReturn: fakeResultVisits{\n\t\t\t\t\t\t\t\t\t\t\t{Visit: ro.Fields[2].Result.(resultObject).Fields[0].Result},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAnnotateWithField: &ro.Fields[2].Result.(resultObject).Fields[1],\n\t\t\t\t\t\t\t\t\t\tReturn: fakeResultVisits{\n\t\t\t\t\t\t\t\t\t\t\t{Visit: ro.Fields[2].Result.(resultObject).Fields[1].Result},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}.Visitor(t)\n\n\t\twalkResult(ro, v)\n\t})\n}\n"
        },
        {
          "name": "scope.go",
          "type": "blob",
          "size": 9.4033203125,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"sort\"\n\t\"time\"\n\n\t\"go.uber.org/dig/internal/digclock\"\n)\n\n// A ScopeOption modifies the default behavior of Scope; currently,\n// there are no implementations.\ntype ScopeOption interface {\n\tnoScopeOption() // yet\n}\n\n// Scope is a scoped DAG of types and their dependencies.\n// A Scope may also have one or more child Scopes that inherit\n// from it.\ntype Scope struct {\n\t// This implements containerStore interface.\n\n\t// Name of the Scope\n\tname string\n\t// Mapping from key to all the constructor node that can provide a value for that\n\t// key.\n\tproviders map[key][]*constructorNode\n\n\t// Mapping from key to the decorator that decorates a value for that key.\n\tdecorators map[key]*decoratorNode\n\n\t// constructorNodes provided directly to this Scope. i.e. it does not include\n\t// any nodes that were provided to the parent Scope this inherited from.\n\tnodes []*constructorNode\n\n\t// Values that generated via decorators in the Scope.\n\tdecoratedValues map[key]reflect.Value\n\n\t// Values that generated directly in the Scope.\n\tvalues map[key]reflect.Value\n\n\t// Values groups that generated directly in the Scope.\n\tgroups map[key][]reflect.Value\n\n\t// Values groups that generated via decoraters in the Scope.\n\tdecoratedGroups map[key]reflect.Value\n\n\t// Source of randomness.\n\trand *rand.Rand\n\n\t// Flag indicating whether the graph has been checked for cycles.\n\tisVerifiedAcyclic bool\n\n\t// Defer acyclic check on provide until Invoke.\n\tdeferAcyclicVerification bool\n\n\t// Recover from panics in user-provided code and wrap in an exported error type.\n\trecoverFromPanics bool\n\n\t// invokerFn calls a function with arguments provided to Provide or Invoke.\n\tinvokerFn invokerFn\n\n\t// graph of this Scope. Note that this holds the dependency graph of all the\n\t// nodes that affect this Scope, not just the ones provided directly to this Scope.\n\tgh *graphHolder\n\n\t// Parent of this Scope.\n\tparentScope *Scope\n\n\t// All the child scopes of this Scope.\n\tchildScopes []*Scope\n\n\t// clockSrc stores the source of time. Defaults to system clock.\n\tclockSrc digclock.Clock\n}\n\nfunc newScope() *Scope {\n\ts := &Scope{\n\t\tproviders:       make(map[key][]*constructorNode),\n\t\tdecorators:      make(map[key]*decoratorNode),\n\t\tvalues:          make(map[key]reflect.Value),\n\t\tdecoratedValues: make(map[key]reflect.Value),\n\t\tgroups:          make(map[key][]reflect.Value),\n\t\tdecoratedGroups: make(map[key]reflect.Value),\n\t\tinvokerFn:       defaultInvoker,\n\t\trand:            rand.New(rand.NewSource(time.Now().UnixNano())),\n\t\tclockSrc:        digclock.System,\n\t}\n\ts.gh = newGraphHolder(s)\n\treturn s\n}\n\n// Scope creates a new Scope with the given name and options from current Scope.\n// Any constructors that the current Scope knows about, as well as any modifications\n// made to it in the future will be propagated to the child scope.\n// However, no modifications made to the child scope being created will be propagated\n// to the parent Scope.\nfunc (s *Scope) Scope(name string, opts ...ScopeOption) *Scope {\n\tchild := newScope()\n\tchild.name = name\n\tchild.parentScope = s\n\tchild.invokerFn = s.invokerFn\n\tchild.clockSrc = s.clockSrc\n\tchild.deferAcyclicVerification = s.deferAcyclicVerification\n\tchild.recoverFromPanics = s.recoverFromPanics\n\n\t// child copies the parent's graph nodes.\n\tfor _, node := range s.gh.nodes {\n\t\tchild.gh.nodes = append(child.gh.nodes, node)\n\t\tif ctrNode, ok := node.Wrapped.(*constructorNode); ok {\n\t\t\tctrNode.CopyOrder(s, child)\n\t\t}\n\t}\n\n\tfor _, opt := range opts {\n\t\topt.noScopeOption()\n\t}\n\n\ts.childScopes = append(s.childScopes, child)\n\treturn child\n}\n\n// ancestors returns a list of scopes of ancestors of this scope up to the\n// root. The scope at at index 0 is this scope itself.\nfunc (s *Scope) ancestors() []*Scope {\n\tvar scopes []*Scope\n\tfor s := s; s != nil; s = s.parentScope {\n\t\tscopes = append(scopes, s)\n\t}\n\treturn scopes\n}\n\nfunc (s *Scope) appendSubscopes(dest []*Scope) []*Scope {\n\tdest = append(dest, s)\n\tfor _, cs := range s.childScopes {\n\t\tdest = cs.appendSubscopes(dest)\n\t}\n\treturn dest\n}\n\nfunc (s *Scope) storesToRoot() []containerStore {\n\tscopes := s.ancestors()\n\tstores := make([]containerStore, len(scopes))\n\tfor i, s := range scopes {\n\t\tstores[i] = s\n\t}\n\treturn stores\n}\n\nfunc (s *Scope) knownTypes() []reflect.Type {\n\ttypeSet := make(map[reflect.Type]struct{}, len(s.providers))\n\tfor k := range s.providers {\n\t\ttypeSet[k.t] = struct{}{}\n\t}\n\n\ttypes := make([]reflect.Type, 0, len(typeSet))\n\tfor t := range typeSet {\n\t\ttypes = append(types, t)\n\t}\n\tsort.Sort(byTypeName(types))\n\treturn types\n}\n\nfunc (s *Scope) getValue(name string, t reflect.Type) (v reflect.Value, ok bool) {\n\tv, ok = s.values[key{name: name, t: t}]\n\treturn\n}\n\nfunc (s *Scope) getDecoratedValue(name string, t reflect.Type) (v reflect.Value, ok bool) {\n\tv, ok = s.decoratedValues[key{name: name, t: t}]\n\treturn\n}\n\nfunc (s *Scope) setValue(name string, t reflect.Type, v reflect.Value) {\n\ts.values[key{name: name, t: t}] = v\n}\n\nfunc (s *Scope) setDecoratedValue(name string, t reflect.Type, v reflect.Value) {\n\ts.decoratedValues[key{name: name, t: t}] = v\n}\n\nfunc (s *Scope) getValueGroup(name string, t reflect.Type) []reflect.Value {\n\titems := s.groups[key{group: name, t: t}]\n\t// shuffle the list so users don't rely on the ordering of grouped values\n\treturn shuffledCopy(s.rand, items)\n}\n\nfunc (s *Scope) getDecoratedValueGroup(name string, t reflect.Type) (reflect.Value, bool) {\n\titems, ok := s.decoratedGroups[key{group: name, t: t}]\n\treturn items, ok\n}\n\nfunc (s *Scope) submitGroupedValue(name string, t reflect.Type, v reflect.Value) {\n\tk := key{group: name, t: t}\n\ts.groups[k] = append(s.groups[k], v)\n}\n\nfunc (s *Scope) submitDecoratedGroupedValue(name string, t reflect.Type, v reflect.Value) {\n\tk := key{group: name, t: t}\n\ts.decoratedGroups[k] = v\n}\n\nfunc (s *Scope) getValueProviders(name string, t reflect.Type) []provider {\n\treturn s.getProviders(key{name: name, t: t})\n}\n\nfunc (s *Scope) getGroupProviders(name string, t reflect.Type) []provider {\n\treturn s.getProviders(key{group: name, t: t})\n}\n\nfunc (s *Scope) getValueDecorator(name string, t reflect.Type) (decorator, bool) {\n\treturn s.getDecorators(key{name: name, t: t})\n}\n\nfunc (s *Scope) getGroupDecorator(name string, t reflect.Type) (decorator, bool) {\n\treturn s.getDecorators(key{group: name, t: t})\n}\n\nfunc (s *Scope) getDecorators(k key) (decorator, bool) {\n\td, found := s.decorators[k]\n\treturn d, found\n}\n\nfunc (s *Scope) getProviders(k key) []provider {\n\tnodes := s.providers[k]\n\tproviders := make([]provider, len(nodes))\n\tfor i, n := range nodes {\n\t\tproviders[i] = n\n\t}\n\treturn providers\n}\n\nfunc (s *Scope) getAllGroupProviders(name string, t reflect.Type) []provider {\n\treturn s.getAllProviders(key{group: name, t: t})\n}\n\nfunc (s *Scope) getAllValueProviders(name string, t reflect.Type) []provider {\n\treturn s.getAllProviders(key{name: name, t: t})\n}\n\nfunc (s *Scope) getAllProviders(k key) []provider {\n\tallScopes := s.ancestors()\n\tvar providers []provider\n\tfor _, scope := range allScopes {\n\t\tproviders = append(providers, scope.getProviders(k)...)\n\t}\n\treturn providers\n}\n\nfunc (s *Scope) invoker() invokerFn {\n\treturn s.invokerFn\n}\n\nfunc (s *Scope) clock() digclock.Clock {\n\treturn s.clockSrc\n}\n\n// adds a new graphNode to this Scope and all of its descendent\n// scope.\nfunc (s *Scope) newGraphNode(wrapped interface{}, orders map[*Scope]int) {\n\torders[s] = s.gh.NewNode(wrapped)\n\tfor _, cs := range s.childScopes {\n\t\tcs.newGraphNode(wrapped, orders)\n\t}\n}\n\nfunc (s *Scope) cycleDetectedError(cycle []int) error {\n\tvar path []cycleErrPathEntry\n\tfor _, n := range cycle {\n\t\tif n, ok := s.gh.Lookup(n).(*constructorNode); ok {\n\t\t\tpath = append(path, cycleErrPathEntry{\n\t\t\t\tKey: key{\n\t\t\t\t\tt: n.CType(),\n\t\t\t\t},\n\t\t\t\tFunc: n.Location(),\n\t\t\t})\n\t\t}\n\t}\n\treturn errCycleDetected{Path: path, scope: s}\n}\n\n// Returns the root Scope that can be reached from this Scope.\nfunc (s *Scope) rootScope() *Scope {\n\tcurr := s\n\tfor curr.parentScope != nil {\n\t\tcurr = curr.parentScope\n\t}\n\treturn curr\n}\n\n// String representation of the entire Scope\nfunc (s *Scope) String() string {\n\tb := &bytes.Buffer{}\n\tfmt.Fprintln(b, \"nodes: {\")\n\tfor k, vs := range s.providers {\n\t\tfor _, v := range vs {\n\t\t\tfmt.Fprintln(b, \"\\t\", k, \"->\", v)\n\t\t}\n\t}\n\tfmt.Fprintln(b, \"}\")\n\n\tfmt.Fprintln(b, \"values: {\")\n\tfor k, v := range s.values {\n\t\tfmt.Fprintln(b, \"\\t\", k, \"=>\", v)\n\t}\n\tfor k, vs := range s.groups {\n\t\tfor _, v := range vs {\n\t\t\tfmt.Fprintln(b, \"\\t\", k, \"=>\", v)\n\t\t}\n\t}\n\tfmt.Fprintln(b, \"}\")\n\n\treturn b.String()\n}\n"
        },
        {
          "name": "scope_int_test.go",
          "type": "blob",
          "size": 1.4482421875,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestScopeAncestorsAndStoresToRoot(t *testing.T) {\n\tc := New()\n\ts1 := c.Scope(\"child1\")\n\ts2 := s1.Scope(\"child2\")\n\ts3 := s2.Scope(\"child2\")\n\n\tassert.Equal(t, []containerStore{s3, s2, s1, c.scope}, s3.storesToRoot())\n\tassert.Equal(t, []*Scope{s3, s2, s1, c.scope}, s3.ancestors())\n}\n"
        },
        {
          "name": "scope_test.go",
          "type": "blob",
          "size": 11.462890625,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/dig/internal/digtest\"\n)\n\nfunc TestScopedOperations(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"private provides\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\ts := c.Scope(\"child\")\n\t\ttype A struct{}\n\n\t\tf := func(a *A) {\n\t\t\tassert.NotEqual(t, nil, a)\n\t\t}\n\n\t\ts.RequireProvide(func() *A { return &A{} })\n\t\ts.RequireInvoke(f)\n\t\tassert.Error(t, c.Invoke(f))\n\t})\n\n\tt.Run(\"private provides inherits\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\ttype B struct{}\n\n\t\tuseA := func(a *A) {\n\t\t\tassert.NotEqual(t, nil, a)\n\t\t}\n\t\tuseB := func(b *B) {\n\t\t\tassert.NotEqual(t, nil, b)\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func() *A { return &A{} })\n\n\t\tchild := c.Scope(\"child\")\n\t\tchild.RequireProvide(func() *B { return &B{} })\n\t\tchild.RequireInvoke(useA)\n\t\tchild.RequireInvoke(useB)\n\n\t\tgrandchild := child.Scope(\"grandchild\")\n\n\t\tgrandchild.RequireInvoke(useA)\n\t\tgrandchild.RequireInvoke(useB)\n\t\tassert.Error(t, c.Invoke(useB))\n\t})\n\n\tt.Run(\"private provides doesn't depend on invoke order\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tchild := c.Scope(\"child\")\n\n\t\tc.RequireProvide(func() string { return \"container\" })\n\t\tchild.RequireProvide(func() string { return \"child\" })\n\n\t\tverifyContainerStr := func(s string) {\n\t\t\tassert.Equal(t, \"container\", s)\n\t\t}\n\t\tverifyChildStr := func(s string) {\n\t\t\tassert.Equal(t, \"child\", s)\n\t\t}\n\n\t\tc.RequireInvoke(verifyContainerStr)\n\t\tchild.RequireInvoke(verifyChildStr)\n\t})\n\n\tt.Run(\"provides to top-level Container propagates to all scopes\", func(t *testing.T) {\n\t\ttype A struct{}\n\n\t\t// Scope tree:\n\t\t//     root  <-- Provide(func() *A)\n\t\t//    /    \\\n\t\t//   c1\t    c2\n\t\t//   |     /  \\\n\t\t//   gc1  gc2  gc3\n\t\tvar allScopes []*digtest.Scope\n\t\troot := digtest.New(t)\n\n\t\tallScopes = append(allScopes, root.Scope(\"child 1\"), root.Scope(\"child 2\"))\n\t\tallScopes = append(allScopes, allScopes[0].Scope(\"grandchild 1\"), allScopes[1].Scope(\"grandchild 2\"), allScopes[1].Scope(\"grandchild 3\"))\n\n\t\troot.RequireProvide(func() *A {\n\t\t\treturn &A{}\n\t\t})\n\n\t\t// top-level provide should be available in all the scopes.\n\t\tfor _, scope := range allScopes {\n\t\t\tscope.RequireInvoke(func(a *A) {})\n\t\t}\n\t})\n\n\tt.Run(\"provide with Export\", func(t *testing.T) {\n\t\t// Scope tree:\n\t\t//     root\n\t\t//    /    \\\n\t\t//   c1\t    c2\n\t\t//   |     /  \\\n\t\t//   gc1  gc2  gc3 <-- Provide(func() *A)\n\n\t\troot := digtest.New(t)\n\t\tvar allScopes []*digtest.Scope\n\n\t\tallScopes = append(allScopes, root.Scope(\"child 1\"), root.Scope(\"child 2\"))\n\t\tallScopes = append(allScopes, allScopes[0].Scope(\"grandchild 1\"), allScopes[1].Scope(\"grandchild 2\"), allScopes[1].Scope(\"grandchild 3\"))\n\n\t\ttype A struct{}\n\t\t// provide to the leaf Scope with Export option set.\n\t\tallScopes[len(allScopes)-1].RequireProvide(func() *A {\n\t\t\treturn &A{}\n\t\t}, dig.Export(true))\n\n\t\t// since constructor was provided with Export option, this should let all the Scopes below should see it.\n\t\tfor _, scope := range allScopes {\n\t\t\tscope.RequireInvoke(func(a *A) {})\n\t\t}\n\t})\n\n\tt.Run(\"parent shares values with children\", func(t *testing.T) {\n\t\ttype (\n\t\t\tT1 struct{ s string }\n\t\t\tT2 struct{}\n\t\t)\n\n\t\tparent := digtest.New(t)\n\n\t\tparent.RequireProvide(func() T1 {\n\t\t\tassert.Fail(t, \"parent should not be called\")\n\t\t\treturn T1{\"parent\"}\n\t\t})\n\n\t\tchild := parent.Scope(\"child\")\n\n\t\tvar childCalled bool\n\t\tdefer func() {\n\t\t\tassert.True(t, childCalled, \"child constructor must be called\")\n\t\t}()\n\t\tchild.RequireProvide(func() T1 {\n\t\t\tchildCalled = true\n\t\t\treturn T1{\"child\"}\n\t\t})\n\n\t\tchild.RequireProvide(func(v T1) T2 {\n\t\t\tassert.Equal(t, \"child\", v.s,\n\t\t\t\t\"value should be built by child\")\n\t\t\treturn T2{}\n\t\t})\n\n\t\tchild.RequireInvoke(func(T2) {})\n\t})\n}\n\nfunc TestScopeFailures(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"introduce a cycle with child\", func(t *testing.T) {\n\t\t// what root sees:\n\t\t// A <- B    C\n\t\t// |         ^\n\t\t// |_________|\n\t\t//\n\t\t// what child sees:\n\t\t// A <- B <- C\n\t\t// |         ^\n\t\t// |_________|\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\ttype C struct{}\n\t\tnewA := func(*C) *A { return &A{} }\n\t\tnewB := func(*A) *B { return &B{} }\n\t\tnewC := func(*B) *C { return &C{} }\n\n\t\t// Create a child Scope, and introduce a cycle\n\t\t// in the child only.\n\t\tcheck := func(c *digtest.Container, fails bool) {\n\t\t\ts := c.Scope(\"child\")\n\t\t\tc.RequireProvide(newA)\n\t\t\ts.RequireProvide(newB)\n\t\t\terr := c.Provide(newC)\n\n\t\t\tif fails {\n\t\t\t\tassert.Error(t, err, \"expected a cycle to be introduced in the child\")\n\t\t\t\tassert.Contains(t, err.Error(), `[scope \"child\"]`)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t}\n\n\t\t// Same as check, but this time child should inherit\n\t\t// parent-provided constructors upon construction.\n\t\tcheckWithInheritance := func(c *digtest.Container, fails bool) {\n\t\t\tc.RequireProvide(newA)\n\t\t\ts := c.Scope(\"child\")\n\t\t\ts.RequireProvide(newB)\n\t\t\terr := c.Provide(newC)\n\t\t\tif fails {\n\t\t\t\tassert.Error(t, err, \"expected a cycle to be introduced in the child\")\n\t\t\t\tassert.Contains(t, err.Error(), `[scope \"child\"]`)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t}\n\n\t\t// Test using different permutations\n\t\tnodeferContainers := []func() *digtest.Container{\n\t\t\tfunc() *digtest.Container { return digtest.New(t) },\n\t\t\tfunc() *digtest.Container { return digtest.New(t, dig.DryRun(true)) },\n\t\t\tfunc() *digtest.Container { return digtest.New(t, dig.DryRun(false)) },\n\t\t}\n\t\t// Container permutations with DeferAcyclicVerification.\n\t\tdeferredContainers := []func() *digtest.Container{\n\t\t\tfunc() *digtest.Container { return digtest.New(t, dig.DeferAcyclicVerification()) },\n\t\t\tfunc() *digtest.Container { return digtest.New(t, dig.DeferAcyclicVerification(), dig.DryRun(true)) },\n\t\t\tfunc() *digtest.Container { return digtest.New(t, dig.DeferAcyclicVerification(), dig.DryRun(false)) },\n\t\t}\n\n\t\tfor _, c := range nodeferContainers {\n\t\t\tcheck(c(), true)\n\t\t\tcheckWithInheritance(c(), true)\n\t\t}\n\n\t\t// with deferAcyclicVerification, these should not\n\t\t// error on Provides.\n\t\tfor _, c := range deferredContainers {\n\t\t\tcheck(c(), false)\n\t\t\tcheckWithInheritance(c(), false)\n\t\t}\n\t})\n\n\tt.Run(\"introduce a cycle with Export option\", func(t *testing.T) {\n\t\t// what root and child1 sees:\n\t\t// A <- B    C\n\t\t// |         ^\n\t\t// |_________|\n\t\t//\n\t\t// what child2 sees:\n\t\t// A <- B <- C\n\t\t// |         ^\n\t\t// |_________|\n\n\t\ttype A struct{}\n\t\ttype B struct{}\n\t\ttype C struct{}\n\t\tnewA := func(*C) *A { return &A{} }\n\t\tnewB := func(*A) *B { return &B{} }\n\t\tnewC := func(*B) *C { return &C{} }\n\n\t\troot := digtest.New(t)\n\t\tchild1 := root.Scope(\"child 1\")\n\t\tchild2 := root.Scope(\"child 2\")\n\n\t\t// A <- B made available to all Scopes with root provision.\n\t\troot.RequireProvide(newA)\n\n\t\t// B <- C made available to only child 2 with private provide.\n\t\tchild2.RequireProvide(newB)\n\n\t\t// C <- A made available to all Scopes with Export provide.\n\t\terr := child1.Provide(newC, dig.Export(true))\n\t\tassert.Error(t, err, \"expected a cycle to be introduced in child 2\")\n\t\tassert.Contains(t, err.Error(), `[scope \"child 2\"]`)\n\t})\n\n\tt.Run(\"private provides do not propagate upstream\", func(t *testing.T) {\n\t\ttype A struct{}\n\n\t\troot := digtest.New(t)\n\t\tc := root.Scope(\"child\")\n\t\tgc := c.Scope(\"grandchild\")\n\t\tgc.RequireProvide(func() *A { return &A{} })\n\n\t\tassert.Error(t, root.Invoke(func(a *A) {}), \"invoking on grandchild's private-provided type should fail\")\n\t\tassert.Error(t, c.Invoke(func(a *A) {}), \"invoking on child's private-provided type should fail\")\n\t})\n\n\tt.Run(\"private provides to child should be available to grandchildren, but not root\", func(t *testing.T) {\n\t\ttype A struct{}\n\t\t// Scope tree:\n\t\t//     root\n\t\t//      |\n\t\t//     child  <-- Provide(func() *A)\n\t\t//     /  \\\n\t\t//   gc1   gc2\n\t\troot := digtest.New(t)\n\t\tc := root.Scope(\"child\")\n\t\tgc := c.Scope(\"grandchild\")\n\n\t\tc.RequireProvide(func() *A { return &A{} })\n\n\t\terr := root.Invoke(func(a *A) {})\n\t\tassert.Error(t, err, \"expected Invoke in root container on child's private-provided type to fail\")\n\t\tassert.Contains(t, err.Error(), \"missing type: *dig_test.A\")\n\n\t\tgc.RequireInvoke(func(a *A) {})\n\t})\n}\n\nfunc TestScopeValueGroups(t *testing.T) {\n\tt.Run(\"provide in parent and child\", func(t *testing.T) {\n\t\ttype result struct {\n\t\t\tdig.Out\n\n\t\t\tValue string `group:\"foo\"`\n\t\t}\n\n\t\troot := digtest.New(t)\n\t\troot.RequireProvide(func() result {\n\t\t\treturn result{Value: \"a\"}\n\t\t})\n\n\t\troot.RequireProvide(func() result {\n\t\t\treturn result{Value: \"b\"}\n\t\t})\n\n\t\troot.RequireProvide(func() result {\n\t\t\treturn result{Value: \"c\"}\n\t\t})\n\n\t\tchild := root.Scope(\"child\")\n\t\tchild.RequireProvide(func() result {\n\t\t\treturn result{Value: \"d\"}\n\t\t})\n\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tValues []string `group:\"foo\"`\n\t\t}\n\n\t\tt.Run(\"invoke parent\", func(t *testing.T) {\n\t\t\troot.RequireInvoke(func(i param) {\n\t\t\t\tassert.ElementsMatch(t, []string{\"a\", \"b\", \"c\"}, i.Values)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"invoke child\", func(t *testing.T) {\n\t\t\tchild.RequireInvoke(func(i param) {\n\t\t\t\tassert.ElementsMatch(t, []string{\"a\", \"b\", \"c\", \"d\"}, i.Values)\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"value group as a parent dependency\", func(t *testing.T) {\n\t\t// Tree:\n\t\t//\n\t\t//   root      defines a function that consumes the value group\n\t\t//    |\n\t\t//    |\n\t\t//   child     produces values to the value group\n\n\t\ttype T1 struct{}\n\t\ttype param struct {\n\t\t\tdig.In\n\n\t\t\tValues []string `group:\"foo\"`\n\t\t}\n\n\t\troot := digtest.New(t)\n\n\t\troot.RequireProvide(func(p param) T1 {\n\t\t\tassert.ElementsMatch(t, []string{\"a\", \"b\", \"c\"}, p.Values)\n\t\t\treturn T1{}\n\t\t})\n\n\t\tchild := root.Scope(\"child\")\n\t\tchild.RequireProvide(func() string { return \"a\" }, dig.Group(\"foo\"), dig.Export(true))\n\t\tchild.RequireProvide(func() string { return \"b\" }, dig.Group(\"foo\"), dig.Export(true))\n\t\tchild.RequireProvide(func() string { return \"c\" }, dig.Group(\"foo\"), dig.Export(true))\n\n\t\t// Invocation in child should see values provided to the child,\n\t\t// even though the constructor we're invoking is provided in\n\t\t// the parent.\n\t\tchild.RequireInvoke(func(T1) {})\n\t})\n}\n\n// This tests that a child scope correctly copies its parent's graph,\n// including information about the order of each node.\n// Otherwise, during cycle detection, constructor nodes might\n// return 0 as the order for all functions in the root scope,\n// causing cycle detection to detect cycles that don't exist.\nfunc TestFalsePositiveScopeCycleDetection(t *testing.T) {\n\tt.Run(\"single provide\", func(t *testing.T) {\n\t\troot := digtest.New(t)\n\t\troot.RequireProvide(func(val string) int { return 0 })\n\t\troot.RequireProvide(func() string { return \"sample\" })\n\t\tchild := root.Scope(\"child\")\n\t\t// Cycle detection would error here because previous two provides\n\t\t// would both have order 0 for child scope.\n\t\tchild.RequireProvide(func() float32 { return 0 })\n\t})\n}\n"
        },
        {
          "name": "stringer_test.go",
          "type": "blob",
          "size": 3.2978515625,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig_test\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/dig/internal/digtest\"\n)\n\nfunc TestStringer(t *testing.T) {\n\ttype A struct{}\n\ttype B struct{}\n\ttype C struct{}\n\ttype D struct{}\n\n\ttype in struct {\n\t\tdig.In\n\n\t\tA A `name:\"foo\"`\n\t\tB B `optional:\"true\"`\n\t\tC C `name:\"bar\" optional:\"true\"`\n\n\t\tStrings []string `group:\"baz\"`\n\t}\n\n\ttype out struct {\n\t\tdig.Out\n\n\t\tA A `name:\"foo\"`\n\t\tC C `name:\"bar\"`\n\t}\n\n\ttype stringOut struct {\n\t\tdig.Out\n\n\t\tS string `group:\"baz\"`\n\t}\n\n\tc := digtest.New(t, dig.SetRand(rand.New(rand.NewSource(0))))\n\n\tc.RequireProvide(func(i in) D {\n\t\tassert.Equal(t, []string{\"bar\", \"baz\", \"foo\"}, i.Strings)\n\t\treturn D{}\n\t})\n\n\tc.RequireProvide(func() out {\n\t\treturn out{\n\t\t\tA: A{},\n\t\t\tC: C{},\n\t\t}\n\t})\n\n\tc.RequireProvide(func() A { return A{} })\n\tc.RequireProvide(func() B { return B{} })\n\tc.RequireProvide(func() C { return C{} })\n\n\tc.RequireProvide(func(A) stringOut { return stringOut{S: \"foo\"} })\n\tc.RequireProvide(func(B) stringOut { return stringOut{S: \"bar\"} })\n\tc.RequireProvide(func(C) stringOut { return stringOut{S: \"baz\"} })\n\n\tc.RequireInvoke(func(D) {\n\t})\n\n\ts := c.String()\n\n\t// All nodes\n\tassert.Contains(t, s, `dig_test.A[name=\"foo\"] -> deps: []`)\n\tassert.Contains(t, s, \"dig_test.A -> deps: []\")\n\tassert.Contains(t, s, \"dig_test.B -> deps: []\")\n\tassert.Contains(t, s, \"dig_test.C -> deps: []\")\n\tassert.Contains(t, s, `dig_test.C[name=\"bar\"] -> deps: []`)\n\tassert.Contains(t, s, `dig_test.D -> deps: [dig_test.A[name=\"foo\"] dig_test.B[optional] dig_test.C[optional, name=\"bar\"] string[group=\"baz\"]]`)\n\tassert.Contains(t, s, `string[group=\"baz\"] -> deps: [dig_test.A]`)\n\tassert.Contains(t, s, `string[group=\"baz\"] -> deps: [dig_test.B]`)\n\tassert.Contains(t, s, `string[group=\"baz\"] -> deps: [dig_test.C]`)\n\n\t// Values\n\tassert.Contains(t, s, \"dig_test.A => {}\")\n\tassert.Contains(t, s, \"dig_test.B => {}\")\n\tassert.Contains(t, s, \"dig_test.C => {}\")\n\tassert.Contains(t, s, \"dig_test.D => {}\")\n\tassert.Contains(t, s, `dig_test.A[name=\"foo\"] => {}`)\n\tassert.Contains(t, s, `dig_test.C[name=\"bar\"] => {}`)\n\tassert.Contains(t, s, `string[group=\"baz\"] => foo`)\n\tassert.Contains(t, s, `string[group=\"baz\"] => bar`)\n\tassert.Contains(t, s, `string[group=\"baz\"] => baz`)\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 1.1630859375,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\n// Version of the library.\nconst Version = \"1.19.0-dev\"\n"
        },
        {
          "name": "visualize.go",
          "type": "blob",
          "size": 4.9921875,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"text/template\"\n\n\t\"go.uber.org/dig/internal/dot\"\n)\n\n// A VisualizeOption modifies the default behavior of Visualize.\ntype VisualizeOption interface {\n\tapplyVisualizeOption(*visualizeOptions)\n}\n\ntype visualizeOptions struct {\n\tVisualizeError error\n}\n\n// VisualizeError includes a visualization of the given error in the output of\n// Visualize if an error was returned by Invoke or Provide.\n//\n//\tif err := c.Provide(...); err != nil {\n//\t  dig.Visualize(c, w, dig.VisualizeError(err))\n//\t}\n//\n// This option has no effect if the error was nil or if it didn't contain any\n// information to visualize.\nfunc VisualizeError(err error) VisualizeOption {\n\treturn visualizeErrorOption{err}\n}\n\ntype visualizeErrorOption struct{ err error }\n\nfunc (o visualizeErrorOption) String() string {\n\treturn fmt.Sprintf(\"VisualizeError(%v)\", o.err)\n}\n\nfunc (o visualizeErrorOption) applyVisualizeOption(opt *visualizeOptions) {\n\topt.VisualizeError = o.err\n}\n\nfunc updateGraph(dg *dot.Graph, err error) error {\n\tvar errs []errVisualizer\n\t// Unwrap error to find the root cause.\n\tfor {\n\t\tif ev, ok := err.(errVisualizer); ok {\n\t\t\terrs = append(errs, ev)\n\t\t}\n\t\te := errors.Unwrap(err)\n\t\tif e == nil {\n\t\t\tbreak\n\t\t}\n\t\terr = e\n\t}\n\n\t// If there are no errVisualizers included, we do not modify the graph.\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\t// We iterate in reverse because the last element is the root cause.\n\tfor i := len(errs) - 1; i >= 0; i-- {\n\t\terrs[i].updateGraph(dg)\n\t}\n\n\t// Remove non-error entries from the graph for readability.\n\tdg.PruneSuccess()\n\n\treturn nil\n}\n\nvar _graphTmpl = template.Must(\n\ttemplate.New(\"DotGraph\").\n\t\tFuncs(template.FuncMap{\n\t\t\t\"quote\": strconv.Quote,\n\t\t}).\n\t\tParse(`digraph {\n\trankdir=RL;\n\tgraph [compound=true];\n\t{{range $g := .Groups}}\n\t\t{{- quote .String}} [{{.Attributes}}];\n\t\t{{range .Results}}\n\t\t\t{{- quote $g.String}} -> {{quote .String}};\n\t\t{{end}}\n\t{{end -}}\n\t{{range $index, $ctor := .Ctors}}\n\t\tsubgraph cluster_{{$index}} {\n\t\t\t{{ with .Package }}label = {{ quote .}};\n\t\t\t{{ end -}}\n\n\t\t\tconstructor_{{$index}} [shape=plaintext label={{quote .Name}}];\n\t\t\t{{with .ErrorType}}color={{.Color}};{{end}}\n\t\t\t{{range .Results}}\n\t\t\t\t{{- quote .String}} [{{.Attributes}}];\n\t\t\t{{end}}\n\t\t}\n\t\t{{range .Params}}\n\t\t\tconstructor_{{$index}} -> {{quote .String}} [ltail=cluster_{{$index}}{{if .Optional}} style=dashed{{end}}];\n\t\t{{end}}\n\t\t{{range .GroupParams}}\n\t\t\tconstructor_{{$index}} -> {{quote .String}} [ltail=cluster_{{$index}}];\n\t\t{{end -}}\n\t{{end}}\n\t{{range .Failed.TransitiveFailures}}\n\t\t{{- quote .String}} [color=orange];\n\t{{end -}}\n\t{{range .Failed.RootCauses}}\n\t\t{{- quote .String}} [color=red];\n\t{{end}}\n}`))\n\n// Visualize parses the graph in Container c into DOT format and writes it to\n// io.Writer w.\nfunc Visualize(c *Container, w io.Writer, opts ...VisualizeOption) error {\n\tdg := c.createGraph()\n\n\tvar options visualizeOptions\n\tfor _, o := range opts {\n\t\to.applyVisualizeOption(&options)\n\t}\n\n\tif options.VisualizeError != nil {\n\t\tif err := updateGraph(dg, options.VisualizeError); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn _graphTmpl.Execute(w, dg)\n}\n\n// CanVisualizeError returns true if the error is an errVisualizer.\nfunc CanVisualizeError(err error) bool {\n\tfor {\n\t\tif _, ok := err.(errVisualizer); ok {\n\t\t\treturn true\n\t\t}\n\t\te := errors.Unwrap(err)\n\t\tif e == nil {\n\t\t\tbreak\n\t\t}\n\t\terr = e\n\t}\n\n\treturn false\n}\n\nfunc (c *Container) createGraph() *dot.Graph {\n\treturn c.scope.createGraph()\n}\n\nfunc (s *Scope) createGraph() *dot.Graph {\n\tdg := dot.NewGraph()\n\n\ts.addNodes(dg)\n\n\treturn dg\n}\n\nfunc (s *Scope) addNodes(dg *dot.Graph) {\n\tfor _, n := range s.nodes {\n\t\tdg.AddCtor(newDotCtor(n), n.paramList.DotParam(), n.resultList.DotResult())\n\t}\n\n\tfor _, cs := range s.childScopes {\n\t\tcs.addNodes(dg)\n\t}\n}\n\nfunc newDotCtor(n *constructorNode) *dot.Ctor {\n\treturn &dot.Ctor{\n\t\tID:      n.id,\n\t\tName:    n.location.Name,\n\t\tPackage: n.location.Package,\n\t\tFile:    n.location.File,\n\t\tLine:    n.location.Line,\n\t}\n}\n"
        },
        {
          "name": "visualize_golden_test.go",
          "type": "blob",
          "size": 2.021484375,
          "content": "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"bytes\"\n\t\"flag\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar generate = flag.Bool(\"generate\", false, \"generates output to testdata/ if set\")\n\nfunc VerifyVisualization(t *testing.T, testname string, c *Container, opts ...VisualizeOption) {\n\tvar b bytes.Buffer\n\trequire.NoError(t, Visualize(c, &b, opts...))\n\tgot := b.Bytes()\n\tgot = bytes.ReplaceAll(got, []byte(\"\\r\\n\"), []byte(\"\\n\")) // normalize line endings\n\n\tdotFile := filepath.Join(\"testdata\", testname+\".dot\")\n\n\tif *generate {\n\t\terr := os.WriteFile(dotFile, got, 0o644)\n\t\trequire.NoError(t, err)\n\t\treturn\n\t}\n\n\twant, err := os.ReadFile(dotFile)\n\trequire.NoError(t, err)\n\twant = bytes.ReplaceAll(want, []byte(\"\\r\\n\"), []byte(\"\\n\")) // normalize line endings\n\n\tassert.Equal(t, string(want), string(got),\n\t\t\"Output did not match. Make sure you updated the testdata by running 'go test -generate'\")\n}\n"
        },
        {
          "name": "visualize_int_test.go",
          "type": "blob",
          "size": 2.62109375,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/dig/internal/dot\"\n)\n\nfunc (c *Container) CreateGraph() *dot.Graph {\n\treturn c.createGraph()\n}\n\nfunc (s *Scope) CreateGraph() *dot.Graph {\n\treturn s.createGraph()\n}\n\ntype nestedErr struct {\n\terr error\n}\n\nvar _ digError = nestedErr{}\n\nfunc (e nestedErr) Error() string {\n\treturn fmt.Sprint(e)\n}\n\nfunc (e nestedErr) Unwrap() error {\n\treturn e.err\n}\n\nfunc (e nestedErr) writeMessage(w io.Writer, _ string) {\n\tio.WriteString(w, \"oh no\")\n}\n\nfunc (e nestedErr) Format(w fmt.State, c rune) {\n\tformatError(e, w, c)\n}\n\ntype visualizableErr struct{}\n\nfunc (err visualizableErr) Error() string             { return \"great sadness\" }\nfunc (err visualizableErr) updateGraph(dg *dot.Graph) {}\n\nfunc TestCanVisualizeError(t *testing.T) {\n\ttests := []struct {\n\t\tdesc         string\n\t\terr          error\n\t\tcanVisualize bool\n\t}{\n\t\t{\n\t\t\tdesc:         \"unvisualizable error\",\n\t\t\terr:          errors.New(\"great sadness\"),\n\t\t\tcanVisualize: false,\n\t\t},\n\t\t{\n\t\t\tdesc:         \"nested unvisualizable error\",\n\t\t\terr:          nestedErr{err: errors.New(\"great sadness\")},\n\t\t\tcanVisualize: false,\n\t\t},\n\t\t{\n\t\t\tdesc:         \"visualizable error\",\n\t\t\terr:          visualizableErr{},\n\t\t\tcanVisualize: true,\n\t\t},\n\t\t{\n\t\t\tdesc:         \"nested visualizable error\",\n\t\t\terr:          nestedErr{err: visualizableErr{}},\n\t\t\tcanVisualize: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tassert.Equal(t, tt.canVisualize, CanVisualizeError(tt.err))\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "visualize_test.go",
          "type": "blob",
          "size": 13.9873046875,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage dig_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/dig\"\n\t\"go.uber.org/dig/internal/digtest\"\n\t\"go.uber.org/dig/internal/dot\"\n)\n\nfunc TestDotGraph(t *testing.T) {\n\ttparam := func(t reflect.Type, n string, g string, o bool) *dot.Param {\n\t\treturn &dot.Param{\n\t\t\tNode: &dot.Node{\n\t\t\t\tType:  t,\n\t\t\t\tName:  n,\n\t\t\t\tGroup: g,\n\t\t\t},\n\t\t\tOptional: o,\n\t\t}\n\t}\n\n\ttresult := func(t reflect.Type, n string, g string, gi int) *dot.Result {\n\t\treturn &dot.Result{\n\t\t\tNode: &dot.Node{\n\t\t\t\tType:  t,\n\t\t\t\tName:  n,\n\t\t\t\tGroup: g,\n\t\t\t},\n\t\t\tGroupIndex: gi,\n\t\t}\n\t}\n\n\ttype t1 struct{}\n\ttype t2 struct{}\n\ttype t3 struct{}\n\ttype t4 struct{}\n\ttype t5 struct {\n\t\tstrings.Reader\n\t}\n\n\ttype1 := reflect.TypeOf(t1{})\n\ttype2 := reflect.TypeOf(t2{})\n\ttype3 := reflect.TypeOf(t3{})\n\ttype4 := reflect.TypeOf(t4{})\n\ttype6 := reflect.Indirect(reflect.ValueOf(new(io.Reader))).Type()\n\ttype7 := reflect.Indirect(reflect.ValueOf(new(io.Writer))).Type()\n\n\tp1 := tparam(type1, \"\", \"\", false)\n\tp2 := tparam(type2, \"\", \"\", false)\n\tp3 := tparam(type3, \"\", \"\", false)\n\tp4 := tparam(type4, \"\", \"\", false)\n\n\tr1 := tresult(type1, \"\", \"\", 0)\n\tr2 := tresult(type2, \"\", \"\", 0)\n\tr3 := tresult(type3, \"\", \"\", 0)\n\tr4 := tresult(type4, \"\", \"\", 0)\n\tr6 := tresult(type6, \"\", \"\", 0)\n\n\tt.Parallel()\n\n\tt.Run(\"create graph with one constructor\", func(t *testing.T) {\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1},\n\t\t\t\tResults: []*dot.Result{r2},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(A t1) t2 { return t2{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"create graph with one constructor and as interface option\", func(t *testing.T) {\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1},\n\t\t\t\tResults: []*dot.Result{r6},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(A t1) *t5 { return &t5{} }, dig.As(new(io.Reader)))\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"create graph with multiple constructors\", func(t *testing.T) {\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1},\n\t\t\t\tResults: []*dot.Result{r2},\n\t\t\t},\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1},\n\t\t\t\tResults: []*dot.Result{r3},\n\t\t\t},\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p2},\n\t\t\t\tResults: []*dot.Result{r4},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(A t1) t2 { return t2{} })\n\t\tc.RequireProvide(func(A t1) t3 { return t3{} })\n\t\tc.RequireProvide(func(A t2) t4 { return t4{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"create graph with scope\", func(t *testing.T) {\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1},\n\t\t\t\tResults: []*dot.Result{r2},\n\t\t\t},\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1},\n\t\t\t\tResults: []*dot.Result{r3},\n\t\t\t},\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p2},\n\t\t\t\tResults: []*dot.Result{r4},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(A t1) t2 { return t2{} })\n\n\t\ts := c.Scope(\"test\")\n\t\ts.Provide(func(A t1) t3 { return t3{} })\n\t\ts.Provide(func(A t2) t4 { return t4{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"create graph with child scope\", func(t *testing.T) {\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1},\n\t\t\t\tResults: []*dot.Result{r2},\n\t\t\t},\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1},\n\t\t\t\tResults: []*dot.Result{r3},\n\t\t\t},\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p2},\n\t\t\t\tResults: []*dot.Result{r4},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(A t1) t2 { return t2{} })\n\n\t\ts := c.Scope(\"parent_scope\")\n\t\ts.Provide(func(A t1) t3 { return t3{} })\n\n\t\tcs := s.Scope(\"child_scope\")\n\t\tcs.Provide(func(A t2) t4 { return t4{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"constructor with multiple params and results\", func(t *testing.T) {\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p3, p4},\n\t\t\t\tResults: []*dot.Result{r1, r2},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(A t3, B t4) (t1, t2) { return t1{}, t2{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"param objects and result objects\", func(t *testing.T) {\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tA t1\n\t\t\tB t2\n\t\t}\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tC t3\n\t\t\tD t4\n\t\t}\n\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1, p2},\n\t\t\t\tResults: []*dot.Result{r3, r4},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(i in) out { return out{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"nested param object\", func(t *testing.T) {\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tA    t1\n\t\t\tNest struct {\n\t\t\t\tdig.In\n\n\t\t\t\tB    t2\n\t\t\t\tNest struct {\n\t\t\t\t\tdig.In\n\n\t\t\t\t\tC t3\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1, p2, p3},\n\t\t\t\tResults: []*dot.Result{r4},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(p in) t4 { return t4{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"nested result object\", func(t *testing.T) {\n\t\ttype nested1 struct {\n\t\t\tdig.Out\n\n\t\t\tD t4\n\t\t}\n\n\t\ttype nested2 struct {\n\t\t\tdig.Out\n\n\t\t\tC    t3\n\t\t\tNest nested1\n\t\t}\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tB    t2\n\t\t\tNest nested2\n\t\t}\n\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p1},\n\t\t\t\tResults: []*dot.Result{r2, r3, r4},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(A t1) out { return out{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"value groups\", func(t *testing.T) {\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tD []t1 `group:\"foo\"`\n\t\t}\n\n\t\ttype out1 struct {\n\t\t\tdig.Out\n\n\t\t\tA t1 `group:\"foo\"`\n\t\t}\n\n\t\ttype out2 struct {\n\t\t\tdig.Out\n\n\t\t\tA t1 `group:\"foo\"`\n\t\t}\n\n\t\tres0 := tresult(type1, \"\", \"foo\", 0)\n\t\tres1 := tresult(type1, \"\", \"foo\", 1)\n\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p2},\n\t\t\t\tResults: []*dot.Result{res0},\n\t\t\t},\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{p4},\n\t\t\t\tResults: []*dot.Result{res1},\n\t\t\t},\n\t\t\t{\n\t\t\t\tGroupParams: []*dot.Group{\n\t\t\t\t\t{\n\t\t\t\t\t\tType:    type1,\n\t\t\t\t\t\tName:    \"foo\",\n\t\t\t\t\t\tResults: []*dot.Result{res0, res1},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResults: []*dot.Result{r3},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(B t2) out1 { return out1{} })\n\t\tc.RequireProvide(func(B t4) out2 { return out2{} })\n\t\tc.RequireProvide(func(i in) t3 { return t3{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"value groups as\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(\n\t\t\tfunc() *bytes.Buffer { return bytes.NewBufferString(\"foo\") },\n\t\t\tdig.As(new(io.Reader), new(io.Writer)),\n\t\t\tdig.Group(\"buffs\"),\n\t\t)\n\t\tc.RequireProvide(\n\t\t\tfunc() *bytes.Buffer { return bytes.NewBufferString(\"bar\") },\n\t\t\tdig.As(new(io.Reader), new(io.Writer)),\n\t\t\tdig.Group(\"buffs\"),\n\t\t)\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tResults: []*dot.Result{tresult(type6, \"\", \"buffs\", 0), tresult(type7, \"\", \"buffs\", 0)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tResults: []*dot.Result{tresult(type6, \"\", \"buffs\", 1), tresult(type7, \"\", \"buffs\", 1)},\n\t\t\t},\n\t\t}\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"named values\", func(t *testing.T) {\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tA t1 `name:\"A\"`\n\t\t}\n\n\t\ttype out struct {\n\t\t\tdig.Out\n\n\t\t\tB t2 `name:\"B\"`\n\t\t}\n\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams: []*dot.Param{\n\t\t\t\t\ttparam(type1, \"A\", \"\", false),\n\t\t\t\t},\n\t\t\t\tResults: []*dot.Result{\n\t\t\t\t\ttresult(type2, \"B\", \"\", 0),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(i in) out { return out{B: t2{}} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n\n\tt.Run(\"optional dependencies\", func(t *testing.T) {\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tA t1 `name:\"A\" optional:\"true\"`\n\t\t\tB t2 `name:\"B\"`\n\t\t\tC t3 `optional:\"true\"`\n\t\t}\n\n\t\tpar1 := tparam(type1, \"A\", \"\", true)\n\t\tpar2 := tparam(type2, \"B\", \"\", false)\n\t\tpar3 := tparam(type3, \"\", \"\", true)\n\n\t\texpected := []*dot.Ctor{\n\t\t\t{\n\t\t\t\tParams:  []*dot.Param{par1, par2, par3},\n\t\t\t\tResults: []*dot.Result{r4},\n\t\t\t},\n\t\t}\n\n\t\tc := digtest.New(t)\n\t\tc.RequireProvide(func(i in) t4 { return t4{} })\n\n\t\tdg := c.CreateGraph()\n\t\tassertCtorsEqual(t, expected, dg.Ctors)\n\t})\n}\n\nfunc assertCtorEqual(t *testing.T, expected *dot.Ctor, ctor *dot.Ctor) {\n\tassert.Equal(t, expected.Params, ctor.Params)\n\tassert.Equal(t, expected.Results, ctor.Results)\n\tassert.NotZero(t, ctor.Line)\n}\n\nfunc assertCtorsEqual(t *testing.T, expected []*dot.Ctor, ctors []*dot.Ctor) {\n\trequire.Equal(t, len(expected), len(ctors))\n\tfor i, c := range ctors {\n\t\tassertCtorEqual(t, expected[i], c)\n\t}\n}\n\nfunc TestVisualize(t *testing.T) {\n\ttype t1 struct{}\n\ttype t2 struct{}\n\ttype t3 struct{}\n\ttype t4 struct{}\n\n\tt.Parallel()\n\n\tt.Run(\"empty graph in container\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\tdig.VerifyVisualization(t, \"empty\", c.Container)\n\t})\n\n\tt.Run(\"simple graph\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(func() (t1, t2) { return t1{}, t2{} })\n\t\tc.RequireProvide(func(A t1, B t2) (t3, t4) { return t3{}, t4{} })\n\t\tdig.VerifyVisualization(t, \"simple\", c.Container)\n\t})\n\n\tt.Run(\"named types\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tA t3 `name:\"foo\"`\n\t\t}\n\t\ttype out1 struct {\n\t\t\tdig.Out\n\n\t\t\tA t1 `name:\"bar\"`\n\t\t\tB t2 `name:\"baz\"`\n\t\t}\n\t\ttype out2 struct {\n\t\t\tdig.Out\n\n\t\t\tA t3 `name:\"foo\"`\n\t\t}\n\n\t\tc.RequireProvide(func(in) out1 { return out1{} })\n\t\tc.RequireProvide(func() out2 { return out2{} })\n\t\tdig.VerifyVisualization(t, \"named\", c.Container)\n\t})\n\n\tt.Run(\"dig.As two types\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(\n\t\t\tfunc() *bytes.Buffer {\n\t\t\t\tpanic(\"this function should not be called\")\n\t\t\t},\n\t\t\tdig.As(new(io.Reader), new(io.Writer)))\n\n\t\tdig.VerifyVisualization(t, \"dig_as_two\", c.Container)\n\t})\n\n\tt.Run(\"optional params\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tA t1 `optional:\"true\"`\n\t\t}\n\n\t\tc.RequireProvide(func() t1 { return t1{} })\n\t\tc.RequireProvide(func(in) t2 { return t2{} })\n\t\tdig.VerifyVisualization(t, \"optional\", c.Container)\n\t})\n\n\tt.Run(\"grouped types\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype in struct {\n\t\t\tdig.In\n\n\t\t\tA []t3 `group:\"foo\"`\n\t\t}\n\n\t\ttype out1 struct {\n\t\t\tdig.Out\n\n\t\t\tA t3 `group:\"foo\"`\n\t\t}\n\n\t\ttype out2 struct {\n\t\t\tdig.Out\n\n\t\t\tA t3 `group:\"foo\"`\n\t\t}\n\n\t\tc.RequireProvide(func() out1 { return out1{} })\n\t\tc.RequireProvide(func() out2 { return out2{} })\n\t\tc.RequireProvide(func(in) t2 { return t2{} })\n\n\t\tdig.VerifyVisualization(t, \"grouped\", c.Container)\n\t})\n\n\tt.Run(\"constructor fails with an error\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\ttype in1 struct {\n\t\t\tdig.In\n\n\t\t\tC []t1 `group:\"g1\"`\n\t\t}\n\n\t\ttype in2 struct {\n\t\t\tdig.In\n\n\t\t\tA []t2 `group:\"g2\"`\n\t\t\tB t3   `name:\"n3\"`\n\t\t}\n\n\t\ttype out1 struct {\n\t\t\tdig.Out\n\n\t\t\tB t3 `name:\"n3\"`\n\t\t\tC t2 `group:\"g2\"`\n\t\t}\n\n\t\ttype out2 struct {\n\t\t\tdig.Out\n\n\t\t\tD t2 `group:\"g2\"`\n\t\t}\n\n\t\ttype out3 struct {\n\t\t\tdig.Out\n\n\t\t\tA t1 `group:\"g1\"`\n\t\t\tB t2 `group:\"g2\"`\n\t\t}\n\n\t\tc.RequireProvide(func(in1) out1 { return out1{} })\n\t\tc.RequireProvide(func(in2) t4 { return t4{} })\n\t\tc.RequireProvide(func() out2 { return out2{} })\n\t\tc.RequireProvide(func() (out3, error) { return out3{}, errors.New(\"great sadness\") })\n\t\terr := c.Invoke(func(t4 t4) {})\n\n\t\tdig.VerifyVisualization(t, \"error\", c.Container, dig.VisualizeError(err))\n\n\t\tt.Run(\"non-failing graph nodes are pruned\", func(t *testing.T) {\n\t\t\tt.Run(\"prune non-failing constructor result\", func(t *testing.T) {\n\t\t\t\tc := digtest.New(t)\n\t\t\t\tc.RequireProvide(func(in1) out1 { return out1{} })\n\t\t\t\tc.RequireProvide(func(in2) t4 { return t4{} })\n\t\t\t\tc.RequireProvide(func() (out2, error) { return out2{}, errors.New(\"great sadness\") })\n\t\t\t\tc.RequireProvide(func() out3 { return out3{} })\n\t\t\t\terr := c.Invoke(func(t4 t4) {})\n\n\t\t\t\tdig.VerifyVisualization(t, \"prune_constructor_result\", c.Container, dig.VisualizeError(err))\n\t\t\t})\n\n\t\t\tt.Run(\"if only the root node fails all node except for the root should be pruned\", func(t *testing.T) {\n\t\t\t\tc := digtest.New(t)\n\t\t\t\tc.RequireProvide(func(in1) out1 { return out1{} })\n\t\t\t\tc.RequireProvide(func(in2) (t4, error) { return t4{}, errors.New(\"great sadness\") })\n\t\t\t\tc.RequireProvide(func() out2 { return out2{} })\n\t\t\t\tc.RequireProvide(func() out3 { return out3{} })\n\t\t\t\terr := c.Invoke(func(t4 t4) {})\n\n\t\t\t\tdig.VerifyVisualization(t, \"prune_non_root_nodes\", c.Container, dig.VisualizeError(err))\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"missing types\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\n\t\tc.RequireProvide(func(A t1, B t2, C t3) t4 { return t4{} })\n\t\terr := c.Invoke(func(t4 t4) {})\n\n\t\tdig.VerifyVisualization(t, \"missing\", c.Container, dig.VisualizeError(err))\n\t})\n\n\tt.Run(\"missing dependency\", func(t *testing.T) {\n\t\tc := digtest.New(t)\n\t\terr := c.Invoke(func(t1 t1) {})\n\n\t\tdig.VerifyVisualization(t, \"missingDep\", c.Container, dig.VisualizeError(err))\n\t})\n}\n\nfunc TestVisualizeErrorString(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\topt := dig.VisualizeError(nil)\n\t\tassert.Equal(t, \"VisualizeError(<nil>)\", fmt.Sprint(opt))\n\t})\n\n\tt.Run(\"not nil\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\topt := dig.VisualizeError(errors.New(\"great sadness\"))\n\t\tassert.Equal(t, \"VisualizeError(great sadness)\", fmt.Sprint(opt))\n\t})\n}\n"
        }
      ]
    }
  ]
}