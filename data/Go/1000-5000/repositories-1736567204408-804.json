{
  "metadata": {
    "timestamp": 1736567204408,
    "page": 804,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jedisct1/piknik",
      "stars": 2453,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.267578125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\npiknik\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 2.1376953125,
          "content": "* Version 0.9.1\n - Piknik can now be compiled for Plan9 and Solaris.\n - Sending an INFO signal to the server now prints whether the clipboard\nis empty or not.\n - Godep was replaced with Glide.\n - Documentation fixes.\n\n* Version 0.9\n - Support for protocol version 3 (Piknik <= 0.2) was removed from the server.\n Please upgrade the clients running these old versions.\n - Compatibility with protocol version 4 (Piknik >= 0.3 and <= 0.7) was\n restored.\n\n* Version 0.8\n - The clipboard now includes a timestamp, so that clients can reject\ncontent that is too old. By default, the maximum age is 7 days. This\ncan be adjusted with a \"TTL\" property in the configuration file. The\nduration is expressed in seconds.\n\n* Version 0.7\n - The number of simultaneous connections to a Piknik server can now\nbe controlled with the `-maxclients` command-line flag. When more than\n90% of the available slots are filled, new sessions can only be open by\nclient IPs having recently completed a successful handshake.\n - New command-line flags: `-timeout` and `-datatimeout` in order to\nenforce deadlines for handshakes and data transfers.\n\n* Version 0.6\n - Improved error messages\n\n* Version 0.5\n - A new switch, `-password` can now follow `-genkeys` in order to\ndeterministically derive the keys from a password. Not recommended,\nbut it can be useful to create an temporary initial configuration on air\ngapped devices.\n - An Homebrew (tap) formula was added to easily install it and keep it up\nto date on MacOS.\n\n* Version 0.4\n - Servers recomputed the key ID instead of reading it from the\nclient, requiring the `EncryptSk` property to be present. This is no\nlonger the case. Thanks to jpmens@ for the bug report.\n\n* Version 0.3\n - Improved documentation\n - The protocol was slightly changed; old clients are still supported\nbut the server must be updated in order to communicate with clients\nrunning this version.\n - Precompiled binaries are now available for many architectures.\n\n* Version 0.2\n - New `-move` operation to paste the clipboard content and delete it\nafterwards. This introduces a protocol change, requiring an update to\nthe server and to the clients.\n\n* Version 0.1\n - Initial public release.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.283203125,
          "content": "ISC LICENSE.\n\nCopyright (c) 2016-2024, Frank Denis\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.0302734375,
          "content": "[![Latest release](https://img.shields.io/github/release/jedisct1/piknik.svg)](https://github.com/jedisct1/piknik/releases/latest)\n[![Build status](https://travis-ci.com/jedisct1/piknik.svg?branch=master)](https://travis-ci.com/jedisct1/piknik?branch=master)\n![CodeQL scan](https://github.com/jedisct1/piknik/workflows/Code%20scanning%20-%20action/badge.svg)\n\n# Piknik\n\nCopy/paste anything over the network!\n\n[[watch a demo on Asciinema](https://asciinema.org/a/80708)] -\n[[download the source code / binaries](https://github.com/jedisct1/piknik/releases/latest)]\n\n![Piknik](https://raw.github.com/jedisct1/piknik/master/piknik.png)\n\nEver needed a copy/paste clipboard that works over the network?\n\nPiknik seamlessly and securely transfers URLs, code snippets, documents, virtually anything between arbitrary hosts.\n\nNo SSH needed, and hosts can sit behind NAT gateways, on different networks.\n\nFill in the clipboard (\"copy\") with whatever comes in to the standard input:\n\n```sh\n$ pkc\nclipboard content\n```\n\nMagically retrieve that content from any other host having Piknik installed with the same configuration:\n\n```sh\n$ pkp\nclipboard content\n```\n\nBoom.\n\nObviously, it can be used to transfer files as well:\n\n```sh\n$ pkc < kitten.gif\n$ pkp > kittencopy.gif\n```\n\n```sh\n$ tar cvf - *.txt | pkc\n$ pkp | tar xvf -\n```\n\nIn order to work around firewalls/NAT gatways, the clipboard content transits over TCP via a staging server.\n\nNothing transits without end-to-end encryption; the server cannot learn much about what the clipboard actually contains.\n\nData can be shared between different operating systems, including MacOS, Linux and Windows.\n\n## Installation\n\n### Option 1: use precompiled binaries\n\nPrecompiled binaries for MacOS, Linux (i386, x86_64, ARM), Win32, Win64, DragonflyBSD, NetBSD and FreeBSD can be downloaded here:\nhttps://github.com/jedisct1/piknik/releases/latest\n\n### Option 2 (on MacOS): use Homebrew\n\n```sh\n$ brew install piknik\n```\n\n### Option 3: compile the source code\n\nThis project is written in Go.\n\nGo >= 1.11 is required, as well as the following incantation:\n\n```sh\n$ go build\n```\n\nThe `piknik` executable file should then be available in current path.\n\n## Setup\n\nPiknik requires a bunch of keys. Generate them all with\n\n```sh\n$ piknik -genkeys\n```\n\nThis generates random keys (highly recommended).\n\nYou will need to copy parts (not all!) of that command's output to a `piknik.toml` configuration file.\n\nA temporary alternative is to derive the keys from a password. The same password will always generate the same set of keys, on all platforms. In order to do so, add the `-password` switch:\n\n```sh\n$ piknik -genkeys -password\n```\n\nThe output of the `-genkeys` command is all you need to build a configuration file.\n\nOnly copy the section for servers on the staging server. Only copy the section for clients on the clients.\n\nIs a host gonna act both as a staging server and as a client? Ponder on it before copying the \"hybrid\" section, but it's there, just in case.\n\nThe default location for the configuration file is `~/.piknik.toml`. With the exception of Windows, where dot-files are not so common. On that platform, the file is simply called `piknik.toml`.\n\nSample configuration file for a staging server:\n\n```toml\nListen = \"0.0.0.0:8075\"         # Edit appropriately\nPsk    = \"bf82bab384697243fbf616d3428477a563e33268f0f2307dd14e7245dd8c995d\"\nSignPk = \"0c41ca9b0a1b5fe4daae789534e72329a93a352a6ad73d6f1d368d8eff37271c\"\n```\n\nSample configuration file for clients:\n\n```toml\nConnect   = \"127.0.0.1:8075\"    # Edit appropriately\nPsk       = \"bf82bab384697243fbf616d3428477a563e33268f0f2307dd14e7245dd8c995d\"\nSignPk    = \"0c41ca9b0a1b5fe4daae789534e72329a93a352a6ad73d6f1d368d8eff37271c\"\nSignSk    = \"cecf1d92052f7ba87da36ac3e4a745b64ade8f9e908e52b4f7cd41235dfe7481\"\nEncryptSk = \"2f530eb85e59c1977fce726df9f87345206f2a3d40bf91f9e0e9eeec2c59a3e4\"\n```\n\nDo not use these, uh? Get your very own keys with the `piknik -genkeys` command.\nEdit the `Connect` and `Listen` properties to reflect the staging server IP and port.\nAnd `chmod 600 ~/.piknik.toml` might not be a bad idea.\n\nDon't like the default config file location? Use the `-config` switch.\n\n## Usage (staging server)\n\nRun the following command on the staging server (or use `runit`, `openrc`, `systemd`, whatever to run it as a background service):\n\n```sh\n$ piknik -server\n```\n\nThe staging server has to be publicly accessible. At the very least, it must be reachable by the clients over TCP with the port you specify in the configuration.\n\nCommands without a valid API key (present in the client configuration file) will be rejected by the server.\n\n## Usage (clients)\n\n```sh\n$ piknik -copy\n```\n\nCopy the standard input to the clipboard.\n\n```sh\n$ piknik -paste\n```\n\nRetrieve the content of the clipboard and spit it to the standard output.\n`-paste` is actually a no-op. This is the default action if `-copy` was not specified.\n\n```sh\n$ piknik -move\n```\n\nRetrieve the content of the clipboard, spit it to the standard output\nand clear the clipboard. Not necessarily in this order.\nOnly one lucky client will have the privilege to see the content.\n\nThat's it.\n\nFeed it anything. Text, binary data, whatever. As long as it fits in memory.\n\n## Suggested shell aliases\n\nWait. Where are the `pkc` and `pkp` commands mentioned earlier?\n\nSample shell aliases:\n\n```sh\n# pko <content> : copy <content> to the clipboard\npko() {\n    echo \"$*\" | piknik -copy\n}\n\n# pkf <file> : copy the content of <file> to the clipboard\npkf() {\n    piknik -copy < $1\n}\n\n# pkc : read the content to copy to the clipboard from STDIN\nalias pkc='piknik -copy'\n\n# pkp : paste the clipboard content\nalias pkp='piknik -paste'\n\n# pkm : move the clipboard content\nalias pkm='piknik -move'\n\n# pkz : delete the clipboard content\nalias pkz='piknik -copy < /dev/null'\n\n# pkfr [<dir>] : send a whole directory to the clipboard, as a tar archive\npkfr() {\n    tar czpvf - ${1:-.} | piknik -copy\n}\n\n# pkpr : extract clipboard content sent using the pkfr command\nalias pkpr='piknik -paste | tar xzpvf -'\n```\n\n## Piknik integration in third-party packages\n\n* The [Piknik package for Atom](https://atom.io/packages/piknik)\nallows copying/pasting text between hosts running the Atom text editor.\n* The [Piknik package for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=jedisct1.piknik)\nallows copying/pasting text between hosts running the Visual Studio Code text editor.\n\n## Use cases\n\nUse it to:\n\n* Securely send passwords, API keys, URLs from one host to another\n* Share a clipboard with your teammates (which can be a lot of fun)\n* Copy data from/to isolated VMs, without the VMWare tools or shared volumes (great for unsupported operating systems and malware sandboxes)\n* Copy files from/to a Windows machine, without Samba or SSH\n* Transfer data between hosts sitting behind firewalls/NAT gateways\n* Easily copy configuration files to multiple hosts\n* Start a slow download at the office, retrieve it later at home\n* Quickly backup a file to the cloud before messing with it\n* ...and more!\n\n## Protocol\n\nCommon definitions:\n\n```text\nk: API key\nek: 256-bit symmetric encryption key\nekid: encryption key id encoded as a 64-bit little endian integer\nm: plaintext\nct: XChaCha20 ek,n (m)\nHk,s: BLAKE2b(domain=\"SK\", key=k, salt=s, size=32)\nLen(x): x encoded as a 64-bit little endian unsigned integer\nn: random 192-bit nonce\nr: random 256-bit client nonce\nr': random 256-bit server nonce\nts: Unix timestamp as a 64-bit little endian integer\nSig: Ed25519\nv: 6\n```\n\nCopy:\n\n```text\n-> v || r || h0\nh0 := Hk,0(v || r)\n\n<- v || r' || h1\nh1 := Hk,1(v || r' || h0)\n\n-> 'S' || h2 || Len(ekid || n || ct) || ts || s || ekid || n || ct\ns := Sig(ekid || n || ct)\nh2 := Hk,2(h1 || 'S' || ts || s)\n\n<- Hk,3(h2)\n```\n\nMove/Paste:\n\n```text\nMove:  opcode := 'M'\nPaste: opcode := 'G'\n\n-> v || r || h0\nh0 := Hk,0(v || r)\n\n<- v || r' || h1\nh1 := Hk,1(v || r' || H0)\n\n-> opcode || h2\nh2 := Hk,2(h1 || opcode)\n\n<- Hk,3(h2 || ts || s) || Len(ekid || n || ct) || ts || s || ekid || n || ct\ns := Sig(ekid || n || ct)\n```\n\n## License\n\n[ISC](https://en.wikipedia.org/wiki/ISC_license).\n\n## Credits\n\nPiknik diagram by [EasyPi](https://easypi.herokuapp.com/copy-paste-anything-over-network/).\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 1.7646484375,
          "content": "package main\n\nimport blake2b \"github.com/minio/blake2b-simd\"\n\nfunc auth0(conf Conf, clientVersion byte, r []byte) []byte {\n\thf0, _ := blake2b.New(&blake2b.Config{\n\t\tKey:    conf.Psk,\n\t\tPerson: []byte(DomainStr),\n\t\tSize:   32,\n\t\tSalt:   []byte{0},\n\t})\n\thf0.Write([]byte{clientVersion})\n\thf0.Write(r)\n\th0 := hf0.Sum(nil)\n\n\treturn h0\n}\n\nfunc auth1(conf Conf, clientVersion byte, h0 []byte, r2 []byte) []byte {\n\thf1, _ := blake2b.New(&blake2b.Config{\n\t\tKey:    conf.Psk,\n\t\tPerson: []byte(DomainStr),\n\t\tSize:   32,\n\t\tSalt:   []byte{1},\n\t})\n\thf1.Write([]byte{clientVersion})\n\thf1.Write(r2)\n\thf1.Write(h0)\n\th1 := hf1.Sum(nil)\n\n\treturn h1\n}\n\nfunc auth2get(conf Conf, clientVersion byte, h1 []byte, opcode byte) []byte {\n\thf2, _ := blake2b.New(&blake2b.Config{\n\t\tKey:    conf.Psk,\n\t\tPerson: []byte(DomainStr),\n\t\tSize:   32,\n\t\tSalt:   []byte{2},\n\t})\n\thf2.Write(h1)\n\thf2.Write([]byte{opcode})\n\th2 := hf2.Sum(nil)\n\n\treturn h2\n}\n\nfunc auth2store(conf Conf, clientVersion byte, h1 []byte, opcode byte,\n\tts []byte, signature []byte,\n) []byte {\n\thf2, _ := blake2b.New(&blake2b.Config{\n\t\tKey:    conf.Psk,\n\t\tPerson: []byte(DomainStr),\n\t\tSize:   32,\n\t\tSalt:   []byte{2},\n\t})\n\thf2.Write(h1)\n\thf2.Write([]byte{opcode})\n\thf2.Write(ts)\n\thf2.Write(signature)\n\th2 := hf2.Sum(nil)\n\n\treturn h2\n}\n\nfunc auth3get(conf Conf, clientVersion byte, h2 []byte,\n\tts []byte, signature []byte,\n) []byte {\n\thf3, _ := blake2b.New(&blake2b.Config{\n\t\tKey:    conf.Psk,\n\t\tPerson: []byte(DomainStr),\n\t\tSize:   32,\n\t\tSalt:   []byte{3},\n\t})\n\thf3.Write(h2)\n\thf3.Write(ts)\n\thf3.Write(signature)\n\th3 := hf3.Sum(nil)\n\n\treturn h3\n}\n\nfunc auth3store(conf Conf, h2 []byte) []byte {\n\thf3, _ := blake2b.New(&blake2b.Config{\n\t\tKey:    conf.Psk,\n\t\tPerson: []byte(DomainStr),\n\t\tSize:   32,\n\t\tSalt:   []byte{3},\n\t})\n\thf3.Write(h2)\n\th3 := hf3.Sum(nil)\n\n\treturn h3\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 6.1279296875,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/subtle\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/chacha20\"\n\t\"golang.org/x/crypto/ed25519\"\n)\n\n// DefaultClientVersion - Default client version\nconst DefaultClientVersion = byte(6)\n\n// Client - Client data\ntype Client struct {\n\tconf    Conf\n\tconn    net.Conn\n\treader  *bufio.Reader\n\twriter  *bufio.Writer\n\tversion byte\n}\n\nfunc (client *Client) copyOperation(h1 []byte) {\n\tts := make([]byte, 8)\n\tbinary.LittleEndian.PutUint64(ts, uint64(time.Now().Unix()))\n\n\tconf, reader, writer := client.conf, client.reader, client.writer\n\n\tvar contentWithEncryptSkIDAndNonceBuf bytes.Buffer\n\tcontentWithEncryptSkIDAndNonceBuf.Grow(8 + 24 + bytes.MinRead)\n\n\tcontentWithEncryptSkIDAndNonceBuf.Write(conf.EncryptSkID)\n\n\tnonce := make([]byte, 24)\n\tif _, err := rand.Read(nonce); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcontentWithEncryptSkIDAndNonceBuf.Write(nonce)\n\n\t_, err := contentWithEncryptSkIDAndNonceBuf.ReadFrom(os.Stdin)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcontentWithEncryptSkIDAndNonce := contentWithEncryptSkIDAndNonceBuf.Bytes()\n\n\tcipher, err := chacha20.NewUnauthenticatedCipher(conf.EncryptSk, nonce)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\topcode := byte('S')\n\tcipher.XORKeyStream(contentWithEncryptSkIDAndNonce[8+24:], contentWithEncryptSkIDAndNonce[8+24:])\n\tsignature := ed25519.Sign(conf.SignSk, contentWithEncryptSkIDAndNonce)\n\n\tclient.conn.SetDeadline(time.Now().Add(conf.DataTimeout))\n\th2 := auth2store(conf, client.version, h1, opcode, ts, signature)\n\twriter.WriteByte(opcode)\n\twriter.Write(h2)\n\tciphertextWithEncryptSkIDAndNonceLen := uint64(len(contentWithEncryptSkIDAndNonce))\n\tbinary.Write(writer, binary.LittleEndian, ciphertextWithEncryptSkIDAndNonceLen)\n\twriter.Write(ts)\n\twriter.Write(signature)\n\twriter.Write(contentWithEncryptSkIDAndNonce)\n\tif err = writer.Flush(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\trbuf := make([]byte, 32)\n\tif _, err = io.ReadFull(reader, rbuf); err != nil {\n\t\tif err == io.ErrUnexpectedEOF {\n\t\t\tlog.Fatal(\"The server may be running an incompatible version\")\n\t\t} else {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\th3 := rbuf\n\twh3 := auth3store(conf, h2)\n\tif subtle.ConstantTimeCompare(wh3, h3) != 1 {\n\t\tlog.Fatal(\"Incorrect authentication code\")\n\t}\n\tif IsTerminal(int(syscall.Stderr)) {\n\t\tos.Stderr.WriteString(\"Sent\\n\")\n\t}\n}\n\nfunc (client *Client) pasteOperation(h1 []byte, isMove bool) {\n\tconf, reader, writer := client.conf, client.reader, client.writer\n\topcode := byte('G')\n\tif isMove {\n\t\topcode = byte('M')\n\t}\n\th2 := auth2get(conf, client.version, h1, opcode)\n\twriter.WriteByte(opcode)\n\twriter.Write(h2)\n\tif err := writer.Flush(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\trbuf := make([]byte, 112)\n\tif nbread, err := io.ReadFull(reader, rbuf); err != nil {\n\t\tif err == io.ErrUnexpectedEOF {\n\t\t\tif nbread < 80 {\n\t\t\t\tlog.Fatal(\"The clipboard might be empty\")\n\t\t\t} else {\n\t\t\t\tlog.Fatal(\"The server may be running an incompatible version\")\n\t\t\t}\n\t\t} else {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\th3 := rbuf[0:32]\n\tciphertextWithEncryptSkIDAndNonceLen := binary.LittleEndian.Uint64(rbuf[32:40])\n\tts := rbuf[40:48]\n\tsignature := rbuf[48:112]\n\twh3 := auth3get(conf, client.version, h2, ts, signature)\n\tif subtle.ConstantTimeCompare(wh3, h3) != 1 {\n\t\tlog.Fatal(\"Incorrect authentication code\")\n\t}\n\telapsed := time.Since(time.Unix(int64(binary.LittleEndian.Uint64(ts)), 0))\n\tif elapsed >= conf.TTL {\n\t\tlog.Fatal(\"Clipboard content is too old\")\n\t}\n\tif ciphertextWithEncryptSkIDAndNonceLen < 8+24 {\n\t\tlog.Fatal(\"Clipboard content is too short\")\n\t}\n\tciphertextWithEncryptSkIDAndNonce := make([]byte, ciphertextWithEncryptSkIDAndNonceLen)\n\tclient.conn.SetDeadline(time.Now().Add(conf.DataTimeout))\n\tif _, err := io.ReadFull(reader, ciphertextWithEncryptSkIDAndNonce); err != nil {\n\t\tif err == io.ErrUnexpectedEOF {\n\t\t\tlog.Fatal(\"The server may be running an incompatible version\")\n\t\t} else {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\tencryptSkID := ciphertextWithEncryptSkIDAndNonce[0:8]\n\tif !bytes.Equal(conf.EncryptSkID, encryptSkID) {\n\t\twEncryptSkIDStr := binary.LittleEndian.Uint64(conf.EncryptSkID)\n\t\tencryptSkIDStr := binary.LittleEndian.Uint64(encryptSkID)\n\t\tlog.Fatal(fmt.Sprintf(\"Configured key ID is %v but content was encrypted using key ID %v\",\n\t\t\twEncryptSkIDStr, encryptSkIDStr))\n\t}\n\tif !ed25519.Verify(conf.SignPk, ciphertextWithEncryptSkIDAndNonce, signature) {\n\t\tlog.Fatal(\"Signature doesn't verify\")\n\t}\n\tnonce := ciphertextWithEncryptSkIDAndNonce[8:32]\n\tcipher, err := chacha20.NewUnauthenticatedCipher(conf.EncryptSk, nonce)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcontent := ciphertextWithEncryptSkIDAndNonce[32:]\n\tcipher.XORKeyStream(content, content)\n\tbinary.Write(os.Stdout, binary.LittleEndian, content)\n}\n\n// RunClient - Process a client query\nfunc RunClient(conf Conf, isCopy bool, isMove bool) {\n\tconn, err := net.DialTimeout(\"tcp\", conf.Connect, conf.Timeout)\n\tif err != nil {\n\t\tlog.Fatal(fmt.Sprintf(\"Unable to connect to %v - Is a Piknik server running on that host?\",\n\t\t\tconf.Connect))\n\t}\n\tdefer conn.Close()\n\n\tconn.SetDeadline(time.Now().Add(conf.Timeout))\n\treader, writer := bufio.NewReader(conn), bufio.NewWriter(conn)\n\tclient := Client{\n\t\tconf:    conf,\n\t\tconn:    conn,\n\t\treader:  reader,\n\t\twriter:  writer,\n\t\tversion: DefaultClientVersion,\n\t}\n\tr := make([]byte, 32)\n\tif _, err = rand.Read(r); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\th0 := auth0(conf, client.version, r)\n\twriter.Write([]byte{client.version})\n\twriter.Write(r)\n\twriter.Write(h0)\n\tif err := writer.Flush(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\trbuf := make([]byte, 65)\n\tif nbread, err := io.ReadFull(reader, rbuf); err != nil {\n\t\tif nbread < 2 {\n\t\t\tlog.Fatal(\"The server rejected the connection - Check that it is running the same Piknik version or retry later\")\n\t\t} else {\n\t\t\tlog.Fatal(\"The server doesn't support this protocol\")\n\t\t}\n\t}\n\tif serverVersion := rbuf[0]; serverVersion != client.version {\n\t\tlog.Fatal(fmt.Sprintf(\"Incompatible server version (client version: %v - server version: %v)\",\n\t\t\tclient.version, serverVersion))\n\t}\n\tr2 := rbuf[1:33]\n\th1 := rbuf[33:65]\n\twh1 := auth1(conf, client.version, h0, r2)\n\tif subtle.ConstantTimeCompare(wh1, h1) != 1 {\n\t\tlog.Fatal(\"Incorrect authentication code\")\n\t}\n\tif isCopy {\n\t\tclient.copyOperation(h1)\n\t} else {\n\t\tclient.pasteOperation(h1, isMove)\n\t}\n}\n"
        },
        {
          "name": "fish-shell",
          "type": "tree",
          "content": null
        },
        {
          "name": "genkeys.go",
          "type": "blob",
          "size": 2.8388671875,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/ed25519\"\n\t\"golang.org/x/crypto/scrypt\"\n)\n\n// DeterministicRand - Deterministic random function\ntype DeterministicRand struct {\n\tpool []byte\n\tpos  int\n}\n\nvar deterministicRand DeterministicRand\n\nfunc initDeterministicRand(leKey []byte, poolLen int) {\n\tkey, err := scrypt.Key(leKey, []byte{}, 16384, 12, 1, poolLen)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\tdeterministicRand.pool, deterministicRand.pos = key, 0\n}\n\nfunc (DeterministicRand) Read(p []byte) (n int, err error) {\n\treqLen := len(p)\n\tleft := len(deterministicRand.pool) - deterministicRand.pos\n\tif left < reqLen {\n\t\tlog.Panic(fmt.Sprintf(\"rand pool exhaustion (%v left, %v needed)\",\n\t\t\tleft, reqLen))\n\t}\n\tcopy(p, deterministicRand.pool[deterministicRand.pos:deterministicRand.pos+reqLen])\n\tfor i := 0; i < reqLen; i++ {\n\t\tdeterministicRand.pool[i] = 0\n\t}\n\tdeterministicRand.pos += reqLen\n\n\treturn reqLen, nil\n}\n\nfunc genKeys(conf Conf, configFile string, leKey string) {\n\trandRead, randReader := rand.Read, io.Reader(nil)\n\tif len(leKey) > 0 {\n\t\tinitDeterministicRand([]byte(leKey), 96)\n\t\trandRead, randReader = deterministicRand.Read, deterministicRand\n\t}\n\tpsk := make([]byte, 32)\n\tif _, err := randRead(psk); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tpskHex := hex.EncodeToString(psk)\n\n\tencryptSk := make([]byte, 32)\n\tif _, err := randRead(encryptSk); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tencryptSkHex := hex.EncodeToString(encryptSk)\n\n\tsignPk, signSk, err := ed25519.GenerateKey(randReader)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tsignPkHex := hex.EncodeToString(signPk)\n\tsignSkHex := hex.EncodeToString(signSk[0:32])\n\n\tfmt.Printf(\"\\n\\n--- Create a file named %s with only the lines relevant to your configuration ---\\n\\n\\n\", configFile)\n\tfmt.Printf(\"# Configuration for a client\\n\\n\")\n\tfmt.Printf(\"Connect   = %q\\t# Edit appropriately\\n\", conf.Connect)\n\tfmt.Printf(\"Psk       = %q\\n\", pskHex)\n\tfmt.Printf(\"SignPk    = %q\\n\", signPkHex)\n\tfmt.Printf(\"SignSk    = %q\\n\", signSkHex)\n\tfmt.Printf(\"EncryptSk = %q\\n\", encryptSkHex)\n\n\tfmt.Printf(\"\\n\\n\")\n\n\tfmt.Printf(\"# Configuration for a server\\n\\n\")\n\tfmt.Printf(\"Listen = %q\\t# Edit appropriately\\n\", conf.Listen)\n\tfmt.Printf(\"Psk    = %q\\n\", pskHex)\n\tfmt.Printf(\"SignPk = %q\\n\", signPkHex)\n\n\tfmt.Printf(\"\\n\\n\")\n\n\tfmt.Printf(\"# Hybrid configuration\\n\\n\")\n\tfmt.Printf(\"Connect   = %q\\t# Edit appropriately\\n\", conf.Connect)\n\tfmt.Printf(\"Listen    = %q\\t# Edit appropriately\\n\", conf.Listen)\n\tfmt.Printf(\"Psk       = %q\\n\", pskHex)\n\tfmt.Printf(\"SignPk    = %q\\n\", signPkHex)\n\tfmt.Printf(\"SignSk    = %q\\n\", signSkHex)\n\tfmt.Printf(\"EncryptSk = %q\\n\", encryptSkHex)\n}\n\nfunc getPassword(prompt string) string {\n\tos.Stdout.Write([]byte(prompt))\n\treader := bufio.NewReader(os.Stdin)\n\tpassword, err := reader.ReadString('\\n')\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn strings.TrimSpace(password)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2939453125,
          "content": "module github.com/jedisct1/piknik\n\ngo 1.23.4\n\nrequire (\n\tgithub.com/BurntSushi/toml v1.4.0\n\tgithub.com/minio/blake2b-simd v0.0.0-20160723061019-3f5f724cb5b1\n\tgithub.com/mitchellh/go-homedir v1.1.0\n\tgolang.org/x/crypto v0.31.0\n\tgolang.org/x/term v0.27.0\n)\n\nrequire golang.org/x/sys v0.28.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.02734375,
          "content": "github.com/BurntSushi/toml v1.4.0 h1:kuoIxZQy2WRRk1pttg9asf+WVv6tWQuBNVmK8+nqPr0=\ngithub.com/BurntSushi/toml v1.4.0/go.mod h1:ukJfTF/6rtPPRCnwkur4qwRxa8vTRFBF0uk2lLoLwho=\ngithub.com/minio/blake2b-simd v0.0.0-20160723061019-3f5f724cb5b1 h1:lYpkrQH5ajf0OXOcUbGjvZxxijuBwbbmlSxLiuofa+g=\ngithub.com/minio/blake2b-simd v0.0.0-20160723061019-3f5f724cb5b1/go.mod h1:pD8RvIylQ358TN4wwqatJ8rNavkEINozVn9DtGI3dfQ=\ngithub.com/mitchellh/go-homedir v1.1.0 h1:lukF9ziXFxDFPkA1vsr5zpc1XuPDn/wFntq5mG+4E0Y=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=\ngolang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\n"
        },
        {
          "name": "piknik.go",
          "type": "blob",
          "size": 5.7734375,
          "content": "package main\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/BurntSushi/toml\"\n\t\"github.com/minio/blake2b-simd\"\n\t\"github.com/mitchellh/go-homedir\"\n)\n\nconst (\n\t// Version - Piknik version\n\tVersion = \"0.10.2\"\n\t// DomainStr - BLAKE2 domain (personalization)\n\tDomainStr = \"PK\"\n\t// DefaultListen - Default value for the Listen parameter\n\tDefaultListen = \"0.0.0.0:8075\"\n\t// DefaultConnect - Default value for the Connect parameter\n\tDefaultConnect = \"127.0.0.1:8075\"\n\t// DefaultTTL - Time after the clipboard is considered obsolete, in seconds\n\tDefaultTTL = 7 * 24 * time.Hour\n)\n\ntype tomlConfig struct {\n\tConnect     string\n\tListen      string\n\tEncryptSk   string\n\tEncryptSkID uint64\n\tPsk         string\n\tSignPk      string\n\tSignSk      string\n\tTimeout     uint\n\tDataTimeout uint\n\tTTL         uint\n}\n\n// Conf - Shared config\ntype Conf struct {\n\tConnect        string\n\tListen         string\n\tMaxClients     uint64\n\tMaxLen         uint64\n\tEncryptSk      []byte\n\tEncryptSkID    []byte\n\tPsk            []byte\n\tSignPk         []byte\n\tSignSk         []byte\n\tTimeout        time.Duration\n\tDataTimeout    time.Duration\n\tTTL            time.Duration\n\tTrustedIPCount uint64\n}\n\nfunc expandConfigFile(path string) string {\n\tfile, err := homedir.Expand(path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn file\n}\n\nfunc version() {\n\tfmt.Printf(\"\\nPiknik v%v (protocol version: %v)\\n\",\n\t\tVersion, DefaultClientVersion)\n}\n\nfunc confCheck(conf Conf, isServer bool) {\n\tif len(conf.Psk) != 32 {\n\t\tlog.Fatal(\"Configuration error: the Psk property is either missing or invalid\")\n\t}\n\tif len(conf.SignPk) != 32 {\n\t\tlog.Fatal(\"Configuration error: the SignPk property is either missing or invalid\")\n\t}\n\tif isServer {\n\t\tif len(conf.Listen) < 3 {\n\t\t\tlog.Fatal(\"Configuration error: the Listen property must be valid for a server\")\n\t\t}\n\t\tif conf.MaxClients <= 0 {\n\t\t\tlog.Fatal(\"Configuration error: MaxClients should be at least 1\")\n\t\t}\n\t} else {\n\t\tif len(conf.Connect) < 3 {\n\t\t\tlog.Fatal(\"Configuration error: the Connect property must be valid for a client\")\n\t\t}\n\t\tif len(conf.EncryptSk) != 32 || len(conf.SignSk) != 64 {\n\t\t\tlog.Fatal(\"Configuration error: the EncryptSk and SignSk properties must be present\\n\" +\n\t\t\t\t\"and valid in order to use this command in client mode\")\n\t\t}\n\t\tif conf.TTL <= 0 {\n\t\t\tlog.Fatal(\"TTL cannot be 0\")\n\t\t}\n\t}\n}\n\nfunc main() {\n\tlog.SetFlags(0)\n\n\tisCopy := flag.Bool(\"copy\", false, \"store content (copy)\")\n\t_ = flag.Bool(\"paste\", false, \"retrieve the content (paste) - this is the default action\")\n\tisMove := flag.Bool(\"move\", false, \"retrieve and delete the clipboard content\")\n\tisServer := flag.Bool(\"server\", false, \"start a server\")\n\tisGenKeys := flag.Bool(\"genkeys\", false, \"generate keys\")\n\tisDeterministic := flag.Bool(\"password\", false, \"derive the keys from a password (default=random keys)\")\n\tmaxClients := flag.Uint64(\"maxclients\", 10, \"maximum number of simultaneous client connections\")\n\tmaxLenMb := flag.Uint64(\"maxlen\", 0, \"maximum content length to accept in Mb (0=unlimited)\")\n\ttimeout := flag.Uint(\"timeout\", 10, \"connection timeout (seconds)\")\n\tdataTimeout := flag.Uint(\"datatimeout\", 3600, \"data transmission timeout (seconds)\")\n\tisVersion := flag.Bool(\"version\", false, \"display package version\")\n\n\tdefaultConfigFile := \"~/.piknik.toml\"\n\tif runtime.GOOS == \"windows\" {\n\t\tdefaultConfigFile = \"~/piknik.toml\"\n\t}\n\tconfigFile := flag.String(\"config\", defaultConfigFile, \"configuration file\")\n\tflag.Parse()\n\tif *isVersion {\n\t\tversion()\n\t\treturn\n\t}\n\ttomlData, err := os.ReadFile(expandConfigFile(*configFile))\n\tif err != nil && !*isGenKeys {\n\t\tlog.Fatal(err)\n\t}\n\tvar tomlConf tomlConfig\n\tif _, err = toml.Decode(string(tomlData), &tomlConf); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar conf Conf\n\tif tomlConf.Listen == \"\" {\n\t\tconf.Listen = DefaultListen\n\t} else {\n\t\tconf.Listen = tomlConf.Listen\n\t}\n\tif tomlConf.Connect == \"\" {\n\t\tconf.Connect = DefaultConnect\n\t} else {\n\t\tconf.Connect = tomlConf.Connect\n\t}\n\tif *isGenKeys {\n\t\tleKey := \"\"\n\t\tif *isDeterministic {\n\t\t\tleKey = getPassword(\"Password> \")\n\t\t}\n\t\tgenKeys(conf, *configFile, leKey)\n\t\treturn\n\t}\n\tpskHex := tomlConf.Psk\n\tpsk, err := hex.DecodeString(pskHex)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tconf.Psk = psk\n\tif encryptSkHex := tomlConf.EncryptSk; encryptSkHex != \"\" {\n\t\tencryptSk, err := hex.DecodeString(encryptSkHex)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tconf.EncryptSk = encryptSk\n\t}\n\tif signPkHex := tomlConf.SignPk; signPkHex != \"\" {\n\t\tsignPk, err := hex.DecodeString(signPkHex)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tconf.SignPk = signPk\n\t}\n\tif encryptSkID := tomlConf.EncryptSkID; encryptSkID > 0 {\n\t\tconf.EncryptSkID = make([]byte, 8)\n\t\tbinary.LittleEndian.PutUint64(conf.EncryptSkID, encryptSkID)\n\t} else if len(conf.EncryptSk) > 0 {\n\t\thf, _ := blake2b.New(&blake2b.Config{\n\t\t\tPerson: []byte(DomainStr),\n\t\t\tSize:   8,\n\t\t})\n\t\thf.Write(conf.EncryptSk)\n\t\tencryptSkID := hf.Sum(nil)\n\t\tencryptSkID[7] &= 0x7f\n\t\tconf.EncryptSkID = encryptSkID\n\t}\n\tconf.TTL = DefaultTTL\n\tif ttl := tomlConf.TTL; ttl > 0 {\n\t\tconf.TTL = time.Duration(ttl) * time.Second\n\t}\n\tif signSkHex := tomlConf.SignSk; signSkHex != \"\" {\n\t\tsignSk, err := hex.DecodeString(signSkHex)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tswitch len(signSk) {\n\t\tcase 32:\n\t\t\tif len(conf.SignPk) != 32 {\n\t\t\t\tlog.Fatal(\"Public signing key required\")\n\t\t\t}\n\t\t\tsignSk = append(signSk, conf.SignPk...)\n\t\tcase 64:\n\t\tdefault:\n\t\t\tlog.Fatal(\"Unsupported length for the secret signing key\")\n\t\t}\n\t\tconf.SignSk = signSk\n\t}\n\tconf.MaxClients = *maxClients\n\tconf.MaxLen = *maxLenMb * 1024 * 1024\n\tconf.Timeout = time.Duration(*timeout) * time.Second\n\tconf.DataTimeout = time.Duration(*dataTimeout) * time.Second\n\tconf.TrustedIPCount = uint64(float64(conf.MaxClients) * 0.1)\n\tif conf.TrustedIPCount < 1 {\n\t\tconf.TrustedIPCount = 1\n\t}\n\tconfCheck(conf, *isServer)\n\tif *isServer {\n\t\tRunServer(conf)\n\t} else {\n\t\tRunClient(conf, *isCopy, *isMove)\n\t}\n}\n"
        },
        {
          "name": "piknik.png",
          "type": "blob",
          "size": 14.54296875,
          "content": null
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 6.439453125,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"crypto/rand\"\n\t\"crypto/subtle\"\n\t\"encoding/binary\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ed25519\"\n)\n\n// ClientConnection - A client connection\ntype ClientConnection struct {\n\tconf          Conf\n\tconn          net.Conn\n\treader        *bufio.Reader\n\twriter        *bufio.Writer\n\tclientVersion byte\n}\n\n// StoredContent - Paste buffer\ntype StoredContent struct {\n\tsync.RWMutex\n\n\tts                                []byte\n\tsignature                         []byte\n\tciphertextWithEncryptSkIDAndNonce []byte\n}\n\nvar (\n\tstoredContent  StoredContent\n\ttrustedClients TrustedClients\n\tclientsCount   = uint64(0)\n)\n\nfunc (cnx *ClientConnection) getOperation(h1 []byte, isMove bool) {\n\tconf, reader, writer := cnx.conf, cnx.reader, cnx.writer\n\trbuf := make([]byte, 32)\n\tif _, err := io.ReadFull(reader, rbuf); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\th2 := rbuf\n\topcode := byte('G')\n\tif isMove {\n\t\topcode = byte('M')\n\t}\n\twh2 := auth2get(conf, cnx.clientVersion, h1, opcode)\n\tif subtle.ConstantTimeCompare(wh2, h2) != 1 {\n\t\treturn\n\t}\n\n\tvar ts, signature, ciphertextWithEncryptSkIDAndNonce []byte\n\tif isMove {\n\t\tstoredContent.Lock()\n\t\tts, signature, ciphertextWithEncryptSkIDAndNonce = storedContent.ts, storedContent.signature, storedContent.ciphertextWithEncryptSkIDAndNonce\n\t\tstoredContent.ts, storedContent.signature,\n\t\t\tstoredContent.ciphertextWithEncryptSkIDAndNonce = nil, nil, nil\n\t\tstoredContent.Unlock()\n\t} else {\n\t\tstoredContent.RLock()\n\t\tts, signature, ciphertextWithEncryptSkIDAndNonce = storedContent.ts, storedContent.signature,\n\t\t\tstoredContent.ciphertextWithEncryptSkIDAndNonce\n\t\tstoredContent.RUnlock()\n\t}\n\n\tcnx.conn.SetDeadline(time.Now().Add(conf.DataTimeout))\n\th3 := auth3get(conf, cnx.clientVersion, h2, ts, signature)\n\twriter.Write(h3)\n\tciphertextWithEncryptSkIDAndNonceLen := uint64(len(ciphertextWithEncryptSkIDAndNonce))\n\tbinary.Write(writer, binary.LittleEndian, ciphertextWithEncryptSkIDAndNonceLen)\n\twriter.Write(ts)\n\twriter.Write(signature)\n\twriter.Write(ciphertextWithEncryptSkIDAndNonce)\n\tif err := writer.Flush(); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n}\n\nfunc (cnx *ClientConnection) storeOperation(h1 []byte) {\n\tconf, reader, writer := cnx.conf, cnx.reader, cnx.writer\n\trbuf := make([]byte, 112)\n\tif _, err := io.ReadFull(reader, rbuf); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\th2 := rbuf[0:32]\n\tciphertextWithEncryptSkIDAndNonceLen := binary.LittleEndian.Uint64(rbuf[32:40])\n\tif ciphertextWithEncryptSkIDAndNonceLen < 8+24 {\n\t\tlog.Printf(\"Short encrypted message (only %v bytes)\\n\", ciphertextWithEncryptSkIDAndNonceLen)\n\t\treturn\n\t}\n\tif conf.MaxLen > 0 && ciphertextWithEncryptSkIDAndNonceLen > conf.MaxLen {\n\t\tlog.Printf(\"%v bytes requested to be stored, but limit set to %v bytes (%v Mb)\\n\",\n\t\t\tciphertextWithEncryptSkIDAndNonceLen, conf.MaxLen, conf.MaxLen/(1024*1024))\n\t\treturn\n\t}\n\tvar ts, signature []byte\n\tts = rbuf[40:48]\n\tsignature = rbuf[48:112]\n\topcode := byte('S')\n\n\twh2 := auth2store(conf, cnx.clientVersion, h1, opcode, ts, signature)\n\tif subtle.ConstantTimeCompare(wh2, h2) != 1 {\n\t\treturn\n\t}\n\tciphertextWithEncryptSkIDAndNonce := make([]byte, ciphertextWithEncryptSkIDAndNonceLen)\n\n\tcnx.conn.SetDeadline(time.Now().Add(conf.DataTimeout))\n\tif _, err := io.ReadFull(reader, ciphertextWithEncryptSkIDAndNonce); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\tif !ed25519.Verify(conf.SignPk, ciphertextWithEncryptSkIDAndNonce, signature) {\n\t\treturn\n\t}\n\th3 := auth3store(conf, h2)\n\n\tstoredContent.Lock()\n\tstoredContent.ts = ts\n\tstoredContent.signature = signature\n\tstoredContent.ciphertextWithEncryptSkIDAndNonce = ciphertextWithEncryptSkIDAndNonce\n\tstoredContent.Unlock()\n\n\twriter.Write(h3)\n\tif err := writer.Flush(); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n}\n\nfunc handleClientConnection(conf Conf, conn net.Conn) {\n\tdefer conn.Close()\n\treader, writer := bufio.NewReader(conn), bufio.NewWriter(conn)\n\tcnx := ClientConnection{\n\t\tconf:   conf,\n\t\tconn:   conn,\n\t\treader: reader,\n\t\twriter: writer,\n\t}\n\trbuf := make([]byte, 65)\n\tif _, err := io.ReadFull(reader, rbuf); err != nil {\n\t\treturn\n\t}\n\tcnx.clientVersion = rbuf[0]\n\tif cnx.clientVersion != 6 {\n\t\tlog.Print(\"Unsupported client version - Please run the same version on the server and on the client\")\n\t\treturn\n\t}\n\tr := rbuf[1:33]\n\th0 := rbuf[33:65]\n\twh0 := auth0(conf, cnx.clientVersion, r)\n\tif subtle.ConstantTimeCompare(wh0, h0) != 1 {\n\t\treturn\n\t}\n\tr2 := make([]byte, 32)\n\tif _, err := rand.Read(r2); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\th1 := auth1(conf, cnx.clientVersion, h0, r2)\n\twriter.Write([]byte{cnx.clientVersion})\n\twriter.Write(r2)\n\twriter.Write(h1)\n\tif err := writer.Flush(); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\tremoteIP := cnx.conn.RemoteAddr().(*net.TCPAddr).IP\n\taddToTrustedIPs(conf, remoteIP)\n\topcode, err := reader.ReadByte()\n\tif err != nil {\n\t\treturn\n\t}\n\tswitch opcode {\n\tcase byte('G'):\n\t\tcnx.getOperation(h1, false)\n\tcase byte('M'):\n\t\tcnx.getOperation(h1, true)\n\tcase byte('S'):\n\t\tcnx.storeOperation(h1)\n\t}\n}\n\n// TrustedClients - Clients IPs having recently performed a successful handshake\ntype TrustedClients struct {\n\tsync.RWMutex\n\n\tips []net.IP\n}\n\nfunc addToTrustedIPs(conf Conf, ip net.IP) {\n\ttrustedClients.Lock()\n\tif uint64(len(trustedClients.ips)) >= conf.TrustedIPCount {\n\t\ttrustedClients.ips = append(trustedClients.ips[1:], ip)\n\t} else {\n\t\ttrustedClients.ips = append(trustedClients.ips, ip)\n\t}\n\ttrustedClients.Unlock()\n}\n\nfunc isIPTrusted(conf Conf, ip net.IP) bool {\n\ttrustedClients.RLock()\n\tdefer trustedClients.RUnlock()\n\tif len(trustedClients.ips) == 0 {\n\t\treturn true\n\t}\n\tfor _, foundIP := range trustedClients.ips {\n\t\tif foundIP.Equal(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc acceptClient(conf Conf, conn net.Conn) {\n\thandleClientConnection(conf, conn)\n\tatomic.AddUint64(&clientsCount, ^uint64(0))\n}\n\nfunc maybeAcceptClient(conf Conf, conn net.Conn) {\n\tconn.SetDeadline(time.Now().Add(conf.Timeout))\n\tremoteIP := conn.RemoteAddr().(*net.TCPAddr).IP\n\tfor {\n\t\tcount := atomic.LoadUint64(&clientsCount)\n\t\tif count >= conf.MaxClients-conf.TrustedIPCount && !isIPTrusted(conf, remoteIP) {\n\t\t\tconn.Close()\n\t\t\treturn\n\t\t}\n\t\tif count >= conf.MaxClients {\n\t\t\tconn.Close()\n\t\t\treturn\n\t\t} else if atomic.CompareAndSwapUint64(&clientsCount, count, count+1) {\n\t\t\tbreak\n\t\t}\n\t}\n\tgo acceptClient(conf, conn)\n}\n\n// RunServer - run a server\nfunc RunServer(conf Conf) {\n\tgo handleSignals()\n\tlisten, err := net.Listen(\"tcp\", conf.Listen)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer listen.Close()\n\tfor {\n\t\tconn, err := listen.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tmaybeAcceptClient(conf, conn)\n\t}\n}\n"
        },
        {
          "name": "signals_bsd.go",
          "type": "blob",
          "size": 0.9677734375,
          "content": "//go:build darwin || dragonfly || freebsd || netbsd || openbsd\n// +build darwin dragonfly freebsd netbsd openbsd\n\npackage main\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc handleSignals() {\n\tsignals := make(chan os.Signal, 1)\n\tsignal.Notify(signals, syscall.SIGINFO)\n\tfor {\n\t\tsignal, ok := <-signals\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tswitch signal {\n\t\tcase syscall.SIGINFO:\n\t\t\tstoredContent.RLock()\n\t\t\tprocName := \"piknik\"\n\t\t\tif len(os.Args) >= 1 {\n\t\t\t\tprocName = os.Args[0]\n\t\t\t}\n\t\t\tif storedContent.ts == nil {\n\t\t\t\tfmt.Printf(\"%v: the clipboard is empty\\n\", procName)\n\t\t\t} else {\n\t\t\t\telapsed := time.Since(time.Unix(int64(binary.LittleEndian.Uint64(storedContent.ts)), 0))\n\t\t\t\tif elapsed <= 1 {\n\t\t\t\t\tfmt.Printf(\"%v: the clipboard is not empty (last filled a few moments ago)\\n\",\n\t\t\t\t\t\tprocName)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"%v: the clipboard is not empty (last filled %v minutes ago)\\n\",\n\t\t\t\t\t\tprocName, elapsed)\n\t\t\t\t}\n\t\t\t}\n\t\t\tstoredContent.RUnlock()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "signals_notbsd.go",
          "type": "blob",
          "size": 0.158203125,
          "content": "//go:build !darwin && !dragonfly && !freebsd && !netbsd && !openbsd\n// +build !darwin,!dragonfly,!freebsd,!netbsd,!openbsd\n\npackage main\n\nfunc handleSignals() {}\n"
        },
        {
          "name": "terminal_notty.go",
          "type": "blob",
          "size": 0.3349609375,
          "content": "//go:build (!darwin && !dragonfly && !freebsd && !linux && !netbsd && !openbsd && !windows) || (linux && appengine)\n// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!windows linux,appengine\n\npackage main\n\n// IsTerminal - returns true if the file descriptor is attached to a terminal\nfunc IsTerminal(fd int) bool {\n\treturn false\n}\n"
        },
        {
          "name": "terminal_tty.go",
          "type": "blob",
          "size": 0.34765625,
          "content": "//go:build darwin || dragonfly || freebsd || (linux && !appengine) || netbsd || openbsd || windows\n// +build darwin dragonfly freebsd linux,!appengine netbsd openbsd windows\n\npackage main\n\nimport \"golang.org/x/term\"\n\n// IsTerminal - returns true if the file descriptor is attached to a terminal\nfunc IsTerminal(fd int) bool {\n\treturn term.IsTerminal(fd)\n}\n"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 1.078125,
          "content": "#! /bin/sh\n\nset -e\n\nTMPDIR=${TMPDIR:-/tmp}\nPIKNIK_S=\"./piknik -config ${TMPDIR}/piknik-test-server.toml -server\"\nPIKNIK_C=\"./piknik -config ${TMPDIR}/piknik-test-client.toml\"\n\ncat > \"${TMPDIR}/piknik-test-server.toml\" <<EOT\nListen    = \"127.0.0.1:8076\"\nPsk       = \"627ea393638048bc0d5a7554ab58e41e5601e2f4975a214dfc53b500be462a9a\"\nSignPk    = \"c2e46983e667a37d7d8d69679f40f3a05eb8086337693d91dcaf8546d39ddb5e\"\nEOT\n\ncat > \"${TMPDIR}/piknik-test-client.toml\" <<EOT\nConnect   = \"127.0.0.1:8076\"\nPsk       = \"627ea393638048bc0d5a7554ab58e41e5601e2f4975a214dfc53b500be462a9a\"\nSignPk    = \"c2e46983e667a37d7d8d69679f40f3a05eb8086337693d91dcaf8546d39ddb5e\"\nSignSk    = \"7599dad4726247d301c00ce0dc0dbfb9144fa958b4e9db30209a8f9d840ac9ca\"\nEncryptSk = \"f313e1fd4ad5fee8841d40ca3d54e14041eb05bf7f4888ad8c800ceb61942db6\"\nEOT\n\ngo build\n$PIKNIK_S &\npid=$!\nsleep 2\ndd if=/dev/urandom of=/tmp/pi bs=1000 count=1\n$PIKNIK_C -copy < /tmp/pi\n$PIKNIK_C -paste > /tmp/pi2\ncmp /tmp/pi /tmp/pi2\n$PIKNIK_C | $PIKNIK_C -copy\n$PIKNIK_C -move > /tmp/pi2\ncmp /tmp/pi /tmp/pi2\n$PIKNIK_C && exit 1\nkill $pid\n\necho\necho 'Success!'\necho\n"
        },
        {
          "name": "zsh.aliases",
          "type": "blob",
          "size": 0.681640625,
          "content": "# pko <content> : copy <content> to the clipboard\npko() {\n    echo \"$*\" | piknik -copy\n}\n\n# pkf <file> : copy the content of <file> to the clipboard\npkf() {\n    piknik -copy < $1\n}\n\n# pkc : read the content to copy to the clipboard from STDIN\nalias pkc='piknik -copy'\n\n# pkp : paste the clipboard content\nalias pkp='piknik -paste'\n\n# pkm : move the clipboard content\nalias pkm='piknik -move'\n\n# pkz : delete the clipboard content\nalias pkz='piknik -copy < /dev/null'\n\n# pkfr [<dir>] : send a whole directory to the clipboard, as a tar archive\npkfr() {\n    tar czpvf - ${1:-.} | piknik -copy\n}\n\n# pkpr : extract clipboard content sent using the pkfr command\nalias pkpr='piknik -paste | tar xzpvf -'\n"
        }
      ]
    }
  ]
}