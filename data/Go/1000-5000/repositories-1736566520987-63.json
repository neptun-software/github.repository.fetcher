{
  "metadata": {
    "timestamp": 1736566520987,
    "page": 63,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nsf/termbox-go",
      "stars": 4689,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.0986328125,
          "content": "# Please keep this file sorted.\n\nGeorg Reinke <guelfey@googlemail.com>\nnsf <no.smile.face@gmail.com>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "Copyright (C) 2012 termbox-go authors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.4931640625,
          "content": "[![Go Reference](https://pkg.go.dev/badge/github.com/nsf/termbox-go.svg)](https://pkg.go.dev/github.com/nsf/termbox-go)\n![Build](https://github.com/nsf/termbox-go/actions/workflows/test-ubuntu.yml/badge.svg)\n\n## IMPORTANT\n\nThis library is somewhat not maintained anymore. But I'm glad that it did what I wanted the most. It moved people away from \"ncurses\" mindset and these days we see both re-implementations of termbox API in various languages and even possibly better libs with similar API design. If you're looking for a Go lib that provides terminal-based user interface facilities, I've heard that [gdamore/tcell](https://github.com/gdamore/tcell) is good (never used it myself). Also for more complicated interfaces and/or computer games I recommend you to consider using HTML-based UI. Having said that, termbox still somewhat works. In fact I'm writing this line of text right now in godit (which is a text editor written using termbox-go). So, be aware. Good luck and have a nice day.\n\n## Termbox\nTermbox is a library that provides a minimalistic API which allows the programmer to write text-based user interfaces. The library is crossplatform and has both terminal-based implementations on \\*nix operating systems and a winapi console based implementation for windows operating systems. The basic idea is an abstraction of the greatest common subset of features available on all major terminals and other terminal-like APIs in a minimalistic fashion. Small API means it is easy to implement, test, maintain and learn it, that's what makes the termbox a distinct library in its area.\n\n### Installation\nInstall and update this go package with `go get -u github.com/nsf/termbox-go`\n\n### Examples\nFor examples of what can be done take a look at various examples in the `_demos` directory. You can try them with go run: `go run _demos/keyboard.go`\n\nThere are also some interesting projects using termbox-go:\n - [godit](https://github.com/nsf/godit) is an emacsish lightweight text editor written using termbox.\n - [gotetris](https://github.com/jjinux/gotetris) is an implementation of Tetris.\n - [sokoban-go](https://github.com/rn2dy/sokoban-go) is an implementation of sokoban game.\n - [hecate](https://github.com/evanmiller/hecate) is a hex editor designed by Satan.\n - [httopd](https://github.com/verdverm/httopd) is top for httpd logs.\n - [mop](https://github.com/mop-tracker/mop) is stock market tracker for hackers.\n - [termui](https://github.com/gizak/termui) is a terminal dashboard.\n - [termloop](https://github.com/JoelOtter/termloop) is a terminal game engine.\n - [xterm-color-chart](https://github.com/kutuluk/xterm-color-chart) is a XTerm 256 color chart.\n - [gocui](https://github.com/jroimartin/gocui) is a minimalist Go library aimed at creating console user interfaces.\n - [dry](https://github.com/moncho/dry) is an interactive cli to manage Docker containers.\n - [pxl](https://github.com/ichinaski/pxl) displays images in the terminal.\n - [snake-game](https://github.com/DyegoCosta/snake-game) is an implementation of the Snake game.\n - [gone](https://github.com/guillaumebreton/gone) is a CLI pomodoroÂ® timer.\n - [Spoof.go](https://github.com/sabey/spoofgo) controllable movement spoofing from the cli.\n - [rat](https://github.com/ericfreese/rat) lets you compose shell commands to build terminal applications.\n - [httplab](https://github.com/gchaincl/httplab) An interactive web server.\n - [wot](https://github.com/kyu-suke/wot) Wait time during command is completed.\n - [2048-go](https://github.com/1984weed/2048-go) is 2048 in Go.\n - [jv](https://github.com/maxzender/jv) helps you view JSON on the command-line.\n - [pinger](https://github.com/hirose31/pinger) helps you to monitor numerous hosts using ICMP ECHO_REQUEST.\n - [vixl44](https://github.com/sebashwa/vixl44) lets you create pixel art inside your terminal using vim movements.\n - [zterm](https://github.com/varunrau/zterm) is a typing game inspired by http://zty.pe/.\n - [gotypist](https://github.com/pb-/gotypist) is a fun touch-typing tutor following Steve Yegge's method.\n - [cointop](https://github.com/miguelmota/cointop) is an interactive terminal based UI application for tracking cryptocurrencies.\n - [pexpo](https://github.com/nnao45/pexpo) is a terminal sending ping tool written in Go.\n - [jid](https://github.com/simeji/jid) is an interactive JSON drill down tool using filtering queries like jq.\n - [nonograminGo](https://github.com/N0RM4L15T/nonograminGo) is a nonogram (aka. picross) in Go.\n - [tower-of-go](https://github.com/kjirou/tower-of-go) is a tiny maze game that runs on the terminal.\n"
        },
        {
          "name": "_demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "api.go",
          "type": "blob",
          "size": 14.259765625,
          "content": "// +build !windows\n\npackage termbox\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"runtime\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/mattn/go-runewidth\"\n)\n\n// public API\n\n// Initializes termbox library. This function should be called before any other functions.\n// After successful initialization, the library must be finalized using 'Close' function.\n//\n// Example usage:\n//      err := termbox.Init()\n//      if err != nil {\n//              panic(err)\n//      }\n//      defer termbox.Close()\nfunc Init() error {\n\tif IsInit {\n\t\treturn nil\n\t}\n\n\tvar err error\n\n\tif runtime.GOOS == \"openbsd\" || runtime.GOOS == \"freebsd\" {\n\t\tout, err = os.OpenFile(\"/dev/tty\", os.O_RDWR, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tin = int(out.Fd())\n\t} else {\n\t\tout, err = os.OpenFile(\"/dev/tty\", os.O_WRONLY, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tin, err = syscall.Open(\"/dev/tty\", syscall.O_RDONLY, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Fd clears the O_NONBLOCK flag. On systems where in and out are the\n\t// same file descriptor (see above), that would be a problem, because\n\t// the in file descriptor needs to be nonblocking. Save the Fd return\n\t// value here so that we won't need to call Fd later after the in file\n\t// descriptor has been made nonblocking (see below).\n\toutfd = out.Fd()\n\n\terr = setup_term()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"termbox: error while reading terminfo data: %v\", err)\n\t}\n\n\tsignal.Notify(sigwinch, syscall.SIGWINCH)\n\tsignal.Notify(sigio, syscall.SIGIO)\n\n\t_, err = fcntl(in, syscall.F_SETFL, syscall.O_ASYNC|syscall.O_NONBLOCK)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fcntl(in, syscall.F_SETOWN, syscall.Getpid())\n\tif runtime.GOOS != \"darwin\" && err != nil {\n\t\treturn err\n\t}\n\terr = tcgetattr(outfd, &orig_tios)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttios := orig_tios\n\ttios.Iflag &^= syscall_IGNBRK | syscall_BRKINT | syscall_PARMRK |\n\t\tsyscall_ISTRIP | syscall_INLCR | syscall_IGNCR |\n\t\tsyscall_ICRNL | syscall_IXON\n\ttios.Lflag &^= syscall_ECHO | syscall_ECHONL | syscall_ICANON |\n\t\tsyscall_ISIG | syscall_IEXTEN\n\ttios.Cflag &^= syscall_CSIZE | syscall_PARENB\n\ttios.Cflag |= syscall_CS8\n\ttios.Cc[syscall_VMIN] = 1\n\ttios.Cc[syscall_VTIME] = 0\n\n\terr = tcsetattr(outfd, &tios)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tout.WriteString(funcs[t_enter_ca])\n\tout.WriteString(funcs[t_enter_keypad])\n\tout.WriteString(funcs[t_hide_cursor])\n\tout.WriteString(funcs[t_clear_screen])\n\n\ttermw, termh = get_term_size(outfd)\n\tback_buffer.init(termw, termh)\n\tfront_buffer.init(termw, termh)\n\tback_buffer.clear()\n\tfront_buffer.clear()\n\n\tgo func() {\n\t\tbuf := make([]byte, 128)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-sigio:\n\t\t\t\tfor {\n\t\t\t\t\tn, err := syscall.Read(in, buf)\n\t\t\t\t\tif err == syscall.EAGAIN || err == syscall.EWOULDBLOCK {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tselect {\n\t\t\t\t\tcase input_comm <- input_event{buf[:n], err}:\n\t\t\t\t\t\tie := <-input_comm\n\t\t\t\t\t\tbuf = ie.data[:128]\n\t\t\t\t\tcase <-quit:\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase <-quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tIsInit = true\n\treturn nil\n}\n\n// Interrupt an in-progress call to PollEvent by causing it to return\n// EventInterrupt.  Note that this function will block until the PollEvent\n// function has successfully been interrupted.\nfunc Interrupt() {\n\tinterrupt_comm <- struct{}{}\n}\n\n// Finalizes termbox library, should be called after successful initialization\n// when termbox's functionality isn't required anymore.\nfunc Close() {\n\tif !IsInit {\n\t\treturn\n\t}\n\n\tquit <- 1\n\tout.WriteString(funcs[t_show_cursor])\n\tout.WriteString(funcs[t_sgr0])\n\tout.WriteString(funcs[t_clear_screen])\n\tout.WriteString(funcs[t_exit_ca])\n\tout.WriteString(funcs[t_exit_keypad])\n\tout.WriteString(funcs[t_exit_mouse])\n\ttcsetattr(outfd, &orig_tios)\n\n\tout.Close()\n\tsyscall.Close(in)\n\n\t// reset the state, so that on next Init() it will work again\n\ttermw = 0\n\ttermh = 0\n\tinput_mode = InputEsc\n\tout = nil\n\tin = 0\n\tlastfg = attr_invalid\n\tlastbg = attr_invalid\n\tlastx = coord_invalid\n\tlasty = coord_invalid\n\tcursor_x = cursor_hidden\n\tcursor_y = cursor_hidden\n\tforeground = ColorDefault\n\tbackground = ColorDefault\n\tIsInit = false\n}\n\n// Synchronizes the internal back buffer with the terminal.\nfunc Flush() error {\n\t// invalidate cursor position\n\tlastx = coord_invalid\n\tlasty = coord_invalid\n\n\tupdate_size_maybe()\n\n\tfor y := 0; y < front_buffer.height; y++ {\n\t\tline_offset := y * front_buffer.width\n\t\tfor x := 0; x < front_buffer.width; {\n\t\t\tcell_offset := line_offset + x\n\t\t\tback := &back_buffer.cells[cell_offset]\n\t\t\tfront := &front_buffer.cells[cell_offset]\n\t\t\tif back.Ch < ' ' {\n\t\t\t\tback.Ch = ' '\n\t\t\t}\n\t\t\tw := runewidth.RuneWidth(back.Ch)\n\t\t\tif w == 0 || w == 2 && runewidth.IsAmbiguousWidth(back.Ch) {\n\t\t\t\tw = 1\n\t\t\t}\n\t\t\tif *back == *front {\n\t\t\t\tx += w\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t*front = *back\n\t\t\tsend_attr(back.Fg, back.Bg)\n\n\t\t\tif w == 2 && x == front_buffer.width-1 {\n\t\t\t\t// there's not enough space for 2-cells rune,\n\t\t\t\t// let's just put a space in there\n\t\t\t\tsend_char(x, y, ' ')\n\t\t\t} else {\n\t\t\t\tsend_char(x, y, back.Ch)\n\t\t\t\tif w == 2 {\n\t\t\t\t\tnext := cell_offset + 1\n\t\t\t\t\tfront_buffer.cells[next] = Cell{\n\t\t\t\t\t\tCh: 0,\n\t\t\t\t\t\tFg: back.Fg,\n\t\t\t\t\t\tBg: back.Bg,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += w\n\t\t}\n\t}\n\tif !is_cursor_hidden(cursor_x, cursor_y) {\n\t\twrite_cursor(cursor_x, cursor_y)\n\t}\n\treturn flush()\n}\n\n// Sets the position of the cursor. See also HideCursor().\nfunc SetCursor(x, y int) {\n\tif is_cursor_hidden(cursor_x, cursor_y) && !is_cursor_hidden(x, y) {\n\t\toutbuf.WriteString(funcs[t_show_cursor])\n\t}\n\n\tif !is_cursor_hidden(cursor_x, cursor_y) && is_cursor_hidden(x, y) {\n\t\toutbuf.WriteString(funcs[t_hide_cursor])\n\t}\n\n\tcursor_x, cursor_y = x, y\n\tif !is_cursor_hidden(cursor_x, cursor_y) {\n\t\twrite_cursor(cursor_x, cursor_y)\n\t}\n}\n\n// The shortcut for SetCursor(-1, -1).\nfunc HideCursor() {\n\tSetCursor(cursor_hidden, cursor_hidden)\n}\n\n// Changes cell's parameters in the internal back buffer at the specified\n// position.\nfunc SetCell(x, y int, ch rune, fg, bg Attribute) {\n\tif x < 0 || x >= back_buffer.width {\n\t\treturn\n\t}\n\tif y < 0 || y >= back_buffer.height {\n\t\treturn\n\t}\n\n\tback_buffer.cells[y*back_buffer.width+x] = Cell{ch, fg, bg}\n}\n\n// Returns the specified cell from the internal back buffer.\nfunc GetCell(x, y int) Cell {\n\treturn back_buffer.cells[y*back_buffer.width+x]\n}\n\n// Changes cell's character (rune) in the internal back buffer at the\n// specified position.\nfunc SetChar(x, y int, ch rune) {\n\tif x < 0 || x >= back_buffer.width {\n\t\treturn\n\t}\n\tif y < 0 || y >= back_buffer.height {\n\t\treturn\n\t}\n\n\tback_buffer.cells[y*back_buffer.width+x].Ch = ch\n}\n\n// Changes cell's foreground attributes in the internal back buffer at\n// the specified position.\nfunc SetFg(x, y int, fg Attribute) {\n\tif x < 0 || x >= back_buffer.width {\n\t\treturn\n\t}\n\tif y < 0 || y >= back_buffer.height {\n\t\treturn\n\t}\n\n\tback_buffer.cells[y*back_buffer.width+x].Fg = fg\n}\n\n// Changes cell's background attributes in the internal back buffer at\n// the specified position.\nfunc SetBg(x, y int, bg Attribute) {\n\tif x < 0 || x >= back_buffer.width {\n\t\treturn\n\t}\n\tif y < 0 || y >= back_buffer.height {\n\t\treturn\n\t}\n\n\tback_buffer.cells[y*back_buffer.width+x].Bg = bg\n}\n\n// Returns a slice into the termbox's back buffer. You can get its dimensions\n// using 'Size' function. The slice remains valid as long as no 'Clear' or\n// 'Flush' function calls were made after call to this function.\nfunc CellBuffer() []Cell {\n\treturn back_buffer.cells\n}\n\n// After getting a raw event from PollRawEvent function call, you can parse it\n// again into an ordinary one using termbox logic. That is parse an event as\n// termbox would do it. Returned event in addition to usual Event struct fields\n// sets N field to the amount of bytes used within 'data' slice. If the length\n// of 'data' slice is zero or event cannot be parsed for some other reason, the\n// function will return a special event type: EventNone.\n//\n// IMPORTANT: EventNone may contain a non-zero N, which means you should skip\n// these bytes, because termbox cannot recognize them.\n//\n// NOTE: This API is experimental and may change in future.\nfunc ParseEvent(data []byte) Event {\n\tevent := Event{Type: EventKey}\n\tstatus := extract_event(data, &event, false)\n\tif status != event_extracted {\n\t\treturn Event{Type: EventNone, N: event.N}\n\t}\n\treturn event\n}\n\n// Wait for an event and return it. This is a blocking function call. Instead\n// of EventKey and EventMouse it returns EventRaw events. Raw event is written\n// into `data` slice and Event's N field is set to the amount of bytes written.\n// The minimum required length of the 'data' slice is 1. This requirement may\n// vary on different platforms.\n//\n// NOTE: This API is experimental and may change in future.\nfunc PollRawEvent(data []byte) Event {\n\tif len(data) == 0 {\n\t\tpanic(\"len(data) >= 1 is a requirement\")\n\t}\n\n\tvar event Event\n\tif extract_raw_event(data, &event) {\n\t\treturn event\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase ev := <-input_comm:\n\t\t\tif ev.err != nil {\n\t\t\t\treturn Event{Type: EventError, Err: ev.err}\n\t\t\t}\n\n\t\t\tinbuf = append(inbuf, ev.data...)\n\t\t\tinput_comm <- ev\n\t\t\tif extract_raw_event(data, &event) {\n\t\t\t\treturn event\n\t\t\t}\n\t\tcase <-interrupt_comm:\n\t\t\tevent.Type = EventInterrupt\n\t\t\treturn event\n\n\t\tcase <-sigwinch:\n\t\t\tevent.Type = EventResize\n\t\t\tevent.Width, event.Height = get_term_size(outfd)\n\t\t\treturn event\n\t\t}\n\t}\n}\n\n// Wait for an event and return it. This is a blocking function call.\nfunc PollEvent() Event {\n\t// Constant governing macOS specific behavior. See https://github.com/nsf/termbox-go/issues/132\n\t// This is an arbitrary delay which hopefully will be enough time for any lagging\n\t// partial escape sequences to come through.\n\tconst esc_wait_delay = 100 * time.Millisecond\n\n\tvar event Event\n\tvar esc_wait_timer *time.Timer\n\tvar esc_timeout <-chan time.Time\n\n\t// try to extract event from input buffer, return on success\n\tevent.Type = EventKey\n\tstatus := extract_event(inbuf, &event, true)\n\tif event.N != 0 {\n\t\tcopy(inbuf, inbuf[event.N:])\n\t\tinbuf = inbuf[:len(inbuf)-event.N]\n\t}\n\tif status == event_extracted {\n\t\treturn event\n\t} else if status == esc_wait {\n\t\tesc_wait_timer = time.NewTimer(esc_wait_delay)\n\t\tesc_timeout = esc_wait_timer.C\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase ev := <-input_comm:\n\t\t\tif esc_wait_timer != nil {\n\t\t\t\tif !esc_wait_timer.Stop() {\n\t\t\t\t\t<-esc_wait_timer.C\n\t\t\t\t}\n\t\t\t\tesc_wait_timer = nil\n\t\t\t}\n\n\t\t\tif ev.err != nil {\n\t\t\t\treturn Event{Type: EventError, Err: ev.err}\n\t\t\t}\n\n\t\t\tinbuf = append(inbuf, ev.data...)\n\t\t\tinput_comm <- ev\n\t\t\tstatus := extract_event(inbuf, &event, true)\n\t\t\tif event.N != 0 {\n\t\t\t\tcopy(inbuf, inbuf[event.N:])\n\t\t\t\tinbuf = inbuf[:len(inbuf)-event.N]\n\t\t\t}\n\t\t\tif status == event_extracted {\n\t\t\t\treturn event\n\t\t\t} else if status == esc_wait {\n\t\t\t\tesc_wait_timer = time.NewTimer(esc_wait_delay)\n\t\t\t\tesc_timeout = esc_wait_timer.C\n\t\t\t}\n\t\tcase <-esc_timeout:\n\t\t\tesc_wait_timer = nil\n\n\t\t\tstatus := extract_event(inbuf, &event, false)\n\t\t\tif event.N != 0 {\n\t\t\t\tcopy(inbuf, inbuf[event.N:])\n\t\t\t\tinbuf = inbuf[:len(inbuf)-event.N]\n\t\t\t}\n\t\t\tif status == event_extracted {\n\t\t\t\treturn event\n\t\t\t}\n\t\tcase <-interrupt_comm:\n\t\t\tevent.Type = EventInterrupt\n\t\t\treturn event\n\n\t\tcase <-sigwinch:\n\t\t\tevent.Type = EventResize\n\t\t\tevent.Width, event.Height = get_term_size(outfd)\n\t\t\treturn event\n\t\t}\n\t}\n}\n\n// Returns the size of the internal back buffer (which is mostly the same as\n// terminal's window size in characters). But it doesn't always match the size\n// of the terminal window, after the terminal size has changed, the internal\n// back buffer will get in sync only after Clear or Flush function calls.\nfunc Size() (width int, height int) {\n\treturn termw, termh\n}\n\n// Clears the internal back buffer.\nfunc Clear(fg, bg Attribute) error {\n\tforeground, background = fg, bg\n\terr := update_size_maybe()\n\tback_buffer.clear()\n\treturn err\n}\n\n// Sets termbox input mode. Termbox has two input modes:\n//\n// 1. Esc input mode. When ESC sequence is in the buffer and it doesn't match\n// any known sequence. ESC means KeyEsc. This is the default input mode.\n//\n// 2. Alt input mode. When ESC sequence is in the buffer and it doesn't match\n// any known sequence. ESC enables ModAlt modifier for the next keyboard event.\n//\n// Both input modes can be OR'ed with Mouse mode. Setting Mouse mode bit up will\n// enable mouse button press/release and drag events.\n//\n// If 'mode' is InputCurrent, returns the current input mode. See also Input*\n// constants.\nfunc SetInputMode(mode InputMode) InputMode {\n\tif mode == InputCurrent {\n\t\treturn input_mode\n\t}\n\tif mode&(InputEsc|InputAlt) == 0 {\n\t\tmode |= InputEsc\n\t}\n\tif mode&(InputEsc|InputAlt) == InputEsc|InputAlt {\n\t\tmode &^= InputAlt\n\t}\n\tif mode&InputMouse != 0 {\n\t\tout.WriteString(funcs[t_enter_mouse])\n\t} else {\n\t\tout.WriteString(funcs[t_exit_mouse])\n\t}\n\n\tinput_mode = mode\n\treturn input_mode\n}\n\n// Sets the termbox output mode. Termbox has four output options:\n//\n// 1. OutputNormal => [1..8]\n//    This mode provides 8 different colors:\n//        black, red, green, yellow, blue, magenta, cyan, white\n//    Shortcut: ColorBlack, ColorRed, ...\n//    Attributes: AttrBold, AttrUnderline, AttrReverse\n//\n//    Example usage:\n//        SetCell(x, y, '@', ColorBlack | AttrBold, ColorRed);\n//\n// 2. Output256 => [1..256]\n//    In this mode you can leverage the 256 terminal mode:\n//    0x01 - 0x08: the 8 colors as in OutputNormal\n//    0x09 - 0x10: Color* | AttrBold\n//    0x11 - 0xe8: 216 different colors\n//    0xe9 - 0x1ff: 24 different shades of grey\n//\n//    Example usage:\n//        SetCell(x, y, '@', 184, 240);\n//        SetCell(x, y, '@', 0xb8, 0xf0);\n//\n// 3. Output216 => [1..216]\n//    This mode supports the 3rd range of the 256 mode only.\n//    But you don't need to provide an offset.\n//\n// 4. OutputGrayscale => [1..26]\n//    This mode supports the 4th range of the 256 mode\n//    and black and white colors from 3th range of the 256 mode\n//    But you don't need to provide an offset.\n//\n// In all modes, 0x00 represents the default color.\n//\n// `go run _demos/output.go` to see its impact on your terminal.\n//\n// If 'mode' is OutputCurrent, it returns the current output mode.\n//\n// Note that this may return a different OutputMode than the one requested,\n// as the requested mode may not be available on the target platform.\nfunc SetOutputMode(mode OutputMode) OutputMode {\n\tif mode == OutputCurrent {\n\t\treturn output_mode\n\t}\n\n\toutput_mode = mode\n\treturn output_mode\n}\n\n// Sync comes handy when something causes desync between termbox's understanding\n// of a terminal buffer and the reality. Such as a third party process. Sync\n// forces a complete resync between the termbox and a terminal, it may not be\n// visually pretty though.\nfunc Sync() error {\n\tfront_buffer.clear()\n\terr := send_clear()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn Flush()\n}\n"
        },
        {
          "name": "api_common.go",
          "type": "blob",
          "size": 5.5673828125,
          "content": "// termbox is a library for creating cross-platform text-based interfaces\npackage termbox\n\n// public API, common OS agnostic part\n\ntype (\n\tInputMode  int\n\tOutputMode int\n\tEventType  uint8\n\tModifier   uint8\n\tKey        uint16\n\tAttribute  uint64\n)\n\n// This type represents a termbox event. The 'Mod', 'Key' and 'Ch' fields are\n// valid if 'Type' is EventKey. The 'Width' and 'Height' fields are valid if\n// 'Type' is EventResize. The 'Err' field is valid if 'Type' is EventError.\ntype Event struct {\n\tType   EventType // one of Event* constants\n\tMod    Modifier  // one of Mod* constants or 0\n\tKey    Key       // one of Key* constants, invalid if 'Ch' is not 0\n\tCh     rune      // a unicode character\n\tWidth  int       // width of the screen\n\tHeight int       // height of the screen\n\tErr    error     // error in case if input failed\n\tMouseX int       // x coord of mouse\n\tMouseY int       // y coord of mouse\n\tN      int       // number of bytes written when getting a raw event\n}\n\n// A cell, single conceptual entity on the screen. The screen is basically a 2d\n// array of cells. 'Ch' is a unicode character, 'Fg' and 'Bg' are foreground\n// and background attributes respectively.\ntype Cell struct {\n\tCh rune\n\tFg Attribute\n\tBg Attribute\n}\n\n// To know if termbox has been initialized or not\nvar (\n\tIsInit bool = false\n)\n\n// Key constants, see Event.Key field.\nconst (\n\tKeyF1 Key = 0xFFFF - iota\n\tKeyF2\n\tKeyF3\n\tKeyF4\n\tKeyF5\n\tKeyF6\n\tKeyF7\n\tKeyF8\n\tKeyF9\n\tKeyF10\n\tKeyF11\n\tKeyF12\n\tKeyInsert\n\tKeyDelete\n\tKeyHome\n\tKeyEnd\n\tKeyPgup\n\tKeyPgdn\n\tKeyArrowUp\n\tKeyArrowDown\n\tKeyArrowLeft\n\tKeyArrowRight\n\tkey_min // see terminfo\n\tMouseLeft\n\tMouseMiddle\n\tMouseRight\n\tMouseRelease\n\tMouseWheelUp\n\tMouseWheelDown\n)\n\nconst (\n\tKeyCtrlTilde      Key = 0x00\n\tKeyCtrl2          Key = 0x00\n\tKeyCtrlSpace      Key = 0x00\n\tKeyCtrlA          Key = 0x01\n\tKeyCtrlB          Key = 0x02\n\tKeyCtrlC          Key = 0x03\n\tKeyCtrlD          Key = 0x04\n\tKeyCtrlE          Key = 0x05\n\tKeyCtrlF          Key = 0x06\n\tKeyCtrlG          Key = 0x07\n\tKeyBackspace      Key = 0x08\n\tKeyCtrlH          Key = 0x08\n\tKeyTab            Key = 0x09\n\tKeyCtrlI          Key = 0x09\n\tKeyCtrlJ          Key = 0x0A\n\tKeyCtrlK          Key = 0x0B\n\tKeyCtrlL          Key = 0x0C\n\tKeyEnter          Key = 0x0D\n\tKeyCtrlM          Key = 0x0D\n\tKeyCtrlN          Key = 0x0E\n\tKeyCtrlO          Key = 0x0F\n\tKeyCtrlP          Key = 0x10\n\tKeyCtrlQ          Key = 0x11\n\tKeyCtrlR          Key = 0x12\n\tKeyCtrlS          Key = 0x13\n\tKeyCtrlT          Key = 0x14\n\tKeyCtrlU          Key = 0x15\n\tKeyCtrlV          Key = 0x16\n\tKeyCtrlW          Key = 0x17\n\tKeyCtrlX          Key = 0x18\n\tKeyCtrlY          Key = 0x19\n\tKeyCtrlZ          Key = 0x1A\n\tKeyEsc            Key = 0x1B\n\tKeyCtrlLsqBracket Key = 0x1B\n\tKeyCtrl3          Key = 0x1B\n\tKeyCtrl4          Key = 0x1C\n\tKeyCtrlBackslash  Key = 0x1C\n\tKeyCtrl5          Key = 0x1D\n\tKeyCtrlRsqBracket Key = 0x1D\n\tKeyCtrl6          Key = 0x1E\n\tKeyCtrl7          Key = 0x1F\n\tKeyCtrlSlash      Key = 0x1F\n\tKeyCtrlUnderscore Key = 0x1F\n\tKeySpace          Key = 0x20\n\tKeyBackspace2     Key = 0x7F\n\tKeyCtrl8          Key = 0x7F\n)\n\n// Alt modifier constant, see Event.Mod field and SetInputMode function.\nconst (\n\tModAlt Modifier = 1 << iota\n\tModMotion\n)\n\n// Cell colors, you can combine a color with multiple attributes using bitwise\n// OR ('|').\nconst (\n\tColorDefault Attribute = iota\n\tColorBlack\n\tColorRed\n\tColorGreen\n\tColorYellow\n\tColorBlue\n\tColorMagenta\n\tColorCyan\n\tColorWhite\n\tColorDarkGray\n\tColorLightRed\n\tColorLightGreen\n\tColorLightYellow\n\tColorLightBlue\n\tColorLightMagenta\n\tColorLightCyan\n\tColorLightGray\n)\n\n// Cell attributes, it is possible to use multiple attributes by combining them\n// using bitwise OR ('|'). Although, colors cannot be combined. But you can\n// combine attributes and a single color.\n//\n// It's worth mentioning that some platforms don't support certain attributes.\n// For example windows console doesn't support AttrUnderline. And on some\n// terminals applying AttrBold to background may result in blinking text. Use\n// them with caution and test your code on various terminals.\nconst (\n\tAttrBold Attribute = 1 << (iota + 9)\n\tAttrBlink\n\tAttrHidden\n\tAttrDim\n\tAttrUnderline\n\tAttrCursive\n\tAttrReverse\n\tmax_attr\n)\n\n// Input mode. See SetInputMode function.\nconst (\n\tInputEsc InputMode = 1 << iota\n\tInputAlt\n\tInputMouse\n\tInputCurrent InputMode = 0\n)\n\n// Output mode. See SetOutputMode function.\nconst (\n\tOutputCurrent OutputMode = iota\n\tOutputNormal\n\tOutput256\n\tOutput216\n\tOutputGrayscale\n\tOutputRGB\n)\n\n// Event type. See Event.Type field.\nconst (\n\tEventKey EventType = iota\n\tEventResize\n\tEventMouse\n\tEventError\n\tEventInterrupt\n\tEventRaw\n\tEventNone\n)\n\n// AttributeToRGB converts an Attribute to the underlying rgb triplet.\n// This is only useful if termbox is in Full RGB mode and the specified\n// attribute is also an attribute with r, g, b specified\nfunc AttributeToRGB(attr Attribute) (uint8, uint8, uint8) {\n\tvar color uint64 = uint64(attr) / uint64(max_attr)\n\t// Have to right-shift with the highest attribute bit.\n\t// For this, we divide by max_attr\n\tvar b uint8 = uint8(color % 256)\n\tvar g uint8 = uint8(color >> 8 % 256)\n\tvar r uint8 = uint8(color >> 16 % 256)\n\treturn r, g, b\n}\n\n// RGBToAttribute is used to convert an rgb triplet into a termbox attribute.\n// This attribute can only be applied when termbox is in Full RGB mode,\n// otherwise it'll be ignored and no color will be drawn.\n// R, G, B have to be in the range of 0 and 255.\nfunc RGBToAttribute(r uint8, g uint8, b uint8) Attribute {\n\tvar color uint64 = uint64(b)\n\tcolor += uint64(g) << 8\n\tcolor += uint64(r) << 16\n\tcolor += 1 << 25\n\tcolor = color * uint64(max_attr)\n\t// Left-shift back to the place where rgb is stored.\n\treturn Attribute(color)\n}\n"
        },
        {
          "name": "api_windows.go",
          "type": "blob",
          "size": 7.5146484375,
          "content": "package termbox\n\nimport (\n\t\"syscall\"\n\n\t\"github.com/mattn/go-runewidth\"\n)\n\n// public API\n\n// Initializes termbox library. This function should be called before any other functions.\n// After successful initialization, the library must be finalized using 'Close' function.\n//\n// Example usage:\n//      err := termbox.Init()\n//      if err != nil {\n//              panic(err)\n//      }\n//      defer termbox.Close()\nfunc Init() error {\n\tvar err error\n\n\tinterrupt, err = create_event()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tin, err = syscall.Open(\"CONIN$\", syscall.O_RDWR, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tout, err = syscall.Open(\"CONOUT$\", syscall.O_RDWR, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = get_console_mode(in, &orig_mode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = set_console_mode(in, enable_window_input)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\torig_size, orig_window = get_term_size(out)\n\twin_size := get_win_size(out)\n\n\terr = set_console_screen_buffer_size(out, win_size)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = fix_win_size(out, win_size)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = get_console_cursor_info(out, &orig_cursor_info)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tshow_cursor(false)\n\tterm_size, _ = get_term_size(out)\n\tback_buffer.init(int(term_size.x), int(term_size.y))\n\tfront_buffer.init(int(term_size.x), int(term_size.y))\n\tback_buffer.clear()\n\tfront_buffer.clear()\n\tclear()\n\n\tdiffbuf = make([]diff_msg, 0, 32)\n\n\tgo input_event_producer()\n\tIsInit = true\n\treturn nil\n}\n\n// Finalizes termbox library, should be called after successful initialization\n// when termbox's functionality isn't required anymore.\nfunc Close() {\n\t// we ignore errors here, because we can't really do anything about them\n\tClear(0, 0)\n\tFlush()\n\n\t// stop event producer\n\tcancel_comm <- true\n\tset_event(interrupt)\n\tselect {\n\tcase <-input_comm:\n\tdefault:\n\t}\n\t<-cancel_done_comm\n\n\tset_console_screen_buffer_size(out, orig_size)\n\tset_console_window_info(out, &orig_window)\n\tset_console_cursor_info(out, &orig_cursor_info)\n\tset_console_cursor_position(out, coord{})\n\tset_console_mode(in, orig_mode)\n\tsyscall.Close(in)\n\tsyscall.Close(out)\n\tsyscall.Close(interrupt)\n\tIsInit = false\n}\n\n// Interrupt an in-progress call to PollEvent by causing it to return\n// EventInterrupt.  Note that this function will block until the PollEvent\n// function has successfully been interrupted.\nfunc Interrupt() {\n\tinterrupt_comm <- struct{}{}\n}\n\n// https://docs.microsoft.com/en-us/windows/console/char-info-str\nconst (\n\tcommon_lvb_leading_byte  = 0x0100\n\tcommon_lvb_trailing_byte = 0x0200\n)\n\n// Synchronizes the internal back buffer with the terminal.\nfunc Flush() error {\n\tupdate_size_maybe()\n\tprepare_diff_messages()\n\tfor _, diff := range diffbuf {\n\t\tchars := []char_info{}\n\t\tfor _, char := range diff.chars {\n\t\t\tif runewidth.RuneWidth(rune(char.char)) > 1 {\n\t\t\t\tchar.attr |= common_lvb_leading_byte\n\t\t\t\tchars = append(chars, char)\n\t\t\t\tchars = append(chars, char_info{\n\t\t\t\t\tchar: char.char,\n\t\t\t\t\tattr: char.attr | common_lvb_trailing_byte,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tchars = append(chars, char)\n\t\t\t}\n\t\t}\n\t\tr := small_rect{\n\t\t\tleft:   0,\n\t\t\ttop:    diff.pos,\n\t\t\tright:  term_size.x - 1,\n\t\t\tbottom: diff.pos + diff.lines - 1,\n\t\t}\n\t\twrite_console_output(out, chars, r)\n\t}\n\tif !is_cursor_hidden(cursor_x, cursor_y) {\n\t\tmove_cursor(cursor_x, cursor_y)\n\t}\n\treturn nil\n}\n\n// Sets the position of the cursor. See also HideCursor().\nfunc SetCursor(x, y int) {\n\tif is_cursor_hidden(cursor_x, cursor_y) && !is_cursor_hidden(x, y) {\n\t\tshow_cursor(true)\n\t}\n\n\tif !is_cursor_hidden(cursor_x, cursor_y) && is_cursor_hidden(x, y) {\n\t\tshow_cursor(false)\n\t}\n\n\tcursor_x, cursor_y = x, y\n\tif !is_cursor_hidden(cursor_x, cursor_y) {\n\t\tmove_cursor(cursor_x, cursor_y)\n\t}\n}\n\n// The shortcut for SetCursor(-1, -1).\nfunc HideCursor() {\n\tSetCursor(cursor_hidden, cursor_hidden)\n}\n\n// Changes cell's parameters in the internal back buffer at the specified\n// position.\nfunc SetCell(x, y int, ch rune, fg, bg Attribute) {\n\tif x < 0 || x >= back_buffer.width {\n\t\treturn\n\t}\n\tif y < 0 || y >= back_buffer.height {\n\t\treturn\n\t}\n\n\tback_buffer.cells[y*back_buffer.width+x] = Cell{ch, fg, bg}\n}\n\n// Returns the specified cell from the internal back buffer.\nfunc GetCell(x, y int) Cell {\n\treturn back_buffer.cells[y*back_buffer.width+x]\n}\n\n// Changes cell's character (rune) in the internal back buffer at the\n// specified position.\nfunc SetChar(x, y int, ch rune) {\n\tif x < 0 || x >= back_buffer.width {\n\t\treturn\n\t}\n\tif y < 0 || y >= back_buffer.height {\n\t\treturn\n\t}\n\n\tback_buffer.cells[y*back_buffer.width+x].Ch = ch\n}\n\n// Changes cell's foreground attributes in the internal back buffer at\n// the specified position.\nfunc SetFg(x, y int, fg Attribute) {\n\tif x < 0 || x >= back_buffer.width {\n\t\treturn\n\t}\n\tif y < 0 || y >= back_buffer.height {\n\t\treturn\n\t}\n\n\tback_buffer.cells[y*back_buffer.width+x].Fg = fg\n}\n\n// Changes cell's background attributes in the internal back buffer at\n// the specified position.\nfunc SetBg(x, y int, bg Attribute) {\n\tif x < 0 || x >= back_buffer.width {\n\t\treturn\n\t}\n\tif y < 0 || y >= back_buffer.height {\n\t\treturn\n\t}\n\n\tback_buffer.cells[y*back_buffer.width+x].Bg = bg\n}\n\n// Returns a slice into the termbox's back buffer. You can get its dimensions\n// using 'Size' function. The slice remains valid as long as no 'Clear' or\n// 'Flush' function calls were made after call to this function.\nfunc CellBuffer() []Cell {\n\treturn back_buffer.cells\n}\n\n// Wait for an event and return it. This is a blocking function call.\nfunc PollEvent() Event {\n\tselect {\n\tcase ev := <-input_comm:\n\t\treturn ev\n\tcase <-interrupt_comm:\n\t\treturn Event{Type: EventInterrupt}\n\t}\n}\n\n// Returns the size of the internal back buffer (which is mostly the same as\n// console's window size in characters). But it doesn't always match the size\n// of the console window, after the console size has changed, the internal back\n// buffer will get in sync only after Clear or Flush function calls.\nfunc Size() (int, int) {\n\treturn int(term_size.x), int(term_size.y)\n}\n\n// Clears the internal back buffer.\nfunc Clear(fg, bg Attribute) error {\n\tforeground, background = fg, bg\n\tupdate_size_maybe()\n\tback_buffer.clear()\n\treturn nil\n}\n\n// Sets termbox input mode. Termbox has two input modes:\n//\n// 1. Esc input mode. When ESC sequence is in the buffer and it doesn't match\n// any known sequence. ESC means KeyEsc. This is the default input mode.\n//\n// 2. Alt input mode. When ESC sequence is in the buffer and it doesn't match\n// any known sequence. ESC enables ModAlt modifier for the next keyboard event.\n//\n// Both input modes can be OR'ed with Mouse mode. Setting Mouse mode bit up will\n// enable mouse button press/release and drag events.\n//\n// If 'mode' is InputCurrent, returns the current input mode. See also Input*\n// constants.\nfunc SetInputMode(mode InputMode) InputMode {\n\tif mode == InputCurrent {\n\t\treturn input_mode\n\t}\n\tif mode&InputMouse != 0 {\n\t\terr := set_console_mode(in, enable_window_input|enable_mouse_input|enable_extended_flags)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\terr := set_console_mode(in, enable_window_input)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tinput_mode = mode\n\treturn input_mode\n}\n\n// Sets the termbox output mode.\n//\n// Windows console does not support extra colour modes,\n// so this will always set and return OutputNormal.\nfunc SetOutputMode(mode OutputMode) OutputMode {\n\treturn OutputNormal\n}\n\n// Sync comes handy when something causes desync between termbox's understanding\n// of a terminal buffer and the reality. Such as a third party process. Sync\n// forces a complete resync between the termbox and a terminal, it may not be\n// visually pretty though. At the moment on Windows it does nothing.\nfunc Sync() error {\n\treturn nil\n}\n"
        },
        {
          "name": "collect_terminfo.py",
          "type": "blob",
          "size": 2.0341796875,
          "content": "#!/usr/bin/env python\n\nimport sys, os, subprocess\n\ndef escaped(s):\n\treturn repr(s)[1:-1]\n\ndef tput(term, name):\n\ttry:\n\t\treturn subprocess.check_output(['tput', '-T%s' % term, name]).decode()\n\texcept subprocess.CalledProcessError as e:\n\t\treturn e.output.decode()\n\n\ndef w(s):\n\tif s == None:\n\t\treturn\n\tsys.stdout.write(s)\n\nterminals = {\n\t'xterm' : 'xterm',\n\t'rxvt-256color' : 'rxvt_256color',\n\t'rxvt-unicode' : 'rxvt_unicode',\n\t'linux' : 'linux',\n\t'Eterm' : 'eterm',\n\t'screen' : 'screen'\n}\n\nkeys = [\n\t\"F1\",\t\t\"kf1\",\n\t\"F2\",\t\t\"kf2\",\n\t\"F3\",\t\t\"kf3\",\n\t\"F4\",\t\t\"kf4\",\n\t\"F5\",\t\t\"kf5\",\n\t\"F6\",\t\t\"kf6\",\n\t\"F7\",\t\t\"kf7\",\n\t\"F8\",\t\t\"kf8\",\n\t\"F9\",\t\t\"kf9\",\n\t\"F10\",\t\t\"kf10\",\n\t\"F11\",\t\t\"kf11\",\n\t\"F12\",\t\t\"kf12\",\n\t\"INSERT\",\t\"kich1\",\n\t\"DELETE\",\t\"kdch1\",\n\t\"HOME\",\t\t\"khome\",\n\t\"END\",\t\t\"kend\",\n\t\"PGUP\",\t\t\"kpp\",\n\t\"PGDN\",\t\t\"knp\",\n\t\"KEY_UP\",\t\"kcuu1\",\n\t\"KEY_DOWN\",\t\"kcud1\",\n\t\"KEY_LEFT\",\t\"kcub1\",\n\t\"KEY_RIGHT\",\t\"kcuf1\"\n]\n\nfuncs = [\n\t\"T_ENTER_CA\",\t\t\"smcup\",\n\t\"T_EXIT_CA\",\t\t\"rmcup\",\n\t\"T_SHOW_CURSOR\",\t\"cnorm\",\n\t\"T_HIDE_CURSOR\",\t\"civis\",\n\t\"T_CLEAR_SCREEN\",\t\"clear\",\n\t\"T_SGR0\",\t\t\"sgr0\",\n\t\"T_UNDERLINE\",\t\t\"smul\",\n\t\"T_BOLD\",\t\t\"bold\",\n\t\"T_BLINK\",\t\t\"blink\",\n\t\"T_REVERSE\",            \"rev\",\n\t\"T_ENTER_KEYPAD\",\t\"smkx\",\n\t\"T_EXIT_KEYPAD\",\t\"rmkx\"\n]\n\ndef iter_pairs(iterable):\n\titerable = iter(iterable)\n\twhile True:\n\t\ttry:\n\t\t\tyield (next(iterable), next(iterable))\n\t\texcept StopIteration:\n\t\t\treturn\n\ndef do_term(term, nick):\n\tw(\"// %s\\n\" % term)\n\tw(\"var %s_keys = []string{\\n\\t\" % nick)\n\tfor k, v in iter_pairs(keys):\n\t\tw('\"')\n\t\tw(escaped(tput(term, v)))\n\t\tw('\",')\n\tw(\"\\n}\\n\")\n\tw(\"var %s_funcs = []string{\\n\\t\" % nick)\n\tfor k,v in iter_pairs(funcs):\n\t\tw('\"')\n\t\tif v == \"sgr\":\n\t\t\tw(\"\\\\033[3%d;4%dm\")\n\t\telif v == \"cup\":\n\t\t\tw(\"\\\\033[%d;%dH\")\n\t\telse:\n\t\t\tw(escaped(tput(term, v)))\n\t\tw('\", ')\n\tw(\"\\n}\\n\\n\")\n\ndef do_terms(d):\n\tw(\"var terms = []struct {\\n\")\n\tw(\"\\tname  string\\n\")\n\tw(\"\\tkeys  []string\\n\")\n\tw(\"\\tfuncs []string\\n\")\n\tw(\"}{\\n\")\n\tfor k, v in d.items():\n\t\tw('\\t{\"%s\", %s_keys, %s_funcs},\\n' % (k, v, v))\n\tw(\"}\\n\\n\")\n\nw(\"// +build !windows\\n\\npackage termbox\\n\\n\")\n\nfor k,v in terminals.items():\n\tdo_term(k, v)\n\ndo_terms(terminals)\n\n"
        },
        {
          "name": "escwait.go",
          "type": "blob",
          "size": 0.3642578125,
          "content": "// +build !darwin\n\npackage termbox\n\n// On all systems other than macOS, disable behavior which will wait before\n// deciding that the escape key was pressed, to account for partially send\n// escape sequences, especially with regard to lengthy mouse sequences.\n// See https://github.com/nsf/termbox-go/issues/132\nfunc enable_wait_for_escape_sequence() bool {\n\treturn false\n}\n"
        },
        {
          "name": "escwait_darwin.go",
          "type": "blob",
          "size": 0.3212890625,
          "content": "package termbox\n\n// On macOS, enable behavior which will wait before deciding that the escape\n// key was pressed, to account for partially send escape sequences, especially\n// with regard to lengthy mouse sequences.\n// See https://github.com/nsf/termbox-go/issues/132\nfunc enable_wait_for_escape_sequence() bool {\n\treturn true\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.166015625,
          "content": "module github.com/nsf/termbox-go\n\ngo 1.15\n\nrequire (\n\tgithub.com/mattn/go-runewidth v0.0.12\n\tgithub.com/rivo/uniseg v0.2.0 // indirect\n)\n\nretract v1.1.0 // panics on BSD\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.4169921875,
          "content": "github.com/mattn/go-runewidth v0.0.12 h1:Y41i/hVW3Pgwr8gV+J23B9YEY0zxjptBuCWEaxmAOow=\ngithub.com/mattn/go-runewidth v0.0.12/go.mod h1:RAqKPSqVFrSLVXbA8x7dzmKdmGzieGRCM46jaSJTDAk=\ngithub.com/rivo/uniseg v0.1.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.2.0 h1:S1pD9weZBuJdFmowNwbpi7BJ8TNftyUImj/0WQi72jY=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\n"
        },
        {
          "name": "syscalls.go",
          "type": "blob",
          "size": 0.7548828125,
          "content": "// +build ignore\n\npackage termbox\n\n/*\n#include <termios.h>\n#include <sys/ioctl.h>\n*/\nimport \"C\"\n\ntype syscall_Termios C.struct_termios\n\nconst (\n\tsyscall_IGNBRK = C.IGNBRK\n\tsyscall_BRKINT = C.BRKINT\n\tsyscall_PARMRK = C.PARMRK\n\tsyscall_ISTRIP = C.ISTRIP\n\tsyscall_INLCR  = C.INLCR\n\tsyscall_IGNCR  = C.IGNCR\n\tsyscall_ICRNL  = C.ICRNL\n\tsyscall_IXON   = C.IXON\n\tsyscall_OPOST  = C.OPOST\n\tsyscall_ECHO   = C.ECHO\n\tsyscall_ECHONL = C.ECHONL\n\tsyscall_ICANON = C.ICANON\n\tsyscall_ISIG   = C.ISIG\n\tsyscall_IEXTEN = C.IEXTEN\n\tsyscall_CSIZE  = C.CSIZE\n\tsyscall_PARENB = C.PARENB\n\tsyscall_CS8    = C.CS8\n\tsyscall_VMIN   = C.VMIN\n\tsyscall_VTIME  = C.VTIME\n\n\t// on darwin change these to (on *bsd too?):\n\t// C.TIOCGETA\n\t// C.TIOCSETA\n\tsyscall_TCGETS = C.TCGETS\n\tsyscall_TCSETS = C.TCSETS\n)\n"
        },
        {
          "name": "syscalls_darwin.go",
          "type": "blob",
          "size": 0.7353515625,
          "content": "// Created by cgo -godefs - DO NOT EDIT\n// cgo -godefs syscalls.go\n\n// +build !amd64\n\npackage termbox\n\ntype syscall_Termios struct {\n\tIflag  uint32\n\tOflag  uint32\n\tCflag  uint32\n\tLflag  uint32\n\tCc     [20]uint8\n\tIspeed uint32\n\tOspeed uint32\n}\n\nconst (\n\tsyscall_IGNBRK = 0x1\n\tsyscall_BRKINT = 0x2\n\tsyscall_PARMRK = 0x8\n\tsyscall_ISTRIP = 0x20\n\tsyscall_INLCR  = 0x40\n\tsyscall_IGNCR  = 0x80\n\tsyscall_ICRNL  = 0x100\n\tsyscall_IXON   = 0x200\n\tsyscall_OPOST  = 0x1\n\tsyscall_ECHO   = 0x8\n\tsyscall_ECHONL = 0x10\n\tsyscall_ICANON = 0x100\n\tsyscall_ISIG   = 0x80\n\tsyscall_IEXTEN = 0x400\n\tsyscall_CSIZE  = 0x300\n\tsyscall_PARENB = 0x1000\n\tsyscall_CS8    = 0x300\n\tsyscall_VMIN   = 0x10\n\tsyscall_VTIME  = 0x11\n\n\tsyscall_TCGETS = 0x402c7413\n\tsyscall_TCSETS = 0x802c7414\n)\n"
        },
        {
          "name": "syscalls_darwin_amd64.go",
          "type": "blob",
          "size": 0.7568359375,
          "content": "// Created by cgo -godefs - DO NOT EDIT\n// cgo -godefs syscalls.go\n\npackage termbox\n\ntype syscall_Termios struct {\n\tIflag     uint64\n\tOflag     uint64\n\tCflag     uint64\n\tLflag     uint64\n\tCc        [20]uint8\n\tPad_cgo_0 [4]byte\n\tIspeed    uint64\n\tOspeed    uint64\n}\n\nconst (\n\tsyscall_IGNBRK = 0x1\n\tsyscall_BRKINT = 0x2\n\tsyscall_PARMRK = 0x8\n\tsyscall_ISTRIP = 0x20\n\tsyscall_INLCR  = 0x40\n\tsyscall_IGNCR  = 0x80\n\tsyscall_ICRNL  = 0x100\n\tsyscall_IXON   = 0x200\n\tsyscall_OPOST  = 0x1\n\tsyscall_ECHO   = 0x8\n\tsyscall_ECHONL = 0x10\n\tsyscall_ICANON = 0x100\n\tsyscall_ISIG   = 0x80\n\tsyscall_IEXTEN = 0x400\n\tsyscall_CSIZE  = 0x300\n\tsyscall_PARENB = 0x1000\n\tsyscall_CS8    = 0x300\n\tsyscall_VMIN   = 0x10\n\tsyscall_VTIME  = 0x11\n\n\tsyscall_TCGETS = 0x40487413\n\tsyscall_TCSETS = 0x80487414\n)\n"
        },
        {
          "name": "syscalls_dragonfly.go",
          "type": "blob",
          "size": 0.7177734375,
          "content": "// Created by cgo -godefs - DO NOT EDIT\n// cgo -godefs syscalls.go\n\npackage termbox\n\ntype syscall_Termios struct {\n\tIflag  uint32\n\tOflag  uint32\n\tCflag  uint32\n\tLflag  uint32\n\tCc     [20]uint8\n\tIspeed uint32\n\tOspeed uint32\n}\n\nconst (\n\tsyscall_IGNBRK = 0x1\n\tsyscall_BRKINT = 0x2\n\tsyscall_PARMRK = 0x8\n\tsyscall_ISTRIP = 0x20\n\tsyscall_INLCR  = 0x40\n\tsyscall_IGNCR  = 0x80\n\tsyscall_ICRNL  = 0x100\n\tsyscall_IXON   = 0x200\n\tsyscall_OPOST  = 0x1\n\tsyscall_ECHO   = 0x8\n\tsyscall_ECHONL = 0x10\n\tsyscall_ICANON = 0x100\n\tsyscall_ISIG   = 0x80\n\tsyscall_IEXTEN = 0x400\n\tsyscall_CSIZE  = 0x300\n\tsyscall_PARENB = 0x1000\n\tsyscall_CS8    = 0x300\n\tsyscall_VMIN   = 0x10\n\tsyscall_VTIME  = 0x11\n\n\tsyscall_TCGETS = 0x402c7413\n\tsyscall_TCSETS = 0x802c7414\n)\n"
        },
        {
          "name": "syscalls_freebsd.go",
          "type": "blob",
          "size": 0.7177734375,
          "content": "// Created by cgo -godefs - DO NOT EDIT\n// cgo -godefs syscalls.go\n\npackage termbox\n\ntype syscall_Termios struct {\n\tIflag  uint32\n\tOflag  uint32\n\tCflag  uint32\n\tLflag  uint32\n\tCc     [20]uint8\n\tIspeed uint32\n\tOspeed uint32\n}\n\nconst (\n\tsyscall_IGNBRK = 0x1\n\tsyscall_BRKINT = 0x2\n\tsyscall_PARMRK = 0x8\n\tsyscall_ISTRIP = 0x20\n\tsyscall_INLCR  = 0x40\n\tsyscall_IGNCR  = 0x80\n\tsyscall_ICRNL  = 0x100\n\tsyscall_IXON   = 0x200\n\tsyscall_OPOST  = 0x1\n\tsyscall_ECHO   = 0x8\n\tsyscall_ECHONL = 0x10\n\tsyscall_ICANON = 0x100\n\tsyscall_ISIG   = 0x80\n\tsyscall_IEXTEN = 0x400\n\tsyscall_CSIZE  = 0x300\n\tsyscall_PARENB = 0x1000\n\tsyscall_CS8    = 0x300\n\tsyscall_VMIN   = 0x10\n\tsyscall_VTIME  = 0x11\n\n\tsyscall_TCGETS = 0x402c7413\n\tsyscall_TCSETS = 0x802c7414\n)\n"
        },
        {
          "name": "syscalls_linux.go",
          "type": "blob",
          "size": 0.80859375,
          "content": "// Created by cgo -godefs - DO NOT EDIT\n// cgo -godefs syscalls.go\n\npackage termbox\n\nimport \"syscall\"\n\ntype syscall_Termios syscall.Termios\n\nconst (\n\tsyscall_IGNBRK = syscall.IGNBRK\n\tsyscall_BRKINT = syscall.BRKINT\n\tsyscall_PARMRK = syscall.PARMRK\n\tsyscall_ISTRIP = syscall.ISTRIP\n\tsyscall_INLCR  = syscall.INLCR\n\tsyscall_IGNCR  = syscall.IGNCR\n\tsyscall_ICRNL  = syscall.ICRNL\n\tsyscall_IXON   = syscall.IXON\n\tsyscall_OPOST  = syscall.OPOST\n\tsyscall_ECHO   = syscall.ECHO\n\tsyscall_ECHONL = syscall.ECHONL\n\tsyscall_ICANON = syscall.ICANON\n\tsyscall_ISIG   = syscall.ISIG\n\tsyscall_IEXTEN = syscall.IEXTEN\n\tsyscall_CSIZE  = syscall.CSIZE\n\tsyscall_PARENB = syscall.PARENB\n\tsyscall_CS8    = syscall.CS8\n\tsyscall_VMIN   = syscall.VMIN\n\tsyscall_VTIME  = syscall.VTIME\n\n\tsyscall_TCGETS = syscall.TCGETS\n\tsyscall_TCSETS = syscall.TCSETS\n)\n"
        },
        {
          "name": "syscalls_netbsd.go",
          "type": "blob",
          "size": 0.7158203125,
          "content": "// Created by cgo -godefs - DO NOT EDIT\n// cgo -godefs syscalls.go\n\npackage termbox\n\ntype syscall_Termios struct {\n\tIflag  uint32\n\tOflag  uint32\n\tCflag  uint32\n\tLflag  uint32\n\tCc     [20]uint8\n\tIspeed int32\n\tOspeed int32\n}\n\nconst (\n\tsyscall_IGNBRK = 0x1\n\tsyscall_BRKINT = 0x2\n\tsyscall_PARMRK = 0x8\n\tsyscall_ISTRIP = 0x20\n\tsyscall_INLCR  = 0x40\n\tsyscall_IGNCR  = 0x80\n\tsyscall_ICRNL  = 0x100\n\tsyscall_IXON   = 0x200\n\tsyscall_OPOST  = 0x1\n\tsyscall_ECHO   = 0x8\n\tsyscall_ECHONL = 0x10\n\tsyscall_ICANON = 0x100\n\tsyscall_ISIG   = 0x80\n\tsyscall_IEXTEN = 0x400\n\tsyscall_CSIZE  = 0x300\n\tsyscall_PARENB = 0x1000\n\tsyscall_CS8    = 0x300\n\tsyscall_VMIN   = 0x10\n\tsyscall_VTIME  = 0x11\n\n\tsyscall_TCGETS = 0x402c7413\n\tsyscall_TCSETS = 0x802c7414\n)\n"
        },
        {
          "name": "syscalls_openbsd.go",
          "type": "blob",
          "size": 0.7158203125,
          "content": "// Created by cgo -godefs - DO NOT EDIT\n// cgo -godefs syscalls.go\n\npackage termbox\n\ntype syscall_Termios struct {\n\tIflag  uint32\n\tOflag  uint32\n\tCflag  uint32\n\tLflag  uint32\n\tCc     [20]uint8\n\tIspeed int32\n\tOspeed int32\n}\n\nconst (\n\tsyscall_IGNBRK = 0x1\n\tsyscall_BRKINT = 0x2\n\tsyscall_PARMRK = 0x8\n\tsyscall_ISTRIP = 0x20\n\tsyscall_INLCR  = 0x40\n\tsyscall_IGNCR  = 0x80\n\tsyscall_ICRNL  = 0x100\n\tsyscall_IXON   = 0x200\n\tsyscall_OPOST  = 0x1\n\tsyscall_ECHO   = 0x8\n\tsyscall_ECHONL = 0x10\n\tsyscall_ICANON = 0x100\n\tsyscall_ISIG   = 0x80\n\tsyscall_IEXTEN = 0x400\n\tsyscall_CSIZE  = 0x300\n\tsyscall_PARENB = 0x1000\n\tsyscall_CS8    = 0x300\n\tsyscall_VMIN   = 0x10\n\tsyscall_VTIME  = 0x11\n\n\tsyscall_TCGETS = 0x402c7413\n\tsyscall_TCSETS = 0x802c7414\n)\n"
        },
        {
          "name": "syscalls_windows.go",
          "type": "blob",
          "size": 1.4521484375,
          "content": "// Created by cgo -godefs - DO NOT EDIT\n// cgo -godefs -- -DUNICODE syscalls.go\n\npackage termbox\n\nconst (\n\tforeground_blue          = 0x1\n\tforeground_green         = 0x2\n\tforeground_red           = 0x4\n\tforeground_intensity     = 0x8\n\tbackground_blue          = 0x10\n\tbackground_green         = 0x20\n\tbackground_red           = 0x40\n\tbackground_intensity     = 0x80\n\tstd_input_handle         = -0xa\n\tstd_output_handle        = -0xb\n\tkey_event                = 0x1\n\tmouse_event              = 0x2\n\twindow_buffer_size_event = 0x4\n\tenable_window_input      = 0x8\n\tenable_mouse_input       = 0x10\n\tenable_extended_flags    = 0x80\n\n\tvk_f1          = 0x70\n\tvk_f2          = 0x71\n\tvk_f3          = 0x72\n\tvk_f4          = 0x73\n\tvk_f5          = 0x74\n\tvk_f6          = 0x75\n\tvk_f7          = 0x76\n\tvk_f8          = 0x77\n\tvk_f9          = 0x78\n\tvk_f10         = 0x79\n\tvk_f11         = 0x7a\n\tvk_f12         = 0x7b\n\tvk_insert      = 0x2d\n\tvk_delete      = 0x2e\n\tvk_home        = 0x24\n\tvk_end         = 0x23\n\tvk_pgup        = 0x21\n\tvk_pgdn        = 0x22\n\tvk_arrow_up    = 0x26\n\tvk_arrow_down  = 0x28\n\tvk_arrow_left  = 0x25\n\tvk_arrow_right = 0x27\n\tvk_backspace   = 0x8\n\tvk_tab         = 0x9\n\tvk_enter       = 0xd\n\tvk_esc         = 0x1b\n\tvk_space       = 0x20\n\n\tleft_alt_pressed   = 0x2\n\tleft_ctrl_pressed  = 0x8\n\tright_alt_pressed  = 0x1\n\tright_ctrl_pressed = 0x4\n\tshift_pressed      = 0x10\n\n\tgeneric_read            = 0x80000000\n\tgeneric_write           = 0x40000000\n\tconsole_textmode_buffer = 0x1\n)\n"
        },
        {
          "name": "termbox.go",
          "type": "blob",
          "size": 13.326171875,
          "content": "// +build !windows\n\npackage termbox\n\nimport \"unicode/utf8\"\nimport \"bytes\"\nimport \"syscall\"\nimport \"unsafe\"\nimport \"strings\"\nimport \"strconv\"\nimport \"os\"\nimport \"io\"\n\n// private API\n\nconst (\n\t// for future contributors: after adding something here,\n\t// you have to add the corresponding index in a terminfo\n\t// file to `terminfo.go#ti_funcs`. The values can be taken\n\t// from (ncurses) `term.h`. The builtin terminfo at terminfo_builtin.go\n\t// also needs adjusting with the new values.\n\tt_enter_ca = iota\n\tt_exit_ca\n\tt_show_cursor\n\tt_hide_cursor\n\tt_clear_screen\n\tt_sgr0\n\tt_underline\n\tt_bold\n\tt_hidden\n\tt_blink\n\tt_dim\n\tt_cursive\n\tt_reverse\n\tt_enter_keypad\n\tt_exit_keypad\n\tt_enter_mouse\n\tt_exit_mouse\n\tt_max_funcs\n)\n\nconst (\n\tcoord_invalid = -2\n\tattr_invalid  = Attribute(0xFFFF)\n)\n\ntype input_event struct {\n\tdata []byte\n\terr  error\n}\n\ntype extract_event_res int\n\nconst (\n\tevent_not_extracted extract_event_res = iota\n\tevent_extracted\n\tesc_wait\n)\n\nvar (\n\t// term specific sequences\n\tkeys  []string\n\tfuncs []string\n\n\t// termbox inner state\n\torig_tios      syscall_Termios\n\tback_buffer    cellbuf\n\tfront_buffer   cellbuf\n\ttermw          int\n\ttermh          int\n\tinput_mode     = InputEsc\n\toutput_mode    = OutputNormal\n\tout            *os.File\n\toutfd          uintptr\n\tin             int\n\tlastfg         = attr_invalid\n\tlastbg         = attr_invalid\n\tlastx          = coord_invalid\n\tlasty          = coord_invalid\n\tcursor_x       = cursor_hidden\n\tcursor_y       = cursor_hidden\n\tforeground     = ColorDefault\n\tbackground     = ColorDefault\n\tinbuf          = make([]byte, 0, 64)\n\toutbuf         bytes.Buffer\n\tsigwinch       = make(chan os.Signal, 1)\n\tsigio          = make(chan os.Signal, 1)\n\tquit           = make(chan int)\n\tinput_comm     = make(chan input_event)\n\tinterrupt_comm = make(chan struct{})\n\tintbuf         = make([]byte, 0, 16)\n\n\t// grayscale indexes\n\tgrayscale = []Attribute{\n\t\t0, 17, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244,\n\t\t245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 232,\n\t}\n)\n\nfunc write_cursor(x, y int) {\n\toutbuf.WriteString(\"\\033[\")\n\toutbuf.Write(strconv.AppendUint(intbuf, uint64(y+1), 10))\n\toutbuf.WriteString(\";\")\n\toutbuf.Write(strconv.AppendUint(intbuf, uint64(x+1), 10))\n\toutbuf.WriteString(\"H\")\n}\n\nfunc write_sgr_fg(a Attribute) {\n\tswitch output_mode {\n\tcase Output256, Output216, OutputGrayscale:\n\t\toutbuf.WriteString(\"\\033[38;5;\")\n\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(a-1), 10))\n\t\toutbuf.WriteString(\"m\")\n\tcase OutputRGB:\n\t\tr, g, b := AttributeToRGB(a)\n\t\toutbuf.WriteString(escapeRGB(true, r, g, b))\n\tdefault:\n\t\tif a < ColorDarkGray {\n\t\t\toutbuf.WriteString(\"\\033[3\")\n\t\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(a-ColorBlack), 10))\n\t\t\toutbuf.WriteString(\"m\")\n\t\t} else {\n\t\t\toutbuf.WriteString(\"\\033[9\")\n\t\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(a-ColorDarkGray), 10))\n\t\t\toutbuf.WriteString(\"m\")\n\t\t}\n\t}\n}\n\nfunc write_sgr_bg(a Attribute) {\n\tswitch output_mode {\n\tcase Output256, Output216, OutputGrayscale:\n\t\toutbuf.WriteString(\"\\033[48;5;\")\n\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(a-1), 10))\n\t\toutbuf.WriteString(\"m\")\n\tcase OutputRGB:\n\t\tr, g, b := AttributeToRGB(a)\n\t\toutbuf.WriteString(escapeRGB(false, r, g, b))\n\tdefault:\n\t\tif a < ColorDarkGray {\n\t\t\toutbuf.WriteString(\"\\033[4\")\n\t\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(a-ColorBlack), 10))\n\t\t\toutbuf.WriteString(\"m\")\n\t\t} else {\n\t\t\toutbuf.WriteString(\"\\033[10\")\n\t\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(a-ColorDarkGray), 10))\n\t\t\toutbuf.WriteString(\"m\")\n\t\t}\n\t}\n}\n\nfunc write_sgr(fg, bg Attribute) {\n\tswitch output_mode {\n\tcase Output256, Output216, OutputGrayscale:\n\t\toutbuf.WriteString(\"\\033[38;5;\")\n\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(fg-1), 10))\n\t\toutbuf.WriteString(\"m\")\n\t\toutbuf.WriteString(\"\\033[48;5;\")\n\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(bg-1), 10))\n\t\toutbuf.WriteString(\"m\")\n\tcase OutputRGB:\n\t\tr, g, b := AttributeToRGB(fg)\n\t\toutbuf.WriteString(escapeRGB(true, r, g, b))\n\t\tr, g, b = AttributeToRGB(bg)\n\t\toutbuf.WriteString(escapeRGB(false, r, g, b))\n\tdefault:\n\t\tif fg < ColorDarkGray {\n\t\t\toutbuf.WriteString(\"\\033[3\")\n\t\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(fg-ColorBlack), 10))\n\t\t\toutbuf.WriteString(\";\")\n\t\t} else {\n\t\t\toutbuf.WriteString(\"\\033[9\")\n\t\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(fg-ColorDarkGray), 10))\n\t\t\toutbuf.WriteString(\";\")\n\t\t}\n\t\tif bg < ColorDarkGray {\n\t\t\toutbuf.WriteString(\"4\")\n\t\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(bg-ColorBlack), 10))\n\t\t\toutbuf.WriteString(\"m\")\n\t\t} else {\n\t\t\toutbuf.WriteString(\"10\")\n\t\t\toutbuf.Write(strconv.AppendUint(intbuf, uint64(bg-ColorDarkGray), 10))\n\t\t\toutbuf.WriteString(\"m\")\n\t\t}\n\t}\n}\n\nfunc escapeRGB(fg bool, r uint8, g uint8, b uint8) string {\n\tvar escape string = \"\\033[\"\n\tif fg {\n\t\tescape += \"38\"\n\t} else {\n\t\tescape += \"48\"\n\t}\n\tescape += \";2;\"\n\tescape += strconv.FormatUint(uint64(r), 10) + \";\"\n\tescape += strconv.FormatUint(uint64(g), 10) + \";\"\n\tescape += strconv.FormatUint(uint64(b), 10) + \"m\"\n\treturn escape\n}\n\ntype winsize struct {\n\trows    uint16\n\tcols    uint16\n\txpixels uint16\n\typixels uint16\n}\n\nfunc get_term_size(fd uintptr) (int, int) {\n\tvar sz winsize\n\t_, _, _ = syscall.Syscall(syscall.SYS_IOCTL,\n\t\tfd, uintptr(syscall.TIOCGWINSZ), uintptr(unsafe.Pointer(&sz)))\n\treturn int(sz.cols), int(sz.rows)\n}\n\nfunc send_attr(fg, bg Attribute) {\n\tif fg == lastfg && bg == lastbg {\n\t\treturn\n\t}\n\n\toutbuf.WriteString(funcs[t_sgr0])\n\n\tvar fgcol, bgcol Attribute\n\n\tswitch output_mode {\n\tcase Output256:\n\t\tfgcol = fg & 0x1FF\n\t\tbgcol = bg & 0x1FF\n\tcase Output216:\n\t\tfgcol = fg & 0xFF\n\t\tbgcol = bg & 0xFF\n\t\tif fgcol > 216 {\n\t\t\tfgcol = ColorDefault\n\t\t}\n\t\tif bgcol > 216 {\n\t\t\tbgcol = ColorDefault\n\t\t}\n\t\tif fgcol != ColorDefault {\n\t\t\tfgcol += 0x10\n\t\t}\n\t\tif bgcol != ColorDefault {\n\t\t\tbgcol += 0x10\n\t\t}\n\tcase OutputGrayscale:\n\t\tfgcol = fg & 0x1F\n\t\tbgcol = bg & 0x1F\n\t\tif fgcol > 26 {\n\t\t\tfgcol = ColorDefault\n\t\t}\n\t\tif bgcol > 26 {\n\t\t\tbgcol = ColorDefault\n\t\t}\n\t\tif fgcol != ColorDefault {\n\t\t\tfgcol = grayscale[fgcol]\n\t\t}\n\t\tif bgcol != ColorDefault {\n\t\t\tbgcol = grayscale[bgcol]\n\t\t}\n\tcase OutputRGB:\n\t\tfgcol = fg\n\t\tbgcol = bg\n\tdefault:\n\t\tfgcol = fg & 0xFF\n\t\tbgcol = bg & 0xFF\n\t}\n\n\tif fgcol != ColorDefault {\n\t\tif bgcol != ColorDefault {\n\t\t\twrite_sgr(fgcol, bgcol)\n\t\t} else {\n\t\t\twrite_sgr_fg(fgcol)\n\t\t}\n\t} else if bgcol != ColorDefault {\n\t\twrite_sgr_bg(bgcol)\n\t}\n\n\tif fg&AttrBold != 0 {\n\t\toutbuf.WriteString(funcs[t_bold])\n\t}\n\t/*if bg&AttrBold != 0 {\n\t\toutbuf.WriteString(funcs[t_blink])\n\t}*/\n\tif fg&AttrBlink != 0 {\n\t\toutbuf.WriteString(funcs[t_blink])\n\t}\n\tif fg&AttrUnderline != 0 {\n\t\toutbuf.WriteString(funcs[t_underline])\n\t}\n\tif fg&AttrCursive != 0 {\n\t\toutbuf.WriteString(funcs[t_cursive])\n\t}\n\tif fg&AttrHidden != 0 {\n\t\toutbuf.WriteString(funcs[t_hidden])\n\t}\n\tif fg&AttrDim != 0 {\n\t\toutbuf.WriteString(funcs[t_dim])\n\t}\n\tif fg&AttrReverse|bg&AttrReverse != 0 {\n\t\toutbuf.WriteString(funcs[t_reverse])\n\t}\n\n\tlastfg, lastbg = fg, bg\n}\n\nfunc send_char(x, y int, ch rune) {\n\tvar buf [8]byte\n\tn := utf8.EncodeRune(buf[:], ch)\n\tif x-1 != lastx || y != lasty {\n\t\twrite_cursor(x, y)\n\t}\n\tlastx, lasty = x, y\n\toutbuf.Write(buf[:n])\n}\n\nfunc flush() error {\n\t_, err := io.Copy(out, &outbuf)\n\toutbuf.Reset()\n\treturn err\n}\n\nfunc send_clear() error {\n\tsend_attr(foreground, background)\n\toutbuf.WriteString(funcs[t_clear_screen])\n\tif !is_cursor_hidden(cursor_x, cursor_y) {\n\t\twrite_cursor(cursor_x, cursor_y)\n\t}\n\n\t// we need to invalidate cursor position too and these two vars are\n\t// used only for simple cursor positioning optimization, cursor\n\t// actually may be in the correct place, but we simply discard\n\t// optimization once and it gives us simple solution for the case when\n\t// cursor moved\n\tlastx = coord_invalid\n\tlasty = coord_invalid\n\n\treturn flush()\n}\n\nfunc update_size_maybe() error {\n\tw, h := get_term_size(outfd)\n\tif w != termw || h != termh {\n\t\ttermw, termh = w, h\n\t\tback_buffer.resize(termw, termh)\n\t\tfront_buffer.resize(termw, termh)\n\t\tfront_buffer.clear()\n\t\treturn send_clear()\n\t}\n\treturn nil\n}\n\nfunc tcsetattr(fd uintptr, termios *syscall_Termios) error {\n\tr, _, e := syscall.Syscall(syscall.SYS_IOCTL,\n\t\tfd, uintptr(syscall_TCSETS), uintptr(unsafe.Pointer(termios)))\n\tif r != 0 {\n\t\treturn os.NewSyscallError(\"SYS_IOCTL\", e)\n\t}\n\treturn nil\n}\n\nfunc tcgetattr(fd uintptr, termios *syscall_Termios) error {\n\tr, _, e := syscall.Syscall(syscall.SYS_IOCTL,\n\t\tfd, uintptr(syscall_TCGETS), uintptr(unsafe.Pointer(termios)))\n\tif r != 0 {\n\t\treturn os.NewSyscallError(\"SYS_IOCTL\", e)\n\t}\n\treturn nil\n}\n\nfunc parse_mouse_event(event *Event, buf string) (int, bool) {\n\tif strings.HasPrefix(buf, \"\\033[M\") && len(buf) >= 6 {\n\t\t// X10 mouse encoding, the simplest one\n\t\t// \\033 [ M Cb Cx Cy\n\t\tb := buf[3] - 32\n\t\tswitch b & 3 {\n\t\tcase 0:\n\t\t\tif b&64 != 0 {\n\t\t\t\tevent.Key = MouseWheelUp\n\t\t\t} else {\n\t\t\t\tevent.Key = MouseLeft\n\t\t\t}\n\t\tcase 1:\n\t\t\tif b&64 != 0 {\n\t\t\t\tevent.Key = MouseWheelDown\n\t\t\t} else {\n\t\t\t\tevent.Key = MouseMiddle\n\t\t\t}\n\t\tcase 2:\n\t\t\tevent.Key = MouseRight\n\t\tcase 3:\n\t\t\tevent.Key = MouseRelease\n\t\tdefault:\n\t\t\treturn 6, false\n\t\t}\n\t\tevent.Type = EventMouse // KeyEvent by default\n\t\tif b&32 != 0 {\n\t\t\tevent.Mod |= ModMotion\n\t\t}\n\n\t\t// the coord is 1,1 for upper left\n\t\tevent.MouseX = int(buf[4]) - 1 - 32\n\t\tevent.MouseY = int(buf[5]) - 1 - 32\n\t\treturn 6, true\n\t} else if strings.HasPrefix(buf, \"\\033[<\") || strings.HasPrefix(buf, \"\\033[\") {\n\t\t// xterm 1006 extended mode or urxvt 1015 extended mode\n\t\t// xterm: \\033 [ < Cb ; Cx ; Cy (M or m)\n\t\t// urxvt: \\033 [ Cb ; Cx ; Cy M\n\n\t\t// find the first M or m, that's where we stop\n\t\tmi := strings.IndexAny(buf, \"Mm\")\n\t\tif mi == -1 {\n\t\t\treturn 0, false\n\t\t}\n\n\t\t// whether it's a capital M or not\n\t\tisM := buf[mi] == 'M'\n\n\t\t// whether it's urxvt or not\n\t\tisU := false\n\n\t\t// buf[2] is safe here, because having M or m found means we have at\n\t\t// least 3 bytes in a string\n\t\tif buf[2] == '<' {\n\t\t\tbuf = buf[3:mi]\n\t\t} else {\n\t\t\tisU = true\n\t\t\tbuf = buf[2:mi]\n\t\t}\n\n\t\ts1 := strings.Index(buf, \";\")\n\t\ts2 := strings.LastIndex(buf, \";\")\n\t\t// not found or only one ';'\n\t\tif s1 == -1 || s2 == -1 || s1 == s2 {\n\t\t\treturn 0, false\n\t\t}\n\n\t\tn1, err := strconv.ParseInt(buf[0:s1], 10, 64)\n\t\tif err != nil {\n\t\t\treturn 0, false\n\t\t}\n\t\tn2, err := strconv.ParseInt(buf[s1+1:s2], 10, 64)\n\t\tif err != nil {\n\t\t\treturn 0, false\n\t\t}\n\t\tn3, err := strconv.ParseInt(buf[s2+1:], 10, 64)\n\t\tif err != nil {\n\t\t\treturn 0, false\n\t\t}\n\n\t\t// on urxvt, first number is encoded exactly as in X10, but we need to\n\t\t// make it zero-based, on xterm it is zero-based already\n\t\tif isU {\n\t\t\tn1 -= 32\n\t\t}\n\t\tswitch n1 & 3 {\n\t\tcase 0:\n\t\t\tif n1&64 != 0 {\n\t\t\t\tevent.Key = MouseWheelUp\n\t\t\t} else {\n\t\t\t\tevent.Key = MouseLeft\n\t\t\t}\n\t\tcase 1:\n\t\t\tif n1&64 != 0 {\n\t\t\t\tevent.Key = MouseWheelDown\n\t\t\t} else {\n\t\t\t\tevent.Key = MouseMiddle\n\t\t\t}\n\t\tcase 2:\n\t\t\tevent.Key = MouseRight\n\t\tcase 3:\n\t\t\tevent.Key = MouseRelease\n\t\tdefault:\n\t\t\treturn mi + 1, false\n\t\t}\n\t\tif !isM {\n\t\t\t// on xterm mouse release is signaled by lowercase m\n\t\t\tevent.Key = MouseRelease\n\t\t}\n\n\t\tevent.Type = EventMouse // KeyEvent by default\n\t\tif n1&32 != 0 {\n\t\t\tevent.Mod |= ModMotion\n\t\t}\n\n\t\tevent.MouseX = int(n2) - 1\n\t\tevent.MouseY = int(n3) - 1\n\t\treturn mi + 1, true\n\t}\n\n\treturn 0, false\n}\n\nfunc parse_escape_sequence(event *Event, buf []byte) (int, bool) {\n\tbufstr := string(buf)\n\tfor i, key := range keys {\n\t\tif strings.HasPrefix(bufstr, key) {\n\t\t\tevent.Ch = 0\n\t\t\tevent.Key = Key(0xFFFF - i)\n\t\t\treturn len(key), true\n\t\t}\n\t}\n\n\t// if none of the keys match, let's try mouse sequences\n\treturn parse_mouse_event(event, bufstr)\n}\n\nfunc extract_raw_event(data []byte, event *Event) bool {\n\tif len(inbuf) == 0 {\n\t\treturn false\n\t}\n\n\tn := len(data)\n\tif n == 0 {\n\t\treturn false\n\t}\n\n\tn = copy(data, inbuf)\n\tcopy(inbuf, inbuf[n:])\n\tinbuf = inbuf[:len(inbuf)-n]\n\n\tevent.N = n\n\tevent.Type = EventRaw\n\treturn true\n}\n\nfunc extract_event(inbuf []byte, event *Event, allow_esc_wait bool) extract_event_res {\n\tif len(inbuf) == 0 {\n\t\tevent.N = 0\n\t\treturn event_not_extracted\n\t}\n\n\tif inbuf[0] == '\\033' {\n\t\t// possible escape sequence\n\t\tif n, ok := parse_escape_sequence(event, inbuf); n != 0 {\n\t\t\tevent.N = n\n\t\t\tif ok {\n\t\t\t\treturn event_extracted\n\t\t\t} else {\n\t\t\t\treturn event_not_extracted\n\t\t\t}\n\t\t}\n\n\t\t// possible partially read escape sequence; trigger a wait if appropriate\n\t\tif enable_wait_for_escape_sequence() && allow_esc_wait {\n\t\t\tevent.N = 0\n\t\t\treturn esc_wait\n\t\t}\n\n\t\t// it's not escape sequence, then it's Alt or Esc, check input_mode\n\t\tswitch {\n\t\tcase input_mode&InputEsc != 0:\n\t\t\t// if we're in escape mode, fill Esc event, pop buffer, return success\n\t\t\tevent.Ch = 0\n\t\t\tevent.Key = KeyEsc\n\t\t\tevent.Mod = 0\n\t\t\tevent.N = 1\n\t\t\treturn event_extracted\n\t\tcase input_mode&InputAlt != 0:\n\t\t\t// if we're in alt mode, set Alt modifier to event and redo parsing\n\t\t\tevent.Mod = ModAlt\n\t\t\tstatus := extract_event(inbuf[1:], event, false)\n\t\t\tif status == event_extracted {\n\t\t\t\tevent.N++\n\t\t\t} else {\n\t\t\t\tevent.N = 0\n\t\t\t}\n\t\t\treturn status\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t}\n\n\t// if we're here, this is not an escape sequence and not an alt sequence\n\t// so, it's a FUNCTIONAL KEY or a UNICODE character\n\n\t// first of all check if it's a functional key\n\tif Key(inbuf[0]) <= KeySpace || Key(inbuf[0]) == KeyBackspace2 {\n\t\t// fill event, pop buffer, return success\n\t\tevent.Ch = 0\n\t\tevent.Key = Key(inbuf[0])\n\t\tevent.N = 1\n\t\treturn event_extracted\n\t}\n\n\t// the only possible option is utf8 rune\n\tif r, n := utf8.DecodeRune(inbuf); r != utf8.RuneError {\n\t\tevent.Ch = r\n\t\tevent.Key = 0\n\t\tevent.N = n\n\t\treturn event_extracted\n\t}\n\n\treturn event_not_extracted\n}\n\nfunc fcntl(fd int, cmd int, arg int) (val int, err error) {\n\tr, _, e := syscall.Syscall(syscall.SYS_FCNTL, uintptr(fd), uintptr(cmd),\n\t\tuintptr(arg))\n\tval = int(r)\n\tif e != 0 {\n\t\terr = e\n\t}\n\treturn\n}\n"
        },
        {
          "name": "termbox_common.go",
          "type": "blob",
          "size": 0.970703125,
          "content": "package termbox\n\n// private API, common OS agnostic part\n\ntype cellbuf struct {\n\twidth  int\n\theight int\n\tcells  []Cell\n}\n\nfunc (this *cellbuf) init(width, height int) {\n\tthis.width = width\n\tthis.height = height\n\tthis.cells = make([]Cell, width*height)\n}\n\nfunc (this *cellbuf) resize(width, height int) {\n\tif this.width == width && this.height == height {\n\t\treturn\n\t}\n\n\toldw := this.width\n\toldh := this.height\n\toldcells := this.cells\n\n\tthis.init(width, height)\n\tthis.clear()\n\n\tminw, minh := oldw, oldh\n\n\tif width < minw {\n\t\tminw = width\n\t}\n\tif height < minh {\n\t\tminh = height\n\t}\n\n\tfor i := 0; i < minh; i++ {\n\t\tsrco, dsto := i*oldw, i*width\n\t\tsrc := oldcells[srco : srco+minw]\n\t\tdst := this.cells[dsto : dsto+minw]\n\t\tcopy(dst, src)\n\t}\n}\n\nfunc (this *cellbuf) clear() {\n\tfor i := range this.cells {\n\t\tc := &this.cells[i]\n\t\tc.Ch = ' '\n\t\tc.Fg = foreground\n\t\tc.Bg = background\n\t}\n}\n\nconst cursor_hidden = -1\n\nfunc is_cursor_hidden(x, y int) bool {\n\treturn x == cursor_hidden || y == cursor_hidden\n}\n"
        },
        {
          "name": "termbox_windows.go",
          "type": "blob",
          "size": 22.0068359375,
          "content": "package termbox\n\nimport \"math\"\nimport \"syscall\"\nimport \"unsafe\"\nimport \"unicode/utf16\"\nimport \"github.com/mattn/go-runewidth\"\n\ntype (\n\twchar     uint16\n\tshort     int16\n\tdword     uint32\n\tword      uint16\n\tchar_info struct {\n\t\tchar wchar\n\t\tattr word\n\t}\n\tcoord struct {\n\t\tx short\n\t\ty short\n\t}\n\tsmall_rect struct {\n\t\tleft   short\n\t\ttop    short\n\t\tright  short\n\t\tbottom short\n\t}\n\tconsole_screen_buffer_info struct {\n\t\tsize                coord\n\t\tcursor_position     coord\n\t\tattributes          word\n\t\twindow              small_rect\n\t\tmaximum_window_size coord\n\t}\n\tconsole_cursor_info struct {\n\t\tsize    dword\n\t\tvisible int32\n\t}\n\tinput_record struct {\n\t\tevent_type word\n\t\t_          [2]byte\n\t\tevent      [16]byte\n\t}\n\tkey_event_record struct {\n\t\tkey_down          int32\n\t\trepeat_count      word\n\t\tvirtual_key_code  word\n\t\tvirtual_scan_code word\n\t\tunicode_char      wchar\n\t\tcontrol_key_state dword\n\t}\n\twindow_buffer_size_record struct {\n\t\tsize coord\n\t}\n\tmouse_event_record struct {\n\t\tmouse_pos         coord\n\t\tbutton_state      dword\n\t\tcontrol_key_state dword\n\t\tevent_flags       dword\n\t}\n\tconsole_font_info struct {\n\t\tfont      uint32\n\t\tfont_size coord\n\t}\n)\n\nconst (\n\tmouse_lmb = 0x1\n\tmouse_rmb = 0x2\n\tmouse_mmb = 0x4 | 0x8 | 0x10\n\tSM_CXMIN  = 28\n\tSM_CYMIN  = 29\n)\n\nfunc (this coord) uintptr() uintptr {\n\treturn uintptr(*(*int32)(unsafe.Pointer(&this)))\n}\n\nfunc (this *small_rect) uintptr() uintptr {\n\treturn uintptr(unsafe.Pointer(this))\n}\n\nvar kernel32 = syscall.NewLazyDLL(\"kernel32.dll\")\nvar moduser32 = syscall.NewLazyDLL(\"user32.dll\")\nvar is_cjk = runewidth.IsEastAsian()\n\nvar (\n\tproc_set_console_active_screen_buffer = kernel32.NewProc(\"SetConsoleActiveScreenBuffer\")\n\tproc_set_console_screen_buffer_size   = kernel32.NewProc(\"SetConsoleScreenBufferSize\")\n\tproc_set_console_window_info          = kernel32.NewProc(\"SetConsoleWindowInfo\")\n\tproc_create_console_screen_buffer     = kernel32.NewProc(\"CreateConsoleScreenBuffer\")\n\tproc_get_console_screen_buffer_info   = kernel32.NewProc(\"GetConsoleScreenBufferInfo\")\n\tproc_write_console_output             = kernel32.NewProc(\"WriteConsoleOutputW\")\n\tproc_write_console_output_character   = kernel32.NewProc(\"WriteConsoleOutputCharacterW\")\n\tproc_write_console_output_attribute   = kernel32.NewProc(\"WriteConsoleOutputAttribute\")\n\tproc_set_console_cursor_info          = kernel32.NewProc(\"SetConsoleCursorInfo\")\n\tproc_set_console_cursor_position      = kernel32.NewProc(\"SetConsoleCursorPosition\")\n\tproc_get_console_cursor_info          = kernel32.NewProc(\"GetConsoleCursorInfo\")\n\tproc_read_console_input               = kernel32.NewProc(\"ReadConsoleInputW\")\n\tproc_get_console_mode                 = kernel32.NewProc(\"GetConsoleMode\")\n\tproc_set_console_mode                 = kernel32.NewProc(\"SetConsoleMode\")\n\tproc_fill_console_output_character    = kernel32.NewProc(\"FillConsoleOutputCharacterW\")\n\tproc_fill_console_output_attribute    = kernel32.NewProc(\"FillConsoleOutputAttribute\")\n\tproc_create_event                     = kernel32.NewProc(\"CreateEventW\")\n\tproc_wait_for_multiple_objects        = kernel32.NewProc(\"WaitForMultipleObjects\")\n\tproc_set_event                        = kernel32.NewProc(\"SetEvent\")\n\tproc_get_current_console_font         = kernel32.NewProc(\"GetCurrentConsoleFont\")\n\tget_system_metrics                    = moduser32.NewProc(\"GetSystemMetrics\")\n)\n\nfunc set_console_active_screen_buffer(h syscall.Handle) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_set_console_active_screen_buffer.Addr(),\n\t\t1, uintptr(h), 0, 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc set_console_screen_buffer_size(h syscall.Handle, size coord) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_set_console_screen_buffer_size.Addr(),\n\t\t2, uintptr(h), size.uintptr(), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc set_console_window_info(h syscall.Handle, window *small_rect) (err error) {\n\tvar absolute uint32\n\tabsolute = 1\n\tr0, _, e1 := syscall.Syscall(proc_set_console_window_info.Addr(),\n\t\t3, uintptr(h), uintptr(absolute), window.uintptr())\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc create_console_screen_buffer() (h syscall.Handle, err error) {\n\tr0, _, e1 := syscall.Syscall6(proc_create_console_screen_buffer.Addr(),\n\t\t5, uintptr(generic_read|generic_write), 0, 0, console_textmode_buffer, 0, 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn syscall.Handle(r0), err\n}\n\nfunc get_console_screen_buffer_info(h syscall.Handle, info *console_screen_buffer_info) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_get_console_screen_buffer_info.Addr(),\n\t\t2, uintptr(h), uintptr(unsafe.Pointer(info)), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc write_console_output(h syscall.Handle, chars []char_info, dst small_rect) (err error) {\n\ttmp_coord = coord{dst.right - dst.left + 1, dst.bottom - dst.top + 1}\n\ttmp_rect = dst\n\tr0, _, e1 := syscall.Syscall6(proc_write_console_output.Addr(),\n\t\t5, uintptr(h), uintptr(unsafe.Pointer(&chars[0])), tmp_coord.uintptr(),\n\t\ttmp_coord0.uintptr(), uintptr(unsafe.Pointer(&tmp_rect)), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc write_console_output_character(h syscall.Handle, chars []wchar, pos coord) (err error) {\n\tr0, _, e1 := syscall.Syscall6(proc_write_console_output_character.Addr(),\n\t\t5, uintptr(h), uintptr(unsafe.Pointer(&chars[0])), uintptr(len(chars)),\n\t\tpos.uintptr(), uintptr(unsafe.Pointer(&tmp_arg)), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc write_console_output_attribute(h syscall.Handle, attrs []word, pos coord) (err error) {\n\tr0, _, e1 := syscall.Syscall6(proc_write_console_output_attribute.Addr(),\n\t\t5, uintptr(h), uintptr(unsafe.Pointer(&attrs[0])), uintptr(len(attrs)),\n\t\tpos.uintptr(), uintptr(unsafe.Pointer(&tmp_arg)), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc set_console_cursor_info(h syscall.Handle, info *console_cursor_info) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_set_console_cursor_info.Addr(),\n\t\t2, uintptr(h), uintptr(unsafe.Pointer(info)), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc get_console_cursor_info(h syscall.Handle, info *console_cursor_info) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_get_console_cursor_info.Addr(),\n\t\t2, uintptr(h), uintptr(unsafe.Pointer(info)), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc set_console_cursor_position(h syscall.Handle, pos coord) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_set_console_cursor_position.Addr(),\n\t\t2, uintptr(h), pos.uintptr(), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc read_console_input(h syscall.Handle, record *input_record) (err error) {\n\tr0, _, e1 := syscall.Syscall6(proc_read_console_input.Addr(),\n\t\t4, uintptr(h), uintptr(unsafe.Pointer(record)), 1, uintptr(unsafe.Pointer(&tmp_arg)), 0, 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc get_console_mode(h syscall.Handle, mode *dword) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_get_console_mode.Addr(),\n\t\t2, uintptr(h), uintptr(unsafe.Pointer(mode)), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc set_console_mode(h syscall.Handle, mode dword) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_set_console_mode.Addr(),\n\t\t2, uintptr(h), uintptr(mode), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc fill_console_output_character(h syscall.Handle, char wchar, n int) (err error) {\n\ttmp_coord = coord{0, 0}\n\tr0, _, e1 := syscall.Syscall6(proc_fill_console_output_character.Addr(),\n\t\t5, uintptr(h), uintptr(char), uintptr(n), tmp_coord.uintptr(),\n\t\tuintptr(unsafe.Pointer(&tmp_arg)), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc fill_console_output_attribute(h syscall.Handle, attr word, n int) (err error) {\n\ttmp_coord = coord{0, 0}\n\tr0, _, e1 := syscall.Syscall6(proc_fill_console_output_attribute.Addr(),\n\t\t5, uintptr(h), uintptr(attr), uintptr(n), tmp_coord.uintptr(),\n\t\tuintptr(unsafe.Pointer(&tmp_arg)), 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc create_event() (out syscall.Handle, err error) {\n\tr0, _, e1 := syscall.Syscall6(proc_create_event.Addr(),\n\t\t4, 0, 0, 0, 0, 0, 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn syscall.Handle(r0), err\n}\n\nfunc wait_for_multiple_objects(objects []syscall.Handle) (err error) {\n\tr0, _, e1 := syscall.Syscall6(proc_wait_for_multiple_objects.Addr(),\n\t\t4, uintptr(len(objects)), uintptr(unsafe.Pointer(&objects[0])),\n\t\t0, 0xFFFFFFFF, 0, 0)\n\tif uint32(r0) == 0xFFFFFFFF {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc set_event(ev syscall.Handle) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_set_event.Addr(),\n\t\t1, uintptr(ev), 0, 0)\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\nfunc get_current_console_font(h syscall.Handle, info *console_font_info) (err error) {\n\tr0, _, e1 := syscall.Syscall(proc_get_current_console_font.Addr(),\n\t\t3, uintptr(h), 0, uintptr(unsafe.Pointer(info)))\n\tif int(r0) == 0 {\n\t\tif e1 != 0 {\n\t\t\terr = error(e1)\n\t\t} else {\n\t\t\terr = syscall.EINVAL\n\t\t}\n\t}\n\treturn\n}\n\ntype diff_msg struct {\n\tpos   short\n\tlines short\n\tchars []char_info\n}\n\ntype input_event struct {\n\tevent Event\n\terr   error\n}\n\nvar (\n\torig_cursor_info console_cursor_info\n\torig_size        coord\n\torig_window      small_rect\n\torig_mode        dword\n\torig_screen      syscall.Handle\n\tback_buffer      cellbuf\n\tfront_buffer     cellbuf\n\tterm_size        coord\n\tinput_mode       = InputEsc\n\tcursor_x         = cursor_hidden\n\tcursor_y         = cursor_hidden\n\tforeground       = ColorDefault\n\tbackground       = ColorDefault\n\tin               syscall.Handle\n\tout              syscall.Handle\n\tinterrupt        syscall.Handle\n\tcharbuf          []char_info\n\tdiffbuf          []diff_msg\n\tbeg_x            = -1\n\tbeg_y            = -1\n\tbeg_i            = -1\n\tinput_comm       = make(chan Event)\n\tinterrupt_comm   = make(chan struct{})\n\tcancel_comm      = make(chan bool, 1)\n\tcancel_done_comm = make(chan bool)\n\talt_mode_esc     = false\n\n\t// these ones just to prevent heap allocs at all costs\n\ttmp_info   console_screen_buffer_info\n\ttmp_arg    dword\n\ttmp_coord0 = coord{0, 0}\n\ttmp_coord  = coord{0, 0}\n\ttmp_rect   = small_rect{0, 0, 0, 0}\n\ttmp_finfo  console_font_info\n)\n\nfunc get_cursor_position(out syscall.Handle) coord {\n\terr := get_console_screen_buffer_info(out, &tmp_info)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn tmp_info.cursor_position\n}\n\nfunc get_term_size(out syscall.Handle) (coord, small_rect) {\n\terr := get_console_screen_buffer_info(out, &tmp_info)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn tmp_info.size, tmp_info.window\n}\n\nfunc get_win_min_size(out syscall.Handle) coord {\n\tx, _, err := get_system_metrics.Call(SM_CXMIN)\n\ty, _, err := get_system_metrics.Call(SM_CYMIN)\n\n\tif x == 0 || y == 0 {\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\terr1 := get_current_console_font(out, &tmp_finfo)\n\tif err1 != nil {\n\t\tpanic(err1)\n\t}\n\n\treturn coord{\n\t\tx: short(math.Ceil(float64(x) / float64(tmp_finfo.font_size.x))),\n\t\ty: short(math.Ceil(float64(y) / float64(tmp_finfo.font_size.y))),\n\t}\n}\n\nfunc get_win_size(out syscall.Handle) coord {\n\terr := get_console_screen_buffer_info(out, &tmp_info)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmin_size := get_win_min_size(out)\n\n\tsize := coord{\n\t\tx: tmp_info.window.right - tmp_info.window.left + 1,\n\t\ty: tmp_info.window.bottom - tmp_info.window.top + 1,\n\t}\n\n\tif size.x < min_size.x {\n\t\tsize.x = min_size.x\n\t}\n\n\tif size.y < min_size.y {\n\t\tsize.y = min_size.y\n\t}\n\n\treturn size\n}\n\nfunc fix_win_size(out syscall.Handle, size coord) (err error) {\n\twindow := small_rect{}\n\twindow.top = 0\n\twindow.bottom = size.y - 1\n\twindow.left = 0\n\twindow.right = size.x - 1\n\treturn set_console_window_info(out, &window)\n}\n\nfunc update_size_maybe() {\n\tsize := get_win_size(out)\n\tif size.x != term_size.x || size.y != term_size.y {\n\t\tset_console_screen_buffer_size(out, size)\n\t\tfix_win_size(out, size)\n\t\tterm_size = size\n\t\tback_buffer.resize(int(size.x), int(size.y))\n\t\tfront_buffer.resize(int(size.x), int(size.y))\n\t\tfront_buffer.clear()\n\t\tclear()\n\n\t\tarea := int(size.x) * int(size.y)\n\t\tif cap(charbuf) < area {\n\t\t\tcharbuf = make([]char_info, 0, area)\n\t\t}\n\t}\n}\n\nvar color_table_bg = []word{\n\t0, // default (black)\n\t0, // black\n\tbackground_red,\n\tbackground_green,\n\tbackground_red | background_green, // yellow\n\tbackground_blue,\n\tbackground_red | background_blue,   // magenta\n\tbackground_green | background_blue, // cyan\n\tbackground_red | background_blue | background_green, // white\n}\n\nvar color_table_fg = []word{\n\tforeground_red | foreground_blue | foreground_green, // default (white)\n\t0,\n\tforeground_red,\n\tforeground_green,\n\tforeground_red | foreground_green, // yellow\n\tforeground_blue,\n\tforeground_red | foreground_blue,   // magenta\n\tforeground_green | foreground_blue, // cyan\n\tforeground_red | foreground_blue | foreground_green, // white\n}\n\nconst (\n\treplacement_char = '\\uFFFD'\n\tmax_rune         = '\\U0010FFFF'\n\tsurr1            = 0xd800\n\tsurr2            = 0xdc00\n\tsurr3            = 0xe000\n\tsurr_self        = 0x10000\n)\n\nfunc append_diff_line(y int) int {\n\tn := 0\n\tfor x := 0; x < front_buffer.width; {\n\t\tcell_offset := y*front_buffer.width + x\n\t\tback := &back_buffer.cells[cell_offset]\n\t\tfront := &front_buffer.cells[cell_offset]\n\t\tattr, char := cell_to_char_info(*back)\n\t\tcharbuf = append(charbuf, char_info{attr: attr, char: char[0]})\n\t\t*front = *back\n\t\tn++\n\t\tw := runewidth.RuneWidth(back.Ch)\n\t\tif w == 0 || w == 2 && runewidth.IsAmbiguousWidth(back.Ch) {\n\t\t\tw = 1\n\t\t}\n\t\tx += w\n\t\t// If not CJK, fill trailing space with whitespace\n\t\tif !is_cjk && w == 2 {\n\t\t\tcharbuf = append(charbuf, char_info{attr: attr, char: ' '})\n\t\t}\n\t}\n\treturn n\n}\n\n// compares 'back_buffer' with 'front_buffer' and prepares all changes in the form of\n// 'diff_msg's in the 'diff_buf'\nfunc prepare_diff_messages() {\n\t// clear buffers\n\tdiffbuf = diffbuf[:0]\n\tcharbuf = charbuf[:0]\n\n\tvar diff diff_msg\n\tgbeg := 0\n\tfor y := 0; y < front_buffer.height; y++ {\n\t\tsame := true\n\t\tline_offset := y * front_buffer.width\n\t\tfor x := 0; x < front_buffer.width; x++ {\n\t\t\tcell_offset := line_offset + x\n\t\t\tback := &back_buffer.cells[cell_offset]\n\t\t\tfront := &front_buffer.cells[cell_offset]\n\t\t\tif *back != *front {\n\t\t\t\tsame = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif same && diff.lines > 0 {\n\t\t\tdiffbuf = append(diffbuf, diff)\n\t\t\tdiff = diff_msg{}\n\t\t}\n\t\tif !same {\n\t\t\tbeg := len(charbuf)\n\t\t\tend := beg + append_diff_line(y)\n\t\t\tif diff.lines == 0 {\n\t\t\t\tdiff.pos = short(y)\n\t\t\t\tgbeg = beg\n\t\t\t}\n\t\t\tdiff.lines++\n\t\t\tdiff.chars = charbuf[gbeg:end]\n\t\t}\n\t}\n\tif diff.lines > 0 {\n\t\tdiffbuf = append(diffbuf, diff)\n\t\tdiff = diff_msg{}\n\t}\n}\n\nfunc get_ct(table []word, idx int) word {\n\tidx = idx & 0x0F\n\tif idx >= len(table) {\n\t\tidx = len(table) - 1\n\t}\n\treturn table[idx]\n}\n\nfunc cell_to_char_info(c Cell) (attr word, wc [2]wchar) {\n\tattr = get_ct(color_table_fg, int(c.Fg)) | get_ct(color_table_bg, int(c.Bg))\n\tif c.Fg&AttrReverse|c.Bg&AttrReverse != 0 {\n\t\tattr = (attr&0xF0)>>4 | (attr&0x0F)<<4\n\t}\n\tif c.Fg&AttrBold != 0 {\n\t\tattr |= foreground_intensity\n\t}\n\tif c.Bg&AttrBold != 0 {\n\t\tattr |= background_intensity\n\t}\n\n\tr0, r1 := utf16.EncodeRune(c.Ch)\n\tif r0 == 0xFFFD {\n\t\twc[0] = wchar(c.Ch)\n\t\twc[1] = ' '\n\t} else {\n\t\twc[0] = wchar(r0)\n\t\twc[1] = wchar(r1)\n\t}\n\treturn\n}\n\nfunc move_cursor(x, y int) {\n\terr := set_console_cursor_position(out, coord{short(x), short(y)})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc show_cursor(visible bool) {\n\tvar v int32\n\tif visible {\n\t\tv = 1\n\t}\n\n\tvar info console_cursor_info\n\tinfo.size = 100\n\tinfo.visible = v\n\terr := set_console_cursor_info(out, &info)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc clear() {\n\tvar err error\n\tattr, char := cell_to_char_info(Cell{\n\t\t' ',\n\t\tforeground,\n\t\tbackground,\n\t})\n\n\tarea := int(term_size.x) * int(term_size.y)\n\terr = fill_console_output_attribute(out, attr, area)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = fill_console_output_character(out, char[0], area)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif !is_cursor_hidden(cursor_x, cursor_y) {\n\t\tmove_cursor(cursor_x, cursor_y)\n\t}\n}\n\nfunc key_event_record_to_event(r *key_event_record) (Event, bool) {\n\tif r.key_down == 0 {\n\t\treturn Event{}, false\n\t}\n\n\te := Event{Type: EventKey}\n\tif input_mode&InputAlt != 0 {\n\t\tif alt_mode_esc {\n\t\t\te.Mod = ModAlt\n\t\t\talt_mode_esc = false\n\t\t}\n\t\tif r.control_key_state&(left_alt_pressed|right_alt_pressed) != 0 {\n\t\t\te.Mod = ModAlt\n\t\t}\n\t}\n\n\tctrlpressed := r.control_key_state&(left_ctrl_pressed|right_ctrl_pressed) != 0\n\n\tif r.virtual_key_code >= vk_f1 && r.virtual_key_code <= vk_f12 {\n\t\tswitch r.virtual_key_code {\n\t\tcase vk_f1:\n\t\t\te.Key = KeyF1\n\t\tcase vk_f2:\n\t\t\te.Key = KeyF2\n\t\tcase vk_f3:\n\t\t\te.Key = KeyF3\n\t\tcase vk_f4:\n\t\t\te.Key = KeyF4\n\t\tcase vk_f5:\n\t\t\te.Key = KeyF5\n\t\tcase vk_f6:\n\t\t\te.Key = KeyF6\n\t\tcase vk_f7:\n\t\t\te.Key = KeyF7\n\t\tcase vk_f8:\n\t\t\te.Key = KeyF8\n\t\tcase vk_f9:\n\t\t\te.Key = KeyF9\n\t\tcase vk_f10:\n\t\t\te.Key = KeyF10\n\t\tcase vk_f11:\n\t\t\te.Key = KeyF11\n\t\tcase vk_f12:\n\t\t\te.Key = KeyF12\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\n\t\treturn e, true\n\t}\n\n\tif r.virtual_key_code <= vk_delete {\n\t\tswitch r.virtual_key_code {\n\t\tcase vk_insert:\n\t\t\te.Key = KeyInsert\n\t\tcase vk_delete:\n\t\t\te.Key = KeyDelete\n\t\tcase vk_home:\n\t\t\te.Key = KeyHome\n\t\tcase vk_end:\n\t\t\te.Key = KeyEnd\n\t\tcase vk_pgup:\n\t\t\te.Key = KeyPgup\n\t\tcase vk_pgdn:\n\t\t\te.Key = KeyPgdn\n\t\tcase vk_arrow_up:\n\t\t\te.Key = KeyArrowUp\n\t\tcase vk_arrow_down:\n\t\t\te.Key = KeyArrowDown\n\t\tcase vk_arrow_left:\n\t\t\te.Key = KeyArrowLeft\n\t\tcase vk_arrow_right:\n\t\t\te.Key = KeyArrowRight\n\t\tcase vk_backspace:\n\t\t\tif ctrlpressed {\n\t\t\t\te.Key = KeyBackspace2\n\t\t\t} else {\n\t\t\t\te.Key = KeyBackspace\n\t\t\t}\n\t\tcase vk_tab:\n\t\t\te.Key = KeyTab\n\t\tcase vk_enter:\n\t\t\tif ctrlpressed {\n\t\t\t\te.Key = KeyCtrlJ\n\t\t\t} else {\n\t\t\t\te.Key = KeyEnter\n\t\t\t}\n\t\tcase vk_esc:\n\t\t\tswitch {\n\t\t\tcase input_mode&InputEsc != 0:\n\t\t\t\te.Key = KeyEsc\n\t\t\tcase input_mode&InputAlt != 0:\n\t\t\t\talt_mode_esc = true\n\t\t\t\treturn Event{}, false\n\t\t\t}\n\t\tcase vk_space:\n\t\t\tif ctrlpressed {\n\t\t\t\t// manual return here, because KeyCtrlSpace is zero\n\t\t\t\te.Key = KeyCtrlSpace\n\t\t\t\treturn e, true\n\t\t\t} else {\n\t\t\t\te.Key = KeySpace\n\t\t\t}\n\t\t}\n\n\t\tif e.Key != 0 {\n\t\t\treturn e, true\n\t\t}\n\t}\n\n\tif ctrlpressed {\n\t\tif Key(r.unicode_char) >= KeyCtrlA && Key(r.unicode_char) <= KeyCtrlRsqBracket {\n\t\t\te.Key = Key(r.unicode_char)\n\t\t\tif input_mode&InputAlt != 0 && e.Key == KeyEsc {\n\t\t\t\talt_mode_esc = true\n\t\t\t\treturn Event{}, false\n\t\t\t}\n\t\t\treturn e, true\n\t\t}\n\t\tswitch r.virtual_key_code {\n\t\tcase 192, 50:\n\t\t\t// manual return here, because KeyCtrl2 is zero\n\t\t\te.Key = KeyCtrl2\n\t\t\treturn e, true\n\t\tcase 51:\n\t\t\tif input_mode&InputAlt != 0 {\n\t\t\t\talt_mode_esc = true\n\t\t\t\treturn Event{}, false\n\t\t\t}\n\t\t\te.Key = KeyCtrl3\n\t\tcase 52:\n\t\t\te.Key = KeyCtrl4\n\t\tcase 53:\n\t\t\te.Key = KeyCtrl5\n\t\tcase 54:\n\t\t\te.Key = KeyCtrl6\n\t\tcase 189, 191, 55:\n\t\t\te.Key = KeyCtrl7\n\t\tcase 8, 56:\n\t\t\te.Key = KeyCtrl8\n\t\t}\n\n\t\tif e.Key != 0 {\n\t\t\treturn e, true\n\t\t}\n\t}\n\n\tif r.unicode_char != 0 {\n\t\te.Ch = rune(r.unicode_char)\n\t\treturn e, true\n\t}\n\n\treturn Event{}, false\n}\n\nfunc input_event_producer() {\n\tvar r input_record\n\tvar err error\n\tvar last_button Key\n\tvar last_button_pressed Key\n\tvar last_state = dword(0)\n\tvar last_x, last_y = -1, -1\n\thandles := []syscall.Handle{in, interrupt}\n\tfor {\n\t\terr = wait_for_multiple_objects(handles)\n\t\tif err != nil {\n\t\t\tinput_comm <- Event{Type: EventError, Err: err}\n\t\t}\n\n\t\tselect {\n\t\tcase <-cancel_comm:\n\t\t\tcancel_done_comm <- true\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\terr = read_console_input(in, &r)\n\t\tif err != nil {\n\t\t\tinput_comm <- Event{Type: EventError, Err: err}\n\t\t}\n\n\t\tswitch r.event_type {\n\t\tcase key_event:\n\t\t\tkr := (*key_event_record)(unsafe.Pointer(&r.event))\n\t\t\tev, ok := key_event_record_to_event(kr)\n\t\t\tif ok {\n\t\t\t\tfor i := 0; i < int(kr.repeat_count); i++ {\n\t\t\t\t\tinput_comm <- ev\n\t\t\t\t}\n\t\t\t}\n\t\tcase window_buffer_size_event:\n\t\t\tsr := *(*window_buffer_size_record)(unsafe.Pointer(&r.event))\n\t\t\tinput_comm <- Event{\n\t\t\t\tType:   EventResize,\n\t\t\t\tWidth:  int(sr.size.x),\n\t\t\t\tHeight: int(sr.size.y),\n\t\t\t}\n\t\tcase mouse_event:\n\t\t\tmr := *(*mouse_event_record)(unsafe.Pointer(&r.event))\n\t\t\tev := Event{Type: EventMouse}\n\t\t\tswitch mr.event_flags {\n\t\t\tcase 0, 2:\n\t\t\t\t// single or double click\n\t\t\t\tcur_state := mr.button_state\n\t\t\t\tswitch {\n\t\t\t\tcase last_state&mouse_lmb == 0 && cur_state&mouse_lmb != 0:\n\t\t\t\t\tlast_button = MouseLeft\n\t\t\t\t\tlast_button_pressed = last_button\n\t\t\t\tcase last_state&mouse_rmb == 0 && cur_state&mouse_rmb != 0:\n\t\t\t\t\tlast_button = MouseRight\n\t\t\t\t\tlast_button_pressed = last_button\n\t\t\t\tcase last_state&mouse_mmb == 0 && cur_state&mouse_mmb != 0:\n\t\t\t\t\tlast_button = MouseMiddle\n\t\t\t\t\tlast_button_pressed = last_button\n\t\t\t\tcase last_state&mouse_lmb != 0 && cur_state&mouse_lmb == 0:\n\t\t\t\t\tlast_button = MouseRelease\n\t\t\t\tcase last_state&mouse_rmb != 0 && cur_state&mouse_rmb == 0:\n\t\t\t\t\tlast_button = MouseRelease\n\t\t\t\tcase last_state&mouse_mmb != 0 && cur_state&mouse_mmb == 0:\n\t\t\t\t\tlast_button = MouseRelease\n\t\t\t\tdefault:\n\t\t\t\t\tlast_state = cur_state\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tlast_state = cur_state\n\t\t\t\tev.Key = last_button\n\t\t\t\tlast_x, last_y = int(mr.mouse_pos.x), int(mr.mouse_pos.y)\n\t\t\t\tev.MouseX = last_x\n\t\t\t\tev.MouseY = last_y\n\t\t\tcase 1:\n\t\t\t\t// mouse motion\n\t\t\t\tx, y := int(mr.mouse_pos.x), int(mr.mouse_pos.y)\n\t\t\t\tif last_state != 0 && (last_x != x || last_y != y) {\n\t\t\t\t\tev.Key = last_button_pressed\n\t\t\t\t\tev.Mod = ModMotion\n\t\t\t\t\tev.MouseX = x\n\t\t\t\t\tev.MouseY = y\n\t\t\t\t\tlast_x, last_y = x, y\n\t\t\t\t} else {\n\t\t\t\t\tev.Type = EventNone\n\t\t\t\t}\n\t\t\tcase 4:\n\t\t\t\t// mouse wheel\n\t\t\t\tn := int16(mr.button_state >> 16)\n\t\t\t\tif n > 0 {\n\t\t\t\t\tev.Key = MouseWheelUp\n\t\t\t\t} else {\n\t\t\t\t\tev.Key = MouseWheelDown\n\t\t\t\t}\n\t\t\t\tlast_x, last_y = int(mr.mouse_pos.x), int(mr.mouse_pos.y)\n\t\t\t\tev.MouseX = last_x\n\t\t\t\tev.MouseY = last_y\n\t\t\tdefault:\n\t\t\t\tev.Type = EventNone\n\t\t\t}\n\t\t\tif ev.Type != EventNone {\n\t\t\t\tinput_comm <- ev\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "terminfo.go",
          "type": "blob",
          "size": 5.8603515625,
          "content": "// +build !windows\n// This file contains a simple and incomplete implementation of the terminfo\n// database. Information was taken from the ncurses manpages term(5) and\n// terminfo(5). Currently, only the string capabilities for special keys and for\n// functions without parameters are actually used. Colors are still done with\n// ANSI escape sequences. Other special features that are not (yet?) supported\n// are reading from ~/.terminfo, the TERMINFO_DIRS variable, Berkeley database\n// format and extended capabilities.\n\npackage termbox\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\nconst (\n\tti_magic         = 0432\n\tti_header_length = 12\n\tti_mouse_enter   = \"\\x1b[?1000h\\x1b[?1002h\\x1b[?1015h\\x1b[?1006h\"\n\tti_mouse_leave   = \"\\x1b[?1006l\\x1b[?1015l\\x1b[?1002l\\x1b[?1000l\"\n)\n\nfunc load_terminfo() ([]byte, error) {\n\tvar data []byte\n\tvar err error\n\n\tterm := os.Getenv(\"TERM\")\n\tif term == \"\" {\n\t\treturn nil, fmt.Errorf(\"termbox: TERM not set\")\n\t}\n\n\t// The following behaviour follows the one described in terminfo(5) as\n\t// distributed by ncurses.\n\n\tterminfo := os.Getenv(\"TERMINFO\")\n\tif terminfo != \"\" {\n\t\t// if TERMINFO is set, no other directory should be searched\n\t\treturn ti_try_path(terminfo)\n\t}\n\n\t// next, consider ~/.terminfo\n\thome := os.Getenv(\"HOME\")\n\tif home != \"\" {\n\t\tdata, err = ti_try_path(home + \"/.terminfo\")\n\t\tif err == nil {\n\t\t\treturn data, nil\n\t\t}\n\t}\n\n\t// next, TERMINFO_DIRS\n\tdirs := os.Getenv(\"TERMINFO_DIRS\")\n\tif dirs != \"\" {\n\t\tfor _, dir := range strings.Split(dirs, \":\") {\n\t\t\tif dir == \"\" {\n\t\t\t\t// \"\" -> \"/usr/share/terminfo\"\n\t\t\t\tdir = \"/usr/share/terminfo\"\n\t\t\t}\n\t\t\tdata, err = ti_try_path(dir)\n\t\t\tif err == nil {\n\t\t\t\treturn data, nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// next, /lib/terminfo\n\tdata, err = ti_try_path(\"/lib/terminfo\")\n\tif err == nil {\n\t\treturn data, nil\n\t}\n\n\t// fall back to /usr/share/terminfo\n\treturn ti_try_path(\"/usr/share/terminfo\")\n}\n\nfunc ti_try_path(path string) (data []byte, err error) {\n\t// load_terminfo already made sure it is set\n\tterm := os.Getenv(\"TERM\")\n\n\t// first try, the typical *nix path\n\tterminfo := path + \"/\" + term[0:1] + \"/\" + term\n\tdata, err = ioutil.ReadFile(terminfo)\n\tif err == nil {\n\t\treturn\n\t}\n\n\t// fallback to darwin specific dirs structure\n\tterminfo = path + \"/\" + hex.EncodeToString([]byte(term[:1])) + \"/\" + term\n\tdata, err = ioutil.ReadFile(terminfo)\n\treturn\n}\n\nfunc setup_term_builtin() error {\n\tname := os.Getenv(\"TERM\")\n\tif name == \"\" {\n\t\treturn errors.New(\"termbox: TERM environment variable not set\")\n\t}\n\n\tfor _, t := range terms {\n\t\tif t.name == name {\n\t\t\tkeys = t.keys\n\t\t\tfuncs = t.funcs\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tcompat_table := []struct {\n\t\tpartial string\n\t\tkeys    []string\n\t\tfuncs   []string\n\t}{\n\t\t{\"xterm\", xterm_keys, xterm_funcs},\n\t\t{\"rxvt\", rxvt_unicode_keys, rxvt_unicode_funcs},\n\t\t{\"linux\", linux_keys, linux_funcs},\n\t\t{\"Eterm\", eterm_keys, eterm_funcs},\n\t\t{\"screen\", screen_keys, screen_funcs},\n\t\t// let's assume that 'cygwin' is xterm compatible\n\t\t{\"cygwin\", xterm_keys, xterm_funcs},\n\t\t{\"st\", xterm_keys, xterm_funcs},\n\t}\n\n\t// try compatibility variants\n\tfor _, it := range compat_table {\n\t\tif strings.Contains(name, it.partial) {\n\t\t\tkeys = it.keys\n\t\t\tfuncs = it.funcs\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errors.New(\"termbox: unsupported terminal\")\n}\n\nfunc setup_term() (err error) {\n\tvar data []byte\n\tvar header [6]int16\n\tvar str_offset, table_offset int16\n\n\tdata, err = load_terminfo()\n\tif err != nil {\n\t\treturn setup_term_builtin()\n\t}\n\n\trd := bytes.NewReader(data)\n\t// 0: magic number, 1: size of names section, 2: size of boolean section, 3:\n\t// size of numbers section (in integers), 4: size of the strings section (in\n\t// integers), 5: size of the string table\n\n\terr = binary.Read(rd, binary.LittleEndian, header[:])\n\tif err != nil {\n\t\treturn\n\t}\n\n\tnumber_sec_len := int16(2)\n\tif header[0] == 542 { // doc says it should be octal 0542, but what I see it terminfo files is 542, learn to program please... thank you..\n\t\tnumber_sec_len = 4\n\t}\n\n\tif (header[1]+header[2])%2 != 0 {\n\t\t// old quirk to align everything on word boundaries\n\t\theader[2] += 1\n\t}\n\tstr_offset = ti_header_length + header[1] + header[2] + number_sec_len*header[3]\n\ttable_offset = str_offset + 2*header[4]\n\n\tkeys = make([]string, 0xFFFF-key_min)\n\tfor i, _ := range keys {\n\t\tkeys[i], err = ti_read_string(rd, str_offset+2*ti_keys[i], table_offset)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tfuncs = make([]string, t_max_funcs)\n\t// the last two entries are reserved for mouse. because the table offset is\n\t// not there, the two entries have to fill in manually\n\tfor i, _ := range funcs[:len(funcs)-2] {\n\t\tfuncs[i], err = ti_read_string(rd, str_offset+2*ti_funcs[i], table_offset)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tfuncs[t_max_funcs-2] = ti_mouse_enter\n\tfuncs[t_max_funcs-1] = ti_mouse_leave\n\treturn nil\n}\n\nfunc ti_read_string(rd *bytes.Reader, str_off, table int16) (string, error) {\n\tvar off int16\n\n\t_, err := rd.Seek(int64(str_off), 0)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\terr = binary.Read(rd, binary.LittleEndian, &off)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t_, err = rd.Seek(int64(table+off), 0)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tvar bs []byte\n\tfor {\n\t\tb, err := rd.ReadByte()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif b == byte(0x00) {\n\t\t\tbreak\n\t\t}\n\t\tbs = append(bs, b)\n\t}\n\treturn string(bs), nil\n}\n\n// \"Maps\" the function constants from termbox.go to the number of the respective\n// string capability in the terminfo file. Taken from (ncurses) term.h.\nvar ti_funcs = []int16{\n\t28,  // enter ca\n\t40,  // exit ca\n\t16,  // show cursor\n\t13,  // hide cursor\n\t5,   // clear screen\n\t39,  // sgr0\n\t36,  // underline\n\t27,  // bold\n\t32,  // hidden\n\t26,  // blink\n\t30,  // dim\n\t311, // cursive\n\t34,  // reverse\n\t89,  // enter keypad (\"keypad_xmit\")\n\t88,  // exit keypad (\"keypad_local\")\n}\n\n// Same as above for the special keys.\nvar ti_keys = []int16{\n\t66, 68 /* apparently not a typo; 67 is F10 for whatever reason */, 69, 70,\n\t71, 72, 73, 74, 75, 67, 216, 217, 77, 59, 76, 164, 82, 81, 87, 61, 79, 83,\n}\n"
        },
        {
          "name": "terminfo_builtin.go",
          "type": "blob",
          "size": 5.1044921875,
          "content": "// +build !windows\n\npackage termbox\n\n// Eterm\nvar eterm_keys = []string{\n\t\"\\x1b[11~\", \"\\x1b[12~\", \"\\x1b[13~\", \"\\x1b[14~\", \"\\x1b[15~\", \"\\x1b[17~\", \"\\x1b[18~\", \"\\x1b[19~\", \"\\x1b[20~\", \"\\x1b[21~\", \"\\x1b[23~\", \"\\x1b[24~\", \"\\x1b[2~\", \"\\x1b[3~\", \"\\x1b[7~\", \"\\x1b[8~\", \"\\x1b[5~\", \"\\x1b[6~\", \"\\x1b[A\", \"\\x1b[B\", \"\\x1b[D\", \"\\x1b[C\",\n}\nvar eterm_funcs = []string{\n\tt_enter_ca:     \"\\x1b7\\x1b[?47h\",\n\tt_exit_ca:      \"\\x1b[2J\\x1b[?47l\\x1b8\",\n\tt_show_cursor:  \"\\x1b[?25h\",\n\tt_hide_cursor:  \"\\x1b[?25l\",\n\tt_clear_screen: \"\\x1b[H\\x1b[2J\",\n\tt_sgr0:         \"\\x1b[m\\x0f\",\n\tt_underline:    \"\\x1b[4m\",\n\tt_bold:         \"\\x1b[1m\",\n\tt_hidden:       \"\",\n\tt_blink:        \"\\x1b[5m\",\n\tt_dim:          \"\",\n\tt_cursive:      \"\",\n\tt_reverse:      \"\\x1b[7m\",\n\tt_enter_keypad: \"\",\n\tt_exit_keypad:  \"\",\n\tt_enter_mouse:  \"\",\n\tt_exit_mouse:   \"\",\n}\n\n// screen\nvar screen_keys = []string{\n\t\"\\x1bOP\", \"\\x1bOQ\", \"\\x1bOR\", \"\\x1bOS\", \"\\x1b[15~\", \"\\x1b[17~\", \"\\x1b[18~\", \"\\x1b[19~\", \"\\x1b[20~\", \"\\x1b[21~\", \"\\x1b[23~\", \"\\x1b[24~\", \"\\x1b[2~\", \"\\x1b[3~\", \"\\x1b[1~\", \"\\x1b[4~\", \"\\x1b[5~\", \"\\x1b[6~\", \"\\x1bOA\", \"\\x1bOB\", \"\\x1bOD\", \"\\x1bOC\",\n}\nvar screen_funcs = []string{\n\tt_enter_ca:     \"\\x1b[?1049h\",\n\tt_exit_ca:      \"\\x1b[?1049l\",\n\tt_show_cursor:  \"\\x1b[34h\\x1b[?25h\",\n\tt_hide_cursor:  \"\\x1b[?25l\",\n\tt_clear_screen: \"\\x1b[H\\x1b[J\",\n\tt_sgr0:         \"\\x1b[m\\x0f\",\n\tt_underline:    \"\\x1b[4m\",\n\tt_bold:         \"\\x1b[1m\",\n\tt_hidden:       \"\",\n\tt_blink:        \"\\x1b[5m\",\n\tt_dim:          \"\",\n\tt_cursive:      \"\",\n\tt_reverse:      \"\\x1b[7m\",\n\tt_enter_keypad: \"\\x1b[?1h\\x1b=\",\n\tt_exit_keypad:  \"\\x1b[?1l\\x1b>\",\n\tt_enter_mouse:  ti_mouse_enter,\n\tt_exit_mouse:   ti_mouse_leave,\n}\n\n// xterm\nvar xterm_keys = []string{\n\t\"\\x1bOP\", \"\\x1bOQ\", \"\\x1bOR\", \"\\x1bOS\", \"\\x1b[15~\", \"\\x1b[17~\", \"\\x1b[18~\", \"\\x1b[19~\", \"\\x1b[20~\", \"\\x1b[21~\", \"\\x1b[23~\", \"\\x1b[24~\", \"\\x1b[2~\", \"\\x1b[3~\", \"\\x1bOH\", \"\\x1bOF\", \"\\x1b[5~\", \"\\x1b[6~\", \"\\x1bOA\", \"\\x1bOB\", \"\\x1bOD\", \"\\x1bOC\",\n}\nvar xterm_funcs = []string{\n\tt_enter_ca:     \"\\x1b[?1049h\",\n\tt_exit_ca:      \"\\x1b[?1049l\",\n\tt_show_cursor:  \"\\x1b[?12l\\x1b[?25h\",\n\tt_hide_cursor:  \"\\x1b[?25l\",\n\tt_clear_screen: \"\\x1b[H\\x1b[2J\",\n\tt_sgr0:         \"\\x1b(B\\x1b[m\",\n\tt_underline:    \"\\x1b[4m\",\n\tt_bold:         \"\\x1b[1m\",\n\tt_hidden:       \"\",\n\tt_blink:        \"\\x1b[5m\",\n\tt_dim:          \"\",\n\tt_cursive:      \"\",\n\tt_reverse:      \"\\x1b[7m\",\n\tt_enter_keypad: \"\\x1b[?1h\\x1b=\",\n\tt_exit_keypad:  \"\\x1b[?1l\\x1b>\",\n\tt_enter_mouse:  ti_mouse_enter,\n\tt_exit_mouse:   ti_mouse_leave,\n}\n\n// rxvt-unicode\nvar rxvt_unicode_keys = []string{\n\t\"\\x1b[11~\", \"\\x1b[12~\", \"\\x1b[13~\", \"\\x1b[14~\", \"\\x1b[15~\", \"\\x1b[17~\", \"\\x1b[18~\", \"\\x1b[19~\", \"\\x1b[20~\", \"\\x1b[21~\", \"\\x1b[23~\", \"\\x1b[24~\", \"\\x1b[2~\", \"\\x1b[3~\", \"\\x1b[7~\", \"\\x1b[8~\", \"\\x1b[5~\", \"\\x1b[6~\", \"\\x1b[A\", \"\\x1b[B\", \"\\x1b[D\", \"\\x1b[C\",\n}\nvar rxvt_unicode_funcs = []string{\n\tt_enter_ca:     \"\\x1b[?1049h\",\n\tt_exit_ca:      \"\\x1b[r\\x1b[?1049l\",\n\tt_show_cursor:  \"\\x1b[?25h\",\n\tt_hide_cursor:  \"\\x1b[?25l\",\n\tt_clear_screen: \"\\x1b[H\\x1b[2J\",\n\tt_sgr0:         \"\\x1b[m\\x1b(B\",\n\tt_underline:    \"\\x1b[4m\",\n\tt_bold:         \"\\x1b[1m\",\n\tt_hidden:       \"\",\n\tt_blink:        \"\\x1b[5m\",\n\tt_dim:          \"\",\n\tt_cursive:      \"\",\n\tt_reverse:      \"\\x1b[7m\",\n\tt_enter_keypad: \"\\x1b=\",\n\tt_exit_keypad:  \"\\x1b>\",\n\tt_enter_mouse:  ti_mouse_enter,\n\tt_exit_mouse:   ti_mouse_leave,\n}\n\n// linux\nvar linux_keys = []string{\n\t\"\\x1b[[A\", \"\\x1b[[B\", \"\\x1b[[C\", \"\\x1b[[D\", \"\\x1b[[E\", \"\\x1b[17~\", \"\\x1b[18~\", \"\\x1b[19~\", \"\\x1b[20~\", \"\\x1b[21~\", \"\\x1b[23~\", \"\\x1b[24~\", \"\\x1b[2~\", \"\\x1b[3~\", \"\\x1b[1~\", \"\\x1b[4~\", \"\\x1b[5~\", \"\\x1b[6~\", \"\\x1b[A\", \"\\x1b[B\", \"\\x1b[D\", \"\\x1b[C\",\n}\nvar linux_funcs = []string{\n\tt_enter_ca:     \"\",\n\tt_exit_ca:      \"\",\n\tt_show_cursor:  \"\\x1b[?25h\\x1b[?0c\",\n\tt_hide_cursor:  \"\\x1b[?25l\\x1b[?1c\",\n\tt_clear_screen: \"\\x1b[H\\x1b[J\",\n\tt_sgr0:         \"\\x1b[0;10m\",\n\tt_underline:    \"\\x1b[4m\",\n\tt_bold:         \"\\x1b[1m\",\n\tt_hidden:       \"\",\n\tt_blink:        \"\\x1b[5m\",\n\tt_dim:          \"\",\n\tt_cursive:      \"\",\n\tt_reverse:      \"\\x1b[7m\",\n\tt_enter_keypad: \"\",\n\tt_exit_keypad:  \"\",\n\tt_enter_mouse:  \"\",\n\tt_exit_mouse:   \"\",\n}\n\n// rxvt-256color\nvar rxvt_256color_keys = []string{\n\t\"\\x1b[11~\", \"\\x1b[12~\", \"\\x1b[13~\", \"\\x1b[14~\", \"\\x1b[15~\", \"\\x1b[17~\", \"\\x1b[18~\", \"\\x1b[19~\", \"\\x1b[20~\", \"\\x1b[21~\", \"\\x1b[23~\", \"\\x1b[24~\", \"\\x1b[2~\", \"\\x1b[3~\", \"\\x1b[7~\", \"\\x1b[8~\", \"\\x1b[5~\", \"\\x1b[6~\", \"\\x1b[A\", \"\\x1b[B\", \"\\x1b[D\", \"\\x1b[C\",\n}\nvar rxvt_256color_funcs = []string{\n\tt_enter_ca:     \"\\x1b7\\x1b[?47h\",\n\tt_exit_ca:      \"\\x1b[2J\\x1b[?47l\\x1b8\",\n\tt_show_cursor:  \"\\x1b[?25h\",\n\tt_hide_cursor:  \"\\x1b[?25l\",\n\tt_clear_screen: \"\\x1b[H\\x1b[2J\",\n\tt_sgr0:         \"\\x1b[m\\x0f\",\n\tt_underline:    \"\\x1b[4m\",\n\tt_bold:         \"\\x1b[1m\",\n\tt_hidden:       \"\",\n\tt_blink:        \"\\x1b[5m\",\n\tt_dim:          \"\",\n\tt_cursive:      \"\",\n\tt_reverse:      \"\\x1b[7m\",\n\tt_enter_keypad: \"\\x1b=\",\n\tt_exit_keypad:  \"\\x1b>\",\n\tt_enter_mouse:  ti_mouse_enter,\n\tt_exit_mouse:   ti_mouse_leave,\n}\n\nvar terms = []struct {\n\tname  string\n\tkeys  []string\n\tfuncs []string\n}{\n\t{\"Eterm\", eterm_keys, eterm_funcs},\n\t{\"screen\", screen_keys, screen_funcs},\n\t{\"xterm\", xterm_keys, xterm_funcs},\n\t{\"rxvt-unicode\", rxvt_unicode_keys, rxvt_unicode_funcs},\n\t{\"linux\", linux_keys, linux_funcs},\n\t{\"rxvt-256color\", rxvt_256color_keys, rxvt_256color_funcs},\n}\n"
        },
        {
          "name": "terminfo_builtin_test.go",
          "type": "blob",
          "size": 0.2890625,
          "content": "// +build !windows\n\npackage termbox\n\nimport \"testing\"\n\nfunc TestTerminfoTerms(t *testing.T) {\n\tfor _, term := range terms {\n\t\tt.Run(term.name, func(t *testing.T) {\n\t\t\tif len(term.funcs) != t_max_funcs {\n\t\t\t\tt.Errorf(\"want %d got %d terminfo entries\", t_max_funcs, len(term.funcs))\n\t\t\t}\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}