{
  "metadata": {
    "timestamp": 1736567242485,
    "page": 839,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gocelery/gocelery",
      "stars": 2391,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.294921875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n*.pyc\n\ncoverage.out\nvendor\n.vscode/"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2019 Sick Yoon\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1259765625,
          "content": ".PHONY: build\nbuild:\n\tgo install .\n\n.PHONY: lint\nlint:\n\tgolangci-lint run\n\n.PHONY: test\ntest:\n\tgo test -timeout 30s -v -cover .\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.373046875,
          "content": "# gocelery\n\nGo Client/Server for Celery Distributed Task Queue\n\n[![Build Status](https://github.com/gocelery/gocelery/workflows/Go/badge.svg)](https://github.com/gocelery/gocelery/workflows/Go/badge.svg)\n[![Coverage Status](https://coveralls.io/repos/github/gocelery/gocelery/badge.svg?branch=master)](https://coveralls.io/github/gocelery/gocelery?branch=master)\n[![Go Report Card](https://goreportcard.com/badge/github.com/gocelery/gocelery)](https://goreportcard.com/report/github.com/gocelery/gocelery)\n[![\"Open Issues\"](https://img.shields.io/github/issues-raw/gocelery/gocelery.svg)](https://github.com/gocelery/gocelery/issues)\n[![\"Latest Release\"](https://img.shields.io/github/release/gocelery/gocelery.svg)](https://github.com/gocelery/gocelery/releases/latest)\n[![GoDoc](https://godoc.org/github.com/gocelery/gocelery?status.svg)](https://godoc.org/github.com/gocelery/gocelery)\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/gocelery/gocelery/blob/master/LICENSE)\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fgocelery%2Fgocelery.svg?type=shield)](https://app.fossa.io/projects/git%2Bgithub.com%2Fgocelery%2Fgocelery?ref=badge_shield)\n\n## Why?\n\nHaving been involved in several projects migrating servers from Python to Go, I have realized Go can improve performance of existing python web applications.\nAs Celery distributed tasks are often used in such web applications, this library allows you to both implement celery workers and submit celery tasks in Go.\n\nYou can also use this library as pure go distributed task queue.\n\n## Go Celery Worker in Action\n\n![demo](https://raw.githubusercontent.com/gocelery/gocelery/master/demo.gif)\n\n## Supported Brokers/Backends\n\nNow supporting both Redis and AMQP!!\n\n* Redis (broker/backend)\n* AMQP (broker/backend) - does not allow concurrent use of channels\n\n## Celery Configuration\n\nCelery must be configured to use **json** instead of default **pickle** encoding.\nThis is because Go currently has no stable support for decoding pickle objects.\nPass below configuration parameters to use **json**.\n\nStarting from version 4.0, Celery uses message protocol version 2 as default value.\nGoCelery does not yet support message protocol version 2, so you must explicitly set `CELERY_TASK_PROTOCOL` to 1.\n\n```python\nCELERY_TASK_SERIALIZER='json',\nCELERY_ACCEPT_CONTENT=['json'],  # Ignore other content\nCELERY_RESULT_SERIALIZER='json',\nCELERY_ENABLE_UTC=True,\nCELERY_TASK_PROTOCOL=1,\n```\n\n## Example\n\n[GoCelery GoDoc](https://godoc.org/github.com/gocelery/gocelery) has good examples.<br/>\nAlso take a look at `example` directory for sample python code.\n\n### GoCelery Worker Example\n\nRun Celery Worker implemented in Go\n\n```go\n// create redis connection pool\nredisPool := &redis.Pool{\n  Dial: func() (redis.Conn, error) {\n\t\tc, err := redis.DialURL(\"redis://\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn c, err\n\t},\n}\n\n// initialize celery client\ncli, _ := gocelery.NewCeleryClient(\n\tgocelery.NewRedisBroker(redisPool),\n\t&gocelery.RedisCeleryBackend{Pool: redisPool},\n\t5, // number of workers\n)\n\n// task\nadd := func(a, b int) int {\n\treturn a + b\n}\n\n// register task\ncli.Register(\"worker.add\", add)\n\n// start workers (non-blocking call)\ncli.StartWorker()\n\n// wait for client request\ntime.Sleep(10 * time.Second)\n\n// stop workers gracefully (blocking call)\ncli.StopWorker()\n```\n\n### Python Client Example\n\nSubmit Task from Python Client\n\n```python\nfrom celery import Celery\n\napp = Celery('tasks',\n    broker='redis://localhost:6379',\n    backend='redis://localhost:6379'\n)\n\n@app.task\ndef add(x, y):\n    return x + y\n\nif __name__ == '__main__':\n    ar = add.apply_async((5456, 2878), serializer='json')\n    print(ar.get())\n```\n\n### Python Worker Example\n\nRun Celery Worker implemented in Python\n\n```python\nfrom celery import Celery\n\napp = Celery('tasks',\n    broker='redis://localhost:6379',\n    backend='redis://localhost:6379'\n)\n\n@app.task\ndef add(x, y):\n    return x + y\n```\n\n```bash\ncelery -A worker worker --loglevel=debug --without-heartbeat --without-mingle\n```\n\n### GoCelery Client Example\n\nSubmit Task from Go Client\n\n```go\n// create redis connection pool\nredisPool := &redis.Pool{\n  Dial: func() (redis.Conn, error) {\n\t\tc, err := redis.DialURL(\"redis://\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn c, err\n\t},\n}\n\n// initialize celery client\ncli, _ := gocelery.NewCeleryClient(\n\tgocelery.NewRedisBroker(redisPool),\n\t&gocelery.RedisCeleryBackend{Pool: redisPool},\n\t1,\n)\n\n// prepare arguments\ntaskName := \"worker.add\"\nargA := rand.Intn(10)\nargB := rand.Intn(10)\n\n// run task\nasyncResult, err := cli.Delay(taskName, argA, argB)\nif err != nil {\n\tpanic(err)\n}\n\n// get results from backend with timeout\nres, err := asyncResult.Get(10 * time.Second)\nif err != nil {\n\tpanic(err)\n}\n\nlog.Printf(\"result: %+v of type %+v\", res, reflect.TypeOf(res))\n```\n\n## Sample Celery Task Message\n\nCelery Message Protocol Version 1\n\n```javascript\n{\n    \"expires\": null,\n    \"utc\": true,\n    \"args\": [5456, 2878],\n    \"chord\": null,\n    \"callbacks\": null,\n    \"errbacks\": null,\n    \"taskset\": null,\n    \"id\": \"c8535050-68f1-4e18-9f32-f52f1aab6d9b\",\n    \"retries\": 0,\n    \"task\": \"worker.add\",\n    \"timelimit\": [null, null],\n    \"eta\": null,\n    \"kwargs\": {}\n}\n```\n\n## Projects\n\nPlease let us know if you use gocelery in your project!\n\n## Contributing\n\nYou are more than welcome to make any contributions.\nPlease create Pull Request for any changes.\n\n## LICENSE\n\nThe gocelery is offered under MIT license.\n"
        },
        {
          "name": "amqp.go",
          "type": "blob",
          "size": 0.564453125,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"log\"\n\n\t\"github.com/streadway/amqp\"\n)\n\n// deliveryAck acknowledges delivery message with retries on error\nfunc deliveryAck(delivery amqp.Delivery) {\n\tvar err error\n\tfor retryCount := 3; retryCount > 0; retryCount-- {\n\t\tif err = delivery.Ack(false); err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\tlog.Printf(\"amqp_backend: failed to acknowledge result message %+v: %+v\", delivery.MessageId, err)\n\t}\n}\n"
        },
        {
          "name": "amqp_backend.go",
          "type": "blob",
          "size": 3.08203125,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\n// AMQPCeleryBackend CeleryBackend for AMQP\ntype AMQPCeleryBackend struct {\n\t*amqp.Channel\n\tConnection *amqp.Connection\n\tHost       string\n}\n\n// NewAMQPCeleryBackend creates new AMQPCeleryBackend\nfunc NewAMQPCeleryBackend(host string) *AMQPCeleryBackend {\n\tbackend := NewAMQPCeleryBackendByConnAndChannel(NewAMQPConnection(host))\n\tbackend.Host = host\n\treturn backend\n}\n\n// NewAMQPCeleryBackendByConnAndChannel creates new AMQPCeleryBackend by AMQP connection and channel\nfunc NewAMQPCeleryBackendByConnAndChannel(conn *amqp.Connection, channel *amqp.Channel) *AMQPCeleryBackend {\n\tbackend := &AMQPCeleryBackend{\n\t\tChannel:    channel,\n\t\tConnection: conn,\n\t}\n\treturn backend\n}\n\n// Reconnect reconnects to AMQP server\nfunc (b *AMQPCeleryBackend) Reconnect() {\n\tb.Connection.Close()\n\tconn, channel := NewAMQPConnection(b.Host)\n\tb.Channel = channel\n\tb.Connection = conn\n}\n\n// GetResult retrieves result from AMQP queue\nfunc (b *AMQPCeleryBackend) GetResult(taskID string) (*ResultMessage, error) {\n\n\tqueueName := strings.Replace(taskID, \"-\", \"\", -1)\n\n\targs := amqp.Table{\"x-expires\": int32(86400000)}\n\n\t_, err := b.QueueDeclare(\n\t\tqueueName, // name\n\t\ttrue,      // durable\n\t\ttrue,      // autoDelete\n\t\tfalse,     // exclusive\n\t\tfalse,     // noWait\n\t\targs,      // args\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = b.ExchangeDeclare(\n\t\t\"default\",\n\t\t\"direct\",\n\t\ttrue,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// open channel temporarily\n\tchannel, err := b.Consume(queueName, \"\", false, false, false, false, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resultMessage ResultMessage\n\n\tdelivery := <-channel\n\tdeliveryAck(delivery)\n\tif err := json.Unmarshal(delivery.Body, &resultMessage); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resultMessage, nil\n}\n\n// SetResult sets result back to AMQP queue\nfunc (b *AMQPCeleryBackend) SetResult(taskID string, result *ResultMessage) error {\n\n\tresult.ID = taskID\n\n\t//queueName := taskID\n\tqueueName := strings.Replace(taskID, \"-\", \"\", -1)\n\n\t// autodelete is automatically set to true by python\n\t// (406) PRECONDITION_FAILED - inequivalent arg 'durable' for queue 'bc58c0d895c7421eb7cb2b9bbbd8b36f' in vhost '/': received 'true' but current is 'false'\n\n\targs := amqp.Table{\"x-expires\": int32(86400000)}\n\t_, err := b.QueueDeclare(\n\t\tqueueName, // name\n\t\ttrue,      // durable\n\t\ttrue,      // autoDelete\n\t\tfalse,     // exclusive\n\t\tfalse,     // noWait\n\t\targs,      // args\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = b.ExchangeDeclare(\n\t\t\"default\",\n\t\t\"direct\",\n\t\ttrue,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresBytes, err := json.Marshal(result)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmessage := amqp.Publishing{\n\t\tDeliveryMode: amqp.Persistent,\n\t\tTimestamp:    time.Now(),\n\t\tContentType:  \"application/json\",\n\t\tBody:         resBytes,\n\t}\n\treturn b.Publish(\n\t\t\"\",\n\t\tqueueName,\n\t\tfalse,\n\t\tfalse,\n\t\tmessage,\n\t)\n}\n"
        },
        {
          "name": "amqp_broker.go",
          "type": "blob",
          "size": 4.2265625,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\n// AMQPExchange stores AMQP Exchange configuration\ntype AMQPExchange struct {\n\tName       string\n\tType       string\n\tDurable    bool\n\tAutoDelete bool\n}\n\n// NewAMQPExchange creates new AMQPExchange\nfunc NewAMQPExchange(name string) *AMQPExchange {\n\treturn &AMQPExchange{\n\t\tName:       name,\n\t\tType:       \"direct\",\n\t\tDurable:    true,\n\t\tAutoDelete: true,\n\t}\n}\n\n// AMQPQueue stores AMQP Queue configuration\ntype AMQPQueue struct {\n\tName       string\n\tDurable    bool\n\tAutoDelete bool\n}\n\n// NewAMQPQueue creates new AMQPQueue\nfunc NewAMQPQueue(name string) *AMQPQueue {\n\treturn &AMQPQueue{\n\t\tName:       name,\n\t\tDurable:    true,\n\t\tAutoDelete: false,\n\t}\n}\n\n//AMQPCeleryBroker is RedisBroker for AMQP\ntype AMQPCeleryBroker struct {\n\t*amqp.Channel\n\tConnection       *amqp.Connection\n\tExchange         *AMQPExchange\n\tQueue            *AMQPQueue\n\tconsumingChannel <-chan amqp.Delivery\n\tRate             int\n}\n\n// NewAMQPConnection creates new AMQP channel\nfunc NewAMQPConnection(host string) (*amqp.Connection, *amqp.Channel) {\n\tconnection, err := amqp.Dial(host)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tchannel, err := connection.Channel()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn connection, channel\n}\n\n// NewAMQPCeleryBroker creates new AMQPCeleryBroker\nfunc NewAMQPCeleryBroker(host string) *AMQPCeleryBroker {\n\treturn NewAMQPCeleryBrokerByConnAndChannel(NewAMQPConnection(host))\n}\n\n// NewAMQPCeleryBrokerByConnAndChannel creates new AMQPCeleryBroker using AMQP conn and channel\nfunc NewAMQPCeleryBrokerByConnAndChannel(conn *amqp.Connection, channel *amqp.Channel) *AMQPCeleryBroker {\n\tbroker := &AMQPCeleryBroker{\n\t\tChannel:    channel,\n\t\tConnection: conn,\n\t\tExchange:   NewAMQPExchange(\"default\"),\n\t\tQueue:      NewAMQPQueue(\"celery\"),\n\t\tRate:       4,\n\t}\n\tif err := broker.CreateExchange(); err != nil {\n\t\tpanic(err)\n\t}\n\tif err := broker.CreateQueue(); err != nil {\n\t\tpanic(err)\n\t}\n\tif err := broker.Qos(broker.Rate, 0, false); err != nil {\n\t\tpanic(err)\n\t}\n\tif err := broker.StartConsumingChannel(); err != nil {\n\t\tpanic(err)\n\t}\n\treturn broker\n}\n\n// StartConsumingChannel spawns receiving channel on AMQP queue\nfunc (b *AMQPCeleryBroker) StartConsumingChannel() error {\n\tchannel, err := b.Consume(b.Queue.Name, \"\", false, false, false, false, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.consumingChannel = channel\n\treturn nil\n}\n\n// SendCeleryMessage sends CeleryMessage to broker\nfunc (b *AMQPCeleryBroker) SendCeleryMessage(message *CeleryMessage) error {\n\ttaskMessage := message.GetTaskMessage()\n\tqueueName := \"celery\"\n\t_, err := b.QueueDeclare(\n\t\tqueueName, // name\n\t\ttrue,      // durable\n\t\tfalse,     // autoDelete\n\t\tfalse,     // exclusive\n\t\tfalse,     // noWait\n\t\tnil,       // args\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = b.ExchangeDeclare(\n\t\t\"default\",\n\t\t\"direct\",\n\t\ttrue,\n\t\ttrue,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresBytes, err := json.Marshal(taskMessage)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpublishMessage := amqp.Publishing{\n\t\tDeliveryMode: amqp.Persistent,\n\t\tTimestamp:    time.Now(),\n\t\tContentType:  \"application/json\",\n\t\tBody:         resBytes,\n\t}\n\n\treturn b.Publish(\n\t\t\"\",\n\t\tqueueName,\n\t\tfalse,\n\t\tfalse,\n\t\tpublishMessage,\n\t)\n}\n\n// GetTaskMessage retrieves task message from AMQP queue\nfunc (b *AMQPCeleryBroker) GetTaskMessage() (*TaskMessage, error) {\n\tselect {\n\tcase delivery := <-b.consumingChannel:\n\t\tdeliveryAck(delivery)\n\t\tvar taskMessage TaskMessage\n\t\tif err := json.Unmarshal(delivery.Body, &taskMessage); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &taskMessage, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"consuming channel is empty\")\n\t}\n}\n\n// CreateExchange declares AMQP exchange with stored configuration\nfunc (b *AMQPCeleryBroker) CreateExchange() error {\n\treturn b.ExchangeDeclare(\n\t\tb.Exchange.Name,\n\t\tb.Exchange.Type,\n\t\tb.Exchange.Durable,\n\t\tb.Exchange.AutoDelete,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n}\n\n// CreateQueue declares AMQP Queue with stored configuration\nfunc (b *AMQPCeleryBroker) CreateQueue() error {\n\t_, err := b.QueueDeclare(\n\t\tb.Queue.Name,\n\t\tb.Queue.Durable,\n\t\tb.Queue.AutoDelete,\n\t\tfalse,\n\t\tfalse,\n\t\tnil,\n\t)\n\treturn err\n}\n"
        },
        {
          "name": "backend_test.go",
          "type": "blob",
          "size": 4.439453125,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"testing\"\n\n\tuuid \"github.com/satori/go.uuid\"\n)\n\n// TestBackendRedisGetResult is Redis specific test to get result from backend\nfunc TestBackendRedisGetResult(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tbackend *RedisCeleryBackend\n\t}{\n\t\t{\n\t\t\tname:    \"get result from redis backend\",\n\t\t\tbackend: redisBackend,\n\t\t},\n\t\t{\n\t\t\tname:    \"get result from redis backend with connection\",\n\t\t\tbackend: redisBackendWithConn,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\ttaskID := uuid.Must(uuid.NewV4()).String()\n\t\t// value must be float64 for testing due to json limitation\n\t\tvalue := reflect.ValueOf(rand.Float64())\n\t\tresultMessage := getReflectionResultMessage(&value)\n\t\tmessageBytes, err := json.Marshal(resultMessage)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': error marshalling result message: %v\", tc.name, err)\n\t\t\treleaseResultMessage(resultMessage)\n\t\t\tcontinue\n\t\t}\n\t\tconn := tc.backend.Get()\n\t\tdefer conn.Close()\n\t\t_, err = conn.Do(\"SETEX\", fmt.Sprintf(\"celery-task-meta-%s\", taskID), 86400, messageBytes)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': error setting result message to celery: %v\", tc.name, err)\n\t\t\treleaseResultMessage(resultMessage)\n\t\t\tcontinue\n\t\t}\n\t\tres, err := tc.backend.GetResult(taskID)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': error getting result from backend: %v\", tc.name, err)\n\t\t\treleaseResultMessage(resultMessage)\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(res, resultMessage) {\n\t\t\tt.Errorf(\"test '%s': result message received %v is different from original %v\", tc.name, res, resultMessage)\n\t\t}\n\t\treleaseResultMessage(resultMessage)\n\t}\n}\n\n// TestBackendRedisSetResult is Redis specific test to set result to backend\nfunc TestBackendRedisSetResult(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tbackend *RedisCeleryBackend\n\t}{\n\t\t{\n\t\t\tname:    \"set result to redis backend\",\n\t\t\tbackend: redisBackend,\n\t\t},\n\t\t{\n\t\t\tname:    \"set result to redis backend with connection\",\n\t\t\tbackend: redisBackendWithConn,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\ttaskID := uuid.Must(uuid.NewV4()).String()\n\t\tvalue := reflect.ValueOf(rand.Float64())\n\t\tresultMessage := getReflectionResultMessage(&value)\n\t\terr := tc.backend.SetResult(taskID, resultMessage)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': error setting result to backend: %v\", tc.name, err)\n\t\t\treleaseResultMessage(resultMessage)\n\t\t\tcontinue\n\t\t}\n\t\tconn := tc.backend.Get()\n\t\tdefer conn.Close()\n\t\tval, err := conn.Do(\"GET\", fmt.Sprintf(\"celery-task-meta-%s\", taskID))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': error getting data from redis: %v\", tc.name, err)\n\t\t\treleaseResultMessage(resultMessage)\n\t\t\tcontinue\n\t\t}\n\t\tif val == nil {\n\t\t\tt.Errorf(\"test '%s': result not available from redis\", tc.name)\n\t\t\treleaseResultMessage(resultMessage)\n\t\t\tcontinue\n\t\t}\n\t\tvar res ResultMessage\n\t\terr = json.Unmarshal(val.([]byte), &res)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': error parsing json result\", tc.name)\n\t\t\treleaseResultMessage(resultMessage)\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(&res, resultMessage) {\n\t\t\tt.Errorf(\"test '%s': result message received %v is different from original %v\", tc.name, &res, resultMessage)\n\t\t}\n\t\treleaseResultMessage(resultMessage)\n\t}\n}\n\n// TestBackendSetGetResult tests set/get result feature for all backends\nfunc TestBackendSetGetResult(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tbackend CeleryBackend\n\t}{\n\t\t{\n\t\t\tname:    \"set/get result to redis backend\",\n\t\t\tbackend: redisBackend,\n\t\t},\n\t\t{\n\t\t\tname:    \"set/get result to redis backend with connection\",\n\t\t\tbackend: redisBackendWithConn,\n\t\t},\n\t\t{\n\t\t\tname:    \"set/get result to amqp backend\",\n\t\t\tbackend: amqpBackend,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\ttaskID := uuid.Must(uuid.NewV4()).String()\n\t\tvalue := reflect.ValueOf(rand.Float64())\n\t\tresultMessage := getReflectionResultMessage(&value)\n\t\terr := tc.backend.SetResult(taskID, resultMessage)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error setting result to backend: %v\", err)\n\t\t\treleaseResultMessage(resultMessage)\n\t\t\tcontinue\n\t\t}\n\t\tres, err := tc.backend.GetResult(taskID)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error getting result from backend: %v\", err)\n\t\t\treleaseResultMessage(resultMessage)\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(res, resultMessage) {\n\t\t\tt.Errorf(\"result message received %v is different from original %v\", res, resultMessage)\n\t\t}\n\t\treleaseResultMessage(resultMessage)\n\t}\n}\n"
        },
        {
          "name": "broker_test.go",
          "type": "blob",
          "size": 5.0517578125,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"encoding/json\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc makeCeleryMessage() (*CeleryMessage, error) {\n\ttaskMessage := getTaskMessage(\"add\")\n\ttaskMessage.Args = []interface{}{rand.Intn(10), rand.Intn(10)}\n\tdefer releaseTaskMessage(taskMessage)\n\tencodedTaskMessage, err := taskMessage.Encode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn getCeleryMessage(encodedTaskMessage), nil\n}\n\n// TestBrokerRedisSend is Redis specific test that sets CeleryMessage to queue\nfunc TestBrokerRedisSend(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tbroker *RedisCeleryBroker\n\t}{\n\t\t{\n\t\t\tname:   \"send task to redis broker\",\n\t\t\tbroker: redisBroker,\n\t\t},\n\t\t{\n\t\t\tname:   \"send task to redis broker with connection\",\n\t\t\tbroker: redisBrokerWithConn,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tceleryMessage, err := makeCeleryMessage()\n\t\tif err != nil || celeryMessage == nil {\n\t\t\tt.Errorf(\"test '%s': failed to construct celery message: %v\", tc.name, err)\n\t\t\tcontinue\n\t\t}\n\t\terr = tc.broker.SendCeleryMessage(celeryMessage)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to send celery message to broker: %v\", tc.name, err)\n\t\t\treleaseCeleryMessage(celeryMessage)\n\t\t\tcontinue\n\t\t}\n\t\tconn := tc.broker.Get()\n\t\tdefer conn.Close()\n\t\tmessageJSON, err := conn.Do(\"BRPOP\", tc.broker.QueueName, \"1\")\n\t\tif err != nil || messageJSON == nil {\n\t\t\tt.Errorf(\"test '%s': failed to get celery message from broker: %v\", tc.name, err)\n\t\t\treleaseCeleryMessage(celeryMessage)\n\t\t\tcontinue\n\t\t}\n\t\tmessageList := messageJSON.([]interface{})\n\t\tif string(messageList[0].([]byte)) != \"celery\" {\n\t\t\tt.Errorf(\"test '%s': non celery message received\", tc.name)\n\t\t\treleaseCeleryMessage(celeryMessage)\n\t\t\tcontinue\n\t\t}\n\t\tvar message CeleryMessage\n\t\tif err := json.Unmarshal(messageList[1].([]byte), &message); err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to unmarshal received message: %v\", tc.name, err)\n\t\t\treleaseCeleryMessage(celeryMessage)\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(celeryMessage, &message) {\n\t\t\tt.Errorf(\"test '%s': received message %v different from original message %v\", tc.name, &message, celeryMessage)\n\t\t}\n\t\treleaseCeleryMessage(celeryMessage)\n\t}\n}\n\n// TestBrokerRedisGet is Redis specific test that gets CeleryMessage from queue\nfunc TestBrokerRedisGet(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tbroker *RedisCeleryBroker\n\t}{\n\t\t{\n\t\t\tname:   \"get task from redis broker\",\n\t\t\tbroker: redisBroker,\n\t\t},\n\t\t{\n\t\t\tname:   \"get task from redis broker with connection\",\n\t\t\tbroker: redisBrokerWithConn,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tceleryMessage, err := makeCeleryMessage()\n\t\tif err != nil || celeryMessage == nil {\n\t\t\tt.Errorf(\"test '%s': failed to construct celery message: %v\", tc.name, err)\n\t\t\tcontinue\n\t\t}\n\t\tjsonBytes, err := json.Marshal(celeryMessage)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to marshal celery message: %v\", tc.name, err)\n\t\t\treleaseCeleryMessage(celeryMessage)\n\t\t\tcontinue\n\t\t}\n\t\tconn := tc.broker.Get()\n\t\tdefer conn.Close()\n\t\t_, err = conn.Do(\"LPUSH\", tc.broker.QueueName, jsonBytes)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to push celery message to redis: %v\", tc.name, err)\n\t\t\treleaseCeleryMessage(celeryMessage)\n\t\t\tcontinue\n\t\t}\n\t\tmessage, err := tc.broker.GetCeleryMessage()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get celery message from broker: %v\", tc.name, err)\n\t\t\treleaseCeleryMessage(celeryMessage)\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(message, celeryMessage) {\n\t\t\tt.Errorf(\"test '%s': received message %v different from original message %v\", tc.name, message, celeryMessage)\n\t\t}\n\t\treleaseCeleryMessage(celeryMessage)\n\t}\n}\n\n// TestBrokerSendGet tests set/get features for all brokers\nfunc TestBrokerSendGet(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tbroker CeleryBroker\n\t}{\n\t\t{\n\t\t\tname:   \"send/get task for redis broker\",\n\t\t\tbroker: redisBroker,\n\t\t},\n\t\t{\n\t\t\tname:   \"send/get task for redis broker with connection\",\n\t\t\tbroker: redisBrokerWithConn,\n\t\t},\n\t\t{\n\t\t\tname:   \"send/get task for amqp broker\",\n\t\t\tbroker: amqpBroker,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tceleryMessage, err := makeCeleryMessage()\n\t\tif err != nil || celeryMessage == nil {\n\t\t\tt.Errorf(\"test '%s': failed to construct celery message: %v\", tc.name, err)\n\t\t\tcontinue\n\t\t}\n\t\terr = tc.broker.SendCeleryMessage(celeryMessage)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to send celery message to broker: %v\", tc.name, err)\n\t\t\treleaseCeleryMessage(celeryMessage)\n\t\t\tcontinue\n\t\t}\n\t\t// wait arbitrary time for message to propagate\n\t\ttime.Sleep(1 * time.Second)\n\t\tmessage, err := tc.broker.GetTaskMessage()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get celery message from broker: %v\", tc.name, err)\n\t\t\treleaseCeleryMessage(celeryMessage)\n\t\t\tcontinue\n\t\t}\n\t\toriginalMessage := celeryMessage.GetTaskMessage()\n\t\tif !reflect.DeepEqual(message, originalMessage) {\n\t\t\tt.Errorf(\"test '%s': received message %v different from original message %v\", tc.name, message, originalMessage)\n\t\t}\n\t\treleaseCeleryMessage(celeryMessage)\n\t}\n}\n"
        },
        {
          "name": "convert.go",
          "type": "blob",
          "size": 0.7939453125,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"reflect\"\n)\n\n// GetRealValue returns real value of reflect.Value\n// Required for JSON Marshalling\nfunc GetRealValue(val *reflect.Value) interface{} {\n\tif val == nil {\n\t\treturn nil\n\t}\n\tswitch val.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn val.Int()\n\tcase reflect.String:\n\t\treturn val.String()\n\tcase reflect.Bool:\n\t\treturn val.Bool()\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn val.Uint()\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn val.Float()\n\tcase reflect.Slice, reflect.Map:\n\t\treturn val.Interface()\n\tdefault:\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "demo.gif",
          "type": "blob",
          "size": 1395.8115234375,
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.908203125,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\n/*\nPackage gocelery is Celery Distributed Task Queue in Go\n\nCelery distributed tasks are used heavily in many python web applications and this library allows you to implement celery workers in Go as well as being able to submit celery tasks in Go.\n\nThis package can also be used as pure go distributed task queue.\n\nSupported brokers/backends\n\n    * Redis (broker/backend)\n    * AMQP (broker/backend)\n\nCelery must be configured to use json instead of default pickle encoding. This is because Go currently has no stable support for decoding pickle objects. Pass below configuration parameters to use json.\n\n    CELERY_TASK_SERIALIZER='json'\n    CELERY_ACCEPT_CONTENT=['json']  # Ignore other content\n    CELERY_RESULT_SERIALIZER='json'\n    CELERY_ENABLE_UTC=True\n*/\npackage gocelery\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "example_client_named_arg_test.go",
          "type": "blob",
          "size": 1.0908203125,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"log\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\nfunc Example_clientWithNamedArguments() {\n\n\t// create redis connection pool\n\t// create redis connection pool\n\tredisPool := &redis.Pool{\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(\"redis://\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t}\n\n\t// initialize celery client\n\tcli, _ := NewCeleryClient(\n\t\tNewRedisBroker(redisPool),\n\t\t&RedisCeleryBackend{Pool: redisPool},\n\t\t1,\n\t)\n\n\t// prepare arguments\n\ttaskName := \"worker.add\"\n\targA := rand.Intn(10)\n\targB := rand.Intn(10)\n\n\t// run task\n\tasyncResult, err := cli.DelayKwargs(\n\t\ttaskName,\n\t\tmap[string]interface{}{\n\t\t\t\"a\": argA,\n\t\t\t\"b\": argB,\n\t\t},\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// get results from backend with timeout\n\tres, err := asyncResult.Get(10 * time.Second)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tlog.Printf(\"result: %+v of type %+v\", res, reflect.TypeOf(res))\n\n}\n"
        },
        {
          "name": "example_client_test.go",
          "type": "blob",
          "size": 0.9833984375,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"log\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\nfunc Example_client() {\n\n\t// create redis connection pool\n\tredisPool := &redis.Pool{\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(\"redis://\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t}\n\n\t// initialize celery client\n\tcli, _ := NewCeleryClient(\n\t\tNewRedisBroker(redisPool),\n\t\t&RedisCeleryBackend{Pool: redisPool},\n\t\t1,\n\t)\n\n\t// prepare arguments\n\ttaskName := \"worker.add\"\n\targA := rand.Intn(10)\n\targB := rand.Intn(10)\n\n\t// run task\n\tasyncResult, err := cli.Delay(taskName, argA, argB)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// get results from backend with timeout\n\tres, err := asyncResult.Get(10 * time.Second)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tlog.Printf(\"result: %+v of type %+v\", res, reflect.TypeOf(res))\n\n}\n"
        },
        {
          "name": "example_worker_named_arg_test.go",
          "type": "blob",
          "size": 1.537109375,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\n// exampleAddTask is integer addition task\n// with named arguments\ntype exampleAddTask struct {\n\ta int\n\tb int\n}\n\nfunc (a *exampleAddTask) ParseKwargs(kwargs map[string]interface{}) error {\n\tkwargA, ok := kwargs[\"a\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg a\")\n\t}\n\tkwargAFloat, ok := kwargA.(float64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg a\")\n\t}\n\ta.a = int(kwargAFloat)\n\tkwargB, ok := kwargs[\"b\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg b\")\n\t}\n\tkwargBFloat, ok := kwargB.(float64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg b\")\n\t}\n\ta.b = int(kwargBFloat)\n\treturn nil\n}\n\nfunc (a *exampleAddTask) RunTask() (interface{}, error) {\n\tresult := a.a + a.b\n\treturn result, nil\n}\n\nfunc Example_workerWithNamedArguments() {\n\n\t// create redis connection pool\n\tredisPool := &redis.Pool{\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(\"redis://\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t}\n\n\t// initialize celery client\n\tcli, _ := NewCeleryClient(\n\t\tNewRedisBroker(redisPool),\n\t\t&RedisCeleryBackend{Pool: redisPool},\n\t\t5, // number of workers\n\t)\n\n\t// register task\n\tcli.Register(\"add\", &exampleAddTask{})\n\n\t// start workers (non-blocking call)\n\tcli.StartWorker()\n\n\t// wait for client request\n\ttime.Sleep(10 * time.Second)\n\n\t// stop workers gracefully (blocking call)\n\tcli.StopWorker()\n}\n"
        },
        {
          "name": "example_worker_test.go",
          "type": "blob",
          "size": 0.8740234375,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"time\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\nfunc Example_worker() {\n\n\t// create redis connection pool\n\tredisPool := &redis.Pool{\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(\"redis://\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t}\n\n\t// initialize celery client\n\tcli, _ := NewCeleryClient(\n\t\tNewRedisBroker(redisPool),\n\t\t&RedisCeleryBackend{Pool: redisPool},\n\t\t5, // number of workers\n\t)\n\n\t// task\n\tadd := func(a, b int) int {\n\t\treturn a + b\n\t}\n\n\t// register task\n\tcli.Register(\"add\", add)\n\n\t// start workers (non-blocking call)\n\tcli.StartWorker()\n\n\t// wait for client request\n\ttime.Sleep(10 * time.Second)\n\n\t// stop workers gracefully (blocking call)\n\tcli.StopWorker()\n\n}\n"
        },
        {
          "name": "example_worker_with_context_test.go",
          "type": "blob",
          "size": 1.0576171875,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\nfunc Example_workerWithContext() {\n\n\t// create redis connection pool\n\tredisPool := &redis.Pool{\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(\"redis://\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t}\n\n\t// initialize celery client\n\tcli, _ := NewCeleryClient(\n\t\tNewRedisBroker(redisPool),\n\t\t&RedisCeleryBackend{Pool: redisPool},\n\t\t1,\n\t)\n\n\t// task\n\tadd := func(a, b int) int {\n\t\treturn a + b\n\t}\n\n\t// register task\n\tcli.Register(\"add\", add)\n\n\t// context with cancelFunc to handle exit gracefully\n\tctx, cancel := context.WithCancel(context.Background())\n\n\t// start workers (non-blocking call)\n\tcli.StartWorkerWithContext(ctx)\n\n\t// wait for client request\n\ttime.Sleep(10 * time.Second)\n\n\t// stop workers by cancelling context\n\tcancel()\n\n\t// optional: wait for all workers to terminate\n\tcli.WaitForStopWorker()\n\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.40234375,
          "content": "module github.com/gocelery/gocelery\n\ngo 1.13\n\nrequire (\n\tgithub.com/gomodule/redigo v2.0.0+incompatible\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e // indirect\n\tgithub.com/satori/go.uuid v1.2.1-0.20181028125025-b2ce2384e17b\n\tgithub.com/streadway/amqp v0.0.0-20190827072141-edfb9018d271\n\tgopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.4521484375,
          "content": "github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/gomodule/redigo v2.0.0+incompatible h1:K/R+8tc58AaqLkqG2Ol3Qk+DR/TlNuhuh457pBFPtt0=\ngithub.com/gomodule/redigo v2.0.0+incompatible/go.mod h1:B4C85qUVwatsJoIUNIfCRsp7qO0iAmpGFZ4EELWSbC4=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/satori/go.uuid v1.2.1-0.20181028125025-b2ce2384e17b h1:gQZ0qzfKHQIybLANtM3mBXNUtOfsCFXeTsnBqCsx1KM=\ngithub.com/satori/go.uuid v1.2.1-0.20181028125025-b2ce2384e17b/go.mod h1:dA0hQrYB0VpLJoorglMZABFdXlWrHn1NEOzdhQKdks0=\ngithub.com/streadway/amqp v0.0.0-20190827072141-edfb9018d271 h1:WhxRHzgeVGETMlmVfqhRn8RIeeNoPr2Czh33I4Zdccw=\ngithub.com/streadway/amqp v0.0.0-20190827072141-edfb9018d271/go.mod h1:AZpEONHx3DKn8O/DFsRAY58/XVQiIPMTMB1SddzLXVw=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f h1:BLraFXnmrev5lT+xlilqcH8XK9/i0At2xKjWk4p6zsU=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\n"
        },
        {
          "name": "gocelery.go",
          "type": "blob",
          "size": 4.2666015625,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// CeleryClient provides API for sending celery tasks\ntype CeleryClient struct {\n\tbroker  CeleryBroker\n\tbackend CeleryBackend\n\tworker  *CeleryWorker\n}\n\n// CeleryBroker is interface for celery broker database\ntype CeleryBroker interface {\n\tSendCeleryMessage(*CeleryMessage) error\n\tGetTaskMessage() (*TaskMessage, error) // must be non-blocking\n}\n\n// CeleryBackend is interface for celery backend database\ntype CeleryBackend interface {\n\tGetResult(string) (*ResultMessage, error) // must be non-blocking\n\tSetResult(taskID string, result *ResultMessage) error\n}\n\n// NewCeleryClient creates new celery client\nfunc NewCeleryClient(broker CeleryBroker, backend CeleryBackend, numWorkers int) (*CeleryClient, error) {\n\treturn &CeleryClient{\n\t\tbroker,\n\t\tbackend,\n\t\tNewCeleryWorker(broker, backend, numWorkers),\n\t}, nil\n}\n\n// Register task\nfunc (cc *CeleryClient) Register(name string, task interface{}) {\n\tcc.worker.Register(name, task)\n}\n\n// StartWorkerWithContext starts celery workers with given parent context\nfunc (cc *CeleryClient) StartWorkerWithContext(ctx context.Context) {\n\tcc.worker.StartWorkerWithContext(ctx)\n}\n\n// StartWorker starts celery workers\nfunc (cc *CeleryClient) StartWorker() {\n\tcc.worker.StartWorker()\n}\n\n// StopWorker stops celery workers\nfunc (cc *CeleryClient) StopWorker() {\n\tcc.worker.StopWorker()\n}\n\n// WaitForStopWorker waits for celery workers to terminate\nfunc (cc *CeleryClient) WaitForStopWorker() {\n\tcc.worker.StopWait()\n}\n\n// Delay gets asynchronous result\nfunc (cc *CeleryClient) Delay(task string, args ...interface{}) (*AsyncResult, error) {\n\tceleryTask := getTaskMessage(task)\n\tceleryTask.Args = args\n\treturn cc.delay(celeryTask)\n}\n\n// DelayKwargs gets asynchronous results with argument map\nfunc (cc *CeleryClient) DelayKwargs(task string, args map[string]interface{}) (*AsyncResult, error) {\n\tceleryTask := getTaskMessage(task)\n\tceleryTask.Kwargs = args\n\treturn cc.delay(celeryTask)\n}\n\nfunc (cc *CeleryClient) delay(task *TaskMessage) (*AsyncResult, error) {\n\tdefer releaseTaskMessage(task)\n\tencodedMessage, err := task.Encode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tceleryMessage := getCeleryMessage(encodedMessage)\n\tdefer releaseCeleryMessage(celeryMessage)\n\terr = cc.broker.SendCeleryMessage(celeryMessage)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &AsyncResult{\n\t\tTaskID:  task.ID,\n\t\tbackend: cc.backend,\n\t}, nil\n}\n\n// CeleryTask is an interface that represents actual task\n// Passing CeleryTask interface instead of function pointer\n// avoids reflection and may have performance gain.\n// ResultMessage must be obtained using GetResultMessage()\ntype CeleryTask interface {\n\n\t// ParseKwargs - define a method to parse kwargs\n\tParseKwargs(map[string]interface{}) error\n\n\t// RunTask - define a method for execution\n\tRunTask() (interface{}, error)\n}\n\n// AsyncResult represents pending result\ntype AsyncResult struct {\n\tTaskID  string\n\tbackend CeleryBackend\n\tresult  *ResultMessage\n}\n\n// Get gets actual result from backend\n// It blocks for period of time set by timeout and returns error if unavailable\nfunc (ar *AsyncResult) Get(timeout time.Duration) (interface{}, error) {\n\tticker := time.NewTicker(50 * time.Millisecond)\n\ttimeoutChan := time.After(timeout)\n\tfor {\n\t\tselect {\n\t\tcase <-timeoutChan:\n\t\t\terr := fmt.Errorf(\"%v timeout getting result for %s\", timeout, ar.TaskID)\n\t\t\treturn nil, err\n\t\tcase <-ticker.C:\n\t\t\tval, err := ar.AsyncGet()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn val, nil\n\t\t}\n\t}\n}\n\n// AsyncGet gets actual result from backend and returns nil if not available\nfunc (ar *AsyncResult) AsyncGet() (interface{}, error) {\n\tif ar.result != nil {\n\t\treturn ar.result.Result, nil\n\t}\n\tval, err := ar.backend.GetResult(ar.TaskID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif val == nil {\n\t\treturn nil, err\n\t}\n\tif val.Status != \"SUCCESS\" {\n\t\treturn nil, fmt.Errorf(\"error response status %v\", val)\n\t}\n\tar.result = val\n\treturn val.Result, nil\n}\n\n// Ready checks if actual result is ready\nfunc (ar *AsyncResult) Ready() (bool, error) {\n\tif ar.result != nil {\n\t\treturn true, nil\n\t}\n\tval, err := ar.backend.GetResult(ar.TaskID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tar.result = val\n\treturn (val != nil), nil\n}\n"
        },
        {
          "name": "gocelery_test.go",
          "type": "blob",
          "size": 37.7734375,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gomodule/redigo/redis\"\n\tuuid \"github.com/satori/go.uuid\"\n)\n\nconst TIMEOUT = 2 * time.Second\n\nvar (\n\tredisPool = &redis.Pool{\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(\"redis://\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t}\n\tredisBroker          = NewRedisCeleryBroker(\"redis://\")\n\tredisBrokerWithConn  = NewRedisBroker(redisPool)\n\tredisBackend         = NewRedisCeleryBackend(\"redis://\")\n\tredisBackendWithConn = NewRedisBackend(redisPool)\n\tamqpBroker           = NewAMQPCeleryBroker(\"amqp://\")\n\tamqpBackend          = NewAMQPCeleryBackend(\"amqp://\")\n)\n\n// TestNoArg tests successful function execution\n// with no argument and valid return value\nfunc TestNoArg(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"no argument that returns integer value with redis broker/backend \",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: func() int { return 5545 },\n\t\t\texpected: 5545,\n\t\t},\n\t\t{\n\t\t\tname:     \"no argument that returns integer value with redis broker/backend \",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &noArgTask{},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"no argument that returns integer value with amqp broker/backend \",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: func() int { return 6930 },\n\t\t\texpected: 6930,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.Delay(tc.taskName)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\t// json always return float64 intead of int\n\t\tif tc.expected != int(res.(float64)) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestInteger tests successful function execution\n// with integer arguments and return value\nfunc TestInteger(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      int\n\t\tinB      int\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"integer addition with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addInt,\n\t\t\tinA:      2485,\n\t\t\tinB:      6468,\n\t\t\texpected: 8953,\n\t\t},\n\t\t{\n\t\t\tname:     \"integer addition with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addInt,\n\t\t\tinA:      2485,\n\t\t\tinB:      6468,\n\t\t\texpected: 8953,\n\t\t},\n\t\t{\n\t\t\tname:     \"integer addition with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addInt,\n\t\t\tinA:      2485,\n\t\t\tinB:      6468,\n\t\t\texpected: 8953,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.Delay(tc.taskName, tc.inA, tc.inB)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\t// json always return float64 intead of int\n\t\tif tc.expected != int(res.(float64)) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestIntegerNamedArguments tests successful function execution\n// with integer arguments and return value\nfunc TestIntegerNamedArguments(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      int\n\t\tinB      int\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"integer addition (named arguments) with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addIntTask{},\n\t\t\tinA:      2485,\n\t\t\tinB:      6468,\n\t\t\texpected: 8953,\n\t\t},\n\t\t{\n\t\t\tname:     \"integer addition (named arguments) with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addIntTask{},\n\t\t\tinA:      2485,\n\t\t\tinB:      6468,\n\t\t\texpected: 8953,\n\t\t},\n\t\t{\n\t\t\tname:     \"integer addition (named arguments) with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addIntTask{},\n\t\t\tinA:      2485,\n\t\t\tinB:      6468,\n\t\t\texpected: 8953,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.DelayKwargs(\n\t\t\ttc.taskName,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"a\": tc.inA,\n\t\t\t\t\"b\": tc.inB,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\t// json always return float64 intead of int\n\t\tif tc.expected != int(res.(float64)) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestString tests successful function execution\n// with string arguments and return value\nfunc TestString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      string\n\t\tinB      string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"string addition with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addStr,\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      \"world\",\n\t\t\texpected: \"helloworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string addition with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addStr,\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      \"world\",\n\t\t\texpected: \"helloworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string addition with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addStr,\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      \"world\",\n\t\t\texpected: \"helloworld\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.Delay(tc.taskName, tc.inA, tc.inB)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != res.(string) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestStringNamedArguments tests successful function execution\n// with string arguments and return value\nfunc TestStringNamedArguments(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      string\n\t\tinB      string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"string addition (named arguments) with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addStrTask{},\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      \"world\",\n\t\t\texpected: \"helloworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string addition (named arguments) with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addStrTask{},\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      \"world\",\n\t\t\texpected: \"helloworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string addition (named arguments) with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addStrTask{},\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      \"world\",\n\t\t\texpected: \"helloworld\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.DelayKwargs(\n\t\t\ttc.taskName,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"a\": tc.inA,\n\t\t\t\t\"b\": tc.inB,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != res.(string) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestStringInteger tests successful function execution\n// with string and integer arguments and string return value\nfunc TestStringInteger(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      string\n\t\tinB      int\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"integer and string concatenation with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addStrInt,\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      5,\n\t\t\texpected: \"hello5\",\n\t\t},\n\t\t{\n\t\t\tname:     \"integer and string concatenation with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addStrInt,\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      5,\n\t\t\texpected: \"hello5\",\n\t\t},\n\t\t{\n\t\t\tname:     \"integer and string concatenation with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addStrInt,\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      5,\n\t\t\texpected: \"hello5\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.Delay(tc.taskName, tc.inA, tc.inB)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != res.(string) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestStringIntegerNamedArguments tests successful function execution\n// with string and integer arguments and string return value\nfunc TestStringIntegerNamedArguments(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      string\n\t\tinB      int\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"integer and string concatenation (named arguments) with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addStrIntTask{},\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      5,\n\t\t\texpected: \"hello5\",\n\t\t},\n\t\t{\n\t\t\tname:     \"integer and string concatenation (named arguments) with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addStrIntTask{},\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      5,\n\t\t\texpected: \"hello5\",\n\t\t},\n\t\t{\n\t\t\tname:     \"integer and string concatenation (named arguments) with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addStrIntTask{},\n\t\t\tinA:      \"hello\",\n\t\t\tinB:      5,\n\t\t\texpected: \"hello5\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.DelayKwargs(\n\t\t\ttc.taskName,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"a\": tc.inA,\n\t\t\t\t\"b\": tc.inB,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != res.(string) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestFloat tests successful function execution\n// with float64 arguments and return value\nfunc TestFloat(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      float64\n\t\tinB      float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"float addition with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addFloat,\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: 8.8268,\n\t\t},\n\t\t{\n\t\t\tname:     \"float addition with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addFloat,\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: 8.8268,\n\t\t},\n\t\t{\n\t\t\tname:     \"float addition with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addFloat,\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: 8.8268,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.Delay(tc.taskName, tc.inA, tc.inB)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != res.(float64) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestFloatNamedArguments tests successful function execution\n// with float64 arguments and return value\nfunc TestFloatNamedArguments(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      float64\n\t\tinB      float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"float addition with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addFloatTask{},\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: 8.8268,\n\t\t},\n\t\t{\n\t\t\tname:     \"float addition with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addFloatTask{},\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: 8.8268,\n\t\t},\n\t\t{\n\t\t\tname:     \"float addition with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addFloatTask{},\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: 8.8268,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.DelayKwargs(\n\t\t\ttc.taskName,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"a\": tc.inA,\n\t\t\t\t\"b\": tc.inB,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != res.(float64) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestFloat32 tests successful function execution\n// with float32 arguments and return value\n// Bug(sickyoon): float32 as an argument throws a panic\n// https://github.com/gocelery/gocelery/issues/75\nfunc TestFloat32(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      float32\n\t\tinB      float32\n\t\texpected float32\n\t}{\n\t\t{\n\t\t\tname:     \"float32 addition with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addFloat32,\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: float32(8.8268),\n\t\t},\n\t\t{\n\t\t\tname:     \"float32 addition with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addFloat32,\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: float32(8.8268),\n\t\t},\n\t\t{\n\t\t\tname:     \"float32 addition with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addFloat32,\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: 8.8268,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.Delay(tc.taskName, tc.inA, tc.inB)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != float32(res.(float64)) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestFloat32NamedArguments tests successful function execution\n// with float32 arguments and return value\n// Bug(sickyoon): float32 as an argument throws a panic\n// https://github.com/gocelery/gocelery/issues/75\nfunc TestFloat32NamedArguments(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      float32\n\t\tinB      float32\n\t\texpected float32\n\t}{\n\t\t{\n\t\t\tname:     \"float32 addition with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addFloat32Task{},\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: float32(8.8268),\n\t\t},\n\t\t{\n\t\t\tname:     \"float32 addition with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addFloat32Task{},\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: float32(8.8268),\n\t\t},\n\t\t{\n\t\t\tname:     \"float32 addition with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &addFloat32Task{},\n\t\t\tinA:      3.4580,\n\t\t\tinB:      5.3688,\n\t\t\texpected: float32(8.8268),\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.DelayKwargs(\n\t\t\ttc.taskName,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"a\": tc.inA,\n\t\t\t\t\"b\": tc.inB,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != float32(res.(float64)) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestBool tests successful function execution\n// with boolean arguments and return value\nfunc TestBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      bool\n\t\tinB      bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"boolean and operation with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: andBool,\n\t\t\tinA:      true,\n\t\t\tinB:      false,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"boolean and operation with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: andBool,\n\t\t\tinA:      true,\n\t\t\tinB:      false,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"boolean and operation with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: andBool,\n\t\t\tinA:      true,\n\t\t\tinB:      true,\n\t\t\texpected: true,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.Delay(tc.taskName, tc.inA, tc.inB)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != res.(bool) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestBoolNamedArguments tests successful function execution\n// with boolean arguments and return value\nfunc TestBoolNamedArguments(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      bool\n\t\tinB      bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"boolean and operation (named arguments) with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &andBoolTask{},\n\t\t\tinA:      true,\n\t\t\tinB:      false,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"boolean and operation (named arguments) with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &andBoolTask{},\n\t\t\tinA:      true,\n\t\t\tinB:      false,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"boolean and operation (named arguments) with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &andBoolTask{},\n\t\t\tinA:      true,\n\t\t\tinB:      true,\n\t\t\texpected: true,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.DelayKwargs(\n\t\t\ttc.taskName,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"a\": tc.inA,\n\t\t\t\t\"b\": tc.inB,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != res.(bool) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestArrayIntNamedArguments tests successful function execution\n// with array arguments and integer return value\nfunc TestArrayIntNamedArguments(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      []string\n\t\tinB      []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"maximum array length (named arguments) with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &maxArrLenTask{},\n\t\t\tinA:      []string{\"a\", \"b\", \"c\", \"d\"},\n\t\t\tinB:      []string{\"e\", \"f\", \"g\", \"h\"},\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"maximum array length (named arguments) with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &maxArrLenTask{},\n\t\t\tinA:      []string{\"a\", \"b\", \"c\", \"d\"},\n\t\t\tinB:      []string{\"e\", \"f\", \"g\", \"h\"},\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"maximum array length (named arguments) with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: &maxArrLenTask{},\n\t\t\tinA:      []string{\"a\", \"b\", \"c\", \"d\"},\n\t\t\tinB:      []string{\"e\", \"f\", \"g\", \"h\"},\n\t\t\texpected: 4,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.DelayKwargs(\n\t\t\ttc.taskName,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"a\": tc.inA,\n\t\t\t\t\"b\": tc.inB,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif tc.expected != int(res.(float64)) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestArray tests successful function execution\n// with array arguments and return value\nfunc TestArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      []string\n\t\tinB      []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\tname:     \"array addition with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addArr,\n\t\t\tinA:      []string{\"a\", \"b\", \"c\", \"d\"},\n\t\t\tinB:      []string{\"e\", \"f\", \"g\", \"h\"},\n\t\t\texpected: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"array addition with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addArr,\n\t\t\tinA:      []string{\"a\", \"b\", \"c\", \"d\"},\n\t\t\tinB:      []string{\"e\", \"f\", \"g\", \"h\"},\n\t\t\texpected: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"array addition with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addArr,\n\t\t\tinA:      []string{\"a\", \"b\", \"c\", \"d\"},\n\t\t\tinB:      []string{\"e\", \"f\", \"g\", \"h\"},\n\t\t\texpected: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.Delay(tc.taskName, tc.inA, tc.inB)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(tc.expected, convertInterfaceToStringSlice(res)) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// TestMap tests successful function execution\n// with map arguments and return value\nfunc TestMap(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tbroker   CeleryBroker\n\t\tbackend  CeleryBackend\n\t\ttaskName string\n\t\ttaskFunc interface{}\n\t\tinA      map[string]string\n\t\tinB      map[string]string\n\t\texpected map[string]string\n\t}{\n\t\t{\n\t\t\tname:     \"integer addition with redis broker/backend\",\n\t\t\tbroker:   redisBroker,\n\t\t\tbackend:  redisBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addMap,\n\t\t\tinA:      map[string]string{\"a\": \"a\"},\n\t\t\tinB:      map[string]string{\"b\": \"b\"},\n\t\t\texpected: map[string]string{\"a\": \"a\", \"b\": \"b\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"integer addition with redis broker/backend with connection\",\n\t\t\tbroker:   redisBrokerWithConn,\n\t\t\tbackend:  redisBackendWithConn,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addMap,\n\t\t\tinA:      map[string]string{\"a\": \"a\"},\n\t\t\tinB:      map[string]string{\"b\": \"b\"},\n\t\t\texpected: map[string]string{\"a\": \"a\", \"b\": \"b\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"integer addition with amqp broker/backend\",\n\t\t\tbroker:   amqpBroker,\n\t\t\tbackend:  amqpBackend,\n\t\t\ttaskName: uuid.Must(uuid.NewV4()).String(),\n\t\t\ttaskFunc: addMap,\n\t\t\tinA:      map[string]string{\"a\": \"a\"},\n\t\t\tinB:      map[string]string{\"b\": \"b\"},\n\t\t\texpected: map[string]string{\"a\": \"a\", \"b\": \"b\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tcli, _ := NewCeleryClient(tc.broker, tc.backend, 1)\n\t\tcli.Register(tc.taskName, tc.taskFunc)\n\t\tcli.StartWorker()\n\t\tasyncResult, err := cli.Delay(tc.taskName, tc.inA, tc.inB)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tres, err := asyncResult.Get(TIMEOUT)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to get result for task %s: %+v\", tc.name, tc.taskName, err)\n\t\t\tcli.StopWorker()\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(tc.expected, convertInterfaceToStringMap(res)) {\n\t\t\tt.Errorf(\"test '%s': returned result %+v is different from expected result %+v\", tc.name, res, tc.expected)\n\t\t}\n\t\tcli.StopWorker()\n\t}\n}\n\n// noArgTask accepts no function arguments\ntype noArgTask struct{}\n\n// ParseKwargs does nothing for noArgTask since there are no arguments to process\nfunc (a *noArgTask) ParseKwargs(kwargs map[string]interface{}) error {\n\treturn nil\n}\n\n// RunTask executes noArgTask example by returning hard-coded integer value 1\nfunc (a *noArgTask) RunTask() (interface{}, error) {\n\treturn 1, nil\n}\n\n// addInt returns sum of two integers\nfunc addInt(a, b int) int {\n\treturn a + b\n}\n\n// addIntTask returns sum of two integers\ntype addIntTask struct {\n\ta int\n\tb int\n}\n\n// ParseKwargs parses named arguments for addIntTask example\nfunc (a *addIntTask) ParseKwargs(kwargs map[string]interface{}) error {\n\tkwargA, ok := kwargs[\"a\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg a\")\n\t}\n\tkwargAFloat, ok := kwargA.(float64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg a\")\n\t}\n\ta.a = int(kwargAFloat)\n\tkwargB, ok := kwargs[\"b\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg b\")\n\t}\n\tkwargBFloat, ok := kwargB.(float64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg b\")\n\t}\n\ta.b = int(kwargBFloat)\n\treturn nil\n}\n\n// RunTask executes addIntTask example\nfunc (a *addIntTask) RunTask() (interface{}, error) {\n\tresult := a.a + a.b\n\treturn result, nil\n}\n\n// addStr concatenates two given strings\nfunc addStr(a, b string) string {\n\treturn a + b\n}\n\n// addStrTask concatenates two given strings\ntype addStrTask struct {\n\ta string\n\tb string\n}\n\nfunc (a *addStrTask) ParseKwargs(kwargs map[string]interface{}) error {\n\tkwargA, ok := kwargs[\"a\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg a\")\n\t}\n\ta.a, ok = kwargA.(string)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg a\")\n\t}\n\tkwargB, ok := kwargs[\"b\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg b\")\n\t}\n\ta.b, ok = kwargB.(string)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg b\")\n\t}\n\treturn nil\n}\n\nfunc (a *addStrTask) RunTask() (interface{}, error) {\n\treturn a.a + a.b, nil\n}\n\n// addStrInt concatenates string and integer\nfunc addStrInt(a string, b int) string {\n\treturn a + strconv.Itoa(b)\n}\n\n// addStrIntTask concatenates string and integer\ntype addStrIntTask struct {\n\ta string\n\tb int\n}\n\nfunc (a *addStrIntTask) ParseKwargs(kwargs map[string]interface{}) error {\n\tkwargA, ok := kwargs[\"a\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg a\")\n\t}\n\ta.a, ok = kwargA.(string)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg a\")\n\t}\n\tkwargB, ok := kwargs[\"b\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg b\")\n\t}\n\tkwargBFloat, ok := kwargB.(float64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg b\")\n\t}\n\ta.b = int(kwargBFloat)\n\treturn nil\n}\n\nfunc (a *addStrIntTask) RunTask() (interface{}, error) {\n\treturn a.a + strconv.Itoa(a.b), nil\n}\n\n// addFloat returns sum of two float64 values\nfunc addFloat(a, b float64) float64 {\n\treturn a + b\n}\n\n// addFloatTask returns sum of two float64 values\ntype addFloatTask struct {\n\ta float64\n\tb float64\n}\n\nfunc (a *addFloatTask) ParseKwargs(kwargs map[string]interface{}) error {\n\tkwargA, ok := kwargs[\"a\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg a\")\n\t}\n\ta.a, ok = kwargA.(float64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg a\")\n\t}\n\tkwargB, ok := kwargs[\"b\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg b\")\n\t}\n\ta.b, ok = kwargB.(float64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg b\")\n\t}\n\treturn nil\n}\n\nfunc (a *addFloatTask) RunTask() (interface{}, error) {\n\treturn a.a + a.b, nil\n}\n\n// Bug(sickyoon): float32 as am argument throws a panic\n// https://github.com/gocelery/gocelery/issues/75\n\n// addFloat32 returns sum of two float32 values\nfunc addFloat32(a, b float32) float32 {\n\treturn a + b\n}\n\n// addFloat32Task returns sum of two float32 values\ntype addFloat32Task struct {\n\ta float32\n\tb float32\n}\n\nfunc (a *addFloat32Task) ParseKwargs(kwargs map[string]interface{}) error {\n\tkwargA, ok := kwargs[\"a\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg a\")\n\t}\n\tkwargAFloat, ok := kwargA.(float64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg a\")\n\t}\n\ta.a = float32(kwargAFloat)\n\tkwargB, ok := kwargs[\"b\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg b\")\n\t}\n\tkwargBFloat, ok := kwargB.(float64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg b\")\n\t}\n\ta.b = float32(kwargBFloat)\n\treturn nil\n}\n\nfunc (a *addFloat32Task) RunTask() (interface{}, error) {\n\treturn a.a + a.b, nil\n}\n\n// andBool returns result of and operation of two given boolean values\nfunc andBool(a, b bool) bool {\n\treturn a && b\n}\n\n// andBoolTask returns result of and operation of two given boolean values\ntype andBoolTask struct {\n\ta bool\n\tb bool\n}\n\nfunc (a *andBoolTask) ParseKwargs(kwargs map[string]interface{}) error {\n\tkwargA, ok := kwargs[\"a\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg a\")\n\t}\n\ta.a, ok = kwargA.(bool)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg a\")\n\t}\n\tkwargB, ok := kwargs[\"b\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg b\")\n\t}\n\ta.b, ok = kwargB.(bool)\n\tif !ok {\n\t\treturn fmt.Errorf(\"malformed kwarg b\")\n\t}\n\treturn nil\n\n}\n\nfunc (a *andBoolTask) RunTask() (interface{}, error) {\n\treturn a.a && a.b, nil\n}\n\n// maxArrLenTask returns maximum length of two given arrays\ntype maxArrLenTask struct {\n\ta []string\n\tb []string\n}\n\n// ParseKwargs parses named arguments for maxArrLenTask\nfunc (m *maxArrLenTask) ParseKwargs(kwargs map[string]interface{}) error {\n\tkwargA, ok := kwargs[\"a\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg a\")\n\t}\n\tm.a = convertInterfaceToStringSlice(kwargA)\n\tkwargB, ok := kwargs[\"b\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"undefined kwarg b\")\n\t}\n\tm.b = convertInterfaceToStringSlice(kwargB)\n\treturn nil\n}\n\n// RunTask returns maximum length of two given arrays from maxArrLenTask struct\nfunc (m *maxArrLenTask) RunTask() (interface{}, error) {\n\tif len(m.a) > len(m.b) {\n\t\treturn len(m.a), nil\n\t}\n\treturn len(m.b), nil\n}\n\n// addArr concatenates two slices together\nfunc addArr(a, b []interface{}) []interface{} {\n\treturn append(a, b...)\n}\n\n// addMap concatenates two maps together\nfunc addMap(a, b map[string]interface{}) map[string]interface{} {\n\tc := map[string]interface{}{}\n\tfor k, v := range a {\n\t\tc[k] = v\n\t}\n\tfor k, v := range b {\n\t\tc[k] = v\n\t}\n\treturn c\n}\n\nfunc convertInterfaceToStringSlice(i interface{}) []string {\n\tis := i.([]interface{})\n\tstringSlice := make([]string, len(is))\n\tfor i, v := range is {\n\t\tstringSlice[i] = fmt.Sprint(v)\n\t}\n\treturn stringSlice\n}\n\nfunc convertInterfaceToStringMap(i interface{}) map[string]string {\n\tim := i.(map[string]interface{})\n\tstringMap := make(map[string]string, len(im))\n\tfor i, v := range im {\n\t\tstringMap[i] = fmt.Sprint(v)\n\t}\n\treturn stringMap\n}"
        },
        {
          "name": "message.go",
          "type": "blob",
          "size": 5.666015625,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"reflect\"\n\t\"sync\"\n\t\"time\"\n\n\tuuid \"github.com/satori/go.uuid\"\n)\n\n// CeleryMessage is actual message to be sent to Redis\ntype CeleryMessage struct {\n\tBody            string                 `json:\"body\"`\n\tHeaders         map[string]interface{} `json:\"headers,omitempty\"`\n\tContentType     string                 `json:\"content-type\"`\n\tProperties      CeleryProperties       `json:\"properties\"`\n\tContentEncoding string                 `json:\"content-encoding\"`\n}\n\nfunc (cm *CeleryMessage) reset() {\n\tcm.Headers = nil\n\tcm.Body = \"\"\n\tcm.Properties.CorrelationID = uuid.Must(uuid.NewV4()).String()\n\tcm.Properties.ReplyTo = uuid.Must(uuid.NewV4()).String()\n\tcm.Properties.DeliveryTag = uuid.Must(uuid.NewV4()).String()\n}\n\nvar celeryMessagePool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn &CeleryMessage{\n\t\t\tBody:        \"\",\n\t\t\tHeaders:     nil,\n\t\t\tContentType: \"application/json\",\n\t\t\tProperties: CeleryProperties{\n\t\t\t\tBodyEncoding:  \"base64\",\n\t\t\t\tCorrelationID: uuid.Must(uuid.NewV4()).String(),\n\t\t\t\tReplyTo:       uuid.Must(uuid.NewV4()).String(),\n\t\t\t\tDeliveryInfo: CeleryDeliveryInfo{\n\t\t\t\t\tPriority:   0,\n\t\t\t\t\tRoutingKey: \"celery\",\n\t\t\t\t\tExchange:   \"celery\",\n\t\t\t\t},\n\t\t\t\tDeliveryMode: 2,\n\t\t\t\tDeliveryTag:  uuid.Must(uuid.NewV4()).String(),\n\t\t\t},\n\t\t\tContentEncoding: \"utf-8\",\n\t\t}\n\t},\n}\n\nfunc getCeleryMessage(encodedTaskMessage string) *CeleryMessage {\n\tmsg := celeryMessagePool.Get().(*CeleryMessage)\n\tmsg.Body = encodedTaskMessage\n\treturn msg\n}\n\nfunc releaseCeleryMessage(v *CeleryMessage) {\n\tv.reset()\n\tceleryMessagePool.Put(v)\n}\n\n// CeleryProperties represents properties json\ntype CeleryProperties struct {\n\tBodyEncoding  string             `json:\"body_encoding\"`\n\tCorrelationID string             `json:\"correlation_id\"`\n\tReplyTo       string             `json:\"reply_to\"`\n\tDeliveryInfo  CeleryDeliveryInfo `json:\"delivery_info\"`\n\tDeliveryMode  int                `json:\"delivery_mode\"`\n\tDeliveryTag   string             `json:\"delivery_tag\"`\n}\n\n// CeleryDeliveryInfo represents deliveryinfo json\ntype CeleryDeliveryInfo struct {\n\tPriority   int    `json:\"priority\"`\n\tRoutingKey string `json:\"routing_key\"`\n\tExchange   string `json:\"exchange\"`\n}\n\n// GetTaskMessage retrieve and decode task messages from broker\nfunc (cm *CeleryMessage) GetTaskMessage() *TaskMessage {\n\t// ensure content-type is 'application/json'\n\tif cm.ContentType != \"application/json\" {\n\t\tlog.Println(\"unsupported content type \" + cm.ContentType)\n\t\treturn nil\n\t}\n\t// ensure body encoding is base64\n\tif cm.Properties.BodyEncoding != \"base64\" {\n\t\tlog.Println(\"unsupported body encoding \" + cm.Properties.BodyEncoding)\n\t\treturn nil\n\t}\n\t// ensure content encoding is utf-8\n\tif cm.ContentEncoding != \"utf-8\" {\n\t\tlog.Println(\"unsupported encoding \" + cm.ContentEncoding)\n\t\treturn nil\n\t}\n\t// decode body\n\ttaskMessage, err := DecodeTaskMessage(cm.Body)\n\tif err != nil {\n\t\tlog.Println(\"failed to decode task message\")\n\t\treturn nil\n\t}\n\treturn taskMessage\n}\n\n// TaskMessage is celery-compatible message\ntype TaskMessage struct {\n\tID      string                 `json:\"id\"`\n\tTask    string                 `json:\"task\"`\n\tArgs    []interface{}          `json:\"args\"`\n\tKwargs  map[string]interface{} `json:\"kwargs\"`\n\tRetries int                    `json:\"retries\"`\n\tETA     *string                `json:\"eta\"`\n\tExpires *time.Time             `json:\"expires\"`\n}\n\nfunc (tm *TaskMessage) reset() {\n\ttm.ID = uuid.Must(uuid.NewV4()).String()\n\ttm.Task = \"\"\n\ttm.Args = nil\n\ttm.Kwargs = nil\n}\n\nvar taskMessagePool = sync.Pool{\n\tNew: func() interface{} {\n\t\teta := time.Now().Format(time.RFC3339)\n\t\treturn &TaskMessage{\n\t\t\tID:      uuid.Must(uuid.NewV4()).String(),\n\t\t\tRetries: 0,\n\t\t\tKwargs:  nil,\n\t\t\tETA:     &eta,\n\t\t}\n\t},\n}\n\nfunc getTaskMessage(task string) *TaskMessage {\n\tmsg := taskMessagePool.Get().(*TaskMessage)\n\tmsg.Task = task\n\tmsg.Args = make([]interface{}, 0)\n\tmsg.Kwargs = make(map[string]interface{})\n\tmsg.ETA = nil\n\treturn msg\n}\n\nfunc releaseTaskMessage(v *TaskMessage) {\n\tv.reset()\n\ttaskMessagePool.Put(v)\n}\n\n// DecodeTaskMessage decodes base64 encrypted body and return TaskMessage object\nfunc DecodeTaskMessage(encodedBody string) (*TaskMessage, error) {\n\tbody, err := base64.StdEncoding.DecodeString(encodedBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmessage := taskMessagePool.Get().(*TaskMessage)\n\terr = json.Unmarshal(body, message)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn message, nil\n}\n\n// Encode returns base64 json encoded string\nfunc (tm *TaskMessage) Encode() (string, error) {\n\tif tm.Args == nil {\n\t\ttm.Args = make([]interface{}, 0)\n\t}\n\tjsonData, err := json.Marshal(tm)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tencodedData := base64.StdEncoding.EncodeToString(jsonData)\n\treturn encodedData, err\n}\n\n// ResultMessage is return message received from broker\ntype ResultMessage struct {\n\tID        string        `json:\"task_id\"`\n\tStatus    string        `json:\"status\"`\n\tTraceback interface{}   `json:\"traceback\"`\n\tResult    interface{}   `json:\"result\"`\n\tChildren  []interface{} `json:\"children\"`\n}\n\nfunc (rm *ResultMessage) reset() {\n\trm.Result = nil\n}\n\nvar resultMessagePool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn &ResultMessage{\n\t\t\tStatus:    \"SUCCESS\",\n\t\t\tTraceback: nil,\n\t\t\tChildren:  nil,\n\t\t}\n\t},\n}\n\nfunc getResultMessage(val interface{}) *ResultMessage {\n\tmsg := resultMessagePool.Get().(*ResultMessage)\n\tmsg.Result = val\n\treturn msg\n}\n\nfunc getReflectionResultMessage(val *reflect.Value) *ResultMessage {\n\tmsg := resultMessagePool.Get().(*ResultMessage)\n\tmsg.Result = GetRealValue(val)\n\treturn msg\n}\n\nfunc releaseResultMessage(v *ResultMessage) {\n\tv.reset()\n\tresultMessagePool.Put(v)\n}\n"
        },
        {
          "name": "redis_backend.go",
          "type": "blob",
          "size": 1.740234375,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\n// RedisCeleryBackend is celery backend for redis\ntype RedisCeleryBackend struct {\n\t*redis.Pool\n}\n\n// NewRedisBackend creates new RedisCeleryBackend with given redis pool.\n// RedisCeleryBackend can be initialized manually as well.\nfunc NewRedisBackend(conn *redis.Pool) *RedisCeleryBackend {\n\treturn &RedisCeleryBackend{\n\t\tPool: conn,\n\t}\n}\n\n// NewRedisCeleryBackend creates new RedisCeleryBackend\n//\n// Deprecated: NewRedisCeleryBackend exists for historical compatibility\n// and should not be used. Pool should be initialized outside of gocelery package.\nfunc NewRedisCeleryBackend(uri string) *RedisCeleryBackend {\n\treturn &RedisCeleryBackend{\n\t\tPool: NewRedisPool(uri),\n\t}\n}\n\n// GetResult queries redis backend to get asynchronous result\nfunc (cb *RedisCeleryBackend) GetResult(taskID string) (*ResultMessage, error) {\n\tconn := cb.Get()\n\tdefer conn.Close()\n\tval, err := conn.Do(\"GET\", fmt.Sprintf(\"celery-task-meta-%s\", taskID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif val == nil {\n\t\treturn nil, fmt.Errorf(\"result not available\")\n\t}\n\tvar resultMessage ResultMessage\n\terr = json.Unmarshal(val.([]byte), &resultMessage)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &resultMessage, nil\n}\n\n// SetResult pushes result back into redis backend\nfunc (cb *RedisCeleryBackend) SetResult(taskID string, result *ResultMessage) error {\n\tresBytes, err := json.Marshal(result)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := cb.Get()\n\tdefer conn.Close()\n\t_, err = conn.Do(\"SETEX\", fmt.Sprintf(\"celery-task-meta-%s\", taskID), 86400, resBytes)\n\treturn err\n}\n"
        },
        {
          "name": "redis_broker.go",
          "type": "blob",
          "size": 2.7626953125,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/gomodule/redigo/redis\"\n)\n\n// RedisCeleryBroker is celery broker for redis\ntype RedisCeleryBroker struct {\n\t*redis.Pool\n\tQueueName string\n}\n\n// NewRedisBroker creates new RedisCeleryBroker with given redis connection pool\nfunc NewRedisBroker(conn *redis.Pool) *RedisCeleryBroker {\n\treturn &RedisCeleryBroker{\n\t\tPool:      conn,\n\t\tQueueName: \"celery\",\n\t}\n}\n\n// NewRedisCeleryBroker creates new RedisCeleryBroker based on given uri\n//\n// Deprecated: NewRedisCeleryBroker exists for historical compatibility\n// and should not be used. Use NewRedisBroker instead to create new RedisCeleryBroker.\nfunc NewRedisCeleryBroker(uri string) *RedisCeleryBroker {\n\treturn &RedisCeleryBroker{\n\t\tPool:      NewRedisPool(uri),\n\t\tQueueName: \"celery\",\n\t}\n}\n\n// SendCeleryMessage sends CeleryMessage to redis queue\nfunc (cb *RedisCeleryBroker) SendCeleryMessage(message *CeleryMessage) error {\n\tjsonBytes, err := json.Marshal(message)\n\tif err != nil {\n\t\treturn err\n\t}\n\tconn := cb.Get()\n\tdefer conn.Close()\n\t_, err = conn.Do(\"LPUSH\", cb.QueueName, jsonBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// GetCeleryMessage retrieves celery message from redis queue\nfunc (cb *RedisCeleryBroker) GetCeleryMessage() (*CeleryMessage, error) {\n\tconn := cb.Get()\n\tdefer conn.Close()\n\tmessageJSON, err := conn.Do(\"BRPOP\", cb.QueueName, \"1\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif messageJSON == nil {\n\t\treturn nil, fmt.Errorf(\"null message received from redis\")\n\t}\n\tmessageList := messageJSON.([]interface{})\n\tif string(messageList[0].([]byte)) != cb.QueueName {\n\t\treturn nil, fmt.Errorf(\"not a celery message: %v\", messageList[0])\n\t}\n\tvar message CeleryMessage\n\tif err := json.Unmarshal(messageList[1].([]byte), &message); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &message, nil\n}\n\n// GetTaskMessage retrieves task message from redis queue\nfunc (cb *RedisCeleryBroker) GetTaskMessage() (*TaskMessage, error) {\n\tceleryMessage, err := cb.GetCeleryMessage()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn celeryMessage.GetTaskMessage(), nil\n}\n\n// NewRedisPool creates pool of redis connections from given connection string\n//\n// Deprecated: newRedisPool exists for historical compatibility\n// and should not be used. Pool should be initialized outside of gocelery package.\nfunc NewRedisPool(uri string) *redis.Pool {\n\treturn &redis.Pool{\n\t\tMaxIdle:     3,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(uri)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\t_, err := c.Do(\"PING\")\n\t\t\treturn err\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "worker.go",
          "type": "blob",
          "size": 4.787109375,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"reflect\"\n\t\"sync\"\n\t\"time\"\n)\n\n// CeleryWorker represents distributed task worker\ntype CeleryWorker struct {\n\tbroker          CeleryBroker\n\tbackend         CeleryBackend\n\tnumWorkers      int\n\tregisteredTasks map[string]interface{}\n\ttaskLock        sync.RWMutex\n\tcancel          context.CancelFunc\n\tworkWG          sync.WaitGroup\n\trateLimitPeriod time.Duration\n}\n\n// NewCeleryWorker returns new celery worker\nfunc NewCeleryWorker(broker CeleryBroker, backend CeleryBackend, numWorkers int) *CeleryWorker {\n\treturn &CeleryWorker{\n\t\tbroker:          broker,\n\t\tbackend:         backend,\n\t\tnumWorkers:      numWorkers,\n\t\tregisteredTasks: map[string]interface{}{},\n\t\trateLimitPeriod: 100 * time.Millisecond,\n\t}\n}\n\n// StartWorkerWithContext starts celery worker(s) with given parent context\nfunc (w *CeleryWorker) StartWorkerWithContext(ctx context.Context) {\n\tvar wctx context.Context\n\twctx, w.cancel = context.WithCancel(ctx)\n\tw.workWG.Add(w.numWorkers)\n\tfor i := 0; i < w.numWorkers; i++ {\n\t\tgo func(workerID int) {\n\t\t\tdefer w.workWG.Done()\n\t\t\tticker := time.NewTicker(w.rateLimitPeriod)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-wctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\t// process task request\n\t\t\t\t\ttaskMessage, err := w.broker.GetTaskMessage()\n\t\t\t\t\tif err != nil || taskMessage == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// run task\n\t\t\t\t\tresultMsg, err := w.RunTask(taskMessage)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Printf(\"failed to run task message %s: %+v\", taskMessage.ID, err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tdefer releaseResultMessage(resultMsg)\n\n\t\t\t\t\t// push result to backend\n\t\t\t\t\terr = w.backend.SetResult(taskMessage.ID, resultMsg)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Printf(\"failed to push result: %+v\", err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n}\n\n// StartWorker starts celery workers\nfunc (w *CeleryWorker) StartWorker() {\n\tw.StartWorkerWithContext(context.Background())\n}\n\n// StopWorker stops celery workers\nfunc (w *CeleryWorker) StopWorker() {\n\tw.cancel()\n\tw.workWG.Wait()\n}\n\n// StopWait waits for celery workers to terminate\nfunc (w *CeleryWorker) StopWait() {\n\tw.workWG.Wait()\n}\n\n// GetNumWorkers returns number of currently running workers\nfunc (w *CeleryWorker) GetNumWorkers() int {\n\treturn w.numWorkers\n}\n\n// Register registers tasks (functions)\nfunc (w *CeleryWorker) Register(name string, task interface{}) {\n\tw.taskLock.Lock()\n\tw.registeredTasks[name] = task\n\tw.taskLock.Unlock()\n}\n\n// GetTask retrieves registered task\nfunc (w *CeleryWorker) GetTask(name string) interface{} {\n\tw.taskLock.RLock()\n\ttask, ok := w.registeredTasks[name]\n\tif !ok {\n\t\tw.taskLock.RUnlock()\n\t\treturn nil\n\t}\n\tw.taskLock.RUnlock()\n\treturn task\n}\n\n// RunTask runs celery task\nfunc (w *CeleryWorker) RunTask(message *TaskMessage) (*ResultMessage, error) {\n\n\t// ignore if the message is expired\n\tif message.Expires != nil && message.Expires.UTC().Before(time.Now().UTC()) {\n\t\treturn nil, fmt.Errorf(\"task %s is expired on %s\", message.ID, message.Expires)\n\t}\n\n\t// check for malformed task message - args cannot be nil\n\tif message.Args == nil {\n\t\treturn nil, fmt.Errorf(\"task %s is malformed - args cannot be nil\", message.ID)\n\t}\n\n\t// get task\n\ttask := w.GetTask(message.Task)\n\tif task == nil {\n\t\treturn nil, fmt.Errorf(\"task %s is not registered\", message.Task)\n\t}\n\n\t// convert to task interface\n\ttaskInterface, ok := task.(CeleryTask)\n\tif ok {\n\t\tif err := taskInterface.ParseKwargs(message.Kwargs); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tval, err := taskInterface.RunTask()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn getResultMessage(val), err\n\t}\n\n\t// use reflection to execute function ptr\n\ttaskFunc := reflect.ValueOf(task)\n\treturn runTaskFunc(&taskFunc, message)\n}\n\nfunc runTaskFunc(taskFunc *reflect.Value, message *TaskMessage) (*ResultMessage, error) {\n\n\t// check number of arguments\n\tnumArgs := taskFunc.Type().NumIn()\n\tmessageNumArgs := len(message.Args)\n\tif numArgs != messageNumArgs {\n\t\treturn nil, fmt.Errorf(\"Number of task arguments %d does not match number of message arguments %d\", numArgs, messageNumArgs)\n\t}\n\n\t// construct arguments\n\tin := make([]reflect.Value, messageNumArgs)\n\tfor i, arg := range message.Args {\n\t\torigType := taskFunc.Type().In(i).Kind()\n\t\tmsgType := reflect.TypeOf(arg).Kind()\n\t\t// special case - convert float64 to int if applicable\n\t\t// this is due to json limitation where all numbers are converted to float64\n\t\tif origType == reflect.Int && msgType == reflect.Float64 {\n\t\t\targ = int(arg.(float64))\n\t\t}\n\t\tif origType == reflect.Float32 && msgType == reflect.Float64 {\n\t\t\targ = float32(arg.(float64))\n\t\t}\n\n\t\tin[i] = reflect.ValueOf(arg)\n\t}\n\n\t// call method\n\tres := taskFunc.Call(in)\n\tif len(res) == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn getReflectionResultMessage(&res[0]), nil\n}\n"
        },
        {
          "name": "worker_test.go",
          "type": "blob",
          "size": 5.826171875,
          "content": "// Copyright (c) 2019 Sick Yoon\n// This file is part of gocelery which is released under MIT license.\n// See file LICENSE for full license details.\n\npackage gocelery\n\nimport (\n\t\"context\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\tuuid \"github.com/satori/go.uuid\"\n)\n\n// add is test task method\nfunc add(a int, b int) int {\n\treturn a + b\n}\n\n// TestWorkerRegisterTask tests whether a task can be registered and retrieved correctly\nfunc TestWorkerRegisterTask(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tbroker         CeleryBroker\n\t\tbackend        CeleryBackend\n\t\tregisteredTask interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"register task with redis broker/backend\",\n\t\t\tbroker:         redisBroker,\n\t\t\tbackend:        redisBackend,\n\t\t\tregisteredTask: add,\n\t\t},\n\t\t{\n\t\t\tname:           \"register task with amqp broker/backend\",\n\t\t\tbroker:         amqpBroker,\n\t\t\tbackend:        amqpBackend,\n\t\t\tregisteredTask: add,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tceleryWorker := NewCeleryWorker(tc.broker, tc.backend, 1)\n\t\ttaskName := uuid.Must(uuid.NewV4()).String()\n\t\tceleryWorker.Register(taskName, tc.registeredTask)\n\t\treceivedTask := celeryWorker.GetTask(taskName)\n\t\tif !reflect.DeepEqual(\n\t\t\treflect.ValueOf(receivedTask),\n\t\t\treflect.ValueOf(tc.registeredTask),\n\t\t) {\n\t\t\tt.Errorf(\"test '%s': expected registered task %+v but received %+v\", tc.name, tc.registeredTask, receivedTask)\n\t\t}\n\t}\n}\n\n// TestWorkerRunTask tests successful function execution\nfunc TestWorkerRunTask(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tbroker         CeleryBroker\n\t\tbackend        CeleryBackend\n\t\tregisteredTask interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"run task with redis broker/backend\",\n\t\t\tbroker:         redisBroker,\n\t\t\tbackend:        redisBackend,\n\t\t\tregisteredTask: add,\n\t\t},\n\t\t{\n\t\t\tname:           \"run task with amqp broker/backend\",\n\t\t\tbroker:         amqpBroker,\n\t\t\tbackend:        amqpBackend,\n\t\t\tregisteredTask: add,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tceleryWorker := NewCeleryWorker(tc.broker, tc.backend, 1)\n\t\ttaskName := uuid.Must(uuid.NewV4()).String()\n\t\tceleryWorker.Register(taskName, tc.registeredTask)\n\t\targs := []interface{}{\n\t\t\trand.Int(),\n\t\t\trand.Int(),\n\t\t}\n\t\tres := add(args[0].(int), args[1].(int))\n\t\ttaskMessage := &TaskMessage{\n\t\t\tID:      uuid.Must(uuid.NewV4()).String(),\n\t\t\tTask:    taskName,\n\t\t\tArgs:    args,\n\t\t\tKwargs:  nil,\n\t\t\tRetries: 1,\n\t\t\tETA:     nil,\n\t\t}\n\t\tresultMsg, err := celeryWorker.RunTask(taskMessage)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test '%s': failed to run celery task %v: %v\", tc.name, taskMessage, err)\n\t\t\tcontinue\n\t\t}\n\t\treflectRes := resultMsg.Result.(int64)\n\t\tif int64(res) != reflectRes {\n\t\t\tt.Errorf(\"test '%s': reflect result %v is different from normal result %v\", tc.name, reflectRes, res)\n\t\t}\n\t}\n}\n\n// TestWorkerExpiredTask tests expired tasks\nfunc TestWorkerExpiredTask(t *testing.T) {\n\tnow := time.Now()\n\ttestCases := []struct {\n\t\tname           string\n\t\tbroker         CeleryBroker\n\t\tbackend        CeleryBackend\n\t\texpires        *time.Time\n\t\tregisteredTask interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"run expired task with redis broker/backend\",\n\t\t\tbroker:         redisBroker,\n\t\t\tbackend:        redisBackend,\n\t\t\texpires:        &now,\n\t\t\tregisteredTask: add,\n\t\t},\n\t\t{\n\t\t\tname:           \"run expired task with amqp broker/backend\",\n\t\t\tbroker:         amqpBroker,\n\t\t\tbackend:        amqpBackend,\n\t\t\texpires:        &now,\n\t\t\tregisteredTask: add,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tceleryWorker := NewCeleryWorker(tc.broker, tc.backend, 1)\n\t\ttaskName := uuid.Must(uuid.NewV4()).String()\n\t\tceleryWorker.Register(taskName, tc.registeredTask)\n\t\targs := []interface{}{\n\t\t\trand.Int(),\n\t\t\trand.Int(),\n\t\t}\n\t\ttaskMessage := &TaskMessage{\n\t\t\tID:      uuid.Must(uuid.NewV4()).String(),\n\t\t\tTask:    taskName,\n\t\t\tArgs:    args,\n\t\t\tKwargs:  nil,\n\t\t\tRetries: 1,\n\t\t\tETA:     nil,\n\t\t\tExpires: tc.expires,\n\t\t}\n\t\tif _, err := celeryWorker.RunTask(taskMessage); err == nil {\n\t\t\tt.Errorf(\"test '%s': expired task was not ignored\", tc.name)\n\t\t}\n\t}\n}\n\n// TestWorkerNumWorkers ensures correct number of workers is set\nfunc TestWorkerNumWorkers(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tbroker  CeleryBroker\n\t\tbackend CeleryBackend\n\t}{\n\t\t{\n\t\t\tname:    \"ensure correct number of workers with redis broker/backend\",\n\t\t\tbroker:  redisBroker,\n\t\t\tbackend: redisBackend,\n\t\t},\n\t\t{\n\t\t\tname:    \"ensure correct number of workers with amqp broker/backend\",\n\t\t\tbroker:  amqpBroker,\n\t\t\tbackend: amqpBackend,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tnumWorkers := rand.Intn(10)\n\t\tceleryWorker := NewCeleryWorker(tc.broker, tc.backend, numWorkers)\n\t\tceleryNumWorkers := celeryWorker.GetNumWorkers()\n\t\tif numWorkers != celeryNumWorkers {\n\t\t\tt.Errorf(\"test '%s': number of workers are different: %d vs %d\", tc.name, numWorkers, celeryNumWorkers)\n\t\t}\n\t}\n}\n\n// TestWorkerStartStop tests starting and stopping workers\n// and gracefully wait for all workers to terminate\n// ensure test timeout is set to avoid hanging\nfunc TestWorkerStartStop(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tbroker  CeleryBroker\n\t\tbackend CeleryBackend\n\t}{\n\t\t{\n\t\t\tname:    \"start and gracefully stop workers with redis broker/backend\",\n\t\t\tbroker:  redisBroker,\n\t\t\tbackend: redisBackend,\n\t\t},\n\t\t{\n\t\t\tname:    \"start and gracefully stop workers with amqp broker/backend\",\n\t\t\tbroker:  amqpBroker,\n\t\t\tbackend: amqpBackend,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tceleryWorker := NewCeleryWorker(tc.broker, tc.backend, 1000)\n\t\tgo celeryWorker.StartWorker()\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tctx, cancel := context.WithTimeout(context.Background(), 20*time.Second)\n\t\tgo func() {\n\t\t\tceleryWorker.StopWorker()\n\t\t\tcancel()\n\t\t}()\n\t\tfunc() {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tif ctx.Err() != context.Canceled {\n\t\t\t\t\t\tt.Errorf(\"test '%s': failed to stop celery workers in time: %+v\", tc.name, ctx.Err())\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n}\n"
        }
      ]
    }
  ]
}