{
  "metadata": {
    "timestamp": 1736567337508,
    "page": 949,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "alexedwards/scs",
      "stars": 2205,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.07421875,
          "content": "language: go\n\ngo:\n- 1.13.x\n- 1.14.x\n- 1.15.x\n- tip\n\nscript: go test -race .\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Alex Edwards\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.2392578125,
          "content": "# SCS: HTTP Session Management for Go\n\n[![GoDoc](https://godoc.org/github.com/alexedwards/scs?status.png)](https://pkg.go.dev/github.com/alexedwards/scs/v2?tab=doc)\n[![Go report card](https://goreportcard.com/badge/github.com/alexedwards/scs)](https://goreportcard.com/report/github.com/alexedwards/scs)\n[![Test coverage](http://gocover.io/_badge/github.com/alexedwards/scs)](https://gocover.io/github.com/alexedwards/scs)\n\n## Features\n\n- Automatic loading and saving of session data via middleware.\n- Choice of 19 different server-side session stores including PostgreSQL, MySQL, MSSQL, SQLite, Redis and many others. Custom session stores are also supported.\n- Supports multiple sessions per request, 'flash' messages, session token regeneration, idle and absolute session timeouts, and 'remember me' functionality.\n- Easy to extend and customize. Communicate session tokens to/from clients in HTTP headers or request/response bodies.\n- Efficient design. Smaller, faster and uses less memory than [gorilla/sessions](https://github.com/gorilla/sessions).\n\n## Instructions\n\n- [SCS: HTTP Session Management for Go](#scs-http-session-management-for-go)\n  - [Features](#features)\n  - [Instructions](#instructions)\n    - [Installation](#installation)\n    - [Basic Use](#basic-use)\n    - [Configuring Session Behavior](#configuring-session-behavior)\n    - [Working with Session Data](#working-with-session-data)\n    - [Loading and Saving Sessions](#loading-and-saving-sessions)\n    - [Configuring the Session Store](#configuring-the-session-store)\n    - [Using Custom Session Stores](#using-custom-session-stores)\n      - [Using Custom Session Stores (with context.Context)](#using-custom-session-stores-with-contextcontext)\n    - [Multiple Sessions per Request](#multiple-sessions-per-request)\n    - [Enumerate All Sessions](#enumerate-all-sessions)\n    - [Flushing and Streaming Responses](#flushing-and-streaming-responses)\n    - [Compatibility](#compatibility)\n    - [Contributing](#contributing)\n\n### Installation\n\nThis package requires Go 1.12 or newer.\n\n```sh\ngo get github.com/alexedwards/scs/v2\n```\n\nNote: If you're using the traditional `GOPATH` mechanism to manage dependencies, instead of modules, you'll need to `go get` and `import` `github.com/alexedwards/scs` without the `v2` suffix.\n\nPlease use [versioned releases](https://github.com/alexedwards/scs/releases). Code in tip may contain experimental features which are subject to change.\n\n### Basic Use\n\nSCS implements a session management pattern following the [OWASP security guidelines](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Session_Management_Cheat_Sheet.md). Session data is stored on the server, and a randomly-generated unique session token (or _session ID_) is communicated to and from the client in a session cookie.\n\n```go\npackage main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/alexedwards/scs/v2\"\n)\n\nvar sessionManager *scs.SessionManager\n\nfunc main() {\n\t// Initialize a new session manager and configure the session lifetime.\n\tsessionManager = scs.New()\n\tsessionManager.Lifetime = 24 * time.Hour\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/put\", putHandler)\n\tmux.HandleFunc(\"/get\", getHandler)\n\n\t// Wrap your handlers with the LoadAndSave() middleware.\n\thttp.ListenAndServe(\":4000\", sessionManager.LoadAndSave(mux))\n}\n\nfunc putHandler(w http.ResponseWriter, r *http.Request) {\n\t// Store a new key and value in the session data.\n\tsessionManager.Put(r.Context(), \"message\", \"Hello from a session!\")\n}\n\nfunc getHandler(w http.ResponseWriter, r *http.Request) {\n\t// Use the GetString helper to retrieve the string value associated with a\n\t// key. The zero value is returned if the key does not exist.\n\tmsg := sessionManager.GetString(r.Context(), \"message\")\n\tio.WriteString(w, msg)\n}\n```\n\n```\n$ curl -i --cookie-jar cj --cookie cj localhost:4000/put\nHTTP/1.1 200 OK\nCache-Control: no-cache=\"Set-Cookie\"\nSet-Cookie: session=lHqcPNiQp_5diPxumzOklsSdE-MJ7zyU6kjch1Ee0UM; Path=/; Expires=Sat, 27 Apr 2019 10:28:20 GMT; Max-Age=86400; HttpOnly; SameSite=Lax\nVary: Cookie\nDate: Fri, 26 Apr 2019 10:28:19 GMT\nContent-Length: 0\n\n$ curl -i --cookie-jar cj --cookie cj localhost:4000/get\nHTTP/1.1 200 OK\nDate: Fri, 26 Apr 2019 10:28:24 GMT\nContent-Length: 21\nContent-Type: text/plain; charset=utf-8\n\nHello from a session!\n```\n\n### Configuring Session Behavior\n\nSession behavior can be configured via the `SessionManager` fields.\n\n```go\nsessionManager = scs.New()\nsessionManager.Lifetime = 3 * time.Hour\nsessionManager.IdleTimeout = 20 * time.Minute\nsessionManager.Cookie.Name = \"session_id\"\nsessionManager.Cookie.Domain = \"example.com\"\nsessionManager.Cookie.HttpOnly = true\nsessionManager.Cookie.Path = \"/example/\"\nsessionManager.Cookie.Persist = true\nsessionManager.Cookie.SameSite = http.SameSiteStrictMode\nsessionManager.Cookie.Secure = true\n```\n\nDocumentation for all available settings and their default values can be [found here](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager).\n\n### Working with Session Data\n\nData can be set using the [`Put()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.Put) method and retrieved with the [`Get()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.Get) method. A variety of helper methods like [`GetString()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.GetString), [`GetInt()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.GetInt) and [`GetBytes()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.GetBytes) are included for common data types. Please see [the documentation](https://pkg.go.dev/github.com/alexedwards/scs/v2#pkg-index) for a full list of helper methods.\n\nThe [`Pop()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.Pop) method (and accompanying helpers for common data types) act like a one-time `Get()`, retrieving the data and removing it from the session in one step. These are useful if you want to implement 'flash' message functionality in your application, where messages are displayed to the user once only.\n\nSome other useful functions are [`Exists()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.Exists) (which returns a `bool` indicating whether or not a given key exists in the session data) and [`Keys()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.Keys) (which returns a sorted slice of keys in the session data).\n\nIndividual data items can be deleted from the session using the [`Remove()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.Remove) method. Alternatively, all session data can be deleted by using the [`Destroy()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.Destroy) method. After calling `Destroy()`, any further operations in the same request cycle will result in a new session being created --- with a new session token and a new lifetime.\n\nBehind the scenes SCS uses gob encoding to store session data, so if you want to store custom types in the session data they must be [registered](https://golang.org/pkg/encoding/gob/#Register) with the encoding/gob package first. Struct fields of custom types must also be exported so that they are visible to the encoding/gob package. Please [see here](https://gist.github.com/alexedwards/d6eca7136f98ec12ad606e774d3abad3) for a working example.\n\n### Loading and Saving Sessions\n\nMost applications will use the [`LoadAndSave()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.LoadAndSave) middleware. This middleware takes care of loading and committing session data to the session store, and communicating the session token to/from the client in a cookie as necessary.\n\nIf you want to customize the behavior (like communicating the session token to/from the client in a HTTP header, or creating a distributed lock on the session token for the duration of the request) you are encouraged to create your own alternative middleware using the code in [`LoadAndSave()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.LoadAndSave) as a template. An example is [given here](https://gist.github.com/alexedwards/cc6190195acfa466bf27f05aa5023f50).\n\nOr for more fine-grained control you can load and save sessions within your individual handlers (or from anywhere in your application). [See here](https://gist.github.com/alexedwards/0570e5a59677e278e13acb8ea53a3b30) for an example.\n\n### Configuring the Session Store\n\nBy default SCS uses an in-memory store for session data. This is convenient (no setup!) and very fast, but all session data will be lost when your application is stopped or restarted. Therefore it's useful for applications where data loss is an acceptable trade off for fast performance, or for prototyping and testing purposes. In most production applications you will want to use a persistent session store like PostgreSQL or MySQL instead.\n\nThe session stores currently included are shown in the table below. Please click the links for usage instructions and examples.\n\n| Package                                                                             |                                                                                       |\n| :---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |\n| [badgerstore](https://github.com/alexedwards/scs/tree/master/badgerstore)           | Badger based session store                                                            |\n| [boltstore](https://github.com/alexedwards/scs/tree/master/boltstore)               | Bolt based session store                                                              |\n| [bunstore](https://github.com/alexedwards/scs/tree/master/bunstore)                 | Bun based session store                                                               |\n| [buntdbstore](https://github.com/alexedwards/scs/tree/master/buntdbstore)           | BuntDB based session store                                                            |\n| [cockroachdbstore](https://github.com/alexedwards/scs/tree/master/cockroachdbstore) | CockroachDB based session store                                                       |\n| [consulstore](https://github.com/alexedwards/scs/tree/master/consulstore)           | Consul based session store                                                            |\n| [etcdstore](https://github.com/alexedwards/scs/tree/master/etcdstore)               | Etcd based session store                                                              |\n| [firestore](https://github.com/alexedwards/scs/tree/master/firestore)               | Google Cloud Firestore based session store                                            |\n| [gormstore](https://github.com/alexedwards/scs/tree/master/gormstore)               | GORM based session store                                                              |\n| [leveldbstore](https://github.com/alexedwards/scs/tree/master/leveldbstore)         | LevelDB based session store                                                           |\n| [memstore](https://github.com/alexedwards/scs/tree/master/memstore)                 | In-memory session store (default)                                                     |\n| [mongodbstore](https://github.com/alexedwards/scs/tree/master/mongodbstore)         | MongoDB based session store                                                           |\n| [mssqlstore](https://github.com/alexedwards/scs/tree/master/mssqlstore)             | MSSQL based session store                                                             |\n| [mysqlstore](https://github.com/alexedwards/scs/tree/master/mysqlstore)             | MySQL based session store                                                             |\n| [pgxstore](https://github.com/alexedwards/scs/tree/master/pgxstore)                 | PostgreSQL based session store (using the [pgx](https://github.com/jackc/pgx) driver) |\n| [postgresstore](https://github.com/alexedwards/scs/tree/master/postgresstore)       | PostgreSQL based session store (using the [pq](https://github.com/lib/pq) driver)     |\n| [redisstore](https://github.com/alexedwards/scs/tree/master/redisstore)             | Redis based session store                                                             |\n| [sqlite3store](https://github.com/alexedwards/scs/tree/master/sqlite3store)         | SQLite3 based session store                                                           |\n\nCustom session stores are also supported. Please [see here](#using-custom-session-stores) for more information.\n\n### Using Custom Session Stores\n\n[`scs.Store`](https://pkg.go.dev/github.com/alexedwards/scs/v2#Store) defines the interface for custom session stores. Any object that implements this interface can be set as the store when configuring the session.\n\n```go\ntype Store interface {\n\t// Delete should remove the session token and corresponding data from the\n\t// session store. If the token does not exist then Delete should be a no-op\n\t// and return nil (not an error).\n\tDelete(token string) (err error)\n\n\t// Find should return the data for a session token from the store. If the\n\t// session token is not found or is expired, the found return value should\n\t// be false (and the err return value should be nil). Similarly, tampered\n\t// or malformed tokens should result in a found return value of false and a\n\t// nil err value. The err return value should be used for system errors only.\n\tFind(token string) (b []byte, found bool, err error)\n\n\t// Commit should add the session token and data to the store, with the given\n\t// expiry time. If the session token already exists, then the data and\n\t// expiry time should be overwritten.\n\tCommit(token string, b []byte, expiry time.Time) (err error)\n}\n\ntype IterableStore interface {\n\t// All should return a map containing data for all active sessions (i.e.\n\t// sessions which have not expired). The map key should be the session\n\t// token and the map value should be the session data. If no active\n\t// sessions exist this should return an empty (not nil) map.\n\tAll() (map[string][]byte, error)\n}\n```\n\n#### Using Custom Session Stores (with context.Context)\n\n[`scs.CtxStore`](https://pkg.go.dev/github.com/alexedwards/scs/v2#CtxStore) defines the interface for custom session stores (with methods take context.Context parameter).\n\n```go\ntype CtxStore interface {\n\tStore\n\n\t// DeleteCtx is the same as Store.Delete, except it takes a context.Context.\n\tDeleteCtx(ctx context.Context, token string) (err error)\n\n\t// FindCtx is the same as Store.Find, except it takes a context.Context.\n\tFindCtx(ctx context.Context, token string) (b []byte, found bool, err error)\n\n\t// CommitCtx is the same as Store.Commit, except it takes a context.Context.\n\tCommitCtx(ctx context.Context, token string, b []byte, expiry time.Time) (err error)\n}\n\ntype IterableCtxStore interface {\n\t// AllCtx is the same as IterableStore.All, expect it takes a\n\t// context.Context.\n\tAllCtx(ctx context.Context) (map[string][]byte, error)\n}\n```\n\n### Preventing Session Fixation\n\nTo help prevent session fixation attacks you should [renew the session token after any privilege level change](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Session_Management_Cheat_Sheet.md#renew-the-session-id-after-any-privilege-level-change). Commonly, this means that the session token must to be changed when a user logs in or out of your application. You can do this using the [`RenewToken()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.RenewToken) method like so:\n\n```go\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\tuserID := 123\n\n\t// First renew the session token...\n\terr := sessionManager.RenewToken(r.Context())\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// Then make the privilege-level change.\n\tsessionManager.Put(r.Context(), \"userID\", userID)\n}\n```\n\n### Multiple Sessions per Request\n\nIt is possible for an application to support multiple sessions per request, with different lifetime lengths and even different stores. Please [see here for an example](https://gist.github.com/alexedwards/22535f758356bfaf96038fffad154824).\n\n### Enumerate All Sessions\n\n\nTo iterate throught all sessions, SCS offers to all data stores an `All()` function where they can return their own sessions.\n\nEssentially, in your code, you pass the `Iterate()` method a closure with the signature `func(ctx context.Context) error` which contains the logic that you want to execute against each session. For example, if you want to revoke all sessions with contain a `userID` value equal to `4` you can do the following:\n\n```go\nerr := sessionManager.Iterate(r.Context(), func(ctx context.Context) error {\n\tuserID := sessionManager.GetInt(ctx, \"userID\")\n\n\tif userID == 4 {\n\t\treturn sessionManager.Destroy(ctx)\n\t}\n\n\treturn nil\n})\nif err != nil {\n\tlog.Fatal(err)\n}\n```\n\n### Flushing and Streaming Responses\n\nFlushing responses is supported via the `http.NewResponseController` type (available in Go >= 1.20).\n\n```go\nfunc flushingHandler(w http.ResponseWriter, r *http.Request) {\n\tsessionManager.Put(r.Context(), \"message\", \"Hello from a flushing handler!\")\n\n\trc := http.NewResponseController(w)\n\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Fprintf(w, \"Write %d\\n\", i)\n\n\t\terr := rc.Flush()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\ttime.Sleep(time.Second)\n\t}\n}\n```\n\nFor a complete working example, please see [this comment](https://github.com/alexedwards/scs/issues/141#issuecomment-1774050802).\n\nNote that the `http.ResponseWriter` passed on by the [`LoadAndSave()`](https://pkg.go.dev/github.com/alexedwards/scs/v2#SessionManager.LoadAndSave) middleware does not support the `http.Flusher` interface directly. This effectively means that flushing/streaming is only supported by SCS if you are using Go >= 1.20.\n\n### Compatibility\n\nYou may have some problems using this package with Go frameworks that do not propagate the request context from standard-library compatible middleware, like [Echo](https://github.com/alexedwards/scs/issues/57) and [Fiber](https://github.com/alexedwards/scs/issues/106). If you are using Echo, please use the [echo-scs-session](https://github.com/spazzymoto/echo-scs-session) fork of this package instead.\n\n### Contributing\n\nBug fixes and documentation improvements are very welcome! For feature additions or behavioral changes, please open an issue to discuss the change before submitting a PR. For new stores, please also open an issue to establish whether there is wider demand for the store before submitting a PR."
        },
        {
          "name": "badgerstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "boltstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "bunstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "buntdbstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "cockroachdbstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "codec.go",
          "type": "blob",
          "size": 1.2548828125,
          "content": "package scs\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"time\"\n)\n\n// Codec is the interface for encoding/decoding session data to and from a byte\n// slice for use by the session store.\ntype Codec interface {\n\tEncode(deadline time.Time, values map[string]interface{}) ([]byte, error)\n\tDecode([]byte) (deadline time.Time, values map[string]interface{}, err error)\n}\n\n// GobCodec is used for encoding/decoding session data to and from a byte\n// slice using the encoding/gob package.\ntype GobCodec struct{}\n\n// Encode converts a session deadline and values into a byte slice.\nfunc (GobCodec) Encode(deadline time.Time, values map[string]interface{}) ([]byte, error) {\n\taux := &struct {\n\t\tDeadline time.Time\n\t\tValues   map[string]interface{}\n\t}{\n\t\tDeadline: deadline,\n\t\tValues:   values,\n\t}\n\n\tvar b bytes.Buffer\n\tif err := gob.NewEncoder(&b).Encode(&aux); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b.Bytes(), nil\n}\n\n// Decode converts a byte slice into a session deadline and values.\nfunc (GobCodec) Decode(b []byte) (time.Time, map[string]interface{}, error) {\n\taux := &struct {\n\t\tDeadline time.Time\n\t\tValues   map[string]interface{}\n\t}{}\n\n\tr := bytes.NewReader(b)\n\tif err := gob.NewDecoder(r).Decode(&aux); err != nil {\n\t\treturn time.Time{}, nil, err\n\t}\n\n\treturn aux.Deadline, aux.Values, nil\n}\n"
        },
        {
          "name": "consulstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "data.go",
          "type": "blob",
          "size": 18.5380859375,
          "content": "package scs\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"sort\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Status represents the state of the session data during a request cycle.\ntype Status int\n\nconst (\n\t// Unmodified indicates that the session data hasn't been changed in the\n\t// current request cycle.\n\tUnmodified Status = iota\n\n\t// Modified indicates that the session data has been changed in the current\n\t// request cycle.\n\tModified\n\n\t// Destroyed indicates that the session data has been destroyed in the\n\t// current request cycle.\n\tDestroyed\n)\n\ntype sessionData struct {\n\tdeadline time.Time\n\tstatus   Status\n\ttoken    string\n\tvalues   map[string]interface{}\n\tmu       sync.Mutex\n}\n\nfunc newSessionData(lifetime time.Duration) *sessionData {\n\treturn &sessionData{\n\t\tdeadline: time.Now().Add(lifetime).UTC(),\n\t\tstatus:   Unmodified,\n\t\tvalues:   make(map[string]interface{}),\n\t}\n}\n\n// Load retrieves the session data for the given token from the session store,\n// and returns a new context.Context containing the session data. If no matching\n// token is found then this will create a new session.\n//\n// Most applications will use the LoadAndSave() middleware and will not need to\n// use this method.\nfunc (s *SessionManager) Load(ctx context.Context, token string) (context.Context, error) {\n\tif _, ok := ctx.Value(s.contextKey).(*sessionData); ok {\n\t\treturn ctx, nil\n\t}\n\n\tif token == \"\" {\n\t\treturn s.addSessionDataToContext(ctx, newSessionData(s.Lifetime)), nil\n\t}\n\n\tb, found, err := s.doStoreFind(ctx, token)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if !found {\n\t\treturn s.addSessionDataToContext(ctx, newSessionData(s.Lifetime)), nil\n\t}\n\n\tsd := &sessionData{\n\t\tstatus: Unmodified,\n\t\ttoken:  token,\n\t}\n\tif sd.deadline, sd.values, err = s.Codec.Decode(b); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Mark the session data as modified if an idle timeout is being used. This\n\t// will force the session data to be re-committed to the session store with\n\t// a new expiry time.\n\tif s.IdleTimeout > 0 {\n\t\tsd.status = Modified\n\t}\n\n\treturn s.addSessionDataToContext(ctx, sd), nil\n}\n\n// Commit saves the session data to the session store and returns the session\n// token and expiry time.\n//\n// Most applications will use the LoadAndSave() middleware and will not need to\n// use this method.\nfunc (s *SessionManager) Commit(ctx context.Context) (string, time.Time, error) {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\tif sd.token == \"\" {\n\t\tvar err error\n\t\tif sd.token, err = generateToken(); err != nil {\n\t\t\treturn \"\", time.Time{}, err\n\t\t}\n\t}\n\n\tb, err := s.Codec.Encode(sd.deadline, sd.values)\n\tif err != nil {\n\t\treturn \"\", time.Time{}, err\n\t}\n\n\texpiry := sd.deadline\n\tif s.IdleTimeout > 0 {\n\t\tie := time.Now().Add(s.IdleTimeout).UTC()\n\t\tif ie.Before(expiry) {\n\t\t\texpiry = ie\n\t\t}\n\t}\n\n\tif err := s.doStoreCommit(ctx, sd.token, b, expiry); err != nil {\n\t\treturn \"\", time.Time{}, err\n\t}\n\n\treturn sd.token, expiry, nil\n}\n\n// Destroy deletes the session data from the session store and sets the session\n// status to Destroyed. Any further operations in the same request cycle will\n// result in a new session being created.\nfunc (s *SessionManager) Destroy(ctx context.Context) error {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\terr := s.doStoreDelete(ctx, sd.token)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsd.status = Destroyed\n\n\t// Reset everything else to defaults.\n\tsd.token = \"\"\n\tsd.deadline = time.Now().Add(s.Lifetime).UTC()\n\tfor key := range sd.values {\n\t\tdelete(sd.values, key)\n\t}\n\n\treturn nil\n}\n\n// Put adds a key and corresponding value to the session data. Any existing\n// value for the key will be replaced. The session data status will be set to\n// Modified.\nfunc (s *SessionManager) Put(ctx context.Context, key string, val interface{}) {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tsd.values[key] = val\n\tsd.status = Modified\n\tsd.mu.Unlock()\n}\n\n// Get returns the value for a given key from the session data. The return\n// value has the type interface{} so will usually need to be type asserted\n// before you can use it. For example:\n//\n//\tfoo, ok := session.Get(r, \"foo\").(string)\n//\tif !ok {\n//\t\treturn errors.New(\"type assertion to string failed\")\n//\t}\n//\n// Also see the GetString(), GetInt(), GetBytes() and other helper methods which\n// wrap the type conversion for common types.\nfunc (s *SessionManager) Get(ctx context.Context, key string) interface{} {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\treturn sd.values[key]\n}\n\n// Pop acts like a one-time Get. It returns the value for a given key from the\n// session data and deletes the key and value from the session data. The\n// session data status will be set to Modified. The return value has the type\n// interface{} so will usually need to be type asserted before you can use it.\nfunc (s *SessionManager) Pop(ctx context.Context, key string) interface{} {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\tval, exists := sd.values[key]\n\tif !exists {\n\t\treturn nil\n\t}\n\tdelete(sd.values, key)\n\tsd.status = Modified\n\n\treturn val\n}\n\n// Remove deletes the given key and corresponding value from the session data.\n// The session data status will be set to Modified. If the key is not present\n// this operation is a no-op.\nfunc (s *SessionManager) Remove(ctx context.Context, key string) {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\t_, exists := sd.values[key]\n\tif !exists {\n\t\treturn\n\t}\n\n\tdelete(sd.values, key)\n\tsd.status = Modified\n}\n\n// Clear removes all data for the current session. The session token and\n// lifetime are unaffected. If there is no data in the current session this is\n// a no-op.\nfunc (s *SessionManager) Clear(ctx context.Context) error {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\tif len(sd.values) == 0 {\n\t\treturn nil\n\t}\n\n\tfor key := range sd.values {\n\t\tdelete(sd.values, key)\n\t}\n\tsd.status = Modified\n\treturn nil\n}\n\n// Exists returns true if the given key is present in the session data.\nfunc (s *SessionManager) Exists(ctx context.Context, key string) bool {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\t_, exists := sd.values[key]\n\tsd.mu.Unlock()\n\n\treturn exists\n}\n\n// Keys returns a slice of all key names present in the session data, sorted\n// alphabetically. If the data contains no data then an empty slice will be\n// returned.\nfunc (s *SessionManager) Keys(ctx context.Context) []string {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tkeys := make([]string, len(sd.values))\n\ti := 0\n\tfor key := range sd.values {\n\t\tkeys[i] = key\n\t\ti++\n\t}\n\tsd.mu.Unlock()\n\n\tsort.Strings(keys)\n\treturn keys\n}\n\n// RenewToken updates the session data to have a new session token while\n// retaining the current session data. The session lifetime is also reset and\n// the session data status will be set to Modified.\n//\n// The old session token and accompanying data are deleted from the session store.\n//\n// To mitigate the risk of session fixation attacks, it's important that you call\n// RenewToken before making any changes to privilege levels (e.g. login and\n// logout operations). See https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Session_Management_Cheat_Sheet.md#renew-the-session-id-after-any-privilege-level-change\n// for additional information.\nfunc (s *SessionManager) RenewToken(ctx context.Context) error {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\tif sd.token != \"\" {\n\t\terr := s.doStoreDelete(ctx, sd.token)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tnewToken, err := generateToken()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsd.token = newToken\n\tsd.deadline = time.Now().Add(s.Lifetime).UTC()\n\tsd.status = Modified\n\n\treturn nil\n}\n\n// MergeSession is used to merge in data from a different session in case strict\n// session tokens are lost across an oauth or similar redirect flows. Use Clear()\n// if no values of the new session are to be used.\nfunc (s *SessionManager) MergeSession(ctx context.Context, token string) error {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tb, found, err := s.doStoreFind(ctx, token)\n\tif err != nil {\n\t\treturn err\n\t} else if !found {\n\t\treturn nil\n\t}\n\n\tdeadline, values, err := s.Codec.Decode(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\t// If it is the same session, nothing needs to be done.\n\tif sd.token == token {\n\t\treturn nil\n\t}\n\n\tif deadline.After(sd.deadline) {\n\t\tsd.deadline = deadline\n\t}\n\n\tfor k, v := range values {\n\t\tsd.values[k] = v\n\t}\n\n\tsd.status = Modified\n\treturn s.doStoreDelete(ctx, token)\n}\n\n// Status returns the current status of the session data.\nfunc (s *SessionManager) Status(ctx context.Context) Status {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\treturn sd.status\n}\n\n// GetString returns the string value for a given key from the session data.\n// The zero value for a string (\"\") is returned if the key does not exist or the\n// value could not be type asserted to a string.\nfunc (s *SessionManager) GetString(ctx context.Context, key string) string {\n\tval := s.Get(ctx, key)\n\tstr, ok := val.(string)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn str\n}\n\n// GetBool returns the bool value for a given key from the session data. The\n// zero value for a bool (false) is returned if the key does not exist or the\n// value could not be type asserted to a bool.\nfunc (s *SessionManager) GetBool(ctx context.Context, key string) bool {\n\tval := s.Get(ctx, key)\n\tb, ok := val.(bool)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn b\n}\n\n// GetInt returns the int value for a given key from the session data. The\n// zero value for an int (0) is returned if the key does not exist or the\n// value could not be type asserted to an int.\nfunc (s *SessionManager) GetInt(ctx context.Context, key string) int {\n\tval := s.Get(ctx, key)\n\ti, ok := val.(int)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn i\n}\n\n// GetInt64 returns the int64 value for a given key from the session data. The\n// zero value for an int64 (0) is returned if the key does not exist or the\n// value could not be type asserted to an int64.\nfunc (s *SessionManager) GetInt64(ctx context.Context, key string) int64 {\n\tval := s.Get(ctx, key)\n\ti, ok := val.(int64)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn i\n}\n\n// GetInt32 returns the int value for a given key from the session data. The\n// zero value for an int32 (0) is returned if the key does not exist or the\n// value could not be type asserted to an int32.\nfunc (s *SessionManager) GetInt32(ctx context.Context, key string) int32 {\n\tval := s.Get(ctx, key)\n\ti, ok := val.(int32)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn i\n}\n\n// GetFloat returns the float64 value for a given key from the session data. The\n// zero value for an float64 (0) is returned if the key does not exist or the\n// value could not be type asserted to a float64.\nfunc (s *SessionManager) GetFloat(ctx context.Context, key string) float64 {\n\tval := s.Get(ctx, key)\n\tf, ok := val.(float64)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn f\n}\n\n// GetBytes returns the byte slice ([]byte) value for a given key from the session\n// data. The zero value for a slice (nil) is returned if the key does not exist\n// or could not be type asserted to []byte.\nfunc (s *SessionManager) GetBytes(ctx context.Context, key string) []byte {\n\tval := s.Get(ctx, key)\n\tb, ok := val.([]byte)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn b\n}\n\n// GetTime returns the time.Time value for a given key from the session data. The\n// zero value for a time.Time object is returned if the key does not exist or the\n// value could not be type asserted to a time.Time. This can be tested with the\n// time.IsZero() method.\nfunc (s *SessionManager) GetTime(ctx context.Context, key string) time.Time {\n\tval := s.Get(ctx, key)\n\tt, ok := val.(time.Time)\n\tif !ok {\n\t\treturn time.Time{}\n\t}\n\treturn t\n}\n\n// PopString returns the string value for a given key and then deletes it from the\n// session data. The session data status will be set to Modified. The zero\n// value for a string (\"\") is returned if the key does not exist or the value\n// could not be type asserted to a string.\nfunc (s *SessionManager) PopString(ctx context.Context, key string) string {\n\tval := s.Pop(ctx, key)\n\tstr, ok := val.(string)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn str\n}\n\n// PopBool returns the bool value for a given key and then deletes it from the\n// session data. The session data status will be set to Modified. The zero\n// value for a bool (false) is returned if the key does not exist or the value\n// could not be type asserted to a bool.\nfunc (s *SessionManager) PopBool(ctx context.Context, key string) bool {\n\tval := s.Pop(ctx, key)\n\tb, ok := val.(bool)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn b\n}\n\n// PopInt returns the int value for a given key and then deletes it from the\n// session data. The session data status will be set to Modified. The zero\n// value for an int (0) is returned if the key does not exist or the value could\n// not be type asserted to an int.\nfunc (s *SessionManager) PopInt(ctx context.Context, key string) int {\n\tval := s.Pop(ctx, key)\n\ti, ok := val.(int)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn i\n}\n\n// PopFloat returns the float64 value for a given key and then deletes it from the\n// session data. The session data status will be set to Modified. The zero\n// value for an float64 (0) is returned if the key does not exist or the value\n// could not be type asserted to a float64.\nfunc (s *SessionManager) PopFloat(ctx context.Context, key string) float64 {\n\tval := s.Pop(ctx, key)\n\tf, ok := val.(float64)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn f\n}\n\n// PopBytes returns the byte slice ([]byte) value for a given key and then\n// deletes it from the from the session data. The session data status will be\n// set to Modified. The zero value for a slice (nil) is returned if the key does\n// not exist or could not be type asserted to []byte.\nfunc (s *SessionManager) PopBytes(ctx context.Context, key string) []byte {\n\tval := s.Pop(ctx, key)\n\tb, ok := val.([]byte)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn b\n}\n\n// PopTime returns the time.Time value for a given key and then deletes it from\n// the session data. The session data status will be set to Modified. The zero\n// value for a time.Time object is returned if the key does not exist or the\n// value could not be type asserted to a time.Time.\nfunc (s *SessionManager) PopTime(ctx context.Context, key string) time.Time {\n\tval := s.Pop(ctx, key)\n\tt, ok := val.(time.Time)\n\tif !ok {\n\t\treturn time.Time{}\n\t}\n\treturn t\n}\n\n// RememberMe controls whether the session cookie is persistent (i.e  whether it\n// is retained after a user closes their browser). RememberMe only has an effect\n// if you have set SessionManager.Cookie.Persist = false (the default is true) and\n// you are using the standard LoadAndSave() middleware.\nfunc (s *SessionManager) RememberMe(ctx context.Context, val bool) {\n\ts.Put(ctx, \"__rememberMe\", val)\n}\n\n// Iterate retrieves all active (i.e. not expired) sessions from the store and\n// executes the provided function fn for each session. If the session store\n// being used does not support iteration then Iterate will panic.\nfunc (s *SessionManager) Iterate(ctx context.Context, fn func(context.Context) error) error {\n\tallSessions, err := s.doStoreAll(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor token, b := range allSessions {\n\t\tsd := &sessionData{\n\t\t\tstatus: Unmodified,\n\t\t\ttoken:  token,\n\t\t}\n\n\t\tsd.deadline, sd.values, err = s.Codec.Decode(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tctx = s.addSessionDataToContext(ctx, sd)\n\n\t\terr = fn(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Deadline returns the 'absolute' expiry time for the session. Please note\n// that if you are using an idle timeout, it is possible that a session will\n// expire due to non-use before the returned deadline.\nfunc (s *SessionManager) Deadline(ctx context.Context) time.Time {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\treturn sd.deadline\n}\n\n// SetDeadline updates the 'absolute' expiry time for the session. Please note\n// that if you are using an idle timeout, it is possible that a session will\n// expire due to non-use before the set deadline.\nfunc (s *SessionManager) SetDeadline(ctx context.Context, expire time.Time) {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\tsd.deadline = expire\n\tsd.status = Modified\n}\n\n// Token returns the session token. Please note that this will return the\n// empty string \"\" if it is called before the session has been committed to\n// the store.\nfunc (s *SessionManager) Token(ctx context.Context) string {\n\tsd := s.getSessionDataFromContext(ctx)\n\n\tsd.mu.Lock()\n\tdefer sd.mu.Unlock()\n\n\treturn sd.token\n}\n\nfunc (s *SessionManager) addSessionDataToContext(ctx context.Context, sd *sessionData) context.Context {\n\treturn context.WithValue(ctx, s.contextKey, sd)\n}\n\nfunc (s *SessionManager) getSessionDataFromContext(ctx context.Context) *sessionData {\n\tc, ok := ctx.Value(s.contextKey).(*sessionData)\n\tif !ok {\n\t\tpanic(\"scs: no session data in context\")\n\t}\n\treturn c\n}\n\nfunc generateToken() (string, error) {\n\tb := make([]byte, 32)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.RawURLEncoding.EncodeToString(b), nil\n}\n\nfunc hashToken(token string) string {\n\thash := sha256.Sum256([]byte(token))\n\treturn base64.RawURLEncoding.EncodeToString(hash[:])\n}\n\ntype contextKey string\n\nvar (\n\tcontextKeyID      uint64\n\tcontextKeyIDMutex = &sync.Mutex{}\n)\n\nfunc generateContextKey() contextKey {\n\tcontextKeyIDMutex.Lock()\n\tdefer contextKeyIDMutex.Unlock()\n\tatomic.AddUint64(&contextKeyID, 1)\n\treturn contextKey(fmt.Sprintf(\"session.%d\", contextKeyID))\n}\n\nfunc (s *SessionManager) doStoreDelete(ctx context.Context, token string) (err error) {\n\tif s.HashTokenInStore {\n\t\ttoken = hashToken(token)\n\t}\n\tc, ok := s.Store.(interface {\n\t\tDeleteCtx(context.Context, string) error\n\t})\n\tif ok {\n\t\treturn c.DeleteCtx(ctx, token)\n\t}\n\treturn s.Store.Delete(token)\n}\n\nfunc (s *SessionManager) doStoreFind(ctx context.Context, token string) (b []byte, found bool, err error) {\n\tif s.HashTokenInStore {\n\t\ttoken = hashToken(token)\n\t}\n\tc, ok := s.Store.(interface {\n\t\tFindCtx(context.Context, string) ([]byte, bool, error)\n\t})\n\tif ok {\n\t\treturn c.FindCtx(ctx, token)\n\t}\n\treturn s.Store.Find(token)\n}\n\nfunc (s *SessionManager) doStoreCommit(ctx context.Context, token string, b []byte, expiry time.Time) (err error) {\n\tif s.HashTokenInStore {\n\t\ttoken = hashToken(token)\n\t}\n\tc, ok := s.Store.(interface {\n\t\tCommitCtx(context.Context, string, []byte, time.Time) error\n\t})\n\tif ok {\n\t\treturn c.CommitCtx(ctx, token, b, expiry)\n\t}\n\treturn s.Store.Commit(token, b, expiry)\n}\n\nfunc (s *SessionManager) doStoreAll(ctx context.Context) (map[string][]byte, error) {\n\tcs, ok := s.Store.(IterableCtxStore)\n\tif ok {\n\t\treturn cs.AllCtx(ctx)\n\t}\n\n\tis, ok := s.Store.(IterableStore)\n\tif ok {\n\t\treturn is.All()\n\t}\n\n\tpanic(fmt.Sprintf(\"type %T does not support iteration\", s.Store))\n}\n"
        },
        {
          "name": "data_test.go",
          "type": "blob",
          "size": 18.763671875,
          "content": "package scs\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"reflect\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alexedwards/scs/v2/mockstore\"\n)\n\nfunc TestSessionDataFromContext(t *testing.T) {\n\tt.Parallel()\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"the code did not panic\")\n\t\t}\n\t}()\n\n\ts := New()\n\ts.getSessionDataFromContext(context.Background())\n}\n\nfunc TestSessionManager_Load(T *testing.T) {\n\tT.Parallel()\n\n\tT.Run(\"happy path\", func(t *testing.T) {\n\t\ts := New()\n\t\ts.IdleTimeout = time.Hour * 24\n\n\t\tctx := context.Background()\n\t\texpected := \"example\"\n\t\texampleDeadline := time.Now().Add(time.Hour)\n\n\t\tencodedValue, err := s.Codec.Encode(exampleDeadline, map[string]interface{}{\n\t\t\t\"things\": \"stuff\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error encoding value: %v\", err)\n\t\t}\n\n\t\tif err := s.Store.Commit(expected, encodedValue, exampleDeadline); err != nil {\n\t\t\tt.Errorf(\"error committing to session store: %v\", err)\n\t\t}\n\n\t\tnewCtx, err := s.Load(ctx, expected)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error loading from session manager: %v\", err)\n\t\t}\n\t\tif newCtx == nil {\n\t\t\tt.Error(\"returned context is unexpectedly nil\")\n\t\t}\n\n\t\tsd, ok := newCtx.Value(s.contextKey).(*sessionData)\n\t\tif !ok {\n\t\t\tt.Error(\"sessionData not present in returned context\")\n\t\t}\n\t\tif sd == nil {\n\t\t\tt.Error(\"sessionData present in returned context unexpectedly nil\")\n\t\t\treturn\n\t\t}\n\n\t\tactual := sd.token\n\n\t\tif expected != actual {\n\t\t\tt.Errorf(\"expected %s to equal %s\", expected, actual)\n\t\t}\n\t})\n\n\tT.Run(\"with preexisting session data\", func(t *testing.T) {\n\t\ts := New()\n\n\t\tobligatorySessionData := &sessionData{}\n\t\tctx := context.WithValue(context.Background(), s.contextKey, obligatorySessionData)\n\t\texpected := \"example\"\n\n\t\tnewCtx, err := s.Load(ctx, expected)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error loading from session manager: %v\", err)\n\t\t}\n\t\tif newCtx == nil {\n\t\t\tt.Error(\"returned context is unexpectedly nil\")\n\t\t}\n\t})\n\n\tT.Run(\"with empty token\", func(t *testing.T) {\n\t\ts := New()\n\n\t\tctx := context.Background()\n\t\texpected := \"\"\n\t\texampleDeadline := time.Now().Add(time.Hour)\n\n\t\tencodedValue, err := s.Codec.Encode(exampleDeadline, map[string]interface{}{\n\t\t\t\"things\": \"stuff\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error encoding value: %v\", err)\n\t\t}\n\n\t\tif err := s.Store.Commit(expected, encodedValue, exampleDeadline); err != nil {\n\t\t\tt.Errorf(\"error committing to session store: %v\", err)\n\t\t}\n\n\t\tnewCtx, err := s.Load(ctx, \"\")\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error loading from session manager: %v\", err)\n\t\t}\n\t\tif newCtx == nil {\n\t\t\tt.Error(\"returned context is unexpectedly nil\")\n\t\t}\n\n\t\tsd, ok := newCtx.Value(s.contextKey).(*sessionData)\n\t\tif !ok {\n\t\t\tt.Error(\"sessionData not present in returned context\")\n\t\t}\n\t\tif sd == nil {\n\t\t\tt.Error(\"sessionData present in returned context unexpectedly nil\")\n\t\t\treturn\n\t\t}\n\n\t\tactual := sd.token\n\n\t\tif expected != actual {\n\t\t\tt.Errorf(\"expected %s to equal %s\", expected, actual)\n\t\t}\n\t})\n\n\tT.Run(\"with error finding token in store\", func(t *testing.T) {\n\t\ts := New()\n\t\tstore := &mockstore.MockStore{}\n\n\t\tctx := context.Background()\n\t\texpected := \"example\"\n\n\t\tstore.ExpectFind(expected, []byte{}, true, errors.New(\"arbitrary\"))\n\t\ts.Store = store\n\n\t\tnewCtx, err := s.Load(ctx, expected)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"no error loading from session manager: %v\", err)\n\t\t}\n\t\tif newCtx != nil {\n\t\t\tt.Error(\"returned context is unexpectedly not nil\")\n\t\t}\n\t})\n\n\tT.Run(\"with unfound token in store\", func(t *testing.T) {\n\t\ts := New()\n\n\t\tctx := context.Background()\n\t\texampleToken := \"example\"\n\t\texpected := \"\"\n\n\t\tnewCtx, err := s.Load(ctx, exampleToken)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error loading from session manager: %v\", err)\n\t\t}\n\t\tif newCtx == nil {\n\t\t\tt.Error(\"returned context is unexpectedly nil\")\n\t\t}\n\n\t\tsd, ok := newCtx.Value(s.contextKey).(*sessionData)\n\t\tif !ok {\n\t\t\tt.Error(\"sessionData not present in returned context\")\n\t\t}\n\t\tif sd == nil {\n\t\t\tt.Error(\"sessionData present in returned context unexpectedly nil\")\n\t\t\treturn\n\t\t}\n\n\t\tactual := sd.token\n\n\t\tif expected != actual {\n\t\t\tt.Errorf(\"expected %s to equal %s\", expected, actual)\n\t\t}\n\t})\n\n\tT.Run(\"with error decoding found token\", func(t *testing.T) {\n\t\ts := New()\n\n\t\tctx := context.Background()\n\t\texpected := \"example\"\n\t\texampleDeadline := time.Now().Add(time.Hour)\n\n\t\tif err := s.Store.Commit(expected, []byte(\"\"), exampleDeadline); err != nil {\n\t\t\tt.Errorf(\"error committing to session store: %v\", err)\n\t\t}\n\n\t\tnewCtx, err := s.Load(ctx, expected)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"no error loading from session manager: %v\", err)\n\t\t}\n\t\tif newCtx != nil {\n\t\t\tt.Error(\"returned context is unexpectedly nil\")\n\t\t}\n\t})\n\n\tT.Run(\"with token hashing\", func(t *testing.T) {\n\t\ts := New()\n\t\ts.HashTokenInStore = true\n\t\ts.IdleTimeout = time.Hour * 24\n\n\t\texpectedToken := \"example\"\n\t\texpectedExpiry := time.Now().Add(time.Hour)\n\n\t\tinitialCtx := context.WithValue(context.Background(), s.contextKey, &sessionData{\n\t\t\tdeadline: expectedExpiry,\n\t\t\ttoken:    expectedToken,\n\t\t\tvalues: map[string]interface{}{\n\t\t\t\t\"blah\": \"blah\",\n\t\t\t},\n\t\t\tmu: sync.Mutex{},\n\t\t})\n\n\t\tactualToken, actualExpiry, err := s.Commit(initialCtx)\n\t\tif expectedToken != actualToken {\n\t\t\tt.Errorf(\"expected token to equal %q, but received %q\", expectedToken, actualToken)\n\t\t}\n\t\tif expectedExpiry != actualExpiry {\n\t\t\tt.Errorf(\"expected expiry to equal %v, but received %v\", expectedExpiry, actualExpiry)\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error returned: %v\", err)\n\t\t}\n\n\t\tretrievedCtx, err := s.Load(context.Background(), expectedToken)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error returned: %v\", err)\n\t\t}\n\t\tretrievedSessionData, ok := retrievedCtx.Value(s.contextKey).(*sessionData)\n\t\tif !ok {\n\t\t\tt.Errorf(\"unexpected data in retrieved context\")\n\t\t} else if retrievedSessionData.token != expectedToken {\n\t\t\tt.Errorf(\"expected token in context's session data data to equal %v, but received %v\", expectedToken, retrievedSessionData.token)\n\t\t}\n\n\t\tif err := s.Destroy(retrievedCtx); err != nil {\n\t\t\tt.Errorf(\"unexpected error returned: %v\", err)\n\t\t}\n\t})\n}\n\nfunc TestSessionManager_Commit(T *testing.T) {\n\tT.Parallel()\n\n\tT.Run(\"happy path\", func(t *testing.T) {\n\t\ts := New()\n\t\ts.IdleTimeout = time.Hour * 24\n\n\t\texpectedToken := \"example\"\n\t\texpectedExpiry := time.Now().Add(time.Hour)\n\n\t\tctx := context.WithValue(context.Background(), s.contextKey, &sessionData{\n\t\t\tdeadline: expectedExpiry,\n\t\t\ttoken:    expectedToken,\n\t\t\tvalues: map[string]interface{}{\n\t\t\t\t\"blah\": \"blah\",\n\t\t\t},\n\t\t\tmu: sync.Mutex{},\n\t\t})\n\n\t\tactualToken, actualExpiry, err := s.Commit(ctx)\n\t\tif expectedToken != actualToken {\n\t\t\tt.Errorf(\"expected token to equal %q, but received %q\", expectedToken, actualToken)\n\t\t}\n\t\tif expectedExpiry != actualExpiry {\n\t\t\tt.Errorf(\"expected expiry to equal %v, but received %v\", expectedExpiry, actualExpiry)\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error returned: %v\", err)\n\t\t}\n\t})\n\n\tT.Run(\"with empty token\", func(t *testing.T) {\n\t\ts := New()\n\t\ts.IdleTimeout = time.Hour * 24\n\n\t\texpectedToken := \"XO6_D4NBpGP3D_BtekxTEO6o2ZvOzYnArauSQbgg\"\n\t\texpectedExpiry := time.Now().Add(time.Hour)\n\n\t\tctx := context.WithValue(context.Background(), s.contextKey, &sessionData{\n\t\t\tdeadline: expectedExpiry,\n\t\t\ttoken:    expectedToken,\n\t\t\tvalues: map[string]interface{}{\n\t\t\t\t\"blah\": \"blah\",\n\t\t\t},\n\t\t\tmu: sync.Mutex{},\n\t\t})\n\n\t\tactualToken, actualExpiry, err := s.Commit(ctx)\n\t\tif expectedToken != actualToken {\n\t\t\tt.Errorf(\"expected token to equal %q, but received %q\", expectedToken, actualToken)\n\t\t}\n\t\tif expectedExpiry != actualExpiry {\n\t\t\tt.Errorf(\"expected expiry to equal %v, but received %v\", expectedExpiry, actualExpiry)\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error returned: %v\", err)\n\t\t}\n\t})\n\n\tT.Run(\"with expired deadline\", func(t *testing.T) {\n\t\ts := New()\n\t\ts.IdleTimeout = time.Millisecond\n\n\t\texpectedToken := \"example\"\n\t\texpectedExpiry := time.Now().Add(time.Hour * -100)\n\n\t\tctx := context.WithValue(context.Background(), s.contextKey, &sessionData{\n\t\t\tdeadline: time.Now().Add(time.Hour * 24),\n\t\t\ttoken:    expectedToken,\n\t\t\tvalues: map[string]interface{}{\n\t\t\t\t\"blah\": \"blah\",\n\t\t\t},\n\t\t\tmu: sync.Mutex{},\n\t\t})\n\n\t\tactualToken, actualExpiry, err := s.Commit(ctx)\n\t\tif expectedToken != actualToken {\n\t\t\tt.Errorf(\"expected token to equal %q, but received %q\", expectedToken, actualToken)\n\t\t}\n\t\tif expectedExpiry == actualExpiry {\n\t\t\tt.Errorf(\"expected expiry not to equal %v\", actualExpiry)\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error returned: %v\", err)\n\t\t}\n\t})\n\n\tT.Run(\"with error committing to store\", func(t *testing.T) {\n\t\ts := New()\n\t\ts.IdleTimeout = time.Hour * 24\n\n\t\tstore := &mockstore.MockStore{}\n\t\texpectedErr := errors.New(\"arbitrary\")\n\n\t\tsd := &sessionData{\n\t\t\tdeadline: time.Now().Add(time.Hour),\n\t\t\ttoken:    \"example\",\n\t\t\tvalues: map[string]interface{}{\n\t\t\t\t\"blah\": \"blah\",\n\t\t\t},\n\t\t\tmu: sync.Mutex{},\n\t\t}\n\t\texpectedBytes, err := s.Codec.Encode(sd.deadline, sd.values)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected encode error: %v\", err)\n\t\t}\n\n\t\tctx := context.WithValue(context.Background(), s.contextKey, sd)\n\n\t\tstore.ExpectCommit(sd.token, expectedBytes, sd.deadline, expectedErr)\n\t\ts.Store = store\n\n\t\tactualToken, _, err := s.Commit(ctx)\n\t\tif actualToken != \"\" {\n\t\t\tt.Error(\"expected empty token\")\n\t\t}\n\t\tif err == nil {\n\t\t\tt.Error(\"expected error not returned\")\n\t\t}\n\t})\n\n\tT.Run(\"with token hashing\", func(t *testing.T) {\n\t\ts := New()\n\t\ts.HashTokenInStore = true\n\t\ts.IdleTimeout = time.Hour * 24\n\n\t\texpectedToken := \"example\"\n\t\texpectedExpiry := time.Now().Add(time.Hour)\n\n\t\tctx := context.WithValue(context.Background(), s.contextKey, &sessionData{\n\t\t\tdeadline: expectedExpiry,\n\t\t\ttoken:    expectedToken,\n\t\t\tvalues: map[string]interface{}{\n\t\t\t\t\"blah\": \"blah\",\n\t\t\t},\n\t\t\tmu: sync.Mutex{},\n\t\t})\n\n\t\tactualToken, actualExpiry, err := s.Commit(ctx)\n\t\tif expectedToken != actualToken {\n\t\t\tt.Errorf(\"expected token to equal %q, but received %q\", expectedToken, actualToken)\n\t\t}\n\t\tif expectedExpiry != actualExpiry {\n\t\t\tt.Errorf(\"expected expiry to equal %v, but received %v\", expectedExpiry, actualExpiry)\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error returned: %v\", err)\n\t\t}\n\t})\n}\n\nfunc TestPut(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\ts.Put(ctx, \"foo\", \"bar\")\n\n\tif sd.values[\"foo\"] != \"bar\" {\n\t\tt.Errorf(\"got %q: expected %q\", sd.values[\"foo\"], \"bar\")\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n}\n\nfunc TestGet(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = \"bar\"\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tstr, ok := s.Get(ctx, \"foo\").(string)\n\tif !ok {\n\t\tt.Errorf(\"could not convert %T to string\", s.Get(ctx, \"foo\"))\n\t}\n\n\tif str != \"bar\" {\n\t\tt.Errorf(\"got %q: expected %q\", str, \"bar\")\n\t}\n}\n\nfunc TestPop(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = \"bar\"\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tstr, ok := s.Pop(ctx, \"foo\").(string)\n\tif !ok {\n\t\tt.Errorf(\"could not convert %T to string\", s.Get(ctx, \"foo\"))\n\t}\n\n\tif str != \"bar\" {\n\t\tt.Errorf(\"got %q: expected %q\", str, \"bar\")\n\t}\n\n\t_, ok = sd.values[\"foo\"]\n\tif ok {\n\t\tt.Errorf(\"got %v: expected %v\", ok, false)\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n}\n\nfunc TestRemove(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = \"bar\"\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\ts.Remove(ctx, \"foo\")\n\n\tif sd.values[\"foo\"] != nil {\n\t\tt.Errorf(\"got %v: expected %v\", sd.values[\"foo\"], nil)\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n}\n\nfunc TestClear(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = \"bar\"\n\tsd.values[\"baz\"] = \"boz\"\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tif err := s.Clear(ctx); err != nil {\n\t\tt.Errorf(\"unexpected error encountered clearing session: %v\", err)\n\t}\n\n\tif sd.values[\"foo\"] != nil {\n\t\tt.Errorf(\"got %v: expected %v\", sd.values[\"foo\"], nil)\n\t}\n\n\tif sd.values[\"baz\"] != nil {\n\t\tt.Errorf(\"got %v: expected %v\", sd.values[\"baz\"], nil)\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n}\n\nfunc TestExists(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = \"bar\"\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tif !s.Exists(ctx, \"foo\") {\n\t\tt.Errorf(\"got %v: expected %v\", s.Exists(ctx, \"foo\"), true)\n\t}\n\n\tif s.Exists(ctx, \"baz\") {\n\t\tt.Errorf(\"got %v: expected %v\", s.Exists(ctx, \"baz\"), false)\n\t}\n}\n\nfunc TestKeys(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = \"bar\"\n\tsd.values[\"woo\"] = \"waa\"\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tkeys := s.Keys(ctx)\n\tif !reflect.DeepEqual(keys, []string{\"foo\", \"woo\"}) {\n\t\tt.Errorf(\"got %v: expected %v\", keys, []string{\"foo\", \"woo\"})\n\t}\n}\n\nfunc TestGetString(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = \"bar\"\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tstr := s.GetString(ctx, \"foo\")\n\tif str != \"bar\" {\n\t\tt.Errorf(\"got %q: expected %q\", str, \"bar\")\n\t}\n\n\tstr = s.GetString(ctx, \"baz\")\n\tif str != \"\" {\n\t\tt.Errorf(\"got %q: expected %q\", str, \"\")\n\t}\n}\n\nfunc TestGetBool(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = true\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tb := s.GetBool(ctx, \"foo\")\n\tif b != true {\n\t\tt.Errorf(\"got %v: expected %v\", b, true)\n\t}\n\n\tb = s.GetBool(ctx, \"baz\")\n\tif b != false {\n\t\tt.Errorf(\"got %v: expected %v\", b, false)\n\t}\n}\n\nfunc TestGetInt(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = 123\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\ti := s.GetInt(ctx, \"foo\")\n\tif i != 123 {\n\t\tt.Errorf(\"got %v: expected %d\", i, 123)\n\t}\n\n\ti = s.GetInt(ctx, \"baz\")\n\tif i != 0 {\n\t\tt.Errorf(\"got %v: expected %d\", i, 0)\n\t}\n}\n\nfunc TestGetFloat(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = 123.456\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tf := s.GetFloat(ctx, \"foo\")\n\tif f != 123.456 {\n\t\tt.Errorf(\"got %v: expected %f\", f, 123.456)\n\t}\n\n\tf = s.GetFloat(ctx, \"baz\")\n\tif f != 0 {\n\t\tt.Errorf(\"got %v: expected %f\", f, 0.00)\n\t}\n}\n\nfunc TestGetBytes(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = []byte(\"bar\")\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tb := s.GetBytes(ctx, \"foo\")\n\tif !bytes.Equal(b, []byte(\"bar\")) {\n\t\tt.Errorf(\"got %v: expected %v\", b, []byte(\"bar\"))\n\t}\n\n\tb = s.GetBytes(ctx, \"baz\")\n\tif b != nil {\n\t\tt.Errorf(\"got %v: expected %v\", b, nil)\n\t}\n}\n\nfunc TestGetTime(t *testing.T) {\n\tt.Parallel()\n\n\tnow := time.Now()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = now\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\ttm := s.GetTime(ctx, \"foo\")\n\tif tm != now {\n\t\tt.Errorf(\"got %v: expected %v\", tm, now)\n\t}\n\n\ttm = s.GetTime(ctx, \"baz\")\n\tif !tm.IsZero() {\n\t\tt.Errorf(\"got %v: expected %v\", tm, time.Time{})\n\t}\n}\n\nfunc TestPopString(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = \"bar\"\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tstr := s.PopString(ctx, \"foo\")\n\tif str != \"bar\" {\n\t\tt.Errorf(\"got %q: expected %q\", str, \"bar\")\n\t}\n\n\t_, ok := sd.values[\"foo\"]\n\tif ok {\n\t\tt.Errorf(\"got %v: expected %v\", ok, false)\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n\n\tstr = s.PopString(ctx, \"bar\")\n\tif str != \"\" {\n\t\tt.Errorf(\"got %q: expected %q\", str, \"\")\n\t}\n}\n\nfunc TestPopBool(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = true\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tb := s.PopBool(ctx, \"foo\")\n\tif b != true {\n\t\tt.Errorf(\"got %v: expected %v\", b, true)\n\t}\n\n\t_, ok := sd.values[\"foo\"]\n\tif ok {\n\t\tt.Errorf(\"got %v: expected %v\", ok, false)\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n\n\tb = s.PopBool(ctx, \"bar\")\n\tif b != false {\n\t\tt.Errorf(\"got %v: expected %v\", b, false)\n\t}\n}\n\nfunc TestPopInt(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = 123\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\ti := s.PopInt(ctx, \"foo\")\n\tif i != 123 {\n\t\tt.Errorf(\"got %d: expected %d\", i, 123)\n\t}\n\n\t_, ok := sd.values[\"foo\"]\n\tif ok {\n\t\tt.Errorf(\"got %v: expected %v\", ok, false)\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n\n\ti = s.PopInt(ctx, \"bar\")\n\tif i != 0 {\n\t\tt.Errorf(\"got %d: expected %d\", i, 0)\n\t}\n}\n\nfunc TestPopFloat(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = 123.456\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tf := s.PopFloat(ctx, \"foo\")\n\tif f != 123.456 {\n\t\tt.Errorf(\"got %f: expected %f\", f, 123.456)\n\t}\n\n\t_, ok := sd.values[\"foo\"]\n\tif ok {\n\t\tt.Errorf(\"got %v: expected %v\", ok, false)\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n\n\tf = s.PopFloat(ctx, \"bar\")\n\tif f != 0.0 {\n\t\tt.Errorf(\"got %f: expected %f\", f, 0.0)\n\t}\n}\n\nfunc TestPopBytes(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = []byte(\"bar\")\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tb := s.PopBytes(ctx, \"foo\")\n\tif !bytes.Equal(b, []byte(\"bar\")) {\n\t\tt.Errorf(\"got %v: expected %v\", b, []byte(\"bar\"))\n\t}\n\t_, ok := sd.values[\"foo\"]\n\tif ok {\n\t\tt.Errorf(\"got %v: expected %v\", ok, false)\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n\n\tb = s.PopBytes(ctx, \"bar\")\n\tif b != nil {\n\t\tt.Errorf(\"got %v: expected %v\", b, nil)\n\t}\n}\n\nfunc TestPopTime(t *testing.T) {\n\tt.Parallel()\n\n\tnow := time.Now()\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tsd.values[\"foo\"] = now\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\ttm := s.PopTime(ctx, \"foo\")\n\tif tm != now {\n\t\tt.Errorf(\"got %v: expected %v\", tm, now)\n\t}\n\n\t_, ok := sd.values[\"foo\"]\n\tif ok {\n\t\tt.Errorf(\"got %v: expected %v\", ok, false)\n\t}\n\n\tif sd.status != Modified {\n\t\tt.Errorf(\"got %v: expected %v\", sd.status, \"modified\")\n\t}\n\n\ttm = s.PopTime(ctx, \"baz\")\n\tif !tm.IsZero() {\n\t\tt.Errorf(\"got %v: expected %v\", tm, time.Time{})\n\t}\n\n}\n\nfunc TestStatus(t *testing.T) {\n\tt.Parallel()\n\n\ts := New()\n\tsd := newSessionData(time.Hour)\n\tctx := s.addSessionDataToContext(context.Background(), sd)\n\n\tstatus := s.Status(ctx)\n\tif status != Unmodified {\n\t\tt.Errorf(\"got %d: expected %d\", status, Unmodified)\n\t}\n\n\ts.Put(ctx, \"foo\", \"bar\")\n\tstatus = s.Status(ctx)\n\tif status != Modified {\n\t\tt.Errorf(\"got %d: expected %d\", status, Modified)\n\t}\n\n\tif err := s.Destroy(ctx); err != nil {\n\t\tt.Errorf(\"unexpected error destroying session data: %v\", err)\n\t}\n\n\tstatus = s.Status(ctx)\n\tif status != Destroyed {\n\t\tt.Errorf(\"got %d: expected %d\", status, Destroyed)\n\t}\n}\n"
        },
        {
          "name": "etcdstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "firestore",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.044921875,
          "content": "module github.com/alexedwards/scs/v2\n\ngo 1.12\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "goredisstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "gormstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "leveldbstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "memstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "mockstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "mongodbstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "mssqlstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "mysqlstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "pgxstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "postgresstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "redisstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 8.08984375,
          "content": "package scs\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/alexedwards/scs/v2/memstore\"\n)\n\n// Deprecated: Session is a backwards-compatible alias for SessionManager.\ntype Session = SessionManager\n\n// SessionManager holds the configuration settings for your sessions.\ntype SessionManager struct {\n\t// IdleTimeout controls the maximum length of time a session can be inactive\n\t// before it expires. For example, some applications may wish to set this so\n\t// there is a timeout after 20 minutes of inactivity. By default IdleTimeout\n\t// is not set and there is no inactivity timeout.\n\tIdleTimeout time.Duration\n\n\t// Lifetime controls the maximum length of time that a session is valid for\n\t// before it expires. The lifetime is an 'absolute expiry' which is set when\n\t// the session is first created and does not change. The default value is 24\n\t// hours.\n\tLifetime time.Duration\n\n\t// Store controls the session store where the session data is persisted.\n\tStore Store\n\n\t// Cookie contains the configuration settings for session cookies.\n\tCookie SessionCookie\n\n\t// Codec controls the encoder/decoder used to transform session data to a\n\t// byte slice for use by the session store. By default session data is\n\t// encoded/decoded using encoding/gob.\n\tCodec Codec\n\n\t// ErrorFunc allows you to control behavior when an error is encountered by\n\t// the LoadAndSave middleware. The default behavior is for a HTTP 500\n\t// \"Internal Server Error\" message to be sent to the client and the error\n\t// logged using Go's standard logger. If a custom ErrorFunc is set, then\n\t// control will be passed to this instead. A typical use would be to provide\n\t// a function which logs the error and returns a customized HTML error page.\n\tErrorFunc func(http.ResponseWriter, *http.Request, error)\n\n\t// HashTokenInStore controls whether or not to store the session token or a hashed version in the store.\n\tHashTokenInStore bool\n\n\t// contextKey is the key used to set and retrieve the session data from a\n\t// context.Context. It's automatically generated to ensure uniqueness.\n\tcontextKey contextKey\n}\n\n// SessionCookie contains the configuration settings for session cookies.\ntype SessionCookie struct {\n\t// Name sets the name of the session cookie. It should not contain\n\t// whitespace, commas, colons, semicolons, backslashes, the equals sign or\n\t// control characters as per RFC6265. The default cookie name is \"session\".\n\t// If your application uses two different sessions, you must make sure that\n\t// the cookie name for each is unique.\n\tName string\n\n\t// Domain sets the 'Domain' attribute on the session cookie. By default\n\t// it will be set to the domain name that the cookie was issued from.\n\tDomain string\n\n\t// HttpOnly sets the 'HttpOnly' attribute on the session cookie. The\n\t// default value is true.\n\tHttpOnly bool\n\n\t// Path sets the 'Path' attribute on the session cookie. The default value\n\t// is \"/\". Passing the empty string \"\" will result in it being set to the\n\t// path that the cookie was issued from.\n\tPath string\n\n\t// Persist sets whether the session cookie should be persistent or not\n\t// (i.e. whether it should be retained after a user closes their browser).\n\t// The default value is true, which means that the session cookie will not\n\t// be destroyed when the user closes their browser and the appropriate\n\t// 'Expires' and 'MaxAge' values will be added to the session cookie. If you\n\t// want to only persist some sessions (rather than all of them), then set this\n\t// to false and call the RememberMe() method for the specific sessions that you\n\t// want to persist.\n\tPersist bool\n\n\t// SameSite controls the value of the 'SameSite' attribute on the session\n\t// cookie. By default this is set to 'SameSite=Lax'. If you want no SameSite\n\t// attribute or value in the session cookie then you should set this to 0.\n\tSameSite http.SameSite\n\n\t// Secure sets the 'Secure' attribute on the session cookie. The default\n\t// value is false. It's recommended that you set this to true and serve all\n\t// requests over HTTPS in production environments.\n\t// See https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Session_Management_Cheat_Sheet.md#transport-layer-security.\n\tSecure bool\n}\n\n// New returns a new session manager with the default options. It is safe for\n// concurrent use.\nfunc New() *SessionManager {\n\ts := &SessionManager{\n\t\tIdleTimeout: 0,\n\t\tLifetime:    24 * time.Hour,\n\t\tStore:       memstore.New(),\n\t\tCodec:       GobCodec{},\n\t\tErrorFunc:   defaultErrorFunc,\n\t\tcontextKey:  generateContextKey(),\n\t\tCookie: SessionCookie{\n\t\t\tName:     \"session\",\n\t\t\tDomain:   \"\",\n\t\t\tHttpOnly: true,\n\t\t\tPath:     \"/\",\n\t\t\tPersist:  true,\n\t\t\tSecure:   false,\n\t\t\tSameSite: http.SameSiteLaxMode,\n\t\t},\n\t}\n\treturn s\n}\n\n// Deprecated: NewSession is a backwards-compatible alias for New. Use the New\n// function instead.\nfunc NewSession() *SessionManager {\n\treturn New()\n}\n\n// LoadAndSave provides middleware which automatically loads and saves session\n// data for the current request, and communicates the session token to and from\n// the client in a cookie.\nfunc (s *SessionManager) LoadAndSave(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Add(\"Vary\", \"Cookie\")\n\n\t\tvar token string\n\t\tcookie, err := r.Cookie(s.Cookie.Name)\n\t\tif err == nil {\n\t\t\ttoken = cookie.Value\n\t\t}\n\n\t\tctx, err := s.Load(r.Context(), token)\n\t\tif err != nil {\n\t\t\ts.ErrorFunc(w, r, err)\n\t\t\treturn\n\t\t}\n\n\t\tsr := r.WithContext(ctx)\n\n\t\tsw := &sessionResponseWriter{\n\t\t\tResponseWriter: w,\n\t\t\trequest:        sr,\n\t\t\tsessionManager: s,\n\t\t}\n\n\t\tnext.ServeHTTP(sw, sr)\n\n\t\tif !sw.written {\n\t\t\ts.commitAndWriteSessionCookie(w, sr)\n\t\t}\n\t})\n}\n\nfunc (s *SessionManager) commitAndWriteSessionCookie(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tswitch s.Status(ctx) {\n\tcase Modified:\n\t\ttoken, expiry, err := s.Commit(ctx)\n\t\tif err != nil {\n\t\t\ts.ErrorFunc(w, r, err)\n\t\t\treturn\n\t\t}\n\n\t\ts.WriteSessionCookie(ctx, w, token, expiry)\n\tcase Destroyed:\n\t\ts.WriteSessionCookie(ctx, w, \"\", time.Time{})\n\t}\n}\n\n// WriteSessionCookie writes a cookie to the HTTP response with the provided\n// token as the cookie value and expiry as the cookie expiry time. The expiry\n// time will be included in the cookie only if the session is set to persist\n// or has had RememberMe(true) called on it. If expiry is an empty time.Time\n// struct (so that it's IsZero() method returns true) the cookie will be\n// marked with a historical expiry time and negative max-age (so the browser\n// deletes it).\n//\n// Most applications will use the LoadAndSave() middleware and will not need to\n// use this method.\nfunc (s *SessionManager) WriteSessionCookie(ctx context.Context, w http.ResponseWriter, token string, expiry time.Time) {\n\tcookie := &http.Cookie{\n\t\tName:     s.Cookie.Name,\n\t\tValue:    token,\n\t\tPath:     s.Cookie.Path,\n\t\tDomain:   s.Cookie.Domain,\n\t\tSecure:   s.Cookie.Secure,\n\t\tHttpOnly: s.Cookie.HttpOnly,\n\t\tSameSite: s.Cookie.SameSite,\n\t}\n\n\tif expiry.IsZero() {\n\t\tcookie.Expires = time.Unix(1, 0)\n\t\tcookie.MaxAge = -1\n\t} else if s.Cookie.Persist || s.GetBool(ctx, \"__rememberMe\") {\n\t\tcookie.Expires = time.Unix(expiry.Unix()+1, 0)        // Round up to the nearest second.\n\t\tcookie.MaxAge = int(time.Until(expiry).Seconds() + 1) // Round up to the nearest second.\n\t}\n\n\tw.Header().Add(\"Set-Cookie\", cookie.String())\n\tw.Header().Add(\"Cache-Control\", `no-cache=\"Set-Cookie\"`)\n}\n\nfunc defaultErrorFunc(w http.ResponseWriter, r *http.Request, err error) {\n\tlog.Output(2, err.Error())\n\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n}\n\ntype sessionResponseWriter struct {\n\thttp.ResponseWriter\n\trequest        *http.Request\n\tsessionManager *SessionManager\n\twritten        bool\n}\n\nfunc (sw *sessionResponseWriter) Write(b []byte) (int, error) {\n\tif !sw.written {\n\t\tsw.sessionManager.commitAndWriteSessionCookie(sw.ResponseWriter, sw.request)\n\t\tsw.written = true\n\t}\n\n\treturn sw.ResponseWriter.Write(b)\n}\n\nfunc (sw *sessionResponseWriter) WriteHeader(code int) {\n\tif !sw.written {\n\t\tsw.sessionManager.commitAndWriteSessionCookie(sw.ResponseWriter, sw.request)\n\t\tsw.written = true\n\t}\n\n\tsw.ResponseWriter.WriteHeader(code)\n}\n\nfunc (sw *sessionResponseWriter) Unwrap() http.ResponseWriter {\n\treturn sw.ResponseWriter\n}\n"
        },
        {
          "name": "session_go120.go",
          "type": "blob",
          "size": 0.328125,
          "content": "//go:build go1.20\n// +build go1.20\n\npackage scs\n\nimport (\n\t\"bufio\"\n\t\"net\"\n\t\"net/http\"\n)\n\nfunc (sw *sessionResponseWriter) Flush() {\n\thttp.NewResponseController(sw.ResponseWriter).Flush()\n}\n\nfunc (sw *sessionResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\treturn http.NewResponseController(sw.ResponseWriter).Hijack()\n}\n"
        },
        {
          "name": "session_go120_test.go",
          "type": "blob",
          "size": 1.07421875,
          "content": "//go:build go1.20\n// +build go1.20\n\npackage scs\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestFlusher(t *testing.T) {\n\tt.Parallel()\n\n\tsessionManager := New()\n\tsessionManager.Lifetime = 500 * time.Millisecond\n\n\tmux := http.NewServeMux()\n\n\tmux.HandleFunc(\"/get\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, ok := w.(http.Flusher)\n\n\t\tfmt.Fprint(w, ok)\n\t}))\n\n\tts := newTestServer(t, sessionManager.LoadAndSave(mux))\n\tdefer ts.Close()\n\n\tts.execute(t, \"/put\")\n\n\t_, body := ts.execute(t, \"/get\")\n\tif body != \"true\" {\n\t\tt.Errorf(\"want %q; got %q\", \"true\", body)\n\t}\n}\n\nfunc TestHijacker(t *testing.T) {\n\tt.Parallel()\n\n\tsessionManager := New()\n\tsessionManager.Lifetime = 500 * time.Millisecond\n\n\tmux := http.NewServeMux()\n\n\tmux.HandleFunc(\"/get\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, ok := w.(http.Hijacker)\n\n\t\tfmt.Fprint(w, ok)\n\t}))\n\n\tts := newTestServer(t, sessionManager.LoadAndSave(mux))\n\tdefer ts.Close()\n\n\tts.execute(t, \"/put\")\n\n\t_, body := ts.execute(t, \"/get\")\n\tif body != \"true\" {\n\t\tt.Errorf(\"want %q; got %q\", \"true\", body)\n\t}\n}\n"
        },
        {
          "name": "session_test.go",
          "type": "blob",
          "size": 9.1015625,
          "content": "package scs\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype testServer struct {\n\t*httptest.Server\n}\n\nfunc newTestServer(t *testing.T, h http.Handler) *testServer {\n\tts := httptest.NewTLSServer(h)\n\n\tjar, err := cookiejar.New(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tts.Client().Jar = jar\n\n\tts.Client().CheckRedirect = func(req *http.Request, via []*http.Request) error {\n\t\treturn http.ErrUseLastResponse\n\t}\n\n\treturn &testServer{ts}\n}\n\nfunc (ts *testServer) execute(t *testing.T, urlPath string) (http.Header, string) {\n\trs, err := ts.Client().Get(ts.URL + urlPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer rs.Body.Close()\n\tbody, err := ioutil.ReadAll(rs.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn rs.Header, string(body)\n}\n\nfunc extractTokenFromCookie(c string) string {\n\tparts := strings.Split(c, \";\")\n\treturn strings.SplitN(parts[0], \"=\", 2)[1]\n}\n\nfunc TestEnable(t *testing.T) {\n\tt.Parallel()\n\n\tsessionManager := New()\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/put\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsessionManager.Put(r.Context(), \"foo\", \"bar\")\n\t}))\n\tmux.HandleFunc(\"/get\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ts := sessionManager.Get(r.Context(), \"foo\").(string)\n\t\tw.Write([]byte(s))\n\t}))\n\n\tts := newTestServer(t, sessionManager.LoadAndSave(mux))\n\tdefer ts.Close()\n\n\theader, _ := ts.execute(t, \"/put\")\n\ttoken1 := extractTokenFromCookie(header.Get(\"Set-Cookie\"))\n\n\theader, body := ts.execute(t, \"/get\")\n\tif body != \"bar\" {\n\t\tt.Errorf(\"want %q; got %q\", \"bar\", body)\n\t}\n\tif header.Get(\"Set-Cookie\") != \"\" {\n\t\tt.Errorf(\"want %q; got %q\", \"\", header.Get(\"Set-Cookie\"))\n\t}\n\n\theader, _ = ts.execute(t, \"/put\")\n\ttoken2 := extractTokenFromCookie(header.Get(\"Set-Cookie\"))\n\tif token1 != token2 {\n\t\tt.Error(\"want tokens to be the same\")\n\t}\n}\n\nfunc TestLifetime(t *testing.T) {\n\tt.Parallel()\n\n\tsessionManager := New()\n\tsessionManager.Lifetime = 500 * time.Millisecond\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/put\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsessionManager.Put(r.Context(), \"foo\", \"bar\")\n\t}))\n\tmux.HandleFunc(\"/get\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tv := sessionManager.Get(r.Context(), \"foo\")\n\t\tif v == nil {\n\t\t\thttp.Error(w, \"foo does not exist in session\", 500)\n\t\t\treturn\n\t\t}\n\t\tw.Write([]byte(v.(string)))\n\t}))\n\n\tts := newTestServer(t, sessionManager.LoadAndSave(mux))\n\tdefer ts.Close()\n\n\tts.execute(t, \"/put\")\n\n\t_, body := ts.execute(t, \"/get\")\n\tif body != \"bar\" {\n\t\tt.Errorf(\"want %q; got %q\", \"bar\", body)\n\t}\n\ttime.Sleep(time.Second)\n\n\t_, body = ts.execute(t, \"/get\")\n\tif body != \"foo does not exist in session\\n\" {\n\t\tt.Errorf(\"want %q; got %q\", \"foo does not exist in session\\n\", body)\n\t}\n}\n\nfunc TestIdleTimeout(t *testing.T) {\n\tt.Parallel()\n\n\tsessionManager := New()\n\tsessionManager.IdleTimeout = 200 * time.Millisecond\n\tsessionManager.Lifetime = time.Second\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/put\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsessionManager.Put(r.Context(), \"foo\", \"bar\")\n\t}))\n\tmux.HandleFunc(\"/get\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tv := sessionManager.Get(r.Context(), \"foo\")\n\t\tif v == nil {\n\t\t\thttp.Error(w, \"foo does not exist in session\", 500)\n\t\t\treturn\n\t\t}\n\t\tw.Write([]byte(v.(string)))\n\t}))\n\n\tts := newTestServer(t, sessionManager.LoadAndSave(mux))\n\tdefer ts.Close()\n\n\tts.execute(t, \"/put\")\n\n\ttime.Sleep(100 * time.Millisecond)\n\tts.execute(t, \"/get\")\n\n\ttime.Sleep(150 * time.Millisecond)\n\t_, body := ts.execute(t, \"/get\")\n\tif body != \"bar\" {\n\t\tt.Errorf(\"want %q; got %q\", \"bar\", body)\n\t}\n\n\ttime.Sleep(200 * time.Millisecond)\n\t_, body = ts.execute(t, \"/get\")\n\tif body != \"foo does not exist in session\\n\" {\n\t\tt.Errorf(\"want %q; got %q\", \"foo does not exist in session\\n\", body)\n\t}\n}\n\nfunc TestDestroy(t *testing.T) {\n\tt.Parallel()\n\n\tsessionManager := New()\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/put\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsessionManager.Put(r.Context(), \"foo\", \"bar\")\n\t}))\n\tmux.HandleFunc(\"/destroy\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\terr := sessionManager.Destroy(r.Context())\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\treturn\n\t\t}\n\t}))\n\tmux.HandleFunc(\"/get\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tv := sessionManager.Get(r.Context(), \"foo\")\n\t\tif v == nil {\n\t\t\thttp.Error(w, \"foo does not exist in session\", 500)\n\t\t\treturn\n\t\t}\n\t\tw.Write([]byte(v.(string)))\n\t}))\n\n\tts := newTestServer(t, sessionManager.LoadAndSave(mux))\n\tdefer ts.Close()\n\n\tts.execute(t, \"/put\")\n\theader, _ := ts.execute(t, \"/destroy\")\n\tcookie := header.Get(\"Set-Cookie\")\n\n\tif strings.HasPrefix(cookie, fmt.Sprintf(\"%s=;\", sessionManager.Cookie.Name)) == false {\n\t\tt.Fatalf(\"got %q: expected prefix %q\", cookie, fmt.Sprintf(\"%s=;\", sessionManager.Cookie.Name))\n\t}\n\tif strings.Contains(cookie, \"Expires=Thu, 01 Jan 1970 00:00:01 GMT\") == false {\n\t\tt.Fatalf(\"got %q: expected to contain %q\", cookie, \"Expires=Thu, 01 Jan 1970 00:00:01 GMT\")\n\t}\n\tif strings.Contains(cookie, \"Max-Age=0\") == false {\n\t\tt.Fatalf(\"got %q: expected to contain %q\", cookie, \"Max-Age=0\")\n\t}\n\n\t_, body := ts.execute(t, \"/get\")\n\tif body != \"foo does not exist in session\\n\" {\n\t\tt.Errorf(\"want %q; got %q\", \"foo does not exist in session\\n\", body)\n\t}\n}\n\nfunc TestRenewToken(t *testing.T) {\n\tt.Parallel()\n\n\tsessionManager := New()\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/put\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsessionManager.Put(r.Context(), \"foo\", \"bar\")\n\t}))\n\tmux.HandleFunc(\"/renew\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\terr := sessionManager.RenewToken(r.Context())\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), 500)\n\t\t\treturn\n\t\t}\n\t}))\n\tmux.HandleFunc(\"/get\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tv := sessionManager.Get(r.Context(), \"foo\")\n\t\tif v == nil {\n\t\t\thttp.Error(w, \"foo does not exist in session\", 500)\n\t\t\treturn\n\t\t}\n\t\tw.Write([]byte(v.(string)))\n\t}))\n\n\tts := newTestServer(t, sessionManager.LoadAndSave(mux))\n\tdefer ts.Close()\n\n\theader, _ := ts.execute(t, \"/put\")\n\tcookie := header.Get(\"Set-Cookie\")\n\toriginalToken := extractTokenFromCookie(cookie)\n\n\theader, _ = ts.execute(t, \"/renew\")\n\tcookie = header.Get(\"Set-Cookie\")\n\tnewToken := extractTokenFromCookie(cookie)\n\n\tif newToken == originalToken {\n\t\tt.Fatal(\"token has not changed\")\n\t}\n\n\t_, body := ts.execute(t, \"/get\")\n\tif body != \"bar\" {\n\t\tt.Errorf(\"want %q; got %q\", \"bar\", body)\n\t}\n}\n\nfunc TestRememberMe(t *testing.T) {\n\tt.Parallel()\n\n\tsessionManager := New()\n\tsessionManager.Cookie.Persist = false\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/put-normal\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsessionManager.Put(r.Context(), \"foo\", \"bar\")\n\t}))\n\tmux.HandleFunc(\"/put-rememberMe-true\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsessionManager.RememberMe(r.Context(), true)\n\t\tsessionManager.Put(r.Context(), \"foo\", \"bar\")\n\t}))\n\tmux.HandleFunc(\"/put-rememberMe-false\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsessionManager.RememberMe(r.Context(), false)\n\t\tsessionManager.Put(r.Context(), \"foo\", \"bar\")\n\t}))\n\n\tts := newTestServer(t, sessionManager.LoadAndSave(mux))\n\tdefer ts.Close()\n\n\theader, _ := ts.execute(t, \"/put-normal\")\n\theader.Get(\"Set-Cookie\")\n\n\tif strings.Contains(header.Get(\"Set-Cookie\"), \"Max-Age=\") || strings.Contains(header.Get(\"Set-Cookie\"), \"Expires=\") {\n\t\tt.Errorf(\"want no Max-Age or Expires attributes; got %q\", header.Get(\"Set-Cookie\"))\n\t}\n\n\theader, _ = ts.execute(t, \"/put-rememberMe-true\")\n\theader.Get(\"Set-Cookie\")\n\n\tif !strings.Contains(header.Get(\"Set-Cookie\"), \"Max-Age=\") || !strings.Contains(header.Get(\"Set-Cookie\"), \"Expires=\") {\n\t\tt.Errorf(\"want Max-Age and Expires attributes; got %q\", header.Get(\"Set-Cookie\"))\n\t}\n\n\theader, _ = ts.execute(t, \"/put-rememberMe-false\")\n\theader.Get(\"Set-Cookie\")\n\n\tif strings.Contains(header.Get(\"Set-Cookie\"), \"Max-Age=\") || strings.Contains(header.Get(\"Set-Cookie\"), \"Expires=\") {\n\t\tt.Errorf(\"want no Max-Age or Expires attributes; got %q\", header.Get(\"Set-Cookie\"))\n\t}\n}\n\nfunc TestIterate(t *testing.T) {\n\tt.Parallel()\n\n\tsessionManager := New()\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/put\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsessionManager.Put(r.Context(), \"foo\", r.URL.Query().Get(\"foo\"))\n\t}))\n\n\tfor i := 0; i < 3; i++ {\n\t\tts := newTestServer(t, sessionManager.LoadAndSave(mux))\n\t\tdefer ts.Close()\n\n\t\tts.execute(t, \"/put?foo=\"+strconv.Itoa(i))\n\t}\n\n\tresults := []string{}\n\n\terr := sessionManager.Iterate(context.Background(), func(ctx context.Context) error {\n\t\ti := sessionManager.GetString(ctx, \"foo\")\n\t\tresults = append(results, i)\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsort.Strings(results)\n\n\tif !reflect.DeepEqual(results, []string{\"0\", \"1\", \"2\"}) {\n\t\tt.Fatalf(\"unexpected value: got %v\", results)\n\t}\n\n\terr = sessionManager.Iterate(context.Background(), func(ctx context.Context) error {\n\t\treturn errors.New(\"expected error\")\n\t})\n\tif err.Error() != \"expected error\" {\n\t\tt.Fatal(\"didn't get expected error\")\n\t}\n}\n"
        },
        {
          "name": "sqlite3store",
          "type": "tree",
          "content": null
        },
        {
          "name": "store.go",
          "type": "blob",
          "size": 2.2783203125,
          "content": "package scs\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\n// Store is the interface for session stores.\ntype Store interface {\n\t// Delete should remove the session token and corresponding data from the\n\t// session store. If the token does not exist then Delete should be a no-op\n\t// and return nil (not an error).\n\tDelete(token string) (err error)\n\n\t// Find should return the data for a session token from the store. If the\n\t// session token is not found or is expired, the found return value should\n\t// be false (and the err return value should be nil). Similarly, tampered\n\t// or malformed tokens should result in a found return value of false and a\n\t// nil err value. The err return value should be used for system errors only.\n\tFind(token string) (b []byte, found bool, err error)\n\n\t// Commit should add the session token and data to the store, with the given\n\t// expiry time. If the session token already exists, then the data and\n\t// expiry time should be overwritten.\n\tCommit(token string, b []byte, expiry time.Time) (err error)\n}\n\n// IterableStore is the interface for session stores which support iteration.\ntype IterableStore interface {\n\t// All should return a map containing data for all active sessions (i.e.\n\t// sessions which have not expired). The map key should be the session\n\t// token and the map value should be the session data. If no active\n\t// sessions exist this should return an empty (not nil) map.\n\tAll() (map[string][]byte, error)\n}\n\n// CtxStore is an interface for session stores which take a context.Context\n// parameter.\ntype CtxStore interface {\n\tStore\n\n\t// DeleteCtx is the same as Store.Delete, except it takes a context.Context.\n\tDeleteCtx(ctx context.Context, token string) (err error)\n\n\t// FindCtx is the same as Store.Find, except it takes a context.Context.\n\tFindCtx(ctx context.Context, token string) (b []byte, found bool, err error)\n\n\t// CommitCtx is the same as Store.Commit, except it takes a context.Context.\n\tCommitCtx(ctx context.Context, token string, b []byte, expiry time.Time) (err error)\n}\n\n// IterableCtxStore is the interface for session stores which support iteration\n// and which take a context.Context parameter.\ntype IterableCtxStore interface {\n\t// AllCtx is the same as IterableStore.All, expect it takes a\n\t// context.Context.\n\tAllCtx(ctx context.Context) (map[string][]byte, error)\n}\n"
        }
      ]
    }
  ]
}