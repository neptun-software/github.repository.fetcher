{
  "metadata": {
    "timestamp": 1736566652750,
    "page": 204,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "coder/websocket",
      "stars": 4062,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 0.7236328125,
          "content": "Copyright (c) 2023 Anmol Sethi <hi@nhooyr.io>\n\nPermission to use, copy, modify, and distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.81640625,
          "content": "# websocket\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/coder/websocket.svg)](https://pkg.go.dev/github.com/coder/websocket)\n[![Go Coverage](https://coder.github.io/websocket/coverage.svg)](https://coder.github.io/websocket/coverage.html)\n\nwebsocket is a minimal and idiomatic WebSocket library for Go.\n\n## Install\n\n```sh\ngo get github.com/coder/websocket\n```\n\n> [!NOTE]\n> Coder now maintains this project as explained in [this blog post](https://coder.com/blog/websocket).\n> We're grateful to [nhooyr](https://github.com/nhooyr) for authoring and maintaining this project from\n> 2019 to 2024.\n\n## Highlights\n\n- Minimal and idiomatic API\n- First class [context.Context](https://blog.golang.org/context) support\n- Fully passes the WebSocket [autobahn-testsuite](https://github.com/crossbario/autobahn-testsuite)\n- [Zero dependencies](https://pkg.go.dev/github.com/coder/websocket?tab=imports)\n- JSON helpers in the [wsjson](https://pkg.go.dev/github.com/coder/websocket/wsjson) subpackage\n- Zero alloc reads and writes\n- Concurrent writes\n- [Close handshake](https://pkg.go.dev/github.com/coder/websocket#Conn.Close)\n- [net.Conn](https://pkg.go.dev/github.com/coder/websocket#NetConn) wrapper\n- [Ping pong](https://pkg.go.dev/github.com/coder/websocket#Conn.Ping) API\n- [RFC 7692](https://tools.ietf.org/html/rfc7692) permessage-deflate compression\n- [CloseRead](https://pkg.go.dev/github.com/coder/websocket#Conn.CloseRead) helper for write only connections\n- Compile to [Wasm](https://pkg.go.dev/github.com/coder/websocket#hdr-Wasm)\n\n## Roadmap\n\nSee GitHub issues for minor issues but the major future enhancements are:\n\n- [ ] Perfect examples [#217](https://github.com/nhooyr/websocket/issues/217)\n- [ ] wstest.Pipe for in memory testing [#340](https://github.com/nhooyr/websocket/issues/340)\n- [ ] Ping pong heartbeat helper [#267](https://github.com/nhooyr/websocket/issues/267)\n- [ ] Ping pong instrumentation callbacks [#246](https://github.com/nhooyr/websocket/issues/246)\n- [ ] Graceful shutdown helpers [#209](https://github.com/nhooyr/websocket/issues/209)\n- [ ] Assembly for WebSocket masking [#16](https://github.com/nhooyr/websocket/issues/16)\n  - WIP at [#326](https://github.com/nhooyr/websocket/pull/326), about 3x faster\n- [ ] HTTP/2 [#4](https://github.com/nhooyr/websocket/issues/4)\n- [ ] The holy grail [#402](https://github.com/nhooyr/websocket/issues/402)\n\n## Examples\n\nFor a production quality example that demonstrates the complete API, see the\n[echo example](./internal/examples/echo).\n\nFor a full stack example, see the [chat example](./internal/examples/chat).\n\n### Server\n\n```go\nhttp.HandlerFunc(func (w http.ResponseWriter, r *http.Request) {\n\tc, err := websocket.Accept(w, r, nil)\n\tif err != nil {\n\t\t// ...\n\t}\n\tdefer c.CloseNow()\n\n\t// Set the context as needed. Use of r.Context() is not recommended\n\t// to avoid surprising behavior (see http.Hijacker).\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\n\tvar v interface{}\n\terr = wsjson.Read(ctx, c, &v)\n\tif err != nil {\n\t\t// ...\n\t}\n\n\tlog.Printf(\"received: %v\", v)\n\n\tc.Close(websocket.StatusNormalClosure, \"\")\n})\n```\n\n### Client\n\n```go\nctx, cancel := context.WithTimeout(context.Background(), time.Minute)\ndefer cancel()\n\nc, _, err := websocket.Dial(ctx, \"ws://localhost:8080\", nil)\nif err != nil {\n\t// ...\n}\ndefer c.CloseNow()\n\nerr = wsjson.Write(ctx, c, \"hi\")\nif err != nil {\n\t// ...\n}\n\nc.Close(websocket.StatusNormalClosure, \"\")\n```\n\n## Comparison\n\n### gorilla/websocket\n\nAdvantages of [gorilla/websocket](https://github.com/gorilla/websocket):\n\n- Mature and widely used\n- [Prepared writes](https://pkg.go.dev/github.com/gorilla/websocket#PreparedMessage)\n- Configurable [buffer sizes](https://pkg.go.dev/github.com/gorilla/websocket#hdr-Buffers)\n- No extra goroutine per connection to support cancellation with context.Context. This costs github.com/coder/websocket 2 KB of memory per connection.\n  - Will be removed soon with [context.AfterFunc](https://github.com/golang/go/issues/57928). See [#411](https://github.com/nhooyr/websocket/issues/411)\n\nAdvantages of github.com/coder/websocket:\n\n- Minimal and idiomatic API\n  - Compare godoc of [github.com/coder/websocket](https://pkg.go.dev/github.com/coder/websocket) with [gorilla/websocket](https://pkg.go.dev/github.com/gorilla/websocket) side by side.\n- [net.Conn](https://pkg.go.dev/github.com/coder/websocket#NetConn) wrapper\n- Zero alloc reads and writes ([gorilla/websocket#535](https://github.com/gorilla/websocket/issues/535))\n- Full [context.Context](https://blog.golang.org/context) support\n- Dial uses [net/http.Client](https://golang.org/pkg/net/http/#Client)\n  - Will enable easy HTTP/2 support in the future\n  - Gorilla writes directly to a net.Conn and so duplicates features of net/http.Client.\n- Concurrent writes\n- Close handshake ([gorilla/websocket#448](https://github.com/gorilla/websocket/issues/448))\n- Idiomatic [ping pong](https://pkg.go.dev/github.com/coder/websocket#Conn.Ping) API\n  - Gorilla requires registering a pong callback before sending a Ping\n- Can target Wasm ([gorilla/websocket#432](https://github.com/gorilla/websocket/issues/432))\n- Transparent message buffer reuse with [wsjson](https://pkg.go.dev/github.com/coder/websocket/wsjson) subpackage\n- [1.75x](https://github.com/nhooyr/websocket/releases/tag/v1.7.4) faster WebSocket masking implementation in pure Go\n  - Gorilla's implementation is slower and uses [unsafe](https://golang.org/pkg/unsafe/).\n    Soon we'll have assembly and be 3x faster [#326](https://github.com/nhooyr/websocket/pull/326)\n- Full [permessage-deflate](https://tools.ietf.org/html/rfc7692) compression extension support\n  - Gorilla only supports no context takeover mode\n- [CloseRead](https://pkg.go.dev/github.com/coder/websocket#Conn.CloseRead) helper for write only connections ([gorilla/websocket#492](https://github.com/gorilla/websocket/issues/492))\n\n#### golang.org/x/net/websocket\n\n[golang.org/x/net/websocket](https://pkg.go.dev/golang.org/x/net/websocket) is deprecated.\nSee [golang/go/issues/18152](https://github.com/golang/go/issues/18152).\n\nThe [net.Conn](https://pkg.go.dev/github.com/coder/websocket#NetConn) can help in transitioning\nto github.com/coder/websocket.\n\n#### gobwas/ws\n\n[gobwas/ws](https://github.com/gobwas/ws) has an extremely flexible API that allows it to be used\nin an event driven style for performance. See the author's [blog post](https://medium.freecodecamp.org/million-websockets-and-go-cc58418460bb).\n\nHowever it is quite bloated. See https://pkg.go.dev/github.com/gobwas/ws\n\nWhen writing idiomatic Go, github.com/coder/websocket will be faster and easier to use.\n\n#### lesismal/nbio\n\n[lesismal/nbio](https://github.com/lesismal/nbio) is similar to gobwas/ws in that the API is\nevent driven for performance reasons.\n\nHowever it is quite bloated. See https://pkg.go.dev/github.com/lesismal/nbio\n\nWhen writing idiomatic Go, github.com/coder/websocket will be faster and easier to use.\n"
        },
        {
          "name": "accept.go",
          "type": "blob",
          "size": 10.23046875,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha1\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"net/url\"\n\t\"path\"\n\t\"strings\"\n\n\t\"github.com/coder/websocket/internal/errd\"\n)\n\n// AcceptOptions represents Accept's options.\ntype AcceptOptions struct {\n\t// Subprotocols lists the WebSocket subprotocols that Accept will negotiate with the client.\n\t// The empty subprotocol will always be negotiated as per RFC 6455. If you would like to\n\t// reject it, close the connection when c.Subprotocol() == \"\".\n\tSubprotocols []string\n\n\t// InsecureSkipVerify is used to disable Accept's origin verification behaviour.\n\t//\n\t// You probably want to use OriginPatterns instead.\n\tInsecureSkipVerify bool\n\n\t// OriginPatterns lists the host patterns for authorized origins.\n\t// The request host is always authorized.\n\t// Use this to enable cross origin WebSockets.\n\t//\n\t// i.e javascript running on example.com wants to access a WebSocket server at chat.example.com.\n\t// In such a case, example.com is the origin and chat.example.com is the request host.\n\t// One would set this field to []string{\"example.com\"} to authorize example.com to connect.\n\t//\n\t// Each pattern is matched case insensitively against the request origin host\n\t// with path.Match.\n\t// See https://golang.org/pkg/path/#Match\n\t//\n\t// Please ensure you understand the ramifications of enabling this.\n\t// If used incorrectly your WebSocket server will be open to CSRF attacks.\n\t//\n\t// Do not use * as a pattern to allow any origin, prefer to use InsecureSkipVerify instead\n\t// to bring attention to the danger of such a setting.\n\tOriginPatterns []string\n\n\t// CompressionMode controls the compression mode.\n\t// Defaults to CompressionDisabled.\n\t//\n\t// See docs on CompressionMode for details.\n\tCompressionMode CompressionMode\n\n\t// CompressionThreshold controls the minimum size of a message before compression is applied.\n\t//\n\t// Defaults to 512 bytes for CompressionNoContextTakeover and 128 bytes\n\t// for CompressionContextTakeover.\n\tCompressionThreshold int\n}\n\nfunc (opts *AcceptOptions) cloneWithDefaults() *AcceptOptions {\n\tvar o AcceptOptions\n\tif opts != nil {\n\t\to = *opts\n\t}\n\treturn &o\n}\n\n// Accept accepts a WebSocket handshake from a client and upgrades the\n// the connection to a WebSocket.\n//\n// Accept will not allow cross origin requests by default.\n// See the InsecureSkipVerify and OriginPatterns options to allow cross origin requests.\n//\n// Accept will write a response to w on all errors.\n//\n// Note that using the http.Request Context after Accept returns may lead to\n// unexpected behavior (see http.Hijacker).\nfunc Accept(w http.ResponseWriter, r *http.Request, opts *AcceptOptions) (*Conn, error) {\n\treturn accept(w, r, opts)\n}\n\nfunc accept(w http.ResponseWriter, r *http.Request, opts *AcceptOptions) (_ *Conn, err error) {\n\tdefer errd.Wrap(&err, \"failed to accept WebSocket connection\")\n\n\terrCode, err := verifyClientRequest(w, r)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), errCode)\n\t\treturn nil, err\n\t}\n\n\topts = opts.cloneWithDefaults()\n\tif !opts.InsecureSkipVerify {\n\t\terr = authenticateOrigin(r, opts.OriginPatterns)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, path.ErrBadPattern) {\n\t\t\t\tlog.Printf(\"websocket: %v\", err)\n\t\t\t\terr = errors.New(http.StatusText(http.StatusForbidden))\n\t\t\t}\n\t\t\thttp.Error(w, err.Error(), http.StatusForbidden)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\thj, ok := hijacker(w)\n\tif !ok {\n\t\terr = errors.New(\"http.ResponseWriter does not implement http.Hijacker\")\n\t\thttp.Error(w, http.StatusText(http.StatusNotImplemented), http.StatusNotImplemented)\n\t\treturn nil, err\n\t}\n\n\tw.Header().Set(\"Upgrade\", \"websocket\")\n\tw.Header().Set(\"Connection\", \"Upgrade\")\n\n\tkey := r.Header.Get(\"Sec-WebSocket-Key\")\n\tw.Header().Set(\"Sec-WebSocket-Accept\", secWebSocketAccept(key))\n\n\tsubproto := selectSubprotocol(r, opts.Subprotocols)\n\tif subproto != \"\" {\n\t\tw.Header().Set(\"Sec-WebSocket-Protocol\", subproto)\n\t}\n\n\tcopts, ok := selectDeflate(websocketExtensions(r.Header), opts.CompressionMode)\n\tif ok {\n\t\tw.Header().Set(\"Sec-WebSocket-Extensions\", copts.String())\n\t}\n\n\tw.WriteHeader(http.StatusSwitchingProtocols)\n\t// See https://github.com/nhooyr/websocket/issues/166\n\tif ginWriter, ok := w.(interface {\n\t\tWriteHeaderNow()\n\t}); ok {\n\t\tginWriter.WriteHeaderNow()\n\t}\n\n\tnetConn, brw, err := hj.Hijack()\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to hijack connection: %w\", err)\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn nil, err\n\t}\n\n\t// https://github.com/golang/go/issues/32314\n\tb, _ := brw.Reader.Peek(brw.Reader.Buffered())\n\tbrw.Reader.Reset(io.MultiReader(bytes.NewReader(b), netConn))\n\n\treturn newConn(connConfig{\n\t\tsubprotocol:    w.Header().Get(\"Sec-WebSocket-Protocol\"),\n\t\trwc:            netConn,\n\t\tclient:         false,\n\t\tcopts:          copts,\n\t\tflateThreshold: opts.CompressionThreshold,\n\n\t\tbr: brw.Reader,\n\t\tbw: brw.Writer,\n\t}), nil\n}\n\nfunc verifyClientRequest(w http.ResponseWriter, r *http.Request) (errCode int, _ error) {\n\tif !r.ProtoAtLeast(1, 1) {\n\t\treturn http.StatusUpgradeRequired, fmt.Errorf(\"WebSocket protocol violation: handshake request must be at least HTTP/1.1: %q\", r.Proto)\n\t}\n\n\tif !headerContainsTokenIgnoreCase(r.Header, \"Connection\", \"Upgrade\") {\n\t\tw.Header().Set(\"Connection\", \"Upgrade\")\n\t\tw.Header().Set(\"Upgrade\", \"websocket\")\n\t\treturn http.StatusUpgradeRequired, fmt.Errorf(\"WebSocket protocol violation: Connection header %q does not contain Upgrade\", r.Header.Get(\"Connection\"))\n\t}\n\n\tif !headerContainsTokenIgnoreCase(r.Header, \"Upgrade\", \"websocket\") {\n\t\tw.Header().Set(\"Connection\", \"Upgrade\")\n\t\tw.Header().Set(\"Upgrade\", \"websocket\")\n\t\treturn http.StatusUpgradeRequired, fmt.Errorf(\"WebSocket protocol violation: Upgrade header %q does not contain websocket\", r.Header.Get(\"Upgrade\"))\n\t}\n\n\tif r.Method != \"GET\" {\n\t\treturn http.StatusMethodNotAllowed, fmt.Errorf(\"WebSocket protocol violation: handshake request method is not GET but %q\", r.Method)\n\t}\n\n\tif r.Header.Get(\"Sec-WebSocket-Version\") != \"13\" {\n\t\tw.Header().Set(\"Sec-WebSocket-Version\", \"13\")\n\t\treturn http.StatusBadRequest, fmt.Errorf(\"unsupported WebSocket protocol version (only 13 is supported): %q\", r.Header.Get(\"Sec-WebSocket-Version\"))\n\t}\n\n\twebsocketSecKeys := r.Header.Values(\"Sec-WebSocket-Key\")\n\tif len(websocketSecKeys) == 0 {\n\t\treturn http.StatusBadRequest, errors.New(\"WebSocket protocol violation: missing Sec-WebSocket-Key\")\n\t}\n\n\tif len(websocketSecKeys) > 1 {\n\t\treturn http.StatusBadRequest, errors.New(\"WebSocket protocol violation: multiple Sec-WebSocket-Key headers\")\n\t}\n\n\t// The RFC states to remove any leading or trailing whitespace.\n\twebsocketSecKey := strings.TrimSpace(websocketSecKeys[0])\n\tif v, err := base64.StdEncoding.DecodeString(websocketSecKey); err != nil || len(v) != 16 {\n\t\treturn http.StatusBadRequest, fmt.Errorf(\"WebSocket protocol violation: invalid Sec-WebSocket-Key %q, must be a 16 byte base64 encoded string\", websocketSecKey)\n\t}\n\n\treturn 0, nil\n}\n\nfunc authenticateOrigin(r *http.Request, originHosts []string) error {\n\torigin := r.Header.Get(\"Origin\")\n\tif origin == \"\" {\n\t\treturn nil\n\t}\n\n\tu, err := url.Parse(origin)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse Origin header %q: %w\", origin, err)\n\t}\n\n\tif strings.EqualFold(r.Host, u.Host) {\n\t\treturn nil\n\t}\n\n\tfor _, hostPattern := range originHosts {\n\t\tmatched, err := match(hostPattern, u.Host)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to parse path pattern %q: %w\", hostPattern, err)\n\t\t}\n\t\tif matched {\n\t\t\treturn nil\n\t\t}\n\t}\n\tif u.Host == \"\" {\n\t\treturn fmt.Errorf(\"request Origin %q is not a valid URL with a host\", origin)\n\t}\n\treturn fmt.Errorf(\"request Origin %q is not authorized for Host %q\", u.Host, r.Host)\n}\n\nfunc match(pattern, s string) (bool, error) {\n\treturn path.Match(strings.ToLower(pattern), strings.ToLower(s))\n}\n\nfunc selectSubprotocol(r *http.Request, subprotocols []string) string {\n\tcps := headerTokens(r.Header, \"Sec-WebSocket-Protocol\")\n\tfor _, sp := range subprotocols {\n\t\tfor _, cp := range cps {\n\t\t\tif strings.EqualFold(sp, cp) {\n\t\t\t\treturn cp\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc selectDeflate(extensions []websocketExtension, mode CompressionMode) (*compressionOptions, bool) {\n\tif mode == CompressionDisabled {\n\t\treturn nil, false\n\t}\n\tfor _, ext := range extensions {\n\t\tswitch ext.name {\n\t\t// We used to implement x-webkit-deflate-frame too for Safari but Safari has bugs...\n\t\t// See https://github.com/nhooyr/websocket/issues/218\n\t\tcase \"permessage-deflate\":\n\t\t\tcopts, ok := acceptDeflate(ext, mode)\n\t\t\tif ok {\n\t\t\t\treturn copts, true\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc acceptDeflate(ext websocketExtension, mode CompressionMode) (*compressionOptions, bool) {\n\tcopts := mode.opts()\n\tfor _, p := range ext.params {\n\t\tswitch p {\n\t\tcase \"client_no_context_takeover\":\n\t\t\tcopts.clientNoContextTakeover = true\n\t\t\tcontinue\n\t\tcase \"server_no_context_takeover\":\n\t\t\tcopts.serverNoContextTakeover = true\n\t\t\tcontinue\n\t\tcase \"client_max_window_bits\",\n\t\t\t\"server_max_window_bits=15\":\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.HasPrefix(p, \"client_max_window_bits=\") {\n\t\t\t// We can't adjust the deflate window, but decoding with a larger window is acceptable.\n\t\t\tcontinue\n\t\t}\n\t\treturn nil, false\n\t}\n\treturn copts, true\n}\n\nfunc headerContainsTokenIgnoreCase(h http.Header, key, token string) bool {\n\tfor _, t := range headerTokens(h, key) {\n\t\tif strings.EqualFold(t, token) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\ntype websocketExtension struct {\n\tname   string\n\tparams []string\n}\n\nfunc websocketExtensions(h http.Header) []websocketExtension {\n\tvar exts []websocketExtension\n\textStrs := headerTokens(h, \"Sec-WebSocket-Extensions\")\n\tfor _, extStr := range extStrs {\n\t\tif extStr == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tvals := strings.Split(extStr, \";\")\n\t\tfor i := range vals {\n\t\t\tvals[i] = strings.TrimSpace(vals[i])\n\t\t}\n\n\t\te := websocketExtension{\n\t\t\tname:   vals[0],\n\t\t\tparams: vals[1:],\n\t\t}\n\n\t\texts = append(exts, e)\n\t}\n\treturn exts\n}\n\nfunc headerTokens(h http.Header, key string) []string {\n\tkey = textproto.CanonicalMIMEHeaderKey(key)\n\tvar tokens []string\n\tfor _, v := range h[key] {\n\t\tv = strings.TrimSpace(v)\n\t\tfor _, t := range strings.Split(v, \",\") {\n\t\t\tt = strings.TrimSpace(t)\n\t\t\ttokens = append(tokens, t)\n\t\t}\n\t}\n\treturn tokens\n}\n\nvar keyGUID = []byte(\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")\n\nfunc secWebSocketAccept(secWebSocketKey string) string {\n\th := sha1.New()\n\th.Write([]byte(secWebSocketKey))\n\th.Write(keyGUID)\n\n\treturn base64.StdEncoding.EncodeToString(h.Sum(nil))\n}\n"
        },
        {
          "name": "accept_test.go",
          "type": "blob",
          "size": 13.326171875,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/coder/websocket/internal/test/assert\"\n\t\"github.com/coder/websocket/internal/test/xrand\"\n)\n\nfunc TestAccept(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"badClientHandshake\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\n\t\t_, err := Accept(w, r, nil)\n\t\tassert.Contains(t, err, \"protocol violation\")\n\t})\n\n\tt.Run(\"badOrigin\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\tr.Header.Set(\"Connection\", \"Upgrade\")\n\t\tr.Header.Set(\"Upgrade\", \"websocket\")\n\t\tr.Header.Set(\"Sec-WebSocket-Version\", \"13\")\n\t\tr.Header.Set(\"Sec-WebSocket-Key\", xrand.Base64(16))\n\t\tr.Header.Set(\"Origin\", \"harhar.com\")\n\n\t\t_, err := Accept(w, r, nil)\n\t\tassert.Contains(t, err, `request Origin \"harhar.com\" is not a valid URL with a host`)\n\t})\n\n\t// #247\n\tt.Run(\"unauthorizedOriginErrorMessage\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\tr.Header.Set(\"Connection\", \"Upgrade\")\n\t\tr.Header.Set(\"Upgrade\", \"websocket\")\n\t\tr.Header.Set(\"Sec-WebSocket-Version\", \"13\")\n\t\tr.Header.Set(\"Sec-WebSocket-Key\", xrand.Base64(16))\n\t\tr.Header.Set(\"Origin\", \"https://harhar.com\")\n\n\t\t_, err := Accept(w, r, nil)\n\t\tassert.Contains(t, err, `request Origin \"harhar.com\" is not authorized for Host \"example.com\"`)\n\t})\n\n\tt.Run(\"badCompression\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tnewRequest := func(extensions string) *http.Request {\n\t\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\t\tr.Header.Set(\"Connection\", \"Upgrade\")\n\t\t\tr.Header.Set(\"Upgrade\", \"websocket\")\n\t\t\tr.Header.Set(\"Sec-WebSocket-Version\", \"13\")\n\t\t\tr.Header.Set(\"Sec-WebSocket-Key\", xrand.Base64(16))\n\t\t\tr.Header.Set(\"Sec-WebSocket-Extensions\", extensions)\n\t\t\treturn r\n\t\t}\n\t\terrHijack := errors.New(\"hijack error\")\n\t\tnewResponseWriter := func() http.ResponseWriter {\n\t\t\treturn mockHijacker{\n\t\t\t\tResponseWriter: httptest.NewRecorder(),\n\t\t\t\thijack: func() (net.Conn, *bufio.ReadWriter, error) {\n\t\t\t\t\treturn nil, nil, errHijack\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tt.Run(\"withoutFallback\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tw := newResponseWriter()\n\t\t\tr := newRequest(\"permessage-deflate; harharhar\")\n\t\t\t_, err := Accept(w, r, &AcceptOptions{\n\t\t\t\tCompressionMode: CompressionNoContextTakeover,\n\t\t\t})\n\t\t\tassert.ErrorIs(t, errHijack, err)\n\t\t\tassert.Equal(t, \"extension header\", w.Header().Get(\"Sec-WebSocket-Extensions\"), \"\")\n\t\t})\n\t\tt.Run(\"withFallback\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tw := newResponseWriter()\n\t\t\tr := newRequest(\"permessage-deflate; harharhar, permessage-deflate\")\n\t\t\t_, err := Accept(w, r, &AcceptOptions{\n\t\t\t\tCompressionMode: CompressionNoContextTakeover,\n\t\t\t})\n\t\t\tassert.ErrorIs(t, errHijack, err)\n\t\t\tassert.Equal(t, \"extension header\",\n\t\t\t\tw.Header().Get(\"Sec-WebSocket-Extensions\"),\n\t\t\t\tCompressionNoContextTakeover.opts().String(),\n\t\t\t)\n\t\t})\n\t})\n\n\tt.Run(\"requireHttpHijacker\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\tr.Header.Set(\"Connection\", \"Upgrade\")\n\t\tr.Header.Set(\"Upgrade\", \"websocket\")\n\t\tr.Header.Set(\"Sec-WebSocket-Version\", \"13\")\n\t\tr.Header.Set(\"Sec-WebSocket-Key\", xrand.Base64(16))\n\n\t\t_, err := Accept(w, r, nil)\n\t\tassert.Contains(t, err, `http.ResponseWriter does not implement http.Hijacker`)\n\t})\n\n\tt.Run(\"badHijack\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tw := mockHijacker{\n\t\t\tResponseWriter: httptest.NewRecorder(),\n\t\t\thijack: func() (conn net.Conn, writer *bufio.ReadWriter, err error) {\n\t\t\t\treturn nil, nil, errors.New(\"haha\")\n\t\t\t},\n\t\t}\n\n\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\tr.Header.Set(\"Connection\", \"Upgrade\")\n\t\tr.Header.Set(\"Upgrade\", \"websocket\")\n\t\tr.Header.Set(\"Sec-WebSocket-Version\", \"13\")\n\t\tr.Header.Set(\"Sec-WebSocket-Key\", xrand.Base64(16))\n\n\t\t_, err := Accept(w, r, nil)\n\t\tassert.Contains(t, err, `failed to hijack connection`)\n\t})\n\n\tt.Run(\"wrapperHijackerIsUnwrapped\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\trr := httptest.NewRecorder()\n\t\tw := mockUnwrapper{\n\t\t\tResponseWriter: rr,\n\t\t\tunwrap: func() http.ResponseWriter {\n\t\t\t\treturn mockHijacker{\n\t\t\t\t\tResponseWriter: rr,\n\t\t\t\t\thijack: func() (conn net.Conn, writer *bufio.ReadWriter, err error) {\n\t\t\t\t\t\treturn nil, nil, errors.New(\"haha\")\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\n\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\tr.Header.Set(\"Connection\", \"Upgrade\")\n\t\tr.Header.Set(\"Upgrade\", \"websocket\")\n\t\tr.Header.Set(\"Sec-WebSocket-Version\", \"13\")\n\t\tr.Header.Set(\"Sec-WebSocket-Key\", xrand.Base64(16))\n\n\t\t_, err := Accept(w, r, nil)\n\t\tassert.Contains(t, err, \"failed to hijack connection\")\n\t})\n\n\tt.Run(\"closeRace\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tserver, _ := net.Pipe()\n\n\t\trw := bufio.NewReadWriter(bufio.NewReader(server), bufio.NewWriter(server))\n\t\tnewResponseWriter := func() http.ResponseWriter {\n\t\t\treturn mockHijacker{\n\t\t\t\tResponseWriter: httptest.NewRecorder(),\n\t\t\t\thijack: func() (net.Conn, *bufio.ReadWriter, error) {\n\t\t\t\t\treturn server, rw, nil\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tw := newResponseWriter()\n\n\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\tr.Header.Set(\"Connection\", \"Upgrade\")\n\t\tr.Header.Set(\"Upgrade\", \"websocket\")\n\t\tr.Header.Set(\"Sec-WebSocket-Version\", \"13\")\n\t\tr.Header.Set(\"Sec-WebSocket-Key\", xrand.Base64(16))\n\n\t\tc, err := Accept(w, r, nil)\n\t\twg := &sync.WaitGroup{}\n\t\twg.Add(2)\n\t\tgo func() {\n\t\t\tc.Close(StatusInternalError, \"the sky is falling\")\n\t\t\twg.Done()\n\t\t}()\n\t\tgo func() {\n\t\t\tc.CloseNow()\n\t\t\twg.Done()\n\t\t}()\n\t\twg.Wait()\n\t\tassert.Success(t, err)\n\t})\n}\n\nfunc Test_verifyClientHandshake(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname    string\n\t\tmethod  string\n\t\thttp1   bool\n\t\th       map[string]string\n\t\tsuccess bool\n\t}{\n\t\t{\n\t\t\tname: \"badConnection\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\": \"notUpgrade\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"badUpgrade\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\": \"Upgrade\",\n\t\t\t\t\"Upgrade\":    \"notWebSocket\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"badMethod\",\n\t\t\tmethod: \"POST\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\": \"Upgrade\",\n\t\t\t\t\"Upgrade\":    \"websocket\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"badWebSocketVersion\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\":            \"Upgrade\",\n\t\t\t\t\"Upgrade\":               \"websocket\",\n\t\t\t\t\"Sec-WebSocket-Version\": \"14\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missingWebSocketKey\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\":            \"Upgrade\",\n\t\t\t\t\"Upgrade\":               \"websocket\",\n\t\t\t\t\"Sec-WebSocket-Version\": \"13\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"emptyWebSocketKey\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\":            \"Upgrade\",\n\t\t\t\t\"Upgrade\":               \"websocket\",\n\t\t\t\t\"Sec-WebSocket-Version\": \"13\",\n\t\t\t\t\"Sec-WebSocket-Key\":     \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"shortWebSocketKey\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\":            \"Upgrade\",\n\t\t\t\t\"Upgrade\":               \"websocket\",\n\t\t\t\t\"Sec-WebSocket-Version\": \"13\",\n\t\t\t\t\"Sec-WebSocket-Key\":     xrand.Base64(15),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalidWebSocketKey\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\":            \"Upgrade\",\n\t\t\t\t\"Upgrade\":               \"websocket\",\n\t\t\t\t\"Sec-WebSocket-Version\": \"13\",\n\t\t\t\t\"Sec-WebSocket-Key\":     \"notbase64\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"extraWebSocketKey\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\":            \"Upgrade\",\n\t\t\t\t\"Upgrade\":               \"websocket\",\n\t\t\t\t\"Sec-WebSocket-Version\": \"13\",\n\t\t\t\t// Kinda cheeky, but http headers are case-insensitive.\n\t\t\t\t// If 2 sec keys are present, this is a failure condition.\n\t\t\t\t\"Sec-WebSocket-Key\": xrand.Base64(16),\n\t\t\t\t\"sec-webSocket-key\": xrand.Base64(16),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"badHTTPVersion\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\":            \"Upgrade\",\n\t\t\t\t\"Upgrade\":               \"websocket\",\n\t\t\t\t\"Sec-WebSocket-Version\": \"13\",\n\t\t\t\t\"Sec-WebSocket-Key\":     xrand.Base64(16),\n\t\t\t},\n\t\t\thttp1: true,\n\t\t},\n\t\t{\n\t\t\tname: \"success\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\":            \"keep-alive, Upgrade\",\n\t\t\t\t\"Upgrade\":               \"websocket\",\n\t\t\t\t\"Sec-WebSocket-Version\": \"13\",\n\t\t\t\t\"Sec-WebSocket-Key\":     xrand.Base64(16),\n\t\t\t},\n\t\t\tsuccess: true,\n\t\t},\n\t\t{\n\t\t\tname: \"successSecKeyExtraSpace\",\n\t\t\th: map[string]string{\n\t\t\t\t\"Connection\":            \"keep-alive, Upgrade\",\n\t\t\t\t\"Upgrade\":               \"websocket\",\n\t\t\t\t\"Sec-WebSocket-Version\": \"13\",\n\t\t\t\t\"Sec-WebSocket-Key\":     \"   \" + xrand.Base64(16) + \"  \",\n\t\t\t},\n\t\t\tsuccess: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tr := httptest.NewRequest(tc.method, \"/\", nil)\n\n\t\t\tr.ProtoMajor = 1\n\t\t\tr.ProtoMinor = 1\n\t\t\tif tc.http1 {\n\t\t\t\tr.ProtoMinor = 0\n\t\t\t}\n\n\t\t\tfor k, v := range tc.h {\n\t\t\t\tr.Header.Add(k, v)\n\t\t\t}\n\n\t\t\t_, err := verifyClientRequest(httptest.NewRecorder(), r)\n\t\t\tif tc.success {\n\t\t\t\tassert.Success(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_selectSubprotocol(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname            string\n\t\tclientProtocols []string\n\t\tserverProtocols []string\n\t\tnegotiated      string\n\t}{\n\t\t{\n\t\t\tname:            \"empty\",\n\t\t\tclientProtocols: nil,\n\t\t\tserverProtocols: nil,\n\t\t\tnegotiated:      \"\",\n\t\t},\n\t\t{\n\t\t\tname:            \"basic\",\n\t\t\tclientProtocols: []string{\"echo\", \"echo2\"},\n\t\t\tserverProtocols: []string{\"echo2\", \"echo\"},\n\t\t\tnegotiated:      \"echo2\",\n\t\t},\n\t\t{\n\t\t\tname:            \"none\",\n\t\t\tclientProtocols: []string{\"echo\", \"echo3\"},\n\t\t\tserverProtocols: []string{\"echo2\", \"echo4\"},\n\t\t\tnegotiated:      \"\",\n\t\t},\n\t\t{\n\t\t\tname:            \"fallback\",\n\t\t\tclientProtocols: []string{\"echo\", \"echo3\"},\n\t\t\tserverProtocols: []string{\"echo2\", \"echo3\"},\n\t\t\tnegotiated:      \"echo3\",\n\t\t},\n\t\t{\n\t\t\tname:            \"clientCasePresered\",\n\t\t\tclientProtocols: []string{\"Echo1\"},\n\t\t\tserverProtocols: []string{\"echo1\"},\n\t\t\tnegotiated:      \"Echo1\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\t\tr.Header.Set(\"Sec-WebSocket-Protocol\", strings.Join(tc.clientProtocols, \",\"))\n\n\t\t\tnegotiated := selectSubprotocol(r, tc.serverProtocols)\n\t\t\tassert.Equal(t, \"negotiated\", tc.negotiated, negotiated)\n\t\t})\n\t}\n}\n\nfunc Test_authenticateOrigin(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname           string\n\t\torigin         string\n\t\thost           string\n\t\toriginPatterns []string\n\t\tsuccess        bool\n\t}{\n\t\t{\n\t\t\tname:    \"none\",\n\t\t\tsuccess: true,\n\t\t\thost:    \"example.com\",\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid\",\n\t\t\torigin:  \"$#)(*)$#@*$(#@*$)#@*%)#(@*%)#(@%#@$#@$#$#@$#@}{}{}\",\n\t\t\thost:    \"example.com\",\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unauthorized\",\n\t\t\torigin:  \"https://example.com\",\n\t\t\thost:    \"example1.com\",\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"authorized\",\n\t\t\torigin:  \"https://example.com\",\n\t\t\thost:    \"example.com\",\n\t\t\tsuccess: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"authorizedCaseInsensitive\",\n\t\t\torigin:  \"https://examplE.com\",\n\t\t\thost:    \"example.com\",\n\t\t\tsuccess: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"originPatterns\",\n\t\t\torigin: \"https://two.examplE.com\",\n\t\t\thost:   \"example.com\",\n\t\t\toriginPatterns: []string{\n\t\t\t\t\"*.example.com\",\n\t\t\t\t\"bar.com\",\n\t\t\t},\n\t\t\tsuccess: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"originPatternsUnauthorized\",\n\t\t\torigin: \"https://two.examplE.com\",\n\t\t\thost:   \"example.com\",\n\t\t\toriginPatterns: []string{\n\t\t\t\t\"exam3.com\",\n\t\t\t\t\"bar.com\",\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tr := httptest.NewRequest(\"GET\", \"http://\"+tc.host+\"/\", nil)\n\t\t\tr.Header.Set(\"Origin\", tc.origin)\n\n\t\t\terr := authenticateOrigin(r, tc.originPatterns)\n\t\t\tif tc.success {\n\t\t\t\tassert.Success(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_selectDeflate(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tmode     CompressionMode\n\t\theader   string\n\t\texpCopts *compressionOptions\n\t\texpOK    bool\n\t}{\n\t\t{\n\t\t\tname:     \"disabled\",\n\t\t\tmode:     CompressionDisabled,\n\t\t\texpCopts: nil,\n\t\t\texpOK:    false,\n\t\t},\n\t\t{\n\t\t\tname:     \"noClientSupport\",\n\t\t\tmode:     CompressionNoContextTakeover,\n\t\t\texpCopts: nil,\n\t\t\texpOK:    false,\n\t\t},\n\t\t{\n\t\t\tname:   \"permessage-deflate\",\n\t\t\tmode:   CompressionNoContextTakeover,\n\t\t\theader: \"permessage-deflate; client_max_window_bits\",\n\t\t\texpCopts: &compressionOptions{\n\t\t\t\tclientNoContextTakeover: true,\n\t\t\t\tserverNoContextTakeover: true,\n\t\t\t},\n\t\t\texpOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"permessage-deflate/unknown-parameter\",\n\t\t\tmode:   CompressionNoContextTakeover,\n\t\t\theader: \"permessage-deflate; meow\",\n\t\t\texpOK:  false,\n\t\t},\n\t\t{\n\t\t\tname:   \"permessage-deflate/unknown-parameter\",\n\t\t\tmode:   CompressionNoContextTakeover,\n\t\t\theader: \"permessage-deflate; meow, permessage-deflate; client_max_window_bits\",\n\t\t\texpCopts: &compressionOptions{\n\t\t\t\tclientNoContextTakeover: true,\n\t\t\t\tserverNoContextTakeover: true,\n\t\t\t},\n\t\t\texpOK: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\th := http.Header{}\n\t\t\th.Set(\"Sec-WebSocket-Extensions\", tc.header)\n\t\t\tcopts, ok := selectDeflate(websocketExtensions(h), tc.mode)\n\t\t\tassert.Equal(t, \"selected options\", tc.expOK, ok)\n\t\t\tassert.Equal(t, \"compression options\", tc.expCopts, copts)\n\t\t})\n\t}\n}\n\ntype mockHijacker struct {\n\thttp.ResponseWriter\n\thijack func() (net.Conn, *bufio.ReadWriter, error)\n}\n\nvar _ http.Hijacker = mockHijacker{}\n\nfunc (mj mockHijacker) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\treturn mj.hijack()\n}\n\ntype mockUnwrapper struct {\n\thttp.ResponseWriter\n\tunwrap func() http.ResponseWriter\n}\n\nvar _ rwUnwrapper = mockUnwrapper{}\n\nfunc (mu mockUnwrapper) Unwrap() http.ResponseWriter {\n\treturn mu.unwrap()\n}\n"
        },
        {
          "name": "autobahn_test.go",
          "type": "blob",
          "size": 7.1796875,
          "content": "//go:build !js\n// +build !js\n\npackage websocket_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/coder/websocket\"\n\t\"github.com/coder/websocket/internal/errd\"\n\t\"github.com/coder/websocket/internal/test/assert\"\n\t\"github.com/coder/websocket/internal/test/wstest\"\n\t\"github.com/coder/websocket/internal/util\"\n)\n\nvar excludedAutobahnCases = []string{\n\t// We skip the UTF-8 handling tests as there isn't any reason to reject invalid UTF-8, just\n\t// more performance overhead.\n\t\"6.*\", \"7.5.1\",\n\n\t// We skip the tests related to requestMaxWindowBits as that is unimplemented due\n\t// to limitations in compress/flate. See https://github.com/golang/go/issues/3155\n\t\"13.3.*\", \"13.4.*\", \"13.5.*\", \"13.6.*\",\n}\n\nvar autobahnCases = []string{\"*\"}\n\n// Used to run individual test cases. autobahnCases runs only those cases matched\n// and not excluded by excludedAutobahnCases. Adding cases here means excludedAutobahnCases\n// is niled.\nvar onlyAutobahnCases = []string{}\n\nfunc TestAutobahn(t *testing.T) {\n\tt.Parallel()\n\n\tif os.Getenv(\"AUTOBAHN\") == \"\" {\n\t\tt.SkipNow()\n\t}\n\n\tif os.Getenv(\"AUTOBAHN\") == \"fast\" {\n\t\t// These are the slow tests.\n\t\texcludedAutobahnCases = append(excludedAutobahnCases,\n\t\t\t\"9.*\", \"12.*\", \"13.*\",\n\t\t)\n\t}\n\n\tif len(onlyAutobahnCases) > 0 {\n\t\texcludedAutobahnCases = []string{}\n\t\tautobahnCases = onlyAutobahnCases\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Hour)\n\tdefer cancel()\n\n\twstestURL, closeFn, err := wstestServer(t, ctx)\n\tassert.Success(t, err)\n\tdefer func() {\n\t\tassert.Success(t, closeFn())\n\t}()\n\n\terr = waitWS(ctx, wstestURL)\n\tassert.Success(t, err)\n\n\tcases, err := wstestCaseCount(ctx, wstestURL)\n\tassert.Success(t, err)\n\n\tt.Run(\"cases\", func(t *testing.T) {\n\t\tfor i := 1; i <= cases; i++ {\n\t\t\ti := i\n\t\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Minute*5)\n\t\t\t\tdefer cancel()\n\n\t\t\t\tc, _, err := websocket.Dial(ctx, fmt.Sprintf(wstestURL+\"/runCase?case=%v&agent=main\", i), &websocket.DialOptions{\n\t\t\t\t\tCompressionMode: websocket.CompressionContextTakeover,\n\t\t\t\t})\n\t\t\t\tassert.Success(t, err)\n\t\t\t\terr = wstest.EchoLoop(ctx, c)\n\t\t\t\tt.Logf(\"echoLoop: %v\", err)\n\t\t\t})\n\t\t}\n\t})\n\n\tc, _, err := websocket.Dial(ctx, fmt.Sprintf(wstestURL+\"/updateReports?agent=main\"), nil)\n\tassert.Success(t, err)\n\tc.Close(websocket.StatusNormalClosure, \"\")\n\n\tcheckWSTestIndex(t, \"./ci/out/autobahn-report/index.json\")\n}\n\nfunc waitWS(ctx context.Context, url string) error {\n\tctx, cancel := context.WithTimeout(ctx, time.Second*5)\n\tdefer cancel()\n\n\tfor ctx.Err() == nil {\n\t\tc, _, err := websocket.Dial(ctx, url, nil)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tc.Close(websocket.StatusNormalClosure, \"\")\n\t\treturn nil\n\t}\n\n\treturn ctx.Err()\n}\n\nfunc wstestServer(tb testing.TB, ctx context.Context) (url string, closeFn func() error, err error) {\n\tdefer errd.Wrap(&err, \"failed to start autobahn wstest server\")\n\n\tserverAddr, err := unusedListenAddr()\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\t_, serverPort, err := net.SplitHostPort(serverAddr)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\turl = \"ws://\" + serverAddr\n\tconst outDir = \"ci/out/autobahn-report\"\n\n\tspecFile, err := tempJSONFile(map[string]interface{}{\n\t\t\"url\":           url,\n\t\t\"outdir\":        outDir,\n\t\t\"cases\":         autobahnCases,\n\t\t\"exclude-cases\": excludedAutobahnCases,\n\t})\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to write spec: %w\", err)\n\t}\n\n\tctx, cancel := context.WithTimeout(ctx, time.Hour)\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tcancel()\n\t\t}\n\t}()\n\n\tdockerPull := exec.CommandContext(ctx, \"docker\", \"pull\", \"crossbario/autobahn-testsuite\")\n\tdockerPull.Stdout = util.WriterFunc(func(p []byte) (int, error) {\n\t\ttb.Log(string(p))\n\t\treturn len(p), nil\n\t})\n\tdockerPull.Stderr = util.WriterFunc(func(p []byte) (int, error) {\n\t\ttb.Log(string(p))\n\t\treturn len(p), nil\n\t})\n\ttb.Log(dockerPull)\n\terr = dockerPull.Run()\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to pull docker image: %w\", err)\n\t}\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tvar args []string\n\targs = append(args, \"run\", \"-i\", \"--rm\",\n\t\t\"-v\", fmt.Sprintf(\"%s:%[1]s\", specFile),\n\t\t\"-v\", fmt.Sprintf(\"%s/ci:/ci\", wd),\n\t\tfmt.Sprintf(\"-p=%s:%s\", serverAddr, serverPort),\n\t\t\"crossbario/autobahn-testsuite\",\n\t)\n\targs = append(args, \"wstest\", \"--mode\", \"fuzzingserver\", \"--spec\", specFile,\n\t\t// Disables some server that runs as part of fuzzingserver mode.\n\t\t// See https://github.com/crossbario/autobahn-testsuite/blob/058db3a36b7c3a1edf68c282307c6b899ca4857f/autobahntestsuite/autobahntestsuite/wstest.py#L124\n\t\t\"--webport=0\",\n\t)\n\twstest := exec.CommandContext(ctx, \"docker\", args...)\n\twstest.Stdout = util.WriterFunc(func(p []byte) (int, error) {\n\t\ttb.Log(string(p))\n\t\treturn len(p), nil\n\t})\n\twstest.Stderr = util.WriterFunc(func(p []byte) (int, error) {\n\t\ttb.Log(string(p))\n\t\treturn len(p), nil\n\t})\n\ttb.Log(wstest)\n\terr = wstest.Start()\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to start wstest: %w\", err)\n\t}\n\n\treturn url, func() error {\n\t\terr = wstest.Process.Kill()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to kill wstest: %w\", err)\n\t\t}\n\t\terr = wstest.Wait()\n\t\tvar ee *exec.ExitError\n\t\tif errors.As(err, &ee) && ee.ExitCode() == -1 {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}, nil\n}\n\nfunc wstestCaseCount(ctx context.Context, url string) (cases int, err error) {\n\tdefer errd.Wrap(&err, \"failed to get case count\")\n\n\tc, _, err := websocket.Dial(ctx, url+\"/getCaseCount\", nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer c.Close(websocket.StatusInternalError, \"\")\n\n\t_, r, err := c.Reader(ctx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tb, err := io.ReadAll(r)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tcases, err = strconv.Atoi(string(b))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tc.Close(websocket.StatusNormalClosure, \"\")\n\n\treturn cases, nil\n}\n\nfunc checkWSTestIndex(t *testing.T, path string) {\n\twstestOut, err := os.ReadFile(path)\n\tassert.Success(t, err)\n\n\tvar indexJSON map[string]map[string]struct {\n\t\tBehavior      string `json:\"behavior\"`\n\t\tBehaviorClose string `json:\"behaviorClose\"`\n\t}\n\terr = json.Unmarshal(wstestOut, &indexJSON)\n\tassert.Success(t, err)\n\n\tfor _, tests := range indexJSON {\n\t\tfor test, result := range tests {\n\t\t\tt.Run(test, func(t *testing.T) {\n\t\t\t\tswitch result.BehaviorClose {\n\t\t\t\tcase \"OK\", \"INFORMATIONAL\":\n\t\t\t\tdefault:\n\t\t\t\t\tt.Errorf(\"bad close behaviour\")\n\t\t\t\t}\n\n\t\t\t\tswitch result.Behavior {\n\t\t\t\tcase \"OK\", \"NON-STRICT\", \"INFORMATIONAL\":\n\t\t\t\tdefault:\n\t\t\t\t\tt.Errorf(\"failed\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tif t.Failed() {\n\t\thtmlPath := strings.Replace(path, \".json\", \".html\", 1)\n\t\tt.Errorf(\"detected autobahn violation, see %q\", htmlPath)\n\t}\n}\n\nfunc unusedListenAddr() (_ string, err error) {\n\tdefer errd.Wrap(&err, \"failed to get unused listen address\")\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tl.Close()\n\treturn l.Addr().String(), nil\n}\n\nfunc tempJSONFile(v interface{}) (string, error) {\n\tf, err := os.CreateTemp(\"\", \"temp.json\")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"temp file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\te := json.NewEncoder(f)\n\te.SetIndent(\"\", \"\\t\")\n\terr = e.Encode(v)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"json encode: %w\", err)\n\t}\n\n\terr = f.Close()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"close temp file: %w\", err)\n\t}\n\n\treturn f.Name(), nil\n}\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "close.go",
          "type": "blob",
          "size": 7.8056640625,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"context\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/coder/websocket/internal/errd\"\n)\n\n// StatusCode represents a WebSocket status code.\n// https://tools.ietf.org/html/rfc6455#section-7.4\ntype StatusCode int\n\n// https://www.iana.org/assignments/websocket/websocket.xhtml#close-code-number\n//\n// These are only the status codes defined by the protocol.\n//\n// You can define custom codes in the 3000-4999 range.\n// The 3000-3999 range is reserved for use by libraries, frameworks and applications.\n// The 4000-4999 range is reserved for private use.\nconst (\n\tStatusNormalClosure   StatusCode = 1000\n\tStatusGoingAway       StatusCode = 1001\n\tStatusProtocolError   StatusCode = 1002\n\tStatusUnsupportedData StatusCode = 1003\n\n\t// 1004 is reserved and so unexported.\n\tstatusReserved StatusCode = 1004\n\n\t// StatusNoStatusRcvd cannot be sent in a close message.\n\t// It is reserved for when a close message is received without\n\t// a status code.\n\tStatusNoStatusRcvd StatusCode = 1005\n\n\t// StatusAbnormalClosure is exported for use only with Wasm.\n\t// In non Wasm Go, the returned error will indicate whether the\n\t// connection was closed abnormally.\n\tStatusAbnormalClosure StatusCode = 1006\n\n\tStatusInvalidFramePayloadData StatusCode = 1007\n\tStatusPolicyViolation         StatusCode = 1008\n\tStatusMessageTooBig           StatusCode = 1009\n\tStatusMandatoryExtension      StatusCode = 1010\n\tStatusInternalError           StatusCode = 1011\n\tStatusServiceRestart          StatusCode = 1012\n\tStatusTryAgainLater           StatusCode = 1013\n\tStatusBadGateway              StatusCode = 1014\n\n\t// StatusTLSHandshake is only exported for use with Wasm.\n\t// In non Wasm Go, the returned error will indicate whether there was\n\t// a TLS handshake failure.\n\tStatusTLSHandshake StatusCode = 1015\n)\n\n// CloseError is returned when the connection is closed with a status and reason.\n//\n// Use Go 1.13's errors.As to check for this error.\n// Also see the CloseStatus helper.\ntype CloseError struct {\n\tCode   StatusCode\n\tReason string\n}\n\nfunc (ce CloseError) Error() string {\n\treturn fmt.Sprintf(\"status = %v and reason = %q\", ce.Code, ce.Reason)\n}\n\n// CloseStatus is a convenience wrapper around Go 1.13's errors.As to grab\n// the status code from a CloseError.\n//\n// -1 will be returned if the passed error is nil or not a CloseError.\nfunc CloseStatus(err error) StatusCode {\n\tvar ce CloseError\n\tif errors.As(err, &ce) {\n\t\treturn ce.Code\n\t}\n\treturn -1\n}\n\n// Close performs the WebSocket close handshake with the given status code and reason.\n//\n// It will write a WebSocket close frame with a timeout of 5s and then wait 5s for\n// the peer to send a close frame.\n// All data messages received from the peer during the close handshake will be discarded.\n//\n// The connection can only be closed once. Additional calls to Close\n// are no-ops.\n//\n// The maximum length of reason must be 125 bytes. Avoid sending a dynamic reason.\n//\n// Close will unblock all goroutines interacting with the connection once\n// complete.\nfunc (c *Conn) Close(code StatusCode, reason string) (err error) {\n\tdefer errd.Wrap(&err, \"failed to close WebSocket\")\n\n\tif c.casClosing() {\n\t\terr = c.waitGoroutines()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn net.ErrClosed\n\t}\n\tdefer func() {\n\t\tif errors.Is(err, net.ErrClosed) {\n\t\t\terr = nil\n\t\t}\n\t}()\n\n\terr = c.closeHandshake(code, reason)\n\n\terr2 := c.close()\n\tif err == nil && err2 != nil {\n\t\terr = err2\n\t}\n\n\terr2 = c.waitGoroutines()\n\tif err == nil && err2 != nil {\n\t\terr = err2\n\t}\n\n\treturn err\n}\n\n// CloseNow closes the WebSocket connection without attempting a close handshake.\n// Use when you do not want the overhead of the close handshake.\nfunc (c *Conn) CloseNow() (err error) {\n\tdefer errd.Wrap(&err, \"failed to immediately close WebSocket\")\n\n\tif c.casClosing() {\n\t\terr = c.waitGoroutines()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn net.ErrClosed\n\t}\n\tdefer func() {\n\t\tif errors.Is(err, net.ErrClosed) {\n\t\t\terr = nil\n\t\t}\n\t}()\n\n\terr = c.close()\n\n\terr2 := c.waitGoroutines()\n\tif err == nil && err2 != nil {\n\t\terr = err2\n\t}\n\treturn err\n}\n\nfunc (c *Conn) closeHandshake(code StatusCode, reason string) error {\n\terr := c.writeClose(code, reason)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = c.waitCloseHandshake()\n\tif CloseStatus(err) != code {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *Conn) writeClose(code StatusCode, reason string) error {\n\tce := CloseError{\n\t\tCode:   code,\n\t\tReason: reason,\n\t}\n\n\tvar p []byte\n\tvar err error\n\tif ce.Code != StatusNoStatusRcvd {\n\t\tp, err = ce.bytes()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\terr = c.writeControl(ctx, opClose, p)\n\t// If the connection closed as we're writing we ignore the error as we might\n\t// have written the close frame, the peer responded and then someone else read it\n\t// and closed the connection.\n\tif err != nil && !errors.Is(err, net.ErrClosed) {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *Conn) waitCloseHandshake() error {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\terr := c.readMu.lock(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.readMu.unlock()\n\n\tfor i := int64(0); i < c.msgReader.payloadLength; i++ {\n\t\t_, err := c.br.ReadByte()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor {\n\t\th, err := c.readLoop(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor i := int64(0); i < h.payloadLength; i++ {\n\t\t\t_, err := c.br.ReadByte()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *Conn) waitGoroutines() error {\n\tt := time.NewTimer(time.Second * 15)\n\tdefer t.Stop()\n\n\tselect {\n\tcase <-c.timeoutLoopDone:\n\tcase <-t.C:\n\t\treturn errors.New(\"failed to wait for timeoutLoop goroutine to exit\")\n\t}\n\n\tc.closeReadMu.Lock()\n\tcloseRead := c.closeReadCtx != nil\n\tc.closeReadMu.Unlock()\n\tif closeRead {\n\t\tselect {\n\t\tcase <-c.closeReadDone:\n\t\tcase <-t.C:\n\t\t\treturn errors.New(\"failed to wait for close read goroutine to exit\")\n\t\t}\n\t}\n\n\tselect {\n\tcase <-c.closed:\n\tcase <-t.C:\n\t\treturn errors.New(\"failed to wait for connection to be closed\")\n\t}\n\n\treturn nil\n}\n\nfunc parseClosePayload(p []byte) (CloseError, error) {\n\tif len(p) == 0 {\n\t\treturn CloseError{\n\t\t\tCode: StatusNoStatusRcvd,\n\t\t}, nil\n\t}\n\n\tif len(p) < 2 {\n\t\treturn CloseError{}, fmt.Errorf(\"close payload %q too small, cannot even contain the 2 byte status code\", p)\n\t}\n\n\tce := CloseError{\n\t\tCode:   StatusCode(binary.BigEndian.Uint16(p)),\n\t\tReason: string(p[2:]),\n\t}\n\n\tif !validWireCloseCode(ce.Code) {\n\t\treturn CloseError{}, fmt.Errorf(\"invalid status code %v\", ce.Code)\n\t}\n\n\treturn ce, nil\n}\n\n// See http://www.iana.org/assignments/websocket/websocket.xhtml#close-code-number\n// and https://tools.ietf.org/html/rfc6455#section-7.4.1\nfunc validWireCloseCode(code StatusCode) bool {\n\tswitch code {\n\tcase statusReserved, StatusNoStatusRcvd, StatusAbnormalClosure, StatusTLSHandshake:\n\t\treturn false\n\t}\n\n\tif code >= StatusNormalClosure && code <= StatusBadGateway {\n\t\treturn true\n\t}\n\tif code >= 3000 && code <= 4999 {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (ce CloseError) bytes() ([]byte, error) {\n\tp, err := ce.bytesErr()\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to marshal close frame: %w\", err)\n\t\tce = CloseError{\n\t\t\tCode: StatusInternalError,\n\t\t}\n\t\tp, _ = ce.bytesErr()\n\t}\n\treturn p, err\n}\n\nconst maxCloseReason = maxControlPayload - 2\n\nfunc (ce CloseError) bytesErr() ([]byte, error) {\n\tif len(ce.Reason) > maxCloseReason {\n\t\treturn nil, fmt.Errorf(\"reason string max is %v but got %q with length %v\", maxCloseReason, ce.Reason, len(ce.Reason))\n\t}\n\n\tif !validWireCloseCode(ce.Code) {\n\t\treturn nil, fmt.Errorf(\"status code %v cannot be set\", ce.Code)\n\t}\n\n\tbuf := make([]byte, 2+len(ce.Reason))\n\tbinary.BigEndian.PutUint16(buf, uint16(ce.Code))\n\tcopy(buf[2:], ce.Reason)\n\treturn buf, nil\n}\n\nfunc (c *Conn) casClosing() bool {\n\treturn c.closing.Swap(true)\n}\n\nfunc (c *Conn) isClosed() bool {\n\tselect {\n\tcase <-c.closed:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n"
        },
        {
          "name": "close_test.go",
          "type": "blob",
          "size": 3.2587890625,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"io\"\n\t\"math\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/coder/websocket/internal/test/assert\"\n)\n\nfunc TestCloseError(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname    string\n\t\tce      CloseError\n\t\tsuccess bool\n\t}{\n\t\t{\n\t\t\tname: \"normal\",\n\t\t\tce: CloseError{\n\t\t\t\tCode:   StatusNormalClosure,\n\t\t\t\tReason: strings.Repeat(\"x\", maxCloseReason),\n\t\t\t},\n\t\t\tsuccess: true,\n\t\t},\n\t\t{\n\t\t\tname: \"bigReason\",\n\t\t\tce: CloseError{\n\t\t\t\tCode:   StatusNormalClosure,\n\t\t\t\tReason: strings.Repeat(\"x\", maxCloseReason+1),\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname: \"bigCode\",\n\t\t\tce: CloseError{\n\t\t\t\tCode:   math.MaxUint16,\n\t\t\t\tReason: strings.Repeat(\"x\", maxCloseReason),\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := tc.ce.bytesErr()\n\t\t\tif tc.success {\n\t\t\t\tassert.Success(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Error\", func(t *testing.T) {\n\t\texp := `status = StatusInternalError and reason = \"meow\"`\n\t\tact := CloseError{\n\t\t\tCode:   StatusInternalError,\n\t\t\tReason: \"meow\",\n\t\t}.Error()\n\t\tassert.Equal(t, \"CloseError.Error()\", exp, act)\n\t})\n}\n\nfunc Test_parseClosePayload(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname    string\n\t\tp       []byte\n\t\tsuccess bool\n\t\tce      CloseError\n\t}{\n\t\t{\n\t\t\tname:    \"normal\",\n\t\t\tp:       append([]byte{0x3, 0xE8}, []byte(\"hello\")...),\n\t\t\tsuccess: true,\n\t\t\tce: CloseError{\n\t\t\t\tCode:   StatusNormalClosure,\n\t\t\t\tReason: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"nothing\",\n\t\t\tsuccess: true,\n\t\t\tce: CloseError{\n\t\t\t\tCode: StatusNoStatusRcvd,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"oneByte\",\n\t\t\tp:       []byte{0},\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"badStatusCode\",\n\t\t\tp:       []byte{0x17, 0x70},\n\t\t\tsuccess: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tce, err := parseClosePayload(tc.p)\n\t\t\tif tc.success {\n\t\t\t\tassert.Success(t, err)\n\t\t\t\tassert.Equal(t, \"close payload\", tc.ce, ce)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_validWireCloseCode(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname  string\n\t\tcode  StatusCode\n\t\tvalid bool\n\t}{\n\t\t{\n\t\t\tname:  \"normal\",\n\t\t\tcode:  StatusNormalClosure,\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"noStatus\",\n\t\t\tcode:  StatusNoStatusRcvd,\n\t\t\tvalid: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"3000\",\n\t\t\tcode:  3000,\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"4999\",\n\t\t\tcode:  4999,\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"unknown\",\n\t\t\tcode:  5000,\n\t\t\tvalid: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tact := validWireCloseCode(tc.code)\n\t\t\tassert.Equal(t, \"wire close code\", tc.valid, act)\n\t\t})\n\t}\n}\n\nfunc TestCloseStatus(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname string\n\t\tin   error\n\t\texp  StatusCode\n\t}{\n\t\t{\n\t\t\tname: \"nil\",\n\t\t\tin:   nil,\n\t\t\texp:  -1,\n\t\t},\n\t\t{\n\t\t\tname: \"io.EOF\",\n\t\t\tin:   io.EOF,\n\t\t\texp:  -1,\n\t\t},\n\t\t{\n\t\t\tname: \"StatusInternalError\",\n\t\t\tin: CloseError{\n\t\t\t\tCode: StatusInternalError,\n\t\t\t},\n\t\t\texp: StatusInternalError,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tact := CloseStatus(tc.in)\n\t\t\tassert.Equal(t, \"close status\", tc.exp, act)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "compress.go",
          "type": "blob",
          "size": 5.7099609375,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"compress/flate\"\n\t\"io\"\n\t\"sync\"\n)\n\n// CompressionMode represents the modes available to the permessage-deflate extension.\n// See https://tools.ietf.org/html/rfc7692\n//\n// Works in all modern browsers except Safari which does not implement the permessage-deflate extension.\n//\n// Compression is only used if the peer supports the mode selected.\ntype CompressionMode int\n\nconst (\n\t// CompressionDisabled disables the negotiation of the permessage-deflate extension.\n\t//\n\t// This is the default. Do not enable compression without benchmarking for your particular use case first.\n\tCompressionDisabled CompressionMode = iota\n\n\t// CompressionContextTakeover compresses each message greater than 128 bytes reusing the 32 KB sliding window from\n\t// previous messages. i.e compression context across messages is preserved.\n\t//\n\t// As most WebSocket protocols are text based and repetitive, this compression mode can be very efficient.\n\t//\n\t// The memory overhead is a fixed 32 KB sliding window, a fixed 1.2 MB flate.Writer and a sync.Pool of 40 KB flate.Reader's\n\t// that are used when reading and then returned.\n\t//\n\t// Thus, it uses more memory than CompressionNoContextTakeover but compresses more efficiently.\n\t//\n\t// If the peer does not support CompressionContextTakeover then we will fall back to CompressionNoContextTakeover.\n\tCompressionContextTakeover\n\n\t// CompressionNoContextTakeover compresses each message greater than 512 bytes. Each message is compressed with\n\t// a new 1.2 MB flate.Writer pulled from a sync.Pool. Each message is read with a 40 KB flate.Reader pulled from\n\t// a sync.Pool.\n\t//\n\t// This means less efficient compression as the sliding window from previous messages will not be used but the\n\t// memory overhead will be lower as there will be no fixed cost for the flate.Writer nor the 32 KB sliding window.\n\t// Especially if the connections are long lived and seldom written to.\n\t//\n\t// Thus, it uses less memory than CompressionContextTakeover but compresses less efficiently.\n\t//\n\t// If the peer does not support CompressionNoContextTakeover then we will fall back to CompressionDisabled.\n\tCompressionNoContextTakeover\n)\n\nfunc (m CompressionMode) opts() *compressionOptions {\n\treturn &compressionOptions{\n\t\tclientNoContextTakeover: m == CompressionNoContextTakeover,\n\t\tserverNoContextTakeover: m == CompressionNoContextTakeover,\n\t}\n}\n\ntype compressionOptions struct {\n\tclientNoContextTakeover bool\n\tserverNoContextTakeover bool\n}\n\nfunc (copts *compressionOptions) String() string {\n\ts := \"permessage-deflate\"\n\tif copts.clientNoContextTakeover {\n\t\ts += \"; client_no_context_takeover\"\n\t}\n\tif copts.serverNoContextTakeover {\n\t\ts += \"; server_no_context_takeover\"\n\t}\n\treturn s\n}\n\n// These bytes are required to get flate.Reader to return.\n// They are removed when sending to avoid the overhead as\n// WebSocket framing tell's when the message has ended but then\n// we need to add them back otherwise flate.Reader keeps\n// trying to read more bytes.\nconst deflateMessageTail = \"\\x00\\x00\\xff\\xff\"\n\ntype trimLastFourBytesWriter struct {\n\tw    io.Writer\n\ttail []byte\n}\n\nfunc (tw *trimLastFourBytesWriter) reset() {\n\tif tw != nil && tw.tail != nil {\n\t\ttw.tail = tw.tail[:0]\n\t}\n}\n\nfunc (tw *trimLastFourBytesWriter) Write(p []byte) (int, error) {\n\tif tw.tail == nil {\n\t\ttw.tail = make([]byte, 0, 4)\n\t}\n\n\textra := len(tw.tail) + len(p) - 4\n\n\tif extra <= 0 {\n\t\ttw.tail = append(tw.tail, p...)\n\t\treturn len(p), nil\n\t}\n\n\t// Now we need to write as many extra bytes as we can from the previous tail.\n\tif extra > len(tw.tail) {\n\t\textra = len(tw.tail)\n\t}\n\tif extra > 0 {\n\t\t_, err := tw.w.Write(tw.tail[:extra])\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// Shift remaining bytes in tail over.\n\t\tn := copy(tw.tail, tw.tail[extra:])\n\t\ttw.tail = tw.tail[:n]\n\t}\n\n\t// If p is less than or equal to 4 bytes,\n\t// all of it is is part of the tail.\n\tif len(p) <= 4 {\n\t\ttw.tail = append(tw.tail, p...)\n\t\treturn len(p), nil\n\t}\n\n\t// Otherwise, only the last 4 bytes are.\n\ttw.tail = append(tw.tail, p[len(p)-4:]...)\n\n\tp = p[:len(p)-4]\n\tn, err := tw.w.Write(p)\n\treturn n + 4, err\n}\n\nvar flateReaderPool sync.Pool\n\nfunc getFlateReader(r io.Reader, dict []byte) io.Reader {\n\tfr, ok := flateReaderPool.Get().(io.Reader)\n\tif !ok {\n\t\treturn flate.NewReaderDict(r, dict)\n\t}\n\tfr.(flate.Resetter).Reset(r, dict)\n\treturn fr\n}\n\nfunc putFlateReader(fr io.Reader) {\n\tflateReaderPool.Put(fr)\n}\n\nvar flateWriterPool sync.Pool\n\nfunc getFlateWriter(w io.Writer) *flate.Writer {\n\tfw, ok := flateWriterPool.Get().(*flate.Writer)\n\tif !ok {\n\t\tfw, _ = flate.NewWriter(w, flate.BestSpeed)\n\t\treturn fw\n\t}\n\tfw.Reset(w)\n\treturn fw\n}\n\nfunc putFlateWriter(w *flate.Writer) {\n\tflateWriterPool.Put(w)\n}\n\ntype slidingWindow struct {\n\tbuf []byte\n}\n\nvar swPoolMu sync.RWMutex\nvar swPool = map[int]*sync.Pool{}\n\nfunc slidingWindowPool(n int) *sync.Pool {\n\tswPoolMu.RLock()\n\tp, ok := swPool[n]\n\tswPoolMu.RUnlock()\n\tif ok {\n\t\treturn p\n\t}\n\n\tp = &sync.Pool{}\n\n\tswPoolMu.Lock()\n\tswPool[n] = p\n\tswPoolMu.Unlock()\n\n\treturn p\n}\n\nfunc (sw *slidingWindow) init(n int) {\n\tif sw.buf != nil {\n\t\treturn\n\t}\n\n\tif n == 0 {\n\t\tn = 32768\n\t}\n\n\tp := slidingWindowPool(n)\n\tsw2, ok := p.Get().(*slidingWindow)\n\tif ok {\n\t\t*sw = *sw2\n\t} else {\n\t\tsw.buf = make([]byte, 0, n)\n\t}\n}\n\nfunc (sw *slidingWindow) close() {\n\tsw.buf = sw.buf[:0]\n\tswPoolMu.Lock()\n\tswPool[cap(sw.buf)].Put(sw)\n\tswPoolMu.Unlock()\n}\n\nfunc (sw *slidingWindow) write(p []byte) {\n\tif len(p) >= cap(sw.buf) {\n\t\tsw.buf = sw.buf[:cap(sw.buf)]\n\t\tp = p[len(p)-cap(sw.buf):]\n\t\tcopy(sw.buf, p)\n\t\treturn\n\t}\n\n\tleft := cap(sw.buf) - len(sw.buf)\n\tif left < len(p) {\n\t\t// We need to shift spaceNeeded bytes from the end to make room for p at the end.\n\t\tspaceNeeded := len(p) - left\n\t\tcopy(sw.buf, sw.buf[spaceNeeded:])\n\t\tsw.buf = sw.buf[:len(sw.buf)-spaceNeeded]\n\t}\n\n\tsw.buf = append(sw.buf, p...)\n}\n"
        },
        {
          "name": "compress_test.go",
          "type": "blob",
          "size": 1.2587890625,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"bytes\"\n\t\"compress/flate\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/coder/websocket/internal/test/assert\"\n\t\"github.com/coder/websocket/internal/test/xrand\"\n)\n\nfunc Test_slidingWindow(t *testing.T) {\n\tt.Parallel()\n\n\tconst testCount = 99\n\tconst maxWindow = 99999\n\tfor i := 0; i < testCount; i++ {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tinput := xrand.String(maxWindow)\n\t\t\twindowLength := xrand.Int(maxWindow)\n\t\t\tvar sw slidingWindow\n\t\t\tsw.init(windowLength)\n\t\t\tsw.write([]byte(input))\n\n\t\t\tassert.Equal(t, \"window length\", windowLength, cap(sw.buf))\n\t\t\tif !strings.HasSuffix(input, string(sw.buf)) {\n\t\t\t\tt.Fatalf(\"r.buf is not a suffix of input: %q and %q\", input, sw.buf)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkFlateWriter(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tw, _ := flate.NewWriter(io.Discard, flate.BestSpeed)\n\t\t// We have to write a byte to get the writer to allocate to its full extent.\n\t\tw.Write([]byte{'a'})\n\t\tw.Flush()\n\t}\n}\n\nfunc BenchmarkFlateReader(b *testing.B) {\n\tb.ReportAllocs()\n\n\tvar buf bytes.Buffer\n\tw, _ := flate.NewWriter(&buf, flate.BestSpeed)\n\tw.Write([]byte{'a'})\n\tw.Flush()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tr := flate.NewReader(bytes.NewReader(buf.Bytes()))\n\t\tio.ReadAll(r)\n\t}\n}\n"
        },
        {
          "name": "conn.go",
          "type": "blob",
          "size": 5.9921875,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\n// MessageType represents the type of a WebSocket message.\n// See https://tools.ietf.org/html/rfc6455#section-5.6\ntype MessageType int\n\n// MessageType constants.\nconst (\n\t// MessageText is for UTF-8 encoded text messages like JSON.\n\tMessageText MessageType = iota + 1\n\t// MessageBinary is for binary messages like protobufs.\n\tMessageBinary\n)\n\n// Conn represents a WebSocket connection.\n// All methods may be called concurrently except for Reader and Read.\n//\n// You must always read from the connection. Otherwise control\n// frames will not be handled. See Reader and CloseRead.\n//\n// Be sure to call Close on the connection when you\n// are finished with it to release associated resources.\n//\n// On any error from any method, the connection is closed\n// with an appropriate reason.\n//\n// This applies to context expirations as well unfortunately.\n// See https://github.com/nhooyr/websocket/issues/242#issuecomment-633182220\ntype Conn struct {\n\tnoCopy noCopy\n\n\tsubprotocol    string\n\trwc            io.ReadWriteCloser\n\tclient         bool\n\tcopts          *compressionOptions\n\tflateThreshold int\n\tbr             *bufio.Reader\n\tbw             *bufio.Writer\n\n\treadTimeout     chan context.Context\n\twriteTimeout    chan context.Context\n\ttimeoutLoopDone chan struct{}\n\n\t// Read state.\n\treadMu         *mu\n\treadHeaderBuf  [8]byte\n\treadControlBuf [maxControlPayload]byte\n\tmsgReader      *msgReader\n\n\t// Write state.\n\tmsgWriter      *msgWriter\n\twriteFrameMu   *mu\n\twriteBuf       []byte\n\twriteHeaderBuf [8]byte\n\twriteHeader    header\n\n\t// Close handshake state.\n\tcloseStateMu     sync.RWMutex\n\tcloseReceivedErr error\n\tcloseSentErr     error\n\n\t// CloseRead state.\n\tcloseReadMu   sync.Mutex\n\tcloseReadCtx  context.Context\n\tcloseReadDone chan struct{}\n\n\tclosing atomic.Bool\n\tcloseMu sync.Mutex // Protects following.\n\tclosed  chan struct{}\n\n\tpingCounter   atomic.Int64\n\tactivePingsMu sync.Mutex\n\tactivePings   map[string]chan<- struct{}\n}\n\ntype connConfig struct {\n\tsubprotocol    string\n\trwc            io.ReadWriteCloser\n\tclient         bool\n\tcopts          *compressionOptions\n\tflateThreshold int\n\n\tbr *bufio.Reader\n\tbw *bufio.Writer\n}\n\nfunc newConn(cfg connConfig) *Conn {\n\tc := &Conn{\n\t\tsubprotocol:    cfg.subprotocol,\n\t\trwc:            cfg.rwc,\n\t\tclient:         cfg.client,\n\t\tcopts:          cfg.copts,\n\t\tflateThreshold: cfg.flateThreshold,\n\n\t\tbr: cfg.br,\n\t\tbw: cfg.bw,\n\n\t\treadTimeout:     make(chan context.Context),\n\t\twriteTimeout:    make(chan context.Context),\n\t\ttimeoutLoopDone: make(chan struct{}),\n\n\t\tclosed:      make(chan struct{}),\n\t\tactivePings: make(map[string]chan<- struct{}),\n\t}\n\n\tc.readMu = newMu(c)\n\tc.writeFrameMu = newMu(c)\n\n\tc.msgReader = newMsgReader(c)\n\n\tc.msgWriter = newMsgWriter(c)\n\tif c.client {\n\t\tc.writeBuf = extractBufioWriterBuf(c.bw, c.rwc)\n\t}\n\n\tif c.flate() && c.flateThreshold == 0 {\n\t\tc.flateThreshold = 128\n\t\tif !c.msgWriter.flateContextTakeover() {\n\t\t\tc.flateThreshold = 512\n\t\t}\n\t}\n\n\truntime.SetFinalizer(c, func(c *Conn) {\n\t\tc.close()\n\t})\n\n\tgo c.timeoutLoop()\n\n\treturn c\n}\n\n// Subprotocol returns the negotiated subprotocol.\n// An empty string means the default protocol.\nfunc (c *Conn) Subprotocol() string {\n\treturn c.subprotocol\n}\n\nfunc (c *Conn) close() error {\n\tc.closeMu.Lock()\n\tdefer c.closeMu.Unlock()\n\n\tif c.isClosed() {\n\t\treturn net.ErrClosed\n\t}\n\truntime.SetFinalizer(c, nil)\n\tclose(c.closed)\n\n\t// Have to close after c.closed is closed to ensure any goroutine that wakes up\n\t// from the connection being closed also sees that c.closed is closed and returns\n\t// closeErr.\n\terr := c.rwc.Close()\n\t// With the close of rwc, these become safe to close.\n\tc.msgWriter.close()\n\tc.msgReader.close()\n\treturn err\n}\n\nfunc (c *Conn) timeoutLoop() {\n\tdefer close(c.timeoutLoopDone)\n\n\treadCtx := context.Background()\n\twriteCtx := context.Background()\n\n\tfor {\n\t\tselect {\n\t\tcase <-c.closed:\n\t\t\treturn\n\n\t\tcase writeCtx = <-c.writeTimeout:\n\t\tcase readCtx = <-c.readTimeout:\n\n\t\tcase <-readCtx.Done():\n\t\t\tc.close()\n\t\t\treturn\n\t\tcase <-writeCtx.Done():\n\t\t\tc.close()\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (c *Conn) flate() bool {\n\treturn c.copts != nil\n}\n\n// Ping sends a ping to the peer and waits for a pong.\n// Use this to measure latency or ensure the peer is responsive.\n// Ping must be called concurrently with Reader as it does\n// not read from the connection but instead waits for a Reader call\n// to read the pong.\n//\n// TCP Keepalives should suffice for most use cases.\nfunc (c *Conn) Ping(ctx context.Context) error {\n\tp := c.pingCounter.Add(1)\n\n\terr := c.ping(ctx, strconv.FormatInt(p, 10))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to ping: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *Conn) ping(ctx context.Context, p string) error {\n\tpong := make(chan struct{}, 1)\n\n\tc.activePingsMu.Lock()\n\tc.activePings[p] = pong\n\tc.activePingsMu.Unlock()\n\n\tdefer func() {\n\t\tc.activePingsMu.Lock()\n\t\tdelete(c.activePings, p)\n\t\tc.activePingsMu.Unlock()\n\t}()\n\n\terr := c.writeControl(ctx, opPing, []byte(p))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase <-c.closed:\n\t\treturn net.ErrClosed\n\tcase <-ctx.Done():\n\t\treturn fmt.Errorf(\"failed to wait for pong: %w\", ctx.Err())\n\tcase <-pong:\n\t\treturn nil\n\t}\n}\n\ntype mu struct {\n\tc  *Conn\n\tch chan struct{}\n}\n\nfunc newMu(c *Conn) *mu {\n\treturn &mu{\n\t\tc:  c,\n\t\tch: make(chan struct{}, 1),\n\t}\n}\n\nfunc (m *mu) forceLock() {\n\tm.ch <- struct{}{}\n}\n\nfunc (m *mu) tryLock() bool {\n\tselect {\n\tcase m.ch <- struct{}{}:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (m *mu) lock(ctx context.Context) error {\n\tselect {\n\tcase <-m.c.closed:\n\t\treturn net.ErrClosed\n\tcase <-ctx.Done():\n\t\treturn fmt.Errorf(\"failed to acquire lock: %w\", ctx.Err())\n\tcase m.ch <- struct{}{}:\n\t\t// To make sure the connection is certainly alive.\n\t\t// As it's possible the send on m.ch was selected\n\t\t// over the receive on closed.\n\t\tselect {\n\t\tcase <-m.c.closed:\n\t\t\t// Make sure to release.\n\t\t\tm.unlock()\n\t\t\treturn net.ErrClosed\n\t\tdefault:\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc (m *mu) unlock() {\n\tselect {\n\tcase <-m.ch:\n\tdefault:\n\t}\n}\n\ntype noCopy struct{}\n\nfunc (*noCopy) Lock() {}\n"
        },
        {
          "name": "conn_test.go",
          "type": "blob",
          "size": 17.263671875,
          "content": "//go:build !js\n\npackage websocket_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/coder/websocket\"\n\t\"github.com/coder/websocket/internal/errd\"\n\t\"github.com/coder/websocket/internal/test/assert\"\n\t\"github.com/coder/websocket/internal/test/wstest\"\n\t\"github.com/coder/websocket/internal/test/xrand\"\n\t\"github.com/coder/websocket/internal/xsync\"\n\t\"github.com/coder/websocket/wsjson\"\n)\n\nfunc TestConn(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"fuzzData\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tcompressionMode := func() websocket.CompressionMode {\n\t\t\treturn websocket.CompressionMode(xrand.Int(int(websocket.CompressionContextTakeover) + 1))\n\t\t}\n\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\t\ttt, c1, c2 := newConnTest(t, &websocket.DialOptions{\n\t\t\t\t\tCompressionMode:      compressionMode(),\n\t\t\t\t\tCompressionThreshold: xrand.Int(9999),\n\t\t\t\t}, &websocket.AcceptOptions{\n\t\t\t\t\tCompressionMode:      compressionMode(),\n\t\t\t\t\tCompressionThreshold: xrand.Int(9999),\n\t\t\t\t})\n\n\t\t\t\ttt.goEchoLoop(c2)\n\n\t\t\t\tc1.SetReadLimit(131072)\n\n\t\t\t\tfor i := 0; i < 5; i++ {\n\t\t\t\t\terr := wstest.Echo(tt.ctx, c1, 131072)\n\t\t\t\t\tassert.Success(t, err)\n\t\t\t\t}\n\n\t\t\t\terr := c1.Close(websocket.StatusNormalClosure, \"\")\n\t\t\t\tassert.Success(t, err)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"badClose\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\tc2.CloseRead(tt.ctx)\n\n\t\terr := c1.Close(-1, \"\")\n\t\tassert.Contains(t, err, \"failed to marshal close frame: status code StatusCode(-1) cannot be set\")\n\t})\n\n\tt.Run(\"ping\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\tc1.CloseRead(tt.ctx)\n\t\tc2.CloseRead(tt.ctx)\n\n\t\tfor i := 0; i < 10; i++ {\n\t\t\terr := c1.Ping(tt.ctx)\n\t\t\tassert.Success(t, err)\n\t\t}\n\n\t\terr := c1.Close(websocket.StatusNormalClosure, \"\")\n\t\tassert.Success(t, err)\n\t})\n\n\tt.Run(\"badPing\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\tc2.CloseRead(tt.ctx)\n\n\t\tctx, cancel := context.WithTimeout(tt.ctx, time.Millisecond*100)\n\t\tdefer cancel()\n\n\t\terr := c1.Ping(ctx)\n\t\tassert.Contains(t, err, \"failed to wait for pong\")\n\t})\n\n\tt.Run(\"concurrentWrite\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\ttt.goDiscardLoop(c2)\n\n\t\tmsg := xrand.Bytes(xrand.Int(9999))\n\t\tconst count = 100\n\t\terrs := make(chan error, count)\n\n\t\tfor i := 0; i < count; i++ {\n\t\t\tgo func() {\n\t\t\t\tselect {\n\t\t\t\tcase errs <- c1.Write(tt.ctx, websocket.MessageBinary, msg):\n\t\t\t\tcase <-tt.ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tfor i := 0; i < count; i++ {\n\t\t\tselect {\n\t\t\tcase err := <-errs:\n\t\t\t\tassert.Success(t, err)\n\t\t\tcase <-tt.ctx.Done():\n\t\t\t\tt.Fatal(tt.ctx.Err())\n\t\t\t}\n\t\t}\n\n\t\terr := c1.Close(websocket.StatusNormalClosure, \"\")\n\t\tassert.Success(t, err)\n\t})\n\n\tt.Run(\"concurrentWriteError\", func(t *testing.T) {\n\t\ttt, c1, _ := newConnTest(t, nil, nil)\n\n\t\t_, err := c1.Writer(tt.ctx, websocket.MessageText)\n\t\tassert.Success(t, err)\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)\n\t\tdefer cancel()\n\n\t\terr = c1.Write(ctx, websocket.MessageText, []byte(\"x\"))\n\t\tif !errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Fatalf(\"unexpected error: %#v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"netConn\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\tn1 := websocket.NetConn(tt.ctx, c1, websocket.MessageBinary)\n\t\tn2 := websocket.NetConn(tt.ctx, c2, websocket.MessageBinary)\n\n\t\t// Does not give any confidence but at least ensures no crashes.\n\t\td, _ := tt.ctx.Deadline()\n\t\tn1.SetDeadline(d)\n\t\tn1.SetDeadline(time.Time{})\n\n\t\tassert.Equal(t, \"remote addr\", n1.RemoteAddr(), n1.LocalAddr())\n\t\tassert.Equal(t, \"remote addr string\", \"pipe\", n1.RemoteAddr().String())\n\t\tassert.Equal(t, \"remote addr network\", \"pipe\", n1.RemoteAddr().Network())\n\n\t\terrs := xsync.Go(func() error {\n\t\t\t_, err := n2.Write([]byte(\"hello\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn n2.Close()\n\t\t})\n\n\t\tb, err := io.ReadAll(n1)\n\t\tassert.Success(t, err)\n\n\t\t_, err = n1.Read(nil)\n\t\tassert.Equal(t, \"read error\", err, io.EOF)\n\n\t\tselect {\n\t\tcase err := <-errs:\n\t\t\tassert.Success(t, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\tassert.Equal(t, \"read msg\", []byte(\"hello\"), b)\n\t})\n\n\tt.Run(\"netConn/BadMsg\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\tn1 := websocket.NetConn(tt.ctx, c1, websocket.MessageBinary)\n\t\tn2 := websocket.NetConn(tt.ctx, c2, websocket.MessageText)\n\n\t\tc2.CloseRead(tt.ctx)\n\t\terrs := xsync.Go(func() error {\n\t\t\t_, err := n2.Write([]byte(\"hello\"))\n\t\t\treturn err\n\t\t})\n\n\t\t_, err := io.ReadAll(n1)\n\t\tassert.Contains(t, err, `unexpected frame type read (expected MessageBinary): MessageText`)\n\n\t\tselect {\n\t\tcase err := <-errs:\n\t\t\tassert.Success(t, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\t})\n\n\tt.Run(\"netConn/readLimit\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\tn1 := websocket.NetConn(tt.ctx, c1, websocket.MessageBinary)\n\t\tn2 := websocket.NetConn(tt.ctx, c2, websocket.MessageBinary)\n\n\t\ts := strings.Repeat(\"papa\", 1<<20)\n\t\terrs := xsync.Go(func() error {\n\t\t\t_, err := n2.Write([]byte(s))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn n2.Close()\n\t\t})\n\n\t\tb, err := io.ReadAll(n1)\n\t\tassert.Success(t, err)\n\n\t\t_, err = n1.Read(nil)\n\t\tassert.Equal(t, \"read error\", err, io.EOF)\n\n\t\tselect {\n\t\tcase err := <-errs:\n\t\t\tassert.Success(t, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\tassert.Equal(t, \"read msg\", s, string(b))\n\t})\n\n\tt.Run(\"netConn/pastDeadline\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\tn1 := websocket.NetConn(tt.ctx, c1, websocket.MessageBinary)\n\t\tn2 := websocket.NetConn(tt.ctx, c2, websocket.MessageBinary)\n\n\t\tn1.SetDeadline(time.Now().Add(-time.Minute))\n\t\tn2.SetDeadline(time.Now().Add(-time.Minute))\n\n\t\t// No panic we're good.\n\t})\n\n\tt.Run(\"wsjson\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\ttt.goEchoLoop(c2)\n\n\t\tc1.SetReadLimit(1 << 30)\n\n\t\texp := xrand.String(xrand.Int(131072))\n\n\t\twerr := xsync.Go(func() error {\n\t\t\treturn wsjson.Write(tt.ctx, c1, exp)\n\t\t})\n\n\t\tvar act interface{}\n\t\terr := wsjson.Read(tt.ctx, c1, &act)\n\t\tassert.Success(t, err)\n\t\tassert.Equal(t, \"read msg\", exp, act)\n\n\t\tselect {\n\t\tcase err := <-werr:\n\t\t\tassert.Success(t, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\terr = c1.Close(websocket.StatusNormalClosure, \"\")\n\t\tassert.Success(t, err)\n\t})\n\n\tt.Run(\"HTTPClient.Timeout\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, &websocket.DialOptions{\n\t\t\tHTTPClient: &http.Client{Timeout: time.Second * 5},\n\t\t}, nil)\n\n\t\ttt.goEchoLoop(c2)\n\n\t\tc1.SetReadLimit(1 << 30)\n\n\t\texp := xrand.String(xrand.Int(131072))\n\n\t\twerr := xsync.Go(func() error {\n\t\t\treturn wsjson.Write(tt.ctx, c1, exp)\n\t\t})\n\n\t\tvar act interface{}\n\t\terr := wsjson.Read(tt.ctx, c1, &act)\n\t\tassert.Success(t, err)\n\t\tassert.Equal(t, \"read msg\", exp, act)\n\n\t\tselect {\n\t\tcase err := <-werr:\n\t\t\tassert.Success(t, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\terr = c1.Close(websocket.StatusNormalClosure, \"\")\n\t\tassert.Success(t, err)\n\t})\n\n\tt.Run(\"CloseNow\", func(t *testing.T) {\n\t\t_, c1, c2 := newConnTest(t, nil, nil)\n\n\t\terr1 := c1.CloseNow()\n\t\terr2 := c2.CloseNow()\n\t\tassert.Success(t, err1)\n\t\tassert.Success(t, err2)\n\t\terr1 = c1.CloseNow()\n\t\terr2 = c2.CloseNow()\n\t\tassert.ErrorIs(t, websocket.ErrClosed, err1)\n\t\tassert.ErrorIs(t, websocket.ErrClosed, err2)\n\t})\n\n\tt.Run(\"MidReadClose\", func(t *testing.T) {\n\t\ttt, c1, c2 := newConnTest(t, nil, nil)\n\n\t\ttt.goEchoLoop(c2)\n\n\t\tc1.SetReadLimit(131072)\n\n\t\tfor i := 0; i < 5; i++ {\n\t\t\terr := wstest.Echo(tt.ctx, c1, 131072)\n\t\t\tassert.Success(t, err)\n\t\t}\n\n\t\terr := wsjson.Write(tt.ctx, c1, \"four\")\n\t\tassert.Success(t, err)\n\t\t_, _, err = c1.Reader(tt.ctx)\n\t\tassert.Success(t, err)\n\n\t\terr = c1.Close(websocket.StatusNormalClosure, \"\")\n\t\tassert.Success(t, err)\n\t})\n}\n\nfunc TestWasm(t *testing.T) {\n\tt.Parallel()\n\tif os.Getenv(\"CI\") == \"\" {\n\t\tt.SkipNow()\n\t}\n\n\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\terr := echoServer(w, r, &websocket.AcceptOptions{\n\t\t\tSubprotocols:       []string{\"echo\"},\n\t\t\tInsecureSkipVerify: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}))\n\tdefer s.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\tcmd := exec.CommandContext(ctx, \"go\", \"test\", \"-exec=wasmbrowsertest\", \".\", \"-v\")\n\tcmd.Env = append(cleanEnv(os.Environ()), \"GOOS=js\", \"GOARCH=wasm\", fmt.Sprintf(\"WS_ECHO_SERVER_URL=%v\", s.URL))\n\n\tb, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\tt.Fatalf(\"wasm test binary failed: %v:\\n%s\", err, b)\n\t}\n}\n\nfunc cleanEnv(env []string) (out []string) {\n\tfor _, e := range env {\n\t\t// Filter out GITHUB envs and anything with token in it,\n\t\t// especially GITHUB_TOKEN in CI as it breaks TestWasm.\n\t\tif strings.HasPrefix(e, \"GITHUB\") || strings.Contains(e, \"TOKEN\") {\n\t\t\tcontinue\n\t\t}\n\t\tout = append(out, e)\n\t}\n\treturn out\n}\n\nfunc assertCloseStatus(exp websocket.StatusCode, err error) error {\n\tif websocket.CloseStatus(err) == -1 {\n\t\treturn fmt.Errorf(\"expected websocket.CloseError: %T %v\", err, err)\n\t}\n\tif websocket.CloseStatus(err) != exp {\n\t\treturn fmt.Errorf(\"expected close status %v but got %v\", exp, err)\n\t}\n\treturn nil\n}\n\ntype connTest struct {\n\tt   testing.TB\n\tctx context.Context\n}\n\nfunc newConnTest(t testing.TB, dialOpts *websocket.DialOptions, acceptOpts *websocket.AcceptOptions) (tt *connTest, c1, c2 *websocket.Conn) {\n\tif t, ok := t.(*testing.T); ok {\n\t\tt.Parallel()\n\t}\n\tt.Helper()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*30)\n\ttt = &connTest{t: t, ctx: ctx}\n\tt.Cleanup(cancel)\n\n\tc1, c2 = wstest.Pipe(dialOpts, acceptOpts)\n\tif xrand.Bool() {\n\t\tc1, c2 = c2, c1\n\t}\n\tt.Cleanup(func() {\n\t\tc2.CloseNow()\n\t\tc1.CloseNow()\n\t})\n\n\treturn tt, c1, c2\n}\n\nfunc (tt *connTest) goEchoLoop(c *websocket.Conn) {\n\tctx, cancel := context.WithCancel(tt.ctx)\n\n\techoLoopErr := xsync.Go(func() error {\n\t\terr := wstest.EchoLoop(ctx, c)\n\t\treturn assertCloseStatus(websocket.StatusNormalClosure, err)\n\t})\n\ttt.t.Cleanup(func() {\n\t\tcancel()\n\t\terr := <-echoLoopErr\n\t\tif err != nil {\n\t\t\ttt.t.Errorf(\"echo loop error: %v\", err)\n\t\t}\n\t})\n}\n\nfunc (tt *connTest) goDiscardLoop(c *websocket.Conn) {\n\tctx, cancel := context.WithCancel(tt.ctx)\n\n\tdiscardLoopErr := xsync.Go(func() error {\n\t\tdefer c.Close(websocket.StatusInternalError, \"\")\n\n\t\tfor {\n\t\t\t_, _, err := c.Read(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn assertCloseStatus(websocket.StatusNormalClosure, err)\n\t\t\t}\n\t\t}\n\t})\n\ttt.t.Cleanup(func() {\n\t\tcancel()\n\t\terr := <-discardLoopErr\n\t\tif err != nil {\n\t\t\ttt.t.Errorf(\"discard loop error: %v\", err)\n\t\t}\n\t})\n}\n\nfunc BenchmarkConn(b *testing.B) {\n\tbenchCases := []struct {\n\t\tname string\n\t\tmode websocket.CompressionMode\n\t}{\n\t\t{\n\t\t\tname: \"disabledCompress\",\n\t\t\tmode: websocket.CompressionDisabled,\n\t\t},\n\t\t{\n\t\t\tname: \"compressContextTakeover\",\n\t\t\tmode: websocket.CompressionContextTakeover,\n\t\t},\n\t\t{\n\t\t\tname: \"compressNoContext\",\n\t\t\tmode: websocket.CompressionNoContextTakeover,\n\t\t},\n\t}\n\tfor _, bc := range benchCases {\n\t\tb.Run(bc.name, func(b *testing.B) {\n\t\t\tbb, c1, c2 := newConnTest(b, &websocket.DialOptions{\n\t\t\t\tCompressionMode: bc.mode,\n\t\t\t}, &websocket.AcceptOptions{\n\t\t\t\tCompressionMode: bc.mode,\n\t\t\t})\n\n\t\t\tbb.goEchoLoop(c2)\n\n\t\t\tbytesWritten := c1.RecordBytesWritten()\n\t\t\tbytesRead := c1.RecordBytesRead()\n\n\t\t\tmsg := []byte(strings.Repeat(\"1234\", 128))\n\t\t\treadBuf := make([]byte, len(msg))\n\t\t\twrites := make(chan struct{})\n\t\t\tdefer close(writes)\n\t\t\twerrs := make(chan error)\n\n\t\t\tgo func() {\n\t\t\t\tfor range writes {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase werrs <- c1.Write(bb.ctx, websocket.MessageText, msg):\n\t\t\t\t\tcase <-bb.ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tb.SetBytes(int64(len(msg)))\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tselect {\n\t\t\t\tcase writes <- struct{}{}:\n\t\t\t\tcase <-bb.ctx.Done():\n\t\t\t\t\tb.Fatal(bb.ctx.Err())\n\t\t\t\t}\n\n\t\t\t\ttyp, r, err := c1.Reader(bb.ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(i, err)\n\t\t\t\t}\n\t\t\t\tif websocket.MessageText != typ {\n\t\t\t\t\tassert.Equal(b, \"data type\", websocket.MessageText, typ)\n\t\t\t\t}\n\n\t\t\t\t_, err = io.ReadFull(r, readBuf)\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tn2, err := r.Read(readBuf)\n\t\t\t\tif err != io.EOF {\n\t\t\t\t\tassert.Equal(b, \"read err\", io.EOF, err)\n\t\t\t\t}\n\t\t\t\tif n2 != 0 {\n\t\t\t\t\tassert.Equal(b, \"n2\", 0, n2)\n\t\t\t\t}\n\n\t\t\t\tif !bytes.Equal(msg, readBuf) {\n\t\t\t\t\tassert.Equal(b, \"msg\", msg, readBuf)\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase err = <-werrs:\n\t\t\t\tcase <-bb.ctx.Done():\n\t\t\t\t\tb.Fatal(bb.ctx.Err())\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tb.StopTimer()\n\n\t\t\tb.ReportMetric(float64(*bytesWritten/b.N), \"written/op\")\n\t\t\tb.ReportMetric(float64(*bytesRead/b.N), \"read/op\")\n\n\t\t\terr := c1.Close(websocket.StatusNormalClosure, \"\")\n\t\t\tassert.Success(b, err)\n\t\t})\n\t}\n}\n\nfunc echoServer(w http.ResponseWriter, r *http.Request, opts *websocket.AcceptOptions) (err error) {\n\tdefer errd.Wrap(&err, \"echo server failed\")\n\n\tc, err := websocket.Accept(w, r, opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.Close(websocket.StatusInternalError, \"\")\n\n\terr = wstest.EchoLoop(r.Context(), c)\n\treturn assertCloseStatus(websocket.StatusNormalClosure, err)\n}\n\nfunc assertEcho(tb testing.TB, ctx context.Context, c *websocket.Conn) {\n\texp := xrand.String(xrand.Int(131072))\n\n\twerr := xsync.Go(func() error {\n\t\treturn wsjson.Write(ctx, c, exp)\n\t})\n\n\tvar act interface{}\n\tc.SetReadLimit(1 << 30)\n\terr := wsjson.Read(ctx, c, &act)\n\tassert.Success(tb, err)\n\tassert.Equal(tb, \"read msg\", exp, act)\n\n\tselect {\n\tcase err := <-werr:\n\t\tassert.Success(tb, err)\n\tcase <-ctx.Done():\n\t\ttb.Fatal(ctx.Err())\n\t}\n}\n\nfunc assertClose(tb testing.TB, c *websocket.Conn) {\n\ttb.Helper()\n\terr := c.Close(websocket.StatusNormalClosure, \"\")\n\tassert.Success(tb, err)\n}\n\nfunc TestConcurrentClosePing(t *testing.T) {\n\tt.Parallel()\n\tfor i := 0; i < 64; i++ {\n\t\tfunc() {\n\t\t\tc1, c2 := wstest.Pipe(nil, nil)\n\t\t\tdefer c1.CloseNow()\n\t\t\tdefer c2.CloseNow()\n\t\t\tc1.CloseRead(context.Background())\n\t\t\tc2.CloseRead(context.Background())\n\t\t\terrc := xsync.Go(func() error {\n\t\t\t\tfor range time.Tick(time.Millisecond) {\n\t\t\t\t\terr := c1.Ping(context.Background())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpanic(\"unreachable\")\n\t\t\t})\n\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\tassert.Success(t, c1.Close(websocket.StatusNormalClosure, \"\"))\n\t\t\t<-errc\n\t\t}()\n\t}\n}\n\nfunc TestConnClosePropagation(t *testing.T) {\n\tt.Parallel()\n\n\twant := []byte(\"hello\")\n\tkeepWriting := func(c *websocket.Conn) <-chan error {\n\t\treturn xsync.Go(func() error {\n\t\t\tfor {\n\t\t\t\terr := c.Write(context.Background(), websocket.MessageText, want)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\tkeepReading := func(c *websocket.Conn) <-chan error {\n\t\treturn xsync.Go(func() error {\n\t\t\tfor {\n\t\t\t\t_, got, err := c.Read(context.Background())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif !bytes.Equal(want, got) {\n\t\t\t\t\treturn fmt.Errorf(\"unexpected message: want %q, got %q\", want, got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\tcheckReadErr := func(t *testing.T, err error) {\n\t\t// Check read error (output depends on when read is called in relation to connection closure).\n\t\tvar ce websocket.CloseError\n\t\tif errors.As(err, &ce) {\n\t\t\tassert.Equal(t, \"\", websocket.StatusNormalClosure, ce.Code)\n\t\t} else {\n\t\t\tassert.ErrorIs(t, net.ErrClosed, err)\n\t\t}\n\t}\n\tcheckConnErrs := func(t *testing.T, conn ...*websocket.Conn) {\n\t\tfor _, c := range conn {\n\t\t\t// Check write error.\n\t\t\terr := c.Write(context.Background(), websocket.MessageText, want)\n\t\t\tassert.ErrorIs(t, net.ErrClosed, err)\n\n\t\t\t_, _, err = c.Read(context.Background())\n\t\t\tcheckReadErr(t, err)\n\t\t}\n\t}\n\n\tt.Run(\"CloseOtherSideDuringWrite\", func(t *testing.T) {\n\t\ttt, this, other := newConnTest(t, nil, nil)\n\n\t\t_ = this.CloseRead(tt.ctx)\n\t\tthisWriteErr := keepWriting(this)\n\n\t\t_, got, err := other.Read(tt.ctx)\n\t\tassert.Success(t, err)\n\t\tassert.Equal(t, \"msg\", want, got)\n\n\t\terr = other.Close(websocket.StatusNormalClosure, \"\")\n\t\tassert.Success(t, err)\n\n\t\tselect {\n\t\tcase err := <-thisWriteErr:\n\t\t\tassert.ErrorIs(t, net.ErrClosed, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\tcheckConnErrs(t, this, other)\n\t})\n\tt.Run(\"CloseThisSideDuringWrite\", func(t *testing.T) {\n\t\ttt, this, other := newConnTest(t, nil, nil)\n\n\t\t_ = this.CloseRead(tt.ctx)\n\t\tthisWriteErr := keepWriting(this)\n\t\totherReadErr := keepReading(other)\n\n\t\terr := this.Close(websocket.StatusNormalClosure, \"\")\n\t\tassert.Success(t, err)\n\n\t\tselect {\n\t\tcase err := <-thisWriteErr:\n\t\t\tassert.ErrorIs(t, net.ErrClosed, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\tselect {\n\t\tcase err := <-otherReadErr:\n\t\t\tcheckReadErr(t, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\tcheckConnErrs(t, this, other)\n\t})\n\tt.Run(\"CloseOtherSideDuringRead\", func(t *testing.T) {\n\t\ttt, this, other := newConnTest(t, nil, nil)\n\n\t\t_ = other.CloseRead(tt.ctx)\n\t\terrs := keepReading(this)\n\n\t\terr := other.Write(tt.ctx, websocket.MessageText, want)\n\t\tassert.Success(t, err)\n\n\t\terr = other.Close(websocket.StatusNormalClosure, \"\")\n\t\tassert.Success(t, err)\n\n\t\tselect {\n\t\tcase err := <-errs:\n\t\t\tcheckReadErr(t, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\tcheckConnErrs(t, this, other)\n\t})\n\tt.Run(\"CloseThisSideDuringRead\", func(t *testing.T) {\n\t\ttt, this, other := newConnTest(t, nil, nil)\n\n\t\tthisReadErr := keepReading(this)\n\t\totherReadErr := keepReading(other)\n\n\t\terr := other.Write(tt.ctx, websocket.MessageText, want)\n\t\tassert.Success(t, err)\n\n\t\terr = this.Close(websocket.StatusNormalClosure, \"\")\n\t\tassert.Success(t, err)\n\n\t\tselect {\n\t\tcase err := <-thisReadErr:\n\t\t\tcheckReadErr(t, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\tselect {\n\t\tcase err := <-otherReadErr:\n\t\t\tcheckReadErr(t, err)\n\t\tcase <-tt.ctx.Done():\n\t\t\tt.Fatal(tt.ctx.Err())\n\t\t}\n\n\t\tcheckConnErrs(t, this, other)\n\t})\n}\n"
        },
        {
          "name": "dial.go",
          "type": "blob",
          "size": 8.7470703125,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/coder/websocket/internal/errd\"\n)\n\n// DialOptions represents Dial's options.\ntype DialOptions struct {\n\t// HTTPClient is used for the connection.\n\t// Its Transport must return writable bodies for WebSocket handshakes.\n\t// http.Transport does beginning with Go 1.12.\n\tHTTPClient *http.Client\n\n\t// HTTPHeader specifies the HTTP headers included in the handshake request.\n\tHTTPHeader http.Header\n\n\t// Host optionally overrides the Host HTTP header to send. If empty, the value\n\t// of URL.Host will be used.\n\tHost string\n\n\t// Subprotocols lists the WebSocket subprotocols to negotiate with the server.\n\tSubprotocols []string\n\n\t// CompressionMode controls the compression mode.\n\t// Defaults to CompressionDisabled.\n\t//\n\t// See docs on CompressionMode for details.\n\tCompressionMode CompressionMode\n\n\t// CompressionThreshold controls the minimum size of a message before compression is applied.\n\t//\n\t// Defaults to 512 bytes for CompressionNoContextTakeover and 128 bytes\n\t// for CompressionContextTakeover.\n\tCompressionThreshold int\n}\n\nfunc (opts *DialOptions) cloneWithDefaults(ctx context.Context) (context.Context, context.CancelFunc, *DialOptions) {\n\tvar cancel context.CancelFunc\n\n\tvar o DialOptions\n\tif opts != nil {\n\t\to = *opts\n\t}\n\tif o.HTTPClient == nil {\n\t\to.HTTPClient = http.DefaultClient\n\t}\n\tif o.HTTPClient.Timeout > 0 {\n\t\tctx, cancel = context.WithTimeout(ctx, o.HTTPClient.Timeout)\n\n\t\tnewClient := *o.HTTPClient\n\t\tnewClient.Timeout = 0\n\t\to.HTTPClient = &newClient\n\t}\n\tif o.HTTPHeader == nil {\n\t\to.HTTPHeader = http.Header{}\n\t}\n\tnewClient := *o.HTTPClient\n\toldCheckRedirect := o.HTTPClient.CheckRedirect\n\tnewClient.CheckRedirect = func(req *http.Request, via []*http.Request) error {\n\t\tswitch req.URL.Scheme {\n\t\tcase \"ws\":\n\t\t\treq.URL.Scheme = \"http\"\n\t\tcase \"wss\":\n\t\t\treq.URL.Scheme = \"https\"\n\t\t}\n\t\tif oldCheckRedirect != nil {\n\t\t\treturn oldCheckRedirect(req, via)\n\t\t}\n\t\treturn nil\n\t}\n\to.HTTPClient = &newClient\n\n\treturn ctx, cancel, &o\n}\n\n// Dial performs a WebSocket handshake on url.\n//\n// The response is the WebSocket handshake response from the server.\n// You never need to close resp.Body yourself.\n//\n// If an error occurs, the returned response may be non nil.\n// However, you can only read the first 1024 bytes of the body.\n//\n// This function requires at least Go 1.12 as it uses a new feature\n// in net/http to perform WebSocket handshakes.\n// See docs on the HTTPClient option and https://github.com/golang/go/issues/26937#issuecomment-415855861\n//\n// URLs with http/https schemes will work and are interpreted as ws/wss.\nfunc Dial(ctx context.Context, u string, opts *DialOptions) (*Conn, *http.Response, error) {\n\treturn dial(ctx, u, opts, nil)\n}\n\nfunc dial(ctx context.Context, urls string, opts *DialOptions, rand io.Reader) (_ *Conn, _ *http.Response, err error) {\n\tdefer errd.Wrap(&err, \"failed to WebSocket dial\")\n\n\tvar cancel context.CancelFunc\n\tctx, cancel, opts = opts.cloneWithDefaults(ctx)\n\tif cancel != nil {\n\t\tdefer cancel()\n\t}\n\n\tsecWebSocketKey, err := secWebSocketKey(rand)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to generate Sec-WebSocket-Key: %w\", err)\n\t}\n\n\tvar copts *compressionOptions\n\tif opts.CompressionMode != CompressionDisabled {\n\t\tcopts = opts.CompressionMode.opts()\n\t}\n\n\tresp, err := handshakeRequest(ctx, urls, opts, copts, secWebSocketKey)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\trespBody := resp.Body\n\tresp.Body = nil\n\tdefer func() {\n\t\tif err != nil {\n\t\t\t// We read a bit of the body for easier debugging.\n\t\t\tr := io.LimitReader(respBody, 1024)\n\n\t\t\ttimer := time.AfterFunc(time.Second*3, func() {\n\t\t\t\trespBody.Close()\n\t\t\t})\n\t\t\tdefer timer.Stop()\n\n\t\t\tb, _ := io.ReadAll(r)\n\t\t\trespBody.Close()\n\t\t\tresp.Body = io.NopCloser(bytes.NewReader(b))\n\t\t}\n\t}()\n\n\tcopts, err = verifyServerResponse(opts, copts, secWebSocketKey, resp)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\trwc, ok := respBody.(io.ReadWriteCloser)\n\tif !ok {\n\t\treturn nil, resp, fmt.Errorf(\"response body is not a io.ReadWriteCloser: %T\", respBody)\n\t}\n\n\treturn newConn(connConfig{\n\t\tsubprotocol:    resp.Header.Get(\"Sec-WebSocket-Protocol\"),\n\t\trwc:            rwc,\n\t\tclient:         true,\n\t\tcopts:          copts,\n\t\tflateThreshold: opts.CompressionThreshold,\n\t\tbr:             getBufioReader(rwc),\n\t\tbw:             getBufioWriter(rwc),\n\t}), resp, nil\n}\n\nfunc handshakeRequest(ctx context.Context, urls string, opts *DialOptions, copts *compressionOptions, secWebSocketKey string) (*http.Response, error) {\n\tu, err := url.Parse(urls)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse url: %w\", err)\n\t}\n\n\tswitch u.Scheme {\n\tcase \"ws\":\n\t\tu.Scheme = \"http\"\n\tcase \"wss\":\n\t\tu.Scheme = \"https\"\n\tcase \"http\", \"https\":\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected url scheme: %q\", u.Scheme)\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", u.String(), nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create new http request: %w\", err)\n\t}\n\tif len(opts.Host) > 0 {\n\t\treq.Host = opts.Host\n\t}\n\treq.Header = opts.HTTPHeader.Clone()\n\treq.Header.Set(\"Connection\", \"Upgrade\")\n\treq.Header.Set(\"Upgrade\", \"websocket\")\n\treq.Header.Set(\"Sec-WebSocket-Version\", \"13\")\n\treq.Header.Set(\"Sec-WebSocket-Key\", secWebSocketKey)\n\tif len(opts.Subprotocols) > 0 {\n\t\treq.Header.Set(\"Sec-WebSocket-Protocol\", strings.Join(opts.Subprotocols, \",\"))\n\t}\n\tif copts != nil {\n\t\treq.Header.Set(\"Sec-WebSocket-Extensions\", copts.String())\n\t}\n\n\tresp, err := opts.HTTPClient.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send handshake request: %w\", err)\n\t}\n\treturn resp, nil\n}\n\nfunc secWebSocketKey(rr io.Reader) (string, error) {\n\tif rr == nil {\n\t\trr = rand.Reader\n\t}\n\tb := make([]byte, 16)\n\t_, err := io.ReadFull(rr, b)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read random data from rand.Reader: %w\", err)\n\t}\n\treturn base64.StdEncoding.EncodeToString(b), nil\n}\n\nfunc verifyServerResponse(opts *DialOptions, copts *compressionOptions, secWebSocketKey string, resp *http.Response) (*compressionOptions, error) {\n\tif resp.StatusCode != http.StatusSwitchingProtocols {\n\t\treturn nil, fmt.Errorf(\"expected handshake response status code %v but got %v\", http.StatusSwitchingProtocols, resp.StatusCode)\n\t}\n\n\tif !headerContainsTokenIgnoreCase(resp.Header, \"Connection\", \"Upgrade\") {\n\t\treturn nil, fmt.Errorf(\"WebSocket protocol violation: Connection header %q does not contain Upgrade\", resp.Header.Get(\"Connection\"))\n\t}\n\n\tif !headerContainsTokenIgnoreCase(resp.Header, \"Upgrade\", \"WebSocket\") {\n\t\treturn nil, fmt.Errorf(\"WebSocket protocol violation: Upgrade header %q does not contain websocket\", resp.Header.Get(\"Upgrade\"))\n\t}\n\n\tif resp.Header.Get(\"Sec-WebSocket-Accept\") != secWebSocketAccept(secWebSocketKey) {\n\t\treturn nil, fmt.Errorf(\"WebSocket protocol violation: invalid Sec-WebSocket-Accept %q, key %q\",\n\t\t\tresp.Header.Get(\"Sec-WebSocket-Accept\"),\n\t\t\tsecWebSocketKey,\n\t\t)\n\t}\n\n\terr := verifySubprotocol(opts.Subprotocols, resp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn verifyServerExtensions(copts, resp.Header)\n}\n\nfunc verifySubprotocol(subprotos []string, resp *http.Response) error {\n\tproto := resp.Header.Get(\"Sec-WebSocket-Protocol\")\n\tif proto == \"\" {\n\t\treturn nil\n\t}\n\n\tfor _, sp2 := range subprotos {\n\t\tif strings.EqualFold(sp2, proto) {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"WebSocket protocol violation: unexpected Sec-WebSocket-Protocol from server: %q\", proto)\n}\n\nfunc verifyServerExtensions(copts *compressionOptions, h http.Header) (*compressionOptions, error) {\n\texts := websocketExtensions(h)\n\tif len(exts) == 0 {\n\t\treturn nil, nil\n\t}\n\n\text := exts[0]\n\tif ext.name != \"permessage-deflate\" || len(exts) > 1 || copts == nil {\n\t\treturn nil, fmt.Errorf(\"WebSocket protcol violation: unsupported extensions from server: %+v\", exts[1:])\n\t}\n\n\t_copts := *copts\n\tcopts = &_copts\n\n\tfor _, p := range ext.params {\n\t\tswitch p {\n\t\tcase \"client_no_context_takeover\":\n\t\t\tcopts.clientNoContextTakeover = true\n\t\t\tcontinue\n\t\tcase \"server_no_context_takeover\":\n\t\t\tcopts.serverNoContextTakeover = true\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(p, \"server_max_window_bits=\") {\n\t\t\t// We can't adjust the deflate window, but decoding with a larger window is acceptable.\n\t\t\tcontinue\n\t\t}\n\n\t\treturn nil, fmt.Errorf(\"unsupported permessage-deflate parameter: %q\", p)\n\t}\n\n\treturn copts, nil\n}\n\nvar bufioReaderPool sync.Pool\n\nfunc getBufioReader(r io.Reader) *bufio.Reader {\n\tbr, ok := bufioReaderPool.Get().(*bufio.Reader)\n\tif !ok {\n\t\treturn bufio.NewReader(r)\n\t}\n\tbr.Reset(r)\n\treturn br\n}\n\nfunc putBufioReader(br *bufio.Reader) {\n\tbufioReaderPool.Put(br)\n}\n\nvar bufioWriterPool sync.Pool\n\nfunc getBufioWriter(w io.Writer) *bufio.Writer {\n\tbw, ok := bufioWriterPool.Get().(*bufio.Writer)\n\tif !ok {\n\t\treturn bufio.NewWriter(w)\n\t}\n\tbw.Reset(w)\n\treturn bw\n}\n\nfunc putBufioWriter(bw *bufio.Writer) {\n\tbufioWriterPool.Put(bw)\n}\n"
        },
        {
          "name": "dial_test.go",
          "type": "blob",
          "size": 9.6640625,
          "content": "//go:build !js\n// +build !js\n\npackage websocket_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/coder/websocket\"\n\t\"github.com/coder/websocket/internal/test/assert\"\n\t\"github.com/coder/websocket/internal/util\"\n\t\"github.com/coder/websocket/internal/xsync\"\n)\n\nfunc TestBadDials(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"badReq\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestCases := []struct {\n\t\t\tname   string\n\t\t\turl    string\n\t\t\topts   *websocket.DialOptions\n\t\t\trand   util.ReaderFunc\n\t\t\tnilCtx bool\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"badURL\",\n\t\t\t\turl:  \"://noscheme\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"badURLScheme\",\n\t\t\t\turl:  \"ftp://nhooyr.io\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"badTLS\",\n\t\t\t\turl:  \"wss://totallyfake.nhooyr.io\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"badReader\",\n\t\t\t\trand: func(p []byte) (int, error) {\n\t\t\t\t\treturn 0, io.EOF\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"nilContext\",\n\t\t\t\turl:    \"http://localhost\",\n\t\t\t\tnilCtx: true,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testCases {\n\t\t\ttc := tc\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tvar ctx context.Context\n\t\t\t\tvar cancel func()\n\t\t\t\tif !tc.nilCtx {\n\t\t\t\t\tctx, cancel = context.WithTimeout(context.Background(), time.Second*5)\n\t\t\t\t\tdefer cancel()\n\t\t\t\t}\n\n\t\t\t\tif tc.rand == nil {\n\t\t\t\t\ttc.rand = rand.Reader.Read\n\t\t\t\t}\n\n\t\t\t\t_, _, err := websocket.ExportedDial(ctx, tc.url, tc.opts, tc.rand)\n\t\t\t\tassert.Error(t, err)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"badResponse\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\t\tdefer cancel()\n\n\t\t_, _, err := websocket.Dial(ctx, \"ws://example.com\", &websocket.DialOptions{\n\t\t\tHTTPClient: mockHTTPClient(func(*http.Request) (*http.Response, error) {\n\t\t\t\treturn &http.Response{\n\t\t\t\t\tBody: io.NopCloser(strings.NewReader(\"hi\")),\n\t\t\t\t}, nil\n\t\t\t}),\n\t\t})\n\t\tassert.Contains(t, err, \"failed to WebSocket dial: expected handshake response status code 101 but got 0\")\n\t})\n\n\tt.Run(\"badBody\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\t\tdefer cancel()\n\n\t\trt := func(r *http.Request) (*http.Response, error) {\n\t\t\th := http.Header{}\n\t\t\th.Set(\"Connection\", \"Upgrade\")\n\t\t\th.Set(\"Upgrade\", \"websocket\")\n\t\t\th.Set(\"Sec-WebSocket-Accept\", websocket.SecWebSocketAccept(r.Header.Get(\"Sec-WebSocket-Key\")))\n\n\t\t\treturn &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tHeader:     h,\n\t\t\t\tBody:       io.NopCloser(strings.NewReader(\"hi\")),\n\t\t\t}, nil\n\t\t}\n\n\t\t_, _, err := websocket.Dial(ctx, \"ws://example.com\", &websocket.DialOptions{\n\t\t\tHTTPClient: mockHTTPClient(rt),\n\t\t})\n\t\tassert.Contains(t, err, \"response body is not a io.ReadWriteCloser\")\n\t})\n}\n\nfunc Test_verifyHostOverride(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\thost string\n\t\texp  string\n\t}{\n\t\t{\n\t\t\tname: \"noOverride\",\n\t\t\thost: \"\",\n\t\t\texp:  \"example.com\",\n\t\t},\n\t\t{\n\t\t\tname: \"hostOverride\",\n\t\t\thost: \"example.net\",\n\t\t\texp:  \"example.net\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\t\t\tdefer cancel()\n\n\t\t\trt := func(r *http.Request) (*http.Response, error) {\n\t\t\t\tassert.Equal(t, \"Host\", tc.exp, r.Host)\n\n\t\t\t\th := http.Header{}\n\t\t\t\th.Set(\"Connection\", \"Upgrade\")\n\t\t\t\th.Set(\"Upgrade\", \"websocket\")\n\t\t\t\th.Set(\"Sec-WebSocket-Accept\", websocket.SecWebSocketAccept(r.Header.Get(\"Sec-WebSocket-Key\")))\n\n\t\t\t\treturn &http.Response{\n\t\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\t\tHeader:     h,\n\t\t\t\t\tBody:       mockBody{bytes.NewBufferString(\"hi\")},\n\t\t\t\t}, nil\n\t\t\t}\n\n\t\t\tc, _, err := websocket.Dial(ctx, \"ws://example.com\", &websocket.DialOptions{\n\t\t\t\tHTTPClient: mockHTTPClient(rt),\n\t\t\t\tHost:       tc.host,\n\t\t\t})\n\t\t\tassert.Success(t, err)\n\t\t\tc.CloseNow()\n\t\t})\n\t}\n\n}\n\ntype mockBody struct {\n\t*bytes.Buffer\n}\n\nfunc (mb mockBody) Close() error {\n\treturn nil\n}\n\nfunc Test_verifyServerHandshake(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tresponse func(w http.ResponseWriter)\n\t\tsuccess  bool\n\t}{\n\t\t{\n\t\t\tname: \"badStatus\",\n\t\t\tresponse: func(w http.ResponseWriter) {\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname: \"badConnection\",\n\t\t\tresponse: func(w http.ResponseWriter) {\n\t\t\t\tw.Header().Set(\"Connection\", \"???\")\n\t\t\t\tw.WriteHeader(http.StatusSwitchingProtocols)\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname: \"badUpgrade\",\n\t\t\tresponse: func(w http.ResponseWriter) {\n\t\t\t\tw.Header().Set(\"Connection\", \"Upgrade\")\n\t\t\t\tw.Header().Set(\"Upgrade\", \"???\")\n\t\t\t\tw.WriteHeader(http.StatusSwitchingProtocols)\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname: \"badSecWebSocketAccept\",\n\t\t\tresponse: func(w http.ResponseWriter) {\n\t\t\t\tw.Header().Set(\"Connection\", \"Upgrade\")\n\t\t\t\tw.Header().Set(\"Upgrade\", \"websocket\")\n\t\t\t\tw.Header().Set(\"Sec-WebSocket-Accept\", \"xd\")\n\t\t\t\tw.WriteHeader(http.StatusSwitchingProtocols)\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname: \"badSecWebSocketProtocol\",\n\t\t\tresponse: func(w http.ResponseWriter) {\n\t\t\t\tw.Header().Set(\"Connection\", \"Upgrade\")\n\t\t\t\tw.Header().Set(\"Upgrade\", \"websocket\")\n\t\t\t\tw.Header().Set(\"Sec-WebSocket-Protocol\", \"xd\")\n\t\t\t\tw.WriteHeader(http.StatusSwitchingProtocols)\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unsupportedExtension\",\n\t\t\tresponse: func(w http.ResponseWriter) {\n\t\t\t\tw.Header().Set(\"Connection\", \"Upgrade\")\n\t\t\t\tw.Header().Set(\"Upgrade\", \"websocket\")\n\t\t\t\tw.Header().Set(\"Sec-WebSocket-Extensions\", \"meow\")\n\t\t\t\tw.WriteHeader(http.StatusSwitchingProtocols)\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unsupportedDeflateParam\",\n\t\t\tresponse: func(w http.ResponseWriter) {\n\t\t\t\tw.Header().Set(\"Connection\", \"Upgrade\")\n\t\t\t\tw.Header().Set(\"Upgrade\", \"websocket\")\n\t\t\t\tw.Header().Set(\"Sec-WebSocket-Extensions\", \"permessage-deflate; meow\")\n\t\t\t\tw.WriteHeader(http.StatusSwitchingProtocols)\n\t\t\t},\n\t\t\tsuccess: false,\n\t\t},\n\t\t{\n\t\t\tname: \"success\",\n\t\t\tresponse: func(w http.ResponseWriter) {\n\t\t\t\tw.Header().Set(\"Connection\", \"Upgrade\")\n\t\t\t\tw.Header().Set(\"Upgrade\", \"websocket\")\n\t\t\t\tw.WriteHeader(http.StatusSwitchingProtocols)\n\t\t\t},\n\t\t\tsuccess: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tw := httptest.NewRecorder()\n\t\t\ttc.response(w)\n\t\t\tresp := w.Result()\n\n\t\t\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t\t\tkey, err := websocket.SecWebSocketKey(rand.Reader)\n\t\t\tassert.Success(t, err)\n\t\t\tr.Header.Set(\"Sec-WebSocket-Key\", key)\n\n\t\t\tif resp.Header.Get(\"Sec-WebSocket-Accept\") == \"\" {\n\t\t\t\tresp.Header.Set(\"Sec-WebSocket-Accept\", websocket.SecWebSocketAccept(key))\n\t\t\t}\n\n\t\t\topts := &websocket.DialOptions{\n\t\t\t\tSubprotocols: strings.Split(r.Header.Get(\"Sec-WebSocket-Protocol\"), \",\"),\n\t\t\t}\n\t\t\t_, err = websocket.VerifyServerResponse(opts, websocket.CompressionModeOpts(opts.CompressionMode), key, resp)\n\t\t\tif tc.success {\n\t\t\t\tassert.Success(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc mockHTTPClient(fn roundTripperFunc) *http.Client {\n\treturn &http.Client{\n\t\tTransport: fn,\n\t}\n}\n\ntype roundTripperFunc func(*http.Request) (*http.Response, error)\n\nfunc (f roundTripperFunc) RoundTrip(r *http.Request) (*http.Response, error) {\n\treturn f(r)\n}\n\nfunc TestDialRedirect(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\tdefer cancel()\n\n\t_, _, err := websocket.Dial(ctx, \"ws://example.com\", &websocket.DialOptions{\n\t\tHTTPClient: mockHTTPClient(func(r *http.Request) (*http.Response, error) {\n\t\t\tresp := &http.Response{\n\t\t\t\tHeader: http.Header{},\n\t\t\t}\n\t\t\tif r.URL.Scheme != \"https\" {\n\t\t\t\tresp.Header.Set(\"Location\", \"wss://example.com\")\n\t\t\t\tresp.StatusCode = http.StatusFound\n\t\t\t\treturn resp, nil\n\t\t\t}\n\t\t\tresp.Header.Set(\"Connection\", \"Upgrade\")\n\t\t\tresp.Header.Set(\"Upgrade\", \"meow\")\n\t\t\tresp.StatusCode = http.StatusSwitchingProtocols\n\t\t\treturn resp, nil\n\t\t}),\n\t})\n\tassert.Contains(t, err, \"failed to WebSocket dial: WebSocket protocol violation: Upgrade header \\\"meow\\\" does not contain websocket\")\n}\n\ntype forwardProxy struct {\n\thc *http.Client\n}\n\nfunc newForwardProxy() *forwardProxy {\n\treturn &forwardProxy{\n\t\thc: &http.Client{},\n\t}\n}\n\nfunc (fc *forwardProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tctx, cancel := context.WithTimeout(r.Context(), time.Second*10)\n\tdefer cancel()\n\n\tr = r.WithContext(ctx)\n\tr.RequestURI = \"\"\n\tresp, err := fc.hc.Do(r)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tfor k, v := range resp.Header {\n\t\tw.Header()[k] = v\n\t}\n\tw.Header().Set(\"PROXIED\", \"true\")\n\tw.WriteHeader(resp.StatusCode)\n\tif resprw, ok := resp.Body.(io.ReadWriter); ok {\n\t\tc, brw, err := w.(http.Hijacker).Hijack()\n\t\tif err != nil {\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tbrw.Flush()\n\n\t\terrc1 := xsync.Go(func() error {\n\t\t\t_, err := io.Copy(c, resprw)\n\t\t\treturn err\n\t\t})\n\t\terrc2 := xsync.Go(func() error {\n\t\t\t_, err := io.Copy(resprw, c)\n\t\t\treturn err\n\t\t})\n\t\tselect {\n\t\tcase <-errc1:\n\t\tcase <-errc2:\n\t\tcase <-r.Context().Done():\n\t\t}\n\t} else {\n\t\tio.Copy(w, resp.Body)\n\t}\n}\n\nfunc TestDialViaProxy(t *testing.T) {\n\tt.Parallel()\n\n\tps := httptest.NewServer(newForwardProxy())\n\tdefer ps.Close()\n\n\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\terr := echoServer(w, r, nil)\n\t\tassert.Success(t, err)\n\t}))\n\tdefer s.Close()\n\n\tpsu, err := url.Parse(ps.URL)\n\tassert.Success(t, err)\n\tproxyTransport := http.DefaultTransport.(*http.Transport).Clone()\n\tproxyTransport.Proxy = http.ProxyURL(psu)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\tc, resp, err := websocket.Dial(ctx, s.URL, &websocket.DialOptions{\n\t\tHTTPClient: &http.Client{\n\t\t\tTransport: proxyTransport,\n\t\t},\n\t})\n\tassert.Success(t, err)\n\tassert.Equal(t, \"\", \"true\", resp.Header.Get(\"PROXIED\"))\n\n\tassertEcho(t, ctx, c)\n\tassertClose(t, c)\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.0302734375,
          "content": "//go:build !js\n// +build !js\n\n// Package websocket implements the RFC 6455 WebSocket protocol.\n//\n// https://tools.ietf.org/html/rfc6455\n//\n// Use Dial to dial a WebSocket server.\n//\n// Use Accept to accept a WebSocket client.\n//\n// Conn represents the resulting WebSocket connection.\n//\n// The examples are the best way to understand how to correctly use the library.\n//\n// The wsjson subpackage contain helpers for JSON and protobuf messages.\n//\n// More documentation at https://github.com/coder/websocket.\n//\n// # Wasm\n//\n// The client side supports compiling to Wasm.\n// It wraps the WebSocket browser API.\n//\n// See https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n//\n// Some important caveats to be aware of:\n//\n//   - Accept always errors out\n//   - Conn.Ping is no-op\n//   - Conn.CloseNow is Close(StatusGoingAway, \"\")\n//   - HTTPClient, HTTPHeader and CompressionMode in DialOptions are no-op\n//   - *http.Response from Dial is &http.Response{} with a 101 status code on success\npackage websocket // import \"github.com/coder/websocket\"\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 3.83203125,
          "content": "package websocket_test\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/coder/websocket\"\n\t\"github.com/coder/websocket/wsjson\"\n)\n\nfunc ExampleAccept() {\n\t// This handler accepts a WebSocket connection, reads a single JSON\n\t// message from the client and then closes the connection.\n\n\tfn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := websocket.Accept(w, r, nil)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t\tdefer c.CloseNow()\n\n\t\tctx, cancel := context.WithTimeout(r.Context(), time.Second*10)\n\t\tdefer cancel()\n\n\t\tvar v interface{}\n\t\terr = wsjson.Read(ctx, c, &v)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tc.Close(websocket.StatusNormalClosure, \"\")\n\t})\n\n\terr := http.ListenAndServe(\"localhost:8080\", fn)\n\tlog.Fatal(err)\n}\n\nfunc ExampleDial() {\n\t// Dials a server, writes a single JSON message and then\n\t// closes the connection.\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\tc, _, err := websocket.Dial(ctx, \"ws://localhost:8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer c.CloseNow()\n\n\terr = wsjson.Write(ctx, c, \"hi\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tc.Close(websocket.StatusNormalClosure, \"\")\n}\n\nfunc ExampleCloseStatus() {\n\t// Dials a server and then expects to be disconnected with status code\n\t// websocket.StatusNormalClosure.\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\tc, _, err := websocket.Dial(ctx, \"ws://localhost:8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer c.CloseNow()\n\n\t_, _, err = c.Reader(ctx)\n\tif websocket.CloseStatus(err) != websocket.StatusNormalClosure {\n\t\tlog.Fatalf(\"expected to be disconnected with StatusNormalClosure but got: %v\", err)\n\t}\n}\n\nfunc Example_writeOnly() {\n\t// This handler demonstrates how to correctly handle a write only WebSocket connection.\n\t// i.e you only expect to write messages and do not expect to read any messages.\n\tfn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := websocket.Accept(w, r, nil)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t\tdefer c.CloseNow()\n\n\t\tctx, cancel := context.WithTimeout(r.Context(), time.Minute*10)\n\t\tdefer cancel()\n\n\t\tctx = c.CloseRead(ctx)\n\n\t\tt := time.NewTicker(time.Second * 30)\n\t\tdefer t.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tc.Close(websocket.StatusNormalClosure, \"\")\n\t\t\t\treturn\n\t\t\tcase <-t.C:\n\t\t\t\terr = wsjson.Write(ctx, c, \"hi\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\terr := http.ListenAndServe(\"localhost:8080\", fn)\n\tlog.Fatal(err)\n}\n\nfunc Example_crossOrigin() {\n\t// This handler demonstrates how to safely accept cross origin WebSockets\n\t// from the origin example.com.\n\tfn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tc, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n\t\t\tOriginPatterns: []string{\"example.com\"},\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t\tc.Close(websocket.StatusNormalClosure, \"cross origin WebSocket accepted\")\n\t})\n\n\terr := http.ListenAndServe(\"localhost:8080\", fn)\n\tlog.Fatal(err)\n}\n\nfunc ExampleConn_Ping() {\n\t// Dials a server and pings it 5 times.\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\tc, _, err := websocket.Dial(ctx, \"ws://localhost:8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer c.CloseNow()\n\n\t// Required to read the Pongs from the server.\n\tctx = c.CloseRead(ctx)\n\n\tfor i := 0; i < 5; i++ {\n\t\terr = c.Ping(ctx)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\tc.Close(websocket.StatusNormalClosure, \"\")\n}\n\n// This example demonstrates full stack chat with an automated test.\nfunc Example_fullStackChat() {\n\t// https://github.com/nhooyr/websocket/tree/master/internal/examples/chat\n}\n\n// This example demonstrates a echo server.\nfunc Example_echo() {\n\t// https://github.com/nhooyr/websocket/tree/master/internal/examples/echo\n}\n"
        },
        {
          "name": "export_test.go",
          "type": "blob",
          "size": 0.7333984375,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"net\"\n\n\t\"github.com/coder/websocket/internal/util\"\n)\n\nfunc (c *Conn) RecordBytesWritten() *int {\n\tvar bytesWritten int\n\tc.bw.Reset(util.WriterFunc(func(p []byte) (int, error) {\n\t\tbytesWritten += len(p)\n\t\treturn c.rwc.Write(p)\n\t}))\n\treturn &bytesWritten\n}\n\nfunc (c *Conn) RecordBytesRead() *int {\n\tvar bytesRead int\n\tc.br.Reset(util.ReaderFunc(func(p []byte) (int, error) {\n\t\tn, err := c.rwc.Read(p)\n\t\tbytesRead += n\n\t\treturn n, err\n\t}))\n\treturn &bytesRead\n}\n\nvar ErrClosed = net.ErrClosed\n\nvar ExportedDial = dial\nvar SecWebSocketAccept = secWebSocketAccept\nvar SecWebSocketKey = secWebSocketKey\nvar VerifyServerResponse = verifyServerResponse\n\nvar CompressionModeOpts = CompressionMode.opts\n"
        },
        {
          "name": "frame.go",
          "type": "blob",
          "size": 3.2099609375,
          "content": "//go:build !js\n\npackage websocket\n\nimport (\n\t\"bufio\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\n\t\"github.com/coder/websocket/internal/errd\"\n)\n\n// opcode represents a WebSocket opcode.\ntype opcode int\n\n// https://tools.ietf.org/html/rfc6455#section-11.8.\nconst (\n\topContinuation opcode = iota\n\topText\n\topBinary\n\t// 3 - 7 are reserved for further non-control frames.\n\t_\n\t_\n\t_\n\t_\n\t_\n\topClose\n\topPing\n\topPong\n\t// 11-16 are reserved for further control frames.\n)\n\n// header represents a WebSocket frame header.\n// See https://tools.ietf.org/html/rfc6455#section-5.2.\ntype header struct {\n\tfin    bool\n\trsv1   bool\n\trsv2   bool\n\trsv3   bool\n\topcode opcode\n\n\tpayloadLength int64\n\n\tmasked  bool\n\tmaskKey uint32\n}\n\n// readFrameHeader reads a header from the reader.\n// See https://tools.ietf.org/html/rfc6455#section-5.2.\nfunc readFrameHeader(r *bufio.Reader, readBuf []byte) (h header, err error) {\n\tdefer errd.Wrap(&err, \"failed to read frame header\")\n\n\tb, err := r.ReadByte()\n\tif err != nil {\n\t\treturn header{}, err\n\t}\n\n\th.fin = b&(1<<7) != 0\n\th.rsv1 = b&(1<<6) != 0\n\th.rsv2 = b&(1<<5) != 0\n\th.rsv3 = b&(1<<4) != 0\n\n\th.opcode = opcode(b & 0xf)\n\n\tb, err = r.ReadByte()\n\tif err != nil {\n\t\treturn header{}, err\n\t}\n\n\th.masked = b&(1<<7) != 0\n\n\tpayloadLength := b &^ (1 << 7)\n\tswitch {\n\tcase payloadLength < 126:\n\t\th.payloadLength = int64(payloadLength)\n\tcase payloadLength == 126:\n\t\t_, err = io.ReadFull(r, readBuf[:2])\n\t\th.payloadLength = int64(binary.BigEndian.Uint16(readBuf))\n\tcase payloadLength == 127:\n\t\t_, err = io.ReadFull(r, readBuf)\n\t\th.payloadLength = int64(binary.BigEndian.Uint64(readBuf))\n\t}\n\tif err != nil {\n\t\treturn header{}, err\n\t}\n\n\tif h.payloadLength < 0 {\n\t\treturn header{}, fmt.Errorf(\"received negative payload length: %v\", h.payloadLength)\n\t}\n\n\tif h.masked {\n\t\t_, err = io.ReadFull(r, readBuf[:4])\n\t\tif err != nil {\n\t\t\treturn header{}, err\n\t\t}\n\t\th.maskKey = binary.LittleEndian.Uint32(readBuf)\n\t}\n\n\treturn h, nil\n}\n\n// maxControlPayload is the maximum length of a control frame payload.\n// See https://tools.ietf.org/html/rfc6455#section-5.5.\nconst maxControlPayload = 125\n\n// writeFrameHeader writes the bytes of the header to w.\n// See https://tools.ietf.org/html/rfc6455#section-5.2\nfunc writeFrameHeader(h header, w *bufio.Writer, buf []byte) (err error) {\n\tdefer errd.Wrap(&err, \"failed to write frame header\")\n\n\tvar b byte\n\tif h.fin {\n\t\tb |= 1 << 7\n\t}\n\tif h.rsv1 {\n\t\tb |= 1 << 6\n\t}\n\tif h.rsv2 {\n\t\tb |= 1 << 5\n\t}\n\tif h.rsv3 {\n\t\tb |= 1 << 4\n\t}\n\n\tb |= byte(h.opcode)\n\n\terr = w.WriteByte(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlengthByte := byte(0)\n\tif h.masked {\n\t\tlengthByte |= 1 << 7\n\t}\n\n\tswitch {\n\tcase h.payloadLength > math.MaxUint16:\n\t\tlengthByte |= 127\n\tcase h.payloadLength > 125:\n\t\tlengthByte |= 126\n\tcase h.payloadLength >= 0:\n\t\tlengthByte |= byte(h.payloadLength)\n\t}\n\terr = w.WriteByte(lengthByte)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch {\n\tcase h.payloadLength > math.MaxUint16:\n\t\tbinary.BigEndian.PutUint64(buf, uint64(h.payloadLength))\n\t\t_, err = w.Write(buf)\n\tcase h.payloadLength > 125:\n\t\tbinary.BigEndian.PutUint16(buf, uint16(h.payloadLength))\n\t\t_, err = w.Write(buf[:2])\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif h.masked {\n\t\tbinary.LittleEndian.PutUint32(buf, h.maskKey)\n\t\t_, err = w.Write(buf[:4])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "frame_test.go",
          "type": "blob",
          "size": 1.73046875,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"math/bits\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/coder/websocket/internal/test/assert\"\n)\n\nfunc TestHeader(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"lengths\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tlengths := []int{\n\t\t\t124,\n\t\t\t125,\n\t\t\t126,\n\t\t\t127,\n\n\t\t\t65534,\n\t\t\t65535,\n\t\t\t65536,\n\t\t\t65537,\n\t\t}\n\n\t\tfor _, n := range lengths {\n\t\t\tn := n\n\t\t\tt.Run(strconv.Itoa(n), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\ttestHeader(t, header{\n\t\t\t\t\tpayloadLength: int64(n),\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"fuzz\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\t\trandBool := func() bool {\n\t\t\treturn r.Intn(2) == 0\n\t\t}\n\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\th := header{\n\t\t\t\tfin:    randBool(),\n\t\t\t\trsv1:   randBool(),\n\t\t\t\trsv2:   randBool(),\n\t\t\t\trsv3:   randBool(),\n\t\t\t\topcode: opcode(r.Intn(16)),\n\n\t\t\t\tmasked:        randBool(),\n\t\t\t\tpayloadLength: r.Int63(),\n\t\t\t}\n\t\t\tif h.masked {\n\t\t\t\th.maskKey = r.Uint32()\n\t\t\t}\n\n\t\t\ttestHeader(t, h)\n\t\t}\n\t})\n}\n\nfunc testHeader(t *testing.T, h header) {\n\tb := &bytes.Buffer{}\n\tw := bufio.NewWriter(b)\n\tr := bufio.NewReader(b)\n\n\terr := writeFrameHeader(h, w, make([]byte, 8))\n\tassert.Success(t, err)\n\n\terr = w.Flush()\n\tassert.Success(t, err)\n\n\th2, err := readFrameHeader(r, make([]byte, 8))\n\tassert.Success(t, err)\n\n\tassert.Equal(t, \"read header\", h, h2)\n}\n\nfunc Test_mask(t *testing.T) {\n\tt.Parallel()\n\n\tkey := []byte{0xa, 0xb, 0xc, 0xff}\n\tkey32 := binary.LittleEndian.Uint32(key)\n\tp := []byte{0xa, 0xb, 0xc, 0xf2, 0xc}\n\tgotKey32 := mask(p, key32)\n\n\texpP := []byte{0, 0, 0, 0x0d, 0x6}\n\tassert.Equal(t, \"p\", expP, p)\n\n\texpKey32 := bits.RotateLeft32(key32, -8)\n\tassert.Equal(t, \"key32\", expKey32, gotKey32)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0419921875,
          "content": "module github.com/coder/websocket\n\ngo 1.19\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "hijack.go",
          "type": "blob",
          "size": 0.828125,
          "content": "//go:build !js\n\npackage websocket\n\nimport (\n\t\"net/http\"\n)\n\ntype rwUnwrapper interface {\n\tUnwrap() http.ResponseWriter\n}\n\n// hijacker returns the Hijacker interface of the http.ResponseWriter.\n// It follows the Unwrap method of the http.ResponseWriter if available,\n// matching the behavior of http.ResponseController. If the Hijacker\n// interface is not found, it returns false.\n//\n// Since the http.ResponseController is not available in Go 1.19, and\n// does not support checking the presence of the Hijacker interface,\n// this function is used to provide a consistent way to check for the\n// Hijacker interface across Go versions.\nfunc hijacker(rw http.ResponseWriter) (http.Hijacker, bool) {\n\tfor {\n\t\tswitch t := rw.(type) {\n\t\tcase http.Hijacker:\n\t\t\treturn t, true\n\t\tcase rwUnwrapper:\n\t\t\trw = t.Unwrap()\n\t\tdefault:\n\t\t\treturn nil, false\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "hijack_go120_test.go",
          "type": "blob",
          "size": 0.755859375,
          "content": "//go:build !js && go1.20\n\npackage websocket\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/coder/websocket/internal/test/assert\"\n)\n\nfunc Test_hijackerHTTPResponseControllerCompatibility(t *testing.T) {\n\tt.Parallel()\n\n\trr := httptest.NewRecorder()\n\tw := mockUnwrapper{\n\t\tResponseWriter: rr,\n\t\tunwrap: func() http.ResponseWriter {\n\t\t\treturn mockHijacker{\n\t\t\t\tResponseWriter: rr,\n\t\t\t\thijack: func() (conn net.Conn, writer *bufio.ReadWriter, err error) {\n\t\t\t\t\treturn nil, nil, errors.New(\"haha\")\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t}\n\n\t_, _, err := http.NewResponseController(w).Hijack()\n\tassert.Contains(t, err, \"haha\")\n\thj, ok := hijacker(w)\n\tassert.Equal(t, \"hijacker found\", ok, true)\n\t_, _, err = hj.Hijack()\n\tassert.Contains(t, err, \"haha\")\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 0.59375,
          "content": "package websocket_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"testing\"\n)\n\nfunc goroutineStacks() []byte {\n\tbuf := make([]byte, 512)\n\tfor {\n\t\tm := runtime.Stack(buf, true)\n\t\tif m < len(buf) {\n\t\t\treturn buf[:m]\n\t\t}\n\t\tbuf = make([]byte, len(buf)*2)\n\t}\n}\n\nfunc TestMain(m *testing.M) {\n\tcode := m.Run()\n\tif runtime.GOOS != \"js\" && runtime.NumGoroutine() != 1 ||\n\t\truntime.GOOS == \"js\" && runtime.NumGoroutine() != 2 {\n\t\tfmt.Fprintf(os.Stderr, \"goroutine leak detected, expected 1 but got %d goroutines\\n\", runtime.NumGoroutine())\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", goroutineStacks())\n\t\tos.Exit(1)\n\t}\n\tos.Exit(code)\n}\n"
        },
        {
          "name": "make.sh",
          "type": "blob",
          "size": 0.171875,
          "content": "#!/bin/sh\nset -eu\ncd -- \"$(dirname \"$0\")\"\n\necho \"=== fmt.sh\"\n./ci/fmt.sh\necho \"=== lint.sh\"\n./ci/lint.sh\necho \"=== test.sh\"\n./ci/test.sh \"$@\"\necho \"=== bench.sh\"\n./ci/bench.sh\n"
        },
        {
          "name": "mask.go",
          "type": "blob",
          "size": 4.2197265625,
          "content": "package websocket\n\nimport (\n\t\"encoding/binary\"\n\t\"math/bits\"\n)\n\n// maskGo applies the WebSocket masking algorithm to p\n// with the given key.\n// See https://tools.ietf.org/html/rfc6455#section-5.3\n//\n// The returned value is the correctly rotated key to\n// to continue to mask/unmask the message.\n//\n// It is optimized for LittleEndian and expects the key\n// to be in little endian.\n//\n// See https://github.com/golang/go/issues/31586\nfunc maskGo(b []byte, key uint32) uint32 {\n\tif len(b) >= 8 {\n\t\tkey64 := uint64(key)<<32 | uint64(key)\n\n\t\t// At some point in the future we can clean these unrolled loops up.\n\t\t// See https://github.com/golang/go/issues/31586#issuecomment-487436401\n\n\t\t// Then we xor until b is less than 128 bytes.\n\t\tfor len(b) >= 128 {\n\t\t\tv := binary.LittleEndian.Uint64(b)\n\t\t\tbinary.LittleEndian.PutUint64(b, v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[8:16])\n\t\t\tbinary.LittleEndian.PutUint64(b[8:16], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[16:24])\n\t\t\tbinary.LittleEndian.PutUint64(b[16:24], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[24:32])\n\t\t\tbinary.LittleEndian.PutUint64(b[24:32], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[32:40])\n\t\t\tbinary.LittleEndian.PutUint64(b[32:40], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[40:48])\n\t\t\tbinary.LittleEndian.PutUint64(b[40:48], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[48:56])\n\t\t\tbinary.LittleEndian.PutUint64(b[48:56], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[56:64])\n\t\t\tbinary.LittleEndian.PutUint64(b[56:64], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[64:72])\n\t\t\tbinary.LittleEndian.PutUint64(b[64:72], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[72:80])\n\t\t\tbinary.LittleEndian.PutUint64(b[72:80], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[80:88])\n\t\t\tbinary.LittleEndian.PutUint64(b[80:88], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[88:96])\n\t\t\tbinary.LittleEndian.PutUint64(b[88:96], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[96:104])\n\t\t\tbinary.LittleEndian.PutUint64(b[96:104], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[104:112])\n\t\t\tbinary.LittleEndian.PutUint64(b[104:112], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[112:120])\n\t\t\tbinary.LittleEndian.PutUint64(b[112:120], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[120:128])\n\t\t\tbinary.LittleEndian.PutUint64(b[120:128], v^key64)\n\t\t\tb = b[128:]\n\t\t}\n\n\t\t// Then we xor until b is less than 64 bytes.\n\t\tfor len(b) >= 64 {\n\t\t\tv := binary.LittleEndian.Uint64(b)\n\t\t\tbinary.LittleEndian.PutUint64(b, v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[8:16])\n\t\t\tbinary.LittleEndian.PutUint64(b[8:16], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[16:24])\n\t\t\tbinary.LittleEndian.PutUint64(b[16:24], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[24:32])\n\t\t\tbinary.LittleEndian.PutUint64(b[24:32], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[32:40])\n\t\t\tbinary.LittleEndian.PutUint64(b[32:40], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[40:48])\n\t\t\tbinary.LittleEndian.PutUint64(b[40:48], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[48:56])\n\t\t\tbinary.LittleEndian.PutUint64(b[48:56], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[56:64])\n\t\t\tbinary.LittleEndian.PutUint64(b[56:64], v^key64)\n\t\t\tb = b[64:]\n\t\t}\n\n\t\t// Then we xor until b is less than 32 bytes.\n\t\tfor len(b) >= 32 {\n\t\t\tv := binary.LittleEndian.Uint64(b)\n\t\t\tbinary.LittleEndian.PutUint64(b, v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[8:16])\n\t\t\tbinary.LittleEndian.PutUint64(b[8:16], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[16:24])\n\t\t\tbinary.LittleEndian.PutUint64(b[16:24], v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[24:32])\n\t\t\tbinary.LittleEndian.PutUint64(b[24:32], v^key64)\n\t\t\tb = b[32:]\n\t\t}\n\n\t\t// Then we xor until b is less than 16 bytes.\n\t\tfor len(b) >= 16 {\n\t\t\tv := binary.LittleEndian.Uint64(b)\n\t\t\tbinary.LittleEndian.PutUint64(b, v^key64)\n\t\t\tv = binary.LittleEndian.Uint64(b[8:16])\n\t\t\tbinary.LittleEndian.PutUint64(b[8:16], v^key64)\n\t\t\tb = b[16:]\n\t\t}\n\n\t\t// Then we xor until b is less than 8 bytes.\n\t\tfor len(b) >= 8 {\n\t\t\tv := binary.LittleEndian.Uint64(b)\n\t\t\tbinary.LittleEndian.PutUint64(b, v^key64)\n\t\t\tb = b[8:]\n\t\t}\n\t}\n\n\t// Then we xor until b is less than 4 bytes.\n\tfor len(b) >= 4 {\n\t\tv := binary.LittleEndian.Uint32(b)\n\t\tbinary.LittleEndian.PutUint32(b, v^key)\n\t\tb = b[4:]\n\t}\n\n\t// xor remaining bytes.\n\tfor i := range b {\n\t\tb[i] ^= byte(key)\n\t\tkey = bits.RotateLeft32(key, -8)\n\t}\n\n\treturn key\n}\n"
        },
        {
          "name": "mask_amd64.s",
          "type": "blob",
          "size": 1.9560546875,
          "content": "#include \"textflag.h\"\n\n// func maskAsm(b *byte, len int, key uint32)\nTEXT ·maskAsm(SB), NOSPLIT, $0-28\n\t// AX = b\n\t// CX = len (left length)\n\t// SI = key (uint32)\n\t// DI = uint64(SI) | uint64(SI)<<32\n\tMOVQ b+0(FP), AX\n\tMOVQ len+8(FP), CX\n\tMOVL key+16(FP), SI\n\n\t// calculate the DI\n\t// DI = SI<<32 | SI\n\tMOVL SI, DI\n\tMOVQ DI, DX\n\tSHLQ $32, DI\n\tORQ  DX, DI\n\n\tCMPQ  CX, $15\n\tJLE   less_than_16\n\tCMPQ  CX, $63\n\tJLE   less_than_64\n\tCMPQ  CX, $128\n\tJLE   sse\n\tTESTQ $31, AX\n\tJNZ   unaligned\n\nunaligned_loop_1byte:\n\tXORB  SI, (AX)\n\tINCQ  AX\n\tDECQ  CX\n\tROLL  $24, SI\n\tTESTQ $7, AX\n\tJNZ   unaligned_loop_1byte\n\n\t// calculate DI again since SI was modified\n\t// DI = SI<<32 | SI\n\tMOVL SI, DI\n\tMOVQ DI, DX\n\tSHLQ $32, DI\n\tORQ  DX, DI\n\n\tTESTQ $31, AX\n\tJZ    sse\n\nunaligned:\n\tTESTQ $7, AX               // AND $7 & len, if not zero jump to loop_1b.\n\tJNZ   unaligned_loop_1byte\n\nunaligned_loop:\n\t// we don't need to check the CX since we know it's above 128\n\tXORQ  DI, (AX)\n\tADDQ  $8, AX\n\tSUBQ  $8, CX\n\tTESTQ $31, AX\n\tJNZ   unaligned_loop\n\tJMP   sse\n\nsse:\n\tCMPQ       CX, $0x40\n\tJL         less_than_64\n\tMOVQ       DI, X0\n\tPUNPCKLQDQ X0, X0\n\nsse_loop:\n\tMOVOU 0*16(AX), X1\n\tMOVOU 1*16(AX), X2\n\tMOVOU 2*16(AX), X3\n\tMOVOU 3*16(AX), X4\n\tPXOR  X0, X1\n\tPXOR  X0, X2\n\tPXOR  X0, X3\n\tPXOR  X0, X4\n\tMOVOU X1, 0*16(AX)\n\tMOVOU X2, 1*16(AX)\n\tMOVOU X3, 2*16(AX)\n\tMOVOU X4, 3*16(AX)\n\tADDQ  $0x40, AX\n\tSUBQ  $0x40, CX\n\tCMPQ  CX, $0x40\n\tJAE   sse_loop\n\nless_than_64:\n\tTESTQ $32, CX\n\tJZ    less_than_32\n\tXORQ  DI, (AX)\n\tXORQ  DI, 8(AX)\n\tXORQ  DI, 16(AX)\n\tXORQ  DI, 24(AX)\n\tADDQ  $32, AX\n\nless_than_32:\n\tTESTQ $16, CX\n\tJZ    less_than_16\n\tXORQ  DI, (AX)\n\tXORQ  DI, 8(AX)\n\tADDQ  $16, AX\n\nless_than_16:\n\tTESTQ $8, CX\n\tJZ    less_than_8\n\tXORQ  DI, (AX)\n\tADDQ  $8, AX\n\nless_than_8:\n\tTESTQ $4, CX\n\tJZ    less_than_4\n\tXORL  SI, (AX)\n\tADDQ  $4, AX\n\nless_than_4:\n\tTESTQ $2, CX\n\tJZ    less_than_2\n\tXORW  SI, (AX)\n\tROLL  $16, SI\n\tADDQ  $2, AX\n\nless_than_2:\n\tTESTQ $1, CX\n\tJZ    done\n\tXORB  SI, (AX)\n\tROLL  $24, SI\n\ndone:\n\tMOVL SI, ret+24(FP)\n\tRET\n"
        },
        {
          "name": "mask_arm64.s",
          "type": "blob",
          "size": 1.3798828125,
          "content": "#include \"textflag.h\"\n\n// func maskAsm(b *byte, len int, key uint32)\nTEXT ·maskAsm(SB), NOSPLIT, $0-28\n\t// R0 = b\n\t// R1 = len\n\t// R3 = key (uint32)\n\t// R2 = uint64(key)<<32 | uint64(key)\n\tMOVD  b_ptr+0(FP), R0\n\tMOVD  b_len+8(FP), R1\n\tMOVWU key+16(FP), R3\n\tMOVD  R3, R2\n\tORR   R2<<32, R2, R2\n\tVDUP  R2, V0.D2\n\tCMP   $64, R1\n\tBLT   less_than_64\n\nloop_64:\n\tVLD1   (R0), [V1.B16, V2.B16, V3.B16, V4.B16]\n\tVEOR   V1.B16, V0.B16, V1.B16\n\tVEOR   V2.B16, V0.B16, V2.B16\n\tVEOR   V3.B16, V0.B16, V3.B16\n\tVEOR   V4.B16, V0.B16, V4.B16\n\tVST1.P [V1.B16, V2.B16, V3.B16, V4.B16], 64(R0)\n\tSUBS   $64, R1\n\tCMP    $64, R1\n\tBGE    loop_64\n\nless_than_64:\n\tCBZ    R1, end\n\tTBZ    $5, R1, less_than_32\n\tVLD1   (R0), [V1.B16, V2.B16]\n\tVEOR   V1.B16, V0.B16, V1.B16\n\tVEOR   V2.B16, V0.B16, V2.B16\n\tVST1.P [V1.B16, V2.B16], 32(R0)\n\nless_than_32:\n\tTBZ   $4, R1, less_than_16\n\tLDP   (R0), (R11, R12)\n\tEOR   R11, R2, R11\n\tEOR   R12, R2, R12\n\tSTP.P (R11, R12), 16(R0)\n\nless_than_16:\n\tTBZ    $3, R1, less_than_8\n\tMOVD   (R0), R11\n\tEOR    R2, R11, R11\n\tMOVD.P R11, 8(R0)\n\nless_than_8:\n\tTBZ     $2, R1, less_than_4\n\tMOVWU   (R0), R11\n\tEORW    R2, R11, R11\n\tMOVWU.P R11, 4(R0)\n\nless_than_4:\n\tTBZ     $1, R1, less_than_2\n\tMOVHU   (R0), R11\n\tEORW    R3, R11, R11\n\tMOVHU.P R11, 2(R0)\n\tRORW    $16, R3\n\nless_than_2:\n\tTBZ     $0, R1, end\n\tMOVBU   (R0), R11\n\tEORW    R3, R11, R11\n\tMOVBU.P R11, 1(R0)\n\tRORW    $8, R3\n\nend:\n\tMOVWU R3, ret+24(FP)\n\tRET\n"
        },
        {
          "name": "mask_asm.go",
          "type": "blob",
          "size": 0.853515625,
          "content": "//go:build amd64 || arm64\n\npackage websocket\n\nfunc mask(b []byte, key uint32) uint32 {\n\t// TODO: Will enable in v1.9.0.\n\treturn maskGo(b, key)\n\t/*\n\t\tif len(b) > 0 {\n\t\t\treturn maskAsm(&b[0], len(b), key)\n\t\t}\n\t\treturn key\n\t*/\n}\n\n// @nhooyr: I am not confident that the amd64 or the arm64 implementations of this\n// function are perfect. There are almost certainly missing optimizations or\n// opportunities for simplification. I'm confident there are no bugs though.\n// For example, the arm64 implementation doesn't align memory like the amd64.\n// Or the amd64 implementation could use AVX512 instead of just AVX2.\n// The AVX2 code I had to disable anyway as it wasn't performing as expected.\n// See https://github.com/nhooyr/websocket/pull/326#issuecomment-1771138049\n//\n//go:noescape\n//lint:ignore U1000 disabled till v1.9.0\nfunc maskAsm(b *byte, len int, key uint32) uint32\n"
        },
        {
          "name": "mask_asm_test.go",
          "type": "blob",
          "size": 0.140625,
          "content": "//go:build amd64 || arm64\n\npackage websocket\n\nimport \"testing\"\n\nfunc TestMaskASM(t *testing.T) {\n\tt.Parallel()\n\n\ttestMask(t, \"maskASM\", mask)\n}\n"
        },
        {
          "name": "mask_go.go",
          "type": "blob",
          "size": 0.1181640625,
          "content": "//go:build !amd64 && !arm64 && !js\n\npackage websocket\n\nfunc mask(b []byte, key uint32) uint32 {\n\treturn maskGo(b, key)\n}\n"
        },
        {
          "name": "mask_test.go",
          "type": "blob",
          "size": 1.3896484375,
          "content": "package websocket\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n\t\"math/big\"\n\t\"math/bits\"\n\t\"testing\"\n\n\t\"github.com/coder/websocket/internal/test/assert\"\n)\n\nfunc basicMask(b []byte, key uint32) uint32 {\n\tfor i := range b {\n\t\tb[i] ^= byte(key)\n\t\tkey = bits.RotateLeft32(key, -8)\n\t}\n\treturn key\n}\n\nfunc basicMask2(b []byte, key uint32) uint32 {\n\tkeyb := binary.LittleEndian.AppendUint32(nil, key)\n\tpos := 0\n\tfor i := range b {\n\t\tb[i] ^= keyb[pos&3]\n\t\tpos++\n\t}\n\treturn bits.RotateLeft32(key, (pos&3)*-8)\n}\n\nfunc TestMask(t *testing.T) {\n\tt.Parallel()\n\n\ttestMask(t, \"basicMask\", basicMask)\n\ttestMask(t, \"maskGo\", maskGo)\n\ttestMask(t, \"basicMask2\", basicMask2)\n}\n\nfunc testMask(t *testing.T, name string, fn func(b []byte, key uint32) uint32) {\n\tt.Run(name, func(t *testing.T) {\n\t\tt.Parallel()\n\t\tfor i := 0; i < 9999; i++ {\n\t\t\tkeyb := make([]byte, 4)\n\t\t\t_, err := rand.Read(keyb)\n\t\t\tassert.Success(t, err)\n\t\t\tkey := binary.LittleEndian.Uint32(keyb)\n\n\t\t\tn, err := rand.Int(rand.Reader, big.NewInt(1<<16))\n\t\t\tassert.Success(t, err)\n\n\t\t\tb := make([]byte, 1+n.Int64())\n\t\t\t_, err = rand.Read(b)\n\t\t\tassert.Success(t, err)\n\n\t\t\tb2 := make([]byte, len(b))\n\t\t\tcopy(b2, b)\n\t\t\tb3 := make([]byte, len(b))\n\t\t\tcopy(b3, b)\n\n\t\t\tkey2 := basicMask(b2, key)\n\t\t\tkey3 := fn(b3, key)\n\n\t\t\tif key2 != key3 {\n\t\t\t\tt.Errorf(\"expected key %X but got %X\", key2, key3)\n\t\t\t}\n\t\t\tif !bytes.Equal(b2, b3) {\n\t\t\t\tt.Error(\"bad bytes\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "netconn.go",
          "type": "blob",
          "size": 5.34765625,
          "content": "package websocket\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// NetConn converts a *websocket.Conn into a net.Conn.\n//\n// It's for tunneling arbitrary protocols over WebSockets.\n// Few users of the library will need this but it's tricky to implement\n// correctly and so provided in the library.\n// See https://github.com/nhooyr/websocket/issues/100.\n//\n// Every Write to the net.Conn will correspond to a message write of\n// the given type on *websocket.Conn.\n//\n// The passed ctx bounds the lifetime of the net.Conn. If cancelled,\n// all reads and writes on the net.Conn will be cancelled.\n//\n// If a message is read that is not of the correct type, the connection\n// will be closed with StatusUnsupportedData and an error will be returned.\n//\n// Close will close the *websocket.Conn with StatusNormalClosure.\n//\n// When a deadline is hit and there is an active read or write goroutine, the\n// connection will be closed. This is different from most net.Conn implementations\n// where only the reading/writing goroutines are interrupted but the connection\n// is kept alive.\n//\n// The Addr methods will return the real addresses for connections obtained\n// from websocket.Accept. But for connections obtained from websocket.Dial, a mock net.Addr\n// will be returned that gives \"websocket\" for Network() and \"websocket/unknown-addr\" for\n// String(). This is because websocket.Dial only exposes a io.ReadWriteCloser instead of the\n// full net.Conn to us.\n//\n// When running as WASM, the Addr methods will always return the mock address described above.\n//\n// A received StatusNormalClosure or StatusGoingAway close frame will be translated to\n// io.EOF when reading.\n//\n// Furthermore, the ReadLimit is set to -1 to disable it.\nfunc NetConn(ctx context.Context, c *Conn, msgType MessageType) net.Conn {\n\tc.SetReadLimit(-1)\n\n\tnc := &netConn{\n\t\tc:       c,\n\t\tmsgType: msgType,\n\t\treadMu:  newMu(c),\n\t\twriteMu: newMu(c),\n\t}\n\n\tnc.writeCtx, nc.writeCancel = context.WithCancel(ctx)\n\tnc.readCtx, nc.readCancel = context.WithCancel(ctx)\n\n\tnc.writeTimer = time.AfterFunc(math.MaxInt64, func() {\n\t\tif !nc.writeMu.tryLock() {\n\t\t\t// If the lock cannot be acquired, then there is an\n\t\t\t// active write goroutine and so we should cancel the context.\n\t\t\tnc.writeCancel()\n\t\t\treturn\n\t\t}\n\t\tdefer nc.writeMu.unlock()\n\n\t\t// Prevents future writes from writing until the deadline is reset.\n\t\tnc.writeExpired.Store(1)\n\t})\n\tif !nc.writeTimer.Stop() {\n\t\t<-nc.writeTimer.C\n\t}\n\n\tnc.readTimer = time.AfterFunc(math.MaxInt64, func() {\n\t\tif !nc.readMu.tryLock() {\n\t\t\t// If the lock cannot be acquired, then there is an\n\t\t\t// active read goroutine and so we should cancel the context.\n\t\t\tnc.readCancel()\n\t\t\treturn\n\t\t}\n\t\tdefer nc.readMu.unlock()\n\n\t\t// Prevents future reads from reading until the deadline is reset.\n\t\tnc.readExpired.Store(1)\n\t})\n\tif !nc.readTimer.Stop() {\n\t\t<-nc.readTimer.C\n\t}\n\n\treturn nc\n}\n\ntype netConn struct {\n\tc       *Conn\n\tmsgType MessageType\n\n\twriteTimer   *time.Timer\n\twriteMu      *mu\n\twriteExpired atomic.Int64\n\twriteCtx     context.Context\n\twriteCancel  context.CancelFunc\n\n\treadTimer   *time.Timer\n\treadMu      *mu\n\treadExpired atomic.Int64\n\treadCtx     context.Context\n\treadCancel  context.CancelFunc\n\treadEOFed   bool\n\treader      io.Reader\n}\n\nvar _ net.Conn = &netConn{}\n\nfunc (nc *netConn) Close() error {\n\tnc.writeTimer.Stop()\n\tnc.writeCancel()\n\tnc.readTimer.Stop()\n\tnc.readCancel()\n\treturn nc.c.Close(StatusNormalClosure, \"\")\n}\n\nfunc (nc *netConn) Write(p []byte) (int, error) {\n\tnc.writeMu.forceLock()\n\tdefer nc.writeMu.unlock()\n\n\tif nc.writeExpired.Load() == 1 {\n\t\treturn 0, fmt.Errorf(\"failed to write: %w\", context.DeadlineExceeded)\n\t}\n\n\terr := nc.c.Write(nc.writeCtx, nc.msgType, p)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn len(p), nil\n}\n\nfunc (nc *netConn) Read(p []byte) (int, error) {\n\tnc.readMu.forceLock()\n\tdefer nc.readMu.unlock()\n\n\tfor {\n\t\tn, err := nc.read(p)\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tif n == 0 {\n\t\t\tcontinue\n\t\t}\n\t\treturn n, nil\n\t}\n}\n\nfunc (nc *netConn) read(p []byte) (int, error) {\n\tif nc.readExpired.Load() == 1 {\n\t\treturn 0, fmt.Errorf(\"failed to read: %w\", context.DeadlineExceeded)\n\t}\n\n\tif nc.readEOFed {\n\t\treturn 0, io.EOF\n\t}\n\n\tif nc.reader == nil {\n\t\ttyp, r, err := nc.c.Reader(nc.readCtx)\n\t\tif err != nil {\n\t\t\tswitch CloseStatus(err) {\n\t\t\tcase StatusNormalClosure, StatusGoingAway:\n\t\t\t\tnc.readEOFed = true\n\t\t\t\treturn 0, io.EOF\n\t\t\t}\n\t\t\treturn 0, err\n\t\t}\n\t\tif typ != nc.msgType {\n\t\t\terr := fmt.Errorf(\"unexpected frame type read (expected %v): %v\", nc.msgType, typ)\n\t\t\tnc.c.Close(StatusUnsupportedData, err.Error())\n\t\t\treturn 0, err\n\t\t}\n\t\tnc.reader = r\n\t}\n\n\tn, err := nc.reader.Read(p)\n\tif err == io.EOF {\n\t\tnc.reader = nil\n\t\terr = nil\n\t}\n\treturn n, err\n}\n\ntype websocketAddr struct {\n}\n\nfunc (a websocketAddr) Network() string {\n\treturn \"websocket\"\n}\n\nfunc (a websocketAddr) String() string {\n\treturn \"websocket/unknown-addr\"\n}\n\nfunc (nc *netConn) SetDeadline(t time.Time) error {\n\tnc.SetWriteDeadline(t)\n\tnc.SetReadDeadline(t)\n\treturn nil\n}\n\nfunc (nc *netConn) SetWriteDeadline(t time.Time) error {\n\tnc.writeExpired.Store(0)\n\tif t.IsZero() {\n\t\tnc.writeTimer.Stop()\n\t} else {\n\t\tdur := time.Until(t)\n\t\tif dur <= 0 {\n\t\t\tdur = 1\n\t\t}\n\t\tnc.writeTimer.Reset(dur)\n\t}\n\treturn nil\n}\n\nfunc (nc *netConn) SetReadDeadline(t time.Time) error {\n\tnc.readExpired.Store(0)\n\tif t.IsZero() {\n\t\tnc.readTimer.Stop()\n\t} else {\n\t\tdur := time.Until(t)\n\t\tif dur <= 0 {\n\t\t\tdur = 1\n\t\t}\n\t\tnc.readTimer.Reset(dur)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "netconn_js.go",
          "type": "blob",
          "size": 0.1669921875,
          "content": "package websocket\n\nimport \"net\"\n\nfunc (nc *netConn) RemoteAddr() net.Addr {\n\treturn websocketAddr{}\n}\n\nfunc (nc *netConn) LocalAddr() net.Addr {\n\treturn websocketAddr{}\n}\n"
        },
        {
          "name": "netconn_notjs.go",
          "type": "blob",
          "size": 0.33203125,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport \"net\"\n\nfunc (nc *netConn) RemoteAddr() net.Addr {\n\tif unc, ok := nc.c.rwc.(net.Conn); ok {\n\t\treturn unc.RemoteAddr()\n\t}\n\treturn websocketAddr{}\n}\n\nfunc (nc *netConn) LocalAddr() net.Addr {\n\tif unc, ok := nc.c.rwc.(net.Conn); ok {\n\t\treturn unc.LocalAddr()\n\t}\n\treturn websocketAddr{}\n}\n"
        },
        {
          "name": "read.go",
          "type": "blob",
          "size": 11.7451171875,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/coder/websocket/internal/errd\"\n\t\"github.com/coder/websocket/internal/util\"\n)\n\n// Reader reads from the connection until there is a WebSocket\n// data message to be read. It will handle ping, pong and close frames as appropriate.\n//\n// It returns the type of the message and an io.Reader to read it.\n// The passed context will also bound the reader.\n// Ensure you read to EOF otherwise the connection will hang.\n//\n// Call CloseRead if you do not expect any data messages from the peer.\n//\n// Only one Reader may be open at a time.\n//\n// If you need a separate timeout on the Reader call and the Read itself,\n// use time.AfterFunc to cancel the context passed in.\n// See https://github.com/nhooyr/websocket/issues/87#issue-451703332\n// Most users should not need this.\nfunc (c *Conn) Reader(ctx context.Context) (MessageType, io.Reader, error) {\n\treturn c.reader(ctx)\n}\n\n// Read is a convenience method around Reader to read a single message\n// from the connection.\nfunc (c *Conn) Read(ctx context.Context) (MessageType, []byte, error) {\n\ttyp, r, err := c.Reader(ctx)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\tb, err := io.ReadAll(r)\n\treturn typ, b, err\n}\n\n// CloseRead starts a goroutine to read from the connection until it is closed\n// or a data message is received.\n//\n// Once CloseRead is called you cannot read any messages from the connection.\n// The returned context will be cancelled when the connection is closed.\n//\n// If a data message is received, the connection will be closed with StatusPolicyViolation.\n//\n// Call CloseRead when you do not expect to read any more messages.\n// Since it actively reads from the connection, it will ensure that ping, pong and close\n// frames are responded to. This means c.Ping and c.Close will still work as expected.\n//\n// This function is idempotent.\nfunc (c *Conn) CloseRead(ctx context.Context) context.Context {\n\tc.closeReadMu.Lock()\n\tctx2 := c.closeReadCtx\n\tif ctx2 != nil {\n\t\tc.closeReadMu.Unlock()\n\t\treturn ctx2\n\t}\n\tctx, cancel := context.WithCancel(ctx)\n\tc.closeReadCtx = ctx\n\tc.closeReadDone = make(chan struct{})\n\tc.closeReadMu.Unlock()\n\n\tgo func() {\n\t\tdefer close(c.closeReadDone)\n\t\tdefer cancel()\n\t\tdefer c.close()\n\t\t_, _, err := c.Reader(ctx)\n\t\tif err == nil {\n\t\t\tc.Close(StatusPolicyViolation, \"unexpected data message\")\n\t\t}\n\t}()\n\treturn ctx\n}\n\n// SetReadLimit sets the max number of bytes to read for a single message.\n// It applies to the Reader and Read methods.\n//\n// By default, the connection has a message read limit of 32768 bytes.\n//\n// When the limit is hit, the connection will be closed with StatusMessageTooBig.\n//\n// Set to -1 to disable.\nfunc (c *Conn) SetReadLimit(n int64) {\n\tif n >= 0 {\n\t\t// We read one more byte than the limit in case\n\t\t// there is a fin frame that needs to be read.\n\t\tn++\n\t}\n\n\tc.msgReader.limitReader.limit.Store(n)\n}\n\nconst defaultReadLimit = 32768\n\nfunc newMsgReader(c *Conn) *msgReader {\n\tmr := &msgReader{\n\t\tc:   c,\n\t\tfin: true,\n\t}\n\tmr.readFunc = mr.read\n\n\tmr.limitReader = newLimitReader(c, mr.readFunc, defaultReadLimit+1)\n\treturn mr\n}\n\nfunc (mr *msgReader) resetFlate() {\n\tif mr.flateContextTakeover() {\n\t\tif mr.dict == nil {\n\t\t\tmr.dict = &slidingWindow{}\n\t\t}\n\t\tmr.dict.init(32768)\n\t}\n\tif mr.flateBufio == nil {\n\t\tmr.flateBufio = getBufioReader(mr.readFunc)\n\t}\n\n\tif mr.flateContextTakeover() {\n\t\tmr.flateReader = getFlateReader(mr.flateBufio, mr.dict.buf)\n\t} else {\n\t\tmr.flateReader = getFlateReader(mr.flateBufio, nil)\n\t}\n\tmr.limitReader.r = mr.flateReader\n\tmr.flateTail.Reset(deflateMessageTail)\n}\n\nfunc (mr *msgReader) putFlateReader() {\n\tif mr.flateReader != nil {\n\t\tputFlateReader(mr.flateReader)\n\t\tmr.flateReader = nil\n\t}\n}\n\nfunc (mr *msgReader) close() {\n\tmr.c.readMu.forceLock()\n\tmr.putFlateReader()\n\tif mr.dict != nil {\n\t\tmr.dict.close()\n\t\tmr.dict = nil\n\t}\n\tif mr.flateBufio != nil {\n\t\tputBufioReader(mr.flateBufio)\n\t}\n\n\tif mr.c.client {\n\t\tputBufioReader(mr.c.br)\n\t\tmr.c.br = nil\n\t}\n}\n\nfunc (mr *msgReader) flateContextTakeover() bool {\n\tif mr.c.client {\n\t\treturn !mr.c.copts.serverNoContextTakeover\n\t}\n\treturn !mr.c.copts.clientNoContextTakeover\n}\n\nfunc (c *Conn) readRSV1Illegal(h header) bool {\n\t// If compression is disabled, rsv1 is illegal.\n\tif !c.flate() {\n\t\treturn true\n\t}\n\t// rsv1 is only allowed on data frames beginning messages.\n\tif h.opcode != opText && h.opcode != opBinary {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (c *Conn) readLoop(ctx context.Context) (header, error) {\n\tfor {\n\t\th, err := c.readFrameHeader(ctx)\n\t\tif err != nil {\n\t\t\treturn header{}, err\n\t\t}\n\n\t\tif h.rsv1 && c.readRSV1Illegal(h) || h.rsv2 || h.rsv3 {\n\t\t\terr := fmt.Errorf(\"received header with unexpected rsv bits set: %v:%v:%v\", h.rsv1, h.rsv2, h.rsv3)\n\t\t\tc.writeError(StatusProtocolError, err)\n\t\t\treturn header{}, err\n\t\t}\n\n\t\tif !c.client && !h.masked {\n\t\t\treturn header{}, errors.New(\"received unmasked frame from client\")\n\t\t}\n\n\t\tswitch h.opcode {\n\t\tcase opClose, opPing, opPong:\n\t\t\terr = c.handleControl(ctx, h)\n\t\t\tif err != nil {\n\t\t\t\t// Pass through CloseErrors when receiving a close frame.\n\t\t\t\tif h.opcode == opClose && CloseStatus(err) != -1 {\n\t\t\t\t\treturn header{}, err\n\t\t\t\t}\n\t\t\t\treturn header{}, fmt.Errorf(\"failed to handle control frame %v: %w\", h.opcode, err)\n\t\t\t}\n\t\tcase opContinuation, opText, opBinary:\n\t\t\treturn h, nil\n\t\tdefault:\n\t\t\terr := fmt.Errorf(\"received unknown opcode %v\", h.opcode)\n\t\t\tc.writeError(StatusProtocolError, err)\n\t\t\treturn header{}, err\n\t\t}\n\t}\n}\n\n// prepareRead sets the readTimeout context and returns a done function\n// to be called after the read is done. It also returns an error if the\n// connection is closed. The reference to the error is used to assign\n// an error depending on if the connection closed or the context timed\n// out during use. Typically the referenced error is a named return\n// variable of the function calling this method.\nfunc (c *Conn) prepareRead(ctx context.Context, err *error) (func(), error) {\n\tselect {\n\tcase <-c.closed:\n\t\treturn nil, net.ErrClosed\n\tcase c.readTimeout <- ctx:\n\t}\n\n\tdone := func() {\n\t\tselect {\n\t\tcase <-c.closed:\n\t\t\tif *err != nil {\n\t\t\t\t*err = net.ErrClosed\n\t\t\t}\n\t\tcase c.readTimeout <- context.Background():\n\t\t}\n\t\tif *err != nil && ctx.Err() != nil {\n\t\t\t*err = ctx.Err()\n\t\t}\n\t}\n\n\tc.closeStateMu.Lock()\n\tcloseReceivedErr := c.closeReceivedErr\n\tc.closeStateMu.Unlock()\n\tif closeReceivedErr != nil {\n\t\tdefer done()\n\t\treturn nil, closeReceivedErr\n\t}\n\n\treturn done, nil\n}\n\nfunc (c *Conn) readFrameHeader(ctx context.Context) (_ header, err error) {\n\treadDone, err := c.prepareRead(ctx, &err)\n\tif err != nil {\n\t\treturn header{}, err\n\t}\n\tdefer readDone()\n\n\th, err := readFrameHeader(c.br, c.readHeaderBuf[:])\n\tif err != nil {\n\t\treturn header{}, err\n\t}\n\n\treturn h, nil\n}\n\nfunc (c *Conn) readFramePayload(ctx context.Context, p []byte) (_ int, err error) {\n\treadDone, err := c.prepareRead(ctx, &err)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer readDone()\n\n\tn, err := io.ReadFull(c.br, p)\n\tif err != nil {\n\t\treturn n, fmt.Errorf(\"failed to read frame payload: %w\", err)\n\t}\n\n\treturn n, err\n}\n\nfunc (c *Conn) handleControl(ctx context.Context, h header) (err error) {\n\tif h.payloadLength < 0 || h.payloadLength > maxControlPayload {\n\t\terr := fmt.Errorf(\"received control frame payload with invalid length: %d\", h.payloadLength)\n\t\tc.writeError(StatusProtocolError, err)\n\t\treturn err\n\t}\n\n\tif !h.fin {\n\t\terr := errors.New(\"received fragmented control frame\")\n\t\tc.writeError(StatusProtocolError, err)\n\t\treturn err\n\t}\n\n\tctx, cancel := context.WithTimeout(ctx, time.Second*5)\n\tdefer cancel()\n\n\tb := c.readControlBuf[:h.payloadLength]\n\t_, err = c.readFramePayload(ctx, b)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif h.masked {\n\t\tmask(b, h.maskKey)\n\t}\n\n\tswitch h.opcode {\n\tcase opPing:\n\t\treturn c.writeControl(ctx, opPong, b)\n\tcase opPong:\n\t\tc.activePingsMu.Lock()\n\t\tpong, ok := c.activePings[string(b)]\n\t\tc.activePingsMu.Unlock()\n\t\tif ok {\n\t\t\tselect {\n\t\t\tcase pong <- struct{}{}:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\t// opClose\n\n\tce, err := parseClosePayload(b)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"received invalid close payload: %w\", err)\n\t\tc.writeError(StatusProtocolError, err)\n\t\treturn err\n\t}\n\n\terr = fmt.Errorf(\"received close frame: %w\", ce)\n\tc.closeStateMu.Lock()\n\tc.closeReceivedErr = err\n\tcloseSent := c.closeSentErr != nil\n\tc.closeStateMu.Unlock()\n\n\t// Only unlock readMu if this connection is being closed becaue\n\t// c.close will try to acquire the readMu lock. We unlock for\n\t// writeClose as well because it may also call c.close.\n\tif !closeSent {\n\t\tc.readMu.unlock()\n\t\t_ = c.writeClose(ce.Code, ce.Reason)\n\t}\n\tif !c.casClosing() {\n\t\tc.readMu.unlock()\n\t\t_ = c.close()\n\t}\n\treturn err\n}\n\nfunc (c *Conn) reader(ctx context.Context) (_ MessageType, _ io.Reader, err error) {\n\tdefer errd.Wrap(&err, \"failed to get reader\")\n\n\terr = c.readMu.lock(ctx)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tdefer c.readMu.unlock()\n\n\tif !c.msgReader.fin {\n\t\treturn 0, nil, errors.New(\"previous message not read to completion\")\n\t}\n\n\th, err := c.readLoop(ctx)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\tif h.opcode == opContinuation {\n\t\terr := errors.New(\"received continuation frame without text or binary frame\")\n\t\tc.writeError(StatusProtocolError, err)\n\t\treturn 0, nil, err\n\t}\n\n\tc.msgReader.reset(ctx, h)\n\n\treturn MessageType(h.opcode), c.msgReader, nil\n}\n\ntype msgReader struct {\n\tc *Conn\n\n\tctx         context.Context\n\tflate       bool\n\tflateReader io.Reader\n\tflateBufio  *bufio.Reader\n\tflateTail   strings.Reader\n\tlimitReader *limitReader\n\tdict        *slidingWindow\n\n\tfin           bool\n\tpayloadLength int64\n\tmaskKey       uint32\n\n\t// util.ReaderFunc(mr.Read) to avoid continuous allocations.\n\treadFunc util.ReaderFunc\n}\n\nfunc (mr *msgReader) reset(ctx context.Context, h header) {\n\tmr.ctx = ctx\n\tmr.flate = h.rsv1\n\tmr.limitReader.reset(mr.readFunc)\n\n\tif mr.flate {\n\t\tmr.resetFlate()\n\t}\n\n\tmr.setFrame(h)\n}\n\nfunc (mr *msgReader) setFrame(h header) {\n\tmr.fin = h.fin\n\tmr.payloadLength = h.payloadLength\n\tmr.maskKey = h.maskKey\n}\n\nfunc (mr *msgReader) Read(p []byte) (n int, err error) {\n\terr = mr.c.readMu.lock(mr.ctx)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to read: %w\", err)\n\t}\n\tdefer mr.c.readMu.unlock()\n\n\tn, err = mr.limitReader.Read(p)\n\tif mr.flate && mr.flateContextTakeover() {\n\t\tp = p[:n]\n\t\tmr.dict.write(p)\n\t}\n\tif errors.Is(err, io.EOF) || errors.Is(err, io.ErrUnexpectedEOF) && mr.fin && mr.flate {\n\t\tmr.putFlateReader()\n\t\treturn n, io.EOF\n\t}\n\tif err != nil {\n\t\treturn n, fmt.Errorf(\"failed to read: %w\", err)\n\t}\n\treturn n, nil\n}\n\nfunc (mr *msgReader) read(p []byte) (int, error) {\n\tfor {\n\t\tif mr.payloadLength == 0 {\n\t\t\tif mr.fin {\n\t\t\t\tif mr.flate {\n\t\t\t\t\treturn mr.flateTail.Read(p)\n\t\t\t\t}\n\t\t\t\treturn 0, io.EOF\n\t\t\t}\n\n\t\t\th, err := mr.c.readLoop(mr.ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif h.opcode != opContinuation {\n\t\t\t\terr := errors.New(\"received new data message without finishing the previous message\")\n\t\t\t\tmr.c.writeError(StatusProtocolError, err)\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tmr.setFrame(h)\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif int64(len(p)) > mr.payloadLength {\n\t\t\tp = p[:mr.payloadLength]\n\t\t}\n\n\t\tn, err := mr.c.readFramePayload(mr.ctx, p)\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\n\t\tmr.payloadLength -= int64(n)\n\n\t\tif !mr.c.client {\n\t\t\tmr.maskKey = mask(p, mr.maskKey)\n\t\t}\n\n\t\treturn n, nil\n\t}\n}\n\ntype limitReader struct {\n\tc     *Conn\n\tr     io.Reader\n\tlimit atomic.Int64\n\tn     int64\n}\n\nfunc newLimitReader(c *Conn, r io.Reader, limit int64) *limitReader {\n\tlr := &limitReader{\n\t\tc: c,\n\t}\n\tlr.limit.Store(limit)\n\tlr.reset(r)\n\treturn lr\n}\n\nfunc (lr *limitReader) reset(r io.Reader) {\n\tlr.n = lr.limit.Load()\n\tlr.r = r\n}\n\nfunc (lr *limitReader) Read(p []byte) (int, error) {\n\tif lr.n < 0 {\n\t\treturn lr.r.Read(p)\n\t}\n\n\tif lr.n == 0 {\n\t\terr := fmt.Errorf(\"read limited at %v bytes\", lr.limit.Load())\n\t\tlr.c.writeError(StatusMessageTooBig, err)\n\t\treturn 0, err\n\t}\n\n\tif int64(len(p)) > lr.n {\n\t\tp = p[:lr.n]\n\t}\n\tn, err := lr.r.Read(p)\n\tlr.n -= int64(n)\n\tif lr.n < 0 {\n\t\tlr.n = 0\n\t}\n\treturn n, err\n}\n"
        },
        {
          "name": "stringer.go",
          "type": "blob",
          "size": 2.8740234375,
          "content": "// Code generated by \"stringer -type=opcode,MessageType,StatusCode -output=stringer.go\"; DO NOT EDIT.\n\npackage websocket\n\nimport \"strconv\"\n\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[opContinuation-0]\n\t_ = x[opText-1]\n\t_ = x[opBinary-2]\n\t_ = x[opClose-8]\n\t_ = x[opPing-9]\n\t_ = x[opPong-10]\n}\n\nconst (\n\t_opcode_name_0 = \"opContinuationopTextopBinary\"\n\t_opcode_name_1 = \"opCloseopPingopPong\"\n)\n\nvar (\n\t_opcode_index_0 = [...]uint8{0, 14, 20, 28}\n\t_opcode_index_1 = [...]uint8{0, 7, 13, 19}\n)\n\nfunc (i opcode) String() string {\n\tswitch {\n\tcase 0 <= i && i <= 2:\n\t\treturn _opcode_name_0[_opcode_index_0[i]:_opcode_index_0[i+1]]\n\tcase 8 <= i && i <= 10:\n\t\ti -= 8\n\t\treturn _opcode_name_1[_opcode_index_1[i]:_opcode_index_1[i+1]]\n\tdefault:\n\t\treturn \"opcode(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n}\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[MessageText-1]\n\t_ = x[MessageBinary-2]\n}\n\nconst _MessageType_name = \"MessageTextMessageBinary\"\n\nvar _MessageType_index = [...]uint8{0, 11, 24}\n\nfunc (i MessageType) String() string {\n\ti -= 1\n\tif i < 0 || i >= MessageType(len(_MessageType_index)-1) {\n\t\treturn \"MessageType(\" + strconv.FormatInt(int64(i+1), 10) + \")\"\n\t}\n\treturn _MessageType_name[_MessageType_index[i]:_MessageType_index[i+1]]\n}\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[StatusNormalClosure-1000]\n\t_ = x[StatusGoingAway-1001]\n\t_ = x[StatusProtocolError-1002]\n\t_ = x[StatusUnsupportedData-1003]\n\t_ = x[statusReserved-1004]\n\t_ = x[StatusNoStatusRcvd-1005]\n\t_ = x[StatusAbnormalClosure-1006]\n\t_ = x[StatusInvalidFramePayloadData-1007]\n\t_ = x[StatusPolicyViolation-1008]\n\t_ = x[StatusMessageTooBig-1009]\n\t_ = x[StatusMandatoryExtension-1010]\n\t_ = x[StatusInternalError-1011]\n\t_ = x[StatusServiceRestart-1012]\n\t_ = x[StatusTryAgainLater-1013]\n\t_ = x[StatusBadGateway-1014]\n\t_ = x[StatusTLSHandshake-1015]\n}\n\nconst _StatusCode_name = \"StatusNormalClosureStatusGoingAwayStatusProtocolErrorStatusUnsupportedDatastatusReservedStatusNoStatusRcvdStatusAbnormalClosureStatusInvalidFramePayloadDataStatusPolicyViolationStatusMessageTooBigStatusMandatoryExtensionStatusInternalErrorStatusServiceRestartStatusTryAgainLaterStatusBadGatewayStatusTLSHandshake\"\n\nvar _StatusCode_index = [...]uint16{0, 19, 34, 53, 74, 88, 106, 127, 156, 177, 196, 220, 239, 259, 278, 294, 312}\n\nfunc (i StatusCode) String() string {\n\ti -= 1000\n\tif i < 0 || i >= StatusCode(len(_StatusCode_index)-1) {\n\t\treturn \"StatusCode(\" + strconv.FormatInt(int64(i+1000), 10) + \")\"\n\t}\n\treturn _StatusCode_name[_StatusCode_index[i]:_StatusCode_index[i+1]]\n}\n"
        },
        {
          "name": "write.go",
          "type": "blob",
          "size": 7.837890625,
          "content": "//go:build !js\n// +build !js\n\npackage websocket\n\nimport (\n\t\"bufio\"\n\t\"compress/flate\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/coder/websocket/internal/errd\"\n\t\"github.com/coder/websocket/internal/util\"\n)\n\n// Writer returns a writer bounded by the context that will write\n// a WebSocket message of type dataType to the connection.\n//\n// You must close the writer once you have written the entire message.\n//\n// Only one writer can be open at a time, multiple calls will block until the previous writer\n// is closed.\nfunc (c *Conn) Writer(ctx context.Context, typ MessageType) (io.WriteCloser, error) {\n\tw, err := c.writer(ctx, typ)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get writer: %w\", err)\n\t}\n\treturn w, nil\n}\n\n// Write writes a message to the connection.\n//\n// See the Writer method if you want to stream a message.\n//\n// If compression is disabled or the compression threshold is not met, then it\n// will write the message in a single frame.\nfunc (c *Conn) Write(ctx context.Context, typ MessageType, p []byte) error {\n\t_, err := c.write(ctx, typ, p)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write msg: %w\", err)\n\t}\n\treturn nil\n}\n\ntype msgWriter struct {\n\tc *Conn\n\n\tmu      *mu\n\twriteMu *mu\n\tclosed  bool\n\n\tctx    context.Context\n\topcode opcode\n\tflate  bool\n\n\ttrimWriter  *trimLastFourBytesWriter\n\tflateWriter *flate.Writer\n}\n\nfunc newMsgWriter(c *Conn) *msgWriter {\n\tmw := &msgWriter{\n\t\tc:       c,\n\t\tmu:      newMu(c),\n\t\twriteMu: newMu(c),\n\t}\n\treturn mw\n}\n\nfunc (mw *msgWriter) ensureFlate() {\n\tif mw.trimWriter == nil {\n\t\tmw.trimWriter = &trimLastFourBytesWriter{\n\t\t\tw: util.WriterFunc(mw.write),\n\t\t}\n\t}\n\n\tif mw.flateWriter == nil {\n\t\tmw.flateWriter = getFlateWriter(mw.trimWriter)\n\t}\n\tmw.flate = true\n}\n\nfunc (mw *msgWriter) flateContextTakeover() bool {\n\tif mw.c.client {\n\t\treturn !mw.c.copts.clientNoContextTakeover\n\t}\n\treturn !mw.c.copts.serverNoContextTakeover\n}\n\nfunc (c *Conn) writer(ctx context.Context, typ MessageType) (io.WriteCloser, error) {\n\terr := c.msgWriter.reset(ctx, typ)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.msgWriter, nil\n}\n\nfunc (c *Conn) write(ctx context.Context, typ MessageType, p []byte) (int, error) {\n\tmw, err := c.writer(ctx, typ)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif !c.flate() {\n\t\tdefer c.msgWriter.mu.unlock()\n\t\treturn c.writeFrame(ctx, true, false, c.msgWriter.opcode, p)\n\t}\n\n\tn, err := mw.Write(p)\n\tif err != nil {\n\t\treturn n, err\n\t}\n\n\terr = mw.Close()\n\treturn n, err\n}\n\nfunc (mw *msgWriter) reset(ctx context.Context, typ MessageType) error {\n\terr := mw.mu.lock(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmw.ctx = ctx\n\tmw.opcode = opcode(typ)\n\tmw.flate = false\n\tmw.closed = false\n\n\tmw.trimWriter.reset()\n\n\treturn nil\n}\n\nfunc (mw *msgWriter) putFlateWriter() {\n\tif mw.flateWriter != nil {\n\t\tputFlateWriter(mw.flateWriter)\n\t\tmw.flateWriter = nil\n\t}\n}\n\n// Write writes the given bytes to the WebSocket connection.\nfunc (mw *msgWriter) Write(p []byte) (_ int, err error) {\n\terr = mw.writeMu.lock(mw.ctx)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to write: %w\", err)\n\t}\n\tdefer mw.writeMu.unlock()\n\n\tif mw.closed {\n\t\treturn 0, errors.New(\"cannot use closed writer\")\n\t}\n\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"failed to write: %w\", err)\n\t\t}\n\t}()\n\n\tif mw.c.flate() {\n\t\t// Only enables flate if the length crosses the\n\t\t// threshold on the first frame\n\t\tif mw.opcode != opContinuation && len(p) >= mw.c.flateThreshold {\n\t\t\tmw.ensureFlate()\n\t\t}\n\t}\n\n\tif mw.flate {\n\t\treturn mw.flateWriter.Write(p)\n\t}\n\n\treturn mw.write(p)\n}\n\nfunc (mw *msgWriter) write(p []byte) (int, error) {\n\tn, err := mw.c.writeFrame(mw.ctx, false, mw.flate, mw.opcode, p)\n\tif err != nil {\n\t\treturn n, fmt.Errorf(\"failed to write data frame: %w\", err)\n\t}\n\tmw.opcode = opContinuation\n\treturn n, nil\n}\n\n// Close flushes the frame to the connection.\nfunc (mw *msgWriter) Close() (err error) {\n\tdefer errd.Wrap(&err, \"failed to close writer\")\n\n\terr = mw.writeMu.lock(mw.ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer mw.writeMu.unlock()\n\n\tif mw.closed {\n\t\treturn errors.New(\"writer already closed\")\n\t}\n\tmw.closed = true\n\n\tif mw.flate {\n\t\terr = mw.flateWriter.Flush()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to flush flate: %w\", err)\n\t\t}\n\t}\n\n\t_, err = mw.c.writeFrame(mw.ctx, true, mw.flate, mw.opcode, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write fin frame: %w\", err)\n\t}\n\n\tif mw.flate && !mw.flateContextTakeover() {\n\t\tmw.putFlateWriter()\n\t}\n\tmw.mu.unlock()\n\treturn nil\n}\n\nfunc (mw *msgWriter) close() {\n\tif mw.c.client {\n\t\tmw.c.writeFrameMu.forceLock()\n\t\tputBufioWriter(mw.c.bw)\n\t}\n\n\tmw.writeMu.forceLock()\n\tmw.putFlateWriter()\n}\n\nfunc (c *Conn) writeControl(ctx context.Context, opcode opcode, p []byte) error {\n\tctx, cancel := context.WithTimeout(ctx, time.Second*5)\n\tdefer cancel()\n\n\t_, err := c.writeFrame(ctx, true, false, opcode, p)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write control frame %v: %w\", opcode, err)\n\t}\n\treturn nil\n}\n\n// writeFrame handles all writes to the connection.\nfunc (c *Conn) writeFrame(ctx context.Context, fin bool, flate bool, opcode opcode, p []byte) (_ int, err error) {\n\terr = c.writeFrameMu.lock(ctx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer c.writeFrameMu.unlock()\n\n\tdefer func() {\n\t\tif c.isClosed() && opcode == opClose {\n\t\t\terr = nil\n\t\t}\n\t\tif err != nil {\n\t\t\tif ctx.Err() != nil {\n\t\t\t\terr = ctx.Err()\n\t\t\t} else if c.isClosed() {\n\t\t\t\terr = net.ErrClosed\n\t\t\t}\n\t\t\terr = fmt.Errorf(\"failed to write frame: %w\", err)\n\t\t}\n\t}()\n\n\tc.closeStateMu.Lock()\n\tcloseSentErr := c.closeSentErr\n\tc.closeStateMu.Unlock()\n\tif closeSentErr != nil {\n\t\treturn 0, net.ErrClosed\n\t}\n\n\tselect {\n\tcase <-c.closed:\n\t\treturn 0, net.ErrClosed\n\tcase c.writeTimeout <- ctx:\n\t}\n\tdefer func() {\n\t\tselect {\n\t\tcase <-c.closed:\n\t\tcase c.writeTimeout <- context.Background():\n\t\t}\n\t}()\n\n\tc.writeHeader.fin = fin\n\tc.writeHeader.opcode = opcode\n\tc.writeHeader.payloadLength = int64(len(p))\n\n\tif c.client {\n\t\tc.writeHeader.masked = true\n\t\t_, err = io.ReadFull(rand.Reader, c.writeHeaderBuf[:4])\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to generate masking key: %w\", err)\n\t\t}\n\t\tc.writeHeader.maskKey = binary.LittleEndian.Uint32(c.writeHeaderBuf[:])\n\t}\n\n\tc.writeHeader.rsv1 = false\n\tif flate && (opcode == opText || opcode == opBinary) {\n\t\tc.writeHeader.rsv1 = true\n\t}\n\n\terr = writeFrameHeader(c.writeHeader, c.bw, c.writeHeaderBuf[:])\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tn, err := c.writeFramePayload(p)\n\tif err != nil {\n\t\treturn n, err\n\t}\n\n\tif c.writeHeader.fin {\n\t\terr = c.bw.Flush()\n\t\tif err != nil {\n\t\t\treturn n, fmt.Errorf(\"failed to flush: %w\", err)\n\t\t}\n\t}\n\n\tif opcode == opClose {\n\t\tc.closeStateMu.Lock()\n\t\tc.closeSentErr = fmt.Errorf(\"sent close frame: %w\", net.ErrClosed)\n\t\tcloseReceived := c.closeReceivedErr != nil\n\t\tc.closeStateMu.Unlock()\n\n\t\tif closeReceived && !c.casClosing() {\n\t\t\tc.writeFrameMu.unlock()\n\t\t\t_ = c.close()\n\t\t}\n\t}\n\n\treturn n, nil\n}\n\nfunc (c *Conn) writeFramePayload(p []byte) (n int, err error) {\n\tdefer errd.Wrap(&err, \"failed to write frame payload\")\n\n\tif !c.writeHeader.masked {\n\t\treturn c.bw.Write(p)\n\t}\n\n\tmaskKey := c.writeHeader.maskKey\n\tfor len(p) > 0 {\n\t\t// If the buffer is full, we need to flush.\n\t\tif c.bw.Available() == 0 {\n\t\t\terr = c.bw.Flush()\n\t\t\tif err != nil {\n\t\t\t\treturn n, err\n\t\t\t}\n\t\t}\n\n\t\t// Start of next write in the buffer.\n\t\ti := c.bw.Buffered()\n\n\t\tj := len(p)\n\t\tif j > c.bw.Available() {\n\t\t\tj = c.bw.Available()\n\t\t}\n\n\t\t_, err := c.bw.Write(p[:j])\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\n\t\tmaskKey = mask(c.writeBuf[i:c.bw.Buffered()], maskKey)\n\n\t\tp = p[j:]\n\t\tn += j\n\t}\n\n\treturn n, nil\n}\n\n// extractBufioWriterBuf grabs the []byte backing a *bufio.Writer\n// and returns it.\nfunc extractBufioWriterBuf(bw *bufio.Writer, w io.Writer) []byte {\n\tvar writeBuf []byte\n\tbw.Reset(util.WriterFunc(func(p2 []byte) (int, error) {\n\t\twriteBuf = p2[:cap(p2)]\n\t\treturn len(p2), nil\n\t}))\n\n\tbw.WriteByte(0)\n\tbw.Flush()\n\n\tbw.Reset(w)\n\n\treturn writeBuf\n}\n\nfunc (c *Conn) writeError(code StatusCode, err error) {\n\tc.writeClose(code, err.Error())\n}\n"
        },
        {
          "name": "ws_js.go",
          "type": "blob",
          "size": 14.64453125,
          "content": "package websocket // import \"github.com/coder/websocket\"\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall/js\"\n\n\t\"github.com/coder/websocket/internal/bpool\"\n\t\"github.com/coder/websocket/internal/wsjs\"\n)\n\n// opcode represents a WebSocket opcode.\ntype opcode int\n\n// https://tools.ietf.org/html/rfc6455#section-11.8.\nconst (\n\topContinuation opcode = iota\n\topText\n\topBinary\n\t// 3 - 7 are reserved for further non-control frames.\n\t_\n\t_\n\t_\n\t_\n\t_\n\topClose\n\topPing\n\topPong\n\t// 11-16 are reserved for further control frames.\n)\n\n// Conn provides a wrapper around the browser WebSocket API.\ntype Conn struct {\n\tnoCopy noCopy\n\tws     wsjs.WebSocket\n\n\t// read limit for a message in bytes.\n\tmsgReadLimit atomic.Int64\n\n\tcloseReadMu  sync.Mutex\n\tcloseReadCtx context.Context\n\n\tclosingMu     sync.Mutex\n\tcloseOnce     sync.Once\n\tclosed        chan struct{}\n\tcloseErrOnce  sync.Once\n\tcloseErr      error\n\tcloseWasClean bool\n\n\treleaseOnClose   func()\n\treleaseOnError   func()\n\treleaseOnMessage func()\n\n\treadSignal chan struct{}\n\treadBufMu  sync.Mutex\n\treadBuf    []wsjs.MessageEvent\n}\n\nfunc (c *Conn) close(err error, wasClean bool) {\n\tc.closeOnce.Do(func() {\n\t\truntime.SetFinalizer(c, nil)\n\n\t\tif !wasClean {\n\t\t\terr = fmt.Errorf(\"unclean connection close: %w\", err)\n\t\t}\n\t\tc.setCloseErr(err)\n\t\tc.closeWasClean = wasClean\n\t\tclose(c.closed)\n\t})\n}\n\nfunc (c *Conn) init() {\n\tc.closed = make(chan struct{})\n\tc.readSignal = make(chan struct{}, 1)\n\n\tc.msgReadLimit.Store(32768)\n\n\tc.releaseOnClose = c.ws.OnClose(func(e wsjs.CloseEvent) {\n\t\terr := CloseError{\n\t\t\tCode:   StatusCode(e.Code),\n\t\t\tReason: e.Reason,\n\t\t}\n\t\t// We do not know if we sent or received this close as\n\t\t// its possible the browser triggered it without us\n\t\t// explicitly sending it.\n\t\tc.close(err, e.WasClean)\n\n\t\tc.releaseOnClose()\n\t\tc.releaseOnError()\n\t\tc.releaseOnMessage()\n\t})\n\n\tc.releaseOnError = c.ws.OnError(func(v js.Value) {\n\t\tc.setCloseErr(errors.New(v.Get(\"message\").String()))\n\t\tc.closeWithInternal()\n\t})\n\n\tc.releaseOnMessage = c.ws.OnMessage(func(e wsjs.MessageEvent) {\n\t\tc.readBufMu.Lock()\n\t\tdefer c.readBufMu.Unlock()\n\n\t\tc.readBuf = append(c.readBuf, e)\n\n\t\t// Lets the read goroutine know there is definitely something in readBuf.\n\t\tselect {\n\t\tcase c.readSignal <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t})\n\n\truntime.SetFinalizer(c, func(c *Conn) {\n\t\tc.setCloseErr(errors.New(\"connection garbage collected\"))\n\t\tc.closeWithInternal()\n\t})\n}\n\nfunc (c *Conn) closeWithInternal() {\n\tc.Close(StatusInternalError, \"something went wrong\")\n}\n\n// Read attempts to read a message from the connection.\n// The maximum time spent waiting is bounded by the context.\nfunc (c *Conn) Read(ctx context.Context) (MessageType, []byte, error) {\n\tc.closeReadMu.Lock()\n\tclosedRead := c.closeReadCtx != nil\n\tc.closeReadMu.Unlock()\n\tif closedRead {\n\t\treturn 0, nil, errors.New(\"WebSocket connection read closed\")\n\t}\n\n\ttyp, p, err := c.read(ctx)\n\tif err != nil {\n\t\treturn 0, nil, fmt.Errorf(\"failed to read: %w\", err)\n\t}\n\treadLimit := c.msgReadLimit.Load()\n\tif readLimit >= 0 && int64(len(p)) > readLimit {\n\t\terr := fmt.Errorf(\"read limited at %v bytes\", c.msgReadLimit.Load())\n\t\tc.Close(StatusMessageTooBig, err.Error())\n\t\treturn 0, nil, err\n\t}\n\treturn typ, p, nil\n}\n\nfunc (c *Conn) read(ctx context.Context) (MessageType, []byte, error) {\n\tselect {\n\tcase <-ctx.Done():\n\t\tc.Close(StatusPolicyViolation, \"read timed out\")\n\t\treturn 0, nil, ctx.Err()\n\tcase <-c.readSignal:\n\tcase <-c.closed:\n\t\treturn 0, nil, net.ErrClosed\n\t}\n\n\tc.readBufMu.Lock()\n\tdefer c.readBufMu.Unlock()\n\n\tme := c.readBuf[0]\n\t// We copy the messages forward and decrease the size\n\t// of the slice to avoid reallocating.\n\tcopy(c.readBuf, c.readBuf[1:])\n\tc.readBuf = c.readBuf[:len(c.readBuf)-1]\n\n\tif len(c.readBuf) > 0 {\n\t\t// Next time we read, we'll grab the message.\n\t\tselect {\n\t\tcase c.readSignal <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\n\tswitch p := me.Data.(type) {\n\tcase string:\n\t\treturn MessageText, []byte(p), nil\n\tcase []byte:\n\t\treturn MessageBinary, p, nil\n\tdefault:\n\t\tpanic(\"websocket: unexpected data type from wsjs OnMessage: \" + reflect.TypeOf(me.Data).String())\n\t}\n}\n\n// Ping is mocked out for Wasm.\nfunc (c *Conn) Ping(ctx context.Context) error {\n\treturn nil\n}\n\n// Write writes a message of the given type to the connection.\n// Always non blocking.\nfunc (c *Conn) Write(ctx context.Context, typ MessageType, p []byte) error {\n\terr := c.write(ctx, typ, p)\n\tif err != nil {\n\t\t// Have to ensure the WebSocket is closed after a write error\n\t\t// to match the Go API. It can only error if the message type\n\t\t// is unexpected or the passed bytes contain invalid UTF-8 for\n\t\t// MessageText.\n\t\terr := fmt.Errorf(\"failed to write: %w\", err)\n\t\tc.setCloseErr(err)\n\t\tc.closeWithInternal()\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *Conn) write(ctx context.Context, typ MessageType, p []byte) error {\n\tif c.isClosed() {\n\t\treturn net.ErrClosed\n\t}\n\tswitch typ {\n\tcase MessageBinary:\n\t\treturn c.ws.SendBytes(p)\n\tcase MessageText:\n\t\treturn c.ws.SendText(string(p))\n\tdefault:\n\t\treturn fmt.Errorf(\"unexpected message type: %v\", typ)\n\t}\n}\n\n// Close closes the WebSocket with the given code and reason.\n// It will wait until the peer responds with a close frame\n// or the connection is closed.\n// It thus performs the full WebSocket close handshake.\nfunc (c *Conn) Close(code StatusCode, reason string) error {\n\terr := c.exportedClose(code, reason)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to close WebSocket: %w\", err)\n\t}\n\treturn nil\n}\n\n// CloseNow closes the WebSocket connection without attempting a close handshake.\n// Use when you do not want the overhead of the close handshake.\n//\n// note: No different from Close(StatusGoingAway, \"\") in WASM as there is no way to close\n// a WebSocket without the close handshake.\nfunc (c *Conn) CloseNow() error {\n\treturn c.Close(StatusGoingAway, \"\")\n}\n\nfunc (c *Conn) exportedClose(code StatusCode, reason string) error {\n\tc.closingMu.Lock()\n\tdefer c.closingMu.Unlock()\n\n\tif c.isClosed() {\n\t\treturn net.ErrClosed\n\t}\n\n\tce := fmt.Errorf(\"sent close: %w\", CloseError{\n\t\tCode:   code,\n\t\tReason: reason,\n\t})\n\n\tc.setCloseErr(ce)\n\terr := c.ws.Close(int(code), reason)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t<-c.closed\n\tif !c.closeWasClean {\n\t\treturn c.closeErr\n\t}\n\treturn nil\n}\n\n// Subprotocol returns the negotiated subprotocol.\n// An empty string means the default protocol.\nfunc (c *Conn) Subprotocol() string {\n\treturn c.ws.Subprotocol()\n}\n\n// DialOptions represents the options available to pass to Dial.\ntype DialOptions struct {\n\t// Subprotocols lists the subprotocols to negotiate with the server.\n\tSubprotocols []string\n}\n\n// Dial creates a new WebSocket connection to the given url with the given options.\n// The passed context bounds the maximum time spent waiting for the connection to open.\n// The returned *http.Response is always nil or a mock. It's only in the signature\n// to match the core API.\nfunc Dial(ctx context.Context, url string, opts *DialOptions) (*Conn, *http.Response, error) {\n\tc, resp, err := dial(ctx, url, opts)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to WebSocket dial %q: %w\", url, err)\n\t}\n\treturn c, resp, nil\n}\n\nfunc dial(ctx context.Context, url string, opts *DialOptions) (*Conn, *http.Response, error) {\n\tif opts == nil {\n\t\topts = &DialOptions{}\n\t}\n\n\turl = strings.Replace(url, \"http://\", \"ws://\", 1)\n\turl = strings.Replace(url, \"https://\", \"wss://\", 1)\n\n\tws, err := wsjs.New(url, opts.Subprotocols)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := &Conn{\n\t\tws: ws,\n\t}\n\tc.init()\n\n\topench := make(chan struct{})\n\treleaseOpen := ws.OnOpen(func(e js.Value) {\n\t\tclose(opench)\n\t})\n\tdefer releaseOpen()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tc.Close(StatusPolicyViolation, \"dial timed out\")\n\t\treturn nil, nil, ctx.Err()\n\tcase <-opench:\n\t\treturn c, &http.Response{\n\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t}, nil\n\tcase <-c.closed:\n\t\treturn nil, nil, net.ErrClosed\n\t}\n}\n\n// Reader attempts to read a message from the connection.\n// The maximum time spent waiting is bounded by the context.\nfunc (c *Conn) Reader(ctx context.Context) (MessageType, io.Reader, error) {\n\ttyp, p, err := c.Read(ctx)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\treturn typ, bytes.NewReader(p), nil\n}\n\n// Writer returns a writer to write a WebSocket data message to the connection.\n// It buffers the entire message in memory and then sends it when the writer\n// is closed.\nfunc (c *Conn) Writer(ctx context.Context, typ MessageType) (io.WriteCloser, error) {\n\treturn &writer{\n\t\tc:   c,\n\t\tctx: ctx,\n\t\ttyp: typ,\n\t\tb:   bpool.Get(),\n\t}, nil\n}\n\ntype writer struct {\n\tclosed bool\n\n\tc   *Conn\n\tctx context.Context\n\ttyp MessageType\n\n\tb *bytes.Buffer\n}\n\nfunc (w *writer) Write(p []byte) (int, error) {\n\tif w.closed {\n\t\treturn 0, errors.New(\"cannot write to closed writer\")\n\t}\n\tn, err := w.b.Write(p)\n\tif err != nil {\n\t\treturn n, fmt.Errorf(\"failed to write message: %w\", err)\n\t}\n\treturn n, nil\n}\n\nfunc (w *writer) Close() error {\n\tif w.closed {\n\t\treturn errors.New(\"cannot close closed writer\")\n\t}\n\tw.closed = true\n\tdefer bpool.Put(w.b)\n\n\terr := w.c.Write(w.ctx, w.typ, w.b.Bytes())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to close writer: %w\", err)\n\t}\n\treturn nil\n}\n\n// CloseRead implements *Conn.CloseRead for wasm.\nfunc (c *Conn) CloseRead(ctx context.Context) context.Context {\n\tc.closeReadMu.Lock()\n\tctx2 := c.closeReadCtx\n\tif ctx2 != nil {\n\t\tc.closeReadMu.Unlock()\n\t\treturn ctx2\n\t}\n\tctx, cancel := context.WithCancel(ctx)\n\tc.closeReadCtx = ctx\n\tc.closeReadMu.Unlock()\n\n\tgo func() {\n\t\tdefer cancel()\n\t\tdefer c.CloseNow()\n\t\t_, _, err := c.read(ctx)\n\t\tif err != nil {\n\t\t\tc.Close(StatusPolicyViolation, \"unexpected data message\")\n\t\t}\n\t}()\n\treturn ctx\n}\n\n// SetReadLimit implements *Conn.SetReadLimit for wasm.\nfunc (c *Conn) SetReadLimit(n int64) {\n\tc.msgReadLimit.Store(n)\n}\n\nfunc (c *Conn) setCloseErr(err error) {\n\tc.closeErrOnce.Do(func() {\n\t\tc.closeErr = fmt.Errorf(\"WebSocket closed: %w\", err)\n\t})\n}\n\nfunc (c *Conn) isClosed() bool {\n\tselect {\n\tcase <-c.closed:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// AcceptOptions represents Accept's options.\ntype AcceptOptions struct {\n\tSubprotocols         []string\n\tInsecureSkipVerify   bool\n\tOriginPatterns       []string\n\tCompressionMode      CompressionMode\n\tCompressionThreshold int\n}\n\n// Accept is stubbed out for Wasm.\nfunc Accept(w http.ResponseWriter, r *http.Request, opts *AcceptOptions) (*Conn, error) {\n\treturn nil, errors.New(\"unimplemented\")\n}\n\n// StatusCode represents a WebSocket status code.\n// https://tools.ietf.org/html/rfc6455#section-7.4\ntype StatusCode int\n\n// https://www.iana.org/assignments/websocket/websocket.xhtml#close-code-number\n//\n// These are only the status codes defined by the protocol.\n//\n// You can define custom codes in the 3000-4999 range.\n// The 3000-3999 range is reserved for use by libraries, frameworks and applications.\n// The 4000-4999 range is reserved for private use.\nconst (\n\tStatusNormalClosure   StatusCode = 1000\n\tStatusGoingAway       StatusCode = 1001\n\tStatusProtocolError   StatusCode = 1002\n\tStatusUnsupportedData StatusCode = 1003\n\n\t// 1004 is reserved and so unexported.\n\tstatusReserved StatusCode = 1004\n\n\t// StatusNoStatusRcvd cannot be sent in a close message.\n\t// It is reserved for when a close message is received without\n\t// a status code.\n\tStatusNoStatusRcvd StatusCode = 1005\n\n\t// StatusAbnormalClosure is exported for use only with Wasm.\n\t// In non Wasm Go, the returned error will indicate whether the\n\t// connection was closed abnormally.\n\tStatusAbnormalClosure StatusCode = 1006\n\n\tStatusInvalidFramePayloadData StatusCode = 1007\n\tStatusPolicyViolation         StatusCode = 1008\n\tStatusMessageTooBig           StatusCode = 1009\n\tStatusMandatoryExtension      StatusCode = 1010\n\tStatusInternalError           StatusCode = 1011\n\tStatusServiceRestart          StatusCode = 1012\n\tStatusTryAgainLater           StatusCode = 1013\n\tStatusBadGateway              StatusCode = 1014\n\n\t// StatusTLSHandshake is only exported for use with Wasm.\n\t// In non Wasm Go, the returned error will indicate whether there was\n\t// a TLS handshake failure.\n\tStatusTLSHandshake StatusCode = 1015\n)\n\n// CloseError is returned when the connection is closed with a status and reason.\n//\n// Use Go 1.13's errors.As to check for this error.\n// Also see the CloseStatus helper.\ntype CloseError struct {\n\tCode   StatusCode\n\tReason string\n}\n\nfunc (ce CloseError) Error() string {\n\treturn fmt.Sprintf(\"status = %v and reason = %q\", ce.Code, ce.Reason)\n}\n\n// CloseStatus is a convenience wrapper around Go 1.13's errors.As to grab\n// the status code from a CloseError.\n//\n// -1 will be returned if the passed error is nil or not a CloseError.\nfunc CloseStatus(err error) StatusCode {\n\tvar ce CloseError\n\tif errors.As(err, &ce) {\n\t\treturn ce.Code\n\t}\n\treturn -1\n}\n\n// CompressionMode represents the modes available to the deflate extension.\n// See https://tools.ietf.org/html/rfc7692\n// Works in all browsers except Safari which does not implement the deflate extension.\ntype CompressionMode int\n\nconst (\n\t// CompressionNoContextTakeover grabs a new flate.Reader and flate.Writer as needed\n\t// for every message. This applies to both server and client side.\n\t//\n\t// This means less efficient compression as the sliding window from previous messages\n\t// will not be used but the memory overhead will be lower if the connections\n\t// are long lived and seldom used.\n\t//\n\t// The message will only be compressed if greater than 512 bytes.\n\tCompressionNoContextTakeover CompressionMode = iota\n\n\t// CompressionContextTakeover uses a flate.Reader and flate.Writer per connection.\n\t// This enables reusing the sliding window from previous messages.\n\t// As most WebSocket protocols are repetitive, this can be very efficient.\n\t// It carries an overhead of 8 kB for every connection compared to CompressionNoContextTakeover.\n\t//\n\t// If the peer negotiates NoContextTakeover on the client or server side, it will be\n\t// used instead as this is required by the RFC.\n\tCompressionContextTakeover\n\n\t// CompressionDisabled disables the deflate extension.\n\t//\n\t// Use this if you are using a predominantly binary protocol with very\n\t// little duplication in between messages or CPU and memory are more\n\t// important than bandwidth.\n\tCompressionDisabled\n)\n\n// MessageType represents the type of a WebSocket message.\n// See https://tools.ietf.org/html/rfc6455#section-5.6\ntype MessageType int\n\n// MessageType constants.\nconst (\n\t// MessageText is for UTF-8 encoded text messages like JSON.\n\tMessageText MessageType = iota + 1\n\t// MessageBinary is for binary messages like protobufs.\n\tMessageBinary\n)\n\ntype mu struct {\n\tc  *Conn\n\tch chan struct{}\n}\n\nfunc newMu(c *Conn) *mu {\n\treturn &mu{\n\t\tc:  c,\n\t\tch: make(chan struct{}, 1),\n\t}\n}\n\nfunc (m *mu) forceLock() {\n\tm.ch <- struct{}{}\n}\n\nfunc (m *mu) tryLock() bool {\n\tselect {\n\tcase m.ch <- struct{}{}:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (m *mu) unlock() {\n\tselect {\n\tcase <-m.ch:\n\tdefault:\n\t}\n}\n\ntype noCopy struct{}\n\nfunc (*noCopy) Lock() {}\n"
        },
        {
          "name": "ws_js_test.go",
          "type": "blob",
          "size": 1.3017578125,
          "content": "package websocket_test\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/coder/websocket\"\n\t\"github.com/coder/websocket/internal/test/assert\"\n\t\"github.com/coder/websocket/internal/test/wstest\"\n)\n\nfunc TestWasm(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\tc, resp, err := websocket.Dial(ctx, os.Getenv(\"WS_ECHO_SERVER_URL\"), &websocket.DialOptions{\n\t\tSubprotocols: []string{\"echo\"},\n\t})\n\tassert.Success(t, err)\n\tdefer c.Close(websocket.StatusInternalError, \"\")\n\n\tassert.Equal(t, \"subprotocol\", \"echo\", c.Subprotocol())\n\tassert.Equal(t, \"response code\", http.StatusSwitchingProtocols, resp.StatusCode)\n\n\tc.SetReadLimit(65536)\n\tfor i := 0; i < 10; i++ {\n\t\terr = wstest.Echo(ctx, c, 65536)\n\t\tassert.Success(t, err)\n\t}\n\n\terr = c.Close(websocket.StatusNormalClosure, \"\")\n\tassert.Success(t, err)\n}\n\nfunc TestWasmDialTimeout(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond)\n\tdefer cancel()\n\n\tbeforeDial := time.Now()\n\t_, _, err := websocket.Dial(ctx, \"ws://example.com:9893\", &websocket.DialOptions{\n\t\tSubprotocols: []string{\"echo\"},\n\t})\n\tassert.Error(t, err)\n\tif time.Since(beforeDial) >= time.Second {\n\t\tt.Fatal(\"wasm context dial timeout is not working\", time.Since(beforeDial))\n\t}\n}\n"
        },
        {
          "name": "wsjson",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}