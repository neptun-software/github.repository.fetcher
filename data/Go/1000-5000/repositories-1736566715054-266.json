{
  "metadata": {
    "timestamp": 1736566715054,
    "page": 266,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-ozzo/ozzo-validation",
      "stars": 3815,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.29296875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Idea Directory\n.idea\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n.DS_Store\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3623046875,
          "content": "dist: bionic\n\nlanguage: go\n\ngo:\n  - 1.13.x\n\ninstall:\n  - go get golang.org/x/tools/cmd/cover\n  - go get github.com/mattn/goveralls\n  - go get golang.org/x/lint/golint\n\nscript:\n  - test -z \"`gofmt -l -d .`\"\n  - test -z \"`golint ./...`\"\n  - go test -v -covermode=count -coverprofile=coverage.out\n  - $HOME/gopath/bin/goveralls -coverprofile=coverage.out -service=travis-ci\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\nCopyright (c) 2016, Qiang Xue\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software\nand associated documentation files (the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge, publish, distribute,\nsublicense, and/or sell copies of the Software, and to permit persons to whom the Software\nis furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or\nsubstantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\nBUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 28.9365234375,
          "content": "# ozzo-validation\n\n[![GoDoc](https://godoc.org/github.com/go-ozzo/ozzo-validation?status.png)](http://godoc.org/github.com/go-ozzo/ozzo-validation)\n[![Build Status](https://travis-ci.org/go-ozzo/ozzo-validation.svg?branch=master)](https://travis-ci.org/go-ozzo/ozzo-validation)\n[![Coverage Status](https://coveralls.io/repos/github/go-ozzo/ozzo-validation/badge.svg?branch=master)](https://coveralls.io/github/go-ozzo/ozzo-validation?branch=master)\n[![Go Report](https://goreportcard.com/badge/github.com/go-ozzo/ozzo-validation)](https://goreportcard.com/report/github.com/go-ozzo/ozzo-validation)\n\n## Description\n\nozzo-validation is a Go package that provides configurable and extensible data validation capabilities.\nIt has the following features:\n\n* use normal programming constructs rather than error-prone struct tags to specify how data should be validated.\n* can validate data of different types, e.g., structs, strings, byte slices, slices, maps, arrays.\n* can validate custom data types as long as they implement the `Validatable` interface.\n* can validate data types that implement the `sql.Valuer` interface (e.g. `sql.NullString`).\n* customizable and well-formatted validation errors.\n* error code and message translation support.\n* provide a rich set of validation rules right out of box.\n* extremely easy to create and use custom validation rules.\n\nFor an example on how this library is used in an application, please refer to [go-rest-api](https://github.com/qiangxue/go-rest-api) which is a starter kit for building RESTful APIs in Go.\n\n## Requirements\n\nGo 1.13 or above.\n\n\n## Getting Started\n\nThe ozzo-validation package mainly includes a set of validation rules and two validation methods. You use \nvalidation rules to describe how a value should be considered valid, and you call either `validation.Validate()`\nor `validation.ValidateStruct()` to validate the value.\n\n\n### Installation\n\nRun the following command to install the package:\n\n```\ngo get github.com/go-ozzo/ozzo-validation\n```\n\n### Validating a Simple Value\n\nFor a simple value, such as a string or an integer, you may use `validation.Validate()` to validate it. For example, \n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-ozzo/ozzo-validation/v4\"\n\t\"github.com/go-ozzo/ozzo-validation/v4/is\"\n)\n\nfunc main() {\n\tdata := \"example\"\n\terr := validation.Validate(data,\n\t\tvalidation.Required,       // not empty\n\t\tvalidation.Length(5, 100), // length between 5 and 100\n\t\tis.URL,                    // is a valid URL\n\t)\n\tfmt.Println(err)\n\t// Output:\n\t// must be a valid URL\n}\n```\n\nThe method `validation.Validate()` will run through the rules in the order that they are listed. If a rule fails\nthe validation, the method will return the corresponding error and skip the rest of the rules. The method will\nreturn nil if the value passes all validation rules.\n\n\n### Validating a Struct\n\nFor a struct value, you usually want to check if its fields are valid. For example, in a RESTful application, you\nmay unmarshal the request payload into a struct and then validate the struct fields. If one or multiple fields\nare invalid, you may want to get an error describing which fields are invalid. You can use `validation.ValidateStruct()`\nto achieve this purpose. A single struct can have rules for multiple fields, and a field can be associated with multiple \nrules. For example,\n\n```go\ntype Address struct {\n\tStreet string\n\tCity   string\n\tState  string\n\tZip    string\n}\n\nfunc (a Address) Validate() error {\n\treturn validation.ValidateStruct(&a,\n\t\t// Street cannot be empty, and the length must between 5 and 50\n\t\tvalidation.Field(&a.Street, validation.Required, validation.Length(5, 50)),\n\t\t// City cannot be empty, and the length must between 5 and 50\n\t\tvalidation.Field(&a.City, validation.Required, validation.Length(5, 50)),\n\t\t// State cannot be empty, and must be a string consisting of two letters in upper case\n\t\tvalidation.Field(&a.State, validation.Required, validation.Match(regexp.MustCompile(\"^[A-Z]{2}$\"))),\n\t\t// State cannot be empty, and must be a string consisting of five digits\n\t\tvalidation.Field(&a.Zip, validation.Required, validation.Match(regexp.MustCompile(\"^[0-9]{5}$\"))),\n\t)\n}\n\na := Address{\n    Street: \"123\",\n    City:   \"Unknown\",\n    State:  \"Virginia\",\n    Zip:    \"12345\",\n}\n\nerr := a.Validate()\nfmt.Println(err)\n// Output:\n// Street: the length must be between 5 and 50; State: must be in a valid format.\n```\n\nNote that when calling `validation.ValidateStruct` to validate a struct, you should pass to the method a pointer \nto the struct instead of the struct itself. Similarly, when calling `validation.Field` to specify the rules\nfor a struct field, you should use a pointer to the struct field. \n\nWhen the struct validation is performed, the fields are validated in the order they are specified in `ValidateStruct`. \nAnd when each field is validated, its rules are also evaluated in the order they are associated with the field.\nIf a rule fails, an error is recorded for that field, and the validation will continue with the next field.\n\n\n### Validating a Map\n\nSometimes you might need to work with dynamic data stored in maps rather than a typed model. You can use `validation.Map()`\nin this situation. A single map can have rules for multiple keys, and a key can be associated with multiple \nrules. For example,\n\n```go\nc := map[string]interface{}{\n\t\"Name\":  \"Qiang Xue\",\n\t\"Email\": \"q\",\n\t\"Address\": map[string]interface{}{\n\t\t\"Street\": \"123\",\n\t\t\"City\":   \"Unknown\",\n\t\t\"State\":  \"Virginia\",\n\t\t\"Zip\":    \"12345\",\n\t},\n}\n\nerr := validation.Validate(c,\n\tvalidation.Map(\n\t\t// Name cannot be empty, and the length must be between 5 and 20.\n\t\tvalidation.Key(\"Name\", validation.Required, validation.Length(5, 20)),\n\t\t// Email cannot be empty and should be in a valid email format.\n\t\tvalidation.Key(\"Email\", validation.Required, is.Email),\n\t\t// Validate Address using its own validation rules\n\t\tvalidation.Key(\"Address\", validation.Map(\n\t\t\t// Street cannot be empty, and the length must between 5 and 50\n\t\t\tvalidation.Key(\"Street\", validation.Required, validation.Length(5, 50)),\n\t\t\t// City cannot be empty, and the length must between 5 and 50\n\t\t\tvalidation.Key(\"City\", validation.Required, validation.Length(5, 50)),\n\t\t\t// State cannot be empty, and must be a string consisting of two letters in upper case\n\t\t\tvalidation.Key(\"State\", validation.Required, validation.Match(regexp.MustCompile(\"^[A-Z]{2}$\"))),\n\t\t\t// State cannot be empty, and must be a string consisting of five digits\n\t\t\tvalidation.Key(\"Zip\", validation.Required, validation.Match(regexp.MustCompile(\"^[0-9]{5}$\"))),\n\t\t)),\n\t),\n)\nfmt.Println(err)\n// Output:\n// Address: (State: must be in a valid format; Street: the length must be between 5 and 50.); Email: must be a valid email address.\n```\n\nWhen the map validation is performed, the keys are validated in the order they are specified in `Map`. \nAnd when each key is validated, its rules are also evaluated in the order they are associated with the key.\nIf a rule fails, an error is recorded for that key, and the validation will continue with the next key.\n\n\n### Validation Errors\n\nThe `validation.ValidateStruct` method returns validation errors found in struct fields in terms of `validation.Errors` \nwhich is a map of fields and their corresponding errors. Nil is returned if validation passes.\n\nBy default, `validation.Errors` uses the struct tags named `json` to determine what names should be used to \nrepresent the invalid fields. The type also implements the `json.Marshaler` interface so that it can be marshaled \ninto a proper JSON object. For example,\n\n```go\ntype Address struct {\n\tStreet string `json:\"street\"`\n\tCity   string `json:\"city\"`\n\tState  string `json:\"state\"`\n\tZip    string `json:\"zip\"`\n}\n\n// ...perform validation here...\n\nerr := a.Validate()\nb, _ := json.Marshal(err)\nfmt.Println(string(b))\n// Output:\n// {\"street\":\"the length must be between 5 and 50\",\"state\":\"must be in a valid format\"}\n```\n\nYou may modify `validation.ErrorTag` to use a different struct tag name.\n\nIf you do not like the magic that `ValidateStruct` determines error keys based on struct field names or corresponding\ntag values, you may use the following alternative approach:\n\n```go\nc := Customer{\n\tName:  \"Qiang Xue\",\n\tEmail: \"q\",\n\tAddress: Address{\n\t\tState:  \"Virginia\",\n\t},\n}\n\nerr := validation.Errors{\n\t\"name\": validation.Validate(c.Name, validation.Required, validation.Length(5, 20)),\n\t\"email\": validation.Validate(c.Name, validation.Required, is.Email),\n\t\"zip\": validation.Validate(c.Address.Zip, validation.Required, validation.Match(regexp.MustCompile(\"^[0-9]{5}$\"))),\n}.Filter()\nfmt.Println(err)\n// Output:\n// email: must be a valid email address; zip: cannot be blank.\n```\n\nIn the above example, we build a `validation.Errors` by a list of names and the corresponding validation results. \nAt the end we call `Errors.Filter()` to remove from `Errors` all nils which correspond to those successful validation \nresults. The method will return nil if `Errors` is empty.\n\nThe above approach is very flexible as it allows you to freely build up your validation error structure. You can use\nit to validate both struct and non-struct values. Compared to using `ValidateStruct` to validate a struct, \nit has the drawback that you have to redundantly specify the error keys while `ValidateStruct` can automatically \nfind them out.\n\n\n### Internal Errors\n\nInternal errors are different from validation errors in that internal errors are caused by malfunctioning code (e.g.\na validator making a remote call to validate some data when the remote service is down) rather\nthan the data being validated. When an internal error happens during data validation, you may allow the user to resubmit\nthe same data to perform validation again, hoping the program resumes functioning. On the other hand, if data validation\nfails due to data error, the user should generally not resubmit the same data again.\n\nTo differentiate internal errors from validation errors, when an internal error occurs in a validator, wrap it\ninto `validation.InternalError` by calling `validation.NewInternalError()`. The user of the validator can then check\nif a returned error is an internal error or not. For example,\n\n```go\nif err := a.Validate(); err != nil {\n\tif e, ok := err.(validation.InternalError); ok {\n\t\t// an internal error happened\n\t\tfmt.Println(e.InternalError())\n\t}\n}\n```\n\n\n## Validatable Types\n\nA type is validatable if it implements the `validation.Validatable` interface. \n\nWhen `validation.Validate` is used to validate a validatable value, if it does not find any error with the \ngiven validation rules, it will further call the value's `Validate()` method. \n\nSimilarly, when `validation.ValidateStruct` is validating a struct field whose type is validatable, it will call \nthe field's `Validate` method after it passes the listed rules.\n\n> Note: When implementing `validation.Validatable`, do not call `validation.Validate()` to validate the value in its\n> original type because this will cause infinite loops. For example, if you define a new type `MyString` as `string`\n> and implement `validation.Validatable` for `MyString`, within the `Validate()` function you should cast the value \n> to `string` first before calling `validation.Validate()` to validate it.\n\nIn the following example, the `Address` field of `Customer` is validatable because `Address` implements \n`validation.Validatable`. Therefore, when validating a `Customer` struct with `validation.ValidateStruct`,\nvalidation will \"dive\" into the `Address` field.\n\n```go\ntype Customer struct {\n\tName    string\n\tGender  string\n\tEmail   string\n\tAddress Address\n}\n\nfunc (c Customer) Validate() error {\n\treturn validation.ValidateStruct(&c,\n\t\t// Name cannot be empty, and the length must be between 5 and 20.\n\t\tvalidation.Field(&c.Name, validation.Required, validation.Length(5, 20)),\n\t\t// Gender is optional, and should be either \"Female\" or \"Male\".\n\t\tvalidation.Field(&c.Gender, validation.In(\"Female\", \"Male\")),\n\t\t// Email cannot be empty and should be in a valid email format.\n\t\tvalidation.Field(&c.Email, validation.Required, is.Email),\n\t\t// Validate Address using its own validation rules\n\t\tvalidation.Field(&c.Address),\n\t)\n}\n\nc := Customer{\n\tName:  \"Qiang Xue\",\n\tEmail: \"q\",\n\tAddress: Address{\n\t\tStreet: \"123 Main Street\",\n\t\tCity:   \"Unknown\",\n\t\tState:  \"Virginia\",\n\t\tZip:    \"12345\",\n\t},\n}\n\nerr := c.Validate()\nfmt.Println(err)\n// Output:\n// Address: (State: must be in a valid format.); Email: must be a valid email address.\n```\n\nSometimes, you may want to skip the invocation of a type's `Validate` method. To do so, simply associate\na `validation.Skip` rule with the value being validated.\n\n### Maps/Slices/Arrays of Validatables\n\nWhen validating an iterable (map, slice, or array), whose element type implements the `validation.Validatable` interface,\nthe `validation.Validate` method will call the `Validate` method of every non-nil element.\nThe validation errors of the elements will be returned as `validation.Errors` which maps the keys of the\ninvalid elements to their corresponding validation errors. For example,\n\n```go\naddresses := []Address{\n\tAddress{State: \"MD\", Zip: \"12345\"},\n\tAddress{Street: \"123 Main St\", City: \"Vienna\", State: \"VA\", Zip: \"12345\"},\n\tAddress{City: \"Unknown\", State: \"NC\", Zip: \"123\"},\n}\nerr := validation.Validate(addresses)\nfmt.Println(err)\n// Output:\n// 0: (City: cannot be blank; Street: cannot be blank.); 2: (Street: cannot be blank; Zip: must be in a valid format.).\n```\n\nWhen using `validation.ValidateStruct` to validate a struct, the above validation procedure also applies to those struct \nfields which are map/slices/arrays of validatables. \n\n#### Each\n\nThe `Each` validation rule allows you to apply a set of rules to each element of an array, slice, or map.\n\n```go\ntype Customer struct {\n    Name      string\n    Emails    []string\n}\n\nfunc (c Customer) Validate() error {\n    return validation.ValidateStruct(&c,\n        // Name cannot be empty, and the length must be between 5 and 20.\n\t\tvalidation.Field(&c.Name, validation.Required, validation.Length(5, 20)),\n\t\t// Emails are optional, but if given must be valid.\n\t\tvalidation.Field(&c.Emails, validation.Each(is.Email)),\n    )\n}\n\nc := Customer{\n    Name:   \"Qiang Xue\",\n    Emails: []Email{\n        \"valid@example.com\",\n        \"invalid\",\n    },\n}\n\nerr := c.Validate()\nfmt.Println(err)\n// Output:\n// Emails: (1: must be a valid email address.).\n```\n\n### Pointers\n\nWhen a value being validated is a pointer, most validation rules will validate the actual value pointed to by the pointer.\nIf the pointer is nil, these rules will skip the validation.\n\nAn exception is the `validation.Required` and `validation.NotNil` rules. When a pointer is nil, they\nwill report a validation error.\n\n\n### Types Implementing `sql.Valuer`\n\nIf a data type implements the `sql.Valuer` interface (e.g. `sql.NullString`), the built-in validation rules will handle\nit properly. In particular, when a rule is validating such data, it will call the `Value()` method and validate\nthe returned value instead.\n\n\n### Required vs. Not Nil\n\nWhen validating input values, there are two different scenarios about checking if input values are provided or not.\n\nIn the first scenario, an input value is considered missing if it is not entered or it is entered as a zero value\n(e.g. an empty string, a zero integer). You can use the `validation.Required` rule in this case.\n\nIn the second scenario, an input value is considered missing only if it is not entered. A pointer field is usually\nused in this case so that you can detect if a value is entered or not by checking if the pointer is nil or not.\nYou can use the `validation.NotNil` rule to ensure a value is entered (even if it is a zero value).\n\n\n### Embedded Structs\n\nThe `validation.ValidateStruct` method will properly validate a struct that contains embedded structs. In particular,\nthe fields of an embedded struct are treated as if they belong directly to the containing struct. For example,\n\n```go\ntype Employee struct {\n\tName string\n}\n\ntype Manager struct {\n\tEmployee\n\tLevel int\n}\n\nm := Manager{}\nerr := validation.ValidateStruct(&m,\n\tvalidation.Field(&m.Name, validation.Required),\n\tvalidation.Field(&m.Level, validation.Required),\n)\nfmt.Println(err)\n// Output:\n// Level: cannot be blank; Name: cannot be blank.\n```\n\nIn the above code, we use `&m.Name` to specify the validation of the `Name` field of the embedded struct `Employee`.\nAnd the validation error uses `Name` as the key for the error associated with the `Name` field as if `Name` a field\ndirectly belonging to `Manager`.\n\nIf `Employee` implements the `validation.Validatable` interface, we can also use the following code to validate\n`Manager`, which generates the same validation result:\n\n```go\nfunc (e Employee) Validate() error {\n\treturn validation.ValidateStruct(&e,\n\t\tvalidation.Field(&e.Name, validation.Required),\n\t)\n}\n\nerr := validation.ValidateStruct(&m,\n\tvalidation.Field(&m.Employee),\n\tvalidation.Field(&m.Level, validation.Required),\n)\nfmt.Println(err)\n// Output:\n// Level: cannot be blank; Name: cannot be blank.\n```\n\n\n### Conditional Validation\n\nSometimes, we may want to validate a value only when certain condition is met. For example, we want to ensure the \n`unit` struct field is not empty only when the `quantity` field is not empty; or we may want to ensure either `email`\nor `phone` is provided. The so-called conditional validation can be achieved with the help of `validation.When`.\nThe following code implements the aforementioned examples:\n\n```go\nresult := validation.ValidateStruct(&a,\n    validation.Field(&a.Unit, validation.When(a.Quantity != \"\", validation.Required).Else(validation.Nil)),\n    validation.Field(&a.Phone, validation.When(a.Email == \"\", validation.Required.Error('Either phone or Email is required.')),\n    validation.Field(&a.Email, validation.When(a.Phone == \"\", validation.Required.Error('Either phone or Email is required.')),\n)\n```\n\nNote that `validation.When` and `validation.When.Else` can take a list of validation rules. These rules will be executed only when the condition is true (When) or false (Else).\n\nThe above code can also be simplified using the shortcut `validation.Required.When`:\n\n```go\nresult := validation.ValidateStruct(&a,\n    validation.Field(&a.Unit, validation.Required.When(a.Quantity != \"\"), validation.Nil.When(a.Quantity == \"\")),\n    validation.Field(&a.Phone, validation.Required.When(a.Email == \"\").Error('Either phone or Email is required.')),\n    validation.Field(&a.Email, validation.Required.When(a.Phone == \"\").Error('Either phone or Email is required.')),\n)\n```\n\n### Customizing Error Messages\n\nAll built-in validation rules allow you to customize their error messages. To do so, simply call the `Error()` method\nof the rules. For example,\n\n```go\ndata := \"2123\"\nerr := validation.Validate(data,\n\tvalidation.Required.Error(\"is required\"),\n\tvalidation.Match(regexp.MustCompile(\"^[0-9]{5}$\")).Error(\"must be a string with five digits\"),\n)\nfmt.Println(err)\n// Output:\n// must be a string with five digits\n```\n\nYou can also customize the pre-defined error(s) of a built-in rule such that the customization applies to *every*\ninstance of the rule. For example, the `Required` rule uses the pre-defined error `ErrRequired`. You can customize it\nduring the application initialization:\n```go\nvalidation.ErrRequired = validation.ErrRequired.SetMessage(\"the value is required\") \n```\n\n### Error Code and Message Translation\n\nThe errors returned by the validation rules implement the `Error` interface which contains the `Code()` method \nto provide the error code information. While the message of a validation error is often customized, the code is immutable.\nYou can use error code to programmatically check a validation error or look for the translation of the corresponding message.\n\nIf you are developing your own validation rules, you can use `validation.NewError()` to create a validation error which\nimplements the aforementioned `Error` interface.\n\n## Creating Custom Rules\n\nCreating a custom rule is as simple as implementing the `validation.Rule` interface. The interface contains a single\nmethod as shown below, which should validate the value and return the validation error, if any:\n\n```go\n// Validate validates a value and returns an error if validation fails.\nValidate(value interface{}) error\n```\n\nIf you already have a function with the same signature as shown above, you can call `validation.By()` to turn\nit into a validation rule. For example,\n\n```go\nfunc checkAbc(value interface{}) error {\n\ts, _ := value.(string)\n\tif s != \"abc\" {\n\t\treturn errors.New(\"must be abc\")\n\t}\n\treturn nil\n}\n\nerr := validation.Validate(\"xyz\", validation.By(checkAbc))\nfmt.Println(err)\n// Output: must be abc\n```\n\nIf your validation function takes additional parameters, you can use the following closure trick:\n\n```go\nfunc stringEquals(str string) validation.RuleFunc {\n\treturn func(value interface{}) error {\n\t\ts, _ := value.(string)\n        if s != str {\n            return errors.New(\"unexpected string\")\n        }\n        return nil\n    }\n}\n\nerr := validation.Validate(\"xyz\", validation.By(stringEquals(\"abc\")))\nfmt.Println(err)\n// Output: unexpected string\n```\n\n\n### Rule Groups\n\nWhen a combination of several rules are used in multiple places, you may use the following trick to create a \nrule group so that your code is more maintainable.\n\n```go\nvar NameRule = []validation.Rule{\n\tvalidation.Required,\n\tvalidation.Length(5, 20),\n}\n\ntype User struct {\n\tFirstName string\n\tLastName  string\n}\n\nfunc (u User) Validate() error {\n\treturn validation.ValidateStruct(&u,\n\t\tvalidation.Field(&u.FirstName, NameRule...),\n\t\tvalidation.Field(&u.LastName, NameRule...),\n\t)\n}\n```\n\nIn the above example, we create a rule group `NameRule` which consists of two validation rules. We then use this rule\ngroup to validate both `FirstName` and `LastName`.\n\n\n## Context-aware Validation\n\nWhile most validation rules are self-contained, some rules may depend dynamically on a context. A rule may implement the\n`validation.RuleWithContext` interface to support the so-called context-aware validation.\n \nTo validate an arbitrary value with a context, call `validation.ValidateWithContext()`. The `context.Conext` parameter \nwill be passed along to those rules that implement `validation.RuleWithContext`.\n\nTo validate the fields of a struct with a context, call `validation.ValidateStructWithContext()`. \n\nYou can define a context-aware rule from scratch by implementing both `validation.Rule` and `validation.RuleWithContext`. \nYou can also use `validation.WithContext()` to turn a function into a context-aware rule. For example,\n\n\n```go\nrule := validation.WithContext(func(ctx context.Context, value interface{}) error {\n\tif ctx.Value(\"secret\") == value.(string) {\n\t    return nil\n\t}\n\treturn errors.New(\"value incorrect\")\n})\nvalue := \"xyz\"\nctx := context.WithValue(context.Background(), \"secret\", \"example\")\nerr := validation.ValidateWithContext(ctx, value, rule)\nfmt.Println(err)\n// Output: value incorrect\n```\n\nWhen performing context-aware validation, if a rule does not implement `validation.RuleWithContext`, its\n`validation.Rule` will be used instead.\n\n\n## Built-in Validation Rules\n\nThe following rules are provided in the `validation` package:\n\n* `In(...interface{})`: checks if a value can be found in the given list of values.\n* `NotIn(...interface{})`: checks if a value is NOT among the given list of values.\n* `Length(min, max int)`: checks if the length of a value is within the specified range.\n  This rule should only be used for validating strings, slices, maps, and arrays.\n* `RuneLength(min, max int)`: checks if the length of a string is within the specified range.\n  This rule is similar as `Length` except that when the value being validated is a string, it checks\n  its rune length instead of byte length.\n* `Min(min interface{})` and `Max(max interface{})`: checks if a value is within the specified range.\n  These two rules should only be used for validating int, uint, float and time.Time types.\n* `Match(*regexp.Regexp)`: checks if a value matches the specified regular expression.\n  This rule should only be used for strings and byte slices.\n* `Date(layout string)`: checks if a string value is a date whose format is specified by the layout.\n  By calling `Min()` and/or `Max()`, you can check additionally if the date is within the specified range.\n* `Required`: checks if a value is not empty (neither nil nor zero).\n* `NotNil`: checks if a pointer value is not nil. Non-pointer values are considered valid.\n* `NilOrNotEmpty`: checks if a value is a nil pointer or a non-empty value. This differs from `Required` in that it treats a nil pointer as valid.\n* `Nil`: checks if a value is a nil pointer.\n* `Empty`: checks if a value is empty. nil pointers are considered valid.\n* `Skip`: this is a special rule used to indicate that all rules following it should be skipped (including the nested ones).\n* `MultipleOf`: checks if the value is a multiple of the specified range.\n* `Each(rules ...Rule)`: checks the elements within an iterable (map/slice/array) with other rules.\n* `When(condition, rules ...Rule)`: validates with the specified rules only when the condition is true.\n* `Else(rules ...Rule)`: must be used with `When(condition, rules ...Rule)`, validates with the specified rules only when the condition is false.\n\nThe `is` sub-package provides a list of commonly used string validation rules that can be used to check if the format\nof a value satisfies certain requirements. Note that these rules only handle strings and byte slices and if a string\n or byte slice is empty, it is considered valid. You may use a `Required` rule to ensure a value is not empty.\nBelow is the whole list of the rules provided by the `is` package:\n\n* `Email`: validates if a string is an email or not. It also checks if the MX record exists for the email domain.\n* `EmailFormat`: validates if a string is an email or not. It does NOT check the existence of the MX record.\n* `URL`: validates if a string is a valid URL\n* `RequestURL`: validates if a string is a valid request URL\n* `RequestURI`: validates if a string is a valid request URI\n* `Alpha`: validates if a string contains English letters only (a-zA-Z)\n* `Digit`: validates if a string contains digits only (0-9)\n* `Alphanumeric`: validates if a string contains English letters and digits only (a-zA-Z0-9)\n* `UTFLetter`: validates if a string contains unicode letters only\n* `UTFDigit`: validates if a string contains unicode decimal digits only\n* `UTFLetterNumeric`: validates if a string contains unicode letters and numbers only\n* `UTFNumeric`: validates if a string contains unicode number characters (category N) only\n* `LowerCase`: validates if a string contains lower case unicode letters only\n* `UpperCase`: validates if a string contains upper case unicode letters only\n* `Hexadecimal`: validates if a string is a valid hexadecimal number\n* `HexColor`: validates if a string is a valid hexadecimal color code\n* `RGBColor`: validates if a string is a valid RGB color in the form of rgb(R, G, B)\n* `Int`: validates if a string is a valid integer number\n* `Float`: validates if a string is a floating point number\n* `UUIDv3`: validates if a string is a valid version 3 UUID\n* `UUIDv4`: validates if a string is a valid version 4 UUID\n* `UUIDv5`: validates if a string is a valid version 5 UUID\n* `UUID`: validates if a string is a valid UUID\n* `CreditCard`: validates if a string is a valid credit card number\n* `ISBN10`: validates if a string is an ISBN version 10\n* `ISBN13`: validates if a string is an ISBN version 13\n* `ISBN`: validates if a string is an ISBN (either version 10 or 13)\n* `JSON`: validates if a string is in valid JSON format\n* `ASCII`: validates if a string contains ASCII characters only\n* `PrintableASCII`: validates if a string contains printable ASCII characters only\n* `Multibyte`: validates if a string contains multibyte characters\n* `FullWidth`: validates if a string contains full-width characters\n* `HalfWidth`: validates if a string contains half-width characters\n* `VariableWidth`: validates if a string contains both full-width and half-width characters\n* `Base64`: validates if a string is encoded in Base64\n* `DataURI`: validates if a string is a valid base64-encoded data URI\n* `E164`: validates if a string is a valid E164 phone number (+19251232233)\n* `CountryCode2`: validates if a string is a valid ISO3166 Alpha 2 country code\n* `CountryCode3`: validates if a string is a valid ISO3166 Alpha 3 country code\n* `DialString`: validates if a string is a valid dial string that can be passed to Dial()\n* `MAC`: validates if a string is a MAC address\n* `IP`: validates if a string is a valid IP address (either version 4 or 6)\n* `IPv4`: validates if a string is a valid version 4 IP address\n* `IPv6`: validates if a string is a valid version 6 IP address\n* `Subdomain`: validates if a string is valid subdomain\n* `Domain`: validates if a string is valid domain\n* `DNSName`: validates if a string is valid DNS name\n* `Host`: validates if a string is a valid IP (both v4 and v6) or a valid DNS name\n* `Port`: validates if a string is a valid port number\n* `MongoID`: validates if a string is a valid Mongo ID\n* `Latitude`: validates if a string is a valid latitude\n* `Longitude`: validates if a string is a valid longitude\n* `SSN`: validates if a string is a social security number (SSN)\n* `Semver`: validates if a string is a valid semantic version\n\n## Credits\n\nThe `is` sub-package wraps the excellent validators provided by the [govalidator](https://github.com/asaskevich/govalidator) package.\n"
        },
        {
          "name": "UPGRADE.md",
          "type": "blob",
          "size": 2.357421875,
          "content": "# Upgrade Instructions\n\n## Upgrade from 3.x to 4.x\n\nIf you are customizing the error messages of the following built-in validation rules, you may need to \nchange the parameter placeholders from `%v` to the Go template variable placeholders.\n* `Length`: use `{{.min}}` and `{{.max}}` in the error message to refer to the minimum and maximum lengths.\n* `Min`: use `{{.threshold}}` in the error message to refer to the lower bound.\n* `Max`: use `{{.threshold}}` in the error message to refer to the upper bound\n* `MultipleOf`: use `{{.base}}` in the error message to refer to the base of the multiples.\n\nFor example,\n ```go\n// 3.x\nlengthRule := validation.Length(2,10).Error(\"the length must be between %v and %v\")\n\n// 4.x\nlengthRule := validation.Length(2,10).Error(\"the length must be between {{.min}} and {{.max}}\")\n```\n\n## Upgrade from 2.x to 3.x\n\n* Instead of using `StructRules` to define struct validation rules, use `ValidateStruct()` to declare and perform\n  struct validation. The following code snippet shows how to modify your code:\n```go\n// 2.x usage\nerr := validation.StructRules{}.\n\tAdd(\"Street\", validation.Required, validation.Length(5, 50)).\n\tAdd(\"City\", validation.Required, validation.Length(5, 50)).\n\tAdd(\"State\", validation.Required, validation.Match(regexp.MustCompile(\"^[A-Z]{2}$\"))).\n\tAdd(\"Zip\", validation.Required, validation.Match(regexp.MustCompile(\"^[0-9]{5}$\"))).\n\tValidate(a)\n\n// 3.x usage\nerr := validation.ValidateStruct(&a,\n\tvalidation.Field(&a.Street, validation.Required, validation.Length(5, 50)),\n\tvalidation.Field(&a.City, validation.Required, validation.Length(5, 50)),\n\tvalidation.Field(&a.State, validation.Required, validation.Match(regexp.MustCompile(\"^[A-Z]{2}$\"))),\n\tvalidation.Field(&a.Zip, validation.Required, validation.Match(regexp.MustCompile(\"^[0-9]{5}$\"))),\n)\n```\n\n* Instead of using `Rules` to declare a rule list and use it to validate a value, call `Validate()` with the rules directly.\n```go\ndata := \"example\"\n\n// 2.x usage\nrules := validation.Rules{\n\tvalidation.Required,      \n\tvalidation.Length(5, 100),\n\tis.URL,                   \n}\nerr := rules.Validate(data)\n\n// 3.x usage\nerr := validation.Validate(data,\n\tvalidation.Required,      \n\tvalidation.Length(5, 100),\n\tis.URL,                   \n)\n```\n\n* The default struct tags used for determining error keys is changed from `validation` to `json`. You may modify\n  `validation.ErrorTag` to change it back."
        },
        {
          "name": "absent.go",
          "type": "blob",
          "size": 1.626953125,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nvar (\n\t// ErrNil is the error that returns when a value is not nil.\n\tErrNil = NewError(\"validation_nil\", \"must be blank\")\n\t// ErrEmpty is the error that returns when a not nil value is not empty.\n\tErrEmpty = NewError(\"validation_empty\", \"must be blank\")\n)\n\n// Nil is a validation rule that checks if a value is nil.\n// It is the opposite of NotNil rule\nvar Nil = absentRule{condition: true, skipNil: false}\n\n// Empty checks if a not nil value is empty.\nvar Empty = absentRule{condition: true, skipNil: true}\n\ntype absentRule struct {\n\tcondition bool\n\terr       Error\n\tskipNil   bool\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r absentRule) Validate(value interface{}) error {\n\tif r.condition {\n\t\tvalue, isNil := Indirect(value)\n\t\tif !r.skipNil && !isNil || r.skipNil && !isNil && !IsEmpty(value) {\n\t\t\tif r.err != nil {\n\t\t\t\treturn r.err\n\t\t\t}\n\t\t\tif r.skipNil {\n\t\t\t\treturn ErrEmpty\n\t\t\t}\n\t\t\treturn ErrNil\n\t\t}\n\t}\n\treturn nil\n}\n\n// When sets the condition that determines if the validation should be performed.\nfunc (r absentRule) When(condition bool) absentRule {\n\tr.condition = condition\n\treturn r\n}\n\n// Error sets the error message for the rule.\nfunc (r absentRule) Error(message string) absentRule {\n\tif r.err == nil {\n\t\tif r.skipNil {\n\t\t\tr.err = ErrEmpty\n\t\t} else {\n\t\t\tr.err = ErrNil\n\t\t}\n\t}\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r absentRule) ErrorObject(err Error) absentRule {\n\tr.err = err\n\treturn r\n}\n"
        },
        {
          "name": "absent_test.go",
          "type": "blob",
          "size": 2.171875,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNil(t *testing.T) {\n\ts1 := \"123\"\n\ts2 := \"\"\n\tvar time1 time.Time\n\ttests := []struct {\n\t\ttag   string\n\t\tvalue interface{}\n\t\terr   string\n\t}{\n\t\t{\"t1\", 123, \"must be blank\"},\n\t\t{\"t2\", \"\", \"must be blank\"},\n\t\t{\"t3\", &s1, \"must be blank\"},\n\t\t{\"t4\", &s2, \"must be blank\"},\n\t\t{\"t5\", nil, \"\"},\n\t\t{\"t6\", time1, \"must be blank\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := Nil\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestEmpty(t *testing.T) {\n\ts1 := \"123\"\n\ts2 := \"\"\n\ttime1 := time.Now()\n\tvar time2 time.Time\n\ttests := []struct {\n\t\ttag   string\n\t\tvalue interface{}\n\t\terr   string\n\t}{\n\t\t{\"t1\", 123, \"must be blank\"},\n\t\t{\"t2\", \"\", \"\"},\n\t\t{\"t3\", &s1, \"must be blank\"},\n\t\t{\"t4\", &s2, \"\"},\n\t\t{\"t5\", nil, \"\"},\n\t\t{\"t6\", time1, \"must be blank\"},\n\t\t{\"t7\", time2, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := Empty\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestAbsentRule_When(t *testing.T) {\n\tr := Nil.When(false)\n\terr := Validate(42, r)\n\tassert.Nil(t, err)\n\n\tr = Nil.When(true)\n\terr = Validate(42, r)\n\tassert.Equal(t, ErrNil, err)\n}\n\nfunc Test_absentRule_Error(t *testing.T) {\n\tr := Nil\n\tassert.Equal(t, \"must be blank\", r.Validate(\"42\").Error())\n\tassert.False(t, r.skipNil)\n\tr2 := r.Error(\"123\")\n\tassert.Equal(t, \"must be blank\", r.Validate(\"42\").Error())\n\tassert.False(t, r.skipNil)\n\tassert.Equal(t, \"123\", r2.err.Message())\n\tassert.False(t, r2.skipNil)\n\n\tr = Empty\n\tassert.Equal(t, \"must be blank\", r.Validate(\"42\").Error())\n\tassert.True(t, r.skipNil)\n\tr2 = r.Error(\"123\")\n\tassert.Equal(t, \"must be blank\", r.Validate(\"42\").Error())\n\tassert.True(t, r.skipNil)\n\tassert.Equal(t, \"123\", r2.err.Message())\n\tassert.True(t, r2.skipNil)\n}\n\nfunc TestAbsentRule_Error(t *testing.T) {\n\tr := Nil\n\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, err.Code(), r.err.Code())\n\tassert.Equal(t, err.Message(), r.err.Message())\n\tassert.NotEqual(t, err, Nil.err)\n}\n"
        },
        {
          "name": "date.go",
          "type": "blob",
          "size": 2.9765625,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"time\"\n)\n\nvar (\n\t// ErrDateInvalid is the error that returns in case of an invalid date.\n\tErrDateInvalid = NewError(\"validation_date_invalid\", \"must be a valid date\")\n\t// ErrDateOutOfRange is the error that returns in case of an invalid date.\n\tErrDateOutOfRange = NewError(\"validation_date_out_of_range\", \"the date is out of range\")\n)\n\n// DateRule is a validation rule that validates date/time string values.\ntype DateRule struct {\n\tlayout        string\n\tmin, max      time.Time\n\terr, rangeErr Error\n}\n\n// Date returns a validation rule that checks if a string value is in a format that can be parsed into a date.\n// The format of the date should be specified as the layout parameter which accepts the same value as that for time.Parse.\n// For example,\n//    validation.Date(time.ANSIC)\n//    validation.Date(\"02 Jan 06 15:04 MST\")\n//    validation.Date(\"2006-01-02\")\n//\n// By calling Min() and/or Max(), you can let the Date rule to check if a parsed date value is within\n// the specified date range.\n//\n// An empty value is considered valid. Use the Required rule to make sure a value is not empty.\nfunc Date(layout string) DateRule {\n\treturn DateRule{\n\t\tlayout:   layout,\n\t\terr:      ErrDateInvalid,\n\t\trangeErr: ErrDateOutOfRange,\n\t}\n}\n\n// Error sets the error message that is used when the value being validated is not a valid date.\nfunc (r DateRule) Error(message string) DateRule {\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct that is used when the value being validated is not a valid date..\nfunc (r DateRule) ErrorObject(err Error) DateRule {\n\tr.err = err\n\treturn r\n}\n\n// RangeError sets the error message that is used when the value being validated is out of the specified Min/Max date range.\nfunc (r DateRule) RangeError(message string) DateRule {\n\tr.rangeErr = r.rangeErr.SetMessage(message)\n\treturn r\n}\n\n// RangeErrorObject sets the error struct that is used when the value being validated is out of the specified Min/Max date range.\nfunc (r DateRule) RangeErrorObject(err Error) DateRule {\n\tr.rangeErr = err\n\treturn r\n}\n\n// Min sets the minimum date range. A zero value means skipping the minimum range validation.\nfunc (r DateRule) Min(min time.Time) DateRule {\n\tr.min = min\n\treturn r\n}\n\n// Max sets the maximum date range. A zero value means skipping the maximum range validation.\nfunc (r DateRule) Max(max time.Time) DateRule {\n\tr.max = max\n\treturn r\n}\n\n// Validate checks if the given value is a valid date.\nfunc (r DateRule) Validate(value interface{}) error {\n\tvalue, isNil := Indirect(value)\n\tif isNil || IsEmpty(value) {\n\t\treturn nil\n\t}\n\n\tstr, err := EnsureString(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdate, err := time.Parse(r.layout, str)\n\tif err != nil {\n\t\treturn r.err\n\t}\n\n\tif !r.min.IsZero() && r.min.After(date) || !r.max.IsZero() && date.After(r.max) {\n\t\treturn r.rangeErr\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "date_test.go",
          "type": "blob",
          "size": 2.796875,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDate(t *testing.T) {\n\ttests := []struct {\n\t\ttag    string\n\t\tlayout string\n\t\tvalue  interface{}\n\t\terr    string\n\t}{\n\t\t{\"t1\", time.ANSIC, \"\", \"\"},\n\t\t{\"t2\", time.ANSIC, \"Wed Feb  4 21:00:57 2009\", \"\"},\n\t\t{\"t3\", time.ANSIC, \"Wed Feb  29 21:00:57 2009\", \"must be a valid date\"},\n\t\t{\"t4\", \"2006-01-02\", \"2009-11-12\", \"\"},\n\t\t{\"t5\", \"2006-01-02\", \"2009-11-12 21:00:57\", \"must be a valid date\"},\n\t\t{\"t6\", \"2006-01-02\", \"2009-1-12\", \"must be a valid date\"},\n\t\t{\"t7\", \"2006-01-02\", \"2009-01-12\", \"\"},\n\t\t{\"t8\", \"2006-01-02\", \"2009-01-32\", \"must be a valid date\"},\n\t\t{\"t9\", \"2006-01-02\", 1, \"must be either a string or byte slice\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := Date(test.layout)\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestDateRule_Error(t *testing.T) {\n\tr := Date(time.RFC3339)\n\tassert.Equal(t, \"must be a valid date\", r.Validate(\"0001-01-02T15:04:05Z07:00\").Error())\n\tr2 := r.Min(time.Date(2000, 1, 1, 1, 1, 1, 0, time.UTC))\n\tassert.Equal(t, \"the date is out of range\", r2.Validate(\"1999-01-02T15:04:05Z\").Error())\n\tr = r.Error(\"123\")\n\tr = r.RangeError(\"456\")\n\tassert.Equal(t, \"123\", r.err.Message())\n\tassert.Equal(t, \"456\", r.rangeErr.Message())\n}\n\nfunc TestDateRule_ErrorObject(t *testing.T) {\n\tr := Date(time.RFC3339)\n\tassert.Equal(t, \"must be a valid date\", r.Validate(\"0001-01-02T15:04:05Z07:00\").Error())\n\n\tr = r.ErrorObject(NewError(\"code\", \"abc\"))\n\n\tassert.Equal(t, \"code\", r.err.Code())\n\tassert.Equal(t, \"abc\", r.Validate(\"0001-01-02T15:04:05Z07:00\").Error())\n\n\tr2 := r.Min(time.Date(2000, 1, 1, 1, 1, 1, 0, time.UTC))\n\tassert.Equal(t, \"the date is out of range\", r2.Validate(\"1999-01-02T15:04:05Z\").Error())\n\n\tr = r.ErrorObject(NewError(\"C\", \"def\"))\n\tr = r.RangeErrorObject(NewError(\"D\", \"123\"))\n\n\tassert.Equal(t, \"C\", r.err.Code())\n\tassert.Equal(t, \"def\", r.err.Message())\n\tassert.Equal(t, \"D\", r.rangeErr.Code())\n\tassert.Equal(t, \"123\", r.rangeErr.Message())\n}\n\nfunc TestDateRule_MinMax(t *testing.T) {\n\tr := Date(time.ANSIC)\n\tassert.True(t, r.min.IsZero())\n\tassert.True(t, r.max.IsZero())\n\tr = r.Min(time.Now())\n\tassert.False(t, r.min.IsZero())\n\tassert.True(t, r.max.IsZero())\n\tr = r.Max(time.Now())\n\tassert.False(t, r.max.IsZero())\n\n\tr2 := Date(\"2006-01-02\").Min(time.Date(2000, 12, 1, 0, 0, 0, 0, time.UTC)).Max(time.Date(2020, 2, 1, 0, 0, 0, 0, time.UTC))\n\tassert.Nil(t, r2.Validate(\"2010-01-02\"))\n\terr := r2.Validate(\"1999-01-02\")\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"the date is out of range\", err.Error())\n\t}\n\terr = r2.Validate(\"2021-01-02\")\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"the date is out of range\", err.Error())\n\t}\n}\n"
        },
        {
          "name": "each.go",
          "type": "blob",
          "size": 2.3251953125,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"reflect\"\n\t\"strconv\"\n)\n\n// Each returns a validation rule that loops through an iterable (map, slice or array)\n// and validates each value inside with the provided rules.\n// An empty iterable is considered valid. Use the Required rule to make sure the iterable is not empty.\nfunc Each(rules ...Rule) EachRule {\n\treturn EachRule{\n\t\trules: rules,\n\t}\n}\n\n// EachRule is a validation rule that validates elements in a map/slice/array using the specified list of rules.\ntype EachRule struct {\n\trules []Rule\n}\n\n// Validate loops through the given iterable and calls the Ozzo Validate() method for each value.\nfunc (r EachRule) Validate(value interface{}) error {\n\treturn r.ValidateWithContext(nil, value)\n}\n\n// ValidateWithContext loops through the given iterable and calls the Ozzo ValidateWithContext() method for each value.\nfunc (r EachRule) ValidateWithContext(ctx context.Context, value interface{}) error {\n\terrs := Errors{}\n\n\tv := reflect.ValueOf(value)\n\tswitch v.Kind() {\n\tcase reflect.Map:\n\t\tfor _, k := range v.MapKeys() {\n\t\t\tval := r.getInterface(v.MapIndex(k))\n\t\t\tvar err error\n\t\t\tif ctx == nil {\n\t\t\t\terr = Validate(val, r.rules...)\n\t\t\t} else {\n\t\t\t\terr = ValidateWithContext(ctx, val, r.rules...)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\terrs[r.getString(k)] = err\n\t\t\t}\n\t\t}\n\tcase reflect.Slice, reflect.Array:\n\t\tfor i := 0; i < v.Len(); i++ {\n\t\t\tval := r.getInterface(v.Index(i))\n\t\t\tvar err error\n\t\t\tif ctx == nil {\n\t\t\t\terr = Validate(val, r.rules...)\n\t\t\t} else {\n\t\t\t\terr = ValidateWithContext(ctx, val, r.rules...)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\terrs[strconv.Itoa(i)] = err\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn errors.New(\"must be an iterable (map, slice or array)\")\n\t}\n\n\tif len(errs) > 0 {\n\t\treturn errs\n\t}\n\treturn nil\n}\n\nfunc (r EachRule) getInterface(value reflect.Value) interface{} {\n\tswitch value.Kind() {\n\tcase reflect.Ptr, reflect.Interface:\n\t\tif value.IsNil() {\n\t\t\treturn nil\n\t\t}\n\t\treturn value.Elem().Interface()\n\tdefault:\n\t\treturn value.Interface()\n\t}\n}\n\nfunc (r EachRule) getString(value reflect.Value) string {\n\tswitch value.Kind() {\n\tcase reflect.Ptr, reflect.Interface:\n\t\tif value.IsNil() {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn value.Elem().String()\n\tdefault:\n\t\treturn value.String()\n\t}\n}\n"
        },
        {
          "name": "each_test.go",
          "type": "blob",
          "size": 2.4677734375,
          "content": "package validation\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestEach(t *testing.T) {\n\tvar a *int\n\tvar f = func(v string) string { return v }\n\tvar c0 chan int\n\tc1 := make(chan int)\n\n\ttests := []struct {\n\t\ttag   string\n\t\tvalue interface{}\n\t\terr   string\n\t}{\n\t\t{\"t1\", nil, \"must be an iterable (map, slice or array)\"},\n\t\t{\"t2\", map[string]string{}, \"\"},\n\t\t{\"t3\", map[string]string{\"key1\": \"value1\", \"key2\": \"value2\"}, \"\"},\n\t\t{\"t4\", map[string]string{\"key1\": \"\", \"key2\": \"value2\", \"key3\": \"\"}, \"key1: cannot be blank; key3: cannot be blank.\"},\n\t\t{\"t5\", map[string]map[string]string{\"key1\": {\"key1.1\": \"value1\"}, \"key2\": {\"key2.1\": \"value1\"}}, \"\"},\n\t\t{\"t6\", map[string]map[string]string{\"\": nil}, \": cannot be blank.\"},\n\t\t{\"t7\", map[interface{}]interface{}{}, \"\"},\n\t\t{\"t8\", map[interface{}]interface{}{\"key1\": struct{ foo string }{\"foo\"}}, \"\"},\n\t\t{\"t9\", map[interface{}]interface{}{nil: \"\", \"\": \"\", \"key1\": nil}, \": cannot be blank; key1: cannot be blank.\"},\n\t\t{\"t10\", []string{\"value1\", \"value2\", \"value3\"}, \"\"},\n\t\t{\"t11\", []string{\"\", \"value2\", \"\"}, \"0: cannot be blank; 2: cannot be blank.\"},\n\t\t{\"t12\", []interface{}{struct{ foo string }{\"foo\"}}, \"\"},\n\t\t{\"t13\", []interface{}{nil, a}, \"0: cannot be blank; 1: cannot be blank.\"},\n\t\t{\"t14\", []interface{}{c0, c1, f}, \"0: cannot be blank.\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := Each(Required)\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestEachWithContext(t *testing.T) {\n\trule := Each(WithContext(func(ctx context.Context, value interface{}) error {\n\t\tif !strings.Contains(value.(string), ctx.Value(contains).(string)) {\n\t\t\treturn errors.New(\"unexpected value\")\n\t\t}\n\t\treturn nil\n\t}))\n\tctx1 := context.WithValue(context.Background(), contains, \"abc\")\n\tctx2 := context.WithValue(context.Background(), contains, \"xyz\")\n\n\ttests := []struct {\n\t\ttag   string\n\t\tvalue interface{}\n\t\tctx   context.Context\n\t\terr   string\n\t}{\n\t\t{\"t1.1\", map[string]string{\"key\": \"abc\"}, ctx1, \"\"},\n\t\t{\"t1.2\", map[string]string{\"key\": \"abc\"}, ctx2, \"key: unexpected value.\"},\n\t\t{\"t1.3\", map[string]string{\"key\": \"xyz\"}, ctx1, \"key: unexpected value.\"},\n\t\t{\"t1.4\", map[string]string{\"key\": \"xyz\"}, ctx2, \"\"},\n\t\t{\"t1.5\", []string{\"abc\"}, ctx1, \"\"},\n\t\t{\"t1.6\", []string{\"abc\"}, ctx2, \"0: unexpected value.\"},\n\t\t{\"t1.7\", []string{\"xyz\"}, ctx1, \"0: unexpected value.\"},\n\t\t{\"t1.8\", []string{\"xyz\"}, ctx2, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\terr := ValidateWithContext(test.ctx, test.value, rule)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 3.8076171875,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"text/template\"\n)\n\ntype (\n\t// Error interface represents an validation error\n\tError interface {\n\t\tError() string\n\t\tCode() string\n\t\tMessage() string\n\t\tSetMessage(string) Error\n\t\tParams() map[string]interface{}\n\t\tSetParams(map[string]interface{}) Error\n\t}\n\n\t// ErrorObject is the default validation error\n\t// that implements the Error interface.\n\tErrorObject struct {\n\t\tcode    string\n\t\tmessage string\n\t\tparams  map[string]interface{}\n\t}\n\n\t// Errors represents the validation errors that are indexed by struct field names, map or slice keys.\n\t// values are Error or Errors (for map, slice and array error value is Errors).\n\tErrors map[string]error\n\n\t// InternalError represents an error that should NOT be treated as a validation error.\n\tInternalError interface {\n\t\terror\n\t\tInternalError() error\n\t}\n\n\tinternalError struct {\n\t\terror\n\t}\n)\n\n// NewInternalError wraps a given error into an InternalError.\nfunc NewInternalError(err error) InternalError {\n\treturn internalError{error: err}\n}\n\n// InternalError returns the actual error that it wraps around.\nfunc (e internalError) InternalError() error {\n\treturn e.error\n}\n\n// SetCode set the error's translation code.\nfunc (e ErrorObject) SetCode(code string) Error {\n\te.code = code\n\treturn e\n}\n\n// Code get the error's translation code.\nfunc (e ErrorObject) Code() string {\n\treturn e.code\n}\n\n// SetParams set the error's params.\nfunc (e ErrorObject) SetParams(params map[string]interface{}) Error {\n\te.params = params\n\treturn e\n}\n\n// AddParam add parameter to the error's parameters.\nfunc (e ErrorObject) AddParam(name string, value interface{}) Error {\n\tif e.params == nil {\n\t\te.params = make(map[string]interface{})\n\t}\n\n\te.params[name] = value\n\treturn e\n}\n\n// Params returns the error's params.\nfunc (e ErrorObject) Params() map[string]interface{} {\n\treturn e.params\n}\n\n// SetMessage set the error's message.\nfunc (e ErrorObject) SetMessage(message string) Error {\n\te.message = message\n\treturn e\n}\n\n// Message return the error's message.\nfunc (e ErrorObject) Message() string {\n\treturn e.message\n}\n\n// Error returns the error message.\nfunc (e ErrorObject) Error() string {\n\tif len(e.params) == 0 {\n\t\treturn e.message\n\t}\n\n\tres := bytes.Buffer{}\n\t_ = template.Must(template.New(\"err\").Parse(e.message)).Execute(&res, e.params)\n\n\treturn res.String()\n}\n\n// Error returns the error string of Errors.\nfunc (es Errors) Error() string {\n\tif len(es) == 0 {\n\t\treturn \"\"\n\t}\n\n\tkeys := make([]string, len(es))\n\ti := 0\n\tfor key := range es {\n\t\tkeys[i] = key\n\t\ti++\n\t}\n\tsort.Strings(keys)\n\n\tvar s strings.Builder\n\tfor i, key := range keys {\n\t\tif i > 0 {\n\t\t\ts.WriteString(\"; \")\n\t\t}\n\t\tif errs, ok := es[key].(Errors); ok {\n\t\t\t_, _ = fmt.Fprintf(&s, \"%v: (%v)\", key, errs)\n\t\t} else {\n\t\t\t_, _ = fmt.Fprintf(&s, \"%v: %v\", key, es[key].Error())\n\t\t}\n\t}\n\ts.WriteString(\".\")\n\treturn s.String()\n}\n\n// MarshalJSON converts the Errors into a valid JSON.\nfunc (es Errors) MarshalJSON() ([]byte, error) {\n\terrs := map[string]interface{}{}\n\tfor key, err := range es {\n\t\tif ms, ok := err.(json.Marshaler); ok {\n\t\t\terrs[key] = ms\n\t\t} else {\n\t\t\terrs[key] = err.Error()\n\t\t}\n\t}\n\treturn json.Marshal(errs)\n}\n\n// Filter removes all nils from Errors and returns back the updated Errors as an error.\n// If the length of Errors becomes 0, it will return nil.\nfunc (es Errors) Filter() error {\n\tfor key, value := range es {\n\t\tif value == nil {\n\t\t\tdelete(es, key)\n\t\t}\n\t}\n\tif len(es) == 0 {\n\t\treturn nil\n\t}\n\treturn es\n}\n\n// NewError create new validation error.\nfunc NewError(code, message string) Error {\n\treturn ErrorObject{\n\t\tcode:    code,\n\t\tmessage: message,\n\t}\n}\n\n// Assert that our ErrorObject implements the Error interface.\nvar _ Error = ErrorObject{}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 3.9853515625,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewInternalError(t *testing.T) {\n\terr := NewInternalError(errors.New(\"abc\"))\n\tif assert.NotNil(t, err.InternalError()) {\n\t\tassert.Equal(t, \"abc\", err.InternalError().Error())\n\t}\n}\n\nfunc TestErrors_Error(t *testing.T) {\n\terrs := Errors{\n\t\t\"B\": errors.New(\"B1\"),\n\t\t\"C\": errors.New(\"C1\"),\n\t\t\"A\": errors.New(\"A1\"),\n\t}\n\tassert.Equal(t, \"A: A1; B: B1; C: C1.\", errs.Error())\n\n\terrs = Errors{\n\t\t\"B\": errors.New(\"B1\"),\n\t}\n\tassert.Equal(t, \"B: B1.\", errs.Error())\n\n\terrs = Errors{}\n\tassert.Equal(t, \"\", errs.Error())\n}\n\nfunc TestErrors_MarshalMessage(t *testing.T) {\n\terrs := Errors{\n\t\t\"A\": errors.New(\"A1\"),\n\t\t\"B\": Errors{\n\t\t\t\"2\": errors.New(\"B1\"),\n\t\t},\n\t}\n\terrsJSON, err := errs.MarshalJSON()\n\tassert.Nil(t, err)\n\tassert.Equal(t, \"{\\\"A\\\":\\\"A1\\\",\\\"B\\\":{\\\"2\\\":\\\"B1\\\"}}\", string(errsJSON))\n}\n\nfunc TestErrors_Filter(t *testing.T) {\n\terrs := Errors{\n\t\t\"B\": errors.New(\"B1\"),\n\t\t\"C\": nil,\n\t\t\"A\": errors.New(\"A1\"),\n\t}\n\terr := errs.Filter()\n\tassert.Equal(t, 2, len(errs))\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"A: A1; B: B1.\", err.Error())\n\t}\n\n\terrs = Errors{}\n\tassert.Nil(t, errs.Filter())\n\n\terrs = Errors{\n\t\t\"B\": nil,\n\t\t\"C\": nil,\n\t}\n\n\tassert.Nil(t, errs.Filter())\n}\n\nfunc TestErrorObject_SetCode(t *testing.T) {\n\terr := NewError(\"A\", \"msg\").(ErrorObject)\n\n\tassert.Equal(t, err.code, \"A\")\n\tassert.Equal(t, err.Code(), \"A\")\n\n\terr = err.SetCode(\"B\").(ErrorObject)\n\tassert.Equal(t, \"B\", err.code)\n}\n\nfunc TestErrorObject_Code(t *testing.T) {\n\terr := NewError(\"A\", \"msg\").(ErrorObject)\n\n\tassert.Equal(t, err.Code(), \"A\")\n}\n\nfunc TestErrorObject_SetMessage(t *testing.T) {\n\terr := NewError(\"code\", \"A\").(ErrorObject)\n\n\tassert.Equal(t, err.message, \"A\")\n\tassert.Equal(t, err.Message(), \"A\")\n\n\terr = err.SetMessage(\"abc\").(ErrorObject)\n\tassert.Equal(t, err.message, \"abc\")\n\tassert.Equal(t, err.Message(), \"abc\")\n}\n\nfunc TestErrorObject_Message(t *testing.T) {\n\terr := NewError(\"code\", \"A\").(ErrorObject)\n\n\tassert.Equal(t, err.message, \"A\")\n\tassert.Equal(t, err.Message(), \"A\")\n}\n\nfunc TestErrorObject_Params(t *testing.T) {\n\tp := map[string]interface{}{\"A\": \"val1\", \"AA\": \"val2\"}\n\n\terr := NewError(\"code\", \"A\").(ErrorObject)\n\terr = err.SetParams(p).(ErrorObject)\n\terr = err.SetMessage(\"B\").(ErrorObject)\n\n\tassert.Equal(t, err.params, p)\n\tassert.Equal(t, err.Params(), p)\n}\n\nfunc TestErrorObject_AddParam2(t *testing.T) {\n\tp := map[string]interface{}{\"key\": \"val\"}\n\terr := NewError(\"code\", \"A\").(ErrorObject)\n\terr = err.AddParam(\"key\", \"val\").(ErrorObject)\n\n\tassert.Equal(t, err.params, p)\n\tassert.Equal(t, err.Params(), p)\n}\n\nfunc TestErrorObject_AddParam(t *testing.T) {\n\tp := map[string]interface{}{\"A\": \"val1\", \"B\": \"val2\"}\n\n\terr := NewError(\"code\", \"A\").(ErrorObject)\n\terr = err.SetParams(p).(ErrorObject)\n\terr = err.AddParam(\"C\", \"val3\").(ErrorObject)\n\n\tp[\"C\"] = \"val3\"\n\n\tassert.Equal(t, err.params, p)\n\tassert.Equal(t, err.Params(), p)\n}\n\nfunc TestError_Code(t *testing.T) {\n\terr := NewError(\"A\", \"msg\")\n\n\tassert.Equal(t, err.Code(), \"A\")\n}\n\nfunc TestError_SetMessage(t *testing.T) {\n\terr := NewError(\"code\", \"A\")\n\n\tassert.Equal(t, err.Message(), \"A\")\n\n\terr = err.SetMessage(\"abc\")\n\tassert.Equal(t, err.Message(), \"abc\")\n}\n\nfunc TestError_Message(t *testing.T) {\n\terr := NewError(\"code\", \"A\")\n\n\tassert.Equal(t, err.Message(), \"A\")\n}\n\nfunc TestError_Params(t *testing.T) {\n\tp := map[string]interface{}{\"A\": \"val1\", \"AA\": \"val2\"}\n\n\terr := NewError(\"code\", \"A\")\n\terr = err.SetParams(p)\n\terr = err.SetMessage(\"B\")\n\n\tassert.Equal(t, err.Params(), p)\n}\n\nfunc TestValidationError(t *testing.T) {\n\tparams := map[string]interface{}{\n\t\t\"A\": \"B\",\n\t}\n\n\terr := NewError(\"code\", \"msg\")\n\terr = err.SetParams(params)\n\n\tassert.Equal(t, err.Code(), \"code\")\n\tassert.Equal(t, err.Message(), \"msg\")\n\tassert.Equal(t, err.Params(), params)\n\n\tparams = map[string]interface{}{\"min\": 1}\n\terr = err.SetParams(params)\n\n\tassert.Equal(t, err.Params(), params)\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 5.44140625,
          "content": "package validation_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\n\t\"github.com/go-ozzo/ozzo-validation/v4\"\n\t\"github.com/go-ozzo/ozzo-validation/v4/is\"\n)\n\ntype Address struct {\n\tStreet string\n\tCity   string\n\tState  string\n\tZip    string\n}\n\ntype Customer struct {\n\tName    string\n\tGender  string\n\tEmail   string\n\tAddress Address\n}\n\nfunc (a Address) Validate() error {\n\treturn validation.ValidateStruct(&a,\n\t\t// Street cannot be empty, and the length must between 5 and 50\n\t\tvalidation.Field(&a.Street, validation.Required, validation.Length(5, 50)),\n\t\t// City cannot be empty, and the length must between 5 and 50\n\t\tvalidation.Field(&a.City, validation.Required, validation.Length(5, 50)),\n\t\t// State cannot be empty, and must be a string consisting of two letters in upper case\n\t\tvalidation.Field(&a.State, validation.Required, validation.Match(regexp.MustCompile(\"^[A-Z]{2}$\"))),\n\t\t// State cannot be empty, and must be a string consisting of five digits\n\t\tvalidation.Field(&a.Zip, validation.Required, validation.Match(regexp.MustCompile(\"^[0-9]{5}$\"))),\n\t)\n}\n\nfunc (c Customer) Validate() error {\n\treturn validation.ValidateStruct(&c,\n\t\t// Name cannot be empty, and the length must be between 5 and 20.\n\t\tvalidation.Field(&c.Name, validation.Required, validation.Length(5, 20)),\n\t\t// Gender is optional, and should be either \"Female\" or \"Male\".\n\t\tvalidation.Field(&c.Gender, validation.In(\"Female\", \"Male\")),\n\t\t// Email cannot be empty and should be in a valid email format.\n\t\tvalidation.Field(&c.Email, validation.Required, is.Email),\n\t\t// Validate Address using its own validation rules\n\t\tvalidation.Field(&c.Address),\n\t)\n}\n\nfunc Example() {\n\tc := Customer{\n\t\tName:  \"Qiang Xue\",\n\t\tEmail: \"q\",\n\t\tAddress: Address{\n\t\t\tStreet: \"123 Main Street\",\n\t\t\tCity:   \"Unknown\",\n\t\t\tState:  \"Virginia\",\n\t\t\tZip:    \"12345\",\n\t\t},\n\t}\n\n\terr := c.Validate()\n\tfmt.Println(err)\n\t// Output:\n\t// Address: (State: must be in a valid format.); Email: must be a valid email address.\n}\n\nfunc Example_second() {\n\tdata := \"example\"\n\terr := validation.Validate(data,\n\t\tvalidation.Required,       // not empty\n\t\tvalidation.Length(5, 100), // length between 5 and 100\n\t\tis.URL,                    // is a valid URL\n\t)\n\tfmt.Println(err)\n\t// Output:\n\t// must be a valid URL\n}\n\nfunc Example_third() {\n\taddresses := []Address{\n\t\t{State: \"MD\", Zip: \"12345\"},\n\t\t{Street: \"123 Main St\", City: \"Vienna\", State: \"VA\", Zip: \"12345\"},\n\t\t{City: \"Unknown\", State: \"NC\", Zip: \"123\"},\n\t}\n\terr := validation.Validate(addresses)\n\tfmt.Println(err)\n\t// Output:\n\t// 0: (City: cannot be blank; Street: cannot be blank.); 2: (Street: cannot be blank; Zip: must be in a valid format.).\n}\n\nfunc Example_four() {\n\tc := Customer{\n\t\tName:  \"Qiang Xue\",\n\t\tEmail: \"q\",\n\t\tAddress: Address{\n\t\t\tState: \"Virginia\",\n\t\t},\n\t}\n\n\terr := validation.Errors{\n\t\t\"name\":  validation.Validate(c.Name, validation.Required, validation.Length(5, 20)),\n\t\t\"email\": validation.Validate(c.Name, validation.Required, is.Email),\n\t\t\"zip\":   validation.Validate(c.Address.Zip, validation.Required, validation.Match(regexp.MustCompile(\"^[0-9]{5}$\"))),\n\t}.Filter()\n\tfmt.Println(err)\n\t// Output:\n\t// email: must be a valid email address; zip: cannot be blank.\n}\n\nfunc Example_five() {\n\ttype Employee struct {\n\t\tName string\n\t}\n\n\ttype Manager struct {\n\t\tEmployee\n\t\tLevel int\n\t}\n\n\tm := Manager{}\n\terr := validation.ValidateStruct(&m,\n\t\tvalidation.Field(&m.Name, validation.Required),\n\t\tvalidation.Field(&m.Level, validation.Required),\n\t)\n\tfmt.Println(err)\n\t// Output:\n\t// Level: cannot be blank; Name: cannot be blank.\n}\n\ntype contextKey int\n\nfunc Example_six() {\n\tkey := contextKey(1)\n\trule := validation.WithContext(func(ctx context.Context, value interface{}) error {\n\t\ts, _ := value.(string)\n\t\tif ctx.Value(key) == s {\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.New(\"unexpected value\")\n\t})\n\tctx := context.WithValue(context.Background(), key, \"good sample\")\n\n\terr1 := validation.ValidateWithContext(ctx, \"bad sample\", rule)\n\tfmt.Println(err1)\n\n\terr2 := validation.ValidateWithContext(ctx, \"good sample\", rule)\n\tfmt.Println(err2)\n\n\t// Output:\n\t// unexpected value\n\t// <nil>\n}\n\nfunc Example_seven() {\n\tc := map[string]interface{}{\n\t\t\"Name\":  \"Qiang Xue\",\n\t\t\"Email\": \"q\",\n\t\t\"Address\": map[string]interface{}{\n\t\t\t\"Street\": \"123\",\n\t\t\t\"City\":   \"Unknown\",\n\t\t\t\"State\":  \"Virginia\",\n\t\t\t\"Zip\":    \"12345\",\n\t\t},\n\t}\n\n\terr := validation.Validate(c,\n\t\tvalidation.Map(\n\t\t\t// Name cannot be empty, and the length must be between 5 and 20.\n\t\t\tvalidation.Key(\"Name\", validation.Required, validation.Length(5, 20)),\n\t\t\t// Email cannot be empty and should be in a valid email format.\n\t\t\tvalidation.Key(\"Email\", validation.Required, is.Email),\n\t\t\t// Validate Address using its own validation rules\n\t\t\tvalidation.Key(\"Address\", validation.Map(\n\t\t\t\t// Street cannot be empty, and the length must between 5 and 50\n\t\t\t\tvalidation.Key(\"Street\", validation.Required, validation.Length(5, 50)),\n\t\t\t\t// City cannot be empty, and the length must between 5 and 50\n\t\t\t\tvalidation.Key(\"City\", validation.Required, validation.Length(5, 50)),\n\t\t\t\t// State cannot be empty, and must be a string consisting of two letters in upper case\n\t\t\t\tvalidation.Key(\"State\", validation.Required, validation.Match(regexp.MustCompile(\"^[A-Z]{2}$\"))),\n\t\t\t\t// State cannot be empty, and must be a string consisting of five digits\n\t\t\t\tvalidation.Key(\"Zip\", validation.Required, validation.Match(regexp.MustCompile(\"^[0-9]{5}$\"))),\n\t\t\t)),\n\t\t),\n\t)\n\tfmt.Println(err)\n\t// Output:\n\t// Address: (State: must be in a valid format; Street: the length must be between 5 and 50.); Email: must be a valid email address.\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1689453125,
          "content": "module github.com/go-ozzo/ozzo-validation/v4\n\ngo 1.13\n\nrequire (\n\tgithub.com/asaskevich/govalidator v0.0.0-20200108200545-475eaeb16496\n\tgithub.com/stretchr/testify v1.4.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.2587890625,
          "content": "github.com/asaskevich/govalidator v0.0.0-20200108200545-475eaeb16496 h1:zV3ejI06GQ59hwDQAvmK1qxOQGB3WuVTRoY0okPTAv0=\ngithub.com/asaskevich/govalidator v0.0.0-20200108200545-475eaeb16496/go.mod h1:oGkLhpf+kjZl6xBf758TQhh5XrAeiJv/7FRz/2spLIg=\ngithub.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0 h1:4G4v2dO3VZwixGIRoQ5Lfboy6nUhCyYzaqnIAPPhYs4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n"
        },
        {
          "name": "in.go",
          "type": "blob",
          "size": 1.5,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"reflect\"\n)\n\n// ErrInInvalid is the error that returns in case of an invalid value for \"in\" rule.\nvar ErrInInvalid = NewError(\"validation_in_invalid\", \"must be a valid value\")\n\n// In returns a validation rule that checks if a value can be found in the given list of values.\n// reflect.DeepEqual() will be used to determine if two values are equal.\n// For more details please refer to https://golang.org/pkg/reflect/#DeepEqual\n// An empty value is considered valid. Use the Required rule to make sure a value is not empty.\nfunc In(values ...interface{}) InRule {\n\treturn InRule{\n\t\telements: values,\n\t\terr:      ErrInInvalid,\n\t}\n}\n\n// InRule is a validation rule that validates if a value can be found in the given list of values.\ntype InRule struct {\n\telements []interface{}\n\terr      Error\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r InRule) Validate(value interface{}) error {\n\tvalue, isNil := Indirect(value)\n\tif isNil || IsEmpty(value) {\n\t\treturn nil\n\t}\n\n\tfor _, e := range r.elements {\n\t\tif reflect.DeepEqual(e, value) {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn r.err\n}\n\n// Error sets the error message for the rule.\nfunc (r InRule) Error(message string) InRule {\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r InRule) ErrorObject(err Error) InRule {\n\tr.err = err\n\treturn r\n}\n"
        },
        {
          "name": "in_test.go",
          "type": "blob",
          "size": 1.36328125,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIn(t *testing.T) {\n\tvar v = 1\n\tvar v2 *int\n\ttests := []struct {\n\t\ttag    string\n\t\tvalues []interface{}\n\t\tvalue  interface{}\n\t\terr    string\n\t}{\n\t\t{\"t0\", []interface{}{1, 2}, 0, \"\"},\n\t\t{\"t1\", []interface{}{1, 2}, 1, \"\"},\n\t\t{\"t2\", []interface{}{1, 2}, 2, \"\"},\n\t\t{\"t3\", []interface{}{1, 2}, 3, \"must be a valid value\"},\n\t\t{\"t4\", []interface{}{}, 3, \"must be a valid value\"},\n\t\t{\"t5\", []interface{}{1, 2}, \"1\", \"must be a valid value\"},\n\t\t{\"t6\", []interface{}{1, 2}, &v, \"\"},\n\t\t{\"t7\", []interface{}{1, 2}, v2, \"\"},\n\t\t{\"t8\", []interface{}{[]byte{1}, 1, 2}, []byte{1}, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := In(test.values...)\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc Test_InRule_Error(t *testing.T) {\n\tr := In(1, 2, 3)\n\tval := 4\n\tassert.Equal(t, \"must be a valid value\", r.Validate(&val).Error())\n\tr = r.Error(\"123\")\n\tassert.Equal(t, \"123\", r.err.Message())\n}\n\nfunc TestInRule_ErrorObject(t *testing.T) {\n\tr := In(1, 2, 3)\n\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, err.Code(), r.err.Code())\n\tassert.Equal(t, err.Message(), r.err.Message())\n}\n"
        },
        {
          "name": "is",
          "type": "tree",
          "content": null
        },
        {
          "name": "length.go",
          "type": "blob",
          "size": 3.3837890625,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"unicode/utf8\"\n)\n\nvar (\n\t// ErrLengthTooLong is the error that returns in case of too long length.\n\tErrLengthTooLong = NewError(\"validation_length_too_long\", \"the length must be no more than {{.max}}\")\n\t// ErrLengthTooShort is the error that returns in case of too short length.\n\tErrLengthTooShort = NewError(\"validation_length_too_short\", \"the length must be no less than {{.min}}\")\n\t// ErrLengthInvalid is the error that returns in case of an invalid length.\n\tErrLengthInvalid = NewError(\"validation_length_invalid\", \"the length must be exactly {{.min}}\")\n\t// ErrLengthOutOfRange is the error that returns in case of out of range length.\n\tErrLengthOutOfRange = NewError(\"validation_length_out_of_range\", \"the length must be between {{.min}} and {{.max}}\")\n\t// ErrLengthEmptyRequired is the error that returns in case of non-empty value.\n\tErrLengthEmptyRequired = NewError(\"validation_length_empty_required\", \"the value must be empty\")\n)\n\n// Length returns a validation rule that checks if a value's length is within the specified range.\n// If max is 0, it means there is no upper bound for the length.\n// This rule should only be used for validating strings, slices, maps, and arrays.\n// An empty value is considered valid. Use the Required rule to make sure a value is not empty.\nfunc Length(min, max int) LengthRule {\n\treturn LengthRule{min: min, max: max, err: buildLengthRuleError(min, max)}\n}\n\n// RuneLength returns a validation rule that checks if a string's rune length is within the specified range.\n// If max is 0, it means there is no upper bound for the length.\n// This rule should only be used for validating strings, slices, maps, and arrays.\n// An empty value is considered valid. Use the Required rule to make sure a value is not empty.\n// If the value being validated is not a string, the rule works the same as Length.\nfunc RuneLength(min, max int) LengthRule {\n\tr := Length(min, max)\n\tr.rune = true\n\n\treturn r\n}\n\n// LengthRule is a validation rule that checks if a value's length is within the specified range.\ntype LengthRule struct {\n\terr Error\n\n\tmin, max int\n\trune     bool\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r LengthRule) Validate(value interface{}) error {\n\tvalue, isNil := Indirect(value)\n\tif isNil || IsEmpty(value) {\n\t\treturn nil\n\t}\n\n\tvar (\n\t\tl   int\n\t\terr error\n\t)\n\tif s, ok := value.(string); ok && r.rune {\n\t\tl = utf8.RuneCountInString(s)\n\t} else if l, err = LengthOfValue(value); err != nil {\n\t\treturn err\n\t}\n\n\tif r.min > 0 && l < r.min || r.max > 0 && l > r.max || r.min == 0 && r.max == 0 && l > 0 {\n\t\treturn r.err\n\t}\n\n\treturn nil\n}\n\n// Error sets the error message for the rule.\nfunc (r LengthRule) Error(message string) LengthRule {\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r LengthRule) ErrorObject(err Error) LengthRule {\n\tr.err = err\n\treturn r\n}\n\nfunc buildLengthRuleError(min, max int) (err Error) {\n\tif min == 0 && max > 0 {\n\t\terr = ErrLengthTooLong\n\t} else if min > 0 && max == 0 {\n\t\terr = ErrLengthTooShort\n\t} else if min > 0 && max > 0 {\n\t\tif min == max {\n\t\t\terr = ErrLengthInvalid\n\t\t} else {\n\t\t\terr = ErrLengthOutOfRange\n\t\t}\n\t} else {\n\t\terr = ErrLengthEmptyRequired\n\t}\n\n\treturn err.SetParams(map[string]interface{}{\"min\": min, \"max\": max})\n}\n"
        },
        {
          "name": "length_test.go",
          "type": "blob",
          "size": 3.197265625,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"database/sql\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestLength(t *testing.T) {\n\tvar v *string\n\ttests := []struct {\n\t\ttag      string\n\t\tmin, max int\n\t\tvalue    interface{}\n\t\terr      string\n\t}{\n\t\t{\"t1\", 2, 4, \"abc\", \"\"},\n\t\t{\"t2\", 2, 4, \"\", \"\"},\n\t\t{\"t3\", 2, 4, \"abcdf\", \"the length must be between 2 and 4\"},\n\t\t{\"t4\", 0, 4, \"ab\", \"\"},\n\t\t{\"t5\", 0, 4, \"abcde\", \"the length must be no more than 4\"},\n\t\t{\"t6\", 2, 0, \"ab\", \"\"},\n\t\t{\"t7\", 2, 0, \"a\", \"the length must be no less than 2\"},\n\t\t{\"t8\", 2, 0, v, \"\"},\n\t\t{\"t9\", 2, 0, 123, \"cannot get the length of int\"},\n\t\t{\"t10\", 2, 4, sql.NullString{String: \"abc\", Valid: true}, \"\"},\n\t\t{\"t11\", 2, 4, sql.NullString{String: \"\", Valid: true}, \"\"},\n\t\t{\"t12\", 2, 4, &sql.NullString{String: \"abc\", Valid: true}, \"\"},\n\t\t{\"t13\", 2, 2, \"abcdf\", \"the length must be exactly 2\"},\n\t\t{\"t14\", 2, 2, \"ab\", \"\"},\n\t\t{\"t15\", 0, 0, \"\", \"\"},\n\t\t{\"t16\", 0, 0, \"ab\", \"the value must be empty\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := Length(test.min, test.max)\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestRuneLength(t *testing.T) {\n\tvar v *string\n\ttests := []struct {\n\t\ttag      string\n\t\tmin, max int\n\t\tvalue    interface{}\n\t\terr      string\n\t}{\n\t\t{\"t1\", 2, 4, \"abc\", \"\"},\n\t\t{\"t1.1\", 2, 3, \"\", \"\"},\n\t\t{\"t1.2\", 2, 3, \"\", \"\"},\n\t\t{\"t1.3\", 2, 3, \"\", \"the length must be between 2 and 3\"},\n\t\t{\"t1.4\", 2, 3, \"\", \"the length must be between 2 and 3\"},\n\t\t{\"t2\", 2, 4, \"\", \"\"},\n\t\t{\"t3\", 2, 4, \"abcdf\", \"the length must be between 2 and 4\"},\n\t\t{\"t4\", 0, 4, \"ab\", \"\"},\n\t\t{\"t5\", 0, 4, \"abcde\", \"the length must be no more than 4\"},\n\t\t{\"t6\", 2, 0, \"ab\", \"\"},\n\t\t{\"t7\", 2, 0, \"a\", \"the length must be no less than 2\"},\n\t\t{\"t8\", 2, 0, v, \"\"},\n\t\t{\"t9\", 2, 0, 123, \"cannot get the length of int\"},\n\t\t{\"t10\", 2, 4, sql.NullString{String: \"abc\", Valid: true}, \"\"},\n\t\t{\"t11\", 2, 4, sql.NullString{String: \"\", Valid: true}, \"\"},\n\t\t{\"t12\", 2, 4, &sql.NullString{String: \"abc\", Valid: true}, \"\"},\n\t\t{\"t13\", 2, 3, &sql.NullString{String: \"\", Valid: true}, \"\"},\n\t\t{\"t14\", 2, 3, &sql.NullString{String: \"\", Valid: true}, \"the length must be between 2 and 3\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := RuneLength(test.min, test.max)\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc Test_LengthRule_Error(t *testing.T) {\n\tr := Length(10, 20)\n\tassert.Equal(t, \"the length must be between 10 and 20\", r.Validate(\"abc\").Error())\n\n\tr = Length(0, 20)\n\tassert.Equal(t, \"the length must be no more than 20\", r.Validate(make([]string, 21)).Error())\n\n\tr = Length(10, 0)\n\tassert.Equal(t, \"the length must be no less than 10\", r.Validate([9]string{}).Error())\n\n\tr = Length(0, 0)\n\tassert.Equal(t, \"validation_length_empty_required\", r.err.Code())\n\n\tr = r.Error(\"123\")\n\tassert.Equal(t, \"123\", r.err.Message())\n}\n\nfunc TestLengthRule_ErrorObject(t *testing.T) {\n\tr := Length(10, 20)\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, err.Code(), r.err.Code())\n\tassert.Equal(t, err.Message(), r.err.Message())\n}\n"
        },
        {
          "name": "map.go",
          "type": "blob",
          "size": 3.7109375,
          "content": "package validation\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar (\n\t// ErrNotMap is the error that the value being validated is not a map.\n\tErrNotMap = errors.New(\"only a map can be validated\")\n\n\t// ErrKeyWrongType is the error returned in case of an incorrect key type.\n\tErrKeyWrongType = NewError(\"validation_key_wrong_type\", \"key not the correct type\")\n\n\t// ErrKeyMissing is the error returned in case of a missing key.\n\tErrKeyMissing = NewError(\"validation_key_missing\", \"required key is missing\")\n\n\t// ErrKeyUnexpected is the error returned in case of an unexpected key.\n\tErrKeyUnexpected = NewError(\"validation_key_unexpected\", \"key not expected\")\n)\n\ntype (\n\t// MapRule represents a rule set associated with a map.\n\tMapRule struct {\n\t\tkeys           []*KeyRules\n\t\tallowExtraKeys bool\n\t}\n\n\t// KeyRules represents a rule set associated with a map key.\n\tKeyRules struct {\n\t\tkey      interface{}\n\t\toptional bool\n\t\trules    []Rule\n\t}\n)\n\n// Map returns a validation rule that checks the keys and values of a map.\n// This rule should only be used for validating maps, or a validation error will be reported.\n// Use Key() to specify map keys that need to be validated. Each Key() call specifies a single key which can\n// be associated with multiple rules.\n// For example,\n//    validation.Map(\n//        validation.Key(\"Name\", validation.Required),\n//        validation.Key(\"Value\", validation.Required, validation.Length(5, 10)),\n//    )\n//\n// A nil value is considered valid. Use the Required rule to make sure a map value is present.\nfunc Map(keys ...*KeyRules) MapRule {\n\treturn MapRule{keys: keys}\n}\n\n// AllowExtraKeys configures the rule to ignore extra keys.\nfunc (r MapRule) AllowExtraKeys() MapRule {\n\tr.allowExtraKeys = true\n\treturn r\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r MapRule) Validate(m interface{}) error {\n\treturn r.ValidateWithContext(nil, m)\n}\n\n// ValidateWithContext checks if the given value is valid or not.\nfunc (r MapRule) ValidateWithContext(ctx context.Context, m interface{}) error {\n\tvalue := reflect.ValueOf(m)\n\tif value.Kind() == reflect.Ptr {\n\t\tvalue = value.Elem()\n\t}\n\tif value.Kind() != reflect.Map {\n\t\t// must be a map\n\t\treturn NewInternalError(ErrNotMap)\n\t}\n\tif value.IsNil() {\n\t\t// treat a nil map as valid\n\t\treturn nil\n\t}\n\n\terrs := Errors{}\n\tkt := value.Type().Key()\n\n\tvar extraKeys map[interface{}]bool\n\tif !r.allowExtraKeys {\n\t\textraKeys = make(map[interface{}]bool, value.Len())\n\t\tfor _, k := range value.MapKeys() {\n\t\t\textraKeys[k.Interface()] = true\n\t\t}\n\t}\n\n\tfor _, kr := range r.keys {\n\t\tvar err error\n\t\tif kv := reflect.ValueOf(kr.key); !kt.AssignableTo(kv.Type()) {\n\t\t\terr = ErrKeyWrongType\n\t\t} else if vv := value.MapIndex(kv); !vv.IsValid() {\n\t\t\tif !kr.optional {\n\t\t\t\terr = ErrKeyMissing\n\t\t\t}\n\t\t} else if ctx == nil {\n\t\t\terr = Validate(vv.Interface(), kr.rules...)\n\t\t} else {\n\t\t\terr = ValidateWithContext(ctx, vv.Interface(), kr.rules...)\n\t\t}\n\t\tif err != nil {\n\t\t\tif ie, ok := err.(InternalError); ok && ie.InternalError() != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\terrs[getErrorKeyName(kr.key)] = err\n\t\t}\n\t\tif !r.allowExtraKeys {\n\t\t\tdelete(extraKeys, kr.key)\n\t\t}\n\t}\n\n\tif !r.allowExtraKeys {\n\t\tfor key := range extraKeys {\n\t\t\terrs[getErrorKeyName(key)] = ErrKeyUnexpected\n\t\t}\n\t}\n\n\tif len(errs) > 0 {\n\t\treturn errs\n\t}\n\treturn nil\n}\n\n// Key specifies a map key and the corresponding validation rules.\nfunc Key(key interface{}, rules ...Rule) *KeyRules {\n\treturn &KeyRules{\n\t\tkey:   key,\n\t\trules: rules,\n\t}\n}\n\n// Optional configures the rule to ignore the key if missing.\nfunc (r *KeyRules) Optional() *KeyRules {\n\tr.optional = true\n\treturn r\n}\n\n// getErrorKeyName returns the name that should be used to represent the validation error of a map key.\nfunc getErrorKeyName(key interface{}) string {\n\treturn fmt.Sprintf(\"%v\", key)\n}\n"
        },
        {
          "name": "map_test.go",
          "type": "blob",
          "size": 5.5146484375,
          "content": "package validation\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMap(t *testing.T) {\n\tvar m0 map[string]interface{}\n\tm1 := map[string]interface{}{\"A\": \"abc\", \"B\": \"xyz\", \"c\": \"abc\", \"D\": (*string)(nil), \"F\": (*String123)(nil), \"H\": []string{\"abc\", \"abc\"}, \"I\": map[string]string{\"foo\": \"abc\"}}\n\tm2 := map[string]interface{}{\"E\": String123(\"xyz\"), \"F\": (*String123)(nil)}\n\tm3 := map[string]interface{}{\"M3\": Model3{}}\n\tm4 := map[string]interface{}{\"M3\": Model3{A: \"abc\"}}\n\tm5 := map[string]interface{}{\"A\": \"internal\", \"B\": \"\"}\n\tm6 := map[int]string{11: \"abc\", 22: \"xyz\"}\n\ttests := []struct {\n\t\ttag   string\n\t\tmodel interface{}\n\t\trules []*KeyRules\n\t\terr   string\n\t}{\n\t\t// empty rules\n\t\t{\"t1.1\", m1, []*KeyRules{}, \"\"},\n\t\t{\"t1.2\", m1, []*KeyRules{Key(\"A\"), Key(\"B\")}, \"\"},\n\t\t// normal rules\n\t\t{\"t2.1\", m1, []*KeyRules{Key(\"A\", &validateAbc{}), Key(\"B\", &validateXyz{})}, \"\"},\n\t\t{\"t2.2\", m1, []*KeyRules{Key(\"A\", &validateXyz{}), Key(\"B\", &validateAbc{})}, \"A: error xyz; B: error abc.\"},\n\t\t{\"t2.3\", m1, []*KeyRules{Key(\"A\", &validateXyz{}), Key(\"c\", &validateXyz{})}, \"A: error xyz; c: error xyz.\"},\n\t\t{\"t2.4\", m1, []*KeyRules{Key(\"D\", Length(0, 5))}, \"\"},\n\t\t{\"t2.5\", m1, []*KeyRules{Key(\"F\", Length(0, 5))}, \"\"},\n\t\t{\"t2.6\", m1, []*KeyRules{Key(\"H\", Each(&validateAbc{})), Key(\"I\", Each(&validateAbc{}))}, \"\"},\n\t\t{\"t2.7\", m1, []*KeyRules{Key(\"H\", Each(&validateXyz{})), Key(\"I\", Each(&validateXyz{}))}, \"H: (0: error xyz; 1: error xyz.); I: (foo: error xyz.).\"},\n\t\t{\"t2.8\", m1, []*KeyRules{Key(\"I\", Map(Key(\"foo\", &validateAbc{})))}, \"\"},\n\t\t{\"t2.9\", m1, []*KeyRules{Key(\"I\", Map(Key(\"foo\", &validateXyz{})))}, \"I: (foo: error xyz.).\"},\n\t\t// non-map value\n\t\t{\"t3.1\", &m1, []*KeyRules{}, \"\"},\n\t\t{\"t3.2\", nil, []*KeyRules{}, ErrNotMap.Error()},\n\t\t{\"t3.3\", m0, []*KeyRules{}, \"\"},\n\t\t{\"t3.4\", &m0, []*KeyRules{}, \"\"},\n\t\t{\"t3.5\", 123, []*KeyRules{}, ErrNotMap.Error()},\n\t\t// invalid key spec\n\t\t{\"t4.1\", m1, []*KeyRules{Key(123)}, \"123: key not the correct type.\"},\n\t\t{\"t4.2\", m1, []*KeyRules{Key(\"X\")}, \"X: required key is missing.\"},\n\t\t{\"t4.3\", m1, []*KeyRules{Key(\"X\").Optional()}, \"\"},\n\t\t// non-string keys\n\t\t{\"t5.1\", m6, []*KeyRules{Key(11, &validateAbc{}), Key(22, &validateXyz{})}, \"\"},\n\t\t{\"t5.2\", m6, []*KeyRules{Key(11, &validateXyz{}), Key(22, &validateAbc{})}, \"11: error xyz; 22: error abc.\"},\n\t\t// validatable value\n\t\t{\"t6.1\", m2, []*KeyRules{Key(\"E\")}, \"E: error 123.\"},\n\t\t{\"t6.2\", m2, []*KeyRules{Key(\"E\", Skip)}, \"\"},\n\t\t{\"t6.3\", m2, []*KeyRules{Key(\"E\", Skip.When(true))}, \"\"},\n\t\t{\"t6.4\", m2, []*KeyRules{Key(\"E\", Skip.When(false))}, \"E: error 123.\"},\n\t\t// Required, NotNil\n\t\t{\"t7.1\", m2, []*KeyRules{Key(\"F\", Required)}, \"F: cannot be blank.\"},\n\t\t{\"t7.2\", m2, []*KeyRules{Key(\"F\", NotNil)}, \"F: is required.\"},\n\t\t{\"t7.3\", m2, []*KeyRules{Key(\"F\", Skip, Required)}, \"\"},\n\t\t{\"t7.4\", m2, []*KeyRules{Key(\"F\", Skip, NotNil)}, \"\"},\n\t\t{\"t7.5\", m2, []*KeyRules{Key(\"F\", Skip.When(true), Required)}, \"\"},\n\t\t{\"t7.6\", m2, []*KeyRules{Key(\"F\", Skip.When(true), NotNil)}, \"\"},\n\t\t{\"t7.7\", m2, []*KeyRules{Key(\"F\", Skip.When(false), Required)}, \"F: cannot be blank.\"},\n\t\t{\"t7.8\", m2, []*KeyRules{Key(\"F\", Skip.When(false), NotNil)}, \"F: is required.\"},\n\t\t// validatable structs\n\t\t{\"t8.1\", m3, []*KeyRules{Key(\"M3\", Skip)}, \"\"},\n\t\t{\"t8.2\", m3, []*KeyRules{Key(\"M3\")}, \"M3: (A: error abc.).\"},\n\t\t{\"t8.3\", m4, []*KeyRules{Key(\"M3\")}, \"\"},\n\t\t// internal error\n\t\t{\"t9.1\", m5, []*KeyRules{Key(\"A\", &validateAbc{}), Key(\"B\", Required), Key(\"A\", &validateInternalError{})}, \"error internal\"},\n\t}\n\tfor _, test := range tests {\n\t\terr1 := Validate(test.model, Map(test.rules...).AllowExtraKeys())\n\t\terr2 := ValidateWithContext(context.Background(), test.model, Map(test.rules...).AllowExtraKeys())\n\t\tassertError(t, test.err, err1, test.tag)\n\t\tassertError(t, test.err, err2, test.tag)\n\t}\n\n\ta := map[string]interface{}{\"Name\": \"name\", \"Value\": \"demo\", \"Extra\": true}\n\terr := Validate(a, Map(\n\t\tKey(\"Name\", Required),\n\t\tKey(\"Value\", Required, Length(5, 10)),\n\t))\n\tassert.EqualError(t, err, \"Extra: key not expected; Value: the length must be between 5 and 10.\")\n}\n\nfunc TestMapWithContext(t *testing.T) {\n\tm1 := map[string]interface{}{\"A\": \"abc\", \"B\": \"xyz\", \"c\": \"abc\", \"g\": \"xyz\"}\n\tm2 := map[string]interface{}{\"A\": \"internal\", \"B\": \"\"}\n\ttests := []struct {\n\t\ttag   string\n\t\tmodel interface{}\n\t\trules []*KeyRules\n\t\terr   string\n\t}{\n\t\t// normal rules\n\t\t{\"t1.1\", m1, []*KeyRules{Key(\"A\", &validateContextAbc{}), Key(\"B\", &validateContextXyz{})}, \"\"},\n\t\t{\"t1.2\", m1, []*KeyRules{Key(\"A\", &validateContextXyz{}), Key(\"B\", &validateContextAbc{})}, \"A: error xyz; B: error abc.\"},\n\t\t{\"t1.3\", m1, []*KeyRules{Key(\"A\", &validateContextXyz{}), Key(\"c\", &validateContextXyz{})}, \"A: error xyz; c: error xyz.\"},\n\t\t{\"t1.4\", m1, []*KeyRules{Key(\"g\", &validateContextAbc{})}, \"g: error abc.\"},\n\t\t// skip rule\n\t\t{\"t2.1\", m1, []*KeyRules{Key(\"g\", Skip, &validateContextAbc{})}, \"\"},\n\t\t{\"t2.2\", m1, []*KeyRules{Key(\"g\", &validateContextAbc{}, Skip)}, \"g: error abc.\"},\n\t\t// internal error\n\t\t{\"t3.1\", m2, []*KeyRules{Key(\"A\", &validateContextAbc{}), Key(\"B\", Required), Key(\"A\", &validateInternalError{})}, \"error internal\"},\n\t}\n\tfor _, test := range tests {\n\t\terr := ValidateWithContext(context.Background(), test.model, Map(test.rules...).AllowExtraKeys())\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n\n\ta := map[string]interface{}{\"Name\": \"name\", \"Value\": \"demo\", \"Extra\": true}\n\terr := ValidateWithContext(context.Background(), a, Map(\n\t\tKey(\"Name\", Required),\n\t\tKey(\"Value\", Required, Length(5, 10)),\n\t))\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"Extra: key not expected; Value: the length must be between 5 and 10.\", err.Error())\n\t}\n}\n"
        },
        {
          "name": "match.go",
          "type": "blob",
          "size": 1.5478515625,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"regexp\"\n)\n\n// ErrMatchInvalid is the error that returns in case of invalid format.\nvar ErrMatchInvalid = NewError(\"validation_match_invalid\", \"must be in a valid format\")\n\n// Match returns a validation rule that checks if a value matches the specified regular expression.\n// This rule should only be used for validating strings and byte slices, or a validation error will be reported.\n// An empty value is considered valid. Use the Required rule to make sure a value is not empty.\nfunc Match(re *regexp.Regexp) MatchRule {\n\treturn MatchRule{\n\t\tre:  re,\n\t\terr: ErrMatchInvalid,\n\t}\n}\n\n// MatchRule is a validation rule that checks if a value matches the specified regular expression.\ntype MatchRule struct {\n\tre  *regexp.Regexp\n\terr Error\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r MatchRule) Validate(value interface{}) error {\n\tvalue, isNil := Indirect(value)\n\tif isNil {\n\t\treturn nil\n\t}\n\n\tisString, str, isBytes, bs := StringOrBytes(value)\n\tif isString && (str == \"\" || r.re.MatchString(str)) {\n\t\treturn nil\n\t} else if isBytes && (len(bs) == 0 || r.re.Match(bs)) {\n\t\treturn nil\n\t}\n\treturn r.err\n}\n\n// Error sets the error message for the rule.\nfunc (r MatchRule) Error(message string) MatchRule {\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r MatchRule) ErrorObject(err Error) MatchRule {\n\tr.err = err\n\treturn r\n}\n"
        },
        {
          "name": "match_test.go",
          "type": "blob",
          "size": 1.3095703125,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMatch(t *testing.T) {\n\tvar v2 *string\n\ttests := []struct {\n\t\ttag   string\n\t\tre    string\n\t\tvalue interface{}\n\t\terr   string\n\t}{\n\t\t{\"t1\", \"[a-z]+\", \"abc\", \"\"},\n\t\t{\"t2\", \"[a-z]+\", \"\", \"\"},\n\t\t{\"t3\", \"[a-z]+\", v2, \"\"},\n\t\t{\"t4\", \"[a-z]+\", \"123\", \"must be in a valid format\"},\n\t\t{\"t5\", \"[a-z]+\", []byte(\"abc\"), \"\"},\n\t\t{\"t6\", \"[a-z]+\", []byte(\"123\"), \"must be in a valid format\"},\n\t\t{\"t7\", \"[a-z]+\", []byte(\"\"), \"\"},\n\t\t{\"t8\", \"[a-z]+\", nil, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := Match(regexp.MustCompile(test.re))\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc Test_MatchRule_Error(t *testing.T) {\n\tr := Match(regexp.MustCompile(\"[a-z]+\"))\n\tassert.Equal(t, \"must be in a valid format\", r.Validate(\"13\").Error())\n\tr = r.Error(\"123\")\n\tassert.Equal(t, \"123\", r.err.Message())\n}\n\nfunc TestMatchRule_ErrorObject(t *testing.T) {\n\tr := Match(regexp.MustCompile(\"[a-z]+\"))\n\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, err.Code(), r.err.Code())\n\tassert.Equal(t, err.Message(), r.err.Message())\n}\n"
        },
        {
          "name": "minmax.go",
          "type": "blob",
          "size": 5.583984375,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"time\"\n)\n\nvar (\n\t// ErrMinGreaterEqualThanRequired is the error that returns when a value is less than a specified threshold.\n\tErrMinGreaterEqualThanRequired = NewError(\"validation_min_greater_equal_than_required\", \"must be no less than {{.threshold}}\")\n\t// ErrMaxLessEqualThanRequired is the error that returns when a value is greater than a specified threshold.\n\tErrMaxLessEqualThanRequired = NewError(\"validation_max_less_equal_than_required\", \"must be no greater than {{.threshold}}\")\n\t// ErrMinGreaterThanRequired is the error that returns when a value is less than or equal to a specified threshold.\n\tErrMinGreaterThanRequired = NewError(\"validation_min_greater_than_required\", \"must be greater than {{.threshold}}\")\n\t// ErrMaxLessThanRequired is the error that returns when a value is greater than or equal to a specified threshold.\n\tErrMaxLessThanRequired = NewError(\"validation_max_less_than_required\", \"must be less than {{.threshold}}\")\n)\n\n// ThresholdRule is a validation rule that checks if a value satisfies the specified threshold requirement.\ntype ThresholdRule struct {\n\tthreshold interface{}\n\toperator  int\n\terr       Error\n}\n\nconst (\n\tgreaterThan = iota\n\tgreaterEqualThan\n\tlessThan\n\tlessEqualThan\n)\n\n// Min returns a validation rule that checks if a value is greater or equal than the specified value.\n// By calling Exclusive, the rule will check if the value is strictly greater than the specified value.\n// Note that the value being checked and the threshold value must be of the same type.\n// Only int, uint, float and time.Time types are supported.\n// An empty value is considered valid. Please use the Required rule to make sure a value is not empty.\nfunc Min(min interface{}) ThresholdRule {\n\treturn ThresholdRule{\n\t\tthreshold: min,\n\t\toperator:  greaterEqualThan,\n\t\terr:       ErrMinGreaterEqualThanRequired,\n\t}\n\n}\n\n// Max returns a validation rule that checks if a value is less or equal than the specified value.\n// By calling Exclusive, the rule will check if the value is strictly less than the specified value.\n// Note that the value being checked and the threshold value must be of the same type.\n// Only int, uint, float and time.Time types are supported.\n// An empty value is considered valid. Please use the Required rule to make sure a value is not empty.\nfunc Max(max interface{}) ThresholdRule {\n\treturn ThresholdRule{\n\t\tthreshold: max,\n\t\toperator:  lessEqualThan,\n\t\terr:       ErrMaxLessEqualThanRequired,\n\t}\n}\n\n// Exclusive sets the comparison to exclude the boundary value.\nfunc (r ThresholdRule) Exclusive() ThresholdRule {\n\tif r.operator == greaterEqualThan {\n\t\tr.operator = greaterThan\n\t\tr.err = ErrMinGreaterThanRequired\n\t} else if r.operator == lessEqualThan {\n\t\tr.operator = lessThan\n\t\tr.err = ErrMaxLessThanRequired\n\t}\n\treturn r\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r ThresholdRule) Validate(value interface{}) error {\n\tvalue, isNil := Indirect(value)\n\tif isNil || IsEmpty(value) {\n\t\treturn nil\n\t}\n\n\trv := reflect.ValueOf(r.threshold)\n\tswitch rv.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tv, err := ToInt(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif r.compareInt(rv.Int(), v) {\n\t\t\treturn nil\n\t\t}\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tv, err := ToUint(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif r.compareUint(rv.Uint(), v) {\n\t\t\treturn nil\n\t\t}\n\n\tcase reflect.Float32, reflect.Float64:\n\t\tv, err := ToFloat(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif r.compareFloat(rv.Float(), v) {\n\t\t\treturn nil\n\t\t}\n\n\tcase reflect.Struct:\n\t\tt, ok := r.threshold.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"type not supported: %v\", rv.Type())\n\t\t}\n\t\tv, ok := value.(time.Time)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"cannot convert %v to time.Time\", reflect.TypeOf(value))\n\t\t}\n\t\tif v.IsZero() || r.compareTime(t, v) {\n\t\t\treturn nil\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"type not supported: %v\", rv.Type())\n\t}\n\n\treturn r.err.SetParams(map[string]interface{}{\"threshold\": r.threshold})\n}\n\n// Error sets the error message for the rule.\nfunc (r ThresholdRule) Error(message string) ThresholdRule {\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r ThresholdRule) ErrorObject(err Error) ThresholdRule {\n\tr.err = err\n\treturn r\n}\n\nfunc (r ThresholdRule) compareInt(threshold, value int64) bool {\n\tswitch r.operator {\n\tcase greaterThan:\n\t\treturn value > threshold\n\tcase greaterEqualThan:\n\t\treturn value >= threshold\n\tcase lessThan:\n\t\treturn value < threshold\n\tdefault:\n\t\treturn value <= threshold\n\t}\n}\n\nfunc (r ThresholdRule) compareUint(threshold, value uint64) bool {\n\tswitch r.operator {\n\tcase greaterThan:\n\t\treturn value > threshold\n\tcase greaterEqualThan:\n\t\treturn value >= threshold\n\tcase lessThan:\n\t\treturn value < threshold\n\tdefault:\n\t\treturn value <= threshold\n\t}\n}\n\nfunc (r ThresholdRule) compareFloat(threshold, value float64) bool {\n\tswitch r.operator {\n\tcase greaterThan:\n\t\treturn value > threshold\n\tcase greaterEqualThan:\n\t\treturn value >= threshold\n\tcase lessThan:\n\t\treturn value < threshold\n\tdefault:\n\t\treturn value <= threshold\n\t}\n}\n\nfunc (r ThresholdRule) compareTime(threshold, value time.Time) bool {\n\tswitch r.operator {\n\tcase greaterThan:\n\t\treturn value.After(threshold)\n\tcase greaterEqualThan:\n\t\treturn value.After(threshold) || value.Equal(threshold)\n\tcase lessThan:\n\t\treturn value.Before(threshold)\n\tdefault:\n\t\treturn value.Before(threshold) || value.Equal(threshold)\n\t}\n}\n"
        },
        {
          "name": "minmax_test.go",
          "type": "blob",
          "size": 4.859375,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMin(t *testing.T) {\n\tdate0 := time.Time{}\n\tdate20000101 := time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)\n\tdate20001201 := time.Date(2000, 12, 1, 0, 0, 0, 0, time.UTC)\n\tdate20000601 := time.Date(2000, 6, 1, 0, 0, 0, 0, time.UTC)\n\n\ttests := []struct {\n\t\ttag       string\n\t\tthreshold interface{}\n\t\texclusive bool\n\t\tvalue     interface{}\n\t\terr       string\n\t}{\n\t\t// int cases\n\t\t{\"t1.1\", 1, false, 1, \"\"},\n\t\t{\"t1.2\", 1, false, 2, \"\"},\n\t\t{\"t1.3\", 1, false, -1, \"must be no less than 1\"},\n\t\t{\"t1.4\", 1, false, 0, \"\"},\n\t\t{\"t1.5\", 1, true, 1, \"must be greater than 1\"},\n\t\t{\"t1.6\", 1, false, \"1\", \"cannot convert string to int64\"},\n\t\t{\"t1.7\", \"1\", false, 1, \"type not supported: string\"},\n\t\t// uint cases\n\t\t{\"t2.1\", uint(2), false, uint(2), \"\"},\n\t\t{\"t2.2\", uint(2), false, uint(3), \"\"},\n\t\t{\"t2.3\", uint(2), false, uint(1), \"must be no less than 2\"},\n\t\t{\"t2.4\", uint(2), false, uint(0), \"\"},\n\t\t{\"t2.5\", uint(2), true, uint(2), \"must be greater than 2\"},\n\t\t{\"t2.6\", uint(2), false, \"1\", \"cannot convert string to uint64\"},\n\t\t// float cases\n\t\t{\"t3.1\", float64(2), false, float64(2), \"\"},\n\t\t{\"t3.2\", float64(2), false, float64(3), \"\"},\n\t\t{\"t3.3\", float64(2), false, float64(1), \"must be no less than 2\"},\n\t\t{\"t3.4\", float64(2), false, float64(0), \"\"},\n\t\t{\"t3.5\", float64(2), true, float64(2), \"must be greater than 2\"},\n\t\t{\"t3.6\", float64(2), false, \"1\", \"cannot convert string to float64\"},\n\t\t// Time cases\n\t\t{\"t4.1\", date20000601, false, date20000601, \"\"},\n\t\t{\"t4.2\", date20000601, false, date20001201, \"\"},\n\t\t{\"t4.3\", date20000601, false, date20000101, \"must be no less than 2000-06-01 00:00:00 +0000 UTC\"},\n\t\t{\"t4.4\", date20000601, false, date0, \"\"},\n\t\t{\"t4.5\", date20000601, true, date20000601, \"must be greater than 2000-06-01 00:00:00 +0000 UTC\"},\n\t\t{\"t4.6\", date20000601, true, 1, \"cannot convert int to time.Time\"},\n\t\t{\"t4.7\", struct{}{}, false, 1, \"type not supported: struct {}\"},\n\t\t{\"t4.8\", date0, false, date20000601, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := Min(test.threshold)\n\t\tif test.exclusive {\n\t\t\tr = r.Exclusive()\n\t\t}\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestMinError(t *testing.T) {\n\tr := Min(10)\n\tassert.Equal(t, \"must be no less than 10\", r.Validate(9).Error())\n\n\tr = r.Error(\"123\")\n\tassert.Equal(t, \"123\", r.err.Message())\n}\n\nfunc TestMax(t *testing.T) {\n\tdate0 := time.Time{}\n\tdate20000101 := time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)\n\tdate20001201 := time.Date(2000, 12, 1, 0, 0, 0, 0, time.UTC)\n\tdate20000601 := time.Date(2000, 6, 1, 0, 0, 0, 0, time.UTC)\n\n\ttests := []struct {\n\t\ttag       string\n\t\tthreshold interface{}\n\t\texclusive bool\n\t\tvalue     interface{}\n\t\terr       string\n\t}{\n\t\t// int cases\n\t\t{\"t1.1\", 2, false, 2, \"\"},\n\t\t{\"t1.2\", 2, false, 1, \"\"},\n\t\t{\"t1.3\", 2, false, 3, \"must be no greater than 2\"},\n\t\t{\"t1.4\", 2, false, 0, \"\"},\n\t\t{\"t1.5\", 2, true, 2, \"must be less than 2\"},\n\t\t{\"t1.6\", 2, false, \"1\", \"cannot convert string to int64\"},\n\t\t{\"t1.7\", \"1\", false, 1, \"type not supported: string\"},\n\t\t// uint cases\n\t\t{\"t2.1\", uint(2), false, uint(2), \"\"},\n\t\t{\"t2.2\", uint(2), false, uint(1), \"\"},\n\t\t{\"t2.3\", uint(2), false, uint(3), \"must be no greater than 2\"},\n\t\t{\"t2.4\", uint(2), false, uint(0), \"\"},\n\t\t{\"t2.5\", uint(2), true, uint(2), \"must be less than 2\"},\n\t\t{\"t2.6\", uint(2), false, \"1\", \"cannot convert string to uint64\"},\n\t\t// float cases\n\t\t{\"t3.1\", float64(2), false, float64(2), \"\"},\n\t\t{\"t3.2\", float64(2), false, float64(1), \"\"},\n\t\t{\"t3.3\", float64(2), false, float64(3), \"must be no greater than 2\"},\n\t\t{\"t3.4\", float64(2), false, float64(0), \"\"},\n\t\t{\"t3.5\", float64(2), true, float64(2), \"must be less than 2\"},\n\t\t{\"t3.6\", float64(2), false, \"1\", \"cannot convert string to float64\"},\n\t\t// Time cases\n\t\t{\"t4.1\", date20000601, false, date20000601, \"\"},\n\t\t{\"t4.2\", date20000601, false, date20000101, \"\"},\n\t\t{\"t4.3\", date20000601, false, date20001201, \"must be no greater than 2000-06-01 00:00:00 +0000 UTC\"},\n\t\t{\"t4.4\", date20000601, false, date0, \"\"},\n\t\t{\"t4.5\", date20000601, true, date20000601, \"must be less than 2000-06-01 00:00:00 +0000 UTC\"},\n\t\t{\"t4.6\", date20000601, true, 1, \"cannot convert int to time.Time\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := Max(test.threshold)\n\t\tif test.exclusive {\n\t\t\tr = r.Exclusive()\n\t\t}\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestMaxError(t *testing.T) {\n\tr := Max(10)\n\tassert.Equal(t, \"must be no greater than 10\", r.Validate(11).Error())\n\n\tr = r.Error(\"123\")\n\tassert.Equal(t, \"123\", r.err.Message())\n}\n\nfunc TestThresholdRule_ErrorObject(t *testing.T) {\n\tr := Max(10)\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, err.Code(), r.err.Code())\n\tassert.Equal(t, err.Message(), r.err.Message())\n}\n"
        },
        {
          "name": "multipleof.go",
          "type": "blob",
          "size": 1.6328125,
          "content": "package validation\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// ErrMultipleOfInvalid is the error that returns when a value is not multiple of a base.\nvar ErrMultipleOfInvalid = NewError(\"validation_multiple_of_invalid\", \"must be multiple of {{.base}}\")\n\n// MultipleOf returns a validation rule that checks if a value is a multiple of the \"base\" value.\n// Note that \"base\" should be of integer type.\nfunc MultipleOf(base interface{}) MultipleOfRule {\n\treturn MultipleOfRule{\n\t\tbase: base,\n\t\terr:  ErrMultipleOfInvalid,\n\t}\n}\n\n// MultipleOfRule is a validation rule that checks if a value is a multiple of the \"base\" value.\ntype MultipleOfRule struct {\n\tbase interface{}\n\terr  Error\n}\n\n// Error sets the error message for the rule.\nfunc (r MultipleOfRule) Error(message string) MultipleOfRule {\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r MultipleOfRule) ErrorObject(err Error) MultipleOfRule {\n\tr.err = err\n\treturn r\n}\n\n// Validate checks if the value is a multiple of the \"base\" value.\nfunc (r MultipleOfRule) Validate(value interface{}) error {\n\trv := reflect.ValueOf(r.base)\n\tswitch rv.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tv, err := ToInt(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif v%rv.Int() == 0 {\n\t\t\treturn nil\n\t\t}\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tv, err := ToUint(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif v%rv.Uint() == 0 {\n\t\t\treturn nil\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"type not supported: %v\", rv.Type())\n\t}\n\n\treturn r.err.SetParams(map[string]interface{}{\"base\": r.base})\n}\n"
        },
        {
          "name": "multipleof_test.go",
          "type": "blob",
          "size": 1.298828125,
          "content": "// Copyright 2016 Qiang Xue, Google LLC. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMultipleOf(t *testing.T) {\n\tr := MultipleOf(10)\n\tassert.Equal(t, \"must be multiple of 10\", r.Validate(11).Error())\n\tassert.Equal(t, nil, r.Validate(20))\n\tassert.Equal(t, \"cannot convert float32 to int64\", r.Validate(float32(20)).Error())\n\n\tr2 := MultipleOf(\"some string ....\")\n\tassert.Equal(t, \"type not supported: string\", r2.Validate(10).Error())\n\n\tr3 := MultipleOf(uint(10))\n\tassert.Equal(t, \"must be multiple of 10\", r3.Validate(uint(11)).Error())\n\tassert.Equal(t, nil, r3.Validate(uint(20)))\n\tassert.Equal(t, \"cannot convert float32 to uint64\", r3.Validate(float32(20)).Error())\n\n}\n\nfunc Test_MultipleOf_Error(t *testing.T) {\n\tr := MultipleOf(10)\n\tassert.Equal(t, \"must be multiple of 10\", r.Validate(3).Error())\n\n\tr = r.Error(\"some error string ...\")\n\tassert.Equal(t, \"some error string ...\", r.err.Message())\n}\n\nfunc TestMultipleOfRule_ErrorObject(t *testing.T) {\n\tr := MultipleOf(10)\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, err.Code(), r.err.Code())\n\tassert.Equal(t, err.Message(), r.err.Message())\n}\n"
        },
        {
          "name": "not_in.go",
          "type": "blob",
          "size": 1.439453125,
          "content": "// Copyright 2018 Qiang Xue, Google LLC. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\n// ErrNotInInvalid is the error that returns when a value is in a list.\nvar ErrNotInInvalid = NewError(\"validation_not_in_invalid\", \"must not be in list\")\n\n// NotIn returns a validation rule that checks if a value is absent from the given list of values.\n// Note that the value being checked and the possible range of values must be of the same type.\n// An empty value is considered valid. Use the Required rule to make sure a value is not empty.\nfunc NotIn(values ...interface{}) NotInRule {\n\treturn NotInRule{\n\t\telements: values,\n\t\terr:      ErrNotInInvalid,\n\t}\n}\n\n// NotInRule is a validation rule that checks if a value is absent from the given list of values.\ntype NotInRule struct {\n\telements []interface{}\n\terr      Error\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r NotInRule) Validate(value interface{}) error {\n\tvalue, isNil := Indirect(value)\n\tif isNil || IsEmpty(value) {\n\t\treturn nil\n\t}\n\n\tfor _, e := range r.elements {\n\t\tif e == value {\n\t\t\treturn r.err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Error sets the error message for the rule.\nfunc (r NotInRule) Error(message string) NotInRule {\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r NotInRule) ErrorObject(err Error) NotInRule {\n\tr.err = err\n\treturn r\n}\n"
        },
        {
          "name": "not_in_test.go",
          "type": "blob",
          "size": 1.31640625,
          "content": "// Copyright 2016 Qiang Xue, Google LLC. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNotIn(t *testing.T) {\n\tv := 1\n\tvar v2 *int\n\tvar tests = []struct {\n\t\ttag    string\n\t\tvalues []interface{}\n\t\tvalue  interface{}\n\t\terr    string\n\t}{\n\t\t{\"t0\", []interface{}{1, 2}, 0, \"\"},\n\t\t{\"t1\", []interface{}{1, 2}, 1, \"must not be in list\"},\n\t\t{\"t2\", []interface{}{1, 2}, 2, \"must not be in list\"},\n\t\t{\"t3\", []interface{}{1, 2}, 3, \"\"},\n\t\t{\"t4\", []interface{}{}, 3, \"\"},\n\t\t{\"t5\", []interface{}{1, 2}, \"1\", \"\"},\n\t\t{\"t6\", []interface{}{1, 2}, &v, \"must not be in list\"},\n\t\t{\"t7\", []interface{}{1, 2}, v2, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := NotIn(test.values...)\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc Test_NotInRule_Error(t *testing.T) {\n\tr := NotIn(1, 2, 3)\n\tassert.Equal(t, \"must not be in list\", r.Validate(1).Error())\n\tr = r.Error(\"123\")\n\tassert.Equal(t, \"123\", r.err.Message())\n}\n\nfunc TestNotInRule_ErrorObject(t *testing.T) {\n\tr := NotIn(1, 2, 3)\n\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, err.Code(), r.err.Code())\n\tassert.Equal(t, err.Message(), r.err.Message())\n}\n"
        },
        {
          "name": "not_nil.go",
          "type": "blob",
          "size": 1.1123046875,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\n// ErrNotNilRequired is the error that returns when a value is Nil.\nvar ErrNotNilRequired = NewError(\"validation_not_nil_required\", \"is required\")\n\n// NotNil is a validation rule that checks if a value is not nil.\n// NotNil only handles types including interface, pointer, slice, and map.\n// All other types are considered valid.\nvar NotNil = notNilRule{}\n\ntype notNilRule struct {\n\terr Error\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r notNilRule) Validate(value interface{}) error {\n\t_, isNil := Indirect(value)\n\tif isNil {\n\t\tif r.err != nil {\n\t\t\treturn r.err\n\t\t}\n\t\treturn ErrNotNilRequired\n\t}\n\treturn nil\n}\n\n// Error sets the error message for the rule.\nfunc (r notNilRule) Error(message string) notNilRule {\n\tif r.err == nil {\n\t\tr.err = ErrNotNilRequired\n\t}\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r notNilRule) ErrorObject(err Error) notNilRule {\n\tr.err = err\n\treturn r\n}\n"
        },
        {
          "name": "not_nil_test.go",
          "type": "blob",
          "size": 1.2685546875,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype MyInterface interface {\n\tHello()\n}\n\nfunc TestNotNil(t *testing.T) {\n\tvar v1 []int\n\tvar v2 map[string]int\n\tvar v3 *int\n\tvar v4 interface{}\n\tvar v5 MyInterface\n\ttests := []struct {\n\t\ttag   string\n\t\tvalue interface{}\n\t\terr   string\n\t}{\n\t\t{\"t1\", v1, \"is required\"},\n\t\t{\"t2\", v2, \"is required\"},\n\t\t{\"t3\", v3, \"is required\"},\n\t\t{\"t4\", v4, \"is required\"},\n\t\t{\"t5\", v5, \"is required\"},\n\t\t{\"t6\", \"\", \"\"},\n\t\t{\"t7\", 0, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := NotNil\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc Test_notNilRule_Error(t *testing.T) {\n\tr := NotNil\n\tassert.Equal(t, \"is required\", r.Validate(nil).Error())\n\tr2 := r.Error(\"123\")\n\tassert.Equal(t, \"is required\", r.Validate(nil).Error())\n\tassert.Equal(t, \"123\", r2.err.Message())\n}\n\nfunc TestNotNilRule_ErrorObject(t *testing.T) {\n\tr := NotNil\n\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, err.Code(), r.err.Code())\n\tassert.Equal(t, err.Message(), r.err.Message())\n\tassert.NotEqual(t, err, NotNil.err)\n}\n"
        },
        {
          "name": "required.go",
          "type": "blob",
          "size": 2.1240234375,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nvar (\n\t// ErrRequired is the error that returns when a value is required.\n\tErrRequired = NewError(\"validation_required\", \"cannot be blank\")\n\t// ErrNilOrNotEmpty is the error that returns when a value is not nil and is empty.\n\tErrNilOrNotEmpty = NewError(\"validation_nil_or_not_empty_required\", \"cannot be blank\")\n)\n\n// Required is a validation rule that checks if a value is not empty.\n// A value is considered not empty if\n// - integer, float: not zero\n// - bool: true\n// - string, array, slice, map: len() > 0\n// - interface, pointer: not nil and the referenced value is not empty\n// - any other types\nvar Required = RequiredRule{skipNil: false, condition: true}\n\n// NilOrNotEmpty checks if a value is a nil pointer or a value that is not empty.\n// NilOrNotEmpty differs from Required in that it treats a nil pointer as valid.\nvar NilOrNotEmpty = RequiredRule{skipNil: true, condition: true}\n\n// RequiredRule is a rule that checks if a value is not empty.\ntype RequiredRule struct {\n\tcondition bool\n\tskipNil   bool\n\terr       Error\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r RequiredRule) Validate(value interface{}) error {\n\tif r.condition {\n\t\tvalue, isNil := Indirect(value)\n\t\tif r.skipNil && !isNil && IsEmpty(value) || !r.skipNil && (isNil || IsEmpty(value)) {\n\t\t\tif r.err != nil {\n\t\t\t\treturn r.err\n\t\t\t}\n\t\t\tif r.skipNil {\n\t\t\t\treturn ErrNilOrNotEmpty\n\t\t\t}\n\t\t\treturn ErrRequired\n\t\t}\n\t}\n\treturn nil\n}\n\n// When sets the condition that determines if the validation should be performed.\nfunc (r RequiredRule) When(condition bool) RequiredRule {\n\tr.condition = condition\n\treturn r\n}\n\n// Error sets the error message for the rule.\nfunc (r RequiredRule) Error(message string) RequiredRule {\n\tif r.err == nil {\n\t\tif r.skipNil {\n\t\t\tr.err = ErrNilOrNotEmpty\n\t\t} else {\n\t\t\tr.err = ErrRequired\n\t\t}\n\t}\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r RequiredRule) ErrorObject(err Error) RequiredRule {\n\tr.err = err\n\treturn r\n}\n"
        },
        {
          "name": "required_test.go",
          "type": "blob",
          "size": 2.1484375,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRequired(t *testing.T) {\n\ts1 := \"123\"\n\ts2 := \"\"\n\tvar time1 time.Time\n\ttests := []struct {\n\t\ttag   string\n\t\tvalue interface{}\n\t\terr   string\n\t}{\n\t\t{\"t1\", 123, \"\"},\n\t\t{\"t2\", \"\", \"cannot be blank\"},\n\t\t{\"t3\", &s1, \"\"},\n\t\t{\"t4\", &s2, \"cannot be blank\"},\n\t\t{\"t5\", nil, \"cannot be blank\"},\n\t\t{\"t6\", time1, \"cannot be blank\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := Required\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestRequiredRule_When(t *testing.T) {\n\tr := Required.When(false)\n\terr := Validate(nil, r)\n\tassert.Nil(t, err)\n\n\tr = Required.When(true)\n\terr = Validate(nil, r)\n\tassert.Equal(t, ErrRequired, err)\n}\n\nfunc TestNilOrNotEmpty(t *testing.T) {\n\ts1 := \"123\"\n\ts2 := \"\"\n\ttests := []struct {\n\t\ttag   string\n\t\tvalue interface{}\n\t\terr   string\n\t}{\n\t\t{\"t1\", 123, \"\"},\n\t\t{\"t2\", \"\", \"cannot be blank\"},\n\t\t{\"t3\", &s1, \"\"},\n\t\t{\"t4\", &s2, \"cannot be blank\"},\n\t\t{\"t5\", nil, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := NilOrNotEmpty\n\t\terr := r.Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc Test_requiredRule_Error(t *testing.T) {\n\tr := Required\n\tassert.Equal(t, \"cannot be blank\", r.Validate(nil).Error())\n\tassert.False(t, r.skipNil)\n\tr2 := r.Error(\"123\")\n\tassert.Equal(t, \"cannot be blank\", r.Validate(nil).Error())\n\tassert.False(t, r.skipNil)\n\tassert.Equal(t, \"123\", r2.err.Message())\n\tassert.False(t, r2.skipNil)\n\n\tr = NilOrNotEmpty\n\tassert.Equal(t, \"cannot be blank\", r.Validate(\"\").Error())\n\tassert.True(t, r.skipNil)\n\tr2 = r.Error(\"123\")\n\tassert.Equal(t, \"cannot be blank\", r.Validate(\"\").Error())\n\tassert.True(t, r.skipNil)\n\tassert.Equal(t, \"123\", r2.err.Message())\n\tassert.True(t, r2.skipNil)\n}\n\nfunc TestRequiredRule_Error(t *testing.T) {\n\tr := Required\n\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, err.Code(), r.err.Code())\n\tassert.Equal(t, err.Message(), r.err.Message())\n\tassert.NotEqual(t, err, Required.err)\n}\n"
        },
        {
          "name": "string.go",
          "type": "blob",
          "size": 1.876953125,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\ntype stringValidator func(string) bool\n\n// StringRule is a rule that checks a string variable using a specified stringValidator.\ntype StringRule struct {\n\tvalidate stringValidator\n\terr      Error\n}\n\n// NewStringRule creates a new validation rule using a function that takes a string value and returns a bool.\n// The rule returned will use the function to check if a given string or byte slice is valid or not.\n// An empty value is considered to be valid. Please use the Required rule to make sure a value is not empty.\nfunc NewStringRule(validator stringValidator, message string) StringRule {\n\treturn StringRule{\n\t\tvalidate: validator,\n\t\terr:      NewError(\"\", message),\n\t}\n}\n\n// NewStringRuleWithError creates a new validation rule using a function that takes a string value and returns a bool.\n// The rule returned will use the function to check if a given string or byte slice is valid or not.\n// An empty value is considered to be valid. Please use the Required rule to make sure a value is not empty.\nfunc NewStringRuleWithError(validator stringValidator, err Error) StringRule {\n\treturn StringRule{\n\t\tvalidate: validator,\n\t\terr:      err,\n\t}\n}\n\n// Error sets the error message for the rule.\nfunc (r StringRule) Error(message string) StringRule {\n\tr.err = r.err.SetMessage(message)\n\treturn r\n}\n\n// ErrorObject sets the error struct for the rule.\nfunc (r StringRule) ErrorObject(err Error) StringRule {\n\tr.err = err\n\treturn r\n}\n\n// Validate checks if the given value is valid or not.\nfunc (r StringRule) Validate(value interface{}) error {\n\tvalue, isNil := Indirect(value)\n\tif isNil || IsEmpty(value) {\n\t\treturn nil\n\t}\n\n\tstr, err := EnsureString(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif r.validate(str) {\n\t\treturn nil\n\t}\n\n\treturn r.err\n}\n"
        },
        {
          "name": "string_test.go",
          "type": "blob",
          "size": 2.8076171875,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"database/sql\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc validateMe(s string) bool {\n\treturn s == \"me\"\n}\n\nfunc TestNewStringRule(t *testing.T) {\n\tv := NewStringRule(validateMe, \"abc\")\n\n\tassert.NotNil(t, v.validate)\n\tassert.Equal(t, \"\", v.err.Code())\n\tassert.Equal(t, \"abc\", v.err.Message())\n}\n\nfunc TestNewStringRuleWithError(t *testing.T) {\n\terr := NewError(\"C\", \"abc\")\n\tv := NewStringRuleWithError(validateMe, err)\n\n\tassert.NotNil(t, v.validate)\n\tassert.Equal(t, err, v.err)\n\tassert.Equal(t, \"C\", v.err.Code())\n\tassert.Equal(t, \"abc\", v.err.Message())\n}\n\nfunc TestStringRule_Error(t *testing.T) {\n\terr := NewError(\"code\", \"abc\")\n\tv := NewStringRuleWithError(validateMe, err).Error(\"abc\")\n\tassert.Equal(t, \"code\", v.err.Code())\n\tassert.Equal(t, \"abc\", v.err.Message())\n\n\tv2 := v.Error(\"correct\")\n\tassert.Equal(t, \"code\", v.err.Code())\n\tassert.Equal(t, \"correct\", v2.err.Message())\n\tassert.Equal(t, \"abc\", v.err.Message())\n}\n\nfunc TestStringValidator_Validate(t *testing.T) {\n\tv := NewStringRule(validateMe, \"wrong_rule\").Error(\"wrong\")\n\n\tvalue := \"me\"\n\n\terr := v.Validate(value)\n\tassert.Nil(t, err)\n\n\terr = v.Validate(&value)\n\tassert.Nil(t, err)\n\n\tvalue = \"\"\n\n\terr = v.Validate(value)\n\tassert.Nil(t, err)\n\n\terr = v.Validate(&value)\n\tassert.Nil(t, err)\n\n\tnullValue := sql.NullString{String: \"me\", Valid: true}\n\terr = v.Validate(nullValue)\n\tassert.Nil(t, err)\n\n\tnullValue = sql.NullString{String: \"\", Valid: true}\n\terr = v.Validate(nullValue)\n\tassert.Nil(t, err)\n\n\tvar s *string\n\terr = v.Validate(s)\n\tassert.Nil(t, err)\n\n\terr = v.Validate(\"not me\")\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"wrong\", err.Error())\n\t}\n\n\terr = v.Validate(100)\n\tif assert.NotNil(t, err) {\n\t\tassert.NotEqual(t, \"wrong\", err.Error())\n\t}\n\n\tv2 := v.Error(\"Wrong!\")\n\terr = v2.Validate(\"not me\")\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"Wrong!\", err.Error())\n\t}\n}\n\nfunc TestGetErrorFieldName(t *testing.T) {\n\ttype A struct {\n\t\tT0 string\n\t\tT1 string `json:\"t1\"`\n\t\tT2 string `json:\"t2,omitempty\"`\n\t\tT3 string `json:\",omitempty\"`\n\t\tT4 string `json:\"t4,x1,omitempty\"`\n\t}\n\ttests := []struct {\n\t\ttag   string\n\t\tfield string\n\t\tname  string\n\t}{\n\t\t{\"t1\", \"T0\", \"T0\"},\n\t\t{\"t2\", \"T1\", \"t1\"},\n\t\t{\"t3\", \"T2\", \"t2\"},\n\t\t{\"t4\", \"T3\", \"T3\"},\n\t\t{\"t5\", \"T4\", \"t4\"},\n\t}\n\ta := reflect.TypeOf(A{})\n\tfor _, test := range tests {\n\t\tfield, _ := a.FieldByName(test.field)\n\t\tassert.Equal(t, test.name, getErrorFieldName(&field), test.tag)\n\t}\n}\n\nfunc TestStringRule_ErrorObject(t *testing.T) {\n\tr := NewStringRule(validateMe, \"wrong_rule\")\n\n\terr := NewError(\"code\", \"abc\")\n\tr = r.ErrorObject(err)\n\n\tassert.Equal(t, err, r.err)\n\tassert.Equal(t, \"code\", r.err.Code())\n\tassert.Equal(t, \"abc\", r.err.Message())\n}\n"
        },
        {
          "name": "struct.go",
          "type": "blob",
          "size": 5.1953125,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\nvar (\n\t// ErrStructPointer is the error that a struct being validated is not specified as a pointer.\n\tErrStructPointer = errors.New(\"only a pointer to a struct can be validated\")\n)\n\ntype (\n\t// ErrFieldPointer is the error that a field is not specified as a pointer.\n\tErrFieldPointer int\n\n\t// ErrFieldNotFound is the error that a field cannot be found in the struct.\n\tErrFieldNotFound int\n\n\t// FieldRules represents a rule set associated with a struct field.\n\tFieldRules struct {\n\t\tfieldPtr interface{}\n\t\trules    []Rule\n\t}\n)\n\n// Error returns the error string of ErrFieldPointer.\nfunc (e ErrFieldPointer) Error() string {\n\treturn fmt.Sprintf(\"field #%v must be specified as a pointer\", int(e))\n}\n\n// Error returns the error string of ErrFieldNotFound.\nfunc (e ErrFieldNotFound) Error() string {\n\treturn fmt.Sprintf(\"field #%v cannot be found in the struct\", int(e))\n}\n\n// ValidateStruct validates a struct by checking the specified struct fields against the corresponding validation rules.\n// Note that the struct being validated must be specified as a pointer to it. If the pointer is nil, it is considered valid.\n// Use Field() to specify struct fields that need to be validated. Each Field() call specifies a single field which\n// should be specified as a pointer to the field. A field can be associated with multiple rules.\n// For example,\n//\n//    value := struct {\n//        Name  string\n//        Value string\n//    }{\"name\", \"demo\"}\n//    err := validation.ValidateStruct(&value,\n//        validation.Field(&a.Name, validation.Required),\n//        validation.Field(&a.Value, validation.Required, validation.Length(5, 10)),\n//    )\n//    fmt.Println(err)\n//    // Value: the length must be between 5 and 10.\n//\n// An error will be returned if validation fails.\nfunc ValidateStruct(structPtr interface{}, fields ...*FieldRules) error {\n\treturn ValidateStructWithContext(nil, structPtr, fields...)\n}\n\n// ValidateStructWithContext validates a struct with the given context.\n// The only difference between ValidateStructWithContext and ValidateStruct is that the former will\n// validate struct fields with the provided context.\n// Please refer to ValidateStruct for the detailed instructions on how to use this function.\nfunc ValidateStructWithContext(ctx context.Context, structPtr interface{}, fields ...*FieldRules) error {\n\tvalue := reflect.ValueOf(structPtr)\n\tif value.Kind() != reflect.Ptr || !value.IsNil() && value.Elem().Kind() != reflect.Struct {\n\t\t// must be a pointer to a struct\n\t\treturn NewInternalError(ErrStructPointer)\n\t}\n\tif value.IsNil() {\n\t\t// treat a nil struct pointer as valid\n\t\treturn nil\n\t}\n\tvalue = value.Elem()\n\n\terrs := Errors{}\n\n\tfor i, fr := range fields {\n\t\tfv := reflect.ValueOf(fr.fieldPtr)\n\t\tif fv.Kind() != reflect.Ptr {\n\t\t\treturn NewInternalError(ErrFieldPointer(i))\n\t\t}\n\t\tft := findStructField(value, fv)\n\t\tif ft == nil {\n\t\t\treturn NewInternalError(ErrFieldNotFound(i))\n\t\t}\n\t\tvar err error\n\t\tif ctx == nil {\n\t\t\terr = Validate(fv.Elem().Interface(), fr.rules...)\n\t\t} else {\n\t\t\terr = ValidateWithContext(ctx, fv.Elem().Interface(), fr.rules...)\n\t\t}\n\t\tif err != nil {\n\t\t\tif ie, ok := err.(InternalError); ok && ie.InternalError() != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif ft.Anonymous {\n\t\t\t\t// merge errors from anonymous struct field\n\t\t\t\tif es, ok := err.(Errors); ok {\n\t\t\t\t\tfor name, value := range es {\n\t\t\t\t\t\terrs[name] = value\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\terrs[getErrorFieldName(ft)] = err\n\t\t}\n\t}\n\n\tif len(errs) > 0 {\n\t\treturn errs\n\t}\n\treturn nil\n}\n\n// Field specifies a struct field and the corresponding validation rules.\n// The struct field must be specified as a pointer to it.\nfunc Field(fieldPtr interface{}, rules ...Rule) *FieldRules {\n\treturn &FieldRules{\n\t\tfieldPtr: fieldPtr,\n\t\trules:    rules,\n\t}\n}\n\n// findStructField looks for a field in the given struct.\n// The field being looked for should be a pointer to the actual struct field.\n// If found, the field info will be returned. Otherwise, nil will be returned.\nfunc findStructField(structValue reflect.Value, fieldValue reflect.Value) *reflect.StructField {\n\tptr := fieldValue.Pointer()\n\tfor i := structValue.NumField() - 1; i >= 0; i-- {\n\t\tsf := structValue.Type().Field(i)\n\t\tif ptr == structValue.Field(i).UnsafeAddr() {\n\t\t\t// do additional type comparison because it's possible that the address of\n\t\t\t// an embedded struct is the same as the first field of the embedded struct\n\t\t\tif sf.Type == fieldValue.Elem().Type() {\n\t\t\t\treturn &sf\n\t\t\t}\n\t\t}\n\t\tif sf.Anonymous {\n\t\t\t// delve into anonymous struct to look for the field\n\t\t\tfi := structValue.Field(i)\n\t\t\tif sf.Type.Kind() == reflect.Ptr {\n\t\t\t\tfi = fi.Elem()\n\t\t\t}\n\t\t\tif fi.Kind() == reflect.Struct {\n\t\t\t\tif f := findStructField(fi, fieldValue); f != nil {\n\t\t\t\t\treturn f\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// getErrorFieldName returns the name that should be used to represent the validation error of a struct field.\nfunc getErrorFieldName(f *reflect.StructField) string {\n\tif tag := f.Tag.Get(ErrorTag); tag != \"\" && tag != \"-\" {\n\t\tif cps := strings.SplitN(tag, \",\", 2); cps[0] != \"\" {\n\t\t\treturn cps[0]\n\t\t}\n\t}\n\treturn f.Name\n}\n"
        },
        {
          "name": "struct_test.go",
          "type": "blob",
          "size": 8.267578125,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype Struct1 struct {\n\tField1 int\n\tField2 *int\n\tField3 []int\n\tField4 [4]int\n\tfield5 int\n\tStruct2\n\tS1               *Struct2\n\tS2               Struct2\n\tJSONField        int `json:\"some_json_field\"`\n\tJSONIgnoredField int `json:\"-\"`\n}\n\ntype Struct2 struct {\n\tField21 string\n\tField22 string\n}\n\ntype Struct3 struct {\n\t*Struct2\n\tS1 string\n}\n\nfunc TestFindStructField(t *testing.T) {\n\tvar s1 Struct1\n\tv1 := reflect.ValueOf(&s1).Elem()\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.Field1)))\n\tassert.Nil(t, findStructField(v1, reflect.ValueOf(s1.Field2)))\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.Field2)))\n\tassert.Nil(t, findStructField(v1, reflect.ValueOf(s1.Field3)))\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.Field3)))\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.Field4)))\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.field5)))\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.Struct2)))\n\tassert.Nil(t, findStructField(v1, reflect.ValueOf(s1.S1)))\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.S1)))\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.Field21)))\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.Field22)))\n\tassert.NotNil(t, findStructField(v1, reflect.ValueOf(&s1.Struct2.Field22)))\n\ts2 := reflect.ValueOf(&s1.Struct2).Elem()\n\tassert.NotNil(t, findStructField(s2, reflect.ValueOf(&s1.Field21)))\n\tassert.NotNil(t, findStructField(s2, reflect.ValueOf(&s1.Struct2.Field21)))\n\tassert.NotNil(t, findStructField(s2, reflect.ValueOf(&s1.Struct2.Field22)))\n\ts3 := Struct3{\n\t\tStruct2: &Struct2{},\n\t}\n\tv3 := reflect.ValueOf(&s3).Elem()\n\tassert.NotNil(t, findStructField(v3, reflect.ValueOf(&s3.Struct2)))\n\tassert.NotNil(t, findStructField(v3, reflect.ValueOf(&s3.Field21)))\n}\n\nfunc TestValidateStruct(t *testing.T) {\n\tvar m0 *Model1\n\tm1 := Model1{A: \"abc\", B: \"xyz\", c: \"abc\", G: \"xyz\", H: []string{\"abc\", \"abc\"}, I: map[string]string{\"foo\": \"abc\"}}\n\tm2 := Model1{E: String123(\"xyz\")}\n\tm3 := Model2{}\n\tm4 := Model2{M3: Model3{A: \"abc\"}, Model3: Model3{A: \"abc\"}}\n\tm5 := Model2{Model3: Model3{A: \"internal\"}}\n\ttests := []struct {\n\t\ttag   string\n\t\tmodel interface{}\n\t\trules []*FieldRules\n\t\terr   string\n\t}{\n\t\t// empty rules\n\t\t{\"t1.1\", &m1, []*FieldRules{}, \"\"},\n\t\t{\"t1.2\", &m1, []*FieldRules{Field(&m1.A), Field(&m1.B)}, \"\"},\n\t\t// normal rules\n\t\t{\"t2.1\", &m1, []*FieldRules{Field(&m1.A, &validateAbc{}), Field(&m1.B, &validateXyz{})}, \"\"},\n\t\t{\"t2.2\", &m1, []*FieldRules{Field(&m1.A, &validateXyz{}), Field(&m1.B, &validateAbc{})}, \"A: error xyz; B: error abc.\"},\n\t\t{\"t2.3\", &m1, []*FieldRules{Field(&m1.A, &validateXyz{}), Field(&m1.c, &validateXyz{})}, \"A: error xyz; c: error xyz.\"},\n\t\t{\"t2.4\", &m1, []*FieldRules{Field(&m1.D, Length(0, 5))}, \"\"},\n\t\t{\"t2.5\", &m1, []*FieldRules{Field(&m1.F, Length(0, 5))}, \"\"},\n\t\t{\"t2.6\", &m1, []*FieldRules{Field(&m1.H, Each(&validateAbc{})), Field(&m1.I, Each(&validateAbc{}))}, \"\"},\n\t\t{\"t2.7\", &m1, []*FieldRules{Field(&m1.H, Each(&validateXyz{})), Field(&m1.I, Each(&validateXyz{}))}, \"H: (0: error xyz; 1: error xyz.); I: (foo: error xyz.).\"},\n\t\t// non-struct pointer\n\t\t{\"t3.1\", m1, []*FieldRules{}, ErrStructPointer.Error()},\n\t\t{\"t3.2\", nil, []*FieldRules{}, ErrStructPointer.Error()},\n\t\t{\"t3.3\", m0, []*FieldRules{}, \"\"},\n\t\t{\"t3.4\", &m0, []*FieldRules{}, ErrStructPointer.Error()},\n\t\t// invalid field spec\n\t\t{\"t4.1\", &m1, []*FieldRules{Field(m1)}, ErrFieldPointer(0).Error()},\n\t\t{\"t4.2\", &m1, []*FieldRules{Field(&m1)}, ErrFieldNotFound(0).Error()},\n\t\t// struct tag\n\t\t{\"t5.1\", &m1, []*FieldRules{Field(&m1.G, &validateAbc{})}, \"g: error abc.\"},\n\t\t// validatable field\n\t\t{\"t6.1\", &m2, []*FieldRules{Field(&m2.E)}, \"E: error 123.\"},\n\t\t{\"t6.2\", &m2, []*FieldRules{Field(&m2.E, Skip)}, \"\"},\n\t\t{\"t6.3\", &m2, []*FieldRules{Field(&m2.E, Skip.When(true))}, \"\"},\n\t\t{\"t6.4\", &m2, []*FieldRules{Field(&m2.E, Skip.When(false))}, \"E: error 123.\"},\n\t\t// Required, NotNil\n\t\t{\"t7.1\", &m2, []*FieldRules{Field(&m2.F, Required)}, \"F: cannot be blank.\"},\n\t\t{\"t7.2\", &m2, []*FieldRules{Field(&m2.F, NotNil)}, \"F: is required.\"},\n\t\t{\"t7.3\", &m2, []*FieldRules{Field(&m2.F, Skip, Required)}, \"\"},\n\t\t{\"t7.4\", &m2, []*FieldRules{Field(&m2.F, Skip, NotNil)}, \"\"},\n\t\t{\"t7.5\", &m2, []*FieldRules{Field(&m2.F, Skip.When(true), Required)}, \"\"},\n\t\t{\"t7.6\", &m2, []*FieldRules{Field(&m2.F, Skip.When(true), NotNil)}, \"\"},\n\t\t{\"t7.7\", &m2, []*FieldRules{Field(&m2.F, Skip.When(false), Required)}, \"F: cannot be blank.\"},\n\t\t{\"t7.8\", &m2, []*FieldRules{Field(&m2.F, Skip.When(false), NotNil)}, \"F: is required.\"},\n\t\t// embedded structs\n\t\t{\"t8.1\", &m3, []*FieldRules{Field(&m3.M3, Skip)}, \"\"},\n\t\t{\"t8.2\", &m3, []*FieldRules{Field(&m3.M3)}, \"M3: (A: error abc.).\"},\n\t\t{\"t8.3\", &m3, []*FieldRules{Field(&m3.Model3, Skip)}, \"\"},\n\t\t{\"t8.4\", &m3, []*FieldRules{Field(&m3.Model3)}, \"A: error abc.\"},\n\t\t{\"t8.5\", &m4, []*FieldRules{Field(&m4.M3)}, \"\"},\n\t\t{\"t8.6\", &m4, []*FieldRules{Field(&m4.Model3)}, \"\"},\n\t\t{\"t8.7\", &m3, []*FieldRules{Field(&m3.A, Required), Field(&m3.B, Required)}, \"A: cannot be blank; B: cannot be blank.\"},\n\t\t{\"t8.8\", &m3, []*FieldRules{Field(&m4.A, Required)}, \"field #0 cannot be found in the struct\"},\n\t\t// internal error\n\t\t{\"t9.1\", &m5, []*FieldRules{Field(&m5.A, &validateAbc{}), Field(&m5.B, Required), Field(&m5.A, &validateInternalError{})}, \"error internal\"},\n\t}\n\tfor _, test := range tests {\n\t\terr1 := ValidateStruct(test.model, test.rules...)\n\t\terr2 := ValidateStructWithContext(context.Background(), test.model, test.rules...)\n\t\tassertError(t, test.err, err1, test.tag)\n\t\tassertError(t, test.err, err2, test.tag)\n\t}\n\n\t// embedded struct\n\terr := Validate(&m3)\n\tassert.EqualError(t, err, \"A: error abc.\")\n\n\ta := struct {\n\t\tName  string\n\t\tValue string\n\t}{\"name\", \"demo\"}\n\terr = ValidateStruct(&a,\n\t\tField(&a.Name, Required),\n\t\tField(&a.Value, Required, Length(5, 10)),\n\t)\n\tassert.EqualError(t, err, \"Value: the length must be between 5 and 10.\")\n}\n\nfunc TestValidateStructWithContext(t *testing.T) {\n\tm1 := Model1{A: \"abc\", B: \"xyz\", c: \"abc\", G: \"xyz\"}\n\tm2 := Model2{Model3: Model3{A: \"internal\"}}\n\tm3 := Model5{}\n\ttests := []struct {\n\t\ttag   string\n\t\tmodel interface{}\n\t\trules []*FieldRules\n\t\terr   string\n\t}{\n\t\t// normal rules\n\t\t{\"t1.1\", &m1, []*FieldRules{Field(&m1.A, &validateContextAbc{}), Field(&m1.B, &validateContextXyz{})}, \"\"},\n\t\t{\"t1.2\", &m1, []*FieldRules{Field(&m1.A, &validateContextXyz{}), Field(&m1.B, &validateContextAbc{})}, \"A: error xyz; B: error abc.\"},\n\t\t{\"t1.3\", &m1, []*FieldRules{Field(&m1.A, &validateContextXyz{}), Field(&m1.c, &validateContextXyz{})}, \"A: error xyz; c: error xyz.\"},\n\t\t{\"t1.4\", &m1, []*FieldRules{Field(&m1.G, &validateContextAbc{})}, \"g: error abc.\"},\n\t\t// skip rule\n\t\t{\"t2.1\", &m1, []*FieldRules{Field(&m1.G, Skip, &validateContextAbc{})}, \"\"},\n\t\t{\"t2.2\", &m1, []*FieldRules{Field(&m1.G, &validateContextAbc{}, Skip)}, \"g: error abc.\"},\n\t\t// internal error\n\t\t{\"t3.1\", &m2, []*FieldRules{Field(&m2.A, &validateContextAbc{}), Field(&m2.B, Required), Field(&m2.A, &validateInternalError{})}, \"error internal\"},\n\t}\n\tfor _, test := range tests {\n\t\terr := ValidateStructWithContext(context.Background(), test.model, test.rules...)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n\n\t//embedded struct\n\terr := ValidateWithContext(context.Background(), &m3)\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"A: error abc.\", err.Error())\n\t}\n\n\ta := struct {\n\t\tName  string\n\t\tValue string\n\t}{\"name\", \"demo\"}\n\terr = ValidateStructWithContext(context.Background(), &a,\n\t\tField(&a.Name, Required),\n\t\tField(&a.Value, Required, Length(5, 10)),\n\t)\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"Value: the length must be between 5 and 10.\", err.Error())\n\t}\n}\n\nfunc Test_getErrorFieldName(t *testing.T) {\n\tvar s1 Struct1\n\tv1 := reflect.ValueOf(&s1).Elem()\n\n\tsf1 := findStructField(v1, reflect.ValueOf(&s1.Field1))\n\tassert.NotNil(t, sf1)\n\tassert.Equal(t, \"Field1\", getErrorFieldName(sf1))\n\n\tjsonField := findStructField(v1, reflect.ValueOf(&s1.JSONField))\n\tassert.NotNil(t, jsonField)\n\tassert.Equal(t, \"some_json_field\", getErrorFieldName(jsonField))\n\n\tjsonIgnoredField := findStructField(v1, reflect.ValueOf(&s1.JSONIgnoredField))\n\tassert.NotNil(t, jsonIgnoredField)\n\tassert.Equal(t, \"JSONIgnoredField\", getErrorFieldName(jsonIgnoredField))\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 4.7236328125,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"time\"\n)\n\nvar (\n\tbytesType  = reflect.TypeOf([]byte(nil))\n\tvaluerType = reflect.TypeOf((*driver.Valuer)(nil)).Elem()\n)\n\n// EnsureString ensures the given value is a string.\n// If the value is a byte slice, it will be typecast into a string.\n// An error is returned otherwise.\nfunc EnsureString(value interface{}) (string, error) {\n\tv := reflect.ValueOf(value)\n\tif v.Kind() == reflect.String {\n\t\treturn v.String(), nil\n\t}\n\tif v.Type() == bytesType {\n\t\treturn string(v.Interface().([]byte)), nil\n\t}\n\treturn \"\", errors.New(\"must be either a string or byte slice\")\n}\n\n// StringOrBytes typecasts a value into a string or byte slice.\n// Boolean flags are returned to indicate if the typecasting succeeds or not.\nfunc StringOrBytes(value interface{}) (isString bool, str string, isBytes bool, bs []byte) {\n\tv := reflect.ValueOf(value)\n\tif v.Kind() == reflect.String {\n\t\tstr = v.String()\n\t\tisString = true\n\t} else if v.Kind() == reflect.Slice && v.Type() == bytesType {\n\t\tbs = v.Interface().([]byte)\n\t\tisBytes = true\n\t}\n\treturn\n}\n\n// LengthOfValue returns the length of a value that is a string, slice, map, or array.\n// An error is returned for all other types.\nfunc LengthOfValue(value interface{}) (int, error) {\n\tv := reflect.ValueOf(value)\n\tswitch v.Kind() {\n\tcase reflect.String, reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn v.Len(), nil\n\t}\n\treturn 0, fmt.Errorf(\"cannot get the length of %v\", v.Kind())\n}\n\n// ToInt converts the given value to an int64.\n// An error is returned for all incompatible types.\nfunc ToInt(value interface{}) (int64, error) {\n\tv := reflect.ValueOf(value)\n\tswitch v.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int(), nil\n\t}\n\treturn 0, fmt.Errorf(\"cannot convert %v to int64\", v.Kind())\n}\n\n// ToUint converts the given value to an uint64.\n// An error is returned for all incompatible types.\nfunc ToUint(value interface{}) (uint64, error) {\n\tv := reflect.ValueOf(value)\n\tswitch v.Kind() {\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint(), nil\n\t}\n\treturn 0, fmt.Errorf(\"cannot convert %v to uint64\", v.Kind())\n}\n\n// ToFloat converts the given value to a float64.\n// An error is returned for all incompatible types.\nfunc ToFloat(value interface{}) (float64, error) {\n\tv := reflect.ValueOf(value)\n\tswitch v.Kind() {\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float(), nil\n\t}\n\treturn 0, fmt.Errorf(\"cannot convert %v to float64\", v.Kind())\n}\n\n// IsEmpty checks if a value is empty or not.\n// A value is considered empty if\n// - integer, float: zero\n// - bool: false\n// - string, array: len() == 0\n// - slice, map: nil or len() == 0\n// - interface, pointer: nil or the referenced value is empty\nfunc IsEmpty(value interface{}) bool {\n\tv := reflect.ValueOf(value)\n\tswitch v.Kind() {\n\tcase reflect.String, reflect.Array, reflect.Map, reflect.Slice:\n\t\treturn v.Len() == 0\n\tcase reflect.Bool:\n\t\treturn !v.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float() == 0\n\tcase reflect.Invalid:\n\t\treturn true\n\tcase reflect.Interface, reflect.Ptr:\n\t\tif v.IsNil() {\n\t\t\treturn true\n\t\t}\n\t\treturn IsEmpty(v.Elem().Interface())\n\tcase reflect.Struct:\n\t\tv, ok := value.(time.Time)\n\t\tif ok && v.IsZero() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Indirect returns the value that the given interface or pointer references to.\n// If the value implements driver.Valuer, it will deal with the value returned by\n// the Value() method instead. A boolean value is also returned to indicate if\n// the value is nil or not (only applicable to interface, pointer, map, and slice).\n// If the value is neither an interface nor a pointer, it will be returned back.\nfunc Indirect(value interface{}) (interface{}, bool) {\n\trv := reflect.ValueOf(value)\n\tkind := rv.Kind()\n\tswitch kind {\n\tcase reflect.Invalid:\n\t\treturn nil, true\n\tcase reflect.Ptr, reflect.Interface:\n\t\tif rv.IsNil() {\n\t\t\treturn nil, true\n\t\t}\n\t\treturn Indirect(rv.Elem().Interface())\n\tcase reflect.Slice, reflect.Map, reflect.Func, reflect.Chan:\n\t\tif rv.IsNil() {\n\t\t\treturn nil, true\n\t\t}\n\t}\n\n\tif rv.Type().Implements(valuerType) {\n\t\treturn indirectValuer(value.(driver.Valuer))\n\t}\n\n\treturn value, false\n}\n\nfunc indirectValuer(valuer driver.Valuer) (interface{}, bool) {\n\tif value, err := valuer.Value(); value != nil && err == nil {\n\t\treturn Indirect(value)\n\t}\n\treturn nil, true\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 7.2890625,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"database/sql\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEnsureString(t *testing.T) {\n\tstr := \"abc\"\n\tbytes := []byte(\"abc\")\n\n\ttests := []struct {\n\t\ttag      string\n\t\tvalue    interface{}\n\t\texpected string\n\t\thasError bool\n\t}{\n\t\t{\"t1\", \"abc\", \"abc\", false},\n\t\t{\"t2\", &str, \"\", true},\n\t\t{\"t3\", bytes, \"abc\", false},\n\t\t{\"t4\", &bytes, \"\", true},\n\t\t{\"t5\", 100, \"\", true},\n\t}\n\tfor _, test := range tests {\n\t\ts, err := EnsureString(test.value)\n\t\tif test.hasError {\n\t\t\tassert.NotNil(t, err, test.tag)\n\t\t} else {\n\t\t\tassert.Nil(t, err, test.tag)\n\t\t\tassert.Equal(t, test.expected, s, test.tag)\n\t\t}\n\t}\n}\n\ntype MyString string\n\nfunc TestStringOrBytes(t *testing.T) {\n\tstr := \"abc\"\n\tbytes := []byte(\"abc\")\n\tvar str2 string\n\tvar bytes2 []byte\n\tvar str3 MyString = \"abc\"\n\tvar str4 *string\n\n\ttests := []struct {\n\t\ttag      string\n\t\tvalue    interface{}\n\t\tstr      string\n\t\tbs       []byte\n\t\tisString bool\n\t\tisBytes  bool\n\t}{\n\t\t{\"t1\", str, \"abc\", nil, true, false},\n\t\t{\"t2\", &str, \"\", nil, false, false},\n\t\t{\"t3\", bytes, \"\", []byte(\"abc\"), false, true},\n\t\t{\"t4\", &bytes, \"\", nil, false, false},\n\t\t{\"t5\", 100, \"\", nil, false, false},\n\t\t{\"t6\", str2, \"\", nil, true, false},\n\t\t{\"t7\", &str2, \"\", nil, false, false},\n\t\t{\"t8\", bytes2, \"\", nil, false, true},\n\t\t{\"t9\", &bytes2, \"\", nil, false, false},\n\t\t{\"t10\", str3, \"abc\", nil, true, false},\n\t\t{\"t11\", &str3, \"\", nil, false, false},\n\t\t{\"t12\", str4, \"\", nil, false, false},\n\t}\n\tfor _, test := range tests {\n\t\tisString, str, isBytes, bs := StringOrBytes(test.value)\n\t\tassert.Equal(t, test.str, str, test.tag)\n\t\tassert.Equal(t, test.bs, bs, test.tag)\n\t\tassert.Equal(t, test.isString, isString, test.tag)\n\t\tassert.Equal(t, test.isBytes, isBytes, test.tag)\n\t}\n}\n\nfunc TestLengthOfValue(t *testing.T) {\n\tvar a [3]int\n\n\ttests := []struct {\n\t\ttag    string\n\t\tvalue  interface{}\n\t\tlength int\n\t\terr    string\n\t}{\n\t\t{\"t1\", \"abc\", 3, \"\"},\n\t\t{\"t2\", []int{1, 2}, 2, \"\"},\n\t\t{\"t3\", map[string]int{\"A\": 1, \"B\": 2}, 2, \"\"},\n\t\t{\"t4\", a, 3, \"\"},\n\t\t{\"t5\", &a, 0, \"cannot get the length of ptr\"},\n\t\t{\"t6\", 123, 0, \"cannot get the length of int\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tl, err := LengthOfValue(test.value)\n\t\tassert.Equal(t, test.length, l, test.tag)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestToInt(t *testing.T) {\n\tvar a int\n\n\ttests := []struct {\n\t\ttag    string\n\t\tvalue  interface{}\n\t\tresult int64\n\t\terr    string\n\t}{\n\t\t{\"t1\", 1, 1, \"\"},\n\t\t{\"t2\", int8(1), 1, \"\"},\n\t\t{\"t3\", int16(1), 1, \"\"},\n\t\t{\"t4\", int32(1), 1, \"\"},\n\t\t{\"t5\", int64(1), 1, \"\"},\n\t\t{\"t6\", &a, 0, \"cannot convert ptr to int64\"},\n\t\t{\"t7\", uint(1), 0, \"cannot convert uint to int64\"},\n\t\t{\"t8\", float64(1), 0, \"cannot convert float64 to int64\"},\n\t\t{\"t9\", \"abc\", 0, \"cannot convert string to int64\"},\n\t\t{\"t10\", []int{1, 2}, 0, \"cannot convert slice to int64\"},\n\t\t{\"t11\", map[string]int{\"A\": 1}, 0, \"cannot convert map to int64\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tl, err := ToInt(test.value)\n\t\tassert.Equal(t, test.result, l, test.tag)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestToUint(t *testing.T) {\n\tvar a int\n\tvar b uint\n\n\ttests := []struct {\n\t\ttag    string\n\t\tvalue  interface{}\n\t\tresult uint64\n\t\terr    string\n\t}{\n\t\t{\"t1\", uint(1), 1, \"\"},\n\t\t{\"t2\", uint8(1), 1, \"\"},\n\t\t{\"t3\", uint16(1), 1, \"\"},\n\t\t{\"t4\", uint32(1), 1, \"\"},\n\t\t{\"t5\", uint64(1), 1, \"\"},\n\t\t{\"t6\", 1, 0, \"cannot convert int to uint64\"},\n\t\t{\"t7\", &a, 0, \"cannot convert ptr to uint64\"},\n\t\t{\"t8\", &b, 0, \"cannot convert ptr to uint64\"},\n\t\t{\"t9\", float64(1), 0, \"cannot convert float64 to uint64\"},\n\t\t{\"t10\", \"abc\", 0, \"cannot convert string to uint64\"},\n\t\t{\"t11\", []int{1, 2}, 0, \"cannot convert slice to uint64\"},\n\t\t{\"t12\", map[string]int{\"A\": 1}, 0, \"cannot convert map to uint64\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tl, err := ToUint(test.value)\n\t\tassert.Equal(t, test.result, l, test.tag)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestToFloat(t *testing.T) {\n\tvar a int\n\tvar b uint\n\n\ttests := []struct {\n\t\ttag    string\n\t\tvalue  interface{}\n\t\tresult float64\n\t\terr    string\n\t}{\n\t\t{\"t1\", float32(1), 1, \"\"},\n\t\t{\"t2\", float64(1), 1, \"\"},\n\t\t{\"t3\", 1, 0, \"cannot convert int to float64\"},\n\t\t{\"t4\", uint(1), 0, \"cannot convert uint to float64\"},\n\t\t{\"t5\", &a, 0, \"cannot convert ptr to float64\"},\n\t\t{\"t6\", &b, 0, \"cannot convert ptr to float64\"},\n\t\t{\"t7\", \"abc\", 0, \"cannot convert string to float64\"},\n\t\t{\"t8\", []int{1, 2}, 0, \"cannot convert slice to float64\"},\n\t\t{\"t9\", map[string]int{\"A\": 1}, 0, \"cannot convert map to float64\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tl, err := ToFloat(test.value)\n\t\tassert.Equal(t, test.result, l, test.tag)\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\nfunc TestIsEmpty(t *testing.T) {\n\tvar s1 string\n\tvar s2 = \"a\"\n\tvar s3 *string\n\ts4 := struct{}{}\n\ttime1 := time.Now()\n\tvar time2 time.Time\n\ttests := []struct {\n\t\ttag   string\n\t\tvalue interface{}\n\t\tempty bool\n\t}{\n\t\t// nil\n\t\t{\"t0\", nil, true},\n\t\t// string\n\t\t{\"t1.1\", \"\", true},\n\t\t{\"t1.2\", \"1\", false},\n\t\t{\"t1.3\", MyString(\"\"), true},\n\t\t{\"t1.4\", MyString(\"1\"), false},\n\t\t// slice\n\t\t{\"t2.1\", []byte(\"\"), true},\n\t\t{\"t2.2\", []byte(\"1\"), false},\n\t\t// map\n\t\t{\"t3.1\", map[string]int{}, true},\n\t\t{\"t3.2\", map[string]int{\"a\": 1}, false},\n\t\t// bool\n\t\t{\"t4.1\", false, true},\n\t\t{\"t4.2\", true, false},\n\t\t// int\n\t\t{\"t5.1\", 0, true},\n\t\t{\"t5.2\", int8(0), true},\n\t\t{\"t5.3\", int16(0), true},\n\t\t{\"t5.4\", int32(0), true},\n\t\t{\"t5.5\", int64(0), true},\n\t\t{\"t5.6\", 1, false},\n\t\t{\"t5.7\", int8(1), false},\n\t\t{\"t5.8\", int16(1), false},\n\t\t{\"t5.9\", int32(1), false},\n\t\t{\"t5.10\", int64(1), false},\n\t\t// uint\n\t\t{\"t6.1\", uint(0), true},\n\t\t{\"t6.2\", uint8(0), true},\n\t\t{\"t6.3\", uint16(0), true},\n\t\t{\"t6.4\", uint32(0), true},\n\t\t{\"t6.5\", uint64(0), true},\n\t\t{\"t6.6\", uint(1), false},\n\t\t{\"t6.7\", uint8(1), false},\n\t\t{\"t6.8\", uint16(1), false},\n\t\t{\"t6.9\", uint32(1), false},\n\t\t{\"t6.10\", uint64(1), false},\n\t\t// float\n\t\t{\"t7.1\", float32(0), true},\n\t\t{\"t7.2\", float64(0), true},\n\t\t{\"t7.3\", float32(1), false},\n\t\t{\"t7.4\", float64(1), false},\n\t\t// interface, ptr\n\t\t{\"t8.1\", &s1, true},\n\t\t{\"t8.2\", &s2, false},\n\t\t{\"t8.3\", s3, true},\n\t\t// struct\n\t\t{\"t9.1\", s4, false},\n\t\t{\"t9.2\", &s4, false},\n\t\t// time.Time\n\t\t{\"t10.1\", time1, false},\n\t\t{\"t10.2\", &time1, false},\n\t\t{\"t10.3\", time2, true},\n\t\t{\"t10.4\", &time2, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tempty := IsEmpty(test.value)\n\t\tassert.Equal(t, test.empty, empty, test.tag)\n\t}\n}\n\nfunc TestIndirect(t *testing.T) {\n\tvar a = 100\n\tvar b *int\n\tvar c *sql.NullInt64\n\n\ttests := []struct {\n\t\ttag    string\n\t\tvalue  interface{}\n\t\tresult interface{}\n\t\tisNil  bool\n\t}{\n\t\t{\"t1\", 100, 100, false},\n\t\t{\"t2\", &a, 100, false},\n\t\t{\"t3\", b, nil, true},\n\t\t{\"t4\", nil, nil, true},\n\t\t{\"t5\", sql.NullInt64{Int64: 0, Valid: false}, nil, true},\n\t\t{\"t6\", sql.NullInt64{Int64: 1, Valid: false}, nil, true},\n\t\t{\"t7\", &sql.NullInt64{Int64: 0, Valid: false}, nil, true},\n\t\t{\"t8\", &sql.NullInt64{Int64: 1, Valid: false}, nil, true},\n\t\t{\"t9\", sql.NullInt64{Int64: 0, Valid: true}, int64(0), false},\n\t\t{\"t10\", sql.NullInt64{Int64: 1, Valid: true}, int64(1), false},\n\t\t{\"t11\", &sql.NullInt64{Int64: 0, Valid: true}, int64(0), false},\n\t\t{\"t12\", &sql.NullInt64{Int64: 1, Valid: true}, int64(1), false},\n\t\t{\"t13\", c, nil, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, isNil := Indirect(test.value)\n\t\tassert.Equal(t, test.result, result, test.tag)\n\t\tassert.Equal(t, test.isNil, isNil, test.tag)\n\t}\n}\n"
        },
        {
          "name": "validation.go",
          "type": "blob",
          "size": 8.0341796875,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\n// Package validation provides configurable and extensible rules for validating data of various types.\npackage validation\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n)\n\ntype (\n\t// Validatable is the interface indicating the type implementing it supports data validation.\n\tValidatable interface {\n\t\t// Validate validates the data and returns an error if validation fails.\n\t\tValidate() error\n\t}\n\n\t// ValidatableWithContext is the interface indicating the type implementing it supports context-aware data validation.\n\tValidatableWithContext interface {\n\t\t// ValidateWithContext validates the data with the given context and returns an error if validation fails.\n\t\tValidateWithContext(ctx context.Context) error\n\t}\n\n\t// Rule represents a validation rule.\n\tRule interface {\n\t\t// Validate validates a value and returns a value if validation fails.\n\t\tValidate(value interface{}) error\n\t}\n\n\t// RuleWithContext represents a context-aware validation rule.\n\tRuleWithContext interface {\n\t\t// ValidateWithContext validates a value and returns a value if validation fails.\n\t\tValidateWithContext(ctx context.Context, value interface{}) error\n\t}\n\n\t// RuleFunc represents a validator function.\n\t// You may wrap it as a Rule by calling By().\n\tRuleFunc func(value interface{}) error\n\n\t// RuleWithContextFunc represents a validator function that is context-aware.\n\t// You may wrap it as a Rule by calling WithContext().\n\tRuleWithContextFunc func(ctx context.Context, value interface{}) error\n)\n\nvar (\n\t// ErrorTag is the struct tag name used to customize the error field name for a struct field.\n\tErrorTag = \"json\"\n\n\t// Skip is a special validation rule that indicates all rules following it should be skipped.\n\tSkip = skipRule{skip: true}\n\n\tvalidatableType            = reflect.TypeOf((*Validatable)(nil)).Elem()\n\tvalidatableWithContextType = reflect.TypeOf((*ValidatableWithContext)(nil)).Elem()\n)\n\n// Validate validates the given value and returns the validation error, if any.\n//\n// Validate performs validation using the following steps:\n// 1. For each rule, call its `Validate()` to validate the value. Return if any error is found.\n// 2. If the value being validated implements `Validatable`, call the value's `Validate()`.\n//    Return with the validation result.\n// 3. If the value being validated is a map/slice/array, and the element type implements `Validatable`,\n//    for each element call the element value's `Validate()`. Return with the validation result.\nfunc Validate(value interface{}, rules ...Rule) error {\n\tfor _, rule := range rules {\n\t\tif s, ok := rule.(skipRule); ok && s.skip {\n\t\t\treturn nil\n\t\t}\n\t\tif err := rule.Validate(value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\trv := reflect.ValueOf(value)\n\tif (rv.Kind() == reflect.Ptr || rv.Kind() == reflect.Interface) && rv.IsNil() {\n\t\treturn nil\n\t}\n\n\tif v, ok := value.(Validatable); ok {\n\t\treturn v.Validate()\n\t}\n\n\tswitch rv.Kind() {\n\tcase reflect.Map:\n\t\tif rv.Type().Elem().Implements(validatableType) {\n\t\t\treturn validateMap(rv)\n\t\t}\n\tcase reflect.Slice, reflect.Array:\n\t\tif rv.Type().Elem().Implements(validatableType) {\n\t\t\treturn validateSlice(rv)\n\t\t}\n\tcase reflect.Ptr, reflect.Interface:\n\t\treturn Validate(rv.Elem().Interface())\n\t}\n\n\treturn nil\n}\n\n// ValidateWithContext validates the given value with the given context and returns the validation error, if any.\n//\n// ValidateWithContext performs validation using the following steps:\n// 1. For each rule, call its `ValidateWithContext()` to validate the value if the rule implements `RuleWithContext`.\n//    Otherwise call `Validate()` of the rule. Return if any error is found.\n// 2. If the value being validated implements `ValidatableWithContext`, call the value's `ValidateWithContext()`\n//    and return with the validation result.\n// 3. If the value being validated implements `Validatable`, call the value's `Validate()`\n//    and return with the validation result.\n// 4. If the value being validated is a map/slice/array, and the element type implements `ValidatableWithContext`,\n//    for each element call the element value's `ValidateWithContext()`. Return with the validation result.\n// 5. If the value being validated is a map/slice/array, and the element type implements `Validatable`,\n//    for each element call the element value's `Validate()`. Return with the validation result.\nfunc ValidateWithContext(ctx context.Context, value interface{}, rules ...Rule) error {\n\tfor _, rule := range rules {\n\t\tif s, ok := rule.(skipRule); ok && s.skip {\n\t\t\treturn nil\n\t\t}\n\t\tif rc, ok := rule.(RuleWithContext); ok {\n\t\t\tif err := rc.ValidateWithContext(ctx, value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if err := rule.Validate(value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\trv := reflect.ValueOf(value)\n\tif (rv.Kind() == reflect.Ptr || rv.Kind() == reflect.Interface) && rv.IsNil() {\n\t\treturn nil\n\t}\n\n\tif v, ok := value.(ValidatableWithContext); ok {\n\t\treturn v.ValidateWithContext(ctx)\n\t}\n\n\tif v, ok := value.(Validatable); ok {\n\t\treturn v.Validate()\n\t}\n\n\tswitch rv.Kind() {\n\tcase reflect.Map:\n\t\tif rv.Type().Elem().Implements(validatableWithContextType) {\n\t\t\treturn validateMapWithContext(ctx, rv)\n\t\t}\n\t\tif rv.Type().Elem().Implements(validatableType) {\n\t\t\treturn validateMap(rv)\n\t\t}\n\tcase reflect.Slice, reflect.Array:\n\t\tif rv.Type().Elem().Implements(validatableWithContextType) {\n\t\t\treturn validateSliceWithContext(ctx, rv)\n\t\t}\n\t\tif rv.Type().Elem().Implements(validatableType) {\n\t\t\treturn validateSlice(rv)\n\t\t}\n\tcase reflect.Ptr, reflect.Interface:\n\t\treturn ValidateWithContext(ctx, rv.Elem().Interface())\n\t}\n\n\treturn nil\n}\n\n// validateMap validates a map of validatable elements\nfunc validateMap(rv reflect.Value) error {\n\terrs := Errors{}\n\tfor _, key := range rv.MapKeys() {\n\t\tif mv := rv.MapIndex(key).Interface(); mv != nil {\n\t\t\tif err := mv.(Validatable).Validate(); err != nil {\n\t\t\t\terrs[fmt.Sprintf(\"%v\", key.Interface())] = err\n\t\t\t}\n\t\t}\n\t}\n\tif len(errs) > 0 {\n\t\treturn errs\n\t}\n\treturn nil\n}\n\n// validateMapWithContext validates a map of validatable elements with the given context.\nfunc validateMapWithContext(ctx context.Context, rv reflect.Value) error {\n\terrs := Errors{}\n\tfor _, key := range rv.MapKeys() {\n\t\tif mv := rv.MapIndex(key).Interface(); mv != nil {\n\t\t\tif err := mv.(ValidatableWithContext).ValidateWithContext(ctx); err != nil {\n\t\t\t\terrs[fmt.Sprintf(\"%v\", key.Interface())] = err\n\t\t\t}\n\t\t}\n\t}\n\tif len(errs) > 0 {\n\t\treturn errs\n\t}\n\treturn nil\n}\n\n// validateSlice validates a slice/array of validatable elements\nfunc validateSlice(rv reflect.Value) error {\n\terrs := Errors{}\n\tl := rv.Len()\n\tfor i := 0; i < l; i++ {\n\t\tif ev := rv.Index(i).Interface(); ev != nil {\n\t\t\tif err := ev.(Validatable).Validate(); err != nil {\n\t\t\t\terrs[strconv.Itoa(i)] = err\n\t\t\t}\n\t\t}\n\t}\n\tif len(errs) > 0 {\n\t\treturn errs\n\t}\n\treturn nil\n}\n\n// validateSliceWithContext validates a slice/array of validatable elements with the given context.\nfunc validateSliceWithContext(ctx context.Context, rv reflect.Value) error {\n\terrs := Errors{}\n\tl := rv.Len()\n\tfor i := 0; i < l; i++ {\n\t\tif ev := rv.Index(i).Interface(); ev != nil {\n\t\t\tif err := ev.(ValidatableWithContext).ValidateWithContext(ctx); err != nil {\n\t\t\t\terrs[strconv.Itoa(i)] = err\n\t\t\t}\n\t\t}\n\t}\n\tif len(errs) > 0 {\n\t\treturn errs\n\t}\n\treturn nil\n}\n\ntype skipRule struct {\n\tskip bool\n}\n\nfunc (r skipRule) Validate(interface{}) error {\n\treturn nil\n}\n\n// When determines if all rules following it should be skipped.\nfunc (r skipRule) When(condition bool) skipRule {\n\tr.skip = condition\n\treturn r\n}\n\ntype inlineRule struct {\n\tf  RuleFunc\n\tfc RuleWithContextFunc\n}\n\nfunc (r *inlineRule) Validate(value interface{}) error {\n\tif r.f == nil {\n\t\treturn r.fc(context.Background(), value)\n\t}\n\treturn r.f(value)\n}\n\nfunc (r *inlineRule) ValidateWithContext(ctx context.Context, value interface{}) error {\n\tif r.fc == nil {\n\t\treturn r.f(value)\n\t}\n\treturn r.fc(ctx, value)\n}\n\n// By wraps a RuleFunc into a Rule.\nfunc By(f RuleFunc) Rule {\n\treturn &inlineRule{f: f}\n}\n\n// WithContext wraps a RuleWithContextFunc into a context-aware Rule.\nfunc WithContext(f RuleWithContextFunc) Rule {\n\treturn &inlineRule{fc: f}\n}\n"
        },
        {
          "name": "validation_test.go",
          "type": "blob",
          "size": 6.8984375,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestValidate(t *testing.T) {\n\tslice := []String123{String123(\"abc\"), String123(\"123\"), String123(\"xyz\")}\n\tctxSlice := []Model4{{A: \"abc\"}, {A: \"def\"}}\n\tmp := map[string]String123{\"c\": String123(\"abc\"), \"b\": String123(\"123\"), \"a\": String123(\"xyz\")}\n\tmpCtx := map[string]StringValidateContext{\"c\": StringValidateContext(\"abc\"), \"b\": StringValidateContext(\"123\"), \"a\": StringValidateContext(\"xyz\")}\n\tvar (\n\t\tptr     *string\n\t\tnoCtx   StringValidate        = \"abc\"\n\t\twithCtx StringValidateContext = \"xyz\"\n\t)\n\ttests := []struct {\n\t\ttag            string\n\t\tvalue          interface{}\n\t\terr            string\n\t\terrWithContext string\n\t}{\n\t\t{\"t1\", 123, \"\", \"\"},\n\t\t{\"t2\", String123(\"123\"), \"\", \"\"},\n\t\t{\"t3\", String123(\"abc\"), \"error 123\", \"error 123\"},\n\t\t{\"t4\", []String123{}, \"\", \"\"},\n\t\t{\"t4.1\", []StringValidateContext{}, \"\", \"\"},\n\t\t{\"t4.2\", map[string]StringValidateContext{}, \"\", \"\"},\n\t\t{\"t5\", slice, \"0: error 123; 2: error 123.\", \"0: error 123; 2: error 123.\"},\n\t\t{\"t6\", &slice, \"0: error 123; 2: error 123.\", \"0: error 123; 2: error 123.\"},\n\t\t{\"t7\", ctxSlice, \"\", \"1: (A: error abc.).\"},\n\t\t{\"t8\", mp, \"a: error 123; c: error 123.\", \"a: error 123; c: error 123.\"},\n\t\t{\"t8.1\", mpCtx, \"a: must be abc; b: must be abc.\", \"a: must be abc with context; b: must be abc with context.\"},\n\t\t{\"t9\", &mp, \"a: error 123; c: error 123.\", \"a: error 123; c: error 123.\"},\n\t\t{\"t10\", map[string]String123{}, \"\", \"\"},\n\t\t{\"t11\", ptr, \"\", \"\"},\n\t\t{\"t12\", noCtx, \"called validate\", \"called validate\"},\n\t\t{\"t13\", withCtx, \"must be abc\", \"must be abc with context\"},\n\t}\n\tfor _, test := range tests {\n\t\terr := Validate(test.value)\n\t\tassertError(t, test.err, err, test.tag)\n\t\t// rules that are not context-aware should still be applied in context-aware validation\n\t\terr = ValidateWithContext(context.Background(), test.value)\n\t\tassertError(t, test.errWithContext, err, test.tag)\n\t}\n\n\t// with rules\n\terr := Validate(\"123\", &validateAbc{}, &validateXyz{})\n\tassert.EqualError(t, err, \"error abc\")\n\terr = Validate(\"abc\", &validateAbc{}, &validateXyz{})\n\tassert.EqualError(t, err, \"error xyz\")\n\terr = Validate(\"abcxyz\", &validateAbc{}, &validateXyz{})\n\tassert.NoError(t, err)\n\n\terr = Validate(\"123\", &validateAbc{}, Skip, &validateXyz{})\n\tassert.EqualError(t, err, \"error abc\")\n\terr = Validate(\"abc\", &validateAbc{}, Skip, &validateXyz{})\n\tassert.NoError(t, err)\n\n\terr = Validate(\"123\", &validateAbc{}, Skip.When(true), &validateXyz{})\n\tassert.EqualError(t, err, \"error abc\")\n\terr = Validate(\"abc\", &validateAbc{}, Skip.When(true), &validateXyz{})\n\tassert.NoError(t, err)\n\n\terr = Validate(\"123\", &validateAbc{}, Skip.When(false), &validateXyz{})\n\tassert.EqualError(t, err, \"error abc\")\n\terr = Validate(\"abc\", &validateAbc{}, Skip.When(false), &validateXyz{})\n\tassert.EqualError(t, err, \"error xyz\")\n}\n\nfunc stringEqual(str string) RuleFunc {\n\treturn func(value interface{}) error {\n\t\ts, _ := value.(string)\n\t\tif s != str {\n\t\t\treturn errors.New(\"unexpected string\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc TestBy(t *testing.T) {\n\tabcRule := By(func(value interface{}) error {\n\t\ts, _ := value.(string)\n\t\tif s != \"abc\" {\n\t\t\treturn errors.New(\"must be abc\")\n\t\t}\n\t\treturn nil\n\t})\n\tassert.Nil(t, Validate(\"abc\", abcRule))\n\terr := Validate(\"xyz\", abcRule)\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"must be abc\", err.Error())\n\t}\n\n\txyzRule := By(stringEqual(\"xyz\"))\n\tassert.Nil(t, Validate(\"xyz\", xyzRule))\n\tassert.NotNil(t, Validate(\"abc\", xyzRule))\n\tassert.Nil(t, ValidateWithContext(context.Background(), \"xyz\", xyzRule))\n\tassert.NotNil(t, ValidateWithContext(context.Background(), \"abc\", xyzRule))\n}\n\ntype key int\n\nfunc TestByWithContext(t *testing.T) {\n\tk := key(1)\n\tabcRule := WithContext(func(ctx context.Context, value interface{}) error {\n\t\tif ctx.Value(k) != value.(string) {\n\t\t\treturn errors.New(\"must be abc\")\n\t\t}\n\t\treturn nil\n\t})\n\tctx := context.WithValue(context.Background(), k, \"abc\")\n\tassert.Nil(t, ValidateWithContext(ctx, \"abc\", abcRule))\n\terr := ValidateWithContext(ctx, \"xyz\", abcRule)\n\tif assert.NotNil(t, err) {\n\t\tassert.Equal(t, \"must be abc\", err.Error())\n\t}\n\n\tassert.NotNil(t, Validate(\"abc\", abcRule))\n}\n\nfunc Test_skipRule_Validate(t *testing.T) {\n\tassert.Nil(t, Skip.Validate(100))\n}\n\nfunc assertError(t *testing.T, expected string, err error, tag string) {\n\tif expected == \"\" {\n\t\tassert.NoError(t, err, tag)\n\t} else {\n\t\tassert.EqualError(t, err, expected, tag)\n\t}\n}\n\ntype validateAbc struct{}\n\nfunc (v *validateAbc) Validate(obj interface{}) error {\n\tif !strings.Contains(obj.(string), \"abc\") {\n\t\treturn errors.New(\"error abc\")\n\t}\n\treturn nil\n}\n\ntype validateContextAbc struct{}\n\nfunc (v *validateContextAbc) Validate(obj interface{}) error {\n\treturn v.ValidateWithContext(context.Background(), obj)\n}\n\nfunc (v *validateContextAbc) ValidateWithContext(_ context.Context, obj interface{}) error {\n\tif !strings.Contains(obj.(string), \"abc\") {\n\t\treturn errors.New(\"error abc\")\n\t}\n\treturn nil\n}\n\ntype validateXyz struct{}\n\nfunc (v *validateXyz) Validate(obj interface{}) error {\n\tif !strings.Contains(obj.(string), \"xyz\") {\n\t\treturn errors.New(\"error xyz\")\n\t}\n\treturn nil\n}\n\ntype validateContextXyz struct{}\n\nfunc (v *validateContextXyz) Validate(obj interface{}) error {\n\treturn v.ValidateWithContext(context.Background(), obj)\n}\n\nfunc (v *validateContextXyz) ValidateWithContext(_ context.Context, obj interface{}) error {\n\tif !strings.Contains(obj.(string), \"xyz\") {\n\t\treturn errors.New(\"error xyz\")\n\t}\n\treturn nil\n}\n\ntype validateInternalError struct{}\n\nfunc (v *validateInternalError) Validate(obj interface{}) error {\n\tif strings.Contains(obj.(string), \"internal\") {\n\t\treturn NewInternalError(errors.New(\"error internal\"))\n\t}\n\treturn nil\n}\n\ntype Model1 struct {\n\tA string\n\tB string\n\tc string\n\tD *string\n\tE String123\n\tF *String123\n\tG string `json:\"g\"`\n\tH []string\n\tI map[string]string\n}\n\ntype String123 string\n\nfunc (s String123) Validate() error {\n\tif !strings.Contains(string(s), \"123\") {\n\t\treturn errors.New(\"error 123\")\n\t}\n\treturn nil\n}\n\ntype Model2 struct {\n\tModel3\n\tM3 Model3\n\tB  string\n}\n\ntype Model3 struct {\n\tA string\n}\n\nfunc (m Model3) Validate() error {\n\treturn ValidateStruct(&m,\n\t\tField(&m.A, &validateAbc{}),\n\t)\n}\n\ntype Model4 struct {\n\tA string\n}\n\nfunc (m Model4) ValidateWithContext(ctx context.Context) error {\n\treturn ValidateStructWithContext(ctx, &m,\n\t\tField(&m.A, &validateContextAbc{}),\n\t)\n}\n\ntype Model5 struct {\n\tModel4\n\tM4 Model4\n\tB  string\n}\n\ntype StringValidate string\n\nfunc (s StringValidate) Validate() error {\n\treturn errors.New(\"called validate\")\n}\n\ntype StringValidateContext string\n\nfunc (s StringValidateContext) Validate() error {\n\tif string(s) != \"abc\" {\n\t\treturn errors.New(\"must be abc\")\n\t}\n\treturn nil\n}\n\nfunc (s StringValidateContext) ValidateWithContext(context.Context) error {\n\tif string(s) != \"abc\" {\n\t\treturn errors.New(\"must be abc with context\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "when.go",
          "type": "blob",
          "size": 1.271484375,
          "content": "package validation\n\nimport \"context\"\n\n// When returns a validation rule that executes the given list of rules when the condition is true.\nfunc When(condition bool, rules ...Rule) WhenRule {\n\treturn WhenRule{\n\t\tcondition: condition,\n\t\trules:     rules,\n\t\telseRules: []Rule{},\n\t}\n}\n\n// WhenRule is a validation rule that executes the given list of rules when the condition is true.\ntype WhenRule struct {\n\tcondition bool\n\trules     []Rule\n\telseRules []Rule\n}\n\n// Validate checks if the condition is true and if so, it validates the value using the specified rules.\nfunc (r WhenRule) Validate(value interface{}) error {\n\treturn r.ValidateWithContext(nil, value)\n}\n\n// ValidateWithContext checks if the condition is true and if so, it validates the value using the specified rules.\nfunc (r WhenRule) ValidateWithContext(ctx context.Context, value interface{}) error {\n\tif r.condition {\n\t\tif ctx == nil {\n\t\t\treturn Validate(value, r.rules...)\n\t\t}\n\t\treturn ValidateWithContext(ctx, value, r.rules...)\n\t}\n\n\tif ctx == nil {\n\t\treturn Validate(value, r.elseRules...)\n\t}\n\treturn ValidateWithContext(ctx, value, r.elseRules...)\n}\n\n// Else returns a validation rule that executes the given list of rules when the condition is false.\nfunc (r WhenRule) Else(rules ...Rule) WhenRule {\n\tr.elseRules = rules\n\treturn r\n}\n"
        },
        {
          "name": "when_test.go",
          "type": "blob",
          "size": 3.037109375,
          "content": "// Copyright 2016 Qiang Xue. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage validation\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc abcValidation(val string) bool {\n\treturn val == \"abc\"\n}\n\nfunc TestWhen(t *testing.T) {\n\tabcRule := NewStringRule(abcValidation, \"wrong_abc\")\n\tvalidateMeRule := NewStringRule(validateMe, \"wrong_me\")\n\n\ttests := []struct {\n\t\ttag       string\n\t\tcondition bool\n\t\tvalue     interface{}\n\t\trules     []Rule\n\t\telseRules []Rule\n\t\terr       string\n\t}{\n\t\t// True condition\n\t\t{\"t1.1\", true, nil, []Rule{}, []Rule{}, \"\"},\n\t\t{\"t1.2\", true, \"\", []Rule{}, []Rule{}, \"\"},\n\t\t{\"t1.3\", true, \"\", []Rule{abcRule}, []Rule{}, \"\"},\n\t\t{\"t1.4\", true, 12, []Rule{Required}, []Rule{}, \"\"},\n\t\t{\"t1.5\", true, nil, []Rule{Required}, []Rule{}, \"cannot be blank\"},\n\t\t{\"t1.6\", true, \"123\", []Rule{abcRule}, []Rule{}, \"wrong_abc\"},\n\t\t{\"t1.7\", true, \"abc\", []Rule{abcRule}, []Rule{}, \"\"},\n\t\t{\"t1.8\", true, \"abc\", []Rule{abcRule, abcRule}, []Rule{}, \"\"},\n\t\t{\"t1.9\", true, \"abc\", []Rule{abcRule, validateMeRule}, []Rule{}, \"wrong_me\"},\n\t\t{\"t1.10\", true, \"me\", []Rule{abcRule, validateMeRule}, []Rule{}, \"wrong_abc\"},\n\t\t{\"t1.11\", true, \"me\", []Rule{}, []Rule{abcRule}, \"\"},\n\n\t\t// False condition\n\t\t{\"t2.1\", false, \"\", []Rule{}, []Rule{}, \"\"},\n\t\t{\"t2.2\", false, \"\", []Rule{abcRule}, []Rule{}, \"\"},\n\t\t{\"t2.3\", false, \"abc\", []Rule{abcRule}, []Rule{}, \"\"},\n\t\t{\"t2.4\", false, \"abc\", []Rule{abcRule, abcRule}, []Rule{}, \"\"},\n\t\t{\"t2.5\", false, \"abc\", []Rule{abcRule, validateMeRule}, []Rule{}, \"\"},\n\t\t{\"t2.6\", false, \"me\", []Rule{abcRule, validateMeRule}, []Rule{}, \"\"},\n\t\t{\"t2.7\", false, \"\", []Rule{abcRule, validateMeRule}, []Rule{}, \"\"},\n\t\t{\"t2.8\", false, \"me\", []Rule{}, []Rule{abcRule, validateMeRule}, \"wrong_abc\"},\n\t}\n\n\tfor _, test := range tests {\n\t\terr := Validate(test.value, When(test.condition, test.rules...).Else(test.elseRules...))\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n\ntype ctxKey int\n\nconst (\n\tcontains ctxKey = iota\n)\n\nfunc TestWhenWithContext(t *testing.T) {\n\trule := WithContext(func(ctx context.Context, value interface{}) error {\n\t\tif !strings.Contains(value.(string), ctx.Value(contains).(string)) {\n\t\t\treturn errors.New(\"unexpected value\")\n\t\t}\n\t\treturn nil\n\t})\n\tctx1 := context.WithValue(context.Background(), contains, \"abc\")\n\tctx2 := context.WithValue(context.Background(), contains, \"xyz\")\n\n\ttests := []struct {\n\t\ttag       string\n\t\tcondition bool\n\t\tvalue     interface{}\n\t\tctx       context.Context\n\t\terr       string\n\t}{\n\t\t// True condition\n\t\t{\"t1.1\", true, \"abc\", ctx1, \"\"},\n\t\t{\"t1.2\", true, \"abc\", ctx2, \"unexpected value\"},\n\t\t{\"t1.3\", true, \"xyz\", ctx1, \"unexpected value\"},\n\t\t{\"t1.4\", true, \"xyz\", ctx2, \"\"},\n\n\t\t// False condition\n\t\t{\"t2.1\", false, \"abc\", ctx1, \"\"},\n\t\t{\"t2.2\", false, \"abc\", ctx2, \"unexpected value\"},\n\t\t{\"t2.3\", false, \"xyz\", ctx1, \"unexpected value\"},\n\t\t{\"t2.4\", false, \"xyz\", ctx2, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\terr := ValidateWithContext(test.ctx, test.value, When(test.condition, rule).Else(rule))\n\t\tassertError(t, test.err, err, test.tag)\n\t}\n}\n"
        }
      ]
    }
  ]
}