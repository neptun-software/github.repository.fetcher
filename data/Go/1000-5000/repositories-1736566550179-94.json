{
  "metadata": {
    "timestamp": 1736566550179,
    "page": 94,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "writefreely/writefreely",
      "stars": 4603,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": "Dockerfile\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1337890625,
          "content": "root = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\ncharset = utf-8\n\n[*.go]\nindent_style = tab\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.083984375,
          "content": "node_modules\n*~\n*.swp\n*.swo\n\nstatic/local/custom.css\nbuild\ntmp\n*.ini\n*.db\n\nbindata.go\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0712890625,
          "content": "language: go\n\ngo:\n  - \"1.13.x\"\n\nenv:\n  - GO111MODULE=on\n\nscript: make ci\n"
        },
        {
          "name": "AUTHORS.md",
          "type": "blob",
          "size": 0.4296875,
          "content": "# WriteFreely Contributors\n\nWriteFreely is built by [Matt Baer](https://github.com/thebaer), with contributions from:\n\n* [Jean-Francois Arseneau](https://github.com/TheJF)\n* [Ben Overmyer](https://github.com/BenOvermyer)\n* [Marcel van der Boom](https://github.com/mrvdb)\n* [Brad Koehn](https://github.com/koehn)\n* [kaiyou](https://github.com/kaiyou)\n* [Aaron Ogle](https://github.com/geekgonecrazy)\n* [Norman](https://github.com/nkoehring)\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5.9814453125,
          "content": "# Contributing to WriteFreely\n\nWelcome! We're glad you're interested in contributing to WriteFreely.\n\nFor **questions**, **help**, **feature requests**, and **general discussion**, please use [our forum](https://discuss.write.as).\n\nFor **bug reports**, please [open a GitHub issue](https://github.com/writefreely/writefreely/issues/new). See our guide on [submitting bug reports](https://writefreely.org/contribute#bugs).\n\n## Getting Started\n\nThere are many ways to contribute to WriteFreely, from code to documentation, to translations, to help in the community!\n\nSee our [Contributing Guide](https://writefreely.org/contribute) on WriteFreely.org for ways to contribute without writing code. Otherwise, please read on.\n\n## Working on WriteFreely\n\nFirst, you'll want to clone the WriteFreely repo, install development dependencies, and build the application from source. Learn how to do this in our [Development Setup](https://writefreely.org/docs/latest/developer/setup) guide.\n\n### Starting development\n\nNext, [join our forum](https://discuss.write.as) so you can discuss development with the team. Then take a look at [our roadmap on Phabricator](https://todo.musing.studio/tag/writefreely/) to see where the project is today and where it's headed.\n\nWhen you find something you want to work on, start a new topic on the forum or jump into an existing discussion, if there is one. The team will respond and continue the conversation there.\n\nLastly, **before submitting any code**, please sign our [contributor's agreement](https://todo.musing.studio/L1) so we can accept your contributions. It is substantially similar to the _Apache Individual Contributor License Agreement_. If you'd like to know about the rationale behind this requirement, you can [read more about that here](https://todo.musing.studio/w/writefreely/cla/).\n\n### Branching\n\nAll stable work lives on the `master` branch. We merge into it only when creating a release. Releases are tagged using semantic versioning.\n\nWhile developing, we primarily work from the `develop` branch, creating _feature branches_ off of it for new features and fixes. When starting a new feature or fix, you should also create a new branch off of `develop`.\n\n#### Branch naming\n\nFor fixes and modifications to existing behavior, branch names should follow a similar pattern to commit messages (see below), such as `fix-post-rendering` or `update-documentation`. You can optionally append a task number, e.g. `fix-post-rendering-T000`.\n\nFor new features, branches can be named after the new feature, e.g. `activitypub-mentions` or `import-zip`.\n\n#### Pull request scope\n\nThe scope of work on each branch should be as small as possible -- one complete feature, one complete change, or one complete fix. This makes it easier for us to review and accept.\n\n### Writing code\n\nWe value reliable, readable, and maintainable code over all else in our work. To help you write that kind of code, we offer a few guiding principles, as well as a few concrete guidelines.\n\n#### Guiding principles\n\n* Write code for other humans, not computers.\n* The less complexity, the better. The more someone can understand code just by looking at it, the better.\n* Functionality, readability, and maintainability over senseless elegance.\n* Only abstract when necessary.\n* Keep an eye to the future, but don't pre-optimize at the expense of today's simplicity.\n\n#### Code guidelines\n\n* Format all Go code with `go fmt` before committing (**important!**)\n* Follow whitespace conventions established within the project (tabs vs. spaces)\n* Add comments to exported Go functions and variables\n* Follow Go naming conventions, like using [`mixedCaps`](https://golang.org/doc/effective_go.html#mixed-caps)\n* Avoid new dependencies unless absolutely necessary\n\n### Commit messages\n\nWe highly value commit messages that follow established form within the project. Generally speaking, we follow the practices [outlined](https://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project#_commit_guidelines) in the Pro Git Book. A good commit message will look like the following:\n\n* **Line 1**: A short summary written in the present imperative tense. For example:\n  * ✔️ **Good**: \"Fix post rendering bug\"\n  * ❌ No: ~~\"Fixes post rendering bug\"~~\n  * ❌ No: ~~\"Fixing post rendering bug\"~~\n  * ❌ No: ~~\"Fixed post rendering bug\"~~\n  * ❌ No: ~~\"Post rendering bug is fixed now\"~~\n* **Line 2**: _[left blank]_\n* **Line 3**: An added description of what changed, any rationale, etc. -- if necessary\n* **Last line**: A mention of any applicable task or issue\n  * For Phabricator tasks: `Ref T000` or `Closes T000`\n  * For GitHub issues: `Ref #000` or `Fixes #000`\n\n#### Good examples\n\nWhen in doubt, look to our existing git history for examples of good commit messages. Here are a few:\n\n* [Rename Suspend status to Silence](https://github.com/writefreely/writefreely/commit/7e014ca65958750ab703e317b1ce8cfc4aad2d6e)\n* [Show 404 when remote user not found](https://github.com/writefreely/writefreely/commit/867eb53b3596bd7b3f2be3c53a3faf857f4cd36d)\n* [Fix post deletion on Pleroma](https://github.com/writefreely/writefreely/commit/fe82cbb96e3d5c57cfde0db76c28c4ea6dabfe50)\n\n### Submitting pull requests\n\nLike our GitHub issues, we aim to keep our number of open pull requests to a minimum. You can follow a few guidelines to ensure changes are merged quickly.\n\nFirst, make sure your changes follow the established practices and good form outlined in this guide. This is crucial to our project, and ignoring our practices can delay otherwise important fixes.\n\nBeyond that, we prioritize pull requests in this order:\n\n1. Fixes to open GitHub issues\n2. Superficial changes and improvements that don't adversely impact users\n3. New features and changes that have been discussed before with the team\n\nAny pull requests that haven't previously been discussed with the team may be extensively delayed or closed, especially if they require a wider consideration before integrating into the project. When in doubt, please reach out [on the forum](https://discuss.write.as) before submitting a pull request.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.458984375,
          "content": "# Build image\nFROM golang:1.21-alpine3.18 as build\n\nLABEL org.opencontainers.image.source=\"https://github.com/writefreely/writefreely\"\nLABEL org.opencontainers.image.description=\"WriteFreely is a clean, minimalist publishing platform made for writers. Start a blog, share knowledge within your organization, or build a community around the shared act of writing.\"\n\nRUN apk -U upgrade \\\n    && apk add --no-cache nodejs npm make g++ git \\\n    && npm install -g less less-plugin-clean-css \\\n    && mkdir -p /go/src/github.com/writefreely/writefreely\n\nWORKDIR /go/src/github.com/writefreely/writefreely\n\nCOPY . .\n\nRUN cat ossl_legacy.cnf > /etc/ssl/openssl.cnf\n\nENV GO111MODULE=on\nENV NODE_OPTIONS=--openssl-legacy-provider\n\nRUN make build \\\n    && make ui \\\n    && mkdir /stage \\\n    && cp -R /go/bin \\\n      /go/src/github.com/writefreely/writefreely/templates \\\n      /go/src/github.com/writefreely/writefreely/static \\\n      /go/src/github.com/writefreely/writefreely/pages \\\n      /go/src/github.com/writefreely/writefreely/keys \\\n      /go/src/github.com/writefreely/writefreely/cmd \\\n      /stage\n\n# Final image\nFROM alpine:3.18.4\n\nRUN apk -U upgrade \\\n    && apk add --no-cache openssl ca-certificates\n\nCOPY --from=build --chown=daemon:daemon /stage /go\n\nWORKDIR /go\nVOLUME /go/keys\nEXPOSE 8080\nUSER daemon\n\nENTRYPOINT [\"cmd/writefreely/writefreely\"]\n\nHEALTHCHECK --start-period=5s --interval=15s --timeout=5s \\\n    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/ || exit 1"
        },
        {
          "name": "Dockerfile.prod",
          "type": "blob",
          "size": 1.396484375,
          "content": "FROM golang:alpine AS build\n\nLABEL org.opencontainers.image.source=\"https://github.com/writefreely/writefreely\"\nLABEL org.opencontainers.image.description=\"WriteFreely is a clean, minimalist publishing platform made for writers. Start a blog, share knowledge within your organization, or build a community around the shared act of writing.\"\n\nRUN apk update --no-cache && \\\n\tapk upgrade --no-cache && \\\n\tapk add --no-cache nodejs npm make g++ git sqlite-dev patch && \\\n\tnpm install -g less less-plugin-clean-css && \\\n\tmkdir -p /go/src/github.com/writefreely/writefreely\n\nCOPY . /go/src/github.com/writefreely/writefreely\nWORKDIR /go/src/github.com/writefreely/writefreely\nENV NODE_OPTIONS=--openssl-legacy-provider\nRUN cat ossl_legacy.cnf >> /etc/ssl/openssl.cnf && \\\n\tmake build && \\\n\tmake ui\n\nFROM alpine\n\nRUN apk update --no-cache && \\\n\tapk upgrade --no-cache && \\\n\tapk add --no-cache openssl ca-certificates && \\\n\tmkdir /usr/share/writefreely\n\nCOPY --from=build /go/src/github.com/writefreely/writefreely/cmd/writefreely/writefreely /usr/bin\nCOPY --from=build /go/src/github.com/writefreely/writefreely/pages /usr/share/writefreely/pages\nCOPY --from=build /go/src/github.com/writefreely/writefreely/static /usr/share/writefreely/static\nCOPY --from=build /go/src/github.com/writefreely/writefreely/templates /usr/share/writefreely/templates\n\nENV WRITEFREELY_DOCKER=True\nENV HOME=/data\nWORKDIR /data\nCMD [\"/usr/bin/writefreely\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 33.7109375,
          "content": "                    GNU AFFERO GENERAL PUBLIC LICENSE\n                       Version 3, 19 November 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU Affero General Public License is a free, copyleft license for\nsoftware and other kinds of works, specifically designed to ensure\ncooperation with the community in the case of network server software.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nour General Public Licenses are intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  Developers that use our General Public Licenses protect your rights\nwith two steps: (1) assert copyright on the software, and (2) offer\nyou this License which gives you legal permission to copy, distribute\nand/or modify the software.\n\n  A secondary benefit of defending all users' freedom is that\nimprovements made in alternate versions of the program, if they\nreceive widespread use, become available for other developers to\nincorporate.  Many developers of free software are heartened and\nencouraged by the resulting cooperation.  However, in the case of\nsoftware used on network servers, this result may fail to come about.\nThe GNU General Public License permits making a modified version and\nletting the public access it on a server without ever releasing its\nsource code to the public.\n\n  The GNU Affero General Public License is designed specifically to\nensure that, in such cases, the modified source code becomes available\nto the community.  It requires the operator of a network server to\nprovide the source code of the modified version running there to the\nusers of that server.  Therefore, public use of a modified version, on\na publicly accessible server, gives the public access to the source\ncode of the modified version.\n\n  An older license, called the Affero General Public License and\npublished by Affero, was designed to accomplish similar goals.  This is\na different license, not a version of the Affero GPL, but Affero has\nreleased a new version of the Affero GPL which permits relicensing under\nthis license.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU Affero General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Remote Network Interaction; Use with the GNU General Public License.\n\n  Notwithstanding any other provision of this License, if you modify the\nProgram, your modified version must prominently offer all users\ninteracting with it remotely through a computer network (if your version\nsupports such interaction) an opportunity to receive the Corresponding\nSource of your version by providing access to the Corresponding Source\nfrom a network server at no charge, through some standard or customary\nmeans of facilitating copying of software.  This Corresponding Source\nshall include the Corresponding Source for any work covered by version 3\nof the GNU General Public License that is incorporated pursuant to the\nfollowing paragraph.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the work with which it is combined will remain governed by version\n3 of the GNU General Public License.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU Affero General Public License from time to time.  Such new versions\nwill be similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU Affero General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU Affero General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU Affero General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If your software can interact with users remotely through a computer\nnetwork, you should also make sure that it provides a way for users to\nget its source.  For example, if your program is a web application, its\ninterface could display a \"Source\" link that leads users to an archive\nof the code.  There are many ways you could offer source, and different\nsolutions will be better for different programs; see section 13 for the\nspecific requirements.\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU AGPL, see\n<http://www.gnu.org/licenses/>.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.7109375,
          "content": "GITREV=`git describe | cut -c 2-`\nLDFLAGS=-ldflags=\"-s -w -X 'github.com/writefreely/writefreely.softwareVer=$(GITREV)' -extldflags '-static'\"\n\nGOCMD=go\nGOINSTALL=$(GOCMD) install $(LDFLAGS)\nGOBUILD=$(GOCMD) build $(LDFLAGS)\nGOTEST=$(GOCMD) test $(LDFLAGS)\nGOGET=$(GOCMD) get\nBINARY_NAME=writefreely\nBUILDPATH=build/$(BINARY_NAME)\nDOCKERCMD=docker\nIMAGE_NAME=writeas/writefreely\nTMPBIN=./tmp\n\nall : build\n\nci: deps\n\tcd cmd/writefreely; $(GOBUILD) -v\n\nbuild: deps\n\tcd cmd/writefreely; $(GOBUILD) -v -tags='netgo sqlite'\n\nbuild-no-sqlite: deps-no-sqlite\n\tcd cmd/writefreely; $(GOBUILD) -v -tags='netgo' -o $(BINARY_NAME)\n\nbuild-linux: deps\n\t@hash xgo > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GOCMD) install src.techknowlogick.com/xgo@latest; \\\n\tfi\n\txgo --targets=linux/amd64, -dest build/ $(LDFLAGS) -tags='netgo sqlite' -go go-1.21.x -out writefreely -pkg ./cmd/writefreely .\n\nbuild-windows: deps\n\t@hash xgo > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GOCMD) install src.techknowlogick.com/xgo@latest; \\\n\tfi\n\txgo --targets=windows/amd64, -dest build/ $(LDFLAGS) -tags='netgo sqlite' -go go-1.21.x -out writefreely -pkg ./cmd/writefreely .\n\nbuild-darwin: deps\n\t@hash xgo > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GOCMD) install src.techknowlogick.com/xgo@latest; \\\n\tfi\n\txgo --targets=darwin/amd64, -dest build/ $(LDFLAGS) -tags='netgo sqlite' -go go-1.21.x -out writefreely -pkg ./cmd/writefreely .\n\nbuild-arm6: deps\n\t@hash xgo > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GOCMD) install src.techknowlogick.com/xgo@latest; \\\n\tfi\n\txgo --targets=linux/arm-6, -dest build/ $(LDFLAGS) -tags='netgo sqlite' -go go-1.21.x -out writefreely -pkg ./cmd/writefreely .\n\nbuild-arm7: deps\n\t@hash xgo > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GOCMD) install src.techknowlogick.com/xgo@latest; \\\n\tfi\n\txgo --targets=linux/arm-7, -dest build/ $(LDFLAGS) -tags='netgo sqlite' -go go-1.21.x -out writefreely -pkg ./cmd/writefreely .\n\nbuild-arm64: deps\n\t@hash xgo > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GOCMD) install src.techknowlogick.com/xgo@latest; \\\n\tfi\n\txgo --targets=linux/arm64, -dest build/ $(LDFLAGS) -tags='netgo sqlite' -go go-1.21.x -out writefreely -pkg ./cmd/writefreely .\n\nbuild-docker :\n\t$(DOCKERCMD) build -t $(IMAGE_NAME):latest -t $(IMAGE_NAME):$(GITREV) .\n\ntest:\n\t$(GOTEST) -v ./...\n\nrun:\n\t$(GOINSTALL) -tags='netgo sqlite' ./...\n\t$(BINARY_NAME) --debug\n\ndeps :\n\t$(GOGET) -tags='sqlite' -d -v ./...\n\ndeps-no-sqlite:\n\t$(GOGET) -d -v ./...\n\ninstall : build\n\tcmd/writefreely/$(BINARY_NAME) --config\n\tcmd/writefreely/$(BINARY_NAME) --gen-keys\n\tcmd/writefreely/$(BINARY_NAME) --init-db\n\tcd less/; $(MAKE) install $(MFLAGS)\n\nrelease : clean ui\n\tmkdir -p $(BUILDPATH)\n\tcp -r templates $(BUILDPATH)\n\tcp -r pages $(BUILDPATH)\n\tcp -r static $(BUILDPATH)\n\trm -r $(BUILDPATH)/static/local\n\tscripts/invalidate-css.sh $(BUILDPATH)\n\tmkdir $(BUILDPATH)/keys\n\t$(MAKE) build-linux\n\tmv build/$(BINARY_NAME)-linux-amd64 $(BUILDPATH)/$(BINARY_NAME)\n\ttar -cvzf $(BINARY_NAME)_$(GITREV)_linux_amd64.tar.gz -C build $(BINARY_NAME)\n\trm $(BUILDPATH)/$(BINARY_NAME)\n\t$(MAKE) build-arm6\n\tmv build/$(BINARY_NAME)-linux-arm-6 $(BUILDPATH)/$(BINARY_NAME)\n\ttar -cvzf $(BINARY_NAME)_$(GITREV)_linux_arm6.tar.gz -C build $(BINARY_NAME)\n\trm $(BUILDPATH)/$(BINARY_NAME)\n\t$(MAKE) build-arm7\n\tmv build/$(BINARY_NAME)-linux-arm-7 $(BUILDPATH)/$(BINARY_NAME)\n\ttar -cvzf $(BINARY_NAME)_$(GITREV)_linux_arm7.tar.gz -C build $(BINARY_NAME)\n\trm $(BUILDPATH)/$(BINARY_NAME)\n\t$(MAKE) build-arm64\n\tmv build/$(BINARY_NAME)-linux-arm64 $(BUILDPATH)/$(BINARY_NAME)\n\ttar -cvzf $(BINARY_NAME)_$(GITREV)_linux_arm64.tar.gz -C build $(BINARY_NAME)\n\trm $(BUILDPATH)/$(BINARY_NAME)\n\t$(MAKE) build-darwin\n\tmv build/$(BINARY_NAME)-darwin-10.12-amd64 $(BUILDPATH)/$(BINARY_NAME)\n\ttar -cvzf $(BINARY_NAME)_$(GITREV)_macos_amd64.tar.gz -C build $(BINARY_NAME)\n\trm $(BUILDPATH)/$(BINARY_NAME)\n\t$(MAKE) build-windows\n\tmv build/$(BINARY_NAME)-windows-4.0-amd64.exe $(BUILDPATH)/$(BINARY_NAME).exe\n\tcd build; zip -r ../$(BINARY_NAME)_$(GITREV)_windows_amd64.zip ./$(BINARY_NAME)\n\trm $(BUILDPATH)/$(BINARY_NAME).exe\n\t$(MAKE) build-docker\n\t$(MAKE) release-docker\n\n# This assumes you're on linux/amd64\nrelease-linux : clean ui\n\tmkdir -p $(BUILDPATH)\n\tcp -r templates $(BUILDPATH)\n\tcp -r pages $(BUILDPATH)\n\tcp -r static $(BUILDPATH)\n\tmkdir $(BUILDPATH)/keys\n\t$(MAKE) build-no-sqlite\n\tmv cmd/writefreely/$(BINARY_NAME) $(BUILDPATH)/$(BINARY_NAME)\n\ttar -cvzf $(BINARY_NAME)_$(GITREV)_linux_amd64.tar.gz -C build $(BINARY_NAME)\n\nrelease-docker :\n\t$(DOCKERCMD) push $(IMAGE_NAME)\n\nui : force_look\n\tcd less/; $(MAKE) $(MFLAGS)\n\tcd prose/; $(MAKE) $(MFLAGS)\n\n$(TMPBIN):\n\tmkdir -p $(TMPBIN)\n\n$(TMPBIN)/xgo: deps $(TMPBIN)\n\t$(GOBUILD) -o $(TMPBIN)/xgo src.techknowlogick.com/xgo\n\nclean :\n\t-rm -rf build\n\t-rm -rf tmp\n\tcd less/; $(MAKE) clean $(MFLAGS)\n\nforce_look : \n\ttrue\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.9677734375,
          "content": "&nbsp;\n<p align=\"center\">\n\t<a href=\"https://writefreely.org\"><img src=\"https://writefreely.org/img/writefreely.svg\" width=\"350px\" alt=\"WriteFreely\" /></a>\n</p>\n<hr />\n<p align=\"center\">\n\t<a href=\"https://github.com/writefreely/writefreely/releases/\">\n\t\t<img src=\"https://img.shields.io/github/release/writefreely/writefreely.svg\" alt=\"Latest release\" />\n\t</a>\n\t<a href=\"https://travis-ci.org/writeas/writefreely\">\n\t\t<img src=\"https://travis-ci.org/writefreely/writefreely.svg\" alt=\"Build status\" />\n\t</a>\n\t<a href=\"https://github.com/writefreely/writefreely/releases/latest\">\n\t\t<img src=\"https://img.shields.io/github/downloads/writefreely/writefreely/total.svg\" />\n\t</a>\n\t<a href=\"https://goreportcard.com/report/github.com/writefreely/writefreely\">\n\t\t<img src=\"https://goreportcard.com/badge/github.com/writefreely/writefreely\" alt=\"Go Report Card\" />\n\t</a>\n\t<a href=\"https://hub.docker.com/r/writeas/writefreely/\">\n\t\t<img src=\"https://img.shields.io/docker/pulls/writeas/writefreely.svg\" />\n\t</a>\n</p>\n&nbsp;\n\nWriteFreely is a clean, minimalist publishing platform made for writers. Start a blog, share knowledge within your organization, or build a community around the shared act of writing.\n\n![](https://writefreely.org/img/screens/pencil-reader.png)\n\n[Try the writing experience](https://write.as/new)\n\n[Find an instance](https://writefreely.org/instances)\n\n## Features\n\n### Made for writing\n\nBuilt on a plain, auto-saving editor, WriteFreely gives you a distraction-free writing environment. Once published, your words are front and center, and easy to read.\n\n### A connected community\n\nStart writing together, publicly or privately. Connect with other communities, whether running WriteFreely, [Plume](https://joinplu.me/), or other ActivityPub-powered software. And bring members on board from your existing platforms, thanks to our OAuth 2.0 support.\n\n### Intuitive organization\n\nCategorize articles [with hashtags](https://writefreely.org/docs/latest/writer/hashtags), and create static pages from normal posts by [_pinning_ them](https://writefreely.org/docs/latest/writer/static) to your blog. Create draft posts and publish to multiple blogs from one account.\n\n### International\n\nBlog elements are localized in 20+ languages, and WriteFreely includes first-class support for non-Latin and right-to-left (RTL) script languages.\n\n### Private by default\n\nWriteFreely collects minimal data, and never publicizes more than a writer consents to. Writers can seamlessly create multiple blogs from a single account for different pen names or purposes without publicly revealing their association.\n\n<h2><a href=\"https://write.as/writefreely\"><img src=\"https://writefreely.org/img/writeas-readme.png\" height=\"32px\" alt=\"Write.as\" /></a></h2>\n\nThe quickest way to deploy WriteFreely is with [Write.as](https://write.as/writefreely), a hosted service from the team behind WriteFreely. You'll get fully-managed installation, backup, upgrades, and maintenance — and directly fund our free software work ❤️\n\n[**Learn more on Write.as**](https://write.as/writefreely).\n\n## Quick start\n\nWriteFreely deploys as a static binary on any platform and architecture that Go supports. Just use our built-in SQLite support, or add a MySQL database, and you'll be up and running!\n\nFor common platforms, start with our [pre-built binaries](https://github.com/writefreely/writefreely/releases/) and head over to our [installation guide](https://writefreely.org/start) to get started.\n\n### Packages\n\nYou can also find WriteFreely in these package repositories, thanks to our wonderful community!\n\n* [Arch User Repository](https://aur.archlinux.org/packages/writefreely/)\n\n## Documentation\n\nRead our full [documentation on WriteFreely.org](https://writefreely.org/docs) &mdash;️ and help us improve by contributing to the [writefreely/documentation](https://github.com/writefreely/documentation) repo.\n\n## Development\n\nStart hacking on WriteFreely with our [developer setup guide](https://writefreely.org/docs/latest/developer/setup). For Docker support, see our [Docker guide](https://writefreely.org/docs/latest/admin/docker).\n\n## Contributing\n\nWe gladly welcome contributions to WriteFreely, whether in the form of [code](https://github.com/writefreely/writefreely/blob/master/CONTRIBUTING.md#contributing-to-writefreely), [bug reports](https://github.com/writefreely/writefreely/issues/new?template=bug_report.md), [feature requests](https://discuss.write.as/c/feedback/feature-requests), [translations](https://poeditor.com/join/project/TIZ6HFRFdE), or [documentation](https://github.com/writefreely/documentation) improvements.\n\nBefore contributing anything, please read our [Contributing Guide](https://github.com/writefreely/writefreely/blob/master/CONTRIBUTING.md#contributing-to-writefreely). It describes the correct channels for submitting contributions and any potential requirements.\n\n## License\n\nCopyright © 2018-2022 [Musing Studio LLC](https://musing.studio) and contributing authors. Licensed under the [AGPL](https://github.com/writefreely/writefreely/blob/develop/LICENSE).\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.1162109375,
          "content": "# Security Policy\n\n## Reporting a Vulnerability\n\nTo report a vulnerability, send an email to security@writefreely.org.\n"
        },
        {
          "name": "account.go",
          "type": "blob",
          "size": 42.9482421875,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/mailgun/mailgun-go\"\n\t\"github.com/writefreely/writefreely/spam\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/csrf\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/guregu/null/zero\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/auth\"\n\t\"github.com/writeas/web-core/data\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/author\"\n\t\"github.com/writefreely/writefreely/config\"\n\t\"github.com/writefreely/writefreely/page\"\n)\n\ntype (\n\tuserSettings struct {\n\t\tUsername string `schema:\"username\" json:\"username\"`\n\t\tEmail    string `schema:\"email\" json:\"email\"`\n\t\tNewPass  string `schema:\"new-pass\" json:\"new_pass\"`\n\t\tOldPass  string `schema:\"current-pass\" json:\"current_pass\"`\n\t\tIsLogOut bool   `schema:\"logout\" json:\"logout\"`\n\t}\n\n\tUserPage struct {\n\t\tpage.StaticPage\n\n\t\tPageTitle string\n\t\tSeparator template.HTML\n\t\tIsAdmin   bool\n\t\tCanInvite bool\n\t\tCollAlias string\n\t}\n)\n\nfunc NewUserPage(app *App, r *http.Request, u *User, title string, flashes []string) *UserPage {\n\tup := &UserPage{\n\t\tStaticPage: pageForReq(app, r),\n\t\tPageTitle:  title,\n\t}\n\tup.Username = u.Username\n\tup.Flashes = flashes\n\tup.Path = r.URL.Path\n\tup.IsAdmin = u.IsAdmin()\n\tup.CanInvite = canUserInvite(app.cfg, up.IsAdmin)\n\treturn up\n}\n\nfunc canUserInvite(cfg *config.Config, isAdmin bool) bool {\n\treturn cfg.App.UserInvites != \"\" &&\n\t\t(isAdmin || cfg.App.UserInvites != \"admin\")\n}\n\nfunc (up *UserPage) SetMessaging(u *User) {\n\t// up.NeedsAuth = app.db.DoesUserNeedAuth(u.ID)\n}\n\nconst (\n\tloginAttemptExpiration = 3 * time.Second\n)\n\nvar actuallyUsernameReg = regexp.MustCompile(\"username is actually ([a-z0-9\\\\-]+)\\\\. Please try that, instead\")\n\nfunc apiSignup(app *App, w http.ResponseWriter, r *http.Request) error {\n\t_, err := signup(app, w, r)\n\treturn err\n}\n\nfunc signup(app *App, w http.ResponseWriter, r *http.Request) (*AuthUser, error) {\n\tif app.cfg.App.DisablePasswordAuth {\n\t\terr := ErrDisabledPasswordAuth\n\t\treturn nil, err\n\t}\n\n\treqJSON := IsJSON(r)\n\n\t// Get params\n\tvar ur userRegistration\n\tif reqJSON {\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr := decoder.Decode(&ur)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse signup JSON request: %v\\n\", err)\n\t\t\treturn nil, ErrBadJSON\n\t\t}\n\t} else {\n\t\t// Check if user is already logged in\n\t\tu := getUserSession(app, r)\n\t\tif u != nil {\n\t\t\treturn &AuthUser{User: u}, nil\n\t\t}\n\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse signup form request: %v\\n\", err)\n\t\t\treturn nil, ErrBadFormData\n\t\t}\n\n\t\terr = app.formDecoder.Decode(&ur, r.PostForm)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't decode signup form request: %v\\n\", err)\n\t\t\treturn nil, ErrBadFormData\n\t\t}\n\t}\n\n\treturn signupWithRegistration(app, ur, w, r)\n}\n\nfunc signupWithRegistration(app *App, signup userRegistration, w http.ResponseWriter, r *http.Request) (*AuthUser, error) {\n\treqJSON := IsJSON(r)\n\n\t// Validate required params (alias)\n\tif signup.Alias == \"\" {\n\t\treturn nil, impart.HTTPError{http.StatusBadRequest, \"A username is required.\"}\n\t}\n\tif signup.Pass == \"\" {\n\t\treturn nil, impart.HTTPError{http.StatusBadRequest, \"A password is required.\"}\n\t}\n\tvar desiredUsername string\n\tif signup.Normalize {\n\t\t// With this option we simply conform the username to what we expect\n\t\t// without complaining. Since they might've done something funny, like\n\t\t// enter: write.as/Way Out There, we'll use their raw input for the new\n\t\t// collection name and sanitize for the slug / username.\n\t\tdesiredUsername = signup.Alias\n\t\tsignup.Alias = getSlug(signup.Alias, \"\")\n\t}\n\tif !author.IsValidUsername(app.cfg, signup.Alias) {\n\t\t// Ensure the username is syntactically correct.\n\t\treturn nil, impart.HTTPError{http.StatusPreconditionFailed, \"Username is reserved or isn't valid. It must be at least 3 characters long, and can only include letters, numbers, and hyphens.\"}\n\t}\n\n\t// Handle empty optional params\n\thashedPass, err := auth.HashPass([]byte(signup.Pass))\n\tif err != nil {\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Could not create password hash.\"}\n\t}\n\n\t// Create struct to insert\n\tu := &User{\n\t\tUsername:   signup.Alias,\n\t\tHashedPass: hashedPass,\n\t\tHasPass:    true,\n\t\tEmail:      prepareUserEmail(signup.Email, app.keys.EmailKey),\n\t\tCreated:    time.Now().Truncate(time.Second).UTC(),\n\t}\n\n\t// Create actual user\n\tif err := app.db.CreateUser(app.cfg, u, desiredUsername, signup.Description); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Log invite if needed\n\tif signup.InviteCode != \"\" {\n\t\terr = app.db.CreateInvitedUser(signup.InviteCode, u.ID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Add back unencrypted data for response\n\tif signup.Email != \"\" {\n\t\tu.Email.String = signup.Email\n\t}\n\n\tresUser := &AuthUser{\n\t\tUser: u,\n\t}\n\ttitle := signup.Alias\n\tif signup.Normalize {\n\t\ttitle = desiredUsername\n\t}\n\tresUser.Collections = &[]Collection{\n\t\t{\n\t\t\tAlias:       signup.Alias,\n\t\t\tTitle:       title,\n\t\t\tDescription: signup.Description,\n\t\t},\n\t}\n\n\tvar coll *Collection\n\tif signup.Monetization != \"\" {\n\t\tif coll == nil {\n\t\t\tcoll, err = app.db.GetCollection(signup.Alias)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Unable to get new collection '%s' for monetization on signup: %v\", signup.Alias, err)\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\terr = app.db.SetCollectionAttribute(coll.ID, \"monetization_pointer\", signup.Monetization)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to add monetization on signup: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tcoll.Monetization = signup.Monetization\n\t}\n\n\tvar token string\n\tif reqJSON && !signup.Web {\n\t\ttoken, err = app.db.GetAccessToken(u.ID)\n\t\tif err != nil {\n\t\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Could not create access token. Try re-authenticating.\"}\n\t\t}\n\t\tresUser.AccessToken = token\n\t} else {\n\t\tsession, err := app.sessionStore.Get(r, cookieName)\n\t\tif err != nil {\n\t\t\t// The cookie should still save, even if there's an error.\n\t\t\t// Source: https://github.com/gorilla/sessions/issues/16#issuecomment-143642144\n\t\t\tlog.Error(\"Session: %v; ignoring\", err)\n\t\t}\n\t\tsession.Values[cookieUserVal] = resUser.User.Cookie()\n\t\terr = session.Save(r, w)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't save session: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif reqJSON {\n\t\treturn resUser, impart.WriteSuccess(w, resUser, http.StatusCreated)\n\t}\n\n\treturn resUser, nil\n}\n\nfunc viewLogout(app *App, w http.ResponseWriter, r *http.Request) error {\n\tsession, err := app.sessionStore.Get(r, cookieName)\n\tif err != nil {\n\t\treturn ErrInternalCookieSession\n\t}\n\n\t// Ensure user has an email or password set before they go, so they don't\n\t// lose access to their account.\n\tval := session.Values[cookieUserVal]\n\tvar u = &User{}\n\tvar ok bool\n\tif u, ok = val.(*User); !ok {\n\t\tlog.Error(\"Error casting user object on logout. Vals: %+v Resetting cookie.\", session.Values)\n\n\t\terr = session.Save(r, w)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't save session on logout: %v\", err)\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Unable to save cookie session.\"}\n\t\t}\n\n\t\treturn impart.HTTPError{http.StatusFound, \"/\"}\n\t}\n\n\tu, err = app.db.GetUserByID(u.ID)\n\tif err != nil && err != ErrUserNotFound {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Unable to fetch user information.\"}\n\t}\n\n\tsession.Options.MaxAge = -1\n\n\terr = session.Save(r, w)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't save session on logout: %v\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Unable to save cookie session.\"}\n\t}\n\n\treturn impart.HTTPError{http.StatusFound, \"/\"}\n}\n\nfunc handleAPILogout(app *App, w http.ResponseWriter, r *http.Request) error {\n\taccessToken := r.Header.Get(\"Authorization\")\n\tif accessToken == \"\" {\n\t\treturn ErrNoAccessToken\n\t}\n\tt := auth.GetToken(accessToken)\n\tif len(t) == 0 {\n\t\treturn ErrNoAccessToken\n\t}\n\terr := app.db.DeleteToken(t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn impart.HTTPError{Status: http.StatusNoContent}\n}\n\nfunc viewLogin(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvar earlyError string\n\toneTimeToken := r.FormValue(\"with\")\n\tif oneTimeToken != \"\" {\n\t\tlog.Info(\"Calling login with one-time token.\")\n\t\terr := login(app, w, r)\n\t\tif err != nil {\n\t\t\tlog.Info(\"Received error: %v\", err)\n\t\t\tearlyError = fmt.Sprintf(\"%s\", err)\n\t\t}\n\t}\n\n\tsession, err := app.sessionStore.Get(r, cookieName)\n\tif err != nil {\n\t\t// Ignore this\n\t\tlog.Error(\"Unable to get session; ignoring: %v\", err)\n\t}\n\n\tp := &struct {\n\t\tpage.StaticPage\n\t\t*OAuthButtons\n\t\tTo            string\n\t\tMessage       template.HTML\n\t\tFlashes       []template.HTML\n\t\tEmailEnabled  bool\n\t\tLoginUsername string\n\t}{\n\t\tStaticPage:    pageForReq(app, r),\n\t\tOAuthButtons:  NewOAuthButtons(app.Config()),\n\t\tTo:            r.FormValue(\"to\"),\n\t\tMessage:       template.HTML(\"\"),\n\t\tFlashes:       []template.HTML{},\n\t\tEmailEnabled:  app.cfg.Email.Enabled(),\n\t\tLoginUsername: getTempInfo(app, \"login-user\", r, w),\n\t}\n\n\tif earlyError != \"\" {\n\t\tp.Flashes = append(p.Flashes, template.HTML(earlyError))\n\t}\n\n\t// Display any error messages\n\tflashes, _ := getSessionFlashes(app, w, r, session)\n\tfor _, flash := range flashes {\n\t\tp.Flashes = append(p.Flashes, template.HTML(flash))\n\t}\n\terr = pages[\"login.tmpl\"].ExecuteTemplate(w, \"base\", p)\n\tif err != nil {\n\t\tlog.Error(\"Unable to render login: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc webLogin(app *App, w http.ResponseWriter, r *http.Request) error {\n\terr := login(app, w, r)\n\tif err != nil {\n\t\tusername := r.FormValue(\"alias\")\n\t\t// Login request was unsuccessful; save the error in the session and redirect them\n\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\tsession, _ := app.sessionStore.Get(r, cookieName)\n\t\t\tif session != nil {\n\t\t\t\tsession.AddFlash(err.Message)\n\t\t\t\tsession.Save(r, w)\n\t\t\t}\n\n\t\t\tif m := actuallyUsernameReg.FindStringSubmatch(err.Message); len(m) > 0 {\n\t\t\t\t// Retain fixed username recommendation for the login form\n\t\t\t\tusername = m[1]\n\t\t\t}\n\t\t}\n\n\t\t// Pass along certain information\n\t\tsaveTempInfo(app, \"login-user\", username, r, w)\n\n\t\t// Retain post-login URL if one was given\n\t\tredirectTo := \"/login\"\n\t\tpostLoginRedirect := r.FormValue(\"to\")\n\t\tif postLoginRedirect != \"\" {\n\t\t\tredirectTo += \"?to=\" + postLoginRedirect\n\t\t}\n\n\t\tlog.Error(\"Unable to login: %v\", err)\n\t\treturn impart.HTTPError{http.StatusTemporaryRedirect, redirectTo}\n\t}\n\n\treturn nil\n}\n\nvar loginAttemptUsers = sync.Map{}\n\nfunc login(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\toneTimeToken := r.FormValue(\"with\")\n\tverbose := r.FormValue(\"all\") == \"true\" || r.FormValue(\"verbose\") == \"1\" || r.FormValue(\"verbose\") == \"true\" || (reqJSON && oneTimeToken != \"\")\n\n\tredirectTo := r.FormValue(\"to\")\n\tif redirectTo == \"\" {\n\t\tif app.cfg.App.SingleUser {\n\t\t\tredirectTo = \"/me/new\"\n\t\t} else {\n\t\t\tredirectTo = \"/\"\n\t\t}\n\t}\n\n\tvar u *User\n\tvar err error\n\tvar signin userCredentials\n\n\tif app.cfg.App.DisablePasswordAuth {\n\t\terr := ErrDisabledPasswordAuth\n\t\treturn err\n\t}\n\n\t// Log in with one-time token if one is given\n\tif oneTimeToken != \"\" {\n\t\tlog.Info(\"Login: Logging user in via token.\")\n\t\tuserID := app.db.GetUserID(oneTimeToken)\n\t\tif userID == -1 {\n\t\t\tlog.Error(\"Login: Got user -1 from token\")\n\t\t\terr := ErrBadAccessToken\n\t\t\terr.Message = \"Expired or invalid login code.\"\n\t\t\treturn err\n\t\t}\n\t\tlog.Info(\"Login: Found user %d.\", userID)\n\n\t\tu, err = app.db.GetUserByID(userID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to fetch user on one-time token login: %v\", err)\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, \"There was an error retrieving the user you want.\"}\n\t\t}\n\t\tlog.Info(\"Login: Got user via token\")\n\t} else {\n\t\t// Get params\n\t\tif reqJSON {\n\t\t\tdecoder := json.NewDecoder(r.Body)\n\t\t\terr := decoder.Decode(&signin)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't parse signin JSON request: %v\\n\", err)\n\t\t\t\treturn ErrBadJSON\n\t\t\t}\n\t\t} else {\n\t\t\terr := r.ParseForm()\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't parse signin form request: %v\\n\", err)\n\t\t\t\treturn ErrBadFormData\n\t\t\t}\n\n\t\t\terr = app.formDecoder.Decode(&signin, r.PostForm)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't decode signin form request: %v\\n\", err)\n\t\t\t\treturn ErrBadFormData\n\t\t\t}\n\t\t}\n\n\t\tlog.Info(\"Login: Attempting login for '%s'\", signin.Alias)\n\n\t\t// Validate required params (all)\n\t\tif signin.Alias == \"\" {\n\t\t\tmsg := \"Parameter `alias` required.\"\n\t\t\tif signin.Web {\n\t\t\t\tmsg = \"A username is required.\"\n\t\t\t}\n\t\t\treturn impart.HTTPError{http.StatusBadRequest, msg}\n\t\t}\n\t\tif !signin.EmailLogin && signin.Pass == \"\" {\n\t\t\tmsg := \"Parameter `pass` required.\"\n\t\t\tif signin.Web {\n\t\t\t\tmsg = \"A password is required.\"\n\t\t\t}\n\t\t\treturn impart.HTTPError{http.StatusBadRequest, msg}\n\t\t}\n\n\t\t// Prevent excessive login attempts on the same account\n\t\t// Skip this check in dev environment\n\t\tif !app.cfg.Server.Dev {\n\t\t\tnow := time.Now()\n\t\t\tattemptExp, att := loginAttemptUsers.LoadOrStore(signin.Alias, now.Add(loginAttemptExpiration))\n\t\t\tif att {\n\t\t\t\tif attemptExpTime, ok := attemptExp.(time.Time); ok {\n\t\t\t\t\tif attemptExpTime.After(now) {\n\t\t\t\t\t\t// This user attempted previously, and the period hasn't expired yet\n\t\t\t\t\t\treturn impart.HTTPError{http.StatusTooManyRequests, \"You're doing that too much.\"}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This user attempted previously, but the time expired; free up space\n\t\t\t\t\t\tloginAttemptUsers.Delete(signin.Alias)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlog.Error(\"Unable to cast expiration to time\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Retrieve password\n\t\tu, err = app.db.GetUserForAuth(signin.Alias)\n\t\tif err != nil {\n\t\t\tlog.Info(\"Unable to getUserForAuth on %s: %v\", signin.Alias, err)\n\t\t\tif strings.IndexAny(signin.Alias, \"@\") > 0 {\n\t\t\t\tlog.Info(\"Suggesting: %s\", ErrUserNotFoundEmail.Message)\n\t\t\t\treturn ErrUserNotFoundEmail\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\t// Authenticate\n\t\tif u.Email.String == \"\" {\n\t\t\t// User has no email set, so check if they haven't added a password, either,\n\t\t\t// so we can return a more helpful error message.\n\t\t\tif hasPass, _ := app.db.IsUserPassSet(u.ID); !hasPass {\n\t\t\t\tlog.Info(\"Tried logging into %s, but no password or email.\", signin.Alias)\n\t\t\t\treturn impart.HTTPError{http.StatusPreconditionFailed, \"This user never added a password or email address. Please contact us for help.\"}\n\t\t\t}\n\t\t}\n\t\tif len(u.HashedPass) == 0 {\n\t\t\treturn impart.HTTPError{http.StatusUnauthorized, \"This user never set a password. Perhaps try logging in via OAuth?\"}\n\t\t}\n\t\tif !auth.Authenticated(u.HashedPass, []byte(signin.Pass)) {\n\t\t\treturn impart.HTTPError{http.StatusUnauthorized, \"Incorrect password.\"}\n\t\t}\n\t}\n\n\tif reqJSON && !signin.Web {\n\t\tvar token string\n\t\tif r.Header.Get(\"User-Agent\") == \"\" {\n\t\t\t// Get last created token when User-Agent is empty\n\t\t\ttoken = app.db.FetchLastAccessToken(u.ID)\n\t\t\tif token == \"\" {\n\t\t\t\ttoken, err = app.db.GetAccessToken(u.ID)\n\t\t\t}\n\t\t} else {\n\t\t\ttoken, err = app.db.GetAccessToken(u.ID)\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Error(\"Login: Unable to create access token: %v\", err)\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Could not create access token. Try re-authenticating.\"}\n\t\t}\n\t\tresUser := getVerboseAuthUser(app, token, u, verbose)\n\t\treturn impart.WriteSuccess(w, resUser, http.StatusOK)\n\t}\n\n\tsession, err := app.sessionStore.Get(r, cookieName)\n\tif err != nil {\n\t\t// The cookie should still save, even if there's an error.\n\t\tlog.Error(\"Login: Session: %v; ignoring\", err)\n\t}\n\n\t// Remove unwanted data\n\tsession.Values[cookieUserVal] = u.Cookie()\n\terr = session.Save(r, w)\n\tif err != nil {\n\t\tlog.Error(\"Login: Couldn't save session: %v\", err)\n\t\t// TODO: return error\n\t}\n\n\t// Send success\n\tif reqJSON {\n\t\treturn impart.WriteSuccess(w, &AuthUser{User: u}, http.StatusOK)\n\t}\n\tlog.Info(\"Login: Redirecting to %s\", redirectTo)\n\tw.Header().Set(\"Location\", redirectTo)\n\tw.WriteHeader(http.StatusFound)\n\treturn nil\n}\n\nfunc getVerboseAuthUser(app *App, token string, u *User, verbose bool) *AuthUser {\n\tresUser := &AuthUser{\n\t\tAccessToken: token,\n\t\tUser:        u,\n\t}\n\n\t// Fetch verbose user data if requested\n\tif verbose {\n\t\tposts, err := app.db.GetUserPosts(u)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Login: Unable to get user posts: %v\", err)\n\t\t}\n\t\tcolls, err := app.db.GetCollections(u, app.cfg.App.Host)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Login: Unable to get user collections: %v\", err)\n\t\t}\n\t\tpassIsSet, err := app.db.IsUserPassSet(u.ID)\n\t\tif err != nil {\n\t\t\t// TODO: correct error message\n\t\t\tlog.Error(\"Login: Unable to get user collections: %v\", err)\n\t\t}\n\n\t\tresUser.Posts = posts\n\t\tresUser.Collections = colls\n\t\tresUser.User.HasPass = passIsSet\n\t}\n\treturn resUser\n}\n\nfunc viewExportOptions(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\t// Fetch extra user data\n\tp := NewUserPage(app, r, u, \"Export\", nil)\n\n\tshowUserPage(w, \"export\", p)\n\treturn nil\n}\n\nfunc viewExportPosts(app *App, w http.ResponseWriter, r *http.Request) ([]byte, string, error) {\n\tvar filename string\n\tvar u = &User{}\n\treqJSON := IsJSON(r)\n\tif reqJSON {\n\t\t// Use given Authorization header\n\t\taccessToken := r.Header.Get(\"Authorization\")\n\t\tif accessToken == \"\" {\n\t\t\treturn nil, filename, ErrNoAccessToken\n\t\t}\n\n\t\tuserID := app.db.GetUserID(accessToken)\n\t\tif userID == -1 {\n\t\t\treturn nil, filename, ErrBadAccessToken\n\t\t}\n\n\t\tvar err error\n\t\tu, err = app.db.GetUserByID(userID)\n\t\tif err != nil {\n\t\t\treturn nil, filename, impart.HTTPError{http.StatusInternalServerError, \"Unable to retrieve requested user.\"}\n\t\t}\n\t} else {\n\t\t// Use user cookie\n\t\tsession, err := app.sessionStore.Get(r, cookieName)\n\t\tif err != nil {\n\t\t\t// The cookie should still save, even if there's an error.\n\t\t\tlog.Error(\"Session: %v; ignoring\", err)\n\t\t}\n\n\t\tval := session.Values[cookieUserVal]\n\t\tvar ok bool\n\t\tif u, ok = val.(*User); !ok {\n\t\t\treturn nil, filename, ErrNotLoggedIn\n\t\t}\n\t}\n\n\tfilename = u.Username + \"-posts-\" + time.Now().Truncate(time.Second).UTC().Format(\"200601021504\")\n\n\t// Fetch data we're exporting\n\tvar err error\n\tvar data []byte\n\tposts, err := app.db.GetUserPosts(u)\n\tif err != nil {\n\t\treturn data, filename, err\n\t}\n\n\t// Export as CSV\n\tif strings.HasSuffix(r.URL.Path, \".csv\") {\n\t\tdata = exportPostsCSV(app.cfg.App.Host, u, posts)\n\t\treturn data, filename, err\n\t}\n\tif strings.HasSuffix(r.URL.Path, \".zip\") {\n\t\tdata = exportPostsZip(u, posts)\n\t\treturn data, filename, err\n\t}\n\n\tif r.FormValue(\"pretty\") == \"1\" {\n\t\tdata, err = json.MarshalIndent(posts, \"\", \"\\t\")\n\t} else {\n\t\tdata, err = json.Marshal(posts)\n\t}\n\treturn data, filename, err\n}\n\nfunc viewExportFull(app *App, w http.ResponseWriter, r *http.Request) ([]byte, string, error) {\n\tvar err error\n\tfilename := \"\"\n\tu := getUserSession(app, r)\n\tif u == nil {\n\t\treturn nil, filename, ErrNotLoggedIn\n\t}\n\tfilename = u.Username + \"-\" + time.Now().Truncate(time.Second).UTC().Format(\"200601021504\")\n\n\texportUser := compileFullExport(app, u)\n\n\tvar data []byte\n\tif r.FormValue(\"pretty\") == \"1\" {\n\t\tdata, err = json.MarshalIndent(exportUser, \"\", \"\\t\")\n\t} else {\n\t\tdata, err = json.Marshal(exportUser)\n\t}\n\treturn data, filename, err\n}\n\nfunc viewMeAPI(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\tuObj := struct {\n\t\tID       int64  `json:\"id,omitempty\"`\n\t\tUsername string `json:\"username,omitempty\"`\n\t}{}\n\tvar err error\n\n\tif reqJSON {\n\t\t_, uObj.Username, err = app.db.GetUserDataFromToken(r.Header.Get(\"Authorization\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tu := getUserSession(app, r)\n\t\tif u == nil {\n\t\t\treturn impart.WriteSuccess(w, uObj, http.StatusOK)\n\t\t}\n\t\tuObj.Username = u.Username\n\t}\n\n\treturn impart.WriteSuccess(w, uObj, http.StatusOK)\n}\n\nfunc viewMyPostsAPI(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\tif !reqJSON {\n\t\treturn ErrBadRequestedType\n\t}\n\n\tisAnonPosts := r.FormValue(\"anonymous\") == \"1\"\n\tif isAnonPosts {\n\t\tpageStr := r.FormValue(\"page\")\n\t\tpg, err := strconv.Atoi(pageStr)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Error parsing page parameter '%s': %s\", pageStr, err)\n\t\t\tpg = 1\n\t\t}\n\n\t\tp, err := app.db.GetAnonymousPosts(u, pg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn impart.WriteSuccess(w, p, http.StatusOK)\n\t}\n\n\tvar err error\n\tp := GetPostsCache(u.ID)\n\tif p == nil {\n\t\tuserPostsCache.Lock()\n\t\tif userPostsCache.users[u.ID].ready == nil {\n\t\t\tuserPostsCache.users[u.ID] = postsCacheItem{ready: make(chan struct{})}\n\t\t\tuserPostsCache.Unlock()\n\n\t\t\tp, err = app.db.GetUserPosts(u)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tCachePosts(u.ID, p)\n\t\t} else {\n\t\t\tuserPostsCache.Unlock()\n\n\t\t\t<-userPostsCache.users[u.ID].ready\n\t\t\tp = GetPostsCache(u.ID)\n\t\t}\n\t}\n\n\treturn impart.WriteSuccess(w, p, http.StatusOK)\n}\n\nfunc viewMyCollectionsAPI(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\tif !reqJSON {\n\t\treturn ErrBadRequestedType\n\t}\n\n\tp, err := app.db.GetCollections(u, app.cfg.App.Host)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn impart.WriteSuccess(w, p, http.StatusOK)\n}\n\nfunc viewArticles(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tp, err := app.db.GetAnonymousPosts(u, 1)\n\tif err != nil {\n\t\tlog.Error(\"unable to fetch anon posts: %v\", err)\n\t}\n\t// nil-out AnonymousPosts slice for easy detection in the template\n\tif p != nil && len(*p) == 0 {\n\t\tp = nil\n\t}\n\n\tf, err := getSessionFlashes(app, w, r, nil)\n\tif err != nil {\n\t\tlog.Error(\"unable to fetch flashes: %v\", err)\n\t}\n\n\tc, err := app.db.GetPublishableCollections(u, app.cfg.App.Host)\n\tif err != nil {\n\t\tlog.Error(\"unable to fetch collections: %v\", err)\n\t}\n\n\tsilenced, err := app.db.IsUserSilenced(u.ID)\n\tif err != nil {\n\t\tif err == ErrUserNotFound {\n\t\t\treturn err\n\t\t}\n\t\tlog.Error(\"view articles: %v\", err)\n\t}\n\td := struct {\n\t\t*UserPage\n\t\tAnonymousPosts *[]PublicPost\n\t\tCollections    *[]Collection\n\t\tSilenced       bool\n\t}{\n\t\tUserPage:       NewUserPage(app, r, u, u.Username+\"'s Posts\", f),\n\t\tAnonymousPosts: p,\n\t\tCollections:    c,\n\t\tSilenced:       silenced,\n\t}\n\td.UserPage.SetMessaging(u)\n\tw.Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n\tw.Header().Set(\"Expires\", \"Thu, 04 Oct 1990 20:00:00 GMT\")\n\tshowUserPage(w, \"articles\", d)\n\n\treturn nil\n}\n\nfunc viewCollections(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tc, err := app.db.GetCollections(u, app.cfg.App.Host)\n\tif err != nil {\n\t\tlog.Error(\"unable to fetch collections: %v\", err)\n\t\treturn fmt.Errorf(\"No collections\")\n\t}\n\n\tf, _ := getSessionFlashes(app, w, r, nil)\n\n\tuc, _ := app.db.GetUserCollectionCount(u.ID)\n\t// TODO: handle any errors\n\n\tsilenced, err := app.db.IsUserSilenced(u.ID)\n\tif err != nil {\n\t\tif err == ErrUserNotFound {\n\t\t\treturn err\n\t\t}\n\t\tlog.Error(\"view collections: %v\", err)\n\t\treturn fmt.Errorf(\"view collections: %v\", err)\n\t}\n\td := struct {\n\t\t*UserPage\n\t\tCollections *[]Collection\n\n\t\tUsedCollections, TotalCollections int\n\n\t\tNewBlogsDisabled bool\n\t\tSilenced         bool\n\t}{\n\t\tUserPage:         NewUserPage(app, r, u, u.Username+\"'s Blogs\", f),\n\t\tCollections:      c,\n\t\tUsedCollections:  int(uc),\n\t\tNewBlogsDisabled: !app.cfg.App.CanCreateBlogs(uc),\n\t\tSilenced:         silenced,\n\t}\n\td.UserPage.SetMessaging(u)\n\tshowUserPage(w, \"collections\", d)\n\n\treturn nil\n}\n\nfunc viewEditCollection(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tc, err := app.db.GetCollection(vars[\"collection\"])\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.OwnerID != u.ID {\n\t\treturn ErrCollectionNotFound\n\t}\n\n\tsilenced, err := app.db.IsUserSilenced(u.ID)\n\tif err != nil {\n\t\tif err == ErrUserNotFound {\n\t\t\treturn err\n\t\t}\n\t\tlog.Error(\"view edit collection %v\", err)\n\t\treturn fmt.Errorf(\"view edit collection: %v\", err)\n\t}\n\tflashes, _ := getSessionFlashes(app, w, r, nil)\n\tobj := struct {\n\t\t*UserPage\n\t\t*Collection\n\t\tSilenced bool\n\n\t\tconfig.EmailCfg\n\t\tLetterReplyTo string\n\t}{\n\t\tUserPage:   NewUserPage(app, r, u, \"Edit \"+c.DisplayTitle(), flashes),\n\t\tCollection: c,\n\t\tSilenced:   silenced,\n\t\tEmailCfg:   app.cfg.Email,\n\t}\n\tobj.UserPage.CollAlias = c.Alias\n\tif obj.EmailCfg.Enabled() {\n\t\tobj.LetterReplyTo = app.db.GetCollectionAttribute(c.ID, collAttrLetterReplyTo)\n\t}\n\n\tshowUserPage(w, \"collection\", obj)\n\treturn nil\n}\n\nfunc updateSettings(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\n\tvar s userSettings\n\tvar u *User\n\tvar sess *sessions.Session\n\tvar err error\n\tif reqJSON {\n\t\taccessToken := r.Header.Get(\"Authorization\")\n\t\tif accessToken == \"\" {\n\t\t\treturn ErrNoAccessToken\n\t\t}\n\n\t\tu, err = app.db.GetAPIUser(accessToken)\n\t\tif err != nil {\n\t\t\treturn ErrBadAccessToken\n\t\t}\n\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr := decoder.Decode(&s)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse settings JSON request: %v\\n\", err)\n\t\t\treturn ErrBadJSON\n\t\t}\n\n\t\t// Prevent all username updates\n\t\t// TODO: support changing username via JSON API request\n\t\ts.Username = \"\"\n\t} else {\n\t\tu, sess = getUserAndSession(app, r)\n\t\tif u == nil {\n\t\t\treturn ErrNotLoggedIn\n\t\t}\n\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse settings form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\n\t\terr = app.formDecoder.Decode(&s, r.PostForm)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't decode settings form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\t}\n\n\t// Do update\n\tpostUpdateReturn := r.FormValue(\"return\")\n\tredirectTo := \"/me/settings\"\n\tif s.IsLogOut {\n\t\tredirectTo += \"?logout=1\"\n\t} else if postUpdateReturn != \"\" {\n\t\tredirectTo = postUpdateReturn\n\t}\n\n\t// Only do updates on values we need\n\tif s.Username != \"\" && s.Username == u.Username {\n\t\t// Username hasn't actually changed; blank it out\n\t\ts.Username = \"\"\n\t}\n\terr = app.db.ChangeSettings(app, u, &s)\n\tif err != nil {\n\t\tif reqJSON {\n\t\t\treturn err\n\t\t}\n\n\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\taddSessionFlash(app, w, r, err.Message, nil)\n\t\t}\n\t} else {\n\t\t// Successful update.\n\t\tif reqJSON {\n\t\t\treturn impart.WriteSuccess(w, u, http.StatusOK)\n\t\t}\n\n\t\tif s.IsLogOut {\n\t\t\tredirectTo = \"/me/logout\"\n\t\t} else {\n\t\t\tsess.Values[cookieUserVal] = u.Cookie()\n\t\t\taddSessionFlash(app, w, r, \"Account updated.\", nil)\n\t\t}\n\t}\n\n\tw.Header().Set(\"Location\", redirectTo)\n\tw.WriteHeader(http.StatusFound)\n\treturn nil\n}\n\nfunc updatePassphrase(app *App, w http.ResponseWriter, r *http.Request) error {\n\taccessToken := r.Header.Get(\"Authorization\")\n\tif accessToken == \"\" {\n\t\treturn ErrNoAccessToken\n\t}\n\n\tcurPass := r.FormValue(\"current\")\n\tnewPass := r.FormValue(\"new\")\n\t// Ensure a new password is given (always required)\n\tif newPass == \"\" {\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"Provide a new password.\"}\n\t}\n\n\tuserID, sudo := app.db.GetUserIDPrivilege(accessToken)\n\tif userID == -1 {\n\t\treturn ErrBadAccessToken\n\t}\n\n\t// Ensure a current password is given if the access token doesn't have sudo\n\t// privileges.\n\tif !sudo && curPass == \"\" {\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"Provide current password.\"}\n\t}\n\n\t// Hash the new password\n\thashedPass, err := auth.HashPass([]byte(newPass))\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Could not create password hash.\"}\n\t}\n\n\t// Do update\n\terr = app.db.ChangePassphrase(userID, sudo, curPass, hashedPass)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn impart.WriteSuccess(w, struct{}{}, http.StatusOK)\n}\n\nfunc viewStats(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tvar c *Collection\n\tvar err error\n\tvars := mux.Vars(r)\n\talias := vars[\"collection\"]\n\tif alias != \"\" {\n\t\tc, err = app.db.GetCollection(alias)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif c.OwnerID != u.ID {\n\t\t\treturn ErrCollectionNotFound\n\t\t}\n\t\tc.hostName = app.cfg.App.Host\n\t}\n\n\ttopPosts, err := app.db.GetTopPosts(u, alias, c.hostName)\n\tif err != nil {\n\t\tlog.Error(\"Unable to get top posts: %v\", err)\n\t\treturn err\n\t}\n\n\tflashes, _ := getSessionFlashes(app, w, r, nil)\n\ttitleStats := \"\"\n\tif c != nil {\n\t\ttitleStats = c.DisplayTitle() + \" \"\n\t}\n\n\tsilenced, err := app.db.IsUserSilenced(u.ID)\n\tif err != nil {\n\t\tif err == ErrUserNotFound {\n\t\t\treturn err\n\t\t}\n\t\tlog.Error(\"view stats: %v\", err)\n\t\treturn err\n\t}\n\tobj := struct {\n\t\t*UserPage\n\t\tVisitsBlog       string\n\t\tCollection       *Collection\n\t\tTopPosts         *[]PublicPost\n\t\tAPFollowers      int\n\t\tEmailEnabled     bool\n\t\tEmailSubscribers int\n\t\tSilenced         bool\n\t}{\n\t\tUserPage:     NewUserPage(app, r, u, titleStats+\"Stats\", flashes),\n\t\tVisitsBlog:   alias,\n\t\tCollection:   c,\n\t\tTopPosts:     topPosts,\n\t\tEmailEnabled: app.cfg.Email.Enabled(),\n\t\tSilenced:     silenced,\n\t}\n\tobj.UserPage.CollAlias = c.Alias\n\tif app.cfg.App.Federation {\n\t\tfolls, err := app.db.GetAPFollowers(c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tobj.APFollowers = len(*folls)\n\t}\n\tif obj.EmailEnabled {\n\t\tsubs, err := app.db.GetEmailSubscribers(c.ID, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tobj.EmailSubscribers = len(subs)\n\t}\n\n\tshowUserPage(w, \"stats\", obj)\n\treturn nil\n}\n\nfunc handleViewSubscribers(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tc, err := app.db.GetCollection(vars[\"collection\"])\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfilter := r.FormValue(\"filter\")\n\n\tflashes, _ := getSessionFlashes(app, w, r, nil)\n\tobj := struct {\n\t\t*UserPage\n\t\tCollection CollectionNav\n\t\tEmailSubs  []*EmailSubscriber\n\t\tFollowers  *[]RemoteUser\n\t\tSilenced   bool\n\n\t\tFilter            string\n\t\tFederationEnabled bool\n\t\tCanEmailSub       bool\n\t\tCanAddSubs        bool\n\t\tEmailSubsEnabled  bool\n\t}{\n\t\tUserPage: NewUserPage(app, r, u, c.DisplayTitle()+\" Subscribers\", flashes),\n\t\tCollection: CollectionNav{\n\t\t\tCollection: c,\n\t\t\tPath:       r.URL.Path,\n\t\t\tSingleUser: app.cfg.App.SingleUser,\n\t\t},\n\t\tSilenced:          u.IsSilenced(),\n\t\tFilter:            filter,\n\t\tFederationEnabled: app.cfg.App.Federation,\n\t\tCanEmailSub:       app.cfg.Email.Enabled(),\n\t\tEmailSubsEnabled:  c.EmailSubsEnabled(),\n\t}\n\n\tobj.Followers, err = app.db.GetAPFollowers(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tobj.EmailSubs, err = app.db.GetEmailSubscribers(c.ID, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif obj.Filter == \"\" {\n\t\t// Set permission to add email subscribers\n\t\t//obj.CanAddSubs = app.db.GetUserAttribute(c.OwnerID, userAttrCanAddEmailSubs) == \"1\"\n\t}\n\n\tshowUserPage(w, \"subscribers\", obj)\n\treturn nil\n}\n\nfunc viewSettings(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tfullUser, err := app.db.GetUserByID(u.ID)\n\tif err != nil {\n\t\tif err == ErrUserNotFound {\n\t\t\treturn err\n\t\t}\n\t\tlog.Error(\"Unable to get user for settings: %s\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Unable to retrieve user data. The humans have been alerted.\"}\n\t}\n\n\tpassIsSet, err := app.db.IsUserPassSet(u.ID)\n\tif err != nil {\n\t\tlog.Error(\"Unable to get isUserPassSet for settings: %s\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Unable to retrieve user data. The humans have been alerted.\"}\n\t}\n\n\tflashes, _ := getSessionFlashes(app, w, r, nil)\n\n\tenableOauthSlack := app.Config().SlackOauth.ClientID != \"\"\n\tenableOauthWriteAs := app.Config().WriteAsOauth.ClientID != \"\"\n\tenableOauthGitLab := app.Config().GitlabOauth.ClientID != \"\"\n\tenableOauthGeneric := app.Config().GenericOauth.ClientID != \"\"\n\tenableOauthGitea := app.Config().GiteaOauth.ClientID != \"\"\n\n\toauthAccounts, err := app.db.GetOauthAccounts(r.Context(), u.ID)\n\tif err != nil {\n\t\tlog.Error(\"Unable to get oauth accounts for settings: %s\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Unable to retrieve user data. The humans have been alerted.\"}\n\t}\n\tfor idx, oauthAccount := range oauthAccounts {\n\t\tswitch oauthAccount.Provider {\n\t\tcase \"slack\":\n\t\t\tenableOauthSlack = false\n\t\tcase \"write.as\":\n\t\t\tenableOauthWriteAs = false\n\t\tcase \"gitlab\":\n\t\t\tenableOauthGitLab = false\n\t\tcase \"generic\":\n\t\t\toauthAccounts[idx].DisplayName = app.Config().GenericOauth.DisplayName\n\t\t\toauthAccounts[idx].AllowDisconnect = app.Config().GenericOauth.AllowDisconnect\n\t\t\tenableOauthGeneric = false\n\t\tcase \"gitea\":\n\t\t\tenableOauthGitea = false\n\t\t}\n\t}\n\n\tdisplayOauthSection := enableOauthSlack || enableOauthWriteAs || enableOauthGitLab || enableOauthGeneric || enableOauthGitea || len(oauthAccounts) > 0\n\n\tobj := struct {\n\t\t*UserPage\n\t\tEmail                   string\n\t\tHasPass                 bool\n\t\tIsLogOut                bool\n\t\tSilenced                bool\n\t\tCSRFField               template.HTML\n\t\tOauthSection            bool\n\t\tOauthAccounts           []oauthAccountInfo\n\t\tOauthSlack              bool\n\t\tOauthWriteAs            bool\n\t\tOauthGitLab             bool\n\t\tGitLabDisplayName       string\n\t\tOauthGeneric            bool\n\t\tOauthGenericDisplayName string\n\t\tOauthGitea              bool\n\t\tGiteaDisplayName        string\n\t}{\n\t\tUserPage:                NewUserPage(app, r, u, \"Account Settings\", flashes),\n\t\tEmail:                   fullUser.EmailClear(app.keys),\n\t\tHasPass:                 passIsSet,\n\t\tIsLogOut:                r.FormValue(\"logout\") == \"1\",\n\t\tSilenced:                fullUser.IsSilenced(),\n\t\tCSRFField:               csrf.TemplateField(r),\n\t\tOauthSection:            displayOauthSection,\n\t\tOauthAccounts:           oauthAccounts,\n\t\tOauthSlack:              enableOauthSlack,\n\t\tOauthWriteAs:            enableOauthWriteAs,\n\t\tOauthGitLab:             enableOauthGitLab,\n\t\tGitLabDisplayName:       config.OrDefaultString(app.Config().GitlabOauth.DisplayName, gitlabDisplayName),\n\t\tOauthGeneric:            enableOauthGeneric,\n\t\tOauthGenericDisplayName: config.OrDefaultString(app.Config().GenericOauth.DisplayName, genericOauthDisplayName),\n\t\tOauthGitea:              enableOauthGitea,\n\t\tGiteaDisplayName:        config.OrDefaultString(app.Config().GiteaOauth.DisplayName, giteaDisplayName),\n\t}\n\n\tshowUserPage(w, \"settings\", obj)\n\treturn nil\n}\n\nfunc viewResetPassword(app *App, w http.ResponseWriter, r *http.Request) error {\n\ttoken := r.FormValue(\"t\")\n\tresetting := false\n\tvar userID int64 = 0\n\tif token != \"\" {\n\t\t// Show new password page\n\t\tuserID = app.db.GetUserFromPasswordReset(token)\n\t\tif userID == 0 {\n\t\t\treturn impart.HTTPError{http.StatusNotFound, \"\"}\n\t\t}\n\t\tresetting = true\n\t}\n\n\tif r.Method == http.MethodPost {\n\t\tnewPass := r.FormValue(\"new-pass\")\n\t\tif newPass == \"\" {\n\t\t\t// Send password reset email\n\t\t\treturn handleResetPasswordInit(app, w, r)\n\t\t}\n\n\t\t// Do actual password reset\n\t\t// Assumes token has been validated above\n\t\terr := doAutomatedPasswordChange(app, userID, newPass)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = app.db.ConsumePasswordResetToken(token)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't consume token %s for user %d!!! %s\", token, userID, err)\n\t\t}\n\t\taddSessionFlash(app, w, r, \"Your password was reset. Now you can log in below.\", nil)\n\t\treturn impart.HTTPError{http.StatusFound, \"/login\"}\n\t}\n\n\tf, _ := getSessionFlashes(app, w, r, nil)\n\n\t// Show reset password page\n\td := struct {\n\t\tpage.StaticPage\n\t\tFlashes      []string\n\t\tEmailEnabled bool\n\t\tCSRFField    template.HTML\n\t\tToken        string\n\t\tIsResetting  bool\n\t\tIsSent       bool\n\t}{\n\t\tStaticPage:   pageForReq(app, r),\n\t\tFlashes:      f,\n\t\tEmailEnabled: app.cfg.Email.Enabled(),\n\t\tCSRFField:    csrf.TemplateField(r),\n\t\tToken:        token,\n\t\tIsResetting:  resetting,\n\t\tIsSent:       r.FormValue(\"sent\") == \"1\",\n\t}\n\terr := pages[\"reset.tmpl\"].ExecuteTemplate(w, \"base\", d)\n\tif err != nil {\n\t\tlog.Error(\"Unable to render password reset page: %v\", err)\n\t\treturn err\n\t}\n\treturn err\n}\n\nfunc doAutomatedPasswordChange(app *App, userID int64, newPass string) error {\n\t// Do password reset\n\thashedPass, err := auth.HashPass([]byte(newPass))\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Could not create password hash.\"}\n\t}\n\n\t// Do update\n\terr = app.db.ChangePassphrase(userID, true, \"\", hashedPass)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc handleResetPasswordInit(app *App, w http.ResponseWriter, r *http.Request) error {\n\treturnLoc := impart.HTTPError{http.StatusFound, \"/reset\"}\n\n\tif !app.cfg.Email.Enabled() {\n\t\t// Email isn't configured, so there's nothing to do; send back to the reset form, where they'll get an explanation\n\t\treturn returnLoc\n\t}\n\n\tip := spam.GetIP(r)\n\talias := r.FormValue(\"alias\")\n\n\tu, err := app.db.GetUserForAuth(alias)\n\tif err != nil {\n\t\tif strings.IndexAny(alias, \"@\") > 0 {\n\t\t\taddSessionFlash(app, w, r, ErrUserNotFoundEmail.Message, nil)\n\t\t\treturn returnLoc\n\t\t}\n\t\taddSessionFlash(app, w, r, ErrUserNotFound.Message, nil)\n\t\treturn returnLoc\n\t}\n\tif u.IsAdmin() {\n\t\t// Prevent any reset emails on admin accounts\n\t\tlog.Error(\"Admin reset attempt\", `Someone just tried to reset the password for an admin (ID %d - %s). IP address: %s`, u.ID, u.Username, ip)\n\t\treturn returnLoc\n\t}\n\tif u.Email.String == \"\" {\n\t\terr := impart.HTTPError{http.StatusPreconditionFailed, \"User doesn't have an email address. Please contact us (\" + app.cfg.App.Host + \"/contact) to reset your password.\"}\n\t\taddSessionFlash(app, w, r, err.Message, nil)\n\t\treturn returnLoc\n\t}\n\tif isSet, _ := app.db.IsUserPassSet(u.ID); !isSet {\n\t\terr = loginViaEmail(app, u.Username, \"/me/settings\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\taddSessionFlash(app, w, r, \"We've emailed you a link to log in with.\", nil)\n\t\treturn returnLoc\n\t}\n\n\ttoken, err := app.db.CreatePasswordResetToken(u.ID)\n\tif err != nil {\n\t\tlog.Error(\"Error resetting password: %s\", err)\n\t\taddSessionFlash(app, w, r, ErrInternalGeneral.Message, nil)\n\t\treturn returnLoc\n\t}\n\n\terr = emailPasswordReset(app, u.EmailClear(app.keys), token)\n\tif err != nil {\n\t\tlog.Error(\"Error emailing password reset: %s\", err)\n\t\taddSessionFlash(app, w, r, ErrInternalGeneral.Message, nil)\n\t\treturn returnLoc\n\t}\n\n\taddSessionFlash(app, w, r, \"We sent an email to the address associated with this account.\", nil)\n\treturnLoc.Message += \"?sent=1\"\n\treturn returnLoc\n}\n\nfunc emailPasswordReset(app *App, toEmail, token string) error {\n\t// Send email\n\tgun := mailgun.NewMailgun(app.cfg.Email.Domain, app.cfg.Email.MailgunPrivate)\n\tfooterPara := \"Didn't request this password reset? Your account is still safe, and you can safely ignore this email.\"\n\n\tplainMsg := fmt.Sprintf(\"We received a request to reset your password on %s. Please click the following link to continue (or copy and paste it into your browser): %s/reset?t=%s\\n\\n%s\", app.cfg.App.SiteName, app.cfg.App.Host, token, footerPara)\n\tm := mailgun.NewMessage(app.cfg.App.SiteName+\" <noreply-password@\"+app.cfg.Email.Domain+\">\", \"Reset Your \"+app.cfg.App.SiteName+\" Password\", plainMsg, fmt.Sprintf(\"<%s>\", toEmail))\n\tm.AddTag(\"Password Reset\")\n\tm.SetHtml(fmt.Sprintf(`<html>\n\t<body style=\"font-family:Lora, 'Palatino Linotype', Palatino, Baskerville, 'Book Antiqua', 'New York', 'DejaVu serif', serif; font-size: 100%%; margin:1em 2em;\">\n\t\t<div style=\"margin:0 auto; max-width: 40em; font-size: 1.2em;\">\n        <h1 style=\"font-size:1.75em\"><a style=\"text-decoration:none;color:#000;\" href=\"%s\">%s</a></h1>\n\t\t<p>We received a request to reset your password on %s. Please click the following link to continue:</p>\n\t\t<p style=\"font-size:1.2em;margin-bottom:1.5em;\"><a href=\"%s/reset?t=%s\">Reset your password</a></p>\n        <p style=\"font-size: 0.86em;margin:1em auto\">%s</p>\n        </div>\n\t</body>\n</html>`, app.cfg.App.Host, app.cfg.App.SiteName, app.cfg.App.SiteName, app.cfg.App.Host, token, footerPara))\n\t_, _, err := gun.Send(m)\n\treturn err\n}\n\nfunc loginViaEmail(app *App, alias, redirectTo string) error {\n\tif !app.cfg.Email.Enabled() {\n\t\treturn fmt.Errorf(\"EMAIL ISN'T CONFIGURED on this server\")\n\t}\n\n\t// Make sure user has added an email\n\t// TODO: create a new func to just get user's email; \"ForAuth\" doesn't match here\n\tu, _ := app.db.GetUserForAuth(alias)\n\tif u == nil {\n\t\tif strings.IndexAny(alias, \"@\") > 0 {\n\t\t\treturn ErrUserNotFoundEmail\n\t\t}\n\t\treturn ErrUserNotFound\n\t}\n\tif u.Email.String == \"\" {\n\t\treturn impart.HTTPError{http.StatusPreconditionFailed, \"User doesn't have an email address. Log in with password, instead.\"}\n\t}\n\n\t// Generate one-time login token\n\tt, err := app.db.GetTemporaryOneTimeAccessToken(u.ID, 60*15, true)\n\tif err != nil {\n\t\tlog.Error(\"Unable to generate token for email login: %s\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Unable to generate token.\"}\n\t}\n\n\t// Send email\n\tgun := mailgun.NewMailgun(app.cfg.Email.Domain, app.cfg.Email.MailgunPrivate)\n\ttoEmail := u.EmailClear(app.keys)\n\tfooterPara := \"This link will only work once and expires in 15 minutes. Didn't ask us to log in? You can safely ignore this email.\"\n\n\tplainMsg := fmt.Sprintf(\"Log in to %s here: %s/login?to=%s&with=%s\\n\\n%s\", app.cfg.App.SiteName, app.cfg.App.Host, redirectTo, t, footerPara)\n\tm := mailgun.NewMessage(app.cfg.App.SiteName+\" <noreply-login@\"+app.cfg.Email.Domain+\">\", \"Log in to \"+app.cfg.App.SiteName, plainMsg, fmt.Sprintf(\"<%s>\", toEmail))\n\tm.AddTag(\"Email Login\")\n\n\tm.SetHtml(fmt.Sprintf(`<html>\n\t<body style=\"font-family:Lora, 'Palatino Linotype', Palatino, Baskerville, 'Book Antiqua', 'New York', 'DejaVu serif', serif; font-size: 100%%; margin:1em 2em;\">\n\t\t<div style=\"margin:0 auto; max-width: 40em; font-size: 1.2em;\">\n        <h1 style=\"font-size:1.75em\"><a style=\"text-decoration:none;color:#000;\" href=\"%s\">%s</a></h1>\n\t\t<p style=\"font-size:1.2em;margin-bottom:1.5em;text-align:center\"><a href=\"%s/login?to=%s&with=%s\">Log in to %s here</a>.</p>\n        <p style=\"font-size: 0.86em;color:#666;text-align:center;max-width:35em;margin:1em auto\">%s</p>\n        </div>\n\t</body>\n</html>`, app.cfg.App.Host, app.cfg.App.SiteName, app.cfg.App.Host, redirectTo, t, app.cfg.App.SiteName, footerPara))\n\t_, _, err = gun.Send(m)\n\n\treturn err\n}\n\nfunc saveTempInfo(app *App, key, val string, r *http.Request, w http.ResponseWriter) error {\n\tsession, err := app.sessionStore.Get(r, \"t\")\n\tif err != nil {\n\t\treturn ErrInternalCookieSession\n\t}\n\n\tsession.Values[key] = val\n\terr = session.Save(r, w)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't saveTempInfo for key-val (%s:%s): %v\", key, val, err)\n\t}\n\treturn err\n}\n\nfunc getTempInfo(app *App, key string, r *http.Request, w http.ResponseWriter) string {\n\tsession, err := app.sessionStore.Get(r, \"t\")\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\t// Get the information\n\tvar s = \"\"\n\tvar ok bool\n\tif s, ok = session.Values[key].(string); !ok {\n\t\treturn \"\"\n\t}\n\n\t// Delete cookie\n\tsession.Options.MaxAge = -1\n\terr = session.Save(r, w)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't erase temp data for key %s: %v\", key, err)\n\t}\n\n\t// Return value\n\treturn s\n}\n\nfunc handleUserDelete(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tif !app.cfg.App.OpenDeletion {\n\t\treturn impart.HTTPError{http.StatusForbidden, \"Open account deletion is disabled on this instance.\"}\n\t}\n\n\tconfirmUsername := r.PostFormValue(\"confirm-username\")\n\tif u.Username != confirmUsername {\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"Confirmation username must match your username exactly.\"}\n\t}\n\n\t// Check for account deletion safeguards in place\n\tif u.IsAdmin() {\n\t\treturn impart.HTTPError{http.StatusForbidden, \"Cannot delete admin.\"}\n\t}\n\n\terr := app.db.DeleteAccount(u.ID)\n\tif err != nil {\n\t\tlog.Error(\"user delete account: %v\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not delete account: %v\", err)}\n\t}\n\n\t// FIXME: This doesn't ever appear to the user, as (I believe) the value is erased when the session cookie is reset\n\t_ = addSessionFlash(app, w, r, \"Thanks for writing with us! You account was deleted successfully.\", nil)\n\treturn impart.HTTPError{http.StatusFound, \"/me/logout\"}\n}\n\nfunc removeOauth(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tprovider := r.FormValue(\"provider\")\n\tclientID := r.FormValue(\"client_id\")\n\tremoteUserID := r.FormValue(\"remote_user_id\")\n\n\terr := app.db.RemoveOauth(r.Context(), u.ID, provider, clientID, remoteUserID)\n\tif err != nil {\n\t\treturn impart.HTTPError{Status: http.StatusInternalServerError, Message: err.Error()}\n\t}\n\n\treturn impart.HTTPError{Status: http.StatusFound, Message: \"/me/settings\"}\n}\n\nfunc prepareUserEmail(input string, emailKey []byte) zero.String {\n\temail := zero.NewString(\"\", input != \"\")\n\tif len(input) > 0 {\n\t\tencEmail, err := data.Encrypt(emailKey, input)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to encrypt email: %s\\n\", err)\n\t\t} else {\n\t\t\temail.String = string(encEmail)\n\n\t\t}\n\t}\n\treturn email\n}\n"
        },
        {
          "name": "account_import.go",
          "type": "blob",
          "size": 5.3408203125,
          "content": "package writefreely\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-multierror\"\n\t\"github.com/writeas/impart\"\n\twfimport \"github.com/writeas/import\"\n\t\"github.com/writeas/web-core/log\"\n)\n\nfunc viewImport(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\t// Fetch extra user data\n\tp := NewUserPage(app, r, u, \"Import Posts\", nil)\n\n\tc, err := app.db.GetCollections(u, app.Config().App.Host)\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"unable to fetch collections: %v\", err)}\n\t}\n\n\td := struct {\n\t\t*UserPage\n\t\tCollections *[]Collection\n\t\tFlashes     []template.HTML\n\t\tMessage     string\n\t\tInfoMsg     bool\n\t}{\n\t\tUserPage:    p,\n\t\tCollections: c,\n\t\tFlashes:     []template.HTML{},\n\t}\n\n\tflashes, _ := getSessionFlashes(app, w, r, nil)\n\tfor _, flash := range flashes {\n\t\tif strings.HasPrefix(flash, \"SUCCESS: \") {\n\t\t\td.Message = strings.TrimPrefix(flash, \"SUCCESS: \")\n\t\t} else if strings.HasPrefix(flash, \"INFO: \") {\n\t\t\td.Message = strings.TrimPrefix(flash, \"INFO: \")\n\t\t\td.InfoMsg = true\n\t\t} else {\n\t\t\td.Flashes = append(d.Flashes, template.HTML(flash))\n\t\t}\n\t}\n\n\tshowUserPage(w, \"import\", d)\n\treturn nil\n}\n\nfunc handleImport(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\t// limit 10MB per submission\n\tr.ParseMultipartForm(10 << 20)\n\n\tcollAlias := r.PostFormValue(\"collection\")\n\tcoll := &Collection{\n\t\tID: 0,\n\t}\n\tvar err error\n\tif collAlias != \"\" {\n\t\tcoll, err = app.db.GetCollection(collAlias)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to get collection for import: %s\", err)\n\t\t\treturn err\n\t\t}\n\t\t// Only allow uploading to collection if current user is owner\n\t\tif coll.OwnerID != u.ID {\n\t\t\terr := ErrUnauthorizedGeneral\n\t\t\t_ = addSessionFlash(app, w, r, err.Message, nil)\n\t\t\treturn err\n\t\t}\n\t\tcoll.hostName = app.cfg.App.Host\n\t}\n\n\tfileDates := make(map[string]int64)\n\terr = json.Unmarshal([]byte(r.FormValue(\"fileDates\")), &fileDates)\n\tif err != nil {\n\t\tlog.Error(\"invalid form data for file dates: %v\", err)\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"form data for file dates was invalid\"}\n\t}\n\tfiles := r.MultipartForm.File[\"files\"]\n\tvar fileErrs []error\n\tfilesSubmitted := len(files)\n\tvar filesImported int\n\tfor _, formFile := range files {\n\t\tfname := \"\"\n\t\tok := func() bool {\n\t\t\tfile, err := formFile.Open()\n\t\t\tif err != nil {\n\t\t\t\tfileErrs = append(fileErrs, fmt.Errorf(\"Unable to read file %s\", formFile.Filename))\n\t\t\t\tlog.Error(\"import file: open from form: %v\", err)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\ttempFile, err := os.CreateTemp(\"\", \"post-upload-*.txt\")\n\t\t\tif err != nil {\n\t\t\t\tfileErrs = append(fileErrs, fmt.Errorf(\"Internal error for %s\", formFile.Filename))\n\t\t\t\tlog.Error(\"import file: create temp file %s: %v\", formFile.Filename, err)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tdefer tempFile.Close()\n\n\t\t\t_, err = io.Copy(tempFile, file)\n\t\t\tif err != nil {\n\t\t\t\tfileErrs = append(fileErrs, fmt.Errorf(\"Internal error for %s\", formFile.Filename))\n\t\t\t\tlog.Error(\"import file: copy to temp location %s: %v\", formFile.Filename, err)\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tinfo, err := tempFile.Stat()\n\t\t\tif err != nil {\n\t\t\t\tfileErrs = append(fileErrs, fmt.Errorf(\"Internal error for %s\", formFile.Filename))\n\t\t\t\tlog.Error(\"import file: stat temp file %s: %v\", formFile.Filename, err)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfname = info.Name()\n\t\t\treturn true\n\t\t}()\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tpost, err := wfimport.FromFile(filepath.Join(os.TempDir(), fname))\n\t\tif err == wfimport.ErrEmptyFile {\n\t\t\t// not a real error so don't log\n\t\t\t_ = addSessionFlash(app, w, r, fmt.Sprintf(\"%s was empty, import skipped\", formFile.Filename), nil)\n\t\t\tcontinue\n\t\t} else if err == wfimport.ErrInvalidContentType {\n\t\t\t// same as above\n\t\t\t_ = addSessionFlash(app, w, r, fmt.Sprintf(\"%s is not a supported post file\", formFile.Filename), nil)\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\tfileErrs = append(fileErrs, fmt.Errorf(\"failed to read copy of %s\", formFile.Filename))\n\t\t\tlog.Error(\"import textfile: file to post: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif collAlias != \"\" {\n\t\t\tpost.Collection = collAlias\n\t\t}\n\t\tdateTime := time.Unix(fileDates[formFile.Filename], 0)\n\t\tpost.Created = &dateTime\n\t\tcreated := post.Created.Format(\"2006-01-02T15:04:05Z\")\n\t\tsubmittedPost := SubmittedPost{\n\t\t\tTitle:   &post.Title,\n\t\t\tContent: &post.Content,\n\t\t\tFont:    \"norm\",\n\t\t\tCreated: &created,\n\t\t}\n\t\trp, err := app.db.CreatePost(u.ID, coll.ID, &submittedPost)\n\t\tif err != nil {\n\t\t\tfileErrs = append(fileErrs, fmt.Errorf(\"failed to create post from %s\", formFile.Filename))\n\t\t\tlog.Error(\"import textfile: create db post: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Federate post, if necessary\n\t\tif app.cfg.App.Federation && coll.ID > 0 {\n\t\t\tgo federatePost(\n\t\t\t\tapp,\n\t\t\t\t&PublicPost{\n\t\t\t\t\tPost: rp,\n\t\t\t\t\tCollection: &CollectionObj{\n\t\t\t\t\t\tCollection: *coll,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tcoll.ID,\n\t\t\t\tfalse,\n\t\t\t)\n\t\t}\n\t\tfilesImported++\n\t}\n\tif len(fileErrs) != 0 {\n\t\t_ = addSessionFlash(app, w, r, multierror.ListFormatFunc(fileErrs), nil)\n\t}\n\n\tif filesImported == filesSubmitted {\n\t\tverb := \"posts\"\n\t\tif filesSubmitted == 1 {\n\t\t\tverb = \"post\"\n\t\t}\n\t\t_ = addSessionFlash(app, w, r, fmt.Sprintf(\"SUCCESS: Import complete, %d %s imported.\", filesImported, verb), nil)\n\t} else if filesImported > 0 {\n\t\t_ = addSessionFlash(app, w, r, fmt.Sprintf(\"INFO: %d of %d posts imported, see details below.\", filesImported, filesSubmitted), nil)\n\t}\n\treturn impart.HTTPError{http.StatusFound, \"/me/import\"}\n}\n"
        },
        {
          "name": "activitypub.go",
          "type": "blob",
          "size": 30.916015625,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"database/sql\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/writeas/activity/streams\"\n\t\"github.com/writeas/activityserve\"\n\t\"github.com/writeas/httpsig\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/activitypub\"\n\t\"github.com/writeas/web-core/activitystreams\"\n\t\"github.com/writeas/web-core/id\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writeas/web-core/silobridge\"\n)\n\nconst (\n\t// TODO: delete. don't use this!\n\tapCustomHandleDefault = \"blog\"\n\n\tapCacheTime = time.Minute\n)\n\nvar (\n\tapCollectionPostIRIRegex = regexp.MustCompile(\"/api/collections/([a-z0-9\\\\-]+)/posts/([a-z0-9\\\\-]+)$\")\n\tapDraftPostIRIRegex      = regexp.MustCompile(\"/api/posts/([a-z0-9\\\\-]+)$\")\n)\n\nvar instanceColl *Collection\n\nfunc initActivityPub(app *App) {\n\tur, _ := url.Parse(app.cfg.App.Host)\n\tinstanceColl = &Collection{\n\t\tID:       0,\n\t\tAlias:    ur.Host,\n\t\tTitle:    ur.Host,\n\t\tdb:       app.db,\n\t\thostName: app.cfg.App.Host,\n\t}\n}\n\ntype RemoteUser struct {\n\tID          int64\n\tActorID     string\n\tInbox       string\n\tSharedInbox string\n\tURL         string\n\tHandle      string\n\tCreated     time.Time\n}\n\nfunc (ru *RemoteUser) CreatedFriendly() string {\n\treturn ru.Created.Format(\"January 2, 2006\")\n}\n\nfunc (ru *RemoteUser) EstimatedHandle() string {\n\tif ru.Handle != \"\" {\n\t\treturn ru.Handle\n\t}\n\tusername := filepath.Base(ru.ActorID)\n\thost, _ := url.Parse(ru.ActorID)\n\treturn username + \"@\" + host.Host\n}\n\nfunc (ru *RemoteUser) AsPerson() *activitystreams.Person {\n\treturn &activitystreams.Person{\n\t\tBaseObject: activitystreams.BaseObject{\n\t\t\tType: \"Person\",\n\t\t\tContext: []interface{}{\n\t\t\t\tactivitystreams.Namespace,\n\t\t\t},\n\t\t\tID: ru.ActorID,\n\t\t},\n\t\tInbox: ru.Inbox,\n\t\tEndpoints: activitystreams.Endpoints{\n\t\t\tSharedInbox: ru.SharedInbox,\n\t\t},\n\t}\n}\n\nfunc activityPubClient() *http.Client {\n\treturn &http.Client{\n\t\tTimeout: 15 * time.Second,\n\t}\n}\n\nfunc handleFetchCollectionActivities(app *App, w http.ResponseWriter, r *http.Request) error {\n\tw.Header().Set(\"Server\", serverSoftware)\n\n\tvars := mux.Vars(r)\n\talias := vars[\"alias\"]\n\tif alias == \"\" {\n\t\talias = filepath.Base(r.RequestURI)\n\t}\n\n\t// TODO: enforce visibility\n\t// Get base Collection data\n\tvar c *Collection\n\tvar err error\n\tif alias == r.Host {\n\t\tc = instanceColl\n\t} else if app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tif !c.IsInstanceColl() {\n\t\tsilenced, err := app.db.IsUserSilenced(c.OwnerID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"fetch collection activities: %v\", err)\n\t\t\treturn ErrInternalGeneral\n\t\t}\n\t\tif silenced {\n\t\t\treturn ErrCollectionNotFound\n\t\t}\n\t}\n\n\tp := c.PersonObject()\n\n\tsetCacheControl(w, apCacheTime)\n\treturn impart.RenderActivityJSON(w, p, http.StatusOK)\n}\n\nfunc handleFetchCollectionOutbox(app *App, w http.ResponseWriter, r *http.Request) error {\n\tw.Header().Set(\"Server\", serverSoftware)\n\n\tvars := mux.Vars(r)\n\talias := vars[\"alias\"]\n\n\t// TODO: enforce visibility\n\t// Get base Collection data\n\tvar c *Collection\n\tvar err error\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tsilenced, err := app.db.IsUserSilenced(c.OwnerID)\n\tif err != nil {\n\t\tlog.Error(\"fetch collection outbox: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\tif silenced {\n\t\treturn ErrCollectionNotFound\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tif app.cfg.App.SingleUser {\n\t\tif alias != c.Alias {\n\t\t\treturn ErrCollectionNotFound\n\t\t}\n\t}\n\n\tres := &CollectionObj{Collection: *c}\n\tapp.db.GetPostsCount(res, false)\n\taccountRoot := c.FederatedAccount()\n\n\tpage := r.FormValue(\"page\")\n\tp, err := strconv.Atoi(page)\n\tif err != nil || p < 1 {\n\t\t// Return outbox\n\t\toc := activitystreams.NewOrderedCollection(accountRoot, \"outbox\", res.TotalPosts)\n\t\treturn impart.RenderActivityJSON(w, oc, http.StatusOK)\n\t}\n\n\t// Return outbox page\n\tocp := activitystreams.NewOrderedCollectionPage(accountRoot, \"outbox\", res.TotalPosts, p)\n\tocp.OrderedItems = []interface{}{}\n\n\tposts, err := app.db.GetPosts(app.cfg, c, p, false, true, false)\n\tfor _, pp := range *posts {\n\t\tpp.Collection = res\n\t\to := pp.ActivityObject(app)\n\t\ta := activitystreams.NewCreateActivity(o)\n\t\ta.Context = nil\n\t\tocp.OrderedItems = append(ocp.OrderedItems, *a)\n\t}\n\n\tsetCacheControl(w, apCacheTime)\n\treturn impart.RenderActivityJSON(w, ocp, http.StatusOK)\n}\n\nfunc handleFetchCollectionFollowers(app *App, w http.ResponseWriter, r *http.Request) error {\n\tw.Header().Set(\"Server\", serverSoftware)\n\n\tvars := mux.Vars(r)\n\talias := vars[\"alias\"]\n\n\t// TODO: enforce visibility\n\t// Get base Collection data\n\tvar c *Collection\n\tvar err error\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tsilenced, err := app.db.IsUserSilenced(c.OwnerID)\n\tif err != nil {\n\t\tlog.Error(\"fetch collection followers: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\tif silenced {\n\t\treturn ErrCollectionNotFound\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\taccountRoot := c.FederatedAccount()\n\n\tfolls, err := app.db.GetAPFollowers(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpage := r.FormValue(\"page\")\n\tp, err := strconv.Atoi(page)\n\tif err != nil || p < 1 {\n\t\t// Return outbox\n\t\toc := activitystreams.NewOrderedCollection(accountRoot, \"followers\", len(*folls))\n\t\treturn impart.RenderActivityJSON(w, oc, http.StatusOK)\n\t}\n\n\t// Return outbox page\n\tocp := activitystreams.NewOrderedCollectionPage(accountRoot, \"followers\", len(*folls), p)\n\tocp.OrderedItems = []interface{}{}\n\t/*\n\t\tfor _, f := range *folls {\n\t\t\tocp.OrderedItems = append(ocp.OrderedItems, f.ActorID)\n\t\t}\n\t*/\n\tsetCacheControl(w, apCacheTime)\n\treturn impart.RenderActivityJSON(w, ocp, http.StatusOK)\n}\n\nfunc handleFetchCollectionFollowing(app *App, w http.ResponseWriter, r *http.Request) error {\n\tw.Header().Set(\"Server\", serverSoftware)\n\n\tvars := mux.Vars(r)\n\talias := vars[\"alias\"]\n\n\t// TODO: enforce visibility\n\t// Get base Collection data\n\tvar c *Collection\n\tvar err error\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tsilenced, err := app.db.IsUserSilenced(c.OwnerID)\n\tif err != nil {\n\t\tlog.Error(\"fetch collection following: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\tif silenced {\n\t\treturn ErrCollectionNotFound\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\taccountRoot := c.FederatedAccount()\n\n\tpage := r.FormValue(\"page\")\n\tp, err := strconv.Atoi(page)\n\tif err != nil || p < 1 {\n\t\t// Return outbox\n\t\toc := activitystreams.NewOrderedCollection(accountRoot, \"following\", 0)\n\t\treturn impart.RenderActivityJSON(w, oc, http.StatusOK)\n\t}\n\n\t// Return outbox page\n\tocp := activitystreams.NewOrderedCollectionPage(accountRoot, \"following\", 0, p)\n\tocp.OrderedItems = []interface{}{}\n\tsetCacheControl(w, apCacheTime)\n\treturn impart.RenderActivityJSON(w, ocp, http.StatusOK)\n}\n\nfunc handleFetchCollectionInbox(app *App, w http.ResponseWriter, r *http.Request) error {\n\tw.Header().Set(\"Server\", serverSoftware)\n\n\tvars := mux.Vars(r)\n\talias := vars[\"alias\"]\n\tvar c *Collection\n\tvar err error\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\t// TODO: return Reject?\n\t\treturn err\n\t}\n\tsilenced, err := app.db.IsUserSilenced(c.OwnerID)\n\tif err != nil {\n\t\tlog.Error(\"fetch collection inbox: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\tif silenced {\n\t\treturn ErrCollectionNotFound\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tif debugging {\n\t\tdump, err := httputil.DumpRequest(r, true)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Can't dump: %v\", err)\n\t\t} else {\n\t\t\tlog.Info(\"Rec'd! %q\", dump)\n\t\t}\n\t}\n\n\tvar m map[string]interface{}\n\tif err := json.NewDecoder(r.Body).Decode(&m); err != nil {\n\t\treturn err\n\t}\n\n\ta := streams.NewAccept()\n\tp := c.PersonObject()\n\tvar to *url.URL\n\tvar isFollow, isUnfollow, isLike, isUnlike bool\n\tvar likePostID, unlikePostID string\n\tfullActor := &activitystreams.Person{}\n\tvar remoteUser *RemoteUser\n\n\tres := &streams.Resolver{\n\t\tLikeCallback: func(l *streams.Like) error {\n\t\t\tisLike = true\n\n\t\t\t// 1) Use the Like concrete type here\n\t\t\t// 2) Errors are propagated to res.Deserialize call below\n\t\t\tm[\"@context\"] = []string{activitystreams.Namespace}\n\t\t\tb, _ := json.Marshal(m)\n\t\t\tif debugging {\n\t\t\t\tlog.Info(\"Like: %s\", b)\n\t\t\t}\n\n\t\t\t_, likeID := l.GetId()\n\t\t\tif likeID == nil {\n\t\t\t\tlog.Error(\"Didn't resolve Like ID\")\n\t\t\t}\n\t\t\tif p := l.HasObject(0); p == streams.NoPresence {\n\t\t\t\treturn fmt.Errorf(\"no object for Like activity at index 0\")\n\t\t\t}\n\n\t\t\tobj := l.Raw().GetObjectIRI(0)\n\t\t\t/*\n\t\t\t   // TODO: handle this more robustly\n\t\t\t   l.ResolveObject(&streams.Resolver{\n\t\t\t     LinkCallback: func(link *streams.Link) error {\n\t\t\t       return nil\n\t\t\t     },\n\t\t\t   }, 0)\n\t\t\t*/\n\n\t\t\tif obj == nil {\n\t\t\t\treturn fmt.Errorf(\"didn't get ObjectIRI to Like\")\n\t\t\t}\n\t\t\tlikePostID, err = parsePostIDFromURL(app, obj)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Finally, get actor information\n\t\t\t_, from := l.GetActor(0)\n\t\t\tif from == nil {\n\t\t\t\treturn fmt.Errorf(\"No valid actor string\")\n\t\t\t}\n\t\t\tfullActor, remoteUser, err = getActor(app, from.String())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tFollowCallback: func(f *streams.Follow) error {\n\t\t\tisFollow = true\n\n\t\t\t// 1) Use the Follow concrete type here\n\t\t\t// 2) Errors are propagated to res.Deserialize call below\n\t\t\tm[\"@context\"] = []string{activitystreams.Namespace}\n\t\t\tb, _ := json.Marshal(m)\n\t\t\tif debugging {\n\t\t\t\tlog.Info(\"Follow: %s\", b)\n\t\t\t}\n\n\t\t\t_, followID := f.GetId()\n\t\t\tif followID == nil {\n\t\t\t\tlog.Error(\"Didn't resolve follow ID\")\n\t\t\t} else {\n\t\t\t\taID := c.FederatedAccount() + \"#accept-\" + id.GenerateFriendlyRandomString(20)\n\t\t\t\tacceptID, err := url.Parse(aID)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error(\"Couldn't parse generated Accept URL '%s': %v\", aID, err)\n\t\t\t\t}\n\t\t\t\ta.SetId(acceptID)\n\t\t\t}\n\t\t\ta.AppendObject(f.Raw())\n\t\t\t_, to = f.GetActor(0)\n\t\t\tobj := f.Raw().GetObjectIRI(0)\n\t\t\ta.AppendActor(obj)\n\n\t\t\t// First get actor information\n\t\t\tif to == nil {\n\t\t\t\treturn fmt.Errorf(\"No valid `to` string\")\n\t\t\t}\n\t\t\tfullActor, remoteUser, err = getActor(app, to.String())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn impart.RenderActivityJSON(w, m, http.StatusOK)\n\t\t},\n\t\tUndoCallback: func(u *streams.Undo) error {\n\t\t\tm[\"@context\"] = []string{activitystreams.Namespace}\n\t\t\tb, _ := json.Marshal(m)\n\t\t\tif debugging {\n\t\t\t\tlog.Info(\"Undo: %s\", b)\n\t\t\t}\n\n\t\t\ta.AppendObject(u.Raw())\n\n\t\t\t// Check type -- we handle Undo:Like and Undo:Follow\n\t\t\t_, err := u.ResolveObject(&streams.Resolver{\n\t\t\t\tLikeCallback: func(like *streams.Like) error {\n\t\t\t\t\tisUnlike = true\n\n\t\t\t\t\t_, from := like.GetActor(0)\n\t\t\t\t\tobj := like.Raw().GetObjectIRI(0)\n\t\t\t\t\tif obj == nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"didn't get ObjectIRI for Undo Like\")\n\t\t\t\t\t}\n\t\t\t\t\tunlikePostID, err = parsePostIDFromURL(app, obj)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tfullActor, remoteUser, err = getActor(app, from.String())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\t// TODO: add FollowCallback for more robust handling\n\t\t\t}, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif isUnlike {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tisUnfollow = true\n\t\t\t_, to = u.GetActor(0)\n\t\t\t// TODO: get actor from object.object, not object\n\t\t\tobj := u.Raw().GetObjectIRI(0)\n\t\t\ta.AppendActor(obj)\n\t\t\tif to != nil {\n\t\t\t\t// Populate fullActor from DB?\n\t\t\t\tremoteUser, err = getRemoteUser(app, to.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\tif iErr, ok := err.(*impart.HTTPError); ok {\n\t\t\t\t\t\tif iErr.Status == http.StatusNotFound {\n\t\t\t\t\t\t\tlog.Error(\"No remoteuser info for Undo event!\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn err\n\t\t\t\t} else {\n\t\t\t\t\tfullActor = remoteUser.AsPerson()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.Error(\"No to on Undo!\")\n\t\t\t}\n\t\t\treturn impart.RenderActivityJSON(w, m, http.StatusOK)\n\t\t},\n\t}\n\tif err := res.Deserialize(m); err != nil {\n\t\t// 3) Any errors from #2 can be handled, or the payload is an unknown type.\n\t\tlog.Error(\"Unable to resolve Follow: %v\", err)\n\t\tif debugging {\n\t\t\tlog.Error(\"Map: %s\", m)\n\t\t}\n\t\treturn err\n\t}\n\n\t// Handle synchronous activities\n\tif isLike {\n\t\tt, err := app.db.Begin()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to start transaction: %v\", err)\n\t\t\treturn fmt.Errorf(\"unable to start transaction: %v\", err)\n\t\t}\n\n\t\tvar remoteUserID int64\n\t\tif remoteUser != nil {\n\t\t\tremoteUserID = remoteUser.ID\n\t\t} else {\n\t\t\tremoteUserID, err = apAddRemoteUser(app, t, fullActor)\n\t\t}\n\n\t\t// Add like\n\t\t_, err = t.Exec(\"INSERT INTO remote_likes (post_id, remote_user_id, created) VALUES (?, ?, \"+app.db.now()+\")\", likePostID, remoteUserID)\n\t\tif err != nil {\n\t\t\tif !app.db.isDuplicateKeyErr(err) {\n\t\t\t\tt.Rollback()\n\t\t\t\tlog.Error(\"Couldn't add like in DB: %v\\n\", err)\n\t\t\t\treturn fmt.Errorf(\"Couldn't add like in DB: %v\", err)\n\t\t\t} else {\n\t\t\t\tt.Rollback()\n\t\t\t\tlog.Error(\"Couldn't add like in DB: %v\\n\", err)\n\t\t\t\treturn fmt.Errorf(\"Couldn't add like in DB: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\terr = t.Commit()\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Rolling back after Commit(): %v\\n\", err)\n\t\t\treturn fmt.Errorf(\"Rolling back after Commit(): %v\\n\", err)\n\t\t}\n\n\t\tif debugging {\n\t\t\tlog.Info(\"Successfully liked post %s by remote user %s\", likePostID, remoteUser.URL)\n\t\t}\n\t\treturn impart.RenderActivityJSON(w, \"\", http.StatusOK)\n\t} else if isUnlike {\n\t\tt, err := app.db.Begin()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to start transaction: %v\", err)\n\t\t\treturn fmt.Errorf(\"unable to start transaction: %v\", err)\n\t\t}\n\n\t\tvar remoteUserID int64\n\t\tif remoteUser != nil {\n\t\t\tremoteUserID = remoteUser.ID\n\t\t} else {\n\t\t\tremoteUserID, err = apAddRemoteUser(app, t, fullActor)\n\t\t}\n\n\t\t// Remove like\n\t\t_, err = t.Exec(\"DELETE FROM remote_likes WHERE post_id = ? AND remote_user_id = ?\", unlikePostID, remoteUserID)\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Couldn't delete Like from DB: %v\\n\", err)\n\t\t\treturn fmt.Errorf(\"Couldn't delete Like from DB: %v\", err)\n\t\t}\n\n\t\terr = t.Commit()\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Rolling back after Commit(): %v\\n\", err)\n\t\t\treturn fmt.Errorf(\"Rolling back after Commit(): %v\\n\", err)\n\t\t}\n\n\t\tif debugging {\n\t\t\tlog.Info(\"Successfully un-liked post %s by remote user %s\", unlikePostID, remoteUser.URL)\n\t\t}\n\t\treturn impart.RenderActivityJSON(w, \"\", http.StatusOK)\n\t}\n\n\tgo func() {\n\t\tif to == nil {\n\t\t\tif debugging {\n\t\t\t\tlog.Error(\"No `to` value!\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\ttime.Sleep(2 * time.Second)\n\t\tam, err := a.Serialize()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to serialize Accept: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tam[\"@context\"] = []string{activitystreams.Namespace}\n\n\t\terr = makeActivityPost(app.cfg.App.Host, p, fullActor.Inbox, am)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to make activity POST: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif isFollow {\n\t\t\tt, err := app.db.Begin()\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Unable to start transaction: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar followerID int64\n\n\t\t\tif remoteUser != nil {\n\t\t\t\tfollowerID = remoteUser.ID\n\t\t\t} else {\n\t\t\t\t// TODO: use apAddRemoteUser() here, instead!\n\t\t\t\t// Add follower locally, since it wasn't found before\n\t\t\t\tres, err := t.Exec(\"INSERT INTO remoteusers (actor_id, inbox, shared_inbox, url) VALUES (?, ?, ?, ?)\", fullActor.ID, fullActor.Inbox, fullActor.Endpoints.SharedInbox, fullActor.URL)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// if duplicate key, res will be nil and panic on\n\t\t\t\t\t// res.LastInsertId below\n\t\t\t\t\tt.Rollback()\n\t\t\t\t\tlog.Error(\"Couldn't add new remoteuser in DB: %v\\n\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tfollowerID, err = res.LastInsertId()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Rollback()\n\t\t\t\t\tlog.Error(\"no lastinsertid for followers, rolling back: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Add in key\n\t\t\t\t_, err = t.Exec(\"INSERT INTO remoteuserkeys (id, remote_user_id, public_key) VALUES (?, ?, ?)\", fullActor.PublicKey.ID, followerID, fullActor.PublicKey.PublicKeyPEM)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif !app.db.isDuplicateKeyErr(err) {\n\t\t\t\t\t\tt.Rollback()\n\t\t\t\t\t\tlog.Error(\"Couldn't add follower keys in DB: %v\\n\", err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add follow\n\t\t\t_, err = t.Exec(\"INSERT INTO remotefollows (collection_id, remote_user_id, created) VALUES (?, ?, \"+app.db.now()+\")\", c.ID, followerID)\n\t\t\tif err != nil {\n\t\t\t\tif !app.db.isDuplicateKeyErr(err) {\n\t\t\t\t\tt.Rollback()\n\t\t\t\t\tlog.Error(\"Couldn't add follower in DB: %v\\n\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = t.Commit()\n\t\t\tif err != nil {\n\t\t\t\tt.Rollback()\n\t\t\t\tlog.Error(\"Rolling back after Commit(): %v\\n\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else if isUnfollow {\n\t\t\t// Remove follower locally\n\t\t\t_, err = app.db.Exec(\"DELETE FROM remotefollows WHERE collection_id = ? AND remote_user_id = (SELECT id FROM remoteusers WHERE actor_id = ?)\", c.ID, to.String())\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't remove follower from DB: %v\\n\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc makeActivityPost(hostName string, p *activitystreams.Person, url string, m interface{}) error {\n\tlog.Info(\"POST %s\", url)\n\tb, err := json.Marshal(m)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tr, _ := http.NewRequest(\"POST\", url, bytes.NewBuffer(b))\n\tr.Header.Add(\"Content-Type\", \"application/activity+json\")\n\tr.Header.Set(\"User-Agent\", ServerUserAgent(hostName))\n\th := sha256.New()\n\th.Write(b)\n\tr.Header.Add(\"Digest\", \"SHA-256=\"+base64.StdEncoding.EncodeToString(h.Sum(nil)))\n\n\t// Sign using the 'Signature' header\n\tprivKey, err := activitypub.DecodePrivateKey(p.GetPrivKey())\n\tif err != nil {\n\t\treturn err\n\t}\n\tsigner := httpsig.NewSigner(p.PublicKey.ID, privKey, httpsig.RSASHA256, []string{\"(request-target)\", \"date\", \"host\", \"digest\"})\n\terr = signer.SignSigHeader(r)\n\tif err != nil {\n\t\tlog.Error(\"Can't sign: %v\", err)\n\t}\n\n\tif debugging {\n\t\tdump, err := httputil.DumpRequestOut(r, true)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Can't dump: %v\", err)\n\t\t} else {\n\t\t\tlog.Info(\"%s\", dump)\n\t\t}\n\t}\n\n\tresp, err := activityPubClient().Do(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp != nil && resp.Body != nil {\n\t\tdefer resp.Body.Close()\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif debugging {\n\t\tlog.Info(\"Status  : %s\", resp.Status)\n\t\tlog.Info(\"Response: %s\", body)\n\t}\n\n\treturn nil\n}\n\nfunc resolveIRI(hostName, url string) ([]byte, error) {\n\tlog.Info(\"GET %s\", url)\n\n\tr, _ := http.NewRequest(\"GET\", url, nil)\n\tr.Header.Add(\"Accept\", \"application/activity+json\")\n\tr.Header.Set(\"User-Agent\", ServerUserAgent(hostName))\n\n\tp := instanceColl.PersonObject()\n\th := sha256.New()\n\th.Write([]byte{})\n\tr.Header.Add(\"Digest\", \"SHA-256=\"+base64.StdEncoding.EncodeToString(h.Sum(nil)))\n\n\t// Sign using the 'Signature' header\n\tprivKey, err := activitypub.DecodePrivateKey(p.GetPrivKey())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsigner := httpsig.NewSigner(p.PublicKey.ID, privKey, httpsig.RSASHA256, []string{\"(request-target)\", \"date\", \"host\", \"digest\"})\n\terr = signer.SignSigHeader(r)\n\tif err != nil {\n\t\tlog.Error(\"Can't sign: %v\", err)\n\t}\n\n\tif debugging {\n\t\tdump, err := httputil.DumpRequestOut(r, true)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Can't dump: %v\", err)\n\t\t} else {\n\t\t\tlog.Info(\"%s\", dump)\n\t\t}\n\t}\n\n\tresp, err := activityPubClient().Do(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp != nil && resp.Body != nil {\n\t\tdefer resp.Body.Close()\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif debugging {\n\t\tlog.Info(\"Status  : %s\", resp.Status)\n\t\tlog.Info(\"Response: %s\", body)\n\t}\n\n\treturn body, nil\n}\n\nfunc deleteFederatedPost(app *App, p *PublicPost, collID int64) error {\n\tif debugging {\n\t\tlog.Info(\"Deleting federated post!\")\n\t}\n\tp.Collection.hostName = app.cfg.App.Host\n\tactor := p.Collection.PersonObject(collID)\n\tna := p.ActivityObject(app)\n\n\t// Add followers\n\tp.Collection.ID = collID\n\tfollowers, err := app.db.GetAPFollowers(&p.Collection.Collection)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't delete post (get followers)! %v\", err)\n\t\treturn err\n\t}\n\n\tinboxes := map[string][]string{}\n\tfor _, f := range *followers {\n\t\tinbox := f.SharedInbox\n\t\tif inbox == \"\" {\n\t\t\tinbox = f.Inbox\n\t\t}\n\t\tif _, ok := inboxes[inbox]; ok {\n\t\t\tinboxes[inbox] = append(inboxes[inbox], f.ActorID)\n\t\t} else {\n\t\t\tinboxes[inbox] = []string{f.ActorID}\n\t\t}\n\t}\n\n\tfor si, instFolls := range inboxes {\n\t\tna.CC = []string{}\n\t\tna.CC = append(na.CC, instFolls...)\n\t\tda := activitystreams.NewDeleteActivity(na)\n\t\t// Make the ID unique to ensure it works in Pleroma\n\t\t// See: https://git.pleroma.social/pleroma/pleroma/issues/1481\n\t\tda.ID += \"#Delete\"\n\n\t\terr = makeActivityPost(app.cfg.App.Host, actor, si, da)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't delete post! %v\", err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc federatePost(app *App, p *PublicPost, collID int64, isUpdate bool) error {\n\t// If app is private, do not federate\n\tif app.cfg.App.Private {\n\t\treturn nil\n\t}\n\n\t// Do not federate posts from private or protected blogs\n\tif p.Collection.Visibility == CollPrivate || p.Collection.Visibility == CollProtected {\n\t\treturn nil\n\t}\n\n\tif debugging {\n\t\tif isUpdate {\n\t\t\tlog.Info(\"Federating updated post!\")\n\t\t} else {\n\t\t\tlog.Info(\"Federating new post!\")\n\t\t}\n\t}\n\n\tactor := p.Collection.PersonObject(collID)\n\tna := p.ActivityObject(app)\n\n\t// Add followers\n\tp.Collection.ID = collID\n\tfollowers, err := app.db.GetAPFollowers(&p.Collection.Collection)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't post! %v\", err)\n\t\treturn err\n\t}\n\tlog.Info(\"Followers for %d: %+v\", collID, followers)\n\n\tinboxes := map[string][]string{}\n\tfor _, f := range *followers {\n\t\tinbox := f.SharedInbox\n\t\tif inbox == \"\" {\n\t\t\tinbox = f.Inbox\n\t\t}\n\t\tif _, ok := inboxes[inbox]; ok {\n\t\t\t// check if we're already sending to this shared inbox\n\t\t\tinboxes[inbox] = append(inboxes[inbox], f.ActorID)\n\t\t} else {\n\t\t\t// add the new shared inbox to the list\n\t\t\tinboxes[inbox] = []string{f.ActorID}\n\t\t}\n\t}\n\n\tvar activity *activitystreams.Activity\n\t// for each one of the shared inboxes\n\tfor si, instFolls := range inboxes {\n\t\t// add all followers from that instance\n\t\t// to the CC field\n\t\tna.CC = []string{}\n\t\tna.CC = append(na.CC, instFolls...)\n\t\t// create a new \"Create\" activity\n\t\t// with our article as object\n\t\tif isUpdate {\n\t\t\tna.Updated = &p.Updated\n\t\t\tactivity = activitystreams.NewUpdateActivity(na)\n\t\t} else {\n\t\t\tactivity = activitystreams.NewCreateActivity(na)\n\t\t\tactivity.To = na.To\n\t\t\tactivity.CC = na.CC\n\t\t}\n\t\t// and post it to that sharedInbox\n\t\terr = makeActivityPost(app.cfg.App.Host, actor, si, activity)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't post! %v\", err)\n\t\t}\n\t}\n\n\t// re-create the object so that the CC list gets reset and has\n\t// the mentioned users. This might seem wasteful but the code is\n\t// cleaner than adding the mentioned users to CC here instead of\n\t// in p.ActivityObject()\n\tna = p.ActivityObject(app)\n\tfor _, tag := range na.Tag {\n\t\tif tag.Type == \"Mention\" {\n\t\t\tactivity = activitystreams.NewCreateActivity(na)\n\t\t\tactivity.To = na.To\n\t\t\tactivity.CC = na.CC\n\t\t\t// This here might be redundant in some cases as we might have already\n\t\t\t// sent this to the sharedInbox of this instance above, but we need too\n\t\t\t// much logic to catch this at the expense of the odd extra request.\n\t\t\t// I don't believe we'd ever have too many mentions in a single post that this\n\t\t\t// could become a burden.\n\t\t\tremoteUser, err := getRemoteUser(app, tag.HRef)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Unable to find remote user %s. Skipping: %v\", tag.HRef, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr = makeActivityPost(app.cfg.App.Host, actor, remoteUser.Inbox, activity)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't post! %v\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc getRemoteUser(app *App, actorID string) (*RemoteUser, error) {\n\tu := RemoteUser{ActorID: actorID}\n\tvar urlVal, handle sql.NullString\n\terr := app.db.QueryRow(\"SELECT id, inbox, shared_inbox, url, handle FROM remoteusers WHERE actor_id = ?\", actorID).Scan(&u.ID, &u.Inbox, &u.SharedInbox, &urlVal, &handle)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, impart.HTTPError{http.StatusNotFound, \"No remote user with that ID.\"}\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't get remote user %s: %v\", actorID, err)\n\t\treturn nil, err\n\t}\n\n\tu.URL = urlVal.String\n\tu.Handle = handle.String\n\n\treturn &u, nil\n}\n\n// getRemoteUserFromHandle retrieves the profile page of a remote user\n// from the @user@server.tld handle\nfunc getRemoteUserFromHandle(app *App, handle string) (*RemoteUser, error) {\n\tu := RemoteUser{Handle: handle}\n\tvar urlVal sql.NullString\n\terr := app.db.QueryRow(\"SELECT id, actor_id, inbox, shared_inbox, url FROM remoteusers WHERE handle = ?\", handle).Scan(&u.ID, &u.ActorID, &u.Inbox, &u.SharedInbox, &urlVal)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, ErrRemoteUserNotFound\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't get remote user %s: %v\", handle, err)\n\t\treturn nil, err\n\t}\n\tu.URL = urlVal.String\n\treturn &u, nil\n}\n\nfunc getActor(app *App, actorIRI string) (*activitystreams.Person, *RemoteUser, error) {\n\tlog.Info(\"Fetching actor %s locally\", actorIRI)\n\tactor := &activitystreams.Person{}\n\tremoteUser, err := getRemoteUser(app, actorIRI)\n\tif err != nil {\n\t\tif iErr, ok := err.(impart.HTTPError); ok {\n\t\t\tif iErr.Status == http.StatusNotFound {\n\t\t\t\t// Fetch remote actor\n\t\t\t\tlog.Info(\"Not found; fetching actor %s remotely\", actorIRI)\n\t\t\t\tactorResp, err := resolveIRI(app.cfg.App.Host, actorIRI)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error(\"Unable to get base actor! %v\", err)\n\t\t\t\t\treturn nil, nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't fetch actor.\"}\n\t\t\t\t}\n\t\t\t\tif err := unmarshalActor(actorResp, actor); err != nil {\n\t\t\t\t\tlog.Error(\"Unable to unmarshal base actor! %v\", err)\n\t\t\t\t\treturn nil, nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't parse actor.\"}\n\t\t\t\t}\n\t\t\t\tbaseActor := &activitystreams.Person{}\n\t\t\t\tif err := unmarshalActor(actorResp, baseActor); err != nil {\n\t\t\t\t\tlog.Error(\"Unable to unmarshal actual actor! %v\", err)\n\t\t\t\t\treturn nil, nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't parse actual actor.\"}\n\t\t\t\t}\n\t\t\t\t// Fetch the actual actor using the owner field from the publicKey object\n\t\t\t\tactualActorResp, err := resolveIRI(app.cfg.App.Host, baseActor.PublicKey.Owner)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error(\"Unable to get actual actor! %v\", err)\n\t\t\t\t\treturn nil, nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't fetch actual actor.\"}\n\t\t\t\t}\n\t\t\t\tif err := unmarshalActor(actualActorResp, actor); err != nil {\n\t\t\t\t\tlog.Error(\"Unable to unmarshal actual actor! %v\", err)\n\t\t\t\t\treturn nil, nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't parse actual actor.\"}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, nil, err\n\t\t}\n\t} else {\n\t\tactor = remoteUser.AsPerson()\n\t}\n\treturn actor, remoteUser, nil\n}\n\nfunc GetProfileURLFromHandle(app *App, handle string) (string, error) {\n\thandle = strings.TrimLeft(handle, \"@\")\n\tactorIRI := \"\"\n\tparts := strings.Split(handle, \"@\")\n\tif len(parts) != 2 {\n\t\treturn \"\", fmt.Errorf(\"invalid handle format\")\n\t}\n\tdomain := parts[1]\n\n\t// Check non-AP instances\n\tif siloProfileURL := silobridge.Profile(parts[0], domain); siloProfileURL != \"\" {\n\t\treturn siloProfileURL, nil\n\t}\n\n\tremoteUser, err := getRemoteUserFromHandle(app, handle)\n\tif err != nil {\n\t\t// can't find using handle in the table but the table may already have this user without\n\t\t// handle from a previous version\n\t\t// TODO: Make this determination. We should know whether a user exists without a handle, or doesn't exist at all\n\t\tactorIRI = RemoteLookup(handle)\n\t\t_, errRemoteUser := getRemoteUser(app, actorIRI)\n\t\t// if it exists then we need to update the handle\n\t\tif errRemoteUser == nil {\n\t\t\t_, err := app.db.Exec(\"UPDATE remoteusers SET handle = ? WHERE actor_id = ?\", handle, actorIRI)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't update handle '%s' for user %s\", handle, actorIRI)\n\t\t\t}\n\t\t} else {\n\t\t\t// this probably means we don't have the user in the table so let's try to insert it\n\t\t\t// here we need to ask the server for the inboxes\n\t\t\tremoteActor, err := activityserve.NewRemoteActor(actorIRI)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't fetch remote actor: %v\", err)\n\t\t\t}\n\t\t\tif debugging {\n\t\t\t\tlog.Info(\"Got remote actor: %s %s %s %s %s\", actorIRI, remoteActor.GetInbox(), remoteActor.GetSharedInbox(), remoteActor.URL(), handle)\n\t\t\t}\n\t\t\t_, err = app.db.Exec(\"INSERT INTO remoteusers (actor_id, inbox, shared_inbox, url, handle) VALUES(?, ?, ?, ?, ?)\", actorIRI, remoteActor.GetInbox(), remoteActor.GetSharedInbox(), remoteActor.URL(), handle)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't insert remote user: %v\", err)\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\tactorIRI = remoteActor.URL()\n\t\t}\n\t} else if remoteUser.URL == \"\" {\n\t\tlog.Info(\"Remote user %s URL empty, fetching\", remoteUser.ActorID)\n\t\tnewRemoteActor, err := activityserve.NewRemoteActor(remoteUser.ActorID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't fetch remote actor: %v\", err)\n\t\t} else {\n\t\t\t_, err := app.db.Exec(\"UPDATE remoteusers SET url = ? WHERE actor_id = ?\", newRemoteActor.URL(), remoteUser.ActorID)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't update handle '%s' for user %s\", handle, actorIRI)\n\t\t\t} else {\n\t\t\t\tactorIRI = newRemoteActor.URL()\n\t\t\t}\n\t\t}\n\t} else {\n\t\tactorIRI = remoteUser.URL\n\t}\n\treturn actorIRI, nil\n}\n\n// unmarshal actor normalizes the actor response to conform to\n// the type Person from github.com/writeas/web-core/activitysteams\n//\n// some implementations return different context field types\n// this converts any non-slice contexts into a slice\nfunc unmarshalActor(actorResp []byte, actor *activitystreams.Person) error {\n\t// FIXME: Hubzilla has an object for the Actor's url: cannot unmarshal object into Go struct field Person.url of type string\n\n\t// flexActor overrides the Context field to allow\n\t// all valid representations during unmarshal\n\tflexActor := struct {\n\t\tactivitystreams.Person\n\t\tContext json.RawMessage `json:\"@context,omitempty\"`\n\t}{}\n\tif err := json.Unmarshal(actorResp, &flexActor); err != nil {\n\t\treturn err\n\t}\n\n\tactor.Endpoints = flexActor.Endpoints\n\tactor.Followers = flexActor.Followers\n\tactor.Following = flexActor.Following\n\tactor.ID = flexActor.ID\n\tactor.Icon = flexActor.Icon\n\tactor.Inbox = flexActor.Inbox\n\tactor.Name = flexActor.Name\n\tactor.Outbox = flexActor.Outbox\n\tactor.PreferredUsername = flexActor.PreferredUsername\n\tactor.PublicKey = flexActor.PublicKey\n\tactor.Summary = flexActor.Summary\n\tactor.Type = flexActor.Type\n\tactor.URL = flexActor.URL\n\n\tfunc(val interface{}) {\n\t\tswitch val.(type) {\n\t\tcase []interface{}:\n\t\t\t// already a slice, do nothing\n\t\t\tactor.Context = val.([]interface{})\n\t\tdefault:\n\t\t\tactor.Context = []interface{}{val}\n\t\t}\n\t}(flexActor.Context)\n\n\treturn nil\n}\n\nfunc parsePostIDFromURL(app *App, u *url.URL) (string, error) {\n\t// Get post ID from URL\n\tvar collAlias, slug, postID string\n\tif m := apCollectionPostIRIRegex.FindStringSubmatch(u.String()); len(m) == 3 {\n\t\tcollAlias = m[1]\n\t\tslug = m[2]\n\t} else if m = apDraftPostIRIRegex.FindStringSubmatch(u.String()); len(m) == 2 {\n\t\tpostID = m[1]\n\t} else {\n\t\treturn \"\", fmt.Errorf(\"unable to match objectIRI: %s\", u)\n\t}\n\n\t// Get postID if all we have is collection and slug\n\tif collAlias != \"\" && slug != \"\" {\n\t\tc, err := app.db.GetCollection(collAlias)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tp, err := app.db.GetPost(slug, c.ID)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tpostID = p.ID\n\t}\n\n\treturn postID, nil\n}\n\nfunc setCacheControl(w http.ResponseWriter, ttl time.Duration) {\n\tw.Header().Set(\"Cache-Control\", fmt.Sprintf(\"public, max-age=%.0f\", ttl.Seconds()))\n}\n"
        },
        {
          "name": "activitypub_test.go",
          "type": "blob",
          "size": 0.560546875,
          "content": "package writefreely\n\nimport (\n\t\"testing\"\n\n\t\"github.com/writeas/web-core/activitystreams\"\n)\n\nvar actorTestTable = []struct {\n\tName string\n\tResp []byte\n}{\n\t{\n\t\t\"Context as a string\",\n\t\t[]byte(`{\"@context\":\"https://www.w3.org/ns/activitystreams\"}`),\n\t},\n\t{\n\t\t\"Context as a list\",\n\t\t[]byte(`{\"@context\":[\"one string\", \"two strings\"]}`),\n\t},\n}\n\nfunc TestUnmarshalActor(t *testing.T) {\n\tfor _, tc := range actorTestTable {\n\t\tactor := activitystreams.Person{}\n\t\terr := unmarshalActor(tc.Resp, &actor)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s failed with error %s\", tc.Name, err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "admin.go",
          "type": "blob",
          "size": 19.8779296875,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/auth\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writeas/web-core/passgen\"\n\t\"github.com/writefreely/writefreely/appstats\"\n\t\"github.com/writefreely/writefreely/config\"\n)\n\nvar (\n\tappStartTime = time.Now()\n\tsysStatus    systemStatus\n)\n\nconst adminUsersPerPage = 30\n\ntype systemStatus struct {\n\tUptime       string\n\tNumGoroutine int\n\n\t// General statistics.\n\tMemAllocated string // bytes allocated and still in use\n\tMemTotal     string // bytes allocated (even if freed)\n\tMemSys       string // bytes obtained from system (sum of XxxSys below)\n\tLookups      uint64 // number of pointer lookups\n\tMemMallocs   uint64 // number of mallocs\n\tMemFrees     uint64 // number of frees\n\n\t// Main allocation heap statistics.\n\tHeapAlloc    string // bytes allocated and still in use\n\tHeapSys      string // bytes obtained from system\n\tHeapIdle     string // bytes in idle spans\n\tHeapInuse    string // bytes in non-idle span\n\tHeapReleased string // bytes released to the OS\n\tHeapObjects  uint64 // total number of allocated objects\n\n\t// Low-level fixed-size structure allocator statistics.\n\t//\tInuse is bytes used now.\n\t//\tSys is bytes obtained from system.\n\tStackInuse  string // bootstrap stacks\n\tStackSys    string\n\tMSpanInuse  string // mspan structures\n\tMSpanSys    string\n\tMCacheInuse string // mcache structures\n\tMCacheSys   string\n\tBuckHashSys string // profiling bucket hash table\n\tGCSys       string // GC metadata\n\tOtherSys    string // other system allocations\n\n\t// Garbage collector statistics.\n\tNextGC       string // next run in HeapAlloc time (bytes)\n\tLastGC       string // last run in absolute time (ns)\n\tPauseTotalNs string\n\tPauseNs      string // circular buffer of recent GC pause times, most recent at [(NumGC+255)%256]\n\tNumGC        uint32\n}\n\ntype inspectedCollection struct {\n\tCollectionObj\n\tFollowers int\n\tLastPost  string\n}\n\ntype instanceContent struct {\n\tID      string\n\tType    string\n\tTitle   sql.NullString\n\tContent string\n\tUpdated time.Time\n}\n\ntype AdminPage struct {\n\tUpdateAvailable bool\n}\n\nfunc NewAdminPage(app *App) *AdminPage {\n\tap := &AdminPage{}\n\tif app.updates != nil {\n\t\tap.UpdateAvailable = app.updates.AreAvailableNoCheck()\n\t}\n\treturn ap\n}\n\nfunc (c instanceContent) UpdatedFriendly() template.HTML {\n\t/*\n\t\t// TODO: accept a locale in this method and use that for the format\n\t\tvar loc monday.Locale = monday.LocaleEnUS\n\t\treturn monday.Format(u.Created, monday.DateTimeFormatsByLocale[loc], loc)\n\t*/\n\tif c.Updated.IsZero() {\n\t\treturn \"<em>Never</em>\"\n\t}\n\treturn template.HTML(c.Updated.Format(\"January 2, 2006, 3:04 PM\"))\n}\n\nfunc handleViewAdminDash(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tp := struct {\n\t\t*UserPage\n\t\t*AdminPage\n\t\tMessage string\n\n\t\tUsersCount, CollectionsCount, PostsCount int64\n\t}{\n\t\tUserPage:  NewUserPage(app, r, u, \"Admin\", nil),\n\t\tAdminPage: NewAdminPage(app),\n\t\tMessage:   r.FormValue(\"m\"),\n\t}\n\n\t// Get user stats\n\tp.UsersCount = app.db.GetAllUsersCount()\n\tvar err error\n\tp.CollectionsCount, err = app.db.GetTotalCollections()\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.PostsCount, err = app.db.GetTotalPosts()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tshowUserPage(w, \"admin\", p)\n\treturn nil\n}\n\nfunc handleViewAdminMonitor(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tupdateAppStats()\n\tp := struct {\n\t\t*UserPage\n\t\t*AdminPage\n\t\tSysStatus systemStatus\n\t\tConfig    config.AppCfg\n\n\t\tMessage, ConfigMessage string\n\t}{\n\t\tUserPage:  NewUserPage(app, r, u, \"Admin\", nil),\n\t\tAdminPage: NewAdminPage(app),\n\t\tSysStatus: sysStatus,\n\t\tConfig:    app.cfg.App,\n\n\t\tMessage:       r.FormValue(\"m\"),\n\t\tConfigMessage: r.FormValue(\"cm\"),\n\t}\n\n\tshowUserPage(w, \"monitor\", p)\n\treturn nil\n}\n\nfunc handleViewAdminSettings(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tp := struct {\n\t\t*UserPage\n\t\t*AdminPage\n\t\tConfig config.AppCfg\n\n\t\tMessage, ConfigMessage string\n\t}{\n\t\tUserPage:  NewUserPage(app, r, u, \"Admin\", nil),\n\t\tAdminPage: NewAdminPage(app),\n\t\tConfig:    app.cfg.App,\n\n\t\tMessage:       r.FormValue(\"m\"),\n\t\tConfigMessage: r.FormValue(\"cm\"),\n\t}\n\n\tshowUserPage(w, \"app-settings\", p)\n\treturn nil\n}\n\nfunc handleViewAdminUsers(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tp := struct {\n\t\t*UserPage\n\t\t*AdminPage\n\t\tConfig  config.AppCfg\n\t\tMessage string\n\t\tFlashes []string\n\n\t\tUsers      *[]User\n\t\tCurPage    int\n\t\tTotalUsers int64\n\t\tTotalPages []int\n\t}{\n\t\tUserPage:  NewUserPage(app, r, u, \"Users\", nil),\n\t\tAdminPage: NewAdminPage(app),\n\t\tConfig:    app.cfg.App,\n\t\tMessage:   r.FormValue(\"m\"),\n\t}\n\n\tp.Flashes, _ = getSessionFlashes(app, w, r, nil)\n\tp.TotalUsers = app.db.GetAllUsersCount()\n\tttlPages := p.TotalUsers / adminUsersPerPage\n\tp.TotalPages = []int{}\n\tfor i := 1; i <= int(ttlPages); i++ {\n\t\tp.TotalPages = append(p.TotalPages, i)\n\t}\n\n\tvar err error\n\tp.CurPage, err = strconv.Atoi(r.FormValue(\"p\"))\n\tif err != nil || p.CurPage < 1 {\n\t\tp.CurPage = 1\n\t} else if p.CurPage > int(ttlPages) {\n\t\tp.CurPage = int(ttlPages)\n\t}\n\n\tp.Users, err = app.db.GetAllUsers(uint(p.CurPage))\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get users: %v\", err)}\n\t}\n\n\tshowUserPage(w, \"users\", p)\n\treturn nil\n}\n\nfunc handleViewAdminUser(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tusername := vars[\"username\"]\n\tif username == \"\" {\n\t\treturn impart.HTTPError{http.StatusFound, \"/admin/users\"}\n\t}\n\n\tp := struct {\n\t\t*UserPage\n\t\t*AdminPage\n\t\tConfig  config.AppCfg\n\t\tMessage string\n\n\t\tUser        *User\n\t\tColls       []inspectedCollection\n\t\tLastPost    string\n\t\tNewPassword string\n\t\tTotalPosts  int64\n\t\tClearEmail  string\n\t}{\n\t\tAdminPage: NewAdminPage(app),\n\t\tConfig:    app.cfg.App,\n\t\tMessage:   r.FormValue(\"m\"),\n\t\tColls:     []inspectedCollection{},\n\t}\n\n\tvar err error\n\tp.User, err = app.db.GetUserForAuth(username)\n\tif err != nil {\n\t\tif err == ErrUserNotFound {\n\t\t\treturn err\n\t\t}\n\t\tlog.Error(\"Could not get user: %v\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, err.Error()}\n\t}\n\n\tflashes, _ := getSessionFlashes(app, w, r, nil)\n\tfor _, flash := range flashes {\n\t\tif strings.HasPrefix(flash, \"SUCCESS: \") {\n\t\t\tp.NewPassword = strings.TrimPrefix(flash, \"SUCCESS: \")\n\t\t\tp.ClearEmail = p.User.EmailClear(app.keys)\n\t\t}\n\t}\n\tp.UserPage = NewUserPage(app, r, u, p.User.Username, nil)\n\tp.TotalPosts = app.db.GetUserPostsCount(p.User.ID)\n\tlp, err := app.db.GetUserLastPostTime(p.User.ID)\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get user's last post time: %v\", err)}\n\t}\n\tif lp != nil {\n\t\tp.LastPost = lp.Format(\"January 2, 2006, 3:04 PM\")\n\t}\n\n\tcolls, err := app.db.GetCollections(p.User, app.cfg.App.Host)\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get user's collections: %v\", err)}\n\t}\n\tfor _, c := range *colls {\n\t\tic := inspectedCollection{\n\t\t\tCollectionObj: CollectionObj{Collection: c},\n\t\t}\n\n\t\tif app.cfg.App.Federation {\n\t\t\tfolls, err := app.db.GetAPFollowers(&c)\n\t\t\tif err == nil {\n\t\t\t\t// TODO: handle error here (at least log it)\n\t\t\t\tic.Followers = len(*folls)\n\t\t\t}\n\t\t}\n\n\t\tapp.db.GetPostsCount(&ic.CollectionObj, true)\n\n\t\tlp, err := app.db.GetCollectionLastPostTime(c.ID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Didn't get last post time for collection %d: %v\", c.ID, err)\n\t\t}\n\t\tif lp != nil {\n\t\t\tic.LastPost = lp.Format(\"January 2, 2006, 3:04 PM\")\n\t\t}\n\n\t\tp.Colls = append(p.Colls, ic)\n\t}\n\n\tshowUserPage(w, \"view-user\", p)\n\treturn nil\n}\n\nfunc handleAdminDeleteUser(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tif !u.IsAdmin() {\n\t\treturn impart.HTTPError{http.StatusForbidden, \"Administrator privileges required for this action\"}\n\t}\n\n\tvars := mux.Vars(r)\n\tusername := vars[\"username\"]\n\tconfirmUsername := r.PostFormValue(\"confirm-username\")\n\n\tif confirmUsername != username {\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"Username was not confirmed\"}\n\t}\n\n\tuser, err := app.db.GetUserForAuth(username)\n\tif err == ErrUserNotFound {\n\t\treturn impart.HTTPError{http.StatusNotFound, fmt.Sprintf(\"User '%s' was not found\", username)}\n\t} else if err != nil {\n\t\tlog.Error(\"get user for deletion: %v\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get user with username '%s': %v\", username, err)}\n\t}\n\n\terr = app.db.DeleteAccount(user.ID)\n\tif err != nil {\n\t\tlog.Error(\"delete user %s: %v\", user.Username, err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not delete user account for '%s': %v\", username, err)}\n\t}\n\n\t_ = addSessionFlash(app, w, r, fmt.Sprintf(\"User \\\"%s\\\" was deleted successfully.\", username), nil)\n\treturn impart.HTTPError{http.StatusFound, \"/admin/users\"}\n}\n\nfunc handleAdminToggleUserStatus(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tusername := vars[\"username\"]\n\tif username == \"\" {\n\t\treturn impart.HTTPError{http.StatusFound, \"/admin/users\"}\n\t}\n\n\tuser, err := app.db.GetUserForAuth(username)\n\tif err != nil {\n\t\tlog.Error(\"failed to get user: %v\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get user from username: %v\", err)}\n\t}\n\tif user.IsSilenced() {\n\t\terr = app.db.SetUserStatus(user.ID, UserActive)\n\t} else {\n\t\terr = app.db.SetUserStatus(user.ID, UserSilenced)\n\n\t\t// reset the cache to removed silence user posts\n\t\tupdateTimelineCache(app.timeline, true)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"toggle user silenced: %v\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not toggle user status: %v\", err)}\n\t}\n\treturn impart.HTTPError{http.StatusFound, fmt.Sprintf(\"/admin/user/%s#status\", username)}\n}\n\nfunc handleAdminResetUserPass(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tusername := vars[\"username\"]\n\tif username == \"\" {\n\t\treturn impart.HTTPError{http.StatusFound, \"/admin/users\"}\n\t}\n\n\t// Generate new random password since none supplied\n\tpass := passgen.NewWordish()\n\thashedPass, err := auth.HashPass([]byte(pass))\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not create password hash: %v\", err)}\n\t}\n\n\tuserIDVal := r.FormValue(\"user\")\n\tlog.Info(\"ADMIN: Changing user %s password\", userIDVal)\n\tid, err := strconv.Atoi(userIDVal)\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusBadRequest, fmt.Sprintf(\"Invalid user ID: %v\", err)}\n\t}\n\n\terr = app.db.ChangePassphrase(int64(id), true, \"\", hashedPass)\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not update passphrase: %v\", err)}\n\t}\n\tlog.Info(\"ADMIN: Successfully changed.\")\n\n\taddSessionFlash(app, w, r, fmt.Sprintf(\"SUCCESS: %s\", pass), nil)\n\n\treturn impart.HTTPError{http.StatusFound, fmt.Sprintf(\"/admin/user/%s\", username)}\n}\n\nfunc handleViewAdminPages(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tp := struct {\n\t\t*UserPage\n\t\t*AdminPage\n\t\tConfig  config.AppCfg\n\t\tMessage string\n\n\t\tPages []*instanceContent\n\t}{\n\t\tUserPage:  NewUserPage(app, r, u, \"Pages\", nil),\n\t\tAdminPage: NewAdminPage(app),\n\t\tConfig:    app.cfg.App,\n\t\tMessage:   r.FormValue(\"m\"),\n\t}\n\n\tvar err error\n\tp.Pages, err = app.db.GetInstancePages()\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get pages: %v\", err)}\n\t}\n\n\t// Add in default pages\n\tvar hasAbout, hasContact, hasPrivacy bool\n\tfor i, c := range p.Pages {\n\t\tif hasAbout && hasContact && hasPrivacy {\n\t\t\tbreak\n\t\t}\n\t\tif c.ID == \"about\" {\n\t\t\thasAbout = true\n\t\t\tif !c.Title.Valid {\n\t\t\t\tp.Pages[i].Title = defaultAboutTitle(app.cfg)\n\t\t\t}\n\t\t} else if c.ID == \"contact\" {\n\t\t\thasContact = true\n\t\t\tif !c.Title.Valid {\n\t\t\t\tp.Pages[i].Title = defaultContactTitle()\n\t\t\t}\n\t\t} else if c.ID == \"privacy\" {\n\t\t\thasPrivacy = true\n\t\t\tif !c.Title.Valid {\n\t\t\t\tp.Pages[i].Title = defaultPrivacyTitle()\n\t\t\t}\n\t\t}\n\t}\n\tif !hasAbout {\n\t\tp.Pages = append(p.Pages, &instanceContent{\n\t\t\tID:      \"about\",\n\t\t\tTitle:   defaultAboutTitle(app.cfg),\n\t\t\tContent: defaultAboutPage(app.cfg),\n\t\t\tUpdated: defaultPageUpdatedTime,\n\t\t})\n\t}\n\tif !hasContact {\n\t\tp.Pages = append(p.Pages, &instanceContent{\n\t\t\tID:      \"contact\",\n\t\t\tTitle:   defaultContactTitle(),\n\t\t\tContent: defaultContactPage(app),\n\t\t})\n\t}\n\tif !hasPrivacy {\n\t\tp.Pages = append(p.Pages, &instanceContent{\n\t\t\tID:      \"privacy\",\n\t\t\tTitle:   defaultPrivacyTitle(),\n\t\t\tContent: defaultPrivacyPolicy(app.cfg),\n\t\t\tUpdated: defaultPageUpdatedTime,\n\t\t})\n\t}\n\n\tshowUserPage(w, \"pages\", p)\n\treturn nil\n}\n\nfunc handleViewAdminPage(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tslug := vars[\"slug\"]\n\tif slug == \"\" {\n\t\treturn impart.HTTPError{http.StatusFound, \"/admin/pages\"}\n\t}\n\n\tp := struct {\n\t\t*UserPage\n\t\t*AdminPage\n\t\tConfig  config.AppCfg\n\t\tMessage string\n\n\t\tBanner  *instanceContent\n\t\tContent *instanceContent\n\t}{\n\t\tAdminPage: NewAdminPage(app),\n\t\tConfig:    app.cfg.App,\n\t\tMessage:   r.FormValue(\"m\"),\n\t}\n\n\tvar err error\n\t// Get pre-defined pages, or select slug\n\tif slug == \"about\" {\n\t\tp.Content, err = getAboutPage(app)\n\t} else if slug == \"contact\" {\n\t\tp.Content, err = getContactPage(app)\n\t} else if slug == \"privacy\" {\n\t\tp.Content, err = getPrivacyPage(app)\n\t} else if slug == \"landing\" {\n\t\tp.Banner, err = getLandingBanner(app)\n\t\tif err != nil {\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get banner: %v\", err)}\n\t\t}\n\t\tp.Content, err = getLandingBody(app)\n\t\tp.Content.ID = \"landing\"\n\t} else if slug == \"reader\" {\n\t\tp.Content, err = getReaderSection(app)\n\t} else {\n\t\tp.Content, err = app.db.GetDynamicContent(slug)\n\t}\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get page: %v\", err)}\n\t}\n\ttitle := \"New page\"\n\tif p.Content != nil {\n\t\ttitle = \"Edit \" + p.Content.ID\n\t} else {\n\t\tp.Content = &instanceContent{}\n\t}\n\tp.UserPage = NewUserPage(app, r, u, title, nil)\n\n\tshowUserPage(w, \"view-page\", p)\n\treturn nil\n}\n\nfunc handleAdminUpdateSite(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tid := vars[\"page\"]\n\n\t// Validate\n\tif id != \"about\" && id != \"contact\" && id != \"privacy\" && id != \"landing\" && id != \"reader\" {\n\t\treturn impart.HTTPError{http.StatusNotFound, \"No such page.\"}\n\t}\n\n\tvar err error\n\tm := \"\"\n\tif id == \"landing\" {\n\t\t// Handle special landing page\n\t\terr = app.db.UpdateDynamicContent(\"landing-banner\", \"\", r.FormValue(\"banner\"), \"section\")\n\t\tif err != nil {\n\t\t\tm = \"?m=\" + err.Error()\n\t\t\treturn impart.HTTPError{http.StatusFound, \"/admin/page/\" + id + m}\n\t\t}\n\t\terr = app.db.UpdateDynamicContent(\"landing-body\", \"\", r.FormValue(\"content\"), \"section\")\n\t} else if id == \"reader\" {\n\t\t// Update sections with titles\n\t\terr = app.db.UpdateDynamicContent(id, r.FormValue(\"title\"), r.FormValue(\"content\"), \"section\")\n\t} else {\n\t\t// Update page\n\t\terr = app.db.UpdateDynamicContent(id, r.FormValue(\"title\"), r.FormValue(\"content\"), \"page\")\n\t}\n\tif err != nil {\n\t\tm = \"?m=\" + err.Error()\n\t}\n\treturn impart.HTTPError{http.StatusFound, \"/admin/page/\" + id + m}\n}\n\nfunc handleAdminUpdateConfig(apper Apper, u *User, w http.ResponseWriter, r *http.Request) error {\n\tapper.App().cfg.App.SiteName = r.FormValue(\"site_name\")\n\tapper.App().cfg.App.SiteDesc = r.FormValue(\"site_desc\")\n\tapper.App().cfg.App.Landing = r.FormValue(\"landing\")\n\tapper.App().cfg.App.OpenRegistration = r.FormValue(\"open_registration\") == \"on\"\n\tapper.App().cfg.App.OpenDeletion = r.FormValue(\"open_deletion\") == \"on\"\n\tmul, err := strconv.Atoi(r.FormValue(\"min_username_len\"))\n\tif err == nil {\n\t\tapper.App().cfg.App.MinUsernameLen = mul\n\t}\n\tmb, err := strconv.Atoi(r.FormValue(\"max_blogs\"))\n\tif err == nil {\n\t\tapper.App().cfg.App.MaxBlogs = mb\n\t}\n\tapper.App().cfg.App.Federation = r.FormValue(\"federation\") == \"on\"\n\tapper.App().cfg.App.PublicStats = r.FormValue(\"public_stats\") == \"on\"\n\tapper.App().cfg.App.Monetization = r.FormValue(\"monetization\") == \"on\"\n\tapper.App().cfg.App.Private = r.FormValue(\"private\") == \"on\"\n\tapper.App().cfg.App.LocalTimeline = r.FormValue(\"local_timeline\") == \"on\"\n\tif apper.App().cfg.App.LocalTimeline && apper.App().timeline == nil {\n\t\tlog.Info(\"Initializing local timeline...\")\n\t\tinitLocalTimeline(apper.App())\n\t}\n\tapper.App().cfg.App.UserInvites = r.FormValue(\"user_invites\")\n\tif apper.App().cfg.App.UserInvites == \"none\" {\n\t\tapper.App().cfg.App.UserInvites = \"\"\n\t}\n\tapper.App().cfg.App.DefaultVisibility = r.FormValue(\"default_visibility\")\n\n\tm := \"?cm=Configuration+saved.\"\n\terr = apper.SaveConfig(apper.App().cfg)\n\tif err != nil {\n\t\tm = \"?cm=\" + err.Error()\n\t}\n\treturn impart.HTTPError{http.StatusFound, \"/admin/settings\" + m + \"#config\"}\n}\n\nfunc updateAppStats() {\n\tsysStatus.Uptime = appstats.TimeSincePro(appStartTime)\n\n\tm := new(runtime.MemStats)\n\truntime.ReadMemStats(m)\n\tsysStatus.NumGoroutine = runtime.NumGoroutine()\n\n\tsysStatus.MemAllocated = appstats.FileSize(int64(m.Alloc))\n\tsysStatus.MemTotal = appstats.FileSize(int64(m.TotalAlloc))\n\tsysStatus.MemSys = appstats.FileSize(int64(m.Sys))\n\tsysStatus.Lookups = m.Lookups\n\tsysStatus.MemMallocs = m.Mallocs\n\tsysStatus.MemFrees = m.Frees\n\n\tsysStatus.HeapAlloc = appstats.FileSize(int64(m.HeapAlloc))\n\tsysStatus.HeapSys = appstats.FileSize(int64(m.HeapSys))\n\tsysStatus.HeapIdle = appstats.FileSize(int64(m.HeapIdle))\n\tsysStatus.HeapInuse = appstats.FileSize(int64(m.HeapInuse))\n\tsysStatus.HeapReleased = appstats.FileSize(int64(m.HeapReleased))\n\tsysStatus.HeapObjects = m.HeapObjects\n\n\tsysStatus.StackInuse = appstats.FileSize(int64(m.StackInuse))\n\tsysStatus.StackSys = appstats.FileSize(int64(m.StackSys))\n\tsysStatus.MSpanInuse = appstats.FileSize(int64(m.MSpanInuse))\n\tsysStatus.MSpanSys = appstats.FileSize(int64(m.MSpanSys))\n\tsysStatus.MCacheInuse = appstats.FileSize(int64(m.MCacheInuse))\n\tsysStatus.MCacheSys = appstats.FileSize(int64(m.MCacheSys))\n\tsysStatus.BuckHashSys = appstats.FileSize(int64(m.BuckHashSys))\n\tsysStatus.GCSys = appstats.FileSize(int64(m.GCSys))\n\tsysStatus.OtherSys = appstats.FileSize(int64(m.OtherSys))\n\n\tsysStatus.NextGC = appstats.FileSize(int64(m.NextGC))\n\tsysStatus.LastGC = fmt.Sprintf(\"%.1fs\", float64(time.Now().UnixNano()-int64(m.LastGC))/1000/1000/1000)\n\tsysStatus.PauseTotalNs = fmt.Sprintf(\"%.1fs\", float64(m.PauseTotalNs)/1000/1000/1000)\n\tsysStatus.PauseNs = fmt.Sprintf(\"%.3fs\", float64(m.PauseNs[(m.NumGC+255)%256])/1000/1000/1000)\n\tsysStatus.NumGC = m.NumGC\n}\n\nfunc adminResetPassword(app *App, u *User, newPass string) error {\n\thashedPass, err := auth.HashPass([]byte(newPass))\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not create password hash: %v\", err)}\n\t}\n\n\terr = app.db.ChangePassphrase(u.ID, true, \"\", hashedPass)\n\tif err != nil {\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not update passphrase: %v\", err)}\n\t}\n\treturn nil\n}\n\nfunc handleViewAdminUpdates(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tcheck := r.URL.Query().Get(\"check\")\n\n\tif check == \"now\" && app.cfg.App.UpdateChecks {\n\t\tapp.updates.CheckNow()\n\t}\n\n\tp := struct {\n\t\t*UserPage\n\t\t*AdminPage\n\t\tCurReleaseNotesURL    string\n\t\tLastChecked           string\n\t\tLastChecked8601       string\n\t\tLatestVersion         string\n\t\tLatestReleaseURL      string\n\t\tLatestReleaseNotesURL string\n\t\tCheckFailed           bool\n\t}{\n\t\tUserPage:  NewUserPage(app, r, u, \"Updates\", nil),\n\t\tAdminPage: NewAdminPage(app),\n\t}\n\tp.CurReleaseNotesURL = wfReleaseNotesURL(p.Version)\n\tif app.cfg.App.UpdateChecks {\n\t\tp.LastChecked = app.updates.lastCheck.Format(\"January 2, 2006, 3:04 PM\")\n\t\tp.LastChecked8601 = app.updates.lastCheck.Format(\"2006-01-02T15:04:05Z\")\n\t\tp.LatestVersion = app.updates.LatestVersion()\n\t\tp.LatestReleaseURL = app.updates.ReleaseURL()\n\t\tp.LatestReleaseNotesURL = app.updates.ReleaseNotesURL()\n\t\tp.UpdateAvailable = app.updates.AreAvailable()\n\t\tp.CheckFailed = app.updates.checkError != nil\n\t}\n\n\tshowUserPage(w, \"app-updates\", p)\n\treturn nil\n}\n"
        },
        {
          "name": "app.go",
          "type": "blob",
          "size": 25.685546875,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"crypto/tls\"\n\t\"database/sql\"\n\t_ \"embed\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gorilla/schema\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/manifoldco/promptui\"\n\tstripmd \"github.com/writeas/go-strip-markdown/v2\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/auth\"\n\t\"github.com/writeas/web-core/converter\"\n\t\"github.com/writeas/web-core/log\"\n\t\"golang.org/x/crypto/acme/autocert\"\n\n\t\"github.com/writefreely/writefreely/author\"\n\t\"github.com/writefreely/writefreely/config\"\n\t\"github.com/writefreely/writefreely/key\"\n\t\"github.com/writefreely/writefreely/migrations\"\n\t\"github.com/writefreely/writefreely/page\"\n)\n\nconst (\n\tstaticDir       = \"static\"\n\tassumedTitleLen = 80\n\tpostsPerPage    = 10\n\n\tserverSoftware = \"WriteFreely\"\n\tsoftwareURL    = \"https://writefreely.org\"\n)\n\nvar (\n\tdebugging bool\n\n\t// Software version can be set from git env using -ldflags\n\tsoftwareVer = \"0.15.1\"\n\n\t// DEPRECATED VARS\n\tisSingleUser bool\n)\n\n// App holds data and configuration for an individual WriteFreely instance.\ntype App struct {\n\trouter       *mux.Router\n\tshttp        *http.ServeMux\n\tdb           *datastore\n\tcfg          *config.Config\n\tcfgFile      string\n\tkeys         *key.Keychain\n\tsessionStore sessions.Store\n\tformDecoder  *schema.Decoder\n\tupdates      *updatesCache\n\n\ttimeline *localTimeline\n}\n\n// DB returns the App's datastore\nfunc (app *App) DB() *datastore {\n\treturn app.db\n}\n\n// Router returns the App's router\nfunc (app *App) Router() *mux.Router {\n\treturn app.router\n}\n\n// Config returns the App's current configuration.\nfunc (app *App) Config() *config.Config {\n\treturn app.cfg\n}\n\n// SetConfig updates the App's Config to the given value.\nfunc (app *App) SetConfig(cfg *config.Config) {\n\tapp.cfg = cfg\n}\n\n// SetKeys updates the App's Keychain to the given value.\nfunc (app *App) SetKeys(k *key.Keychain) {\n\tapp.keys = k\n}\n\nfunc (app *App) SessionStore() sessions.Store {\n\treturn app.sessionStore\n}\n\nfunc (app *App) SetSessionStore(s sessions.Store) {\n\tapp.sessionStore = s\n}\n\n// Apper is the interface for getting data into and out of a WriteFreely\n// instance (or \"App\").\n//\n// App returns the App for the current instance.\n//\n// LoadConfig reads an app configuration into the App, returning any error\n// encountered.\n//\n// SaveConfig persists the current App configuration.\n//\n// LoadKeys reads the App's encryption keys and loads them into its\n// key.Keychain.\ntype Apper interface {\n\tApp() *App\n\n\tLoadConfig() error\n\tSaveConfig(*config.Config) error\n\n\tLoadKeys() error\n\n\tReqLog(r *http.Request, status int, timeSince time.Duration) string\n}\n\n// App returns the App\nfunc (app *App) App() *App {\n\treturn app\n}\n\n// LoadConfig loads and parses a config file.\nfunc (app *App) LoadConfig() error {\n\tlog.Info(\"Loading %s configuration...\", app.cfgFile)\n\tcfg, err := config.Load(app.cfgFile)\n\tif err != nil {\n\t\tlog.Error(\"Unable to load configuration: %v\", err)\n\t\tos.Exit(1)\n\t\treturn err\n\t}\n\tapp.cfg = cfg\n\treturn nil\n}\n\n// SaveConfig saves the given Config to disk -- namely, to the App's cfgFile.\nfunc (app *App) SaveConfig(c *config.Config) error {\n\treturn config.Save(c, app.cfgFile)\n}\n\n// LoadKeys reads all needed keys from disk into the App. In order to use the\n// configured `Server.KeysParentDir`, you must call initKeyPaths(App) before\n// this.\nfunc (app *App) LoadKeys() error {\n\tvar err error\n\tapp.keys = &key.Keychain{}\n\n\tif debugging {\n\t\tlog.Info(\"  %s\", emailKeyPath)\n\t}\n\n\texecutable, err := os.Executable()\n\tif err != nil {\n\t\texecutable = \"writefreely\"\n\t} else {\n\t\texecutable = filepath.Base(executable)\n\t}\n\n\tapp.keys.EmailKey, err = os.ReadFile(emailKeyPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif debugging {\n\t\tlog.Info(\"  %s\", cookieAuthKeyPath)\n\t}\n\tapp.keys.CookieAuthKey, err = os.ReadFile(cookieAuthKeyPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif debugging {\n\t\tlog.Info(\"  %s\", cookieKeyPath)\n\t}\n\tapp.keys.CookieKey, err = os.ReadFile(cookieKeyPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif debugging {\n\t\tlog.Info(\"  %s\", csrfKeyPath)\n\t}\n\tapp.keys.CSRFKey, err = os.ReadFile(csrfKeyPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tlog.Error(`Missing key: %s.\n\n  Run this command to generate missing keys:\n    %s keys generate\n\n`, csrfKeyPath, executable)\n\t\t}\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (app *App) ReqLog(r *http.Request, status int, timeSince time.Duration) string {\n\treturn fmt.Sprintf(\"\\\"%s %s\\\" %d %s \\\"%s\\\"\", r.Method, r.RequestURI, status, timeSince, r.UserAgent())\n}\n\n// handleViewHome shows page at root path. It checks the configuration and\n// authentication state to show the correct page.\nfunc handleViewHome(app *App, w http.ResponseWriter, r *http.Request) error {\n\tif app.cfg.App.SingleUser {\n\t\t// Render blog index\n\t\treturn handleViewCollection(app, w, r)\n\t}\n\n\t// Multi-user instance\n\tforceLanding := r.FormValue(\"landing\") == \"1\"\n\tif !forceLanding {\n\t\t// Show correct page based on user auth status and configured landing path\n\t\tu := getUserSession(app, r)\n\n\t\tif app.cfg.App.Chorus {\n\t\t\t// This instance is focused on reading, so show Reader on home route if not\n\t\t\t// private or a private-instance user is logged in.\n\t\t\tif !app.cfg.App.Private || u != nil {\n\t\t\t\treturn viewLocalTimeline(app, w, r)\n\t\t\t}\n\t\t}\n\n\t\tif u != nil {\n\t\t\t// User is logged in, so show the Pad\n\t\t\treturn handleViewPad(app, w, r)\n\t\t}\n\n\t\tif app.cfg.App.Private {\n\t\t\treturn viewLogin(app, w, r)\n\t\t}\n\n\t\tif land := app.cfg.App.LandingPath(); land != \"/\" {\n\t\t\treturn impart.HTTPError{http.StatusFound, land}\n\t\t}\n\t}\n\n\treturn handleViewLanding(app, w, r)\n}\n\nfunc handleViewLanding(app *App, w http.ResponseWriter, r *http.Request) error {\n\tforceLanding := r.FormValue(\"landing\") == \"1\"\n\n\tp := struct {\n\t\tpage.StaticPage\n\t\t*OAuthButtons\n\t\tFlashes []template.HTML\n\t\tBanner  template.HTML\n\t\tContent template.HTML\n\n\t\tForcedLanding bool\n\t}{\n\t\tStaticPage:    pageForReq(app, r),\n\t\tOAuthButtons:  NewOAuthButtons(app.Config()),\n\t\tForcedLanding: forceLanding,\n\t}\n\n\tbanner, err := getLandingBanner(app)\n\tif err != nil {\n\t\tlog.Error(\"unable to get landing banner: %v\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get banner: %v\", err)}\n\t}\n\tp.Banner = template.HTML(applyMarkdown([]byte(banner.Content), \"\", app.cfg))\n\n\tcontent, err := getLandingBody(app)\n\tif err != nil {\n\t\tlog.Error(\"unable to get landing content: %v\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, fmt.Sprintf(\"Could not get content: %v\", err)}\n\t}\n\tp.Content = template.HTML(applyMarkdown([]byte(content.Content), \"\", app.cfg))\n\n\t// Get error messages\n\tsession, err := app.sessionStore.Get(r, cookieName)\n\tif err != nil {\n\t\t// Ignore this\n\t\tlog.Error(\"Unable to get session in handleViewHome; ignoring: %v\", err)\n\t}\n\tflashes, _ := getSessionFlashes(app, w, r, session)\n\tfor _, flash := range flashes {\n\t\tp.Flashes = append(p.Flashes, template.HTML(flash))\n\t}\n\n\t// Show landing page\n\treturn renderPage(w, \"landing.tmpl\", p)\n}\n\nfunc handleTemplatedPage(app *App, w http.ResponseWriter, r *http.Request, t *template.Template) error {\n\tp := struct {\n\t\tpage.StaticPage\n\t\tContentTitle string\n\t\tContent      template.HTML\n\t\tPlainContent string\n\t\tUpdated      string\n\n\t\tAboutStats *InstanceStats\n\t}{\n\t\tStaticPage: pageForReq(app, r),\n\t}\n\tif r.URL.Path == \"/about\" || r.URL.Path == \"/contact\" || r.URL.Path == \"/privacy\" {\n\t\tvar c *instanceContent\n\t\tvar err error\n\n\t\tif r.URL.Path == \"/about\" {\n\t\t\tc, err = getAboutPage(app)\n\n\t\t\t// Fetch stats\n\t\t\tp.AboutStats = &InstanceStats{}\n\t\t\tp.AboutStats.NumPosts, _ = app.db.GetTotalPosts()\n\t\t\tp.AboutStats.NumBlogs, _ = app.db.GetTotalCollections()\n\t\t} else if r.URL.Path == \"/contact\" {\n\t\t\tc, err = getContactPage(app)\n\t\t\tif c.Updated.IsZero() {\n\t\t\t\t// Page was never set up, so return 404\n\t\t\t\treturn ErrPostNotFound\n\t\t\t}\n\t\t} else {\n\t\t\tc, err = getPrivacyPage(app)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp.ContentTitle = c.Title.String\n\t\tp.Content = template.HTML(applyMarkdown([]byte(c.Content), \"\", app.cfg))\n\t\tp.PlainContent = shortPostDescription(stripmd.Strip(c.Content))\n\t\tif !c.Updated.IsZero() {\n\t\t\tp.Updated = c.Updated.Format(\"January 2, 2006\")\n\t\t}\n\t}\n\n\t// Serve templated page\n\terr := t.ExecuteTemplate(w, \"base\", p)\n\tif err != nil {\n\t\tlog.Error(\"Unable to render page: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc pageForReq(app *App, r *http.Request) page.StaticPage {\n\tp := page.StaticPage{\n\t\tAppCfg:  app.cfg.App,\n\t\tPath:    r.URL.Path,\n\t\tVersion: \"v\" + softwareVer,\n\t}\n\n\t// Use custom style, if file exists\n\tif _, err := os.Stat(filepath.Join(app.cfg.Server.StaticParentDir, staticDir, \"local\", \"custom.css\")); err == nil {\n\t\tp.CustomCSS = true\n\t}\n\n\t// Add user information, if given\n\tvar u *User\n\taccessToken := r.FormValue(\"t\")\n\tif accessToken != \"\" {\n\t\tuserID := app.db.GetUserID(accessToken)\n\t\tif userID != -1 {\n\t\t\tvar err error\n\t\t\tu, err = app.db.GetUserByID(userID)\n\t\t\tif err == nil {\n\t\t\t\tp.Username = u.Username\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu = getUserSession(app, r)\n\t\tif u != nil {\n\t\t\tp.Username = u.Username\n\t\t\tp.IsAdmin = u != nil && u.IsAdmin()\n\t\t\tp.CanInvite = canUserInvite(app.cfg, p.IsAdmin)\n\t\t}\n\t}\n\tp.CanViewReader = !app.cfg.App.Private || u != nil\n\n\treturn p\n}\n\nvar fileRegex = regexp.MustCompile(\"/([^/]*\\\\.[^/]*)$\")\n\n// Initialize loads the app configuration and initializes templates, keys,\n// session, route handlers, and the database connection.\nfunc Initialize(apper Apper, debug bool) (*App, error) {\n\tdebugging = debug\n\n\tapper.LoadConfig()\n\n\t// Load templates\n\terr := InitTemplates(apper.App().Config())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"load templates: %s\", err)\n\t}\n\n\t// Load keys and set up session\n\tinitKeyPaths(apper.App()) // TODO: find a better way to do this, since it's unneeded in all Apper implementations\n\terr = InitKeys(apper)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"init keys: %s\", err)\n\t}\n\tapper.App().InitUpdates()\n\n\tapper.App().InitSession()\n\n\tapper.App().InitDecoder()\n\n\terr = ConnectToDatabase(apper.App())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"connect to DB: %s\", err)\n\t}\n\n\tinitActivityPub(apper.App())\n\n\tif apper.App().cfg.Email.Domain != \"\" || apper.App().cfg.Email.MailgunPrivate != \"\" {\n\t\tif apper.App().cfg.Email.Domain == \"\" {\n\t\t\tlog.Error(\"[FAILED] Starting publish jobs queue: no [letters]domain config value set.\")\n\t\t} else if apper.App().cfg.Email.MailgunPrivate == \"\" {\n\t\t\tlog.Error(\"[FAILED] Starting publish jobs queue: no [letters]mailgun_private config value set.\")\n\t\t} else {\n\t\t\tlog.Info(\"Starting publish jobs queue...\")\n\t\t\tgo startPublishJobsQueue(apper.App())\n\t\t}\n\t}\n\n\t// Handle local timeline, if enabled\n\tif apper.App().cfg.App.LocalTimeline {\n\t\tlog.Info(\"Initializing local timeline...\")\n\t\tinitLocalTimeline(apper.App())\n\t}\n\n\treturn apper.App(), nil\n}\n\nfunc Serve(app *App, r *mux.Router) {\n\tlog.Info(\"Going to serve...\")\n\n\tisSingleUser = app.cfg.App.SingleUser\n\tapp.cfg.Server.Dev = debugging\n\n\t// Handle shutdown\n\tc := make(chan os.Signal, 2)\n\tsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-c\n\t\tlog.Info(\"Shutting down...\")\n\t\tshutdown(app)\n\t\tlog.Info(\"Done.\")\n\t\tos.Exit(0)\n\t}()\n\n\t// Start gopher server\n\tif app.cfg.Server.GopherPort > 0 && !app.cfg.App.Private {\n\t\tgo initGopher(app)\n\t}\n\n\t// Start web application server\n\tvar bindAddress = app.cfg.Server.Bind\n\tif bindAddress == \"\" {\n\t\tbindAddress = \"localhost\"\n\t}\n\tvar err error\n\tif app.cfg.IsSecureStandalone() {\n\t\tif app.cfg.Server.Autocert {\n\t\t\tm := &autocert.Manager{\n\t\t\t\tPrompt: autocert.AcceptTOS,\n\t\t\t\tCache:  autocert.DirCache(app.cfg.Server.TLSCertPath),\n\t\t\t}\n\t\t\thost, err := url.Parse(app.cfg.App.Host)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"[WARNING] Unable to parse configured host! %s\", err)\n\t\t\t\tlog.Error(`[WARNING] ALL hosts are allowed, which can open you to an attack where\nclients connect to a server by IP address and pretend to be asking for an\nincorrect host name, and cause you to reach the CA's rate limit for certificate\nrequests. We recommend supplying a valid host name.`)\n\t\t\t\tlog.Info(\"Using autocert on ANY host\")\n\t\t\t} else {\n\t\t\t\tlog.Info(\"Using autocert on host %s\", host.Host)\n\t\t\t\tm.HostPolicy = autocert.HostWhitelist(host.Host)\n\t\t\t}\n\t\t\ts := &http.Server{\n\t\t\t\tAddr:    \":https\",\n\t\t\t\tHandler: r,\n\t\t\t\tTLSConfig: &tls.Config{\n\t\t\t\t\tGetCertificate: m.GetCertificate,\n\t\t\t\t},\n\t\t\t}\n\t\t\ts.SetKeepAlivesEnabled(false)\n\n\t\t\tgo func() {\n\t\t\t\tlog.Info(\"Serving redirects on http://%s:80\", bindAddress)\n\t\t\t\terr = http.ListenAndServe(\":80\", m.HTTPHandler(nil))\n\t\t\t\tlog.Error(\"Unable to start redirect server: %v\", err)\n\t\t\t}()\n\n\t\t\tlog.Info(\"Serving on https://%s:443\", bindAddress)\n\t\t\tlog.Info(\"---\")\n\t\t\terr = s.ListenAndServeTLS(\"\", \"\")\n\t\t} else {\n\t\t\tgo func() {\n\t\t\t\tlog.Info(\"Serving redirects on http://%s:80\", bindAddress)\n\t\t\t\terr = http.ListenAndServe(fmt.Sprintf(\"%s:80\", bindAddress), http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\thttp.Redirect(w, r, app.cfg.App.Host, http.StatusMovedPermanently)\n\t\t\t\t}))\n\t\t\t\tlog.Error(\"Unable to start redirect server: %v\", err)\n\t\t\t}()\n\n\t\t\tlog.Info(\"Serving on https://%s:443\", bindAddress)\n\t\t\tlog.Info(\"Using manual certificates\")\n\t\t\tlog.Info(\"---\")\n\t\t\terr = http.ListenAndServeTLS(fmt.Sprintf(\"%s:443\", bindAddress), app.cfg.Server.TLSCertPath, app.cfg.Server.TLSKeyPath, r)\n\t\t}\n\t} else {\n\t\tnetwork := \"tcp\"\n\t\tprotocol := \"http\"\n\t\tif strings.HasPrefix(bindAddress, \"/\") {\n\t\t\tnetwork = \"unix\"\n\t\t\tprotocol = \"http+unix\"\n\n\t\t\t// old sockets will remain after server closes;\n\t\t\t// we need to delete them in order to open new ones\n\t\t\terr = os.Remove(bindAddress)\n\t\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\t\tlog.Error(\"%s already exists but could not be removed: %v\", bindAddress, err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t} else {\n\t\t\tbindAddress = fmt.Sprintf(\"%s:%d\", bindAddress, app.cfg.Server.Port)\n\t\t}\n\n\t\tlog.Info(\"Serving on %s://%s\", protocol, bindAddress)\n\t\tlog.Info(\"---\")\n\t\tlistener, err := net.Listen(network, bindAddress)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Could not bind to address: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tif network == \"unix\" {\n\t\t\terr = os.Chmod(bindAddress, 0o666)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Could not update socket permissions: %v\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\n\t\tdefer listener.Close()\n\t\terr = http.Serve(listener, r)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Unable to start: %v\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc (app *App) InitDecoder() {\n\t// TODO: do this at the package level, instead of the App level\n\t// Initialize modules\n\tapp.formDecoder = schema.NewDecoder()\n\tapp.formDecoder.RegisterConverter(converter.NullJSONString{}, converter.ConvertJSONNullString)\n\tapp.formDecoder.RegisterConverter(converter.NullJSONBool{}, converter.ConvertJSONNullBool)\n\tapp.formDecoder.RegisterConverter(sql.NullString{}, converter.ConvertSQLNullString)\n\tapp.formDecoder.RegisterConverter(sql.NullBool{}, converter.ConvertSQLNullBool)\n\tapp.formDecoder.RegisterConverter(sql.NullInt64{}, converter.ConvertSQLNullInt64)\n\tapp.formDecoder.RegisterConverter(sql.NullFloat64{}, converter.ConvertSQLNullFloat64)\n}\n\n// ConnectToDatabase validates and connects to the configured database, then\n// tests the connection.\nfunc ConnectToDatabase(app *App) error {\n\t// Check database configuration\n\tif app.cfg.Database.Type == driverMySQL && app.cfg.Database.User == \"\" {\n\t\treturn fmt.Errorf(\"Database user not set.\")\n\t}\n\tif app.cfg.Database.Host == \"\" {\n\t\tapp.cfg.Database.Host = \"localhost\"\n\t}\n\tif app.cfg.Database.Database == \"\" {\n\t\tapp.cfg.Database.Database = \"writefreely\"\n\t}\n\n\t// TODO: check err\n\tconnectToDatabase(app)\n\n\t// Test database connection\n\terr := app.db.Ping()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Database ping failed: %s\", err)\n\t}\n\n\treturn nil\n}\n\n// FormatVersion constructs the version string for the application\nfunc FormatVersion() string {\n\treturn serverSoftware + \" \" + softwareVer\n}\n\n// OutputVersion prints out the version of the application.\nfunc OutputVersion() {\n\tfmt.Println(FormatVersion())\n}\n\n// NewApp creates a new app instance.\nfunc NewApp(cfgFile string) *App {\n\treturn &App{\n\t\tcfgFile: cfgFile,\n\t}\n}\n\n// CreateConfig creates a default configuration and saves it to the app's cfgFile.\nfunc CreateConfig(app *App) error {\n\tlog.Info(\"Creating configuration...\")\n\tc := config.New()\n\tlog.Info(\"Saving configuration %s...\", app.cfgFile)\n\terr := config.Save(c, app.cfgFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to save configuration: %v\", err)\n\t}\n\treturn nil\n}\n\n// DoConfig runs the interactive configuration process.\nfunc DoConfig(app *App, configSections string) {\n\tif configSections == \"\" {\n\t\tconfigSections = \"server db app\"\n\t}\n\t// let's check there aren't any garbage in the list\n\tconfigSectionsArray := strings.Split(configSections, \" \")\n\tfor _, element := range configSectionsArray {\n\t\tif element != \"server\" && element != \"db\" && element != \"app\" {\n\t\t\tlog.Error(\"Invalid argument to --sections. Valid arguments are only \\\"server\\\", \\\"db\\\" and \\\"app\\\"\")\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\td, err := config.Configure(app.cfgFile, configSections)\n\tif err != nil {\n\t\tlog.Error(\"Unable to configure: %v\", err)\n\t\tos.Exit(1)\n\t}\n\tapp.cfg = d.Config\n\tconnectToDatabase(app)\n\tdefer shutdown(app)\n\n\tif !app.db.DatabaseInitialized() {\n\t\terr = adminInitDatabase(app)\n\t\tif err != nil {\n\t\t\tlog.Error(err.Error())\n\t\t\tos.Exit(1)\n\t\t}\n\t} else {\n\t\tlog.Info(\"Database already initialized.\")\n\t}\n\n\tif d.User != nil {\n\t\tu := &User{\n\t\t\tUsername:   d.User.Username,\n\t\t\tHashedPass: d.User.HashedPass,\n\t\t\tCreated:    time.Now().Truncate(time.Second).UTC(),\n\t\t}\n\n\t\t// Create blog\n\t\tlog.Info(\"Creating user %s...\\n\", u.Username)\n\t\terr = app.db.CreateUser(app.cfg, u, app.cfg.App.SiteName, \"\")\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to create user: %s\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tlog.Info(\"Done!\")\n\t}\n\tos.Exit(0)\n}\n\n// GenerateKeyFiles creates app encryption keys and saves them into the configured KeysParentDir.\nfunc GenerateKeyFiles(app *App) error {\n\t// Read keys path from config\n\tapp.LoadConfig()\n\n\t// Create keys dir if it doesn't exist yet\n\tfullKeysDir := filepath.Join(app.cfg.Server.KeysParentDir, keysDir)\n\tif _, err := os.Stat(fullKeysDir); os.IsNotExist(err) {\n\t\terr = os.Mkdir(fullKeysDir, 0700)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Generate keys\n\tinitKeyPaths(app)\n\t// TODO: use something like https://github.com/hashicorp/go-multierror to return errors\n\tvar keyErrs error\n\terr := generateKey(emailKeyPath)\n\tif err != nil {\n\t\tkeyErrs = err\n\t}\n\terr = generateKey(cookieAuthKeyPath)\n\tif err != nil {\n\t\tkeyErrs = err\n\t}\n\terr = generateKey(cookieKeyPath)\n\tif err != nil {\n\t\tkeyErrs = err\n\t}\n\terr = generateKey(csrfKeyPath)\n\tif err != nil {\n\t\tkeyErrs = err\n\t}\n\n\treturn keyErrs\n}\n\n// CreateSchema creates all database tables needed for the application.\nfunc CreateSchema(apper Apper) error {\n\tapper.LoadConfig()\n\tconnectToDatabase(apper.App())\n\tdefer shutdown(apper.App())\n\terr := adminInitDatabase(apper.App())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Migrate runs all necessary database migrations.\nfunc Migrate(apper Apper) error {\n\tapper.LoadConfig()\n\tconnectToDatabase(apper.App())\n\tdefer shutdown(apper.App())\n\n\terr := migrations.Migrate(migrations.NewDatastore(apper.App().db.DB, apper.App().db.driverName))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"migrate: %s\", err)\n\t}\n\treturn nil\n}\n\n// ResetPassword runs the interactive password reset process.\nfunc ResetPassword(apper Apper, username string) error {\n\t// Connect to the database\n\tapper.LoadConfig()\n\tconnectToDatabase(apper.App())\n\tdefer shutdown(apper.App())\n\n\t// Fetch user\n\tu, err := apper.App().db.GetUserForAuth(username)\n\tif err != nil {\n\t\tlog.Error(\"Get user: %s\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Prompt for new password\n\tprompt := promptui.Prompt{\n\t\tTemplates: &promptui.PromptTemplates{\n\t\t\tSuccess: \"{{ . | bold | faint }}: \",\n\t\t},\n\t\tLabel: \"New password\",\n\t\tMask:  '*',\n\t}\n\tnewPass, err := prompt.Run()\n\tif err != nil {\n\t\tlog.Error(\"%s\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Do the update\n\tlog.Info(\"Updating...\")\n\terr = adminResetPassword(apper.App(), u, newPass)\n\tif err != nil {\n\t\tlog.Error(\"%s\", err)\n\t\tos.Exit(1)\n\t}\n\tlog.Info(\"Success.\")\n\treturn nil\n}\n\n// DoDeleteAccount runs the confirmation and account delete process.\nfunc DoDeleteAccount(apper Apper, username string) error {\n\t// Connect to the database\n\tapper.LoadConfig()\n\tconnectToDatabase(apper.App())\n\tdefer shutdown(apper.App())\n\n\t// check user exists\n\tu, err := apper.App().db.GetUserForAuth(username)\n\tif err != nil {\n\t\tlog.Error(\"%s\", err)\n\t\tos.Exit(1)\n\t}\n\tuserID := u.ID\n\n\t// do not delete the admin account\n\t// TODO: check for other admins and skip?\n\tif u.IsAdmin() {\n\t\tlog.Error(\"Can not delete admin account\")\n\t\tos.Exit(1)\n\t}\n\n\t// confirm deletion, w/ w/out posts\n\tprompt := promptui.Prompt{\n\t\tTemplates: &promptui.PromptTemplates{\n\t\t\tSuccess: \"{{ . | bold | faint }}: \",\n\t\t},\n\t\tLabel:     fmt.Sprintf(\"Really delete user : %s\", username),\n\t\tIsConfirm: true,\n\t}\n\t_, err = prompt.Run()\n\tif err != nil {\n\t\tlog.Info(\"Aborted...\")\n\t\tos.Exit(0)\n\t}\n\n\tlog.Info(\"Deleting...\")\n\terr = apper.App().db.DeleteAccount(userID)\n\tif err != nil {\n\t\tlog.Error(\"%s\", err)\n\t\tos.Exit(1)\n\t}\n\tlog.Info(\"Success.\")\n\treturn nil\n}\n\nfunc connectToDatabase(app *App) {\n\tlog.Info(\"Connecting to %s database...\", app.cfg.Database.Type)\n\n\tvar db *sql.DB\n\tvar err error\n\tif app.cfg.Database.Type == driverMySQL {\n\t\tdb, err = sql.Open(app.cfg.Database.Type, fmt.Sprintf(\"%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=true&loc=%s&tls=%t\", app.cfg.Database.User, app.cfg.Database.Password, app.cfg.Database.Host, app.cfg.Database.Port, app.cfg.Database.Database, url.QueryEscape(time.Local.String()), app.cfg.Database.TLS))\n\t\tdb.SetMaxOpenConns(50)\n\t} else if app.cfg.Database.Type == driverSQLite {\n\t\tif !SQLiteEnabled {\n\t\t\tlog.Error(\"Invalid database type '%s'. Binary wasn't compiled with SQLite3 support.\", app.cfg.Database.Type)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif app.cfg.Database.FileName == \"\" {\n\t\t\tlog.Error(\"SQLite database filename value in config.ini is empty.\")\n\t\t\tos.Exit(1)\n\t\t}\n\t\tdb, err = sql.Open(\"sqlite3_with_regex\", app.cfg.Database.FileName+\"?parseTime=true&cached=shared\")\n\t\tdb.SetMaxOpenConns(2)\n\t} else {\n\t\tlog.Error(\"Invalid database type '%s'. Only 'mysql' and 'sqlite3' are supported right now.\", app.cfg.Database.Type)\n\t\tos.Exit(1)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"%s\", err)\n\t\tos.Exit(1)\n\t}\n\tapp.db = &datastore{db, app.cfg.Database.Type}\n}\n\nfunc shutdown(app *App) {\n\tlog.Info(\"Closing database connection...\")\n\tapp.db.Close()\n\tif strings.HasPrefix(app.cfg.Server.Bind, \"/\") {\n\t\t// Clean up socket\n\t\tlog.Info(\"Removing socket file...\")\n\t\terr := os.Remove(app.cfg.Server.Bind)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to remove socket: %s\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tlog.Info(\"Success.\")\n\t}\n}\n\n// CreateUser creates a new admin or normal user from the given credentials.\nfunc CreateUser(apper Apper, username, password string, isAdmin bool) error {\n\t// Create an admin user with --create-admin\n\tapper.LoadConfig()\n\tconnectToDatabase(apper.App())\n\tdefer shutdown(apper.App())\n\n\t// Ensure an admin / first user doesn't already exist\n\tfirstUser, _ := apper.App().db.GetUserByID(1)\n\tif isAdmin {\n\t\t// Abort if trying to create admin user, but one already exists\n\t\tif firstUser != nil {\n\t\t\treturn fmt.Errorf(\"Admin user already exists (%s). Create a regular user with: writefreely user create [USER]:[PASSWORD]\", firstUser.Username)\n\t\t}\n\t} else {\n\t\t// Abort if trying to create regular user, but no admin exists yet\n\t\tif firstUser == nil {\n\t\t\treturn fmt.Errorf(\"No admin user exists yet. Create an admin first with: writefreely user create --admin [USER]:[PASSWORD]\")\n\t\t}\n\t}\n\n\t// Create the user\n\t// Normalize and validate username\n\tdesiredUsername := username\n\tusername = getSlug(username, \"\")\n\n\tusernameDesc := username\n\tif username != desiredUsername {\n\t\tusernameDesc += \" (originally: \" + desiredUsername + \")\"\n\t}\n\n\tif !author.IsValidUsername(apper.App().cfg, username) {\n\t\treturn fmt.Errorf(\"Username %s is invalid, reserved, or shorter than configured minimum length (%d characters).\", usernameDesc, apper.App().cfg.App.MinUsernameLen)\n\t}\n\n\t// Hash the password\n\thashedPass, err := auth.HashPass([]byte(password))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to hash password: %v\", err)\n\t}\n\n\tu := &User{\n\t\tUsername:   username,\n\t\tHashedPass: hashedPass,\n\t\tCreated:    time.Now().Truncate(time.Second).UTC(),\n\t}\n\n\tuserType := \"user\"\n\tif isAdmin {\n\t\tuserType = \"admin\"\n\t}\n\tlog.Info(\"Creating %s %s...\", userType, usernameDesc)\n\terr = apper.App().db.CreateUser(apper.App().Config(), u, desiredUsername, \"\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to create user: %s\", err)\n\t}\n\tlog.Info(\"Done!\")\n\treturn nil\n}\n\n//go:embed schema.sql\nvar schemaSql string\n\n//go:embed sqlite.sql\nvar sqliteSql string\n\nfunc adminInitDatabase(app *App) error {\n\tvar schema string\n\tif app.cfg.Database.Type == driverSQLite {\n\t\tschema = sqliteSql\n\t} else {\n\t\tschema = schemaSql\n\t}\n\n\ttblReg := regexp.MustCompile(\"CREATE TABLE (IF NOT EXISTS )?`([a-z_]+)`\")\n\n\tqueries := strings.Split(string(schema), \";\\n\")\n\tfor _, q := range queries {\n\t\tif strings.TrimSpace(q) == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tparts := tblReg.FindStringSubmatch(q)\n\t\tif len(parts) >= 3 {\n\t\t\tlog.Info(\"Creating table %s...\", parts[2])\n\t\t} else {\n\t\t\tlog.Info(\"Creating table ??? (Weird query) No match in: %v\", parts)\n\t\t}\n\t\t_, err := app.db.Exec(q)\n\t\tif err != nil {\n\t\t\tlog.Error(\"%s\", err)\n\t\t} else {\n\t\t\tlog.Info(\"Created.\")\n\t\t}\n\t}\n\n\t// Set up migrations table\n\tlog.Info(\"Initializing appmigrations table...\")\n\terr := migrations.SetInitialMigrations(migrations.NewDatastore(app.db.DB, app.db.driverName))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to set initial migrations: %v\", err)\n\t}\n\n\tlog.Info(\"Running migrations...\")\n\terr = migrations.Migrate(migrations.NewDatastore(app.db.DB, app.db.driverName))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"migrate: %s\", err)\n\t}\n\n\tlog.Info(\"Done.\")\n\treturn nil\n}\n\n// ServerUserAgent returns a User-Agent string to use in external requests. The\n// hostName parameter may be left empty.\nfunc ServerUserAgent(hostName string) string {\n\thostUAStr := \"\"\n\tif hostName != \"\" {\n\t\thostUAStr = \"; +\" + hostName\n\t}\n\treturn \"Go (\" + serverSoftware + \"/\" + softwareVer + hostUAStr + \")\"\n}\n"
        },
        {
          "name": "appstats",
          "type": "tree",
          "content": null
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 0.822265625,
          "content": "/*\n * Copyright © 2018 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\n// AuthenticateUser ensures a user with the given accessToken is valid. Call\n// it before any operations that require authentication or optionally associate\n// data with a user account.\n// Returns an error if the given accessToken is invalid. Otherwise the\n// associated user ID is returned.\nfunc AuthenticateUser(db writestore, accessToken string) (int64, error) {\n\tif accessToken == \"\" {\n\t\treturn 0, ErrNoAccessToken\n\t}\n\tuserID := db.GetUserID(accessToken)\n\tif userID == -1 {\n\t\treturn 0, ErrBadAccessToken\n\t}\n\n\treturn userID, nil\n}\n"
        },
        {
          "name": "author",
          "type": "tree",
          "content": null
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 1.2021484375,
          "content": "/*\n * Copyright © 2018 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\nconst (\n\tpostsCacheTime = 4 * time.Second\n)\n\ntype (\n\tpostsCacheItem struct {\n\t\tExpire time.Time\n\t\tPosts  *[]PublicPost\n\t\tready  chan struct{}\n\t}\n\n\tAuthCache struct {\n\t\tAlias, Pass, Token string\n\t\tBadPasses          map[string]bool\n\n\t\texpire time.Time\n\t}\n)\n\nvar (\n\tuserPostsCache = struct {\n\t\tsync.RWMutex\n\t\tusers map[int64]postsCacheItem\n\t}{\n\t\tusers: map[int64]postsCacheItem{},\n\t}\n)\n\nfunc CachePosts(userID int64, p *[]PublicPost) {\n\tclose(userPostsCache.users[userID].ready)\n\tuserPostsCache.Lock()\n\tuserPostsCache.users[userID] = postsCacheItem{\n\t\tExpire: time.Now().Add(postsCacheTime),\n\t\tPosts:  p,\n\t}\n\tuserPostsCache.Unlock()\n}\n\nfunc GetPostsCache(userID int64) *[]PublicPost {\n\tuserPostsCache.RLock()\n\tpci, ok := userPostsCache.users[userID]\n\tuserPostsCache.RUnlock()\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tif pci.Expire.Before(time.Now()) {\n\t\t// Cache is expired\n\t\treturn nil\n\t}\n\treturn pci.Posts\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "collections.go",
          "type": "blob",
          "size": 38.330078125,
          "content": "/*\n * Copyright © 2018-2022 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"math\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/gorilla/mux\"\n\tstripmd \"github.com/writeas/go-strip-markdown/v2\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/activitystreams\"\n\t\"github.com/writeas/web-core/auth\"\n\t\"github.com/writeas/web-core/bots\"\n\t\"github.com/writeas/web-core/i18n\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writeas/web-core/posts\"\n\t\"github.com/writefreely/writefreely/author\"\n\t\"github.com/writefreely/writefreely/config\"\n\t\"github.com/writefreely/writefreely/page\"\n\t\"github.com/writefreely/writefreely/spam\"\n\t\"golang.org/x/net/idna\"\n)\n\nconst (\n\tcollAttrLetterReplyTo = \"letter_reply_to\"\n\n\tcollMaxLengthTitle       = 255\n\tcollMaxLengthDescription = 160\n)\n\ntype (\n\t// TODO: add Direction to db\n\t// TODO: add Language to db\n\tCollection struct {\n\t\tID          int64          `datastore:\"id\" json:\"-\"`\n\t\tAlias       string         `datastore:\"alias\" schema:\"alias\" json:\"alias\"`\n\t\tTitle       string         `datastore:\"title\" schema:\"title\" json:\"title\"`\n\t\tDescription string         `datastore:\"description\" schema:\"description\" json:\"description\"`\n\t\tDirection   string         `schema:\"dir\" json:\"dir,omitempty\"`\n\t\tLanguage    string         `schema:\"lang\" json:\"lang,omitempty\"`\n\t\tStyleSheet  string         `datastore:\"style_sheet\" schema:\"style_sheet\" json:\"style_sheet\"`\n\t\tScript      string         `datastore:\"script\" schema:\"script\" json:\"script,omitempty\"`\n\t\tSignature   string         `datastore:\"post_signature\" schema:\"signature\" json:\"-\"`\n\t\tPublic      bool           `datastore:\"public\" json:\"public\"`\n\t\tVisibility  collVisibility `datastore:\"private\" json:\"-\"`\n\t\tFormat      string         `datastore:\"format\" json:\"format,omitempty\"`\n\t\tViews       int64          `json:\"views\"`\n\t\tOwnerID     int64          `datastore:\"owner_id\" json:\"-\"`\n\t\tPublicOwner bool           `datastore:\"public_owner\" json:\"-\"`\n\t\tURL         string         `json:\"url,omitempty\"`\n\n\t\tMonetization string `json:\"monetization_pointer,omitempty\"`\n\t\tVerification string `json:\"verification_link\"`\n\n\t\tdb       *datastore\n\t\thostName string\n\t}\n\tCollectionObj struct {\n\t\tCollection\n\t\tTotalPosts int           `json:\"total_posts\"`\n\t\tOwner      *User         `json:\"owner,omitempty\"`\n\t\tPosts      *[]PublicPost `json:\"posts,omitempty\"`\n\t\tFormat     *CollectionFormat\n\t}\n\tDisplayCollection struct {\n\t\t*CollectionObj\n\t\tPrefix      string\n\t\tNavSuffix   string\n\t\tIsTopLevel  bool\n\t\tCurrentPage int\n\t\tTotalPages  int\n\t\tSilenced    bool\n\t}\n\n\tCollectionNav struct {\n\t\t*Collection\n\t\tPath       string\n\t\tSingleUser bool\n\t\tCanPost    bool\n\t}\n\n\tSubmittedCollection struct {\n\t\t// Data used for updating a given collection\n\t\tID      int64\n\t\tOwnerID uint64\n\n\t\t// Form helpers\n\t\tPreferURL string `schema:\"prefer_url\" json:\"prefer_url\"`\n\t\tPrivacy   int    `schema:\"privacy\" json:\"privacy\"`\n\t\tPass      string `schema:\"password\" json:\"password\"`\n\t\tMathJax   bool   `schema:\"mathjax\" json:\"mathjax\"`\n\t\tEmailSubs bool   `schema:\"email_subs\" json:\"email_subs\"`\n\t\tHandle    string `schema:\"handle\" json:\"handle\"`\n\n\t\t// Actual collection values updated in the DB\n\t\tAlias        *string         `schema:\"alias\" json:\"alias\"`\n\t\tTitle        *string         `schema:\"title\" json:\"title\"`\n\t\tDescription  *string         `schema:\"description\" json:\"description\"`\n\t\tStyleSheet   *string         `schema:\"style_sheet\" json:\"style_sheet\"`\n\t\tScript       *string         `schema:\"script\" json:\"script\"`\n\t\tSignature    *string         `schema:\"signature\" json:\"signature\"`\n\t\tMonetization *string         `schema:\"monetization_pointer\" json:\"monetization_pointer\"`\n\t\tVerification *string         `schema:\"verification_link\" json:\"verification_link\"`\n\t\tLetterReply  *string         `schema:\"letter_reply\" json:\"letter_reply\"`\n\t\tVisibility   *int            `schema:\"visibility\" json:\"public\"`\n\t\tFormat       *sql.NullString `schema:\"format\" json:\"format\"`\n\t}\n\tCollectionFormat struct {\n\t\tFormat string\n\t}\n\n\tcollectionReq struct {\n\t\t// Information about the collection request itself\n\t\tprefix, alias, domain string\n\t\tisCustomDomain        bool\n\n\t\t// User-related fields\n\t\tisCollOwner bool\n\n\t\tisAuthorized bool\n\t}\n)\n\nfunc (sc *SubmittedCollection) FediverseHandle() string {\n\tif sc.Handle == \"\" {\n\t\treturn apCustomHandleDefault\n\t}\n\treturn getSlug(sc.Handle, \"\")\n}\n\n// collVisibility represents the visibility level for the collection.\ntype collVisibility int\n\n// Visibility levels. Values are bitmasks, stored in the database as\n// decimal numbers. If adding types, append them to this list. If removing,\n// replace the desired visibility with a new value.\nconst CollUnlisted collVisibility = 0\nconst (\n\tCollPublic collVisibility = 1 << iota\n\tCollPrivate\n\tCollProtected\n)\n\nvar collVisibilityStrings = map[string]collVisibility{\n\t\"unlisted\":  CollUnlisted,\n\t\"public\":    CollPublic,\n\t\"private\":   CollPrivate,\n\t\"protected\": CollProtected,\n}\n\nfunc defaultVisibility(cfg *config.Config) collVisibility {\n\tvis, ok := collVisibilityStrings[cfg.App.DefaultVisibility]\n\tif !ok {\n\t\tvis = CollUnlisted\n\t}\n\treturn vis\n}\n\nfunc (cf *CollectionFormat) Ascending() bool {\n\treturn cf.Format == \"novel\"\n}\nfunc (cf *CollectionFormat) ShowDates() bool {\n\treturn cf.Format == \"blog\"\n}\nfunc (cf *CollectionFormat) PostsPerPage() int {\n\tif cf.Format == \"novel\" {\n\t\treturn postsPerPage\n\t}\n\treturn postsPerPage\n}\n\n// Valid returns whether or not a format value is valid.\nfunc (cf *CollectionFormat) Valid() bool {\n\treturn cf.Format == \"blog\" ||\n\t\tcf.Format == \"novel\" ||\n\t\tcf.Format == \"notebook\"\n}\n\n// NewFormat creates a new CollectionFormat object from the Collection.\nfunc (c *Collection) NewFormat() *CollectionFormat {\n\tcf := &CollectionFormat{Format: c.Format}\n\n\t// Fill in default format\n\tif cf.Format == \"\" {\n\t\tcf.Format = \"blog\"\n\t}\n\n\treturn cf\n}\n\nfunc (c *Collection) IsInstanceColl() bool {\n\tur, _ := url.Parse(c.hostName)\n\treturn c.Alias == ur.Host\n}\n\nfunc (c *Collection) IsUnlisted() bool {\n\treturn c.Visibility == 0\n}\n\nfunc (c *Collection) IsPrivate() bool {\n\treturn c.Visibility&CollPrivate != 0\n}\n\nfunc (c *Collection) IsProtected() bool {\n\treturn c.Visibility&CollProtected != 0\n}\n\nfunc (c *Collection) IsPublic() bool {\n\treturn c.Visibility&CollPublic != 0\n}\n\nfunc (c *Collection) FriendlyVisibility() string {\n\tif c.IsPrivate() {\n\t\treturn \"Private\"\n\t}\n\tif c.IsPublic() {\n\t\treturn \"Public\"\n\t}\n\tif c.IsProtected() {\n\t\treturn \"Password-protected\"\n\t}\n\treturn \"Unlisted\"\n}\n\nfunc (c *Collection) ShowFooterBranding() bool {\n\t// TODO: implement this setting\n\treturn true\n}\n\n// CanonicalURL returns a fully-qualified URL to the collection.\nfunc (c *Collection) CanonicalURL() string {\n\treturn c.RedirectingCanonicalURL(false)\n}\n\nfunc (c *Collection) DisplayCanonicalURL() string {\n\tus := c.CanonicalURL()\n\tu, err := url.Parse(us)\n\tif err != nil {\n\t\treturn us\n\t}\n\tp := u.Path\n\tif p == \"/\" {\n\t\tp = \"\"\n\t}\n\td := u.Hostname()\n\td, _ = idna.ToUnicode(d)\n\treturn d + p\n}\n\n// RedirectingCanonicalURL returns the fully-qualified canonical URL for the Collection, with a trailing slash. The\n// hostName field needs to be populated for this to work correctly.\nfunc (c *Collection) RedirectingCanonicalURL(isRedir bool) string {\n\tif c.hostName == \"\" {\n\t\t// If this is true, the human programmers screwed up. So ask for a bug report and fail, fail, fail\n\t\tlog.Error(\"[PROGRAMMER ERROR] WARNING: Collection.hostName is empty! Federation and many other things will fail! If you're seeing this in the wild, please report this bug and let us know what you were doing just before this: https://github.com/writefreely/writefreely/issues/new?template=bug_report.md\")\n\t}\n\tif isSingleUser {\n\t\treturn c.hostName + \"/\"\n\t}\n\n\treturn fmt.Sprintf(\"%s/%s/\", c.hostName, c.Alias)\n}\n\n// PrevPageURL provides a full URL for the previous page of collection posts,\n// returning a /page/N result for pages >1\nfunc (c *Collection) PrevPageURL(prefix, navSuffix string, n int, tl bool) string {\n\tu := \"\"\n\tif n == 2 {\n\t\t// Previous page is 1; no need for /page/ prefix\n\t\tif prefix == \"\" {\n\t\t\tu = navSuffix + \"/\"\n\t\t}\n\t\t// Else leave off trailing slash\n\t} else {\n\t\tu = fmt.Sprintf(\"%s/page/%d\", navSuffix, n-1)\n\t}\n\n\tif tl {\n\t\treturn u\n\t}\n\treturn \"/\" + prefix + c.Alias + u\n}\n\n// NextPageURL provides a full URL for the next page of collection posts\nfunc (c *Collection) NextPageURL(prefix, navSuffix string, n int, tl bool) string {\n\n\tif tl {\n\t\treturn fmt.Sprintf(\"%s/page/%d\", navSuffix, n+1)\n\t}\n\treturn fmt.Sprintf(\"/%s%s%s/page/%d\", prefix, c.Alias, navSuffix, n+1)\n}\n\nfunc (c *Collection) DisplayTitle() string {\n\tif c.Title != \"\" {\n\t\treturn c.Title\n\t}\n\treturn c.Alias\n}\n\nfunc (c *Collection) StyleSheetDisplay() template.CSS {\n\treturn template.CSS(c.StyleSheet)\n}\n\n// ForPublic modifies the Collection for public consumption, such as via\n// the API.\nfunc (c *Collection) ForPublic() {\n\tc.URL = c.CanonicalURL()\n}\n\nvar isAvatarChar = regexp.MustCompile(\"[a-z0-9]\").MatchString\n\nfunc (c *Collection) PersonObject(ids ...int64) *activitystreams.Person {\n\taccountRoot := c.FederatedAccount()\n\tp := activitystreams.NewPerson(accountRoot)\n\tp.URL = c.CanonicalURL()\n\tuname := c.Alias\n\tp.PreferredUsername = uname\n\tp.Name = c.DisplayTitle()\n\tp.Summary = c.Description\n\tif p.Name != \"\" {\n\t\tif av := c.AvatarURL(); av != \"\" {\n\t\t\tp.Icon = activitystreams.Image{\n\t\t\t\tType:      \"Image\",\n\t\t\t\tMediaType: \"image/png\",\n\t\t\t\tURL:       av,\n\t\t\t}\n\t\t}\n\t}\n\n\tcollID := c.ID\n\tif len(ids) > 0 {\n\t\tcollID = ids[0]\n\t}\n\tpub, priv := c.db.GetAPActorKeys(collID)\n\tif pub != nil {\n\t\tp.AddPubKey(pub)\n\t\tp.SetPrivKey(priv)\n\t}\n\n\treturn p\n}\n\nfunc (c *Collection) AvatarURL() string {\n\tfl := string(unicode.ToLower([]rune(c.DisplayTitle())[0]))\n\tif !isAvatarChar(fl) {\n\t\treturn \"\"\n\t}\n\treturn c.hostName + \"/img/avatars/\" + fl + \".png\"\n}\n\nfunc (c *Collection) FederatedAPIBase() string {\n\treturn c.hostName + \"/\"\n}\n\nfunc (c *Collection) FederatedAccount() string {\n\taccountUser := c.Alias\n\treturn c.FederatedAPIBase() + \"api/collections/\" + accountUser\n}\n\nfunc (c *Collection) RenderMathJax() bool {\n\treturn c.db.CollectionHasAttribute(c.ID, \"render_mathjax\")\n}\n\nfunc (c *Collection) EmailSubsEnabled() bool {\n\treturn c.db.CollectionHasAttribute(c.ID, \"email_subs\")\n}\n\nfunc (c *Collection) MonetizationURL() string {\n\tif c.Monetization == \"\" {\n\t\treturn \"\"\n\t}\n\treturn strings.Replace(c.Monetization, \"$\", \"https://\", 1)\n}\n\n// DisplayDescription returns the description with rendered Markdown and HTML.\nfunc (c *Collection) DisplayDescription() *template.HTML {\n\tif c.Description == \"\" {\n\t\ts := template.HTML(\"\")\n\t\treturn &s\n\t}\n\tt := template.HTML(posts.ApplyBasicAccessibleMarkdown([]byte(c.Description)))\n\treturn &t\n}\n\n// PlainDescription returns the description with all Markdown and HTML removed.\nfunc (c *Collection) PlainDescription() string {\n\tif c.Description == \"\" {\n\t\treturn \"\"\n\t}\n\tdesc := stripHTMLWithoutEscaping(c.Description)\n\tdesc = stripmd.Strip(desc)\n\treturn desc\n}\n\nfunc (c CollectionPage) DisplayMonetization() string {\n\treturn displayMonetization(c.Monetization, c.Alias)\n}\n\nfunc (c *DisplayCollection) Direction() string {\n\tif c.Language == \"\" {\n\t\treturn \"auto\"\n\t}\n\tif i18n.LangIsRTL(c.Language) {\n\t\treturn \"rtl\"\n\t}\n\treturn \"ltr\"\n}\n\nfunc newCollection(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\talias := r.FormValue(\"alias\")\n\ttitle := r.FormValue(\"title\")\n\n\tvar missingParams, accessToken string\n\tvar u *User\n\tc := struct {\n\t\tAlias string `json:\"alias\" schema:\"alias\"`\n\t\tTitle string `json:\"title\" schema:\"title\"`\n\t\tWeb   bool   `json:\"web\" schema:\"web\"`\n\t}{}\n\tif reqJSON {\n\t\t// Decode JSON request\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr := decoder.Decode(&c)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse post update JSON request: %v\\n\", err)\n\t\t\treturn ErrBadJSON\n\t\t}\n\t} else {\n\t\t// TODO: move form parsing to formDecoder\n\t\tc.Alias = alias\n\t\tc.Title = title\n\t}\n\n\tif c.Alias == \"\" {\n\t\tif c.Title != \"\" {\n\t\t\t// If only a title was given, just use it to generate the alias.\n\t\t\tc.Alias = getSlug(c.Title, \"\")\n\t\t} else {\n\t\t\tmissingParams += \"`alias` \"\n\t\t}\n\t}\n\tif c.Title == \"\" {\n\t\tmissingParams += \"`title` \"\n\t}\n\tif missingParams != \"\" {\n\t\treturn impart.HTTPError{http.StatusBadRequest, fmt.Sprintf(\"Parameter(s) %srequired.\", missingParams)}\n\t}\n\n\tvar userID int64\n\tvar err error\n\tif reqJSON && !c.Web {\n\t\taccessToken = r.Header.Get(\"Authorization\")\n\t\tif accessToken == \"\" {\n\t\t\treturn ErrNoAccessToken\n\t\t}\n\t\tuserID = app.db.GetUserID(accessToken)\n\t\tif userID == -1 {\n\t\t\treturn ErrBadAccessToken\n\t\t}\n\t} else {\n\t\tu = getUserSession(app, r)\n\t\tif u == nil {\n\t\t\treturn ErrNotLoggedIn\n\t\t}\n\t\tuserID = u.ID\n\t}\n\tsilenced, err := app.db.IsUserSilenced(userID)\n\tif err != nil {\n\t\tlog.Error(\"new collection: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\tif silenced {\n\t\treturn ErrUserSilenced\n\t}\n\n\tif !author.IsValidUsername(app.cfg, c.Alias) {\n\t\treturn impart.HTTPError{http.StatusPreconditionFailed, \"Collection alias isn't valid.\"}\n\t}\n\n\tcoll, err := app.db.CreateCollection(app.cfg, c.Alias, c.Title, userID)\n\tif err != nil {\n\t\t// TODO: handle this\n\t\treturn err\n\t}\n\n\tres := &CollectionObj{Collection: *coll}\n\n\tif reqJSON {\n\t\treturn impart.WriteSuccess(w, res, http.StatusCreated)\n\t}\n\tredirectTo := \"/me/c/\"\n\t// TODO: redirect to pad when necessary\n\treturn impart.HTTPError{http.StatusFound, redirectTo}\n}\n\nfunc apiCheckCollectionPermissions(app *App, r *http.Request, c *Collection) (int64, error) {\n\taccessToken := r.Header.Get(\"Authorization\")\n\tvar userID int64 = -1\n\tif accessToken != \"\" {\n\t\tuserID = app.db.GetUserID(accessToken)\n\t}\n\tisCollOwner := userID == c.OwnerID\n\tif c.IsPrivate() && !isCollOwner {\n\t\t// Collection is private, but user isn't authenticated\n\t\treturn -1, ErrCollectionNotFound\n\t}\n\tif c.IsProtected() {\n\t\t// TODO: check access token\n\t\treturn -1, ErrCollectionUnauthorizedRead\n\t}\n\n\treturn userID, nil\n}\n\n// fetchCollection handles the API endpoint for retrieving collection data.\nfunc fetchCollection(app *App, w http.ResponseWriter, r *http.Request) error {\n\tif IsActivityPubRequest(r) {\n\t\treturn handleFetchCollectionActivities(app, w, r)\n\t}\n\n\tvars := mux.Vars(r)\n\talias := vars[\"alias\"]\n\n\t// TODO: move this logic into a common getCollection function\n\t// Get base Collection data\n\tc, err := app.db.GetCollection(alias)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\t// Redirect users who aren't requesting JSON\n\treqJSON := IsJSON(r)\n\tif !reqJSON {\n\t\treturn impart.HTTPError{http.StatusFound, c.CanonicalURL()}\n\t}\n\n\t// Check permissions\n\tuserID, err := apiCheckCollectionPermissions(app, r, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\tisCollOwner := userID == c.OwnerID\n\n\t// Fetch extra data about the Collection\n\tres := &CollectionObj{Collection: *c}\n\tif c.PublicOwner {\n\t\tu, err := app.db.GetUserByID(res.OwnerID)\n\t\tif err != nil {\n\t\t\t// Log the error and just continue\n\t\t\tlog.Error(\"Error getting user for collection: %v\", err)\n\t\t} else {\n\t\t\tres.Owner = u\n\t\t}\n\t}\n\t// TODO: check status for silenced\n\tapp.db.GetPostsCount(res, isCollOwner)\n\t// Strip non-public information\n\tres.Collection.ForPublic()\n\n\treturn impart.WriteSuccess(w, res, http.StatusOK)\n}\n\n// fetchCollectionPosts handles an API endpoint for retrieving a collection's\n// posts.\nfunc fetchCollectionPosts(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\talias := vars[\"alias\"]\n\n\tc, err := app.db.GetCollection(alias)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\t// Check permissions\n\tuserID, err := apiCheckCollectionPermissions(app, r, c)\n\tif err != nil {\n\t\treturn err\n\t}\n\tisCollOwner := userID == c.OwnerID\n\n\t// Get page\n\tpage := 1\n\tif p := r.FormValue(\"page\"); p != \"\" {\n\t\tpInt, _ := strconv.Atoi(p)\n\t\tif pInt > 0 {\n\t\t\tpage = pInt\n\t\t}\n\t}\n\n\tps, err := app.db.GetPosts(app.cfg, c, page, isCollOwner, false, false)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcoll := &CollectionObj{Collection: *c, Posts: ps}\n\tapp.db.GetPostsCount(coll, isCollOwner)\n\t// Strip non-public information\n\tcoll.Collection.ForPublic()\n\n\t// Transform post bodies if needed\n\tif r.FormValue(\"body\") == \"html\" {\n\t\tfor _, p := range *coll.Posts {\n\t\t\tp.Content = posts.ApplyMarkdown([]byte(p.Content))\n\t\t}\n\t}\n\n\treturn impart.WriteSuccess(w, coll, http.StatusOK)\n}\n\ntype CollectionPage struct {\n\tpage.StaticPage\n\t*DisplayCollection\n\tIsCustomDomain bool\n\tIsWelcome      bool\n\tIsOwner        bool\n\tIsCollLoggedIn bool\n\tHoneypot       string\n\tIsSubscriber   bool\n\tCanPin         bool\n\tUsername       string\n\tMonetization   string\n\tFlash          template.HTML\n\tCollections    *[]Collection\n\tPinnedPosts    *[]PublicPost\n\n\tIsAdmin   bool\n\tCanInvite bool\n\n\t// Helper field for Chorus mode\n\tCollAlias string\n}\n\ntype TagCollectionPage struct {\n\tCollectionPage\n\tTag string\n}\n\nfunc (tcp TagCollectionPage) PrevPageURL(prefix string, n int, tl bool) string {\n\tu := fmt.Sprintf(\"/tag:%s\", tcp.Tag)\n\tif n > 2 {\n\t\tu += fmt.Sprintf(\"/page/%d\", n-1)\n\t}\n\tif tl {\n\t\treturn u\n\t}\n\treturn \"/\" + prefix + tcp.Alias + u\n\n}\n\nfunc (tcp TagCollectionPage) NextPageURL(prefix string, n int, tl bool) string {\n\tif tl {\n\t\treturn fmt.Sprintf(\"/tag:%s/page/%d\", tcp.Tag, n+1)\n\t}\n\treturn fmt.Sprintf(\"/%s%s/tag:%s/page/%d\", prefix, tcp.Alias, tcp.Tag, n+1)\n}\n\nfunc NewCollectionObj(c *Collection) *CollectionObj {\n\treturn &CollectionObj{\n\t\tCollection: *c,\n\t\tFormat:     c.NewFormat(),\n\t}\n}\n\nfunc (c *CollectionObj) ScriptDisplay() template.JS {\n\treturn template.JS(c.Script)\n}\n\nvar jsSourceCommentReg = regexp.MustCompile(\"(?m)^// src:(.+)$\")\n\nfunc (c *CollectionObj) ExternalScripts() []template.URL {\n\tscripts := []template.URL{}\n\tif c.Script == \"\" {\n\t\treturn scripts\n\t}\n\n\tmatches := jsSourceCommentReg.FindAllStringSubmatch(c.Script, -1)\n\tfor _, m := range matches {\n\t\tscripts = append(scripts, template.URL(strings.TrimSpace(m[1])))\n\t}\n\treturn scripts\n}\n\nfunc (c *CollectionObj) CanShowScript() bool {\n\treturn false\n}\n\nfunc processCollectionRequest(cr *collectionReq, vars map[string]string, w http.ResponseWriter, r *http.Request) error {\n\tcr.prefix = vars[\"prefix\"]\n\tcr.alias = vars[\"collection\"]\n\t// Normalize the URL, redirecting user to consistent post URL\n\tif cr.alias != strings.ToLower(cr.alias) {\n\t\treturn impart.HTTPError{http.StatusMovedPermanently, fmt.Sprintf(\"/%s/\", strings.ToLower(cr.alias))}\n\t}\n\n\treturn nil\n}\n\n// processCollectionPermissions checks the permissions for the given\n// collectionReq, returning a Collection if access is granted; otherwise this\n// renders any necessary collection pages, for example, if requesting a custom\n// domain that doesn't yet have a collection associated, or if a collection\n// requires a password. In either case, this will return nil, nil -- thus both\n// values should ALWAYS be checked to determine whether or not to continue.\nfunc processCollectionPermissions(app *App, cr *collectionReq, u *User, w http.ResponseWriter, r *http.Request) (*Collection, error) {\n\t// Display collection if this is a collection\n\tvar c *Collection\n\tvar err error\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(cr.alias)\n\t}\n\t// TODO: verify we don't reveal the existence of a private collection with redirection\n\tif err != nil {\n\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\tif err.Status == http.StatusNotFound {\n\t\t\t\tif cr.isCustomDomain {\n\t\t\t\t\t// User is on the site from a custom domain\n\t\t\t\t\t//tErr := pages[\"404-domain.tmpl\"].ExecuteTemplate(w, \"base\", pageForHost(page.StaticPage{}, r))\n\t\t\t\t\t//if tErr != nil {\n\t\t\t\t\t//log.Error(\"Unable to render 404-domain page: %v\", err)\n\t\t\t\t\t//}\n\t\t\t\t\treturn nil, nil\n\t\t\t\t}\n\t\t\t\tif len(cr.alias) >= minIDLen && len(cr.alias) <= maxIDLen {\n\t\t\t\t\t// Alias is within post ID range, so just be sure this isn't a post\n\t\t\t\t\tif app.db.PostIDExists(cr.alias) {\n\t\t\t\t\t\t// TODO: use StatusFound for vanity post URLs when we implement them\n\t\t\t\t\t\treturn nil, impart.HTTPError{http.StatusMovedPermanently, \"/\" + cr.alias}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Redirect if necessary\n\t\t\t\tnewAlias := app.db.GetCollectionRedirect(cr.alias)\n\t\t\t\tif newAlias != \"\" {\n\t\t\t\t\treturn nil, impart.HTTPError{http.StatusFound, \"/\" + newAlias + \"/\"}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil, err\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\t// Update CollectionRequest to reflect owner status\n\tcr.isCollOwner = u != nil && u.ID == c.OwnerID\n\n\t// Check permissions\n\tif !cr.isCollOwner {\n\t\tif c.IsPrivate() {\n\t\t\treturn nil, ErrCollectionNotFound\n\t\t} else if c.IsProtected() {\n\t\t\tuname := \"\"\n\t\t\tif u != nil {\n\t\t\t\tuname = u.Username\n\t\t\t}\n\n\t\t\t// TODO: move this to all permission checks?\n\t\t\tsuspended, err := app.db.IsUserSilenced(c.OwnerID)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"process protected collection permissions: %v\", err)\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif suspended {\n\t\t\t\treturn nil, ErrCollectionNotFound\n\t\t\t}\n\n\t\t\t// See if we've authorized this collection\n\t\t\tcr.isAuthorized = isAuthorizedForCollection(app, c.Alias, r)\n\n\t\t\tif !cr.isAuthorized {\n\t\t\t\tp := struct {\n\t\t\t\t\tpage.StaticPage\n\t\t\t\t\t*CollectionObj\n\t\t\t\t\tUsername string\n\t\t\t\t\tNext     string\n\t\t\t\t\tFlashes  []template.HTML\n\t\t\t\t}{\n\t\t\t\t\tStaticPage:    pageForReq(app, r),\n\t\t\t\t\tCollectionObj: &CollectionObj{Collection: *c},\n\t\t\t\t\tUsername:      uname,\n\t\t\t\t\tNext:          r.FormValue(\"g\"),\n\t\t\t\t\tFlashes:       []template.HTML{},\n\t\t\t\t}\n\t\t\t\t// Get owner information\n\t\t\t\tp.CollectionObj.Owner, err = app.db.GetUserByID(c.OwnerID)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// Log the error and just continue\n\t\t\t\t\tlog.Error(\"Error getting user for collection: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tflashes, _ := getSessionFlashes(app, w, r, nil)\n\t\t\t\tfor _, flash := range flashes {\n\t\t\t\t\tp.Flashes = append(p.Flashes, template.HTML(flash))\n\t\t\t\t}\n\t\t\t\terr = templates[\"password-collection\"].ExecuteTemplate(w, \"password-collection\", p)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error(\"Unable to render password-collection: %v\", err)\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn c, nil\n}\n\nfunc checkUserForCollection(app *App, cr *collectionReq, r *http.Request, isPostReq bool) (*User, error) {\n\tu := getUserSession(app, r)\n\treturn u, nil\n}\n\nfunc newDisplayCollection(c *Collection, cr *collectionReq, page int) *DisplayCollection {\n\tcoll := &DisplayCollection{\n\t\tCollectionObj: NewCollectionObj(c),\n\t\tCurrentPage:   page,\n\t\tPrefix:        cr.prefix,\n\t\tIsTopLevel:    isSingleUser,\n\t}\n\tc.db.GetPostsCount(coll.CollectionObj, cr.isCollOwner)\n\treturn coll\n}\n\n// getCollectionPage returns the collection page as an int. If the parsed page value is not\n// greater than 0 then the default value of 1 is returned.\nfunc getCollectionPage(vars map[string]string) int {\n\tif p, _ := strconv.Atoi(vars[\"page\"]); p > 0 {\n\t\treturn p\n\t}\n\n\treturn 1\n}\n\n// handleViewCollection displays the requested Collection\nfunc handleViewCollection(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tcr := &collectionReq{}\n\n\terr := processCollectionRequest(cr, vars, w, r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tu, err := checkUserForCollection(app, cr, r, false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpage := getCollectionPage(vars)\n\n\tc, err := processCollectionPermissions(app, cr, u, w, r)\n\tif c == nil || err != nil {\n\t\treturn err\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tsilenced, err := app.db.IsUserSilenced(c.OwnerID)\n\tif err != nil {\n\t\tlog.Error(\"view collection: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\n\t// Serve ActivityStreams data now, if requested\n\tif IsActivityPubRequest(r) {\n\t\tac := c.PersonObject()\n\t\tac.Context = []interface{}{activitystreams.Namespace}\n\t\tsetCacheControl(w, apCacheTime)\n\t\treturn impart.RenderActivityJSON(w, ac, http.StatusOK)\n\t}\n\n\t// Fetch extra data about the Collection\n\t// TODO: refactor out this logic, shared in collection.go:fetchCollection()\n\tcoll := newDisplayCollection(c, cr, page)\n\n\tcoll.TotalPages = int(math.Ceil(float64(coll.TotalPosts) / float64(coll.Format.PostsPerPage())))\n\tif coll.TotalPages > 0 && page > coll.TotalPages {\n\t\tredirURL := fmt.Sprintf(\"/page/%d\", coll.TotalPages)\n\t\tif !app.cfg.App.SingleUser {\n\t\t\tredirURL = fmt.Sprintf(\"/%s%s%s\", cr.prefix, coll.Alias, redirURL)\n\t\t}\n\t\treturn impart.HTTPError{http.StatusFound, redirURL}\n\t}\n\n\tcoll.Posts, _ = app.db.GetPosts(app.cfg, c, page, cr.isCollOwner, false, false)\n\n\t// Serve collection\n\tdisplayPage := CollectionPage{\n\t\tDisplayCollection: coll,\n\t\tIsCollLoggedIn:    cr.isAuthorized,\n\t\tStaticPage:        pageForReq(app, r),\n\t\tIsCustomDomain:    cr.isCustomDomain,\n\t\tIsWelcome:         r.FormValue(\"greeting\") != \"\",\n\t\tHoneypot:          spam.HoneypotFieldName(),\n\t\tCollAlias:         c.Alias,\n\t}\n\tflashes, _ := getSessionFlashes(app, w, r, nil)\n\tfor _, f := range flashes {\n\t\tdisplayPage.Flash = template.HTML(f)\n\t}\n\tdisplayPage.IsAdmin = u != nil && u.IsAdmin()\n\tdisplayPage.CanInvite = canUserInvite(app.cfg, displayPage.IsAdmin)\n\tvar owner *User\n\tif u != nil {\n\t\tdisplayPage.Username = u.Username\n\t\tdisplayPage.IsOwner = u.ID == coll.OwnerID\n\t\tdisplayPage.IsSubscriber = u.IsEmailSubscriber(app, coll.ID)\n\t\tif displayPage.IsOwner {\n\t\t\t// Add in needed information for users viewing their own collection\n\t\t\towner = u\n\t\t\tdisplayPage.CanPin = true\n\n\t\t\tpubColls, err := app.db.GetPublishableCollections(owner, app.cfg.App.Host)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"unable to fetch collections: %v\", err)\n\t\t\t}\n\t\t\tdisplayPage.Collections = pubColls\n\t\t}\n\t}\n\tisOwner := owner != nil\n\tif !isOwner {\n\t\t// Current user doesn't own collection; retrieve owner information\n\t\towner, err = app.db.GetUserByID(coll.OwnerID)\n\t\tif err != nil {\n\t\t\t// Log the error and just continue\n\t\t\tlog.Error(\"Error getting user for collection: %v\", err)\n\t\t}\n\t}\n\tif !isOwner && silenced {\n\t\treturn ErrCollectionNotFound\n\t}\n\tdisplayPage.Silenced = isOwner && silenced\n\tdisplayPage.Owner = owner\n\tcoll.Owner = displayPage.Owner\n\n\t// Add more data\n\t// TODO: fix this mess of collections inside collections\n\tdisplayPage.PinnedPosts, _ = app.db.GetPinnedPosts(coll.CollectionObj, isOwner)\n\tdisplayPage.Monetization = app.db.GetCollectionAttribute(coll.ID, \"monetization_pointer\")\n\n\tcollTmpl := \"collection\"\n\tif app.cfg.App.Chorus {\n\t\tcollTmpl = \"chorus-collection\"\n\t}\n\terr = templates[collTmpl].ExecuteTemplate(w, \"collection\", displayPage)\n\tif err != nil {\n\t\tlog.Error(\"Unable to render collection index: %v\", err)\n\t}\n\n\t// Update collection view count\n\tgo func() {\n\t\t// Don't update if owner is viewing the collection.\n\t\tif u != nil && u.ID == coll.OwnerID {\n\t\t\treturn\n\t\t}\n\t\t// Only update for human views\n\t\tif r.Method == \"HEAD\" || bots.IsBot(r.UserAgent()) {\n\t\t\treturn\n\t\t}\n\n\t\t_, err := app.db.Exec(\"UPDATE collections SET view_count = view_count + 1 WHERE id = ?\", coll.ID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to update collections count: %v\", err)\n\t\t}\n\t}()\n\n\treturn err\n}\n\nfunc handleViewMention(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\thandle := vars[\"handle\"]\n\n\tremoteUser, err := app.db.GetProfilePageFromHandle(app, handle)\n\tif err != nil || remoteUser == \"\" {\n\t\tlog.Error(\"Couldn't find user %s: %v\", handle, err)\n\t\treturn ErrRemoteUserNotFound\n\t}\n\n\treturn impart.HTTPError{Status: http.StatusFound, Message: remoteUser}\n}\n\nfunc handleViewCollectionTag(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\ttag := vars[\"tag\"]\n\n\tcr := &collectionReq{}\n\terr := processCollectionRequest(cr, vars, w, r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tu, err := checkUserForCollection(app, cr, r, false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpage := getCollectionPage(vars)\n\n\tc, err := processCollectionPermissions(app, cr, u, w, r)\n\tif c == nil || err != nil {\n\t\treturn err\n\t}\n\n\tcoll := newDisplayCollection(c, cr, page)\n\n\ttaggedPostIDs, err := app.db.GetAllPostsTaggedIDs(c, tag, cr.isCollOwner)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tttlPosts := len(taggedPostIDs)\n\tpagePosts := coll.Format.PostsPerPage()\n\tcoll.TotalPages = int(math.Ceil(float64(ttlPosts) / float64(pagePosts)))\n\tif coll.TotalPages > 0 && page > coll.TotalPages {\n\t\tredirURL := fmt.Sprintf(\"/page/%d\", coll.TotalPages)\n\t\tif !app.cfg.App.SingleUser {\n\t\t\tredirURL = fmt.Sprintf(\"/%s%s%s\", cr.prefix, coll.Alias, redirURL)\n\t\t}\n\t\treturn impart.HTTPError{http.StatusFound, redirURL}\n\t}\n\n\tcoll.Posts, _ = app.db.GetPostsTagged(app.cfg, c, tag, page, cr.isCollOwner)\n\tif coll.Posts != nil && len(*coll.Posts) == 0 {\n\t\treturn ErrCollectionPageNotFound\n\t}\n\n\t// Serve collection\n\tdisplayPage := TagCollectionPage{\n\t\tCollectionPage: CollectionPage{\n\t\t\tDisplayCollection: coll,\n\t\t\tStaticPage:        pageForReq(app, r),\n\t\t\tIsCustomDomain:    cr.isCustomDomain,\n\t\t},\n\t\tTag: tag,\n\t}\n\tvar owner *User\n\tif u != nil {\n\t\tdisplayPage.Username = u.Username\n\t\tdisplayPage.IsOwner = u.ID == coll.OwnerID\n\t\tif displayPage.IsOwner {\n\t\t\t// Add in needed information for users viewing their own collection\n\t\t\towner = u\n\t\t\tdisplayPage.CanPin = true\n\n\t\t\tpubColls, err := app.db.GetPublishableCollections(owner, app.cfg.App.Host)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"unable to fetch collections: %v\", err)\n\t\t\t}\n\t\t\tdisplayPage.Collections = pubColls\n\t\t}\n\t}\n\tisOwner := owner != nil\n\tif !isOwner {\n\t\t// Current user doesn't own collection; retrieve owner information\n\t\towner, err = app.db.GetUserByID(coll.OwnerID)\n\t\tif err != nil {\n\t\t\t// Log the error and just continue\n\t\t\tlog.Error(\"Error getting user for collection: %v\", err)\n\t\t}\n\t\tif owner.IsSilenced() {\n\t\t\treturn ErrCollectionNotFound\n\t\t}\n\t}\n\tdisplayPage.Silenced = owner != nil && owner.IsSilenced()\n\tdisplayPage.Owner = owner\n\tcoll.Owner = displayPage.Owner\n\t// Add more data\n\t// TODO: fix this mess of collections inside collections\n\tdisplayPage.PinnedPosts, _ = app.db.GetPinnedPosts(coll.CollectionObj, isOwner)\n\tdisplayPage.Monetization = app.db.GetCollectionAttribute(coll.ID, \"monetization_pointer\")\n\n\terr = templates[\"collection-tags\"].ExecuteTemplate(w, \"collection-tags\", displayPage)\n\tif err != nil {\n\t\tlog.Error(\"Unable to render collection tag page: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc handleViewCollectionLang(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tlang := vars[\"lang\"]\n\n\tcr := &collectionReq{}\n\terr := processCollectionRequest(cr, vars, w, r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tu, err := checkUserForCollection(app, cr, r, false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpage := getCollectionPage(vars)\n\n\tc, err := processCollectionPermissions(app, cr, u, w, r)\n\tif c == nil || err != nil {\n\t\treturn err\n\t}\n\n\tcoll := newDisplayCollection(c, cr, page)\n\tcoll.Language = lang\n\tcoll.NavSuffix = fmt.Sprintf(\"/lang:%s\", lang)\n\n\tttlPosts, err := app.db.GetCollLangTotalPosts(coll.ID, lang)\n\tif err != nil {\n\t\tlog.Error(\"Unable to getCollLangTotalPosts: %s\", err)\n\t}\n\tpagePosts := coll.Format.PostsPerPage()\n\tcoll.TotalPages = int(math.Ceil(float64(ttlPosts) / float64(pagePosts)))\n\tif coll.TotalPages > 0 && page > coll.TotalPages {\n\t\tredirURL := fmt.Sprintf(\"/lang:%s/page/%d\", lang, coll.TotalPages)\n\t\tif !app.cfg.App.SingleUser {\n\t\t\tredirURL = fmt.Sprintf(\"/%s%s%s\", cr.prefix, coll.Alias, redirURL)\n\t\t}\n\t\treturn impart.HTTPError{http.StatusFound, redirURL}\n\t}\n\n\tcoll.Posts, _ = app.db.GetLangPosts(app.cfg, c, lang, page, cr.isCollOwner)\n\tif err != nil {\n\t\treturn ErrCollectionPageNotFound\n\t}\n\n\t// Serve collection\n\tdisplayPage := struct {\n\t\tCollectionPage\n\t\tTag string\n\t}{\n\t\tCollectionPage: CollectionPage{\n\t\t\tDisplayCollection: coll,\n\t\t\tStaticPage:        pageForReq(app, r),\n\t\t\tIsCustomDomain:    cr.isCustomDomain,\n\t\t},\n\t\tTag: lang,\n\t}\n\tvar owner *User\n\tif u != nil {\n\t\tdisplayPage.Username = u.Username\n\t\tdisplayPage.IsOwner = u.ID == coll.OwnerID\n\t\tif displayPage.IsOwner {\n\t\t\t// Add in needed information for users viewing their own collection\n\t\t\towner = u\n\t\t\tdisplayPage.CanPin = true\n\n\t\t\tpubColls, err := app.db.GetPublishableCollections(owner, app.cfg.App.Host)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"unable to fetch collections: %v\", err)\n\t\t\t}\n\t\t\tdisplayPage.Collections = pubColls\n\t\t}\n\t}\n\tisOwner := owner != nil\n\tif !isOwner {\n\t\t// Current user doesn't own collection; retrieve owner information\n\t\towner, err = app.db.GetUserByID(coll.OwnerID)\n\t\tif err != nil {\n\t\t\t// Log the error and just continue\n\t\t\tlog.Error(\"Error getting user for collection: %v\", err)\n\t\t}\n\t\tif owner.IsSilenced() {\n\t\t\treturn ErrCollectionNotFound\n\t\t}\n\t}\n\tdisplayPage.Silenced = owner != nil && owner.IsSilenced()\n\tdisplayPage.Owner = owner\n\tcoll.Owner = displayPage.Owner\n\t// Add more data\n\t// TODO: fix this mess of collections inside collections\n\tdisplayPage.PinnedPosts, _ = app.db.GetPinnedPosts(coll.CollectionObj, isOwner)\n\tdisplayPage.Monetization = app.db.GetCollectionAttribute(coll.ID, \"monetization_pointer\")\n\n\tcollTmpl := \"collection\"\n\tif app.cfg.App.Chorus {\n\t\tcollTmpl = \"chorus-collection\"\n\t}\n\terr = templates[collTmpl].ExecuteTemplate(w, \"collection\", displayPage)\n\tif err != nil {\n\t\tlog.Error(\"Unable to render collection lang page: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc handleCollectionPostRedirect(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tslug := vars[\"slug\"]\n\n\tcr := &collectionReq{}\n\terr := processCollectionRequest(cr, vars, w, r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Normalize the URL, redirecting user to consistent post URL\n\tloc := fmt.Sprintf(\"/%s\", slug)\n\tif !app.cfg.App.SingleUser {\n\t\tloc = fmt.Sprintf(\"/%s/%s\", cr.alias, slug)\n\t}\n\treturn impart.HTTPError{http.StatusFound, loc}\n}\n\nfunc existingCollection(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\tvars := mux.Vars(r)\n\tcollAlias := vars[\"alias\"]\n\tisWeb := r.FormValue(\"web\") == \"1\"\n\n\tu := &User{}\n\tif reqJSON && !isWeb {\n\t\t// Ensure an access token was given\n\t\taccessToken := r.Header.Get(\"Authorization\")\n\t\tu.ID = app.db.GetUserID(accessToken)\n\t\tif u.ID == -1 {\n\t\t\treturn ErrBadAccessToken\n\t\t}\n\t} else {\n\t\tu = getUserSession(app, r)\n\t\tif u == nil {\n\t\t\treturn ErrNotLoggedIn\n\t\t}\n\t}\n\n\tsilenced, err := app.db.IsUserSilenced(u.ID)\n\tif err != nil {\n\t\tlog.Error(\"existing collection: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\n\tif silenced {\n\t\treturn ErrUserSilenced\n\t}\n\n\tif r.Method == \"DELETE\" {\n\t\terr := app.db.DeleteCollection(collAlias, u.ID)\n\t\tif err != nil {\n\t\t\t// TODO: if not HTTPError, report error to admin\n\t\t\tlog.Error(\"Unable to delete collection: %s\", err)\n\t\t\treturn err\n\t\t}\n\t\taddSessionFlash(app, w, r, \"Deleted your blog, \"+collAlias+\".\", nil)\n\t\treturn impart.HTTPError{Status: http.StatusNoContent}\n\t}\n\n\tc := SubmittedCollection{OwnerID: uint64(u.ID)}\n\n\tif reqJSON {\n\t\t// Decode JSON request\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr = decoder.Decode(&c)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse collection update JSON request: %v\\n\", err)\n\t\t\treturn ErrBadJSON\n\t\t}\n\t} else {\n\t\terr = r.ParseForm()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse collection update form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\n\t\terr = app.formDecoder.Decode(&c, r.PostForm)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't decode collection update form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\t}\n\n\terr = app.db.UpdateCollection(app, &c, collAlias)\n\tif err != nil {\n\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\tif reqJSON {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\taddSessionFlash(app, w, r, err.Message, nil)\n\t\t\treturn impart.HTTPError{http.StatusFound, \"/me/c/\" + collAlias}\n\t\t} else {\n\t\t\tlog.Error(\"Couldn't update collection: %v\\n\", err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif reqJSON {\n\t\treturn impart.WriteSuccess(w, struct {\n\t\t}{}, http.StatusOK)\n\t}\n\n\taddSessionFlash(app, w, r, \"Blog updated!\", nil)\n\treturn impart.HTTPError{http.StatusFound, \"/me/c/\" + collAlias}\n}\n\n// collectionAliasFromReq takes a request and returns the collection alias\n// if it can be ascertained, as well as whether or not the collection uses a\n// custom domain.\nfunc collectionAliasFromReq(r *http.Request) string {\n\tvars := mux.Vars(r)\n\talias := vars[\"subdomain\"]\n\tisSubdomain := alias != \"\"\n\tif !isSubdomain {\n\t\t// Fall back to write.as/{collection} since this isn't a custom domain\n\t\talias = vars[\"collection\"]\n\t}\n\treturn alias\n}\n\nfunc handleWebCollectionUnlock(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvar readReq struct {\n\t\tAlias string `schema:\"alias\" json:\"alias\"`\n\t\tPass  string `schema:\"password\" json:\"password\"`\n\t\tNext  string `schema:\"to\" json:\"to\"`\n\t}\n\n\t// Get params\n\tif impart.ReqJSON(r) {\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr := decoder.Decode(&readReq)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse readReq JSON request: %v\\n\", err)\n\t\t\treturn ErrBadJSON\n\t\t}\n\t} else {\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse readReq form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\n\t\terr = app.formDecoder.Decode(&readReq, r.PostForm)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't decode readReq form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\t}\n\n\tif readReq.Alias == \"\" {\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"Need a collection `alias` to read.\"}\n\t}\n\tif readReq.Pass == \"\" {\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"Please supply a password.\"}\n\t}\n\n\tvar collHashedPass []byte\n\terr := app.db.QueryRow(\"SELECT password FROM collectionpasswords INNER JOIN collections ON id = collection_id WHERE alias = ?\", readReq.Alias).Scan(&collHashedPass)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\tlog.Error(\"No collectionpassword found when trying to read collection %s\", readReq.Alias)\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Something went very wrong. The humans have been alerted.\"}\n\t\t}\n\t\treturn err\n\t}\n\n\tif !auth.Authenticated(collHashedPass, []byte(readReq.Pass)) {\n\t\treturn impart.HTTPError{http.StatusUnauthorized, \"Incorrect password.\"}\n\t}\n\n\t// Success; set cookie\n\tsession, err := app.sessionStore.Get(r, blogPassCookieName)\n\tif err == nil {\n\t\tsession.Values[readReq.Alias] = true\n\t\terr = session.Save(r, w)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Didn't save unlocked blog '%s': %v\", readReq.Alias, err)\n\t\t}\n\t}\n\n\tnext := \"/\" + readReq.Next\n\tif !app.cfg.App.SingleUser {\n\t\tnext = \"/\" + readReq.Alias + next\n\t}\n\treturn impart.HTTPError{http.StatusFound, next}\n}\n\nfunc isAuthorizedForCollection(app *App, alias string, r *http.Request) bool {\n\tauthd := false\n\tsession, err := app.sessionStore.Get(r, blogPassCookieName)\n\tif err == nil {\n\t\t_, authd = session.Values[alias]\n\t}\n\treturn authd\n}\n\nfunc logOutCollection(app *App, alias string, w http.ResponseWriter, r *http.Request) error {\n\tsession, err := app.sessionStore.Get(r, blogPassCookieName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Remove this from map of blogs logged into\n\tdelete(session.Values, alias)\n\n\t// If not auth'd with any blog, delete entire cookie\n\tif len(session.Values) == 0 {\n\t\tsession.Options.MaxAge = -1\n\t}\n\treturn session.Save(r, w)\n}\n\nfunc handleLogOutCollection(app *App, w http.ResponseWriter, r *http.Request) error {\n\talias := collectionAliasFromReq(r)\n\tvar c *Collection\n\tvar err error\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !c.IsProtected() {\n\t\t// Invalid to log out of this collection\n\t\treturn ErrCollectionPageNotFound\n\t}\n\n\terr = logOutCollection(app, c.Alias, w, r)\n\tif err != nil {\n\t\taddSessionFlash(app, w, r, \"Logging out failed. Try clearing cookies for this site, instead.\", nil)\n\t}\n\treturn impart.HTTPError{http.StatusFound, c.CanonicalURL()}\n}\n"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "database-lib.go",
          "type": "blob",
          "size": 0.6396484375,
          "content": "//go:build wflib\n// +build wflib\n\n/*\n * Copyright © 2019-2020 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\n// This file contains dummy database funcs for when writefreely is used as a\n// library.\n\npackage writefreely\n\nfunc (db *datastore) isDuplicateKeyErr(err error) bool {\n\treturn false\n}\n\nfunc (db *datastore) isIgnorableError(err error) bool {\n\treturn false\n}\n\nfunc (db *datastore) isHighLoadError(err error) bool {\n\treturn false\n}\n"
        },
        {
          "name": "database-no-sqlite.go",
          "type": "blob",
          "size": 1.3115234375,
          "content": "//go:build !sqlite && !wflib\n// +build !sqlite,!wflib\n\n/*\n * Copyright © 2019-2020 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"github.com/go-sql-driver/mysql\"\n\t\"github.com/writeas/web-core/log\"\n)\n\nfunc (db *datastore) isDuplicateKeyErr(err error) bool {\n\tif db.driverName == driverMySQL {\n\t\tif mysqlErr, ok := err.(*mysql.MySQLError); ok {\n\t\t\treturn mysqlErr.Number == mySQLErrDuplicateKey\n\t\t}\n\t} else {\n\t\tlog.Error(\"isDuplicateKeyErr: failed check for unrecognized driver '%s'\", db.driverName)\n\t}\n\n\treturn false\n}\n\nfunc (db *datastore) isIgnorableError(err error) bool {\n\tif db.driverName == driverMySQL {\n\t\tif mysqlErr, ok := err.(*mysql.MySQLError); ok {\n\t\t\treturn mysqlErr.Number == mySQLErrCollationMix\n\t\t}\n\t} else {\n\t\tlog.Error(\"isIgnorableError: failed check for unrecognized driver '%s'\", db.driverName)\n\t}\n\n\treturn false\n}\n\nfunc (db *datastore) isHighLoadError(err error) bool {\n\tif db.driverName == driverMySQL {\n\t\tif mysqlErr, ok := err.(*mysql.MySQLError); ok {\n\t\t\treturn mysqlErr.Number == mySQLErrMaxUserConns || mysqlErr.Number == mySQLErrTooManyConns\n\t\t}\n\t}\n\n\treturn false\n}\n"
        },
        {
          "name": "database-sqlite.go",
          "type": "blob",
          "size": 1.7841796875,
          "content": "//go:build sqlite && !wflib\n// +build sqlite,!wflib\n\n/*\n * Copyright © 2019-2020 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"github.com/mattn/go-sqlite3\"\n\t\"github.com/writeas/web-core/log\"\n\t\"regexp\"\n)\n\nfunc init() {\n\tSQLiteEnabled = true\n\n\tregex := func(re, s string) (bool, error) {\n\t\treturn regexp.MatchString(re, s)\n\t}\n\tsql.Register(\"sqlite3_with_regex\", &sqlite3.SQLiteDriver{\n\t\tConnectHook: func(conn *sqlite3.SQLiteConn) error {\n\t\t\treturn conn.RegisterFunc(\"regexp\", regex, true)\n\t\t},\n\t})\n}\n\nfunc (db *datastore) isDuplicateKeyErr(err error) bool {\n\tif db.driverName == driverSQLite {\n\t\tif err, ok := err.(sqlite3.Error); ok {\n\t\t\treturn err.Code == sqlite3.ErrConstraint\n\t\t}\n\t} else if db.driverName == driverMySQL {\n\t\tif mysqlErr, ok := err.(*mysql.MySQLError); ok {\n\t\t\treturn mysqlErr.Number == mySQLErrDuplicateKey\n\t\t}\n\t} else {\n\t\tlog.Error(\"isDuplicateKeyErr: failed check for unrecognized driver '%s'\", db.driverName)\n\t}\n\n\treturn false\n}\n\nfunc (db *datastore) isIgnorableError(err error) bool {\n\tif db.driverName == driverMySQL {\n\t\tif mysqlErr, ok := err.(*mysql.MySQLError); ok {\n\t\t\treturn mysqlErr.Number == mySQLErrCollationMix\n\t\t}\n\t} else {\n\t\tlog.Error(\"isIgnorableError: failed check for unrecognized driver '%s'\", db.driverName)\n\t}\n\n\treturn false\n}\n\nfunc (db *datastore) isHighLoadError(err error) bool {\n\tif db.driverName == driverMySQL {\n\t\tif mysqlErr, ok := err.(*mysql.MySQLError); ok {\n\t\t\treturn mysqlErr.Number == mySQLErrMaxUserConns || mysqlErr.Number == mySQLErrTooManyConns\n\t\t}\n\t}\n\n\treturn false\n}\n"
        },
        {
          "name": "database.go",
          "type": "blob",
          "size": 101.2451171875,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-sql-driver/mysql\"\n\t\"github.com/writeas/web-core/silobridge\"\n\twf_db \"github.com/writefreely/writefreely/db\"\n\t\"github.com/writefreely/writefreely/parse\"\n\n\t\"github.com/guregu/null\"\n\t\"github.com/guregu/null/zero\"\n\tuuid \"github.com/nu7hatch/gouuid\"\n\t\"github.com/writeas/activityserve\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/activitypub\"\n\t\"github.com/writeas/web-core/auth\"\n\t\"github.com/writeas/web-core/data\"\n\t\"github.com/writeas/web-core/id\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writeas/web-core/query\"\n\t\"github.com/writefreely/writefreely/author\"\n\t\"github.com/writefreely/writefreely/config\"\n\t\"github.com/writefreely/writefreely/key\"\n)\n\nconst (\n\tmySQLErrDuplicateKey = 1062\n\tmySQLErrCollationMix = 1267\n\tmySQLErrTooManyConns = 1040\n\tmySQLErrMaxUserConns = 1203\n\n\tdriverMySQL  = \"mysql\"\n\tdriverSQLite = \"sqlite3\"\n)\n\nvar (\n\tSQLiteEnabled bool\n)\n\ntype writestore interface {\n\tCreateUser(*config.Config, *User, string, string) error\n\tUpdateUserEmail(keys *key.Keychain, userID int64, email string) error\n\tUpdateEncryptedUserEmail(int64, []byte) error\n\tGetUserByID(int64) (*User, error)\n\tGetUserForAuth(string) (*User, error)\n\tGetUserForAuthByID(int64) (*User, error)\n\tGetUserNameFromToken(string) (string, error)\n\tGetUserDataFromToken(string) (int64, string, error)\n\tGetAPIUser(header string) (*User, error)\n\tGetUserID(accessToken string) int64\n\tGetUserIDPrivilege(accessToken string) (userID int64, sudo bool)\n\tDeleteToken(accessToken []byte) error\n\tFetchLastAccessToken(userID int64) string\n\tGetAccessToken(userID int64) (string, error)\n\tGetTemporaryAccessToken(userID int64, validSecs int) (string, error)\n\tGetTemporaryOneTimeAccessToken(userID int64, validSecs int, oneTime bool) (string, error)\n\tDeleteAccount(userID int64) error\n\tChangeSettings(app *App, u *User, s *userSettings) error\n\tChangePassphrase(userID int64, sudo bool, curPass string, hashedPass []byte) error\n\n\tGetCollections(u *User, hostName string) (*[]Collection, error)\n\tGetPublishableCollections(u *User, hostName string) (*[]Collection, error)\n\tGetMeStats(u *User) userMeStats\n\tGetTotalCollections() (int64, error)\n\tGetTotalPosts() (int64, error)\n\tGetTopPosts(u *User, alias string, hostName string) (*[]PublicPost, error)\n\tGetAnonymousPosts(u *User, page int) (*[]PublicPost, error)\n\tGetUserPosts(u *User) (*[]PublicPost, error)\n\n\tCreateOwnedPost(post *SubmittedPost, accessToken, collAlias, hostName string) (*PublicPost, error)\n\tCreatePost(userID, collID int64, post *SubmittedPost) (*Post, error)\n\tUpdateOwnedPost(post *AuthenticatedPost, userID int64) error\n\tGetEditablePost(id, editToken string) (*PublicPost, error)\n\tPostIDExists(id string) bool\n\tGetPost(id string, collectionID int64) (*PublicPost, error)\n\tGetOwnedPost(id string, ownerID int64) (*PublicPost, error)\n\tGetPostProperty(id string, collectionID int64, property string) (interface{}, error)\n\n\tCreateCollectionFromToken(*config.Config, string, string, string) (*Collection, error)\n\tCreateCollection(*config.Config, string, string, int64) (*Collection, error)\n\tGetCollectionBy(condition string, value interface{}) (*Collection, error)\n\tGetCollection(alias string) (*Collection, error)\n\tGetCollectionForPad(alias string) (*Collection, error)\n\tGetCollectionByID(id int64) (*Collection, error)\n\tUpdateCollection(app *App, c *SubmittedCollection, alias string) error\n\tDeleteCollection(alias string, userID int64) error\n\n\tUpdatePostPinState(pinned bool, postID string, collID, ownerID, pos int64) error\n\tGetLastPinnedPostPos(collID int64) int64\n\tGetPinnedPosts(coll *CollectionObj, includeFuture bool) (*[]PublicPost, error)\n\tRemoveCollectionRedirect(t *sql.Tx, alias string) error\n\tGetCollectionRedirect(alias string) (new string)\n\tIsCollectionAttributeOn(id int64, attr string) bool\n\tCollectionHasAttribute(id int64, attr string) bool\n\n\tCanCollect(cpr *ClaimPostRequest, userID int64) bool\n\tAttemptClaim(p *ClaimPostRequest, query string, params []interface{}, slugIdx int) (sql.Result, error)\n\tDispersePosts(userID int64, postIDs []string) (*[]ClaimPostResult, error)\n\tClaimPosts(cfg *config.Config, userID int64, collAlias string, posts *[]ClaimPostRequest) (*[]ClaimPostResult, error)\n\n\tGetPostLikeCounts(postID string) (int64, error)\n\tGetPostsCount(c *CollectionObj, includeFuture bool)\n\tGetPosts(cfg *config.Config, c *Collection, page int, includeFuture, forceRecentFirst, includePinned bool) (*[]PublicPost, error)\n\tGetAllPostsTaggedIDs(c *Collection, tag string, includeFuture bool) ([]string, error)\n\tGetPostsTagged(cfg *config.Config, c *Collection, tag string, page int, includeFuture bool) (*[]PublicPost, error)\n\n\tGetAPFollowers(c *Collection) (*[]RemoteUser, error)\n\tGetAPActorKeys(collectionID int64) ([]byte, []byte)\n\tCreateUserInvite(id string, userID int64, maxUses int, expires *time.Time) error\n\tGetUserInvites(userID int64) (*[]Invite, error)\n\tGetUserInvite(id string) (*Invite, error)\n\tGetUsersInvitedCount(id string) int64\n\tCreateInvitedUser(inviteID string, userID int64) error\n\n\tGetDynamicContent(id string) (*instanceContent, error)\n\tUpdateDynamicContent(id, title, content, contentType string) error\n\tGetAllUsers(page uint) (*[]User, error)\n\tGetAllUsersCount() int64\n\tGetUserLastPostTime(id int64) (*time.Time, error)\n\tGetCollectionLastPostTime(id int64) (*time.Time, error)\n\n\tGetIDForRemoteUser(context.Context, string, string, string) (int64, error)\n\tRecordRemoteUserID(context.Context, int64, string, string, string, string) error\n\tValidateOAuthState(context.Context, string) (string, string, int64, string, error)\n\tGenerateOAuthState(context.Context, string, string, int64, string) (string, error)\n\tGetOauthAccounts(ctx context.Context, userID int64) ([]oauthAccountInfo, error)\n\tRemoveOauth(ctx context.Context, userID int64, provider string, clientID string, remoteUserID string) error\n\n\tDatabaseInitialized() bool\n}\n\ntype datastore struct {\n\t*sql.DB\n\tdriverName string\n}\n\nvar _ writestore = &datastore{}\n\nfunc (db *datastore) now() string {\n\tif db.driverName == driverSQLite {\n\t\treturn \"strftime('%Y-%m-%d %H:%M:%S','now')\"\n\t}\n\treturn \"NOW()\"\n}\n\nfunc (db *datastore) clip(field string, l int) string {\n\tif db.driverName == driverSQLite {\n\t\treturn fmt.Sprintf(\"SUBSTR(%s, 0, %d)\", field, l)\n\t}\n\treturn fmt.Sprintf(\"LEFT(%s, %d)\", field, l)\n}\n\nfunc (db *datastore) upsert(indexedCols ...string) string {\n\tif db.driverName == driverSQLite {\n\t\t// NOTE: SQLite UPSERT syntax only works in v3.24.0 (2018-06-04) or later\n\t\t// Leaving this for whenever we can upgrade and include it in our binary\n\t\tcc := strings.Join(indexedCols, \", \")\n\t\treturn \"ON CONFLICT(\" + cc + \") DO UPDATE SET\"\n\t}\n\treturn \"ON DUPLICATE KEY UPDATE\"\n}\n\nfunc (db *datastore) dateAdd(l int, unit string) string {\n\tif db.driverName == driverSQLite {\n\t\treturn fmt.Sprintf(\"DATETIME('now', '%d %s')\", l, unit)\n\t}\n\treturn fmt.Sprintf(\"DATE_ADD(NOW(), INTERVAL %d %s)\", l, unit)\n}\n\nfunc (db *datastore) dateSub(l int, unit string) string {\n\tif db.driverName == driverSQLite {\n\t\treturn fmt.Sprintf(\"DATETIME('now', '-%d %s')\", l, unit)\n\t}\n\treturn fmt.Sprintf(\"DATE_SUB(NOW(), INTERVAL %d %s)\", l, unit)\n}\n\n// CreateUser creates a new user in the database from the given User, UPDATING it in the process with the user's ID.\nfunc (db *datastore) CreateUser(cfg *config.Config, u *User, collectionTitle string, collectionDesc string) error {\n\tif db.PostIDExists(u.Username) {\n\t\treturn impart.HTTPError{http.StatusConflict, \"Invalid collection name.\"}\n\t}\n\n\t// New users get a `users` and `collections` row.\n\tt, err := db.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 1. Add to `users` table\n\t// NOTE: Assumes User's Password is already hashed!\n\tres, err := t.Exec(\"INSERT INTO users (username, password, email) VALUES (?, ?, ?)\", u.Username, u.HashedPass, u.Email)\n\tif err != nil {\n\t\tt.Rollback()\n\t\tif db.isDuplicateKeyErr(err) {\n\t\t\treturn impart.HTTPError{http.StatusConflict, \"Username is already taken.\"}\n\t\t}\n\n\t\tlog.Error(\"Rolling back users INSERT: %v\\n\", err)\n\t\treturn err\n\t}\n\tu.ID, err = res.LastInsertId()\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Rolling back after LastInsertId: %v\\n\", err)\n\t\treturn err\n\t}\n\n\t// 2. Create user's Collection\n\tif collectionTitle == \"\" {\n\t\tcollectionTitle = u.Username\n\t}\n\tres, err = t.Exec(\"INSERT INTO collections (alias, title, description, privacy, owner_id, view_count) VALUES (?, ?, ?, ?, ?, ?)\", u.Username, collectionTitle, collectionDesc, defaultVisibility(cfg), u.ID, 0)\n\tif err != nil {\n\t\tt.Rollback()\n\t\tif db.isDuplicateKeyErr(err) {\n\t\t\treturn impart.HTTPError{http.StatusConflict, \"Username is already taken.\"}\n\t\t}\n\t\tlog.Error(\"Rolling back collections INSERT: %v\\n\", err)\n\t\treturn err\n\t}\n\n\tdb.RemoveCollectionRedirect(t, u.Username)\n\n\terr = t.Commit()\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Rolling back after Commit(): %v\\n\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// FIXME: We're returning errors inconsistently in this file. Do we use Errorf\n// for returned value, or impart?\nfunc (db *datastore) UpdateUserEmail(keys *key.Keychain, userID int64, email string) error {\n\tencEmail, err := data.Encrypt(keys.EmailKey, email)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Couldn't encrypt email %s: %s\\n\", email, err)\n\t}\n\n\treturn db.UpdateEncryptedUserEmail(userID, encEmail)\n}\n\nfunc (db *datastore) UpdateEncryptedUserEmail(userID int64, encEmail []byte) error {\n\t_, err := db.Exec(\"UPDATE users SET email = ? WHERE id = ?\", encEmail, userID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to update user email: %s\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (db *datastore) CreateCollectionFromToken(cfg *config.Config, alias, title, accessToken string) (*Collection, error) {\n\tuserID := db.GetUserID(accessToken)\n\tif userID == -1 {\n\t\treturn nil, ErrBadAccessToken\n\t}\n\n\treturn db.CreateCollection(cfg, alias, title, userID)\n}\n\nfunc (db *datastore) GetUserCollectionCount(userID int64) (uint64, error) {\n\tvar collCount uint64\n\terr := db.QueryRow(\"SELECT COUNT(*) FROM collections WHERE owner_id = ?\", userID).Scan(&collCount)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn 0, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve user from database.\"}\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't get collections count for user %d: %v\", userID, err)\n\t\treturn 0, err\n\t}\n\n\treturn collCount, nil\n}\n\nfunc (db *datastore) CreateCollection(cfg *config.Config, alias, title string, userID int64) (*Collection, error) {\n\tif db.PostIDExists(alias) {\n\t\treturn nil, impart.HTTPError{http.StatusConflict, \"Invalid collection name.\"}\n\t}\n\n\t// All good, so create new collection\n\tres, err := db.Exec(\"INSERT INTO collections (alias, title, description, privacy, owner_id, view_count) VALUES (?, ?, ?, ?, ?, ?)\", alias, title, \"\", defaultVisibility(cfg), userID, 0)\n\tif err != nil {\n\t\tif db.isDuplicateKeyErr(err) {\n\t\t\treturn nil, impart.HTTPError{http.StatusConflict, \"Collection already exists.\"}\n\t\t}\n\t\tlog.Error(\"Couldn't add to collections: %v\\n\", err)\n\t\treturn nil, err\n\t}\n\n\tc := &Collection{\n\t\tAlias:       alias,\n\t\tTitle:       title,\n\t\tOwnerID:     userID,\n\t\tPublicOwner: false,\n\t\tPublic:      defaultVisibility(cfg) == CollPublic,\n\t}\n\n\tc.ID, err = res.LastInsertId()\n\tif err != nil {\n\t\tlog.Error(\"Couldn't get collection LastInsertId: %v\\n\", err)\n\t}\n\n\treturn c, nil\n}\n\nfunc (db *datastore) GetUserByID(id int64) (*User, error) {\n\tu := &User{ID: id}\n\n\terr := db.QueryRow(\"SELECT username, password, email, created, status FROM users WHERE id = ?\", id).Scan(&u.Username, &u.HashedPass, &u.Email, &u.Created, &u.Status)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, ErrUserNotFound\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT user password: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn u, nil\n}\n\n// IsUserSilenced returns true if the user account associated with id is\n// currently silenced.\nfunc (db *datastore) IsUserSilenced(id int64) (bool, error) {\n\tu := &User{ID: id}\n\n\terr := db.QueryRow(\"SELECT status FROM users WHERE id = ?\", id).Scan(&u.Status)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn false, ErrUserNotFound\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT user status: %v\", err)\n\t\treturn false, fmt.Errorf(\"is user silenced: %v\", err)\n\t}\n\n\treturn u.IsSilenced(), nil\n}\n\n// DoesUserNeedAuth returns true if the user hasn't provided any methods for\n// authenticating with the account, such a passphrase or email address.\n// Any errors are reported to admin and silently quashed, returning false as the\n// result.\nfunc (db *datastore) DoesUserNeedAuth(id int64) bool {\n\tvar pass, email []byte\n\n\t// Find out if user has an email set first\n\terr := db.QueryRow(\"SELECT password, email FROM users WHERE id = ?\", id).Scan(&pass, &email)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\t// ERROR. Don't give false positives on needing auth methods\n\t\treturn false\n\tcase err != nil:\n\t\t// ERROR. Don't give false positives on needing auth methods\n\t\tlog.Error(\"Couldn't SELECT user %d from users: %v\", id, err)\n\t\treturn false\n\t}\n\t// User doesn't need auth if there's an email\n\treturn len(email) == 0 && len(pass) == 0\n}\n\nfunc (db *datastore) IsUserPassSet(id int64) (bool, error) {\n\tvar pass []byte\n\terr := db.QueryRow(\"SELECT password FROM users WHERE id = ?\", id).Scan(&pass)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn false, nil\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT user %d from users: %v\", id, err)\n\t\treturn false, err\n\t}\n\n\treturn len(pass) > 0, nil\n}\n\nfunc (db *datastore) GetUserForAuth(username string) (*User, error) {\n\tu := &User{Username: username}\n\n\terr := db.QueryRow(\"SELECT id, password, email, created, status FROM users WHERE username = ?\", username).Scan(&u.ID, &u.HashedPass, &u.Email, &u.Created, &u.Status)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\t// Check if they've entered the wrong, unnormalized username\n\t\tusername = getSlug(username, \"\")\n\t\tif username != u.Username {\n\t\t\terr = db.QueryRow(\"SELECT id FROM users WHERE username = ? LIMIT 1\", username).Scan(&u.ID)\n\t\t\tif err == nil {\n\t\t\t\treturn db.GetUserForAuth(username)\n\t\t\t}\n\t\t}\n\t\treturn nil, ErrUserNotFound\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT user password: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn u, nil\n}\n\nfunc (db *datastore) GetUserForAuthByID(userID int64) (*User, error) {\n\tu := &User{ID: userID}\n\n\terr := db.QueryRow(\"SELECT id, password, email, created, status FROM users WHERE id = ?\", u.ID).Scan(&u.ID, &u.HashedPass, &u.Email, &u.Created, &u.Status)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, ErrUserNotFound\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT userForAuthByID: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn u, nil\n}\n\nfunc (db *datastore) GetUserNameFromToken(accessToken string) (string, error) {\n\tt := auth.GetToken(accessToken)\n\tif len(t) == 0 {\n\t\treturn \"\", ErrNoAccessToken\n\t}\n\n\tvar oneTime bool\n\tvar username string\n\terr := db.QueryRow(\"SELECT username, one_time FROM accesstokens LEFT JOIN users ON user_id = id WHERE token LIKE ? AND (expires IS NULL OR expires > \"+db.now()+\")\", t).Scan(&username, &oneTime)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn \"\", ErrBadAccessToken\n\tcase err != nil:\n\t\treturn \"\", ErrInternalGeneral\n\t}\n\n\t// Delete token if it was one-time\n\tif oneTime {\n\t\tdb.DeleteToken(t[:])\n\t}\n\n\treturn username, nil\n}\n\nfunc (db *datastore) GetUserDataFromToken(accessToken string) (int64, string, error) {\n\tt := auth.GetToken(accessToken)\n\tif len(t) == 0 {\n\t\treturn 0, \"\", ErrNoAccessToken\n\t}\n\n\tvar userID int64\n\tvar oneTime bool\n\tvar username string\n\terr := db.QueryRow(\"SELECT user_id, username, one_time FROM accesstokens LEFT JOIN users ON user_id = id WHERE token LIKE ? AND (expires IS NULL OR expires > \"+db.now()+\")\", t).Scan(&userID, &username, &oneTime)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn 0, \"\", ErrBadAccessToken\n\tcase err != nil:\n\t\treturn 0, \"\", ErrInternalGeneral\n\t}\n\n\t// Delete token if it was one-time\n\tif oneTime {\n\t\tdb.DeleteToken(t[:])\n\t}\n\n\treturn userID, username, nil\n}\n\nfunc (db *datastore) GetAPIUser(header string) (*User, error) {\n\tuID := db.GetUserID(header)\n\tif uID == -1 {\n\t\treturn nil, fmt.Errorf(ErrUserNotFound.Error())\n\t}\n\treturn db.GetUserByID(uID)\n}\n\n// GetUserID takes a hexadecimal accessToken, parses it into its binary\n// representation, and gets any user ID associated with the token. If no user\n// is associated, -1 is returned.\nfunc (db *datastore) GetUserID(accessToken string) int64 {\n\ti, _ := db.GetUserIDPrivilege(accessToken)\n\treturn i\n}\n\nfunc (db *datastore) GetUserIDPrivilege(accessToken string) (userID int64, sudo bool) {\n\tt := auth.GetToken(accessToken)\n\tif len(t) == 0 {\n\t\treturn -1, false\n\t}\n\n\tvar oneTime bool\n\terr := db.QueryRow(\"SELECT user_id, sudo, one_time FROM accesstokens WHERE token LIKE ? AND (expires IS NULL OR expires > \"+db.now()+\")\", t).Scan(&userID, &sudo, &oneTime)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn -1, false\n\tcase err != nil:\n\t\treturn -1, false\n\t}\n\n\t// Delete token if it was one-time\n\tif oneTime {\n\t\tdb.DeleteToken(t[:])\n\t}\n\n\treturn\n}\n\nfunc (db *datastore) DeleteToken(accessToken []byte) error {\n\tres, err := db.Exec(\"DELETE FROM accesstokens WHERE token LIKE ?\", accessToken)\n\tif err != nil {\n\t\treturn err\n\t}\n\trowsAffected, _ := res.RowsAffected()\n\tif rowsAffected == 0 {\n\t\treturn impart.HTTPError{http.StatusNotFound, \"Token is invalid or doesn't exist\"}\n\t}\n\treturn nil\n}\n\n// FetchLastAccessToken creates a new non-expiring, valid access token for the given\n// userID.\nfunc (db *datastore) FetchLastAccessToken(userID int64) string {\n\tvar t []byte\n\terr := db.QueryRow(\"SELECT token FROM accesstokens WHERE user_id = ? AND (expires IS NULL OR expires > \"+db.now()+\") ORDER BY created DESC LIMIT 1\", userID).Scan(&t)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn \"\"\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting from accesstoken: %v\", err)\n\t\treturn \"\"\n\t}\n\n\tu, err := uuid.Parse(t)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn u.String()\n}\n\n// GetAccessToken creates a new non-expiring, valid access token for the given\n// userID.\nfunc (db *datastore) GetAccessToken(userID int64) (string, error) {\n\treturn db.GetTemporaryOneTimeAccessToken(userID, 0, false)\n}\n\n// GetTemporaryAccessToken creates a new valid access token for the given\n// userID that remains valid for the given time in seconds. If validSecs is 0,\n// the access token doesn't automatically expire.\nfunc (db *datastore) GetTemporaryAccessToken(userID int64, validSecs int) (string, error) {\n\treturn db.GetTemporaryOneTimeAccessToken(userID, validSecs, false)\n}\n\n// GetTemporaryOneTimeAccessToken creates a new valid access token for the given\n// userID that remains valid for the given time in seconds and can only be used\n// once if oneTime is true. If validSecs is 0, the access token doesn't\n// automatically expire.\nfunc (db *datastore) GetTemporaryOneTimeAccessToken(userID int64, validSecs int, oneTime bool) (string, error) {\n\tu, err := uuid.NewV4()\n\tif err != nil {\n\t\tlog.Error(\"Unable to generate token: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\t// Insert UUID to `accesstokens`\n\tbinTok := u[:]\n\n\texpirationVal := \"NULL\"\n\tif validSecs > 0 {\n\t\texpirationVal = db.dateAdd(validSecs, \"SECOND\")\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO accesstokens (token, user_id, one_time, expires) VALUES (?, ?, ?, \"+expirationVal+\")\", string(binTok), userID, oneTime)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't INSERT accesstoken: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn u.String(), nil\n}\n\nfunc (db *datastore) CreatePasswordResetToken(userID int64) (string, error) {\n\tt := id.Generate62RandomString(32)\n\n\t_, err := db.Exec(\"INSERT INTO password_resets (user_id, token, used, created) VALUES (?, ?, 0, \"+db.now()+\")\", userID, t)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't INSERT password_resets: %v\", err)\n\t\treturn \"\", err\n\t}\n\n\treturn t, nil\n}\n\nfunc (db *datastore) GetUserFromPasswordReset(token string) int64 {\n\tvar userID int64\n\terr := db.QueryRow(\"SELECT user_id FROM password_resets WHERE token = ? AND used = 0 AND created > \"+db.dateSub(3, \"HOUR\"), token).Scan(&userID)\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn userID\n}\n\nfunc (db *datastore) ConsumePasswordResetToken(t string) error {\n\t_, err := db.Exec(\"UPDATE password_resets SET used = 1 WHERE token = ?\", t)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't UPDATE password_resets: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (db *datastore) CreateOwnedPost(post *SubmittedPost, accessToken, collAlias, hostName string) (*PublicPost, error) {\n\tvar userID, collID int64 = -1, -1\n\tvar coll *Collection\n\tvar err error\n\tif accessToken != \"\" {\n\t\tuserID = db.GetUserID(accessToken)\n\t\tif userID == -1 {\n\t\t\treturn nil, ErrBadAccessToken\n\t\t}\n\t\tif collAlias != \"\" {\n\t\t\tcoll, err = db.GetCollection(collAlias)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcoll.hostName = hostName\n\t\t\tif coll.OwnerID != userID {\n\t\t\t\treturn nil, ErrForbiddenCollection\n\t\t\t}\n\t\t\tcollID = coll.ID\n\t\t}\n\t}\n\n\trp := &PublicPost{}\n\trp.Post, err = db.CreatePost(userID, collID, post)\n\tif err != nil {\n\t\treturn rp, err\n\t}\n\tif coll != nil {\n\t\tcoll.ForPublic()\n\t\trp.Collection = &CollectionObj{Collection: *coll}\n\t}\n\treturn rp, nil\n}\n\nfunc (db *datastore) CreatePost(userID, collID int64, post *SubmittedPost) (*Post, error) {\n\tidLen := postIDLen\n\tfriendlyID := id.GenerateFriendlyRandomString(idLen)\n\n\t// Handle appearance / font face\n\tappearance := post.Font\n\tif !post.isFontValid() {\n\t\tappearance = \"norm\"\n\t}\n\n\tvar err error\n\townerID := sql.NullInt64{\n\t\tValid: false,\n\t}\n\townerCollID := sql.NullInt64{\n\t\tValid: false,\n\t}\n\tslug := sql.NullString{\"\", false}\n\n\t// If an alias was supplied, we'll add this to the collection as well.\n\tif userID > 0 {\n\t\townerID.Int64 = userID\n\t\townerID.Valid = true\n\t\tif collID > 0 {\n\t\t\townerCollID.Int64 = collID\n\t\t\townerCollID.Valid = true\n\t\t\tvar slugVal string\n\t\t\tif post.Slug != nil && *post.Slug != \"\" {\n\t\t\t\tslugVal = *post.Slug\n\t\t\t} else {\n\t\t\t\tif post.Title != nil && *post.Title != \"\" {\n\t\t\t\t\tslugVal = getSlug(*post.Title, post.Language.String)\n\t\t\t\t\tif slugVal == \"\" {\n\t\t\t\t\t\tslugVal = getSlug(*post.Content, post.Language.String)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tslugVal = getSlug(*post.Content, post.Language.String)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif slugVal == \"\" {\n\t\t\t\tslugVal = friendlyID\n\t\t\t}\n\t\t\tslug = sql.NullString{slugVal, true}\n\t\t}\n\t}\n\n\tcreated := time.Now()\n\tif db.driverName == driverSQLite {\n\t\t// SQLite stores datetimes in UTC, so convert time.Now() to it here\n\t\tcreated = created.UTC()\n\t}\n\tif post.Created != nil && *post.Created != \"\" {\n\t\tcreated, err = time.Parse(\"2006-01-02T15:04:05Z\", *post.Created)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to parse Created time '%s': %v\", *post.Created, err)\n\t\t\tcreated = time.Now()\n\t\t\tif db.driverName == driverSQLite {\n\t\t\t\t// SQLite stores datetimes in UTC, so convert time.Now() to it here\n\t\t\t\tcreated = created.UTC()\n\t\t\t}\n\t\t}\n\t}\n\n\tstmt, err := db.Prepare(\"INSERT INTO posts (id, slug, title, content, text_appearance, language, rtl, privacy, owner_id, collection_id, created, updated, view_count) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \" + db.now() + \", ?)\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\t_, err = stmt.Exec(friendlyID, slug, post.Title, post.Content, appearance, post.Language, post.IsRTL, 0, ownerID, ownerCollID, created, 0)\n\tif err != nil {\n\t\tif db.isDuplicateKeyErr(err) {\n\t\t\t// Duplicate entry error; try a new slug\n\t\t\t// TODO: make this a little more robust\n\t\t\tslug = sql.NullString{id.GenSafeUniqueSlug(slug.String), true}\n\t\t\t_, err = stmt.Exec(friendlyID, slug, post.Title, post.Content, appearance, post.Language, post.IsRTL, 0, ownerID, ownerCollID, created, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, handleFailedPostInsert(fmt.Errorf(\"Retried slug generation, still failed: %v\", err))\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, handleFailedPostInsert(err)\n\t\t}\n\t}\n\n\t// TODO: return Created field in proper format\n\treturn &Post{\n\t\tID:           friendlyID,\n\t\tSlug:         null.NewString(slug.String, slug.Valid),\n\t\tFont:         appearance,\n\t\tLanguage:     zero.NewString(post.Language.String, post.Language.Valid),\n\t\tRTL:          zero.NewBool(post.IsRTL.Bool, post.IsRTL.Valid),\n\t\tOwnerID:      null.NewInt(userID, true),\n\t\tCollectionID: null.NewInt(userID, true),\n\t\tCreated:      created.Truncate(time.Second).UTC(),\n\t\tUpdated:      time.Now().Truncate(time.Second).UTC(),\n\t\tTitle:        zero.NewString(*(post.Title), true),\n\t\tContent:      *(post.Content),\n\t}, nil\n}\n\n// UpdateOwnedPost updates an existing post with only the given fields in the\n// supplied AuthenticatedPost.\nfunc (db *datastore) UpdateOwnedPost(post *AuthenticatedPost, userID int64) error {\n\tparams := []interface{}{}\n\tvar queryUpdates, sep, authCondition string\n\tif post.Slug != nil && *post.Slug != \"\" {\n\t\tqueryUpdates += sep + \"slug = ?\"\n\t\tsep = \", \"\n\t\tparams = append(params, getSlug(*post.Slug, \"\"))\n\t}\n\tif post.Content != nil {\n\t\tqueryUpdates += sep + \"content = ?\"\n\t\tsep = \", \"\n\t\tparams = append(params, post.Content)\n\t}\n\tif post.Title != nil {\n\t\tqueryUpdates += sep + \"title = ?\"\n\t\tsep = \", \"\n\t\tparams = append(params, post.Title)\n\t}\n\tif post.Language.Valid {\n\t\tqueryUpdates += sep + \"language = ?\"\n\t\tsep = \", \"\n\t\tparams = append(params, post.Language.String)\n\t}\n\tif post.IsRTL.Valid {\n\t\tqueryUpdates += sep + \"rtl = ?\"\n\t\tsep = \", \"\n\t\tparams = append(params, post.IsRTL.Bool)\n\t}\n\tif post.Font != \"\" {\n\t\tqueryUpdates += sep + \"text_appearance = ?\"\n\t\tsep = \", \"\n\t\tparams = append(params, post.Font)\n\t}\n\tif post.Created != nil {\n\t\tcreateTime, err := time.Parse(postMetaDateFormat, *post.Created)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to parse Created date: %v\", err)\n\t\t\treturn fmt.Errorf(\"That's the incorrect format for Created date.\")\n\t\t}\n\t\tqueryUpdates += sep + \"created = ?\"\n\t\tsep = \", \"\n\t\tparams = append(params, createTime)\n\t}\n\n\t// WHERE parameters...\n\t// id = ?\n\tparams = append(params, post.ID)\n\t// AND owner_id = ?\n\tauthCondition = \"(owner_id = ?)\"\n\tparams = append(params, userID)\n\n\tif queryUpdates == \"\" {\n\t\treturn ErrPostNoUpdatableVals\n\t}\n\n\tqueryUpdates += sep + \"updated = \" + db.now()\n\n\tres, err := db.Exec(\"UPDATE posts SET \"+queryUpdates+\" WHERE id = ? AND \"+authCondition, params...)\n\tif err != nil {\n\t\tlog.Error(\"Unable to update owned post: %v\", err)\n\t\treturn err\n\t}\n\n\trowsAffected, _ := res.RowsAffected()\n\tif rowsAffected == 0 {\n\t\t// Show the correct error message if nothing was updated\n\t\tvar dummy int\n\t\terr := db.QueryRow(\"SELECT 1 FROM posts WHERE id = ? AND \"+authCondition, post.ID, params[len(params)-1]).Scan(&dummy)\n\t\tswitch {\n\t\tcase err == sql.ErrNoRows:\n\t\t\treturn ErrUnauthorizedEditPost\n\t\tcase err != nil:\n\t\t\tlog.Error(\"Failed selecting from posts: %v\", err)\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\nfunc (db *datastore) GetCollectionBy(condition string, value interface{}) (*Collection, error) {\n\tc := &Collection{}\n\n\t// FIXME: change Collection to reflect database values. Add helper functions to get actual values\n\tvar styleSheet, script, signature, format zero.String\n\trow := db.QueryRow(\"SELECT id, alias, title, description, style_sheet, script, post_signature, format, owner_id, privacy, view_count FROM collections WHERE \"+condition, value)\n\n\terr := row.Scan(&c.ID, &c.Alias, &c.Title, &c.Description, &styleSheet, &script, &signature, &format, &c.OwnerID, &c.Visibility, &c.Views)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, impart.HTTPError{http.StatusNotFound, \"Collection doesn't exist.\"}\n\tcase db.isHighLoadError(err):\n\t\treturn nil, ErrUnavailable\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting from collections: %v\", err)\n\t\treturn nil, err\n\t}\n\tc.StyleSheet = styleSheet.String\n\tc.Script = script.String\n\tc.Signature = signature.String\n\tc.Format = format.String\n\tc.Public = c.IsPublic()\n\tc.Monetization = db.GetCollectionAttribute(c.ID, \"monetization_pointer\")\n\tc.Verification = db.GetCollectionAttribute(c.ID, \"verification_link\")\n\n\tc.db = db\n\n\treturn c, nil\n}\n\nfunc (db *datastore) GetCollection(alias string) (*Collection, error) {\n\treturn db.GetCollectionBy(\"alias = ?\", alias)\n}\n\nfunc (db *datastore) GetCollectionForPad(alias string) (*Collection, error) {\n\tc := &Collection{Alias: alias}\n\n\trow := db.QueryRow(\"SELECT id, alias, title, description, privacy FROM collections WHERE alias = ?\", alias)\n\n\terr := row.Scan(&c.ID, &c.Alias, &c.Title, &c.Description, &c.Visibility)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn c, impart.HTTPError{http.StatusNotFound, \"Collection doesn't exist.\"}\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting from collections: %v\", err)\n\t\treturn c, ErrInternalGeneral\n\t}\n\tc.Public = c.IsPublic()\n\n\treturn c, nil\n}\n\nfunc (db *datastore) GetCollectionByID(id int64) (*Collection, error) {\n\treturn db.GetCollectionBy(\"id = ?\", id)\n}\n\nfunc (db *datastore) GetCollectionFromDomain(host string) (*Collection, error) {\n\treturn db.GetCollectionBy(\"host = ?\", host)\n}\n\nfunc (db *datastore) UpdateCollection(app *App, c *SubmittedCollection, alias string) error {\n\t// Truncate fields correctly, so we don't get \"Data too long for column\" errors in MySQL (writefreely#600)\n\tif c.Title != nil {\n\t\t*c.Title = parse.Truncate(*c.Title, collMaxLengthTitle)\n\t}\n\tif c.Description != nil {\n\t\t*c.Description = parse.Truncate(*c.Description, collMaxLengthDescription)\n\t}\n\n\tq := query.NewUpdate().\n\t\tSetStringPtr(c.Title, \"title\").\n\t\tSetStringPtr(c.Description, \"description\").\n\t\tSetStringPtr(c.StyleSheet, \"style_sheet\").\n\t\tSetStringPtr(c.Script, \"script\").\n\t\tSetStringPtr(c.Signature, \"post_signature\")\n\n\tif c.Format != nil {\n\t\tcf := &CollectionFormat{Format: c.Format.String}\n\t\tif cf.Valid() {\n\t\t\tq.SetNullString(c.Format, \"format\")\n\t\t}\n\t}\n\n\tvar updatePass bool\n\tif c.Visibility != nil && (collVisibility(*c.Visibility)&CollProtected == 0 || c.Pass != \"\") {\n\t\tq.SetIntPtr(c.Visibility, \"privacy\")\n\t\tif c.Pass != \"\" {\n\t\t\tupdatePass = true\n\t\t}\n\t}\n\n\t// WHERE values\n\tq.Where(\"alias = ? AND owner_id = ?\", alias, c.OwnerID)\n\n\tif q.Updates == \"\" && c.Monetization == nil {\n\t\treturn ErrPostNoUpdatableVals\n\t}\n\n\t// Find any current domain\n\tvar collID int64\n\tvar rowsAffected int64\n\tvar changed bool\n\tvar res sql.Result\n\terr := db.QueryRow(\"SELECT id FROM collections WHERE alias = ?\", alias).Scan(&collID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from collections: %v. Some things won't work.\", err)\n\t}\n\n\t// Update MathJax value\n\tif c.MathJax {\n\t\tif db.driverName == driverSQLite {\n\t\t\t_, err = db.Exec(\"INSERT OR REPLACE INTO collectionattributes (collection_id, attribute, value) VALUES (?, ?, ?)\", collID, \"render_mathjax\", \"1\")\n\t\t} else {\n\t\t\t_, err = db.Exec(\"INSERT INTO collectionattributes (collection_id, attribute, value) VALUES (?, ?, ?) \"+db.upsert(\"collection_id\", \"attribute\")+\" value = ?\", collID, \"render_mathjax\", \"1\", \"1\")\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to insert render_mathjax value: %v\", err)\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t_, err = db.Exec(\"DELETE FROM collectionattributes WHERE collection_id = ? AND attribute = ?\", collID, \"render_mathjax\")\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to delete render_mathjax value: %v\", err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Update Verification link value\n\tif c.Verification != nil {\n\t\tskipUpdate := false\n\t\tif *c.Verification != \"\" {\n\t\t\t// Strip away any excess spaces\n\t\t\ttrimmed := strings.TrimSpace(*c.Verification)\n\t\t\tif strings.HasPrefix(trimmed, \"@\") && strings.Count(trimmed, \"@\") == 2 {\n\t\t\t\t// This looks like a fediverse handle, so resolve profile URL\n\t\t\t\tprofileURL, err := GetProfileURLFromHandle(app, trimmed)\n\t\t\t\tif err != nil || profileURL == \"\" {\n\t\t\t\t\tlog.Error(\"Couldn't find user %s: %v\", trimmed, err)\n\t\t\t\t\tskipUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\tc.Verification = &profileURL\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !strings.HasPrefix(trimmed, \"http\") {\n\t\t\t\t\ttrimmed = \"https://\" + trimmed\n\t\t\t\t}\n\t\t\t\tvu, err := url.Parse(trimmed)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// Value appears invalid, so don't update\n\t\t\t\t\tskipUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ts := vu.String()\n\t\t\t\t\tc.Verification = &s\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !skipUpdate {\n\t\t\terr = db.SetCollectionAttribute(collID, \"verification_link\", *c.Verification)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Unable to insert verification_link value: %v\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update Monetization value\n\tif c.Monetization != nil {\n\t\tskipUpdate := false\n\t\tif *c.Monetization != \"\" {\n\t\t\t// Strip away any excess spaces\n\t\t\ttrimmed := strings.TrimSpace(*c.Monetization)\n\t\t\t// Only update value when it starts with \"$\", per spec: https://paymentpointers.org\n\t\t\tif strings.HasPrefix(trimmed, \"$\") {\n\t\t\t\tc.Monetization = &trimmed\n\t\t\t} else {\n\t\t\t\t// Value appears invalid, so don't update\n\t\t\t\tskipUpdate = true\n\t\t\t}\n\t\t}\n\t\tif !skipUpdate {\n\t\t\t_, err = db.Exec(\"INSERT INTO collectionattributes (collection_id, attribute, value) VALUES (?, ?, ?) \"+db.upsert(\"collection_id\", \"attribute\")+\" value = ?\", collID, \"monetization_pointer\", *c.Monetization, *c.Monetization)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Unable to insert monetization_pointer value: %v\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update EmailSub value\n\tif c.EmailSubs {\n\t\terr = db.SetCollectionAttribute(collID, \"email_subs\", \"1\")\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to insert email_subs value: %v\", err)\n\t\t\treturn err\n\t\t}\n\t\tskipUpdate := false\n\t\tif c.LetterReply != nil {\n\t\t\t// Strip away any excess spaces\n\t\t\ttrimmed := strings.TrimSpace(*c.LetterReply)\n\t\t\t// Only update value when it contains \"@\"\n\t\t\tif strings.IndexRune(trimmed, '@') > 0 {\n\t\t\t\tc.LetterReply = &trimmed\n\t\t\t} else {\n\t\t\t\t// Value appears invalid, so don't update\n\t\t\t\tskipUpdate = true\n\t\t\t}\n\t\t\tif !skipUpdate {\n\t\t\t\terr = db.SetCollectionAttribute(collID, collAttrLetterReplyTo, *c.LetterReply)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error(\"Unable to insert %s value: %v\", collAttrLetterReplyTo, err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t_, err = db.Exec(\"DELETE FROM collectionattributes WHERE collection_id = ? AND attribute = ?\", collID, \"email_subs\")\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to delete email_subs value: %v\", err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Update rest of the collection data\n\tif q.Updates != \"\" {\n\t\tres, err = db.Exec(\"UPDATE collections SET \"+q.Updates+\" WHERE \"+q.Conditions, q.Params...)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to update collection: %v\", err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\trowsAffected, _ = res.RowsAffected()\n\tif !changed || rowsAffected == 0 {\n\t\t// Show the correct error message if nothing was updated\n\t\tvar dummy int\n\t\terr := db.QueryRow(\"SELECT 1 FROM collections WHERE alias = ? AND owner_id = ?\", alias, c.OwnerID).Scan(&dummy)\n\t\tswitch {\n\t\tcase err == sql.ErrNoRows:\n\t\t\treturn ErrUnauthorizedEditPost\n\t\tcase err != nil:\n\t\t\tlog.Error(\"Failed selecting from collections: %v\", err)\n\t\t}\n\t\tif !updatePass {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif updatePass {\n\t\thashedPass, err := auth.HashPass([]byte(c.Pass))\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to create hash: %s\", err)\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Could not create password hash.\"}\n\t\t}\n\t\tif db.driverName == driverSQLite {\n\t\t\t_, err = db.Exec(\"INSERT OR REPLACE INTO collectionpasswords (collection_id, password) VALUES ((SELECT id FROM collections WHERE alias = ?), ?)\", alias, hashedPass)\n\t\t} else {\n\t\t\t_, err = db.Exec(\"INSERT INTO collectionpasswords (collection_id, password) VALUES ((SELECT id FROM collections WHERE alias = ?), ?) \"+db.upsert(\"collection_id\")+\" password = ?\", alias, hashedPass, hashedPass)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nconst postCols = \"id, slug, text_appearance, language, rtl, privacy, owner_id, collection_id, pinned_position, created, updated, view_count, title, content\"\n\n// getEditablePost returns a PublicPost with the given ID only if the given\n// edit token is valid for the post.\nfunc (db *datastore) GetEditablePost(id, editToken string) (*PublicPost, error) {\n\t// FIXME: code duplicated from getPost()\n\t// TODO: add slight logic difference to getPost / one func\n\tvar ownerName sql.NullString\n\tp := &Post{}\n\n\trow := db.QueryRow(\"SELECT \"+postCols+\", (SELECT username FROM users WHERE users.id = posts.owner_id) AS username FROM posts WHERE id = ? LIMIT 1\", id)\n\terr := row.Scan(&p.ID, &p.Slug, &p.Font, &p.Language, &p.RTL, &p.Privacy, &p.OwnerID, &p.CollectionID, &p.PinnedPosition, &p.Created, &p.Updated, &p.ViewCount, &p.Title, &p.Content, &ownerName)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, ErrPostNotFound\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting from collections: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif p.Content == \"\" && p.Title.String == \"\" {\n\t\treturn nil, ErrPostUnpublished\n\t}\n\n\tres := p.processPost()\n\tif ownerName.Valid {\n\t\tres.Owner = &PublicUser{Username: ownerName.String}\n\t}\n\n\treturn &res, nil\n}\n\nfunc (db *datastore) PostIDExists(id string) bool {\n\tvar dummy bool\n\terr := db.QueryRow(\"SELECT 1 FROM posts WHERE id = ?\", id).Scan(&dummy)\n\treturn err == nil && dummy\n}\n\n// GetPost gets a public-facing post object from the database. If collectionID\n// is > 0, the post will be retrieved by slug and collection ID, rather than\n// post ID.\n// TODO: break this into two functions:\n//   - GetPost(id string)\n//   - GetCollectionPost(slug string, collectionID int64)\nfunc (db *datastore) GetPost(id string, collectionID int64) (*PublicPost, error) {\n\tvar ownerName sql.NullString\n\tp := &Post{}\n\n\tvar row *sql.Row\n\tvar where string\n\tparams := []interface{}{id}\n\tif collectionID > 0 {\n\t\twhere = \"slug = ? AND collection_id = ?\"\n\t\tparams = append(params, collectionID)\n\t} else {\n\t\twhere = \"id = ?\"\n\t}\n\trow = db.QueryRow(\"SELECT \"+postCols+\", (SELECT username FROM users WHERE users.id = posts.owner_id) AS username FROM posts WHERE \"+where+\" LIMIT 1\", params...)\n\terr := row.Scan(&p.ID, &p.Slug, &p.Font, &p.Language, &p.RTL, &p.Privacy, &p.OwnerID, &p.CollectionID, &p.PinnedPosition, &p.Created, &p.Updated, &p.ViewCount, &p.Title, &p.Content, &ownerName)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\tif collectionID > 0 {\n\t\t\treturn nil, ErrCollectionPageNotFound\n\t\t}\n\t\treturn nil, ErrPostNotFound\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting from collections: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif p.Content == \"\" && p.Title.String == \"\" {\n\t\treturn nil, ErrPostUnpublished\n\t}\n\n\t// Get additional information needed before processing post data\n\tp.LikeCount, err = db.GetPostLikeCounts(p.ID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres := p.processPost()\n\tif ownerName.Valid {\n\t\tres.Owner = &PublicUser{Username: ownerName.String}\n\t}\n\n\treturn &res, nil\n}\n\n// TODO: don't duplicate getPost() functionality\nfunc (db *datastore) GetOwnedPost(id string, ownerID int64) (*PublicPost, error) {\n\tp := &Post{}\n\n\tvar row *sql.Row\n\twhere := \"id = ? AND owner_id = ?\"\n\tparams := []interface{}{id, ownerID}\n\trow = db.QueryRow(\"SELECT \"+postCols+\" FROM posts WHERE \"+where+\" LIMIT 1\", params...)\n\terr := row.Scan(&p.ID, &p.Slug, &p.Font, &p.Language, &p.RTL, &p.Privacy, &p.OwnerID, &p.CollectionID, &p.PinnedPosition, &p.Created, &p.Updated, &p.ViewCount, &p.Title, &p.Content)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, ErrPostNotFound\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting from collections: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tif p.Content == \"\" && p.Title.String == \"\" {\n\t\treturn nil, ErrPostUnpublished\n\t}\n\n\tres := p.processPost()\n\n\treturn &res, nil\n}\n\nfunc (db *datastore) GetPostProperty(id string, collectionID int64, property string) (interface{}, error) {\n\tpropSelects := map[string]string{\n\t\t\"views\": \"view_count AS views\",\n\t}\n\tselectQuery, ok := propSelects[property]\n\tif !ok {\n\t\treturn nil, impart.HTTPError{http.StatusBadRequest, fmt.Sprintf(\"Invalid property: %s.\", property)}\n\t}\n\n\tvar res interface{}\n\tvar row *sql.Row\n\tif collectionID != 0 {\n\t\trow = db.QueryRow(\"SELECT \"+selectQuery+\" FROM posts WHERE slug = ? AND collection_id = ? LIMIT 1\", id, collectionID)\n\t} else {\n\t\trow = db.QueryRow(\"SELECT \"+selectQuery+\" FROM posts WHERE id = ? LIMIT 1\", id)\n\t}\n\terr := row.Scan(&res)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, impart.HTTPError{http.StatusNotFound, \"Post not found.\"}\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting post: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n\nfunc (db *datastore) GetPostLikeCounts(postID string) (int64, error) {\n\tvar count int64\n\terr := db.QueryRow(\"SELECT COUNT(*) FROM remote_likes WHERE post_id = ?\", postID).Scan(&count)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\tcount = 0\n\tcase err != nil:\n\t\treturn 0, err\n\t}\n\treturn count, nil\n}\n\n// GetPostsCount modifies the CollectionObj to include the correct number of\n// standard (non-pinned) posts. It will return future posts if `includeFuture`\n// is true.\nfunc (db *datastore) GetPostsCount(c *CollectionObj, includeFuture bool) {\n\tvar count int64\n\ttimeCondition := \"\"\n\tif !includeFuture {\n\t\ttimeCondition = \"AND created <= \" + db.now()\n\t}\n\terr := db.QueryRow(\"SELECT COUNT(*) FROM posts WHERE collection_id = ? AND pinned_position IS NULL \"+timeCondition, c.ID).Scan(&count)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\tc.TotalPosts = 0\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting from collections: %v\", err)\n\t\tc.TotalPosts = 0\n\t}\n\n\tc.TotalPosts = int(count)\n}\n\n// GetPosts retrieves all posts for the given Collection.\n// It will return future posts if `includeFuture` is true.\n// It will include only standard (non-pinned) posts unless `includePinned` is true.\n// TODO: change includeFuture to isOwner, since that's how it's used\nfunc (db *datastore) GetPosts(cfg *config.Config, c *Collection, page int, includeFuture, forceRecentFirst, includePinned bool) (*[]PublicPost, error) {\n\tcollID := c.ID\n\n\tcf := c.NewFormat()\n\torder := \"DESC\"\n\tif cf.Ascending() && !forceRecentFirst {\n\t\torder = \"ASC\"\n\t}\n\n\tpagePosts := cf.PostsPerPage()\n\tstart := page*pagePosts - pagePosts\n\tif page == 0 {\n\t\tstart = 0\n\t\tpagePosts = 1000\n\t}\n\n\tlimitStr := \"\"\n\tif page > 0 {\n\t\tlimitStr = fmt.Sprintf(\" LIMIT %d, %d\", start, pagePosts)\n\t}\n\ttimeCondition := \"\"\n\tif !includeFuture {\n\t\ttimeCondition = \"AND created <= \" + db.now()\n\t}\n\tpinnedCondition := \"\"\n\tif !includePinned {\n\t\tpinnedCondition = \"AND pinned_position IS NULL\"\n\t}\n\trows, err := db.Query(\"SELECT \"+postCols+\" FROM posts WHERE collection_id = ? \"+pinnedCondition+\" \"+timeCondition+\" ORDER BY created \"+order+limitStr, collID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from posts: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve collection posts.\"}\n\t}\n\tdefer rows.Close()\n\n\t// TODO: extract this common row scanning logic for queries using `postCols`\n\tposts := []PublicPost{}\n\tfor rows.Next() {\n\t\tp := &Post{}\n\t\terr = rows.Scan(&p.ID, &p.Slug, &p.Font, &p.Language, &p.RTL, &p.Privacy, &p.OwnerID, &p.CollectionID, &p.PinnedPosition, &p.Created, &p.Updated, &p.ViewCount, &p.Title, &p.Content)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tp.extractData()\n\t\tp.augmentContent(c)\n\t\tp.formatContent(cfg, c, includeFuture, false)\n\n\t\tposts = append(posts, p.processPost())\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\treturn &posts, nil\n}\n\nfunc (db *datastore) GetAllPostsTaggedIDs(c *Collection, tag string, includeFuture bool) ([]string, error) {\n\tcollID := c.ID\n\n\tcf := c.NewFormat()\n\torder := \"DESC\"\n\tif cf.Ascending() {\n\t\torder = \"ASC\"\n\t}\n\n\ttimeCondition := \"\"\n\tif !includeFuture {\n\t\ttimeCondition = \"AND created <= \" + db.now()\n\t}\n\tvar rows *sql.Rows\n\tvar err error\n\tif db.driverName == driverSQLite {\n\t\trows, err = db.Query(\"SELECT id FROM posts WHERE collection_id = ? AND LOWER(content) regexp ? \"+timeCondition+\" ORDER BY created \"+order, collID, `.*#`+strings.ToLower(tag)+`\\b.*`)\n\t} else {\n\t\trows, err = db.Query(\"SELECT id FROM posts WHERE collection_id = ? AND LOWER(content) RLIKE ? \"+timeCondition+\" ORDER BY created \"+order, collID, \"#\"+strings.ToLower(tag)+\"[[:>:]]\")\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting tagged posts: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve tagged collection posts.\"}\n\t}\n\tdefer rows.Close()\n\n\tids := []string{}\n\tfor rows.Next() {\n\t\tvar id string\n\t\terr = rows.Scan(&id)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row: %v\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tids = append(ids, id)\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\treturn ids, nil\n}\n\n// GetPostsTagged retrieves all posts on the given Collection that contain the\n// given tag.\n// It will return future posts if `includeFuture` is true.\n// TODO: change includeFuture to isOwner, since that's how it's used\nfunc (db *datastore) GetPostsTagged(cfg *config.Config, c *Collection, tag string, page int, includeFuture bool) (*[]PublicPost, error) {\n\tcollID := c.ID\n\n\tcf := c.NewFormat()\n\torder := \"DESC\"\n\tif cf.Ascending() {\n\t\torder = \"ASC\"\n\t}\n\n\tpagePosts := cf.PostsPerPage()\n\tstart := page*pagePosts - pagePosts\n\tif page == 0 {\n\t\tstart = 0\n\t\tpagePosts = 1000\n\t}\n\n\tlimitStr := \"\"\n\tif page > 0 {\n\t\tlimitStr = fmt.Sprintf(\" LIMIT %d, %d\", start, pagePosts)\n\t}\n\ttimeCondition := \"\"\n\tif !includeFuture {\n\t\ttimeCondition = \"AND created <= \" + db.now()\n\t}\n\n\tvar rows *sql.Rows\n\tvar err error\n\tif db.driverName == driverSQLite {\n\t\trows, err = db.Query(\"SELECT \"+postCols+\" FROM posts WHERE collection_id = ? AND LOWER(content) regexp ? \"+timeCondition+\" ORDER BY created \"+order+limitStr, collID, `.*#`+strings.ToLower(tag)+`\\b.*`)\n\t} else {\n\t\trows, err = db.Query(\"SELECT \"+postCols+\" FROM posts WHERE collection_id = ? AND LOWER(content) RLIKE ? \"+timeCondition+\" ORDER BY created \"+order+limitStr, collID, \"#\"+strings.ToLower(tag)+\"[[:>:]]\")\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from posts: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve collection posts.\"}\n\t}\n\tdefer rows.Close()\n\n\t// TODO: extract this common row scanning logic for queries using `postCols`\n\tposts := []PublicPost{}\n\tfor rows.Next() {\n\t\tp := &Post{}\n\t\terr = rows.Scan(&p.ID, &p.Slug, &p.Font, &p.Language, &p.RTL, &p.Privacy, &p.OwnerID, &p.CollectionID, &p.PinnedPosition, &p.Created, &p.Updated, &p.ViewCount, &p.Title, &p.Content)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tp.extractData()\n\t\tp.augmentContent(c)\n\t\tp.formatContent(cfg, c, includeFuture, false)\n\n\t\tposts = append(posts, p.processPost())\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\treturn &posts, nil\n}\n\nfunc (db *datastore) GetCollLangTotalPosts(collID int64, lang string) (uint64, error) {\n\tvar articles uint64\n\terr := db.QueryRow(\"SELECT COUNT(*) FROM posts WHERE collection_id = ? AND language = ? AND created <= \"+db.now(), collID, lang).Scan(&articles)\n\tif err != nil && err != sql.ErrNoRows {\n\t\tlog.Error(\"Couldn't get total lang posts count for collection %d: %v\", collID, err)\n\t\treturn 0, err\n\t}\n\treturn articles, nil\n}\n\nfunc (db *datastore) GetLangPosts(cfg *config.Config, c *Collection, lang string, page int, includeFuture bool) (*[]PublicPost, error) {\n\tcollID := c.ID\n\n\tcf := c.NewFormat()\n\torder := \"DESC\"\n\tif cf.Ascending() {\n\t\torder = \"ASC\"\n\t}\n\n\tpagePosts := cf.PostsPerPage()\n\tstart := page*pagePosts - pagePosts\n\tif page == 0 {\n\t\tstart = 0\n\t\tpagePosts = 1000\n\t}\n\n\tlimitStr := \"\"\n\tif page > 0 {\n\t\tlimitStr = fmt.Sprintf(\" LIMIT %d, %d\", start, pagePosts)\n\t}\n\ttimeCondition := \"\"\n\tif !includeFuture {\n\t\ttimeCondition = \"AND created <= \" + db.now()\n\t}\n\n\trows, err := db.Query(`SELECT `+postCols+`\nFROM posts\nWHERE collection_id = ? AND language = ? `+timeCondition+`\nORDER BY created `+order+limitStr, collID, lang)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from posts: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve collection posts.\"}\n\t}\n\tdefer rows.Close()\n\n\t// TODO: extract this common row scanning logic for queries using `postCols`\n\tposts := []PublicPost{}\n\tfor rows.Next() {\n\t\tp := &Post{}\n\t\terr = rows.Scan(&p.ID, &p.Slug, &p.Font, &p.Language, &p.RTL, &p.Privacy, &p.OwnerID, &p.CollectionID, &p.PinnedPosition, &p.Created, &p.Updated, &p.ViewCount, &p.Title, &p.Content)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tp.extractData()\n\t\tp.augmentContent(c)\n\t\tp.formatContent(cfg, c, includeFuture, false)\n\n\t\tposts = append(posts, p.processPost())\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\treturn &posts, nil\n}\n\nfunc (db *datastore) GetAPFollowers(c *Collection) (*[]RemoteUser, error) {\n\trows, err := db.Query(\"SELECT actor_id, inbox, shared_inbox, f.created FROM remotefollows f INNER JOIN remoteusers u ON f.remote_user_id = u.id WHERE collection_id = ?\", c.ID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from followers: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve followers.\"}\n\t}\n\tdefer rows.Close()\n\n\tfollowers := []RemoteUser{}\n\tfor rows.Next() {\n\t\tf := RemoteUser{}\n\t\terr = rows.Scan(&f.ActorID, &f.Inbox, &f.SharedInbox, &f.Created)\n\t\tfollowers = append(followers, f)\n\t}\n\treturn &followers, nil\n}\n\n// CanCollect returns whether or not the given user can add the given post to a\n// collection. This is true when a post is already owned by the user.\n// NOTE: this is currently only used to potentially add owned posts to a\n// collection. This has the SIDE EFFECT of also generating a slug for the post.\n// FIXME: make this side effect more explicit (or extract it)\nfunc (db *datastore) CanCollect(cpr *ClaimPostRequest, userID int64) bool {\n\tvar title, content string\n\tvar lang sql.NullString\n\terr := db.QueryRow(\"SELECT title, content, language FROM posts WHERE id = ? AND owner_id = ?\", cpr.ID, userID).Scan(&title, &content, &lang)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn false\n\tcase err != nil:\n\t\tlog.Error(\"Failed on post CanCollect(%s, %d): %v\", cpr.ID, userID, err)\n\t\treturn false\n\t}\n\n\t// Since we have the post content and the post is collectable, generate the\n\t// post's slug now.\n\tcpr.Slug = getSlugFromPost(title, content, lang.String)\n\n\treturn true\n}\n\nfunc (db *datastore) AttemptClaim(p *ClaimPostRequest, query string, params []interface{}, slugIdx int) (sql.Result, error) {\n\tqRes, err := db.Exec(query, params...)\n\tif err != nil {\n\t\tif db.isDuplicateKeyErr(err) && slugIdx > -1 {\n\t\t\ts := id.GenSafeUniqueSlug(p.Slug)\n\t\t\tif s == p.Slug {\n\t\t\t\t// Sanity check to prevent infinite recursion\n\t\t\t\treturn qRes, fmt.Errorf(\"GenSafeUniqueSlug generated nothing unique: %s\", s)\n\t\t\t}\n\t\t\tp.Slug = s\n\t\t\tparams[slugIdx] = p.Slug\n\t\t\treturn db.AttemptClaim(p, query, params, slugIdx)\n\t\t}\n\t\treturn qRes, fmt.Errorf(\"attemptClaim: %s\", err)\n\t}\n\treturn qRes, nil\n}\n\nfunc (db *datastore) DispersePosts(userID int64, postIDs []string) (*[]ClaimPostResult, error) {\n\tpostClaimReqs := map[string]bool{}\n\tres := []ClaimPostResult{}\n\tfor i := range postIDs {\n\t\tpostID := postIDs[i]\n\n\t\tr := ClaimPostResult{Code: 0, ErrorMessage: \"\"}\n\n\t\t// Perform post validation\n\t\tif postID == \"\" {\n\t\t\tr.ErrorMessage = \"Missing post ID. \"\n\t\t}\n\t\tif _, ok := postClaimReqs[postID]; ok {\n\t\t\tr.Code = 429\n\t\t\tr.ErrorMessage = \"You've already tried anonymizing this post.\"\n\t\t\tr.ID = postID\n\t\t\tres = append(res, r)\n\t\t\tcontinue\n\t\t}\n\t\tpostClaimReqs[postID] = true\n\n\t\tvar err error\n\t\t// Get full post information to return\n\t\tvar fullPost *PublicPost\n\t\tfullPost, err = db.GetPost(postID, 0)\n\t\tif err != nil {\n\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\tr.Code = err.Status\n\t\t\t\tr.ErrorMessage = err.Message\n\t\t\t\tr.ID = postID\n\t\t\t\tres = append(res, r)\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tlog.Error(\"Error getting post in dispersePosts: %v\", err)\n\t\t\t}\n\t\t}\n\t\tif fullPost.OwnerID.Int64 != userID {\n\t\t\tr.Code = http.StatusConflict\n\t\t\tr.ErrorMessage = \"Post is already owned by someone else.\"\n\t\t\tr.ID = postID\n\t\t\tres = append(res, r)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar qRes sql.Result\n\t\tvar query string\n\t\tvar params []interface{}\n\t\t// Do AND owner_id = ? for sanity.\n\t\t// This should've been caught and returned with a good error message\n\t\t// just above.\n\t\tquery = \"UPDATE posts SET collection_id = NULL WHERE id = ? AND owner_id = ?\"\n\t\tparams = []interface{}{postID, userID}\n\t\tqRes, err = db.Exec(query, params...)\n\t\tif err != nil {\n\t\t\tr.Code = http.StatusInternalServerError\n\t\t\tr.ErrorMessage = \"A glitch happened on our end.\"\n\t\t\tr.ID = postID\n\t\t\tres = append(res, r)\n\t\t\tlog.Error(\"dispersePosts (post %s): %v\", postID, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Post was successfully dispersed\n\t\tr.Code = http.StatusOK\n\t\tr.Post = fullPost\n\n\t\trowsAffected, _ := qRes.RowsAffected()\n\t\tif rowsAffected == 0 {\n\t\t\t// This was already claimed, but return 200\n\t\t\tr.Code = http.StatusOK\n\t\t}\n\t\tres = append(res, r)\n\t}\n\n\treturn &res, nil\n}\n\nfunc (db *datastore) ClaimPosts(cfg *config.Config, userID int64, collAlias string, posts *[]ClaimPostRequest) (*[]ClaimPostResult, error) {\n\tpostClaimReqs := map[string]bool{}\n\tres := []ClaimPostResult{}\n\tpostCollAlias := collAlias\n\tfor i := range *posts {\n\t\tp := (*posts)[i]\n\t\tif &p == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tr := ClaimPostResult{Code: 0, ErrorMessage: \"\"}\n\n\t\t// Perform post validation\n\t\tif p.ID == \"\" {\n\t\t\tr.ErrorMessage = \"Missing post ID `id`. \"\n\t\t}\n\t\tif _, ok := postClaimReqs[p.ID]; ok {\n\t\t\tr.Code = 429\n\t\t\tr.ErrorMessage = \"You've already tried claiming this post.\"\n\t\t\tr.ID = p.ID\n\t\t\tres = append(res, r)\n\t\t\tcontinue\n\t\t}\n\t\tpostClaimReqs[p.ID] = true\n\n\t\tcanCollect := db.CanCollect(&p, userID)\n\t\tif !canCollect && p.Token == \"\" {\n\t\t\t// TODO: ensure post isn't owned by anyone else when a valid modify\n\t\t\t// token is given.\n\t\t\tr.ErrorMessage += \"Missing post Edit Token `token`.\"\n\t\t}\n\t\tif r.ErrorMessage != \"\" {\n\t\t\t// Post validate failed\n\t\t\tr.Code = http.StatusBadRequest\n\t\t\tr.ID = p.ID\n\t\t\tres = append(res, r)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar err error\n\t\tvar qRes sql.Result\n\t\tvar query string\n\t\tvar params []interface{}\n\t\tvar slugIdx int = -1\n\t\tvar coll *Collection\n\t\tif collAlias == \"\" {\n\t\t\t// Posts are being claimed at /posts/claim, not\n\t\t\t// /collections/{alias}/collect, so use given individual collection\n\t\t\t// to associate post with.\n\t\t\tpostCollAlias = p.CollectionAlias\n\t\t}\n\t\tif postCollAlias != \"\" {\n\t\t\t// Associate this post with a collection\n\t\t\tif p.CreateCollection {\n\t\t\t\t// This is a new collection\n\t\t\t\t// TODO: consider removing this. This seriously complicates this\n\t\t\t\t// method and adds another (unnecessary?) logic path.\n\t\t\t\tcoll, err = db.CreateCollection(cfg, postCollAlias, \"\", userID)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\t\t\tr.Code = err.Status\n\t\t\t\t\t\tr.ErrorMessage = err.Message\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr.Code = http.StatusInternalServerError\n\t\t\t\t\t\tr.ErrorMessage = \"Unknown error occurred creating collection\"\n\t\t\t\t\t}\n\t\t\t\t\tr.ID = p.ID\n\t\t\t\t\tres = append(res, r)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Attempt to add to existing collection\n\t\t\t\tcoll, err = db.GetCollection(postCollAlias)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\t\t\tif err.Status == http.StatusNotFound {\n\t\t\t\t\t\t\t// Show obfuscated \"forbidden\" response, as if attempting to add to an\n\t\t\t\t\t\t\t// unowned blog.\n\t\t\t\t\t\t\tr.Code = ErrForbiddenCollection.Status\n\t\t\t\t\t\t\tr.ErrorMessage = ErrForbiddenCollection.Message\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr.Code = err.Status\n\t\t\t\t\t\t\tr.ErrorMessage = err.Message\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr.Code = http.StatusInternalServerError\n\t\t\t\t\t\tr.ErrorMessage = \"Unknown error occurred claiming post with collection\"\n\t\t\t\t\t}\n\t\t\t\t\tr.ID = p.ID\n\t\t\t\t\tres = append(res, r)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif coll.OwnerID != userID {\n\t\t\t\t\tr.Code = ErrForbiddenCollection.Status\n\t\t\t\t\tr.ErrorMessage = ErrForbiddenCollection.Message\n\t\t\t\t\tr.ID = p.ID\n\t\t\t\t\tres = append(res, r)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif p.Slug == \"\" {\n\t\t\t\tp.Slug = p.ID\n\t\t\t}\n\t\t\tif canCollect {\n\t\t\t\t// User already owns this post, so just add it to the given\n\t\t\t\t// collection.\n\t\t\t\tquery = \"UPDATE posts SET collection_id = ?, slug = ? WHERE id = ? AND owner_id = ?\"\n\t\t\t\tparams = []interface{}{coll.ID, p.Slug, p.ID, userID}\n\t\t\t\tslugIdx = 1\n\t\t\t} else {\n\t\t\t\tquery = \"UPDATE posts SET owner_id = ?, collection_id = ?, slug = ? WHERE id = ? AND modify_token = ? AND owner_id IS NULL\"\n\t\t\t\tparams = []interface{}{userID, coll.ID, p.Slug, p.ID, p.Token}\n\t\t\t\tslugIdx = 2\n\t\t\t}\n\t\t} else {\n\t\t\tquery = \"UPDATE posts SET owner_id = ? WHERE id = ? AND modify_token = ? AND owner_id IS NULL\"\n\t\t\tparams = []interface{}{userID, p.ID, p.Token}\n\t\t}\n\t\tqRes, err = db.AttemptClaim(&p, query, params, slugIdx)\n\t\tif err != nil {\n\t\t\tr.Code = http.StatusInternalServerError\n\t\t\tr.ErrorMessage = \"An unknown error occurred.\"\n\t\t\tr.ID = p.ID\n\t\t\tres = append(res, r)\n\t\t\tlog.Error(\"claimPosts (post %s): %v\", p.ID, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get full post information to return\n\t\tvar fullPost *PublicPost\n\t\tif p.Token != \"\" {\n\t\t\tfullPost, err = db.GetEditablePost(p.ID, p.Token)\n\t\t} else {\n\t\t\tfullPost, err = db.GetPost(p.ID, 0)\n\t\t}\n\t\tif err != nil {\n\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\tr.Code = err.Status\n\t\t\t\tr.ErrorMessage = err.Message\n\t\t\t\tr.ID = p.ID\n\t\t\t\tres = append(res, r)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif fullPost.OwnerID.Int64 != userID {\n\t\t\tr.Code = http.StatusConflict\n\t\t\tr.ErrorMessage = \"Post is already owned by someone else.\"\n\t\t\tr.ID = p.ID\n\t\t\tres = append(res, r)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Post was successfully claimed\n\t\tr.Code = http.StatusOK\n\t\tr.Post = fullPost\n\t\tif coll != nil {\n\t\t\tr.Post.Collection = &CollectionObj{Collection: *coll}\n\t\t}\n\n\t\trowsAffected, _ := qRes.RowsAffected()\n\t\tif rowsAffected == 0 {\n\t\t\t// This was already claimed, but return 200\n\t\t\tr.Code = http.StatusOK\n\t\t}\n\t\tres = append(res, r)\n\t}\n\n\treturn &res, nil\n}\n\nfunc (db *datastore) UpdatePostPinState(pinned bool, postID string, collID, ownerID, pos int64) error {\n\tif pos <= 0 || pos > 20 {\n\t\tpos = db.GetLastPinnedPostPos(collID) + 1\n\t\tif pos == -1 {\n\t\t\tpos = 1\n\t\t}\n\t}\n\tvar err error\n\tif pinned {\n\t\t_, err = db.Exec(\"UPDATE posts SET pinned_position = ? WHERE id = ?\", pos, postID)\n\t} else {\n\t\t_, err = db.Exec(\"UPDATE posts SET pinned_position = NULL WHERE id = ?\", postID)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Unable to update pinned post: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (db *datastore) GetLastPinnedPostPos(collID int64) int64 {\n\tvar lastPos sql.NullInt64\n\terr := db.QueryRow(\"SELECT MAX(pinned_position) FROM posts WHERE collection_id = ? AND pinned_position IS NOT NULL\", collID).Scan(&lastPos)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn -1\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting from posts: %v\", err)\n\t\treturn -1\n\t}\n\tif !lastPos.Valid {\n\t\treturn -1\n\t}\n\treturn lastPos.Int64\n}\n\nfunc (db *datastore) GetPinnedPosts(coll *CollectionObj, includeFuture bool) (*[]PublicPost, error) {\n\t// FIXME: sqlite-backed instances don't include ellipsis on truncated titles\n\ttimeCondition := \"\"\n\tif !includeFuture {\n\t\ttimeCondition = \"AND created <= \" + db.now()\n\t}\n\trows, err := db.Query(\"SELECT id, slug, title, \"+db.clip(\"content\", 80)+\", pinned_position FROM posts WHERE collection_id = ? AND pinned_position IS NOT NULL \"+timeCondition+\" ORDER BY pinned_position ASC\", coll.ID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting pinned posts: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve pinned posts.\"}\n\t}\n\tdefer rows.Close()\n\n\tposts := []PublicPost{}\n\tfor rows.Next() {\n\t\tp := &Post{}\n\t\terr = rows.Scan(&p.ID, &p.Slug, &p.Title, &p.Content, &p.PinnedPosition)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tp.extractData()\n\t\tp.augmentContent(&coll.Collection)\n\n\t\tpp := p.processPost()\n\t\tpp.Collection = coll\n\t\tposts = append(posts, pp)\n\t}\n\treturn &posts, nil\n}\n\nfunc (db *datastore) GetCollections(u *User, hostName string) (*[]Collection, error) {\n\trows, err := db.Query(\"SELECT id, alias, title, description, privacy, view_count FROM collections WHERE owner_id = ? ORDER BY id ASC\", u.ID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from collections: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve user collections.\"}\n\t}\n\tdefer rows.Close()\n\n\tcolls := []Collection{}\n\tfor rows.Next() {\n\t\tc := Collection{}\n\t\terr = rows.Scan(&c.ID, &c.Alias, &c.Title, &c.Description, &c.Visibility, &c.Views)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tc.hostName = hostName\n\t\tc.URL = c.CanonicalURL()\n\t\tc.Public = c.IsPublic()\n\n\t\t/*\n\t\t\t// NOTE: future functionality\n\t\t\tif visibility != nil { // TODO: && visibility == CollPublic {\n\t\t\t\t// Add Monetization info when retrieving all public collections\n\t\t\t\tc.Monetization = db.GetCollectionAttribute(c.ID, \"monetization_pointer\")\n\t\t\t}\n\t\t*/\n\n\t\tcolls = append(colls, c)\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\treturn &colls, nil\n}\n\nfunc (db *datastore) GetPublishableCollections(u *User, hostName string) (*[]Collection, error) {\n\tc, err := db.GetCollections(u, hostName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(*c) == 0 {\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"You don't seem to have any blogs; they might've moved to another account. Try logging out and logging into your other account.\"}\n\t}\n\treturn c, nil\n}\n\nfunc (db *datastore) GetPublicCollections(hostName string) (*[]Collection, error) {\n\trows, err := db.Query(`SELECT c.id, alias, title, description, privacy, view_count\n\tFROM collections c\n\tLEFT JOIN users u ON u.id = c.owner_id\n\tWHERE c.privacy = 1 AND u.status = 0\n\tORDER BY title ASC`)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting public collections: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve public collections.\"}\n\t}\n\tdefer rows.Close()\n\n\tcolls := []Collection{}\n\tfor rows.Next() {\n\t\tc := Collection{}\n\t\terr = rows.Scan(&c.ID, &c.Alias, &c.Title, &c.Description, &c.Visibility, &c.Views)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tc.hostName = hostName\n\t\tc.URL = c.CanonicalURL()\n\t\tc.Public = c.IsPublic()\n\n\t\t// Add Monetization information\n\t\tc.Monetization = db.GetCollectionAttribute(c.ID, \"monetization_pointer\")\n\n\t\tcolls = append(colls, c)\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\treturn &colls, nil\n}\n\nfunc (db *datastore) GetMeStats(u *User) userMeStats {\n\ts := userMeStats{}\n\n\t// User counts\n\tcolls, _ := db.GetUserCollectionCount(u.ID)\n\ts.TotalCollections = colls\n\n\tvar articles, collPosts uint64\n\terr := db.QueryRow(\"SELECT COUNT(*) FROM posts WHERE owner_id = ? AND collection_id IS NULL\", u.ID).Scan(&articles)\n\tif err != nil && err != sql.ErrNoRows {\n\t\tlog.Error(\"Couldn't get articles count for user %d: %v\", u.ID, err)\n\t}\n\ts.TotalArticles = articles\n\n\terr = db.QueryRow(\"SELECT COUNT(*) FROM posts WHERE owner_id = ? AND collection_id IS NOT NULL\", u.ID).Scan(&collPosts)\n\tif err != nil && err != sql.ErrNoRows {\n\t\tlog.Error(\"Couldn't get coll posts count for user %d: %v\", u.ID, err)\n\t}\n\ts.CollectionPosts = collPosts\n\n\treturn s\n}\n\nfunc (db *datastore) GetTotalCollections() (collCount int64, err error) {\n\terr = db.QueryRow(`\n\tSELECT COUNT(*) \n\tFROM collections c\n\tLEFT JOIN users u ON u.id = c.owner_id\n\tWHERE u.status = 0`).Scan(&collCount)\n\tif err != nil {\n\t\tlog.Error(\"Unable to fetch collections count: %v\", err)\n\t}\n\treturn\n}\n\nfunc (db *datastore) GetTotalPosts() (postCount int64, err error) {\n\terr = db.QueryRow(`\n\tSELECT COUNT(*)\n\tFROM posts p\n\tLEFT JOIN users u ON u.id = p.owner_id\n\tWHERE u.status = 0`).Scan(&postCount)\n\tif err != nil {\n\t\tlog.Error(\"Unable to fetch posts count: %v\", err)\n\t}\n\treturn\n}\n\nfunc (db *datastore) GetTopPosts(u *User, alias string, hostName string) (*[]PublicPost, error) {\n\tparams := []interface{}{u.ID}\n\twhere := \"\"\n\tif alias != \"\" {\n\t\twhere = \" AND alias = ?\"\n\t\tparams = append(params, alias)\n\t}\n\trows, err := db.Query(\"SELECT p.id, p.slug, p.view_count, p.title, p.content, c.alias, c.title, c.description, c.view_count FROM posts p LEFT JOIN collections c ON p.collection_id = c.id WHERE p.owner_id = ?\"+where+\" ORDER BY p.view_count DESC, created DESC LIMIT 25\", params...)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from posts: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve user top posts.\"}\n\t}\n\tdefer rows.Close()\n\n\tposts := []PublicPost{}\n\tvar gotErr bool\n\tfor rows.Next() {\n\t\tp := Post{}\n\t\tc := Collection{}\n\t\tvar alias, title, description sql.NullString\n\t\tvar views sql.NullInt64\n\t\terr = rows.Scan(&p.ID, &p.Slug, &p.ViewCount, &p.Title, &p.Content, &alias, &title, &description, &views)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning User.getPosts() row: %v\", err)\n\t\t\tgotErr = true\n\t\t\tbreak\n\t\t}\n\t\tp.extractData()\n\t\tpubPost := p.processPost()\n\n\t\tif alias.Valid && alias.String != \"\" {\n\t\t\tc.Alias = alias.String\n\t\t\tc.Title = title.String\n\t\t\tc.Description = description.String\n\t\t\tc.Views = views.Int64\n\t\t\tc.hostName = hostName\n\t\t\tpubPost.Collection = &CollectionObj{Collection: c}\n\t\t}\n\n\t\tposts = append(posts, pubPost)\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\tif gotErr && len(posts) == 0 {\n\t\t// There were a lot of errors\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Unable to get data.\"}\n\t}\n\n\treturn &posts, nil\n}\n\nfunc (db *datastore) GetAnonymousPosts(u *User, page int) (*[]PublicPost, error) {\n\tpagePosts := 10\n\tstart := page*pagePosts - pagePosts\n\tif page == 0 {\n\t\tstart = 0\n\t\tpagePosts = 1000\n\t}\n\n\tlimitStr := \"\"\n\tif page > 0 {\n\t\tlimitStr = fmt.Sprintf(\" LIMIT %d, %d\", start, pagePosts)\n\t}\n\trows, err := db.Query(\"SELECT id, view_count, title, language, created, updated, content FROM posts WHERE owner_id = ? AND collection_id IS NULL ORDER BY created DESC\"+limitStr, u.ID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from posts: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve user anonymous posts.\"}\n\t}\n\tdefer rows.Close()\n\n\tposts := []PublicPost{}\n\tfor rows.Next() {\n\t\tp := Post{}\n\t\terr = rows.Scan(&p.ID, &p.ViewCount, &p.Title, &p.Language, &p.Created, &p.Updated, &p.Content)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tp.extractData()\n\n\t\tposts = append(posts, p.processPost())\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\treturn &posts, nil\n}\n\nfunc (db *datastore) GetUserPosts(u *User) (*[]PublicPost, error) {\n\trows, err := db.Query(\"SELECT p.id, p.slug, p.view_count, p.title, p.created, p.updated, p.content, p.text_appearance, p.language, p.rtl, c.alias, c.title, c.description, c.view_count FROM posts p LEFT JOIN collections c ON collection_id = c.id WHERE p.owner_id = ? ORDER BY created ASC\", u.ID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from posts: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve user posts.\"}\n\t}\n\tdefer rows.Close()\n\n\tposts := []PublicPost{}\n\tvar gotErr bool\n\tfor rows.Next() {\n\t\tp := Post{}\n\t\tc := Collection{}\n\t\tvar alias, title, description sql.NullString\n\t\tvar views sql.NullInt64\n\t\terr = rows.Scan(&p.ID, &p.Slug, &p.ViewCount, &p.Title, &p.Created, &p.Updated, &p.Content, &p.Font, &p.Language, &p.RTL, &alias, &title, &description, &views)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning User.getPosts() row: %v\", err)\n\t\t\tgotErr = true\n\t\t\tbreak\n\t\t}\n\t\tp.extractData()\n\t\tpubPost := p.processPost()\n\n\t\tif alias.Valid && alias.String != \"\" {\n\t\t\tc.Alias = alias.String\n\t\t\tc.Title = title.String\n\t\t\tc.Description = description.String\n\t\t\tc.Views = views.Int64\n\t\t\tpubPost.Collection = &CollectionObj{Collection: c}\n\t\t}\n\n\t\tposts = append(posts, pubPost)\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\tif gotErr && len(posts) == 0 {\n\t\t// There were a lot of errors\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Unable to get data.\"}\n\t}\n\n\treturn &posts, nil\n}\n\nfunc (db *datastore) GetUserPostsCount(userID int64) int64 {\n\tvar count int64\n\terr := db.QueryRow(\"SELECT COUNT(*) FROM posts WHERE owner_id = ?\", userID).Scan(&count)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn 0\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting posts count for user %d: %v\", userID, err)\n\t\treturn 0\n\t}\n\n\treturn count\n}\n\n// ChangeSettings takes a User and applies the changes in the given\n// userSettings, MODIFYING THE USER with successful changes.\nfunc (db *datastore) ChangeSettings(app *App, u *User, s *userSettings) error {\n\tvar errPass error\n\tq := query.NewUpdate()\n\n\t// Update email if given\n\tif s.Email != \"\" {\n\t\tencEmail, err := data.Encrypt(app.keys.EmailKey, s.Email)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't encrypt email %s: %s\\n\", s.Email, err)\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, \"Unable to encrypt email address.\"}\n\t\t}\n\t\tq.SetBytes(encEmail, \"email\")\n\n\t\t// Update the email if something goes awry updating the password\n\t\tdefer func() {\n\t\t\tif errPass != nil {\n\t\t\t\tdb.UpdateEncryptedUserEmail(u.ID, encEmail)\n\t\t\t}\n\t\t}()\n\t\tu.Email = zero.StringFrom(s.Email)\n\t}\n\n\t// Update username if given\n\tvar newUsername string\n\tif s.Username != \"\" {\n\t\tvar ie *impart.HTTPError\n\t\tnewUsername, ie = getValidUsername(app, s.Username, u.Username)\n\t\tif ie != nil {\n\t\t\t// Username is invalid\n\t\t\treturn *ie\n\t\t}\n\t\tif !author.IsValidUsername(app.cfg, newUsername) {\n\t\t\t// Ensure the username is syntactically correct.\n\t\t\treturn impart.HTTPError{http.StatusPreconditionFailed, \"Username isn't valid.\"}\n\t\t}\n\n\t\tt, err := db.Begin()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't start username change transaction: %v\", err)\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = t.Exec(\"UPDATE users SET username = ? WHERE id = ?\", newUsername, u.ID)\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tif db.isDuplicateKeyErr(err) {\n\t\t\t\treturn impart.HTTPError{http.StatusConflict, \"Username is already taken.\"}\n\t\t\t}\n\t\t\tlog.Error(\"Unable to update users table: %v\", err)\n\t\t\treturn ErrInternalGeneral\n\t\t}\n\n\t\t_, err = t.Exec(\"UPDATE collections SET alias = ? WHERE alias = ? AND owner_id = ?\", newUsername, u.Username, u.ID)\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tif db.isDuplicateKeyErr(err) {\n\t\t\t\treturn impart.HTTPError{http.StatusConflict, \"Username is already taken.\"}\n\t\t\t}\n\t\t\tlog.Error(\"Unable to update collection: %v\", err)\n\t\t\treturn ErrInternalGeneral\n\t\t}\n\n\t\t// Keep track of name changes for redirection\n\t\tdb.RemoveCollectionRedirect(t, newUsername)\n\t\t_, err = t.Exec(\"UPDATE collectionredirects SET new_alias = ? WHERE new_alias = ?\", newUsername, u.Username)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to update collectionredirects: %v\", err)\n\t\t}\n\t\t_, err = t.Exec(\"INSERT INTO collectionredirects (prev_alias, new_alias) VALUES (?, ?)\", u.Username, newUsername)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to add new collectionredirect: %v\", err)\n\t\t}\n\n\t\terr = t.Commit()\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Rolling back after Commit(): %v\\n\", err)\n\t\t\treturn err\n\t\t}\n\n\t\tu.Username = newUsername\n\t}\n\n\t// Update passphrase if given\n\tif s.NewPass != \"\" {\n\t\t// Check if user has already set a password\n\t\tvar err error\n\t\tu.HasPass, err = db.IsUserPassSet(u.ID)\n\t\tif err != nil {\n\t\t\terrPass = impart.HTTPError{http.StatusInternalServerError, \"Unable to retrieve user data.\"}\n\t\t\treturn errPass\n\t\t}\n\n\t\tif u.HasPass {\n\t\t\t// Check if currently-set password is correct\n\t\t\thashedPass := u.HashedPass\n\t\t\tif len(hashedPass) == 0 {\n\t\t\t\tauthUser, err := db.GetUserForAuthByID(u.ID)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrPass = err\n\t\t\t\t\treturn errPass\n\t\t\t\t}\n\t\t\t\thashedPass = authUser.HashedPass\n\t\t\t}\n\t\t\tif !auth.Authenticated(hashedPass, []byte(s.OldPass)) {\n\t\t\t\terrPass = impart.HTTPError{http.StatusUnauthorized, \"Incorrect password.\"}\n\t\t\t\treturn errPass\n\t\t\t}\n\t\t}\n\t\thashedPass, err := auth.HashPass([]byte(s.NewPass))\n\t\tif err != nil {\n\t\t\terrPass = impart.HTTPError{http.StatusInternalServerError, \"Could not create password hash.\"}\n\t\t\treturn errPass\n\t\t}\n\t\tq.SetBytes(hashedPass, \"password\")\n\t}\n\n\t// WHERE values\n\tq.Append(u.ID)\n\n\tif q.Updates == \"\" {\n\t\tif s.Username == \"\" {\n\t\t\treturn ErrPostNoUpdatableVals\n\t\t}\n\n\t\t// Nothing to update except username. That was successful, so return now.\n\t\treturn nil\n\t}\n\n\tres, err := db.Exec(\"UPDATE users SET \"+q.Updates+\" WHERE id = ?\", q.Params...)\n\tif err != nil {\n\t\tlog.Error(\"Unable to update collection: %v\", err)\n\t\treturn err\n\t}\n\n\trowsAffected, _ := res.RowsAffected()\n\tif rowsAffected == 0 {\n\t\t// Show the correct error message if nothing was updated\n\t\tvar dummy int\n\t\terr := db.QueryRow(\"SELECT 1 FROM users WHERE id = ?\", u.ID).Scan(&dummy)\n\t\tswitch {\n\t\tcase err == sql.ErrNoRows:\n\t\t\treturn ErrUnauthorizedGeneral\n\t\tcase err != nil:\n\t\t\tlog.Error(\"Failed selecting from users: %v\", err)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif s.NewPass != \"\" && !u.HasPass {\n\t\tu.HasPass = true\n\t}\n\n\treturn nil\n}\n\nfunc (db *datastore) ChangePassphrase(userID int64, sudo bool, curPass string, hashedPass []byte) error {\n\tvar dbPass []byte\n\terr := db.QueryRow(\"SELECT password FROM users WHERE id = ?\", userID).Scan(&dbPass)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn ErrUserNotFound\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT user password for change: %v\", err)\n\t\treturn err\n\t}\n\n\tif !sudo && !auth.Authenticated(dbPass, []byte(curPass)) {\n\t\treturn impart.HTTPError{http.StatusUnauthorized, \"Incorrect password.\"}\n\t}\n\n\t_, err = db.Exec(\"UPDATE users SET password = ? WHERE id = ?\", hashedPass, userID)\n\tif err != nil {\n\t\tlog.Error(\"Could not update passphrase: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (db *datastore) RemoveCollectionRedirect(t *sql.Tx, alias string) error {\n\t_, err := t.Exec(\"DELETE FROM collectionredirects WHERE prev_alias = ?\", alias)\n\tif err != nil {\n\t\tlog.Error(\"Unable to delete from collectionredirects: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (db *datastore) GetCollectionRedirect(alias string) (new string) {\n\trow := db.QueryRow(\"SELECT new_alias FROM collectionredirects WHERE prev_alias = ?\", alias)\n\terr := row.Scan(&new)\n\tif err != nil && err != sql.ErrNoRows && !db.isIgnorableError(err) {\n\t\tlog.Error(\"Failed selecting from collectionredirects: %v\", err)\n\t}\n\treturn\n}\n\nfunc (db *datastore) DeleteCollection(alias string, userID int64) error {\n\tc := &Collection{Alias: alias}\n\tvar username string\n\n\trow := db.QueryRow(\"SELECT username FROM users WHERE id = ?\", userID)\n\terr := row.Scan(&username)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Ensure user isn't deleting their main blog\n\tif alias == username {\n\t\treturn impart.HTTPError{http.StatusForbidden, \"You cannot currently delete your primary blog.\"}\n\t}\n\n\trow = db.QueryRow(\"SELECT id FROM collections WHERE alias = ? AND owner_id = ?\", alias, userID)\n\terr = row.Scan(&c.ID)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn impart.HTTPError{http.StatusNotFound, \"Collection doesn't exist or you're not allowed to delete it.\"}\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting from collections: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\n\tt, err := db.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Float all collection's posts\n\t_, err = t.Exec(\"UPDATE posts SET collection_id = NULL WHERE collection_id = ? AND owner_id = ?\", c.ID, userID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\treturn err\n\t}\n\n\t// Remove redirects to or from this collection\n\t_, err = t.Exec(\"DELETE FROM collectionredirects WHERE prev_alias = ? OR new_alias = ?\", alias, alias)\n\tif err != nil {\n\t\tt.Rollback()\n\t\treturn err\n\t}\n\n\t// Remove any optional collection password\n\t_, err = t.Exec(\"DELETE FROM collectionpasswords WHERE collection_id = ?\", c.ID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\treturn err\n\t}\n\n\t// Finally, delete collection itself\n\t_, err = t.Exec(\"DELETE FROM collections WHERE id = ?\", c.ID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\treturn err\n\t}\n\n\terr = t.Commit()\n\tif err != nil {\n\t\tt.Rollback()\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (db *datastore) IsCollectionAttributeOn(id int64, attr string) bool {\n\tvar v string\n\terr := db.QueryRow(\"SELECT value FROM collectionattributes WHERE collection_id = ? AND attribute = ?\", id, attr).Scan(&v)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn false\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT value in isCollectionAttributeOn for attribute '%s': %v\", attr, err)\n\t\treturn false\n\t}\n\treturn v == \"1\"\n}\n\nfunc (db *datastore) CollectionHasAttribute(id int64, attr string) bool {\n\tvar dummy string\n\terr := db.QueryRow(\"SELECT value FROM collectionattributes WHERE collection_id = ? AND attribute = ?\", id, attr).Scan(&dummy)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn false\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT value in collectionHasAttribute for attribute '%s': %v\", attr, err)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (db *datastore) GetCollectionAttribute(id int64, attr string) string {\n\tvar v string\n\terr := db.QueryRow(\"SELECT value FROM collectionattributes WHERE collection_id = ? AND attribute = ?\", id, attr).Scan(&v)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn \"\"\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT value in getCollectionAttribute for attribute '%s': %v\", attr, err)\n\t\treturn \"\"\n\t}\n\treturn v\n}\n\nfunc (db *datastore) SetCollectionAttribute(id int64, attr, v string) error {\n\t_, err := db.Exec(\"INSERT INTO collectionattributes (collection_id, attribute, value) VALUES (?, ?, ?) \"+db.upsert(\"collection_id\", \"attribute\")+\" value = ?\", id, attr, v, v)\n\tif err != nil {\n\t\tlog.Error(\"Unable to INSERT into collectionattributes: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// DeleteAccount will delete the entire account for userID\nfunc (db *datastore) DeleteAccount(userID int64) error {\n\t// Get all collections\n\trows, err := db.Query(\"SELECT id, alias FROM collections WHERE owner_id = ?\", userID)\n\tif err != nil {\n\t\tlog.Error(\"Unable to get collections: %v\", err)\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\tcolls := []Collection{}\n\tvar c Collection\n\tfor rows.Next() {\n\t\terr = rows.Scan(&c.ID, &c.Alias)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to scan collection cols: %v\", err)\n\t\t\treturn err\n\t\t}\n\t\tcolls = append(colls, c)\n\t}\n\n\t// Start transaction\n\tt, err := db.Begin()\n\tif err != nil {\n\t\tlog.Error(\"Unable to begin: %v\", err)\n\t\treturn err\n\t}\n\n\t// Clean up all collection related information\n\tvar res sql.Result\n\tfor _, c := range colls {\n\t\t// Delete tokens\n\t\tres, err = t.Exec(\"DELETE FROM collectionattributes WHERE collection_id = ?\", c.ID)\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Unable to delete attributes on %s: %v\", c.Alias, err)\n\t\t\treturn err\n\t\t}\n\t\trs, _ := res.RowsAffected()\n\t\tlog.Info(\"Deleted %d for %s from collectionattributes\", rs, c.Alias)\n\n\t\t// Remove any optional collection password\n\t\tres, err = t.Exec(\"DELETE FROM collectionpasswords WHERE collection_id = ?\", c.ID)\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Unable to delete passwords on %s: %v\", c.Alias, err)\n\t\t\treturn err\n\t\t}\n\t\trs, _ = res.RowsAffected()\n\t\tlog.Info(\"Deleted %d for %s from collectionpasswords\", rs, c.Alias)\n\n\t\t// Remove redirects to this collection\n\t\tres, err = t.Exec(\"DELETE FROM collectionredirects WHERE new_alias = ?\", c.Alias)\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Unable to delete redirects on %s: %v\", c.Alias, err)\n\t\t\treturn err\n\t\t}\n\t\trs, _ = res.RowsAffected()\n\t\tlog.Info(\"Deleted %d for %s from collectionredirects\", rs, c.Alias)\n\n\t\t// Remove any collection keys\n\t\tres, err = t.Exec(\"DELETE FROM collectionkeys WHERE collection_id = ?\", c.ID)\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Unable to delete keys on %s: %v\", c.Alias, err)\n\t\t\treturn err\n\t\t}\n\t\trs, _ = res.RowsAffected()\n\t\tlog.Info(\"Deleted %d for %s from collectionkeys\", rs, c.Alias)\n\n\t\t// TODO: federate delete collection\n\n\t\t// Remove remote follows\n\t\tres, err = t.Exec(\"DELETE FROM remotefollows WHERE collection_id = ?\", c.ID)\n\t\tif err != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Unable to delete remote follows on %s: %v\", c.Alias, err)\n\t\t\treturn err\n\t\t}\n\t\trs, _ = res.RowsAffected()\n\t\tlog.Info(\"Deleted %d for %s from remotefollows\", rs, c.Alias)\n\t}\n\n\t// Delete collections\n\tres, err = t.Exec(\"DELETE FROM collections WHERE owner_id = ?\", userID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Unable to delete collections: %v\", err)\n\t\treturn err\n\t}\n\trs, _ := res.RowsAffected()\n\tlog.Info(\"Deleted %d from collections\", rs)\n\n\t// Delete tokens\n\tres, err = t.Exec(\"DELETE FROM accesstokens WHERE user_id = ?\", userID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Unable to delete access tokens: %v\", err)\n\t\treturn err\n\t}\n\trs, _ = res.RowsAffected()\n\tlog.Info(\"Deleted %d from accesstokens\", rs)\n\n\t// Delete user attributes\n\tres, err = t.Exec(\"DELETE FROM oauth_users WHERE user_id = ?\", userID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Unable to delete oauth_users: %v\", err)\n\t\treturn err\n\t}\n\trs, _ = res.RowsAffected()\n\tlog.Info(\"Deleted %d from oauth_users\", rs)\n\n\t// Delete posts\n\t// TODO: should maybe get each row so we can federate a delete\n\t// if so needs to be outside of transaction like collections\n\tres, err = t.Exec(\"DELETE FROM posts WHERE owner_id = ?\", userID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Unable to delete posts: %v\", err)\n\t\treturn err\n\t}\n\trs, _ = res.RowsAffected()\n\tlog.Info(\"Deleted %d from posts\", rs)\n\n\t// Delete user attributes\n\tres, err = t.Exec(\"DELETE FROM userattributes WHERE user_id = ?\", userID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Unable to delete attributes: %v\", err)\n\t\treturn err\n\t}\n\trs, _ = res.RowsAffected()\n\tlog.Info(\"Deleted %d from userattributes\", rs)\n\n\t// Delete user invites\n\tres, err = t.Exec(\"DELETE FROM userinvites WHERE owner_id = ?\", userID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Unable to delete invites: %v\", err)\n\t\treturn err\n\t}\n\trs, _ = res.RowsAffected()\n\tlog.Info(\"Deleted %d from userinvites\", rs)\n\n\t// Delete the user\n\tres, err = t.Exec(\"DELETE FROM users WHERE id = ?\", userID)\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Unable to delete user: %v\", err)\n\t\treturn err\n\t}\n\trs, _ = res.RowsAffected()\n\tlog.Info(\"Deleted %d from users\", rs)\n\n\t// Commit all changes to the database\n\terr = t.Commit()\n\tif err != nil {\n\t\tt.Rollback()\n\t\tlog.Error(\"Unable to commit: %v\", err)\n\t\treturn err\n\t}\n\n\t// TODO: federate delete actor\n\n\treturn nil\n}\n\nfunc (db *datastore) GetAPActorKeys(collectionID int64) ([]byte, []byte) {\n\tvar pub, priv []byte\n\terr := db.QueryRow(\"SELECT public_key, private_key FROM collectionkeys WHERE collection_id = ?\", collectionID).Scan(&pub, &priv)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\t// Generate keys\n\t\tpub, priv = activitypub.GenerateKeys()\n\t\t_, err = db.Exec(\"INSERT INTO collectionkeys (collection_id, public_key, private_key) VALUES (?, ?, ?)\", collectionID, pub, priv)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to INSERT new activitypub keypair: %v\", err)\n\t\t\treturn nil, nil\n\t\t}\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT collectionkeys: %v\", err)\n\t\treturn nil, nil\n\t}\n\n\treturn pub, priv\n}\n\nfunc (db *datastore) CreateUserInvite(id string, userID int64, maxUses int, expires *time.Time) error {\n\t_, err := db.Exec(\"INSERT INTO userinvites (id, owner_id, max_uses, created, expires, inactive) VALUES (?, ?, ?, \"+db.now()+\", ?, 0)\", id, userID, maxUses, expires)\n\treturn err\n}\n\nfunc (db *datastore) GetUserInvites(userID int64) (*[]Invite, error) {\n\trows, err := db.Query(\"SELECT id, max_uses, created, expires, inactive FROM userinvites WHERE owner_id = ? ORDER BY created DESC\", userID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from userinvites: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve user invites.\"}\n\t}\n\tdefer rows.Close()\n\n\tis := []Invite{}\n\tfor rows.Next() {\n\t\ti := Invite{}\n\t\terr = rows.Scan(&i.ID, &i.MaxUses, &i.Created, &i.Expires, &i.Inactive)\n\t\tis = append(is, i)\n\t}\n\treturn &is, nil\n}\n\nfunc (db *datastore) GetUserInvite(id string) (*Invite, error) {\n\tvar i Invite\n\terr := db.QueryRow(\"SELECT id, max_uses, created, expires, inactive FROM userinvites WHERE id = ?\", id).Scan(&i.ID, &i.MaxUses, &i.Created, &i.Expires, &i.Inactive)\n\tswitch {\n\tcase err == sql.ErrNoRows, db.isIgnorableError(err):\n\t\treturn nil, impart.HTTPError{http.StatusNotFound, \"Invite doesn't exist.\"}\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting invite: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn &i, nil\n}\n\n// IsUsersInvite returns true if the user with ID created the invite with code\n// and an error other than sql no rows, if any. Will return false in the event\n// of an error.\nfunc (db *datastore) IsUsersInvite(code string, userID int64) (bool, error) {\n\tvar id string\n\terr := db.QueryRow(\"SELECT id FROM userinvites WHERE id = ? AND owner_id = ?\", code, userID).Scan(&id)\n\tif err != nil && err != sql.ErrNoRows {\n\t\tlog.Error(\"Failed selecting invite: %v\", err)\n\t\treturn false, err\n\t}\n\treturn id != \"\", nil\n}\n\nfunc (db *datastore) GetUsersInvitedCount(id string) int64 {\n\tvar count int64\n\terr := db.QueryRow(\"SELECT COUNT(*) FROM usersinvited WHERE invite_id = ?\", id).Scan(&count)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn 0\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting users invited count: %v\", err)\n\t\treturn 0\n\t}\n\n\treturn count\n}\n\nfunc (db *datastore) CreateInvitedUser(inviteID string, userID int64) error {\n\t_, err := db.Exec(\"INSERT INTO usersinvited (invite_id, user_id) VALUES (?, ?)\", inviteID, userID)\n\treturn err\n}\n\nfunc (db *datastore) GetInstancePages() ([]*instanceContent, error) {\n\treturn db.GetAllDynamicContent(\"page\")\n}\n\nfunc (db *datastore) GetAllDynamicContent(t string) ([]*instanceContent, error) {\n\twhere := \"\"\n\tparams := []interface{}{}\n\tif t != \"\" {\n\t\twhere = \" WHERE content_type = ?\"\n\t\tparams = append(params, t)\n\t}\n\trows, err := db.Query(\"SELECT id, title, content, updated, content_type FROM appcontent\"+where, params...)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from appcontent: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve instance pages.\"}\n\t}\n\tdefer rows.Close()\n\n\tpages := []*instanceContent{}\n\tfor rows.Next() {\n\t\tc := &instanceContent{}\n\t\terr = rows.Scan(&c.ID, &c.Title, &c.Content, &c.Updated, &c.Type)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tpages = append(pages, c)\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.Error(\"Error after Next() on rows: %v\", err)\n\t}\n\n\treturn pages, nil\n}\n\nfunc (db *datastore) GetDynamicContent(id string) (*instanceContent, error) {\n\tc := &instanceContent{\n\t\tID: id,\n\t}\n\terr := db.QueryRow(\"SELECT title, content, updated, content_type FROM appcontent WHERE id = ?\", id).Scan(&c.Title, &c.Content, &c.Updated, &c.Type)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, nil\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT FROM appcontent for id '%s': %v\", id, err)\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\nfunc (db *datastore) UpdateDynamicContent(id, title, content, contentType string) error {\n\tvar err error\n\tif db.driverName == driverSQLite {\n\t\t_, err = db.Exec(\"INSERT OR REPLACE INTO appcontent (id, title, content, updated, content_type) VALUES (?, ?, ?, \"+db.now()+\", ?)\", id, title, content, contentType)\n\t} else {\n\t\t_, err = db.Exec(\"INSERT INTO appcontent (id, title, content, updated, content_type) VALUES (?, ?, ?, \"+db.now()+\", ?) \"+db.upsert(\"id\")+\" title = ?, content = ?, updated = \"+db.now(), id, title, content, contentType, title, content)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Unable to INSERT appcontent for '%s': %v\", id, err)\n\t}\n\treturn err\n}\n\nfunc (db *datastore) GetAllUsers(page uint) (*[]User, error) {\n\tlimitStr := fmt.Sprintf(\"0, %d\", adminUsersPerPage)\n\tif page > 1 {\n\t\tlimitStr = fmt.Sprintf(\"%d, %d\", (page-1)*adminUsersPerPage, adminUsersPerPage)\n\t}\n\n\trows, err := db.Query(\"SELECT id, username, created, status FROM users ORDER BY created DESC LIMIT \" + limitStr)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from users: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve all users.\"}\n\t}\n\tdefer rows.Close()\n\n\tusers := []User{}\n\tfor rows.Next() {\n\t\tu := User{}\n\t\terr = rows.Scan(&u.ID, &u.Username, &u.Created, &u.Status)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning GetAllUsers() row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tusers = append(users, u)\n\t}\n\treturn &users, nil\n}\n\nfunc (db *datastore) GetAllUsersCount() int64 {\n\tvar count int64\n\terr := db.QueryRow(\"SELECT COUNT(*) FROM users\").Scan(&count)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn 0\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting all users count: %v\", err)\n\t\treturn 0\n\t}\n\n\treturn count\n}\n\nfunc (db *datastore) GetUserLastPostTime(id int64) (*time.Time, error) {\n\tvar t time.Time\n\terr := db.QueryRow(\"SELECT created FROM posts WHERE owner_id = ? ORDER BY created DESC LIMIT 1\", id).Scan(&t)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, nil\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting last post time from posts: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn &t, nil\n}\n\n// SetUserStatus changes a user's status in the database. see Users.UserStatus\nfunc (db *datastore) SetUserStatus(id int64, status UserStatus) error {\n\t_, err := db.Exec(\"UPDATE users SET status = ? WHERE id = ?\", status, id)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to update user status: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (db *datastore) GetCollectionLastPostTime(id int64) (*time.Time, error) {\n\tvar t time.Time\n\terr := db.QueryRow(\"SELECT created FROM posts WHERE collection_id = ? ORDER BY created DESC LIMIT 1\", id).Scan(&t)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, nil\n\tcase err != nil:\n\t\tlog.Error(\"Failed selecting last post time from posts: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn &t, nil\n}\n\nfunc (db *datastore) GenerateOAuthState(ctx context.Context, provider string, clientID string, attachUser int64, inviteCode string) (string, error) {\n\tstate := id.Generate62RandomString(24)\n\tattachUserVal := sql.NullInt64{Valid: attachUser > 0, Int64: attachUser}\n\tinviteCodeVal := sql.NullString{Valid: inviteCode != \"\", String: inviteCode}\n\t_, err := db.ExecContext(ctx, \"INSERT INTO oauth_client_states (state, provider, client_id, used, created_at, attach_user_id, invite_code) VALUES (?, ?, ?, FALSE, \"+db.now()+\", ?, ?)\", state, provider, clientID, attachUserVal, inviteCodeVal)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"unable to record oauth client state: %w\", err)\n\t}\n\treturn state, nil\n}\n\nfunc (db *datastore) ValidateOAuthState(ctx context.Context, state string) (string, string, int64, string, error) {\n\tvar provider string\n\tvar clientID string\n\tvar attachUserID sql.NullInt64\n\tvar inviteCode sql.NullString\n\terr := wf_db.RunTransactionWithOptions(ctx, db.DB, &sql.TxOptions{}, func(ctx context.Context, tx *sql.Tx) error {\n\t\terr := tx.\n\t\t\tQueryRowContext(ctx, \"SELECT provider, client_id, attach_user_id, invite_code FROM oauth_client_states WHERE state = ? AND used = FALSE\", state).\n\t\t\tScan(&provider, &clientID, &attachUserID, &inviteCode)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tres, err := tx.ExecContext(ctx, \"UPDATE oauth_client_states SET used = TRUE WHERE state = ?\", state)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trowsAffected, err := res.RowsAffected()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rowsAffected != 1 {\n\t\t\treturn fmt.Errorf(\"state not found\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn \"\", \"\", 0, \"\", nil\n\t}\n\treturn provider, clientID, attachUserID.Int64, inviteCode.String, nil\n}\n\nfunc (db *datastore) RecordRemoteUserID(ctx context.Context, localUserID int64, remoteUserID, provider, clientID, accessToken string) error {\n\tvar err error\n\tif db.driverName == driverSQLite {\n\t\t_, err = db.ExecContext(ctx, \"INSERT OR REPLACE INTO oauth_users (user_id, remote_user_id, provider, client_id, access_token) VALUES (?, ?, ?, ?, ?)\", localUserID, remoteUserID, provider, clientID, accessToken)\n\t} else {\n\t\t_, err = db.ExecContext(ctx, \"INSERT INTO oauth_users (user_id, remote_user_id, provider, client_id, access_token) VALUES (?, ?, ?, ?, ?) \"+db.upsert(\"user\")+\" access_token = ?\", localUserID, remoteUserID, provider, clientID, accessToken, accessToken)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Unable to INSERT oauth_users for '%d': %v\", localUserID, err)\n\t}\n\treturn err\n}\n\n// GetIDForRemoteUser returns a user ID associated with a remote user ID.\nfunc (db *datastore) GetIDForRemoteUser(ctx context.Context, remoteUserID, provider, clientID string) (int64, error) {\n\tvar userID int64 = -1\n\terr := db.\n\t\tQueryRowContext(ctx, \"SELECT user_id FROM oauth_users WHERE remote_user_id = ? AND provider = ? AND client_id = ?\", remoteUserID, provider, clientID).\n\t\tScan(&userID)\n\t// Not finding a record is OK.\n\tif err != nil && err != sql.ErrNoRows {\n\t\treturn -1, err\n\t}\n\treturn userID, nil\n}\n\ntype oauthAccountInfo struct {\n\tProvider        string\n\tClientID        string\n\tRemoteUserID    string\n\tDisplayName     string\n\tAllowDisconnect bool\n}\n\nfunc (db *datastore) GetOauthAccounts(ctx context.Context, userID int64) ([]oauthAccountInfo, error) {\n\trows, err := db.QueryContext(ctx, \"SELECT provider, client_id, remote_user_id FROM oauth_users WHERE user_id = ? \", userID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from oauth_users: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve user oauth accounts.\"}\n\t}\n\tdefer rows.Close()\n\n\tvar records []oauthAccountInfo\n\tfor rows.Next() {\n\t\tinfo := oauthAccountInfo{}\n\t\terr = rows.Scan(&info.Provider, &info.ClientID, &info.RemoteUserID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning GetAllUsers() row: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\trecords = append(records, info)\n\t}\n\treturn records, nil\n}\n\n// DatabaseInitialized returns whether or not the current datastore has been\n// initialized with the correct schema.\n// Currently, it checks to see if the `users` table exists.\nfunc (db *datastore) DatabaseInitialized() bool {\n\tvar dummy string\n\tvar err error\n\tif db.driverName == driverSQLite {\n\t\terr = db.QueryRow(\"SELECT name FROM sqlite_master WHERE type = 'table' AND name = 'users'\").Scan(&dummy)\n\t} else {\n\t\terr = db.QueryRow(\"SHOW TABLES LIKE 'users'\").Scan(&dummy)\n\t}\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn false\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SHOW TABLES: %v\", err)\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (db *datastore) RemoveOauth(ctx context.Context, userID int64, provider string, clientID string, remoteUserID string) error {\n\t_, err := db.ExecContext(ctx, `DELETE FROM oauth_users WHERE user_id = ? AND provider = ? AND client_id = ? AND remote_user_id = ?`, userID, provider, clientID, remoteUserID)\n\treturn err\n}\n\nfunc stringLogln(log *string, s string, v ...interface{}) {\n\t*log += fmt.Sprintf(s+\"\\n\", v...)\n}\n\nfunc handleFailedPostInsert(err error) error {\n\tlog.Error(\"Couldn't insert into posts: %v\", err)\n\treturn err\n}\n\n// Deprecated: use GetProfileURLFromHandle() instead, which returns user-facing URL instead of actor_id\nfunc (db *datastore) GetProfilePageFromHandle(app *App, handle string) (string, error) {\n\thandle = strings.TrimLeft(handle, \"@\")\n\tactorIRI := \"\"\n\tparts := strings.Split(handle, \"@\")\n\tif len(parts) != 2 {\n\t\treturn \"\", fmt.Errorf(\"invalid handle format\")\n\t}\n\tdomain := parts[1]\n\n\t// Check non-AP instances\n\tif siloProfileURL := silobridge.Profile(parts[0], domain); siloProfileURL != \"\" {\n\t\treturn siloProfileURL, nil\n\t}\n\n\tremoteUser, err := getRemoteUserFromHandle(app, handle)\n\tif err != nil {\n\t\t// can't find using handle in the table but the table may already have this user without\n\t\t// handle from a previous version\n\t\t// TODO: Make this determination. We should know whether a user exists without a handle, or doesn't exist at all\n\t\tactorIRI = RemoteLookup(handle)\n\t\t_, errRemoteUser := getRemoteUser(app, actorIRI)\n\t\t// if it exists then we need to update the handle\n\t\tif errRemoteUser == nil {\n\t\t\t_, err := app.db.Exec(\"UPDATE remoteusers SET handle = ? WHERE actor_id = ?\", handle, actorIRI)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't update handle '%s' for user %s\", handle, actorIRI)\n\t\t\t}\n\t\t} else {\n\t\t\t// this probably means we don't have the user in the table so let's try to insert it\n\t\t\t// here we need to ask the server for the inboxes\n\t\t\tremoteActor, err := activityserve.NewRemoteActor(actorIRI)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't fetch remote actor: %v\", err)\n\t\t\t}\n\t\t\tif debugging {\n\t\t\t\tlog.Info(\"%s %s %s %s\", actorIRI, remoteActor.GetInbox(), remoteActor.GetSharedInbox(), handle)\n\t\t\t}\n\t\t\t_, err = app.db.Exec(\"INSERT INTO remoteusers (actor_id, inbox, shared_inbox, handle) VALUES(?, ?, ?, ?)\", actorIRI, remoteActor.GetInbox(), remoteActor.GetSharedInbox(), handle)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Couldn't insert remote user: %v\", err)\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t} else {\n\t\tactorIRI = remoteUser.ActorID\n\t}\n\treturn actorIRI, nil\n}\n\nfunc (db *datastore) AddEmailSubscription(collID, userID int64, email string, confirmed bool) (*EmailSubscriber, error) {\n\tfriendlyChars := \"0123456789BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\n\tsubID := id.GenerateRandomString(friendlyChars, 8)\n\ttoken := id.GenerateRandomString(friendlyChars, 16)\n\temailVal := sql.NullString{\n\t\tString: email,\n\t\tValid:  email != \"\",\n\t}\n\tuserIDVal := sql.NullInt64{\n\t\tInt64: userID,\n\t\tValid: userID > 0,\n\t}\n\n\t_, err := db.Exec(\"INSERT INTO emailsubscribers (id, collection_id, user_id, email, subscribed, token, confirmed) VALUES (?, ?, ?, ?, \"+db.now()+\", ?, ?)\", subID, collID, userIDVal, emailVal, token, confirmed)\n\tif err != nil {\n\t\tif mysqlErr, ok := err.(*mysql.MySQLError); ok {\n\t\t\tif mysqlErr.Number == mySQLErrDuplicateKey {\n\t\t\t\t// Duplicate, so just return existing subscriber information\n\t\t\t\tlog.Info(\"Duplicate subscriber for email %s, user %d; returning existing subscriber\", email, userID)\n\t\t\t\treturn db.FetchEmailSubscriber(email, userID, collID)\n\t\t\t}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &EmailSubscriber{\n\t\tID:     subID,\n\t\tCollID: collID,\n\t\tUserID: userIDVal,\n\t\tEmail:  emailVal,\n\t\tToken:  token,\n\t}, nil\n}\n\nfunc (db *datastore) IsEmailSubscriber(email string, userID, collID int64) bool {\n\tvar dummy int\n\tvar err error\n\tif email != \"\" {\n\t\terr = db.QueryRow(\"SELECT 1 FROM emailsubscribers WHERE email = ? AND collection_id = ?\", email, collID).Scan(&dummy)\n\t} else {\n\t\terr = db.QueryRow(\"SELECT 1 FROM emailsubscribers WHERE user_id = ? AND collection_id = ?\", userID, collID).Scan(&dummy)\n\t}\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn false\n\tcase err != nil:\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (db *datastore) GetEmailSubscribers(collID int64, reqConfirmed bool) ([]*EmailSubscriber, error) {\n\tcond := \"\"\n\tif reqConfirmed {\n\t\tcond = \" AND confirmed = 1\"\n\t}\n\trows, err := db.Query(`SELECT s.id, collection_id, user_id, s.email, u.email, subscribed, token, confirmed, allow_export \nFROM emailsubscribers s \nLEFT JOIN users u \n  ON u.id = user_id \nWHERE collection_id = ?`+cond+`\nORDER BY subscribed DESC`, collID)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting email subscribers for collection %d: %v\", collID, err)\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar subs []*EmailSubscriber\n\tfor rows.Next() {\n\t\ts := &EmailSubscriber{}\n\t\terr = rows.Scan(&s.ID, &s.CollID, &s.UserID, &s.Email, &s.acctEmail, &s.Subscribed, &s.Token, &s.Confirmed, &s.AllowExport)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed scanning row from email subscribers: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tsubs = append(subs, s)\n\t}\n\treturn subs, nil\n}\n\nfunc (db *datastore) FetchEmailSubscriberEmail(subID, token string) (string, error) {\n\tvar email sql.NullString\n\t// TODO: return user email if there's a user_id ?\n\terr := db.QueryRow(\"SELECT email FROM emailsubscribers WHERE id = ? AND token = ?\", subID, token).Scan(&email)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn \"\", fmt.Errorf(\"Subscriber doesn't exist or token is invalid.\")\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT email from emailsubscribers: %v\", err)\n\t\treturn \"\", fmt.Errorf(\"Something went very wrong.\")\n\t}\n\n\treturn email.String, nil\n}\n\nfunc (db *datastore) FetchEmailSubscriber(email string, userID, collID int64) (*EmailSubscriber, error) {\n\tconst emailSubCols = \"id, collection_id, user_id, email, subscribed, token, confirmed, allow_export\"\n\n\ts := &EmailSubscriber{}\n\tvar row *sql.Row\n\tif email != \"\" {\n\t\trow = db.QueryRow(\"SELECT \"+emailSubCols+\" FROM emailsubscribers WHERE email = ? AND collection_id = ?\", email, collID)\n\t} else {\n\t\trow = db.QueryRow(\"SELECT \"+emailSubCols+\" FROM emailsubscribers WHERE user_id = ? AND collection_id = ?\", userID, collID)\n\t}\n\terr := row.Scan(&s.ID, &s.CollID, &s.UserID, &s.Email, &s.Subscribed, &s.Token, &s.Confirmed, &s.AllowExport)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn nil, nil\n\tcase err != nil:\n\t\treturn nil, err\n\t}\n\treturn s, nil\n}\n\nfunc (db *datastore) DeleteEmailSubscriber(subID, token string) error {\n\tres, err := db.Exec(\"DELETE FROM emailsubscribers WHERE id = ? AND token = ?\", subID, token)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trowsAffected, _ := res.RowsAffected()\n\tif rowsAffected == 0 {\n\t\treturn impart.HTTPError{http.StatusNotFound, \"Invalid token, or subscriber doesn't exist\"}\n\t}\n\treturn nil\n}\n\nfunc (db *datastore) DeleteEmailSubscriberByUser(email string, userID, collID int64) error {\n\tvar res sql.Result\n\tvar err error\n\tif email != \"\" {\n\t\tres, err = db.Exec(\"DELETE FROM emailsubscribers WHERE email = ? AND collection_id = ?\", email, collID)\n\t} else {\n\t\tres, err = db.Exec(\"DELETE FROM emailsubscribers WHERE user_id = ? AND collection_id = ?\", userID, collID)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trowsAffected, _ := res.RowsAffected()\n\tif rowsAffected == 0 {\n\t\treturn impart.HTTPError{http.StatusNotFound, \"Subscriber doesn't exist\"}\n\t}\n\treturn nil\n}\n\nfunc (db *datastore) UpdateSubscriberConfirmed(subID, token string) error {\n\temail, err := db.FetchEmailSubscriberEmail(subID, token)\n\tif err != nil {\n\t\tlog.Error(\"Didn't fetch email subscriber: %v\", err)\n\t\treturn err\n\t}\n\n\t// TODO: ensure all addresses with original name are also confirmed, e.g. matt+fake@write.as and matt@write.as are now confirmed\n\t_, err = db.Exec(\"UPDATE emailsubscribers SET confirmed = 1 WHERE email = ?\", email)\n\tif err != nil {\n\t\tlog.Error(\"Could not update email subscriber confirmation status: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (db *datastore) IsSubscriberConfirmed(email string) bool {\n\tvar dummy int64\n\terr := db.QueryRow(\"SELECT 1 FROM emailsubscribers WHERE email = ? AND confirmed = 1\", email).Scan(&dummy)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn false\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT in isSubscriberConfirmed: %v\", err)\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (db *datastore) InsertJob(j *PostJob) error {\n\tres, err := db.Exec(\"INSERT INTO publishjobs (post_id, action, delay) VALUES (?, ?, ?)\", j.PostID, j.Action, j.Delay)\n\tif err != nil {\n\t\treturn err\n\t}\n\tjobID, err := res.LastInsertId()\n\tif err != nil {\n\t\tlog.Error(\"[jobs] Couldn't get last insert ID! %s\", err)\n\t}\n\tlog.Info(\"[jobs] Queued %s job #%d for post %s, delayed %d minutes\", j.Action, jobID, j.PostID, j.Delay)\n\treturn nil\n}\n\nfunc (db *datastore) UpdateJobForPost(postID string, delay int64) error {\n\t_, err := db.Exec(\"UPDATE publishjobs SET delay = ? WHERE post_id = ?\", delay, postID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to update publish job: %s\", err)\n\t}\n\tlog.Info(\"Updated job for post %s: delay %d\", postID, delay)\n\treturn nil\n}\n\nfunc (db *datastore) DeleteJob(id int64) error {\n\t_, err := db.Exec(\"DELETE FROM publishjobs WHERE id = ?\", id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlog.Info(\"[job #%d] Deleted.\", id)\n\treturn nil\n}\n\nfunc (db *datastore) DeleteJobByPost(postID string) error {\n\t_, err := db.Exec(\"DELETE FROM publishjobs WHERE post_id = ?\", postID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlog.Info(\"[job] Deleted job for post %s\", postID)\n\treturn nil\n}\n\nfunc (db *datastore) GetJobsToRun(action string) ([]*PostJob, error) {\n\ttimeWhere := \"created < DATE_SUB(NOW(), INTERVAL delay MINUTE) AND created > DATE_SUB(NOW(), INTERVAL delay + 5 MINUTE)\"\n\tif db.driverName == driverSQLite {\n\t\ttimeWhere = \"created < DATETIME('now', '-' || delay || ' MINUTE') AND created > DATETIME('now', '-' || (delay+5) || ' MINUTE')\"\n\t}\n\trows, err := db.Query(`SELECT pj.id, post_id, action, delay\n\t\tFROM publishjobs pj\n\t\tINNER JOIN posts p\n\t\t\tON post_id = p.id\n\t\tWHERE action = ? AND `+timeWhere+`\n\t\tORDER BY created ASC`, action)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from publishjobs: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve publish jobs.\"}\n\t}\n\tdefer rows.Close()\n\n\tjobs := []*PostJob{}\n\tfor rows.Next() {\n\t\tj := &PostJob{}\n\t\terr = rows.Scan(&j.ID, &j.PostID, &j.Action, &j.Delay)\n\t\tjobs = append(jobs, j)\n\t}\n\treturn jobs, nil\n}\n"
        },
        {
          "name": "database_activitypub.go",
          "type": "blob",
          "size": 1.5634765625,
          "content": "/*\n * Copyright © 2024 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"github.com/writeas/web-core/activitystreams\"\n\t\"github.com/writeas/web-core/log\"\n)\n\nfunc apAddRemoteUser(app *App, t *sql.Tx, fullActor *activitystreams.Person) (int64, error) {\n\t// Add remote user locally, since it wasn't found before\n\tres, err := t.Exec(\"INSERT INTO remoteusers (actor_id, inbox, shared_inbox, url) VALUES (?, ?, ?, ?)\", fullActor.ID, fullActor.Inbox, fullActor.Endpoints.SharedInbox, fullActor.URL)\n\tif err != nil {\n\t\tt.Rollback()\n\t\treturn -1, fmt.Errorf(\"couldn't add new remoteuser in DB: %v\", err)\n\t}\n\n\tremoteUserID, err := res.LastInsertId()\n\tif err != nil {\n\t\tt.Rollback()\n\t\treturn -1, fmt.Errorf(\"no lastinsertid for followers, rolling back: %v\", err)\n\t}\n\n\t// Add in key\n\t_, err = t.Exec(\"INSERT INTO remoteuserkeys (id, remote_user_id, public_key) VALUES (?, ?, ?)\", fullActor.PublicKey.ID, remoteUserID, fullActor.PublicKey.PublicKeyPEM)\n\tif err != nil {\n\t\tif !app.db.isDuplicateKeyErr(err) {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Couldn't add follower keys in DB: %v\\n\", err)\n\t\t\treturn -1, fmt.Errorf(\"couldn't add follower keys in DB: %v\", err)\n\t\t} else {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Couldn't add follower keys in DB: %v\\n\", err)\n\t\t\treturn -1, fmt.Errorf(\"couldn't add follower keys in DB: %v\", err)\n\t\t}\n\t}\n\n\treturn remoteUserID, nil\n}\n"
        },
        {
          "name": "database_test.go",
          "type": "blob",
          "size": 1.60546875,
          "content": "package writefreely\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n)\n\nfunc TestOAuthDatastore(t *testing.T) {\n\tif !runMySQLTests() {\n\t\tt.Skip(\"skipping mysql tests\")\n\t}\n\twithTestDB(t, func(db *sql.DB) {\n\t\tctx := context.Background()\n\t\tds := &datastore{\n\t\t\tDB:         db,\n\t\t\tdriverName: \"\",\n\t\t}\n\n\t\tstate, err := ds.GenerateOAuthState(ctx, \"test\", \"development\", 0, \"\")\n\t\tassert.NoError(t, err)\n\t\tassert.Len(t, state, 24)\n\n\t\tcountRows(t, ctx, db, 1, \"SELECT COUNT(*) FROM `oauth_client_states` WHERE `state` = ? AND `used` = false\", state)\n\n\t\t_, _, _, _, err = ds.ValidateOAuthState(ctx, state)\n\t\tassert.NoError(t, err)\n\n\t\tcountRows(t, ctx, db, 1, \"SELECT COUNT(*) FROM `oauth_client_states` WHERE `state` = ? AND `used` = true\", state)\n\n\t\tvar localUserID int64 = 99\n\t\tvar remoteUserID = \"100\"\n\t\terr = ds.RecordRemoteUserID(ctx, localUserID, remoteUserID, \"test\", \"test\", \"access_token_a\")\n\t\tassert.NoError(t, err)\n\n\t\tcountRows(t, ctx, db, 1, \"SELECT COUNT(*) FROM `oauth_users` WHERE `user_id` = ? AND `remote_user_id` = ? AND access_token = 'access_token_a'\", localUserID, remoteUserID)\n\n\t\terr = ds.RecordRemoteUserID(ctx, localUserID, remoteUserID, \"test\", \"test\", \"access_token_b\")\n\t\tassert.NoError(t, err)\n\n\t\tcountRows(t, ctx, db, 1, \"SELECT COUNT(*) FROM `oauth_users` WHERE `user_id` = ? AND `remote_user_id` = ? AND access_token = 'access_token_b'\", localUserID, remoteUserID)\n\n\t\tcountRows(t, ctx, db, 1, \"SELECT COUNT(*) FROM `oauth_users`\")\n\n\t\tfoundUserID, err := ds.GetIDForRemoteUser(ctx, remoteUserID, \"test\", \"test\")\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, localUserID, foundUserID)\n\t})\n}\n"
        },
        {
          "name": "db",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose.prod.yml",
          "type": "blob",
          "size": 0.5087890625,
          "content": "services:\n  app:\n    image: writefreely\n    container_name: writefreely\n    volumes:\n      - ./data:/data\n    ports:\n      - 127.0.0.1:8080:8080\n    depends_on:\n      - db\n    restart: unless-stopped\n\n  db:\n    image: lscr.io/linuxserver/mariadb\n    container_name: writefreely-mariadb\n    volumes: \n      - ./db:/config\n    environment:\n      - PUID=65534\n      - PGID=65534\n      - TZ=Etc/UTC\n      - MYSQL_DATABASE=writefreely\n      - MYSQL_USER=writefreely\n      - MYSQL_PASSWORD=P@ssw0rd\n    restart: unless-stopped\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.7744140625,
          "content": "version: \"3\"\n\nvolumes:\n  web-keys:\n  db-data:\n\nnetworks:\n  external_writefreely:\n  internal_writefreely:\n    internal: true\n\nservices:\n  writefreely-web:\n    container_name: \"writefreely-web\"\n    image: \"writeas/writefreely:latest\"\n\n    volumes:\n      - \"web-keys:/go/keys\"\n      - \"./config.ini:/go/config.ini\"\n\n    networks:\n      - \"internal_writefreely\"\n      - \"external_writefreely\"\n\n    ports:\n      - \"8080:8080\"\n\n    depends_on:\n      - \"writefreely-db\"\n\n    restart: unless-stopped\n\n  writefreely-db:\n    container_name: \"writefreely-db\"\n    image: \"mariadb:latest\"\n\n    volumes:\n      - \"db-data:/var/lib/mysql/data\"\n\n    networks:\n      - \"internal_writefreely\"\n\n    environment:\n      - MYSQL_DATABASE=writefreely\n      - MYSQL_ROOT_PASSWORD=changeme\n\n    restart: unless-stopped\n"
        },
        {
          "name": "docker-setup.sh",
          "type": "blob",
          "size": 0.205078125,
          "content": "#!/bin/bash\ndocker-compose exec db sh -c 'exec mysql -u root -pchangeme writefreely < /tmp/schema.sql'\ndocker exec writefreely_web_1 writefreely --gen-keys\ndocker exec -it writefreely_web_1 writefreely --config"
        },
        {
          "name": "email.go",
          "type": "blob",
          "size": 12.744140625,
          "content": "/*\n * Copyright © 2019-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/aymerick/douceur/inliner\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/mailgun/mailgun-go\"\n\tstripmd \"github.com/writeas/go-strip-markdown/v2\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/data\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/key\"\n\t\"github.com/writefreely/writefreely/spam\"\n)\n\nconst (\n\temailSendDelay = 15\n)\n\ntype (\n\tSubmittedSubscription struct {\n\t\tCollAlias string\n\t\tUserID    int64\n\n\t\tEmail string `schema:\"email\" json:\"email\"`\n\t\tWeb   bool   `schema:\"web\" json:\"web\"`\n\t\tSlug  string `schema:\"slug\" json:\"slug\"`\n\t\tFrom  string `schema:\"from\" json:\"from\"`\n\t}\n\n\tEmailSubscriber struct {\n\t\tID          string\n\t\tCollID      int64\n\t\tUserID      sql.NullInt64\n\t\tEmail       sql.NullString\n\t\tSubscribed  time.Time\n\t\tToken       string\n\t\tConfirmed   bool\n\t\tAllowExport bool\n\t\tacctEmail   sql.NullString\n\t}\n)\n\nfunc (es *EmailSubscriber) FinalEmail(keys *key.Keychain) string {\n\tif !es.UserID.Valid || es.Email.Valid {\n\t\treturn es.Email.String\n\t}\n\n\tdecEmail, err := data.Decrypt(keys.EmailKey, []byte(es.acctEmail.String))\n\tif err != nil {\n\t\tlog.Error(\"Error decrypting user email: %v\", err)\n\t\treturn \"\"\n\t}\n\treturn string(decEmail)\n}\n\nfunc (es *EmailSubscriber) SubscribedFriendly() string {\n\treturn es.Subscribed.Format(\"January 2, 2006\")\n}\n\nfunc handleCreateEmailSubscription(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\tvars := mux.Vars(r)\n\tvar err error\n\n\tss := SubmittedSubscription{\n\t\tCollAlias: vars[\"alias\"],\n\t}\n\tu := getUserSession(app, r)\n\tif u != nil {\n\t\tss.UserID = u.ID\n\t}\n\tif reqJSON {\n\t\t// Decode JSON request\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr = decoder.Decode(&ss)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse new subscription JSON request: %v\\n\", err)\n\t\t\treturn ErrBadJSON\n\t\t}\n\t} else {\n\t\terr = r.ParseForm()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse new subscription form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\n\t\terr = app.formDecoder.Decode(&ss, r.PostForm)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Continuing, but error decoding new subscription form request: %v\\n\", err)\n\t\t\t//return ErrBadFormData\n\t\t}\n\t}\n\n\tc, err := app.db.GetCollection(ss.CollAlias)\n\tif err != nil {\n\t\tlog.Error(\"getCollection: %s\", err)\n\t\treturn err\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tfrom := c.CanonicalURL()\n\tisAuthorBanned, err := app.db.IsUserSilenced(c.OwnerID)\n\tif isAuthorBanned {\n\t\tlog.Info(\"Author is silenced, so subscription is blocked.\")\n\t\treturn impart.HTTPError{http.StatusFound, from}\n\t}\n\n\tif ss.Web {\n\t\tif u != nil && u.ID == c.OwnerID {\n\t\t\tfrom = \"/\" + c.Alias + \"/\"\n\t\t}\n\t\tfrom += ss.Slug\n\t}\n\n\tif r.FormValue(spam.HoneypotFieldName()) != \"\" || r.FormValue(\"fake_password\") != \"\" {\n\t\tlog.Info(\"Honeypot field was filled out! Not subscribing.\")\n\t\treturn impart.HTTPError{http.StatusFound, from}\n\t}\n\n\tif ss.Email == \"\" && ss.UserID < 1 {\n\t\tlog.Info(\"No subscriber data. Not subscribing.\")\n\t\treturn impart.HTTPError{http.StatusFound, from}\n\t}\n\n\tconfirmed := app.db.IsSubscriberConfirmed(ss.Email)\n\tes, err := app.db.AddEmailSubscription(c.ID, ss.UserID, ss.Email, confirmed)\n\tif err != nil {\n\t\tlog.Error(\"addEmailSubscription: %s\", err)\n\t\treturn err\n\t}\n\n\t// Send confirmation email if needed\n\tif !confirmed {\n\t\terr = sendSubConfirmEmail(app, c, ss.Email, es.ID, es.Token)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed to send subscription confirmation email: %s\", err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif ss.Web {\n\t\tsession, err := app.sessionStore.Get(r, userEmailCookieName)\n\t\tif err != nil {\n\t\t\t// The cookie should still save, even if there's an error.\n\t\t\t// Source: https://github.com/gorilla/sessions/issues/16#issuecomment-143642144\n\t\t\tlog.Error(\"Getting user email cookie: %v; ignoring\", err)\n\t\t}\n\t\tif confirmed {\n\t\t\taddSessionFlash(app, w, r, \"<strong>Subscribed</strong>. You'll now receive future blog posts via email.\", nil)\n\t\t} else {\n\t\t\taddSessionFlash(app, w, r, \"Please check your email and <strong>click the confirmation link</strong> to subscribe.\", nil)\n\t\t}\n\t\tsession.Values[userEmailCookieVal] = ss.Email\n\t\terr = session.Save(r, w)\n\t\tif err != nil {\n\t\t\tlog.Error(\"save email cookie: %s\", err)\n\t\t\treturn err\n\t\t}\n\n\t\treturn impart.HTTPError{http.StatusFound, from}\n\t}\n\treturn impart.WriteSuccess(w, \"\", http.StatusAccepted)\n}\n\nfunc handleDeleteEmailSubscription(app *App, w http.ResponseWriter, r *http.Request) error {\n\talias := collectionAliasFromReq(r)\n\n\tvars := mux.Vars(r)\n\tsubID := vars[\"subscriber\"]\n\temail := r.FormValue(\"email\")\n\ttoken := r.FormValue(\"t\")\n\tslug := r.FormValue(\"slug\")\n\tisWeb := r.Method == \"GET\"\n\n\t// Display collection if this is a collection\n\tvar c *Collection\n\tvar err error\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Get collection: %s\", err)\n\t\treturn err\n\t}\n\n\tfrom := c.CanonicalURL()\n\n\tif subID != \"\" {\n\t\t// User unsubscribing via email, so assume action is taken by either current\n\t\t// user or not current user, and only use the request's information to\n\t\t// satisfy this unsubscribe, i.e. subscriberID and token.\n\t\terr = app.db.DeleteEmailSubscriber(subID, token)\n\t} else {\n\t\t// User unsubscribing through the web app, so assume action is taken by\n\t\t// currently-auth'd user.\n\t\tvar userID int64\n\t\tu := getUserSession(app, r)\n\t\tif u != nil {\n\t\t\t// User is logged in\n\t\t\tuserID = u.ID\n\t\t\tif userID == c.OwnerID {\n\t\t\t\tfrom = \"/\" + c.Alias + \"/\"\n\t\t\t}\n\t\t}\n\t\tif email == \"\" && userID <= 0 {\n\t\t\t// Get email address from saved cookie\n\t\t\tsession, err := app.sessionStore.Get(r, userEmailCookieName)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Unable to get email cookie: %s\", err)\n\t\t\t} else {\n\t\t\t\temail = session.Values[userEmailCookieVal].(string)\n\t\t\t}\n\t\t}\n\n\t\tif email == \"\" && userID <= 0 {\n\t\t\terr = fmt.Errorf(\"No subscriber given.\")\n\t\t\tlog.Error(\"Not deleting subscription: %s\", err)\n\t\t\treturn err\n\t\t}\n\n\t\terr = app.db.DeleteEmailSubscriberByUser(email, userID, c.ID)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Unable to delete subscriber: %v\", err)\n\t\treturn err\n\t}\n\n\tif isWeb {\n\t\tfrom += slug\n\t\taddSessionFlash(app, w, r, \"<strong>Unsubscribed</strong>. You will no longer receive these blog posts via email.\", nil)\n\t\treturn impart.HTTPError{http.StatusFound, from}\n\t}\n\treturn impart.WriteSuccess(w, \"\", http.StatusAccepted)\n}\n\nfunc handleConfirmEmailSubscription(app *App, w http.ResponseWriter, r *http.Request) error {\n\talias := collectionAliasFromReq(r)\n\tsubID := mux.Vars(r)[\"subscriber\"]\n\ttoken := r.FormValue(\"t\")\n\n\tvar c *Collection\n\tvar err error\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Get collection: %s\", err)\n\t\treturn err\n\t}\n\n\tfrom := c.CanonicalURL()\n\n\terr = app.db.UpdateSubscriberConfirmed(subID, token)\n\tif err != nil {\n\t\taddSessionFlash(app, w, r, err.Error(), nil)\n\t\treturn impart.HTTPError{http.StatusFound, from}\n\t}\n\n\taddSessionFlash(app, w, r, \"<strong>Confirmed</strong>! Thanks. Now you'll receive future blog posts via email.\", nil)\n\treturn impart.HTTPError{http.StatusFound, from}\n}\n\nfunc emailPost(app *App, p *PublicPost, collID int64) error {\n\tp.augmentContent()\n\n\t// Do some shortcode replacement.\n\t// Since the user is receiving this email, we can assume they're subscribed via email.\n\tp.Content = strings.Replace(p.Content, \"<!--emailsub-->\", `<p id=\"emailsub\">You're subscribed to email updates.</p>`, -1)\n\n\tif p.HTMLContent == template.HTML(\"\") {\n\t\tp.formatContent(app.cfg, false, false)\n\t}\n\tp.augmentReadingDestination()\n\n\ttitle := p.Title.String\n\tif title != \"\" {\n\t\ttitle = p.Title.String + \"\\n\\n\"\n\t}\n\tplainMsg := title + \"A new post from \" + p.CanonicalURL(app.cfg.App.Host) + \"\\n\\n\" + stripmd.Strip(p.Content)\n\tplainMsg += `\n\n---------------------------------------------------------------------------------\n\nOriginally published on ` + p.Collection.DisplayTitle() + ` (` + p.Collection.CanonicalURL() + `), a blog you subscribe to.\n\nSent to %recipient.to%. Unsubscribe: ` + p.Collection.CanonicalURL() + `email/unsubscribe/%recipient.id%?t=%recipient.token%`\n\n\tgun := mailgun.NewMailgun(app.cfg.Email.Domain, app.cfg.Email.MailgunPrivate)\n\tm := mailgun.NewMessage(p.Collection.DisplayTitle()+\" <\"+p.Collection.Alias+\"@\"+app.cfg.Email.Domain+\">\", stripmd.Strip(p.DisplayTitle()), plainMsg)\n\treplyTo := app.db.GetCollectionAttribute(collID, collAttrLetterReplyTo)\n\tif replyTo != \"\" {\n\t\tm.SetReplyTo(replyTo)\n\t}\n\n\tsubs, err := app.db.GetEmailSubscribers(collID, true)\n\tif err != nil {\n\t\tlog.Error(\"Unable to get email subscribers: %v\", err)\n\t\treturn err\n\t}\n\tif len(subs) == 0 {\n\t\treturn nil\n\t}\n\n\tif title != \"\" {\n\t\ttitle = string(`<h2 id=\"title\">` + p.FormattedDisplayTitle() + `</h2>`)\n\t}\n\tm.AddTag(\"New post\")\n\n\tfontFam := \"Lora, Palatino, Baskerville, serif\"\n\tif p.IsSans() {\n\t\tfontFam = `\"Open Sans\", Tahoma, Arial, sans-serif`\n\t} else if p.IsMonospace() {\n\t\tfontFam = `Hack, consolas, Menlo-Regular, Menlo, Monaco, monospace, monospace`\n\t}\n\n\t// TODO: move this to a templated file and LESS-generated stylesheet\n\tfullHTML := `<html>\n\t<head>\n\t\t<style>\n\t\tbody {\n\t\t\tfont-size: 120%;\n\t\t\tfont-family: ` + fontFam + `;\n\t\t\tmargin: 1em 2em;\n\t\t}\n\t\t#article {\n\t\t\tline-height: 1.5;\n\t\t\tmargin: 1.5em 0;\n\t\t\twhite-space: pre-wrap;\n\t\t\tword-wrap: break-word;\n\t\t}\n\t\th1, h2, h3, h4, h5, h6, p, code {\n\t\t\tdisplay: inline\n\t\t}\n\t\timg, iframe, video {\n\t\t\tmax-width: 100%\n\t\t}\n\t\t#title {\n\t\t\tmargin-bottom: 1em;\n\t\t\tdisplay: block;\n\t\t}\n\t\t.intro {\n\t\t\tfont-style: italic;\n\t\t\tfont-size: 0.95em;\n\t\t}\n\t\tdiv#footer {\n\t\t\ttext-align: center;\n\t\t\tmax-width: 35em;\n\t\t\tmargin: 2em auto;\n\t\t}\n\t\tdiv#footer p {\n\t\t\tdisplay: block;\n\t\t\tfont-size: 0.86em;\n\t\t\tcolor: #666;\n\t\t}\n\t\thr {\n\t\t\tborder: 1px solid #ccc;\n\t\t\tmargin: 2em 1em;\n\t\t}\n\t\tp#emailsub {\n\t\t\ttext-align: center;\n\t\t\tdisplay: inline-block !important;\n\t\t\twidth: 100%;\n\t\t\tfont-style: italic;\n\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div id=\"article\">` + title + `<p class=\"intro\">From <a href=\"` + p.CanonicalURL(app.cfg.App.Host) + `\">` + p.DisplayCanonicalURL() + `</a></p>\n\n` + string(p.HTMLContent) + `</div>\n\t\t<hr />\n\t\t<div id=\"footer\">\n\t\t\t<p>Originally published on <a href=\"` + p.Collection.CanonicalURL() + `\">` + p.Collection.DisplayTitle() + `</a>, a blog you subscribe to.</p>\n\t\t\t<p>Sent to %recipient.to%. <a href=\"` + p.Collection.CanonicalURL() + `email/unsubscribe/%recipient.id%?t=%recipient.token%\">Unsubscribe</a>.</p>\n\t\t</div>\n\t</body>\n</html>`\n\n\t// inline CSS\n\thtml, err := inliner.Inline(fullHTML)\n\tif err != nil {\n\t\tlog.Error(\"Unable to inline email HTML: %v\", err)\n\t\treturn err\n\t}\n\n\tm.SetHtml(html)\n\n\tlog.Info(\"[email] Adding %d recipient(s)\", len(subs))\n\tfor _, s := range subs {\n\t\te := s.FinalEmail(app.keys)\n\t\tlog.Info(\"[email] Adding %s\", e)\n\t\terr = m.AddRecipientAndVariables(e, map[string]interface{}{\n\t\t\t\"id\":    s.ID,\n\t\t\t\"to\":    e,\n\t\t\t\"token\": s.Token,\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to add receipient %s: %s\", e, err)\n\t\t}\n\t}\n\n\tres, _, err := gun.Send(m)\n\tlog.Info(\"[email] Send result: %s\", res)\n\tif err != nil {\n\t\tlog.Error(\"Unable to send post email: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc sendSubConfirmEmail(app *App, c *Collection, email, subID, token string) error {\n\tif email == \"\" {\n\t\treturn fmt.Errorf(\"You must supply an email to verify.\")\n\t}\n\n\t// Send email\n\tgun := mailgun.NewMailgun(app.cfg.Email.Domain, app.cfg.Email.MailgunPrivate)\n\n\tplainMsg := \"Confirm your subscription to \" + c.DisplayTitle() + ` (` + c.CanonicalURL() + `) to start receiving future posts. Simply click the following link (or copy and paste it into your browser):\n\n` + c.CanonicalURL() + \"email/confirm/\" + subID + \"?t=\" + token + `\n\nIf you didn't subscribe to this site or you're not sure why you're getting this email, you can delete it. You won't be subscribed or receive any future emails.`\n\tm := mailgun.NewMessage(c.DisplayTitle()+\" <\"+c.Alias+\"@\"+app.cfg.Email.Domain+\">\", \"Confirm your subscription to \"+c.DisplayTitle(), plainMsg, fmt.Sprintf(\"<%s>\", email))\n\tm.AddTag(\"Email Verification\")\n\n\tm.SetHtml(`<html>\n\t<body style=\"font-family:Lora, 'Palatino Linotype', Palatino, Baskerville, 'Book Antiqua', 'New York', 'DejaVu serif', serif; font-size: 100%%; margin:1em 2em;\">\n\t\t<div style=\"font-size: 1.2em;\">\n\t\t\t<p>Confirm your subscription to <a href=\"` + c.CanonicalURL() + `\">` + c.DisplayTitle() + `</a> to start receiving future posts:</p>\n\t\t\t<p><a href=\"` + c.CanonicalURL() + `email/confirm/` + subID + `?t=` + token + `\">Subscribe to ` + c.DisplayTitle() + `</a></p>\n\t\t\t<p>If you didn't subscribe to this site or you're not sure why you're getting this email, you can delete it. You won't be subscribed or receive any future emails.</p>\n        </div>\n\t</body>\n</html>`)\n\tgun.Send(m)\n\n\treturn nil\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 3.4384765625,
          "content": "/*\n * Copyright © 2018-2020 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/writeas/impart\"\n)\n\n// Commonly returned HTTP errors\nvar (\n\tErrBadFormData    = impart.HTTPError{http.StatusBadRequest, \"Expected valid form data.\"}\n\tErrBadJSON        = impart.HTTPError{http.StatusBadRequest, \"Expected valid JSON object.\"}\n\tErrBadJSONArray   = impart.HTTPError{http.StatusBadRequest, \"Expected valid JSON array.\"}\n\tErrBadAccessToken = impart.HTTPError{http.StatusUnauthorized, \"Invalid access token.\"}\n\tErrNoAccessToken  = impart.HTTPError{http.StatusBadRequest, \"Authorization token required.\"}\n\tErrNotLoggedIn    = impart.HTTPError{http.StatusUnauthorized, \"Not logged in.\"}\n\n\tErrForbiddenCollection        = impart.HTTPError{http.StatusForbidden, \"You don't have permission to add to this collection.\"}\n\tErrForbiddenEditPost          = impart.HTTPError{http.StatusForbidden, \"You don't have permission to update this post.\"}\n\tErrUnauthorizedEditPost       = impart.HTTPError{http.StatusUnauthorized, \"Invalid editing credentials.\"}\n\tErrUnauthorizedGeneral        = impart.HTTPError{http.StatusUnauthorized, \"You don't have permission to do that.\"}\n\tErrBadRequestedType           = impart.HTTPError{http.StatusNotAcceptable, \"Bad requested Content-Type.\"}\n\tErrCollectionUnauthorizedRead = impart.HTTPError{http.StatusUnauthorized, \"You don't have permission to access this collection.\"}\n\n\tErrNoPublishableContent = impart.HTTPError{http.StatusBadRequest, \"Supply something to publish.\"}\n\n\tErrInternalGeneral       = impart.HTTPError{http.StatusInternalServerError, \"The humans messed something up. They've been notified.\"}\n\tErrInternalCookieSession = impart.HTTPError{http.StatusInternalServerError, \"Could not get cookie session.\"}\n\n\tErrUnavailable = impart.HTTPError{http.StatusServiceUnavailable, \"Service temporarily unavailable due to high load.\"}\n\n\tErrCollectionNotFound     = impart.HTTPError{http.StatusNotFound, \"Collection doesn't exist.\"}\n\tErrCollectionGone         = impart.HTTPError{http.StatusGone, \"This blog was unpublished.\"}\n\tErrCollectionPageNotFound = impart.HTTPError{http.StatusNotFound, \"Collection page doesn't exist.\"}\n\tErrPostNotFound           = impart.HTTPError{Status: http.StatusNotFound, Message: \"Post not found.\"}\n\tErrPostBanned             = impart.HTTPError{Status: http.StatusGone, Message: \"Post removed.\"}\n\tErrPostUnpublished        = impart.HTTPError{Status: http.StatusGone, Message: \"Post unpublished by author.\"}\n\tErrPostFetchError         = impart.HTTPError{Status: http.StatusInternalServerError, Message: \"We encountered an error getting the post. The humans have been alerted.\"}\n\n\tErrUserNotFound       = impart.HTTPError{http.StatusNotFound, \"User doesn't exist.\"}\n\tErrRemoteUserNotFound = impart.HTTPError{http.StatusNotFound, \"Remote user not found.\"}\n\tErrUserNotFoundEmail  = impart.HTTPError{http.StatusNotFound, \"Please enter your username instead of your email address.\"}\n\n\tErrUserSilenced = impart.HTTPError{http.StatusForbidden, \"Account is silenced.\"}\n\n\tErrDisabledPasswordAuth = impart.HTTPError{http.StatusForbidden, \"Password authentication is disabled.\"}\n)\n\n// Post operation errors\nvar (\n\tErrPostNoUpdatableVals = impart.HTTPError{http.StatusBadRequest, \"Supply some properties to update.\"}\n)\n"
        },
        {
          "name": "export.go",
          "type": "blob",
          "size": 2.958984375,
          "content": "/*\n * Copyright © 2018-2019 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"encoding/csv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/writeas/web-core/log\"\n)\n\nfunc exportPostsCSV(hostName string, u *User, posts *[]PublicPost) []byte {\n\tvar b bytes.Buffer\n\n\tr := [][]string{\n\t\t{\"id\", \"slug\", \"blog\", \"url\", \"created\", \"title\", \"body\"},\n\t}\n\tfor _, p := range *posts {\n\t\tvar blog string\n\t\tif p.Collection != nil {\n\t\t\tblog = p.Collection.Alias\n\t\t\tp.Collection.hostName = hostName\n\t\t}\n\t\tf := []string{p.ID, p.Slug.String, blog, p.CanonicalURL(hostName), p.Created8601(), p.Title.String, strings.Replace(p.Content, \"\\n\", \"\\\\n\", -1)}\n\t\tr = append(r, f)\n\t}\n\n\tw := csv.NewWriter(&b)\n\tw.WriteAll(r) // calls Flush internally\n\tif err := w.Error(); err != nil {\n\t\tlog.Info(\"error writing csv: %v\", err)\n\t}\n\n\treturn b.Bytes()\n}\n\ntype exportedTxt struct {\n\tName, Title, Body string\n\n\tMod time.Time\n}\n\nfunc exportPostsZip(u *User, posts *[]PublicPost) []byte {\n\t// Create a buffer to write our archive to.\n\tb := new(bytes.Buffer)\n\n\t// Create a new zip archive.\n\tw := zip.NewWriter(b)\n\n\t// Add some files to the archive.\n\tvar filename string\n\tfiles := []exportedTxt{}\n\tfor _, p := range *posts {\n\t\tfilename = \"\"\n\t\tif p.Collection != nil {\n\t\t\tfilename += p.Collection.Alias + \"/\"\n\t\t}\n\t\tif p.Slug.String != \"\" {\n\t\t\tfilename += p.Slug.String + \"_\"\n\t\t}\n\t\tfilename += p.ID + \".txt\"\n\t\tfiles = append(files, exportedTxt{filename, p.Title.String, p.Content, p.Created})\n\t}\n\n\tfor _, file := range files {\n\t\thead := &zip.FileHeader{Name: file.Name}\n\t\thead.SetModTime(file.Mod)\n\t\tf, err := w.CreateHeader(head)\n\t\tif err != nil {\n\t\t\tlog.Error(\"export zip header: %v\", err)\n\t\t}\n\t\tvar fullPost string\n\t\tif file.Title != \"\" {\n\t\t\tfullPost = \"# \" + file.Title + \"\\n\\n\"\n\t\t}\n\t\tfullPost += file.Body\n\t\t_, err = f.Write([]byte(fullPost))\n\t\tif err != nil {\n\t\t\tlog.Error(\"export zip write: %v\", err)\n\t\t}\n\t}\n\n\t// Make sure to check the error on Close.\n\terr := w.Close()\n\tif err != nil {\n\t\tlog.Error(\"export zip close: %v\", err)\n\t}\n\n\treturn b.Bytes()\n}\n\nfunc compileFullExport(app *App, u *User) *ExportUser {\n\texportUser := &ExportUser{\n\t\tUser: u,\n\t}\n\n\tcolls, err := app.db.GetCollections(u, app.cfg.App.Host)\n\tif err != nil {\n\t\tlog.Error(\"unable to fetch collections: %v\", err)\n\t}\n\n\tposts, err := app.db.GetAnonymousPosts(u, 0)\n\tif err != nil {\n\t\tlog.Error(\"unable to fetch anon posts: %v\", err)\n\t}\n\texportUser.AnonymousPosts = *posts\n\n\tvar collObjs []CollectionObj\n\tfor _, c := range *colls {\n\t\tco := &CollectionObj{Collection: c}\n\t\tco.Posts, err = app.db.GetPosts(app.cfg, &c, 0, true, false, true)\n\t\tif err != nil {\n\t\t\tlog.Error(\"unable to get collection posts: %v\", err)\n\t\t}\n\t\tapp.db.GetPostsCount(co, true)\n\t\tcollObjs = append(collObjs, *co)\n\t}\n\texportUser.Collections = &collObjs\n\n\treturn exportUser\n}\n"
        },
        {
          "name": "feed.go",
          "type": "blob",
          "size": 3.0791015625,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/feeds\"\n\t\"github.com/gorilla/mux\"\n\tstripmd \"github.com/writeas/go-strip-markdown/v2\"\n\t\"github.com/writeas/web-core/log\"\n)\n\nfunc ViewFeed(app *App, w http.ResponseWriter, req *http.Request) error {\n\talias := collectionAliasFromReq(req)\n\n\t// Display collection if this is a collection\n\tvar c *Collection\n\tvar err error\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tsilenced, err := app.db.IsUserSilenced(c.OwnerID)\n\tif err != nil {\n\t\tlog.Error(\"view feed: get user: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\tif silenced {\n\t\treturn ErrCollectionNotFound\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tif c.IsPrivate() || c.IsProtected() {\n\t\treturn ErrCollectionNotFound\n\t}\n\n\t// Fetch extra data about the Collection\n\t// TODO: refactor out this logic, shared in collection.go:fetchCollection()\n\tcoll := &DisplayCollection{CollectionObj: &CollectionObj{Collection: *c}}\n\tif c.PublicOwner {\n\t\tu, err := app.db.GetUserByID(coll.OwnerID)\n\t\tif err != nil {\n\t\t\t// Log the error and just continue\n\t\t\tlog.Error(\"Error getting user for collection: %v\", err)\n\t\t} else {\n\t\t\tcoll.Owner = u\n\t\t}\n\t}\n\n\ttag := mux.Vars(req)[\"tag\"]\n\tif tag != \"\" {\n\t\tcoll.Posts, _ = app.db.GetPostsTagged(app.cfg, c, tag, 1, false)\n\t} else {\n\t\tcoll.Posts, _ = app.db.GetPosts(app.cfg, c, 1, false, true, false)\n\t}\n\n\tauthor := \"\"\n\tif coll.Owner != nil {\n\t\tauthor = coll.Owner.Username\n\t}\n\n\tcollectionTitle := coll.DisplayTitle()\n\tif tag != \"\" {\n\t\tcollectionTitle = tag + \" &mdash; \" + collectionTitle\n\t}\n\n\tbaseUrl := coll.CanonicalURL()\n\tbasePermalinkUrl := baseUrl\n\tsiteURL := baseUrl\n\tif tag != \"\" {\n\t\tsiteURL += \"tag:\" + tag\n\t}\n\n\tfeed := &feeds.Feed{\n\t\tTitle:       collectionTitle,\n\t\tLink:        &feeds.Link{Href: siteURL},\n\t\tDescription: coll.Description,\n\t\tAuthor:      &feeds.Author{author, \"\"},\n\t\tCreated:     time.Now(),\n\t}\n\n\tvar title, permalink string\n\tfor _, p := range *coll.Posts {\n\t\t// Add necessary path back to the web browser for Web Monetization if needed\n\t\tp.Collection = coll.CollectionObj // augmentReadingDestination requires a populated Collection field\n\t\tp.augmentReadingDestination()\n\t\t// Create the item for the feed\n\t\ttitle = p.PlainDisplayTitle()\n\t\tpermalink = fmt.Sprintf(\"%s%s\", baseUrl, p.Slug.String)\n\t\tfeed.Items = append(feed.Items, &feeds.Item{\n\t\t\tId:          fmt.Sprintf(\"%s%s\", basePermalinkUrl, p.Slug.String),\n\t\t\tTitle:       title,\n\t\t\tLink:        &feeds.Link{Href: permalink},\n\t\t\tDescription: \"<![CDATA[\" + stripmd.Strip(p.Content) + \"]]>\",\n\t\t\tContent:     string(p.HTMLContent),\n\t\t\tAuthor:      &feeds.Author{author, \"\"},\n\t\t\tCreated:     p.Created,\n\t\t\tUpdated:     p.Updated,\n\t\t})\n\t}\n\n\trss, err := feed.ToRss()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprint(w, rss)\n\treturn nil\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 4.240234375,
          "content": "module github.com/writefreely/writefreely\n\nrequire (\n\tgithub.com/PuerkitoBio/goquery v1.8.1 // indirect\n\tgithub.com/aymerick/douceur v0.2.0\n\tgithub.com/clbanning/mxj v1.8.4 // indirect\n\tgithub.com/dustin/go-humanize v1.0.1\n\tgithub.com/facebookgo/ensure v0.0.0-20200202191622-63f1cf65ac4c // indirect\n\tgithub.com/facebookgo/stack v0.0.0-20160209184415-751773369052 // indirect\n\tgithub.com/facebookgo/subset v0.0.0-20200203212716-c811ad88dec4 // indirect\n\tgithub.com/fatih/color v1.17.0\n\tgithub.com/go-ini/ini v1.67.0\n\tgithub.com/go-sql-driver/mysql v1.8.1\n\tgithub.com/go-test/deep v1.0.1 // indirect\n\tgithub.com/gobuffalo/envy v1.9.0 // indirect\n\tgithub.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e // indirect\n\tgithub.com/gorilla/csrf v1.7.2\n\tgithub.com/gorilla/feeds v1.1.2\n\tgithub.com/gorilla/mux v1.8.1\n\tgithub.com/gorilla/schema v1.4.1\n\tgithub.com/gorilla/sessions v1.3.0\n\tgithub.com/gosimple/slug v1.14.0\n\tgithub.com/guregu/null v4.0.0+incompatible\n\tgithub.com/hashicorp/go-multierror v1.1.1\n\tgithub.com/ikeikeikeike/go-sitemap-generator/v2 v2.0.2\n\tgithub.com/kylemcc/twitter-text-go v0.0.0-20180726194232-7f582f6736ec\n\tgithub.com/mailgun/mailgun-go v2.0.0+incompatible\n\tgithub.com/manifoldco/promptui v0.9.0\n\tgithub.com/mattn/go-sqlite3 v1.14.21\n\tgithub.com/microcosm-cc/bluemonday v1.0.26\n\tgithub.com/mitchellh/go-wordwrap v1.0.1\n\tgithub.com/nu7hatch/gouuid v0.0.0-20131221200532-179d4d0c4d8d\n\tgithub.com/onsi/ginkgo v1.16.4 // indirect\n\tgithub.com/onsi/gomega v1.13.0 // indirect\n\tgithub.com/rainycape/unidecode v0.0.0-20150907023854-cb7f23ec59be // indirect\n\tgithub.com/smartystreets/assertions v0.0.0-20190116191733-b6c0e53d7304 // indirect\n\tgithub.com/smartystreets/goconvey v0.0.0-20181108003508-044398e4856c // indirect\n\tgithub.com/stretchr/testify v1.9.0\n\tgithub.com/urfave/cli/v2 v2.27.4\n\tgithub.com/writeas/activity v0.1.2\n\tgithub.com/writeas/activityserve v0.0.0-20230428180247-dc13a4f4d835\n\tgithub.com/writeas/go-strip-markdown/v2 v2.1.1\n\tgithub.com/writeas/go-webfinger v1.1.0\n\tgithub.com/writeas/httpsig v1.0.0\n\tgithub.com/writeas/impart v1.1.1\n\tgithub.com/writeas/import v0.2.1\n\tgithub.com/writeas/monday v1.3.0\n\tgithub.com/writeas/saturday v1.7.2-0.20200427193424-392b95a03320\n\tgithub.com/writeas/web-core v1.6.1-0.20231003013047-d81124d45431\n\tgithub.com/writefreely/go-gopher v0.0.0-20220429181814-40127126f83b\n\tgithub.com/writefreely/go-nodeinfo v1.2.0\n\tgolang.org/x/crypto v0.28.0\n\tgolang.org/x/net v0.30.0\n)\n\nrequire (\n\tcode.as/core/socks v1.0.0 // indirect\n\tfilippo.io/edwards25519 v1.1.0 // indirect\n\tgithub.com/andybalholm/cascadia v1.3.2 // indirect\n\tgithub.com/beevik/etree v1.1.0 // indirect\n\tgithub.com/captncraig/cors v0.0.0-20190703115713-e80254a89df1 // indirect\n\tgithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e // indirect\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.4 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/dchest/uniuri v0.0.0-20200228104902-7aecb25e1fe5 // indirect\n\tgithub.com/fatih/structs v1.1.0 // indirect\n\tgithub.com/go-fed/httpsig v0.1.1-0.20200204213531-0ef28562fabe // indirect\n\tgithub.com/gofrs/uuid v3.3.0+incompatible // indirect\n\tgithub.com/gologme/log v1.2.0 // indirect\n\tgithub.com/gorilla/css v1.0.0 // indirect\n\tgithub.com/gorilla/securecookie v1.1.2 // indirect\n\tgithub.com/gosimple/unidecode v1.0.1 // indirect\n\tgithub.com/hashicorp/errwrap v1.0.0 // indirect\n\tgithub.com/joho/godotenv v1.3.0 // indirect\n\tgithub.com/jtolds/gls v4.2.1+incompatible // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/petermattis/goid v0.0.0-20180202154549-b0b1615b78e5 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rogpeppe/go-internal v1.9.0 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n\tgithub.com/sasha-s/go-deadlock v0.3.1 // indirect\n\tgithub.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect\n\tgithub.com/writeas/go-writeas/v2 v2.0.2 // indirect\n\tgithub.com/writeas/openssl-go v1.0.0 // indirect\n\tgithub.com/writeas/slug v1.2.0 // indirect\n\tgithub.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect\n\tgolang.org/x/sys v0.26.0 // indirect\n\tgolang.org/x/text v0.19.0 // indirect\n\tgopkg.in/ini.v1 v1.62.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n\ngo 1.21\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 30.0478515625,
          "content": "code.as/core/socks v1.0.0 h1:SPQXNp4SbEwjOAP9VzUahLHak8SDqy5n+9cm9tpjZOs=\ncode.as/core/socks v1.0.0/go.mod h1:BAXBy5O9s2gmw6UxLqNJcVbWY7C/UPs+801CcSsfWOY=\nfilippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\nfilippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\ngithub.com/PuerkitoBio/goquery v1.8.1 h1:uQxhNlArOIdbrH1tr0UXwdVFgDcZDrZVdcpygAcwmWM=\ngithub.com/PuerkitoBio/goquery v1.8.1/go.mod h1:Q8ICL1kNUJ2sXGoAhPGUdYDJvgQgHzJsnnd3H7Ho5jQ=\ngithub.com/andybalholm/cascadia v1.3.1/go.mod h1:R4bJ1UQfqADjvDa4P6HZHLh/3OxWWEqc0Sk8XGwHqvA=\ngithub.com/andybalholm/cascadia v1.3.2 h1:3Xi6Dw5lHF15JtdcmAHD3i1+T8plmv7BQ/nsViSLyss=\ngithub.com/andybalholm/cascadia v1.3.2/go.mod h1:7gtRlve5FxPPgIgX36uWBX58OdBsSS6lUvCFb+h7KvU=\ngithub.com/aymerick/douceur v0.2.0 h1:Mv+mAeH1Q+n9Fr+oyamOlAkUNPWPlA8PPGR0QAaYuPk=\ngithub.com/aymerick/douceur v0.2.0/go.mod h1:wlT5vV2O3h55X9m7iVYN0TBM0NH/MmbLnd30/FjWUq4=\ngithub.com/beevik/etree v1.1.0 h1:T0xke/WvNtMoCqgzPhkX2r4rjY3GDZFi+FjpRZY2Jbs=\ngithub.com/beevik/etree v1.1.0/go.mod h1:r8Aw8JqVegEf0w2fDnATrX9VpkMcyFeM0FhwO62wh+A=\ngithub.com/captncraig/cors v0.0.0-20190703115713-e80254a89df1 h1:AFSJaASPGYNbkUa5c8ZybrcW9pP3Cy7+z5dnpcc/qG8=\ngithub.com/captncraig/cors v0.0.0-20190703115713-e80254a89df1/go.mod h1:EIlIeMufZ8nqdUhnesledB15xLRl4wIJUppwDLPrdrQ=\ngithub.com/chzyer/logex v1.1.10 h1:Swpa1K6QvQznwJRcfTfQJmTE72DqScAa40E+fbHEXEE=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e h1:fY5BOSpyZCqRo5OhCuC+XN+r/bBCmeuuJtjz+bCNIf8=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1 h1:q763qf9huN11kDQavWsoZXJNW3xEE4JJyHa5Q25/sd8=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/clbanning/mxj v1.8.3/go.mod h1:BVjHeAH+rl9rs6f+QIpeRl0tfu10SXn1pUSa5PVGJng=\ngithub.com/clbanning/mxj v1.8.4 h1:HuhwZtbyvyOw+3Z1AowPkU87JkJUSv751ELWaiTpj8I=\ngithub.com/clbanning/mxj v1.8.4/go.mod h1:BVjHeAH+rl9rs6f+QIpeRl0tfu10SXn1pUSa5PVGJng=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4 h1:wfIWP927BUkWJb2NmU/kNDYIBTh/ziUX91+lVfRxZq4=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dchest/uniuri v0.0.0-20200228104902-7aecb25e1fe5 h1:RAV05c0xOkJ3dZGS0JFybxFKZ2WMLabgx3uXnd7rpGs=\ngithub.com/dchest/uniuri v0.0.0-20200228104902-7aecb25e1fe5/go.mod h1:GgB8SF9nRG+GqaDtLcwJZsQFhcogVCJ79j4EdT0c2V4=\ngithub.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=\ngithub.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=\ngithub.com/facebookgo/ensure v0.0.0-20200202191622-63f1cf65ac4c h1:8ISkoahWXwZR41ois5lSJBSVw4D0OV19Ht/JSTzvSv0=\ngithub.com/facebookgo/ensure v0.0.0-20200202191622-63f1cf65ac4c/go.mod h1:Yg+htXGokKKdzcwhuNDwVvN+uBxDGXJ7G/VN1d8fa64=\ngithub.com/facebookgo/stack v0.0.0-20160209184415-751773369052 h1:JWuenKqqX8nojtoVVWjGfOF9635RETekkoH6Cc9SX0A=\ngithub.com/facebookgo/stack v0.0.0-20160209184415-751773369052/go.mod h1:UbMTZqLaRiH3MsBH8va0n7s1pQYcu3uTb8G4tygF4Zg=\ngithub.com/facebookgo/subset v0.0.0-20200203212716-c811ad88dec4 h1:7HZCaLC5+BZpmbhCOZJ293Lz68O7PYrF2EzeiFMwCLk=\ngithub.com/facebookgo/subset v0.0.0-20200203212716-c811ad88dec4/go.mod h1:5tD+neXqOorC30/tWg0LCSkrqj/AR6gu8yY8/fpw1q0=\ngithub.com/fatih/color v1.17.0 h1:GlRw1BRJxkpqUCBKzKOw098ed57fEsKeNjpTe3cSjK4=\ngithub.com/fatih/color v1.17.0/go.mod h1:YZ7TlrGPkiz6ku9fK3TLD/pl3CpsiFyu8N92HLgmosI=\ngithub.com/fatih/structs v1.1.0 h1:Q7juDM0QtcnhCpeyLGQKyg4TOIghuNXrkL32pHAUMxo=\ngithub.com/fatih/structs v1.1.0/go.mod h1:9NiDSp5zOcgEDl+j00MP/WkGVPOlPRLejGD8Ga6PJ7M=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/fsnotify/fsnotify v1.4.9 h1:hsms1Qyu0jgnwNXIxa+/V/PDsU6CfLf6CNO8H7IWoS4=\ngithub.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=\ngithub.com/go-fed/httpsig v0.1.0/go.mod h1:T56HUNYZUQ1AGUzhAYPugZfp36sKApVnGBgKlIY+aIE=\ngithub.com/go-fed/httpsig v0.1.1-0.20200204213531-0ef28562fabe h1:U71giCx5NjRn4Lb71UuprPHqhjxGv3Jqonb9fgcaJH8=\ngithub.com/go-fed/httpsig v0.1.1-0.20200204213531-0ef28562fabe/go.mod h1:T56HUNYZUQ1AGUzhAYPugZfp36sKApVnGBgKlIY+aIE=\ngithub.com/go-ini/ini v1.67.0 h1:z6ZrTEZqSWOTyH2FlglNbNgARyHG8oLW9gMELqKr06A=\ngithub.com/go-ini/ini v1.67.0/go.mod h1:ByCAeIL28uOIIG0E3PJtZPDL8WnHpFKFOtgjp+3Ies8=\ngithub.com/go-sql-driver/mysql v1.8.1 h1:LedoTUt/eveggdHS9qUFC1EFSa8bU2+1pZjSRpvNJ1Y=\ngithub.com/go-sql-driver/mysql v1.8.1/go.mod h1:wEBSXgmK//2ZFJyE+qWnIsVGmvmEKlqwuVSjsCm7DZg=\ngithub.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0/go.mod h1:fyg7847qk6SyHyPtNmDHnmrv/HOrqktSC+C9fM+CJOE=\ngithub.com/go-test/deep v1.0.1 h1:UQhStjbkDClarlmv0am7OXXO4/GaPdCGiUiMTvi28sg=\ngithub.com/go-test/deep v1.0.1/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=\ngithub.com/gobuffalo/envy v1.9.0 h1:eZR0DuEgVLfeIb1zIKt3bT4YovIMf9O9LXQeCZLXpqE=\ngithub.com/gobuffalo/envy v1.9.0/go.mod h1:FurDp9+EDPE4aIUS3ZLyD+7/9fpx7YRt/ukY6jIHf0w=\ngithub.com/gofrs/uuid v3.3.0+incompatible h1:8K4tyRfvU1CYPgJsveYFQMhpFd/wXNM7iK6rR7UHz84=\ngithub.com/gofrs/uuid v3.3.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/gologme/log v1.2.0 h1:Ya5Ip/KD6FX7uH0S31QO87nCCSucKtF44TLbTtO7V4c=\ngithub.com/gologme/log v1.2.0/go.mod h1:gq31gQ8wEHkR+WekdWsqDuf8pXTUZA9BnnzTuPz1Y9U=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/gofuzz v1.2.0 h1:xRy4A+RhZaiKjJ1bPfwQ8sedCA+YS2YcCHW6ec7JMi0=\ngithub.com/google/gofuzz v1.2.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e h1:JKmoR8x90Iww1ks85zJ1lfDGgIiMDuIptTOhJq+zKyg=\ngithub.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gorilla/csrf v1.7.2 h1:oTUjx0vyf2T+wkrx09Trsev1TE+/EbDAeHtSTbtC2eI=\ngithub.com/gorilla/csrf v1.7.2/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\ngithub.com/gorilla/css v1.0.0 h1:BQqNyPTi50JCFMTw/b67hByjMVXZRwGha6wxVGkeihY=\ngithub.com/gorilla/css v1.0.0/go.mod h1:Dn721qIggHpt4+EFCcTLTU/vk5ySda2ReITrtgBl60c=\ngithub.com/gorilla/feeds v1.1.2 h1:pxzZ5PD3RJdhFH2FsJJ4x6PqMqbgFk1+Vez4XWBW8Iw=\ngithub.com/gorilla/feeds v1.1.2/go.mod h1:WMib8uJP3BbY+X8Szd1rA5Pzhdfh+HCCAYT2z7Fza6Y=\ngithub.com/gorilla/mux v1.7.4/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=\ngithub.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=\ngithub.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=\ngithub.com/gorilla/schema v1.4.1 h1:jUg5hUjCSDZpNGLuXQOgIWGdlgrIdYvgQ0wZtdK1M3E=\ngithub.com/gorilla/schema v1.4.1/go.mod h1:Dg5SSm5PV60mhF2NFaTV1xuYYj8tV8NOPRo4FggUMnM=\ngithub.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\ngithub.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\ngithub.com/gorilla/sessions v1.3.0 h1:XYlkq7KcpOB2ZhHBPv5WpjMIxrQosiZanfoy1HLZFzg=\ngithub.com/gorilla/sessions v1.3.0/go.mod h1:ePLdVu+jbEgHH+KWw8I1z2wqd0BAdAQh/8LRvBeoNcQ=\ngithub.com/gosimple/slug v1.14.0 h1:RtTL/71mJNDfpUbCOmnf/XFkzKRtD6wL6Uy+3akm4Es=\ngithub.com/gosimple/slug v1.14.0/go.mod h1:UiRaFH+GEilHstLUmcBgWcI42viBN7mAb818JrYOeFQ=\ngithub.com/gosimple/unidecode v1.0.1 h1:hZzFTMMqSswvf0LBJZCZgThIZrpDHFXux9KeGmn6T/o=\ngithub.com/gosimple/unidecode v1.0.1/go.mod h1:CP0Cr1Y1kogOtx0bJblKzsVWrqYaqfNOnHzpgWw4Awc=\ngithub.com/guregu/null v4.0.0+incompatible h1:4zw0ckM7ECd6FNNddc3Fu4aty9nTlpkkzH7dPn4/4Gw=\ngithub.com/guregu/null v4.0.0+incompatible/go.mod h1:ePGpQaN9cw0tj45IR5E5ehMvsFlLlQZAkkOXZurJ3NM=\ngithub.com/hashicorp/errwrap v1.0.0 h1:hLrqtEDnRye3+sgx6z4qVLNuviH3MR5aQ0ykNJa/UYA=\ngithub.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/go-multierror v1.0.0/go.mod h1:dHtQlpGsu+cZNNAkkCN/P3hoUDHhCYQXV3UM06sGGrk=\ngithub.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=\ngithub.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/ikeikeikeike/go-sitemap-generator/v2 v2.0.2 h1:wIdDEle9HEy7vBPjC6oKz6ejs3Ut+jmsYvuOoAW2pSM=\ngithub.com/ikeikeikeike/go-sitemap-generator/v2 v2.0.2/go.mod h1:WtaVKD9TeruTED9ydiaOJU08qGoEPP/LyzTKiD3jEsw=\ngithub.com/joho/godotenv v1.3.0 h1:Zjp+RcGpHhGlrMbJzXTrZZPrWj+1vfm90La1wgB6Bhc=\ngithub.com/joho/godotenv v1.3.0/go.mod h1:7hK45KPybAkOC6peb+G5yklZfMxEjkZhHbwpqxOKXbg=\ngithub.com/jtolds/gls v4.2.1+incompatible h1:fSuqC+Gmlu6l/ZYAoZzx2pyucC8Xza35fpRVWLVmUEE=\ngithub.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/kylemcc/twitter-text-go v0.0.0-20180726194232-7f582f6736ec h1:ZXWuspqypleMuJy4bzYEqlMhJnGAYpLrWe5p7W3CdvI=\ngithub.com/kylemcc/twitter-text-go v0.0.0-20180726194232-7f582f6736ec/go.mod h1:voECJzdraJmolzPBgL9Z7ANwXf4oMXaTCsIkdiPpR/g=\ngithub.com/mailgun/mailgun-go v2.0.0+incompatible h1:0FoRHWwMUctnd8KIR3vtZbqdfjpIMxOZgcSa51s8F8o=\ngithub.com/mailgun/mailgun-go v2.0.0+incompatible/go.mod h1:NWTyU+O4aczg/nsGhQnvHL6v2n5Gy6Sv5tNDVvC6FbU=\ngithub.com/manifoldco/promptui v0.9.0 h1:3V4HzJk1TtXW1MTZMP7mdlwbBpIinw3HztaIlYthEiA=\ngithub.com/manifoldco/promptui v0.9.0/go.mod h1:ka04sppxSGFAtxX0qhlYQjISsg9mR4GWtQEhdbn6Pgg=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-sqlite3 v1.14.21 h1:IXocQLOykluc3xPE0Lvy8FtggMz1G+U3mEjg+0zGizc=\ngithub.com/mattn/go-sqlite3 v1.14.21/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=\ngithub.com/microcosm-cc/bluemonday v1.0.23/go.mod h1:mN70sk7UkkF8TUr2IGBpNN0jAgStuPzlK76QuruE/z4=\ngithub.com/microcosm-cc/bluemonday v1.0.26 h1:xbqSvqzQMeEHCqMi64VAs4d8uy6Mequs3rQ0k/Khz58=\ngithub.com/microcosm-cc/bluemonday v1.0.26/go.mod h1:JyzOCs9gkyQyjs+6h10UEVSe02CGwkhd72Xdqh78TWs=\ngithub.com/mitchellh/go-wordwrap v1.0.1 h1:TLuKupo69TCn6TQSyGxwI1EblZZEsQ0vMlAFQflz0v0=\ngithub.com/mitchellh/go-wordwrap v1.0.1/go.mod h1:R62XHJLzvMFRBbcrT7m7WgmE1eOyTSsCt+hzestvNj0=\ngithub.com/nu7hatch/gouuid v0.0.0-20131221200532-179d4d0c4d8d h1:VhgPp6v9qf9Agr/56bj7Y/xa04UccTW04VP0Qed4vnQ=\ngithub.com/nu7hatch/gouuid v0.0.0-20131221200532-179d4d0c4d8d/go.mod h1:YUTz3bUH2ZwIWBy3CJBeOBEugqcmXREj14T+iG/4k4U=\ngithub.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=\ngithub.com/nxadm/tail v1.4.8 h1:nPr65rt6Y5JFSKQO7qToXr7pePgD6Gwiw05lkbyAQTE=\ngithub.com/nxadm/tail v1.4.8/go.mod h1:+ncqLTQzXmGhMZNUePPaPqPvBxHAIsmXswZKocGu+AU=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=\ngithub.com/onsi/ginkgo v1.16.2/go.mod h1:CObGmKUOKaSC0RjmoAK7tKyn4Azo5P2IWuoMnvwxz1E=\ngithub.com/onsi/ginkgo v1.16.4 h1:29JGrr5oVBm5ulCWet69zQkzWipVXIol6ygQUe/EzNc=\ngithub.com/onsi/ginkgo v1.16.4/go.mod h1:dX+/inL/fNMqNlz0e9LfyB9TswhZpCVdJM/Z6Vvnwo0=\ngithub.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=\ngithub.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\ngithub.com/onsi/gomega v1.13.0 h1:7lLHu94wT9Ij0o6EWWclhu0aOh32VxhkwEJvzuWPeak=\ngithub.com/onsi/gomega v1.13.0/go.mod h1:lRk9szgn8TxENtWd0Tp4c3wjlRfMTMH27I+3Je41yGY=\ngithub.com/petermattis/goid v0.0.0-20180202154549-b0b1615b78e5 h1:q2e307iGHPdTGp0hoxKjt1H5pDo6utceo3dQVK3I5XQ=\ngithub.com/petermattis/goid v0.0.0-20180202154549-b0b1615b78e5/go.mod h1:jvVRKCrJTQWu0XVbaOlby/2lO20uSCHEMzzplHXte1o=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rainycape/unidecode v0.0.0-20150907023854-cb7f23ec59be h1:ta7tUOvsPHVHGom5hKW5VXNc2xZIkfCKP8iaqOyYtUQ=\ngithub.com/rainycape/unidecode v0.0.0-20150907023854-cb7f23ec59be/go.mod h1:MIDFMn7db1kT65GmV94GzpX9Qdi7N/pQlwb+AN8wh+Q=\ngithub.com/rogpeppe/go-internal v1.3.2/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=\ngithub.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/sasha-s/go-deadlock v0.3.1 h1:sqv7fDNShgjcaxkO0JNcOAlr8B9+cV5Ey/OB71efZx0=\ngithub.com/sasha-s/go-deadlock v0.3.1/go.mod h1:F73l+cr82YSh10GxyRI6qZiCgK64VaZjwesgfQ1/iLM=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/smartystreets/assertions v0.0.0-20190116191733-b6c0e53d7304 h1:Jpy1PXuP99tXNrhbq2BaPz9B+jNAvH1JPQQpG/9GCXY=\ngithub.com/smartystreets/assertions v0.0.0-20190116191733-b6c0e53d7304/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\ngithub.com/smartystreets/goconvey v0.0.0-20181108003508-044398e4856c h1:Ho+uVpkel/udgjbwB5Lktg9BtvJSh2DT0Hi6LPSyI2w=\ngithub.com/smartystreets/goconvey v0.0.0-20181108003508-044398e4856c/go.mod h1:XDJAKZRPZ1CvBcN2aX5YOUTYGHki24fSF0Iv48Ibg0s=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/urfave/cli/v2 v2.27.4 h1:o1owoI+02Eb+K107p27wEX9Bb8eqIoZCfLXloLUSWJ8=\ngithub.com/urfave/cli/v2 v2.27.4/go.mod h1:m4QzxcD2qpra4z7WhzEGn74WZLViBnMpb1ToCAKdGRQ=\ngithub.com/writeas/activity v0.1.2 h1:Y12B5lIrabfqKE7e7HFCWiXrlfXljr9tlkFm2mp7DgY=\ngithub.com/writeas/activity v0.1.2/go.mod h1:mYYgiewmEM+8tlifirK/vl6tmB2EbjYaxwb+ndUw5T0=\ngithub.com/writeas/activityserve v0.0.0-20230428180247-dc13a4f4d835 h1:bm/7gYo6y3GxtTa1qyUFyCk29CTnBAKt7z4D2MASYrw=\ngithub.com/writeas/activityserve v0.0.0-20230428180247-dc13a4f4d835/go.mod h1:4akDJSl+sSp+QhrQKMqzAqdV1gJ1pPx6XPI77zgMM8o=\ngithub.com/writeas/go-strip-markdown/v2 v2.1.1 h1:hAxUM21Uhznf/FnbVGiJciqzska6iLei22Ijc3q2e28=\ngithub.com/writeas/go-strip-markdown/v2 v2.1.1/go.mod h1:UvvgPJgn1vvN8nWuE5e7v/+qmDu3BSVnKAB6Gl7hFzA=\ngithub.com/writeas/go-webfinger v1.1.0 h1:MzNyt0ry/GMsRmJGftn2o9mPwqK1Q5MLdh4VuJCfb1Q=\ngithub.com/writeas/go-webfinger v1.1.0/go.mod h1:w2VxyRO/J5vfNjJHYVubsjUGHd3RLDoVciz0DE3ApOc=\ngithub.com/writeas/go-writeas v1.1.0/go.mod h1:oh9U1rWaiE0p3kzdKwwvOpNXgp0P0IELI7OLOwV4fkA=\ngithub.com/writeas/go-writeas/v2 v2.0.2 h1:akvdMg89U5oBJiCkBwOXljVLTqP354uN6qnG2oOMrbk=\ngithub.com/writeas/go-writeas/v2 v2.0.2/go.mod h1:9sjczQJKmru925fLzg0usrU1R1tE4vBmQtGnItUMR0M=\ngithub.com/writeas/httpsig v1.0.0 h1:peIAoIA3DmlP8IG8tMNZqI4YD1uEnWBmkcC9OFPjt3A=\ngithub.com/writeas/httpsig v1.0.0/go.mod h1:7ClMGSrSVXJbmiLa17bZ1LrG1oibGZmUMlh3402flPY=\ngithub.com/writeas/impart v1.1.0/go.mod h1:g0MpxdnTOHHrl+Ca/2oMXUHJ0PcRAEWtkCzYCJUXC9Y=\ngithub.com/writeas/impart v1.1.1 h1:RyA9+CqbdbDuz53k+nXCWUY+NlEkdyw6+nWanxSBl5o=\ngithub.com/writeas/impart v1.1.1/go.mod h1:g0MpxdnTOHHrl+Ca/2oMXUHJ0PcRAEWtkCzYCJUXC9Y=\ngithub.com/writeas/import v0.2.1 h1:3k+bDNCyqaWdZinyUZtEO4je3mR6fr/nE4ozTh9/9Wg=\ngithub.com/writeas/import v0.2.1/go.mod h1:gFe0Pl7ZWYiXbI0TJxeMMyylPGZmhVvCfQxhMEc8CxM=\ngithub.com/writeas/monday v1.3.0 h1:h51wJ0DULXIDZ1w11zutLL7YCBRO5LznXISSzqVLZeA=\ngithub.com/writeas/monday v1.3.0/go.mod h1:9/CdGLDdIeAvzvf4oeihX++PE/qXUT2+tUlPQKCfRWY=\ngithub.com/writeas/openssl-go v1.0.0 h1:YXM1tDXeYOlTyJjoMlYLQH1xOloUimSR1WMF8kjFc5o=\ngithub.com/writeas/openssl-go v1.0.0/go.mod h1:WsKeK5jYl0B5y8ggOmtVjbmb+3rEGqSD25TppjJnETA=\ngithub.com/writeas/saturday v1.7.1/go.mod h1:ETE1EK6ogxptJpAgUbcJD0prAtX48bSloie80+tvnzQ=\ngithub.com/writeas/saturday v1.7.2-0.20200427193424-392b95a03320 h1:PozPZ29CQ/xt6ym/+FvIz+KvKEObSSc5ye+95zbTjVU=\ngithub.com/writeas/saturday v1.7.2-0.20200427193424-392b95a03320/go.mod h1:ETE1EK6ogxptJpAgUbcJD0prAtX48bSloie80+tvnzQ=\ngithub.com/writeas/slug v1.2.0 h1:EMQ+cwLiOcA6EtFwUgyw3Ge18x9uflUnOnR6bp/J+/g=\ngithub.com/writeas/slug v1.2.0/go.mod h1:RE8shOqQP3YhsfsQe0L3RnuejfQ4Mk+JjY5YJQFubfQ=\ngithub.com/writeas/web-core v1.6.1-0.20231003013047-d81124d45431 h1:ruqL2u87k504PXkR/fC4DcfZyyHmCindlpjOQKmyOsY=\ngithub.com/writeas/web-core v1.6.1-0.20231003013047-d81124d45431/go.mod h1:7+idL4Y4woF7MnUfNX2mvkaQ8nLIJXths2y5iYPtA3k=\ngithub.com/writefreely/go-gopher v0.0.0-20220429181814-40127126f83b h1:h3NzB8OZ50NNi5k9yrFeyFszt3LyqyVK4+xUHFYY8B0=\ngithub.com/writefreely/go-gopher v0.0.0-20220429181814-40127126f83b/go.mod h1:T2UVVzt+R5KSSZe2xRSytnwc2M9AoDegi7foeIsik+M=\ngithub.com/writefreely/go-nodeinfo v1.2.0 h1:La+YbTCvmpTwFhBSlebWDDL81N88Qf/SCAvRLR7F8ss=\ngithub.com/writefreely/go-nodeinfo v1.2.0/go.mod h1:UTvE78KpcjYOlRHupZIiSEFcXHioTXuacCbHU+CAcPg=\ngithub.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=\ngithub.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20180527072434-ab813273cd59/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.1.0/go.mod h1:RecgLatLF4+eUMCP1PoPZQb+cVrJcOPbHkTkbkB9sbw=\ngolang.org/x/crypto v0.28.0 h1:GBDwsMXVQi34v5CCYUm2jkJvu4cbtru2U4TN2PSyQnw=\ngolang.org/x/crypto v0.28.0/go.mod h1:rmgy+3RHxRZMyY0jjAJShp2zgEdOqj2AO7U0pYmeQ7U=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210428140749-89ef3d95e781/go.mod h1:OJAsFXCWl8Ukc7SiCT/9KSuxbyM7479/AVlXFRxuMCk=\ngolang.org/x/net v0.0.0-20210916014120-12bc252f5db8/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.1.0/go.mod h1:Cx3nUiGt4eDBEyega/BKRp+/AlGL8hYe7U9odMt2Cco=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.7.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.8.0/go.mod h1:QVkue5JL9kW//ek3r6jTKnTFis1tRmNAW2P1shuFdJc=\ngolang.org/x/net v0.9.0/go.mod h1:d48xBJpPfHeWQsugry2m+kC02ZBRGRgulfHnEXEuWns=\ngolang.org/x/net v0.30.0 h1:AcW1SDZMkb8IpzCdQUaIq2sP4sZ4zw+55h6ynffypl4=\ngolang.org/x/net v0.30.0/go.mod h1:2wGyMJ5iFasEhkwi13ChkO/t1ECNC4X4eBKkVFyYFlU=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180525142821-c11f84a56e43/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181122145206-62eef0e2fa9b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210112080510-489259a85091/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.7.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=\ngolang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.6.0/go.mod h1:m6U89DPEgQRMq3DNkDClhWw02AUbt2daBVO4cn4Hv9U=\ngolang.org/x/term v0.7.0/go.mod h1:P32HKFT3hSsZrRxla30E9HqToFYAQPCMs/zFMBUFqPY=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.8.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.19.0 h1:kTxAhCbGbxhK0IwgSKiMO5awPoDQ0RpfiVYBfK860YM=\ngolang.org/x/text v0.19.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20201224043029-2b0845dc783e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/ini.v1 v1.55.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/ini.v1 v1.62.0 h1:duBzk771uxoUuOlyRLkHsygud9+5lrlGjdFBb4mSKDU=\ngopkg.in/ini.v1 v1.62.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/yaml.v1 v1.0.0-20140924161607-9f9df34309c0 h1:POO/ycCATvegFmVuPpQzZFJ+pGZeX22Ufu6fibxDVjU=\ngopkg.in/yaml.v1 v1.0.0-20140924161607-9f9df34309c0/go.mod h1:WDnlLJ4WF5VGsH/HVa3CI79GS0ol3YnhVnKP89i0kNg=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "gopher.go",
          "type": "blob",
          "size": 3.765625,
          "content": "/*\n * Copyright © 2020 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/go-gopher\"\n)\n\nfunc initGopher(apper Apper) {\n\thandler := NewWFHandler(apper)\n\n\tgopher.HandleFunc(\"/\", handler.Gopher(handleGopher))\n\tlog.Info(\"Serving on gopher://localhost:%d\", apper.App().Config().Server.GopherPort)\n\tgopher.ListenAndServe(fmt.Sprintf(\":%d\", apper.App().Config().Server.GopherPort), nil)\n}\n\n// Utility function to strip the URL from the hostname provided by app.cfg.App.Host\nfunc stripHostProtocol(app *App) string {\n\tu, err := url.Parse(app.cfg.App.Host)\n\tif err != nil {\n\t\t// Fall back to host, with scheme stripped\n\t\treturn string(regexp.MustCompile(\"^.*://\").ReplaceAll([]byte(app.cfg.App.Host), []byte(\"\")))\n\t}\n\treturn u.Hostname()\n}\n\nfunc handleGopher(app *App, w gopher.ResponseWriter, r *gopher.Request) error {\n\tparts := strings.Split(r.Selector, \"/\")\n\tif app.cfg.App.SingleUser {\n\t\tif parts[1] != \"\" {\n\t\t\treturn handleGopherCollectionPost(app, w, r)\n\t\t}\n\t\treturn handleGopherCollection(app, w, r)\n\t}\n\n\t// Show all public collections (a gopher Reader view, essentially)\n\tif len(parts) == 3 {\n\t\treturn handleGopherCollection(app, w, r)\n\t}\n\n\tw.WriteInfo(fmt.Sprintf(\"Welcome to %s\", app.cfg.App.SiteName))\n\n\tcolls, err := app.db.GetPublicCollections(app.cfg.App.Host)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, c := range *colls {\n\t\tw.WriteItem(&gopher.Item{\n\t\t\tHost:        stripHostProtocol(app),\n\t\t\tPort:        app.cfg.Server.GopherPort,\n\t\t\tType:        gopher.DIRECTORY,\n\t\t\tDescription: c.DisplayTitle(),\n\t\t\tSelector:    \"/\" + c.Alias + \"/\",\n\t\t})\n\t}\n\treturn w.End()\n}\n\nfunc handleGopherCollection(app *App, w gopher.ResponseWriter, r *gopher.Request) error {\n\tvar collAlias, slug string\n\tvar c *Collection\n\tvar err error\n\tvar baseSel = \"/\"\n\n\tparts := strings.Split(r.Selector, \"/\")\n\tif app.cfg.App.SingleUser {\n\t\t// sanity check\n\t\tslug = parts[1]\n\t\tif slug != \"\" {\n\t\t\treturn handleGopherCollectionPost(app, w, r)\n\t\t}\n\n\t\tc, err = app.db.GetCollectionByID(1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tcollAlias = parts[1]\n\t\tslug = parts[2]\n\t\tif slug != \"\" {\n\t\t\treturn handleGopherCollectionPost(app, w, r)\n\t\t}\n\n\t\tc, err = app.db.GetCollection(collAlias)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbaseSel = \"/\" + c.Alias + \"/\"\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tw.WriteInfo(c.DisplayTitle())\n\tif c.Description != \"\" {\n\t\tw.WriteInfo(c.Description)\n\t}\n\n\tposts, err := app.db.GetPosts(app.cfg, c, 0, false, false, false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, p := range *posts {\n\t\tw.WriteItem(&gopher.Item{\n\t\t\tPort:        app.cfg.Server.GopherPort,\n\t\t\tHost:        stripHostProtocol(app),\n\t\t\tType:        gopher.FILE,\n\t\t\tDescription: p.CreatedDate() + \" - \" + p.DisplayTitle(),\n\t\t\tSelector:    baseSel + p.Slug.String,\n\t\t})\n\t}\n\treturn w.End()\n}\n\nfunc handleGopherCollectionPost(app *App, w gopher.ResponseWriter, r *gopher.Request) error {\n\tvar collAlias, slug string\n\tvar c *Collection\n\tvar err error\n\n\tparts := strings.Split(r.Selector, \"/\")\n\tif app.cfg.App.SingleUser {\n\t\tslug = parts[1]\n\t\tc, err = app.db.GetCollectionByID(1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tcollAlias = parts[1]\n\t\tslug = parts[2]\n\t\tc, err = app.db.GetCollection(collAlias)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tp, err := app.db.GetPost(slug, c.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb := bytes.Buffer{}\n\tif p.Title.String != \"\" {\n\t\tb.WriteString(p.Title.String + \"\\n\")\n\t}\n\tb.WriteString(p.DisplayDate + \"\\n\\n\")\n\tb.WriteString(p.Content)\n\tio.Copy(w, &b)\n\n\treturn w.End()\n}\n"
        },
        {
          "name": "handle.go",
          "type": "blob",
          "size": 28.2431640625,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/go-gopher\"\n\t\"github.com/writefreely/writefreely/config\"\n\t\"github.com/writefreely/writefreely/page\"\n)\n\n// UserLevel represents the required user level for accessing an endpoint\ntype UserLevel int\n\nconst (\n\tUserLevelNoneType         UserLevel = iota // user or not -- ignored\n\tUserLevelOptionalType                      // user or not -- object fetched if user\n\tUserLevelNoneRequiredType                  // non-user (required)\n\tUserLevelUserType                          // user (required)\n)\n\nfunc UserLevelNone(cfg *config.Config) UserLevel {\n\treturn UserLevelNoneType\n}\n\nfunc UserLevelOptional(cfg *config.Config) UserLevel {\n\treturn UserLevelOptionalType\n}\n\nfunc UserLevelNoneRequired(cfg *config.Config) UserLevel {\n\treturn UserLevelNoneRequiredType\n}\n\nfunc UserLevelUser(cfg *config.Config) UserLevel {\n\treturn UserLevelUserType\n}\n\n// UserLevelReader returns the permission level required for any route where\n// users can read published content.\nfunc UserLevelReader(cfg *config.Config) UserLevel {\n\tif cfg.App.Private {\n\t\treturn UserLevelUserType\n\t}\n\treturn UserLevelOptionalType\n}\n\ntype (\n\thandlerFunc          func(app *App, w http.ResponseWriter, r *http.Request) error\n\tgopherFunc           func(app *App, w gopher.ResponseWriter, r *gopher.Request) error\n\tuserHandlerFunc      func(app *App, u *User, w http.ResponseWriter, r *http.Request) error\n\tuserApperHandlerFunc func(apper Apper, u *User, w http.ResponseWriter, r *http.Request) error\n\tdataHandlerFunc      func(app *App, w http.ResponseWriter, r *http.Request) ([]byte, string, error)\n\tauthFunc             func(app *App, r *http.Request) (*User, error)\n\tUserLevelFunc        func(cfg *config.Config) UserLevel\n)\n\ntype Handler struct {\n\terrors       *ErrorPages\n\tsessionStore sessions.Store\n\tapp          Apper\n}\n\n// ErrorPages hold template HTML error pages for displaying errors to the user.\n// In each, there should be a defined template named \"base\".\ntype ErrorPages struct {\n\tNotFound            *template.Template\n\tGone                *template.Template\n\tInternalServerError *template.Template\n\tUnavailableError    *template.Template\n\tBlank               *template.Template\n}\n\n// NewHandler returns a new Handler instance, using the given StaticPage data,\n// and saving alias to the application's CookieStore.\nfunc NewHandler(apper Apper) *Handler {\n\th := &Handler{\n\t\terrors: &ErrorPages{\n\t\t\tNotFound:            template.Must(template.New(\"\").Parse(\"{{define \\\"base\\\"}}<html><head><title>404</title></head><body><p>Not found.</p></body></html>{{end}}\")),\n\t\t\tGone:                template.Must(template.New(\"\").Parse(\"{{define \\\"base\\\"}}<html><head><title>410</title></head><body><p>Gone.</p></body></html>{{end}}\")),\n\t\t\tInternalServerError: template.Must(template.New(\"\").Parse(\"{{define \\\"base\\\"}}<html><head><title>500</title></head><body><p>Internal server error.</p></body></html>{{end}}\")),\n\t\t\tUnavailableError:    template.Must(template.New(\"\").Parse(\"{{define \\\"base\\\"}}<html><head><title>503</title></head><body><p>Service is temporarily unavailable.</p></body></html>{{end}}\")),\n\t\t\tBlank:               template.Must(template.New(\"\").Parse(\"{{define \\\"base\\\"}}<html><head><title>{{.Title}}</title></head><body><p>{{.Content}}</p></body></html>{{end}}\")),\n\t\t},\n\t\tsessionStore: apper.App().SessionStore(),\n\t\tapp:          apper,\n\t}\n\n\treturn h\n}\n\n// NewWFHandler returns a new Handler instance, using WriteFreely template files.\n// You MUST call writefreely.InitTemplates() before this.\nfunc NewWFHandler(apper Apper) *Handler {\n\th := NewHandler(apper)\n\th.SetErrorPages(&ErrorPages{\n\t\tNotFound:            pages[\"404-general.tmpl\"],\n\t\tGone:                pages[\"410.tmpl\"],\n\t\tInternalServerError: pages[\"500.tmpl\"],\n\t\tUnavailableError:    pages[\"503.tmpl\"],\n\t\tBlank:               pages[\"blank.tmpl\"],\n\t})\n\treturn h\n}\n\n// SetErrorPages sets the given set of ErrorPages as templates for any errors\n// that come up.\nfunc (h *Handler) SetErrorPages(e *ErrorPages) {\n\th.errors = e\n}\n\n// User handles requests made in the web application by the authenticated user.\n// This provides user-friendly HTML pages and actions that work in the browser.\nfunc (h *Handler) User(f userHandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleHTTPError(w, r, func() error {\n\t\t\tvar status int\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"%s: %s\", e, debug.Stack())\n\t\t\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\t\t\tstatus = http.StatusInternalServerError\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\tu := getUserSession(h.app.App(), r)\n\t\t\tif u == nil {\n\t\t\t\terr := ErrNotLoggedIn\n\t\t\t\tstatus = err.Status\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr := f(h.app.App(), u, w, r)\n\t\t\tif err == nil {\n\t\t\t\tstatus = http.StatusOK\n\t\t\t} else if impErr, ok := err.(impart.HTTPError); ok {\n\t\t\t\tstatus = impErr.Status\n\t\t\t\tif impErr == ErrUserNotFound {\n\t\t\t\t\tlog.Info(\"Logged-in user not found. Logging out.\")\n\t\t\t\t\tsendRedirect(w, http.StatusFound, \"/me/logout?to=\"+h.app.App().cfg.App.LandingPath())\n\t\t\t\t\t// Reset err so handleHTTPError does nothing\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstatus = http.StatusInternalServerError\n\t\t\t}\n\n\t\t\treturn err\n\t\t}())\n\t}\n}\n\n// Admin handles requests on /admin routes\nfunc (h *Handler) Admin(f userHandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleHTTPError(w, r, func() error {\n\t\t\tvar status int\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"%s: %s\", e, debug.Stack())\n\t\t\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\t\t\tstatus = http.StatusInternalServerError\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\tu := getUserSession(h.app.App(), r)\n\t\t\tif u == nil || !u.IsAdmin() {\n\t\t\t\terr := impart.HTTPError{http.StatusNotFound, \"\"}\n\t\t\t\tstatus = err.Status\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr := f(h.app.App(), u, w, r)\n\t\t\tif err == nil {\n\t\t\t\tstatus = http.StatusOK\n\t\t\t} else if err, ok := err.(impart.HTTPError); ok {\n\t\t\t\tstatus = err.Status\n\t\t\t} else {\n\t\t\t\tstatus = http.StatusInternalServerError\n\t\t\t}\n\n\t\t\treturn err\n\t\t}())\n\t}\n}\n\n// AdminApper handles requests on /admin routes that require an Apper.\nfunc (h *Handler) AdminApper(f userApperHandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleHTTPError(w, r, func() error {\n\t\t\tvar status int\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"%s: %s\", e, debug.Stack())\n\t\t\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\t\t\tstatus = http.StatusInternalServerError\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\tu := getUserSession(h.app.App(), r)\n\t\t\tif u == nil || !u.IsAdmin() {\n\t\t\t\terr := impart.HTTPError{http.StatusNotFound, \"\"}\n\t\t\t\tstatus = err.Status\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr := f(h.app, u, w, r)\n\t\t\tif err == nil {\n\t\t\t\tstatus = http.StatusOK\n\t\t\t} else if err, ok := err.(impart.HTTPError); ok {\n\t\t\t\tstatus = err.Status\n\t\t\t} else {\n\t\t\t\tstatus = http.StatusInternalServerError\n\t\t\t}\n\n\t\t\treturn err\n\t\t}())\n\t}\n}\n\nfunc apiAuth(app *App, r *http.Request) (*User, error) {\n\t// Authorize user from Authorization header\n\tt := r.Header.Get(\"Authorization\")\n\tif t == \"\" {\n\t\treturn nil, ErrNoAccessToken\n\t}\n\tu := &User{ID: app.db.GetUserID(t)}\n\tif u.ID == -1 {\n\t\treturn nil, ErrBadAccessToken\n\t}\n\n\treturn u, nil\n}\n\n// optionalAPIAuth is used for endpoints that accept authenticated requests via\n// Authorization header or cookie, unlike apiAuth. It returns a different err\n// in the case where no Authorization header is present.\nfunc optionalAPIAuth(app *App, r *http.Request) (*User, error) {\n\t// Authorize user from Authorization header\n\tt := r.Header.Get(\"Authorization\")\n\tif t == \"\" {\n\t\treturn nil, ErrNotLoggedIn\n\t}\n\tu := &User{ID: app.db.GetUserID(t)}\n\tif u.ID == -1 {\n\t\treturn nil, ErrBadAccessToken\n\t}\n\n\treturn u, nil\n}\n\nfunc webAuth(app *App, r *http.Request) (*User, error) {\n\tu := getUserSession(app, r)\n\tif u == nil {\n\t\treturn nil, ErrNotLoggedIn\n\t}\n\treturn u, nil\n}\n\n// UserAPI handles requests made in the API by the authenticated user.\n// This provides user-friendly HTML pages and actions that work in the browser.\nfunc (h *Handler) UserAPI(f userHandlerFunc) http.HandlerFunc {\n\treturn h.UserAll(false, f, apiAuth)\n}\n\n// UserWebAPI handles endpoints that accept a user authorized either via the web (cookies) or an Authorization header.\nfunc (h *Handler) UserWebAPI(f userHandlerFunc) http.HandlerFunc {\n\treturn h.UserAll(false, f, func(app *App, r *http.Request) (*User, error) {\n\t\t// Authorize user via cookies\n\t\tu := getUserSession(app, r)\n\t\tif u != nil {\n\t\t\treturn u, nil\n\t\t}\n\n\t\t// Fall back to access token, since user isn't logged in via web\n\t\tvar err error\n\t\tu, err = apiAuth(app, r)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn u, nil\n\t})\n}\n\nfunc (h *Handler) UserAll(web bool, f userHandlerFunc, a authFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\thandleFunc := func() error {\n\t\t\tvar status int\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"%s: %s\", e, debug.Stack())\n\t\t\t\t\timpart.WriteError(w, impart.HTTPError{http.StatusInternalServerError, \"Something didn't work quite right.\"})\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\tu, err := a(h.app.App(), r)\n\t\t\tif err != nil {\n\t\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t} else {\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = f(h.app.App(), u, w, r)\n\t\t\tif err == nil {\n\t\t\t\tstatus = 200\n\t\t\t} else if err, ok := err.(impart.HTTPError); ok {\n\t\t\t\tstatus = err.Status\n\t\t\t} else {\n\t\t\t\tstatus = 500\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\n\t\tif web {\n\t\t\th.handleHTTPError(w, r, handleFunc())\n\t\t} else {\n\t\t\th.handleError(w, r, handleFunc())\n\t\t}\n\t}\n}\n\nfunc (h *Handler) RedirectOnErr(f handlerFunc, loc string) handlerFunc {\n\treturn func(app *App, w http.ResponseWriter, r *http.Request) error {\n\t\terr := f(app, w, r)\n\t\tif err != nil {\n\t\t\tif ie, ok := err.(impart.HTTPError); ok {\n\t\t\t\t// Override default redirect with returned error's, if it's a\n\t\t\t\t// redirect error.\n\t\t\t\tif ie.Status == http.StatusFound {\n\t\t\t\t\treturn ie\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn impart.HTTPError{http.StatusFound, loc}\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc (h *Handler) Page(n string) http.HandlerFunc {\n\treturn h.Web(func(app *App, w http.ResponseWriter, r *http.Request) error {\n\t\tt, ok := pages[n]\n\t\tif !ok {\n\t\t\treturn impart.HTTPError{http.StatusNotFound, \"Page not found.\"}\n\t\t}\n\n\t\tsp := pageForReq(app, r)\n\n\t\terr := t.ExecuteTemplate(w, \"base\", sp)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to render page: %v\", err)\n\t\t}\n\t\treturn err\n\t}, UserLevelOptional)\n}\n\nfunc (h *Handler) WebErrors(f handlerFunc, ul UserLevelFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// TODO: factor out this logic shared with Web()\n\t\th.handleHTTPError(w, r, func() error {\n\t\t\tvar status int\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tu := getUserSession(h.app.App(), r)\n\t\t\t\t\tusername := \"None\"\n\t\t\t\t\tif u != nil {\n\t\t\t\t\t\tusername = u.Username\n\t\t\t\t\t}\n\t\t\t\t\tlog.Error(\"User: %s\\n\\n%s: %s\", username, e, debug.Stack())\n\t\t\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\tvar session *sessions.Session\n\t\t\tvar err error\n\t\t\tif ul(h.app.App().cfg) != UserLevelNoneType {\n\t\t\t\tsession, err = h.sessionStore.Get(r, cookieName)\n\t\t\t\tif err != nil && (ul(h.app.App().cfg) == UserLevelNoneRequiredType || ul(h.app.App().cfg) == UserLevelUserType) {\n\t\t\t\t\t// Cookie is required, but we can ignore this error\n\t\t\t\t\tlog.Error(\"Handler: Unable to get session (for user permission %d); ignoring: %v\", ul(h.app.App().cfg), err)\n\t\t\t\t}\n\n\t\t\t\t_, gotUser := session.Values[cookieUserVal].(*User)\n\t\t\t\tif ul(h.app.App().cfg) == UserLevelNoneRequiredType && gotUser {\n\t\t\t\t\tto := correctPageFromLoginAttempt(r)\n\t\t\t\t\tlog.Info(\"Handler: Required NO user, but got one. Redirecting to %s\", to)\n\t\t\t\t\terr := impart.HTTPError{http.StatusFound, to}\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t\treturn err\n\t\t\t\t} else if ul(h.app.App().cfg) == UserLevelUserType && !gotUser {\n\t\t\t\t\tlog.Info(\"Handler: Required a user, but DIDN'T get one. Sending not logged in.\")\n\t\t\t\t\terr := ErrNotLoggedIn\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: pass User object to function\n\t\t\terr = f(h.app.App(), w, r)\n\t\t\tif err == nil {\n\t\t\t\tstatus = 200\n\t\t\t} else if httpErr, ok := err.(impart.HTTPError); ok {\n\t\t\t\tstatus = httpErr.Status\n\t\t\t\tif status < 300 || status > 399 {\n\t\t\t\t\taddSessionFlash(h.app.App(), w, r, httpErr.Message, session)\n\t\t\t\t\treturn impart.HTTPError{http.StatusFound, r.Referer()}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\te := fmt.Sprintf(\"[Web handler] 500: %v\", err)\n\t\t\t\tif !strings.HasSuffix(e, \"write: broken pipe\") {\n\t\t\t\t\tlog.Error(e)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Error(e)\n\t\t\t\t}\n\t\t\t\tlog.Info(\"Web handler internal error render\")\n\t\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\t\tstatus = 500\n\t\t\t}\n\n\t\t\treturn err\n\t\t}())\n\t}\n}\n\nfunc (h *Handler) CollectionPostOrStatic(w http.ResponseWriter, r *http.Request) {\n\tif strings.Contains(r.URL.Path, \".\") && !isRaw(r) {\n\t\tstart := time.Now()\n\t\tstatus := 200\n\t\tdefer func() {\n\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t}()\n\n\t\t// Serve static file\n\t\th.app.App().shttp.ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\th.Web(viewCollectionPost, UserLevelReader)(w, r)\n}\n\n// Web handles requests made in the web application. This provides user-\n// friendly HTML pages and actions that work in the browser.\nfunc (h *Handler) Web(f handlerFunc, ul UserLevelFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleHTTPError(w, r, func() error {\n\t\t\tvar status int\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tu := getUserSession(h.app.App(), r)\n\t\t\t\t\tusername := \"None\"\n\t\t\t\t\tif u != nil {\n\t\t\t\t\t\tusername = u.Username\n\t\t\t\t\t}\n\t\t\t\t\tlog.Error(\"User: %s\\n\\n%s: %s\", username, e, debug.Stack())\n\t\t\t\t\tlog.Info(\"Web deferred internal error render\")\n\t\t\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\tif ul(h.app.App().cfg) != UserLevelNoneType {\n\t\t\t\tsession, err := h.sessionStore.Get(r, cookieName)\n\t\t\t\tif err != nil && (ul(h.app.App().cfg) == UserLevelNoneRequiredType || ul(h.app.App().cfg) == UserLevelUserType) {\n\t\t\t\t\t// Cookie is required, but we can ignore this error\n\t\t\t\t\tlog.Error(\"Handler: Unable to get session (for user permission %d); ignoring: %v\", ul(h.app.App().cfg), err)\n\t\t\t\t}\n\n\t\t\t\t_, gotUser := session.Values[cookieUserVal].(*User)\n\t\t\t\tif ul(h.app.App().cfg) == UserLevelNoneRequiredType && gotUser {\n\t\t\t\t\tto := correctPageFromLoginAttempt(r)\n\t\t\t\t\tlog.Info(\"Handler: Required NO user, but got one. Redirecting to %s\", to)\n\t\t\t\t\terr := impart.HTTPError{http.StatusFound, to}\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t\treturn err\n\t\t\t\t} else if ul(h.app.App().cfg) == UserLevelUserType && !gotUser {\n\t\t\t\t\tlog.Info(\"Handler: Required a user, but DIDN'T get one. Sending not logged in.\")\n\t\t\t\t\terr := ErrNotLoggedIn\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: pass User object to function\n\t\t\terr := f(h.app.App(), w, r)\n\t\t\tif err == nil {\n\t\t\t\tstatus = 200\n\t\t\t} else if httpErr, ok := err.(impart.HTTPError); ok {\n\t\t\t\tstatus = httpErr.Status\n\t\t\t} else {\n\t\t\t\te := fmt.Sprintf(\"[Web handler] 500: %v\", err)\n\t\t\t\tlog.Error(e)\n\t\t\t\tlog.Info(\"Web internal error render\")\n\t\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\t\tstatus = 500\n\t\t\t}\n\n\t\t\treturn err\n\t\t}())\n\t}\n}\n\nfunc (h *Handler) All(f handlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleError(w, r, func() error {\n\t\t\t// TODO: return correct \"success\" status\n\t\t\tstatus := 200\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"%s:\\n%s\", e, debug.Stack())\n\t\t\t\t\timpart.WriteError(w, impart.HTTPError{http.StatusInternalServerError, \"Something didn't work quite right.\"})\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\t// TODO: do any needed authentication\n\n\t\t\terr := f(h.app.App(), w, r)\n\t\t\tif err != nil {\n\t\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t} else {\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn err\n\t\t}())\n\t}\n}\n\nfunc (h *Handler) PlainTextAPI(f handlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleTextError(w, r, func() error {\n\t\t\t// TODO: return correct \"success\" status\n\t\t\tstatus := 200\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"%s:\\n%s\", e, debug.Stack())\n\t\t\t\t\tstatus = http.StatusInternalServerError\n\t\t\t\t\tw.WriteHeader(status)\n\t\t\t\t\tfmt.Fprintf(w, \"Something didn't work quite right. The robots have alerted the humans.\")\n\t\t\t\t}\n\n\t\t\t\tlog.Info(fmt.Sprintf(\"\\\"%s %s\\\" %d %s \\\"%s\\\" \\\"%s\\\"\", r.Method, r.RequestURI, status, time.Since(start), r.UserAgent(), r.Host))\n\t\t\t}()\n\n\t\t\terr := f(h.app.App(), w, r)\n\t\t\tif err != nil {\n\t\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t} else {\n\t\t\t\t\tstatus = http.StatusInternalServerError\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn err\n\t\t}())\n\t}\n}\n\nfunc (h *Handler) OAuth(f handlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleOAuthError(w, r, func() error {\n\t\t\t// TODO: return correct \"success\" status\n\t\t\tstatus := 200\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"%s:\\n%s\", e, debug.Stack())\n\t\t\t\t\timpart.WriteError(w, impart.HTTPError{http.StatusInternalServerError, \"Something didn't work quite right.\"})\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\terr := f(h.app.App(), w, r)\n\t\t\tif err != nil {\n\t\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t} else {\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn err\n\t\t}())\n\t}\n}\n\nfunc (h *Handler) AllReader(f handlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleError(w, r, func() error {\n\t\t\tstatus := 200\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"%s:\\n%s\", e, debug.Stack())\n\t\t\t\t\timpart.WriteError(w, impart.HTTPError{http.StatusInternalServerError, \"Something didn't work quite right.\"})\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\t// Allow any origin, as public endpoints are handled in here\n\t\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\n\t\t\tif h.app.App().cfg.App.Private {\n\t\t\t\t// This instance is private, so ensure it's being accessed by a valid user\n\t\t\t\t// Check if authenticated with an access token\n\t\t\t\t_, apiErr := optionalAPIAuth(h.app.App(), r)\n\t\t\t\tif apiErr != nil {\n\t\t\t\t\tif err, ok := apiErr.(impart.HTTPError); ok {\n\t\t\t\t\t\tstatus = err.Status\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatus = 500\n\t\t\t\t\t}\n\n\t\t\t\t\tif apiErr == ErrNotLoggedIn {\n\t\t\t\t\t\t// Fall back to web auth since there was no access token given\n\t\t\t\t\t\t_, err := webAuth(h.app.App(), r)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tif err, ok := apiErr.(impart.HTTPError); ok {\n\t\t\t\t\t\t\t\tstatus = err.Status\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstatus = 500\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn apiErr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr := f(h.app.App(), w, r)\n\t\t\tif err != nil {\n\t\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t} else {\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn err\n\t\t}())\n\t}\n}\n\nfunc (h *Handler) Download(f dataHandlerFunc, ul UserLevelFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleHTTPError(w, r, func() error {\n\t\t\tvar status int\n\t\t\tstart := time.Now()\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"%s: %s\", e, debug.Stack())\n\t\t\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\tdata, filename, err := f(h.app.App(), w, r)\n\t\t\tif err != nil {\n\t\t\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t} else {\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\text := \".json\"\n\t\t\tct := \"application/json\"\n\t\t\tif strings.HasSuffix(r.URL.Path, \".csv\") {\n\t\t\t\text = \".csv\"\n\t\t\t\tct = \"text/csv\"\n\t\t\t} else if strings.HasSuffix(r.URL.Path, \".zip\") {\n\t\t\t\text = \".zip\"\n\t\t\t\tct = \"application/zip\"\n\t\t\t}\n\t\t\tw.Header().Set(\"Content-Disposition\", fmt.Sprintf(\"attachment; filename=%s%s\", filename, ext))\n\t\t\tw.Header().Set(\"Content-Type\", ct)\n\t\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(data)))\n\t\t\tfmt.Fprint(w, string(data))\n\n\t\t\tstatus = 200\n\t\t\treturn nil\n\t\t}())\n\t}\n}\n\nfunc (h *Handler) Redirect(url string, ul UserLevelFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleHTTPError(w, r, func() error {\n\t\t\tstart := time.Now()\n\n\t\t\tvar status int\n\t\t\tif ul(h.app.App().cfg) != UserLevelNoneType {\n\t\t\t\tsession, err := h.sessionStore.Get(r, cookieName)\n\t\t\t\tif err != nil && (ul(h.app.App().cfg) == UserLevelNoneRequiredType || ul(h.app.App().cfg) == UserLevelUserType) {\n\t\t\t\t\t// Cookie is required, but we can ignore this error\n\t\t\t\t\tlog.Error(\"Handler: Unable to get session (for user permission %d); ignoring: %v\", ul(h.app.App().cfg), err)\n\t\t\t\t}\n\n\t\t\t\t_, gotUser := session.Values[cookieUserVal].(*User)\n\t\t\t\tif ul(h.app.App().cfg) == UserLevelNoneRequiredType && gotUser {\n\t\t\t\t\tto := correctPageFromLoginAttempt(r)\n\t\t\t\t\tlog.Info(\"Handler: Required NO user, but got one. Redirecting to %s\", to)\n\t\t\t\t\terr := impart.HTTPError{http.StatusFound, to}\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t\treturn err\n\t\t\t\t} else if ul(h.app.App().cfg) == UserLevelUserType && !gotUser {\n\t\t\t\t\tlog.Info(\"Handler: Required a user, but DIDN'T get one. Sending not logged in.\")\n\t\t\t\t\terr := ErrNotLoggedIn\n\t\t\t\t\tstatus = err.Status\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatus = sendRedirect(w, http.StatusFound, url)\n\n\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\n\t\t\treturn nil\n\t\t}())\n\t}\n}\n\nfunc (h *Handler) handleHTTPError(w http.ResponseWriter, r *http.Request, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tif err, ok := err.(impart.HTTPError); ok {\n\t\tif err.Status >= 300 && err.Status < 400 {\n\t\t\tsendRedirect(w, err.Status, err.Message)\n\t\t\treturn\n\t\t} else if err.Status == http.StatusUnauthorized {\n\t\t\tq := \"\"\n\t\t\tif r.URL.RawQuery != \"\" {\n\t\t\t\tq = url.QueryEscape(\"?\" + r.URL.RawQuery)\n\t\t\t}\n\t\t\tsendRedirect(w, http.StatusFound, \"/login?to=\"+r.URL.Path+q)\n\t\t\treturn\n\t\t} else if err.Status == http.StatusGone {\n\t\t\tw.WriteHeader(err.Status)\n\t\t\tp := &struct {\n\t\t\t\tpage.StaticPage\n\t\t\t\tContent *template.HTML\n\t\t\t}{\n\t\t\t\tStaticPage: pageForReq(h.app.App(), r),\n\t\t\t}\n\t\t\tif err.Message != \"\" {\n\t\t\t\tco := template.HTML(err.Message)\n\t\t\t\tp.Content = &co\n\t\t\t}\n\t\t\th.errors.Gone.ExecuteTemplate(w, \"base\", p)\n\t\t\treturn\n\t\t} else if err.Status == http.StatusNotFound {\n\t\t\tw.WriteHeader(err.Status)\n\t\t\tif IsActivityPubRequest(r) {\n\t\t\t\t// This is a fediverse request; simply return the header\n\t\t\t\treturn\n\t\t\t}\n\t\t\th.errors.NotFound.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\treturn\n\t\t} else if err.Status == http.StatusInternalServerError {\n\t\t\tw.WriteHeader(err.Status)\n\t\t\tlog.Info(\"handleHTTPErorr internal error render\")\n\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\treturn\n\t\t} else if err.Status == http.StatusServiceUnavailable {\n\t\t\tw.WriteHeader(err.Status)\n\t\t\th.errors.UnavailableError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\treturn\n\t\t} else if err.Status == http.StatusAccepted {\n\t\t\timpart.WriteSuccess(w, \"\", err.Status)\n\t\t\treturn\n\t\t} else {\n\t\t\tp := &struct {\n\t\t\t\tpage.StaticPage\n\t\t\t\tTitle   string\n\t\t\t\tContent template.HTML\n\t\t\t}{\n\t\t\t\tpageForReq(h.app.App(), r),\n\t\t\t\tfmt.Sprintf(\"Uh oh (%d)\", err.Status),\n\t\t\t\ttemplate.HTML(fmt.Sprintf(\"<p style=\\\"text-align: center\\\" class=\\\"introduction\\\">%s</p>\", err.Message)),\n\t\t\t}\n\t\t\th.errors.Blank.ExecuteTemplate(w, \"base\", p)\n\t\t\treturn\n\t\t}\n\t\timpart.WriteError(w, err)\n\t\treturn\n\t}\n\n\timpart.WriteError(w, impart.HTTPError{http.StatusInternalServerError, \"This is an unhelpful error message for a miscellaneous internal error.\"})\n}\n\nfunc (h *Handler) handleError(w http.ResponseWriter, r *http.Request, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tif err, ok := err.(impart.HTTPError); ok {\n\t\tif err.Status >= 300 && err.Status < 400 {\n\t\t\tsendRedirect(w, err.Status, err.Message)\n\t\t\treturn\n\t\t}\n\n\t\t//\t\tif strings.Contains(r.Header.Get(\"Accept\"), \"text/html\") {\n\t\timpart.WriteError(w, err)\n\t\t//\t\t}\n\t\treturn\n\t}\n\n\tif IsJSON(r) {\n\t\timpart.WriteError(w, impart.HTTPError{http.StatusInternalServerError, \"This is an unhelpful error message for a miscellaneous internal error.\"})\n\t\treturn\n\t}\n\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n}\n\nfunc (h *Handler) handleTextError(w http.ResponseWriter, r *http.Request, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tif err, ok := err.(impart.HTTPError); ok {\n\t\tif err.Status >= 300 && err.Status < 400 {\n\t\t\tsendRedirect(w, err.Status, err.Message)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(err.Status)\n\t\tfmt.Fprintf(w, http.StatusText(err.Status))\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusInternalServerError)\n\tfmt.Fprintf(w, \"This is an unhelpful error message for a miscellaneous internal error.\")\n}\n\nfunc (h *Handler) handleOAuthError(w http.ResponseWriter, r *http.Request, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tif err, ok := err.(impart.HTTPError); ok {\n\t\tif err.Status >= 300 && err.Status < 400 {\n\t\t\tsendRedirect(w, err.Status, err.Message)\n\t\t\treturn\n\t\t}\n\n\t\timpart.WriteOAuthError(w, err)\n\t\treturn\n\t}\n\n\timpart.WriteOAuthError(w, impart.HTTPError{http.StatusInternalServerError, \"This is an unhelpful error message for a miscellaneous internal error.\"})\n\treturn\n}\n\nfunc correctPageFromLoginAttempt(r *http.Request) string {\n\tto := r.FormValue(\"to\")\n\tif to == \"\" {\n\t\tto = \"/\"\n\t} else if !strings.HasPrefix(to, \"/\") {\n\t\tto = \"/\" + to\n\t}\n\treturn to\n}\n\nfunc (h *Handler) LogHandlerFunc(f http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\th.handleHTTPError(w, r, func() error {\n\t\t\tstatus := 200\n\t\t\tstart := time.Now()\n\n\t\t\tdefer func() {\n\t\t\t\tif e := recover(); e != nil {\n\t\t\t\t\tlog.Error(\"Handler.LogHandlerFunc\\n\\n%s: %s\", e, debug.Stack())\n\t\t\t\t\th.errors.InternalServerError.ExecuteTemplate(w, \"base\", pageForReq(h.app.App(), r))\n\t\t\t\t\tstatus = 500\n\t\t\t\t}\n\n\t\t\t\t// TODO: log actual status code returned\n\t\t\t\tlog.Info(h.app.ReqLog(r, status, time.Since(start)))\n\t\t\t}()\n\n\t\t\tif h.app.App().cfg.App.Private {\n\t\t\t\t// This instance is private, so ensure it's being accessed by a valid user\n\t\t\t\t// Check if authenticated with an access token\n\t\t\t\t_, apiErr := optionalAPIAuth(h.app.App(), r)\n\t\t\t\tif apiErr != nil {\n\t\t\t\t\tif err, ok := apiErr.(impart.HTTPError); ok {\n\t\t\t\t\t\tstatus = err.Status\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatus = 500\n\t\t\t\t\t}\n\n\t\t\t\t\tif apiErr == ErrNotLoggedIn {\n\t\t\t\t\t\t// Fall back to web auth since there was no access token given\n\t\t\t\t\t\t_, err := webAuth(h.app.App(), r)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tif err, ok := apiErr.(impart.HTTPError); ok {\n\t\t\t\t\t\t\t\tstatus = err.Status\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstatus = 500\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn apiErr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tf(w, r)\n\n\t\t\treturn nil\n\t\t}())\n\t}\n}\n\nfunc (h *Handler) Gopher(f gopherFunc) gopher.HandlerFunc {\n\treturn func(w gopher.ResponseWriter, r *gopher.Request) {\n\t\tdefer func() {\n\t\t\tif e := recover(); e != nil {\n\t\t\t\tlog.Error(\"%s: %s\", e, debug.Stack())\n\t\t\t\tw.WriteError(\"An internal error occurred\")\n\t\t\t}\n\t\t\tlog.Info(\"gopher: %s\", r.Selector)\n\t\t}()\n\n\t\terr := f(h.app.App(), w, r)\n\t\tif err != nil {\n\t\t\tlog.Error(\"failed: %s\", err)\n\t\t\tw.WriteError(\"the page failed for some reason (see logs)\")\n\t\t}\n\t}\n}\n\nfunc sendRedirect(w http.ResponseWriter, code int, location string) int {\n\tw.Header().Set(\"Location\", location)\n\tw.WriteHeader(code)\n\treturn code\n}\n\nfunc cacheControl(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Cache-Control\", \"public, max-age=604800, immutable\")\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n"
        },
        {
          "name": "hostmeta.go",
          "type": "blob",
          "size": 0.7890625,
          "content": "/*\n * Copyright © 2018-2019 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handleViewHostMeta(app *App, w http.ResponseWriter, r *http.Request) error {\n\tw.Header().Set(\"Server\", serverSoftware)\n\tw.Header().Set(\"Content-Type\", \"application/xrd+xml; charset=utf-8\")\n\n\tmeta := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<XRD xmlns=\"http://docs.oasis-open.org/ns/xri/xrd-1.0\">\n  <Link rel=\"lrdd\" type=\"application/xrd+xml\" template=\"https://` + r.Host + `/.well-known/webfinger?resource={uri}\"/>\n</XRD>`\n\tfmt.Fprintf(w, meta)\n\n\treturn nil\n}\n"
        },
        {
          "name": "instance.go",
          "type": "blob",
          "size": 0.361328125,
          "content": "/*\n * Copyright © 2018 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\ntype InstanceStats struct {\n\tNumPosts int64\n\tNumBlogs int64\n}\n"
        },
        {
          "name": "invites.go",
          "type": "blob",
          "size": 4.72265625,
          "content": "/*\n * Copyright © 2019-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/id\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/page\"\n)\n\ntype Invite struct {\n\tID       string\n\tMaxUses  sql.NullInt64\n\tCreated  time.Time\n\tExpires  *time.Time\n\tInactive bool\n\n\tuses int64\n}\n\nfunc (i Invite) Uses() int64 {\n\treturn i.uses\n}\n\nfunc (i Invite) Expired() bool {\n\treturn i.Expires != nil && i.Expires.Before(time.Now())\n}\n\nfunc (i Invite) Active(db *datastore) bool {\n\tif i.Expired() {\n\t\treturn false\n\t}\n\tif i.MaxUses.Valid && i.MaxUses.Int64 > 0 {\n\t\tif c := db.GetUsersInvitedCount(i.ID); c >= i.MaxUses.Int64 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (i Invite) ExpiresFriendly() string {\n\treturn i.Expires.Format(\"January 2, 2006, 3:04 PM\")\n}\n\nfunc handleViewUserInvites(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\t// Don't show page if instance doesn't allow it\n\tif !(app.cfg.App.UserInvites != \"\" && (u.IsAdmin() || app.cfg.App.UserInvites != \"admin\")) {\n\t\treturn impart.HTTPError{http.StatusNotFound, \"\"}\n\t}\n\n\tf, _ := getSessionFlashes(app, w, r, nil)\n\n\tp := struct {\n\t\t*UserPage\n\t\tInvites  *[]Invite\n\t\tSilenced bool\n\t}{\n\t\tUserPage: NewUserPage(app, r, u, \"Invite People\", f),\n\t}\n\n\tvar err error\n\n\tp.Silenced, err = app.db.IsUserSilenced(u.ID)\n\tif err != nil {\n\t\tif err == ErrUserNotFound {\n\t\t\treturn err\n\t\t}\n\t\tlog.Error(\"view invites: %v\", err)\n\t}\n\n\tp.Invites, err = app.db.GetUserInvites(u.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor i := range *p.Invites {\n\t\t(*p.Invites)[i].uses = app.db.GetUsersInvitedCount((*p.Invites)[i].ID)\n\t}\n\n\tshowUserPage(w, \"invite\", p)\n\treturn nil\n}\n\nfunc handleCreateUserInvite(app *App, u *User, w http.ResponseWriter, r *http.Request) error {\n\tmuVal := r.FormValue(\"uses\")\n\texpVal := r.FormValue(\"expires\")\n\n\tif u.IsSilenced() {\n\t\treturn ErrUserSilenced\n\t}\n\n\tvar err error\n\tvar maxUses int\n\tif muVal != \"0\" {\n\t\tmaxUses, err = strconv.Atoi(muVal)\n\t\tif err != nil {\n\t\t\treturn impart.HTTPError{http.StatusBadRequest, \"Invalid value for 'max_uses'\"}\n\t\t}\n\t}\n\n\tvar expDate *time.Time\n\tvar expires int\n\tif expVal != \"0\" {\n\t\texpires, err = strconv.Atoi(expVal)\n\t\tif err != nil {\n\t\t\treturn impart.HTTPError{http.StatusBadRequest, \"Invalid value for 'expires'\"}\n\t\t}\n\t\ted := time.Now().Add(time.Duration(expires) * time.Minute)\n\t\texpDate = &ed\n\t}\n\n\tinviteID := id.GenerateRandomString(\"0123456789BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\", 6)\n\terr = app.db.CreateUserInvite(inviteID, u.ID, maxUses, expDate)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn impart.HTTPError{http.StatusFound, \"/me/invites\"}\n}\n\nfunc handleViewInvite(app *App, w http.ResponseWriter, r *http.Request) error {\n\tinviteCode := mux.Vars(r)[\"code\"]\n\n\ti, err := app.db.GetUserInvite(inviteCode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\texpired := i.Expired()\n\tif !expired && i.MaxUses.Valid && i.MaxUses.Int64 > 0 {\n\t\t// Invite has a max-use number, so check if we're past that limit\n\t\ti.uses = app.db.GetUsersInvitedCount(inviteCode)\n\t\texpired = i.uses >= i.MaxUses.Int64\n\t}\n\n\tif u := getUserSession(app, r); u != nil {\n\t\t// check if invite belongs to another user\n\t\t// error can be ignored as not important in this case\n\t\tif ownInvite, _ := app.db.IsUsersInvite(inviteCode, u.ID); !ownInvite {\n\t\t\taddSessionFlash(app, w, r, \"You're already registered and logged in.\", nil)\n\t\t\t// show homepage\n\t\t\treturn impart.HTTPError{http.StatusFound, \"/me/settings\"}\n\t\t}\n\n\t\t// show invite instructions\n\t\tp := struct {\n\t\t\t*UserPage\n\t\t\tInvite  *Invite\n\t\t\tExpired bool\n\t\t}{\n\t\t\tUserPage: NewUserPage(app, r, u, \"Invite to \"+app.cfg.App.SiteName, nil),\n\t\t\tInvite:   i,\n\t\t\tExpired:  expired,\n\t\t}\n\t\tshowUserPage(w, \"invite-help\", p)\n\t\treturn nil\n\t}\n\n\tp := struct {\n\t\tpage.StaticPage\n\t\t*OAuthButtons\n\t\tError   string\n\t\tFlashes []template.HTML\n\t\tInvite  string\n\t}{\n\t\tStaticPage:   pageForReq(app, r),\n\t\tOAuthButtons: NewOAuthButtons(app.cfg),\n\t\tInvite:       inviteCode,\n\t}\n\n\tif expired {\n\t\tp.Error = \"This invite link has expired.\"\n\t}\n\n\t// Tell search engines not to index invite links\n\tw.Header().Set(\"X-Robots-Tag\", \"noindex\")\n\n\t// Get error messages\n\tsession, err := app.sessionStore.Get(r, cookieName)\n\tif err != nil {\n\t\t// Ignore this\n\t\tlog.Error(\"Unable to get session in handleViewInvite; ignoring: %v\", err)\n\t}\n\tflashes, _ := getSessionFlashes(app, w, r, session)\n\tfor _, flash := range flashes {\n\t\tp.Flashes = append(p.Flashes, template.HTML(flash))\n\t}\n\n\t// Show landing page\n\treturn renderPage(w, \"signup.tmpl\", p)\n}\n"
        },
        {
          "name": "jobs.go",
          "type": "blob",
          "size": 1.62890625,
          "content": "package writefreely\n\nimport (\n\t\"github.com/writeas/web-core/log\"\n\t\"time\"\n)\n\ntype PostJob struct {\n\tID     int64\n\tPostID string\n\tAction string\n\tDelay  int64\n}\n\nfunc addJob(app *App, p *PublicPost, action string, delay int64) error {\n\tj := &PostJob{\n\t\tPostID: p.ID,\n\t\tAction: action,\n\t\tDelay:  delay,\n\t}\n\treturn app.db.InsertJob(j)\n}\n\nfunc startPublishJobsQueue(app *App) {\n\tt := time.NewTicker(62 * time.Second)\n\tfor {\n\t\tlog.Info(\"[jobs] Done.\")\n\t\t<-t.C\n\t\tlog.Info(\"[jobs] Fetching email publish jobs...\")\n\t\tjobs, err := app.db.GetJobsToRun(\"email\")\n\t\tif err != nil {\n\t\t\tlog.Error(\"[jobs] %s - Skipping.\", err)\n\t\t\tcontinue\n\t\t}\n\t\tlog.Info(\"[jobs] Running %d email publish jobs...\", len(jobs))\n\t\terr = runJobs(app, jobs, true)\n\t\tif err != nil {\n\t\t\tlog.Error(\"[jobs] Failed: %s\", err)\n\t\t}\n\t}\n}\n\nfunc runJobs(app *App, jobs []*PostJob, reqColl bool) error {\n\tfor _, j := range jobs {\n\t\tp, err := app.db.GetPost(j.PostID, 0)\n\t\tif err != nil {\n\t\t\tlog.Info(\"[job #%d] Unable to get post: %s\", j.ID, err)\n\t\t\tcontinue\n\t\t}\n\t\tif !p.CollectionID.Valid && reqColl {\n\t\t\tlog.Info(\"[job #%d] Post %s not part of a collection\", j.ID, p.ID)\n\t\t\tapp.db.DeleteJob(j.ID)\n\t\t\tcontinue\n\t\t}\n\t\tcoll, err := app.db.GetCollectionByID(p.CollectionID.Int64)\n\t\tif err != nil {\n\t\t\tlog.Info(\"[job #%d] Unable to get collection: %s\", j.ID, err)\n\t\t\tcontinue\n\t\t}\n\t\tcoll.hostName = app.cfg.App.Host\n\t\tcoll.ForPublic()\n\t\tp.Collection = &CollectionObj{Collection: *coll}\n\t\terr = emailPost(app, p, p.Collection.ID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"[job #%d] Failed to email post %s\", j.ID, p.ID)\n\t\t\tcontinue\n\t\t}\n\t\tlog.Info(\"[job #%d] Success for post %s.\", j.ID, p.ID)\n\t\tapp.db.DeleteJob(j.ID)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "key",
          "type": "tree",
          "content": null
        },
        {
          "name": "keys.go",
          "type": "blob",
          "size": 2.0751953125,
          "content": "/*\n * Copyright © 2018-2019, 2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/key\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nconst (\n\tkeysDir = \"keys\"\n)\n\nvar (\n\temailKeyPath      = filepath.Join(keysDir, \"email.aes256\")\n\tcookieAuthKeyPath = filepath.Join(keysDir, \"cookies_auth.aes256\")\n\tcookieKeyPath     = filepath.Join(keysDir, \"cookies_enc.aes256\")\n\tcsrfKeyPath       = filepath.Join(keysDir, \"csrf.aes256\")\n)\n\n// InitKeys loads encryption keys into memory via the given Apper interface\nfunc InitKeys(apper Apper) error {\n\tlog.Info(\"Loading encryption keys...\")\n\terr := apper.LoadKeys()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc initKeyPaths(app *App) {\n\temailKeyPath = filepath.Join(app.cfg.Server.KeysParentDir, emailKeyPath)\n\tcookieAuthKeyPath = filepath.Join(app.cfg.Server.KeysParentDir, cookieAuthKeyPath)\n\tcookieKeyPath = filepath.Join(app.cfg.Server.KeysParentDir, cookieKeyPath)\n\tcsrfKeyPath = filepath.Join(app.cfg.Server.KeysParentDir, csrfKeyPath)\n}\n\n// generateKey generates a key at the given path used for the encryption of\n// certain user data. Because user data becomes unrecoverable without these\n// keys, this won't overwrite any existing key, and instead outputs a message.\nfunc generateKey(path string) error {\n\t// Check if key file exists\n\tif _, err := os.Stat(path); err == nil {\n\t\tlog.Info(\"%s already exists. rm the file if you understand the consequences.\", path)\n\t\treturn nil\n\t} else if !os.IsNotExist(err) {\n\t\tlog.Error(\"%s\", err)\n\t\treturn err\n\t}\n\n\tlog.Info(\"Generating %s.\", path)\n\tb, err := key.GenerateBytes(key.EncKeysBytes)\n\tif err != nil {\n\t\tlog.Error(\"FAILED. %s. Run writefreely --gen-keys again.\", err)\n\t\treturn err\n\t}\n\terr = os.WriteFile(path, b, 0600)\n\tif err != nil {\n\t\tlog.Error(\"FAILED writing file: %s\", err)\n\t\treturn err\n\t}\n\tlog.Info(\"Success.\")\n\treturn nil\n}\n"
        },
        {
          "name": "keys",
          "type": "tree",
          "content": null
        },
        {
          "name": "less",
          "type": "tree",
          "content": null
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 3.5810546875,
          "content": "package writefreely\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"encoding/gob\"\n\t\"errors\"\n\t\"fmt\"\n\tuuid \"github.com/nu7hatch/gouuid\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"math/rand\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar testDB *sql.DB\n\ntype ScopedTestBody func(*sql.DB)\n\n// TestMain provides testing infrastructure within this package.\nfunc TestMain(m *testing.M) {\n\trand.Seed(time.Now().UTC().UnixNano())\n\tgob.Register(&User{})\n\n\tif runMySQLTests() {\n\t\tvar err error\n\n\t\ttestDB, err = initMySQL(os.Getenv(\"WF_USER\"), os.Getenv(\"WF_PASSWORD\"), os.Getenv(\"WF_DB\"), os.Getenv(\"WF_HOST\"))\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tcode := m.Run()\n\tif runMySQLTests() {\n\t\tif closeErr := testDB.Close(); closeErr != nil {\n\t\t\tfmt.Println(closeErr)\n\t\t}\n\t}\n\tos.Exit(code)\n}\n\nfunc runMySQLTests() bool {\n\treturn len(os.Getenv(\"TEST_MYSQL\")) > 0\n}\n\nfunc initMySQL(dbUser, dbPassword, dbName, dbHost string) (*sql.DB, error) {\n\tif dbUser == \"\" || dbPassword == \"\" {\n\t\treturn nil, errors.New(\"database user or password not set\")\n\t}\n\tif dbHost == \"\" {\n\t\tdbHost = \"localhost\"\n\t}\n\tif dbName == \"\" {\n\t\tdbName = \"writefreely\"\n\t}\n\n\tdsn := fmt.Sprintf(\"%s:%s@tcp(%s:3306)/%s?charset=utf8mb4&parseTime=true\", dbUser, dbPassword, dbHost, dbName)\n\tdb, err := sql.Open(\"mysql\", dsn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := ensureMySQL(db); err != nil {\n\t\treturn nil, err\n\t}\n\treturn db, nil\n}\n\nfunc ensureMySQL(db *sql.DB) error {\n\tif err := db.Ping(); err != nil {\n\t\treturn err\n\t}\n\tdb.SetMaxOpenConns(250)\n\treturn nil\n}\n\n// withTestDB provides a scoped database connection.\nfunc withTestDB(t *testing.T, testBody ScopedTestBody) {\n\tdb, cleanup, err := newTestDatabase(testDB,\n\t\tos.Getenv(\"WF_USER\"),\n\t\tos.Getenv(\"WF_PASSWORD\"),\n\t\tos.Getenv(\"WF_DB\"),\n\t\tos.Getenv(\"WF_HOST\"),\n\t)\n\tassert.NoError(t, err)\n\tdefer func() {\n\t\tassert.NoError(t, cleanup())\n\t}()\n\n\ttestBody(db)\n}\n\n// newTestDatabase creates a new temporary test database. When a test\n// database connection is returned, it will have created a new database and\n// initialized it with tables from a reference database.\nfunc newTestDatabase(base *sql.DB, dbUser, dbPassword, dbName, dbHost string) (*sql.DB, func() error, error) {\n\tvar err error\n\tvar baseName = dbName\n\n\tif baseName == \"\" {\n\t\trow := base.QueryRow(\"SELECT DATABASE()\")\n\t\terr := row.Scan(&baseName)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\ttUUID, _ := uuid.NewV4()\n\tsuffix := strings.Replace(tUUID.String(), \"-\", \"_\", -1)\n\tnewDBName := baseName + suffix\n\t_, err = base.Exec(\"CREATE DATABASE \" + newDBName)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tnewDB, err := initMySQL(dbUser, dbPassword, newDBName, dbHost)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trows, err := base.Query(\"SHOW TABLES IN \" + baseName)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfor rows.Next() {\n\t\tvar tableName string\n\t\tif err := rows.Scan(&tableName); err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tquery := fmt.Sprintf(\"CREATE TABLE %s LIKE %s.%s\", tableName, baseName, tableName)\n\t\tif _, err := newDB.Exec(query); err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\tcleanup := func() error {\n\t\tif closeErr := newDB.Close(); closeErr != nil {\n\t\t\tfmt.Println(closeErr)\n\t\t}\n\n\t\t_, err = base.Exec(\"DROP DATABASE \" + newDBName)\n\t\treturn err\n\t}\n\treturn newDB, cleanup, nil\n}\n\nfunc countRows(t *testing.T, ctx context.Context, db *sql.DB, count int, query string, args ...interface{}) {\n\tvar returned int\n\terr := db.QueryRowContext(ctx, query, args...).Scan(&returned)\n\tassert.NoError(t, err, \"error executing query %s and args %s\", query, args)\n\tassert.Equal(t, count, returned, \"unexpected return count %d, expected %d from %s and args %s\", returned, count, query, args)\n}\n"
        },
        {
          "name": "migrations",
          "type": "tree",
          "content": null
        },
        {
          "name": "monetization.go",
          "type": "blob",
          "size": 3.7900390625,
          "content": "/*\n * Copyright © 2020-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/log\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc displayMonetization(monetization, alias string) string {\n\tif monetization == \"\" {\n\t\treturn \"\"\n\t}\n\n\tptrURL, err := url.Parse(strings.Replace(monetization, \"$\", \"https://\", 1))\n\tif err == nil {\n\t\tif strings.HasSuffix(ptrURL.Host, \".xrptipbot.com\") {\n\t\t\t// xrp tip bot doesn't support stream receipts, so return plain pointer\n\t\t\treturn monetization\n\t\t}\n\t}\n\n\tu := os.Getenv(\"PAYMENT_HOST\")\n\tif u == \"\" {\n\t\treturn \"$webmonetization.org/api/receipts/\" + url.PathEscape(monetization)\n\t}\n\tu += \"/\" + alias\n\treturn u\n}\n\nfunc handleSPSPEndpoint(app *App, w http.ResponseWriter, r *http.Request) error {\n\tidStr := r.FormValue(\"id\")\n\tid, err := url.QueryUnescape(idStr)\n\tif err != nil {\n\t\tlog.Error(\"Unable to unescape: %s\", err)\n\t\treturn err\n\t}\n\n\tvar c *Collection\n\tif strings.IndexRune(id, '.') > 0 && app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(id)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpointer := c.Monetization\n\tif pointer == \"\" {\n\t\terr := impart.HTTPError{http.StatusNotFound, \"No monetization pointer.\"}\n\t\treturn err\n\t}\n\n\tfmt.Fprintf(w, pointer)\n\treturn nil\n}\n\nfunc handleGetSplitContent(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvar collID int64\n\tvar collLookupID string\n\tvar coll *Collection\n\tvar err error\n\tvars := mux.Vars(r)\n\tif collAlias := vars[\"alias\"]; collAlias != \"\" {\n\t\t// Fetch collection information, since an alias is provided\n\t\tcoll, err = app.db.GetCollection(collAlias)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcollID = coll.ID\n\t\tcollLookupID = coll.Alias\n\t}\n\n\tp, err := app.db.GetPost(vars[\"post\"], collID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treceipt := r.FormValue(\"receipt\")\n\tif receipt == \"\" {\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"No `receipt` given.\"}\n\t}\n\terr = verifyReceipt(receipt, collLookupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td := struct {\n\t\tContent     string `json:\"body\"`\n\t\tHTMLContent string `json:\"html_body\"`\n\t}{}\n\n\tif exc := strings.Index(p.Content, shortCodePaid); exc > -1 {\n\t\tbaseURL := \"\"\n\t\tif coll != nil {\n\t\t\tbaseURL = coll.CanonicalURL()\n\t\t}\n\n\t\td.Content = p.Content[exc+len(shortCodePaid):]\n\t\td.HTMLContent = applyMarkdown([]byte(d.Content), baseURL, app.cfg)\n\t}\n\n\treturn impart.WriteSuccess(w, d, http.StatusOK)\n}\n\nfunc verifyReceipt(receipt, id string) error {\n\treceiptsHost := os.Getenv(\"RECEIPTS_HOST\")\n\tif receiptsHost == \"\" {\n\t\treceiptsHost = \"https://webmonetization.org/api/receipts/verify?id=\" + id\n\t} else {\n\t\treceiptsHost = fmt.Sprintf(\"%s/receipts?id=%s\", receiptsHost, id)\n\t}\n\n\tlog.Info(\"Verifying receipt %s at %s\", receipt, receiptsHost)\n\tr, err := http.NewRequest(\"POST\", receiptsHost, bytes.NewBufferString(receipt))\n\tif err != nil {\n\t\tlog.Error(\"Unable to create new request to %s: %s\", receiptsHost, err)\n\t\treturn err\n\t}\n\n\tresp, err := http.DefaultClient.Do(r)\n\tif err != nil {\n\t\tlog.Error(\"Unable to Do() request to %s: %s\", receiptsHost, err)\n\t\treturn err\n\t}\n\tif resp != nil && resp.Body != nil {\n\t\tdefer resp.Body.Close()\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Error(\"Unable to read %s response body: %s\", receiptsHost, err)\n\t\treturn err\n\t}\n\tlog.Info(\"Status  : %s\", resp.Status)\n\tlog.Info(\"Response: %s\", body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Error(\"Bad response from %s:\\nStatus: %d\\n%s\", receiptsHost, resp.StatusCode, string(body))\n\t\treturn impart.HTTPError{resp.StatusCode, string(body)}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "nodeinfo.go",
          "type": "blob",
          "size": 3.0263671875,
          "content": "/*\n * Copyright © 2018-2019, 2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/go-nodeinfo\"\n\t\"github.com/writefreely/writefreely/config\"\n\t\"strings\"\n)\n\ntype nodeInfoResolver struct {\n\tcfg *config.Config\n\tdb  *datastore\n}\n\nfunc nodeInfoConfig(db *datastore, cfg *config.Config) *nodeinfo.Config {\n\tname := cfg.App.SiteName\n\tdesc := cfg.App.SiteDesc\n\tif desc == \"\" {\n\t\tdesc = \"Minimal, federated blogging platform.\"\n\t}\n\tif cfg.App.SingleUser {\n\t\t// Fetch blog information, instead\n\t\tcoll, err := db.GetCollectionByID(1)\n\t\tif err == nil {\n\t\t\tdesc = coll.Description\n\t\t}\n\t}\n\treturn &nodeinfo.Config{\n\t\tBaseURL: cfg.App.Host,\n\t\tInfoURL: \"/api/nodeinfo\",\n\n\t\tMetadata: nodeinfo.Metadata{\n\t\t\tNodeName:        name,\n\t\t\tNodeDescription: desc,\n\t\t\tPrivate:         cfg.App.Private,\n\t\t\tSoftware: nodeinfo.SoftwareMeta{\n\t\t\t\tHomePage: softwareURL,\n\t\t\t\tGitHub:   \"https://github.com/writefreely/writefreely\",\n\t\t\t\tFollow:   \"https://writing.exchange/@writefreely\",\n\t\t\t},\n\t\t\tMaxBlogs:     cfg.App.MaxBlogs,\n\t\t\tPublicReader: cfg.App.LocalTimeline,\n\t\t\tInvites:      cfg.App.UserInvites != \"\",\n\t\t},\n\t\tProtocols: []nodeinfo.NodeProtocol{\n\t\t\tnodeinfo.ProtocolActivityPub,\n\t\t},\n\t\tServices: nodeinfo.Services{\n\t\t\tInbound: []nodeinfo.NodeService{},\n\t\t\tOutbound: []nodeinfo.NodeService{\n\t\t\t\tnodeinfo.ServiceRSS,\n\t\t\t},\n\t\t},\n\t\tSoftware: nodeinfo.SoftwareInfo{\n\t\t\tName:    strings.ToLower(serverSoftware),\n\t\t\tVersion: softwareVer,\n\t\t},\n\t}\n}\n\nfunc (r nodeInfoResolver) IsOpenRegistration() (bool, error) {\n\treturn r.cfg.App.OpenRegistration, nil\n}\n\nfunc (r nodeInfoResolver) Usage() (nodeinfo.Usage, error) {\n\tvar collCount, postCount int64\n\tvar activeHalfYear, activeMonth int\n\tvar err error\n\tcollCount, err = r.db.GetTotalCollections()\n\tif err != nil {\n\t\tcollCount = 0\n\t}\n\tpostCount, err = r.db.GetTotalPosts()\n\tif err != nil {\n\t\tlog.Error(\"Unable to fetch post counts: %v\", err)\n\t}\n\n\tif r.cfg.App.PublicStats {\n\t\t// Display bi-yearly / monthly stats\n\t\terr = r.db.QueryRow(`SELECT COUNT(*) FROM (\nSELECT DISTINCT collection_id\nFROM posts\nINNER JOIN collections c\nON collection_id = c.id\nWHERE collection_id IS NOT NULL\n\tAND updated > DATE_SUB(NOW(), INTERVAL 6 MONTH)) co`).Scan(&activeHalfYear)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed getting 6-month active user stats: %s\", err)\n\t\t}\n\n\t\terr = r.db.QueryRow(`SELECT COUNT(*) FROM (\nSELECT DISTINCT collection_id\nFROM posts\nINNER JOIN collections c\nON collection_id = c.id\nWHERE collection_id IS NOT NULL\n\tAND updated > DATE_SUB(NOW(), INTERVAL 1 MONTH)) co`).Scan(&activeMonth)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed getting 1-month active user stats: %s\", err)\n\t\t}\n\t}\n\n\treturn nodeinfo.Usage{\n\t\tUsers: nodeinfo.UsageUsers{\n\t\t\tTotal:          int(collCount),\n\t\t\tActiveHalfYear: activeHalfYear,\n\t\t\tActiveMonth:    activeMonth,\n\t\t},\n\t\tLocalPosts: int(postCount),\n\t}, nil\n}\n"
        },
        {
          "name": "oauth.go",
          "type": "blob",
          "size": 17.2177734375,
          "content": "/*\n * Copyright © 2019-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/config\"\n)\n\n// OAuthButtons holds display information for different OAuth providers we support.\ntype OAuthButtons struct {\n\tSlackEnabled       bool\n\tWriteAsEnabled     bool\n\tGitLabEnabled      bool\n\tGitLabDisplayName  string\n\tGiteaEnabled       bool\n\tGiteaDisplayName   string\n\tGenericEnabled     bool\n\tGenericDisplayName string\n}\n\n// NewOAuthButtons creates a new OAuthButtons struct based on our app configuration.\nfunc NewOAuthButtons(cfg *config.Config) *OAuthButtons {\n\treturn &OAuthButtons{\n\t\tSlackEnabled:       cfg.SlackOauth.ClientID != \"\",\n\t\tWriteAsEnabled:     cfg.WriteAsOauth.ClientID != \"\",\n\t\tGitLabEnabled:      cfg.GitlabOauth.ClientID != \"\",\n\t\tGitLabDisplayName:  config.OrDefaultString(cfg.GitlabOauth.DisplayName, gitlabDisplayName),\n\t\tGiteaEnabled:       cfg.GiteaOauth.ClientID != \"\",\n\t\tGiteaDisplayName:   config.OrDefaultString(cfg.GiteaOauth.DisplayName, giteaDisplayName),\n\t\tGenericEnabled:     cfg.GenericOauth.ClientID != \"\",\n\t\tGenericDisplayName: config.OrDefaultString(cfg.GenericOauth.DisplayName, genericOauthDisplayName),\n\t}\n}\n\n// TokenResponse contains data returned when a token is created either\n// through a code exchange or using a refresh token.\ntype TokenResponse struct {\n\tAccessToken  string `json:\"access_token\"`\n\tExpiresIn    int    `json:\"expires_in\"`\n\tRefreshToken string `json:\"refresh_token\"`\n\tTokenType    string `json:\"token_type\"`\n\tError        string `json:\"error\"`\n}\n\n// InspectResponse contains data returned when an access token is inspected.\ntype InspectResponse struct {\n\tClientID    string    `json:\"client_id\"`\n\tUserID      string    `json:\"user_id\"`\n\tExpiresAt   time.Time `json:\"expires_at\"`\n\tUsername    string    `json:\"username\"`\n\tDisplayName string    `json:\"-\"`\n\tEmail       string    `json:\"email\"`\n\tError       string    `json:\"error\"`\n}\n\n// tokenRequestMaxLen is the most bytes that we'll read from the /oauth/token\n// endpoint. One megabyte is plenty.\nconst tokenRequestMaxLen = 1000000\n\n// infoRequestMaxLen is the most bytes that we'll read from the\n// /oauth/inspect endpoint.\nconst infoRequestMaxLen = 1000000\n\n// OAuthDatastoreProvider provides a minimal interface of data store, config,\n// and session store for use with the oauth handlers.\ntype OAuthDatastoreProvider interface {\n\tDB() OAuthDatastore\n\tConfig() *config.Config\n\tSessionStore() sessions.Store\n}\n\n// OAuthDatastore provides a minimal interface of data store methods used in\n// oauth functionality.\ntype OAuthDatastore interface {\n\tGetIDForRemoteUser(context.Context, string, string, string) (int64, error)\n\tRecordRemoteUserID(context.Context, int64, string, string, string, string) error\n\tValidateOAuthState(context.Context, string) (string, string, int64, string, error)\n\tGenerateOAuthState(context.Context, string, string, int64, string) (string, error)\n\n\tCreateUser(*config.Config, *User, string, string) error\n\tGetUserByID(int64) (*User, error)\n}\n\ntype HttpClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n\ntype oauthClient interface {\n\tGetProvider() string\n\tGetClientID() string\n\tGetCallbackLocation() string\n\tbuildLoginURL(state string) (string, error)\n\texchangeOauthCode(ctx context.Context, code string) (*TokenResponse, error)\n\tinspectOauthAccessToken(ctx context.Context, accessToken string) (*InspectResponse, error)\n}\n\ntype callbackProxyClient struct {\n\tserver           string\n\tcallbackLocation string\n\thttpClient       HttpClient\n}\n\ntype oauthHandler struct {\n\tConfig        *config.Config\n\tDB            OAuthDatastore\n\tStore         sessions.Store\n\tEmailKey      []byte\n\toauthClient   oauthClient\n\tcallbackProxy *callbackProxyClient\n}\n\nfunc (h oauthHandler) viewOauthInit(app *App, w http.ResponseWriter, r *http.Request) error {\n\tctx := r.Context()\n\n\tvar attachUser int64\n\tif attach := r.URL.Query().Get(\"attach\"); attach == \"t\" {\n\t\tuser, _ := getUserAndSession(app, r)\n\t\tif user == nil {\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, \"cannot attach auth to user: user not found in session\"}\n\t\t}\n\t\tattachUser = user.ID\n\t}\n\n\tstate, err := h.DB.GenerateOAuthState(ctx, h.oauthClient.GetProvider(), h.oauthClient.GetClientID(), attachUser, r.FormValue(\"invite_code\"))\n\tif err != nil {\n\t\tlog.Error(\"viewOauthInit error: %s\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"could not prepare oauth redirect url\"}\n\t}\n\n\tif h.callbackProxy != nil {\n\t\tif err := h.callbackProxy.register(ctx, state); err != nil {\n\t\t\tlog.Error(\"viewOauthInit error: %s\", err)\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, \"could not register state server\"}\n\t\t}\n\t}\n\n\tlocation, err := h.oauthClient.buildLoginURL(state)\n\tif err != nil {\n\t\tlog.Error(\"viewOauthInit error: %s\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"could not prepare oauth redirect url\"}\n\t}\n\treturn impart.HTTPError{http.StatusTemporaryRedirect, location}\n}\n\nfunc configureSlackOauth(parentHandler *Handler, r *mux.Router, app *App) {\n\tif app.Config().SlackOauth.ClientID != \"\" {\n\t\tcallbackLocation := app.Config().App.Host + \"/oauth/callback/slack\"\n\n\t\tvar stateRegisterClient *callbackProxyClient = nil\n\t\tif app.Config().SlackOauth.CallbackProxyAPI != \"\" {\n\t\t\tstateRegisterClient = &callbackProxyClient{\n\t\t\t\tserver:           app.Config().SlackOauth.CallbackProxyAPI,\n\t\t\t\tcallbackLocation: app.Config().App.Host + \"/oauth/callback/slack\",\n\t\t\t\thttpClient:       config.DefaultHTTPClient(),\n\t\t\t}\n\t\t\tcallbackLocation = app.Config().SlackOauth.CallbackProxy\n\t\t}\n\t\toauthClient := slackOauthClient{\n\t\t\tClientID:         app.Config().SlackOauth.ClientID,\n\t\t\tClientSecret:     app.Config().SlackOauth.ClientSecret,\n\t\t\tTeamID:           app.Config().SlackOauth.TeamID,\n\t\t\tHttpClient:       config.DefaultHTTPClient(),\n\t\t\tCallbackLocation: callbackLocation,\n\t\t}\n\t\tconfigureOauthRoutes(parentHandler, r, app, oauthClient, stateRegisterClient)\n\t}\n}\n\nfunc configureWriteAsOauth(parentHandler *Handler, r *mux.Router, app *App) {\n\tif app.Config().WriteAsOauth.ClientID != \"\" {\n\t\tcallbackLocation := app.Config().App.Host + \"/oauth/callback/write.as\"\n\n\t\tvar callbackProxy *callbackProxyClient = nil\n\t\tif app.Config().WriteAsOauth.CallbackProxy != \"\" {\n\t\t\tcallbackProxy = &callbackProxyClient{\n\t\t\t\tserver:           app.Config().WriteAsOauth.CallbackProxyAPI,\n\t\t\t\tcallbackLocation: app.Config().App.Host + \"/oauth/callback/write.as\",\n\t\t\t\thttpClient:       config.DefaultHTTPClient(),\n\t\t\t}\n\t\t\tcallbackLocation = app.Config().WriteAsOauth.CallbackProxy\n\t\t}\n\n\t\toauthClient := writeAsOauthClient{\n\t\t\tClientID:         app.Config().WriteAsOauth.ClientID,\n\t\t\tClientSecret:     app.Config().WriteAsOauth.ClientSecret,\n\t\t\tExchangeLocation: config.OrDefaultString(app.Config().WriteAsOauth.TokenLocation, writeAsExchangeLocation),\n\t\t\tInspectLocation:  config.OrDefaultString(app.Config().WriteAsOauth.InspectLocation, writeAsIdentityLocation),\n\t\t\tAuthLocation:     config.OrDefaultString(app.Config().WriteAsOauth.AuthLocation, writeAsAuthLocation),\n\t\t\tHttpClient:       config.DefaultHTTPClient(),\n\t\t\tCallbackLocation: callbackLocation,\n\t\t}\n\t\tconfigureOauthRoutes(parentHandler, r, app, oauthClient, callbackProxy)\n\t}\n}\n\nfunc configureGitlabOauth(parentHandler *Handler, r *mux.Router, app *App) {\n\tif app.Config().GitlabOauth.ClientID != \"\" {\n\t\tcallbackLocation := app.Config().App.Host + \"/oauth/callback/gitlab\"\n\n\t\tvar callbackProxy *callbackProxyClient = nil\n\t\tif app.Config().GitlabOauth.CallbackProxy != \"\" {\n\t\t\tcallbackProxy = &callbackProxyClient{\n\t\t\t\tserver:           app.Config().GitlabOauth.CallbackProxyAPI,\n\t\t\t\tcallbackLocation: app.Config().App.Host + \"/oauth/callback/gitlab\",\n\t\t\t\thttpClient:       config.DefaultHTTPClient(),\n\t\t\t}\n\t\t\tcallbackLocation = app.Config().GitlabOauth.CallbackProxy\n\t\t}\n\n\t\taddress := config.OrDefaultString(app.Config().GitlabOauth.Host, gitlabHost)\n\t\toauthClient := gitlabOauthClient{\n\t\t\tClientID:         app.Config().GitlabOauth.ClientID,\n\t\t\tClientSecret:     app.Config().GitlabOauth.ClientSecret,\n\t\t\tExchangeLocation: address + \"/oauth/token\",\n\t\t\tInspectLocation:  address + \"/api/v4/user\",\n\t\t\tAuthLocation:     address + \"/oauth/authorize\",\n\t\t\tHttpClient:       config.DefaultHTTPClient(),\n\t\t\tCallbackLocation: callbackLocation,\n\t\t}\n\t\tconfigureOauthRoutes(parentHandler, r, app, oauthClient, callbackProxy)\n\t}\n}\n\nfunc configureGenericOauth(parentHandler *Handler, r *mux.Router, app *App) {\n\tif app.Config().GenericOauth.ClientID != \"\" {\n\t\tcallbackLocation := app.Config().App.Host + \"/oauth/callback/generic\"\n\n\t\tvar callbackProxy *callbackProxyClient = nil\n\t\tif app.Config().GenericOauth.CallbackProxy != \"\" {\n\t\t\tcallbackProxy = &callbackProxyClient{\n\t\t\t\tserver:           app.Config().GenericOauth.CallbackProxyAPI,\n\t\t\t\tcallbackLocation: app.Config().App.Host + \"/oauth/callback/generic\",\n\t\t\t\thttpClient:       config.DefaultHTTPClient(),\n\t\t\t}\n\t\t\tcallbackLocation = app.Config().GenericOauth.CallbackProxy\n\t\t}\n\n\t\toauthClient := genericOauthClient{\n\t\t\tClientID:         app.Config().GenericOauth.ClientID,\n\t\t\tClientSecret:     app.Config().GenericOauth.ClientSecret,\n\t\t\tExchangeLocation: app.Config().GenericOauth.Host + app.Config().GenericOauth.TokenEndpoint,\n\t\t\tInspectLocation:  app.Config().GenericOauth.Host + app.Config().GenericOauth.InspectEndpoint,\n\t\t\tAuthLocation:     app.Config().GenericOauth.Host + app.Config().GenericOauth.AuthEndpoint,\n\t\t\tHttpClient:       config.DefaultHTTPClient(),\n\t\t\tCallbackLocation: callbackLocation,\n\t\t\tScope:            config.OrDefaultString(app.Config().GenericOauth.Scope, \"read_user\"),\n\t\t\tMapUserID:        config.OrDefaultString(app.Config().GenericOauth.MapUserID, \"user_id\"),\n\t\t\tMapUsername:      config.OrDefaultString(app.Config().GenericOauth.MapUsername, \"username\"),\n\t\t\tMapDisplayName:   config.OrDefaultString(app.Config().GenericOauth.MapDisplayName, \"-\"),\n\t\t\tMapEmail:         config.OrDefaultString(app.Config().GenericOauth.MapEmail, \"email\"),\n\t\t}\n\t\tconfigureOauthRoutes(parentHandler, r, app, oauthClient, callbackProxy)\n\t}\n}\n\nfunc configureGiteaOauth(parentHandler *Handler, r *mux.Router, app *App) {\n\tif app.Config().GiteaOauth.ClientID != \"\" {\n\t\tcallbackLocation := app.Config().App.Host + \"/oauth/callback/gitea\"\n\n\t\tvar callbackProxy *callbackProxyClient = nil\n\t\tif app.Config().GiteaOauth.CallbackProxy != \"\" {\n\t\t\tcallbackProxy = &callbackProxyClient{\n\t\t\t\tserver:           app.Config().GiteaOauth.CallbackProxyAPI,\n\t\t\t\tcallbackLocation: app.Config().App.Host + \"/oauth/callback/gitea\",\n\t\t\t\thttpClient:       config.DefaultHTTPClient(),\n\t\t\t}\n\t\t\tcallbackLocation = app.Config().GiteaOauth.CallbackProxy\n\t\t}\n\n\t\toauthClient := giteaOauthClient{\n\t\t\tClientID:         app.Config().GiteaOauth.ClientID,\n\t\t\tClientSecret:     app.Config().GiteaOauth.ClientSecret,\n\t\t\tExchangeLocation: app.Config().GiteaOauth.Host + \"/login/oauth/access_token\",\n\t\t\tInspectLocation:  app.Config().GiteaOauth.Host + \"/login/oauth/userinfo\",\n\t\t\tAuthLocation:     app.Config().GiteaOauth.Host + \"/login/oauth/authorize\",\n\t\t\tHttpClient:       config.DefaultHTTPClient(),\n\t\t\tCallbackLocation: callbackLocation,\n\t\t\tScope:            \"openid profile email\",\n\t\t\tMapUserID:        \"sub\",\n\t\t\tMapUsername:      \"login\",\n\t\t\tMapDisplayName:   \"full_name\",\n\t\t\tMapEmail:         \"email\",\n\t\t}\n\t\tconfigureOauthRoutes(parentHandler, r, app, oauthClient, callbackProxy)\n\t}\n}\n\nfunc configureOauthRoutes(parentHandler *Handler, r *mux.Router, app *App, oauthClient oauthClient, callbackProxy *callbackProxyClient) {\n\thandler := &oauthHandler{\n\t\tConfig:        app.Config(),\n\t\tDB:            app.DB(),\n\t\tStore:         app.SessionStore(),\n\t\toauthClient:   oauthClient,\n\t\tEmailKey:      app.keys.EmailKey,\n\t\tcallbackProxy: callbackProxy,\n\t}\n\tr.HandleFunc(\"/oauth/\"+oauthClient.GetProvider(), parentHandler.OAuth(handler.viewOauthInit)).Methods(\"GET\")\n\tr.HandleFunc(\"/oauth/callback/\"+oauthClient.GetProvider(), parentHandler.OAuth(handler.viewOauthCallback)).Methods(\"GET\")\n\tr.HandleFunc(\"/oauth/signup\", parentHandler.OAuth(handler.viewOauthSignup)).Methods(\"POST\")\n}\n\nfunc (h oauthHandler) viewOauthCallback(app *App, w http.ResponseWriter, r *http.Request) error {\n\tctx := r.Context()\n\n\tcode := r.FormValue(\"code\")\n\tstate := r.FormValue(\"state\")\n\n\tprovider, clientID, attachUserID, inviteCode, err := h.DB.ValidateOAuthState(ctx, state)\n\tif err != nil {\n\t\tlog.Error(\"Unable to ValidateOAuthState: %s\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, err.Error()}\n\t}\n\n\ttokenResponse, err := h.oauthClient.exchangeOauthCode(ctx, code)\n\tif err != nil {\n\t\tlog.Error(\"Unable to exchangeOauthCode: %s\", err)\n\t\t// TODO: show user friendly message if needed\n\t\t// TODO: show NO message for cases like user pressing \"Cancel\" on authorize step\n\t\taddSessionFlash(app, w, r, err.Error(), nil)\n\t\tif attachUserID > 0 {\n\t\t\treturn impart.HTTPError{http.StatusFound, \"/me/settings\"}\n\t\t}\n\t\treturn impart.HTTPError{http.StatusInternalServerError, err.Error()}\n\t}\n\n\t// Now that we have the access token, let's use it real quick to make sure\n\t// it really really works.\n\ttokenInfo, err := h.oauthClient.inspectOauthAccessToken(ctx, tokenResponse.AccessToken)\n\tif err != nil {\n\t\tlog.Error(\"Unable to inspectOauthAccessToken: %s\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, err.Error()}\n\t}\n\n\tlocalUserID, err := h.DB.GetIDForRemoteUser(ctx, tokenInfo.UserID, provider, clientID)\n\tif err != nil {\n\t\tlog.Error(\"Unable to GetIDForRemoteUser: %s\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, err.Error()}\n\t}\n\n\tif localUserID != -1 && attachUserID > 0 {\n\t\tif err = addSessionFlash(app, w, r, \"This OAuth account is already attached to another user.\", nil); err != nil {\n\t\t\treturn impart.HTTPError{Status: http.StatusInternalServerError, Message: err.Error()}\n\t\t}\n\t\treturn impart.HTTPError{http.StatusFound, \"/me/settings\"}\n\t}\n\n\tif localUserID != -1 {\n\t\t// Existing user, so log in now\n\t\tuser, err := h.DB.GetUserByID(localUserID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to GetUserByID %d: %s\", localUserID, err)\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, err.Error()}\n\t\t}\n\t\tif err = loginOrFail(h.Store, w, r, user); err != nil {\n\t\t\tlog.Error(\"Unable to loginOrFail %d: %s\", localUserID, err)\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, err.Error()}\n\t\t}\n\t\treturn nil\n\t}\n\tif attachUserID > 0 {\n\t\tlog.Info(\"attaching to user %d\", attachUserID)\n\t\tlog.Info(\"OAuth userid: %s\", tokenInfo.UserID)\n\t\terr = h.DB.RecordRemoteUserID(r.Context(), attachUserID, tokenInfo.UserID, provider, clientID, tokenResponse.AccessToken)\n\t\tif err != nil {\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, err.Error()}\n\t\t}\n\t\treturn impart.HTTPError{http.StatusFound, \"/me/settings\"}\n\t}\n\n\t// New user registration below.\n\t// First, verify that user is allowed to register\n\tif inviteCode != \"\" {\n\t\t// Verify invite code is valid\n\t\ti, err := app.db.GetUserInvite(inviteCode)\n\t\tif err != nil {\n\t\t\treturn impart.HTTPError{http.StatusInternalServerError, err.Error()}\n\t\t}\n\t\tif !i.Active(app.db) {\n\t\t\treturn impart.HTTPError{http.StatusNotFound, \"Invite link has expired.\"}\n\t\t}\n\t} else if !app.cfg.App.OpenRegistration {\n\t\taddSessionFlash(app, w, r, ErrUserNotFound.Error(), nil)\n\t\treturn impart.HTTPError{http.StatusFound, \"/login\"}\n\t}\n\n\tdisplayName := tokenInfo.DisplayName\n\tif len(displayName) == 0 {\n\t\tdisplayName = tokenInfo.Username\n\t}\n\n\ttp := &oauthSignupPageParams{\n\t\tAccessToken:     tokenResponse.AccessToken,\n\t\tTokenUsername:   tokenInfo.Username,\n\t\tTokenAlias:      tokenInfo.DisplayName,\n\t\tTokenEmail:      tokenInfo.Email,\n\t\tTokenRemoteUser: tokenInfo.UserID,\n\t\tProvider:        provider,\n\t\tClientID:        clientID,\n\t\tInviteCode:      inviteCode,\n\t}\n\ttp.TokenHash = tp.HashTokenParams(h.Config.Server.HashSeed)\n\n\treturn h.showOauthSignupPage(app, w, r, tp, nil)\n}\n\nfunc (r *callbackProxyClient) register(ctx context.Context, state string) error {\n\tform := url.Values{}\n\tform.Add(\"state\", state)\n\tform.Add(\"location\", r.callbackLocation)\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", r.server, strings.NewReader(form.Encode()))\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\tresp, err := r.httpClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp.StatusCode != http.StatusCreated {\n\t\treturn fmt.Errorf(\"unable register state location: %d\", resp.StatusCode)\n\t}\n\n\treturn nil\n}\n\nfunc limitedJsonUnmarshal(body io.ReadCloser, n int, thing interface{}) error {\n\tlr := io.LimitReader(body, int64(n+1))\n\tdata, err := io.ReadAll(lr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(data) == n+1 {\n\t\treturn fmt.Errorf(\"content larger than max read allowance: %d\", n)\n\t}\n\treturn json.Unmarshal(data, thing)\n}\n\nfunc loginOrFail(store sessions.Store, w http.ResponseWriter, r *http.Request, user *User) error {\n\t// An error may be returned, but a valid session should always be returned.\n\tsession, _ := store.Get(r, cookieName)\n\tsession.Values[cookieUserVal] = user.Cookie()\n\tif err := session.Save(r, w); err != nil {\n\t\tfmt.Println(\"error saving session\", err)\n\t\treturn err\n\t}\n\thttp.Redirect(w, r, \"/\", http.StatusTemporaryRedirect)\n\treturn nil\n}\n"
        },
        {
          "name": "oauth",
          "type": "tree",
          "content": null
        },
        {
          "name": "oauth_generic.go",
          "type": "blob",
          "size": 4.158203125,
          "content": "/*\n * Copyright © 2020-2021 Musing Studio LLC and respective authors.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/writeas/web-core/log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\ntype genericOauthClient struct {\n\tClientID         string\n\tClientSecret     string\n\tAuthLocation     string\n\tExchangeLocation string\n\tInspectLocation  string\n\tCallbackLocation string\n\tScope            string\n\tMapUserID        string\n\tMapUsername      string\n\tMapDisplayName   string\n\tMapEmail         string\n\tHttpClient       HttpClient\n}\n\nvar _ oauthClient = genericOauthClient{}\n\nconst (\n\tgenericOauthDisplayName = \"OAuth\"\n)\n\nfunc (c genericOauthClient) GetProvider() string {\n\treturn \"generic\"\n}\n\nfunc (c genericOauthClient) GetClientID() string {\n\treturn c.ClientID\n}\n\nfunc (c genericOauthClient) GetCallbackLocation() string {\n\treturn c.CallbackLocation\n}\n\nfunc (c genericOauthClient) buildLoginURL(state string) (string, error) {\n\tu, err := url.Parse(c.AuthLocation)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tq := u.Query()\n\tq.Set(\"client_id\", c.ClientID)\n\tq.Set(\"redirect_uri\", c.CallbackLocation)\n\tq.Set(\"response_type\", \"code\")\n\tq.Set(\"state\", state)\n\tq.Set(\"scope\", c.Scope)\n\tu.RawQuery = q.Encode()\n\treturn u.String(), nil\n}\n\nfunc (c genericOauthClient) exchangeOauthCode(ctx context.Context, code string) (*TokenResponse, error) {\n\tform := url.Values{}\n\tform.Add(\"client_id\", c.ClientID)\n\tform.Add(\"client_secret\", c.ClientSecret)\n\tform.Add(\"grant_type\", \"authorization_code\")\n\tform.Add(\"redirect_uri\", c.CallbackLocation)\n\tform.Add(\"scope\", c.Scope)\n\tform.Add(\"code\", code)\n\treq, err := http.NewRequest(\"POST\", c.ExchangeLocation, strings.NewReader(form.Encode()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(c.ClientID, c.ClientSecret)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to exchange code for access token\")\n\t}\n\n\tvar tokenResponse TokenResponse\n\tif err := limitedJsonUnmarshal(resp.Body, tokenRequestMaxLen, &tokenResponse); err != nil {\n\t\treturn nil, err\n\t}\n\tif tokenResponse.Error != \"\" {\n\t\treturn nil, errors.New(tokenResponse.Error)\n\t}\n\treturn &tokenResponse, nil\n}\n\nfunc (c genericOauthClient) inspectOauthAccessToken(ctx context.Context, accessToken string) (*InspectResponse, error) {\n\treq, err := http.NewRequest(\"GET\", c.InspectLocation, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+accessToken)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to inspect access token\")\n\t}\n\n\t// since we don't know what the JSON from the server will look like, we create a\n\t// generic interface and then map manually to values set in the config\n\tvar genericInterface map[string]interface{}\n\tif err := limitedJsonUnmarshal(resp.Body, infoRequestMaxLen, &genericInterface); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// map each relevant field in inspectResponse to the mapped field from the config\n\tvar inspectResponse InspectResponse\n\tinspectResponse.UserID, _ = genericInterface[c.MapUserID].(string)\n\tif inspectResponse.UserID == \"\" {\n\t\tlog.Error(\"[CONFIGURATION ERROR] Generic OAuth provider returned empty UserID value (`%s`).\\n  Do you need to configure a different `map_user_id` value for this provider?\", c.MapUserID)\n\t\treturn nil, fmt.Errorf(\"no UserID (`%s`) value returned\", c.MapUserID)\n\t}\n\tinspectResponse.Username, _ = genericInterface[c.MapUsername].(string)\n\tinspectResponse.DisplayName, _ = genericInterface[c.MapDisplayName].(string)\n\tinspectResponse.Email, _ = genericInterface[c.MapEmail].(string)\n\n\treturn &inspectResponse, nil\n}\n"
        },
        {
          "name": "oauth_gitea.go",
          "type": "blob",
          "size": 3.80859375,
          "content": "package writefreely\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/writeas/web-core/log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\ntype giteaOauthClient struct {\n\tClientID         string\n\tClientSecret     string\n\tAuthLocation     string\n\tExchangeLocation string\n\tInspectLocation  string\n\tCallbackLocation string\n\tScope            string\n\tMapUserID        string\n\tMapUsername      string\n\tMapDisplayName   string\n\tMapEmail         string\n\tHttpClient       HttpClient\n}\n\nvar _ oauthClient = giteaOauthClient{}\n\nconst (\n\tgiteaDisplayName = \"Gitea\"\n)\n\nfunc (c giteaOauthClient) GetProvider() string {\n\treturn \"gitea\"\n}\n\nfunc (c giteaOauthClient) GetClientID() string {\n\treturn c.ClientID\n}\n\nfunc (c giteaOauthClient) GetCallbackLocation() string {\n\treturn c.CallbackLocation\n}\n\nfunc (c giteaOauthClient) buildLoginURL(state string) (string, error) {\n\tu, err := url.Parse(c.AuthLocation)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tq := u.Query()\n\tq.Set(\"client_id\", c.ClientID)\n\tq.Set(\"redirect_uri\", c.CallbackLocation)\n\tq.Set(\"response_type\", \"code\")\n\tq.Set(\"state\", state)\n\tq.Set(\"scope\", c.Scope)\n\tu.RawQuery = q.Encode()\n\treturn u.String(), nil\n}\n\nfunc (c giteaOauthClient) exchangeOauthCode(ctx context.Context, code string) (*TokenResponse, error) {\n\tform := url.Values{}\n\tform.Add(\"grant_type\", \"authorization_code\")\n\tform.Add(\"redirect_uri\", c.CallbackLocation)\n\tform.Add(\"scope\", c.Scope)\n\tform.Add(\"code\", code)\n\treq, err := http.NewRequest(\"POST\", c.ExchangeLocation, strings.NewReader(form.Encode()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(c.ClientID, c.ClientSecret)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to exchange code for access token\")\n\t}\n\n\tvar tokenResponse TokenResponse\n\tif err := limitedJsonUnmarshal(resp.Body, tokenRequestMaxLen, &tokenResponse); err != nil {\n\t\treturn nil, err\n\t}\n\tif tokenResponse.Error != \"\" {\n\t\treturn nil, errors.New(tokenResponse.Error)\n\t}\n\treturn &tokenResponse, nil\n}\n\nfunc (c giteaOauthClient) inspectOauthAccessToken(ctx context.Context, accessToken string) (*InspectResponse, error) {\n\treq, err := http.NewRequest(\"GET\", c.InspectLocation, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+accessToken)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to inspect access token\")\n\t}\n\n\t// since we don't know what the JSON from the server will look like, we create a\n\t// generic interface and then map manually to values set in the config\n\tvar genericInterface map[string]interface{}\n\tif err := limitedJsonUnmarshal(resp.Body, infoRequestMaxLen, &genericInterface); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// map each relevant field in inspectResponse to the mapped field from the config\n\tvar inspectResponse InspectResponse\n\tinspectResponse.UserID, _ = genericInterface[c.MapUserID].(string)\n\t// log.Info(\"Userid from Gitea: %s\", inspectResponse.UserID)\n\tif inspectResponse.UserID == \"\" {\n\t\tlog.Error(\"[CONFIGURATION ERROR] Gitea OAuth provider returned empty UserID value (`%s`).\\n  Do you need to configure a different `map_user_id` value for this provider?\", c.MapUserID)\n\t\treturn nil, fmt.Errorf(\"no UserID (`%s`) value returned\", c.MapUserID)\n\t}\n\tinspectResponse.Username, _ = genericInterface[c.MapUsername].(string)\n\tinspectResponse.DisplayName, _ = genericInterface[c.MapDisplayName].(string)\n\tinspectResponse.Email, _ = genericInterface[c.MapEmail].(string)\n\n\treturn &inspectResponse, nil\n}\n"
        },
        {
          "name": "oauth_gitlab.go",
          "type": "blob",
          "size": 2.8818359375,
          "content": "package writefreely\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\ntype gitlabOauthClient struct {\n\tClientID         string\n\tClientSecret     string\n\tAuthLocation     string\n\tExchangeLocation string\n\tInspectLocation  string\n\tCallbackLocation string\n\tHttpClient       HttpClient\n}\n\nvar _ oauthClient = gitlabOauthClient{}\n\nconst (\n\tgitlabHost        = \"https://gitlab.com\"\n\tgitlabDisplayName = \"GitLab\"\n)\n\nfunc (c gitlabOauthClient) GetProvider() string {\n\treturn \"gitlab\"\n}\n\nfunc (c gitlabOauthClient) GetClientID() string {\n\treturn c.ClientID\n}\n\nfunc (c gitlabOauthClient) GetCallbackLocation() string {\n\treturn c.CallbackLocation\n}\n\nfunc (c gitlabOauthClient) buildLoginURL(state string) (string, error) {\n\tu, err := url.Parse(c.AuthLocation)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tq := u.Query()\n\tq.Set(\"client_id\", c.ClientID)\n\tq.Set(\"redirect_uri\", c.CallbackLocation)\n\tq.Set(\"response_type\", \"code\")\n\tq.Set(\"state\", state)\n\tq.Set(\"scope\", \"read_user\")\n\tu.RawQuery = q.Encode()\n\treturn u.String(), nil\n}\n\nfunc (c gitlabOauthClient) exchangeOauthCode(ctx context.Context, code string) (*TokenResponse, error) {\n\tform := url.Values{}\n\tform.Add(\"grant_type\", \"authorization_code\")\n\tform.Add(\"redirect_uri\", c.CallbackLocation)\n\tform.Add(\"scope\", \"read_user\")\n\tform.Add(\"code\", code)\n\treq, err := http.NewRequest(\"POST\", c.ExchangeLocation, strings.NewReader(form.Encode()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(c.ClientID, c.ClientSecret)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to exchange code for access token\")\n\t}\n\n\tvar tokenResponse TokenResponse\n\tif err := limitedJsonUnmarshal(resp.Body, tokenRequestMaxLen, &tokenResponse); err != nil {\n\t\treturn nil, err\n\t}\n\tif tokenResponse.Error != \"\" {\n\t\treturn nil, errors.New(tokenResponse.Error)\n\t}\n\treturn &tokenResponse, nil\n}\n\nfunc (c gitlabOauthClient) inspectOauthAccessToken(ctx context.Context, accessToken string) (*InspectResponse, error) {\n\treq, err := http.NewRequest(\"GET\", c.InspectLocation, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+accessToken)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to inspect access token\")\n\t}\n\n\tvar inspectResponse InspectResponse\n\tif err := limitedJsonUnmarshal(resp.Body, infoRequestMaxLen, &inspectResponse); err != nil {\n\t\treturn nil, err\n\t}\n\tif inspectResponse.Error != \"\" {\n\t\treturn nil, errors.New(inspectResponse.Error)\n\t}\n\treturn &inspectResponse, nil\n}\n"
        },
        {
          "name": "oauth_signup.go",
          "type": "blob",
          "size": 6.8876953125,
          "content": "/*\n * Copyright © 2020-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/auth\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/page\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype viewOauthSignupVars struct {\n\tpage.StaticPage\n\tTo      string\n\tMessage template.HTML\n\tFlashes []template.HTML\n\n\tAccessToken     string\n\tTokenUsername   string\n\tTokenAlias      string // TODO: rename this to match the data it represents: the collection title\n\tTokenEmail      string\n\tTokenRemoteUser string\n\tProvider        string\n\tClientID        string\n\tTokenHash       string\n\tInviteCode      string\n\n\tLoginUsername string\n\tAlias         string // TODO: rename this to match the data it represents: the collection title\n\tEmail         string\n}\n\nconst (\n\toauthParamAccessToken       = \"access_token\"\n\toauthParamTokenUsername     = \"token_username\"\n\toauthParamTokenAlias        = \"token_alias\"\n\toauthParamTokenEmail        = \"token_email\"\n\toauthParamTokenRemoteUserID = \"token_remote_user\"\n\toauthParamClientID          = \"client_id\"\n\toauthParamProvider          = \"provider\"\n\toauthParamHash              = \"signature\"\n\toauthParamUsername          = \"username\"\n\toauthParamAlias             = \"alias\"\n\toauthParamEmail             = \"email\"\n\toauthParamPassword          = \"password\"\n\toauthParamInviteCode        = \"invite_code\"\n)\n\ntype oauthSignupPageParams struct {\n\tAccessToken     string\n\tTokenUsername   string\n\tTokenAlias      string // TODO: rename this to match the data it represents: the collection title\n\tTokenEmail      string\n\tTokenRemoteUser string\n\tClientID        string\n\tProvider        string\n\tTokenHash       string\n\tInviteCode      string\n}\n\nfunc (p oauthSignupPageParams) HashTokenParams(key string) string {\n\thasher := sha256.New()\n\thasher.Write([]byte(key))\n\thasher.Write([]byte(p.AccessToken))\n\thasher.Write([]byte(p.TokenUsername))\n\thasher.Write([]byte(p.TokenAlias))\n\thasher.Write([]byte(p.TokenEmail))\n\thasher.Write([]byte(p.TokenRemoteUser))\n\thasher.Write([]byte(p.ClientID))\n\thasher.Write([]byte(p.Provider))\n\treturn hex.EncodeToString(hasher.Sum(nil))\n}\n\nfunc (h oauthHandler) viewOauthSignup(app *App, w http.ResponseWriter, r *http.Request) error {\n\ttp := &oauthSignupPageParams{\n\t\tAccessToken:     r.FormValue(oauthParamAccessToken),\n\t\tTokenUsername:   r.FormValue(oauthParamTokenUsername),\n\t\tTokenAlias:      r.FormValue(oauthParamTokenAlias),\n\t\tTokenEmail:      r.FormValue(oauthParamTokenEmail),\n\t\tTokenRemoteUser: r.FormValue(oauthParamTokenRemoteUserID),\n\t\tClientID:        r.FormValue(oauthParamClientID),\n\t\tProvider:        r.FormValue(oauthParamProvider),\n\t\tInviteCode:      r.FormValue(oauthParamInviteCode),\n\t}\n\tif tp.HashTokenParams(h.Config.Server.HashSeed) != r.FormValue(oauthParamHash) {\n\t\treturn impart.HTTPError{Status: http.StatusBadRequest, Message: \"Request has been tampered with.\"}\n\t}\n\ttp.TokenHash = tp.HashTokenParams(h.Config.Server.HashSeed)\n\tif err := h.validateOauthSignup(r); err != nil {\n\t\treturn h.showOauthSignupPage(app, w, r, tp, err)\n\t}\n\n\tvar err error\n\thashedPass := []byte{}\n\tclearPass := r.FormValue(oauthParamPassword)\n\thasPass := clearPass != \"\"\n\tif hasPass {\n\t\thashedPass, err = auth.HashPass([]byte(clearPass))\n\t\tif err != nil {\n\t\t\treturn h.showOauthSignupPage(app, w, r, tp, fmt.Errorf(\"unable to hash password\"))\n\t\t}\n\t}\n\tnewUser := &User{\n\t\tUsername:   r.FormValue(oauthParamUsername),\n\t\tHashedPass: hashedPass,\n\t\tHasPass:    hasPass,\n\t\tEmail:      prepareUserEmail(r.FormValue(oauthParamEmail), h.EmailKey),\n\t\tCreated:    time.Now().Truncate(time.Second).UTC(),\n\t}\n\tdisplayName := r.FormValue(oauthParamAlias)\n\tif len(displayName) == 0 {\n\t\tdisplayName = r.FormValue(oauthParamUsername)\n\t}\n\n\terr = h.DB.CreateUser(h.Config, newUser, displayName, \"\")\n\tif err != nil {\n\t\treturn h.showOauthSignupPage(app, w, r, tp, err)\n\t}\n\n\t// Log invite if needed\n\tif tp.InviteCode != \"\" {\n\t\terr = app.db.CreateInvitedUser(tp.InviteCode, newUser.ID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = h.DB.RecordRemoteUserID(r.Context(), newUser.ID, r.FormValue(oauthParamTokenRemoteUserID), r.FormValue(oauthParamProvider), r.FormValue(oauthParamClientID), r.FormValue(oauthParamAccessToken))\n\tif err != nil {\n\t\treturn h.showOauthSignupPage(app, w, r, tp, err)\n\t}\n\n\tif err := loginOrFail(h.Store, w, r, newUser); err != nil {\n\t\treturn h.showOauthSignupPage(app, w, r, tp, err)\n\t}\n\treturn nil\n}\n\nfunc (h oauthHandler) validateOauthSignup(r *http.Request) error {\n\tusername := r.FormValue(oauthParamUsername)\n\tif len(username) < h.Config.App.MinUsernameLen {\n\t\treturn impart.HTTPError{Status: http.StatusBadRequest, Message: \"Username is too short.\"}\n\t}\n\tif len(username) > 100 {\n\t\treturn impart.HTTPError{Status: http.StatusBadRequest, Message: \"Username is too long.\"}\n\t}\n\tcollTitle := r.FormValue(oauthParamAlias)\n\tif len(collTitle) == 0 {\n\t\tcollTitle = username\n\t}\n\temail := r.FormValue(oauthParamEmail)\n\tif len(email) > 0 {\n\t\tparts := strings.Split(email, \"@\")\n\t\tif len(parts) != 2 || (len(parts[0]) < 1 || len(parts[1]) < 1) {\n\t\t\treturn impart.HTTPError{Status: http.StatusBadRequest, Message: \"Invalid email address\"}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (h oauthHandler) showOauthSignupPage(app *App, w http.ResponseWriter, r *http.Request, tp *oauthSignupPageParams, errMsg error) error {\n\tusername := tp.TokenUsername\n\tcollTitle := tp.TokenAlias\n\temail := tp.TokenEmail\n\n\tsession, err := app.sessionStore.Get(r, cookieName)\n\tif err != nil {\n\t\t// Ignore this\n\t\tlog.Error(\"Unable to get session; ignoring: %v\", err)\n\t}\n\n\tif tmpValue := r.FormValue(oauthParamUsername); len(tmpValue) > 0 {\n\t\tusername = tmpValue\n\t}\n\tif tmpValue := r.FormValue(oauthParamAlias); len(tmpValue) > 0 {\n\t\tcollTitle = tmpValue\n\t}\n\tif tmpValue := r.FormValue(oauthParamEmail); len(tmpValue) > 0 {\n\t\temail = tmpValue\n\t}\n\n\tp := &viewOauthSignupVars{\n\t\tStaticPage: pageForReq(app, r),\n\t\tTo:         r.FormValue(\"to\"),\n\t\tFlashes:    []template.HTML{},\n\n\t\tAccessToken:     tp.AccessToken,\n\t\tTokenUsername:   tp.TokenUsername,\n\t\tTokenAlias:      tp.TokenAlias,\n\t\tTokenEmail:      tp.TokenEmail,\n\t\tTokenRemoteUser: tp.TokenRemoteUser,\n\t\tProvider:        tp.Provider,\n\t\tClientID:        tp.ClientID,\n\t\tTokenHash:       tp.TokenHash,\n\t\tInviteCode:      tp.InviteCode,\n\n\t\tLoginUsername: username,\n\t\tAlias:         collTitle,\n\t\tEmail:         email,\n\t}\n\n\t// Display any error messages\n\tflashes, _ := getSessionFlashes(app, w, r, session)\n\tfor _, flash := range flashes {\n\t\tp.Flashes = append(p.Flashes, template.HTML(flash))\n\t}\n\tif errMsg != nil {\n\t\tp.Flashes = append(p.Flashes, template.HTML(errMsg.Error()))\n\t}\n\terr = pages[\"signup-oauth.tmpl\"].ExecuteTemplate(w, \"base\", p)\n\tif err != nil {\n\t\tlog.Error(\"Unable to render signup-oauth: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "oauth_slack.go",
          "type": "blob",
          "size": 4.8251953125,
          "content": "/*\n * Copyright © 2019-2020 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/gosimple/slug\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\ntype slackOauthClient struct {\n\tClientID         string\n\tClientSecret     string\n\tTeamID           string\n\tCallbackLocation string\n\tHttpClient       HttpClient\n}\n\ntype slackExchangeResponse struct {\n\tOK          bool   `json:\"ok\"`\n\tAccessToken string `json:\"access_token\"`\n\tScope       string `json:\"scope\"`\n\tTeamName    string `json:\"team_name\"`\n\tTeamID      string `json:\"team_id\"`\n\tError       string `json:\"error\"`\n}\n\ntype slackIdentity struct {\n\tName  string `json:\"name\"`\n\tID    string `json:\"id\"`\n\tEmail string `json:\"email\"`\n}\n\ntype slackTeam struct {\n\tName string `json:\"name\"`\n\tID   string `json:\"id\"`\n}\n\ntype slackUserIdentityResponse struct {\n\tOK    bool          `json:\"ok\"`\n\tUser  slackIdentity `json:\"user\"`\n\tTeam  slackTeam     `json:\"team\"`\n\tError string        `json:\"error\"`\n}\n\nconst (\n\tslackAuthLocation     = \"https://slack.com/oauth/authorize\"\n\tslackExchangeLocation = \"https://slack.com/api/oauth.access\"\n\tslackIdentityLocation = \"https://slack.com/api/users.identity\"\n)\n\nvar _ oauthClient = slackOauthClient{}\n\nfunc (c slackOauthClient) GetProvider() string {\n\treturn \"slack\"\n}\n\nfunc (c slackOauthClient) GetClientID() string {\n\treturn c.ClientID\n}\n\nfunc (c slackOauthClient) GetCallbackLocation() string {\n\treturn c.CallbackLocation\n}\n\nfunc (c slackOauthClient) buildLoginURL(state string) (string, error) {\n\tu, err := url.Parse(slackAuthLocation)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tq := u.Query()\n\tq.Set(\"client_id\", c.ClientID)\n\tq.Set(\"scope\", \"identity.basic identity.email identity.team\")\n\tq.Set(\"redirect_uri\", c.CallbackLocation)\n\tq.Set(\"state\", state)\n\n\t// If this param is not set, the user can select which team they\n\t// authenticate through and then we'd have to match the configured team\n\t// against the profile get. That is extra work in the post-auth phase\n\t// that we don't want to do.\n\tq.Set(\"team\", c.TeamID)\n\n\t// The Slack OAuth docs don't explicitly list this one, but it is part of\n\t// the spec, so we include it anyway.\n\tq.Set(\"response_type\", \"code\")\n\tu.RawQuery = q.Encode()\n\treturn u.String(), nil\n}\n\nfunc (c slackOauthClient) exchangeOauthCode(ctx context.Context, code string) (*TokenResponse, error) {\n\tform := url.Values{}\n\t// The oauth.access documentation doesn't explicitly mention this\n\t// parameter, but it is part of the spec, so we include it anyway.\n\t// https://api.slack.com/methods/oauth.access\n\tform.Add(\"grant_type\", \"authorization_code\")\n\tform.Add(\"redirect_uri\", c.CallbackLocation)\n\tform.Add(\"code\", code)\n\treq, err := http.NewRequest(\"POST\", slackExchangeLocation, strings.NewReader(form.Encode()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(c.ClientID, c.ClientSecret)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to exchange code for access token\")\n\t}\n\n\tvar tokenResponse slackExchangeResponse\n\tif err := limitedJsonUnmarshal(resp.Body, tokenRequestMaxLen, &tokenResponse); err != nil {\n\t\treturn nil, err\n\t}\n\tif !tokenResponse.OK {\n\t\treturn nil, errors.New(tokenResponse.Error)\n\t}\n\treturn tokenResponse.TokenResponse(), nil\n}\n\nfunc (c slackOauthClient) inspectOauthAccessToken(ctx context.Context, accessToken string) (*InspectResponse, error) {\n\treq, err := http.NewRequest(\"GET\", slackIdentityLocation, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+accessToken)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to inspect access token\")\n\t}\n\n\tvar inspectResponse slackUserIdentityResponse\n\tif err := limitedJsonUnmarshal(resp.Body, infoRequestMaxLen, &inspectResponse); err != nil {\n\t\treturn nil, err\n\t}\n\tif !inspectResponse.OK {\n\t\treturn nil, errors.New(inspectResponse.Error)\n\t}\n\treturn inspectResponse.InspectResponse(), nil\n}\n\nfunc (resp slackUserIdentityResponse) InspectResponse() *InspectResponse {\n\treturn &InspectResponse{\n\t\tUserID:      resp.User.ID,\n\t\tUsername:    slug.Make(resp.User.Name),\n\t\tDisplayName: resp.User.Name,\n\t\tEmail:       resp.User.Email,\n\t}\n}\n\nfunc (resp slackExchangeResponse) TokenResponse() *TokenResponse {\n\treturn &TokenResponse{\n\t\tAccessToken: resp.AccessToken,\n\t}\n}\n"
        },
        {
          "name": "oauth_test.go",
          "type": "blob",
          "size": 8.5087890625,
          "content": "/*\n * Copyright © 2019-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/id\"\n\t\"github.com/writefreely/writefreely/config\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype MockOAuthDatastoreProvider struct {\n\tDoDB           func() OAuthDatastore\n\tDoConfig       func() *config.Config\n\tDoSessionStore func() sessions.Store\n}\n\ntype MockOAuthDatastore struct {\n\tDoGenerateOAuthState func(context.Context, string, string, int64, string) (string, error)\n\tDoValidateOAuthState func(context.Context, string) (string, string, int64, string, error)\n\tDoGetIDForRemoteUser func(context.Context, string, string, string) (int64, error)\n\tDoCreateUser         func(*config.Config, *User, string) error\n\tDoRecordRemoteUserID func(context.Context, int64, string, string, string, string) error\n\tDoGetUserByID        func(int64) (*User, error)\n}\n\nvar _ OAuthDatastore = &MockOAuthDatastore{}\n\ntype StringReadCloser struct {\n\t*strings.Reader\n}\n\nfunc (src *StringReadCloser) Close() error {\n\treturn nil\n}\n\ntype MockHTTPClient struct {\n\tDoDo func(req *http.Request) (*http.Response, error)\n}\n\nfunc (m *MockHTTPClient) Do(req *http.Request) (*http.Response, error) {\n\tif m.DoDo != nil {\n\t\treturn m.DoDo(req)\n\t}\n\treturn &http.Response{}, nil\n}\n\nfunc (m *MockOAuthDatastoreProvider) SessionStore() sessions.Store {\n\tif m.DoSessionStore != nil {\n\t\treturn m.DoSessionStore()\n\t}\n\treturn sessions.NewCookieStore([]byte(\"secret-key\"))\n}\n\nfunc (m *MockOAuthDatastoreProvider) DB() OAuthDatastore {\n\tif m.DoDB != nil {\n\t\treturn m.DoDB()\n\t}\n\treturn &MockOAuthDatastore{}\n}\n\nfunc (m *MockOAuthDatastoreProvider) Config() *config.Config {\n\tif m.DoConfig != nil {\n\t\treturn m.DoConfig()\n\t}\n\tcfg := config.New()\n\tcfg.UseSQLite(true)\n\tcfg.WriteAsOauth = config.WriteAsOauthCfg{\n\t\tClientID:        \"development\",\n\t\tClientSecret:    \"development\",\n\t\tAuthLocation:    \"https://write.as/oauth/login\",\n\t\tTokenLocation:   \"https://write.as/oauth/token\",\n\t\tInspectLocation: \"https://write.as/oauth/inspect\",\n\t}\n\tcfg.SlackOauth = config.SlackOauthCfg{\n\t\tClientID:     \"development\",\n\t\tClientSecret: \"development\",\n\t\tTeamID:       \"development\",\n\t}\n\treturn cfg\n}\n\nfunc (m *MockOAuthDatastore) ValidateOAuthState(ctx context.Context, state string) (string, string, int64, string, error) {\n\tif m.DoValidateOAuthState != nil {\n\t\treturn m.DoValidateOAuthState(ctx, state)\n\t}\n\treturn \"\", \"\", 0, \"\", nil\n}\n\nfunc (m *MockOAuthDatastore) GetIDForRemoteUser(ctx context.Context, remoteUserID, provider, clientID string) (int64, error) {\n\tif m.DoGetIDForRemoteUser != nil {\n\t\treturn m.DoGetIDForRemoteUser(ctx, remoteUserID, provider, clientID)\n\t}\n\treturn -1, nil\n}\n\nfunc (m *MockOAuthDatastore) CreateUser(cfg *config.Config, u *User, username, description string) error {\n\tif m.DoCreateUser != nil {\n\t\treturn m.DoCreateUser(cfg, u, username)\n\t}\n\tu.ID = 1\n\treturn nil\n}\n\nfunc (m *MockOAuthDatastore) RecordRemoteUserID(ctx context.Context, localUserID int64, remoteUserID, provider, clientID, accessToken string) error {\n\tif m.DoRecordRemoteUserID != nil {\n\t\treturn m.DoRecordRemoteUserID(ctx, localUserID, remoteUserID, provider, clientID, accessToken)\n\t}\n\treturn nil\n}\n\nfunc (m *MockOAuthDatastore) GetUserByID(userID int64) (*User, error) {\n\tif m.DoGetUserByID != nil {\n\t\treturn m.DoGetUserByID(userID)\n\t}\n\tuser := &User{}\n\treturn user, nil\n}\n\nfunc (m *MockOAuthDatastore) GenerateOAuthState(ctx context.Context, provider string, clientID string, attachUserID int64, inviteCode string) (string, error) {\n\tif m.DoGenerateOAuthState != nil {\n\t\treturn m.DoGenerateOAuthState(ctx, provider, clientID, attachUserID, inviteCode)\n\t}\n\treturn id.Generate62RandomString(14), nil\n}\n\nfunc TestViewOauthInit(t *testing.T) {\n\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tapp := &MockOAuthDatastoreProvider{}\n\t\th := oauthHandler{\n\t\t\tConfig:   app.Config(),\n\t\t\tDB:       app.DB(),\n\t\t\tStore:    app.SessionStore(),\n\t\t\tEmailKey: []byte{0xd, 0xe, 0xc, 0xa, 0xf, 0xf, 0xb, 0xa, 0xd},\n\t\t\toauthClient: writeAsOauthClient{\n\t\t\t\tClientID:         app.Config().WriteAsOauth.ClientID,\n\t\t\t\tClientSecret:     app.Config().WriteAsOauth.ClientSecret,\n\t\t\t\tExchangeLocation: app.Config().WriteAsOauth.TokenLocation,\n\t\t\t\tInspectLocation:  app.Config().WriteAsOauth.InspectLocation,\n\t\t\t\tAuthLocation:     app.Config().WriteAsOauth.AuthLocation,\n\t\t\t\tCallbackLocation: \"http://localhost/oauth/callback\",\n\t\t\t\tHttpClient:       nil,\n\t\t\t},\n\t\t}\n\t\treq, err := http.NewRequest(\"GET\", \"/oauth/client\", nil)\n\t\tassert.NoError(t, err)\n\t\trr := httptest.NewRecorder()\n\t\terr = h.viewOauthInit(nil, rr, req)\n\t\tassert.NotNil(t, err)\n\t\thttpErr, ok := err.(impart.HTTPError)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, http.StatusTemporaryRedirect, httpErr.Status)\n\t\tassert.NotEmpty(t, httpErr.Message)\n\t\tlocURI, err := url.Parse(httpErr.Message)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"/oauth/login\", locURI.Path)\n\t\tassert.Equal(t, \"development\", locURI.Query().Get(\"client_id\"))\n\t\tassert.Equal(t, \"http://localhost/oauth/callback\", locURI.Query().Get(\"redirect_uri\"))\n\t\tassert.Equal(t, \"code\", locURI.Query().Get(\"response_type\"))\n\t\tassert.NotEmpty(t, locURI.Query().Get(\"state\"))\n\t})\n\n\tt.Run(\"state failure\", func(t *testing.T) {\n\t\tapp := &MockOAuthDatastoreProvider{\n\t\t\tDoDB: func() OAuthDatastore {\n\t\t\t\treturn &MockOAuthDatastore{\n\t\t\t\t\tDoGenerateOAuthState: func(ctx context.Context, provider, clientID string, attachUserID int64, inviteCode string) (string, error) {\n\t\t\t\t\t\treturn \"\", fmt.Errorf(\"pretend unable to write state error\")\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\th := oauthHandler{\n\t\t\tConfig:   app.Config(),\n\t\t\tDB:       app.DB(),\n\t\t\tStore:    app.SessionStore(),\n\t\t\tEmailKey: []byte{0xd, 0xe, 0xc, 0xa, 0xf, 0xf, 0xb, 0xa, 0xd},\n\t\t\toauthClient: writeAsOauthClient{\n\t\t\t\tClientID:         app.Config().WriteAsOauth.ClientID,\n\t\t\t\tClientSecret:     app.Config().WriteAsOauth.ClientSecret,\n\t\t\t\tExchangeLocation: app.Config().WriteAsOauth.TokenLocation,\n\t\t\t\tInspectLocation:  app.Config().WriteAsOauth.InspectLocation,\n\t\t\t\tAuthLocation:     app.Config().WriteAsOauth.AuthLocation,\n\t\t\t\tCallbackLocation: \"http://localhost/oauth/callback\",\n\t\t\t\tHttpClient:       nil,\n\t\t\t},\n\t\t}\n\t\treq, err := http.NewRequest(\"GET\", \"/oauth/client\", nil)\n\t\tassert.NoError(t, err)\n\t\trr := httptest.NewRecorder()\n\t\terr = h.viewOauthInit(nil, rr, req)\n\t\thttpErr, ok := err.(impart.HTTPError)\n\t\tassert.True(t, ok)\n\t\tassert.NotEmpty(t, httpErr.Message)\n\t\tassert.Equal(t, http.StatusInternalServerError, httpErr.Status)\n\t\tassert.Equal(t, \"could not prepare oauth redirect url\", httpErr.Message)\n\t})\n}\n\nfunc TestViewOauthCallback(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tapp := &MockOAuthDatastoreProvider{}\n\t\th := oauthHandler{\n\t\t\tConfig:   app.Config(),\n\t\t\tDB:       app.DB(),\n\t\t\tStore:    app.SessionStore(),\n\t\t\tEmailKey: []byte{0xd, 0xe, 0xc, 0xa, 0xf, 0xf, 0xb, 0xa, 0xd},\n\t\t\toauthClient: writeAsOauthClient{\n\t\t\t\tClientID:         app.Config().WriteAsOauth.ClientID,\n\t\t\t\tClientSecret:     app.Config().WriteAsOauth.ClientSecret,\n\t\t\t\tExchangeLocation: app.Config().WriteAsOauth.TokenLocation,\n\t\t\t\tInspectLocation:  app.Config().WriteAsOauth.InspectLocation,\n\t\t\t\tAuthLocation:     app.Config().WriteAsOauth.AuthLocation,\n\t\t\t\tCallbackLocation: \"http://localhost/oauth/callback\",\n\t\t\t\tHttpClient: &MockHTTPClient{\n\t\t\t\t\tDoDo: func(req *http.Request) (*http.Response, error) {\n\t\t\t\t\t\tswitch req.URL.String() {\n\t\t\t\t\t\tcase \"https://write.as/oauth/token\":\n\t\t\t\t\t\t\treturn &http.Response{\n\t\t\t\t\t\t\t\tStatusCode: 200,\n\t\t\t\t\t\t\t\tBody:       &StringReadCloser{strings.NewReader(`{\"access_token\": \"access_token\", \"expires_in\": 1000, \"refresh_token\": \"refresh_token\", \"token_type\": \"access\"}`)},\n\t\t\t\t\t\t\t}, nil\n\t\t\t\t\t\tcase \"https://write.as/oauth/inspect\":\n\t\t\t\t\t\t\treturn &http.Response{\n\t\t\t\t\t\t\t\tStatusCode: 200,\n\t\t\t\t\t\t\t\tBody:       &StringReadCloser{strings.NewReader(`{\"client_id\": \"development\", \"user_id\": \"1\", \"expires_at\": \"2019-12-19T11:42:01Z\", \"username\": \"nick\", \"email\": \"nick@testing.write.as\"}`)},\n\t\t\t\t\t\t\t}, nil\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn &http.Response{\n\t\t\t\t\t\t\tStatusCode: http.StatusNotFound,\n\t\t\t\t\t\t}, nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\treq, err := http.NewRequest(\"GET\", \"/oauth/callback\", nil)\n\t\tassert.NoError(t, err)\n\t\trr := httptest.NewRecorder()\n\t\terr = h.viewOauthCallback(&App{cfg: app.Config(), sessionStore: app.SessionStore()}, rr, req)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, http.StatusTemporaryRedirect, rr.Code)\n\t})\n}\n"
        },
        {
          "name": "oauth_writeas.go",
          "type": "blob",
          "size": 2.93359375,
          "content": "package writefreely\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\ntype writeAsOauthClient struct {\n\tClientID         string\n\tClientSecret     string\n\tAuthLocation     string\n\tExchangeLocation string\n\tInspectLocation  string\n\tCallbackLocation string\n\tHttpClient       HttpClient\n}\n\nvar _ oauthClient = writeAsOauthClient{}\n\nconst (\n\twriteAsAuthLocation     = \"https://write.as/oauth/login\"\n\twriteAsExchangeLocation = \"https://write.as/oauth/token\"\n\twriteAsIdentityLocation = \"https://write.as/oauth/inspect\"\n)\n\nfunc (c writeAsOauthClient) GetProvider() string {\n\treturn \"write.as\"\n}\n\nfunc (c writeAsOauthClient) GetClientID() string {\n\treturn c.ClientID\n}\n\nfunc (c writeAsOauthClient) GetCallbackLocation() string {\n\treturn c.CallbackLocation\n}\n\nfunc (c writeAsOauthClient) buildLoginURL(state string) (string, error) {\n\tu, err := url.Parse(c.AuthLocation)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tq := u.Query()\n\tq.Set(\"client_id\", c.ClientID)\n\tq.Set(\"redirect_uri\", c.CallbackLocation)\n\tq.Set(\"response_type\", \"code\")\n\tq.Set(\"state\", state)\n\tu.RawQuery = q.Encode()\n\treturn u.String(), nil\n}\n\nfunc (c writeAsOauthClient) exchangeOauthCode(ctx context.Context, code string) (*TokenResponse, error) {\n\tform := url.Values{}\n\tform.Add(\"grant_type\", \"authorization_code\")\n\tform.Add(\"redirect_uri\", c.CallbackLocation)\n\tform.Add(\"code\", code)\n\treq, err := http.NewRequest(\"POST\", c.ExchangeLocation, strings.NewReader(form.Encode()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(c.ClientID, c.ClientSecret)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to exchange code for access token\")\n\t}\n\n\tvar tokenResponse TokenResponse\n\tif err := limitedJsonUnmarshal(resp.Body, tokenRequestMaxLen, &tokenResponse); err != nil {\n\t\treturn nil, err\n\t}\n\tif tokenResponse.Error != \"\" {\n\t\treturn nil, errors.New(tokenResponse.Error)\n\t}\n\treturn &tokenResponse, nil\n}\n\nfunc (c writeAsOauthClient) inspectOauthAccessToken(ctx context.Context, accessToken string) (*InspectResponse, error) {\n\treq, err := http.NewRequest(\"GET\", c.InspectLocation, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.WithContext(ctx)\n\treq.Header.Set(\"User-Agent\", ServerUserAgent(\"\"))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+accessToken)\n\n\tresp, err := c.HttpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(\"unable to inspect access token\")\n\t}\n\n\tvar inspectResponse InspectResponse\n\tif err := limitedJsonUnmarshal(resp.Body, infoRequestMaxLen, &inspectResponse); err != nil {\n\t\treturn nil, err\n\t}\n\tif inspectResponse.Error != \"\" {\n\t\treturn nil, errors.New(inspectResponse.Error)\n\t}\n\treturn &inspectResponse, nil\n}\n"
        },
        {
          "name": "ossl_legacy.cnf",
          "type": "blob",
          "size": 0.115234375,
          "content": "\n[provider_sect]\ndefault = default_sect\nlegacy = legacy_sect\n\n[default_sect]\nactivate = 1\n\n[legacy_sect]\nactivate = 1\n"
        },
        {
          "name": "pad.go",
          "type": "blob",
          "size": 5.6044921875,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/page\"\n)\n\nfunc handleViewPad(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\taction := vars[\"action\"]\n\tslug := vars[\"slug\"]\n\tcollAlias := vars[\"collection\"]\n\tif app.cfg.App.SingleUser {\n\t\t// TODO: refactor all of this, especially for single-user blogs\n\t\tc, err := app.db.GetCollectionByID(1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcollAlias = c.Alias\n\t}\n\tappData := &struct {\n\t\tpage.StaticPage\n\t\tPost     *RawPost\n\t\tUser     *User\n\t\tBlogs    *[]Collection\n\t\tSilenced bool\n\n\t\tEditing        bool        // True if we're modifying an existing post\n\t\tEditCollection *Collection // Collection of the post we're editing, if any\n\t}{\n\t\tStaticPage: pageForReq(app, r),\n\t\tPost:       &RawPost{Font: \"norm\"},\n\t\tUser:       getUserSession(app, r),\n\t}\n\tvar err error\n\tif appData.User != nil {\n\t\tappData.Blogs, err = app.db.GetPublishableCollections(appData.User, app.cfg.App.Host)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to get user's blogs for Pad: %v\", err)\n\t\t}\n\t\tappData.Silenced, err = app.db.IsUserSilenced(appData.User.ID)\n\t\tif err != nil {\n\t\t\tif err == ErrUserNotFound {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tlog.Error(\"Unable to get user status for Pad: %v\", err)\n\t\t}\n\t}\n\n\tpadTmpl := app.cfg.App.Editor\n\tif templates[padTmpl] == nil {\n\t\tif padTmpl != \"\" {\n\t\t\tlog.Info(\"No template '%s' found. Falling back to default 'pad' template.\", padTmpl)\n\t\t}\n\t\tpadTmpl = \"pad\"\n\t}\n\n\tif action == \"\" && slug == \"\" {\n\t\t// Not editing any post; simply render the Pad\n\t\tif err = templates[padTmpl].ExecuteTemplate(w, \"pad\", appData); err != nil {\n\t\t\tlog.Error(\"Unable to execute template: %v\", err)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// Retrieve post information for editing\n\tappData.Editing = true\n\t// Make sure this isn't cached, so user doesn't accidentally lose data\n\tw.Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n\tw.Header().Set(\"Expires\", \"Thu, 04 Oct 1990 20:00:00 GMT\")\n\tif slug != \"\" {\n\t\t// TODO: refactor all of this, especially for single-user blogs\n\t\tappData.Post = getRawCollectionPost(app, slug, collAlias)\n\t\tif appData.Post.OwnerID != appData.User.ID {\n\t\t\t// TODO: add ErrForbiddenEditPost message to flashes\n\t\t\treturn impart.HTTPError{http.StatusFound, r.URL.Path[:strings.LastIndex(r.URL.Path, \"/edit\")]}\n\t\t}\n\t\tappData.EditCollection, err = app.db.GetCollectionForPad(collAlias)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Unable to GetCollectionForPad: %s\", err)\n\t\t\treturn err\n\t\t}\n\t\tappData.EditCollection.hostName = app.cfg.App.Host\n\t} else {\n\t\t// Editing a floating article\n\t\tappData.Post = getRawPost(app, action)\n\t\tappData.Post.Id = action\n\t}\n\n\tif appData.Post.Gone {\n\t\treturn ErrPostUnpublished\n\t} else if appData.Post.Found && (appData.Post.Title != \"\" || appData.Post.Content != \"\") {\n\t\t// Got the post\n\t} else if appData.Post.Found {\n\t\tlog.Error(\"Found post, but other conditions failed.\")\n\t\treturn ErrPostFetchError\n\t} else {\n\t\treturn ErrPostNotFound\n\t}\n\n\tif err = templates[padTmpl].ExecuteTemplate(w, \"pad\", appData); err != nil {\n\t\tlog.Error(\"Unable to execute template: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc handleViewMeta(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\taction := vars[\"action\"]\n\tslug := vars[\"slug\"]\n\tcollAlias := vars[\"collection\"]\n\tappData := &struct {\n\t\tpage.StaticPage\n\t\tPost           *RawPost\n\t\tUser           *User\n\t\tEditCollection *Collection // Collection of the post we're editing, if any\n\t\tFlashes        []string\n\t\tNeedsToken     bool\n\t\tSilenced       bool\n\t}{\n\t\tStaticPage: pageForReq(app, r),\n\t\tPost:       &RawPost{Font: \"norm\"},\n\t\tUser:       getUserSession(app, r),\n\t}\n\tvar err error\n\tappData.Silenced, err = app.db.IsUserSilenced(appData.User.ID)\n\tif err != nil {\n\t\tlog.Error(\"view meta: get user status: %v\", err)\n\t\treturn ErrInternalGeneral\n\t}\n\n\tif action == \"\" && slug == \"\" {\n\t\treturn ErrPostNotFound\n\t}\n\n\t// Make sure this isn't cached, so user doesn't accidentally lose data\n\tw.Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n\tw.Header().Set(\"Expires\", \"Thu, 28 Jul 1989 12:00:00 GMT\")\n\tif slug != \"\" {\n\t\tappData.Post = getRawCollectionPost(app, slug, collAlias)\n\t\tif appData.Post.OwnerID != appData.User.ID {\n\t\t\t// TODO: add ErrForbiddenEditPost message to flashes\n\t\t\treturn impart.HTTPError{http.StatusFound, r.URL.Path[:strings.LastIndex(r.URL.Path, \"/meta\")]}\n\t\t}\n\t\tif app.cfg.App.SingleUser {\n\t\t\t// TODO: optimize this query just like we do in GetCollectionForPad (?)\n\t\t\tappData.EditCollection, err = app.db.GetCollectionByID(1)\n\t\t} else {\n\t\t\tappData.EditCollection, err = app.db.GetCollectionForPad(collAlias)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tappData.EditCollection.hostName = app.cfg.App.Host\n\t} else {\n\t\t// Editing a floating article\n\t\tappData.Post = getRawPost(app, action)\n\t\tappData.Post.Id = action\n\t}\n\tappData.NeedsToken = appData.User == nil || appData.User.ID != appData.Post.OwnerID\n\n\tif appData.Post.Gone {\n\t\treturn ErrPostUnpublished\n\t} else if appData.Post.Found && appData.Post.Content != \"\" {\n\t\t// Got the post\n\t} else if appData.Post.Found {\n\t\treturn ErrPostFetchError\n\t} else {\n\t\treturn ErrPostNotFound\n\t}\n\tappData.Flashes, _ = getSessionFlashes(app, w, r, nil)\n\n\tif err = templates[\"edit-meta\"].ExecuteTemplate(w, \"edit-meta\", appData); err != nil {\n\t\tlog.Error(\"Unable to execute template: %v\", err)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "page",
          "type": "tree",
          "content": null
        },
        {
          "name": "pages.go",
          "type": "blob",
          "size": 5.724609375,
          "content": "/*\n * Copyright © 2018-2019, 2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"github.com/writefreely/writefreely/config\"\n\t\"time\"\n)\n\nvar defaultPageUpdatedTime = time.Date(2018, 11, 8, 12, 0, 0, 0, time.Local)\n\nfunc getAboutPage(app *App) (*instanceContent, error) {\n\tc, err := app.db.GetDynamicContent(\"about\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c == nil {\n\t\tc = &instanceContent{\n\t\t\tID:      \"about\",\n\t\t\tType:    \"page\",\n\t\t\tContent: defaultAboutPage(app.cfg),\n\t\t}\n\t}\n\tif !c.Title.Valid {\n\t\tc.Title = defaultAboutTitle(app.cfg)\n\t}\n\treturn c, nil\n}\n\nfunc defaultAboutTitle(cfg *config.Config) sql.NullString {\n\treturn sql.NullString{String: \"About \" + cfg.App.SiteName, Valid: true}\n}\n\nfunc getContactPage(app *App) (*instanceContent, error) {\n\tc, err := app.db.GetDynamicContent(\"contact\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c == nil {\n\t\tc = &instanceContent{\n\t\t\tID:      \"contact\",\n\t\t\tType:    \"page\",\n\t\t\tContent: defaultContactPage(app),\n\t\t}\n\t}\n\tif !c.Title.Valid {\n\t\tc.Title = defaultContactTitle()\n\t}\n\treturn c, nil\n}\n\nfunc defaultContactTitle() sql.NullString {\n\treturn sql.NullString{String: \"Contact Us\", Valid: true}\n}\n\nfunc getPrivacyPage(app *App) (*instanceContent, error) {\n\tc, err := app.db.GetDynamicContent(\"privacy\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c == nil {\n\t\tc = &instanceContent{\n\t\t\tID:      \"privacy\",\n\t\t\tType:    \"page\",\n\t\t\tContent: defaultPrivacyPolicy(app.cfg),\n\t\t\tUpdated: defaultPageUpdatedTime,\n\t\t}\n\t}\n\tif !c.Title.Valid {\n\t\tc.Title = defaultPrivacyTitle()\n\t}\n\treturn c, nil\n}\n\nfunc defaultPrivacyTitle() sql.NullString {\n\treturn sql.NullString{String: \"Privacy Policy\", Valid: true}\n}\n\nfunc defaultAboutPage(cfg *config.Config) string {\n\tif cfg.App.Federation {\n\t\treturn `_` + cfg.App.SiteName + `_ is an interconnected place for you to write and publish, powered by [WriteFreely](https://writefreely.org) and ActivityPub.`\n\t}\n\treturn `_` + cfg.App.SiteName + `_ is a place for you to write and publish, powered by [WriteFreely](https://writefreely.org).`\n}\n\nfunc defaultContactPage(app *App) string {\n\tc, err := app.db.GetCollectionByID(1)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn `_` + app.cfg.App.SiteName + `_ is administered by: [**` + c.Alias + `**](/` + c.Alias + `/).\n\nContact them at this email address: _EMAIL GOES HERE_.\n\nYou can also reach them here...`\n}\n\nfunc defaultPrivacyPolicy(cfg *config.Config) string {\n\treturn `[WriteFreely](https://writefreely.org), the software that powers this site, is built to enforce your right to privacy by default.\n\nIt retains as little data about you as possible, not even requiring an email address to sign up. However, if you _do_ give us your email address, it is stored encrypted in our database. We salt and hash your account's password.\n\nWe store log files, or data about what happens on our servers. We also use cookies to keep you logged into your account.\n\nBeyond this, it's important that you trust whoever runs **` + cfg.App.SiteName + `**. Software can only do so much to protect you -- your level of privacy protections will ultimately fall on the humans that run this particular service.`\n}\n\nfunc getLandingBanner(app *App) (*instanceContent, error) {\n\tc, err := app.db.GetDynamicContent(\"landing-banner\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c == nil {\n\t\tc = &instanceContent{\n\t\t\tID:      \"landing-banner\",\n\t\t\tType:    \"section\",\n\t\t\tContent: defaultLandingBanner(app.cfg),\n\t\t\tUpdated: defaultPageUpdatedTime,\n\t\t}\n\t}\n\treturn c, nil\n}\n\nfunc getLandingBody(app *App) (*instanceContent, error) {\n\tc, err := app.db.GetDynamicContent(\"landing-body\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c == nil {\n\t\tc = &instanceContent{\n\t\t\tID:      \"landing-body\",\n\t\t\tType:    \"section\",\n\t\t\tContent: defaultLandingBody(app.cfg),\n\t\t\tUpdated: defaultPageUpdatedTime,\n\t\t}\n\t}\n\treturn c, nil\n}\n\nfunc defaultLandingBanner(cfg *config.Config) string {\n\tif cfg.App.Federation {\n\t\treturn \"# Start your blog in the fediverse\"\n\t}\n\treturn \"# Start your blog\"\n}\n\nfunc defaultLandingBody(cfg *config.Config) string {\n\tif cfg.App.Federation {\n\t\treturn `## Join the Fediverse\n\nThe fediverse is a large network of platforms that all speak a common language. Imagine if you could reply to Instagram posts from Twitter, or interact with your favorite Medium blogs from Facebook -- federated alternatives like [PixelFed](https://pixelfed.org), [Mastodon](https://joinmastodon.org), and WriteFreely enable you to do these types of things.\n\n<div style=\"text-align:center\">\n\t<iframe style=\"width: 560px; height: 315px; max-width: 100%;\" sandbox=\"allow-same-origin allow-scripts\" src=\"https://video.writeas.org/videos/embed/cc55e615-d204-417c-9575-7b57674cc6f3\" frameborder=\"0\" allowfullscreen></iframe>\n</div>\n\n## Write More Socially\n\nWriteFreely can communicate with other federated platforms like Mastodon, so people can follow your blogs, bookmark their favorite posts, and boost them to their followers. Sign up above to create a blog and join the fediverse.`\n\t}\n\treturn \"\"\n}\n\nfunc getReaderSection(app *App) (*instanceContent, error) {\n\tc, err := app.db.GetDynamicContent(\"reader\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c == nil {\n\t\tc = &instanceContent{\n\t\t\tID:      \"reader\",\n\t\t\tType:    \"section\",\n\t\t\tContent: defaultReaderBanner(app.cfg),\n\t\t\tUpdated: defaultPageUpdatedTime,\n\t\t}\n\t}\n\tif !c.Title.Valid {\n\t\tc.Title = defaultReaderTitle(app.cfg)\n\t}\n\treturn c, nil\n}\n\nfunc defaultReaderTitle(cfg *config.Config) sql.NullString {\n\treturn sql.NullString{String: \"Reader\", Valid: true}\n}\n\nfunc defaultReaderBanner(cfg *config.Config) string {\n\treturn \"Read the latest posts from \" + cfg.App.SiteName + \".\"\n}\n"
        },
        {
          "name": "pages",
          "type": "tree",
          "content": null
        },
        {
          "name": "parse",
          "type": "tree",
          "content": null
        },
        {
          "name": "postrender.go",
          "type": "blob",
          "size": 11.8955078125,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/microcosm-cc/bluemonday\"\n\tstripmd \"github.com/writeas/go-strip-markdown/v2\"\n\t\"github.com/writeas/impart\"\n\tblackfriday \"github.com/writeas/saturday\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writeas/web-core/stringmanip\"\n\t\"github.com/writefreely/writefreely/config\"\n\t\"github.com/writefreely/writefreely/parse\"\n)\n\nvar (\n\tblockReg        = regexp.MustCompile(\"<(ul|ol|blockquote)>\\n\")\n\tendBlockReg     = regexp.MustCompile(\"</([a-z]+)>\\n</(ul|ol|blockquote)>\")\n\tyoutubeReg      = regexp.MustCompile(\"(https?://www.youtube.com/embed/[a-zA-Z0-9\\\\-_]+)(\\\\?[^\\t\\n\\f\\r \\\"']+)?\")\n\ttitleElementReg = regexp.MustCompile(\"</?h[1-6]>\")\n\thashtagReg      = regexp.MustCompile(`{{\\[\\[\\|\\|([^|]+)\\|\\|\\]\\]}}`)\n\tmarkeddownReg   = regexp.MustCompile(\"<p>(.+)</p>\")\n\tmentionReg      = regexp.MustCompile(`@([A-Za-z0-9._%+-]+)(@[A-Za-z0-9.-]+\\.[A-Za-z]+)\\b`)\n)\n\nfunc (p *Post) handlePremiumContent(c *Collection, isOwner, postPage bool, cfg *config.Config) {\n\tif c.Monetization != \"\" {\n\t\t// User has Web Monetization enabled, so split content if it exists\n\t\tspl := strings.Index(p.Content, shortCodePaid)\n\t\tp.IsPaid = spl > -1\n\t\tif postPage {\n\t\t\t// We're viewing the individual post\n\t\t\tif isOwner {\n\t\t\t\tp.Content = strings.Replace(p.Content, shortCodePaid, \"\\n\\n\"+`<p class=\"split\">Your subscriber content begins here.</p>`+\"\\n\\n\", 1)\n\t\t\t} else {\n\t\t\t\tif spl > -1 {\n\t\t\t\t\tp.Content = p.Content[:spl+len(shortCodePaid)]\n\t\t\t\t\tp.Content = strings.Replace(p.Content, shortCodePaid, \"\\n\\n\"+`<p class=\"split\">Continue reading with a <strong>Coil</strong> membership.</p>`+\"\\n\\n\", 1)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// We've viewing the post on the collection landing\n\t\t\tif spl > -1 {\n\t\t\t\tbaseURL := c.CanonicalURL()\n\t\t\t\tif isOwner {\n\t\t\t\t\tbaseURL = \"/\" + c.Alias + \"/\"\n\t\t\t\t}\n\n\t\t\t\tp.Content = p.Content[:spl+len(shortCodePaid)]\n\t\t\t\tp.HTMLExcerpt = template.HTML(applyMarkdown([]byte(p.Content[:spl]), baseURL, cfg))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *Post) formatContent(cfg *config.Config, c *Collection, isOwner bool, isPostPage bool) {\n\tbaseURL := c.CanonicalURL()\n\t// TODO: redundant\n\tif !isSingleUser {\n\t\tbaseURL = \"/\" + c.Alias + \"/\"\n\t}\n\n\tp.handlePremiumContent(c, isOwner, isPostPage, cfg)\n\tp.Content = strings.Replace(p.Content, \"&lt;!--paid-->\", \"<!--paid-->\", 1)\n\n\tp.HTMLTitle = template.HTML(applyBasicMarkdown([]byte(p.Title.String)))\n\tp.HTMLContent = template.HTML(applyMarkdown([]byte(p.Content), baseURL, cfg))\n\tif exc := strings.Index(string(p.Content), \"<!--more-->\"); exc > -1 {\n\t\tp.HTMLExcerpt = template.HTML(applyMarkdown([]byte(p.Content[:exc]), baseURL, cfg))\n\t}\n}\n\nfunc (p *PublicPost) formatContent(cfg *config.Config, isOwner bool, isPostPage bool) {\n\tp.Post.formatContent(cfg, &p.Collection.Collection, isOwner, isPostPage)\n}\n\nfunc (p *Post) augmentContent(c *Collection) {\n\tif p.PinnedPosition.Valid {\n\t\t// Don't augment posts that are pinned\n\t\treturn\n\t}\n\tif strings.Index(p.Content, \"<!--nosig-->\") > -1 {\n\t\t// Don't augment posts with the special \"nosig\" shortcode\n\t\treturn\n\t}\n\t// Add post signatures\n\tif c.Signature != \"\" {\n\t\tp.Content += \"\\n\\n\" + c.Signature\n\t}\n}\n\nfunc (p *PublicPost) augmentContent() {\n\tp.Post.augmentContent(&p.Collection.Collection)\n}\n\nfunc (p *PublicPost) augmentReadingDestination() {\n\tif p.IsPaid {\n\t\tp.HTMLContent += template.HTML(\"\\n\\n\" + `<p><a class=\"read-more\" href=\"` + p.Collection.CanonicalURL() + p.Slug.String + `\">` + localStr(\"Read more...\", p.Language.String) + `</a> ($)</p>`)\n\t}\n}\n\nfunc applyMarkdown(data []byte, baseURL string, cfg *config.Config) string {\n\treturn applyMarkdownSpecial(data, baseURL, cfg, cfg.App.SingleUser)\n}\n\nfunc disableYoutubeAutoplay(outHTML string) string {\n\tfor _, match := range youtubeReg.FindAllString(outHTML, -1) {\n\t\tu, err := url.Parse(match)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tu.RawQuery = html.UnescapeString(u.RawQuery)\n\t\tq := u.Query()\n\t\t// Set Youtube autoplay url parameter, if any, to 0\n\t\tif len(q[\"autoplay\"]) == 1 {\n\t\t\tq.Set(\"autoplay\", \"0\")\n\t\t}\n\t\tu.RawQuery = q.Encode()\n\t\tcleanURL := u.String()\n\t\toutHTML = strings.Replace(outHTML, match, cleanURL, 1)\n\t}\n\treturn outHTML\n}\n\nfunc applyMarkdownSpecial(data []byte, baseURL string, cfg *config.Config, skipNoFollow bool) string {\n\tmdExtensions := 0 |\n\t\tblackfriday.EXTENSION_TABLES |\n\t\tblackfriday.EXTENSION_FENCED_CODE |\n\t\tblackfriday.EXTENSION_AUTOLINK |\n\t\tblackfriday.EXTENSION_STRIKETHROUGH |\n\t\tblackfriday.EXTENSION_SPACE_HEADERS |\n\t\tblackfriday.EXTENSION_AUTO_HEADER_IDS\n\thtmlFlags := 0 |\n\t\tblackfriday.HTML_USE_SMARTYPANTS |\n\t\tblackfriday.HTML_SMARTYPANTS_DASHES\n\n\tif baseURL != \"\" {\n\t\thtmlFlags |= blackfriday.HTML_HASHTAGS\n\t}\n\n\t// Generate Markdown\n\tmd := blackfriday.Markdown([]byte(data), blackfriday.HtmlRenderer(htmlFlags, \"\", \"\"), mdExtensions)\n\tif baseURL != \"\" {\n\t\t// Replace special text generated by Markdown parser\n\t\ttagPrefix := baseURL + \"tag:\"\n\t\tif cfg.App.Chorus {\n\t\t\ttagPrefix = \"/read/t/\"\n\t\t}\n\t\tmd = []byte(hashtagReg.ReplaceAll(md, []byte(\"<a href=\\\"\"+tagPrefix+\"$1\\\" class=\\\"hashtag\\\"><span>#</span><span class=\\\"p-category\\\">$1</span></a>\")))\n\t\thandlePrefix := cfg.App.Host + \"/@/\"\n\t\tmd = []byte(mentionReg.ReplaceAll(md, []byte(\"<a href=\\\"\"+handlePrefix+\"$1$2\\\" class=\\\"u-url mention\\\">@<span>$1$2</span></a>\")))\n\t}\n\t// Strip out bad HTML\n\tpolicy := getSanitizationPolicy()\n\tpolicy.RequireNoFollowOnLinks(!skipNoFollow)\n\toutHTML := string(policy.SanitizeBytes(md))\n\t// Strip newlines on certain block elements that render with them\n\toutHTML = blockReg.ReplaceAllString(outHTML, \"<$1>\")\n\toutHTML = endBlockReg.ReplaceAllString(outHTML, \"</$1></$2>\")\n\toutHTML = disableYoutubeAutoplay(outHTML)\n\treturn outHTML\n}\n\nfunc applyBasicMarkdown(data []byte) string {\n\tif len(bytes.TrimSpace(data)) == 0 {\n\t\treturn \"\"\n\t}\n\n\tmdExtensions := 0 |\n\t\tblackfriday.EXTENSION_STRIKETHROUGH |\n\t\tblackfriday.EXTENSION_SPACE_HEADERS |\n\t\tblackfriday.EXTENSION_HEADER_IDS\n\thtmlFlags := 0 |\n\t\tblackfriday.HTML_SKIP_HTML |\n\t\tblackfriday.HTML_USE_SMARTYPANTS |\n\t\tblackfriday.HTML_SMARTYPANTS_DASHES\n\n\t// Generate Markdown\n\t// This passes the supplied title into blackfriday.Markdown() as an H1 header, so we only render HTML that\n\t// belongs in an H1.\n\tmd := blackfriday.Markdown(append([]byte(\"# \"), data...), blackfriday.HtmlRenderer(htmlFlags, \"\", \"\"), mdExtensions)\n\t// Remove H1 markup\n\tmd = bytes.TrimSpace(md) // blackfriday.Markdown adds a newline at the end of the <h1>\n\tif len(md) == 0 {\n\t\treturn \"\"\n\t}\n\tmd = md[len(\"<h1>\") : len(md)-len(\"</h1>\")]\n\t// Strip out bad HTML\n\tpolicy := bluemonday.UGCPolicy()\n\tpolicy.AllowAttrs(\"class\", \"id\").Globally()\n\toutHTML := string(policy.SanitizeBytes(md))\n\toutHTML = markeddownReg.ReplaceAllString(outHTML, \"$1\")\n\toutHTML = strings.TrimRightFunc(outHTML, unicode.IsSpace)\n\n\treturn outHTML\n}\n\nfunc postTitle(content, friendlyId string) string {\n\tconst maxTitleLen = 80\n\n\tcontent = stripHTMLWithoutEscaping(content)\n\n\tcontent = strings.TrimLeftFunc(stripmd.Strip(content), unicode.IsSpace)\n\teol := strings.IndexRune(content, '\\n')\n\tblankLine := strings.Index(content, \"\\n\\n\")\n\tif blankLine != -1 && blankLine <= eol && blankLine <= assumedTitleLen {\n\t\treturn strings.TrimSpace(content[:blankLine])\n\t} else if utf8.RuneCountInString(content) <= maxTitleLen {\n\t\treturn content\n\t}\n\treturn friendlyId\n}\n\n// TODO: fix duplicated code from postTitle. postTitle is a widely used func we\n// don't have time to investigate right now.\nfunc friendlyPostTitle(content, friendlyId string) string {\n\tconst maxTitleLen = 80\n\n\tcontent = stripHTMLWithoutEscaping(content)\n\n\tcontent = strings.TrimLeftFunc(stripmd.Strip(content), unicode.IsSpace)\n\teol := strings.IndexRune(content, '\\n')\n\tblankLine := strings.Index(content, \"\\n\\n\")\n\tif blankLine != -1 && blankLine <= eol && blankLine <= assumedTitleLen {\n\t\treturn strings.TrimSpace(content[:blankLine])\n\t} else if eol == -1 && utf8.RuneCountInString(content) <= maxTitleLen {\n\t\treturn content\n\t}\n\ttitle, truncd := parse.TruncToWord(parse.PostLede(content, true), maxTitleLen)\n\tif truncd {\n\t\ttitle += \"...\"\n\t}\n\treturn title\n}\n\n// Strip HTML tags with bluemonday's StrictPolicy, then unescape the HTML\n// entities added in by sanitizing the content.\nfunc stripHTMLWithoutEscaping(content string) string {\n\treturn html.UnescapeString(bluemonday.StrictPolicy().Sanitize(content))\n}\n\nfunc getSanitizationPolicy() *bluemonday.Policy {\n\tpolicy := bluemonday.UGCPolicy()\n\tpolicy.AllowAttrs(\"src\", \"style\").OnElements(\"iframe\", \"video\", \"audio\")\n\tpolicy.AllowAttrs(\"src\", \"type\").OnElements(\"source\")\n\tpolicy.AllowAttrs(\"frameborder\", \"width\", \"height\").Matching(bluemonday.Integer).OnElements(\"iframe\")\n\tpolicy.AllowAttrs(\"allowfullscreen\").OnElements(\"iframe\")\n\tpolicy.AllowAttrs(\"controls\", \"loop\", \"muted\", \"autoplay\").OnElements(\"video\")\n\tpolicy.AllowAttrs(\"controls\", \"loop\", \"muted\", \"autoplay\", \"preload\").OnElements(\"audio\")\n\tpolicy.AllowAttrs(\"target\").OnElements(\"a\")\n\tpolicy.AllowAttrs(\"title\").OnElements(\"abbr\")\n\tpolicy.AllowAttrs(\"style\", \"class\", \"id\").Globally()\n\tpolicy.AllowAttrs(\"alt\").OnElements(\"img\")\n\tpolicy.AllowElements(\"header\", \"footer\")\n\tpolicy.AllowURLSchemes(\"http\", \"https\", \"mailto\", \"xmpp\")\n\treturn policy\n}\n\nfunc sanitizePost(content string) string {\n\treturn strings.Replace(content, \"<\", \"&lt;\", -1)\n}\n\n// postDescription generates a description based on the given post content,\n// title, and post ID. This doesn't consider a V2 post field, `title` when\n// choosing what to generate. In case a post has a title, this function will\n// fail, and logic should instead be implemented to skip this when there's no\n// title, like so:\n//\n//\tvar desc string\n//\tif title == \"\" {\n//\t    desc = postDescription(content, title, friendlyId)\n//\t} else {\n//\t    desc = shortPostDescription(content)\n//\t}\nfunc postDescription(content, title, friendlyId string) string {\n\tmaxLen := 140\n\n\tif content == \"\" {\n\t\tcontent = \"WriteFreely is a painless, simple, federated blogging platform.\"\n\t} else {\n\t\tfmtStr := \"%s\"\n\t\ttruncation := 0\n\t\tif utf8.RuneCountInString(content) > maxLen {\n\t\t\t// Post is longer than the max description, so let's show a better description\n\t\t\tfmtStr = \"%s...\"\n\t\t\ttruncation = 3\n\t\t}\n\n\t\tif title == friendlyId {\n\t\t\t// No specific title was found; simply truncate the post, starting at the beginning\n\t\t\tcontent = fmt.Sprintf(fmtStr, strings.Replace(stringmanip.Substring(content, 0, maxLen-truncation), \"\\n\", \" \", -1))\n\t\t} else {\n\t\t\t// There was a title, so return a real description\n\t\t\tblankLine := strings.Index(content, \"\\n\\n\")\n\t\t\tif blankLine < 0 {\n\t\t\t\tblankLine = 0\n\t\t\t}\n\t\t\ttruncd := stringmanip.Substring(content, blankLine, blankLine+maxLen-truncation)\n\t\t\tcontentNoNL := strings.Replace(truncd, \"\\n\", \" \", -1)\n\t\t\tcontent = strings.TrimSpace(fmt.Sprintf(fmtStr, contentNoNL))\n\t\t}\n\t}\n\n\treturn content\n}\n\nfunc shortPostDescription(content string) string {\n\tmaxLen := 140\n\tfmtStr := \"%s\"\n\ttruncation := 0\n\tif utf8.RuneCountInString(content) > maxLen {\n\t\t// Post is longer than the max description, so let's show a better description\n\t\tfmtStr = \"%s...\"\n\t\ttruncation = 3\n\t}\n\treturn strings.TrimSpace(fmt.Sprintf(fmtStr, strings.Replace(stringmanip.Substring(content, 0, maxLen-truncation), \"\\n\", \" \", -1)))\n}\n\nfunc handleRenderMarkdown(app *App, w http.ResponseWriter, r *http.Request) error {\n\tif !IsJSON(r) {\n\t\treturn impart.HTTPError{Status: http.StatusUnsupportedMediaType, Message: \"Markdown API only supports JSON requests\"}\n\t}\n\n\tin := struct {\n\t\tCollectionURL string `json:\"collection_url\"`\n\t\tRawBody       string `json:\"raw_body\"`\n\t}{}\n\n\tdecoder := json.NewDecoder(r.Body)\n\terr := decoder.Decode(&in)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't parse markdown JSON request: %v\", err)\n\t\treturn ErrBadJSON\n\t}\n\n\tout := struct {\n\t\tBody string `json:\"body\"`\n\t}{\n\t\tBody: applyMarkdown([]byte(in.RawBody), in.CollectionURL, app.cfg),\n\t}\n\n\treturn impart.WriteSuccess(w, out, http.StatusOK)\n}\n"
        },
        {
          "name": "postrender_test.go",
          "type": "blob",
          "size": 1.203125,
          "content": "/*\n * Copyright © 2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport \"testing\"\n\nfunc TestApplyBasicMarkdown(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tin     string\n\t\tresult string\n\t}{\n\t\t{\"empty\", \"\", \"\"},\n\t\t{\"empty spaces\", \"  \", \"\"},\n\t\t{\"empty tabs\", \"\\t\", \"\"},\n\t\t{\"empty newline\", \"\\n\", \"\"},\n\t\t{\"nums\", \"123\", \"123\"},\n\t\t{\"dot\", \".\", \".\"},\n\t\t{\"dash\", \"-\", \"-\"},\n\t\t{\"plain\", \"Hello, World!\", \"Hello, World!\"},\n\t\t{\"multibyte\", \"こんにちは\", `こんにちは`},\n\t\t{\"bold\", \"**안녕하세요**\", `<strong>안녕하세요</strong>`},\n\t\t{\"link\", \"[WriteFreely](https://writefreely.org)\", `<a href=\"https://writefreely.org\" rel=\"nofollow\">WriteFreely</a>`},\n\t\t{\"date\", \"12. April\", `12. April`},\n\t\t{\"table\", \"| Hi | There |\", `| Hi | There |`},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tres := applyBasicMarkdown([]byte(test.in))\n\t\t\tif res != test.result {\n\t\t\t\tt.Errorf(\"%s: wanted %s, got %s\", test.name, test.result, res)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "posts.go",
          "type": "blob",
          "size": 45.154296875,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/writefreely/writefreely/spam\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gosimple/slug\"\n\t\"github.com/guregu/null\"\n\t\"github.com/guregu/null/zero\"\n\t\"github.com/kylemcc/twitter-text-go/extract\"\n\t\"github.com/microcosm-cc/bluemonday\"\n\tstripmd \"github.com/writeas/go-strip-markdown/v2\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/monday\"\n\t\"github.com/writeas/web-core/activitystreams\"\n\t\"github.com/writeas/web-core/bots\"\n\t\"github.com/writeas/web-core/converter\"\n\t\"github.com/writeas/web-core/i18n\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writeas/web-core/tags\"\n\t\"github.com/writefreely/writefreely/page\"\n\t\"github.com/writefreely/writefreely/parse\"\n)\n\nconst (\n\t// Post ID length bounds\n\tminIDLen      = 10\n\tmaxIDLen      = 10\n\tuserPostIDLen = 10\n\tpostIDLen     = 10\n\n\tpostMetaDateFormat = \"2006-01-02 15:04:05\"\n\n\tshortCodePaid = \"<!--paid-->\"\n)\n\ntype (\n\tAnonymousPost struct {\n\t\tID          string\n\t\tContent     string\n\t\tHTMLContent template.HTML\n\t\tFont        string\n\t\tLanguage    string\n\t\tDirection   string\n\t\tTitle       string\n\t\tGenTitle    string\n\t\tDescription string\n\t\tAuthor      string\n\t\tViews       int64\n\t\tImages      []string\n\t\tIsPlainText bool\n\t\tIsCode      bool\n\t\tIsLinkable  bool\n\t}\n\n\tAuthenticatedPost struct {\n\t\tID  string `json:\"id\" schema:\"id\"`\n\t\tWeb bool   `json:\"web\" schema:\"web\"`\n\t\t*SubmittedPost\n\t}\n\n\t// SubmittedPost represents a post supplied by a client for publishing or\n\t// updating. Since Title and Content can be updated to \"\", they are\n\t// pointers that can be easily tested to detect changes.\n\tSubmittedPost struct {\n\t\tSlug     *string                  `json:\"slug\" schema:\"slug\"`\n\t\tTitle    *string                  `json:\"title\" schema:\"title\"`\n\t\tContent  *string                  `json:\"body\" schema:\"body\"`\n\t\tFont     string                   `json:\"font\" schema:\"font\"`\n\t\tIsRTL    converter.NullJSONBool   `json:\"rtl\" schema:\"rtl\"`\n\t\tLanguage converter.NullJSONString `json:\"lang\" schema:\"lang\"`\n\t\tCreated  *string                  `json:\"created\" schema:\"created\"`\n\t}\n\n\t// Post represents a post as found in the database.\n\tPost struct {\n\t\tID             string        `db:\"id\" json:\"id\"`\n\t\tSlug           null.String   `db:\"slug\" json:\"slug,omitempty\"`\n\t\tFont           string        `db:\"text_appearance\" json:\"appearance\"`\n\t\tLanguage       zero.String   `db:\"language\" json:\"language\"`\n\t\tRTL            zero.Bool     `db:\"rtl\" json:\"rtl\"`\n\t\tPrivacy        int64         `db:\"privacy\" json:\"-\"`\n\t\tOwnerID        null.Int      `db:\"owner_id\" json:\"-\"`\n\t\tCollectionID   null.Int      `db:\"collection_id\" json:\"-\"`\n\t\tPinnedPosition null.Int      `db:\"pinned_position\" json:\"-\"`\n\t\tCreated        time.Time     `db:\"created\" json:\"created\"`\n\t\tUpdated        time.Time     `db:\"updated\" json:\"updated\"`\n\t\tViewCount      int64         `db:\"view_count\" json:\"-\"`\n\t\tLikeCount      int64         `db:\"like_count\" json:\"likes\"`\n\t\tTitle          zero.String   `db:\"title\" json:\"title\"`\n\t\tHTMLTitle      template.HTML `db:\"title\" json:\"-\"`\n\t\tContent        string        `db:\"content\" json:\"body\"`\n\t\tHTMLContent    template.HTML `db:\"content\" json:\"-\"`\n\t\tHTMLExcerpt    template.HTML `db:\"content\" json:\"-\"`\n\t\tTags           []string      `json:\"tags\"`\n\t\tImages         []string      `json:\"images,omitempty\"`\n\t\tIsPaid         bool          `json:\"paid\"`\n\n\t\tOwnerName string `json:\"owner,omitempty\"`\n\t}\n\n\t// PublicPost holds properties for a publicly returned post, i.e. a post in\n\t// a context where the viewer may not be the owner. As such, sensitive\n\t// metadata for the post is hidden and properties supporting the display of\n\t// the post are added.\n\tPublicPost struct {\n\t\t*Post\n\t\tIsSubdomain bool           `json:\"-\"`\n\t\tIsTopLevel  bool           `json:\"-\"`\n\t\tDisplayDate string         `json:\"-\"`\n\t\tViews       int64          `json:\"views\"`\n\t\tLikes       int64          `json:\"likes\"`\n\t\tOwner       *PublicUser    `json:\"-\"`\n\t\tIsOwner     bool           `json:\"-\"`\n\t\tURL         string         `json:\"url,omitempty\"`\n\t\tCollection  *CollectionObj `json:\"collection,omitempty\"`\n\t}\n\n\tCollectionPostPage struct {\n\t\t*PublicPost\n\t\tpage.StaticPage\n\t\tIsOwner        bool\n\t\tIsPinned       bool\n\t\tIsCustomDomain bool\n\t\tMonetization   string\n\t\tVerification   string\n\t\tPinnedPosts    *[]PublicPost\n\t\tIsFound        bool\n\t\tIsAdmin        bool\n\t\tCanInvite      bool\n\t\tSilenced       bool\n\n\t\t// Helper field for Chorus mode\n\t\tCollAlias string\n\t}\n\n\tRawPost struct {\n\t\tId, Slug     string\n\t\tTitle        string\n\t\tContent      string\n\t\tViews        int64\n\t\tFont         string\n\t\tCreated      time.Time\n\t\tUpdated      time.Time\n\t\tIsRTL        sql.NullBool\n\t\tLanguage     sql.NullString\n\t\tOwnerID      int64\n\t\tCollectionID sql.NullInt64\n\n\t\tFound bool\n\t\tGone  bool\n\t}\n\n\tAnonymousAuthPost struct {\n\t\tID    string `json:\"id\"`\n\t\tToken string `json:\"token\"`\n\t}\n\tClaimPostRequest struct {\n\t\t*AnonymousAuthPost\n\t\tCollectionAlias  string `json:\"collection\"`\n\t\tCreateCollection bool   `json:\"create_collection\"`\n\n\t\t// Generated properties\n\t\tSlug string `json:\"-\"`\n\t}\n\tClaimPostResult struct {\n\t\tID           string      `json:\"id,omitempty\"`\n\t\tCode         int         `json:\"code,omitempty\"`\n\t\tErrorMessage string      `json:\"error_msg,omitempty\"`\n\t\tPost         *PublicPost `json:\"post,omitempty\"`\n\t}\n)\n\nfunc (p *Post) Direction() string {\n\tif p.RTL.Valid {\n\t\tif p.RTL.Bool {\n\t\t\treturn \"rtl\"\n\t\t}\n\t\treturn \"ltr\"\n\t}\n\treturn \"auto\"\n}\n\n// DisplayTitle dynamically generates a title from the Post's contents if it\n// doesn't already have an explicit title.\nfunc (p *Post) DisplayTitle() string {\n\tif p.Title.String != \"\" {\n\t\treturn p.Title.String\n\t}\n\tt := friendlyPostTitle(p.Content, p.ID)\n\treturn t\n}\n\n// PlainDisplayTitle dynamically generates a title from the Post's contents if it\n// doesn't already have an explicit title.\nfunc (p *Post) PlainDisplayTitle() string {\n\tif t := stripmd.Strip(p.DisplayTitle()); t != \"\" {\n\t\treturn t\n\t}\n\treturn p.ID\n}\n\n// FormattedDisplayTitle dynamically generates a title from the Post's contents if it\n// doesn't already have an explicit title.\nfunc (p *Post) FormattedDisplayTitle() template.HTML {\n\tif p.HTMLTitle != \"\" {\n\t\treturn p.HTMLTitle\n\t}\n\treturn template.HTML(p.DisplayTitle())\n}\n\n// Summary gives a shortened summary of the post based on the post's title,\n// especially for display in a longer list of posts. It extracts a summary for\n// posts in the Title\\n\\nBody format, returning nothing if the entire was short\n// enough that the extracted title == extracted summary.\nfunc (p Post) Summary() string {\n\tif p.Content == \"\" {\n\t\treturn \"\"\n\t}\n\tp.Content = stripHTMLWithoutEscaping(p.Content)\n\t// and Markdown\n\tp.Content = stripmd.StripOptions(p.Content, stripmd.Options{SkipImages: true})\n\n\ttitle := p.Title.String\n\tvar desc string\n\tif title == \"\" {\n\t\t// No title, so generate one\n\t\ttitle = friendlyPostTitle(p.Content, p.ID)\n\t\tdesc = postDescription(p.Content, title, p.ID)\n\t\tif desc == title {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn desc\n\t}\n\n\treturn shortPostDescription(p.Content)\n}\n\nfunc (p Post) SummaryHTML() template.HTML {\n\treturn template.HTML(p.Summary())\n}\n\n// Excerpt shows any text that comes before a (more) tag.\n// TODO: use HTMLExcerpt in templates instead of this method\nfunc (p *Post) Excerpt() template.HTML {\n\treturn p.HTMLExcerpt\n}\n\nfunc (p *Post) CreatedDate() string {\n\treturn p.Created.Format(\"2006-01-02\")\n}\n\nfunc (p *Post) Created8601() string {\n\treturn p.Created.Format(\"2006-01-02T15:04:05Z\")\n}\n\nfunc (p *Post) IsScheduled() bool {\n\treturn p.Created.After(time.Now())\n}\n\nfunc (p *Post) HasTag(tag string) bool {\n\t// Regexp looks for tag and has a non-capturing group at the end looking\n\t// for the end of the word.\n\t// Assisted by: https://stackoverflow.com/a/35192941/1549194\n\thasTag, _ := regexp.MatchString(\"#\"+tag+`(?:[[:punct:]]|\\s|\\z)`, p.Content)\n\treturn hasTag\n}\n\nfunc (p *Post) HasTitleLink() bool {\n\tif p.Title.String == \"\" {\n\t\treturn false\n\t}\n\thasLink, _ := regexp.MatchString(`([^!]+|^)\\[.+\\]\\(.+\\)`, p.Title.String)\n\treturn hasLink\n}\n\nfunc (c CollectionPostPage) DisplayMonetization() string {\n\tif c.Collection == nil {\n\t\tlog.Info(\"CollectionPostPage.DisplayMonetization: c.Collection is nil\")\n\t\treturn \"\"\n\t}\n\treturn displayMonetization(c.Monetization, c.Collection.Alias)\n}\n\nfunc handleViewPost(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tfriendlyID := vars[\"post\"]\n\n\t// NOTE: until this is done better, be sure to keep this in parity with\n\t// isRaw() and viewCollectionPost()\n\tisJSON := strings.HasSuffix(friendlyID, \".json\")\n\tisXML := strings.HasSuffix(friendlyID, \".xml\")\n\tisCSS := strings.HasSuffix(friendlyID, \".css\")\n\tisMarkdown := strings.HasSuffix(friendlyID, \".md\")\n\tisRaw := strings.HasSuffix(friendlyID, \".txt\") || isJSON || isXML || isCSS || isMarkdown\n\n\t// Display reserved page if that is requested resource\n\tif t, ok := pages[r.URL.Path[1:]+\".tmpl\"]; ok {\n\t\treturn handleTemplatedPage(app, w, r, t)\n\t} else if r.URL.Path == \"/sitemap.xml\" && !app.cfg.App.SingleUser {\n\t\treturn impart.HTTPError{Status: http.StatusNotFound, Message: \"Page not found.\"}\n\t} else if (strings.Contains(r.URL.Path, \".\") && !isRaw && !isMarkdown) || r.URL.Path == \"/robots.txt\" || r.URL.Path == \"/manifest.json\" {\n\t\t// Serve static file\n\t\tapp.shttp.ServeHTTP(w, r)\n\t\treturn nil\n\t}\n\n\t// Display collection if this is a collection\n\tc, _ := app.db.GetCollection(friendlyID)\n\tif c != nil {\n\t\treturn impart.HTTPError{http.StatusMovedPermanently, fmt.Sprintf(\"/%s/\", friendlyID)}\n\t}\n\n\t// Normalize the URL, redirecting user to consistent post URL\n\tif friendlyID != strings.ToLower(friendlyID) {\n\t\treturn impart.HTTPError{http.StatusMovedPermanently, fmt.Sprintf(\"/%s\", strings.ToLower(friendlyID))}\n\t}\n\n\text := \"\"\n\tif isRaw {\n\t\tparts := strings.Split(friendlyID, \".\")\n\t\tfriendlyID = parts[0]\n\t\tif len(parts) > 1 {\n\t\t\text = \".\" + parts[1]\n\t\t}\n\t}\n\n\tvar ownerID sql.NullInt64\n\tvar collectionID sql.NullInt64\n\tvar title string\n\tvar content string\n\tvar font string\n\tvar language []byte\n\tvar rtl []byte\n\tvar views int64\n\tvar post *AnonymousPost\n\tvar found bool\n\tvar gone bool\n\n\tfixedID := slug.Make(friendlyID)\n\tif fixedID != friendlyID {\n\t\treturn impart.HTTPError{http.StatusFound, fmt.Sprintf(\"/%s%s\", fixedID, ext)}\n\t}\n\n\terr := app.db.QueryRow(\"SELECT owner_id, collection_id, title, content, text_appearance, view_count, language, rtl FROM posts WHERE id = ?\", friendlyID).Scan(&ownerID, &collectionID, &title, &content, &font, &views, &language, &rtl)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\tfound = false\n\n\t\t// Output the error in the correct format\n\t\tif isJSON {\n\t\t\tcontent = \"{\\\"error\\\": \\\"Post not found.\\\"}\"\n\t\t} else if isRaw {\n\t\t\tcontent = \"Post not found.\"\n\t\t} else {\n\t\t\treturn ErrPostNotFound\n\t\t}\n\tcase err != nil:\n\t\tfound = false\n\n\t\tlog.Error(\"Post loading err: %s\\n\", err)\n\t\treturn ErrInternalGeneral\n\tdefault:\n\t\tfound = true\n\n\t\tvar d string\n\t\tif len(rtl) == 0 {\n\t\t\td = \"auto\"\n\t\t} else if rtl[0] == 49 {\n\t\t\t// TODO: find a cleaner way to get this (possibly NULL) value\n\t\t\td = \"rtl\"\n\t\t} else {\n\t\t\td = \"ltr\"\n\t\t}\n\t\tgeneratedTitle := friendlyPostTitle(content, friendlyID)\n\t\tsanitizedContent := content\n\t\tif font != \"code\" {\n\t\t\tsanitizedContent = template.HTMLEscapeString(content)\n\t\t}\n\t\tvar desc string\n\t\tif title == \"\" {\n\t\t\tdesc = postDescription(content, title, friendlyID)\n\t\t} else {\n\t\t\tdesc = shortPostDescription(content)\n\t\t}\n\t\tpost = &AnonymousPost{\n\t\t\tID:          friendlyID,\n\t\t\tContent:     sanitizedContent,\n\t\t\tTitle:       title,\n\t\t\tGenTitle:    generatedTitle,\n\t\t\tDescription: desc,\n\t\t\tAuthor:      \"\",\n\t\t\tFont:        font,\n\t\t\tIsPlainText: isRaw,\n\t\t\tIsCode:      font == \"code\",\n\t\t\tIsLinkable:  font != \"code\",\n\t\t\tViews:       views,\n\t\t\tLanguage:    string(language),\n\t\t\tDirection:   d,\n\t\t}\n\t\tif !isRaw {\n\t\t\tpost.HTMLContent = template.HTML(applyMarkdown([]byte(content), \"\", app.cfg))\n\t\t\tpost.Images = extractImages(post.Content)\n\t\t}\n\t}\n\n\tvar silenced bool\n\tif found {\n\t\tsilenced, err = app.db.IsUserSilenced(ownerID.Int64)\n\t\tif err != nil {\n\t\t\tlog.Error(\"view post: %v\", err)\n\t\t}\n\t}\n\n\tvar protectDraft bool\n\tif found && collectionID.Valid {\n\t\tcollection, err := app.db.GetCollectionByID(collectionID.Int64)\n\t\tif err != nil {\n\t\t\tlog.Error(\"view post: %v\", err)\n\t\t}\n\n\t\tprotectDraft = collection.IsPrivate() || collection.IsProtected()\n\t}\n\n\t// Check if post has been unpublished\n\tif title == \"\" && content == \"\" {\n\t\tgone = true\n\n\t\tif isJSON {\n\t\t\tcontent = \"{\\\"error\\\": \\\"Post was unpublished.\\\"}\"\n\t\t} else if isCSS {\n\t\t\tcontent = \"\"\n\t\t} else if isRaw {\n\t\t\tcontent = \"Post was unpublished.\"\n\t\t} else {\n\t\t\treturn ErrPostUnpublished\n\t\t}\n\t}\n\n\tvar u = &User{}\n\tif isRaw {\n\t\tcontentType := \"text/plain\"\n\t\tif isJSON {\n\t\t\tcontentType = \"application/json\"\n\t\t} else if isCSS {\n\t\t\tcontentType = \"text/css\"\n\t\t} else if isXML {\n\t\t\tcontentType = \"application/xml\"\n\t\t} else if isMarkdown {\n\t\t\tcontentType = \"text/markdown\"\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", fmt.Sprintf(\"%s; charset=utf-8\", contentType))\n\t\tif isMarkdown && post.Title != \"\" {\n\t\t\tfmt.Fprintf(w, \"%s\\n\", post.Title)\n\t\t\tfor i := 1; i <= len(post.Title); i++ {\n\t\t\t\tfmt.Fprintf(w, \"=\")\n\t\t\t}\n\t\t\tfmt.Fprintf(w, \"\\n\\n\")\n\t\t}\n\t\tfmt.Fprint(w, content)\n\n\t\tif !found {\n\t\t\treturn ErrPostNotFound\n\t\t} else if gone {\n\t\t\treturn ErrPostUnpublished\n\t\t}\n\t} else {\n\t\tvar err error\n\t\tpage := struct {\n\t\t\t*AnonymousPost\n\t\t\tpage.StaticPage\n\t\t\tUsername string\n\t\t\tIsOwner  bool\n\t\t\tSiteURL  string\n\t\t\tSilenced bool\n\t\t}{\n\t\t\tAnonymousPost: post,\n\t\t\tStaticPage:    pageForReq(app, r),\n\t\t\tSiteURL:       app.cfg.App.Host,\n\t\t}\n\t\tif u = getUserSession(app, r); u != nil {\n\t\t\tpage.Username = u.Username\n\t\t\tpage.IsOwner = ownerID.Valid && ownerID.Int64 == u.ID\n\t\t}\n\n\t\tif !page.IsOwner && silenced {\n\t\t\treturn ErrPostNotFound\n\t\t}\n\n\t\tif !page.IsOwner && protectDraft {\n\t\t\treturn ErrPostNotFound\n\t\t}\n\t\tpage.Silenced = silenced\n\t\terr = templates[\"post\"].ExecuteTemplate(w, \"post\", page)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Post template execute error: %v\", err)\n\t\t}\n\t}\n\n\tgo func() {\n\t\tif u != nil && ownerID.Valid && ownerID.Int64 == u.ID {\n\t\t\t// Post is owned by someone; skip view increment since that person is viewing this post.\n\t\t\treturn\n\t\t}\n\t\t// Update stats for non-raw post views\n\t\tif !isRaw && r.Method != \"HEAD\" && !bots.IsBot(r.UserAgent()) {\n\t\t\t_, err := app.db.Exec(\"UPDATE posts SET view_count = view_count + 1 WHERE id = ?\", friendlyID)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Unable to update posts count: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\n// API v2 funcs\n// newPost creates a new post with or without an owning Collection.\n//\n// Endpoints:\n//   - /posts\n//   - /posts?collection={alias}\n//   - ? /collections/{alias}/posts\nfunc newPost(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\tvars := mux.Vars(r)\n\tcollAlias := vars[\"alias\"]\n\tif collAlias == \"\" {\n\t\tcollAlias = r.FormValue(\"collection\")\n\t}\n\taccessToken := r.Header.Get(\"Authorization\")\n\tif accessToken == \"\" {\n\t\t// TODO: remove this\n\t\taccessToken = r.FormValue(\"access_token\")\n\t}\n\n\t// FIXME: determine web submission with Content-Type header\n\tvar u *User\n\tvar userID int64 = -1\n\tvar username string\n\tif accessToken == \"\" {\n\t\tu = getUserSession(app, r)\n\t\tif u != nil {\n\t\t\tuserID = u.ID\n\t\t\tusername = u.Username\n\t\t}\n\t} else {\n\t\tuserID = app.db.GetUserID(accessToken)\n\t}\n\tsilenced, err := app.db.IsUserSilenced(userID)\n\tif err != nil {\n\t\tlog.Error(\"new post: %v\", err)\n\t}\n\tif silenced {\n\t\treturn ErrUserSilenced\n\t}\n\n\tif userID == -1 {\n\t\treturn ErrNotLoggedIn\n\t}\n\n\tif accessToken == \"\" && u == nil && collAlias != \"\" {\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"Parameter `access_token` required.\"}\n\t}\n\n\t// Get post data\n\tvar p *SubmittedPost\n\tif reqJSON {\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr = decoder.Decode(&p)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse new post JSON request: %v\\n\", err)\n\t\t\treturn ErrBadJSON\n\t\t}\n\t\tif p.Title == nil {\n\t\t\tt := \"\"\n\t\t\tp.Title = &t\n\t\t}\n\t\tif strings.TrimSpace(*(p.Title)) == \"\" && (p.Content == nil || strings.TrimSpace(*(p.Content)) == \"\") {\n\t\t\treturn ErrNoPublishableContent\n\t\t}\n\t\tif p.Content == nil {\n\t\t\tc := \"\"\n\t\t\tp.Content = &c\n\t\t}\n\n\t} else {\n\t\tpost := r.FormValue(\"body\")\n\t\tappearance := r.FormValue(\"font\")\n\t\ttitle := r.FormValue(\"title\")\n\t\trtlValue := r.FormValue(\"rtl\")\n\t\tlangValue := r.FormValue(\"lang\")\n\t\tif strings.TrimSpace(post) == \"\" {\n\t\t\treturn ErrNoPublishableContent\n\t\t}\n\n\t\tvar isRTL, rtlValid bool\n\t\tif rtlValue == \"auto\" && langValue != \"\" {\n\t\t\tisRTL = i18n.LangIsRTL(langValue)\n\t\t\trtlValid = true\n\t\t} else {\n\t\t\tisRTL = rtlValue == \"true\"\n\t\t\trtlValid = rtlValue != \"\" && langValue != \"\"\n\t\t}\n\n\t\t// Create a new post\n\t\tp = &SubmittedPost{\n\t\t\tTitle:    &title,\n\t\t\tContent:  &post,\n\t\t\tFont:     appearance,\n\t\t\tIsRTL:    converter.NullJSONBool{sql.NullBool{Bool: isRTL, Valid: rtlValid}},\n\t\t\tLanguage: converter.NullJSONString{sql.NullString{String: langValue, Valid: langValue != \"\"}},\n\t\t}\n\t}\n\tif !p.isFontValid() {\n\t\tp.Font = \"norm\"\n\t}\n\n\tvar newPost *PublicPost = &PublicPost{}\n\tvar coll *Collection\n\tif accessToken != \"\" {\n\t\tnewPost, err = app.db.CreateOwnedPost(p, accessToken, collAlias, app.cfg.App.Host)\n\t} else {\n\t\t//return ErrNotLoggedIn\n\t\t// TODO: verify user is logged in\n\t\tvar collID int64\n\t\tif collAlias != \"\" {\n\t\t\tcoll, err = app.db.GetCollection(collAlias)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcoll.hostName = app.cfg.App.Host\n\t\t\tif coll.OwnerID != u.ID {\n\t\t\t\treturn ErrForbiddenCollection\n\t\t\t}\n\t\t\tcollID = coll.ID\n\t\t}\n\t\t// TODO: return PublicPost from createPost\n\t\tnewPost.Post, err = app.db.CreatePost(userID, collID, p)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tif coll != nil {\n\t\tcoll.ForPublic()\n\t\tnewPost.Collection = &CollectionObj{Collection: *coll}\n\t}\n\n\tnewPost.extractData()\n\tnewPost.OwnerName = username\n\tnewPost.URL = newPost.CanonicalURL(app.cfg.App.Host)\n\n\t// Write success now\n\tresponse := impart.WriteSuccess(w, newPost, http.StatusCreated)\n\n\tif newPost.Collection != nil {\n\t\tif !app.cfg.App.Private && app.cfg.App.Federation && !newPost.Created.After(time.Now()) {\n\t\t\tgo federatePost(app, newPost, newPost.Collection.ID, false)\n\t\t}\n\t\tif app.cfg.Email.Enabled() && newPost.Collection.EmailSubsEnabled() {\n\t\t\tgo app.db.InsertJob(&PostJob{\n\t\t\t\tPostID: newPost.ID,\n\t\t\t\tAction: \"email\",\n\t\t\t\tDelay:  emailSendDelay,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn response\n}\n\nfunc existingPost(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\tvars := mux.Vars(r)\n\tpostID := vars[\"post\"]\n\n\tp := AuthenticatedPost{ID: postID}\n\tvar err error\n\n\tif reqJSON {\n\t\t// Decode JSON request\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr = decoder.Decode(&p)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse post update JSON request: %v\\n\", err)\n\t\t\treturn ErrBadJSON\n\t\t}\n\t} else {\n\t\terr = r.ParseForm()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse post update form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\n\t\t// Can't decode to a nil SubmittedPost property, so create instance now\n\t\tp.SubmittedPost = &SubmittedPost{}\n\t\terr = app.formDecoder.Decode(&p, r.PostForm)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't decode post update form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\t}\n\n\tif p.Web {\n\t\tp.IsRTL.Valid = true\n\t}\n\n\tif p.SubmittedPost == nil {\n\t\treturn ErrPostNoUpdatableVals\n\t}\n\n\t// Ensure an access token was given\n\taccessToken := r.Header.Get(\"Authorization\")\n\t// Get user's cookie session if there's no token\n\tvar u *User\n\t//var username string\n\tif accessToken == \"\" {\n\t\tu = getUserSession(app, r)\n\t\tif u != nil {\n\t\t\t//username = u.Username\n\t\t}\n\t}\n\tif u == nil && accessToken == \"\" {\n\t\treturn ErrNoAccessToken\n\t}\n\n\t// Get user ID from current session or given access token, if one was given.\n\tvar userID int64\n\tif u != nil {\n\t\tuserID = u.ID\n\t} else if accessToken != \"\" {\n\t\tuserID, err = AuthenticateUser(app.db, accessToken)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tsilenced, err := app.db.IsUserSilenced(userID)\n\tif err != nil {\n\t\tlog.Error(\"existing post: %v\", err)\n\t}\n\tif silenced {\n\t\treturn ErrUserSilenced\n\t}\n\n\t// Modify post struct\n\tp.ID = postID\n\n\terr = app.db.UpdateOwnedPost(&p, userID)\n\tif err != nil {\n\t\tif reqJSON {\n\t\t\treturn err\n\t\t}\n\n\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\taddSessionFlash(app, w, r, err.Message, nil)\n\t\t} else {\n\t\t\taddSessionFlash(app, w, r, err.Error(), nil)\n\t\t}\n\t}\n\n\tvar pRes *PublicPost\n\tpRes, err = app.db.GetPost(p.ID, 0)\n\tif reqJSON {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpRes.extractData()\n\t}\n\n\tif pRes.CollectionID.Valid {\n\t\tcoll, err := app.db.GetCollectionBy(\"id = ?\", pRes.CollectionID.Int64)\n\t\tif err == nil && !app.cfg.App.Private && app.cfg.App.Federation {\n\t\t\tcoll.hostName = app.cfg.App.Host\n\t\t\tpRes.Collection = &CollectionObj{Collection: *coll}\n\t\t\tgo federatePost(app, pRes, pRes.Collection.ID, true)\n\t\t}\n\t}\n\n\t// Write success now\n\tif reqJSON {\n\t\treturn impart.WriteSuccess(w, pRes, http.StatusOK)\n\t}\n\n\taddSessionFlash(app, w, r, \"Changes saved.\", nil)\n\tcollectionAlias := vars[\"alias\"]\n\tredirect := \"/\" + postID + \"/meta\"\n\tif collectionAlias != \"\" {\n\t\tcollPre := \"/\" + collectionAlias\n\t\tif app.cfg.App.SingleUser {\n\t\t\tcollPre = \"\"\n\t\t}\n\t\tredirect = collPre + \"/\" + pRes.Slug.String + \"/edit/meta\"\n\t} else {\n\t\tif app.cfg.App.SingleUser {\n\t\t\tredirect = \"/d\" + redirect\n\t\t}\n\t}\n\tw.Header().Set(\"Location\", redirect)\n\tw.WriteHeader(http.StatusFound)\n\n\treturn nil\n}\n\nfunc deletePost(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tfriendlyID := vars[\"post\"]\n\teditToken := r.FormValue(\"token\")\n\n\tvar ownerID int64\n\tvar u *User\n\taccessToken := r.Header.Get(\"Authorization\")\n\tif accessToken == \"\" && editToken == \"\" {\n\t\tu = getUserSession(app, r)\n\t\tif u == nil {\n\t\t\treturn ErrNoAccessToken\n\t\t}\n\t}\n\n\tvar res sql.Result\n\tvar t *sql.Tx\n\tvar err error\n\tvar collID sql.NullInt64\n\tvar coll *Collection\n\tvar pp *PublicPost\n\tif editToken != \"\" {\n\t\t// TODO: SELECT owner_id, as well, and return appropriate error if NULL instead of running two queries\n\t\tvar dummy int64\n\t\terr = app.db.QueryRow(\"SELECT 1 FROM posts WHERE id = ?\", friendlyID).Scan(&dummy)\n\t\tswitch {\n\t\tcase err == sql.ErrNoRows:\n\t\t\treturn impart.HTTPError{http.StatusNotFound, \"Post not found.\"}\n\t\t}\n\t\terr = app.db.QueryRow(\"SELECT 1 FROM posts WHERE id = ? AND owner_id IS NULL\", friendlyID).Scan(&dummy)\n\t\tswitch {\n\t\tcase err == sql.ErrNoRows:\n\t\t\t// Post already has an owner. This could provide a bad experience\n\t\t\t// for the user, but it's more important to ensure data isn't lost\n\t\t\t// unexpectedly. So prevent deletion via token.\n\t\t\treturn impart.HTTPError{http.StatusConflict, \"This post belongs to some user (hopefully yours). Please log in and delete it from that user's account.\"}\n\t\t}\n\t\tres, err = app.db.Exec(\"DELETE FROM posts WHERE id = ? AND modify_token = ? AND owner_id IS NULL\", friendlyID, editToken)\n\t} else if accessToken != \"\" || u != nil {\n\t\t// Caller provided some way to authenticate; assume caller expects the\n\t\t// post to be deleted based on a specific post owner, thus we should\n\t\t// return corresponding errors.\n\t\tif accessToken != \"\" {\n\t\t\townerID = app.db.GetUserID(accessToken)\n\t\t\tif ownerID == -1 {\n\t\t\t\treturn ErrBadAccessToken\n\t\t\t}\n\t\t} else {\n\t\t\townerID = u.ID\n\t\t}\n\n\t\t// TODO: don't make two queries\n\t\tvar realOwnerID sql.NullInt64\n\t\terr = app.db.QueryRow(\"SELECT collection_id, owner_id FROM posts WHERE id = ?\", friendlyID).Scan(&collID, &realOwnerID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !collID.Valid {\n\t\t\t// There's no collection; simply delete the post\n\t\t\tres, err = app.db.Exec(\"DELETE FROM posts WHERE id = ? AND owner_id = ?\", friendlyID, ownerID)\n\t\t} else {\n\t\t\t// Post belongs to a collection; do any additional clean up\n\t\t\tcoll, err = app.db.GetCollectionBy(\"id = ?\", collID.Int64)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Unable to get collection: %v\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif app.cfg.App.Federation {\n\t\t\t\t// First fetch full post for federation\n\t\t\t\tpp, err = app.db.GetOwnedPost(friendlyID, ownerID)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error(\"Unable to get owned post: %v\", err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcollObj := &CollectionObj{Collection: *coll}\n\t\t\t\tpp.Collection = collObj\n\t\t\t}\n\n\t\t\tt, err = app.db.Begin()\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"No begin: %v\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tres, err = t.Exec(\"DELETE FROM posts WHERE id = ? AND owner_id = ?\", friendlyID, ownerID)\n\t\t}\n\t} else {\n\t\treturn impart.HTTPError{http.StatusBadRequest, \"No authenticated user or post token given.\"}\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\taffected, err := res.RowsAffected()\n\tif err != nil {\n\t\tif t != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"Rows affected err! Rolling back\")\n\t\t}\n\t\treturn err\n\t} else if affected == 0 {\n\t\tif t != nil {\n\t\t\tt.Rollback()\n\t\t\tlog.Error(\"No rows affected! Rolling back\")\n\t\t}\n\t\treturn impart.HTTPError{http.StatusForbidden, \"Post not found, or you're not the owner.\"}\n\t}\n\tif t != nil {\n\t\tt.Commit()\n\t}\n\tif coll != nil && !app.cfg.App.Private && app.cfg.App.Federation {\n\t\tgo deleteFederatedPost(app, pp, collID.Int64)\n\t}\n\n\treturn impart.HTTPError{Status: http.StatusNoContent}\n}\n\n// addPost associates a post with the authenticated user.\nfunc addPost(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvar ownerID int64\n\n\t// Authenticate user\n\tat := r.Header.Get(\"Authorization\")\n\tif at != \"\" {\n\t\townerID = app.db.GetUserID(at)\n\t\tif ownerID == -1 {\n\t\t\treturn ErrBadAccessToken\n\t\t}\n\t} else {\n\t\tu := getUserSession(app, r)\n\t\tif u == nil {\n\t\t\treturn ErrNotLoggedIn\n\t\t}\n\t\townerID = u.ID\n\t}\n\n\tsilenced, err := app.db.IsUserSilenced(ownerID)\n\tif err != nil {\n\t\tlog.Error(\"add post: %v\", err)\n\t}\n\tif silenced {\n\t\treturn ErrUserSilenced\n\t}\n\n\t// Parse claimed posts in format:\n\t// [{\"id\": \"...\", \"token\": \"...\"}]\n\tvar claims *[]ClaimPostRequest\n\tdecoder := json.NewDecoder(r.Body)\n\terr = decoder.Decode(&claims)\n\tif err != nil {\n\t\treturn ErrBadJSONArray\n\t}\n\n\tvars := mux.Vars(r)\n\tcollAlias := vars[\"alias\"]\n\n\t// Update all given posts\n\tres, err := app.db.ClaimPosts(app.cfg, ownerID, collAlias, claims)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, pRes := range *res {\n\t\tif pRes.Code != http.StatusOK {\n\t\t\tcontinue\n\t\t}\n\t\tif !app.cfg.App.Private && app.cfg.App.Federation {\n\t\t\tif !pRes.Post.Created.After(time.Now()) {\n\t\t\t\tpRes.Post.Collection.hostName = app.cfg.App.Host\n\t\t\t\tgo federatePost(app, pRes.Post, pRes.Post.Collection.ID, false)\n\t\t\t}\n\t\t}\n\t\tif app.cfg.Email.Enabled() && pRes.Post.Collection.EmailSubsEnabled() {\n\t\t\tgo app.db.InsertJob(&PostJob{\n\t\t\t\tPostID: pRes.Post.ID,\n\t\t\t\tAction: \"email\",\n\t\t\t\tDelay:  emailSendDelay,\n\t\t\t})\n\t\t}\n\t}\n\treturn impart.WriteSuccess(w, res, http.StatusOK)\n}\n\nfunc dispersePost(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvar ownerID int64\n\n\t// Authenticate user\n\tat := r.Header.Get(\"Authorization\")\n\tif at != \"\" {\n\t\townerID = app.db.GetUserID(at)\n\t\tif ownerID == -1 {\n\t\t\treturn ErrBadAccessToken\n\t\t}\n\t} else {\n\t\tu := getUserSession(app, r)\n\t\tif u == nil {\n\t\t\treturn ErrNotLoggedIn\n\t\t}\n\t\townerID = u.ID\n\t}\n\n\t// Parse posts in format:\n\t// [\"...\"]\n\tvar postIDs []string\n\tdecoder := json.NewDecoder(r.Body)\n\terr := decoder.Decode(&postIDs)\n\tif err != nil {\n\t\treturn ErrBadJSONArray\n\t}\n\n\t// Update all given posts\n\tres, err := app.db.DispersePosts(ownerID, postIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn impart.WriteSuccess(w, res, http.StatusOK)\n}\n\ntype (\n\tPinPostResult struct {\n\t\tID           string `json:\"id,omitempty\"`\n\t\tCode         int    `json:\"code,omitempty\"`\n\t\tErrorMessage string `json:\"error_msg,omitempty\"`\n\t}\n)\n\n// pinPost pins a post to a blog\nfunc pinPost(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvar userID int64\n\n\t// Authenticate user\n\tat := r.Header.Get(\"Authorization\")\n\tif at != \"\" {\n\t\tuserID = app.db.GetUserID(at)\n\t\tif userID == -1 {\n\t\t\treturn ErrBadAccessToken\n\t\t}\n\t} else {\n\t\tu := getUserSession(app, r)\n\t\tif u == nil {\n\t\t\treturn ErrNotLoggedIn\n\t\t}\n\t\tuserID = u.ID\n\t}\n\n\tsilenced, err := app.db.IsUserSilenced(userID)\n\tif err != nil {\n\t\tlog.Error(\"pin post: %v\", err)\n\t}\n\tif silenced {\n\t\treturn ErrUserSilenced\n\t}\n\n\t// Parse request\n\tvar posts []struct {\n\t\tID       string `json:\"id\"`\n\t\tPosition int64  `json:\"position\"`\n\t}\n\tdecoder := json.NewDecoder(r.Body)\n\terr = decoder.Decode(&posts)\n\tif err != nil {\n\t\treturn ErrBadJSONArray\n\t}\n\n\t// Validate data\n\tvars := mux.Vars(r)\n\tcollAlias := vars[\"alias\"]\n\n\tcoll, err := app.db.GetCollection(collAlias)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif coll.OwnerID != userID {\n\t\treturn ErrForbiddenCollection\n\t}\n\n\t// Do (un)pinning\n\tisPinning := r.URL.Path[strings.LastIndex(r.URL.Path, \"/\"):] == \"/pin\"\n\tres := []PinPostResult{}\n\tfor _, p := range posts {\n\t\terr = app.db.UpdatePostPinState(isPinning, p.ID, coll.ID, userID, p.Position)\n\t\tppr := PinPostResult{ID: p.ID}\n\t\tif err != nil {\n\t\t\tppr.Code = http.StatusInternalServerError\n\t\t\t// TODO: set error message\n\t\t} else {\n\t\t\tppr.Code = http.StatusOK\n\t\t}\n\t\tres = append(res, ppr)\n\t}\n\treturn impart.WriteSuccess(w, res, http.StatusOK)\n}\n\nfunc fetchPost(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvar collID int64\n\tvar coll *Collection\n\tvar err error\n\tvars := mux.Vars(r)\n\tif collAlias := vars[\"alias\"]; collAlias != \"\" {\n\t\t// Fetch collection information, since an alias is provided\n\t\tcoll, err = app.db.GetCollection(collAlias)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcollID = coll.ID\n\t}\n\n\tp, err := app.db.GetPost(vars[\"post\"], collID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif coll == nil && p.CollectionID.Valid {\n\t\t// Collection post is getting fetched by post ID, not coll alias + post slug, so get coll info now.\n\t\tcoll, err = app.db.GetCollectionByID(p.CollectionID.Int64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif coll != nil {\n\t\tcoll.hostName = app.cfg.App.Host\n\t\t_, err = apiCheckCollectionPermissions(app, r, coll)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tsilenced, err := app.db.IsUserSilenced(p.OwnerID.Int64)\n\tif err != nil {\n\t\tlog.Error(\"fetch post: %v\", err)\n\t}\n\tif silenced {\n\t\treturn ErrPostNotFound\n\t}\n\n\tp.extractData()\n\n\tif IsActivityPubRequest(r) {\n\t\tif coll == nil {\n\t\t\t// This is a draft post; 404 for now\n\t\t\t// TODO: return ActivityObject\n\t\t\treturn impart.HTTPError{http.StatusNotFound, \"\"}\n\t\t}\n\n\t\tp.Collection = &CollectionObj{Collection: *coll}\n\t\tpo := p.ActivityObject(app)\n\t\tpo.Context = []interface{}{activitystreams.Namespace}\n\t\tsetCacheControl(w, apCacheTime)\n\t\treturn impart.RenderActivityJSON(w, po, http.StatusOK)\n\t}\n\n\treturn impart.WriteSuccess(w, p, http.StatusOK)\n}\n\nfunc fetchPostProperty(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tp, err := app.db.GetPostProperty(vars[\"post\"], 0, vars[\"property\"])\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn impart.WriteSuccess(w, p, http.StatusOK)\n}\n\nfunc (p *Post) processPost() PublicPost {\n\tres := &PublicPost{Post: p, Views: 0}\n\tres.Views = p.ViewCount\n\tres.Likes = p.LikeCount\n\t// TODO: move to own function\n\tloc := monday.FuzzyLocale(p.Language.String)\n\tres.DisplayDate = monday.Format(p.Created, monday.LongFormatsByLocale[loc], loc)\n\n\treturn *res\n}\n\nfunc (p *PublicPost) CanonicalURL(hostName string) string {\n\tif p.Collection == nil || p.Collection.Alias == \"\" {\n\t\treturn hostName + \"/\" + p.ID + \".md\"\n\t}\n\treturn p.Collection.CanonicalURL() + p.Slug.String\n}\n\nfunc (pp *PublicPost) DisplayCanonicalURL() string {\n\tus := pp.CanonicalURL(pp.Collection.hostName)\n\tu, err := url.Parse(us)\n\tif err != nil {\n\t\treturn us\n\t}\n\treturn u.Hostname() + u.Path\n}\n\nfunc (p *PublicPost) ActivityObject(app *App) *activitystreams.Object {\n\tcfg := app.cfg\n\tvar o *activitystreams.Object\n\tif cfg.App.NotesOnly || strings.Index(p.Content, \"\\n\\n\") == -1 {\n\t\to = activitystreams.NewNoteObject()\n\t} else {\n\t\to = activitystreams.NewArticleObject()\n\t}\n\to.ID = p.Collection.FederatedAPIBase() + \"api/posts/\" + p.ID\n\to.Published = p.Created\n\to.URL = p.CanonicalURL(cfg.App.Host)\n\to.AttributedTo = p.Collection.FederatedAccount()\n\to.CC = []string{\n\t\tp.Collection.FederatedAccount() + \"/followers\",\n\t}\n\to.Name = p.DisplayTitle()\n\tp.augmentContent()\n\tif p.HTMLContent == template.HTML(\"\") {\n\t\tp.formatContent(cfg, false, false)\n\t\tp.augmentReadingDestination()\n\t}\n\to.Content = string(p.HTMLContent)\n\tif p.Language.Valid {\n\t\to.ContentMap = map[string]string{\n\t\t\tp.Language.String: string(p.HTMLContent),\n\t\t}\n\t}\n\tif len(p.Tags) == 0 {\n\t\to.Tag = []activitystreams.Tag{}\n\t} else {\n\t\tvar tagBaseURL string\n\t\tif isSingleUser {\n\t\t\ttagBaseURL = p.Collection.CanonicalURL() + \"tag:\"\n\t\t} else {\n\t\t\tif cfg.App.Chorus {\n\t\t\t\ttagBaseURL = fmt.Sprintf(\"%s/read/t/\", p.Collection.hostName)\n\t\t\t} else {\n\t\t\t\ttagBaseURL = fmt.Sprintf(\"%s/%s/tag:\", p.Collection.hostName, p.Collection.Alias)\n\t\t\t}\n\t\t}\n\t\tfor _, t := range p.Tags {\n\t\t\to.Tag = append(o.Tag, activitystreams.Tag{\n\t\t\t\tType: activitystreams.TagHashtag,\n\t\t\t\tHRef: tagBaseURL + t,\n\t\t\t\tName: \"#\" + t,\n\t\t\t})\n\t\t}\n\t}\n\tif len(p.Images) > 0 {\n\t\tfor _, i := range p.Images {\n\t\t\to.Attachment = append(o.Attachment, activitystreams.NewImageAttachment(i))\n\t\t}\n\t}\n\t// Find mentioned users\n\tmentionedUsers := make(map[string]string)\n\n\tstripper := bluemonday.StrictPolicy()\n\tcontent := stripper.Sanitize(p.Content)\n\tmentions := mentionReg.FindAllString(content, -1)\n\n\tfor _, handle := range mentions {\n\t\tactorIRI, err := app.db.GetProfilePageFromHandle(app, handle)\n\t\tif err != nil {\n\t\t\tlog.Info(\"Couldn't find user '%s' locally or remotely\", handle)\n\t\t\tcontinue\n\t\t}\n\t\tmentionedUsers[handle] = actorIRI\n\t}\n\n\tfor handle, iri := range mentionedUsers {\n\t\to.CC = append(o.CC, iri)\n\t\to.Tag = append(o.Tag, activitystreams.Tag{Type: \"Mention\", HRef: iri, Name: handle})\n\t}\n\treturn o\n}\n\n// TODO: merge this into getSlugFromPost or phase it out\nfunc getSlug(title, lang string) string {\n\treturn getSlugFromPost(\"\", title, lang)\n}\n\nfunc getSlugFromPost(title, body, lang string) string {\n\tif title == \"\" {\n\t\t// Remove Markdown, so e.g. link URLs and image alt text don't make it into the slug\n\t\tbody = strings.TrimSpace(stripmd.StripOptions(body, stripmd.Options{SkipImages: true}))\n\t\ttitle = postTitle(body, body)\n\t}\n\ttitle = parse.PostLede(title, false)\n\t// Truncate lede if needed\n\ttitle, _ = parse.TruncToWord(title, 80)\n\tvar s string\n\tif lang != \"\" && len(lang) == 2 {\n\t\ts = slug.MakeLang(title, lang)\n\t} else {\n\t\ts = slug.Make(title)\n\t}\n\n\t// Transliteration may cause the slug to expand past the limit, so truncate again\n\ts, _ = parse.TruncToWord(s, 80)\n\treturn strings.TrimFunc(s, func(r rune) bool {\n\t\t// TruncToWord doesn't respect words in a slug, since spaces are replaced\n\t\t// with hyphens. So remove any trailing hyphens.\n\t\treturn r == '-'\n\t})\n}\n\n// isFontValid returns whether or not the submitted post's appearance is valid.\nfunc (p *SubmittedPost) isFontValid() bool {\n\tvalidFonts := map[string]bool{\n\t\t\"norm\": true,\n\t\t\"sans\": true,\n\t\t\"mono\": true,\n\t\t\"wrap\": true,\n\t\t\"code\": true,\n\t}\n\n\t_, valid := validFonts[p.Font]\n\treturn valid\n}\n\nfunc getRawPost(app *App, friendlyID string) *RawPost {\n\tvar content, font, title string\n\tvar isRTL sql.NullBool\n\tvar lang sql.NullString\n\tvar ownerID sql.NullInt64\n\tvar created, updated time.Time\n\n\terr := app.db.QueryRow(\"SELECT title, content, text_appearance, language, rtl, created, updated, owner_id FROM posts WHERE id = ?\", friendlyID).Scan(&title, &content, &font, &lang, &isRTL, &created, &updated, &ownerID)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn &RawPost{Content: \"\", Found: false, Gone: false}\n\tcase err != nil:\n\t\tlog.Error(\"Unable to fetch getRawPost: %s\", err)\n\t\treturn &RawPost{Content: \"\", Found: true, Gone: false}\n\t}\n\n\treturn &RawPost{\n\t\tTitle:    title,\n\t\tContent:  content,\n\t\tFont:     font,\n\t\tCreated:  created,\n\t\tUpdated:  updated,\n\t\tIsRTL:    isRTL,\n\t\tLanguage: lang,\n\t\tOwnerID:  ownerID.Int64,\n\t\tFound:    true,\n\t\tGone:     content == \"\" && title == \"\",\n\t}\n\n}\n\n// TODO; return a Post!\nfunc getRawCollectionPost(app *App, slug, collAlias string) *RawPost {\n\tvar id, title, content, font string\n\tvar isRTL sql.NullBool\n\tvar lang sql.NullString\n\tvar created, updated time.Time\n\tvar ownerID null.Int\n\tvar views int64\n\tvar err error\n\n\tif app.cfg.App.SingleUser {\n\t\terr = app.db.QueryRow(\"SELECT id, title, content, text_appearance, language, rtl, view_count, created, updated, owner_id FROM posts WHERE slug = ? AND collection_id = 1\", slug).Scan(&id, &title, &content, &font, &lang, &isRTL, &views, &created, &updated, &ownerID)\n\t} else {\n\t\terr = app.db.QueryRow(\"SELECT id, title, content, text_appearance, language, rtl, view_count, created, updated, owner_id FROM posts WHERE slug = ? AND collection_id = (SELECT id FROM collections WHERE alias = ?)\", slug, collAlias).Scan(&id, &title, &content, &font, &lang, &isRTL, &views, &created, &updated, &ownerID)\n\t}\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn &RawPost{Content: \"\", Found: false, Gone: false}\n\tcase err != nil:\n\t\tlog.Error(\"Unable to fetch getRawCollectionPost: %s\", err)\n\t\treturn &RawPost{Content: \"\", Found: true, Gone: false}\n\t}\n\n\treturn &RawPost{\n\t\tId:       id,\n\t\tSlug:     slug,\n\t\tTitle:    title,\n\t\tContent:  content,\n\t\tFont:     font,\n\t\tCreated:  created,\n\t\tUpdated:  updated,\n\t\tIsRTL:    isRTL,\n\t\tLanguage: lang,\n\t\tOwnerID:  ownerID.Int64,\n\t\tFound:    true,\n\t\tGone:     content == \"\" && title == \"\",\n\t\tViews:    views,\n\t}\n}\n\nfunc isRaw(r *http.Request) bool {\n\tvars := mux.Vars(r)\n\tslug := vars[\"slug\"]\n\n\t// NOTE: until this is done better, be sure to keep this in parity with\n\t// isRaw in viewCollectionPost() and handleViewPost()\n\tisJSON := strings.HasSuffix(slug, \".json\")\n\tisXML := strings.HasSuffix(slug, \".xml\")\n\tisMarkdown := strings.HasSuffix(slug, \".md\")\n\treturn strings.HasSuffix(slug, \".txt\") || isJSON || isXML || isMarkdown\n}\n\nfunc viewCollectionPost(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tslug := vars[\"slug\"]\n\n\t// NOTE: until this is done better, be sure to keep this in parity with\n\t// isRaw() and handleViewPost()\n\tisJSON := strings.HasSuffix(slug, \".json\")\n\tisXML := strings.HasSuffix(slug, \".xml\")\n\tisMarkdown := strings.HasSuffix(slug, \".md\")\n\tisRaw := strings.HasSuffix(slug, \".txt\") || isJSON || isXML || isMarkdown\n\n\tcr := &collectionReq{}\n\terr := processCollectionRequest(cr, vars, w, r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check for hellbanned users\n\tu, err := checkUserForCollection(app, cr, r, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Normalize the URL, redirecting user to consistent post URL\n\tif slug != strings.ToLower(slug) {\n\t\tloc := fmt.Sprintf(\"/%s\", strings.ToLower(slug))\n\t\tif !app.cfg.App.SingleUser {\n\t\t\tloc = \"/\" + cr.alias + loc\n\t\t}\n\t\treturn impart.HTTPError{http.StatusMovedPermanently, loc}\n\t}\n\n\t// Display collection if this is a collection\n\tvar c *Collection\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(cr.alias)\n\t}\n\tif err != nil {\n\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\tif err.Status == http.StatusNotFound {\n\t\t\t\t// Redirect if necessary\n\t\t\t\tnewAlias := app.db.GetCollectionRedirect(cr.alias)\n\t\t\t\tif newAlias != \"\" {\n\t\t\t\t\treturn impart.HTTPError{http.StatusFound, \"/\" + newAlias + \"/\" + slug}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tsilenced, err := app.db.IsUserSilenced(c.OwnerID)\n\tif err != nil {\n\t\tlog.Error(\"view collection post: %v\", err)\n\t}\n\n\t// Check collection permissions\n\tif c.IsPrivate() && (u == nil || u.ID != c.OwnerID) {\n\t\treturn ErrPostNotFound\n\t}\n\tif c.IsProtected() && (u == nil || u.ID != c.OwnerID) {\n\t\tif silenced {\n\t\t\treturn ErrPostNotFound\n\t\t} else if !isAuthorizedForCollection(app, c.Alias, r) {\n\t\t\treturn impart.HTTPError{http.StatusFound, c.CanonicalURL() + \"/?g=\" + slug}\n\t\t}\n\t}\n\n\tcr.isCollOwner = u != nil && c.OwnerID == u.ID\n\n\tif isRaw {\n\t\tslug = strings.Split(slug, \".\")[0]\n\t}\n\n\t// Fetch extra data about the Collection\n\t// TODO: refactor out this logic, shared in collection.go:fetchCollection()\n\tcoll := NewCollectionObj(c)\n\towner, err := app.db.GetUserByID(coll.OwnerID)\n\tif err != nil {\n\t\t// Log the error and just continue\n\t\tlog.Error(\"Error getting user for collection: %v\", err)\n\t} else {\n\t\tcoll.Owner = owner\n\t}\n\n\tpostFound := true\n\tp, err := app.db.GetPost(slug, coll.ID)\n\tif err != nil {\n\t\tif err == ErrCollectionPageNotFound {\n\t\t\tpostFound = false\n\n\t\t\tif slug == \"feed\" {\n\t\t\t\t// User tried to access blog feed without a trailing slash, and\n\t\t\t\t// there's no post with a slug \"feed\"\n\t\t\t\treturn impart.HTTPError{http.StatusFound, c.CanonicalURL() + \"feed/\"}\n\t\t\t}\n\n\t\t\tpo := &Post{\n\t\t\t\tSlug:     null.NewString(slug, true),\n\t\t\t\tFont:     \"norm\",\n\t\t\t\tLanguage: zero.NewString(\"en\", true),\n\t\t\t\tRTL:      zero.NewBool(false, true),\n\t\t\t\tContent: `<p class=\"msg\">This page is missing.</p>\n\nAre you sure it was ever here?`,\n\t\t\t}\n\t\t\tpp := po.processPost()\n\t\t\tp = &pp\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Check if the authenticated user is the post owner\n\tp.IsOwner = u != nil && u.ID == p.OwnerID.Int64\n\tp.Collection = coll\n\tp.IsTopLevel = app.cfg.App.SingleUser\n\n\t// Only allow a post owner or admin to view a post for silenced collections\n\tif silenced && !p.IsOwner && (u == nil || !u.IsAdmin()) {\n\t\treturn ErrPostNotFound\n\t}\n\n\t// Check if post has been unpublished\n\tif p.Content == \"\" && p.Title.String == \"\" {\n\t\treturn impart.HTTPError{http.StatusGone, \"Post was unpublished.\"}\n\t}\n\n\tp.augmentContent()\n\n\t// Serve collection post\n\tif isRaw {\n\t\tcontentType := \"text/plain\"\n\t\tif isJSON {\n\t\t\tcontentType = \"application/json\"\n\t\t} else if isXML {\n\t\t\tcontentType = \"application/xml\"\n\t\t} else if isMarkdown {\n\t\t\tcontentType = \"text/markdown\"\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", fmt.Sprintf(\"%s; charset=utf-8\", contentType))\n\t\tif !postFound {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\tfmt.Fprintf(w, \"Post not found.\")\n\t\t\t// TODO: return error instead, so status is correctly reflected in logs\n\t\t\treturn nil\n\t\t}\n\t\tif isMarkdown && p.Title.String != \"\" {\n\t\t\tfmt.Fprintf(w, \"# %s\\n\\n\", p.Title.String)\n\t\t}\n\t\tfmt.Fprint(w, p.Content)\n\t} else if IsActivityPubRequest(r) {\n\t\tif !postFound {\n\t\t\treturn ErrCollectionPageNotFound\n\t\t}\n\t\tp.extractData()\n\t\tap := p.ActivityObject(app)\n\t\tap.Context = []interface{}{activitystreams.Namespace}\n\t\tsetCacheControl(w, apCacheTime)\n\t\treturn impart.RenderActivityJSON(w, ap, http.StatusOK)\n\t} else {\n\t\tp.extractData()\n\t\tp.Content = strings.Replace(p.Content, \"<!--more-->\", \"\", 1)\n\t\tif app.cfg.Email.Enabled() && c.EmailSubsEnabled() {\n\t\t\t// TODO: indicate plan is inactive or subs disabled when OWNER is viewing their own post.\n\t\t\tif u != nil && u.IsEmailSubscriber(app, c.ID) {\n\t\t\t\tp.Content = strings.Replace(p.Content, \"<!--emailsub-->\", `<p id=\"emailsub\">You're subscribed to email updates. <a href=\"/api/collections/`+c.Alias+`/email/unsubscribe?slug=`+p.Slug.String+`\">Unsubscribe</a>.</p>`, -1)\n\t\t\t} else {\n\t\t\t\tp.Content = strings.Replace(p.Content, \"<!--emailsub-->\", `<form method=\"post\" id=\"emailsub\" action=\"/api/collections/`+c.Alias+`/email/subscribe\"><input type=\"hidden\" name=\"slug\" value=\"`+p.Slug.String+`\" /><input type=\"hidden\" name=\"web\" value=\"1\" /><div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"email\" name=\"`+spam.HoneypotFieldName()+`\" tabindex=\"-1\" value=\"\" /><input type=\"password\" name=\"fake_password\" tabindex=\"-1\" placeholder=\"password\" autocomplete=\"new-password\" /></div><input type=\"email\" name=\"email\" placeholder=\"me@example.com\" /><input type=\"submit\" id=\"subscribe-btn\" value=\"Subscribe\" /></form>`, -1)\n\t\t\t}\n\t\t}\n\t\tp.Content = strings.Replace(p.Content, \"&lt;!--emailsub-->\", \"<!--emailsub-->\", 1)\n\t\t// TODO: move this to function\n\t\tp.formatContent(app.cfg, cr.isCollOwner, true)\n\t\ttp := CollectionPostPage{\n\t\t\tPublicPost:     p,\n\t\t\tStaticPage:     pageForReq(app, r),\n\t\t\tIsOwner:        cr.isCollOwner,\n\t\t\tIsCustomDomain: cr.isCustomDomain,\n\t\t\tIsFound:        postFound,\n\t\t\tSilenced:       silenced,\n\t\t\tCollAlias:      c.Alias,\n\t\t}\n\t\ttp.IsAdmin = u != nil && u.IsAdmin()\n\t\ttp.CanInvite = canUserInvite(app.cfg, tp.IsAdmin)\n\t\ttp.PinnedPosts, _ = app.db.GetPinnedPosts(coll, p.IsOwner)\n\t\ttp.IsPinned = len(*tp.PinnedPosts) > 0 && PostsContains(tp.PinnedPosts, p)\n\t\ttp.Monetization = coll.Monetization\n\t\ttp.Verification = coll.Verification\n\n\t\tif !postFound {\n\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t}\n\t\tpostTmpl := \"collection-post\"\n\t\tif app.cfg.App.Chorus {\n\t\t\tpostTmpl = \"chorus-collection-post\"\n\t\t}\n\t\tif err := templates[postTmpl].ExecuteTemplate(w, \"post\", tp); err != nil {\n\t\t\tlog.Error(\"Error in %s template: %v\", postTmpl, err)\n\t\t}\n\t}\n\n\tgo func() {\n\t\tif p.OwnerID.Valid {\n\t\t\t// Post is owned by someone. Don't update stats if owner is viewing the post.\n\t\t\tif u != nil && p.OwnerID.Int64 == u.ID {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// Update stats for non-raw post views\n\t\tif !isRaw && r.Method != \"HEAD\" && !bots.IsBot(r.UserAgent()) {\n\t\t\t_, err := app.db.Exec(\"UPDATE posts SET view_count = view_count + 1 WHERE slug = ? AND collection_id = ?\", slug, coll.ID)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Unable to update posts count: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\n// TODO: move this to utils after making it more generic\nfunc PostsContains(sl *[]PublicPost, s *PublicPost) bool {\n\tfor _, e := range *sl {\n\t\tif e.ID == s.ID {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p *Post) extractData() {\n\tp.Tags = tags.Extract(p.Content)\n\tp.extractImages()\n}\n\nfunc (p *Post) IsSans() bool {\n\treturn p.Font == \"sans\"\n}\n\nfunc (p *Post) IsMonospace() bool {\n\treturn p.Font == \"mono\"\n}\n\nfunc (rp *RawPost) UserFacingCreated() string {\n\treturn rp.Created.Format(postMetaDateFormat)\n}\n\nfunc (rp *RawPost) Created8601() string {\n\treturn rp.Created.Format(\"2006-01-02T15:04:05Z\")\n}\n\nfunc (rp *RawPost) Updated8601() string {\n\tif rp.Updated.IsZero() {\n\t\treturn \"\"\n\t}\n\treturn rp.Updated.Format(\"2006-01-02T15:04:05Z\")\n}\n\nvar imageURLRegex = regexp.MustCompile(`(?i)[^ ]+\\.(gif|png|jpg|jpeg|avif|avifs|webp|jxl|image)$`)\n\nfunc (p *Post) extractImages() {\n\tp.Images = extractImages(p.Content)\n}\n\nfunc extractImages(content string) []string {\n\tmatches := extract.ExtractUrls(content)\n\turls := map[string]bool{}\n\tfor i := range matches {\n\t\tuRaw := matches[i].Text\n\t\t// Parse the extracted text so we can examine the path\n\t\tu, err := url.Parse(uRaw)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Ensure the path looks like it leads to an image file\n\t\tif !imageURLRegex.MatchString(u.Path) {\n\t\t\tcontinue\n\t\t}\n\t\turls[uRaw] = true\n\t}\n\n\tresURLs := make([]string, 0)\n\tfor k := range urls {\n\t\tresURLs = append(resURLs, k)\n\t}\n\treturn resURLs\n}\n"
        },
        {
          "name": "posts_test.go",
          "type": "blob",
          "size": 1.1953125,
          "content": "/*\n * Copyright © 2020-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/guregu/null/zero\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/writefreely/writefreely\"\n)\n\nfunc TestPostSummary(t *testing.T) {\n\ttestCases := map[string]struct {\n\t\tgiven    writefreely.Post\n\t\texpected string\n\t}{\n\t\t\"no special chars\":          {givenPost(\"Content.\"), \"Content.\"},\n\t\t\"HTML content\":              {givenPost(\"Content <p>with a</p> paragraph.\"), \"Content with a paragraph.\"},\n\t\t\"content with escaped char\": {givenPost(\"Content&#39;s all OK.\"), \"Content's all OK.\"},\n\t\t\"multiline content\": {givenPost(`Content\nin\nmultiple\nlines.`), \"Content in multiple lines.\"},\n\t}\n\n\tfor name, test := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tactual := test.given.Summary()\n\t\t\tassert.Equal(t, test.expected, actual)\n\t\t})\n\t}\n}\n\nfunc givenPost(content string) writefreely.Post {\n\treturn writefreely.Post{Title: zero.StringFrom(\"Title\"), Content: content}\n}\n"
        },
        {
          "name": "prose",
          "type": "tree",
          "content": null
        },
        {
          "name": "read.go",
          "type": "blob",
          "size": 8.8408203125,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"math\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t. \"github.com/gorilla/feeds\"\n\t\"github.com/gorilla/mux\"\n\tstripmd \"github.com/writeas/go-strip-markdown/v2\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writeas/web-core/memo\"\n\t\"github.com/writefreely/writefreely/page\"\n)\n\nconst (\n\ttlFeedLimit      = 100\n\ttlAPIPageLimit   = 10\n\ttlMaxAuthorPosts = 5\n\ttlPostsPerPage   = 16\n\ttlMaxPostCache   = 250\n\ttlCacheDur       = 10 * time.Minute\n)\n\ntype localTimeline struct {\n\tm     *memo.Memo\n\tposts *[]PublicPost\n\n\t// Configuration values\n\tpostsPerPage int\n}\n\ntype readPublication struct {\n\tpage.StaticPage\n\tPosts       *[]PublicPost\n\tCurrentPage int\n\tTotalPages  int\n\tSelTopic    string\n\tIsAdmin     bool\n\tCanInvite   bool\n\n\t// Customizable page content\n\tContentTitle string\n\tContent      template.HTML\n}\n\nfunc initLocalTimeline(app *App) {\n\tapp.timeline = &localTimeline{\n\t\tpostsPerPage: tlPostsPerPage,\n\t\tm:            memo.New(app.FetchPublicPosts, tlCacheDur),\n\t}\n}\n\n// satisfies memo.Func\nfunc (app *App) FetchPublicPosts() (interface{}, error) {\n\t// Conditions\n\tlimit := fmt.Sprintf(\"LIMIT %d\", tlMaxPostCache)\n\t// This is better than the hard limit when limiting posts from individual authors\n\t// ageCond := `p.created >= ` + app.db.dateSub(3, \"month\") + ` AND `\n\n\t// Finds all public posts and posts in a public collection published during the owner's active subscription period and within the last 3 months\n\trows, err := app.db.Query(`SELECT p.id, c.id, alias, c.title, p.slug, p.title, p.content, p.text_appearance, p.language, p.rtl, p.created, p.updated\n\tFROM collections c\n\tLEFT JOIN posts p ON p.collection_id = c.id\n\tLEFT JOIN users u ON u.id = p.owner_id\n\tWHERE c.privacy = 1 AND (p.created <= ` + app.db.now() + ` AND pinned_position IS NULL) AND u.status = 0\n\tORDER BY p.created DESC\n\t` + limit)\n\tif err != nil {\n\t\tlog.Error(\"Failed selecting from posts: %v\", err)\n\t\treturn nil, impart.HTTPError{http.StatusInternalServerError, \"Couldn't retrieve collection posts.\" + err.Error()}\n\t}\n\tdefer rows.Close()\n\n\tap := map[string]uint{}\n\n\tposts := []PublicPost{}\n\tfor rows.Next() {\n\t\tp := &Post{}\n\t\tc := &Collection{}\n\t\tvar alias, title sql.NullString\n\t\terr = rows.Scan(&p.ID, &c.ID, &alias, &title, &p.Slug, &p.Title, &p.Content, &p.Font, &p.Language, &p.RTL, &p.Created, &p.Updated)\n\t\tif err != nil {\n\t\t\tlog.Error(\"[READ] Unable to scan row, skipping: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tc.hostName = app.cfg.App.Host\n\n\t\tisCollectionPost := alias.Valid\n\t\tif isCollectionPost {\n\t\t\tc.Alias = alias.String\n\t\t\tif c.Alias != \"\" && ap[c.Alias] == tlMaxAuthorPosts {\n\t\t\t\t// Don't add post if we've hit the post-per-author limit\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tc.Public = true\n\t\t\tc.Title = title.String\n\t\t\tc.Monetization = app.db.GetCollectionAttribute(c.ID, \"monetization_pointer\")\n\t\t}\n\n\t\tp.extractData()\n\t\tp.handlePremiumContent(c, false, false, app.cfg)\n\t\tp.HTMLContent = template.HTML(applyMarkdown([]byte(p.Content), \"\", app.cfg))\n\t\tfp := p.processPost()\n\t\tif isCollectionPost {\n\t\t\tfp.Collection = &CollectionObj{Collection: *c}\n\t\t}\n\n\t\tposts = append(posts, fp)\n\t\tap[c.Alias]++\n\t}\n\n\treturn posts, nil\n}\n\nfunc viewLocalTimelineAPI(app *App, w http.ResponseWriter, r *http.Request) error {\n\tupdateTimelineCache(app.timeline, false)\n\n\tskip, _ := strconv.Atoi(r.FormValue(\"skip\"))\n\n\tposts := []PublicPost{}\n\tfor i := skip; i < skip+tlAPIPageLimit && i < len(*app.timeline.posts); i++ {\n\t\tposts = append(posts, (*app.timeline.posts)[i])\n\t}\n\n\treturn impart.WriteSuccess(w, posts, http.StatusOK)\n}\n\nfunc viewLocalTimeline(app *App, w http.ResponseWriter, r *http.Request) error {\n\tif !app.cfg.App.LocalTimeline {\n\t\treturn impart.HTTPError{http.StatusNotFound, \"Page doesn't exist.\"}\n\t}\n\n\tvars := mux.Vars(r)\n\tvar p int\n\tpage := 1\n\tp, _ = strconv.Atoi(vars[\"page\"])\n\tif p > 0 {\n\t\tpage = p\n\t}\n\n\treturn showLocalTimeline(app, w, r, page, vars[\"author\"], vars[\"tag\"])\n}\n\n// updateTimelineCache will reset and update the cache if it is stale or\n// the boolean passed in is true.\nfunc updateTimelineCache(tl *localTimeline, reset bool) {\n\tif reset {\n\t\ttl.m.Reset()\n\t}\n\n\t// Fetch posts if the cache is empty, has been reset or enough time has\n\t// passed since last cache.\n\tif tl.posts == nil || reset || tl.m.Invalidate() {\n\t\tlog.Info(\"[READ] Updating post cache\")\n\n\t\tpostsInterfaces, err := tl.m.Get()\n\t\tif err != nil {\n\t\t\tlog.Error(\"[READ] Unable to cache posts: %v\", err)\n\t\t} else {\n\t\t\tcastPosts := postsInterfaces.([]PublicPost)\n\t\t\ttl.posts = &castPosts\n\t\t}\n\t}\n\n}\n\nfunc showLocalTimeline(app *App, w http.ResponseWriter, r *http.Request, page int, author, tag string) error {\n\tupdateTimelineCache(app.timeline, false)\n\n\tpl := len(*(app.timeline.posts))\n\tttlPages := int(math.Ceil(float64(pl) / float64(app.timeline.postsPerPage)))\n\n\tstart := 0\n\tif page > 1 {\n\t\tstart = app.timeline.postsPerPage * (page - 1)\n\t\tif start > pl {\n\t\t\treturn impart.HTTPError{http.StatusFound, fmt.Sprintf(\"/read/p/%d\", ttlPages)}\n\t\t}\n\t}\n\tend := app.timeline.postsPerPage * page\n\tif end > pl {\n\t\tend = pl\n\t}\n\tvar posts []PublicPost\n\tif author != \"\" {\n\t\tposts = []PublicPost{}\n\t\tfor _, p := range *app.timeline.posts {\n\t\t\tif author == \"anonymous\" {\n\t\t\t\tif p.Collection == nil {\n\t\t\t\t\tposts = append(posts, p)\n\t\t\t\t}\n\t\t\t} else if p.Collection != nil && p.Collection.Alias == author {\n\t\t\t\tposts = append(posts, p)\n\t\t\t}\n\t\t}\n\t} else if tag != \"\" {\n\t\tposts = []PublicPost{}\n\t\tfor _, p := range *app.timeline.posts {\n\t\t\tif p.HasTag(tag) {\n\t\t\t\tposts = append(posts, p)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tposts = *app.timeline.posts\n\t\tposts = posts[start:end]\n\t}\n\n\td := &readPublication{\n\t\tStaticPage:  pageForReq(app, r),\n\t\tPosts:       &posts,\n\t\tCurrentPage: page,\n\t\tTotalPages:  ttlPages,\n\t\tSelTopic:    tag,\n\t}\n\tu := getUserSession(app, r)\n\td.IsAdmin = u != nil && u.IsAdmin()\n\td.CanInvite = canUserInvite(app.cfg, d.IsAdmin)\n\tc, err := getReaderSection(app)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.ContentTitle = c.Title.String\n\td.Content = template.HTML(applyMarkdown([]byte(c.Content), \"\", app.cfg))\n\n\terr = templates[\"read\"].ExecuteTemplate(w, \"base\", d)\n\tif err != nil {\n\t\tlog.Error(\"Unable to render reader: %v\", err)\n\t\tfmt.Fprintf(w, \":(\")\n\t}\n\treturn nil\n}\n\n// NextPageURL provides a full URL for the next page of collection posts\nfunc (c *readPublication) NextPageURL(n int) string {\n\treturn fmt.Sprintf(\"/read/p/%d\", n+1)\n}\n\n// PrevPageURL provides a full URL for the previous page of collection posts,\n// returning a /page/N result for pages >1\nfunc (c *readPublication) PrevPageURL(n int) string {\n\tif n == 2 {\n\t\t// Previous page is 1; no need for /p/ prefix\n\t\treturn \"/read\"\n\t}\n\treturn fmt.Sprintf(\"/read/p/%d\", n-1)\n}\n\n// handlePostIDRedirect handles a route where a post ID is given and redirects\n// the user to the canonical post URL.\nfunc handlePostIDRedirect(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\tpostID := vars[\"post\"]\n\tp, err := app.db.GetPost(postID, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !p.CollectionID.Valid {\n\t\t// No collection; send to normal URL\n\t\t// NOTE: not handling single user blogs here since this handler is only used for the Reader\n\t\treturn impart.HTTPError{http.StatusFound, app.cfg.App.Host + \"/\" + postID + \".md\"}\n\t}\n\n\tc, err := app.db.GetCollectionBy(\"id = ?\", fmt.Sprintf(\"%d\", p.CollectionID.Int64))\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\t// Retrieve collection information and send user to canonical URL\n\treturn impart.HTTPError{http.StatusFound, c.CanonicalURL() + p.Slug.String}\n}\n\nfunc viewLocalTimelineFeed(app *App, w http.ResponseWriter, req *http.Request) error {\n\tif !app.cfg.App.LocalTimeline {\n\t\treturn impart.HTTPError{http.StatusNotFound, \"Page doesn't exist.\"}\n\t}\n\n\tupdateTimelineCache(app.timeline, false)\n\n\tfeed := &Feed{\n\t\tTitle:       app.cfg.App.SiteName + \" Reader\",\n\t\tLink:        &Link{Href: app.cfg.App.Host},\n\t\tDescription: \"Read the latest posts from \" + app.cfg.App.SiteName + \".\",\n\t\tCreated:     time.Now(),\n\t}\n\n\tc := 0\n\tvar title, permalink, author string\n\tfor _, p := range *app.timeline.posts {\n\t\tif c == tlFeedLimit {\n\t\t\tbreak\n\t\t}\n\n\t\ttitle = p.PlainDisplayTitle()\n\t\tpermalink = p.CanonicalURL(app.cfg.App.Host)\n\t\tif p.Collection != nil {\n\t\t\tauthor = p.Collection.Title\n\t\t} else {\n\t\t\tauthor = \"Anonymous\"\n\t\t}\n\t\ti := &Item{\n\t\t\tId:          app.cfg.App.Host + \"/read/a/\" + p.ID,\n\t\t\tTitle:       title,\n\t\t\tLink:        &Link{Href: permalink},\n\t\t\tDescription: \"<![CDATA[\" + stripmd.Strip(p.Content) + \"]]>\",\n\t\t\tContent:     applyMarkdown([]byte(p.Content), \"\", app.cfg),\n\t\t\tAuthor:      &Author{author, \"\"},\n\t\t\tCreated:     p.Created,\n\t\t\tUpdated:     p.Updated,\n\t\t}\n\t\tfeed.Items = append(feed.Items, i)\n\t\tc++\n\t}\n\n\trss, err := feed.ToRss()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprint(w, rss)\n\treturn nil\n}\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 0.76953125,
          "content": "/*\n * Copyright © 2018 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"mime\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc IsJSON(r *http.Request) bool {\n\tct, _, _ := mime.ParseMediaType(r.Header.Get(\"Content-Type\"))\n\taccept := r.Header.Get(\"Accept\")\n\treturn ct == \"application/json\" || accept == \"application/json\"\n}\n\nfunc IsActivityPubRequest(r *http.Request) bool {\n\taccept := r.Header.Get(\"Accept\")\n\treturn strings.Contains(accept, \"application/activity+json\") ||\n\t\taccept == \"application/ld+json; profile=\\\"https://www.w3.org/ns/activitystreams\\\"\"\n}\n"
        },
        {
          "name": "routes.go",
          "type": "blob",
          "size": 13.396484375,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/gorilla/csrf\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/writeas/go-webfinger\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/go-nodeinfo\"\n)\n\n// InitStaticRoutes adds routes for serving static files.\n// TODO: this should just be a func, not method\nfunc (app *App) InitStaticRoutes(r *mux.Router) {\n\t// Handle static files\n\tfs := http.FileServer(http.Dir(filepath.Join(app.cfg.Server.StaticParentDir, staticDir)))\n\tfs = cacheControl(fs)\n\tapp.shttp = http.NewServeMux()\n\tapp.shttp.Handle(\"/\", fs)\n\tr.PathPrefix(\"/\").Handler(fs)\n}\n\n// InitRoutes adds dynamic routes for the given mux.Router.\nfunc InitRoutes(apper Apper, r *mux.Router) *mux.Router {\n\t// Create handler\n\thandler := NewWFHandler(apper)\n\n\t// Set up routes\n\thostSubroute := apper.App().cfg.App.Host[strings.Index(apper.App().cfg.App.Host, \"://\")+3:]\n\tif apper.App().cfg.App.SingleUser {\n\t\thostSubroute = \"{domain}\"\n\t} else {\n\t\tif strings.HasPrefix(hostSubroute, \"localhost\") {\n\t\t\thostSubroute = \"localhost\"\n\t\t}\n\t}\n\n\tif apper.App().cfg.App.SingleUser {\n\t\tlog.Info(\"Adding %s routes (single user)...\", hostSubroute)\n\t} else {\n\t\tlog.Info(\"Adding %s routes (multi-user)...\", hostSubroute)\n\t}\n\n\t// Primary app routes\n\twrite := r.PathPrefix(\"/\").Subrouter()\n\n\t// Federation endpoint configurations\n\twf := webfinger.Default(wfResolver{apper.App().db, apper.App().cfg})\n\twf.NoTLSHandler = nil\n\n\t// Federation endpoints\n\t// host-meta\n\twrite.HandleFunc(\"/.well-known/host-meta\", handler.Web(handleViewHostMeta, UserLevelReader))\n\t// webfinger\n\twrite.HandleFunc(webfinger.WebFingerPath, handler.LogHandlerFunc(http.HandlerFunc(wf.Webfinger)))\n\t// nodeinfo\n\tniCfg := nodeInfoConfig(apper.App().db, apper.App().cfg)\n\tni := nodeinfo.NewService(*niCfg, nodeInfoResolver{apper.App().cfg, apper.App().db})\n\twrite.HandleFunc(nodeinfo.NodeInfoPath, handler.LogHandlerFunc(http.HandlerFunc(ni.NodeInfoDiscover)))\n\twrite.HandleFunc(niCfg.InfoURL, handler.LogHandlerFunc(http.HandlerFunc(ni.NodeInfo)))\n\n\t// handle mentions\n\twrite.HandleFunc(\"/@/{handle}\", handler.Web(handleViewMention, UserLevelReader))\n\n\tconfigureSlackOauth(handler, write, apper.App())\n\tconfigureWriteAsOauth(handler, write, apper.App())\n\tconfigureGitlabOauth(handler, write, apper.App())\n\tconfigureGenericOauth(handler, write, apper.App())\n\tconfigureGiteaOauth(handler, write, apper.App())\n\n\t// Set up dynamic page handlers\n\t// Handle auth\n\tauth := write.PathPrefix(\"/api/auth/\").Subrouter()\n\tif apper.App().cfg.App.OpenRegistration {\n\t\tauth.HandleFunc(\"/signup\", handler.All(apiSignup)).Methods(\"POST\")\n\t}\n\tauth.HandleFunc(\"/login\", handler.All(login)).Methods(\"POST\")\n\tauth.HandleFunc(\"/read\", handler.WebErrors(handleWebCollectionUnlock, UserLevelNone)).Methods(\"POST\")\n\tauth.HandleFunc(\"/me\", handler.All(handleAPILogout)).Methods(\"DELETE\")\n\n\t// Handle logged in user sections\n\tme := write.PathPrefix(\"/me\").Subrouter()\n\tme.HandleFunc(\"/\", handler.Redirect(\"/me\", UserLevelUser))\n\tme.HandleFunc(\"/c\", handler.Redirect(\"/me/c/\", UserLevelUser)).Methods(\"GET\")\n\tme.HandleFunc(\"/c/\", handler.User(viewCollections)).Methods(\"GET\")\n\tme.HandleFunc(\"/c/{collection}\", handler.User(viewEditCollection)).Methods(\"GET\")\n\tme.HandleFunc(\"/c/{collection}/stats\", handler.User(viewStats)).Methods(\"GET\")\n\tme.HandleFunc(\"/c/{collection}/subscribers\", handler.User(handleViewSubscribers)).Methods(\"GET\")\n\tme.Path(\"/delete\").Handler(csrf.Protect(apper.App().keys.CSRFKey)(handler.User(handleUserDelete))).Methods(\"POST\")\n\tme.HandleFunc(\"/posts\", handler.Redirect(\"/me/posts/\", UserLevelUser)).Methods(\"GET\")\n\tme.HandleFunc(\"/posts/\", handler.User(viewArticles)).Methods(\"GET\")\n\tme.HandleFunc(\"/posts/export.csv\", handler.Download(viewExportPosts, UserLevelUser)).Methods(\"GET\")\n\tme.HandleFunc(\"/posts/export.zip\", handler.Download(viewExportPosts, UserLevelUser)).Methods(\"GET\")\n\tme.HandleFunc(\"/posts/export.json\", handler.Download(viewExportPosts, UserLevelUser)).Methods(\"GET\")\n\tme.HandleFunc(\"/export\", handler.User(viewExportOptions)).Methods(\"GET\")\n\tme.HandleFunc(\"/export.json\", handler.Download(viewExportFull, UserLevelUser)).Methods(\"GET\")\n\tme.HandleFunc(\"/import\", handler.User(viewImport)).Methods(\"GET\")\n\tme.Path(\"/settings\").Handler(csrf.Protect(apper.App().keys.CSRFKey)(handler.User(viewSettings))).Methods(\"GET\")\n\tme.HandleFunc(\"/invites\", handler.User(handleViewUserInvites)).Methods(\"GET\")\n\tme.HandleFunc(\"/logout\", handler.Web(viewLogout, UserLevelNone)).Methods(\"GET\")\n\n\twrite.HandleFunc(\"/api/me\", handler.All(viewMeAPI)).Methods(\"GET\")\n\tapiMe := write.PathPrefix(\"/api/me/\").Subrouter()\n\tapiMe.HandleFunc(\"/\", handler.All(viewMeAPI)).Methods(\"GET\")\n\tapiMe.HandleFunc(\"/posts\", handler.UserWebAPI(viewMyPostsAPI)).Methods(\"GET\")\n\tapiMe.HandleFunc(\"/collections\", handler.UserAPI(viewMyCollectionsAPI)).Methods(\"GET\")\n\tapiMe.HandleFunc(\"/password\", handler.All(updatePassphrase)).Methods(\"POST\")\n\tapiMe.HandleFunc(\"/self\", handler.All(updateSettings)).Methods(\"POST\")\n\tapiMe.HandleFunc(\"/invites\", handler.User(handleCreateUserInvite)).Methods(\"POST\")\n\tapiMe.HandleFunc(\"/import\", handler.User(handleImport)).Methods(\"POST\")\n\tapiMe.HandleFunc(\"/oauth/remove\", handler.User(removeOauth)).Methods(\"POST\")\n\n\t// Sign up validation\n\twrite.HandleFunc(\"/api/alias\", handler.All(handleUsernameCheck)).Methods(\"POST\")\n\n\twrite.HandleFunc(\"/api/markdown\", handler.All(handleRenderMarkdown)).Methods(\"POST\")\n\n\tinstanceURL, _ := url.Parse(apper.App().Config().App.Host)\n\thost := instanceURL.Host\n\n\t// Handle collections\n\twrite.HandleFunc(\"/api/collections\", handler.All(newCollection)).Methods(\"POST\")\n\tapiColls := write.PathPrefix(\"/api/collections/\").Subrouter()\n\tapiColls.HandleFunc(\"/monetization-pointer\", handler.PlainTextAPI(handleSPSPEndpoint)).Methods(\"GET\")\n\tapiColls.HandleFunc(\"/\"+host, handler.AllReader(fetchCollection)).Methods(\"GET\")\n\tapiColls.HandleFunc(\"/{alias:[0-9a-zA-Z\\\\-]+}\", handler.AllReader(fetchCollection)).Methods(\"GET\")\n\tapiColls.HandleFunc(\"/{alias:[0-9a-zA-Z\\\\-]+}\", handler.All(existingCollection)).Methods(\"POST\", \"DELETE\")\n\tapiColls.HandleFunc(\"/{alias}/posts\", handler.AllReader(fetchCollectionPosts)).Methods(\"GET\")\n\tapiColls.HandleFunc(\"/{alias}/posts\", handler.All(newPost)).Methods(\"POST\")\n\tapiColls.HandleFunc(\"/{alias}/posts/{post}\", handler.AllReader(fetchPost)).Methods(\"GET\")\n\tapiColls.HandleFunc(\"/{alias}/posts/{post:[a-zA-Z0-9]{10}}\", handler.All(existingPost)).Methods(\"POST\")\n\tapiColls.HandleFunc(\"/{alias}/posts/{post}/splitcontent\", handler.AllReader(handleGetSplitContent)).Methods(\"GET\", \"POST\")\n\tapiColls.HandleFunc(\"/{alias}/posts/{post}/{property}\", handler.AllReader(fetchPostProperty)).Methods(\"GET\")\n\tapiColls.HandleFunc(\"/{alias}/collect\", handler.All(addPost)).Methods(\"POST\")\n\tapiColls.HandleFunc(\"/{alias}/pin\", handler.All(pinPost)).Methods(\"POST\")\n\tapiColls.HandleFunc(\"/{alias}/unpin\", handler.All(pinPost)).Methods(\"POST\")\n\tapiColls.HandleFunc(\"/{alias}/email/subscribe\", handler.All(handleCreateEmailSubscription)).Methods(\"POST\")\n\tapiColls.HandleFunc(\"/{alias}/email/subscribe\", handler.All(handleDeleteEmailSubscription)).Methods(\"DELETE\")\n\tapiColls.HandleFunc(\"/{collection}/email/unsubscribe\", handler.All(handleDeleteEmailSubscription)).Methods(\"GET\")\n\tapiColls.HandleFunc(\"/{alias}/inbox\", handler.All(handleFetchCollectionInbox)).Methods(\"POST\")\n\tapiColls.HandleFunc(\"/{alias}/outbox\", handler.AllReader(handleFetchCollectionOutbox)).Methods(\"GET\")\n\tapiColls.HandleFunc(\"/{alias}/following\", handler.AllReader(handleFetchCollectionFollowing)).Methods(\"GET\")\n\tapiColls.HandleFunc(\"/{alias}/followers\", handler.AllReader(handleFetchCollectionFollowers)).Methods(\"GET\")\n\n\t// Handle posts\n\twrite.HandleFunc(\"/api/posts\", handler.All(newPost)).Methods(\"POST\")\n\tposts := write.PathPrefix(\"/api/posts/\").Subrouter()\n\tposts.HandleFunc(\"/{post:[a-zA-Z0-9]+}\", handler.AllReader(fetchPost)).Methods(\"GET\")\n\tposts.HandleFunc(\"/{post:[a-zA-Z0-9]+}\", handler.All(existingPost)).Methods(\"POST\", \"PUT\")\n\tposts.HandleFunc(\"/{post:[a-zA-Z0-9]+}\", handler.All(deletePost)).Methods(\"DELETE\")\n\tposts.HandleFunc(\"/{post:[a-zA-Z0-9]+}/{property}\", handler.AllReader(fetchPostProperty)).Methods(\"GET\")\n\tposts.HandleFunc(\"/claim\", handler.All(addPost)).Methods(\"POST\")\n\tposts.HandleFunc(\"/disperse\", handler.All(dispersePost)).Methods(\"POST\")\n\n\twrite.HandleFunc(\"/auth/signup\", handler.Web(handleWebSignup, UserLevelNoneRequired)).Methods(\"POST\")\n\twrite.HandleFunc(\"/auth/login\", handler.Web(webLogin, UserLevelNoneRequired)).Methods(\"POST\")\n\n\twrite.HandleFunc(\"/admin\", handler.Admin(handleViewAdminDash)).Methods(\"GET\")\n\twrite.HandleFunc(\"/admin/monitor\", handler.Admin(handleViewAdminMonitor)).Methods(\"GET\")\n\twrite.HandleFunc(\"/admin/settings\", handler.Admin(handleViewAdminSettings)).Methods(\"GET\")\n\twrite.HandleFunc(\"/admin/users\", handler.Admin(handleViewAdminUsers)).Methods(\"GET\")\n\twrite.HandleFunc(\"/admin/user/{username}\", handler.Admin(handleViewAdminUser)).Methods(\"GET\")\n\twrite.HandleFunc(\"/admin/user/{username}/delete\", handler.Admin(handleAdminDeleteUser)).Methods(\"POST\")\n\twrite.HandleFunc(\"/admin/user/{username}/status\", handler.Admin(handleAdminToggleUserStatus)).Methods(\"POST\")\n\twrite.HandleFunc(\"/admin/user/{username}/passphrase\", handler.Admin(handleAdminResetUserPass)).Methods(\"POST\")\n\twrite.HandleFunc(\"/admin/pages\", handler.Admin(handleViewAdminPages)).Methods(\"GET\")\n\twrite.HandleFunc(\"/admin/page/{slug}\", handler.Admin(handleViewAdminPage)).Methods(\"GET\")\n\twrite.HandleFunc(\"/admin/update/config\", handler.AdminApper(handleAdminUpdateConfig)).Methods(\"POST\")\n\twrite.HandleFunc(\"/admin/update/{page}\", handler.Admin(handleAdminUpdateSite)).Methods(\"POST\")\n\twrite.HandleFunc(\"/admin/updates\", handler.Admin(handleViewAdminUpdates)).Methods(\"GET\")\n\n\t// Handle special pages first\n\twrite.Path(\"/reset\").Handler(csrf.Protect(apper.App().keys.CSRFKey)(handler.Web(viewResetPassword, UserLevelNoneRequired)))\n\twrite.HandleFunc(\"/login\", handler.Web(viewLogin, UserLevelNoneRequired))\n\twrite.HandleFunc(\"/signup\", handler.Web(handleViewLanding, UserLevelNoneRequired))\n\twrite.HandleFunc(\"/invite/{code:[a-zA-Z0-9]+}\", handler.Web(handleViewInvite, UserLevelOptional)).Methods(\"GET\")\n\t// TODO: show a reader-specific 404 page if the function is disabled\n\twrite.HandleFunc(\"/read\", handler.Web(viewLocalTimeline, UserLevelReader))\n\tRouteRead(handler, UserLevelReader, write.PathPrefix(\"/read\").Subrouter())\n\n\tdraftEditPrefix := \"\"\n\tif apper.App().cfg.App.SingleUser {\n\t\tdraftEditPrefix = \"/d\"\n\t\twrite.HandleFunc(\"/me/new\", handler.Web(handleViewPad, UserLevelUser)).Methods(\"GET\")\n\t} else {\n\t\twrite.HandleFunc(\"/new\", handler.Web(handleViewPad, UserLevelUser)).Methods(\"GET\")\n\t}\n\n\t// All the existing stuff\n\twrite.HandleFunc(draftEditPrefix+\"/{action}/edit\", handler.Web(handleViewPad, UserLevelUser)).Methods(\"GET\")\n\twrite.HandleFunc(draftEditPrefix+\"/{action}/meta\", handler.Web(handleViewMeta, UserLevelUser)).Methods(\"GET\")\n\t// Collections\n\tif apper.App().cfg.App.SingleUser {\n\t\tRouteCollections(handler, write.PathPrefix(\"/\").Subrouter())\n\t} else {\n\t\twrite.HandleFunc(\"/{prefix:[@~$!\\\\-+]}{collection}\", handler.Web(handleViewCollection, UserLevelReader))\n\t\twrite.HandleFunc(\"/{collection}/\", handler.Web(handleViewCollection, UserLevelReader))\n\t\tRouteCollections(handler, write.PathPrefix(\"/{prefix:[@~$!\\\\-+]?}{collection}\").Subrouter())\n\t\t// Posts\n\t}\n\twrite.HandleFunc(draftEditPrefix+\"/{post}\", handler.Web(handleViewPost, UserLevelOptional))\n\twrite.HandleFunc(\"/\", handler.Web(handleViewHome, UserLevelOptional))\n\n\treturn r\n}\n\nfunc RouteCollections(handler *Handler, r *mux.Router) {\n\tr.HandleFunc(\"/logout\", handler.Web(handleLogOutCollection, UserLevelOptional))\n\tr.HandleFunc(\"/page/{page:[0-9]+}\", handler.Web(handleViewCollection, UserLevelReader))\n\tr.HandleFunc(\"/lang:{lang:[a-z]{2}}\", handler.Web(handleViewCollectionLang, UserLevelOptional))\n\tr.HandleFunc(\"/lang:{lang:[a-z]{2}}/page/{page:[0-9]+}\", handler.Web(handleViewCollectionLang, UserLevelOptional))\n\tr.HandleFunc(\"/tag:{tag}\", handler.Web(handleViewCollectionTag, UserLevelReader))\n\tr.HandleFunc(\"/tag:{tag}/page/{page:[0-9]+}\", handler.Web(handleViewCollectionTag, UserLevelReader))\n\tr.HandleFunc(\"/tag:{tag}/feed/\", handler.Web(ViewFeed, UserLevelReader))\n\tr.HandleFunc(\"/sitemap.xml\", handler.AllReader(handleViewSitemap))\n\tr.HandleFunc(\"/feed/\", handler.AllReader(ViewFeed))\n\tr.HandleFunc(\"/email/confirm/{subscriber}\", handler.All(handleConfirmEmailSubscription)).Methods(\"GET\")\n\tr.HandleFunc(\"/email/unsubscribe/{subscriber}\", handler.All(handleDeleteEmailSubscription)).Methods(\"GET\")\n\tr.HandleFunc(\"/{slug}\", handler.CollectionPostOrStatic)\n\tr.HandleFunc(\"/{slug}/edit\", handler.Web(handleViewPad, UserLevelUser))\n\tr.HandleFunc(\"/{slug}/edit/meta\", handler.Web(handleViewMeta, UserLevelUser))\n\tr.HandleFunc(\"/{slug}/\", handler.Web(handleCollectionPostRedirect, UserLevelReader)).Methods(\"GET\")\n}\n\nfunc RouteRead(handler *Handler, readPerm UserLevelFunc, r *mux.Router) {\n\tr.HandleFunc(\"/api/posts\", handler.Web(viewLocalTimelineAPI, readPerm))\n\tr.HandleFunc(\"/p/{page}\", handler.Web(viewLocalTimeline, readPerm))\n\tr.HandleFunc(\"/feed/\", handler.Web(viewLocalTimelineFeed, readPerm))\n\tr.HandleFunc(\"/t/{tag}\", handler.Web(viewLocalTimeline, readPerm))\n\tr.HandleFunc(\"/a/{post}\", handler.Web(handlePostIDRedirect, readPerm))\n\tr.HandleFunc(\"/{author}\", handler.Web(viewLocalTimeline, readPerm))\n\tr.HandleFunc(\"/\", handler.Web(viewLocalTimeline, readPerm))\n}\n"
        },
        {
          "name": "routes_test.go",
          "type": "blob",
          "size": 0.896484375,
          "content": "package writefreely\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc TestCacheControlForStaticFiles(t *testing.T) {\n\tapp := NewApp(\"testdata/config.ini\")\n\tif err := app.LoadConfig(); err != nil {\n\t\tt.Fatalf(\"Could not create an app; %v\", err)\n\t}\n\trouter := mux.NewRouter()\n\tapp.InitStaticRoutes(router)\n\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(\"GET\", \"/style.css\", nil)\n\trouter.ServeHTTP(rec, req)\n\tif code := rec.Result().StatusCode; code != http.StatusOK {\n\t\tt.Fatalf(\"Could not get /style.css, got HTTP status %d\", code)\n\t}\n\tactual := rec.Result().Header.Get(\"Cache-Control\")\n\n\texpectedDirectives := []string{\n\t\t\"public\",\n\t\t\"max-age\",\n\t\t\"immutable\",\n\t}\n\tfor _, expected := range expectedDirectives {\n\t\tif !strings.Contains(actual, expected) {\n\t\t\tt.Errorf(\"Expected Cache-Control header to contain '%s', but was '%s'\", expected, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "schema.sql",
          "type": "blob",
          "size": 6.765625,
          "content": "--\n-- Database: `writefreely`\n--\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `accesstokens`\n--\n\nCREATE TABLE IF NOT EXISTS `accesstokens` (\n  `token` binary(16) NOT NULL,\n  `user_id` int(6) NOT NULL,\n  `sudo` tinyint(1) NOT NULL DEFAULT '0',\n  `one_time` tinyint(1) NOT NULL DEFAULT '0',\n  `created` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  `expires` datetime DEFAULT NULL,\n  `user_agent` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`token`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `appcontent`\n--\n\nCREATE TABLE IF NOT EXISTS `appcontent` (\n  `id` varchar(36) NOT NULL,\n  `content` mediumtext CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,\n  `updated` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `appmigrations`\n--\n\nCREATE TABLE `appmigrations` (\n  `version` int(11) NOT NULL,\n  `migrated` datetime NOT NULL,\n  `result` text NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `collectionattributes`\n--\n\nCREATE TABLE IF NOT EXISTS `collectionattributes` (\n  `collection_id` int(6) NOT NULL,\n  `attribute` varchar(128) NOT NULL,\n  `value` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,\n  PRIMARY KEY (`collection_id`,`attribute`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `collectionkeys`\n--\n\nCREATE TABLE IF NOT EXISTS `collectionkeys` (\n  `collection_id` int(6) NOT NULL,\n  `public_key` blob NOT NULL,\n  `private_key` blob NOT NULL,\n  PRIMARY KEY (`collection_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `collectionpasswords`\n--\n\nCREATE TABLE IF NOT EXISTS `collectionpasswords` (\n  `collection_id` int(6) NOT NULL,\n  `password` char(60) NOT NULL,\n  PRIMARY KEY (`collection_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `collectionredirects`\n--\n\nCREATE TABLE IF NOT EXISTS `collectionredirects` (\n  `prev_alias` varchar(100) NOT NULL,\n  `new_alias` varchar(100) NOT NULL,\n  PRIMARY KEY (`prev_alias`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `collections`\n--\n\nCREATE TABLE IF NOT EXISTS `collections` (\n  `id` int(6) NOT NULL AUTO_INCREMENT,\n  `alias` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,\n  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,\n  `description` varchar(160) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,\n  `style_sheet` text,\n  `script` text CHARACTER SET utf8mb4 COLLATE utf8mb4_bin,\n  `format` varchar(8) DEFAULT NULL,\n  `privacy` tinyint(1) NOT NULL,\n  `owner_id` int(6) NOT NULL,\n  `view_count` int(6) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `alias` (`alias`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `posts`\n--\n\nCREATE TABLE IF NOT EXISTS `posts` (\n  `id` char(16) NOT NULL,\n  `slug` varchar(100) DEFAULT NULL,\n  `modify_token` char(32) DEFAULT NULL,\n  `text_appearance` char(4) NOT NULL DEFAULT 'norm',\n  `language` char(2) DEFAULT NULL,\n  `rtl` tinyint(1) DEFAULT NULL,\n  `privacy` tinyint(1) NOT NULL,\n  `owner_id` int(6) DEFAULT NULL,\n  `collection_id` int(6) DEFAULT NULL,\n  `pinned_position` tinyint(1) UNSIGNED DEFAULT NULL,\n  `created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  `updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  `view_count` int(6) NOT NULL,\n  `title` varchar(160) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,\n  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `id_slug` (`collection_id`,`slug`),\n  UNIQUE KEY `owner_id` (`owner_id`,`id`),\n  KEY `privacy_id` (`privacy`,`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `remotefollows`\n--\n\nCREATE TABLE IF NOT EXISTS `remotefollows` (\n  `collection_id` int(11) NOT NULL,\n  `remote_user_id` int(11) NOT NULL,\n  `created` datetime NOT NULL,\n  PRIMARY KEY (`collection_id`,`remote_user_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `remoteuserkeys`\n--\n\nCREATE TABLE IF NOT EXISTS `remoteuserkeys` (\n  `id` varchar(255) NOT NULL,\n  `remote_user_id` int(11) NOT NULL,\n  `public_key` blob NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `follower_id` (`remote_user_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `remoteusers`\n--\n\nCREATE TABLE IF NOT EXISTS `remoteusers` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `actor_id` varchar(255) NOT NULL,\n  `inbox` varchar(255) NOT NULL,\n  `shared_inbox` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `collection_id` (`actor_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `userattributes`\n--\n\nCREATE TABLE IF NOT EXISTS `userattributes` (\n  `user_id` int(6) NOT NULL,\n  `attribute` varchar(64) NOT NULL,\n  `value` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,\n  PRIMARY KEY (`user_id`,`attribute`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `userinvites`\n--\n\nCREATE TABLE `userinvites` (\n  `id` char(6) NOT NULL,\n  `owner_id` int(11) NOT NULL,\n  `max_uses` smallint(6) DEFAULT NULL,\n  `created` datetime NOT NULL,\n  `expires` datetime DEFAULT NULL,\n  `inactive` tinyint(1) NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `users`\n--\n\nCREATE TABLE IF NOT EXISTS `users` (\n  `id` int(6) NOT NULL AUTO_INCREMENT,\n  `username` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,\n  `password` char(60) CHARACTER SET latin1 COLLATE latin1_bin NOT NULL,\n  `email` varbinary(255) DEFAULT NULL,\n  `created` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `username` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `usersinvited`\n--\n\nCREATE TABLE `usersinvited` (\n  `invite_id` char(6) NOT NULL,\n  `user_id` int(11) NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "semver.go",
          "type": "blob",
          "size": 6.6591796875,
          "content": "// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package semver implements comparison of semantic version strings.\n// In this package, semantic version strings must begin with a leading \"v\",\n// as in \"v1.0.0\".\n//\n// The general form of a semantic version string accepted by this package is\n//\n//\tvMAJOR[.MINOR[.PATCH[-PRERELEASE][+BUILD]]]\n//\n// where square brackets indicate optional parts of the syntax;\n// MAJOR, MINOR, and PATCH are decimal integers without extra leading zeros;\n// PRERELEASE and BUILD are each a series of non-empty dot-separated identifiers\n// using only alphanumeric characters and hyphens; and\n// all-numeric PRERELEASE identifiers must not have leading zeros.\n//\n// This package follows Semantic Versioning 2.0.0 (see semver.org)\n// with two exceptions. First, it requires the \"v\" prefix. Second, it recognizes\n// vMAJOR and vMAJOR.MINOR (with no prerelease or build suffixes)\n// as shorthands for vMAJOR.0.0 and vMAJOR.MINOR.0.\n\n// Package writefreely\n// copied from\n// https://github.com/golang/tools/blob/master/internal/semver/semver.go\n// slight modifications made\npackage writefreely\n\n// parsed returns the parsed form of a semantic version string.\ntype parsed struct {\n\tmajor      string\n\tminor      string\n\tpatch      string\n\tshort      string\n\tprerelease string\n\tbuild      string\n\terr        string\n}\n\n// IsValid reports whether v is a valid semantic version string.\nfunc IsValid(v string) bool {\n\t_, ok := semParse(v)\n\treturn ok\n}\n\n// CompareSemver returns an integer comparing two versions according to\n// according to semantic version precedence.\n// The result will be 0 if v == w, -1 if v < w, or +1 if v > w.\n//\n// An invalid semantic version string is considered less than a valid one.\n// All invalid semantic version strings compare equal to each other.\nfunc CompareSemver(v, w string) int {\n\tpv, ok1 := semParse(v)\n\tpw, ok2 := semParse(w)\n\tif !ok1 && !ok2 {\n\t\treturn 0\n\t}\n\tif !ok1 {\n\t\treturn -1\n\t}\n\tif !ok2 {\n\t\treturn +1\n\t}\n\tif c := compareInt(pv.major, pw.major); c != 0 {\n\t\treturn c\n\t}\n\tif c := compareInt(pv.minor, pw.minor); c != 0 {\n\t\treturn c\n\t}\n\tif c := compareInt(pv.patch, pw.patch); c != 0 {\n\t\treturn c\n\t}\n\treturn comparePrerelease(pv.prerelease, pw.prerelease)\n}\n\nfunc semParse(v string) (p parsed, ok bool) {\n\tif v == \"\" || v[0] != 'v' {\n\t\tp.err = \"missing v prefix\"\n\t\treturn\n\t}\n\tp.major, v, ok = parseInt(v[1:])\n\tif !ok {\n\t\tp.err = \"bad major version\"\n\t\treturn\n\t}\n\tif v == \"\" {\n\t\tp.minor = \"0\"\n\t\tp.patch = \"0\"\n\t\tp.short = \".0.0\"\n\t\treturn\n\t}\n\tif v[0] != '.' {\n\t\tp.err = \"bad minor prefix\"\n\t\tok = false\n\t\treturn\n\t}\n\tp.minor, v, ok = parseInt(v[1:])\n\tif !ok {\n\t\tp.err = \"bad minor version\"\n\t\treturn\n\t}\n\tif v == \"\" {\n\t\tp.patch = \"0\"\n\t\tp.short = \".0\"\n\t\treturn\n\t}\n\tif v[0] != '.' {\n\t\tp.err = \"bad patch prefix\"\n\t\tok = false\n\t\treturn\n\t}\n\tp.patch, v, ok = parseInt(v[1:])\n\tif !ok {\n\t\tp.err = \"bad patch version\"\n\t\treturn\n\t}\n\tif len(v) > 0 && v[0] == '-' {\n\t\tp.prerelease, v, ok = parsePrerelease(v)\n\t\tif !ok {\n\t\t\tp.err = \"bad prerelease\"\n\t\t\treturn\n\t\t}\n\t}\n\tif len(v) > 0 && v[0] == '+' {\n\t\tp.build, v, ok = parseBuild(v)\n\t\tif !ok {\n\t\t\tp.err = \"bad build\"\n\t\t\treturn\n\t\t}\n\t}\n\tif v != \"\" {\n\t\tp.err = \"junk on end\"\n\t\tok = false\n\t\treturn\n\t}\n\tok = true\n\treturn\n}\n\nfunc parseInt(v string) (t, rest string, ok bool) {\n\tif v == \"\" {\n\t\treturn\n\t}\n\tif v[0] < '0' || '9' < v[0] {\n\t\treturn\n\t}\n\ti := 1\n\tfor i < len(v) && '0' <= v[i] && v[i] <= '9' {\n\t\ti++\n\t}\n\tif v[0] == '0' && i != 1 {\n\t\treturn\n\t}\n\treturn v[:i], v[i:], true\n}\n\nfunc parsePrerelease(v string) (t, rest string, ok bool) {\n\t// \"A pre-release version MAY be denoted by appending a hyphen and\n\t// a series of dot separated identifiers immediately following the patch version.\n\t// Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].\n\t// Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes.\"\n\tif v == \"\" || v[0] != '-' {\n\t\treturn\n\t}\n\ti := 1\n\tstart := 1\n\tfor i < len(v) && v[i] != '+' {\n\t\tif !isIdentChar(v[i]) && v[i] != '.' {\n\t\t\treturn\n\t\t}\n\t\tif v[i] == '.' {\n\t\t\tif start == i || isBadNum(v[start:i]) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tstart = i + 1\n\t\t}\n\t\ti++\n\t}\n\tif start == i || isBadNum(v[start:i]) {\n\t\treturn\n\t}\n\treturn v[:i], v[i:], true\n}\n\nfunc parseBuild(v string) (t, rest string, ok bool) {\n\tif v == \"\" || v[0] != '+' {\n\t\treturn\n\t}\n\ti := 1\n\tstart := 1\n\tfor i < len(v) {\n\t\tif !isIdentChar(v[i]) {\n\t\t\treturn\n\t\t}\n\t\tif v[i] == '.' {\n\t\t\tif start == i {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tstart = i + 1\n\t\t}\n\t\ti++\n\t}\n\tif start == i {\n\t\treturn\n\t}\n\treturn v[:i], v[i:], true\n}\n\nfunc isIdentChar(c byte) bool {\n\treturn 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' || c == '-'\n}\n\nfunc isBadNum(v string) bool {\n\ti := 0\n\tfor i < len(v) && '0' <= v[i] && v[i] <= '9' {\n\t\ti++\n\t}\n\treturn i == len(v) && i > 1 && v[0] == '0'\n}\n\nfunc isNum(v string) bool {\n\ti := 0\n\tfor i < len(v) && '0' <= v[i] && v[i] <= '9' {\n\t\ti++\n\t}\n\treturn i == len(v)\n}\n\nfunc compareInt(x, y string) int {\n\tif x == y {\n\t\treturn 0\n\t}\n\tif len(x) < len(y) {\n\t\treturn -1\n\t}\n\tif len(x) > len(y) {\n\t\treturn +1\n\t}\n\tif x < y {\n\t\treturn -1\n\t} else {\n\t\treturn +1\n\t}\n}\n\nfunc comparePrerelease(x, y string) int {\n\t// \"When major, minor, and patch are equal, a pre-release version has\n\t// lower precedence than a normal version.\n\t// Example: 1.0.0-alpha < 1.0.0.\n\t// Precedence for two pre-release versions with the same major, minor,\n\t// and patch version MUST be determined by comparing each dot separated\n\t// identifier from left to right until a difference is found as follows:\n\t// identifiers consisting of only digits are compared numerically and\n\t// identifiers with letters or hyphens are compared lexically in ASCII\n\t// sort order. Numeric identifiers always have lower precedence than\n\t// non-numeric identifiers. A larger set of pre-release fields has a\n\t// higher precedence than a smaller set, if all of the preceding\n\t// identifiers are equal.\n\t// Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta <\n\t// 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\"\n\tif x == y {\n\t\treturn 0\n\t}\n\tif x == \"\" {\n\t\treturn +1\n\t}\n\tif y == \"\" {\n\t\treturn -1\n\t}\n\tfor x != \"\" && y != \"\" {\n\t\tx = x[1:] // skip - or .\n\t\ty = y[1:] // skip - or .\n\t\tvar dx, dy string\n\t\tdx, x = nextIdent(x)\n\t\tdy, y = nextIdent(y)\n\t\tif dx != dy {\n\t\t\tix := isNum(dx)\n\t\t\tiy := isNum(dy)\n\t\t\tif ix != iy {\n\t\t\t\tif ix {\n\t\t\t\t\treturn -1\n\t\t\t\t} else {\n\t\t\t\t\treturn +1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ix {\n\t\t\t\tif len(dx) < len(dy) {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\t\tif len(dx) > len(dy) {\n\t\t\t\t\treturn +1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif dx < dy {\n\t\t\t\treturn -1\n\t\t\t} else {\n\t\t\t\treturn +1\n\t\t\t}\n\t\t}\n\t}\n\tif x == \"\" {\n\t\treturn -1\n\t} else {\n\t\treturn +1\n\t}\n}\n\nfunc nextIdent(x string) (dx, rest string) {\n\ti := 0\n\tfor i < len(x) && x[i] != '.' {\n\t\ti++\n\t}\n\treturn x[:i], x[i:]\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 3.2451171875,
          "content": "/*\n * Copyright © 2018-2019 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"encoding/gob\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/writeas/web-core/log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nconst (\n\tday           = 86400\n\tsessionLength = 180 * day\n\n\tuserEmailCookieName = \"ue\"\n\tuserEmailCookieVal  = \"email\"\n\n\tcookieName    = \"wfu\"\n\tcookieUserVal = \"u\"\n\n\tblogPassCookieName = \"ub\"\n)\n\n// InitSession creates the cookie store. It depends on the keychain already\n// being loaded.\nfunc (app *App) InitSession() {\n\t// Register complex data types we'll be storing in cookies\n\tgob.Register(&User{})\n\n\t// Create the cookie store\n\tstore := sessions.NewCookieStore(app.keys.CookieAuthKey, app.keys.CookieKey)\n\tstore.Options = &sessions.Options{\n\t\tPath:     \"/\",\n\t\tMaxAge:   sessionLength,\n\t\tHttpOnly: true,\n\t\tSecure:   strings.HasPrefix(app.cfg.App.Host, \"https://\"),\n\t}\n\tif store.Options.Secure {\n\t\tstore.Options.SameSite = http.SameSiteNoneMode\n\t}\n\tapp.sessionStore = store\n}\n\nfunc getSessionFlashes(app *App, w http.ResponseWriter, r *http.Request, session *sessions.Session) ([]string, error) {\n\tvar err error\n\tif session == nil {\n\t\tsession, err = app.sessionStore.Get(r, cookieName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tf := []string{}\n\tif flashes := session.Flashes(); len(flashes) > 0 {\n\t\tfor _, flash := range flashes {\n\t\t\tif str, ok := flash.(string); ok {\n\t\t\t\tf = append(f, str)\n\t\t\t}\n\t\t}\n\t}\n\tsaveUserSession(app, r, w)\n\n\treturn f, nil\n}\n\nfunc addSessionFlash(app *App, w http.ResponseWriter, r *http.Request, m string, session *sessions.Session) error {\n\tvar err error\n\tif session == nil {\n\t\tsession, err = app.sessionStore.Get(r, cookieName)\n\t}\n\n\tif err != nil {\n\t\tlog.Error(\"Unable to add flash '%s': %v\", m, err)\n\t\treturn err\n\t}\n\n\tsession.AddFlash(m)\n\tsaveUserSession(app, r, w)\n\treturn nil\n}\n\nfunc getUserAndSession(app *App, r *http.Request) (*User, *sessions.Session) {\n\tsession, err := app.sessionStore.Get(r, cookieName)\n\tif err == nil {\n\t\t// Got the currently logged-in user\n\t\tval := session.Values[cookieUserVal]\n\t\tvar u = &User{}\n\t\tvar ok bool\n\t\tif u, ok = val.(*User); ok {\n\t\t\treturn u, session\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n\nfunc getUserSession(app *App, r *http.Request) *User {\n\tu, _ := getUserAndSession(app, r)\n\treturn u\n}\n\nfunc saveUserSession(app *App, r *http.Request, w http.ResponseWriter) error {\n\tsession, err := app.sessionStore.Get(r, cookieName)\n\tif err != nil {\n\t\treturn ErrInternalCookieSession\n\t}\n\n\t// Extend the session\n\tsession.Options.MaxAge = int(sessionLength)\n\n\t// Remove any information that accidentally got added\n\t// FIXME: find where Plan information is getting saved to cookie.\n\tval := session.Values[cookieUserVal]\n\tvar u = &User{}\n\tvar ok bool\n\tif u, ok = val.(*User); ok {\n\t\tsession.Values[cookieUserVal] = u.Cookie()\n\t}\n\n\terr = session.Save(r, w)\n\tif err != nil {\n\t\tlog.Error(\"Couldn't saveUserSession: %v\", err)\n\t}\n\treturn err\n}\n\nfunc getFullUserSession(app *App, r *http.Request) (*User, error) {\n\tu := getUserSession(app, r)\n\tif u == nil {\n\t\treturn nil, nil\n\t}\n\n\tvar err error\n\tu, err = app.db.GetUserByID(u.ID)\n\treturn u, err\n}\n"
        },
        {
          "name": "sitemap.go",
          "type": "blob",
          "size": 2.1396484375,
          "content": "/*\n * Copyright © 2018-2019 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/ikeikeikeike/go-sitemap-generator/v2/stm\"\n\t\"github.com/writeas/web-core/log\"\n)\n\nfunc buildSitemap(host, alias string) *stm.Sitemap {\n\tsm := stm.NewSitemap(0)\n\tsm.SetDefaultHost(host)\n\tif alias != \"/\" {\n\t\tsm.SetSitemapsPath(alias)\n\t}\n\n\tsm.Create()\n\n\t// Note: Do not call `sm.Finalize()` because it flushes\n\t// the underlying datastructure from memory to disk.\n\n\treturn sm\n}\n\nfunc handleViewSitemap(app *App, w http.ResponseWriter, r *http.Request) error {\n\tvars := mux.Vars(r)\n\n\t// Determine canonical blog URL\n\talias := vars[\"collection\"]\n\tsubdomain := vars[\"subdomain\"]\n\tisSubdomain := subdomain != \"\"\n\tif isSubdomain {\n\t\talias = subdomain\n\t}\n\n\thost := fmt.Sprintf(\"%s/%s/\", app.cfg.App.Host, alias)\n\tvar c *Collection\n\tvar err error\n\tpre := \"/\"\n\tif app.cfg.App.SingleUser {\n\t\tc, err = app.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = app.db.GetCollection(alias)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.hostName = app.cfg.App.Host\n\n\tif !isSubdomain {\n\t\tpre += alias + \"/\"\n\t}\n\thost = c.CanonicalURL()\n\n\tsm := buildSitemap(host, pre)\n\tposts, err := app.db.GetPosts(app.cfg, c, 0, false, false, false)\n\tif err != nil {\n\t\tlog.Error(\"Error getting posts: %v\", err)\n\t\treturn err\n\t}\n\tlastSiteMod := time.Now()\n\tfor i, p := range *posts {\n\t\tif i == 0 {\n\t\t\tlastSiteMod = p.Updated\n\t\t}\n\t\tu := stm.URL{\n\t\t\t{\"loc\", p.Slug.String},\n\t\t\t{\"changefreq\", \"weekly\"},\n\t\t\t{\"mobile\", true},\n\t\t\t{\"lastmod\", p.Updated},\n\t\t}\n\t\tif len(p.Images) > 0 {\n\t\t\timgs := []stm.URL{}\n\t\t\tfor _, i := range p.Images {\n\t\t\t\timgs = append(imgs, stm.URL{\n\t\t\t\t\t{\"loc\", i},\n\t\t\t\t\t{\"title\", \"\"},\n\t\t\t\t})\n\t\t\t}\n\t\t\tu = append(u, []interface{}{\"image\", imgs})\n\t\t}\n\t\tsm.Add(u)\n\t}\n\n\t// Add top URL\n\tsm.Add(stm.URL{\n\t\t{\"loc\", pre},\n\t\t{\"changefreq\", \"daily\"},\n\t\t{\"priority\", \"1.0\"},\n\t\t{\"lastmod\", lastSiteMod},\n\t})\n\n\tw.Write(sm.XMLContent())\n\n\treturn nil\n}\n"
        },
        {
          "name": "spam",
          "type": "tree",
          "content": null
        },
        {
          "name": "sqlite.sql",
          "type": "blob",
          "size": 5.16796875,
          "content": "--\n-- Database: writefreely\n--\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table accesstokens\n--\n\nCREATE TABLE IF NOT EXISTS `accesstokens` (\n  token TEXT NOT NULL PRIMARY KEY,\n  user_id INTEGER NOT NULL,\n  sudo INTEGER NOT NULL DEFAULT '0',\n  one_time INTEGER NOT NULL DEFAULT '0',\n  created DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  expires DATETIME DEFAULT NULL,\n  user_agent TEXT DEFAULT NULL\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table appcontent\n--\n\nCREATE TABLE IF NOT EXISTS `appcontent` (\n  id TEXT NOT NULL PRIMARY KEY,\n  content TEXT NOT NULL,\n  updated DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table appmigrations\n--\n\nCREATE TABLE `appmigrations` (\n  `version` INT NOT NULL,\n  `migrated` DATETIME NOT NULL,\n  `result` TEXT NOT NULL\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table collectionattributes\n--\n\nCREATE TABLE IF NOT EXISTS `collectionattributes` (\n  collection_id INTEGER NOT NULL,\n  attribute TEXT NOT NULL,\n  value TEXT NOT NULL,\n  PRIMARY KEY (collection_id, attribute)\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table collectionkeys\n--\n\nCREATE TABLE IF NOT EXISTS `collectionkeys` (\n  collection_id INTEGER PRIMARY KEY,\n  public_key blob NOT NULL,\n  private_key blob NOT NULL\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table collectionpasswords\n--\n\nCREATE TABLE IF NOT EXISTS `collectionpasswords` (\n  collection_id INTEGER PRIMARY KEY,\n  password TEXT NOT NULL\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table collectionredirects\n--\n\nCREATE TABLE IF NOT EXISTS `collectionredirects` (\n  prev_alias TEXT NOT NULL PRIMARY KEY,\n  new_alias TEXT NOT NULL\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table collections\n--\n\nCREATE TABLE IF NOT EXISTS `collections` (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  alias TEXT DEFAULT NULL UNIQUE,\n  title TEXT NOT NULL,\n  description TEXT NOT NULL,\n  style_sheet TEXT,\n  script TEXT,\n  format TEXT DEFAULT NULL,\n  privacy INTEGER NOT NULL,\n  owner_id INTEGER NOT NULL,\n  view_count INTEGER NOT NULL\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table posts\n--\n\nCREATE TABLE IF NOT EXISTS `posts` (\n  id TEXT NOT NULL,\n  slug TEXT DEFAULT NULL,\n  modify_token TEXT DEFAULT NULL,\n  text_appearance TEXT NOT NULL DEFAULT 'norm',\n  language TEXT DEFAULT NULL,\n  rtl INTEGER DEFAULT NULL,\n  privacy INTEGER NOT NULL,\n  owner_id INTEGER DEFAULT NULL,\n  collection_id INTEGER DEFAULT NULL,\n  pinned_position INTEGER UNSIGNED DEFAULT NULL,\n  created DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  updated DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  view_count INTEGER NOT NULL,\n  title TEXT NOT NULL,\n  content TEXT NOT NULL,\n  CONSTRAINT id_slug UNIQUE (collection_id, slug),\n  CONSTRAINT owner_id UNIQUE (owner_id, id),\n  CONSTRAINT privacy_id UNIQUE (privacy, id)\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table remotefollows\n--\n\nCREATE TABLE IF NOT EXISTS `remotefollows` (\n  collection_id INTEGER NOT NULL,\n  remote_user_id INTEGER NOT NULL,\n  created DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY (collection_id,remote_user_id)\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table remoteuserkeys\n--\n\nCREATE TABLE IF NOT EXISTS `remoteuserkeys` (\n  id TEXT NOT NULL,\n  remote_user_id INTEGER NOT NULL,\n  public_key blob NOT NULL,\n  CONSTRAINT follower_id UNIQUE (remote_user_id)\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table remoteusers\n--\n\nCREATE TABLE IF NOT EXISTS `remoteusers` (\n  id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n  actor_id TEXT NOT NULL,\n  inbox TEXT NOT NULL,\n  shared_inbox TEXT NOT NULL,\n  CONSTRAINT collection_id UNIQUE (actor_id)\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table userattributes\n--\n\nCREATE TABLE IF NOT EXISTS `userattributes` (\n  user_id INTEGER NOT NULL,\n  attribute TEXT NOT NULL,\n  value TEXT NOT NULL,\n  PRIMARY KEY (user_id, attribute)\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `userinvites`\n--\n\nCREATE TABLE `userinvites` (\n  `id` TEXT NOT NULL,\n  `owner_id` INTEGER NOT NULL,\n  `max_uses` INTEGER DEFAULT NULL,\n  `created` DATETIME NOT NULL,\n  `expires` DATETIME DEFAULT NULL,\n  `inactive` INTEGER NOT NULL\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table users\n--\n\nCREATE TABLE IF NOT EXISTS `users` (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  username TEXT NOT NULL UNIQUE,\n  password TEXT NOT NULL,\n  email TEXT DEFAULT NULL,\n  created DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `usersinvited`\n--\n\nCREATE TABLE `usersinvited` (\n  `invite_id` TEXT NOT NULL,\n  `user_id` INTEGER NOT NULL\n);\n"
        },
        {
          "name": "static",
          "type": "tree",
          "content": null
        },
        {
          "name": "templates.go",
          "type": "blob",
          "size": 6.6806640625,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"errors\"\n\t\"html/template\"\n\t\"io\"\n\t\"os\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/dustin/go-humanize\"\n\t\"github.com/writeas/web-core/l10n\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/config\"\n)\n\nvar (\n\ttemplates = map[string]*template.Template{}\n\tpages     = map[string]*template.Template{}\n\tuserPages = map[string]*template.Template{}\n\tfuncMap   = template.FuncMap{\n\t\t\"largeNumFmt\": largeNumFmt,\n\t\t\"pluralize\":   pluralize,\n\t\t\"isRTL\":       isRTL,\n\t\t\"isLTR\":       isLTR,\n\t\t\"localstr\":    localStr,\n\t\t\"localhtml\":   localHTML,\n\t\t\"tolower\":     strings.ToLower,\n\t\t\"title\":       strings.Title,\n\t\t\"hasPrefix\":   strings.HasPrefix,\n\t\t\"hasSuffix\":   strings.HasSuffix,\n\t\t\"dict\":        dict,\n\t}\n)\n\nconst (\n\ttemplatesDir = \"templates\"\n\tpagesDir     = \"pages\"\n)\n\nfunc showUserPage(w http.ResponseWriter, name string, obj interface{}) {\n\tif obj == nil {\n\t\tlog.Error(\"showUserPage: data is nil!\")\n\t\treturn\n\t}\n\tif err := userPages[filepath.Join(\"user\", name+\".tmpl\")].ExecuteTemplate(w, name, obj); err != nil {\n\t\tlog.Error(\"Error parsing %s: %v\", name, err)\n\t}\n}\n\nfunc initTemplate(parentDir, name string) {\n\tif debugging {\n\t\tlog.Info(\"  \" + filepath.Join(parentDir, templatesDir, name+\".tmpl\"))\n\t}\n\n\tfiles := []string{\n\t\tfilepath.Join(parentDir, templatesDir, name+\".tmpl\"),\n\t\tfilepath.Join(parentDir, templatesDir, \"include\", \"footer.tmpl\"),\n\t\tfilepath.Join(parentDir, templatesDir, \"base.tmpl\"),\n\t\tfilepath.Join(parentDir, templatesDir, \"user\", \"include\", \"silenced.tmpl\"),\n\t}\n\tif name == \"collection\" || name == \"collection-tags\" || name == \"chorus-collection\" || name == \"read\" {\n\t\t// These pages list out collection posts, so we also parse templatesDir + \"include/posts.tmpl\"\n\t\tfiles = append(files, filepath.Join(parentDir, templatesDir, \"include\", \"posts.tmpl\"))\n\t}\n\tif name == \"chorus-collection\" || name == \"chorus-collection-post\" {\n\t\tfiles = append(files, filepath.Join(parentDir, templatesDir, \"user\", \"include\", \"header.tmpl\"))\n\t}\n\tif name == \"collection\" || name == \"collection-tags\" || name == \"collection-post\" || name == \"post\" || name == \"chorus-collection\" || name == \"chorus-collection-post\" {\n\t\tfiles = append(files, filepath.Join(parentDir, templatesDir, \"include\", \"post-render.tmpl\"))\n\t}\n\ttemplates[name] = template.Must(template.New(\"\").Funcs(funcMap).ParseFiles(files...))\n}\n\nfunc initPage(parentDir, path, key string) {\n\tif debugging {\n\t\tlog.Info(\"  [%s] %s\", key, path)\n\t}\n\n\tfiles := []string{\n\t\tpath,\n\t\tfilepath.Join(parentDir, templatesDir, \"include\", \"footer.tmpl\"),\n\t\tfilepath.Join(parentDir, templatesDir, \"base.tmpl\"),\n\t\tfilepath.Join(parentDir, templatesDir, \"user\", \"include\", \"silenced.tmpl\"),\n\t}\n\n\tif key == \"login.tmpl\" || key == \"landing.tmpl\" || key == \"signup.tmpl\" {\n\t\tfiles = append(files, filepath.Join(parentDir, templatesDir, \"include\", \"oauth.tmpl\"))\n\t}\n\n\tpages[key] = template.Must(template.New(\"\").Funcs(funcMap).ParseFiles(files...))\n}\n\nfunc initUserPage(parentDir, path, key string) {\n\tif debugging {\n\t\tlog.Info(\"  [%s] %s\", key, path)\n\t}\n\n\tuserPages[key] = template.Must(template.New(key).Funcs(funcMap).ParseFiles(\n\t\tpath,\n\t\tfilepath.Join(parentDir, templatesDir, \"user\", \"include\", \"header.tmpl\"),\n\t\tfilepath.Join(parentDir, templatesDir, \"user\", \"include\", \"footer.tmpl\"),\n\t\tfilepath.Join(parentDir, templatesDir, \"user\", \"include\", \"silenced.tmpl\"),\n\t\tfilepath.Join(parentDir, templatesDir, \"user\", \"include\", \"nav.tmpl\"),\n\t))\n}\n\n// InitTemplates loads all template files from the configured parent dir.\nfunc InitTemplates(cfg *config.Config) error {\n\tlog.Info(\"Loading templates...\")\n\ttmplFiles, err := os.ReadDir(filepath.Join(cfg.Server.TemplatesParentDir, templatesDir))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, f := range tmplFiles {\n\t\tif !f.IsDir() && !strings.HasPrefix(f.Name(), \".\") {\n\t\t\tparts := strings.Split(f.Name(), \".\")\n\t\t\tkey := parts[0]\n\t\t\tinitTemplate(cfg.Server.TemplatesParentDir, key)\n\t\t}\n\t}\n\n\tlog.Info(\"Loading pages...\")\n\t// Initialize all static pages that use the base template\n\terr = filepath.Walk(filepath.Join(cfg.Server.PagesParentDir, pagesDir), func(path string, i os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !i.IsDir() && !strings.HasPrefix(i.Name(), \".\") {\n\t\t\tkey := i.Name()\n\t\t\tinitPage(cfg.Server.PagesParentDir, path, key)\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Info(\"Loading user pages...\")\n\t// Initialize all user pages that use base templates\n\terr = filepath.Walk(filepath.Join(cfg.Server.TemplatesParentDir, templatesDir, \"user\"), func(path string, f os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !f.IsDir() && !strings.HasPrefix(f.Name(), \".\") {\n\t\t\tcorePath := path\n\t\t\tif cfg.Server.TemplatesParentDir != \"\" {\n\t\t\t\tcorePath = corePath[len(cfg.Server.TemplatesParentDir)+1:]\n\t\t\t}\n\t\t\tparts := strings.Split(corePath, string(filepath.Separator))\n\t\t\tkey := f.Name()\n\t\t\tif len(parts) > 2 {\n\t\t\t\tkey = filepath.Join(parts[1], f.Name())\n\t\t\t}\n\t\t\tinitUserPage(cfg.Server.TemplatesParentDir, path, key)\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// renderPage retrieves the given template and renders it to the given io.Writer.\n// If something goes wrong, the error is logged and returned.\nfunc renderPage(w io.Writer, tmpl string, data interface{}) error {\n\terr := pages[tmpl].ExecuteTemplate(w, \"base\", data)\n\tif err != nil {\n\t\tlog.Error(\"%v\", err)\n\t}\n\treturn err\n}\n\nfunc largeNumFmt(n int64) string {\n\treturn humanize.Comma(n)\n}\n\nfunc pluralize(singular, plural string, n int64) string {\n\tif n == 1 {\n\t\treturn singular\n\t}\n\treturn plural\n}\n\nfunc isRTL(d string) bool {\n\treturn d == \"rtl\"\n}\n\nfunc isLTR(d string) bool {\n\treturn d == \"ltr\" || d == \"auto\"\n}\n\nfunc localStr(term, lang string) string {\n\ts := l10n.Strings(lang)[term]\n\tif s == \"\" {\n\t\ts = l10n.Strings(\"\")[term]\n\t}\n\treturn s\n}\n\nfunc localHTML(term, lang string) template.HTML {\n\ts := l10n.Strings(lang)[term]\n\tif s == \"\" {\n\t\ts = l10n.Strings(\"\")[term]\n\t}\n\ts = strings.Replace(s, \"write.as\", \"<a href=\\\"https://writefreely.org\\\">writefreely</a>\", 1)\n\treturn template.HTML(s)\n}\n\n// from: https://stackoverflow.com/a/18276968/1549194\nfunc dict(values ...interface{}) (map[string]interface{}, error) {\n\tif len(values)%2 != 0 {\n\t\treturn nil, errors.New(\"dict: invalid number of parameters\")\n\t}\n\tdict := make(map[string]interface{}, len(values)/2)\n\tfor i := 0; i < len(values); i += 2 {\n\t\tkey, ok := values[i].(string)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"dict: keys must be strings\")\n\t\t}\n\t\tdict[key] = values[i+1]\n\t}\n\treturn dict, nil\n}\n"
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "unregisteredusers.go",
          "type": "blob",
          "size": 4.08203125,
          "content": "/*\n * Copyright © 2018-2019 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/log\"\n)\n\nfunc handleWebSignup(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\n\t// Get params\n\tvar ur userRegistration\n\tif reqJSON {\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr := decoder.Decode(&ur)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse signup JSON request: %v\\n\", err)\n\t\t\treturn ErrBadJSON\n\t\t}\n\t} else {\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't parse signup form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\n\t\terr = app.formDecoder.Decode(&ur, r.PostForm)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't decode signup form request: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\t}\n\tur.Web = true\n\tur.Normalize = true\n\n\tto := \"/\"\n\tif app.cfg.App.SimpleNav {\n\t\tto = \"/new\"\n\t}\n\tif ur.InviteCode != \"\" {\n\t\tto = \"/invite/\" + ur.InviteCode\n\t}\n\t_, err := signupWithRegistration(app, ur, w, r)\n\tif err != nil {\n\t\tif err, ok := err.(impart.HTTPError); ok {\n\t\t\tsession, _ := app.sessionStore.Get(r, cookieName)\n\t\t\tif session != nil {\n\t\t\t\tsession.AddFlash(err.Message)\n\t\t\t\tsession.Save(r, w)\n\t\t\t\treturn impart.HTTPError{http.StatusFound, to}\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\treturn impart.HTTPError{http.StatusFound, to}\n}\n\n// { \"username\": \"asdf\" }\n// result: { code: 204 }\nfunc handleUsernameCheck(app *App, w http.ResponseWriter, r *http.Request) error {\n\treqJSON := IsJSON(r)\n\n\t// Get params\n\tvar d struct {\n\t\tUsername string `json:\"username\"`\n\t}\n\tif reqJSON {\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr := decoder.Decode(&d)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Couldn't decode username check: %v\\n\", err)\n\t\t\treturn ErrBadFormData\n\t\t}\n\t} else {\n\t\treturn impart.HTTPError{http.StatusNotAcceptable, \"Must be JSON request\"}\n\t}\n\n\t// Check if username is okay\n\tfinalUsername := getSlug(d.Username, \"\")\n\tif finalUsername == \"\" {\n\t\terrMsg := \"Invalid username\"\n\t\tif d.Username != \"\" {\n\t\t\t// Username was provided, but didn't convert into valid latin characters\n\t\t\terrMsg += \" - must have at least 2 letters or numbers\"\n\t\t}\n\t\treturn impart.HTTPError{http.StatusBadRequest, errMsg + \".\"}\n\t}\n\tif app.db.PostIDExists(finalUsername) {\n\t\treturn impart.HTTPError{http.StatusConflict, \"Username is already taken.\"}\n\t}\n\tvar un string\n\terr := app.db.QueryRow(\"SELECT username FROM users WHERE username = ?\", finalUsername).Scan(&un)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn impart.WriteSuccess(w, finalUsername, http.StatusOK)\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT username: %v\", err)\n\t\treturn impart.HTTPError{http.StatusInternalServerError, \"We messed up.\"}\n\t}\n\n\t// Username was found, so it's taken\n\treturn impart.HTTPError{http.StatusConflict, \"Username is already taken.\"}\n}\n\nfunc getValidUsername(app *App, reqName, prevName string) (string, *impart.HTTPError) {\n\t// Check if username is okay\n\tfinalUsername := getSlug(reqName, \"\")\n\tif finalUsername == \"\" {\n\t\terrMsg := \"Invalid username\"\n\t\tif reqName != \"\" {\n\t\t\t// Username was provided, but didn't convert into valid latin characters\n\t\t\terrMsg += \" - must have at least 2 letters or numbers\"\n\t\t}\n\t\treturn \"\", &impart.HTTPError{http.StatusBadRequest, errMsg + \".\"}\n\t}\n\tif finalUsername == prevName {\n\t\treturn \"\", &impart.HTTPError{http.StatusNotModified, \"Username unchanged.\"}\n\t}\n\tif app.db.PostIDExists(finalUsername) {\n\t\treturn \"\", &impart.HTTPError{http.StatusConflict, \"Username is already taken.\"}\n\t}\n\tvar un string\n\terr := app.db.QueryRow(\"SELECT username FROM users WHERE username = ?\", finalUsername).Scan(&un)\n\tswitch {\n\tcase err == sql.ErrNoRows:\n\t\treturn finalUsername, nil\n\tcase err != nil:\n\t\tlog.Error(\"Couldn't SELECT username: %v\", err)\n\t\treturn \"\", &impart.HTTPError{http.StatusInternalServerError, \"We messed up.\"}\n\t}\n\n\t// Username was found, so it's taken\n\treturn \"\", &impart.HTTPError{http.StatusConflict, \"Username is already taken.\"}\n}\n"
        },
        {
          "name": "updates.go",
          "type": "blob",
          "size": 3.5654296875,
          "content": "/*\n * Copyright © 2019-2020 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"github.com/writeas/web-core/log\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\n// updatesCacheTime is the default interval between cache updates for new\n// software versions\nconst defaultUpdatesCacheTime = 12 * time.Hour\n\n// updatesCache holds data about current and new releases of the writefreely\n// software\ntype updatesCache struct {\n\tmu             sync.Mutex\n\tfrequency      time.Duration\n\tlastCheck      time.Time\n\tlatestVersion  string\n\tcurrentVersion string\n\tcheckError     error\n}\n\n// CheckNow asks for the latest released version of writefreely and updates\n// the cache last checked time. If the version postdates the current 'latest'\n// the version value is replaced.\nfunc (uc *updatesCache) CheckNow() error {\n\tif debugging {\n\t\tlog.Info(\"[update check] Checking for update now.\")\n\t}\n\tuc.mu.Lock()\n\tdefer uc.mu.Unlock()\n\tuc.lastCheck = time.Now()\n\tlatestRemote, err := newVersionCheck()\n\tif err != nil {\n\t\tlog.Error(\"[update check] Failed: %v\", err)\n\t\tuc.checkError = err\n\t\treturn err\n\t}\n\tif CompareSemver(latestRemote, uc.latestVersion) == 1 {\n\t\tuc.latestVersion = latestRemote\n\t}\n\treturn nil\n}\n\n// AreAvailable updates the cache if the frequency duration has passed\n// then returns if the latest release is newer than the current running version.\nfunc (uc updatesCache) AreAvailable() bool {\n\tif time.Since(uc.lastCheck) > uc.frequency {\n\t\tuc.CheckNow()\n\t}\n\treturn CompareSemver(uc.latestVersion, uc.currentVersion) == 1\n}\n\n// AreAvailableNoCheck returns if the latest release is newer than the current\n// running version.\nfunc (uc updatesCache) AreAvailableNoCheck() bool {\n\treturn CompareSemver(uc.latestVersion, uc.currentVersion) == 1\n}\n\n// LatestVersion returns the latest stored version available.\nfunc (uc updatesCache) LatestVersion() string {\n\treturn uc.latestVersion\n}\n\nfunc (uc updatesCache) ReleaseURL() string {\n\treturn \"https://writefreely.org/releases/\" + uc.latestVersion\n}\n\n// ReleaseNotesURL returns the full URL to the blog.writefreely.org release notes\n// for the latest version as stored in the cache.\nfunc (uc updatesCache) ReleaseNotesURL() string {\n\treturn wfReleaseNotesURL(uc.latestVersion)\n}\n\nfunc wfReleaseNotesURL(v string) string {\n\tver := strings.TrimPrefix(v, \"v\")\n\tver = strings.TrimSuffix(ver, \".0\")\n\t// hack until go 1.12 in build/travis\n\tseg := strings.Split(ver, \".\")\n\treturn \"https://blog.writefreely.org/version-\" + strings.Join(seg, \"-\")\n}\n\n// newUpdatesCache returns an initialized updates cache\nfunc newUpdatesCache(expiry time.Duration) *updatesCache {\n\tcache := updatesCache{\n\t\tfrequency:      expiry,\n\t\tcurrentVersion: \"v\" + softwareVer,\n\t}\n\tgo cache.CheckNow()\n\treturn &cache\n}\n\n// InitUpdates initializes the updates cache, if the config value is set\n// It uses the defaultUpdatesCacheTime for the cache expiry\nfunc (app *App) InitUpdates() {\n\tif app.cfg.App.UpdateChecks {\n\t\tapp.updates = newUpdatesCache(defaultUpdatesCacheTime)\n\t}\n}\n\nfunc newVersionCheck() (string, error) {\n\tres, err := http.Get(\"https://version.writefreely.org\")\n\tif debugging {\n\t\tlog.Info(\"[update check] GET https://version.writefreely.org\")\n\t}\n\t// TODO: return error if statusCode != OK\n\tif err == nil && res.StatusCode == http.StatusOK {\n\t\tdefer res.Body.Close()\n\n\t\tbody, err := io.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn string(body), nil\n\t}\n\treturn \"\", err\n}\n"
        },
        {
          "name": "updates_test.go",
          "type": "blob",
          "size": 2.01171875,
          "content": "package writefreely\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestUpdatesRoundTrip(t *testing.T) {\n\tcache := newUpdatesCache(defaultUpdatesCacheTime)\n\tt.Run(\"New Updates Cache\", func(t *testing.T) {\n\n\t\tif cache == nil {\n\t\t\tt.Fatal(\"Returned nil cache\")\n\t\t}\n\n\t\tif cache.frequency != defaultUpdatesCacheTime {\n\t\t\tt.Fatalf(\"Got cache expiry frequency: %s but expected: %s\", cache.frequency, defaultUpdatesCacheTime)\n\t\t}\n\n\t\tif cache.currentVersion != \"v\"+softwareVer {\n\t\t\tt.Fatalf(\"Got current version: %s but expected: %s\", cache.currentVersion, \"v\"+softwareVer)\n\t\t}\n\t})\n\n\tt.Run(\"Release URL\", func(t *testing.T) {\n\t\turl := cache.ReleaseNotesURL()\n\n\t\treg, err := regexp.Compile(`^https:\\/\\/blog.writefreely.org\\/version(-\\d+){1,}$`)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Test Case Error: Failed to compile regex: %v\", err)\n\t\t}\n\t\tmatch := reg.MatchString(url)\n\n\t\tif !match {\n\t\t\tt.Fatalf(\"Malformed Release URL: %s\", url)\n\t\t}\n\t})\n\n\tt.Run(\"Check Now\", func(t *testing.T) {\n\t\t// ensure time between init and next check\n\t\ttime.Sleep(1 * time.Second)\n\n\t\tprevLastCheck := cache.lastCheck\n\n\t\t// force to known older version for latest and current\n\t\tprevLatestVer := \"v0.8.1\"\n\t\tcache.latestVersion = prevLatestVer\n\t\tcache.currentVersion = \"v0.8.0\"\n\n\t\terr := cache.CheckNow()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error should be nil, got: %v\", err)\n\t\t}\n\n\t\tif prevLastCheck == cache.lastCheck {\n\t\t\tt.Fatal(\"Expected lastCheck to update\")\n\t\t}\n\n\t\tif cache.lastCheck.Before(prevLastCheck) {\n\t\t\tt.Fatal(\"Last check should be newer than previous\")\n\t\t}\n\n\t\tif prevLatestVer == cache.latestVersion {\n\t\t\tt.Fatal(\"expected latestVersion to update\")\n\t\t}\n\n\t})\n\n\tt.Run(\"Are Available\", func(t *testing.T) {\n\t\tif !cache.AreAvailable() {\n\t\t\tt.Fatalf(\"Cache reports not updates but Current is %s and Latest is %s\", cache.currentVersion, cache.latestVersion)\n\t\t}\n\t})\n\n\tt.Run(\"Latest Version\", func(t *testing.T) {\n\t\tgotLatest := cache.LatestVersion()\n\t\tif gotLatest != cache.latestVersion {\n\t\t\tt.Fatalf(\"Malformed latest version. Expected: %s but got: %s\", cache.latestVersion, gotLatest)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "users.go",
          "type": "blob",
          "size": 3.5205078125,
          "content": "/*\n * Copyright © 2018-2019, 2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"time\"\n\n\t\"github.com/guregu/null/zero\"\n\t\"github.com/writeas/web-core/data\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/key\"\n)\n\ntype UserStatus int\n\nconst (\n\tUserActive = iota\n\tUserSilenced\n)\n\ntype (\n\tuserCredentials struct {\n\t\tAlias string `json:\"alias\" schema:\"alias\"`\n\t\tPass  string `json:\"pass\" schema:\"pass\"`\n\t\tEmail string `json:\"email\" schema:\"email\"`\n\t\tWeb   bool   `json:\"web\" schema:\"-\"`\n\t\tTo    string `json:\"-\" schema:\"to\"`\n\n\t\tEmailLogin bool `json:\"via_email\" schema:\"via_email\"`\n\t}\n\n\tuserRegistration struct {\n\t\tuserCredentials\n\t\tInviteCode string `json:\"invite_code\" schema:\"invite_code\"`\n\t\tHoneypot   string `json:\"fullname\" schema:\"fullname\"`\n\t\tNormalize  bool   `json:\"normalize\" schema:\"normalize\"`\n\t\tSignup     bool   `json:\"signup\" schema:\"signup\"`\n\n\t\t// Feature fields\n\t\tDescription  string `json:\"description\" schema:\"description\"`\n\t\tMonetization string `json:\"monetization\" schema:\"monetization\"`\n\t}\n\n\t// AuthUser contains information for a newly authenticated user (either\n\t// from signing up or logging in).\n\tAuthUser struct {\n\t\tAccessToken string `json:\"access_token,omitempty\"`\n\t\tPassword    string `json:\"password,omitempty\"`\n\t\tUser        *User  `json:\"user\"`\n\n\t\t// Verbose user data\n\t\tPosts       *[]PublicPost `json:\"posts,omitempty\"`\n\t\tCollections *[]Collection `json:\"collections,omitempty\"`\n\t}\n\n\t// User is a consistent user object in the database and all contexts (auth\n\t// and non-auth) in the API.\n\tUser struct {\n\t\tID         int64       `json:\"-\"`\n\t\tUsername   string      `json:\"username\"`\n\t\tHashedPass []byte      `json:\"-\"`\n\t\tHasPass    bool        `json:\"has_pass\"`\n\t\tEmail      zero.String `json:\"email\"`\n\t\tCreated    time.Time   `json:\"created\"`\n\t\tStatus     UserStatus  `json:\"status\"`\n\n\t\tclearEmail string `json:\"email\"`\n\t}\n\n\tuserMeStats struct {\n\t\tTotalCollections, TotalArticles, CollectionPosts uint64\n\t}\n\n\tExportUser struct {\n\t\t*User\n\t\tCollections    *[]CollectionObj `json:\"collections\"`\n\t\tAnonymousPosts []PublicPost     `json:\"posts\"`\n\t}\n\n\tPublicUser struct {\n\t\tUsername string `json:\"username\"`\n\t}\n)\n\n// EmailClear decrypts and returns the user's email, caching it in the user\n// object.\nfunc (u *User) EmailClear(keys *key.Keychain) string {\n\tif u.clearEmail != \"\" {\n\t\treturn u.clearEmail\n\t}\n\n\tif u.Email.Valid && u.Email.String != \"\" {\n\t\temail, err := data.Decrypt(keys.EmailKey, []byte(u.Email.String))\n\t\tif err != nil {\n\t\t\tlog.Error(\"Error decrypting user email: %v\", err)\n\t\t} else {\n\t\t\tu.clearEmail = string(email)\n\t\t\treturn u.clearEmail\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (u User) CreatedFriendly() string {\n\t/*\n\t\t// TODO: accept a locale in this method and use that for the format\n\t\tvar loc monday.Locale = monday.LocaleEnUS\n\t\treturn monday.Format(u.Created, monday.DateTimeFormatsByLocale[loc], loc)\n\t*/\n\treturn u.Created.Format(\"January 2, 2006, 3:04 PM\")\n}\n\n// Cookie strips down an AuthUser to contain only information necessary for\n// cookies.\nfunc (u User) Cookie() *User {\n\tu.HashedPass = []byte{}\n\n\treturn &u\n}\n\nfunc (u *User) IsAdmin() bool {\n\t// TODO: get this from database\n\treturn u.ID == 1\n}\n\nfunc (u *User) IsSilenced() bool {\n\treturn u.Status&UserSilenced != 0\n}\n\nfunc (u *User) IsEmailSubscriber(app *App, collID int64) bool {\n\treturn app.db.IsEmailSubscriber(\"\", u.ID, collID)\n}\n"
        },
        {
          "name": "webfinger.go",
          "type": "blob",
          "size": 3.513671875,
          "content": "/*\n * Copyright © 2018-2021 Musing Studio LLC.\n *\n * This file is part of WriteFreely.\n *\n * WriteFreely is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, included\n * in the LICENSE file in this source code package.\n */\n\npackage writefreely\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/writeas/go-webfinger\"\n\t\"github.com/writeas/impart\"\n\t\"github.com/writeas/web-core/log\"\n\t\"github.com/writefreely/writefreely/config\"\n)\n\ntype wfResolver struct {\n\tdb  *datastore\n\tcfg *config.Config\n}\n\nvar wfUserNotFoundErr = impart.HTTPError{http.StatusNotFound, \"User not found.\"}\n\nfunc (wfr wfResolver) FindUser(username string, host, requestHost string, r []webfinger.Rel) (*webfinger.Resource, error) {\n\tvar c *Collection\n\tvar err error\n\tif username == host {\n\t\tc = instanceColl\n\t} else if wfr.cfg.App.SingleUser {\n\t\tc, err = wfr.db.GetCollectionByID(1)\n\t} else {\n\t\tc, err = wfr.db.GetCollection(username)\n\t}\n\tif err != nil {\n\t\tlog.Error(\"Unable to get blog: %v\", err)\n\t\treturn nil, err\n\t}\n\tc.hostName = wfr.cfg.App.Host\n\n\tif !c.IsInstanceColl() {\n\t\tsilenced, err := wfr.db.IsUserSilenced(c.OwnerID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"webfinger find user: check is silenced: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\tif silenced {\n\t\t\treturn nil, wfUserNotFoundErr\n\t\t}\n\t}\n\tif wfr.cfg.App.SingleUser {\n\t\t// Ensure handle matches user-chosen one on single-user blogs\n\t\tif username != c.Alias {\n\t\t\tlog.Info(\"Username '%s' is not handle '%s'\", username, c.Alias)\n\t\t\treturn nil, wfUserNotFoundErr\n\t\t}\n\t}\n\t// Only return information if site has federation enabled.\n\t// TODO: enable two levels of federation? Unlisted or Public on timelines?\n\tif !wfr.cfg.App.Federation {\n\t\treturn nil, wfUserNotFoundErr\n\t}\n\n\tres := webfinger.Resource{\n\t\tSubject: \"acct:\" + username + \"@\" + host,\n\t\tAliases: []string{\n\t\t\tc.CanonicalURL(),\n\t\t\tc.FederatedAccount(),\n\t\t},\n\t\tLinks: []webfinger.Link{\n\t\t\t{\n\t\t\t\tHRef: c.CanonicalURL(),\n\t\t\t\tType: \"text/html\",\n\t\t\t\tRel:  \"https://webfinger.net/rel/profile-page\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tHRef: c.FederatedAccount(),\n\t\t\t\tType: \"application/activity+json\",\n\t\t\t\tRel:  \"self\",\n\t\t\t},\n\t\t},\n\t}\n\treturn &res, nil\n}\n\nfunc (wfr wfResolver) DummyUser(username string, hostname string, r []webfinger.Rel) (*webfinger.Resource, error) {\n\treturn nil, wfUserNotFoundErr\n}\n\nfunc (wfr wfResolver) IsNotFoundError(err error) bool {\n\treturn err == wfUserNotFoundErr\n}\n\n// RemoteLookup looks up a user by handle at a remote server\n// and returns the actor URL\nfunc RemoteLookup(handle string) string {\n\thandle = strings.TrimLeft(handle, \"@\")\n\t// let's take the server part of the handle\n\tparts := strings.Split(handle, \"@\")\n\tresp, err := http.Get(\"https://\" + parts[1] + \"/.well-known/webfinger?resource=acct:\" + handle)\n\tif err != nil {\n\t\tlog.Error(\"Error on webfinger request: %v\", err)\n\t\treturn \"\"\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Error(\"Error on webfinger response: %v\", err)\n\t\treturn \"\"\n\t}\n\n\tvar result webfinger.Resource\n\terr = json.Unmarshal(body, &result)\n\tif err != nil {\n\t\tlog.Error(\"Unable to parse webfinger response: %v\", err)\n\t\treturn \"\"\n\t}\n\n\tvar href string\n\t// iterate over webfinger links and find the one with\n\t// a self \"rel\"\n\tfor _, link := range result.Links {\n\t\tif link.Rel == \"self\" {\n\t\t\thref = link.HRef\n\t\t}\n\t}\n\n\t// if we didn't find it with the above then\n\t// try using aliases\n\tif href == \"\" {\n\t\t// take the last alias because mastodon has the\n\t\t// https://instance.tld/@user first which\n\t\t// doesn't work as an href\n\t\thref = result.Aliases[len(result.Aliases)-1]\n\t}\n\n\treturn href\n}\n"
        }
      ]
    }
  ]
}