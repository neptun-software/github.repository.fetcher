{
  "metadata": {
    "timestamp": 1736567117974,
    "page": 712,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bluele/gcache",
      "stars": 2625,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017 Jun Kimura\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.162109375,
          "content": "# GCache\n\n![Test](https://github.com/bluele/gcache/workflows/Test/badge.svg)\n[![GoDoc](https://godoc.org/github.com/bluele/gcache?status.svg)](https://pkg.go.dev/github.com/bluele/gcache?tab=doc)\n\nCache library for golang. It supports expirable Cache, LFU, LRU and ARC.\n\n## Features\n\n* Supports expirable Cache, LFU, LRU and ARC.\n\n* Goroutine safe.\n\n* Supports event handlers which evict, purge, and add entry. (Optional)\n\n* Automatically load cache if it doesn't exists. (Optional)\n\n## Install\n\n```\n$ go get github.com/bluele/gcache\n```\n\n## Example\n\n### Manually set a key-value pair.\n\n```go\npackage main\n\nimport (\n  \"github.com/bluele/gcache\"\n  \"fmt\"\n)\n\nfunc main() {\n  gc := gcache.New(20).\n    LRU().\n    Build()\n  gc.Set(\"key\", \"ok\")\n  value, err := gc.Get(\"key\")\n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(\"Get:\", value)\n}\n```\n\n```\nGet: ok\n```\n\n### Manually set a key-value pair, with an expiration time.\n\n```go\npackage main\n\nimport (\n  \"github.com/bluele/gcache\"\n  \"fmt\"\n  \"time\"\n)\n\nfunc main() {\n  gc := gcache.New(20).\n    LRU().\n    Build()\n  gc.SetWithExpire(\"key\", \"ok\", time.Second*10)\n  value, _ := gc.Get(\"key\")\n  fmt.Println(\"Get:\", value)\n\n  // Wait for value to expire\n  time.Sleep(time.Second*10)\n\n  value, err := gc.Get(\"key\")\n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(\"Get:\", value)\n}\n```\n\n```\nGet: ok\n// 10 seconds later, new attempt:\npanic: ErrKeyNotFound\n```\n\n\n### Automatically load value\n\n```go\npackage main\n\nimport (\n  \"github.com/bluele/gcache\"\n  \"fmt\"\n)\n\nfunc main() {\n  gc := gcache.New(20).\n    LRU().\n    LoaderFunc(func(key interface{}) (interface{}, error) {\n      return \"ok\", nil\n    }).\n    Build()\n  value, err := gc.Get(\"key\")\n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(\"Get:\", value)\n}\n```\n\n```\nGet: ok\n```\n\n### Automatically load value with expiration\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"time\"\n\n  \"github.com/bluele/gcache\"\n)\n\nfunc main() {\n  var evictCounter, loaderCounter, purgeCounter int\n  gc := gcache.New(20).\n    LRU().\n    LoaderExpireFunc(func(key interface{}) (interface{}, *time.Duration, error) {\n      loaderCounter++\n      expire := 1 * time.Second\n      return \"ok\", &expire, nil\n    }).\n    EvictedFunc(func(key, value interface{}) {\n      evictCounter++\n      fmt.Println(\"evicted key:\", key)\n    }).\n    PurgeVisitorFunc(func(key, value interface{}) {\n      purgeCounter++\n      fmt.Println(\"purged key:\", key)\n    }).\n    Build()\n  value, err := gc.Get(\"key\")\n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(\"Get:\", value)\n  time.Sleep(1 * time.Second)\n  value, err = gc.Get(\"key\")\n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(\"Get:\", value)\n  gc.Purge()\n  if loaderCounter != evictCounter+purgeCounter {\n    panic(\"bad\")\n  }\n}\n```\n\n```\nGet: ok\nevicted key: key\nGet: ok\npurged key: key\n```\n\n\n## Cache Algorithm\n\n  * Least-Frequently Used (LFU)\n\n  Discards the least frequently used items first.\n\n  ```go\n  func main() {\n    // size: 10\n    gc := gcache.New(10).\n      LFU().\n      Build()\n    gc.Set(\"key\", \"value\")\n  }\n  ```\n\n  * Least Recently Used (LRU)\n\n  Discards the least recently used items first.\n\n  ```go\n  func main() {\n    // size: 10\n    gc := gcache.New(10).\n      LRU().\n      Build()\n    gc.Set(\"key\", \"value\")\n  }\n  ```\n\n  * Adaptive Replacement Cache (ARC)\n\n  Constantly balances between LRU and LFU, to improve the combined result.\n\n  detail: http://en.wikipedia.org/wiki/Adaptive_replacement_cache\n\n  ```go\n  func main() {\n    // size: 10\n    gc := gcache.New(10).\n      ARC().\n      Build()\n    gc.Set(\"key\", \"value\")\n  }\n  ```\n\n  * SimpleCache (Default)\n\n  SimpleCache has no clear priority for evict cache. It depends on key-value map order.\n\n  ```go\n  func main() {\n    // size: 10\n    gc := gcache.New(10).Build()\n    gc.Set(\"key\", \"value\")\n    v, err := gc.Get(\"key\")\n    if err != nil {\n      panic(err)\n    }\n  }\n  ```\n\n## Loading Cache\n\nIf specified `LoaderFunc`, values are automatically loaded by the cache, and are stored in the cache until either evicted or manually invalidated.\n\n```go\nfunc main() {\n  gc := gcache.New(10).\n    LRU().\n    LoaderFunc(func(key interface{}) (interface{}, error) {\n      return \"value\", nil\n    }).\n    Build()\n  v, _ := gc.Get(\"key\")\n  // output: \"value\"\n  fmt.Println(v)\n}\n```\n\nGCache coordinates cache fills such that only one load in one process of an entire replicated set of processes populates the cache, then multiplexes the loaded value to all callers.\n\n## Expirable cache\n\n```go\nfunc main() {\n  // LRU cache, size: 10, expiration: after a hour\n  gc := gcache.New(10).\n    LRU().\n    Expiration(time.Hour).\n    Build()\n}\n```\n\n## Event handlers\n\n### Evicted handler\n\nEvent handler for evict the entry.\n\n```go\nfunc main() {\n  gc := gcache.New(2).\n    EvictedFunc(func(key, value interface{}) {\n      fmt.Println(\"evicted key:\", key)\n    }).\n    Build()\n  for i := 0; i < 3; i++ {\n    gc.Set(i, i*i)\n  }\n}\n```\n\n```\nevicted key: 0\n```\n\n### Added handler\n\nEvent handler for add the entry.\n\n```go\nfunc main() {\n  gc := gcache.New(2).\n    AddedFunc(func(key, value interface{}) {\n      fmt.Println(\"added key:\", key)\n    }).\n    Build()\n  for i := 0; i < 3; i++ {\n    gc.Set(i, i*i)\n  }\n}\n```\n\n```\nadded key: 0\nadded key: 1\nadded key: 2\n```\n\n# Author\n\n**Jun Kimura**\n\n* <http://github.com/bluele>\n* <junkxdev@gmail.com>\n"
        },
        {
          "name": "arc.go",
          "type": "blob",
          "size": 8.9501953125,
          "content": "package gcache\n\nimport (\n\t\"container/list\"\n\t\"time\"\n)\n\n// Constantly balances between LRU and LFU, to improve the combined result.\ntype ARC struct {\n\tbaseCache\n\titems map[interface{}]*arcItem\n\n\tpart int\n\tt1   *arcList\n\tt2   *arcList\n\tb1   *arcList\n\tb2   *arcList\n}\n\nfunc newARC(cb *CacheBuilder) *ARC {\n\tc := &ARC{}\n\tbuildCache(&c.baseCache, cb)\n\n\tc.init()\n\tc.loadGroup.cache = c\n\treturn c\n}\n\nfunc (c *ARC) init() {\n\tc.items = make(map[interface{}]*arcItem)\n\tc.t1 = newARCList()\n\tc.t2 = newARCList()\n\tc.b1 = newARCList()\n\tc.b2 = newARCList()\n}\n\nfunc (c *ARC) replace(key interface{}) {\n\tif !c.isCacheFull() {\n\t\treturn\n\t}\n\tvar old interface{}\n\tif c.t1.Len() > 0 && ((c.b2.Has(key) && c.t1.Len() == c.part) || (c.t1.Len() > c.part)) {\n\t\told = c.t1.RemoveTail()\n\t\tc.b1.PushFront(old)\n\t} else if c.t2.Len() > 0 {\n\t\told = c.t2.RemoveTail()\n\t\tc.b2.PushFront(old)\n\t} else {\n\t\told = c.t1.RemoveTail()\n\t\tc.b1.PushFront(old)\n\t}\n\titem, ok := c.items[old]\n\tif ok {\n\t\tdelete(c.items, old)\n\t\tif c.evictedFunc != nil {\n\t\t\tc.evictedFunc(item.key, item.value)\n\t\t}\n\t}\n}\n\nfunc (c *ARC) Set(key, value interface{}) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\t_, err := c.set(key, value)\n\treturn err\n}\n\n// Set a new key-value pair with an expiration time\nfunc (c *ARC) SetWithExpire(key, value interface{}, expiration time.Duration) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\titem, err := c.set(key, value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt := c.clock.Now().Add(expiration)\n\titem.(*arcItem).expiration = &t\n\treturn nil\n}\n\nfunc (c *ARC) set(key, value interface{}) (interface{}, error) {\n\tvar err error\n\tif c.serializeFunc != nil {\n\t\tvalue, err = c.serializeFunc(key, value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\titem, ok := c.items[key]\n\tif ok {\n\t\titem.value = value\n\t} else {\n\t\titem = &arcItem{\n\t\t\tclock: c.clock,\n\t\t\tkey:   key,\n\t\t\tvalue: value,\n\t\t}\n\t\tc.items[key] = item\n\t}\n\n\tif c.expiration != nil {\n\t\tt := c.clock.Now().Add(*c.expiration)\n\t\titem.expiration = &t\n\t}\n\n\tdefer func() {\n\t\tif c.addedFunc != nil {\n\t\t\tc.addedFunc(key, value)\n\t\t}\n\t}()\n\n\tif c.t1.Has(key) || c.t2.Has(key) {\n\t\treturn item, nil\n\t}\n\n\tif elt := c.b1.Lookup(key); elt != nil {\n\t\tc.setPart(minInt(c.size, c.part+maxInt(c.b2.Len()/c.b1.Len(), 1)))\n\t\tc.replace(key)\n\t\tc.b1.Remove(key, elt)\n\t\tc.t2.PushFront(key)\n\t\treturn item, nil\n\t}\n\n\tif elt := c.b2.Lookup(key); elt != nil {\n\t\tc.setPart(maxInt(0, c.part-maxInt(c.b1.Len()/c.b2.Len(), 1)))\n\t\tc.replace(key)\n\t\tc.b2.Remove(key, elt)\n\t\tc.t2.PushFront(key)\n\t\treturn item, nil\n\t}\n\n\tif c.isCacheFull() && c.t1.Len()+c.b1.Len() == c.size {\n\t\tif c.t1.Len() < c.size {\n\t\t\tc.b1.RemoveTail()\n\t\t\tc.replace(key)\n\t\t} else {\n\t\t\tpop := c.t1.RemoveTail()\n\t\t\titem, ok := c.items[pop]\n\t\t\tif ok {\n\t\t\t\tdelete(c.items, pop)\n\t\t\t\tif c.evictedFunc != nil {\n\t\t\t\t\tc.evictedFunc(item.key, item.value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttotal := c.t1.Len() + c.b1.Len() + c.t2.Len() + c.b2.Len()\n\t\tif total >= c.size {\n\t\t\tif total == (2 * c.size) {\n\t\t\t\tif c.b2.Len() > 0 {\n\t\t\t\t\tc.b2.RemoveTail()\n\t\t\t\t} else {\n\t\t\t\t\tc.b1.RemoveTail()\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.replace(key)\n\t\t}\n\t}\n\tc.t1.PushFront(key)\n\treturn item, nil\n}\n\n// Get a value from cache pool using key if it exists. If not exists and it has LoaderFunc, it will generate the value using you have specified LoaderFunc method returns value.\nfunc (c *ARC) Get(key interface{}) (interface{}, error) {\n\tv, err := c.get(key, false)\n\tif err == KeyNotFoundError {\n\t\treturn c.getWithLoader(key, true)\n\t}\n\treturn v, err\n}\n\n// GetIFPresent gets a value from cache pool using key if it exists.\n// If it does not exists key, returns KeyNotFoundError.\n// And send a request which refresh value for specified key if cache object has LoaderFunc.\nfunc (c *ARC) GetIFPresent(key interface{}) (interface{}, error) {\n\tv, err := c.get(key, false)\n\tif err == KeyNotFoundError {\n\t\treturn c.getWithLoader(key, false)\n\t}\n\treturn v, err\n}\n\nfunc (c *ARC) get(key interface{}, onLoad bool) (interface{}, error) {\n\tv, err := c.getValue(key, onLoad)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c.deserializeFunc != nil {\n\t\treturn c.deserializeFunc(key, v)\n\t}\n\treturn v, nil\n}\n\nfunc (c *ARC) getValue(key interface{}, onLoad bool) (interface{}, error) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif elt := c.t1.Lookup(key); elt != nil {\n\t\tc.t1.Remove(key, elt)\n\t\titem := c.items[key]\n\t\tif !item.IsExpired(nil) {\n\t\t\tc.t2.PushFront(key)\n\t\t\tif !onLoad {\n\t\t\t\tc.stats.IncrHitCount()\n\t\t\t}\n\t\t\treturn item.value, nil\n\t\t} else {\n\t\t\tdelete(c.items, key)\n\t\t\tc.b1.PushFront(key)\n\t\t\tif c.evictedFunc != nil {\n\t\t\t\tc.evictedFunc(item.key, item.value)\n\t\t\t}\n\t\t}\n\t}\n\tif elt := c.t2.Lookup(key); elt != nil {\n\t\titem := c.items[key]\n\t\tif !item.IsExpired(nil) {\n\t\t\tc.t2.MoveToFront(elt)\n\t\t\tif !onLoad {\n\t\t\t\tc.stats.IncrHitCount()\n\t\t\t}\n\t\t\treturn item.value, nil\n\t\t} else {\n\t\t\tdelete(c.items, key)\n\t\t\tc.t2.Remove(key, elt)\n\t\t\tc.b2.PushFront(key)\n\t\t\tif c.evictedFunc != nil {\n\t\t\t\tc.evictedFunc(item.key, item.value)\n\t\t\t}\n\t\t}\n\t}\n\n\tif !onLoad {\n\t\tc.stats.IncrMissCount()\n\t}\n\treturn nil, KeyNotFoundError\n}\n\nfunc (c *ARC) getWithLoader(key interface{}, isWait bool) (interface{}, error) {\n\tif c.loaderExpireFunc == nil {\n\t\treturn nil, KeyNotFoundError\n\t}\n\tvalue, _, err := c.load(key, func(v interface{}, expiration *time.Duration, e error) (interface{}, error) {\n\t\tif e != nil {\n\t\t\treturn nil, e\n\t\t}\n\t\tc.mu.Lock()\n\t\tdefer c.mu.Unlock()\n\t\titem, err := c.set(key, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif expiration != nil {\n\t\t\tt := c.clock.Now().Add(*expiration)\n\t\t\titem.(*arcItem).expiration = &t\n\t\t}\n\t\treturn v, nil\n\t}, isWait)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn value, nil\n}\n\n// Has checks if key exists in cache\nfunc (c *ARC) Has(key interface{}) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tnow := time.Now()\n\treturn c.has(key, &now)\n}\n\nfunc (c *ARC) has(key interface{}, now *time.Time) bool {\n\titem, ok := c.items[key]\n\tif !ok {\n\t\treturn false\n\t}\n\treturn !item.IsExpired(now)\n}\n\n// Remove removes the provided key from the cache.\nfunc (c *ARC) Remove(key interface{}) bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\treturn c.remove(key)\n}\n\nfunc (c *ARC) remove(key interface{}) bool {\n\tif elt := c.t1.Lookup(key); elt != nil {\n\t\tc.t1.Remove(key, elt)\n\t\titem := c.items[key]\n\t\tdelete(c.items, key)\n\t\tc.b1.PushFront(key)\n\t\tif c.evictedFunc != nil {\n\t\t\tc.evictedFunc(key, item.value)\n\t\t}\n\t\treturn true\n\t}\n\n\tif elt := c.t2.Lookup(key); elt != nil {\n\t\tc.t2.Remove(key, elt)\n\t\titem := c.items[key]\n\t\tdelete(c.items, key)\n\t\tc.b2.PushFront(key)\n\t\tif c.evictedFunc != nil {\n\t\t\tc.evictedFunc(key, item.value)\n\t\t}\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// GetALL returns all key-value pairs in the cache.\nfunc (c *ARC) GetALL(checkExpired bool) map[interface{}]interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\titems := make(map[interface{}]interface{}, len(c.items))\n\tnow := time.Now()\n\tfor k, item := range c.items {\n\t\tif !checkExpired || c.has(k, &now) {\n\t\t\titems[k] = item.value\n\t\t}\n\t}\n\treturn items\n}\n\n// Keys returns a slice of the keys in the cache.\nfunc (c *ARC) Keys(checkExpired bool) []interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tkeys := make([]interface{}, 0, len(c.items))\n\tnow := time.Now()\n\tfor k := range c.items {\n\t\tif !checkExpired || c.has(k, &now) {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t}\n\treturn keys\n}\n\n// Len returns the number of items in the cache.\nfunc (c *ARC) Len(checkExpired bool) int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tif !checkExpired {\n\t\treturn len(c.items)\n\t}\n\tvar length int\n\tnow := time.Now()\n\tfor k := range c.items {\n\t\tif c.has(k, &now) {\n\t\t\tlength++\n\t\t}\n\t}\n\treturn length\n}\n\n// Purge is used to completely clear the cache\nfunc (c *ARC) Purge() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.purgeVisitorFunc != nil {\n\t\tfor _, item := range c.items {\n\t\t\tc.purgeVisitorFunc(item.key, item.value)\n\t\t}\n\t}\n\n\tc.init()\n}\n\nfunc (c *ARC) setPart(p int) {\n\tif c.isCacheFull() {\n\t\tc.part = p\n\t}\n}\n\nfunc (c *ARC) isCacheFull() bool {\n\treturn (c.t1.Len() + c.t2.Len()) == c.size\n}\n\n// IsExpired returns boolean value whether this item is expired or not.\nfunc (it *arcItem) IsExpired(now *time.Time) bool {\n\tif it.expiration == nil {\n\t\treturn false\n\t}\n\tif now == nil {\n\t\tt := it.clock.Now()\n\t\tnow = &t\n\t}\n\treturn it.expiration.Before(*now)\n}\n\ntype arcList struct {\n\tl    *list.List\n\tkeys map[interface{}]*list.Element\n}\n\ntype arcItem struct {\n\tclock      Clock\n\tkey        interface{}\n\tvalue      interface{}\n\texpiration *time.Time\n}\n\nfunc newARCList() *arcList {\n\treturn &arcList{\n\t\tl:    list.New(),\n\t\tkeys: make(map[interface{}]*list.Element),\n\t}\n}\n\nfunc (al *arcList) Has(key interface{}) bool {\n\t_, ok := al.keys[key]\n\treturn ok\n}\n\nfunc (al *arcList) Lookup(key interface{}) *list.Element {\n\telt := al.keys[key]\n\treturn elt\n}\n\nfunc (al *arcList) MoveToFront(elt *list.Element) {\n\tal.l.MoveToFront(elt)\n}\n\nfunc (al *arcList) PushFront(key interface{}) {\n\tif elt, ok := al.keys[key]; ok {\n\t\tal.l.MoveToFront(elt)\n\t\treturn\n\t}\n\telt := al.l.PushFront(key)\n\tal.keys[key] = elt\n}\n\nfunc (al *arcList) Remove(key interface{}, elt *list.Element) {\n\tdelete(al.keys, key)\n\tal.l.Remove(elt)\n}\n\nfunc (al *arcList) RemoveTail() interface{} {\n\telt := al.l.Back()\n\tal.l.Remove(elt)\n\n\tkey := elt.Value\n\tdelete(al.keys, key)\n\n\treturn key\n}\n\nfunc (al *arcList) Len() int {\n\treturn al.l.Len()\n}\n"
        },
        {
          "name": "arc_test.go",
          "type": "blob",
          "size": 2.263671875,
          "content": "package gcache\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestARCGet(t *testing.T) {\n\tsize := 1000\n\tgc := buildTestCache(t, TYPE_ARC, size)\n\ttestSetCache(t, gc, size)\n\ttestGetCache(t, gc, size)\n}\n\nfunc TestLoadingARCGet(t *testing.T) {\n\tsize := 1000\n\tnumbers := 1000\n\ttestGetCache(t, buildTestLoadingCache(t, TYPE_ARC, size, loader), numbers)\n}\n\nfunc TestARCLength(t *testing.T) {\n\tgc := buildTestLoadingCacheWithExpiration(t, TYPE_ARC, 2, time.Millisecond)\n\tgc.Get(\"test1\")\n\tgc.Get(\"test2\")\n\tgc.Get(\"test3\")\n\tlength := gc.Len(true)\n\texpectedLength := 2\n\tif length != expectedLength {\n\t\tt.Errorf(\"Expected length is %v, not %v\", expectedLength, length)\n\t}\n\ttime.Sleep(time.Millisecond)\n\tgc.Get(\"test4\")\n\tlength = gc.Len(true)\n\texpectedLength = 1\n\tif length != expectedLength {\n\t\tt.Errorf(\"Expected length is %v, not %v\", expectedLength, length)\n\t}\n}\n\nfunc TestARCEvictItem(t *testing.T) {\n\tcacheSize := 10\n\tnumbers := cacheSize + 1\n\tgc := buildTestLoadingCache(t, TYPE_ARC, cacheSize, loader)\n\n\tfor i := 0; i < numbers; i++ {\n\t\t_, err := gc.Get(fmt.Sprintf(\"Key-%d\", i))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestARCPurgeCache(t *testing.T) {\n\tcacheSize := 10\n\tpurgeCount := 0\n\tgc := New(cacheSize).\n\t\tARC().\n\t\tLoaderFunc(loader).\n\t\tPurgeVisitorFunc(func(k, v interface{}) {\n\t\t\tpurgeCount++\n\t\t}).\n\t\tBuild()\n\n\tfor i := 0; i < cacheSize; i++ {\n\t\t_, err := gc.Get(fmt.Sprintf(\"Key-%d\", i))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t}\n\n\tgc.Purge()\n\n\tif purgeCount != cacheSize {\n\t\tt.Errorf(\"failed to purge everything\")\n\t}\n}\n\nfunc TestARCGetIFPresent(t *testing.T) {\n\ttestGetIFPresent(t, TYPE_ARC)\n}\n\nfunc TestARCHas(t *testing.T) {\n\tgc := buildTestLoadingCacheWithExpiration(t, TYPE_ARC, 2, 10*time.Millisecond)\n\n\tfor i := 0; i < 10; i++ {\n\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n\t\t\tgc.Get(\"test1\")\n\t\t\tgc.Get(\"test2\")\n\n\t\t\tif gc.Has(\"test0\") {\n\t\t\t\tt.Fatal(\"should not have test0\")\n\t\t\t}\n\t\t\tif !gc.Has(\"test1\") {\n\t\t\t\tt.Fatal(\"should have test1\")\n\t\t\t}\n\t\t\tif !gc.Has(\"test2\") {\n\t\t\t\tt.Fatal(\"should have test2\")\n\t\t\t}\n\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\t\tif gc.Has(\"test0\") {\n\t\t\t\tt.Fatal(\"should not have test0\")\n\t\t\t}\n\t\t\tif gc.Has(\"test1\") {\n\t\t\t\tt.Fatal(\"should not have test1\")\n\t\t\t}\n\t\t\tif gc.Has(\"test2\") {\n\t\t\t\tt.Fatal(\"should not have test2\")\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 6.1123046875,
          "content": "package gcache\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nconst (\n\tTYPE_SIMPLE = \"simple\"\n\tTYPE_LRU    = \"lru\"\n\tTYPE_LFU    = \"lfu\"\n\tTYPE_ARC    = \"arc\"\n)\n\nvar KeyNotFoundError = errors.New(\"Key not found.\")\n\ntype Cache interface {\n\t// Set inserts or updates the specified key-value pair.\n\tSet(key, value interface{}) error\n\t// SetWithExpire inserts or updates the specified key-value pair with an expiration time.\n\tSetWithExpire(key, value interface{}, expiration time.Duration) error\n\t// Get returns the value for the specified key if it is present in the cache.\n\t// If the key is not present in the cache and the cache has LoaderFunc,\n\t// invoke the `LoaderFunc` function and inserts the key-value pair in the cache.\n\t// If the key is not present in the cache and the cache does not have a LoaderFunc,\n\t// return KeyNotFoundError.\n\tGet(key interface{}) (interface{}, error)\n\t// GetIFPresent returns the value for the specified key if it is present in the cache.\n\t// Return KeyNotFoundError if the key is not present.\n\tGetIFPresent(key interface{}) (interface{}, error)\n\t// GetAll returns a map containing all key-value pairs in the cache.\n\tGetALL(checkExpired bool) map[interface{}]interface{}\n\tget(key interface{}, onLoad bool) (interface{}, error)\n\t// Remove removes the specified key from the cache if the key is present.\n\t// Returns true if the key was present and the key has been deleted.\n\tRemove(key interface{}) bool\n\t// Purge removes all key-value pairs from the cache.\n\tPurge()\n\t// Keys returns a slice containing all keys in the cache.\n\tKeys(checkExpired bool) []interface{}\n\t// Len returns the number of items in the cache.\n\tLen(checkExpired bool) int\n\t// Has returns true if the key exists in the cache.\n\tHas(key interface{}) bool\n\n\tstatsAccessor\n}\n\ntype baseCache struct {\n\tclock            Clock\n\tsize             int\n\tloaderExpireFunc LoaderExpireFunc\n\tevictedFunc      EvictedFunc\n\tpurgeVisitorFunc PurgeVisitorFunc\n\taddedFunc        AddedFunc\n\tdeserializeFunc  DeserializeFunc\n\tserializeFunc    SerializeFunc\n\texpiration       *time.Duration\n\tmu               sync.RWMutex\n\tloadGroup        Group\n\t*stats\n}\n\ntype (\n\tLoaderFunc       func(interface{}) (interface{}, error)\n\tLoaderExpireFunc func(interface{}) (interface{}, *time.Duration, error)\n\tEvictedFunc      func(interface{}, interface{})\n\tPurgeVisitorFunc func(interface{}, interface{})\n\tAddedFunc        func(interface{}, interface{})\n\tDeserializeFunc  func(interface{}, interface{}) (interface{}, error)\n\tSerializeFunc    func(interface{}, interface{}) (interface{}, error)\n)\n\ntype CacheBuilder struct {\n\tclock            Clock\n\ttp               string\n\tsize             int\n\tloaderExpireFunc LoaderExpireFunc\n\tevictedFunc      EvictedFunc\n\tpurgeVisitorFunc PurgeVisitorFunc\n\taddedFunc        AddedFunc\n\texpiration       *time.Duration\n\tdeserializeFunc  DeserializeFunc\n\tserializeFunc    SerializeFunc\n}\n\nfunc New(size int) *CacheBuilder {\n\treturn &CacheBuilder{\n\t\tclock: NewRealClock(),\n\t\ttp:    TYPE_SIMPLE,\n\t\tsize:  size,\n\t}\n}\n\nfunc (cb *CacheBuilder) Clock(clock Clock) *CacheBuilder {\n\tcb.clock = clock\n\treturn cb\n}\n\n// Set a loader function.\n// loaderFunc: create a new value with this function if cached value is expired.\nfunc (cb *CacheBuilder) LoaderFunc(loaderFunc LoaderFunc) *CacheBuilder {\n\tcb.loaderExpireFunc = func(k interface{}) (interface{}, *time.Duration, error) {\n\t\tv, err := loaderFunc(k)\n\t\treturn v, nil, err\n\t}\n\treturn cb\n}\n\n// Set a loader function with expiration.\n// loaderExpireFunc: create a new value with this function if cached value is expired.\n// If nil returned instead of time.Duration from loaderExpireFunc than value will never expire.\nfunc (cb *CacheBuilder) LoaderExpireFunc(loaderExpireFunc LoaderExpireFunc) *CacheBuilder {\n\tcb.loaderExpireFunc = loaderExpireFunc\n\treturn cb\n}\n\nfunc (cb *CacheBuilder) EvictType(tp string) *CacheBuilder {\n\tcb.tp = tp\n\treturn cb\n}\n\nfunc (cb *CacheBuilder) Simple() *CacheBuilder {\n\treturn cb.EvictType(TYPE_SIMPLE)\n}\n\nfunc (cb *CacheBuilder) LRU() *CacheBuilder {\n\treturn cb.EvictType(TYPE_LRU)\n}\n\nfunc (cb *CacheBuilder) LFU() *CacheBuilder {\n\treturn cb.EvictType(TYPE_LFU)\n}\n\nfunc (cb *CacheBuilder) ARC() *CacheBuilder {\n\treturn cb.EvictType(TYPE_ARC)\n}\n\nfunc (cb *CacheBuilder) EvictedFunc(evictedFunc EvictedFunc) *CacheBuilder {\n\tcb.evictedFunc = evictedFunc\n\treturn cb\n}\n\nfunc (cb *CacheBuilder) PurgeVisitorFunc(purgeVisitorFunc PurgeVisitorFunc) *CacheBuilder {\n\tcb.purgeVisitorFunc = purgeVisitorFunc\n\treturn cb\n}\n\nfunc (cb *CacheBuilder) AddedFunc(addedFunc AddedFunc) *CacheBuilder {\n\tcb.addedFunc = addedFunc\n\treturn cb\n}\n\nfunc (cb *CacheBuilder) DeserializeFunc(deserializeFunc DeserializeFunc) *CacheBuilder {\n\tcb.deserializeFunc = deserializeFunc\n\treturn cb\n}\n\nfunc (cb *CacheBuilder) SerializeFunc(serializeFunc SerializeFunc) *CacheBuilder {\n\tcb.serializeFunc = serializeFunc\n\treturn cb\n}\n\nfunc (cb *CacheBuilder) Expiration(expiration time.Duration) *CacheBuilder {\n\tcb.expiration = &expiration\n\treturn cb\n}\n\nfunc (cb *CacheBuilder) Build() Cache {\n\tif cb.size <= 0 && cb.tp != TYPE_SIMPLE {\n\t\tpanic(\"gcache: Cache size <= 0\")\n\t}\n\n\treturn cb.build()\n}\n\nfunc (cb *CacheBuilder) build() Cache {\n\tswitch cb.tp {\n\tcase TYPE_SIMPLE:\n\t\treturn newSimpleCache(cb)\n\tcase TYPE_LRU:\n\t\treturn newLRUCache(cb)\n\tcase TYPE_LFU:\n\t\treturn newLFUCache(cb)\n\tcase TYPE_ARC:\n\t\treturn newARC(cb)\n\tdefault:\n\t\tpanic(\"gcache: Unknown type \" + cb.tp)\n\t}\n}\n\nfunc buildCache(c *baseCache, cb *CacheBuilder) {\n\tc.clock = cb.clock\n\tc.size = cb.size\n\tc.loaderExpireFunc = cb.loaderExpireFunc\n\tc.expiration = cb.expiration\n\tc.addedFunc = cb.addedFunc\n\tc.deserializeFunc = cb.deserializeFunc\n\tc.serializeFunc = cb.serializeFunc\n\tc.evictedFunc = cb.evictedFunc\n\tc.purgeVisitorFunc = cb.purgeVisitorFunc\n\tc.stats = &stats{}\n}\n\n// load a new value using by specified key.\nfunc (c *baseCache) load(key interface{}, cb func(interface{}, *time.Duration, error) (interface{}, error), isWait bool) (interface{}, bool, error) {\n\tv, called, err := c.loadGroup.Do(key, func() (v interface{}, e error) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\te = fmt.Errorf(\"Loader panics: %v\", r)\n\t\t\t}\n\t\t}()\n\t\treturn cb(c.loaderExpireFunc(key))\n\t}, isWait)\n\tif err != nil {\n\t\treturn nil, called, err\n\t}\n\treturn v, called, nil\n}\n"
        },
        {
          "name": "cache_test.go",
          "type": "blob",
          "size": 5.4140625,
          "content": "package gcache\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestLoaderFunc(t *testing.T) {\n\tsize := 2\n\tvar testCaches = []*CacheBuilder{\n\t\tNew(size).Simple(),\n\t\tNew(size).LRU(),\n\t\tNew(size).LFU(),\n\t\tNew(size).ARC(),\n\t}\n\tfor _, builder := range testCaches {\n\t\tvar testCounter int64\n\t\tcounter := 1000\n\t\tcache := builder.\n\t\t\tLoaderFunc(func(key interface{}) (interface{}, error) {\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\treturn atomic.AddInt64(&testCounter, 1), nil\n\t\t\t}).\n\t\t\tEvictedFunc(func(key, value interface{}) {\n\t\t\t\tpanic(key)\n\t\t\t}).Build()\n\n\t\tvar wg sync.WaitGroup\n\t\tfor i := 0; i < counter; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\t_, err := cache.Get(0)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\tif testCounter != 1 {\n\t\t\tt.Errorf(\"testCounter != %v\", testCounter)\n\t\t}\n\t}\n}\n\nfunc TestLoaderExpireFuncWithoutExpire(t *testing.T) {\n\tsize := 2\n\tvar testCaches = []*CacheBuilder{\n\t\tNew(size).Simple(),\n\t\tNew(size).LRU(),\n\t\tNew(size).LFU(),\n\t\tNew(size).ARC(),\n\t}\n\tfor _, builder := range testCaches {\n\t\tvar testCounter int64\n\t\tcounter := 1000\n\t\tcache := builder.\n\t\t\tLoaderExpireFunc(func(key interface{}) (interface{}, *time.Duration, error) {\n\t\t\t\treturn atomic.AddInt64(&testCounter, 1), nil, nil\n\t\t\t}).\n\t\t\tEvictedFunc(func(key, value interface{}) {\n\t\t\t\tpanic(key)\n\t\t\t}).Build()\n\n\t\tvar wg sync.WaitGroup\n\t\tfor i := 0; i < counter; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\t_, err := cache.Get(0)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\twg.Wait()\n\n\t\tif testCounter != 1 {\n\t\t\tt.Errorf(\"testCounter != %v\", testCounter)\n\t\t}\n\t}\n}\n\nfunc TestLoaderExpireFuncWithExpire(t *testing.T) {\n\tsize := 2\n\tvar testCaches = []*CacheBuilder{\n\t\tNew(size).Simple(),\n\t\tNew(size).LRU(),\n\t\tNew(size).LFU(),\n\t\tNew(size).ARC(),\n\t}\n\tfor _, builder := range testCaches {\n\t\tvar testCounter int64\n\t\tcounter := 1000\n\t\texpire := 200 * time.Millisecond\n\t\tcache := builder.\n\t\t\tLoaderExpireFunc(func(key interface{}) (interface{}, *time.Duration, error) {\n\t\t\t\treturn atomic.AddInt64(&testCounter, 1), &expire, nil\n\t\t\t}).\n\t\t\tBuild()\n\n\t\tvar wg sync.WaitGroup\n\t\tfor i := 0; i < counter; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\t_, err := cache.Get(0)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\ttime.Sleep(expire) // Waiting for key expiration\n\t\tfor i := 0; i < counter; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\t_, err := cache.Get(0)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\twg.Wait()\n\n\t\tif testCounter != 2 {\n\t\t\tt.Errorf(\"testCounter != %v\", testCounter)\n\t\t}\n\t}\n}\n\nfunc TestLoaderPurgeVisitorFunc(t *testing.T) {\n\tsize := 7\n\ttests := []struct {\n\t\tname         string\n\t\tcacheBuilder *CacheBuilder\n\t}{\n\t\t{\n\t\t\tname:         \"simple\",\n\t\t\tcacheBuilder: New(size).Simple(),\n\t\t},\n\t\t{\n\t\t\tname:         \"lru\",\n\t\t\tcacheBuilder: New(size).LRU(),\n\t\t},\n\t\t{\n\t\t\tname:         \"lfu\",\n\t\t\tcacheBuilder: New(size).LFU(),\n\t\t},\n\t\t{\n\t\t\tname:         \"arc\",\n\t\t\tcacheBuilder: New(size).ARC(),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar purgeCounter, evictCounter, loaderCounter int64\n\t\tcounter := 1000\n\t\tcache := test.cacheBuilder.\n\t\t\tLoaderFunc(func(key interface{}) (interface{}, error) {\n\t\t\t\treturn atomic.AddInt64(&loaderCounter, 1), nil\n\t\t\t}).\n\t\t\tEvictedFunc(func(key, value interface{}) {\n\t\t\t\tatomic.AddInt64(&evictCounter, 1)\n\t\t\t}).\n\t\t\tPurgeVisitorFunc(func(k, v interface{}) {\n\t\t\t\tatomic.AddInt64(&purgeCounter, 1)\n\t\t\t}).\n\t\t\tBuild()\n\n\t\tvar wg sync.WaitGroup\n\t\tfor i := 0; i < counter; i++ {\n\t\t\ti := i\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\t_, err := cache.Get(i)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\twg.Wait()\n\n\t\tif loaderCounter != int64(counter) {\n\t\t\tt.Errorf(\"%s: loaderCounter != %v\", test.name, loaderCounter)\n\t\t}\n\n\t\tcache.Purge()\n\n\t\tif evictCounter+purgeCounter != loaderCounter {\n\t\t\tt.Logf(\"%s: evictCounter: %d\", test.name, evictCounter)\n\t\t\tt.Logf(\"%s: purgeCounter: %d\", test.name, purgeCounter)\n\t\t\tt.Logf(\"%s: loaderCounter: %d\", test.name, loaderCounter)\n\t\t\tt.Errorf(\"%s: load != evict+purge\", test.name)\n\t\t}\n\t}\n}\n\nfunc TestDeserializeFunc(t *testing.T) {\n\tvar cases = []struct {\n\t\ttp string\n\t}{\n\t\t{TYPE_SIMPLE},\n\t\t{TYPE_LRU},\n\t\t{TYPE_LFU},\n\t\t{TYPE_ARC},\n\t}\n\n\tfor _, cs := range cases {\n\t\tkey1, value1 := \"key1\", \"value1\"\n\t\tkey2, value2 := \"key2\", \"value2\"\n\t\tcc := New(32).\n\t\t\tEvictType(cs.tp).\n\t\t\tLoaderFunc(func(k interface{}) (interface{}, error) {\n\t\t\t\treturn value1, nil\n\t\t\t}).\n\t\t\tDeserializeFunc(func(k, v interface{}) (interface{}, error) {\n\t\t\t\tdec := gob.NewDecoder(bytes.NewBuffer(v.([]byte)))\n\t\t\t\tvar str string\n\t\t\t\terr := dec.Decode(&str)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn str, nil\n\t\t\t}).\n\t\t\tSerializeFunc(func(k, v interface{}) (interface{}, error) {\n\t\t\t\tbuf := new(bytes.Buffer)\n\t\t\t\tenc := gob.NewEncoder(buf)\n\t\t\t\terr := enc.Encode(v)\n\t\t\t\treturn buf.Bytes(), err\n\t\t\t}).\n\t\t\tBuild()\n\t\tv, err := cc.Get(key1)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v != value1 {\n\t\t\tt.Errorf(\"%v != %v\", v, value1)\n\t\t}\n\t\tv, err = cc.Get(key1)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v != value1 {\n\t\t\tt.Errorf(\"%v != %v\", v, value1)\n\t\t}\n\t\tif err := cc.Set(key2, value2); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tv, err = cc.Get(key2)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif v != value2 {\n\t\t\tt.Errorf(\"%v != %v\", v, value2)\n\t\t}\n\t}\n}\n\nfunc TestExpiredItems(t *testing.T) {\n\tvar tps = []string{\n\t\tTYPE_SIMPLE,\n\t\tTYPE_LRU,\n\t\tTYPE_LFU,\n\t\tTYPE_ARC,\n\t}\n\tfor _, tp := range tps {\n\t\tt.Run(tp, func(t *testing.T) {\n\t\t\ttestExpiredItems(t, tp)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "clock.go",
          "type": "blob",
          "size": 0.78125,
          "content": "package gcache\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype Clock interface {\n\tNow() time.Time\n}\n\ntype RealClock struct{}\n\nfunc NewRealClock() Clock {\n\treturn RealClock{}\n}\n\nfunc (rc RealClock) Now() time.Time {\n\tt := time.Now()\n\treturn t\n}\n\ntype FakeClock interface {\n\tClock\n\n\tAdvance(d time.Duration)\n}\n\nfunc NewFakeClock() FakeClock {\n\treturn &fakeclock{\n\t\t// Taken from github.com/jonboulle/clockwork: use a fixture that does not fulfill Time.IsZero()\n\t\tnow: time.Date(1984, time.April, 4, 0, 0, 0, 0, time.UTC),\n\t}\n}\n\ntype fakeclock struct {\n\tnow time.Time\n\n\tmutex sync.RWMutex\n}\n\nfunc (fc *fakeclock) Now() time.Time {\n\tfc.mutex.RLock()\n\tdefer fc.mutex.RUnlock()\n\tt := fc.now\n\treturn t\n}\n\nfunc (fc *fakeclock) Advance(d time.Duration) {\n\tfc.mutex.Lock()\n\tdefer fc.mutex.Unlock()\n\tfc.now = fc.now.Add(d)\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0400390625,
          "content": "module github.com/bluele/gcache\n\ngo 1.15\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 3.4599609375,
          "content": "package gcache\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc loader(key interface{}) (interface{}, error) {\n\treturn fmt.Sprintf(\"valueFor%s\", key), nil\n}\n\nfunc testSetCache(t *testing.T, gc Cache, numbers int) {\n\tfor i := 0; i < numbers; i++ {\n\t\tkey := fmt.Sprintf(\"Key-%d\", i)\n\t\tvalue, err := loader(key)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\t\tgc.Set(key, value)\n\t}\n}\n\nfunc testGetCache(t *testing.T, gc Cache, numbers int) {\n\tfor i := 0; i < numbers; i++ {\n\t\tkey := fmt.Sprintf(\"Key-%d\", i)\n\t\tv, err := gc.Get(key)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\texpectedV, _ := loader(key)\n\t\tif v != expectedV {\n\t\t\tt.Errorf(\"Expected value is %v, not %v\", expectedV, v)\n\t\t}\n\t}\n}\n\nfunc testGetIFPresent(t *testing.T, evT string) {\n\tcache :=\n\t\tNew(8).\n\t\t\tEvictType(evT).\n\t\t\tLoaderFunc(\n\t\t\t\tfunc(key interface{}) (interface{}, error) {\n\t\t\t\t\treturn \"value\", nil\n\t\t\t\t}).\n\t\t\tBuild()\n\n\tv, err := cache.GetIFPresent(\"key\")\n\tif err != KeyNotFoundError {\n\t\tt.Errorf(\"err should not be %v\", err)\n\t}\n\n\ttime.Sleep(2 * time.Millisecond)\n\n\tv, err = cache.GetIFPresent(\"key\")\n\tif err != nil {\n\t\tt.Errorf(\"err should not be %v\", err)\n\t}\n\tif v != \"value\" {\n\t\tt.Errorf(\"v should not be %v\", v)\n\t}\n}\n\nfunc setItemsByRange(t *testing.T, c Cache, start, end int) {\n\tfor i := start; i < end; i++ {\n\t\tif err := c.Set(i, i); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc keysToMap(keys []interface{}) map[interface{}]struct{} {\n\tm := make(map[interface{}]struct{}, len(keys))\n\tfor _, k := range keys {\n\t\tm[k] = struct{}{}\n\t}\n\treturn m\n}\n\nfunc checkItemsByRange(t *testing.T, keys []interface{}, m map[interface{}]interface{}, size, start, end int) {\n\tif len(keys) != size {\n\t\tt.Fatalf(\"%v != %v\", len(keys), size)\n\t} else if len(m) != size {\n\t\tt.Fatalf(\"%v != %v\", len(m), size)\n\t}\n\tkm := keysToMap(keys)\n\tfor i := start; i < end; i++ {\n\t\tif _, ok := km[i]; !ok {\n\t\t\tt.Errorf(\"keys should contain %v\", i)\n\t\t}\n\t\tv, ok := m[i]\n\t\tif !ok {\n\t\t\tt.Errorf(\"m should contain %v\", i)\n\t\t\tcontinue\n\t\t}\n\t\tif v.(int) != i {\n\t\t\tt.Errorf(\"%v != %v\", v, i)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc testExpiredItems(t *testing.T, evT string) {\n\tsize := 8\n\tcache :=\n\t\tNew(size).\n\t\t\tExpiration(time.Millisecond).\n\t\t\tEvictType(evT).\n\t\t\tBuild()\n\n\tsetItemsByRange(t, cache, 0, size)\n\tcheckItemsByRange(t, cache.Keys(true), cache.GetALL(true), cache.Len(true), 0, size)\n\n\ttime.Sleep(time.Millisecond)\n\n\tcheckItemsByRange(t, cache.Keys(false), cache.GetALL(false), cache.Len(false), 0, size)\n\n\tif l := cache.Len(true); l != 0 {\n\t\tt.Fatalf(\"GetALL should returns no items, but got length %v\", l)\n\t}\n\n\tcache.Set(1, 1)\n\tm := cache.GetALL(true)\n\tif len(m) != 1 {\n\t\tt.Fatalf(\"%v != %v\", len(m), 1)\n\t} else if l := cache.Len(true); l != 1 {\n\t\tt.Fatalf(\"%v != %v\", l, 1)\n\t}\n\tif m[1] != 1 {\n\t\tt.Fatalf(\"%v != %v\", m[1], 1)\n\t}\n}\n\nfunc getSimpleEvictedFunc(t *testing.T) func(interface{}, interface{}) {\n\treturn func(key, value interface{}) {\n\t\tt.Logf(\"Key=%v Value=%v will be evicted.\\n\", key, value)\n\t}\n}\n\nfunc buildTestCache(t *testing.T, tp string, size int) Cache {\n\treturn New(size).\n\t\tEvictType(tp).\n\t\tEvictedFunc(getSimpleEvictedFunc(t)).\n\t\tBuild()\n}\n\nfunc buildTestLoadingCache(t *testing.T, tp string, size int, loader LoaderFunc) Cache {\n\treturn New(size).\n\t\tEvictType(tp).\n\t\tLoaderFunc(loader).\n\t\tEvictedFunc(getSimpleEvictedFunc(t)).\n\t\tBuild()\n}\n\nfunc buildTestLoadingCacheWithExpiration(t *testing.T, tp string, size int, ep time.Duration) Cache {\n\treturn New(size).\n\t\tEvictType(tp).\n\t\tExpiration(ep).\n\t\tLoaderFunc(loader).\n\t\tEvictedFunc(getSimpleEvictedFunc(t)).\n\t\tBuild()\n}\n"
        },
        {
          "name": "lfu.go",
          "type": "blob",
          "size": 7.9794921875,
          "content": "package gcache\n\nimport (\n\t\"container/list\"\n\t\"time\"\n)\n\n// Discards the least frequently used items first.\ntype LFUCache struct {\n\tbaseCache\n\titems    map[interface{}]*lfuItem\n\tfreqList *list.List // list for freqEntry\n}\n\nvar _ Cache = (*LFUCache)(nil)\n\ntype lfuItem struct {\n\tclock       Clock\n\tkey         interface{}\n\tvalue       interface{}\n\tfreqElement *list.Element\n\texpiration  *time.Time\n}\n\ntype freqEntry struct {\n\tfreq  uint\n\titems map[*lfuItem]struct{}\n}\n\nfunc newLFUCache(cb *CacheBuilder) *LFUCache {\n\tc := &LFUCache{}\n\tbuildCache(&c.baseCache, cb)\n\n\tc.init()\n\tc.loadGroup.cache = c\n\treturn c\n}\n\nfunc (c *LFUCache) init() {\n\tc.freqList = list.New()\n\tc.items = make(map[interface{}]*lfuItem, c.size)\n\tc.freqList.PushFront(&freqEntry{\n\t\tfreq:  0,\n\t\titems: make(map[*lfuItem]struct{}),\n\t})\n}\n\n// Set a new key-value pair\nfunc (c *LFUCache) Set(key, value interface{}) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\t_, err := c.set(key, value)\n\treturn err\n}\n\n// Set a new key-value pair with an expiration time\nfunc (c *LFUCache) SetWithExpire(key, value interface{}, expiration time.Duration) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\titem, err := c.set(key, value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt := c.clock.Now().Add(expiration)\n\titem.(*lfuItem).expiration = &t\n\treturn nil\n}\n\nfunc (c *LFUCache) set(key, value interface{}) (interface{}, error) {\n\tvar err error\n\tif c.serializeFunc != nil {\n\t\tvalue, err = c.serializeFunc(key, value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Check for existing item\n\titem, ok := c.items[key]\n\tif ok {\n\t\titem.value = value\n\t} else {\n\t\t// Verify size not exceeded\n\t\tif len(c.items) >= c.size {\n\t\t\tc.evict(1)\n\t\t}\n\t\titem = &lfuItem{\n\t\t\tclock:       c.clock,\n\t\t\tkey:         key,\n\t\t\tvalue:       value,\n\t\t\tfreqElement: nil,\n\t\t}\n\t\tel := c.freqList.Front()\n\t\tfe := el.Value.(*freqEntry)\n\t\tfe.items[item] = struct{}{}\n\n\t\titem.freqElement = el\n\t\tc.items[key] = item\n\t}\n\n\tif c.expiration != nil {\n\t\tt := c.clock.Now().Add(*c.expiration)\n\t\titem.expiration = &t\n\t}\n\n\tif c.addedFunc != nil {\n\t\tc.addedFunc(key, value)\n\t}\n\n\treturn item, nil\n}\n\n// Get a value from cache pool using key if it exists.\n// If it does not exists key and has LoaderFunc,\n// generate a value using `LoaderFunc` method returns value.\nfunc (c *LFUCache) Get(key interface{}) (interface{}, error) {\n\tv, err := c.get(key, false)\n\tif err == KeyNotFoundError {\n\t\treturn c.getWithLoader(key, true)\n\t}\n\treturn v, err\n}\n\n// GetIFPresent gets a value from cache pool using key if it exists.\n// If it does not exists key, returns KeyNotFoundError.\n// And send a request which refresh value for specified key if cache object has LoaderFunc.\nfunc (c *LFUCache) GetIFPresent(key interface{}) (interface{}, error) {\n\tv, err := c.get(key, false)\n\tif err == KeyNotFoundError {\n\t\treturn c.getWithLoader(key, false)\n\t}\n\treturn v, err\n}\n\nfunc (c *LFUCache) get(key interface{}, onLoad bool) (interface{}, error) {\n\tv, err := c.getValue(key, onLoad)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c.deserializeFunc != nil {\n\t\treturn c.deserializeFunc(key, v)\n\t}\n\treturn v, nil\n}\n\nfunc (c *LFUCache) getValue(key interface{}, onLoad bool) (interface{}, error) {\n\tc.mu.Lock()\n\titem, ok := c.items[key]\n\tif ok {\n\t\tif !item.IsExpired(nil) {\n\t\t\tc.increment(item)\n\t\t\tv := item.value\n\t\t\tc.mu.Unlock()\n\t\t\tif !onLoad {\n\t\t\t\tc.stats.IncrHitCount()\n\t\t\t}\n\t\t\treturn v, nil\n\t\t}\n\t\tc.removeItem(item)\n\t}\n\tc.mu.Unlock()\n\tif !onLoad {\n\t\tc.stats.IncrMissCount()\n\t}\n\treturn nil, KeyNotFoundError\n}\n\nfunc (c *LFUCache) getWithLoader(key interface{}, isWait bool) (interface{}, error) {\n\tif c.loaderExpireFunc == nil {\n\t\treturn nil, KeyNotFoundError\n\t}\n\tvalue, _, err := c.load(key, func(v interface{}, expiration *time.Duration, e error) (interface{}, error) {\n\t\tif e != nil {\n\t\t\treturn nil, e\n\t\t}\n\t\tc.mu.Lock()\n\t\tdefer c.mu.Unlock()\n\t\titem, err := c.set(key, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif expiration != nil {\n\t\t\tt := c.clock.Now().Add(*expiration)\n\t\t\titem.(*lfuItem).expiration = &t\n\t\t}\n\t\treturn v, nil\n\t}, isWait)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn value, nil\n}\n\nfunc (c *LFUCache) increment(item *lfuItem) {\n\tcurrentFreqElement := item.freqElement\n\tcurrentFreqEntry := currentFreqElement.Value.(*freqEntry)\n\tnextFreq := currentFreqEntry.freq + 1\n\tdelete(currentFreqEntry.items, item)\n\n\t// a boolean whether reuse the empty current entry\n\tremovable := isRemovableFreqEntry(currentFreqEntry)\n\n\t// insert item into a valid entry\n\tnextFreqElement := currentFreqElement.Next()\n\tswitch {\n\tcase nextFreqElement == nil || nextFreqElement.Value.(*freqEntry).freq > nextFreq:\n\t\tif removable {\n\t\t\tcurrentFreqEntry.freq = nextFreq\n\t\t\tnextFreqElement = currentFreqElement\n\t\t} else {\n\t\t\tnextFreqElement = c.freqList.InsertAfter(&freqEntry{\n\t\t\t\tfreq:  nextFreq,\n\t\t\t\titems: make(map[*lfuItem]struct{}),\n\t\t\t}, currentFreqElement)\n\t\t}\n\tcase nextFreqElement.Value.(*freqEntry).freq == nextFreq:\n\t\tif removable {\n\t\t\tc.freqList.Remove(currentFreqElement)\n\t\t}\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n\tnextFreqElement.Value.(*freqEntry).items[item] = struct{}{}\n\titem.freqElement = nextFreqElement\n}\n\n// evict removes the least frequence item from the cache.\nfunc (c *LFUCache) evict(count int) {\n\tentry := c.freqList.Front()\n\tfor i := 0; i < count; {\n\t\tif entry == nil {\n\t\t\treturn\n\t\t} else {\n\t\t\tfor item := range entry.Value.(*freqEntry).items {\n\t\t\t\tif i >= count {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tc.removeItem(item)\n\t\t\t\ti++\n\t\t\t}\n\t\t\tentry = entry.Next()\n\t\t}\n\t}\n}\n\n// Has checks if key exists in cache\nfunc (c *LFUCache) Has(key interface{}) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tnow := time.Now()\n\treturn c.has(key, &now)\n}\n\nfunc (c *LFUCache) has(key interface{}, now *time.Time) bool {\n\titem, ok := c.items[key]\n\tif !ok {\n\t\treturn false\n\t}\n\treturn !item.IsExpired(now)\n}\n\n// Remove removes the provided key from the cache.\nfunc (c *LFUCache) Remove(key interface{}) bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\treturn c.remove(key)\n}\n\nfunc (c *LFUCache) remove(key interface{}) bool {\n\tif item, ok := c.items[key]; ok {\n\t\tc.removeItem(item)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// removeElement is used to remove a given list element from the cache\nfunc (c *LFUCache) removeItem(item *lfuItem) {\n\tentry := item.freqElement.Value.(*freqEntry)\n\tdelete(c.items, item.key)\n\tdelete(entry.items, item)\n\tif isRemovableFreqEntry(entry) {\n\t\tc.freqList.Remove(item.freqElement)\n\t}\n\tif c.evictedFunc != nil {\n\t\tc.evictedFunc(item.key, item.value)\n\t}\n}\n\nfunc (c *LFUCache) keys() []interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tkeys := make([]interface{}, len(c.items))\n\tvar i = 0\n\tfor k := range c.items {\n\t\tkeys[i] = k\n\t\ti++\n\t}\n\treturn keys\n}\n\n// GetALL returns all key-value pairs in the cache.\nfunc (c *LFUCache) GetALL(checkExpired bool) map[interface{}]interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\titems := make(map[interface{}]interface{}, len(c.items))\n\tnow := time.Now()\n\tfor k, item := range c.items {\n\t\tif !checkExpired || c.has(k, &now) {\n\t\t\titems[k] = item.value\n\t\t}\n\t}\n\treturn items\n}\n\n// Keys returns a slice of the keys in the cache.\nfunc (c *LFUCache) Keys(checkExpired bool) []interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tkeys := make([]interface{}, 0, len(c.items))\n\tnow := time.Now()\n\tfor k := range c.items {\n\t\tif !checkExpired || c.has(k, &now) {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t}\n\treturn keys\n}\n\n// Len returns the number of items in the cache.\nfunc (c *LFUCache) Len(checkExpired bool) int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tif !checkExpired {\n\t\treturn len(c.items)\n\t}\n\tvar length int\n\tnow := time.Now()\n\tfor k := range c.items {\n\t\tif c.has(k, &now) {\n\t\t\tlength++\n\t\t}\n\t}\n\treturn length\n}\n\n// Completely clear the cache\nfunc (c *LFUCache) Purge() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.purgeVisitorFunc != nil {\n\t\tfor key, item := range c.items {\n\t\t\tc.purgeVisitorFunc(key, item.value)\n\t\t}\n\t}\n\n\tc.init()\n}\n\n// IsExpired returns boolean value whether this item is expired or not.\nfunc (it *lfuItem) IsExpired(now *time.Time) bool {\n\tif it.expiration == nil {\n\t\treturn false\n\t}\n\tif now == nil {\n\t\tt := it.clock.Now()\n\t\tnow = &t\n\t}\n\treturn it.expiration.Before(*now)\n}\n\nfunc isRemovableFreqEntry(entry *freqEntry) bool {\n\treturn entry.freq != 0 && len(entry.items) == 0\n}\n"
        },
        {
          "name": "lfu_test.go",
          "type": "blob",
          "size": 3.7841796875,
          "content": "package gcache\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestLFUGet(t *testing.T) {\n\tsize := 1000\n\tnumbers := 1000\n\n\tgc := buildTestLoadingCache(t, TYPE_LFU, size, loader)\n\ttestSetCache(t, gc, numbers)\n\ttestGetCache(t, gc, numbers)\n}\n\nfunc TestLoadingLFUGet(t *testing.T) {\n\tsize := 1000\n\tnumbers := 1000\n\n\tgc := buildTestLoadingCache(t, TYPE_LFU, size, loader)\n\ttestGetCache(t, gc, numbers)\n}\n\nfunc TestLFULength(t *testing.T) {\n\tgc := buildTestLoadingCache(t, TYPE_LFU, 1000, loader)\n\tgc.Get(\"test1\")\n\tgc.Get(\"test2\")\n\tlength := gc.Len(true)\n\texpectedLength := 2\n\tif length != expectedLength {\n\t\tt.Errorf(\"Expected length is %v, not %v\", length, expectedLength)\n\t}\n}\n\nfunc TestLFUEvictItem(t *testing.T) {\n\tcacheSize := 10\n\tnumbers := 11\n\tgc := buildTestLoadingCache(t, TYPE_LFU, cacheSize, loader)\n\n\tfor i := 0; i < numbers; i++ {\n\t\t_, err := gc.Get(fmt.Sprintf(\"Key-%d\", i))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestLFUGetIFPresent(t *testing.T) {\n\ttestGetIFPresent(t, TYPE_LFU)\n}\n\nfunc TestLFUHas(t *testing.T) {\n\tgc := buildTestLoadingCacheWithExpiration(t, TYPE_LFU, 2, 10*time.Millisecond)\n\n\tfor i := 0; i < 10; i++ {\n\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n\t\t\tgc.Get(\"test1\")\n\t\t\tgc.Get(\"test2\")\n\n\t\t\tif gc.Has(\"test0\") {\n\t\t\t\tt.Fatal(\"should not have test0\")\n\t\t\t}\n\t\t\tif !gc.Has(\"test1\") {\n\t\t\t\tt.Fatal(\"should have test1\")\n\t\t\t}\n\t\t\tif !gc.Has(\"test2\") {\n\t\t\t\tt.Fatal(\"should have test2\")\n\t\t\t}\n\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\t\tif gc.Has(\"test0\") {\n\t\t\t\tt.Fatal(\"should not have test0\")\n\t\t\t}\n\t\t\tif gc.Has(\"test1\") {\n\t\t\t\tt.Fatal(\"should not have test1\")\n\t\t\t}\n\t\t\tif gc.Has(\"test2\") {\n\t\t\t\tt.Fatal(\"should not have test2\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLFUFreqListOrder(t *testing.T) {\n\tgc := buildTestCache(t, TYPE_LFU, 5)\n\tfor i := 4; i >= 0; i-- {\n\t\tgc.Set(i, i)\n\t\tfor j := 0; j <= i; j++ {\n\t\t\tgc.Get(i)\n\t\t}\n\t}\n\tif l := gc.(*LFUCache).freqList.Len(); l != 6 {\n\t\tt.Fatalf(\"%v != 6\", l)\n\t}\n\tvar i uint\n\tfor e := gc.(*LFUCache).freqList.Front(); e != nil; e = e.Next() {\n\t\tif e.Value.(*freqEntry).freq != i {\n\t\t\tt.Fatalf(\"%v != %v\", e.Value.(*freqEntry).freq, i)\n\t\t}\n\t\ti++\n\t}\n\tgc.Remove(1)\n\n\tif l := gc.(*LFUCache).freqList.Len(); l != 5 {\n\t\tt.Fatalf(\"%v != 5\", l)\n\t}\n\tgc.Set(1, 1)\n\tif l := gc.(*LFUCache).freqList.Len(); l != 5 {\n\t\tt.Fatalf(\"%v != 5\", l)\n\t}\n\tgc.Get(1)\n\tif l := gc.(*LFUCache).freqList.Len(); l != 5 {\n\t\tt.Fatalf(\"%v != 5\", l)\n\t}\n\tgc.Get(1)\n\tif l := gc.(*LFUCache).freqList.Len(); l != 6 {\n\t\tt.Fatalf(\"%v != 6\", l)\n\t}\n}\n\nfunc TestLFUFreqListLength(t *testing.T) {\n\tk0, v0 := \"k0\", \"v0\"\n\tk1, v1 := \"k1\", \"v1\"\n\n\t{\n\t\tgc := buildTestCache(t, TYPE_LFU, 5)\n\t\tif l := gc.(*LFUCache).freqList.Len(); l != 1 {\n\t\t\tt.Fatalf(\"%v != 1\", l)\n\t\t}\n\t}\n\t{\n\t\tgc := buildTestCache(t, TYPE_LFU, 5)\n\t\tgc.Set(k0, v0)\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tgc.Get(k0)\n\t\t}\n\t\tif l := gc.(*LFUCache).freqList.Len(); l != 2 {\n\t\t\tt.Fatalf(\"%v != 2\", l)\n\t\t}\n\t}\n\n\t{\n\t\tgc := buildTestCache(t, TYPE_LFU, 5)\n\t\tgc.Set(k0, v0)\n\t\tgc.Set(k1, v1)\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tgc.Get(k0)\n\t\t\tgc.Get(k1)\n\t\t}\n\t\tif l := gc.(*LFUCache).freqList.Len(); l != 2 {\n\t\t\tt.Fatalf(\"%v != 2\", l)\n\t\t}\n\t}\n\n\t{\n\t\tgc := buildTestCache(t, TYPE_LFU, 5)\n\t\tgc.Set(k0, v0)\n\t\tgc.Set(k1, v1)\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tgc.Get(k0)\n\t\t}\n\t\tif l := gc.(*LFUCache).freqList.Len(); l != 2 {\n\t\t\tt.Fatalf(\"%v != 2\", l)\n\t\t}\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tgc.Get(k1)\n\t\t}\n\t\tif l := gc.(*LFUCache).freqList.Len(); l != 2 {\n\t\t\tt.Fatalf(\"%v != 2\", l)\n\t\t}\n\t}\n\n\t{\n\t\tgc := buildTestCache(t, TYPE_LFU, 5)\n\t\tgc.Set(k0, v0)\n\t\tgc.Get(k0)\n\t\tif l := gc.(*LFUCache).freqList.Len(); l != 2 {\n\t\t\tt.Fatalf(\"%v != 2\", l)\n\t\t}\n\t\tgc.Remove(k0)\n\t\tif l := gc.(*LFUCache).freqList.Len(); l != 1 {\n\t\t\tt.Fatalf(\"%v != 1\", l)\n\t\t}\n\t\tgc.Set(k0, v0)\n\t\tif l := gc.(*LFUCache).freqList.Len(); l != 1 {\n\t\t\tt.Fatalf(\"%v != 1\", l)\n\t\t}\n\t\tgc.Get(k0)\n\t\tif l := gc.(*LFUCache).freqList.Len(); l != 2 {\n\t\t\tt.Fatalf(\"%v != 2\", l)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "lru.go",
          "type": "blob",
          "size": 6.4755859375,
          "content": "package gcache\n\nimport (\n\t\"container/list\"\n\t\"time\"\n)\n\n// Discards the least recently used items first.\ntype LRUCache struct {\n\tbaseCache\n\titems     map[interface{}]*list.Element\n\tevictList *list.List\n}\n\nfunc newLRUCache(cb *CacheBuilder) *LRUCache {\n\tc := &LRUCache{}\n\tbuildCache(&c.baseCache, cb)\n\n\tc.init()\n\tc.loadGroup.cache = c\n\treturn c\n}\n\nfunc (c *LRUCache) init() {\n\tc.evictList = list.New()\n\tc.items = make(map[interface{}]*list.Element, c.size+1)\n}\n\nfunc (c *LRUCache) set(key, value interface{}) (interface{}, error) {\n\tvar err error\n\tif c.serializeFunc != nil {\n\t\tvalue, err = c.serializeFunc(key, value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Check for existing item\n\tvar item *lruItem\n\tif it, ok := c.items[key]; ok {\n\t\tc.evictList.MoveToFront(it)\n\t\titem = it.Value.(*lruItem)\n\t\titem.value = value\n\t} else {\n\t\t// Verify size not exceeded\n\t\tif c.evictList.Len() >= c.size {\n\t\t\tc.evict(1)\n\t\t}\n\t\titem = &lruItem{\n\t\t\tclock: c.clock,\n\t\t\tkey:   key,\n\t\t\tvalue: value,\n\t\t}\n\t\tc.items[key] = c.evictList.PushFront(item)\n\t}\n\n\tif c.expiration != nil {\n\t\tt := c.clock.Now().Add(*c.expiration)\n\t\titem.expiration = &t\n\t}\n\n\tif c.addedFunc != nil {\n\t\tc.addedFunc(key, value)\n\t}\n\n\treturn item, nil\n}\n\n// set a new key-value pair\nfunc (c *LRUCache) Set(key, value interface{}) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\t_, err := c.set(key, value)\n\treturn err\n}\n\n// Set a new key-value pair with an expiration time\nfunc (c *LRUCache) SetWithExpire(key, value interface{}, expiration time.Duration) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\titem, err := c.set(key, value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt := c.clock.Now().Add(expiration)\n\titem.(*lruItem).expiration = &t\n\treturn nil\n}\n\n// Get a value from cache pool using key if it exists.\n// If it does not exists key and has LoaderFunc,\n// generate a value using `LoaderFunc` method returns value.\nfunc (c *LRUCache) Get(key interface{}) (interface{}, error) {\n\tv, err := c.get(key, false)\n\tif err == KeyNotFoundError {\n\t\treturn c.getWithLoader(key, true)\n\t}\n\treturn v, err\n}\n\n// GetIFPresent gets a value from cache pool using key if it exists.\n// If it does not exists key, returns KeyNotFoundError.\n// And send a request which refresh value for specified key if cache object has LoaderFunc.\nfunc (c *LRUCache) GetIFPresent(key interface{}) (interface{}, error) {\n\tv, err := c.get(key, false)\n\tif err == KeyNotFoundError {\n\t\treturn c.getWithLoader(key, false)\n\t}\n\treturn v, err\n}\n\nfunc (c *LRUCache) get(key interface{}, onLoad bool) (interface{}, error) {\n\tv, err := c.getValue(key, onLoad)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c.deserializeFunc != nil {\n\t\treturn c.deserializeFunc(key, v)\n\t}\n\treturn v, nil\n}\n\nfunc (c *LRUCache) getValue(key interface{}, onLoad bool) (interface{}, error) {\n\tc.mu.Lock()\n\titem, ok := c.items[key]\n\tif ok {\n\t\tit := item.Value.(*lruItem)\n\t\tif !it.IsExpired(nil) {\n\t\t\tc.evictList.MoveToFront(item)\n\t\t\tv := it.value\n\t\t\tc.mu.Unlock()\n\t\t\tif !onLoad {\n\t\t\t\tc.stats.IncrHitCount()\n\t\t\t}\n\t\t\treturn v, nil\n\t\t}\n\t\tc.removeElement(item)\n\t}\n\tc.mu.Unlock()\n\tif !onLoad {\n\t\tc.stats.IncrMissCount()\n\t}\n\treturn nil, KeyNotFoundError\n}\n\nfunc (c *LRUCache) getWithLoader(key interface{}, isWait bool) (interface{}, error) {\n\tif c.loaderExpireFunc == nil {\n\t\treturn nil, KeyNotFoundError\n\t}\n\tvalue, _, err := c.load(key, func(v interface{}, expiration *time.Duration, e error) (interface{}, error) {\n\t\tif e != nil {\n\t\t\treturn nil, e\n\t\t}\n\t\tc.mu.Lock()\n\t\tdefer c.mu.Unlock()\n\t\titem, err := c.set(key, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif expiration != nil {\n\t\t\tt := c.clock.Now().Add(*expiration)\n\t\t\titem.(*lruItem).expiration = &t\n\t\t}\n\t\treturn v, nil\n\t}, isWait)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn value, nil\n}\n\n// evict removes the oldest item from the cache.\nfunc (c *LRUCache) evict(count int) {\n\tfor i := 0; i < count; i++ {\n\t\tent := c.evictList.Back()\n\t\tif ent == nil {\n\t\t\treturn\n\t\t} else {\n\t\t\tc.removeElement(ent)\n\t\t}\n\t}\n}\n\n// Has checks if key exists in cache\nfunc (c *LRUCache) Has(key interface{}) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tnow := time.Now()\n\treturn c.has(key, &now)\n}\n\nfunc (c *LRUCache) has(key interface{}, now *time.Time) bool {\n\titem, ok := c.items[key]\n\tif !ok {\n\t\treturn false\n\t}\n\treturn !item.Value.(*lruItem).IsExpired(now)\n}\n\n// Remove removes the provided key from the cache.\nfunc (c *LRUCache) Remove(key interface{}) bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\treturn c.remove(key)\n}\n\nfunc (c *LRUCache) remove(key interface{}) bool {\n\tif ent, ok := c.items[key]; ok {\n\t\tc.removeElement(ent)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (c *LRUCache) removeElement(e *list.Element) {\n\tc.evictList.Remove(e)\n\tentry := e.Value.(*lruItem)\n\tdelete(c.items, entry.key)\n\tif c.evictedFunc != nil {\n\t\tentry := e.Value.(*lruItem)\n\t\tc.evictedFunc(entry.key, entry.value)\n\t}\n}\n\nfunc (c *LRUCache) keys() []interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tkeys := make([]interface{}, len(c.items))\n\tvar i = 0\n\tfor k := range c.items {\n\t\tkeys[i] = k\n\t\ti++\n\t}\n\treturn keys\n}\n\n// GetALL returns all key-value pairs in the cache.\nfunc (c *LRUCache) GetALL(checkExpired bool) map[interface{}]interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\titems := make(map[interface{}]interface{}, len(c.items))\n\tnow := time.Now()\n\tfor k, item := range c.items {\n\t\tif !checkExpired || c.has(k, &now) {\n\t\t\titems[k] = item.Value.(*lruItem).value\n\t\t}\n\t}\n\treturn items\n}\n\n// Keys returns a slice of the keys in the cache.\nfunc (c *LRUCache) Keys(checkExpired bool) []interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tkeys := make([]interface{}, 0, len(c.items))\n\tnow := time.Now()\n\tfor k := range c.items {\n\t\tif !checkExpired || c.has(k, &now) {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t}\n\treturn keys\n}\n\n// Len returns the number of items in the cache.\nfunc (c *LRUCache) Len(checkExpired bool) int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tif !checkExpired {\n\t\treturn len(c.items)\n\t}\n\tvar length int\n\tnow := time.Now()\n\tfor k := range c.items {\n\t\tif c.has(k, &now) {\n\t\t\tlength++\n\t\t}\n\t}\n\treturn length\n}\n\n// Completely clear the cache\nfunc (c *LRUCache) Purge() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.purgeVisitorFunc != nil {\n\t\tfor key, item := range c.items {\n\t\t\tit := item.Value.(*lruItem)\n\t\t\tv := it.value\n\t\t\tc.purgeVisitorFunc(key, v)\n\t\t}\n\t}\n\n\tc.init()\n}\n\ntype lruItem struct {\n\tclock      Clock\n\tkey        interface{}\n\tvalue      interface{}\n\texpiration *time.Time\n}\n\n// IsExpired returns boolean value whether this item is expired or not.\nfunc (it *lruItem) IsExpired(now *time.Time) bool {\n\tif it.expiration == nil {\n\t\treturn false\n\t}\n\tif now == nil {\n\t\tt := it.clock.Now()\n\t\tnow = &t\n\t}\n\treturn it.expiration.Before(*now)\n}\n"
        },
        {
          "name": "lru_test.go",
          "type": "blob",
          "size": 1.5888671875,
          "content": "package gcache\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestLRUGet(t *testing.T) {\n\tsize := 1000\n\tgc := buildTestCache(t, TYPE_LRU, size)\n\ttestSetCache(t, gc, size)\n\ttestGetCache(t, gc, size)\n}\n\nfunc TestLoadingLRUGet(t *testing.T) {\n\tsize := 1000\n\tgc := buildTestLoadingCache(t, TYPE_LRU, size, loader)\n\ttestGetCache(t, gc, size)\n}\n\nfunc TestLRULength(t *testing.T) {\n\tgc := buildTestLoadingCache(t, TYPE_LRU, 1000, loader)\n\tgc.Get(\"test1\")\n\tgc.Get(\"test2\")\n\tlength := gc.Len(true)\n\texpectedLength := 2\n\tif length != expectedLength {\n\t\tt.Errorf(\"Expected length is %v, not %v\", length, expectedLength)\n\t}\n}\n\nfunc TestLRUEvictItem(t *testing.T) {\n\tcacheSize := 10\n\tnumbers := 11\n\tgc := buildTestLoadingCache(t, TYPE_LRU, cacheSize, loader)\n\n\tfor i := 0; i < numbers; i++ {\n\t\t_, err := gc.Get(fmt.Sprintf(\"Key-%d\", i))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestLRUGetIFPresent(t *testing.T) {\n\ttestGetIFPresent(t, TYPE_LRU)\n}\n\nfunc TestLRUHas(t *testing.T) {\n\tgc := buildTestLoadingCacheWithExpiration(t, TYPE_LRU, 2, 10*time.Millisecond)\n\n\tfor i := 0; i < 10; i++ {\n\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n\t\t\tgc.Get(\"test1\")\n\t\t\tgc.Get(\"test2\")\n\n\t\t\tif gc.Has(\"test0\") {\n\t\t\t\tt.Fatal(\"should not have test0\")\n\t\t\t}\n\t\t\tif !gc.Has(\"test1\") {\n\t\t\t\tt.Fatal(\"should have test1\")\n\t\t\t}\n\t\t\tif !gc.Has(\"test2\") {\n\t\t\t\tt.Fatal(\"should have test2\")\n\t\t\t}\n\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\t\tif gc.Has(\"test0\") {\n\t\t\t\tt.Fatal(\"should not have test0\")\n\t\t\t}\n\t\t\tif gc.Has(\"test1\") {\n\t\t\t\tt.Fatal(\"should not have test1\")\n\t\t\t}\n\t\t\tif gc.Has(\"test2\") {\n\t\t\t\tt.Fatal(\"should not have test2\")\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "simple.go",
          "type": "blob",
          "size": 6.251953125,
          "content": "package gcache\n\nimport (\n\t\"time\"\n)\n\n// SimpleCache has no clear priority for evict cache. It depends on key-value map order.\ntype SimpleCache struct {\n\tbaseCache\n\titems map[interface{}]*simpleItem\n}\n\nfunc newSimpleCache(cb *CacheBuilder) *SimpleCache {\n\tc := &SimpleCache{}\n\tbuildCache(&c.baseCache, cb)\n\n\tc.init()\n\tc.loadGroup.cache = c\n\treturn c\n}\n\nfunc (c *SimpleCache) init() {\n\tif c.size <= 0 {\n\t\tc.items = make(map[interface{}]*simpleItem)\n\t} else {\n\t\tc.items = make(map[interface{}]*simpleItem, c.size)\n\t}\n}\n\n// Set a new key-value pair\nfunc (c *SimpleCache) Set(key, value interface{}) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\t_, err := c.set(key, value)\n\treturn err\n}\n\n// Set a new key-value pair with an expiration time\nfunc (c *SimpleCache) SetWithExpire(key, value interface{}, expiration time.Duration) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\titem, err := c.set(key, value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt := c.clock.Now().Add(expiration)\n\titem.(*simpleItem).expiration = &t\n\treturn nil\n}\n\nfunc (c *SimpleCache) set(key, value interface{}) (interface{}, error) {\n\tvar err error\n\tif c.serializeFunc != nil {\n\t\tvalue, err = c.serializeFunc(key, value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Check for existing item\n\titem, ok := c.items[key]\n\tif ok {\n\t\titem.value = value\n\t} else {\n\t\t// Verify size not exceeded\n\t\tif (len(c.items) >= c.size) && c.size > 0 {\n\t\t\tc.evict(1)\n\t\t}\n\t\titem = &simpleItem{\n\t\t\tclock: c.clock,\n\t\t\tvalue: value,\n\t\t}\n\t\tc.items[key] = item\n\t}\n\n\tif c.expiration != nil {\n\t\tt := c.clock.Now().Add(*c.expiration)\n\t\titem.expiration = &t\n\t}\n\n\tif c.addedFunc != nil {\n\t\tc.addedFunc(key, value)\n\t}\n\n\treturn item, nil\n}\n\n// Get a value from cache pool using key if it exists.\n// If it does not exists key and has LoaderFunc,\n// generate a value using `LoaderFunc` method returns value.\nfunc (c *SimpleCache) Get(key interface{}) (interface{}, error) {\n\tv, err := c.get(key, false)\n\tif err == KeyNotFoundError {\n\t\treturn c.getWithLoader(key, true)\n\t}\n\treturn v, err\n}\n\n// GetIFPresent gets a value from cache pool using key if it exists.\n// If it does not exists key, returns KeyNotFoundError.\n// And send a request which refresh value for specified key if cache object has LoaderFunc.\nfunc (c *SimpleCache) GetIFPresent(key interface{}) (interface{}, error) {\n\tv, err := c.get(key, false)\n\tif err == KeyNotFoundError {\n\t\treturn c.getWithLoader(key, false)\n\t}\n\treturn v, nil\n}\n\nfunc (c *SimpleCache) get(key interface{}, onLoad bool) (interface{}, error) {\n\tv, err := c.getValue(key, onLoad)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif c.deserializeFunc != nil {\n\t\treturn c.deserializeFunc(key, v)\n\t}\n\treturn v, nil\n}\n\nfunc (c *SimpleCache) getValue(key interface{}, onLoad bool) (interface{}, error) {\n\tc.mu.Lock()\n\titem, ok := c.items[key]\n\tif ok {\n\t\tif !item.IsExpired(nil) {\n\t\t\tv := item.value\n\t\t\tc.mu.Unlock()\n\t\t\tif !onLoad {\n\t\t\t\tc.stats.IncrHitCount()\n\t\t\t}\n\t\t\treturn v, nil\n\t\t}\n\t\tc.remove(key)\n\t}\n\tc.mu.Unlock()\n\tif !onLoad {\n\t\tc.stats.IncrMissCount()\n\t}\n\treturn nil, KeyNotFoundError\n}\n\nfunc (c *SimpleCache) getWithLoader(key interface{}, isWait bool) (interface{}, error) {\n\tif c.loaderExpireFunc == nil {\n\t\treturn nil, KeyNotFoundError\n\t}\n\tvalue, _, err := c.load(key, func(v interface{}, expiration *time.Duration, e error) (interface{}, error) {\n\t\tif e != nil {\n\t\t\treturn nil, e\n\t\t}\n\t\tc.mu.Lock()\n\t\tdefer c.mu.Unlock()\n\t\titem, err := c.set(key, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif expiration != nil {\n\t\t\tt := c.clock.Now().Add(*expiration)\n\t\t\titem.(*simpleItem).expiration = &t\n\t\t}\n\t\treturn v, nil\n\t}, isWait)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn value, nil\n}\n\nfunc (c *SimpleCache) evict(count int) {\n\tnow := c.clock.Now()\n\tcurrent := 0\n\tfor key, item := range c.items {\n\t\tif current >= count {\n\t\t\treturn\n\t\t}\n\t\tif item.expiration == nil || now.After(*item.expiration) {\n\t\t\tdefer c.remove(key)\n\t\t\tcurrent++\n\t\t}\n\t}\n}\n\n// Has checks if key exists in cache\nfunc (c *SimpleCache) Has(key interface{}) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tnow := time.Now()\n\treturn c.has(key, &now)\n}\n\nfunc (c *SimpleCache) has(key interface{}, now *time.Time) bool {\n\titem, ok := c.items[key]\n\tif !ok {\n\t\treturn false\n\t}\n\treturn !item.IsExpired(now)\n}\n\n// Remove removes the provided key from the cache.\nfunc (c *SimpleCache) Remove(key interface{}) bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\treturn c.remove(key)\n}\n\nfunc (c *SimpleCache) remove(key interface{}) bool {\n\titem, ok := c.items[key]\n\tif ok {\n\t\tdelete(c.items, key)\n\t\tif c.evictedFunc != nil {\n\t\t\tc.evictedFunc(key, item.value)\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Returns a slice of the keys in the cache.\nfunc (c *SimpleCache) keys() []interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tkeys := make([]interface{}, len(c.items))\n\tvar i = 0\n\tfor k := range c.items {\n\t\tkeys[i] = k\n\t\ti++\n\t}\n\treturn keys\n}\n\n// GetALL returns all key-value pairs in the cache.\nfunc (c *SimpleCache) GetALL(checkExpired bool) map[interface{}]interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\titems := make(map[interface{}]interface{}, len(c.items))\n\tnow := time.Now()\n\tfor k, item := range c.items {\n\t\tif !checkExpired || c.has(k, &now) {\n\t\t\titems[k] = item.value\n\t\t}\n\t}\n\treturn items\n}\n\n// Keys returns a slice of the keys in the cache.\nfunc (c *SimpleCache) Keys(checkExpired bool) []interface{} {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tkeys := make([]interface{}, 0, len(c.items))\n\tnow := time.Now()\n\tfor k := range c.items {\n\t\tif !checkExpired || c.has(k, &now) {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t}\n\treturn keys\n}\n\n// Len returns the number of items in the cache.\nfunc (c *SimpleCache) Len(checkExpired bool) int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tif !checkExpired {\n\t\treturn len(c.items)\n\t}\n\tvar length int\n\tnow := time.Now()\n\tfor k := range c.items {\n\t\tif c.has(k, &now) {\n\t\t\tlength++\n\t\t}\n\t}\n\treturn length\n}\n\n// Completely clear the cache\nfunc (c *SimpleCache) Purge() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.purgeVisitorFunc != nil {\n\t\tfor key, item := range c.items {\n\t\t\tc.purgeVisitorFunc(key, item.value)\n\t\t}\n\t}\n\n\tc.init()\n}\n\ntype simpleItem struct {\n\tclock      Clock\n\tvalue      interface{}\n\texpiration *time.Time\n}\n\n// IsExpired returns boolean value whether this item is expired or not.\nfunc (si *simpleItem) IsExpired(now *time.Time) bool {\n\tif si.expiration == nil {\n\t\treturn false\n\t}\n\tif now == nil {\n\t\tt := si.clock.Now()\n\t\tnow = &t\n\t}\n\treturn si.expiration.Before(*now)\n}\n"
        },
        {
          "name": "simple_test.go",
          "type": "blob",
          "size": 2.08203125,
          "content": "package gcache\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSimpleGet(t *testing.T) {\n\tsize := 1000\n\tgc := buildTestCache(t, TYPE_SIMPLE, size)\n\ttestSetCache(t, gc, size)\n\ttestGetCache(t, gc, size)\n}\n\nfunc TestLoadingSimpleGet(t *testing.T) {\n\tsize := 1000\n\tnumbers := 1000\n\ttestGetCache(t, buildTestLoadingCache(t, TYPE_SIMPLE, size, loader), numbers)\n}\n\nfunc TestSimpleLength(t *testing.T) {\n\tgc := buildTestLoadingCache(t, TYPE_SIMPLE, 1000, loader)\n\tgc.Get(\"test1\")\n\tgc.Get(\"test2\")\n\tlength := gc.Len(true)\n\texpectedLength := 2\n\tif length != expectedLength {\n\t\tt.Errorf(\"Expected length is %v, not %v\", length, expectedLength)\n\t}\n}\n\nfunc TestSimpleEvictItem(t *testing.T) {\n\tcacheSize := 10\n\tnumbers := 11\n\tgc := buildTestLoadingCache(t, TYPE_SIMPLE, cacheSize, loader)\n\n\tfor i := 0; i < numbers; i++ {\n\t\t_, err := gc.Get(fmt.Sprintf(\"Key-%d\", i))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestSimpleUnboundedNoEviction(t *testing.T) {\n\tnumbers := 1000\n\tsize_tracker := 0\n\tgcu := buildTestLoadingCache(t, TYPE_SIMPLE, 0, loader)\n\n\tfor i := 0; i < numbers; i++ {\n\t\tcurrent_size := gcu.Len(true)\n\t\tif current_size != size_tracker {\n\t\t\tt.Errorf(\"Excepted cache size is %v not %v\", current_size, size_tracker)\n\t\t}\n\n\t\t_, err := gcu.Get(fmt.Sprintf(\"Key-%d\", i))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\n\t\tsize_tracker++\n\t}\n}\n\nfunc TestSimpleGetIFPresent(t *testing.T) {\n\ttestGetIFPresent(t, TYPE_SIMPLE)\n}\n\nfunc TestSimpleHas(t *testing.T) {\n\tgc := buildTestLoadingCacheWithExpiration(t, TYPE_SIMPLE, 2, 10*time.Millisecond)\n\n\tfor i := 0; i < 10; i++ {\n\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n\t\t\tgc.Get(\"test1\")\n\t\t\tgc.Get(\"test2\")\n\n\t\t\tif gc.Has(\"test0\") {\n\t\t\t\tt.Fatal(\"should not have test0\")\n\t\t\t}\n\t\t\tif !gc.Has(\"test1\") {\n\t\t\t\tt.Fatal(\"should have test1\")\n\t\t\t}\n\t\t\tif !gc.Has(\"test2\") {\n\t\t\t\tt.Fatal(\"should have test2\")\n\t\t\t}\n\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\t\tif gc.Has(\"test0\") {\n\t\t\t\tt.Fatal(\"should not have test0\")\n\t\t\t}\n\t\t\tif gc.Has(\"test1\") {\n\t\t\t\tt.Fatal(\"should not have test1\")\n\t\t\t}\n\t\t\tif gc.Has(\"test2\") {\n\t\t\t\tt.Fatal(\"should not have test2\")\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "singleflight.go",
          "type": "blob",
          "size": 2.0673828125,
          "content": "package gcache\n\n/*\nCopyright 2012 Google Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// This module provides a duplicate function call suppression\n// mechanism.\n\nimport \"sync\"\n\n// call is an in-flight or completed Do call\ntype call struct {\n\twg  sync.WaitGroup\n\tval interface{}\n\terr error\n}\n\n// Group represents a class of work and forms a namespace in which\n// units of work can be executed with duplicate suppression.\ntype Group struct {\n\tcache Cache\n\tmu    sync.Mutex            // protects m\n\tm     map[interface{}]*call // lazily initialized\n}\n\n// Do executes and returns the results of the given function, making\n// sure that only one execution is in-flight for a given key at a\n// time. If a duplicate comes in, the duplicate caller waits for the\n// original to complete and receives the same results.\nfunc (g *Group) Do(key interface{}, fn func() (interface{}, error), isWait bool) (interface{}, bool, error) {\n\tg.mu.Lock()\n\tv, err := g.cache.get(key, true)\n\tif err == nil {\n\t\tg.mu.Unlock()\n\t\treturn v, false, nil\n\t}\n\tif g.m == nil {\n\t\tg.m = make(map[interface{}]*call)\n\t}\n\tif c, ok := g.m[key]; ok {\n\t\tg.mu.Unlock()\n\t\tif !isWait {\n\t\t\treturn nil, false, KeyNotFoundError\n\t\t}\n\t\tc.wg.Wait()\n\t\treturn c.val, false, c.err\n\t}\n\tc := new(call)\n\tc.wg.Add(1)\n\tg.m[key] = c\n\tg.mu.Unlock()\n\tif !isWait {\n\t\tgo g.call(c, key, fn)\n\t\treturn nil, false, KeyNotFoundError\n\t}\n\tv, err = g.call(c, key, fn)\n\treturn v, true, err\n}\n\nfunc (g *Group) call(c *call, key interface{}, fn func() (interface{}, error)) (interface{}, error) {\n\tc.val, c.err = fn()\n\tc.wg.Done()\n\n\tg.mu.Lock()\n\tdelete(g.m, key)\n\tg.mu.Unlock()\n\n\treturn c.val, c.err\n}\n"
        },
        {
          "name": "singleflight_test.go",
          "type": "blob",
          "size": 1.9462890625,
          "content": "package gcache\n\n/*\nCopyright 2012 Google Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestDo(t *testing.T) {\n\tvar g Group\n\tg.cache = New(32).Build()\n\tv, _, err := g.Do(\"key\", func() (interface{}, error) {\n\t\treturn \"bar\", nil\n\t}, true)\n\tif got, want := fmt.Sprintf(\"%v (%T)\", v, v), \"bar (string)\"; got != want {\n\t\tt.Errorf(\"Do = %v; want %v\", got, want)\n\t}\n\tif err != nil {\n\t\tt.Errorf(\"Do error = %v\", err)\n\t}\n}\n\nfunc TestDoErr(t *testing.T) {\n\tvar g Group\n\tg.cache = New(32).Build()\n\tsomeErr := errors.New(\"Some error\")\n\tv, _, err := g.Do(\"key\", func() (interface{}, error) {\n\t\treturn nil, someErr\n\t}, true)\n\tif err != someErr {\n\t\tt.Errorf(\"Do error = %v; want someErr\", err)\n\t}\n\tif v != nil {\n\t\tt.Errorf(\"unexpected non-nil value %#v\", v)\n\t}\n}\n\nfunc TestDoDupSuppress(t *testing.T) {\n\tvar g Group\n\tg.cache = New(32).Build()\n\tc := make(chan string)\n\tvar calls int32\n\tfn := func() (interface{}, error) {\n\t\tatomic.AddInt32(&calls, 1)\n\t\treturn <-c, nil\n\t}\n\n\tconst n = 10\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < n; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tv, _, err := g.Do(\"key\", fn, true)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Do error: %v\", err)\n\t\t\t}\n\t\t\tif v.(string) != \"bar\" {\n\t\t\t\tt.Errorf(\"got %q; want %q\", v, \"bar\")\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\ttime.Sleep(100 * time.Millisecond) // let goroutines above block\n\tc <- \"bar\"\n\twg.Wait()\n\tif got := atomic.LoadInt32(&calls); got != 1 {\n\t\tt.Errorf(\"number of calls = %d; want 1\", got)\n\t}\n}\n"
        },
        {
          "name": "stats.go",
          "type": "blob",
          "size": 0.9794921875,
          "content": "package gcache\n\nimport (\n\t\"sync/atomic\"\n)\n\ntype statsAccessor interface {\n\tHitCount() uint64\n\tMissCount() uint64\n\tLookupCount() uint64\n\tHitRate() float64\n}\n\n// statistics\ntype stats struct {\n\thitCount  uint64\n\tmissCount uint64\n}\n\n// increment hit count\nfunc (st *stats) IncrHitCount() uint64 {\n\treturn atomic.AddUint64(&st.hitCount, 1)\n}\n\n// increment miss count\nfunc (st *stats) IncrMissCount() uint64 {\n\treturn atomic.AddUint64(&st.missCount, 1)\n}\n\n// HitCount returns hit count\nfunc (st *stats) HitCount() uint64 {\n\treturn atomic.LoadUint64(&st.hitCount)\n}\n\n// MissCount returns miss count\nfunc (st *stats) MissCount() uint64 {\n\treturn atomic.LoadUint64(&st.missCount)\n}\n\n// LookupCount returns lookup count\nfunc (st *stats) LookupCount() uint64 {\n\treturn st.HitCount() + st.MissCount()\n}\n\n// HitRate returns rate for cache hitting\nfunc (st *stats) HitRate() float64 {\n\thc, mc := st.HitCount(), st.MissCount()\n\ttotal := hc + mc\n\tif total == 0 {\n\t\treturn 0.0\n\t}\n\treturn float64(hc) / float64(total)\n}\n"
        },
        {
          "name": "stats_test.go",
          "type": "blob",
          "size": 2.0703125,
          "content": "package gcache\n\nimport (\n\t\"testing\"\n)\n\nfunc TestStats(t *testing.T) {\n\tvar cases = []struct {\n\t\thit  int\n\t\tmiss int\n\t\trate float64\n\t}{\n\t\t{3, 1, 0.75},\n\t\t{0, 1, 0.0},\n\t\t{3, 0, 1.0},\n\t\t{0, 0, 0.0},\n\t}\n\n\tfor _, cs := range cases {\n\t\tst := &stats{}\n\t\tfor i := 0; i < cs.hit; i++ {\n\t\t\tst.IncrHitCount()\n\t\t}\n\t\tfor i := 0; i < cs.miss; i++ {\n\t\t\tst.IncrMissCount()\n\t\t}\n\t\tif rate := st.HitRate(); rate != cs.rate {\n\t\t\tt.Errorf(\"%v != %v\", rate, cs.rate)\n\t\t}\n\t}\n}\n\nfunc getter(key interface{}) (interface{}, error) {\n\treturn key, nil\n}\n\nfunc TestCacheStats(t *testing.T) {\n\tvar cases = []struct {\n\t\tbuilder func() Cache\n\t\trate    float64\n\t}{\n\t\t{\n\t\t\tbuilder: func() Cache {\n\t\t\t\tcc := New(32).Simple().Build()\n\t\t\t\tcc.Set(0, 0)\n\t\t\t\tcc.Get(0)\n\t\t\t\tcc.Get(1)\n\t\t\t\treturn cc\n\t\t\t},\n\t\t\trate: 0.5,\n\t\t},\n\t\t{\n\t\t\tbuilder: func() Cache {\n\t\t\t\tcc := New(32).LRU().Build()\n\t\t\t\tcc.Set(0, 0)\n\t\t\t\tcc.Get(0)\n\t\t\t\tcc.Get(1)\n\t\t\t\treturn cc\n\t\t\t},\n\t\t\trate: 0.5,\n\t\t},\n\t\t{\n\t\t\tbuilder: func() Cache {\n\t\t\t\tcc := New(32).LFU().Build()\n\t\t\t\tcc.Set(0, 0)\n\t\t\t\tcc.Get(0)\n\t\t\t\tcc.Get(1)\n\t\t\t\treturn cc\n\t\t\t},\n\t\t\trate: 0.5,\n\t\t},\n\t\t{\n\t\t\tbuilder: func() Cache {\n\t\t\t\tcc := New(32).ARC().Build()\n\t\t\t\tcc.Set(0, 0)\n\t\t\t\tcc.Get(0)\n\t\t\t\tcc.Get(1)\n\t\t\t\treturn cc\n\t\t\t},\n\t\t\trate: 0.5,\n\t\t},\n\t\t{\n\t\t\tbuilder: func() Cache {\n\t\t\t\tcc := New(32).\n\t\t\t\t\tSimple().\n\t\t\t\t\tLoaderFunc(getter).\n\t\t\t\t\tBuild()\n\t\t\t\tcc.Set(0, 0)\n\t\t\t\tcc.Get(0)\n\t\t\t\tcc.Get(1)\n\t\t\t\treturn cc\n\t\t\t},\n\t\t\trate: 0.5,\n\t\t},\n\t\t{\n\t\t\tbuilder: func() Cache {\n\t\t\t\tcc := New(32).\n\t\t\t\t\tLRU().\n\t\t\t\t\tLoaderFunc(getter).\n\t\t\t\t\tBuild()\n\t\t\t\tcc.Set(0, 0)\n\t\t\t\tcc.Get(0)\n\t\t\t\tcc.Get(1)\n\t\t\t\treturn cc\n\t\t\t},\n\t\t\trate: 0.5,\n\t\t},\n\t\t{\n\t\t\tbuilder: func() Cache {\n\t\t\t\tcc := New(32).\n\t\t\t\t\tLFU().\n\t\t\t\t\tLoaderFunc(getter).\n\t\t\t\t\tBuild()\n\t\t\t\tcc.Set(0, 0)\n\t\t\t\tcc.Get(0)\n\t\t\t\tcc.Get(1)\n\t\t\t\treturn cc\n\t\t\t},\n\t\t\trate: 0.5,\n\t\t},\n\t\t{\n\t\t\tbuilder: func() Cache {\n\t\t\t\tcc := New(32).\n\t\t\t\t\tARC().\n\t\t\t\t\tLoaderFunc(getter).\n\t\t\t\t\tBuild()\n\t\t\t\tcc.Set(0, 0)\n\t\t\t\tcc.Get(0)\n\t\t\t\tcc.Get(1)\n\t\t\t\treturn cc\n\t\t\t},\n\t\t\trate: 0.5,\n\t\t},\n\t}\n\n\tfor i, cs := range cases {\n\t\tcc := cs.builder()\n\t\tif rate := cc.HitRate(); rate != cs.rate {\n\t\t\tt.Errorf(\"case-%v: %v != %v\", i, rate, cs.rate)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 0.1455078125,
          "content": "package gcache\n\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc maxInt(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n"
        }
      ]
    }
  ]
}