{
  "metadata": {
    "timestamp": 1736566666515,
    "page": 219,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "wcharczuk/go-chart",
      "stars": 3998,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.314453125,
          "content": "# Binaries for programs and plugins\n*.exe\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n.glide/\n\n# Other\n.vscode\n.DS_Store\ncoverage.html\n.idea\n"
        },
        {
          "name": "COVERAGE",
          "type": "blob",
          "size": 0.0048828125,
          "content": "29.02"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0478515625,
          "content": "MIT License\n\nCopyright (c) 2016 William Charczuk.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.107421875,
          "content": "all: new-install test\n\nnew-install:\n\t@go get -v -u ./...\n\ngenerate:\n\t@go generate ./...\n\ntest:\n\t@go test ./..."
        },
        {
          "name": "PROFANITY_RULES.yml",
          "type": "blob",
          "size": 0.1376953125,
          "content": "go-sdk:\n  excludeFiles: [ \"*_test.go\" ]\n  importsContain: [ github.com/blend/go-sdk/* ]\n  description: \"please don't use go-sdk in this repo\""
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.484375,
          "content": "go-chart\n========\n\nThis project is archived!\n\nI originally released this as a way to publish stock charts in slack bots. It was kind of fun at the time! I never anticipated that it would become heavily used, and as often happens with open source, I have a ton of time commitments elsewhere, and can't reasonbly devote enough time to this project to match the usage.\n\nThere have been a number of forks over time, I'd encourage you all to seek those out, or new charting libraries. \n\nBest,\n\n- Will\n"
        },
        {
          "name": "_colors",
          "type": "tree",
          "content": null
        },
        {
          "name": "_images",
          "type": "tree",
          "content": null
        },
        {
          "name": "annotation_series.go",
          "type": "blob",
          "size": 2.4169921875,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// Interface Assertions.\nvar (\n\t_ Series = (*AnnotationSeries)(nil)\n)\n\n// AnnotationSeries is a series of labels on the chart.\ntype AnnotationSeries struct {\n\tName        string\n\tStyle       Style\n\tYAxis       YAxisType\n\tAnnotations []Value2\n}\n\n// GetName returns the name of the time series.\nfunc (as AnnotationSeries) GetName() string {\n\treturn as.Name\n}\n\n// GetStyle returns the line style.\nfunc (as AnnotationSeries) GetStyle() Style {\n\treturn as.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (as AnnotationSeries) GetYAxis() YAxisType {\n\treturn as.YAxis\n}\n\nfunc (as AnnotationSeries) annotationStyleDefaults(defaults Style) Style {\n\treturn Style{\n\t\tFontColor:   DefaultTextColor,\n\t\tFont:        defaults.Font,\n\t\tFillColor:   DefaultAnnotationFillColor,\n\t\tFontSize:    DefaultAnnotationFontSize,\n\t\tStrokeColor: defaults.StrokeColor,\n\t\tStrokeWidth: defaults.StrokeWidth,\n\t\tPadding:     DefaultAnnotationPadding,\n\t}\n}\n\n// Measure returns a bounds box of the series.\nfunc (as AnnotationSeries) Measure(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) Box {\n\tbox := Box{\n\t\tTop:    math.MaxInt32,\n\t\tLeft:   math.MaxInt32,\n\t\tRight:  0,\n\t\tBottom: 0,\n\t}\n\tif !as.Style.Hidden {\n\t\tseriesStyle := as.Style.InheritFrom(as.annotationStyleDefaults(defaults))\n\t\tfor _, a := range as.Annotations {\n\t\t\tstyle := a.Style.InheritFrom(seriesStyle)\n\t\t\tlx := canvasBox.Left + xrange.Translate(a.XValue)\n\t\t\tly := canvasBox.Bottom - yrange.Translate(a.YValue)\n\t\t\tab := Draw.MeasureAnnotation(r, canvasBox, style, lx, ly, a.Label)\n\t\t\tbox.Top = MinInt(box.Top, ab.Top)\n\t\t\tbox.Left = MinInt(box.Left, ab.Left)\n\t\t\tbox.Right = MaxInt(box.Right, ab.Right)\n\t\t\tbox.Bottom = MaxInt(box.Bottom, ab.Bottom)\n\t\t}\n\t}\n\treturn box\n}\n\n// Render draws the series.\nfunc (as AnnotationSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tif !as.Style.Hidden {\n\t\tseriesStyle := as.Style.InheritFrom(as.annotationStyleDefaults(defaults))\n\t\tfor _, a := range as.Annotations {\n\t\t\tstyle := a.Style.InheritFrom(seriesStyle)\n\t\t\tlx := canvasBox.Left + xrange.Translate(a.XValue)\n\t\t\tly := canvasBox.Bottom - yrange.Translate(a.YValue)\n\t\t\tDraw.Annotation(r, canvasBox, style, lx, ly, a.Label)\n\t\t}\n\t}\n}\n\n// Validate validates the series.\nfunc (as AnnotationSeries) Validate() error {\n\tif len(as.Annotations) == 0 {\n\t\treturn fmt.Errorf(\"annotation series requires annotations to be set and not empty\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "annotation_series_test.go",
          "type": "blob",
          "size": 2.2958984375,
          "content": "package chart\n\nimport (\n\t\"image/color\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/drawing\"\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestAnnotationSeriesMeasure(t *testing.T) {\n\t// replaced new assertions helper\n\n\tas := AnnotationSeries{\n\t\tAnnotations: []Value2{\n\t\t\t{XValue: 1.0, YValue: 1.0, Label: \"1.0\"},\n\t\t\t{XValue: 2.0, YValue: 2.0, Label: \"2.0\"},\n\t\t\t{XValue: 3.0, YValue: 3.0, Label: \"3.0\"},\n\t\t\t{XValue: 4.0, YValue: 4.0, Label: \"4.0\"},\n\t\t},\n\t}\n\n\tr, err := PNG(110, 110)\n\ttestutil.AssertNil(t, err)\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\txrange := &ContinuousRange{\n\t\tMin:    1.0,\n\t\tMax:    4.0,\n\t\tDomain: 100,\n\t}\n\tyrange := &ContinuousRange{\n\t\tMin:    1.0,\n\t\tMax:    4.0,\n\t\tDomain: 100,\n\t}\n\n\tcb := Box{\n\t\tTop:    5,\n\t\tLeft:   5,\n\t\tRight:  105,\n\t\tBottom: 105,\n\t}\n\tsd := Style{\n\t\tFontSize: 10.0,\n\t\tFont:     f,\n\t}\n\n\tbox := as.Measure(r, cb, xrange, yrange, sd)\n\ttestutil.AssertFalse(t, box.IsZero())\n\ttestutil.AssertEqual(t, -5.0, box.Top)\n\ttestutil.AssertEqual(t, 5.0, box.Left)\n\ttestutil.AssertEqual(t, 146.0, box.Right) //the top,left annotation sticks up 5px and out ~44px.\n\ttestutil.AssertEqual(t, 115.0, box.Bottom)\n}\n\nfunc TestAnnotationSeriesRender(t *testing.T) {\n\t// replaced new assertions helper\n\n\tas := AnnotationSeries{\n\t\tStyle: Style{\n\t\t\tFillColor:   drawing.ColorWhite,\n\t\t\tStrokeColor: drawing.ColorBlack,\n\t\t},\n\t\tAnnotations: []Value2{\n\t\t\t{XValue: 1.0, YValue: 1.0, Label: \"1.0\"},\n\t\t\t{XValue: 2.0, YValue: 2.0, Label: \"2.0\"},\n\t\t\t{XValue: 3.0, YValue: 3.0, Label: \"3.0\"},\n\t\t\t{XValue: 4.0, YValue: 4.0, Label: \"4.0\"},\n\t\t},\n\t}\n\n\tr, err := PNG(110, 110)\n\ttestutil.AssertNil(t, err)\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\txrange := &ContinuousRange{\n\t\tMin:    1.0,\n\t\tMax:    4.0,\n\t\tDomain: 100,\n\t}\n\tyrange := &ContinuousRange{\n\t\tMin:    1.0,\n\t\tMax:    4.0,\n\t\tDomain: 100,\n\t}\n\n\tcb := Box{\n\t\tTop:    5,\n\t\tLeft:   5,\n\t\tRight:  105,\n\t\tBottom: 105,\n\t}\n\tsd := Style{\n\t\tFontSize: 10.0,\n\t\tFont:     f,\n\t}\n\n\tas.Render(r, cb, xrange, yrange, sd)\n\n\trr, isRaster := r.(*rasterRenderer)\n\ttestutil.AssertTrue(t, isRaster)\n\ttestutil.AssertNotNil(t, rr)\n\n\tc := rr.i.At(38, 70)\n\tconverted, isRGBA := color.RGBAModel.Convert(c).(color.RGBA)\n\ttestutil.AssertTrue(t, isRGBA)\n\ttestutil.AssertEqual(t, 0, converted.R)\n\ttestutil.AssertEqual(t, 0, converted.G)\n\ttestutil.AssertEqual(t, 0, converted.B)\n}\n"
        },
        {
          "name": "array.go",
          "type": "blob",
          "size": 0.548828125,
          "content": "package chart\n\nvar (\n\t_ Sequence = (*Array)(nil)\n)\n\n// NewArray returns a new array from a given set of values.\n// Array implements Sequence, which allows it to be used with the sequence helpers.\nfunc NewArray(values ...float64) Array {\n\treturn Array(values)\n}\n\n// Array is a wrapper for an array of floats that implements `ValuesProvider`.\ntype Array []float64\n\n// Len returns the value provider length.\nfunc (a Array) Len() int {\n\treturn len(a)\n}\n\n// GetValue returns the value at a given index.\nfunc (a Array) GetValue(index int) float64 {\n\treturn a[index]\n}\n"
        },
        {
          "name": "axis.go",
          "type": "blob",
          "size": 1.314453125,
          "content": "package chart\n\n// TickPosition is an enumeration of possible tick drawing positions.\ntype TickPosition int\n\nconst (\n\t// TickPositionUnset means to use the default tick position.\n\tTickPositionUnset TickPosition = 0\n\t// TickPositionBetweenTicks draws the labels for a tick between the previous and current tick.\n\tTickPositionBetweenTicks TickPosition = 1\n\t// TickPositionUnderTick draws the tick below the tick.\n\tTickPositionUnderTick TickPosition = 2\n)\n\n// YAxisType is a type of y-axis; it can either be primary or secondary.\ntype YAxisType int\n\nconst (\n\t// YAxisPrimary is the primary axis.\n\tYAxisPrimary YAxisType = 0\n\t// YAxisSecondary is the secondary axis.\n\tYAxisSecondary YAxisType = 1\n)\n\n// Axis is a chart feature detailing what values happen where.\ntype Axis interface {\n\tGetName() string\n\tSetName(name string)\n\n\tGetStyle() Style\n\tSetStyle(style Style)\n\n\tGetTicks() []Tick\n\tGenerateTicks(r Renderer, ra Range, vf ValueFormatter) []Tick\n\n\t// GenerateGridLines returns the gridlines for the axis.\n\tGetGridLines(ticks []Tick) []GridLine\n\n\t// Measure should return an absolute box for the axis.\n\t// This is used when auto-fitting the canvas to the background.\n\tMeasure(r Renderer, canvasBox Box, ra Range, style Style, ticks []Tick) Box\n\n\t// Render renders the axis.\n\tRender(r Renderer, canvasBox Box, ra Range, style Style, ticks []Tick)\n}\n"
        },
        {
          "name": "bar_chart.go",
          "type": "blob",
          "size": 11.6005859375,
          "content": "package chart\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\n\t\"github.com/golang/freetype/truetype\"\n)\n\n// BarChart is a chart that draws bars on a range.\ntype BarChart struct {\n\tTitle      string\n\tTitleStyle Style\n\n\tColorPalette ColorPalette\n\n\tWidth  int\n\tHeight int\n\tDPI    float64\n\n\tBarWidth int\n\n\tBackground Style\n\tCanvas     Style\n\n\tXAxis Style\n\tYAxis YAxis\n\n\tBarSpacing int\n\n\tUseBaseValue bool\n\tBaseValue    float64\n\n\tFont        *truetype.Font\n\tdefaultFont *truetype.Font\n\n\tBars     []Value\n\tElements []Renderable\n}\n\n// GetDPI returns the dpi for the chart.\nfunc (bc BarChart) GetDPI() float64 {\n\tif bc.DPI == 0 {\n\t\treturn DefaultDPI\n\t}\n\treturn bc.DPI\n}\n\n// GetFont returns the text font.\nfunc (bc BarChart) GetFont() *truetype.Font {\n\tif bc.Font == nil {\n\t\treturn bc.defaultFont\n\t}\n\treturn bc.Font\n}\n\n// GetWidth returns the chart width or the default value.\nfunc (bc BarChart) GetWidth() int {\n\tif bc.Width == 0 {\n\t\treturn DefaultChartWidth\n\t}\n\treturn bc.Width\n}\n\n// GetHeight returns the chart height or the default value.\nfunc (bc BarChart) GetHeight() int {\n\tif bc.Height == 0 {\n\t\treturn DefaultChartHeight\n\t}\n\treturn bc.Height\n}\n\n// GetBarSpacing returns the spacing between bars.\nfunc (bc BarChart) GetBarSpacing() int {\n\tif bc.BarSpacing == 0 {\n\t\treturn DefaultBarSpacing\n\t}\n\treturn bc.BarSpacing\n}\n\n// GetBarWidth returns the default bar width.\nfunc (bc BarChart) GetBarWidth() int {\n\tif bc.BarWidth == 0 {\n\t\treturn DefaultBarWidth\n\t}\n\treturn bc.BarWidth\n}\n\n// Render renders the chart with the given renderer to the given io.Writer.\nfunc (bc BarChart) Render(rp RendererProvider, w io.Writer) error {\n\tif len(bc.Bars) == 0 {\n\t\treturn errors.New(\"please provide at least one bar\")\n\t}\n\n\tr, err := rp(bc.GetWidth(), bc.GetHeight())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif bc.Font == nil {\n\t\tdefaultFont, err := GetDefaultFont()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbc.defaultFont = defaultFont\n\t}\n\tr.SetDPI(bc.GetDPI())\n\n\tbc.drawBackground(r)\n\n\tvar canvasBox Box\n\tvar yt []Tick\n\tvar yr Range\n\tvar yf ValueFormatter\n\n\tcanvasBox = bc.getDefaultCanvasBox()\n\tyr = bc.getRanges()\n\tif yr.GetMax()-yr.GetMin() == 0 {\n\t\treturn fmt.Errorf(\"invalid data range; cannot be zero\")\n\t}\n\tyr = bc.setRangeDomains(canvasBox, yr)\n\tyf = bc.getValueFormatters()\n\n\tif bc.hasAxes() {\n\t\tyt = bc.getAxesTicks(r, yr, yf)\n\t\tcanvasBox = bc.getAdjustedCanvasBox(r, canvasBox, yr, yt)\n\t\tyr = bc.setRangeDomains(canvasBox, yr)\n\t}\n\tbc.drawCanvas(r, canvasBox)\n\tbc.drawBars(r, canvasBox, yr)\n\tbc.drawXAxis(r, canvasBox)\n\tbc.drawYAxis(r, canvasBox, yr, yt)\n\n\tbc.drawTitle(r)\n\tfor _, a := range bc.Elements {\n\t\ta(r, canvasBox, bc.styleDefaultsElements())\n\t}\n\n\treturn r.Save(w)\n}\n\nfunc (bc BarChart) drawCanvas(r Renderer, canvasBox Box) {\n\tDraw.Box(r, canvasBox, bc.getCanvasStyle())\n}\n\nfunc (bc BarChart) getRanges() Range {\n\tvar yrange Range\n\tif bc.YAxis.Range != nil && !bc.YAxis.Range.IsZero() {\n\t\tyrange = bc.YAxis.Range\n\t} else {\n\t\tyrange = &ContinuousRange{}\n\t}\n\n\tif !yrange.IsZero() {\n\t\treturn yrange\n\t}\n\n\tif len(bc.YAxis.Ticks) > 0 {\n\t\ttickMin, tickMax := math.MaxFloat64, -math.MaxFloat64\n\t\tfor _, t := range bc.YAxis.Ticks {\n\t\t\ttickMin = math.Min(tickMin, t.Value)\n\t\t\ttickMax = math.Max(tickMax, t.Value)\n\t\t}\n\t\tyrange.SetMin(tickMin)\n\t\tyrange.SetMax(tickMax)\n\t\treturn yrange\n\t}\n\n\tmin, max := math.MaxFloat64, -math.MaxFloat64\n\tfor _, b := range bc.Bars {\n\t\tmin = math.Min(b.Value, min)\n\t\tmax = math.Max(b.Value, max)\n\t}\n\n\tyrange.SetMin(min)\n\tyrange.SetMax(max)\n\n\treturn yrange\n}\n\nfunc (bc BarChart) drawBackground(r Renderer) {\n\tDraw.Box(r, Box{\n\t\tRight:  bc.GetWidth(),\n\t\tBottom: bc.GetHeight(),\n\t}, bc.getBackgroundStyle())\n}\n\nfunc (bc BarChart) drawBars(r Renderer, canvasBox Box, yr Range) {\n\txoffset := canvasBox.Left\n\n\twidth, spacing, _ := bc.calculateScaledTotalWidth(canvasBox)\n\tbs2 := spacing >> 1\n\n\tvar barBox Box\n\tvar bxl, bxr, by int\n\tfor index, bar := range bc.Bars {\n\t\tbxl = xoffset + bs2\n\t\tbxr = bxl + width\n\n\t\tby = canvasBox.Bottom - yr.Translate(bar.Value)\n\n\t\tif bc.UseBaseValue {\n\t\t\tbarBox = Box{\n\t\t\t\tTop:    by,\n\t\t\t\tLeft:   bxl,\n\t\t\t\tRight:  bxr,\n\t\t\t\tBottom: canvasBox.Bottom - yr.Translate(bc.BaseValue),\n\t\t\t}\n\t\t} else {\n\t\t\tbarBox = Box{\n\t\t\t\tTop:    by,\n\t\t\t\tLeft:   bxl,\n\t\t\t\tRight:  bxr,\n\t\t\t\tBottom: canvasBox.Bottom,\n\t\t\t}\n\t\t}\n\n\t\tDraw.Box(r, barBox, bar.Style.InheritFrom(bc.styleDefaultsBar(index)))\n\n\t\txoffset += width + spacing\n\t}\n}\n\nfunc (bc BarChart) drawXAxis(r Renderer, canvasBox Box) {\n\tif !bc.XAxis.Hidden {\n\t\taxisStyle := bc.XAxis.InheritFrom(bc.styleDefaultsAxes())\n\t\taxisStyle.WriteToRenderer(r)\n\n\t\twidth, spacing, _ := bc.calculateScaledTotalWidth(canvasBox)\n\n\t\tr.MoveTo(canvasBox.Left, canvasBox.Bottom)\n\t\tr.LineTo(canvasBox.Right, canvasBox.Bottom)\n\t\tr.Stroke()\n\n\t\tr.MoveTo(canvasBox.Left, canvasBox.Bottom)\n\t\tr.LineTo(canvasBox.Left, canvasBox.Bottom+DefaultVerticalTickHeight)\n\t\tr.Stroke()\n\n\t\tcursor := canvasBox.Left\n\t\tfor index, bar := range bc.Bars {\n\t\t\tbarLabelBox := Box{\n\t\t\t\tTop:    canvasBox.Bottom + DefaultXAxisMargin,\n\t\t\t\tLeft:   cursor,\n\t\t\t\tRight:  cursor + width + spacing,\n\t\t\t\tBottom: bc.GetHeight(),\n\t\t\t}\n\n\t\t\tif len(bar.Label) > 0 {\n\t\t\t\tDraw.TextWithin(r, bar.Label, barLabelBox, axisStyle)\n\t\t\t}\n\n\t\t\taxisStyle.WriteToRenderer(r)\n\t\t\tif index < len(bc.Bars)-1 {\n\t\t\t\tr.MoveTo(barLabelBox.Right, canvasBox.Bottom)\n\t\t\t\tr.LineTo(barLabelBox.Right, canvasBox.Bottom+DefaultVerticalTickHeight)\n\t\t\t\tr.Stroke()\n\t\t\t}\n\t\t\tcursor += width + spacing\n\t\t}\n\t}\n}\n\nfunc (bc BarChart) drawYAxis(r Renderer, canvasBox Box, yr Range, ticks []Tick) {\n\tif !bc.YAxis.Style.Hidden {\n\t\tbc.YAxis.Render(r, canvasBox, yr, bc.styleDefaultsAxes(), ticks)\n\t}\n}\n\nfunc (bc BarChart) drawTitle(r Renderer) {\n\tif len(bc.Title) > 0 && !bc.TitleStyle.Hidden {\n\t\tr.SetFont(bc.TitleStyle.GetFont(bc.GetFont()))\n\t\tr.SetFontColor(bc.TitleStyle.GetFontColor(bc.GetColorPalette().TextColor()))\n\t\ttitleFontSize := bc.TitleStyle.GetFontSize(bc.getTitleFontSize())\n\t\tr.SetFontSize(titleFontSize)\n\n\t\ttextBox := r.MeasureText(bc.Title)\n\n\t\ttextWidth := textBox.Width()\n\t\ttextHeight := textBox.Height()\n\n\t\ttitleX := (bc.GetWidth() >> 1) - (textWidth >> 1)\n\t\ttitleY := bc.TitleStyle.Padding.GetTop(DefaultTitleTop) + textHeight\n\n\t\tr.Text(bc.Title, titleX, titleY)\n\t}\n}\n\nfunc (bc BarChart) getCanvasStyle() Style {\n\treturn bc.Canvas.InheritFrom(bc.styleDefaultsCanvas())\n}\n\nfunc (bc BarChart) styleDefaultsCanvas() Style {\n\treturn Style{\n\t\tFillColor:   bc.GetColorPalette().CanvasColor(),\n\t\tStrokeColor: bc.GetColorPalette().CanvasStrokeColor(),\n\t\tStrokeWidth: DefaultCanvasStrokeWidth,\n\t}\n}\n\nfunc (bc BarChart) hasAxes() bool {\n\treturn !bc.YAxis.Style.Hidden\n}\n\nfunc (bc BarChart) setRangeDomains(canvasBox Box, yr Range) Range {\n\tyr.SetDomain(canvasBox.Height())\n\treturn yr\n}\n\nfunc (bc BarChart) getDefaultCanvasBox() Box {\n\treturn bc.box()\n}\n\nfunc (bc BarChart) getValueFormatters() ValueFormatter {\n\tif bc.YAxis.ValueFormatter != nil {\n\t\treturn bc.YAxis.ValueFormatter\n\t}\n\treturn FloatValueFormatter\n}\n\nfunc (bc BarChart) getAxesTicks(r Renderer, yr Range, yf ValueFormatter) (yticks []Tick) {\n\tif !bc.YAxis.Style.Hidden {\n\t\tyticks = bc.YAxis.GetTicks(r, yr, bc.styleDefaultsAxes(), yf)\n\t}\n\treturn\n}\n\nfunc (bc BarChart) calculateEffectiveBarSpacing(canvasBox Box) int {\n\ttotalWithBaseSpacing := bc.calculateTotalBarWidth(bc.GetBarWidth(), bc.GetBarSpacing())\n\tif totalWithBaseSpacing > canvasBox.Width() {\n\t\tlessBarWidths := canvasBox.Width() - (len(bc.Bars) * bc.GetBarWidth())\n\t\tif lessBarWidths > 0 {\n\t\t\treturn int(math.Ceil(float64(lessBarWidths) / float64(len(bc.Bars))))\n\t\t}\n\t\treturn 0\n\t}\n\treturn bc.GetBarSpacing()\n}\n\nfunc (bc BarChart) calculateEffectiveBarWidth(canvasBox Box, spacing int) int {\n\ttotalWithBaseWidth := bc.calculateTotalBarWidth(bc.GetBarWidth(), spacing)\n\tif totalWithBaseWidth > canvasBox.Width() {\n\t\ttotalLessBarSpacings := canvasBox.Width() - (len(bc.Bars) * spacing)\n\t\tif totalLessBarSpacings > 0 {\n\t\t\treturn int(math.Ceil(float64(totalLessBarSpacings) / float64(len(bc.Bars))))\n\t\t}\n\t\treturn 0\n\t}\n\treturn bc.GetBarWidth()\n}\n\nfunc (bc BarChart) calculateTotalBarWidth(barWidth, spacing int) int {\n\treturn len(bc.Bars) * (barWidth + spacing)\n}\n\nfunc (bc BarChart) calculateScaledTotalWidth(canvasBox Box) (width, spacing, total int) {\n\tspacing = bc.calculateEffectiveBarSpacing(canvasBox)\n\twidth = bc.calculateEffectiveBarWidth(canvasBox, spacing)\n\ttotal = bc.calculateTotalBarWidth(width, spacing)\n\treturn\n}\n\nfunc (bc BarChart) getAdjustedCanvasBox(r Renderer, canvasBox Box, yrange Range, yticks []Tick) Box {\n\taxesOuterBox := canvasBox.Clone()\n\n\t_, _, totalWidth := bc.calculateScaledTotalWidth(canvasBox)\n\n\tif !bc.XAxis.Hidden {\n\t\txaxisHeight := DefaultVerticalTickHeight\n\n\t\taxisStyle := bc.XAxis.InheritFrom(bc.styleDefaultsAxes())\n\t\taxisStyle.WriteToRenderer(r)\n\n\t\tcursor := canvasBox.Left\n\t\tfor _, bar := range bc.Bars {\n\t\t\tif len(bar.Label) > 0 {\n\t\t\t\tbarLabelBox := Box{\n\t\t\t\t\tTop:    canvasBox.Bottom + DefaultXAxisMargin,\n\t\t\t\t\tLeft:   cursor,\n\t\t\t\t\tRight:  cursor + bc.GetBarWidth() + bc.GetBarSpacing(),\n\t\t\t\t\tBottom: bc.GetHeight(),\n\t\t\t\t}\n\t\t\t\tlines := Text.WrapFit(r, bar.Label, barLabelBox.Width(), axisStyle)\n\t\t\t\tlinesBox := Text.MeasureLines(r, lines, axisStyle)\n\n\t\t\t\txaxisHeight = MinInt(linesBox.Height()+(2*DefaultXAxisMargin), xaxisHeight)\n\t\t\t}\n\t\t}\n\n\t\txbox := Box{\n\t\t\tTop:    canvasBox.Top,\n\t\t\tLeft:   canvasBox.Left,\n\t\t\tRight:  canvasBox.Left + totalWidth,\n\t\t\tBottom: bc.GetHeight() - xaxisHeight,\n\t\t}\n\n\t\taxesOuterBox = axesOuterBox.Grow(xbox)\n\t}\n\n\tif !bc.YAxis.Style.Hidden {\n\t\taxesBounds := bc.YAxis.Measure(r, canvasBox, yrange, bc.styleDefaultsAxes(), yticks)\n\t\taxesOuterBox = axesOuterBox.Grow(axesBounds)\n\t}\n\n\treturn canvasBox.OuterConstrain(bc.box(), axesOuterBox)\n}\n\n// box returns the chart bounds as a box.\nfunc (bc BarChart) box() Box {\n\tdpr := bc.Background.Padding.GetRight(10)\n\tdpb := bc.Background.Padding.GetBottom(50)\n\n\treturn Box{\n\t\tTop:    bc.Background.Padding.GetTop(20),\n\t\tLeft:   bc.Background.Padding.GetLeft(20),\n\t\tRight:  bc.GetWidth() - dpr,\n\t\tBottom: bc.GetHeight() - dpb,\n\t}\n}\n\nfunc (bc BarChart) getBackgroundStyle() Style {\n\treturn bc.Background.InheritFrom(bc.styleDefaultsBackground())\n}\n\nfunc (bc BarChart) styleDefaultsBackground() Style {\n\treturn Style{\n\t\tFillColor:   bc.GetColorPalette().BackgroundColor(),\n\t\tStrokeColor: bc.GetColorPalette().BackgroundStrokeColor(),\n\t\tStrokeWidth: DefaultStrokeWidth,\n\t}\n}\n\nfunc (bc BarChart) styleDefaultsBar(index int) Style {\n\treturn Style{\n\t\tStrokeColor: bc.GetColorPalette().GetSeriesColor(index),\n\t\tStrokeWidth: 3.0,\n\t\tFillColor:   bc.GetColorPalette().GetSeriesColor(index),\n\t}\n}\n\nfunc (bc BarChart) styleDefaultsTitle() Style {\n\treturn bc.TitleStyle.InheritFrom(Style{\n\t\tFontColor:           bc.GetColorPalette().TextColor(),\n\t\tFont:                bc.GetFont(),\n\t\tFontSize:            bc.getTitleFontSize(),\n\t\tTextHorizontalAlign: TextHorizontalAlignCenter,\n\t\tTextVerticalAlign:   TextVerticalAlignTop,\n\t\tTextWrap:            TextWrapWord,\n\t})\n}\n\nfunc (bc BarChart) getTitleFontSize() float64 {\n\teffectiveDimension := MinInt(bc.GetWidth(), bc.GetHeight())\n\tif effectiveDimension >= 2048 {\n\t\treturn 48\n\t} else if effectiveDimension >= 1024 {\n\t\treturn 24\n\t} else if effectiveDimension >= 512 {\n\t\treturn 18\n\t} else if effectiveDimension >= 256 {\n\t\treturn 12\n\t}\n\treturn 10\n}\n\nfunc (bc BarChart) styleDefaultsAxes() Style {\n\treturn Style{\n\t\tStrokeColor:         bc.GetColorPalette().AxisStrokeColor(),\n\t\tFont:                bc.GetFont(),\n\t\tFontSize:            DefaultAxisFontSize,\n\t\tFontColor:           bc.GetColorPalette().TextColor(),\n\t\tTextHorizontalAlign: TextHorizontalAlignCenter,\n\t\tTextVerticalAlign:   TextVerticalAlignTop,\n\t\tTextWrap:            TextWrapWord,\n\t}\n}\n\nfunc (bc BarChart) styleDefaultsElements() Style {\n\treturn Style{\n\t\tFont: bc.GetFont(),\n\t}\n}\n\n// GetColorPalette returns the color palette for the chart.\nfunc (bc BarChart) GetColorPalette() ColorPalette {\n\tif bc.ColorPalette != nil {\n\t\treturn bc.ColorPalette\n\t}\n\treturn AlternateColorPalette\n}\n"
        },
        {
          "name": "bar_chart_test.go",
          "type": "blob",
          "size": 7.0029296875,
          "content": "package chart\n\nimport (\n\t\"bytes\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestBarChartRender(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{\n\t\tWidth: 1024,\n\t\tTitle: \"Test Title\",\n\t\tBars: []Value{\n\t\t\t{Value: 1.0, Label: \"One\"},\n\t\t\t{Value: 2.0, Label: \"Two\"},\n\t\t\t{Value: 3.0, Label: \"Three\"},\n\t\t\t{Value: 4.0, Label: \"Four\"},\n\t\t\t{Value: 5.0, Label: \"Five\"},\n\t\t},\n\t}\n\n\tbuf := bytes.NewBuffer([]byte{})\n\terr := bc.Render(PNG, buf)\n\ttestutil.AssertNil(t, err)\n\ttestutil.AssertNotZero(t, buf.Len())\n}\n\nfunc TestBarChartRenderZero(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{\n\t\tWidth: 1024,\n\t\tTitle: \"Test Title\",\n\t\tBars: []Value{\n\t\t\t{Value: 0.0, Label: \"One\"},\n\t\t\t{Value: 0.0, Label: \"Two\"},\n\t\t},\n\t}\n\n\tbuf := bytes.NewBuffer([]byte{})\n\terr := bc.Render(PNG, buf)\n\ttestutil.AssertNotNil(t, err)\n}\n\nfunc TestBarChartProps(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{}\n\n\ttestutil.AssertEqual(t, DefaultDPI, bc.GetDPI())\n\tbc.DPI = 100\n\ttestutil.AssertEqual(t, 100, bc.GetDPI())\n\n\ttestutil.AssertNil(t, bc.GetFont())\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\tbc.Font = f\n\ttestutil.AssertNotNil(t, bc.GetFont())\n\n\ttestutil.AssertEqual(t, DefaultChartWidth, bc.GetWidth())\n\tbc.Width = DefaultChartWidth - 1\n\ttestutil.AssertEqual(t, DefaultChartWidth-1, bc.GetWidth())\n\n\ttestutil.AssertEqual(t, DefaultChartHeight, bc.GetHeight())\n\tbc.Height = DefaultChartHeight - 1\n\ttestutil.AssertEqual(t, DefaultChartHeight-1, bc.GetHeight())\n\n\ttestutil.AssertEqual(t, DefaultBarSpacing, bc.GetBarSpacing())\n\tbc.BarSpacing = 150\n\ttestutil.AssertEqual(t, 150, bc.GetBarSpacing())\n\n\ttestutil.AssertEqual(t, DefaultBarWidth, bc.GetBarWidth())\n\tbc.BarWidth = 75\n\ttestutil.AssertEqual(t, 75, bc.GetBarWidth())\n}\n\nfunc TestBarChartRenderNoBars(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{}\n\terr := bc.Render(PNG, bytes.NewBuffer([]byte{}))\n\ttestutil.AssertNotNil(t, err)\n}\n\nfunc TestBarChartGetRanges(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{}\n\n\tyr := bc.getRanges()\n\ttestutil.AssertNotNil(t, yr)\n\ttestutil.AssertFalse(t, yr.IsZero())\n\n\ttestutil.AssertEqual(t, -math.MaxFloat64, yr.GetMax())\n\ttestutil.AssertEqual(t, math.MaxFloat64, yr.GetMin())\n}\n\nfunc TestBarChartGetRangesBarsMinMax(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{\n\t\tBars: []Value{\n\t\t\t{Value: 1.0},\n\t\t\t{Value: 10.0},\n\t\t},\n\t}\n\n\tyr := bc.getRanges()\n\ttestutil.AssertNotNil(t, yr)\n\ttestutil.AssertFalse(t, yr.IsZero())\n\n\ttestutil.AssertEqual(t, 10, yr.GetMax())\n\ttestutil.AssertEqual(t, 1, yr.GetMin())\n}\n\nfunc TestBarChartGetRangesMinMax(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{\n\t\tYAxis: YAxis{\n\t\t\tRange: &ContinuousRange{\n\t\t\t\tMin: 5.0,\n\t\t\t\tMax: 15.0,\n\t\t\t},\n\t\t\tTicks: []Tick{\n\t\t\t\t{Value: 7.0, Label: \"Foo\"},\n\t\t\t\t{Value: 11.0, Label: \"Foo2\"},\n\t\t\t},\n\t\t},\n\t\tBars: []Value{\n\t\t\t{Value: 1.0},\n\t\t\t{Value: 10.0},\n\t\t},\n\t}\n\n\tyr := bc.getRanges()\n\ttestutil.AssertNotNil(t, yr)\n\ttestutil.AssertFalse(t, yr.IsZero())\n\n\ttestutil.AssertEqual(t, 15, yr.GetMax())\n\ttestutil.AssertEqual(t, 5, yr.GetMin())\n}\n\nfunc TestBarChartGetRangesTicksMinMax(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{\n\t\tYAxis: YAxis{\n\t\t\tTicks: []Tick{\n\t\t\t\t{Value: 7.0, Label: \"Foo\"},\n\t\t\t\t{Value: 11.0, Label: \"Foo2\"},\n\t\t\t},\n\t\t},\n\t\tBars: []Value{\n\t\t\t{Value: 1.0},\n\t\t\t{Value: 10.0},\n\t\t},\n\t}\n\n\tyr := bc.getRanges()\n\ttestutil.AssertNotNil(t, yr)\n\ttestutil.AssertFalse(t, yr.IsZero())\n\n\ttestutil.AssertEqual(t, 11, yr.GetMax())\n\ttestutil.AssertEqual(t, 7, yr.GetMin())\n}\n\nfunc TestBarChartHasAxes(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{}\n\ttestutil.AssertTrue(t, bc.hasAxes())\n\tbc.YAxis = YAxis{\n\t\tStyle: Hidden(),\n\t}\n\ttestutil.AssertFalse(t, bc.hasAxes())\n}\n\nfunc TestBarChartGetDefaultCanvasBox(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{}\n\tb := bc.getDefaultCanvasBox()\n\ttestutil.AssertFalse(t, b.IsZero())\n}\n\nfunc TestBarChartSetRangeDomains(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{}\n\tcb := bc.box()\n\tyr := bc.getRanges()\n\tyr2 := bc.setRangeDomains(cb, yr)\n\ttestutil.AssertNotZero(t, yr2.GetDomain())\n}\n\nfunc TestBarChartGetValueFormatters(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{}\n\tvf := bc.getValueFormatters()\n\ttestutil.AssertNotNil(t, vf)\n\ttestutil.AssertEqual(t, \"1234.00\", vf(1234.0))\n\n\tbc.YAxis.ValueFormatter = func(_ interface{}) string { return \"test\" }\n\ttestutil.AssertEqual(t, \"test\", bc.getValueFormatters()(1234))\n}\n\nfunc TestBarChartGetAxesTicks(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{\n\t\tBars: []Value{\n\t\t\t{Value: 1.0},\n\t\t\t{Value: 2.0},\n\t\t\t{Value: 3.0},\n\t\t},\n\t}\n\n\tr, err := PNG(128, 128)\n\ttestutil.AssertNil(t, err)\n\tyr := bc.getRanges()\n\tyf := bc.getValueFormatters()\n\n\tbc.YAxis.Style.Hidden = true\n\tticks := bc.getAxesTicks(r, yr, yf)\n\ttestutil.AssertEmpty(t, ticks)\n\n\tbc.YAxis.Style.Hidden = false\n\tticks = bc.getAxesTicks(r, yr, yf)\n\ttestutil.AssertLen(t, ticks, 2)\n}\n\nfunc TestBarChartCalculateEffectiveBarSpacing(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{\n\t\tWidth:    1024,\n\t\tBarWidth: 10,\n\t\tBars: []Value{\n\t\t\t{Value: 1.0, Label: \"One\"},\n\t\t\t{Value: 2.0, Label: \"Two\"},\n\t\t\t{Value: 3.0, Label: \"Three\"},\n\t\t\t{Value: 4.0, Label: \"Four\"},\n\t\t\t{Value: 5.0, Label: \"Five\"},\n\t\t},\n\t}\n\n\tspacing := bc.calculateEffectiveBarSpacing(bc.box())\n\ttestutil.AssertNotZero(t, spacing)\n\n\tbc.BarWidth = 250\n\tspacing = bc.calculateEffectiveBarSpacing(bc.box())\n\ttestutil.AssertZero(t, spacing)\n}\n\nfunc TestBarChartCalculateEffectiveBarWidth(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BarChart{\n\t\tWidth:    1024,\n\t\tBarWidth: 10,\n\t\tBars: []Value{\n\t\t\t{Value: 1.0, Label: \"One\"},\n\t\t\t{Value: 2.0, Label: \"Two\"},\n\t\t\t{Value: 3.0, Label: \"Three\"},\n\t\t\t{Value: 4.0, Label: \"Four\"},\n\t\t\t{Value: 5.0, Label: \"Five\"},\n\t\t},\n\t}\n\n\tcb := bc.box()\n\n\tspacing := bc.calculateEffectiveBarSpacing(bc.box())\n\ttestutil.AssertNotZero(t, spacing)\n\n\tbarWidth := bc.calculateEffectiveBarWidth(bc.box(), spacing)\n\ttestutil.AssertEqual(t, 10, barWidth)\n\n\tbc.BarWidth = 250\n\tspacing = bc.calculateEffectiveBarSpacing(bc.box())\n\ttestutil.AssertZero(t, spacing)\n\tbarWidth = bc.calculateEffectiveBarWidth(bc.box(), spacing)\n\ttestutil.AssertEqual(t, 199, barWidth)\n\n\ttestutil.AssertEqual(t, cb.Width()+1, bc.calculateTotalBarWidth(barWidth, spacing))\n\n\tbw, bs, total := bc.calculateScaledTotalWidth(cb)\n\ttestutil.AssertEqual(t, spacing, bs)\n\ttestutil.AssertEqual(t, barWidth, bw)\n\ttestutil.AssertEqual(t, cb.Width()+1, total)\n}\n\nfunc TestBarChatGetTitleFontSize(t *testing.T) {\n\t// replaced new assertions helper\n\tsize := BarChart{Width: 2049, Height: 2049}.getTitleFontSize()\n\ttestutil.AssertEqual(t, 48, size)\n\tsize = BarChart{Width: 1025, Height: 1025}.getTitleFontSize()\n\ttestutil.AssertEqual(t, 24, size)\n\tsize = BarChart{Width: 513, Height: 513}.getTitleFontSize()\n\ttestutil.AssertEqual(t, 18, size)\n\tsize = BarChart{Width: 257, Height: 257}.getTitleFontSize()\n\ttestutil.AssertEqual(t, 12, size)\n\tsize = BarChart{Width: 128, Height: 128}.getTitleFontSize()\n\ttestutil.AssertEqual(t, 10, size)\n}\n"
        },
        {
          "name": "bollinger_band_series.go",
          "type": "blob",
          "size": 3.1669921875,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n)\n\n// Interface Assertions.\nvar (\n\t_ Series = (*BollingerBandsSeries)(nil)\n)\n\n// BollingerBandsSeries draws bollinger bands for an inner series.\n// Bollinger bands are defined by two lines, one at SMA+k*stddev, one at SMA-k*stdev.\ntype BollingerBandsSeries struct {\n\tName  string\n\tStyle Style\n\tYAxis YAxisType\n\n\tPeriod      int\n\tK           float64\n\tInnerSeries ValuesProvider\n\n\tvalueBuffer *ValueBuffer\n}\n\n// GetName returns the name of the time series.\nfunc (bbs BollingerBandsSeries) GetName() string {\n\treturn bbs.Name\n}\n\n// GetStyle returns the line style.\nfunc (bbs BollingerBandsSeries) GetStyle() Style {\n\treturn bbs.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (bbs BollingerBandsSeries) GetYAxis() YAxisType {\n\treturn bbs.YAxis\n}\n\n// GetPeriod returns the window size.\nfunc (bbs BollingerBandsSeries) GetPeriod() int {\n\tif bbs.Period == 0 {\n\t\treturn DefaultSimpleMovingAveragePeriod\n\t}\n\treturn bbs.Period\n}\n\n// GetK returns the K value, or the number of standard deviations above and below\n// to band the simple moving average with.\n// Typical K value is 2.0.\nfunc (bbs BollingerBandsSeries) GetK(defaults ...float64) float64 {\n\tif bbs.K == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn 2.0\n\t}\n\treturn bbs.K\n}\n\n// Len returns the number of elements in the series.\nfunc (bbs BollingerBandsSeries) Len() int {\n\treturn bbs.InnerSeries.Len()\n}\n\n// GetBoundedValues gets the bounded value for the series.\nfunc (bbs *BollingerBandsSeries) GetBoundedValues(index int) (x, y1, y2 float64) {\n\tif bbs.InnerSeries == nil {\n\t\treturn\n\t}\n\tif bbs.valueBuffer == nil || index == 0 {\n\t\tbbs.valueBuffer = NewValueBufferWithCapacity(bbs.GetPeriod())\n\t}\n\tif bbs.valueBuffer.Len() >= bbs.GetPeriod() {\n\t\tbbs.valueBuffer.Dequeue()\n\t}\n\tpx, py := bbs.InnerSeries.GetValues(index)\n\tbbs.valueBuffer.Enqueue(py)\n\tx = px\n\n\tay := Seq{bbs.valueBuffer}.Average()\n\tstd := Seq{bbs.valueBuffer}.StdDev()\n\n\ty1 = ay + (bbs.GetK() * std)\n\ty2 = ay - (bbs.GetK() * std)\n\treturn\n}\n\n// GetBoundedLastValues returns the last bounded value for the series.\nfunc (bbs *BollingerBandsSeries) GetBoundedLastValues() (x, y1, y2 float64) {\n\tif bbs.InnerSeries == nil {\n\t\treturn\n\t}\n\tperiod := bbs.GetPeriod()\n\tseriesLength := bbs.InnerSeries.Len()\n\tstartAt := seriesLength - period\n\tif startAt < 0 {\n\t\tstartAt = 0\n\t}\n\n\tvb := NewValueBufferWithCapacity(period)\n\tfor index := startAt; index < seriesLength; index++ {\n\t\txn, yn := bbs.InnerSeries.GetValues(index)\n\t\tvb.Enqueue(yn)\n\t\tx = xn\n\t}\n\n\tay := Seq{vb}.Average()\n\tstd := Seq{vb}.StdDev()\n\n\ty1 = ay + (bbs.GetK() * std)\n\ty2 = ay - (bbs.GetK() * std)\n\n\treturn\n}\n\n// Render renders the series.\nfunc (bbs *BollingerBandsSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\ts := bbs.Style.InheritFrom(defaults.InheritFrom(Style{\n\t\tStrokeWidth: 1.0,\n\t\tStrokeColor: DefaultAxisColor.WithAlpha(64),\n\t\tFillColor:   DefaultAxisColor.WithAlpha(32),\n\t}))\n\n\tDraw.BoundedSeries(r, canvasBox, xrange, yrange, s, bbs, bbs.GetPeriod())\n}\n\n// Validate validates the series.\nfunc (bbs BollingerBandsSeries) Validate() error {\n\tif bbs.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"bollinger bands series requires InnerSeries to be set\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "bollinger_band_series_test.go",
          "type": "blob",
          "size": 1.0556640625,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestBollingerBandSeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\ts1 := mockValuesProvider{\n\t\tX: LinearRange(1.0, 100.0),\n\t\tY: RandomValuesWithMax(100, 1024),\n\t}\n\n\tbbs := &BollingerBandsSeries{\n\t\tInnerSeries: s1,\n\t}\n\n\txvalues := make([]float64, 100)\n\ty1values := make([]float64, 100)\n\ty2values := make([]float64, 100)\n\n\tfor x := 0; x < 100; x++ {\n\t\txvalues[x], y1values[x], y2values[x] = bbs.GetBoundedValues(x)\n\t}\n\n\tfor x := bbs.GetPeriod(); x < 100; x++ {\n\t\ttestutil.AssertTrue(t, y1values[x] > y2values[x], fmt.Sprintf(\"%v vs. %v\", y1values[x], y2values[x]))\n\t}\n}\n\nfunc TestBollingerBandLastValue(t *testing.T) {\n\t// replaced new assertions helper\n\n\ts1 := mockValuesProvider{\n\t\tX: LinearRange(1.0, 100.0),\n\t\tY: LinearRange(1.0, 100.0),\n\t}\n\n\tbbs := &BollingerBandsSeries{\n\t\tInnerSeries: s1,\n\t}\n\n\tx, y1, y2 := bbs.GetBoundedLastValues()\n\ttestutil.AssertEqual(t, 100.0, x)\n\ttestutil.AssertEqual(t, 101, math.Floor(y1))\n\ttestutil.AssertEqual(t, 83, math.Floor(y2))\n}\n"
        },
        {
          "name": "bounded_last_values_annotation_series.go",
          "type": "blob",
          "size": 0.9404296875,
          "content": "package chart\n\nimport \"fmt\"\n\n// BoundedLastValuesAnnotationSeries returns a last value annotation series for a bounded values provider.\nfunc BoundedLastValuesAnnotationSeries(innerSeries FullBoundedValuesProvider, vfs ...ValueFormatter) AnnotationSeries {\n\tlvx, lvy1, lvy2 := innerSeries.GetBoundedLastValues()\n\n\tvar vf ValueFormatter\n\tif len(vfs) > 0 {\n\t\tvf = vfs[0]\n\t} else if typed, isTyped := innerSeries.(ValueFormatterProvider); isTyped {\n\t\t_, vf = typed.GetValueFormatters()\n\t} else {\n\t\tvf = FloatValueFormatter\n\t}\n\n\tlabel1 := vf(lvy1)\n\tlabel2 := vf(lvy2)\n\n\tvar seriesName string\n\tvar seriesStyle Style\n\tif typed, isTyped := innerSeries.(Series); isTyped {\n\t\tseriesName = fmt.Sprintf(\"%s - Last Values\", typed.GetName())\n\t\tseriesStyle = typed.GetStyle()\n\t}\n\n\treturn AnnotationSeries{\n\t\tName:  seriesName,\n\t\tStyle: seriesStyle,\n\t\tAnnotations: []Value2{\n\t\t\t{XValue: lvx, YValue: lvy1, Label: label1},\n\t\t\t{XValue: lvx, YValue: lvy2, Label: label2},\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "box.go",
          "type": "blob",
          "size": 8.4013671875,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nvar (\n\t// BoxZero is a preset box that represents an intentional zero value.\n\tBoxZero = Box{IsSet: true}\n)\n\n// NewBox returns a new (set) box.\nfunc NewBox(top, left, right, bottom int) Box {\n\treturn Box{\n\t\tIsSet:  true,\n\t\tTop:    top,\n\t\tLeft:   left,\n\t\tRight:  right,\n\t\tBottom: bottom,\n\t}\n}\n\n// Box represents the main 4 dimensions of a box.\ntype Box struct {\n\tTop    int\n\tLeft   int\n\tRight  int\n\tBottom int\n\tIsSet  bool\n}\n\n// IsZero returns if the box is set or not.\nfunc (b Box) IsZero() bool {\n\tif b.IsSet {\n\t\treturn false\n\t}\n\treturn b.Top == 0 && b.Left == 0 && b.Right == 0 && b.Bottom == 0\n}\n\n// String returns a string representation of the box.\nfunc (b Box) String() string {\n\treturn fmt.Sprintf(\"box(%d,%d,%d,%d)\", b.Top, b.Left, b.Right, b.Bottom)\n}\n\n// GetTop returns a coalesced value with a default.\nfunc (b Box) GetTop(defaults ...int) int {\n\tif !b.IsSet && b.Top == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn 0\n\t}\n\treturn b.Top\n}\n\n// GetLeft returns a coalesced value with a default.\nfunc (b Box) GetLeft(defaults ...int) int {\n\tif !b.IsSet && b.Left == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn 0\n\t}\n\treturn b.Left\n}\n\n// GetRight returns a coalesced value with a default.\nfunc (b Box) GetRight(defaults ...int) int {\n\tif !b.IsSet && b.Right == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn 0\n\t}\n\treturn b.Right\n}\n\n// GetBottom returns a coalesced value with a default.\nfunc (b Box) GetBottom(defaults ...int) int {\n\tif !b.IsSet && b.Bottom == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn 0\n\t}\n\treturn b.Bottom\n}\n\n// Width returns the width\nfunc (b Box) Width() int {\n\treturn AbsInt(b.Right - b.Left)\n}\n\n// Height returns the height\nfunc (b Box) Height() int {\n\treturn AbsInt(b.Bottom - b.Top)\n}\n\n// Center returns the center of the box\nfunc (b Box) Center() (x, y int) {\n\tw2, h2 := b.Width()>>1, b.Height()>>1\n\treturn b.Left + w2, b.Top + h2\n}\n\n// Aspect returns the aspect ratio of the box.\nfunc (b Box) Aspect() float64 {\n\treturn float64(b.Width()) / float64(b.Height())\n}\n\n// Clone returns a new copy of the box.\nfunc (b Box) Clone() Box {\n\treturn Box{\n\t\tIsSet:  b.IsSet,\n\t\tTop:    b.Top,\n\t\tLeft:   b.Left,\n\t\tRight:  b.Right,\n\t\tBottom: b.Bottom,\n\t}\n}\n\n// IsBiggerThan returns if a box is bigger than another box.\nfunc (b Box) IsBiggerThan(other Box) bool {\n\treturn b.Top < other.Top ||\n\t\tb.Bottom > other.Bottom ||\n\t\tb.Left < other.Left ||\n\t\tb.Right > other.Right\n}\n\n// IsSmallerThan returns if a box is smaller than another box.\nfunc (b Box) IsSmallerThan(other Box) bool {\n\treturn b.Top > other.Top &&\n\t\tb.Bottom < other.Bottom &&\n\t\tb.Left > other.Left &&\n\t\tb.Right < other.Right\n}\n\n// Equals returns if the box equals another box.\nfunc (b Box) Equals(other Box) bool {\n\treturn b.Top == other.Top &&\n\t\tb.Left == other.Left &&\n\t\tb.Right == other.Right &&\n\t\tb.Bottom == other.Bottom\n}\n\n// Grow grows a box based on another box.\nfunc (b Box) Grow(other Box) Box {\n\treturn Box{\n\t\tTop:    MinInt(b.Top, other.Top),\n\t\tLeft:   MinInt(b.Left, other.Left),\n\t\tRight:  MaxInt(b.Right, other.Right),\n\t\tBottom: MaxInt(b.Bottom, other.Bottom),\n\t}\n}\n\n// Shift pushes a box by x,y.\nfunc (b Box) Shift(x, y int) Box {\n\treturn Box{\n\t\tTop:    b.Top + y,\n\t\tLeft:   b.Left + x,\n\t\tRight:  b.Right + x,\n\t\tBottom: b.Bottom + y,\n\t}\n}\n\n// Corners returns the box as a set of corners.\nfunc (b Box) Corners() BoxCorners {\n\treturn BoxCorners{\n\t\tTopLeft:     Point{b.Left, b.Top},\n\t\tTopRight:    Point{b.Right, b.Top},\n\t\tBottomRight: Point{b.Right, b.Bottom},\n\t\tBottomLeft:  Point{b.Left, b.Bottom},\n\t}\n}\n\n// Fit is functionally the inverse of grow.\n// Fit maintains the original aspect ratio of the `other` box,\n// but constrains it to the bounds of the target box.\nfunc (b Box) Fit(other Box) Box {\n\tba := b.Aspect()\n\toa := other.Aspect()\n\n\tif oa == ba {\n\t\treturn b.Clone()\n\t}\n\n\tbw, bh := float64(b.Width()), float64(b.Height())\n\tbw2 := int(bw) >> 1\n\tbh2 := int(bh) >> 1\n\tif oa > ba { // ex. 16:9 vs. 4:3\n\t\tvar noh2 int\n\t\tif oa > 1.0 {\n\t\t\tnoh2 = int(bw/oa) >> 1\n\t\t} else {\n\t\t\tnoh2 = int(bh*oa) >> 1\n\t\t}\n\t\treturn Box{\n\t\t\tTop:    (b.Top + bh2) - noh2,\n\t\t\tLeft:   b.Left,\n\t\t\tRight:  b.Right,\n\t\t\tBottom: (b.Top + bh2) + noh2,\n\t\t}\n\t}\n\tvar now2 int\n\tif oa > 1.0 {\n\t\tnow2 = int(bh/oa) >> 1\n\t} else {\n\t\tnow2 = int(bw*oa) >> 1\n\t}\n\treturn Box{\n\t\tTop:    b.Top,\n\t\tLeft:   (b.Left + bw2) - now2,\n\t\tRight:  (b.Left + bw2) + now2,\n\t\tBottom: b.Bottom,\n\t}\n}\n\n// Constrain is similar to `Fit` except that it will work\n// more literally like the opposite of grow.\nfunc (b Box) Constrain(other Box) Box {\n\tnewBox := b.Clone()\n\n\tnewBox.Top = MaxInt(newBox.Top, other.Top)\n\tnewBox.Left = MaxInt(newBox.Left, other.Left)\n\tnewBox.Right = MinInt(newBox.Right, other.Right)\n\tnewBox.Bottom = MinInt(newBox.Bottom, other.Bottom)\n\n\treturn newBox\n}\n\n// OuterConstrain is similar to `Constraint` with the difference\n// that it applies corrections\nfunc (b Box) OuterConstrain(bounds, other Box) Box {\n\tnewBox := b.Clone()\n\tif other.Top < bounds.Top {\n\t\tdelta := bounds.Top - other.Top\n\t\tnewBox.Top = b.Top + delta\n\t}\n\n\tif other.Left < bounds.Left {\n\t\tdelta := bounds.Left - other.Left\n\t\tnewBox.Left = b.Left + delta\n\t}\n\n\tif other.Right > bounds.Right {\n\t\tdelta := other.Right - bounds.Right\n\t\tnewBox.Right = b.Right - delta\n\t}\n\n\tif other.Bottom > bounds.Bottom {\n\t\tdelta := other.Bottom - bounds.Bottom\n\t\tnewBox.Bottom = b.Bottom - delta\n\t}\n\treturn newBox\n}\n\nfunc (b Box) Validate() error {\n\tif b.Left < 0 {\n\t\treturn fmt.Errorf(\"invalid left; must be >= 0\")\n\t}\n\tif b.Right < 0 {\n\t\treturn fmt.Errorf(\"invalid right; must be > 0\")\n\t}\n\tif b.Top < 0 {\n\t\treturn fmt.Errorf(\"invalid top; must be > 0\")\n\t}\n\tif b.Bottom < 0 {\n\t\treturn fmt.Errorf(\"invalid bottom; must be > 0\")\n\t}\n\treturn nil\n}\n\n// BoxCorners is a box with independent corners.\ntype BoxCorners struct {\n\tTopLeft, TopRight, BottomRight, BottomLeft Point\n}\n\n// Box return the BoxCorners as a regular box.\nfunc (bc BoxCorners) Box() Box {\n\treturn Box{\n\t\tTop:    MinInt(bc.TopLeft.Y, bc.TopRight.Y),\n\t\tLeft:   MinInt(bc.TopLeft.X, bc.BottomLeft.X),\n\t\tRight:  MaxInt(bc.TopRight.X, bc.BottomRight.X),\n\t\tBottom: MaxInt(bc.BottomLeft.Y, bc.BottomRight.Y),\n\t}\n}\n\n// Width returns the width\nfunc (bc BoxCorners) Width() int {\n\tminLeft := MinInt(bc.TopLeft.X, bc.BottomLeft.X)\n\tmaxRight := MaxInt(bc.TopRight.X, bc.BottomRight.X)\n\treturn maxRight - minLeft\n}\n\n// Height returns the height\nfunc (bc BoxCorners) Height() int {\n\tminTop := MinInt(bc.TopLeft.Y, bc.TopRight.Y)\n\tmaxBottom := MaxInt(bc.BottomLeft.Y, bc.BottomRight.Y)\n\treturn maxBottom - minTop\n}\n\n// Center returns the center of the box\nfunc (bc BoxCorners) Center() (x, y int) {\n\n\tleft := MeanInt(bc.TopLeft.X, bc.BottomLeft.X)\n\tright := MeanInt(bc.TopRight.X, bc.BottomRight.X)\n\tx = ((right - left) >> 1) + left\n\n\ttop := MeanInt(bc.TopLeft.Y, bc.TopRight.Y)\n\tbottom := MeanInt(bc.BottomLeft.Y, bc.BottomRight.Y)\n\ty = ((bottom - top) >> 1) + top\n\n\treturn\n}\n\n// Rotate rotates the box.\nfunc (bc BoxCorners) Rotate(thetaDegrees float64) BoxCorners {\n\tcx, cy := bc.Center()\n\n\tthetaRadians := DegreesToRadians(thetaDegrees)\n\n\ttlx, tly := RotateCoordinate(cx, cy, bc.TopLeft.X, bc.TopLeft.Y, thetaRadians)\n\ttrx, try := RotateCoordinate(cx, cy, bc.TopRight.X, bc.TopRight.Y, thetaRadians)\n\tbrx, bry := RotateCoordinate(cx, cy, bc.BottomRight.X, bc.BottomRight.Y, thetaRadians)\n\tblx, bly := RotateCoordinate(cx, cy, bc.BottomLeft.X, bc.BottomLeft.Y, thetaRadians)\n\n\treturn BoxCorners{\n\t\tTopLeft:     Point{tlx, tly},\n\t\tTopRight:    Point{trx, try},\n\t\tBottomRight: Point{brx, bry},\n\t\tBottomLeft:  Point{blx, bly},\n\t}\n}\n\n// Equals returns if the box equals another box.\nfunc (bc BoxCorners) Equals(other BoxCorners) bool {\n\treturn bc.TopLeft.Equals(other.TopLeft) &&\n\t\tbc.TopRight.Equals(other.TopRight) &&\n\t\tbc.BottomRight.Equals(other.BottomRight) &&\n\t\tbc.BottomLeft.Equals(other.BottomLeft)\n}\n\nfunc (bc BoxCorners) String() string {\n\treturn fmt.Sprintf(\"BoxC{%s,%s,%s,%s}\", bc.TopLeft.String(), bc.TopRight.String(), bc.BottomRight.String(), bc.BottomLeft.String())\n}\n\n// Point is an X,Y pair\ntype Point struct {\n\tX, Y int\n}\n\n// DistanceTo calculates the distance to another point.\nfunc (p Point) DistanceTo(other Point) float64 {\n\tdx := math.Pow(float64(p.X-other.X), 2)\n\tdy := math.Pow(float64(p.Y-other.Y), 2)\n\treturn math.Pow(dx+dy, 0.5)\n}\n\n// Equals returns if a point equals another point.\nfunc (p Point) Equals(other Point) bool {\n\treturn p.X == other.X && p.Y == other.Y\n}\n\n// String returns a string representation of the point.\nfunc (p Point) String() string {\n\treturn fmt.Sprintf(\"P{%d,%d}\", p.X, p.Y)\n}\n"
        },
        {
          "name": "box_test.go",
          "type": "blob",
          "size": 5.0439453125,
          "content": "package chart\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestBoxClone(t *testing.T) {\n\t// replaced new assertions helper\n\ta := Box{Top: 5, Left: 5, Right: 15, Bottom: 15}\n\tb := a.Clone()\n\ttestutil.AssertTrue(t, a.Equals(b))\n\ttestutil.AssertTrue(t, b.Equals(a))\n}\n\nfunc TestBoxEquals(t *testing.T) {\n\t// replaced new assertions helper\n\n\ta := Box{Top: 5, Left: 5, Right: 15, Bottom: 15}\n\tb := Box{Top: 10, Left: 10, Right: 30, Bottom: 30}\n\tc := Box{Top: 5, Left: 5, Right: 15, Bottom: 15}\n\ttestutil.AssertTrue(t, a.Equals(a))\n\ttestutil.AssertTrue(t, a.Equals(c))\n\ttestutil.AssertTrue(t, c.Equals(a))\n\ttestutil.AssertFalse(t, a.Equals(b))\n\ttestutil.AssertFalse(t, c.Equals(b))\n\ttestutil.AssertFalse(t, b.Equals(a))\n\ttestutil.AssertFalse(t, b.Equals(c))\n}\n\nfunc TestBoxIsBiggerThan(t *testing.T) {\n\t// replaced new assertions helper\n\n\ta := Box{Top: 5, Left: 5, Right: 25, Bottom: 25}\n\tb := Box{Top: 10, Left: 10, Right: 20, Bottom: 20} // only half bigger\n\tc := Box{Top: 1, Left: 1, Right: 30, Bottom: 30}   //bigger\n\ttestutil.AssertTrue(t, a.IsBiggerThan(b))\n\ttestutil.AssertFalse(t, a.IsBiggerThan(c))\n\ttestutil.AssertTrue(t, c.IsBiggerThan(a))\n}\n\nfunc TestBoxIsSmallerThan(t *testing.T) {\n\t// replaced new assertions helper\n\n\ta := Box{Top: 5, Left: 5, Right: 25, Bottom: 25}\n\tb := Box{Top: 10, Left: 10, Right: 20, Bottom: 20} // only half bigger\n\tc := Box{Top: 1, Left: 1, Right: 30, Bottom: 30}   //bigger\n\ttestutil.AssertFalse(t, a.IsSmallerThan(b))\n\ttestutil.AssertTrue(t, a.IsSmallerThan(c))\n\ttestutil.AssertFalse(t, c.IsSmallerThan(a))\n}\n\nfunc TestBoxGrow(t *testing.T) {\n\t// replaced new assertions helper\n\n\ta := Box{Top: 1, Left: 2, Right: 15, Bottom: 15}\n\tb := Box{Top: 4, Left: 5, Right: 30, Bottom: 35}\n\tc := a.Grow(b)\n\ttestutil.AssertFalse(t, c.Equals(b))\n\ttestutil.AssertFalse(t, c.Equals(a))\n\ttestutil.AssertEqual(t, 1, c.Top)\n\ttestutil.AssertEqual(t, 2, c.Left)\n\ttestutil.AssertEqual(t, 30, c.Right)\n\ttestutil.AssertEqual(t, 35, c.Bottom)\n}\n\nfunc TestBoxFit(t *testing.T) {\n\t// replaced new assertions helper\n\n\ta := Box{Top: 64, Left: 64, Right: 192, Bottom: 192}\n\tb := Box{Top: 16, Left: 16, Right: 256, Bottom: 170}\n\tc := Box{Top: 16, Left: 16, Right: 170, Bottom: 256}\n\n\tfab := a.Fit(b)\n\ttestutil.AssertEqual(t, a.Left, fab.Left)\n\ttestutil.AssertEqual(t, a.Right, fab.Right)\n\ttestutil.AssertTrue(t, fab.Top < fab.Bottom)\n\ttestutil.AssertTrue(t, fab.Left < fab.Right)\n\ttestutil.AssertTrue(t, math.Abs(b.Aspect()-fab.Aspect()) < 0.02)\n\n\tfac := a.Fit(c)\n\ttestutil.AssertEqual(t, a.Top, fac.Top)\n\ttestutil.AssertEqual(t, a.Bottom, fac.Bottom)\n\ttestutil.AssertTrue(t, math.Abs(c.Aspect()-fac.Aspect()) < 0.02)\n}\n\nfunc TestBoxConstrain(t *testing.T) {\n\t// replaced new assertions helper\n\n\ta := Box{Top: 64, Left: 64, Right: 192, Bottom: 192}\n\tb := Box{Top: 16, Left: 16, Right: 256, Bottom: 170}\n\tc := Box{Top: 16, Left: 16, Right: 170, Bottom: 256}\n\n\tcab := a.Constrain(b)\n\ttestutil.AssertEqual(t, 64, cab.Top)\n\ttestutil.AssertEqual(t, 64, cab.Left)\n\ttestutil.AssertEqual(t, 192, cab.Right)\n\ttestutil.AssertEqual(t, 170, cab.Bottom)\n\n\tcac := a.Constrain(c)\n\ttestutil.AssertEqual(t, 64, cac.Top)\n\ttestutil.AssertEqual(t, 64, cac.Left)\n\ttestutil.AssertEqual(t, 170, cac.Right)\n\ttestutil.AssertEqual(t, 192, cac.Bottom)\n}\n\nfunc TestBoxOuterConstrain(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbox := NewBox(0, 0, 100, 100)\n\tcanvas := NewBox(5, 5, 95, 95)\n\ttaller := NewBox(-10, 5, 50, 50)\n\n\tc := canvas.OuterConstrain(box, taller)\n\ttestutil.AssertEqual(t, 15, c.Top, c.String())\n\ttestutil.AssertEqual(t, 5, c.Left, c.String())\n\ttestutil.AssertEqual(t, 95, c.Right, c.String())\n\ttestutil.AssertEqual(t, 95, c.Bottom, c.String())\n\n\twider := NewBox(5, 5, 110, 50)\n\td := canvas.OuterConstrain(box, wider)\n\ttestutil.AssertEqual(t, 5, d.Top, d.String())\n\ttestutil.AssertEqual(t, 5, d.Left, d.String())\n\ttestutil.AssertEqual(t, 85, d.Right, d.String())\n\ttestutil.AssertEqual(t, 95, d.Bottom, d.String())\n}\n\nfunc TestBoxShift(t *testing.T) {\n\t// replaced new assertions helper\n\n\tb := Box{\n\t\tTop:    5,\n\t\tLeft:   5,\n\t\tRight:  10,\n\t\tBottom: 10,\n\t}\n\n\tshifted := b.Shift(1, 2)\n\ttestutil.AssertEqual(t, 7, shifted.Top)\n\ttestutil.AssertEqual(t, 6, shifted.Left)\n\ttestutil.AssertEqual(t, 11, shifted.Right)\n\ttestutil.AssertEqual(t, 12, shifted.Bottom)\n}\n\nfunc TestBoxCenter(t *testing.T) {\n\t// replaced new assertions helper\n\n\tb := Box{\n\t\tTop:    10,\n\t\tLeft:   10,\n\t\tRight:  20,\n\t\tBottom: 30,\n\t}\n\tcx, cy := b.Center()\n\ttestutil.AssertEqual(t, 15, cx)\n\ttestutil.AssertEqual(t, 20, cy)\n}\n\nfunc TestBoxCornersCenter(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BoxCorners{\n\t\tTopLeft:     Point{5, 5},\n\t\tTopRight:    Point{15, 5},\n\t\tBottomRight: Point{15, 15},\n\t\tBottomLeft:  Point{5, 15},\n\t}\n\n\tcx, cy := bc.Center()\n\ttestutil.AssertEqual(t, 10, cx)\n\ttestutil.AssertEqual(t, 10, cy)\n}\n\nfunc TestBoxCornersRotate(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbc := BoxCorners{\n\t\tTopLeft:     Point{5, 5},\n\t\tTopRight:    Point{15, 5},\n\t\tBottomRight: Point{15, 15},\n\t\tBottomLeft:  Point{5, 15},\n\t}\n\n\trotated := bc.Rotate(45)\n\ttestutil.AssertTrue(t, rotated.TopLeft.Equals(Point{10, 3}), rotated.String())\n}\n"
        },
        {
          "name": "chart.go",
          "type": "blob",
          "size": 14.828125,
          "content": "package chart\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\n\t\"github.com/golang/freetype/truetype\"\n)\n\n// Chart is what we're drawing.\ntype Chart struct {\n\tTitle      string\n\tTitleStyle Style\n\n\tColorPalette ColorPalette\n\n\tWidth  int\n\tHeight int\n\tDPI    float64\n\n\tBackground Style\n\tCanvas     Style\n\n\tXAxis          XAxis\n\tYAxis          YAxis\n\tYAxisSecondary YAxis\n\n\tFont        *truetype.Font\n\tdefaultFont *truetype.Font\n\n\tSeries   []Series\n\tElements []Renderable\n\n\tLog Logger\n}\n\n// GetDPI returns the dpi for the chart.\nfunc (c Chart) GetDPI(defaults ...float64) float64 {\n\tif c.DPI == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn DefaultDPI\n\t}\n\treturn c.DPI\n}\n\n// GetFont returns the text font.\nfunc (c Chart) GetFont() *truetype.Font {\n\tif c.Font == nil {\n\t\treturn c.defaultFont\n\t}\n\treturn c.Font\n}\n\n// GetWidth returns the chart width or the default value.\nfunc (c Chart) GetWidth() int {\n\tif c.Width == 0 {\n\t\treturn DefaultChartWidth\n\t}\n\treturn c.Width\n}\n\n// GetHeight returns the chart height or the default value.\nfunc (c Chart) GetHeight() int {\n\tif c.Height == 0 {\n\t\treturn DefaultChartHeight\n\t}\n\treturn c.Height\n}\n\n// Render renders the chart with the given renderer to the given io.Writer.\nfunc (c Chart) Render(rp RendererProvider, w io.Writer) error {\n\tif len(c.Series) == 0 {\n\t\treturn errors.New(\"please provide at least one series\")\n\t}\n\tif err := c.checkHasVisibleSeries(); err != nil {\n\t\treturn err\n\t}\n\n\tc.YAxisSecondary.AxisType = YAxisSecondary\n\n\tr, err := rp(c.GetWidth(), c.GetHeight())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.Font == nil {\n\t\tdefaultFont, err := GetDefaultFont()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.defaultFont = defaultFont\n\t}\n\tr.SetDPI(c.GetDPI(DefaultDPI))\n\n\tc.drawBackground(r)\n\n\tvar xt, yt, yta []Tick\n\txr, yr, yra := c.getRanges()\n\tcanvasBox := c.getDefaultCanvasBox()\n\txf, yf, yfa := c.getValueFormatters()\n\n\tDebugf(c.Log, \"chart; canvas box: %v\", canvasBox)\n\n\txr, yr, yra = c.setRangeDomains(canvasBox, xr, yr, yra)\n\n\terr = c.checkRanges(xr, yr, yra)\n\tif err != nil {\n\t\tr.Save(w)\n\t\treturn err\n\t}\n\n\tif c.hasAxes() {\n\t\txt, yt, yta = c.getAxesTicks(r, xr, yr, yra, xf, yf, yfa)\n\t\tcanvasBox = c.getAxesAdjustedCanvasBox(r, canvasBox, xr, yr, yra, xt, yt, yta)\n\t\txr, yr, yra = c.setRangeDomains(canvasBox, xr, yr, yra)\n\n\t\tDebugf(c.Log, \"chart; axes adjusted canvas box: %v\", canvasBox)\n\n\t\t// do a second pass in case things haven't settled yet.\n\t\txt, yt, yta = c.getAxesTicks(r, xr, yr, yra, xf, yf, yfa)\n\t\tcanvasBox = c.getAxesAdjustedCanvasBox(r, canvasBox, xr, yr, yra, xt, yt, yta)\n\t\txr, yr, yra = c.setRangeDomains(canvasBox, xr, yr, yra)\n\t}\n\n\tif c.hasAnnotationSeries() {\n\t\tcanvasBox = c.getAnnotationAdjustedCanvasBox(r, canvasBox, xr, yr, yra, xf, yf, yfa)\n\t\txr, yr, yra = c.setRangeDomains(canvasBox, xr, yr, yra)\n\t\txt, yt, yta = c.getAxesTicks(r, xr, yr, yra, xf, yf, yfa)\n\n\t\tDebugf(c.Log, \"chart; annotation adjusted canvas box: %v\", canvasBox)\n\t}\n\n\tc.drawCanvas(r, canvasBox)\n\tc.drawAxes(r, canvasBox, xr, yr, yra, xt, yt, yta)\n\tfor index, series := range c.Series {\n\t\tc.drawSeries(r, canvasBox, xr, yr, yra, series, index)\n\t}\n\n\tc.drawTitle(r)\n\n\tfor _, a := range c.Elements {\n\t\ta(r, canvasBox, c.styleDefaultsElements())\n\t}\n\n\treturn r.Save(w)\n}\n\nfunc (c Chart) checkHasVisibleSeries() error {\n\tvar style Style\n\tfor _, s := range c.Series {\n\t\tstyle = s.GetStyle()\n\t\tif !style.Hidden {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"chart render; must have (1) visible series\")\n}\n\nfunc (c Chart) validateSeries() error {\n\tvar err error\n\tfor _, s := range c.Series {\n\t\terr = s.Validate()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c Chart) getRanges() (xrange, yrange, yrangeAlt Range) {\n\tvar minx, maxx float64 = math.MaxFloat64, -math.MaxFloat64\n\tvar miny, maxy float64 = math.MaxFloat64, -math.MaxFloat64\n\tvar minya, maxya float64 = math.MaxFloat64, -math.MaxFloat64\n\n\tseriesMappedToSecondaryAxis := false\n\n\t// note: a possible future optimization is to not scan the series values if\n\t// all axis are represented by either custom ticks or custom ranges.\n\tfor _, s := range c.Series {\n\t\tif !s.GetStyle().Hidden {\n\t\t\tseriesAxis := s.GetYAxis()\n\t\t\tif bvp, isBoundedValuesProvider := s.(BoundedValuesProvider); isBoundedValuesProvider {\n\t\t\t\tseriesLength := bvp.Len()\n\t\t\t\tfor index := 0; index < seriesLength; index++ {\n\t\t\t\t\tvx, vy1, vy2 := bvp.GetBoundedValues(index)\n\n\t\t\t\t\tminx = math.Min(minx, vx)\n\t\t\t\t\tmaxx = math.Max(maxx, vx)\n\n\t\t\t\t\tif seriesAxis == YAxisPrimary {\n\t\t\t\t\t\tminy = math.Min(miny, vy1)\n\t\t\t\t\t\tminy = math.Min(miny, vy2)\n\t\t\t\t\t\tmaxy = math.Max(maxy, vy1)\n\t\t\t\t\t\tmaxy = math.Max(maxy, vy2)\n\t\t\t\t\t} else if seriesAxis == YAxisSecondary {\n\t\t\t\t\t\tminya = math.Min(minya, vy1)\n\t\t\t\t\t\tminya = math.Min(minya, vy2)\n\t\t\t\t\t\tmaxya = math.Max(maxya, vy1)\n\t\t\t\t\t\tmaxya = math.Max(maxya, vy2)\n\t\t\t\t\t\tseriesMappedToSecondaryAxis = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if vp, isValuesProvider := s.(ValuesProvider); isValuesProvider {\n\t\t\t\tseriesLength := vp.Len()\n\t\t\t\tfor index := 0; index < seriesLength; index++ {\n\t\t\t\t\tvx, vy := vp.GetValues(index)\n\n\t\t\t\t\tminx = math.Min(minx, vx)\n\t\t\t\t\tmaxx = math.Max(maxx, vx)\n\n\t\t\t\t\tif seriesAxis == YAxisPrimary {\n\t\t\t\t\t\tminy = math.Min(miny, vy)\n\t\t\t\t\t\tmaxy = math.Max(maxy, vy)\n\t\t\t\t\t} else if seriesAxis == YAxisSecondary {\n\t\t\t\t\t\tminya = math.Min(minya, vy)\n\t\t\t\t\t\tmaxya = math.Max(maxya, vy)\n\t\t\t\t\t\tseriesMappedToSecondaryAxis = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.XAxis.Range == nil {\n\t\txrange = &ContinuousRange{}\n\t} else {\n\t\txrange = c.XAxis.Range\n\t}\n\n\tif c.YAxis.Range == nil {\n\t\tyrange = &ContinuousRange{}\n\t} else {\n\t\tyrange = c.YAxis.Range\n\t}\n\n\tif c.YAxisSecondary.Range == nil {\n\t\tyrangeAlt = &ContinuousRange{}\n\t} else {\n\t\tyrangeAlt = c.YAxisSecondary.Range\n\t}\n\n\tif len(c.XAxis.Ticks) > 0 {\n\t\ttickMin, tickMax := math.MaxFloat64, -math.MaxFloat64\n\t\tfor _, t := range c.XAxis.Ticks {\n\t\t\ttickMin = math.Min(tickMin, t.Value)\n\t\t\ttickMax = math.Max(tickMax, t.Value)\n\t\t}\n\t\txrange.SetMin(tickMin)\n\t\txrange.SetMax(tickMax)\n\t} else if xrange.IsZero() {\n\t\txrange.SetMin(minx)\n\t\txrange.SetMax(maxx)\n\t}\n\n\tif len(c.YAxis.Ticks) > 0 {\n\t\ttickMin, tickMax := math.MaxFloat64, -math.MaxFloat64\n\t\tfor _, t := range c.YAxis.Ticks {\n\t\t\ttickMin = math.Min(tickMin, t.Value)\n\t\t\ttickMax = math.Max(tickMax, t.Value)\n\t\t}\n\t\tyrange.SetMin(tickMin)\n\t\tyrange.SetMax(tickMax)\n\t} else if yrange.IsZero() {\n\t\tyrange.SetMin(miny)\n\t\tyrange.SetMax(maxy)\n\n\t\tif !c.YAxis.Style.Hidden {\n\t\t\tdelta := yrange.GetDelta()\n\t\t\troundTo := GetRoundToForDelta(delta)\n\t\t\trmin, rmax := RoundDown(yrange.GetMin(), roundTo), RoundUp(yrange.GetMax(), roundTo)\n\n\t\t\tyrange.SetMin(rmin)\n\t\t\tyrange.SetMax(rmax)\n\t\t}\n\t}\n\n\tif len(c.YAxisSecondary.Ticks) > 0 {\n\t\ttickMin, tickMax := math.MaxFloat64, -math.MaxFloat64\n\t\tfor _, t := range c.YAxis.Ticks {\n\t\t\ttickMin = math.Min(tickMin, t.Value)\n\t\t\ttickMax = math.Max(tickMax, t.Value)\n\t\t}\n\t\tyrangeAlt.SetMin(tickMin)\n\t\tyrangeAlt.SetMax(tickMax)\n\t} else if seriesMappedToSecondaryAxis && yrangeAlt.IsZero() {\n\t\tyrangeAlt.SetMin(minya)\n\t\tyrangeAlt.SetMax(maxya)\n\n\t\tif !c.YAxisSecondary.Style.Hidden {\n\t\t\tdelta := yrangeAlt.GetDelta()\n\t\t\troundTo := GetRoundToForDelta(delta)\n\t\t\trmin, rmax := RoundDown(yrangeAlt.GetMin(), roundTo), RoundUp(yrangeAlt.GetMax(), roundTo)\n\t\t\tyrangeAlt.SetMin(rmin)\n\t\t\tyrangeAlt.SetMax(rmax)\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (c Chart) checkRanges(xr, yr, yra Range) error {\n\tDebugf(c.Log, \"checking xrange: %v\", xr)\n\txDelta := xr.GetDelta()\n\tif math.IsInf(xDelta, 0) {\n\t\treturn errors.New(\"infinite x-range delta\")\n\t}\n\tif math.IsNaN(xDelta) {\n\t\treturn errors.New(\"nan x-range delta\")\n\t}\n\tif xDelta == 0 {\n\t\treturn errors.New(\"zero x-range delta; there needs to be at least (2) values\")\n\t}\n\n\tDebugf(c.Log, \"checking yrange: %v\", yr)\n\tyDelta := yr.GetDelta()\n\tif math.IsInf(yDelta, 0) {\n\t\treturn errors.New(\"infinite y-range delta\")\n\t}\n\tif math.IsNaN(yDelta) {\n\t\treturn errors.New(\"nan y-range delta\")\n\t}\n\n\tif c.hasSecondarySeries() {\n\t\tDebugf(c.Log, \"checking secondary yrange: %v\", yra)\n\t\tyraDelta := yra.GetDelta()\n\t\tif math.IsInf(yraDelta, 0) {\n\t\t\treturn errors.New(\"infinite secondary y-range delta\")\n\t\t}\n\t\tif math.IsNaN(yraDelta) {\n\t\t\treturn errors.New(\"nan secondary y-range delta\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (c Chart) getDefaultCanvasBox() Box {\n\treturn c.Box()\n}\n\nfunc (c Chart) getValueFormatters() (x, y, ya ValueFormatter) {\n\tfor _, s := range c.Series {\n\t\tif vfp, isVfp := s.(ValueFormatterProvider); isVfp {\n\t\t\tsx, sy := vfp.GetValueFormatters()\n\t\t\tif s.GetYAxis() == YAxisPrimary {\n\t\t\t\tx = sx\n\t\t\t\ty = sy\n\t\t\t} else if s.GetYAxis() == YAxisSecondary {\n\t\t\t\tx = sx\n\t\t\t\tya = sy\n\t\t\t}\n\t\t}\n\t}\n\tif c.XAxis.ValueFormatter != nil {\n\t\tx = c.XAxis.GetValueFormatter()\n\t}\n\tif c.YAxis.ValueFormatter != nil {\n\t\ty = c.YAxis.GetValueFormatter()\n\t}\n\tif c.YAxisSecondary.ValueFormatter != nil {\n\t\tya = c.YAxisSecondary.GetValueFormatter()\n\t}\n\treturn\n}\n\nfunc (c Chart) hasAxes() bool {\n\treturn !c.XAxis.Style.Hidden || !c.YAxis.Style.Hidden || !c.YAxisSecondary.Style.Hidden\n}\n\nfunc (c Chart) getAxesTicks(r Renderer, xr, yr, yar Range, xf, yf, yfa ValueFormatter) (xticks, yticks, yticksAlt []Tick) {\n\tif !c.XAxis.Style.Hidden {\n\t\txticks = c.XAxis.GetTicks(r, xr, c.styleDefaultsAxes(), xf)\n\t}\n\tif !c.YAxis.Style.Hidden {\n\t\tyticks = c.YAxis.GetTicks(r, yr, c.styleDefaultsAxes(), yf)\n\t}\n\tif !c.YAxisSecondary.Style.Hidden {\n\t\tyticksAlt = c.YAxisSecondary.GetTicks(r, yar, c.styleDefaultsAxes(), yfa)\n\t}\n\treturn\n}\n\nfunc (c Chart) getAxesAdjustedCanvasBox(r Renderer, canvasBox Box, xr, yr, yra Range, xticks, yticks, yticksAlt []Tick) Box {\n\taxesOuterBox := canvasBox.Clone()\n\tif !c.XAxis.Style.Hidden {\n\t\taxesBounds := c.XAxis.Measure(r, canvasBox, xr, c.styleDefaultsAxes(), xticks)\n\t\tDebugf(c.Log, \"chart; x-axis measured %v\", axesBounds)\n\t\taxesOuterBox = axesOuterBox.Grow(axesBounds)\n\t}\n\tif !c.YAxis.Style.Hidden {\n\t\taxesBounds := c.YAxis.Measure(r, canvasBox, yr, c.styleDefaultsAxes(), yticks)\n\t\tDebugf(c.Log, \"chart; y-axis measured %v\", axesBounds)\n\t\taxesOuterBox = axesOuterBox.Grow(axesBounds)\n\t}\n\tif !c.YAxisSecondary.Style.Hidden && c.hasSecondarySeries() {\n\t\taxesBounds := c.YAxisSecondary.Measure(r, canvasBox, yra, c.styleDefaultsAxes(), yticksAlt)\n\t\tDebugf(c.Log, \"chart; y-axis secondary measured %v\", axesBounds)\n\t\taxesOuterBox = axesOuterBox.Grow(axesBounds)\n\t}\n\n\treturn canvasBox.OuterConstrain(c.Box(), axesOuterBox)\n}\n\nfunc (c Chart) setRangeDomains(canvasBox Box, xr, yr, yra Range) (Range, Range, Range) {\n\txr.SetDomain(canvasBox.Width())\n\tyr.SetDomain(canvasBox.Height())\n\tyra.SetDomain(canvasBox.Height())\n\treturn xr, yr, yra\n}\n\nfunc (c Chart) hasAnnotationSeries() bool {\n\tfor _, s := range c.Series {\n\t\tif as, isAnnotationSeries := s.(AnnotationSeries); isAnnotationSeries {\n\t\t\tif !as.GetStyle().Hidden {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c Chart) hasSecondarySeries() bool {\n\tfor _, s := range c.Series {\n\t\tif s.GetYAxis() == YAxisSecondary {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c Chart) getAnnotationAdjustedCanvasBox(r Renderer, canvasBox Box, xr, yr, yra Range, xf, yf, yfa ValueFormatter) Box {\n\tannotationSeriesBox := canvasBox.Clone()\n\tfor seriesIndex, s := range c.Series {\n\t\tif as, isAnnotationSeries := s.(AnnotationSeries); isAnnotationSeries {\n\t\t\tif !as.GetStyle().Hidden {\n\t\t\t\tstyle := c.styleDefaultsSeries(seriesIndex)\n\t\t\t\tvar annotationBounds Box\n\t\t\t\tif as.YAxis == YAxisPrimary {\n\t\t\t\t\tannotationBounds = as.Measure(r, canvasBox, xr, yr, style)\n\t\t\t\t} else if as.YAxis == YAxisSecondary {\n\t\t\t\t\tannotationBounds = as.Measure(r, canvasBox, xr, yra, style)\n\t\t\t\t}\n\n\t\t\t\tannotationSeriesBox = annotationSeriesBox.Grow(annotationBounds)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn canvasBox.OuterConstrain(c.Box(), annotationSeriesBox)\n}\n\nfunc (c Chart) getBackgroundStyle() Style {\n\treturn c.Background.InheritFrom(c.styleDefaultsBackground())\n}\n\nfunc (c Chart) drawBackground(r Renderer) {\n\tDraw.Box(r, Box{\n\t\tRight:  c.GetWidth(),\n\t\tBottom: c.GetHeight(),\n\t}, c.getBackgroundStyle())\n}\n\nfunc (c Chart) getCanvasStyle() Style {\n\treturn c.Canvas.InheritFrom(c.styleDefaultsCanvas())\n}\n\nfunc (c Chart) drawCanvas(r Renderer, canvasBox Box) {\n\tDraw.Box(r, canvasBox, c.getCanvasStyle())\n}\n\nfunc (c Chart) drawAxes(r Renderer, canvasBox Box, xrange, yrange, yrangeAlt Range, xticks, yticks, yticksAlt []Tick) {\n\tif !c.XAxis.Style.Hidden {\n\t\tc.XAxis.Render(r, canvasBox, xrange, c.styleDefaultsAxes(), xticks)\n\t}\n\tif !c.YAxis.Style.Hidden {\n\t\tc.YAxis.Render(r, canvasBox, yrange, c.styleDefaultsAxes(), yticks)\n\t}\n\tif !c.YAxisSecondary.Style.Hidden {\n\t\tc.YAxisSecondary.Render(r, canvasBox, yrangeAlt, c.styleDefaultsAxes(), yticksAlt)\n\t}\n}\n\nfunc (c Chart) drawSeries(r Renderer, canvasBox Box, xrange, yrange, yrangeAlt Range, s Series, seriesIndex int) {\n\tif !s.GetStyle().Hidden {\n\t\tif s.GetYAxis() == YAxisPrimary {\n\t\t\ts.Render(r, canvasBox, xrange, yrange, c.styleDefaultsSeries(seriesIndex))\n\t\t} else if s.GetYAxis() == YAxisSecondary {\n\t\t\ts.Render(r, canvasBox, xrange, yrangeAlt, c.styleDefaultsSeries(seriesIndex))\n\t\t}\n\t}\n}\n\nfunc (c Chart) drawTitle(r Renderer) {\n\tif len(c.Title) > 0 && !c.TitleStyle.Hidden {\n\t\tr.SetFont(c.TitleStyle.GetFont(c.GetFont()))\n\t\tr.SetFontColor(c.TitleStyle.GetFontColor(c.GetColorPalette().TextColor()))\n\t\ttitleFontSize := c.TitleStyle.GetFontSize(DefaultTitleFontSize)\n\t\tr.SetFontSize(titleFontSize)\n\n\t\ttextBox := r.MeasureText(c.Title)\n\n\t\ttextWidth := textBox.Width()\n\t\ttextHeight := textBox.Height()\n\n\t\ttitleX := (c.GetWidth() >> 1) - (textWidth >> 1)\n\t\ttitleY := c.TitleStyle.Padding.GetTop(DefaultTitleTop) + textHeight\n\n\t\tr.Text(c.Title, titleX, titleY)\n\t}\n}\n\nfunc (c Chart) styleDefaultsBackground() Style {\n\treturn Style{\n\t\tFillColor:   c.GetColorPalette().BackgroundColor(),\n\t\tStrokeColor: c.GetColorPalette().BackgroundStrokeColor(),\n\t\tStrokeWidth: DefaultBackgroundStrokeWidth,\n\t}\n}\n\nfunc (c Chart) styleDefaultsCanvas() Style {\n\treturn Style{\n\t\tFillColor:   c.GetColorPalette().CanvasColor(),\n\t\tStrokeColor: c.GetColorPalette().CanvasStrokeColor(),\n\t\tStrokeWidth: DefaultCanvasStrokeWidth,\n\t}\n}\n\nfunc (c Chart) styleDefaultsSeries(seriesIndex int) Style {\n\treturn Style{\n\t\tDotColor:    c.GetColorPalette().GetSeriesColor(seriesIndex),\n\t\tStrokeColor: c.GetColorPalette().GetSeriesColor(seriesIndex),\n\t\tStrokeWidth: DefaultSeriesLineWidth,\n\t\tFont:        c.GetFont(),\n\t\tFontSize:    DefaultFontSize,\n\t}\n}\n\nfunc (c Chart) styleDefaultsAxes() Style {\n\treturn Style{\n\t\tFont:        c.GetFont(),\n\t\tFontColor:   c.GetColorPalette().TextColor(),\n\t\tFontSize:    DefaultAxisFontSize,\n\t\tStrokeColor: c.GetColorPalette().AxisStrokeColor(),\n\t\tStrokeWidth: DefaultAxisLineWidth,\n\t}\n}\n\nfunc (c Chart) styleDefaultsElements() Style {\n\treturn Style{\n\t\tFont: c.GetFont(),\n\t}\n}\n\n// GetColorPalette returns the color palette for the chart.\nfunc (c Chart) GetColorPalette() ColorPalette {\n\tif c.ColorPalette != nil {\n\t\treturn c.ColorPalette\n\t}\n\treturn DefaultColorPalette\n}\n\n// Box returns the chart bounds as a box.\nfunc (c Chart) Box() Box {\n\tdpr := c.Background.Padding.GetRight(DefaultBackgroundPadding.Right)\n\tdpb := c.Background.Padding.GetBottom(DefaultBackgroundPadding.Bottom)\n\n\treturn Box{\n\t\tTop:    c.Background.Padding.GetTop(DefaultBackgroundPadding.Top),\n\t\tLeft:   c.Background.Padding.GetLeft(DefaultBackgroundPadding.Left),\n\t\tRight:  c.GetWidth() - dpr,\n\t\tBottom: c.GetHeight() - dpb,\n\t}\n}\n"
        },
        {
          "name": "chart_test.go",
          "type": "blob",
          "size": 13.7314453125,
          "content": "package chart\n\nimport (\n\t\"bytes\"\n\t\"image\"\n\t\"image/png\"\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/wcharczuk/go-chart/v2/drawing\"\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestChartGetDPI(t *testing.T) {\n\t// replaced new assertions helper\n\n\tunset := Chart{}\n\ttestutil.AssertEqual(t, DefaultDPI, unset.GetDPI())\n\ttestutil.AssertEqual(t, 192, unset.GetDPI(192))\n\n\tset := Chart{DPI: 128}\n\ttestutil.AssertEqual(t, 128, set.GetDPI())\n\ttestutil.AssertEqual(t, 128, set.GetDPI(192))\n}\n\nfunc TestChartGetFont(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tunset := Chart{}\n\ttestutil.AssertNil(t, unset.GetFont())\n\n\tset := Chart{Font: f}\n\ttestutil.AssertNotNil(t, set.GetFont())\n}\n\nfunc TestChartGetWidth(t *testing.T) {\n\t// replaced new assertions helper\n\n\tunset := Chart{}\n\ttestutil.AssertEqual(t, DefaultChartWidth, unset.GetWidth())\n\n\tset := Chart{Width: DefaultChartWidth + 10}\n\ttestutil.AssertEqual(t, DefaultChartWidth+10, set.GetWidth())\n}\n\nfunc TestChartGetHeight(t *testing.T) {\n\t// replaced new assertions helper\n\n\tunset := Chart{}\n\ttestutil.AssertEqual(t, DefaultChartHeight, unset.GetHeight())\n\n\tset := Chart{Height: DefaultChartHeight + 10}\n\ttestutil.AssertEqual(t, DefaultChartHeight+10, set.GetHeight())\n}\n\nfunc TestChartGetRanges(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{-2.0, -1.0, 0, 1.0, 2.0},\n\t\t\t\tYValues: []float64{1.0, 2.0, 3.0, 4.0, 4.5},\n\t\t\t},\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tYValues: []float64{-2.1, -1.0, 0, 1.0, 2.0},\n\t\t\t},\n\t\t\tContinuousSeries{\n\t\t\t\tYAxis:   YAxisSecondary,\n\t\t\t\tXValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tYValues: []float64{10.0, 11.0, 12.0, 13.0, 14.0},\n\t\t\t},\n\t\t},\n\t}\n\n\txrange, yrange, yrangeAlt := c.getRanges()\n\ttestutil.AssertEqual(t, -2.0, xrange.GetMin())\n\ttestutil.AssertEqual(t, 5.0, xrange.GetMax())\n\n\ttestutil.AssertEqual(t, -2.1, yrange.GetMin())\n\ttestutil.AssertEqual(t, 4.5, yrange.GetMax())\n\n\ttestutil.AssertEqual(t, 10.0, yrangeAlt.GetMin())\n\ttestutil.AssertEqual(t, 14.0, yrangeAlt.GetMax())\n\n\tcSet := Chart{\n\t\tXAxis: XAxis{\n\t\t\tRange: &ContinuousRange{Min: 9.8, Max: 19.8},\n\t\t},\n\t\tYAxis: YAxis{\n\t\t\tRange: &ContinuousRange{Min: 9.9, Max: 19.9},\n\t\t},\n\t\tYAxisSecondary: YAxis{\n\t\t\tRange: &ContinuousRange{Min: 9.7, Max: 19.7},\n\t\t},\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{-2.0, -1.0, 0, 1.0, 2.0},\n\t\t\t\tYValues: []float64{1.0, 2.0, 3.0, 4.0, 4.5},\n\t\t\t},\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tYValues: []float64{-2.1, -1.0, 0, 1.0, 2.0},\n\t\t\t},\n\t\t\tContinuousSeries{\n\t\t\t\tYAxis:   YAxisSecondary,\n\t\t\t\tXValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tYValues: []float64{10.0, 11.0, 12.0, 13.0, 14.0},\n\t\t\t},\n\t\t},\n\t}\n\n\txr2, yr2, yra2 := cSet.getRanges()\n\ttestutil.AssertEqual(t, 9.8, xr2.GetMin())\n\ttestutil.AssertEqual(t, 19.8, xr2.GetMax())\n\n\ttestutil.AssertEqual(t, 9.9, yr2.GetMin())\n\ttestutil.AssertEqual(t, 19.9, yr2.GetMax())\n\n\ttestutil.AssertEqual(t, 9.7, yra2.GetMin())\n\ttestutil.AssertEqual(t, 19.7, yra2.GetMax())\n}\n\nfunc TestChartGetRangesUseTicks(t *testing.T) {\n\t// replaced new assertions helper\n\n\t// this test asserts that ticks should supercede manual ranges when generating the overall ranges.\n\n\tc := Chart{\n\t\tYAxis: YAxis{\n\t\t\tTicks: []Tick{\n\t\t\t\t{0.0, \"Zero\"},\n\t\t\t\t{1.0, \"1.0\"},\n\t\t\t\t{2.0, \"2.0\"},\n\t\t\t\t{3.0, \"3.0\"},\n\t\t\t\t{4.0, \"4.0\"},\n\t\t\t\t{5.0, \"Five\"},\n\t\t\t},\n\t\t\tRange: &ContinuousRange{\n\t\t\t\tMin: -5.0,\n\t\t\t\tMax: 5.0,\n\t\t\t},\n\t\t},\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{-2.0, -1.0, 0, 1.0, 2.0},\n\t\t\t\tYValues: []float64{1.0, 2.0, 3.0, 4.0, 4.5},\n\t\t\t},\n\t\t},\n\t}\n\n\txr, yr, yar := c.getRanges()\n\ttestutil.AssertEqual(t, -2.0, xr.GetMin())\n\ttestutil.AssertEqual(t, 2.0, xr.GetMax())\n\ttestutil.AssertEqual(t, 0.0, yr.GetMin())\n\ttestutil.AssertEqual(t, 5.0, yr.GetMax())\n\ttestutil.AssertTrue(t, yar.IsZero(), yar.String())\n}\n\nfunc TestChartGetRangesUseUserRanges(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tYAxis: YAxis{\n\t\t\tRange: &ContinuousRange{\n\t\t\t\tMin: -5.0,\n\t\t\t\tMax: 5.0,\n\t\t\t},\n\t\t},\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{-2.0, -1.0, 0, 1.0, 2.0},\n\t\t\t\tYValues: []float64{1.0, 2.0, 3.0, 4.0, 4.5},\n\t\t\t},\n\t\t},\n\t}\n\n\txr, yr, yar := c.getRanges()\n\ttestutil.AssertEqual(t, -2.0, xr.GetMin())\n\ttestutil.AssertEqual(t, 2.0, xr.GetMax())\n\ttestutil.AssertEqual(t, -5.0, yr.GetMin())\n\ttestutil.AssertEqual(t, 5.0, yr.GetMax())\n\ttestutil.AssertTrue(t, yar.IsZero(), yar.String())\n}\n\nfunc TestChartGetBackgroundStyle(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tBackground: Style{\n\t\t\tFillColor: drawing.ColorBlack,\n\t\t},\n\t}\n\n\tbs := c.getBackgroundStyle()\n\ttestutil.AssertEqual(t, bs.FillColor.String(), drawing.ColorBlack.String())\n}\n\nfunc TestChartGetCanvasStyle(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tCanvas: Style{\n\t\t\tFillColor: drawing.ColorBlack,\n\t\t},\n\t}\n\n\tbs := c.getCanvasStyle()\n\ttestutil.AssertEqual(t, bs.FillColor.String(), drawing.ColorBlack.String())\n}\n\nfunc TestChartGetDefaultCanvasBox(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{}\n\tcanvasBoxDefault := c.getDefaultCanvasBox()\n\ttestutil.AssertFalse(t, canvasBoxDefault.IsZero())\n\ttestutil.AssertEqual(t, DefaultBackgroundPadding.Top, canvasBoxDefault.Top)\n\ttestutil.AssertEqual(t, DefaultBackgroundPadding.Left, canvasBoxDefault.Left)\n\ttestutil.AssertEqual(t, c.GetWidth()-DefaultBackgroundPadding.Right, canvasBoxDefault.Right)\n\ttestutil.AssertEqual(t, c.GetHeight()-DefaultBackgroundPadding.Bottom, canvasBoxDefault.Bottom)\n\n\tcustom := Chart{\n\t\tBackground: Style{\n\t\t\tPadding: Box{\n\t\t\t\tTop:    DefaultBackgroundPadding.Top + 1,\n\t\t\t\tLeft:   DefaultBackgroundPadding.Left + 1,\n\t\t\t\tRight:  DefaultBackgroundPadding.Right + 1,\n\t\t\t\tBottom: DefaultBackgroundPadding.Bottom + 1,\n\t\t\t},\n\t\t},\n\t}\n\tcanvasBoxCustom := custom.getDefaultCanvasBox()\n\ttestutil.AssertFalse(t, canvasBoxCustom.IsZero())\n\ttestutil.AssertEqual(t, DefaultBackgroundPadding.Top+1, canvasBoxCustom.Top)\n\ttestutil.AssertEqual(t, DefaultBackgroundPadding.Left+1, canvasBoxCustom.Left)\n\ttestutil.AssertEqual(t, c.GetWidth()-(DefaultBackgroundPadding.Right+1), canvasBoxCustom.Right)\n\ttestutil.AssertEqual(t, c.GetHeight()-(DefaultBackgroundPadding.Bottom+1), canvasBoxCustom.Bottom)\n}\n\nfunc TestChartGetValueFormatters(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{-2.0, -1.0, 0, 1.0, 2.0},\n\t\t\t\tYValues: []float64{1.0, 2.0, 3.0, 4.0, 4.5},\n\t\t\t},\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tYValues: []float64{-2.1, -1.0, 0, 1.0, 2.0},\n\t\t\t},\n\t\t\tContinuousSeries{\n\t\t\t\tYAxis:   YAxisSecondary,\n\t\t\t\tXValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tYValues: []float64{10.0, 11.0, 12.0, 13.0, 14.0},\n\t\t\t},\n\t\t},\n\t}\n\n\tdxf, dyf, dyaf := c.getValueFormatters()\n\ttestutil.AssertNotNil(t, dxf)\n\ttestutil.AssertNotNil(t, dyf)\n\ttestutil.AssertNotNil(t, dyaf)\n}\n\nfunc TestChartHasAxes(t *testing.T) {\n\t// replaced new assertions helper\n\n\ttestutil.AssertTrue(t, Chart{}.hasAxes())\n\ttestutil.AssertFalse(t, Chart{XAxis: XAxis{Style: Hidden()}, YAxis: YAxis{Style: Hidden()}, YAxisSecondary: YAxis{Style: Hidden()}}.hasAxes())\n\n\tx := Chart{\n\t\tXAxis: XAxis{\n\t\t\tStyle: Hidden(),\n\t\t},\n\t\tYAxis: YAxis{\n\t\t\tStyle: Shown(),\n\t\t},\n\t\tYAxisSecondary: YAxis{\n\t\t\tStyle: Hidden(),\n\t\t},\n\t}\n\ttestutil.AssertTrue(t, x.hasAxes())\n\n\ty := Chart{\n\t\tXAxis: XAxis{\n\t\t\tStyle: Shown(),\n\t\t},\n\t\tYAxis: YAxis{\n\t\t\tStyle: Hidden(),\n\t\t},\n\t\tYAxisSecondary: YAxis{\n\t\t\tStyle: Hidden(),\n\t\t},\n\t}\n\ttestutil.AssertTrue(t, y.hasAxes())\n\n\tya := Chart{\n\t\tXAxis: XAxis{\n\t\t\tStyle: Hidden(),\n\t\t},\n\t\tYAxis: YAxis{\n\t\t\tStyle: Hidden(),\n\t\t},\n\t\tYAxisSecondary: YAxis{\n\t\t\tStyle: Shown(),\n\t\t},\n\t}\n\ttestutil.AssertTrue(t, ya.hasAxes())\n}\n\nfunc TestChartGetAxesTicks(t *testing.T) {\n\t// replaced new assertions helper\n\n\tr, err := PNG(1024, 1024)\n\ttestutil.AssertNil(t, err)\n\n\tc := Chart{\n\t\tXAxis: XAxis{\n\t\t\tRange: &ContinuousRange{Min: 9.8, Max: 19.8},\n\t\t},\n\t\tYAxis: YAxis{\n\t\t\tRange: &ContinuousRange{Min: 9.9, Max: 19.9},\n\t\t},\n\t\tYAxisSecondary: YAxis{\n\t\t\tRange: &ContinuousRange{Min: 9.7, Max: 19.7},\n\t\t},\n\t}\n\txr, yr, yar := c.getRanges()\n\n\txt, yt, yat := c.getAxesTicks(r, xr, yr, yar, FloatValueFormatter, FloatValueFormatter, FloatValueFormatter)\n\ttestutil.AssertNotEmpty(t, xt)\n\ttestutil.AssertNotEmpty(t, yt)\n\ttestutil.AssertNotEmpty(t, yat)\n}\n\nfunc TestChartSingleSeries(t *testing.T) {\n\t// replaced new assertions helper\n\tnow := time.Now()\n\tc := Chart{\n\t\tTitle:  \"Hello!\",\n\t\tWidth:  1024,\n\t\tHeight: 400,\n\t\tYAxis: YAxis{\n\t\t\tRange: &ContinuousRange{\n\t\t\t\tMin: 0.0,\n\t\t\t\tMax: 4.0,\n\t\t\t},\n\t\t},\n\t\tSeries: []Series{\n\t\t\tTimeSeries{\n\t\t\t\tName:    \"goog\",\n\t\t\t\tXValues: []time.Time{now.AddDate(0, 0, -3), now.AddDate(0, 0, -2), now.AddDate(0, 0, -1)},\n\t\t\t\tYValues: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t},\n\t}\n\n\tbuffer := bytes.NewBuffer([]byte{})\n\tc.Render(PNG, buffer)\n\ttestutil.AssertNotEmpty(t, buffer.Bytes())\n}\n\nfunc TestChartRegressionBadRanges(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\t\tYValues: []float64{1.0, 2.0, 3.0, 4.0, 4.5},\n\t\t\t},\n\t\t},\n\t}\n\tbuffer := bytes.NewBuffer([]byte{})\n\tc.Render(PNG, buffer)\n\ttestutil.AssertTrue(t, true, \"Render needs to finish.\")\n}\n\nfunc TestChartRegressionBadRangesByUser(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tYAxis: YAxis{\n\t\t\tRange: &ContinuousRange{\n\t\t\t\tMin: math.Inf(-1),\n\t\t\t\tMax: math.Inf(1), // this could really happen? eh.\n\t\t\t},\n\t\t},\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: LinearRange(1.0, 10.0),\n\t\t\t\tYValues: LinearRange(1.0, 10.0),\n\t\t\t},\n\t\t},\n\t}\n\tbuffer := bytes.NewBuffer([]byte{})\n\tc.Render(PNG, buffer)\n\ttestutil.AssertTrue(t, true, \"Render needs to finish.\")\n}\n\nfunc TestChartValidatesSeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: LinearRange(1.0, 10.0),\n\t\t\t\tYValues: LinearRange(1.0, 10.0),\n\t\t\t},\n\t\t},\n\t}\n\n\ttestutil.AssertNil(t, c.validateSeries())\n\n\tc = Chart{\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: LinearRange(1.0, 10.0),\n\t\t\t},\n\t\t},\n\t}\n\n\ttestutil.AssertNotNil(t, c.validateSeries())\n}\n\nfunc TestChartCheckRanges(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{1.0, 2.0},\n\t\t\t\tYValues: []float64{3.10, 3.14},\n\t\t\t},\n\t\t},\n\t}\n\n\txr, yr, yra := c.getRanges()\n\ttestutil.AssertNil(t, c.checkRanges(xr, yr, yra))\n}\n\nfunc TestChartCheckRangesWithRanges(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tXAxis: XAxis{\n\t\t\tRange: &ContinuousRange{\n\t\t\t\tMin: 0,\n\t\t\t\tMax: 10,\n\t\t\t},\n\t\t},\n\t\tYAxis: YAxis{\n\t\t\tRange: &ContinuousRange{\n\t\t\t\tMin: 0,\n\t\t\t\tMax: 5,\n\t\t\t},\n\t\t},\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: []float64{1.0, 2.0},\n\t\t\t\tYValues: []float64{3.14, 3.14},\n\t\t\t},\n\t\t},\n\t}\n\n\txr, yr, yra := c.getRanges()\n\ttestutil.AssertNil(t, c.checkRanges(xr, yr, yra))\n}\n\nfunc at(i image.Image, x, y int) drawing.Color {\n\treturn drawing.ColorFromAlphaMixedRGBA(i.At(x, y).RGBA())\n}\n\nfunc TestChartE2ELine(t *testing.T) {\n\t// replaced new assertions helper\n\n\tc := Chart{\n\t\tHeight:         50,\n\t\tWidth:          50,\n\t\tTitleStyle:     Hidden(),\n\t\tXAxis:          HideXAxis(),\n\t\tYAxis:          HideYAxis(),\n\t\tYAxisSecondary: HideYAxis(),\n\t\tCanvas: Style{\n\t\t\tPadding: BoxZero,\n\t\t},\n\t\tBackground: Style{\n\t\t\tPadding: BoxZero,\n\t\t},\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tXValues: LinearRangeWithStep(0, 4, 1),\n\t\t\t\tYValues: LinearRangeWithStep(0, 4, 1),\n\t\t\t},\n\t\t},\n\t}\n\n\tvar buffer = &bytes.Buffer{}\n\terr := c.Render(PNG, buffer)\n\ttestutil.AssertNil(t, err)\n\n\t// do color tests ...\n\n\ti, err := png.Decode(buffer)\n\ttestutil.AssertNil(t, err)\n\n\t// test the bottom and top of the line\n\ttestutil.AssertEqual(t, drawing.ColorWhite, at(i, 0, 0))\n\ttestutil.AssertEqual(t, drawing.ColorWhite, at(i, 49, 49))\n\n\t// test a line mid point\n\tdefaultSeriesColor := GetDefaultColor(0)\n\ttestutil.AssertEqual(t, defaultSeriesColor, at(i, 0, 49))\n\ttestutil.AssertEqual(t, defaultSeriesColor, at(i, 49, 0))\n\ttestutil.AssertEqual(t, drawing.ColorFromHex(\"bddbf6\"), at(i, 24, 24))\n}\n\nfunc TestChartE2ELineWithFill(t *testing.T) {\n\t// replaced new assertions helper\n\n\tlogBuffer := new(bytes.Buffer)\n\n\tc := Chart{\n\t\tHeight: 50,\n\t\tWidth:  50,\n\t\tCanvas: Style{\n\t\t\tPadding: BoxZero,\n\t\t},\n\t\tBackground: Style{\n\t\t\tPadding: BoxZero,\n\t\t},\n\t\tTitleStyle:     Hidden(),\n\t\tXAxis:          HideXAxis(),\n\t\tYAxis:          HideYAxis(),\n\t\tYAxisSecondary: HideYAxis(),\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tStyle: Style{\n\t\t\t\t\tStrokeColor: drawing.ColorBlue,\n\t\t\t\t\tFillColor:   drawing.ColorRed,\n\t\t\t\t},\n\t\t\t\tXValues: LinearRangeWithStep(0, 4, 1),\n\t\t\t\tYValues: LinearRangeWithStep(0, 4, 1),\n\t\t\t},\n\t\t},\n\t\tLog: NewLogger(OptLoggerStdout(logBuffer), OptLoggerStderr(logBuffer)),\n\t}\n\n\ttestutil.AssertEqual(t, 5, len(c.Series[0].(ContinuousSeries).XValues))\n\ttestutil.AssertEqual(t, 5, len(c.Series[0].(ContinuousSeries).YValues))\n\n\tvar buffer = &bytes.Buffer{}\n\terr := c.Render(PNG, buffer)\n\ttestutil.AssertNil(t, err)\n\n\ti, err := png.Decode(buffer)\n\ttestutil.AssertNil(t, err)\n\n\t// test the bottom and top of the line\n\ttestutil.AssertEqual(t, drawing.ColorWhite, at(i, 0, 0))\n\ttestutil.AssertEqual(t, drawing.ColorRed, at(i, 49, 49))\n\n\t// test a line mid point\n\tdefaultSeriesColor := drawing.ColorBlue\n\ttestutil.AssertEqual(t, defaultSeriesColor, at(i, 0, 49))\n\ttestutil.AssertEqual(t, defaultSeriesColor, at(i, 49, 0))\n}\n\nfunc Test_Chart_cve(t *testing.T) {\n\tpoc := StackedBarChart{\n\t\tTitle: \"poc\",\n\t\tBars: []StackedBar{\n\t\t\t{\n\t\t\t\tName: \"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\",\n\t\t\t\tValues: []Value{\n\t\t\t\t\t{Value: 1, Label: \"infinite\"},\n\t\t\t\t\t{Value: 1, Label: \"loop\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tvar imgContent bytes.Buffer\n\terr := poc.Render(PNG, &imgContent)\n\ttestutil.AssertNotNil(t, err)\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "colors.go",
          "type": "blob",
          "size": 5.7919921875,
          "content": "package chart\n\nimport \"github.com/wcharczuk/go-chart/v2/drawing\"\n\nvar (\n\t// ColorWhite is white.\n\tColorWhite = drawing.Color{R: 255, G: 255, B: 255, A: 255}\n\t// ColorBlue is the basic theme blue color.\n\tColorBlue = drawing.Color{R: 0, G: 116, B: 217, A: 255}\n\t// ColorCyan is the basic theme cyan color.\n\tColorCyan = drawing.Color{R: 0, G: 217, B: 210, A: 255}\n\t// ColorGreen is the basic theme green color.\n\tColorGreen = drawing.Color{R: 0, G: 217, B: 101, A: 255}\n\t// ColorRed is the basic theme red color.\n\tColorRed = drawing.Color{R: 217, G: 0, B: 116, A: 255}\n\t// ColorOrange is the basic theme orange color.\n\tColorOrange = drawing.Color{R: 217, G: 101, B: 0, A: 255}\n\t// ColorYellow is the basic theme yellow color.\n\tColorYellow = drawing.Color{R: 217, G: 210, B: 0, A: 255}\n\t// ColorBlack is the basic theme black color.\n\tColorBlack = drawing.Color{R: 51, G: 51, B: 51, A: 255}\n\t// ColorLightGray is the basic theme light gray color.\n\tColorLightGray = drawing.Color{R: 239, G: 239, B: 239, A: 255}\n\n\t// ColorAlternateBlue is a alternate theme color.\n\tColorAlternateBlue = drawing.Color{R: 106, G: 195, B: 203, A: 255}\n\t// ColorAlternateGreen is a alternate theme color.\n\tColorAlternateGreen = drawing.Color{R: 42, G: 190, B: 137, A: 255}\n\t// ColorAlternateGray is a alternate theme color.\n\tColorAlternateGray = drawing.Color{R: 110, G: 128, B: 139, A: 255}\n\t// ColorAlternateYellow is a alternate theme color.\n\tColorAlternateYellow = drawing.Color{R: 240, G: 174, B: 90, A: 255}\n\t// ColorAlternateLightGray is a alternate theme color.\n\tColorAlternateLightGray = drawing.Color{R: 187, G: 190, B: 191, A: 255}\n\n\t// ColorTransparent is a transparent (alpha zero) color.\n\tColorTransparent = drawing.Color{R: 1, G: 1, B: 1, A: 0}\n)\n\nvar (\n\t// DefaultBackgroundColor is the default chart background color.\n\t// It is equivalent to css color:white.\n\tDefaultBackgroundColor = ColorWhite\n\t// DefaultBackgroundStrokeColor is the default chart border color.\n\t// It is equivalent to color:white.\n\tDefaultBackgroundStrokeColor = ColorWhite\n\t// DefaultCanvasColor is the default chart canvas color.\n\t// It is equivalent to css color:white.\n\tDefaultCanvasColor = ColorWhite\n\t// DefaultCanvasStrokeColor is the default chart canvas stroke color.\n\t// It is equivalent to css color:white.\n\tDefaultCanvasStrokeColor = ColorWhite\n\t// DefaultTextColor is the default chart text color.\n\t// It is equivalent to #333333.\n\tDefaultTextColor = ColorBlack\n\t// DefaultAxisColor is the default chart axis line color.\n\t// It is equivalent to #333333.\n\tDefaultAxisColor = ColorBlack\n\t// DefaultStrokeColor is the default chart border color.\n\t// It is equivalent to #efefef.\n\tDefaultStrokeColor = ColorLightGray\n\t// DefaultFillColor is the default fill color.\n\t// It is equivalent to #0074d9.\n\tDefaultFillColor = ColorBlue\n\t// DefaultAnnotationFillColor is the default annotation background color.\n\tDefaultAnnotationFillColor = ColorWhite\n\t// DefaultGridLineColor is the default grid line color.\n\tDefaultGridLineColor = ColorLightGray\n)\n\nvar (\n\t// DefaultColors are a couple default series colors.\n\tDefaultColors = []drawing.Color{\n\t\tColorBlue,\n\t\tColorGreen,\n\t\tColorRed,\n\t\tColorCyan,\n\t\tColorOrange,\n\t}\n\n\t// DefaultAlternateColors are a couple alternate colors.\n\tDefaultAlternateColors = []drawing.Color{\n\t\tColorAlternateBlue,\n\t\tColorAlternateGreen,\n\t\tColorAlternateGray,\n\t\tColorAlternateYellow,\n\t\tColorBlue,\n\t\tColorGreen,\n\t\tColorRed,\n\t\tColorCyan,\n\t\tColorOrange,\n\t}\n)\n\n// GetDefaultColor returns a color from the default list by index.\n// NOTE: the index will wrap around (using a modulo).\nfunc GetDefaultColor(index int) drawing.Color {\n\tfinalIndex := index % len(DefaultColors)\n\treturn DefaultColors[finalIndex]\n}\n\n// GetAlternateColor returns a color from the default list by index.\n// NOTE: the index will wrap around (using a modulo).\nfunc GetAlternateColor(index int) drawing.Color {\n\tfinalIndex := index % len(DefaultAlternateColors)\n\treturn DefaultAlternateColors[finalIndex]\n}\n\n// ColorPalette is a set of colors that.\ntype ColorPalette interface {\n\tBackgroundColor() drawing.Color\n\tBackgroundStrokeColor() drawing.Color\n\tCanvasColor() drawing.Color\n\tCanvasStrokeColor() drawing.Color\n\tAxisStrokeColor() drawing.Color\n\tTextColor() drawing.Color\n\tGetSeriesColor(index int) drawing.Color\n}\n\n// DefaultColorPalette represents the default palatte.\nvar DefaultColorPalette defaultColorPalette\n\ntype defaultColorPalette struct{}\n\nfunc (dp defaultColorPalette) BackgroundColor() drawing.Color {\n\treturn DefaultBackgroundColor\n}\n\nfunc (dp defaultColorPalette) BackgroundStrokeColor() drawing.Color {\n\treturn DefaultBackgroundStrokeColor\n}\n\nfunc (dp defaultColorPalette) CanvasColor() drawing.Color {\n\treturn DefaultCanvasColor\n}\n\nfunc (dp defaultColorPalette) CanvasStrokeColor() drawing.Color {\n\treturn DefaultCanvasStrokeColor\n}\n\nfunc (dp defaultColorPalette) AxisStrokeColor() drawing.Color {\n\treturn DefaultAxisColor\n}\n\nfunc (dp defaultColorPalette) TextColor() drawing.Color {\n\treturn DefaultTextColor\n}\n\nfunc (dp defaultColorPalette) GetSeriesColor(index int) drawing.Color {\n\treturn GetDefaultColor(index)\n}\n\n// AlternateColorPalette represents the default palatte.\nvar AlternateColorPalette alternateColorPalette\n\ntype alternateColorPalette struct{}\n\nfunc (ap alternateColorPalette) BackgroundColor() drawing.Color {\n\treturn DefaultBackgroundColor\n}\n\nfunc (ap alternateColorPalette) BackgroundStrokeColor() drawing.Color {\n\treturn DefaultBackgroundStrokeColor\n}\n\nfunc (ap alternateColorPalette) CanvasColor() drawing.Color {\n\treturn DefaultCanvasColor\n}\n\nfunc (ap alternateColorPalette) CanvasStrokeColor() drawing.Color {\n\treturn DefaultCanvasStrokeColor\n}\n\nfunc (ap alternateColorPalette) AxisStrokeColor() drawing.Color {\n\treturn DefaultAxisColor\n}\n\nfunc (ap alternateColorPalette) TextColor() drawing.Color {\n\treturn DefaultTextColor\n}\n\nfunc (ap alternateColorPalette) GetSeriesColor(index int) drawing.Color {\n\treturn GetAlternateColor(index)\n}\n"
        },
        {
          "name": "concat_series.go",
          "type": "blob",
          "size": 0.947265625,
          "content": "package chart\n\n// ConcatSeries is a special type of series that concatenates its `InnerSeries`.\ntype ConcatSeries []Series\n\n// Len returns the length of the concatenated set of series.\nfunc (cs ConcatSeries) Len() int {\n\ttotal := 0\n\tfor _, s := range cs {\n\t\tif typed, isValuesProvider := s.(ValuesProvider); isValuesProvider {\n\t\t\ttotal += typed.Len()\n\t\t}\n\t}\n\n\treturn total\n}\n\n// GetValue returns the value at the (meta) index (i.e 0 => totalLen-1)\nfunc (cs ConcatSeries) GetValue(index int) (x, y float64) {\n\tcursor := 0\n\tfor _, s := range cs {\n\t\tif typed, isValuesProvider := s.(ValuesProvider); isValuesProvider {\n\t\t\tlen := typed.Len()\n\t\t\tif index < cursor+len {\n\t\t\t\tx, y = typed.GetValues(index - cursor) //FENCEPOSTS.\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcursor += typed.Len()\n\t\t}\n\t}\n\treturn\n}\n\n// Validate validates the series.\nfunc (cs ConcatSeries) Validate() error {\n\tvar err error\n\tfor _, s := range cs {\n\t\terr = s.Validate()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "concat_series_test.go",
          "type": "blob",
          "size": 0.806640625,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestConcatSeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\ts1 := ContinuousSeries{\n\t\tXValues: LinearRange(1.0, 10.0),\n\t\tYValues: LinearRange(1.0, 10.0),\n\t}\n\n\ts2 := ContinuousSeries{\n\t\tXValues: LinearRange(11, 20.0),\n\t\tYValues: LinearRange(10.0, 1.0),\n\t}\n\n\ts3 := ContinuousSeries{\n\t\tXValues: LinearRange(21, 30.0),\n\t\tYValues: LinearRange(1.0, 10.0),\n\t}\n\n\tcs := ConcatSeries([]Series{s1, s2, s3})\n\ttestutil.AssertEqual(t, 30, cs.Len())\n\n\tx0, y0 := cs.GetValue(0)\n\ttestutil.AssertEqual(t, 1.0, x0)\n\ttestutil.AssertEqual(t, 1.0, y0)\n\n\txm, ym := cs.GetValue(19)\n\ttestutil.AssertEqual(t, 20.0, xm)\n\ttestutil.AssertEqual(t, 1.0, ym)\n\n\txn, yn := cs.GetValue(29)\n\ttestutil.AssertEqual(t, 30.0, xn)\n\ttestutil.AssertEqual(t, 10.0, yn)\n}\n"
        },
        {
          "name": "continuous_range.go",
          "type": "blob",
          "size": 1.8876953125,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// ContinuousRange represents a boundary for a set of numbers.\ntype ContinuousRange struct {\n\tMin        float64\n\tMax        float64\n\tDomain     int\n\tDescending bool\n}\n\n// IsDescending returns if the range is descending.\nfunc (r ContinuousRange) IsDescending() bool {\n\treturn r.Descending\n}\n\n// IsZero returns if the ContinuousRange has been set or not.\nfunc (r ContinuousRange) IsZero() bool {\n\treturn (r.Min == 0 || math.IsNaN(r.Min)) &&\n\t\t(r.Max == 0 || math.IsNaN(r.Max)) &&\n\t\tr.Domain == 0\n}\n\n// GetMin gets the min value for the continuous range.\nfunc (r ContinuousRange) GetMin() float64 {\n\treturn r.Min\n}\n\n// SetMin sets the min value for the continuous range.\nfunc (r *ContinuousRange) SetMin(min float64) {\n\tr.Min = min\n}\n\n// GetMax returns the max value for the continuous range.\nfunc (r ContinuousRange) GetMax() float64 {\n\treturn r.Max\n}\n\n// SetMax sets the max value for the continuous range.\nfunc (r *ContinuousRange) SetMax(max float64) {\n\tr.Max = max\n}\n\n// GetDelta returns the difference between the min and max value.\nfunc (r ContinuousRange) GetDelta() float64 {\n\treturn r.Max - r.Min\n}\n\n// GetDomain returns the range domain.\nfunc (r ContinuousRange) GetDomain() int {\n\treturn r.Domain\n}\n\n// SetDomain sets the range domain.\nfunc (r *ContinuousRange) SetDomain(domain int) {\n\tr.Domain = domain\n}\n\n// String returns a simple string for the ContinuousRange.\nfunc (r ContinuousRange) String() string {\n\tif r.GetDelta() == 0 {\n\t\treturn \"ContinuousRange [empty]\"\n\t}\n\treturn fmt.Sprintf(\"ContinuousRange [%.2f,%.2f] => %d\", r.Min, r.Max, r.Domain)\n}\n\n// Translate maps a given value into the ContinuousRange space.\nfunc (r ContinuousRange) Translate(value float64) int {\n\tnormalized := value - r.Min\n\tratio := normalized / r.GetDelta()\n\n\tif r.IsDescending() {\n\t\treturn r.Domain - int(math.Ceil(ratio*float64(r.Domain)))\n\t}\n\n\treturn int(math.Ceil(ratio * float64(r.Domain)))\n}\n"
        },
        {
          "name": "continuous_range_test.go",
          "type": "blob",
          "size": 0.5048828125,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestRangeTranslate(t *testing.T) {\n\t// replaced new assertions helper\n\tvalues := []float64{1.0, 2.0, 2.5, 2.7, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0}\n\tr := ContinuousRange{Domain: 1000}\n\tr.Min, r.Max = MinMax(values...)\n\n\t// delta = ~7.0\n\t// value = ~5.0\n\t// domain = ~1000\n\t// 5/8 * 1000 ~=\n\ttestutil.AssertEqual(t, 0, r.Translate(1.0))\n\ttestutil.AssertEqual(t, 1000, r.Translate(8.0))\n\ttestutil.AssertEqual(t, 572, r.Translate(5.0))\n}\n"
        },
        {
          "name": "continuous_series.go",
          "type": "blob",
          "size": 2.333984375,
          "content": "package chart\n\nimport \"fmt\"\n\n// Interface Assertions.\nvar (\n\t_ Series              = (*ContinuousSeries)(nil)\n\t_ FirstValuesProvider = (*ContinuousSeries)(nil)\n\t_ LastValuesProvider  = (*ContinuousSeries)(nil)\n)\n\n// ContinuousSeries represents a line on a chart.\ntype ContinuousSeries struct {\n\tName  string\n\tStyle Style\n\n\tYAxis YAxisType\n\n\tXValueFormatter ValueFormatter\n\tYValueFormatter ValueFormatter\n\n\tXValues []float64\n\tYValues []float64\n}\n\n// GetName returns the name of the time series.\nfunc (cs ContinuousSeries) GetName() string {\n\treturn cs.Name\n}\n\n// GetStyle returns the line style.\nfunc (cs ContinuousSeries) GetStyle() Style {\n\treturn cs.Style\n}\n\n// Len returns the number of elements in the series.\nfunc (cs ContinuousSeries) Len() int {\n\treturn len(cs.XValues)\n}\n\n// GetValues gets the x,y values at a given index.\nfunc (cs ContinuousSeries) GetValues(index int) (float64, float64) {\n\treturn cs.XValues[index], cs.YValues[index]\n}\n\n// GetFirstValues gets the first x,y values.\nfunc (cs ContinuousSeries) GetFirstValues() (float64, float64) {\n\treturn cs.XValues[0], cs.YValues[0]\n}\n\n// GetLastValues gets the last x,y values.\nfunc (cs ContinuousSeries) GetLastValues() (float64, float64) {\n\treturn cs.XValues[len(cs.XValues)-1], cs.YValues[len(cs.YValues)-1]\n}\n\n// GetValueFormatters returns value formatter defaults for the series.\nfunc (cs ContinuousSeries) GetValueFormatters() (x, y ValueFormatter) {\n\tif cs.XValueFormatter != nil {\n\t\tx = cs.XValueFormatter\n\t} else {\n\t\tx = FloatValueFormatter\n\t}\n\tif cs.YValueFormatter != nil {\n\t\ty = cs.YValueFormatter\n\t} else {\n\t\ty = FloatValueFormatter\n\t}\n\treturn\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (cs ContinuousSeries) GetYAxis() YAxisType {\n\treturn cs.YAxis\n}\n\n// Render renders the series.\nfunc (cs ContinuousSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := cs.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, cs)\n}\n\n// Validate validates the series.\nfunc (cs ContinuousSeries) Validate() error {\n\tif len(cs.XValues) == 0 {\n\t\treturn fmt.Errorf(\"continuous series; must have xvalues set\")\n\t}\n\n\tif len(cs.YValues) == 0 {\n\t\treturn fmt.Errorf(\"continuous series; must have yvalues set\")\n\t}\n\n\tif len(cs.XValues) != len(cs.YValues) {\n\t\treturn fmt.Errorf(\"continuous series; must have same length xvalues as yvalues\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "continuous_series_test.go",
          "type": "blob",
          "size": 1.58984375,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestContinuousSeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\tcs := ContinuousSeries{\n\t\tName:    \"Test Series\",\n\t\tXValues: LinearRange(1.0, 10.0),\n\t\tYValues: LinearRange(1.0, 10.0),\n\t}\n\n\ttestutil.AssertEqual(t, \"Test Series\", cs.GetName())\n\ttestutil.AssertEqual(t, 10, cs.Len())\n\tx0, y0 := cs.GetValues(0)\n\ttestutil.AssertEqual(t, 1.0, x0)\n\ttestutil.AssertEqual(t, 1.0, y0)\n\n\txn, yn := cs.GetValues(9)\n\ttestutil.AssertEqual(t, 10.0, xn)\n\ttestutil.AssertEqual(t, 10.0, yn)\n\n\txn, yn = cs.GetLastValues()\n\ttestutil.AssertEqual(t, 10.0, xn)\n\ttestutil.AssertEqual(t, 10.0, yn)\n}\n\nfunc TestContinuousSeriesValueFormatter(t *testing.T) {\n\t// replaced new assertions helper\n\n\tcs := ContinuousSeries{\n\t\tXValueFormatter: func(v interface{}) string {\n\t\t\treturn fmt.Sprintf(\"%f foo\", v)\n\t\t},\n\t\tYValueFormatter: func(v interface{}) string {\n\t\t\treturn fmt.Sprintf(\"%f bar\", v)\n\t\t},\n\t}\n\n\txf, yf := cs.GetValueFormatters()\n\ttestutil.AssertEqual(t, \"0.100000 foo\", xf(0.1))\n\ttestutil.AssertEqual(t, \"0.100000 bar\", yf(0.1))\n}\n\nfunc TestContinuousSeriesValidate(t *testing.T) {\n\t// replaced new assertions helper\n\n\tcs := ContinuousSeries{\n\t\tName:    \"Test Series\",\n\t\tXValues: LinearRange(1.0, 10.0),\n\t\tYValues: LinearRange(1.0, 10.0),\n\t}\n\ttestutil.AssertNil(t, cs.Validate())\n\n\tcs = ContinuousSeries{\n\t\tName:    \"Test Series\",\n\t\tXValues: LinearRange(1.0, 10.0),\n\t}\n\ttestutil.AssertNotNil(t, cs.Validate())\n\n\tcs = ContinuousSeries{\n\t\tName:    \"Test Series\",\n\t\tYValues: LinearRange(1.0, 10.0),\n\t}\n\ttestutil.AssertNotNil(t, cs.Validate())\n}\n"
        },
        {
          "name": "defaults.go",
          "type": "blob",
          "size": 4.041015625,
          "content": "package chart\n\nconst (\n\t// DefaultChartHeight is the default chart height.\n\tDefaultChartHeight = 400\n\t// DefaultChartWidth is the default chart width.\n\tDefaultChartWidth = 1024\n\t// DefaultStrokeWidth is the default chart stroke width.\n\tDefaultStrokeWidth = 0.0\n\t// DefaultDotWidth is the default chart dot width.\n\tDefaultDotWidth = 0.0\n\t// DefaultSeriesLineWidth is the default line width.\n\tDefaultSeriesLineWidth = 1.0\n\t// DefaultAxisLineWidth is the line width of the axis lines.\n\tDefaultAxisLineWidth = 1.0\n\t//DefaultDPI is the default dots per inch for the chart.\n\tDefaultDPI = 92.0\n\t// DefaultMinimumFontSize is the default minimum font size.\n\tDefaultMinimumFontSize = 8.0\n\t// DefaultFontSize is the default font size.\n\tDefaultFontSize = 10.0\n\t// DefaultTitleFontSize is the default title font size.\n\tDefaultTitleFontSize = 18.0\n\t// DefaultAnnotationDeltaWidth is the width of the left triangle out of annotations.\n\tDefaultAnnotationDeltaWidth = 10\n\t// DefaultAnnotationFontSize is the font size of annotations.\n\tDefaultAnnotationFontSize = 10.0\n\t// DefaultAxisFontSize is the font size of the axis labels.\n\tDefaultAxisFontSize = 10.0\n\t// DefaultTitleTop is the default distance from the top of the chart to put the title.\n\tDefaultTitleTop = 10\n\n\t// DefaultBackgroundStrokeWidth is the default stroke on the chart background.\n\tDefaultBackgroundStrokeWidth = 0.0\n\t// DefaultCanvasStrokeWidth is the default stroke on the chart canvas.\n\tDefaultCanvasStrokeWidth = 0.0\n\n\t// DefaultLineSpacing is the default vertical distance between lines of text.\n\tDefaultLineSpacing = 5\n\n\t// DefaultYAxisMargin is the default distance from the right of the canvas to the y axis labels.\n\tDefaultYAxisMargin = 10\n\t// DefaultXAxisMargin is the default distance from bottom of the canvas to the x axis labels.\n\tDefaultXAxisMargin = 10\n\n\t//DefaultVerticalTickHeight is half the margin.\n\tDefaultVerticalTickHeight = DefaultXAxisMargin >> 1\n\t//DefaultHorizontalTickWidth is half the margin.\n\tDefaultHorizontalTickWidth = DefaultYAxisMargin >> 1\n\n\t// DefaultTickCount is the default number of ticks to show\n\tDefaultTickCount = 10\n\t// DefaultTickCountSanityCheck is a hard limit on number of ticks to prevent infinite loops.\n\tDefaultTickCountSanityCheck = 1 << 10 //1024\n\n\t// DefaultMinimumTickHorizontalSpacing is the minimum distance between horizontal ticks.\n\tDefaultMinimumTickHorizontalSpacing = 20\n\t// DefaultMinimumTickVerticalSpacing is the minimum distance between vertical ticks.\n\tDefaultMinimumTickVerticalSpacing = 20\n\n\t// DefaultDateFormat is the default date format.\n\tDefaultDateFormat = \"2006-01-02\"\n\t// DefaultDateHourFormat is the date format for hour timestamp formats.\n\tDefaultDateHourFormat = \"01-02 3PM\"\n\t// DefaultDateMinuteFormat is the date format for minute range timestamp formats.\n\tDefaultDateMinuteFormat = \"01-02 3:04PM\"\n\t// DefaultFloatFormat is the default float format.\n\tDefaultFloatFormat = \"%.2f\"\n\t// DefaultPercentValueFormat is the default percent format.\n\tDefaultPercentValueFormat = \"%0.2f%%\"\n\n\t// DefaultBarSpacing is the default pixel spacing between bars.\n\tDefaultBarSpacing = 100\n\t// DefaultBarWidth is the default pixel width of bars in a bar chart.\n\tDefaultBarWidth = 50\n)\n\nvar (\n\t// DashArrayDots is a dash array that represents '....' style stroke dashes.\n\tDashArrayDots = []int{1, 1}\n\t// DashArrayDashesSmall is a dash array that represents '- - -' style stroke dashes.\n\tDashArrayDashesSmall = []int{3, 3}\n\t// DashArrayDashesMedium is a dash array that represents '-- -- --' style stroke dashes.\n\tDashArrayDashesMedium = []int{5, 5}\n\t// DashArrayDashesLarge is a dash array that represents '----- ----- -----' style stroke dashes.\n\tDashArrayDashesLarge = []int{10, 10}\n)\n\nvar (\n\t// DefaultAnnotationPadding is the padding around an annotation.\n\tDefaultAnnotationPadding = Box{Top: 5, Left: 5, Right: 5, Bottom: 5}\n\n\t// DefaultBackgroundPadding is the default canvas padding config.\n\tDefaultBackgroundPadding = Box{Top: 5, Left: 5, Right: 5, Bottom: 5}\n)\n\nconst (\n\t// ContentTypePNG is the png mime type.\n\tContentTypePNG = \"image/png\"\n\n\t// ContentTypeSVG is the svg mime type.\n\tContentTypeSVG = \"image/svg+xml\"\n)\n"
        },
        {
          "name": "donut_chart.go",
          "type": "blob",
          "size": 7.5634765625,
          "content": "package chart\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/golang/freetype/truetype\"\n)\n\n// DonutChart is a chart that draws sections of a circle based on percentages with an hole.\ntype DonutChart struct {\n\tTitle      string\n\tTitleStyle Style\n\n\tColorPalette ColorPalette\n\n\tWidth  int\n\tHeight int\n\tDPI    float64\n\n\tBackground Style\n\tCanvas     Style\n\tSliceStyle Style\n\n\tFont        *truetype.Font\n\tdefaultFont *truetype.Font\n\n\tValues   []Value\n\tElements []Renderable\n}\n\n// GetDPI returns the dpi for the chart.\nfunc (pc DonutChart) GetDPI(defaults ...float64) float64 {\n\tif pc.DPI == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn DefaultDPI\n\t}\n\treturn pc.DPI\n}\n\n// GetFont returns the text font.\nfunc (pc DonutChart) GetFont() *truetype.Font {\n\tif pc.Font == nil {\n\t\treturn pc.defaultFont\n\t}\n\treturn pc.Font\n}\n\n// GetWidth returns the chart width or the default value.\nfunc (pc DonutChart) GetWidth() int {\n\tif pc.Width == 0 {\n\t\treturn DefaultChartWidth\n\t}\n\treturn pc.Width\n}\n\n// GetHeight returns the chart height or the default value.\nfunc (pc DonutChart) GetHeight() int {\n\tif pc.Height == 0 {\n\t\treturn DefaultChartWidth\n\t}\n\treturn pc.Height\n}\n\n// Render renders the chart with the given renderer to the given io.Writer.\nfunc (pc DonutChart) Render(rp RendererProvider, w io.Writer) error {\n\tif len(pc.Values) == 0 {\n\t\treturn errors.New(\"please provide at least one value\")\n\t}\n\n\tr, err := rp(pc.GetWidth(), pc.GetHeight())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif pc.Font == nil {\n\t\tdefaultFont, err := GetDefaultFont()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpc.defaultFont = defaultFont\n\t}\n\tr.SetDPI(pc.GetDPI(DefaultDPI))\n\n\tcanvasBox := pc.getDefaultCanvasBox()\n\tcanvasBox = pc.getCircleAdjustedCanvasBox(canvasBox)\n\n\tpc.drawBackground(r)\n\tpc.drawCanvas(r, canvasBox)\n\n\tfinalValues, err := pc.finalizeValues(pc.Values)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpc.drawSlices(r, canvasBox, finalValues)\n\tpc.drawTitle(r)\n\tfor _, a := range pc.Elements {\n\t\ta(r, canvasBox, pc.styleDefaultsElements())\n\t}\n\n\treturn r.Save(w)\n}\n\nfunc (pc DonutChart) drawBackground(r Renderer) {\n\tDraw.Box(r, Box{\n\t\tRight:  pc.GetWidth(),\n\t\tBottom: pc.GetHeight(),\n\t}, pc.getBackgroundStyle())\n}\n\nfunc (pc DonutChart) drawCanvas(r Renderer, canvasBox Box) {\n\tDraw.Box(r, canvasBox, pc.getCanvasStyle())\n}\n\nfunc (pc DonutChart) drawTitle(r Renderer) {\n\tif len(pc.Title) > 0 && !pc.TitleStyle.Hidden {\n\t\tDraw.TextWithin(r, pc.Title, pc.Box(), pc.styleDefaultsTitle())\n\t}\n}\n\nfunc (pc DonutChart) drawSlices(r Renderer, canvasBox Box, values []Value) {\n\tcx, cy := canvasBox.Center()\n\tdiameter := MinInt(canvasBox.Width(), canvasBox.Height())\n\tradius := float64(diameter>>1) / 1.1\n\tlabelRadius := (radius * 2.83) / 3.0\n\n\t// draw the donut slices\n\tvar rads, delta, delta2, total float64\n\tvar lx, ly int\n\n\tif len(values) == 1 {\n\t\tpc.styleDonutChartValue(0).WriteToRenderer(r)\n\t\tr.MoveTo(cx, cy)\n\t\tr.Circle(radius, cx, cy)\n\t} else {\n\t\tfor index, v := range values {\n\t\t\tv.Style.InheritFrom(pc.styleDonutChartValue(index)).WriteToRenderer(r)\n\t\t\tr.MoveTo(cx, cy)\n\t\t\trads = PercentToRadians(total)\n\t\t\tdelta = PercentToRadians(v.Value)\n\n\t\t\tr.ArcTo(cx, cy, (radius / 1.25), (radius / 1.25), rads, delta)\n\n\t\t\tr.LineTo(cx, cy)\n\t\t\tr.Close()\n\t\t\tr.FillStroke()\n\t\t\ttotal = total + v.Value\n\t\t}\n\t}\n\n\t//making the donut hole\n\tv := Value{Value: 100, Label: \"center\"}\n\tstyletemp := pc.SliceStyle.InheritFrom(Style{\n\t\tStrokeColor: ColorWhite, StrokeWidth: 4.0, FillColor: ColorWhite, FontColor: ColorWhite, //Font:        pc.GetFont(),//FontSize:    pc.getScaledFontSize(),\n\t})\n\tv.Style.InheritFrom(styletemp).WriteToRenderer(r)\n\tr.MoveTo(cx, cy)\n\tr.ArcTo(cx, cy, (radius / 3.5), (radius / 3.5), DegreesToRadians(0), DegreesToRadians(359))\n\tr.LineTo(cx, cy)\n\tr.Close()\n\tr.FillStroke()\n\n\t// draw the labels\n\ttotal = 0\n\tfor index, v := range values {\n\t\tv.Style.InheritFrom(pc.styleDonutChartValue(index)).WriteToRenderer(r)\n\t\tif len(v.Label) > 0 {\n\t\t\tdelta2 = PercentToRadians(total + (v.Value / 2.0))\n\t\t\tdelta2 = RadianAdd(delta2, _pi2)\n\t\t\tlx, ly = CirclePoint(cx, cy, labelRadius, delta2)\n\n\t\t\ttb := r.MeasureText(v.Label)\n\t\t\tlx = lx - (tb.Width() >> 1)\n\t\t\tly = ly + (tb.Height() >> 1)\n\n\t\t\tr.Text(v.Label, lx, ly)\n\t\t}\n\t\ttotal = total + v.Value\n\t}\n}\n\nfunc (pc DonutChart) finalizeValues(values []Value) ([]Value, error) {\n\tfinalValues := Values(values).Normalize()\n\tif len(finalValues) == 0 {\n\t\treturn nil, fmt.Errorf(\"donut chart must contain at least (1) non-zero value\")\n\t}\n\treturn finalValues, nil\n}\n\nfunc (pc DonutChart) getDefaultCanvasBox() Box {\n\treturn pc.Box()\n}\n\nfunc (pc DonutChart) getCircleAdjustedCanvasBox(canvasBox Box) Box {\n\tcircleDiameter := MinInt(canvasBox.Width(), canvasBox.Height())\n\n\tsquare := Box{\n\t\tRight:  circleDiameter,\n\t\tBottom: circleDiameter,\n\t}\n\n\treturn canvasBox.Fit(square)\n}\n\nfunc (pc DonutChart) getBackgroundStyle() Style {\n\treturn pc.Background.InheritFrom(pc.styleDefaultsBackground())\n}\n\nfunc (pc DonutChart) getCanvasStyle() Style {\n\treturn pc.Canvas.InheritFrom(pc.styleDefaultsCanvas())\n}\n\nfunc (pc DonutChart) styleDefaultsCanvas() Style {\n\treturn Style{\n\t\tFillColor:   pc.GetColorPalette().CanvasColor(),\n\t\tStrokeColor: pc.GetColorPalette().CanvasStrokeColor(),\n\t\tStrokeWidth: DefaultStrokeWidth,\n\t}\n}\n\nfunc (pc DonutChart) styleDefaultsDonutChartValue() Style {\n\treturn Style{\n\t\tStrokeColor: pc.GetColorPalette().TextColor(),\n\t\tStrokeWidth: 4.0,\n\t\tFillColor:   pc.GetColorPalette().TextColor(),\n\t}\n}\n\nfunc (pc DonutChart) styleDonutChartValue(index int) Style {\n\treturn pc.SliceStyle.InheritFrom(Style{\n\t\tStrokeColor: ColorWhite,\n\t\tStrokeWidth: 4.0,\n\t\tFillColor:   pc.GetColorPalette().GetSeriesColor(index),\n\t\tFontSize:    pc.getScaledFontSize(),\n\t\tFontColor:   pc.GetColorPalette().TextColor(),\n\t\tFont:        pc.GetFont(),\n\t})\n}\n\nfunc (pc DonutChart) getScaledFontSize() float64 {\n\teffectiveDimension := MinInt(pc.GetWidth(), pc.GetHeight())\n\tif effectiveDimension >= 2048 {\n\t\treturn 48.0\n\t} else if effectiveDimension >= 1024 {\n\t\treturn 24.0\n\t} else if effectiveDimension > 512 {\n\t\treturn 18.0\n\t} else if effectiveDimension > 256 {\n\t\treturn 12.0\n\t}\n\treturn 10.0\n}\n\nfunc (pc DonutChart) styleDefaultsBackground() Style {\n\treturn Style{\n\t\tFillColor:   pc.GetColorPalette().BackgroundColor(),\n\t\tStrokeColor: pc.GetColorPalette().BackgroundStrokeColor(),\n\t\tStrokeWidth: DefaultStrokeWidth,\n\t}\n}\n\nfunc (pc DonutChart) styleDefaultsElements() Style {\n\treturn Style{\n\t\tFont: pc.GetFont(),\n\t}\n}\n\nfunc (pc DonutChart) styleDefaultsTitle() Style {\n\treturn pc.TitleStyle.InheritFrom(Style{\n\t\tFontColor:           pc.GetColorPalette().TextColor(),\n\t\tFont:                pc.GetFont(),\n\t\tFontSize:            pc.getTitleFontSize(),\n\t\tTextHorizontalAlign: TextHorizontalAlignCenter,\n\t\tTextVerticalAlign:   TextVerticalAlignTop,\n\t\tTextWrap:            TextWrapWord,\n\t})\n}\n\nfunc (pc DonutChart) getTitleFontSize() float64 {\n\teffectiveDimension := MinInt(pc.GetWidth(), pc.GetHeight())\n\tif effectiveDimension >= 2048 {\n\t\treturn 48\n\t} else if effectiveDimension >= 1024 {\n\t\treturn 24\n\t} else if effectiveDimension >= 512 {\n\t\treturn 18\n\t} else if effectiveDimension >= 256 {\n\t\treturn 12\n\t}\n\treturn 10\n}\n\n// GetColorPalette returns the color palette for the chart.\nfunc (pc DonutChart) GetColorPalette() ColorPalette {\n\tif pc.ColorPalette != nil {\n\t\treturn pc.ColorPalette\n\t}\n\treturn AlternateColorPalette\n}\n\n// Box returns the chart bounds as a box.\nfunc (pc DonutChart) Box() Box {\n\tdpr := pc.Background.Padding.GetRight(DefaultBackgroundPadding.Right)\n\tdpb := pc.Background.Padding.GetBottom(DefaultBackgroundPadding.Bottom)\n\n\treturn Box{\n\t\tTop:    pc.Background.Padding.GetTop(DefaultBackgroundPadding.Top),\n\t\tLeft:   pc.Background.Padding.GetLeft(DefaultBackgroundPadding.Left),\n\t\tRight:  pc.GetWidth() - dpr,\n\t\tBottom: pc.GetHeight() - dpb,\n\t}\n}\n"
        },
        {
          "name": "donut_chart_test.go",
          "type": "blob",
          "size": 1.2724609375,
          "content": "package chart\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestDonutChart(t *testing.T) {\n\t// replaced new assertions helper\n\n\tpie := DonutChart{\n\t\tCanvas: Style{\n\t\t\tFillColor: ColorLightGray,\n\t\t},\n\t\tValues: []Value{\n\t\t\t{Value: 10, Label: \"Blue\"},\n\t\t\t{Value: 9, Label: \"Green\"},\n\t\t\t{Value: 8, Label: \"Gray\"},\n\t\t\t{Value: 7, Label: \"Orange\"},\n\t\t\t{Value: 6, Label: \"HEANG\"},\n\t\t\t{Value: 5, Label: \"??\"},\n\t\t\t{Value: 2, Label: \"!!\"},\n\t\t},\n\t}\n\n\tb := bytes.NewBuffer([]byte{})\n\tpie.Render(PNG, b)\n\ttestutil.AssertNotZero(t, b.Len())\n}\n\nfunc TestDonutChartDropsZeroValues(t *testing.T) {\n\t// replaced new assertions helper\n\n\tpie := DonutChart{\n\t\tCanvas: Style{\n\t\t\tFillColor: ColorLightGray,\n\t\t},\n\t\tValues: []Value{\n\t\t\t{Value: 5, Label: \"Blue\"},\n\t\t\t{Value: 5, Label: \"Green\"},\n\t\t\t{Value: 0, Label: \"Gray\"},\n\t\t},\n\t}\n\n\tb := bytes.NewBuffer([]byte{})\n\terr := pie.Render(PNG, b)\n\ttestutil.AssertNil(t, err)\n}\n\nfunc TestDonutChartAllZeroValues(t *testing.T) {\n\t// replaced new assertions helper\n\n\tpie := DonutChart{\n\t\tCanvas: Style{\n\t\t\tFillColor: ColorLightGray,\n\t\t},\n\t\tValues: []Value{\n\t\t\t{Value: 0, Label: \"Blue\"},\n\t\t\t{Value: 0, Label: \"Green\"},\n\t\t\t{Value: 0, Label: \"Gray\"},\n\t\t},\n\t}\n\n\tb := bytes.NewBuffer([]byte{})\n\terr := pie.Render(PNG, b)\n\ttestutil.AssertNotNil(t, err)\n}\n"
        },
        {
          "name": "draw.go",
          "type": "blob",
          "size": 8.0859375,
          "content": "package chart\n\nimport (\n\t\"math\"\n)\n\nvar (\n\t// Draw contains helpers for drawing common objects.\n\tDraw = &draw{}\n)\n\ntype draw struct{}\n\n// LineSeries draws a line series with a renderer.\nfunc (d draw) LineSeries(r Renderer, canvasBox Box, xrange, yrange Range, style Style, vs ValuesProvider) {\n\tif vs.Len() == 0 {\n\t\treturn\n\t}\n\n\tcb := canvasBox.Bottom\n\tcl := canvasBox.Left\n\n\tv0x, v0y := vs.GetValues(0)\n\tx0 := cl + xrange.Translate(v0x)\n\ty0 := cb - yrange.Translate(v0y)\n\n\tyv0 := yrange.Translate(0)\n\n\tvar vx, vy float64\n\tvar x, y int\n\n\tif style.ShouldDrawStroke() && style.ShouldDrawFill() {\n\t\tstyle.GetFillOptions().WriteDrawingOptionsToRenderer(r)\n\t\tr.MoveTo(x0, y0)\n\t\tfor i := 1; i < vs.Len(); i++ {\n\t\t\tvx, vy = vs.GetValues(i)\n\t\t\tx = cl + xrange.Translate(vx)\n\t\t\ty = cb - yrange.Translate(vy)\n\t\t\tr.LineTo(x, y)\n\t\t}\n\t\tr.LineTo(x, MinInt(cb, cb-yv0))\n\t\tr.LineTo(x0, MinInt(cb, cb-yv0))\n\t\tr.LineTo(x0, y0)\n\t\tr.Fill()\n\t}\n\n\tif style.ShouldDrawStroke() {\n\t\tstyle.GetStrokeOptions().WriteDrawingOptionsToRenderer(r)\n\n\t\tr.MoveTo(x0, y0)\n\t\tfor i := 1; i < vs.Len(); i++ {\n\t\t\tvx, vy = vs.GetValues(i)\n\t\t\tx = cl + xrange.Translate(vx)\n\t\t\ty = cb - yrange.Translate(vy)\n\t\t\tr.LineTo(x, y)\n\t\t}\n\t\tr.Stroke()\n\t}\n\n\tif style.ShouldDrawDot() {\n\t\tdefaultDotWidth := style.GetDotWidth()\n\n\t\tstyle.GetDotOptions().WriteDrawingOptionsToRenderer(r)\n\t\tfor i := 0; i < vs.Len(); i++ {\n\t\t\tvx, vy = vs.GetValues(i)\n\t\t\tx = cl + xrange.Translate(vx)\n\t\t\ty = cb - yrange.Translate(vy)\n\n\t\t\tdotWidth := defaultDotWidth\n\t\t\tif style.DotWidthProvider != nil {\n\t\t\t\tdotWidth = style.DotWidthProvider(xrange, yrange, i, vx, vy)\n\t\t\t}\n\n\t\t\tif style.DotColorProvider != nil {\n\t\t\t\tdotColor := style.DotColorProvider(xrange, yrange, i, vx, vy)\n\n\t\t\t\tr.SetFillColor(dotColor)\n\t\t\t\tr.SetStrokeColor(dotColor)\n\t\t\t}\n\n\t\t\tr.Circle(dotWidth, x, y)\n\t\t\tr.FillStroke()\n\t\t}\n\t}\n}\n\n// BoundedSeries draws a series that implements BoundedValuesProvider.\nfunc (d draw) BoundedSeries(r Renderer, canvasBox Box, xrange, yrange Range, style Style, bbs BoundedValuesProvider, drawOffsetIndexes ...int) {\n\tdrawOffsetIndex := 0\n\tif len(drawOffsetIndexes) > 0 {\n\t\tdrawOffsetIndex = drawOffsetIndexes[0]\n\t}\n\n\tcb := canvasBox.Bottom\n\tcl := canvasBox.Left\n\n\tv0x, v0y1, v0y2 := bbs.GetBoundedValues(0)\n\tx0 := cl + xrange.Translate(v0x)\n\ty0 := cb - yrange.Translate(v0y1)\n\n\tvar vx, vy1, vy2 float64\n\tvar x, y int\n\n\txvalues := make([]float64, bbs.Len())\n\txvalues[0] = v0x\n\ty2values := make([]float64, bbs.Len())\n\ty2values[0] = v0y2\n\n\tstyle.GetFillAndStrokeOptions().WriteToRenderer(r)\n\tr.MoveTo(x0, y0)\n\tfor i := 1; i < bbs.Len(); i++ {\n\t\tvx, vy1, vy2 = bbs.GetBoundedValues(i)\n\n\t\txvalues[i] = vx\n\t\ty2values[i] = vy2\n\n\t\tx = cl + xrange.Translate(vx)\n\t\ty = cb - yrange.Translate(vy1)\n\t\tif i > drawOffsetIndex {\n\t\t\tr.LineTo(x, y)\n\t\t} else {\n\t\t\tr.MoveTo(x, y)\n\t\t}\n\t}\n\ty = cb - yrange.Translate(vy2)\n\tr.LineTo(x, y)\n\tfor i := bbs.Len() - 1; i >= drawOffsetIndex; i-- {\n\t\tvx, vy2 = xvalues[i], y2values[i]\n\t\tx = cl + xrange.Translate(vx)\n\t\ty = cb - yrange.Translate(vy2)\n\t\tr.LineTo(x, y)\n\t}\n\tr.Close()\n\tr.FillStroke()\n}\n\n// HistogramSeries draws a value provider as boxes from 0.\nfunc (d draw) HistogramSeries(r Renderer, canvasBox Box, xrange, yrange Range, style Style, vs ValuesProvider, barWidths ...int) {\n\tif vs.Len() == 0 {\n\t\treturn\n\t}\n\n\t//calculate bar width?\n\tseriesLength := vs.Len()\n\tbarWidth := int(math.Floor(float64(xrange.GetDomain()) / float64(seriesLength)))\n\tif len(barWidths) > 0 {\n\t\tbarWidth = barWidths[0]\n\t}\n\n\tcb := canvasBox.Bottom\n\tcl := canvasBox.Left\n\n\t//foreach datapoint, draw a box.\n\tfor index := 0; index < seriesLength; index++ {\n\t\tvx, vy := vs.GetValues(index)\n\t\ty0 := yrange.Translate(0)\n\t\tx := cl + xrange.Translate(vx)\n\t\ty := yrange.Translate(vy)\n\n\t\td.Box(r, Box{\n\t\t\tTop:    cb - y0,\n\t\t\tLeft:   x - (barWidth >> 1),\n\t\t\tRight:  x + (barWidth >> 1),\n\t\t\tBottom: cb - y,\n\t\t}, style)\n\t}\n}\n\n// MeasureAnnotation measures how big an annotation would be.\nfunc (d draw) MeasureAnnotation(r Renderer, canvasBox Box, style Style, lx, ly int, label string) Box {\n\tstyle.WriteToRenderer(r)\n\tdefer r.ResetStyle()\n\n\ttextBox := r.MeasureText(label)\n\ttextWidth := textBox.Width()\n\ttextHeight := textBox.Height()\n\thalfTextHeight := textHeight >> 1\n\n\tpt := style.Padding.GetTop(DefaultAnnotationPadding.Top)\n\tpl := style.Padding.GetLeft(DefaultAnnotationPadding.Left)\n\tpr := style.Padding.GetRight(DefaultAnnotationPadding.Right)\n\tpb := style.Padding.GetBottom(DefaultAnnotationPadding.Bottom)\n\n\tstrokeWidth := style.GetStrokeWidth()\n\n\ttop := ly - (pt + halfTextHeight)\n\tright := lx + pl + pr + textWidth + DefaultAnnotationDeltaWidth + int(strokeWidth)\n\tbottom := ly + (pb + halfTextHeight)\n\n\treturn Box{\n\t\tTop:    top,\n\t\tLeft:   lx,\n\t\tRight:  right,\n\t\tBottom: bottom,\n\t}\n}\n\n// Annotation draws an anotation with a renderer.\nfunc (d draw) Annotation(r Renderer, canvasBox Box, style Style, lx, ly int, label string) {\n\tstyle.GetTextOptions().WriteToRenderer(r)\n\tdefer r.ResetStyle()\n\n\ttextBox := r.MeasureText(label)\n\ttextWidth := textBox.Width()\n\thalfTextHeight := textBox.Height() >> 1\n\n\tstyle.GetFillAndStrokeOptions().WriteToRenderer(r)\n\n\tpt := style.Padding.GetTop(DefaultAnnotationPadding.Top)\n\tpl := style.Padding.GetLeft(DefaultAnnotationPadding.Left)\n\tpr := style.Padding.GetRight(DefaultAnnotationPadding.Right)\n\tpb := style.Padding.GetBottom(DefaultAnnotationPadding.Bottom)\n\n\ttextX := lx + pl + DefaultAnnotationDeltaWidth\n\ttextY := ly + halfTextHeight\n\n\tltx := lx + DefaultAnnotationDeltaWidth\n\tlty := ly - (pt + halfTextHeight)\n\n\trtx := lx + pl + pr + textWidth + DefaultAnnotationDeltaWidth\n\trty := ly - (pt + halfTextHeight)\n\n\trbx := lx + pl + pr + textWidth + DefaultAnnotationDeltaWidth\n\trby := ly + (pb + halfTextHeight)\n\n\tlbx := lx + DefaultAnnotationDeltaWidth\n\tlby := ly + (pb + halfTextHeight)\n\n\tr.MoveTo(lx, ly)\n\tr.LineTo(ltx, lty)\n\tr.LineTo(rtx, rty)\n\tr.LineTo(rbx, rby)\n\tr.LineTo(lbx, lby)\n\tr.LineTo(lx, ly)\n\tr.Close()\n\tr.FillStroke()\n\n\tstyle.GetTextOptions().WriteToRenderer(r)\n\tr.Text(label, textX, textY)\n}\n\n// Box draws a box with a given style.\nfunc (d draw) Box(r Renderer, b Box, s Style) {\n\ts.GetFillAndStrokeOptions().WriteToRenderer(r)\n\tdefer r.ResetStyle()\n\n\tr.MoveTo(b.Left, b.Top)\n\tr.LineTo(b.Right, b.Top)\n\tr.LineTo(b.Right, b.Bottom)\n\tr.LineTo(b.Left, b.Bottom)\n\tr.LineTo(b.Left, b.Top)\n\tr.FillStroke()\n}\n\nfunc (d draw) BoxRotated(r Renderer, b Box, thetaDegrees float64, s Style) {\n\td.BoxCorners(r, b.Corners().Rotate(thetaDegrees), s)\n}\n\nfunc (d draw) BoxCorners(r Renderer, bc BoxCorners, s Style) {\n\ts.GetFillAndStrokeOptions().WriteToRenderer(r)\n\tdefer r.ResetStyle()\n\n\tr.MoveTo(bc.TopLeft.X, bc.TopLeft.Y)\n\tr.LineTo(bc.TopRight.X, bc.TopRight.Y)\n\tr.LineTo(bc.BottomRight.X, bc.BottomRight.Y)\n\tr.LineTo(bc.BottomLeft.X, bc.BottomLeft.Y)\n\tr.Close()\n\tr.FillStroke()\n}\n\n// DrawText draws text with a given style.\nfunc (d draw) Text(r Renderer, text string, x, y int, style Style) {\n\tstyle.GetTextOptions().WriteToRenderer(r)\n\tdefer r.ResetStyle()\n\n\tr.Text(text, x, y)\n}\n\nfunc (d draw) MeasureText(r Renderer, text string, style Style) Box {\n\tstyle.GetTextOptions().WriteToRenderer(r)\n\tdefer r.ResetStyle()\n\n\treturn r.MeasureText(text)\n}\n\n// TextWithin draws the text within a given box.\nfunc (d draw) TextWithin(r Renderer, text string, box Box, style Style) {\n\tstyle.GetTextOptions().WriteToRenderer(r)\n\tdefer r.ResetStyle()\n\n\tlines := Text.WrapFit(r, text, box.Width(), style)\n\tlinesBox := Text.MeasureLines(r, lines, style)\n\n\ty := box.Top\n\n\tswitch style.GetTextVerticalAlign() {\n\tcase TextVerticalAlignBottom, TextVerticalAlignBaseline: // i have to build better baseline handling into measure text\n\t\ty = y - linesBox.Height()\n\tcase TextVerticalAlignMiddle:\n\t\ty = y + (box.Height() >> 1) - (linesBox.Height() >> 1)\n\tcase TextVerticalAlignMiddleBaseline:\n\t\ty = y + (box.Height() >> 1) - linesBox.Height()\n\t}\n\n\tvar tx, ty int\n\tfor _, line := range lines {\n\t\tlineBox := r.MeasureText(line)\n\t\tswitch style.GetTextHorizontalAlign() {\n\t\tcase TextHorizontalAlignCenter:\n\t\t\ttx = box.Left + ((box.Width() - lineBox.Width()) >> 1)\n\t\tcase TextHorizontalAlignRight:\n\t\t\ttx = box.Right - lineBox.Width()\n\t\tdefault:\n\t\t\ttx = box.Left\n\t\t}\n\t\tif style.TextRotationDegrees == 0 {\n\t\t\tty = y + lineBox.Height()\n\t\t} else {\n\t\t\tty = y\n\t\t}\n\n\t\tr.Text(line, tx, ty)\n\t\ty += lineBox.Height() + style.GetTextLineSpacing()\n\t}\n}\n"
        },
        {
          "name": "drawing",
          "type": "tree",
          "content": null
        },
        {
          "name": "ema_series.go",
          "type": "blob",
          "size": 2.9150390625,
          "content": "package chart\n\nimport \"fmt\"\n\nconst (\n\t// DefaultEMAPeriod is the default EMA period used in the sigma calculation.\n\tDefaultEMAPeriod = 12\n)\n\n// Interface Assertions.\nvar (\n\t_ Series              = (*EMASeries)(nil)\n\t_ FirstValuesProvider = (*EMASeries)(nil)\n\t_ LastValuesProvider  = (*EMASeries)(nil)\n)\n\n// EMASeries is a computed series.\ntype EMASeries struct {\n\tName  string\n\tStyle Style\n\tYAxis YAxisType\n\n\tPeriod      int\n\tInnerSeries ValuesProvider\n\n\tcache []float64\n}\n\n// GetName returns the name of the time series.\nfunc (ema EMASeries) GetName() string {\n\treturn ema.Name\n}\n\n// GetStyle returns the line style.\nfunc (ema EMASeries) GetStyle() Style {\n\treturn ema.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (ema EMASeries) GetYAxis() YAxisType {\n\treturn ema.YAxis\n}\n\n// GetPeriod returns the window size.\nfunc (ema EMASeries) GetPeriod() int {\n\tif ema.Period == 0 {\n\t\treturn DefaultEMAPeriod\n\t}\n\treturn ema.Period\n}\n\n// Len returns the number of elements in the series.\nfunc (ema EMASeries) Len() int {\n\treturn ema.InnerSeries.Len()\n}\n\n// GetSigma returns the smoothing factor for the serise.\nfunc (ema EMASeries) GetSigma() float64 {\n\treturn 2.0 / (float64(ema.GetPeriod()) + 1)\n}\n\n// GetValues gets a value at a given index.\nfunc (ema *EMASeries) GetValues(index int) (x, y float64) {\n\tif ema.InnerSeries == nil {\n\t\treturn\n\t}\n\tif len(ema.cache) == 0 {\n\t\tema.ensureCachedValues()\n\t}\n\tvx, _ := ema.InnerSeries.GetValues(index)\n\tx = vx\n\ty = ema.cache[index]\n\treturn\n}\n\n// GetFirstValues computes the first moving average value.\nfunc (ema *EMASeries) GetFirstValues() (x, y float64) {\n\tif ema.InnerSeries == nil {\n\t\treturn\n\t}\n\tif len(ema.cache) == 0 {\n\t\tema.ensureCachedValues()\n\t}\n\tx, _ = ema.InnerSeries.GetValues(0)\n\ty = ema.cache[0]\n\treturn\n}\n\n// GetLastValues computes the last moving average value but walking back window size samples,\n// and recomputing the last moving average chunk.\nfunc (ema *EMASeries) GetLastValues() (x, y float64) {\n\tif ema.InnerSeries == nil {\n\t\treturn\n\t}\n\tif len(ema.cache) == 0 {\n\t\tema.ensureCachedValues()\n\t}\n\tlastIndex := ema.InnerSeries.Len() - 1\n\tx, _ = ema.InnerSeries.GetValues(lastIndex)\n\ty = ema.cache[lastIndex]\n\treturn\n}\n\nfunc (ema *EMASeries) ensureCachedValues() {\n\tseriesLength := ema.InnerSeries.Len()\n\tema.cache = make([]float64, seriesLength)\n\tsigma := ema.GetSigma()\n\tfor x := 0; x < seriesLength; x++ {\n\t\t_, y := ema.InnerSeries.GetValues(x)\n\t\tif x == 0 {\n\t\t\tema.cache[x] = y\n\t\t\tcontinue\n\t\t}\n\t\tpreviousEMA := ema.cache[x-1]\n\t\tema.cache[x] = ((y - previousEMA) * sigma) + previousEMA\n\t}\n}\n\n// Render renders the series.\nfunc (ema *EMASeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := ema.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, ema)\n}\n\n// Validate validates the series.\nfunc (ema *EMASeries) Validate() error {\n\tif ema.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"ema series requires InnerSeries to be set\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "ema_series_test.go",
          "type": "blob",
          "size": 1.736328125,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nvar (\n\temaXValues = LinearRange(1.0, 50.0)\n\temaYValues = []float64{\n\t\t1, 2, 3, 4, 5, 4, 3, 2,\n\t\t1, 2, 3, 4, 5, 4, 3, 2,\n\t\t1, 2, 3, 4, 5, 4, 3, 2,\n\t\t1, 2, 3, 4, 5, 4, 3, 2,\n\t\t1, 2, 3, 4, 5, 4, 3, 2,\n\t\t1, 2, 3, 4, 5, 4, 3, 2,\n\t\t1, 2,\n\t}\n\temaExpected = []float64{\n\t\t1,\n\t\t1.074074074,\n\t\t1.216735254,\n\t\t1.422903013,\n\t\t1.68787316,\n\t\t1.859141815,\n\t\t1.943649828,\n\t\t1.947823915,\n\t\t1.877614736,\n\t\t1.886680311,\n\t\t1.969148437,\n\t\t2.119581886,\n\t\t2.33294619,\n\t\t2.456431658,\n\t\t2.496695979,\n\t\t2.459903685,\n\t\t2.351762671,\n\t\t2.325706177,\n\t\t2.375653867,\n\t\t2.495975803,\n\t\t2.681459077,\n\t\t2.779128775,\n\t\t2.795489607,\n\t\t2.73656445,\n\t\t2.607930047,\n\t\t2.562898191,\n\t\t2.595276103,\n\t\t2.699329725,\n\t\t2.869749746,\n\t\t2.953471987,\n\t\t2.956918506,\n\t\t2.886035654,\n\t\t2.746329309,\n\t\t2.691045657,\n\t\t2.713931163,\n\t\t2.809195522,\n\t\t2.971477335,\n\t\t3.047664199,\n\t\t3.044133518,\n\t\t2.966790294,\n\t\t2.821102124,\n\t\t2.760279745,\n\t\t2.778036801,\n\t\t2.868552593,\n\t\t3.026437586,\n\t\t3.098553321,\n\t\t3.091253075,\n\t\t3.010419514,\n\t\t2.86149955,\n\t\t2.797684768,\n\t}\n\temaDelta = 0.0001\n)\n\nfunc TestEMASeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\tmockSeries := mockValuesProvider{\n\t\temaXValues,\n\t\temaYValues,\n\t}\n\ttestutil.AssertEqual(t, 50, mockSeries.Len())\n\n\tema := &EMASeries{\n\t\tInnerSeries: mockSeries,\n\t\tPeriod:      26,\n\t}\n\n\tsig := ema.GetSigma()\n\ttestutil.AssertEqual(t, 2.0/(26.0+1), sig)\n\n\tvar yvalues []float64\n\tfor x := 0; x < ema.Len(); x++ {\n\t\t_, y := ema.GetValues(x)\n\t\tyvalues = append(yvalues, y)\n\t}\n\n\tfor index, yv := range yvalues {\n\t\ttestutil.AssertInDelta(t, yv, emaExpected[index], emaDelta)\n\t}\n\n\tlvx, lvy := ema.GetLastValues()\n\ttestutil.AssertEqual(t, 50.0, lvx)\n\ttestutil.AssertInDelta(t, lvy, emaExpected[49], emaDelta)\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fileutil.go",
          "type": "blob",
          "size": 0.8544921875,
          "content": "package chart\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"os\"\n)\n\n// ReadLines reads a file and calls the handler for each line.\nfunc ReadLines(filePath string, handler func(string) error) error {\n\tf, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\terr = handler(line)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// ReadChunks reads a file in `chunkSize` pieces, dispatched to the handler.\nfunc ReadChunks(filePath string, chunkSize int, handler func([]byte) error) error {\n\tf, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tchunk := make([]byte, chunkSize)\n\tfor {\n\t\treadBytes, err := f.Read(chunk)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\treadData := chunk[:readBytes]\n\t\terr = handler(readData)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "first_value_annotation.go",
          "type": "blob",
          "size": 1.0693359375,
          "content": "package chart\n\nimport \"fmt\"\n\n// FirstValueAnnotation returns an annotation series of just the first value of a value provider as an annotation.\nfunc FirstValueAnnotation(innerSeries ValuesProvider, vfs ...ValueFormatter) AnnotationSeries {\n\tvar vf ValueFormatter\n\tif len(vfs) > 0 {\n\t\tvf = vfs[0]\n\t} else if typed, isTyped := innerSeries.(ValueFormatterProvider); isTyped {\n\t\t_, vf = typed.GetValueFormatters()\n\t} else {\n\t\tvf = FloatValueFormatter\n\t}\n\n\tvar firstValue Value2\n\tif typed, isTyped := innerSeries.(FirstValuesProvider); isTyped {\n\t\tfirstValue.XValue, firstValue.YValue = typed.GetFirstValues()\n\t\tfirstValue.Label = vf(firstValue.YValue)\n\t} else {\n\t\tfirstValue.XValue, firstValue.YValue = innerSeries.GetValues(0)\n\t\tfirstValue.Label = vf(firstValue.YValue)\n\t}\n\n\tvar seriesName string\n\tvar seriesStyle Style\n\tif typed, isTyped := innerSeries.(Series); isTyped {\n\t\tseriesName = fmt.Sprintf(\"%s - First Value\", typed.GetName())\n\t\tseriesStyle = typed.GetStyle()\n\t}\n\n\treturn AnnotationSeries{\n\t\tName:        seriesName,\n\t\tStyle:       seriesStyle,\n\t\tAnnotations: []Value2{firstValue},\n\t}\n}\n"
        },
        {
          "name": "first_value_annotation_test.go",
          "type": "blob",
          "size": 0.4755859375,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestFirstValueAnnotation(t *testing.T) {\n\t// replaced new assertions helper\n\n\tseries := ContinuousSeries{\n\t\tXValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\tYValues: []float64{5.0, 3.0, 3.0, 2.0, 1.0},\n\t}\n\n\tfva := FirstValueAnnotation(series)\n\ttestutil.AssertNotEmpty(t, fva.Annotations)\n\tfvaa := fva.Annotations[0]\n\ttestutil.AssertEqual(t, 1, fvaa.XValue)\n\ttestutil.AssertEqual(t, 5, fvaa.YValue)\n}\n"
        },
        {
          "name": "font.go",
          "type": "blob",
          "size": 0.544921875,
          "content": "package chart\n\nimport (\n\t\"sync\"\n\n\t\"github.com/golang/freetype/truetype\"\n\t\"github.com/wcharczuk/go-chart/v2/roboto\"\n)\n\nvar (\n\t_defaultFontLock sync.Mutex\n\t_defaultFont     *truetype.Font\n)\n\n// GetDefaultFont returns the default font (Roboto-Medium).\nfunc GetDefaultFont() (*truetype.Font, error) {\n\tif _defaultFont == nil {\n\t\t_defaultFontLock.Lock()\n\t\tdefer _defaultFontLock.Unlock()\n\t\tif _defaultFont == nil {\n\t\t\tfont, err := truetype.Parse(roboto.Roboto)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t_defaultFont = font\n\t\t}\n\t}\n\treturn _defaultFont, nil\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1494140625,
          "content": "module github.com/wcharczuk/go-chart/v2\n\ngo 1.15\n\nrequire (\n\tgithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0\n\tgolang.org/x/image v0.18.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.6552734375,
          "content": "github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 h1:DACJavvAHhabrF08vX0COfcOBJRhZ8lUbR+ZWIs0Y5g=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\ngolang.org/x/image v0.18.0 h1:jGzIakQa/ZXI1I0Fxvaa9W7yP25TqT6cHIHn+6CqvSQ=\ngolang.org/x/image v0.18.0/go.mod h1:4yyo5vMFQjVjUcVk4jEQcU9MGy/rulF5WvUILseCM2E=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "grid_line.go",
          "type": "blob",
          "size": 1.68359375,
          "content": "package chart\n\n// GridLineProvider is a type that provides grid lines.\ntype GridLineProvider interface {\n\tGetGridLines(ticks []Tick, isVertical bool, majorStyle, minorStyle Style) []GridLine\n}\n\n// GridLine is a line on a graph canvas.\ntype GridLine struct {\n\tIsMinor bool\n\tStyle   Style\n\tValue   float64\n}\n\n// Major returns if the gridline is a `major` line.\nfunc (gl GridLine) Major() bool {\n\treturn !gl.IsMinor\n}\n\n// Minor returns if the gridline is a `minor` line.\nfunc (gl GridLine) Minor() bool {\n\treturn gl.IsMinor\n}\n\n// Render renders the gridline\nfunc (gl GridLine) Render(r Renderer, canvasBox Box, ra Range, isVertical bool, defaults Style) {\n\tr.SetStrokeColor(gl.Style.GetStrokeColor(defaults.GetStrokeColor()))\n\tr.SetStrokeWidth(gl.Style.GetStrokeWidth(defaults.GetStrokeWidth()))\n\tr.SetStrokeDashArray(gl.Style.GetStrokeDashArray(defaults.GetStrokeDashArray()))\n\n\tif isVertical {\n\t\tlineLeft := canvasBox.Left + ra.Translate(gl.Value)\n\t\tlineBottom := canvasBox.Bottom\n\t\tlineTop := canvasBox.Top\n\n\t\tr.MoveTo(lineLeft, lineBottom)\n\t\tr.LineTo(lineLeft, lineTop)\n\t\tr.Stroke()\n\t} else {\n\t\tlineLeft := canvasBox.Left\n\t\tlineRight := canvasBox.Right\n\t\tlineHeight := canvasBox.Bottom - ra.Translate(gl.Value)\n\n\t\tr.MoveTo(lineLeft, lineHeight)\n\t\tr.LineTo(lineRight, lineHeight)\n\t\tr.Stroke()\n\t}\n}\n\n// GenerateGridLines generates grid lines.\nfunc GenerateGridLines(ticks []Tick, majorStyle, minorStyle Style) []GridLine {\n\tvar gl []GridLine\n\tisMinor := false\n\n\tif len(ticks) < 3 {\n\t\treturn gl\n\t}\n\n\tfor _, t := range ticks[1 : len(ticks)-1] {\n\t\ts := majorStyle\n\t\tif isMinor {\n\t\t\ts = minorStyle\n\t\t}\n\t\tgl = append(gl, GridLine{\n\t\t\tStyle:   s,\n\t\t\tIsMinor: isMinor,\n\t\t\tValue:   t.Value,\n\t\t})\n\t\tisMinor = !isMinor\n\t}\n\treturn gl\n}\n"
        },
        {
          "name": "grid_line_test.go",
          "type": "blob",
          "size": 0.462890625,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestGenerateGridLines(t *testing.T) {\n\t// replaced new assertions helper\n\n\tticks := []Tick{\n\t\t{Value: 1.0, Label: \"1.0\"},\n\t\t{Value: 2.0, Label: \"2.0\"},\n\t\t{Value: 3.0, Label: \"3.0\"},\n\t\t{Value: 4.0, Label: \"4.0\"},\n\t}\n\n\tgl := GenerateGridLines(ticks, Style{}, Style{})\n\ttestutil.AssertLen(t, gl, 2)\n\n\ttestutil.AssertEqual(t, 2.0, gl[0].Value)\n\ttestutil.AssertEqual(t, 3.0, gl[1].Value)\n}\n"
        },
        {
          "name": "histogram_series.go",
          "type": "blob",
          "size": 1.6640625,
          "content": "package chart\n\nimport \"fmt\"\n\n// HistogramSeries is a special type of series that draws as a histogram.\n// Some peculiarities; it will always be lower bounded at 0 (at the very least).\n// This may alter ranges a bit and generally you want to put a histogram series on it's own y-axis.\ntype HistogramSeries struct {\n\tName        string\n\tStyle       Style\n\tYAxis       YAxisType\n\tInnerSeries ValuesProvider\n}\n\n// GetName implements Series.GetName.\nfunc (hs HistogramSeries) GetName() string {\n\treturn hs.Name\n}\n\n// GetStyle implements Series.GetStyle.\nfunc (hs HistogramSeries) GetStyle() Style {\n\treturn hs.Style\n}\n\n// GetYAxis returns which yaxis the series is mapped to.\nfunc (hs HistogramSeries) GetYAxis() YAxisType {\n\treturn hs.YAxis\n}\n\n// Len implements BoundedValuesProvider.Len.\nfunc (hs HistogramSeries) Len() int {\n\treturn hs.InnerSeries.Len()\n}\n\n// GetValues implements ValuesProvider.GetValues.\nfunc (hs HistogramSeries) GetValues(index int) (x, y float64) {\n\treturn hs.InnerSeries.GetValues(index)\n}\n\n// GetBoundedValues implements BoundedValuesProvider.GetBoundedValue\nfunc (hs HistogramSeries) GetBoundedValues(index int) (x, y1, y2 float64) {\n\tvx, vy := hs.InnerSeries.GetValues(index)\n\n\tx = vx\n\n\tif vy > 0 {\n\t\ty1 = vy\n\t\treturn\n\t}\n\n\ty2 = vy\n\treturn\n}\n\n// Render implements Series.Render.\nfunc (hs HistogramSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := hs.Style.InheritFrom(defaults)\n\tDraw.HistogramSeries(r, canvasBox, xrange, yrange, style, hs)\n}\n\n// Validate validates the series.\nfunc (hs HistogramSeries) Validate() error {\n\tif hs.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"histogram series requires InnerSeries to be set\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "histogram_series_test.go",
          "type": "blob",
          "size": 0.662109375,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestHistogramSeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\tcs := ContinuousSeries{\n\t\tName:    \"Test Series\",\n\t\tXValues: LinearRange(1.0, 20.0),\n\t\tYValues: LinearRange(10.0, -10.0),\n\t}\n\n\ths := HistogramSeries{\n\t\tInnerSeries: cs,\n\t}\n\n\tfor x := 0; x < hs.Len(); x++ {\n\t\tcsx, csy := cs.GetValues(0)\n\t\thsx, hsy1, hsy2 := hs.GetBoundedValues(0)\n\t\ttestutil.AssertEqual(t, csx, hsx)\n\t\ttestutil.AssertTrue(t, hsy1 > 0)\n\t\ttestutil.AssertTrue(t, hsy2 <= 0)\n\t\ttestutil.AssertTrue(t, csy < 0 || (csy > 0 && csy == hsy1))\n\t\ttestutil.AssertTrue(t, csy > 0 || (csy < 0 && csy == hsy2))\n\t}\n}\n"
        },
        {
          "name": "image_writer.go",
          "type": "blob",
          "size": 0.890625,
          "content": "package chart\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"image\"\n\t\"image/png\"\n)\n\n// RGBACollector is a render target for a chart.\ntype RGBACollector interface {\n\tSetRGBA(i *image.RGBA)\n}\n\n// ImageWriter is a special type of io.Writer that produces a final image.\ntype ImageWriter struct {\n\trgba     *image.RGBA\n\tcontents *bytes.Buffer\n}\n\nfunc (ir *ImageWriter) Write(buffer []byte) (int, error) {\n\tif ir.contents == nil {\n\t\tir.contents = bytes.NewBuffer([]byte{})\n\t}\n\treturn ir.contents.Write(buffer)\n}\n\n// SetRGBA sets a raw version of the image.\nfunc (ir *ImageWriter) SetRGBA(i *image.RGBA) {\n\tir.rgba = i\n}\n\n// Image returns an *image.Image for the result.\nfunc (ir *ImageWriter) Image() (image.Image, error) {\n\tif ir.rgba != nil {\n\t\treturn ir.rgba, nil\n\t}\n\tif ir.contents != nil && ir.contents.Len() > 0 {\n\t\treturn png.Decode(ir.contents)\n\t}\n\treturn nil, errors.New(\"no valid sources for image data, cannot continue\")\n}\n"
        },
        {
          "name": "jet.go",
          "type": "blob",
          "size": 0.736328125,
          "content": "package chart\n\nimport \"github.com/wcharczuk/go-chart/v2/drawing\"\n\n// Jet is a color map provider based on matlab's jet color map.\nfunc Jet(v, vmin, vmax float64) drawing.Color {\n\tc := drawing.Color{R: 0xff, G: 0xff, B: 0xff, A: 0xff} // white\n\tvar dv float64\n\n\tif v < vmin {\n\t\tv = vmin\n\t}\n\tif v > vmax {\n\t\tv = vmax\n\t}\n\tdv = vmax - vmin\n\n\tif v < (vmin + 0.25*dv) {\n\t\tc.R = 0\n\t\tc.G = drawing.ColorChannelFromFloat(4 * (v - vmin) / dv)\n\t} else if v < (vmin + 0.5*dv) {\n\t\tc.R = 0\n\t\tc.B = drawing.ColorChannelFromFloat(1 + 4*(vmin+0.25*dv-v)/dv)\n\t} else if v < (vmin + 0.75*dv) {\n\t\tc.R = drawing.ColorChannelFromFloat(4 * (v - vmin - 0.5*dv) / dv)\n\t\tc.B = 0\n\t} else {\n\t\tc.G = drawing.ColorChannelFromFloat(1 + 4*(vmin+0.75*dv-v)/dv)\n\t\tc.B = 0\n\t}\n\n\treturn c\n}\n"
        },
        {
          "name": "last_value_annotation_series.go",
          "type": "blob",
          "size": 1.068359375,
          "content": "package chart\n\nimport \"fmt\"\n\n// LastValueAnnotationSeries returns an annotation series of just the last value of a value provider.\nfunc LastValueAnnotationSeries(innerSeries ValuesProvider, vfs ...ValueFormatter) AnnotationSeries {\n\tvar vf ValueFormatter\n\tif len(vfs) > 0 {\n\t\tvf = vfs[0]\n\t} else if typed, isTyped := innerSeries.(ValueFormatterProvider); isTyped {\n\t\t_, vf = typed.GetValueFormatters()\n\t} else {\n\t\tvf = FloatValueFormatter\n\t}\n\n\tvar lastValue Value2\n\tif typed, isTyped := innerSeries.(LastValuesProvider); isTyped {\n\t\tlastValue.XValue, lastValue.YValue = typed.GetLastValues()\n\t\tlastValue.Label = vf(lastValue.YValue)\n\t} else {\n\t\tlastValue.XValue, lastValue.YValue = innerSeries.GetValues(innerSeries.Len() - 1)\n\t\tlastValue.Label = vf(lastValue.YValue)\n\t}\n\n\tvar seriesName string\n\tvar seriesStyle Style\n\tif typed, isTyped := innerSeries.(Series); isTyped {\n\t\tseriesName = fmt.Sprintf(\"%s - Last Value\", typed.GetName())\n\t\tseriesStyle = typed.GetStyle()\n\t}\n\n\treturn AnnotationSeries{\n\t\tName:        seriesName,\n\t\tStyle:       seriesStyle,\n\t\tAnnotations: []Value2{lastValue},\n\t}\n}\n"
        },
        {
          "name": "last_value_annotation_series_test.go",
          "type": "blob",
          "size": 0.4853515625,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestLastValueAnnotationSeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\tseries := ContinuousSeries{\n\t\tXValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\tYValues: []float64{5.0, 3.0, 3.0, 2.0, 1.0},\n\t}\n\n\tlva := LastValueAnnotationSeries(series)\n\ttestutil.AssertNotEmpty(t, lva.Annotations)\n\tlvaa := lva.Annotations[0]\n\ttestutil.AssertEqual(t, 5, lvaa.XValue)\n\ttestutil.AssertEqual(t, 1, lvaa.YValue)\n}\n"
        },
        {
          "name": "legend.go",
          "type": "blob",
          "size": 8.2763671875,
          "content": "package chart\n\nimport (\n\t\"github.com/wcharczuk/go-chart/v2/drawing\"\n)\n\n// Legend returns a legend renderable function.\nfunc Legend(c *Chart, userDefaults ...Style) Renderable {\n\treturn func(r Renderer, cb Box, chartDefaults Style) {\n\t\tlegendDefaults := Style{\n\t\t\tFillColor:   drawing.ColorWhite,\n\t\t\tFontColor:   DefaultTextColor,\n\t\t\tFontSize:    8.0,\n\t\t\tStrokeColor: DefaultAxisColor,\n\t\t\tStrokeWidth: DefaultAxisLineWidth,\n\t\t}\n\n\t\tvar legendStyle Style\n\t\tif len(userDefaults) > 0 {\n\t\t\tlegendStyle = userDefaults[0].InheritFrom(chartDefaults.InheritFrom(legendDefaults))\n\t\t} else {\n\t\t\tlegendStyle = chartDefaults.InheritFrom(legendDefaults)\n\t\t}\n\n\t\t// DEFAULTS\n\t\tlegendPadding := Box{\n\t\t\tTop:    5,\n\t\t\tLeft:   5,\n\t\t\tRight:  5,\n\t\t\tBottom: 5,\n\t\t}\n\t\tlineTextGap := 5\n\t\tlineLengthMinimum := 25\n\n\t\tvar labels []string\n\t\tvar lines []Style\n\t\tfor index, s := range c.Series {\n\t\t\tif !s.GetStyle().Hidden {\n\t\t\t\tif _, isAnnotationSeries := s.(AnnotationSeries); !isAnnotationSeries {\n\t\t\t\t\tlabels = append(labels, s.GetName())\n\t\t\t\t\tlines = append(lines, s.GetStyle().InheritFrom(c.styleDefaultsSeries(index)))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlegend := Box{\n\t\t\tTop:  cb.Top,\n\t\t\tLeft: cb.Left,\n\t\t\t// bottom and right will be sized by the legend content + relevant padding.\n\t\t}\n\n\t\tlegendContent := Box{\n\t\t\tTop:    legend.Top + legendPadding.Top,\n\t\t\tLeft:   legend.Left + legendPadding.Left,\n\t\t\tRight:  legend.Left + legendPadding.Left,\n\t\t\tBottom: legend.Top + legendPadding.Top,\n\t\t}\n\n\t\tlegendStyle.GetTextOptions().WriteToRenderer(r)\n\n\t\t// measure\n\t\tlabelCount := 0\n\t\tfor x := 0; x < len(labels); x++ {\n\t\t\tif len(labels[x]) > 0 {\n\t\t\t\ttb := r.MeasureText(labels[x])\n\t\t\t\tif labelCount > 0 {\n\t\t\t\t\tlegendContent.Bottom += DefaultMinimumTickVerticalSpacing\n\t\t\t\t}\n\t\t\t\tlegendContent.Bottom += tb.Height()\n\t\t\t\tright := legendContent.Left + tb.Width() + lineTextGap + lineLengthMinimum\n\t\t\t\tlegendContent.Right = MaxInt(legendContent.Right, right)\n\t\t\t\tlabelCount++\n\t\t\t}\n\t\t}\n\n\t\tlegend = legend.Grow(legendContent)\n\t\tlegend.Right = legendContent.Right + legendPadding.Right\n\t\tlegend.Bottom = legendContent.Bottom + legendPadding.Bottom\n\n\t\tDraw.Box(r, legend, legendStyle)\n\n\t\tlegendStyle.GetTextOptions().WriteToRenderer(r)\n\n\t\tycursor := legendContent.Top\n\t\ttx := legendContent.Left\n\t\tlegendCount := 0\n\t\tvar label string\n\t\tfor x := 0; x < len(labels); x++ {\n\t\t\tlabel = labels[x]\n\t\t\tif len(label) > 0 {\n\t\t\t\tif legendCount > 0 {\n\t\t\t\t\tycursor += DefaultMinimumTickVerticalSpacing\n\t\t\t\t}\n\n\t\t\t\ttb := r.MeasureText(label)\n\n\t\t\t\tty := ycursor + tb.Height()\n\t\t\t\tr.Text(label, tx, ty)\n\n\t\t\t\tth2 := tb.Height() >> 1\n\n\t\t\t\tlx := tx + tb.Width() + lineTextGap\n\t\t\t\tly := ty - th2\n\t\t\t\tlx2 := legendContent.Right - legendPadding.Right\n\n\t\t\t\tr.SetStrokeColor(lines[x].GetStrokeColor())\n\t\t\t\tr.SetStrokeWidth(lines[x].GetStrokeWidth())\n\t\t\t\tr.SetStrokeDashArray(lines[x].GetStrokeDashArray())\n\n\t\t\t\tr.MoveTo(lx, ly)\n\t\t\t\tr.LineTo(lx2, ly)\n\t\t\t\tr.Stroke()\n\n\t\t\t\tycursor += tb.Height()\n\t\t\t\tlegendCount++\n\t\t\t}\n\t\t}\n\t}\n}\n\n// LegendThin is a legend that doesn't obscure the chart area.\nfunc LegendThin(c *Chart, userDefaults ...Style) Renderable {\n\treturn func(r Renderer, cb Box, chartDefaults Style) {\n\t\tlegendDefaults := Style{\n\t\t\tFillColor:   drawing.ColorWhite,\n\t\t\tFontColor:   DefaultTextColor,\n\t\t\tFontSize:    8.0,\n\t\t\tStrokeColor: DefaultAxisColor,\n\t\t\tStrokeWidth: DefaultAxisLineWidth,\n\t\t\tPadding: Box{\n\t\t\t\tTop:    2,\n\t\t\t\tLeft:   7,\n\t\t\t\tRight:  7,\n\t\t\t\tBottom: 5,\n\t\t\t},\n\t\t}\n\n\t\tvar legendStyle Style\n\t\tif len(userDefaults) > 0 {\n\t\t\tlegendStyle = userDefaults[0].InheritFrom(chartDefaults.InheritFrom(legendDefaults))\n\t\t} else {\n\t\t\tlegendStyle = chartDefaults.InheritFrom(legendDefaults)\n\t\t}\n\n\t\tr.SetFont(legendStyle.GetFont())\n\t\tr.SetFontColor(legendStyle.GetFontColor())\n\t\tr.SetFontSize(legendStyle.GetFontSize())\n\n\t\tvar labels []string\n\t\tvar lines []Style\n\t\tfor index, s := range c.Series {\n\t\t\tif !s.GetStyle().Hidden {\n\t\t\t\tif _, isAnnotationSeries := s.(AnnotationSeries); !isAnnotationSeries {\n\t\t\t\t\tlabels = append(labels, s.GetName())\n\t\t\t\t\tlines = append(lines, s.GetStyle().InheritFrom(c.styleDefaultsSeries(index)))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar textHeight int\n\t\tvar textWidth int\n\t\tvar textBox Box\n\t\tfor x := 0; x < len(labels); x++ {\n\t\t\tif len(labels[x]) > 0 {\n\t\t\t\ttextBox = r.MeasureText(labels[x])\n\t\t\t\ttextHeight = MaxInt(textBox.Height(), textHeight)\n\t\t\t\ttextWidth = MaxInt(textBox.Width(), textWidth)\n\t\t\t}\n\t\t}\n\n\t\tlegendBoxHeight := textHeight + legendStyle.Padding.Top + legendStyle.Padding.Bottom\n\t\tchartPadding := cb.Top\n\t\tlegendYMargin := (chartPadding - legendBoxHeight) >> 1\n\n\t\tlegendBox := Box{\n\t\t\tLeft:   cb.Left,\n\t\t\tRight:  cb.Right,\n\t\t\tTop:    legendYMargin,\n\t\t\tBottom: legendYMargin + legendBoxHeight,\n\t\t}\n\n\t\tDraw.Box(r, legendBox, legendDefaults)\n\n\t\tr.SetFont(legendStyle.GetFont())\n\t\tr.SetFontColor(legendStyle.GetFontColor())\n\t\tr.SetFontSize(legendStyle.GetFontSize())\n\n\t\tlineTextGap := 5\n\t\tlineLengthMinimum := 25\n\n\t\ttx := legendBox.Left + legendStyle.Padding.Left\n\t\tty := legendYMargin + legendStyle.Padding.Top + textHeight\n\t\tvar label string\n\t\tvar lx, ly int\n\t\tth2 := textHeight >> 1\n\t\tfor index := range labels {\n\t\t\tlabel = labels[index]\n\t\t\tif len(label) > 0 {\n\t\t\t\ttextBox = r.MeasureText(label)\n\t\t\t\tr.Text(label, tx, ty)\n\n\t\t\t\tlx = tx + textBox.Width() + lineTextGap\n\t\t\t\tly = ty - th2\n\n\t\t\t\tr.SetStrokeColor(lines[index].GetStrokeColor())\n\t\t\t\tr.SetStrokeWidth(lines[index].GetStrokeWidth())\n\t\t\t\tr.SetStrokeDashArray(lines[index].GetStrokeDashArray())\n\n\t\t\t\tr.MoveTo(lx, ly)\n\t\t\t\tr.LineTo(lx+lineLengthMinimum, ly)\n\t\t\t\tr.Stroke()\n\n\t\t\t\ttx += textBox.Width() + DefaultMinimumTickHorizontalSpacing + lineTextGap + lineLengthMinimum\n\t\t\t}\n\t\t}\n\t}\n}\n\n// LegendLeft is a legend that is designed for longer series lists.\nfunc LegendLeft(c *Chart, userDefaults ...Style) Renderable {\n\treturn func(r Renderer, cb Box, chartDefaults Style) {\n\t\tlegendDefaults := Style{\n\t\t\tFillColor:   drawing.ColorWhite,\n\t\t\tFontColor:   DefaultTextColor,\n\t\t\tFontSize:    8.0,\n\t\t\tStrokeColor: DefaultAxisColor,\n\t\t\tStrokeWidth: DefaultAxisLineWidth,\n\t\t}\n\n\t\tvar legendStyle Style\n\t\tif len(userDefaults) > 0 {\n\t\t\tlegendStyle = userDefaults[0].InheritFrom(chartDefaults.InheritFrom(legendDefaults))\n\t\t} else {\n\t\t\tlegendStyle = chartDefaults.InheritFrom(legendDefaults)\n\t\t}\n\n\t\t// DEFAULTS\n\t\tlegendPadding := Box{\n\t\t\tTop:    5,\n\t\t\tLeft:   5,\n\t\t\tRight:  5,\n\t\t\tBottom: 5,\n\t\t}\n\t\tlineTextGap := 5\n\t\tlineLengthMinimum := 25\n\n\t\tvar labels []string\n\t\tvar lines []Style\n\t\tfor index, s := range c.Series {\n\t\t\tif !s.GetStyle().Hidden {\n\t\t\t\tif _, isAnnotationSeries := s.(AnnotationSeries); !isAnnotationSeries {\n\t\t\t\t\tlabels = append(labels, s.GetName())\n\t\t\t\t\tlines = append(lines, s.GetStyle().InheritFrom(c.styleDefaultsSeries(index)))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlegend := Box{\n\t\t\tTop:  5,\n\t\t\tLeft: 5,\n\t\t\t// bottom and right will be sized by the legend content + relevant padding.\n\t\t}\n\n\t\tlegendContent := Box{\n\t\t\tTop:    legend.Top + legendPadding.Top,\n\t\t\tLeft:   legend.Left + legendPadding.Left,\n\t\t\tRight:  legend.Left + legendPadding.Left,\n\t\t\tBottom: legend.Top + legendPadding.Top,\n\t\t}\n\n\t\tlegendStyle.GetTextOptions().WriteToRenderer(r)\n\n\t\t// measure\n\t\tlabelCount := 0\n\t\tfor x := 0; x < len(labels); x++ {\n\t\t\tif len(labels[x]) > 0 {\n\t\t\t\ttb := r.MeasureText(labels[x])\n\t\t\t\tif labelCount > 0 {\n\t\t\t\t\tlegendContent.Bottom += DefaultMinimumTickVerticalSpacing\n\t\t\t\t}\n\t\t\t\tlegendContent.Bottom += tb.Height()\n\t\t\t\tright := legendContent.Left + tb.Width() + lineTextGap + lineLengthMinimum\n\t\t\t\tlegendContent.Right = MaxInt(legendContent.Right, right)\n\t\t\t\tlabelCount++\n\t\t\t}\n\t\t}\n\n\t\tlegend = legend.Grow(legendContent)\n\t\tlegend.Right = legendContent.Right + legendPadding.Right\n\t\tlegend.Bottom = legendContent.Bottom + legendPadding.Bottom\n\n\t\tDraw.Box(r, legend, legendStyle)\n\n\t\tlegendStyle.GetTextOptions().WriteToRenderer(r)\n\n\t\tycursor := legendContent.Top\n\t\ttx := legendContent.Left\n\t\tlegendCount := 0\n\t\tvar label string\n\t\tfor x := 0; x < len(labels); x++ {\n\t\t\tlabel = labels[x]\n\t\t\tif len(label) > 0 {\n\t\t\t\tif legendCount > 0 {\n\t\t\t\t\tycursor += DefaultMinimumTickVerticalSpacing\n\t\t\t\t}\n\n\t\t\t\ttb := r.MeasureText(label)\n\n\t\t\t\tty := ycursor + tb.Height()\n\t\t\t\tr.Text(label, tx, ty)\n\n\t\t\t\tth2 := tb.Height() >> 1\n\n\t\t\t\tlx := tx + tb.Width() + lineTextGap\n\t\t\t\tly := ty - th2\n\t\t\t\tlx2 := legendContent.Right - legendPadding.Right\n\n\t\t\t\tr.SetStrokeColor(lines[x].GetStrokeColor())\n\t\t\t\tr.SetStrokeWidth(lines[x].GetStrokeWidth())\n\t\t\t\tr.SetStrokeDashArray(lines[x].GetStrokeDashArray())\n\n\t\t\t\tr.MoveTo(lx, ly)\n\t\t\t\tr.LineTo(lx2, ly)\n\t\t\t\tr.Stroke()\n\n\t\t\t\tycursor += tb.Height()\n\t\t\t\tlegendCount++\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "legend_test.go",
          "type": "blob",
          "size": 0.6162109375,
          "content": "package chart\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestLegend(t *testing.T) {\n\t// replaced new assertions helper\n\n\tgraph := Chart{\n\t\tSeries: []Series{\n\t\t\tContinuousSeries{\n\t\t\t\tName:    \"A test series\",\n\t\t\t\tXValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tYValues: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t},\n\t}\n\n\t//note we have to do this as a separate step because we need a reference to graph\n\tgraph.Elements = []Renderable{\n\t\tLegend(&graph),\n\t}\n\tbuf := bytes.NewBuffer([]byte{})\n\terr := graph.Render(PNG, buf)\n\ttestutil.AssertNil(t, err)\n\ttestutil.AssertNotZero(t, buf.Len())\n}\n"
        },
        {
          "name": "linear_coefficient_provider.go",
          "type": "blob",
          "size": 0.9658203125,
          "content": "package chart\n\n// LinearCoefficientProvider is a type that returns linear cofficients.\ntype LinearCoefficientProvider interface {\n\tCoefficients() (m, b, stdev, avg float64)\n}\n\n// LinearCoefficients returns a fixed linear coefficient pair.\nfunc LinearCoefficients(m, b float64) LinearCoefficientSet {\n\treturn LinearCoefficientSet{\n\t\tM: m,\n\t\tB: b,\n\t}\n}\n\n// NormalizedLinearCoefficients returns a fixed linear coefficient pair.\nfunc NormalizedLinearCoefficients(m, b, stdev, avg float64) LinearCoefficientSet {\n\treturn LinearCoefficientSet{\n\t\tM:      m,\n\t\tB:      b,\n\t\tStdDev: stdev,\n\t\tAvg:    avg,\n\t}\n}\n\n// LinearCoefficientSet is the m and b values for the linear equation in the form:\n// y = (m*x) + b\ntype LinearCoefficientSet struct {\n\tM      float64\n\tB      float64\n\tStdDev float64\n\tAvg    float64\n}\n\n// Coefficients returns the coefficients.\nfunc (lcs LinearCoefficientSet) Coefficients() (m, b, stdev, avg float64) {\n\tm = lcs.M\n\tb = lcs.B\n\tstdev = lcs.StdDev\n\tavg = lcs.Avg\n\treturn\n}\n"
        },
        {
          "name": "linear_regression_series.go",
          "type": "blob",
          "size": 4.60546875,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n)\n\n// Interface Assertions.\nvar (\n\t_ Series                    = (*LinearRegressionSeries)(nil)\n\t_ FirstValuesProvider       = (*LinearRegressionSeries)(nil)\n\t_ LastValuesProvider        = (*LinearRegressionSeries)(nil)\n\t_ LinearCoefficientProvider = (*LinearRegressionSeries)(nil)\n)\n\n// LinearRegressionSeries is a series that plots the n-nearest neighbors\n// linear regression for the values.\ntype LinearRegressionSeries struct {\n\tName  string\n\tStyle Style\n\tYAxis YAxisType\n\n\tLimit       int\n\tOffset      int\n\tInnerSeries ValuesProvider\n\n\tm       float64\n\tb       float64\n\tavgx    float64\n\tstddevx float64\n}\n\n// Coefficients returns the linear coefficients for the series.\nfunc (lrs LinearRegressionSeries) Coefficients() (m, b, stdev, avg float64) {\n\tif lrs.IsZero() {\n\t\tlrs.computeCoefficients()\n\t}\n\n\tm = lrs.m\n\tb = lrs.b\n\tstdev = lrs.stddevx\n\tavg = lrs.avgx\n\treturn\n}\n\n// GetName returns the name of the time series.\nfunc (lrs LinearRegressionSeries) GetName() string {\n\treturn lrs.Name\n}\n\n// GetStyle returns the line style.\nfunc (lrs LinearRegressionSeries) GetStyle() Style {\n\treturn lrs.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (lrs LinearRegressionSeries) GetYAxis() YAxisType {\n\treturn lrs.YAxis\n}\n\n// Len returns the number of elements in the series.\nfunc (lrs LinearRegressionSeries) Len() int {\n\treturn MinInt(lrs.GetLimit(), lrs.InnerSeries.Len()-lrs.GetOffset())\n}\n\n// GetLimit returns the window size.\nfunc (lrs LinearRegressionSeries) GetLimit() int {\n\tif lrs.Limit == 0 {\n\t\treturn lrs.InnerSeries.Len()\n\t}\n\treturn lrs.Limit\n}\n\n// GetEndIndex returns the effective limit end.\nfunc (lrs LinearRegressionSeries) GetEndIndex() int {\n\twindowEnd := lrs.GetOffset() + lrs.GetLimit()\n\tinnerSeriesLastIndex := lrs.InnerSeries.Len() - 1\n\treturn MinInt(windowEnd, innerSeriesLastIndex)\n}\n\n// GetOffset returns the data offset.\nfunc (lrs LinearRegressionSeries) GetOffset() int {\n\tif lrs.Offset == 0 {\n\t\treturn 0\n\t}\n\treturn lrs.Offset\n}\n\n// GetValues gets a value at a given index.\nfunc (lrs *LinearRegressionSeries) GetValues(index int) (x, y float64) {\n\tif lrs.InnerSeries == nil || lrs.InnerSeries.Len() == 0 {\n\t\treturn\n\t}\n\tif lrs.IsZero() {\n\t\tlrs.computeCoefficients()\n\t}\n\toffset := lrs.GetOffset()\n\teffectiveIndex := MinInt(index+offset, lrs.InnerSeries.Len())\n\tx, y = lrs.InnerSeries.GetValues(effectiveIndex)\n\ty = (lrs.m * lrs.normalize(x)) + lrs.b\n\treturn\n}\n\n// GetFirstValues computes the first linear regression value.\nfunc (lrs *LinearRegressionSeries) GetFirstValues() (x, y float64) {\n\tif lrs.InnerSeries == nil || lrs.InnerSeries.Len() == 0 {\n\t\treturn\n\t}\n\tif lrs.IsZero() {\n\t\tlrs.computeCoefficients()\n\t}\n\tx, y = lrs.InnerSeries.GetValues(0)\n\ty = (lrs.m * lrs.normalize(x)) + lrs.b\n\treturn\n}\n\n// GetLastValues computes the last linear regression value.\nfunc (lrs *LinearRegressionSeries) GetLastValues() (x, y float64) {\n\tif lrs.InnerSeries == nil || lrs.InnerSeries.Len() == 0 {\n\t\treturn\n\t}\n\tif lrs.IsZero() {\n\t\tlrs.computeCoefficients()\n\t}\n\tendIndex := lrs.GetEndIndex()\n\tx, y = lrs.InnerSeries.GetValues(endIndex)\n\ty = (lrs.m * lrs.normalize(x)) + lrs.b\n\treturn\n}\n\n// Render renders the series.\nfunc (lrs *LinearRegressionSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := lrs.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, lrs)\n}\n\n// Validate validates the series.\nfunc (lrs *LinearRegressionSeries) Validate() error {\n\tif lrs.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"linear regression series requires InnerSeries to be set\")\n\t}\n\treturn nil\n}\n\n// IsZero returns if we've computed the coefficients or not.\nfunc (lrs *LinearRegressionSeries) IsZero() bool {\n\treturn lrs.m == 0 && lrs.b == 0\n}\n\n//\n// internal helpers\n//\n\nfunc (lrs *LinearRegressionSeries) normalize(xvalue float64) float64 {\n\treturn (xvalue - lrs.avgx) / lrs.stddevx\n}\n\n// computeCoefficients computes the `m` and `b` terms in the linear formula given by `y = mx+b`.\nfunc (lrs *LinearRegressionSeries) computeCoefficients() {\n\tstartIndex := lrs.GetOffset()\n\tendIndex := lrs.GetEndIndex()\n\n\tp := float64(endIndex - startIndex)\n\n\txvalues := NewValueBufferWithCapacity(lrs.Len())\n\tfor index := startIndex; index < endIndex; index++ {\n\t\tx, _ := lrs.InnerSeries.GetValues(index)\n\t\txvalues.Enqueue(x)\n\t}\n\n\tlrs.avgx = Seq{xvalues}.Average()\n\tlrs.stddevx = Seq{xvalues}.StdDev()\n\n\tvar sumx, sumy, sumxx, sumxy float64\n\tfor index := startIndex; index < endIndex; index++ {\n\t\tx, y := lrs.InnerSeries.GetValues(index)\n\n\t\tx = lrs.normalize(x)\n\n\t\tsumx += x\n\t\tsumy += y\n\t\tsumxx += x * x\n\t\tsumxy += x * y\n\t}\n\n\tlrs.m = (p*sumxy - sumx*sumy) / (p*sumxx - sumx*sumx)\n\tlrs.b = (sumy / p) - (lrs.m * sumx / p)\n}\n"
        },
        {
          "name": "linear_regression_series_test.go",
          "type": "blob",
          "size": 1.8935546875,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestLinearRegressionSeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\tmainSeries := ContinuousSeries{\n\t\tName:    \"A test series\",\n\t\tXValues: LinearRange(1.0, 100.0),\n\t\tYValues: LinearRange(1.0, 100.0),\n\t}\n\n\tlinRegSeries := &LinearRegressionSeries{\n\t\tInnerSeries: mainSeries,\n\t}\n\n\tlrx0, lry0 := linRegSeries.GetValues(0)\n\ttestutil.AssertInDelta(t, 1.0, lrx0, 0.0000001)\n\ttestutil.AssertInDelta(t, 1.0, lry0, 0.0000001)\n\n\tlrxn, lryn := linRegSeries.GetLastValues()\n\ttestutil.AssertInDelta(t, 100.0, lrxn, 0.0000001)\n\ttestutil.AssertInDelta(t, 100.0, lryn, 0.0000001)\n}\n\nfunc TestLinearRegressionSeriesDesc(t *testing.T) {\n\t// replaced new assertions helper\n\n\tmainSeries := ContinuousSeries{\n\t\tName:    \"A test series\",\n\t\tXValues: LinearRange(100.0, 1.0),\n\t\tYValues: LinearRange(100.0, 1.0),\n\t}\n\n\tlinRegSeries := &LinearRegressionSeries{\n\t\tInnerSeries: mainSeries,\n\t}\n\n\tlrx0, lry0 := linRegSeries.GetValues(0)\n\ttestutil.AssertInDelta(t, 100.0, lrx0, 0.0000001)\n\ttestutil.AssertInDelta(t, 100.0, lry0, 0.0000001)\n\n\tlrxn, lryn := linRegSeries.GetLastValues()\n\ttestutil.AssertInDelta(t, 1.0, lrxn, 0.0000001)\n\ttestutil.AssertInDelta(t, 1.0, lryn, 0.0000001)\n}\n\nfunc TestLinearRegressionSeriesWindowAndOffset(t *testing.T) {\n\t// replaced new assertions helper\n\n\tmainSeries := ContinuousSeries{\n\t\tName:    \"A test series\",\n\t\tXValues: LinearRange(100.0, 1.0),\n\t\tYValues: LinearRange(100.0, 1.0),\n\t}\n\n\tlinRegSeries := &LinearRegressionSeries{\n\t\tInnerSeries: mainSeries,\n\t\tOffset:      10,\n\t\tLimit:       10,\n\t}\n\n\ttestutil.AssertEqual(t, 10, linRegSeries.Len())\n\n\tlrx0, lry0 := linRegSeries.GetValues(0)\n\ttestutil.AssertInDelta(t, 90.0, lrx0, 0.0000001)\n\ttestutil.AssertInDelta(t, 90.0, lry0, 0.0000001)\n\n\tlrxn, lryn := linRegSeries.GetLastValues()\n\ttestutil.AssertInDelta(t, 80.0, lrxn, 0.0000001)\n\ttestutil.AssertInDelta(t, 80.0, lryn, 0.0000001)\n}\n"
        },
        {
          "name": "linear_sequence.go",
          "type": "blob",
          "size": 1.8291015625,
          "content": "package chart\n\n// LinearRange returns an array of values representing the range from start to end, incremented by 1.0.\nfunc LinearRange(start, end float64) []float64 {\n\treturn Seq{NewLinearSequence().WithStart(start).WithEnd(end).WithStep(1.0)}.Values()\n}\n\n// LinearRangeWithStep returns the array values of a linear seq with a given start, end and optional step.\nfunc LinearRangeWithStep(start, end, step float64) []float64 {\n\treturn Seq{NewLinearSequence().WithStart(start).WithEnd(end).WithStep(step)}.Values()\n}\n\n// NewLinearSequence returns a new linear generator.\nfunc NewLinearSequence() *LinearSeq {\n\treturn &LinearSeq{step: 1.0}\n}\n\n// LinearSeq is a stepwise generator.\ntype LinearSeq struct {\n\tstart float64\n\tend   float64\n\tstep  float64\n}\n\n// Start returns the start value.\nfunc (lg LinearSeq) Start() float64 {\n\treturn lg.start\n}\n\n// End returns the end value.\nfunc (lg LinearSeq) End() float64 {\n\treturn lg.end\n}\n\n// Step returns the step value.\nfunc (lg LinearSeq) Step() float64 {\n\treturn lg.step\n}\n\n// Len returns the number of elements in the seq.\nfunc (lg LinearSeq) Len() int {\n\tif lg.start < lg.end {\n\t\treturn int((lg.end-lg.start)/lg.step) + 1\n\t}\n\treturn int((lg.start-lg.end)/lg.step) + 1\n}\n\n// GetValue returns the value at a given index.\nfunc (lg LinearSeq) GetValue(index int) float64 {\n\tfi := float64(index)\n\tif lg.start < lg.end {\n\t\treturn lg.start + (fi * lg.step)\n\t}\n\treturn lg.start - (fi * lg.step)\n}\n\n// WithStart sets the start and returns the linear generator.\nfunc (lg *LinearSeq) WithStart(start float64) *LinearSeq {\n\tlg.start = start\n\treturn lg\n}\n\n// WithEnd sets the end and returns the linear generator.\nfunc (lg *LinearSeq) WithEnd(end float64) *LinearSeq {\n\tlg.end = end\n\treturn lg\n}\n\n// WithStep sets the step and returns the linear generator.\nfunc (lg *LinearSeq) WithStep(step float64) *LinearSeq {\n\tlg.step = step\n\treturn lg\n}\n"
        },
        {
          "name": "linear_series.go",
          "type": "blob",
          "size": 2.7236328125,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n)\n\n// Interface Assertions.\nvar (\n\t_ Series              = (*LinearSeries)(nil)\n\t_ FirstValuesProvider = (*LinearSeries)(nil)\n\t_ LastValuesProvider  = (*LinearSeries)(nil)\n)\n\n// LinearSeries is a series that plots a line in a given domain.\ntype LinearSeries struct {\n\tName  string\n\tStyle Style\n\tYAxis YAxisType\n\n\tXValues     []float64\n\tInnerSeries LinearCoefficientProvider\n\n\tm     float64\n\tb     float64\n\tstdev float64\n\tavg   float64\n}\n\n// GetName returns the name of the time series.\nfunc (ls LinearSeries) GetName() string {\n\treturn ls.Name\n}\n\n// GetStyle returns the line style.\nfunc (ls LinearSeries) GetStyle() Style {\n\treturn ls.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (ls LinearSeries) GetYAxis() YAxisType {\n\treturn ls.YAxis\n}\n\n// Len returns the number of elements in the series.\nfunc (ls LinearSeries) Len() int {\n\treturn len(ls.XValues)\n}\n\n// GetEndIndex returns the effective limit end.\nfunc (ls LinearSeries) GetEndIndex() int {\n\treturn len(ls.XValues) - 1\n}\n\n// GetValues gets a value at a given index.\nfunc (ls *LinearSeries) GetValues(index int) (x, y float64) {\n\tif ls.InnerSeries == nil || len(ls.XValues) == 0 {\n\t\treturn\n\t}\n\tif ls.IsZero() {\n\t\tls.computeCoefficients()\n\t}\n\tx = ls.XValues[index]\n\ty = (ls.m * ls.normalize(x)) + ls.b\n\treturn\n}\n\n// GetFirstValues computes the first linear regression value.\nfunc (ls *LinearSeries) GetFirstValues() (x, y float64) {\n\tif ls.InnerSeries == nil || len(ls.XValues) == 0 {\n\t\treturn\n\t}\n\tif ls.IsZero() {\n\t\tls.computeCoefficients()\n\t}\n\tx, y = ls.GetValues(0)\n\treturn\n}\n\n// GetLastValues computes the last linear regression value.\nfunc (ls *LinearSeries) GetLastValues() (x, y float64) {\n\tif ls.InnerSeries == nil || len(ls.XValues) == 0 {\n\t\treturn\n\t}\n\tif ls.IsZero() {\n\t\tls.computeCoefficients()\n\t}\n\tx, y = ls.GetValues(ls.GetEndIndex())\n\treturn\n}\n\n// Render renders the series.\nfunc (ls *LinearSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, ls.Style.InheritFrom(defaults), ls)\n}\n\n// Validate validates the series.\nfunc (ls LinearSeries) Validate() error {\n\tif ls.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"linear regression series requires InnerSeries to be set\")\n\t}\n\treturn nil\n}\n\n// IsZero returns if the linear series has computed coefficients or not.\nfunc (ls LinearSeries) IsZero() bool {\n\treturn ls.m == 0 && ls.b == 0\n}\n\n// computeCoefficients computes the `m` and `b` terms in the linear formula given by `y = mx+b`.\nfunc (ls *LinearSeries) computeCoefficients() {\n\tls.m, ls.b, ls.stdev, ls.avg = ls.InnerSeries.Coefficients()\n}\n\nfunc (ls *LinearSeries) normalize(xvalue float64) float64 {\n\tif ls.avg > 0 && ls.stdev > 0 {\n\t\treturn (xvalue - ls.avg) / ls.stdev\n\t}\n\treturn xvalue\n}\n"
        },
        {
          "name": "logarithmic_range.go",
          "type": "blob",
          "size": 2.494140625,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// LogarithmicRange represents a boundary for a set of numbers.\ntype LogarithmicRange struct {\n\tMin        float64\n\tMax        float64\n\tDomain     int\n\tDescending bool\n}\n\n// IsDescending returns if the range is descending.\nfunc (r LogarithmicRange) IsDescending() bool {\n\treturn r.Descending\n}\n\n// IsZero returns if the LogarithmicRange has been set or not.\nfunc (r LogarithmicRange) IsZero() bool {\n\treturn (r.Min == 0 || math.IsNaN(r.Min)) &&\n\t\t(r.Max == 0 || math.IsNaN(r.Max)) &&\n\t\tr.Domain == 0\n}\n\n// GetMin gets the min value for the continuous range.\nfunc (r LogarithmicRange) GetMin() float64 {\n\treturn r.Min\n}\n\n// SetMin sets the min value for the continuous range.\nfunc (r *LogarithmicRange) SetMin(min float64) {\n\tr.Min = min\n}\n\n// GetMax returns the max value for the continuous range.\nfunc (r LogarithmicRange) GetMax() float64 {\n\treturn r.Max\n}\n\n// SetMax sets the max value for the continuous range.\nfunc (r *LogarithmicRange) SetMax(max float64) {\n\tr.Max = max\n}\n\n// GetDelta returns the difference between the min and max value.\nfunc (r LogarithmicRange) GetDelta() float64 {\n\treturn r.Max - r.Min\n}\n\n// GetDomain returns the range domain.\nfunc (r LogarithmicRange) GetDomain() int {\n\treturn r.Domain\n}\n\n// SetDomain sets the range domain.\nfunc (r *LogarithmicRange) SetDomain(domain int) {\n\tr.Domain = domain\n}\n\n// String returns a simple string for the LogarithmicRange.\nfunc (r LogarithmicRange) String() string {\n\treturn fmt.Sprintf(\"LogarithmicRange [%.2f,%.2f] => %d\", r.Min, r.Max, r.Domain)\n}\n\n// Translate maps a given value into the LogarithmicRange space. Modified version from ContinuousRange.\nfunc (r LogarithmicRange) Translate(value float64) int {\n\tif value < 1 {\n\t\treturn 0\n\t}\n\tnormalized := math.Max(value-r.Min, 1)\n\tratio := math.Log10(normalized) / math.Log10(r.GetDelta())\n\n\tif r.IsDescending() {\n\t\treturn r.Domain - int(math.Ceil(ratio*float64(r.Domain)))\n\t}\n\n\treturn int(math.Ceil(ratio * float64(r.Domain)))\n}\n\n// GetTicks calculates the needed ticks for the axis, in log scale. Only supports Y values > 0.\nfunc (r LogarithmicRange) GetTicks(render Renderer, defaults Style, vf ValueFormatter) []Tick {\n\tvar ticks []Tick\n\texponentStart := int64(math.Max(0, math.Floor(math.Log10(r.Min))))   // one below min\n\texponentEnd := int64(math.Max(0, math.Ceil(math.Log10(r.Max))))      // one above max\n\tfor exp:=exponentStart; exp<=exponentEnd; exp++ {\n\t\ttickVal := math.Pow(10, float64(exp))\n\t\tticks = append(ticks, Tick{Value: tickVal, Label: vf(tickVal)})\n\t}\n\n\treturn ticks\n}\n"
        },
        {
          "name": "logarithmic_range_test.go",
          "type": "blob",
          "size": 1.4365234375,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestLogRangeTranslate(t *testing.T) {\n\tvalues := []float64{1, 10, 100, 1000, 10000, 100000, 1000000}\n\tr := LogarithmicRange{Domain: 1000}\n\tr.Min, r.Max = MinMax(values...)\n\n\ttestutil.AssertEqual(t, 0, r.Translate(0))          // goes to bottom\n\ttestutil.AssertEqual(t, 0, r.Translate(1))          // goes to bottom\n\ttestutil.AssertEqual(t, 160, r.Translate(10))       // roughly 1/6th of max\n\ttestutil.AssertEqual(t, 500, r.Translate(1000))     // roughly 1/2 of max (1.0e6 / 1.0e3)\n\ttestutil.AssertEqual(t, 1000, r.Translate(1000000)) // max value\n}\n\nfunc TestGetTicks(t *testing.T) {\n\tvalues := []float64{35, 512, 1525122}\n\tr := LogarithmicRange{Domain: 1000}\n\tr.Min, r.Max = MinMax(values...)\n\n\tticks := r.GetTicks(nil, Style{}, FloatValueFormatter)\n\ttestutil.AssertEqual(t, 7, len(ticks))\n\ttestutil.AssertEqual(t, 10, ticks[0].Value)\n\ttestutil.AssertEqual(t, 100, ticks[1].Value)\n\ttestutil.AssertEqual(t, 10000000, ticks[6].Value)\n}\n\nfunc TestGetTicksFromHigh(t *testing.T) {\n\tvalues := []float64{1412, 352144, 1525122} // min tick should be 1000\n\tr := LogarithmicRange{}\n\tr.Min, r.Max = MinMax(values...)\n\n\tticks := r.GetTicks(nil, Style{}, FloatValueFormatter)\n\ttestutil.AssertEqual(t, 5, len(ticks))\n\ttestutil.AssertEqual(t, float64(1000), ticks[0].Value)\n\ttestutil.AssertEqual(t, float64(10000), ticks[1].Value)\n\ttestutil.AssertEqual(t, float64(10000000), ticks[4].Value)\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 3.5302734375,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\t_ Logger = (*StdoutLogger)(nil)\n)\n\n// NewLogger returns a new logger.\nfunc NewLogger(options ...LoggerOption) Logger {\n\tstl := &StdoutLogger{\n\t\tTimeFormat: time.RFC3339Nano,\n\t\tStdout:     os.Stdout,\n\t\tStderr:     os.Stderr,\n\t}\n\tfor _, option := range options {\n\t\toption(stl)\n\t}\n\treturn stl\n}\n\n// Logger is a type that implements the logging interface.\ntype Logger interface {\n\tInfo(...interface{})\n\tInfof(string, ...interface{})\n\tDebug(...interface{})\n\tDebugf(string, ...interface{})\n\tErr(error)\n\tFatalErr(error)\n\tError(...interface{})\n\tErrorf(string, ...interface{})\n}\n\n// Info logs an info message if the logger is set.\nfunc Info(log Logger, arguments ...interface{}) {\n\tif log == nil {\n\t\treturn\n\t}\n\tlog.Info(arguments...)\n}\n\n// Infof logs an info message if the logger is set.\nfunc Infof(log Logger, format string, arguments ...interface{}) {\n\tif log == nil {\n\t\treturn\n\t}\n\tlog.Infof(format, arguments...)\n}\n\n// Debug logs an debug message if the logger is set.\nfunc Debug(log Logger, arguments ...interface{}) {\n\tif log == nil {\n\t\treturn\n\t}\n\tlog.Debug(arguments...)\n}\n\n// Debugf logs an debug message if the logger is set.\nfunc Debugf(log Logger, format string, arguments ...interface{}) {\n\tif log == nil {\n\t\treturn\n\t}\n\tlog.Debugf(format, arguments...)\n}\n\n// LoggerOption mutates a stdout logger.\ntype LoggerOption = func(*StdoutLogger)\n\n//OptLoggerStdout sets the Stdout writer.\nfunc OptLoggerStdout(wr io.Writer) LoggerOption {\n\treturn func(stl *StdoutLogger) {\n\t\tstl.Stdout = wr\n\t}\n}\n\n// OptLoggerStderr sets the Stdout writer.\nfunc OptLoggerStderr(wr io.Writer) LoggerOption {\n\treturn func(stl *StdoutLogger) {\n\t\tstl.Stderr = wr\n\t}\n}\n\n// StdoutLogger is a basic logger.\ntype StdoutLogger struct {\n\tTimeFormat string\n\tStdout     io.Writer\n\tStderr     io.Writer\n}\n\n// Info writes an info message.\nfunc (l *StdoutLogger) Info(arguments ...interface{}) {\n\tl.Println(append([]interface{}{\"[INFO]\"}, arguments...)...)\n}\n\n// Infof writes an info message.\nfunc (l *StdoutLogger) Infof(format string, arguments ...interface{}) {\n\tl.Println(append([]interface{}{\"[INFO]\"}, fmt.Sprintf(format, arguments...))...)\n}\n\n// Debug writes an debug message.\nfunc (l *StdoutLogger) Debug(arguments ...interface{}) {\n\tl.Println(append([]interface{}{\"[DEBUG]\"}, arguments...)...)\n}\n\n// Debugf writes an debug message.\nfunc (l *StdoutLogger) Debugf(format string, arguments ...interface{}) {\n\tl.Println(append([]interface{}{\"[DEBUG]\"}, fmt.Sprintf(format, arguments...))...)\n}\n\n// Error writes an error message.\nfunc (l *StdoutLogger) Error(arguments ...interface{}) {\n\tl.Println(append([]interface{}{\"[ERROR]\"}, arguments...)...)\n}\n\n// Errorf writes an error message.\nfunc (l *StdoutLogger) Errorf(format string, arguments ...interface{}) {\n\tl.Println(append([]interface{}{\"[ERROR]\"}, fmt.Sprintf(format, arguments...))...)\n}\n\n// Err writes an error message.\nfunc (l *StdoutLogger) Err(err error) {\n\tif err != nil {\n\t\tl.Println(append([]interface{}{\"[ERROR]\"}, err.Error())...)\n\t}\n}\n\n// FatalErr writes an error message and exits.\nfunc (l *StdoutLogger) FatalErr(err error) {\n\tif err != nil {\n\t\tl.Println(append([]interface{}{\"[FATAL]\"}, err.Error())...)\n\t\tos.Exit(1)\n\t}\n}\n\n// Println prints a new message.\nfunc (l *StdoutLogger) Println(arguments ...interface{}) {\n\tfmt.Fprintln(l.Stdout, append([]interface{}{time.Now().UTC().Format(l.TimeFormat)}, arguments...)...)\n}\n\n// Errorln prints a new message.\nfunc (l *StdoutLogger) Errorln(arguments ...interface{}) {\n\tfmt.Fprintln(l.Stderr, append([]interface{}{time.Now().UTC().Format(l.TimeFormat)}, arguments...)...)\n}\n"
        },
        {
          "name": "macd_series.go",
          "type": "blob",
          "size": 7.224609375,
          "content": "package chart\n\nimport \"fmt\"\n\nconst (\n\t// DefaultMACDPeriodPrimary is the long window.\n\tDefaultMACDPeriodPrimary = 26\n\t// DefaultMACDPeriodSecondary is the short window.\n\tDefaultMACDPeriodSecondary = 12\n\t// DefaultMACDSignalPeriod is the signal period to compute for the MACD.\n\tDefaultMACDSignalPeriod = 9\n)\n\n// MACDSeries computes the difference between the MACD line and the MACD Signal line.\n// It is used in technical analysis and gives a lagging indicator of momentum.\ntype MACDSeries struct {\n\tName        string\n\tStyle       Style\n\tYAxis       YAxisType\n\tInnerSeries ValuesProvider\n\n\tPrimaryPeriod   int\n\tSecondaryPeriod int\n\tSignalPeriod    int\n\n\tsignal *MACDSignalSeries\n\tmacdl  *MACDLineSeries\n}\n\n// Validate validates the series.\nfunc (macd MACDSeries) Validate() error {\n\tvar err error\n\tif macd.signal != nil {\n\t\terr = macd.signal.Validate()\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tif macd.macdl != nil {\n\t\terr = macd.macdl.Validate()\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// GetPeriods returns the primary and secondary periods.\nfunc (macd MACDSeries) GetPeriods() (w1, w2, sig int) {\n\tif macd.PrimaryPeriod == 0 {\n\t\tw1 = DefaultMACDPeriodPrimary\n\t} else {\n\t\tw1 = macd.PrimaryPeriod\n\t}\n\tif macd.SecondaryPeriod == 0 {\n\t\tw2 = DefaultMACDPeriodSecondary\n\t} else {\n\t\tw2 = macd.SecondaryPeriod\n\t}\n\tif macd.SignalPeriod == 0 {\n\t\tsig = DefaultMACDSignalPeriod\n\t} else {\n\t\tsig = macd.SignalPeriod\n\t}\n\treturn\n}\n\n// GetName returns the name of the time series.\nfunc (macd MACDSeries) GetName() string {\n\treturn macd.Name\n}\n\n// GetStyle returns the line style.\nfunc (macd MACDSeries) GetStyle() Style {\n\treturn macd.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (macd MACDSeries) GetYAxis() YAxisType {\n\treturn macd.YAxis\n}\n\n// Len returns the number of elements in the series.\nfunc (macd MACDSeries) Len() int {\n\tif macd.InnerSeries == nil {\n\t\treturn 0\n\t}\n\n\treturn macd.InnerSeries.Len()\n}\n\n// GetValues gets a value at a given index. For MACD it is the signal value.\nfunc (macd *MACDSeries) GetValues(index int) (x float64, y float64) {\n\tif macd.InnerSeries == nil {\n\t\treturn\n\t}\n\n\tif macd.signal == nil || macd.macdl == nil {\n\t\tmacd.ensureChildSeries()\n\t}\n\n\t_, lv := macd.macdl.GetValues(index)\n\t_, sv := macd.signal.GetValues(index)\n\n\tx, _ = macd.InnerSeries.GetValues(index)\n\ty = lv - sv\n\n\treturn\n}\n\nfunc (macd *MACDSeries) ensureChildSeries() {\n\tw1, w2, sig := macd.GetPeriods()\n\n\tmacd.signal = &MACDSignalSeries{\n\t\tInnerSeries:     macd.InnerSeries,\n\t\tPrimaryPeriod:   w1,\n\t\tSecondaryPeriod: w2,\n\t\tSignalPeriod:    sig,\n\t}\n\n\tmacd.macdl = &MACDLineSeries{\n\t\tInnerSeries:     macd.InnerSeries,\n\t\tPrimaryPeriod:   w1,\n\t\tSecondaryPeriod: w2,\n\t}\n}\n\n// MACDSignalSeries computes the EMA of the MACDLineSeries.\ntype MACDSignalSeries struct {\n\tName        string\n\tStyle       Style\n\tYAxis       YAxisType\n\tInnerSeries ValuesProvider\n\n\tPrimaryPeriod   int\n\tSecondaryPeriod int\n\tSignalPeriod    int\n\n\tsignal *EMASeries\n}\n\n// Validate validates the series.\nfunc (macds MACDSignalSeries) Validate() error {\n\tif macds.signal != nil {\n\t\treturn macds.signal.Validate()\n\t}\n\treturn nil\n}\n\n// GetPeriods returns the primary and secondary periods.\nfunc (macds MACDSignalSeries) GetPeriods() (w1, w2, sig int) {\n\tif macds.PrimaryPeriod == 0 {\n\t\tw1 = DefaultMACDPeriodPrimary\n\t} else {\n\t\tw1 = macds.PrimaryPeriod\n\t}\n\tif macds.SecondaryPeriod == 0 {\n\t\tw2 = DefaultMACDPeriodSecondary\n\t} else {\n\t\tw2 = macds.SecondaryPeriod\n\t}\n\tif macds.SignalPeriod == 0 {\n\t\tsig = DefaultMACDSignalPeriod\n\t} else {\n\t\tsig = macds.SignalPeriod\n\t}\n\treturn\n}\n\n// GetName returns the name of the time series.\nfunc (macds MACDSignalSeries) GetName() string {\n\treturn macds.Name\n}\n\n// GetStyle returns the line style.\nfunc (macds MACDSignalSeries) GetStyle() Style {\n\treturn macds.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (macds MACDSignalSeries) GetYAxis() YAxisType {\n\treturn macds.YAxis\n}\n\n// Len returns the number of elements in the series.\nfunc (macds *MACDSignalSeries) Len() int {\n\tif macds.InnerSeries == nil {\n\t\treturn 0\n\t}\n\n\treturn macds.InnerSeries.Len()\n}\n\n// GetValues gets a value at a given index. For MACD it is the signal value.\nfunc (macds *MACDSignalSeries) GetValues(index int) (x float64, y float64) {\n\tif macds.InnerSeries == nil {\n\t\treturn\n\t}\n\n\tif macds.signal == nil {\n\t\tmacds.ensureSignal()\n\t}\n\tx, _ = macds.InnerSeries.GetValues(index)\n\t_, y = macds.signal.GetValues(index)\n\treturn\n}\n\nfunc (macds *MACDSignalSeries) ensureSignal() {\n\tw1, w2, sig := macds.GetPeriods()\n\n\tmacds.signal = &EMASeries{\n\t\tInnerSeries: &MACDLineSeries{\n\t\t\tInnerSeries:     macds.InnerSeries,\n\t\t\tPrimaryPeriod:   w1,\n\t\t\tSecondaryPeriod: w2,\n\t\t},\n\t\tPeriod: sig,\n\t}\n}\n\n// Render renders the series.\nfunc (macds *MACDSignalSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := macds.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, macds)\n}\n\n// MACDLineSeries is a series that computes the inner ema1-ema2 value as a series.\ntype MACDLineSeries struct {\n\tName        string\n\tStyle       Style\n\tYAxis       YAxisType\n\tInnerSeries ValuesProvider\n\n\tPrimaryPeriod   int\n\tSecondaryPeriod int\n\n\tema1 *EMASeries\n\tema2 *EMASeries\n\n\tSigma float64\n}\n\n// Validate validates the series.\nfunc (macdl MACDLineSeries) Validate() error {\n\tvar err error\n\tif macdl.ema1 != nil {\n\t\terr = macdl.ema1.Validate()\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tif macdl.ema2 != nil {\n\t\terr = macdl.ema2.Validate()\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tif macdl.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"MACDLineSeries: must provide an inner series\")\n\t}\n\treturn nil\n}\n\n// GetName returns the name of the time series.\nfunc (macdl MACDLineSeries) GetName() string {\n\treturn macdl.Name\n}\n\n// GetStyle returns the line style.\nfunc (macdl MACDLineSeries) GetStyle() Style {\n\treturn macdl.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (macdl MACDLineSeries) GetYAxis() YAxisType {\n\treturn macdl.YAxis\n}\n\n// GetPeriods returns the primary and secondary periods.\nfunc (macdl MACDLineSeries) GetPeriods() (w1, w2 int) {\n\tif macdl.PrimaryPeriod == 0 {\n\t\tw1 = DefaultMACDPeriodPrimary\n\t} else {\n\t\tw1 = macdl.PrimaryPeriod\n\t}\n\tif macdl.SecondaryPeriod == 0 {\n\t\tw2 = DefaultMACDPeriodSecondary\n\t} else {\n\t\tw2 = macdl.SecondaryPeriod\n\t}\n\treturn\n}\n\n// Len returns the number of elements in the series.\nfunc (macdl *MACDLineSeries) Len() int {\n\tif macdl.InnerSeries == nil {\n\t\treturn 0\n\t}\n\n\treturn macdl.InnerSeries.Len()\n}\n\n// GetValues gets a value at a given index. For MACD it is the signal value.\nfunc (macdl *MACDLineSeries) GetValues(index int) (x float64, y float64) {\n\tif macdl.InnerSeries == nil {\n\t\treturn\n\t}\n\tif macdl.ema1 == nil && macdl.ema2 == nil {\n\t\tmacdl.ensureEMASeries()\n\t}\n\n\tx, _ = macdl.InnerSeries.GetValues(index)\n\n\t_, emav1 := macdl.ema1.GetValues(index)\n\t_, emav2 := macdl.ema2.GetValues(index)\n\n\ty = emav2 - emav1\n\treturn\n}\n\nfunc (macdl *MACDLineSeries) ensureEMASeries() {\n\tw1, w2 := macdl.GetPeriods()\n\n\tmacdl.ema1 = &EMASeries{\n\t\tInnerSeries: macdl.InnerSeries,\n\t\tPeriod:      w1,\n\t}\n\tmacdl.ema2 = &EMASeries{\n\t\tInnerSeries: macdl.InnerSeries,\n\t\tPeriod:      w2,\n\t}\n}\n\n// Render renders the series.\nfunc (macdl *MACDLineSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := macdl.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, macdl)\n}\n"
        },
        {
          "name": "macd_series_test.go",
          "type": "blob",
          "size": 1.517578125,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nvar (\n\tmacdExpected = []float64{\n\t\t0,\n\t\t0.06381766382,\n\t\t0.1641441222,\n\t\t0.2817201894,\n\t\t0.4033023481,\n\t\t0.3924673744,\n\t\t0.2983093823,\n\t\t0.1561821464,\n\t\t-0.008916708129,\n\t\t-0.05210332292,\n\t\t-0.01649503993,\n\t\t0.06667130899,\n\t\t0.1751344574,\n\t\t0.1657328378,\n\t\t0.08257097469,\n\t\t-0.04265109369,\n\t\t-0.1875741257,\n\t\t-0.2091853882,\n\t\t-0.1518975486,\n\t\t-0.04781419838,\n\t\t0.08025242841,\n\t\t0.08881960494,\n\t\t0.02183529775,\n\t\t-0.08904155476,\n\t\t-0.2214141128,\n\t\t-0.2321805992,\n\t\t-0.1656331722,\n\t\t-0.05373789678,\n\t\t0.08083727586,\n\t\t0.09475354363,\n\t\t0.03209767112,\n\t\t-0.07534076818,\n\t\t-0.2050442354,\n\t\t-0.2138010557,\n\t\t-0.1458045181,\n\t\t-0.03293263556,\n\t\t0.1022243734,\n\t\t0.1163957964,\n\t\t0.05372761902,\n\t\t-0.05393941791,\n\t\t-0.1840438454,\n\t\t-0.1933365048,\n\t\t-0.1259788988,\n\t\t-0.01382225715,\n\t\t0.1205656194,\n\t\t0.1339326478,\n\t\t0.07044017167,\n\t\t-0.03805851969,\n\t\t-0.1689918111,\n\t\t-0.1791024416,\n\t}\n)\n\nfunc TestMACDSeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\tmockSeries := mockValuesProvider{\n\t\temaXValues,\n\t\temaYValues,\n\t}\n\ttestutil.AssertEqual(t, 50, mockSeries.Len())\n\n\tmas := &MACDSeries{\n\t\tInnerSeries: mockSeries,\n\t}\n\n\tvar yvalues []float64\n\tfor x := 0; x < mas.Len(); x++ {\n\t\t_, y := mas.GetValues(x)\n\t\tyvalues = append(yvalues, y)\n\t}\n\n\ttestutil.AssertNotEmpty(t, yvalues)\n\tfor index, vy := range yvalues {\n\t\ttestutil.AssertInDelta(t, vy, macdExpected[index], emaDelta, fmt.Sprintf(\"delta @ %d actual: %0.9f expected: %0.9f\", index, vy, macdExpected[index]))\n\t}\n}\n"
        },
        {
          "name": "mathutil.go",
          "type": "blob",
          "size": 5.4921875,
          "content": "package chart\n\nimport \"math\"\n\nconst (\n\t_pi   = math.Pi\n\t_2pi  = 2 * math.Pi\n\t_3pi4 = (3 * math.Pi) / 4.0\n\t_4pi3 = (4 * math.Pi) / 3.0\n\t_3pi2 = (3 * math.Pi) / 2.0\n\t_5pi4 = (5 * math.Pi) / 4.0\n\t_7pi4 = (7 * math.Pi) / 4.0\n\t_pi2  = math.Pi / 2.0\n\t_pi4  = math.Pi / 4.0\n\t_d2r  = (math.Pi / 180.0)\n\t_r2d  = (180.0 / math.Pi)\n)\n\n// MinMax returns the minimum and maximum of a given set of values.\nfunc MinMax(values ...float64) (min, max float64) {\n\tif len(values) == 0 {\n\t\treturn\n\t}\n\n\tmax = values[0]\n\tmin = values[0]\n\tvar value float64\n\tfor index := 1; index < len(values); index++ {\n\t\tvalue = values[index]\n\t\tif value < min {\n\t\t\tmin = value\n\t\t}\n\t\tif value > max {\n\t\t\tmax = value\n\t\t}\n\t}\n\treturn\n}\n\n// MinInt returns the minimum int.\nfunc MinInt(values ...int) (min int) {\n\tif len(values) == 0 {\n\t\treturn\n\t}\n\n\tmin = values[0]\n\tvar value int\n\tfor index := 1; index < len(values); index++ {\n\t\tvalue = values[index]\n\t\tif value < min {\n\t\t\tmin = value\n\t\t}\n\t}\n\treturn\n}\n\n// MaxInt returns the maximum int.\nfunc MaxInt(values ...int) (max int) {\n\tif len(values) == 0 {\n\t\treturn\n\t}\n\n\tmax = values[0]\n\tvar value int\n\tfor index := 1; index < len(values); index++ {\n\t\tvalue = values[index]\n\t\tif value > max {\n\t\t\tmax = value\n\t\t}\n\t}\n\treturn\n}\n\n// AbsInt returns the absolute value of an int.\nfunc AbsInt(value int) int {\n\tif value < 0 {\n\t\treturn -value\n\t}\n\treturn value\n}\n\n// DegreesToRadians returns degrees as radians.\nfunc DegreesToRadians(degrees float64) float64 {\n\treturn degrees * _d2r\n}\n\n// RadiansToDegrees translates a radian value to a degree value.\nfunc RadiansToDegrees(value float64) float64 {\n\treturn math.Mod(value, _2pi) * _r2d\n}\n\n// PercentToRadians converts a normalized value (0,1) to radians.\nfunc PercentToRadians(pct float64) float64 {\n\treturn DegreesToRadians(360.0 * pct)\n}\n\n// RadianAdd adds a delta to a base in radians.\nfunc RadianAdd(base, delta float64) float64 {\n\tvalue := base + delta\n\tif value > _2pi {\n\t\treturn math.Mod(value, _2pi)\n\t} else if value < 0 {\n\t\treturn math.Mod(_2pi+value, _2pi)\n\t}\n\treturn value\n}\n\n// DegreesAdd adds a delta to a base in radians.\nfunc DegreesAdd(baseDegrees, deltaDegrees float64) float64 {\n\tvalue := baseDegrees + deltaDegrees\n\tif value > _2pi {\n\t\treturn math.Mod(value, 360.0)\n\t} else if value < 0 {\n\t\treturn math.Mod(360.0+value, 360.0)\n\t}\n\treturn value\n}\n\n// DegreesToCompass returns the degree value in compass / clock orientation.\nfunc DegreesToCompass(deg float64) float64 {\n\treturn DegreesAdd(deg, -90.0)\n}\n\n// CirclePoint returns the absolute position of a circle diameter point given\n// by the radius and the theta.\nfunc CirclePoint(cx, cy int, radius, thetaRadians float64) (x, y int) {\n\tx = cx + int(radius*math.Sin(thetaRadians))\n\ty = cy - int(radius*math.Cos(thetaRadians))\n\treturn\n}\n\n// RotateCoordinate rotates a coordinate around a given center by a theta in radians.\nfunc RotateCoordinate(cx, cy, x, y int, thetaRadians float64) (rx, ry int) {\n\ttempX, tempY := float64(x-cx), float64(y-cy)\n\trotatedX := tempX*math.Cos(thetaRadians) - tempY*math.Sin(thetaRadians)\n\trotatedY := tempX*math.Sin(thetaRadians) + tempY*math.Cos(thetaRadians)\n\trx = int(rotatedX) + cx\n\try = int(rotatedY) + cy\n\treturn\n}\n\n// RoundUp rounds up to a given roundTo value.\nfunc RoundUp(value, roundTo float64) float64 {\n\tif roundTo < 0.000000000000001 {\n\t\treturn value\n\t}\n\td1 := math.Ceil(value / roundTo)\n\treturn d1 * roundTo\n}\n\n// RoundDown rounds down to a given roundTo value.\nfunc RoundDown(value, roundTo float64) float64 {\n\tif roundTo < 0.000000000000001 {\n\t\treturn value\n\t}\n\td1 := math.Floor(value / roundTo)\n\treturn d1 * roundTo\n}\n\n// Normalize returns a set of numbers on the interval [0,1] for a given set of inputs.\n// An example: 4,3,2,1 => 0.4, 0.3, 0.2, 0.1\n// Caveat; the total may be < 1.0; there are going to be issues with irrational numbers etc.\nfunc Normalize(values ...float64) []float64 {\n\tvar total float64\n\tfor _, v := range values {\n\t\ttotal += v\n\t}\n\toutput := make([]float64, len(values))\n\tfor x, v := range values {\n\t\toutput[x] = RoundDown(v/total, 0.0001)\n\t}\n\treturn output\n}\n\n// Mean returns the mean of a set of values\nfunc Mean(values ...float64) float64 {\n\treturn Sum(values...) / float64(len(values))\n}\n\n// MeanInt returns the mean of a set of integer values.\nfunc MeanInt(values ...int) int {\n\treturn SumInt(values...) / len(values)\n}\n\n// Sum sums a set of values.\nfunc Sum(values ...float64) float64 {\n\tvar total float64\n\tfor _, v := range values {\n\t\ttotal += v\n\t}\n\treturn total\n}\n\n// SumInt sums a set of values.\nfunc SumInt(values ...int) int {\n\tvar total int\n\tfor _, v := range values {\n\t\ttotal += v\n\t}\n\treturn total\n}\n\n// PercentDifference computes the percentage difference between two values.\n// The formula is (v2-v1)/v1.\nfunc PercentDifference(v1, v2 float64) float64 {\n\tif v1 == 0 {\n\t\treturn 0\n\t}\n\treturn (v2 - v1) / v1\n}\n\n// GetRoundToForDelta returns a `roundTo` value for a given delta.\nfunc GetRoundToForDelta(delta float64) float64 {\n\tstartingDeltaBound := math.Pow(10.0, 10.0)\n\tfor cursor := startingDeltaBound; cursor > 0; cursor /= 10.0 {\n\t\tif delta > cursor {\n\t\t\treturn cursor / 10.0\n\t\t}\n\t}\n\n\treturn 0.0\n}\n\n// RoundPlaces rounds an input to a given places.\nfunc RoundPlaces(input float64, places int) (rounded float64) {\n\tif math.IsNaN(input) {\n\t\treturn 0.0\n\t}\n\n\tsign := 1.0\n\tif input < 0 {\n\t\tsign = -1\n\t\tinput *= -1\n\t}\n\n\tprecision := math.Pow(10, float64(places))\n\tdigit := input * precision\n\t_, decimal := math.Modf(digit)\n\n\tif decimal >= 0.5 {\n\t\trounded = math.Ceil(digit)\n\t} else {\n\t\trounded = math.Floor(digit)\n\t}\n\n\treturn rounded / precision * sign\n}\n\nfunc f64i(value float64) int {\n\tr := RoundPlaces(value, 0)\n\treturn int(r)\n}\n"
        },
        {
          "name": "matrix",
          "type": "tree",
          "content": null
        },
        {
          "name": "min_max_series.go",
          "type": "blob",
          "size": 3.02734375,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// MinSeries draws a horizontal line at the minimum value of the inner series.\ntype MinSeries struct {\n\tName        string\n\tStyle       Style\n\tYAxis       YAxisType\n\tInnerSeries ValuesProvider\n\n\tminValue *float64\n}\n\n// GetName returns the name of the time series.\nfunc (ms MinSeries) GetName() string {\n\treturn ms.Name\n}\n\n// GetStyle returns the line style.\nfunc (ms MinSeries) GetStyle() Style {\n\treturn ms.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (ms MinSeries) GetYAxis() YAxisType {\n\treturn ms.YAxis\n}\n\n// Len returns the number of elements in the series.\nfunc (ms MinSeries) Len() int {\n\treturn ms.InnerSeries.Len()\n}\n\n// GetValues gets a value at a given index.\nfunc (ms *MinSeries) GetValues(index int) (x, y float64) {\n\tms.ensureMinValue()\n\tx, _ = ms.InnerSeries.GetValues(index)\n\ty = *ms.minValue\n\treturn\n}\n\n// Render renders the series.\nfunc (ms *MinSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := ms.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, ms)\n}\n\nfunc (ms *MinSeries) ensureMinValue() {\n\tif ms.minValue == nil {\n\t\tminValue := math.MaxFloat64\n\t\tvar y float64\n\t\tfor x := 0; x < ms.InnerSeries.Len(); x++ {\n\t\t\t_, y = ms.InnerSeries.GetValues(x)\n\t\t\tif y < minValue {\n\t\t\t\tminValue = y\n\t\t\t}\n\t\t}\n\t\tms.minValue = &minValue\n\t}\n}\n\n// Validate validates the series.\nfunc (ms *MinSeries) Validate() error {\n\tif ms.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"min series requires InnerSeries to be set\")\n\t}\n\treturn nil\n}\n\n// MaxSeries draws a horizontal line at the maximum value of the inner series.\ntype MaxSeries struct {\n\tName        string\n\tStyle       Style\n\tYAxis       YAxisType\n\tInnerSeries ValuesProvider\n\n\tmaxValue *float64\n}\n\n// GetName returns the name of the time series.\nfunc (ms MaxSeries) GetName() string {\n\treturn ms.Name\n}\n\n// GetStyle returns the line style.\nfunc (ms MaxSeries) GetStyle() Style {\n\treturn ms.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (ms MaxSeries) GetYAxis() YAxisType {\n\treturn ms.YAxis\n}\n\n// Len returns the number of elements in the series.\nfunc (ms MaxSeries) Len() int {\n\treturn ms.InnerSeries.Len()\n}\n\n// GetValues gets a value at a given index.\nfunc (ms *MaxSeries) GetValues(index int) (x, y float64) {\n\tms.ensureMaxValue()\n\tx, _ = ms.InnerSeries.GetValues(index)\n\ty = *ms.maxValue\n\treturn\n}\n\n// Render renders the series.\nfunc (ms *MaxSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := ms.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, ms)\n}\n\nfunc (ms *MaxSeries) ensureMaxValue() {\n\tif ms.maxValue == nil {\n\t\tmaxValue := -math.MaxFloat64\n\t\tvar y float64\n\t\tfor x := 0; x < ms.InnerSeries.Len(); x++ {\n\t\t\t_, y = ms.InnerSeries.GetValues(x)\n\t\t\tif y > maxValue {\n\t\t\t\tmaxValue = y\n\t\t\t}\n\t\t}\n\t\tms.maxValue = &maxValue\n\t}\n}\n\n// Validate validates the series.\nfunc (ms *MaxSeries) Validate() error {\n\tif ms.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"max series requires InnerSeries to be set\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "parse.go",
          "type": "blob",
          "size": 0.88671875,
          "content": "package chart\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// ParseFloats parses a list of floats.\nfunc ParseFloats(values ...string) ([]float64, error) {\n\tvar output []float64\n\tvar parsedValue float64\n\tvar err error\n\tvar cleaned string\n\tfor _, value := range values {\n\t\tcleaned = strings.TrimSpace(strings.Replace(value, \",\", \"\", -1))\n\t\tif cleaned == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif parsedValue, err = strconv.ParseFloat(cleaned, 64); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\toutput = append(output, parsedValue)\n\t}\n\treturn output, nil\n}\n\n// ParseTimes parses a list of times with a given format.\nfunc ParseTimes(layout string, values ...string) ([]time.Time, error) {\n\tvar output []time.Time\n\tvar parsedValue time.Time\n\tvar err error\n\tfor _, value := range values {\n\t\tif parsedValue, err = time.Parse(layout, value); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\toutput = append(output, parsedValue)\n\t}\n\treturn output, nil\n}\n"
        },
        {
          "name": "percent_change_series.go",
          "type": "blob",
          "size": 2.37890625,
          "content": "package chart\n\n// Interface Assertions.\nvar (\n\t_ Series                 = (*PercentChangeSeries)(nil)\n\t_ FirstValuesProvider    = (*PercentChangeSeries)(nil)\n\t_ LastValuesProvider     = (*PercentChangeSeries)(nil)\n\t_ ValueFormatterProvider = (*PercentChangeSeries)(nil)\n)\n\n// PercentChangeSeriesSource is a series that\n// can be used with a PercentChangeSeries\ntype PercentChangeSeriesSource interface {\n\tSeries\n\tFirstValuesProvider\n\tLastValuesProvider\n\tValuesProvider\n\tValueFormatterProvider\n}\n\n// PercentChangeSeries applies a\n// percentage difference function to a given continuous series.\ntype PercentChangeSeries struct {\n\tName        string\n\tStyle       Style\n\tYAxis       YAxisType\n\tInnerSeries PercentChangeSeriesSource\n}\n\n// GetName returns the name of the time series.\nfunc (pcs PercentChangeSeries) GetName() string {\n\treturn pcs.Name\n}\n\n// GetStyle returns the line style.\nfunc (pcs PercentChangeSeries) GetStyle() Style {\n\treturn pcs.Style\n}\n\n// Len implements part of Series.\nfunc (pcs PercentChangeSeries) Len() int {\n\treturn pcs.InnerSeries.Len()\n}\n\n// GetFirstValues implements FirstValuesProvider.\nfunc (pcs PercentChangeSeries) GetFirstValues() (x, y float64) {\n\treturn pcs.InnerSeries.GetFirstValues()\n}\n\n// GetValues gets x, y values at a given index.\nfunc (pcs PercentChangeSeries) GetValues(index int) (x, y float64) {\n\t_, fy := pcs.InnerSeries.GetFirstValues()\n\tx0, y0 := pcs.InnerSeries.GetValues(index)\n\tx = x0\n\ty = PercentDifference(fy, y0)\n\treturn\n}\n\n// GetValueFormatters returns value formatter defaults for the series.\nfunc (pcs PercentChangeSeries) GetValueFormatters() (x, y ValueFormatter) {\n\tx, _ = pcs.InnerSeries.GetValueFormatters()\n\ty = PercentValueFormatter\n\treturn\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (pcs PercentChangeSeries) GetYAxis() YAxisType {\n\treturn pcs.YAxis\n}\n\n// GetLastValues gets the last values.\nfunc (pcs PercentChangeSeries) GetLastValues() (x, y float64) {\n\t_, fy := pcs.InnerSeries.GetFirstValues()\n\tx0, y0 := pcs.InnerSeries.GetLastValues()\n\tx = x0\n\ty = PercentDifference(fy, y0)\n\treturn\n}\n\n// Render renders the series.\nfunc (pcs PercentChangeSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := pcs.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, pcs)\n}\n\n// Validate validates the series.\nfunc (pcs PercentChangeSeries) Validate() error {\n\treturn pcs.InnerSeries.Validate()\n}\n"
        },
        {
          "name": "percent_change_series_test.go",
          "type": "blob",
          "size": 0.724609375,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestPercentageDifferenceSeries(t *testing.T) {\n\t// replaced new assertions helper\n\n\tcs := ContinuousSeries{\n\t\tXValues: LinearRange(1.0, 10.0),\n\t\tYValues: LinearRange(1.0, 10.0),\n\t}\n\n\tpcs := PercentChangeSeries{\n\t\tName:        \"Test Series\",\n\t\tInnerSeries: cs,\n\t}\n\n\ttestutil.AssertEqual(t, \"Test Series\", pcs.GetName())\n\ttestutil.AssertEqual(t, 10, pcs.Len())\n\tx0, y0 := pcs.GetValues(0)\n\ttestutil.AssertEqual(t, 1.0, x0)\n\ttestutil.AssertEqual(t, 0, y0)\n\n\txn, yn := pcs.GetValues(9)\n\ttestutil.AssertEqual(t, 10.0, xn)\n\ttestutil.AssertEqual(t, 9.0, yn)\n\n\txn, yn = pcs.GetLastValues()\n\ttestutil.AssertEqual(t, 10.0, xn)\n\ttestutil.AssertEqual(t, 9.0, yn)\n}\n"
        },
        {
          "name": "pie_chart.go",
          "type": "blob",
          "size": 7.0546875,
          "content": "package chart\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/golang/freetype/truetype\"\n)\n\n// PieChart is a chart that draws sections of a circle based on percentages.\ntype PieChart struct {\n\tTitle      string\n\tTitleStyle Style\n\n\tColorPalette ColorPalette\n\n\tWidth  int\n\tHeight int\n\tDPI    float64\n\n\tBackground Style\n\tCanvas     Style\n\tSliceStyle Style\n\n\tFont        *truetype.Font\n\tdefaultFont *truetype.Font\n\n\tValues   []Value\n\tElements []Renderable\n}\n\n// GetDPI returns the dpi for the chart.\nfunc (pc PieChart) GetDPI(defaults ...float64) float64 {\n\tif pc.DPI == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn DefaultDPI\n\t}\n\treturn pc.DPI\n}\n\n// GetFont returns the text font.\nfunc (pc PieChart) GetFont() *truetype.Font {\n\tif pc.Font == nil {\n\t\treturn pc.defaultFont\n\t}\n\treturn pc.Font\n}\n\n// GetWidth returns the chart width or the default value.\nfunc (pc PieChart) GetWidth() int {\n\tif pc.Width == 0 {\n\t\treturn DefaultChartWidth\n\t}\n\treturn pc.Width\n}\n\n// GetHeight returns the chart height or the default value.\nfunc (pc PieChart) GetHeight() int {\n\tif pc.Height == 0 {\n\t\treturn DefaultChartWidth\n\t}\n\treturn pc.Height\n}\n\n// Render renders the chart with the given renderer to the given io.Writer.\nfunc (pc PieChart) Render(rp RendererProvider, w io.Writer) error {\n\tif len(pc.Values) == 0 {\n\t\treturn errors.New(\"please provide at least one value\")\n\t}\n\n\tr, err := rp(pc.GetWidth(), pc.GetHeight())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif pc.Font == nil {\n\t\tdefaultFont, err := GetDefaultFont()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpc.defaultFont = defaultFont\n\t}\n\tr.SetDPI(pc.GetDPI(DefaultDPI))\n\n\tcanvasBox := pc.getDefaultCanvasBox()\n\tcanvasBox = pc.getCircleAdjustedCanvasBox(canvasBox)\n\n\tpc.drawBackground(r)\n\tpc.drawCanvas(r, canvasBox)\n\n\tfinalValues, err := pc.finalizeValues(pc.Values)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpc.drawSlices(r, canvasBox, finalValues)\n\tpc.drawTitle(r)\n\tfor _, a := range pc.Elements {\n\t\ta(r, canvasBox, pc.styleDefaultsElements())\n\t}\n\n\treturn r.Save(w)\n}\n\nfunc (pc PieChart) drawBackground(r Renderer) {\n\tDraw.Box(r, Box{\n\t\tRight:  pc.GetWidth(),\n\t\tBottom: pc.GetHeight(),\n\t}, pc.getBackgroundStyle())\n}\n\nfunc (pc PieChart) drawCanvas(r Renderer, canvasBox Box) {\n\tDraw.Box(r, canvasBox, pc.getCanvasStyle())\n}\n\nfunc (pc PieChart) drawTitle(r Renderer) {\n\tif len(pc.Title) > 0 && !pc.TitleStyle.Hidden {\n\t\tDraw.TextWithin(r, pc.Title, pc.Box(), pc.styleDefaultsTitle())\n\t}\n}\n\nfunc (pc PieChart) drawSlices(r Renderer, canvasBox Box, values []Value) {\n\tcx, cy := canvasBox.Center()\n\tdiameter := MinInt(canvasBox.Width(), canvasBox.Height())\n\tradius := float64(diameter >> 1)\n\tlabelRadius := (radius * 2.0) / 3.0\n\n\t// draw the pie slices\n\tvar rads, delta, delta2, total float64\n\tvar lx, ly int\n\n\tif len(values) == 1 {\n\t\tpc.stylePieChartValue(0).WriteToRenderer(r)\n\t\tr.MoveTo(cx, cy)\n\t\tr.Circle(radius, cx, cy)\n\t} else {\n\t\tfor index, v := range values {\n\t\t\tv.Style.InheritFrom(pc.stylePieChartValue(index)).WriteToRenderer(r)\n\n\t\t\tr.MoveTo(cx, cy)\n\t\t\trads = PercentToRadians(total)\n\t\t\tdelta = PercentToRadians(v.Value)\n\n\t\t\tr.ArcTo(cx, cy, radius, radius, rads, delta)\n\n\t\t\tr.LineTo(cx, cy)\n\t\t\tr.Close()\n\t\t\tr.FillStroke()\n\t\t\ttotal = total + v.Value\n\t\t}\n\t}\n\n\t// draw the labels\n\ttotal = 0\n\tfor index, v := range values {\n\t\tv.Style.InheritFrom(pc.stylePieChartValue(index)).WriteToRenderer(r)\n\t\tif len(v.Label) > 0 {\n\t\t\tdelta2 = PercentToRadians(total + (v.Value / 2.0))\n\t\t\tdelta2 = RadianAdd(delta2, _pi2)\n\t\t\tlx, ly = CirclePoint(cx, cy, labelRadius, delta2)\n\n\t\t\ttb := r.MeasureText(v.Label)\n\t\t\tlx = lx - (tb.Width() >> 1)\n\t\t\tly = ly + (tb.Height() >> 1)\n\n\t\t\tif lx < 0 {\n\t\t\t\tlx = 0\n\t\t\t}\n\t\t\tif ly < 0 {\n\t\t\t\tlx = 0\n\t\t\t}\n\n\t\t\tr.Text(v.Label, lx, ly)\n\t\t}\n\t\ttotal = total + v.Value\n\t}\n}\n\nfunc (pc PieChart) finalizeValues(values []Value) ([]Value, error) {\n\tfinalValues := Values(values).Normalize()\n\tif len(finalValues) == 0 {\n\t\treturn nil, fmt.Errorf(\"pie chart must contain at least (1) non-zero value\")\n\t}\n\treturn finalValues, nil\n}\n\nfunc (pc PieChart) getDefaultCanvasBox() Box {\n\treturn pc.Box()\n}\n\nfunc (pc PieChart) getCircleAdjustedCanvasBox(canvasBox Box) Box {\n\tcircleDiameter := MinInt(canvasBox.Width(), canvasBox.Height())\n\n\tsquare := Box{\n\t\tRight:  circleDiameter,\n\t\tBottom: circleDiameter,\n\t}\n\n\treturn canvasBox.Fit(square)\n}\n\nfunc (pc PieChart) getBackgroundStyle() Style {\n\treturn pc.Background.InheritFrom(pc.styleDefaultsBackground())\n}\n\nfunc (pc PieChart) getCanvasStyle() Style {\n\treturn pc.Canvas.InheritFrom(pc.styleDefaultsCanvas())\n}\n\nfunc (pc PieChart) styleDefaultsCanvas() Style {\n\treturn Style{\n\t\tFillColor:   pc.GetColorPalette().CanvasColor(),\n\t\tStrokeColor: pc.GetColorPalette().CanvasStrokeColor(),\n\t\tStrokeWidth: DefaultStrokeWidth,\n\t}\n}\n\nfunc (pc PieChart) styleDefaultsPieChartValue() Style {\n\treturn Style{\n\t\tStrokeColor: pc.GetColorPalette().TextColor(),\n\t\tStrokeWidth: 5.0,\n\t\tFillColor:   pc.GetColorPalette().TextColor(),\n\t}\n}\n\nfunc (pc PieChart) stylePieChartValue(index int) Style {\n\treturn pc.SliceStyle.InheritFrom(Style{\n\t\tStrokeColor: ColorWhite,\n\t\tStrokeWidth: 5.0,\n\t\tFillColor:   pc.GetColorPalette().GetSeriesColor(index),\n\t\tFontSize:    pc.getScaledFontSize(),\n\t\tFontColor:   pc.GetColorPalette().TextColor(),\n\t\tFont:        pc.GetFont(),\n\t})\n}\n\nfunc (pc PieChart) getScaledFontSize() float64 {\n\teffectiveDimension := MinInt(pc.GetWidth(), pc.GetHeight())\n\tif effectiveDimension >= 2048 {\n\t\treturn 48.0\n\t} else if effectiveDimension >= 1024 {\n\t\treturn 24.0\n\t} else if effectiveDimension > 512 {\n\t\treturn 18.0\n\t} else if effectiveDimension > 256 {\n\t\treturn 12.0\n\t}\n\treturn 10.0\n}\n\nfunc (pc PieChart) styleDefaultsBackground() Style {\n\treturn Style{\n\t\tFillColor:   pc.GetColorPalette().BackgroundColor(),\n\t\tStrokeColor: pc.GetColorPalette().BackgroundStrokeColor(),\n\t\tStrokeWidth: DefaultStrokeWidth,\n\t}\n}\n\nfunc (pc PieChart) styleDefaultsElements() Style {\n\treturn Style{\n\t\tFont: pc.GetFont(),\n\t}\n}\n\nfunc (pc PieChart) styleDefaultsTitle() Style {\n\treturn pc.TitleStyle.InheritFrom(Style{\n\t\tFontColor:           pc.GetColorPalette().TextColor(),\n\t\tFont:                pc.GetFont(),\n\t\tFontSize:            pc.getTitleFontSize(),\n\t\tTextHorizontalAlign: TextHorizontalAlignCenter,\n\t\tTextVerticalAlign:   TextVerticalAlignTop,\n\t\tTextWrap:            TextWrapWord,\n\t})\n}\n\nfunc (pc PieChart) getTitleFontSize() float64 {\n\teffectiveDimension := MinInt(pc.GetWidth(), pc.GetHeight())\n\tif effectiveDimension >= 2048 {\n\t\treturn 48\n\t} else if effectiveDimension >= 1024 {\n\t\treturn 24\n\t} else if effectiveDimension >= 512 {\n\t\treturn 18\n\t} else if effectiveDimension >= 256 {\n\t\treturn 12\n\t}\n\treturn 10\n}\n\n// GetColorPalette returns the color palette for the chart.\nfunc (pc PieChart) GetColorPalette() ColorPalette {\n\tif pc.ColorPalette != nil {\n\t\treturn pc.ColorPalette\n\t}\n\treturn AlternateColorPalette\n}\n\n// Box returns the chart bounds as a box.\nfunc (pc PieChart) Box() Box {\n\tdpr := pc.Background.Padding.GetRight(DefaultBackgroundPadding.Right)\n\tdpb := pc.Background.Padding.GetBottom(DefaultBackgroundPadding.Bottom)\n\n\treturn Box{\n\t\tTop:    pc.Background.Padding.GetTop(DefaultBackgroundPadding.Top),\n\t\tLeft:   pc.Background.Padding.GetLeft(DefaultBackgroundPadding.Left),\n\t\tRight:  pc.GetWidth() - dpr,\n\t\tBottom: pc.GetHeight() - dpb,\n\t}\n}\n"
        },
        {
          "name": "pie_chart_test.go",
          "type": "blob",
          "size": 1.2607421875,
          "content": "package chart\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestPieChart(t *testing.T) {\n\t// replaced new assertions helper\n\n\tpie := PieChart{\n\t\tCanvas: Style{\n\t\t\tFillColor: ColorLightGray,\n\t\t},\n\t\tValues: []Value{\n\t\t\t{Value: 10, Label: \"Blue\"},\n\t\t\t{Value: 9, Label: \"Green\"},\n\t\t\t{Value: 8, Label: \"Gray\"},\n\t\t\t{Value: 7, Label: \"Orange\"},\n\t\t\t{Value: 6, Label: \"HEANG\"},\n\t\t\t{Value: 5, Label: \"??\"},\n\t\t\t{Value: 2, Label: \"!!\"},\n\t\t},\n\t}\n\n\tb := bytes.NewBuffer([]byte{})\n\tpie.Render(PNG, b)\n\ttestutil.AssertNotZero(t, b.Len())\n}\n\nfunc TestPieChartDropsZeroValues(t *testing.T) {\n\t// replaced new assertions helper\n\n\tpie := PieChart{\n\t\tCanvas: Style{\n\t\t\tFillColor: ColorLightGray,\n\t\t},\n\t\tValues: []Value{\n\t\t\t{Value: 5, Label: \"Blue\"},\n\t\t\t{Value: 5, Label: \"Green\"},\n\t\t\t{Value: 0, Label: \"Gray\"},\n\t\t},\n\t}\n\n\tb := bytes.NewBuffer([]byte{})\n\terr := pie.Render(PNG, b)\n\ttestutil.AssertNil(t, err)\n}\n\nfunc TestPieChartAllZeroValues(t *testing.T) {\n\t// replaced new assertions helper\n\n\tpie := PieChart{\n\t\tCanvas: Style{\n\t\t\tFillColor: ColorLightGray,\n\t\t},\n\t\tValues: []Value{\n\t\t\t{Value: 0, Label: \"Blue\"},\n\t\t\t{Value: 0, Label: \"Green\"},\n\t\t\t{Value: 0, Label: \"Gray\"},\n\t\t},\n\t}\n\n\tb := bytes.NewBuffer([]byte{})\n\terr := pie.Render(PNG, b)\n\ttestutil.AssertNotNil(t, err)\n}\n"
        },
        {
          "name": "polynomial_regression_series.go",
          "type": "blob",
          "size": 4.3583984375,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\n\t\"github.com/wcharczuk/go-chart/v2/matrix\"\n)\n\n// Interface Assertions.\nvar (\n\t_ Series              = (*PolynomialRegressionSeries)(nil)\n\t_ FirstValuesProvider = (*PolynomialRegressionSeries)(nil)\n\t_ LastValuesProvider  = (*PolynomialRegressionSeries)(nil)\n)\n\n// PolynomialRegressionSeries implements a polynomial regression over a given\n// inner series.\ntype PolynomialRegressionSeries struct {\n\tName  string\n\tStyle Style\n\tYAxis YAxisType\n\n\tLimit       int\n\tOffset      int\n\tDegree      int\n\tInnerSeries ValuesProvider\n\n\tcoeffs []float64\n}\n\n// GetName returns the name of the time series.\nfunc (prs PolynomialRegressionSeries) GetName() string {\n\treturn prs.Name\n}\n\n// GetStyle returns the line style.\nfunc (prs PolynomialRegressionSeries) GetStyle() Style {\n\treturn prs.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (prs PolynomialRegressionSeries) GetYAxis() YAxisType {\n\treturn prs.YAxis\n}\n\n// Len returns the number of elements in the series.\nfunc (prs PolynomialRegressionSeries) Len() int {\n\treturn MinInt(prs.GetLimit(), prs.InnerSeries.Len()-prs.GetOffset())\n}\n\n// GetLimit returns the window size.\nfunc (prs PolynomialRegressionSeries) GetLimit() int {\n\tif prs.Limit == 0 {\n\t\treturn prs.InnerSeries.Len()\n\t}\n\treturn prs.Limit\n}\n\n// GetEndIndex returns the effective limit end.\nfunc (prs PolynomialRegressionSeries) GetEndIndex() int {\n\twindowEnd := prs.GetOffset() + prs.GetLimit()\n\tinnerSeriesLastIndex := prs.InnerSeries.Len() - 1\n\treturn MinInt(windowEnd, innerSeriesLastIndex)\n}\n\n// GetOffset returns the data offset.\nfunc (prs PolynomialRegressionSeries) GetOffset() int {\n\tif prs.Offset == 0 {\n\t\treturn 0\n\t}\n\treturn prs.Offset\n}\n\n// Validate validates the series.\nfunc (prs *PolynomialRegressionSeries) Validate() error {\n\tif prs.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"linear regression series requires InnerSeries to be set\")\n\t}\n\n\tendIndex := prs.GetEndIndex()\n\tif endIndex >= prs.InnerSeries.Len() {\n\t\treturn fmt.Errorf(\"invalid window; inner series has length %d but end index is %d\", prs.InnerSeries.Len(), endIndex)\n\t}\n\n\treturn nil\n}\n\n// GetValues returns the series value for a given index.\nfunc (prs *PolynomialRegressionSeries) GetValues(index int) (x, y float64) {\n\tif prs.InnerSeries == nil || prs.InnerSeries.Len() == 0 {\n\t\treturn\n\t}\n\n\tif prs.coeffs == nil {\n\t\tcoeffs, err := prs.computeCoefficients()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tprs.coeffs = coeffs\n\t}\n\n\toffset := prs.GetOffset()\n\teffectiveIndex := MinInt(index+offset, prs.InnerSeries.Len())\n\tx, y = prs.InnerSeries.GetValues(effectiveIndex)\n\ty = prs.apply(x)\n\treturn\n}\n\n// GetFirstValues computes the first poly regression value.\nfunc (prs *PolynomialRegressionSeries) GetFirstValues() (x, y float64) {\n\tif prs.InnerSeries == nil || prs.InnerSeries.Len() == 0 {\n\t\treturn\n\t}\n\tif prs.coeffs == nil {\n\t\tcoeffs, err := prs.computeCoefficients()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tprs.coeffs = coeffs\n\t}\n\tx, y = prs.InnerSeries.GetValues(0)\n\ty = prs.apply(x)\n\treturn\n}\n\n// GetLastValues computes the last poly regression value.\nfunc (prs *PolynomialRegressionSeries) GetLastValues() (x, y float64) {\n\tif prs.InnerSeries == nil || prs.InnerSeries.Len() == 0 {\n\t\treturn\n\t}\n\tif prs.coeffs == nil {\n\t\tcoeffs, err := prs.computeCoefficients()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tprs.coeffs = coeffs\n\t}\n\tendIndex := prs.GetEndIndex()\n\tx, y = prs.InnerSeries.GetValues(endIndex)\n\ty = prs.apply(x)\n\treturn\n}\n\nfunc (prs *PolynomialRegressionSeries) apply(v float64) (out float64) {\n\tfor index, coeff := range prs.coeffs {\n\t\tout = out + (coeff * math.Pow(v, float64(index)))\n\t}\n\treturn\n}\n\nfunc (prs *PolynomialRegressionSeries) computeCoefficients() ([]float64, error) {\n\txvalues, yvalues := prs.values()\n\treturn matrix.Poly(xvalues, yvalues, prs.Degree)\n}\n\nfunc (prs *PolynomialRegressionSeries) values() (xvalues, yvalues []float64) {\n\tstartIndex := prs.GetOffset()\n\tendIndex := prs.GetEndIndex()\n\n\txvalues = make([]float64, endIndex-startIndex)\n\tyvalues = make([]float64, endIndex-startIndex)\n\n\tfor index := startIndex; index < endIndex; index++ {\n\t\tx, y := prs.InnerSeries.GetValues(index)\n\t\txvalues[index-startIndex] = x\n\t\tyvalues[index-startIndex] = y\n\t}\n\n\treturn\n}\n\n// Render renders the series.\nfunc (prs *PolynomialRegressionSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := prs.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, prs)\n}\n"
        },
        {
          "name": "polynomial_regression_test.go",
          "type": "blob",
          "size": 0.6005859375,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/matrix\"\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestPolynomialRegression(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvar xv []float64\n\tvar yv []float64\n\n\tfor i := 0; i < 100; i++ {\n\t\txv = append(xv, float64(i))\n\t\tyv = append(yv, float64(i*i))\n\t}\n\n\tvalues := ContinuousSeries{\n\t\tXValues: xv,\n\t\tYValues: yv,\n\t}\n\n\tpoly := &PolynomialRegressionSeries{\n\t\tInnerSeries: values,\n\t\tDegree:      2,\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\t_, y := poly.GetValues(i)\n\t\ttestutil.AssertInDelta(t, float64(i*i), y, matrix.DefaultEpsilon)\n\t}\n}\n"
        },
        {
          "name": "random_sequence.go",
          "type": "blob",
          "size": 1.837890625,
          "content": "package chart\n\nimport (\n\t\"math\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nvar (\n\t_ Sequence = (*RandomSeq)(nil)\n)\n\n// RandomValues returns an array of random values.\nfunc RandomValues(count int) []float64 {\n\treturn Seq{NewRandomSequence().WithLen(count)}.Values()\n}\n\n// RandomValuesWithMax returns an array of random values with a given average.\nfunc RandomValuesWithMax(count int, max float64) []float64 {\n\treturn Seq{NewRandomSequence().WithMax(max).WithLen(count)}.Values()\n}\n\n// NewRandomSequence creates a new random seq.\nfunc NewRandomSequence() *RandomSeq {\n\treturn &RandomSeq{\n\t\trnd: rand.New(rand.NewSource(time.Now().Unix())),\n\t}\n}\n\n// RandomSeq is a random number seq generator.\ntype RandomSeq struct {\n\trnd *rand.Rand\n\tmax *float64\n\tmin *float64\n\tlen *int\n}\n\n// Len returns the number of elements that will be generated.\nfunc (r *RandomSeq) Len() int {\n\tif r.len != nil {\n\t\treturn *r.len\n\t}\n\treturn math.MaxInt32\n}\n\n// GetValue returns the value.\nfunc (r *RandomSeq) GetValue(_ int) float64 {\n\tif r.min != nil && r.max != nil {\n\t\tvar delta float64\n\n\t\tif *r.max > *r.min {\n\t\t\tdelta = *r.max - *r.min\n\t\t} else {\n\t\t\tdelta = *r.min - *r.max\n\t\t}\n\n\t\treturn *r.min + (r.rnd.Float64() * delta)\n\t} else if r.max != nil {\n\t\treturn r.rnd.Float64() * *r.max\n\t} else if r.min != nil {\n\t\treturn *r.min + (r.rnd.Float64())\n\t}\n\treturn r.rnd.Float64()\n}\n\n// WithLen sets a maximum len\nfunc (r *RandomSeq) WithLen(length int) *RandomSeq {\n\tr.len = &length\n\treturn r\n}\n\n// Min returns the minimum value.\nfunc (r RandomSeq) Min() *float64 {\n\treturn r.min\n}\n\n// WithMin sets the scale and returns the Random.\nfunc (r *RandomSeq) WithMin(min float64) *RandomSeq {\n\tr.min = &min\n\treturn r\n}\n\n// Max returns the maximum value.\nfunc (r RandomSeq) Max() *float64 {\n\treturn r.max\n}\n\n// WithMax sets the average and returns the Random.\nfunc (r *RandomSeq) WithMax(max float64) *RandomSeq {\n\tr.max = &max\n\treturn r\n}\n"
        },
        {
          "name": "range.go",
          "type": "blob",
          "size": 0.7470703125,
          "content": "package chart\n\n// NameProvider is a type that returns a name.\ntype NameProvider interface {\n\tGetName() string\n}\n\n// StyleProvider is a type that returns a style.\ntype StyleProvider interface {\n\tGetStyle() Style\n}\n\n// IsZeroable is a type that returns if it's been set or not.\ntype IsZeroable interface {\n\tIsZero() bool\n}\n\n// Stringable is a type that has a string representation.\ntype Stringable interface {\n\tString() string\n}\n\n// Range is a common interface for a range of values.\ntype Range interface {\n\tStringable\n\tIsZeroable\n\n\tGetMin() float64\n\tSetMin(min float64)\n\n\tGetMax() float64\n\tSetMax(max float64)\n\n\tGetDelta() float64\n\n\tGetDomain() int\n\tSetDomain(domain int)\n\n\tIsDescending() bool\n\n\t// Translate the range to the domain.\n\tTranslate(value float64) int\n}\n"
        },
        {
          "name": "raster_renderer.go",
          "type": "blob",
          "size": 5.435546875,
          "content": "package chart\n\nimport (\n\t\"image\"\n\t\"image/png\"\n\t\"io\"\n\t\"math\"\n\n\t\"github.com/golang/freetype/truetype\"\n\t\"github.com/wcharczuk/go-chart/v2/drawing\"\n)\n\n// PNG returns a new png/raster renderer.\nfunc PNG(width, height int) (Renderer, error) {\n\ti := image.NewRGBA(image.Rect(0, 0, width, height))\n\tgc, err := drawing.NewRasterGraphicContext(i)\n\tif err == nil {\n\t\treturn &rasterRenderer{\n\t\t\ti:  i,\n\t\t\tgc: gc,\n\t\t}, nil\n\t}\n\treturn nil, err\n}\n\n// rasterRenderer renders chart commands to a bitmap.\ntype rasterRenderer struct {\n\ti  *image.RGBA\n\tgc *drawing.RasterGraphicContext\n\n\trotateRadians *float64\n\n\ts Style\n}\n\nfunc (rr *rasterRenderer) ResetStyle() {\n\trr.s = Style{Font: rr.s.Font}\n\trr.ClearTextRotation()\n}\n\n// GetDPI returns the dpi.\nfunc (rr *rasterRenderer) GetDPI() float64 {\n\treturn rr.gc.GetDPI()\n}\n\n// SetDPI implements the interface method.\nfunc (rr *rasterRenderer) SetDPI(dpi float64) {\n\trr.gc.SetDPI(dpi)\n}\n\n// SetClassName implements the interface method. However, PNGs have no classes.\nfunc (rr *rasterRenderer) SetClassName(_ string) {}\n\n// SetStrokeColor implements the interface method.\nfunc (rr *rasterRenderer) SetStrokeColor(c drawing.Color) {\n\trr.s.StrokeColor = c\n}\n\n// SetLineWidth implements the interface method.\nfunc (rr *rasterRenderer) SetStrokeWidth(width float64) {\n\trr.s.StrokeWidth = width\n}\n\n// StrokeDashArray sets the stroke dash array.\nfunc (rr *rasterRenderer) SetStrokeDashArray(dashArray []float64) {\n\trr.s.StrokeDashArray = dashArray\n}\n\n// SetFillColor implements the interface method.\nfunc (rr *rasterRenderer) SetFillColor(c drawing.Color) {\n\trr.s.FillColor = c\n}\n\n// MoveTo implements the interface method.\nfunc (rr *rasterRenderer) MoveTo(x, y int) {\n\trr.gc.MoveTo(float64(x), float64(y))\n}\n\n// LineTo implements the interface method.\nfunc (rr *rasterRenderer) LineTo(x, y int) {\n\trr.gc.LineTo(float64(x), float64(y))\n}\n\n// QuadCurveTo implements the interface method.\nfunc (rr *rasterRenderer) QuadCurveTo(cx, cy, x, y int) {\n\trr.gc.QuadCurveTo(float64(cx), float64(cy), float64(x), float64(y))\n}\n\n// ArcTo implements the interface method.\nfunc (rr *rasterRenderer) ArcTo(cx, cy int, rx, ry, startAngle, delta float64) {\n\trr.gc.ArcTo(float64(cx), float64(cy), rx, ry, startAngle, delta)\n}\n\n// Close implements the interface method.\nfunc (rr *rasterRenderer) Close() {\n\trr.gc.Close()\n}\n\n// Stroke implements the interface method.\nfunc (rr *rasterRenderer) Stroke() {\n\trr.gc.SetStrokeColor(rr.s.StrokeColor)\n\trr.gc.SetLineWidth(rr.s.StrokeWidth)\n\trr.gc.SetLineDash(rr.s.StrokeDashArray, 0)\n\trr.gc.Stroke()\n}\n\n// Fill implements the interface method.\nfunc (rr *rasterRenderer) Fill() {\n\trr.gc.SetFillColor(rr.s.FillColor)\n\trr.gc.Fill()\n}\n\n// FillStroke implements the interface method.\nfunc (rr *rasterRenderer) FillStroke() {\n\trr.gc.SetFillColor(rr.s.FillColor)\n\trr.gc.SetStrokeColor(rr.s.StrokeColor)\n\trr.gc.SetLineWidth(rr.s.StrokeWidth)\n\trr.gc.SetLineDash(rr.s.StrokeDashArray, 0)\n\trr.gc.FillStroke()\n}\n\n// Circle fully draws a circle at a given point but does not apply the fill or stroke.\nfunc (rr *rasterRenderer) Circle(radius float64, x, y int) {\n\txf := float64(x)\n\tyf := float64(y)\n\n\trr.gc.MoveTo(xf-radius, yf)                            //9\n\trr.gc.QuadCurveTo(xf-radius, yf-radius, xf, yf-radius) //12\n\trr.gc.QuadCurveTo(xf+radius, yf-radius, xf+radius, yf) //3\n\trr.gc.QuadCurveTo(xf+radius, yf+radius, xf, yf+radius) //6\n\trr.gc.QuadCurveTo(xf-radius, yf+radius, xf-radius, yf) //9\n}\n\n// SetFont implements the interface method.\nfunc (rr *rasterRenderer) SetFont(f *truetype.Font) {\n\trr.s.Font = f\n}\n\n// SetFontSize implements the interface method.\nfunc (rr *rasterRenderer) SetFontSize(size float64) {\n\trr.s.FontSize = size\n}\n\n// SetFontColor implements the interface method.\nfunc (rr *rasterRenderer) SetFontColor(c drawing.Color) {\n\trr.s.FontColor = c\n}\n\n// Text implements the interface method.\nfunc (rr *rasterRenderer) Text(body string, x, y int) {\n\txf, yf := rr.getCoords(x, y)\n\trr.gc.SetFont(rr.s.Font)\n\trr.gc.SetFontSize(rr.s.FontSize)\n\trr.gc.SetFillColor(rr.s.FontColor)\n\trr.gc.CreateStringPath(body, float64(xf), float64(yf))\n\trr.gc.Fill()\n}\n\n// MeasureText returns the height and width in pixels of a string.\nfunc (rr *rasterRenderer) MeasureText(body string) Box {\n\trr.gc.SetFont(rr.s.Font)\n\trr.gc.SetFontSize(rr.s.FontSize)\n\trr.gc.SetFillColor(rr.s.FontColor)\n\tl, t, r, b, err := rr.gc.GetStringBounds(body)\n\tif err != nil {\n\t\treturn Box{}\n\t}\n\tif l < 0 {\n\t\tr = r - l // equivalent to r+(-1*l)\n\t\tl = 0\n\t}\n\tif t < 0 {\n\t\tb = b - t\n\t\tt = 0\n\t}\n\n\tif l > 0 {\n\t\tr = r + l\n\t\tl = 0\n\t}\n\n\tif t > 0 {\n\t\tb = b + t\n\t\tt = 0\n\t}\n\n\ttextBox := Box{\n\t\tTop:    int(math.Ceil(t)),\n\t\tLeft:   int(math.Ceil(l)),\n\t\tRight:  int(math.Ceil(r)),\n\t\tBottom: int(math.Ceil(b)),\n\t}\n\tif rr.rotateRadians == nil {\n\t\treturn textBox\n\t}\n\n\treturn textBox.Corners().Rotate(RadiansToDegrees(*rr.rotateRadians)).Box()\n}\n\n// SetTextRotation sets a text rotation.\nfunc (rr *rasterRenderer) SetTextRotation(radians float64) {\n\trr.rotateRadians = &radians\n}\n\nfunc (rr *rasterRenderer) getCoords(x, y int) (xf, yf int) {\n\tif rr.rotateRadians == nil {\n\t\txf = x\n\t\tyf = y\n\t\treturn\n\t}\n\n\trr.gc.Translate(float64(x), float64(y))\n\trr.gc.Rotate(*rr.rotateRadians)\n\treturn\n}\n\n// ClearTextRotation clears text rotation.\nfunc (rr *rasterRenderer) ClearTextRotation() {\n\trr.gc.SetMatrixTransform(drawing.NewIdentityMatrix())\n\trr.rotateRadians = nil\n}\n\n// Save implements the interface method.\nfunc (rr *rasterRenderer) Save(w io.Writer) error {\n\tif typed, isTyped := w.(RGBACollector); isTyped {\n\t\ttyped.SetRGBA(rr.i)\n\t\treturn nil\n\t}\n\treturn png.Encode(w, rr.i)\n}\n"
        },
        {
          "name": "renderable.go",
          "type": "blob",
          "size": 0.162109375,
          "content": "package chart\n\n// Renderable is a function that can be called to render custom elements on the chart.\ntype Renderable func(r Renderer, canvasBox Box, defaults Style)\n"
        },
        {
          "name": "renderer.go",
          "type": "blob",
          "size": 2.1181640625,
          "content": "package chart\n\nimport (\n\t\"io\"\n\n\t\"github.com/golang/freetype/truetype\"\n\t\"github.com/wcharczuk/go-chart/v2/drawing\"\n)\n\n// Renderer represents the basic methods required to draw a chart.\ntype Renderer interface {\n\t// ResetStyle should reset any style related settings on the renderer.\n\tResetStyle()\n\n\t// GetDPI gets the DPI for the renderer.\n\tGetDPI() float64\n\n\t// SetDPI sets the DPI for the renderer.\n\tSetDPI(dpi float64)\n\n\t// SetClassName sets the current class name.\n\tSetClassName(string)\n\n\t// SetStrokeColor sets the current stroke color.\n\tSetStrokeColor(drawing.Color)\n\n\t// SetFillColor sets the current fill color.\n\tSetFillColor(drawing.Color)\n\n\t// SetStrokeWidth sets the stroke width.\n\tSetStrokeWidth(width float64)\n\n\t// SetStrokeDashArray sets the stroke dash array.\n\tSetStrokeDashArray(dashArray []float64)\n\n\t// MoveTo moves the cursor to a given point.\n\tMoveTo(x, y int)\n\n\t// LineTo both starts a shape and draws a line to a given point\n\t// from the previous point.\n\tLineTo(x, y int)\n\n\t// QuadCurveTo draws a quad curve.\n\t// cx and cy represent the bezier \"control points\".\n\tQuadCurveTo(cx, cy, x, y int)\n\n\t// ArcTo draws an arc with a given center (cx,cy)\n\t// a given set of radii (rx,ry), a startAngle and delta (in radians).\n\tArcTo(cx, cy int, rx, ry, startAngle, delta float64)\n\n\t// Close finalizes a shape as drawn by LineTo.\n\tClose()\n\n\t// Stroke strokes the path.\n\tStroke()\n\n\t// Fill fills the path, but does not stroke.\n\tFill()\n\n\t// FillStroke fills and strokes a path.\n\tFillStroke()\n\n\t// Circle draws a circle at the given coords with a given radius.\n\tCircle(radius float64, x, y int)\n\n\t// SetFont sets a font for a text field.\n\tSetFont(*truetype.Font)\n\n\t// SetFontColor sets a font's color\n\tSetFontColor(drawing.Color)\n\n\t// SetFontSize sets the font size for a text field.\n\tSetFontSize(size float64)\n\n\t// Text draws a text blob.\n\tText(body string, x, y int)\n\n\t// MeasureText measures text.\n\tMeasureText(body string) Box\n\n\t// SetTextRotatation sets a rotation for drawing elements.\n\tSetTextRotation(radians float64)\n\n\t// ClearTextRotation clears rotation.\n\tClearTextRotation()\n\n\t// Save writes the image to the given writer.\n\tSave(w io.Writer) error\n}\n"
        },
        {
          "name": "renderer_provider.go",
          "type": "blob",
          "size": 0.1259765625,
          "content": "package chart\n\n// RendererProvider is a function that returns a renderer.\ntype RendererProvider func(int, int) (Renderer, error)\n"
        },
        {
          "name": "roboto",
          "type": "tree",
          "content": null
        },
        {
          "name": "seq.go",
          "type": "blob",
          "size": 5.0400390625,
          "content": "package chart\n\nimport (\n\t\"math\"\n\t\"sort\"\n)\n\n// ValueSequence returns a sequence for a given values set.\nfunc ValueSequence(values ...float64) Seq {\n\treturn Seq{NewArray(values...)}\n}\n\n// Sequence is a provider for values for a seq.\ntype Sequence interface {\n\tLen() int\n\tGetValue(int) float64\n}\n\n// Seq is a utility wrapper for seq providers.\ntype Seq struct {\n\tSequence\n}\n\n// Values enumerates the seq into a slice.\nfunc (s Seq) Values() (output []float64) {\n\tif s.Len() == 0 {\n\t\treturn\n\t}\n\n\toutput = make([]float64, s.Len())\n\tfor i := 0; i < s.Len(); i++ {\n\t\toutput[i] = s.GetValue(i)\n\t}\n\treturn\n}\n\n// Each applies the `mapfn` to all values in the value provider.\nfunc (s Seq) Each(mapfn func(int, float64)) {\n\tfor i := 0; i < s.Len(); i++ {\n\t\tmapfn(i, s.GetValue(i))\n\t}\n}\n\n// Map applies the `mapfn` to all values in the value provider,\n// returning a new seq.\nfunc (s Seq) Map(mapfn func(i int, v float64) float64) Seq {\n\toutput := make([]float64, s.Len())\n\tfor i := 0; i < s.Len(); i++ {\n\t\tmapfn(i, s.GetValue(i))\n\t}\n\treturn Seq{Array(output)}\n}\n\n// FoldLeft collapses a seq from left to right.\nfunc (s Seq) FoldLeft(mapfn func(i int, v0, v float64) float64) (v0 float64) {\n\tif s.Len() == 0 {\n\t\treturn 0\n\t}\n\n\tif s.Len() == 1 {\n\t\treturn s.GetValue(0)\n\t}\n\n\tv0 = s.GetValue(0)\n\tfor i := 1; i < s.Len(); i++ {\n\t\tv0 = mapfn(i, v0, s.GetValue(i))\n\t}\n\treturn\n}\n\n// FoldRight collapses a seq from right to left.\nfunc (s Seq) FoldRight(mapfn func(i int, v0, v float64) float64) (v0 float64) {\n\tif s.Len() == 0 {\n\t\treturn 0\n\t}\n\n\tif s.Len() == 1 {\n\t\treturn s.GetValue(0)\n\t}\n\n\tv0 = s.GetValue(s.Len() - 1)\n\tfor i := s.Len() - 2; i >= 0; i-- {\n\t\tv0 = mapfn(i, v0, s.GetValue(i))\n\t}\n\treturn\n}\n\n// Min returns the minimum value in the seq.\nfunc (s Seq) Min() float64 {\n\tif s.Len() == 0 {\n\t\treturn 0\n\t}\n\tmin := s.GetValue(0)\n\tvar value float64\n\tfor i := 1; i < s.Len(); i++ {\n\t\tvalue = s.GetValue(i)\n\t\tif value < min {\n\t\t\tmin = value\n\t\t}\n\t}\n\treturn min\n}\n\n// Max returns the maximum value in the seq.\nfunc (s Seq) Max() float64 {\n\tif s.Len() == 0 {\n\t\treturn 0\n\t}\n\tmax := s.GetValue(0)\n\tvar value float64\n\tfor i := 1; i < s.Len(); i++ {\n\t\tvalue = s.GetValue(i)\n\t\tif value > max {\n\t\t\tmax = value\n\t\t}\n\t}\n\treturn max\n}\n\n// MinMax returns the minimum and the maximum in one pass.\nfunc (s Seq) MinMax() (min, max float64) {\n\tif s.Len() == 0 {\n\t\treturn\n\t}\n\tmin = s.GetValue(0)\n\tmax = min\n\tvar value float64\n\tfor i := 1; i < s.Len(); i++ {\n\t\tvalue = s.GetValue(i)\n\t\tif value < min {\n\t\t\tmin = value\n\t\t}\n\t\tif value > max {\n\t\t\tmax = value\n\t\t}\n\t}\n\treturn\n}\n\n// Sort returns the seq sorted in ascending order.\n// This fully enumerates the seq.\nfunc (s Seq) Sort() Seq {\n\tif s.Len() == 0 {\n\t\treturn s\n\t}\n\tvalues := s.Values()\n\tsort.Float64s(values)\n\treturn Seq{Array(values)}\n}\n\n// Reverse reverses the sequence\nfunc (s Seq) Reverse() Seq {\n\tif s.Len() == 0 {\n\t\treturn s\n\t}\n\n\tvalues := s.Values()\n\tvaluesLen := len(values)\n\tvaluesLen1 := len(values) - 1\n\tvaluesLen2 := valuesLen >> 1\n\tvar i, j float64\n\tfor index := 0; index < valuesLen2; index++ {\n\t\ti = values[index]\n\t\tj = values[valuesLen1-index]\n\t\tvalues[index] = j\n\t\tvalues[valuesLen1-index] = i\n\t}\n\n\treturn Seq{Array(values)}\n}\n\n// Median returns the median or middle value in the sorted seq.\nfunc (s Seq) Median() (median float64) {\n\tl := s.Len()\n\tif l == 0 {\n\t\treturn\n\t}\n\n\tsorted := s.Sort()\n\tif l%2 == 0 {\n\t\tv0 := sorted.GetValue(l/2 - 1)\n\t\tv1 := sorted.GetValue(l/2 + 1)\n\t\tmedian = (v0 + v1) / 2\n\t} else {\n\t\tmedian = float64(sorted.GetValue(l << 1))\n\t}\n\n\treturn\n}\n\n// Sum adds all the elements of a series together.\nfunc (s Seq) Sum() (accum float64) {\n\tif s.Len() == 0 {\n\t\treturn 0\n\t}\n\n\tfor i := 0; i < s.Len(); i++ {\n\t\taccum += s.GetValue(i)\n\t}\n\treturn\n}\n\n// Average returns the float average of the values in the buffer.\nfunc (s Seq) Average() float64 {\n\tif s.Len() == 0 {\n\t\treturn 0\n\t}\n\n\treturn s.Sum() / float64(s.Len())\n}\n\n// Variance computes the variance of the buffer.\nfunc (s Seq) Variance() float64 {\n\tif s.Len() == 0 {\n\t\treturn 0\n\t}\n\n\tm := s.Average()\n\tvar variance, v float64\n\tfor i := 0; i < s.Len(); i++ {\n\t\tv = s.GetValue(i)\n\t\tvariance += (v - m) * (v - m)\n\t}\n\n\treturn variance / float64(s.Len())\n}\n\n// StdDev returns the standard deviation.\nfunc (s Seq) StdDev() float64 {\n\tif s.Len() == 0 {\n\t\treturn 0\n\t}\n\n\treturn math.Pow(s.Variance(), 0.5)\n}\n\n//Percentile finds the relative standing in a slice of floats.\n// `percent` should be given on the interval [0,1.0).\nfunc (s Seq) Percentile(percent float64) (percentile float64) {\n\tl := s.Len()\n\tif l == 0 {\n\t\treturn 0\n\t}\n\n\tif percent < 0 || percent > 1.0 {\n\t\tpanic(\"percent out of range [0.0, 1.0)\")\n\t}\n\n\tsorted := s.Sort()\n\tindex := percent * float64(l)\n\tif index == float64(int64(index)) {\n\t\ti := f64i(index)\n\t\tci := sorted.GetValue(i - 1)\n\t\tc := sorted.GetValue(i)\n\t\tpercentile = (ci + c) / 2.0\n\t} else {\n\t\ti := f64i(index)\n\t\tpercentile = sorted.GetValue(i)\n\t}\n\n\treturn percentile\n}\n\n// Normalize maps every value to the interval [0, 1.0].\nfunc (s Seq) Normalize() Seq {\n\tmin, max := s.MinMax()\n\n\tdelta := max - min\n\toutput := make([]float64, s.Len())\n\tfor i := 0; i < s.Len(); i++ {\n\t\toutput[i] = (s.GetValue(i) - min) / delta\n\t}\n\n\treturn Seq{Array(output)}\n}\n"
        },
        {
          "name": "seq_test.go",
          "type": "blob",
          "size": 3.3798828125,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestSeqEach(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := Seq{NewArray(1, 2, 3, 4)}\n\tvalues.Each(func(i int, v float64) {\n\t\ttestutil.AssertEqual(t, i, v-1)\n\t})\n}\n\nfunc TestSeqMap(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := Seq{NewArray(1, 2, 3, 4)}\n\tmapped := values.Map(func(i int, v float64) float64 {\n\t\ttestutil.AssertEqual(t, i, v-1)\n\t\treturn v * 2\n\t})\n\ttestutil.AssertEqual(t, 4, mapped.Len())\n}\n\nfunc TestSeqFoldLeft(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := Seq{NewArray(1, 2, 3, 4)}\n\tten := values.FoldLeft(func(_ int, vp, v float64) float64 {\n\t\treturn vp + v\n\t})\n\ttestutil.AssertEqual(t, 10, ten)\n\n\torderTest := Seq{NewArray(10, 3, 2, 1)}\n\tfour := orderTest.FoldLeft(func(_ int, vp, v float64) float64 {\n\t\treturn vp - v\n\t})\n\ttestutil.AssertEqual(t, 4, four)\n}\n\nfunc TestSeqFoldRight(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := Seq{NewArray(1, 2, 3, 4)}\n\tten := values.FoldRight(func(_ int, vp, v float64) float64 {\n\t\treturn vp + v\n\t})\n\ttestutil.AssertEqual(t, 10, ten)\n\n\torderTest := Seq{NewArray(10, 3, 2, 1)}\n\tnotFour := orderTest.FoldRight(func(_ int, vp, v float64) float64 {\n\t\treturn vp - v\n\t})\n\ttestutil.AssertEqual(t, -14, notFour)\n}\n\nfunc TestSeqSum(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := Seq{NewArray(1, 2, 3, 4)}\n\ttestutil.AssertEqual(t, 10, values.Sum())\n}\n\nfunc TestSeqAverage(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := Seq{NewArray(1, 2, 3, 4)}\n\ttestutil.AssertEqual(t, 2.5, values.Average())\n\n\tvaluesOdd := Seq{NewArray(1, 2, 3, 4, 5)}\n\ttestutil.AssertEqual(t, 3, valuesOdd.Average())\n}\n\nfunc TestSequenceVariance(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := Seq{NewArray(1, 2, 3, 4, 5)}\n\ttestutil.AssertEqual(t, 2, values.Variance())\n}\n\nfunc TestSequenceNormalize(t *testing.T) {\n\t// replaced new assertions helper\n\n\tnormalized := ValueSequence(1, 2, 3, 4, 5).Normalize().Values()\n\n\ttestutil.AssertNotEmpty(t, normalized)\n\ttestutil.AssertLen(t, normalized, 5)\n\ttestutil.AssertEqual(t, 0, normalized[0])\n\ttestutil.AssertEqual(t, 0.25, normalized[1])\n\ttestutil.AssertEqual(t, 1, normalized[4])\n}\n\nfunc TestLinearRange(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := LinearRange(1, 100)\n\ttestutil.AssertLen(t, values, 100)\n\ttestutil.AssertEqual(t, 1, values[0])\n\ttestutil.AssertEqual(t, 100, values[99])\n}\n\nfunc TestLinearRangeWithStep(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := LinearRangeWithStep(0, 100, 5)\n\ttestutil.AssertEqual(t, 100, values[20])\n\ttestutil.AssertLen(t, values, 21)\n}\n\nfunc TestLinearRangeReversed(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := LinearRange(10.0, 1.0)\n\ttestutil.AssertEqual(t, 10, len(values))\n\ttestutil.AssertEqual(t, 10.0, values[0])\n\ttestutil.AssertEqual(t, 1.0, values[9])\n}\n\nfunc TestLinearSequenceRegression(t *testing.T) {\n\t// replaced new assertions helper\n\n\t// note; this assumes a 1.0 step is implicitly set in the constructor.\n\tlinearProvider := NewLinearSequence().WithStart(1.0).WithEnd(100.0)\n\ttestutil.AssertEqual(t, 1, linearProvider.Start())\n\ttestutil.AssertEqual(t, 100, linearProvider.End())\n\ttestutil.AssertEqual(t, 100, linearProvider.Len())\n\n\tvalues := Seq{linearProvider}.Values()\n\ttestutil.AssertLen(t, values, 100)\n\ttestutil.AssertEqual(t, 1.0, values[0])\n\ttestutil.AssertEqual(t, 100, values[99])\n}\n"
        },
        {
          "name": "series.go",
          "type": "blob",
          "size": 0.21484375,
          "content": "package chart\n\n// Series is an alias to Renderable.\ntype Series interface {\n\tGetName() string\n\tGetYAxis() YAxisType\n\tGetStyle() Style\n\tValidate() error\n\tRender(r Renderer, canvasBox Box, xrange, yrange Range, s Style)\n}\n"
        },
        {
          "name": "sma_series.go",
          "type": "blob",
          "size": 2.7255859375,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n)\n\nconst (\n\t// DefaultSimpleMovingAveragePeriod is the default number of values to average.\n\tDefaultSimpleMovingAveragePeriod = 16\n)\n\n// Interface Assertions.\nvar (\n\t_ Series              = (*SMASeries)(nil)\n\t_ FirstValuesProvider = (*SMASeries)(nil)\n\t_ LastValuesProvider  = (*SMASeries)(nil)\n)\n\n// SMASeries is a computed series.\ntype SMASeries struct {\n\tName  string\n\tStyle Style\n\tYAxis YAxisType\n\n\tPeriod      int\n\tInnerSeries ValuesProvider\n}\n\n// GetName returns the name of the time series.\nfunc (sma SMASeries) GetName() string {\n\treturn sma.Name\n}\n\n// GetStyle returns the line style.\nfunc (sma SMASeries) GetStyle() Style {\n\treturn sma.Style\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (sma SMASeries) GetYAxis() YAxisType {\n\treturn sma.YAxis\n}\n\n// Len returns the number of elements in the series.\nfunc (sma SMASeries) Len() int {\n\treturn sma.InnerSeries.Len()\n}\n\n// GetPeriod returns the window size.\nfunc (sma SMASeries) GetPeriod(defaults ...int) int {\n\tif sma.Period == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn DefaultSimpleMovingAveragePeriod\n\t}\n\treturn sma.Period\n}\n\n// GetValues gets a value at a given index.\nfunc (sma SMASeries) GetValues(index int) (x, y float64) {\n\tif sma.InnerSeries == nil || sma.InnerSeries.Len() == 0 {\n\t\treturn\n\t}\n\tpx, _ := sma.InnerSeries.GetValues(index)\n\tx = px\n\ty = sma.getAverage(index)\n\treturn\n}\n\n// GetFirstValues computes the first moving average value.\nfunc (sma SMASeries) GetFirstValues() (x, y float64) {\n\tif sma.InnerSeries == nil || sma.InnerSeries.Len() == 0 {\n\t\treturn\n\t}\n\tpx, _ := sma.InnerSeries.GetValues(0)\n\tx = px\n\ty = sma.getAverage(0)\n\treturn\n}\n\n// GetLastValues computes the last moving average value but walking back window size samples,\n// and recomputing the last moving average chunk.\nfunc (sma SMASeries) GetLastValues() (x, y float64) {\n\tif sma.InnerSeries == nil || sma.InnerSeries.Len() == 0 {\n\t\treturn\n\t}\n\tseriesLen := sma.InnerSeries.Len()\n\tpx, _ := sma.InnerSeries.GetValues(seriesLen - 1)\n\tx = px\n\ty = sma.getAverage(seriesLen - 1)\n\treturn\n}\n\nfunc (sma SMASeries) getAverage(index int) float64 {\n\tperiod := sma.GetPeriod()\n\tfloor := MaxInt(0, index-period)\n\tvar accum float64\n\tvar count float64\n\tfor x := index; x >= floor; x-- {\n\t\t_, vy := sma.InnerSeries.GetValues(x)\n\t\taccum += vy\n\t\tcount += 1.0\n\t}\n\treturn accum / count\n}\n\n// Render renders the series.\nfunc (sma SMASeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := sma.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, sma)\n}\n\n// Validate validates the series.\nfunc (sma SMASeries) Validate() error {\n\tif sma.InnerSeries == nil {\n\t\treturn fmt.Errorf(\"sma series requires InnerSeries to be set\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "sma_series_test.go",
          "type": "blob",
          "size": 2.36328125,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\ntype mockValuesProvider struct {\n\tX []float64\n\tY []float64\n}\n\nfunc (m mockValuesProvider) Len() int {\n\treturn MinInt(len(m.X), len(m.Y))\n}\n\nfunc (m mockValuesProvider) GetValues(index int) (x, y float64) {\n\tif index < 0 {\n\t\tpanic(\"negative index at GetValue()\")\n\t}\n\tif index >= MinInt(len(m.X), len(m.Y)) {\n\t\tpanic(\"index is outside the length of m.X or m.Y\")\n\t}\n\tx = m.X[index]\n\ty = m.Y[index]\n\treturn\n}\n\nfunc TestSMASeriesGetValue(t *testing.T) {\n\t// replaced new assertions helper\n\n\tmockSeries := mockValuesProvider{\n\t\tLinearRange(1.0, 10.0),\n\t\tLinearRange(10, 1.0),\n\t}\n\ttestutil.AssertEqual(t, 10, mockSeries.Len())\n\n\tmas := &SMASeries{\n\t\tInnerSeries: mockSeries,\n\t\tPeriod:      10,\n\t}\n\n\tvar yvalues []float64\n\tfor x := 0; x < mas.Len(); x++ {\n\t\t_, y := mas.GetValues(x)\n\t\tyvalues = append(yvalues, y)\n\t}\n\n\ttestutil.AssertEqual(t, 10.0, yvalues[0])\n\ttestutil.AssertEqual(t, 9.5, yvalues[1])\n\ttestutil.AssertEqual(t, 9.0, yvalues[2])\n\ttestutil.AssertEqual(t, 8.5, yvalues[3])\n\ttestutil.AssertEqual(t, 8.0, yvalues[4])\n\ttestutil.AssertEqual(t, 7.5, yvalues[5])\n\ttestutil.AssertEqual(t, 7.0, yvalues[6])\n\ttestutil.AssertEqual(t, 6.5, yvalues[7])\n\ttestutil.AssertEqual(t, 6.0, yvalues[8])\n}\n\nfunc TestSMASeriesGetLastValueWindowOverlap(t *testing.T) {\n\t// replaced new assertions helper\n\n\tmockSeries := mockValuesProvider{\n\t\tLinearRange(1.0, 10.0),\n\t\tLinearRange(10, 1.0),\n\t}\n\ttestutil.AssertEqual(t, 10, mockSeries.Len())\n\n\tmas := &SMASeries{\n\t\tInnerSeries: mockSeries,\n\t\tPeriod:      15,\n\t}\n\n\tvar yvalues []float64\n\tfor x := 0; x < mas.Len(); x++ {\n\t\t_, y := mas.GetValues(x)\n\t\tyvalues = append(yvalues, y)\n\t}\n\n\tlx, ly := mas.GetLastValues()\n\ttestutil.AssertEqual(t, 10.0, lx)\n\ttestutil.AssertEqual(t, 5.5, ly)\n\ttestutil.AssertEqual(t, yvalues[len(yvalues)-1], ly)\n}\n\nfunc TestSMASeriesGetLastValue(t *testing.T) {\n\t// replaced new assertions helper\n\n\tmockSeries := mockValuesProvider{\n\t\tLinearRange(1.0, 100.0),\n\t\tLinearRange(100, 1.0),\n\t}\n\ttestutil.AssertEqual(t, 100, mockSeries.Len())\n\n\tmas := &SMASeries{\n\t\tInnerSeries: mockSeries,\n\t\tPeriod:      10,\n\t}\n\n\tvar yvalues []float64\n\tfor x := 0; x < mas.Len(); x++ {\n\t\t_, y := mas.GetValues(x)\n\t\tyvalues = append(yvalues, y)\n\t}\n\n\tlx, ly := mas.GetLastValues()\n\ttestutil.AssertEqual(t, 100.0, lx)\n\ttestutil.AssertEqual(t, 6, ly)\n\ttestutil.AssertEqual(t, yvalues[len(yvalues)-1], ly)\n}\n"
        },
        {
          "name": "stacked_bar_chart.go",
          "type": "blob",
          "size": 15.8017578125,
          "content": "package chart\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\n\t\"github.com/golang/freetype/truetype\"\n)\n\n// StackedBar is a bar within a StackedBarChart.\ntype StackedBar struct {\n\tName   string\n\tWidth  int\n\tValues []Value\n}\n\n// GetWidth returns the width of the bar.\nfunc (sb StackedBar) GetWidth() int {\n\tif sb.Width == 0 {\n\t\treturn 50\n\t}\n\treturn sb.Width\n}\n\n// StackedBarChart is a chart that draws sections of a bar based on percentages.\ntype StackedBarChart struct {\n\tTitle      string\n\tTitleStyle Style\n\n\tColorPalette ColorPalette\n\n\tWidth  int\n\tHeight int\n\tDPI    float64\n\n\tBackground Style\n\tCanvas     Style\n\n\tXAxis Style\n\tYAxis Style\n\n\tBarSpacing int\n\n\tFont        *truetype.Font\n\tdefaultFont *truetype.Font\n\n\tIsHorizontal bool\n\n\tBars     []StackedBar\n\tElements []Renderable\n}\n\n// GetDPI returns the dpi for the chart.\nfunc (sbc StackedBarChart) GetDPI(defaults ...float64) float64 {\n\tif sbc.DPI == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn DefaultDPI\n\t}\n\treturn sbc.DPI\n}\n\n// GetFont returns the text font.\nfunc (sbc StackedBarChart) GetFont() *truetype.Font {\n\tif sbc.Font == nil {\n\t\treturn sbc.defaultFont\n\t}\n\treturn sbc.Font\n}\n\n// GetWidth returns the chart width or the default value.\nfunc (sbc StackedBarChart) GetWidth() int {\n\tif sbc.Width == 0 {\n\t\treturn DefaultChartWidth\n\t}\n\treturn sbc.Width\n}\n\n// GetHeight returns the chart height or the default value.\nfunc (sbc StackedBarChart) GetHeight() int {\n\tif sbc.Height == 0 {\n\t\treturn DefaultChartWidth\n\t}\n\treturn sbc.Height\n}\n\n// GetBarSpacing returns the spacing between bars.\nfunc (sbc StackedBarChart) GetBarSpacing() int {\n\tif sbc.BarSpacing == 0 {\n\t\treturn 100\n\t}\n\treturn sbc.BarSpacing\n}\n\n// Render renders the chart with the given renderer to the given io.Writer.\nfunc (sbc StackedBarChart) Render(rp RendererProvider, w io.Writer) error {\n\tif len(sbc.Bars) == 0 {\n\t\treturn errors.New(\"please provide at least one bar\")\n\t}\n\n\tr, err := rp(sbc.GetWidth(), sbc.GetHeight())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif sbc.Font == nil {\n\t\tdefaultFont, err := GetDefaultFont()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsbc.defaultFont = defaultFont\n\t}\n\tr.SetDPI(sbc.GetDPI(DefaultDPI))\n\n\tvar canvasBox Box\n\tif sbc.IsHorizontal {\n\t\tcanvasBox = sbc.getHorizontalAdjustedCanvasBox(r, sbc.getDefaultCanvasBox())\n\t\tif err := canvasBox.Validate(); err != nil {\n\t\t\treturn fmt.Errorf(\"invalid canvas box: %w\", err)\n\t\t}\n\t\tsbc.drawCanvas(r, canvasBox)\n\t\tsbc.drawHorizontalBars(r, canvasBox)\n\t\tsbc.drawHorizontalXAxis(r, canvasBox)\n\t\tsbc.drawHorizontalYAxis(r, canvasBox)\n\t} else {\n\t\tcanvasBox = sbc.getAdjustedCanvasBox(r, sbc.getDefaultCanvasBox())\n\t\tif err := canvasBox.Validate(); err != nil {\n\t\t\treturn fmt.Errorf(\"invalid canvas box: %w\", err)\n\t\t}\n\t\tsbc.drawCanvas(r, canvasBox)\n\t\tsbc.drawBars(r, canvasBox)\n\t\tsbc.drawXAxis(r, canvasBox)\n\t\tsbc.drawYAxis(r, canvasBox)\n\t}\n\n\tsbc.drawTitle(r)\n\tfor _, a := range sbc.Elements {\n\t\ta(r, canvasBox, sbc.styleDefaultsElements())\n\t}\n\n\treturn r.Save(w)\n}\n\nfunc (sbc StackedBarChart) drawCanvas(r Renderer, canvasBox Box) {\n\tDraw.Box(r, canvasBox, sbc.getCanvasStyle())\n}\n\nfunc (sbc StackedBarChart) drawBars(r Renderer, canvasBox Box) {\n\txoffset := canvasBox.Left\n\tfor _, bar := range sbc.Bars {\n\t\tsbc.drawBar(r, canvasBox, xoffset, bar)\n\t\txoffset += (sbc.GetBarSpacing() + bar.GetWidth())\n\t}\n}\n\nfunc (sbc StackedBarChart) drawHorizontalBars(r Renderer, canvasBox Box) {\n\tyOffset := canvasBox.Top\n\tfor _, bar := range sbc.Bars {\n\t\tsbc.drawHorizontalBar(r, canvasBox, yOffset, bar)\n\t\tyOffset += sbc.GetBarSpacing() + bar.GetWidth()\n\t}\n}\n\nfunc (sbc StackedBarChart) drawBar(r Renderer, canvasBox Box, xoffset int, bar StackedBar) int {\n\tbarSpacing2 := sbc.GetBarSpacing() >> 1\n\tbxl := xoffset + barSpacing2\n\tbxr := bxl + bar.GetWidth()\n\n\tnormalizedBarComponents := Values(bar.Values).Normalize()\n\tyoffset := canvasBox.Top\n\tfor index, bv := range normalizedBarComponents {\n\t\tbarHeight := int(math.Ceil(bv.Value * float64(canvasBox.Height())))\n\t\tbarBox := Box{\n\t\t\tTop:    yoffset,\n\t\t\tLeft:   bxl,\n\t\t\tRight:  bxr,\n\t\t\tBottom: MinInt(yoffset+barHeight, canvasBox.Bottom-DefaultStrokeWidth),\n\t\t}\n\t\tDraw.Box(r, barBox, bv.Style.InheritFrom(sbc.styleDefaultsStackedBarValue(index)))\n\t\tyoffset += barHeight\n\t}\n\n\t// draw the labels\n\tyoffset = canvasBox.Top\n\tvar lx, ly int\n\tfor index, bv := range normalizedBarComponents {\n\t\tbarHeight := int(math.Ceil(bv.Value * float64(canvasBox.Height())))\n\n\t\tif len(bv.Label) > 0 {\n\t\t\tlx = bxl + ((bxr - bxl) / 2)\n\t\t\tly = yoffset + (barHeight / 2)\n\n\t\t\tbv.Style.InheritFrom(sbc.styleDefaultsStackedBarValue(index)).WriteToRenderer(r)\n\t\t\ttb := r.MeasureText(bv.Label)\n\t\t\tlx = lx - (tb.Width() >> 1)\n\t\t\tly = ly + (tb.Height() >> 1)\n\n\t\t\tif lx < 0 {\n\t\t\t\tlx = 0\n\t\t\t}\n\t\t\tif ly < 0 {\n\t\t\t\tlx = 0\n\t\t\t}\n\n\t\t\tr.Text(bv.Label, lx, ly)\n\t\t}\n\t\tyoffset += barHeight\n\t}\n\n\treturn bxr\n}\n\nfunc (sbc StackedBarChart) drawHorizontalBar(r Renderer, canvasBox Box, yoffset int, bar StackedBar) {\n\thalfBarSpacing := sbc.GetBarSpacing() >> 1\n\n\tboxTop := yoffset + halfBarSpacing\n\tboxBottom := boxTop + bar.GetWidth()\n\n\tnormalizedBarComponents := Values(bar.Values).Normalize()\n\n\txOffset := canvasBox.Right\n\tfor index, bv := range normalizedBarComponents {\n\t\tbarHeight := int(math.Ceil(bv.Value * float64(canvasBox.Width())))\n\t\tbarBox := Box{\n\t\t\tTop:    boxTop,\n\t\t\tLeft:   MinInt(xOffset-barHeight, canvasBox.Left+DefaultStrokeWidth),\n\t\t\tRight:  xOffset,\n\t\t\tBottom: boxBottom,\n\t\t}\n\t\tDraw.Box(r, barBox, bv.Style.InheritFrom(sbc.styleDefaultsStackedBarValue(index)))\n\t\txOffset -= barHeight\n\t}\n\n\t// draw the labels\n\txOffset = canvasBox.Right\n\tvar lx, ly int\n\tfor index, bv := range normalizedBarComponents {\n\t\tbarHeight := int(math.Ceil(bv.Value * float64(canvasBox.Width())))\n\n\t\tif len(bv.Label) > 0 {\n\t\t\tlx = xOffset - (barHeight / 2)\n\t\t\tly = boxTop + ((boxBottom - boxTop) / 2)\n\n\t\t\tbv.Style.InheritFrom(sbc.styleDefaultsStackedBarValue(index)).WriteToRenderer(r)\n\t\t\ttb := r.MeasureText(bv.Label)\n\t\t\tlx = lx - (tb.Width() >> 1)\n\t\t\tly = ly + (tb.Height() >> 1)\n\n\t\t\tif lx < 0 {\n\t\t\t\tlx = 0\n\t\t\t}\n\t\t\tif ly < 0 {\n\t\t\t\tlx = 0\n\t\t\t}\n\n\t\t\tr.Text(bv.Label, lx, ly)\n\t\t}\n\t\txOffset -= barHeight\n\t}\n}\n\nfunc (sbc StackedBarChart) drawXAxis(r Renderer, canvasBox Box) {\n\tif !sbc.XAxis.Hidden {\n\t\taxisStyle := sbc.XAxis.InheritFrom(sbc.styleDefaultsAxes())\n\t\taxisStyle.WriteToRenderer(r)\n\n\t\tr.MoveTo(canvasBox.Left, canvasBox.Bottom)\n\t\tr.LineTo(canvasBox.Right, canvasBox.Bottom)\n\t\tr.Stroke()\n\n\t\tr.MoveTo(canvasBox.Left, canvasBox.Bottom)\n\t\tr.LineTo(canvasBox.Left, canvasBox.Bottom+DefaultVerticalTickHeight)\n\t\tr.Stroke()\n\n\t\tcursor := canvasBox.Left\n\t\tfor _, bar := range sbc.Bars {\n\n\t\t\tbarLabelBox := Box{\n\t\t\t\tTop:    canvasBox.Bottom + DefaultXAxisMargin,\n\t\t\t\tLeft:   cursor,\n\t\t\t\tRight:  cursor + bar.GetWidth() + sbc.GetBarSpacing(),\n\t\t\t\tBottom: sbc.GetHeight(),\n\t\t\t}\n\t\t\tif len(bar.Name) > 0 {\n\t\t\t\tDraw.TextWithin(r, bar.Name, barLabelBox, axisStyle)\n\t\t\t}\n\t\t\taxisStyle.WriteToRenderer(r)\n\t\t\tr.MoveTo(barLabelBox.Right, canvasBox.Bottom)\n\t\t\tr.LineTo(barLabelBox.Right, canvasBox.Bottom+DefaultVerticalTickHeight)\n\t\t\tr.Stroke()\n\t\t\tcursor += bar.GetWidth() + sbc.GetBarSpacing()\n\t\t}\n\t}\n}\n\nfunc (sbc StackedBarChart) drawHorizontalXAxis(r Renderer, canvasBox Box) {\n\tif !sbc.XAxis.Hidden {\n\t\taxisStyle := sbc.XAxis.InheritFrom(sbc.styleDefaultsAxes())\n\t\taxisStyle.WriteToRenderer(r)\n\t\tr.MoveTo(canvasBox.Left, canvasBox.Bottom)\n\t\tr.LineTo(canvasBox.Right, canvasBox.Bottom)\n\t\tr.Stroke()\n\n\t\tr.MoveTo(canvasBox.Left, canvasBox.Bottom)\n\t\tr.LineTo(canvasBox.Left, canvasBox.Bottom+DefaultVerticalTickHeight)\n\t\tr.Stroke()\n\n\t\tticks := LinearRangeWithStep(0.0, 1.0, 0.2)\n\t\tfor _, t := range ticks {\n\t\t\taxisStyle.GetStrokeOptions().WriteToRenderer(r)\n\t\t\ttx := canvasBox.Left + int(t*float64(canvasBox.Width()))\n\t\t\tr.MoveTo(tx, canvasBox.Bottom)\n\t\t\tr.LineTo(tx, canvasBox.Bottom+DefaultVerticalTickHeight)\n\t\t\tr.Stroke()\n\n\t\t\taxisStyle.GetTextOptions().WriteToRenderer(r)\n\t\t\ttext := fmt.Sprintf(\"%0.0f%%\", t*100)\n\n\t\t\ttextBox := r.MeasureText(text)\n\t\t\ttextX := tx - (textBox.Width() >> 1)\n\t\t\ttextY := canvasBox.Bottom + DefaultXAxisMargin + 10\n\n\t\t\tif t == 1 {\n\t\t\t\ttextX = canvasBox.Right - textBox.Width()\n\t\t\t}\n\n\t\t\tDraw.Text(r, text, textX, textY, axisStyle)\n\t\t}\n\t}\n}\n\nfunc (sbc StackedBarChart) drawYAxis(r Renderer, canvasBox Box) {\n\tif !sbc.YAxis.Hidden {\n\t\taxisStyle := sbc.YAxis.InheritFrom(sbc.styleDefaultsAxes())\n\t\taxisStyle.WriteToRenderer(r)\n\t\tr.MoveTo(canvasBox.Right, canvasBox.Top)\n\t\tr.LineTo(canvasBox.Right, canvasBox.Bottom)\n\t\tr.Stroke()\n\n\t\tr.MoveTo(canvasBox.Right, canvasBox.Bottom)\n\t\tr.LineTo(canvasBox.Right+DefaultHorizontalTickWidth, canvasBox.Bottom)\n\t\tr.Stroke()\n\n\t\tticks := LinearRangeWithStep(0.0, 1.0, 0.2)\n\t\tfor _, t := range ticks {\n\t\t\taxisStyle.GetStrokeOptions().WriteToRenderer(r)\n\t\t\tty := canvasBox.Bottom - int(t*float64(canvasBox.Height()))\n\t\t\tr.MoveTo(canvasBox.Right, ty)\n\t\t\tr.LineTo(canvasBox.Right+DefaultHorizontalTickWidth, ty)\n\t\t\tr.Stroke()\n\n\t\t\taxisStyle.GetTextOptions().WriteToRenderer(r)\n\t\t\ttext := fmt.Sprintf(\"%0.0f%%\", t*100)\n\n\t\t\ttb := r.MeasureText(text)\n\t\t\tDraw.Text(r, text, canvasBox.Right+DefaultYAxisMargin+5, ty+(tb.Height()>>1), axisStyle)\n\t\t}\n\t}\n}\n\nfunc (sbc StackedBarChart) drawHorizontalYAxis(r Renderer, canvasBox Box) {\n\tif !sbc.YAxis.Hidden {\n\t\taxisStyle := sbc.YAxis.InheritFrom(sbc.styleDefaultsHorizontalAxes())\n\t\taxisStyle.WriteToRenderer(r)\n\n\t\tr.MoveTo(canvasBox.Left, canvasBox.Bottom)\n\t\tr.LineTo(canvasBox.Left, canvasBox.Top)\n\t\tr.Stroke()\n\n\t\tr.MoveTo(canvasBox.Left, canvasBox.Bottom)\n\t\tr.LineTo(canvasBox.Left-DefaultHorizontalTickWidth, canvasBox.Bottom)\n\t\tr.Stroke()\n\n\t\tcursor := canvasBox.Top\n\t\tfor _, bar := range sbc.Bars {\n\t\t\tbarLabelBox := Box{\n\t\t\t\tTop:    cursor,\n\t\t\t\tLeft:   0,\n\t\t\t\tRight:  canvasBox.Left - DefaultYAxisMargin,\n\t\t\t\tBottom: cursor + bar.GetWidth() + sbc.GetBarSpacing(),\n\t\t\t}\n\t\t\tif len(bar.Name) > 0 {\n\t\t\t\tDraw.TextWithin(r, bar.Name, barLabelBox, axisStyle)\n\t\t\t}\n\t\t\taxisStyle.WriteToRenderer(r)\n\t\t\tr.MoveTo(canvasBox.Left, barLabelBox.Bottom)\n\t\t\tr.LineTo(canvasBox.Left-DefaultHorizontalTickWidth, barLabelBox.Bottom)\n\t\t\tr.Stroke()\n\t\t\tcursor += bar.GetWidth() + sbc.GetBarSpacing()\n\t\t}\n\t}\n}\n\nfunc (sbc StackedBarChart) drawTitle(r Renderer) {\n\tif len(sbc.Title) > 0 && !sbc.TitleStyle.Hidden {\n\t\tr.SetFont(sbc.TitleStyle.GetFont(sbc.GetFont()))\n\t\tr.SetFontColor(sbc.TitleStyle.GetFontColor(sbc.GetColorPalette().TextColor()))\n\t\ttitleFontSize := sbc.TitleStyle.GetFontSize(DefaultTitleFontSize)\n\t\tr.SetFontSize(titleFontSize)\n\n\t\ttextBox := r.MeasureText(sbc.Title)\n\n\t\ttextWidth := textBox.Width()\n\t\ttextHeight := textBox.Height()\n\n\t\ttitleX := (sbc.GetWidth() >> 1) - (textWidth >> 1)\n\t\ttitleY := sbc.TitleStyle.Padding.GetTop(DefaultTitleTop) + textHeight\n\n\t\tr.Text(sbc.Title, titleX, titleY)\n\t}\n}\n\nfunc (sbc StackedBarChart) getCanvasStyle() Style {\n\treturn sbc.Canvas.InheritFrom(sbc.styleDefaultsCanvas())\n}\n\nfunc (sbc StackedBarChart) styleDefaultsCanvas() Style {\n\treturn Style{\n\t\tFillColor:   sbc.GetColorPalette().CanvasColor(),\n\t\tStrokeColor: sbc.GetColorPalette().CanvasStrokeColor(),\n\t\tStrokeWidth: DefaultCanvasStrokeWidth,\n\t}\n}\n\n// GetColorPalette returns the color palette for the chart.\nfunc (sbc StackedBarChart) GetColorPalette() ColorPalette {\n\tif sbc.ColorPalette != nil {\n\t\treturn sbc.ColorPalette\n\t}\n\treturn AlternateColorPalette\n}\n\nfunc (sbc StackedBarChart) getDefaultCanvasBox() Box {\n\treturn sbc.Box()\n}\n\nfunc (sbc StackedBarChart) getAdjustedCanvasBox(r Renderer, canvasBox Box) Box {\n\tvar totalWidth int\n\tfor _, bar := range sbc.Bars {\n\t\ttotalWidth += bar.GetWidth() + sbc.GetBarSpacing()\n\t}\n\n\tif !sbc.XAxis.Hidden {\n\t\txaxisHeight := DefaultVerticalTickHeight\n\n\t\taxisStyle := sbc.XAxis.InheritFrom(sbc.styleDefaultsAxes())\n\t\taxisStyle.WriteToRenderer(r)\n\n\t\tcursor := canvasBox.Left\n\t\tfor _, bar := range sbc.Bars {\n\t\t\tif len(bar.Name) > 0 {\n\t\t\t\tbarLabelBox := Box{\n\t\t\t\t\tTop:    canvasBox.Bottom + DefaultXAxisMargin,\n\t\t\t\t\tLeft:   cursor,\n\t\t\t\t\tRight:  cursor + bar.GetWidth() + sbc.GetBarSpacing(),\n\t\t\t\t\tBottom: sbc.GetHeight(),\n\t\t\t\t}\n\t\t\t\tlines := Text.WrapFit(r, bar.Name, barLabelBox.Width(), axisStyle)\n\t\t\t\tlinesBox := Text.MeasureLines(r, lines, axisStyle)\n\n\t\t\t\txaxisHeight = MaxInt(linesBox.Height()+(2*DefaultXAxisMargin), xaxisHeight)\n\t\t\t}\n\t\t}\n\t\treturn Box{\n\t\t\tTop:    canvasBox.Top,\n\t\t\tLeft:   canvasBox.Left,\n\t\t\tRight:  canvasBox.Left + totalWidth,\n\t\t\tBottom: sbc.GetHeight() - xaxisHeight,\n\t\t}\n\t}\n\treturn Box{\n\t\tTop:    canvasBox.Top,\n\t\tLeft:   canvasBox.Left,\n\t\tRight:  canvasBox.Left + totalWidth,\n\t\tBottom: canvasBox.Bottom,\n\t}\n\n}\n\nfunc (sbc StackedBarChart) getHorizontalAdjustedCanvasBox(r Renderer, canvasBox Box) Box {\n\tvar totalHeight int\n\tfor _, bar := range sbc.Bars {\n\t\ttotalHeight += bar.GetWidth() + sbc.GetBarSpacing()\n\t}\n\n\tif !sbc.YAxis.Hidden {\n\t\tyAxisWidth := DefaultHorizontalTickWidth\n\n\t\taxisStyle := sbc.YAxis.InheritFrom(sbc.styleDefaultsHorizontalAxes())\n\t\taxisStyle.WriteToRenderer(r)\n\n\t\tcursor := canvasBox.Top\n\t\tfor _, bar := range sbc.Bars {\n\t\t\tif len(bar.Name) > 0 {\n\t\t\t\tbarLabelBox := Box{\n\t\t\t\t\tTop:    cursor,\n\t\t\t\t\tLeft:   0,\n\t\t\t\t\tRight:  canvasBox.Left + DefaultYAxisMargin,\n\t\t\t\t\tBottom: cursor + bar.GetWidth() + sbc.GetBarSpacing(),\n\t\t\t\t}\n\t\t\t\tlines := Text.WrapFit(r, bar.Name, barLabelBox.Width(), axisStyle)\n\t\t\t\tlinesBox := Text.MeasureLines(r, lines, axisStyle)\n\n\t\t\t\tyAxisWidth = MaxInt(linesBox.Height()+(2*DefaultXAxisMargin), yAxisWidth)\n\t\t\t}\n\t\t}\n\t\treturn Box{\n\t\t\tTop:    canvasBox.Top,\n\t\t\tLeft:   canvasBox.Left + yAxisWidth,\n\t\t\tRight:  canvasBox.Right,\n\t\t\tBottom: canvasBox.Top + totalHeight,\n\t\t}\n\t}\n\treturn Box{\n\t\tTop:    canvasBox.Top,\n\t\tLeft:   canvasBox.Left,\n\t\tRight:  canvasBox.Right,\n\t\tBottom: canvasBox.Top + totalHeight,\n\t}\n}\n\n// Box returns the chart bounds as a box.\nfunc (sbc StackedBarChart) Box() Box {\n\tdpr := sbc.Background.Padding.GetRight(10)\n\tdpb := sbc.Background.Padding.GetBottom(50)\n\n\treturn Box{\n\t\tTop:    sbc.Background.Padding.GetTop(20),\n\t\tLeft:   sbc.Background.Padding.GetLeft(20),\n\t\tRight:  sbc.GetWidth() - dpr,\n\t\tBottom: sbc.GetHeight() - dpb,\n\t}\n}\n\nfunc (sbc StackedBarChart) styleDefaultsStackedBarValue(index int) Style {\n\treturn Style{\n\t\tStrokeColor: sbc.GetColorPalette().GetSeriesColor(index),\n\t\tStrokeWidth: 3.0,\n\t\tFillColor:   sbc.GetColorPalette().GetSeriesColor(index),\n\t\tFontSize:    sbc.getScaledFontSize(),\n\t\tFontColor:   sbc.GetColorPalette().TextColor(),\n\t\tFont:        sbc.GetFont(),\n\t}\n}\n\nfunc (sbc StackedBarChart) styleDefaultsTitle() Style {\n\treturn sbc.TitleStyle.InheritFrom(Style{\n\t\tFontColor:           DefaultTextColor,\n\t\tFont:                sbc.GetFont(),\n\t\tFontSize:            sbc.getTitleFontSize(),\n\t\tTextHorizontalAlign: TextHorizontalAlignCenter,\n\t\tTextVerticalAlign:   TextVerticalAlignTop,\n\t\tTextWrap:            TextWrapWord,\n\t})\n}\n\nfunc (sbc StackedBarChart) getScaledFontSize() float64 {\n\teffectiveDimension := MinInt(sbc.GetWidth(), sbc.GetHeight())\n\tif effectiveDimension >= 2048 {\n\t\treturn 48.0\n\t} else if effectiveDimension >= 1024 {\n\t\treturn 24.0\n\t} else if effectiveDimension > 512 {\n\t\treturn 18.0\n\t} else if effectiveDimension > 256 {\n\t\treturn 12.0\n\t}\n\treturn 10.0\n}\n\nfunc (sbc StackedBarChart) getTitleFontSize() float64 {\n\teffectiveDimension := MinInt(sbc.GetWidth(), sbc.GetHeight())\n\tif effectiveDimension >= 2048 {\n\t\treturn 48\n\t} else if effectiveDimension >= 1024 {\n\t\treturn 24\n\t} else if effectiveDimension >= 512 {\n\t\treturn 18\n\t} else if effectiveDimension >= 256 {\n\t\treturn 12\n\t}\n\treturn 10\n}\n\nfunc (sbc StackedBarChart) styleDefaultsAxes() Style {\n\treturn Style{\n\t\tStrokeColor:         DefaultAxisColor,\n\t\tFont:                sbc.GetFont(),\n\t\tFontSize:            DefaultAxisFontSize,\n\t\tFontColor:           DefaultAxisColor,\n\t\tTextHorizontalAlign: TextHorizontalAlignCenter,\n\t\tTextVerticalAlign:   TextVerticalAlignTop,\n\t\tTextWrap:            TextWrapWord,\n\t}\n}\n\nfunc (sbc StackedBarChart) styleDefaultsHorizontalAxes() Style {\n\treturn Style{\n\t\tStrokeColor:         DefaultAxisColor,\n\t\tFont:                sbc.GetFont(),\n\t\tFontSize:            DefaultAxisFontSize,\n\t\tFontColor:           DefaultAxisColor,\n\t\tTextHorizontalAlign: TextHorizontalAlignCenter,\n\t\tTextVerticalAlign:   TextVerticalAlignMiddle,\n\t\tTextWrap:            TextWrapWord,\n\t}\n}\n\nfunc (sbc StackedBarChart) styleDefaultsElements() Style {\n\treturn Style{\n\t\tFont: sbc.GetFont(),\n\t}\n}\n"
        },
        {
          "name": "stringutil.go",
          "type": "blob",
          "size": 1.0283203125,
          "content": "package chart\n\nimport \"strings\"\n\n// SplitCSV splits a corpus by the `,`, dropping leading or trailing whitespace unless quoted.\nfunc SplitCSV(text string) (output []string) {\n\tif len(text) == 0 {\n\t\treturn\n\t}\n\n\tvar state int\n\tvar word []rune\n\tvar opened rune\n\tfor _, r := range text {\n\t\tswitch state {\n\t\tcase 0: // word\n\t\t\tif isQuote(r) {\n\t\t\t\topened = r\n\t\t\t\tstate = 1\n\t\t\t} else if isCSVDelim(r) {\n\t\t\t\toutput = append(output, strings.TrimSpace(string(word)))\n\t\t\t\tword = nil\n\t\t\t} else {\n\t\t\t\tword = append(word, r)\n\t\t\t}\n\t\tcase 1: // we're in a quoted section\n\t\t\tif matchesQuote(opened, r) {\n\t\t\t\tstate = 0\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tword = append(word, r)\n\t\t}\n\t}\n\n\tif len(word) > 0 {\n\t\toutput = append(output, strings.TrimSpace(string(word)))\n\t}\n\treturn\n}\n\nfunc isCSVDelim(r rune) bool {\n\treturn r == rune(',')\n}\n\nfunc isQuote(r rune) bool {\n\treturn r == '\"' || r == '\\'' || r == '' || r == '' || r == '`'\n}\n\nfunc matchesQuote(a, b rune) bool {\n\tif a == '' && b == '' {\n\t\treturn true\n\t}\n\tif a == '' && b == '' {\n\t\treturn true\n\t}\n\treturn a == b\n}\n"
        },
        {
          "name": "stringutil_test.go",
          "type": "blob",
          "size": 0.919921875,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestSplitCSV(t *testing.T) {\n\t// replaced new assertions helper\n\n\ttestutil.AssertEmpty(t, SplitCSV(\"\"))\n\ttestutil.AssertEqual(t, []string{\"foo\"}, SplitCSV(\"foo\"))\n\ttestutil.AssertEqual(t, []string{\"foo\", \"bar\"}, SplitCSV(\"foo,bar\"))\n\ttestutil.AssertEqual(t, []string{\"foo\", \"bar\"}, SplitCSV(\"foo, bar\"))\n\ttestutil.AssertEqual(t, []string{\"foo\", \"bar\"}, SplitCSV(\" foo , bar \"))\n\ttestutil.AssertEqual(t, []string{\"foo\", \"bar\", \"baz\"}, SplitCSV(\"foo,bar,baz\"))\n\ttestutil.AssertEqual(t, []string{\"foo\", \"bar\", \"baz,buzz\"}, SplitCSV(\"foo,bar,\\\"baz,buzz\\\"\"))\n\ttestutil.AssertEqual(t, []string{\"foo\", \"bar\", \"baz,'buzz'\"}, SplitCSV(\"foo,bar,\\\"baz,'buzz'\\\"\"))\n\ttestutil.AssertEqual(t, []string{\"foo\", \"bar\", \"baz,'buzz\"}, SplitCSV(\"foo,bar,\\\"baz,'buzz\\\"\"))\n\ttestutil.AssertEqual(t, []string{\"foo\", \"bar\", \"baz,\\\"buzz\\\"\"}, SplitCSV(\"foo,bar,'baz,\\\"buzz\\\"'\"))\n}\n"
        },
        {
          "name": "style.go",
          "type": "blob",
          "size": 12.0986328125,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/golang/freetype/truetype\"\n\t\"github.com/wcharczuk/go-chart/v2/drawing\"\n)\n\nconst (\n\t// Disabled indicates if the value should be interpreted as set intentionally to zero.\n\t// this is because golang optionals aren't here yet.\n\tDisabled = -1\n)\n\n// Hidden is a prebuilt style with the `Hidden` property set to true.\nfunc Hidden() Style {\n\treturn Style{\n\t\tHidden: true,\n\t}\n}\n\n// Shown is a prebuilt style with the `Hidden` property set to false.\n// You can also think of this as the default.\nfunc Shown() Style {\n\treturn Style{\n\t\tHidden: false,\n\t}\n}\n\n// StyleTextDefaults returns a style for drawing outside a\n// chart context.\nfunc StyleTextDefaults() Style {\n\tfont, _ := GetDefaultFont()\n\treturn Style{\n\t\tHidden:    false,\n\t\tFont:      font,\n\t\tFontColor: DefaultTextColor,\n\t\tFontSize:  DefaultTitleFontSize,\n\t}\n}\n\n// Style is a simple style set.\ntype Style struct {\n\tHidden  bool\n\tPadding Box\n\n\tClassName string\n\n\tStrokeWidth     float64\n\tStrokeColor     drawing.Color\n\tStrokeDashArray []float64\n\n\tDotColor drawing.Color\n\tDotWidth float64\n\n\tDotWidthProvider SizeProvider\n\tDotColorProvider DotColorProvider\n\n\tFillColor drawing.Color\n\n\tFontSize  float64\n\tFontColor drawing.Color\n\tFont      *truetype.Font\n\n\tTextHorizontalAlign TextHorizontalAlign\n\tTextVerticalAlign   TextVerticalAlign\n\tTextWrap            TextWrap\n\tTextLineSpacing     int\n\tTextRotationDegrees float64 //0 is unset or normal\n}\n\n// IsZero returns if the object is set or not.\nfunc (s Style) IsZero() bool {\n\treturn !s.Hidden &&\n\t\ts.StrokeColor.IsZero() &&\n\t\ts.StrokeWidth == 0 &&\n\t\ts.DotColor.IsZero() &&\n\t\ts.DotWidth == 0 &&\n\t\ts.FillColor.IsZero() &&\n\t\ts.FontColor.IsZero() &&\n\t\ts.FontSize == 0 &&\n\t\ts.Font == nil &&\n\t\ts.ClassName == \"\"\n}\n\n// String returns a text representation of the style.\nfunc (s Style) String() string {\n\tif s.IsZero() {\n\t\treturn \"{}\"\n\t}\n\n\tvar output []string\n\tif s.Hidden {\n\t\toutput = []string{\"\\\"hidden\\\": true\"}\n\t} else {\n\t\toutput = []string{\"\\\"hidden\\\": false\"}\n\t}\n\n\tif s.ClassName != \"\" {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"class_name\\\": %s\", s.ClassName))\n\t} else {\n\t\toutput = append(output, \"\\\"class_name\\\": null\")\n\t}\n\n\tif !s.Padding.IsZero() {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"padding\\\": %s\", s.Padding.String()))\n\t} else {\n\t\toutput = append(output, \"\\\"padding\\\": null\")\n\t}\n\n\tif s.StrokeWidth >= 0 {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"stroke_width\\\": %0.2f\", s.StrokeWidth))\n\t} else {\n\t\toutput = append(output, \"\\\"stroke_width\\\": null\")\n\t}\n\n\tif !s.StrokeColor.IsZero() {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"stroke_color\\\": %s\", s.StrokeColor.String()))\n\t} else {\n\t\toutput = append(output, \"\\\"stroke_color\\\": null\")\n\t}\n\n\tif len(s.StrokeDashArray) > 0 {\n\t\tvar elements []string\n\t\tfor _, v := range s.StrokeDashArray {\n\t\t\telements = append(elements, fmt.Sprintf(\"%.2f\", v))\n\t\t}\n\t\tdashArray := strings.Join(elements, \", \")\n\t\toutput = append(output, fmt.Sprintf(\"\\\"stroke_dash_array\\\": [%s]\", dashArray))\n\t} else {\n\t\toutput = append(output, \"\\\"stroke_dash_array\\\": null\")\n\t}\n\n\tif s.DotWidth >= 0 {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"dot_width\\\": %0.2f\", s.DotWidth))\n\t} else {\n\t\toutput = append(output, \"\\\"dot_width\\\": null\")\n\t}\n\n\tif !s.DotColor.IsZero() {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"dot_color\\\": %s\", s.DotColor.String()))\n\t} else {\n\t\toutput = append(output, \"\\\"dot_color\\\": null\")\n\t}\n\n\tif !s.FillColor.IsZero() {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"fill_color\\\": %s\", s.FillColor.String()))\n\t} else {\n\t\toutput = append(output, \"\\\"fill_color\\\": null\")\n\t}\n\n\tif s.FontSize != 0 {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"font_size\\\": \\\"%0.2fpt\\\"\", s.FontSize))\n\t} else {\n\t\toutput = append(output, \"\\\"font_size\\\": null\")\n\t}\n\n\tif !s.FontColor.IsZero() {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"font_color\\\": %s\", s.FontColor.String()))\n\t} else {\n\t\toutput = append(output, \"\\\"font_color\\\": null\")\n\t}\n\n\tif s.Font != nil {\n\t\toutput = append(output, fmt.Sprintf(\"\\\"font\\\": \\\"%s\\\"\", s.Font.Name(truetype.NameIDFontFamily)))\n\t} else {\n\t\toutput = append(output, \"\\\"font_color\\\": null\")\n\t}\n\n\treturn \"{\" + strings.Join(output, \", \") + \"}\"\n}\n\n// GetClassName returns the class name or a default.\nfunc (s Style) GetClassName(defaults ...string) string {\n\tif s.ClassName == \"\" {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn \"\"\n\t}\n\treturn s.ClassName\n}\n\n// GetStrokeColor returns the stroke color.\nfunc (s Style) GetStrokeColor(defaults ...drawing.Color) drawing.Color {\n\tif s.StrokeColor.IsZero() {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn drawing.ColorTransparent\n\t}\n\treturn s.StrokeColor\n}\n\n// GetFillColor returns the fill color.\nfunc (s Style) GetFillColor(defaults ...drawing.Color) drawing.Color {\n\tif s.FillColor.IsZero() {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn drawing.ColorTransparent\n\t}\n\treturn s.FillColor\n}\n\n// GetDotColor returns the stroke color.\nfunc (s Style) GetDotColor(defaults ...drawing.Color) drawing.Color {\n\tif s.DotColor.IsZero() {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn drawing.ColorTransparent\n\t}\n\treturn s.DotColor\n}\n\n// GetStrokeWidth returns the stroke width.\nfunc (s Style) GetStrokeWidth(defaults ...float64) float64 {\n\tif s.StrokeWidth == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn DefaultStrokeWidth\n\t}\n\treturn s.StrokeWidth\n}\n\n// GetDotWidth returns the dot width for scatter plots.\nfunc (s Style) GetDotWidth(defaults ...float64) float64 {\n\tif s.DotWidth == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn DefaultDotWidth\n\t}\n\treturn s.DotWidth\n}\n\n// GetStrokeDashArray returns the stroke dash array.\nfunc (s Style) GetStrokeDashArray(defaults ...[]float64) []float64 {\n\tif len(s.StrokeDashArray) == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn nil\n\t}\n\treturn s.StrokeDashArray\n}\n\n// GetFontSize gets the font size.\nfunc (s Style) GetFontSize(defaults ...float64) float64 {\n\tif s.FontSize == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn DefaultFontSize\n\t}\n\treturn s.FontSize\n}\n\n// GetFontColor gets the font size.\nfunc (s Style) GetFontColor(defaults ...drawing.Color) drawing.Color {\n\tif s.FontColor.IsZero() {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn drawing.ColorTransparent\n\t}\n\treturn s.FontColor\n}\n\n// GetFont returns the font face.\nfunc (s Style) GetFont(defaults ...*truetype.Font) *truetype.Font {\n\tif s.Font == nil {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn nil\n\t}\n\treturn s.Font\n}\n\n// GetPadding returns the padding.\nfunc (s Style) GetPadding(defaults ...Box) Box {\n\tif s.Padding.IsZero() {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn Box{}\n\t}\n\treturn s.Padding\n}\n\n// GetTextHorizontalAlign returns the horizontal alignment.\nfunc (s Style) GetTextHorizontalAlign(defaults ...TextHorizontalAlign) TextHorizontalAlign {\n\tif s.TextHorizontalAlign == TextHorizontalAlignUnset {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn TextHorizontalAlignUnset\n\t}\n\treturn s.TextHorizontalAlign\n}\n\n// GetTextVerticalAlign returns the vertical alignment.\nfunc (s Style) GetTextVerticalAlign(defaults ...TextVerticalAlign) TextVerticalAlign {\n\tif s.TextVerticalAlign == TextVerticalAlignUnset {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn TextVerticalAlignUnset\n\t}\n\treturn s.TextVerticalAlign\n}\n\n// GetTextWrap returns the word wrap.\nfunc (s Style) GetTextWrap(defaults ...TextWrap) TextWrap {\n\tif s.TextWrap == TextWrapUnset {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn TextWrapUnset\n\t}\n\treturn s.TextWrap\n}\n\n// GetTextLineSpacing returns the spacing in pixels between lines of text (vertically).\nfunc (s Style) GetTextLineSpacing(defaults ...int) int {\n\tif s.TextLineSpacing == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn DefaultLineSpacing\n\t}\n\treturn s.TextLineSpacing\n}\n\n// GetTextRotationDegrees returns the text rotation in degrees.\nfunc (s Style) GetTextRotationDegrees(defaults ...float64) float64 {\n\tif s.TextRotationDegrees == 0 {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t}\n\treturn s.TextRotationDegrees\n}\n\n// WriteToRenderer passes the style's options to a renderer.\nfunc (s Style) WriteToRenderer(r Renderer) {\n\tr.SetClassName(s.GetClassName())\n\tr.SetStrokeColor(s.GetStrokeColor())\n\tr.SetStrokeWidth(s.GetStrokeWidth())\n\tr.SetStrokeDashArray(s.GetStrokeDashArray())\n\tr.SetFillColor(s.GetFillColor())\n\tr.SetFont(s.GetFont())\n\tr.SetFontColor(s.GetFontColor())\n\tr.SetFontSize(s.GetFontSize())\n\n\tr.ClearTextRotation()\n\tif s.GetTextRotationDegrees() != 0 {\n\t\tr.SetTextRotation(DegreesToRadians(s.GetTextRotationDegrees()))\n\t}\n}\n\n// WriteDrawingOptionsToRenderer passes just the drawing style options to a renderer.\nfunc (s Style) WriteDrawingOptionsToRenderer(r Renderer) {\n\tr.SetClassName(s.GetClassName())\n\tr.SetStrokeColor(s.GetStrokeColor())\n\tr.SetStrokeWidth(s.GetStrokeWidth())\n\tr.SetStrokeDashArray(s.GetStrokeDashArray())\n\tr.SetFillColor(s.GetFillColor())\n}\n\n// WriteTextOptionsToRenderer passes just the text style options to a renderer.\nfunc (s Style) WriteTextOptionsToRenderer(r Renderer) {\n\tr.SetClassName(s.GetClassName())\n\tr.SetFont(s.GetFont())\n\tr.SetFontColor(s.GetFontColor())\n\tr.SetFontSize(s.GetFontSize())\n}\n\n// InheritFrom coalesces two styles into a new style.\nfunc (s Style) InheritFrom(defaults Style) (final Style) {\n\tfinal.ClassName = s.GetClassName(defaults.ClassName)\n\n\tfinal.StrokeColor = s.GetStrokeColor(defaults.StrokeColor)\n\tfinal.StrokeWidth = s.GetStrokeWidth(defaults.StrokeWidth)\n\tfinal.StrokeDashArray = s.GetStrokeDashArray(defaults.StrokeDashArray)\n\n\tfinal.DotColor = s.GetDotColor(defaults.DotColor)\n\tfinal.DotWidth = s.GetDotWidth(defaults.DotWidth)\n\n\tfinal.DotWidthProvider = s.DotWidthProvider\n\tfinal.DotColorProvider = s.DotColorProvider\n\n\tfinal.FillColor = s.GetFillColor(defaults.FillColor)\n\tfinal.FontColor = s.GetFontColor(defaults.FontColor)\n\tfinal.FontSize = s.GetFontSize(defaults.FontSize)\n\tfinal.Font = s.GetFont(defaults.Font)\n\tfinal.Padding = s.GetPadding(defaults.Padding)\n\tfinal.TextHorizontalAlign = s.GetTextHorizontalAlign(defaults.TextHorizontalAlign)\n\tfinal.TextVerticalAlign = s.GetTextVerticalAlign(defaults.TextVerticalAlign)\n\tfinal.TextWrap = s.GetTextWrap(defaults.TextWrap)\n\tfinal.TextLineSpacing = s.GetTextLineSpacing(defaults.TextLineSpacing)\n\tfinal.TextRotationDegrees = s.GetTextRotationDegrees(defaults.TextRotationDegrees)\n\n\treturn\n}\n\n// GetStrokeOptions returns the stroke components.\nfunc (s Style) GetStrokeOptions() Style {\n\treturn Style{\n\t\tClassName:       s.ClassName,\n\t\tStrokeDashArray: s.StrokeDashArray,\n\t\tStrokeColor:     s.StrokeColor,\n\t\tStrokeWidth:     s.StrokeWidth,\n\t}\n}\n\n// GetFillOptions returns the fill components.\nfunc (s Style) GetFillOptions() Style {\n\treturn Style{\n\t\tClassName: s.ClassName,\n\t\tFillColor: s.FillColor,\n\t}\n}\n\n// GetDotOptions returns the dot components.\nfunc (s Style) GetDotOptions() Style {\n\treturn Style{\n\t\tClassName:       s.ClassName,\n\t\tStrokeDashArray: nil,\n\t\tFillColor:       s.DotColor,\n\t\tStrokeColor:     s.DotColor,\n\t\tStrokeWidth:     1.0,\n\t}\n}\n\n// GetFillAndStrokeOptions returns the fill and stroke components.\nfunc (s Style) GetFillAndStrokeOptions() Style {\n\treturn Style{\n\t\tClassName:       s.ClassName,\n\t\tStrokeDashArray: s.StrokeDashArray,\n\t\tFillColor:       s.FillColor,\n\t\tStrokeColor:     s.StrokeColor,\n\t\tStrokeWidth:     s.StrokeWidth,\n\t}\n}\n\n// GetTextOptions returns just the text components of the style.\nfunc (s Style) GetTextOptions() Style {\n\treturn Style{\n\t\tClassName:           s.ClassName,\n\t\tFontColor:           s.FontColor,\n\t\tFontSize:            s.FontSize,\n\t\tFont:                s.Font,\n\t\tTextHorizontalAlign: s.TextHorizontalAlign,\n\t\tTextVerticalAlign:   s.TextVerticalAlign,\n\t\tTextWrap:            s.TextWrap,\n\t\tTextLineSpacing:     s.TextLineSpacing,\n\t\tTextRotationDegrees: s.TextRotationDegrees,\n\t}\n}\n\n// ShouldDrawStroke tells drawing functions if they should draw the stroke.\nfunc (s Style) ShouldDrawStroke() bool {\n\treturn !s.StrokeColor.IsZero() && s.StrokeWidth > 0\n}\n\n// ShouldDrawDot tells drawing functions if they should draw the dot.\nfunc (s Style) ShouldDrawDot() bool {\n\treturn (!s.DotColor.IsZero() && s.DotWidth > 0) || s.DotColorProvider != nil || s.DotWidthProvider != nil\n}\n\n// ShouldDrawFill tells drawing functions if they should draw the stroke.\nfunc (s Style) ShouldDrawFill() bool {\n\treturn !s.FillColor.IsZero()\n}\n"
        },
        {
          "name": "style_test.go",
          "type": "blob",
          "size": 6.5693359375,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/golang/freetype/truetype\"\n\t\"github.com/wcharczuk/go-chart/v2/drawing\"\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestStyleIsZero(t *testing.T) {\n\t// replaced new assertions helper\n\tzero := Style{}\n\ttestutil.AssertTrue(t, zero.IsZero())\n\n\tstrokeColor := Style{StrokeColor: drawing.ColorWhite}\n\ttestutil.AssertFalse(t, strokeColor.IsZero())\n\n\tfillColor := Style{FillColor: drawing.ColorWhite}\n\ttestutil.AssertFalse(t, fillColor.IsZero())\n\n\tstrokeWidth := Style{StrokeWidth: 5.0}\n\ttestutil.AssertFalse(t, strokeWidth.IsZero())\n\n\tfontSize := Style{FontSize: 12.0}\n\ttestutil.AssertFalse(t, fontSize.IsZero())\n\n\tfontColor := Style{FontColor: drawing.ColorWhite}\n\ttestutil.AssertFalse(t, fontColor.IsZero())\n\n\tfont := Style{Font: &truetype.Font{}}\n\ttestutil.AssertFalse(t, font.IsZero())\n}\n\nfunc TestStyleGetStrokeColor(t *testing.T) {\n\t// replaced new assertions helper\n\n\tunset := Style{}\n\ttestutil.AssertEqual(t, drawing.ColorTransparent, unset.GetStrokeColor())\n\ttestutil.AssertEqual(t, drawing.ColorWhite, unset.GetStrokeColor(drawing.ColorWhite))\n\n\tset := Style{StrokeColor: drawing.ColorWhite}\n\ttestutil.AssertEqual(t, drawing.ColorWhite, set.GetStrokeColor())\n\ttestutil.AssertEqual(t, drawing.ColorWhite, set.GetStrokeColor(drawing.ColorBlack))\n}\n\nfunc TestStyleGetFillColor(t *testing.T) {\n\t// replaced new assertions helper\n\n\tunset := Style{}\n\ttestutil.AssertEqual(t, drawing.ColorTransparent, unset.GetFillColor())\n\ttestutil.AssertEqual(t, drawing.ColorWhite, unset.GetFillColor(drawing.ColorWhite))\n\n\tset := Style{FillColor: drawing.ColorWhite}\n\ttestutil.AssertEqual(t, drawing.ColorWhite, set.GetFillColor())\n\ttestutil.AssertEqual(t, drawing.ColorWhite, set.GetFillColor(drawing.ColorBlack))\n}\n\nfunc TestStyleGetStrokeWidth(t *testing.T) {\n\t// replaced new assertions helper\n\n\tunset := Style{}\n\ttestutil.AssertEqual(t, DefaultStrokeWidth, unset.GetStrokeWidth())\n\ttestutil.AssertEqual(t, DefaultStrokeWidth+1, unset.GetStrokeWidth(DefaultStrokeWidth+1))\n\n\tset := Style{StrokeWidth: DefaultStrokeWidth + 2}\n\ttestutil.AssertEqual(t, DefaultStrokeWidth+2, set.GetStrokeWidth())\n\ttestutil.AssertEqual(t, DefaultStrokeWidth+2, set.GetStrokeWidth(DefaultStrokeWidth+1))\n}\n\nfunc TestStyleGetFontSize(t *testing.T) {\n\t// replaced new assertions helper\n\n\tunset := Style{}\n\ttestutil.AssertEqual(t, DefaultFontSize, unset.GetFontSize())\n\ttestutil.AssertEqual(t, DefaultFontSize+1, unset.GetFontSize(DefaultFontSize+1))\n\n\tset := Style{FontSize: DefaultFontSize + 2}\n\ttestutil.AssertEqual(t, DefaultFontSize+2, set.GetFontSize())\n\ttestutil.AssertEqual(t, DefaultFontSize+2, set.GetFontSize(DefaultFontSize+1))\n}\n\nfunc TestStyleGetFontColor(t *testing.T) {\n\t// replaced new assertions helper\n\n\tunset := Style{}\n\ttestutil.AssertEqual(t, drawing.ColorTransparent, unset.GetFontColor())\n\ttestutil.AssertEqual(t, drawing.ColorWhite, unset.GetFontColor(drawing.ColorWhite))\n\n\tset := Style{FontColor: drawing.ColorWhite}\n\ttestutil.AssertEqual(t, drawing.ColorWhite, set.GetFontColor())\n\ttestutil.AssertEqual(t, drawing.ColorWhite, set.GetFontColor(drawing.ColorBlack))\n}\n\nfunc TestStyleGetFont(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tunset := Style{}\n\ttestutil.AssertNil(t, unset.GetFont())\n\ttestutil.AssertEqual(t, f, unset.GetFont(f))\n\n\tset := Style{Font: f}\n\ttestutil.AssertNotNil(t, set.GetFont())\n}\n\nfunc TestStyleGetPadding(t *testing.T) {\n\t// replaced new assertions helper\n\n\tunset := Style{}\n\ttestutil.AssertTrue(t, unset.GetPadding().IsZero())\n\ttestutil.AssertFalse(t, unset.GetPadding(DefaultBackgroundPadding).IsZero())\n\ttestutil.AssertEqual(t, DefaultBackgroundPadding, unset.GetPadding(DefaultBackgroundPadding))\n\n\tset := Style{Padding: DefaultBackgroundPadding}\n\ttestutil.AssertFalse(t, set.GetPadding().IsZero())\n\ttestutil.AssertEqual(t, DefaultBackgroundPadding, set.GetPadding())\n\ttestutil.AssertEqual(t, DefaultBackgroundPadding, set.GetPadding(Box{\n\t\tTop:    DefaultBackgroundPadding.Top + 1,\n\t\tLeft:   DefaultBackgroundPadding.Left + 1,\n\t\tRight:  DefaultBackgroundPadding.Right + 1,\n\t\tBottom: DefaultBackgroundPadding.Bottom + 1,\n\t}))\n}\n\nfunc TestStyleWithDefaultsFrom(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tunset := Style{}\n\tset := Style{\n\t\tStrokeColor: drawing.ColorWhite,\n\t\tStrokeWidth: 5.0,\n\t\tFillColor:   drawing.ColorWhite,\n\t\tFontColor:   drawing.ColorWhite,\n\t\tFont:        f,\n\t\tPadding:     DefaultBackgroundPadding,\n\t}\n\n\tcoalesced := unset.InheritFrom(set)\n\ttestutil.AssertEqual(t, set, coalesced)\n}\n\nfunc TestStyleGetStrokeOptions(t *testing.T) {\n\t// replaced new assertions helper\n\n\tset := Style{\n\t\tStrokeColor: drawing.ColorWhite,\n\t\tStrokeWidth: 5.0,\n\t\tFillColor:   drawing.ColorWhite,\n\t\tFontColor:   drawing.ColorWhite,\n\t\tPadding:     DefaultBackgroundPadding,\n\t}\n\tsvgStroke := set.GetStrokeOptions()\n\ttestutil.AssertFalse(t, svgStroke.StrokeColor.IsZero())\n\ttestutil.AssertNotZero(t, svgStroke.StrokeWidth)\n\ttestutil.AssertTrue(t, svgStroke.FillColor.IsZero())\n\ttestutil.AssertTrue(t, svgStroke.FontColor.IsZero())\n}\n\nfunc TestStyleGetFillOptions(t *testing.T) {\n\t// replaced new assertions helper\n\n\tset := Style{\n\t\tStrokeColor: drawing.ColorWhite,\n\t\tStrokeWidth: 5.0,\n\t\tFillColor:   drawing.ColorWhite,\n\t\tFontColor:   drawing.ColorWhite,\n\t\tPadding:     DefaultBackgroundPadding,\n\t}\n\tsvgFill := set.GetFillOptions()\n\ttestutil.AssertFalse(t, svgFill.FillColor.IsZero())\n\ttestutil.AssertZero(t, svgFill.StrokeWidth)\n\ttestutil.AssertTrue(t, svgFill.StrokeColor.IsZero())\n\ttestutil.AssertTrue(t, svgFill.FontColor.IsZero())\n}\n\nfunc TestStyleGetFillAndStrokeOptions(t *testing.T) {\n\t// replaced new assertions helper\n\n\tset := Style{\n\t\tStrokeColor: drawing.ColorWhite,\n\t\tStrokeWidth: 5.0,\n\t\tFillColor:   drawing.ColorWhite,\n\t\tFontColor:   drawing.ColorWhite,\n\t\tPadding:     DefaultBackgroundPadding,\n\t}\n\tsvgFillAndStroke := set.GetFillAndStrokeOptions()\n\ttestutil.AssertFalse(t, svgFillAndStroke.FillColor.IsZero())\n\ttestutil.AssertNotZero(t, svgFillAndStroke.StrokeWidth)\n\ttestutil.AssertFalse(t, svgFillAndStroke.StrokeColor.IsZero())\n\ttestutil.AssertTrue(t, svgFillAndStroke.FontColor.IsZero())\n}\n\nfunc TestStyleGetTextOptions(t *testing.T) {\n\t// replaced new assertions helper\n\n\tset := Style{\n\t\tStrokeColor: drawing.ColorWhite,\n\t\tStrokeWidth: 5.0,\n\t\tFillColor:   drawing.ColorWhite,\n\t\tFontColor:   drawing.ColorWhite,\n\t\tPadding:     DefaultBackgroundPadding,\n\t}\n\tsvgStroke := set.GetTextOptions()\n\ttestutil.AssertTrue(t, svgStroke.StrokeColor.IsZero())\n\ttestutil.AssertZero(t, svgStroke.StrokeWidth)\n\ttestutil.AssertTrue(t, svgStroke.FillColor.IsZero())\n\ttestutil.AssertFalse(t, svgStroke.FontColor.IsZero())\n}\n"
        },
        {
          "name": "testutil",
          "type": "tree",
          "content": null
        },
        {
          "name": "text.go",
          "type": "blob",
          "size": 4.7685546875,
          "content": "package chart\n\nimport (\n\t\"strings\"\n)\n\n// TextHorizontalAlign is an enum for the horizontal alignment options.\ntype TextHorizontalAlign int\n\nconst (\n\t// TextHorizontalAlignUnset is the unset state for text horizontal alignment.\n\tTextHorizontalAlignUnset TextHorizontalAlign = 0\n\t// TextHorizontalAlignLeft aligns a string horizontally so that it's left ligature starts at horizontal pixel 0.\n\tTextHorizontalAlignLeft TextHorizontalAlign = 1\n\t// TextHorizontalAlignCenter left aligns a string horizontally so that there are equal pixels\n\t// to the left and to the right of a string within a box.\n\tTextHorizontalAlignCenter TextHorizontalAlign = 2\n\t// TextHorizontalAlignRight right aligns a string horizontally so that the right ligature ends at the right-most pixel\n\t// of a box.\n\tTextHorizontalAlignRight TextHorizontalAlign = 3\n)\n\n// TextWrap is an enum for the word wrap options.\ntype TextWrap int\n\nconst (\n\t// TextWrapUnset is the unset state for text wrap options.\n\tTextWrapUnset TextWrap = 0\n\t// TextWrapNone will spill text past horizontal boundaries.\n\tTextWrapNone TextWrap = 1\n\t// TextWrapWord will split a string on words (i.e. spaces) to fit within a horizontal boundary.\n\tTextWrapWord TextWrap = 2\n\t// TextWrapRune will split a string on a rune (i.e. utf-8 codepage) to fit within a horizontal boundary.\n\tTextWrapRune TextWrap = 3\n)\n\n// TextVerticalAlign is an enum for the vertical alignment options.\ntype TextVerticalAlign int\n\nconst (\n\t// TextVerticalAlignUnset is the unset state for vertical alignment options.\n\tTextVerticalAlignUnset TextVerticalAlign = 0\n\t// TextVerticalAlignBaseline aligns text according to the \"baseline\" of the string, or where a normal ascender begins.\n\tTextVerticalAlignBaseline TextVerticalAlign = 1\n\t// TextVerticalAlignBottom aligns the text according to the lowers pixel of any of the ligatures (ex. g or q both extend below the baseline).\n\tTextVerticalAlignBottom TextVerticalAlign = 2\n\t// TextVerticalAlignMiddle aligns the text so that there is an equal amount of space above and below the top and bottom of the ligatures.\n\tTextVerticalAlignMiddle TextVerticalAlign = 3\n\t// TextVerticalAlignMiddleBaseline aligns the text vertically so that there is an equal number of pixels above and below the baseline of the string.\n\tTextVerticalAlignMiddleBaseline TextVerticalAlign = 4\n\t// TextVerticalAlignTop alignts the text so that the top of the ligatures are at y-pixel 0 in the container.\n\tTextVerticalAlignTop TextVerticalAlign = 5\n)\n\nvar (\n\t// Text contains utilities for text.\n\tText = &text{}\n)\n\n// TextStyle encapsulates text style options.\ntype TextStyle struct {\n\tHorizontalAlign TextHorizontalAlign\n\tVerticalAlign   TextVerticalAlign\n\tWrap            TextWrap\n}\n\ntype text struct{}\n\nfunc (t text) WrapFit(r Renderer, value string, width int, style Style) []string {\n\tswitch style.TextWrap {\n\tcase TextWrapRune:\n\t\treturn t.WrapFitRune(r, value, width, style)\n\tcase TextWrapWord:\n\t\treturn t.WrapFitWord(r, value, width, style)\n\t}\n\treturn []string{value}\n}\n\nfunc (t text) WrapFitWord(r Renderer, value string, width int, style Style) []string {\n\tstyle.WriteToRenderer(r)\n\n\tvar output []string\n\tvar line string\n\tvar word string\n\n\tvar textBox Box\n\n\tfor _, c := range value {\n\t\tif c == rune('\\n') { // commit the line to output\n\t\t\toutput = append(output, t.Trim(line+word))\n\t\t\tline = \"\"\n\t\t\tword = \"\"\n\t\t\tcontinue\n\t\t}\n\n\t\ttextBox = r.MeasureText(line + word + string(c))\n\n\t\tif textBox.Width() >= width {\n\t\t\toutput = append(output, t.Trim(line))\n\t\t\tline = word\n\t\t\tword = string(c)\n\t\t\tcontinue\n\t\t}\n\n\t\tif c == rune(' ') || c == rune('\\t') {\n\t\t\tline = line + word + string(c)\n\t\t\tword = \"\"\n\t\t\tcontinue\n\t\t}\n\t\tword = word + string(c)\n\t}\n\n\treturn append(output, t.Trim(line+word))\n}\n\nfunc (t text) WrapFitRune(r Renderer, value string, width int, style Style) []string {\n\tstyle.WriteToRenderer(r)\n\n\tvar output []string\n\tvar line string\n\tvar textBox Box\n\tfor _, c := range value {\n\t\tif c == rune('\\n') {\n\t\t\toutput = append(output, line)\n\t\t\tline = \"\"\n\t\t\tcontinue\n\t\t}\n\n\t\ttextBox = r.MeasureText(line + string(c))\n\n\t\tif textBox.Width() >= width {\n\t\t\toutput = append(output, line)\n\t\t\tline = string(c)\n\t\t\tcontinue\n\t\t}\n\t\tline = line + string(c)\n\t}\n\treturn t.appendLast(output, line)\n}\n\nfunc (t text) Trim(value string) string {\n\treturn strings.Trim(value, \" \\t\\n\\r\")\n}\n\nfunc (t text) MeasureLines(r Renderer, lines []string, style Style) Box {\n\tstyle.WriteTextOptionsToRenderer(r)\n\tvar output Box\n\tfor index, line := range lines {\n\t\tlineBox := r.MeasureText(line)\n\t\toutput.Right = MaxInt(lineBox.Right, output.Right)\n\t\toutput.Bottom += lineBox.Height()\n\t\tif index < len(lines)-1 {\n\t\t\toutput.Bottom += +style.GetTextLineSpacing()\n\t\t}\n\t}\n\treturn output\n}\n\nfunc (t text) appendLast(lines []string, text string) []string {\n\tif len(lines) == 0 {\n\t\treturn []string{text}\n\t}\n\tlastLine := lines[len(lines)-1]\n\tlines[len(lines)-1] = lastLine + text\n\treturn lines\n}\n"
        },
        {
          "name": "text_test.go",
          "type": "blob",
          "size": 1.701171875,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestTextWrapWord(t *testing.T) {\n\t// replaced new assertions helper\n\n\tr, err := PNG(1024, 1024)\n\ttestutil.AssertNil(t, err)\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tbasicTextStyle := Style{Font: f, FontSize: 24}\n\n\toutput := Text.WrapFitWord(r, \"this is a test string\", 100, basicTextStyle)\n\ttestutil.AssertNotEmpty(t, output)\n\ttestutil.AssertLen(t, output, 3)\n\n\tfor _, line := range output {\n\t\tbasicTextStyle.WriteToRenderer(r)\n\t\tlineBox := r.MeasureText(line)\n\t\ttestutil.AssertTrue(t, lineBox.Width() < 100, line+\": \"+lineBox.String())\n\t}\n\ttestutil.AssertEqual(t, \"this is\", output[0])\n\ttestutil.AssertEqual(t, \"a test\", output[1])\n\ttestutil.AssertEqual(t, \"string\", output[2])\n\n\toutput = Text.WrapFitWord(r, \"foo\", 100, basicTextStyle)\n\ttestutil.AssertLen(t, output, 1)\n\ttestutil.AssertEqual(t, \"foo\", output[0])\n\n\t// test that it handles newlines.\n\toutput = Text.WrapFitWord(r, \"this\\nis\\na\\ntest\\nstring\", 100, basicTextStyle)\n\ttestutil.AssertLen(t, output, 5)\n\n\t// test that it handles newlines and long lines.\n\toutput = Text.WrapFitWord(r, \"this\\nis\\na\\ntest\\nstring that is very long\", 100, basicTextStyle)\n\ttestutil.AssertLen(t, output, 8)\n}\n\nfunc TestTextWrapRune(t *testing.T) {\n\t// replaced new assertions helper\n\n\tr, err := PNG(1024, 1024)\n\ttestutil.AssertNil(t, err)\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tbasicTextStyle := Style{Font: f, FontSize: 24}\n\n\toutput := Text.WrapFitRune(r, \"this is a test string\", 150, basicTextStyle)\n\ttestutil.AssertNotEmpty(t, output)\n\ttestutil.AssertLen(t, output, 2)\n\ttestutil.AssertEqual(t, \"this is a t\", output[0])\n\ttestutil.AssertEqual(t, \"est string\", output[1])\n}\n"
        },
        {
          "name": "tick.go",
          "type": "blob",
          "size": 2.48046875,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n)\n\n// TicksProvider is a type that provides ticks.\ntype TicksProvider interface {\n\tGetTicks(r Renderer, defaults Style, vf ValueFormatter) []Tick\n}\n\n// Tick represents a label on an axis.\ntype Tick struct {\n\tValue float64\n\tLabel string\n}\n\n// Ticks is an array of ticks.\ntype Ticks []Tick\n\n// Len returns the length of the ticks set.\nfunc (t Ticks) Len() int {\n\treturn len(t)\n}\n\n// Swap swaps two elements.\nfunc (t Ticks) Swap(i, j int) {\n\tt[i], t[j] = t[j], t[i]\n}\n\n// Less returns if i's value is less than j's value.\nfunc (t Ticks) Less(i, j int) bool {\n\treturn t[i].Value < t[j].Value\n}\n\n// String returns a string representation of the set of ticks.\nfunc (t Ticks) String() string {\n\tvar values []string\n\tfor i, tick := range t {\n\t\tvalues = append(values, fmt.Sprintf(\"[%d: %s]\", i, tick.Label))\n\t}\n\treturn strings.Join(values, \", \")\n}\n\n// GenerateContinuousTicks generates a set of ticks.\nfunc GenerateContinuousTicks(r Renderer, ra Range, isVertical bool, style Style, vf ValueFormatter) []Tick {\n\tif vf == nil {\n\t\tvf = FloatValueFormatter\n\t}\n\n\tvar ticks []Tick\n\tmin, max := ra.GetMin(), ra.GetMax()\n\n\tif ra.IsDescending() {\n\t\tticks = append(ticks, Tick{\n\t\t\tValue: max,\n\t\t\tLabel: vf(max),\n\t\t})\n\t} else {\n\t\tticks = append(ticks, Tick{\n\t\t\tValue: min,\n\t\t\tLabel: vf(min),\n\t\t})\n\t}\n\n\tminLabel := vf(min)\n\tstyle.GetTextOptions().WriteToRenderer(r)\n\tlabelBox := r.MeasureText(minLabel)\n\n\tvar tickSize float64\n\tif isVertical {\n\t\ttickSize = float64(labelBox.Height() + DefaultMinimumTickVerticalSpacing)\n\t} else {\n\t\ttickSize = float64(labelBox.Width() + DefaultMinimumTickHorizontalSpacing)\n\t}\n\n\tdomain := float64(ra.GetDomain())\n\tdomainRemainder := domain - (tickSize * 2)\n\tintermediateTickCount := int(math.Floor(float64(domainRemainder) / float64(tickSize)))\n\n\trangeDelta := math.Abs(max - min)\n\ttickStep := rangeDelta / float64(intermediateTickCount)\n\n\troundTo := GetRoundToForDelta(rangeDelta) / 10\n\tintermediateTickCount = MinInt(intermediateTickCount, DefaultTickCountSanityCheck)\n\n\tfor x := 1; x < intermediateTickCount; x++ {\n\t\tvar tickValue float64\n\t\tif ra.IsDescending() {\n\t\t\ttickValue = max - RoundUp(tickStep*float64(x), roundTo)\n\t\t} else {\n\t\t\ttickValue = min + RoundUp(tickStep*float64(x), roundTo)\n\t\t}\n\t\tticks = append(ticks, Tick{\n\t\t\tValue: tickValue,\n\t\t\tLabel: vf(tickValue),\n\t\t})\n\t}\n\n\tif ra.IsDescending() {\n\t\tticks = append(ticks, Tick{\n\t\t\tValue: min,\n\t\t\tLabel: vf(min),\n\t\t})\n\t} else {\n\t\tticks = append(ticks, Tick{\n\t\t\tValue: max,\n\t\t\tLabel: vf(max),\n\t\t})\n\t}\n\n\treturn ticks\n}\n"
        },
        {
          "name": "tick_test.go",
          "type": "blob",
          "size": 1.298828125,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestGenerateContinuousTicks(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tr, err := PNG(1024, 1024)\n\ttestutil.AssertNil(t, err)\n\tr.SetFont(f)\n\n\tra := &ContinuousRange{\n\t\tMin:    0.0,\n\t\tMax:    10.0,\n\t\tDomain: 256,\n\t}\n\n\tvf := FloatValueFormatter\n\n\tticks := GenerateContinuousTicks(r, ra, false, Style{}, vf)\n\ttestutil.AssertNotEmpty(t, ticks)\n\ttestutil.AssertLen(t, ticks, 11)\n\ttestutil.AssertEqual(t, 0.0, ticks[0].Value)\n\ttestutil.AssertEqual(t, 10, ticks[len(ticks)-1].Value)\n}\n\nfunc TestGenerateContinuousTicksDescending(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tr, err := PNG(1024, 1024)\n\ttestutil.AssertNil(t, err)\n\tr.SetFont(f)\n\n\tra := &ContinuousRange{\n\t\tMin:        0.0,\n\t\tMax:        10.0,\n\t\tDomain:     256,\n\t\tDescending: true,\n\t}\n\n\tvf := FloatValueFormatter\n\n\tticks := GenerateContinuousTicks(r, ra, false, Style{}, vf)\n\ttestutil.AssertNotEmpty(t, ticks)\n\ttestutil.AssertLen(t, ticks, 11)\n\ttestutil.AssertEqual(t, 10.0, ticks[0].Value)\n\ttestutil.AssertEqual(t, 9.0, ticks[1].Value)\n\ttestutil.AssertEqual(t, 1.0, ticks[len(ticks)-2].Value)\n\ttestutil.AssertEqual(t, 0.0, ticks[len(ticks)-1].Value)\n}\n"
        },
        {
          "name": "time_series.go",
          "type": "blob",
          "size": 2.013671875,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// Interface Assertions.\nvar (\n\t_ Series                 = (*TimeSeries)(nil)\n\t_ FirstValuesProvider    = (*TimeSeries)(nil)\n\t_ LastValuesProvider     = (*TimeSeries)(nil)\n\t_ ValueFormatterProvider = (*TimeSeries)(nil)\n)\n\n// TimeSeries is a line on a chart.\ntype TimeSeries struct {\n\tName  string\n\tStyle Style\n\n\tYAxis YAxisType\n\n\tXValues []time.Time\n\tYValues []float64\n}\n\n// GetName returns the name of the time series.\nfunc (ts TimeSeries) GetName() string {\n\treturn ts.Name\n}\n\n// GetStyle returns the line style.\nfunc (ts TimeSeries) GetStyle() Style {\n\treturn ts.Style\n}\n\n// Len returns the number of elements in the series.\nfunc (ts TimeSeries) Len() int {\n\treturn len(ts.XValues)\n}\n\n// GetValues gets x, y values at a given index.\nfunc (ts TimeSeries) GetValues(index int) (x, y float64) {\n\tx = TimeToFloat64(ts.XValues[index])\n\ty = ts.YValues[index]\n\treturn\n}\n\n// GetFirstValues gets the first values.\nfunc (ts TimeSeries) GetFirstValues() (x, y float64) {\n\tx = TimeToFloat64(ts.XValues[0])\n\ty = ts.YValues[0]\n\treturn\n}\n\n// GetLastValues gets the last values.\nfunc (ts TimeSeries) GetLastValues() (x, y float64) {\n\tx = TimeToFloat64(ts.XValues[len(ts.XValues)-1])\n\ty = ts.YValues[len(ts.YValues)-1]\n\treturn\n}\n\n// GetValueFormatters returns value formatter defaults for the series.\nfunc (ts TimeSeries) GetValueFormatters() (x, y ValueFormatter) {\n\tx = TimeValueFormatter\n\ty = FloatValueFormatter\n\treturn\n}\n\n// GetYAxis returns which YAxis the series draws on.\nfunc (ts TimeSeries) GetYAxis() YAxisType {\n\treturn ts.YAxis\n}\n\n// Render renders the series.\nfunc (ts TimeSeries) Render(r Renderer, canvasBox Box, xrange, yrange Range, defaults Style) {\n\tstyle := ts.Style.InheritFrom(defaults)\n\tDraw.LineSeries(r, canvasBox, xrange, yrange, style, ts)\n}\n\n// Validate validates the series.\nfunc (ts TimeSeries) Validate() error {\n\tif len(ts.XValues) == 0 {\n\t\treturn fmt.Errorf(\"time series must have xvalues set\")\n\t}\n\n\tif len(ts.YValues) == 0 {\n\t\treturn fmt.Errorf(\"time series must have yvalues set\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "time_series_test.go",
          "type": "blob",
          "size": 1.357421875,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestTimeSeriesGetValue(t *testing.T) {\n\t// replaced new assertions helper\n\n\tts := TimeSeries{\n\t\tName: \"Test\",\n\t\tXValues: []time.Time{\n\t\t\ttime.Now().AddDate(0, 0, -5),\n\t\t\ttime.Now().AddDate(0, 0, -4),\n\t\t\ttime.Now().AddDate(0, 0, -3),\n\t\t\ttime.Now().AddDate(0, 0, -2),\n\t\t\ttime.Now().AddDate(0, 0, -1),\n\t\t},\n\t\tYValues: []float64{\n\t\t\t1.0, 2.0, 3.0, 4.0, 5.0,\n\t\t},\n\t}\n\n\tx0, y0 := ts.GetValues(0)\n\ttestutil.AssertNotZero(t, x0)\n\ttestutil.AssertEqual(t, 1.0, y0)\n}\n\nfunc TestTimeSeriesValidate(t *testing.T) {\n\t// replaced new assertions helper\n\n\tcs := TimeSeries{\n\t\tName: \"Test Series\",\n\t\tXValues: []time.Time{\n\t\t\ttime.Now().AddDate(0, 0, -5),\n\t\t\ttime.Now().AddDate(0, 0, -4),\n\t\t\ttime.Now().AddDate(0, 0, -3),\n\t\t\ttime.Now().AddDate(0, 0, -2),\n\t\t\ttime.Now().AddDate(0, 0, -1),\n\t\t},\n\t\tYValues: []float64{\n\t\t\t1.0, 2.0, 3.0, 4.0, 5.0,\n\t\t},\n\t}\n\ttestutil.AssertNil(t, cs.Validate())\n\n\tcs = TimeSeries{\n\t\tName: \"Test Series\",\n\t\tXValues: []time.Time{\n\t\t\ttime.Now().AddDate(0, 0, -5),\n\t\t\ttime.Now().AddDate(0, 0, -4),\n\t\t\ttime.Now().AddDate(0, 0, -3),\n\t\t\ttime.Now().AddDate(0, 0, -2),\n\t\t\ttime.Now().AddDate(0, 0, -1),\n\t\t},\n\t}\n\ttestutil.AssertNotNil(t, cs.Validate())\n\n\tcs = TimeSeries{\n\t\tName: \"Test Series\",\n\t\tYValues: []float64{\n\t\t\t1.0, 2.0, 3.0, 4.0, 5.0,\n\t\t},\n\t}\n\ttestutil.AssertNotNil(t, cs.Validate())\n}\n"
        },
        {
          "name": "times.go",
          "type": "blob",
          "size": 0.896484375,
          "content": "package chart\n\nimport (\n\t\"sort\"\n\t\"time\"\n)\n\n// Assert types implement interfaces.\nvar (\n\t_ Sequence       = (*Times)(nil)\n\t_ sort.Interface = (*Times)(nil)\n)\n\n// Times are an array of times.\n// It wraps the array with methods that implement `seq.Provider`.\ntype Times []time.Time\n\n// Array returns the times to an array.\nfunc (t Times) Array() []time.Time {\n\treturn []time.Time(t)\n}\n\n// Len returns the length of the array.\nfunc (t Times) Len() int {\n\treturn len(t)\n}\n\n// GetValue returns a value at an index as a time.\nfunc (t Times) GetValue(index int) float64 {\n\treturn ToFloat64(t[index])\n}\n\n// Swap implements sort.Interface.\nfunc (t Times) Swap(i, j int) {\n\tt[i], t[j] = t[j], t[i]\n}\n\n// Less implements sort.Interface.\nfunc (t Times) Less(i, j int) bool {\n\treturn t[i].Before(t[j])\n}\n\n// ToFloat64 returns a float64 representation of a time.\nfunc ToFloat64(t time.Time) float64 {\n\treturn float64(t.UnixNano())\n}\n"
        },
        {
          "name": "timeutil.go",
          "type": "blob",
          "size": 3.5029296875,
          "content": "package chart\n\nimport \"time\"\n\n// SecondsPerXYZ\nconst (\n\tSecondsPerHour = 60 * 60\n\tSecondsPerDay  = 60 * 60 * 24\n)\n\n// TimeMillis returns a duration as a float millis.\nfunc TimeMillis(d time.Duration) float64 {\n\treturn float64(d) / float64(time.Millisecond)\n}\n\n// DiffHours returns the difference in hours between two times.\nfunc DiffHours(t1, t2 time.Time) (hours int) {\n\tt1n := t1.Unix()\n\tt2n := t2.Unix()\n\tvar diff int64\n\tif t1n > t2n {\n\t\tdiff = t1n - t2n\n\t} else {\n\t\tdiff = t2n - t1n\n\t}\n\treturn int(diff / (SecondsPerHour))\n}\n\n// TimeMin returns the minimum and maximum times in a given range.\nfunc TimeMin(times ...time.Time) (min time.Time) {\n\tif len(times) == 0 {\n\t\treturn\n\t}\n\tmin = times[0]\n\tfor index := 1; index < len(times); index++ {\n\t\tif times[index].Before(min) {\n\t\t\tmin = times[index]\n\t\t}\n\n\t}\n\treturn\n}\n\n// TimeMax returns the minimum and maximum times in a given range.\nfunc TimeMax(times ...time.Time) (max time.Time) {\n\tif len(times) == 0 {\n\t\treturn\n\t}\n\tmax = times[0]\n\n\tfor index := 1; index < len(times); index++ {\n\t\tif times[index].After(max) {\n\t\t\tmax = times[index]\n\t\t}\n\t}\n\treturn\n}\n\n// TimeMinMax returns the minimum and maximum times in a given range.\nfunc TimeMinMax(times ...time.Time) (min, max time.Time) {\n\tif len(times) == 0 {\n\t\treturn\n\t}\n\tmin = times[0]\n\tmax = times[0]\n\n\tfor index := 1; index < len(times); index++ {\n\t\tif times[index].Before(min) {\n\t\t\tmin = times[index]\n\t\t}\n\t\tif times[index].After(max) {\n\t\t\tmax = times[index]\n\t\t}\n\t}\n\treturn\n}\n\n// TimeToFloat64 returns a float64 representation of a time.\nfunc TimeToFloat64(t time.Time) float64 {\n\treturn float64(t.UnixNano())\n}\n\n// TimeFromFloat64 returns a time from a float64.\nfunc TimeFromFloat64(tf float64) time.Time {\n\treturn time.Unix(0, int64(tf))\n}\n\n// TimeDescending sorts a given list of times ascending, or min to max.\ntype TimeDescending []time.Time\n\n// Len implements sort.Sorter\nfunc (d TimeDescending) Len() int { return len(d) }\n\n// Swap implements sort.Sorter\nfunc (d TimeDescending) Swap(i, j int) { d[i], d[j] = d[j], d[i] }\n\n// Less implements sort.Sorter\nfunc (d TimeDescending) Less(i, j int) bool { return d[i].After(d[j]) }\n\n// TimeAscending sorts a given list of times ascending, or min to max.\ntype TimeAscending []time.Time\n\n// Len implements sort.Sorter\nfunc (a TimeAscending) Len() int { return len(a) }\n\n// Swap implements sort.Sorter\nfunc (a TimeAscending) Swap(i, j int) { a[i], a[j] = a[j], a[i] }\n\n// Less implements sort.Sorter\nfunc (a TimeAscending) Less(i, j int) bool { return a[i].Before(a[j]) }\n\n// Days generates a seq of timestamps by day, from -days to today.\nfunc Days(days int) []time.Time {\n\tvar values []time.Time\n\tfor day := days; day >= 0; day-- {\n\t\tvalues = append(values, time.Now().AddDate(0, 0, -day))\n\t}\n\treturn values\n}\n\n// Hours returns a sequence of times by the hour for a given number of hours\n// after a given start.\nfunc Hours(start time.Time, totalHours int) []time.Time {\n\ttimes := make([]time.Time, totalHours)\n\n\tlast := start\n\tfor i := 0; i < totalHours; i++ {\n\t\ttimes[i] = last\n\t\tlast = last.Add(time.Hour)\n\t}\n\n\treturn times\n}\n\n// HoursFilled adds zero values for the data bounded by the start and end of the xdata array.\nfunc HoursFilled(xdata []time.Time, ydata []float64) ([]time.Time, []float64) {\n\tstart, end := TimeMinMax(xdata...)\n\ttotalHours := DiffHours(start, end)\n\n\tfinalTimes := Hours(start, totalHours+1)\n\tfinalValues := make([]float64, totalHours+1)\n\n\tvar hoursFromStart int\n\tfor i, xd := range xdata {\n\t\thoursFromStart = DiffHours(start, xd)\n\t\tfinalValues[hoursFromStart] = ydata[i]\n\t}\n\n\treturn finalTimes, finalValues\n}\n"
        },
        {
          "name": "value.go",
          "type": "blob",
          "size": 0.9345703125,
          "content": "package chart\n\n// Value is a chart value.\ntype Value struct {\n\tStyle Style\n\tLabel string\n\tValue float64\n}\n\n// Values is an array of Value.\ntype Values []Value\n\n// Values returns the values.\nfunc (vs Values) Values() []float64 {\n\tvalues := make([]float64, len(vs))\n\tfor index, v := range vs {\n\t\tvalues[index] = v.Value\n\t}\n\treturn values\n}\n\n// ValuesNormalized returns normalized values.\nfunc (vs Values) ValuesNormalized() []float64 {\n\treturn Normalize(vs.Values()...)\n}\n\n// Normalize returns the values normalized.\nfunc (vs Values) Normalize() []Value {\n\tvar output []Value\n\tvar total float64\n\n\tfor _, v := range vs {\n\t\ttotal += v.Value\n\t}\n\n\tfor _, v := range vs {\n\t\tif v.Value > 0 {\n\t\t\toutput = append(output, Value{\n\t\t\t\tStyle: v.Style,\n\t\t\t\tLabel: v.Label,\n\t\t\t\tValue: RoundDown(v.Value/total, 0.0001),\n\t\t\t})\n\t\t}\n\t}\n\treturn output\n}\n\n// Value2 is a two axis value.\ntype Value2 struct {\n\tStyle          Style\n\tLabel          string\n\tXValue, YValue float64\n}\n"
        },
        {
          "name": "value_buffer.go",
          "type": "blob",
          "size": 5.1201171875,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nconst (\n\tbufferMinimumGrow     = 4\n\tbufferShrinkThreshold = 32\n\tbufferGrowFactor      = 200\n\tbufferDefaultCapacity = 4\n)\n\n// NewValueBuffer creates a new value buffer with an optional set of values.\nfunc NewValueBuffer(values ...float64) *ValueBuffer {\n\tvar tail int\n\tarray := make([]float64, MaxInt(len(values), bufferDefaultCapacity))\n\tif len(values) > 0 {\n\t\tcopy(array, values)\n\t\ttail = len(values)\n\t}\n\treturn &ValueBuffer{\n\t\tarray: array,\n\t\thead:  0,\n\t\ttail:  tail,\n\t\tsize:  len(values),\n\t}\n}\n\n// NewValueBufferWithCapacity creates a new ValueBuffer pre-allocated with the given capacity.\nfunc NewValueBufferWithCapacity(capacity int) *ValueBuffer {\n\treturn &ValueBuffer{\n\t\tarray: make([]float64, capacity),\n\t\thead:  0,\n\t\ttail:  0,\n\t\tsize:  0,\n\t}\n}\n\n// ValueBuffer is a fifo datastructure that is backed by a pre-allocated array.\n// Instead of allocating a whole new node object for each element, array elements are re-used (which saves GC churn).\n// Enqueue can be O(n), Dequeue is generally O(1).\n// Buffer implements `seq.Provider`\ntype ValueBuffer struct {\n\tarray []float64\n\thead  int\n\ttail  int\n\tsize  int\n}\n\n// Len returns the length of the Buffer (as it is currently populated).\n// Actual memory footprint may be different.\nfunc (b *ValueBuffer) Len() int {\n\treturn b.size\n}\n\n// GetValue implements seq provider.\nfunc (b *ValueBuffer) GetValue(index int) float64 {\n\teffectiveIndex := (b.head + index) % len(b.array)\n\treturn b.array[effectiveIndex]\n}\n\n// Capacity returns the total size of the Buffer, including empty elements.\nfunc (b *ValueBuffer) Capacity() int {\n\treturn len(b.array)\n}\n\n// SetCapacity sets the capacity of the Buffer.\nfunc (b *ValueBuffer) SetCapacity(capacity int) {\n\tnewArray := make([]float64, capacity)\n\tif b.size > 0 {\n\t\tif b.head < b.tail {\n\t\t\tarrayCopy(b.array, b.head, newArray, 0, b.size)\n\t\t} else {\n\t\t\tarrayCopy(b.array, b.head, newArray, 0, len(b.array)-b.head)\n\t\t\tarrayCopy(b.array, 0, newArray, len(b.array)-b.head, b.tail)\n\t\t}\n\t}\n\tb.array = newArray\n\tb.head = 0\n\tif b.size == capacity {\n\t\tb.tail = 0\n\t} else {\n\t\tb.tail = b.size\n\t}\n}\n\n// Clear removes all objects from the Buffer.\nfunc (b *ValueBuffer) Clear() {\n\tb.array = make([]float64, bufferDefaultCapacity)\n\tb.head = 0\n\tb.tail = 0\n\tb.size = 0\n}\n\n// Enqueue adds an element to the \"back\" of the Buffer.\nfunc (b *ValueBuffer) Enqueue(value float64) {\n\tif b.size == len(b.array) {\n\t\tnewCapacity := int(len(b.array) * int(bufferGrowFactor/100))\n\t\tif newCapacity < (len(b.array) + bufferMinimumGrow) {\n\t\t\tnewCapacity = len(b.array) + bufferMinimumGrow\n\t\t}\n\t\tb.SetCapacity(newCapacity)\n\t}\n\n\tb.array[b.tail] = value\n\tb.tail = (b.tail + 1) % len(b.array)\n\tb.size++\n}\n\n// Dequeue removes the first element from the RingBuffer.\nfunc (b *ValueBuffer) Dequeue() float64 {\n\tif b.size == 0 {\n\t\treturn 0\n\t}\n\n\tremoved := b.array[b.head]\n\tb.head = (b.head + 1) % len(b.array)\n\tb.size--\n\treturn removed\n}\n\n// Peek returns but does not remove the first element.\nfunc (b *ValueBuffer) Peek() float64 {\n\tif b.size == 0 {\n\t\treturn 0\n\t}\n\treturn b.array[b.head]\n}\n\n// PeekBack returns but does not remove the last element.\nfunc (b *ValueBuffer) PeekBack() float64 {\n\tif b.size == 0 {\n\t\treturn 0\n\t}\n\tif b.tail == 0 {\n\t\treturn b.array[len(b.array)-1]\n\t}\n\treturn b.array[b.tail-1]\n}\n\n// TrimExcess resizes the capacity of the buffer to better fit the contents.\nfunc (b *ValueBuffer) TrimExcess() {\n\tthreshold := float64(len(b.array)) * 0.9\n\tif b.size < int(threshold) {\n\t\tb.SetCapacity(b.size)\n\t}\n}\n\n// Array returns the ring buffer, in order, as an array.\nfunc (b *ValueBuffer) Array() Array {\n\tnewArray := make([]float64, b.size)\n\n\tif b.size == 0 {\n\t\treturn newArray\n\t}\n\n\tif b.head < b.tail {\n\t\tarrayCopy(b.array, b.head, newArray, 0, b.size)\n\t} else {\n\t\tarrayCopy(b.array, b.head, newArray, 0, len(b.array)-b.head)\n\t\tarrayCopy(b.array, 0, newArray, len(b.array)-b.head, b.tail)\n\t}\n\n\treturn Array(newArray)\n}\n\n// Each calls the consumer for each element in the buffer.\nfunc (b *ValueBuffer) Each(mapfn func(int, float64)) {\n\tif b.size == 0 {\n\t\treturn\n\t}\n\n\tvar index int\n\tif b.head < b.tail {\n\t\tfor cursor := b.head; cursor < b.tail; cursor++ {\n\t\t\tmapfn(index, b.array[cursor])\n\t\t\tindex++\n\t\t}\n\t} else {\n\t\tfor cursor := b.head; cursor < len(b.array); cursor++ {\n\t\t\tmapfn(index, b.array[cursor])\n\t\t\tindex++\n\t\t}\n\t\tfor cursor := 0; cursor < b.tail; cursor++ {\n\t\t\tmapfn(index, b.array[cursor])\n\t\t\tindex++\n\t\t}\n\t}\n}\n\n// String returns a string representation for value buffers.\nfunc (b *ValueBuffer) String() string {\n\tvar values []string\n\tfor _, elem := range b.Array() {\n\t\tvalues = append(values, fmt.Sprintf(\"%v\", elem))\n\t}\n\treturn strings.Join(values, \" <= \")\n}\n\n// --------------------------------------------------------------------------------\n// Util methods\n// --------------------------------------------------------------------------------\n\nfunc arrayClear(source []float64, index, length int) {\n\tfor x := 0; x < length; x++ {\n\t\tabsoluteIndex := x + index\n\t\tsource[absoluteIndex] = 0\n\t}\n}\n\nfunc arrayCopy(source []float64, sourceIndex int, destination []float64, destinationIndex, length int) {\n\tfor x := 0; x < length; x++ {\n\t\tfrom := sourceIndex + x\n\t\tto := destinationIndex + x\n\n\t\tdestination[to] = source[from]\n\t}\n}\n"
        },
        {
          "name": "value_buffer_test.go",
          "type": "blob",
          "size": 4.8798828125,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestBuffer(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbuffer := NewValueBuffer()\n\n\tbuffer.Enqueue(1)\n\ttestutil.AssertEqual(t, 1, buffer.Len())\n\ttestutil.AssertEqual(t, 1, buffer.Peek())\n\ttestutil.AssertEqual(t, 1, buffer.PeekBack())\n\n\tbuffer.Enqueue(2)\n\ttestutil.AssertEqual(t, 2, buffer.Len())\n\ttestutil.AssertEqual(t, 1, buffer.Peek())\n\ttestutil.AssertEqual(t, 2, buffer.PeekBack())\n\n\tbuffer.Enqueue(3)\n\ttestutil.AssertEqual(t, 3, buffer.Len())\n\ttestutil.AssertEqual(t, 1, buffer.Peek())\n\ttestutil.AssertEqual(t, 3, buffer.PeekBack())\n\n\tbuffer.Enqueue(4)\n\ttestutil.AssertEqual(t, 4, buffer.Len())\n\ttestutil.AssertEqual(t, 1, buffer.Peek())\n\ttestutil.AssertEqual(t, 4, buffer.PeekBack())\n\n\tbuffer.Enqueue(5)\n\ttestutil.AssertEqual(t, 5, buffer.Len())\n\ttestutil.AssertEqual(t, 1, buffer.Peek())\n\ttestutil.AssertEqual(t, 5, buffer.PeekBack())\n\n\tbuffer.Enqueue(6)\n\ttestutil.AssertEqual(t, 6, buffer.Len())\n\ttestutil.AssertEqual(t, 1, buffer.Peek())\n\ttestutil.AssertEqual(t, 6, buffer.PeekBack())\n\n\tbuffer.Enqueue(7)\n\ttestutil.AssertEqual(t, 7, buffer.Len())\n\ttestutil.AssertEqual(t, 1, buffer.Peek())\n\ttestutil.AssertEqual(t, 7, buffer.PeekBack())\n\n\tbuffer.Enqueue(8)\n\ttestutil.AssertEqual(t, 8, buffer.Len())\n\ttestutil.AssertEqual(t, 1, buffer.Peek())\n\ttestutil.AssertEqual(t, 8, buffer.PeekBack())\n\n\tvalue := buffer.Dequeue()\n\ttestutil.AssertEqual(t, 1, value)\n\ttestutil.AssertEqual(t, 7, buffer.Len())\n\ttestutil.AssertEqual(t, 2, buffer.Peek())\n\ttestutil.AssertEqual(t, 8, buffer.PeekBack())\n\n\tvalue = buffer.Dequeue()\n\ttestutil.AssertEqual(t, 2, value)\n\ttestutil.AssertEqual(t, 6, buffer.Len())\n\ttestutil.AssertEqual(t, 3, buffer.Peek())\n\ttestutil.AssertEqual(t, 8, buffer.PeekBack())\n\n\tvalue = buffer.Dequeue()\n\ttestutil.AssertEqual(t, 3, value)\n\ttestutil.AssertEqual(t, 5, buffer.Len())\n\ttestutil.AssertEqual(t, 4, buffer.Peek())\n\ttestutil.AssertEqual(t, 8, buffer.PeekBack())\n\n\tvalue = buffer.Dequeue()\n\ttestutil.AssertEqual(t, 4, value)\n\ttestutil.AssertEqual(t, 4, buffer.Len())\n\ttestutil.AssertEqual(t, 5, buffer.Peek())\n\ttestutil.AssertEqual(t, 8, buffer.PeekBack())\n\n\tvalue = buffer.Dequeue()\n\ttestutil.AssertEqual(t, 5, value)\n\ttestutil.AssertEqual(t, 3, buffer.Len())\n\ttestutil.AssertEqual(t, 6, buffer.Peek())\n\ttestutil.AssertEqual(t, 8, buffer.PeekBack())\n\n\tvalue = buffer.Dequeue()\n\ttestutil.AssertEqual(t, 6, value)\n\ttestutil.AssertEqual(t, 2, buffer.Len())\n\ttestutil.AssertEqual(t, 7, buffer.Peek())\n\ttestutil.AssertEqual(t, 8, buffer.PeekBack())\n\n\tvalue = buffer.Dequeue()\n\ttestutil.AssertEqual(t, 7, value)\n\ttestutil.AssertEqual(t, 1, buffer.Len())\n\ttestutil.AssertEqual(t, 8, buffer.Peek())\n\ttestutil.AssertEqual(t, 8, buffer.PeekBack())\n\n\tvalue = buffer.Dequeue()\n\ttestutil.AssertEqual(t, 8, value)\n\ttestutil.AssertEqual(t, 0, buffer.Len())\n\ttestutil.AssertZero(t, buffer.Peek())\n\ttestutil.AssertZero(t, buffer.PeekBack())\n}\n\nfunc TestBufferClear(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbuffer := NewValueBuffer()\n\tbuffer.Enqueue(1)\n\tbuffer.Enqueue(1)\n\tbuffer.Enqueue(1)\n\tbuffer.Enqueue(1)\n\tbuffer.Enqueue(1)\n\tbuffer.Enqueue(1)\n\tbuffer.Enqueue(1)\n\tbuffer.Enqueue(1)\n\n\ttestutil.AssertEqual(t, 8, buffer.Len())\n\n\tbuffer.Clear()\n\ttestutil.AssertEqual(t, 0, buffer.Len())\n\ttestutil.AssertZero(t, buffer.Peek())\n\ttestutil.AssertZero(t, buffer.PeekBack())\n}\n\nfunc TestBufferArray(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbuffer := NewValueBuffer()\n\tbuffer.Enqueue(1)\n\tbuffer.Enqueue(2)\n\tbuffer.Enqueue(3)\n\tbuffer.Enqueue(4)\n\tbuffer.Enqueue(5)\n\n\tcontents := buffer.Array()\n\ttestutil.AssertLen(t, contents, 5)\n\ttestutil.AssertEqual(t, 1, contents[0])\n\ttestutil.AssertEqual(t, 2, contents[1])\n\ttestutil.AssertEqual(t, 3, contents[2])\n\ttestutil.AssertEqual(t, 4, contents[3])\n\ttestutil.AssertEqual(t, 5, contents[4])\n}\n\nfunc TestBufferEach(t *testing.T) {\n\t// replaced new assertions helper\n\n\tbuffer := NewValueBuffer()\n\n\tfor x := 1; x < 17; x++ {\n\t\tbuffer.Enqueue(float64(x))\n\t}\n\n\tcalled := 0\n\tbuffer.Each(func(_ int, v float64) {\n\t\tif v == float64(called+1) {\n\t\t\tcalled++\n\t\t}\n\t})\n\n\ttestutil.AssertEqual(t, 16, called)\n}\n\nfunc TestNewBuffer(t *testing.T) {\n\t// replaced new assertions helper\n\n\tempty := NewValueBuffer()\n\ttestutil.AssertNotNil(t, empty)\n\ttestutil.AssertZero(t, empty.Len())\n\ttestutil.AssertEqual(t, bufferDefaultCapacity, empty.Capacity())\n\ttestutil.AssertZero(t, empty.Peek())\n\ttestutil.AssertZero(t, empty.PeekBack())\n}\n\nfunc TestNewBufferWithValues(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := NewValueBuffer(1, 2, 3, 4, 5)\n\ttestutil.AssertNotNil(t, values)\n\ttestutil.AssertEqual(t, 5, values.Len())\n\ttestutil.AssertEqual(t, 1, values.Peek())\n\ttestutil.AssertEqual(t, 5, values.PeekBack())\n}\n\nfunc TestBufferGrowth(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvalues := NewValueBuffer(1, 2, 3, 4, 5)\n\tfor i := 0; i < 1<<10; i++ {\n\t\tvalues.Enqueue(float64(i))\n\t}\n\n\ttestutil.AssertEqual(t, 1<<10-1, values.PeekBack())\n}\n"
        },
        {
          "name": "value_formatter.go",
          "type": "blob",
          "size": 3.2001953125,
          "content": "package chart\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// ValueFormatter is a function that takes a value and produces a string.\ntype ValueFormatter func(v interface{}) string\n\n// TimeValueFormatter is a ValueFormatter for timestamps.\nfunc TimeValueFormatter(v interface{}) string {\n\treturn formatTime(v, DefaultDateFormat)\n}\n\n// TimeHourValueFormatter is a ValueFormatter for timestamps.\nfunc TimeHourValueFormatter(v interface{}) string {\n\treturn formatTime(v, DefaultDateHourFormat)\n}\n\n// TimeMinuteValueFormatter is a ValueFormatter for timestamps.\nfunc TimeMinuteValueFormatter(v interface{}) string {\n\treturn formatTime(v, DefaultDateMinuteFormat)\n}\n\n// TimeDateValueFormatter is a ValueFormatter for timestamps.\nfunc TimeDateValueFormatter(v interface{}) string {\n\treturn formatTime(v, \"2006-01-02\")\n}\n\n// TimeValueFormatterWithFormat returns a time formatter with a given format.\nfunc TimeValueFormatterWithFormat(format string) ValueFormatter {\n\treturn func(v interface{}) string {\n\t\treturn formatTime(v, format)\n\t}\n}\n\n// TimeValueFormatterWithFormat is a ValueFormatter for timestamps with a given format.\nfunc formatTime(v interface{}, dateFormat string) string {\n\tif typed, isTyped := v.(time.Time); isTyped {\n\t\treturn typed.Format(dateFormat)\n\t}\n\tif typed, isTyped := v.(int64); isTyped {\n\t\treturn time.Unix(0, typed).Format(dateFormat)\n\t}\n\tif typed, isTyped := v.(float64); isTyped {\n\t\treturn time.Unix(0, int64(typed)).Format(dateFormat)\n\t}\n\treturn \"\"\n}\n\n// IntValueFormatter is a ValueFormatter for float64.\nfunc IntValueFormatter(v interface{}) string {\n\tswitch v.(type) {\n\tcase int:\n\t\treturn strconv.Itoa(v.(int))\n\tcase int64:\n\t\treturn strconv.FormatInt(v.(int64), 10)\n\tcase float32:\n\t\treturn strconv.FormatInt(int64(v.(float32)), 10)\n\tcase float64:\n\t\treturn strconv.FormatInt(int64(v.(float64)), 10)\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\n// FloatValueFormatter is a ValueFormatter for float64.\nfunc FloatValueFormatter(v interface{}) string {\n\treturn FloatValueFormatterWithFormat(v, DefaultFloatFormat)\n}\n\n// PercentValueFormatter is a formatter for percent values.\n// NOTE: it normalizes the values, i.e. multiplies by 100.0.\nfunc PercentValueFormatter(v interface{}) string {\n\tif typed, isTyped := v.(float64); isTyped {\n\t\treturn FloatValueFormatterWithFormat(typed*100.0, DefaultPercentValueFormat)\n\t}\n\treturn \"\"\n}\n\n// FloatValueFormatterWithFormat is a ValueFormatter for float64 with a given format.\nfunc FloatValueFormatterWithFormat(v interface{}, floatFormat string) string {\n\tif typed, isTyped := v.(int); isTyped {\n\t\treturn fmt.Sprintf(floatFormat, float64(typed))\n\t}\n\tif typed, isTyped := v.(int64); isTyped {\n\t\treturn fmt.Sprintf(floatFormat, float64(typed))\n\t}\n\tif typed, isTyped := v.(float32); isTyped {\n\t\treturn fmt.Sprintf(floatFormat, typed)\n\t}\n\tif typed, isTyped := v.(float64); isTyped {\n\t\treturn fmt.Sprintf(floatFormat, typed)\n\t}\n\treturn \"\"\n}\n\n// KValueFormatter is a formatter for K values.\nfunc KValueFormatter(k float64, vf ValueFormatter) ValueFormatter {\n\treturn func(v interface{}) string {\n\t\treturn fmt.Sprintf(\"%0.0f %s\", k, vf(v))\n\t}\n}\n\n// FloatValueFormatter is a ValueFormatter for float64, exponential notation, e.g. 1.52e+08.\nfunc ExponentialValueFormatter(v interface{}) string {\n\treturn FloatValueFormatterWithFormat(v, \"%.2e\")\n}\n"
        },
        {
          "name": "value_formatter_provider.go",
          "type": "blob",
          "size": 0.1630859375,
          "content": "package chart\n\n// ValueFormatterProvider is a series that has custom formatters.\ntype ValueFormatterProvider interface {\n\tGetValueFormatters() (x, y ValueFormatter)\n}\n"
        },
        {
          "name": "value_formatter_test.go",
          "type": "blob",
          "size": 1.7802734375,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestTimeValueFormatterWithFormat(t *testing.T) {\n\t// replaced new assertions helper\n\n\td := time.Now()\n\tdi := TimeToFloat64(d)\n\tdf := float64(di)\n\n\ts := formatTime(d, DefaultDateFormat)\n\tsi := formatTime(di, DefaultDateFormat)\n\tsf := formatTime(df, DefaultDateFormat)\n\ttestutil.AssertEqual(t, s, si)\n\ttestutil.AssertEqual(t, s, sf)\n\n\tsd := TimeValueFormatter(d)\n\tsdi := TimeValueFormatter(di)\n\tsdf := TimeValueFormatter(df)\n\ttestutil.AssertEqual(t, s, sd)\n\ttestutil.AssertEqual(t, s, sdi)\n\ttestutil.AssertEqual(t, s, sdf)\n}\n\nfunc TestFloatValueFormatter(t *testing.T) {\n\t// replaced new assertions helper\n\ttestutil.AssertEqual(t, \"1234.00\", FloatValueFormatter(1234.00))\n}\n\nfunc TestFloatValueFormatterWithFloat32Input(t *testing.T) {\n\t// replaced new assertions helper\n\ttestutil.AssertEqual(t, \"1234.00\", FloatValueFormatter(float32(1234.00)))\n}\n\nfunc TestFloatValueFormatterWithIntegerInput(t *testing.T) {\n\t// replaced new assertions helper\n\ttestutil.AssertEqual(t, \"1234.00\", FloatValueFormatter(1234))\n}\n\nfunc TestFloatValueFormatterWithInt64Input(t *testing.T) {\n\t// replaced new assertions helper\n\ttestutil.AssertEqual(t, \"1234.00\", FloatValueFormatter(int64(1234)))\n}\n\nfunc TestFloatValueFormatterWithFormat(t *testing.T) {\n\t// replaced new assertions helper\n\n\tv := 123.456\n\tsv := FloatValueFormatterWithFormat(v, \"%.3f\")\n\ttestutil.AssertEqual(t, \"123.456\", sv)\n\ttestutil.AssertEqual(t, \"123.000\", FloatValueFormatterWithFormat(123, \"%.3f\"))\n}\n\nfunc TestExponentialValueFormatter(t *testing.T) {\n\ttestutil.AssertEqual(t, \"1.23e+02\", ExponentialValueFormatter(123.456))\n\ttestutil.AssertEqual(t, \"1.24e+07\", ExponentialValueFormatter(12421243.424))\n\ttestutil.AssertEqual(t, \"4.50e-01\", ExponentialValueFormatter(0.45))\n}\n"
        },
        {
          "name": "value_provider.go",
          "type": "blob",
          "size": 1.6943359375,
          "content": "package chart\n\nimport \"github.com/wcharczuk/go-chart/v2/drawing\"\n\n// ValuesProvider is a type that produces values.\ntype ValuesProvider interface {\n\tLen() int\n\tGetValues(index int) (float64, float64)\n}\n\n// BoundedValuesProvider allows series to return a range.\ntype BoundedValuesProvider interface {\n\tLen() int\n\tGetBoundedValues(index int) (x, y1, y2 float64)\n}\n\n// FirstValuesProvider is a special type of value provider that can return it's (potentially computed) first value.\ntype FirstValuesProvider interface {\n\tGetFirstValues() (x, y float64)\n}\n\n// LastValuesProvider is a special type of value provider that can return it's (potentially computed) last value.\ntype LastValuesProvider interface {\n\tGetLastValues() (x, y float64)\n}\n\n// BoundedLastValuesProvider is a special type of value provider that can return it's (potentially computed) bounded last value.\ntype BoundedLastValuesProvider interface {\n\tGetBoundedLastValues() (x, y1, y2 float64)\n}\n\n// FullValuesProvider is an interface that combines `ValuesProvider` and `LastValuesProvider`\ntype FullValuesProvider interface {\n\tValuesProvider\n\tLastValuesProvider\n}\n\n// FullBoundedValuesProvider is an interface that combines `BoundedValuesProvider` and `BoundedLastValuesProvider`\ntype FullBoundedValuesProvider interface {\n\tBoundedValuesProvider\n\tBoundedLastValuesProvider\n}\n\n// SizeProvider is a provider for integer size.\ntype SizeProvider func(xrange, yrange Range, index int, x, y float64) float64\n\n// ColorProvider is a general provider for color ranges based on values.\ntype ColorProvider func(v, vmin, vmax float64) drawing.Color\n\n// DotColorProvider is a provider for dot color.\ntype DotColorProvider func(xrange, yrange Range, index int, x, y float64) drawing.Color\n"
        },
        {
          "name": "value_test.go",
          "type": "blob",
          "size": 1.6298828125,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestValuesValues(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvs := []Value{\n\t\t{Value: 10, Label: \"Blue\"},\n\t\t{Value: 9, Label: \"Green\"},\n\t\t{Value: 8, Label: \"Gray\"},\n\t\t{Value: 7, Label: \"Orange\"},\n\t\t{Value: 6, Label: \"HEANG\"},\n\t\t{Value: 5, Label: \"??\"},\n\t\t{Value: 2, Label: \"!!\"},\n\t}\n\n\tvalues := Values(vs).Values()\n\ttestutil.AssertLen(t, values, 7)\n\ttestutil.AssertEqual(t, 10, values[0])\n\ttestutil.AssertEqual(t, 9, values[1])\n\ttestutil.AssertEqual(t, 8, values[2])\n\ttestutil.AssertEqual(t, 7, values[3])\n\ttestutil.AssertEqual(t, 6, values[4])\n\ttestutil.AssertEqual(t, 5, values[5])\n\ttestutil.AssertEqual(t, 2, values[6])\n}\n\nfunc TestValuesValuesNormalized(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvs := []Value{\n\t\t{Value: 10, Label: \"Blue\"},\n\t\t{Value: 9, Label: \"Green\"},\n\t\t{Value: 8, Label: \"Gray\"},\n\t\t{Value: 7, Label: \"Orange\"},\n\t\t{Value: 6, Label: \"HEANG\"},\n\t\t{Value: 5, Label: \"??\"},\n\t\t{Value: 2, Label: \"!!\"},\n\t}\n\n\tvalues := Values(vs).ValuesNormalized()\n\ttestutil.AssertLen(t, values, 7)\n\ttestutil.AssertEqual(t, 0.2127, values[0])\n\ttestutil.AssertEqual(t, 0.0425, values[6])\n}\n\nfunc TestValuesNormalize(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvs := []Value{\n\t\t{Value: 10, Label: \"Blue\"},\n\t\t{Value: 9, Label: \"Green\"},\n\t\t{Value: 8, Label: \"Gray\"},\n\t\t{Value: 7, Label: \"Orange\"},\n\t\t{Value: 6, Label: \"HEANG\"},\n\t\t{Value: 5, Label: \"??\"},\n\t\t{Value: 2, Label: \"!!\"},\n\t}\n\n\tvalues := Values(vs).Normalize()\n\ttestutil.AssertLen(t, values, 7)\n\ttestutil.AssertEqual(t, 0.2127, values[0].Value)\n\ttestutil.AssertEqual(t, 0.0425, values[6].Value)\n}\n"
        },
        {
          "name": "vector_renderer.go",
          "type": "blob",
          "size": 9.220703125,
          "content": "package chart\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"strings\"\n\n\t\"golang.org/x/image/font\"\n\n\t\"github.com/golang/freetype/truetype\"\n\t\"github.com/wcharczuk/go-chart/v2/drawing\"\n)\n\n// SVG returns a new png/raster renderer.\nfunc SVG(width, height int) (Renderer, error) {\n\tbuffer := bytes.NewBuffer([]byte{})\n\tcanvas := newCanvas(buffer)\n\tcanvas.Start(width, height)\n\treturn &vectorRenderer{\n\t\tb:   buffer,\n\t\tc:   canvas,\n\t\ts:   &Style{},\n\t\tp:   []string{},\n\t\tdpi: DefaultDPI,\n\t}, nil\n}\n\n// SVGWithCSS returns a new png/raster renderer with attached custom CSS\n// The optional nonce argument sets a CSP nonce.\nfunc SVGWithCSS(css string, nonce string) func(width, height int) (Renderer, error) {\n\treturn func(width, height int) (Renderer, error) {\n\t\tbuffer := bytes.NewBuffer([]byte{})\n\t\tcanvas := newCanvas(buffer)\n\t\tcanvas.css = css\n\t\tcanvas.nonce = nonce\n\t\tcanvas.Start(width, height)\n\t\treturn &vectorRenderer{\n\t\t\tb:   buffer,\n\t\t\tc:   canvas,\n\t\t\ts:   &Style{},\n\t\t\tp:   []string{},\n\t\t\tdpi: DefaultDPI,\n\t\t}, nil\n\t}\n}\n\n// vectorRenderer renders chart commands to a bitmap.\ntype vectorRenderer struct {\n\tdpi float64\n\tb   *bytes.Buffer\n\tc   *canvas\n\ts   *Style\n\tp   []string\n\tfc  *font.Drawer\n}\n\nfunc (vr *vectorRenderer) ResetStyle() {\n\tvr.s = &Style{Font: vr.s.Font}\n\tvr.fc = nil\n}\n\n// GetDPI returns the dpi.\nfunc (vr *vectorRenderer) GetDPI() float64 {\n\treturn vr.dpi\n}\n\n// SetDPI implements the interface method.\nfunc (vr *vectorRenderer) SetDPI(dpi float64) {\n\tvr.dpi = dpi\n\tvr.c.dpi = dpi\n}\n\n// SetClassName implements the interface method.\nfunc (vr *vectorRenderer) SetClassName(classname string) {\n\tvr.s.ClassName = classname\n}\n\n// SetStrokeColor implements the interface method.\nfunc (vr *vectorRenderer) SetStrokeColor(c drawing.Color) {\n\tvr.s.StrokeColor = c\n}\n\n// SetFillColor implements the interface method.\nfunc (vr *vectorRenderer) SetFillColor(c drawing.Color) {\n\tvr.s.FillColor = c\n}\n\n// SetLineWidth implements the interface method.\nfunc (vr *vectorRenderer) SetStrokeWidth(width float64) {\n\tvr.s.StrokeWidth = width\n}\n\n// StrokeDashArray sets the stroke dash array.\nfunc (vr *vectorRenderer) SetStrokeDashArray(dashArray []float64) {\n\tvr.s.StrokeDashArray = dashArray\n}\n\n// MoveTo implements the interface method.\nfunc (vr *vectorRenderer) MoveTo(x, y int) {\n\tvr.p = append(vr.p, fmt.Sprintf(\"M %d %d\", x, y))\n}\n\n// LineTo implements the interface method.\nfunc (vr *vectorRenderer) LineTo(x, y int) {\n\tvr.p = append(vr.p, fmt.Sprintf(\"L %d %d\", x, y))\n}\n\n// QuadCurveTo draws a quad curve.\nfunc (vr *vectorRenderer) QuadCurveTo(cx, cy, x, y int) {\n\tvr.p = append(vr.p, fmt.Sprintf(\"Q%d,%d %d,%d\", cx, cy, x, y))\n}\n\nfunc (vr *vectorRenderer) ArcTo(cx, cy int, rx, ry, startAngle, delta float64) {\n\tstartAngle = RadianAdd(startAngle, _pi2)\n\tendAngle := RadianAdd(startAngle, delta)\n\n\tstartx := cx + int(rx*math.Sin(startAngle))\n\tstarty := cy - int(ry*math.Cos(startAngle))\n\n\tif len(vr.p) > 0 {\n\t\tvr.p = append(vr.p, fmt.Sprintf(\"L %d %d\", startx, starty))\n\t} else {\n\t\tvr.p = append(vr.p, fmt.Sprintf(\"M %d %d\", startx, starty))\n\t}\n\n\tendx := cx + int(rx*math.Sin(endAngle))\n\tendy := cy - int(ry*math.Cos(endAngle))\n\n\tdd := RadiansToDegrees(delta)\n\n\tlargeArcFlag := 0\n\tif delta > _pi {\n\t\tlargeArcFlag = 1\n\t}\n\n\tvr.p = append(vr.p, fmt.Sprintf(\"A %d %d %0.2f %d 1 %d %d\", int(rx), int(ry), dd, largeArcFlag, endx, endy))\n}\n\n// Close closes a shape.\nfunc (vr *vectorRenderer) Close() {\n\tvr.p = append(vr.p, \"Z\")\n}\n\n// Stroke draws the path with no fill.\nfunc (vr *vectorRenderer) Stroke() {\n\tvr.drawPath(vr.s.GetStrokeOptions())\n}\n\n// Fill draws the path with no stroke.\nfunc (vr *vectorRenderer) Fill() {\n\tvr.drawPath(vr.s.GetFillOptions())\n}\n\n// FillStroke draws the path with both fill and stroke.\nfunc (vr *vectorRenderer) FillStroke() {\n\tvr.drawPath(vr.s.GetFillAndStrokeOptions())\n}\n\n// drawPath draws a path.\nfunc (vr *vectorRenderer) drawPath(s Style) {\n\tvr.c.Path(strings.Join(vr.p, \"\\n\"), vr.s.GetFillAndStrokeOptions())\n\tvr.p = []string{} // clear the path\n}\n\n// Circle implements the interface method.\nfunc (vr *vectorRenderer) Circle(radius float64, x, y int) {\n\tvr.c.Circle(x, y, int(radius), vr.s.GetFillAndStrokeOptions())\n}\n\n// SetFont implements the interface method.\nfunc (vr *vectorRenderer) SetFont(f *truetype.Font) {\n\tvr.s.Font = f\n}\n\n// SetFontColor implements the interface method.\nfunc (vr *vectorRenderer) SetFontColor(c drawing.Color) {\n\tvr.s.FontColor = c\n}\n\n// SetFontSize implements the interface method.\nfunc (vr *vectorRenderer) SetFontSize(size float64) {\n\tvr.s.FontSize = size\n}\n\n// Text draws a text blob.\nfunc (vr *vectorRenderer) Text(body string, x, y int) {\n\tvr.c.Text(x, y, body, vr.s.GetTextOptions())\n}\n\n// MeasureText uses the truetype font drawer to measure the width of text.\nfunc (vr *vectorRenderer) MeasureText(body string) (box Box) {\n\tif vr.s.GetFont() != nil {\n\t\tvr.fc = &font.Drawer{\n\t\t\tFace: truetype.NewFace(vr.s.GetFont(), &truetype.Options{\n\t\t\t\tDPI:  vr.dpi,\n\t\t\t\tSize: vr.s.FontSize,\n\t\t\t}),\n\t\t}\n\t\tw := vr.fc.MeasureString(body).Ceil()\n\n\t\tbox.Right = w\n\t\tbox.Bottom = int(drawing.PointsToPixels(vr.dpi, vr.s.FontSize))\n\t\tif vr.c.textTheta == nil {\n\t\t\treturn\n\t\t}\n\t\tbox = box.Corners().Rotate(RadiansToDegrees(*vr.c.textTheta)).Box()\n\t}\n\treturn\n}\n\n// SetTextRotation sets the text rotation.\nfunc (vr *vectorRenderer) SetTextRotation(radians float64) {\n\tvr.c.textTheta = &radians\n}\n\n// ClearTextRotation clears the text rotation.\nfunc (vr *vectorRenderer) ClearTextRotation() {\n\tvr.c.textTheta = nil\n}\n\n// Save saves the renderer's contents to a writer.\nfunc (vr *vectorRenderer) Save(w io.Writer) error {\n\tvr.c.End()\n\t_, err := w.Write(vr.b.Bytes())\n\treturn err\n}\n\nfunc newCanvas(w io.Writer) *canvas {\n\treturn &canvas{\n\t\tw:   w,\n\t\tdpi: DefaultDPI,\n\t}\n}\n\ntype canvas struct {\n\tw         io.Writer\n\tdpi       float64\n\ttextTheta *float64\n\twidth     int\n\theight    int\n\tcss       string\n\tnonce     string\n}\n\nfunc (c *canvas) Start(width, height int) {\n\tc.width = width\n\tc.height = height\n\tc.w.Write([]byte(fmt.Sprintf(`<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 %d %d\">`, c.width, c.height)))\n\tif c.css != \"\" {\n\t\tc.w.Write([]byte(`<style type=\"text/css\"`))\n\t\tif c.nonce != \"\" {\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\n\t\t\tc.w.Write([]byte(fmt.Sprintf(` nonce=\"%s\"`, c.nonce)))\n\t\t}\n\t\t// To avoid compatibility issues between XML and CSS (f.e. with child selectors) we should encapsulate the CSS with CDATA.\n\t\tc.w.Write([]byte(fmt.Sprintf(`><![CDATA[%s]]></style>`, c.css)))\n\t}\n}\n\nfunc (c *canvas) Path(d string, style Style) {\n\tvar strokeDashArrayProperty string\n\tif len(style.StrokeDashArray) > 0 {\n\t\tstrokeDashArrayProperty = c.getStrokeDashArray(style)\n\t}\n\tc.w.Write([]byte(fmt.Sprintf(`<path %s d=\"%s\" %s/>`, strokeDashArrayProperty, d, c.styleAsSVG(style))))\n}\n\nfunc (c *canvas) Text(x, y int, body string, style Style) {\n\tif c.textTheta == nil {\n\t\tc.w.Write([]byte(fmt.Sprintf(`<text x=\"%d\" y=\"%d\" %s>%s</text>`, x, y, c.styleAsSVG(style), body)))\n\t} else {\n\t\ttransform := fmt.Sprintf(` transform=\"rotate(%0.2f,%d,%d)\"`, RadiansToDegrees(*c.textTheta), x, y)\n\t\tc.w.Write([]byte(fmt.Sprintf(`<text x=\"%d\" y=\"%d\" %s%s>%s</text>`, x, y, c.styleAsSVG(style), transform, body)))\n\t}\n}\n\nfunc (c *canvas) Circle(x, y, r int, style Style) {\n\tc.w.Write([]byte(fmt.Sprintf(`<circle cx=\"%d\" cy=\"%d\" r=\"%d\" %s/>`, x, y, r, c.styleAsSVG(style))))\n}\n\nfunc (c *canvas) End() {\n\tc.w.Write([]byte(\"</svg>\"))\n}\n\n// getStrokeDashArray returns the stroke-dasharray property of a style.\nfunc (c *canvas) getStrokeDashArray(s Style) string {\n\tif len(s.StrokeDashArray) > 0 {\n\t\tvar values []string\n\t\tfor _, v := range s.StrokeDashArray {\n\t\t\tvalues = append(values, fmt.Sprintf(\"%0.1f\", v))\n\t\t}\n\t\treturn \"stroke-dasharray=\\\"\" + strings.Join(values, \", \") + \"\\\"\"\n\t}\n\treturn \"\"\n}\n\n// GetFontFace returns the font face for the style.\nfunc (c *canvas) getFontFace(s Style) string {\n\tfamily := \"sans-serif\"\n\tif s.GetFont() != nil {\n\t\tname := s.GetFont().Name(truetype.NameIDFontFamily)\n\t\tif len(name) != 0 {\n\t\t\tfamily = fmt.Sprintf(`'%s',%s`, name, family)\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"font-family:%s\", family)\n}\n\n// styleAsSVG returns the style as a svg style or class string.\nfunc (c *canvas) styleAsSVG(s Style) string {\n\tsw := s.StrokeWidth\n\tsc := s.StrokeColor\n\tfc := s.FillColor\n\tfs := s.FontSize\n\tfnc := s.FontColor\n\n\tif s.ClassName != \"\" {\n\t\tvar classes []string\n\t\tclasses = append(classes, s.ClassName)\n\t\tif !sc.IsZero() {\n\t\t\tclasses = append(classes, \"stroke\")\n\t\t}\n\t\tif !fc.IsZero() {\n\t\t\tclasses = append(classes, \"fill\")\n\t\t}\n\t\tif fs != 0 || s.Font != nil {\n\t\t\tclasses = append(classes, \"text\")\n\t\t}\n\n\t\treturn fmt.Sprintf(\"class=\\\"%s\\\"\", strings.Join(classes, \" \"))\n\t}\n\n\tvar pieces []string\n\n\tif sw != 0 {\n\t\tpieces = append(pieces, \"stroke-width:\"+fmt.Sprintf(\"%d\", int(sw)))\n\t} else {\n\t\tpieces = append(pieces, \"stroke-width:0\")\n\t}\n\n\tif !sc.IsZero() {\n\t\tpieces = append(pieces, \"stroke:\"+sc.String())\n\t} else {\n\t\tpieces = append(pieces, \"stroke:none\")\n\t}\n\n\tif !fnc.IsZero() {\n\t\tpieces = append(pieces, \"fill:\"+fnc.String())\n\t} else if !fc.IsZero() {\n\t\tpieces = append(pieces, \"fill:\"+fc.String())\n\t} else {\n\t\tpieces = append(pieces, \"fill:none\")\n\t}\n\n\tif fs != 0 {\n\t\tpieces = append(pieces, \"font-size:\"+fmt.Sprintf(\"%.1fpx\", drawing.PointsToPixels(c.dpi, fs)))\n\t}\n\n\tif s.Font != nil {\n\t\tpieces = append(pieces, c.getFontFace(s))\n\t}\n\treturn fmt.Sprintf(\"style=\\\"%s\\\"\", strings.Join(pieces, \";\"))\n}\n"
        },
        {
          "name": "vector_renderer_test.go",
          "type": "blob",
          "size": 2.6796875,
          "content": "package chart\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/drawing\"\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestVectorRendererPath(t *testing.T) {\n\t// replaced new assertions helper\n\n\tvr, err := SVG(100, 100)\n\ttestutil.AssertNil(t, err)\n\n\ttyped, isTyped := vr.(*vectorRenderer)\n\ttestutil.AssertTrue(t, isTyped)\n\n\ttyped.MoveTo(0, 0)\n\ttyped.LineTo(100, 100)\n\ttyped.LineTo(0, 100)\n\ttyped.Close()\n\ttyped.FillStroke()\n\n\tbuffer := bytes.NewBuffer([]byte{})\n\terr = typed.Save(buffer)\n\ttestutil.AssertNil(t, err)\n\n\traw := string(buffer.Bytes())\n\n\ttestutil.AssertTrue(t, strings.HasPrefix(raw, \"<svg\"))\n\ttestutil.AssertTrue(t, strings.HasSuffix(raw, \"</svg>\"))\n}\n\nfunc TestVectorRendererMeasureText(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tvr, err := SVG(100, 100)\n\ttestutil.AssertNil(t, err)\n\n\tvr.SetDPI(DefaultDPI)\n\tvr.SetFont(f)\n\tvr.SetFontSize(12.0)\n\n\ttb := vr.MeasureText(\"Ljp\")\n\ttestutil.AssertEqual(t, 21, tb.Width())\n\ttestutil.AssertEqual(t, 15, tb.Height())\n}\n\nfunc TestCanvasStyleSVG(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tset := Style{\n\t\tStrokeColor: drawing.ColorWhite,\n\t\tStrokeWidth: 5.0,\n\t\tFillColor:   drawing.ColorWhite,\n\t\tFontColor:   drawing.ColorWhite,\n\t\tFont:        f,\n\t\tPadding:     DefaultBackgroundPadding,\n\t}\n\n\tcanvas := &canvas{dpi: DefaultDPI}\n\n\tsvgString := canvas.styleAsSVG(set)\n\ttestutil.AssertNotEmpty(t, svgString)\n\ttestutil.AssertTrue(t, strings.HasPrefix(svgString, \"style=\\\"\"))\n\ttestutil.AssertTrue(t, strings.Contains(svgString, \"stroke:rgba(255,255,255,1.0)\"))\n\ttestutil.AssertTrue(t, strings.Contains(svgString, \"stroke-width:5\"))\n\ttestutil.AssertTrue(t, strings.Contains(svgString, \"fill:rgba(255,255,255,1.0)\"))\n\ttestutil.AssertTrue(t, strings.HasSuffix(svgString, \"\\\"\"))\n}\n\nfunc TestCanvasClassSVG(t *testing.T) {\n\tset := Style{\n\t\tClassName: \"test-class\",\n\t}\n\n\tcanvas := &canvas{dpi: DefaultDPI}\n\n\ttestutil.AssertEqual(t, \"class=\\\"test-class\\\"\", canvas.styleAsSVG(set))\n}\n\nfunc TestCanvasCustomInlineStylesheet(t *testing.T) {\n\tb := strings.Builder{}\n\n\tcanvas := &canvas{\n\t\tw:   &b,\n\t\tcss: \".background { fill: red }\",\n\t}\n\n\tcanvas.Start(200, 200)\n\n\ttestutil.AssertContains(t, b.String(), fmt.Sprintf(`<style type=\"text/css\"><![CDATA[%s]]></style>`, canvas.css))\n}\n\nfunc TestCanvasCustomInlineStylesheetWithNonce(t *testing.T) {\n\tb := strings.Builder{}\n\n\tcanvas := &canvas{\n\t\tw:     &b,\n\t\tcss:   \".background { fill: red }\",\n\t\tnonce: \"RAND0MSTRING\",\n\t}\n\n\tcanvas.Start(200, 200)\n\n\ttestutil.AssertContains(t, b.String(), fmt.Sprintf(`<style type=\"text/css\" nonce=\"%s\"><![CDATA[%s]]></style>`, canvas.nonce, canvas.css))\n}\n"
        },
        {
          "name": "viridis.go",
          "type": "blob",
          "size": 10.041015625,
          "content": "package chart\n\nimport \"github.com/wcharczuk/go-chart/v2/drawing\"\n\nvar viridisColors = [256]drawing.Color{\n\t{R: 0x44, G: 0x1, B: 0x54, A: 0xff},\n\t{R: 0x44, G: 0x2, B: 0x55, A: 0xff},\n\t{R: 0x45, G: 0x3, B: 0x57, A: 0xff},\n\t{R: 0x45, G: 0x5, B: 0x58, A: 0xff},\n\t{R: 0x45, G: 0x6, B: 0x5a, A: 0xff},\n\t{R: 0x46, G: 0x8, B: 0x5b, A: 0xff},\n\t{R: 0x46, G: 0x9, B: 0x5d, A: 0xff},\n\t{R: 0x46, G: 0xb, B: 0x5e, A: 0xff},\n\t{R: 0x46, G: 0xc, B: 0x60, A: 0xff},\n\t{R: 0x47, G: 0xe, B: 0x61, A: 0xff},\n\t{R: 0x47, G: 0xf, B: 0x62, A: 0xff},\n\t{R: 0x47, G: 0x11, B: 0x64, A: 0xff},\n\t{R: 0x47, G: 0x12, B: 0x65, A: 0xff},\n\t{R: 0x47, G: 0x14, B: 0x66, A: 0xff},\n\t{R: 0x48, G: 0x15, B: 0x68, A: 0xff},\n\t{R: 0x48, G: 0x16, B: 0x69, A: 0xff},\n\t{R: 0x48, G: 0x18, B: 0x6a, A: 0xff},\n\t{R: 0x48, G: 0x19, B: 0x6c, A: 0xff},\n\t{R: 0x48, G: 0x1a, B: 0x6d, A: 0xff},\n\t{R: 0x48, G: 0x1c, B: 0x6e, A: 0xff},\n\t{R: 0x48, G: 0x1d, B: 0x6f, A: 0xff},\n\t{R: 0x48, G: 0x1e, B: 0x70, A: 0xff},\n\t{R: 0x48, G: 0x20, B: 0x71, A: 0xff},\n\t{R: 0x48, G: 0x21, B: 0x73, A: 0xff},\n\t{R: 0x48, G: 0x22, B: 0x74, A: 0xff},\n\t{R: 0x48, G: 0x24, B: 0x75, A: 0xff},\n\t{R: 0x48, G: 0x25, B: 0x76, A: 0xff},\n\t{R: 0x48, G: 0x26, B: 0x77, A: 0xff},\n\t{R: 0x48, G: 0x27, B: 0x78, A: 0xff},\n\t{R: 0x47, G: 0x29, B: 0x79, A: 0xff},\n\t{R: 0x47, G: 0x2a, B: 0x79, A: 0xff},\n\t{R: 0x47, G: 0x2b, B: 0x7a, A: 0xff},\n\t{R: 0x47, G: 0x2c, B: 0x7b, A: 0xff},\n\t{R: 0x47, G: 0x2e, B: 0x7c, A: 0xff},\n\t{R: 0x46, G: 0x2f, B: 0x7d, A: 0xff},\n\t{R: 0x46, G: 0x30, B: 0x7e, A: 0xff},\n\t{R: 0x46, G: 0x31, B: 0x7e, A: 0xff},\n\t{R: 0x46, G: 0x33, B: 0x7f, A: 0xff},\n\t{R: 0x45, G: 0x34, B: 0x80, A: 0xff},\n\t{R: 0x45, G: 0x35, B: 0x81, A: 0xff},\n\t{R: 0x45, G: 0x36, B: 0x81, A: 0xff},\n\t{R: 0x44, G: 0x38, B: 0x82, A: 0xff},\n\t{R: 0x44, G: 0x39, B: 0x83, A: 0xff},\n\t{R: 0x44, G: 0x3a, B: 0x83, A: 0xff},\n\t{R: 0x43, G: 0x3b, B: 0x84, A: 0xff},\n\t{R: 0x43, G: 0x3c, B: 0x84, A: 0xff},\n\t{R: 0x43, G: 0x3e, B: 0x85, A: 0xff},\n\t{R: 0x42, G: 0x3f, B: 0x85, A: 0xff},\n\t{R: 0x42, G: 0x40, B: 0x86, A: 0xff},\n\t{R: 0x41, G: 0x41, B: 0x86, A: 0xff},\n\t{R: 0x41, G: 0x42, B: 0x87, A: 0xff},\n\t{R: 0x41, G: 0x43, B: 0x87, A: 0xff},\n\t{R: 0x40, G: 0x45, B: 0x88, A: 0xff},\n\t{R: 0x40, G: 0x46, B: 0x88, A: 0xff},\n\t{R: 0x3f, G: 0x47, B: 0x88, A: 0xff},\n\t{R: 0x3f, G: 0x48, B: 0x89, A: 0xff},\n\t{R: 0x3e, G: 0x49, B: 0x89, A: 0xff},\n\t{R: 0x3e, G: 0x4a, B: 0x89, A: 0xff},\n\t{R: 0x3d, G: 0x4b, B: 0x8a, A: 0xff},\n\t{R: 0x3d, G: 0x4d, B: 0x8a, A: 0xff},\n\t{R: 0x3c, G: 0x4e, B: 0x8a, A: 0xff},\n\t{R: 0x3c, G: 0x4f, B: 0x8a, A: 0xff},\n\t{R: 0x3b, G: 0x50, B: 0x8b, A: 0xff},\n\t{R: 0x3b, G: 0x51, B: 0x8b, A: 0xff},\n\t{R: 0x3a, G: 0x52, B: 0x8b, A: 0xff},\n\t{R: 0x3a, G: 0x53, B: 0x8b, A: 0xff},\n\t{R: 0x39, G: 0x54, B: 0x8c, A: 0xff},\n\t{R: 0x39, G: 0x55, B: 0x8c, A: 0xff},\n\t{R: 0x38, G: 0x56, B: 0x8c, A: 0xff},\n\t{R: 0x38, G: 0x57, B: 0x8c, A: 0xff},\n\t{R: 0x37, G: 0x58, B: 0x8c, A: 0xff},\n\t{R: 0x37, G: 0x59, B: 0x8c, A: 0xff},\n\t{R: 0x36, G: 0x5b, B: 0x8d, A: 0xff},\n\t{R: 0x36, G: 0x5c, B: 0x8d, A: 0xff},\n\t{R: 0x35, G: 0x5d, B: 0x8d, A: 0xff},\n\t{R: 0x35, G: 0x5e, B: 0x8d, A: 0xff},\n\t{R: 0x34, G: 0x5f, B: 0x8d, A: 0xff},\n\t{R: 0x34, G: 0x60, B: 0x8d, A: 0xff},\n\t{R: 0x33, G: 0x61, B: 0x8d, A: 0xff},\n\t{R: 0x33, G: 0x62, B: 0x8d, A: 0xff},\n\t{R: 0x33, G: 0x63, B: 0x8d, A: 0xff},\n\t{R: 0x32, G: 0x64, B: 0x8e, A: 0xff},\n\t{R: 0x32, G: 0x65, B: 0x8e, A: 0xff},\n\t{R: 0x31, G: 0x66, B: 0x8e, A: 0xff},\n\t{R: 0x31, G: 0x67, B: 0x8e, A: 0xff},\n\t{R: 0x30, G: 0x68, B: 0x8e, A: 0xff},\n\t{R: 0x30, G: 0x69, B: 0x8e, A: 0xff},\n\t{R: 0x2f, G: 0x6a, B: 0x8e, A: 0xff},\n\t{R: 0x2f, G: 0x6b, B: 0x8e, A: 0xff},\n\t{R: 0x2f, G: 0x6c, B: 0x8e, A: 0xff},\n\t{R: 0x2e, G: 0x6d, B: 0x8e, A: 0xff},\n\t{R: 0x2e, G: 0x6e, B: 0x8e, A: 0xff},\n\t{R: 0x2d, G: 0x6f, B: 0x8e, A: 0xff},\n\t{R: 0x2d, G: 0x70, B: 0x8e, A: 0xff},\n\t{R: 0x2d, G: 0x70, B: 0x8e, A: 0xff},\n\t{R: 0x2c, G: 0x71, B: 0x8e, A: 0xff},\n\t{R: 0x2c, G: 0x72, B: 0x8e, A: 0xff},\n\t{R: 0x2b, G: 0x73, B: 0x8e, A: 0xff},\n\t{R: 0x2b, G: 0x74, B: 0x8e, A: 0xff},\n\t{R: 0x2b, G: 0x75, B: 0x8e, A: 0xff},\n\t{R: 0x2a, G: 0x76, B: 0x8e, A: 0xff},\n\t{R: 0x2a, G: 0x77, B: 0x8e, A: 0xff},\n\t{R: 0x29, G: 0x78, B: 0x8e, A: 0xff},\n\t{R: 0x29, G: 0x79, B: 0x8e, A: 0xff},\n\t{R: 0x29, G: 0x7a, B: 0x8e, A: 0xff},\n\t{R: 0x28, G: 0x7b, B: 0x8e, A: 0xff},\n\t{R: 0x28, G: 0x7c, B: 0x8e, A: 0xff},\n\t{R: 0x28, G: 0x7d, B: 0x8e, A: 0xff},\n\t{R: 0x27, G: 0x7e, B: 0x8e, A: 0xff},\n\t{R: 0x27, G: 0x7f, B: 0x8e, A: 0xff},\n\t{R: 0x26, G: 0x80, B: 0x8e, A: 0xff},\n\t{R: 0x26, G: 0x81, B: 0x8e, A: 0xff},\n\t{R: 0x26, G: 0x82, B: 0x8e, A: 0xff},\n\t{R: 0x25, G: 0x83, B: 0x8e, A: 0xff},\n\t{R: 0x25, G: 0x83, B: 0x8e, A: 0xff},\n\t{R: 0x25, G: 0x84, B: 0x8e, A: 0xff},\n\t{R: 0x24, G: 0x85, B: 0x8e, A: 0xff},\n\t{R: 0x24, G: 0x86, B: 0x8e, A: 0xff},\n\t{R: 0x23, G: 0x87, B: 0x8e, A: 0xff},\n\t{R: 0x23, G: 0x88, B: 0x8e, A: 0xff},\n\t{R: 0x23, G: 0x89, B: 0x8e, A: 0xff},\n\t{R: 0x22, G: 0x8a, B: 0x8d, A: 0xff},\n\t{R: 0x22, G: 0x8b, B: 0x8d, A: 0xff},\n\t{R: 0x22, G: 0x8c, B: 0x8d, A: 0xff},\n\t{R: 0x21, G: 0x8d, B: 0x8d, A: 0xff},\n\t{R: 0x21, G: 0x8e, B: 0x8d, A: 0xff},\n\t{R: 0x21, G: 0x8f, B: 0x8d, A: 0xff},\n\t{R: 0x20, G: 0x90, B: 0x8d, A: 0xff},\n\t{R: 0x20, G: 0x91, B: 0x8c, A: 0xff},\n\t{R: 0x20, G: 0x92, B: 0x8c, A: 0xff},\n\t{R: 0x20, G: 0x93, B: 0x8c, A: 0xff},\n\t{R: 0x1f, G: 0x93, B: 0x8c, A: 0xff},\n\t{R: 0x1f, G: 0x94, B: 0x8c, A: 0xff},\n\t{R: 0x1f, G: 0x95, B: 0x8b, A: 0xff},\n\t{R: 0x1f, G: 0x96, B: 0x8b, A: 0xff},\n\t{R: 0x1f, G: 0x97, B: 0x8b, A: 0xff},\n\t{R: 0x1e, G: 0x98, B: 0x8b, A: 0xff},\n\t{R: 0x1e, G: 0x99, B: 0x8a, A: 0xff},\n\t{R: 0x1e, G: 0x9a, B: 0x8a, A: 0xff},\n\t{R: 0x1e, G: 0x9b, B: 0x8a, A: 0xff},\n\t{R: 0x1e, G: 0x9c, B: 0x89, A: 0xff},\n\t{R: 0x1e, G: 0x9d, B: 0x89, A: 0xff},\n\t{R: 0x1e, G: 0x9e, B: 0x89, A: 0xff},\n\t{R: 0x1e, G: 0x9f, B: 0x88, A: 0xff},\n\t{R: 0x1e, G: 0xa0, B: 0x88, A: 0xff},\n\t{R: 0x1f, G: 0xa1, B: 0x88, A: 0xff},\n\t{R: 0x1f, G: 0xa2, B: 0x87, A: 0xff},\n\t{R: 0x1f, G: 0xa3, B: 0x87, A: 0xff},\n\t{R: 0x1f, G: 0xa3, B: 0x86, A: 0xff},\n\t{R: 0x20, G: 0xa4, B: 0x86, A: 0xff},\n\t{R: 0x20, G: 0xa5, B: 0x86, A: 0xff},\n\t{R: 0x21, G: 0xa6, B: 0x85, A: 0xff},\n\t{R: 0x21, G: 0xa7, B: 0x85, A: 0xff},\n\t{R: 0x22, G: 0xa8, B: 0x84, A: 0xff},\n\t{R: 0x23, G: 0xa9, B: 0x83, A: 0xff},\n\t{R: 0x23, G: 0xaa, B: 0x83, A: 0xff},\n\t{R: 0x24, G: 0xab, B: 0x82, A: 0xff},\n\t{R: 0x25, G: 0xac, B: 0x82, A: 0xff},\n\t{R: 0x26, G: 0xad, B: 0x81, A: 0xff},\n\t{R: 0x27, G: 0xae, B: 0x81, A: 0xff},\n\t{R: 0x28, G: 0xaf, B: 0x80, A: 0xff},\n\t{R: 0x29, G: 0xaf, B: 0x7f, A: 0xff},\n\t{R: 0x2a, G: 0xb0, B: 0x7f, A: 0xff},\n\t{R: 0x2b, G: 0xb1, B: 0x7e, A: 0xff},\n\t{R: 0x2c, G: 0xb2, B: 0x7d, A: 0xff},\n\t{R: 0x2e, G: 0xb3, B: 0x7c, A: 0xff},\n\t{R: 0x2f, G: 0xb4, B: 0x7c, A: 0xff},\n\t{R: 0x30, G: 0xb5, B: 0x7b, A: 0xff},\n\t{R: 0x32, G: 0xb6, B: 0x7a, A: 0xff},\n\t{R: 0x33, G: 0xb7, B: 0x79, A: 0xff},\n\t{R: 0x35, G: 0xb7, B: 0x79, A: 0xff},\n\t{R: 0x36, G: 0xb8, B: 0x78, A: 0xff},\n\t{R: 0x38, G: 0xb9, B: 0x77, A: 0xff},\n\t{R: 0x39, G: 0xba, B: 0x76, A: 0xff},\n\t{R: 0x3b, G: 0xbb, B: 0x75, A: 0xff},\n\t{R: 0x3d, G: 0xbc, B: 0x74, A: 0xff},\n\t{R: 0x3e, G: 0xbd, B: 0x73, A: 0xff},\n\t{R: 0x40, G: 0xbe, B: 0x72, A: 0xff},\n\t{R: 0x42, G: 0xbe, B: 0x71, A: 0xff},\n\t{R: 0x44, G: 0xbf, B: 0x70, A: 0xff},\n\t{R: 0x46, G: 0xc0, B: 0x6f, A: 0xff},\n\t{R: 0x48, G: 0xc1, B: 0x6e, A: 0xff},\n\t{R: 0x49, G: 0xc2, B: 0x6d, A: 0xff},\n\t{R: 0x4b, G: 0xc2, B: 0x6c, A: 0xff},\n\t{R: 0x4d, G: 0xc3, B: 0x6b, A: 0xff},\n\t{R: 0x4f, G: 0xc4, B: 0x6a, A: 0xff},\n\t{R: 0x51, G: 0xc5, B: 0x69, A: 0xff},\n\t{R: 0x53, G: 0xc6, B: 0x68, A: 0xff},\n\t{R: 0x55, G: 0xc6, B: 0x66, A: 0xff},\n\t{R: 0x58, G: 0xc7, B: 0x65, A: 0xff},\n\t{R: 0x5a, G: 0xc8, B: 0x64, A: 0xff},\n\t{R: 0x5c, G: 0xc9, B: 0x63, A: 0xff},\n\t{R: 0x5e, G: 0xc9, B: 0x62, A: 0xff},\n\t{R: 0x60, G: 0xca, B: 0x60, A: 0xff},\n\t{R: 0x62, G: 0xcb, B: 0x5f, A: 0xff},\n\t{R: 0x65, G: 0xcc, B: 0x5e, A: 0xff},\n\t{R: 0x67, G: 0xcc, B: 0x5c, A: 0xff},\n\t{R: 0x69, G: 0xcd, B: 0x5b, A: 0xff},\n\t{R: 0x6c, G: 0xce, B: 0x5a, A: 0xff},\n\t{R: 0x6e, G: 0xce, B: 0x58, A: 0xff},\n\t{R: 0x70, G: 0xcf, B: 0x57, A: 0xff},\n\t{R: 0x73, G: 0xd0, B: 0x55, A: 0xff},\n\t{R: 0x75, G: 0xd0, B: 0x54, A: 0xff},\n\t{R: 0x77, G: 0xd1, B: 0x52, A: 0xff},\n\t{R: 0x7a, G: 0xd2, B: 0x51, A: 0xff},\n\t{R: 0x7c, G: 0xd2, B: 0x4f, A: 0xff},\n\t{R: 0x7f, G: 0xd3, B: 0x4e, A: 0xff},\n\t{R: 0x81, G: 0xd4, B: 0x4c, A: 0xff},\n\t{R: 0x84, G: 0xd4, B: 0x4b, A: 0xff},\n\t{R: 0x86, G: 0xd5, B: 0x49, A: 0xff},\n\t{R: 0x89, G: 0xd5, B: 0x48, A: 0xff},\n\t{R: 0x8b, G: 0xd6, B: 0x46, A: 0xff},\n\t{R: 0x8e, G: 0xd7, B: 0x44, A: 0xff},\n\t{R: 0x90, G: 0xd7, B: 0x43, A: 0xff},\n\t{R: 0x93, G: 0xd8, B: 0x41, A: 0xff},\n\t{R: 0x95, G: 0xd8, B: 0x3f, A: 0xff},\n\t{R: 0x98, G: 0xd9, B: 0x3e, A: 0xff},\n\t{R: 0x9b, G: 0xd9, B: 0x3c, A: 0xff},\n\t{R: 0x9d, G: 0xda, B: 0x3a, A: 0xff},\n\t{R: 0xa0, G: 0xda, B: 0x39, A: 0xff},\n\t{R: 0xa3, G: 0xdb, B: 0x37, A: 0xff},\n\t{R: 0xa5, G: 0xdb, B: 0x35, A: 0xff},\n\t{R: 0xa8, G: 0xdc, B: 0x33, A: 0xff},\n\t{R: 0xab, G: 0xdc, B: 0x32, A: 0xff},\n\t{R: 0xad, G: 0xdd, B: 0x30, A: 0xff},\n\t{R: 0xb0, G: 0xdd, B: 0x2e, A: 0xff},\n\t{R: 0xb3, G: 0xdd, B: 0x2d, A: 0xff},\n\t{R: 0xb5, G: 0xde, B: 0x2b, A: 0xff},\n\t{R: 0xb8, G: 0xde, B: 0x29, A: 0xff},\n\t{R: 0xbb, G: 0xdf, B: 0x27, A: 0xff},\n\t{R: 0xbd, G: 0xdf, B: 0x26, A: 0xff},\n\t{R: 0xc0, G: 0xdf, B: 0x24, A: 0xff},\n\t{R: 0xc3, G: 0xe0, B: 0x23, A: 0xff},\n\t{R: 0xc5, G: 0xe0, B: 0x21, A: 0xff},\n\t{R: 0xc8, G: 0xe1, B: 0x20, A: 0xff},\n\t{R: 0xcb, G: 0xe1, B: 0x1e, A: 0xff},\n\t{R: 0xcd, G: 0xe1, B: 0x1d, A: 0xff},\n\t{R: 0xd0, G: 0xe2, B: 0x1c, A: 0xff},\n\t{R: 0xd3, G: 0xe2, B: 0x1b, A: 0xff},\n\t{R: 0xd5, G: 0xe2, B: 0x1a, A: 0xff},\n\t{R: 0xd8, G: 0xe3, B: 0x19, A: 0xff},\n\t{R: 0xdb, G: 0xe3, B: 0x18, A: 0xff},\n\t{R: 0xdd, G: 0xe3, B: 0x18, A: 0xff},\n\t{R: 0xe0, G: 0xe4, B: 0x18, A: 0xff},\n\t{R: 0xe2, G: 0xe4, B: 0x18, A: 0xff},\n\t{R: 0xe5, G: 0xe4, B: 0x18, A: 0xff},\n\t{R: 0xe8, G: 0xe5, B: 0x19, A: 0xff},\n\t{R: 0xea, G: 0xe5, B: 0x19, A: 0xff},\n\t{R: 0xed, G: 0xe5, B: 0x1a, A: 0xff},\n\t{R: 0xef, G: 0xe6, B: 0x1b, A: 0xff},\n\t{R: 0xf2, G: 0xe6, B: 0x1c, A: 0xff},\n\t{R: 0xf4, G: 0xe6, B: 0x1e, A: 0xff},\n\t{R: 0xf7, G: 0xe6, B: 0x1f, A: 0xff},\n\t{R: 0xf9, G: 0xe7, B: 0x21, A: 0xff},\n\t{R: 0xfb, G: 0xe7, B: 0x23, A: 0xff},\n\t{R: 0xfe, G: 0xe7, B: 0x24, A: 0xff},\n}\n\n// Viridis creates a color map provider.\nfunc Viridis(v, vmin, vmax float64) drawing.Color {\n\tnormalized := (v - vmin) / (vmax - vmin)\n\tindex := uint8(normalized * 255)\n\treturn viridisColors[index]\n}\n"
        },
        {
          "name": "xaxis.go",
          "type": "blob",
          "size": 5.5126953125,
          "content": "package chart\n\nimport (\n\t\"math\"\n)\n\n// HideXAxis hides the x-axis.\nfunc HideXAxis() XAxis {\n\treturn XAxis{\n\t\tStyle: Hidden(),\n\t}\n}\n\n// XAxis represents the horizontal axis.\ntype XAxis struct {\n\tName      string\n\tNameStyle Style\n\n\tStyle          Style\n\tValueFormatter ValueFormatter\n\tRange          Range\n\n\tTickStyle    Style\n\tTicks        []Tick\n\tTickPosition TickPosition\n\n\tGridLines      []GridLine\n\tGridMajorStyle Style\n\tGridMinorStyle Style\n}\n\n// GetName returns the name.\nfunc (xa XAxis) GetName() string {\n\treturn xa.Name\n}\n\n// GetStyle returns the style.\nfunc (xa XAxis) GetStyle() Style {\n\treturn xa.Style\n}\n\n// GetValueFormatter returns the value formatter for the axis.\nfunc (xa XAxis) GetValueFormatter() ValueFormatter {\n\tif xa.ValueFormatter != nil {\n\t\treturn xa.ValueFormatter\n\t}\n\treturn FloatValueFormatter\n}\n\n// GetTickPosition returns the tick position option for the axis.\nfunc (xa XAxis) GetTickPosition(defaults ...TickPosition) TickPosition {\n\tif xa.TickPosition == TickPositionUnset {\n\t\tif len(defaults) > 0 {\n\t\t\treturn defaults[0]\n\t\t}\n\t\treturn TickPositionUnderTick\n\t}\n\treturn xa.TickPosition\n}\n\n// GetTicks returns the ticks for a series.\n// The coalesce priority is:\n// \t- User Supplied Ticks (i.e. Ticks array on the axis itself).\n// \t- Range ticks (i.e. if the range provides ticks).\n//\t- Generating continuous ticks based on minimum spacing and canvas width.\nfunc (xa XAxis) GetTicks(r Renderer, ra Range, defaults Style, vf ValueFormatter) []Tick {\n\tif len(xa.Ticks) > 0 {\n\t\treturn xa.Ticks\n\t}\n\tif tp, isTickProvider := ra.(TicksProvider); isTickProvider {\n\t\treturn tp.GetTicks(r, defaults, vf)\n\t}\n\ttickStyle := xa.Style.InheritFrom(defaults)\n\treturn GenerateContinuousTicks(r, ra, false, tickStyle, vf)\n}\n\n// GetGridLines returns the gridlines for the axis.\nfunc (xa XAxis) GetGridLines(ticks []Tick) []GridLine {\n\tif len(xa.GridLines) > 0 {\n\t\treturn xa.GridLines\n\t}\n\treturn GenerateGridLines(ticks, xa.GridMajorStyle, xa.GridMinorStyle)\n}\n\n// Measure returns the bounds of the axis.\nfunc (xa XAxis) Measure(r Renderer, canvasBox Box, ra Range, defaults Style, ticks []Tick) Box {\n\ttickStyle := xa.TickStyle.InheritFrom(xa.Style.InheritFrom(defaults))\n\n\ttp := xa.GetTickPosition()\n\n\tvar ltx, rtx int\n\tvar tx, ty int\n\tvar left, right, bottom = math.MaxInt32, 0, 0\n\tfor index, t := range ticks {\n\t\tv := t.Value\n\t\ttb := Draw.MeasureText(r, t.Label, tickStyle.GetTextOptions())\n\n\t\ttx = canvasBox.Left + ra.Translate(v)\n\t\tty = canvasBox.Bottom + DefaultXAxisMargin + tb.Height()\n\t\tswitch tp {\n\t\tcase TickPositionUnderTick, TickPositionUnset:\n\t\t\tltx = tx - tb.Width()>>1\n\t\t\trtx = tx + tb.Width()>>1\n\t\t\tbreak\n\t\tcase TickPositionBetweenTicks:\n\t\t\tif index > 0 {\n\t\t\t\tltx = ra.Translate(ticks[index-1].Value)\n\t\t\t\trtx = tx\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tleft = MinInt(left, ltx)\n\t\tright = MaxInt(right, rtx)\n\t\tbottom = MaxInt(bottom, ty)\n\t}\n\n\tif !xa.NameStyle.Hidden && len(xa.Name) > 0 {\n\t\ttb := Draw.MeasureText(r, xa.Name, xa.NameStyle.InheritFrom(defaults))\n\t\tbottom += DefaultXAxisMargin + tb.Height()\n\t}\n\n\treturn Box{\n\t\tTop:    canvasBox.Bottom,\n\t\tLeft:   left,\n\t\tRight:  right,\n\t\tBottom: bottom,\n\t}\n}\n\n// Render renders the axis\nfunc (xa XAxis) Render(r Renderer, canvasBox Box, ra Range, defaults Style, ticks []Tick) {\n\ttickStyle := xa.TickStyle.InheritFrom(xa.Style.InheritFrom(defaults))\n\n\ttickStyle.GetStrokeOptions().WriteToRenderer(r)\n\tr.MoveTo(canvasBox.Left, canvasBox.Bottom)\n\tr.LineTo(canvasBox.Right, canvasBox.Bottom)\n\tr.Stroke()\n\n\ttp := xa.GetTickPosition()\n\n\tvar tx, ty int\n\tvar maxTextHeight int\n\tfor index, t := range ticks {\n\t\tv := t.Value\n\t\tlx := ra.Translate(v)\n\n\t\ttx = canvasBox.Left + lx\n\n\t\ttickStyle.GetStrokeOptions().WriteToRenderer(r)\n\t\tr.MoveTo(tx, canvasBox.Bottom)\n\t\tr.LineTo(tx, canvasBox.Bottom+DefaultVerticalTickHeight)\n\t\tr.Stroke()\n\n\t\ttickWithAxisStyle := xa.TickStyle.InheritFrom(xa.Style.InheritFrom(defaults))\n\t\ttb := Draw.MeasureText(r, t.Label, tickWithAxisStyle)\n\n\t\tswitch tp {\n\t\tcase TickPositionUnderTick, TickPositionUnset:\n\t\t\tif tickStyle.TextRotationDegrees == 0 {\n\t\t\t\ttx = tx - tb.Width()>>1\n\t\t\t\tty = canvasBox.Bottom + DefaultXAxisMargin + tb.Height()\n\t\t\t} else {\n\t\t\t\tty = canvasBox.Bottom + (2 * DefaultXAxisMargin)\n\t\t\t}\n\t\t\tDraw.Text(r, t.Label, tx, ty, tickWithAxisStyle)\n\t\t\tmaxTextHeight = MaxInt(maxTextHeight, tb.Height())\n\t\t\tbreak\n\t\tcase TickPositionBetweenTicks:\n\t\t\tif index > 0 {\n\t\t\t\tllx := ra.Translate(ticks[index-1].Value)\n\t\t\t\tltx := canvasBox.Left + llx\n\t\t\t\tfinalTickStyle := tickWithAxisStyle.InheritFrom(Style{TextHorizontalAlign: TextHorizontalAlignCenter})\n\n\t\t\t\tDraw.TextWithin(r, t.Label, Box{\n\t\t\t\t\tLeft:   ltx,\n\t\t\t\t\tRight:  tx,\n\t\t\t\t\tTop:    canvasBox.Bottom + DefaultXAxisMargin,\n\t\t\t\t\tBottom: canvasBox.Bottom + DefaultXAxisMargin,\n\t\t\t\t}, finalTickStyle)\n\n\t\t\t\tftb := Text.MeasureLines(r, Text.WrapFit(r, t.Label, tx-ltx, finalTickStyle), finalTickStyle)\n\t\t\t\tmaxTextHeight = MaxInt(maxTextHeight, ftb.Height())\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tnameStyle := xa.NameStyle.InheritFrom(defaults)\n\tif !xa.NameStyle.Hidden && len(xa.Name) > 0 {\n\t\ttb := Draw.MeasureText(r, xa.Name, nameStyle)\n\t\ttx := canvasBox.Right - (canvasBox.Width()>>1 + tb.Width()>>1)\n\t\tty := canvasBox.Bottom + DefaultXAxisMargin + maxTextHeight + DefaultXAxisMargin + tb.Height()\n\t\tDraw.Text(r, xa.Name, tx, ty, nameStyle)\n\t}\n\n\tif !xa.GridMajorStyle.Hidden || !xa.GridMinorStyle.Hidden {\n\t\tfor _, gl := range xa.GetGridLines(ticks) {\n\t\t\tif (gl.IsMinor && !xa.GridMinorStyle.Hidden) || (!gl.IsMinor && !xa.GridMajorStyle.Hidden) {\n\t\t\t\tdefaults := xa.GridMajorStyle\n\t\t\t\tif gl.IsMinor {\n\t\t\t\t\tdefaults = xa.GridMinorStyle\n\t\t\t\t}\n\t\t\t\tgl.Render(r, canvasBox, ra, true, gl.Style.InheritFrom(defaults))\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "xaxis_test.go",
          "type": "blob",
          "size": 1.5263671875,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestXAxisGetTicks(t *testing.T) {\n\t// replaced new assertions helper\n\n\tr, err := PNG(1024, 1024)\n\ttestutil.AssertNil(t, err)\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\txa := XAxis{}\n\txr := &ContinuousRange{Min: 10, Max: 100, Domain: 1024}\n\tstyleDefaults := Style{\n\t\tFont:     f,\n\t\tFontSize: 10.0,\n\t}\n\tvf := FloatValueFormatter\n\tticks := xa.GetTicks(r, xr, styleDefaults, vf)\n\ttestutil.AssertLen(t, ticks, 16)\n}\n\nfunc TestXAxisGetTicksWithUserDefaults(t *testing.T) {\n\t// replaced new assertions helper\n\n\tr, err := PNG(1024, 1024)\n\ttestutil.AssertNil(t, err)\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\txa := XAxis{\n\t\tTicks: []Tick{{Value: 1.0, Label: \"1.0\"}},\n\t}\n\txr := &ContinuousRange{Min: 10, Max: 100, Domain: 1024}\n\tstyleDefaults := Style{\n\t\tFont:     f,\n\t\tFontSize: 10.0,\n\t}\n\tvf := FloatValueFormatter\n\tticks := xa.GetTicks(r, xr, styleDefaults, vf)\n\ttestutil.AssertLen(t, ticks, 1)\n}\n\nfunc TestXAxisMeasure(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\tstyle := Style{\n\t\tFont:     f,\n\t\tFontSize: 10.0,\n\t}\n\tr, err := PNG(100, 100)\n\ttestutil.AssertNil(t, err)\n\tticks := []Tick{{Value: 1.0, Label: \"1.0\"}, {Value: 2.0, Label: \"2.0\"}, {Value: 3.0, Label: \"3.0\"}}\n\txa := XAxis{}\n\txab := xa.Measure(r, NewBox(0, 0, 100, 100), &ContinuousRange{Min: 1.0, Max: 3.0, Domain: 100}, style, ticks)\n\ttestutil.AssertEqual(t, 122, xab.Width())\n\ttestutil.AssertEqual(t, 21, xab.Height())\n}\n"
        },
        {
          "name": "yaxis.go",
          "type": "blob",
          "size": 5.6337890625,
          "content": "package chart\n\nimport (\n\t\"math\"\n)\n\n// HideYAxis hides a y-axis.\nfunc HideYAxis() YAxis {\n\treturn YAxis{\n\t\tStyle: Hidden(),\n\t}\n}\n\n// YAxis is a veritcal rule of the range.\n// There can be (2) y-axes; a primary and secondary.\ntype YAxis struct {\n\tName      string\n\tNameStyle Style\n\n\tStyle Style\n\n\tZero GridLine\n\n\tAxisType  YAxisType\n\tAscending bool\n\n\tValueFormatter ValueFormatter\n\tRange          Range\n\n\tTickStyle Style\n\tTicks     []Tick\n\n\tGridLines      []GridLine\n\tGridMajorStyle Style\n\tGridMinorStyle Style\n}\n\n// GetName returns the name.\nfunc (ya YAxis) GetName() string {\n\treturn ya.Name\n}\n\n// GetNameStyle returns the name style.\nfunc (ya YAxis) GetNameStyle() Style {\n\treturn ya.NameStyle\n}\n\n// GetStyle returns the style.\nfunc (ya YAxis) GetStyle() Style {\n\treturn ya.Style\n}\n\n// GetValueFormatter returns the value formatter for the axis.\nfunc (ya YAxis) GetValueFormatter() ValueFormatter {\n\tif ya.ValueFormatter != nil {\n\t\treturn ya.ValueFormatter\n\t}\n\treturn FloatValueFormatter\n}\n\n// GetTickStyle returns the tick style.\nfunc (ya YAxis) GetTickStyle() Style {\n\treturn ya.TickStyle\n}\n\n// GetTicks returns the ticks for a series.\n// The coalesce priority is:\n// \t- User Supplied Ticks (i.e. Ticks array on the axis itself).\n// \t- Range ticks (i.e. if the range provides ticks).\n//\t- Generating continuous ticks based on minimum spacing and canvas width.\nfunc (ya YAxis) GetTicks(r Renderer, ra Range, defaults Style, vf ValueFormatter) []Tick {\n\tif len(ya.Ticks) > 0 {\n\t\treturn ya.Ticks\n\t}\n\tif tp, isTickProvider := ra.(TicksProvider); isTickProvider {\n\t\treturn tp.GetTicks(r, defaults, vf)\n\t}\n\ttickStyle := ya.Style.InheritFrom(defaults)\n\treturn GenerateContinuousTicks(r, ra, true, tickStyle, vf)\n}\n\n// GetGridLines returns the gridlines for the axis.\nfunc (ya YAxis) GetGridLines(ticks []Tick) []GridLine {\n\tif len(ya.GridLines) > 0 {\n\t\treturn ya.GridLines\n\t}\n\treturn GenerateGridLines(ticks, ya.GridMajorStyle, ya.GridMinorStyle)\n}\n\n// Measure returns the bounds of the axis.\nfunc (ya YAxis) Measure(r Renderer, canvasBox Box, ra Range, defaults Style, ticks []Tick) Box {\n\tvar tx int\n\tif ya.AxisType == YAxisPrimary {\n\t\ttx = canvasBox.Right + DefaultYAxisMargin\n\t} else if ya.AxisType == YAxisSecondary {\n\t\ttx = canvasBox.Left - DefaultYAxisMargin\n\t}\n\n\tya.TickStyle.InheritFrom(ya.Style.InheritFrom(defaults)).WriteToRenderer(r)\n\tvar minx, maxx, miny, maxy = math.MaxInt32, 0, math.MaxInt32, 0\n\tvar maxTextHeight int\n\tfor _, t := range ticks {\n\t\tv := t.Value\n\t\tly := canvasBox.Bottom - ra.Translate(v)\n\n\t\ttb := r.MeasureText(t.Label)\n\t\ttbh2 := tb.Height() >> 1\n\t\tfinalTextX := tx\n\t\tif ya.AxisType == YAxisSecondary {\n\t\t\tfinalTextX = tx - tb.Width()\n\t\t}\n\n\t\tmaxTextHeight = MaxInt(tb.Height(), maxTextHeight)\n\n\t\tif ya.AxisType == YAxisPrimary {\n\t\t\tminx = canvasBox.Right\n\t\t\tmaxx = MaxInt(maxx, tx+tb.Width())\n\t\t} else if ya.AxisType == YAxisSecondary {\n\t\t\tminx = MinInt(minx, finalTextX)\n\t\t\tmaxx = MaxInt(maxx, tx)\n\t\t}\n\n\t\tminy = MinInt(miny, ly-tbh2)\n\t\tmaxy = MaxInt(maxy, ly+tbh2)\n\t}\n\n\tif !ya.NameStyle.Hidden && len(ya.Name) > 0 {\n\t\tmaxx += (DefaultYAxisMargin + maxTextHeight)\n\t}\n\n\treturn Box{\n\t\tTop:    miny,\n\t\tLeft:   minx,\n\t\tRight:  maxx,\n\t\tBottom: maxy,\n\t}\n}\n\n// Render renders the axis.\nfunc (ya YAxis) Render(r Renderer, canvasBox Box, ra Range, defaults Style, ticks []Tick) {\n\ttickStyle := ya.TickStyle.InheritFrom(ya.Style.InheritFrom(defaults))\n\ttickStyle.WriteToRenderer(r)\n\n\tsw := tickStyle.GetStrokeWidth(defaults.StrokeWidth)\n\n\tvar lx int\n\tvar tx int\n\tif ya.AxisType == YAxisPrimary {\n\t\tlx = canvasBox.Right + int(sw)\n\t\ttx = lx + DefaultYAxisMargin\n\t} else if ya.AxisType == YAxisSecondary {\n\t\tlx = canvasBox.Left - int(sw)\n\t\ttx = lx - DefaultYAxisMargin\n\t}\n\n\tr.MoveTo(lx, canvasBox.Bottom)\n\tr.LineTo(lx, canvasBox.Top)\n\tr.Stroke()\n\n\tvar maxTextWidth int\n\tvar finalTextX, finalTextY int\n\tfor _, t := range ticks {\n\t\tv := t.Value\n\t\tly := canvasBox.Bottom - ra.Translate(v)\n\n\t\ttb := Draw.MeasureText(r, t.Label, tickStyle)\n\n\t\tif tb.Width() > maxTextWidth {\n\t\t\tmaxTextWidth = tb.Width()\n\t\t}\n\n\t\tif ya.AxisType == YAxisSecondary {\n\t\t\tfinalTextX = tx - tb.Width()\n\t\t} else {\n\t\t\tfinalTextX = tx\n\t\t}\n\n\t\tif tickStyle.TextRotationDegrees == 0 {\n\t\t\tfinalTextY = ly + tb.Height()>>1\n\t\t} else {\n\t\t\tfinalTextY = ly\n\t\t}\n\n\t\ttickStyle.WriteToRenderer(r)\n\n\t\tr.MoveTo(lx, ly)\n\t\tif ya.AxisType == YAxisPrimary {\n\t\t\tr.LineTo(lx+DefaultHorizontalTickWidth, ly)\n\t\t} else if ya.AxisType == YAxisSecondary {\n\t\t\tr.LineTo(lx-DefaultHorizontalTickWidth, ly)\n\t\t}\n\t\tr.Stroke()\n\n\t\tDraw.Text(r, t.Label, finalTextX, finalTextY, tickStyle)\n\t}\n\n\tnameStyle := ya.NameStyle.InheritFrom(defaults.InheritFrom(Style{TextRotationDegrees: 90}))\n\tif !ya.NameStyle.Hidden && len(ya.Name) > 0 {\n\t\tnameStyle.GetTextOptions().WriteToRenderer(r)\n\t\ttb := Draw.MeasureText(r, ya.Name, nameStyle)\n\n\t\tvar tx int\n\t\tif ya.AxisType == YAxisPrimary {\n\t\t\ttx = canvasBox.Right + int(sw) + DefaultYAxisMargin + maxTextWidth + DefaultYAxisMargin\n\t\t} else if ya.AxisType == YAxisSecondary {\n\t\t\ttx = canvasBox.Left - (DefaultYAxisMargin + int(sw) + maxTextWidth + DefaultYAxisMargin)\n\t\t}\n\n\t\tvar ty int\n\t\tif nameStyle.TextRotationDegrees == 0 {\n\t\t\tty = canvasBox.Top + (canvasBox.Height()>>1 - tb.Width()>>1)\n\t\t} else {\n\t\t\tty = canvasBox.Top + (canvasBox.Height()>>1 - tb.Height()>>1)\n\t\t}\n\n\t\tDraw.Text(r, ya.Name, tx, ty, nameStyle)\n\t}\n\n\tif !ya.Zero.Style.Hidden {\n\t\tya.Zero.Render(r, canvasBox, ra, false, Style{})\n\t}\n\n\tif !ya.GridMajorStyle.Hidden || !ya.GridMinorStyle.Hidden {\n\t\tfor _, gl := range ya.GetGridLines(ticks) {\n\t\t\tif (gl.IsMinor && !ya.GridMinorStyle.Hidden) || (!gl.IsMinor && !ya.GridMajorStyle.Hidden) {\n\t\t\t\tdefaults := ya.GridMajorStyle\n\t\t\t\tif gl.IsMinor {\n\t\t\t\t\tdefaults = ya.GridMinorStyle\n\t\t\t\t}\n\t\t\t\tgl.Render(r, canvasBox, ra, false, gl.Style.InheritFrom(defaults))\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "yaxis_test.go",
          "type": "blob",
          "size": 2.09765625,
          "content": "package chart\n\nimport (\n\t\"testing\"\n\n\t\"github.com/wcharczuk/go-chart/v2/testutil\"\n)\n\nfunc TestYAxisGetTicks(t *testing.T) {\n\t// replaced new assertions helper\n\n\tr, err := PNG(1024, 1024)\n\ttestutil.AssertNil(t, err)\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tya := YAxis{}\n\tyr := &ContinuousRange{Min: 10, Max: 100, Domain: 1024}\n\tstyleDefaults := Style{\n\t\tFont:     f,\n\t\tFontSize: 10.0,\n\t}\n\tvf := FloatValueFormatter\n\tticks := ya.GetTicks(r, yr, styleDefaults, vf)\n\ttestutil.AssertLen(t, ticks, 32)\n}\n\nfunc TestYAxisGetTicksWithUserDefaults(t *testing.T) {\n\t// replaced new assertions helper\n\n\tr, err := PNG(1024, 1024)\n\ttestutil.AssertNil(t, err)\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\n\tya := YAxis{\n\t\tTicks: []Tick{{Value: 1.0, Label: \"1.0\"}},\n\t}\n\tyr := &ContinuousRange{Min: 10, Max: 100, Domain: 1024}\n\tstyleDefaults := Style{\n\t\tFont:     f,\n\t\tFontSize: 10.0,\n\t}\n\tvf := FloatValueFormatter\n\tticks := ya.GetTicks(r, yr, styleDefaults, vf)\n\ttestutil.AssertLen(t, ticks, 1)\n}\n\nfunc TestYAxisMeasure(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\tstyle := Style{\n\t\tFont:     f,\n\t\tFontSize: 10.0,\n\t}\n\tr, err := PNG(100, 100)\n\ttestutil.AssertNil(t, err)\n\tticks := []Tick{{Value: 1.0, Label: \"1.0\"}, {Value: 2.0, Label: \"2.0\"}, {Value: 3.0, Label: \"3.0\"}}\n\tya := YAxis{}\n\tyab := ya.Measure(r, NewBox(0, 0, 100, 100), &ContinuousRange{Min: 1.0, Max: 3.0, Domain: 100}, style, ticks)\n\ttestutil.AssertEqual(t, 32, yab.Width())\n\ttestutil.AssertEqual(t, 110, yab.Height())\n}\n\nfunc TestYAxisSecondaryMeasure(t *testing.T) {\n\t// replaced new assertions helper\n\n\tf, err := GetDefaultFont()\n\ttestutil.AssertNil(t, err)\n\tstyle := Style{\n\t\tFont:     f,\n\t\tFontSize: 10.0,\n\t}\n\tr, err := PNG(100, 100)\n\ttestutil.AssertNil(t, err)\n\tticks := []Tick{{Value: 1.0, Label: \"1.0\"}, {Value: 2.0, Label: \"2.0\"}, {Value: 3.0, Label: \"3.0\"}}\n\tya := YAxis{AxisType: YAxisSecondary}\n\tyab := ya.Measure(r, NewBox(0, 0, 100, 100), &ContinuousRange{Min: 1.0, Max: 3.0, Domain: 100}, style, ticks)\n\ttestutil.AssertEqual(t, 32, yab.Width())\n\ttestutil.AssertEqual(t, 110, yab.Height())\n}\n"
        }
      ]
    }
  ]
}