{
  "metadata": {
    "timestamp": 1736566616656,
    "page": 173,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Ullaakut/cameradar",
      "stars": 4182,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.06640625,
          "content": "# IDE config\n.idea/\n.vscode/\n\n# Golang\n/bin/*\n/pkg/*\n\n# Builds\ndist/"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.2001953125,
          "content": "# https://github.com/golangci/golangci/wiki/Configuration\n\nservice:\n  project-path: github.com/Ullaakut/cameradar\n  prepare:\n    - apt-get update && apt-get install -y libcurl4-gnutls-dev\n    - dep ensure\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.65625,
          "content": "project_name: cameradar\ndist: dist/cameradar\n\nenv:\n  - GO111MODULE=on\nbefore:\n  hooks:\n    - go mod download\n\nbuilds:\n  - binary: cameradar\n    main: ./cmd/cameradar\n    goos:\n      - windows\n      - darwin\n      - linux\n    goarch:\n      - amd64\n      - 386\n      - arm\n      - arm64\n    goarm:\n      - 6\n      - 7\n\n    ignore:\n      - goos: darwin\n        goarch: 386\n\nchangelog:\n  skip: true\n\nchecksum:\n  name_template: \"{{ .ProjectName }}_checksums.txt\"\n\narchives:\n  - name_template: \"{{ .Binary }}_{{ .Os }}_{{ .Arch }}{{ if .Arm}}v{{ .Arm }}{{ end }}\"\n    format: tar.gz\n    format_overrides:\n      - goos: windows\n        format: zip\n    files:\n      - CHANGELOG.md"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.1513671875,
          "content": "dist: trusty\nsudo: required\nlanguage: go\n\naddons:\n  apt:\n    packages:\n    # needed for the nfpm pipe:\n    - rpm\n    # needed for the snap pipe:\n    - snapd\n\nenv:\n  - GO111MODULE=on\n  # needed for the snap pipe:\n  - PATH=/snap/bin:$PATH\n\nservices:\n  - docker\n\nbefore_install:\n- echo \"Testing Docker Hub credentials\"\n- if [[ \"$DOCKER_PASSOWRD\" != \"\" ]]; then docker login -u=$DOCKER_USERNAME -p=$DOCKER_PASSWORD; fi\n- echo \"Docker Hub credentials are working\"\n# If I see one day that Travis CI updates their default docker version\n# I can remove the lines below. That's why I leave this here :-)\n- docker version\n- sudo apt-get remove docker docker-engine docker.io\n- curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n- sudo apt-get update\n- sudo apt-get install -y docker-ce nmap libcurl4-openssl-dev\n- go get github.com/mattn/goveralls\n- docker version\n\ninstall:\n- docker build -t cameradar .\n\nscript:\n# Run unit tests\n- GO111MODULE=on go test -v -covermode=count -coverprofile=coverage.out\n- GO111MODULE=on $HOME/gopath/bin/goveralls -coverprofile=coverage.out -service=travis-ci -repotoken=$COVERALLS_TOKEN\n# Launch fake cameras to check if cameradar is able to access them\n- docker run -d --name=\"fake_camera_digest\" -e RTSP_ROUTE=\"/live.sdp\" -e RTSP_USERNAME=\"admin\" -e RTSP_PASSWORD=\"12345\" -e RTSP_AUTHENTICATION_METHOD=\"digest\" -p 8554:8554 ullaakut/rtspatt\n- docker run -d --name=\"fake_camera_basic\" -e RTSP_ROUTE=\"/live.sdp\" -e RTSP_USERNAME=\"root\" -e RTSP_PASSWORD=\"root\" -e RTSP_AUTHENTICATION_METHOD=\"digest\" -p 5554:5554 ullaakut/rtspatt\n# Launch cameradar on the local machine\n- docker run --net=host -t cameradar -t 0.0.0.0 -p 8554,5554 -v > logs.txt\n# Gather the logs from the cameras\n- docker logs fake_camera_digest > camera_digest_logs.txt\n- docker logs fake_camera_basic > camera_basic_logs.txt\n# Stop the fake cameras\n- docker stop fake_camera_basic\n- docker stop fake_camera_digest\n# Print logs\n- cat camera_digest_logs.txt\n- cat camera_basic_logs.txt\n- cat logs.txt\n- grep \"Successful attack\" logs.txt || exit 1\n- git clean -fd\n\nnotifications:\n  email:\n    recipients:\n      - brendan.le-glaunec@epitech.eu\n    on_success: never\n    on_failure: always\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.0302734375,
          "content": "# Build stage\nFROM golang:alpine AS build-env\n\nCOPY . /go/src/github.com/Ullaakut/cameradar\nWORKDIR /go/src/github.com/Ullaakut/cameradar/cmd/cameradar\n\nRUN apk update && \\\n    apk upgrade && \\\n    apk add nmap nmap-nselibs nmap-scripts \\\n    curl curl-dev \\\n    gcc \\\n    libc-dev \\\n    git \\\n    pkgconfig\nENV GO111MODULE=on\nRUN go version\nRUN go build -o cameradar\n\n# Final stage\nFROM alpine\n\n# Necessary to install curl v7.64.0-r3.\n# Fix for https://github.com/Ullaakut/cameradar/issues/247\nRUN echo 'http://dl-cdn.alpinelinux.org/alpine/v3.9/main' >> /etc/apk/repositories\n\nRUN apk --update add --no-cache nmap \\\n    nmap-nselibs \\\n    nmap-scripts \\\n    curl-dev==7.64.0-r5\n\nWORKDIR /app/cameradar\nCOPY --from=build-env /go/src/github.com/Ullaakut/cameradar/dictionaries/ /app/dictionaries/\nCOPY --from=build-env /go/src/github.com/Ullaakut/cameradar/cmd/cameradar/ /app/cameradar/\n\nENV CAMERADAR_CUSTOM_ROUTES=\"/app/dictionaries/routes\"\nENV CAMERADAR_CUSTOM_CREDENTIALS=\"/app/dictionaries/credentials.json\"\n\nENTRYPOINT [\"/app/cameradar/cameradar\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.998046875,
          "content": "Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.4658203125,
          "content": "# Cameradar\n\n<p align=\"center\">\n    <img src=\"images/Cameradar.gif\" width=\"100%\"/>\n</p>\n\n<p align=\"center\">\n    <a href=\"#license\">\n        <img src=\"https://img.shields.io/badge/license-Apache-blue.svg?style=flat\" />\n    </a>\n    <a href=\"https://hub.docker.com/r/ullaakut/cameradar/\">\n        <img src=\"https://img.shields.io/docker/pulls/ullaakut/cameradar.svg?style=flat\" />\n    </a>\n    <a href=\"https://travis-ci.org/Ullaakut/cameradar\">\n        <img src=\"https://travis-ci.org/Ullaakut/cameradar.svg?branch=master\" />\n    </a>\n    <a href='https://coveralls.io/github/Ullaakut/cameradar?branch=master'>\n        <img src='https://coveralls.io/repos/github/Ullaakut/cameradar/badge.svg?branch=master' alt='Coverage Status' />\n    </a>\n    <a href=\"https://golangci.com/r/github.com/ullaakut/cameradar\">\n        <img src=\"https://golangci.com/badges/github.com/ullaakut/cameradar.svg\" />\n    </a>\n    <a href=\"https://goreportcard.com/report/github.com/ullaakut/cameradar\">\n        <img src=\"https://goreportcard.com/badge/github.com/ullaakut/cameradar\" />\n    </a>\n    <a href=\"https://github.com/ullaakut/cameradar/releases/latest\">\n        <img src=\"https://img.shields.io/github/release/Ullaakut/cameradar.svg?style=flat\" />\n    </a>\n    <a href=\"https://godoc.org/github.com/ullaakut/cameradar\">\n        <img src=\"https://godoc.org/github.com/ullaakut/cameradar?status.svg\" />\n    </a>\n</p>\n\n## An RTSP stream access tool that comes with its library\n\n### Cameradar allows you to\n\n* **Detect open RTSP hosts** on any accessible target host\n* Detect which device model is streaming\n* Launch automated dictionary attacks to get their **stream route** (e.g.: `/live.sdp`)\n* Launch automated dictionary attacks to get the **username and password** of the cameras\n* Retrieve a complete and user-friendly report of the results\n\n<p align=\"center\"><img src=\"images/Cameradar.png\" width=\"250\"/></p>\n\n## Table of content\n\n* [Docker Image](#docker-image)\n* [Configuration](#configuration)\n* [Output](#output)\n* [Check camera access](#check-camera-access)\n* [Command-line options](#command-line-options)\n* [Contribution](#contribution)\n* [Frequently Asked Questions](#frequently-asked-questions)\n* [License](#license)\n\n## Docker Image for Cameradar\n\n<p align=\"center\"><img src=\"images/CameradarV4.png\" width=\"70%\"/></p>\n\nInstall [docker](https://docs.docker.com/engine/installation/) on your machine, and run the following command:\n\n```bash\ndocker run -t ullaakut/cameradar -t <target> <other command-line options>\n```\n\n[See command-line options](#command-line-options).\n\ne.g.: `docker run -t ullaakut/cameradar -t 192.168.100.0/24` will scan the ports 554, 5554 and 8554 of hosts on the 192.168.100.0/24 subnetwork and attack the discovered RTSP streams and will output debug logs.\n\n* `YOUR_TARGET` can be a subnet (e.g.: `172.16.100.0/24`), an IP (e.g.: `172.16.100.10`), or a range of IPs (e.g.: `172.16.100.10-20`).\n* If you want to get the precise results of the nmap scan in the form of an XML file, you can add `-v /your/path:/tmp/cameradar_scan.xml` to the docker run command, before `ullaakut/cameradar`.\n* If you use the `-r` and `-c` options to specify your custom dictionaries, make sure to also use a volume to add them to the docker container. Example: `docker run -t -v /path/to/dictionaries/:/tmp/ ullaakut/cameradar -r /tmp/myroutes -c /tmp/mycredentials.json -t mytarget`\n\n## Installing the binary on your machine\n\nOnly use this solution if for some reason using docker is not an option for you or if you want to locally build Cameradar on your machine.\n\n**WARNING**: Manually building the binary will **NOT WORK** for any camera that uses **DIGEST AUTHENTICATION** [if your version of `curl` is over `7.64.0`](https://github.com/Ullaakut/cameradar/pull/252), which is most likely the case. For more information, see [this response on the subject from the author of curl](https://stackoverflow.com/a/59778142/4145098).\n\n### Dependencies\n\n* `go` (> `1.10`)\n* `libcurl` development library (**[version has to be <7.66.0](https://github.com/Ullaakut/cameradar/issues/247)**)\n    * For apt users: `apt install libcurl4-openssl-dev`\n\n### Steps to install\n\n1. `go install github.com/Ullaakut/cameradar/v5/cmd/cameradar@latest`\n\nThe `cameradar` binary is now in your `$GOPATH/bin` ready to be used. See command line options [here](#command-line-options).\n\n## Configuration\n\nThe **RTSP port used for most cameras is 554**, so you should probably specify 554 as one of the ports you scan. Not specifying any ports to the cameradar application will scan the 554, 5554 and 8554 ports.\n\n`docker run -t --net=host ullaakut/cameradar -p \"18554,19000-19010\" -t localhost` will scan the ports `18554`, and the range of ports between `19000` and `19010` on `localhost`.\n\nYou **can use your own files for the credentials and routes dictionaries** used to attack the cameras, but the Cameradar repository already gives you a good base that works with most cameras, in the `/dictionaries` folder.\n\n```bash\ndocker run -t -v /my/folder/with/dictionaries:/tmp/dictionaries \\\n           ullaakut/cameradar \\\n           -r \"/tmp/dictionaries/my_routes\" \\\n           -c \"/tmp/dictionaries/my_credentials.json\" \\\n           -t 172.19.124.0/24\n```\n\nThis will put the contents of your folder containing dictionaries in the docker image and will use it for the dictionary attack instead of the default dictionaries provided in the cameradar repo.\n\n## Check camera access\n\nIf you have [VLC Media Player](http://www.videolan.org/vlc/), you should be able to use the GUI or the command-line to connect to the RTSP stream using this format: `rtsp://username:password@address:port/route`\n\n## Command-line options\n\n* **\"-t, --targets\"**: Set target. Required. Target can be a file (see [instructions on how to format the file](#format-input-file)), an IP, an IP range, a subnetwork, or a combination of those. Example: `--targets=\"192.168.1.72,192.168.1.74\"`\n* **\"-p, --ports\"**: (Default: `554,5554,8554`) Set custom ports.\n* **\"-s, --scan-speed\"**: (Default: `4`) Set custom nmap discovery presets to improve speed or accuracy. It's recommended to lower it if you are attempting to scan an unstable and slow network, or to increase it if on a very performant and reliable network. You might also want to keep it low to keep your discovery stealthy. See [this for more info on the nmap timing templates](https://nmap.org/book/man-performance.html).\n* **\"-I, --attack-interval\"**: (Default: `0ms`) Set custom interval after which an attack attempt without an answer should give up. It's recommended to increase it when attempting to scan unstable and slow networks or to decrease it on fast and reliable networks.\n* **\"-T, --timeout\"**: (Default: `2000ms`) Set custom timeout value after which an attack attempt without an answer should give up. It's recommended to increase it when attempting to scan unstable and slow networks or to decrease it on fast and reliable networks.\n* **\"-r, --custom-routes\"**: (Default: `<CAMERADAR_GOPATH>/dictionaries/routes`) Set custom dictionary path for routes\n* **\"-c, --custom-credentials\"**: (Default: `<CAMERADAR_GOPATH>/dictionaries/credentials.json`) Set custom dictionary path for credentials\n* **\"-o, --nmap-output\"**: (Default: `/tmp/cameradar_scan.xml`) Set custom nmap output path\n* **\"-d, --debug\"**: Enable debug logs\n* **\"-v, --verbose\"**: Enable verbose curl logs (not recommended for most use)\n* **\"-h\"**: Display the usage information\n\n## Format input file\n\nThe file can contain IPs, hostnames, IP ranges and subnetwork, separated by newlines. Example:\n\n```text\n0.0.0.0\nlocalhost\n192.17.0.0/16\n192.168.1.140-255\n192.168.2-3.0-255\n```\n\n## Environment Variables\n\n### `CAMERADAR_TARGET`\n\nThis variable is mandatory and specifies the target that cameradar should scan and attempt to access RTSP streams on.\n\nExamples:\n\n* `172.16.100.0/24`\n* `192.168.1.1`\n* `localhost`\n* `192.168.1.140-255`\n* `192.168.2-3.0-255`\n\n### `CAMERADAR_PORTS`\n\nThis variable is optional and allows you to specify the ports on which to run the scans.\n\nDefault value: `554,5554,8554`\n\nIt is recommended not to change these except if you are certain that cameras have been configured to stream RTSP over a different port. 99.9% of cameras are streaming on these ports.\n\n### `CAMERADAR_NMAP_OUTPUT_FILE`\n\nThis variable is optional and allows you to specify on which file nmap will write its output.\n\nDefault value: `/tmp/cameradar_scan.xml`\n\nThis can be useful only if you want to read the files yourself, if you don't want it to write in your `/tmp` folder, or if you want to use only the RunNmap function in cameradar, and do its parsing manually.\n\n### `CAMERADAR_CUSTOM_ROUTES`, `CAMERADAR_CUSTOM_CREDENTIALS`\n\nThese variables are optional, allowing to replace the default dictionaries with custom ones, for the dictionary attack.\n\nDefault values: `<CAMERADAR_GOPATH>/dictionaries/routes` and `<CAMERADAR_GOPATH>/dictionaries/credentials.json`\n\n### `CAMERADAR_SCAN_SPEED`\n\nThis optional variable allows you to set custom nmap discovery presets to improve speed or accuracy. It's recommended to lower it if you are attempting to scan an unstable and slow network, or to increase it if on a fast and reliable network. See [this for more info on the nmap timing templates](https://nmap.org/book/man-performance.html).\n\nDefault value: `4`\n\n### `CAMERADAR_ATTACK_INTERVAL`\n\nThis optional variable allows you to set `custom interval` to wait between each attack in order to stay stealthy. It's recommended to increase it when attempting to scan a network that might be protected against bruteforce attacks. By default, there is no interval, in order to make attacks as fast as possible\n\nDefault value: `0ms`\n\n### `CAMERADAR_TIMEOUT`\n\nThis optional variable allows you to set custom timeout value after which an attack attempt without an answer should give up. It's recommended to increase it when attempting to scan unstable and slow networks or to decrease it on fast and reliable networks.\n\nDefault value: `2000ms`\n\n### `CAMERADAR_LOGGING`\n\nThis optional variable allows you to enable a more verbose output to have more information about what is going on.\n\nIt will output nmap results, cURL requests, etc.\n\nDefault: `false`\n\n## Contribution\n\n### Build\n\n#### Docker build\n\nTo build the docker image, simply run `docker build . -t cameradar` in the root of the project.\n\nYour image will be called `cameradar` and NOT `ullaakut/cameradar`.\n\n#### Go build\n\n1. `go get github.com/Ullaakut/cameradar`\n2. `cd $GOPATH/src/github.com/Ullaakut/cameradar`\n3. `cd cmd/cameradar`\n4. `go install`\n\nThe cameradar binary is now in `$GOPATH/bin/cameradar`.\n\n## Frequently Asked Questions\n\n> Cameradar does not detect any camera!\n\nThat means that either your cameras are not streaming in RTSP or that they are not on the target you are scanning. In most cases, CCTV cameras will be on a private subnetwork, isolated from the internet. Use the `-t` option to specify your target. If you are sure you did everything right but it still does not work, please open an issue with details on the device you are trying to access üôè\n\n> Cameradar detects my cameras, but does not manage to access them at all!\n\nMaybe your cameras have been configured, and the credentials / URL have been changed. Cameradar only guesses using default constructor values if a custom dictionary is not provided. You can use your own dictionaries in which you just have to add your credentials and RTSP routes. To do that, see how the [configuration](#configuration) works. Also, maybe your camera's credentials are not yet known, in which case if you find them it would be very nice to add them to the Cameradar dictionaries to help other people in the future.\n\n> What happened to the C++ version?\n\nYou can still find it under the 1.1.4 tag on this repo, however it was slower and less stable than the current version written in Golang. It is not recommended using it.\n\n> How to use the Cameradar library for my own project?\n\nSee the example in `/cmd/cameradar`. You just need to run `go get github.com/Ullaakut/cameradar` and to use the `cameradar` package in your code. You can find the documentation on [godoc](https://godoc.org/github.com/ullaakut/cameradar).\n\n> I want to scan my own localhost for some reason, and it does not work! What's going on?\n\nUse the `--net=host` flag when launching the cameradar image, or use the binary by running `go run cameradar/cameradar.go` or [installing it](#go-build).\n\n> I don't see a colored output:(\n\nYou forgot the `-t` flag before `ullaakut/cameradar` in your command-line. This tells docker to allocate a pseudo-tty for cameradar, which makes it able to use colors.\n\n> I don't have a camera, but I'd like to try Cameradar!\n\nSimply run `docker run -p 8554:8554 -e RTSP_USERNAME=admin -e RTSP_PASSWORD=12345 -e RTSP_PORT=8554 ullaakut/rtspatt` and then run cameradar, and it should guess that the username is admin and that the password is 12345. You can try this with any default constructor credentials (they can be found [here](dictionaries/credentials.json)).\n\n> What authentication types does Cameradar support?\n\nCameradar supports both basic and digest authentication.\n\n## Examples\n\n> Running cameradar on your own machine to scan for default ports\n\n`docker run --net=host -t ullaakut/cameradar -t localhost`\n\n> Running cameradar with an input file, logs enabled on port 8554\n\n`docker run -v /tmp:/tmp --net=host -t ullaakut/cameradar -t /tmp/test.txt -p 8554`\n\n> Running cameradar on a subnetwork with custom dictionaries, on ports 554, 5554 and 8554\n\n`docker run -v /tmp:/tmp --net=host -t ullaakut/cameradar -t 192.168.0.0/24 --custom-credentials=\"/tmp/dictionaries/credentials.json\" --custom-routes=\"/tmp/dictionaries/routes\" -p 554,5554,8554`\n\n## License\n\nCopyright 2023 Ullaakut\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README_RU.md",
          "type": "blob",
          "size": 23.0654296875,
          "content": "# Cameradar\n\n<p align=\"center\">\n    <img src=\"images/Cameradar.gif\" width=\"100%\"/>\n</p>\n\n<p align=\"center\">\n    <a href=\"#license\">\n        <img src=\"https://img.shields.io/badge/license-Apache-blue.svg?style=flat\" />\n    </a>\n    <a href=\"https://hub.docker.com/r/ullaakut/cameradar/\">\n        <img src=\"https://img.shields.io/docker/pulls/ullaakut/cameradar.svg?style=flat\" />\n    </a>\n    <a href=\"https://travis-ci.org/Ullaakut/cameradar\">\n        <img src=\"https://travis-ci.org/Ullaakut/cameradar.svg?branch=master\" />\n    </a>\n    <a href='https://coveralls.io/github/Ullaakut/cameradar?branch=master'>\n        <img src='https://coveralls.io/repos/github/Ullaakut/cameradar/badge.svg?branch=master' alt='Coverage Status' />\n    </a>\n    <a href=\"https://golangci.com/r/github.com/ullaakut/cameradar\">\n        <img src=\"https://golangci.com/badges/github.com/ullaakut/cameradar.svg\" />\n    </a>\n    <a href=\"https://goreportcard.com/report/github.com/ullaakut/cameradar\">\n        <img src=\"https://goreportcard.com/badge/github.com/ullaakut/cameradar\" />\n    </a>\n    <a href=\"https://github.com/ullaakut/cameradar/releases/latest\">\n        <img src=\"https://img.shields.io/github/release/Ullaakut/cameradar.svg?style=flat\" />\n    </a>\n    <a href=\"https://godoc.org/github.com/ullaakut/cameradar\">\n        <img src=\"https://godoc.org/github.com/ullaakut/cameradar?status.svg\" />\n    </a>\n</p>\n\n## RTSP stream –ø–æ—Ç–æ–∫–æ–≤—ã –ø—Ä–æ—Ç–æ–∫–æ–ª —Å–æ —Å–≤–æ–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π\n\n### –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ Cameradar\n\n* **–û–±–Ω–∞—Ä—É–∂–∏—Ç—å –æ—Ç–∫—Ä—ã—Ç—ã–µ RTSP-—Ö–æ—Å—Ç—ã** –Ω–∞ –ª—é–±–æ–º –¥–æ—Å—Ç—É–ø–Ω–æ–º —Ü–µ–ª–µ–≤–æ–º —É–∑–ª–µ.\n* –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –∫–∞–∫–∞—è –º–æ–¥–µ–ª—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç –ø–æ—Ç–æ–∫–æ–≤–æ–µ –≤–µ—â–∞–Ω–∏–µ\n* –ó–∞–ø—É—Å–∫–∞—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–±–æ—Ä –ø–æ —Å–ª–æ–≤–∞—Ä—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è **–º–∞—Ä—à—Ä—É—Ç–∞ –ø–æ—Ç–æ–∫–∞** (–Ω–∞–ø—Ä–∏–º–µ—Ä: `/live.sdp`)\n* –ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–µ—Ä–µ–±–æ—Ä –ø–æ —Å–ª–æ–≤–∞—Ä—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è **–∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ø–∞—Ä–æ–ª—è** –∫–∞–º–µ—Ä.\n* –ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª–Ω—ã–π –∏ —É–¥–æ–±–Ω—ã–π –æ—Ç—á–µ—Ç –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö.\n\n<p align=\"center\"><img src=\"images/Cameradar.png\" width=\"250\"/></p>\n\n## –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ \n\n* [Docker Image](#docker-image)\n* [–ó–∞–≤–∏—Å–º–æ—Å—Ç–∏](#configuration)\n* [–í—ã–≤–æ–¥](#output)\n* [–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏](#command-line-options)\n* [–í–∫–ª–∞–¥](#contribution)\n* [–ß–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã](#frequently-asked-questions)\n* [–õ–∏—Ü–µ–Ω–∑–∏—è](#license)\n\n## Docker –¥–ª—è Cameradar\n\n<p align=\"center\"><img src=\"images/CameradarV4.png\" width=\"70%\"/></p>\n* –£\n–£—Å—Ç–æ–Ω–æ–≤–∫–∞ [docker](https://docs.docker.com/engine/installation/) –Ω–∞ —Å–≤–æ—é –º–∞—à–∏–Ω—É –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–º–∞–Ω–¥—É:\n\n```bash\ndocker run -t ullaakut/cameradar -t <target> <other command-line options>\n```\n\n[–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏](#command-line-options).\n\n–ü—Ä–∏–º–µ—Ä: `docker run -t ullaakut/cameradar -t 192.168.100.0/24` –±—É–¥–µ—Ç —Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Ä—Ç—ã 554, 5554 –∏ 8554 —Ö–æ—Å—Ç–æ–≤ –≤ –ø–æ–¥—Å–µ—Ç–∏ 192.168.100.0/24 –∏ –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã–µ RTSP-stream –∏ –≤—ã–≤–æ–¥–∏—Ç—å –∂—É—Ä–Ω–∞–ª –æ—Ç–ª–∞–¥–∫–∏.\n*YOUR_TARGET –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–¥—Å–µ—Ç—å—é (–Ω–∞–ø—Ä–∏–º–µ—Ä: 172.16.100.0/24), IP (–Ω–∞–ø—Ä–∏–º–µ—Ä: 172.16.100.10) –∏–ª–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º IPs (–Ω–∞–ø—Ä–∏–º–µ—Ä: 172.16.100.10-20).\n* –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å —Ç–æ—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è nmap –≤ –≤–∏–¥–µ XML —Ñ–∞–π–ª–∞, –≤—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å `-v /your/path:/tmp/cameradar_scan.xml` –≤ –∫–æ–º–∞–Ω–¥—É docker run, –ø–µ—Ä–µ–¥ `ullaakut/cameradar`.\n* –ï—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ `-r` –∏ `-c` –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è –≤–∞—à–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Å–ª–æ–≤–∞—Ä–µ–π, —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—ã —Ç–∞–∫–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ  –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏—Ö –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä docker. –ü—Ä–∏–º–µ—Ä: `docker run -t -v /path/to/dictionaries/:/tmp/ ullaakut/cameradar -r /tmp/myroutes -c /tmp/mycredentials.json -t mytarget`.\n\n## –ë–∏–Ω–∞—Ä–Ω–∞—è —É—Å—Ç–æ–Ω–æ–≤–∫–∞\n–†–µ—à–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ Camader –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ docker.\n\n\n\n**WARNING**: –ë–∏–Ω–∞—Ä–Ω–∞—è —É—Å—Ç–Ω–æ–≤–∫–∞ **–ù–ï –ë–£–î–ï–¢ –†–ê–ë–û–¢–ê–¢–¨** –¥–ª—è –∫–∞–º–µ—Ä, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç **DIGEST AUTHENTICATION** [–µ—Å–ª–∏ –≤–∞—à–∞ –≤–µ—Ä—Å–∏—è `curl` —Å—Ç–∞—Ä—à–µ `7.64.0`](https://github.com/Ullaakut/cameradar/pull/252), —Ç–æ —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, —Ç–∞–∫ –∏ –µ—Å—Ç—å. –î–æ–ø–æ–ª–Ω–∏–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è [this response on the subject from the author of curl](https://stackoverflow.com/a/59778142/4145098).\n\n### –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏\n\n* `go` (> `1.10`)\n* `libcurl` –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ (**[version has to be <7.66.0](https://github.com/Ullaakut/cameradar/issues/247)**)\n* –î–ª—è apt: `apt install libcurl4-openssl-dev`\n\n### –≠—Ç–∞–ø—ã —É—Å—Ç–æ–Ω–æ–≤–∫–∏\n\n1. `go install github.com/Ullaakut/cameradar/v5/cmd/cameradar@latest`\n\n–ë–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª `cameradar` –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∑–¥–µ—Å—å `$GOPATH/bin` –∏ –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é. –û–ø—Ü–∏–∏ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏  [–∑–¥–µ—Å—å](#command-line-options).\n\n## –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è \n\n–ü–æ—Ä—Ç **RTSP, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ –∫–∞–º–µ—Ä, 554**, –ø–æ—ç—Ç–æ–º—É —É–∫–∞–∑—ã–≤–∞–µ–º  554 –≤ –∫–∞—á–µ—Å—Ç–≤–µ –æ–¥–Ω–æ–≥–æ –∏–∑ —Å–∫–∞–Ω–∏—Ä—É–µ–º—ã—Ö –ø–æ—Ä—Ç–æ–≤. –ï—Å–ª–∏ –Ω–µ –ø—Ä–æ–ø–∏—Å–∞—Ç—å –ø–æ—Ä—Ç—ã –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ cameradar, –æ–Ω–æ –±—É–¥–µ—Ç –∏—Å–∫–∞—Ç—å –ø–æ—Ä—Ç—ã 554, 5554 –∏ 8554.\n\n`docker run -t --net=host ullaakut/cameradar -p \"18554,19000-19010\" -t localhost`  –±—É–¥–µ—Ç —Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Ä—Ç—ã `18554`, –∏ –¥–∏–∞–ø–∞–∑–æ–Ω –ø–æ—Ä—Ç–æ–≤ –º–µ–∂–¥—É `19000` –∏ `19010` –Ω–∞ `localhost`.\n\n–í—ã **–º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–≤–æ–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –¥–ª—è —Å–ª–æ–≤–∞—Ä–µ–π —É—á–µ—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ –º–∞—Ä—à—Ä—É—Ç–æ–≤**, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –¥–ª—è –∞—Ç–∞–∫–∏ –Ω–∞ –∫–∞–º–µ—Ä—ã, –Ω–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π Cameradar —É–∂–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –≤–∞–º —Ö–æ—Ä–æ—à—É—é –±–∞–∑—É, –∫–æ—Ç–æ—Ä–∞—è —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ–º –∫–∞–º–µ—Ä, –≤ –ø–∞–ø–∫–µ `/dictionaries`.\n\n```bash\ndocker run -t -v /my/folder/with/dictionaries:/tmp/dictionaries \\\nullaakut/cameradar \\\n-r \"/tmp/dictionaries/my_routes\" \\\n-c \"/tmp/dictionaries/my_credentials.json\" \\\n-t 172.19.124.0/24\n```\n\n–≠—Ç–æ –ø–æ–º–µ—Å—Ç–∏—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤–∞—à–µ–π –ø–∞–ø–∫–∏ —Å–æ —Å–ª–æ–≤–∞—Ä—è–º–∏ –≤ –æ–±—Ä–∞–∑ –¥–æ–∫–µ—Ä–∞ –∏ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –¥–ª—è –ø–µ—Ä–µ–±–æ—Ä–∞ —Å–ª–æ–≤–∞—Ä—è, –≤–º–µ—Å—Ç–æ —Å–ª–æ–≤–∞—Ä–µ–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ cameradar.\n\n## –î–æ—Å—Ç—É–ø –∫–∞–º–µ—Ä—ã \n\n–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å [VLC Media Playe](http://www.videolan.org/vlc/), —É –≤–∞—Å –µ—Å—Ç—å  –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–ª–∏ –∫–æ–º–∞–Ω–¥–Ω—É—é —Å—Ç—Ä–æ–∫—É –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ø–æ—Ç–æ–∫—É RTSP, –¥–ª—è —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —ç—Ç–æ—Ç —Ñ–æ—Ä–º–∞—Ç `rtsp://username:password@address:port/route`.\n\n## –û–ø—Ü–∏–∏ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ \n\n* ** \"-t, --targets \"**: –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–µ–ª—å.–¶–µ–ª—å—é –º–æ–∂–µ—Ç –±—ã—Ç—å —Ñ–∞–π–ª (—Å–º. [–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—é —Ñ–∞–π–ª–∞](#format-input-file)), IP, –¥–∏–∞–ø–∞–∑–æ–Ω IP, –ø–æ–¥—Å–µ—Ç—å –∏–ª–∏ –∏—Ö –∫–æ–º–±–∏–Ω–∞—Ü–∏—è. –ü—Ä–∏–º–µ—Ä: `--targets=\"192.168.1.72,192.168.1.74\"`\n* ** \"-p, --ports \"**: (–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: `554,5554,8554`) –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –ø–æ—Ä—Ç—ã.\n* ** \"-s, --scan-speed \"**: (–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: `4`) –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è nmap –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏–ª–∏ —Ç–æ—á–Ω–æ—Å—Ç–∏. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–º–µ–Ω—å—à–∏—Ç—å —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –µ—Å–ª–∏ –≤—ã –ø—ã—Ç–∞–µ—Ç–µ—Å—å —Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—É—é –∏ –º–µ–¥–ª–µ–Ω–Ω—É—é —Å–µ—Ç—å, –∏–ª–∏ —É–≤–µ–ª–∏—á–∏—Ç—å –µ–≥–æ, –µ—Å–ª–∏ –≤—ã —Ä–∞–±–æ—Ç–∞–µ—Ç–µ –≤ –æ—á–µ–Ω—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–π –∏ –Ω–∞–¥–µ–∂–Ω–æ–π —Å–µ—Ç–∏. –í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ  –Ω–∏–∑–∫–∏–º, —á—Ç–æ–±—ã  —É–º–µ–Ω—à–∏—Ç—å –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ–±–Ω—É—Ä—É–∂–µ–Ω–∏—è. –°–º–æ—Ç—Ä–∏—Ç–µ [–∑–¥–µ—Å—å –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —à–∞–±–ª–æ–Ω–∞—Ö —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ nmap] (https://nmap.org/book/man-performance.html).\n* ** \"-I, --attack-interval \"**: (–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: `0ms`) –ó–∞–¥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –ø–æ—Å–ª–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –ø–æ–ø—ã—Ç–∫–∞ –∞—Ç–∞–∫–∏ –±–µ–∑ –æ—Ç–≤–µ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–µ–∫—Ä–∞—Ç–∏—Ç—å—Å—è. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–≤–µ–ª–∏—á–∏—Ç—å –µ–≥–æ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã—Ö –∏ –º–µ–¥–ª–µ–Ω–Ω—ã—Ö —Å–µ—Ç–µ–π –∏–ª–∏ —É–º–µ–Ω—å—à–∏—Ç—å –≤ –±—ã—Å—Ç—Ä—ã—Ö –∏ –Ω–∞–¥–µ–∂–Ω—ã—Ö —Å–µ—Ç—è—Ö.\n* ** \"-T, --timeout \"**: (–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: `2000 –º—Å`) –ó–∞–¥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∞–π–º-–∞—É—Ç–∞, –ø–æ—Å–ª–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –ø–æ–ø—ã—Ç–∫–∞ –∞—Ç–∞–∫–∏ –±–µ–∑ –æ—Ç–≤–µ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–µ–∫—Ä–∞—Ç–∏—Ç—å—Å—è. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–≤–µ–ª–∏—á–∏—Ç—å —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã—Ö –∏ –º–µ–¥–ª–µ–Ω–Ω—ã—Ö —Å–µ—Ç–µ–π –∏–ª–∏ —É–º–µ–Ω—å—à–∏—Ç—å –µ–≥–æ –≤ –±—ã—Å—Ç—Ä—ã—Ö –∏ –Ω–∞–¥–µ–∂–Ω—ã—Ö —Å–µ—Ç—è—Ö.\n* ** \"-r, --custom-routes \"**: (–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: `<CAMERADAR_GOPATH>/dictionaries/routes`) –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—É—Ç—å –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º—É —Å–ª–æ–≤–∞—Ä—é –¥–ª—è –º–∞—Ä—à—Ä—É—Ç–æ–≤.\n* ** \"-c, --custom-credentials \"**: (–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: `<CAMERADAR_GOPATH>/dictionaries/credentials.json`) –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—É—Ç—å –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º—É —Å–ª–æ–≤–∞—Ä—é –¥–ª—è —É—á–µ—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö\n* ** \"-o, --nmap-output \"**: (–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: `/tmp/cameradar_scan.xml`) —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É—Ç—å –≤—ã–≤–æ–¥–∞ nmap.\n* **\"-d, --debug \"**: –í–∫–ª—é—á–∞–µ–º –∂—É—Ä–Ω–∞–ª—ã –æ—Ç–ª–∞–¥–∫–∏\n* **\"-v, --verbose \"**: –í–∫–ª—é—á–∞–µ–º  –∂—É—Ä–Ω–∞–ª—ã curl (–Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–ª—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)\n* **\"-h \"**: –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é\n\n## –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ \n\n–§–∞–π–ª –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å IP-–∞–¥—Ä–µ—Å–∞, –∏–º–µ–Ω–∞ —Ö–æ—Å—Ç–æ–≤, –¥–∏–∞–ø–∞–∑–æ–Ω—ã IP-–∞–¥—Ä–µ—Å–æ–≤ –∏ –ø–æ–¥—Å–µ—Ç–∏, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–µ –Ω–∞ —Å—Ç—Ä–æ–∫–∏. –ù–∞–ø—Ä–∏–º–µ—Ä:\n\n```text\n0.0.0.0\nlocalhost\n192.17.0.0/16\n192.168.1.140-255\n192.168.2-3.0-255\n```\n\n## –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å—Ä–µ–¥—ã\n\n### `CAMERADAR_TARGET`\n\n–≠—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è  –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –∏ —É–∫–∞–∑—ã–≤–∞–µ—Ç —Ü–µ–ª—å, –∫–æ—Ç–æ—Ä—É—é cameradar –¥–æ–ª–∂–µ–Ω —Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –∏ –ø—ã—Ç–∞—Ç—å—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –ø–æ—Ç–æ–∫–∞–º RTSP.\n\n–ù–∞–ø—Ä–∏–º–µ—Ä:\n\n* `172.16.100.0/24`\n* `192.168.1.1`\n* `localhost`\n* `192.168.1.140-255`\n* `192.168.2-3.0-255`\n\n### `CAMERADAR_PORTS`\n\n–≠—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è,–Ω—É–∂–Ω–∞ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–± —É–∫–∞–∑–∞—Ç—å —Å–∫–∞–Ω–∏—Ä—É–µ–º—ã–µ –ø–æ—Ä—Ç—ã \n\n–ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é  `554,5554,8554`\n\n–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –Ω–µ –∏–∑–º–µ–Ω—è—Ç—å –∏—Ö, –∫—Ä–æ–º–µ —Å–ª—É—á–∞–µ–≤, –∫–æ–≥–¥–∞ –≤—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ –∫–∞–º–µ—Ä—ã –±—ã–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –Ω–∞ –ø–µ—Ä–µ–¥–∞—á—É RTSP —á–µ—Ä–µ–∑ –¥—Ä—É–≥–æ–π –ø–æ—Ä—Ç. 99,9% –∫–∞–º–µ—Ä –ø–µ—Ä–µ–¥–∞—é—Ç –ø–æ—Ç–æ–∫ —á–µ—Ä–µ–∑ —ç—Ç–∏ –ø–æ—Ä—Ç—ã.\n\n### `CAMERADAR_NMAP_OUTPUT_FILE`\n\n–≠—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–π –∏ –ø–æ–∑–≤–æ–ª—è–µ—Ç —É–∫–∞–∑–∞—Ç—å, –≤ –∫–∞–∫–æ–π —Ñ–∞–π–ª nmap –±—É–¥–µ—Ç –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å —Å–≤–æ–π –≤—ã–≤–æ–¥.\n\n–ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: `/tmp/cameradar_scan.xml`\n\n–≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω–æ, —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–∞–º–æ—Ç—è—Ç–µ–ª—å–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤, –µ—Å–ª–∏ –≤—ã –Ω–µ —Ö–æ—Ç–∏—Ç–µ, —á—Ç–æ–±—ã –æ–Ω –∑–∞–ø–∏—Å—ã–≤–∞–ª –¥–∞–Ω–Ω—ã–µ –≤ –≤–∞—à—É –ø–∞–ø–∫—É `/tmp`, –∏–ª–∏ –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ñ—É–Ω–∫—Ü–∏—é RunNmap –≤ cameradar, –∏ –¥–µ–ª–∞—Ç—å –µ–µ —Ä–∞–∑–±–æ—Ä –≤—Ä—É—á–Ω—É—é.\n\n### `CAMERADAR_CUSTOM_ROUTES`, `CAMERADAR_CUSTOM_CREDENTIALS`\n\n–≠—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —è–≤–ª—è—é—Ç—Å—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º–∏ –∏ –ø–æ–∑–≤–æ–ª—è—é—Ç –∑–∞–º–µ–Ω–∏—Ç—å —Å–ª–æ–≤–∞—Ä–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ, –≠—Ç–æ –Ω—É–∂–Ω–æ –¥–ª—è –ø–µ—Ä–µ–±–æ—Ä–∞ –ø–æ —Å–ª–æ–≤–∞—Ä—é.\n\n–ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: `<CAMERADAR_GOPATH>/dictionaries/routes` and `<CAMERADAR_GOPATH>/dictionaries/credentials.json`\n\n### `CAMERADAR_SCAN_SPEED`\n\n–≠—Ç–∞ –æ–ø—Ü–∏–∞–Ω–∞–ª—å–Ω–∞—è  –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –ø–æ–∑–≤–æ–ª—è–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏  –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è nmap –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ —Ç–æ—á–Ω–æ—Å—Ç–∏. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–º–µ–Ω—å—à–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, –µ—Å–ª–∏ –≤—ã –ø—ã—Ç–∞–µ—Ç–µ—Å—å —Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—É—é –∏ –º–µ–¥–ª–µ–Ω–Ω—É—é —Å–µ—Ç—å, –∏–ª–∏ —É–≤–µ–ª–∏—á–∏—Ç—å, –µ—Å–ª–∏ —Å–µ—Ç—å –±—ã—Å—Ç—Ä–∞—è –∏ –Ω–∞–¥–µ–∂–Ω–∞—è. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–≤–µ–¥–µ–Ω–∏—è –æ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —à–∞–±–ª–æ–Ω–∞—Ö nmap —Å–º–æ—Ç—Ä–µ—Ç—å [–∑–¥–µ—Å—å](https://nmap.org/book/man-performance.html).\n\n–ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: `4`\n\n### `CAMERADAR_ATTACK_INTERVAL`\n\n–≠—Ç–∞ –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –ø–æ–∑–≤–æ–ª—è–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å `custom interval` –º–µ–∂–¥—É –∫–∞–∂–¥–æ–π –∞—Ç–∞–∫–æ–π, —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∞—Ç—å—Å—è –Ω–µ–∑–∞–º–µ—Ç–Ω—ã–º. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–≤–µ–ª–∏—á–∏–≤–∞—Ç—å –µ–≥–æ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å–µ—Ç–∏, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞—â–∏—â–µ–Ω–∞ –æ—Ç –∞—Ç–∞–∫ –º–µ—Ç–æ–¥–æ–º –ø–µ—Ä–µ–±–æ—Ä–∞. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –∞—Ç–∞–∫–∏ –∫–∞–∫ –º–æ–∂–Ω–æ –±–æ–ª–µ–µ –±—ã—Å—Ç—Ä—ã–º–∏.\n\n–ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: `0ms`\n\n### `CAMERADAR_TIMEOUT`\n\n–≠—Ç–∞ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–∞–µ—Ç –≤–æ–∑–º–æ–¥–∂–Ω–æ—Å—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∞–π–º-–∞—É—Ç–∞, –ø–æ –∏—Å—Ç–µ—á–µ–Ω–∏–∏ –∫–æ—Ç–æ—Ä–æ–≥–æ –ø–æ–ø—ã—Ç–∫–∞ –∞—Ç–∞–∫–∏ –±–µ–∑ –æ—Ç–≤–µ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–µ–∫—Ä–∞—Ç–∏—Ç—å—Å—è. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–≤–µ–ª–∏—á–∏—Ç—å —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã—Ö –∏ –º–µ–¥–ª–µ–Ω–Ω—ã—Ö —Å–µ—Ç–µ–π –∏–ª–∏ —É–º–µ–Ω—å—à–∏—Ç—å –µ–≥–æ –≤ –±—ã—Å—Ç—Ä—ã—Ö –∏ –Ω–∞–¥–µ–∂–Ω—ã—Ö —Å–µ—Ç—è—Ö.\n\n–ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: `2000ms`\n\n### `CAMERADAR_LOGGING`\n\n–≠—Ç–∞ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–∞–º –≤–∫–ª—é—á–∏—Ç—å –±–æ–ª–µ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –≤—ã–≤–æ–¥, —á—Ç–æ–±—ã –∏–º–µ—Ç—å –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ—Ü–µ—Å—Å–∞—Ö.\n\n–û–Ω–∞ –±—É–¥–µ—Ç –≤—ã–≤–æ–¥–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã nmap, –∑–∞–ø—Ä–æ—Å—ã cURL –∏ —Ç.–¥.\n\n–ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: `false`\n\n## –í–∫–ª–∞–¥\n\n### –°–±–æ—Ä–∫–∞ \n\n#### Docker build\n\n–ß—Ç–æ–±—ã —Å–æ–±—Ä–∞—Ç—å –æ–±—Ä–∞–∑ –¥–æ–∫–µ—Ä–∞, –ø—Ä–æ—Å—Ç–æ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É `docker build . -t cameradar` –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞.\n\n–í–∞—à–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –±—É–¥–µ—Ç –Ω–∞–∑—ã–≤–∞—Ç—å—Å—è `cameradar`, –∞ –ù–ï `ullaakut/cameradar`.\n\n#### –ü—Ä–∏—Å—Ç—É–ø–∏–º –∫ —Å–±–æ—Ä–∫–µ \n\n1. `go get github.com/Ullaakut/cameradar`\n2. `cd $GOPATH/src/github.com/Ullaakut/cameradar`\n3. `cd cmd/cameradar`\n4. `go install`\n\n–ë–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª cameradar —Ç–µ–ø–µ—Ä—å –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ `$GOPATH/bin/cameradar`.\n\n## –ß–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã\n\n> Cameradar –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç –Ω–µ –æ–¥–Ω–æ–π –∫–∞–º–µ—Ä—ã!\n\n–≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ª–∏–±–æ –≤–∞—à–∏ –∫–∞–º–µ—Ä—ã –Ω–µ –ø–µ—Ä–µ–¥–∞—é—Ç –ø–æ—Ç–æ–∫ –≤ RTSP, –ª–∏–±–æ –∏—Ö –Ω–µ—Ç –Ω–∞ –æ–±—ä–µ–∫—Ç–µ, –∫–æ—Ç–æ—Ä—ã–π –≤—ã —Å–∫–∞–Ω–∏—Ä—É–µ—Ç–µ. –í –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —Å–ª—É—á–∞–µ–≤ –∫–∞–º–µ—Ä—ã –≤–∏–¥–µ–æ–Ω–∞–±–ª—é–¥–µ–Ω–∏—è –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ —á–∞—Å—Ç–Ω–æ–π –ø–æ–¥—Å–µ—Ç–∏, –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –æ—Ç –ò–Ω—Ç–µ—Ä–Ω–µ—Ç–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–ø—Ü–∏—é `-t` –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è —Ü–µ–ª–∏. –ï—Å–ª–∏ –≤—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ –≤—Å–µ —Å–¥–µ–ª–∞–ª–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ, –Ω–æ —ç—Ç–æ –≤—Å–µ —Ä–∞–≤–Ω–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–æ–±–ª–µ–º—É —Å –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ, –∫ –∫–æ—Ç–æ—Ä–æ–º—É –≤—ã –ø—ã—Ç–∞–µ—Ç–µ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø.\n\n> Cameradar –Ω–∞—à–µ–ª –º–æ–∏ –∫–∞–º–µ—Ä—ã, –Ω–æ –Ω–µ –º–æ–∂–µ—Ç –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –Ω–∏–º \n\n–í–æ–∑–º–æ–∂–Ω–æ, –≤–∞—à–∏ –∫–∞–º–µ—Ä—ã –±—ã–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã, –∏ —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ / URL –±—ã–ª–∏ –∏–∑–º–µ–Ω–µ–Ω—ã. Cameradar —Ç–æ–ª—å–∫–æ —É–≥–∞–¥—ã–≤–∞–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É—è –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å. –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–≤–æ–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å–ª–æ–≤–∞—Ä–∏, –≤ –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å –≤–∞—à–∏ —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏ –º–∞—Ä—à—Ä—É—Ç—ã RTSP. –î–ª—è —ç—Ç–æ–≥–æ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ, –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç [configuration](#configuration). –¢–∞–∫–∂–µ, –≤–æ–∑–º–æ–∂–Ω–æ, —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤–∞—à–µ–π –∫–∞–º–µ—Ä—ã –µ—â–µ –Ω–µ –∏–∑–≤–µ—Å—Ç–Ω—ã, –≤ —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ –≤—ã –∏—Ö –Ω–∞–π–¥–µ—Ç–µ, –±—ã–ª–æ –±—ã –æ—á–µ–Ω—å —Ö–æ—Ä–æ—à–æ –¥–æ–±–∞–≤–∏—Ç—å –∏—Ö –≤ —Å–ª–æ–≤–∞—Ä–∏ Cameradar, —á—Ç–æ–±—ã –ø–æ–º–æ—á—å –¥—Ä—É–≥–∏–º –ª—é–¥—è–º –≤ –±—É–¥—É—â–µ–º.\n\n> –ß—Ç–æ —Å–ª—É—á–∏–ª–æ—Å—å —Å –≤–µ—Ä—Å–∏–µ–π –Ω–∞  C++?\n\n–í—ã –≤—Å–µ –µ—â–µ –º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ –µ–≥–æ –ø–æ–¥ —Ç–µ–≥–æ–º 1.1.4 –≤ —ç—Ç–æ–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏, –æ–¥–Ω–∞–∫–æ –æ–Ω –±—ã–ª –º–µ–¥–ª–µ–Ω–Ω–µ–µ –∏ –º–µ–Ω–µ–µ —Å—Ç–∞–±–∏–ª–µ–Ω, —á–µ–º —Ç–µ–∫—É—â–∞—è –≤–µ—Ä—Å–∏—è, –Ω–∞–ø–∏—Å–∞–Ω–Ω–∞—è –Ω–∞ Golang. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–µ –Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è.\n\n> –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É Cameradar –¥–ª—è –º–æ–µ–≥–æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞?\n\n–°–º–æ—Ç—Ä–∏—Ç–µ –ø—Ä–∏–º–µ—Ä –≤ `/cmd/cameradar`. –í–∞–º –ø—Ä–æ—Å—Ç–æ –Ω—É–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å `go get github.com/Ullaakut/cameradar` –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–∞–∫–µ—Ç `cameradar` –≤ —Å–≤–æ–µ–º –∫–æ–¥–µ. –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –Ω–∞ [godoc](https://godoc.org/github.com/ullaakut/cameradar).\n\n> –Ø –ø–æ—á–µ–º—É-—Ç–æ —Ö–æ—á—É –ø—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π localhost, –∞ –æ–Ω –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç! \n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–ª–∞–≥ `--net=host` –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –æ–±—Ä–∞–∑–∞ cameradar, –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª, –≤—ã–ø–æ–ª–Ω–∏–≤ –∫–æ–º–∞–Ω–¥—É `go run cameradar/cameradar.go` –∏–ª–∏ [—É—Å—Ç–∞–Ω–æ–≤–∏–≤ –µ–≥–æ](#go-build).\n\n> –Ø –Ω–µ –≤–∏–∂—É —Ü–≤–µ—Ç–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ :(\n\n–í–µ—Ä–æ—è—Ç–Ω–µ–µ –≤—ã  –∑–∞–±—ã–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–ª–∞–≥ `-t` –ø–µ—Ä–µ–¥ `ullaakut/cameradar` –≤ –≤–∞—à–µ–π –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ. –≠—Ç–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è  -tty –¥–ª—è cameradar, —á—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –µ–º—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ü–≤–µ—Ç–∞.\n\n> –£ –º–µ–Ω—è –Ω–µ—Ç –∫–∞–º–µ—Ä—ã, –Ω–æ —è —Ö–æ—Ç–µ–ª –±—ã –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å Cameradar!\n\n–ü—Ä–æ—Å—Ç–æ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–æ–º–∞–Ω–¥–æ–π `docker run -p 8554:8554 -e RTSP_USERNAME=admin -e RTSP_PASSWORD=12345 -e RTSP_PORT=8554 ullaakut/rtspatt` –∏ –∑–∞–ø—É—Å—Ç–∏—Ç–µ cameradar, –∏ –æ–Ω –¥–æ–ª–∂–µ–Ω –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —á—Ç–æ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è - admin, –∞ –ø–∞—Ä–æ–ª—å - 12345. –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —ç—Ç–æ —Å –ª—é–±—ã–º–∏ —É—á–µ—Ç–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–∏—Ö –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ [–∑–¥–µ—Å—å](dictionaries/credentials.json)).\n\n> –ö–∞–∫–∏–µ —Ç–∏–ø—ã –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç Cameradar?\n\nCameradar –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–∫ –±–∞–∑–æ–≤—É—é, —Ç–∞–∫ –∏ –¥–∞–π–¥–∂–µ—Å—Ç-–∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é.\n\n\n## –ü—Ä–∏–º–µ—Ä—ã \n\n>> –ó–∞–ø—É—Å–∫ cameradar –Ω–∞ –≤–∞—à–µ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–π –º–∞—à–∏–Ω–µ –¥–ª—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ—Ä—Ç–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é\n\n`docker run --net=host -t ullaakut/cameradar -t localhost`\n\n> –ó–∞–ø—É—Å–∫ cameradar —Å –≤—Ö–æ–¥–Ω—ã–º —Ñ–∞–π–ª–æ–º, –≤–∫–ª—é—á–µ–Ω–∏–µ –∂—É—Ä–Ω–∞–ª–æ–≤ –Ω–∞ –ø–æ—Ä—Ç—É 8554\n\n`docker run -v /tmp:/tmp --net=host -t ullaakut/cameradar -t /tmp/test.txt -p 8554`\n\n> –ó–∞–ø—É—Å–∫ cameradar –≤ –ø–æ–¥—Å–µ—Ç–∏ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º–∏ —Å–ª–æ–≤–∞—Ä—è–º–∏, –Ω–∞ –ø–æ—Ä—Ç–∞—Ö 554, 5554 –∏ 8554\n\n`docker run -v /tmp:/tmp --net=host -t ullaakut/cameradar -t 192.168.0.0/24 --custom-credentials=\"/tmp/dictionaries/credentials.json\" --custom-routes=\"/tmp/dictionaries/routes\" -p 554,5554,8554`.\n\n## –õ–∏—Ü–µ–Ω–∑–∏—è \n\nCopyright 2023 Ullaakut\n\n–ù–∞—Å—Ç–æ—è—â–∏–º –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –ª—é–±–æ–º—É –ª–∏—Ü—É, –ø–æ–ª—É—á–∏–≤—à–µ–º—É –∫–æ–ø–∏—é\n–¥–∞–Ω–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –∏ —Å–æ–ø—É—Ç—Å—Ç–≤—É—é—â–∏—Ö —Ñ–∞–π–ª–æ–≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ (\"–ü—Ä–æ–≥—Ä–∞–º–º–Ω–æ–µ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ\"), —Å–æ–≤–µ—Ä—à–∞—Ç—å —Å–¥–µ–ª–∫–∏ —Å  –ü—Ä–æ–≥—Ä–∞–º–º–Ω—ã–º –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ–º –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π, –≤–∫–ª—é—á–∞—è, –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è, –ø—Ä–∞–≤–∞\n–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å, –∏–∑–º–µ–Ω—è—Ç—å, –æ–±—ä–µ–¥–∏–Ω—è—Ç—å, –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å, —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—Ç—å, –≤—ã–¥–∞–≤–∞—Ç—å —Å—É–±–ª–∏—Ü–µ–Ω–∑–∏–∏ –∏/–∏–ª–∏ –ø—Ä–æ–¥–∞–≤–∞—Ç—å\n–∫–æ–ø–∏–∏ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è, –∞ —Ç–∞–∫–∂–µ —Ä–∞–∑—Ä–µ—à–∞—Ç—å –ª–∏—Ü–∞–º, –∫–æ—Ç–æ—Ä—ã–º –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –ü—Ä–æ–≥—Ä–∞–º–º–Ω–æ–µ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ\n–¥–µ–ª–∞—Ç—å —ç—Ç–æ, –ø—Ä–∏ —Å–æ–±–ª—é–¥–µ–Ω–∏–∏ —Å–ª–µ–¥—É—é—â–∏—Ö —É—Å–ª–æ–≤–∏–π:\n\n–í—ã—à–µ—É–∫–∞–∑–∞–Ω–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –∞–≤—Ç–æ—Ä—Å–∫–æ–º –ø—Ä–∞–≤–µ –∏ –¥–∞–Ω–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∫–ª—é—á–µ–Ω—ã –≤–æ –≤—Å–µ\n–∫–æ–ø–∏—è—Ö –∏–ª–∏ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —á–∞—Å—Ç—è—Ö –ü—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è.\n\n–ü–†–û–ì–†–ê–ú–ú–ù–û–ï –û–ë–ï–°–ü–ï–ß–ï–ù–ò–ï –ü–†–ï–î–û–°–¢–ê–í–õ–Ø–ï–¢–°–Ø \"–ö–ê–ö –ï–°–¢–¨\", –ë–ï–ó –ö–ê–ö–ò–•-–õ–ò–ë–û –ì–ê–†–ê–ù–¢–ò–ô, –Ø–í–ù–´–• –ò–õ–ò\n–ü–û–î–†–ê–ó–£–ú–ï–í–ê–ï–ú–´–•, –í–ö–õ–Æ–ß–ê–Ø, –ù–û –ù–ï –û–ì–†–ê–ù–ò–ß–ò–í–ê–Ø–°–¨ –ì–ê–†–ê–ù–¢–ò–Ø–ú–ò –¢–û–í–ê–†–ù–û–ì–û –°–û–°–¢–û–Ø–ù–ò–Ø,\n–ü–†–ò–ì–û–î–ù–û–°–¢–ò –î–õ–Ø –ö–û–ù–ö–†–ï–¢–ù–û–ô –¶–ï–õ–ò –ò –ù–ï–ù–ê–†–£–®–ï–ù–ò–Ø –ü–†–ê–í. –ù–ò –ü–†–ò –ö–ê–ö–ò–• –û–ë–°–¢–û–Ø–¢–ï–õ–¨–°–¢–í–ê–•\n–ê–í–¢–û–†–´ –ò–õ–ò –í–õ–ê–î–ï–õ–¨–¶–´ –ê–í–¢–û–†–°–ö–ò–• –ü–†–ê–í –ù–ï –ù–ï–°–£–¢ –û–¢–í–ï–¢–°–¢–í–ï–ù–ù–û–°–¢–ò –ó–ê –õ–Æ–ë–´–ï –ü–†–ï–¢–ï–ù–ó–ò–ò, –£–ë–´–¢–ö–ò –ò–õ–ò –î–†–£–ì–£–Æ\n–û–¢–í–ï–¢–°–¢–í–ï–ù–ù–û–°–¢–¨, –ë–£–î–¨ –¢–û –í –†–ê–ú–ö–ê–• –î–û–ì–û–í–û–†–ù–û–ì–û, –î–ï–õ–ò–ö–¢–ù–û–ì–û –ò–õ–ò –ò–ù–û–ì–û –ò–°–ö–ê, –í–û–ó–ù–ò–ö–ê–Æ–©–ï–ì–û\n–ò–ó, –í –†–ï–ó–£–õ–¨–¢–ê–¢–ï –ò–õ–ò –í –°–í–Ø–ó–ò –° –ü–†–û–ì–†–ê–ú–ú–ù–´–ú –û–ë–ï–°–ü–ï–ß–ï–ù–ò–ï–ú –ò–õ–ò –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï–ú –ò–õ–ò –ò–ù–´–ú–ò\n–ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï–ú –ò–õ–ò –î–†–£–ì–ò–ú–ò –î–ï–ô–°–¢–í–ò–Ø–ú–ò –° –ü–†–û–ì–†–ê–ú–ú–ù–´–ú –û–ë–ï–°–ü–ï–ß–ï–ù–ò–ï–ú."
        },
        {
          "name": "attack.go",
          "type": "blob",
          "size": 10.12890625,
          "content": "package cameradar\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/Ullaakut/go-curl\"\n)\n\n// HTTP responses.\nconst (\n\thttpOK           = 200\n\thttpUnauthorized = 401\n\thttpForbidden    = 403\n\thttpNotFound     = 404\n)\n\n// CURL RTSP request types.\nconst (\n\trtspDescribe = 2\n\trtspSetup    = 4\n)\n\n// Authentication types.\nconst (\n\tauthNone   = 0\n\tauthBasic  = 1\n\tauthDigest = 2\n)\n\n// Route that should never be a constructor default.\nconst dummyRoute = \"/0x8b6c42\"\n\n// Attack attacks the given targets and returns the accessed streams.\nfunc (s *Scanner) Attack(targets []Stream) ([]Stream, error) {\n\tif len(targets) == 0 {\n\t\treturn nil, fmt.Errorf(\"no stream found\")\n\t}\n\n\t// Most cameras will be accessed successfully with these two attacks.\n\ts.term.StartStepf(\"Attacking routes of %d streams\", len(targets))\n\tstreams := s.AttackRoute(targets)\n\n\ts.term.StartStepf(\"Attempting to detect authentication methods of %d streams\", len(targets))\n\tstreams = s.DetectAuthMethods(streams)\n\n\ts.term.StartStepf(\"Attacking credentials of %d streams\", len(targets))\n\tstreams = s.AttackCredentials(streams)\n\n\ts.term.StartStep(\"Validating that streams are accessible\")\n\tstreams = s.ValidateStreams(streams)\n\n\t// But some cameras run GST RTSP Server which prioritizes 401 over 404 contrary to most cameras.\n\t// For these cameras, running another route attack will solve the problem.\n\tfor _, stream := range streams {\n\t\tif !stream.RouteFound || !stream.CredentialsFound || !stream.Available {\n\t\t\ts.term.StartStepf(\"Second round of attacks\")\n\t\t\tstreams = s.AttackRoute(streams)\n\n\t\t\ts.term.StartStep(\"Validating that streams are accessible\")\n\t\t\tstreams = s.ValidateStreams(streams)\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\ts.term.EndStep()\n\n\treturn streams, nil\n}\n\n// ValidateStreams tries to setup the stream to validate whether or not it is available.\nfunc (s *Scanner) ValidateStreams(targets []Stream) []Stream {\n\tfor i := range targets {\n\t\ttargets[i].Available = s.validateStream(targets[i])\n\t\ttime.Sleep(s.attackInterval)\n\t}\n\n\treturn targets\n}\n\n// AttackCredentials attempts to guess the provided targets' credentials using the given\n// dictionary or the default dictionary if none was provided by the user.\nfunc (s *Scanner) AttackCredentials(targets []Stream) []Stream {\n\tresChan := make(chan Stream)\n\tdefer close(resChan)\n\n\tfor i := range targets {\n\t\tgo s.attackCameraCredentials(targets[i], resChan)\n\t}\n\n\tfor range targets {\n\t\tattackResult := <-resChan\n\t\tif attackResult.CredentialsFound {\n\t\t\ttargets = replace(targets, attackResult)\n\t\t}\n\t}\n\n\treturn targets\n}\n\n// AttackRoute attempts to guess the provided targets' streaming routes using the given\n// dictionary or the default dictionary if none was provided by the user.\nfunc (s *Scanner) AttackRoute(targets []Stream) []Stream {\n\tresChan := make(chan Stream)\n\tdefer close(resChan)\n\n\tfor i := range targets {\n\t\tgo s.attackCameraRoute(targets[i], resChan)\n\t}\n\n\tfor range targets {\n\t\tattackResult := <-resChan\n\t\tif attackResult.RouteFound {\n\t\t\ttargets = replace(targets, attackResult)\n\t\t}\n\t}\n\n\treturn targets\n}\n\n// DetectAuthMethods attempts to guess the provided targets' authentication types, between\n// digest, basic auth or none at all.\nfunc (s *Scanner) DetectAuthMethods(targets []Stream) []Stream {\n\tfor i := range targets {\n\t\ttargets[i].AuthenticationType = s.detectAuthMethod(targets[i])\n\t\ttime.Sleep(s.attackInterval)\n\n\t\tvar authMethod string\n\t\tswitch targets[i].AuthenticationType {\n\t\tcase authNone:\n\t\t\tauthMethod = \"no\"\n\t\tcase authBasic:\n\t\t\tauthMethod = \"basic\"\n\t\tcase authDigest:\n\t\t\tauthMethod = \"digest\"\n\t\tdefault:\n\t\t\tauthMethod = \"unknown:\" + string(targets[i].AuthenticationType)\n\t\t}\n\n\t\ts.term.Debugf(\"Stream %s uses %s authentication method\\n\", GetCameraRTSPURL(targets[i]), authMethod)\n\t}\n\n\treturn targets\n}\n\nfunc (s *Scanner) attackCameraCredentials(target Stream, resChan chan<- Stream) {\n\tfor _, username := range s.credentials.Usernames {\n\t\tfor _, password := range s.credentials.Passwords {\n\t\t\tok := s.credAttack(target, username, password)\n\t\t\tif ok {\n\t\t\t\ttarget.CredentialsFound = true\n\t\t\t\ttarget.Username = username\n\t\t\t\ttarget.Password = password\n\t\t\t\tresChan <- target\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(s.attackInterval)\n\t\t}\n\t}\n\n\ttarget.CredentialsFound = false\n\tresChan <- target\n}\n\nfunc (s *Scanner) attackCameraRoute(target Stream, resChan chan<- Stream) {\n\t// If the stream responds positively to the dummy route, it means\n\t// it doesn't require (or respect the RFC) a route and the attack\n\t// can be skipped.\n\tok := s.routeAttack(target, dummyRoute)\n\tif ok {\n\t\ttarget.RouteFound = true\n\t\ttarget.Routes = append(target.Routes, \"/\")\n\t\tresChan <- target\n\t\treturn\n\t}\n\n\t// Otherwise, bruteforce the routes.\n\tfor _, route := range s.routes {\n\t\tok := s.routeAttack(target, route)\n\t\tif ok {\n\t\t\ttarget.RouteFound = true\n\t\t\ttarget.Routes = append(target.Routes, route)\n\t\t}\n\t\ttime.Sleep(s.attackInterval)\n\t}\n\n\tresChan <- target\n}\n\nfunc (s *Scanner) detectAuthMethod(stream Stream) int {\n\tc := s.curl.Duphandle()\n\n\tattackURL := fmt.Sprintf(\n\t\t\"rtsp://%s:%d/%s\",\n\t\tstream.Address,\n\t\tstream.Port,\n\t\tstream.Route(),\n\t)\n\n\ts.setCurlOptions(c)\n\n\t// Send a request to the URL of the stream we want to attack.\n\t_ = c.Setopt(curl.OPT_URL, attackURL)\n\t// Set the RTSP STREAM URI as the stream URL.\n\t_ = c.Setopt(curl.OPT_RTSP_STREAM_URI, attackURL)\n\t_ = c.Setopt(curl.OPT_RTSP_REQUEST, rtspDescribe)\n\n\t// Perform the request.\n\terr := c.Perform()\n\tif err != nil {\n\t\ts.term.Errorf(\"Perform failed for %q (auth %d): %v\", attackURL, stream.AuthenticationType, err)\n\t\treturn -1\n\t}\n\n\tauthType, err := c.Getinfo(curl.INFO_HTTPAUTH_AVAIL)\n\tif err != nil {\n\t\ts.term.Errorf(\"Getinfo failed: %v\", err)\n\t\treturn -1\n\t}\n\n\tif s.debug {\n\t\ts.term.Debugln(\"DESCRIBE\", attackURL, \"RTSP/1.0 >\", authType)\n\t}\n\n\treturn authType.(int)\n}\n\nfunc (s *Scanner) routeAttack(stream Stream, route string) bool {\n\tc := s.curl.Duphandle()\n\n\tattackURL := fmt.Sprintf(\n\t\t\"rtsp://%s:%s@%s:%d/%s\",\n\t\tstream.Username,\n\t\tstream.Password,\n\t\tstream.Address,\n\t\tstream.Port,\n\t\troute,\n\t)\n\n\ts.setCurlOptions(c)\n\n\t// Set proper authentication type.\n\t_ = c.Setopt(curl.OPT_HTTPAUTH, stream.AuthenticationType)\n\t_ = c.Setopt(curl.OPT_USERPWD, fmt.Sprint(stream.Username, \":\", stream.Password))\n\n\t// Send a request to the URL of the stream we want to attack.\n\t_ = c.Setopt(curl.OPT_URL, attackURL)\n\t// Set the RTSP STREAM URI as the stream URL.\n\t_ = c.Setopt(curl.OPT_RTSP_STREAM_URI, attackURL)\n\t_ = c.Setopt(curl.OPT_RTSP_REQUEST, rtspDescribe)\n\n\t// Perform the request.\n\terr := c.Perform()\n\tif err != nil {\n\t\ts.term.Errorf(\"Perform failed for %q (auth %d): %v\", attackURL, stream.AuthenticationType, err)\n\t\treturn false\n\t}\n\n\t// Get return code for the request.\n\trc, err := c.Getinfo(curl.INFO_RESPONSE_CODE)\n\tif err != nil {\n\t\ts.term.Errorf(\"Getinfo failed: %v\", err)\n\t\treturn false\n\t}\n\n\tif s.debug {\n\t\ts.term.Debugln(\"DESCRIBE\", attackURL, \"RTSP/1.0 >\", rc)\n\t}\n\t// If it's a 401 or 403, it means that the credentials are wrong but the route might be okay.\n\t// If it's a 200, the stream is accessed successfully.\n\tif rc == httpOK || rc == httpUnauthorized || rc == httpForbidden {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *Scanner) credAttack(stream Stream, username string, password string) bool {\n\tc := s.curl.Duphandle()\n\n\tattackURL := fmt.Sprintf(\n\t\t\"rtsp://%s:%s@%s:%d/%s\",\n\t\tusername,\n\t\tpassword,\n\t\tstream.Address,\n\t\tstream.Port,\n\t\tstream.Route(),\n\t)\n\n\ts.setCurlOptions(c)\n\n\t// Set proper authentication type.\n\t_ = c.Setopt(curl.OPT_HTTPAUTH, stream.AuthenticationType)\n\t_ = c.Setopt(curl.OPT_USERPWD, fmt.Sprint(username, \":\", password))\n\n\t// Send a request to the URL of the stream we want to attack.\n\t_ = c.Setopt(curl.OPT_URL, attackURL)\n\t// Set the RTSP STREAM URI as the stream URL.\n\t_ = c.Setopt(curl.OPT_RTSP_STREAM_URI, attackURL)\n\t_ = c.Setopt(curl.OPT_RTSP_REQUEST, rtspDescribe)\n\n\t// Perform the request.\n\terr := c.Perform()\n\tif err != nil {\n\t\ts.term.Errorf(\"Perform failed for %q (auth %d): %v\", attackURL, stream.AuthenticationType, err)\n\t\treturn false\n\t}\n\n\t// Get return code for the request.\n\trc, err := c.Getinfo(curl.INFO_RESPONSE_CODE)\n\tif err != nil {\n\t\ts.term.Errorf(\"Getinfo failed: %v\", err)\n\t\treturn false\n\t}\n\n\tif s.debug {\n\t\ts.term.Debugln(\"DESCRIBE\", attackURL, \"RTSP/1.0 >\", rc)\n\t}\n\n\t// If it's a 404, it means that the route is incorrect but the credentials might be okay.\n\t// If it's a 200, the stream is accessed successfully.\n\tif rc == httpOK || rc == httpNotFound {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *Scanner) validateStream(stream Stream) bool {\n\tc := s.curl.Duphandle()\n\n\tattackURL := fmt.Sprintf(\n\t\t\"rtsp://%s:%s@%s:%d/%s\",\n\t\tstream.Username,\n\t\tstream.Password,\n\t\tstream.Address,\n\t\tstream.Port,\n\t\tstream.Route(),\n\t)\n\n\ts.setCurlOptions(c)\n\n\t// Set proper authentication type.\n\t_ = c.Setopt(curl.OPT_HTTPAUTH, stream.AuthenticationType)\n\t_ = c.Setopt(curl.OPT_USERPWD, fmt.Sprint(stream.Username, \":\", stream.Password))\n\n\t// Send a request to the URL of the stream we want to attack.\n\t_ = c.Setopt(curl.OPT_URL, attackURL)\n\t// Set the RTSP STREAM URI as the stream URL.\n\t_ = c.Setopt(curl.OPT_RTSP_STREAM_URI, attackURL)\n\t_ = c.Setopt(curl.OPT_RTSP_REQUEST, rtspSetup)\n\n\t_ = c.Setopt(curl.OPT_RTSP_TRANSPORT, \"RTP/AVP;unicast;client_port=33332-33333\")\n\n\t// Perform the request.\n\terr := c.Perform()\n\tif err != nil {\n\t\ts.term.Errorf(\"Perform failed for %q (auth %d): %v\", attackURL, stream.AuthenticationType, err)\n\t\treturn false\n\t}\n\n\t// Get return code for the request.\n\trc, err := c.Getinfo(curl.INFO_RESPONSE_CODE)\n\tif err != nil {\n\t\ts.term.Errorf(\"Getinfo failed: %v\", err)\n\t\treturn false\n\t}\n\n\tif s.debug {\n\t\ts.term.Debugln(\"SETUP\", attackURL, \"RTSP/1.0 >\", rc)\n\t}\n\n\t// If it's a 200, the stream is accessed successfully.\n\tif rc == httpOK {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *Scanner) setCurlOptions(c Curler) {\n\t// Do not write sdp in stdout\n\t_ = c.Setopt(curl.OPT_WRITEFUNCTION, doNotWrite)\n\t// Do not use signals (would break multithreading).\n\t_ = c.Setopt(curl.OPT_NOSIGNAL, 1)\n\t// Do not send a body in the describe request.\n\t_ = c.Setopt(curl.OPT_NOBODY, 1)\n\t// Set custom timeout.\n\t_ = c.Setopt(curl.OPT_TIMEOUT_MS, int(s.timeout/time.Millisecond))\n\n\t// Enable verbose logs if verbose mode is on.\n\tif s.verbose {\n\t\t_ = c.Setopt(curl.OPT_VERBOSE, 1)\n\t} else {\n\t\t_ = c.Setopt(curl.OPT_VERBOSE, 0)\n\t}\n}\n\n// HACK: See https://stackoverflow.com/questions/3572397/lib-curl-in-c-disable-printing\nfunc doNotWrite([]uint8, interface{}) bool {\n\treturn true\n}\n"
        },
        {
          "name": "attack_test.go",
          "type": "blob",
          "size": 14.8134765625,
          "content": "package cameradar\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/Ullaakut/disgo\"\n\t\"github.com/Ullaakut/go-curl\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\ntype CurlerMock struct {\n\tmock.Mock\n}\n\nfunc (m *CurlerMock) Setopt(opt int, param interface{}) error {\n\targs := m.Called(opt, param)\n\treturn args.Error(0)\n}\n\nfunc (m *CurlerMock) Perform() error {\n\targs := m.Called()\n\treturn args.Error(0)\n}\n\nfunc (m *CurlerMock) Getinfo(info curl.CurlInfo) (interface{}, error) {\n\targs := m.Called(info)\n\treturn args.Int(0), args.Error(1)\n}\n\nfunc (m *CurlerMock) Duphandle() Curler {\n\treturn m\n}\n\nfunc TestAttack(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:  \"fakeDevice\",\n\t\t\tAddress: \"fakeAddress\",\n\t\t\tPort:    1337,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:  \"fakeDevice\",\n\t\t\tAddress: \"differentFakeAddress\",\n\t\t\tPort:    1337,\n\t\t}\n\n\t\tfakeTargets     = []Stream{stream1, stream2}\n\t\tfakeRoutes      = Routes{\"live.sdp\", \"media.amp\"}\n\t\tfakeCredentials = Credentials{\n\t\t\tUsernames: []string{\"admin\", \"root\"},\n\t\t\tPasswords: []string{\"12345\", \"root\"},\n\t\t}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\n\t\tperformErr error\n\n\t\texpectedStreams []Stream\n\t\texpectedErr     error\n\t}{\n\t\t{\n\t\t\tdescription: \"inverted RTSP RFC\",\n\n\t\t\ttargets: fakeTargets,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"attack works\",\n\n\t\t\ttargets: fakeTargets,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"no targets\",\n\n\t\t\ttargets: nil,\n\n\t\t\texpectedStreams: nil,\n\t\t\texpectedErr:     errors.New(\"no stream found\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tif len(test.targets) != 0 {\n\t\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\t\tif test.performErr == nil {\n\t\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(200, nil)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:        disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:        curlerMock,\n\t\t\t\ttimeout:     time.Millisecond,\n\t\t\t\tverbose:     true,\n\t\t\t\tdebug:       true,\n\t\t\t\tcredentials: fakeCredentials,\n\t\t\t\troutes:      fakeRoutes,\n\t\t\t}\n\n\t\t\tresults, err := scanner.Attack(test.targets)\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\n\t\t\tassert.Len(t, results, len(test.expectedStreams))\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestAttackCredentials(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets     = []Stream{stream1, stream2}\n\t\tfakeCredentials = Credentials{\n\t\t\tUsernames: []string{\"admin\", \"root\"},\n\t\t\tPasswords: []string{\"12345\", \"root\"},\n\t\t}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets     []Stream\n\t\tcredentials Credentials\n\t\ttimeout     time.Duration\n\t\tverbose     bool\n\n\t\tstatus int\n\n\t\tperformErr     error\n\t\tgetInfoErr     error\n\t\tinvalidTargets bool\n\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tdescription: \"Credentials found\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\n\t\t\tstatus: 404,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Camera accessed\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\n\t\t\tstatus: 200,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl perform fails\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl getinfo fails\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\n\t\t\tgetInfoErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Verbose mode disabled\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\t\t\tverbose:     false,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Verbose mode enabled\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\t\t\tverbose:     true,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tif !test.invalidTargets {\n\t\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\t\tif test.performErr == nil {\n\t\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, test.getInfoErr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:        disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:        curlerMock,\n\t\t\t\ttimeout:     test.timeout,\n\t\t\t\tverbose:     test.verbose,\n\t\t\t\tdebug:       test.verbose,\n\t\t\t\tcredentials: test.credentials,\n\t\t\t}\n\n\t\t\tresults := scanner.AttackCredentials(test.targets)\n\n\t\t\tassert.Len(t, results, len(test.expectedStreams))\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestAttackRoute(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets = []Stream{stream1, stream2}\n\t\tfakeRoutes  = Routes{\"live.sdp\", \"media.amp\"}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\t\troutes  Routes\n\t\ttimeout time.Duration\n\t\tverbose bool\n\n\t\tstatus int\n\n\t\tperformErr     error\n\t\tgetInfoErr     error\n\t\tinvalidTargets bool\n\n\t\texpectedStreams []Stream\n\t\texpectedErr     error\n\t}{\n\t\t{\n\t\t\tdescription: \"Route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 401,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Camera accessed\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 200,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl perform fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl getinfo fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tgetInfoErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose mode disabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: false,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose mode enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: true,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tif !test.invalidTargets {\n\t\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\t\tif test.performErr == nil {\n\t\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, test.getInfoErr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:    curlerMock,\n\t\t\t\ttimeout: test.timeout,\n\t\t\t\tverbose: test.verbose,\n\t\t\t\tdebug:   test.verbose,\n\t\t\t\troutes:  test.routes,\n\t\t\t}\n\n\t\t\tresults := scanner.AttackRoute(test.targets)\n\n\t\t\tassert.Len(t, results, len(test.expectedStreams))\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestAttackRoute_NoDummyRoute(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets = []Stream{stream1, stream2}\n\t\tfakeRoutes  = Routes{\"live.sdp\", \"media.amp\"}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\t\troutes  Routes\n\t\ttimeout time.Duration\n\t\tverbose bool\n\n\t\tstatus int\n\n\t\texpectedStreams []Stream\n\t\texpectedErr     error\n\t}{\n\t\t{\n\t\t\tdescription: \"Route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 401,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Camera accessed\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 200,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\tcurlerMock.On(\"Perform\").Return(nil)\n\n\t\t\t// 404 on first call to the dummy route.\n\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(404, nil).Once()\n\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, nil)\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:    curlerMock,\n\t\t\t\ttimeout: test.timeout,\n\t\t\t\tverbose: test.verbose,\n\t\t\t\troutes:  test.routes,\n\t\t\t}\n\n\t\t\tresults := scanner.AttackRoute(test.targets)\n\n\t\t\tassert.Len(t, results, len(test.expectedStreams))\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestValidateStreams(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets = []Stream{stream1, stream2}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\t\ttimeout time.Duration\n\t\tverbose bool\n\n\t\tstatus int\n\n\t\tperformErr error\n\t\tgetInfoErr error\n\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tdescription: \"route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 401,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"camera accessed\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 200,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"unavailable stream\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 400,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl perform fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl getinfo fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tgetInfoErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose disabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: false,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: true,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\tif test.performErr == nil {\n\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, test.getInfoErr)\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:    curlerMock,\n\t\t\t\ttimeout: test.timeout,\n\t\t\t\tverbose: test.verbose,\n\t\t\t\tdebug:   test.verbose,\n\t\t\t}\n\n\t\t\tresults := scanner.ValidateStreams(test.targets)\n\n\t\t\tassert.Equal(t, len(test.expectedStreams), len(results))\n\n\t\t\tfor _, expectedStream := range test.expectedStreams {\n\t\t\t\tassert.Contains(t, results, expectedStream)\n\t\t\t}\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestDetectAuthenticationType(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets = []Stream{stream1, stream2}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\t\ttimeout time.Duration\n\t\tverbose bool\n\n\t\tstatus int\n\n\t\tperformErr error\n\t\tgetInfoErr error\n\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tdescription: \"no auth enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 0,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"basic auth enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 1,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"digest auth enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 2,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl getinfo fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tgetInfoErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl perform fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose disabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: false,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: true,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\tif test.performErr == nil {\n\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, test.getInfoErr)\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:    curlerMock,\n\t\t\t\ttimeout: test.timeout,\n\t\t\t\tverbose: test.verbose,\n\t\t\t}\n\n\t\t\tresults := scanner.DetectAuthMethods(test.targets)\n\n\t\t\tassert.Equal(t, len(test.expectedStreams), len(results))\n\n\t\t\tfor _, expectedStream := range test.expectedStreams {\n\t\t\t\tassert.Contains(t, results, expectedStream)\n\t\t\t}\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestDoNotWrite(t *testing.T) {\n\tassert.Equal(t, true, doNotWrite(nil, nil))\n}\n"
        },
        {
          "name": "cameradar.go",
          "type": "blob",
          "size": 0.6025390625,
          "content": "// Package cameradar provides methods to be able to discover and\n// attack RTSP streams easily. RTSP streams are used by most\n// IP Cameras, often for surveillance.\n//\n// A simple example usage of the library can be found in\n// https://github.com/Ullaakut/cameradar/tree/master/cameradar\n//\n// The example usage is complete enough for most users to\n// ignore the library, but for users with specific needs\n// such as creating their own bruteforcing dictionary to\n// access cameras, or running their own network scan, this\n// library allows to use simple and performant methods to\n// attack streams.\npackage cameradar\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "curl.go",
          "type": "blob",
          "size": 0.626953125,
          "content": "package cameradar\n\nimport (\n\tcurl \"github.com/Ullaakut/go-curl\"\n)\n\n// Curler is an interface that implements the CURL interface of the go-curl library\n// Used for mocking\ntype Curler interface {\n\tSetopt(opt int, param interface{}) error\n\tPerform() error\n\tGetinfo(info curl.CurlInfo) (interface{}, error)\n\tDuphandle() Curler\n}\n\n// Curl is a libcurl wrapper used to make the Curler interface work even though\n// golang currently does not support covariance (see https://github.com/golang/go/issues/7512)\ntype Curl struct {\n\t*curl.CURL\n}\n\n// Duphandle wraps curl.Duphandle\nfunc (c *Curl) Duphandle() Curler {\n\treturn &Curl{c.CURL.Duphandle()}\n}\n"
        },
        {
          "name": "curl_test.go",
          "type": "blob",
          "size": 0.33203125,
          "content": "package cameradar\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\tcurl \"github.com/Ullaakut/go-curl\"\n)\n\nfunc TestCurl(t *testing.T) {\n\thandle := Curl{\n\t\tCURL: curl.EasyInit(),\n\t}\n\n\thandle2 := handle.Duphandle()\n\n\tif reflect.DeepEqual(handle, handle2) {\n\t\tt.Errorf(\"unexpected identical handle from duphandle: expected %+v got %+v\", handle, handle2)\n\t}\n}\n"
        },
        {
          "name": "dictionaries",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5185546875,
          "content": "module github.com/Ullaakut/cameradar/v5\n\ngo 1.14\n\nrequire (\n\tgithub.com/PuerkitoBio/goquery v1.5.0\n\tgithub.com/Ullaakut/disgo v0.3.1\n\tgithub.com/Ullaakut/go-curl v0.0.0-20190525093431-597e157bbffd\n\tgithub.com/Ullaakut/nmap v2.0.0+incompatible\n\tgithub.com/VividCortex/ewma v1.1.1 // indirect\n\tgithub.com/fatih/color v1.7.0 // indirect\n\tgithub.com/mattn/go-colorable v0.1.2 // indirect\n\tgithub.com/spf13/pflag v1.0.3\n\tgithub.com/spf13/viper v1.4.0\n\tgithub.com/stretchr/testify v1.2.2\n\tgithub.com/vbauerster/mpb v3.4.0+incompatible\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 15.2822265625,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ngithub.com/BurntSushi/toml v0.3.1 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=\ngithub.com/PuerkitoBio/goquery v1.5.0 h1:uGvmFXOA73IKluu/F84Xd1tt/z07GYm8X49XKHP7EJk=\ngithub.com/PuerkitoBio/goquery v1.5.0/go.mod h1:qD2PgZ9lccMbQlc7eEOjaeRlFQON7xY8kdmcsrnKqMg=\ngithub.com/Ullaakut/disgo v0.3.1 h1:BGGVHynji41KGuGI02ztTCnILRvyzlvmiCRl5bBpjKk=\ngithub.com/Ullaakut/disgo v0.3.1/go.mod h1:/CSvpnYVSKOeh2dvUvx9cXshzz2t7T1/lRO/MrFj3fI=\ngithub.com/Ullaakut/go-curl v0.0.0-20190525093431-597e157bbffd h1:CMe+dX1CL4pCXNytxIB2U1qp0xZObGMZosJhaQdUlUo=\ngithub.com/Ullaakut/go-curl v0.0.0-20190525093431-597e157bbffd/go.mod h1:u8mVgpDT88IPIt1B+Tu8vkrcFfBKGcfGwS9I7wmvMh0=\ngithub.com/Ullaakut/nmap v2.0.0+incompatible h1:tNXub052dsnG8+yrgpph9nhVixIBdpRRgzvmQoc8eBA=\ngithub.com/Ullaakut/nmap v2.0.0+incompatible/go.mod h1:fkC066hwfcoKwlI7DS2ARTggSVtBTZYCjVH1TzuTMaQ=\ngithub.com/VividCortex/ewma v1.1.1 h1:MnEK4VOv6n0RSY4vtRe3h11qjxL3+t0B8yOL8iMXdcM=\ngithub.com/VividCortex/ewma v1.1.1/go.mod h1:2Tkkvm3sRDVXaiyucHiACn4cqf7DpdyLvmxzcbUokwA=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/andybalholm/cascadia v1.0.0 h1:hOCXnnZ5A+3eVDX8pvgl4kofXv2ELss0bKcqRySc45o=\ngithub.com/andybalholm/cascadia v1.0.0/go.mod h1:GsXiBklL0woXo1j/WYWtSYYC4ouU9PqHO0sqidkEA4Y=\ngithub.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=\ngithub.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/dgryski/go-sip13 v0.0.0-20181026042036-e10d5fee7954/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=\ngithub.com/fatih/color v1.7.0 h1:DkWD4oS2D8LGGgTQ6IvwJJXSL5Vp2ffcQg58nFV38Ys=\ngithub.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/fsnotify/fsnotify v1.4.7 h1:IXs+QLmnXW2CcXuY+8Mzv/fWEsPGWxqefPtCP5CnV9I=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20190129154638-5b532d6fd5ef/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=\ngithub.com/grpc-ecosystem/grpc-gateway v1.9.0/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=\ngithub.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/magiconair/properties v1.8.0 h1:LLgXmsheXeRoUOBOjtwPQCWIYqM/LU1ayDtDePerRcY=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=\ngithub.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-isatty v0.0.8 h1:HLtExJ+uU2HOZ+wI0Tt5DtUDrx8yhUqDcp7fYERX4CE=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/mitchellh/mapstructure v1.1.2 h1:fmNYVwqnSfB9mZU6OS2O6GsXM+wcskZDuKQzvN1EDeE=\ngithub.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=\ngithub.com/pelletier/go-toml v1.2.0 h1:T5zMGML61Wp+FlcbWjRDT7yAxhJNAiPPLOFECq181zc=\ngithub.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v0.9.3/go.mod h1:/TN21ttK/J9q6uSwhBd54HahCDft0ttaMvbicHlPoso=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/common v0.0.0-20181113130724-41aa239b4cce/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=\ngithub.com/prometheus/common v0.4.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.0-20190507164030-5867b95ac084/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=\ngithub.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=\ngithub.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=\ngithub.com/spf13/afero v1.1.2 h1:m8/z1t7/fwjysjQRYbP0RD+bUIF/8tJwPdEZsI83ACI=\ngithub.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=\ngithub.com/spf13/cast v1.3.0 h1:oget//CVOEoFewqQxwr0Ej5yjygnqGkvggSE/gB35Q8=\ngithub.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/jwalterweatherman v1.0.0 h1:XHEdyB+EcvlqZamSM4ZOMGlc93t6AcsBEu9Gc1vn7yk=\ngithub.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=\ngithub.com/spf13/pflag v1.0.3 h1:zPAT6CGy6wXeQ7NtTnaTerfKOsV6V6F8agHXFiazDkg=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/viper v1.4.0 h1:yXHLWeravcrgGyFSyCgdYpXQ9dR9c/WED3pg1RhxqEU=\ngithub.com/spf13/viper v1.4.0/go.mod h1:PTJ7Z/lr49W6bUbkmS1V3by4uWynFiR9p7+dSq/yZzE=\ngithub.com/stretchr/objx v0.1.1 h1:2vfRuCMp5sSVIDSqO8oNnWJq7mPa6KVP3iPIwFBuy8A=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=\ngithub.com/vbauerster/mpb v3.4.0+incompatible h1:mfiiYw87ARaeRW6x5gWwYRUawxaW1tLAD8IceomUCNw=\ngithub.com/vbauerster/mpb v3.4.0+incompatible/go.mod h1:zAHG26FUhVKETRu+MWqYXcI70POlC6N8up9p1dID7SU=\ngithub.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=\ngithub.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=\ngo.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\ngo.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=\ngo.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2 h1:VklqNMn3ovrHsnt90PveolxSbWFaJdECFbxSq0Mqo2M=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/net v0.0.0-20180218175443-cbe0f9307d01/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190522155817-f3200d17e092 h1:4QSRKanuywn15aTZvI/mIDEgPQpswuFndXpOj3rKEco=\ngolang.org/x/net v0.0.0-20190522155817-f3200d17e092/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223 h1:DH4skfRX4EBpamg7iV4ZlCpblAHI6s6TDM39bFZumv8=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.21.0/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/resty.v1 v1.12.0/go.mod h1:mDo4pnntr5jdWRML875a/NmxYqAlA73dVijT2AXvQQo=\ngopkg.in/yaml.v2 v2.0.0-20170812160011-eb3733d160e7/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 0.7216796875,
          "content": "package cameradar\n\nimport \"fmt\"\n\nfunc replace(streams []Stream, new Stream) []Stream {\n\tvar updatedSlice []Stream\n\n\tfor _, old := range streams {\n\t\tif old.Address == new.Address && old.Port == new.Port {\n\t\t\tupdatedSlice = append(updatedSlice, new)\n\t\t} else {\n\t\t\tupdatedSlice = append(updatedSlice, old)\n\t\t}\n\t}\n\n\treturn updatedSlice\n}\n\n// GetCameraRTSPURL generates a stream's RTSP URL.\nfunc GetCameraRTSPURL(stream Stream) string {\n\treturn \"rtsp://\" + stream.Username + \":\" + stream.Password + \"@\" + stream.Address + \":\" + fmt.Sprint(stream.Port) + \"/\" + stream.Route()\n}\n\n// GetCameraAdminPanelURL returns the URL to the camera's admin panel.\nfunc GetCameraAdminPanelURL(stream Stream) string {\n\treturn \"http://\" + stream.Address + \"/\"\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 1.9404296875,
          "content": "package cameradar\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestReplace(t *testing.T) {\n\tvalidStream1 := Stream{\n\t\tDevice:  \"fakeDevice\",\n\t\tAddress: \"fakeAddress\",\n\t\tPort:    1,\n\t}\n\n\tvalidStream2 := Stream{\n\t\tDevice:  \"fakeDevice\",\n\t\tAddress: \"differentFakeAddress\",\n\t\tPort:    2,\n\t}\n\n\tinvalidStream := Stream{\n\t\tDevice:  \"invalidDevice\",\n\t\tAddress: \"anotherFakeAddress\",\n\t\tPort:    3,\n\t}\n\n\tinvalidStreamModified := Stream{\n\t\tDevice:  \"updatedDevice\",\n\t\tAddress: \"anotherFakeAddress\",\n\t\tPort:    3,\n\t}\n\n\ttestCases := []struct {\n\t\tstreams   []Stream\n\t\tnewStream Stream\n\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tstreams:   []Stream{validStream1, validStream2, invalidStream},\n\t\t\tnewStream: invalidStreamModified,\n\n\t\t\texpectedStreams: []Stream{validStream1, validStream2, invalidStreamModified},\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tstreams := replace(test.streams, test.newStream)\n\n\t\tassert.Equal(t, len(test.expectedStreams), len(streams))\n\n\t\tfor _, expectedStream := range test.expectedStreams {\n\t\t\tassert.Contains(t, streams, expectedStream)\n\t\t}\n\t}\n}\n\nfunc TestGetCameraRTSPURL(t *testing.T) {\n\tvalidStream := Stream{\n\t\tAddress:  \"1.2.3.4\",\n\t\tUsername: \"ullaakut\",\n\t\tPassword: \"ba69897483886f0d2b0afb6345b76c0c\",\n\t\tRoutes:   []string{\"cameradar.sdp\"},\n\t\tPort:     1337,\n\t}\n\n\ttestCases := []struct {\n\t\tstream Stream\n\n\t\texpectedRTSPURL string\n\t}{\n\t\t{\n\t\t\tstream: validStream,\n\n\t\t\texpectedRTSPURL: \"rtsp://ullaakut:ba69897483886f0d2b0afb6345b76c0c@1.2.3.4:1337/cameradar.sdp\",\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tassert.Equal(t, test.expectedRTSPURL, GetCameraRTSPURL(test.stream))\n\t}\n}\n\nfunc TestGetCameraAdminPanelURL(t *testing.T) {\n\tvalidStream := Stream{\n\t\tAddress: \"1.2.3.4\",\n\t}\n\n\ttestCases := []struct {\n\t\tstream Stream\n\n\t\texpectedRTSPURL string\n\t}{\n\t\t{\n\t\t\tstream: validStream,\n\n\t\t\texpectedRTSPURL: \"http://1.2.3.4/\",\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tassert.Equal(t, test.expectedRTSPURL, GetCameraAdminPanelURL(test.stream))\n\t}\n}\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "loaders.go",
          "type": "blob",
          "size": 3.0458984375,
          "content": "package cameradar\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\nvar fs fileSystem = osFS{}\n\ntype fileSystem interface {\n\tOpen(name string) (file, error)\n\tStat(name string) (os.FileInfo, error)\n}\n\ntype file interface {\n\tio.Closer\n\tio.Reader\n\tio.ReaderAt\n\tio.Seeker\n\tStat() (os.FileInfo, error)\n}\n\n// osFS implements fileSystem using the local disk.\ntype osFS struct{}\n\nfunc (osFS) Open(name string) (file, error)        { return os.Open(name) }\nfunc (osFS) Stat(name string) (os.FileInfo, error) { return os.Stat(name) }\n\n// LoadCredentials opens a dictionary file and returns its contents as a Credentials structure.\nfunc (s *Scanner) LoadCredentials() error {\n\ts.term.Debugf(\"Loading credentials dictionary from path %q\\n\", s.credentialDictionaryPath)\n\n\t// Open & Read XML file.\n\tcontent, err := ioutil.ReadFile(s.credentialDictionaryPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not read credentials dictionary file at %q: %v\", s.credentialDictionaryPath, err)\n\t}\n\n\t// Unmarshal content of JSON file into data structure.\n\terr = json.Unmarshal(content, &s.credentials)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to unmarshal dictionary contents: %v\", err)\n\t}\n\n\ts.term.Debugf(\"Loaded %d usernames and %d passwords\\n\", len(s.credentials.Usernames), len(s.credentials.Passwords))\n\treturn nil\n}\n\n// LoadRoutes opens a dictionary file and returns its contents as a Routes structure.\nfunc (s *Scanner) LoadRoutes() error {\n\ts.term.Debugf(\"Loading routes dictionary from path %q\\n\", s.routeDictionaryPath)\n\n\tfile, err := os.Open(s.routeDictionaryPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to open dictionary: %v\", err)\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\ts.routes = append(s.routes, scanner.Text())\n\t}\n\n\ts.term.Debugf(\"Loaded %d routes\\n\", len(s.routes))\n\n\treturn scanner.Err()\n}\n\n// ParseCredentialsFromString parses a dictionary string and returns its contents as a Credentials structure.\nfunc ParseCredentialsFromString(content string) (Credentials, error) {\n\tvar creds Credentials\n\n\t// Unmarshal content of JSON file into data structure.\n\terr := json.Unmarshal([]byte(content), &creds)\n\tif err != nil {\n\t\treturn creds, err\n\t}\n\n\treturn creds, nil\n}\n\n// ParseRoutesFromString parses a dictionary string and returns its contents as a Routes structure.\nfunc ParseRoutesFromString(content string) Routes {\n\treturn strings.Split(content, \"\\n\")\n}\n\n// LoadTargets parses the file containing hosts to targets, if the targets are\n// just set to a file name.\nfunc (s *Scanner) LoadTargets() error {\n\tif len(s.targets) != 1 {\n\t\treturn nil\n\t}\n\n\tpath := s.targets[0]\n\n\t_, err := fs.Stat(path)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tfile, err := fs.Open(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to open targets file %q: %v\", path, err)\n\t}\n\tdefer file.Close()\n\n\tbytes, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to read targets file %q: %v\", path, err)\n\t}\n\n\ts.targets = strings.Split(string(bytes), \"\\n\")\n\n\ts.term.Debugf(\"Successfully parsed targets file with %d entries\", len(s.targets))\n\n\treturn nil\n}\n"
        },
        {
          "name": "loaders_test.go",
          "type": "blob",
          "size": 9.7587890625,
          "content": "package cameradar\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/Ullaakut/disgo\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\n// Setup Mock\ntype mockedFS struct {\n\tosFS\n\n\tfileExists bool\n\topenError  bool\n\n\tfileMock *fileMock\n\n\tfileSize int64\n}\n\n// fileMock mocks a file\ntype fileMock struct {\n\tmock.Mock\n\n\treadError bool\n\n\tbytes.Buffer\n}\n\ntype mockedFileInfo struct {\n\tos.FileInfo\n}\n\nfunc (m mockedFileInfo) Size() int64 { return 1 }\n\nfunc (m mockedFS) Stat(name string) (os.FileInfo, error) {\n\tif !m.fileExists {\n\t\treturn nil, os.ErrNotExist\n\t}\n\treturn mockedFileInfo{}, nil\n}\n\nfunc (m mockedFS) Open(name string) (file, error) {\n\tif m.openError {\n\t\treturn nil, os.ErrNotExist\n\t}\n\n\treturn m.fileMock, nil\n}\n\nfunc (m *fileMock) Read(p []byte) (n int, err error) {\n\tif m.readError {\n\t\treturn 0, os.ErrNotExist\n\t}\n\treturn m.Buffer.Read(p)\n}\n\nfunc (m *fileMock) ReadAt(p []byte, off int64) (n int, err error) {\n\treturn 1, nil\n}\n\nfunc (m *fileMock) Seek(offset int64, whence int) (int64, error) {\n\treturn offset, nil\n}\n\nfunc (m *fileMock) Stat() (os.FileInfo, error) {\n\treturn mockedFileInfo{}, nil\n}\n\n// Close mock\nfunc (m *fileMock) Close() error {\n\targs := m.Called()\n\treturn args.Error(0)\n}\n\n// Sync mock\nfunc (m *fileMock) Sync() error {\n\targs := m.Called()\n\treturn args.Error(0)\n}\n\nfunc TestLoadCredentials(t *testing.T) {\n\tcredentialsJSONString := []byte(\"{\\\"usernames\\\":[\\\"admin\\\",\\\"root\\\"],\\\"passwords\\\":[\\\"12345\\\",\\\"root\\\"]}\")\n\tvalidCredentials := Credentials{\n\t\tUsernames: []string{\"admin\", \"root\"},\n\t\tPasswords: []string{\"12345\", \"root\"},\n\t}\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\tinput      []byte\n\t\tfileExists bool\n\n\t\texpectedCredentials Credentials\n\t\texpectedErr         error\n\t}{\n\t\t{\n\t\t\tdescription: \"Valid baseline\",\n\n\t\t\tfileExists:          true,\n\t\t\tinput:               credentialsJSONString,\n\t\t\texpectedCredentials: validCredentials,\n\t\t},\n\t\t{\n\t\t\tdescription: \"File does not exist\",\n\n\t\t\tfileExists:  false,\n\t\t\tinput:       credentialsJSONString,\n\t\t\texpectedErr: errors.New(\"could not read credentials dictionary file at \\\"/tmp/cameradar_test_load_credentials_1.xml\\\": open /tmp/cameradar_test_load_credentials_1.xml: no such file or directory\"),\n\t\t},\n\t\t{\n\t\t\tdescription: \"Invalid format\",\n\n\t\t\tfileExists:  true,\n\t\t\tinput:       []byte(\"not json\"),\n\t\t\texpectedErr: errors.New(\"unable to unmarshal dictionary contents: invalid character 'o' in literal null (expecting 'u')\"),\n\t\t},\n\t\t{\n\t\t\tdescription: \"No streams in dictionary\",\n\n\t\t\tfileExists: true,\n\t\t\tinput:      []byte(\"{\\\"invalid\\\":\\\"json\\\"}\"),\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tfilePath := \"/tmp/cameradar_test_load_credentials_\" + fmt.Sprint(i) + \".xml\"\n\t\t\t// create file.\n\t\t\tif test.fileExists {\n\t\t\t\t_, err := os.Create(filePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"could not create xml file for LoadCredentials: %v. iteration: %d. file path: %s\\n\", err, i, filePath)\n\t\t\t\t}\n\n\t\t\t\terr = ioutil.WriteFile(filePath, test.input, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"could not write xml file for LoadCredentials: %v. iteration: %d. file path: %s\\n\", err, i, filePath)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:                     disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcredentialDictionaryPath: filePath,\n\t\t\t}\n\n\t\t\terr := scanner.LoadCredentials()\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\n\t\t\tassert.Len(t, scanner.credentials.Usernames, len(test.expectedCredentials.Usernames))\n\t\t\tfor _, expectedUsername := range test.expectedCredentials.Usernames {\n\t\t\t\tassert.Contains(t, scanner.credentials.Usernames, expectedUsername)\n\t\t\t}\n\n\t\t\tassert.Len(t, scanner.credentials.Passwords, len(test.expectedCredentials.Passwords))\n\t\t\tfor _, expectedPassword := range test.expectedCredentials.Passwords {\n\t\t\t\tassert.Contains(t, scanner.credentials.Passwords, expectedPassword)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLoadRoutes(t *testing.T) {\n\troutesJSONString := []byte(\"admin\\nroot\")\n\tvalidRoutes := Routes{\"admin\", \"root\"}\n\n\ttests := []struct {\n\t\tdescription string\n\t\tinput       []byte\n\t\tfileExists  bool\n\n\t\texpectedRoutes Routes\n\t\texpectedErr    error\n\t}{\n\t\t{\n\t\t\tdescription: \"Valid baseline\",\n\n\t\t\tfileExists:     true,\n\t\t\tinput:          routesJSONString,\n\t\t\texpectedRoutes: validRoutes,\n\t\t},\n\t\t{\n\t\t\tdescription: \"File does not exist\",\n\n\t\t\tfileExists:  false,\n\t\t\tinput:       routesJSONString,\n\t\t\texpectedErr: errors.New(\"unable to open dictionary: open /tmp/cameradar_test_load_routes_1.xml: no such file or directory\"),\n\t\t},\n\t\t{\n\t\t\tdescription: \"No streams in dictionary\",\n\n\t\t\tfileExists: true,\n\t\t\tinput:      []byte(\"\"),\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tfilePath := \"/tmp/cameradar_test_load_routes_\" + fmt.Sprint(i) + \".xml\"\n\n\t\t\t// Create file.\n\t\t\tif test.fileExists {\n\t\t\t\t_, err := os.Create(filePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"could not create xml file for LoadRoutes: %v. iteration: %d. file path: %s\\n\", err, i, filePath)\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\n\t\t\t\terr = ioutil.WriteFile(filePath, test.input, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"could not write xml file for LoadRoutes: %v. iteration: %d. file path: %s\\n\", err, i, filePath)\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:                disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\trouteDictionaryPath: filePath,\n\t\t\t}\n\n\t\t\terr := scanner.LoadRoutes()\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\n\t\t\tassert.Len(t, scanner.routes, len(test.expectedRoutes))\n\t\t\tfor _, expectedRoute := range test.expectedRoutes {\n\t\t\t\tassert.Contains(t, scanner.routes, expectedRoute)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseCredentialsFromString(t *testing.T) {\n\tdefaultCredentials := Credentials{\n\t\tUsernames: []string{\n\t\t\t\"\",\n\t\t\t\"admin\",\n\t\t\t\"Admin\",\n\t\t\t\"Administrator\",\n\t\t\t\"root\",\n\t\t\t\"supervisor\",\n\t\t\t\"ubnt\",\n\t\t\t\"service\",\n\t\t\t\"Dinion\",\n\t\t\t\"administrator\",\n\t\t\t\"admin1\",\n\t\t},\n\t\tPasswords: []string{\n\t\t\t\"\",\n\t\t\t\"admin\",\n\t\t\t\"9999\",\n\t\t\t\"123456\",\n\t\t\t\"pass\",\n\t\t\t\"camera\",\n\t\t\t\"1234\",\n\t\t\t\"12345\",\n\t\t\t\"fliradmin\",\n\t\t\t\"system\",\n\t\t\t\"jvc\",\n\t\t\t\"meinsm\",\n\t\t\t\"root\",\n\t\t\t\"4321\",\n\t\t\t\"111111\",\n\t\t\t\"1111111\",\n\t\t\t\"password\",\n\t\t\t\"ikwd\",\n\t\t\t\"supervisor\",\n\t\t\t\"ubnt\",\n\t\t\t\"wbox123\",\n\t\t\t\"service\",\n\t\t},\n\t}\n\n\ttests := []struct {\n\t\tstr                 string\n\t\texpectedCredentials Credentials\n\t}{\n\t\t{\n\t\t\tstr:                 \"{\\\"usernames\\\":[\\\"\\\",\\\"admin\\\",\\\"Admin\\\",\\\"Administrator\\\",\\\"root\\\",\\\"supervisor\\\",\\\"ubnt\\\",\\\"service\\\",\\\"Dinion\\\",\\\"administrator\\\",\\\"admin1\\\"],\\\"passwords\\\":[\\\"\\\",\\\"admin\\\",\\\"9999\\\",\\\"123456\\\",\\\"pass\\\",\\\"camera\\\",\\\"1234\\\",\\\"12345\\\",\\\"fliradmin\\\",\\\"system\\\",\\\"jvc\\\",\\\"meinsm\\\",\\\"root\\\",\\\"4321\\\",\\\"111111\\\",\\\"1111111\\\",\\\"password\\\",\\\"ikwd\\\",\\\"supervisor\\\",\\\"ubnt\\\",\\\"wbox123\\\",\\\"service\\\"]}\",\n\t\t\texpectedCredentials: defaultCredentials,\n\t\t},\n\t\t{\n\t\t\tstr:                 \"{}\",\n\t\t\texpectedCredentials: Credentials{},\n\t\t},\n\t\t{\n\t\t\tstr:                 \"{\\\"invalid_field\\\":42}\",\n\t\t\texpectedCredentials: Credentials{},\n\t\t},\n\t\t{\n\t\t\tstr:                 \"not json\",\n\t\t\texpectedCredentials: Credentials{},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tparsedCredentials, _ := ParseCredentialsFromString(test.str)\n\t\tassert.Equal(t, test.expectedCredentials, parsedCredentials)\n\t}\n}\n\nfunc TestParseRoutesFromString(t *testing.T) {\n\ttests := []struct {\n\t\tstr            string\n\t\texpectedRoutes Routes\n\t}{\n\t\t{\n\t\t\tstr:            \"a\\nb\\nc\",\n\t\t\texpectedRoutes: []string{\"a\", \"b\", \"c\"},\n\t\t},\n\t\t{\n\t\t\tstr:            \"a\",\n\t\t\texpectedRoutes: []string{\"a\"},\n\t\t},\n\t\t{\n\t\t\tstr:            \"\",\n\t\t\texpectedRoutes: []string{\"\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tassert.Equal(t, test.expectedRoutes, ParseRoutesFromString(test.str))\n\t}\n}\n\nfunc TestLoadTargets(t *testing.T) {\n\n\toldFS := fs\n\tmfs := &mockedFS{}\n\tfs = mfs\n\tdefer func() {\n\t\tfs = oldFS\n\t}()\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []string\n\n\t\tfileExists bool\n\t\topenError  bool\n\t\treadError  bool\n\n\t\texpectedTargets []string\n\t\texpectedError   error\n\t}{\n\t\t{\n\t\t\tdescription: \"not a file\",\n\n\t\t\ttargets: []string{\"0.0.0.0\"},\n\n\t\t\tfileExists: false,\n\n\t\t\texpectedTargets: []string{\"0.0.0.0\"},\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"not file targets\",\n\n\t\t\ttargets: []string{\"0.0.0.0\", \"1.2.3.4/24\"},\n\n\t\t\texpectedTargets: []string{\"0.0.0.0\", \"1.2.3.4/24\"},\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"file contains targets\",\n\n\t\t\ttargets: []string{\"test_does_not_really_exist\"},\n\n\t\t\tfileExists: true,\n\n\t\t\texpectedTargets: []string{\"0.0.0.0\", \"localhost\", \"192.17.0.0/16\", \"192.168.1.140-255\", \"192.168.2-3.0-255\"},\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"open error\",\n\n\t\t\ttargets: []string{\"test_does_not_really_exist\"},\n\n\t\t\tfileExists: true,\n\t\t\topenError:  true,\n\n\t\t\texpectedTargets: []string{\"test_does_not_really_exist\"},\n\t\t\texpectedError:   errors.New(\"unable to open targets file \\\"test_does_not_really_exist\\\": file does not exist\"),\n\t\t},\n\t\t{\n\t\t\tdescription: \"read error\",\n\n\t\t\ttargets: []string{\"test_does_not_really_exist\"},\n\n\t\t\tfileExists: true,\n\t\t\treadError:  true,\n\n\t\t\texpectedTargets: []string{\"test_does_not_really_exist\"},\n\t\t\texpectedError:   errors.New(\"unable to read targets file \\\"test_does_not_really_exist\\\": file does not exist\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tmfs.fileExists = test.fileExists\n\t\t\tmfs.openError = test.openError\n\n\t\t\tmfs.fileMock = &fileMock{\n\t\t\t\treadError: test.readError,\n\t\t\t}\n\t\t\tmfs.fileMock.On(\"Close\").Return(nil)\n\t\t\tmfs.fileMock.WriteString(\"0.0.0.0\\nlocalhost\\n192.17.0.0/16\\n192.168.1.140-255\\n192.168.2-3.0-255\")\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\ttargets: test.targets,\n\t\t\t}\n\n\t\t\terr := scanner.LoadTargets()\n\t\t\tassert.Equal(t, test.expectedTargets, scanner.targets)\n\t\t\tassert.Equal(t, test.expectedError, err)\n\t\t})\n\t}\n}\n\n// This is completely useless and just lets me\n// not look at these two red lines on the coverage\n// any longer.\nfunc TestFS(t *testing.T) {\n\tfs := osFS{}\n\n\tfs.Open(\"test\")\n\tfs.Stat(\"test\")\n}\n"
        },
        {
          "name": "models.go",
          "type": "blob",
          "size": 1.36328125,
          "content": "package cameradar\n\nimport \"time\"\n\n// Stream represents a camera's RTSP stream\ntype Stream struct {\n\tDevice   string   `json:\"device\"`\n\tUsername string   `json:\"username\"`\n\tPassword string   `json:\"password\"`\n\tRoutes   []string `json:\"route\"`\n\tAddress  string   `json:\"address\" validate:\"required\"`\n\tPort     uint16   `json:\"port\" validate:\"required\"`\n\n\tCredentialsFound bool `json:\"credentials_found\"`\n\tRouteFound       bool `json:\"route_found\"`\n\tAvailable        bool `json:\"available\"`\n\n\tAuthenticationType int `json:\"authentication_type\"`\n}\n\n// Route returns this stream's route if there is one.\nfunc (s Stream) Route() string {\n\tif len(s.Routes) > 0 {\n\t\treturn s.Routes[0]\n\t}\n\treturn \"\"\n}\n\n// Credentials is a map of credentials\n// usernames are keys and passwords are values\n// creds['admin'] -> 'secure_password'\ntype Credentials struct {\n\tUsernames []string `json:\"usernames\"`\n\tPasswords []string `json:\"passwords\"`\n}\n\n// Routes is a slice of Routes\n// ['/live.sdp', '/media.amp', ...]\ntype Routes []string\n\n// Options contains all options needed to launch a complete cameradar scan\ntype Options struct {\n\tTargets     []string      `json:\"target\" validate:\"required\"`\n\tPorts       []string      `json:\"ports\"`\n\tRoutes      Routes        `json:\"routes\"`\n\tCredentials Credentials   `json:\"credentials\"`\n\tSpeed       int           `json:\"speed\"`\n\tTimeout     time.Duration `json:\"timeout\"`\n}\n"
        },
        {
          "name": "scan.go",
          "type": "blob",
          "size": 1.7294921875,
          "content": "package cameradar\n\nimport (\n\t\"strings\"\n\n\t\"github.com/Ullaakut/nmap\"\n)\n\n// Scan scans the target networks and tries to find RTSP streams within them.\n//\n// targets can be:\n//\n//    - a subnet (e.g.: 172.16.100.0/24)\n//    - an IP (e.g.: 172.16.100.10)\n//    - a hostname (e.g.: localhost)\n//    - a range of IPs (e.g.: 172.16.100.10-20)\n//\n// ports can be:\n//\n//    - one or multiple ports and port ranges separated by commas (e.g.: 554,8554-8560,18554-28554)\nfunc (s *Scanner) Scan() ([]Stream, error) {\n\ts.term.StartStep(\"Scanning the network\")\n\n\t// Run nmap command to discover open ports on the specified targets & ports.\n\tnmapScanner, err := nmap.NewScanner(\n\t\tnmap.WithTargets(s.targets...),\n\t\tnmap.WithPorts(s.ports...),\n\t\tnmap.WithServiceInfo(),\n\t\tnmap.WithTimingTemplate(nmap.Timing(s.scanSpeed)),\n\t)\n\tif err != nil {\n\t\treturn nil, s.term.FailStepf(\"unable to create network scanner: %v\", err)\n\t}\n\n\treturn s.scan(nmapScanner)\n}\n\nfunc (s *Scanner) scan(nmapScanner nmap.ScanRunner) ([]Stream, error) {\n\tresults, warnings, err := nmapScanner.Run()\n\tfor _, warning := range warnings {\n\t\ts.term.Infoln(\"[Nmap Warning]\", warning)\n\t}\n\tif err != nil {\n\t\treturn nil, s.term.FailStepf(\"error while scanning network: %v\", err)\n\t}\n\n\t// Get streams from nmap results.\n\tvar streams []Stream\n\tfor _, host := range results.Hosts {\n\t\tfor _, port := range host.Ports {\n\t\t\tif port.Status() != \"open\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !strings.Contains(port.Service.Name, \"rtsp\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, address := range host.Addresses {\n\t\t\t\tstreams = append(streams, Stream{\n\t\t\t\t\tDevice:  port.Service.Product,\n\t\t\t\t\tAddress: address.Addr,\n\t\t\t\t\tPort:    port.ID,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\ts.term.Debugf(\"Found %d RTSP streams\\n\", len(streams))\n\n\ts.term.EndStep()\n\n\treturn streams, nil\n}\n"
        },
        {
          "name": "scan_test.go",
          "type": "blob",
          "size": 6.1650390625,
          "content": "package cameradar\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/Ullaakut/disgo\"\n\n\t\"github.com/Ullaakut/nmap\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\ntype nmapMock struct {\n\tmock.Mock\n}\n\nfunc (m *nmapMock) Run() (*nmap.Run, []string, error) {\n\targs := m.Called()\n\n\tif args.Get(0) != nil && args.Get(1) != nil {\n\t\treturn args.Get(0).(*nmap.Run), args.Get(1).([]string), args.Error(2)\n\t}\n\treturn nil, nil, args.Error(2)\n}\n\nvar (\n\tvalidStream1 = Stream{\n\t\tDevice:  \"fakeDevice\",\n\t\tAddress: \"fakeAddress\",\n\t\tPort:    1337,\n\t}\n\n\tvalidStream2 = Stream{\n\t\tDevice:  \"fakeDevice\",\n\t\tAddress: \"differentFakeAddress\",\n\t\tPort:    1337,\n\t}\n\n\tinvalidStreamNoPort = Stream{\n\t\tDevice:  \"invalidDevice\",\n\t\tAddress: \"fakeAddress\",\n\t\tPort:    0,\n\t}\n\n\tinvalidStreamNoAddress = Stream{\n\t\tDevice:  \"invalidDevice\",\n\t\tAddress: \"\",\n\t\tPort:    1337,\n\t}\n)\n\nfunc TestScan(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets    []string\n\t\tports      []string\n\t\tspeed      int\n\t\tremovePath bool\n\n\t\texpectedErr     error\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tdescription: \"create new scanner and call scan, no error\",\n\n\t\t\ttargets: []string{\"localhost\"},\n\t\t\tports:   []string{\"80\"},\n\t\t\tspeed:   5,\n\t\t},\n\t\t{\n\t\t\tdescription: \"create new scanner with missing nmap installation\",\n\n\t\t\tremovePath: true,\n\t\t\tports:      []string{\"80\"},\n\n\t\t\texpectedErr: errors.New(\"unable to create network scanner: nmap binary was not found\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tif test.removePath {\n\t\t\t\tos.Setenv(\"PATH\", \"\")\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:      disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\ttargets:   test.targets,\n\t\t\t\tports:     test.ports,\n\t\t\t\tscanSpeed: test.speed,\n\t\t\t}\n\n\t\t\tresult, err := scanner.Scan()\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\t\t\tassert.Equal(t, test.expectedStreams, result)\n\t\t})\n\t}\n}\n\nfunc TestInternalScan(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\n\t\tnmapResult   *nmap.Run\n\t\tnmapWarnings []string\n\t\tnmapError    error\n\n\t\texpectedStreams []Stream\n\t\texpectedErr     error\n\t}{\n\t\t{\n\t\t\tdescription: \"valid streams\",\n\n\t\t\tnmapResult: &nmap.Run{\n\t\t\t\tHosts: []nmap.Host{\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: validStream1.Address,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"open\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream1.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp\",\n\t\t\t\t\t\t\t\t\tProduct: validStream1.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: validStream2.Address,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"open\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: validStream2.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedStreams: []Stream{validStream1, validStream2},\n\t\t},\n\t\t{\n\t\t\tdescription: \"two invalid targets, no error\",\n\n\t\t\tnmapResult: &nmap.Run{\n\t\t\t\tHosts: []nmap.Host{\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"open\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedStreams: nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"different port states, no error\",\n\n\t\t\tnmapResult: &nmap.Run{\n\t\t\t\tHosts: []nmap.Host{\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"closed\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"unfiltered\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"filtered\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedStreams: nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"not rtsp, no error\",\n\n\t\t\tnmapResult: &nmap.Run{\n\t\t\t\tHosts: []nmap.Host{\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"open\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"tcp\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedStreams: nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"no hosts found\",\n\n\t\t\tnmapResult:      &nmap.Run{},\n\t\t\texpectedStreams: nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"scan failed\",\n\n\t\t\tnmapError:    errors.New(\"scan failed\"),\n\t\t\tnmapWarnings: []string{\"invalid host\"},\n\t\t\texpectedErr:  errors.New(\"error while scanning network: scan failed\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tnmapMock := &nmapMock{}\n\n\t\t\tnmapMock.On(\"Run\").Return(test.nmapResult, test.nmapWarnings, test.nmapError)\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm: disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t}\n\n\t\t\tresults, err := scanner.scan(nmapMock)\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\t\t\tassert.Equal(t, test.expectedStreams, results, \"wrong streams parsed\")\n\t\t\tassert.Equal(t, len(test.expectedStreams), len(results), \"wrong streams parsed\")\n\n\t\t\tnmapMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "scanner.go",
          "type": "blob",
          "size": 4.5712890625,
          "content": "package cameradar\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/Ullaakut/disgo\"\n\t\"github.com/Ullaakut/disgo/style\"\n\tcurl \"github.com/Ullaakut/go-curl\"\n)\n\nconst (\n\tdefaultCredentialDictionaryPath = \"${GOPATH}/src/github.com/Ullaakut/cameradar/dictionaries/credentials.json\"\n\tdefaultRouteDictionaryPath      = \"${GOPATH}/src/github.com/Ullaakut/cameradar/dictionaries/routes\"\n)\n\n// Scanner represents a cameradar scanner. It scans a network and\n// attacks all streams found to get their RTSP credentials.\ntype Scanner struct {\n\tcurl Curler\n\tterm *disgo.Terminal\n\n\ttargets                  []string\n\tports                    []string\n\tdebug                    bool\n\tverbose                  bool\n\tscanSpeed                int\n\tattackInterval           time.Duration\n\ttimeout                  time.Duration\n\tcredentialDictionaryPath string\n\trouteDictionaryPath      string\n\n\tcredentials Credentials\n\troutes      Routes\n}\n\n// New creates a new Cameradar Scanner and applies the given options.\nfunc New(options ...func(*Scanner)) (*Scanner, error) {\n\terr := curl.GlobalInit(curl.GLOBAL_ALL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to initialize curl library: %v\", err)\n\t}\n\n\thandle := curl.EasyInit()\n\tif handle == nil {\n\t\treturn nil, fmt.Errorf(\"unable to initialize curl handle: %v\", err)\n\t}\n\n\tscanner := &Scanner{\n\t\tcurl:                     &Curl{CURL: handle},\n\t\tcredentialDictionaryPath: defaultCredentialDictionaryPath,\n\t\trouteDictionaryPath:      defaultRouteDictionaryPath,\n\t}\n\n\tfor _, option := range options {\n\t\toption(scanner)\n\t}\n\n\tgopath := os.Getenv(\"GOPATH\")\n\tif gopath == \"\" && scanner.credentialDictionaryPath == defaultCredentialDictionaryPath && scanner.routeDictionaryPath == defaultRouteDictionaryPath {\n\t\tdisgo.Errorln(style.Failure(\"No $GOPATH was found.\\nDictionaries may not be loaded properly, please set your $GOPATH to use the default dictionaries.\"))\n\t}\n\n\tscanner.credentialDictionaryPath = os.ExpandEnv(scanner.credentialDictionaryPath)\n\tscanner.routeDictionaryPath = os.ExpandEnv(scanner.routeDictionaryPath)\n\n\tscanner.term = disgo.NewTerminal(\n\t\tdisgo.WithDebug(scanner.debug),\n\t)\n\n\terr = scanner.LoadTargets()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse target file: %v\", err)\n\t}\n\n\tscanner.term.StartStepf(\"Loading credentials\")\n\terr = scanner.LoadCredentials()\n\tif err != nil {\n\t\treturn nil, scanner.term.FailStepf(\"unable to load credentials dictionary: %v\", err)\n\t}\n\n\tscanner.term.StartStepf(\"Loading routes\")\n\terr = scanner.LoadRoutes()\n\tif err != nil {\n\t\treturn nil, scanner.term.FailStepf(\"unable to load credentials dictionary: %v\", err)\n\t}\n\n\tdisgo.EndStep()\n\n\treturn scanner, nil\n}\n\n// WithTargets specifies the targets to scan and attack.\nfunc WithTargets(targets []string) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.targets = targets\n\t}\n}\n\n// WithPorts specifies the ports to scan and attack.\nfunc WithPorts(ports []string) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.ports = ports\n\t}\n}\n\n// WithDebug specifies whether or not to enable debug logs.\nfunc WithDebug(debug bool) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.debug = debug\n\t}\n}\n\n// WithVerbose specifies whether or not to enable verbose logs.\nfunc WithVerbose(verbose bool) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.verbose = verbose\n\t}\n}\n\n// WithCustomCredentials specifies a custom credential dictionary\n// to use for the attacks.\nfunc WithCustomCredentials(dictionaryPath string) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.credentialDictionaryPath = dictionaryPath\n\t}\n}\n\n// WithCustomRoutes specifies a custom route dictionary\n// to use for the attacks.\nfunc WithCustomRoutes(dictionaryPath string) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.routeDictionaryPath = dictionaryPath\n\t}\n}\n\n// WithScanSpeed specifies the speed at which the scan should be executed. Faster\n// means easier to detect, slower has bigger timeout values and is more silent.\nfunc WithScanSpeed(speed int) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.scanSpeed = speed\n\t}\n}\n\n// WithAttackInterval specifies the interval of time during which Cameradar\n// should wait between each attack attempt during bruteforcing.\n// Setting a high value for this obviously makes attacks much slower.\nfunc WithAttackInterval(interval time.Duration) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.attackInterval = interval\n\t}\n}\n\n// WithTimeout specifies the amount of time after which attack requests should\n// timeout. This should be high if the network you are attacking has a poor\n// connectivity or that you are located far away from it.\nfunc WithTimeout(timeout time.Duration) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.timeout = timeout\n\t}\n}\n"
        },
        {
          "name": "scanner_test.go",
          "type": "blob",
          "size": 3.3310546875,
          "content": "package cameradar\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\tcurl \"github.com/Ullaakut/go-curl\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNew(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets           []string\n\t\tports             []string\n\t\tdebug             bool\n\t\tverbose           bool\n\t\tcustomCredentials string\n\t\tcustomRoutes      string\n\t\tspeed             int\n\t\tattackInterval    time.Duration\n\t\ttimeout           time.Duration\n\n\t\tloadTargetsFail bool\n\t\tloadCredsFail   bool\n\t\tloadRoutesFail  bool\n\n\t\tcurlGlobalFail bool\n\t\tcurlEasyFail   bool\n\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tdescription: \"no error while loading dictionaries\",\n\n\t\t\ttargets: []string{\"titi\", \"toto\"},\n\t\t\tports:   []string{\"554\"},\n\t\t\tdebug:   true,\n\t\t\tverbose: false,\n\t\t\tspeed:   3,\n\t\t\ttimeout: time.Millisecond,\n\t\t},\n\t\t{\n\t\t\tdescription: \"unable to load targets\",\n\n\t\t\tloadTargetsFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"unable to load credentials\",\n\n\t\t\tloadCredsFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"unable to load routes\",\n\n\t\t\tloadRoutesFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl fails to init\",\n\n\t\t\tcurlGlobalFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl fails to create handle\",\n\n\t\t\tcurlEasyFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"gopath not set and default dicts\",\n\n\t\t\tcustomCredentials: defaultCredentialDictionaryPath,\n\t\t\tcustomRoutes:      defaultRouteDictionaryPath,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t}\n\n\t// Temporarily empty the gopath for testing purposes.\n\tdefer os.Setenv(\"GOPATH\", os.Getenv(\"GOPATH\"))\n\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tos.Setenv(\"GOPATH\", \"\")\n\n\t\t\tif test.loadTargetsFail {\n\t\t\t\ttest.targets = []string{generateTmpFileName(i, \"targets\")}\n\t\t\t\tioutil.WriteFile(test.targets[0], []byte(`0.0.0.0`), 0000)\n\t\t\t}\n\n\t\t\tif !test.loadCredsFail && test.customCredentials == \"\" {\n\t\t\t\ttest.customCredentials = generateTmpFileName(i, \"creds\")\n\t\t\t\tioutil.WriteFile(test.customCredentials, []byte(`{\"usernames\":[\"admin\"],\"passwords\":[\"admin\"]}`), 0644)\n\t\t\t}\n\n\t\t\tif !test.loadRoutesFail && test.customRoutes == \"\" {\n\t\t\t\ttest.customRoutes = generateTmpFileName(i, \"routes\")\n\t\t\t\tioutil.WriteFile(test.customRoutes, []byte(`live.sdp`), 0644)\n\t\t\t}\n\n\t\t\tcurl.TestGlobalFail = test.curlGlobalFail\n\t\t\tcurl.TestEasyFail = test.curlEasyFail\n\n\t\t\tscanner, err := New(\n\t\t\t\tWithTargets(test.targets),\n\t\t\t\tWithPorts(test.ports),\n\t\t\t\tWithDebug(test.debug),\n\t\t\t\tWithVerbose(test.verbose),\n\t\t\t\tWithScanSpeed(test.speed),\n\t\t\t\tWithAttackInterval(test.attackInterval),\n\t\t\t\tWithTimeout(test.timeout),\n\t\t\t\tWithCustomCredentials(test.customCredentials),\n\t\t\t\tWithCustomRoutes(test.customRoutes),\n\t\t\t)\n\n\t\t\tif test.expectedErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\n\t\t\tif scanner != nil {\n\t\t\t\tassert.Equal(t, test.targets, scanner.targets)\n\t\t\t\tassert.Equal(t, test.ports, scanner.ports)\n\t\t\t\tassert.Equal(t, test.debug, scanner.debug)\n\t\t\t\tassert.Equal(t, test.verbose, scanner.verbose)\n\t\t\t\tassert.Equal(t, test.speed, scanner.scanSpeed)\n\t\t\t\tassert.Equal(t, test.attackInterval, scanner.attackInterval)\n\t\t\t\tassert.Equal(t, test.timeout, scanner.timeout)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc generateTmpFileName(iteration int, purpose string) string {\n\treturn fmt.Sprintf(\"/tmp/cameradar_test_scanner_%s_%d_%d\", purpose, time.Now().Unix(), iteration)\n}\n"
        },
        {
          "name": "summary.go",
          "type": "blob",
          "size": 2.5185546875,
          "content": "package cameradar\n\nimport (\n\t\"github.com/Ullaakut/disgo/style\"\n\tcurl \"github.com/Ullaakut/go-curl\"\n)\n\n// PrintStreams prints information on each stream.\nfunc (s *Scanner) PrintStreams(streams []Stream) {\n\tif len(streams) == 0 {\n\t\ts.term.Infof(\"%s No streams were found. Please make sure that your target is on an accessible network.\\n\", style.Failure(style.SymbolCross))\n\t}\n\n\tsuccess := 0\n\tfor _, stream := range streams {\n\t\tif stream.Available {\n\t\t\ts.term.Infof(\"%s\\tDevice RTSP URL:\\t%s\\n\", style.Success(style.SymbolRightTriangle), style.Link(GetCameraRTSPURL(stream)))\n\t\t\ts.term.Infof(\"\\tAvailable:\\t\\t%s\\n\", style.Success(style.SymbolCheck))\n\t\t\tsuccess++\n\t\t} else {\n\t\t\ts.term.Infof(\"%s\\tAdmin panel URL:\\t%s You can use this URL to try attacking the camera's admin panel instead.\\n\", style.Failure(style.SymbolCross), style.Link(GetCameraAdminPanelURL(stream)))\n\t\t\ts.term.Infof(\"\\tAvailable:\\t\\t%s\\n\", style.Failure(style.SymbolCross))\n\t\t}\n\n\t\tif len(stream.Device) > 0 {\n\t\t\ts.term.Infof(\"\\tDevice model:\\t\\t%s\\n\\n\", stream.Device)\n\t\t}\n\n\t\ts.term.Infof(\"\\tIP address:\\t\\t%s\\n\", stream.Address)\n\t\ts.term.Infof(\"\\tRTSP port:\\t\\t%d\\n\", stream.Port)\n\n\t\tswitch stream.AuthenticationType {\n\t\tcase curl.AUTH_NONE:\n\t\t\ts.term.Infoln(\"\\tThis camera does not require authentication\")\n\t\tcase curl.AUTH_BASIC:\n\t\t\ts.term.Infoln(\"\\tAuth type:\\t\\tbasic\")\n\t\tcase curl.AUTH_DIGEST:\n\t\t\ts.term.Infoln(\"\\tAuth type:\\t\\tdigest\")\n\t\t}\n\n\t\tif stream.CredentialsFound {\n\t\t\ts.term.Infof(\"\\tUsername:\\t\\t%s\\n\", style.Success(stream.Username))\n\t\t\ts.term.Infof(\"\\tPassword:\\t\\t%s\\n\", style.Success(stream.Password))\n\t\t} else {\n\t\t\ts.term.Infof(\"\\tUsername:\\t\\t%s\\n\", style.Failure(\"not found\"))\n\t\t\ts.term.Infof(\"\\tPassword:\\t\\t%s\\n\", style.Failure(\"not found\"))\n\t\t}\n\n\t\ts.term.Infoln(\"\\tRTSP routes:\")\n\t\tif stream.RouteFound {\n\t\t\tfor _, route := range stream.Routes {\n\t\t\t\ts.term.Infoln(style.Success(\"\\t\\t\\t\\t/\" + route))\n\t\t\t}\n\t\t} else {\n\t\t\ts.term.Infoln(style.Failure(\"not found\"))\n\t\t}\n\n\t\ts.term.Info(\"\\n\\n\")\n\t}\n\n\tif success > 1 {\n\t\ts.term.Infof(\"%s Successful attack: %s devices were accessed\", style.Success(style.SymbolCheck), style.Success(len(streams)))\n\t} else if success == 1 {\n\t\ts.term.Infof(\"%s Successful attack: %s device was accessed\", style.Success(style.SymbolCheck), style.Success(\"one\"))\n\t} else {\n\t\ts.term.Infof(\"%s Streams were found but none were accessed. They are most likely configured with secure credentials and routes. You can try adding entries to the dictionary or generating your own in order to attempt a bruteforce attack on the cameras.\\n\", style.Failure(\"\\xE2\\x9C\\x96\"))\n\t}\n}\n"
        },
        {
          "name": "summary_test.go",
          "type": "blob",
          "size": 2.9599609375,
          "content": "package cameradar\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/Ullaakut/disgo\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar (\n\tunavailable = Stream{}\n\n\tavailable = Stream{\n\t\tAvailable: true,\n\t}\n\n\tdeviceFound = Stream{\n\t\tDevice: \"devicename\",\n\t}\n\n\tnoAuth = Stream{\n\t\tAuthenticationType: 0,\n\t}\n\n\tbasic = Stream{\n\t\tAuthenticationType: 1,\n\t}\n\n\tdigest = Stream{\n\t\tAuthenticationType: 2,\n\t}\n\n\tcredsFound = Stream{\n\t\tCredentialsFound: true,\n\t\tUsername:         \"us3r\",\n\t\tPassword:         \"p4ss\",\n\t}\n\n\trouteFound = Stream{\n\t\tRouteFound: true,\n\t\tRoutes:     []string{\"r0ute\"},\n\t}\n)\n\nfunc TestPrintStreams(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\n\t\tstreams []Stream\n\n\t\texpectedLogs []string\n\t}{\n\t\t{\n\t\t\tdescription: \"displays the proper message when no streams found\",\n\n\t\t\tstreams: nil,\n\n\t\t\texpectedLogs: []string{\"No streams were found\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays the admin panel URL when a stream is not accessible\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tunavailable,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"Admin panel URL\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays the device name when it is found\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tdeviceFound,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"Device model:\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays authentication type (no auth)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tnoAuth,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"This camera does not require authentication\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays authentication type (basic)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tbasic,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"basic\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays authentication type (digest)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tdigest,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"digest\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays credentials properly\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tcredsFound,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"Username\",\n\t\t\t\t\"us3r\",\n\t\t\t\t\"Password\",\n\t\t\t\t\"p4ss\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays route properly\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\trouteFound,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"RTSP route\",\n\t\t\t\t\"/r0ute\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays successes properly (no success)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tunavailable,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"Streams were found but none were accessed\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays successes properly (1 success)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tavailable,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"Successful attack\",\n\t\t\t\t\"device was accessed\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays successes properly (multiple successes)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tavailable,\n\t\t\t\tavailable,\n\t\t\t\tavailable,\n\t\t\t\tavailable,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"Successful attack\",\n\t\t\t\t\"devices were accessed\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\twriter := &bytes.Buffer{}\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm: disgo.NewTerminal(disgo.WithDefaultOutput(writer)),\n\t\t\t}\n\n\t\t\tscanner.PrintStreams(test.streams)\n\n\t\t\tfor _, expectedLog := range test.expectedLogs {\n\t\t\t\tassert.Contains(t, writer.String(), expectedLog)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}