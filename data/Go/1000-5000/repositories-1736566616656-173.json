{
  "metadata": {
    "timestamp": 1736566616656,
    "page": 173,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Ullaakut/cameradar",
      "stars": 4182,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.06640625,
          "content": "# IDE config\n.idea/\n.vscode/\n\n# Golang\n/bin/*\n/pkg/*\n\n# Builds\ndist/"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.2001953125,
          "content": "# https://github.com/golangci/golangci/wiki/Configuration\n\nservice:\n  project-path: github.com/Ullaakut/cameradar\n  prepare:\n    - apt-get update && apt-get install -y libcurl4-gnutls-dev\n    - dep ensure\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.65625,
          "content": "project_name: cameradar\ndist: dist/cameradar\n\nenv:\n  - GO111MODULE=on\nbefore:\n  hooks:\n    - go mod download\n\nbuilds:\n  - binary: cameradar\n    main: ./cmd/cameradar\n    goos:\n      - windows\n      - darwin\n      - linux\n    goarch:\n      - amd64\n      - 386\n      - arm\n      - arm64\n    goarm:\n      - 6\n      - 7\n\n    ignore:\n      - goos: darwin\n        goarch: 386\n\nchangelog:\n  skip: true\n\nchecksum:\n  name_template: \"{{ .ProjectName }}_checksums.txt\"\n\narchives:\n  - name_template: \"{{ .Binary }}_{{ .Os }}_{{ .Arch }}{{ if .Arm}}v{{ .Arm }}{{ end }}\"\n    format: tar.gz\n    format_overrides:\n      - goos: windows\n        format: zip\n    files:\n      - CHANGELOG.md"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.1513671875,
          "content": "dist: trusty\nsudo: required\nlanguage: go\n\naddons:\n  apt:\n    packages:\n    # needed for the nfpm pipe:\n    - rpm\n    # needed for the snap pipe:\n    - snapd\n\nenv:\n  - GO111MODULE=on\n  # needed for the snap pipe:\n  - PATH=/snap/bin:$PATH\n\nservices:\n  - docker\n\nbefore_install:\n- echo \"Testing Docker Hub credentials\"\n- if [[ \"$DOCKER_PASSOWRD\" != \"\" ]]; then docker login -u=$DOCKER_USERNAME -p=$DOCKER_PASSWORD; fi\n- echo \"Docker Hub credentials are working\"\n# If I see one day that Travis CI updates their default docker version\n# I can remove the lines below. That's why I leave this here :-)\n- docker version\n- sudo apt-get remove docker docker-engine docker.io\n- curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n- sudo apt-get update\n- sudo apt-get install -y docker-ce nmap libcurl4-openssl-dev\n- go get github.com/mattn/goveralls\n- docker version\n\ninstall:\n- docker build -t cameradar .\n\nscript:\n# Run unit tests\n- GO111MODULE=on go test -v -covermode=count -coverprofile=coverage.out\n- GO111MODULE=on $HOME/gopath/bin/goveralls -coverprofile=coverage.out -service=travis-ci -repotoken=$COVERALLS_TOKEN\n# Launch fake cameras to check if cameradar is able to access them\n- docker run -d --name=\"fake_camera_digest\" -e RTSP_ROUTE=\"/live.sdp\" -e RTSP_USERNAME=\"admin\" -e RTSP_PASSWORD=\"12345\" -e RTSP_AUTHENTICATION_METHOD=\"digest\" -p 8554:8554 ullaakut/rtspatt\n- docker run -d --name=\"fake_camera_basic\" -e RTSP_ROUTE=\"/live.sdp\" -e RTSP_USERNAME=\"root\" -e RTSP_PASSWORD=\"root\" -e RTSP_AUTHENTICATION_METHOD=\"digest\" -p 5554:5554 ullaakut/rtspatt\n# Launch cameradar on the local machine\n- docker run --net=host -t cameradar -t 0.0.0.0 -p 8554,5554 -v > logs.txt\n# Gather the logs from the cameras\n- docker logs fake_camera_digest > camera_digest_logs.txt\n- docker logs fake_camera_basic > camera_basic_logs.txt\n# Stop the fake cameras\n- docker stop fake_camera_basic\n- docker stop fake_camera_digest\n# Print logs\n- cat camera_digest_logs.txt\n- cat camera_basic_logs.txt\n- cat logs.txt\n- grep \"Successful attack\" logs.txt || exit 1\n- git clean -fd\n\nnotifications:\n  email:\n    recipients:\n      - brendan.le-glaunec@epitech.eu\n    on_success: never\n    on_failure: always\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.0302734375,
          "content": "# Build stage\nFROM golang:alpine AS build-env\n\nCOPY . /go/src/github.com/Ullaakut/cameradar\nWORKDIR /go/src/github.com/Ullaakut/cameradar/cmd/cameradar\n\nRUN apk update && \\\n    apk upgrade && \\\n    apk add nmap nmap-nselibs nmap-scripts \\\n    curl curl-dev \\\n    gcc \\\n    libc-dev \\\n    git \\\n    pkgconfig\nENV GO111MODULE=on\nRUN go version\nRUN go build -o cameradar\n\n# Final stage\nFROM alpine\n\n# Necessary to install curl v7.64.0-r3.\n# Fix for https://github.com/Ullaakut/cameradar/issues/247\nRUN echo 'http://dl-cdn.alpinelinux.org/alpine/v3.9/main' >> /etc/apk/repositories\n\nRUN apk --update add --no-cache nmap \\\n    nmap-nselibs \\\n    nmap-scripts \\\n    curl-dev==7.64.0-r5\n\nWORKDIR /app/cameradar\nCOPY --from=build-env /go/src/github.com/Ullaakut/cameradar/dictionaries/ /app/dictionaries/\nCOPY --from=build-env /go/src/github.com/Ullaakut/cameradar/cmd/cameradar/ /app/cameradar/\n\nENV CAMERADAR_CUSTOM_ROUTES=\"/app/dictionaries/routes\"\nENV CAMERADAR_CUSTOM_CREDENTIALS=\"/app/dictionaries/credentials.json\"\n\nENTRYPOINT [\"/app/cameradar/cameradar\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.998046875,
          "content": "Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.4658203125,
          "content": "# Cameradar\n\n<p align=\"center\">\n    <img src=\"images/Cameradar.gif\" width=\"100%\"/>\n</p>\n\n<p align=\"center\">\n    <a href=\"#license\">\n        <img src=\"https://img.shields.io/badge/license-Apache-blue.svg?style=flat\" />\n    </a>\n    <a href=\"https://hub.docker.com/r/ullaakut/cameradar/\">\n        <img src=\"https://img.shields.io/docker/pulls/ullaakut/cameradar.svg?style=flat\" />\n    </a>\n    <a href=\"https://travis-ci.org/Ullaakut/cameradar\">\n        <img src=\"https://travis-ci.org/Ullaakut/cameradar.svg?branch=master\" />\n    </a>\n    <a href='https://coveralls.io/github/Ullaakut/cameradar?branch=master'>\n        <img src='https://coveralls.io/repos/github/Ullaakut/cameradar/badge.svg?branch=master' alt='Coverage Status' />\n    </a>\n    <a href=\"https://golangci.com/r/github.com/ullaakut/cameradar\">\n        <img src=\"https://golangci.com/badges/github.com/ullaakut/cameradar.svg\" />\n    </a>\n    <a href=\"https://goreportcard.com/report/github.com/ullaakut/cameradar\">\n        <img src=\"https://goreportcard.com/badge/github.com/ullaakut/cameradar\" />\n    </a>\n    <a href=\"https://github.com/ullaakut/cameradar/releases/latest\">\n        <img src=\"https://img.shields.io/github/release/Ullaakut/cameradar.svg?style=flat\" />\n    </a>\n    <a href=\"https://godoc.org/github.com/ullaakut/cameradar\">\n        <img src=\"https://godoc.org/github.com/ullaakut/cameradar?status.svg\" />\n    </a>\n</p>\n\n## An RTSP stream access tool that comes with its library\n\n### Cameradar allows you to\n\n* **Detect open RTSP hosts** on any accessible target host\n* Detect which device model is streaming\n* Launch automated dictionary attacks to get their **stream route** (e.g.: `/live.sdp`)\n* Launch automated dictionary attacks to get the **username and password** of the cameras\n* Retrieve a complete and user-friendly report of the results\n\n<p align=\"center\"><img src=\"images/Cameradar.png\" width=\"250\"/></p>\n\n## Table of content\n\n* [Docker Image](#docker-image)\n* [Configuration](#configuration)\n* [Output](#output)\n* [Check camera access](#check-camera-access)\n* [Command-line options](#command-line-options)\n* [Contribution](#contribution)\n* [Frequently Asked Questions](#frequently-asked-questions)\n* [License](#license)\n\n## Docker Image for Cameradar\n\n<p align=\"center\"><img src=\"images/CameradarV4.png\" width=\"70%\"/></p>\n\nInstall [docker](https://docs.docker.com/engine/installation/) on your machine, and run the following command:\n\n```bash\ndocker run -t ullaakut/cameradar -t <target> <other command-line options>\n```\n\n[See command-line options](#command-line-options).\n\ne.g.: `docker run -t ullaakut/cameradar -t 192.168.100.0/24` will scan the ports 554, 5554 and 8554 of hosts on the 192.168.100.0/24 subnetwork and attack the discovered RTSP streams and will output debug logs.\n\n* `YOUR_TARGET` can be a subnet (e.g.: `172.16.100.0/24`), an IP (e.g.: `172.16.100.10`), or a range of IPs (e.g.: `172.16.100.10-20`).\n* If you want to get the precise results of the nmap scan in the form of an XML file, you can add `-v /your/path:/tmp/cameradar_scan.xml` to the docker run command, before `ullaakut/cameradar`.\n* If you use the `-r` and `-c` options to specify your custom dictionaries, make sure to also use a volume to add them to the docker container. Example: `docker run -t -v /path/to/dictionaries/:/tmp/ ullaakut/cameradar -r /tmp/myroutes -c /tmp/mycredentials.json -t mytarget`\n\n## Installing the binary on your machine\n\nOnly use this solution if for some reason using docker is not an option for you or if you want to locally build Cameradar on your machine.\n\n**WARNING**: Manually building the binary will **NOT WORK** for any camera that uses **DIGEST AUTHENTICATION** [if your version of `curl` is over `7.64.0`](https://github.com/Ullaakut/cameradar/pull/252), which is most likely the case. For more information, see [this response on the subject from the author of curl](https://stackoverflow.com/a/59778142/4145098).\n\n### Dependencies\n\n* `go` (> `1.10`)\n* `libcurl` development library (**[version has to be <7.66.0](https://github.com/Ullaakut/cameradar/issues/247)**)\n    * For apt users: `apt install libcurl4-openssl-dev`\n\n### Steps to install\n\n1. `go install github.com/Ullaakut/cameradar/v5/cmd/cameradar@latest`\n\nThe `cameradar` binary is now in your `$GOPATH/bin` ready to be used. See command line options [here](#command-line-options).\n\n## Configuration\n\nThe **RTSP port used for most cameras is 554**, so you should probably specify 554 as one of the ports you scan. Not specifying any ports to the cameradar application will scan the 554, 5554 and 8554 ports.\n\n`docker run -t --net=host ullaakut/cameradar -p \"18554,19000-19010\" -t localhost` will scan the ports `18554`, and the range of ports between `19000` and `19010` on `localhost`.\n\nYou **can use your own files for the credentials and routes dictionaries** used to attack the cameras, but the Cameradar repository already gives you a good base that works with most cameras, in the `/dictionaries` folder.\n\n```bash\ndocker run -t -v /my/folder/with/dictionaries:/tmp/dictionaries \\\n           ullaakut/cameradar \\\n           -r \"/tmp/dictionaries/my_routes\" \\\n           -c \"/tmp/dictionaries/my_credentials.json\" \\\n           -t 172.19.124.0/24\n```\n\nThis will put the contents of your folder containing dictionaries in the docker image and will use it for the dictionary attack instead of the default dictionaries provided in the cameradar repo.\n\n## Check camera access\n\nIf you have [VLC Media Player](http://www.videolan.org/vlc/), you should be able to use the GUI or the command-line to connect to the RTSP stream using this format: `rtsp://username:password@address:port/route`\n\n## Command-line options\n\n* **\"-t, --targets\"**: Set target. Required. Target can be a file (see [instructions on how to format the file](#format-input-file)), an IP, an IP range, a subnetwork, or a combination of those. Example: `--targets=\"192.168.1.72,192.168.1.74\"`\n* **\"-p, --ports\"**: (Default: `554,5554,8554`) Set custom ports.\n* **\"-s, --scan-speed\"**: (Default: `4`) Set custom nmap discovery presets to improve speed or accuracy. It's recommended to lower it if you are attempting to scan an unstable and slow network, or to increase it if on a very performant and reliable network. You might also want to keep it low to keep your discovery stealthy. See [this for more info on the nmap timing templates](https://nmap.org/book/man-performance.html).\n* **\"-I, --attack-interval\"**: (Default: `0ms`) Set custom interval after which an attack attempt without an answer should give up. It's recommended to increase it when attempting to scan unstable and slow networks or to decrease it on fast and reliable networks.\n* **\"-T, --timeout\"**: (Default: `2000ms`) Set custom timeout value after which an attack attempt without an answer should give up. It's recommended to increase it when attempting to scan unstable and slow networks or to decrease it on fast and reliable networks.\n* **\"-r, --custom-routes\"**: (Default: `<CAMERADAR_GOPATH>/dictionaries/routes`) Set custom dictionary path for routes\n* **\"-c, --custom-credentials\"**: (Default: `<CAMERADAR_GOPATH>/dictionaries/credentials.json`) Set custom dictionary path for credentials\n* **\"-o, --nmap-output\"**: (Default: `/tmp/cameradar_scan.xml`) Set custom nmap output path\n* **\"-d, --debug\"**: Enable debug logs\n* **\"-v, --verbose\"**: Enable verbose curl logs (not recommended for most use)\n* **\"-h\"**: Display the usage information\n\n## Format input file\n\nThe file can contain IPs, hostnames, IP ranges and subnetwork, separated by newlines. Example:\n\n```text\n0.0.0.0\nlocalhost\n192.17.0.0/16\n192.168.1.140-255\n192.168.2-3.0-255\n```\n\n## Environment Variables\n\n### `CAMERADAR_TARGET`\n\nThis variable is mandatory and specifies the target that cameradar should scan and attempt to access RTSP streams on.\n\nExamples:\n\n* `172.16.100.0/24`\n* `192.168.1.1`\n* `localhost`\n* `192.168.1.140-255`\n* `192.168.2-3.0-255`\n\n### `CAMERADAR_PORTS`\n\nThis variable is optional and allows you to specify the ports on which to run the scans.\n\nDefault value: `554,5554,8554`\n\nIt is recommended not to change these except if you are certain that cameras have been configured to stream RTSP over a different port. 99.9% of cameras are streaming on these ports.\n\n### `CAMERADAR_NMAP_OUTPUT_FILE`\n\nThis variable is optional and allows you to specify on which file nmap will write its output.\n\nDefault value: `/tmp/cameradar_scan.xml`\n\nThis can be useful only if you want to read the files yourself, if you don't want it to write in your `/tmp` folder, or if you want to use only the RunNmap function in cameradar, and do its parsing manually.\n\n### `CAMERADAR_CUSTOM_ROUTES`, `CAMERADAR_CUSTOM_CREDENTIALS`\n\nThese variables are optional, allowing to replace the default dictionaries with custom ones, for the dictionary attack.\n\nDefault values: `<CAMERADAR_GOPATH>/dictionaries/routes` and `<CAMERADAR_GOPATH>/dictionaries/credentials.json`\n\n### `CAMERADAR_SCAN_SPEED`\n\nThis optional variable allows you to set custom nmap discovery presets to improve speed or accuracy. It's recommended to lower it if you are attempting to scan an unstable and slow network, or to increase it if on a fast and reliable network. See [this for more info on the nmap timing templates](https://nmap.org/book/man-performance.html).\n\nDefault value: `4`\n\n### `CAMERADAR_ATTACK_INTERVAL`\n\nThis optional variable allows you to set `custom interval` to wait between each attack in order to stay stealthy. It's recommended to increase it when attempting to scan a network that might be protected against bruteforce attacks. By default, there is no interval, in order to make attacks as fast as possible\n\nDefault value: `0ms`\n\n### `CAMERADAR_TIMEOUT`\n\nThis optional variable allows you to set custom timeout value after which an attack attempt without an answer should give up. It's recommended to increase it when attempting to scan unstable and slow networks or to decrease it on fast and reliable networks.\n\nDefault value: `2000ms`\n\n### `CAMERADAR_LOGGING`\n\nThis optional variable allows you to enable a more verbose output to have more information about what is going on.\n\nIt will output nmap results, cURL requests, etc.\n\nDefault: `false`\n\n## Contribution\n\n### Build\n\n#### Docker build\n\nTo build the docker image, simply run `docker build . -t cameradar` in the root of the project.\n\nYour image will be called `cameradar` and NOT `ullaakut/cameradar`.\n\n#### Go build\n\n1. `go get github.com/Ullaakut/cameradar`\n2. `cd $GOPATH/src/github.com/Ullaakut/cameradar`\n3. `cd cmd/cameradar`\n4. `go install`\n\nThe cameradar binary is now in `$GOPATH/bin/cameradar`.\n\n## Frequently Asked Questions\n\n> Cameradar does not detect any camera!\n\nThat means that either your cameras are not streaming in RTSP or that they are not on the target you are scanning. In most cases, CCTV cameras will be on a private subnetwork, isolated from the internet. Use the `-t` option to specify your target. If you are sure you did everything right but it still does not work, please open an issue with details on the device you are trying to access 🙏\n\n> Cameradar detects my cameras, but does not manage to access them at all!\n\nMaybe your cameras have been configured, and the credentials / URL have been changed. Cameradar only guesses using default constructor values if a custom dictionary is not provided. You can use your own dictionaries in which you just have to add your credentials and RTSP routes. To do that, see how the [configuration](#configuration) works. Also, maybe your camera's credentials are not yet known, in which case if you find them it would be very nice to add them to the Cameradar dictionaries to help other people in the future.\n\n> What happened to the C++ version?\n\nYou can still find it under the 1.1.4 tag on this repo, however it was slower and less stable than the current version written in Golang. It is not recommended using it.\n\n> How to use the Cameradar library for my own project?\n\nSee the example in `/cmd/cameradar`. You just need to run `go get github.com/Ullaakut/cameradar` and to use the `cameradar` package in your code. You can find the documentation on [godoc](https://godoc.org/github.com/ullaakut/cameradar).\n\n> I want to scan my own localhost for some reason, and it does not work! What's going on?\n\nUse the `--net=host` flag when launching the cameradar image, or use the binary by running `go run cameradar/cameradar.go` or [installing it](#go-build).\n\n> I don't see a colored output:(\n\nYou forgot the `-t` flag before `ullaakut/cameradar` in your command-line. This tells docker to allocate a pseudo-tty for cameradar, which makes it able to use colors.\n\n> I don't have a camera, but I'd like to try Cameradar!\n\nSimply run `docker run -p 8554:8554 -e RTSP_USERNAME=admin -e RTSP_PASSWORD=12345 -e RTSP_PORT=8554 ullaakut/rtspatt` and then run cameradar, and it should guess that the username is admin and that the password is 12345. You can try this with any default constructor credentials (they can be found [here](dictionaries/credentials.json)).\n\n> What authentication types does Cameradar support?\n\nCameradar supports both basic and digest authentication.\n\n## Examples\n\n> Running cameradar on your own machine to scan for default ports\n\n`docker run --net=host -t ullaakut/cameradar -t localhost`\n\n> Running cameradar with an input file, logs enabled on port 8554\n\n`docker run -v /tmp:/tmp --net=host -t ullaakut/cameradar -t /tmp/test.txt -p 8554`\n\n> Running cameradar on a subnetwork with custom dictionaries, on ports 554, 5554 and 8554\n\n`docker run -v /tmp:/tmp --net=host -t ullaakut/cameradar -t 192.168.0.0/24 --custom-credentials=\"/tmp/dictionaries/credentials.json\" --custom-routes=\"/tmp/dictionaries/routes\" -p 554,5554,8554`\n\n## License\n\nCopyright 2023 Ullaakut\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README_RU.md",
          "type": "blob",
          "size": 23.0654296875,
          "content": "# Cameradar\n\n<p align=\"center\">\n    <img src=\"images/Cameradar.gif\" width=\"100%\"/>\n</p>\n\n<p align=\"center\">\n    <a href=\"#license\">\n        <img src=\"https://img.shields.io/badge/license-Apache-blue.svg?style=flat\" />\n    </a>\n    <a href=\"https://hub.docker.com/r/ullaakut/cameradar/\">\n        <img src=\"https://img.shields.io/docker/pulls/ullaakut/cameradar.svg?style=flat\" />\n    </a>\n    <a href=\"https://travis-ci.org/Ullaakut/cameradar\">\n        <img src=\"https://travis-ci.org/Ullaakut/cameradar.svg?branch=master\" />\n    </a>\n    <a href='https://coveralls.io/github/Ullaakut/cameradar?branch=master'>\n        <img src='https://coveralls.io/repos/github/Ullaakut/cameradar/badge.svg?branch=master' alt='Coverage Status' />\n    </a>\n    <a href=\"https://golangci.com/r/github.com/ullaakut/cameradar\">\n        <img src=\"https://golangci.com/badges/github.com/ullaakut/cameradar.svg\" />\n    </a>\n    <a href=\"https://goreportcard.com/report/github.com/ullaakut/cameradar\">\n        <img src=\"https://goreportcard.com/badge/github.com/ullaakut/cameradar\" />\n    </a>\n    <a href=\"https://github.com/ullaakut/cameradar/releases/latest\">\n        <img src=\"https://img.shields.io/github/release/Ullaakut/cameradar.svg?style=flat\" />\n    </a>\n    <a href=\"https://godoc.org/github.com/ullaakut/cameradar\">\n        <img src=\"https://godoc.org/github.com/ullaakut/cameradar?status.svg\" />\n    </a>\n</p>\n\n## RTSP stream потоковы протокол со своей библиотекой\n\n### Возможности Cameradar\n\n* **Обнаружить открытые RTSP-хосты** на любом доступном целевом узле.\n* Определить, какая модель устройства осуществляет потоковое вещание\n* Запускать автоматический перебор по словарю для получения **маршрута потока** (например: `/live.sdp`)\n* Запустить автоматические перебор по словарю для получения **имени пользователя и пароля** камер.\n* Получить полный и удобный отчет о результатах.\n\n<p align=\"center\"><img src=\"images/Cameradar.png\" width=\"250\"/></p>\n\n## Оглавление \n\n* [Docker Image](#docker-image)\n* [Зависмости](#configuration)\n* [Вывод](#output)\n* [Параметры командной строки](#command-line-options)\n* [Вклад](#contribution)\n* [Часто задаваемые вопросы](#frequently-asked-questions)\n* [Лицензия](#license)\n\n## Docker для Cameradar\n\n<p align=\"center\"><img src=\"images/CameradarV4.png\" width=\"70%\"/></p>\n* У\nУстоновка [docker](https://docs.docker.com/engine/installation/) на свою машину и запустить команду:\n\n```bash\ndocker run -t ullaakut/cameradar -t <target> <other command-line options>\n```\n\n[Параметры командной строки](#command-line-options).\n\nПример: `docker run -t ullaakut/cameradar -t 192.168.100.0/24` будет сканировать порты 554, 5554 и 8554 хостов в подсети 192.168.100.0/24 и перебирать обнаруженные RTSP-stream и выводить журнал отладки.\n*YOUR_TARGET может быть подсетью (например: 172.16.100.0/24), IP (например: 172.16.100.10) или диапазоном IPs (например: 172.16.100.10-20).\n* Если вы хотите получить точные результаты сканирования nmap в виде XML файла, вы можете добавить `-v /your/path:/tmp/cameradar_scan.xml` в команду docker run, перед `ullaakut/cameradar`.\n* Если вы используете `-r` и `-c` для указания ваших пользовательских словарей, убедитесь, что вы также используете  для добавления их в контейнер docker. Пример: `docker run -t -v /path/to/dictionaries/:/tmp/ ullaakut/cameradar -r /tmp/myroutes -c /tmp/mycredentials.json -t mytarget`.\n\n## Бинарная устоновка\nРешение локального Camader без использование docker.\n\n\n\n**WARNING**: Бинарная устновка **НЕ БУДЕТ РАБОТАТЬ** для камер, которые используют **DIGEST AUTHENTICATION** [если ваша версия `curl` старше `7.64.0`](https://github.com/Ullaakut/cameradar/pull/252), то скорее всего, так и есть. Дополнильная информация [this response on the subject from the author of curl](https://stackoverflow.com/a/59778142/4145098).\n\n### Зависимости\n\n* `go` (> `1.10`)\n* `libcurl` библиотека (**[version has to be <7.66.0](https://github.com/Ullaakut/cameradar/issues/247)**)\n* Для apt: `apt install libcurl4-openssl-dev`\n\n### Этапы устоновки\n\n1. `go install github.com/Ullaakut/cameradar/v5/cmd/cameradar@latest`\n\nБинарный файл `cameradar` находится здесь `$GOPATH/bin` и готов к использованию. Опции командной строки  [здесь](#command-line-options).\n\n## Конфигурация \n\nПорт **RTSP, используемый для большинства камер, 554**, поэтому указываем  554 в качестве одного из сканируемых портов. Если не прописать порты в приложении cameradar, оно будет искать порты 554, 5554 и 8554.\n\n`docker run -t --net=host ullaakut/cameradar -p \"18554,19000-19010\" -t localhost`  будет сканировать порты `18554`, и диапазон портов между `19000` и `19010` на `localhost`.\n\nВы **можете использовать свои собственные файлы для словарей учетных данных и маршрутов**, используемых для атаки на камеры, но репозиторий Cameradar уже предоставляет вам хорошую базу, которая работает с большинством камер, в папке `/dictionaries`.\n\n```bash\ndocker run -t -v /my/folder/with/dictionaries:/tmp/dictionaries \\\nullaakut/cameradar \\\n-r \"/tmp/dictionaries/my_routes\" \\\n-c \"/tmp/dictionaries/my_credentials.json\" \\\n-t 172.19.124.0/24\n```\n\nЭто поместит содержимое вашей папки со словарями в образ докера и будет использовать его для перебора словаря, вместо словарей по умолчанию, предоставленных в репозитории cameradar.\n\n## Доступ камеры \n\nЕсли у вас есть [VLC Media Playe](http://www.videolan.org/vlc/), у вас есть  возможность использовать графический интерфейс или командную строку для подключения к потоку RTSP, для этого используется этот формат `rtsp://username:password@address:port/route`.\n\n## Опции командной строки \n\n* ** \"-t, --targets \"**: Устанавливаем цель.Целью может быть файл (см. [инструкции по форматированию файла](#format-input-file)), IP, диапазон IP, подсеть или их комбинация. Пример: `--targets=\"192.168.1.72,192.168.1.74\"`\n* ** \"-p, --ports \"**: (По умолчанию: `554,5554,8554`) Устанавливаем пользовательские порты.\n* ** \"-s, --scan-speed \"**: (По умолчанию: `4`) Установка пользовательских настроек обнаружения nmap для повышения скорости или точности. Рекомендуется уменьшить это значение, если вы пытаетесь сканировать нестабильную и медленную сеть, или увеличить его, если вы работаете в очень производительной и надежной сети. Вы также можете оставить значение  низким, чтобы  уменшить вероятность обнуружения. Смотрите [здесь более подробная информация о шаблонах синхронизации nmap] (https://nmap.org/book/man-performance.html).\n* ** \"-I, --attack-interval \"**: (По умолчанию: `0ms`) Задает пользовательский интервал, после которого попытка атаки без ответа должна прекратиться. Рекомендуется увеличить его при попытке сканирования нестабильных и медленных сетей или уменьшить в быстрых и надежных сетях.\n* ** \"-T, --timeout \"**: (По умолчанию: `2000 мс`) Задает пользовательское значение тайм-аута, после которого попытка атаки без ответа должна прекратиться. Рекомендуется увеличить это значение при попытке сканирования нестабильных и медленных сетей или уменьшить его в быстрых и надежных сетях.\n* ** \"-r, --custom-routes \"**: (По умолчанию: `<CAMERADAR_GOPATH>/dictionaries/routes`) Устанавливает путь к пользовательскому словарю для маршрутов.\n* ** \"-c, --custom-credentials \"**: (По умолчанию: `<CAMERADAR_GOPATH>/dictionaries/credentials.json`) Устанавливает путь к пользовательскому словарю для учетных данных\n* ** \"-o, --nmap-output \"**: (По умолчанию: `/tmp/cameradar_scan.xml`) устанавливаем путь вывода nmap.\n* **\"-d, --debug \"**: Включаем журналы отладки\n* **\"-v, --verbose \"**: Включаем  журналы curl (не рекомендуется для большинства пользователей)\n* **\"-h \"**: Отображаем использованную информацию\n\n## Форматирование входного файла \n\nФайл может содержать IP-адреса, имена хостов, диапазоны IP-адресов и подсети, разделенные на строки. Например:\n\n```text\n0.0.0.0\nlocalhost\n192.17.0.0/16\n192.168.1.140-255\n192.168.2-3.0-255\n```\n\n## Переменные среды\n\n### `CAMERADAR_TARGET`\n\nЭта переменная  обязательная и указывает цель, которую cameradar должен сканировать и пытаться получить доступ к потокам RTSP.\n\nНапример:\n\n* `172.16.100.0/24`\n* `192.168.1.1`\n* `localhost`\n* `192.168.1.140-255`\n* `192.168.2-3.0-255`\n\n### `CAMERADAR_PORTS`\n\nЭта переменная не обязательная,нужна для того, чтоб указать сканируемые порты \n\nЗначение по умолчанию  `554,5554,8554`\n\nРекомендуется не изменять их, кроме случаев, когда вы уверены, что камеры были настроены на передачу RTSP через другой порт. 99,9% камер передают поток через эти порты.\n\n### `CAMERADAR_NMAP_OUTPUT_FILE`\n\nЭта переменная является необязательной и позволяет указать, в какой файл nmap будет записывать свой вывод.\n\nЗначение по умолчанию: `/tmp/cameradar_scan.xml`\n\nЭто может быть полезно, только для самотятельного чтения файлов, если вы не хотите, чтобы он записывал данные в вашу папку `/tmp`, или если вы хотите использовать только функцию RunNmap в cameradar, и делать ее разбор вручную.\n\n### `CAMERADAR_CUSTOM_ROUTES`, `CAMERADAR_CUSTOM_CREDENTIALS`\n\nЭти переменные являются необязательными и позволяют заменить словари по умолчанию на пользовательские, Это нужно для перебора по словарю.\n\nЗначение по умолчанию: `<CAMERADAR_GOPATH>/dictionaries/routes` and `<CAMERADAR_GOPATH>/dictionaries/credentials.json`\n\n### `CAMERADAR_SCAN_SPEED`\n\nЭта опцианальная  переменная позволяет установить пользовательские настройки  обнаружения nmap для повышения скорости и точности. Рекомендуется уменьшить значение, если вы пытаетесь сканировать нестабильную и медленную сеть, или увеличить, если сеть быстрая и надежная. Дополнительные сведения о временных шаблонах nmap смотреть [здесь](https://nmap.org/book/man-performance.html).\n\nЗначение по умолчанию: `4`\n\n### `CAMERADAR_ATTACK_INTERVAL`\n\nЭта не обязательная переменная позволяет установить `custom interval` между каждой атакой, чтобы оставаться незаметным. Рекомендуется увеличивать его при попытке сканирования сети, которая может быть защищена от атак методом перебора. По умолчанию интервал отсутствует, чтобы сделать атаки как можно более быстрыми.\n\nЗначение по умолчанию: `0ms`\n\n### `CAMERADAR_TIMEOUT`\n\nЭта необязательная переменная дает возмоджность установить пользовательское значение тайм-аута, по истечении которого попытка атаки без ответа должна прекратиться. Рекомендуется увеличить это значение при попытке сканирования нестабильных и медленных сетей или уменьшить его в быстрых и надежных сетях.\n\nЗначение по умолчанию: `2000ms`\n\n### `CAMERADAR_LOGGING`\n\nЭта необязательная переменная позволяет вам включить более расширенный вывод, чтобы иметь больше информации о процессах.\n\nОна будет выводить результаты nmap, запросы cURL и т.д.\n\nЗначение по умолчанию: `false`\n\n## Вклад\n\n### Сборка \n\n#### Docker build\n\nЧтобы собрать образ докера, просто выполните команду `docker build . -t cameradar` в корне проекта.\n\nВаше изображение будет называться `cameradar`, а НЕ `ullaakut/cameradar`.\n\n#### Приступим к сборке \n\n1. `go get github.com/Ullaakut/cameradar`\n2. `cd $GOPATH/src/github.com/Ullaakut/cameradar`\n3. `cd cmd/cameradar`\n4. `go install`\n\nБинарный файл cameradar теперь находится в `$GOPATH/bin/cameradar`.\n\n## Часто задаваемые вопросы\n\n> Cameradar не находит не одной камеры!\n\nЭто означает, что либо ваши камеры не передают поток в RTSP, либо их нет на объекте, который вы сканируете. В большинстве случаев камеры видеонаблюдения находятся в частной подсети, изолированной от Интернета. Используйте опцию `-t` для указания цели. Если вы уверены, что все сделали правильно, но это все равно не работает, пожалуйста, откройте проблему с подробной информацией об устройстве, к которому вы пытаетесь получить доступ.\n\n> Cameradar нашел мои камеры, но не может получить доступ к ним \n\nВозможно, ваши камеры были настроены, и учетные данные / URL были изменены. Cameradar только угадывает, используя значения конструктора по умолчанию, если не предоставлен пользовательский словарь. Вы можете использовать свои собственные словари, в которые нужно просто добавить ваши учетные данные и маршруты RTSP. Для этого посмотрите, как работает [configuration](#configuration). Также, возможно, учетные данные вашей камеры еще не известны, в таком случае, если вы их найдете, было бы очень хорошо добавить их в словари Cameradar, чтобы помочь другим людям в будущем.\n\n> Что случилось с версией на  C++?\n\nВы все еще можете найти его под тегом 1.1.4 в этом репозитории, однако он был медленнее и менее стабилен, чем текущая версия, написанная на Golang. Использовать ее не рекомендуется.\n\n> Как использовать библиотеку Cameradar для моего собственного проекта?\n\nСмотрите пример в `/cmd/cameradar`. Вам просто нужно запустить `go get github.com/Ullaakut/cameradar` и использовать пакет `cameradar` в своем коде. Документацию можно найти на [godoc](https://godoc.org/github.com/ullaakut/cameradar).\n\n> Я почему-то хочу просканировать свой собственный localhost, а он не работает! \n\nИспользуйте флаг `--net=host` при запуске образа cameradar, или используйте бинарный файл, выполнив команду `go run cameradar/cameradar.go` или [установив его](#go-build).\n\n> Я не вижу цветного вывода :(\n\nВероятнее вы  забыли использовать флаг `-t` перед `ullaakut/cameradar` в вашей командной строке. Это указывается  -tty для cameradar, что позволит ему использовать цвета.\n\n> У меня нет камеры, но я хотел бы попробовать Cameradar!\n\nПросто воспользуйтесь командой `docker run -p 8554:8554 -e RTSP_USERNAME=admin -e RTSP_PASSWORD=12345 -e RTSP_PORT=8554 ullaakut/rtspatt` и запустите cameradar, и он должен определить, что имя пользователя - admin, а пароль - 12345. Вы можете попробовать это с любыми учетными данными конструктора по умолчанию (их можно найти [здесь](dictionaries/credentials.json)).\n\n> Какие типы аутентификации поддерживает Cameradar?\n\nCameradar поддерживает как базовую, так и дайджест-аутентификацию.\n\n\n## Примеры \n\n>> Запуск cameradar на вашей собственной машине для сканирования портов по умолчанию\n\n`docker run --net=host -t ullaakut/cameradar -t localhost`\n\n> Запуск cameradar с входным файлом, включение журналов на порту 8554\n\n`docker run -v /tmp:/tmp --net=host -t ullaakut/cameradar -t /tmp/test.txt -p 8554`\n\n> Запуск cameradar в подсети с пользовательскими словарями, на портах 554, 5554 и 8554\n\n`docker run -v /tmp:/tmp --net=host -t ullaakut/cameradar -t 192.168.0.0/24 --custom-credentials=\"/tmp/dictionaries/credentials.json\" --custom-routes=\"/tmp/dictionaries/routes\" -p 554,5554,8554`.\n\n## Лицензия \n\nCopyright 2023 Ullaakut\n\nНастоящим предоставляется бесплатное разрешение любому лицу, получившему копию\nданного программного обеспечения и сопутствующих файлов документации (\"Программное обеспечение\"), совершать сделки с  Программным обеспечением без ограничений, включая, без ограничения, права\nиспользовать, копировать, изменять, объединять, публиковать, распространять, выдавать сублицензии и/или продавать\nкопии программного обеспечения, а также разрешать лицам, которым предоставляется Программное обеспечение\nделать это, при соблюдении следующих условий:\n\nВышеуказанное уведомление об авторском праве и данное уведомление о разрешении должны быть включены во все\nкопиях или существенных частях Программного обеспечения.\n\nПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ \"КАК ЕСТЬ\", БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ\nПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ГАРАНТИЯМИ ТОВАРНОГО СОСТОЯНИЯ,\nПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ И НЕНАРУШЕНИЯ ПРАВ. НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТВАХ\nАВТОРЫ ИЛИ ВЛАДЕЛЬЦЫ АВТОРСКИХ ПРАВ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ЗА ЛЮБЫЕ ПРЕТЕНЗИИ, УБЫТКИ ИЛИ ДРУГУЮ\nОТВЕТСТВЕННОСТЬ, БУДЬ ТО В РАМКАХ ДОГОВОРНОГО, ДЕЛИКТНОГО ИЛИ ИНОГО ИСКА, ВОЗНИКАЮЩЕГО\nИЗ, В РЕЗУЛЬТАТЕ ИЛИ В СВЯЗИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ ИЛИ ИСПОЛЬЗОВАНИЕМ ИЛИ ИНЫМИ\nИСПОЛЬЗОВАНИЕМ ИЛИ ДРУГИМИ ДЕЙСТВИЯМИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ."
        },
        {
          "name": "attack.go",
          "type": "blob",
          "size": 10.12890625,
          "content": "package cameradar\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/Ullaakut/go-curl\"\n)\n\n// HTTP responses.\nconst (\n\thttpOK           = 200\n\thttpUnauthorized = 401\n\thttpForbidden    = 403\n\thttpNotFound     = 404\n)\n\n// CURL RTSP request types.\nconst (\n\trtspDescribe = 2\n\trtspSetup    = 4\n)\n\n// Authentication types.\nconst (\n\tauthNone   = 0\n\tauthBasic  = 1\n\tauthDigest = 2\n)\n\n// Route that should never be a constructor default.\nconst dummyRoute = \"/0x8b6c42\"\n\n// Attack attacks the given targets and returns the accessed streams.\nfunc (s *Scanner) Attack(targets []Stream) ([]Stream, error) {\n\tif len(targets) == 0 {\n\t\treturn nil, fmt.Errorf(\"no stream found\")\n\t}\n\n\t// Most cameras will be accessed successfully with these two attacks.\n\ts.term.StartStepf(\"Attacking routes of %d streams\", len(targets))\n\tstreams := s.AttackRoute(targets)\n\n\ts.term.StartStepf(\"Attempting to detect authentication methods of %d streams\", len(targets))\n\tstreams = s.DetectAuthMethods(streams)\n\n\ts.term.StartStepf(\"Attacking credentials of %d streams\", len(targets))\n\tstreams = s.AttackCredentials(streams)\n\n\ts.term.StartStep(\"Validating that streams are accessible\")\n\tstreams = s.ValidateStreams(streams)\n\n\t// But some cameras run GST RTSP Server which prioritizes 401 over 404 contrary to most cameras.\n\t// For these cameras, running another route attack will solve the problem.\n\tfor _, stream := range streams {\n\t\tif !stream.RouteFound || !stream.CredentialsFound || !stream.Available {\n\t\t\ts.term.StartStepf(\"Second round of attacks\")\n\t\t\tstreams = s.AttackRoute(streams)\n\n\t\t\ts.term.StartStep(\"Validating that streams are accessible\")\n\t\t\tstreams = s.ValidateStreams(streams)\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\ts.term.EndStep()\n\n\treturn streams, nil\n}\n\n// ValidateStreams tries to setup the stream to validate whether or not it is available.\nfunc (s *Scanner) ValidateStreams(targets []Stream) []Stream {\n\tfor i := range targets {\n\t\ttargets[i].Available = s.validateStream(targets[i])\n\t\ttime.Sleep(s.attackInterval)\n\t}\n\n\treturn targets\n}\n\n// AttackCredentials attempts to guess the provided targets' credentials using the given\n// dictionary or the default dictionary if none was provided by the user.\nfunc (s *Scanner) AttackCredentials(targets []Stream) []Stream {\n\tresChan := make(chan Stream)\n\tdefer close(resChan)\n\n\tfor i := range targets {\n\t\tgo s.attackCameraCredentials(targets[i], resChan)\n\t}\n\n\tfor range targets {\n\t\tattackResult := <-resChan\n\t\tif attackResult.CredentialsFound {\n\t\t\ttargets = replace(targets, attackResult)\n\t\t}\n\t}\n\n\treturn targets\n}\n\n// AttackRoute attempts to guess the provided targets' streaming routes using the given\n// dictionary or the default dictionary if none was provided by the user.\nfunc (s *Scanner) AttackRoute(targets []Stream) []Stream {\n\tresChan := make(chan Stream)\n\tdefer close(resChan)\n\n\tfor i := range targets {\n\t\tgo s.attackCameraRoute(targets[i], resChan)\n\t}\n\n\tfor range targets {\n\t\tattackResult := <-resChan\n\t\tif attackResult.RouteFound {\n\t\t\ttargets = replace(targets, attackResult)\n\t\t}\n\t}\n\n\treturn targets\n}\n\n// DetectAuthMethods attempts to guess the provided targets' authentication types, between\n// digest, basic auth or none at all.\nfunc (s *Scanner) DetectAuthMethods(targets []Stream) []Stream {\n\tfor i := range targets {\n\t\ttargets[i].AuthenticationType = s.detectAuthMethod(targets[i])\n\t\ttime.Sleep(s.attackInterval)\n\n\t\tvar authMethod string\n\t\tswitch targets[i].AuthenticationType {\n\t\tcase authNone:\n\t\t\tauthMethod = \"no\"\n\t\tcase authBasic:\n\t\t\tauthMethod = \"basic\"\n\t\tcase authDigest:\n\t\t\tauthMethod = \"digest\"\n\t\tdefault:\n\t\t\tauthMethod = \"unknown:\" + string(targets[i].AuthenticationType)\n\t\t}\n\n\t\ts.term.Debugf(\"Stream %s uses %s authentication method\\n\", GetCameraRTSPURL(targets[i]), authMethod)\n\t}\n\n\treturn targets\n}\n\nfunc (s *Scanner) attackCameraCredentials(target Stream, resChan chan<- Stream) {\n\tfor _, username := range s.credentials.Usernames {\n\t\tfor _, password := range s.credentials.Passwords {\n\t\t\tok := s.credAttack(target, username, password)\n\t\t\tif ok {\n\t\t\t\ttarget.CredentialsFound = true\n\t\t\t\ttarget.Username = username\n\t\t\t\ttarget.Password = password\n\t\t\t\tresChan <- target\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(s.attackInterval)\n\t\t}\n\t}\n\n\ttarget.CredentialsFound = false\n\tresChan <- target\n}\n\nfunc (s *Scanner) attackCameraRoute(target Stream, resChan chan<- Stream) {\n\t// If the stream responds positively to the dummy route, it means\n\t// it doesn't require (or respect the RFC) a route and the attack\n\t// can be skipped.\n\tok := s.routeAttack(target, dummyRoute)\n\tif ok {\n\t\ttarget.RouteFound = true\n\t\ttarget.Routes = append(target.Routes, \"/\")\n\t\tresChan <- target\n\t\treturn\n\t}\n\n\t// Otherwise, bruteforce the routes.\n\tfor _, route := range s.routes {\n\t\tok := s.routeAttack(target, route)\n\t\tif ok {\n\t\t\ttarget.RouteFound = true\n\t\t\ttarget.Routes = append(target.Routes, route)\n\t\t}\n\t\ttime.Sleep(s.attackInterval)\n\t}\n\n\tresChan <- target\n}\n\nfunc (s *Scanner) detectAuthMethod(stream Stream) int {\n\tc := s.curl.Duphandle()\n\n\tattackURL := fmt.Sprintf(\n\t\t\"rtsp://%s:%d/%s\",\n\t\tstream.Address,\n\t\tstream.Port,\n\t\tstream.Route(),\n\t)\n\n\ts.setCurlOptions(c)\n\n\t// Send a request to the URL of the stream we want to attack.\n\t_ = c.Setopt(curl.OPT_URL, attackURL)\n\t// Set the RTSP STREAM URI as the stream URL.\n\t_ = c.Setopt(curl.OPT_RTSP_STREAM_URI, attackURL)\n\t_ = c.Setopt(curl.OPT_RTSP_REQUEST, rtspDescribe)\n\n\t// Perform the request.\n\terr := c.Perform()\n\tif err != nil {\n\t\ts.term.Errorf(\"Perform failed for %q (auth %d): %v\", attackURL, stream.AuthenticationType, err)\n\t\treturn -1\n\t}\n\n\tauthType, err := c.Getinfo(curl.INFO_HTTPAUTH_AVAIL)\n\tif err != nil {\n\t\ts.term.Errorf(\"Getinfo failed: %v\", err)\n\t\treturn -1\n\t}\n\n\tif s.debug {\n\t\ts.term.Debugln(\"DESCRIBE\", attackURL, \"RTSP/1.0 >\", authType)\n\t}\n\n\treturn authType.(int)\n}\n\nfunc (s *Scanner) routeAttack(stream Stream, route string) bool {\n\tc := s.curl.Duphandle()\n\n\tattackURL := fmt.Sprintf(\n\t\t\"rtsp://%s:%s@%s:%d/%s\",\n\t\tstream.Username,\n\t\tstream.Password,\n\t\tstream.Address,\n\t\tstream.Port,\n\t\troute,\n\t)\n\n\ts.setCurlOptions(c)\n\n\t// Set proper authentication type.\n\t_ = c.Setopt(curl.OPT_HTTPAUTH, stream.AuthenticationType)\n\t_ = c.Setopt(curl.OPT_USERPWD, fmt.Sprint(stream.Username, \":\", stream.Password))\n\n\t// Send a request to the URL of the stream we want to attack.\n\t_ = c.Setopt(curl.OPT_URL, attackURL)\n\t// Set the RTSP STREAM URI as the stream URL.\n\t_ = c.Setopt(curl.OPT_RTSP_STREAM_URI, attackURL)\n\t_ = c.Setopt(curl.OPT_RTSP_REQUEST, rtspDescribe)\n\n\t// Perform the request.\n\terr := c.Perform()\n\tif err != nil {\n\t\ts.term.Errorf(\"Perform failed for %q (auth %d): %v\", attackURL, stream.AuthenticationType, err)\n\t\treturn false\n\t}\n\n\t// Get return code for the request.\n\trc, err := c.Getinfo(curl.INFO_RESPONSE_CODE)\n\tif err != nil {\n\t\ts.term.Errorf(\"Getinfo failed: %v\", err)\n\t\treturn false\n\t}\n\n\tif s.debug {\n\t\ts.term.Debugln(\"DESCRIBE\", attackURL, \"RTSP/1.0 >\", rc)\n\t}\n\t// If it's a 401 or 403, it means that the credentials are wrong but the route might be okay.\n\t// If it's a 200, the stream is accessed successfully.\n\tif rc == httpOK || rc == httpUnauthorized || rc == httpForbidden {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *Scanner) credAttack(stream Stream, username string, password string) bool {\n\tc := s.curl.Duphandle()\n\n\tattackURL := fmt.Sprintf(\n\t\t\"rtsp://%s:%s@%s:%d/%s\",\n\t\tusername,\n\t\tpassword,\n\t\tstream.Address,\n\t\tstream.Port,\n\t\tstream.Route(),\n\t)\n\n\ts.setCurlOptions(c)\n\n\t// Set proper authentication type.\n\t_ = c.Setopt(curl.OPT_HTTPAUTH, stream.AuthenticationType)\n\t_ = c.Setopt(curl.OPT_USERPWD, fmt.Sprint(username, \":\", password))\n\n\t// Send a request to the URL of the stream we want to attack.\n\t_ = c.Setopt(curl.OPT_URL, attackURL)\n\t// Set the RTSP STREAM URI as the stream URL.\n\t_ = c.Setopt(curl.OPT_RTSP_STREAM_URI, attackURL)\n\t_ = c.Setopt(curl.OPT_RTSP_REQUEST, rtspDescribe)\n\n\t// Perform the request.\n\terr := c.Perform()\n\tif err != nil {\n\t\ts.term.Errorf(\"Perform failed for %q (auth %d): %v\", attackURL, stream.AuthenticationType, err)\n\t\treturn false\n\t}\n\n\t// Get return code for the request.\n\trc, err := c.Getinfo(curl.INFO_RESPONSE_CODE)\n\tif err != nil {\n\t\ts.term.Errorf(\"Getinfo failed: %v\", err)\n\t\treturn false\n\t}\n\n\tif s.debug {\n\t\ts.term.Debugln(\"DESCRIBE\", attackURL, \"RTSP/1.0 >\", rc)\n\t}\n\n\t// If it's a 404, it means that the route is incorrect but the credentials might be okay.\n\t// If it's a 200, the stream is accessed successfully.\n\tif rc == httpOK || rc == httpNotFound {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *Scanner) validateStream(stream Stream) bool {\n\tc := s.curl.Duphandle()\n\n\tattackURL := fmt.Sprintf(\n\t\t\"rtsp://%s:%s@%s:%d/%s\",\n\t\tstream.Username,\n\t\tstream.Password,\n\t\tstream.Address,\n\t\tstream.Port,\n\t\tstream.Route(),\n\t)\n\n\ts.setCurlOptions(c)\n\n\t// Set proper authentication type.\n\t_ = c.Setopt(curl.OPT_HTTPAUTH, stream.AuthenticationType)\n\t_ = c.Setopt(curl.OPT_USERPWD, fmt.Sprint(stream.Username, \":\", stream.Password))\n\n\t// Send a request to the URL of the stream we want to attack.\n\t_ = c.Setopt(curl.OPT_URL, attackURL)\n\t// Set the RTSP STREAM URI as the stream URL.\n\t_ = c.Setopt(curl.OPT_RTSP_STREAM_URI, attackURL)\n\t_ = c.Setopt(curl.OPT_RTSP_REQUEST, rtspSetup)\n\n\t_ = c.Setopt(curl.OPT_RTSP_TRANSPORT, \"RTP/AVP;unicast;client_port=33332-33333\")\n\n\t// Perform the request.\n\terr := c.Perform()\n\tif err != nil {\n\t\ts.term.Errorf(\"Perform failed for %q (auth %d): %v\", attackURL, stream.AuthenticationType, err)\n\t\treturn false\n\t}\n\n\t// Get return code for the request.\n\trc, err := c.Getinfo(curl.INFO_RESPONSE_CODE)\n\tif err != nil {\n\t\ts.term.Errorf(\"Getinfo failed: %v\", err)\n\t\treturn false\n\t}\n\n\tif s.debug {\n\t\ts.term.Debugln(\"SETUP\", attackURL, \"RTSP/1.0 >\", rc)\n\t}\n\n\t// If it's a 200, the stream is accessed successfully.\n\tif rc == httpOK {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *Scanner) setCurlOptions(c Curler) {\n\t// Do not write sdp in stdout\n\t_ = c.Setopt(curl.OPT_WRITEFUNCTION, doNotWrite)\n\t// Do not use signals (would break multithreading).\n\t_ = c.Setopt(curl.OPT_NOSIGNAL, 1)\n\t// Do not send a body in the describe request.\n\t_ = c.Setopt(curl.OPT_NOBODY, 1)\n\t// Set custom timeout.\n\t_ = c.Setopt(curl.OPT_TIMEOUT_MS, int(s.timeout/time.Millisecond))\n\n\t// Enable verbose logs if verbose mode is on.\n\tif s.verbose {\n\t\t_ = c.Setopt(curl.OPT_VERBOSE, 1)\n\t} else {\n\t\t_ = c.Setopt(curl.OPT_VERBOSE, 0)\n\t}\n}\n\n// HACK: See https://stackoverflow.com/questions/3572397/lib-curl-in-c-disable-printing\nfunc doNotWrite([]uint8, interface{}) bool {\n\treturn true\n}\n"
        },
        {
          "name": "attack_test.go",
          "type": "blob",
          "size": 14.8134765625,
          "content": "package cameradar\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/Ullaakut/disgo\"\n\t\"github.com/Ullaakut/go-curl\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\ntype CurlerMock struct {\n\tmock.Mock\n}\n\nfunc (m *CurlerMock) Setopt(opt int, param interface{}) error {\n\targs := m.Called(opt, param)\n\treturn args.Error(0)\n}\n\nfunc (m *CurlerMock) Perform() error {\n\targs := m.Called()\n\treturn args.Error(0)\n}\n\nfunc (m *CurlerMock) Getinfo(info curl.CurlInfo) (interface{}, error) {\n\targs := m.Called(info)\n\treturn args.Int(0), args.Error(1)\n}\n\nfunc (m *CurlerMock) Duphandle() Curler {\n\treturn m\n}\n\nfunc TestAttack(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:  \"fakeDevice\",\n\t\t\tAddress: \"fakeAddress\",\n\t\t\tPort:    1337,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:  \"fakeDevice\",\n\t\t\tAddress: \"differentFakeAddress\",\n\t\t\tPort:    1337,\n\t\t}\n\n\t\tfakeTargets     = []Stream{stream1, stream2}\n\t\tfakeRoutes      = Routes{\"live.sdp\", \"media.amp\"}\n\t\tfakeCredentials = Credentials{\n\t\t\tUsernames: []string{\"admin\", \"root\"},\n\t\t\tPasswords: []string{\"12345\", \"root\"},\n\t\t}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\n\t\tperformErr error\n\n\t\texpectedStreams []Stream\n\t\texpectedErr     error\n\t}{\n\t\t{\n\t\t\tdescription: \"inverted RTSP RFC\",\n\n\t\t\ttargets: fakeTargets,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"attack works\",\n\n\t\t\ttargets: fakeTargets,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"no targets\",\n\n\t\t\ttargets: nil,\n\n\t\t\texpectedStreams: nil,\n\t\t\texpectedErr:     errors.New(\"no stream found\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tif len(test.targets) != 0 {\n\t\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\t\tif test.performErr == nil {\n\t\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(200, nil)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:        disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:        curlerMock,\n\t\t\t\ttimeout:     time.Millisecond,\n\t\t\t\tverbose:     true,\n\t\t\t\tdebug:       true,\n\t\t\t\tcredentials: fakeCredentials,\n\t\t\t\troutes:      fakeRoutes,\n\t\t\t}\n\n\t\t\tresults, err := scanner.Attack(test.targets)\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\n\t\t\tassert.Len(t, results, len(test.expectedStreams))\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestAttackCredentials(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets     = []Stream{stream1, stream2}\n\t\tfakeCredentials = Credentials{\n\t\t\tUsernames: []string{\"admin\", \"root\"},\n\t\t\tPasswords: []string{\"12345\", \"root\"},\n\t\t}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets     []Stream\n\t\tcredentials Credentials\n\t\ttimeout     time.Duration\n\t\tverbose     bool\n\n\t\tstatus int\n\n\t\tperformErr     error\n\t\tgetInfoErr     error\n\t\tinvalidTargets bool\n\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tdescription: \"Credentials found\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\n\t\t\tstatus: 404,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Camera accessed\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\n\t\t\tstatus: 200,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl perform fails\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl getinfo fails\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\n\t\t\tgetInfoErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Verbose mode disabled\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\t\t\tverbose:     false,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Verbose mode enabled\",\n\n\t\t\ttargets:     fakeTargets,\n\t\t\tcredentials: fakeCredentials,\n\t\t\ttimeout:     1 * time.Millisecond,\n\t\t\tverbose:     true,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tif !test.invalidTargets {\n\t\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\t\tif test.performErr == nil {\n\t\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, test.getInfoErr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:        disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:        curlerMock,\n\t\t\t\ttimeout:     test.timeout,\n\t\t\t\tverbose:     test.verbose,\n\t\t\t\tdebug:       test.verbose,\n\t\t\t\tcredentials: test.credentials,\n\t\t\t}\n\n\t\t\tresults := scanner.AttackCredentials(test.targets)\n\n\t\t\tassert.Len(t, results, len(test.expectedStreams))\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestAttackRoute(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets = []Stream{stream1, stream2}\n\t\tfakeRoutes  = Routes{\"live.sdp\", \"media.amp\"}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\t\troutes  Routes\n\t\ttimeout time.Duration\n\t\tverbose bool\n\n\t\tstatus int\n\n\t\tperformErr     error\n\t\tgetInfoErr     error\n\t\tinvalidTargets bool\n\n\t\texpectedStreams []Stream\n\t\texpectedErr     error\n\t}{\n\t\t{\n\t\t\tdescription: \"Route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 401,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Camera accessed\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 200,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl perform fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl getinfo fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tgetInfoErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose mode disabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: false,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose mode enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: true,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tif !test.invalidTargets {\n\t\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\t\tif test.performErr == nil {\n\t\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, test.getInfoErr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:    curlerMock,\n\t\t\t\ttimeout: test.timeout,\n\t\t\t\tverbose: test.verbose,\n\t\t\t\tdebug:   test.verbose,\n\t\t\t\troutes:  test.routes,\n\t\t\t}\n\n\t\t\tresults := scanner.AttackRoute(test.targets)\n\n\t\t\tassert.Len(t, results, len(test.expectedStreams))\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestAttackRoute_NoDummyRoute(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets = []Stream{stream1, stream2}\n\t\tfakeRoutes  = Routes{\"live.sdp\", \"media.amp\"}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\t\troutes  Routes\n\t\ttimeout time.Duration\n\t\tverbose bool\n\n\t\tstatus int\n\n\t\texpectedStreams []Stream\n\t\texpectedErr     error\n\t}{\n\t\t{\n\t\t\tdescription: \"Route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 401,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Camera accessed\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\troutes:  fakeRoutes,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 200,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\tcurlerMock.On(\"Perform\").Return(nil)\n\n\t\t\t// 404 on first call to the dummy route.\n\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(404, nil).Once()\n\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, nil)\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:    curlerMock,\n\t\t\t\ttimeout: test.timeout,\n\t\t\t\tverbose: test.verbose,\n\t\t\t\troutes:  test.routes,\n\t\t\t}\n\n\t\t\tresults := scanner.AttackRoute(test.targets)\n\n\t\t\tassert.Len(t, results, len(test.expectedStreams))\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestValidateStreams(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets = []Stream{stream1, stream2}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\t\ttimeout time.Duration\n\t\tverbose bool\n\n\t\tstatus int\n\n\t\tperformErr error\n\t\tgetInfoErr error\n\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tdescription: \"route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 403,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"route found\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 401,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"camera accessed\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 200,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"unavailable stream\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 400,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl perform fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl getinfo fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tgetInfoErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose disabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: false,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: true,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\tif test.performErr == nil {\n\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, test.getInfoErr)\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:    curlerMock,\n\t\t\t\ttimeout: test.timeout,\n\t\t\t\tverbose: test.verbose,\n\t\t\t\tdebug:   test.verbose,\n\t\t\t}\n\n\t\t\tresults := scanner.ValidateStreams(test.targets)\n\n\t\t\tassert.Equal(t, len(test.expectedStreams), len(results))\n\n\t\t\tfor _, expectedStream := range test.expectedStreams {\n\t\t\t\tassert.Contains(t, results, expectedStream)\n\t\t\t}\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestDetectAuthenticationType(t *testing.T) {\n\tvar (\n\t\tstream1 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"fakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tstream2 = Stream{\n\t\t\tDevice:    \"fakeDevice\",\n\t\t\tAddress:   \"differentFakeAddress\",\n\t\t\tPort:      1337,\n\t\t\tAvailable: true,\n\t\t}\n\n\t\tfakeTargets = []Stream{stream1, stream2}\n\t)\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []Stream\n\t\ttimeout time.Duration\n\t\tverbose bool\n\n\t\tstatus int\n\n\t\tperformErr error\n\t\tgetInfoErr error\n\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tdescription: \"no auth enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 0,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"basic auth enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 1,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"digest auth enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tstatus: 2,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl getinfo fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tgetInfoErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl perform fails\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\n\t\t\tperformErr: errors.New(\"dummy error\"),\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose disabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: false,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t\t{\n\t\t\tdescription: \"verbose enabled\",\n\n\t\t\ttargets: fakeTargets,\n\t\t\ttimeout: 1 * time.Millisecond,\n\t\t\tverbose: true,\n\n\t\t\texpectedStreams: fakeTargets,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tcurlerMock := &CurlerMock{}\n\n\t\t\tcurlerMock.On(\"Setopt\", mock.Anything, mock.Anything).Return(nil)\n\t\t\tcurlerMock.On(\"Perform\").Return(test.performErr)\n\t\t\tif test.performErr == nil {\n\t\t\t\tcurlerMock.On(\"Getinfo\", mock.Anything).Return(test.status, test.getInfoErr)\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcurl:    curlerMock,\n\t\t\t\ttimeout: test.timeout,\n\t\t\t\tverbose: test.verbose,\n\t\t\t}\n\n\t\t\tresults := scanner.DetectAuthMethods(test.targets)\n\n\t\t\tassert.Equal(t, len(test.expectedStreams), len(results))\n\n\t\t\tfor _, expectedStream := range test.expectedStreams {\n\t\t\t\tassert.Contains(t, results, expectedStream)\n\t\t\t}\n\n\t\t\tcurlerMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n\nfunc TestDoNotWrite(t *testing.T) {\n\tassert.Equal(t, true, doNotWrite(nil, nil))\n}\n"
        },
        {
          "name": "cameradar.go",
          "type": "blob",
          "size": 0.6025390625,
          "content": "// Package cameradar provides methods to be able to discover and\n// attack RTSP streams easily. RTSP streams are used by most\n// IP Cameras, often for surveillance.\n//\n// A simple example usage of the library can be found in\n// https://github.com/Ullaakut/cameradar/tree/master/cameradar\n//\n// The example usage is complete enough for most users to\n// ignore the library, but for users with specific needs\n// such as creating their own bruteforcing dictionary to\n// access cameras, or running their own network scan, this\n// library allows to use simple and performant methods to\n// attack streams.\npackage cameradar\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "curl.go",
          "type": "blob",
          "size": 0.626953125,
          "content": "package cameradar\n\nimport (\n\tcurl \"github.com/Ullaakut/go-curl\"\n)\n\n// Curler is an interface that implements the CURL interface of the go-curl library\n// Used for mocking\ntype Curler interface {\n\tSetopt(opt int, param interface{}) error\n\tPerform() error\n\tGetinfo(info curl.CurlInfo) (interface{}, error)\n\tDuphandle() Curler\n}\n\n// Curl is a libcurl wrapper used to make the Curler interface work even though\n// golang currently does not support covariance (see https://github.com/golang/go/issues/7512)\ntype Curl struct {\n\t*curl.CURL\n}\n\n// Duphandle wraps curl.Duphandle\nfunc (c *Curl) Duphandle() Curler {\n\treturn &Curl{c.CURL.Duphandle()}\n}\n"
        },
        {
          "name": "curl_test.go",
          "type": "blob",
          "size": 0.33203125,
          "content": "package cameradar\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\tcurl \"github.com/Ullaakut/go-curl\"\n)\n\nfunc TestCurl(t *testing.T) {\n\thandle := Curl{\n\t\tCURL: curl.EasyInit(),\n\t}\n\n\thandle2 := handle.Duphandle()\n\n\tif reflect.DeepEqual(handle, handle2) {\n\t\tt.Errorf(\"unexpected identical handle from duphandle: expected %+v got %+v\", handle, handle2)\n\t}\n}\n"
        },
        {
          "name": "dictionaries",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5185546875,
          "content": "module github.com/Ullaakut/cameradar/v5\n\ngo 1.14\n\nrequire (\n\tgithub.com/PuerkitoBio/goquery v1.5.0\n\tgithub.com/Ullaakut/disgo v0.3.1\n\tgithub.com/Ullaakut/go-curl v0.0.0-20190525093431-597e157bbffd\n\tgithub.com/Ullaakut/nmap v2.0.0+incompatible\n\tgithub.com/VividCortex/ewma v1.1.1 // indirect\n\tgithub.com/fatih/color v1.7.0 // indirect\n\tgithub.com/mattn/go-colorable v0.1.2 // indirect\n\tgithub.com/spf13/pflag v1.0.3\n\tgithub.com/spf13/viper v1.4.0\n\tgithub.com/stretchr/testify v1.2.2\n\tgithub.com/vbauerster/mpb v3.4.0+incompatible\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 15.2822265625,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ngithub.com/BurntSushi/toml v0.3.1 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=\ngithub.com/PuerkitoBio/goquery v1.5.0 h1:uGvmFXOA73IKluu/F84Xd1tt/z07GYm8X49XKHP7EJk=\ngithub.com/PuerkitoBio/goquery v1.5.0/go.mod h1:qD2PgZ9lccMbQlc7eEOjaeRlFQON7xY8kdmcsrnKqMg=\ngithub.com/Ullaakut/disgo v0.3.1 h1:BGGVHynji41KGuGI02ztTCnILRvyzlvmiCRl5bBpjKk=\ngithub.com/Ullaakut/disgo v0.3.1/go.mod h1:/CSvpnYVSKOeh2dvUvx9cXshzz2t7T1/lRO/MrFj3fI=\ngithub.com/Ullaakut/go-curl v0.0.0-20190525093431-597e157bbffd h1:CMe+dX1CL4pCXNytxIB2U1qp0xZObGMZosJhaQdUlUo=\ngithub.com/Ullaakut/go-curl v0.0.0-20190525093431-597e157bbffd/go.mod h1:u8mVgpDT88IPIt1B+Tu8vkrcFfBKGcfGwS9I7wmvMh0=\ngithub.com/Ullaakut/nmap v2.0.0+incompatible h1:tNXub052dsnG8+yrgpph9nhVixIBdpRRgzvmQoc8eBA=\ngithub.com/Ullaakut/nmap v2.0.0+incompatible/go.mod h1:fkC066hwfcoKwlI7DS2ARTggSVtBTZYCjVH1TzuTMaQ=\ngithub.com/VividCortex/ewma v1.1.1 h1:MnEK4VOv6n0RSY4vtRe3h11qjxL3+t0B8yOL8iMXdcM=\ngithub.com/VividCortex/ewma v1.1.1/go.mod h1:2Tkkvm3sRDVXaiyucHiACn4cqf7DpdyLvmxzcbUokwA=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/andybalholm/cascadia v1.0.0 h1:hOCXnnZ5A+3eVDX8pvgl4kofXv2ELss0bKcqRySc45o=\ngithub.com/andybalholm/cascadia v1.0.0/go.mod h1:GsXiBklL0woXo1j/WYWtSYYC4ouU9PqHO0sqidkEA4Y=\ngithub.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=\ngithub.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/dgryski/go-sip13 v0.0.0-20181026042036-e10d5fee7954/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=\ngithub.com/fatih/color v1.7.0 h1:DkWD4oS2D8LGGgTQ6IvwJJXSL5Vp2ffcQg58nFV38Ys=\ngithub.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/fsnotify/fsnotify v1.4.7 h1:IXs+QLmnXW2CcXuY+8Mzv/fWEsPGWxqefPtCP5CnV9I=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20190129154638-5b532d6fd5ef/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=\ngithub.com/grpc-ecosystem/grpc-gateway v1.9.0/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=\ngithub.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/magiconair/properties v1.8.0 h1:LLgXmsheXeRoUOBOjtwPQCWIYqM/LU1ayDtDePerRcY=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=\ngithub.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-isatty v0.0.8 h1:HLtExJ+uU2HOZ+wI0Tt5DtUDrx8yhUqDcp7fYERX4CE=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/mitchellh/mapstructure v1.1.2 h1:fmNYVwqnSfB9mZU6OS2O6GsXM+wcskZDuKQzvN1EDeE=\ngithub.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=\ngithub.com/pelletier/go-toml v1.2.0 h1:T5zMGML61Wp+FlcbWjRDT7yAxhJNAiPPLOFECq181zc=\ngithub.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v0.9.3/go.mod h1:/TN21ttK/J9q6uSwhBd54HahCDft0ttaMvbicHlPoso=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/common v0.0.0-20181113130724-41aa239b4cce/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=\ngithub.com/prometheus/common v0.4.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.0-20190507164030-5867b95ac084/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=\ngithub.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=\ngithub.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=\ngithub.com/spf13/afero v1.1.2 h1:m8/z1t7/fwjysjQRYbP0RD+bUIF/8tJwPdEZsI83ACI=\ngithub.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=\ngithub.com/spf13/cast v1.3.0 h1:oget//CVOEoFewqQxwr0Ej5yjygnqGkvggSE/gB35Q8=\ngithub.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/jwalterweatherman v1.0.0 h1:XHEdyB+EcvlqZamSM4ZOMGlc93t6AcsBEu9Gc1vn7yk=\ngithub.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=\ngithub.com/spf13/pflag v1.0.3 h1:zPAT6CGy6wXeQ7NtTnaTerfKOsV6V6F8agHXFiazDkg=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/viper v1.4.0 h1:yXHLWeravcrgGyFSyCgdYpXQ9dR9c/WED3pg1RhxqEU=\ngithub.com/spf13/viper v1.4.0/go.mod h1:PTJ7Z/lr49W6bUbkmS1V3by4uWynFiR9p7+dSq/yZzE=\ngithub.com/stretchr/objx v0.1.1 h1:2vfRuCMp5sSVIDSqO8oNnWJq7mPa6KVP3iPIwFBuy8A=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=\ngithub.com/vbauerster/mpb v3.4.0+incompatible h1:mfiiYw87ARaeRW6x5gWwYRUawxaW1tLAD8IceomUCNw=\ngithub.com/vbauerster/mpb v3.4.0+incompatible/go.mod h1:zAHG26FUhVKETRu+MWqYXcI70POlC6N8up9p1dID7SU=\ngithub.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=\ngithub.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=\ngo.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\ngo.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=\ngo.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2 h1:VklqNMn3ovrHsnt90PveolxSbWFaJdECFbxSq0Mqo2M=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/net v0.0.0-20180218175443-cbe0f9307d01/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190522155817-f3200d17e092 h1:4QSRKanuywn15aTZvI/mIDEgPQpswuFndXpOj3rKEco=\ngolang.org/x/net v0.0.0-20190522155817-f3200d17e092/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223 h1:DH4skfRX4EBpamg7iV4ZlCpblAHI6s6TDM39bFZumv8=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.21.0/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/resty.v1 v1.12.0/go.mod h1:mDo4pnntr5jdWRML875a/NmxYqAlA73dVijT2AXvQQo=\ngopkg.in/yaml.v2 v2.0.0-20170812160011-eb3733d160e7/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 0.7216796875,
          "content": "package cameradar\n\nimport \"fmt\"\n\nfunc replace(streams []Stream, new Stream) []Stream {\n\tvar updatedSlice []Stream\n\n\tfor _, old := range streams {\n\t\tif old.Address == new.Address && old.Port == new.Port {\n\t\t\tupdatedSlice = append(updatedSlice, new)\n\t\t} else {\n\t\t\tupdatedSlice = append(updatedSlice, old)\n\t\t}\n\t}\n\n\treturn updatedSlice\n}\n\n// GetCameraRTSPURL generates a stream's RTSP URL.\nfunc GetCameraRTSPURL(stream Stream) string {\n\treturn \"rtsp://\" + stream.Username + \":\" + stream.Password + \"@\" + stream.Address + \":\" + fmt.Sprint(stream.Port) + \"/\" + stream.Route()\n}\n\n// GetCameraAdminPanelURL returns the URL to the camera's admin panel.\nfunc GetCameraAdminPanelURL(stream Stream) string {\n\treturn \"http://\" + stream.Address + \"/\"\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 1.9404296875,
          "content": "package cameradar\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestReplace(t *testing.T) {\n\tvalidStream1 := Stream{\n\t\tDevice:  \"fakeDevice\",\n\t\tAddress: \"fakeAddress\",\n\t\tPort:    1,\n\t}\n\n\tvalidStream2 := Stream{\n\t\tDevice:  \"fakeDevice\",\n\t\tAddress: \"differentFakeAddress\",\n\t\tPort:    2,\n\t}\n\n\tinvalidStream := Stream{\n\t\tDevice:  \"invalidDevice\",\n\t\tAddress: \"anotherFakeAddress\",\n\t\tPort:    3,\n\t}\n\n\tinvalidStreamModified := Stream{\n\t\tDevice:  \"updatedDevice\",\n\t\tAddress: \"anotherFakeAddress\",\n\t\tPort:    3,\n\t}\n\n\ttestCases := []struct {\n\t\tstreams   []Stream\n\t\tnewStream Stream\n\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tstreams:   []Stream{validStream1, validStream2, invalidStream},\n\t\t\tnewStream: invalidStreamModified,\n\n\t\t\texpectedStreams: []Stream{validStream1, validStream2, invalidStreamModified},\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tstreams := replace(test.streams, test.newStream)\n\n\t\tassert.Equal(t, len(test.expectedStreams), len(streams))\n\n\t\tfor _, expectedStream := range test.expectedStreams {\n\t\t\tassert.Contains(t, streams, expectedStream)\n\t\t}\n\t}\n}\n\nfunc TestGetCameraRTSPURL(t *testing.T) {\n\tvalidStream := Stream{\n\t\tAddress:  \"1.2.3.4\",\n\t\tUsername: \"ullaakut\",\n\t\tPassword: \"ba69897483886f0d2b0afb6345b76c0c\",\n\t\tRoutes:   []string{\"cameradar.sdp\"},\n\t\tPort:     1337,\n\t}\n\n\ttestCases := []struct {\n\t\tstream Stream\n\n\t\texpectedRTSPURL string\n\t}{\n\t\t{\n\t\t\tstream: validStream,\n\n\t\t\texpectedRTSPURL: \"rtsp://ullaakut:ba69897483886f0d2b0afb6345b76c0c@1.2.3.4:1337/cameradar.sdp\",\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tassert.Equal(t, test.expectedRTSPURL, GetCameraRTSPURL(test.stream))\n\t}\n}\n\nfunc TestGetCameraAdminPanelURL(t *testing.T) {\n\tvalidStream := Stream{\n\t\tAddress: \"1.2.3.4\",\n\t}\n\n\ttestCases := []struct {\n\t\tstream Stream\n\n\t\texpectedRTSPURL string\n\t}{\n\t\t{\n\t\t\tstream: validStream,\n\n\t\t\texpectedRTSPURL: \"http://1.2.3.4/\",\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tassert.Equal(t, test.expectedRTSPURL, GetCameraAdminPanelURL(test.stream))\n\t}\n}\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "loaders.go",
          "type": "blob",
          "size": 3.0458984375,
          "content": "package cameradar\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\nvar fs fileSystem = osFS{}\n\ntype fileSystem interface {\n\tOpen(name string) (file, error)\n\tStat(name string) (os.FileInfo, error)\n}\n\ntype file interface {\n\tio.Closer\n\tio.Reader\n\tio.ReaderAt\n\tio.Seeker\n\tStat() (os.FileInfo, error)\n}\n\n// osFS implements fileSystem using the local disk.\ntype osFS struct{}\n\nfunc (osFS) Open(name string) (file, error)        { return os.Open(name) }\nfunc (osFS) Stat(name string) (os.FileInfo, error) { return os.Stat(name) }\n\n// LoadCredentials opens a dictionary file and returns its contents as a Credentials structure.\nfunc (s *Scanner) LoadCredentials() error {\n\ts.term.Debugf(\"Loading credentials dictionary from path %q\\n\", s.credentialDictionaryPath)\n\n\t// Open & Read XML file.\n\tcontent, err := ioutil.ReadFile(s.credentialDictionaryPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not read credentials dictionary file at %q: %v\", s.credentialDictionaryPath, err)\n\t}\n\n\t// Unmarshal content of JSON file into data structure.\n\terr = json.Unmarshal(content, &s.credentials)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to unmarshal dictionary contents: %v\", err)\n\t}\n\n\ts.term.Debugf(\"Loaded %d usernames and %d passwords\\n\", len(s.credentials.Usernames), len(s.credentials.Passwords))\n\treturn nil\n}\n\n// LoadRoutes opens a dictionary file and returns its contents as a Routes structure.\nfunc (s *Scanner) LoadRoutes() error {\n\ts.term.Debugf(\"Loading routes dictionary from path %q\\n\", s.routeDictionaryPath)\n\n\tfile, err := os.Open(s.routeDictionaryPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to open dictionary: %v\", err)\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\ts.routes = append(s.routes, scanner.Text())\n\t}\n\n\ts.term.Debugf(\"Loaded %d routes\\n\", len(s.routes))\n\n\treturn scanner.Err()\n}\n\n// ParseCredentialsFromString parses a dictionary string and returns its contents as a Credentials structure.\nfunc ParseCredentialsFromString(content string) (Credentials, error) {\n\tvar creds Credentials\n\n\t// Unmarshal content of JSON file into data structure.\n\terr := json.Unmarshal([]byte(content), &creds)\n\tif err != nil {\n\t\treturn creds, err\n\t}\n\n\treturn creds, nil\n}\n\n// ParseRoutesFromString parses a dictionary string and returns its contents as a Routes structure.\nfunc ParseRoutesFromString(content string) Routes {\n\treturn strings.Split(content, \"\\n\")\n}\n\n// LoadTargets parses the file containing hosts to targets, if the targets are\n// just set to a file name.\nfunc (s *Scanner) LoadTargets() error {\n\tif len(s.targets) != 1 {\n\t\treturn nil\n\t}\n\n\tpath := s.targets[0]\n\n\t_, err := fs.Stat(path)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tfile, err := fs.Open(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to open targets file %q: %v\", path, err)\n\t}\n\tdefer file.Close()\n\n\tbytes, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to read targets file %q: %v\", path, err)\n\t}\n\n\ts.targets = strings.Split(string(bytes), \"\\n\")\n\n\ts.term.Debugf(\"Successfully parsed targets file with %d entries\", len(s.targets))\n\n\treturn nil\n}\n"
        },
        {
          "name": "loaders_test.go",
          "type": "blob",
          "size": 9.7587890625,
          "content": "package cameradar\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/Ullaakut/disgo\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\n// Setup Mock\ntype mockedFS struct {\n\tosFS\n\n\tfileExists bool\n\topenError  bool\n\n\tfileMock *fileMock\n\n\tfileSize int64\n}\n\n// fileMock mocks a file\ntype fileMock struct {\n\tmock.Mock\n\n\treadError bool\n\n\tbytes.Buffer\n}\n\ntype mockedFileInfo struct {\n\tos.FileInfo\n}\n\nfunc (m mockedFileInfo) Size() int64 { return 1 }\n\nfunc (m mockedFS) Stat(name string) (os.FileInfo, error) {\n\tif !m.fileExists {\n\t\treturn nil, os.ErrNotExist\n\t}\n\treturn mockedFileInfo{}, nil\n}\n\nfunc (m mockedFS) Open(name string) (file, error) {\n\tif m.openError {\n\t\treturn nil, os.ErrNotExist\n\t}\n\n\treturn m.fileMock, nil\n}\n\nfunc (m *fileMock) Read(p []byte) (n int, err error) {\n\tif m.readError {\n\t\treturn 0, os.ErrNotExist\n\t}\n\treturn m.Buffer.Read(p)\n}\n\nfunc (m *fileMock) ReadAt(p []byte, off int64) (n int, err error) {\n\treturn 1, nil\n}\n\nfunc (m *fileMock) Seek(offset int64, whence int) (int64, error) {\n\treturn offset, nil\n}\n\nfunc (m *fileMock) Stat() (os.FileInfo, error) {\n\treturn mockedFileInfo{}, nil\n}\n\n// Close mock\nfunc (m *fileMock) Close() error {\n\targs := m.Called()\n\treturn args.Error(0)\n}\n\n// Sync mock\nfunc (m *fileMock) Sync() error {\n\targs := m.Called()\n\treturn args.Error(0)\n}\n\nfunc TestLoadCredentials(t *testing.T) {\n\tcredentialsJSONString := []byte(\"{\\\"usernames\\\":[\\\"admin\\\",\\\"root\\\"],\\\"passwords\\\":[\\\"12345\\\",\\\"root\\\"]}\")\n\tvalidCredentials := Credentials{\n\t\tUsernames: []string{\"admin\", \"root\"},\n\t\tPasswords: []string{\"12345\", \"root\"},\n\t}\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\tinput      []byte\n\t\tfileExists bool\n\n\t\texpectedCredentials Credentials\n\t\texpectedErr         error\n\t}{\n\t\t{\n\t\t\tdescription: \"Valid baseline\",\n\n\t\t\tfileExists:          true,\n\t\t\tinput:               credentialsJSONString,\n\t\t\texpectedCredentials: validCredentials,\n\t\t},\n\t\t{\n\t\t\tdescription: \"File does not exist\",\n\n\t\t\tfileExists:  false,\n\t\t\tinput:       credentialsJSONString,\n\t\t\texpectedErr: errors.New(\"could not read credentials dictionary file at \\\"/tmp/cameradar_test_load_credentials_1.xml\\\": open /tmp/cameradar_test_load_credentials_1.xml: no such file or directory\"),\n\t\t},\n\t\t{\n\t\t\tdescription: \"Invalid format\",\n\n\t\t\tfileExists:  true,\n\t\t\tinput:       []byte(\"not json\"),\n\t\t\texpectedErr: errors.New(\"unable to unmarshal dictionary contents: invalid character 'o' in literal null (expecting 'u')\"),\n\t\t},\n\t\t{\n\t\t\tdescription: \"No streams in dictionary\",\n\n\t\t\tfileExists: true,\n\t\t\tinput:      []byte(\"{\\\"invalid\\\":\\\"json\\\"}\"),\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tfilePath := \"/tmp/cameradar_test_load_credentials_\" + fmt.Sprint(i) + \".xml\"\n\t\t\t// create file.\n\t\t\tif test.fileExists {\n\t\t\t\t_, err := os.Create(filePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"could not create xml file for LoadCredentials: %v. iteration: %d. file path: %s\\n\", err, i, filePath)\n\t\t\t\t}\n\n\t\t\t\terr = ioutil.WriteFile(filePath, test.input, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"could not write xml file for LoadCredentials: %v. iteration: %d. file path: %s\\n\", err, i, filePath)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:                     disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\tcredentialDictionaryPath: filePath,\n\t\t\t}\n\n\t\t\terr := scanner.LoadCredentials()\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\n\t\t\tassert.Len(t, scanner.credentials.Usernames, len(test.expectedCredentials.Usernames))\n\t\t\tfor _, expectedUsername := range test.expectedCredentials.Usernames {\n\t\t\t\tassert.Contains(t, scanner.credentials.Usernames, expectedUsername)\n\t\t\t}\n\n\t\t\tassert.Len(t, scanner.credentials.Passwords, len(test.expectedCredentials.Passwords))\n\t\t\tfor _, expectedPassword := range test.expectedCredentials.Passwords {\n\t\t\t\tassert.Contains(t, scanner.credentials.Passwords, expectedPassword)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLoadRoutes(t *testing.T) {\n\troutesJSONString := []byte(\"admin\\nroot\")\n\tvalidRoutes := Routes{\"admin\", \"root\"}\n\n\ttests := []struct {\n\t\tdescription string\n\t\tinput       []byte\n\t\tfileExists  bool\n\n\t\texpectedRoutes Routes\n\t\texpectedErr    error\n\t}{\n\t\t{\n\t\t\tdescription: \"Valid baseline\",\n\n\t\t\tfileExists:     true,\n\t\t\tinput:          routesJSONString,\n\t\t\texpectedRoutes: validRoutes,\n\t\t},\n\t\t{\n\t\t\tdescription: \"File does not exist\",\n\n\t\t\tfileExists:  false,\n\t\t\tinput:       routesJSONString,\n\t\t\texpectedErr: errors.New(\"unable to open dictionary: open /tmp/cameradar_test_load_routes_1.xml: no such file or directory\"),\n\t\t},\n\t\t{\n\t\t\tdescription: \"No streams in dictionary\",\n\n\t\t\tfileExists: true,\n\t\t\tinput:      []byte(\"\"),\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tfilePath := \"/tmp/cameradar_test_load_routes_\" + fmt.Sprint(i) + \".xml\"\n\n\t\t\t// Create file.\n\t\t\tif test.fileExists {\n\t\t\t\t_, err := os.Create(filePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"could not create xml file for LoadRoutes: %v. iteration: %d. file path: %s\\n\", err, i, filePath)\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\n\t\t\t\terr = ioutil.WriteFile(filePath, test.input, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"could not write xml file for LoadRoutes: %v. iteration: %d. file path: %s\\n\", err, i, filePath)\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:                disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\trouteDictionaryPath: filePath,\n\t\t\t}\n\n\t\t\terr := scanner.LoadRoutes()\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\n\t\t\tassert.Len(t, scanner.routes, len(test.expectedRoutes))\n\t\t\tfor _, expectedRoute := range test.expectedRoutes {\n\t\t\t\tassert.Contains(t, scanner.routes, expectedRoute)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseCredentialsFromString(t *testing.T) {\n\tdefaultCredentials := Credentials{\n\t\tUsernames: []string{\n\t\t\t\"\",\n\t\t\t\"admin\",\n\t\t\t\"Admin\",\n\t\t\t\"Administrator\",\n\t\t\t\"root\",\n\t\t\t\"supervisor\",\n\t\t\t\"ubnt\",\n\t\t\t\"service\",\n\t\t\t\"Dinion\",\n\t\t\t\"administrator\",\n\t\t\t\"admin1\",\n\t\t},\n\t\tPasswords: []string{\n\t\t\t\"\",\n\t\t\t\"admin\",\n\t\t\t\"9999\",\n\t\t\t\"123456\",\n\t\t\t\"pass\",\n\t\t\t\"camera\",\n\t\t\t\"1234\",\n\t\t\t\"12345\",\n\t\t\t\"fliradmin\",\n\t\t\t\"system\",\n\t\t\t\"jvc\",\n\t\t\t\"meinsm\",\n\t\t\t\"root\",\n\t\t\t\"4321\",\n\t\t\t\"111111\",\n\t\t\t\"1111111\",\n\t\t\t\"password\",\n\t\t\t\"ikwd\",\n\t\t\t\"supervisor\",\n\t\t\t\"ubnt\",\n\t\t\t\"wbox123\",\n\t\t\t\"service\",\n\t\t},\n\t}\n\n\ttests := []struct {\n\t\tstr                 string\n\t\texpectedCredentials Credentials\n\t}{\n\t\t{\n\t\t\tstr:                 \"{\\\"usernames\\\":[\\\"\\\",\\\"admin\\\",\\\"Admin\\\",\\\"Administrator\\\",\\\"root\\\",\\\"supervisor\\\",\\\"ubnt\\\",\\\"service\\\",\\\"Dinion\\\",\\\"administrator\\\",\\\"admin1\\\"],\\\"passwords\\\":[\\\"\\\",\\\"admin\\\",\\\"9999\\\",\\\"123456\\\",\\\"pass\\\",\\\"camera\\\",\\\"1234\\\",\\\"12345\\\",\\\"fliradmin\\\",\\\"system\\\",\\\"jvc\\\",\\\"meinsm\\\",\\\"root\\\",\\\"4321\\\",\\\"111111\\\",\\\"1111111\\\",\\\"password\\\",\\\"ikwd\\\",\\\"supervisor\\\",\\\"ubnt\\\",\\\"wbox123\\\",\\\"service\\\"]}\",\n\t\t\texpectedCredentials: defaultCredentials,\n\t\t},\n\t\t{\n\t\t\tstr:                 \"{}\",\n\t\t\texpectedCredentials: Credentials{},\n\t\t},\n\t\t{\n\t\t\tstr:                 \"{\\\"invalid_field\\\":42}\",\n\t\t\texpectedCredentials: Credentials{},\n\t\t},\n\t\t{\n\t\t\tstr:                 \"not json\",\n\t\t\texpectedCredentials: Credentials{},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tparsedCredentials, _ := ParseCredentialsFromString(test.str)\n\t\tassert.Equal(t, test.expectedCredentials, parsedCredentials)\n\t}\n}\n\nfunc TestParseRoutesFromString(t *testing.T) {\n\ttests := []struct {\n\t\tstr            string\n\t\texpectedRoutes Routes\n\t}{\n\t\t{\n\t\t\tstr:            \"a\\nb\\nc\",\n\t\t\texpectedRoutes: []string{\"a\", \"b\", \"c\"},\n\t\t},\n\t\t{\n\t\t\tstr:            \"a\",\n\t\t\texpectedRoutes: []string{\"a\"},\n\t\t},\n\t\t{\n\t\t\tstr:            \"\",\n\t\t\texpectedRoutes: []string{\"\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tassert.Equal(t, test.expectedRoutes, ParseRoutesFromString(test.str))\n\t}\n}\n\nfunc TestLoadTargets(t *testing.T) {\n\n\toldFS := fs\n\tmfs := &mockedFS{}\n\tfs = mfs\n\tdefer func() {\n\t\tfs = oldFS\n\t}()\n\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets []string\n\n\t\tfileExists bool\n\t\topenError  bool\n\t\treadError  bool\n\n\t\texpectedTargets []string\n\t\texpectedError   error\n\t}{\n\t\t{\n\t\t\tdescription: \"not a file\",\n\n\t\t\ttargets: []string{\"0.0.0.0\"},\n\n\t\t\tfileExists: false,\n\n\t\t\texpectedTargets: []string{\"0.0.0.0\"},\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"not file targets\",\n\n\t\t\ttargets: []string{\"0.0.0.0\", \"1.2.3.4/24\"},\n\n\t\t\texpectedTargets: []string{\"0.0.0.0\", \"1.2.3.4/24\"},\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"file contains targets\",\n\n\t\t\ttargets: []string{\"test_does_not_really_exist\"},\n\n\t\t\tfileExists: true,\n\n\t\t\texpectedTargets: []string{\"0.0.0.0\", \"localhost\", \"192.17.0.0/16\", \"192.168.1.140-255\", \"192.168.2-3.0-255\"},\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"open error\",\n\n\t\t\ttargets: []string{\"test_does_not_really_exist\"},\n\n\t\t\tfileExists: true,\n\t\t\topenError:  true,\n\n\t\t\texpectedTargets: []string{\"test_does_not_really_exist\"},\n\t\t\texpectedError:   errors.New(\"unable to open targets file \\\"test_does_not_really_exist\\\": file does not exist\"),\n\t\t},\n\t\t{\n\t\t\tdescription: \"read error\",\n\n\t\t\ttargets: []string{\"test_does_not_really_exist\"},\n\n\t\t\tfileExists: true,\n\t\t\treadError:  true,\n\n\t\t\texpectedTargets: []string{\"test_does_not_really_exist\"},\n\t\t\texpectedError:   errors.New(\"unable to read targets file \\\"test_does_not_really_exist\\\": file does not exist\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tmfs.fileExists = test.fileExists\n\t\t\tmfs.openError = test.openError\n\n\t\t\tmfs.fileMock = &fileMock{\n\t\t\t\treadError: test.readError,\n\t\t\t}\n\t\t\tmfs.fileMock.On(\"Close\").Return(nil)\n\t\t\tmfs.fileMock.WriteString(\"0.0.0.0\\nlocalhost\\n192.17.0.0/16\\n192.168.1.140-255\\n192.168.2-3.0-255\")\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:    disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\ttargets: test.targets,\n\t\t\t}\n\n\t\t\terr := scanner.LoadTargets()\n\t\t\tassert.Equal(t, test.expectedTargets, scanner.targets)\n\t\t\tassert.Equal(t, test.expectedError, err)\n\t\t})\n\t}\n}\n\n// This is completely useless and just lets me\n// not look at these two red lines on the coverage\n// any longer.\nfunc TestFS(t *testing.T) {\n\tfs := osFS{}\n\n\tfs.Open(\"test\")\n\tfs.Stat(\"test\")\n}\n"
        },
        {
          "name": "models.go",
          "type": "blob",
          "size": 1.36328125,
          "content": "package cameradar\n\nimport \"time\"\n\n// Stream represents a camera's RTSP stream\ntype Stream struct {\n\tDevice   string   `json:\"device\"`\n\tUsername string   `json:\"username\"`\n\tPassword string   `json:\"password\"`\n\tRoutes   []string `json:\"route\"`\n\tAddress  string   `json:\"address\" validate:\"required\"`\n\tPort     uint16   `json:\"port\" validate:\"required\"`\n\n\tCredentialsFound bool `json:\"credentials_found\"`\n\tRouteFound       bool `json:\"route_found\"`\n\tAvailable        bool `json:\"available\"`\n\n\tAuthenticationType int `json:\"authentication_type\"`\n}\n\n// Route returns this stream's route if there is one.\nfunc (s Stream) Route() string {\n\tif len(s.Routes) > 0 {\n\t\treturn s.Routes[0]\n\t}\n\treturn \"\"\n}\n\n// Credentials is a map of credentials\n// usernames are keys and passwords are values\n// creds['admin'] -> 'secure_password'\ntype Credentials struct {\n\tUsernames []string `json:\"usernames\"`\n\tPasswords []string `json:\"passwords\"`\n}\n\n// Routes is a slice of Routes\n// ['/live.sdp', '/media.amp', ...]\ntype Routes []string\n\n// Options contains all options needed to launch a complete cameradar scan\ntype Options struct {\n\tTargets     []string      `json:\"target\" validate:\"required\"`\n\tPorts       []string      `json:\"ports\"`\n\tRoutes      Routes        `json:\"routes\"`\n\tCredentials Credentials   `json:\"credentials\"`\n\tSpeed       int           `json:\"speed\"`\n\tTimeout     time.Duration `json:\"timeout\"`\n}\n"
        },
        {
          "name": "scan.go",
          "type": "blob",
          "size": 1.7294921875,
          "content": "package cameradar\n\nimport (\n\t\"strings\"\n\n\t\"github.com/Ullaakut/nmap\"\n)\n\n// Scan scans the target networks and tries to find RTSP streams within them.\n//\n// targets can be:\n//\n//    - a subnet (e.g.: 172.16.100.0/24)\n//    - an IP (e.g.: 172.16.100.10)\n//    - a hostname (e.g.: localhost)\n//    - a range of IPs (e.g.: 172.16.100.10-20)\n//\n// ports can be:\n//\n//    - one or multiple ports and port ranges separated by commas (e.g.: 554,8554-8560,18554-28554)\nfunc (s *Scanner) Scan() ([]Stream, error) {\n\ts.term.StartStep(\"Scanning the network\")\n\n\t// Run nmap command to discover open ports on the specified targets & ports.\n\tnmapScanner, err := nmap.NewScanner(\n\t\tnmap.WithTargets(s.targets...),\n\t\tnmap.WithPorts(s.ports...),\n\t\tnmap.WithServiceInfo(),\n\t\tnmap.WithTimingTemplate(nmap.Timing(s.scanSpeed)),\n\t)\n\tif err != nil {\n\t\treturn nil, s.term.FailStepf(\"unable to create network scanner: %v\", err)\n\t}\n\n\treturn s.scan(nmapScanner)\n}\n\nfunc (s *Scanner) scan(nmapScanner nmap.ScanRunner) ([]Stream, error) {\n\tresults, warnings, err := nmapScanner.Run()\n\tfor _, warning := range warnings {\n\t\ts.term.Infoln(\"[Nmap Warning]\", warning)\n\t}\n\tif err != nil {\n\t\treturn nil, s.term.FailStepf(\"error while scanning network: %v\", err)\n\t}\n\n\t// Get streams from nmap results.\n\tvar streams []Stream\n\tfor _, host := range results.Hosts {\n\t\tfor _, port := range host.Ports {\n\t\t\tif port.Status() != \"open\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !strings.Contains(port.Service.Name, \"rtsp\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, address := range host.Addresses {\n\t\t\t\tstreams = append(streams, Stream{\n\t\t\t\t\tDevice:  port.Service.Product,\n\t\t\t\t\tAddress: address.Addr,\n\t\t\t\t\tPort:    port.ID,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\ts.term.Debugf(\"Found %d RTSP streams\\n\", len(streams))\n\n\ts.term.EndStep()\n\n\treturn streams, nil\n}\n"
        },
        {
          "name": "scan_test.go",
          "type": "blob",
          "size": 6.1650390625,
          "content": "package cameradar\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/Ullaakut/disgo\"\n\n\t\"github.com/Ullaakut/nmap\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\ntype nmapMock struct {\n\tmock.Mock\n}\n\nfunc (m *nmapMock) Run() (*nmap.Run, []string, error) {\n\targs := m.Called()\n\n\tif args.Get(0) != nil && args.Get(1) != nil {\n\t\treturn args.Get(0).(*nmap.Run), args.Get(1).([]string), args.Error(2)\n\t}\n\treturn nil, nil, args.Error(2)\n}\n\nvar (\n\tvalidStream1 = Stream{\n\t\tDevice:  \"fakeDevice\",\n\t\tAddress: \"fakeAddress\",\n\t\tPort:    1337,\n\t}\n\n\tvalidStream2 = Stream{\n\t\tDevice:  \"fakeDevice\",\n\t\tAddress: \"differentFakeAddress\",\n\t\tPort:    1337,\n\t}\n\n\tinvalidStreamNoPort = Stream{\n\t\tDevice:  \"invalidDevice\",\n\t\tAddress: \"fakeAddress\",\n\t\tPort:    0,\n\t}\n\n\tinvalidStreamNoAddress = Stream{\n\t\tDevice:  \"invalidDevice\",\n\t\tAddress: \"\",\n\t\tPort:    1337,\n\t}\n)\n\nfunc TestScan(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets    []string\n\t\tports      []string\n\t\tspeed      int\n\t\tremovePath bool\n\n\t\texpectedErr     error\n\t\texpectedStreams []Stream\n\t}{\n\t\t{\n\t\t\tdescription: \"create new scanner and call scan, no error\",\n\n\t\t\ttargets: []string{\"localhost\"},\n\t\t\tports:   []string{\"80\"},\n\t\t\tspeed:   5,\n\t\t},\n\t\t{\n\t\t\tdescription: \"create new scanner with missing nmap installation\",\n\n\t\t\tremovePath: true,\n\t\t\tports:      []string{\"80\"},\n\n\t\t\texpectedErr: errors.New(\"unable to create network scanner: nmap binary was not found\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tif test.removePath {\n\t\t\t\tos.Setenv(\"PATH\", \"\")\n\t\t\t}\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm:      disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t\ttargets:   test.targets,\n\t\t\t\tports:     test.ports,\n\t\t\t\tscanSpeed: test.speed,\n\t\t\t}\n\n\t\t\tresult, err := scanner.Scan()\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\t\t\tassert.Equal(t, test.expectedStreams, result)\n\t\t})\n\t}\n}\n\nfunc TestInternalScan(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\n\t\tnmapResult   *nmap.Run\n\t\tnmapWarnings []string\n\t\tnmapError    error\n\n\t\texpectedStreams []Stream\n\t\texpectedErr     error\n\t}{\n\t\t{\n\t\t\tdescription: \"valid streams\",\n\n\t\t\tnmapResult: &nmap.Run{\n\t\t\t\tHosts: []nmap.Host{\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: validStream1.Address,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"open\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream1.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp\",\n\t\t\t\t\t\t\t\t\tProduct: validStream1.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: validStream2.Address,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"open\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: validStream2.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedStreams: []Stream{validStream1, validStream2},\n\t\t},\n\t\t{\n\t\t\tdescription: \"two invalid targets, no error\",\n\n\t\t\tnmapResult: &nmap.Run{\n\t\t\t\tHosts: []nmap.Host{\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"open\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedStreams: nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"different port states, no error\",\n\n\t\t\tnmapResult: &nmap.Run{\n\t\t\t\tHosts: []nmap.Host{\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"closed\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"unfiltered\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"filtered\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"rtsp-alt\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedStreams: nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"not rtsp, no error\",\n\n\t\t\tnmapResult: &nmap.Run{\n\t\t\t\tHosts: []nmap.Host{\n\t\t\t\t\t{\n\t\t\t\t\t\tAddresses: []nmap.Address{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAddr: invalidStreamNoPort.Address,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\tPorts: []nmap.Port{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tState: nmap.State{\n\t\t\t\t\t\t\t\t\tState: \"open\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tID: validStream2.Port,\n\t\t\t\t\t\t\t\tService: nmap.Service{\n\t\t\t\t\t\t\t\t\tName:    \"tcp\",\n\t\t\t\t\t\t\t\t\tProduct: invalidStreamNoAddress.Device,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\n\t\t\texpectedStreams: nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"no hosts found\",\n\n\t\t\tnmapResult:      &nmap.Run{},\n\t\t\texpectedStreams: nil,\n\t\t},\n\t\t{\n\t\t\tdescription: \"scan failed\",\n\n\t\t\tnmapError:    errors.New(\"scan failed\"),\n\t\t\tnmapWarnings: []string{\"invalid host\"},\n\t\t\texpectedErr:  errors.New(\"error while scanning network: scan failed\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tnmapMock := &nmapMock{}\n\n\t\t\tnmapMock.On(\"Run\").Return(test.nmapResult, test.nmapWarnings, test.nmapError)\n\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm: disgo.NewTerminal(disgo.WithDefaultOutput(ioutil.Discard)),\n\t\t\t}\n\n\t\t\tresults, err := scanner.scan(nmapMock)\n\n\t\t\tassert.Equal(t, test.expectedErr, err)\n\t\t\tassert.Equal(t, test.expectedStreams, results, \"wrong streams parsed\")\n\t\t\tassert.Equal(t, len(test.expectedStreams), len(results), \"wrong streams parsed\")\n\n\t\t\tnmapMock.AssertExpectations(t)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "scanner.go",
          "type": "blob",
          "size": 4.5712890625,
          "content": "package cameradar\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/Ullaakut/disgo\"\n\t\"github.com/Ullaakut/disgo/style\"\n\tcurl \"github.com/Ullaakut/go-curl\"\n)\n\nconst (\n\tdefaultCredentialDictionaryPath = \"${GOPATH}/src/github.com/Ullaakut/cameradar/dictionaries/credentials.json\"\n\tdefaultRouteDictionaryPath      = \"${GOPATH}/src/github.com/Ullaakut/cameradar/dictionaries/routes\"\n)\n\n// Scanner represents a cameradar scanner. It scans a network and\n// attacks all streams found to get their RTSP credentials.\ntype Scanner struct {\n\tcurl Curler\n\tterm *disgo.Terminal\n\n\ttargets                  []string\n\tports                    []string\n\tdebug                    bool\n\tverbose                  bool\n\tscanSpeed                int\n\tattackInterval           time.Duration\n\ttimeout                  time.Duration\n\tcredentialDictionaryPath string\n\trouteDictionaryPath      string\n\n\tcredentials Credentials\n\troutes      Routes\n}\n\n// New creates a new Cameradar Scanner and applies the given options.\nfunc New(options ...func(*Scanner)) (*Scanner, error) {\n\terr := curl.GlobalInit(curl.GLOBAL_ALL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to initialize curl library: %v\", err)\n\t}\n\n\thandle := curl.EasyInit()\n\tif handle == nil {\n\t\treturn nil, fmt.Errorf(\"unable to initialize curl handle: %v\", err)\n\t}\n\n\tscanner := &Scanner{\n\t\tcurl:                     &Curl{CURL: handle},\n\t\tcredentialDictionaryPath: defaultCredentialDictionaryPath,\n\t\trouteDictionaryPath:      defaultRouteDictionaryPath,\n\t}\n\n\tfor _, option := range options {\n\t\toption(scanner)\n\t}\n\n\tgopath := os.Getenv(\"GOPATH\")\n\tif gopath == \"\" && scanner.credentialDictionaryPath == defaultCredentialDictionaryPath && scanner.routeDictionaryPath == defaultRouteDictionaryPath {\n\t\tdisgo.Errorln(style.Failure(\"No $GOPATH was found.\\nDictionaries may not be loaded properly, please set your $GOPATH to use the default dictionaries.\"))\n\t}\n\n\tscanner.credentialDictionaryPath = os.ExpandEnv(scanner.credentialDictionaryPath)\n\tscanner.routeDictionaryPath = os.ExpandEnv(scanner.routeDictionaryPath)\n\n\tscanner.term = disgo.NewTerminal(\n\t\tdisgo.WithDebug(scanner.debug),\n\t)\n\n\terr = scanner.LoadTargets()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse target file: %v\", err)\n\t}\n\n\tscanner.term.StartStepf(\"Loading credentials\")\n\terr = scanner.LoadCredentials()\n\tif err != nil {\n\t\treturn nil, scanner.term.FailStepf(\"unable to load credentials dictionary: %v\", err)\n\t}\n\n\tscanner.term.StartStepf(\"Loading routes\")\n\terr = scanner.LoadRoutes()\n\tif err != nil {\n\t\treturn nil, scanner.term.FailStepf(\"unable to load credentials dictionary: %v\", err)\n\t}\n\n\tdisgo.EndStep()\n\n\treturn scanner, nil\n}\n\n// WithTargets specifies the targets to scan and attack.\nfunc WithTargets(targets []string) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.targets = targets\n\t}\n}\n\n// WithPorts specifies the ports to scan and attack.\nfunc WithPorts(ports []string) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.ports = ports\n\t}\n}\n\n// WithDebug specifies whether or not to enable debug logs.\nfunc WithDebug(debug bool) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.debug = debug\n\t}\n}\n\n// WithVerbose specifies whether or not to enable verbose logs.\nfunc WithVerbose(verbose bool) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.verbose = verbose\n\t}\n}\n\n// WithCustomCredentials specifies a custom credential dictionary\n// to use for the attacks.\nfunc WithCustomCredentials(dictionaryPath string) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.credentialDictionaryPath = dictionaryPath\n\t}\n}\n\n// WithCustomRoutes specifies a custom route dictionary\n// to use for the attacks.\nfunc WithCustomRoutes(dictionaryPath string) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.routeDictionaryPath = dictionaryPath\n\t}\n}\n\n// WithScanSpeed specifies the speed at which the scan should be executed. Faster\n// means easier to detect, slower has bigger timeout values and is more silent.\nfunc WithScanSpeed(speed int) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.scanSpeed = speed\n\t}\n}\n\n// WithAttackInterval specifies the interval of time during which Cameradar\n// should wait between each attack attempt during bruteforcing.\n// Setting a high value for this obviously makes attacks much slower.\nfunc WithAttackInterval(interval time.Duration) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.attackInterval = interval\n\t}\n}\n\n// WithTimeout specifies the amount of time after which attack requests should\n// timeout. This should be high if the network you are attacking has a poor\n// connectivity or that you are located far away from it.\nfunc WithTimeout(timeout time.Duration) func(s *Scanner) {\n\treturn func(s *Scanner) {\n\t\ts.timeout = timeout\n\t}\n}\n"
        },
        {
          "name": "scanner_test.go",
          "type": "blob",
          "size": 3.3310546875,
          "content": "package cameradar\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\tcurl \"github.com/Ullaakut/go-curl\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNew(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\n\t\ttargets           []string\n\t\tports             []string\n\t\tdebug             bool\n\t\tverbose           bool\n\t\tcustomCredentials string\n\t\tcustomRoutes      string\n\t\tspeed             int\n\t\tattackInterval    time.Duration\n\t\ttimeout           time.Duration\n\n\t\tloadTargetsFail bool\n\t\tloadCredsFail   bool\n\t\tloadRoutesFail  bool\n\n\t\tcurlGlobalFail bool\n\t\tcurlEasyFail   bool\n\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tdescription: \"no error while loading dictionaries\",\n\n\t\t\ttargets: []string{\"titi\", \"toto\"},\n\t\t\tports:   []string{\"554\"},\n\t\t\tdebug:   true,\n\t\t\tverbose: false,\n\t\t\tspeed:   3,\n\t\t\ttimeout: time.Millisecond,\n\t\t},\n\t\t{\n\t\t\tdescription: \"unable to load targets\",\n\n\t\t\tloadTargetsFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"unable to load credentials\",\n\n\t\t\tloadCredsFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"unable to load routes\",\n\n\t\t\tloadRoutesFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl fails to init\",\n\n\t\t\tcurlGlobalFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"curl fails to create handle\",\n\n\t\t\tcurlEasyFail: true,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"gopath not set and default dicts\",\n\n\t\t\tcustomCredentials: defaultCredentialDictionaryPath,\n\t\t\tcustomRoutes:      defaultRouteDictionaryPath,\n\n\t\t\texpectedErr: true,\n\t\t},\n\t}\n\n\t// Temporarily empty the gopath for testing purposes.\n\tdefer os.Setenv(\"GOPATH\", os.Getenv(\"GOPATH\"))\n\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tos.Setenv(\"GOPATH\", \"\")\n\n\t\t\tif test.loadTargetsFail {\n\t\t\t\ttest.targets = []string{generateTmpFileName(i, \"targets\")}\n\t\t\t\tioutil.WriteFile(test.targets[0], []byte(`0.0.0.0`), 0000)\n\t\t\t}\n\n\t\t\tif !test.loadCredsFail && test.customCredentials == \"\" {\n\t\t\t\ttest.customCredentials = generateTmpFileName(i, \"creds\")\n\t\t\t\tioutil.WriteFile(test.customCredentials, []byte(`{\"usernames\":[\"admin\"],\"passwords\":[\"admin\"]}`), 0644)\n\t\t\t}\n\n\t\t\tif !test.loadRoutesFail && test.customRoutes == \"\" {\n\t\t\t\ttest.customRoutes = generateTmpFileName(i, \"routes\")\n\t\t\t\tioutil.WriteFile(test.customRoutes, []byte(`live.sdp`), 0644)\n\t\t\t}\n\n\t\t\tcurl.TestGlobalFail = test.curlGlobalFail\n\t\t\tcurl.TestEasyFail = test.curlEasyFail\n\n\t\t\tscanner, err := New(\n\t\t\t\tWithTargets(test.targets),\n\t\t\t\tWithPorts(test.ports),\n\t\t\t\tWithDebug(test.debug),\n\t\t\t\tWithVerbose(test.verbose),\n\t\t\t\tWithScanSpeed(test.speed),\n\t\t\t\tWithAttackInterval(test.attackInterval),\n\t\t\t\tWithTimeout(test.timeout),\n\t\t\t\tWithCustomCredentials(test.customCredentials),\n\t\t\t\tWithCustomRoutes(test.customRoutes),\n\t\t\t)\n\n\t\t\tif test.expectedErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\n\t\t\tif scanner != nil {\n\t\t\t\tassert.Equal(t, test.targets, scanner.targets)\n\t\t\t\tassert.Equal(t, test.ports, scanner.ports)\n\t\t\t\tassert.Equal(t, test.debug, scanner.debug)\n\t\t\t\tassert.Equal(t, test.verbose, scanner.verbose)\n\t\t\t\tassert.Equal(t, test.speed, scanner.scanSpeed)\n\t\t\t\tassert.Equal(t, test.attackInterval, scanner.attackInterval)\n\t\t\t\tassert.Equal(t, test.timeout, scanner.timeout)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc generateTmpFileName(iteration int, purpose string) string {\n\treturn fmt.Sprintf(\"/tmp/cameradar_test_scanner_%s_%d_%d\", purpose, time.Now().Unix(), iteration)\n}\n"
        },
        {
          "name": "summary.go",
          "type": "blob",
          "size": 2.5185546875,
          "content": "package cameradar\n\nimport (\n\t\"github.com/Ullaakut/disgo/style\"\n\tcurl \"github.com/Ullaakut/go-curl\"\n)\n\n// PrintStreams prints information on each stream.\nfunc (s *Scanner) PrintStreams(streams []Stream) {\n\tif len(streams) == 0 {\n\t\ts.term.Infof(\"%s No streams were found. Please make sure that your target is on an accessible network.\\n\", style.Failure(style.SymbolCross))\n\t}\n\n\tsuccess := 0\n\tfor _, stream := range streams {\n\t\tif stream.Available {\n\t\t\ts.term.Infof(\"%s\\tDevice RTSP URL:\\t%s\\n\", style.Success(style.SymbolRightTriangle), style.Link(GetCameraRTSPURL(stream)))\n\t\t\ts.term.Infof(\"\\tAvailable:\\t\\t%s\\n\", style.Success(style.SymbolCheck))\n\t\t\tsuccess++\n\t\t} else {\n\t\t\ts.term.Infof(\"%s\\tAdmin panel URL:\\t%s You can use this URL to try attacking the camera's admin panel instead.\\n\", style.Failure(style.SymbolCross), style.Link(GetCameraAdminPanelURL(stream)))\n\t\t\ts.term.Infof(\"\\tAvailable:\\t\\t%s\\n\", style.Failure(style.SymbolCross))\n\t\t}\n\n\t\tif len(stream.Device) > 0 {\n\t\t\ts.term.Infof(\"\\tDevice model:\\t\\t%s\\n\\n\", stream.Device)\n\t\t}\n\n\t\ts.term.Infof(\"\\tIP address:\\t\\t%s\\n\", stream.Address)\n\t\ts.term.Infof(\"\\tRTSP port:\\t\\t%d\\n\", stream.Port)\n\n\t\tswitch stream.AuthenticationType {\n\t\tcase curl.AUTH_NONE:\n\t\t\ts.term.Infoln(\"\\tThis camera does not require authentication\")\n\t\tcase curl.AUTH_BASIC:\n\t\t\ts.term.Infoln(\"\\tAuth type:\\t\\tbasic\")\n\t\tcase curl.AUTH_DIGEST:\n\t\t\ts.term.Infoln(\"\\tAuth type:\\t\\tdigest\")\n\t\t}\n\n\t\tif stream.CredentialsFound {\n\t\t\ts.term.Infof(\"\\tUsername:\\t\\t%s\\n\", style.Success(stream.Username))\n\t\t\ts.term.Infof(\"\\tPassword:\\t\\t%s\\n\", style.Success(stream.Password))\n\t\t} else {\n\t\t\ts.term.Infof(\"\\tUsername:\\t\\t%s\\n\", style.Failure(\"not found\"))\n\t\t\ts.term.Infof(\"\\tPassword:\\t\\t%s\\n\", style.Failure(\"not found\"))\n\t\t}\n\n\t\ts.term.Infoln(\"\\tRTSP routes:\")\n\t\tif stream.RouteFound {\n\t\t\tfor _, route := range stream.Routes {\n\t\t\t\ts.term.Infoln(style.Success(\"\\t\\t\\t\\t/\" + route))\n\t\t\t}\n\t\t} else {\n\t\t\ts.term.Infoln(style.Failure(\"not found\"))\n\t\t}\n\n\t\ts.term.Info(\"\\n\\n\")\n\t}\n\n\tif success > 1 {\n\t\ts.term.Infof(\"%s Successful attack: %s devices were accessed\", style.Success(style.SymbolCheck), style.Success(len(streams)))\n\t} else if success == 1 {\n\t\ts.term.Infof(\"%s Successful attack: %s device was accessed\", style.Success(style.SymbolCheck), style.Success(\"one\"))\n\t} else {\n\t\ts.term.Infof(\"%s Streams were found but none were accessed. They are most likely configured with secure credentials and routes. You can try adding entries to the dictionary or generating your own in order to attempt a bruteforce attack on the cameras.\\n\", style.Failure(\"\\xE2\\x9C\\x96\"))\n\t}\n}\n"
        },
        {
          "name": "summary_test.go",
          "type": "blob",
          "size": 2.9599609375,
          "content": "package cameradar\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/Ullaakut/disgo\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar (\n\tunavailable = Stream{}\n\n\tavailable = Stream{\n\t\tAvailable: true,\n\t}\n\n\tdeviceFound = Stream{\n\t\tDevice: \"devicename\",\n\t}\n\n\tnoAuth = Stream{\n\t\tAuthenticationType: 0,\n\t}\n\n\tbasic = Stream{\n\t\tAuthenticationType: 1,\n\t}\n\n\tdigest = Stream{\n\t\tAuthenticationType: 2,\n\t}\n\n\tcredsFound = Stream{\n\t\tCredentialsFound: true,\n\t\tUsername:         \"us3r\",\n\t\tPassword:         \"p4ss\",\n\t}\n\n\trouteFound = Stream{\n\t\tRouteFound: true,\n\t\tRoutes:     []string{\"r0ute\"},\n\t}\n)\n\nfunc TestPrintStreams(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\n\t\tstreams []Stream\n\n\t\texpectedLogs []string\n\t}{\n\t\t{\n\t\t\tdescription: \"displays the proper message when no streams found\",\n\n\t\t\tstreams: nil,\n\n\t\t\texpectedLogs: []string{\"No streams were found\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays the admin panel URL when a stream is not accessible\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tunavailable,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"Admin panel URL\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays the device name when it is found\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tdeviceFound,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"Device model:\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays authentication type (no auth)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tnoAuth,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"This camera does not require authentication\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays authentication type (basic)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tbasic,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"basic\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays authentication type (digest)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tdigest,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\"digest\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays credentials properly\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tcredsFound,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"Username\",\n\t\t\t\t\"us3r\",\n\t\t\t\t\"Password\",\n\t\t\t\t\"p4ss\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays route properly\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\trouteFound,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"RTSP route\",\n\t\t\t\t\"/r0ute\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays successes properly (no success)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tunavailable,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"Streams were found but none were accessed\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays successes properly (1 success)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tavailable,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"Successful attack\",\n\t\t\t\t\"device was accessed\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"displays successes properly (multiple successes)\",\n\n\t\t\tstreams: []Stream{\n\t\t\t\tavailable,\n\t\t\t\tavailable,\n\t\t\t\tavailable,\n\t\t\t\tavailable,\n\t\t\t},\n\n\t\t\texpectedLogs: []string{\n\t\t\t\t\"Successful attack\",\n\t\t\t\t\"devices were accessed\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\twriter := &bytes.Buffer{}\n\t\t\tscanner := &Scanner{\n\t\t\t\tterm: disgo.NewTerminal(disgo.WithDefaultOutput(writer)),\n\t\t\t}\n\n\t\t\tscanner.PrintStreams(test.streams)\n\n\t\t\tfor _, expectedLog := range test.expectedLogs {\n\t\t\t\tassert.Contains(t, writer.String(), expectedLog)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}