{
  "metadata": {
    "timestamp": 1736567000492,
    "page": 581,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vishvananda/netlink",
      "stars": 2915,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": ".idea/\n.vscode/\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.0576171875,
          "content": "# Changelog\n\n## 1.0.0 (2018-03-15)\n\nInitial release tagging"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.54296875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   Copyright 2014 Vishvananda Ishaya.\n   Copyright 2014 Docker, Inc.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.740234375,
          "content": "DIRS := \\\n\t. \\\n\tnl\n\nDEPS = \\\n\tgithub.com/vishvananda/netns \\\n\tgolang.org/x/sys/unix\n\nuniq = $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1)))\ntestdirs = $(call uniq,$(foreach d,$(1),$(dir $(wildcard $(d)/*_test.go))))\ngoroot = $(addprefix ../../../,$(1))\nunroot = $(subst ../../../,,$(1))\nfmt = $(addprefix fmt-,$(1))\n\nall: test\n\n$(call goroot,$(DEPS)):\n\tgo get $(call unroot,$@)\n\n.PHONY: $(call testdirs,$(DIRS))\n$(call testdirs,$(DIRS)):\n\tgo test -test.exec sudo -test.parallel 4 -timeout 60s -test.v github.com/vishvananda/netlink/$@\n\n$(call fmt,$(call testdirs,$(DIRS))):\n\t! gofmt -l $(subst fmt-,,$@)/*.go | grep -q .\n\n.PHONY: fmt\nfmt: $(call fmt,$(call testdirs,$(DIRS)))\n\ntest: fmt $(call goroot,$(DEPS)) $(call testdirs,$(DIRS))\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.94921875,
          "content": "# netlink - netlink library for go #\n\n![Build Status](https://github.com/vishvananda/netlink/actions/workflows/main.yml/badge.svg) [![GoDoc](https://godoc.org/github.com/vishvananda/netlink?status.svg)](https://godoc.org/github.com/vishvananda/netlink)\n\nThe netlink package provides a simple netlink library for go. Netlink\nis the interface a user-space program in linux uses to communicate with\nthe kernel. It can be used to add and remove interfaces, set ip addresses\nand routes, and configure ipsec. Netlink communication requires elevated\nprivileges, so in most cases this code needs to be run as root. Since\nlow-level netlink messages are inscrutable at best, the library attempts\nto provide an api that is loosely modeled on the CLI provided by iproute2.\nActions like `ip link add` will be accomplished via a similarly named\nfunction like AddLink(). This library began its life as a fork of the\nnetlink functionality in\n[docker/libcontainer](https://github.com/docker/libcontainer) but was\nheavily rewritten to improve testability, performance, and to add new\nfunctionality like ipsec xfrm handling.\n\n## Local Build and Test ##\n\nYou can use go get command:\n\n    go get github.com/vishvananda/netlink\n\nTesting dependencies:\n\n    go get github.com/vishvananda/netns\n\nTesting (requires root):\n\n    sudo -E go test github.com/vishvananda/netlink\n\n## Examples ##\n\nAdd a new bridge and add eth1 into it:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/vishvananda/netlink\"\n)\n\nfunc main() {\n    la := netlink.NewLinkAttrs()\n    la.Name = \"foo\"\n    mybridge := &netlink.Bridge{LinkAttrs: la}\n    err := netlink.LinkAdd(mybridge)\n    if err != nil  {\n        fmt.Printf(\"could not add %s: %v\\n\", la.Name, err)\n    }\n    eth1, _ := netlink.LinkByName(\"eth1\")\n    netlink.LinkSetMaster(eth1, mybridge)\n}\n\n```\nNote `NewLinkAttrs` constructor, it sets default values in structure. For now\nit sets only `TxQLen` to `-1`, so kernel will set default by itself. If you're\nusing simple initialization(`LinkAttrs{Name: \"foo\"}`) `TxQLen` will be set to\n`0` unless you specify it like `LinkAttrs{Name: \"foo\", TxQLen: 1000}`.\n\nAdd a new ip address to loopback:\n\n```go\npackage main\n\nimport (\n    \"github.com/vishvananda/netlink\"\n)\n\nfunc main() {\n    lo, _ := netlink.LinkByName(\"lo\")\n    addr, _ := netlink.ParseAddr(\"169.254.169.254/32\")\n    netlink.AddrAdd(lo, addr)\n}\n\n```\n\n## Future Work ##\n\nMany pieces of netlink are not yet fully supported in the high-level\ninterface. Aspects of virtually all of the high-level objects don't exist.\nMany of the underlying primitives are there, so its a matter of putting\nthe right fields into the high-level objects and making sure that they\nare serialized and deserialized correctly in the Add and List methods.\n\nThere are also a few pieces of low level netlink functionality that still\nneed to be implemented. Routing rules are not in place and some of the\nmore advanced link types. Hopefully there is decent structure and testing\nin place to make these fairly straightforward to add.\n\n"
        },
        {
          "name": "addr.go",
          "type": "blob",
          "size": 1.27734375,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\n// Addr represents an IP address from netlink. Netlink ip addresses\n// include a mask, so it stores the address as a net.IPNet.\ntype Addr struct {\n\t*net.IPNet\n\tLabel       string\n\tFlags       int\n\tScope       int\n\tPeer        *net.IPNet\n\tBroadcast   net.IP\n\tPreferedLft int\n\tValidLft    int\n\tLinkIndex   int\n}\n\n// String returns $ip/$netmask $label\nfunc (a Addr) String() string {\n\treturn strings.TrimSpace(fmt.Sprintf(\"%s %s\", a.IPNet, a.Label))\n}\n\n// ParseAddr parses the string representation of an address in the\n// form $ip/$netmask $label. The label portion is optional\nfunc ParseAddr(s string) (*Addr, error) {\n\tlabel := \"\"\n\tparts := strings.Split(s, \" \")\n\tif len(parts) > 1 {\n\t\ts = parts[0]\n\t\tlabel = parts[1]\n\t}\n\tm, err := ParseIPNet(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Addr{IPNet: m, Label: label}, nil\n}\n\n// Equal returns true if both Addrs have the same net.IPNet value.\nfunc (a Addr) Equal(x Addr) bool {\n\tsizea, _ := a.Mask.Size()\n\tsizeb, _ := x.Mask.Size()\n\t// ignore label for comparison\n\treturn a.IP.Equal(x.IP) && sizea == sizeb\n}\n\nfunc (a Addr) PeerEqual(x Addr) bool {\n\tsizea, _ := a.Peer.Mask.Size()\n\tsizeb, _ := x.Peer.Mask.Size()\n\t// ignore label for comparison\n\treturn a.Peer.IP.Equal(x.Peer.IP) && sizea == sizeb\n}\n"
        },
        {
          "name": "addr_linux.go",
          "type": "blob",
          "size": 12.0703125,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\n// If `net.IPv4zero` is given as the broadcast address, broadcast is disabled.\nfunc AddrAdd(link Link, addr *Addr) error {\n\treturn pkgHandle.AddrAdd(link, addr)\n}\n\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\n// If `net.IPv4zero` is given as the broadcast address, broadcast is disabled.\nfunc (h *Handle) AddrAdd(link Link, addr *Addr) error {\n\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\treturn h.addrHandle(link, addr, req)\n}\n\n// AddrReplace will replace (or, if not present, add) an IP address on a link device.\n//\n// Equivalent to: `ip addr replace $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\n// If `net.IPv4zero` is given as the broadcast address, broadcast is disabled.\nfunc AddrReplace(link Link, addr *Addr) error {\n\treturn pkgHandle.AddrReplace(link, addr)\n}\n\n// AddrReplace will replace (or, if not present, add) an IP address on a link device.\n//\n// Equivalent to: `ip addr replace $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\n// If `net.IPv4zero` is given as the broadcast address, broadcast is disabled.\nfunc (h *Handle) AddrReplace(link Link, addr *Addr) error {\n\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_REPLACE|unix.NLM_F_ACK)\n\treturn h.addrHandle(link, addr, req)\n}\n\n// AddrDel will delete an IP address from a link device.\n//\n// Equivalent to: `ip addr del $addr dev $link`\nfunc AddrDel(link Link, addr *Addr) error {\n\treturn pkgHandle.AddrDel(link, addr)\n}\n\n// AddrDel will delete an IP address from a link device.\n//\n// Equivalent to: `ip addr del $addr dev $link`\nfunc (h *Handle) AddrDel(link Link, addr *Addr) error {\n\treq := h.newNetlinkRequest(unix.RTM_DELADDR, unix.NLM_F_ACK)\n\treturn h.addrHandle(link, addr, req)\n}\n\nfunc (h *Handle) addrHandle(link Link, addr *Addr, req *nl.NetlinkRequest) error {\n\tfamily := nl.GetIPFamily(addr.IP)\n\tmsg := nl.NewIfAddrmsg(family)\n\tmsg.Scope = uint8(addr.Scope)\n\tif link == nil {\n\t\tmsg.Index = uint32(addr.LinkIndex)\n\t} else {\n\t\tbase := link.Attrs()\n\t\tif addr.Label != \"\" && !strings.HasPrefix(addr.Label, base.Name) {\n\t\t\treturn fmt.Errorf(\"label must begin with interface name\")\n\t\t}\n\t\th.ensureIndex(base)\n\t\tmsg.Index = uint32(base.Index)\n\t}\n\tmask := addr.Mask\n\tif addr.Peer != nil {\n\t\tmask = addr.Peer.Mask\n\t}\n\tprefixlen, masklen := mask.Size()\n\tmsg.Prefixlen = uint8(prefixlen)\n\treq.AddData(msg)\n\n\tvar localAddrData []byte\n\tif family == FAMILY_V4 {\n\t\tlocalAddrData = addr.IP.To4()\n\t} else {\n\t\tlocalAddrData = addr.IP.To16()\n\t}\n\n\tlocalData := nl.NewRtAttr(unix.IFA_LOCAL, localAddrData)\n\treq.AddData(localData)\n\tvar peerAddrData []byte\n\tif addr.Peer != nil {\n\t\tif family == FAMILY_V4 {\n\t\t\tpeerAddrData = addr.Peer.IP.To4()\n\t\t} else {\n\t\t\tpeerAddrData = addr.Peer.IP.To16()\n\t\t}\n\t} else {\n\t\tpeerAddrData = localAddrData\n\t}\n\n\taddressData := nl.NewRtAttr(unix.IFA_ADDRESS, peerAddrData)\n\treq.AddData(addressData)\n\n\tif addr.Flags != 0 {\n\t\tif addr.Flags <= 0xff {\n\t\t\tmsg.IfAddrmsg.Flags = uint8(addr.Flags)\n\t\t} else {\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, uint32(addr.Flags))\n\t\t\tflagsData := nl.NewRtAttr(unix.IFA_FLAGS, b)\n\t\t\treq.AddData(flagsData)\n\t\t}\n\t}\n\n\tif family == FAMILY_V4 {\n\t\t// Automatically set the broadcast address if it is unset and the\n\t\t// subnet is large enough to sensibly have one (/30 or larger).\n\t\t// See: RFC 3021\n\t\tif addr.Broadcast == nil && prefixlen < 31 {\n\t\t\tcalcBroadcast := make(net.IP, masklen/8)\n\t\t\tfor i := range localAddrData {\n\t\t\t\tcalcBroadcast[i] = localAddrData[i] | ^mask[i]\n\t\t\t}\n\t\t\taddr.Broadcast = calcBroadcast\n\t\t}\n\n\t\tif net.IPv4zero.Equal(addr.Broadcast) {\n\t\t\taddr.Broadcast = nil\n\t\t}\n\n\t\tif addr.Broadcast != nil {\n\t\t\treq.AddData(nl.NewRtAttr(unix.IFA_BROADCAST, addr.Broadcast))\n\t\t}\n\n\t\tif addr.Label != \"\" {\n\t\t\tlabelData := nl.NewRtAttr(unix.IFA_LABEL, nl.ZeroTerminated(addr.Label))\n\t\t\treq.AddData(labelData)\n\t\t}\n\t}\n\n\t// 0 is the default value for these attributes. However, 0 means \"expired\", while the least-surprising default\n\t// value should be \"forever\". To compensate for that, only add the attributes if at least one of the values is\n\t// non-zero, which means the caller has explicitly set them\n\tif addr.ValidLft > 0 || addr.PreferedLft > 0 {\n\t\tcachedata := nl.IfaCacheInfo{unix.IfaCacheinfo{\n\t\t\tValid:    uint32(addr.ValidLft),\n\t\t\tPrefered: uint32(addr.PreferedLft),\n\t\t}}\n\t\treq.AddData(nl.NewRtAttr(unix.IFA_CACHEINFO, cachedata.Serialize()))\n\t}\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// AddrList gets a list of IP addresses in the system.\n// Equivalent to: `ip addr show`.\n// The list can be filtered by link and ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc AddrList(link Link, family int) ([]Addr, error) {\n\treturn pkgHandle.AddrList(link, family)\n}\n\n// AddrList gets a list of IP addresses in the system.\n// Equivalent to: `ip addr show`.\n// The list can be filtered by link and ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) AddrList(link Link, family int) ([]Addr, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETADDR, unix.NLM_F_DUMP)\n\tmsg := nl.NewIfAddrmsg(family)\n\treq.AddData(msg)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWADDR)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tindexFilter := 0\n\tif link != nil {\n\t\tbase := link.Attrs()\n\t\th.ensureIndex(base)\n\t\tindexFilter = base.Index\n\t}\n\n\tvar res []Addr\n\tfor _, m := range msgs {\n\t\taddr, msgFamily, err := parseAddr(m)\n\t\tif err != nil {\n\t\t\treturn res, err\n\t\t}\n\n\t\tif link != nil && addr.LinkIndex != indexFilter {\n\t\t\t// Ignore messages from other interfaces\n\t\t\tcontinue\n\t\t}\n\n\t\tif family != FAMILY_ALL && msgFamily != family {\n\t\t\tcontinue\n\t\t}\n\n\t\tres = append(res, addr)\n\t}\n\n\treturn res, executeErr\n}\n\nfunc parseAddr(m []byte) (addr Addr, family int, err error) {\n\tmsg := nl.DeserializeIfAddrmsg(m)\n\n\tfamily = -1\n\taddr.LinkIndex = -1\n\n\tattrs, err1 := nl.ParseRouteAttr(m[msg.Len():])\n\tif err1 != nil {\n\t\terr = err1\n\t\treturn\n\t}\n\n\tfamily = int(msg.Family)\n\taddr.LinkIndex = int(msg.Index)\n\n\tvar local, dst *net.IPNet\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase unix.IFA_ADDRESS:\n\t\t\tdst = &net.IPNet{\n\t\t\t\tIP:   attr.Value,\n\t\t\t\tMask: net.CIDRMask(int(msg.Prefixlen), 8*len(attr.Value)),\n\t\t\t}\n\t\tcase unix.IFA_LOCAL:\n\t\t\t// iproute2 manual:\n\t\t\t// If a peer address is specified, the local address\n\t\t\t// cannot have a prefix length. The network prefix is\n\t\t\t// associated with the peer rather than with the local\n\t\t\t// address.\n\t\t\tn := 8 * len(attr.Value)\n\t\t\tlocal = &net.IPNet{\n\t\t\t\tIP:   attr.Value,\n\t\t\t\tMask: net.CIDRMask(n, n),\n\t\t\t}\n\t\tcase unix.IFA_BROADCAST:\n\t\t\taddr.Broadcast = attr.Value\n\t\tcase unix.IFA_LABEL:\n\t\t\taddr.Label = string(attr.Value[:len(attr.Value)-1])\n\t\tcase unix.IFA_FLAGS:\n\t\t\taddr.Flags = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFA_CACHEINFO:\n\t\t\tci := nl.DeserializeIfaCacheInfo(attr.Value)\n\t\t\taddr.PreferedLft = int(ci.Prefered)\n\t\t\taddr.ValidLft = int(ci.Valid)\n\t\t}\n\t}\n\n\t// libnl addr.c comment:\n\t// IPv6 sends the local address as IFA_ADDRESS with no\n\t// IFA_LOCAL, IPv4 sends both IFA_LOCAL and IFA_ADDRESS\n\t// with IFA_ADDRESS being the peer address if they differ\n\t//\n\t// But obviously, as there are IPv6 PtP addresses, too,\n\t// IFA_LOCAL should also be handled for IPv6.\n\tif local != nil {\n\t\tif family == FAMILY_V4 && dst != nil && local.IP.Equal(dst.IP) {\n\t\t\taddr.IPNet = dst\n\t\t} else {\n\t\t\taddr.IPNet = local\n\t\t\taddr.Peer = dst\n\t\t}\n\t} else {\n\t\taddr.IPNet = dst\n\t}\n\n\taddr.Scope = int(msg.Scope)\n\n\treturn\n}\n\ntype AddrUpdate struct {\n\tLinkAddress net.IPNet\n\tLinkIndex   int\n\tFlags       int\n\tScope       int\n\tPreferedLft int\n\tValidLft    int\n\tNewAddr     bool // true=added false=deleted\n}\n\n// AddrSubscribe takes a chan down which notifications will be sent\n// when addresses change.  Close the 'done' chan to stop subscription.\nfunc AddrSubscribe(ch chan<- AddrUpdate, done <-chan struct{}) error {\n\treturn addrSubscribeAt(netns.None(), netns.None(), ch, done, nil, false, 0, nil, false)\n}\n\n// AddrSubscribeAt works like AddrSubscribe plus it allows the caller\n// to choose the network namespace in which to subscribe (ns).\nfunc AddrSubscribeAt(ns netns.NsHandle, ch chan<- AddrUpdate, done <-chan struct{}) error {\n\treturn addrSubscribeAt(ns, netns.None(), ch, done, nil, false, 0, nil, false)\n}\n\n// AddrSubscribeOptions contains a set of options to use with\n// AddrSubscribeWithOptions.\ntype AddrSubscribeOptions struct {\n\tNamespace              *netns.NsHandle\n\tErrorCallback          func(error)\n\tListExisting           bool\n\tReceiveBufferSize      int\n\tReceiveBufferForceSize bool\n\tReceiveTimeout         *unix.Timeval\n}\n\n// AddrSubscribeWithOptions work like AddrSubscribe but enable to\n// provide additional options to modify the behavior. Currently, the\n// namespace can be provided as well as an error callback.\nfunc AddrSubscribeWithOptions(ch chan<- AddrUpdate, done <-chan struct{}, options AddrSubscribeOptions) error {\n\tif options.Namespace == nil {\n\t\tnone := netns.None()\n\t\toptions.Namespace = &none\n\t}\n\treturn addrSubscribeAt(*options.Namespace, netns.None(), ch, done, options.ErrorCallback, options.ListExisting,\n\t\toptions.ReceiveBufferSize, options.ReceiveTimeout, options.ReceiveBufferForceSize)\n}\n\nfunc addrSubscribeAt(newNs, curNs netns.NsHandle, ch chan<- AddrUpdate, done <-chan struct{}, cberr func(error), listExisting bool,\n\trcvbuf int, rcvTimeout *unix.Timeval, rcvBufForce bool) error {\n\ts, err := nl.SubscribeAt(newNs, curNs, unix.NETLINK_ROUTE, unix.RTNLGRP_IPV4_IFADDR, unix.RTNLGRP_IPV6_IFADDR)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif rcvTimeout != nil {\n\t\tif err := s.SetReceiveTimeout(rcvTimeout); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif rcvbuf != 0 {\n\t\terr = s.SetReceiveBufferSize(rcvbuf, rcvBufForce)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif done != nil {\n\t\tgo func() {\n\t\t\t<-done\n\t\t\ts.Close()\n\t\t}()\n\t}\n\tif listExisting {\n\t\treq := pkgHandle.newNetlinkRequest(unix.RTM_GETADDR,\n\t\t\tunix.NLM_F_DUMP)\n\t\tinfmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\t\treq.AddData(infmsg)\n\t\tif err := s.Send(req); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor {\n\t\t\tmsgs, from, err := s.Receive()\n\t\t\tif err != nil {\n\t\t\t\tif cberr != nil {\n\t\t\t\t\tcberr(fmt.Errorf(\"Receive failed: %v\",\n\t\t\t\t\t\terr))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif from.Pid != nl.PidKernel {\n\t\t\t\tif cberr != nil {\n\t\t\t\t\tcberr(fmt.Errorf(\"Wrong sender portid %d, expected %d\", from.Pid, nl.PidKernel))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, m := range msgs {\n\t\t\t\tif m.Header.Type == unix.NLMSG_DONE {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif m.Header.Type == unix.NLMSG_ERROR {\n\t\t\t\t\terror := int32(native.Uint32(m.Data[0:4]))\n\t\t\t\t\tif error == 0 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\tcberr(fmt.Errorf(\"error message: %v\",\n\t\t\t\t\t\t\tsyscall.Errno(-error)))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmsgType := m.Header.Type\n\t\t\t\tif msgType != unix.RTM_NEWADDR && msgType != unix.RTM_DELADDR {\n\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\tcberr(fmt.Errorf(\"bad message type: %d\", msgType))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\taddr, _, err := parseAddr(m.Data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\tcberr(fmt.Errorf(\"could not parse address: %v\", err))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tch <- AddrUpdate{LinkAddress: *addr.IPNet,\n\t\t\t\t\tLinkIndex:   addr.LinkIndex,\n\t\t\t\t\tNewAddr:     msgType == unix.RTM_NEWADDR,\n\t\t\t\t\tFlags:       addr.Flags,\n\t\t\t\t\tScope:       addr.Scope,\n\t\t\t\t\tPreferedLft: addr.PreferedLft,\n\t\t\t\t\tValidLft:    addr.ValidLft}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n"
        },
        {
          "name": "addr_test.go",
          "type": "blob",
          "size": 6.7568359375,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestAddrAdd(t *testing.T) {\n\tDoTestAddr(t, AddrAdd)\n}\n\nfunc TestAddrReplace(t *testing.T) {\n\tDoTestAddr(t, AddrReplace)\n}\n\nfunc DoTestAddr(t *testing.T, FunctionUndertest func(Link, *Addr) error) {\n\tif os.Getenv(\"CI\") == \"true\" {\n\t\tt.Skipf(\"Fails in CI with: addr_test.go:*: Address flags not set properly, got=128, expected=132\")\n\t}\n\t// TODO: IFA_F_PERMANENT does not seem to be set by default on older kernels?\n\t// TODO: IFA_F_OPTIMISTIC failing in CI. should we just skip that one check?\n\tvar address = &net.IPNet{IP: net.IPv4(127, 0, 0, 2), Mask: net.CIDRMask(32, 32)}\n\tvar peer = &net.IPNet{IP: net.IPv4(127, 0, 0, 3), Mask: net.CIDRMask(24, 32)}\n\tvar addrTests = []struct {\n\t\taddr     *Addr\n\t\texpected *Addr\n\t}{\n\t\t{\n\t\t\t&Addr{IPNet: address},\n\t\t\t&Addr{IPNet: address, Label: \"lo\", Scope: unix.RT_SCOPE_UNIVERSE, Flags: unix.IFA_F_PERMANENT},\n\t\t},\n\t\t{\n\t\t\t&Addr{IPNet: address, Label: \"local\"},\n\t\t\t&Addr{IPNet: address, Label: \"local\", Scope: unix.RT_SCOPE_UNIVERSE, Flags: unix.IFA_F_PERMANENT},\n\t\t},\n\t\t{\n\t\t\t&Addr{IPNet: address, Flags: unix.IFA_F_OPTIMISTIC},\n\t\t\t&Addr{IPNet: address, Label: \"lo\", Flags: unix.IFA_F_OPTIMISTIC | unix.IFA_F_PERMANENT, Scope: unix.RT_SCOPE_UNIVERSE},\n\t\t},\n\t\t{\n\t\t\t&Addr{IPNet: address, Flags: unix.IFA_F_OPTIMISTIC | unix.IFA_F_DADFAILED},\n\t\t\t&Addr{IPNet: address, Label: \"lo\", Flags: unix.IFA_F_OPTIMISTIC | unix.IFA_F_DADFAILED | unix.IFA_F_PERMANENT, Scope: unix.RT_SCOPE_UNIVERSE},\n\t\t},\n\t\t{\n\t\t\t&Addr{IPNet: address, Scope: unix.RT_SCOPE_NOWHERE},\n\t\t\t&Addr{IPNet: address, Label: \"lo\", Flags: unix.IFA_F_PERMANENT, Scope: unix.RT_SCOPE_NOWHERE},\n\t\t},\n\t\t{\n\t\t\t&Addr{IPNet: address, Peer: peer},\n\t\t\t&Addr{IPNet: address, Peer: peer, Label: \"lo\", Scope: unix.RT_SCOPE_UNIVERSE, Flags: unix.IFA_F_PERMANENT},\n\t\t},\n\t}\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tt := range addrTests {\n\t\tif err = FunctionUndertest(link, tt.addr); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\taddrs, err := AddrList(link, FAMILY_ALL)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(addrs) != 1 {\n\t\t\tt.Fatal(\"Address not added properly\")\n\t\t}\n\n\t\tif !addrs[0].Equal(*tt.expected) {\n\t\t\tt.Fatalf(\"Address ip no set properly, got=%s, expected=%s\", addrs[0], tt.expected)\n\t\t}\n\n\t\tif addrs[0].Label != tt.expected.Label {\n\t\t\tt.Fatalf(\"Address label not set properly, got=%s, expected=%s\", addrs[0].Label, tt.expected.Label)\n\t\t}\n\n\t\tif addrs[0].Flags != tt.expected.Flags {\n\t\t\tt.Fatalf(\"Address flags not set properly, got=%d, expected=%d\", addrs[0].Flags, tt.expected.Flags)\n\t\t}\n\n\t\tif addrs[0].Scope != tt.expected.Scope {\n\t\t\tt.Fatalf(\"Address scope not set properly, got=%d, expected=%d\", addrs[0].Scope, tt.expected.Scope)\n\t\t}\n\n\t\tif ifindex := link.Attrs().Index; ifindex != addrs[0].LinkIndex {\n\t\t\tt.Fatalf(\"Address ifindex not set properly, got=%d, expected=%d\", addrs[0].LinkIndex, ifindex)\n\t\t}\n\n\t\tif tt.expected.Peer != nil {\n\t\t\tif !addrs[0].PeerEqual(*tt.expected) {\n\t\t\t\tt.Fatalf(\"Peer Address ip no set properly, got=%s, expected=%s\", addrs[0].Peer, tt.expected.Peer)\n\t\t\t}\n\t\t}\n\n\t\t// Pass FAMILY_V4, we should get the same results as FAMILY_ALL\n\t\taddrs, err = AddrList(link, FAMILY_V4)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(addrs) != 1 {\n\t\t\tt.Fatal(\"Address not added properly\")\n\t\t}\n\n\t\t// Pass a wrong family number, we should get nil list\n\t\taddrs, err = AddrList(link, 0x8)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(addrs) != 0 {\n\t\t\tt.Fatal(\"Address not expected\")\n\t\t}\n\n\t\tif err = AddrDel(link, tt.addr); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\taddrs, err = AddrList(link, FAMILY_ALL)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(addrs) != 0 {\n\t\t\tt.Fatal(\"Address not removed properly\")\n\t\t}\n\t}\n\n}\n\nfunc TestAddrAddReplace(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tfor _, nilLink := range []bool{false, true} {\n\t\tvar address = &net.IPNet{IP: net.IPv4(127, 0, 0, 2), Mask: net.CIDRMask(24, 32)}\n\t\tvar addr = &Addr{IPNet: address}\n\n\t\tlink, err := LinkByName(\"lo\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif nilLink {\n\t\t\taddr.LinkIndex = link.Attrs().Index\n\t\t\tlink = nil\n\t\t}\n\n\t\terr = AddrAdd(link, addr)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\taddrs, err := AddrList(link, FAMILY_ALL)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(addrs) != 1 {\n\t\t\tt.Fatal(\"Address not added properly\")\n\t\t}\n\n\t\terr = AddrAdd(link, addr)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Re-adding address should fail (but succeeded unexpectedly).\")\n\t\t}\n\n\t\terr = AddrReplace(link, addr)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Replacing address failed.\")\n\t\t}\n\n\t\taddrs, err = AddrList(link, FAMILY_ALL)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(addrs) != 1 {\n\t\t\tt.Fatal(\"Address not added properly\")\n\t\t}\n\n\t\tif err = AddrDel(link, addr); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\taddrs, err = AddrList(link, FAMILY_ALL)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(addrs) != 0 {\n\t\t\tt.Fatal(\"Address not removed properly\")\n\t\t}\n\t}\n}\n\nfunc expectAddrUpdate(ch <-chan AddrUpdate, add bool, dst net.IP) bool {\n\tfor {\n\t\ttimeout := time.After(time.Minute)\n\t\tselect {\n\t\tcase update := <-ch:\n\t\t\tif update.NewAddr == add && update.LinkAddress.IP.Equal(dst) {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase <-timeout:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunc TestAddrSubscribeWithOptions(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tch := make(chan AddrUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tvar lastError error\n\tdefer func() {\n\t\tif lastError != nil {\n\t\t\tt.Fatalf(\"Fatal error received during subscription: %v\", lastError)\n\t\t}\n\t}()\n\tif err := AddrSubscribeWithOptions(ch, done, AddrSubscribeOptions{\n\t\tErrorCallback: func(err error) {\n\t\t\tlastError = err\n\t\t},\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tip := net.IPv4(127, 0, 0, 1)\n\tif !expectAddrUpdate(ch, true, ip) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n}\n\nfunc TestAddrSubscribeListExisting(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tch := make(chan AddrUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar lastError error\n\tdefer func() {\n\t\tif lastError != nil {\n\t\t\tt.Fatalf(\"Fatal error received during subscription: %v\", lastError)\n\t\t}\n\t}()\n\tif err := AddrSubscribeWithOptions(ch, done, AddrSubscribeOptions{\n\t\tErrorCallback: func(err error) {\n\t\t\tlastError = err\n\t\t},\n\t\tListExisting: true,\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tip := net.IPv4(127, 0, 0, 1)\n\tif !expectAddrUpdate(ch, true, ip) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n}\n"
        },
        {
          "name": "bpf_linux.go",
          "type": "blob",
          "size": 1.6982421875,
          "content": "package netlink\n\nimport (\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\ntype BpfProgType uint32\n\nconst (\n\tBPF_PROG_TYPE_UNSPEC BpfProgType = iota\n\tBPF_PROG_TYPE_SOCKET_FILTER\n\tBPF_PROG_TYPE_KPROBE\n\tBPF_PROG_TYPE_SCHED_CLS\n\tBPF_PROG_TYPE_SCHED_ACT\n\tBPF_PROG_TYPE_TRACEPOINT\n\tBPF_PROG_TYPE_XDP\n\tBPF_PROG_TYPE_PERF_EVENT\n\tBPF_PROG_TYPE_CGROUP_SKB\n\tBPF_PROG_TYPE_CGROUP_SOCK\n\tBPF_PROG_TYPE_LWT_IN\n\tBPF_PROG_TYPE_LWT_OUT\n\tBPF_PROG_TYPE_LWT_XMIT\n\tBPF_PROG_TYPE_SOCK_OPS\n\tBPF_PROG_TYPE_SK_SKB\n\tBPF_PROG_TYPE_CGROUP_DEVICE\n\tBPF_PROG_TYPE_SK_MSG\n\tBPF_PROG_TYPE_RAW_TRACEPOINT\n\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR\n\tBPF_PROG_TYPE_LWT_SEG6LOCAL\n\tBPF_PROG_TYPE_LIRC_MODE2\n\tBPF_PROG_TYPE_SK_REUSEPORT\n\tBPF_PROG_TYPE_FLOW_DISSECTOR\n\tBPF_PROG_TYPE_CGROUP_SYSCTL\n\tBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE\n\tBPF_PROG_TYPE_CGROUP_SOCKOPT\n\tBPF_PROG_TYPE_TRACING\n\tBPF_PROG_TYPE_STRUCT_OPS\n\tBPF_PROG_TYPE_EXT\n\tBPF_PROG_TYPE_LSM\n\tBPF_PROG_TYPE_SK_LOOKUP\n)\n\ntype BPFAttr struct {\n\tProgType    uint32\n\tInsnCnt     uint32\n\tInsns       uintptr\n\tLicense     uintptr\n\tLogLevel    uint32\n\tLogSize     uint32\n\tLogBuf      uintptr\n\tKernVersion uint32\n}\n\n// loadSimpleBpf loads a trivial bpf program for testing purposes.\nfunc loadSimpleBpf(progType BpfProgType, ret uint32) (int, error) {\n\tinsns := []uint64{\n\t\t0x00000000000000b7 | (uint64(ret) << 32),\n\t\t0x0000000000000095,\n\t}\n\tlicense := []byte{'A', 'S', 'L', '2', '\\x00'}\n\tattr := BPFAttr{\n\t\tProgType: uint32(progType),\n\t\tInsnCnt:  uint32(len(insns)),\n\t\tInsns:    uintptr(unsafe.Pointer(&insns[0])),\n\t\tLicense:  uintptr(unsafe.Pointer(&license[0])),\n\t}\n\tfd, _, errno := unix.Syscall(unix.SYS_BPF,\n\t\t5, /* bpf cmd */\n\t\tuintptr(unsafe.Pointer(&attr)),\n\t\tunsafe.Sizeof(attr))\n\tif errno != 0 {\n\t\treturn 0, errno\n\t}\n\treturn int(fd), nil\n}\n"
        },
        {
          "name": "bridge_linux.go",
          "type": "blob",
          "size": 5.5224609375,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// BridgeVlanList gets a map of device id to bridge vlan infos.\n// Equivalent to: `bridge vlan show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc BridgeVlanList() (map[int32][]*nl.BridgeVlanInfo, error) {\n\treturn pkgHandle.BridgeVlanList()\n}\n\n// BridgeVlanList gets a map of device id to bridge vlan infos.\n// Equivalent to: `bridge vlan show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) BridgeVlanList() (map[int32][]*nl.BridgeVlanInfo, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETLINK, unix.NLM_F_DUMP)\n\tmsg := nl.NewIfInfomsg(unix.AF_BRIDGE)\n\treq.AddData(msg)\n\treq.AddData(nl.NewRtAttr(unix.IFLA_EXT_MASK, nl.Uint32Attr(uint32(nl.RTEXT_FILTER_BRVLAN))))\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWLINK)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tret := make(map[int32][]*nl.BridgeVlanInfo)\n\tfor _, m := range msgs {\n\t\tmsg := nl.DeserializeIfInfomsg(m)\n\n\t\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, attr := range attrs {\n\t\t\tswitch attr.Attr.Type {\n\t\t\tcase unix.IFLA_AF_SPEC:\n\t\t\t\t//nested attr\n\t\t\t\tnestAttrs, err := nl.ParseRouteAttr(attr.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"failed to parse nested attr %v\", err)\n\t\t\t\t}\n\t\t\t\tfor _, nestAttr := range nestAttrs {\n\t\t\t\t\tswitch nestAttr.Attr.Type {\n\t\t\t\t\tcase nl.IFLA_BRIDGE_VLAN_INFO:\n\t\t\t\t\t\tvlanInfo := nl.DeserializeBridgeVlanInfo(nestAttr.Value)\n\t\t\t\t\t\tret[msg.Index] = append(ret[msg.Index], vlanInfo)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret, executeErr\n}\n\n// BridgeVlanAdd adds a new vlan filter entry\n// Equivalent to: `bridge vlan add dev DEV vid VID [ pvid ] [ untagged ] [ self ] [ master ]`\nfunc BridgeVlanAdd(link Link, vid uint16, pvid, untagged, self, master bool) error {\n\treturn pkgHandle.BridgeVlanAdd(link, vid, pvid, untagged, self, master)\n}\n\n// BridgeVlanAdd adds a new vlan filter entry\n// Equivalent to: `bridge vlan add dev DEV vid VID [ pvid ] [ untagged ] [ self ] [ master ]`\nfunc (h *Handle) BridgeVlanAdd(link Link, vid uint16, pvid, untagged, self, master bool) error {\n\treturn h.bridgeVlanModify(unix.RTM_SETLINK, link, vid, 0, pvid, untagged, self, master)\n}\n\n// BridgeVlanAddRange adds a new vlan filter entry\n// Equivalent to: `bridge vlan add dev DEV vid VID-VIDEND [ pvid ] [ untagged ] [ self ] [ master ]`\nfunc BridgeVlanAddRange(link Link, vid, vidEnd uint16, pvid, untagged, self, master bool) error {\n\treturn pkgHandle.BridgeVlanAddRange(link, vid, vidEnd, pvid, untagged, self, master)\n}\n\n// BridgeVlanAddRange adds a new vlan filter entry\n// Equivalent to: `bridge vlan add dev DEV vid VID-VIDEND [ pvid ] [ untagged ] [ self ] [ master ]`\nfunc (h *Handle) BridgeVlanAddRange(link Link, vid, vidEnd uint16, pvid, untagged, self, master bool) error {\n\treturn h.bridgeVlanModify(unix.RTM_SETLINK, link, vid, vidEnd, pvid, untagged, self, master)\n}\n\n// BridgeVlanDel adds a new vlan filter entry\n// Equivalent to: `bridge vlan del dev DEV vid VID [ pvid ] [ untagged ] [ self ] [ master ]`\nfunc BridgeVlanDel(link Link, vid uint16, pvid, untagged, self, master bool) error {\n\treturn pkgHandle.BridgeVlanDel(link, vid, pvid, untagged, self, master)\n}\n\n// BridgeVlanDel adds a new vlan filter entry\n// Equivalent to: `bridge vlan del dev DEV vid VID [ pvid ] [ untagged ] [ self ] [ master ]`\nfunc (h *Handle) BridgeVlanDel(link Link, vid uint16, pvid, untagged, self, master bool) error {\n\treturn h.bridgeVlanModify(unix.RTM_DELLINK, link, vid, 0, pvid, untagged, self, master)\n}\n\n// BridgeVlanDelRange adds a new vlan filter entry\n// Equivalent to: `bridge vlan del dev DEV vid VID-VIDEND [ pvid ] [ untagged ] [ self ] [ master ]`\nfunc BridgeVlanDelRange(link Link, vid, vidEnd uint16, pvid, untagged, self, master bool) error {\n\treturn pkgHandle.BridgeVlanDelRange(link, vid, vidEnd, pvid, untagged, self, master)\n}\n\n// BridgeVlanDelRange adds a new vlan filter entry\n// Equivalent to: `bridge vlan del dev DEV vid VID-VIDEND [ pvid ] [ untagged ] [ self ] [ master ]`\nfunc (h *Handle) BridgeVlanDelRange(link Link, vid, vidEnd uint16, pvid, untagged, self, master bool) error {\n\treturn h.bridgeVlanModify(unix.RTM_DELLINK, link, vid, vidEnd, pvid, untagged, self, master)\n}\n\nfunc (h *Handle) bridgeVlanModify(cmd int, link Link, vid, vidEnd uint16, pvid, untagged, self, master bool) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(cmd, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_BRIDGE)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tbr := nl.NewRtAttr(unix.IFLA_AF_SPEC, nil)\n\tvar flags uint16\n\tif self {\n\t\tflags |= nl.BRIDGE_FLAGS_SELF\n\t}\n\tif master {\n\t\tflags |= nl.BRIDGE_FLAGS_MASTER\n\t}\n\tif flags > 0 {\n\t\tbr.AddRtAttr(nl.IFLA_BRIDGE_FLAGS, nl.Uint16Attr(flags))\n\t}\n\tvlanInfo := &nl.BridgeVlanInfo{Vid: vid}\n\tif pvid {\n\t\tvlanInfo.Flags |= nl.BRIDGE_VLAN_INFO_PVID\n\t}\n\tif untagged {\n\t\tvlanInfo.Flags |= nl.BRIDGE_VLAN_INFO_UNTAGGED\n\t}\n\n\tif vidEnd != 0 {\n\t\tvlanEndInfo := &nl.BridgeVlanInfo{Vid: vidEnd}\n\t\tvlanEndInfo.Flags = vlanInfo.Flags\n\n\t\tvlanInfo.Flags |= nl.BRIDGE_VLAN_INFO_RANGE_BEGIN\n\t\tbr.AddRtAttr(nl.IFLA_BRIDGE_VLAN_INFO, vlanInfo.Serialize())\n\n\t\tvlanEndInfo.Flags |= nl.BRIDGE_VLAN_INFO_RANGE_END\n\t\tbr.AddRtAttr(nl.IFLA_BRIDGE_VLAN_INFO, vlanEndInfo.Serialize())\n\t} else { \n\t\tbr.AddRtAttr(nl.IFLA_BRIDGE_VLAN_INFO, vlanInfo.Serialize())\n\t}\n\n\treq.AddData(br)\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n"
        },
        {
          "name": "bridge_linux_test.go",
          "type": "blob",
          "size": 3.046875,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"testing\"\n)\n\nfunc TestBridgeVlan(t *testing.T) {\n\tminKernelRequired(t, 3, 10)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := remountSysfs(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbridgeName := \"foo\"\n\tbridge := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeName}}\n\tif err := LinkAdd(bridge); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := ioutil.WriteFile(fmt.Sprintf(\"/sys/devices/virtual/net/%s/bridge/vlan_filtering\", bridgeName), []byte(\"1\"), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif vlanMap, err := BridgeVlanList(); err != nil {\n\t\tt.Fatal(err)\n\t} else {\n\t\tif len(vlanMap) != 1 {\n\t\t\tt.Fatal()\n\t\t}\n\t\tif vInfo, ok := vlanMap[int32(bridge.Index)]; !ok {\n\t\t\tt.Fatal(\"vlanMap should include foo port vlan info\")\n\t\t} else {\n\t\t\tif len(vInfo) != 1 {\n\t\t\t\tt.Fatal()\n\t\t\t} else {\n\t\t\t\tif !vInfo[0].EngressUntag() || !vInfo[0].PortVID() || vInfo[0].Vid != 1 {\n\t\t\t\t\tt.Fatalf(\"bridge vlan show get wrong return %s\", vInfo[0].String())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdummy := &Dummy{LinkAttrs: LinkAttrs{Name: \"dum1\"}}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetMaster(dummy, bridge); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := BridgeVlanAdd(dummy, 2, false, false, false, false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := BridgeVlanAdd(dummy, 3, true, true, false, false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := BridgeVlanAddRange(dummy, 4, 6, false, false, false, false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif vlanMap, err := BridgeVlanList(); err != nil {\n\t\tt.Fatal(err)\n\t} else {\n\t\tif len(vlanMap) != 2 {\n\t\t\tt.Fatal()\n\t\t}\n\t\tif vInfo, ok := vlanMap[int32(bridge.Index)]; !ok {\n\t\t\tt.Fatal(\"vlanMap should include foo port vlan info\")\n\t\t} else {\n\t\t\tif fmt.Sprintf(\"%v\", vInfo) != \"[{Flags:6 Vid:1}]\" {\n\t\t\t\tt.Fatalf(\"unexpected result %v\", vInfo)\n\t\t\t}\n\t\t}\n\t\tif vInfo, ok := vlanMap[int32(dummy.Index)]; !ok {\n\t\t\tt.Fatal(\"vlanMap should include dum1 port vlan info\")\n\t\t} else {\n\t\t\tif fmt.Sprintf(\"%v\", vInfo) != \"[{Flags:4 Vid:1} {Flags:0 Vid:2} {Flags:6 Vid:3} {Flags:0 Vid:4} {Flags:0 Vid:5} {Flags:0 Vid:6}]\" {\n\t\t\t\tt.Fatalf(\"unexpected result %v\", vInfo)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBridgeGroupFwdMask(t *testing.T) {\n\tminKernelRequired(t, 4, 15) //minimal release for per-port group_fwd_mask\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := remountSysfs(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbridgeName := \"foo\"\n\tvar mask uint16 = 0xfff0\n\tbridge := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeName}, GroupFwdMask: &mask}\n\tif err := LinkAdd(bridge); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbrlink, err := LinkByName(bridgeName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif *(brlink.(*Bridge).GroupFwdMask) != mask {\n\t\tt.Fatalf(\"created bridge has group_fwd_mask value %x, different from expected %x\",\n\t\t\t*(brlink.(*Bridge).GroupFwdMask), mask)\n\t}\n\tdummyName := \"dm1\"\n\tdummy := &Dummy{LinkAttrs: LinkAttrs{Name: dummyName, MasterIndex: brlink.Attrs().Index}}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdmLink, err := LinkByName(dummyName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = LinkSetBRSlaveGroupFwdMask(dmLink, mask); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "chain.go",
          "type": "blob",
          "size": 0.3330078125,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n)\n\n// Chain contains the attributes of a Chain\ntype Chain struct {\n\tParent uint32\n\tChain  uint32\n}\n\nfunc (c Chain) String() string {\n\treturn fmt.Sprintf(\"{Parent: %d, Chain: %d}\", c.Parent, c.Chain)\n}\n\nfunc NewChain(parent uint32, chain uint32) Chain {\n\treturn Chain{\n\t\tParent: parent,\n\t\tChain:  chain,\n\t}\n}\n"
        },
        {
          "name": "chain_linux.go",
          "type": "blob",
          "size": 2.876953125,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// ChainDel will delete a chain from the system.\nfunc ChainDel(link Link, chain Chain) error {\n\t// Equivalent to: `tc chain del $chain`\n\treturn pkgHandle.ChainDel(link, chain)\n}\n\n// ChainDel will delete a chain from the system.\n// Equivalent to: `tc chain del $chain`\nfunc (h *Handle) ChainDel(link Link, chain Chain) error {\n\treturn h.chainModify(unix.RTM_DELCHAIN, 0, link, chain)\n}\n\n// ChainAdd will add a chain to the system.\n// Equivalent to: `tc chain add`\nfunc ChainAdd(link Link, chain Chain) error {\n\treturn pkgHandle.ChainAdd(link, chain)\n}\n\n// ChainAdd will add a chain to the system.\n// Equivalent to: `tc chain add`\nfunc (h *Handle) ChainAdd(link Link, chain Chain) error {\n\treturn h.chainModify(\n\t\tunix.RTM_NEWCHAIN,\n\t\tunix.NLM_F_CREATE|unix.NLM_F_EXCL,\n\t\tlink,\n\t\tchain)\n}\n\nfunc (h *Handle) chainModify(cmd, flags int, link Link, chain Chain) error {\n\treq := h.newNetlinkRequest(cmd, flags|unix.NLM_F_ACK)\n\tindex := int32(0)\n\tif link != nil {\n\t\tbase := link.Attrs()\n\t\th.ensureIndex(base)\n\t\tindex = int32(base.Index)\n\t}\n\tmsg := &nl.TcMsg{\n\t\tFamily:  nl.FAMILY_ALL,\n\t\tIfindex: index,\n\t\tParent:  chain.Parent,\n\t}\n\treq.AddData(msg)\n\treq.AddData(nl.NewRtAttr(nl.TCA_CHAIN, nl.Uint32Attr(chain.Chain)))\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// ChainList gets a list of chains in the system.\n// Equivalent to: `tc chain list`.\n// The list can be filtered by link.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc ChainList(link Link, parent uint32) ([]Chain, error) {\n\treturn pkgHandle.ChainList(link, parent)\n}\n\n// ChainList gets a list of chains in the system.\n// Equivalent to: `tc chain list`.\n// The list can be filtered by link.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) ChainList(link Link, parent uint32) ([]Chain, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETCHAIN, unix.NLM_F_DUMP)\n\tindex := int32(0)\n\tif link != nil {\n\t\tbase := link.Attrs()\n\t\th.ensureIndex(base)\n\t\tindex = int32(base.Index)\n\t}\n\tmsg := &nl.TcMsg{\n\t\tFamily:  nl.FAMILY_ALL,\n\t\tIfindex: index,\n\t\tParent:  parent,\n\t}\n\treq.AddData(msg)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWCHAIN)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res []Chain\n\tfor _, m := range msgs {\n\t\tmsg := nl.DeserializeTcMsg(m)\n\n\t\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// skip chains from other interfaces\n\t\tif link != nil && msg.Ifindex != index {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar chain Chain\n\t\tfor _, attr := range attrs {\n\t\t\tswitch attr.Attr.Type {\n\t\t\tcase nl.TCA_CHAIN:\n\t\t\t\tchain.Chain = native.Uint32(attr.Value)\n\t\t\t\tchain.Parent = parent\n\t\t\t}\n\t\t}\n\t\tres = append(res, chain)\n\t}\n\n\treturn res, executeErr\n}\n"
        },
        {
          "name": "chain_test.go",
          "type": "blob",
          "size": 1.49609375,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"testing\"\n)\n\nfunc TestChainAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Ingress)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tchainVal := new(uint32)\n\t*chainVal = 20\n\tchain := NewChain(HANDLE_INGRESS, *chainVal)\n\terr = ChainAdd(link, chain)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tchains, err := ChainList(link, HANDLE_INGRESS)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(chains) != 1 {\n\t\tt.Fatal(\"Failed to add chain\")\n\t}\n\tif chains[0].Chain != *chainVal {\n\t\tt.Fatal(\"Incorrect chain added\")\n\t}\n\tif chains[0].Parent != HANDLE_INGRESS {\n\t\tt.Fatal(\"Incorrect chain parent\")\n\t}\n\tif err := ChainDel(link, chain); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tchains, err = ChainList(link, HANDLE_INGRESS)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(chains) != 0 {\n\t\tt.Fatal(\"Failed to remove chain\")\n\t}\n}\n"
        },
        {
          "name": "class.go",
          "type": "blob",
          "size": 6.865234375,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n)\n\n// Class interfaces for all classes\ntype Class interface {\n\tAttrs() *ClassAttrs\n\tType() string\n}\n\n// Generic networking statistics for netlink users.\n// This file contains \"gnet_\" prefixed structs and relevant functions.\n// See Documentation/networking/getn_stats.txt in Linux source code for more details.\n\n// GnetStatsBasic Ref: struct gnet_stats_basic { ... }\ntype GnetStatsBasic struct {\n\tBytes   uint64 // number of seen bytes\n\tPackets uint32 // number of seen packets\n}\n\n// GnetStatsRateEst Ref: struct gnet_stats_rate_est { ... }\ntype GnetStatsRateEst struct {\n\tBps uint32 // current byte rate\n\tPps uint32 // current packet rate\n}\n\n// GnetStatsRateEst64 Ref: struct gnet_stats_rate_est64 { ... }\ntype GnetStatsRateEst64 struct {\n\tBps uint64 // current byte rate\n\tPps uint64 // current packet rate\n}\n\n// GnetStatsQueue Ref: struct gnet_stats_queue { ... }\ntype GnetStatsQueue struct {\n\tQlen       uint32 // queue length\n\tBacklog    uint32 // backlog size of queue\n\tDrops      uint32 // number of dropped packets\n\tRequeues   uint32 // number of requues\n\tOverlimits uint32 // number of enqueues over the limit\n}\n\n// ClassStatistics representation based on generic networking statistics for netlink.\n// See Documentation/networking/gen_stats.txt in Linux source code for more details.\ntype ClassStatistics struct {\n\tBasic   *GnetStatsBasic\n\tQueue   *GnetStatsQueue\n\tRateEst *GnetStatsRateEst\n\tBasicHw *GnetStatsBasic // Hardward statistics added in kernel 4.20\n}\n\n// NewClassStatistics Construct a ClassStatistics struct which fields are all initialized by 0.\nfunc NewClassStatistics() *ClassStatistics {\n\treturn &ClassStatistics{\n\t\tBasic:   &GnetStatsBasic{},\n\t\tQueue:   &GnetStatsQueue{},\n\t\tRateEst: &GnetStatsRateEst{},\n\t\tBasicHw: &GnetStatsBasic{},\n\t}\n}\n\n// ClassAttrs represents a netlink class. A filter is associated with a link,\n// has a handle and a parent. The root filter of a device should have a\n// parent == HANDLE_ROOT.\ntype ClassAttrs struct {\n\tLinkIndex  int\n\tHandle     uint32\n\tParent     uint32\n\tLeaf       uint32\n\tStatistics *ClassStatistics\n}\n\nfunc (q ClassAttrs) String() string {\n\treturn fmt.Sprintf(\"{LinkIndex: %d, Handle: %s, Parent: %s, Leaf: %d}\", q.LinkIndex, HandleStr(q.Handle), HandleStr(q.Parent), q.Leaf)\n}\n\n// HtbClassAttrs stores the attributes of HTB class\ntype HtbClassAttrs struct {\n\t// TODO handle all attributes\n\tRate    uint64\n\tCeil    uint64\n\tBuffer  uint32\n\tCbuffer uint32\n\tQuantum uint32\n\tLevel   uint32\n\tPrio    uint32\n}\n\nfunc (q HtbClassAttrs) String() string {\n\treturn fmt.Sprintf(\"{Rate: %d, Ceil: %d, Buffer: %d, Cbuffer: %d}\", q.Rate, q.Ceil, q.Buffer, q.Cbuffer)\n}\n\n// HtbClass represents an Htb class\ntype HtbClass struct {\n\tClassAttrs\n\tRate    uint64\n\tCeil    uint64\n\tBuffer  uint32\n\tCbuffer uint32\n\tQuantum uint32\n\tLevel   uint32\n\tPrio    uint32\n}\n\nfunc (q HtbClass) String() string {\n\treturn fmt.Sprintf(\"{Rate: %d, Ceil: %d, Buffer: %d, Cbuffer: %d}\", q.Rate, q.Ceil, q.Buffer, q.Cbuffer)\n}\n\n// Attrs returns the class attributes\nfunc (q *HtbClass) Attrs() *ClassAttrs {\n\treturn &q.ClassAttrs\n}\n\n// Type return the class type\nfunc (q *HtbClass) Type() string {\n\treturn \"htb\"\n}\n\n// GenericClass classes represent types that are not currently understood\n// by this netlink library.\ntype GenericClass struct {\n\tClassAttrs\n\tClassType string\n}\n\n// Attrs return the class attributes\nfunc (class *GenericClass) Attrs() *ClassAttrs {\n\treturn &class.ClassAttrs\n}\n\n// Type return the class type\nfunc (class *GenericClass) Type() string {\n\treturn class.ClassType\n}\n\n// ServiceCurve is a nondecreasing function of some time unit, returning the amount of service\n// (an allowed or allocated amount of bandwidth) at some specific point in time. The purpose of it\n// should be subconsciously obvious: if a class was allowed to transfer not less than the amount\n// specified by its service curve, then the service curve is not violated.\ntype ServiceCurve struct {\n\tm1 uint32\n\td  uint32\n\tm2 uint32\n}\n\n// Attrs return the parameters of the service curve\nfunc (c *ServiceCurve) Attrs() (uint32, uint32, uint32) {\n\treturn c.m1, c.d, c.m2\n}\n\n// Burst returns the burst rate (m1) of the curve\nfunc (c *ServiceCurve) Burst() uint32 {\n\treturn c.m1\n}\n\n// Delay return the delay (d) of the curve\nfunc (c *ServiceCurve) Delay() uint32 {\n\treturn c.d\n}\n\n// Rate returns the rate (m2) of the curve\nfunc (c *ServiceCurve) Rate() uint32 {\n\treturn c.m2\n}\n\n// HfscClass is a representation of the HFSC class\ntype HfscClass struct {\n\tClassAttrs\n\tRsc ServiceCurve\n\tFsc ServiceCurve\n\tUsc ServiceCurve\n}\n\n// SetUsc sets the USC curve. The bandwidth (m1 and m2) is specified in bits and the delay in\n// seconds.\nfunc (hfsc *HfscClass) SetUsc(m1 uint32, d uint32, m2 uint32) {\n\thfsc.Usc = ServiceCurve{m1: m1, d: d, m2: m2}\n}\n\n// SetFsc sets the Fsc curve. The bandwidth (m1 and m2) is specified in bits and the delay in\n// seconds.\nfunc (hfsc *HfscClass) SetFsc(m1 uint32, d uint32, m2 uint32) {\n\thfsc.Fsc = ServiceCurve{m1: m1, d: d, m2: m2}\n}\n\n// SetRsc sets the Rsc curve. The bandwidth (m1 and m2) is specified in bits and the delay in\n// seconds.\nfunc (hfsc *HfscClass) SetRsc(m1 uint32, d uint32, m2 uint32) {\n\thfsc.Rsc = ServiceCurve{m1: m1, d: d, m2: m2}\n}\n\n// SetSC implements the SC from the `tc` CLI. This function behaves the same as if one would set the\n// USC through the `tc` command-line tool. This means bandwidth (m1 and m2) is specified in bits and\n// the delay in ms.\nfunc (hfsc *HfscClass) SetSC(m1 uint32, d uint32, m2 uint32) {\n\thfsc.SetRsc(m1, d, m2)\n\thfsc.SetFsc(m1, d, m2)\n}\n\n// SetUL implements the UL from the `tc` CLI. This function behaves the same as if one would set the\n// USC through the `tc` command-line tool. This means bandwidth (m1 and m2) is specified in bits and\n// the delay in ms.\nfunc (hfsc *HfscClass) SetUL(m1 uint32, d uint32, m2 uint32) {\n\thfsc.SetUsc(m1, d, m2)\n}\n\n// SetLS implements the LS from the `tc` CLI. This function behaves the same as if one would set the\n// USC through the `tc` command-line tool. This means bandwidth (m1 and m2) is specified in bits and\n// the delay in ms.\nfunc (hfsc *HfscClass) SetLS(m1 uint32, d uint32, m2 uint32) {\n\thfsc.SetFsc(m1, d, m2)\n}\n\n// NewHfscClass returns a new HFSC struct with the set parameters\nfunc NewHfscClass(attrs ClassAttrs) *HfscClass {\n\treturn &HfscClass{\n\t\tClassAttrs: attrs,\n\t\tRsc:        ServiceCurve{},\n\t\tFsc:        ServiceCurve{},\n\t\tUsc:        ServiceCurve{},\n\t}\n}\n\n// String() returns a string that contains the information and attributes of the HFSC class\nfunc (hfsc *HfscClass) String() string {\n\treturn fmt.Sprintf(\n\t\t\"{%s -- {RSC: {m1=%d d=%d m2=%d}} {FSC: {m1=%d d=%d m2=%d}} {USC: {m1=%d d=%d m2=%d}}}\",\n\t\thfsc.Attrs(), hfsc.Rsc.m1*8, hfsc.Rsc.d, hfsc.Rsc.m2*8, hfsc.Fsc.m1*8, hfsc.Fsc.d, hfsc.Fsc.m2*8, hfsc.Usc.m1*8, hfsc.Usc.d, hfsc.Usc.m2*8,\n\t)\n}\n\n// Attrs return the Hfsc parameters\nfunc (hfsc *HfscClass) Attrs() *ClassAttrs {\n\treturn &hfsc.ClassAttrs\n}\n\n// Type return the type of the class\nfunc (hfsc *HfscClass) Type() string {\n\treturn \"hfsc\"\n}\n"
        },
        {
          "name": "class_linux.go",
          "type": "blob",
          "size": 11.2822265625,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// Internal tc_stats representation in Go struct.\n// This is for internal uses only to deserialize the payload of rtattr.\n// After the deserialization, this should be converted into the canonical stats\n// struct, ClassStatistics, in case of statistics of a class.\n// Ref: struct tc_stats { ... }\ntype tcStats struct {\n\tBytes      uint64 // Number of enqueued bytes\n\tPackets    uint32 // Number of enqueued packets\n\tDrops      uint32 // Packets dropped because of lack of resources\n\tOverlimits uint32 // Number of throttle events when this flow goes out of allocated bandwidth\n\tBps        uint32 // Current flow byte rate\n\tPps        uint32 // Current flow packet rate\n\tQlen       uint32\n\tBacklog    uint32\n}\n\n// NewHtbClass NOTE: function is in here because it uses other linux functions\nfunc NewHtbClass(attrs ClassAttrs, cattrs HtbClassAttrs) *HtbClass {\n\tmtu := 1600\n\trate := cattrs.Rate / 8\n\tceil := cattrs.Ceil / 8\n\tbuffer := cattrs.Buffer\n\tcbuffer := cattrs.Cbuffer\n\n\tif ceil == 0 {\n\t\tceil = rate\n\t}\n\n\tif buffer == 0 {\n\t\tbuffer = uint32(float64(rate)/Hz() + float64(mtu))\n\t}\n\tbuffer = Xmittime(rate, buffer)\n\n\tif cbuffer == 0 {\n\t\tcbuffer = uint32(float64(ceil)/Hz() + float64(mtu))\n\t}\n\tcbuffer = Xmittime(ceil, cbuffer)\n\n\treturn &HtbClass{\n\t\tClassAttrs: attrs,\n\t\tRate:       rate,\n\t\tCeil:       ceil,\n\t\tBuffer:     buffer,\n\t\tCbuffer:    cbuffer,\n\t\tLevel:      0,\n\t\tPrio:       cattrs.Prio,\n\t\tQuantum:    cattrs.Quantum,\n\t}\n}\n\n// ClassDel will delete a class from the system.\n// Equivalent to: `tc class del $class`\nfunc ClassDel(class Class) error {\n\treturn pkgHandle.ClassDel(class)\n}\n\n// ClassDel will delete a class from the system.\n// Equivalent to: `tc class del $class`\nfunc (h *Handle) ClassDel(class Class) error {\n\treturn h.classModify(unix.RTM_DELTCLASS, 0, class)\n}\n\n// ClassChange will change a class in place\n// Equivalent to: `tc class change $class`\n// The parent and handle MUST NOT be changed.\nfunc ClassChange(class Class) error {\n\treturn pkgHandle.ClassChange(class)\n}\n\n// ClassChange will change a class in place\n// Equivalent to: `tc class change $class`\n// The parent and handle MUST NOT be changed.\nfunc (h *Handle) ClassChange(class Class) error {\n\treturn h.classModify(unix.RTM_NEWTCLASS, 0, class)\n}\n\n// ClassReplace will replace a class to the system.\n// quivalent to: `tc class replace $class`\n// The handle MAY be changed.\n// If a class already exist with this parent/handle pair, the class is changed.\n// If a class does not already exist with this parent/handle, a new class is created.\nfunc ClassReplace(class Class) error {\n\treturn pkgHandle.ClassReplace(class)\n}\n\n// ClassReplace will replace a class to the system.\n// quivalent to: `tc class replace $class`\n// The handle MAY be changed.\n// If a class already exist with this parent/handle pair, the class is changed.\n// If a class does not already exist with this parent/handle, a new class is created.\nfunc (h *Handle) ClassReplace(class Class) error {\n\treturn h.classModify(unix.RTM_NEWTCLASS, unix.NLM_F_CREATE, class)\n}\n\n// ClassAdd will add a class to the system.\n// Equivalent to: `tc class add $class`\nfunc ClassAdd(class Class) error {\n\treturn pkgHandle.ClassAdd(class)\n}\n\n// ClassAdd will add a class to the system.\n// Equivalent to: `tc class add $class`\nfunc (h *Handle) ClassAdd(class Class) error {\n\treturn h.classModify(\n\t\tunix.RTM_NEWTCLASS,\n\t\tunix.NLM_F_CREATE|unix.NLM_F_EXCL,\n\t\tclass,\n\t)\n}\n\nfunc (h *Handle) classModify(cmd, flags int, class Class) error {\n\treq := h.newNetlinkRequest(cmd, flags|unix.NLM_F_ACK)\n\tbase := class.Attrs()\n\tmsg := &nl.TcMsg{\n\t\tFamily:  nl.FAMILY_ALL,\n\t\tIfindex: int32(base.LinkIndex),\n\t\tHandle:  base.Handle,\n\t\tParent:  base.Parent,\n\t}\n\treq.AddData(msg)\n\n\tif cmd != unix.RTM_DELTCLASS {\n\t\tif err := classPayload(req, class); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc classPayload(req *nl.NetlinkRequest, class Class) error {\n\treq.AddData(nl.NewRtAttr(nl.TCA_KIND, nl.ZeroTerminated(class.Type())))\n\n\toptions := nl.NewRtAttr(nl.TCA_OPTIONS, nil)\n\tswitch class.Type() {\n\tcase \"htb\":\n\t\thtb := class.(*HtbClass)\n\t\topt := nl.TcHtbCopt{}\n\t\topt.Buffer = htb.Buffer\n\t\topt.Cbuffer = htb.Cbuffer\n\t\topt.Quantum = htb.Quantum\n\t\topt.Level = htb.Level\n\t\topt.Prio = htb.Prio\n\t\t// TODO: Handle Debug properly. For now default to 0\n\t\t/* Calculate {R,C}Tab and set Rate and Ceil */\n\t\tcellLog := -1\n\t\tccellLog := -1\n\t\tlinklayer := nl.LINKLAYER_ETHERNET\n\t\tmtu := 1600\n\t\tvar rtab [256]uint32\n\t\tvar ctab [256]uint32\n\t\ttcrate := nl.TcRateSpec{Rate: uint32(htb.Rate)}\n\t\tif CalcRtable(&tcrate, rtab[:], cellLog, uint32(mtu), linklayer) < 0 {\n\t\t\treturn errors.New(\"HTB: failed to calculate rate table\")\n\t\t}\n\t\topt.Rate = tcrate\n\t\ttcceil := nl.TcRateSpec{Rate: uint32(htb.Ceil)}\n\t\tif CalcRtable(&tcceil, ctab[:], ccellLog, uint32(mtu), linklayer) < 0 {\n\t\t\treturn errors.New(\"HTB: failed to calculate ceil rate table\")\n\t\t}\n\t\topt.Ceil = tcceil\n\t\toptions.AddRtAttr(nl.TCA_HTB_PARMS, opt.Serialize())\n\t\toptions.AddRtAttr(nl.TCA_HTB_RTAB, SerializeRtab(rtab))\n\t\toptions.AddRtAttr(nl.TCA_HTB_CTAB, SerializeRtab(ctab))\n\t\tif htb.Rate >= uint64(1<<32) {\n\t\t\toptions.AddRtAttr(nl.TCA_HTB_RATE64, nl.Uint64Attr(htb.Rate))\n\t\t}\n\t\tif htb.Ceil >= uint64(1<<32) {\n\t\t\toptions.AddRtAttr(nl.TCA_HTB_CEIL64, nl.Uint64Attr(htb.Ceil))\n\t\t}\n\tcase \"hfsc\":\n\t\thfsc := class.(*HfscClass)\n\t\topt := nl.HfscCopt{}\n\t\trm1, rd, rm2 := hfsc.Rsc.Attrs()\n\t\topt.Rsc.Set(rm1/8, rd, rm2/8)\n\t\tfm1, fd, fm2 := hfsc.Fsc.Attrs()\n\t\topt.Fsc.Set(fm1/8, fd, fm2/8)\n\t\tum1, ud, um2 := hfsc.Usc.Attrs()\n\t\topt.Usc.Set(um1/8, ud, um2/8)\n\t\toptions.AddRtAttr(nl.TCA_HFSC_RSC, nl.SerializeHfscCurve(&opt.Rsc))\n\t\toptions.AddRtAttr(nl.TCA_HFSC_FSC, nl.SerializeHfscCurve(&opt.Fsc))\n\t\toptions.AddRtAttr(nl.TCA_HFSC_USC, nl.SerializeHfscCurve(&opt.Usc))\n\t}\n\treq.AddData(options)\n\treturn nil\n}\n\n// ClassList gets a list of classes in the system.\n// Equivalent to: `tc class show`.\n//\n// Generally returns nothing if link and parent are not specified.\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc ClassList(link Link, parent uint32) ([]Class, error) {\n\treturn pkgHandle.ClassList(link, parent)\n}\n\n// ClassList gets a list of classes in the system.\n// Equivalent to: `tc class show`.\n//\n// Generally returns nothing if link and parent are not specified.\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) ClassList(link Link, parent uint32) ([]Class, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETTCLASS, unix.NLM_F_DUMP)\n\tmsg := &nl.TcMsg{\n\t\tFamily: nl.FAMILY_ALL,\n\t\tParent: parent,\n\t}\n\tif link != nil {\n\t\tbase := link.Attrs()\n\t\th.ensureIndex(base)\n\t\tmsg.Ifindex = int32(base.Index)\n\t}\n\treq.AddData(msg)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWTCLASS)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res []Class\n\tfor _, m := range msgs {\n\t\tmsg := nl.DeserializeTcMsg(m)\n\n\t\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tbase := ClassAttrs{\n\t\t\tLinkIndex:  int(msg.Ifindex),\n\t\t\tHandle:     msg.Handle,\n\t\t\tParent:     msg.Parent,\n\t\t\tStatistics: nil,\n\t\t}\n\n\t\tvar class Class\n\t\tclassType := \"\"\n\t\tfor _, attr := range attrs {\n\t\t\tswitch attr.Attr.Type {\n\t\t\tcase nl.TCA_KIND:\n\t\t\t\tclassType = string(attr.Value[:len(attr.Value)-1])\n\t\t\t\tswitch classType {\n\t\t\t\tcase \"htb\":\n\t\t\t\t\tclass = &HtbClass{}\n\t\t\t\tcase \"hfsc\":\n\t\t\t\t\tclass = &HfscClass{}\n\t\t\t\tdefault:\n\t\t\t\t\tclass = &GenericClass{ClassType: classType}\n\t\t\t\t}\n\t\t\tcase nl.TCA_OPTIONS:\n\t\t\t\tswitch classType {\n\t\t\t\tcase \"htb\":\n\t\t\t\t\tdata, err := nl.ParseRouteAttr(attr.Value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\t_, err = parseHtbClassData(class, data)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"hfsc\":\n\t\t\t\t\tdata, err := nl.ParseRouteAttr(attr.Value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\t_, err = parseHfscClassData(class, data)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// For backward compatibility.\n\t\t\tcase nl.TCA_STATS:\n\t\t\t\tbase.Statistics, err = parseTcStats(attr.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase nl.TCA_STATS2:\n\t\t\t\tbase.Statistics, err = parseTcStats2(attr.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*class.Attrs() = base\n\t\tres = append(res, class)\n\t}\n\n\treturn res, executeErr\n}\n\nfunc parseHtbClassData(class Class, data []syscall.NetlinkRouteAttr) (bool, error) {\n\thtb := class.(*HtbClass)\n\tdetailed := false\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_HTB_PARMS:\n\t\t\topt := nl.DeserializeTcHtbCopt(datum.Value)\n\t\t\thtb.Rate = uint64(opt.Rate.Rate)\n\t\t\thtb.Ceil = uint64(opt.Ceil.Rate)\n\t\t\thtb.Buffer = opt.Buffer\n\t\t\thtb.Cbuffer = opt.Cbuffer\n\t\t\thtb.Quantum = opt.Quantum\n\t\t\thtb.Level = opt.Level\n\t\t\thtb.Prio = opt.Prio\n\t\tcase nl.TCA_HTB_RATE64:\n\t\t\thtb.Rate = native.Uint64(datum.Value[0:8])\n\t\tcase nl.TCA_HTB_CEIL64:\n\t\t\thtb.Ceil = native.Uint64(datum.Value[0:8])\n\t\t}\n\t}\n\treturn detailed, nil\n}\n\nfunc parseHfscClassData(class Class, data []syscall.NetlinkRouteAttr) (bool, error) {\n\thfsc := class.(*HfscClass)\n\tdetailed := false\n\tfor _, datum := range data {\n\t\tm1, d, m2 := nl.DeserializeHfscCurve(datum.Value).Attrs()\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_HFSC_RSC:\n\t\t\thfsc.Rsc = ServiceCurve{m1: m1 * 8, d: d, m2: m2 * 8}\n\t\tcase nl.TCA_HFSC_FSC:\n\t\t\thfsc.Fsc = ServiceCurve{m1: m1 * 8, d: d, m2: m2 * 8}\n\t\tcase nl.TCA_HFSC_USC:\n\t\t\thfsc.Usc = ServiceCurve{m1: m1 * 8, d: d, m2: m2 * 8}\n\t\t}\n\t}\n\treturn detailed, nil\n}\n\nfunc parseTcStats(data []byte) (*ClassStatistics, error) {\n\tbuf := &bytes.Buffer{}\n\tbuf.Write(data)\n\ttcStats := &tcStats{}\n\tif err := binary.Read(buf, native, tcStats); err != nil {\n\t\treturn nil, err\n\t}\n\n\tstats := NewClassStatistics()\n\tstats.Basic.Bytes = tcStats.Bytes\n\tstats.Basic.Packets = tcStats.Packets\n\tstats.Queue.Qlen = tcStats.Qlen\n\tstats.Queue.Backlog = tcStats.Backlog\n\tstats.Queue.Drops = tcStats.Drops\n\tstats.Queue.Overlimits = tcStats.Overlimits\n\tstats.RateEst.Bps = tcStats.Bps\n\tstats.RateEst.Pps = tcStats.Pps\n\n\treturn stats, nil\n}\n\nfunc parseGnetStats(data []byte, gnetStats interface{}) error {\n\tbuf := &bytes.Buffer{}\n\tbuf.Write(data)\n\treturn binary.Read(buf, native, gnetStats)\n}\n\nfunc parseTcStats2(data []byte) (*ClassStatistics, error) {\n\trtAttrs, err := nl.ParseRouteAttr(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstats := NewClassStatistics()\n\tfor _, datum := range rtAttrs {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_STATS_BASIC:\n\t\t\tif err := parseGnetStats(datum.Value, stats.Basic); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Failed to parse ClassStatistics.Basic with: %v\\n%s\",\n\t\t\t\t\terr, hex.Dump(datum.Value))\n\t\t\t}\n\t\tcase nl.TCA_STATS_QUEUE:\n\t\t\tif err := parseGnetStats(datum.Value, stats.Queue); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Failed to parse ClassStatistics.Queue with: %v\\n%s\",\n\t\t\t\t\terr, hex.Dump(datum.Value))\n\t\t\t}\n\t\tcase nl.TCA_STATS_RATE_EST:\n\t\t\tif err := parseGnetStats(datum.Value, stats.RateEst); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Failed to parse ClassStatistics.RateEst with: %v\\n%s\",\n\t\t\t\t\terr, hex.Dump(datum.Value))\n\t\t\t}\n\t\tcase nl.TCA_STATS_BASIC_HW:\n\t\t\tif err := parseGnetStats(datum.Value, stats.BasicHw); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Failed to parse ClassStatistics.BasicHw with: %v\\n%s\",\n\t\t\t\t\terr, hex.Dump(datum.Value))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stats, nil\n}\n"
        },
        {
          "name": "class_test.go",
          "type": "blob",
          "size": 15.017578125,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc SafeQdiscList(link Link) ([]Qdisc, error) {\n\tqdiscs, err := QdiscList(link)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := []Qdisc{}\n\tfor _, qdisc := range qdiscs {\n\t\t// fmt.Printf(\"%+v\\n\", qdisc)\n\t\t// filter default qdisc created by kernel when custom one deleted\n\t\tattrs := qdisc.Attrs()\n\t\tif attrs.Handle == HANDLE_NONE && attrs.Parent == HANDLE_ROOT {\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, qdisc)\n\t}\n\treturn result, nil\n}\n\nfunc SafeClassList(link Link, handle uint32) ([]Class, error) {\n\tclasses, err := ClassList(link, handle)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := []Class{}\n\tfor ind := range classes {\n\t\tdouble := false\n\t\tfor _, class2 := range classes[ind+1:] {\n\t\t\tif classes[ind].Attrs().Handle == class2.Attrs().Handle {\n\t\t\t\tdouble = true\n\t\t\t}\n\t\t}\n\t\tif !double {\n\t\t\tresult = append(result, classes[ind])\n\t\t}\n\t}\n\treturn result, nil\n}\n\nfunc testClassStats(this, that *ClassStatistics, t *testing.T) {\n\tok := reflect.DeepEqual(this, that)\n\tif !ok {\n\t\tt.Fatalf(\"%#v is expected but it actually was %#v\", that, this)\n\t}\n}\n\nfunc TestClassAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(0xffff, 0),\n\t\tParent:    HANDLE_ROOT,\n\t}\n\tqdisc := NewHtb(attrs)\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Htb)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tclassattrs := ClassAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tParent:    MakeHandle(0xffff, 0),\n\t\tHandle:    MakeHandle(0xffff, 2),\n\t}\n\n\thtbclassattrs := HtbClassAttrs{\n\t\tRate:    1234000,\n\t\tCbuffer: 1690,\n\t\tPrio:    2,\n\t\tQuantum: 1000,\n\t}\n\tclass := NewHtbClass(classattrs, htbclassattrs)\n\tif err := ClassAdd(class); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclasses, err := SafeClassList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 1 {\n\t\tt.Fatal(\"Failed to add class\")\n\t}\n\n\thtb, ok := classes[0].(*HtbClass)\n\tif !ok {\n\t\tt.Fatal(\"Class is the wrong type\")\n\t}\n\tif htb.Rate != class.Rate {\n\t\tt.Fatal(\"Rate doesn't match\")\n\t}\n\tif htb.Ceil != class.Ceil {\n\t\tt.Fatal(\"Ceil doesn't match\")\n\t}\n\tif htb.Buffer != class.Buffer {\n\t\tt.Fatal(\"Buffer doesn't match\")\n\t}\n\tif htb.Cbuffer != class.Cbuffer {\n\t\tt.Fatal(\"Cbuffer doesn't match\")\n\t}\n\tif htb.Prio != class.Prio {\n\t\tt.Fatal(\"Prio doesn't match\")\n\t}\n\tif htb.Quantum != class.Quantum {\n\t\tt.Fatal(\"Quantum doesn't match\")\n\t}\n\n\ttestClassStats(htb.ClassAttrs.Statistics, NewClassStatistics(), t)\n\n\tqattrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(0x2, 0),\n\t\tParent:    MakeHandle(0xffff, 2),\n\t}\n\tnattrs := NetemQdiscAttrs{\n\t\tLatency:     20000,\n\t\tLoss:        23.4,\n\t\tDuplicate:   14.3,\n\t\tLossCorr:    8.34,\n\t\tJitter:      1000,\n\t\tDelayCorr:   12.3,\n\t\tReorderProb: 23.4,\n\t\tCorruptProb: 10.0,\n\t\tCorruptCorr: 10,\n\t\tRate64:      10 * 1024 * 1024,\n\t}\n\tqdiscnetem := NewNetem(qattrs, nattrs)\n\tif err := QdiscAdd(qdiscnetem); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 2 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok = qdiscs[0].(*Htb)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tnetem, ok := qdiscs[1].(*Netem)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\t// Compare the record we got from the list with the one we created\n\tif netem.Loss != qdiscnetem.Loss {\n\t\tt.Fatal(\"Loss does not match\")\n\t}\n\tif netem.Latency != qdiscnetem.Latency {\n\t\tt.Fatal(\"Latency does not match\")\n\t}\n\tif netem.CorruptProb != qdiscnetem.CorruptProb {\n\t\tt.Fatal(\"CorruptProb does not match\")\n\t}\n\tif netem.Jitter != qdiscnetem.Jitter {\n\t\tt.Fatal(\"Jitter does not match\")\n\t}\n\tif netem.LossCorr != qdiscnetem.LossCorr {\n\t\tt.Fatal(\"Loss does not match\")\n\t}\n\tif netem.DuplicateCorr != qdiscnetem.DuplicateCorr {\n\t\tt.Fatal(\"DuplicateCorr does not match\")\n\t}\n\tif netem.Rate64 != qdiscnetem.Rate64 {\n\t\tt.Fatalf(\"Rate64 does not match. Expected %d, got %d\", netem.Rate64, qdiscnetem.Rate64)\n\t}\n\n\t// Deletion\n\t// automatically removes netem qdisc\n\tif err := ClassDel(class); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclasses, err = SafeClassList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 0 {\n\t\tt.Fatal(\"Failed to remove class\")\n\t}\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestHtbClassAddHtbClassChangeDel(t *testing.T) {\n\t/**\n\tThis test first set up a interface ans set up a Htb qdisc\n\tA HTB class is attach to it and a Netem qdisc is attached to that class\n\tNext, we test changing the HTB class in place and confirming the Netem is\n\tstill attached. We also check that invoting ClassChange with a non-existing\n\tclass will fail.\n\tFinally, we test ClassReplace. We confirm it correctly behave like\n\tClassChange when the parent/handle pair exists and that it will create a\n\tnew class if the handle is modified.\n\t*/\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(0xffff, 0),\n\t\tParent:    HANDLE_ROOT,\n\t}\n\tqdisc := NewHtb(attrs)\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Htb)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tclassattrs := ClassAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tParent:    MakeHandle(0xffff, 0),\n\t\tHandle:    MakeHandle(0xffff, 2),\n\t}\n\n\thtbclassattrs := HtbClassAttrs{\n\t\tRate:    uint64(1<<32) + 10,\n\t\tCeil:    uint64(1<<32) + 20,\n\t\tCbuffer: 1690,\n\t}\n\tclass := NewHtbClass(classattrs, htbclassattrs)\n\tif err := ClassAdd(class); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclasses, err := SafeClassList(link, 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 1 {\n\t\tt.Fatal(\"Failed to add class\")\n\t}\n\n\thtb, ok := classes[0].(*HtbClass)\n\tif !ok {\n\t\tt.Fatal(\"Class is the wrong type\")\n\t}\n\n\ttestClassStats(htb.ClassAttrs.Statistics, NewClassStatistics(), t)\n\n\tqattrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(0x2, 0),\n\t\tParent:    MakeHandle(0xffff, 2),\n\t}\n\tnattrs := NetemQdiscAttrs{\n\t\tLatency:     20000,\n\t\tLoss:        23.4,\n\t\tDuplicate:   14.3,\n\t\tLossCorr:    8.34,\n\t\tJitter:      1000,\n\t\tDelayCorr:   12.3,\n\t\tReorderProb: 23.4,\n\t\tCorruptProb: 10.0,\n\t\tCorruptCorr: 10,\n\t}\n\tqdiscnetem := NewNetem(qattrs, nattrs)\n\tif err := QdiscAdd(qdiscnetem); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 2 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\n\t_, ok = qdiscs[1].(*Netem)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\t// Change\n\t// For change to work, the handle and parent cannot be changed.\n\n\t// First, test it fails if we change the Handle.\n\toldHandle := classattrs.Handle\n\tclassattrs.Handle = MakeHandle(0xffff, 3)\n\tclass = NewHtbClass(classattrs, htbclassattrs)\n\tif err := ClassChange(class); err == nil {\n\t\tt.Fatal(\"ClassChange should not work when using a different handle.\")\n\t}\n\t// It should work with the same handle\n\tclassattrs.Handle = oldHandle\n\thtbclassattrs.Rate = 4321000\n\tclass = NewHtbClass(classattrs, htbclassattrs)\n\tif err := ClassChange(class); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tclasses, err = SafeClassList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 1 {\n\t\tt.Fatalf(\n\t\t\t\"1 class expected, %d found\",\n\t\t\tlen(classes),\n\t\t)\n\t}\n\n\thtb, ok = classes[0].(*HtbClass)\n\tif !ok {\n\t\tt.Fatal(\"Class is the wrong type\")\n\t}\n\t// Verify that the rate value has changed.\n\tif htb.Rate != class.Rate {\n\t\tt.Fatal(\"Rate did not get changed while changing the class.\")\n\t}\n\n\t// Check that we still have the netem child qdisc\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(qdiscs) != 2 {\n\t\tt.Fatalf(\"2 qdisc expected, %d found\", len(qdiscs))\n\t}\n\t_, ok = qdiscs[0].(*Htb)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\t_, ok = qdiscs[1].(*Netem)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\t// Replace\n\t// First replace by keeping the same handle, class will be changed.\n\t// Then, replace by providing a new handle, n new class will be created.\n\n\t// Replace acting as Change\n\tclass = NewHtbClass(classattrs, htbclassattrs)\n\tif err := ClassReplace(class); err != nil {\n\t\tt.Fatal(\"Failed to replace class that is existing.\")\n\t}\n\n\tclasses, err = SafeClassList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 1 {\n\t\tt.Fatalf(\n\t\t\t\"1 class expected, %d found\",\n\t\t\tlen(classes),\n\t\t)\n\t}\n\n\thtb, ok = classes[0].(*HtbClass)\n\tif !ok {\n\t\tt.Fatal(\"Class is the wrong type\")\n\t}\n\t// Verify that the rate value has changed.\n\tif htb.Rate != class.Rate {\n\t\tt.Fatal(\"Rate did not get changed while changing the class.\")\n\t}\n\n\t// It should work with the same handle\n\tclassattrs.Handle = MakeHandle(0xffff, 3)\n\tclass = NewHtbClass(classattrs, htbclassattrs)\n\tif err := ClassReplace(class); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tclasses, err = SafeClassList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 2 {\n\t\tt.Fatalf(\n\t\t\t\"2 classes expected, %d found\",\n\t\t\tlen(classes),\n\t\t)\n\t}\n\n\thtb, ok = classes[1].(*HtbClass)\n\tif !ok {\n\t\tt.Fatal(\"Class is the wrong type\")\n\t}\n\t// Verify that the rate value has changed.\n\tif htb.Rate != class.Rate {\n\t\tt.Fatal(\"Rate did not get changed while changing the class.\")\n\t}\n\n\t// Deletion\n\tfor _, class := range classes {\n\t\tif err := ClassDel(class); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tclasses, err = SafeClassList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 0 {\n\t\tt.Fatal(\"Failed to remove class\")\n\t}\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestClassHfsc(t *testing.T) {\n\t// New network namespace for tests\n\ttearDown := setUpNetlinkTestWithKModule(t, \"sch_hfsc\")\n\tdefer tearDown()\n\n\t// Set up testing link and check if succeeded\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Adding HFSC qdisc\n\tqdiscAttrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(1, 0),\n\t\tParent:    HANDLE_ROOT,\n\t}\n\thfscQdisc := NewHfsc(qdiscAttrs)\n\thfscQdisc.Defcls = 2\n\n\terr = QdiscAdd(hfscQdisc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Hfsc)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\t// Adding some HFSC classes\n\tclassAttrs := ClassAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tParent:    MakeHandle(1, 0),\n\t\tHandle:    MakeHandle(1, 1),\n\t}\n\thfscClass := NewHfscClass(classAttrs)\n\thfscClass.SetLS(5e6, 10, 5e6)\n\n\terr = ClassAdd(hfscClass)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thfscClass2 := hfscClass\n\thfscClass2.SetLS(0, 0, 0)\n\thfscClass2.Attrs().Parent = MakeHandle(1, 1)\n\thfscClass2.Attrs().Handle = MakeHandle(1, 2)\n\thfscClass2.SetRsc(0, 0, 2e6)\n\n\terr = ClassAdd(hfscClass2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thfscClass3 := hfscClass\n\thfscClass3.SetLS(0, 0, 0)\n\thfscClass3.Attrs().Parent = MakeHandle(1, 1)\n\thfscClass3.Attrs().Handle = MakeHandle(1, 3)\n\n\terr = ClassAdd(hfscClass3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check the classes\n\tclasses, err := SafeClassList(link, MakeHandle(1, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 4 {\n\t\tt.Fatal(\"Failed to add classes\")\n\t}\n\tfor _, c := range classes {\n\t\tclass, ok := c.(*HfscClass)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Wrong type of class\")\n\t\t}\n\t\tif class.ClassAttrs.Handle == hfscClass.ClassAttrs.Handle {\n\t\t\tif class.Fsc != hfscClass.Fsc {\n\t\t\t\tt.Fatal(\"HfscClass FSC don't match\")\n\t\t\t}\n\t\t\tif class.Usc != hfscClass.Usc {\n\t\t\t\tt.Fatal(\"HfscClass USC don't match\")\n\t\t\t}\n\t\t\tif class.Rsc != hfscClass.Rsc {\n\t\t\t\tt.Fatal(\"HfscClass RSC don't match\")\n\t\t\t}\n\t\t}\n\t\tif class.ClassAttrs.Handle == hfscClass2.ClassAttrs.Handle {\n\t\t\tif class.Fsc != hfscClass2.Fsc {\n\t\t\t\tt.Fatal(\"HfscClass2 FSC don't match\")\n\t\t\t}\n\t\t\tif class.Usc != hfscClass2.Usc {\n\t\t\t\tt.Fatal(\"HfscClass2 USC don't match\")\n\t\t\t}\n\t\t\tif class.Rsc != hfscClass2.Rsc {\n\t\t\t\tt.Fatal(\"HfscClass2 RSC don't match\")\n\t\t\t}\n\t\t}\n\t\tif class.ClassAttrs.Handle == hfscClass3.ClassAttrs.Handle {\n\t\t\tif class.Fsc != hfscClass3.Fsc {\n\t\t\t\tt.Fatal(\"HfscClass3 FSC don't match\")\n\t\t\t}\n\t\t\tif class.Usc != hfscClass3.Usc {\n\t\t\t\tt.Fatal(\"HfscClass3 USC don't match\")\n\t\t\t}\n\t\t\tif class.Rsc != hfscClass3.Rsc {\n\t\t\t\tt.Fatal(\"HfscClass3 RSC don't match\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Terminating the leafs with fq_codel qdiscs\n\tfqcodelAttrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tParent:    MakeHandle(1, 2),\n\t\tHandle:    MakeHandle(2, 0),\n\t}\n\tfqcodel1 := NewFqCodel(fqcodelAttrs)\n\tfqcodel1.ECN = 0\n\tfqcodel1.Limit = 1200\n\tfqcodel1.Flows = 65535\n\tfqcodel1.Target = 5\n\n\terr = QdiscAdd(fqcodel1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfqcodel2 := fqcodel1\n\tfqcodel2.Attrs().Handle = MakeHandle(3, 0)\n\tfqcodel2.Attrs().Parent = MakeHandle(1, 3)\n\n\terr = QdiscAdd(fqcodel2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check the amount of qdiscs\n\tqdiscs, _ = SafeQdiscList(link)\n\tif len(qdiscs) != 3 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\tfor _, q := range qdiscs[1:] {\n\t\t_, ok = q.(*FqCodel)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t\t}\n\t}\n\n\t// removing a class\n\tif err := ClassDel(hfscClass3); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Check the classes\n\tclasses, err = SafeClassList(link, MakeHandle(1, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 3 {\n\t\tt.Fatal(\"Failed to delete classes\")\n\t}\n\t// Check qdisc\n\tqdiscs, _ = SafeQdiscList(link)\n\tif len(qdiscs) != 2 {\n\t\tt.Fatal(\"Failed to delete qdisc\")\n\t}\n\n\t// Changing a class\n\thfscClass2.SetRsc(0, 0, 0)\n\thfscClass2.SetSC(5e6, 100, 1e6)\n\thfscClass2.SetUL(6e6, 50, 2e6)\n\thfscClass2.Attrs().Handle = MakeHandle(1, 8)\n\tif err := ClassChange(hfscClass2); err == nil {\n\t\tt.Fatal(\"Class change shouldn't work with a different handle\")\n\t}\n\thfscClass2.Attrs().Handle = MakeHandle(1, 2)\n\tif err := ClassChange(hfscClass2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Replacing a class\n\t// If the handle doesn't exist, create it\n\thfscClass2.SetSC(6e6, 100, 2e6)\n\thfscClass2.SetUL(8e6, 500, 4e6)\n\thfscClass2.Attrs().Handle = MakeHandle(1, 8)\n\tif err := ClassReplace(hfscClass2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// If the handle exists, replace it\n\thfscClass.SetLS(5e6, 200, 1e6)\n\tif err := ClassChange(hfscClass); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "conntrack_linux.go",
          "type": "blob",
          "size": 31.0390625,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// ConntrackTableType Conntrack table for the netlink operation\ntype ConntrackTableType uint8\n\nconst (\n\t// ConntrackTable Conntrack table\n\t// https://github.com/torvalds/linux/blob/master/include/uapi/linux/netfilter/nfnetlink.h -> #define NFNL_SUBSYS_CTNETLINK\t\t 1\n\tConntrackTable = 1\n\t// ConntrackExpectTable Conntrack expect table\n\t// https://github.com/torvalds/linux/blob/master/include/uapi/linux/netfilter/nfnetlink.h -> #define NFNL_SUBSYS_CTNETLINK_EXP 2\n\tConntrackExpectTable = 2\n)\n\nconst (\n\t// backward compatibility with golang 1.6 which does not have io.SeekCurrent\n\tseekCurrent = 1\n)\n\n// InetFamily Family type\ntype InetFamily uint8\n\n//  -L [table] [options]          List conntrack or expectation table\n//  -G [table] parameters         Get conntrack or expectation\n\n//  -I [table] parameters         Create a conntrack or expectation\n//  -U [table] parameters         Update a conntrack\n//  -E [table] [options]          Show events\n\n//  -C [table]                    Show counter\n//  -S                            Show statistics\n\n// ConntrackTableList returns the flow list of a table of a specific family\n// conntrack -L [table] [options]          List conntrack or expectation table\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc ConntrackTableList(table ConntrackTableType, family InetFamily) ([]*ConntrackFlow, error) {\n\treturn pkgHandle.ConntrackTableList(table, family)\n}\n\n// ConntrackTableFlush flushes all the flows of a specified table\n// conntrack -F [table]            Flush table\n// The flush operation applies to all the family types\nfunc ConntrackTableFlush(table ConntrackTableType) error {\n\treturn pkgHandle.ConntrackTableFlush(table)\n}\n\n// ConntrackCreate creates a new conntrack flow in the desired table\n// conntrack -I [table]\t\tCreate a conntrack or expectation\nfunc ConntrackCreate(table ConntrackTableType, family InetFamily, flow *ConntrackFlow) error {\n\treturn pkgHandle.ConntrackCreate(table, family, flow)\n}\n\n// ConntrackUpdate updates an existing conntrack flow in the desired table using the handle\n// conntrack -U [table]\t\tUpdate a conntrack\nfunc ConntrackUpdate(table ConntrackTableType, family InetFamily, flow *ConntrackFlow) error {\n\treturn pkgHandle.ConntrackUpdate(table, family, flow)\n}\n\n// ConntrackDeleteFilter deletes entries on the specified table on the base of the filter\n// conntrack -D [table] parameters         Delete conntrack or expectation\n//\n// Deprecated: use [ConntrackDeleteFilters] instead.\nfunc ConntrackDeleteFilter(table ConntrackTableType, family InetFamily, filter CustomConntrackFilter) (uint, error) {\n\treturn pkgHandle.ConntrackDeleteFilters(table, family, filter)\n}\n\n// ConntrackDeleteFilters deletes entries on the specified table matching any of the specified filters\n// conntrack -D [table] parameters         Delete conntrack or expectation\nfunc ConntrackDeleteFilters(table ConntrackTableType, family InetFamily, filters ...CustomConntrackFilter) (uint, error) {\n\treturn pkgHandle.ConntrackDeleteFilters(table, family, filters...)\n}\n\n// ConntrackTableList returns the flow list of a table of a specific family using the netlink handle passed\n// conntrack -L [table] [options]          List conntrack or expectation table\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) ConntrackTableList(table ConntrackTableType, family InetFamily) ([]*ConntrackFlow, error) {\n\tres, executeErr := h.dumpConntrackTable(table, family)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\t// Deserialize all the flows\n\tvar result []*ConntrackFlow\n\tfor _, dataRaw := range res {\n\t\tresult = append(result, parseRawData(dataRaw))\n\t}\n\n\treturn result, executeErr\n}\n\n// ConntrackTableFlush flushes all the flows of a specified table using the netlink handle passed\n// conntrack -F [table]            Flush table\n// The flush operation applies to all the family types\nfunc (h *Handle) ConntrackTableFlush(table ConntrackTableType) error {\n\treq := h.newConntrackRequest(table, unix.AF_INET, nl.IPCTNL_MSG_CT_DELETE, unix.NLM_F_ACK)\n\t_, err := req.Execute(unix.NETLINK_NETFILTER, 0)\n\treturn err\n}\n\n// ConntrackCreate creates a new conntrack flow in the desired table using the handle\n// conntrack -I [table]\t\tCreate a conntrack or expectation\nfunc (h *Handle) ConntrackCreate(table ConntrackTableType, family InetFamily, flow *ConntrackFlow) error {\n\treq := h.newConntrackRequest(table, family, nl.IPCTNL_MSG_CT_NEW, unix.NLM_F_ACK|unix.NLM_F_CREATE)\n\tattr, err := flow.toNlData()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, a := range attr {\n\t\treq.AddData(a)\n\t}\n\n\t_, err = req.Execute(unix.NETLINK_NETFILTER, 0)\n\treturn err\n}\n\n// ConntrackUpdate updates an existing conntrack flow in the desired table using the handle\n// conntrack -U [table]\t\tUpdate a conntrack\nfunc (h *Handle) ConntrackUpdate(table ConntrackTableType, family InetFamily, flow *ConntrackFlow) error {\n\treq := h.newConntrackRequest(table, family, nl.IPCTNL_MSG_CT_NEW, unix.NLM_F_ACK|unix.NLM_F_REPLACE)\n\tattr, err := flow.toNlData()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, a := range attr {\n\t\treq.AddData(a)\n\t}\n\n\t_, err = req.Execute(unix.NETLINK_NETFILTER, 0)\n\treturn err\n}\n\n// ConntrackDeleteFilter deletes entries on the specified table on the base of the filter using the netlink handle passed\n// conntrack -D [table] parameters         Delete conntrack or expectation\n//\n// Deprecated: use [Handle.ConntrackDeleteFilters] instead.\nfunc (h *Handle) ConntrackDeleteFilter(table ConntrackTableType, family InetFamily, filter CustomConntrackFilter) (uint, error) {\n\treturn h.ConntrackDeleteFilters(table, family, filter)\n}\n\n// ConntrackDeleteFilters deletes entries on the specified table matching any of the specified filters using the netlink handle passed\n// conntrack -D [table] parameters         Delete conntrack or expectation\nfunc (h *Handle) ConntrackDeleteFilters(table ConntrackTableType, family InetFamily, filters ...CustomConntrackFilter) (uint, error) {\n\tres, err := h.dumpConntrackTable(table, family)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar matched uint\n\tvar errMsgs []string\n\tfor _, dataRaw := range res {\n\t\tflow := parseRawData(dataRaw)\n\t\tfor _, filter := range filters {\n\t\t\tif match := filter.MatchConntrackFlow(flow); match {\n\t\t\t\treq2 := h.newConntrackRequest(table, family, nl.IPCTNL_MSG_CT_DELETE, unix.NLM_F_ACK)\n\t\t\t\t// skip the first 4 byte that are the netfilter header, the newConntrackRequest is adding it already\n\t\t\t\treq2.AddRawData(dataRaw[4:])\n\t\t\t\tif _, err = req2.Execute(unix.NETLINK_NETFILTER, 0); err == nil {\n\t\t\t\t\tmatched++\n\t\t\t\t\t// flow is already deleted, no need to match on other filters and continue to the next flow.\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\terrMsgs = append(errMsgs, fmt.Sprintf(\"failed to delete conntrack flow '%s': %s\", flow.String(), err.Error()))\n\t\t\t}\n\t\t}\n\t}\n\tif len(errMsgs) > 0 {\n\t\treturn matched, fmt.Errorf(strings.Join(errMsgs, \"; \"))\n\t}\n\treturn matched, nil\n}\n\nfunc (h *Handle) newConntrackRequest(table ConntrackTableType, family InetFamily, operation, flags int) *nl.NetlinkRequest {\n\t// Create the Netlink request object\n\treq := h.newNetlinkRequest((int(table)<<8)|operation, flags)\n\t// Add the netfilter header\n\tmsg := &nl.Nfgenmsg{\n\t\tNfgenFamily: uint8(family),\n\t\tVersion:     nl.NFNETLINK_V0,\n\t\tResId:       0,\n\t}\n\treq.AddData(msg)\n\treturn req\n}\n\nfunc (h *Handle) dumpConntrackTable(table ConntrackTableType, family InetFamily) ([][]byte, error) {\n\treq := h.newConntrackRequest(table, family, nl.IPCTNL_MSG_CT_GET, unix.NLM_F_DUMP)\n\treturn req.Execute(unix.NETLINK_NETFILTER, 0)\n}\n\n// ProtoInfo wraps an L4-protocol structure - roughly corresponds to the\n// __nfct_protoinfo union found in libnetfilter_conntrack/include/internal/object.h.\n// Currently, only protocol names, and TCP state is supported.\ntype ProtoInfo interface {\n\tProtocol() string\n}\n\n// ProtoInfoTCP corresponds to the `tcp` struct of the __nfct_protoinfo union.\n// Only TCP state is currently supported.\ntype ProtoInfoTCP struct {\n\tState uint8\n}\n// Protocol returns \"tcp\".\nfunc (*ProtoInfoTCP) Protocol() string {return \"tcp\"}\nfunc (p *ProtoInfoTCP) toNlData() ([]*nl.RtAttr, error) {\n\tctProtoInfo := nl.NewRtAttr(unix.NLA_F_NESTED | nl.CTA_PROTOINFO, []byte{})\n\tctProtoInfoTCP := nl.NewRtAttr(unix.NLA_F_NESTED|nl.CTA_PROTOINFO_TCP, []byte{})\n\tctProtoInfoTCPState := nl.NewRtAttr(nl.CTA_PROTOINFO_TCP_STATE, nl.Uint8Attr(p.State))\n\tctProtoInfoTCP.AddChild(ctProtoInfoTCPState)\n\tctProtoInfo.AddChild(ctProtoInfoTCP)\n\n\treturn []*nl.RtAttr{ctProtoInfo}, nil\n}\n\n// ProtoInfoSCTP only supports the protocol name.\ntype ProtoInfoSCTP struct {}\n// Protocol returns \"sctp\".\nfunc (*ProtoInfoSCTP) Protocol() string {return \"sctp\"}\n\n// ProtoInfoDCCP only supports the protocol name.\ntype ProtoInfoDCCP struct {}\n// Protocol returns \"dccp\".\nfunc (*ProtoInfoDCCP) Protocol() string {return \"dccp\"}\n\n// The full conntrack flow structure is very complicated and can be found in the file:\n// http://git.netfilter.org/libnetfilter_conntrack/tree/include/internal/object.h\n// For the time being, the structure below allows to parse and extract the base information of a flow\ntype IPTuple struct {\n\tBytes    uint64\n\tDstIP    net.IP\n\tDstPort  uint16\n\tPackets  uint64\n\tProtocol uint8\n\tSrcIP    net.IP\n\tSrcPort  uint16\n}\n\n// toNlData generates the inner fields of a nested tuple netlink datastructure\n// does not generate the \"nested\"-flagged outer message.\nfunc (t *IPTuple) toNlData(family uint8) ([]*nl.RtAttr, error) {\n\n\tvar srcIPsFlag, dstIPsFlag int\n\tif family == nl.FAMILY_V4 {\n\t\tsrcIPsFlag = nl.CTA_IP_V4_SRC\n\t\tdstIPsFlag = nl.CTA_IP_V4_DST\n\t} else if family == nl.FAMILY_V6 {\n\t\tsrcIPsFlag = nl.CTA_IP_V6_SRC\n\t\tdstIPsFlag = nl.CTA_IP_V6_DST\n\t} else {\n\t\treturn []*nl.RtAttr{}, fmt.Errorf(\"couldn't generate netlink message for tuple due to unrecognized FamilyType '%d'\", family)\n\t}\n\n\tctTupleIP := nl.NewRtAttr(unix.NLA_F_NESTED|nl.CTA_TUPLE_IP, nil)\n\tctTupleIPSrc := nl.NewRtAttr(srcIPsFlag, t.SrcIP)\n\tctTupleIP.AddChild(ctTupleIPSrc)\n\tctTupleIPDst := nl.NewRtAttr(dstIPsFlag, t.DstIP)\n\tctTupleIP.AddChild(ctTupleIPDst)\n\n\tctTupleProto := nl.NewRtAttr(unix.NLA_F_NESTED|nl.CTA_TUPLE_PROTO, nil)\n\tctTupleProtoNum := nl.NewRtAttr(nl.CTA_PROTO_NUM, []byte{t.Protocol})\n\tctTupleProto.AddChild(ctTupleProtoNum)\n\tctTupleProtoSrcPort := nl.NewRtAttr(nl.CTA_PROTO_SRC_PORT, nl.BEUint16Attr(t.SrcPort))\n\tctTupleProto.AddChild(ctTupleProtoSrcPort)\n\tctTupleProtoDstPort := nl.NewRtAttr(nl.CTA_PROTO_DST_PORT, nl.BEUint16Attr(t.DstPort))\n\tctTupleProto.AddChild(ctTupleProtoDstPort, )\n\n\treturn []*nl.RtAttr{ctTupleIP, ctTupleProto}, nil\n}\n\ntype ConntrackFlow struct {\n\tFamilyType uint8\n\tForward    IPTuple\n\tReverse    IPTuple\n\tMark       uint32\n\tZone       uint16\n\tTimeStart  uint64\n\tTimeStop   uint64\n\tTimeOut    uint32\n\tLabels     []byte\n\tProtoInfo  ProtoInfo\n}\n\nfunc (s *ConntrackFlow) String() string {\n\t// conntrack cmd output:\n\t// udp      17 src=127.0.0.1 dst=127.0.0.1 sport=4001 dport=1234 packets=5 bytes=532 [UNREPLIED] src=127.0.0.1 dst=127.0.0.1 sport=1234 dport=4001 packets=10 bytes=1078 mark=0 labels=0x00000000050012ac4202010000000000 zone=100\n\t//             start=2019-07-26 01:26:21.557800506 +0000 UTC stop=1970-01-01 00:00:00 +0000 UTC timeout=30(sec)\n\tstart := time.Unix(0, int64(s.TimeStart))\n\tstop := time.Unix(0, int64(s.TimeStop))\n\ttimeout := int32(s.TimeOut)\n\tres := fmt.Sprintf(\"%s\\t%d src=%s dst=%s sport=%d dport=%d packets=%d bytes=%d\\tsrc=%s dst=%s sport=%d dport=%d packets=%d bytes=%d mark=0x%x \",\n\t\tnl.L4ProtoMap[s.Forward.Protocol], s.Forward.Protocol,\n\t\ts.Forward.SrcIP.String(), s.Forward.DstIP.String(), s.Forward.SrcPort, s.Forward.DstPort, s.Forward.Packets, s.Forward.Bytes,\n\t\ts.Reverse.SrcIP.String(), s.Reverse.DstIP.String(), s.Reverse.SrcPort, s.Reverse.DstPort, s.Reverse.Packets, s.Reverse.Bytes,\n\t\ts.Mark)\n\tif len(s.Labels) > 0 {\n\t\tres += fmt.Sprintf(\"labels=0x%x \", s.Labels)\n\t}\n\tif s.Zone != 0 {\n\t\tres += fmt.Sprintf(\"zone=%d \", s.Zone)\n\t}\n\tres += fmt.Sprintf(\"start=%v stop=%v timeout=%d(sec)\", start, stop, timeout)\n\treturn res\n}\n\n// toNlData generates netlink messages representing the flow.\nfunc (s *ConntrackFlow) toNlData() ([]*nl.RtAttr, error) {\n\tvar payload []*nl.RtAttr\n\t// The message structure is built as follows:\n\t//\t<len, NLA_F_NESTED|CTA_TUPLE_ORIG>\n\t//\t\t<len, NLA_F_NESTED|CTA_TUPLE_IP>\n\t//\t\t\t<len, [CTA_IP_V4_SRC|CTA_IP_V6_SRC]>\n\t//\t\t\t<IP>\n\t//\t\t\t<len, [CTA_IP_V4_DST|CTA_IP_V6_DST]>\n\t//\t\t\t<IP>\n\t//\t\t<len, NLA_F_NESTED|nl.CTA_TUPLE_PROTO>\n\t//\t\t\t<len, CTA_PROTO_NUM>\n\t//\t\t\t<uint8>\n\t//\t\t\t<len, CTA_PROTO_SRC_PORT>\n\t//\t\t\t<BEuint16>\n\t//\t\t\t<len, CTA_PROTO_DST_PORT>\n\t//\t\t\t<BEuint16>\n\t// \t<len, NLA_F_NESTED|CTA_TUPLE_REPLY>\n\t//\t\t<len, NLA_F_NESTED|CTA_TUPLE_IP>\n\t//\t\t\t<len, [CTA_IP_V4_SRC|CTA_IP_V6_SRC]>\n\t//\t\t\t<IP>\n\t//\t\t\t<len, [CTA_IP_V4_DST|CTA_IP_V6_DST]>\n\t//\t\t\t<IP>\n\t//\t\t<len, NLA_F_NESTED|nl.CTA_TUPLE_PROTO>\n\t//\t\t\t<len, CTA_PROTO_NUM>\n\t//\t\t\t<uint8>\n\t//\t\t\t<len, CTA_PROTO_SRC_PORT>\n\t//\t\t\t<BEuint16>\n\t//\t\t\t<len, CTA_PROTO_DST_PORT>\n\t//\t\t\t<BEuint16>\n\t//\t<len, CTA_STATUS>\n\t//\t<uint64>\n\t//\t<len, CTA_MARK>\n\t//\t<BEuint64>\n\t//\t<len, CTA_TIMEOUT>\n\t//\t<BEuint64>\n\t//\t<len, NLA_F_NESTED|CTA_PROTOINFO>\n \n\t// CTA_TUPLE_ORIG\n\tctTupleOrig := nl.NewRtAttr(unix.NLA_F_NESTED|nl.CTA_TUPLE_ORIG, nil)\n\tforwardFlowAttrs, err := s.Forward.toNlData(s.FamilyType)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't generate netlink data for conntrack forward flow: %w\", err)\n\t}\n\tfor _, a := range forwardFlowAttrs {\n\t\tctTupleOrig.AddChild(a)\n\t}\n\n\t// CTA_TUPLE_REPLY\n\tctTupleReply := nl.NewRtAttr(unix.NLA_F_NESTED|nl.CTA_TUPLE_REPLY, nil)\n\treverseFlowAttrs, err := s.Reverse.toNlData(s.FamilyType)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't generate netlink data for conntrack reverse flow: %w\", err)\n\t}\n\tfor _, a := range reverseFlowAttrs {\n\t\tctTupleReply.AddChild(a)\n\t}\n\n\tctMark := nl.NewRtAttr(nl.CTA_MARK, nl.BEUint32Attr(s.Mark))\n\tctTimeout := nl.NewRtAttr(nl.CTA_TIMEOUT, nl.BEUint32Attr(s.TimeOut))\n\n\tpayload = append(payload, ctTupleOrig, ctTupleReply, ctMark, ctTimeout)\n\n\tif s.ProtoInfo != nil {\n\t\tswitch p := s.ProtoInfo.(type) {\n\t\tcase *ProtoInfoTCP:\n\t\t\tattrs, err := p.toNlData()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"couldn't generate netlink data for conntrack flow's TCP protoinfo: %w\", err)\n\t\t\t}\n\t\t\tpayload = append(payload, attrs...)\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"couldn't generate netlink data for conntrack: field 'ProtoInfo' only supports TCP or nil\")\n\t\t}\n\t}\n\n\treturn payload, nil\n}\n\n// This method parse the ip tuple structure\n// The message structure is the following:\n// <len, [CTA_IP_V4_SRC|CTA_IP_V6_SRC], 16 bytes for the IP>\n// <len, [CTA_IP_V4_DST|CTA_IP_V6_DST], 16 bytes for the IP>\n// <len, NLA_F_NESTED|nl.CTA_TUPLE_PROTO, 1 byte for the protocol, 3 bytes of padding>\n// <len, CTA_PROTO_SRC_PORT, 2 bytes for the source port, 2 bytes of padding>\n// <len, CTA_PROTO_DST_PORT, 2 bytes for the source port, 2 bytes of padding>\nfunc parseIpTuple(reader *bytes.Reader, tpl *IPTuple) uint8 {\n\tfor i := 0; i < 2; i++ {\n\t\t_, t, _, v := parseNfAttrTLV(reader)\n\t\tswitch t {\n\t\tcase nl.CTA_IP_V4_SRC, nl.CTA_IP_V6_SRC:\n\t\t\ttpl.SrcIP = v\n\t\tcase nl.CTA_IP_V4_DST, nl.CTA_IP_V6_DST:\n\t\t\ttpl.DstIP = v\n\t\t}\n\t}\n\t// Get total length of nested protocol-specific info.\n\t_, _, protoInfoTotalLen := parseNfAttrTL(reader)\n\t_, t, l, v := parseNfAttrTLV(reader)\n\t// Track the number of bytes read.\n\tprotoInfoBytesRead := uint16(nl.SizeofNfattr) + l\n\tif t == nl.CTA_PROTO_NUM {\n\t\ttpl.Protocol = uint8(v[0])\n\t}\n\t// We only parse TCP & UDP headers. Skip the others.\n\tif tpl.Protocol != unix.IPPROTO_TCP && tpl.Protocol != unix.IPPROTO_UDP {\n\t\t// skip the rest\n\t\tbytesRemaining := protoInfoTotalLen - protoInfoBytesRead\n\t\treader.Seek(int64(bytesRemaining), seekCurrent)\n\t\treturn tpl.Protocol\n\t}\n\t// Skip 3 bytes of padding\n\treader.Seek(3, seekCurrent)\n\tprotoInfoBytesRead += 3\n\tfor i := 0; i < 2; i++ {\n\t\t_, t, _ := parseNfAttrTL(reader)\n\t\tprotoInfoBytesRead += uint16(nl.SizeofNfattr)\n\t\tswitch t {\n\t\tcase nl.CTA_PROTO_SRC_PORT:\n\t\t\tparseBERaw16(reader, &tpl.SrcPort)\n\t\t\tprotoInfoBytesRead += 2\n\t\tcase nl.CTA_PROTO_DST_PORT:\n\t\t\tparseBERaw16(reader, &tpl.DstPort)\n\t\t\tprotoInfoBytesRead += 2\n\t\t}\n\t\t// Skip 2 bytes of padding\n\t\treader.Seek(2, seekCurrent)\n\t\tprotoInfoBytesRead += 2\n\t}\n\t// Skip any remaining/unknown parts of the message\n\tbytesRemaining := protoInfoTotalLen - protoInfoBytesRead\n\treader.Seek(int64(bytesRemaining), seekCurrent)\n\n\treturn tpl.Protocol\n}\n\nfunc parseNfAttrTLV(r *bytes.Reader) (isNested bool, attrType, len uint16, value []byte) {\n\tisNested, attrType, len = parseNfAttrTL(r)\n\n\tvalue = make([]byte, len)\n\tbinary.Read(r, binary.BigEndian, &value)\n\treturn isNested, attrType, len, value\n}\n\nfunc parseNfAttrTL(r *bytes.Reader) (isNested bool, attrType, len uint16) {\n\tbinary.Read(r, nl.NativeEndian(), &len)\n\tlen -= nl.SizeofNfattr\n\n\tbinary.Read(r, nl.NativeEndian(), &attrType)\n\tisNested = (attrType & nl.NLA_F_NESTED) == nl.NLA_F_NESTED\n\tattrType = attrType & (nl.NLA_F_NESTED - 1)\n\treturn isNested, attrType, len\n}\n\n// skipNfAttrValue seeks `r` past attr of length `len`.\n// Maintains buffer alignment.\n// Returns length of the seek performed.\nfunc skipNfAttrValue(r *bytes.Reader, len uint16) uint16 {\n\tlen = (len + nl.NLA_ALIGNTO - 1) & ^(nl.NLA_ALIGNTO - 1)\n\tr.Seek(int64(len), seekCurrent)\n\treturn len\n}\n\nfunc parseBERaw16(r *bytes.Reader, v *uint16) {\n\tbinary.Read(r, binary.BigEndian, v)\n}\n\nfunc parseBERaw32(r *bytes.Reader, v *uint32) {\n\tbinary.Read(r, binary.BigEndian, v)\n}\n\nfunc parseBERaw64(r *bytes.Reader, v *uint64) {\n\tbinary.Read(r, binary.BigEndian, v)\n}\n\nfunc parseRaw32(r *bytes.Reader, v *uint32) {\n\tbinary.Read(r, nl.NativeEndian(), v)\n}\n\nfunc parseByteAndPacketCounters(r *bytes.Reader) (bytes, packets uint64) {\n\tfor i := 0; i < 2; i++ {\n\t\tswitch _, t, _ := parseNfAttrTL(r); t {\n\t\tcase nl.CTA_COUNTERS_BYTES:\n\t\t\tparseBERaw64(r, &bytes)\n\t\tcase nl.CTA_COUNTERS_PACKETS:\n\t\t\tparseBERaw64(r, &packets)\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// when the flow is alive, only the timestamp_start is returned in structure\nfunc parseTimeStamp(r *bytes.Reader, readSize uint16) (tstart, tstop uint64) {\n\tvar numTimeStamps int\n\toneItem := nl.SizeofNfattr + 8 // 4 bytes attr header + 8 bytes timestamp\n\tif readSize == uint16(oneItem) {\n\t\tnumTimeStamps = 1\n\t} else if readSize == 2*uint16(oneItem) {\n\t\tnumTimeStamps = 2\n\t} else {\n\t\treturn\n\t}\n\tfor i := 0; i < numTimeStamps; i++ {\n\t\tswitch _, t, _ := parseNfAttrTL(r); t {\n\t\tcase nl.CTA_TIMESTAMP_START:\n\t\t\tparseBERaw64(r, &tstart)\n\t\tcase nl.CTA_TIMESTAMP_STOP:\n\t\t\tparseBERaw64(r, &tstop)\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n\n}\n\nfunc parseProtoInfoTCPState(r *bytes.Reader) (s uint8) {\n\tbinary.Read(r, binary.BigEndian, &s)\n\tr.Seek(nl.SizeofNfattr - 1, seekCurrent)\n\treturn s\n}\n\n// parseProtoInfoTCP reads the entire nested protoinfo structure, but only parses the state attr.\nfunc parseProtoInfoTCP(r *bytes.Reader, attrLen uint16) (*ProtoInfoTCP) {\n\tp := new(ProtoInfoTCP)\n\tbytesRead := 0\n\tfor bytesRead < int(attrLen) {\n\t\t_, t, l := parseNfAttrTL(r)\n\t\tbytesRead += nl.SizeofNfattr\n\n\t\tswitch t {\n\t\tcase nl.CTA_PROTOINFO_TCP_STATE:\n\t\t\tp.State = parseProtoInfoTCPState(r)\n\t\t\tbytesRead += nl.SizeofNfattr\n\t\tdefault:\n\t\t\tbytesRead += int(skipNfAttrValue(r, l))\n\t\t}\n\t}\n\n\treturn p\n}\n\nfunc parseProtoInfo(r *bytes.Reader, attrLen uint16) (p ProtoInfo) {\n\tbytesRead := 0\n\tfor bytesRead < int(attrLen) {\n\t\t_, t, l := parseNfAttrTL(r)\n\t\tbytesRead += nl.SizeofNfattr\n\n\t\tswitch t {\n\t\tcase nl.CTA_PROTOINFO_TCP:\n\t\t\tp = parseProtoInfoTCP(r, l)\n\t\t\tbytesRead += int(l)\n\t\t// No inner fields of DCCP / SCTP currently supported.\n\t\tcase nl.CTA_PROTOINFO_DCCP:\n\t\t\tp = new(ProtoInfoDCCP)\n\t\t\tskipped := skipNfAttrValue(r, l)\n\t\t\tbytesRead += int(skipped)\n\t\tcase nl.CTA_PROTOINFO_SCTP:\n\t\t\tp = new(ProtoInfoSCTP)\n\t\t\tskipped := skipNfAttrValue(r, l)\n\t\t\tbytesRead += int(skipped)\n\t\tdefault:\n\t\t\tskipped := skipNfAttrValue(r, l)\n\t\t\tbytesRead += int(skipped)\n\t\t}\n\t}\n\n\treturn p\n}\n\nfunc parseTimeOut(r *bytes.Reader) (ttimeout uint32) {\n\tparseBERaw32(r, &ttimeout)\n\treturn\n}\n\nfunc parseConnectionMark(r *bytes.Reader) (mark uint32) {\n\tparseBERaw32(r, &mark)\n\treturn\n}\n\nfunc parseConnectionLabels(r *bytes.Reader) (label []byte) {\n\tlabel = make([]byte, 16) // netfilter defines 128 bit labels value\n\tbinary.Read(r, nl.NativeEndian(), &label)\n\treturn\n}\n\nfunc parseConnectionZone(r *bytes.Reader) (zone uint16) {\n\tparseBERaw16(r, &zone)\n\tr.Seek(2, seekCurrent)\n\treturn\n}\n\nfunc parseRawData(data []byte) *ConntrackFlow {\n\ts := &ConntrackFlow{}\n\t// First there is the Nfgenmsg header\n\t// consume only the family field\n\treader := bytes.NewReader(data)\n\tbinary.Read(reader, nl.NativeEndian(), &s.FamilyType)\n\n\t// skip rest of the Netfilter header\n\treader.Seek(3, seekCurrent)\n\t// The message structure is the following:\n\t// <len, NLA_F_NESTED|CTA_TUPLE_ORIG> 4 bytes\n\t// <len, NLA_F_NESTED|CTA_TUPLE_IP> 4 bytes\n\t// flow information of the forward flow\n\t// <len, NLA_F_NESTED|CTA_TUPLE_REPLY> 4 bytes\n\t// <len, NLA_F_NESTED|CTA_TUPLE_IP> 4 bytes\n\t// flow information of the reverse flow\n\tfor reader.Len() > 0 {\n\t\tif nested, t, l := parseNfAttrTL(reader); nested {\n\t\t\tswitch t {\n\t\t\tcase nl.CTA_TUPLE_ORIG:\n\t\t\t\tif nested, t, l = parseNfAttrTL(reader); nested && t == nl.CTA_TUPLE_IP {\n\t\t\t\t\tparseIpTuple(reader, &s.Forward)\n\t\t\t\t}\n\t\t\tcase nl.CTA_TUPLE_REPLY:\n\t\t\t\tif nested, t, l = parseNfAttrTL(reader); nested && t == nl.CTA_TUPLE_IP {\n\t\t\t\t\tparseIpTuple(reader, &s.Reverse)\n\t\t\t\t} else {\n\t\t\t\t\t// Header not recognized skip it\n\t\t\t\t\tskipNfAttrValue(reader, l)\n\t\t\t\t}\n\t\t\tcase nl.CTA_COUNTERS_ORIG:\n\t\t\t\ts.Forward.Bytes, s.Forward.Packets = parseByteAndPacketCounters(reader)\n\t\t\tcase nl.CTA_COUNTERS_REPLY:\n\t\t\t\ts.Reverse.Bytes, s.Reverse.Packets = parseByteAndPacketCounters(reader)\n\t\t\tcase nl.CTA_TIMESTAMP:\n\t\t\t\ts.TimeStart, s.TimeStop = parseTimeStamp(reader, l)\n\t\t\tcase nl.CTA_PROTOINFO:\n\t\t\t\ts.ProtoInfo = parseProtoInfo(reader, l)\n\t\t\tdefault:\n\t\t\t\tskipNfAttrValue(reader, l)\n\t\t\t}\n\t\t} else {\n\t\t\tswitch t {\n\t\t\tcase nl.CTA_MARK:\n\t\t\t\ts.Mark = parseConnectionMark(reader)\n\t\t\t\tcase nl.CTA_LABELS:\n\t\t\t\ts.Labels = parseConnectionLabels(reader)\n\t\t\tcase nl.CTA_TIMEOUT:\n\t\t\t\ts.TimeOut = parseTimeOut(reader)\n\t\t\tcase nl.CTA_ID, nl.CTA_STATUS, nl.CTA_USE:\n\t\t\t\tskipNfAttrValue(reader, l)\n\t\t\tcase nl.CTA_ZONE:\n\t\t\t\ts.Zone = parseConnectionZone(reader)\n\t\t\tdefault:\n\t\t\t\tskipNfAttrValue(reader, l)\n\t\t\t}\n\t\t}\n\t}\n\treturn s\n}\n\n// Conntrack parameters and options:\n//   -n, --src-nat ip                      source NAT ip\n//   -g, --dst-nat ip                      destination NAT ip\n//   -j, --any-nat ip                      source or destination NAT ip\n//   -m, --mark mark                       Set mark\n//   -c, --secmark secmark                 Set selinux secmark\n//   -e, --event-mask eventmask            Event mask, eg. NEW,DESTROY\n//   -z, --zero                            Zero counters while listing\n//   -o, --output type[,...]               Output format, eg. xml\n//   -l, --label label[,...]               conntrack labels\n\n// Common parameters and options:\n//   -s, --src, --orig-src ip              Source address from original direction\n//   -d, --dst, --orig-dst ip              Destination address from original direction\n//   -r, --reply-src ip            Source address from reply direction\n//   -q, --reply-dst ip            Destination address from reply direction\n//   -p, --protonum proto          Layer 4 Protocol, eg. 'tcp'\n//   -f, --family proto            Layer 3 Protocol, eg. 'ipv6'\n//   -t, --timeout timeout         Set timeout\n//   -u, --status status           Set status, eg. ASSURED\n//   -w, --zone value              Set conntrack zone\n//   --orig-zone value             Set zone for original direction\n//   --reply-zone value            Set zone for reply direction\n//   -b, --buffer-size             Netlink socket buffer size\n//   --mask-src ip                 Source mask address\n//   --mask-dst ip                 Destination mask address\n\n// Layer 4 Protocol common parameters and options:\n// TCP, UDP, SCTP, UDPLite and DCCP\n//    --sport, --orig-port-src port    Source port in original direction\n//    --dport, --orig-port-dst port    Destination port in original direction\n\n// Filter types\ntype ConntrackFilterType uint8\n\nconst (\n\tConntrackOrigSrcIP     = iota                // -orig-src ip    Source address from original direction\n\tConntrackOrigDstIP                           // -orig-dst ip    Destination address from original direction\n\tConntrackReplySrcIP                          // --reply-src ip  Reply Source IP\n\tConntrackReplyDstIP                          // --reply-dst ip  Reply Destination IP\n\tConntrackReplyAnyIP                          // Match source or destination reply IP\n\tConntrackOrigSrcPort                         // --orig-port-src port    Source port in original direction\n\tConntrackOrigDstPort                         // --orig-port-dst port    Destination port in original direction\n\tConntrackMatchLabels                         // --label label1,label2   Labels used in entry\n\tConntrackUnmatchLabels                       // --label label1,label2   Labels not used in entry\n\tConntrackNatSrcIP      = ConntrackReplySrcIP // deprecated use instead ConntrackReplySrcIP\n\tConntrackNatDstIP      = ConntrackReplyDstIP // deprecated use instead ConntrackReplyDstIP\n\tConntrackNatAnyIP      = ConntrackReplyAnyIP // deprecated use instead ConntrackReplyAnyIP\n)\n\ntype CustomConntrackFilter interface {\n\t// MatchConntrackFlow applies the filter to the flow and returns true if the flow matches\n\t// the filter or false otherwise\n\tMatchConntrackFlow(flow *ConntrackFlow) bool\n}\n\ntype ConntrackFilter struct {\n\tipNetFilter map[ConntrackFilterType]*net.IPNet\n\tportFilter  map[ConntrackFilterType]uint16\n\tprotoFilter uint8\n\tlabelFilter map[ConntrackFilterType][][]byte\n\tzoneFilter  *uint16\n}\n\n// AddIPNet adds a IP subnet to the conntrack filter\nfunc (f *ConntrackFilter) AddIPNet(tp ConntrackFilterType, ipNet *net.IPNet) error {\n\tif ipNet == nil {\n\t\treturn fmt.Errorf(\"Filter attribute empty\")\n\t}\n\tif f.ipNetFilter == nil {\n\t\tf.ipNetFilter = make(map[ConntrackFilterType]*net.IPNet)\n\t}\n\tif _, ok := f.ipNetFilter[tp]; ok {\n\t\treturn errors.New(\"Filter attribute already present\")\n\t}\n\tf.ipNetFilter[tp] = ipNet\n\treturn nil\n}\n\n// AddIP adds an IP to the conntrack filter\nfunc (f *ConntrackFilter) AddIP(tp ConntrackFilterType, ip net.IP) error {\n\tif ip == nil {\n\t\treturn fmt.Errorf(\"Filter attribute empty\")\n\t}\n\treturn f.AddIPNet(tp, NewIPNet(ip))\n}\n\n// AddPort adds a Port to the conntrack filter if the Layer 4 protocol allows it\nfunc (f *ConntrackFilter) AddPort(tp ConntrackFilterType, port uint16) error {\n\tswitch f.protoFilter {\n\t// TCP, UDP, DCCP, SCTP, UDPLite\n\tcase 6, 17, 33, 132, 136:\n\tdefault:\n\t\treturn fmt.Errorf(\"Filter attribute not available without a valid Layer 4 protocol: %d\", f.protoFilter)\n\t}\n\n\tif f.portFilter == nil {\n\t\tf.portFilter = make(map[ConntrackFilterType]uint16)\n\t}\n\tif _, ok := f.portFilter[tp]; ok {\n\t\treturn errors.New(\"Filter attribute already present\")\n\t}\n\tf.portFilter[tp] = port\n\treturn nil\n}\n\n// AddProtocol adds the Layer 4 protocol to the conntrack filter\nfunc (f *ConntrackFilter) AddProtocol(proto uint8) error {\n\tif f.protoFilter != 0 {\n\t\treturn errors.New(\"Filter attribute already present\")\n\t}\n\tf.protoFilter = proto\n\treturn nil\n}\n\n// AddLabels adds the provided list (zero or more) of labels to the conntrack filter\n// ConntrackFilterType here can be either:\n//  1. ConntrackMatchLabels: This matches every flow that has a label value (len(flow.Labels) > 0)\n//     against the list of provided labels. If `flow.Labels` contains ALL the provided labels\n//     it is considered a match. This can be used when you want to match flows that contain\n//     one or more labels.\n//  2. ConntrackUnmatchLabels:  This matches every flow that has a label value (len(flow.Labels) > 0)\n//     against the list of provided labels. If `flow.Labels` does NOT contain ALL the provided labels\n//     it is considered a match. This can be used when you want to match flows that don't contain\n//     one or more labels.\nfunc (f *ConntrackFilter) AddLabels(tp ConntrackFilterType, labels [][]byte) error {\n\tif len(labels) == 0 {\n\t\treturn errors.New(\"Invalid length for provided labels\")\n\t}\n\tif f.labelFilter == nil {\n\t\tf.labelFilter = make(map[ConntrackFilterType][][]byte)\n\t}\n\tif _, ok := f.labelFilter[tp]; ok {\n\t\treturn errors.New(\"Filter attribute already present\")\n\t}\n\tf.labelFilter[tp] = labels\n\treturn nil\n}\n\n// AddZone adds a zone to the conntrack filter\nfunc (f *ConntrackFilter) AddZone(zone uint16) error {\n\tif f.zoneFilter != nil {\n\t\treturn errors.New(\"Filter attribute already present\")\n\t}\n\tf.zoneFilter = &zone\n\treturn nil\n}\n\n// MatchConntrackFlow applies the filter to the flow and returns true if the flow matches the filter\n// false otherwise\nfunc (f *ConntrackFilter) MatchConntrackFlow(flow *ConntrackFlow) bool {\n\tif len(f.ipNetFilter) == 0 && len(f.portFilter) == 0 && f.protoFilter == 0 && len(f.labelFilter) == 0 && f.zoneFilter == nil {\n\t\t// empty filter always not match\n\t\treturn false\n\t}\n\n\t// -p, --protonum proto          Layer 4 Protocol, eg. 'tcp'\n\tif f.protoFilter != 0 && flow.Forward.Protocol != f.protoFilter {\n\t\t// different Layer 4 protocol always not match\n\t\treturn false\n\t}\n\n\t// Conntrack zone filter\n\tif f.zoneFilter != nil && *f.zoneFilter != flow.Zone {\n\t\treturn false\n\t}\n\n\tmatch := true\n\n\t// IP conntrack filter\n\tif len(f.ipNetFilter) > 0 {\n\t\t// -orig-src ip   Source address from original direction\n\t\tif elem, found := f.ipNetFilter[ConntrackOrigSrcIP]; found {\n\t\t\tmatch = match && elem.Contains(flow.Forward.SrcIP)\n\t\t}\n\n\t\t// -orig-dst ip   Destination address from original direction\n\t\tif elem, found := f.ipNetFilter[ConntrackOrigDstIP]; match && found {\n\t\t\tmatch = match && elem.Contains(flow.Forward.DstIP)\n\t\t}\n\n\t\t// -src-nat ip    Source NAT ip\n\t\tif elem, found := f.ipNetFilter[ConntrackReplySrcIP]; match && found {\n\t\t\tmatch = match && elem.Contains(flow.Reverse.SrcIP)\n\t\t}\n\n\t\t// -dst-nat ip    Destination NAT ip\n\t\tif elem, found := f.ipNetFilter[ConntrackReplyDstIP]; match && found {\n\t\t\tmatch = match && elem.Contains(flow.Reverse.DstIP)\n\t\t}\n\n\t\t// Match source or destination reply IP\n\t\tif elem, found := f.ipNetFilter[ConntrackReplyAnyIP]; match && found {\n\t\t\tmatch = match && (elem.Contains(flow.Reverse.SrcIP) || elem.Contains(flow.Reverse.DstIP))\n\t\t}\n\t}\n\n\t// Layer 4 Port filter\n\tif len(f.portFilter) > 0 {\n\t\t// -orig-port-src port\tSource port from original direction\n\t\tif elem, found := f.portFilter[ConntrackOrigSrcPort]; match && found {\n\t\t\tmatch = match && elem == flow.Forward.SrcPort\n\t\t}\n\n\t\t// -orig-port-dst port\tDestination port from original direction\n\t\tif elem, found := f.portFilter[ConntrackOrigDstPort]; match && found {\n\t\t\tmatch = match && elem == flow.Forward.DstPort\n\t\t}\n\t}\n\n\t// Label filter\n\tif len(f.labelFilter) > 0 {\n\t\tif len(flow.Labels) > 0 {\n\t\t\t// --label label1,label2 in conn entry;\n\t\t\t// every label passed should be contained in flow.Labels for a match to be true\n\t\t\tif elem, found := f.labelFilter[ConntrackMatchLabels]; match && found {\n\t\t\t\tfor _, label := range elem {\n\t\t\t\t\tmatch = match && (bytes.Contains(flow.Labels, label))\n\t\t\t\t}\n\t\t\t}\n\t\t\t// --label label1,label2 in conn entry;\n\t\t\t// every label passed should be not contained in flow.Labels for a match to be true\n\t\t\tif elem, found := f.labelFilter[ConntrackUnmatchLabels]; match && found {\n\t\t\t\tfor _, label := range elem {\n\t\t\t\t\tmatch = match && !(bytes.Contains(flow.Labels, label))\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// flow doesn't contain labels, so it doesn't contain or notContain any provided matches\n\t\t\tmatch = false\n\t\t}\n\t}\n\n\treturn match\n}\n\nvar _ CustomConntrackFilter = (*ConntrackFilter)(nil)\n"
        },
        {
          "name": "conntrack_test.go",
          "type": "blob",
          "size": 44.2958984375,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc CheckErrorFail(t *testing.T, err error) {\n\tif err != nil {\n\t\tt.Fatalf(\"Fatal Error: %s\", err)\n\t}\n}\nfunc CheckError(t *testing.T, err error) {\n\tif err != nil {\n\t\tt.Errorf(\"Error: %s\", err)\n\t}\n}\n\nfunc udpFlowCreateProg(t *testing.T, flows, srcPort int, dstIP string, dstPort int) {\n\tfor i := 0; i < flows; i++ {\n\t\tServerAddr, err := net.ResolveUDPAddr(\"udp\", fmt.Sprintf(\"%s:%d\", dstIP, dstPort))\n\t\tCheckError(t, err)\n\n\t\tLocalAddr, err := net.ResolveUDPAddr(\"udp\", fmt.Sprintf(\"127.0.0.1:%d\", srcPort+i))\n\t\tCheckError(t, err)\n\n\t\tConn, err := net.DialUDP(\"udp\", LocalAddr, ServerAddr)\n\t\tCheckError(t, err)\n\n\t\tConn.Write([]byte(\"Hello World\"))\n\t\tConn.Close()\n\t}\n}\n\nfunc nsCreateAndEnter(t *testing.T) (*netns.NsHandle, *netns.NsHandle, *Handle) {\n\t// Lock the OS Thread so we don't accidentally switch namespaces\n\truntime.LockOSThread()\n\n\t// Save the current network namespace\n\torigns, _ := netns.Get()\n\n\tns, err := netns.New()\n\tCheckErrorFail(t, err)\n\n\th, err := NewHandleAt(ns)\n\tCheckErrorFail(t, err)\n\n\t// Enter the new namespace\n\tnetns.Set(ns)\n\n\t// Bing up loopback\n\tlink, _ := h.LinkByName(\"lo\")\n\th.LinkSetUp(link)\n\n\treturn &origns, &ns, h\n}\n\nfunc applyFilter(flowList []ConntrackFlow, ipv4Filter *ConntrackFilter, ipv6Filter *ConntrackFilter) (ipv4Match, ipv6Match uint) {\n\tfor _, flow := range flowList {\n\t\tif ipv4Filter.MatchConntrackFlow(&flow) == true {\n\t\t\tipv4Match++\n\t\t}\n\t\tif ipv6Filter.MatchConntrackFlow(&flow) == true {\n\t\t\tipv6Match++\n\t\t}\n\t}\n\treturn ipv4Match, ipv6Match\n}\n\n// TestConntrackSocket test the opening of a NETFILTER family socket\nfunc TestConntrackSocket(t *testing.T) {\n\tskipUnlessRoot(t)\n\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack\")\n\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack_netlink\")\n\n\th, err := NewHandle(unix.NETLINK_NETFILTER)\n\tCheckErrorFail(t, err)\n\n\tif h.SupportsNetlinkFamily(unix.NETLINK_NETFILTER) != true {\n\t\tt.Fatal(\"ERROR not supporting the NETFILTER family\")\n\t}\n}\n\n// TestConntrackTableList test the conntrack table list\n// Creates some flows and checks that they are correctly fetched from the conntrack table\nfunc TestConntrackTableList(t *testing.T) {\n\tif os.Getenv(\"CI\") == \"true\" {\n\t\tt.Skipf(\"Fails in CI: Flow creation fails\")\n\t}\n\tskipUnlessRoot(t)\n\tk, m, err := KernelVersion()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// conntrack l3proto was unified since 4.19\n\t// https://github.com/torvalds/linux/commit/a0ae2562c6c4b2721d9fddba63b7286c13517d9f\n\tif k < 4 || k == 4 && m < 19 {\n\t\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack_ipv4\")\n\t\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack_ipv6\")\n\t}\n\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack\")\n\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack_netlink\")\n\n\t// Creates a new namespace and bring up the loopback interface\n\torigns, ns, h := nsCreateAndEnter(t)\n\tdefer netns.Set(*origns)\n\tdefer origns.Close()\n\tdefer ns.Close()\n\tdefer runtime.UnlockOSThread()\n\n\tsetUpF(t, \"/proc/sys/net/netfilter/nf_conntrack_acct\", \"1\")\n\tsetUpF(t, \"/proc/sys/net/netfilter/nf_conntrack_timestamp\", \"1\")\n\tsetUpF(t, \"/proc/sys/net/netfilter/nf_conntrack_udp_timeout\", \"45\")\n\n\t// Flush the table to start fresh\n\terr = h.ConntrackTableFlush(ConntrackTable)\n\tCheckErrorFail(t, err)\n\n\t// Create 5 udp\n\tstartTime := time.Now()\n\tudpFlowCreateProg(t, 5, 2000, \"127.0.0.10\", 3000)\n\n\t// Fetch the conntrack table\n\tflows, err := h.ConntrackTableList(ConntrackTable, unix.AF_INET)\n\tCheckErrorFail(t, err)\n\n\t// Check that it is able to find the 5 flows created\n\tvar found int\n\tfor _, flow := range flows {\n\t\tif flow.Forward.Protocol == 17 &&\n\t\t\tflow.Forward.DstIP.Equal(net.ParseIP(\"127.0.0.10\")) &&\n\t\t\tflow.Forward.DstPort == 3000 &&\n\t\t\t(flow.Forward.SrcPort >= 2000 && flow.Forward.SrcPort <= 2005) {\n\t\t\tfound++\n\t\t\tflowStart := time.Unix(0, int64(flow.TimeStart))\n\t\t\tif flowStart.Before(startTime) || flowStart.Sub(startTime) > time.Second {\n\t\t\t\tt.Error(\"Invalid conntrack entry start timestamp\")\n\t\t\t}\n\t\t\tif flow.TimeStop != 0 {\n\t\t\t\tt.Error(\"Invalid conntrack entry stop timestamp\")\n\t\t\t}\n\t\t\t// Expect at most one second to have already passed from the configured UDP timeout of 45secs.\n\t\t\tif flow.TimeOut < 44 || flow.TimeOut > 45 {\n\t\t\t\tt.Error(\"Invalid conntrack entry timeout\")\n\t\t\t}\n\t\t}\n\n\t\tif flow.Forward.Bytes == 0 && flow.Forward.Packets == 0 && flow.Reverse.Bytes == 0 && flow.Reverse.Packets == 0 {\n\t\t\tt.Error(\"No traffic statistics are collected\")\n\t\t}\n\t}\n\tif found != 5 {\n\t\tt.Fatalf(\"Found only %d flows over 5\", found)\n\t}\n\n\t// Give a try also to the IPv6 version\n\t_, err = h.ConntrackTableList(ConntrackTable, unix.AF_INET6)\n\tCheckErrorFail(t, err)\n\n\t// Switch back to the original namespace\n\tnetns.Set(*origns)\n}\n\n// TestConntrackTableFlush test the conntrack table flushing\n// Creates some flows and then call the table flush\nfunc TestConntrackTableFlush(t *testing.T) {\n\tif os.Getenv(\"CI\") == \"true\" {\n\t\tt.Skipf(\"Fails in CI: Flow creation fails\")\n\t}\n\tskipUnlessRoot(t)\n\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack\")\n\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack_netlink\")\n\tk, m, err := KernelVersion()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// conntrack l3proto was unified since 4.19\n\t// https://github.com/torvalds/linux/commit/a0ae2562c6c4b2721d9fddba63b7286c13517d9f\n\tif k < 4 || k == 4 && m < 19 {\n\t\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack_ipv4\")\n\t}\n\tsetUpNetlinkTestWithKModule(t, \"nf_conntrack\")\n\t// Creates a new namespace and bring up the loopback interface\n\torigns, ns, h := nsCreateAndEnter(t)\n\tdefer netns.Set(*origns)\n\tdefer origns.Close()\n\tdefer ns.Close()\n\tdefer runtime.UnlockOSThread()\n\n\t// Create 5 udp flows using netcat\n\tudpFlowCreateProg(t, 5, 3000, \"127.0.0.10\", 4000)\n\n\t// Fetch the conntrack table\n\tflows, err := h.ConntrackTableList(ConntrackTable, unix.AF_INET)\n\tCheckErrorFail(t, err)\n\n\t// Check that it is able to find the 5 flows created\n\tvar found int\n\tfor _, flow := range flows {\n\t\tif flow.Forward.Protocol == 17 &&\n\t\t\tflow.Forward.DstIP.Equal(net.ParseIP(\"127.0.0.10\")) &&\n\t\t\tflow.Forward.DstPort == 4000 &&\n\t\t\t(flow.Forward.SrcPort >= 3000 && flow.Forward.SrcPort <= 3005) {\n\t\t\tfound++\n\t\t}\n\t}\n\tif found != 5 {\n\t\tt.Fatalf(\"Found only %d flows over 5\", found)\n\t}\n\n\t// Flush the table\n\terr = h.ConntrackTableFlush(ConntrackTable)\n\tCheckErrorFail(t, err)\n\n\t// Fetch again the flows to validate the flush\n\tflows, err = h.ConntrackTableList(ConntrackTable, unix.AF_INET)\n\tCheckErrorFail(t, err)\n\n\t// Check if it is still able to find the 5 flows created\n\tfound = 0\n\tfor _, flow := range flows {\n\t\tif flow.Forward.Protocol == 17 &&\n\t\t\tflow.Forward.DstIP.Equal(net.ParseIP(\"127.0.0.10\")) &&\n\t\t\tflow.Forward.DstPort == 4000 &&\n\t\t\t(flow.Forward.SrcPort >= 3000 && flow.Forward.SrcPort <= 3005) {\n\t\t\tfound++\n\t\t}\n\t}\n\tif found > 0 {\n\t\tt.Fatalf(\"Found %d flows, they should had been flushed\", found)\n\t}\n\n\t// Switch back to the original namespace\n\tnetns.Set(*origns)\n}\n\n// TestConntrackTableDelete tests the deletion with filter\n// Creates 2 group of flows then deletes only one group and validates the result\nfunc TestConntrackTableDelete(t *testing.T) {\n\tif os.Getenv(\"CI\") == \"true\" {\n\t\tt.Skipf(\"Fails in CI: Flow creation fails\")\n\t}\n\tskipUnlessRoot(t)\n\n\trequiredModules := []string{\"nf_conntrack\", \"nf_conntrack_netlink\"}\n\tk, m, err := KernelVersion()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// conntrack l3proto was unified since 4.19\n\t// https://github.com/torvalds/linux/commit/a0ae2562c6c4b2721d9fddba63b7286c13517d9f\n\tif k < 4 || k == 4 && m < 19 {\n\t\trequiredModules = append(requiredModules, \"nf_conntrack_ipv4\")\n\t}\n\n\tsetUpNetlinkTestWithKModule(t, requiredModules...)\n\n\t// Creates a new namespace and bring up the loopback interface\n\torigns, ns, h := nsCreateAndEnter(t)\n\tdefer netns.Set(*origns)\n\tdefer origns.Close()\n\tdefer ns.Close()\n\tdefer runtime.UnlockOSThread()\n\n\t// Create 10 udp flows\n\tudpFlowCreateProg(t, 5, 5000, \"127.0.0.10\", 6000)\n\tudpFlowCreateProg(t, 5, 7000, \"127.0.0.20\", 8000)\n\n\t// Fetch the conntrack table\n\tflows, err := h.ConntrackTableList(ConntrackTable, unix.AF_INET)\n\tCheckErrorFail(t, err)\n\n\t// Check that it is able to find the 5 flows created for each group\n\tvar groupA int\n\tvar groupB int\n\tfor _, flow := range flows {\n\t\tif flow.Forward.Protocol == 17 &&\n\t\t\tflow.Forward.DstIP.Equal(net.ParseIP(\"127.0.0.10\")) &&\n\t\t\tflow.Forward.DstPort == 6000 &&\n\t\t\t(flow.Forward.SrcPort >= 5000 && flow.Forward.SrcPort <= 5005) {\n\t\t\tgroupA++\n\t\t}\n\t\tif flow.Forward.Protocol == 17 &&\n\t\t\tflow.Forward.DstIP.Equal(net.ParseIP(\"127.0.0.20\")) &&\n\t\t\tflow.Forward.DstPort == 8000 &&\n\t\t\t(flow.Forward.SrcPort >= 7000 && flow.Forward.SrcPort <= 7005) {\n\t\t\tgroupB++\n\t\t}\n\t}\n\tif groupA != 5 || groupB != 5 {\n\t\tt.Fatalf(\"Flow creation issue groupA:%d, groupB:%d\", groupA, groupB)\n\t}\n\n\t// Create a filter to erase groupB flows\n\tfilter := &ConntrackFilter{}\n\tfilter.AddIP(ConntrackOrigDstIP, net.ParseIP(\"127.0.0.20\"))\n\tfilter.AddProtocol(17)\n\tfilter.AddPort(ConntrackOrigDstPort, 8000)\n\n\t// Flush entries of groupB\n\tvar deleted uint\n\tif deleted, err = h.ConntrackDeleteFilters(ConntrackTable, unix.AF_INET, filter); err != nil {\n\t\tt.Fatalf(\"Error during the erase: %s\", err)\n\t}\n\tif deleted != 5 {\n\t\tt.Fatalf(\"Error deleted a wrong number of flows:%d instead of 5\", deleted)\n\t}\n\n\t// Check again the table to verify that are gone\n\tflows, err = h.ConntrackTableList(ConntrackTable, unix.AF_INET)\n\tCheckErrorFail(t, err)\n\n\t// Check if it is able to find the 5 flows of groupA but none of groupB\n\tgroupA = 0\n\tgroupB = 0\n\tfor _, flow := range flows {\n\t\tif flow.Forward.Protocol == 17 &&\n\t\t\tflow.Forward.DstIP.Equal(net.ParseIP(\"127.0.0.10\")) &&\n\t\t\tflow.Forward.DstPort == 6000 &&\n\t\t\t(flow.Forward.SrcPort >= 5000 && flow.Forward.SrcPort <= 5005) {\n\t\t\tgroupA++\n\t\t}\n\t\tif flow.Forward.Protocol == 17 &&\n\t\t\tflow.Forward.DstIP.Equal(net.ParseIP(\"127.0.0.20\")) &&\n\t\t\tflow.Forward.DstPort == 8000 &&\n\t\t\t(flow.Forward.SrcPort >= 7000 && flow.Forward.SrcPort <= 7005) {\n\t\t\tgroupB++\n\t\t}\n\t}\n\tif groupA != 5 || groupB > 0 {\n\t\tt.Fatalf(\"Error during the erase groupA:%d, groupB:%d\", groupA, groupB)\n\t}\n\n\t// Switch back to the original namespace\n\tnetns.Set(*origns)\n}\n\nfunc TestConntrackFilter(t *testing.T) {\n\tvar flowList []ConntrackFlow\n\tflowList = append(flowList, ConntrackFlow{\n\t\t\tFamilyType: unix.AF_INET,\n\t\t\tForward: IPTuple{\n\t\t\t\tSrcIP:    net.ParseIP(\"10.0.0.1\"),\n\t\t\t\tDstIP:    net.ParseIP(\"20.0.0.1\"),\n\t\t\t\tSrcPort:  1000,\n\t\t\t\tDstPort:  2000,\n\t\t\t\tProtocol: 17,\n\t\t\t},\n\t\t\tReverse: IPTuple{\n\t\t\t\tSrcIP:    net.ParseIP(\"20.0.0.1\"),\n\t\t\t\tDstIP:    net.ParseIP(\"192.168.1.1\"),\n\t\t\t\tSrcPort:  2000,\n\t\t\t\tDstPort:  1000,\n\t\t\t\tProtocol: 17,\n\t\t\t},\n\t\t},\n\t\tConntrackFlow{\n\t\t\tFamilyType: unix.AF_INET,\n\t\t\tForward: IPTuple{\n\t\t\t\tSrcIP:    net.ParseIP(\"10.0.0.2\"),\n\t\t\t\tDstIP:    net.ParseIP(\"20.0.0.2\"),\n\t\t\t\tSrcPort:  5000,\n\t\t\t\tDstPort:  6000,\n\t\t\t\tProtocol: 6,\n\t\t\t},\n\t\t\tReverse: IPTuple{\n\t\t\t\tSrcIP:    net.ParseIP(\"20.0.0.2\"),\n\t\t\t\tDstIP:    net.ParseIP(\"192.168.1.1\"),\n\t\t\t\tSrcPort:  6000,\n\t\t\t\tDstPort:  5000,\n\t\t\t\tProtocol: 6,\n\t\t\t},\n\t\t\tLabels: []byte{0, 0, 0, 0, 3, 4, 61, 141, 207, 170, 2, 0, 0, 0, 0, 0},\n\t\t\tZone:   200,\n\t\t},\n\t\tConntrackFlow{\n\t\t\tFamilyType: unix.AF_INET6,\n\t\t\tForward: IPTuple{\n\t\t\t\tSrcIP:    net.ParseIP(\"eeee:eeee:eeee:eeee:eeee:eeee:eeee:eeee\"),\n\t\t\t\tDstIP:    net.ParseIP(\"dddd:dddd:dddd:dddd:dddd:dddd:dddd:dddd\"),\n\t\t\t\tSrcPort:  1000,\n\t\t\t\tDstPort:  2000,\n\t\t\t\tProtocol: 132,\n\t\t\t},\n\t\t\tReverse: IPTuple{\n\t\t\t\tSrcIP:    net.ParseIP(\"dddd:dddd:dddd:dddd:dddd:dddd:dddd:dddd\"),\n\t\t\t\tDstIP:    net.ParseIP(\"eeee:eeee:eeee:eeee:eeee:eeee:eeee:eeee\"),\n\t\t\t\tSrcPort:  2000,\n\t\t\t\tDstPort:  1000,\n\t\t\t\tProtocol: 132,\n\t\t\t},\n\t\t\tZone: 200,\n\t\t})\n\n\t// Empty filter\n\tv4Match, v6Match := applyFilter(flowList, &ConntrackFilter{}, &ConntrackFilter{})\n\tif v4Match > 0 || v6Match > 0 {\n\t\tt.Fatalf(\"Error, empty filter cannot match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// Filter errors\n\n\t// Adding same attribute should fail\n\tfilter := &ConntrackFilter{}\n\terr := filter.AddIP(ConntrackOrigSrcIP, net.ParseIP(\"10.0.0.1\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\tif err := filter.AddIP(ConntrackOrigSrcIP, net.ParseIP(\"10.0.0.1\")); err == nil {\n\t\tt.Fatalf(\"Error, it should fail adding same attribute to the filter\")\n\t}\n\terr = filter.AddProtocol(6)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\tif err := filter.AddProtocol(17); err == nil {\n\t\tt.Fatalf(\"Error, it should fail adding same attribute to the filter\")\n\t}\n\tfilter.AddPort(ConntrackOrigSrcPort, 80)\n\tif err := filter.AddPort(ConntrackOrigSrcPort, 80); err == nil {\n\t\tt.Fatalf(\"Error, it should fail adding same attribute to the filter\")\n\t}\n\n\t// Can not add a Port filter without Layer 4 protocol\n\tfilter = &ConntrackFilter{}\n\tif err := filter.AddPort(ConntrackOrigSrcPort, 80); err == nil {\n\t\tt.Fatalf(\"Error, it should fail adding a port filter without a protocol\")\n\t}\n\n\t// Can not add a Port filter if the Layer 4 protocol does not support it\n\tfilter = &ConntrackFilter{}\n\terr = filter.AddProtocol(47)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\tif err := filter.AddPort(ConntrackOrigSrcPort, 80); err == nil {\n\t\tt.Fatalf(\"Error, it should fail adding a port filter with a wrong protocol\")\n\t}\n\n\t// Proto filter\n\tfilterV4 := &ConntrackFilter{}\n\terr = filterV4.AddProtocol(6)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 := &ConntrackFilter{}\n\terr = filterV6.AddProtocol(132)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 1 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be only 1 match for TCP:%d, UDP:%d\", v4Match, v6Match)\n\t}\n\n\t// SrcIP filter\n\tfilterV4 = &ConntrackFilter{}\n\terr = filterV4.AddIP(ConntrackOrigSrcIP, net.ParseIP(\"10.0.0.1\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\terr = filterV6.AddIP(ConntrackOrigSrcIP, net.ParseIP(\"eeee:eeee:eeee:eeee:eeee:eeee:eeee:eeee\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 1 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// DstIp filter\n\tfilterV4 = &ConntrackFilter{}\n\terr = filterV4.AddIP(ConntrackOrigDstIP, net.ParseIP(\"20.0.0.1\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\terr = filterV6.AddIP(ConntrackOrigDstIP, net.ParseIP(\"dddd:dddd:dddd:dddd:dddd:dddd:dddd:dddd\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 1 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// SrcIP for NAT\n\tfilterV4 = &ConntrackFilter{}\n\terr = filterV4.AddIP(ConntrackReplySrcIP, net.ParseIP(\"20.0.0.1\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\terr = filterV6.AddIP(ConntrackReplySrcIP, net.ParseIP(\"dddd:dddd:dddd:dddd:dddd:dddd:dddd:dddd\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 1 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// DstIP for NAT\n\tfilterV4 = &ConntrackFilter{}\n\terr = filterV4.AddIP(ConntrackReplyDstIP, net.ParseIP(\"192.168.1.1\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\terr = filterV6.AddIP(ConntrackReplyDstIP, net.ParseIP(\"dddd:dddd:dddd:dddd:dddd:dddd:dddd:dddd\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 2 || v6Match != 0 {\n\t\tt.Fatalf(\"Error, there should be an exact match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// AnyIp for Nat\n\tfilterV4 = &ConntrackFilter{}\n\terr = filterV4.AddIP(ConntrackReplyAnyIP, net.ParseIP(\"192.168.1.1\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\terr = filterV6.AddIP(ConntrackReplyAnyIP, net.ParseIP(\"eeee:eeee:eeee:eeee:eeee:eeee:eeee:eeee\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 2 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be an exact match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// SrcIPNet filter\n\tfilterV4 = &ConntrackFilter{}\n\tipNet, err := ParseIPNet(\"10.0.0.0/12\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV4.AddIPNet(ConntrackOrigSrcIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\tipNet, err = ParseIPNet(\"eeee:eeee:eeee:eeee::/64\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV6.AddIPNet(ConntrackOrigSrcIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 2 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// DstIpNet filter\n\tfilterV4 = &ConntrackFilter{}\n\tipNet, err = ParseIPNet(\"20.0.0.0/12\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV4.AddIPNet(ConntrackOrigDstIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\tipNet, err = ParseIPNet(\"dddd:dddd:dddd:dddd::/64\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV6.AddIPNet(ConntrackOrigDstIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 2 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// SrcIPNet for NAT\n\tfilterV4 = &ConntrackFilter{}\n\tipNet, err = ParseIPNet(\"20.0.0.0/12\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV4.AddIPNet(ConntrackReplySrcIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\tipNet, err = ParseIPNet(\"dddd:dddd:dddd:dddd::/64\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV6.AddIPNet(ConntrackReplySrcIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 2 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// DstIPNet for NAT\n\tfilterV4 = &ConntrackFilter{}\n\tipNet, err = ParseIPNet(\"192.168.0.0/12\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV4.AddIPNet(ConntrackReplyDstIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\tipNet, err = ParseIPNet(\"dddd:dddd:dddd:dddd::/64\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV6.AddIPNet(ConntrackReplyDstIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 2 || v6Match != 0 {\n\t\tt.Fatalf(\"Error, there should be an exact match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// AnyIpNet for Nat\n\tfilterV4 = &ConntrackFilter{}\n\tipNet, err = ParseIPNet(\"192.168.0.0/12\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV4.AddIPNet(ConntrackReplyAnyIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\tipNet, err = ParseIPNet(\"eeee:eeee:eeee:eeee::/64\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV6.AddIPNet(ConntrackReplyAnyIP, ipNet)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 2 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be an exact match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\t// SrcPort filter\n\tfilterV4 = &ConntrackFilter{}\n\terr = filterV4.AddProtocol(6)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV4.AddPort(ConntrackOrigSrcPort, 5000)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\terr = filterV6.AddProtocol(132)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV6.AddPort(ConntrackOrigSrcPort, 1000)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 1 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// DstPort filter\n\tfilterV4 = &ConntrackFilter{}\n\terr = filterV4.AddProtocol(6)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV4.AddPort(ConntrackOrigDstPort, 6000)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\terr = filterV6.AddProtocol(132)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\terr = filterV6.AddPort(ConntrackOrigDstPort, 2000)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 1 || v6Match != 1 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\t// Labels filter\n\tfilterV4 = &ConntrackFilter{}\n\tvar labels [][]byte\n\tlabels = append(labels, []byte{3, 4, 61, 141, 207, 170})\n\tlabels = append(labels, []byte{0x2})\n\terr = filterV4.AddLabels(ConntrackMatchLabels, labels)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tfilterV6 = &ConntrackFilter{}\n\terr = filterV6.AddLabels(ConntrackUnmatchLabels, labels)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 1 || v6Match != 0 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n\n\tfilterV4 = &ConntrackFilter{}\n\terr = filterV4.AddZone(200)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\tfilterV6 = &ConntrackFilter{}\n\tv4Match, v6Match = applyFilter(flowList, filterV4, filterV6)\n\tif v4Match != 2 || v6Match != 0 {\n\t\tt.Fatalf(\"Error, there should be only 1 match, v4:%d, v6:%d\", v4Match, v6Match)\n\t}\n}\n\nfunc TestParseRawData(t *testing.T) {\n\tif nl.NativeEndian() == binary.BigEndian {\n\t\tt.Skip(\"testdata expect little-endian test executor\")\n\t}\n\tos.Setenv(\"TZ\", \"\") // print timestamps in UTC\n\ttests := []struct {\n\t\ttestname         string\n\t\trawData          []byte\n\t\texpConntrackFlow string\n\t}{\n\t\t{\n\t\t\ttestname: \"UDP conntrack\",\n\t\t\trawData: []byte{\n\t\t\t\t/* Nfgenmsg header */\n\t\t\t\t2, 0, 0, 0,\n\t\t\t\t/* >> nested CTA_TUPLE_ORIG */\n\t\t\t\t52, 0, 1, 128,\n\t\t\t\t/* >>>> nested CTA_TUPLE_IP */\n\t\t\t\t20, 0, 1, 128,\n\t\t\t\t/* >>>>>> CTA_IP_V4_SRC */\n\t\t\t\t8, 0, 1, 0,\n\t\t\t\t192, 168, 0, 10,\n\t\t\t\t/* >>>>>> CTA_IP_V4_DST */\n\t\t\t\t8, 0, 2, 0,\n\t\t\t\t192, 168, 0, 3,\n\t\t\t\t/* >>>>>> nested proto info */\n\t\t\t\t28, 0, 2, 128,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_NUM */\n\t\t\t\t5, 0, 1, 0,\n\t\t\t\t17, 0, 0, 0,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_SRC_PORT */\n\t\t\t\t6, 0, 2, 0,\n\t\t\t\t189, 1, 0, 0,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_DST_PORT */\n\t\t\t\t6, 0, 3, 0,\n\t\t\t\t0, 53, 0, 0,\n\t\t\t\t/* >> CTA_TUPLE_REPLY */\n\t\t\t\t52, 0, 2, 128,\n\t\t\t\t/* >>>> nested CTA_TUPLE_IP */\n\t\t\t\t20, 0, 1, 128,\n\t\t\t\t/* >>>>>> CTA_IP_V4_SRC */\n\t\t\t\t8, 0, 1, 0,\n\t\t\t\t192, 168, 0, 3,\n\t\t\t\t/* >>>>>> CTA_IP_V4_DST */\n\t\t\t\t8, 0, 2, 0,\n\t\t\t\t192, 168, 0, 10,\n\t\t\t\t/* >>>>>> nested proto info */\n\t\t\t\t28, 0, 2, 128,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_NUM */\n\t\t\t\t5, 0, 1, 0,\n\t\t\t\t17, 0, 0, 0,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_SRC_PORT */\n\t\t\t\t6, 0, 2, 0,\n\t\t\t\t0, 53, 0, 0,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_DST_PORT */\n\t\t\t\t6, 0, 3, 0,\n\t\t\t\t189, 1, 0, 0,\n\t\t\t\t/* >> CTA_STATUS */\n\t\t\t\t8, 0, 3, 0,\n\t\t\t\t0, 0, 1, 138,\n\t\t\t\t/* >> CTA_MARK */\n\t\t\t\t8, 0, 8, 0,\n\t\t\t\t0, 0, 0, 5,\n\t\t\t\t/* >> CTA_ID */\n\t\t\t\t8, 0, 12, 0,\n\t\t\t\t81, 172, 253, 151,\n\t\t\t\t/* >> CTA_USE */\n\t\t\t\t8, 0, 11, 0,\n\t\t\t\t0, 0, 0, 1,\n\t\t\t\t/* >> CTA_TIMEOUT */\n\t\t\t\t8, 0, 7, 0,\n\t\t\t\t0, 0, 0, 32,\n\t\t\t\t/* >> nested CTA_COUNTERS_ORIG */\n\t\t\t\t28, 0, 9, 128,\n\t\t\t\t/* >>>> CTA_COUNTERS_PACKETS */\n\t\t\t\t12, 0, 1, 0,\n\t\t\t\t0, 0, 0, 0, 0, 0, 0, 1,\n\t\t\t\t/* >>>> CTA_COUNTERS_BYTES */\n\t\t\t\t12, 0, 2, 0,\n\t\t\t\t0, 0, 0, 0, 0, 0, 0, 55,\n\t\t\t\t/* >> nested CTA_COUNTERS_REPLY */\n\t\t\t\t28, 0, 10, 128,\n\t\t\t\t/* >>>> CTA_COUNTERS_PACKETS */\n\t\t\t\t12, 0, 1, 0,\n\t\t\t\t0, 0, 0, 0, 0, 0, 0, 1,\n\t\t\t\t/* >>>> CTA_COUNTERS_BYTES */\n\t\t\t\t12, 0, 2, 0,\n\t\t\t\t0, 0, 0, 0, 0, 0, 0, 71,\n\t\t\t\t/* >> nested CTA_TIMESTAMP */\n\t\t\t\t16, 0, 20, 128,\n\t\t\t\t/* >>>> CTA_TIMESTAMP_START */\n\t\t\t\t12, 0, 1, 0,\n\t\t\t\t22, 134, 80, 142, 230, 127, 74, 166,\n\t\t\t\t/* >> CTA_LABELS */\n\t\t\t\t20, 0, 22, 0,\n\t\t\t\t0, 0, 0, 0, 5, 0, 18, 172, 66, 2, 1, 0, 0, 0, 0, 0},\n\t\t\texpConntrackFlow: \"udp\\t17 src=192.168.0.10 dst=192.168.0.3 sport=48385 dport=53 packets=1 bytes=55\\t\" +\n\t\t\t\t\"src=192.168.0.3 dst=192.168.0.10 sport=53 dport=48385 packets=1 bytes=71 mark=0x5 labels=0x00000000050012ac4202010000000000 \" +\n\t\t\t\t\"start=2021-06-07 13:41:30.39632247 +0000 UTC stop=1970-01-01 00:00:00 +0000 UTC timeout=32(sec)\",\n\t\t},\n\t\t{\n\t\t\ttestname: \"TCP conntrack\",\n\t\t\trawData: []byte{\n\t\t\t\t/* Nfgenmsg header */\n\t\t\t\t2, 0, 0, 0,\n\t\t\t\t/* >> nested CTA_TUPLE_ORIG */\n\t\t\t\t52, 0, 1, 128,\n\t\t\t\t/* >>>> nested CTA_TUPLE_IP */\n\t\t\t\t20, 0, 1, 128,\n\t\t\t\t/* >>>>>> CTA_IP_V4_SRC */\n\t\t\t\t8, 0, 1, 0,\n\t\t\t\t192, 168, 0, 10,\n\t\t\t\t/* >>>>>> CTA_IP_V4_DST */\n\t\t\t\t8, 0, 2, 0,\n\t\t\t\t192, 168, 77, 73,\n\t\t\t\t/* >>>>>> nested proto info */\n\t\t\t\t28, 0, 2, 128,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_NUM */\n\t\t\t\t5, 0, 1, 0,\n\t\t\t\t6, 0, 0, 0,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_SRC_PORT */\n\t\t\t\t6, 0, 2, 0,\n\t\t\t\t166, 129, 0, 0,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_DST_PORT */\n\t\t\t\t6, 0, 3, 0,\n\t\t\t\t13, 5, 0, 0,\n\t\t\t\t/* >> CTA_TUPLE_REPLY */\n\t\t\t\t52, 0, 2, 128,\n\t\t\t\t/* >>>> nested CTA_TUPLE_IP */\n\t\t\t\t20, 0, 1, 128,\n\t\t\t\t/* >>>>>> CTA_IP_V4_SRC */\n\t\t\t\t8, 0, 1, 0,\n\t\t\t\t192, 168, 77, 73,\n\t\t\t\t/* >>>>>> CTA_IP_V4_DST */\n\t\t\t\t8, 0, 2, 0,\n\t\t\t\t192, 168, 0, 10,\n\t\t\t\t/* >>>>>> nested proto info */\n\t\t\t\t28, 0, 2, 128,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_NUM */\n\t\t\t\t5, 0, 1, 0,\n\t\t\t\t6, 0, 0, 0,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_SRC_PORT */\n\t\t\t\t6, 0, 2, 0,\n\t\t\t\t13, 5, 0, 0,\n\t\t\t\t/* >>>>>>>> CTA_PROTO_DST_PORT */\n\t\t\t\t6, 0, 3, 0,\n\t\t\t\t166, 129, 0, 0,\n\t\t\t\t/* >> CTA_STATUS */\n\t\t\t\t8, 0, 3, 0,\n\t\t\t\t0, 0, 1, 142,\n\t\t\t\t/* >> CTA_MARK */\n\t\t\t\t8, 0, 8, 0,\n\t\t\t\t0, 0, 0, 5,\n\t\t\t\t/* >> CTA_ID */\n\t\t\t\t8, 0, 12, 0,\n\t\t\t\t177, 65, 179, 133,\n\t\t\t\t/* >> CTA_USE */\n\t\t\t\t8, 0, 11, 0,\n\t\t\t\t0, 0, 0, 1,\n\t\t\t\t/* >> CTA_TIMEOUT */\n\t\t\t\t8, 0, 7, 0,\n\t\t\t\t0, 0, 0, 152,\n\t\t\t\t/* >> CTA_PROTOINFO */\n\t\t\t\t48, 0, 4, 128,\n\t\t\t\t44, 0, 1, 128,\n\t\t\t\t5, 0, 1, 0, 8, 0, 0, 0,\n\t\t\t\t5, 0, 2, 0, 0, 0, 0, 0,\n\t\t\t\t5, 0, 3, 0, 0, 0, 0, 0,\n\t\t\t\t6, 0, 4, 0, 39, 0, 0, 0,\n\t\t\t\t6, 0, 5, 0, 32, 0, 0, 0,\n\t\t\t\t/* >> nested CTA_COUNTERS_ORIG */\n\t\t\t\t28, 0, 9, 128,\n\t\t\t\t/* >>>> CTA_COUNTERS_PACKETS */\n\t\t\t\t12, 0, 1, 0,\n\t\t\t\t0, 0, 0, 0, 0, 0, 0, 11,\n\t\t\t\t/* >>>> CTA_COUNTERS_BYTES */\n\t\t\t\t12, 0, 2, 0,\n\t\t\t\t0, 0, 0, 0, 0, 0, 7, 122,\n\t\t\t\t/* >> nested CTA_COUNTERS_REPLY */\n\t\t\t\t28, 0, 10, 128,\n\t\t\t\t/* >>>> CTA_COUNTERS_PACKETS */\n\t\t\t\t12, 0, 1, 0,\n\t\t\t\t0, 0, 0, 0, 0, 0, 0, 10,\n\t\t\t\t/* >>>> CTA_COUNTERS_BYTES */\n\t\t\t\t12, 0, 2, 0,\n\t\t\t\t0, 0, 0, 0, 0, 0, 7, 66,\n\t\t\t\t/* >> CTA_ZONE */\n\t\t\t\t8, 0, 18, 0,\n\t\t\t\t0, 100, 0, 0,\n\t\t\t\t/* >> nested CTA_TIMESTAMP */\n\t\t\t\t16, 0, 20, 128,\n\t\t\t\t/* >>>> CTA_TIMESTAMP_START */\n\t\t\t\t12, 0, 1, 0,\n\t\t\t\t22, 134, 80, 175, 134, 10, 182, 221},\n\t\t\texpConntrackFlow: \"tcp\\t6 src=192.168.0.10 dst=192.168.77.73 sport=42625 dport=3333 packets=11 bytes=1914\\t\" +\n\t\t\t\t\"src=192.168.77.73 dst=192.168.0.10 sport=3333 dport=42625 packets=10 bytes=1858 mark=0x5 zone=100 \" +\n\t\t\t\t\"start=2021-06-07 13:43:50.511990493 +0000 UTC stop=1970-01-01 00:00:00 +0000 UTC timeout=152(sec)\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.testname, func(t *testing.T) {\n\t\t\tconntrackFlow := parseRawData(test.rawData)\n\t\t\tif conntrackFlow.String() != test.expConntrackFlow {\n\t\t\t\tt.Errorf(\"expected conntrack flow:\\n\\t%q\\ngot conntrack flow:\\n\\t%q\",\n\t\t\t\t\ttest.expConntrackFlow, conntrackFlow)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestConntrackUpdateV4 first tries to update a non-existant IPv4 conntrack and asserts that an error occurs.\n// It then creates a conntrack entry using and adjacent API method (ConntrackCreate), and attempts to update the value of the created conntrack.\nfunc TestConntrackUpdateV4(t *testing.T) {\n\t// Print timestamps in UTC\n\tos.Setenv(\"TZ\", \"\")\n\n\trequiredModules := []string{\"nf_conntrack\", \"nf_conntrack_netlink\"}\n\tk, m, err := KernelVersion()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Conntrack l3proto was unified since 4.19\n\t// https://github.com/torvalds/linux/commit/a0ae2562c6c4b2721d9fddba63b7286c13517d9f\n\tif k < 4 || k == 4 && m < 19 {\n\t\trequiredModules = append(requiredModules, \"nf_conntrack_ipv4\")\n\t}\n\t// Implicitly skips test if not root:\n\tnsStr, teardown := setUpNamedNetlinkTestWithKModule(t, requiredModules...)\n\tdefer teardown()\n\n\tns, err := netns.GetFromName(nsStr)\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't get handle to generated namespace: %s\", err)\n\t}\n\n\th, err := NewHandleAt(ns, nl.FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create netlink handle: %s\", err)\n\t}\n\n\tflow := ConntrackFlow{\n\t\tFamilyType: FAMILY_V4,\n\t\tForward: IPTuple{\n\t\t\tSrcIP: net.IP{234,234,234,234},\n\t\t\tDstIP: net.IP{123,123,123,123},\n\t\t\tSrcPort: 48385,\n\t\t\tDstPort: 53,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\tReverse: IPTuple{\n\t\t\tSrcIP: net.IP{123,123,123,123},\n\t\t\tDstIP: net.IP{234,234,234,234},\n\t\t\tSrcPort: 53,\n\t\t\tDstPort: 48385,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\t// No point checking equivalence of timeout, but value must\n\t\t// be reasonable to allow for a potentially slow subsequent read.\n\t\tTimeOut:   100,\n\t\tMark: 12,\n\t\tProtoInfo: &ProtoInfoTCP{\n\t\t\tState: nl.TCP_CONNTRACK_SYN_SENT2,\n\t\t},\n\t}\n\n\terr = h.ConntrackUpdate(ConntrackTable, nl.FAMILY_V4, &flow)\n\tif err == nil {\n\t\tt.Fatalf(\"expected an error to occur when trying to update a non-existant conntrack: %+v\", flow)\n\t}\n\n\terr = h.ConntrackCreate(ConntrackTable, nl.FAMILY_V4, &flow)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to insert conntrack: %s\", err)\n\t}\n\n\tflows, err := h.ConntrackTableList(ConntrackTable, nl.FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to list conntracks following successful insert: %s\", err)\n\t}\n\n\tfilter := ConntrackFilter{\n\t\tipNetFilter: map[ConntrackFilterType]*net.IPNet{\n\t\t\tConntrackOrigSrcIP: NewIPNet(flow.Forward.SrcIP),\n\t\t\tConntrackOrigDstIP: NewIPNet(flow.Forward.DstIP),\n\t\t\tConntrackReplySrcIP: NewIPNet(flow.Reverse.SrcIP),\n\t\t\tConntrackReplyDstIP: NewIPNet(flow.Reverse.DstIP),\n\t\t},\n\t\tportFilter: map[ConntrackFilterType]uint16{\n\t\t\tConntrackOrigSrcPort: flow.Forward.SrcPort,\n\t\t\tConntrackOrigDstPort: flow.Forward.DstPort,\n\t\t},\n\t\tprotoFilter:unix.IPPROTO_TCP,\n\t}\n\n\tvar match *ConntrackFlow\n\tfor _, f := range flows {\n\t\tif filter.MatchConntrackFlow(f) {\n\t\t\tmatch = f\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif match == nil {\n\t\tt.Fatalf(\"Didn't find any matching conntrack entries for original flow: %+v\\n Filter used: %+v\", flow, filter)\n\t} else {\n\t\tt.Logf(\"Found entry in conntrack table matching original flow: %+v labels=%+v\", match, match.Labels)\n\t}\n\tcheckFlowsEqual(t, &flow, match)\n\tcheckProtoInfosEqual(t, flow.ProtoInfo, match.ProtoInfo)\n\n\t// Change the conntrack and update the kernel entry.\n\tflow.Mark = 10\n\tflow.ProtoInfo = &ProtoInfoTCP{\n\t\tState: nl.TCP_CONNTRACK_ESTABLISHED,\n\t}\n\terr = h.ConntrackUpdate(ConntrackTable, nl.FAMILY_V4, &flow)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to update conntrack with new mark: %s\", err)\n\t}\n\n\t// Look for updated conntrack.\n\tflows, err = h.ConntrackTableList(ConntrackTable, nl.FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to list conntracks following successful update: %s\", err)\n\t}\n\n\tvar updatedMatch *ConntrackFlow\n\tfor _, f := range flows {\n\t\tif filter.MatchConntrackFlow(f) {\n\t\t\tupdatedMatch = f\n\t\t\tbreak\n\t\t}\n\t}\n\tif updatedMatch == nil {\n\t\tt.Fatalf(\"Didn't find any matching conntrack entries for updated flow: %+v\\n Filter used: %+v\", flow, filter)\n\t} else {\n\t\tt.Logf(\"Found entry in conntrack table matching updated flow: %+v labels=%+v\", updatedMatch, updatedMatch.Labels)\n\t}\n\n\tcheckFlowsEqual(t, &flow, updatedMatch)\n\tcheckProtoInfosEqual(t, flow.ProtoInfo, updatedMatch.ProtoInfo)\n}\n\n// TestConntrackUpdateV6 first tries to update a non-existant IPv6 conntrack and asserts that an error occurs.\n// It then creates a conntrack entry using and adjacent API method (ConntrackCreate), and attempts to update the value of the created conntrack.\nfunc TestConntrackUpdateV6(t *testing.T) {\n\t// Print timestamps in UTC\n\tos.Setenv(\"TZ\", \"\")\n\n\trequiredModules := []string{\"nf_conntrack\", \"nf_conntrack_netlink\"}\n\tk, m, err := KernelVersion()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Conntrack l3proto was unified since 4.19\n\t// https://github.com/torvalds/linux/commit/a0ae2562c6c4b2721d9fddba63b7286c13517d9f\n\tif k < 4 || k == 4 && m < 19 {\n\t\trequiredModules = append(requiredModules, \"nf_conntrack_ipv4\")\n\t}\n\t// Implicitly skips test if not root:\n\tnsStr, teardown := setUpNamedNetlinkTestWithKModule(t, requiredModules...)\n\tdefer teardown()\n\n\tns, err := netns.GetFromName(nsStr)\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't get handle to generated namespace: %s\", err)\n\t}\n\n\th, err := NewHandleAt(ns, nl.FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create netlink handle: %s\", err)\n\t}\n\n\tflow := ConntrackFlow{\n\t\tFamilyType: FAMILY_V6,\n\t\tForward: IPTuple{\n\t\t\tSrcIP: net.ParseIP(\"2001:db8::68\"),\n\t\t\tDstIP: net.ParseIP(\"2001:db9::32\"),\n\t\t\tSrcPort: 48385,\n\t\t\tDstPort: 53,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\tReverse: IPTuple{\n\t\t\tSrcIP: net.ParseIP(\"2001:db9::32\"),\n\t\t\tDstIP: net.ParseIP(\"2001:db8::68\"),\n\t\t\tSrcPort: 53,\n\t\t\tDstPort: 48385,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\t// No point checking equivalence of timeout, but value must\n\t\t// be reasonable to allow for a potentially slow subsequent read.\n\t\tTimeOut:   100,\n\t\tMark: 12,\n\t\tProtoInfo: &ProtoInfoTCP{\n\t\t\tState: nl.TCP_CONNTRACK_SYN_SENT2,\n\t\t},\n\t}\n\n\terr = h.ConntrackUpdate(ConntrackTable, nl.FAMILY_V6, &flow)\n\tif err == nil {\n\t\tt.Fatalf(\"expected an error to occur when trying to update a non-existant conntrack: %+v\", flow)\n\t}\n\n\terr = h.ConntrackCreate(ConntrackTable, nl.FAMILY_V6, &flow)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to insert conntrack: %s\", err)\n\t}\n\n\tflows, err := h.ConntrackTableList(ConntrackTable, nl.FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to list conntracks following successful insert: %s\", err)\n\t}\n\n\tfilter := ConntrackFilter{\n\t\tipNetFilter: map[ConntrackFilterType]*net.IPNet{\n\t\t\tConntrackOrigSrcIP: NewIPNet(flow.Forward.SrcIP),\n\t\t\tConntrackOrigDstIP: NewIPNet(flow.Forward.DstIP),\n\t\t\tConntrackReplySrcIP: NewIPNet(flow.Reverse.SrcIP),\n\t\t\tConntrackReplyDstIP: NewIPNet(flow.Reverse.DstIP),\n\t\t},\n\t\tportFilter: map[ConntrackFilterType]uint16{\n\t\t\tConntrackOrigSrcPort: flow.Forward.SrcPort,\n\t\t\tConntrackOrigDstPort: flow.Forward.DstPort,\n\t\t},\n\t\tprotoFilter:unix.IPPROTO_TCP,\n\t}\n\n\tvar match *ConntrackFlow\n\tfor _, f := range flows {\n\t\tif filter.MatchConntrackFlow(f) {\n\t\t\tmatch = f\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif match == nil {\n\t\tt.Fatalf(\"didn't find any matching conntrack entries for original flow: %+v\\n Filter used: %+v\", flow, filter)\n\t} else {\n\t\tt.Logf(\"found entry in conntrack table matching original flow: %+v labels=%+v\", match, match.Labels)\n\t}\n\tcheckFlowsEqual(t, &flow, match)\n\tcheckProtoInfosEqual(t, flow.ProtoInfo, match.ProtoInfo)\n\n\t// Change the conntrack and update the kernel entry.\n\tflow.Mark = 10\n\tflow.ProtoInfo = &ProtoInfoTCP{\n\t\tState: nl.TCP_CONNTRACK_ESTABLISHED,\n\t}\n\terr = h.ConntrackUpdate(ConntrackTable, nl.FAMILY_V6, &flow)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to update conntrack with new mark: %s\", err)\n\t}\n\n\t// Look for updated conntrack.\n\tflows, err = h.ConntrackTableList(ConntrackTable, nl.FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to list conntracks following successful update: %s\", err)\n\t}\n\n\tvar updatedMatch *ConntrackFlow\n\tfor _, f := range flows {\n\t\tif filter.MatchConntrackFlow(f) {\n\t\t\tupdatedMatch = f\n\t\t\tbreak\n\t\t}\n\t}\n\tif updatedMatch == nil {\n\t\tt.Fatalf(\"didn't find any matching conntrack entries for updated flow: %+v\\n Filter used: %+v\", flow, filter)\n\t} else {\n\t\tt.Logf(\"found entry in conntrack table matching updated flow: %+v labels=%+v\", updatedMatch, updatedMatch.Labels)\n\t}\n\n\tcheckFlowsEqual(t, &flow, updatedMatch)\n\tcheckProtoInfosEqual(t, flow.ProtoInfo, updatedMatch.ProtoInfo)\n}\n\nfunc TestConntrackCreateV4(t *testing.T) {\n\t// Print timestamps in UTC\n\tos.Setenv(\"TZ\", \"\")\n\n\trequiredModules := []string{\"nf_conntrack\", \"nf_conntrack_netlink\"}\n\tk, m, err := KernelVersion()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Conntrack l3proto was unified since 4.19\n\t// https://github.com/torvalds/linux/commit/a0ae2562c6c4b2721d9fddba63b7286c13517d9f\n\tif k < 4 || k == 4 && m < 19 {\n\t\trequiredModules = append(requiredModules, \"nf_conntrack_ipv4\")\n\t}\n\t// Implicitly skips test if not root:\n\tnsStr, teardown := setUpNamedNetlinkTestWithKModule(t, requiredModules...)\n\tdefer teardown()\n\n\tns, err := netns.GetFromName(nsStr)\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't get handle to generated namespace: %s\", err)\n\t}\n\n\th, err := NewHandleAt(ns, nl.FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create netlink handle: %s\", err)\n\t}\n\n\tflow := ConntrackFlow{\n\t\tFamilyType: FAMILY_V4,\n\t\tForward: IPTuple{\n\t\t\tSrcIP: net.IP{234,234,234,234},\n\t\t\tDstIP: net.IP{123,123,123,123},\n\t\t\tSrcPort: 48385,\n\t\t\tDstPort: 53,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\tReverse: IPTuple{\n\t\t\tSrcIP: net.IP{123,123,123,123},\n\t\t\tDstIP: net.IP{234,234,234,234},\n\t\t\tSrcPort: 53,\n\t\t\tDstPort: 48385,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\t// No point checking equivalence of timeout, but value must\n\t\t// be reasonable to allow for a potentially slow subsequent read.\n\t\tTimeOut:   100,\n\t\tMark: 12,\n\t\tProtoInfo: &ProtoInfoTCP{\n\t\t\tState: nl.TCP_CONNTRACK_ESTABLISHED,\n\t\t},\n\t}\n\n\terr = h.ConntrackCreate(ConntrackTable, nl.FAMILY_V4, &flow)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to insert conntrack: %s\", err)\n\t}\n\n\tflows, err := h.ConntrackTableList(ConntrackTable, nl.FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to list conntracks following successful insert: %s\", err)\n\t}\n\n\tfilter := ConntrackFilter{\n\t\tipNetFilter: map[ConntrackFilterType]*net.IPNet{\n\t\t\tConntrackOrigSrcIP: NewIPNet(flow.Forward.SrcIP),\n\t\t\tConntrackOrigDstIP: NewIPNet(flow.Forward.DstIP),\n\t\t\tConntrackReplySrcIP: NewIPNet(flow.Reverse.SrcIP),\n\t\t\tConntrackReplyDstIP: NewIPNet(flow.Reverse.DstIP),\n\t\t},\n\t\tportFilter: map[ConntrackFilterType]uint16{\n\t\t\tConntrackOrigSrcPort: flow.Forward.SrcPort,\n\t\t\tConntrackOrigDstPort: flow.Forward.DstPort,\n\t\t},\n\t\tprotoFilter:unix.IPPROTO_TCP,\n\t}\n\n\tvar match *ConntrackFlow\n\tfor _, f := range flows {\n\t\tif filter.MatchConntrackFlow(f) {\n\t\t\tmatch = f\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif match == nil {\n\t\tt.Fatalf(\"didn't find any matching conntrack entries for original flow: %+v\\n Filter used: %+v\", flow, filter)\n\t} else {\n\t\tt.Logf(\"Found entry in conntrack table matching original flow: %+v labels=%+v\", match, match.Labels)\n\t}\n\n\tcheckFlowsEqual(t, &flow, match)\n\tcheckProtoInfosEqual(t, flow.ProtoInfo, match.ProtoInfo)\n}\n\nfunc TestConntrackCreateV6(t *testing.T) {\n\t// Print timestamps in UTC\n\tos.Setenv(\"TZ\", \"\")\n\n\trequiredModules := []string{\"nf_conntrack\", \"nf_conntrack_netlink\"}\n\tk, m, err := KernelVersion()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Conntrack l3proto was unified since 4.19\n\t// https://github.com/torvalds/linux/commit/a0ae2562c6c4b2721d9fddba63b7286c13517d9f\n\tif k < 4 || k == 4 && m < 19 {\n\t\trequiredModules = append(requiredModules, \"nf_conntrack_ipv4\")\n\t}\n\t// Implicitly skips test if not root:\n\tnsStr, teardown := setUpNamedNetlinkTestWithKModule(t, requiredModules...)\n\tdefer teardown()\n\n\tns, err := netns.GetFromName(nsStr)\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't get handle to generated namespace: %s\", err)\n\t}\n\n\th, err := NewHandleAt(ns, nl.FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create netlink handle: %s\", err)\n\t}\n\n\tflow := ConntrackFlow{\n\t\tFamilyType: FAMILY_V6,\n\t\tForward: IPTuple{\n\t\t\tSrcIP: net.ParseIP(\"2001:db8::68\"),\n\t\t\tDstIP: net.ParseIP(\"2001:db9::32\"),\n\t\t\tSrcPort: 48385,\n\t\t\tDstPort: 53,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\tReverse: IPTuple{\n\t\t\tSrcIP: net.ParseIP(\"2001:db9::32\"),\n\t\t\tDstIP: net.ParseIP(\"2001:db8::68\"),\n\t\t\tSrcPort: 53,\n\t\t\tDstPort: 48385,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\t// No point checking equivalence of timeout, but value must\n\t\t// be reasonable to allow for a potentially slow subsequent read.\n\t\tTimeOut:    100,\n\t\tMark: 12,\n\t\tProtoInfo: &ProtoInfoTCP{\n\t\t\tState: nl.TCP_CONNTRACK_ESTABLISHED,\n\t\t},\n\t}\n\n\terr = h.ConntrackCreate(ConntrackTable, nl.FAMILY_V6, &flow)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to insert conntrack: %s\", err)\n\t}\n\n\tflows, err := h.ConntrackTableList(ConntrackTable, nl.FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to list conntracks following successful insert: %s\", err)\n\t}\n\n\tfilter := ConntrackFilter{\n\t\tipNetFilter: map[ConntrackFilterType]*net.IPNet{\n\t\t\tConntrackOrigSrcIP: NewIPNet(flow.Forward.SrcIP),\n\t\t\tConntrackOrigDstIP: NewIPNet(flow.Forward.DstIP),\n\t\t\tConntrackReplySrcIP: NewIPNet(flow.Reverse.SrcIP),\n\t\t\tConntrackReplyDstIP: NewIPNet(flow.Reverse.DstIP),\n\t\t},\n\t\tportFilter: map[ConntrackFilterType]uint16{\n\t\t\tConntrackOrigSrcPort: flow.Forward.SrcPort,\n\t\t\tConntrackOrigDstPort: flow.Forward.DstPort,\n\t\t},\n\t\tprotoFilter:unix.IPPROTO_TCP,\n\t}\n\n\tvar match *ConntrackFlow\n\tfor _, f := range flows {\n\t\tif filter.MatchConntrackFlow(f) {\n\t\t\tmatch = f\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif match == nil {\n\t\tt.Fatalf(\"Didn't find any matching conntrack entries for original flow: %+v\\n Filter used: %+v\", flow, filter)\n\t} else {\n\t\tt.Logf(\"Found entry in conntrack table matching original flow: %+v labels=%+v\", match, match.Labels)\n\t}\n\n\t// Other fields are implicitly correct due to the filter/match logic.\n\tif match.Mark != flow.Mark {\n\t\tt.Logf(\"Matched kernel entry did not have correct mark. Kernel: %d, Expected: %d\", flow.Mark, match.Mark)\n\t\tt.Fail()\n\t}\n\tcheckProtoInfosEqual(t, flow.ProtoInfo, match.ProtoInfo)\n}\n\n// TestConntrackFlowToNlData generates a serialized representation of a\n// ConntrackFlow and runs the resulting bytes back through `parseRawData` to validate.\nfunc TestConntrackFlowToNlData(t *testing.T) {\n\tflowV4 := ConntrackFlow{\n\t\tFamilyType: FAMILY_V4,\n\t\tForward: IPTuple{\n\t\t\tSrcIP: net.IP{234,234,234,234},\n\t\t\tDstIP: net.IP{123,123,123,123},\n\t\t\tSrcPort: 48385,\n\t\t\tDstPort: 53,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\tReverse: IPTuple{\n\t\t\tSrcIP: net.IP{123,123,123,123},\n\t\t\tDstIP: net.IP{234,234,234,234},\n\t\t\tSrcPort: 53,\n\t\t\tDstPort: 48385,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\tMark: 5,\n\t\tTimeOut:    10,\n\t\tProtoInfo: &ProtoInfoTCP{\n\t\t\tState: nl.TCP_CONNTRACK_ESTABLISHED,\n\t\t},\n\t}\n\tflowV6 := ConntrackFlow\t{\n\t\tFamilyType: FAMILY_V6,\n\t\tForward: IPTuple{\n\t\t\t\tSrcIP: net.ParseIP(\"2001:db8::68\"),\n\t\t\t\tDstIP: net.ParseIP(\"2001:db9::32\"),\n\t\t\t\tSrcPort: 48385,\n\t\t\t\tDstPort: 53,\n\t\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\tReverse: IPTuple{\n\t\t\tSrcIP: net.ParseIP(\"2001:db9::32\"),\n\t\t\tDstIP: net.ParseIP(\"2001:db8::68\"),\n\t\t\tSrcPort: 53,\n\t\t\tDstPort: 48385,\n\t\t\tProtocol: unix.IPPROTO_TCP,\n\t\t},\n\t\tMark: 5,\n\t\tTimeOut:    10,\n\t\tProtoInfo: &ProtoInfoTCP{\n\t\t\tState: nl.TCP_CONNTRACK_ESTABLISHED,\n\t\t},\n\t}\n\n\tvar bytesV4, bytesV6 []byte\n\n\tattrsV4, err := flowV4.toNlData()\n\tif err != nil {\n\t\tt.Fatalf(\"Error converting ConntrackFlow to netlink messages: %s\", err)\n\t}\n\t// Mock nfgenmsg header\n\tbytesV4 = append(bytesV4, flowV4.FamilyType,0,0,0)\n\tfor _, a := range attrsV4 {\n\t\tbytesV4 = append(bytesV4, a.Serialize()...)\n\t}\n\n\tattrsV6, err := flowV6.toNlData()\n\tif err != nil {\n\t\tt.Fatalf(\"Error converting ConntrackFlow to netlink messages: %s\", err)\n\t}\n\t// Mock nfgenmsg header\n\tbytesV6 = append(bytesV6, flowV6.FamilyType,0,0,0)\n\tfor _, a := range attrsV6 {\n\t\tbytesV6 = append(bytesV6, a.Serialize()...)\n\t}\n\n\tparsedFlowV4 := parseRawData(bytesV4)\n\tcheckFlowsEqual(t, &flowV4, parsedFlowV4)\n\tcheckProtoInfosEqual(t, flowV4.ProtoInfo, parsedFlowV4.ProtoInfo)\n\n\tparsedFlowV6 := parseRawData(bytesV6)\n\tcheckFlowsEqual(t, &flowV6, parsedFlowV6)\n\tcheckProtoInfosEqual(t, flowV6.ProtoInfo, parsedFlowV6.ProtoInfo)\n}\n\nfunc checkFlowsEqual(t *testing.T, f1, f2 *ConntrackFlow) {\n\t// No point checking timeout as it will differ between reads.\n\t// Timestart and timestop may also differ.\n\tif f1.FamilyType != f2.FamilyType {\n\t\tt.Logf(\"Conntrack flow FamilyTypes differ. Tuple1: %d, Tuple2: %d.\\n\", f1.FamilyType, f2.FamilyType)\n\t\tt.Fail()\n\t}\n\tif f1.Mark != f2.Mark {\n\t\tt.Logf(\"Conntrack flow Marks differ. Tuple1: %d, Tuple2: %d.\\n\", f1.Mark, f2.Mark)\n\t\tt.Fail()\n\t}\n\tif !tuplesEqual(f1.Forward, f2.Forward) {\n\t\tt.Logf(\"Forward tuples mismatch. Tuple1 forward flow: %+v, Tuple2 forward flow: %+v.\\n\", f1.Forward, f2.Forward)\n\t\tt.Fail()\n\t}\n\tif !tuplesEqual(f1.Reverse, f2.Reverse) {\n\t\tt.Logf(\"Reverse tuples mismatch. Tuple1 reverse flow: %+v, Tuple2 reverse flow: %+v.\\n\", f1.Reverse, f2.Reverse)\n\t\tt.Fail()\n\t}\n}\n\nfunc checkProtoInfosEqual(t *testing.T, p1, p2 ProtoInfo) {\n\tt.Logf(\"Checking protoinfo fields equal:\\n\\t p1: %+v\\n\\t p2: %+v\", p1, p2)\n\tif !protoInfosEqual(p1, p2) {\n\t\tt.Logf(\"Protoinfo structs differ: P1: %+v, P2: %+v\", p1, p2)\n\t\tt.Fail()\n\t}\n}\n\nfunc protoInfosEqual(p1, p2 ProtoInfo) bool {\n\tif p1 == nil {\n\t\treturn p2 == nil\n\t} else if p2 != nil {\n\t\treturn p1.Protocol() == p2.Protocol()\n\t}\n\n\treturn false\n}\n\nfunc tuplesEqual(t1, t2 IPTuple) bool {\n\tif t1.Bytes != t2.Bytes {\n\t\treturn false\n\t}\n\n\tif !t1.DstIP.Equal(t2.DstIP) {\n\t\treturn false\n\t}\n\n\tif !t1.SrcIP.Equal(t2.SrcIP) {\n\t\treturn false\n\t}\n\n\tif t1.DstPort != t2.DstPort {\n\t\treturn false\n\t}\n\n\tif t1.SrcPort != t2.SrcPort {\n\t\treturn false\n\t}\n\n\tif t1.Packets != t2.Packets {\n\t\treturn false\n\t}\n\n\tif t1.Protocol != t2.Protocol {\n\t\treturn false\n\t}\n\n\treturn true\n}\n"
        },
        {
          "name": "conntrack_unspecified.go",
          "type": "blob",
          "size": 2.9658203125,
          "content": "// +build !linux\n\npackage netlink\n\n// ConntrackTableType Conntrack table for the netlink operation\ntype ConntrackTableType uint8\n\n// InetFamily Family type\ntype InetFamily uint8\n\n// ConntrackFlow placeholder\ntype ConntrackFlow struct{}\n\n// CustomConntrackFilter placeholder\ntype CustomConntrackFilter struct{}\n\n// ConntrackFilter placeholder\ntype ConntrackFilter struct{}\n\n// ConntrackTableList returns the flow list of a table of a specific family\n// conntrack -L [table] [options]          List conntrack or expectation table\nfunc ConntrackTableList(table ConntrackTableType, family InetFamily) ([]*ConntrackFlow, error) {\n\treturn nil, ErrNotImplemented\n}\n\n// ConntrackTableFlush flushes all the flows of a specified table\n// conntrack -F [table]            Flush table\n// The flush operation applies to all the family types\nfunc ConntrackTableFlush(table ConntrackTableType) error {\n\treturn ErrNotImplemented\n}\n\n// ConntrackDeleteFilter deletes entries on the specified table on the base of the filter\n// conntrack -D [table] parameters         Delete conntrack or expectation\n//\n// Deprecated: use [ConntrackDeleteFilters] instead.\nfunc ConntrackDeleteFilter(table ConntrackTableType, family InetFamily, filter *ConntrackFilter) (uint, error) {\n\treturn 0, ErrNotImplemented\n}\n\n// ConntrackDeleteFilters deletes entries on the specified table matching any of the specified filters\n// conntrack -D [table] parameters         Delete conntrack or expectation\nfunc ConntrackDeleteFilters(table ConntrackTableType, family InetFamily, filters ...CustomConntrackFilter) (uint, error) {\n\treturn 0, ErrNotImplemented\n}\n\n// ConntrackTableList returns the flow list of a table of a specific family using the netlink handle passed\n// conntrack -L [table] [options]          List conntrack or expectation table\nfunc (h *Handle) ConntrackTableList(table ConntrackTableType, family InetFamily) ([]*ConntrackFlow, error) {\n\treturn nil, ErrNotImplemented\n}\n\n// ConntrackTableFlush flushes all the flows of a specified table using the netlink handle passed\n// conntrack -F [table]            Flush table\n// The flush operation applies to all the family types\nfunc (h *Handle) ConntrackTableFlush(table ConntrackTableType) error {\n\treturn ErrNotImplemented\n}\n\n// ConntrackDeleteFilter deletes entries on the specified table on the base of the filter using the netlink handle passed\n// conntrack -D [table] parameters         Delete conntrack or expectation\n//\n// Deprecated: use [Handle.ConntrackDeleteFilters] instead.\nfunc (h *Handle) ConntrackDeleteFilter(table ConntrackTableType, family InetFamily, filter *ConntrackFilter) (uint, error) {\n\treturn 0, ErrNotImplemented\n}\n\n// ConntrackDeleteFilters deletes entries on the specified table matching any of the specified filters using the netlink handle passed\n// conntrack -D [table] parameters         Delete conntrack or expectation\nfunc (h *Handle) ConntrackDeleteFilters(table ConntrackTableType, family InetFamily, filters ...CustomConntrackFilter) (uint, error) {\n\treturn 0, ErrNotImplemented\n}\n"
        },
        {
          "name": "devlink_linux.go",
          "type": "blob",
          "size": 33.5791015625,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// DevlinkDevEswitchAttr represents device's eswitch attributes\ntype DevlinkDevEswitchAttr struct {\n\tMode       string\n\tInlineMode string\n\tEncapMode  string\n}\n\n// DevlinkDevAttrs represents device attributes\ntype DevlinkDevAttrs struct {\n\tEswitch DevlinkDevEswitchAttr\n}\n\n// DevlinkDevice represents device and its attributes\ntype DevlinkDevice struct {\n\tBusName    string\n\tDeviceName string\n\tAttrs      DevlinkDevAttrs\n}\n\n// DevlinkPortFn represents port function and its attributes\ntype DevlinkPortFn struct {\n\tHwAddr  net.HardwareAddr\n\tState   uint8\n\tOpState uint8\n}\n\n// DevlinkPortFnSetAttrs represents attributes to set\ntype DevlinkPortFnSetAttrs struct {\n\tFnAttrs     DevlinkPortFn\n\tHwAddrValid bool\n\tStateValid  bool\n}\n\n// DevlinkPort represents port and its attributes\ntype DevlinkPort struct {\n\tBusName        string\n\tDeviceName     string\n\tPortIndex      uint32\n\tPortType       uint16\n\tNetdeviceName  string\n\tNetdevIfIndex  uint32\n\tRdmaDeviceName string\n\tPortFlavour    uint16\n\tFn             *DevlinkPortFn\n}\n\ntype DevLinkPortAddAttrs struct {\n\tController      uint32\n\tSfNumber        uint32\n\tPortIndex       uint32\n\tPfNumber        uint16\n\tSfNumberValid   bool\n\tPortIndexValid  bool\n\tControllerValid bool\n}\n\n// DevlinkDeviceInfo represents devlink info\ntype DevlinkDeviceInfo struct {\n\tDriver         string\n\tSerialNumber   string\n\tBoardID        string\n\tFwApp          string\n\tFwAppBoundleID string\n\tFwAppName      string\n\tFwBoundleID    string\n\tFwMgmt         string\n\tFwMgmtAPI      string\n\tFwMgmtBuild    string\n\tFwNetlist      string\n\tFwNetlistBuild string\n\tFwPsidAPI      string\n\tFwUndi         string\n}\n\n// DevlinkResource represents a device resource\ntype DevlinkResource struct {\n\tName            string\n\tID              uint64\n\tSize            uint64\n\tSizeNew         uint64\n\tSizeMin         uint64\n\tSizeMax         uint64\n\tSizeGranularity uint64\n\tPendingChange   bool\n\tUnit            uint8\n\tSizeValid       bool\n\tOCCValid        bool\n\tOCCSize         uint64\n\tParent          *DevlinkResource\n\tChildren        []DevlinkResource\n}\n\n// parseAttributes parses provided Netlink Attributes and populates DevlinkResource, returns error if occured\nfunc (dlr *DevlinkResource) parseAttributes(attrs map[uint16]syscall.NetlinkRouteAttr) error {\n\tvar attr syscall.NetlinkRouteAttr\n\tvar ok bool\n\n\t// mandatory attributes\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_ID]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing resource id\")\n\t}\n\tdlr.ID = native.Uint64(attr.Value)\n\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_NAME]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing resource name\")\n\t}\n\tdlr.Name = nl.BytesToString(attr.Value)\n\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_SIZE]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing resource size\")\n\t}\n\tdlr.Size = native.Uint64(attr.Value)\n\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_SIZE_GRAN]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing resource size granularity\")\n\t}\n\tdlr.SizeGranularity = native.Uint64(attr.Value)\n\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_UNIT]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing resource unit\")\n\t}\n\tdlr.Unit = uint8(attr.Value[0])\n\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_SIZE_MIN]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing resource size min\")\n\t}\n\tdlr.SizeMin = native.Uint64(attr.Value)\n\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_SIZE_MAX]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing resource size max\")\n\t}\n\tdlr.SizeMax = native.Uint64(attr.Value)\n\n\t// optional attributes\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_OCC]\n\tif ok {\n\t\tdlr.OCCSize = native.Uint64(attr.Value)\n\t\tdlr.OCCValid = true\n\t}\n\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_SIZE_VALID]\n\tif ok {\n\t\tdlr.SizeValid = uint8(attr.Value[0]) != 0\n\t}\n\n\tdlr.SizeNew = dlr.Size\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_SIZE_NEW]\n\tif ok {\n\t\tdlr.SizeNew = native.Uint64(attr.Value)\n\t}\n\n\tdlr.PendingChange = dlr.Size != dlr.SizeNew\n\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_LIST]\n\tif ok {\n\t\t// handle nested resoruces recursively\n\t\tsubResources, err := nl.ParseRouteAttr(attr.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, subresource := range subResources {\n\t\t\tresource := DevlinkResource{Parent: dlr}\n\t\t\tattrs, err := nl.ParseRouteAttrAsMap(subresource.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\terr = resource.parseAttributes(attrs)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to parse child resource, parent:%s. %w\", dlr.Name, err)\n\t\t\t}\n\t\t\tdlr.Children = append(dlr.Children, resource)\n\t\t}\n\t}\n\treturn nil\n}\n\n// DevlinkResources represents all devlink resources of a devlink device\ntype DevlinkResources struct {\n\tBus       string\n\tDevice    string\n\tResources []DevlinkResource\n}\n\n// parseAttributes parses provided Netlink Attributes and populates DevlinkResources, returns error if occured\nfunc (dlrs *DevlinkResources) parseAttributes(attrs map[uint16]syscall.NetlinkRouteAttr) error {\n\tvar attr syscall.NetlinkRouteAttr\n\tvar ok bool\n\n\t// Bus\n\tattr, ok = attrs[nl.DEVLINK_ATTR_BUS_NAME]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing bus name\")\n\t}\n\tdlrs.Bus = nl.BytesToString(attr.Value)\n\n\t// Device\n\tattr, ok = attrs[nl.DEVLINK_ATTR_DEV_NAME]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing device name\")\n\t}\n\tdlrs.Device = nl.BytesToString(attr.Value)\n\n\t// Resource List\n\tattr, ok = attrs[nl.DEVLINK_ATTR_RESOURCE_LIST]\n\tif !ok {\n\t\treturn fmt.Errorf(\"missing resource list\")\n\t}\n\n\tresourceAttrs, err := nl.ParseRouteAttr(attr.Value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, resourceAttr := range resourceAttrs {\n\t\tresource := DevlinkResource{}\n\t\tattrs, err := nl.ParseRouteAttrAsMap(resourceAttr.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = resource.parseAttributes(attrs)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to parse root resoruces, %w\", err)\n\t\t}\n\t\tdlrs.Resources = append(dlrs.Resources, resource)\n\t}\n\n\treturn nil\n}\n\n// DevlinkParam represents parameter of the device\ntype DevlinkParam struct {\n\tName      string\n\tIsGeneric bool\n\tType      uint8 // possible values are in nl.DEVLINK_PARAM_TYPE_* constants\n\tValues    []DevlinkParamValue\n}\n\n// DevlinkParamValue contains values of the parameter\n// Data field contains specific type which can be casted by unsing info from the DevlinkParam.Type field\ntype DevlinkParamValue struct {\n\trawData []byte\n\tData    interface{}\n\tCMODE   uint8 // possible values are in nl.DEVLINK_PARAM_CMODE_* constants\n}\n\n// parseAttributes parses provided Netlink Attributes and populates DevlinkParam, returns error if occured\nfunc (dlp *DevlinkParam) parseAttributes(attrs []syscall.NetlinkRouteAttr) error {\n\tvar valuesList [][]syscall.NetlinkRouteAttr\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase nl.DEVLINK_ATTR_PARAM:\n\t\t\tnattrs, err := nl.ParseRouteAttr(attr.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfor _, nattr := range nattrs {\n\t\t\t\tswitch nattr.Attr.Type {\n\t\t\t\tcase nl.DEVLINK_ATTR_PARAM_NAME:\n\t\t\t\t\tdlp.Name = nl.BytesToString(nattr.Value)\n\t\t\t\tcase nl.DEVLINK_ATTR_PARAM_GENERIC:\n\t\t\t\t\tdlp.IsGeneric = true\n\t\t\t\tcase nl.DEVLINK_ATTR_PARAM_TYPE:\n\t\t\t\t\tif len(nattr.Value) == 1 {\n\t\t\t\t\t\tdlp.Type = nattr.Value[0]\n\t\t\t\t\t}\n\t\t\t\tcase nl.DEVLINK_ATTR_PARAM_VALUES_LIST:\n\t\t\t\t\tnnattrs, err := nl.ParseRouteAttr(nattr.Value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tvaluesList = append(valuesList, nnattrs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor _, valAttr := range valuesList {\n\t\tv := DevlinkParamValue{}\n\t\tif err := v.parseAttributes(valAttr, dlp.Type); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdlp.Values = append(dlp.Values, v)\n\t}\n\treturn nil\n}\n\nfunc (dlpv *DevlinkParamValue) parseAttributes(attrs []syscall.NetlinkRouteAttr, paramType uint8) error {\n\tfor _, attr := range attrs {\n\t\tnattrs, err := nl.ParseRouteAttr(attr.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar rawData []byte\n\t\tfor _, nattr := range nattrs {\n\t\t\tswitch nattr.Attr.Type {\n\t\t\tcase nl.DEVLINK_ATTR_PARAM_VALUE_DATA:\n\t\t\t\trawData = nattr.Value\n\t\t\tcase nl.DEVLINK_ATTR_PARAM_VALUE_CMODE:\n\t\t\t\tif len(nattr.Value) == 1 {\n\t\t\t\t\tdlpv.CMODE = nattr.Value[0]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch paramType {\n\t\tcase nl.DEVLINK_PARAM_TYPE_U8:\n\t\t\tdlpv.Data = uint8(0)\n\t\t\tif rawData != nil && len(rawData) == 1 {\n\t\t\t\tdlpv.Data = uint8(rawData[0])\n\t\t\t}\n\t\tcase nl.DEVLINK_PARAM_TYPE_U16:\n\t\t\tdlpv.Data = uint16(0)\n\t\t\tif rawData != nil {\n\t\t\t\tdlpv.Data = native.Uint16(rawData)\n\t\t\t}\n\t\tcase nl.DEVLINK_PARAM_TYPE_U32:\n\t\t\tdlpv.Data = uint32(0)\n\t\t\tif rawData != nil {\n\t\t\t\tdlpv.Data = native.Uint32(rawData)\n\t\t\t}\n\t\tcase nl.DEVLINK_PARAM_TYPE_STRING:\n\t\t\tdlpv.Data = \"\"\n\t\t\tif rawData != nil {\n\t\t\t\tdlpv.Data = nl.BytesToString(rawData)\n\t\t\t}\n\t\tcase nl.DEVLINK_PARAM_TYPE_BOOL:\n\t\t\tdlpv.Data = rawData != nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parseDevLinkDeviceList(msgs [][]byte) ([]*DevlinkDevice, error) {\n\tdevices := make([]*DevlinkDevice, 0, len(msgs))\n\tfor _, m := range msgs {\n\t\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofGenlmsg:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdev := &DevlinkDevice{}\n\t\tif err = dev.parseAttributes(attrs); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdevices = append(devices, dev)\n\t}\n\treturn devices, nil\n}\n\nfunc eswitchStringToMode(modeName string) (uint16, error) {\n\tif modeName == \"legacy\" {\n\t\treturn nl.DEVLINK_ESWITCH_MODE_LEGACY, nil\n\t} else if modeName == \"switchdev\" {\n\t\treturn nl.DEVLINK_ESWITCH_MODE_SWITCHDEV, nil\n\t} else {\n\t\treturn 0xffff, fmt.Errorf(\"invalid switchdev mode\")\n\t}\n}\n\nfunc parseEswitchMode(mode uint16) string {\n\tvar eswitchMode = map[uint16]string{\n\t\tnl.DEVLINK_ESWITCH_MODE_LEGACY:    \"legacy\",\n\t\tnl.DEVLINK_ESWITCH_MODE_SWITCHDEV: \"switchdev\",\n\t}\n\tif eswitchMode[mode] == \"\" {\n\t\treturn \"unknown\"\n\t} else {\n\t\treturn eswitchMode[mode]\n\t}\n}\n\nfunc parseEswitchInlineMode(inlinemode uint8) string {\n\tvar eswitchInlineMode = map[uint8]string{\n\t\tnl.DEVLINK_ESWITCH_INLINE_MODE_NONE:      \"none\",\n\t\tnl.DEVLINK_ESWITCH_INLINE_MODE_LINK:      \"link\",\n\t\tnl.DEVLINK_ESWITCH_INLINE_MODE_NETWORK:   \"network\",\n\t\tnl.DEVLINK_ESWITCH_INLINE_MODE_TRANSPORT: \"transport\",\n\t}\n\tif eswitchInlineMode[inlinemode] == \"\" {\n\t\treturn \"unknown\"\n\t} else {\n\t\treturn eswitchInlineMode[inlinemode]\n\t}\n}\n\nfunc parseEswitchEncapMode(encapmode uint8) string {\n\tvar eswitchEncapMode = map[uint8]string{\n\t\tnl.DEVLINK_ESWITCH_ENCAP_MODE_NONE:  \"disable\",\n\t\tnl.DEVLINK_ESWITCH_ENCAP_MODE_BASIC: \"enable\",\n\t}\n\tif eswitchEncapMode[encapmode] == \"\" {\n\t\treturn \"unknown\"\n\t} else {\n\t\treturn eswitchEncapMode[encapmode]\n\t}\n}\n\nfunc (d *DevlinkDevice) parseAttributes(attrs []syscall.NetlinkRouteAttr) error {\n\tfor _, a := range attrs {\n\t\tswitch a.Attr.Type {\n\t\tcase nl.DEVLINK_ATTR_BUS_NAME:\n\t\t\td.BusName = string(a.Value[:len(a.Value)-1])\n\t\tcase nl.DEVLINK_ATTR_DEV_NAME:\n\t\t\td.DeviceName = string(a.Value[:len(a.Value)-1])\n\t\tcase nl.DEVLINK_ATTR_ESWITCH_MODE:\n\t\t\td.Attrs.Eswitch.Mode = parseEswitchMode(native.Uint16(a.Value))\n\t\tcase nl.DEVLINK_ATTR_ESWITCH_INLINE_MODE:\n\t\t\td.Attrs.Eswitch.InlineMode = parseEswitchInlineMode(uint8(a.Value[0]))\n\t\tcase nl.DEVLINK_ATTR_ESWITCH_ENCAP_MODE:\n\t\t\td.Attrs.Eswitch.EncapMode = parseEswitchEncapMode(uint8(a.Value[0]))\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (dev *DevlinkDevice) parseEswitchAttrs(msgs [][]byte) {\n\tm := msgs[0]\n\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofGenlmsg:])\n\tif err != nil {\n\t\treturn\n\t}\n\tdev.parseAttributes(attrs)\n}\n\nfunc (h *Handle) getEswitchAttrs(family *GenlFamily, dev *DevlinkDevice) {\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.DEVLINK_CMD_ESWITCH_GET,\n\t\tVersion: nl.GENL_DEVLINK_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(family.ID), unix.NLM_F_REQUEST|unix.NLM_F_ACK)\n\treq.AddData(msg)\n\n\tb := make([]byte, len(dev.BusName)+1)\n\tcopy(b, dev.BusName)\n\tdata := nl.NewRtAttr(nl.DEVLINK_ATTR_BUS_NAME, b)\n\treq.AddData(data)\n\n\tb = make([]byte, len(dev.DeviceName)+1)\n\tcopy(b, dev.DeviceName)\n\tdata = nl.NewRtAttr(nl.DEVLINK_ATTR_DEV_NAME, b)\n\treq.AddData(data)\n\n\tmsgs, err := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn\n\t}\n\tdev.parseEswitchAttrs(msgs)\n}\n\n// DevLinkGetDeviceList provides a pointer to devlink devices and nil error,\n// otherwise returns an error code.\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) DevLinkGetDeviceList() ([]*DevlinkDevice, error) {\n\tf, err := h.GenlFamilyGet(nl.GENL_DEVLINK_NAME)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.DEVLINK_CMD_GET,\n\t\tVersion: nl.GENL_DEVLINK_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(f.ID),\n\t\tunix.NLM_F_REQUEST|unix.NLM_F_ACK|unix.NLM_F_DUMP)\n\treq.AddData(msg)\n\tmsgs, executeErr := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tdevices, err := parseDevLinkDeviceList(msgs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, d := range devices {\n\t\th.getEswitchAttrs(f, d)\n\t}\n\treturn devices, executeErr\n}\n\n// DevLinkGetDeviceList provides a pointer to devlink devices and nil error,\n// otherwise returns an error code.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc DevLinkGetDeviceList() ([]*DevlinkDevice, error) {\n\treturn pkgHandle.DevLinkGetDeviceList()\n}\n\nfunc parseDevlinkDevice(msgs [][]byte) (*DevlinkDevice, error) {\n\tm := msgs[0]\n\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofGenlmsg:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdev := &DevlinkDevice{}\n\tif err = dev.parseAttributes(attrs); err != nil {\n\t\treturn nil, err\n\t}\n\treturn dev, nil\n}\n\nfunc (h *Handle) createCmdReq(cmd uint8, bus string, device string) (*GenlFamily, *nl.NetlinkRequest, error) {\n\tf, err := h.GenlFamilyGet(nl.GENL_DEVLINK_NAME)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tmsg := &nl.Genlmsg{\n\t\tCommand: cmd,\n\t\tVersion: nl.GENL_DEVLINK_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(f.ID),\n\t\tunix.NLM_F_REQUEST|unix.NLM_F_ACK)\n\treq.AddData(msg)\n\n\tb := make([]byte, len(bus)+1)\n\tcopy(b, bus)\n\tdata := nl.NewRtAttr(nl.DEVLINK_ATTR_BUS_NAME, b)\n\treq.AddData(data)\n\n\tb = make([]byte, len(device)+1)\n\tcopy(b, device)\n\tdata = nl.NewRtAttr(nl.DEVLINK_ATTR_DEV_NAME, b)\n\treq.AddData(data)\n\n\treturn f, req, nil\n}\n\n// DevlinkGetDeviceByName provides a pointer to devlink device and nil error,\n// otherwise returns an error code.\nfunc (h *Handle) DevLinkGetDeviceByName(Bus string, Device string) (*DevlinkDevice, error) {\n\tf, req, err := h.createCmdReq(nl.DEVLINK_CMD_GET, Bus, Device)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trespmsg, err := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdev, err := parseDevlinkDevice(respmsg)\n\tif err == nil {\n\t\th.getEswitchAttrs(f, dev)\n\t}\n\treturn dev, err\n}\n\n// DevlinkGetDeviceByName provides a pointer to devlink device and nil error,\n// otherwise returns an error code.\nfunc DevLinkGetDeviceByName(Bus string, Device string) (*DevlinkDevice, error) {\n\treturn pkgHandle.DevLinkGetDeviceByName(Bus, Device)\n}\n\n// DevLinkSetEswitchMode sets eswitch mode if able to set successfully or\n// returns an error code.\n// Equivalent to: `devlink dev eswitch set $dev mode switchdev`\n// Equivalent to: `devlink dev eswitch set $dev mode legacy`\nfunc (h *Handle) DevLinkSetEswitchMode(Dev *DevlinkDevice, NewMode string) error {\n\tmode, err := eswitchStringToMode(NewMode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_ESWITCH_SET, Dev.BusName, Dev.DeviceName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_ESWITCH_MODE, nl.Uint16Attr(mode)))\n\n\t_, err = req.Execute(unix.NETLINK_GENERIC, 0)\n\treturn err\n}\n\n// DevLinkSetEswitchMode sets eswitch mode if able to set successfully or\n// returns an error code.\n// Equivalent to: `devlink dev eswitch set $dev mode switchdev`\n// Equivalent to: `devlink dev eswitch set $dev mode legacy`\nfunc DevLinkSetEswitchMode(Dev *DevlinkDevice, NewMode string) error {\n\treturn pkgHandle.DevLinkSetEswitchMode(Dev, NewMode)\n}\n\nfunc (port *DevlinkPort) parseAttributes(attrs []syscall.NetlinkRouteAttr) error {\n\tfor _, a := range attrs {\n\t\tswitch a.Attr.Type {\n\t\tcase nl.DEVLINK_ATTR_BUS_NAME:\n\t\t\tport.BusName = string(a.Value[:len(a.Value)-1])\n\t\tcase nl.DEVLINK_ATTR_DEV_NAME:\n\t\t\tport.DeviceName = string(a.Value[:len(a.Value)-1])\n\t\tcase nl.DEVLINK_ATTR_PORT_INDEX:\n\t\t\tport.PortIndex = native.Uint32(a.Value)\n\t\tcase nl.DEVLINK_ATTR_PORT_TYPE:\n\t\t\tport.PortType = native.Uint16(a.Value)\n\t\tcase nl.DEVLINK_ATTR_PORT_NETDEV_NAME:\n\t\t\tport.NetdeviceName = string(a.Value[:len(a.Value)-1])\n\t\tcase nl.DEVLINK_ATTR_PORT_NETDEV_IFINDEX:\n\t\t\tport.NetdevIfIndex = native.Uint32(a.Value)\n\t\tcase nl.DEVLINK_ATTR_PORT_IBDEV_NAME:\n\t\t\tport.RdmaDeviceName = string(a.Value[:len(a.Value)-1])\n\t\tcase nl.DEVLINK_ATTR_PORT_FLAVOUR:\n\t\t\tport.PortFlavour = native.Uint16(a.Value)\n\t\tcase nl.DEVLINK_ATTR_PORT_FUNCTION:\n\t\t\tport.Fn = &DevlinkPortFn{}\n\t\t\tfor nested := range nl.ParseAttributes(a.Value) {\n\t\t\t\tswitch nested.Type {\n\t\t\t\tcase nl.DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR:\n\t\t\t\t\tport.Fn.HwAddr = nested.Value[:]\n\t\t\t\tcase nl.DEVLINK_PORT_FN_ATTR_STATE:\n\t\t\t\t\tport.Fn.State = uint8(nested.Value[0])\n\t\t\t\tcase nl.DEVLINK_PORT_FN_ATTR_OPSTATE:\n\t\t\t\t\tport.Fn.OpState = uint8(nested.Value[0])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parseDevLinkAllPortList(msgs [][]byte) ([]*DevlinkPort, error) {\n\tports := make([]*DevlinkPort, 0, len(msgs))\n\tfor _, m := range msgs {\n\t\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofGenlmsg:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tport := &DevlinkPort{}\n\t\tif err = port.parseAttributes(attrs); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tports = append(ports, port)\n\t}\n\treturn ports, nil\n}\n\n// DevLinkGetPortList provides a pointer to devlink ports and nil error,\n// otherwise returns an error code.\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) DevLinkGetAllPortList() ([]*DevlinkPort, error) {\n\tf, err := h.GenlFamilyGet(nl.GENL_DEVLINK_NAME)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.DEVLINK_CMD_PORT_GET,\n\t\tVersion: nl.GENL_DEVLINK_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(f.ID),\n\t\tunix.NLM_F_REQUEST|unix.NLM_F_ACK|unix.NLM_F_DUMP)\n\treq.AddData(msg)\n\tmsgs, executeErr := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tports, err := parseDevLinkAllPortList(msgs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ports, executeErr\n}\n\n// DevLinkGetPortList provides a pointer to devlink ports and nil error,\n// otherwise returns an error code.\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc DevLinkGetAllPortList() ([]*DevlinkPort, error) {\n\treturn pkgHandle.DevLinkGetAllPortList()\n}\n\nfunc parseDevlinkPortMsg(msgs [][]byte) (*DevlinkPort, error) {\n\tm := msgs[0]\n\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofGenlmsg:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tport := &DevlinkPort{}\n\tif err = port.parseAttributes(attrs); err != nil {\n\t\treturn nil, err\n\t}\n\treturn port, nil\n}\n\n// DevLinkGetPortByIndexprovides a pointer to devlink device and nil error,\n// otherwise returns an error code.\nfunc (h *Handle) DevLinkGetPortByIndex(Bus string, Device string, PortIndex uint32) (*DevlinkPort, error) {\n\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_PORT_GET, Bus, Device)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PORT_INDEX, nl.Uint32Attr(PortIndex)))\n\n\trespmsg, err := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tport, err := parseDevlinkPortMsg(respmsg)\n\treturn port, err\n}\n\n// DevlinkGetDeviceResources returns devlink device resources\nfunc DevlinkGetDeviceResources(bus string, device string) (*DevlinkResources, error) {\n\treturn pkgHandle.DevlinkGetDeviceResources(bus, device)\n}\n\n// DevlinkGetDeviceResources returns devlink device resources\nfunc (h *Handle) DevlinkGetDeviceResources(bus string, device string) (*DevlinkResources, error) {\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_RESOURCE_DUMP, bus, device)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trespmsg, err := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resources DevlinkResources\n\tfor _, m := range respmsg {\n\t\tattrs, err := nl.ParseRouteAttrAsMap(m[nl.SizeofGenlmsg:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresources.parseAttributes(attrs)\n\t}\n\n\treturn &resources, nil\n}\n\n// DevlinkGetDeviceParams returns parameters for devlink device\n// Equivalent to: `devlink dev param show <bus>/<device>`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) DevlinkGetDeviceParams(bus string, device string) ([]*DevlinkParam, error) {\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_PARAM_GET, bus, device)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Flags |= unix.NLM_F_DUMP\n\trespmsg, executeErr := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tvar params []*DevlinkParam\n\tfor _, m := range respmsg {\n\t\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofGenlmsg:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tp := &DevlinkParam{}\n\t\tif err := p.parseAttributes(attrs); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tparams = append(params, p)\n\t}\n\n\treturn params, executeErr\n}\n\n// DevlinkGetDeviceParams returns parameters for devlink device\n// Equivalent to: `devlink dev param show <bus>/<device>`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc DevlinkGetDeviceParams(bus string, device string) ([]*DevlinkParam, error) {\n\treturn pkgHandle.DevlinkGetDeviceParams(bus, device)\n}\n\n// DevlinkGetDeviceParamByName returns specific parameter for devlink device\n// Equivalent to: `devlink dev param show <bus>/<device> name <param>`\nfunc (h *Handle) DevlinkGetDeviceParamByName(bus string, device string, param string) (*DevlinkParam, error) {\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_PARAM_GET, bus, device)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PARAM_NAME, nl.ZeroTerminated(param)))\n\trespmsg, err := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(respmsg) == 0 {\n\t\treturn nil, fmt.Errorf(\"unexpected response\")\n\t}\n\tattrs, err := nl.ParseRouteAttr(respmsg[0][nl.SizeofGenlmsg:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := &DevlinkParam{}\n\tif err := p.parseAttributes(attrs); err != nil {\n\t\treturn nil, err\n\t}\n\treturn p, nil\n}\n\n// DevlinkGetDeviceParamByName returns specific parameter for devlink device\n// Equivalent to: `devlink dev param show <bus>/<device> name <param>`\nfunc DevlinkGetDeviceParamByName(bus string, device string, param string) (*DevlinkParam, error) {\n\treturn pkgHandle.DevlinkGetDeviceParamByName(bus, device, param)\n}\n\n// DevlinkSetDeviceParam set specific parameter for devlink device\n// Equivalent to: `devlink dev param set <bus>/<device> name <param> cmode <cmode> value <value>`\n// cmode argument should contain valid cmode value as uint8, modes are define in nl.DEVLINK_PARAM_CMODE_* constants\n// value argument should have one of the following types: uint8, uint16, uint32, string, bool\nfunc (h *Handle) DevlinkSetDeviceParam(bus string, device string, param string, cmode uint8, value interface{}) error {\n\t// retrive the param type\n\tp, err := h.DevlinkGetDeviceParamByName(bus, device, param)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get device param: %v\", err)\n\t}\n\tparamType := p.Type\n\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_PARAM_SET, bus, device)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PARAM_TYPE, nl.Uint8Attr(paramType)))\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PARAM_NAME, nl.ZeroTerminated(param)))\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PARAM_VALUE_CMODE, nl.Uint8Attr(cmode)))\n\n\tvar valueAsBytes []byte\n\tswitch paramType {\n\tcase nl.DEVLINK_PARAM_TYPE_U8:\n\t\tv, ok := value.(uint8)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unepected value type required: uint8, actual: %T\", value)\n\t\t}\n\t\tvalueAsBytes = nl.Uint8Attr(v)\n\tcase nl.DEVLINK_PARAM_TYPE_U16:\n\t\tv, ok := value.(uint16)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unepected value type required: uint16, actual: %T\", value)\n\t\t}\n\t\tvalueAsBytes = nl.Uint16Attr(v)\n\tcase nl.DEVLINK_PARAM_TYPE_U32:\n\t\tv, ok := value.(uint32)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unepected value type required: uint32, actual: %T\", value)\n\t\t}\n\t\tvalueAsBytes = nl.Uint32Attr(v)\n\tcase nl.DEVLINK_PARAM_TYPE_STRING:\n\t\tv, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unepected value type required: string, actual: %T\", value)\n\t\t}\n\t\tvalueAsBytes = nl.ZeroTerminated(v)\n\tcase nl.DEVLINK_PARAM_TYPE_BOOL:\n\t\tv, ok := value.(bool)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"unepected value type required: bool, actual: %T\", value)\n\t\t}\n\t\tif v {\n\t\t\tvalueAsBytes = []byte{}\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported parameter type: %d\", paramType)\n\t}\n\tif valueAsBytes != nil {\n\t\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PARAM_VALUE_DATA, valueAsBytes))\n\t}\n\t_, err = req.Execute(unix.NETLINK_GENERIC, 0)\n\treturn err\n}\n\n// DevlinkSetDeviceParam set specific parameter for devlink device\n// Equivalent to: `devlink dev param set <bus>/<device> name <param> cmode <cmode> value <value>`\n// cmode argument should contain valid cmode value as uint8, modes are define in nl.DEVLINK_PARAM_CMODE_* constants\n// value argument should have one of the following types: uint8, uint16, uint32, string, bool\nfunc DevlinkSetDeviceParam(bus string, device string, param string, cmode uint8, value interface{}) error {\n\treturn pkgHandle.DevlinkSetDeviceParam(bus, device, param, cmode, value)\n}\n\n// DevLinkGetPortByIndex provides a pointer to devlink portand nil error,\n// otherwise returns an error code.\nfunc DevLinkGetPortByIndex(Bus string, Device string, PortIndex uint32) (*DevlinkPort, error) {\n\treturn pkgHandle.DevLinkGetPortByIndex(Bus, Device, PortIndex)\n}\n\n// DevLinkPortAdd adds a devlink port and returns a port on success\n// otherwise returns nil port and an error code.\nfunc (h *Handle) DevLinkPortAdd(Bus string, Device string, Flavour uint16, Attrs DevLinkPortAddAttrs) (*DevlinkPort, error) {\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_PORT_NEW, Bus, Device)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PORT_FLAVOUR, nl.Uint16Attr(Flavour)))\n\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PORT_PCI_PF_NUMBER, nl.Uint16Attr(Attrs.PfNumber)))\n\tif Flavour == nl.DEVLINK_PORT_FLAVOUR_PCI_SF && Attrs.SfNumberValid {\n\t\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PORT_PCI_SF_NUMBER, nl.Uint32Attr(Attrs.SfNumber)))\n\t}\n\tif Attrs.PortIndexValid {\n\t\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PORT_INDEX, nl.Uint32Attr(Attrs.PortIndex)))\n\t}\n\tif Attrs.ControllerValid {\n\t\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PORT_CONTROLLER_NUMBER, nl.Uint32Attr(Attrs.Controller)))\n\t}\n\trespmsg, err := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tport, err := parseDevlinkPortMsg(respmsg)\n\treturn port, err\n}\n\n// DevLinkPortAdd adds a devlink port and returns a port on success\n// otherwise returns nil port and an error code.\nfunc DevLinkPortAdd(Bus string, Device string, Flavour uint16, Attrs DevLinkPortAddAttrs) (*DevlinkPort, error) {\n\treturn pkgHandle.DevLinkPortAdd(Bus, Device, Flavour, Attrs)\n}\n\n// DevLinkPortDel deletes a devlink port and returns success or error code.\nfunc (h *Handle) DevLinkPortDel(Bus string, Device string, PortIndex uint32) error {\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_PORT_DEL, Bus, Device)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PORT_INDEX, nl.Uint32Attr(PortIndex)))\n\t_, err = req.Execute(unix.NETLINK_GENERIC, 0)\n\treturn err\n}\n\n// DevLinkPortDel deletes a devlink port and returns success or error code.\nfunc DevLinkPortDel(Bus string, Device string, PortIndex uint32) error {\n\treturn pkgHandle.DevLinkPortDel(Bus, Device, PortIndex)\n}\n\n// DevlinkPortFnSet sets one or more port function attributes specified by the attribute mask.\n// It returns 0 on success or error code.\nfunc (h *Handle) DevlinkPortFnSet(Bus string, Device string, PortIndex uint32, FnAttrs DevlinkPortFnSetAttrs) error {\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_PORT_SET, Bus, Device)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.AddData(nl.NewRtAttr(nl.DEVLINK_ATTR_PORT_INDEX, nl.Uint32Attr(PortIndex)))\n\n\tfnAttr := nl.NewRtAttr(nl.DEVLINK_ATTR_PORT_FUNCTION|unix.NLA_F_NESTED, nil)\n\n\tif FnAttrs.HwAddrValid {\n\t\tfnAttr.AddRtAttr(nl.DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR, []byte(FnAttrs.FnAttrs.HwAddr))\n\t}\n\n\tif FnAttrs.StateValid {\n\t\tfnAttr.AddRtAttr(nl.DEVLINK_PORT_FN_ATTR_STATE, nl.Uint8Attr(FnAttrs.FnAttrs.State))\n\t}\n\treq.AddData(fnAttr)\n\n\t_, err = req.Execute(unix.NETLINK_GENERIC, 0)\n\treturn err\n}\n\n// DevlinkPortFnSet sets one or more port function attributes specified by the attribute mask.\n// It returns 0 on success or error code.\nfunc DevlinkPortFnSet(Bus string, Device string, PortIndex uint32, FnAttrs DevlinkPortFnSetAttrs) error {\n\treturn pkgHandle.DevlinkPortFnSet(Bus, Device, PortIndex, FnAttrs)\n}\n\n// devlinkInfoGetter is function that is responsible for getting devlink info message\n// this is introduced for test purpose\ntype devlinkInfoGetter func(bus, device string) ([]byte, error)\n\n// DevlinkGetDeviceInfoByName returns devlink info for selected device,\n// otherwise returns an error code.\n// Equivalent to: `devlink dev info $dev`\nfunc (h *Handle) DevlinkGetDeviceInfoByName(Bus string, Device string, getInfoMsg devlinkInfoGetter) (*DevlinkDeviceInfo, error) {\n\tinfo, err := h.DevlinkGetDeviceInfoByNameAsMap(Bus, Device, getInfoMsg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn parseInfoData(info), nil\n}\n\n// DevlinkGetDeviceInfoByName returns devlink info for selected device,\n// otherwise returns an error code.\n// Equivalent to: `devlink dev info $dev`\nfunc DevlinkGetDeviceInfoByName(Bus string, Device string) (*DevlinkDeviceInfo, error) {\n\treturn pkgHandle.DevlinkGetDeviceInfoByName(Bus, Device, pkgHandle.getDevlinkInfoMsg)\n}\n\n// DevlinkGetDeviceInfoByNameAsMap returns devlink info for selected device as a map,\n// otherwise returns an error code.\n// Equivalent to: `devlink dev info $dev`\nfunc (h *Handle) DevlinkGetDeviceInfoByNameAsMap(Bus string, Device string, getInfoMsg devlinkInfoGetter) (map[string]string, error) {\n\tresponse, err := getInfoMsg(Bus, Device)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinfo, err := parseInfoMsg(response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn info, nil\n}\n\n// DevlinkGetDeviceInfoByNameAsMap returns devlink info for selected device as a map,\n// otherwise returns an error code.\n// Equivalent to: `devlink dev info $dev`\nfunc DevlinkGetDeviceInfoByNameAsMap(Bus string, Device string) (map[string]string, error) {\n\treturn pkgHandle.DevlinkGetDeviceInfoByNameAsMap(Bus, Device, pkgHandle.getDevlinkInfoMsg)\n}\n\n// GetDevlinkInfo returns devlink info for target device,\n// otherwise returns an error code.\nfunc (d *DevlinkDevice) GetDevlinkInfo() (*DevlinkDeviceInfo, error) {\n\treturn pkgHandle.DevlinkGetDeviceInfoByName(d.BusName, d.DeviceName, pkgHandle.getDevlinkInfoMsg)\n}\n\n// GetDevlinkInfoAsMap returns devlink info for target device as a map,\n// otherwise returns an error code.\nfunc (d *DevlinkDevice) GetDevlinkInfoAsMap() (map[string]string, error) {\n\treturn pkgHandle.DevlinkGetDeviceInfoByNameAsMap(d.BusName, d.DeviceName, pkgHandle.getDevlinkInfoMsg)\n}\n\nfunc (h *Handle) getDevlinkInfoMsg(bus, device string) ([]byte, error) {\n\t_, req, err := h.createCmdReq(nl.DEVLINK_CMD_INFO_GET, bus, device)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse, err := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(response) < 1 {\n\t\treturn nil, fmt.Errorf(\"getDevlinkInfoMsg: message too short\")\n\t}\n\n\treturn response[0], nil\n}\n\nfunc parseInfoMsg(msg []byte) (map[string]string, error) {\n\tif len(msg) < nl.SizeofGenlmsg {\n\t\treturn nil, fmt.Errorf(\"parseInfoMsg: message too short\")\n\t}\n\n\tinfo := make(map[string]string)\n\terr := collectInfoData(msg[nl.SizeofGenlmsg:], info)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn info, nil\n}\n\nfunc collectInfoData(msg []byte, data map[string]string) error {\n\tattrs, err := nl.ParseRouteAttr(msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase nl.DEVLINK_ATTR_INFO_DRIVER_NAME:\n\t\t\tdata[\"driver\"] = parseInfoValue(attr.Value)\n\t\tcase nl.DEVLINK_ATTR_INFO_SERIAL_NUMBER:\n\t\t\tdata[\"serialNumber\"] = parseInfoValue(attr.Value)\n\t\tcase nl.DEVLINK_ATTR_INFO_VERSION_RUNNING, nl.DEVLINK_ATTR_INFO_VERSION_FIXED,\n\t\t\tnl.DEVLINK_ATTR_INFO_VERSION_STORED:\n\t\t\tkey, value, err := getNestedInfoData(attr.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdata[key] = value\n\t\t}\n\t}\n\n\tif len(data) == 0 {\n\t\treturn fmt.Errorf(\"collectInfoData: could not read attributes\")\n\t}\n\n\treturn nil\n}\n\nfunc getNestedInfoData(msg []byte) (string, string, error) {\n\tnestedAttrs, err := nl.ParseRouteAttr(msg)\n\n\tvar key, value string\n\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tif len(nestedAttrs) != 2 {\n\t\treturn \"\", \"\", fmt.Errorf(\"getNestedInfoData: too few attributes in nested structure\")\n\t}\n\n\tfor _, nestedAttr := range nestedAttrs {\n\t\tswitch nestedAttr.Attr.Type {\n\t\tcase nl.DEVLINK_ATTR_INFO_VERSION_NAME:\n\t\t\tkey = parseInfoValue(nestedAttr.Value)\n\t\tcase nl.DEVLINK_ATTR_INFO_VERSION_VALUE:\n\t\t\tvalue = parseInfoValue(nestedAttr.Value)\n\t\t}\n\t}\n\n\tif key == \"\" {\n\t\treturn \"\", \"\", fmt.Errorf(\"getNestedInfoData: key not found\")\n\t}\n\n\tif value == \"\" {\n\t\treturn \"\", \"\", fmt.Errorf(\"getNestedInfoData: value not found\")\n\t}\n\n\treturn key, value, nil\n}\n\nfunc parseInfoData(data map[string]string) *DevlinkDeviceInfo {\n\tinfo := new(DevlinkDeviceInfo)\n\tfor key, value := range data {\n\t\tswitch key {\n\t\tcase \"driver\":\n\t\t\tinfo.Driver = value\n\t\tcase \"serialNumber\":\n\t\t\tinfo.SerialNumber = value\n\t\tcase \"board.id\":\n\t\t\tinfo.BoardID = value\n\t\tcase \"fw.app\":\n\t\t\tinfo.FwApp = value\n\t\tcase \"fw.app.bundle_id\":\n\t\t\tinfo.FwAppBoundleID = value\n\t\tcase \"fw.app.name\":\n\t\t\tinfo.FwAppName = value\n\t\tcase \"fw.bundle_id\":\n\t\t\tinfo.FwBoundleID = value\n\t\tcase \"fw.mgmt\":\n\t\t\tinfo.FwMgmt = value\n\t\tcase \"fw.mgmt.api\":\n\t\t\tinfo.FwMgmtAPI = value\n\t\tcase \"fw.mgmt.build\":\n\t\t\tinfo.FwMgmtBuild = value\n\t\tcase \"fw.netlist\":\n\t\t\tinfo.FwNetlist = value\n\t\tcase \"fw.netlist.build\":\n\t\t\tinfo.FwNetlistBuild = value\n\t\tcase \"fw.psid.api\":\n\t\t\tinfo.FwPsidAPI = value\n\t\tcase \"fw.undi\":\n\t\t\tinfo.FwUndi = value\n\t\t}\n\t}\n\treturn info\n}\n\nfunc parseInfoValue(value []byte) string {\n\tv := strings.ReplaceAll(string(value), \"\\x00\", \"\")\n\treturn strings.TrimSpace(v)\n}\n"
        },
        {
          "name": "devlink_test.go",
          "type": "blob",
          "size": 11.9873046875,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"flag\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n)\n\nfunc TestDevLinkGetDeviceList(t *testing.T) {\n\tminKernelRequired(t, 4, 12)\n\tsetUpNetlinkTestWithKModule(t, \"devlink\")\n\t_, err := DevLinkGetDeviceList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDevLinkGetDeviceByName(t *testing.T) {\n\tminKernelRequired(t, 4, 12)\n\tsetUpNetlinkTestWithKModule(t, \"devlink\")\n\t_, err := DevLinkGetDeviceByName(\"foo\", \"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDevLinkSetEswitchMode(t *testing.T) {\n\tminKernelRequired(t, 4, 12)\n\tsetUpNetlinkTestWithKModule(t, \"devlink\")\n\tdev, err := DevLinkGetDeviceByName(\"foo\", \"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = DevLinkSetEswitchMode(dev, \"switchdev\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = DevLinkSetEswitchMode(dev, \"legacy\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDevLinkGetAllPortList(t *testing.T) {\n\tminKernelRequired(t, 5, 4)\n\tports, err := DevLinkGetAllPortList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(\"devlink port count = \", len(ports))\n\tfor _, port := range ports {\n\t\tt.Log(*port)\n\t}\n}\n\nfunc TestDevLinkAddDelSfPort(t *testing.T) {\n\tvar addAttrs DevLinkPortAddAttrs\n\tminKernelRequired(t, 5, 13)\n\tif bus == \"\" || device == \"\" {\n\t\tt.Log(\"devlink bus and device are empty, skipping test\")\n\t\treturn\n\t}\n\n\tdev, err := DevLinkGetDeviceByName(bus, device)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\taddAttrs.SfNumberValid = true\n\taddAttrs.SfNumber = uint32(sfnum)\n\taddAttrs.PfNumber = 0\n\tport, err2 := DevLinkPortAdd(dev.BusName, dev.DeviceName, 7, addAttrs)\n\tif err2 != nil {\n\t\tt.Fatal(err2)\n\t\treturn\n\t}\n\tt.Log(*port)\n\tif port.Fn != nil {\n\t\tt.Log(\"function attributes = \", *port.Fn)\n\t}\n\terr2 = DevLinkPortDel(dev.BusName, dev.DeviceName, port.PortIndex)\n\tif err2 != nil {\n\t\tt.Fatal(err2)\n\t}\n}\n\nfunc TestDevLinkSfPortFnSet(t *testing.T) {\n\tvar addAttrs DevLinkPortAddAttrs\n\tvar stateAttr DevlinkPortFnSetAttrs\n\n\tminKernelRequired(t, 5, 12)\n\tif bus == \"\" || device == \"\" {\n\t\tt.Log(\"devlink bus and device are empty, skipping test\")\n\t\treturn\n\t}\n\n\tdev, err := DevLinkGetDeviceByName(bus, device)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\taddAttrs.SfNumberValid = true\n\taddAttrs.SfNumber = uint32(sfnum)\n\taddAttrs.PfNumber = 0\n\tport, err2 := DevLinkPortAdd(dev.BusName, dev.DeviceName, 7, addAttrs)\n\tif err2 != nil {\n\t\tt.Fatal(err2)\n\t\treturn\n\t}\n\tt.Log(*port)\n\tif port.Fn != nil {\n\t\tt.Log(\"function attributes = \", *port.Fn)\n\t}\n\tmacAttr := DevlinkPortFnSetAttrs{\n\t\tFnAttrs: DevlinkPortFn{\n\t\t\tHwAddr: net.HardwareAddr{0x00, 0x11, 0x22, 0x33, 0x44, 0x55},\n\t\t},\n\t\tHwAddrValid: true,\n\t}\n\terr2 = DevlinkPortFnSet(dev.BusName, dev.DeviceName, port.PortIndex, macAttr)\n\tif err2 != nil {\n\t\tt.Log(\"function mac set err = \", err2)\n\t}\n\tstateAttr.FnAttrs.State = 1\n\tstateAttr.StateValid = true\n\terr2 = DevlinkPortFnSet(dev.BusName, dev.DeviceName, port.PortIndex, stateAttr)\n\tif err2 != nil {\n\t\tt.Log(\"function state set err = \", err2)\n\t}\n\n\tport, err3 := DevLinkGetPortByIndex(dev.BusName, dev.DeviceName, port.PortIndex)\n\tif err3 == nil {\n\t\tt.Log(*port)\n\t\tt.Log(*port.Fn)\n\t}\n\terr2 = DevLinkPortDel(dev.BusName, dev.DeviceName, port.PortIndex)\n\tif err2 != nil {\n\t\tt.Fatal(err2)\n\t}\n}\n\nvar bus string\nvar device string\nvar sfnum uint\n\nfunc init() {\n\tflag.StringVar(&bus, \"bus\", \"\", \"devlink device bus name\")\n\tflag.StringVar(&device, \"device\", \"\", \"devlink device devicename\")\n\tflag.UintVar(&sfnum, \"sfnum\", 0, \"devlink port sfnumber\")\n}\n\nfunc TestDevlinkGetDeviceInfoByNameAsMap(t *testing.T) {\n\tinfo, err := pkgHandle.DevlinkGetDeviceInfoByNameAsMap(\"pci\", \"0000:00:00.0\", mockDevlinkInfoGetter)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestInfo := devlinkTestInfoParesd()\n\tfor k, v := range info {\n\t\tif testInfo[k] != v {\n\t\t\tt.Fatal(\"Value\", v, \"retrieved for key\", k, \"is not equal to\", testInfo[k])\n\t\t}\n\t}\n}\n\nfunc TestDevlinkGetDeviceInfoByName(t *testing.T) {\n\tinfo, err := pkgHandle.DevlinkGetDeviceInfoByName(\"pci\", \"0000:00:00.0\", mockDevlinkInfoGetter)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestInfo := parseInfoData(devlinkTestInfoParesd())\n\tif !areInfoStructsEqual(info, testInfo) {\n\t\tt.Fatal(\"Info structures are not equal\")\n\t}\n}\n\nfunc TestDevlinkGetDeviceInfoByNameAsMapFail(t *testing.T) {\n\t_, err := pkgHandle.DevlinkGetDeviceInfoByNameAsMap(\"pci\", \"0000:00:00.0\", mockDevlinkInfoGetterEmpty)\n\tif err == nil {\n\t\tt.Fatal()\n\t}\n}\n\nfunc TestDevlinkGetDeviceInfoByNameFail(t *testing.T) {\n\t_, err := pkgHandle.DevlinkGetDeviceInfoByName(\"pci\", \"0000:00:00.0\", mockDevlinkInfoGetterEmpty)\n\tif err == nil {\n\t\tt.Fatal()\n\t}\n}\n\nfunc mockDevlinkInfoGetter(bus, device string) ([]byte, error) {\n\treturn devlinkInfo(), nil\n}\n\nfunc mockDevlinkInfoGetterEmpty(bus, device string) ([]byte, error) {\n\treturn []byte{}, nil\n}\n\nfunc devlinkInfo() []byte {\n\treturn []byte{51, 1, 0, 0, 8, 0, 1, 0, 112, 99, 105, 0, 17, 0, 2, 0, 48,\n\t\t48, 48, 48, 58, 56, 52, 58, 48, 48, 46, 48, 0, 0, 0, 0, 8, 0, 98, 0,\n\t\t105, 99, 101, 0, 28, 0, 99, 0, 51, 48, 45, 56, 57, 45, 97, 51, 45,\n\t\t102, 102, 45, 102, 102, 45, 99, 97, 45, 48, 53, 45, 54, 56, 0, 36,\n\t\t0, 100, 0, 13, 0, 103, 0, 98, 111, 97, 114, 100, 46, 105, 100, 0, 0,\n\t\t0, 0, 15, 0, 104, 0, 75, 56, 53, 53, 56, 53, 45, 48, 48, 48, 0, 0,\n\t\t28, 0, 101, 0, 12, 0, 103, 0, 102, 119, 46, 109, 103, 109, 116, 0,\n\t\t10, 0, 104, 0, 53, 46, 52, 46, 53, 0, 0, 0, 28, 0, 101, 0, 16, 0,\n\t\t103, 0, 102, 119, 46, 109, 103, 109, 116, 46, 97, 112, 105, 0, 8, 0,\n\t\t104, 0, 49, 46, 55, 0, 40, 0, 101, 0, 18, 0, 103, 0, 102, 119, 46,\n\t\t109, 103, 109, 116, 46, 98, 117, 105, 108, 100, 0, 0, 0, 15, 0, 104,\n\t\t0, 48, 120, 51, 57, 49, 102, 55, 54, 52, 48, 0, 0, 32, 0, 101, 0,\n\t\t12, 0, 103, 0, 102, 119, 46, 117, 110, 100, 105, 0, 13, 0, 104, 0,\n\t\t49, 46, 50, 56, 57, 56, 46, 48, 0, 0, 0, 0, 32, 0, 101, 0, 16, 0,\n\t\t103, 0, 102, 119, 46, 112, 115, 105, 100, 46, 97, 112, 105, 0, 9, 0,\n\t\t104, 0, 50, 46, 52, 50, 0, 0, 0, 0, 40, 0, 101, 0, 17, 0, 103, 0,\n\t\t102, 119, 46, 98, 117, 110, 100, 108, 101, 95, 105, 100, 0, 0, 0, 0,\n\t\t15, 0, 104, 0, 48, 120, 56, 48, 48, 48, 55, 48, 54, 98, 0, 0, 48, 0,\n\t\t101, 0, 16, 0, 103, 0, 102, 119, 46, 97, 112, 112, 46, 110, 97, 109,\n\t\t101, 0, 27, 0, 104, 0, 73, 67, 69, 32, 79, 83, 32, 68, 101, 102, 97,\n\t\t117, 108, 116, 32, 80, 97, 99, 107, 97, 103, 101, 0, 0, 32, 0, 101,\n\t\t0, 11, 0, 103, 0, 102, 119, 46, 97, 112, 112, 0, 0, 13, 0, 104, 0,\n\t\t49, 46, 51, 46, 50, 52, 46, 48, 0, 0, 0, 0, 44, 0, 101, 0, 21, 0,\n\t\t103, 0, 102, 119, 46, 97, 112, 112, 46, 98, 117, 110, 100, 108,\n\t\t101, 95, 105, 100, 0, 0, 0, 0, 15, 0, 104, 0, 48, 120, 99, 48, 48,\n\t\t48, 48, 48, 48, 49, 0, 0, 44, 0, 101, 0, 15, 0, 103, 0, 102, 119,\n\t\t46, 110, 101, 116, 108, 105, 115, 116, 0, 0, 21, 0, 104, 0, 50, 46,\n\t\t52, 48, 46, 50, 48, 48, 48, 45, 51, 46, 49, 54, 46, 48, 0, 0, 0, 0,\n\t\t44, 0, 101, 0, 21, 0, 103, 0, 102, 119, 46, 110, 101, 116, 108, 105,\n\t\t115, 116, 46, 98, 117, 105, 108, 100, 0, 0, 0, 0, 15, 0, 104, 0, 48,\n\t\t120, 54, 55, 54, 97, 52, 56, 57, 100, 0, 0}\n}\n\nfunc devlinkTestInfoParesd() map[string]string {\n\treturn map[string]string{\n\t\t\"board.id\":         \"K85585-000\",\n\t\t\"fw.app\":           \"1.3.24.0\",\n\t\t\"fw.app.bundle_id\": \"0xc0000001\",\n\t\t\"fw.app.name\":      \"ICE OS Default Package\",\n\t\t\"fw.bundle_id\":     \"0x8000706b\",\n\t\t\"fw.mgmt\":          \"5.4.5\",\n\t\t\"fw.mgmt.api\":      \"1.7\",\n\t\t\"fw.mgmt.build\":    \"0x391f7640\",\n\t\t\"fw.netlist\":       \"2.40.2000-3.16.0\",\n\t\t\"fw.netlist.build\": \"0x676a489d\",\n\t\t\"fw.psid.api\":      \"2.42\",\n\t\t\"fw.undi\":          \"1.2898.0\",\n\t\t\"driver\":           \"ice\",\n\t\t\"serialNumber\":     \"30-89-a3-ff-ff-ca-05-68\",\n\t}\n}\n\nfunc areInfoStructsEqual(first *DevlinkDeviceInfo, second *DevlinkDeviceInfo) bool {\n\tif first.FwApp != second.FwApp || first.FwAppBoundleID != second.FwAppBoundleID ||\n\t\tfirst.FwAppName != second.FwAppName || first.FwBoundleID != second.FwBoundleID ||\n\t\tfirst.FwMgmt != second.FwMgmt || first.FwMgmtAPI != second.FwMgmtAPI ||\n\t\tfirst.FwMgmtBuild != second.FwMgmtBuild || first.FwNetlist != second.FwNetlist ||\n\t\tfirst.FwNetlistBuild != second.FwNetlistBuild || first.FwPsidAPI != second.FwPsidAPI ||\n\t\tfirst.BoardID != second.BoardID || first.FwUndi != second.FwUndi ||\n\t\tfirst.Driver != second.Driver || first.SerialNumber != second.SerialNumber {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc TestDevlinkGetDeviceResources(t *testing.T) {\n\tminKernelRequired(t, 5, 11)\n\ttearDown := setUpNetlinkTestWithKModule(t, \"devlink\")\n\tdefer tearDown()\n\n\tif bus == \"\" || device == \"\" {\n\t\t//TODO: setup netdevsim device instead of getting device from flags\n\t\tt.Log(\"devlink bus and device are empty, skipping test\")\n\t\tt.SkipNow()\n\t}\n\n\tres, err := DevlinkGetDeviceResources(bus, device)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get device(%s/%s) resources. %s\", bus, device, err)\n\t}\n\n\tif res.Bus != bus || res.Device != device {\n\t\tt.Fatalf(\"missmatching bus/device\")\n\t}\n\n\tt.Logf(\"Resources: %+v\", res)\n}\n\n// devlink device parameters can be tested with netdevsim\n// function will create netdevsim/netdevsim<random_id> virtual device that can be used for testing\n// netdevsim module should be loaded to run devlink param tests\nfunc setupDevlinkDeviceParamTest(t *testing.T) (string, string, func()) {\n\tt.Helper()\n\tskipUnlessRoot(t)\n\tskipUnlessKModuleLoaded(t, \"netdevsim\")\n\ttestDevID := strconv.Itoa(1000 + rand.Intn(1000))\n\terr := os.WriteFile(\"/sys/bus/netdevsim/new_device\", []byte(testDevID), 0755)\n\tif err != nil {\n\t\tt.Fatalf(\"can't create netdevsim test device %s: %v\", testDevID, err)\n\t}\n\n\treturn \"netdevsim\", \"netdevsim\" + testDevID, func() {\n\t\t_ = os.WriteFile(\"/sys/bus/netdevsim/del_device\", []byte(testDevID), 0755)\n\t}\n}\n\nfunc TestDevlinkGetDeviceParams(t *testing.T) {\n\tbusName, deviceName, cleanupFunc := setupDevlinkDeviceParamTest(t)\n\tdefer cleanupFunc()\n\tparams, err := DevlinkGetDeviceParams(busName, deviceName)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get device(%s/%s) parameters. %s\", busName, deviceName, err)\n\t}\n\tif len(params) == 0 {\n\t\tt.Fatal(\"parameters list is empty\")\n\t}\n\tfor _, p := range params {\n\t\tvalidateDeviceParams(t, p)\n\t}\n}\n\nfunc TestDevlinkGetDeviceParamByName(t *testing.T) {\n\tbusName, deviceName, cleanupFunc := setupDevlinkDeviceParamTest(t)\n\tdefer cleanupFunc()\n\tparam, err := DevlinkGetDeviceParamByName(busName, deviceName, \"max_macs\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get device(%s/%s) parameter max_macs. %s\", busName, deviceName, err)\n\t}\n\tvalidateDeviceParams(t, param)\n}\n\nfunc TestDevlinkSetDeviceParam(t *testing.T) {\n\tbusName, deviceName, cleanupFunc := setupDevlinkDeviceParamTest(t)\n\tdefer cleanupFunc()\n\terr := DevlinkSetDeviceParam(busName, deviceName, \"max_macs\", nl.DEVLINK_PARAM_CMODE_DRIVERINIT, uint32(8))\n\tif err != nil {\n\t\tt.Fatalf(\"failed to set max_macs for device(%s/%s): %s\", busName, deviceName, err)\n\t}\n\tparam, err := DevlinkGetDeviceParamByName(busName, deviceName, \"max_macs\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get device(%s/%s) parameter max_macs. %s\", busName, deviceName, err)\n\t}\n\tvalidateDeviceParams(t, param)\n\tv, ok := param.Values[0].Data.(uint32)\n\tif !ok {\n\t\tt.Fatalf(\"unexpected value\")\n\t}\n\tif v != uint32(8) {\n\t\tt.Fatalf(\"value not set\")\n\t}\n}\n\nfunc validateDeviceParams(t *testing.T, p *DevlinkParam) {\n\tif p.Name == \"\" {\n\t\tt.Fatal(\"Name field not set\")\n\t}\n\tif p.Name == \"max_macs\" && !p.IsGeneric {\n\t\tt.Fatal(\"IsGeneric should be true for generic parameter\")\n\t}\n\t// test1 is a driver-specific parameter in netdevsim device, check should\n\t// also path on HW devices\n\tif p.Name == \"test1\" && p.IsGeneric {\n\t\tt.Fatal(\"IsGeneric should be false for driver-specific parameter\")\n\t}\n\tswitch p.Type {\n\tcase nl.DEVLINK_PARAM_TYPE_U8,\n\t\tnl.DEVLINK_PARAM_TYPE_U16,\n\t\tnl.DEVLINK_PARAM_TYPE_U32,\n\t\tnl.DEVLINK_PARAM_TYPE_STRING,\n\t\tnl.DEVLINK_PARAM_TYPE_BOOL:\n\tdefault:\n\t\tt.Fatal(\"Type has unexpected value\")\n\t}\n\tif len(p.Values) == 0 {\n\t\tt.Fatal(\"Values are not set\")\n\t}\n\tfor _, v := range p.Values {\n\t\tswitch v.CMODE {\n\t\tcase nl.DEVLINK_PARAM_CMODE_RUNTIME,\n\t\t\tnl.DEVLINK_PARAM_CMODE_DRIVERINIT,\n\t\t\tnl.DEVLINK_PARAM_CMODE_PERMANENT:\n\t\tdefault:\n\t\t\tt.Fatal(\"CMODE has unexpected value\")\n\t\t}\n\t\tif p.Name == \"max_macs\" {\n\t\t\t_, ok := v.Data.(uint32)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"value max_macs has wrong type: %T, expected: uint32\", v.Data)\n\t\t\t}\n\t\t}\n\t\tif p.Name == \"test1\" {\n\t\t\t_, ok := v.Data.(bool)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"value test1 has wrong type: %T, expected: bool\", v.Data)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "filter.go",
          "type": "blob",
          "size": 8.982421875,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\ntype Filter interface {\n\tAttrs() *FilterAttrs\n\tType() string\n}\n\n// FilterAttrs represents a netlink filter. A filter is associated with a link,\n// has a handle and a parent. The root filter of a device should have a\n// parent == HANDLE_ROOT.\ntype FilterAttrs struct {\n\tLinkIndex int\n\tHandle    uint32\n\tParent    uint32\n\tPriority  uint16 // lower is higher priority\n\tProtocol  uint16 // unix.ETH_P_*\n\tChain     *uint32\n}\n\nfunc (q FilterAttrs) String() string {\n\treturn fmt.Sprintf(\"{LinkIndex: %d, Handle: %s, Parent: %s, Priority: %d, Protocol: %d}\", q.LinkIndex, HandleStr(q.Handle), HandleStr(q.Parent), q.Priority, q.Protocol)\n}\n\ntype TcAct int32\n\nconst (\n\tTC_ACT_EXT_SHIFT    = 28\n\tTC_ACT_EXT_VAL_MASK = (1 << TC_ACT_EXT_SHIFT) - 1\n)\n\nconst (\n\tTC_ACT_UNSPEC     TcAct = -1\n\tTC_ACT_OK         TcAct = 0\n\tTC_ACT_RECLASSIFY TcAct = 1\n\tTC_ACT_SHOT       TcAct = 2\n\tTC_ACT_PIPE       TcAct = 3\n\tTC_ACT_STOLEN     TcAct = 4\n\tTC_ACT_QUEUED     TcAct = 5\n\tTC_ACT_REPEAT     TcAct = 6\n\tTC_ACT_REDIRECT   TcAct = 7\n\tTC_ACT_JUMP       TcAct = 0x10000000\n)\n\nfunc getTcActExt(local int32) int32 {\n\treturn local << TC_ACT_EXT_SHIFT\n}\n\nfunc getTcActGotoChain() TcAct {\n\treturn TcAct(getTcActExt(2))\n}\n\nfunc getTcActExtOpcode(combined int32) int32 {\n\treturn combined & (^TC_ACT_EXT_VAL_MASK)\n}\n\nfunc TcActExtCmp(combined int32, opcode int32) bool {\n\treturn getTcActExtOpcode(combined) == opcode\n}\n\nfunc (a TcAct) String() string {\n\tswitch a {\n\tcase TC_ACT_UNSPEC:\n\t\treturn \"unspec\"\n\tcase TC_ACT_OK:\n\t\treturn \"ok\"\n\tcase TC_ACT_RECLASSIFY:\n\t\treturn \"reclassify\"\n\tcase TC_ACT_SHOT:\n\t\treturn \"shot\"\n\tcase TC_ACT_PIPE:\n\t\treturn \"pipe\"\n\tcase TC_ACT_STOLEN:\n\t\treturn \"stolen\"\n\tcase TC_ACT_QUEUED:\n\t\treturn \"queued\"\n\tcase TC_ACT_REPEAT:\n\t\treturn \"repeat\"\n\tcase TC_ACT_REDIRECT:\n\t\treturn \"redirect\"\n\tcase TC_ACT_JUMP:\n\t\treturn \"jump\"\n\t}\n\tif TcActExtCmp(int32(a), int32(getTcActGotoChain())) {\n\t\treturn \"goto\"\n\t}\n\treturn fmt.Sprintf(\"0x%x\", int32(a))\n}\n\ntype TcPolAct int32\n\nconst (\n\tTC_POLICE_UNSPEC     TcPolAct = TcPolAct(TC_ACT_UNSPEC)\n\tTC_POLICE_OK         TcPolAct = TcPolAct(TC_ACT_OK)\n\tTC_POLICE_RECLASSIFY TcPolAct = TcPolAct(TC_ACT_RECLASSIFY)\n\tTC_POLICE_SHOT       TcPolAct = TcPolAct(TC_ACT_SHOT)\n\tTC_POLICE_PIPE       TcPolAct = TcPolAct(TC_ACT_PIPE)\n)\n\nfunc (a TcPolAct) String() string {\n\tswitch a {\n\tcase TC_POLICE_UNSPEC:\n\t\treturn \"unspec\"\n\tcase TC_POLICE_OK:\n\t\treturn \"ok\"\n\tcase TC_POLICE_RECLASSIFY:\n\t\treturn \"reclassify\"\n\tcase TC_POLICE_SHOT:\n\t\treturn \"shot\"\n\tcase TC_POLICE_PIPE:\n\t\treturn \"pipe\"\n\t}\n\treturn fmt.Sprintf(\"0x%x\", int32(a))\n}\n\ntype ActionAttrs struct {\n\tIndex      int\n\tCapab      int\n\tAction     TcAct\n\tRefcnt     int\n\tBindcnt    int\n\tStatistics *ActionStatistic\n\tTimestamp  *ActionTimestamp\n}\n\nfunc (q ActionAttrs) String() string {\n\treturn fmt.Sprintf(\"{Index: %d, Capab: %x, Action: %s, Refcnt: %d, Bindcnt: %d}\", q.Index, q.Capab, q.Action.String(), q.Refcnt, q.Bindcnt)\n}\n\ntype ActionTimestamp struct {\n\tInstalled uint64\n\tLastUsed  uint64\n\tExpires   uint64\n\tFirstUsed uint64\n}\n\nfunc (t ActionTimestamp) String() string {\n\treturn fmt.Sprintf(\"Installed %d LastUsed %d Expires %d FirstUsed %d\", t.Installed, t.LastUsed, t.Expires, t.FirstUsed)\n}\n\ntype ActionStatistic ClassStatistics\n\n// Action represents an action in any supported filter.\ntype Action interface {\n\tAttrs() *ActionAttrs\n\tType() string\n}\n\ntype GenericAction struct {\n\tActionAttrs\n\tChain int32\n}\n\nfunc (action *GenericAction) Type() string {\n\treturn \"generic\"\n}\n\nfunc (action *GenericAction) Attrs() *ActionAttrs {\n\treturn &action.ActionAttrs\n}\n\ntype BpfAction struct {\n\tActionAttrs\n\tFd   int\n\tName string\n}\n\nfunc (action *BpfAction) Type() string {\n\treturn \"bpf\"\n}\n\nfunc (action *BpfAction) Attrs() *ActionAttrs {\n\treturn &action.ActionAttrs\n}\n\ntype ConnmarkAction struct {\n\tActionAttrs\n\tZone uint16\n}\n\nfunc (action *ConnmarkAction) Type() string {\n\treturn \"connmark\"\n}\n\nfunc (action *ConnmarkAction) Attrs() *ActionAttrs {\n\treturn &action.ActionAttrs\n}\n\nfunc NewConnmarkAction() *ConnmarkAction {\n\treturn &ConnmarkAction{\n\t\tActionAttrs: ActionAttrs{\n\t\t\tAction: TC_ACT_PIPE,\n\t\t},\n\t}\n}\n\ntype CsumUpdateFlags uint32\n\nconst (\n\tTCA_CSUM_UPDATE_FLAG_IPV4HDR CsumUpdateFlags = 1\n\tTCA_CSUM_UPDATE_FLAG_ICMP    CsumUpdateFlags = 2\n\tTCA_CSUM_UPDATE_FLAG_IGMP    CsumUpdateFlags = 4\n\tTCA_CSUM_UPDATE_FLAG_TCP     CsumUpdateFlags = 8\n\tTCA_CSUM_UPDATE_FLAG_UDP     CsumUpdateFlags = 16\n\tTCA_CSUM_UPDATE_FLAG_UDPLITE CsumUpdateFlags = 32\n\tTCA_CSUM_UPDATE_FLAG_SCTP    CsumUpdateFlags = 64\n)\n\ntype CsumAction struct {\n\tActionAttrs\n\tUpdateFlags CsumUpdateFlags\n}\n\nfunc (action *CsumAction) Type() string {\n\treturn \"csum\"\n}\n\nfunc (action *CsumAction) Attrs() *ActionAttrs {\n\treturn &action.ActionAttrs\n}\n\nfunc NewCsumAction() *CsumAction {\n\treturn &CsumAction{\n\t\tActionAttrs: ActionAttrs{\n\t\t\tAction: TC_ACT_PIPE,\n\t\t},\n\t}\n}\n\ntype MirredAct uint8\n\nfunc (a MirredAct) String() string {\n\tswitch a {\n\tcase TCA_EGRESS_REDIR:\n\t\treturn \"egress redir\"\n\tcase TCA_EGRESS_MIRROR:\n\t\treturn \"egress mirror\"\n\tcase TCA_INGRESS_REDIR:\n\t\treturn \"ingress redir\"\n\tcase TCA_INGRESS_MIRROR:\n\t\treturn \"ingress mirror\"\n\t}\n\treturn \"unknown\"\n}\n\nconst (\n\tTCA_EGRESS_REDIR   MirredAct = 1 /* packet redirect to EGRESS*/\n\tTCA_EGRESS_MIRROR  MirredAct = 2 /* mirror packet to EGRESS */\n\tTCA_INGRESS_REDIR  MirredAct = 3 /* packet redirect to INGRESS*/\n\tTCA_INGRESS_MIRROR MirredAct = 4 /* mirror packet to INGRESS */\n)\n\ntype MirredAction struct {\n\tActionAttrs\n\tMirredAction MirredAct\n\tIfindex      int\n}\n\nfunc (action *MirredAction) Type() string {\n\treturn \"mirred\"\n}\n\nfunc (action *MirredAction) Attrs() *ActionAttrs {\n\treturn &action.ActionAttrs\n}\n\nfunc NewMirredAction(redirIndex int) *MirredAction {\n\treturn &MirredAction{\n\t\tActionAttrs: ActionAttrs{\n\t\t\tAction: TC_ACT_STOLEN,\n\t\t},\n\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\tIfindex:      redirIndex,\n\t}\n}\n\ntype TunnelKeyAct int8\n\nconst (\n\tTCA_TUNNEL_KEY_SET   TunnelKeyAct = 1 // set tunnel key\n\tTCA_TUNNEL_KEY_UNSET TunnelKeyAct = 2 // unset tunnel key\n)\n\ntype TunnelKeyAction struct {\n\tActionAttrs\n\tAction   TunnelKeyAct\n\tSrcAddr  net.IP\n\tDstAddr  net.IP\n\tKeyID    uint32\n\tDestPort uint16\n}\n\nfunc (action *TunnelKeyAction) Type() string {\n\treturn \"tunnel_key\"\n}\n\nfunc (action *TunnelKeyAction) Attrs() *ActionAttrs {\n\treturn &action.ActionAttrs\n}\n\nfunc NewTunnelKeyAction() *TunnelKeyAction {\n\treturn &TunnelKeyAction{\n\t\tActionAttrs: ActionAttrs{\n\t\t\tAction: TC_ACT_PIPE,\n\t\t},\n\t}\n}\n\ntype SkbEditAction struct {\n\tActionAttrs\n\tQueueMapping *uint16\n\tPType        *uint16\n\tPriority     *uint32\n\tMark         *uint32\n\tMask         *uint32\n}\n\nfunc (action *SkbEditAction) Type() string {\n\treturn \"skbedit\"\n}\n\nfunc (action *SkbEditAction) Attrs() *ActionAttrs {\n\treturn &action.ActionAttrs\n}\n\nfunc NewSkbEditAction() *SkbEditAction {\n\treturn &SkbEditAction{\n\t\tActionAttrs: ActionAttrs{\n\t\t\tAction: TC_ACT_PIPE,\n\t\t},\n\t}\n}\n\ntype PoliceAction struct {\n\tActionAttrs\n\tRate            uint32 // in byte per second\n\tBurst           uint32 // in byte\n\tRCellLog        int\n\tMtu             uint32\n\tMpu             uint16 // in byte\n\tPeakRate        uint32 // in byte per second\n\tPCellLog        int\n\tAvRate          uint32 // in byte per second\n\tOverhead        uint16\n\tLinkLayer       int\n\tExceedAction    TcPolAct\n\tNotExceedAction TcPolAct\n}\n\nfunc (action *PoliceAction) Type() string {\n\treturn \"police\"\n}\n\nfunc (action *PoliceAction) Attrs() *ActionAttrs {\n\treturn &action.ActionAttrs\n}\n\nfunc NewPoliceAction() *PoliceAction {\n\treturn &PoliceAction{\n\t\tRCellLog:        -1,\n\t\tPCellLog:        -1,\n\t\tLinkLayer:       1, // ETHERNET\n\t\tExceedAction:    TC_POLICE_RECLASSIFY,\n\t\tNotExceedAction: TC_POLICE_OK,\n\t}\n}\n\n// MatchAll filters match all packets\ntype MatchAll struct {\n\tFilterAttrs\n\tClassId uint32\n\tActions []Action\n}\n\nfunc (filter *MatchAll) Attrs() *FilterAttrs {\n\treturn &filter.FilterAttrs\n}\n\nfunc (filter *MatchAll) Type() string {\n\treturn \"matchall\"\n}\n\ntype FwFilter struct {\n\tFilterAttrs\n\tClassId uint32\n\tInDev   string\n\tMask    uint32\n\tPolice  *PoliceAction\n\tActions []Action\n}\n\nfunc (filter *FwFilter) Attrs() *FilterAttrs {\n\treturn &filter.FilterAttrs\n}\n\nfunc (filter *FwFilter) Type() string {\n\treturn \"fw\"\n}\n\ntype BpfFilter struct {\n\tFilterAttrs\n\tClassId      uint32\n\tFd           int\n\tName         string\n\tDirectAction bool\n\tId           int\n\tTag          string\n}\n\nfunc (filter *BpfFilter) Type() string {\n\treturn \"bpf\"\n}\n\nfunc (filter *BpfFilter) Attrs() *FilterAttrs {\n\treturn &filter.FilterAttrs\n}\n\n// GenericFilter filters represent types that are not currently understood\n// by this netlink library.\ntype GenericFilter struct {\n\tFilterAttrs\n\tFilterType string\n}\n\nfunc (filter *GenericFilter) Attrs() *FilterAttrs {\n\treturn &filter.FilterAttrs\n}\n\nfunc (filter *GenericFilter) Type() string {\n\treturn filter.FilterType\n}\n\ntype PeditAction struct {\n\tActionAttrs\n\tProto      uint8\n\tSrcMacAddr net.HardwareAddr\n\tDstMacAddr net.HardwareAddr\n\tSrcIP      net.IP\n\tDstIP      net.IP\n\tSrcPort    uint16\n\tDstPort    uint16\n}\n\nfunc (p *PeditAction) Attrs() *ActionAttrs {\n\treturn &p.ActionAttrs\n}\n\nfunc (p *PeditAction) Type() string {\n\treturn \"pedit\"\n}\n\nfunc NewPeditAction() *PeditAction {\n\treturn &PeditAction{\n\t\tActionAttrs: ActionAttrs{\n\t\t\tAction: TC_ACT_PIPE,\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "filter_linux.go",
          "type": "blob",
          "size": 33.2138671875,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// Constants used in TcU32Sel.Flags.\nconst (\n\tTC_U32_TERMINAL  = nl.TC_U32_TERMINAL\n\tTC_U32_OFFSET    = nl.TC_U32_OFFSET\n\tTC_U32_VAROFFSET = nl.TC_U32_VAROFFSET\n\tTC_U32_EAT       = nl.TC_U32_EAT\n)\n\n// Sel of the U32 filters that contains multiple TcU32Key. This is the type\n// alias and the frontend representation of nl.TcU32Sel. It is serialized into\n// canonical nl.TcU32Sel with the appropriate endianness.\ntype TcU32Sel = nl.TcU32Sel\n\n// TcU32Key contained of Sel in the U32 filters. This is the type alias and the\n// frontend representation of nl.TcU32Key. It is serialized into chanonical\n// nl.TcU32Sel with the appropriate endianness.\ntype TcU32Key = nl.TcU32Key\n\n// U32 filters on many packet related properties\ntype U32 struct {\n\tFilterAttrs\n\tClassId    uint32\n\tDivisor    uint32 // Divisor MUST be power of 2.\n\tHash       uint32\n\tLink       uint32\n\tRedirIndex int\n\tSel        *TcU32Sel\n\tActions    []Action\n\tPolice     *PoliceAction\n}\n\nfunc (filter *U32) Attrs() *FilterAttrs {\n\treturn &filter.FilterAttrs\n}\n\nfunc (filter *U32) Type() string {\n\treturn \"u32\"\n}\n\ntype Flower struct {\n\tFilterAttrs\n\tDestIP        net.IP\n\tDestIPMask    net.IPMask\n\tSrcIP         net.IP\n\tSrcIPMask     net.IPMask\n\tEthType       uint16\n\tEncDestIP     net.IP\n\tEncDestIPMask net.IPMask\n\tEncSrcIP      net.IP\n\tEncSrcIPMask  net.IPMask\n\tEncDestPort   uint16\n\tEncKeyId      uint32\n\tSkipHw        bool\n\tSkipSw        bool\n\tIPProto       *nl.IPProto\n\tDestPort      uint16\n\tSrcPort       uint16\n\n\tActions []Action\n}\n\nfunc (filter *Flower) Attrs() *FilterAttrs {\n\treturn &filter.FilterAttrs\n}\n\nfunc (filter *Flower) Type() string {\n\treturn \"flower\"\n}\n\nfunc (filter *Flower) encodeIP(parent *nl.RtAttr, ip net.IP, mask net.IPMask, v4Type, v6Type int, v4MaskType, v6MaskType int) {\n\tipType := v4Type\n\tmaskType := v4MaskType\n\n\tencodeMask := mask\n\tif mask == nil {\n\t\tencodeMask = net.CIDRMask(32, 32)\n\t}\n\tv4IP := ip.To4()\n\tif v4IP == nil {\n\t\tipType = v6Type\n\t\tmaskType = v6MaskType\n\t\tif mask == nil {\n\t\t\tencodeMask = net.CIDRMask(128, 128)\n\t\t}\n\t} else {\n\t\tip = v4IP\n\t}\n\n\tparent.AddRtAttr(ipType, ip)\n\tparent.AddRtAttr(maskType, encodeMask)\n}\n\nfunc (filter *Flower) encode(parent *nl.RtAttr) error {\n\tif filter.EthType != 0 {\n\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_ETH_TYPE, htons(filter.EthType))\n\t}\n\tif filter.SrcIP != nil {\n\t\tfilter.encodeIP(parent, filter.SrcIP, filter.SrcIPMask,\n\t\t\tnl.TCA_FLOWER_KEY_IPV4_SRC, nl.TCA_FLOWER_KEY_IPV6_SRC,\n\t\t\tnl.TCA_FLOWER_KEY_IPV4_SRC_MASK, nl.TCA_FLOWER_KEY_IPV6_SRC_MASK)\n\t}\n\tif filter.DestIP != nil {\n\t\tfilter.encodeIP(parent, filter.DestIP, filter.DestIPMask,\n\t\t\tnl.TCA_FLOWER_KEY_IPV4_DST, nl.TCA_FLOWER_KEY_IPV6_DST,\n\t\t\tnl.TCA_FLOWER_KEY_IPV4_DST_MASK, nl.TCA_FLOWER_KEY_IPV6_DST_MASK)\n\t}\n\tif filter.EncSrcIP != nil {\n\t\tfilter.encodeIP(parent, filter.EncSrcIP, filter.EncSrcIPMask,\n\t\t\tnl.TCA_FLOWER_KEY_ENC_IPV4_SRC, nl.TCA_FLOWER_KEY_ENC_IPV6_SRC,\n\t\t\tnl.TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK, nl.TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK)\n\t}\n\tif filter.EncDestIP != nil {\n\t\tfilter.encodeIP(parent, filter.EncDestIP, filter.EncSrcIPMask,\n\t\t\tnl.TCA_FLOWER_KEY_ENC_IPV4_DST, nl.TCA_FLOWER_KEY_ENC_IPV6_DST,\n\t\t\tnl.TCA_FLOWER_KEY_ENC_IPV4_DST_MASK, nl.TCA_FLOWER_KEY_ENC_IPV6_DST_MASK)\n\t}\n\tif filter.EncDestPort != 0 {\n\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_ENC_UDP_DST_PORT, htons(filter.EncDestPort))\n\t}\n\tif filter.EncKeyId != 0 {\n\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_ENC_KEY_ID, htonl(filter.EncKeyId))\n\t}\n\tif filter.IPProto != nil {\n\t\tipproto := *filter.IPProto\n\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_IP_PROTO, ipproto.Serialize())\n\t\tif filter.SrcPort != 0 {\n\t\t\tswitch ipproto {\n\t\t\tcase nl.IPPROTO_TCP:\n\t\t\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_TCP_SRC, htons(filter.SrcPort))\n\t\t\tcase nl.IPPROTO_UDP:\n\t\t\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_UDP_SRC, htons(filter.SrcPort))\n\t\t\tcase nl.IPPROTO_SCTP:\n\t\t\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_SCTP_SRC, htons(filter.SrcPort))\n\t\t\t}\n\t\t}\n\t\tif filter.DestPort != 0 {\n\t\t\tswitch ipproto {\n\t\t\tcase nl.IPPROTO_TCP:\n\t\t\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_TCP_DST, htons(filter.DestPort))\n\t\t\tcase nl.IPPROTO_UDP:\n\t\t\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_UDP_DST, htons(filter.DestPort))\n\t\t\tcase nl.IPPROTO_SCTP:\n\t\t\t\tparent.AddRtAttr(nl.TCA_FLOWER_KEY_SCTP_DST, htons(filter.DestPort))\n\t\t\t}\n\t\t}\n\t}\n\n\tvar flags uint32 = 0\n\tif filter.SkipHw {\n\t\tflags |= nl.TCA_CLS_FLAGS_SKIP_HW\n\t}\n\tif filter.SkipSw {\n\t\tflags |= nl.TCA_CLS_FLAGS_SKIP_SW\n\t}\n\tparent.AddRtAttr(nl.TCA_FLOWER_FLAGS, htonl(flags))\n\n\tactionsAttr := parent.AddRtAttr(nl.TCA_FLOWER_ACT, nil)\n\tif err := EncodeActions(actionsAttr, filter.Actions); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (filter *Flower) decode(data []syscall.NetlinkRouteAttr) error {\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_FLOWER_KEY_ETH_TYPE:\n\t\t\tfilter.EthType = ntohs(datum.Value)\n\t\tcase nl.TCA_FLOWER_KEY_IPV4_SRC, nl.TCA_FLOWER_KEY_IPV6_SRC:\n\t\t\tfilter.SrcIP = datum.Value\n\t\tcase nl.TCA_FLOWER_KEY_IPV4_SRC_MASK, nl.TCA_FLOWER_KEY_IPV6_SRC_MASK:\n\t\t\tfilter.SrcIPMask = datum.Value\n\t\tcase nl.TCA_FLOWER_KEY_IPV4_DST, nl.TCA_FLOWER_KEY_IPV6_DST:\n\t\t\tfilter.DestIP = datum.Value\n\t\tcase nl.TCA_FLOWER_KEY_IPV4_DST_MASK, nl.TCA_FLOWER_KEY_IPV6_DST_MASK:\n\t\t\tfilter.DestIPMask = datum.Value\n\t\tcase nl.TCA_FLOWER_KEY_ENC_IPV4_SRC, nl.TCA_FLOWER_KEY_ENC_IPV6_SRC:\n\t\t\tfilter.EncSrcIP = datum.Value\n\t\tcase nl.TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK, nl.TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK:\n\t\t\tfilter.EncSrcIPMask = datum.Value\n\t\tcase nl.TCA_FLOWER_KEY_ENC_IPV4_DST, nl.TCA_FLOWER_KEY_ENC_IPV6_DST:\n\t\t\tfilter.EncDestIP = datum.Value\n\t\tcase nl.TCA_FLOWER_KEY_ENC_IPV4_DST_MASK, nl.TCA_FLOWER_KEY_ENC_IPV6_DST_MASK:\n\t\t\tfilter.EncDestIPMask = datum.Value\n\t\tcase nl.TCA_FLOWER_KEY_ENC_UDP_DST_PORT:\n\t\t\tfilter.EncDestPort = ntohs(datum.Value)\n\t\tcase nl.TCA_FLOWER_KEY_ENC_KEY_ID:\n\t\t\tfilter.EncKeyId = ntohl(datum.Value)\n\t\tcase nl.TCA_FLOWER_KEY_IP_PROTO:\n\t\t\tval := new(nl.IPProto)\n\t\t\t*val = nl.IPProto(datum.Value[0])\n\t\t\tfilter.IPProto = val\n\t\tcase nl.TCA_FLOWER_KEY_TCP_SRC, nl.TCA_FLOWER_KEY_UDP_SRC, nl.TCA_FLOWER_KEY_SCTP_SRC:\n\t\t\tfilter.SrcPort = ntohs(datum.Value)\n\t\tcase nl.TCA_FLOWER_KEY_TCP_DST, nl.TCA_FLOWER_KEY_UDP_DST, nl.TCA_FLOWER_KEY_SCTP_DST:\n\t\t\tfilter.DestPort = ntohs(datum.Value)\n\t\tcase nl.TCA_FLOWER_ACT:\n\t\t\ttables, err := nl.ParseRouteAttr(datum.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfilter.Actions, err = parseActions(tables)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase nl.TCA_FLOWER_FLAGS:\n\t\t\tattr := nl.DeserializeUint32Bitfield(datum.Value)\n\t\t\tskipSw := attr.Value & nl.TCA_CLS_FLAGS_SKIP_HW\n\t\t\tskipHw := attr.Value & nl.TCA_CLS_FLAGS_SKIP_SW\n\t\t\tif skipSw != 0 {\n\t\t\t\tfilter.SkipSw = true\n\t\t\t}\n\t\t\tif skipHw != 0 {\n\t\t\t\tfilter.SkipHw = true\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// FilterDel will delete a filter from the system.\n// Equivalent to: `tc filter del $filter`\nfunc FilterDel(filter Filter) error {\n\treturn pkgHandle.FilterDel(filter)\n}\n\n// FilterDel will delete a filter from the system.\n// Equivalent to: `tc filter del $filter`\nfunc (h *Handle) FilterDel(filter Filter) error {\n\treturn h.filterModify(filter, unix.RTM_DELTFILTER, 0)\n}\n\n// FilterAdd will add a filter to the system.\n// Equivalent to: `tc filter add $filter`\nfunc FilterAdd(filter Filter) error {\n\treturn pkgHandle.FilterAdd(filter)\n}\n\n// FilterAdd will add a filter to the system.\n// Equivalent to: `tc filter add $filter`\nfunc (h *Handle) FilterAdd(filter Filter) error {\n\treturn h.filterModify(filter, unix.RTM_NEWTFILTER, unix.NLM_F_CREATE|unix.NLM_F_EXCL)\n}\n\n// FilterReplace will replace a filter.\n// Equivalent to: `tc filter replace $filter`\nfunc FilterReplace(filter Filter) error {\n\treturn pkgHandle.FilterReplace(filter)\n}\n\n// FilterReplace will replace a filter.\n// Equivalent to: `tc filter replace $filter`\nfunc (h *Handle) FilterReplace(filter Filter) error {\n\treturn h.filterModify(filter, unix.RTM_NEWTFILTER, unix.NLM_F_CREATE)\n}\n\nfunc (h *Handle) filterModify(filter Filter, proto, flags int) error {\n\treq := h.newNetlinkRequest(proto, flags|unix.NLM_F_ACK)\n\tbase := filter.Attrs()\n\tmsg := &nl.TcMsg{\n\t\tFamily:  nl.FAMILY_ALL,\n\t\tIfindex: int32(base.LinkIndex),\n\t\tHandle:  base.Handle,\n\t\tParent:  base.Parent,\n\t\tInfo:    MakeHandle(base.Priority, nl.Swap16(base.Protocol)),\n\t}\n\treq.AddData(msg)\n\tif filter.Attrs().Chain != nil {\n\t\treq.AddData(nl.NewRtAttr(nl.TCA_CHAIN, nl.Uint32Attr(*filter.Attrs().Chain)))\n\t}\n\treq.AddData(nl.NewRtAttr(nl.TCA_KIND, nl.ZeroTerminated(filter.Type())))\n\n\toptions := nl.NewRtAttr(nl.TCA_OPTIONS, nil)\n\n\tswitch filter := filter.(type) {\n\tcase *U32:\n\t\tsel := filter.Sel\n\t\tif sel == nil {\n\t\t\t// match all\n\t\t\tsel = &nl.TcU32Sel{\n\t\t\t\tNkeys: 1,\n\t\t\t\tFlags: nl.TC_U32_TERMINAL,\n\t\t\t}\n\t\t\tsel.Keys = append(sel.Keys, nl.TcU32Key{})\n\t\t}\n\n\t\tif native != networkOrder {\n\t\t\t// Copy TcU32Sel.\n\t\t\tcSel := *sel\n\t\t\tkeys := make([]nl.TcU32Key, cap(sel.Keys))\n\t\t\tcopy(keys, sel.Keys)\n\t\t\tcSel.Keys = keys\n\t\t\tsel = &cSel\n\n\t\t\t// Handle the endianness of attributes\n\t\t\tsel.Offmask = native.Uint16(htons(sel.Offmask))\n\t\t\tsel.Hmask = native.Uint32(htonl(sel.Hmask))\n\t\t\tfor i, key := range sel.Keys {\n\t\t\t\tsel.Keys[i].Mask = native.Uint32(htonl(key.Mask))\n\t\t\t\tsel.Keys[i].Val = native.Uint32(htonl(key.Val))\n\t\t\t}\n\t\t}\n\t\tsel.Nkeys = uint8(len(sel.Keys))\n\t\toptions.AddRtAttr(nl.TCA_U32_SEL, sel.Serialize())\n\t\tif filter.ClassId != 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_U32_CLASSID, nl.Uint32Attr(filter.ClassId))\n\t\t}\n\t\tif filter.Divisor != 0 {\n\t\t\tif (filter.Divisor-1)&filter.Divisor != 0 {\n\t\t\t\treturn fmt.Errorf(\"illegal divisor %d. Must be a power of 2\", filter.Divisor)\n\t\t\t}\n\t\t\toptions.AddRtAttr(nl.TCA_U32_DIVISOR, nl.Uint32Attr(filter.Divisor))\n\t\t}\n\t\tif filter.Hash != 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_U32_HASH, nl.Uint32Attr(filter.Hash))\n\t\t}\n\t\tif filter.Link != 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_U32_LINK, nl.Uint32Attr(filter.Link))\n\t\t}\n\t\tif filter.Police != nil {\n\t\t\tpolice := options.AddRtAttr(nl.TCA_U32_POLICE, nil)\n\t\t\tif err := encodePolice(police, filter.Police); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tactionsAttr := options.AddRtAttr(nl.TCA_U32_ACT, nil)\n\t\t// backwards compatibility\n\t\tif filter.RedirIndex != 0 {\n\t\t\tfilter.Actions = append([]Action{NewMirredAction(filter.RedirIndex)}, filter.Actions...)\n\t\t}\n\t\tif err := EncodeActions(actionsAttr, filter.Actions); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase *FwFilter:\n\t\tif filter.Mask != 0 {\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, filter.Mask)\n\t\t\toptions.AddRtAttr(nl.TCA_FW_MASK, b)\n\t\t}\n\t\tif filter.InDev != \"\" {\n\t\t\toptions.AddRtAttr(nl.TCA_FW_INDEV, nl.ZeroTerminated(filter.InDev))\n\t\t}\n\t\tif filter.Police != nil {\n\t\t\tpolice := options.AddRtAttr(nl.TCA_FW_POLICE, nil)\n\t\t\tif err := encodePolice(police, filter.Police); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif filter.ClassId != 0 {\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, filter.ClassId)\n\t\t\toptions.AddRtAttr(nl.TCA_FW_CLASSID, b)\n\t\t}\n\t\tactionsAttr := options.AddRtAttr(nl.TCA_FW_ACT, nil)\n\t\tif err := EncodeActions(actionsAttr, filter.Actions); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase *BpfFilter:\n\t\tvar bpfFlags uint32\n\t\tif filter.ClassId != 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_BPF_CLASSID, nl.Uint32Attr(filter.ClassId))\n\t\t}\n\t\tif filter.Fd >= 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_BPF_FD, nl.Uint32Attr((uint32(filter.Fd))))\n\t\t}\n\t\tif filter.Name != \"\" {\n\t\t\toptions.AddRtAttr(nl.TCA_BPF_NAME, nl.ZeroTerminated(filter.Name))\n\t\t}\n\t\tif filter.DirectAction {\n\t\t\tbpfFlags |= nl.TCA_BPF_FLAG_ACT_DIRECT\n\t\t}\n\t\toptions.AddRtAttr(nl.TCA_BPF_FLAGS, nl.Uint32Attr(bpfFlags))\n\tcase *MatchAll:\n\t\tactionsAttr := options.AddRtAttr(nl.TCA_MATCHALL_ACT, nil)\n\t\tif err := EncodeActions(actionsAttr, filter.Actions); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif filter.ClassId != 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_MATCHALL_CLASSID, nl.Uint32Attr(filter.ClassId))\n\t\t}\n\tcase *Flower:\n\t\tif err := filter.encode(options); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treq.AddData(options)\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// FilterList gets a list of filters in the system.\n// Equivalent to: `tc filter show`.\n//\n// Generally returns nothing if link and parent are not specified.\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc FilterList(link Link, parent uint32) ([]Filter, error) {\n\treturn pkgHandle.FilterList(link, parent)\n}\n\n// FilterList gets a list of filters in the system.\n// Equivalent to: `tc filter show`.\n//\n// Generally returns nothing if link and parent are not specified.\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) FilterList(link Link, parent uint32) ([]Filter, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETTFILTER, unix.NLM_F_DUMP)\n\tmsg := &nl.TcMsg{\n\t\tFamily: nl.FAMILY_ALL,\n\t\tParent: parent,\n\t}\n\tif link != nil {\n\t\tbase := link.Attrs()\n\t\th.ensureIndex(base)\n\t\tmsg.Ifindex = int32(base.Index)\n\t}\n\treq.AddData(msg)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWTFILTER)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res []Filter\n\tfor _, m := range msgs {\n\t\tmsg := nl.DeserializeTcMsg(m)\n\n\t\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tbase := FilterAttrs{\n\t\t\tLinkIndex: int(msg.Ifindex),\n\t\t\tHandle:    msg.Handle,\n\t\t\tParent:    msg.Parent,\n\t\t}\n\t\tbase.Priority, base.Protocol = MajorMinor(msg.Info)\n\t\tbase.Protocol = nl.Swap16(base.Protocol)\n\n\t\tvar filter Filter\n\t\tfilterType := \"\"\n\t\tdetailed := false\n\t\tfor _, attr := range attrs {\n\t\t\tswitch attr.Attr.Type {\n\t\t\tcase nl.TCA_KIND:\n\t\t\t\tfilterType = string(attr.Value[:len(attr.Value)-1])\n\t\t\t\tswitch filterType {\n\t\t\t\tcase \"u32\":\n\t\t\t\t\tfilter = &U32{}\n\t\t\t\tcase \"fw\":\n\t\t\t\t\tfilter = &FwFilter{}\n\t\t\t\tcase \"bpf\":\n\t\t\t\t\tfilter = &BpfFilter{}\n\t\t\t\tcase \"matchall\":\n\t\t\t\t\tfilter = &MatchAll{}\n\t\t\t\tcase \"flower\":\n\t\t\t\t\tfilter = &Flower{}\n\t\t\t\tdefault:\n\t\t\t\t\tfilter = &GenericFilter{FilterType: filterType}\n\t\t\t\t}\n\t\t\tcase nl.TCA_OPTIONS:\n\t\t\t\tdata, err := nl.ParseRouteAttr(attr.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tswitch filterType {\n\t\t\t\tcase \"u32\":\n\t\t\t\t\tdetailed, err = parseU32Data(filter, data)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"fw\":\n\t\t\t\t\tdetailed, err = parseFwData(filter, data)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"bpf\":\n\t\t\t\t\tdetailed, err = parseBpfData(filter, data)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"matchall\":\n\t\t\t\t\tdetailed, err = parseMatchAllData(filter, data)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"flower\":\n\t\t\t\t\tdetailed, err = parseFlowerData(filter, data)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdetailed = true\n\t\t\t\t}\n\t\t\tcase nl.TCA_CHAIN:\n\t\t\t\tval := new(uint32)\n\t\t\t\t*val = native.Uint32(attr.Value)\n\t\t\t\tbase.Chain = val\n\t\t\t}\n\t\t}\n\t\t// only return the detailed version of the filter\n\t\tif detailed {\n\t\t\t*filter.Attrs() = base\n\t\t\tres = append(res, filter)\n\t\t}\n\t}\n\n\treturn res, executeErr\n}\n\nfunc toTcGen(attrs *ActionAttrs, tcgen *nl.TcGen) {\n\ttcgen.Index = uint32(attrs.Index)\n\ttcgen.Capab = uint32(attrs.Capab)\n\ttcgen.Action = int32(attrs.Action)\n\ttcgen.Refcnt = int32(attrs.Refcnt)\n\ttcgen.Bindcnt = int32(attrs.Bindcnt)\n}\n\nfunc toAttrs(tcgen *nl.TcGen, attrs *ActionAttrs) {\n\tattrs.Index = int(tcgen.Index)\n\tattrs.Capab = int(tcgen.Capab)\n\tattrs.Action = TcAct(tcgen.Action)\n\tattrs.Refcnt = int(tcgen.Refcnt)\n\tattrs.Bindcnt = int(tcgen.Bindcnt)\n}\n\nfunc toTimeStamp(tcf *nl.Tcf) *ActionTimestamp {\n\treturn &ActionTimestamp{\n\t\tInstalled: tcf.Install,\n\t\tLastUsed:  tcf.LastUse,\n\t\tExpires:   tcf.Expires,\n\t\tFirstUsed: tcf.FirstUse}\n}\n\nfunc encodePolice(attr *nl.RtAttr, action *PoliceAction) error {\n\tvar rtab [256]uint32\n\tvar ptab [256]uint32\n\tpolice := nl.TcPolice{}\n\tpolice.Index = uint32(action.Attrs().Index)\n\tpolice.Bindcnt = int32(action.Attrs().Bindcnt)\n\tpolice.Capab = uint32(action.Attrs().Capab)\n\tpolice.Refcnt = int32(action.Attrs().Refcnt)\n\tpolice.Rate.Rate = action.Rate\n\tpolice.PeakRate.Rate = action.PeakRate\n\tpolice.Action = int32(action.ExceedAction)\n\n\tif police.Rate.Rate != 0 {\n\t\tpolice.Rate.Mpu = action.Mpu\n\t\tpolice.Rate.Overhead = action.Overhead\n\t\tif CalcRtable(&police.Rate, rtab[:], action.RCellLog, action.Mtu, action.LinkLayer) < 0 {\n\t\t\treturn errors.New(\"TBF: failed to calculate rate table\")\n\t\t}\n\t\tpolice.Burst = Xmittime(uint64(police.Rate.Rate), action.Burst)\n\t}\n\n\tpolice.Mtu = action.Mtu\n\tif police.PeakRate.Rate != 0 {\n\t\tpolice.PeakRate.Mpu = action.Mpu\n\t\tpolice.PeakRate.Overhead = action.Overhead\n\t\tif CalcRtable(&police.PeakRate, ptab[:], action.PCellLog, action.Mtu, action.LinkLayer) < 0 {\n\t\t\treturn errors.New(\"POLICE: failed to calculate peak rate table\")\n\t\t}\n\t}\n\n\tattr.AddRtAttr(nl.TCA_POLICE_TBF, police.Serialize())\n\tif police.Rate.Rate != 0 {\n\t\tattr.AddRtAttr(nl.TCA_POLICE_RATE, SerializeRtab(rtab))\n\t}\n\tif police.PeakRate.Rate != 0 {\n\t\tattr.AddRtAttr(nl.TCA_POLICE_PEAKRATE, SerializeRtab(ptab))\n\t}\n\tif action.AvRate != 0 {\n\t\tattr.AddRtAttr(nl.TCA_POLICE_AVRATE, nl.Uint32Attr(action.AvRate))\n\t}\n\tif action.NotExceedAction != 0 {\n\t\tattr.AddRtAttr(nl.TCA_POLICE_RESULT, nl.Uint32Attr(uint32(action.NotExceedAction)))\n\t}\n\n\treturn nil\n}\n\nfunc EncodeActions(attr *nl.RtAttr, actions []Action) error {\n\ttabIndex := int(nl.TCA_ACT_TAB)\n\n\tfor _, action := range actions {\n\t\tswitch action := action.(type) {\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown action type %s\", action.Type())\n\t\tcase *PoliceAction:\n\t\t\ttable := attr.AddRtAttr(tabIndex, nil)\n\t\t\ttabIndex++\n\t\t\ttable.AddRtAttr(nl.TCA_ACT_KIND, nl.ZeroTerminated(\"police\"))\n\t\t\taopts := table.AddRtAttr(nl.TCA_ACT_OPTIONS, nil)\n\t\t\tif err := encodePolice(aopts, action); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase *MirredAction:\n\t\t\ttable := attr.AddRtAttr(tabIndex, nil)\n\t\t\ttabIndex++\n\t\t\ttable.AddRtAttr(nl.TCA_ACT_KIND, nl.ZeroTerminated(\"mirred\"))\n\t\t\taopts := table.AddRtAttr(nl.TCA_ACT_OPTIONS, nil)\n\t\t\tmirred := nl.TcMirred{\n\t\t\t\tEaction: int32(action.MirredAction),\n\t\t\t\tIfindex: uint32(action.Ifindex),\n\t\t\t}\n\t\t\ttoTcGen(action.Attrs(), &mirred.TcGen)\n\t\t\taopts.AddRtAttr(nl.TCA_MIRRED_PARMS, mirred.Serialize())\n\t\tcase *TunnelKeyAction:\n\t\t\ttable := attr.AddRtAttr(tabIndex, nil)\n\t\t\ttabIndex++\n\t\t\ttable.AddRtAttr(nl.TCA_ACT_KIND, nl.ZeroTerminated(\"tunnel_key\"))\n\t\t\taopts := table.AddRtAttr(nl.TCA_ACT_OPTIONS, nil)\n\t\t\ttun := nl.TcTunnelKey{\n\t\t\t\tAction: int32(action.Action),\n\t\t\t}\n\t\t\ttoTcGen(action.Attrs(), &tun.TcGen)\n\t\t\taopts.AddRtAttr(nl.TCA_TUNNEL_KEY_PARMS, tun.Serialize())\n\t\t\tif action.Action == TCA_TUNNEL_KEY_SET {\n\t\t\t\taopts.AddRtAttr(nl.TCA_TUNNEL_KEY_ENC_KEY_ID, htonl(action.KeyID))\n\t\t\t\tif v4 := action.SrcAddr.To4(); v4 != nil {\n\t\t\t\t\taopts.AddRtAttr(nl.TCA_TUNNEL_KEY_ENC_IPV4_SRC, v4[:])\n\t\t\t\t} else if v6 := action.SrcAddr.To16(); v6 != nil {\n\t\t\t\t\taopts.AddRtAttr(nl.TCA_TUNNEL_KEY_ENC_IPV6_SRC, v6[:])\n\t\t\t\t} else {\n\t\t\t\t\treturn fmt.Errorf(\"invalid src addr %s for tunnel_key action\", action.SrcAddr)\n\t\t\t\t}\n\t\t\t\tif v4 := action.DstAddr.To4(); v4 != nil {\n\t\t\t\t\taopts.AddRtAttr(nl.TCA_TUNNEL_KEY_ENC_IPV4_DST, v4[:])\n\t\t\t\t} else if v6 := action.DstAddr.To16(); v6 != nil {\n\t\t\t\t\taopts.AddRtAttr(nl.TCA_TUNNEL_KEY_ENC_IPV6_DST, v6[:])\n\t\t\t\t} else {\n\t\t\t\t\treturn fmt.Errorf(\"invalid dst addr %s for tunnel_key action\", action.DstAddr)\n\t\t\t\t}\n\t\t\t\tif action.DestPort != 0 {\n\t\t\t\t\taopts.AddRtAttr(nl.TCA_TUNNEL_KEY_ENC_DST_PORT, htons(action.DestPort))\n\t\t\t\t}\n\t\t\t}\n\t\tcase *SkbEditAction:\n\t\t\ttable := attr.AddRtAttr(tabIndex, nil)\n\t\t\ttabIndex++\n\t\t\ttable.AddRtAttr(nl.TCA_ACT_KIND, nl.ZeroTerminated(\"skbedit\"))\n\t\t\taopts := table.AddRtAttr(nl.TCA_ACT_OPTIONS, nil)\n\t\t\tskbedit := nl.TcSkbEdit{}\n\t\t\ttoTcGen(action.Attrs(), &skbedit.TcGen)\n\t\t\taopts.AddRtAttr(nl.TCA_SKBEDIT_PARMS, skbedit.Serialize())\n\t\t\tif action.QueueMapping != nil {\n\t\t\t\taopts.AddRtAttr(nl.TCA_SKBEDIT_QUEUE_MAPPING, nl.Uint16Attr(*action.QueueMapping))\n\t\t\t}\n\t\t\tif action.Priority != nil {\n\t\t\t\taopts.AddRtAttr(nl.TCA_SKBEDIT_PRIORITY, nl.Uint32Attr(*action.Priority))\n\t\t\t}\n\t\t\tif action.PType != nil {\n\t\t\t\taopts.AddRtAttr(nl.TCA_SKBEDIT_PTYPE, nl.Uint16Attr(*action.PType))\n\t\t\t}\n\t\t\tif action.Mark != nil {\n\t\t\t\taopts.AddRtAttr(nl.TCA_SKBEDIT_MARK, nl.Uint32Attr(*action.Mark))\n\t\t\t}\n\t\t\tif action.Mask != nil {\n\t\t\t\taopts.AddRtAttr(nl.TCA_SKBEDIT_MASK, nl.Uint32Attr(*action.Mask))\n\t\t\t}\n\t\tcase *ConnmarkAction:\n\t\t\ttable := attr.AddRtAttr(tabIndex, nil)\n\t\t\ttabIndex++\n\t\t\ttable.AddRtAttr(nl.TCA_ACT_KIND, nl.ZeroTerminated(\"connmark\"))\n\t\t\taopts := table.AddRtAttr(nl.TCA_ACT_OPTIONS, nil)\n\t\t\tconnmark := nl.TcConnmark{\n\t\t\t\tZone: action.Zone,\n\t\t\t}\n\t\t\ttoTcGen(action.Attrs(), &connmark.TcGen)\n\t\t\taopts.AddRtAttr(nl.TCA_CONNMARK_PARMS, connmark.Serialize())\n\t\tcase *CsumAction:\n\t\t\ttable := attr.AddRtAttr(tabIndex, nil)\n\t\t\ttabIndex++\n\t\t\ttable.AddRtAttr(nl.TCA_ACT_KIND, nl.ZeroTerminated(\"csum\"))\n\t\t\taopts := table.AddRtAttr(nl.TCA_ACT_OPTIONS, nil)\n\t\t\tcsum := nl.TcCsum{\n\t\t\t\tUpdateFlags: uint32(action.UpdateFlags),\n\t\t\t}\n\t\t\ttoTcGen(action.Attrs(), &csum.TcGen)\n\t\t\taopts.AddRtAttr(nl.TCA_CSUM_PARMS, csum.Serialize())\n\t\tcase *BpfAction:\n\t\t\ttable := attr.AddRtAttr(tabIndex, nil)\n\t\t\ttabIndex++\n\t\t\ttable.AddRtAttr(nl.TCA_ACT_KIND, nl.ZeroTerminated(\"bpf\"))\n\t\t\taopts := table.AddRtAttr(nl.TCA_ACT_OPTIONS, nil)\n\t\t\tgen := nl.TcGen{}\n\t\t\ttoTcGen(action.Attrs(), &gen)\n\t\t\taopts.AddRtAttr(nl.TCA_ACT_BPF_PARMS, gen.Serialize())\n\t\t\taopts.AddRtAttr(nl.TCA_ACT_BPF_FD, nl.Uint32Attr(uint32(action.Fd)))\n\t\t\taopts.AddRtAttr(nl.TCA_ACT_BPF_NAME, nl.ZeroTerminated(action.Name))\n\t\tcase *GenericAction:\n\t\t\ttable := attr.AddRtAttr(tabIndex, nil)\n\t\t\ttabIndex++\n\t\t\ttable.AddRtAttr(nl.TCA_ACT_KIND, nl.ZeroTerminated(\"gact\"))\n\t\t\taopts := table.AddRtAttr(nl.TCA_ACT_OPTIONS, nil)\n\t\t\tgen := nl.TcGen{}\n\t\t\ttoTcGen(action.Attrs(), &gen)\n\t\t\taopts.AddRtAttr(nl.TCA_GACT_PARMS, gen.Serialize())\n\t\tcase *PeditAction:\n\t\t\ttable := attr.AddRtAttr(tabIndex, nil)\n\t\t\ttabIndex++\n\t\t\tpedit := nl.TcPedit{}\n\t\t\tif action.SrcMacAddr != nil {\n\t\t\t\tpedit.SetEthSrc(action.SrcMacAddr)\n\t\t\t}\n\t\t\tif action.DstMacAddr != nil {\n\t\t\t\tpedit.SetEthDst(action.DstMacAddr)\n\t\t\t}\n\t\t\tif action.SrcIP != nil {\n\t\t\t\tpedit.SetSrcIP(action.SrcIP)\n\t\t\t}\n\t\t\tif action.DstIP != nil {\n\t\t\t\tpedit.SetDstIP(action.DstIP)\n\t\t\t}\n\t\t\tif action.SrcPort != 0 {\n\t\t\t\tpedit.SetSrcPort(action.SrcPort, action.Proto)\n\t\t\t}\n\t\t\tif action.DstPort != 0 {\n\t\t\t\tpedit.SetDstPort(action.DstPort, action.Proto)\n\t\t\t}\n\t\t\tpedit.Encode(table)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parsePolice(data syscall.NetlinkRouteAttr, police *PoliceAction) {\n\tswitch data.Attr.Type {\n\tcase nl.TCA_POLICE_RESULT:\n\t\tpolice.NotExceedAction = TcPolAct(native.Uint32(data.Value[0:4]))\n\tcase nl.TCA_POLICE_AVRATE:\n\t\tpolice.AvRate = native.Uint32(data.Value[0:4])\n\tcase nl.TCA_POLICE_TBF:\n\t\tp := *nl.DeserializeTcPolice(data.Value)\n\t\tpolice.ActionAttrs = ActionAttrs{}\n\t\tpolice.Attrs().Index = int(p.Index)\n\t\tpolice.Attrs().Bindcnt = int(p.Bindcnt)\n\t\tpolice.Attrs().Capab = int(p.Capab)\n\t\tpolice.Attrs().Refcnt = int(p.Refcnt)\n\t\tpolice.ExceedAction = TcPolAct(p.Action)\n\t\tpolice.Rate = p.Rate.Rate\n\t\tpolice.PeakRate = p.PeakRate.Rate\n\t\tpolice.Burst = Xmitsize(uint64(p.Rate.Rate), p.Burst)\n\t\tpolice.Mtu = p.Mtu\n\t\tpolice.LinkLayer = int(p.Rate.Linklayer) & nl.TC_LINKLAYER_MASK\n\t\tpolice.Overhead = p.Rate.Overhead\n\t}\n}\n\nfunc parseActions(tables []syscall.NetlinkRouteAttr) ([]Action, error) {\n\tvar actions []Action\n\tfor _, table := range tables {\n\t\tvar action Action\n\t\tvar actionType string\n\t\tvar actionnStatistic *ActionStatistic\n\t\tvar actionTimestamp *ActionTimestamp\n\t\taattrs, err := nl.ParseRouteAttr(table.Value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tnextattr:\n\t\tfor _, aattr := range aattrs {\n\t\t\tswitch aattr.Attr.Type {\n\t\t\tcase nl.TCA_KIND:\n\t\t\t\tactionType = string(aattr.Value[:len(aattr.Value)-1])\n\t\t\t\t// only parse if the action is mirred or bpf\n\t\t\t\tswitch actionType {\n\t\t\t\tcase \"mirred\":\n\t\t\t\t\taction = &MirredAction{}\n\t\t\t\tcase \"bpf\":\n\t\t\t\t\taction = &BpfAction{}\n\t\t\t\tcase \"connmark\":\n\t\t\t\t\taction = &ConnmarkAction{}\n\t\t\t\tcase \"csum\":\n\t\t\t\t\taction = &CsumAction{}\n\t\t\t\tcase \"gact\":\n\t\t\t\t\taction = &GenericAction{}\n\t\t\t\tcase \"tunnel_key\":\n\t\t\t\t\taction = &TunnelKeyAction{}\n\t\t\t\tcase \"skbedit\":\n\t\t\t\t\taction = &SkbEditAction{}\n\t\t\t\tcase \"police\":\n\t\t\t\t\taction = &PoliceAction{}\n\t\t\t\tcase \"pedit\":\n\t\t\t\t\taction = &PeditAction{}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak nextattr\n\t\t\t\t}\n\t\t\tcase nl.TCA_OPTIONS:\n\t\t\t\tadata, err := nl.ParseRouteAttr(aattr.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tfor _, adatum := range adata {\n\t\t\t\t\tswitch actionType {\n\t\t\t\t\tcase \"mirred\":\n\t\t\t\t\t\tswitch adatum.Attr.Type {\n\t\t\t\t\t\tcase nl.TCA_MIRRED_PARMS:\n\t\t\t\t\t\t\tmirred := *nl.DeserializeTcMirred(adatum.Value)\n\t\t\t\t\t\t\taction.(*MirredAction).ActionAttrs = ActionAttrs{}\n\t\t\t\t\t\t\ttoAttrs(&mirred.TcGen, action.Attrs())\n\t\t\t\t\t\t\taction.(*MirredAction).Ifindex = int(mirred.Ifindex)\n\t\t\t\t\t\t\taction.(*MirredAction).MirredAction = MirredAct(mirred.Eaction)\n\t\t\t\t\t\tcase nl.TCA_MIRRED_TM:\n\t\t\t\t\t\t\ttcTs := nl.DeserializeTcf(adatum.Value)\n\t\t\t\t\t\t\tactionTimestamp = toTimeStamp(tcTs)\n\t\t\t\t\t\t}\n\n\t\t\t\t\tcase \"tunnel_key\":\n\t\t\t\t\t\tswitch adatum.Attr.Type {\n\t\t\t\t\t\tcase nl.TCA_TUNNEL_KEY_PARMS:\n\t\t\t\t\t\t\ttun := *nl.DeserializeTunnelKey(adatum.Value)\n\t\t\t\t\t\t\taction.(*TunnelKeyAction).ActionAttrs = ActionAttrs{}\n\t\t\t\t\t\t\ttoAttrs(&tun.TcGen, action.Attrs())\n\t\t\t\t\t\t\taction.(*TunnelKeyAction).Action = TunnelKeyAct(tun.Action)\n\t\t\t\t\t\tcase nl.TCA_TUNNEL_KEY_ENC_KEY_ID:\n\t\t\t\t\t\t\taction.(*TunnelKeyAction).KeyID = networkOrder.Uint32(adatum.Value[0:4])\n\t\t\t\t\t\tcase nl.TCA_TUNNEL_KEY_ENC_IPV6_SRC, nl.TCA_TUNNEL_KEY_ENC_IPV4_SRC:\n\t\t\t\t\t\t\taction.(*TunnelKeyAction).SrcAddr = adatum.Value[:]\n\t\t\t\t\t\tcase nl.TCA_TUNNEL_KEY_ENC_IPV6_DST, nl.TCA_TUNNEL_KEY_ENC_IPV4_DST:\n\t\t\t\t\t\t\taction.(*TunnelKeyAction).DstAddr = adatum.Value[:]\n\t\t\t\t\t\tcase nl.TCA_TUNNEL_KEY_ENC_DST_PORT:\n\t\t\t\t\t\t\taction.(*TunnelKeyAction).DestPort = ntohs(adatum.Value)\n\t\t\t\t\t\tcase nl.TCA_TUNNEL_KEY_TM:\n\t\t\t\t\t\t\ttcTs := nl.DeserializeTcf(adatum.Value)\n\t\t\t\t\t\t\tactionTimestamp = toTimeStamp(tcTs)\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"skbedit\":\n\t\t\t\t\t\tswitch adatum.Attr.Type {\n\t\t\t\t\t\tcase nl.TCA_SKBEDIT_PARMS:\n\t\t\t\t\t\t\tskbedit := *nl.DeserializeSkbEdit(adatum.Value)\n\t\t\t\t\t\t\taction.(*SkbEditAction).ActionAttrs = ActionAttrs{}\n\t\t\t\t\t\t\ttoAttrs(&skbedit.TcGen, action.Attrs())\n\t\t\t\t\t\tcase nl.TCA_SKBEDIT_MARK:\n\t\t\t\t\t\t\tmark := native.Uint32(adatum.Value[0:4])\n\t\t\t\t\t\t\taction.(*SkbEditAction).Mark = &mark\n\t\t\t\t\t\tcase nl.TCA_SKBEDIT_MASK:\n\t\t\t\t\t\t\tmask := native.Uint32(adatum.Value[0:4])\n\t\t\t\t\t\t\taction.(*SkbEditAction).Mask = &mask\n\t\t\t\t\t\tcase nl.TCA_SKBEDIT_PRIORITY:\n\t\t\t\t\t\t\tpriority := native.Uint32(adatum.Value[0:4])\n\t\t\t\t\t\t\taction.(*SkbEditAction).Priority = &priority\n\t\t\t\t\t\tcase nl.TCA_SKBEDIT_PTYPE:\n\t\t\t\t\t\t\tptype := native.Uint16(adatum.Value[0:2])\n\t\t\t\t\t\t\taction.(*SkbEditAction).PType = &ptype\n\t\t\t\t\t\tcase nl.TCA_SKBEDIT_QUEUE_MAPPING:\n\t\t\t\t\t\t\tmapping := native.Uint16(adatum.Value[0:2])\n\t\t\t\t\t\t\taction.(*SkbEditAction).QueueMapping = &mapping\n\t\t\t\t\t\tcase nl.TCA_SKBEDIT_TM:\n\t\t\t\t\t\t\ttcTs := nl.DeserializeTcf(adatum.Value)\n\t\t\t\t\t\t\tactionTimestamp = toTimeStamp(tcTs)\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"bpf\":\n\t\t\t\t\t\tswitch adatum.Attr.Type {\n\t\t\t\t\t\tcase nl.TCA_ACT_BPF_PARMS:\n\t\t\t\t\t\t\tgen := *nl.DeserializeTcGen(adatum.Value)\n\t\t\t\t\t\t\ttoAttrs(&gen, action.Attrs())\n\t\t\t\t\t\tcase nl.TCA_ACT_BPF_FD:\n\t\t\t\t\t\t\taction.(*BpfAction).Fd = int(native.Uint32(adatum.Value[0:4]))\n\t\t\t\t\t\tcase nl.TCA_ACT_BPF_NAME:\n\t\t\t\t\t\t\taction.(*BpfAction).Name = string(adatum.Value[:len(adatum.Value)-1])\n\t\t\t\t\t\tcase nl.TCA_ACT_BPF_TM:\n\t\t\t\t\t\t\ttcTs := nl.DeserializeTcf(adatum.Value)\n\t\t\t\t\t\t\tactionTimestamp = toTimeStamp(tcTs)\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"connmark\":\n\t\t\t\t\t\tswitch adatum.Attr.Type {\n\t\t\t\t\t\tcase nl.TCA_CONNMARK_PARMS:\n\t\t\t\t\t\t\tconnmark := *nl.DeserializeTcConnmark(adatum.Value)\n\t\t\t\t\t\t\taction.(*ConnmarkAction).ActionAttrs = ActionAttrs{}\n\t\t\t\t\t\t\ttoAttrs(&connmark.TcGen, action.Attrs())\n\t\t\t\t\t\t\taction.(*ConnmarkAction).Zone = connmark.Zone\n\t\t\t\t\t\tcase nl.TCA_CONNMARK_TM:\n\t\t\t\t\t\t\ttcTs := nl.DeserializeTcf(adatum.Value)\n\t\t\t\t\t\t\tactionTimestamp = toTimeStamp(tcTs)\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"csum\":\n\t\t\t\t\t\tswitch adatum.Attr.Type {\n\t\t\t\t\t\tcase nl.TCA_CSUM_PARMS:\n\t\t\t\t\t\t\tcsum := *nl.DeserializeTcCsum(adatum.Value)\n\t\t\t\t\t\t\taction.(*CsumAction).ActionAttrs = ActionAttrs{}\n\t\t\t\t\t\t\ttoAttrs(&csum.TcGen, action.Attrs())\n\t\t\t\t\t\t\taction.(*CsumAction).UpdateFlags = CsumUpdateFlags(csum.UpdateFlags)\n\t\t\t\t\t\tcase nl.TCA_CSUM_TM:\n\t\t\t\t\t\t\ttcTs := nl.DeserializeTcf(adatum.Value)\n\t\t\t\t\t\t\tactionTimestamp = toTimeStamp(tcTs)\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"gact\":\n\t\t\t\t\t\tswitch adatum.Attr.Type {\n\t\t\t\t\t\tcase nl.TCA_GACT_PARMS:\n\t\t\t\t\t\t\tgen := *nl.DeserializeTcGen(adatum.Value)\n\t\t\t\t\t\t\ttoAttrs(&gen, action.Attrs())\n\t\t\t\t\t\t\tif action.Attrs().Action.String() == \"goto\" {\n\t\t\t\t\t\t\t\taction.(*GenericAction).Chain = TC_ACT_EXT_VAL_MASK & gen.Action\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase nl.TCA_GACT_TM:\n\t\t\t\t\t\t\ttcTs := nl.DeserializeTcf(adatum.Value)\n\t\t\t\t\t\t\tactionTimestamp = toTimeStamp(tcTs)\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"police\":\n\t\t\t\t\t\tparsePolice(adatum, action.(*PoliceAction))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase nl.TCA_ACT_STATS:\n\t\t\t\ts, err := parseTcStats2(aattr.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tactionnStatistic = (*ActionStatistic)(s)\n\t\t\t}\n\t\t}\n\t\tif action != nil {\n\t\t\taction.Attrs().Statistics = actionnStatistic\n\t\t\taction.Attrs().Timestamp = actionTimestamp\n\t\t\tactions = append(actions, action)\n\t\t}\n\t}\n\treturn actions, nil\n}\n\nfunc parseU32Data(filter Filter, data []syscall.NetlinkRouteAttr) (bool, error) {\n\tu32 := filter.(*U32)\n\tdetailed := false\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_U32_SEL:\n\t\t\tdetailed = true\n\t\t\tsel := nl.DeserializeTcU32Sel(datum.Value)\n\t\t\tu32.Sel = sel\n\t\t\tif native != networkOrder {\n\t\t\t\t// Handle the endianness of attributes\n\t\t\t\tu32.Sel.Offmask = native.Uint16(htons(sel.Offmask))\n\t\t\t\tu32.Sel.Hmask = native.Uint32(htonl(sel.Hmask))\n\t\t\t\tfor i, key := range u32.Sel.Keys {\n\t\t\t\t\tu32.Sel.Keys[i].Mask = native.Uint32(htonl(key.Mask))\n\t\t\t\t\tu32.Sel.Keys[i].Val = native.Uint32(htonl(key.Val))\n\t\t\t\t}\n\t\t\t}\n\t\tcase nl.TCA_U32_ACT:\n\t\t\ttables, err := nl.ParseRouteAttr(datum.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn detailed, err\n\t\t\t}\n\t\t\tu32.Actions, err = parseActions(tables)\n\t\t\tif err != nil {\n\t\t\t\treturn detailed, err\n\t\t\t}\n\t\t\tfor _, action := range u32.Actions {\n\t\t\t\tif action, ok := action.(*MirredAction); ok {\n\t\t\t\t\tu32.RedirIndex = int(action.Ifindex)\n\t\t\t\t}\n\t\t\t}\n\t\tcase nl.TCA_U32_POLICE:\n\t\t\tvar police PoliceAction\n\t\t\tadata, _ := nl.ParseRouteAttr(datum.Value)\n\t\t\tfor _, aattr := range adata {\n\t\t\t\tparsePolice(aattr, &police)\n\t\t\t}\n\t\t\tu32.Police = &police\n\t\tcase nl.TCA_U32_CLASSID:\n\t\t\tu32.ClassId = native.Uint32(datum.Value)\n\t\tcase nl.TCA_U32_DIVISOR:\n\t\t\tu32.Divisor = native.Uint32(datum.Value)\n\t\tcase nl.TCA_U32_HASH:\n\t\t\tu32.Hash = native.Uint32(datum.Value)\n\t\tcase nl.TCA_U32_LINK:\n\t\t\tu32.Link = native.Uint32(datum.Value)\n\t\t}\n\t}\n\treturn detailed, nil\n}\n\nfunc parseFwData(filter Filter, data []syscall.NetlinkRouteAttr) (bool, error) {\n\tfw := filter.(*FwFilter)\n\tdetailed := true\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_FW_MASK:\n\t\t\tfw.Mask = native.Uint32(datum.Value[0:4])\n\t\tcase nl.TCA_FW_CLASSID:\n\t\t\tfw.ClassId = native.Uint32(datum.Value[0:4])\n\t\tcase nl.TCA_FW_INDEV:\n\t\t\tfw.InDev = string(datum.Value[:len(datum.Value)-1])\n\t\tcase nl.TCA_FW_POLICE:\n\t\t\tvar police PoliceAction\n\t\t\tadata, _ := nl.ParseRouteAttr(datum.Value)\n\t\t\tfor _, aattr := range adata {\n\t\t\t\tparsePolice(aattr, &police)\n\t\t\t}\n\t\t\tfw.Police = &police\n\t\tcase nl.TCA_FW_ACT:\n\t\t\ttables, err := nl.ParseRouteAttr(datum.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn detailed, err\n\t\t\t}\n\t\t\tfw.Actions, err = parseActions(tables)\n\t\t\tif err != nil {\n\t\t\t\treturn detailed, err\n\t\t\t}\n\t\t}\n\t}\n\treturn detailed, nil\n}\n\nfunc parseBpfData(filter Filter, data []syscall.NetlinkRouteAttr) (bool, error) {\n\tbpf := filter.(*BpfFilter)\n\tdetailed := true\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_BPF_FD:\n\t\t\tbpf.Fd = int(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.TCA_BPF_NAME:\n\t\t\tbpf.Name = string(datum.Value[:len(datum.Value)-1])\n\t\tcase nl.TCA_BPF_CLASSID:\n\t\t\tbpf.ClassId = native.Uint32(datum.Value[0:4])\n\t\tcase nl.TCA_BPF_FLAGS:\n\t\t\tflags := native.Uint32(datum.Value[0:4])\n\t\t\tif (flags & nl.TCA_BPF_FLAG_ACT_DIRECT) != 0 {\n\t\t\t\tbpf.DirectAction = true\n\t\t\t}\n\t\tcase nl.TCA_BPF_ID:\n\t\t\tbpf.Id = int(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.TCA_BPF_TAG:\n\t\t\tbpf.Tag = hex.EncodeToString(datum.Value)\n\t\t}\n\t}\n\treturn detailed, nil\n}\n\nfunc parseMatchAllData(filter Filter, data []syscall.NetlinkRouteAttr) (bool, error) {\n\tmatchall := filter.(*MatchAll)\n\tdetailed := true\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_MATCHALL_CLASSID:\n\t\t\tmatchall.ClassId = native.Uint32(datum.Value[0:4])\n\t\tcase nl.TCA_MATCHALL_ACT:\n\t\t\ttables, err := nl.ParseRouteAttr(datum.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn detailed, err\n\t\t\t}\n\t\t\tmatchall.Actions, err = parseActions(tables)\n\t\t\tif err != nil {\n\t\t\t\treturn detailed, err\n\t\t\t}\n\t\t}\n\t}\n\treturn detailed, nil\n}\n\nfunc parseFlowerData(filter Filter, data []syscall.NetlinkRouteAttr) (bool, error) {\n\treturn true, filter.(*Flower).decode(data)\n}\n\nfunc AlignToAtm(size uint) uint {\n\tvar linksize, cells int\n\tcells = int(size / nl.ATM_CELL_PAYLOAD)\n\tif (size % nl.ATM_CELL_PAYLOAD) > 0 {\n\t\tcells++\n\t}\n\tlinksize = cells * nl.ATM_CELL_SIZE\n\treturn uint(linksize)\n}\n\nfunc AdjustSize(sz uint, mpu uint, linklayer int) uint {\n\tif sz < mpu {\n\t\tsz = mpu\n\t}\n\tswitch linklayer {\n\tcase nl.LINKLAYER_ATM:\n\t\treturn AlignToAtm(sz)\n\tdefault:\n\t\treturn sz\n\t}\n}\n\nfunc CalcRtable(rate *nl.TcRateSpec, rtab []uint32, cellLog int, mtu uint32, linklayer int) int {\n\tbps := rate.Rate\n\tmpu := rate.Mpu\n\tvar sz uint\n\tif mtu == 0 {\n\t\tmtu = 2047\n\t}\n\tif cellLog < 0 {\n\t\tcellLog = 0\n\t\tfor (mtu >> uint(cellLog)) > 255 {\n\t\t\tcellLog++\n\t\t}\n\t}\n\tfor i := 0; i < 256; i++ {\n\t\tsz = AdjustSize(uint((i+1)<<uint32(cellLog)), uint(mpu), linklayer)\n\t\trtab[i] = Xmittime(uint64(bps), uint32(sz))\n\t}\n\trate.CellAlign = -1\n\trate.CellLog = uint8(cellLog)\n\trate.Linklayer = uint8(linklayer & nl.TC_LINKLAYER_MASK)\n\treturn cellLog\n}\n\nfunc DeserializeRtab(b []byte) [256]uint32 {\n\tvar rtab [256]uint32\n\tr := bytes.NewReader(b)\n\t_ = binary.Read(r, native, &rtab)\n\treturn rtab\n}\n\nfunc SerializeRtab(rtab [256]uint32) []byte {\n\tvar w bytes.Buffer\n\t_ = binary.Write(&w, native, rtab)\n\treturn w.Bytes()\n}\n"
        },
        {
          "name": "filter_test.go",
          "type": "blob",
          "size": 50.1611328125,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"net\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestFilterAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Ingress)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tclassId := MakeHandle(1, 1)\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_IP,\n\t\t},\n\t\tRedirIndex: redir.Attrs().Index,\n\t\tClassId:    classId,\n\t}\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tu32, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\tif u32.ClassId != classId {\n\t\tt.Fatalf(\"ClassId of the filter is the wrong value\")\n\t}\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterReplace(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_IP,\n\t\t},\n\t\tRedirIndex: redir.Attrs().Index,\n\t\tClassId:    MakeHandle(1, 1),\n\t}\n\n\tif err := FilterReplace(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed replace filter\")\n\t}\n\n\tif err := FilterReplace(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestAdvancedFilterAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"baz\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"baz\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tindex := link.Attrs().Index\n\n\tqdiscHandle := MakeHandle(0x1, 0x0)\n\tqdiscAttrs := QdiscAttrs{\n\t\tLinkIndex: index,\n\t\tHandle:    qdiscHandle,\n\t\tParent:    HANDLE_ROOT,\n\t}\n\n\tqdisc := NewHtb(qdiscAttrs)\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Htb)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tclassId := MakeHandle(0x1, 0x46cb)\n\tclassAttrs := ClassAttrs{\n\t\tLinkIndex: index,\n\t\tParent:    qdiscHandle,\n\t\tHandle:    classId,\n\t}\n\thtbClassAttrs := HtbClassAttrs{\n\t\tRate:   512 * 1024,\n\t\tBuffer: 32 * 1024,\n\t}\n\thtbClass := NewHtbClass(classAttrs, htbClassAttrs)\n\tif err = ClassReplace(htbClass); err != nil {\n\t\tt.Fatalf(\"Failed to add a HTB class: %v\", err)\n\t}\n\tclasses, err := SafeClassList(link, qdiscHandle)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 1 {\n\t\tt.Fatal(\"Failed to add class\")\n\t}\n\t_, ok = classes[0].(*HtbClass)\n\tif !ok {\n\t\tt.Fatal(\"Class is the wrong type\")\n\t}\n\n\thtid := MakeHandle(0x0010, 0000)\n\tdivisor := uint32(1)\n\thashTable := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: index,\n\t\t\tHandle:    htid,\n\t\t\tParent:    qdiscHandle,\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tDivisor: divisor,\n\t}\n\tcHashTable := *hashTable\n\tif err := FilterAdd(hashTable); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Check if the hash table is identical before and after FilterAdd.\n\tif !reflect.DeepEqual(cHashTable, *hashTable) {\n\t\tt.Fatalf(\"Hash table %v and %v are not equal\", cHashTable, *hashTable)\n\t}\n\n\tu32SelKeys := []TcU32Key{\n\t\t{\n\t\t\tMask:    0xff,\n\t\t\tVal:     80,\n\t\t\tOff:     20,\n\t\t\tOffMask: 0,\n\t\t},\n\t\t{\n\t\t\tMask:    0xffff,\n\t\t\tVal:     0x146ca,\n\t\t\tOff:     32,\n\t\t\tOffMask: 0,\n\t\t},\n\t}\n\n\thandle := MakeHandle(0x0000, 0001)\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: index,\n\t\t\tHandle:    handle,\n\t\t\tParent:    qdiscHandle,\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tSel: &TcU32Sel{\n\t\t\tKeys:  u32SelKeys,\n\t\t\tFlags: TC_U32_TERMINAL,\n\t\t},\n\t\tClassId: classId,\n\t\tHash:    htid,\n\t\tActions: []Action{},\n\t}\n\t// Copy filter.\n\tcFilter := *filter\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Check if the filter is identical before and after FilterAdd.\n\tif !reflect.DeepEqual(cFilter, *filter) {\n\t\tt.Fatalf(\"U32 %v and %v are not equal\", cFilter, *filter)\n\t}\n\n\tfilters, err := FilterList(link, qdiscHandle)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\n\tu32, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\t// Endianness checks\n\tif u32.Sel.Offmask != filter.Sel.Offmask {\n\t\tt.Fatal(\"The endianness of TcU32Key.Sel.Offmask is wrong\")\n\t}\n\tif u32.Sel.Hmask != filter.Sel.Hmask {\n\t\tt.Fatal(\"The endianness of TcU32Key.Sel.Hmask is wrong\")\n\t}\n\tfor i, key := range u32.Sel.Keys {\n\t\tif key.Mask != filter.Sel.Keys[i].Mask {\n\t\t\tt.Fatal(\"The endianness of TcU32Key.Mask is wrong\")\n\t\t}\n\t\tif key.Val != filter.Sel.Keys[i].Val {\n\t\t\tt.Fatal(\"The endianness of TcU32Key.Val is wrong\")\n\t\t}\n\t}\n\tif u32.Handle != (handle | htid) {\n\t\tt.Fatalf(\"The handle is wrong. expected %v but actually %v\",\n\t\t\t(handle | htid), u32.Handle)\n\t}\n\tif u32.Hash != htid {\n\t\tt.Fatal(\"The hash table ID is wrong\")\n\t}\n\n\tif err := FilterDel(u32); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, qdiscHandle)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err = ClassDel(htbClass); err != nil {\n\t\tt.Fatalf(\"Failed to delete a HTP class: %v\", err)\n\t}\n\tclasses, err = SafeClassList(link, qdiscHandle)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 0 {\n\t\tt.Fatal(\"Failed to remove class\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterFwAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(0xffff, 0),\n\t\tParent:    HANDLE_ROOT,\n\t}\n\tqdisc := NewHtb(attrs)\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Htb)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tclassattrs := ClassAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tParent:    MakeHandle(0xffff, 0),\n\t\tHandle:    MakeHandle(0xffff, 2),\n\t}\n\n\thtbclassattrs := HtbClassAttrs{\n\t\tRate:    1234000,\n\t\tCbuffer: 1690,\n\t}\n\tclass := NewHtbClass(classattrs, htbclassattrs)\n\tif err := ClassAdd(class); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclasses, err := SafeClassList(link, MakeHandle(0xffff, 2))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 1 {\n\t\tt.Fatal(\"Failed to add class\")\n\t}\n\n\tpolice := NewPoliceAction()\n\tpolice.Burst = 12345\n\tpolice.Rate = 1234\n\tpolice.PeakRate = 2345\n\tpolice.Action = TcAct(TC_POLICE_SHOT)\n\n\tfilterattrs := FilterAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tParent:    MakeHandle(0xffff, 0),\n\t\tHandle:    MakeHandle(0, 0x6),\n\t\tPriority:  1,\n\t\tProtocol:  unix.ETH_P_IP,\n\t}\n\n\tfilter := FwFilter{\n\t\tFilterAttrs: filterattrs,\n\t\tClassId:     MakeHandle(0xffff, 2),\n\t\tPolice:      police,\n\t}\n\n\tif err := FilterAdd(&filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tfw, ok := filters[0].(*FwFilter)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\tif fw.Police.Rate != filter.Police.Rate {\n\t\tt.Fatal(\"Police Rate doesn't match\")\n\t}\n\tif fw.ClassId != filter.ClassId {\n\t\tt.Fatal(\"ClassId doesn't match\")\n\t}\n\tif fw.InDev != filter.InDev {\n\t\tt.Fatal(\"InDev doesn't match\")\n\t}\n\tif fw.Police.AvRate != filter.Police.AvRate {\n\t\tt.Fatal(\"AvRate doesn't match\")\n\t}\n\n\tif err := FilterDel(&filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\tif err := ClassDel(class); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclasses, err = SafeClassList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(classes) != 0 {\n\t\tt.Fatal(\"Failed to remove class\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterFwActAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Ingress)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tclassId := MakeHandle(1, 1)\n\tfilter := &FwFilter{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t\tHandle:    MakeHandle(0, 0x6),\n\t\t},\n\t\tClassId: classId,\n\t\tActions: []Action{\n\t\t\t&MirredAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_STOLEN,\n\t\t\t\t},\n\t\t\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\t\t\tIfindex:      redir.Attrs().Index,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tfw, ok := filters[0].(*FwFilter)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif len(fw.Actions) != 1 {\n\t\tt.Fatalf(\"Too few Actions in filter\")\n\t}\n\tif fw.ClassId != classId {\n\t\tt.Fatalf(\"ClassId of the filter is the wrong value\")\n\t}\n\n\tmia, ok := fw.Actions[0].(*MirredAction)\n\tif !ok {\n\t\tt.Fatal(\"Unable to find mirred action\")\n\t}\n\n\tif mia.Attrs().Action != TC_ACT_STOLEN {\n\t\tt.Fatal(\"Mirred action isn't TC_ACT_STOLEN\")\n\t}\n\n\tif mia.MirredAction != TCA_EGRESS_REDIR {\n\t\tt.Fatal(\"MirredAction isn't TCA_EGRESS_REDIR\")\n\t}\n\n\tif mia.Ifindex != redir.Attrs().Index {\n\t\tt.Fatal(\"Unmatched redirect index\")\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterU32BpfAddDel(t *testing.T) {\n\tt.Skipf(\"Fd does not match in ci\")\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Ingress)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tfd, err := loadSimpleBpf(BPF_PROG_TYPE_SCHED_ACT, 1)\n\tif err != nil {\n\t\tt.Skipf(\"Loading bpf program failed: %s\", err)\n\t}\n\tclassId := MakeHandle(1, 1)\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tClassId: classId,\n\t\tActions: []Action{\n\t\t\t&BpfAction{Fd: fd, Name: \"simple\"},\n\t\t\t&MirredAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_STOLEN,\n\t\t\t\t},\n\t\t\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\t\t\tIfindex:      redir.Attrs().Index,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tu32, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif len(u32.Actions) != 2 {\n\t\tt.Fatalf(\"Too few Actions in filter\")\n\t}\n\tif u32.ClassId != classId {\n\t\tt.Fatalf(\"ClassId of the filter is the wrong value\")\n\t}\n\n\t// actions can be returned in reverse order\n\tbpfAction, ok := u32.Actions[0].(*BpfAction)\n\tif !ok {\n\t\tbpfAction, ok = u32.Actions[1].(*BpfAction)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Action is the wrong type\")\n\t\t}\n\t}\n\tif bpfAction.Fd != fd {\n\t\tt.Fatalf(\"Action Fd does not match %d != %d\", bpfAction.Fd, fd)\n\t}\n\tif _, ok := u32.Actions[0].(*MirredAction); !ok {\n\t\tif _, ok := u32.Actions[1].(*MirredAction); !ok {\n\t\t\tt.Fatal(\"Action is the wrong type\")\n\t\t}\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterU32ConnmarkAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Ingress)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tclassId := MakeHandle(1, 1)\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tClassId: classId,\n\t\tActions: []Action{\n\t\t\t&ConnmarkAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_PIPE,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&MirredAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_STOLEN,\n\t\t\t\t},\n\t\t\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\t\t\tIfindex:      redir.Attrs().Index,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tu32, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif len(u32.Actions) != 2 {\n\t\tt.Fatalf(\"Too few Actions in filter\")\n\t}\n\tif u32.ClassId != classId {\n\t\tt.Fatalf(\"ClassId of the filter is the wrong value\")\n\t}\n\n\t// actions can be returned in reverse order\n\tcma, ok := u32.Actions[0].(*ConnmarkAction)\n\tif !ok {\n\t\tcma, ok = u32.Actions[1].(*ConnmarkAction)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Unable to find connmark action\")\n\t\t}\n\t}\n\n\tif cma.Attrs().Action != TC_ACT_PIPE {\n\t\tt.Fatal(\"Connmark action isn't TC_ACT_PIPE\")\n\t}\n\n\tmia, ok := u32.Actions[0].(*MirredAction)\n\tif !ok {\n\t\tmia, ok = u32.Actions[1].(*MirredAction)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Unable to find mirred action\")\n\t\t}\n\t}\n\n\tif mia.Attrs().Action != TC_ACT_STOLEN {\n\t\tt.Fatal(\"Mirred action isn't TC_ACT_STOLEN\")\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterU32CsumAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatalf(\"add link foo error: %v\", err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatalf(\"add link foo error: %v\", err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatalf(\"set foo link up error: %v\", err)\n\t}\n\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatalf(\"get qdisc error: %v\", err)\n\t}\n\n\tfound := false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tclassId := MakeHandle(1, 1)\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tClassId: classId,\n\t\tActions: []Action{\n\t\t\t&CsumAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_PIPE,\n\t\t\t\t},\n\t\t\t\tUpdateFlags: TCA_CSUM_UPDATE_FLAG_TCP,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatalf(\"get filter error: %v\", err)\n\t}\n\n\tif len(filters) != 1 {\n\t\tt.Fatalf(\"the count filters error, expect: 1, acutal: %d\", len(filters))\n\t}\n\n\tft, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif ft.LinkIndex != link.Attrs().Index {\n\t\tt.Fatal(\"link index error\")\n\t}\n\n\tif len(ft.Actions) != 1 {\n\t\tt.Fatalf(\"filter has wrong number of actions, expect: 1, acutal: %d\", len(filters))\n\t}\n\n\tcsum, ok := ft.Actions[0].(*CsumAction)\n\tif !ok {\n\t\tt.Fatal(\"action is the wrong type\")\n\t}\n\n\tif csum.Attrs().Action != TC_ACT_PIPE {\n\t\tt.Fatal(\"Csum action isn't TC_ACT_PIPE\")\n\t}\n\n\tif csum.UpdateFlags != TCA_CSUM_UPDATE_FLAG_TCP {\n\t\tt.Fatalf(\"Csum action isn't TCA_CSUM_UPDATE_FLAG_TCP, got %d\", csum.UpdateFlags)\n\t}\n\n\tif err := FilterDel(ft); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound = false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif found {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc setupLinkForTestWithQdisc(t *testing.T, linkName string) (Qdisc, Link) {\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: linkName}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(linkName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Clsact{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_CLSACT,\n\t\t},\n\t}\n\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\", len(qdiscs))\n\t}\n\tif q, ok := qdiscs[0].(*Clsact); !ok || q.Type() != \"clsact\" {\n\t\tt.Fatal(\"qdisc is the wrong type\")\n\t}\n\treturn qdiscs[0], link\n}\n\nfunc TestFilterClsActBpfAddDel(t *testing.T) {\n\tt.Skipf(\"Fd does not match in ci\")\n\t// This feature was added in kernel 4.5\n\tminKernelRequired(t, 4, 5)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tqdisc, link := setupLinkForTestWithQdisc(t, \"foo\")\n\tfilterattrs := FilterAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tParent:    HANDLE_MIN_EGRESS,\n\t\tHandle:    MakeHandle(0, 1),\n\t\tProtocol:  unix.ETH_P_ALL,\n\t\tPriority:  1,\n\t}\n\tfd, err := loadSimpleBpf(BPF_PROG_TYPE_SCHED_CLS, 1)\n\tif err != nil {\n\t\tt.Skipf(\"Loading bpf program failed: %s\", err)\n\t}\n\tfilter := &BpfFilter{\n\t\tFilterAttrs:  filterattrs,\n\t\tFd:           fd,\n\t\tName:         \"simple\",\n\t\tDirectAction: true,\n\t}\n\tif filter.Fd < 0 {\n\t\tt.Skipf(\"Failed to load bpf program\")\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, HANDLE_MIN_EGRESS)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tbpf, ok := filters[0].(*BpfFilter)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif bpf.Fd != filter.Fd {\n\t\tt.Fatal(\"Filter Fd does not match\")\n\t}\n\tif bpf.DirectAction != filter.DirectAction {\n\t\tt.Fatal(\"Filter DirectAction does not match\")\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, HANDLE_MIN_EGRESS)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterMatchAllAddDel(t *testing.T) {\n\t// This classifier was added in kernel 4.7\n\tminKernelRequired(t, 4, 7)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\t_, link := setupLinkForTestWithQdisc(t, \"foo\")\n\t_, link2 := setupLinkForTestWithQdisc(t, \"bar\")\n\tfilter := &MatchAll{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    HANDLE_MIN_EGRESS,\n\t\t\tPriority:  32000,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tActions: []Action{\n\t\t\t&MirredAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_STOLEN,\n\t\t\t\t},\n\t\t\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\t\t\tIfindex:      link2.Attrs().Index,\n\t\t\t},\n\t\t},\n\t}\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, HANDLE_MIN_EGRESS)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tmatchall, ok := filters[0].(*MatchAll)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif matchall.Priority != 32000 {\n\t\tt.Fatal(\"Filter priority does not match\")\n\t}\n\n\tif len(matchall.Actions) != 1 {\n\t\tt.Fatal(\"Filter has no actions\")\n\t}\n\n\tmirredAction, ok := matchall.Actions[0].(*MirredAction)\n\tif !ok {\n\t\tt.Fatal(\"Action does not match\")\n\t}\n\n\tif mirredAction.Ifindex != link2.Attrs().Index {\n\t\tt.Fatal(\"Action ifindex does not match\")\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, HANDLE_MIN_EGRESS)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n}\n\nfunc TestFilterU32TunnelKeyAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound := false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\ttunnelAct := NewTunnelKeyAction()\n\ttunnelAct.SrcAddr = net.IPv4(10, 10, 10, 1)\n\ttunnelAct.DstAddr = net.IPv4(10, 10, 10, 2)\n\ttunnelAct.KeyID = 0x01\n\ttunnelAct.Action = TCA_TUNNEL_KEY_SET\n\ttunnelAct.DestPort = 8472\n\n\tclassId := MakeHandle(1, 1)\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tClassId: classId,\n\t\tActions: []Action{\n\t\t\ttunnelAct,\n\t\t\t&MirredAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_STOLEN,\n\t\t\t\t},\n\t\t\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\t\t\tIfindex:      redir.Attrs().Index,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tu32, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif len(u32.Actions) != 2 {\n\t\tt.Fatalf(\"Too few Actions in filter\")\n\t}\n\tif u32.ClassId != classId {\n\t\tt.Fatalf(\"ClassId of the filter is the wrong value\")\n\t}\n\n\t// actions can be returned in reverse order\n\ttun, ok := u32.Actions[0].(*TunnelKeyAction)\n\tif !ok {\n\t\ttun, ok = u32.Actions[1].(*TunnelKeyAction)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Unable to find tunnel action\")\n\t\t}\n\t}\n\n\tif tun.Attrs().Action != TC_ACT_PIPE {\n\t\tt.Fatal(\"TunnelKey action isn't TC_ACT_PIPE\")\n\t}\n\tif !tun.SrcAddr.Equal(tunnelAct.SrcAddr) {\n\t\tt.Fatal(\"Action SrcAddr doesn't match\")\n\t}\n\tif !tun.DstAddr.Equal(tunnelAct.DstAddr) {\n\t\tt.Fatal(\"Action DstAddr doesn't match\")\n\t}\n\tif tun.KeyID != tunnelAct.KeyID {\n\t\tt.Fatal(\"Action KeyID doesn't match\")\n\t}\n\tif tun.DestPort != tunnelAct.DestPort {\n\t\tt.Fatal(\"Action DestPort doesn't match\")\n\t}\n\tif tun.Action != tunnelAct.Action {\n\t\tt.Fatal(\"Action doesn't match\")\n\t}\n\n\tmia, ok := u32.Actions[0].(*MirredAction)\n\tif !ok {\n\t\tmia, ok = u32.Actions[1].(*MirredAction)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Unable to find mirred action\")\n\t\t}\n\t}\n\n\tif mia.Attrs().Action != TC_ACT_STOLEN {\n\t\tt.Fatal(\"Mirred action isn't TC_ACT_STOLEN\")\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound = false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif found {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterU32SkbEditAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound := false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tskbedit := NewSkbEditAction()\n\tptype := uint16(unix.PACKET_HOST)\n\tskbedit.PType = &ptype\n\tpriority := uint32(0xff)\n\tskbedit.Priority = &priority\n\tmark := uint32(0xfe)\n\tskbedit.Mark = &mark\n\tmask := uint32(0xff)\n\tskbedit.Mask = &mask\n\tmapping := uint16(0xf)\n\tskbedit.QueueMapping = &mapping\n\n\tclassId := MakeHandle(1, 1)\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tClassId: classId,\n\t\tActions: []Action{\n\t\t\tskbedit,\n\t\t\t&MirredAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_STOLEN,\n\t\t\t\t},\n\t\t\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\t\t\tIfindex:      redir.Attrs().Index,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tu32, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif len(u32.Actions) != 2 {\n\t\tt.Fatalf(\"Too few Actions in filter\")\n\t}\n\tif u32.ClassId != classId {\n\t\tt.Fatalf(\"ClassId of the filter is the wrong value\")\n\t}\n\n\t// actions can be returned in reverse order\n\tedit, ok := u32.Actions[0].(*SkbEditAction)\n\tif !ok {\n\t\tedit, ok = u32.Actions[1].(*SkbEditAction)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Unable to find tunnel action\")\n\t\t}\n\t}\n\n\tif edit.Attrs().Action != TC_ACT_PIPE {\n\t\tt.Fatal(\"SkbEdit action isn't TC_ACT_PIPE\")\n\t}\n\tif edit.PType == nil || *edit.PType != *skbedit.PType {\n\t\tt.Fatal(\"Action PType doesn't match\")\n\t}\n\tif edit.QueueMapping == nil || *edit.QueueMapping != *skbedit.QueueMapping {\n\t\tt.Fatal(\"Action QueueMapping doesn't match\")\n\t}\n\tif edit.Mark == nil || *edit.Mark != *skbedit.Mark {\n\t\tt.Fatal(\"Action Mark doesn't match\")\n\t}\n\tif edit.Mask == nil || *edit.Mask != *skbedit.Mask {\n\t\tt.Fatal(\"Action Mask doesn't match\")\n\t}\n\tif edit.Priority == nil || *edit.Priority != *skbedit.Priority {\n\t\tt.Fatal(\"Action Priority doesn't match\")\n\t}\n\n\tmia, ok := u32.Actions[0].(*MirredAction)\n\tif !ok {\n\t\tmia, ok = u32.Actions[1].(*MirredAction)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Unable to find mirred action\")\n\t\t}\n\t}\n\n\tif mia.Attrs().Action != TC_ACT_STOLEN {\n\t\tt.Fatal(\"Mirred action isn't TC_ACT_STOLEN\")\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound = false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif found {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterU32LinkOption(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatalf(\"add link foo error: %v\", err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatalf(\"add link foo error: %v\", err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatalf(\"set foo link up error: %v\", err)\n\t}\n\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatalf(\"get qdisc error: %v\", err)\n\t}\n\n\tfound := false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\thtid := uint32(10)\n\tsize := uint32(8)\n\tpriority := uint16(200)\n\tu32Table := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    htid << 20,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  priority,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tDivisor: size,\n\t}\n\tif err := FilterAdd(u32Table); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tu32 := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tHandle:    1,\n\t\t\tPriority:  priority,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tLink: uint32(htid << 20),\n\t\tSel: &TcU32Sel{\n\t\t\tNkeys:    1,\n\t\t\tFlags:    TC_U32_TERMINAL | TC_U32_VAROFFSET,\n\t\t\tHmask:    0x0000ff00,\n\t\t\tHoff:     0,\n\t\t\tOffshift: 8,\n\t\t\tKeys: []TcU32Key{\n\t\t\t\t{\n\t\t\t\t\tMask: 0,\n\t\t\t\t\tVal:  0,\n\t\t\t\t\tOff:  0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tif err := FilterAdd(u32); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatalf(\"get filter error: %v\", err)\n\t}\n\n\tif len(filters) != 1 {\n\t\tt.Fatalf(\"the count filters error, expect: 1, acutal: %d\", len(filters))\n\t}\n\n\tft, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif ft.LinkIndex != link.Attrs().Index {\n\t\tt.Fatal(\"link index error\")\n\t}\n\n\tif ft.Link != htid<<20 {\n\t\tt.Fatal(\"hash table id error\")\n\t}\n\n\tif ft.Priority != priority {\n\t\tt.Fatal(\"priority error\")\n\t}\n\n\tif err := FilterDel(ft); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound = false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif found {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterFlowerAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound := false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\ttestMask := net.CIDRMask(24, 32)\n\n\tipproto := new(nl.IPProto)\n\t*ipproto = nl.IPPROTO_TCP\n\n\tfilter := &Flower{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tDestIP:        net.ParseIP(\"1.0.0.1\"),\n\t\tDestIPMask:    testMask,\n\t\tSrcIP:         net.ParseIP(\"2.0.0.1\"),\n\t\tSrcIPMask:     testMask,\n\t\tEthType:       unix.ETH_P_IP,\n\t\tEncDestIP:     net.ParseIP(\"3.0.0.1\"),\n\t\tEncDestIPMask: testMask,\n\t\tEncSrcIP:      net.ParseIP(\"4.0.0.1\"),\n\t\tEncSrcIPMask:  testMask,\n\t\tEncDestPort:   8472,\n\t\tEncKeyId:      1234,\n\t\tIPProto:       ipproto,\n\t\tDestPort:      1111,\n\t\tSrcPort:       1111,\n\t\tActions: []Action{\n\t\t\t&MirredAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_STOLEN,\n\t\t\t\t},\n\t\t\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\t\t\tIfindex:      redir.Attrs().Index,\n\t\t\t},\n\t\t\t&GenericAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: getTcActGotoChain(),\n\t\t\t\t},\n\t\t\t\tChain: 20,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttime.Sleep(time.Second)\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tflower, ok := filters[0].(*Flower)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif filter.EthType != flower.EthType {\n\t\tt.Fatalf(\"Flower EthType doesn't match\")\n\t}\n\tif !filter.DestIP.Equal(flower.DestIP) {\n\t\tt.Fatalf(\"Flower DestIP doesn't match\")\n\t}\n\tif !filter.SrcIP.Equal(flower.SrcIP) {\n\t\tt.Fatalf(\"Flower SrcIP doesn't match\")\n\t}\n\n\tif !reflect.DeepEqual(filter.DestIPMask, testMask) {\n\t\tt.Fatalf(\"Flower DestIPMask doesn't match\")\n\t}\n\tif !reflect.DeepEqual(filter.SrcIPMask, testMask) {\n\t\tt.Fatalf(\"Flower SrcIPMask doesn't match\")\n\t}\n\n\tif !filter.EncDestIP.Equal(flower.EncDestIP) {\n\t\tt.Fatalf(\"Flower EncDestIP doesn't match\")\n\t}\n\tif !filter.EncSrcIP.Equal(flower.EncSrcIP) {\n\t\tt.Fatalf(\"Flower EncSrcIP doesn't match\")\n\t}\n\tif !reflect.DeepEqual(filter.EncDestIPMask, testMask) {\n\t\tt.Fatalf(\"Flower EncDestIPMask doesn't match\")\n\t}\n\tif !reflect.DeepEqual(filter.EncSrcIPMask, testMask) {\n\t\tt.Fatalf(\"Flower EncSrcIPMask doesn't match\")\n\t}\n\tif filter.EncKeyId != flower.EncKeyId {\n\t\tt.Fatalf(\"Flower EncKeyId doesn't match\")\n\t}\n\tif filter.EncDestPort != flower.EncDestPort {\n\t\tt.Fatalf(\"Flower EncDestPort doesn't match\")\n\t}\n\tif flower.IPProto == nil || *filter.IPProto != *flower.IPProto {\n\t\tt.Fatalf(\"Flower IPProto doesn't match\")\n\t}\n\tif filter.DestPort != flower.DestPort {\n\t\tt.Fatalf(\"Flower DestPort doesn't match\")\n\t}\n\tif filter.SrcPort != flower.SrcPort {\n\t\tt.Fatalf(\"Flower SrcPort doesn't match\")\n\t}\n\n\tmia, ok := flower.Actions[0].(*MirredAction)\n\tif !ok {\n\t\tt.Fatal(\"Unable to find mirred action\")\n\t}\n\n\tif mia.Attrs().Action != TC_ACT_STOLEN {\n\t\tt.Fatal(\"Mirred action isn't TC_ACT_STOLEN\")\n\t}\n\n\tif mia.Timestamp == nil || mia.Timestamp.Installed == 0 {\n\t\tt.Fatal(\"Incorrect mirred action timestamp\")\n\t}\n\n\tif mia.Statistics == nil {\n\t\tt.Fatal(\"Incorrect mirred action stats\")\n\t}\n\n\tga, ok := flower.Actions[1].(*GenericAction)\n\tif !ok {\n\t\tt.Fatal(\"Unable to find generic action\")\n\t}\n\n\tif ga.Attrs().Action != getTcActGotoChain() {\n\t\tt.Fatal(\"Generic action isn't TC_ACT_GOTO_CHAIN\")\n\t}\n\n\tif ga.Timestamp == nil || ga.Timestamp.Installed == 0 {\n\t\tt.Fatal(\"Incorrect generic action timestamp\")\n\t}\n\n\tif ga.Statistics == nil {\n\t\tt.Fatal(\"Incorrect generic action stats\")\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound = false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif found {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterIPv6FlowerPedit(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound := false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\ttestMask := net.CIDRMask(64, 128)\n\n\tipproto := new(nl.IPProto)\n\t*ipproto = nl.IPPROTO_TCP\n\n\tfilter := &Flower{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tDestIP:     net.ParseIP(\"ffff::fff1\"),\n\t\tDestIPMask: testMask,\n\t\tEthType:    unix.ETH_P_IPV6,\n\t\tIPProto:    ipproto,\n\t\tDestPort:   6666,\n\t\tActions:    []Action{},\n\t}\n\n\tpeditAction := NewPeditAction()\n\tpeditAction.Proto = uint8(nl.IPPROTO_TCP)\n\tpeditAction.SrcPort = 7777\n\tpeditAction.SrcIP = net.ParseIP(\"ffff::fff2\")\n\tfilter.Actions = append(filter.Actions, peditAction)\n\n\tmiaAction := &MirredAction{\n\t\tActionAttrs: ActionAttrs{\n\t\t\tAction: TC_ACT_REDIRECT,\n\t\t},\n\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\tIfindex:      redir.Attrs().Index,\n\t}\n\tfilter.Actions = append(filter.Actions, miaAction)\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tflower, ok := filters[0].(*Flower)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif filter.EthType != flower.EthType {\n\t\tt.Fatalf(\"Flower EthType doesn't match\")\n\t}\n\tif !filter.DestIP.Equal(flower.DestIP) {\n\t\tt.Fatalf(\"Flower DestIP doesn't match\")\n\t}\n\n\tif !reflect.DeepEqual(filter.DestIPMask, testMask) {\n\t\tt.Fatalf(\"Flower DestIPMask doesn't match\")\n\t}\n\n\tif flower.IPProto == nil || *filter.IPProto != *flower.IPProto {\n\t\tt.Fatalf(\"Flower IPProto doesn't match\")\n\t}\n\tif filter.DestPort != flower.DestPort {\n\t\tt.Fatalf(\"Flower DestPort doesn't match\")\n\t}\n\n\t_, ok = flower.Actions[0].(*PeditAction)\n\tif !ok {\n\t\tt.Fatal(\"Unable to find pedit action\")\n\t}\n\n\t_, ok = flower.Actions[1].(*MirredAction)\n\tif !ok {\n\t\tt.Fatal(\"Unable to find mirred action\")\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound = false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif found {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterU32PoliceAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound := false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\n\tconst (\n\t\tpoliceRate     = 0x40000000 // 1 Gbps\n\t\tpoliceBurst    = 0x19000    // 100 KB\n\t\tpolicePeakRate = 0x4000     // 16 Kbps\n\t)\n\n\tpolice := NewPoliceAction()\n\tpolice.Rate = policeRate\n\tpolice.PeakRate = policePeakRate\n\tpolice.Burst = policeBurst\n\tpolice.ExceedAction = TC_POLICE_SHOT\n\tpolice.NotExceedAction = TC_POLICE_UNSPEC\n\n\tclassId := MakeHandle(1, 1)\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tClassId: classId,\n\t\tActions: []Action{\n\t\t\tpolice,\n\t\t\t&MirredAction{\n\t\t\t\tActionAttrs: ActionAttrs{\n\t\t\t\t\tAction: TC_ACT_STOLEN,\n\t\t\t\t},\n\t\t\t\tMirredAction: TCA_EGRESS_REDIR,\n\t\t\t\tIfindex:      redir.Attrs().Index,\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tu32, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif len(u32.Actions) != 2 {\n\t\tt.Fatalf(\"Too few Actions in filter\")\n\t}\n\tif u32.ClassId != classId {\n\t\tt.Fatalf(\"ClassId of the filter is the wrong value\")\n\t}\n\n\t// actions can be returned in reverse order\n\tp, ok := u32.Actions[0].(*PoliceAction)\n\tif !ok {\n\t\tp, ok = u32.Actions[1].(*PoliceAction)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Unable to find police action\")\n\t\t}\n\t}\n\n\tif p.ExceedAction != TC_POLICE_SHOT {\n\t\tt.Fatal(\"Police ExceedAction isn't TC_POLICE_SHOT\")\n\t}\n\n\tif p.NotExceedAction != TC_POLICE_UNSPEC {\n\t\tt.Fatal(\"Police NotExceedAction isn't TC_POLICE_UNSPEC\")\n\t}\n\n\tif p.Rate != policeRate {\n\t\tt.Fatal(\"Action Rate doesn't match\")\n\t}\n\n\tif p.PeakRate != policePeakRate {\n\t\tt.Fatal(\"Action PeakRate doesn't match\")\n\t}\n\n\tif p.LinkLayer != nl.LINKLAYER_ETHERNET {\n\t\tt.Fatal(\"Action LinkLayer doesn't match\")\n\t}\n\n\tmia, ok := u32.Actions[0].(*MirredAction)\n\tif !ok {\n\t\tmia, ok = u32.Actions[1].(*MirredAction)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Unable to find mirred action\")\n\t\t}\n\t}\n\n\tif mia.Attrs().Action != TC_ACT_STOLEN {\n\t\tt.Fatal(\"Mirred action isn't TC_ACT_STOLEN\")\n\t}\n\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound = false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif found {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterU32DirectPoliceAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tconst (\n\t\tpoliceRate     = 0x40000000 // 1 Gbps\n\t\tpoliceBurst    = 0x19000    // 100 KB\n\t\tpolicePeakRate = 0x4000     // 16 Kbps\n\t)\n\n\tpolice := NewPoliceAction()\n\tpolice.Rate = policeRate\n\tpolice.PeakRate = policePeakRate\n\tpolice.Burst = policeBurst\n\tpolice.ExceedAction = TC_POLICE_SHOT\n\tpolice.NotExceedAction = TC_POLICE_UNSPEC\n\n\tclassId := MakeHandle(1, 1)\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_ALL,\n\t\t},\n\t\tClassId: classId,\n\t\tPolice:  police,\n\t}\n\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tu32, ok := filters[0].(*U32)\n\tif !ok {\n\t\tt.Fatal(\"Filter is the wrong type\")\n\t}\n\n\tif u32.Police == nil {\n\t\tt.Fatalf(\"No police in filter\")\n\t}\n\n\tif u32.Police.Rate != policeRate {\n\t\tt.Fatal(\"Filter Rate doesn't match\")\n\t}\n\n\tif u32.Police.PeakRate != policePeakRate {\n\t\tt.Fatal(\"Filter PeakRate doesn't match\")\n\t}\n\n\tif u32.Police.LinkLayer != nl.LINKLAYER_ETHERNET {\n\t\tt.Fatal(\"Filter LinkLayer doesn't match\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound := false\n\tfor _, v := range qdiscs {\n\t\tif _, ok := v.(*Ingress); ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif found {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFilterChainAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"bar\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tredir, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(redir); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(0xffff, 0),\n\t\t\tParent:    HANDLE_INGRESS,\n\t\t},\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Ingress)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tclassId := MakeHandle(1, 1)\n\tchainVal := new(uint32)\n\t*chainVal = 20\n\tfilter := &U32{\n\t\tFilterAttrs: FilterAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tParent:    MakeHandle(0xffff, 0),\n\t\t\tPriority:  1,\n\t\t\tProtocol:  unix.ETH_P_IP,\n\t\t\tChain:     chainVal,\n\t\t},\n\t\tRedirIndex: redir.Attrs().Index,\n\t\tClassId:    classId,\n\t}\n\tif err := FilterAdd(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err := FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 1 {\n\t\tt.Fatal(\"Failed to add filter\")\n\t}\n\tfilterChain := filters[0].Attrs().Chain\n\tif filterChain != nil && *filterChain != *chainVal {\n\t\tt.Fatalf(\"Chain of the filter is the wrong value\")\n\t}\n\tif err := FilterDel(filter); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfilters, err = FilterList(link, MakeHandle(0xffff, 0))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters) != 0 {\n\t\tt.Fatal(\"Failed to remove filter\")\n\t}\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n"
        },
        {
          "name": "fou.go",
          "type": "blob",
          "size": 0.177734375,
          "content": "package netlink\n\nimport (\n\t\"net\"\n)\n\ntype Fou struct {\n\tFamily    int\n\tPort      int\n\tProtocol  int\n\tEncapType int\n\tLocal     net.IP\n\tPeer      net.IP\n\tPeerPort  int\n\tIfIndex   int\n}\n"
        },
        {
          "name": "fou_linux.go",
          "type": "blob",
          "size": 4.232421875,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\tFOU_GENL_NAME = \"fou\"\n)\n\nconst (\n\tFOU_CMD_UNSPEC uint8 = iota\n\tFOU_CMD_ADD\n\tFOU_CMD_DEL\n\tFOU_CMD_GET\n\tFOU_CMD_MAX = FOU_CMD_GET\n)\n\nconst (\n\tFOU_ATTR_UNSPEC = iota\n\tFOU_ATTR_PORT\n\tFOU_ATTR_AF\n\tFOU_ATTR_IPPROTO\n\tFOU_ATTR_TYPE\n\tFOU_ATTR_REMCSUM_NOPARTIAL\n\tFOU_ATTR_LOCAL_V4\n\tFOU_ATTR_LOCAL_V6\n\tFOU_ATTR_PEER_V4\n\tFOU_ATTR_PEER_V6\n\tFOU_ATTR_PEER_PORT\n\tFOU_ATTR_IFINDEX\n\tFOU_ATTR_MAX = FOU_ATTR_REMCSUM_NOPARTIAL\n)\n\nconst (\n\tFOU_ENCAP_UNSPEC = iota\n\tFOU_ENCAP_DIRECT\n\tFOU_ENCAP_GUE\n\tFOU_ENCAP_MAX = FOU_ENCAP_GUE\n)\n\nvar fouFamilyId int\n\nfunc FouFamilyId() (int, error) {\n\tif fouFamilyId != 0 {\n\t\treturn fouFamilyId, nil\n\t}\n\n\tfam, err := GenlFamilyGet(FOU_GENL_NAME)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tfouFamilyId = int(fam.ID)\n\treturn fouFamilyId, nil\n}\n\nfunc FouAdd(f Fou) error {\n\treturn pkgHandle.FouAdd(f)\n}\n\nfunc (h *Handle) FouAdd(f Fou) error {\n\tfam_id, err := FouFamilyId()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// setting ip protocol conflicts with encapsulation type GUE\n\tif f.EncapType == FOU_ENCAP_GUE && f.Protocol != 0 {\n\t\treturn errors.New(\"GUE encapsulation doesn't specify an IP protocol\")\n\t}\n\n\treq := h.newNetlinkRequest(fam_id, unix.NLM_F_ACK)\n\n\t// int to byte for port\n\tbp := make([]byte, 2)\n\tbinary.BigEndian.PutUint16(bp[0:2], uint16(f.Port))\n\n\tattrs := []*nl.RtAttr{\n\t\tnl.NewRtAttr(FOU_ATTR_PORT, bp),\n\t\tnl.NewRtAttr(FOU_ATTR_TYPE, []byte{uint8(f.EncapType)}),\n\t\tnl.NewRtAttr(FOU_ATTR_AF, []byte{uint8(f.Family)}),\n\t\tnl.NewRtAttr(FOU_ATTR_IPPROTO, []byte{uint8(f.Protocol)}),\n\t}\n\traw := []byte{FOU_CMD_ADD, 1, 0, 0}\n\tfor _, a := range attrs {\n\t\traw = append(raw, a.Serialize()...)\n\t}\n\n\treq.AddRawData(raw)\n\n\t_, err = req.Execute(unix.NETLINK_GENERIC, 0)\n\treturn err\n}\n\nfunc FouDel(f Fou) error {\n\treturn pkgHandle.FouDel(f)\n}\n\nfunc (h *Handle) FouDel(f Fou) error {\n\tfam_id, err := FouFamilyId()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq := h.newNetlinkRequest(fam_id, unix.NLM_F_ACK)\n\n\t// int to byte for port\n\tbp := make([]byte, 2)\n\tbinary.BigEndian.PutUint16(bp[0:2], uint16(f.Port))\n\n\tattrs := []*nl.RtAttr{\n\t\tnl.NewRtAttr(FOU_ATTR_PORT, bp),\n\t\tnl.NewRtAttr(FOU_ATTR_AF, []byte{uint8(f.Family)}),\n\t}\n\traw := []byte{FOU_CMD_DEL, 1, 0, 0}\n\tfor _, a := range attrs {\n\t\traw = append(raw, a.Serialize()...)\n\t}\n\n\treq.AddRawData(raw)\n\n\t_, err = req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc FouList(fam int) ([]Fou, error) {\n\treturn pkgHandle.FouList(fam)\n}\n\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) FouList(fam int) ([]Fou, error) {\n\tfam_id, err := FouFamilyId()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq := h.newNetlinkRequest(fam_id, unix.NLM_F_DUMP)\n\n\tattrs := []*nl.RtAttr{\n\t\tnl.NewRtAttr(FOU_ATTR_AF, []byte{uint8(fam)}),\n\t}\n\traw := []byte{FOU_CMD_GET, 1, 0, 0}\n\tfor _, a := range attrs {\n\t\traw = append(raw, a.Serialize()...)\n\t}\n\n\treq.AddRawData(raw)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif executeErr != nil && !errors.Is(err, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tfous := make([]Fou, 0, len(msgs))\n\tfor _, m := range msgs {\n\t\tf, err := deserializeFouMsg(m)\n\t\tif err != nil {\n\t\t\treturn fous, err\n\t\t}\n\n\t\tfous = append(fous, f)\n\t}\n\n\treturn fous, executeErr\n}\n\nfunc deserializeFouMsg(msg []byte) (Fou, error) {\n\tfou := Fou{}\n\n\tfor attr := range nl.ParseAttributes(msg[4:]) {\n\t\tswitch attr.Type {\n\t\tcase FOU_ATTR_AF:\n\t\t\tfou.Family = int(attr.Value[0])\n\t\tcase FOU_ATTR_PORT:\n\t\t\tfou.Port = int(networkOrder.Uint16(attr.Value))\n\t\tcase FOU_ATTR_IPPROTO:\n\t\t\tfou.Protocol = int(attr.Value[0])\n\t\tcase FOU_ATTR_TYPE:\n\t\t\tfou.EncapType = int(attr.Value[0])\n\t\tcase FOU_ATTR_LOCAL_V4, FOU_ATTR_LOCAL_V6:\n\t\t\tfou.Local = net.IP(attr.Value)\n\t\tcase FOU_ATTR_PEER_V4, FOU_ATTR_PEER_V6:\n\t\t\tfou.Peer = net.IP(attr.Value)\n\t\tcase FOU_ATTR_PEER_PORT:\n\t\t\tfou.PeerPort = int(networkOrder.Uint16(attr.Value))\n\t\tcase FOU_ATTR_IFINDEX:\n\t\t\tfou.IfIndex = int(native.Uint16(attr.Value))\n\t\tdefault:\n\t\t\tlog.Printf(\"unknown fou attribute from kernel: %+v %v\", attr, attr.Type&nl.NLA_TYPE_MASK)\n\t\t}\n\t}\n\n\treturn fou, nil\n}\n"
        },
        {
          "name": "fou_test.go",
          "type": "blob",
          "size": 3.541015625,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestFouDeserializeMsg(t *testing.T) {\n\tvar msg []byte\n\n\t// deserialize a valid message\n\tmsg = []byte{3, 1, 0, 0, 5, 0, 2, 0, 2, 0, 0, 0, 6, 0, 1, 0, 21, 179, 0, 0, 5, 0, 3, 0, 4, 0, 0, 0, 5, 0, 4, 0, 1, 0, 0, 0}\n\tif fou, err := deserializeFouMsg(msg); err != nil {\n\t\tt.Error(err.Error())\n\t} else {\n\n\t\t// check if message was deserialized correctly\n\t\tif fou.Family != FAMILY_V4 {\n\t\t\tt.Errorf(\"expected family %d, got %d\", FAMILY_V4, fou.Family)\n\t\t}\n\n\t\tif fou.Port != 5555 {\n\t\t\tt.Errorf(\"expected port 5555, got %d\", fou.Port)\n\t\t}\n\n\t\tif fou.Protocol != 4 { // ipip\n\t\t\tt.Errorf(\"expected protocol 4, got %d\", fou.Protocol)\n\t\t}\n\n\t\tif fou.EncapType != FOU_ENCAP_DIRECT {\n\t\t\tt.Errorf(\"expected encap type %d, got %d\", FOU_ENCAP_DIRECT, fou.EncapType)\n\t\t}\n\t}\n\n\t// deserialize a valid message(kernel >= 5.2)\n\tmsg = []byte{3, 1, 0, 0, 5, 0, 2, 0, 2, 0, 0, 0, 6, 0, 1, 0, 43, 103, 0, 0, 6, 0, 10, 0, 86, 206, 0, 0, 5, 0, 3, 0, 0, 0, 0, 0, 5, 0, 4, 0, 2, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 8, 0, 6, 0, 1, 2, 3, 4, 8, 0, 8, 0, 5, 6, 7, 8}\n\tif fou, err := deserializeFouMsg(msg); err != nil {\n\t\tt.Error(err.Error())\n\t} else {\n\t\tif fou.Family != FAMILY_V4 {\n\t\t\tt.Errorf(\"expected family %d, got %d\", FAMILY_V4, fou.Family)\n\t\t}\n\n\t\tif fou.Port != 11111 {\n\t\t\tt.Errorf(\"expected port 5555, got %d\", fou.Port)\n\t\t}\n\n\t\tif fou.Protocol != 0 { // gue\n\t\t\tt.Errorf(\"expected protocol 0, got %d\", fou.Protocol)\n\t\t}\n\n\t\tif fou.IfIndex != 0 {\n\t\t\tt.Errorf(\"expected ifindex 0, got %d\", fou.Protocol)\n\t\t}\n\n\t\tif fou.EncapType != FOU_ENCAP_GUE {\n\t\t\tt.Errorf(\"expected encap type %d, got %d\", FOU_ENCAP_GUE, fou.EncapType)\n\t\t}\n\n\t\tif expected := net.IPv4(1, 2, 3, 4); !fou.Local.Equal(expected) {\n\t\t\tt.Errorf(\"expected local %v, got %v\", expected, fou.Local)\n\t\t}\n\n\t\tif expected := net.IPv4(5, 6, 7, 8); !fou.Peer.Equal(expected) {\n\t\t\tt.Errorf(\"expected peer %v, got %v\", expected, fou.Peer)\n\t\t}\n\n\t\tif fou.PeerPort != 22222 {\n\t\t\tt.Errorf(\"expected peer port 0, got %d\", fou.PeerPort)\n\t\t}\n\t}\n\n\t// unknown attribute should be skipped\n\tmsg = []byte{3, 1, 0, 0, 5, 0, 112, 0, 2, 0, 0, 0, 5, 0, 2, 0, 2, 0, 0}\n\tif fou, err := deserializeFouMsg(msg); err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err.Error())\n\t} else if fou.Family != 2 {\n\t\tt.Errorf(\"expected family 2, got %d\", fou.Family)\n\t}\n}\n\nfunc TestFouAddDel(t *testing.T) {\n\t// foo-over-udp was merged in 3.18 so skip these tests if the kernel is too old\n\tminKernelRequired(t, 3, 18)\n\n\t// the fou module is usually not compiled in the kernel so we'll load it\n\ttearDown := setUpNetlinkTestWithKModule(t, \"fou\")\n\tdefer tearDown()\n\n\tfou := Fou{\n\t\tPort:      5555,\n\t\tFamily:    FAMILY_V4,\n\t\tProtocol:  4, // ipip\n\t\tEncapType: FOU_ENCAP_DIRECT,\n\t}\n\n\tif err := FouAdd(fou); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlist, err := FouList(FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(list) != 1 {\n\t\tt.Fatalf(\"expected 1 fou, got %d\", len(list))\n\t}\n\n\tif list[0].Port != fou.Port {\n\t\tt.Errorf(\"expected port %d, got %d\", fou.Port, list[0].Port)\n\t}\n\n\tif list[0].Family != fou.Family {\n\t\tt.Errorf(\"expected family %d, got %d\", fou.Family, list[0].Family)\n\t}\n\n\tif list[0].Protocol != fou.Protocol {\n\t\tt.Errorf(\"expected protocol %d, got %d\", fou.Protocol, list[0].Protocol)\n\t}\n\n\tif list[0].EncapType != fou.EncapType {\n\t\tt.Errorf(\"expected encaptype %d, got %d\", fou.EncapType, list[0].EncapType)\n\t}\n\n\tif err := FouDel(Fou{Port: fou.Port, Family: fou.Family}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlist, err = FouList(FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(list) != 0 {\n\t\tt.Fatalf(\"expected 0 fou, got %d\", len(list))\n\t}\n}\n"
        },
        {
          "name": "fou_unspecified.go",
          "type": "blob",
          "size": 0.2314453125,
          "content": "//go:build !linux\n// +build !linux\n\npackage netlink\n\nfunc FouAdd(f Fou) error {\n\treturn ErrNotImplemented\n}\n\nfunc FouDel(f Fou) error {\n\treturn ErrNotImplemented\n}\n\nfunc FouList(fam int) ([]Fou, error) {\n\treturn nil, ErrNotImplemented\n}\n"
        },
        {
          "name": "genetlink_linux.go",
          "type": "blob",
          "size": 4.095703125,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\ntype GenlOp struct {\n\tID    uint32\n\tFlags uint32\n}\n\ntype GenlMulticastGroup struct {\n\tID   uint32\n\tName string\n}\n\ntype GenlFamily struct {\n\tID      uint16\n\tHdrSize uint32\n\tName    string\n\tVersion uint32\n\tMaxAttr uint32\n\tOps     []GenlOp\n\tGroups  []GenlMulticastGroup\n}\n\nfunc parseOps(b []byte) ([]GenlOp, error) {\n\tattrs, err := nl.ParseRouteAttr(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tops := make([]GenlOp, 0, len(attrs))\n\tfor _, a := range attrs {\n\t\tnattrs, err := nl.ParseRouteAttr(a.Value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tvar op GenlOp\n\t\tfor _, na := range nattrs {\n\t\t\tswitch na.Attr.Type {\n\t\t\tcase nl.GENL_CTRL_ATTR_OP_ID:\n\t\t\t\top.ID = native.Uint32(na.Value)\n\t\t\tcase nl.GENL_CTRL_ATTR_OP_FLAGS:\n\t\t\t\top.Flags = native.Uint32(na.Value)\n\t\t\t}\n\t\t}\n\t\tops = append(ops, op)\n\t}\n\treturn ops, nil\n}\n\nfunc parseMulticastGroups(b []byte) ([]GenlMulticastGroup, error) {\n\tattrs, err := nl.ParseRouteAttr(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgroups := make([]GenlMulticastGroup, 0, len(attrs))\n\tfor _, a := range attrs {\n\t\tnattrs, err := nl.ParseRouteAttr(a.Value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tvar g GenlMulticastGroup\n\t\tfor _, na := range nattrs {\n\t\t\tswitch na.Attr.Type {\n\t\t\tcase nl.GENL_CTRL_ATTR_MCAST_GRP_NAME:\n\t\t\t\tg.Name = nl.BytesToString(na.Value)\n\t\t\tcase nl.GENL_CTRL_ATTR_MCAST_GRP_ID:\n\t\t\t\tg.ID = native.Uint32(na.Value)\n\t\t\t}\n\t\t}\n\t\tgroups = append(groups, g)\n\t}\n\treturn groups, nil\n}\n\nfunc (f *GenlFamily) parseAttributes(attrs []syscall.NetlinkRouteAttr) error {\n\tfor _, a := range attrs {\n\t\tswitch a.Attr.Type {\n\t\tcase nl.GENL_CTRL_ATTR_FAMILY_NAME:\n\t\t\tf.Name = nl.BytesToString(a.Value)\n\t\tcase nl.GENL_CTRL_ATTR_FAMILY_ID:\n\t\t\tf.ID = native.Uint16(a.Value)\n\t\tcase nl.GENL_CTRL_ATTR_VERSION:\n\t\t\tf.Version = native.Uint32(a.Value)\n\t\tcase nl.GENL_CTRL_ATTR_HDRSIZE:\n\t\t\tf.HdrSize = native.Uint32(a.Value)\n\t\tcase nl.GENL_CTRL_ATTR_MAXATTR:\n\t\t\tf.MaxAttr = native.Uint32(a.Value)\n\t\tcase nl.GENL_CTRL_ATTR_OPS:\n\t\t\tops, err := parseOps(a.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf.Ops = ops\n\t\tcase nl.GENL_CTRL_ATTR_MCAST_GROUPS:\n\t\t\tgroups, err := parseMulticastGroups(a.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf.Groups = groups\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc parseFamilies(msgs [][]byte) ([]*GenlFamily, error) {\n\tfamilies := make([]*GenlFamily, 0, len(msgs))\n\tfor _, m := range msgs {\n\t\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofGenlmsg:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfamily := &GenlFamily{}\n\t\tif err := family.parseAttributes(attrs); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfamilies = append(families, family)\n\t}\n\treturn families, nil\n}\n\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) GenlFamilyList() ([]*GenlFamily, error) {\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.GENL_CTRL_CMD_GETFAMILY,\n\t\tVersion: nl.GENL_CTRL_VERSION,\n\t}\n\treq := h.newNetlinkRequest(nl.GENL_ID_CTRL, unix.NLM_F_DUMP)\n\treq.AddData(msg)\n\tmsgs, executeErr := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tfamilies, err := parseFamilies(msgs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn families, executeErr\n}\n\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc GenlFamilyList() ([]*GenlFamily, error) {\n\treturn pkgHandle.GenlFamilyList()\n}\n\nfunc (h *Handle) GenlFamilyGet(name string) (*GenlFamily, error) {\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.GENL_CTRL_CMD_GETFAMILY,\n\t\tVersion: nl.GENL_CTRL_VERSION,\n\t}\n\treq := h.newNetlinkRequest(nl.GENL_ID_CTRL, 0)\n\treq.AddData(msg)\n\treq.AddData(nl.NewRtAttr(nl.GENL_CTRL_ATTR_FAMILY_NAME, nl.ZeroTerminated(name)))\n\tmsgs, err := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfamilies, err := parseFamilies(msgs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(families) != 1 {\n\t\treturn nil, fmt.Errorf(\"invalid response for GENL_CTRL_CMD_GETFAMILY\")\n\t}\n\treturn families[0], nil\n}\n\nfunc GenlFamilyGet(name string) (*GenlFamily, error) {\n\treturn pkgHandle.GenlFamilyGet(name)\n}\n"
        },
        {
          "name": "genetlink_unspecified.go",
          "type": "blob",
          "size": 0.46875,
          "content": "// +build !linux\n\npackage netlink\n\ntype GenlOp struct{}\n\ntype GenlMulticastGroup struct{}\n\ntype GenlFamily struct{}\n\nfunc (h *Handle) GenlFamilyList() ([]*GenlFamily, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc GenlFamilyList() ([]*GenlFamily, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) GenlFamilyGet(name string) (*GenlFamily, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc GenlFamilyGet(name string) (*GenlFamily, error) {\n\treturn nil, ErrNotImplemented\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1201171875,
          "content": "module github.com/vishvananda/netlink\n\ngo 1.12\n\nrequire (\n\tgithub.com/vishvananda/netns v0.0.4\n\tgolang.org/x/sys v0.10.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.3974609375,
          "content": "github.com/vishvananda/netns v0.0.4 h1:Oeaw1EM2JMxD51g9uhtC0D7erkIjgmj8+JZc26m1YX8=\ngithub.com/vishvananda/netns v0.0.4/go.mod h1:SpkAiCQRtJ6TvvxPnOSyH3BMl6unz3xZlaprSwhNNJM=\ngolang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.10.0 h1:SqMFp9UcQJZa+pmYuAKjd9xq1f0j5rLcDIk0mj4qAsA=\ngolang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n"
        },
        {
          "name": "gtp_linux.go",
          "type": "blob",
          "size": 6.982421875,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\ntype PDP struct {\n\tVersion     uint32\n\tTID         uint64\n\tPeerAddress net.IP\n\tMSAddress   net.IP\n\tFlow        uint16\n\tNetNSFD     uint32\n\tITEI        uint32\n\tOTEI        uint32\n}\n\nfunc (pdp *PDP) String() string {\n\telems := []string{}\n\telems = append(elems, fmt.Sprintf(\"Version: %d\", pdp.Version))\n\tif pdp.Version == 0 {\n\t\telems = append(elems, fmt.Sprintf(\"TID: %d\", pdp.TID))\n\t} else if pdp.Version == 1 {\n\t\telems = append(elems, fmt.Sprintf(\"TEI: %d/%d\", pdp.ITEI, pdp.OTEI))\n\t}\n\telems = append(elems, fmt.Sprintf(\"MS-Address: %s\", pdp.MSAddress))\n\telems = append(elems, fmt.Sprintf(\"Peer-Address: %s\", pdp.PeerAddress))\n\treturn fmt.Sprintf(\"{%s}\", strings.Join(elems, \" \"))\n}\n\nfunc (p *PDP) parseAttributes(attrs []syscall.NetlinkRouteAttr) error {\n\tfor _, a := range attrs {\n\t\tswitch a.Attr.Type {\n\t\tcase nl.GENL_GTP_ATTR_VERSION:\n\t\t\tp.Version = native.Uint32(a.Value)\n\t\tcase nl.GENL_GTP_ATTR_TID:\n\t\t\tp.TID = native.Uint64(a.Value)\n\t\tcase nl.GENL_GTP_ATTR_PEER_ADDRESS:\n\t\t\tp.PeerAddress = net.IP(a.Value)\n\t\tcase nl.GENL_GTP_ATTR_MS_ADDRESS:\n\t\t\tp.MSAddress = net.IP(a.Value)\n\t\tcase nl.GENL_GTP_ATTR_FLOW:\n\t\t\tp.Flow = native.Uint16(a.Value)\n\t\tcase nl.GENL_GTP_ATTR_NET_NS_FD:\n\t\t\tp.NetNSFD = native.Uint32(a.Value)\n\t\tcase nl.GENL_GTP_ATTR_I_TEI:\n\t\t\tp.ITEI = native.Uint32(a.Value)\n\t\tcase nl.GENL_GTP_ATTR_O_TEI:\n\t\t\tp.OTEI = native.Uint32(a.Value)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parsePDP(msgs [][]byte) ([]*PDP, error) {\n\tpdps := make([]*PDP, 0, len(msgs))\n\tfor _, m := range msgs {\n\t\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofGenlmsg:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpdp := &PDP{}\n\t\tif err := pdp.parseAttributes(attrs); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpdps = append(pdps, pdp)\n\t}\n\treturn pdps, nil\n}\n\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) GTPPDPList() ([]*PDP, error) {\n\tf, err := h.GenlFamilyGet(nl.GENL_GTP_NAME)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.GENL_GTP_CMD_GETPDP,\n\t\tVersion: nl.GENL_GTP_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(f.ID), unix.NLM_F_DUMP)\n\treq.AddData(msg)\n\tmsgs, executeErr := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif executeErr != nil && !errors.Is(err, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tpdps, err := parsePDP(msgs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn pdps, executeErr\n}\n\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc GTPPDPList() ([]*PDP, error) {\n\treturn pkgHandle.GTPPDPList()\n}\n\nfunc gtpPDPGet(req *nl.NetlinkRequest) (*PDP, error) {\n\tmsgs, err := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpdps, err := parsePDP(msgs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(pdps) != 1 {\n\t\treturn nil, fmt.Errorf(\"invalid reqponse for GENL_GTP_CMD_GETPDP\")\n\t}\n\treturn pdps[0], nil\n}\n\nfunc (h *Handle) GTPPDPByTID(link Link, tid int) (*PDP, error) {\n\tf, err := h.GenlFamilyGet(nl.GENL_GTP_NAME)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.GENL_GTP_CMD_GETPDP,\n\t\tVersion: nl.GENL_GTP_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(f.ID), 0)\n\treq.AddData(msg)\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_VERSION, nl.Uint32Attr(0)))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_LINK, nl.Uint32Attr(uint32(link.Attrs().Index))))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_TID, nl.Uint64Attr(uint64(tid))))\n\treturn gtpPDPGet(req)\n}\n\nfunc GTPPDPByTID(link Link, tid int) (*PDP, error) {\n\treturn pkgHandle.GTPPDPByTID(link, tid)\n}\n\nfunc (h *Handle) GTPPDPByITEI(link Link, itei int) (*PDP, error) {\n\tf, err := h.GenlFamilyGet(nl.GENL_GTP_NAME)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.GENL_GTP_CMD_GETPDP,\n\t\tVersion: nl.GENL_GTP_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(f.ID), 0)\n\treq.AddData(msg)\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_VERSION, nl.Uint32Attr(1)))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_LINK, nl.Uint32Attr(uint32(link.Attrs().Index))))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_I_TEI, nl.Uint32Attr(uint32(itei))))\n\treturn gtpPDPGet(req)\n}\n\nfunc GTPPDPByITEI(link Link, itei int) (*PDP, error) {\n\treturn pkgHandle.GTPPDPByITEI(link, itei)\n}\n\nfunc (h *Handle) GTPPDPByMSAddress(link Link, addr net.IP) (*PDP, error) {\n\tf, err := h.GenlFamilyGet(nl.GENL_GTP_NAME)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.GENL_GTP_CMD_GETPDP,\n\t\tVersion: nl.GENL_GTP_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(f.ID), 0)\n\treq.AddData(msg)\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_VERSION, nl.Uint32Attr(0)))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_LINK, nl.Uint32Attr(uint32(link.Attrs().Index))))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_MS_ADDRESS, []byte(addr.To4())))\n\treturn gtpPDPGet(req)\n}\n\nfunc GTPPDPByMSAddress(link Link, addr net.IP) (*PDP, error) {\n\treturn pkgHandle.GTPPDPByMSAddress(link, addr)\n}\n\nfunc (h *Handle) GTPPDPAdd(link Link, pdp *PDP) error {\n\tf, err := h.GenlFamilyGet(nl.GENL_GTP_NAME)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.GENL_GTP_CMD_NEWPDP,\n\t\tVersion: nl.GENL_GTP_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(f.ID), unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\treq.AddData(msg)\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_VERSION, nl.Uint32Attr(pdp.Version)))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_LINK, nl.Uint32Attr(uint32(link.Attrs().Index))))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_PEER_ADDRESS, []byte(pdp.PeerAddress.To4())))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_MS_ADDRESS, []byte(pdp.MSAddress.To4())))\n\n\tswitch pdp.Version {\n\tcase 0:\n\t\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_TID, nl.Uint64Attr(pdp.TID)))\n\t\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_FLOW, nl.Uint16Attr(pdp.Flow)))\n\tcase 1:\n\t\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_I_TEI, nl.Uint32Attr(pdp.ITEI)))\n\t\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_O_TEI, nl.Uint32Attr(pdp.OTEI)))\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported GTP version: %d\", pdp.Version)\n\t}\n\t_, err = req.Execute(unix.NETLINK_GENERIC, 0)\n\treturn err\n}\n\nfunc GTPPDPAdd(link Link, pdp *PDP) error {\n\treturn pkgHandle.GTPPDPAdd(link, pdp)\n}\n\nfunc (h *Handle) GTPPDPDel(link Link, pdp *PDP) error {\n\tf, err := h.GenlFamilyGet(nl.GENL_GTP_NAME)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmsg := &nl.Genlmsg{\n\t\tCommand: nl.GENL_GTP_CMD_DELPDP,\n\t\tVersion: nl.GENL_GTP_VERSION,\n\t}\n\treq := h.newNetlinkRequest(int(f.ID), unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\treq.AddData(msg)\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_VERSION, nl.Uint32Attr(pdp.Version)))\n\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_LINK, nl.Uint32Attr(uint32(link.Attrs().Index))))\n\n\tswitch pdp.Version {\n\tcase 0:\n\t\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_TID, nl.Uint64Attr(pdp.TID)))\n\tcase 1:\n\t\treq.AddData(nl.NewRtAttr(nl.GENL_GTP_ATTR_I_TEI, nl.Uint32Attr(pdp.ITEI)))\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported GTP version: %d\", pdp.Version)\n\t}\n\t_, err = req.Execute(unix.NETLINK_GENERIC, 0)\n\treturn err\n}\n\nfunc GTPPDPDel(link Link, pdp *PDP) error {\n\treturn pkgHandle.GTPPDPDel(link, pdp)\n}\n"
        },
        {
          "name": "gtp_test.go",
          "type": "blob",
          "size": 2.1025390625,
          "content": "// +build linux\n\npackage netlink\n\nimport (\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestPDPv0AddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTestWithKModule(t, \"gtp\")\n\tdefer tearDown()\n\n\tif err := LinkAdd(testGTPLink(t)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"gtp0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = GTPPDPAdd(link, &PDP{\n\t\tPeerAddress: net.ParseIP(\"1.1.1.1\"),\n\t\tMSAddress:   net.ParseIP(\"2.2.2.2\"),\n\t\tTID:         10,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlist, err := GTPPDPList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(list) != 1 {\n\t\tt.Fatal(\"Failed to add v0 PDP\")\n\t}\n\tpdp, err := GTPPDPByMSAddress(link, net.ParseIP(\"2.2.2.2\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif pdp == nil {\n\t\tt.Fatal(\"failed to get v0 PDP by MS address\")\n\t}\n\tpdp, err = GTPPDPByTID(link, 10)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif pdp == nil {\n\t\tt.Fatal(\"failed to get v0 PDP by TID\")\n\t}\n\terr = GTPPDPDel(link, &PDP{TID: 10})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlist, err = GTPPDPList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(list) != 0 {\n\t\tt.Fatal(\"Failed to delete v0 PDP\")\n\t}\n}\n\nfunc TestPDPv1AddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTestWithKModule(t, \"gtp\")\n\tdefer tearDown()\n\n\tif err := LinkAdd(testGTPLink(t)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"gtp0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = GTPPDPAdd(link, &PDP{\n\t\tPeerAddress: net.ParseIP(\"1.1.1.1\"),\n\t\tMSAddress:   net.ParseIP(\"2.2.2.2\"),\n\t\tVersion:     1,\n\t\tITEI:        10,\n\t\tOTEI:        10,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlist, err := GTPPDPList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(list) != 1 {\n\t\tt.Fatal(\"Failed to add v1 PDP\")\n\t}\n\tpdp, err := GTPPDPByMSAddress(link, net.ParseIP(\"2.2.2.2\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif pdp == nil {\n\t\tt.Fatal(\"failed to get v1 PDP by MS address\")\n\t}\n\tpdp, err = GTPPDPByITEI(link, 10)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif pdp == nil {\n\t\tt.Fatal(\"failed to get v1 PDP by ITEI\")\n\t}\n\terr = GTPPDPDel(link, &PDP{Version: 1, ITEI: 10})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlist, err = GTPPDPList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(list) != 0 {\n\t\tt.Fatal(\"Failed to delete v1 PDP\")\n\t}\n}\n"
        },
        {
          "name": "handle_linux.go",
          "type": "blob",
          "size": 5.2685546875,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// Empty handle used by the netlink package methods\nvar pkgHandle = &Handle{}\n\n// Handle is an handle for the netlink requests on a\n// specific network namespace. All the requests on the\n// same netlink family share the same netlink socket,\n// which gets released when the handle is Close'd.\ntype Handle struct {\n\tsockets      map[int]*nl.SocketHandle\n\tlookupByDump bool\n}\n\n// SetSocketTimeout configures timeout for default netlink sockets\nfunc SetSocketTimeout(to time.Duration) error {\n\tif to < time.Microsecond {\n\t\treturn fmt.Errorf(\"invalid timeout, minimul value is %s\", time.Microsecond)\n\t}\n\n\tnl.SocketTimeoutTv = unix.NsecToTimeval(to.Nanoseconds())\n\treturn nil\n}\n\n// GetSocketTimeout returns the timeout value used by default netlink sockets\nfunc GetSocketTimeout() time.Duration {\n\tnsec := unix.TimevalToNsec(nl.SocketTimeoutTv)\n\treturn time.Duration(nsec) * time.Nanosecond\n}\n\n// SupportsNetlinkFamily reports whether the passed netlink family is supported by this Handle\nfunc (h *Handle) SupportsNetlinkFamily(nlFamily int) bool {\n\t_, ok := h.sockets[nlFamily]\n\treturn ok\n}\n\n// NewHandle returns a netlink handle on the current network namespace.\n// Caller may specify the netlink families the handle should support.\n// If no families are specified, all the families the netlink package\n// supports will be automatically added.\nfunc NewHandle(nlFamilies ...int) (*Handle, error) {\n\treturn newHandle(netns.None(), netns.None(), nlFamilies...)\n}\n\n// SetSocketTimeout sets the send and receive timeout for each socket in the\n// netlink handle. Although the socket timeout has granularity of one\n// microsecond, the effective granularity is floored by the kernel timer tick,\n// which default value is four milliseconds.\nfunc (h *Handle) SetSocketTimeout(to time.Duration) error {\n\tif to < time.Microsecond {\n\t\treturn fmt.Errorf(\"invalid timeout, minimul value is %s\", time.Microsecond)\n\t}\n\ttv := unix.NsecToTimeval(to.Nanoseconds())\n\tfor _, sh := range h.sockets {\n\t\tif err := sh.Socket.SetSendTimeout(&tv); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := sh.Socket.SetReceiveTimeout(&tv); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// SetSocketReceiveBufferSize sets the receive buffer size for each\n// socket in the netlink handle. The maximum value is capped by\n// /proc/sys/net/core/rmem_max.\nfunc (h *Handle) SetSocketReceiveBufferSize(size int, force bool) error {\n\topt := unix.SO_RCVBUF\n\tif force {\n\t\topt = unix.SO_RCVBUFFORCE\n\t}\n\tfor _, sh := range h.sockets {\n\t\tfd := sh.Socket.GetFd()\n\t\terr := unix.SetsockoptInt(fd, unix.SOL_SOCKET, opt, size)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// GetSocketReceiveBufferSize gets the receiver buffer size for each\n// socket in the netlink handle. The retrieved value should be the\n// double to the one set for SetSocketReceiveBufferSize.\nfunc (h *Handle) GetSocketReceiveBufferSize() ([]int, error) {\n\tresults := make([]int, len(h.sockets))\n\ti := 0\n\tfor _, sh := range h.sockets {\n\t\tfd := sh.Socket.GetFd()\n\t\tsize, err := unix.GetsockoptInt(fd, unix.SOL_SOCKET, unix.SO_RCVBUF)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresults[i] = size\n\t\ti++\n\t}\n\treturn results, nil\n}\n\n// SetStrictCheck sets the strict check socket option for each socket in the netlink handle. Returns early if any set operation fails\nfunc (h *Handle) SetStrictCheck(state bool) error {\n\tfor _, sh := range h.sockets {\n\t\tvar stateInt int = 0\n\t\tif state {\n\t\t\tstateInt = 1\n\t\t}\n\t\terr := unix.SetsockoptInt(sh.Socket.GetFd(), unix.SOL_NETLINK, unix.NETLINK_GET_STRICT_CHK, stateInt)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// NewHandleAt returns a netlink handle on the network namespace\n// specified by ns. If ns=netns.None(), current network namespace\n// will be assumed\nfunc NewHandleAt(ns netns.NsHandle, nlFamilies ...int) (*Handle, error) {\n\treturn newHandle(ns, netns.None(), nlFamilies...)\n}\n\n// NewHandleAtFrom works as NewHandle but allows client to specify the\n// new and the origin netns Handle.\nfunc NewHandleAtFrom(newNs, curNs netns.NsHandle) (*Handle, error) {\n\treturn newHandle(newNs, curNs)\n}\n\nfunc newHandle(newNs, curNs netns.NsHandle, nlFamilies ...int) (*Handle, error) {\n\th := &Handle{sockets: map[int]*nl.SocketHandle{}}\n\tfams := nl.SupportedNlFamilies\n\tif len(nlFamilies) != 0 {\n\t\tfams = nlFamilies\n\t}\n\tfor _, f := range fams {\n\t\ts, err := nl.GetNetlinkSocketAt(newNs, curNs, f)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\th.sockets[f] = &nl.SocketHandle{Socket: s}\n\t}\n\treturn h, nil\n}\n\n// Close releases the resources allocated to this handle\nfunc (h *Handle) Close() {\n\tfor _, sh := range h.sockets {\n\t\tsh.Close()\n\t}\n\th.sockets = nil\n}\n\n// Delete releases the resources allocated to this handle\n//\n// Deprecated: use Close instead which is in line with typical resource release\n// patterns for files and other resources.\nfunc (h *Handle) Delete() {\n\th.Close()\n}\n\nfunc (h *Handle) newNetlinkRequest(proto, flags int) *nl.NetlinkRequest {\n\t// Do this so that package API still use nl package variable nextSeqNr\n\tif h.sockets == nil {\n\t\treturn nl.NewNetlinkRequest(proto, flags)\n\t}\n\treturn &nl.NetlinkRequest{\n\t\tNlMsghdr: unix.NlMsghdr{\n\t\t\tLen:   uint32(unix.SizeofNlMsghdr),\n\t\t\tType:  uint16(proto),\n\t\t\tFlags: unix.NLM_F_REQUEST | uint16(flags),\n\t\t},\n\t\tSockets: h.sockets,\n\t}\n}\n"
        },
        {
          "name": "handle_linux_test.go",
          "type": "blob",
          "size": 0.37890625,
          "content": "package netlink\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSetGetSocketTimeout(t *testing.T) {\n\ttimeout := 10 * time.Second\n\tif err := SetSocketTimeout(10 * time.Second); err != nil {\n\t\tt.Fatalf(\"Set socket timeout for default handle failed: %v\", err)\n\t}\n\n\tif val := GetSocketTimeout(); val != timeout {\n\t\tt.Fatalf(\"Unexpected socket timeout value: got=%v, expected=%v\", val, timeout)\n\t}\n}\n"
        },
        {
          "name": "handle_test.go",
          "type": "blob",
          "size": 6.904296875,
          "content": "// +build linux\n\npackage netlink\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n)\n\nfunc TestHandleCreateClose(t *testing.T) {\n\th, err := NewHandle()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, f := range nl.SupportedNlFamilies {\n\t\tsh, ok := h.sockets[f]\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Handle socket(s) for family %d was not created\", f)\n\t\t}\n\t\tif sh.Socket == nil {\n\t\t\tt.Fatalf(\"Socket for family %d was not created\", f)\n\t\t}\n\t}\n\n\th.Close()\n\tif h.sockets != nil {\n\t\tt.Fatalf(\"Handle socket(s) were not closed\")\n\t}\n}\n\nfunc TestHandleCreateNetns(t *testing.T) {\n\tskipUnlessRoot(t)\n\n\tid := make([]byte, 4)\n\tif _, err := io.ReadFull(rand.Reader, id); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tifName := \"dummy-\" + hex.EncodeToString(id)\n\n\t// Create an handle on the current netns\n\tcurNs, err := netns.Get()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer curNs.Close()\n\n\tch, err := NewHandleAt(curNs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer ch.Close()\n\n\t// Create an handle on a custom netns\n\tnewNs, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer newNs.Close()\n\n\tnh, err := NewHandleAt(newNs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer nh.Close()\n\n\t// Create an interface using the current handle\n\terr = ch.LinkAdd(&Dummy{LinkAttrs{Name: ifName}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tl, err := ch.LinkByName(ifName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif l.Type() != \"dummy\" {\n\t\tt.Fatalf(\"Unexpected link type: %s\", l.Type())\n\t}\n\n\t// Verify the new handle cannot find the interface\n\tll, err := nh.LinkByName(ifName)\n\tif err == nil {\n\t\tt.Fatalf(\"Unexpected link found on netns %s: %v\", newNs, ll)\n\t}\n\n\t// Move the interface to the new netns\n\terr = ch.LinkSetNsFd(l, int(newNs))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Verify new netns handle can find the interface while current cannot\n\tll, err = nh.LinkByName(ifName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif ll.Type() != \"dummy\" {\n\t\tt.Fatalf(\"Unexpected link type: %s\", ll.Type())\n\t}\n\tll, err = ch.LinkByName(ifName)\n\tif err == nil {\n\t\tt.Fatalf(\"Unexpected link found on netns %s: %v\", curNs, ll)\n\t}\n}\n\nfunc TestHandleTimeout(t *testing.T) {\n\th, err := NewHandle()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer h.Close()\n\n\tfor _, sh := range h.sockets {\n\t\tverifySockTimeVal(t, sh.Socket, time.Duration(0))\n\t}\n\n\tconst timeout = 2*time.Second + 8*time.Millisecond\n\th.SetSocketTimeout(timeout)\n\n\tfor _, sh := range h.sockets {\n\t\tverifySockTimeVal(t, sh.Socket, timeout)\n\t}\n}\n\nfunc verifySockTimeVal(t *testing.T, socket *nl.NetlinkSocket, expTimeout time.Duration) {\n\tt.Helper()\n\tsend, receive := socket.GetTimeouts()\n\tif send != expTimeout || receive != expTimeout {\n\t\tt.Fatalf(\"Expected timeout: %v, got Send: %v, Receive: %v\", expTimeout, send, receive)\n\t}\n}\n\nfunc TestHandleReceiveBuffer(t *testing.T) {\n\th, err := NewHandle()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer h.Close()\n\tif err := h.SetSocketReceiveBufferSize(65536, false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsizes, err := h.GetSocketReceiveBufferSize()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(sizes) != len(h.sockets) {\n\t\tt.Fatalf(\"Unexpected number of socket buffer sizes: %d (expected %d)\",\n\t\t\tlen(sizes), len(h.sockets))\n\t}\n\tfor _, s := range sizes {\n\t\tif s < 65536 || s > 2*65536 {\n\t\t\tt.Fatalf(\"Unexpected socket receive buffer size: %d (expected around %d)\",\n\t\t\t\ts, 65536)\n\t\t}\n\t}\n}\n\nvar (\n\titer      = 10\n\tnumThread = uint32(4)\n\tprefix    = \"iface\"\n\thandle1   *Handle\n\thandle2   *Handle\n\tns1       netns.NsHandle\n\tns2       netns.NsHandle\n\tdone      uint32\n\tinitError error\n\tonce      sync.Once\n)\n\nfunc getXfrmState(thread int) *XfrmState {\n\treturn &XfrmState{\n\t\tSrc:   net.IPv4(byte(192), byte(168), 1, byte(1+thread)),\n\t\tDst:   net.IPv4(byte(192), byte(168), 2, byte(1+thread)),\n\t\tProto: XFRM_PROTO_AH,\n\t\tMode:  XFRM_MODE_TUNNEL,\n\t\tSpi:   thread,\n\t\tAuth: &XfrmStateAlgo{\n\t\t\tName: \"hmac(sha256)\",\n\t\t\tKey:  []byte(\"abcdefghijklmnopqrstuvwzyzABCDEF\"),\n\t\t},\n\t}\n}\n\nfunc getXfrmPolicy(thread int) *XfrmPolicy {\n\treturn &XfrmPolicy{\n\t\tSrc:     &net.IPNet{IP: net.IPv4(byte(10), byte(10), byte(thread), 0), Mask: []byte{255, 255, 255, 0}},\n\t\tDst:     &net.IPNet{IP: net.IPv4(byte(10), byte(10), byte(thread), 0), Mask: []byte{255, 255, 255, 0}},\n\t\tProto:   17,\n\t\tDstPort: 1234,\n\t\tSrcPort: 5678,\n\t\tDir:     XFRM_DIR_OUT,\n\t\tTmpls: []XfrmPolicyTmpl{\n\t\t\t{\n\t\t\t\tSrc:   net.IPv4(byte(192), byte(168), 1, byte(thread)),\n\t\t\t\tDst:   net.IPv4(byte(192), byte(168), 2, byte(thread)),\n\t\t\t\tProto: XFRM_PROTO_ESP,\n\t\t\t\tMode:  XFRM_MODE_TUNNEL,\n\t\t\t},\n\t\t},\n\t}\n}\nfunc initParallel() {\n\tns1, initError = netns.New()\n\tif initError != nil {\n\t\treturn\n\t}\n\thandle1, initError = NewHandleAt(ns1)\n\tif initError != nil {\n\t\treturn\n\t}\n\tns2, initError = netns.New()\n\tif initError != nil {\n\t\treturn\n\t}\n\thandle2, initError = NewHandleAt(ns2)\n\tif initError != nil {\n\t\treturn\n\t}\n}\n\nfunc parallelDone() {\n\tatomic.AddUint32(&done, 1)\n\tif done == numThread {\n\t\tif ns1.IsOpen() {\n\t\t\tns1.Close()\n\t\t}\n\t\tif ns2.IsOpen() {\n\t\t\tns2.Close()\n\t\t}\n\t\tif handle1 != nil {\n\t\t\thandle1.Close()\n\t\t}\n\t\tif handle2 != nil {\n\t\t\thandle2.Close()\n\t\t}\n\t}\n}\n\n// Do few route and xfrm operation on the two handles in parallel\nfunc runParallelTests(t *testing.T, thread int) {\n\tskipUnlessRoot(t)\n\tdefer parallelDone()\n\n\tt.Parallel()\n\n\tonce.Do(initParallel)\n\tif initError != nil {\n\t\tt.Fatal(initError)\n\t}\n\n\tstate := getXfrmState(thread)\n\tpolicy := getXfrmPolicy(thread)\n\tfor i := 0; i < iter; i++ {\n\t\tifName := fmt.Sprintf(\"%s_%d_%d\", prefix, thread, i)\n\t\tlink := &Dummy{LinkAttrs{Name: ifName}}\n\t\terr := handle1.LinkAdd(link)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tl, err := handle1.LinkByName(ifName)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle1.LinkSetUp(l)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\thandle1.LinkSetNsFd(l, int(ns2))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle1.XfrmStateAdd(state)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle1.XfrmPolicyAdd(policy)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle2.LinkSetDown(l)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle2.XfrmStateAdd(state)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle2.XfrmPolicyAdd(policy)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t_, err = handle2.LinkByName(ifName)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\thandle2.LinkSetNsFd(l, int(ns1))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle1.LinkSetUp(l)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t_, err = handle1.LinkByName(ifName)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle1.XfrmPolicyDel(policy)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle2.XfrmPolicyDel(policy)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle1.XfrmStateDel(state)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = handle2.XfrmStateDel(state)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestHandleParallel1(t *testing.T) {\n\trunParallelTests(t, 1)\n}\n\nfunc TestHandleParallel2(t *testing.T) {\n\trunParallelTests(t, 2)\n}\n\nfunc TestHandleParallel3(t *testing.T) {\n\trunParallelTests(t, 3)\n}\n\nfunc TestHandleParallel4(t *testing.T) {\n\trunParallelTests(t, 4)\n}\n"
        },
        {
          "name": "handle_unspecified.go",
          "type": "blob",
          "size": 6.4111328125,
          "content": "// +build !linux\n\npackage netlink\n\nimport (\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/vishvananda/netns\"\n)\n\ntype Handle struct{}\n\nfunc NewHandle(nlFamilies ...int) (*Handle, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc NewHandleAt(ns netns.NsHandle, nlFamilies ...int) (*Handle, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc NewHandleAtFrom(newNs, curNs netns.NsHandle) (*Handle, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) Close() {}\n\nfunc (h *Handle) Delete() {}\n\nfunc (h *Handle) SupportsNetlinkFamily(nlFamily int) bool {\n\treturn false\n}\n\nfunc (h *Handle) SetSocketTimeout(to time.Duration) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) SetPromiscOn(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) SetPromiscOff(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetUp(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetDown(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetMTU(link Link, mtu int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetName(link Link, name string) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetAlias(link Link, name string) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetHardwareAddr(link Link, hwaddr net.HardwareAddr) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetVfHardwareAddr(link Link, vf int, hwaddr net.HardwareAddr) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetVfVlan(link Link, vf, vlan int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetVfVlanQos(link Link, vf, vlan, qos int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetVfVlanQosProto(link Link, vf, vlan, qos, proto int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetVfTxRate(link Link, vf, rate int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetVfRate(link Link, vf, minRate, maxRate int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetMaster(link Link, master Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetNoMaster(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetMasterByIndex(link Link, masterIndex int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetNsPid(link Link, nspid int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetNsFd(link Link, fd int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkAdd(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkDel(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkByName(name string) (Link, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) LinkByAlias(alias string) (Link, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) LinkByIndex(index int) (Link, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) LinkList() ([]Link, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetHairpin(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetGuard(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetFastLeave(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetLearning(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetRootBlock(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetFlood(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetTxQLen(link Link, qlen int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetGroup(link Link, group int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetGSOMaxSize(link Link, maxSize int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetGROMaxSize(link Link, maxSize int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetGSOIPv4MaxSize(link Link, maxSize int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) LinkSetGROIPv4MaxSize(link Link, maxSize int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) setProtinfoAttr(link Link, mode bool, attr int) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) AddrAdd(link Link, addr *Addr) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) AddrDel(link Link, addr *Addr) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) AddrList(link Link, family int) ([]Addr, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) ClassDel(class Class) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) ClassChange(class Class) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) ClassReplace(class Class) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) ClassAdd(class Class) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) ClassList(link Link, parent uint32) ([]Class, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) FilterDel(filter Filter) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) FilterAdd(filter Filter) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) FilterList(link Link, parent uint32) ([]Filter, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) NeighAdd(neigh *Neigh) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) NeighSet(neigh *Neigh) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) NeighAppend(neigh *Neigh) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) NeighDel(neigh *Neigh) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) NeighList(linkIndex, family int) ([]Neigh, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) NeighProxyList(linkIndex, family int) ([]Neigh, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) RouteAdd(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) RouteAppend(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) RouteChange(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) RouteDel(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) RouteGet(destination net.IP) ([]Route, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) RouteList(link Link, family int) ([]Route, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) RouteListFiltered(family int, filter *Route, filterMask uint64) ([]Route, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc (h *Handle) RouteReplace(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) RuleAdd(rule *Rule) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) RuleDel(rule *Rule) error {\n\treturn ErrNotImplemented\n}\n\nfunc (h *Handle) RuleList(family int) ([]Rule, error) {\n\treturn nil, ErrNotImplemented\n}\n"
        },
        {
          "name": "inet_diag.go",
          "type": "blob",
          "size": 0.673828125,
          "content": "package netlink\n\n// INET_DIAG constatns\nconst (\n\tINET_DIAG_NONE = iota\n\tINET_DIAG_MEMINFO\n\tINET_DIAG_INFO\n\tINET_DIAG_VEGASINFO\n\tINET_DIAG_CONG\n\tINET_DIAG_TOS\n\tINET_DIAG_TCLASS\n\tINET_DIAG_SKMEMINFO\n\tINET_DIAG_SHUTDOWN\n\tINET_DIAG_DCTCPINFO\n\tINET_DIAG_PROTOCOL\n\tINET_DIAG_SKV6ONLY\n\tINET_DIAG_LOCALS\n\tINET_DIAG_PEERS\n\tINET_DIAG_PAD\n\tINET_DIAG_MARK\n\tINET_DIAG_BBRINFO\n\tINET_DIAG_CLASS_ID\n\tINET_DIAG_MD5SIG\n\tINET_DIAG_ULP_INFO\n\tINET_DIAG_SK_BPF_STORAGES\n\tINET_DIAG_CGROUP_ID\n\tINET_DIAG_SOCKOPT\n\tINET_DIAG_MAX\n)\n\ntype InetDiagTCPInfoResp struct {\n\tInetDiagMsg *Socket\n\tTCPInfo     *TCPInfo\n\tTCPBBRInfo  *TCPBBRInfo\n}\n\ntype InetDiagUDPInfoResp struct {\n\tInetDiagMsg *Socket\n\tMemory      *MemInfo\n}\n"
        },
        {
          "name": "ioctl_linux.go",
          "type": "blob",
          "size": 2.2412109375,
          "content": "package netlink\n\nimport (\n\t\"syscall\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// ioctl for statistics.\nconst (\n\t// ETHTOOL_GSSET_INFO gets string set info\n\tETHTOOL_GSSET_INFO = 0x00000037\n\t// SIOCETHTOOL is Ethtool interface\n\tSIOCETHTOOL = 0x8946\n\t// ETHTOOL_GSTRINGS gets specified string set\n\tETHTOOL_GSTRINGS = 0x0000001b\n\t// ETHTOOL_GSTATS gets NIC-specific statistics\n\tETHTOOL_GSTATS = 0x0000001d\n)\n\n// string set id.\nconst (\n\t// ETH_SS_TEST is self-test result names, for use with %ETHTOOL_TEST\n\tETH_SS_TEST = iota\n\t// ETH_SS_STATS statistic names, for use with %ETHTOOL_GSTATS\n\tETH_SS_STATS\n\t// ETH_SS_PRIV_FLAGS are driver private flag names\n\tETH_SS_PRIV_FLAGS\n\t// _ETH_SS_NTUPLE_FILTERS is deprecated\n\t_ETH_SS_NTUPLE_FILTERS\n\t// ETH_SS_FEATURES are device feature names\n\tETH_SS_FEATURES\n\t// ETH_SS_RSS_HASH_FUNCS is RSS hush function names\n\tETH_SS_RSS_HASH_FUNCS\n)\n\n// IfreqSlave is a struct for ioctl bond manipulation syscalls.\n// It is used to assign slave to bond interface with Name.\ntype IfreqSlave struct {\n\tName  [unix.IFNAMSIZ]byte\n\tSlave [unix.IFNAMSIZ]byte\n}\n\n// Ifreq is a struct for ioctl ethernet manipulation syscalls.\ntype Ifreq struct {\n\tName [unix.IFNAMSIZ]byte\n\tData uintptr\n}\n\n// ethtoolSset is a string set information\ntype ethtoolSset struct {\n\tcmd      uint32\n\treserved uint32\n\tmask     uint64\n\tdata     [1]uint32\n}\n\ntype ethtoolStats struct {\n\tcmd    uint32\n\tnStats uint32\n\t// Followed by nStats * []uint64.\n}\n\n// newIocltSlaveReq returns filled IfreqSlave with proper interface names\n// It is used by ioctl to assign slave to bond master\nfunc newIocltSlaveReq(slave, master string) *IfreqSlave {\n\tifreq := &IfreqSlave{}\n\tcopy(ifreq.Name[:unix.IFNAMSIZ-1], master)\n\tcopy(ifreq.Slave[:unix.IFNAMSIZ-1], slave)\n\treturn ifreq\n}\n\n// newIocltStringSetReq creates request to get interface string set\nfunc newIocltStringSetReq(linkName string) (*Ifreq, *ethtoolSset) {\n\te := &ethtoolSset{\n\t\tcmd:  ETHTOOL_GSSET_INFO,\n\t\tmask: 1 << ETH_SS_STATS,\n\t}\n\n\tifreq := &Ifreq{Data: uintptr(unsafe.Pointer(e))}\n\tcopy(ifreq.Name[:unix.IFNAMSIZ-1], linkName)\n\treturn ifreq, e\n}\n\n// getSocketUDP returns file descriptor to new UDP socket\n// It is used for communication with ioctl interface.\nfunc getSocketUDP() (int, error) {\n\treturn syscall.Socket(unix.AF_INET, unix.SOCK_DGRAM, 0)\n}\n"
        },
        {
          "name": "ipset_linux.go",
          "type": "blob",
          "size": 15.9052734375,
          "content": "package netlink\n\nimport (\n\t\"encoding/binary\"\n\t\"log\"\n\t\"net\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// IPSetEntry is used for adding, updating, retreiving and deleting entries\ntype IPSetEntry struct {\n\tComment  string\n\tMAC      net.HardwareAddr\n\tIP       net.IP\n\tCIDR     uint8\n\tTimeout  *uint32\n\tPackets  *uint64\n\tBytes    *uint64\n\tProtocol *uint8\n\tPort     *uint16\n\tIP2      net.IP\n\tCIDR2    uint8\n\tIFace    string\n\tMark     *uint32\n\n\tReplace bool // replace existing entry\n}\n\n// IPSetResult is the result of a dump request for a set\ntype IPSetResult struct {\n\tNfgenmsg           *nl.Nfgenmsg\n\tProtocol           uint8\n\tProtocolMinVersion uint8\n\tRevision           uint8\n\tFamily             uint8\n\tFlags              uint8\n\tSetName            string\n\tTypeName           string\n\tComment            string\n\tMarkMask           uint32\n\n\tIPFrom   net.IP\n\tIPTo     net.IP\n\tPortFrom uint16\n\tPortTo   uint16\n\n\tHashSize     uint32\n\tNumEntries   uint32\n\tMaxElements  uint32\n\tReferences   uint32\n\tSizeInMemory uint32\n\tCadtFlags    uint32\n\tTimeout      *uint32\n\tLineNo       uint32\n\n\tEntries []IPSetEntry\n}\n\n// IpsetCreateOptions is the options struct for creating a new ipset\ntype IpsetCreateOptions struct {\n\tReplace  bool // replace existing ipset\n\tTimeout  *uint32\n\tCounters bool\n\tComments bool\n\tSkbinfo  bool\n\n\tFamily      uint8\n\tRevision    uint8\n\tIPFrom      net.IP\n\tIPTo        net.IP\n\tPortFrom    uint16\n\tPortTo      uint16\n\tMaxElements uint32\n}\n\n// IpsetProtocol returns the ipset protocol version from the kernel\nfunc IpsetProtocol() (uint8, uint8, error) {\n\treturn pkgHandle.IpsetProtocol()\n}\n\n// IpsetCreate creates a new ipset\nfunc IpsetCreate(setname, typename string, options IpsetCreateOptions) error {\n\treturn pkgHandle.IpsetCreate(setname, typename, options)\n}\n\n// IpsetDestroy destroys an existing ipset\nfunc IpsetDestroy(setname string) error {\n\treturn pkgHandle.IpsetDestroy(setname)\n}\n\n// IpsetFlush flushes an existing ipset\nfunc IpsetFlush(setname string) error {\n\treturn pkgHandle.IpsetFlush(setname)\n}\n\n// IpsetSwap swaps two ipsets.\nfunc IpsetSwap(setname, othersetname string) error {\n\treturn pkgHandle.IpsetSwap(setname, othersetname)\n}\n\n// IpsetList dumps an specific ipset.\nfunc IpsetList(setname string) (*IPSetResult, error) {\n\treturn pkgHandle.IpsetList(setname)\n}\n\n// IpsetListAll dumps all ipsets.\nfunc IpsetListAll() ([]IPSetResult, error) {\n\treturn pkgHandle.IpsetListAll()\n}\n\n// IpsetAdd adds an entry to an existing ipset.\nfunc IpsetAdd(setname string, entry *IPSetEntry) error {\n\treturn pkgHandle.IpsetAdd(setname, entry)\n}\n\n// IpsetDel deletes an entry from an existing ipset.\nfunc IpsetDel(setname string, entry *IPSetEntry) error {\n\treturn pkgHandle.IpsetDel(setname, entry)\n}\n\n// IpsetTest tests whether an entry is in a set or not.\nfunc IpsetTest(setname string, entry *IPSetEntry) (bool, error) {\n\treturn pkgHandle.IpsetTest(setname, entry)\n}\n\nfunc (h *Handle) IpsetProtocol() (protocol uint8, minVersion uint8, err error) {\n\treq := h.newIpsetRequest(nl.IPSET_CMD_PROTOCOL)\n\tmsgs, err := req.Execute(unix.NETLINK_NETFILTER, 0)\n\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tresponse := ipsetUnserialize(msgs)\n\treturn response.Protocol, response.ProtocolMinVersion, nil\n}\n\nfunc (h *Handle) IpsetCreate(setname, typename string, options IpsetCreateOptions) error {\n\treq := h.newIpsetRequest(nl.IPSET_CMD_CREATE)\n\n\tif !options.Replace {\n\t\treq.Flags |= unix.NLM_F_EXCL\n\t}\n\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_SETNAME, nl.ZeroTerminated(setname)))\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_TYPENAME, nl.ZeroTerminated(typename)))\n\n\trevision := options.Revision\n\tif revision == 0 {\n\t\trevision = getIpsetDefaultWithTypeName(typename)\n\t}\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_REVISION, nl.Uint8Attr(revision)))\n\n\tdata := nl.NewRtAttr(nl.IPSET_ATTR_DATA|int(nl.NLA_F_NESTED), nil)\n\n\tvar family uint8\n\tswitch typename {\n\tcase \"hash:mac\":\n\tcase \"bitmap:port\":\n\t\tbuf := make([]byte, 4)\n\t\tbinary.BigEndian.PutUint16(buf, options.PortFrom)\n\t\tbinary.BigEndian.PutUint16(buf[2:], options.PortTo)\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_PORT_FROM|int(nl.NLA_F_NET_BYTEORDER), buf[:2]))\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_PORT_TO|int(nl.NLA_F_NET_BYTEORDER), buf[2:]))\n\tdefault:\n\t\tfamily = options.Family\n\t\tif family == 0 {\n\t\t\tfamily = unix.AF_INET\n\t\t}\n\t}\n\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_FAMILY, nl.Uint8Attr(family)))\n\n\tif options.MaxElements != 0 {\n\t\tdata.AddChild(&nl.Uint32Attribute{Type: nl.IPSET_ATTR_MAXELEM | nl.NLA_F_NET_BYTEORDER, Value: options.MaxElements})\n\t}\n\n\tif timeout := options.Timeout; timeout != nil {\n\t\tdata.AddChild(&nl.Uint32Attribute{Type: nl.IPSET_ATTR_TIMEOUT | nl.NLA_F_NET_BYTEORDER, Value: *timeout})\n\t}\n\n\tvar cadtFlags uint32\n\n\tif options.Comments {\n\t\tcadtFlags |= nl.IPSET_FLAG_WITH_COMMENT\n\t}\n\tif options.Counters {\n\t\tcadtFlags |= nl.IPSET_FLAG_WITH_COUNTERS\n\t}\n\tif options.Skbinfo {\n\t\tcadtFlags |= nl.IPSET_FLAG_WITH_SKBINFO\n\t}\n\n\tif cadtFlags != 0 {\n\t\tdata.AddChild(&nl.Uint32Attribute{Type: nl.IPSET_ATTR_CADT_FLAGS | nl.NLA_F_NET_BYTEORDER, Value: cadtFlags})\n\t}\n\n\treq.AddData(data)\n\t_, err := ipsetExecute(req)\n\treturn err\n}\n\nfunc (h *Handle) IpsetDestroy(setname string) error {\n\treq := h.newIpsetRequest(nl.IPSET_CMD_DESTROY)\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_SETNAME, nl.ZeroTerminated(setname)))\n\t_, err := ipsetExecute(req)\n\treturn err\n}\n\nfunc (h *Handle) IpsetFlush(setname string) error {\n\treq := h.newIpsetRequest(nl.IPSET_CMD_FLUSH)\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_SETNAME, nl.ZeroTerminated(setname)))\n\t_, err := ipsetExecute(req)\n\treturn err\n}\n\nfunc (h *Handle) IpsetSwap(setname, othersetname string) error {\n\treq := h.newIpsetRequest(nl.IPSET_CMD_SWAP)\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_SETNAME, nl.ZeroTerminated(setname)))\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_TYPENAME, nl.ZeroTerminated(othersetname)))\n\t_, err := ipsetExecute(req)\n\treturn err\n}\n\nfunc (h *Handle) IpsetList(name string) (*IPSetResult, error) {\n\treq := h.newIpsetRequest(nl.IPSET_CMD_LIST)\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_SETNAME, nl.ZeroTerminated(name)))\n\n\tmsgs, err := ipsetExecute(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := ipsetUnserialize(msgs)\n\treturn &result, nil\n}\n\nfunc (h *Handle) IpsetListAll() ([]IPSetResult, error) {\n\treq := h.newIpsetRequest(nl.IPSET_CMD_LIST)\n\n\tmsgs, err := ipsetExecute(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := make([]IPSetResult, len(msgs))\n\tfor i, msg := range msgs {\n\t\tresult[i].unserialize(msg)\n\t}\n\n\treturn result, nil\n}\n\n// IpsetAdd adds an entry to an existing ipset.\nfunc (h *Handle) IpsetAdd(setname string, entry *IPSetEntry) error {\n\treturn h.ipsetAddDel(nl.IPSET_CMD_ADD, setname, entry)\n}\n\n// IpsetDel deletes an entry from an existing ipset.\nfunc (h *Handle) IpsetDel(setname string, entry *IPSetEntry) error {\n\treturn h.ipsetAddDel(nl.IPSET_CMD_DEL, setname, entry)\n}\n\nfunc encodeIP(ip net.IP) (*nl.RtAttr, error) {\n\ttyp := int(nl.NLA_F_NET_BYTEORDER)\n\tif ip4 := ip.To4(); ip4 != nil {\n\t\ttyp |= nl.IPSET_ATTR_IPADDR_IPV4\n\t\tip = ip4\n\t} else {\n\t\ttyp |= nl.IPSET_ATTR_IPADDR_IPV6\n\t}\n\n\treturn nl.NewRtAttr(typ, ip), nil\n}\n\nfunc buildEntryData(entry *IPSetEntry) (*nl.RtAttr, error) {\n\tdata := nl.NewRtAttr(nl.IPSET_ATTR_DATA|int(nl.NLA_F_NESTED), nil)\n\n\tif entry.Comment != \"\" {\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_COMMENT, nl.ZeroTerminated(entry.Comment)))\n\t}\n\n\tif entry.Timeout != nil {\n\t\tdata.AddChild(&nl.Uint32Attribute{Type: nl.IPSET_ATTR_TIMEOUT | nl.NLA_F_NET_BYTEORDER, Value: *entry.Timeout})\n\t}\n\n\tif entry.IP != nil {\n\t\tnestedData, err := encodeIP(entry.IP)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_IP|int(nl.NLA_F_NESTED), nestedData.Serialize()))\n\t}\n\n\tif entry.MAC != nil {\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_ETHER, entry.MAC))\n\t}\n\n\tif entry.CIDR != 0 {\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_CIDR, nl.Uint8Attr(entry.CIDR)))\n\t}\n\n\tif entry.IP2 != nil {\n\t\tnestedData, err := encodeIP(entry.IP2)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_IP2|int(nl.NLA_F_NESTED), nestedData.Serialize()))\n\t}\n\n\tif entry.CIDR2 != 0 {\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_CIDR2, nl.Uint8Attr(entry.CIDR2)))\n\t}\n\n\tif entry.Port != nil {\n\t\tif entry.Protocol == nil {\n\t\t\t// use tcp protocol as default\n\t\t\tval := uint8(unix.IPPROTO_TCP)\n\t\t\tentry.Protocol = &val\n\t\t}\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_PROTO, nl.Uint8Attr(*entry.Protocol)))\n\t\tbuf := make([]byte, 2)\n\t\tbinary.BigEndian.PutUint16(buf, *entry.Port)\n\t\tdata.AddChild(nl.NewRtAttr(int(nl.IPSET_ATTR_PORT|nl.NLA_F_NET_BYTEORDER), buf))\n\t}\n\n\tif entry.IFace != \"\" {\n\t\tdata.AddChild(nl.NewRtAttr(nl.IPSET_ATTR_IFACE, nl.ZeroTerminated(entry.IFace)))\n\t}\n\n\tif entry.Mark != nil {\n\t\tdata.AddChild(&nl.Uint32Attribute{Type: nl.IPSET_ATTR_MARK | nl.NLA_F_NET_BYTEORDER, Value: *entry.Mark})\n\t}\n\treturn data, nil\n}\n\nfunc (h *Handle) ipsetAddDel(nlCmd int, setname string, entry *IPSetEntry) error {\n\treq := h.newIpsetRequest(nlCmd)\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_SETNAME, nl.ZeroTerminated(setname)))\n\n\tif !entry.Replace {\n\t\treq.Flags |= unix.NLM_F_EXCL\n\t}\n\n\tdata, err := buildEntryData(entry)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdata.AddChild(&nl.Uint32Attribute{Type: nl.IPSET_ATTR_LINENO | nl.NLA_F_NET_BYTEORDER, Value: 0})\n\treq.AddData(data)\n\n\t_, err = ipsetExecute(req)\n\treturn err\n}\n\nfunc (h *Handle) IpsetTest(setname string, entry *IPSetEntry) (bool, error) {\n\treq := h.newIpsetRequest(nl.IPSET_CMD_TEST)\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_SETNAME, nl.ZeroTerminated(setname)))\n\n\tif !entry.Replace {\n\t\treq.Flags |= unix.NLM_F_EXCL\n\t}\n\n\tdata, err := buildEntryData(entry)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treq.AddData(data)\n\n\t_, err = ipsetExecute(req)\n\tif err != nil {\n\t\tif err == nl.IPSetError(nl.IPSET_ERR_EXIST) {\n\t\t\t// not exist\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\treturn true, nil\n}\n\nfunc (h *Handle) newIpsetRequest(cmd int) *nl.NetlinkRequest {\n\treq := h.newNetlinkRequest(cmd|(unix.NFNL_SUBSYS_IPSET<<8), nl.GetIpsetFlags(cmd))\n\n\t// Add the netfilter header\n\tmsg := &nl.Nfgenmsg{\n\t\tNfgenFamily: uint8(unix.AF_NETLINK),\n\t\tVersion:     nl.NFNETLINK_V0,\n\t\tResId:       0,\n\t}\n\treq.AddData(msg)\n\treq.AddData(nl.NewRtAttr(nl.IPSET_ATTR_PROTOCOL, nl.Uint8Attr(nl.IPSET_PROTOCOL)))\n\n\treturn req\n}\n\nfunc getIpsetDefaultWithTypeName(typename string) uint8 {\n\tswitch typename {\n\tcase \"hash:ip,port\",\n\t\t\"hash:ip,port,ip\",\n\t\t\"hash:ip,port,net\",\n\t\t\"hash:net,port\":\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc ipsetExecute(req *nl.NetlinkRequest) (msgs [][]byte, err error) {\n\tmsgs, err = req.Execute(unix.NETLINK_NETFILTER, 0)\n\n\tif err != nil {\n\t\tif errno := int(err.(syscall.Errno)); errno >= nl.IPSET_ERR_PRIVATE {\n\t\t\terr = nl.IPSetError(uintptr(errno))\n\t\t}\n\t}\n\treturn\n}\n\nfunc ipsetUnserialize(msgs [][]byte) (result IPSetResult) {\n\tfor _, msg := range msgs {\n\t\tresult.unserialize(msg)\n\t}\n\treturn result\n}\n\nfunc (result *IPSetResult) unserialize(msg []byte) {\n\tresult.Nfgenmsg = nl.DeserializeNfgenmsg(msg)\n\n\tfor attr := range nl.ParseAttributes(msg[4:]) {\n\t\tswitch attr.Type {\n\t\tcase nl.IPSET_ATTR_PROTOCOL:\n\t\t\tresult.Protocol = attr.Value[0]\n\t\tcase nl.IPSET_ATTR_SETNAME:\n\t\t\tresult.SetName = nl.BytesToString(attr.Value)\n\t\tcase nl.IPSET_ATTR_COMMENT:\n\t\t\tresult.Comment = nl.BytesToString(attr.Value)\n\t\tcase nl.IPSET_ATTR_TYPENAME:\n\t\t\tresult.TypeName = nl.BytesToString(attr.Value)\n\t\tcase nl.IPSET_ATTR_REVISION:\n\t\t\tresult.Revision = attr.Value[0]\n\t\tcase nl.IPSET_ATTR_FAMILY:\n\t\t\tresult.Family = attr.Value[0]\n\t\tcase nl.IPSET_ATTR_FLAGS:\n\t\t\tresult.Flags = attr.Value[0]\n\t\tcase nl.IPSET_ATTR_DATA | nl.NLA_F_NESTED:\n\t\t\tresult.parseAttrData(attr.Value)\n\t\tcase nl.IPSET_ATTR_ADT | nl.NLA_F_NESTED:\n\t\t\tresult.parseAttrADT(attr.Value)\n\t\tcase nl.IPSET_ATTR_PROTOCOL_MIN:\n\t\t\tresult.ProtocolMinVersion = attr.Value[0]\n\t\tcase nl.IPSET_ATTR_MARKMASK:\n\t\t\tresult.MarkMask = attr.Uint32()\n\t\tdefault:\n\t\t\tlog.Printf(\"unknown ipset attribute from kernel: %+v %v\", attr, attr.Type&nl.NLA_TYPE_MASK)\n\t\t}\n\t}\n}\n\nfunc (result *IPSetResult) parseAttrData(data []byte) {\n\tfor attr := range nl.ParseAttributes(data) {\n\t\tswitch attr.Type {\n\t\tcase nl.IPSET_ATTR_HASHSIZE | nl.NLA_F_NET_BYTEORDER:\n\t\t\tresult.HashSize = attr.Uint32()\n\t\tcase nl.IPSET_ATTR_MAXELEM | nl.NLA_F_NET_BYTEORDER:\n\t\t\tresult.MaxElements = attr.Uint32()\n\t\tcase nl.IPSET_ATTR_TIMEOUT | nl.NLA_F_NET_BYTEORDER:\n\t\t\tval := attr.Uint32()\n\t\t\tresult.Timeout = &val\n\t\tcase nl.IPSET_ATTR_ELEMENTS | nl.NLA_F_NET_BYTEORDER:\n\t\t\tresult.NumEntries = attr.Uint32()\n\t\tcase nl.IPSET_ATTR_REFERENCES | nl.NLA_F_NET_BYTEORDER:\n\t\t\tresult.References = attr.Uint32()\n\t\tcase nl.IPSET_ATTR_MEMSIZE | nl.NLA_F_NET_BYTEORDER:\n\t\t\tresult.SizeInMemory = attr.Uint32()\n\t\tcase nl.IPSET_ATTR_CADT_FLAGS | nl.NLA_F_NET_BYTEORDER:\n\t\t\tresult.CadtFlags = attr.Uint32()\n\t\tcase nl.IPSET_ATTR_IP | nl.NLA_F_NESTED:\n\t\t\tfor nested := range nl.ParseAttributes(attr.Value) {\n\t\t\t\tswitch nested.Type {\n\t\t\t\tcase nl.IPSET_ATTR_IP | nl.NLA_F_NET_BYTEORDER:\n\t\t\t\t\tresult.Entries = append(result.Entries, IPSetEntry{IP: nested.Value})\n\t\t\t\tcase nl.IPSET_ATTR_IP:\n\t\t\t\t\tresult.IPFrom = nested.Value\n\t\t\t\tdefault:\n\t\t\t\t\tlog.Printf(\"unknown nested ipset data attribute from kernel: %+v %v\", nested, nested.Type&nl.NLA_TYPE_MASK)\n\t\t\t\t}\n\t\t\t}\n\t\tcase nl.IPSET_ATTR_IP_TO | nl.NLA_F_NESTED:\n\t\t\tfor nested := range nl.ParseAttributes(attr.Value) {\n\t\t\t\tswitch nested.Type {\n\t\t\t\tcase nl.IPSET_ATTR_IP:\n\t\t\t\t\tresult.IPTo = nested.Value\n\t\t\t\tdefault:\n\t\t\t\t\tlog.Printf(\"unknown nested ipset data attribute from kernel: %+v %v\", nested, nested.Type&nl.NLA_TYPE_MASK)\n\t\t\t\t}\n\t\t\t}\n\t\tcase nl.IPSET_ATTR_PORT_FROM | nl.NLA_F_NET_BYTEORDER:\n\t\t\tresult.PortFrom = networkOrder.Uint16(attr.Value)\n\t\tcase nl.IPSET_ATTR_PORT_TO | nl.NLA_F_NET_BYTEORDER:\n\t\t\tresult.PortTo = networkOrder.Uint16(attr.Value)\n\t\tcase nl.IPSET_ATTR_CADT_LINENO | nl.NLA_F_NET_BYTEORDER:\n\t\t\tresult.LineNo = attr.Uint32()\n\t\tcase nl.IPSET_ATTR_COMMENT:\n\t\t\tresult.Comment = nl.BytesToString(attr.Value)\n\t\tcase nl.IPSET_ATTR_MARKMASK:\n\t\t\tresult.MarkMask = attr.Uint32()\n\t\tdefault:\n\t\t\tlog.Printf(\"unknown ipset data attribute from kernel: %+v %v\", attr, attr.Type&nl.NLA_TYPE_MASK)\n\t\t}\n\t}\n}\n\nfunc (result *IPSetResult) parseAttrADT(data []byte) {\n\tfor attr := range nl.ParseAttributes(data) {\n\t\tswitch attr.Type {\n\t\tcase nl.IPSET_ATTR_DATA | nl.NLA_F_NESTED:\n\t\t\tresult.Entries = append(result.Entries, parseIPSetEntry(attr.Value))\n\t\tdefault:\n\t\t\tlog.Printf(\"unknown ADT attribute from kernel: %+v %v\", attr, attr.Type&nl.NLA_TYPE_MASK)\n\t\t}\n\t}\n}\n\nfunc parseIPSetEntry(data []byte) (entry IPSetEntry) {\n\tfor attr := range nl.ParseAttributes(data) {\n\t\tswitch attr.Type {\n\t\tcase nl.IPSET_ATTR_TIMEOUT | nl.NLA_F_NET_BYTEORDER:\n\t\t\tval := attr.Uint32()\n\t\t\tentry.Timeout = &val\n\t\tcase nl.IPSET_ATTR_BYTES | nl.NLA_F_NET_BYTEORDER:\n\t\t\tval := attr.Uint64()\n\t\t\tentry.Bytes = &val\n\t\tcase nl.IPSET_ATTR_PACKETS | nl.NLA_F_NET_BYTEORDER:\n\t\t\tval := attr.Uint64()\n\t\t\tentry.Packets = &val\n\t\tcase nl.IPSET_ATTR_ETHER:\n\t\t\tentry.MAC = net.HardwareAddr(attr.Value)\n\t\tcase nl.IPSET_ATTR_IP:\n\t\t\tentry.IP = net.IP(attr.Value)\n\t\tcase nl.IPSET_ATTR_COMMENT:\n\t\t\tentry.Comment = nl.BytesToString(attr.Value)\n\t\tcase nl.IPSET_ATTR_IP | nl.NLA_F_NESTED:\n\t\t\tfor attr := range nl.ParseAttributes(attr.Value) {\n\t\t\t\tswitch attr.Type {\n\t\t\t\tcase nl.IPSET_ATTR_IPADDR_IPV4, nl.IPSET_ATTR_IPADDR_IPV6:\n\t\t\t\t\tentry.IP = net.IP(attr.Value)\n\t\t\t\tdefault:\n\t\t\t\t\tlog.Printf(\"unknown nested ADT attribute from kernel: %+v\", attr)\n\t\t\t\t}\n\t\t\t}\n\t\tcase nl.IPSET_ATTR_IP2 | nl.NLA_F_NESTED:\n\t\t\tfor attr := range nl.ParseAttributes(attr.Value) {\n\t\t\t\tswitch attr.Type {\n\t\t\t\tcase nl.IPSET_ATTR_IPADDR_IPV4, nl.IPSET_ATTR_IPADDR_IPV6:\n\t\t\t\t\tentry.IP2 = net.IP(attr.Value)\n\t\t\t\tdefault:\n\t\t\t\t\tlog.Printf(\"unknown nested ADT attribute from kernel: %+v\", attr)\n\t\t\t\t}\n\t\t\t}\n\t\tcase nl.IPSET_ATTR_CIDR:\n\t\t\tentry.CIDR = attr.Value[0]\n\t\tcase nl.IPSET_ATTR_CIDR2:\n\t\t\tentry.CIDR2 = attr.Value[0]\n\t\tcase nl.IPSET_ATTR_PORT | nl.NLA_F_NET_BYTEORDER:\n\t\t\tval := networkOrder.Uint16(attr.Value)\n\t\t\tentry.Port = &val\n\t\tcase nl.IPSET_ATTR_PROTO:\n\t\t\tval := attr.Value[0]\n\t\t\tentry.Protocol = &val\n\t\tcase nl.IPSET_ATTR_IFACE:\n\t\t\tentry.IFace = nl.BytesToString(attr.Value)\n\t\tcase nl.IPSET_ATTR_MARK | nl.NLA_F_NET_BYTEORDER:\n\t\t\tval := attr.Uint32()\n\t\t\tentry.Mark = &val\n\t\tdefault:\n\t\t\tlog.Printf(\"unknown ADT attribute from kernel: %+v\", attr)\n\t\t}\n\t}\n\treturn\n}\n"
        },
        {
          "name": "ipset_linux_test.go",
          "type": "blob",
          "size": 17.6337890625,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"testing\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestParseIpsetProtocolResult(t *testing.T) {\n\tmsgBytes, err := ioutil.ReadFile(\"testdata/ipset_protocol_result\")\n\tif err != nil {\n\t\tt.Fatalf(\"reading test fixture failed: %v\", err)\n\t}\n\n\tmsg := ipsetUnserialize([][]byte{msgBytes})\n\tif msg.Protocol != 6 {\n\t\tt.Errorf(\"expected msg.Protocol to equal 6, got %d\", msg.Protocol)\n\t}\n}\n\nfunc TestParseIpsetListResult(t *testing.T) {\n\tmsgBytes, err := ioutil.ReadFile(\"testdata/ipset_list_result\")\n\tif err != nil {\n\t\tt.Fatalf(\"reading test fixture failed: %v\", err)\n\t}\n\n\tmsg := ipsetUnserialize([][]byte{msgBytes})\n\tif msg.SetName != \"clients\" {\n\t\tt.Errorf(`expected SetName to equal \"clients\", got %q`, msg.SetName)\n\t}\n\tif msg.TypeName != \"hash:mac\" {\n\t\tt.Errorf(`expected TypeName to equal \"hash:mac\", got %q`, msg.TypeName)\n\t}\n\tif msg.Protocol != 6 {\n\t\tt.Errorf(\"expected Protocol to equal 6, got %d\", msg.Protocol)\n\t}\n\tif msg.References != 0 {\n\t\tt.Errorf(\"expected References to equal 0, got %d\", msg.References)\n\t}\n\tif msg.NumEntries != 2 {\n\t\tt.Errorf(\"expected NumEntries to equal 2, got %d\", msg.NumEntries)\n\t}\n\tif msg.HashSize != 1024 {\n\t\tt.Errorf(\"expected HashSize to equal 1024, got %d\", msg.HashSize)\n\t}\n\tif *msg.Timeout != 3600 {\n\t\tt.Errorf(\"expected Timeout to equal 3600, got %d\", *msg.Timeout)\n\t}\n\tif msg.MaxElements != 65536 {\n\t\tt.Errorf(\"expected MaxElements to equal 65536, got %d\", msg.MaxElements)\n\t}\n\tif msg.CadtFlags != nl.IPSET_FLAG_WITH_COMMENT|nl.IPSET_FLAG_WITH_COUNTERS {\n\t\tt.Error(\"expected CadtFlags to be IPSET_FLAG_WITH_COMMENT and IPSET_FLAG_WITH_COUNTERS\")\n\t}\n\tif len(msg.Entries) != 2 {\n\t\tt.Fatalf(\"expected 2 Entries, got %d\", len(msg.Entries))\n\t}\n\n\t// first entry\n\tent := msg.Entries[0]\n\tif int(*ent.Timeout) != 3577 {\n\t\tt.Errorf(\"expected Timeout for first entry to equal 3577, got %d\", *ent.Timeout)\n\t}\n\tif int(*ent.Bytes) != 4121 {\n\t\tt.Errorf(\"expected Bytes for first entry to equal 4121, got %d\", *ent.Bytes)\n\t}\n\tif int(*ent.Packets) != 42 {\n\t\tt.Errorf(\"expected Packets for first entry to equal 42, got %d\", *ent.Packets)\n\t}\n\tif ent.Comment != \"foo bar\" {\n\t\tt.Errorf(\"unexpected Comment for first entry: %q\", ent.Comment)\n\t}\n\texpectedMAC := net.HardwareAddr{0xde, 0xad, 0x0, 0x0, 0xbe, 0xef}\n\tif !bytes.Equal(ent.MAC, expectedMAC) {\n\t\tt.Errorf(\"expected MAC for first entry to be %s, got %s\", expectedMAC.String(), ent.MAC.String())\n\t}\n\n\t// second entry\n\tent = msg.Entries[1]\n\texpectedMAC = net.HardwareAddr{0x1, 0x2, 0x3, 0x0, 0x1, 0x2}\n\tif !bytes.Equal(ent.MAC, expectedMAC) {\n\t\tt.Errorf(\"expected MAC for second entry to be %s, got %s\", expectedMAC.String(), ent.MAC.String())\n\t}\n}\n\nfunc TestIpsetCreateListAddDelDestroy(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\ttimeout := uint32(3)\n\terr := IpsetCreate(\"my-test-ipset-1\", \"hash:ip\", IpsetCreateOptions{\n\t\tReplace:  true,\n\t\tTimeout:  &timeout,\n\t\tCounters: true,\n\t\tComments: true,\n\t\tSkbinfo:  false,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = IpsetCreate(\"my-test-ipset-2\", \"hash:net\", IpsetCreateOptions{\n\t\tReplace:  true,\n\t\tTimeout:  &timeout,\n\t\tCounters: false,\n\t\tComments: true,\n\t\tSkbinfo:  true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresults, err := IpsetListAll()\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(results) != 2 {\n\t\tt.Fatalf(\"expected 2 IPSets to be created, got %d\", len(results))\n\t}\n\n\tif results[0].SetName != \"my-test-ipset-1\" {\n\t\tt.Errorf(\"expected name to be 'my-test-ipset-1', but got '%s'\", results[0].SetName)\n\t}\n\n\tif results[1].SetName != \"my-test-ipset-2\" {\n\t\tt.Errorf(\"expected name to be 'my-test-ipset-2', but got '%s'\", results[1].SetName)\n\t}\n\n\tif results[0].TypeName != \"hash:ip\" {\n\t\tt.Errorf(\"expected type to be 'hash:ip', but got '%s'\", results[0].TypeName)\n\t}\n\n\tif results[1].TypeName != \"hash:net\" {\n\t\tt.Errorf(\"expected type to be 'hash:net', but got '%s'\", results[1].TypeName)\n\t}\n\n\tif *results[0].Timeout != 3 {\n\t\tt.Errorf(\"expected timeout to be 3, but got '%d'\", *results[0].Timeout)\n\t}\n\n\tip := net.ParseIP(\"10.99.99.99\")\n\texist, err := IpsetTest(\"my-test-ipset-1\", &IPSetEntry{\n\t\tIP: ip,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exist {\n\t\tt.Errorf(\"entry should not exist before being added: %s\", ip.String())\n\t}\n\n\terr = IpsetAdd(\"my-test-ipset-1\", &IPSetEntry{\n\t\tComment: \"test comment\",\n\t\tIP:      ip,\n\t\tReplace: false,\n\t})\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texist, err = IpsetTest(\"my-test-ipset-1\", &IPSetEntry{\n\t\tIP: ip,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !exist {\n\t\tt.Errorf(\"entry should exist after being added: %s\", ip.String())\n\t}\n\n\tresult, err := IpsetList(\"my-test-ipset-1\")\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(result.Entries) != 1 {\n\t\tt.Fatalf(\"expected 1 entry be created, got '%d'\", len(result.Entries))\n\t}\n\tif result.Entries[0].IP.String() != \"10.99.99.99\" {\n\t\tt.Fatalf(\"expected entry to be '10.99.99.99', got '%s'\", result.Entries[0].IP.String())\n\t}\n\n\tif result.Entries[0].Comment != \"test comment\" {\n\t\t// This is only supported in the kernel module from revision 2 or 4, so comments may be ignored.\n\t\tt.Logf(\"expected comment to be 'test comment', got '%s'\", result.Entries[0].Comment)\n\t}\n\n\terr = IpsetDel(\"my-test-ipset-1\", &IPSetEntry{\n\t\tComment: \"test comment\",\n\t\tIP:      net.ParseIP(\"10.99.99.99\"),\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresult, err = IpsetList(\"my-test-ipset-1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(result.Entries) != 0 {\n\t\tt.Fatalf(\"expected 0 entries to exist, got %d\", len(result.Entries))\n\t}\n\n\terr = IpsetDestroy(\"my-test-ipset-1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = IpsetDestroy(\"my-test-ipset-2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestIpsetCreateListAddDelDestroyWithTestCases(t *testing.T) {\n\ttimeout := uint32(3)\n\tprotocalTCP := uint8(unix.IPPROTO_TCP)\n\tport := uint16(80)\n\n\ttestCases := []struct {\n\t\tdesc     string\n\t\tsetname  string\n\t\ttypename string\n\t\toptions  IpsetCreateOptions\n\t\tentry    *IPSetEntry\n\t}{\n\t\t{\n\t\t\tdesc:     \"Type-hash:ip\",\n\t\t\tsetname:  \"my-test-ipset-1\",\n\t\t\ttypename: \"hash:ip\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: true,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  false,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tIP:      net.ParseIP(\"10.99.99.99\"),\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:net\",\n\t\t\tsetname:  \"my-test-ipset-2\",\n\t\t\ttypename: \"hash:net\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: false,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  true,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tIP:      net.ParseIP(\"10.99.99.0\"),\n\t\t\t\tCIDR:    24,\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:net,net\",\n\t\t\tsetname:  \"my-test-ipset-4\",\n\t\t\ttypename: \"hash:net,net\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: false,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  true,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tIP:      net.ParseIP(\"10.99.99.0\"),\n\t\t\t\tCIDR:    24,\n\t\t\t\tIP2:     net.ParseIP(\"10.99.0.0\"),\n\t\t\t\tCIDR2:   24,\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:ip,ip\",\n\t\t\tsetname:  \"my-test-ipset-5\",\n\t\t\ttypename: \"hash:net,net\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: false,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  true,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tIP:      net.ParseIP(\"10.99.99.0\"),\n\t\t\t\tIP2:     net.ParseIP(\"10.99.0.0\"),\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:ip,port\",\n\t\t\tsetname:  \"my-test-ipset-6\",\n\t\t\ttypename: \"hash:ip,port\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: false,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  true,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment:  \"test comment\",\n\t\t\t\tIP:       net.ParseIP(\"10.99.99.1\"),\n\t\t\t\tProtocol: &protocalTCP,\n\t\t\t\tPort:     &port,\n\t\t\t\tReplace:  false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:net,port,net\",\n\t\t\tsetname:  \"my-test-ipset-7\",\n\t\t\ttypename: \"hash:net,port,net\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: false,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  true,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment:  \"test comment\",\n\t\t\t\tIP:       net.ParseIP(\"10.99.99.0\"),\n\t\t\t\tCIDR:     24,\n\t\t\t\tIP2:      net.ParseIP(\"10.99.0.0\"),\n\t\t\t\tCIDR2:    24,\n\t\t\t\tProtocol: &protocalTCP,\n\t\t\t\tPort:     &port,\n\t\t\t\tReplace:  false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:mac\",\n\t\t\tsetname:  \"my-test-ipset-8\",\n\t\t\ttypename: \"hash:mac\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: true,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  false,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tMAC:     net.HardwareAddr{0x26, 0x6f, 0x0d, 0x5b, 0xc1, 0x9d},\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:net,iface\",\n\t\t\tsetname:  \"my-test-ipset-9\",\n\t\t\ttypename: \"hash:net,iface\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: true,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  false,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tIP:      net.ParseIP(\"10.99.99.0\"),\n\t\t\t\tCIDR:    24,\n\t\t\t\tIFace:   \"eth0\",\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:ip,mark\",\n\t\t\tsetname:  \"my-test-ipset-10\",\n\t\t\ttypename: \"hash:ip,mark\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: true,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  false,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tIP:      net.ParseIP(\"10.99.99.0\"),\n\t\t\t\tMark:    &timeout,\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:net6\",\n\t\t\tsetname:  \"my-test-ipset-11\",\n\t\t\ttypename: \"hash:net\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: false,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  true,\n\t\t\t\tFamily:   unix.AF_INET6,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tIP:      net.ParseIP(\"::1\"),\n\t\t\t\tCIDR:    128,\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Type-hash:net6:net6\",\n\t\t\tsetname:  \"my-test-ipset-11\",\n\t\t\ttypename: \"hash:net,net\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: false,\n\t\t\t\tComments: true,\n\t\t\t\tSkbinfo:  true,\n\t\t\t\tFamily:   unix.AF_INET6,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tIP:      net.ParseIP(\"::1\"),\n\t\t\t\tCIDR:    128,\n\t\t\t\tIP2:     net.ParseIP(\"::2\"),\n\t\t\t\tCIDR2:   128,\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tC := range testCases {\n\t\tt.Run(tC.desc, func(t *testing.T) {\n\t\t\ttearDown := setUpNetlinkTest(t)\n\t\t\tdefer tearDown()\n\n\t\t\terr := IpsetCreate(tC.setname, tC.typename, tC.options)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tresult, err := IpsetList(tC.setname)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif result.SetName != tC.setname {\n\t\t\t\tt.Errorf(\"expected name to be '%s', but got '%s'\", tC.setname, result.SetName)\n\t\t\t}\n\n\t\t\tif result.TypeName != tC.typename {\n\t\t\t\tt.Errorf(\"expected type to be '%s', but got '%s'\", tC.typename, result.TypeName)\n\t\t\t}\n\n\t\t\tif *result.Timeout != timeout {\n\t\t\t\tt.Errorf(\"expected timeout to be %d, but got '%d'\", timeout, *result.Timeout)\n\t\t\t}\n\n\t\t\terr = IpsetAdd(tC.setname, tC.entry)\n\n\t\t\tif err != nil {\n\t\t\t\tt.Error(result.Protocol, result.Family)\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\texist, err := IpsetTest(tC.setname, tC.entry)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !exist {\n\t\t\t\tt.Errorf(\"entry should exist, but 'test' got false, case: %s\", tC.desc)\n\t\t\t}\n\n\t\t\tresult, err = IpsetList(tC.setname)\n\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(result.Entries) != 1 {\n\t\t\t\tt.Fatalf(\"expected 1 entry be created, got '%d'\", len(result.Entries))\n\t\t\t}\n\n\t\t\tif tC.entry.IP != nil {\n\t\t\t\tif !tC.entry.IP.Equal(result.Entries[0].IP) {\n\t\t\t\t\tt.Fatalf(\"expected entry to be '%v', got '%v'\", tC.entry.IP, result.Entries[0].IP)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tC.entry.CIDR > 0 {\n\t\t\t\tif result.Entries[0].CIDR != tC.entry.CIDR {\n\t\t\t\t\tt.Fatalf(\"expected cidr to be '%d', got '%d'\", tC.entry.CIDR, result.Entries[0].CIDR)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tC.entry.IP2 != nil {\n\t\t\t\tif !tC.entry.IP2.Equal(result.Entries[0].IP2) {\n\t\t\t\t\tt.Fatalf(\"expected entry.ip2 to be '%v', got '%v'\", tC.entry.IP2, result.Entries[0].IP2)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tC.entry.CIDR2 > 0 {\n\t\t\t\tif result.Entries[0].CIDR2 != tC.entry.CIDR2 {\n\t\t\t\t\tt.Fatalf(\"expected cidr2 to be '%d', got '%d'\", tC.entry.CIDR2, result.Entries[0].CIDR2)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tC.entry.Port != nil {\n\t\t\t\tif *result.Entries[0].Protocol != *tC.entry.Protocol {\n\t\t\t\t\tt.Fatalf(\"expected protocol to be '%d', got '%d'\", *tC.entry.Protocol, *result.Entries[0].Protocol)\n\t\t\t\t}\n\t\t\t\tif *result.Entries[0].Port != *tC.entry.Port {\n\t\t\t\t\tt.Fatalf(\"expected port to be '%d', got '%d'\", *tC.entry.Port, *result.Entries[0].Port)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tC.entry.MAC != nil {\n\t\t\t\tif result.Entries[0].MAC.String() != tC.entry.MAC.String() {\n\t\t\t\t\tt.Fatalf(\"expected mac to be '%v', got '%v'\", tC.entry.MAC, result.Entries[0].MAC)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tC.entry.IFace != \"\" {\n\t\t\t\tif result.Entries[0].IFace != tC.entry.IFace {\n\t\t\t\t\tt.Fatalf(\"expected iface to be '%v', got '%v'\", tC.entry.IFace, result.Entries[0].IFace)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tC.entry.Mark != nil {\n\t\t\t\tif *result.Entries[0].Mark != *tC.entry.Mark {\n\t\t\t\t\tt.Fatalf(\"expected mark to be '%v', got '%v'\", *tC.entry.Mark, *result.Entries[0].Mark)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif result.Entries[0].Comment != tC.entry.Comment {\n\t\t\t\t// This is only supported in the kernel module from revision 2 or 4, so comments may be ignored.\n\t\t\t\tt.Logf(\"expected comment to be '%s', got '%s'\", tC.entry.Comment, result.Entries[0].Comment)\n\t\t\t}\n\n\t\t\terr = IpsetDel(tC.setname, tC.entry)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\texist, err = IpsetTest(tC.setname, tC.entry)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif exist {\n\t\t\t\tt.Errorf(\"entry should be deleted, but 'test' got true, case: %s\", tC.desc)\n\t\t\t}\n\n\t\t\tresult, err = IpsetList(tC.setname)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(result.Entries) != 0 {\n\t\t\t\tt.Fatalf(\"expected 0 entries to exist, got %d\", len(result.Entries))\n\t\t\t}\n\n\t\t\terr = IpsetDestroy(tC.setname)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIpsetBitmapCreateListWithTestCases(t *testing.T) {\n\ttimeout := uint32(3)\n\n\ttestCases := []struct {\n\t\tdesc     string\n\t\tsetname  string\n\t\ttypename string\n\t\toptions  IpsetCreateOptions\n\t\tentry    *IPSetEntry\n\t}{\n\t\t{\n\t\t\tdesc:     \"Type-bitmap:port\",\n\t\t\tsetname:  \"my-test-ipset-11\",\n\t\t\ttypename: \"bitmap:port\",\n\t\t\toptions: IpsetCreateOptions{\n\t\t\t\tReplace:  true,\n\t\t\t\tTimeout:  &timeout,\n\t\t\t\tCounters: true,\n\t\t\t\tComments: false,\n\t\t\t\tSkbinfo:  false,\n\t\t\t\tPortFrom: 100,\n\t\t\t\tPortTo:   600,\n\t\t\t},\n\t\t\tentry: &IPSetEntry{\n\t\t\t\tComment: \"test comment\",\n\t\t\t\tIP:      net.ParseIP(\"10.99.99.0\"),\n\t\t\t\tCIDR:    26,\n\t\t\t\tMark:    &timeout,\n\t\t\t\tReplace: false,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tC := range testCases {\n\t\tt.Run(tC.desc, func(t *testing.T) {\n\t\t\ttearDown := setUpNetlinkTest(t)\n\t\t\tdefer tearDown()\n\n\t\t\terr := IpsetCreate(tC.setname, tC.typename, tC.options)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tresult, err := IpsetList(tC.setname)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif tC.typename == \"bitmap:port\" {\n\t\t\t\tif result.PortFrom != tC.options.PortFrom || result.PortTo != tC.options.PortTo {\n\t\t\t\t\tt.Fatalf(\"expected port range %d-%d, got %d-%d\", tC.options.PortFrom, tC.options.PortTo, result.PortFrom, result.PortTo)\n\t\t\t\t}\n\t\t\t} else if tC.typename == \"bitmap:ip\" {\n\t\t\t\tif result.IPFrom == nil || result.IPTo == nil || result.IPFrom.Equal(tC.options.IPFrom) || result.IPTo.Equal(tC.options.IPTo) {\n\t\t\t\t\tt.Fatalf(\"expected ip range %v-%v, got %v-%v\", tC.options.IPFrom, tC.options.IPTo, result.IPFrom, result.IPTo)\n\t\t\t\t}\n\t\t\t}\n\n\t\t})\n\t}\n}\n\nfunc TestIpsetSwap(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tipset1 := \"my-test-ipset-swap-1\"\n\tipset2 := \"my-test-ipset-swap-2\"\n\n\terr := IpsetCreate(ipset1, \"hash:ip\", IpsetCreateOptions{\n\t\tReplace: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\t_ = IpsetDestroy(ipset1)\n\t}()\n\n\terr = IpsetCreate(ipset2, \"hash:ip\", IpsetCreateOptions{\n\t\tReplace: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\t_ = IpsetDestroy(ipset2)\n\t}()\n\n\terr = IpsetAdd(ipset1, &IPSetEntry{\n\t\tIP: net.ParseIP(\"10.99.99.99\"),\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassertHasOneEntry := func(name string) {\n\t\tresult, err := IpsetList(name)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(result.Entries) != 1 {\n\t\t\tt.Fatalf(\"expected 1 entry be created, got '%d'\", len(result.Entries))\n\t\t}\n\t\tif result.Entries[0].IP.String() != \"10.99.99.99\" {\n\t\t\tt.Fatalf(\"expected entry to be '10.99.99.99', got '%s'\", result.Entries[0].IP.String())\n\t\t}\n\t}\n\n\tassertIsEmpty := func(name string) {\n\t\tresult, err := IpsetList(name)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(result.Entries) != 0 {\n\t\t\tt.Fatalf(\"expected 0 entry be created, got '%d'\", len(result.Entries))\n\t\t}\n\t}\n\n\tassertHasOneEntry(ipset1)\n\tassertIsEmpty(ipset2)\n\n\terr = IpsetSwap(ipset1, ipset2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassertIsEmpty(ipset1)\n\tassertHasOneEntry(ipset2)\n}\n\nfunc nextIP(ip net.IP) {\n\tfor j := len(ip) - 1; j >= 0; j-- {\n\t\tip[j]++\n\t\tif ip[j] > 0 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// TestIpsetMaxElements tests that we can create an ipset containing\n// 128k elements, which is double the default size (64k elements).\nfunc TestIpsetMaxElements(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tipsetName := \"my-test-ipset-max\"\n\tmaxElements := uint32(128 << 10)\n\n\terr := IpsetCreate(ipsetName, \"hash:ip\", IpsetCreateOptions{\n\t\tReplace:     true,\n\t\tMaxElements: maxElements,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\t_ = IpsetDestroy(ipsetName)\n\t}()\n\n\tip := net.ParseIP(\"10.0.0.0\")\n\tfor i := uint32(0); i < maxElements; i++ {\n\t\terr = IpsetAdd(ipsetName, &IPSetEntry{\n\t\t\tIP: ip,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tnextIP(ip)\n\t}\n\n\tresult, err := IpsetList(ipsetName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(result.Entries) != int(maxElements) {\n\t\tt.Fatalf(\"expected '%d' entry be created, got '%d'\", maxElements, len(result.Entries))\n\t}\n}\n"
        },
        {
          "name": "link.go",
          "type": "blob",
          "size": 29.919921875,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n)\n\n// Link represents a link device from netlink. Shared link attributes\n// like name may be retrieved using the Attrs() method. Unique data\n// can be retrieved by casting the object to the proper type.\ntype Link interface {\n\tAttrs() *LinkAttrs\n\tType() string\n}\n\ntype (\n\tNsPid int\n\tNsFd  int\n)\n\n// LinkAttrs represents data shared by most link types\ntype LinkAttrs struct {\n\tIndex          int\n\tMTU            int\n\tTxQLen         int // Transmit Queue Length\n\tName           string\n\tHardwareAddr   net.HardwareAddr\n\tFlags          net.Flags\n\tRawFlags       uint32\n\tParentIndex    int         // index of the parent link device\n\tMasterIndex    int         // must be the index of a bridge\n\tNamespace      interface{} // nil | NsPid | NsFd\n\tAlias          string\n\tAltNames       []string\n\tStatistics     *LinkStatistics\n\tPromisc        int\n\tAllmulti       int\n\tMulti          int\n\tXdp            *LinkXdp\n\tEncapType      string\n\tProtinfo       *Protinfo\n\tOperState      LinkOperState\n\tPhysSwitchID   int\n\tNetNsID        int\n\tNumTxQueues    int\n\tNumRxQueues    int\n\tTSOMaxSegs     uint32\n\tTSOMaxSize     uint32\n\tGSOMaxSegs     uint32\n\tGSOMaxSize     uint32\n\tGROMaxSize     uint32\n\tGSOIPv4MaxSize uint32\n\tGROIPv4MaxSize uint32\n\tVfs            []VfInfo // virtual functions available on link\n\tGroup          uint32\n\tPermHWAddr     net.HardwareAddr\n\tSlave          LinkSlave\n}\n\n// LinkSlave represents a slave device.\ntype LinkSlave interface {\n\tSlaveType() string\n}\n\n// VfInfo represents configuration of virtual function\ntype VfInfo struct {\n\tID        int\n\tMac       net.HardwareAddr\n\tVlan      int\n\tQos       int\n\tVlanProto int\n\tTxRate    int // IFLA_VF_TX_RATE  Max TxRate\n\tSpoofchk  bool\n\tLinkState uint32\n\tMaxTxRate uint32 // IFLA_VF_RATE Max TxRate\n\tMinTxRate uint32 // IFLA_VF_RATE Min TxRate\n\tRxPackets uint64\n\tTxPackets uint64\n\tRxBytes   uint64\n\tTxBytes   uint64\n\tMulticast uint64\n\tBroadcast uint64\n\tRxDropped uint64\n\tTxDropped uint64\n\n\tRssQuery uint32\n\tTrust    uint32\n}\n\n// LinkOperState represents the values of the IFLA_OPERSTATE link\n// attribute, which contains the RFC2863 state of the interface.\ntype LinkOperState uint8\n\nconst (\n\tOperUnknown        = iota // Status can't be determined.\n\tOperNotPresent            // Some component is missing.\n\tOperDown                  // Down.\n\tOperLowerLayerDown        // Down due to state of lower layer.\n\tOperTesting               // In some test mode.\n\tOperDormant               // Not up but pending an external event.\n\tOperUp                    // Up, ready to send packets.\n)\n\nfunc (s LinkOperState) String() string {\n\tswitch s {\n\tcase OperNotPresent:\n\t\treturn \"not-present\"\n\tcase OperDown:\n\t\treturn \"down\"\n\tcase OperLowerLayerDown:\n\t\treturn \"lower-layer-down\"\n\tcase OperTesting:\n\t\treturn \"testing\"\n\tcase OperDormant:\n\t\treturn \"dormant\"\n\tcase OperUp:\n\t\treturn \"up\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\n// NewLinkAttrs returns LinkAttrs structure filled with default values\nfunc NewLinkAttrs() LinkAttrs {\n\treturn LinkAttrs{\n\t\tNetNsID: -1,\n\t\tTxQLen:  -1,\n\t}\n}\n\ntype LinkStatistics LinkStatistics64\n\n/*\nRef: struct rtnl_link_stats {...}\n*/\ntype LinkStatistics32 struct {\n\tRxPackets         uint32\n\tTxPackets         uint32\n\tRxBytes           uint32\n\tTxBytes           uint32\n\tRxErrors          uint32\n\tTxErrors          uint32\n\tRxDropped         uint32\n\tTxDropped         uint32\n\tMulticast         uint32\n\tCollisions        uint32\n\tRxLengthErrors    uint32\n\tRxOverErrors      uint32\n\tRxCrcErrors       uint32\n\tRxFrameErrors     uint32\n\tRxFifoErrors      uint32\n\tRxMissedErrors    uint32\n\tTxAbortedErrors   uint32\n\tTxCarrierErrors   uint32\n\tTxFifoErrors      uint32\n\tTxHeartbeatErrors uint32\n\tTxWindowErrors    uint32\n\tRxCompressed      uint32\n\tTxCompressed      uint32\n}\n\nfunc (s32 LinkStatistics32) to64() *LinkStatistics64 {\n\treturn &LinkStatistics64{\n\t\tRxPackets:         uint64(s32.RxPackets),\n\t\tTxPackets:         uint64(s32.TxPackets),\n\t\tRxBytes:           uint64(s32.RxBytes),\n\t\tTxBytes:           uint64(s32.TxBytes),\n\t\tRxErrors:          uint64(s32.RxErrors),\n\t\tTxErrors:          uint64(s32.TxErrors),\n\t\tRxDropped:         uint64(s32.RxDropped),\n\t\tTxDropped:         uint64(s32.TxDropped),\n\t\tMulticast:         uint64(s32.Multicast),\n\t\tCollisions:        uint64(s32.Collisions),\n\t\tRxLengthErrors:    uint64(s32.RxLengthErrors),\n\t\tRxOverErrors:      uint64(s32.RxOverErrors),\n\t\tRxCrcErrors:       uint64(s32.RxCrcErrors),\n\t\tRxFrameErrors:     uint64(s32.RxFrameErrors),\n\t\tRxFifoErrors:      uint64(s32.RxFifoErrors),\n\t\tRxMissedErrors:    uint64(s32.RxMissedErrors),\n\t\tTxAbortedErrors:   uint64(s32.TxAbortedErrors),\n\t\tTxCarrierErrors:   uint64(s32.TxCarrierErrors),\n\t\tTxFifoErrors:      uint64(s32.TxFifoErrors),\n\t\tTxHeartbeatErrors: uint64(s32.TxHeartbeatErrors),\n\t\tTxWindowErrors:    uint64(s32.TxWindowErrors),\n\t\tRxCompressed:      uint64(s32.RxCompressed),\n\t\tTxCompressed:      uint64(s32.TxCompressed),\n\t}\n}\n\n/*\nRef: struct rtnl_link_stats64 {...}\n*/\ntype LinkStatistics64 struct {\n\tRxPackets         uint64\n\tTxPackets         uint64\n\tRxBytes           uint64\n\tTxBytes           uint64\n\tRxErrors          uint64\n\tTxErrors          uint64\n\tRxDropped         uint64\n\tTxDropped         uint64\n\tMulticast         uint64\n\tCollisions        uint64\n\tRxLengthErrors    uint64\n\tRxOverErrors      uint64\n\tRxCrcErrors       uint64\n\tRxFrameErrors     uint64\n\tRxFifoErrors      uint64\n\tRxMissedErrors    uint64\n\tTxAbortedErrors   uint64\n\tTxCarrierErrors   uint64\n\tTxFifoErrors      uint64\n\tTxHeartbeatErrors uint64\n\tTxWindowErrors    uint64\n\tRxCompressed      uint64\n\tTxCompressed      uint64\n}\n\ntype LinkXdp struct {\n\tFd         int\n\tAttached   bool\n\tAttachMode uint32\n\tFlags      uint32\n\tProgId     uint32\n}\n\n// Device links cannot be created via netlink. These links\n// are links created by udev like 'lo' and 'etho0'\ntype Device struct {\n\tLinkAttrs\n}\n\nfunc (device *Device) Attrs() *LinkAttrs {\n\treturn &device.LinkAttrs\n}\n\nfunc (device *Device) Type() string {\n\treturn \"device\"\n}\n\n// Dummy links are dummy ethernet devices\ntype Dummy struct {\n\tLinkAttrs\n}\n\nfunc (dummy *Dummy) Attrs() *LinkAttrs {\n\treturn &dummy.LinkAttrs\n}\n\nfunc (dummy *Dummy) Type() string {\n\treturn \"dummy\"\n}\n\n// Ifb links are advanced dummy devices for packet filtering\ntype Ifb struct {\n\tLinkAttrs\n}\n\nfunc (ifb *Ifb) Attrs() *LinkAttrs {\n\treturn &ifb.LinkAttrs\n}\n\nfunc (ifb *Ifb) Type() string {\n\treturn \"ifb\"\n}\n\n// Bridge links are simple linux bridges\ntype Bridge struct {\n\tLinkAttrs\n\tMulticastSnooping *bool\n\tAgeingTime        *uint32\n\tHelloTime         *uint32\n\tVlanFiltering     *bool\n\tVlanDefaultPVID   *uint16\n\tGroupFwdMask      *uint16\n}\n\nfunc (bridge *Bridge) Attrs() *LinkAttrs {\n\treturn &bridge.LinkAttrs\n}\n\nfunc (bridge *Bridge) Type() string {\n\treturn \"bridge\"\n}\n\n// Vlan links have ParentIndex set in their Attrs()\ntype Vlan struct {\n\tLinkAttrs\n\tVlanId       int\n\tVlanProtocol VlanProtocol\n}\n\nfunc (vlan *Vlan) Attrs() *LinkAttrs {\n\treturn &vlan.LinkAttrs\n}\n\nfunc (vlan *Vlan) Type() string {\n\treturn \"vlan\"\n}\n\ntype MacvlanMode uint16\n\nconst (\n\tMACVLAN_MODE_DEFAULT MacvlanMode = iota\n\tMACVLAN_MODE_PRIVATE\n\tMACVLAN_MODE_VEPA\n\tMACVLAN_MODE_BRIDGE\n\tMACVLAN_MODE_PASSTHRU\n\tMACVLAN_MODE_SOURCE\n)\n\n// Macvlan links have ParentIndex set in their Attrs()\ntype Macvlan struct {\n\tLinkAttrs\n\tMode MacvlanMode\n\n\t// MACAddrs is only populated for Macvlan SOURCE links\n\tMACAddrs []net.HardwareAddr\n\n\tBCQueueLen     uint32\n\tUsedBCQueueLen uint32\n}\n\nfunc (macvlan *Macvlan) Attrs() *LinkAttrs {\n\treturn &macvlan.LinkAttrs\n}\n\nfunc (macvlan *Macvlan) Type() string {\n\treturn \"macvlan\"\n}\n\n// Macvtap - macvtap is a virtual interfaces based on macvlan\ntype Macvtap struct {\n\tMacvlan\n}\n\nfunc (macvtap Macvtap) Type() string {\n\treturn \"macvtap\"\n}\n\ntype TuntapMode uint16\ntype TuntapFlag uint16\n\n// Tuntap links created via /dev/tun/tap, but can be destroyed via netlink\ntype Tuntap struct {\n\tLinkAttrs\n\tMode       TuntapMode\n\tFlags      TuntapFlag\n\tNonPersist bool\n\tQueues     int\n\tFds        []*os.File\n\tOwner      uint32\n\tGroup      uint32\n}\n\nfunc (tuntap *Tuntap) Attrs() *LinkAttrs {\n\treturn &tuntap.LinkAttrs\n}\n\nfunc (tuntap *Tuntap) Type() string {\n\treturn \"tuntap\"\n}\n\ntype NetkitMode uint32\n\nconst (\n\tNETKIT_MODE_L2 NetkitMode = iota\n\tNETKIT_MODE_L3\n)\n\ntype NetkitPolicy int\n\nconst (\n\tNETKIT_POLICY_FORWARD   NetkitPolicy = 0\n\tNETKIT_POLICY_BLACKHOLE NetkitPolicy = 2\n)\n\ntype NetkitScrub int\n\nconst (\n\tNETKIT_SCRUB_NONE    NetkitScrub = 0\n\tNETKIT_SCRUB_DEFAULT NetkitScrub = 1\n)\n\nfunc (n *Netkit) IsPrimary() bool {\n\treturn n.isPrimary\n}\n\n// SetPeerAttrs will not take effect if trying to modify an existing netkit device\nfunc (n *Netkit) SetPeerAttrs(Attrs *LinkAttrs) {\n\tn.peerLinkAttrs = *Attrs\n}\n\ntype Netkit struct {\n\tLinkAttrs\n\tMode          NetkitMode\n\tPolicy        NetkitPolicy\n\tPeerPolicy    NetkitPolicy\n\tScrub         NetkitScrub\n\tPeerScrub     NetkitScrub\n\tsupportsScrub bool\n\tisPrimary     bool\n\tpeerLinkAttrs LinkAttrs\n}\n\nfunc (n *Netkit) Attrs() *LinkAttrs {\n\treturn &n.LinkAttrs\n}\n\nfunc (n *Netkit) Type() string {\n\treturn \"netkit\"\n}\n\nfunc (n *Netkit) SupportsScrub() bool {\n\treturn n.supportsScrub\n}\n\n// Veth devices must specify PeerName on create\ntype Veth struct {\n\tLinkAttrs\n\tPeerName         string // veth on create only\n\tPeerHardwareAddr net.HardwareAddr\n\tPeerNamespace    interface{}\n}\n\nfunc (veth *Veth) Attrs() *LinkAttrs {\n\treturn &veth.LinkAttrs\n}\n\nfunc (veth *Veth) Type() string {\n\treturn \"veth\"\n}\n\n// Wireguard represent links of type \"wireguard\", see https://www.wireguard.com/\ntype Wireguard struct {\n\tLinkAttrs\n}\n\nfunc (wg *Wireguard) Attrs() *LinkAttrs {\n\treturn &wg.LinkAttrs\n}\n\nfunc (wg *Wireguard) Type() string {\n\treturn \"wireguard\"\n}\n\n// GenericLink links represent types that are not currently understood\n// by this netlink library.\ntype GenericLink struct {\n\tLinkAttrs\n\tLinkType string\n}\n\nfunc (generic *GenericLink) Attrs() *LinkAttrs {\n\treturn &generic.LinkAttrs\n}\n\nfunc (generic *GenericLink) Type() string {\n\treturn generic.LinkType\n}\n\ntype Vxlan struct {\n\tLinkAttrs\n\tVxlanId        int\n\tVtepDevIndex   int\n\tSrcAddr        net.IP\n\tGroup          net.IP\n\tTTL            int\n\tTOS            int\n\tLearning       bool\n\tProxy          bool\n\tRSC            bool\n\tL2miss         bool\n\tL3miss         bool\n\tUDPCSum        bool\n\tUDP6ZeroCSumTx bool\n\tUDP6ZeroCSumRx bool\n\tNoAge          bool\n\tGBP            bool\n\tFlowBased      bool\n\tAge            int\n\tLimit          int\n\tPort           int\n\tPortLow        int\n\tPortHigh       int\n}\n\nfunc (vxlan *Vxlan) Attrs() *LinkAttrs {\n\treturn &vxlan.LinkAttrs\n}\n\nfunc (vxlan *Vxlan) Type() string {\n\treturn \"vxlan\"\n}\n\ntype IPVlanMode uint16\n\nconst (\n\tIPVLAN_MODE_L2 IPVlanMode = iota\n\tIPVLAN_MODE_L3\n\tIPVLAN_MODE_L3S\n\tIPVLAN_MODE_MAX\n)\n\ntype IPVlanFlag uint16\n\nconst (\n\tIPVLAN_FLAG_BRIDGE IPVlanFlag = iota\n\tIPVLAN_FLAG_PRIVATE\n\tIPVLAN_FLAG_VEPA\n)\n\ntype IPVlan struct {\n\tLinkAttrs\n\tMode IPVlanMode\n\tFlag IPVlanFlag\n}\n\nfunc (ipvlan *IPVlan) Attrs() *LinkAttrs {\n\treturn &ipvlan.LinkAttrs\n}\n\nfunc (ipvlan *IPVlan) Type() string {\n\treturn \"ipvlan\"\n}\n\n// IPVtap - IPVtap is a virtual interfaces based on ipvlan\ntype IPVtap struct {\n\tIPVlan\n}\n\nfunc (ipvtap *IPVtap) Attrs() *LinkAttrs {\n\treturn &ipvtap.LinkAttrs\n}\n\nfunc (ipvtap IPVtap) Type() string {\n\treturn \"ipvtap\"\n}\n\n// VlanProtocol type\ntype VlanProtocol int\n\nfunc (p VlanProtocol) String() string {\n\ts, ok := VlanProtocolToString[p]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"VlanProtocol(%d)\", p)\n\t}\n\treturn s\n}\n\n// StringToVlanProtocol returns vlan protocol, or unknown is the s is invalid.\nfunc StringToVlanProtocol(s string) VlanProtocol {\n\tmode, ok := StringToVlanProtocolMap[s]\n\tif !ok {\n\t\treturn VLAN_PROTOCOL_UNKNOWN\n\t}\n\treturn mode\n}\n\n// VlanProtocol possible values\nconst (\n\tVLAN_PROTOCOL_UNKNOWN VlanProtocol = 0\n\tVLAN_PROTOCOL_8021Q   VlanProtocol = 0x8100\n\tVLAN_PROTOCOL_8021AD  VlanProtocol = 0x88A8\n)\n\nvar VlanProtocolToString = map[VlanProtocol]string{\n\tVLAN_PROTOCOL_8021Q:  \"802.1q\",\n\tVLAN_PROTOCOL_8021AD: \"802.1ad\",\n}\n\nvar StringToVlanProtocolMap = map[string]VlanProtocol{\n\t\"802.1q\":  VLAN_PROTOCOL_8021Q,\n\t\"802.1ad\": VLAN_PROTOCOL_8021AD,\n}\n\n// BondMode type\ntype BondMode int\n\nfunc (b BondMode) String() string {\n\ts, ok := bondModeToString[b]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"BondMode(%d)\", b)\n\t}\n\treturn s\n}\n\n// StringToBondMode returns bond mode, or unknown is the s is invalid.\nfunc StringToBondMode(s string) BondMode {\n\tmode, ok := StringToBondModeMap[s]\n\tif !ok {\n\t\treturn BOND_MODE_UNKNOWN\n\t}\n\treturn mode\n}\n\n// Possible BondMode\nconst (\n\tBOND_MODE_BALANCE_RR BondMode = iota\n\tBOND_MODE_ACTIVE_BACKUP\n\tBOND_MODE_BALANCE_XOR\n\tBOND_MODE_BROADCAST\n\tBOND_MODE_802_3AD\n\tBOND_MODE_BALANCE_TLB\n\tBOND_MODE_BALANCE_ALB\n\tBOND_MODE_UNKNOWN\n)\n\nvar bondModeToString = map[BondMode]string{\n\tBOND_MODE_BALANCE_RR:    \"balance-rr\",\n\tBOND_MODE_ACTIVE_BACKUP: \"active-backup\",\n\tBOND_MODE_BALANCE_XOR:   \"balance-xor\",\n\tBOND_MODE_BROADCAST:     \"broadcast\",\n\tBOND_MODE_802_3AD:       \"802.3ad\",\n\tBOND_MODE_BALANCE_TLB:   \"balance-tlb\",\n\tBOND_MODE_BALANCE_ALB:   \"balance-alb\",\n}\nvar StringToBondModeMap = map[string]BondMode{\n\t\"balance-rr\":    BOND_MODE_BALANCE_RR,\n\t\"active-backup\": BOND_MODE_ACTIVE_BACKUP,\n\t\"balance-xor\":   BOND_MODE_BALANCE_XOR,\n\t\"broadcast\":     BOND_MODE_BROADCAST,\n\t\"802.3ad\":       BOND_MODE_802_3AD,\n\t\"balance-tlb\":   BOND_MODE_BALANCE_TLB,\n\t\"balance-alb\":   BOND_MODE_BALANCE_ALB,\n}\n\n// BondArpValidate type\ntype BondArpValidate int\n\n// Possible BondArpValidate value\nconst (\n\tBOND_ARP_VALIDATE_NONE BondArpValidate = iota\n\tBOND_ARP_VALIDATE_ACTIVE\n\tBOND_ARP_VALIDATE_BACKUP\n\tBOND_ARP_VALIDATE_ALL\n)\n\nvar bondArpValidateToString = map[BondArpValidate]string{\n\tBOND_ARP_VALIDATE_NONE:   \"none\",\n\tBOND_ARP_VALIDATE_ACTIVE: \"active\",\n\tBOND_ARP_VALIDATE_BACKUP: \"backup\",\n\tBOND_ARP_VALIDATE_ALL:    \"none\",\n}\nvar StringToBondArpValidateMap = map[string]BondArpValidate{\n\t\"none\":   BOND_ARP_VALIDATE_NONE,\n\t\"active\": BOND_ARP_VALIDATE_ACTIVE,\n\t\"backup\": BOND_ARP_VALIDATE_BACKUP,\n\t\"all\":    BOND_ARP_VALIDATE_ALL,\n}\n\nfunc (b BondArpValidate) String() string {\n\ts, ok := bondArpValidateToString[b]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"BondArpValidate(%d)\", b)\n\t}\n\treturn s\n}\n\n// BondPrimaryReselect type\ntype BondPrimaryReselect int\n\n// Possible BondPrimaryReselect value\nconst (\n\tBOND_PRIMARY_RESELECT_ALWAYS BondPrimaryReselect = iota\n\tBOND_PRIMARY_RESELECT_BETTER\n\tBOND_PRIMARY_RESELECT_FAILURE\n)\n\nvar bondPrimaryReselectToString = map[BondPrimaryReselect]string{\n\tBOND_PRIMARY_RESELECT_ALWAYS:  \"always\",\n\tBOND_PRIMARY_RESELECT_BETTER:  \"better\",\n\tBOND_PRIMARY_RESELECT_FAILURE: \"failure\",\n}\nvar StringToBondPrimaryReselectMap = map[string]BondPrimaryReselect{\n\t\"always\":  BOND_PRIMARY_RESELECT_ALWAYS,\n\t\"better\":  BOND_PRIMARY_RESELECT_BETTER,\n\t\"failure\": BOND_PRIMARY_RESELECT_FAILURE,\n}\n\nfunc (b BondPrimaryReselect) String() string {\n\ts, ok := bondPrimaryReselectToString[b]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"BondPrimaryReselect(%d)\", b)\n\t}\n\treturn s\n}\n\n// BondArpAllTargets type\ntype BondArpAllTargets int\n\n// Possible BondArpAllTargets value\nconst (\n\tBOND_ARP_ALL_TARGETS_ANY BondArpAllTargets = iota\n\tBOND_ARP_ALL_TARGETS_ALL\n)\n\nvar bondArpAllTargetsToString = map[BondArpAllTargets]string{\n\tBOND_ARP_ALL_TARGETS_ANY: \"any\",\n\tBOND_ARP_ALL_TARGETS_ALL: \"all\",\n}\nvar StringToBondArpAllTargetsMap = map[string]BondArpAllTargets{\n\t\"any\": BOND_ARP_ALL_TARGETS_ANY,\n\t\"all\": BOND_ARP_ALL_TARGETS_ALL,\n}\n\nfunc (b BondArpAllTargets) String() string {\n\ts, ok := bondArpAllTargetsToString[b]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"BondArpAllTargets(%d)\", b)\n\t}\n\treturn s\n}\n\n// BondFailOverMac type\ntype BondFailOverMac int\n\n// Possible BondFailOverMac value\nconst (\n\tBOND_FAIL_OVER_MAC_NONE BondFailOverMac = iota\n\tBOND_FAIL_OVER_MAC_ACTIVE\n\tBOND_FAIL_OVER_MAC_FOLLOW\n)\n\nvar bondFailOverMacToString = map[BondFailOverMac]string{\n\tBOND_FAIL_OVER_MAC_NONE:   \"none\",\n\tBOND_FAIL_OVER_MAC_ACTIVE: \"active\",\n\tBOND_FAIL_OVER_MAC_FOLLOW: \"follow\",\n}\nvar StringToBondFailOverMacMap = map[string]BondFailOverMac{\n\t\"none\":   BOND_FAIL_OVER_MAC_NONE,\n\t\"active\": BOND_FAIL_OVER_MAC_ACTIVE,\n\t\"follow\": BOND_FAIL_OVER_MAC_FOLLOW,\n}\n\nfunc (b BondFailOverMac) String() string {\n\ts, ok := bondFailOverMacToString[b]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"BondFailOverMac(%d)\", b)\n\t}\n\treturn s\n}\n\n// BondXmitHashPolicy type\ntype BondXmitHashPolicy int\n\nfunc (b BondXmitHashPolicy) String() string {\n\ts, ok := bondXmitHashPolicyToString[b]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"XmitHashPolicy(%d)\", b)\n\t}\n\treturn s\n}\n\n// StringToBondXmitHashPolicy returns bond lacp arte, or unknown is the s is invalid.\nfunc StringToBondXmitHashPolicy(s string) BondXmitHashPolicy {\n\tlacp, ok := StringToBondXmitHashPolicyMap[s]\n\tif !ok {\n\t\treturn BOND_XMIT_HASH_POLICY_UNKNOWN\n\t}\n\treturn lacp\n}\n\n// Possible BondXmitHashPolicy value\nconst (\n\tBOND_XMIT_HASH_POLICY_LAYER2 BondXmitHashPolicy = iota\n\tBOND_XMIT_HASH_POLICY_LAYER3_4\n\tBOND_XMIT_HASH_POLICY_LAYER2_3\n\tBOND_XMIT_HASH_POLICY_ENCAP2_3\n\tBOND_XMIT_HASH_POLICY_ENCAP3_4\n\tBOND_XMIT_HASH_POLICY_VLAN_SRCMAC\n\tBOND_XMIT_HASH_POLICY_UNKNOWN\n)\n\nvar bondXmitHashPolicyToString = map[BondXmitHashPolicy]string{\n\tBOND_XMIT_HASH_POLICY_LAYER2:      \"layer2\",\n\tBOND_XMIT_HASH_POLICY_LAYER3_4:    \"layer3+4\",\n\tBOND_XMIT_HASH_POLICY_LAYER2_3:    \"layer2+3\",\n\tBOND_XMIT_HASH_POLICY_ENCAP2_3:    \"encap2+3\",\n\tBOND_XMIT_HASH_POLICY_ENCAP3_4:    \"encap3+4\",\n\tBOND_XMIT_HASH_POLICY_VLAN_SRCMAC: \"vlan+srcmac\",\n}\nvar StringToBondXmitHashPolicyMap = map[string]BondXmitHashPolicy{\n\t\"layer2\":      BOND_XMIT_HASH_POLICY_LAYER2,\n\t\"layer3+4\":    BOND_XMIT_HASH_POLICY_LAYER3_4,\n\t\"layer2+3\":    BOND_XMIT_HASH_POLICY_LAYER2_3,\n\t\"encap2+3\":    BOND_XMIT_HASH_POLICY_ENCAP2_3,\n\t\"encap3+4\":    BOND_XMIT_HASH_POLICY_ENCAP3_4,\n\t\"vlan+srcmac\": BOND_XMIT_HASH_POLICY_VLAN_SRCMAC,\n}\n\n// BondLacpRate type\ntype BondLacpRate int\n\nfunc (b BondLacpRate) String() string {\n\ts, ok := bondLacpRateToString[b]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"LacpRate(%d)\", b)\n\t}\n\treturn s\n}\n\n// StringToBondLacpRate returns bond lacp arte, or unknown is the s is invalid.\nfunc StringToBondLacpRate(s string) BondLacpRate {\n\tlacp, ok := StringToBondLacpRateMap[s]\n\tif !ok {\n\t\treturn BOND_LACP_RATE_UNKNOWN\n\t}\n\treturn lacp\n}\n\n// Possible BondLacpRate value\nconst (\n\tBOND_LACP_RATE_SLOW BondLacpRate = iota\n\tBOND_LACP_RATE_FAST\n\tBOND_LACP_RATE_UNKNOWN\n)\n\nvar bondLacpRateToString = map[BondLacpRate]string{\n\tBOND_LACP_RATE_SLOW: \"slow\",\n\tBOND_LACP_RATE_FAST: \"fast\",\n}\nvar StringToBondLacpRateMap = map[string]BondLacpRate{\n\t\"slow\": BOND_LACP_RATE_SLOW,\n\t\"fast\": BOND_LACP_RATE_FAST,\n}\n\n// BondAdSelect type\ntype BondAdSelect int\n\n// Possible BondAdSelect value\nconst (\n\tBOND_AD_SELECT_STABLE BondAdSelect = iota\n\tBOND_AD_SELECT_BANDWIDTH\n\tBOND_AD_SELECT_COUNT\n)\n\nvar bondAdSelectToString = map[BondAdSelect]string{\n\tBOND_AD_SELECT_STABLE:    \"stable\",\n\tBOND_AD_SELECT_BANDWIDTH: \"bandwidth\",\n\tBOND_AD_SELECT_COUNT:     \"count\",\n}\nvar StringToBondAdSelectMap = map[string]BondAdSelect{\n\t\"stable\":    BOND_AD_SELECT_STABLE,\n\t\"bandwidth\": BOND_AD_SELECT_BANDWIDTH,\n\t\"count\":     BOND_AD_SELECT_COUNT,\n}\n\nfunc (b BondAdSelect) String() string {\n\ts, ok := bondAdSelectToString[b]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"BondAdSelect(%d)\", b)\n\t}\n\treturn s\n}\n\n// BondAdInfo represents ad info for bond\ntype BondAdInfo struct {\n\tAggregatorId int\n\tNumPorts     int\n\tActorKey     int\n\tPartnerKey   int\n\tPartnerMac   net.HardwareAddr\n}\n\n// Bond representation\ntype Bond struct {\n\tLinkAttrs\n\tMode            BondMode\n\tActiveSlave     int\n\tMiimon          int\n\tUpDelay         int\n\tDownDelay       int\n\tUseCarrier      int\n\tArpInterval     int\n\tArpIpTargets    []net.IP\n\tArpValidate     BondArpValidate\n\tArpAllTargets   BondArpAllTargets\n\tPrimary         int\n\tPrimaryReselect BondPrimaryReselect\n\tFailOverMac     BondFailOverMac\n\tXmitHashPolicy  BondXmitHashPolicy\n\tResendIgmp      int\n\tNumPeerNotif    int\n\tAllSlavesActive int\n\tMinLinks        int\n\tLpInterval      int\n\tPacketsPerSlave int\n\tLacpRate        BondLacpRate\n\tAdSelect        BondAdSelect\n\t// looking at iproute tool AdInfo can only be retrived. It can't be set.\n\tAdInfo         *BondAdInfo\n\tAdActorSysPrio int\n\tAdUserPortKey  int\n\tAdActorSystem  net.HardwareAddr\n\tTlbDynamicLb   int\n}\n\nfunc NewLinkBond(atr LinkAttrs) *Bond {\n\treturn &Bond{\n\t\tLinkAttrs:       atr,\n\t\tMode:            -1,\n\t\tActiveSlave:     -1,\n\t\tMiimon:          -1,\n\t\tUpDelay:         -1,\n\t\tDownDelay:       -1,\n\t\tUseCarrier:      -1,\n\t\tArpInterval:     -1,\n\t\tArpIpTargets:    nil,\n\t\tArpValidate:     -1,\n\t\tArpAllTargets:   -1,\n\t\tPrimary:         -1,\n\t\tPrimaryReselect: -1,\n\t\tFailOverMac:     -1,\n\t\tXmitHashPolicy:  -1,\n\t\tResendIgmp:      -1,\n\t\tNumPeerNotif:    -1,\n\t\tAllSlavesActive: -1,\n\t\tMinLinks:        -1,\n\t\tLpInterval:      -1,\n\t\tPacketsPerSlave: -1,\n\t\tLacpRate:        -1,\n\t\tAdSelect:        -1,\n\t\tAdActorSysPrio:  -1,\n\t\tAdUserPortKey:   -1,\n\t\tAdActorSystem:   nil,\n\t\tTlbDynamicLb:    -1,\n\t}\n}\n\n// Flag mask for bond options. Bond.Flagmask must be set to on for option to work.\nconst (\n\tBOND_MODE_MASK uint64 = 1 << (1 + iota)\n\tBOND_ACTIVE_SLAVE_MASK\n\tBOND_MIIMON_MASK\n\tBOND_UPDELAY_MASK\n\tBOND_DOWNDELAY_MASK\n\tBOND_USE_CARRIER_MASK\n\tBOND_ARP_INTERVAL_MASK\n\tBOND_ARP_VALIDATE_MASK\n\tBOND_ARP_ALL_TARGETS_MASK\n\tBOND_PRIMARY_MASK\n\tBOND_PRIMARY_RESELECT_MASK\n\tBOND_FAIL_OVER_MAC_MASK\n\tBOND_XMIT_HASH_POLICY_MASK\n\tBOND_RESEND_IGMP_MASK\n\tBOND_NUM_PEER_NOTIF_MASK\n\tBOND_ALL_SLAVES_ACTIVE_MASK\n\tBOND_MIN_LINKS_MASK\n\tBOND_LP_INTERVAL_MASK\n\tBOND_PACKETS_PER_SLAVE_MASK\n\tBOND_LACP_RATE_MASK\n\tBOND_AD_SELECT_MASK\n)\n\n// Attrs implementation.\nfunc (bond *Bond) Attrs() *LinkAttrs {\n\treturn &bond.LinkAttrs\n}\n\n// Type implementation fro Vxlan.\nfunc (bond *Bond) Type() string {\n\treturn \"bond\"\n}\n\n// BondSlaveState represents the values of the IFLA_BOND_SLAVE_STATE bond slave\n// attribute, which contains the state of the bond slave.\ntype BondSlaveState uint8\n\nconst (\n\t//BondStateActive Link is active.\n\tBondStateActive BondSlaveState = iota\n\t//BondStateBackup Link is backup.\n\tBondStateBackup\n)\n\nfunc (s BondSlaveState) String() string {\n\tswitch s {\n\tcase BondStateActive:\n\t\treturn \"ACTIVE\"\n\tcase BondStateBackup:\n\t\treturn \"BACKUP\"\n\tdefault:\n\t\treturn strconv.Itoa(int(s))\n\t}\n}\n\n// BondSlaveMiiStatus represents the values of the IFLA_BOND_SLAVE_MII_STATUS bond slave\n// attribute, which contains the status of MII link monitoring\ntype BondSlaveMiiStatus uint8\n\nconst (\n\t//BondLinkUp link is up and running.\n\tBondLinkUp BondSlaveMiiStatus = iota\n\t//BondLinkFail link has just gone down.\n\tBondLinkFail\n\t//BondLinkDown link has been down for too long time.\n\tBondLinkDown\n\t//BondLinkBack link is going back.\n\tBondLinkBack\n)\n\nfunc (s BondSlaveMiiStatus) String() string {\n\tswitch s {\n\tcase BondLinkUp:\n\t\treturn \"UP\"\n\tcase BondLinkFail:\n\t\treturn \"GOING_DOWN\"\n\tcase BondLinkDown:\n\t\treturn \"DOWN\"\n\tcase BondLinkBack:\n\t\treturn \"GOING_BACK\"\n\tdefault:\n\t\treturn strconv.Itoa(int(s))\n\t}\n}\n\ntype BondSlave struct {\n\tState                  BondSlaveState\n\tMiiStatus              BondSlaveMiiStatus\n\tLinkFailureCount       uint32\n\tPermHardwareAddr       net.HardwareAddr\n\tQueueId                uint16\n\tAggregatorId           uint16\n\tAdActorOperPortState   uint8\n\tAdPartnerOperPortState uint16\n}\n\nfunc (b *BondSlave) SlaveType() string {\n\treturn \"bond\"\n}\n\ntype VrfSlave struct {\n\tTable uint32\n}\n\nfunc (v *VrfSlave) SlaveType() string {\n\treturn \"vrf\"\n}\n\n// Geneve devices must specify RemoteIP and ID (VNI) on create\n// https://github.com/torvalds/linux/blob/47ec5303d73ea344e84f46660fff693c57641386/drivers/net/geneve.c#L1209-L1223\ntype Geneve struct {\n\tLinkAttrs\n\tID                uint32 // vni\n\tRemote            net.IP\n\tTtl               uint8\n\tTos               uint8\n\tDport             uint16\n\tUdpCsum           uint8\n\tUdpZeroCsum6Tx    uint8\n\tUdpZeroCsum6Rx    uint8\n\tLink              uint32\n\tFlowBased         bool\n\tInnerProtoInherit bool\n\tDf                GeneveDf\n}\n\nfunc (geneve *Geneve) Attrs() *LinkAttrs {\n\treturn &geneve.LinkAttrs\n}\n\nfunc (geneve *Geneve) Type() string {\n\treturn \"geneve\"\n}\n\ntype GeneveDf uint8\n\nconst (\n\tGENEVE_DF_UNSET GeneveDf = iota\n\tGENEVE_DF_SET\n\tGENEVE_DF_INHERIT\n\tGENEVE_DF_MAX\n)\n\n// Gretap devices must specify LocalIP and RemoteIP on create\ntype Gretap struct {\n\tLinkAttrs\n\tIKey       uint32\n\tOKey       uint32\n\tEncapSport uint16\n\tEncapDport uint16\n\tLocal      net.IP\n\tRemote     net.IP\n\tIFlags     uint16\n\tOFlags     uint16\n\tPMtuDisc   uint8\n\tTtl        uint8\n\tTos        uint8\n\tEncapType  uint16\n\tEncapFlags uint16\n\tLink       uint32\n\tFlowBased  bool\n}\n\nfunc (gretap *Gretap) Attrs() *LinkAttrs {\n\treturn &gretap.LinkAttrs\n}\n\nfunc (gretap *Gretap) Type() string {\n\tif gretap.Local.To4() == nil {\n\t\treturn \"ip6gretap\"\n\t}\n\treturn \"gretap\"\n}\n\ntype Iptun struct {\n\tLinkAttrs\n\tTtl        uint8\n\tTos        uint8\n\tPMtuDisc   uint8\n\tLink       uint32\n\tLocal      net.IP\n\tRemote     net.IP\n\tEncapSport uint16\n\tEncapDport uint16\n\tEncapType  uint16\n\tEncapFlags uint16\n\tFlowBased  bool\n\tProto      uint8\n}\n\nfunc (iptun *Iptun) Attrs() *LinkAttrs {\n\treturn &iptun.LinkAttrs\n}\n\nfunc (iptun *Iptun) Type() string {\n\treturn \"ipip\"\n}\n\ntype Ip6tnl struct {\n\tLinkAttrs\n\tLink       uint32\n\tLocal      net.IP\n\tRemote     net.IP\n\tTtl        uint8\n\tTos        uint8\n\tFlags      uint32\n\tProto      uint8\n\tFlowInfo   uint32\n\tEncapLimit uint8\n\tEncapType  uint16\n\tEncapFlags uint16\n\tEncapSport uint16\n\tEncapDport uint16\n\tFlowBased  bool\n}\n\nfunc (ip6tnl *Ip6tnl) Attrs() *LinkAttrs {\n\treturn &ip6tnl.LinkAttrs\n}\n\nfunc (ip6tnl *Ip6tnl) Type() string {\n\treturn \"ip6tnl\"\n}\n\n// from https://elixir.bootlin.com/linux/v5.15.4/source/include/uapi/linux/if_tunnel.h#L84\ntype TunnelEncapType uint16\n\nconst (\n\tNone TunnelEncapType = iota\n\tFOU\n\tGUE\n)\n\n// from https://elixir.bootlin.com/linux/v5.15.4/source/include/uapi/linux/if_tunnel.h#L91\ntype TunnelEncapFlag uint16\n\nconst (\n\tCSum    TunnelEncapFlag = 1 << 0\n\tCSum6                   = 1 << 1\n\tRemCSum                 = 1 << 2\n)\n\n// from https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/ip6_tunnel.h#L12\ntype IP6TunnelFlag uint16\n\nconst (\n\tIP6_TNL_F_IGN_ENCAP_LIMIT    IP6TunnelFlag = 1  // don't add encapsulation limit if one isn't present in inner packet\n\tIP6_TNL_F_USE_ORIG_TCLASS                  = 2  // copy the traffic class field from the inner packet\n\tIP6_TNL_F_USE_ORIG_FLOWLABEL               = 4  // copy the flowlabel from the inner packet\n\tIP6_TNL_F_MIP6_DEV                         = 8  // being used for Mobile IPv6\n\tIP6_TNL_F_RCV_DSCP_COPY                    = 10 // copy DSCP from the outer packet\n\tIP6_TNL_F_USE_ORIG_FWMARK                  = 20 // copy fwmark from inner packet\n\tIP6_TNL_F_ALLOW_LOCAL_REMOTE               = 40 // allow remote endpoint on the local node\n)\n\ntype Sittun struct {\n\tLinkAttrs\n\tLink       uint32\n\tTtl        uint8\n\tTos        uint8\n\tPMtuDisc   uint8\n\tProto      uint8\n\tLocal      net.IP\n\tRemote     net.IP\n\tEncapLimit uint8\n\tEncapType  uint16\n\tEncapFlags uint16\n\tEncapSport uint16\n\tEncapDport uint16\n}\n\nfunc (sittun *Sittun) Attrs() *LinkAttrs {\n\treturn &sittun.LinkAttrs\n}\n\nfunc (sittun *Sittun) Type() string {\n\treturn \"sit\"\n}\n\ntype Vti struct {\n\tLinkAttrs\n\tIKey   uint32\n\tOKey   uint32\n\tLink   uint32\n\tLocal  net.IP\n\tRemote net.IP\n}\n\nfunc (vti *Vti) Attrs() *LinkAttrs {\n\treturn &vti.LinkAttrs\n}\n\nfunc (vti *Vti) Type() string {\n\tif vti.Local.To4() == nil {\n\t\treturn \"vti6\"\n\t}\n\treturn \"vti\"\n}\n\ntype Gretun struct {\n\tLinkAttrs\n\tLink       uint32\n\tIFlags     uint16\n\tOFlags     uint16\n\tIKey       uint32\n\tOKey       uint32\n\tLocal      net.IP\n\tRemote     net.IP\n\tTtl        uint8\n\tTos        uint8\n\tPMtuDisc   uint8\n\tEncapType  uint16\n\tEncapFlags uint16\n\tEncapSport uint16\n\tEncapDport uint16\n\tFlowBased  bool\n}\n\nfunc (gretun *Gretun) Attrs() *LinkAttrs {\n\treturn &gretun.LinkAttrs\n}\n\nfunc (gretun *Gretun) Type() string {\n\tif gretun.Local.To4() == nil {\n\t\treturn \"ip6gre\"\n\t}\n\treturn \"gre\"\n}\n\ntype Vrf struct {\n\tLinkAttrs\n\tTable uint32\n}\n\nfunc (vrf *Vrf) Attrs() *LinkAttrs {\n\treturn &vrf.LinkAttrs\n}\n\nfunc (vrf *Vrf) Type() string {\n\treturn \"vrf\"\n}\n\ntype GTP struct {\n\tLinkAttrs\n\tFD0         int\n\tFD1         int\n\tRole        int\n\tPDPHashsize int\n}\n\nfunc (gtp *GTP) Attrs() *LinkAttrs {\n\treturn &gtp.LinkAttrs\n}\n\nfunc (gtp *GTP) Type() string {\n\treturn \"gtp\"\n}\n\n// Virtual XFRM Interfaces\n//\n//\tNamed \"xfrmi\" to prevent confusion with XFRM objects\ntype Xfrmi struct {\n\tLinkAttrs\n\tIfid uint32\n}\n\nfunc (xfrm *Xfrmi) Attrs() *LinkAttrs {\n\treturn &xfrm.LinkAttrs\n}\n\nfunc (xfrm *Xfrmi) Type() string {\n\treturn \"xfrm\"\n}\n\n// IPoIB interface\n\ntype IPoIBMode uint16\n\nfunc (m *IPoIBMode) String() string {\n\tstr, ok := iPoIBModeToString[*m]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"mode(%d)\", *m)\n\t}\n\treturn str\n}\n\nconst (\n\tIPOIB_MODE_DATAGRAM = iota\n\tIPOIB_MODE_CONNECTED\n)\n\nvar iPoIBModeToString = map[IPoIBMode]string{\n\tIPOIB_MODE_DATAGRAM:  \"datagram\",\n\tIPOIB_MODE_CONNECTED: \"connected\",\n}\n\nvar StringToIPoIBMode = map[string]IPoIBMode{\n\t\"datagram\":  IPOIB_MODE_DATAGRAM,\n\t\"connected\": IPOIB_MODE_CONNECTED,\n}\n\nconst (\n\tCAN_STATE_ERROR_ACTIVE = iota\n\tCAN_STATE_ERROR_WARNING\n\tCAN_STATE_ERROR_PASSIVE\n\tCAN_STATE_BUS_OFF\n\tCAN_STATE_STOPPED\n\tCAN_STATE_SLEEPING\n)\n\ntype Can struct {\n\tLinkAttrs\n\n\tBitRate            uint32\n\tSamplePoint        uint32\n\tTimeQuanta         uint32\n\tPropagationSegment uint32\n\tPhaseSegment1      uint32\n\tPhaseSegment2      uint32\n\tSyncJumpWidth      uint32\n\tBitRatePreScaler   uint32\n\n\tName                string\n\tTimeSegment1Min     uint32\n\tTimeSegment1Max     uint32\n\tTimeSegment2Min     uint32\n\tTimeSegment2Max     uint32\n\tSyncJumpWidthMax    uint32\n\tBitRatePreScalerMin uint32\n\tBitRatePreScalerMax uint32\n\tBitRatePreScalerInc uint32\n\n\tClockFrequency uint32\n\n\tState uint32\n\n\tMask  uint32\n\tFlags uint32\n\n\tTxError uint16\n\tRxError uint16\n\n\tRestartMs uint32\n}\n\nfunc (can *Can) Attrs() *LinkAttrs {\n\treturn &can.LinkAttrs\n}\n\nfunc (can *Can) Type() string {\n\treturn \"can\"\n}\n\ntype IPoIB struct {\n\tLinkAttrs\n\tPkey   uint16\n\tMode   IPoIBMode\n\tUmcast uint16\n}\n\nfunc (ipoib *IPoIB) Attrs() *LinkAttrs {\n\treturn &ipoib.LinkAttrs\n}\n\nfunc (ipoib *IPoIB) Type() string {\n\treturn \"ipoib\"\n}\n\ntype BareUDP struct {\n\tLinkAttrs\n\tPort       uint16\n\tEtherType  uint16\n\tSrcPortMin uint16\n\tMultiProto bool\n}\n\nfunc (bareudp *BareUDP) Attrs() *LinkAttrs {\n\treturn &bareudp.LinkAttrs\n}\n\nfunc (bareudp *BareUDP) Type() string {\n\treturn \"bareudp\"\n}\n\n// iproute2 supported devices;\n// vlan | veth | vcan | dummy | ifb | macvlan | macvtap |\n// bridge | bond | ipoib | ip6tnl | ipip | sit | vxlan |\n// gre | gretap | ip6gre | ip6gretap | vti | vti6 | nlmon |\n// bond_slave | ipvlan | xfrm | bareudp\n\n// LinkNotFoundError wraps the various not found errors when\n// getting/reading links. This is intended for better error\n// handling by dependent code so that \"not found error\" can\n// be distinguished from other errors\ntype LinkNotFoundError struct {\n\terror\n}\n"
        },
        {
          "name": "link_linux.go",
          "type": "blob",
          "size": 117.787109375,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"unsafe\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\tSizeofLinkStats32 = 0x5c\n\tSizeofLinkStats64 = 0xb8\n)\n\nconst (\n\tTUNTAP_MODE_TUN             TuntapMode = unix.IFF_TUN\n\tTUNTAP_MODE_TAP             TuntapMode = unix.IFF_TAP\n\tTUNTAP_DEFAULTS             TuntapFlag = unix.IFF_TUN_EXCL | unix.IFF_ONE_QUEUE\n\tTUNTAP_VNET_HDR             TuntapFlag = unix.IFF_VNET_HDR\n\tTUNTAP_TUN_EXCL             TuntapFlag = unix.IFF_TUN_EXCL\n\tTUNTAP_NO_PI                TuntapFlag = unix.IFF_NO_PI\n\tTUNTAP_ONE_QUEUE            TuntapFlag = unix.IFF_ONE_QUEUE\n\tTUNTAP_MULTI_QUEUE          TuntapFlag = unix.IFF_MULTI_QUEUE\n\tTUNTAP_MULTI_QUEUE_DEFAULTS TuntapFlag = TUNTAP_MULTI_QUEUE | TUNTAP_NO_PI\n)\n\nvar StringToTuntapModeMap = map[string]TuntapMode{\n\t\"tun\": TUNTAP_MODE_TUN,\n\t\"tap\": TUNTAP_MODE_TAP,\n}\n\nfunc (ttm TuntapMode) String() string {\n\tswitch ttm {\n\tcase TUNTAP_MODE_TUN:\n\t\treturn \"tun\"\n\tcase TUNTAP_MODE_TAP:\n\t\treturn \"tap\"\n\t}\n\treturn \"unknown\"\n}\n\nconst (\n\tVF_LINK_STATE_AUTO    uint32 = 0\n\tVF_LINK_STATE_ENABLE  uint32 = 1\n\tVF_LINK_STATE_DISABLE uint32 = 2\n)\n\nvar macvlanModes = [...]uint32{\n\t0,\n\tnl.MACVLAN_MODE_PRIVATE,\n\tnl.MACVLAN_MODE_VEPA,\n\tnl.MACVLAN_MODE_BRIDGE,\n\tnl.MACVLAN_MODE_PASSTHRU,\n\tnl.MACVLAN_MODE_SOURCE,\n}\n\nfunc ensureIndex(link *LinkAttrs) {\n\tif link != nil && link.Index == 0 {\n\t\tnewlink, _ := LinkByName(link.Name)\n\t\tif newlink != nil {\n\t\t\tlink.Index = newlink.Attrs().Index\n\t\t}\n\t}\n}\n\nfunc (h *Handle) ensureIndex(link *LinkAttrs) {\n\tif link != nil && link.Index == 0 {\n\t\tnewlink, _ := h.LinkByName(link.Name)\n\t\tif newlink != nil {\n\t\t\tlink.Index = newlink.Attrs().Index\n\t\t}\n\t}\n}\n\nfunc (h *Handle) LinkSetARPOff(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change |= unix.IFF_NOARP\n\tmsg.Flags |= unix.IFF_NOARP\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc LinkSetARPOff(link Link) error {\n\treturn pkgHandle.LinkSetARPOff(link)\n}\n\nfunc (h *Handle) LinkSetARPOn(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change |= unix.IFF_NOARP\n\tmsg.Flags &= ^uint32(unix.IFF_NOARP)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc LinkSetARPOn(link Link) error {\n\treturn pkgHandle.LinkSetARPOn(link)\n}\n\nfunc (h *Handle) SetPromiscOn(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change = unix.IFF_PROMISC\n\tmsg.Flags = unix.IFF_PROMISC\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetAllmulticastOn enables the reception of all hardware multicast packets for the link device.\n// Equivalent to: `ip link set $link allmulticast on`\nfunc LinkSetAllmulticastOn(link Link) error {\n\treturn pkgHandle.LinkSetAllmulticastOn(link)\n}\n\n// LinkSetAllmulticastOn enables the reception of all hardware multicast packets for the link device.\n// Equivalent to: `ip link set $link allmulticast on`\nfunc (h *Handle) LinkSetAllmulticastOn(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change = unix.IFF_ALLMULTI\n\tmsg.Flags = unix.IFF_ALLMULTI\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetAllmulticastOff disables the reception of all hardware multicast packets for the link device.\n// Equivalent to: `ip link set $link allmulticast off`\nfunc LinkSetAllmulticastOff(link Link) error {\n\treturn pkgHandle.LinkSetAllmulticastOff(link)\n}\n\n// LinkSetAllmulticastOff disables the reception of all hardware multicast packets for the link device.\n// Equivalent to: `ip link set $link allmulticast off`\nfunc (h *Handle) LinkSetAllmulticastOff(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change = unix.IFF_ALLMULTI\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetMulticastOn enables the reception of multicast packets for the link device.\n// Equivalent to: `ip link set $link multicast on`\nfunc LinkSetMulticastOn(link Link) error {\n\treturn pkgHandle.LinkSetMulticastOn(link)\n}\n\n// LinkSetMulticastOn enables the reception of multicast packets for the link device.\n// Equivalent to: `ip link set $link multicast on`\nfunc (h *Handle) LinkSetMulticastOn(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change = unix.IFF_MULTICAST\n\tmsg.Flags = unix.IFF_MULTICAST\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetAllmulticastOff disables the reception of multicast packets for the link device.\n// Equivalent to: `ip link set $link multicast off`\nfunc LinkSetMulticastOff(link Link) error {\n\treturn pkgHandle.LinkSetMulticastOff(link)\n}\n\n// LinkSetAllmulticastOff disables the reception of multicast packets for the link device.\n// Equivalent to: `ip link set $link multicast off`\nfunc (h *Handle) LinkSetMulticastOff(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change = unix.IFF_MULTICAST\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc MacvlanMACAddrAdd(link Link, addr net.HardwareAddr) error {\n\treturn pkgHandle.MacvlanMACAddrAdd(link, addr)\n}\n\nfunc (h *Handle) MacvlanMACAddrAdd(link Link, addr net.HardwareAddr) error {\n\treturn h.macvlanMACAddrChange(link, []net.HardwareAddr{addr}, nl.MACVLAN_MACADDR_ADD)\n}\n\nfunc MacvlanMACAddrDel(link Link, addr net.HardwareAddr) error {\n\treturn pkgHandle.MacvlanMACAddrDel(link, addr)\n}\n\nfunc (h *Handle) MacvlanMACAddrDel(link Link, addr net.HardwareAddr) error {\n\treturn h.macvlanMACAddrChange(link, []net.HardwareAddr{addr}, nl.MACVLAN_MACADDR_DEL)\n}\n\nfunc MacvlanMACAddrFlush(link Link) error {\n\treturn pkgHandle.MacvlanMACAddrFlush(link)\n}\n\nfunc (h *Handle) MacvlanMACAddrFlush(link Link) error {\n\treturn h.macvlanMACAddrChange(link, nil, nl.MACVLAN_MACADDR_FLUSH)\n}\n\nfunc MacvlanMACAddrSet(link Link, addrs []net.HardwareAddr) error {\n\treturn pkgHandle.MacvlanMACAddrSet(link, addrs)\n}\n\nfunc (h *Handle) MacvlanMACAddrSet(link Link, addrs []net.HardwareAddr) error {\n\treturn h.macvlanMACAddrChange(link, addrs, nl.MACVLAN_MACADDR_SET)\n}\n\nfunc (h *Handle) macvlanMACAddrChange(link Link, addrs []net.HardwareAddr, mode uint32) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tlinkInfo := nl.NewRtAttr(unix.IFLA_LINKINFO, nil)\n\tlinkInfo.AddRtAttr(nl.IFLA_INFO_KIND, nl.NonZeroTerminated(link.Type()))\n\tinner := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\t// IFLA_MACVLAN_MACADDR_MODE = mode\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, mode)\n\tinner.AddRtAttr(nl.IFLA_MACVLAN_MACADDR_MODE, b)\n\n\t// populate message with MAC addrs, if necessary\n\tswitch mode {\n\tcase nl.MACVLAN_MACADDR_ADD, nl.MACVLAN_MACADDR_DEL:\n\t\tif len(addrs) == 1 {\n\t\t\tinner.AddRtAttr(nl.IFLA_MACVLAN_MACADDR, []byte(addrs[0]))\n\t\t}\n\tcase nl.MACVLAN_MACADDR_SET:\n\t\tmad := inner.AddRtAttr(nl.IFLA_MACVLAN_MACADDR_DATA, nil)\n\t\tfor _, addr := range addrs {\n\t\t\tmad.AddRtAttr(nl.IFLA_MACVLAN_MACADDR, []byte(addr))\n\t\t}\n\t}\n\n\treq.AddData(linkInfo)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetMacvlanMode sets the mode of a macvlan or macvtap link device.\n// Note that passthrough mode cannot be set to and from and will fail.\n// Equivalent to: `ip link set $link type (macvlan|macvtap) mode $mode\nfunc LinkSetMacvlanMode(link Link, mode MacvlanMode) error {\n\treturn pkgHandle.LinkSetMacvlanMode(link, mode)\n}\n\n// LinkSetMacvlanMode sets the mode of the macvlan or macvtap link device.\n// Note that passthrough mode cannot be set to and from and will fail.\n// Equivalent to: `ip link set $link type (macvlan|macvtap) mode $mode\nfunc (h *Handle) LinkSetMacvlanMode(link Link, mode MacvlanMode) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tlinkInfo := nl.NewRtAttr(unix.IFLA_LINKINFO, nil)\n\tlinkInfo.AddRtAttr(nl.IFLA_INFO_KIND, nl.NonZeroTerminated(link.Type()))\n\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\tdata.AddRtAttr(nl.IFLA_MACVLAN_MODE, nl.Uint32Attr(macvlanModes[mode]))\n\n\treq.AddData(linkInfo)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc BridgeSetMcastSnoop(link Link, on bool) error {\n\treturn pkgHandle.BridgeSetMcastSnoop(link, on)\n}\n\nfunc (h *Handle) BridgeSetMcastSnoop(link Link, on bool) error {\n\tbridge := link.(*Bridge)\n\tbridge.MulticastSnooping = &on\n\treturn h.linkModify(bridge, unix.NLM_F_ACK)\n}\n\nfunc BridgeSetVlanFiltering(link Link, on bool) error {\n\treturn pkgHandle.BridgeSetVlanFiltering(link, on)\n}\n\nfunc (h *Handle) BridgeSetVlanFiltering(link Link, on bool) error {\n\tbridge := link.(*Bridge)\n\tbridge.VlanFiltering = &on\n\treturn h.linkModify(bridge, unix.NLM_F_ACK)\n}\n\nfunc BridgeSetVlanDefaultPVID(link Link, pvid uint16) error {\n\treturn pkgHandle.BridgeSetVlanDefaultPVID(link, pvid)\n}\n\nfunc (h *Handle) BridgeSetVlanDefaultPVID(link Link, pvid uint16) error {\n\tbridge := link.(*Bridge)\n\tbridge.VlanDefaultPVID = &pvid\n\treturn h.linkModify(bridge, unix.NLM_F_ACK)\n}\n\nfunc SetPromiscOn(link Link) error {\n\treturn pkgHandle.SetPromiscOn(link)\n}\n\nfunc (h *Handle) SetPromiscOff(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change = unix.IFF_PROMISC\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc SetPromiscOff(link Link) error {\n\treturn pkgHandle.SetPromiscOff(link)\n}\n\n// LinkSetUp enables the link device.\n// Equivalent to: `ip link set $link up`\nfunc LinkSetUp(link Link) error {\n\treturn pkgHandle.LinkSetUp(link)\n}\n\n// LinkSetUp enables the link device.\n// Equivalent to: `ip link set $link up`\nfunc (h *Handle) LinkSetUp(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change = unix.IFF_UP\n\tmsg.Flags = unix.IFF_UP\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetDown disables link device.\n// Equivalent to: `ip link set $link down`\nfunc LinkSetDown(link Link) error {\n\treturn pkgHandle.LinkSetDown(link)\n}\n\n// LinkSetDown disables link device.\n// Equivalent to: `ip link set $link down`\nfunc (h *Handle) LinkSetDown(link Link) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Change = unix.IFF_UP\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetMTU sets the mtu of the link device.\n// Equivalent to: `ip link set $link mtu $mtu`\nfunc LinkSetMTU(link Link, mtu int) error {\n\treturn pkgHandle.LinkSetMTU(link, mtu)\n}\n\n// LinkSetMTU sets the mtu of the link device.\n// Equivalent to: `ip link set $link mtu $mtu`\nfunc (h *Handle) LinkSetMTU(link Link, mtu int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(mtu))\n\n\tdata := nl.NewRtAttr(unix.IFLA_MTU, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetName sets the name of the link device.\n// Equivalent to: `ip link set $link name $name`\nfunc LinkSetName(link Link, name string) error {\n\treturn pkgHandle.LinkSetName(link, name)\n}\n\n// LinkSetName sets the name of the link device.\n// Equivalent to: `ip link set $link name $name`\nfunc (h *Handle) LinkSetName(link Link, name string) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_IFNAME, []byte(name))\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetAlias sets the alias of the link device.\n// Equivalent to: `ip link set dev $link alias $name`\nfunc LinkSetAlias(link Link, name string) error {\n\treturn pkgHandle.LinkSetAlias(link, name)\n}\n\n// LinkSetAlias sets the alias of the link device.\n// Equivalent to: `ip link set dev $link alias $name`\nfunc (h *Handle) LinkSetAlias(link Link, name string) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_IFALIAS, []byte(name))\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkAddAltName adds a new alternative name for the link device.\n// Equivalent to: `ip link property add $link altname $name`\nfunc LinkAddAltName(link Link, name string) error {\n\treturn pkgHandle.LinkAddAltName(link, name)\n}\n\n// LinkAddAltName adds a new alternative name for the link device.\n// Equivalent to: `ip link property add $link altname $name`\nfunc (h *Handle) LinkAddAltName(link Link, name string) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINKPROP, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_PROP_LIST|unix.NLA_F_NESTED, nil)\n\tdata.AddRtAttr(unix.IFLA_ALT_IFNAME, []byte(name))\n\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkDelAltName delete an alternative name for the link device.\n// Equivalent to: `ip link property del $link altname $name`\nfunc LinkDelAltName(link Link, name string) error {\n\treturn pkgHandle.LinkDelAltName(link, name)\n}\n\n// LinkDelAltName delete an alternative name for the link device.\n// Equivalent to: `ip link property del $link altname $name`\nfunc (h *Handle) LinkDelAltName(link Link, name string) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_DELLINKPROP, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_PROP_LIST|unix.NLA_F_NESTED, nil)\n\tdata.AddRtAttr(unix.IFLA_ALT_IFNAME, []byte(name))\n\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetHardwareAddr sets the hardware address of the link device.\n// Equivalent to: `ip link set $link address $hwaddr`\nfunc LinkSetHardwareAddr(link Link, hwaddr net.HardwareAddr) error {\n\treturn pkgHandle.LinkSetHardwareAddr(link, hwaddr)\n}\n\n// LinkSetHardwareAddr sets the hardware address of the link device.\n// Equivalent to: `ip link set $link address $hwaddr`\nfunc (h *Handle) LinkSetHardwareAddr(link Link, hwaddr net.HardwareAddr) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_ADDRESS, []byte(hwaddr))\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfHardwareAddr sets the hardware address of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf mac $hwaddr`\nfunc LinkSetVfHardwareAddr(link Link, vf int, hwaddr net.HardwareAddr) error {\n\treturn pkgHandle.LinkSetVfHardwareAddr(link, vf, hwaddr)\n}\n\n// LinkSetVfHardwareAddr sets the hardware address of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf mac $hwaddr`\nfunc (h *Handle) LinkSetVfHardwareAddr(link Link, vf int, hwaddr net.HardwareAddr) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tinfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tvfmsg := nl.VfMac{\n\t\tVf: uint32(vf),\n\t}\n\tcopy(vfmsg.Mac[:], []byte(hwaddr))\n\tinfo.AddRtAttr(nl.IFLA_VF_MAC, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfVlan sets the vlan of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf vlan $vlan`\nfunc LinkSetVfVlan(link Link, vf, vlan int) error {\n\treturn pkgHandle.LinkSetVfVlan(link, vf, vlan)\n}\n\n// LinkSetVfVlan sets the vlan of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf vlan $vlan`\nfunc (h *Handle) LinkSetVfVlan(link Link, vf, vlan int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tinfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tvfmsg := nl.VfVlan{\n\t\tVf:   uint32(vf),\n\t\tVlan: uint32(vlan),\n\t}\n\tinfo.AddRtAttr(nl.IFLA_VF_VLAN, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfVlanQos sets the vlan and qos priority of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf vlan $vlan qos $qos`\nfunc LinkSetVfVlanQos(link Link, vf, vlan, qos int) error {\n\treturn pkgHandle.LinkSetVfVlanQos(link, vf, vlan, qos)\n}\n\n// LinkSetVfVlanQos sets the vlan and qos priority of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf vlan $vlan qos $qos`\nfunc (h *Handle) LinkSetVfVlanQos(link Link, vf, vlan, qos int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tinfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tvfmsg := nl.VfVlan{\n\t\tVf:   uint32(vf),\n\t\tVlan: uint32(vlan),\n\t\tQos:  uint32(qos),\n\t}\n\tinfo.AddRtAttr(nl.IFLA_VF_VLAN, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfVlanQosProto sets the vlan, qos and protocol of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf vlan $vlan qos $qos proto $proto`\nfunc LinkSetVfVlanQosProto(link Link, vf, vlan, qos, proto int) error {\n\treturn pkgHandle.LinkSetVfVlanQosProto(link, vf, vlan, qos, proto)\n}\n\n// LinkSetVfVlanQosProto sets the vlan, qos and protocol of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf vlan $vlan qos $qos proto $proto`\nfunc (h *Handle) LinkSetVfVlanQosProto(link Link, vf, vlan, qos, proto int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tvfInfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tvfVlanList := vfInfo.AddRtAttr(nl.IFLA_VF_VLAN_LIST, nil)\n\n\tvfmsg := nl.VfVlanInfo{\n\t\tVfVlan: nl.VfVlan{\n\t\t\tVf:   uint32(vf),\n\t\t\tVlan: uint32(vlan),\n\t\t\tQos:  uint32(qos),\n\t\t},\n\t\tVlanProto: (uint16(proto)>>8)&0xFF | (uint16(proto)&0xFF)<<8,\n\t}\n\n\tvfVlanList.AddRtAttr(nl.IFLA_VF_VLAN_INFO, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfTxRate sets the tx rate of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf rate $rate`\nfunc LinkSetVfTxRate(link Link, vf, rate int) error {\n\treturn pkgHandle.LinkSetVfTxRate(link, vf, rate)\n}\n\n// LinkSetVfTxRate sets the tx rate of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf rate $rate`\nfunc (h *Handle) LinkSetVfTxRate(link Link, vf, rate int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tinfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tvfmsg := nl.VfTxRate{\n\t\tVf:   uint32(vf),\n\t\tRate: uint32(rate),\n\t}\n\tinfo.AddRtAttr(nl.IFLA_VF_TX_RATE, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfRate sets the min and max tx rate of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf min_tx_rate $min_rate max_tx_rate $max_rate`\nfunc LinkSetVfRate(link Link, vf, minRate, maxRate int) error {\n\treturn pkgHandle.LinkSetVfRate(link, vf, minRate, maxRate)\n}\n\n// LinkSetVfRate sets the min and max tx rate of a vf for the link.\n// Equivalent to: `ip link set $link vf $vf min_tx_rate $min_rate max_tx_rate $max_rate`\nfunc (h *Handle) LinkSetVfRate(link Link, vf, minRate, maxRate int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tinfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tvfmsg := nl.VfRate{\n\t\tVf:        uint32(vf),\n\t\tMinTxRate: uint32(minRate),\n\t\tMaxTxRate: uint32(maxRate),\n\t}\n\tinfo.AddRtAttr(nl.IFLA_VF_RATE, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfState enables/disables virtual link state on a vf.\n// Equivalent to: `ip link set $link vf $vf state $state`\nfunc LinkSetVfState(link Link, vf int, state uint32) error {\n\treturn pkgHandle.LinkSetVfState(link, vf, state)\n}\n\n// LinkSetVfState enables/disables virtual link state on a vf.\n// Equivalent to: `ip link set $link vf $vf state $state`\nfunc (h *Handle) LinkSetVfState(link Link, vf int, state uint32) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tinfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tvfmsg := nl.VfLinkState{\n\t\tVf:        uint32(vf),\n\t\tLinkState: state,\n\t}\n\tinfo.AddRtAttr(nl.IFLA_VF_LINK_STATE, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfSpoofchk enables/disables spoof check on a vf for the link.\n// Equivalent to: `ip link set $link vf $vf spoofchk $check`\nfunc LinkSetVfSpoofchk(link Link, vf int, check bool) error {\n\treturn pkgHandle.LinkSetVfSpoofchk(link, vf, check)\n}\n\n// LinkSetVfSpoofchk enables/disables spoof check on a vf for the link.\n// Equivalent to: `ip link set $link vf $vf spoofchk $check`\nfunc (h *Handle) LinkSetVfSpoofchk(link Link, vf int, check bool) error {\n\tvar setting uint32\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tinfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tif check {\n\t\tsetting = 1\n\t}\n\tvfmsg := nl.VfSpoofchk{\n\t\tVf:      uint32(vf),\n\t\tSetting: setting,\n\t}\n\tinfo.AddRtAttr(nl.IFLA_VF_SPOOFCHK, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfTrust enables/disables trust state on a vf for the link.\n// Equivalent to: `ip link set $link vf $vf trust $state`\nfunc LinkSetVfTrust(link Link, vf int, state bool) error {\n\treturn pkgHandle.LinkSetVfTrust(link, vf, state)\n}\n\n// LinkSetVfTrust enables/disables trust state on a vf for the link.\n// Equivalent to: `ip link set $link vf $vf trust $state`\nfunc (h *Handle) LinkSetVfTrust(link Link, vf int, state bool) error {\n\tvar setting uint32\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tinfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tif state {\n\t\tsetting = 1\n\t}\n\tvfmsg := nl.VfTrust{\n\t\tVf:      uint32(vf),\n\t\tSetting: setting,\n\t}\n\tinfo.AddRtAttr(nl.IFLA_VF_TRUST, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetVfNodeGUID sets the node GUID of a vf for the link.\n// Equivalent to: `ip link set dev $link vf $vf node_guid $nodeguid`\nfunc LinkSetVfNodeGUID(link Link, vf int, nodeguid net.HardwareAddr) error {\n\treturn pkgHandle.LinkSetVfGUID(link, vf, nodeguid, nl.IFLA_VF_IB_NODE_GUID)\n}\n\n// LinkSetVfPortGUID sets the port GUID of a vf for the link.\n// Equivalent to: `ip link set dev $link vf $vf port_guid $portguid`\nfunc LinkSetVfPortGUID(link Link, vf int, portguid net.HardwareAddr) error {\n\treturn pkgHandle.LinkSetVfGUID(link, vf, portguid, nl.IFLA_VF_IB_PORT_GUID)\n}\n\n// LinkSetVfGUID sets the node or port GUID of a vf for the link.\nfunc (h *Handle) LinkSetVfGUID(link Link, vf int, vfGuid net.HardwareAddr, guidType int) error {\n\tvar err error\n\tvar guid uint64\n\n\tbuf := bytes.NewBuffer(vfGuid)\n\terr = binary.Read(buf, binary.BigEndian, &guid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tdata := nl.NewRtAttr(unix.IFLA_VFINFO_LIST, nil)\n\tinfo := data.AddRtAttr(nl.IFLA_VF_INFO, nil)\n\tvfmsg := nl.VfGUID{\n\t\tVf:   uint32(vf),\n\t\tGUID: guid,\n\t}\n\tinfo.AddRtAttr(guidType, vfmsg.Serialize())\n\treq.AddData(data)\n\n\t_, err = req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetMaster sets the master of the link device.\n// Equivalent to: `ip link set $link master $master`\nfunc LinkSetMaster(link Link, master Link) error {\n\treturn pkgHandle.LinkSetMaster(link, master)\n}\n\n// LinkSetMaster sets the master of the link device.\n// Equivalent to: `ip link set $link master $master`\nfunc (h *Handle) LinkSetMaster(link Link, master Link) error {\n\tindex := 0\n\tif master != nil {\n\t\tmasterBase := master.Attrs()\n\t\th.ensureIndex(masterBase)\n\t\tindex = masterBase.Index\n\t}\n\tif index <= 0 {\n\t\treturn fmt.Errorf(\"Device does not exist\")\n\t}\n\treturn h.LinkSetMasterByIndex(link, index)\n}\n\n// LinkSetNoMaster removes the master of the link device.\n// Equivalent to: `ip link set $link nomaster`\nfunc LinkSetNoMaster(link Link) error {\n\treturn pkgHandle.LinkSetNoMaster(link)\n}\n\n// LinkSetNoMaster removes the master of the link device.\n// Equivalent to: `ip link set $link nomaster`\nfunc (h *Handle) LinkSetNoMaster(link Link) error {\n\treturn h.LinkSetMasterByIndex(link, 0)\n}\n\n// LinkSetMasterByIndex sets the master of the link device.\n// Equivalent to: `ip link set $link master $master`\nfunc LinkSetMasterByIndex(link Link, masterIndex int) error {\n\treturn pkgHandle.LinkSetMasterByIndex(link, masterIndex)\n}\n\n// LinkSetMasterByIndex sets the master of the link device.\n// Equivalent to: `ip link set $link master $master`\nfunc (h *Handle) LinkSetMasterByIndex(link Link, masterIndex int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(masterIndex))\n\n\tdata := nl.NewRtAttr(unix.IFLA_MASTER, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetNsPid puts the device into a new network namespace. The\n// pid must be a pid of a running process.\n// Equivalent to: `ip link set $link netns $pid`\nfunc LinkSetNsPid(link Link, nspid int) error {\n\treturn pkgHandle.LinkSetNsPid(link, nspid)\n}\n\n// LinkSetNsPid puts the device into a new network namespace. The\n// pid must be a pid of a running process.\n// Equivalent to: `ip link set $link netns $pid`\nfunc (h *Handle) LinkSetNsPid(link Link, nspid int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(nspid))\n\n\tdata := nl.NewRtAttr(unix.IFLA_NET_NS_PID, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetNsFd puts the device into a new network namespace. The\n// fd must be an open file descriptor to a network namespace.\n// Similar to: `ip link set $link netns $ns`\nfunc LinkSetNsFd(link Link, fd int) error {\n\treturn pkgHandle.LinkSetNsFd(link, fd)\n}\n\n// LinkSetNsFd puts the device into a new network namespace. The\n// fd must be an open file descriptor to a network namespace.\n// Similar to: `ip link set $link netns $ns`\nfunc (h *Handle) LinkSetNsFd(link Link, fd int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(fd))\n\n\tdata := nl.NewRtAttr(unix.IFLA_NET_NS_FD, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetXdpFd adds a bpf function to the driver. The fd must be a bpf\n// program loaded with bpf(type=BPF_PROG_TYPE_XDP)\nfunc LinkSetXdpFd(link Link, fd int) error {\n\treturn LinkSetXdpFdWithFlags(link, fd, 0)\n}\n\n// LinkSetXdpFdWithFlags adds a bpf function to the driver with the given\n// options. The fd must be a bpf program loaded with bpf(type=BPF_PROG_TYPE_XDP)\nfunc LinkSetXdpFdWithFlags(link Link, fd, flags int) error {\n\tbase := link.Attrs()\n\tensureIndex(base)\n\treq := nl.NewNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\taddXdpAttrs(&LinkXdp{Fd: fd, Flags: uint32(flags)}, req)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetGSOMaxSegs sets the GSO maximum segment count of the link device.\n// Equivalent to: `ip link set $link gso_max_segs $maxSegs`\nfunc LinkSetGSOMaxSegs(link Link, maxSegs int) error {\n\treturn pkgHandle.LinkSetGSOMaxSegs(link, maxSegs)\n}\n\n// LinkSetGSOMaxSegs sets the GSO maximum segment count of the link device.\n// Equivalent to: `ip link set $link gso_max_segs $maxSegs`\nfunc (h *Handle) LinkSetGSOMaxSegs(link Link, maxSize int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(maxSize))\n\n\tdata := nl.NewRtAttr(unix.IFLA_GSO_MAX_SEGS, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetGSOMaxSize sets the IPv6 GSO maximum size of the link device.\n// Equivalent to: `ip link set $link gso_max_size $maxSize`\nfunc LinkSetGSOMaxSize(link Link, maxSize int) error {\n\treturn pkgHandle.LinkSetGSOMaxSize(link, maxSize)\n}\n\n// LinkSetGSOMaxSize sets the IPv6 GSO maximum size of the link device.\n// Equivalent to: `ip link set $link gso_max_size $maxSize`\nfunc (h *Handle) LinkSetGSOMaxSize(link Link, maxSize int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(maxSize))\n\n\tdata := nl.NewRtAttr(unix.IFLA_GSO_MAX_SIZE, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetGROMaxSize sets the IPv6 GRO maximum size of the link device.\n// Equivalent to: `ip link set $link gro_max_size $maxSize`\nfunc LinkSetGROMaxSize(link Link, maxSize int) error {\n\treturn pkgHandle.LinkSetGROMaxSize(link, maxSize)\n}\n\n// LinkSetGROMaxSize sets the IPv6 GRO maximum size of the link device.\n// Equivalent to: `ip link set $link gro_max_size $maxSize`\nfunc (h *Handle) LinkSetGROMaxSize(link Link, maxSize int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(maxSize))\n\n\tdata := nl.NewRtAttr(unix.IFLA_GRO_MAX_SIZE, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetGSOIPv4MaxSize sets the IPv4 GSO maximum size of the link device.\n// Equivalent to: `ip link set $link gso_ipv4_max_size $maxSize`\nfunc LinkSetGSOIPv4MaxSize(link Link, maxSize int) error {\n\treturn pkgHandle.LinkSetGSOIPv4MaxSize(link, maxSize)\n}\n\n// LinkSetGSOIPv4MaxSize sets the IPv4 GSO maximum size of the link device.\n// Equivalent to: `ip link set $link gso_ipv4_max_size $maxSize`\nfunc (h *Handle) LinkSetGSOIPv4MaxSize(link Link, maxSize int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(maxSize))\n\n\tdata := nl.NewRtAttr(unix.IFLA_GSO_IPV4_MAX_SIZE, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetGROIPv4MaxSize sets the IPv4 GRO maximum size of the link device.\n// Equivalent to: `ip link set $link gro_ipv4_max_size $maxSize`\nfunc LinkSetGROIPv4MaxSize(link Link, maxSize int) error {\n\treturn pkgHandle.LinkSetGROIPv4MaxSize(link, maxSize)\n}\n\n// LinkSetGROIPv4MaxSize sets the IPv4 GRO maximum size of the link device.\n// Equivalent to: `ip link set $link gro_ipv4_max_size $maxSize`\nfunc (h *Handle) LinkSetGROIPv4MaxSize(link Link, maxSize int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(maxSize))\n\n\tdata := nl.NewRtAttr(unix.IFLA_GRO_IPV4_MAX_SIZE, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc boolAttr(val bool) []byte {\n\tvar v uint8\n\tif val {\n\t\tv = 1\n\t}\n\treturn nl.Uint8Attr(v)\n}\n\ntype vxlanPortRange struct {\n\tLo, Hi uint16\n}\n\nfunc addVxlanAttrs(vxlan *Vxlan, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\tif vxlan.FlowBased {\n\t\tvxlan.VxlanId = 0\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_VXLAN_ID, nl.Uint32Attr(uint32(vxlan.VxlanId)))\n\n\tif vxlan.VtepDevIndex != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_VXLAN_LINK, nl.Uint32Attr(uint32(vxlan.VtepDevIndex)))\n\t}\n\tif vxlan.SrcAddr != nil {\n\t\tip := vxlan.SrcAddr.To4()\n\t\tif ip != nil {\n\t\t\tdata.AddRtAttr(nl.IFLA_VXLAN_LOCAL, []byte(ip))\n\t\t} else {\n\t\t\tip = vxlan.SrcAddr.To16()\n\t\t\tif ip != nil {\n\t\t\t\tdata.AddRtAttr(nl.IFLA_VXLAN_LOCAL6, []byte(ip))\n\t\t\t}\n\t\t}\n\t}\n\tif vxlan.Group != nil {\n\t\tgroup := vxlan.Group.To4()\n\t\tif group != nil {\n\t\t\tdata.AddRtAttr(nl.IFLA_VXLAN_GROUP, []byte(group))\n\t\t} else {\n\t\t\tgroup = vxlan.Group.To16()\n\t\t\tif group != nil {\n\t\t\t\tdata.AddRtAttr(nl.IFLA_VXLAN_GROUP6, []byte(group))\n\t\t\t}\n\t\t}\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_VXLAN_TTL, nl.Uint8Attr(uint8(vxlan.TTL)))\n\tdata.AddRtAttr(nl.IFLA_VXLAN_TOS, nl.Uint8Attr(uint8(vxlan.TOS)))\n\tdata.AddRtAttr(nl.IFLA_VXLAN_LEARNING, boolAttr(vxlan.Learning))\n\tdata.AddRtAttr(nl.IFLA_VXLAN_PROXY, boolAttr(vxlan.Proxy))\n\tdata.AddRtAttr(nl.IFLA_VXLAN_RSC, boolAttr(vxlan.RSC))\n\tdata.AddRtAttr(nl.IFLA_VXLAN_L2MISS, boolAttr(vxlan.L2miss))\n\tdata.AddRtAttr(nl.IFLA_VXLAN_L3MISS, boolAttr(vxlan.L3miss))\n\tdata.AddRtAttr(nl.IFLA_VXLAN_UDP_ZERO_CSUM6_TX, boolAttr(vxlan.UDP6ZeroCSumTx))\n\tdata.AddRtAttr(nl.IFLA_VXLAN_UDP_ZERO_CSUM6_RX, boolAttr(vxlan.UDP6ZeroCSumRx))\n\n\tif vxlan.UDPCSum {\n\t\tdata.AddRtAttr(nl.IFLA_VXLAN_UDP_CSUM, boolAttr(vxlan.UDPCSum))\n\t}\n\tif vxlan.GBP {\n\t\tdata.AddRtAttr(nl.IFLA_VXLAN_GBP, []byte{})\n\t}\n\tif vxlan.FlowBased {\n\t\tdata.AddRtAttr(nl.IFLA_VXLAN_FLOWBASED, boolAttr(vxlan.FlowBased))\n\t}\n\tif vxlan.NoAge {\n\t\tdata.AddRtAttr(nl.IFLA_VXLAN_AGEING, nl.Uint32Attr(0))\n\t} else if vxlan.Age > 0 {\n\t\tdata.AddRtAttr(nl.IFLA_VXLAN_AGEING, nl.Uint32Attr(uint32(vxlan.Age)))\n\t}\n\tif vxlan.Limit > 0 {\n\t\tdata.AddRtAttr(nl.IFLA_VXLAN_LIMIT, nl.Uint32Attr(uint32(vxlan.Limit)))\n\t}\n\tif vxlan.Port > 0 {\n\t\tdata.AddRtAttr(nl.IFLA_VXLAN_PORT, htons(uint16(vxlan.Port)))\n\t}\n\tif vxlan.PortLow > 0 || vxlan.PortHigh > 0 {\n\t\tpr := vxlanPortRange{uint16(vxlan.PortLow), uint16(vxlan.PortHigh)}\n\n\t\tbuf := new(bytes.Buffer)\n\t\tbinary.Write(buf, binary.BigEndian, &pr)\n\n\t\tdata.AddRtAttr(nl.IFLA_VXLAN_PORT_RANGE, buf.Bytes())\n\t}\n}\n\nfunc addBondAttrs(bond *Bond, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\tif bond.Mode >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_MODE, nl.Uint8Attr(uint8(bond.Mode)))\n\t}\n\tif bond.ActiveSlave >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_ACTIVE_SLAVE, nl.Uint32Attr(uint32(bond.ActiveSlave)))\n\t}\n\tif bond.Miimon >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_MIIMON, nl.Uint32Attr(uint32(bond.Miimon)))\n\t}\n\tif bond.UpDelay >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_UPDELAY, nl.Uint32Attr(uint32(bond.UpDelay)))\n\t}\n\tif bond.DownDelay >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_DOWNDELAY, nl.Uint32Attr(uint32(bond.DownDelay)))\n\t}\n\tif bond.UseCarrier >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_USE_CARRIER, nl.Uint8Attr(uint8(bond.UseCarrier)))\n\t}\n\tif bond.ArpInterval >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_ARP_INTERVAL, nl.Uint32Attr(uint32(bond.ArpInterval)))\n\t}\n\tif bond.ArpIpTargets != nil {\n\t\tmsg := data.AddRtAttr(nl.IFLA_BOND_ARP_IP_TARGET, nil)\n\t\tfor i := range bond.ArpIpTargets {\n\t\t\tip := bond.ArpIpTargets[i].To4()\n\t\t\tif ip != nil {\n\t\t\t\tmsg.AddRtAttr(i, []byte(ip))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = bond.ArpIpTargets[i].To16()\n\t\t\tif ip != nil {\n\t\t\t\tmsg.AddRtAttr(i, []byte(ip))\n\t\t\t}\n\t\t}\n\t}\n\tif bond.ArpValidate >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_ARP_VALIDATE, nl.Uint32Attr(uint32(bond.ArpValidate)))\n\t}\n\tif bond.ArpAllTargets >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_ARP_ALL_TARGETS, nl.Uint32Attr(uint32(bond.ArpAllTargets)))\n\t}\n\tif bond.Primary >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_PRIMARY, nl.Uint32Attr(uint32(bond.Primary)))\n\t}\n\tif bond.PrimaryReselect >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_PRIMARY_RESELECT, nl.Uint8Attr(uint8(bond.PrimaryReselect)))\n\t}\n\tif bond.FailOverMac >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_FAIL_OVER_MAC, nl.Uint8Attr(uint8(bond.FailOverMac)))\n\t}\n\tif bond.XmitHashPolicy >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_XMIT_HASH_POLICY, nl.Uint8Attr(uint8(bond.XmitHashPolicy)))\n\t}\n\tif bond.ResendIgmp >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_RESEND_IGMP, nl.Uint32Attr(uint32(bond.ResendIgmp)))\n\t}\n\tif bond.NumPeerNotif >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_NUM_PEER_NOTIF, nl.Uint8Attr(uint8(bond.NumPeerNotif)))\n\t}\n\tif bond.AllSlavesActive >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_ALL_SLAVES_ACTIVE, nl.Uint8Attr(uint8(bond.AllSlavesActive)))\n\t}\n\tif bond.MinLinks >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_MIN_LINKS, nl.Uint32Attr(uint32(bond.MinLinks)))\n\t}\n\tif bond.LpInterval >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_LP_INTERVAL, nl.Uint32Attr(uint32(bond.LpInterval)))\n\t}\n\tif bond.PacketsPerSlave >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_PACKETS_PER_SLAVE, nl.Uint32Attr(uint32(bond.PacketsPerSlave)))\n\t}\n\tif bond.LacpRate >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_AD_LACP_RATE, nl.Uint8Attr(uint8(bond.LacpRate)))\n\t}\n\tif bond.AdSelect >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_AD_SELECT, nl.Uint8Attr(uint8(bond.AdSelect)))\n\t}\n\tif bond.AdActorSysPrio >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_AD_ACTOR_SYS_PRIO, nl.Uint16Attr(uint16(bond.AdActorSysPrio)))\n\t}\n\tif bond.AdUserPortKey >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_AD_USER_PORT_KEY, nl.Uint16Attr(uint16(bond.AdUserPortKey)))\n\t}\n\tif bond.AdActorSystem != nil {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_AD_ACTOR_SYSTEM, []byte(bond.AdActorSystem))\n\t}\n\tif bond.TlbDynamicLb >= 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_TLB_DYNAMIC_LB, nl.Uint8Attr(uint8(bond.TlbDynamicLb)))\n\t}\n}\n\nfunc cleanupFds(fds []*os.File) {\n\tfor _, f := range fds {\n\t\tf.Close()\n\t}\n}\n\n// LinkAdd adds a new link device. The type and features of the device\n// are taken from the parameters in the link object.\n// Equivalent to: `ip link add $link`\nfunc LinkAdd(link Link) error {\n\treturn pkgHandle.LinkAdd(link)\n}\n\n// LinkAdd adds a new link device. The type and features of the device\n// are taken from the parameters in the link object.\n// Equivalent to: `ip link add $link`\nfunc (h *Handle) LinkAdd(link Link) error {\n\treturn h.linkModify(link, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n}\n\nfunc LinkModify(link Link) error {\n\treturn pkgHandle.LinkModify(link)\n}\n\nfunc (h *Handle) LinkModify(link Link) error {\n\treturn h.linkModify(link, unix.NLM_F_REQUEST|unix.NLM_F_ACK)\n}\n\nfunc (h *Handle) linkModify(link Link, flags int) error {\n\t// TODO: support extra data for macvlan\n\tbase := link.Attrs()\n\n\t// if tuntap, then the name can be empty, OS will provide a name\n\ttuntap, isTuntap := link.(*Tuntap)\n\n\tif base.Name == \"\" && !isTuntap {\n\t\treturn fmt.Errorf(\"LinkAttrs.Name cannot be empty\")\n\t}\n\n\tif isTuntap {\n\t\tif tuntap.Mode < unix.IFF_TUN || tuntap.Mode > unix.IFF_TAP {\n\t\t\treturn fmt.Errorf(\"Tuntap.Mode %v unknown\", tuntap.Mode)\n\t\t}\n\n\t\tqueues := tuntap.Queues\n\n\t\tvar fds []*os.File\n\t\tvar req ifReq\n\t\tcopy(req.Name[:15], base.Name)\n\n\t\treq.Flags = uint16(tuntap.Flags)\n\n\t\tif queues == 0 { //Legacy compatibility\n\t\t\tqueues = 1\n\t\t\tif tuntap.Flags == 0 {\n\t\t\t\treq.Flags = uint16(TUNTAP_DEFAULTS)\n\t\t\t}\n\t\t} else {\n\t\t\t// For best peformance set Flags to TUNTAP_MULTI_QUEUE_DEFAULTS | TUNTAP_VNET_HDR\n\t\t\t// when a) KVM has support for this ABI and\n\t\t\t//      b) the value of the flag is queryable using the TUNGETIFF ioctl\n\t\t\tif tuntap.Flags == 0 {\n\t\t\t\treq.Flags = uint16(TUNTAP_MULTI_QUEUE_DEFAULTS)\n\t\t\t}\n\t\t}\n\n\t\treq.Flags |= uint16(tuntap.Mode)\n\t\tconst TUN = \"/dev/net/tun\"\n\t\tfor i := 0; i < queues; i++ {\n\t\t\tlocalReq := req\n\t\t\tfd, err := unix.Open(TUN, os.O_RDWR|syscall.O_CLOEXEC, 0)\n\t\t\tif err != nil {\n\t\t\t\tcleanupFds(fds)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, _, errno := unix.Syscall(unix.SYS_IOCTL, uintptr(fd), uintptr(unix.TUNSETIFF), uintptr(unsafe.Pointer(&localReq)))\n\t\t\tif errno != 0 {\n\t\t\t\t// close the new fd\n\t\t\t\tunix.Close(fd)\n\t\t\t\t// and the already opened ones\n\t\t\t\tcleanupFds(fds)\n\t\t\t\treturn fmt.Errorf(\"Tuntap IOCTL TUNSETIFF failed [%d], errno %v\", i, errno)\n\t\t\t}\n\n\t\t\t_, _, errno = syscall.Syscall(syscall.SYS_IOCTL, uintptr(fd), syscall.TUNSETOWNER, uintptr(tuntap.Owner))\n\t\t\tif errno != 0 {\n\t\t\t\tcleanupFds(fds)\n\t\t\t\treturn fmt.Errorf(\"Tuntap IOCTL TUNSETOWNER failed [%d], errno %v\", i, errno)\n\t\t\t}\n\n\t\t\t_, _, errno = syscall.Syscall(syscall.SYS_IOCTL, uintptr(fd), syscall.TUNSETGROUP, uintptr(tuntap.Group))\n\t\t\tif errno != 0 {\n\t\t\t\tcleanupFds(fds)\n\t\t\t\treturn fmt.Errorf(\"Tuntap IOCTL TUNSETGROUP failed [%d], errno %v\", i, errno)\n\t\t\t}\n\n\t\t\t// Set the tun device to non-blocking before use. The below comment\n\t\t\t// taken from:\n\t\t\t//\n\t\t\t// https://github.com/mistsys/tuntap/commit/161418c25003bbee77d085a34af64d189df62bea\n\t\t\t//\n\t\t\t// Note there is a complication because in go, if a device node is\n\t\t\t// opened, go sets it to use nonblocking I/O. However a /dev/net/tun\n\t\t\t// doesn't work with epoll until after the TUNSETIFF ioctl has been\n\t\t\t// done. So we open the unix fd directly, do the ioctl, then put the\n\t\t\t// fd in nonblocking mode, an then finally wrap it in a os.File,\n\t\t\t// which will see the nonblocking mode and add the fd to the\n\t\t\t// pollable set, so later on when we Read() from it blocked the\n\t\t\t// calling thread in the kernel.\n\t\t\t//\n\t\t\t// See\n\t\t\t//   https://github.com/golang/go/issues/30426\n\t\t\t// which got exposed in go 1.13 by the fix to\n\t\t\t//   https://github.com/golang/go/issues/30624\n\t\t\terr = unix.SetNonblock(fd, true)\n\t\t\tif err != nil {\n\t\t\t\tcleanupFds(fds)\n\t\t\t\treturn fmt.Errorf(\"Tuntap set to non-blocking failed [%d], err %v\", i, err)\n\t\t\t}\n\n\t\t\t// create the file from the file descriptor and store it\n\t\t\tfile := os.NewFile(uintptr(fd), TUN)\n\t\t\tfds = append(fds, file)\n\n\t\t\t// 1) we only care for the name of the first tap in the multi queue set\n\t\t\t// 2) if the original name was empty, the localReq has now the actual name\n\t\t\t//\n\t\t\t// In addition:\n\t\t\t// This ensures that the link name is always identical to what the kernel returns.\n\t\t\t// Not only in case of an empty name, but also when using name templates.\n\t\t\t// e.g. when the provided name is \"tap%d\", the kernel replaces %d with the next available number.\n\t\t\tif i == 0 {\n\t\t\t\tlink.Attrs().Name = strings.Trim(string(localReq.Name[:]), \"\\x00\")\n\t\t\t}\n\n\t\t}\n\n\t\tcontrol := func(file *os.File, f func(fd uintptr)) error {\n\t\t\tname := file.Name()\n\t\t\tconn, err := file.SyscallConn()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"SyscallConn() failed on %s: %v\", name, err)\n\t\t\t}\n\t\t\tif err := conn.Control(f); err != nil {\n\t\t\t\treturn fmt.Errorf(\"Failed to get file descriptor for %s: %v\", name, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// only persist interface if NonPersist is NOT set\n\t\tif !tuntap.NonPersist {\n\t\t\tvar errno syscall.Errno\n\t\t\tif err := control(fds[0], func(fd uintptr) {\n\t\t\t\t_, _, errno = unix.Syscall(unix.SYS_IOCTL, fd, uintptr(unix.TUNSETPERSIST), 1)\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif errno != 0 {\n\t\t\t\tcleanupFds(fds)\n\t\t\t\treturn fmt.Errorf(\"Tuntap IOCTL TUNSETPERSIST failed, errno %v\", errno)\n\t\t\t}\n\t\t}\n\n\t\th.ensureIndex(base)\n\n\t\t// can't set master during create, so set it afterwards\n\t\tif base.MasterIndex != 0 {\n\t\t\t// TODO: verify MasterIndex is actually a bridge?\n\t\t\terr := h.LinkSetMasterByIndex(link, base.MasterIndex)\n\t\t\tif err != nil {\n\t\t\t\t// un-persist (e.g. allow the interface to be removed) the tuntap\n\t\t\t\t// should not hurt if not set prior, condition might be not needed\n\t\t\t\tif !tuntap.NonPersist {\n\t\t\t\t\t// ignore error\n\t\t\t\t\t_ = control(fds[0], func(fd uintptr) {\n\t\t\t\t\t\t_, _, _ = unix.Syscall(unix.SYS_IOCTL, fd, uintptr(unix.TUNSETPERSIST), 0)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tcleanupFds(fds)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif tuntap.Queues == 0 {\n\t\t\tcleanupFds(fds)\n\t\t} else {\n\t\t\ttuntap.Fds = fds\n\t\t}\n\n\t\treturn nil\n\t}\n\n\treq := h.newNetlinkRequest(unix.RTM_NEWLINK, flags)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\t// TODO: make it shorter\n\tif base.Flags&net.FlagUp != 0 {\n\t\tmsg.Change = unix.IFF_UP\n\t\tmsg.Flags = unix.IFF_UP\n\t}\n\tif base.Flags&net.FlagBroadcast != 0 {\n\t\tmsg.Change |= unix.IFF_BROADCAST\n\t\tmsg.Flags |= unix.IFF_BROADCAST\n\t}\n\tif base.Flags&net.FlagLoopback != 0 {\n\t\tmsg.Change |= unix.IFF_LOOPBACK\n\t\tmsg.Flags |= unix.IFF_LOOPBACK\n\t}\n\tif base.Flags&net.FlagPointToPoint != 0 {\n\t\tmsg.Change |= unix.IFF_POINTOPOINT\n\t\tmsg.Flags |= unix.IFF_POINTOPOINT\n\t}\n\tif base.Flags&net.FlagMulticast != 0 {\n\t\tmsg.Change |= unix.IFF_MULTICAST\n\t\tmsg.Flags |= unix.IFF_MULTICAST\n\t}\n\tif base.Index != 0 {\n\t\tmsg.Index = int32(base.Index)\n\t}\n\n\treq.AddData(msg)\n\n\tif base.ParentIndex != 0 {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(base.ParentIndex))\n\t\tdata := nl.NewRtAttr(unix.IFLA_LINK, b)\n\t\treq.AddData(data)\n\t} else if link.Type() == \"ipvlan\" || link.Type() == \"ipoib\" {\n\t\treturn fmt.Errorf(\"Can't create %s link without ParentIndex\", link.Type())\n\t}\n\n\tnameData := nl.NewRtAttr(unix.IFLA_IFNAME, nl.ZeroTerminated(base.Name))\n\treq.AddData(nameData)\n\n\tif base.Alias != \"\" {\n\t\talias := nl.NewRtAttr(unix.IFLA_IFALIAS, []byte(base.Alias))\n\t\treq.AddData(alias)\n\t}\n\n\tif base.MTU > 0 {\n\t\tmtu := nl.NewRtAttr(unix.IFLA_MTU, nl.Uint32Attr(uint32(base.MTU)))\n\t\treq.AddData(mtu)\n\t}\n\n\tif base.TxQLen >= 0 {\n\t\tqlen := nl.NewRtAttr(unix.IFLA_TXQLEN, nl.Uint32Attr(uint32(base.TxQLen)))\n\t\treq.AddData(qlen)\n\t}\n\n\tif base.HardwareAddr != nil {\n\t\thwaddr := nl.NewRtAttr(unix.IFLA_ADDRESS, []byte(base.HardwareAddr))\n\t\treq.AddData(hwaddr)\n\t}\n\n\tif base.NumTxQueues > 0 {\n\t\ttxqueues := nl.NewRtAttr(unix.IFLA_NUM_TX_QUEUES, nl.Uint32Attr(uint32(base.NumTxQueues)))\n\t\treq.AddData(txqueues)\n\t}\n\n\tif base.NumRxQueues > 0 {\n\t\trxqueues := nl.NewRtAttr(unix.IFLA_NUM_RX_QUEUES, nl.Uint32Attr(uint32(base.NumRxQueues)))\n\t\treq.AddData(rxqueues)\n\t}\n\n\tif base.GSOMaxSegs > 0 {\n\t\tgsoAttr := nl.NewRtAttr(unix.IFLA_GSO_MAX_SEGS, nl.Uint32Attr(base.GSOMaxSegs))\n\t\treq.AddData(gsoAttr)\n\t}\n\n\tif base.GSOMaxSize > 0 {\n\t\tgsoAttr := nl.NewRtAttr(unix.IFLA_GSO_MAX_SIZE, nl.Uint32Attr(base.GSOMaxSize))\n\t\treq.AddData(gsoAttr)\n\t}\n\n\tif base.GROMaxSize > 0 {\n\t\tgroAttr := nl.NewRtAttr(unix.IFLA_GRO_MAX_SIZE, nl.Uint32Attr(base.GROMaxSize))\n\t\treq.AddData(groAttr)\n\t}\n\n\tif base.GSOIPv4MaxSize > 0 {\n\t\tgsoAttr := nl.NewRtAttr(unix.IFLA_GSO_IPV4_MAX_SIZE, nl.Uint32Attr(base.GSOIPv4MaxSize))\n\t\treq.AddData(gsoAttr)\n\t}\n\n\tif base.GROIPv4MaxSize > 0 {\n\t\tgroAttr := nl.NewRtAttr(unix.IFLA_GRO_IPV4_MAX_SIZE, nl.Uint32Attr(base.GROIPv4MaxSize))\n\t\treq.AddData(groAttr)\n\t}\n\n\tif base.Group > 0 {\n\t\tgroupAttr := nl.NewRtAttr(unix.IFLA_GROUP, nl.Uint32Attr(base.Group))\n\t\treq.AddData(groupAttr)\n\t}\n\n\tif base.Namespace != nil {\n\t\tvar attr *nl.RtAttr\n\t\tswitch ns := base.Namespace.(type) {\n\t\tcase NsPid:\n\t\t\tval := nl.Uint32Attr(uint32(ns))\n\t\t\tattr = nl.NewRtAttr(unix.IFLA_NET_NS_PID, val)\n\t\tcase NsFd:\n\t\t\tval := nl.Uint32Attr(uint32(ns))\n\t\t\tattr = nl.NewRtAttr(unix.IFLA_NET_NS_FD, val)\n\t\t}\n\n\t\treq.AddData(attr)\n\t}\n\n\tif base.Xdp != nil {\n\t\taddXdpAttrs(base.Xdp, req)\n\t}\n\n\tlinkInfo := nl.NewRtAttr(unix.IFLA_LINKINFO, nil)\n\tlinkInfo.AddRtAttr(nl.IFLA_INFO_KIND, nl.NonZeroTerminated(link.Type()))\n\n\tswitch link := link.(type) {\n\tcase *Vlan:\n\t\tb := make([]byte, 2)\n\t\tnative.PutUint16(b, uint16(link.VlanId))\n\t\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\t\tdata.AddRtAttr(nl.IFLA_VLAN_ID, b)\n\n\t\tif link.VlanProtocol != VLAN_PROTOCOL_UNKNOWN {\n\t\t\tdata.AddRtAttr(nl.IFLA_VLAN_PROTOCOL, htons(uint16(link.VlanProtocol)))\n\t\t}\n\tcase *Netkit:\n\t\tif err := addNetkitAttrs(link, linkInfo, flags); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase *Veth:\n\t\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\t\tpeer := data.AddRtAttr(nl.VETH_INFO_PEER, nil)\n\t\tnl.NewIfInfomsgChild(peer, unix.AF_UNSPEC)\n\t\tpeer.AddRtAttr(unix.IFLA_IFNAME, nl.ZeroTerminated(link.PeerName))\n\t\tif base.TxQLen >= 0 {\n\t\t\tpeer.AddRtAttr(unix.IFLA_TXQLEN, nl.Uint32Attr(uint32(base.TxQLen)))\n\t\t}\n\t\tif base.NumTxQueues > 0 {\n\t\t\tpeer.AddRtAttr(unix.IFLA_NUM_TX_QUEUES, nl.Uint32Attr(uint32(base.NumTxQueues)))\n\t\t}\n\t\tif base.NumRxQueues > 0 {\n\t\t\tpeer.AddRtAttr(unix.IFLA_NUM_RX_QUEUES, nl.Uint32Attr(uint32(base.NumRxQueues)))\n\t\t}\n\t\tif base.MTU > 0 {\n\t\t\tpeer.AddRtAttr(unix.IFLA_MTU, nl.Uint32Attr(uint32(base.MTU)))\n\t\t}\n\t\tif link.PeerHardwareAddr != nil {\n\t\t\tpeer.AddRtAttr(unix.IFLA_ADDRESS, []byte(link.PeerHardwareAddr))\n\t\t}\n\t\tif link.PeerNamespace != nil {\n\t\t\tswitch ns := link.PeerNamespace.(type) {\n\t\t\tcase NsPid:\n\t\t\t\tval := nl.Uint32Attr(uint32(ns))\n\t\t\t\tpeer.AddRtAttr(unix.IFLA_NET_NS_PID, val)\n\t\t\tcase NsFd:\n\t\t\t\tval := nl.Uint32Attr(uint32(ns))\n\t\t\t\tpeer.AddRtAttr(unix.IFLA_NET_NS_FD, val)\n\t\t\t}\n\t\t}\n\tcase *Vxlan:\n\t\taddVxlanAttrs(link, linkInfo)\n\tcase *Bond:\n\t\taddBondAttrs(link, linkInfo)\n\tcase *IPVlan:\n\t\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\t\tdata.AddRtAttr(nl.IFLA_IPVLAN_MODE, nl.Uint16Attr(uint16(link.Mode)))\n\t\tdata.AddRtAttr(nl.IFLA_IPVLAN_FLAG, nl.Uint16Attr(uint16(link.Flag)))\n\tcase *IPVtap:\n\t\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\t\tdata.AddRtAttr(nl.IFLA_IPVLAN_MODE, nl.Uint16Attr(uint16(link.Mode)))\n\t\tdata.AddRtAttr(nl.IFLA_IPVLAN_FLAG, nl.Uint16Attr(uint16(link.Flag)))\n\tcase *Macvlan:\n\t\taddMacvlanAttrs(link, linkInfo)\n\tcase *Macvtap:\n\t\taddMacvtapAttrs(link, linkInfo)\n\tcase *Geneve:\n\t\taddGeneveAttrs(link, linkInfo)\n\tcase *Gretap:\n\t\taddGretapAttrs(link, linkInfo)\n\tcase *Iptun:\n\t\taddIptunAttrs(link, linkInfo)\n\tcase *Ip6tnl:\n\t\taddIp6tnlAttrs(link, linkInfo)\n\tcase *Sittun:\n\t\taddSittunAttrs(link, linkInfo)\n\tcase *Gretun:\n\t\taddGretunAttrs(link, linkInfo)\n\tcase *Vti:\n\t\taddVtiAttrs(link, linkInfo)\n\tcase *Vrf:\n\t\taddVrfAttrs(link, linkInfo)\n\tcase *Bridge:\n\t\taddBridgeAttrs(link, linkInfo)\n\tcase *GTP:\n\t\taddGTPAttrs(link, linkInfo)\n\tcase *Xfrmi:\n\t\taddXfrmiAttrs(link, linkInfo)\n\tcase *IPoIB:\n\t\taddIPoIBAttrs(link, linkInfo)\n\tcase *BareUDP:\n\t\taddBareUDPAttrs(link, linkInfo)\n\t}\n\n\treq.AddData(linkInfo)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\th.ensureIndex(base)\n\n\t// can't set master during create, so set it afterwards\n\tif base.MasterIndex != 0 {\n\t\t// TODO: verify MasterIndex is actually a bridge?\n\t\treturn h.LinkSetMasterByIndex(link, base.MasterIndex)\n\t}\n\treturn nil\n}\n\n// LinkDel deletes link device. Either Index or Name must be set in\n// the link object for it to be deleted. The other values are ignored.\n// Equivalent to: `ip link del $link`\nfunc LinkDel(link Link) error {\n\treturn pkgHandle.LinkDel(link)\n}\n\n// LinkDel deletes link device. Either Index or Name must be set in\n// the link object for it to be deleted. The other values are ignored.\n// Equivalent to: `ip link del $link`\nfunc (h *Handle) LinkDel(link Link) error {\n\tbase := link.Attrs()\n\n\th.ensureIndex(base)\n\n\treq := h.newNetlinkRequest(unix.RTM_DELLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc (h *Handle) linkByNameDump(name string) (Link, error) {\n\tlinks, executeErr := h.LinkList()\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tfor _, link := range links {\n\t\tif link.Attrs().Name == name {\n\t\t\treturn link, executeErr\n\t\t}\n\n\t\t// support finding interfaces also via altnames\n\t\tfor _, altName := range link.Attrs().AltNames {\n\t\t\tif altName == name {\n\t\t\t\treturn link, executeErr\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, LinkNotFoundError{fmt.Errorf(\"Link %s not found\", name)}\n}\n\nfunc (h *Handle) linkByAliasDump(alias string) (Link, error) {\n\tlinks, executeErr := h.LinkList()\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tfor _, link := range links {\n\t\tif link.Attrs().Alias == alias {\n\t\t\treturn link, executeErr\n\t\t}\n\t}\n\treturn nil, LinkNotFoundError{fmt.Errorf(\"Link alias %s not found\", alias)}\n}\n\n// LinkByName finds a link by name and returns a pointer to the object.\n//\n// If the kernel doesn't support IFLA_IFNAME, this method will fall back to\n// filtering a dump of all link names. In this case, if the returned error is\n// [ErrDumpInterrupted] the result may be missing or outdated.\nfunc LinkByName(name string) (Link, error) {\n\treturn pkgHandle.LinkByName(name)\n}\n\n// LinkByName finds a link by name and returns a pointer to the object.\n//\n// If the kernel doesn't support IFLA_IFNAME, this method will fall back to\n// filtering a dump of all link names. In this case, if the returned error is\n// [ErrDumpInterrupted] the result may be missing or outdated.\nfunc (h *Handle) LinkByName(name string) (Link, error) {\n\tif h.lookupByDump {\n\t\treturn h.linkByNameDump(name)\n\t}\n\n\treq := h.newNetlinkRequest(unix.RTM_GETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\treq.AddData(msg)\n\n\tattr := nl.NewRtAttr(unix.IFLA_EXT_MASK, nl.Uint32Attr(nl.RTEXT_FILTER_VF))\n\treq.AddData(attr)\n\n\tnameData := nl.NewRtAttr(unix.IFLA_IFNAME, nl.ZeroTerminated(name))\n\tif len(name) > 15 {\n\t\tnameData = nl.NewRtAttr(unix.IFLA_ALT_IFNAME, nl.ZeroTerminated(name))\n\t}\n\treq.AddData(nameData)\n\n\tlink, err := execGetLink(req)\n\tif err == unix.EINVAL {\n\t\t// older kernels don't support looking up via IFLA_IFNAME\n\t\t// so fall back to dumping all links\n\t\th.lookupByDump = true\n\t\treturn h.linkByNameDump(name)\n\t}\n\n\treturn link, err\n}\n\n// LinkByAlias finds a link by its alias and returns a pointer to the object.\n// If there are multiple links with the alias it returns the first one\n//\n// If the kernel doesn't support IFLA_IFALIAS, this method will fall back to\n// filtering a dump of all link names. In this case, if the returned error is\n// [ErrDumpInterrupted] the result may be missing or outdated.\nfunc LinkByAlias(alias string) (Link, error) {\n\treturn pkgHandle.LinkByAlias(alias)\n}\n\n// LinkByAlias finds a link by its alias and returns a pointer to the object.\n// If there are multiple links with the alias it returns the first one\n//\n// If the kernel doesn't support IFLA_IFALIAS, this method will fall back to\n// filtering a dump of all link names. In this case, if the returned error is\n// [ErrDumpInterrupted] the result may be missing or outdated.\nfunc (h *Handle) LinkByAlias(alias string) (Link, error) {\n\tif h.lookupByDump {\n\t\treturn h.linkByAliasDump(alias)\n\t}\n\n\treq := h.newNetlinkRequest(unix.RTM_GETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\treq.AddData(msg)\n\n\tattr := nl.NewRtAttr(unix.IFLA_EXT_MASK, nl.Uint32Attr(nl.RTEXT_FILTER_VF))\n\treq.AddData(attr)\n\n\tnameData := nl.NewRtAttr(unix.IFLA_IFALIAS, nl.ZeroTerminated(alias))\n\treq.AddData(nameData)\n\n\tlink, err := execGetLink(req)\n\tif err == unix.EINVAL {\n\t\t// older kernels don't support looking up via IFLA_IFALIAS\n\t\t// so fall back to dumping all links\n\t\th.lookupByDump = true\n\t\treturn h.linkByAliasDump(alias)\n\t}\n\n\treturn link, err\n}\n\n// LinkByIndex finds a link by index and returns a pointer to the object.\nfunc LinkByIndex(index int) (Link, error) {\n\treturn pkgHandle.LinkByIndex(index)\n}\n\n// LinkByIndex finds a link by index and returns a pointer to the object.\nfunc (h *Handle) LinkByIndex(index int) (Link, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(index)\n\treq.AddData(msg)\n\tattr := nl.NewRtAttr(unix.IFLA_EXT_MASK, nl.Uint32Attr(nl.RTEXT_FILTER_VF))\n\treq.AddData(attr)\n\n\treturn execGetLink(req)\n}\n\nfunc execGetLink(req *nl.NetlinkRequest) (Link, error) {\n\tmsgs, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\tif err != nil {\n\t\tif errno, ok := err.(syscall.Errno); ok {\n\t\t\tif errno == unix.ENODEV {\n\t\t\t\treturn nil, LinkNotFoundError{fmt.Errorf(\"Link not found\")}\n\t\t\t}\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tswitch {\n\tcase len(msgs) == 0:\n\t\treturn nil, LinkNotFoundError{fmt.Errorf(\"Link not found\")}\n\n\tcase len(msgs) == 1:\n\t\treturn LinkDeserialize(nil, msgs[0])\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"More than one link found\")\n\t}\n}\n\n// LinkDeserialize deserializes a raw message received from netlink into\n// a link object.\nfunc LinkDeserialize(hdr *unix.NlMsghdr, m []byte) (Link, error) {\n\tmsg := nl.DeserializeIfInfomsg(m)\n\n\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbase := NewLinkAttrs()\n\tbase.Index = int(msg.Index)\n\tbase.RawFlags = msg.Flags\n\tbase.Flags = linkFlags(msg.Flags)\n\tbase.EncapType = msg.EncapType()\n\tbase.NetNsID = -1\n\tif msg.Flags&unix.IFF_ALLMULTI != 0 {\n\t\tbase.Allmulti = 1\n\t}\n\tif msg.Flags&unix.IFF_MULTICAST != 0 {\n\t\tbase.Multi = 1\n\t}\n\n\tvar (\n\t\tlink      Link\n\t\tstats32   *LinkStatistics32\n\t\tstats64   *LinkStatistics64\n\t\tlinkType  string\n\t\tlinkSlave LinkSlave\n\t\tslaveType string\n\t)\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase unix.IFLA_LINKINFO:\n\t\t\tinfos, err := nl.ParseRouteAttr(attr.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfor _, info := range infos {\n\t\t\t\tswitch info.Attr.Type {\n\t\t\t\tcase nl.IFLA_INFO_KIND:\n\t\t\t\t\tlinkType = string(info.Value[:len(info.Value)-1])\n\t\t\t\t\tswitch linkType {\n\t\t\t\t\tcase \"dummy\":\n\t\t\t\t\t\tlink = &Dummy{}\n\t\t\t\t\tcase \"ifb\":\n\t\t\t\t\t\tlink = &Ifb{}\n\t\t\t\t\tcase \"bridge\":\n\t\t\t\t\t\tlink = &Bridge{}\n\t\t\t\t\tcase \"vlan\":\n\t\t\t\t\t\tlink = &Vlan{}\n\t\t\t\t\tcase \"netkit\":\n\t\t\t\t\t\tlink = &Netkit{}\n\t\t\t\t\tcase \"veth\":\n\t\t\t\t\t\tlink = &Veth{}\n\t\t\t\t\tcase \"wireguard\":\n\t\t\t\t\t\tlink = &Wireguard{}\n\t\t\t\t\tcase \"vxlan\":\n\t\t\t\t\t\tlink = &Vxlan{}\n\t\t\t\t\tcase \"bond\":\n\t\t\t\t\t\tlink = &Bond{}\n\t\t\t\t\tcase \"ipvlan\":\n\t\t\t\t\t\tlink = &IPVlan{}\n\t\t\t\t\tcase \"ipvtap\":\n\t\t\t\t\t\tlink = &IPVtap{}\n\t\t\t\t\tcase \"macvlan\":\n\t\t\t\t\t\tlink = &Macvlan{}\n\t\t\t\t\tcase \"macvtap\":\n\t\t\t\t\t\tlink = &Macvtap{}\n\t\t\t\t\tcase \"geneve\":\n\t\t\t\t\t\tlink = &Geneve{}\n\t\t\t\t\tcase \"gretap\":\n\t\t\t\t\t\tlink = &Gretap{}\n\t\t\t\t\tcase \"ip6gretap\":\n\t\t\t\t\t\tlink = &Gretap{}\n\t\t\t\t\tcase \"ipip\":\n\t\t\t\t\t\tlink = &Iptun{}\n\t\t\t\t\tcase \"ip6tnl\":\n\t\t\t\t\t\tlink = &Ip6tnl{}\n\t\t\t\t\tcase \"sit\":\n\t\t\t\t\t\tlink = &Sittun{}\n\t\t\t\t\tcase \"gre\":\n\t\t\t\t\t\tlink = &Gretun{}\n\t\t\t\t\tcase \"ip6gre\":\n\t\t\t\t\t\tlink = &Gretun{}\n\t\t\t\t\tcase \"vti\", \"vti6\":\n\t\t\t\t\t\tlink = &Vti{}\n\t\t\t\t\tcase \"vrf\":\n\t\t\t\t\t\tlink = &Vrf{}\n\t\t\t\t\tcase \"gtp\":\n\t\t\t\t\t\tlink = &GTP{}\n\t\t\t\t\tcase \"xfrm\":\n\t\t\t\t\t\tlink = &Xfrmi{}\n\t\t\t\t\tcase \"tun\":\n\t\t\t\t\t\tlink = &Tuntap{}\n\t\t\t\t\tcase \"ipoib\":\n\t\t\t\t\t\tlink = &IPoIB{}\n\t\t\t\t\tcase \"can\":\n\t\t\t\t\t\tlink = &Can{}\n\t\t\t\t\tcase \"bareudp\":\n\t\t\t\t\t\tlink = &BareUDP{}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlink = &GenericLink{LinkType: linkType}\n\t\t\t\t\t}\n\t\t\t\tcase nl.IFLA_INFO_DATA:\n\t\t\t\t\tdata, err := nl.ParseRouteAttr(info.Value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tswitch linkType {\n\t\t\t\t\tcase \"netkit\":\n\t\t\t\t\t\tparseNetkitData(link, data)\n\t\t\t\t\tcase \"vlan\":\n\t\t\t\t\t\tparseVlanData(link, data)\n\t\t\t\t\tcase \"vxlan\":\n\t\t\t\t\t\tparseVxlanData(link, data)\n\t\t\t\t\tcase \"bond\":\n\t\t\t\t\t\tparseBondData(link, data)\n\t\t\t\t\tcase \"ipvlan\":\n\t\t\t\t\t\tparseIPVlanData(link, data)\n\t\t\t\t\tcase \"ipvtap\":\n\t\t\t\t\t\tparseIPVtapData(link, data)\n\t\t\t\t\tcase \"macvlan\":\n\t\t\t\t\t\tparseMacvlanData(link, data)\n\t\t\t\t\tcase \"macvtap\":\n\t\t\t\t\t\tparseMacvtapData(link, data)\n\t\t\t\t\tcase \"geneve\":\n\t\t\t\t\t\tparseGeneveData(link, data)\n\t\t\t\t\tcase \"gretap\":\n\t\t\t\t\t\tparseGretapData(link, data)\n\t\t\t\t\tcase \"ip6gretap\":\n\t\t\t\t\t\tparseGretapData(link, data)\n\t\t\t\t\tcase \"ipip\":\n\t\t\t\t\t\tparseIptunData(link, data)\n\t\t\t\t\tcase \"ip6tnl\":\n\t\t\t\t\t\tparseIp6tnlData(link, data)\n\t\t\t\t\tcase \"sit\":\n\t\t\t\t\t\tparseSittunData(link, data)\n\t\t\t\t\tcase \"gre\":\n\t\t\t\t\t\tparseGretunData(link, data)\n\t\t\t\t\tcase \"ip6gre\":\n\t\t\t\t\t\tparseGretunData(link, data)\n\t\t\t\t\tcase \"vti\", \"vti6\":\n\t\t\t\t\t\tparseVtiData(link, data)\n\t\t\t\t\tcase \"vrf\":\n\t\t\t\t\t\tparseVrfData(link, data)\n\t\t\t\t\tcase \"bridge\":\n\t\t\t\t\t\tparseBridgeData(link, data)\n\t\t\t\t\tcase \"gtp\":\n\t\t\t\t\t\tparseGTPData(link, data)\n\t\t\t\t\tcase \"xfrm\":\n\t\t\t\t\t\tparseXfrmiData(link, data)\n\t\t\t\t\tcase \"tun\":\n\t\t\t\t\t\tparseTuntapData(link, data)\n\t\t\t\t\tcase \"ipoib\":\n\t\t\t\t\t\tparseIPoIBData(link, data)\n\t\t\t\t\tcase \"can\":\n\t\t\t\t\t\tparseCanData(link, data)\n\t\t\t\t\tcase \"bareudp\":\n\t\t\t\t\t\tparseBareUDPData(link, data)\n\t\t\t\t\t}\n\n\t\t\t\tcase nl.IFLA_INFO_SLAVE_KIND:\n\t\t\t\t\tslaveType = string(info.Value[:len(info.Value)-1])\n\t\t\t\t\tswitch slaveType {\n\t\t\t\t\tcase \"bond\":\n\t\t\t\t\t\tlinkSlave = &BondSlave{}\n\t\t\t\t\tcase \"vrf\":\n\t\t\t\t\t\tlinkSlave = &VrfSlave{}\n\t\t\t\t\t}\n\n\t\t\t\tcase nl.IFLA_INFO_SLAVE_DATA:\n\t\t\t\t\tswitch slaveType {\n\t\t\t\t\tcase \"bond\":\n\t\t\t\t\t\tdata, err := nl.ParseRouteAttr(info.Value)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparseBondSlaveData(linkSlave, data)\n\t\t\t\t\tcase \"vrf\":\n\t\t\t\t\t\tdata, err := nl.ParseRouteAttr(info.Value)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparseVrfSlaveData(linkSlave, data)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase unix.IFLA_ADDRESS:\n\t\t\tvar nonzero bool\n\t\t\tfor _, b := range attr.Value {\n\t\t\t\tif b != 0 {\n\t\t\t\t\tnonzero = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif nonzero {\n\t\t\t\tbase.HardwareAddr = attr.Value[:]\n\t\t\t}\n\t\tcase unix.IFLA_IFNAME:\n\t\t\tbase.Name = string(attr.Value[:len(attr.Value)-1])\n\t\tcase unix.IFLA_MTU:\n\t\t\tbase.MTU = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFLA_PROMISCUITY:\n\t\t\tbase.Promisc = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFLA_LINK:\n\t\t\tbase.ParentIndex = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFLA_MASTER:\n\t\t\tbase.MasterIndex = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFLA_TXQLEN:\n\t\t\tbase.TxQLen = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFLA_IFALIAS:\n\t\t\tbase.Alias = string(attr.Value[:len(attr.Value)-1])\n\t\tcase unix.IFLA_STATS:\n\t\t\tstats32 = new(LinkStatistics32)\n\t\t\tif err := binary.Read(bytes.NewBuffer(attr.Value[:]), nl.NativeEndian(), stats32); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase unix.IFLA_STATS64:\n\t\t\tstats64 = new(LinkStatistics64)\n\t\t\tif err := binary.Read(bytes.NewBuffer(attr.Value[:]), nl.NativeEndian(), stats64); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase unix.IFLA_XDP:\n\t\t\txdp, err := parseLinkXdp(attr.Value[:])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tbase.Xdp = xdp\n\t\tcase unix.IFLA_PROTINFO | unix.NLA_F_NESTED:\n\t\t\tif hdr != nil && hdr.Type == unix.RTM_NEWLINK &&\n\t\t\t\tmsg.Family == unix.AF_BRIDGE {\n\t\t\t\tattrs, err := nl.ParseRouteAttr(attr.Value[:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tprotinfo := parseProtinfo(attrs)\n\t\t\t\tbase.Protinfo = &protinfo\n\t\t\t}\n\t\tcase unix.IFLA_PROP_LIST | unix.NLA_F_NESTED:\n\t\t\tattrs, err := nl.ParseRouteAttr(attr.Value[:])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tbase.AltNames = []string{}\n\t\t\tfor _, attr := range attrs {\n\t\t\t\tif attr.Attr.Type == unix.IFLA_ALT_IFNAME {\n\t\t\t\t\tbase.AltNames = append(base.AltNames, nl.BytesToString(attr.Value))\n\t\t\t\t}\n\t\t\t}\n\t\tcase unix.IFLA_OPERSTATE:\n\t\t\tbase.OperState = LinkOperState(uint8(attr.Value[0]))\n\t\tcase unix.IFLA_PHYS_SWITCH_ID:\n\t\t\tbase.PhysSwitchID = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFLA_LINK_NETNSID:\n\t\t\tbase.NetNsID = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFLA_TSO_MAX_SEGS:\n\t\t\tbase.TSOMaxSegs = native.Uint32(attr.Value[0:4])\n\t\tcase unix.IFLA_TSO_MAX_SIZE:\n\t\t\tbase.TSOMaxSize = native.Uint32(attr.Value[0:4])\n\t\tcase unix.IFLA_GSO_MAX_SEGS:\n\t\t\tbase.GSOMaxSegs = native.Uint32(attr.Value[0:4])\n\t\tcase unix.IFLA_GSO_MAX_SIZE:\n\t\t\tbase.GSOMaxSize = native.Uint32(attr.Value[0:4])\n\t\tcase unix.IFLA_GRO_MAX_SIZE:\n\t\t\tbase.GROMaxSize = native.Uint32(attr.Value[0:4])\n\t\tcase unix.IFLA_GSO_IPV4_MAX_SIZE:\n\t\t\tbase.GSOIPv4MaxSize = native.Uint32(attr.Value[0:4])\n\t\tcase unix.IFLA_GRO_IPV4_MAX_SIZE:\n\t\t\tbase.GROIPv4MaxSize = native.Uint32(attr.Value[0:4])\n\t\tcase unix.IFLA_VFINFO_LIST:\n\t\t\tdata, err := nl.ParseRouteAttr(attr.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tvfs, err := parseVfInfoList(data)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tbase.Vfs = vfs\n\t\tcase unix.IFLA_NUM_TX_QUEUES:\n\t\t\tbase.NumTxQueues = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFLA_NUM_RX_QUEUES:\n\t\t\tbase.NumRxQueues = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.IFLA_GROUP:\n\t\t\tbase.Group = native.Uint32(attr.Value[0:4])\n\t\tcase unix.IFLA_PERM_ADDRESS:\n\t\t\tfor _, b := range attr.Value {\n\t\t\t\tif b != 0 {\n\t\t\t\t\tbase.PermHWAddr = attr.Value[:]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif stats64 != nil {\n\t\tbase.Statistics = (*LinkStatistics)(stats64)\n\t} else if stats32 != nil {\n\t\tbase.Statistics = (*LinkStatistics)(stats32.to64())\n\t}\n\n\t// Links that don't have IFLA_INFO_KIND are hardware devices\n\tif link == nil {\n\t\tlink = &Device{}\n\t}\n\t*link.Attrs() = base\n\tlink.Attrs().Slave = linkSlave\n\n\t// If the tuntap attributes are not updated by netlink due to\n\t// an older driver, use sysfs\n\tif link != nil && linkType == \"tun\" {\n\t\ttuntap := link.(*Tuntap)\n\n\t\tif tuntap.Mode == 0 {\n\t\t\tifname := tuntap.Attrs().Name\n\t\t\tif flags, err := readSysPropAsInt64(ifname, \"tun_flags\"); err == nil {\n\n\t\t\t\tif flags&unix.IFF_TUN != 0 {\n\t\t\t\t\ttuntap.Mode = unix.IFF_TUN\n\t\t\t\t} else if flags&unix.IFF_TAP != 0 {\n\t\t\t\t\ttuntap.Mode = unix.IFF_TAP\n\t\t\t\t}\n\n\t\t\t\ttuntap.NonPersist = false\n\t\t\t\tif flags&unix.IFF_PERSIST == 0 {\n\t\t\t\t\ttuntap.NonPersist = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The sysfs interface for owner/group returns -1 for root user, instead of returning 0.\n\t\t\t// So explicitly check for negative value, before assigning the owner uid/gid.\n\t\t\tif owner, err := readSysPropAsInt64(ifname, \"owner\"); err == nil && owner > 0 {\n\t\t\t\ttuntap.Owner = uint32(owner)\n\t\t\t}\n\n\t\t\tif group, err := readSysPropAsInt64(ifname, \"group\"); err == nil && group > 0 {\n\t\t\t\ttuntap.Group = uint32(group)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn link, nil\n}\n\nfunc readSysPropAsInt64(ifname, prop string) (int64, error) {\n\tfname := fmt.Sprintf(\"/sys/class/net/%s/%s\", ifname, prop)\n\tcontents, err := ioutil.ReadFile(fname)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tnum, err := strconv.ParseInt(strings.TrimSpace(string(contents)), 0, 64)\n\tif err == nil {\n\t\treturn num, nil\n\t}\n\n\treturn 0, err\n}\n\n// LinkList gets a list of link devices.\n// Equivalent to: `ip link show`\nfunc LinkList() ([]Link, error) {\n\treturn pkgHandle.LinkList()\n}\n\n// LinkList gets a list of link devices.\n// Equivalent to: `ip link show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) LinkList() ([]Link, error) {\n\t// NOTE(vish): This duplicates functionality in net/iface_linux.go, but we need\n\t//             to get the message ourselves to parse link type.\n\treq := h.newNetlinkRequest(unix.RTM_GETLINK, unix.NLM_F_DUMP)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\treq.AddData(msg)\n\tattr := nl.NewRtAttr(unix.IFLA_EXT_MASK, nl.Uint32Attr(nl.RTEXT_FILTER_VF))\n\treq.AddData(attr)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWLINK)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res []Link\n\tfor _, m := range msgs {\n\t\tlink, err := LinkDeserialize(nil, m)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres = append(res, link)\n\t}\n\n\treturn res, executeErr\n}\n\n// LinkUpdate is used to pass information back from LinkSubscribe()\ntype LinkUpdate struct {\n\tnl.IfInfomsg\n\tHeader unix.NlMsghdr\n\tLink\n}\n\n// LinkSubscribe takes a chan down which notifications will be sent\n// when links change.  Close the 'done' chan to stop subscription.\nfunc LinkSubscribe(ch chan<- LinkUpdate, done <-chan struct{}) error {\n\treturn linkSubscribeAt(netns.None(), netns.None(), ch, done, nil, false, 0, nil, false)\n}\n\n// LinkSubscribeAt works like LinkSubscribe plus it allows the caller\n// to choose the network namespace in which to subscribe (ns).\nfunc LinkSubscribeAt(ns netns.NsHandle, ch chan<- LinkUpdate, done <-chan struct{}) error {\n\treturn linkSubscribeAt(ns, netns.None(), ch, done, nil, false, 0, nil, false)\n}\n\n// LinkSubscribeOptions contains a set of options to use with\n// LinkSubscribeWithOptions.\ntype LinkSubscribeOptions struct {\n\tNamespace              *netns.NsHandle\n\tErrorCallback          func(error)\n\tListExisting           bool\n\tReceiveBufferSize      int\n\tReceiveBufferForceSize bool\n\tReceiveTimeout         *unix.Timeval\n}\n\n// LinkSubscribeWithOptions work like LinkSubscribe but enable to\n// provide additional options to modify the behavior. Currently, the\n// namespace can be provided as well as an error callback.\n//\n// When options.ListExisting is true, options.ErrorCallback may be\n// called with [ErrDumpInterrupted] to indicate that results from\n// the initial dump of links may be inconsistent or incomplete.\nfunc LinkSubscribeWithOptions(ch chan<- LinkUpdate, done <-chan struct{}, options LinkSubscribeOptions) error {\n\tif options.Namespace == nil {\n\t\tnone := netns.None()\n\t\toptions.Namespace = &none\n\t}\n\treturn linkSubscribeAt(*options.Namespace, netns.None(), ch, done, options.ErrorCallback, options.ListExisting,\n\t\toptions.ReceiveBufferSize, options.ReceiveTimeout, options.ReceiveBufferForceSize)\n}\n\nfunc linkSubscribeAt(newNs, curNs netns.NsHandle, ch chan<- LinkUpdate, done <-chan struct{}, cberr func(error), listExisting bool,\n\trcvbuf int, rcvTimeout *unix.Timeval, rcvbufForce bool) error {\n\ts, err := nl.SubscribeAt(newNs, curNs, unix.NETLINK_ROUTE, unix.RTNLGRP_LINK)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif rcvTimeout != nil {\n\t\tif err := s.SetReceiveTimeout(rcvTimeout); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif rcvbuf != 0 {\n\t\terr = s.SetReceiveBufferSize(rcvbuf, rcvbufForce)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif done != nil {\n\t\tgo func() {\n\t\t\t<-done\n\t\t\ts.Close()\n\t\t}()\n\t}\n\tif listExisting {\n\t\treq := pkgHandle.newNetlinkRequest(unix.RTM_GETLINK,\n\t\t\tunix.NLM_F_DUMP)\n\t\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\t\treq.AddData(msg)\n\t\tif err := s.Send(req); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor {\n\t\t\tmsgs, from, err := s.Receive()\n\t\t\tif err != nil {\n\t\t\t\tif cberr != nil {\n\t\t\t\t\tcberr(fmt.Errorf(\"Receive failed: %v\",\n\t\t\t\t\t\terr))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif from.Pid != nl.PidKernel {\n\t\t\t\tif cberr != nil {\n\t\t\t\t\tcberr(fmt.Errorf(\"Wrong sender portid %d, expected %d\", from.Pid, nl.PidKernel))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, m := range msgs {\n\t\t\t\tif m.Header.Flags&unix.NLM_F_DUMP_INTR != 0 && cberr != nil {\n\t\t\t\t\tcberr(ErrDumpInterrupted)\n\t\t\t\t}\n\t\t\t\tif m.Header.Type == unix.NLMSG_DONE {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif m.Header.Type == unix.NLMSG_ERROR {\n\t\t\t\t\terror := int32(native.Uint32(m.Data[0:4]))\n\t\t\t\t\tif error == 0 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\tcberr(fmt.Errorf(\"error message: %v\",\n\t\t\t\t\t\t\tsyscall.Errno(-error)))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tifmsg := nl.DeserializeIfInfomsg(m.Data)\n\t\t\t\theader := unix.NlMsghdr(m.Header)\n\t\t\t\tlink, err := LinkDeserialize(&header, m.Data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\tcberr(err)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tch <- LinkUpdate{IfInfomsg: *ifmsg, Header: header, Link: link}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc LinkSetHairpin(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetHairpin(link, mode)\n}\n\nfunc (h *Handle) LinkSetHairpin(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_MODE)\n}\n\nfunc LinkSetGuard(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetGuard(link, mode)\n}\n\nfunc (h *Handle) LinkSetGuard(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_GUARD)\n}\n\n// LinkSetBRSlaveGroupFwdMask set the group_fwd_mask of a bridge slave interface\nfunc LinkSetBRSlaveGroupFwdMask(link Link, mask uint16) error {\n\treturn pkgHandle.LinkSetBRSlaveGroupFwdMask(link, mask)\n}\n\n// LinkSetBRSlaveGroupFwdMask set the group_fwd_mask of a bridge slave interface\nfunc (h *Handle) LinkSetBRSlaveGroupFwdMask(link Link, mask uint16) error {\n\treturn h.setProtinfoAttrRawVal(link, nl.Uint16Attr(mask), nl.IFLA_BRPORT_GROUP_FWD_MASK)\n}\n\nfunc LinkSetFastLeave(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetFastLeave(link, mode)\n}\n\nfunc (h *Handle) LinkSetFastLeave(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_FAST_LEAVE)\n}\n\nfunc LinkSetLearning(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetLearning(link, mode)\n}\n\nfunc (h *Handle) LinkSetLearning(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_LEARNING)\n}\n\nfunc LinkSetRootBlock(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetRootBlock(link, mode)\n}\n\nfunc (h *Handle) LinkSetRootBlock(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_PROTECT)\n}\n\nfunc LinkSetFlood(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetFlood(link, mode)\n}\n\nfunc (h *Handle) LinkSetFlood(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_UNICAST_FLOOD)\n}\n\nfunc LinkSetIsolated(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetIsolated(link, mode)\n}\n\nfunc (h *Handle) LinkSetIsolated(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_ISOLATED)\n}\n\nfunc LinkSetBrProxyArp(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetBrProxyArp(link, mode)\n}\n\nfunc (h *Handle) LinkSetBrProxyArp(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_PROXYARP)\n}\n\nfunc LinkSetBrProxyArpWiFi(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetBrProxyArpWiFi(link, mode)\n}\n\nfunc (h *Handle) LinkSetBrProxyArpWiFi(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_PROXYARP_WIFI)\n}\n\nfunc LinkSetBrNeighSuppress(link Link, mode bool) error {\n\treturn pkgHandle.LinkSetBrNeighSuppress(link, mode)\n}\n\nfunc (h *Handle) LinkSetBrNeighSuppress(link Link, mode bool) error {\n\treturn h.setProtinfoAttr(link, mode, nl.IFLA_BRPORT_NEIGH_SUPPRESS)\n}\n\nfunc (h *Handle) setProtinfoAttrRawVal(link Link, val []byte, attr int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_BRIDGE)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tbr := nl.NewRtAttr(unix.IFLA_PROTINFO|unix.NLA_F_NESTED, nil)\n\tbr.AddRtAttr(attr, val)\n\treq.AddData(br)\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\nfunc (h *Handle) setProtinfoAttr(link Link, mode bool, attr int) error {\n\treturn h.setProtinfoAttrRawVal(link, boolToByte(mode), attr)\n}\n\n// LinkSetTxQLen sets the transaction queue length for the link.\n// Equivalent to: `ip link set $link txqlen $qlen`\nfunc LinkSetTxQLen(link Link, qlen int) error {\n\treturn pkgHandle.LinkSetTxQLen(link, qlen)\n}\n\n// LinkSetTxQLen sets the transaction queue length for the link.\n// Equivalent to: `ip link set $link txqlen $qlen`\nfunc (h *Handle) LinkSetTxQLen(link Link, qlen int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(qlen))\n\n\tdata := nl.NewRtAttr(unix.IFLA_TXQLEN, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetGroup sets the link group id which can be used to perform mass actions\n// with iproute2 as well use it as a reference in nft filters.\n// Equivalent to: `ip link set $link group $id`\nfunc LinkSetGroup(link Link, group int) error {\n\treturn pkgHandle.LinkSetGroup(link, group)\n}\n\n// LinkSetGroup sets the link group id which can be used to perform mass actions\n// with iproute2 as well use it as a reference in nft filters.\n// Equivalent to: `ip link set $link group $id`\nfunc (h *Handle) LinkSetGroup(link Link, group int) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(group))\n\n\tdata := nl.NewRtAttr(unix.IFLA_GROUP, b)\n\treq.AddData(data)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc addNetkitAttrs(nk *Netkit, linkInfo *nl.RtAttr, flag int) error {\n\tif nk.peerLinkAttrs.HardwareAddr != nil || nk.HardwareAddr != nil {\n\t\treturn fmt.Errorf(\"netkit doesn't support setting Ethernet\")\n\t}\n\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\t// Kernel will return error if trying to change the mode of an existing netkit device\n\tdata.AddRtAttr(nl.IFLA_NETKIT_MODE, nl.Uint32Attr(uint32(nk.Mode)))\n\tdata.AddRtAttr(nl.IFLA_NETKIT_POLICY, nl.Uint32Attr(uint32(nk.Policy)))\n\tdata.AddRtAttr(nl.IFLA_NETKIT_PEER_POLICY, nl.Uint32Attr(uint32(nk.PeerPolicy)))\n\tdata.AddRtAttr(nl.IFLA_NETKIT_SCRUB, nl.Uint32Attr(uint32(nk.Scrub)))\n\tdata.AddRtAttr(nl.IFLA_NETKIT_PEER_SCRUB, nl.Uint32Attr(uint32(nk.PeerScrub)))\n\n\tif (flag & unix.NLM_F_EXCL) == 0 {\n\t\t// Modifying peer link attributes will not take effect\n\t\treturn nil\n\t}\n\n\tpeer := data.AddRtAttr(nl.IFLA_NETKIT_PEER_INFO, nil)\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tif nk.peerLinkAttrs.Flags&net.FlagUp != 0 {\n\t\tmsg.Change = unix.IFF_UP\n\t\tmsg.Flags = unix.IFF_UP\n\t}\n\tif nk.peerLinkAttrs.Index != 0 {\n\t\tmsg.Index = int32(nk.peerLinkAttrs.Index)\n\t}\n\tpeer.AddChild(msg)\n\tif nk.peerLinkAttrs.Name != \"\" {\n\t\tpeer.AddRtAttr(unix.IFLA_IFNAME, nl.ZeroTerminated(nk.peerLinkAttrs.Name))\n\t}\n\tif nk.peerLinkAttrs.MTU > 0 {\n\t\tpeer.AddRtAttr(unix.IFLA_MTU, nl.Uint32Attr(uint32(nk.peerLinkAttrs.MTU)))\n\t}\n\tif nk.peerLinkAttrs.GSOMaxSegs > 0 {\n\t\tpeer.AddRtAttr(unix.IFLA_GSO_MAX_SEGS, nl.Uint32Attr(nk.peerLinkAttrs.GSOMaxSegs))\n\t}\n\tif nk.peerLinkAttrs.GSOMaxSize > 0 {\n\t\tpeer.AddRtAttr(unix.IFLA_GSO_MAX_SIZE, nl.Uint32Attr(nk.peerLinkAttrs.GSOMaxSize))\n\t}\n\tif nk.peerLinkAttrs.GSOIPv4MaxSize > 0 {\n\t\tpeer.AddRtAttr(unix.IFLA_GSO_IPV4_MAX_SIZE, nl.Uint32Attr(nk.peerLinkAttrs.GSOIPv4MaxSize))\n\t}\n\tif nk.peerLinkAttrs.GROIPv4MaxSize > 0 {\n\t\tpeer.AddRtAttr(unix.IFLA_GRO_IPV4_MAX_SIZE, nl.Uint32Attr(nk.peerLinkAttrs.GROIPv4MaxSize))\n\t}\n\tif nk.peerLinkAttrs.Namespace != nil {\n\t\tswitch ns := nk.peerLinkAttrs.Namespace.(type) {\n\t\tcase NsPid:\n\t\t\tpeer.AddRtAttr(unix.IFLA_NET_NS_PID, nl.Uint32Attr(uint32(ns)))\n\t\tcase NsFd:\n\t\t\tpeer.AddRtAttr(unix.IFLA_NET_NS_FD, nl.Uint32Attr(uint32(ns)))\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parseNetkitData(link Link, data []syscall.NetlinkRouteAttr) {\n\tnetkit := link.(*Netkit)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_NETKIT_PRIMARY:\n\t\t\tisPrimary := datum.Value[0:1][0]\n\t\t\tif isPrimary != 0 {\n\t\t\t\tnetkit.isPrimary = true\n\t\t\t}\n\t\tcase nl.IFLA_NETKIT_MODE:\n\t\t\tnetkit.Mode = NetkitMode(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.IFLA_NETKIT_POLICY:\n\t\t\tnetkit.Policy = NetkitPolicy(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.IFLA_NETKIT_PEER_POLICY:\n\t\t\tnetkit.PeerPolicy = NetkitPolicy(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.IFLA_NETKIT_SCRUB:\n\t\t\tnetkit.supportsScrub = true\n\t\t\tnetkit.Scrub = NetkitScrub(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.IFLA_NETKIT_PEER_SCRUB:\n\t\t\tnetkit.supportsScrub = true\n\t\t\tnetkit.PeerScrub = NetkitScrub(native.Uint32(datum.Value[0:4]))\n\t\t}\n\t}\n}\n\nfunc parseVlanData(link Link, data []syscall.NetlinkRouteAttr) {\n\tvlan := link.(*Vlan)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_VLAN_ID:\n\t\t\tvlan.VlanId = int(native.Uint16(datum.Value[0:2]))\n\t\tcase nl.IFLA_VLAN_PROTOCOL:\n\t\t\tvlan.VlanProtocol = VlanProtocol(int(ntohs(datum.Value[0:2])))\n\t\t}\n\t}\n}\n\nfunc parseVxlanData(link Link, data []syscall.NetlinkRouteAttr) {\n\tvxlan := link.(*Vxlan)\n\tfor _, datum := range data {\n\t\t// NOTE(vish): Apparently some messages can be sent with no value.\n\t\t//             We special case GBP here to not change existing\n\t\t//             functionality. It appears that GBP sends a datum.Value\n\t\t//             of null.\n\t\tif len(datum.Value) == 0 && datum.Attr.Type != nl.IFLA_VXLAN_GBP {\n\t\t\tcontinue\n\t\t}\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_VXLAN_ID:\n\t\t\tvxlan.VxlanId = int(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.IFLA_VXLAN_LINK:\n\t\t\tvxlan.VtepDevIndex = int(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.IFLA_VXLAN_LOCAL:\n\t\t\tvxlan.SrcAddr = net.IP(datum.Value[0:4])\n\t\tcase nl.IFLA_VXLAN_LOCAL6:\n\t\t\tvxlan.SrcAddr = net.IP(datum.Value[0:16])\n\t\tcase nl.IFLA_VXLAN_GROUP:\n\t\t\tvxlan.Group = net.IP(datum.Value[0:4])\n\t\tcase nl.IFLA_VXLAN_GROUP6:\n\t\t\tvxlan.Group = net.IP(datum.Value[0:16])\n\t\tcase nl.IFLA_VXLAN_TTL:\n\t\t\tvxlan.TTL = int(datum.Value[0])\n\t\tcase nl.IFLA_VXLAN_TOS:\n\t\t\tvxlan.TOS = int(datum.Value[0])\n\t\tcase nl.IFLA_VXLAN_LEARNING:\n\t\t\tvxlan.Learning = int8(datum.Value[0]) != 0\n\t\tcase nl.IFLA_VXLAN_PROXY:\n\t\t\tvxlan.Proxy = int8(datum.Value[0]) != 0\n\t\tcase nl.IFLA_VXLAN_RSC:\n\t\t\tvxlan.RSC = int8(datum.Value[0]) != 0\n\t\tcase nl.IFLA_VXLAN_L2MISS:\n\t\t\tvxlan.L2miss = int8(datum.Value[0]) != 0\n\t\tcase nl.IFLA_VXLAN_L3MISS:\n\t\t\tvxlan.L3miss = int8(datum.Value[0]) != 0\n\t\tcase nl.IFLA_VXLAN_UDP_CSUM:\n\t\t\tvxlan.UDPCSum = int8(datum.Value[0]) != 0\n\t\tcase nl.IFLA_VXLAN_UDP_ZERO_CSUM6_TX:\n\t\t\tvxlan.UDP6ZeroCSumTx = int8(datum.Value[0]) != 0\n\t\tcase nl.IFLA_VXLAN_UDP_ZERO_CSUM6_RX:\n\t\t\tvxlan.UDP6ZeroCSumRx = int8(datum.Value[0]) != 0\n\t\tcase nl.IFLA_VXLAN_GBP:\n\t\t\tvxlan.GBP = true\n\t\tcase nl.IFLA_VXLAN_FLOWBASED:\n\t\t\tvxlan.FlowBased = int8(datum.Value[0]) != 0\n\t\tcase nl.IFLA_VXLAN_AGEING:\n\t\t\tvxlan.Age = int(native.Uint32(datum.Value[0:4]))\n\t\t\tvxlan.NoAge = vxlan.Age == 0\n\t\tcase nl.IFLA_VXLAN_LIMIT:\n\t\t\tvxlan.Limit = int(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.IFLA_VXLAN_PORT:\n\t\t\tvxlan.Port = int(ntohs(datum.Value[0:2]))\n\t\tcase nl.IFLA_VXLAN_PORT_RANGE:\n\t\t\tbuf := bytes.NewBuffer(datum.Value[0:4])\n\t\t\tvar pr vxlanPortRange\n\t\t\tif binary.Read(buf, binary.BigEndian, &pr) != nil {\n\t\t\t\tvxlan.PortLow = int(pr.Lo)\n\t\t\t\tvxlan.PortHigh = int(pr.Hi)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc parseBondData(link Link, data []syscall.NetlinkRouteAttr) {\n\tbond := link.(*Bond)\n\tfor i := range data {\n\t\tswitch data[i].Attr.Type {\n\t\tcase nl.IFLA_BOND_MODE:\n\t\t\tbond.Mode = BondMode(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_ACTIVE_SLAVE:\n\t\t\tbond.ActiveSlave = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_MIIMON:\n\t\t\tbond.Miimon = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_UPDELAY:\n\t\t\tbond.UpDelay = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_DOWNDELAY:\n\t\t\tbond.DownDelay = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_USE_CARRIER:\n\t\t\tbond.UseCarrier = int(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_ARP_INTERVAL:\n\t\t\tbond.ArpInterval = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_ARP_IP_TARGET:\n\t\t\tbond.ArpIpTargets = parseBondArpIpTargets(data[i].Value)\n\t\tcase nl.IFLA_BOND_ARP_VALIDATE:\n\t\t\tbond.ArpValidate = BondArpValidate(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_ARP_ALL_TARGETS:\n\t\t\tbond.ArpAllTargets = BondArpAllTargets(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_PRIMARY:\n\t\t\tbond.Primary = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_PRIMARY_RESELECT:\n\t\t\tbond.PrimaryReselect = BondPrimaryReselect(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_FAIL_OVER_MAC:\n\t\t\tbond.FailOverMac = BondFailOverMac(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_XMIT_HASH_POLICY:\n\t\t\tbond.XmitHashPolicy = BondXmitHashPolicy(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_RESEND_IGMP:\n\t\t\tbond.ResendIgmp = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_NUM_PEER_NOTIF:\n\t\t\tbond.NumPeerNotif = int(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_ALL_SLAVES_ACTIVE:\n\t\t\tbond.AllSlavesActive = int(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_MIN_LINKS:\n\t\t\tbond.MinLinks = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_LP_INTERVAL:\n\t\t\tbond.LpInterval = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_PACKETS_PER_SLAVE:\n\t\t\tbond.PacketsPerSlave = int(native.Uint32(data[i].Value[0:4]))\n\t\tcase nl.IFLA_BOND_AD_LACP_RATE:\n\t\t\tbond.LacpRate = BondLacpRate(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_AD_SELECT:\n\t\t\tbond.AdSelect = BondAdSelect(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_AD_INFO:\n\t\t\t// TODO: implement\n\t\tcase nl.IFLA_BOND_AD_ACTOR_SYS_PRIO:\n\t\t\tbond.AdActorSysPrio = int(native.Uint16(data[i].Value[0:2]))\n\t\tcase nl.IFLA_BOND_AD_USER_PORT_KEY:\n\t\t\tbond.AdUserPortKey = int(native.Uint16(data[i].Value[0:2]))\n\t\tcase nl.IFLA_BOND_AD_ACTOR_SYSTEM:\n\t\t\tbond.AdActorSystem = net.HardwareAddr(data[i].Value[0:6])\n\t\tcase nl.IFLA_BOND_TLB_DYNAMIC_LB:\n\t\t\tbond.TlbDynamicLb = int(data[i].Value[0])\n\t\t}\n\t}\n}\n\nfunc parseBondArpIpTargets(value []byte) []net.IP {\n\tdata, err := nl.ParseRouteAttr(value)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\ttargets := []net.IP{}\n\tfor i := range data {\n\t\ttarget := net.IP(data[i].Value)\n\t\tif ip := target.To4(); ip != nil {\n\t\t\ttargets = append(targets, ip)\n\t\t\tcontinue\n\t\t}\n\t\tif ip := target.To16(); ip != nil {\n\t\t\ttargets = append(targets, ip)\n\t\t}\n\t}\n\n\treturn targets\n}\n\nfunc addBondSlaveAttrs(bondSlave *BondSlave, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_SLAVE_DATA, nil)\n\n\tdata.AddRtAttr(nl.IFLA_BOND_SLAVE_STATE, nl.Uint8Attr(uint8(bondSlave.State)))\n\tdata.AddRtAttr(nl.IFLA_BOND_SLAVE_MII_STATUS, nl.Uint8Attr(uint8(bondSlave.MiiStatus)))\n\tdata.AddRtAttr(nl.IFLA_BOND_SLAVE_LINK_FAILURE_COUNT, nl.Uint32Attr(bondSlave.LinkFailureCount))\n\tdata.AddRtAttr(nl.IFLA_BOND_SLAVE_QUEUE_ID, nl.Uint16Attr(bondSlave.QueueId))\n\tdata.AddRtAttr(nl.IFLA_BOND_SLAVE_AD_AGGREGATOR_ID, nl.Uint16Attr(bondSlave.AggregatorId))\n\tdata.AddRtAttr(nl.IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE, nl.Uint8Attr(bondSlave.AdActorOperPortState))\n\tdata.AddRtAttr(nl.IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE, nl.Uint16Attr(bondSlave.AdPartnerOperPortState))\n\n\tif mac := bondSlave.PermHardwareAddr; mac != nil {\n\t\tdata.AddRtAttr(nl.IFLA_BOND_SLAVE_PERM_HWADDR, []byte(mac))\n\t}\n}\n\nfunc parseBondSlaveData(slave LinkSlave, data []syscall.NetlinkRouteAttr) {\n\tbondSlave := slave.(*BondSlave)\n\tfor i := range data {\n\t\tswitch data[i].Attr.Type {\n\t\tcase nl.IFLA_BOND_SLAVE_STATE:\n\t\t\tbondSlave.State = BondSlaveState(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_SLAVE_MII_STATUS:\n\t\t\tbondSlave.MiiStatus = BondSlaveMiiStatus(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_SLAVE_LINK_FAILURE_COUNT:\n\t\t\tbondSlave.LinkFailureCount = native.Uint32(data[i].Value[0:4])\n\t\tcase nl.IFLA_BOND_SLAVE_PERM_HWADDR:\n\t\t\tbondSlave.PermHardwareAddr = net.HardwareAddr(data[i].Value[0:6])\n\t\tcase nl.IFLA_BOND_SLAVE_QUEUE_ID:\n\t\t\tbondSlave.QueueId = native.Uint16(data[i].Value[0:2])\n\t\tcase nl.IFLA_BOND_SLAVE_AD_AGGREGATOR_ID:\n\t\t\tbondSlave.AggregatorId = native.Uint16(data[i].Value[0:2])\n\t\tcase nl.IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE:\n\t\t\tbondSlave.AdActorOperPortState = uint8(data[i].Value[0])\n\t\tcase nl.IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE:\n\t\t\tbondSlave.AdPartnerOperPortState = native.Uint16(data[i].Value[0:2])\n\t\t}\n\t}\n}\n\nfunc parseVrfSlaveData(slave LinkSlave, data []syscall.NetlinkRouteAttr) {\n\tvrfSlave := slave.(*VrfSlave)\n\tfor i := range data {\n\t\tswitch data[i].Attr.Type {\n\t\tcase nl.IFLA_BOND_SLAVE_STATE:\n\t\t\tvrfSlave.Table = native.Uint32(data[i].Value[0:4])\n\t\t}\n\t}\n}\n\nfunc parseIPVlanData(link Link, data []syscall.NetlinkRouteAttr) {\n\tipv := link.(*IPVlan)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_IPVLAN_MODE:\n\t\t\tipv.Mode = IPVlanMode(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.IFLA_IPVLAN_FLAG:\n\t\t\tipv.Flag = IPVlanFlag(native.Uint32(datum.Value[0:4]))\n\t\t}\n\t}\n}\n\nfunc parseIPVtapData(link Link, data []syscall.NetlinkRouteAttr) {\n\tipv := link.(*IPVtap)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_IPVLAN_MODE:\n\t\t\tipv.Mode = IPVlanMode(native.Uint32(datum.Value[0:4]))\n\t\tcase nl.IFLA_IPVLAN_FLAG:\n\t\t\tipv.Flag = IPVlanFlag(native.Uint32(datum.Value[0:4]))\n\t\t}\n\t}\n}\n\nfunc addMacvtapAttrs(macvtap *Macvtap, linkInfo *nl.RtAttr) {\n\taddMacvlanAttrs(&macvtap.Macvlan, linkInfo)\n}\n\nfunc parseMacvtapData(link Link, data []syscall.NetlinkRouteAttr) {\n\tmacv := link.(*Macvtap)\n\tparseMacvlanData(&macv.Macvlan, data)\n}\n\nfunc addMacvlanAttrs(macvlan *Macvlan, linkInfo *nl.RtAttr) {\n\tvar data *nl.RtAttr\n\n\tif macvlan.Mode != MACVLAN_MODE_DEFAULT || macvlan.BCQueueLen > 0 {\n\t\tdata = linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\t}\n\n\tif macvlan.Mode != MACVLAN_MODE_DEFAULT {\n\t\tdata.AddRtAttr(nl.IFLA_MACVLAN_MODE, nl.Uint32Attr(macvlanModes[macvlan.Mode]))\n\t}\n\tif macvlan.BCQueueLen > 0 {\n\t\tdata.AddRtAttr(nl.IFLA_MACVLAN_BC_QUEUE_LEN, nl.Uint32Attr(macvlan.BCQueueLen))\n\t}\n}\n\nfunc parseMacvlanData(link Link, data []syscall.NetlinkRouteAttr) {\n\tmacv := link.(*Macvlan)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_MACVLAN_MODE:\n\t\t\tswitch native.Uint32(datum.Value[0:4]) {\n\t\t\tcase nl.MACVLAN_MODE_PRIVATE:\n\t\t\t\tmacv.Mode = MACVLAN_MODE_PRIVATE\n\t\t\tcase nl.MACVLAN_MODE_VEPA:\n\t\t\t\tmacv.Mode = MACVLAN_MODE_VEPA\n\t\t\tcase nl.MACVLAN_MODE_BRIDGE:\n\t\t\t\tmacv.Mode = MACVLAN_MODE_BRIDGE\n\t\t\tcase nl.MACVLAN_MODE_PASSTHRU:\n\t\t\t\tmacv.Mode = MACVLAN_MODE_PASSTHRU\n\t\t\tcase nl.MACVLAN_MODE_SOURCE:\n\t\t\t\tmacv.Mode = MACVLAN_MODE_SOURCE\n\t\t\t}\n\t\tcase nl.IFLA_MACVLAN_MACADDR_COUNT:\n\t\t\tmacv.MACAddrs = make([]net.HardwareAddr, 0, int(native.Uint32(datum.Value[0:4])))\n\t\tcase nl.IFLA_MACVLAN_MACADDR_DATA:\n\t\t\tmacs, err := nl.ParseRouteAttr(datum.Value[:])\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Sprintf(\"failed to ParseRouteAttr for IFLA_MACVLAN_MACADDR_DATA: %v\", err))\n\t\t\t}\n\t\t\tfor _, macDatum := range macs {\n\t\t\t\tmacv.MACAddrs = append(macv.MACAddrs, net.HardwareAddr(macDatum.Value[0:6]))\n\t\t\t}\n\t\tcase nl.IFLA_MACVLAN_BC_QUEUE_LEN:\n\t\t\tmacv.BCQueueLen = native.Uint32(datum.Value[0:4])\n\t\tcase nl.IFLA_MACVLAN_BC_QUEUE_LEN_USED:\n\t\t\tmacv.UsedBCQueueLen = native.Uint32(datum.Value[0:4])\n\t\t}\n\t}\n}\n\n// copied from pkg/net_linux.go\nfunc linkFlags(rawFlags uint32) net.Flags {\n\tvar f net.Flags\n\tif rawFlags&unix.IFF_UP != 0 {\n\t\tf |= net.FlagUp\n\t}\n\tif rawFlags&unix.IFF_BROADCAST != 0 {\n\t\tf |= net.FlagBroadcast\n\t}\n\tif rawFlags&unix.IFF_LOOPBACK != 0 {\n\t\tf |= net.FlagLoopback\n\t}\n\tif rawFlags&unix.IFF_POINTOPOINT != 0 {\n\t\tf |= net.FlagPointToPoint\n\t}\n\tif rawFlags&unix.IFF_MULTICAST != 0 {\n\t\tf |= net.FlagMulticast\n\t}\n\treturn f\n}\n\nfunc addGeneveAttrs(geneve *Geneve, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\tif geneve.InnerProtoInherit {\n\t\tdata.AddRtAttr(nl.IFLA_GENEVE_INNER_PROTO_INHERIT, []byte{})\n\t}\n\n\tif geneve.FlowBased {\n\t\tgeneve.ID = 0\n\t\tdata.AddRtAttr(nl.IFLA_GENEVE_COLLECT_METADATA, []byte{})\n\t}\n\n\tif ip := geneve.Remote; ip != nil {\n\t\tif ip4 := ip.To4(); ip4 != nil {\n\t\t\tdata.AddRtAttr(nl.IFLA_GENEVE_REMOTE, ip.To4())\n\t\t} else {\n\t\t\tdata.AddRtAttr(nl.IFLA_GENEVE_REMOTE6, []byte(ip))\n\t\t}\n\t}\n\n\tif geneve.ID != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GENEVE_ID, nl.Uint32Attr(geneve.ID))\n\t}\n\n\tif geneve.Dport != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GENEVE_PORT, htons(geneve.Dport))\n\t}\n\n\tif geneve.Ttl != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GENEVE_TTL, nl.Uint8Attr(geneve.Ttl))\n\t}\n\n\tif geneve.Tos != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GENEVE_TOS, nl.Uint8Attr(geneve.Tos))\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_GENEVE_DF, nl.Uint8Attr(uint8(geneve.Df)))\n}\n\nfunc parseGeneveData(link Link, data []syscall.NetlinkRouteAttr) {\n\tgeneve := link.(*Geneve)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_GENEVE_ID:\n\t\t\tgeneve.ID = native.Uint32(datum.Value[0:4])\n\t\tcase nl.IFLA_GENEVE_REMOTE, nl.IFLA_GENEVE_REMOTE6:\n\t\t\tgeneve.Remote = datum.Value\n\t\tcase nl.IFLA_GENEVE_PORT:\n\t\t\tgeneve.Dport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_GENEVE_TTL:\n\t\t\tgeneve.Ttl = uint8(datum.Value[0])\n\t\tcase nl.IFLA_GENEVE_TOS:\n\t\t\tgeneve.Tos = uint8(datum.Value[0])\n\t\tcase nl.IFLA_GENEVE_COLLECT_METADATA:\n\t\t\tgeneve.FlowBased = true\n\t\tcase nl.IFLA_GENEVE_INNER_PROTO_INHERIT:\n\t\t\tgeneve.InnerProtoInherit = true\n\t\t}\n\t}\n}\n\nfunc addGretapAttrs(gretap *Gretap, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\tif gretap.FlowBased {\n\t\t// In flow based mode, no other attributes need to be configured\n\t\tdata.AddRtAttr(nl.IFLA_GRE_COLLECT_METADATA, []byte{})\n\t\treturn\n\t}\n\n\tif ip := gretap.Local; ip != nil {\n\t\tif ip.To4() != nil {\n\t\t\tip = ip.To4()\n\t\t}\n\t\tdata.AddRtAttr(nl.IFLA_GRE_LOCAL, []byte(ip))\n\t}\n\n\tif ip := gretap.Remote; ip != nil {\n\t\tif ip.To4() != nil {\n\t\t\tip = ip.To4()\n\t\t}\n\t\tdata.AddRtAttr(nl.IFLA_GRE_REMOTE, []byte(ip))\n\t}\n\n\tif gretap.IKey != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GRE_IKEY, htonl(gretap.IKey))\n\t\tgretap.IFlags |= uint16(nl.GRE_KEY)\n\t}\n\n\tif gretap.OKey != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GRE_OKEY, htonl(gretap.OKey))\n\t\tgretap.OFlags |= uint16(nl.GRE_KEY)\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_GRE_IFLAGS, htons(gretap.IFlags))\n\tdata.AddRtAttr(nl.IFLA_GRE_OFLAGS, htons(gretap.OFlags))\n\n\tif gretap.Link != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GRE_LINK, nl.Uint32Attr(gretap.Link))\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_GRE_PMTUDISC, nl.Uint8Attr(gretap.PMtuDisc))\n\tdata.AddRtAttr(nl.IFLA_GRE_TTL, nl.Uint8Attr(gretap.Ttl))\n\tdata.AddRtAttr(nl.IFLA_GRE_TOS, nl.Uint8Attr(gretap.Tos))\n\tdata.AddRtAttr(nl.IFLA_GRE_ENCAP_TYPE, nl.Uint16Attr(gretap.EncapType))\n\tdata.AddRtAttr(nl.IFLA_GRE_ENCAP_FLAGS, nl.Uint16Attr(gretap.EncapFlags))\n\tdata.AddRtAttr(nl.IFLA_GRE_ENCAP_SPORT, htons(gretap.EncapSport))\n\tdata.AddRtAttr(nl.IFLA_GRE_ENCAP_DPORT, htons(gretap.EncapDport))\n}\n\nfunc parseGretapData(link Link, data []syscall.NetlinkRouteAttr) {\n\tgre := link.(*Gretap)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_GRE_OKEY:\n\t\t\tgre.IKey = ntohl(datum.Value[0:4])\n\t\tcase nl.IFLA_GRE_IKEY:\n\t\t\tgre.OKey = ntohl(datum.Value[0:4])\n\t\tcase nl.IFLA_GRE_LOCAL:\n\t\t\tgre.Local = net.IP(datum.Value)\n\t\tcase nl.IFLA_GRE_REMOTE:\n\t\t\tgre.Remote = net.IP(datum.Value)\n\t\tcase nl.IFLA_GRE_ENCAP_SPORT:\n\t\t\tgre.EncapSport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_ENCAP_DPORT:\n\t\t\tgre.EncapDport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_IFLAGS:\n\t\t\tgre.IFlags = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_OFLAGS:\n\t\t\tgre.OFlags = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_TTL:\n\t\t\tgre.Ttl = uint8(datum.Value[0])\n\t\tcase nl.IFLA_GRE_TOS:\n\t\t\tgre.Tos = uint8(datum.Value[0])\n\t\tcase nl.IFLA_GRE_PMTUDISC:\n\t\t\tgre.PMtuDisc = uint8(datum.Value[0])\n\t\tcase nl.IFLA_GRE_ENCAP_TYPE:\n\t\t\tgre.EncapType = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_ENCAP_FLAGS:\n\t\t\tgre.EncapFlags = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_COLLECT_METADATA:\n\t\t\tgre.FlowBased = true\n\t\t}\n\t}\n}\n\nfunc addGretunAttrs(gre *Gretun, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\tif gre.FlowBased {\n\t\t// In flow based mode, no other attributes need to be configured\n\t\tdata.AddRtAttr(nl.IFLA_GRE_COLLECT_METADATA, []byte{})\n\t\treturn\n\t}\n\n\tif ip := gre.Local; ip != nil {\n\t\tif ip.To4() != nil {\n\t\t\tip = ip.To4()\n\t\t}\n\t\tdata.AddRtAttr(nl.IFLA_GRE_LOCAL, []byte(ip))\n\t}\n\n\tif ip := gre.Remote; ip != nil {\n\t\tif ip.To4() != nil {\n\t\t\tip = ip.To4()\n\t\t}\n\t\tdata.AddRtAttr(nl.IFLA_GRE_REMOTE, []byte(ip))\n\t}\n\n\tif gre.IKey != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GRE_IKEY, htonl(gre.IKey))\n\t\tgre.IFlags |= uint16(nl.GRE_KEY)\n\t}\n\n\tif gre.OKey != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GRE_OKEY, htonl(gre.OKey))\n\t\tgre.OFlags |= uint16(nl.GRE_KEY)\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_GRE_IFLAGS, htons(gre.IFlags))\n\tdata.AddRtAttr(nl.IFLA_GRE_OFLAGS, htons(gre.OFlags))\n\n\tif gre.Link != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_GRE_LINK, nl.Uint32Attr(gre.Link))\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_GRE_PMTUDISC, nl.Uint8Attr(gre.PMtuDisc))\n\tdata.AddRtAttr(nl.IFLA_GRE_TTL, nl.Uint8Attr(gre.Ttl))\n\tdata.AddRtAttr(nl.IFLA_GRE_TOS, nl.Uint8Attr(gre.Tos))\n\tdata.AddRtAttr(nl.IFLA_GRE_ENCAP_TYPE, nl.Uint16Attr(gre.EncapType))\n\tdata.AddRtAttr(nl.IFLA_GRE_ENCAP_FLAGS, nl.Uint16Attr(gre.EncapFlags))\n\tdata.AddRtAttr(nl.IFLA_GRE_ENCAP_SPORT, htons(gre.EncapSport))\n\tdata.AddRtAttr(nl.IFLA_GRE_ENCAP_DPORT, htons(gre.EncapDport))\n}\n\nfunc parseGretunData(link Link, data []syscall.NetlinkRouteAttr) {\n\tgre := link.(*Gretun)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_GRE_IKEY:\n\t\t\tgre.IKey = ntohl(datum.Value[0:4])\n\t\tcase nl.IFLA_GRE_OKEY:\n\t\t\tgre.OKey = ntohl(datum.Value[0:4])\n\t\tcase nl.IFLA_GRE_LOCAL:\n\t\t\tgre.Local = net.IP(datum.Value)\n\t\tcase nl.IFLA_GRE_REMOTE:\n\t\t\tgre.Remote = net.IP(datum.Value)\n\t\tcase nl.IFLA_GRE_IFLAGS:\n\t\t\tgre.IFlags = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_OFLAGS:\n\t\t\tgre.OFlags = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_TTL:\n\t\t\tgre.Ttl = uint8(datum.Value[0])\n\t\tcase nl.IFLA_GRE_TOS:\n\t\t\tgre.Tos = uint8(datum.Value[0])\n\t\tcase nl.IFLA_GRE_PMTUDISC:\n\t\t\tgre.PMtuDisc = uint8(datum.Value[0])\n\t\tcase nl.IFLA_GRE_ENCAP_TYPE:\n\t\t\tgre.EncapType = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_ENCAP_FLAGS:\n\t\t\tgre.EncapFlags = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_ENCAP_SPORT:\n\t\t\tgre.EncapSport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_ENCAP_DPORT:\n\t\t\tgre.EncapDport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_GRE_COLLECT_METADATA:\n\t\t\tgre.FlowBased = true\n\t\t}\n\t}\n}\n\nfunc addXdpAttrs(xdp *LinkXdp, req *nl.NetlinkRequest) {\n\tattrs := nl.NewRtAttr(unix.IFLA_XDP|unix.NLA_F_NESTED, nil)\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(xdp.Fd))\n\tattrs.AddRtAttr(nl.IFLA_XDP_FD, b)\n\tif xdp.Flags != 0 {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, xdp.Flags)\n\t\tattrs.AddRtAttr(nl.IFLA_XDP_FLAGS, b)\n\t}\n\treq.AddData(attrs)\n}\n\nfunc parseLinkXdp(data []byte) (*LinkXdp, error) {\n\tattrs, err := nl.ParseRouteAttr(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\txdp := &LinkXdp{}\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase nl.IFLA_XDP_FD:\n\t\t\txdp.Fd = int(native.Uint32(attr.Value[0:4]))\n\t\tcase nl.IFLA_XDP_ATTACHED:\n\t\t\txdp.AttachMode = uint32(attr.Value[0])\n\t\t\txdp.Attached = xdp.AttachMode != 0\n\t\tcase nl.IFLA_XDP_FLAGS:\n\t\t\txdp.Flags = native.Uint32(attr.Value[0:4])\n\t\tcase nl.IFLA_XDP_PROG_ID:\n\t\t\txdp.ProgId = native.Uint32(attr.Value[0:4])\n\t\t}\n\t}\n\treturn xdp, nil\n}\n\nfunc addIptunAttrs(iptun *Iptun, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\tif iptun.FlowBased {\n\t\t// In flow based mode, no other attributes need to be configured\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_COLLECT_METADATA, []byte{})\n\t\treturn\n\t}\n\n\tip := iptun.Local.To4()\n\tif ip != nil {\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_LOCAL, []byte(ip))\n\t}\n\n\tip = iptun.Remote.To4()\n\tif ip != nil {\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_REMOTE, []byte(ip))\n\t}\n\n\tif iptun.Link != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_LINK, nl.Uint32Attr(iptun.Link))\n\t}\n\tdata.AddRtAttr(nl.IFLA_IPTUN_PMTUDISC, nl.Uint8Attr(iptun.PMtuDisc))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_TTL, nl.Uint8Attr(iptun.Ttl))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_TOS, nl.Uint8Attr(iptun.Tos))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_TYPE, nl.Uint16Attr(iptun.EncapType))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_FLAGS, nl.Uint16Attr(iptun.EncapFlags))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_SPORT, htons(iptun.EncapSport))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_DPORT, htons(iptun.EncapDport))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_PROTO, nl.Uint8Attr(iptun.Proto))\n}\n\nfunc parseIptunData(link Link, data []syscall.NetlinkRouteAttr) {\n\tiptun := link.(*Iptun)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_IPTUN_LOCAL:\n\t\t\tiptun.Local = net.IP(datum.Value[0:4])\n\t\tcase nl.IFLA_IPTUN_REMOTE:\n\t\t\tiptun.Remote = net.IP(datum.Value[0:4])\n\t\tcase nl.IFLA_IPTUN_TTL:\n\t\t\tiptun.Ttl = uint8(datum.Value[0])\n\t\tcase nl.IFLA_IPTUN_TOS:\n\t\t\tiptun.Tos = uint8(datum.Value[0])\n\t\tcase nl.IFLA_IPTUN_PMTUDISC:\n\t\t\tiptun.PMtuDisc = uint8(datum.Value[0])\n\t\tcase nl.IFLA_IPTUN_ENCAP_SPORT:\n\t\t\tiptun.EncapSport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_ENCAP_DPORT:\n\t\t\tiptun.EncapDport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_ENCAP_TYPE:\n\t\t\tiptun.EncapType = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_ENCAP_FLAGS:\n\t\t\tiptun.EncapFlags = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_COLLECT_METADATA:\n\t\t\tiptun.FlowBased = true\n\t\tcase nl.IFLA_IPTUN_PROTO:\n\t\t\tiptun.Proto = datum.Value[0]\n\t\t}\n\t}\n}\n\nfunc addIp6tnlAttrs(ip6tnl *Ip6tnl, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\tif ip6tnl.FlowBased {\n\t\t// In flow based mode, no other attributes need to be configured\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_COLLECT_METADATA, []byte{})\n\t\treturn\n\t}\n\n\tif ip6tnl.Link != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_LINK, nl.Uint32Attr(ip6tnl.Link))\n\t}\n\n\tip := ip6tnl.Local.To16()\n\tif ip != nil {\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_LOCAL, []byte(ip))\n\t}\n\n\tip = ip6tnl.Remote.To16()\n\tif ip != nil {\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_REMOTE, []byte(ip))\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_IPTUN_TTL, nl.Uint8Attr(ip6tnl.Ttl))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_TOS, nl.Uint8Attr(ip6tnl.Tos))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_FLAGS, nl.Uint32Attr(ip6tnl.Flags))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_PROTO, nl.Uint8Attr(ip6tnl.Proto))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_FLOWINFO, nl.Uint32Attr(ip6tnl.FlowInfo))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_LIMIT, nl.Uint8Attr(ip6tnl.EncapLimit))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_TYPE, nl.Uint16Attr(ip6tnl.EncapType))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_FLAGS, nl.Uint16Attr(ip6tnl.EncapFlags))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_SPORT, htons(ip6tnl.EncapSport))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_DPORT, htons(ip6tnl.EncapDport))\n}\n\nfunc parseIp6tnlData(link Link, data []syscall.NetlinkRouteAttr) {\n\tip6tnl := link.(*Ip6tnl)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_IPTUN_LOCAL:\n\t\t\tip6tnl.Local = net.IP(datum.Value[:16])\n\t\tcase nl.IFLA_IPTUN_REMOTE:\n\t\t\tip6tnl.Remote = net.IP(datum.Value[:16])\n\t\tcase nl.IFLA_IPTUN_TTL:\n\t\t\tip6tnl.Ttl = datum.Value[0]\n\t\tcase nl.IFLA_IPTUN_TOS:\n\t\t\tip6tnl.Tos = datum.Value[0]\n\t\tcase nl.IFLA_IPTUN_FLAGS:\n\t\t\tip6tnl.Flags = native.Uint32(datum.Value[:4])\n\t\tcase nl.IFLA_IPTUN_PROTO:\n\t\t\tip6tnl.Proto = datum.Value[0]\n\t\tcase nl.IFLA_IPTUN_FLOWINFO:\n\t\t\tip6tnl.FlowInfo = native.Uint32(datum.Value[:4])\n\t\tcase nl.IFLA_IPTUN_ENCAP_LIMIT:\n\t\t\tip6tnl.EncapLimit = datum.Value[0]\n\t\tcase nl.IFLA_IPTUN_ENCAP_TYPE:\n\t\t\tip6tnl.EncapType = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_ENCAP_FLAGS:\n\t\t\tip6tnl.EncapFlags = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_ENCAP_SPORT:\n\t\t\tip6tnl.EncapSport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_ENCAP_DPORT:\n\t\t\tip6tnl.EncapDport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_COLLECT_METADATA:\n\t\t\tip6tnl.FlowBased = true\n\t\t}\n\t}\n}\n\nfunc addSittunAttrs(sittun *Sittun, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\tif sittun.Link != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_LINK, nl.Uint32Attr(sittun.Link))\n\t}\n\n\tip := sittun.Local.To4()\n\tif ip != nil {\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_LOCAL, []byte(ip))\n\t}\n\n\tip = sittun.Remote.To4()\n\tif ip != nil {\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_REMOTE, []byte(ip))\n\t}\n\n\tif sittun.Ttl > 0 {\n\t\t// Would otherwise fail on 3.10 kernel\n\t\tdata.AddRtAttr(nl.IFLA_IPTUN_TTL, nl.Uint8Attr(sittun.Ttl))\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_IPTUN_PROTO, nl.Uint8Attr(sittun.Proto))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_TOS, nl.Uint8Attr(sittun.Tos))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_PMTUDISC, nl.Uint8Attr(sittun.PMtuDisc))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_LIMIT, nl.Uint8Attr(sittun.EncapLimit))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_TYPE, nl.Uint16Attr(sittun.EncapType))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_FLAGS, nl.Uint16Attr(sittun.EncapFlags))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_SPORT, htons(sittun.EncapSport))\n\tdata.AddRtAttr(nl.IFLA_IPTUN_ENCAP_DPORT, htons(sittun.EncapDport))\n}\n\nfunc parseSittunData(link Link, data []syscall.NetlinkRouteAttr) {\n\tsittun := link.(*Sittun)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_IPTUN_LOCAL:\n\t\t\tsittun.Local = net.IP(datum.Value[0:4])\n\t\tcase nl.IFLA_IPTUN_REMOTE:\n\t\t\tsittun.Remote = net.IP(datum.Value[0:4])\n\t\tcase nl.IFLA_IPTUN_TTL:\n\t\t\tsittun.Ttl = datum.Value[0]\n\t\tcase nl.IFLA_IPTUN_TOS:\n\t\t\tsittun.Tos = datum.Value[0]\n\t\tcase nl.IFLA_IPTUN_PMTUDISC:\n\t\t\tsittun.PMtuDisc = datum.Value[0]\n\t\tcase nl.IFLA_IPTUN_PROTO:\n\t\t\tsittun.Proto = datum.Value[0]\n\t\tcase nl.IFLA_IPTUN_ENCAP_TYPE:\n\t\t\tsittun.EncapType = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_ENCAP_FLAGS:\n\t\t\tsittun.EncapFlags = native.Uint16(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_ENCAP_SPORT:\n\t\t\tsittun.EncapSport = ntohs(datum.Value[0:2])\n\t\tcase nl.IFLA_IPTUN_ENCAP_DPORT:\n\t\t\tsittun.EncapDport = ntohs(datum.Value[0:2])\n\t\t}\n\t}\n}\n\nfunc addVtiAttrs(vti *Vti, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\tfamily := FAMILY_V4\n\tif vti.Local.To4() == nil {\n\t\tfamily = FAMILY_V6\n\t}\n\n\tvar ip net.IP\n\n\tif family == FAMILY_V4 {\n\t\tip = vti.Local.To4()\n\t} else {\n\t\tip = vti.Local\n\t}\n\tif ip != nil {\n\t\tdata.AddRtAttr(nl.IFLA_VTI_LOCAL, []byte(ip))\n\t}\n\n\tif family == FAMILY_V4 {\n\t\tip = vti.Remote.To4()\n\t} else {\n\t\tip = vti.Remote\n\t}\n\tif ip != nil {\n\t\tdata.AddRtAttr(nl.IFLA_VTI_REMOTE, []byte(ip))\n\t}\n\n\tif vti.Link != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_VTI_LINK, nl.Uint32Attr(vti.Link))\n\t}\n\n\tdata.AddRtAttr(nl.IFLA_VTI_IKEY, htonl(vti.IKey))\n\tdata.AddRtAttr(nl.IFLA_VTI_OKEY, htonl(vti.OKey))\n}\n\nfunc parseVtiData(link Link, data []syscall.NetlinkRouteAttr) {\n\tvti := link.(*Vti)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_VTI_LOCAL:\n\t\t\tvti.Local = net.IP(datum.Value)\n\t\tcase nl.IFLA_VTI_REMOTE:\n\t\t\tvti.Remote = net.IP(datum.Value)\n\t\tcase nl.IFLA_VTI_IKEY:\n\t\t\tvti.IKey = ntohl(datum.Value[0:4])\n\t\tcase nl.IFLA_VTI_OKEY:\n\t\t\tvti.OKey = ntohl(datum.Value[0:4])\n\t\t}\n\t}\n}\n\nfunc addVrfAttrs(vrf *Vrf, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(vrf.Table))\n\tdata.AddRtAttr(nl.IFLA_VRF_TABLE, b)\n}\n\nfunc parseVrfData(link Link, data []syscall.NetlinkRouteAttr) {\n\tvrf := link.(*Vrf)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_VRF_TABLE:\n\t\t\tvrf.Table = native.Uint32(datum.Value[0:4])\n\t\t}\n\t}\n}\n\nfunc addBridgeAttrs(bridge *Bridge, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\tif bridge.MulticastSnooping != nil {\n\t\tdata.AddRtAttr(nl.IFLA_BR_MCAST_SNOOPING, boolToByte(*bridge.MulticastSnooping))\n\t}\n\tif bridge.AgeingTime != nil {\n\t\tdata.AddRtAttr(nl.IFLA_BR_AGEING_TIME, nl.Uint32Attr(*bridge.AgeingTime))\n\t}\n\tif bridge.HelloTime != nil {\n\t\tdata.AddRtAttr(nl.IFLA_BR_HELLO_TIME, nl.Uint32Attr(*bridge.HelloTime))\n\t}\n\tif bridge.VlanFiltering != nil {\n\t\tdata.AddRtAttr(nl.IFLA_BR_VLAN_FILTERING, boolToByte(*bridge.VlanFiltering))\n\t}\n\tif bridge.VlanDefaultPVID != nil {\n\t\tdata.AddRtAttr(nl.IFLA_BR_VLAN_DEFAULT_PVID, nl.Uint16Attr(*bridge.VlanDefaultPVID))\n\t}\n\tif bridge.GroupFwdMask != nil {\n\t\tdata.AddRtAttr(nl.IFLA_BR_GROUP_FWD_MASK, nl.Uint16Attr(*bridge.GroupFwdMask))\n\t}\n}\n\nfunc parseBridgeData(bridge Link, data []syscall.NetlinkRouteAttr) {\n\tbr := bridge.(*Bridge)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_BR_AGEING_TIME:\n\t\t\tageingTime := native.Uint32(datum.Value[0:4])\n\t\t\tbr.AgeingTime = &ageingTime\n\t\tcase nl.IFLA_BR_HELLO_TIME:\n\t\t\thelloTime := native.Uint32(datum.Value[0:4])\n\t\t\tbr.HelloTime = &helloTime\n\t\tcase nl.IFLA_BR_MCAST_SNOOPING:\n\t\t\tmcastSnooping := datum.Value[0] == 1\n\t\t\tbr.MulticastSnooping = &mcastSnooping\n\t\tcase nl.IFLA_BR_VLAN_FILTERING:\n\t\t\tvlanFiltering := datum.Value[0] == 1\n\t\t\tbr.VlanFiltering = &vlanFiltering\n\t\tcase nl.IFLA_BR_VLAN_DEFAULT_PVID:\n\t\t\tvlanDefaultPVID := native.Uint16(datum.Value[0:2])\n\t\t\tbr.VlanDefaultPVID = &vlanDefaultPVID\n\t\tcase nl.IFLA_BR_GROUP_FWD_MASK:\n\t\t\tmask := native.Uint16(datum.Value[0:2])\n\t\t\tbr.GroupFwdMask = &mask\n\t\t}\n\t}\n}\n\nfunc addGTPAttrs(gtp *GTP, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\tdata.AddRtAttr(nl.IFLA_GTP_FD0, nl.Uint32Attr(uint32(gtp.FD0)))\n\tdata.AddRtAttr(nl.IFLA_GTP_FD1, nl.Uint32Attr(uint32(gtp.FD1)))\n\tdata.AddRtAttr(nl.IFLA_GTP_PDP_HASHSIZE, nl.Uint32Attr(131072))\n\tif gtp.Role != nl.GTP_ROLE_GGSN {\n\t\tdata.AddRtAttr(nl.IFLA_GTP_ROLE, nl.Uint32Attr(uint32(gtp.Role)))\n\t}\n}\n\nfunc parseGTPData(link Link, data []syscall.NetlinkRouteAttr) {\n\tgtp := link.(*GTP)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_GTP_FD0:\n\t\t\tgtp.FD0 = int(native.Uint32(datum.Value))\n\t\tcase nl.IFLA_GTP_FD1:\n\t\t\tgtp.FD1 = int(native.Uint32(datum.Value))\n\t\tcase nl.IFLA_GTP_PDP_HASHSIZE:\n\t\t\tgtp.PDPHashsize = int(native.Uint32(datum.Value))\n\t\tcase nl.IFLA_GTP_ROLE:\n\t\t\tgtp.Role = int(native.Uint32(datum.Value))\n\t\t}\n\t}\n}\n\nfunc parseVfInfoList(data []syscall.NetlinkRouteAttr) ([]VfInfo, error) {\n\tvar vfs []VfInfo\n\n\tfor i, element := range data {\n\t\tif element.Attr.Type != nl.IFLA_VF_INFO {\n\t\t\treturn nil, fmt.Errorf(\"Incorrect element type in vf info list: %d\", element.Attr.Type)\n\t\t}\n\t\tvfAttrs, err := nl.ParseRouteAttr(element.Value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvf, err := parseVfInfo(vfAttrs, i)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tvfs = append(vfs, vf)\n\t}\n\treturn vfs, nil\n}\n\nfunc parseVfInfo(data []syscall.NetlinkRouteAttr, id int) (VfInfo, error) {\n\tvf := VfInfo{ID: id}\n\tfor _, element := range data {\n\t\tswitch element.Attr.Type {\n\t\tcase nl.IFLA_VF_MAC:\n\t\t\tmac := nl.DeserializeVfMac(element.Value[:])\n\t\t\tvf.Mac = mac.Mac[:6]\n\t\tcase nl.IFLA_VF_VLAN:\n\t\t\tvl := nl.DeserializeVfVlan(element.Value[:])\n\t\t\tvf.Vlan = int(vl.Vlan)\n\t\t\tvf.Qos = int(vl.Qos)\n\t\tcase nl.IFLA_VF_VLAN_LIST:\n\t\t\tvfVlanInfoList, err := nl.DeserializeVfVlanList(element.Value[:])\n\t\t\tif err != nil {\n\t\t\t\treturn vf, err\n\t\t\t}\n\t\t\tvf.VlanProto = int(vfVlanInfoList[0].VlanProto)\n\t\tcase nl.IFLA_VF_TX_RATE:\n\t\t\ttxr := nl.DeserializeVfTxRate(element.Value[:])\n\t\t\tvf.TxRate = int(txr.Rate)\n\t\tcase nl.IFLA_VF_SPOOFCHK:\n\t\t\tsp := nl.DeserializeVfSpoofchk(element.Value[:])\n\t\t\tvf.Spoofchk = sp.Setting != 0\n\t\tcase nl.IFLA_VF_LINK_STATE:\n\t\t\tls := nl.DeserializeVfLinkState(element.Value[:])\n\t\t\tvf.LinkState = ls.LinkState\n\t\tcase nl.IFLA_VF_RATE:\n\t\t\tvfr := nl.DeserializeVfRate(element.Value[:])\n\t\t\tvf.MaxTxRate = vfr.MaxTxRate\n\t\t\tvf.MinTxRate = vfr.MinTxRate\n\t\tcase nl.IFLA_VF_STATS:\n\t\t\tvfstats := nl.DeserializeVfStats(element.Value[:])\n\t\t\tvf.RxPackets = vfstats.RxPackets\n\t\t\tvf.TxPackets = vfstats.TxPackets\n\t\t\tvf.RxBytes = vfstats.RxBytes\n\t\t\tvf.TxBytes = vfstats.TxBytes\n\t\t\tvf.Multicast = vfstats.Multicast\n\t\t\tvf.Broadcast = vfstats.Broadcast\n\t\t\tvf.RxDropped = vfstats.RxDropped\n\t\t\tvf.TxDropped = vfstats.TxDropped\n\n\t\tcase nl.IFLA_VF_RSS_QUERY_EN:\n\t\t\tresult := nl.DeserializeVfRssQueryEn(element.Value)\n\t\t\tvf.RssQuery = result.Setting\n\n\t\tcase nl.IFLA_VF_TRUST:\n\t\t\tresult := nl.DeserializeVfTrust(element.Value)\n\t\t\tvf.Trust = result.Setting\n\t\t}\n\t}\n\treturn vf, nil\n}\n\nfunc addXfrmiAttrs(xfrmi *Xfrmi, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\tdata.AddRtAttr(nl.IFLA_XFRM_LINK, nl.Uint32Attr(uint32(xfrmi.ParentIndex)))\n\tif xfrmi.Ifid != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_XFRM_IF_ID, nl.Uint32Attr(xfrmi.Ifid))\n\t}\n}\n\nfunc parseXfrmiData(link Link, data []syscall.NetlinkRouteAttr) {\n\txfrmi := link.(*Xfrmi)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_XFRM_LINK:\n\t\t\txfrmi.ParentIndex = int(native.Uint32(datum.Value))\n\t\tcase nl.IFLA_XFRM_IF_ID:\n\t\t\txfrmi.Ifid = native.Uint32(datum.Value)\n\t\t}\n\t}\n}\n\nfunc ioctlBondSlave(cmd uintptr, link Link, master *Bond) error {\n\tfd, err := getSocketUDP()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer syscall.Close(fd)\n\n\tifreq := newIocltSlaveReq(link.Attrs().Name, master.Attrs().Name)\n\t_, _, errno := syscall.Syscall(syscall.SYS_IOCTL, uintptr(fd), cmd, uintptr(unsafe.Pointer(ifreq)))\n\tif errno != 0 {\n\t\treturn fmt.Errorf(\"errno=%v\", errno)\n\t}\n\treturn nil\n}\n\n// LinkSetBondSlaveActive sets specified slave to ACTIVE in an `active-backup` bond link via ioctl interface.\n//\n//\tMultiple calls keeps the status unchanged(shown in the unit test).\nfunc LinkSetBondSlaveActive(link Link, master *Bond) error {\n\terr := ioctlBondSlave(unix.SIOCBONDCHANGEACTIVE, link, master)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to set slave %q active in %q, %v\", link.Attrs().Name, master.Attrs().Name, err)\n\t}\n\treturn nil\n}\n\n// LinkSetBondSlave add slave to bond link via ioctl interface.\nfunc LinkSetBondSlave(link Link, master *Bond) error {\n\terr := ioctlBondSlave(unix.SIOCBONDENSLAVE, link, master)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to enslave %q to %q, %v\", link.Attrs().Name, master.Attrs().Name, err)\n\t}\n\treturn nil\n}\n\n// LinkSetBondSlave removes specified slave from bond link via ioctl interface.\nfunc LinkDelBondSlave(link Link, master *Bond) error {\n\terr := ioctlBondSlave(unix.SIOCBONDRELEASE, link, master)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to del slave %q from %q, %v\", link.Attrs().Name, master.Attrs().Name, err)\n\t}\n\treturn nil\n}\n\n// LinkSetBondSlaveQueueId modify bond slave queue-id.\nfunc (h *Handle) LinkSetBondSlaveQueueId(link Link, queueId uint16) error {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\treq := h.newNetlinkRequest(unix.RTM_SETLINK, unix.NLM_F_ACK)\n\n\tmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\tmsg.Index = int32(base.Index)\n\treq.AddData(msg)\n\n\tlinkInfo := nl.NewRtAttr(unix.IFLA_LINKINFO, nil)\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_SLAVE_DATA, nil)\n\tdata.AddRtAttr(nl.IFLA_BOND_SLAVE_QUEUE_ID, nl.Uint16Attr(queueId))\n\n\treq.AddData(linkInfo)\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// LinkSetBondSlaveQueueId modify bond slave queue-id.\nfunc LinkSetBondSlaveQueueId(link Link, queueId uint16) error {\n\treturn pkgHandle.LinkSetBondSlaveQueueId(link, queueId)\n}\n\nfunc vethStatsSerialize(stats ethtoolStats) ([]byte, error) {\n\tstatsSize := int(unsafe.Sizeof(stats)) + int(stats.nStats)*int(unsafe.Sizeof(uint64(0)))\n\tb := make([]byte, 0, statsSize)\n\tbuf := bytes.NewBuffer(b)\n\terr := binary.Write(buf, nl.NativeEndian(), stats)\n\treturn buf.Bytes()[:statsSize], err\n}\n\ntype vethEthtoolStats struct {\n\tCmd    uint32\n\tNStats uint32\n\tPeer   uint64\n\t// Newer kernels have XDP stats in here, but we only care\n\t// to extract the peer ifindex here.\n}\n\nfunc vethStatsDeserialize(b []byte) (vethEthtoolStats, error) {\n\tvar stats = vethEthtoolStats{}\n\terr := binary.Read(bytes.NewReader(b), nl.NativeEndian(), &stats)\n\treturn stats, err\n}\n\n// VethPeerIndex get veth peer index.\nfunc VethPeerIndex(link *Veth) (int, error) {\n\tfd, err := getSocketUDP()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tdefer syscall.Close(fd)\n\n\tifreq, sSet := newIocltStringSetReq(link.Name)\n\t_, _, errno := syscall.Syscall(syscall.SYS_IOCTL, uintptr(fd), SIOCETHTOOL, uintptr(unsafe.Pointer(ifreq)))\n\tif errno != 0 {\n\t\treturn -1, fmt.Errorf(\"SIOCETHTOOL request for %q failed, errno=%v\", link.Attrs().Name, errno)\n\t}\n\n\tstats := ethtoolStats{\n\t\tcmd:    ETHTOOL_GSTATS,\n\t\tnStats: sSet.data[0],\n\t}\n\n\tbuffer, err := vethStatsSerialize(stats)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tifreq.Data = uintptr(unsafe.Pointer(&buffer[0]))\n\t_, _, errno = syscall.Syscall(syscall.SYS_IOCTL, uintptr(fd), SIOCETHTOOL, uintptr(unsafe.Pointer(ifreq)))\n\tif errno != 0 {\n\t\treturn -1, fmt.Errorf(\"SIOCETHTOOL request for %q failed, errno=%v\", link.Attrs().Name, errno)\n\t}\n\n\tvstats, err := vethStatsDeserialize(buffer)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\treturn int(vstats.Peer), nil\n}\n\nfunc parseTuntapData(link Link, data []syscall.NetlinkRouteAttr) {\n\ttuntap := link.(*Tuntap)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_TUN_OWNER:\n\t\t\ttuntap.Owner = native.Uint32(datum.Value)\n\t\tcase nl.IFLA_TUN_GROUP:\n\t\t\ttuntap.Group = native.Uint32(datum.Value)\n\t\tcase nl.IFLA_TUN_TYPE:\n\t\t\ttuntap.Mode = TuntapMode(uint8(datum.Value[0]))\n\t\tcase nl.IFLA_TUN_PERSIST:\n\t\t\ttuntap.NonPersist = false\n\t\t\tif uint8(datum.Value[0]) == 0 {\n\t\t\t\ttuntap.NonPersist = true\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc parseIPoIBData(link Link, data []syscall.NetlinkRouteAttr) {\n\tipoib := link.(*IPoIB)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_IPOIB_PKEY:\n\t\t\tipoib.Pkey = uint16(native.Uint16(datum.Value))\n\t\tcase nl.IFLA_IPOIB_MODE:\n\t\t\tipoib.Mode = IPoIBMode(native.Uint16(datum.Value))\n\t\tcase nl.IFLA_IPOIB_UMCAST:\n\t\t\tipoib.Umcast = uint16(native.Uint16(datum.Value))\n\t\t}\n\t}\n}\n\nfunc parseCanData(link Link, data []syscall.NetlinkRouteAttr) {\n\tcan := link.(*Can)\n\tfor _, datum := range data {\n\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.IFLA_CAN_BITTIMING:\n\t\t\tcan.BitRate = native.Uint32(datum.Value)\n\t\t\tcan.SamplePoint = native.Uint32(datum.Value[4:])\n\t\t\tcan.TimeQuanta = native.Uint32(datum.Value[8:])\n\t\t\tcan.PropagationSegment = native.Uint32(datum.Value[12:])\n\t\t\tcan.PhaseSegment1 = native.Uint32(datum.Value[16:])\n\t\t\tcan.PhaseSegment2 = native.Uint32(datum.Value[20:])\n\t\t\tcan.SyncJumpWidth = native.Uint32(datum.Value[24:])\n\t\t\tcan.BitRatePreScaler = native.Uint32(datum.Value[28:])\n\t\tcase nl.IFLA_CAN_BITTIMING_CONST:\n\t\t\tcan.Name = string(datum.Value[:16])\n\t\t\tcan.TimeSegment1Min = native.Uint32(datum.Value[16:])\n\t\t\tcan.TimeSegment1Max = native.Uint32(datum.Value[20:])\n\t\t\tcan.TimeSegment2Min = native.Uint32(datum.Value[24:])\n\t\t\tcan.TimeSegment2Max = native.Uint32(datum.Value[28:])\n\t\t\tcan.SyncJumpWidthMax = native.Uint32(datum.Value[32:])\n\t\t\tcan.BitRatePreScalerMin = native.Uint32(datum.Value[36:])\n\t\t\tcan.BitRatePreScalerMax = native.Uint32(datum.Value[40:])\n\t\t\tcan.BitRatePreScalerInc = native.Uint32(datum.Value[44:])\n\t\tcase nl.IFLA_CAN_CLOCK:\n\t\t\tcan.ClockFrequency = native.Uint32(datum.Value)\n\t\tcase nl.IFLA_CAN_STATE:\n\t\t\tcan.State = native.Uint32(datum.Value)\n\t\tcase nl.IFLA_CAN_CTRLMODE:\n\t\t\tcan.Mask = native.Uint32(datum.Value)\n\t\t\tcan.Flags = native.Uint32(datum.Value[4:])\n\t\tcase nl.IFLA_CAN_BERR_COUNTER:\n\t\t\tcan.TxError = native.Uint16(datum.Value)\n\t\t\tcan.RxError = native.Uint16(datum.Value[2:])\n\t\tcase nl.IFLA_CAN_RESTART_MS:\n\t\t\tcan.RestartMs = native.Uint32(datum.Value)\n\t\tcase nl.IFLA_CAN_DATA_BITTIMING_CONST:\n\t\tcase nl.IFLA_CAN_RESTART:\n\t\tcase nl.IFLA_CAN_DATA_BITTIMING:\n\t\tcase nl.IFLA_CAN_TERMINATION:\n\t\tcase nl.IFLA_CAN_TERMINATION_CONST:\n\t\tcase nl.IFLA_CAN_BITRATE_CONST:\n\t\tcase nl.IFLA_CAN_DATA_BITRATE_CONST:\n\t\tcase nl.IFLA_CAN_BITRATE_MAX:\n\t\t}\n\t}\n}\n\nfunc addIPoIBAttrs(ipoib *IPoIB, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\tdata.AddRtAttr(nl.IFLA_IPOIB_PKEY, nl.Uint16Attr(uint16(ipoib.Pkey)))\n\tdata.AddRtAttr(nl.IFLA_IPOIB_MODE, nl.Uint16Attr(uint16(ipoib.Mode)))\n\tdata.AddRtAttr(nl.IFLA_IPOIB_UMCAST, nl.Uint16Attr(uint16(ipoib.Umcast)))\n}\n\nfunc addBareUDPAttrs(bareudp *BareUDP, linkInfo *nl.RtAttr) {\n\tdata := linkInfo.AddRtAttr(nl.IFLA_INFO_DATA, nil)\n\n\tdata.AddRtAttr(nl.IFLA_BAREUDP_PORT, nl.Uint16Attr(nl.Swap16(bareudp.Port)))\n\tdata.AddRtAttr(nl.IFLA_BAREUDP_ETHERTYPE, nl.Uint16Attr(nl.Swap16(bareudp.EtherType)))\n\tif bareudp.SrcPortMin != 0 {\n\t\tdata.AddRtAttr(nl.IFLA_BAREUDP_SRCPORT_MIN, nl.Uint16Attr(bareudp.SrcPortMin))\n\t}\n\tif bareudp.MultiProto {\n\t\tdata.AddRtAttr(nl.IFLA_BAREUDP_MULTIPROTO_MODE, []byte{})\n\t}\n}\n\nfunc parseBareUDPData(link Link, data []syscall.NetlinkRouteAttr) {\n\tbareudp := link.(*BareUDP)\n\tfor _, attr := range data {\n\t\tswitch attr.Attr.Type {\n\t\tcase nl.IFLA_BAREUDP_PORT:\n\t\t\tbareudp.Port = binary.BigEndian.Uint16(attr.Value)\n\t\tcase nl.IFLA_BAREUDP_ETHERTYPE:\n\t\t\tbareudp.EtherType = binary.BigEndian.Uint16(attr.Value)\n\t\tcase nl.IFLA_BAREUDP_SRCPORT_MIN:\n\t\t\tbareudp.SrcPortMin = native.Uint16(attr.Value)\n\t\tcase nl.IFLA_BAREUDP_MULTIPROTO_MODE:\n\t\t\tbareudp.MultiProto = true\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "link_test.go",
          "type": "blob",
          "size": 78.62890625,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"sort\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\ttestTxQLen    int = 100\n\tdefaultTxQLen int = 1000\n\ttestTxQueues  int = 4\n\ttestRxQueues  int = 8\n)\n\nfunc testLinkAddDel(t *testing.T, link Link) {\n\t_, err := LinkList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbase := link.Attrs()\n\n\tresult, err := LinkByName(base.Name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trBase := result.Attrs()\n\n\tif base.Index != 0 {\n\t\tif base.Index != rBase.Index {\n\t\t\tt.Fatalf(\"index is %d, should be %d\", rBase.Index, base.Index)\n\t\t}\n\t}\n\n\tif base.Group > 0 {\n\t\tif base.Group != rBase.Group {\n\t\t\tt.Fatalf(\"group is %d, should be %d\", rBase.Group, base.Group)\n\t\t}\n\t}\n\n\tif vlan, ok := link.(*Vlan); ok {\n\t\tother, ok := result.(*Vlan)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a vlan\")\n\t\t}\n\t\tif vlan.VlanId != other.VlanId {\n\t\t\tt.Fatal(\"Link.VlanId id doesn't match\")\n\t\t}\n\t}\n\n\tif resultPrimary, ok := result.(*Netkit); ok {\n\t\tif inputPrimary, ok := link.(*Netkit); ok {\n\t\t\tif resultPrimary.Policy != inputPrimary.Policy {\n\t\t\t\tt.Fatalf(\"Policy is %d, should be %d\", int(resultPrimary.Policy), int(inputPrimary.Policy))\n\t\t\t}\n\t\t\tif resultPrimary.PeerPolicy != inputPrimary.PeerPolicy {\n\t\t\t\tt.Fatalf(\"Peer Policy is %d, should be %d\", int(resultPrimary.PeerPolicy), int(inputPrimary.PeerPolicy))\n\t\t\t}\n\t\t\tif resultPrimary.Mode != inputPrimary.Mode {\n\t\t\t\tt.Fatalf(\"Mode is %d, should be %d\", int(resultPrimary.Mode), int(inputPrimary.Mode))\n\t\t\t}\n\t\t\tif resultPrimary.SupportsScrub() && resultPrimary.Scrub != inputPrimary.Scrub {\n\t\t\t\tt.Fatalf(\"Scrub is %d, should be %d\", int(resultPrimary.Scrub), int(inputPrimary.Scrub))\n\t\t\t}\n\t\t\tif resultPrimary.SupportsScrub() && resultPrimary.PeerScrub != inputPrimary.PeerScrub {\n\t\t\t\tt.Fatalf(\"Peer Scrub is %d, should be %d\", int(resultPrimary.PeerScrub), int(inputPrimary.PeerScrub))\n\t\t\t}\n\n\t\t\tif inputPrimary.peerLinkAttrs.Name != \"\" {\n\t\t\t\tvar resultPeer *Netkit\n\t\t\t\tpLink, err := LinkByName(inputPrimary.peerLinkAttrs.Name)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"Failed to get Peer netkit %s\", inputPrimary.peerLinkAttrs.Name)\n\t\t\t\t}\n\t\t\t\tif resultPeer, ok = pLink.(*Netkit); !ok {\n\t\t\t\t\tt.Fatalf(\"Peer %s is incorrect type\", inputPrimary.peerLinkAttrs.Name)\n\t\t\t\t}\n\t\t\t\tif resultPrimary.PeerPolicy != resultPeer.Policy {\n\t\t\t\t\tt.Fatalf(\"Peer Policy from primary is %d, should be %d\", int(resultPrimary.PeerPolicy), int(resultPeer.Policy))\n\t\t\t\t}\n\t\t\t\tif resultPeer.PeerPolicy != resultPrimary.Policy {\n\t\t\t\t\tt.Fatalf(\"PeerPolicy from peer is %d, should be %d\", int(resultPeer.PeerPolicy), int(resultPrimary.Policy))\n\t\t\t\t}\n\t\t\t\tif resultPrimary.Mode != resultPeer.Mode {\n\t\t\t\t\tt.Fatalf(\"Peer Mode from primary is %d, should be %d\", int(resultPrimary.Mode), int(resultPeer.Mode))\n\t\t\t\t}\n\t\t\t\tif resultPrimary.IsPrimary() == resultPeer.IsPrimary() {\n\t\t\t\t\tt.Fatalf(\"Both primary and peer device has the same value in IsPrimary() %t\", resultPrimary.IsPrimary())\n\t\t\t\t}\n\t\t\t\tif resultPrimary.SupportsScrub() != resultPeer.SupportsScrub() {\n\t\t\t\t\tt.Fatalf(\"Peer SupportsScrub() should return %v\", resultPrimary.SupportsScrub())\n\t\t\t\t}\n\t\t\t\tif resultPrimary.PeerScrub != resultPeer.Scrub {\n\t\t\t\t\tt.Fatalf(\"Scrub from peer is %d, should be %d\", int(resultPeer.Scrub), int(resultPrimary.PeerScrub))\n\t\t\t\t}\n\t\t\t\tif resultPrimary.Scrub != resultPeer.PeerScrub {\n\t\t\t\t\tt.Fatalf(\"PeerScrub from peer is %d, should be %d\", int(resultPeer.PeerScrub), int(resultPrimary.Scrub))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif veth, ok := result.(*Veth); ok {\n\t\tif rBase.TxQLen != base.TxQLen {\n\t\t\tt.Fatalf(\"qlen is %d, should be %d\", rBase.TxQLen, base.TxQLen)\n\t\t}\n\n\t\tif rBase.NumTxQueues != base.NumTxQueues {\n\t\t\tt.Fatalf(\"txQueues is %d, should be %d\", rBase.NumTxQueues, base.NumTxQueues)\n\t\t}\n\n\t\tif rBase.NumRxQueues != base.NumRxQueues {\n\t\t\tt.Fatalf(\"rxQueues is %d, should be %d\", rBase.NumRxQueues, base.NumRxQueues)\n\t\t}\n\n\t\tif rBase.MTU != base.MTU {\n\t\t\tt.Fatalf(\"MTU is %d, should be %d\", rBase.MTU, base.MTU)\n\t\t}\n\n\t\tif original, ok := link.(*Veth); ok {\n\t\t\tif original.PeerName != \"\" {\n\t\t\t\tvar peer *Veth\n\t\t\t\tother, err := LinkByName(original.PeerName)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"Peer %s not created\", veth.PeerName)\n\t\t\t\t}\n\t\t\t\tif peer, ok = other.(*Veth); !ok {\n\t\t\t\t\tt.Fatalf(\"Peer %s is incorrect type\", veth.PeerName)\n\t\t\t\t}\n\t\t\t\tif peer.TxQLen != testTxQLen {\n\t\t\t\t\tt.Fatalf(\"TxQLen of peer is %d, should be %d\", peer.TxQLen, testTxQLen)\n\t\t\t\t}\n\t\t\t\tif peer.NumTxQueues != testTxQueues {\n\t\t\t\t\tt.Fatalf(\"NumTxQueues of peer is %d, should be %d\", peer.NumTxQueues, testTxQueues)\n\t\t\t\t}\n\t\t\t\tif peer.NumRxQueues != testRxQueues {\n\t\t\t\t\tt.Fatalf(\"NumRxQueues of peer is %d, should be %d\", peer.NumRxQueues, testRxQueues)\n\t\t\t\t}\n\t\t\t\tif !bytes.Equal(peer.Attrs().HardwareAddr, original.PeerHardwareAddr) {\n\t\t\t\t\tt.Fatalf(\"Peer MAC addr is %s, should be %s\", peer.Attrs().HardwareAddr, original.PeerHardwareAddr)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif _, ok := result.(*Veth); !ok {\n\t\tif _, ok := result.(*Netkit); !ok {\n\t\t\t// recent kernels set the parent index for veths/netkit in the response\n\t\t\tif rBase.ParentIndex == 0 && base.ParentIndex != 0 {\n\t\t\t\tt.Fatalf(\"Created link doesn't have parent %d but it should\", base.ParentIndex)\n\t\t\t} else if rBase.ParentIndex != 0 && base.ParentIndex == 0 {\n\t\t\t\tt.Fatalf(\"Created link has parent %d but it shouldn't\", rBase.ParentIndex)\n\t\t\t} else if rBase.ParentIndex != 0 && base.ParentIndex != 0 {\n\t\t\t\tif rBase.ParentIndex != base.ParentIndex {\n\t\t\t\t\tt.Fatalf(\"Link.ParentIndex doesn't match %d != %d\", rBase.ParentIndex, base.ParentIndex)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif _, ok := link.(*Wireguard); ok {\n\t\t_, ok := result.(*Wireguard)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a wireguard\")\n\t\t}\n\t}\n\n\tif vxlan, ok := link.(*Vxlan); ok {\n\t\tother, ok := result.(*Vxlan)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a vxlan\")\n\t\t}\n\t\tcompareVxlan(t, vxlan, other)\n\t}\n\n\tif ipv, ok := link.(*IPVlan); ok {\n\t\tother, ok := result.(*IPVlan)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a ipvlan\")\n\t\t}\n\t\tif ipv.Mode != other.Mode {\n\t\t\tt.Fatalf(\"Got unexpected mode: %d, expected: %d\", other.Mode, ipv.Mode)\n\t\t}\n\t\tif ipv.Flag != other.Flag {\n\t\t\tt.Fatalf(\"Got unexpected flag: %d, expected: %d\", other.Flag, ipv.Flag)\n\t\t}\n\t}\n\n\tif macv, ok := link.(*Macvlan); ok {\n\t\tother, ok := result.(*Macvlan)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a macvlan\")\n\t\t}\n\t\tif macv.Mode != other.Mode {\n\t\t\tt.Fatalf(\"Got unexpected mode: %d, expected: %d\", other.Mode, macv.Mode)\n\t\t}\n\t\tif other.BCQueueLen > 0 || other.UsedBCQueueLen > 0 {\n\t\t\tif other.UsedBCQueueLen < other.BCQueueLen {\n\t\t\t\tt.Fatalf(\"UsedBCQueueLen (%d) is smaller than BCQueueLen (%d)\", other.UsedBCQueueLen, other.BCQueueLen)\n\t\t\t}\n\t\t}\n\t\tif macv.BCQueueLen > 0 {\n\t\t\tif macv.BCQueueLen != other.BCQueueLen {\n\t\t\t\tt.Fatalf(\"BCQueueLen not set correctly: %d, expected: %d\", other.BCQueueLen, macv.BCQueueLen)\n\t\t\t}\n\t\t}\n\t}\n\n\tif macv, ok := link.(*Macvtap); ok {\n\t\tother, ok := result.(*Macvtap)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a macvtap\")\n\t\t}\n\t\tif macv.Mode != other.Mode {\n\t\t\tt.Fatalf(\"Got unexpected mode: %d, expected: %d\", other.Mode, macv.Mode)\n\t\t}\n\t\tif other.BCQueueLen > 0 || other.UsedBCQueueLen > 0 {\n\t\t\tif other.UsedBCQueueLen < other.BCQueueLen {\n\t\t\t\tt.Fatalf(\"UsedBCQueueLen (%d) is smaller than BCQueueLen (%d)\", other.UsedBCQueueLen, other.BCQueueLen)\n\t\t\t}\n\t\t}\n\t\tif macv.BCQueueLen > 0 {\n\t\t\tif macv.BCQueueLen != other.BCQueueLen {\n\t\t\t\tt.Fatalf(\"BCQueueLen not set correctly: %d, expected: %d\", other.BCQueueLen, macv.BCQueueLen)\n\t\t\t}\n\t\t}\n\t}\n\n\tif _, ok := link.(*Vti); ok {\n\t\t_, ok := result.(*Vti)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a vti\")\n\t\t}\n\t}\n\n\tif bond, ok := link.(*Bond); ok {\n\t\tother, ok := result.(*Bond)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a bond\")\n\t\t}\n\t\tif bond.Mode != other.Mode {\n\t\t\tt.Fatalf(\"Got unexpected mode: %d, expected: %d\", other.Mode, bond.Mode)\n\t\t}\n\t\tif bond.ArpIpTargets != nil {\n\t\t\tif other.ArpIpTargets == nil {\n\t\t\t\tt.Fatalf(\"Got unexpected ArpIpTargets: nil\")\n\t\t\t}\n\n\t\t\tif len(bond.ArpIpTargets) != len(other.ArpIpTargets) {\n\t\t\t\tt.Fatalf(\"Got unexpected ArpIpTargets len: %d, expected: %d\",\n\t\t\t\t\tlen(other.ArpIpTargets), len(bond.ArpIpTargets))\n\t\t\t}\n\n\t\t\tfor i := range bond.ArpIpTargets {\n\t\t\t\tif !bond.ArpIpTargets[i].Equal(other.ArpIpTargets[i]) {\n\t\t\t\t\tt.Fatalf(\"Got unexpected ArpIpTargets: %s, expected: %s\",\n\t\t\t\t\t\tother.ArpIpTargets[i], bond.ArpIpTargets[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch mode := bondModeToString[bond.Mode]; mode {\n\t\tcase \"802.3ad\":\n\t\t\tif bond.AdSelect != other.AdSelect {\n\t\t\t\tt.Fatalf(\"Got unexpected AdSelect: %d, expected: %d\", other.AdSelect, bond.AdSelect)\n\t\t\t}\n\t\t\tif bond.AdActorSysPrio != other.AdActorSysPrio {\n\t\t\t\tt.Fatalf(\"Got unexpected AdActorSysPrio: %d, expected: %d\", other.AdActorSysPrio, bond.AdActorSysPrio)\n\t\t\t}\n\t\t\tif bond.AdUserPortKey != other.AdUserPortKey {\n\t\t\t\tt.Fatalf(\"Got unexpected AdUserPortKey: %d, expected: %d\", other.AdUserPortKey, bond.AdUserPortKey)\n\t\t\t}\n\t\t\tif !bytes.Equal(bond.AdActorSystem, other.AdActorSystem) {\n\t\t\t\tt.Fatalf(\"Got unexpected AdActorSystem: %d, expected: %d\", other.AdActorSystem, bond.AdActorSystem)\n\t\t\t}\n\t\tcase \"balance-tlb\":\n\t\t\tif bond.TlbDynamicLb != other.TlbDynamicLb {\n\t\t\t\tt.Fatalf(\"Got unexpected TlbDynamicLb: %d, expected: %d\", other.TlbDynamicLb, bond.TlbDynamicLb)\n\t\t\t}\n\t\t}\n\t}\n\n\tif iptun, ok := link.(*Iptun); ok {\n\t\tother, ok := result.(*Iptun)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a iptun\")\n\t\t}\n\t\tif iptun.FlowBased != other.FlowBased {\n\t\t\tt.Fatal(\"Iptun.FlowBased doesn't match\")\n\t\t}\n\t}\n\n\tif ip6tnl, ok := link.(*Ip6tnl); ok {\n\t\tother, ok := result.(*Ip6tnl)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a ip6tnl\")\n\t\t}\n\t\tif ip6tnl.FlowBased != other.FlowBased {\n\t\t\tt.Fatal(\"Ip6tnl.FlowBased doesn't match\")\n\t\t}\n\n\t}\n\n\tif _, ok := link.(*Sittun); ok {\n\t\t_, ok := result.(*Sittun)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a sittun\")\n\t\t}\n\t}\n\n\tif geneve, ok := link.(*Geneve); ok {\n\t\tother, ok := result.(*Geneve)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a Geneve\")\n\t\t}\n\t\tcompareGeneve(t, geneve, other)\n\t}\n\n\tif gretap, ok := link.(*Gretap); ok {\n\t\tother, ok := result.(*Gretap)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a Gretap\")\n\t\t}\n\t\tcompareGretap(t, gretap, other)\n\t}\n\n\tif gretun, ok := link.(*Gretun); ok {\n\t\tother, ok := result.(*Gretun)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a Gretun\")\n\t\t}\n\t\tcompareGretun(t, gretun, other)\n\t}\n\n\tif xfrmi, ok := link.(*Xfrmi); ok {\n\t\tother, ok := result.(*Xfrmi)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a xfrmi\")\n\t\t}\n\t\tcompareXfrmi(t, xfrmi, other)\n\t}\n\n\tif tuntap, ok := link.(*Tuntap); ok {\n\t\tother, ok := result.(*Tuntap)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a tuntap\")\n\t\t}\n\t\tcompareTuntap(t, tuntap, other)\n\t}\n\n\tif bareudp, ok := link.(*BareUDP); ok {\n\t\tother, ok := result.(*BareUDP)\n\t\tif !ok {\n\t\t\tt.Fatal(\"Result of create is not a BareUDP\")\n\t\t}\n\t\tcompareBareUDP(t, bareudp, other)\n\t}\n\n\tif err = LinkDel(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlinks, err := LinkList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, l := range links {\n\t\tif l.Attrs().Name == link.Attrs().Name {\n\t\t\tt.Fatal(\"Link not removed properly\")\n\t\t}\n\t}\n}\n\nfunc compareGeneve(t *testing.T, expected, actual *Geneve) {\n\tif actual.ID != expected.ID {\n\t\tt.Fatalf(\"Geneve.ID doesn't match: %d %d\", actual.ID, expected.ID)\n\t}\n\n\t// set the Dport to 6081 (the linux default) if it wasn't specified at creation\n\tif expected.Dport == 0 {\n\t\texpected.Dport = 6081\n\t}\n\n\tif actual.Dport != expected.Dport {\n\t\tt.Fatal(\"Geneve.Dport doesn't match\")\n\t}\n\n\tif actual.Ttl != expected.Ttl {\n\t\tt.Fatal(\"Geneve.Ttl doesn't match\")\n\t}\n\n\tif actual.Tos != expected.Tos {\n\t\tt.Fatal(\"Geneve.Tos doesn't match\")\n\t}\n\n\tif !actual.Remote.Equal(expected.Remote) {\n\t\tt.Fatalf(\"Geneve.Remote is not equal: %s!=%s\", actual.Remote, expected.Remote)\n\t}\n\n\tif actual.FlowBased != expected.FlowBased {\n\t\tt.Fatal(\"Geneve.FlowBased doesn't match\")\n\t}\n\n\tif actual.InnerProtoInherit != expected.InnerProtoInherit {\n\t\tt.Fatal(\"Geneve.InnerProtoInherit doesn't match\")\n\t}\n\n\t// TODO: we should implement the rest of the geneve methods\n}\n\nfunc compareGretap(t *testing.T, expected, actual *Gretap) {\n\tif actual.IKey != expected.IKey {\n\t\tt.Fatal(\"Gretap.IKey doesn't match\")\n\t}\n\n\tif actual.OKey != expected.OKey {\n\t\tt.Fatal(\"Gretap.OKey doesn't match\")\n\t}\n\n\tif actual.EncapSport != expected.EncapSport {\n\t\tt.Fatal(\"Gretap.EncapSport doesn't match\")\n\t}\n\n\tif actual.EncapDport != expected.EncapDport {\n\t\tt.Fatal(\"Gretap.EncapDport doesn't match\")\n\t}\n\n\tif expected.Local != nil && !actual.Local.Equal(expected.Local) {\n\t\tt.Fatal(\"Gretap.Local doesn't match\")\n\t}\n\n\tif expected.Remote != nil && !actual.Remote.Equal(expected.Remote) {\n\t\tt.Fatal(\"Gretap.Remote doesn't match\")\n\t}\n\n\tif actual.IFlags != expected.IFlags {\n\t\tt.Fatal(\"Gretap.IFlags doesn't match\")\n\t}\n\n\tif actual.OFlags != expected.OFlags {\n\t\tt.Fatal(\"Gretap.OFlags doesn't match\")\n\t}\n\n\tif actual.PMtuDisc != expected.PMtuDisc {\n\t\tt.Fatal(\"Gretap.PMtuDisc doesn't match\")\n\t}\n\n\tif actual.Ttl != expected.Ttl {\n\t\tt.Fatal(\"Gretap.Ttl doesn't match\")\n\t}\n\n\tif actual.Tos != expected.Tos {\n\t\tt.Fatal(\"Gretap.Tos doesn't match\")\n\t}\n\n\tif actual.EncapType != expected.EncapType {\n\t\tt.Fatal(\"Gretap.EncapType doesn't match\")\n\t}\n\n\tif actual.EncapFlags != expected.EncapFlags {\n\t\tt.Fatal(\"Gretap.EncapFlags doesn't match\")\n\t}\n\n\tif actual.Link != expected.Link {\n\t\tt.Fatal(\"Gretap.Link doesn't match\")\n\t}\n\n\tif actual.FlowBased != expected.FlowBased {\n\t\tt.Fatal(\"Gretap.FlowBased doesn't match\")\n\t}\n}\n\nfunc compareGretun(t *testing.T, expected, actual *Gretun) {\n\tif actual.Link != expected.Link {\n\t\tt.Fatal(\"Gretun.Link doesn't match\")\n\t}\n\n\tif actual.IFlags != expected.IFlags {\n\t\tt.Fatal(\"Gretun.IFlags doesn't match\")\n\t}\n\n\tif actual.OFlags != expected.OFlags {\n\t\tt.Fatal(\"Gretun.OFlags doesn't match\")\n\t}\n\n\tif actual.IKey != expected.IKey {\n\t\tt.Fatal(\"Gretun.IKey doesn't match\")\n\t}\n\n\tif actual.OKey != expected.OKey {\n\t\tt.Fatal(\"Gretun.OKey doesn't match\")\n\t}\n\n\tif expected.Local != nil && !actual.Local.Equal(expected.Local) {\n\t\tt.Fatal(\"Gretun.Local doesn't match\")\n\t}\n\n\tif expected.Remote != nil && !actual.Remote.Equal(expected.Remote) {\n\t\tt.Fatal(\"Gretun.Remote doesn't match\")\n\t}\n\n\tif actual.Ttl != expected.Ttl {\n\t\tt.Fatal(\"Gretun.Ttl doesn't match\")\n\t}\n\n\tif actual.Tos != expected.Tos {\n\t\tt.Fatal(\"Gretun.Tos doesn't match\")\n\t}\n\n\tif actual.PMtuDisc != expected.PMtuDisc {\n\t\tt.Fatal(\"Gretun.PMtuDisc doesn't match\")\n\t}\n\n\tif actual.EncapType != expected.EncapType {\n\t\tt.Fatal(\"Gretun.EncapType doesn't match\")\n\t}\n\n\tif actual.EncapFlags != expected.EncapFlags {\n\t\tt.Fatal(\"Gretun.EncapFlags doesn't match\")\n\t}\n\n\tif actual.EncapSport != expected.EncapSport {\n\t\tt.Fatal(\"Gretun.EncapSport doesn't match\")\n\t}\n\n\tif actual.EncapDport != expected.EncapDport {\n\t\tt.Fatal(\"Gretun.EncapDport doesn't match\")\n\t}\n\tif actual.FlowBased != expected.FlowBased {\n\t\tt.Fatal(\"Gretun.FlowBased doesn't match\")\n\t}\n}\n\nfunc compareVxlan(t *testing.T, expected, actual *Vxlan) {\n\n\tif actual.VxlanId != expected.VxlanId {\n\t\tt.Fatal(\"Vxlan.VxlanId doesn't match\")\n\t}\n\tif expected.SrcAddr != nil && !actual.SrcAddr.Equal(expected.SrcAddr) {\n\t\tt.Fatal(\"Vxlan.SrcAddr doesn't match\")\n\t}\n\tif expected.Group != nil && !actual.Group.Equal(expected.Group) {\n\t\tt.Fatal(\"Vxlan.Group doesn't match\")\n\t}\n\tif expected.TTL != -1 && actual.TTL != expected.TTL {\n\t\tt.Fatal(\"Vxlan.TTL doesn't match\")\n\t}\n\tif expected.TOS != -1 && actual.TOS != expected.TOS {\n\t\tt.Fatal(\"Vxlan.TOS doesn't match\")\n\t}\n\tif actual.Learning != expected.Learning {\n\t\tt.Fatal(\"Vxlan.Learning doesn't match\")\n\t}\n\tif actual.Proxy != expected.Proxy {\n\t\tt.Fatal(\"Vxlan.Proxy doesn't match\")\n\t}\n\tif actual.RSC != expected.RSC {\n\t\tt.Fatal(\"Vxlan.RSC doesn't match\")\n\t}\n\tif actual.L2miss != expected.L2miss {\n\t\tt.Fatal(\"Vxlan.L2miss doesn't match\")\n\t}\n\tif actual.L3miss != expected.L3miss {\n\t\tt.Fatal(\"Vxlan.L3miss doesn't match\")\n\t}\n\tif actual.GBP != expected.GBP {\n\t\tt.Fatal(\"Vxlan.GBP doesn't match\")\n\t}\n\tif actual.FlowBased != expected.FlowBased {\n\t\tt.Fatal(\"Vxlan.FlowBased doesn't match\")\n\t}\n\tif actual.UDP6ZeroCSumTx != expected.UDP6ZeroCSumTx {\n\t\tt.Fatal(\"Vxlan.UDP6ZeroCSumTx doesn't match\")\n\t}\n\tif actual.UDP6ZeroCSumRx != expected.UDP6ZeroCSumRx {\n\t\tt.Fatal(\"Vxlan.UDP6ZeroCSumRx doesn't match\")\n\t}\n\tif expected.NoAge {\n\t\tif !actual.NoAge {\n\t\t\tt.Fatal(\"Vxlan.NoAge doesn't match\")\n\t\t}\n\t} else if expected.Age > 0 && actual.Age != expected.Age {\n\t\tt.Fatal(\"Vxlan.Age doesn't match\")\n\t}\n\tif expected.Limit > 0 && actual.Limit != expected.Limit {\n\t\tt.Fatal(\"Vxlan.Limit doesn't match\")\n\t}\n\tif expected.Port > 0 && actual.Port != expected.Port {\n\t\tt.Fatal(\"Vxlan.Port doesn't match\")\n\t}\n\tif expected.PortLow > 0 || expected.PortHigh > 0 {\n\t\tif actual.PortLow != expected.PortLow {\n\t\t\tt.Fatal(\"Vxlan.PortLow doesn't match\")\n\t\t}\n\t\tif actual.PortHigh != expected.PortHigh {\n\t\t\tt.Fatal(\"Vxlan.PortHigh doesn't match\")\n\t\t}\n\t}\n}\n\nfunc compareXfrmi(t *testing.T, expected, actual *Xfrmi) {\n\tif expected.Ifid != actual.Ifid {\n\t\tt.Fatal(\"Xfrmi.Ifid doesn't match\")\n\t}\n}\n\nfunc compareTuntap(t *testing.T, expected, actual *Tuntap) {\n\tif expected.Mode != actual.Mode {\n\t\tt.Fatalf(\"Tuntap.Mode doesn't match: expected : %+v, got %+v\", expected.Mode, actual.Mode)\n\t}\n\n\tif expected.Owner != actual.Owner {\n\t\tt.Fatal(\"Tuntap.Owner doesn't match\")\n\t}\n\n\tif expected.Group != actual.Group {\n\t\tt.Fatal(\"Tuntap.Group doesn't match\")\n\t}\n\n\tif expected.NonPersist != actual.NonPersist {\n\t\tt.Fatal(\"Tuntap.Group doesn't match\")\n\t}\n}\n\nfunc compareBareUDP(t *testing.T, expected, actual *BareUDP) {\n\t// set the Port to 6635 (the linux default) if it wasn't specified at creation\n\tif expected.Port == 0 {\n\t\texpected.Port = 6635\n\t}\n\tif actual.Port != expected.Port {\n\t\tt.Fatalf(\"BareUDP.Port doesn't match: %d %d\", actual.Port, expected.Port)\n\t}\n\n\tif actual.EtherType != expected.EtherType {\n\t\tt.Fatalf(\"BareUDP.EtherType doesn't match: %x %x\", actual.EtherType, expected.EtherType)\n\t}\n\n\tif actual.SrcPortMin != expected.SrcPortMin {\n\t\tt.Fatalf(\"BareUDP.SrcPortMin doesn't match: %d %d\", actual.SrcPortMin, expected.SrcPortMin)\n\t}\n\n\tif actual.MultiProto != expected.MultiProto {\n\t\tt.Fatal(\"BareUDP.MultiProto doesn't match\")\n\t}\n}\n\nfunc TestLinkAddDelWithIndex(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Dummy{LinkAttrs{Index: 1000, Name: \"foo\"}})\n}\n\nfunc TestLinkAddDelDummy(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Dummy{LinkAttrs{Name: \"foo\"}})\n}\n\nfunc TestLinkAddDelDummyWithGroup(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Dummy{LinkAttrs{Name: \"foo\", Group: 42}})\n}\n\nfunc TestLinkModify(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tlinkName := \"foo\"\n\toriginalMTU := 1500\n\tupdatedMTU := 1442\n\n\tlink := &Dummy{LinkAttrs{Name: linkName, MTU: originalMTU}}\n\tbase := link.Attrs()\n\n\tif err := LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink.MTU = updatedMTU\n\tif err := LinkModify(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresult, err := LinkByName(linkName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trBase := result.Attrs()\n\tif rBase.MTU != updatedMTU {\n\t\tt.Fatalf(\"MTU is %d, should be %d\", rBase.MTU, base.MTU)\n\t}\n}\n\nfunc TestLinkAddDelIfb(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Ifb{LinkAttrs{Name: \"foo\"}})\n}\n\nfunc TestLinkAddDelBridge(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Bridge{LinkAttrs: LinkAttrs{Name: \"foo\", MTU: 1400}})\n}\n\nfunc TestLinkAddDelGeneve(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Geneve{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo4\", EncapType: \"geneve\"},\n\t\tID:        0x1000,\n\t\tRemote:    net.IPv4(127, 0, 0, 1)})\n\n\ttestLinkAddDel(t, &Geneve{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo6\", EncapType: \"geneve\"},\n\t\tID:        0x1000,\n\t\tRemote:    net.ParseIP(\"2001:db8:ef33::2\")})\n}\n\nfunc TestLinkAddDelGeneveFlowBased(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Geneve{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo\"},\n\t\tDport:     1234,\n\t\tFlowBased: true})\n}\n\nfunc TestGeneveCompareToIP(t *testing.T) {\n\tns, tearDown := setUpNamedNetlinkTest(t)\n\tdefer tearDown()\n\n\texpected := &Geneve{\n\t\tID:     0x764332, // 23 bits\n\t\tRemote: net.ParseIP(\"1.2.3.4\"),\n\t\tDport:  6081,\n\t}\n\n\t// Create interface\n\tcmd := exec.Command(\"ip\", \"netns\", \"exec\", ns,\n\t\t\"ip\", \"link\", \"add\", \"gen0\",\n\t\t\"type\", \"geneve\",\n\t\t\"vni\", fmt.Sprint(expected.ID),\n\t\t\"remote\", expected.Remote.String(),\n\t\t// TODO: unit tests are currently done on ubuntu 16, and the version of iproute2 there doesn't support dstport\n\t\t// We can still do most of the testing by verifying that we do read the default port\n\t\t// \"dstport\", fmt.Sprint(expected.Dport),\n\t)\n\tout := &bytes.Buffer{}\n\tcmd.Stdout = out\n\tcmd.Stderr = out\n\n\tif rc := cmd.Run(); rc != nil {\n\t\tt.Fatal(\"failed creating link:\", rc, out.String())\n\t}\n\n\tlink, err := LinkByName(\"gen0\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed getting link: \", err)\n\t}\n\tactual, ok := link.(*Geneve)\n\tif !ok {\n\t\tt.Fatalf(\"resulted interface is not geneve: %T\", link)\n\t}\n\tcompareGeneve(t, expected, actual)\n}\n\nfunc TestLinkAddDelGretap(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Gretap{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo4\"},\n\t\tIKey:      0x101,\n\t\tOKey:      0x101,\n\t\tPMtuDisc:  1,\n\t\tLocal:     net.IPv4(127, 0, 0, 1),\n\t\tRemote:    net.IPv4(127, 0, 0, 1)})\n\n\ttestLinkAddDel(t, &Gretap{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo6\"},\n\t\tIKey:      0x101,\n\t\tOKey:      0x101,\n\t\tLocal:     net.ParseIP(\"2001:db8:abcd::1\"),\n\t\tRemote:    net.ParseIP(\"2001:db8:ef33::2\")})\n}\n\nfunc TestLinkAddDelGretun(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Gretun{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo4\"},\n\t\tLocal:     net.IPv4(127, 0, 0, 1),\n\t\tRemote:    net.IPv4(127, 0, 0, 1)})\n\n\ttestLinkAddDel(t, &Gretun{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo6\"},\n\t\tLocal:     net.ParseIP(\"2001:db8:abcd::1\"),\n\t\tRemote:    net.ParseIP(\"2001:db8:ef33::2\")})\n}\n\nfunc TestLinkAddDelGretunPointToMultiPoint(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Gretun{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo\"},\n\t\tLocal:     net.IPv4(127, 0, 0, 1),\n\t\tIKey:      1234,\n\t\tOKey:      1234})\n\n\ttestLinkAddDel(t, &Gretun{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo6\"},\n\t\tLocal:     net.ParseIP(\"2001:db8:1234::4\"),\n\t\tIKey:      5678,\n\t\tOKey:      7890})\n}\n\nfunc TestLinkAddDelGretunFlowBased(t *testing.T) {\n\tminKernelRequired(t, 4, 3)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Gretun{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo\"},\n\t\tFlowBased: true})\n}\n\nfunc TestLinkAddDelGretapFlowBased(t *testing.T) {\n\tminKernelRequired(t, 4, 3)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Gretap{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo\"},\n\t\tFlowBased: true})\n}\n\nfunc TestLinkAddDelVlan(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tparent := &Dummy{LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestLinkAddDel(t, &Vlan{LinkAttrs{Name: \"bar\", ParentIndex: parent.Attrs().Index}, 900, VLAN_PROTOCOL_8021Q})\n\n\tif err := LinkDel(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkAddDelMacvlan(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tparent := &Dummy{LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestLinkAddDel(t, &Macvlan{\n\t\tLinkAttrs: LinkAttrs{Name: \"bar\", ParentIndex: parent.Attrs().Index},\n\t\tMode:      MACVLAN_MODE_PRIVATE,\n\t})\n\n\ttestLinkAddDel(t, &Macvlan{\n\t\tLinkAttrs: LinkAttrs{Name: \"bar\", ParentIndex: parent.Attrs().Index},\n\t\tMode:      MACVLAN_MODE_BRIDGE,\n\t})\n\n\ttestLinkAddDel(t, &Macvlan{\n\t\tLinkAttrs: LinkAttrs{Name: \"bar\", ParentIndex: parent.Attrs().Index},\n\t\tMode:      MACVLAN_MODE_VEPA,\n\t})\n\n\tif err := LinkDel(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkAddDelMacvtap(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tparent := &Dummy{LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestLinkAddDel(t, &Macvtap{\n\t\tMacvlan: Macvlan{\n\t\t\tLinkAttrs: LinkAttrs{Name: \"bar\", ParentIndex: parent.Attrs().Index},\n\t\t\tMode:      MACVLAN_MODE_PRIVATE,\n\t\t},\n\t})\n\n\ttestLinkAddDel(t, &Macvtap{\n\t\tMacvlan: Macvlan{\n\t\t\tLinkAttrs: LinkAttrs{Name: \"bar\", ParentIndex: parent.Attrs().Index},\n\t\t\tMode:      MACVLAN_MODE_BRIDGE,\n\t\t},\n\t})\n\n\ttestLinkAddDel(t, &Macvtap{\n\t\tMacvlan: Macvlan{\n\t\t\tLinkAttrs: LinkAttrs{Name: \"bar\", ParentIndex: parent.Attrs().Index},\n\t\t\tMode:      MACVLAN_MODE_VEPA,\n\t\t},\n\t})\n\n\tif err := LinkDel(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkMacvBCQueueLen(t *testing.T) {\n\tminKernelRequired(t, 5, 11)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tparent := &Dummy{LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestLinkAddDel(t, &Macvlan{\n\t\tLinkAttrs:  LinkAttrs{Name: \"bar\", ParentIndex: parent.Attrs().Index},\n\t\tMode:       MACVLAN_MODE_PRIVATE,\n\t\tBCQueueLen: 10000,\n\t})\n\n\ttestLinkAddDel(t, &Macvtap{\n\t\tMacvlan: Macvlan{\n\t\t\tLinkAttrs:  LinkAttrs{Name: \"bar\", ParentIndex: parent.Attrs().Index},\n\t\t\tMode:       MACVLAN_MODE_PRIVATE,\n\t\t\tBCQueueLen: 10000,\n\t\t},\n\t})\n\n\tif err := LinkDel(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestNetkitPeerNs(t *testing.T) {\n\tminKernelRequired(t, 6, 7)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbasens, err := netns.Get()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get basens\")\n\t}\n\tdefer basens.Close()\n\n\tnsOne, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create nsOne\")\n\t}\n\tdefer nsOne.Close()\n\n\tnsTwo, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create nsTwo\")\n\t}\n\tdefer nsTwo.Close()\n\n\tnetkit := &Netkit{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: NsFd(basens),\n\t\t},\n\t\tMode:       NETKIT_MODE_L2,\n\t\tPolicy:     NETKIT_POLICY_FORWARD,\n\t\tPeerPolicy: NETKIT_POLICY_BLACKHOLE,\n\t}\n\tpeerAttr := &LinkAttrs{\n\t\tName:      \"bar\",\n\t\tNamespace: NsFd(nsOne),\n\t}\n\tnetkit.SetPeerAttrs(peerAttr)\n\n\tif err := LinkAdd(netkit); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = LinkByName(\"bar\")\n\tif err == nil {\n\t\tt.Fatal(\"netkit link bar is in nsTwo\")\n\t}\n\n\t_, err = LinkByName(\"foo\")\n\tif err == nil {\n\t\tt.Fatal(\"netkit link foo is in nsTwo\")\n\t}\n\n\terr = netns.Set(basens)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to set basens\")\n\t}\n\n\t_, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(\"netkit link foo is not in basens\")\n\t}\n\n\terr = netns.Set(nsOne)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to set nsOne\")\n\t}\n\n\t_, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(\"netkit link bar is not in nsOne\")\n\t}\n}\n\nfunc TestLinkAddDelNetkit(t *testing.T) {\n\tminKernelRequired(t, 6, 7)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tnetkit := &Netkit{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName: \"foo\",\n\t\t},\n\t\tMode:       NETKIT_MODE_L2,\n\t\tPolicy:     NETKIT_POLICY_FORWARD,\n\t\tPeerPolicy: NETKIT_POLICY_BLACKHOLE,\n\t\tScrub:      NETKIT_SCRUB_DEFAULT,\n\t\tPeerScrub:  NETKIT_SCRUB_NONE,\n\t}\n\tpeerAttr := &LinkAttrs{\n\t\tName: \"bar\",\n\t}\n\tnetkit.SetPeerAttrs(peerAttr)\n\ttestLinkAddDel(t, netkit)\n}\n\nfunc TestLinkAddDelVeth(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tpeerMAC, _ := net.ParseMAC(\"00:12:34:56:78:02\")\n\n\tveth := &Veth{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName:        \"foo\",\n\t\t\tTxQLen:      testTxQLen,\n\t\t\tMTU:         1400,\n\t\t\tNumTxQueues: testTxQueues,\n\t\t\tNumRxQueues: testRxQueues,\n\t\t},\n\t\tPeerName:         \"bar\",\n\t\tPeerHardwareAddr: peerMAC,\n\t}\n\ttestLinkAddDel(t, veth)\n}\n\nfunc TestLinkAddDelBond(t *testing.T) {\n\tminKernelRequired(t, 3, 13)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tmodes := []string{\"802.3ad\", \"balance-tlb\"}\n\tfor _, mode := range modes {\n\t\tbond := NewLinkBond(LinkAttrs{Name: \"foo\"})\n\t\tbond.Mode = StringToBondModeMap[mode]\n\t\tswitch mode {\n\t\tcase \"802.3ad\":\n\t\t\tbond.AdSelect = BondAdSelect(BOND_AD_SELECT_BANDWIDTH)\n\t\t\tbond.AdActorSysPrio = 1\n\t\t\tbond.AdUserPortKey = 1\n\t\t\tbond.AdActorSystem, _ = net.ParseMAC(\"06:aa:bb:cc:dd:ee\")\n\t\t\tbond.ArpIpTargets = []net.IP{net.ParseIP(\"1.1.1.1\"), net.ParseIP(\"1.1.1.2\")}\n\t\tcase \"balance-tlb\":\n\t\t\tbond.TlbDynamicLb = 1\n\t\t\tbond.ArpIpTargets = []net.IP{net.ParseIP(\"1.1.1.2\"), net.ParseIP(\"1.1.1.1\")}\n\t\t}\n\t\ttestLinkAddDel(t, bond)\n\t}\n}\n\nfunc TestLinkAddVethWithDefaultTxQLen(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tla := NewLinkAttrs()\n\tla.Name = \"foo\"\n\n\tveth := &Veth{LinkAttrs: la, PeerName: \"bar\"}\n\tif err := LinkAdd(veth); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif veth, ok := link.(*Veth); !ok {\n\t\tt.Fatalf(\"unexpected link type: %T\", link)\n\t} else {\n\t\tif veth.TxQLen != defaultTxQLen {\n\t\t\tt.Fatalf(\"TxQLen is %d, should be %d\", veth.TxQLen, defaultTxQLen)\n\t\t}\n\t}\n\tpeer, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif veth, ok := peer.(*Veth); !ok {\n\t\tt.Fatalf(\"unexpected link type: %T\", link)\n\t} else {\n\t\tif veth.TxQLen != defaultTxQLen {\n\t\t\tt.Fatalf(\"TxQLen is %d, should be %d\", veth.TxQLen, defaultTxQLen)\n\t\t}\n\t}\n}\n\nfunc TestLinkAddVethWithZeroTxQLen(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tla := NewLinkAttrs()\n\tla.Name = \"foo\"\n\tla.TxQLen = 0\n\n\tveth := &Veth{LinkAttrs: la, PeerName: \"bar\"}\n\tif err := LinkAdd(veth); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif veth, ok := link.(*Veth); !ok {\n\t\tt.Fatalf(\"unexpected link type: %T\", link)\n\t} else {\n\t\tif veth.TxQLen != 0 {\n\t\t\tt.Fatalf(\"TxQLen is %d, should be %d\", veth.TxQLen, 0)\n\t\t}\n\t}\n\tpeer, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif veth, ok := peer.(*Veth); !ok {\n\t\tt.Fatalf(\"unexpected link type: %T\", link)\n\t} else {\n\t\tif veth.TxQLen != 0 {\n\t\t\tt.Fatalf(\"TxQLen is %d, should be %d\", veth.TxQLen, 0)\n\t\t}\n\t}\n}\n\nfunc TestLinkAddDelDummyWithGSO(t *testing.T) {\n\tconst (\n\t\tgsoMaxSegs = 16\n\t\tgsoMaxSize = 1 << 14\n\t)\n\tminKernelRequired(t, 4, 16)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tdummy := &Dummy{LinkAttrs: LinkAttrs{Name: \"foo\", GSOMaxSize: gsoMaxSize, GSOMaxSegs: gsoMaxSegs}}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdummy, ok := link.(*Dummy)\n\tif !ok {\n\t\tt.Fatalf(\"unexpected link type: %T\", link)\n\t}\n\n\tif dummy.GSOMaxSize != gsoMaxSize {\n\t\tt.Fatalf(\"GSOMaxSize is %d, should be %d\", dummy.GSOMaxSize, gsoMaxSize)\n\t}\n\tif dummy.GSOMaxSegs != gsoMaxSegs {\n\t\tt.Fatalf(\"GSOMaxSeg is %d, should be %d\", dummy.GSOMaxSegs, gsoMaxSegs)\n\t}\n}\n\nfunc TestLinkAddDelDummyWithGRO(t *testing.T) {\n\tconst (\n\t\tgroMaxSize = 1 << 14\n\t)\n\tminKernelRequired(t, 5, 19)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tdummy := &Dummy{LinkAttrs: LinkAttrs{Name: \"foo\", GROMaxSize: groMaxSize}}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdummy, ok := link.(*Dummy)\n\tif !ok {\n\t\tt.Fatalf(\"unexpected link type: %T\", link)\n\t}\n\n\tif dummy.GROMaxSize != groMaxSize {\n\t\tt.Fatalf(\"GROMaxSize is %d, should be %d\", dummy.GROMaxSize, groMaxSize)\n\t}\n}\n\nfunc TestLinkAddDummyWithTxQLen(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tla := NewLinkAttrs()\n\tla.Name = \"foo\"\n\tla.TxQLen = 1500\n\n\tdummy := &Dummy{LinkAttrs: la}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif dummy, ok := link.(*Dummy); !ok {\n\t\tt.Fatalf(\"unexpected link type: %T\", link)\n\t} else {\n\t\tif dummy.TxQLen != 1500 {\n\t\t\tt.Fatalf(\"TxQLen is %d, should be %d\", dummy.TxQLen, 1500)\n\t\t}\n\t}\n}\n\nfunc TestLinkAddDelBridgeMaster(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tmaster := &Bridge{LinkAttrs: LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(master); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestLinkAddDel(t, &Dummy{LinkAttrs{Name: \"bar\", MasterIndex: master.Attrs().Index}})\n\n\tif err := LinkDel(master); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc testLinkSetUnsetResetMaster(t *testing.T, master, newmaster Link) {\n\tslave := &Dummy{LinkAttrs{Name: \"baz\"}}\n\tif err := LinkAdd(slave); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tnonexistsmaster := &Bridge{LinkAttrs: LinkAttrs{Name: \"foobar\"}}\n\n\tif err := LinkSetMaster(slave, nonexistsmaster); err == nil {\n\t\tt.Fatal(\"error expected\")\n\t}\n\n\tif err := LinkSetMaster(slave, master); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"baz\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().MasterIndex != master.Attrs().Index {\n\t\tt.Fatal(\"Master not set properly\")\n\t}\n\n\tif err := LinkSetMaster(slave, newmaster); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"baz\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().MasterIndex != newmaster.Attrs().Index {\n\t\tt.Fatal(\"Master not reset properly\")\n\t}\n\n\tif err := LinkSetNoMaster(slave); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"baz\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().MasterIndex != 0 {\n\t\tt.Fatal(\"Master not unset properly\")\n\t}\n\tif err := LinkDel(slave); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkSetUnsetResetMaster(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tmaster := &Bridge{LinkAttrs: LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(master); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tnewmaster := &Bridge{LinkAttrs: LinkAttrs{Name: \"bar\"}}\n\tif err := LinkAdd(newmaster); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestLinkSetUnsetResetMaster(t, master, newmaster)\n\n\tif err := LinkDel(newmaster); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkDel(master); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkSetUnsetResetMasterBond(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tmaster := NewLinkBond(LinkAttrs{Name: \"foo\"})\n\tmaster.Mode = BOND_MODE_BALANCE_RR\n\tif err := LinkAdd(master); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tnewmaster := NewLinkBond(LinkAttrs{Name: \"bar\"})\n\tnewmaster.Mode = BOND_MODE_BALANCE_RR\n\tif err := LinkAdd(newmaster); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestLinkSetUnsetResetMaster(t, master, newmaster)\n\n\tif err := LinkDel(newmaster); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkDel(master); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkSetNs(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbasens, err := netns.Get()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get basens\")\n\t}\n\tdefer basens.Close()\n\n\tnewns, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create newns\")\n\t}\n\tdefer newns.Close()\n\n\tlink := &Veth{LinkAttrs{Name: \"foo\"}, \"bar\", nil, nil}\n\tif err := LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpeer, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tLinkSetNsFd(peer, int(basens))\n\tif err != nil {\n\t\tt.Fatal(\"Failed to set newns for link\")\n\t}\n\n\t_, err = LinkByName(\"bar\")\n\tif err == nil {\n\t\tt.Fatal(\"Link bar is still in newns\")\n\t}\n\n\terr = netns.Set(basens)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to set basens\")\n\t}\n\n\tpeer, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(\"Link is not in basens\")\n\t}\n\n\tif err := LinkDel(peer); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = netns.Set(newns)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to set newns\")\n\t}\n\n\t_, err = LinkByName(\"foo\")\n\tif err == nil {\n\t\tt.Fatal(\"Other half of veth pair not deleted\")\n\t}\n\n}\n\nfunc TestLinkAddDelWireguard(t *testing.T) {\n\tminKernelRequired(t, 5, 6)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Wireguard{LinkAttrs: LinkAttrs{Name: \"wg0\"}})\n}\n\nfunc TestVethPeerNs(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbasens, err := netns.Get()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get basens\")\n\t}\n\tdefer basens.Close()\n\n\tnewns, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create newns\")\n\t}\n\tdefer newns.Close()\n\n\tlink := &Veth{LinkAttrs{Name: \"foo\"}, \"bar\", nil, NsFd(basens)}\n\tif err := LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = LinkByName(\"bar\")\n\tif err == nil {\n\t\tt.Fatal(\"Link bar is in newns\")\n\t}\n\n\terr = netns.Set(basens)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to set basens\")\n\t}\n\n\t_, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(\"Link bar is not in basens\")\n\t}\n\n\terr = netns.Set(newns)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to set newns\")\n\t}\n\n\t_, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Link foo is not in newns\")\n\t}\n}\n\nfunc TestVethPeerNs2(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbasens, err := netns.Get()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get basens\")\n\t}\n\tdefer basens.Close()\n\n\tonens, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create newns\")\n\t}\n\tdefer onens.Close()\n\n\ttwons, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create twons\")\n\t}\n\tdefer twons.Close()\n\n\tlink := &Veth{LinkAttrs{Name: \"foo\", Namespace: NsFd(onens)}, \"bar\", nil, NsFd(basens)}\n\tif err := LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = LinkByName(\"foo\")\n\tif err == nil {\n\t\tt.Fatal(\"Link foo is in twons\")\n\t}\n\n\t_, err = LinkByName(\"bar\")\n\tif err == nil {\n\t\tt.Fatal(\"Link bar is in twons\")\n\t}\n\n\terr = netns.Set(basens)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to set basens\")\n\t}\n\n\t_, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(\"Link bar is not in basens\")\n\t}\n\n\terr = netns.Set(onens)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to set onens\")\n\t}\n\n\t_, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Link foo is not in onens\")\n\t}\n}\n\nfunc TestLinkAddDelVxlan(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tparent := &Dummy{\n\t\tLinkAttrs{Name: \"foo\"},\n\t}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvxlan := Vxlan{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName: \"bar\",\n\t\t},\n\t\tVxlanId:      10,\n\t\tVtepDevIndex: parent.Index,\n\t\tLearning:     true,\n\t\tL2miss:       true,\n\t\tL3miss:       true,\n\t}\n\n\ttestLinkAddDel(t, &vxlan)\n\tif err := LinkDel(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkAddDelVxlanUdpCSum6(t *testing.T) {\n\tminKernelRequired(t, 3, 16)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tparent := &Dummy{\n\t\tLinkAttrs{Name: \"foo\"},\n\t}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvxlan := Vxlan{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName: \"bar\",\n\t\t},\n\t\tVxlanId:        10,\n\t\tVtepDevIndex:   parent.Index,\n\t\tLearning:       true,\n\t\tL2miss:         true,\n\t\tL3miss:         true,\n\t\tUDP6ZeroCSumTx: true,\n\t\tUDP6ZeroCSumRx: true,\n\t}\n\n\ttestLinkAddDel(t, &vxlan)\n\tif err := LinkDel(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkAddDelVxlanGbp(t *testing.T) {\n\tminKernelRequired(t, 4, 0)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tparent := &Dummy{\n\t\tLinkAttrs{Name: \"foo\"},\n\t}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvxlan := Vxlan{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName: \"bar\",\n\t\t},\n\t\tVxlanId:        10,\n\t\tVtepDevIndex:   parent.Index,\n\t\tLearning:       true,\n\t\tL2miss:         true,\n\t\tL3miss:         true,\n\t\tUDP6ZeroCSumTx: true,\n\t\tUDP6ZeroCSumRx: true,\n\t\tGBP:            true,\n\t}\n\n\ttestLinkAddDel(t, &vxlan)\n\tif err := LinkDel(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkAddDelVxlanFlowBased(t *testing.T) {\n\tminKernelRequired(t, 4, 3)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tvxlan := Vxlan{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName: \"foo\",\n\t\t},\n\t\tLearning:  false,\n\t\tFlowBased: true,\n\t}\n\n\ttestLinkAddDel(t, &vxlan)\n}\n\nfunc TestLinkAddDelBareUDP(t *testing.T) {\n\tminKernelRequired(t, 5, 1)\n\tsetUpNetlinkTestWithKModule(t, \"bareudp\")\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &BareUDP{\n\t\tLinkAttrs:  LinkAttrs{Name: \"foo99\"},\n\t\tPort:       6635,\n\t\tEtherType:  syscall.ETH_P_MPLS_UC,\n\t\tSrcPortMin: 12345,\n\t\tMultiProto: true,\n\t})\n\n\ttestLinkAddDel(t, &BareUDP{\n\t\tLinkAttrs:  LinkAttrs{Name: \"foo100\"},\n\t\tPort:       6635,\n\t\tEtherType:  syscall.ETH_P_IP,\n\t\tSrcPortMin: 12345,\n\t\tMultiProto: true,\n\t})\n}\n\nfunc TestBareUDPCompareToIP(t *testing.T) {\n\tif os.Getenv(\"CI\") == \"true\" {\n\t\tt.Skipf(\"Fails in CI due to old iproute2\")\n\t}\n\t// requires iproute2 >= 5.10\n\tminKernelRequired(t, 5, 9)\n\tsetUpNetlinkTestWithKModule(t, \"bareudp\")\n\tns, tearDown := setUpNamedNetlinkTest(t)\n\tdefer tearDown()\n\n\texpected := &BareUDP{\n\t\tPort:       uint16(6635),\n\t\tEtherType:  syscall.ETH_P_MPLS_UC,\n\t\tSrcPortMin: 12345,\n\t\tMultiProto: true,\n\t}\n\n\t// Create interface\n\tcmd := exec.Command(\"ip\", \"netns\", \"exec\", ns,\n\t\t\"ip\", \"link\", \"add\", \"b0\",\n\t\t\"type\", \"bareudp\",\n\t\t\"dstport\", fmt.Sprint(expected.Port),\n\t\t\"ethertype\", \"mpls_uc\",\n\t\t\"srcportmin\", fmt.Sprint(expected.SrcPortMin),\n\t\t\"multiproto\",\n\t)\n\tout := &bytes.Buffer{}\n\tcmd.Stdout = out\n\tcmd.Stderr = out\n\n\tif rc := cmd.Run(); rc != nil {\n\t\tt.Fatal(\"failed creating link:\", rc, out.String())\n\t}\n\n\tlink, err := LinkByName(\"b0\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed getting link: \", err)\n\t}\n\tactual, ok := link.(*BareUDP)\n\tif !ok {\n\t\tt.Fatalf(\"resulted interface is not BareUDP: %T\", link)\n\t}\n\tcompareBareUDP(t, expected, actual)\n}\n\nfunc TestLinkAddDelIPVlanL2(t *testing.T) {\n\tminKernelRequired(t, 4, 2)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tparent := &Dummy{LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tipv := IPVlan{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName:        \"bar\",\n\t\t\tParentIndex: parent.Index,\n\t\t},\n\t\tMode: IPVLAN_MODE_L2,\n\t}\n\n\ttestLinkAddDel(t, &ipv)\n}\n\nfunc TestLinkAddDelIPVlanL3(t *testing.T) {\n\tminKernelRequired(t, 4, 2)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tparent := &Dummy{LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tipv := IPVlan{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName:        \"bar\",\n\t\t\tParentIndex: parent.Index,\n\t\t},\n\t\tMode: IPVLAN_MODE_L3,\n\t}\n\n\ttestLinkAddDel(t, &ipv)\n}\n\nfunc TestLinkAddDelIPVlanVepa(t *testing.T) {\n\tminKernelRequired(t, 4, 15)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tparent := &Dummy{LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tipv := IPVlan{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName:        \"bar\",\n\t\t\tParentIndex: parent.Index,\n\t\t},\n\t\tMode: IPVLAN_MODE_L3,\n\t\tFlag: IPVLAN_FLAG_VEPA,\n\t}\n\n\ttestLinkAddDel(t, &ipv)\n}\n\nfunc TestLinkAddDelIPVlanNoParent(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tipv := IPVlan{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName: \"bar\",\n\t\t},\n\t\tMode: IPVLAN_MODE_L3,\n\t}\n\terr := LinkAdd(&ipv)\n\tif err == nil {\n\t\tt.Fatal(\"Add should fail if ipvlan creating without ParentIndex\")\n\t}\n\tif err.Error() != \"Can't create ipvlan link without ParentIndex\" {\n\t\tt.Fatalf(\"Error should be about missing ParentIndex, got %q\", err)\n\t}\n}\n\nfunc TestLinkByIndex(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tdummy := &Dummy{LinkAttrs{Name: \"dummy\"}}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfound, err := LinkByIndex(dummy.Index)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif found.Attrs().Index != dummy.Attrs().Index {\n\t\tt.Fatalf(\"Indices don't match: %v != %v\", found.Attrs().Index, dummy.Attrs().Index)\n\t}\n\n\tLinkDel(dummy)\n\n\t// test not found\n\t_, err = LinkByIndex(dummy.Attrs().Index)\n\tif err == nil {\n\t\tt.Fatalf(\"LinkByIndex(%v) found deleted link\", err)\n\t}\n}\n\nfunc TestLinkSet(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Dummy{LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetName(link, \"bar\")\n\tif err != nil {\n\t\tt.Fatalf(\"Could not change interface name: %v\", err)\n\t}\n\n\tlink, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatalf(\"Interface name not changed: %v\", err)\n\t}\n\n\terr = LinkSetMTU(link, 1400)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not set MTU: %v\", err)\n\t}\n\n\tlink, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().MTU != 1400 {\n\t\tt.Fatal(\"MTU not changed\")\n\t}\n\n\terr = LinkSetTxQLen(link, 500)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not set txqlen: %v\", err)\n\t}\n\n\tlink, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().TxQLen != 500 {\n\t\tt.Fatal(\"txqlen not changed\")\n\t}\n\n\taddr, err := net.ParseMAC(\"00:12:34:56:78:AB\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetHardwareAddr(link, addr)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !bytes.Equal(link.Attrs().HardwareAddr, addr) {\n\t\tt.Fatalf(\"hardware address not changed\")\n\t}\n\n\terr = LinkSetAlias(link, \"barAlias\")\n\tif err != nil {\n\t\tt.Fatalf(\"Could not set alias: %v\", err)\n\t}\n\n\tlink, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().Alias != \"barAlias\" {\n\t\tt.Fatalf(\"alias not changed\")\n\t}\n\n\tlink, err = LinkByAlias(\"barAlias\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetGroup(link, 42)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not set group: %v\", err)\n\t}\n\n\tlink, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().Group != 42 {\n\t\tt.Fatal(\"Link group not changed\")\n\t}\n}\n\nfunc TestLinkAltName(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Dummy{LinkAttrs{Name: \"bar\"}}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\taltNames := []string{\"altname\", \"altname2\", \"some_longer_altname\"}\n\tsort.Strings(altNames)\n\taltNamesStr := strings.Join(altNames, \",\")\n\n\tfor _, altname := range altNames {\n\t\terr = LinkAddAltName(link, altname)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not add %s: %v\", altname, err)\n\t\t}\n\t}\n\n\tlink, err = LinkByName(\"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsort.Strings(link.Attrs().AltNames)\n\tlinkAltNamesStr := strings.Join(link.Attrs().AltNames, \",\")\n\n\tif altNamesStr != linkAltNamesStr {\n\t\tt.Fatalf(\"Expected %s AltNames, got %s\", altNamesStr, linkAltNamesStr)\n\t}\n\n\tfor _, altname := range altNames {\n\t\tlink, err = LinkByName(altname)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tfor idx, altName := range altNames {\n\t\terr = LinkDelAltName(link, altName)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not delete %s: %v\", altName, err)\n\t\t}\n\n\t\tlink, err = LinkByName(\"bar\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tsort.Strings(link.Attrs().AltNames)\n\t\tlinkAltNamesStr := strings.Join(link.Attrs().AltNames, \",\")\n\t\taltNamesStr := strings.Join(altNames[idx+1:], \",\")\n\n\t\tif linkAltNamesStr != altNamesStr {\n\t\t\tt.Fatalf(\"Expected %s AltNames, got %s\", altNamesStr, linkAltNamesStr)\n\t\t}\n\t}\n\n}\n\nfunc TestLinkSetARP(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Veth{LinkAttrs: LinkAttrs{Name: \"foo\", TxQLen: testTxQLen, MTU: 1500}, PeerName: \"banana\"}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetARPOff(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().RawFlags&unix.IFF_NOARP != uint32(unix.IFF_NOARP) {\n\t\tt.Fatalf(\"NOARP was not set\")\n\t}\n\n\terr = LinkSetARPOn(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().RawFlags&unix.IFF_NOARP != 0 {\n\t\tt.Fatalf(\"NOARP is still set\")\n\t}\n}\n\nfunc expectLinkUpdate(ch <-chan LinkUpdate, ifaceName string, up bool) bool {\n\tfor {\n\t\ttimeout := time.After(time.Minute)\n\t\tselect {\n\t\tcase update := <-ch:\n\t\t\tif ifaceName == update.Link.Attrs().Name && (update.IfInfomsg.Flags&unix.IFF_UP != 0) == up {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase <-timeout:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunc TestLinkSubscribe(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tch := make(chan LinkUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := LinkSubscribe(ch, done); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink := &Veth{LinkAttrs{Name: \"foo\", TxQLen: testTxQLen, MTU: 1400}, \"bar\", nil, nil}\n\tif err := LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"foo\", false) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"foo\", true) {\n\t\tt.Fatal(\"Link Up update not received as expected\")\n\t}\n\n\tif err := LinkDel(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"foo\", false) {\n\t\tt.Fatal(\"Del update not received as expected\")\n\t}\n}\n\nfunc TestLinkSubscribeWithOptions(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tch := make(chan LinkUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tvar lastError error\n\tdefer func() {\n\t\tif lastError != nil {\n\t\t\tt.Fatalf(\"Fatal error received during subscription: %v\", lastError)\n\t\t}\n\t}()\n\tif err := LinkSubscribeWithOptions(ch, done, LinkSubscribeOptions{\n\t\tErrorCallback: func(err error) {\n\t\t\tlastError = err\n\t\t},\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink := &Veth{LinkAttrs{Name: \"foo\", TxQLen: testTxQLen, MTU: 1400}, \"bar\", nil, nil}\n\tif err := LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"foo\", false) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n}\n\nfunc TestLinkSubscribeAt(t *testing.T) {\n\tskipUnlessRoot(t)\n\n\t// Create an handle on a custom netns\n\tnewNs, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer newNs.Close()\n\n\tnh, err := NewHandleAt(newNs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer nh.Close()\n\n\t// Subscribe for Link events on the custom netns\n\tch := make(chan LinkUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := LinkSubscribeAt(newNs, ch, done); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink := &Veth{LinkAttrs{Name: \"test\", TxQLen: testTxQLen, MTU: 1400}, \"bar\", nil, nil}\n\tif err := nh.LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"test\", false) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n\n\tif err := nh.LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"test\", true) {\n\t\tt.Fatal(\"Link Up update not received as expected\")\n\t}\n\n\tif err := nh.LinkDel(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"test\", false) {\n\t\tt.Fatal(\"Del update not received as expected\")\n\t}\n}\n\nfunc TestLinkSubscribeListExisting(t *testing.T) {\n\tskipUnlessRoot(t)\n\n\t// Create an handle on a custom netns\n\tnewNs, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer newNs.Close()\n\n\tnh, err := NewHandleAt(newNs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer nh.Close()\n\n\tlink := &Veth{LinkAttrs{Name: \"test\", TxQLen: testTxQLen, MTU: 1400}, \"bar\", nil, nil}\n\tif err := nh.LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Subscribe for Link events on the custom netns\n\tch := make(chan LinkUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := LinkSubscribeWithOptions(ch, done, LinkSubscribeOptions{\n\t\tNamespace:    &newNs,\n\t\tListExisting: true},\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"test\", false) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n\n\tif err := nh.LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"test\", true) {\n\t\tt.Fatal(\"Link Up update not received as expected\")\n\t}\n\n\tif err := nh.LinkDel(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectLinkUpdate(ch, \"test\", false) {\n\t\tt.Fatal(\"Del update not received as expected\")\n\t}\n}\n\nfunc TestLinkStats(t *testing.T) {\n\tdefer setUpNetlinkTest(t)()\n\n\t// Create a veth pair and verify the cross-stats once both\n\t// ends are brought up and some ICMPv6 packets are exchanged\n\tv0 := \"v0\"\n\tv1 := \"v1\"\n\n\tvethLink := &Veth{LinkAttrs: LinkAttrs{Name: v0}, PeerName: v1}\n\tif err := LinkAdd(vethLink); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tveth0, err := LinkByName(v0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(veth0); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tveth1, err := LinkByName(v1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(veth1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttime.Sleep(2 * time.Second)\n\n\t// verify statistics\n\tveth0, err = LinkByName(v0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tveth1, err = LinkByName(v1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tv0Stats := veth0.Attrs().Statistics\n\tv1Stats := veth1.Attrs().Statistics\n\tif v0Stats.RxPackets != v1Stats.TxPackets || v0Stats.TxPackets != v1Stats.RxPackets ||\n\t\tv0Stats.RxBytes != v1Stats.TxBytes || v0Stats.TxBytes != v1Stats.RxBytes {\n\t\tt.Fatalf(\"veth ends counters differ:\\n%v\\n%v\", v0Stats, v1Stats)\n\t}\n}\n\nfunc TestLinkXdp(t *testing.T) {\n\tlinks, err := LinkList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar testXdpLink Link\n\tfor _, link := range links {\n\t\tif link.Attrs().Xdp != nil && !link.Attrs().Xdp.Attached {\n\t\t\ttestXdpLink = link\n\t\t\tbreak\n\t\t}\n\t}\n\tif testXdpLink == nil {\n\t\tt.Skipf(\"No link supporting XDP found\")\n\t}\n\tfd, err := loadSimpleBpf(BPF_PROG_TYPE_XDP, 2 /*XDP_PASS*/)\n\tif err != nil {\n\t\tt.Skipf(\"Loading bpf program failed: %s\", err)\n\t}\n\tif err := LinkSetXdpFd(testXdpLink, fd); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetXdpFdWithFlags(testXdpLink, fd, nl.XDP_FLAGS_UPDATE_IF_NOEXIST); !errors.Is(err, unix.EBUSY) {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetXdpFd(testXdpLink, -1); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkAddDelIptun(t *testing.T) {\n\tminKernelRequired(t, 4, 9)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Iptun{\n\t\tLinkAttrs: LinkAttrs{Name: \"iptunfoo\"},\n\t\tPMtuDisc:  1,\n\t\tLocal:     net.IPv4(127, 0, 0, 1),\n\t\tRemote:    net.IPv4(127, 0, 0, 1)})\n}\n\nfunc TestLinkAddDelIptunFlowBased(t *testing.T) {\n\tminKernelRequired(t, 4, 9)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Iptun{\n\t\tLinkAttrs: LinkAttrs{Name: \"iptunflowfoo\"},\n\t\tFlowBased: true,\n\t})\n}\n\nfunc TestLinkAddDelIp6tnl(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Ip6tnl{\n\t\tLinkAttrs: LinkAttrs{Name: \"ip6tnltest\"},\n\t\tLocal:     net.ParseIP(\"2001:db8::100\"),\n\t\tRemote:    net.ParseIP(\"2001:db8::200\"),\n\t})\n}\n\nfunc TestLinkAddDelIp6tnlFlowbased(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Ip6tnl{\n\t\tLinkAttrs: LinkAttrs{Name: \"ip6tnltest\"},\n\t\tFlowBased: true,\n\t})\n}\n\nfunc TestLinkAddDelSittun(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Sittun{\n\t\tLinkAttrs: LinkAttrs{Name: \"sittunfoo\"},\n\t\tPMtuDisc:  1,\n\t\tLocal:     net.IPv4(127, 0, 0, 1),\n\t\tRemote:    net.IPv4(127, 0, 0, 1)})\n}\n\nfunc TestLinkAddDelVti(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\ttestLinkAddDel(t, &Vti{\n\t\tLinkAttrs: LinkAttrs{Name: \"vtifoo\"},\n\t\tIKey:      0x101,\n\t\tOKey:      0x101,\n\t\tLocal:     net.IPv4(127, 0, 0, 1),\n\t\tRemote:    net.IPv4(127, 0, 0, 1)})\n\n\ttestLinkAddDel(t, &Vti{\n\t\tLinkAttrs: LinkAttrs{Name: \"vtibar\"},\n\t\tIKey:      0x101,\n\t\tOKey:      0x101,\n\t\tLocal:     net.IPv6loopback,\n\t\tRemote:    net.IPv6loopback})\n}\n\nfunc TestLinkSetGSOMaxSize(t *testing.T) {\n\tminKernelRequired(t, 5, 19)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Veth{LinkAttrs: LinkAttrs{Name: \"foo\", TxQLen: testTxQLen, MTU: 1500}, PeerName: \"bar\"}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetGSOMaxSize(link, 32768)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().GSOMaxSize != 32768 {\n\t\tt.Fatalf(\"GSO max size was not modified\")\n\t}\n}\n\nfunc TestLinkSetGSOMaxSegs(t *testing.T) {\n\tminKernelRequired(t, 5, 19)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Veth{LinkAttrs: LinkAttrs{Name: \"foo\", TxQLen: testTxQLen, MTU: 1500}, PeerName: \"bar\"}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetGSOMaxSegs(link, 16)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().GSOMaxSegs != 16 {\n\t\tt.Fatalf(\"GSO max segments was not modified\")\n\t}\n}\n\nfunc TestLinkSetGROMaxSize(t *testing.T) {\n\tminKernelRequired(t, 5, 19)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Veth{LinkAttrs: LinkAttrs{Name: \"foo\", TxQLen: testTxQLen, MTU: 1500}, PeerName: \"bar\"}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetGROMaxSize(link, 32768)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().GROMaxSize != 32768 {\n\t\tt.Fatalf(\"GRO max size was not modified\")\n\t}\n}\n\nfunc TestLinkGetTSOMax(t *testing.T) {\n\tminKernelRequired(t, 5, 19)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Veth{LinkAttrs: LinkAttrs{Name: \"foo\", TxQLen: testTxQLen, MTU: 1500}, PeerName: \"bar\"}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().TSOMaxSize != 524280 || link.Attrs().TSOMaxSegs != 65535 {\n\t\tt.Fatalf(\"TSO max size and segments could not be retrieved\")\n\t}\n}\n\nfunc TestLinkSetGSOIPv4MaxSize(t *testing.T) {\n\tminKernelRequired(t, 6, 3)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Veth{LinkAttrs: LinkAttrs{Name: \"foo\", TxQLen: testTxQLen, MTU: 1500}, PeerName: \"bar\"}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetGSOIPv4MaxSize(link, 32768)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().GSOIPv4MaxSize != 32768 {\n\t\tt.Fatalf(\"GSO max size was not modified\")\n\t}\n}\n\nfunc TestLinkSetGROIPv4MaxSize(t *testing.T) {\n\tminKernelRequired(t, 6, 3)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Veth{LinkAttrs: LinkAttrs{Name: \"foo\", TxQLen: testTxQLen, MTU: 1500}, PeerName: \"bar\"}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetGROIPv4MaxSize(link, 32768)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().GROIPv4MaxSize != 32768 {\n\t\tt.Fatalf(\"GRO max size was not modified\")\n\t}\n}\n\nfunc TestBridgeCreationWithMulticastSnooping(t *testing.T) {\n\tminKernelRequired(t, 4, 4)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbridgeWithDefaultMcastSnoopName := \"foo\"\n\tbridgeWithDefaultMcastSnoop := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeWithDefaultMcastSnoopName}}\n\tif err := LinkAdd(bridgeWithDefaultMcastSnoop); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectMcastSnooping(t, bridgeWithDefaultMcastSnoopName, true)\n\tif err := LinkDel(bridgeWithDefaultMcastSnoop); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmcastSnoop := true\n\tbridgeWithMcastSnoopOnName := \"bar\"\n\tbridgeWithMcastSnoopOn := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeWithMcastSnoopOnName}, MulticastSnooping: &mcastSnoop}\n\tif err := LinkAdd(bridgeWithMcastSnoopOn); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectMcastSnooping(t, bridgeWithMcastSnoopOnName, true)\n\tif err := LinkDel(bridgeWithMcastSnoopOn); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmcastSnoop = false\n\tbridgeWithMcastSnoopOffName := \"foobar\"\n\tbridgeWithMcastSnoopOff := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeWithMcastSnoopOffName}, MulticastSnooping: &mcastSnoop}\n\tif err := LinkAdd(bridgeWithMcastSnoopOff); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectMcastSnooping(t, bridgeWithMcastSnoopOffName, false)\n\tif err := LinkDel(bridgeWithMcastSnoopOff); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBridgeSetMcastSnoop(t *testing.T) {\n\tminKernelRequired(t, 4, 4)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbridgeName := \"foo\"\n\tbridge := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeName}}\n\tif err := LinkAdd(bridge); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectMcastSnooping(t, bridgeName, true)\n\n\tif err := BridgeSetMcastSnoop(bridge, false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectMcastSnooping(t, bridgeName, false)\n\n\tif err := BridgeSetMcastSnoop(bridge, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectMcastSnooping(t, bridgeName, true)\n\n\tif err := LinkDel(bridge); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc expectMcastSnooping(t *testing.T, linkName string, expected bool) {\n\tbridge, err := LinkByName(linkName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif actual := *bridge.(*Bridge).MulticastSnooping; actual != expected {\n\t\tt.Fatalf(\"expected %t got %t\", expected, actual)\n\t}\n}\n\nfunc TestBridgeSetVlanFiltering(t *testing.T) {\n\tminKernelRequired(t, 4, 4)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbridgeName := \"foo\"\n\tbridge := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeName}}\n\tif err := LinkAdd(bridge); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectVlanFiltering(t, bridgeName, false)\n\n\tif err := BridgeSetVlanFiltering(bridge, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectVlanFiltering(t, bridgeName, true)\n\n\tif err := BridgeSetVlanFiltering(bridge, false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectVlanFiltering(t, bridgeName, false)\n\n\tif err := LinkDel(bridge); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBridgeDefaultPVID(t *testing.T) {\n\tminKernelRequired(t, 4, 4)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbridgeName := \"foo\"\n\tbridge := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeName}}\n\tif err := LinkAdd(bridge); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectVlanDefaultPVID(t, bridgeName, 1)\n\n\tif err := BridgeSetVlanDefaultPVID(bridge, 100); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectVlanDefaultPVID(t, bridgeName, 100)\n\n\tif err := BridgeSetVlanDefaultPVID(bridge, 0); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectVlanDefaultPVID(t, bridgeName, 0)\n\n\tif err := LinkDel(bridge); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc expectVlanFiltering(t *testing.T, linkName string, expected bool) {\n\tbridge, err := LinkByName(linkName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif actual := *bridge.(*Bridge).VlanFiltering; actual != expected {\n\t\tt.Fatalf(\"expected %t got %t\", expected, actual)\n\t}\n}\n\nfunc expectVlanDefaultPVID(t *testing.T, linkName string, expected uint16) {\n\tbridge, err := LinkByName(linkName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif actual := *bridge.(*Bridge).VlanDefaultPVID; actual != expected {\n\t\tt.Fatalf(\"expected %d got %d\", expected, actual)\n\t}\n}\n\nfunc TestBridgeCreationWithAgeingTime(t *testing.T) {\n\tminKernelRequired(t, 3, 18)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbridgeWithSpecifiedAgeingTimeName := \"foo\"\n\tageingTime := uint32(20000)\n\tbridgeWithSpecifiedAgeingTime := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeWithSpecifiedAgeingTimeName}, AgeingTime: &ageingTime}\n\tif err := LinkAdd(bridgeWithSpecifiedAgeingTime); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tretrievedBridge, err := LinkByName(bridgeWithSpecifiedAgeingTimeName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tactualAgeingTime := *retrievedBridge.(*Bridge).AgeingTime\n\tif actualAgeingTime != ageingTime {\n\t\tt.Fatalf(\"expected %d got %d\", ageingTime, actualAgeingTime)\n\t}\n\tif err := LinkDel(bridgeWithSpecifiedAgeingTime); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbridgeWithDefaultAgeingTimeName := \"bar\"\n\tbridgeWithDefaultAgeingTime := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeWithDefaultAgeingTimeName}}\n\tif err := LinkAdd(bridgeWithDefaultAgeingTime); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tretrievedBridge, err = LinkByName(bridgeWithDefaultAgeingTimeName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tactualAgeingTime = *retrievedBridge.(*Bridge).AgeingTime\n\tif actualAgeingTime != 30000 {\n\t\tt.Fatalf(\"expected %d got %d\", 30000, actualAgeingTime)\n\t}\n\tif err := LinkDel(bridgeWithDefaultAgeingTime); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBridgeCreationWithHelloTime(t *testing.T) {\n\tminKernelRequired(t, 3, 18)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbridgeWithSpecifiedHelloTimeName := \"foo\"\n\thelloTime := uint32(300)\n\tbridgeWithSpecifiedHelloTime := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeWithSpecifiedHelloTimeName}, HelloTime: &helloTime}\n\tif err := LinkAdd(bridgeWithSpecifiedHelloTime); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tretrievedBridge, err := LinkByName(bridgeWithSpecifiedHelloTimeName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tactualHelloTime := *retrievedBridge.(*Bridge).HelloTime\n\tif actualHelloTime != helloTime {\n\t\tt.Fatalf(\"expected %d got %d\", helloTime, actualHelloTime)\n\t}\n\tif err := LinkDel(bridgeWithSpecifiedHelloTime); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbridgeWithDefaultHelloTimeName := \"bar\"\n\tbridgeWithDefaultHelloTime := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeWithDefaultHelloTimeName}}\n\tif err := LinkAdd(bridgeWithDefaultHelloTime); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tretrievedBridge, err = LinkByName(bridgeWithDefaultHelloTimeName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tactualHelloTime = *retrievedBridge.(*Bridge).HelloTime\n\tif actualHelloTime != 200 {\n\t\tt.Fatalf(\"expected %d got %d\", 200, actualHelloTime)\n\t}\n\tif err := LinkDel(bridgeWithDefaultHelloTime); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBridgeCreationWithVlanFiltering(t *testing.T) {\n\tminKernelRequired(t, 3, 18)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tbridgeWithVlanFilteringEnabledName := \"foo\"\n\tvlanFiltering := true\n\tbridgeWithVlanFilteringEnabled := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeWithVlanFilteringEnabledName}, VlanFiltering: &vlanFiltering}\n\tif err := LinkAdd(bridgeWithVlanFilteringEnabled); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tretrievedBridge, err := LinkByName(bridgeWithVlanFilteringEnabledName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tretrievedVlanFilteringState := *retrievedBridge.(*Bridge).VlanFiltering\n\tif retrievedVlanFilteringState != vlanFiltering {\n\t\tt.Fatalf(\"expected %t got %t\", vlanFiltering, retrievedVlanFilteringState)\n\t}\n\tif err := LinkDel(bridgeWithVlanFilteringEnabled); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbridgeWithDefaultVlanFilteringName := \"bar\"\n\tbridgeWIthDefaultVlanFiltering := &Bridge{LinkAttrs: LinkAttrs{Name: bridgeWithDefaultVlanFilteringName}}\n\tif err := LinkAdd(bridgeWIthDefaultVlanFiltering); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tretrievedBridge, err = LinkByName(bridgeWithDefaultVlanFilteringName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tretrievedVlanFilteringState = *retrievedBridge.(*Bridge).VlanFiltering\n\tif retrievedVlanFilteringState != false {\n\t\tt.Fatalf(\"expected %t got %t\", false, retrievedVlanFilteringState)\n\t}\n\tif err := LinkDel(bridgeWIthDefaultVlanFiltering); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkSubscribeWithProtinfo(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tmaster := &Bridge{LinkAttrs: LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(master); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tslave := &Veth{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName:        \"bar\",\n\t\t\tTxQLen:      testTxQLen,\n\t\t\tMTU:         1400,\n\t\t\tMasterIndex: master.Attrs().Index,\n\t\t},\n\t\tPeerName: \"bar-peer\",\n\t}\n\tif err := LinkAdd(slave); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tch := make(chan LinkUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := LinkSubscribe(ch, done); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetHairpin(slave, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase update := <-ch:\n\t\tif !(update.Attrs().Name == \"bar\" && update.Attrs().Protinfo != nil &&\n\t\t\tupdate.Attrs().Protinfo.Hairpin) {\n\t\t\tt.Fatal(\"Hairpin update not received as expected\")\n\t\t}\n\tcase <-time.After(time.Minute):\n\t\tt.Fatal(\"Hairpin update timed out\")\n\t}\n\n\tif err := LinkDel(slave); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkDel(master); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc testGTPLink(t *testing.T) *GTP {\n\tconn1, err := net.ListenUDP(\"udp\", &net.UDPAddr{\n\t\tIP:   net.ParseIP(\"0.0.0.0\"),\n\t\tPort: 3386,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconn2, err := net.ListenUDP(\"udp\", &net.UDPAddr{\n\t\tIP:   net.ParseIP(\"0.0.0.0\"),\n\t\tPort: 2152,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfd1, _ := conn1.File()\n\tfd2, _ := conn2.File()\n\treturn &GTP{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName: \"gtp0\",\n\t\t},\n\t\tFD0: int(fd1.Fd()),\n\t\tFD1: int(fd2.Fd()),\n\t}\n}\n\nfunc TestLinkAddDelGTP(t *testing.T) {\n\ttearDown := setUpNetlinkTestWithKModule(t, \"gtp\")\n\tdefer tearDown()\n\tgtp := testGTPLink(t)\n\ttestLinkAddDel(t, gtp)\n}\n\nfunc TestLinkAddDelXfrmi(t *testing.T) {\n\tminKernelRequired(t, 4, 19)\n\tdefer setUpNetlinkTest(t)()\n\n\tlo, _ := LinkByName(\"lo\")\n\n\ttestLinkAddDel(t, &Xfrmi{\n\t\tLinkAttrs: LinkAttrs{Name: \"xfrm123\", ParentIndex: lo.Attrs().Index},\n\t\tIfid:      123})\n}\n\nfunc TestLinkAddDelXfrmiNoId(t *testing.T) {\n\tminKernelRequired(t, 4, 19)\n\tdefer setUpNetlinkTest(t)()\n\n\tlo, _ := LinkByName(\"lo\")\n\n\terr := LinkAdd(&Xfrmi{\n\t\tLinkAttrs: LinkAttrs{Name: \"xfrm0\", ParentIndex: lo.Attrs().Index}})\n\tif !errors.Is(err, unix.EINVAL) {\n\t\tt.Errorf(\"Error returned expected to be EINVAL\")\n\t}\n\n}\n\nfunc TestLinkByNameWhenLinkIsNotFound(t *testing.T) {\n\t_, err := LinkByName(\"iammissing\")\n\tif err == nil {\n\t\tt.Fatal(\"Link not expected to found\")\n\t}\n\n\t_, ok := err.(LinkNotFoundError)\n\tif !ok {\n\t\tt.Errorf(\"Error returned expected to of LinkNotFoundError type: %v\", err)\n\t}\n}\n\nfunc TestLinkByAliasWhenLinkIsNotFound(t *testing.T) {\n\t_, err := LinkByAlias(\"iammissing\")\n\tif err == nil {\n\t\tt.Fatal(\"Link not expected to found\")\n\t}\n\n\t_, ok := err.(LinkNotFoundError)\n\tif !ok {\n\t\tt.Errorf(\"Error returned expected to of LinkNotFoundError type: %v\", err)\n\t}\n}\n\nfunc TestLinkAddDelTuntap(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// Mount sysfs so that sysfs gets the namespace tag of the current network namespace\n\t// This is necessary so that /sys shows the network interfaces of the current namespace.\n\tif err := syscall.Mount(\"sysfs\", \"/sys\", \"sysfs\", syscall.MS_RDONLY, \"\"); err != nil {\n\t\tt.Fatal(\"Cannot mount sysfs\")\n\t}\n\n\tdefer func() {\n\t\tif err := syscall.Unmount(\"/sys\", 0); err != nil {\n\t\t\tt.Fatal(\"Cannot umount /sys\")\n\t\t}\n\t}()\n\n\ttestLinkAddDel(t, &Tuntap{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo\"},\n\t\tMode:      TUNTAP_MODE_TAP})\n}\n\nfunc TestLinkAddDelTuntapMq(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tif err := syscall.Mount(\"sysfs\", \"/sys\", \"sysfs\", syscall.MS_RDONLY, \"\"); err != nil {\n\t\tt.Fatal(\"Cannot mount sysfs\")\n\t}\n\n\tdefer func() {\n\t\tif err := syscall.Unmount(\"/sys\", 0); err != nil {\n\t\t\tt.Fatal(\"Cannot umount /sys\")\n\t\t}\n\t}()\n\n\ttestLinkAddDel(t, &Tuntap{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo\"},\n\t\tMode:      TUNTAP_MODE_TAP,\n\t\tQueues:    4})\n\n\ttestLinkAddDel(t, &Tuntap{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo\"},\n\t\tMode:      TUNTAP_MODE_TAP,\n\t\tQueues:    4,\n\t\tFlags:     TUNTAP_MULTI_QUEUE_DEFAULTS | TUNTAP_VNET_HDR})\n}\n\nfunc TestLinkAddDelTuntapOwnerGroup(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tif err := syscall.Mount(\"sysfs\", \"/sys\", \"sysfs\", syscall.MS_RDONLY, \"\"); err != nil {\n\t\tt.Fatal(\"Cannot mount sysfs\")\n\t}\n\n\tdefer func() {\n\t\tif err := syscall.Unmount(\"/sys\", 0); err != nil {\n\t\t\tt.Fatal(\"Cannot umount /sys\")\n\t\t}\n\t}()\n\n\ttestLinkAddDel(t, &Tuntap{\n\t\tLinkAttrs: LinkAttrs{Name: \"foo\"},\n\t\tMode:      TUNTAP_MODE_TAP,\n\t\tOwner:     0,\n\t\tGroup:     0,\n\t})\n}\n\nfunc TestVethPeerIndex(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tconst (\n\t\tvethPeer1 = \"vethOne\"\n\t\tvethPeer2 = \"vethTwo\"\n\t)\n\n\tlink := &Veth{\n\t\tLinkAttrs: LinkAttrs{\n\t\t\tName:  vethPeer1,\n\t\t\tMTU:   1500,\n\t\t\tFlags: net.FlagUp,\n\t\t},\n\t\tPeerName: vethPeer2,\n\t}\n\n\tif err := LinkAdd(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlinkOne, err := LinkByName(\"vethOne\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlinkTwo, err := LinkByName(\"vethTwo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpeerIndexOne, err := VethPeerIndex(&Veth{LinkAttrs: *linkOne.Attrs()})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpeerIndexTwo, err := VethPeerIndex(&Veth{LinkAttrs: *linkTwo.Attrs()})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif peerIndexOne != linkTwo.Attrs().Index {\n\t\tt.Errorf(\"VethPeerIndex(%s) mismatch %d != %d\", linkOne.Attrs().Name, peerIndexOne, linkTwo.Attrs().Index)\n\t}\n\n\tif peerIndexTwo != linkOne.Attrs().Index {\n\t\tt.Errorf(\"VethPeerIndex(%s) mismatch %d != %d\", linkTwo.Attrs().Name, peerIndexTwo, linkOne.Attrs().Index)\n\t}\n}\n\nfunc TestLinkSlaveBond(t *testing.T) {\n\tminKernelRequired(t, 3, 13)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tconst (\n\t\tbondName  = \"foo\"\n\t\tslaveName = \"fooFoo\"\n\t)\n\n\tbond := NewLinkBond(LinkAttrs{Name: bondName})\n\tbond.Mode = BOND_MODE_BALANCE_RR\n\tif err := LinkAdd(bond); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(bond)\n\n\tslaveDummy := &Dummy{LinkAttrs{Name: slaveName}}\n\tif err := LinkAdd(slaveDummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(slaveDummy)\n\n\tif err := LinkSetBondSlave(slaveDummy, bond); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tslaveLink, err := LinkByName(slaveName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tslave := slaveLink.Attrs().Slave\n\tif slave == nil {\n\t\tt.Errorf(\"for %s expected slave is not nil.\", slaveName)\n\t}\n\n\tif slaveType := slave.SlaveType(); slaveType != \"bond\" {\n\t\tt.Errorf(\"for %s expected slave type is 'bond', but '%s'\", slaveName, slaveType)\n\t}\n}\n\nfunc TestLinkSetBondSlaveQueueId(t *testing.T) {\n\tminKernelRequired(t, 3, 13)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tconst (\n\t\tbondName   = \"foo\"\n\t\tslave1Name = \"fooFoo\"\n\t)\n\n\tbond := NewLinkBond(LinkAttrs{Name: bondName})\n\tif err := LinkAdd(bond); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(bond)\n\n\tslave := &Dummy{LinkAttrs{Name: slave1Name}}\n\tif err := LinkAdd(slave); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(slave)\n\n\tif err := LinkSetBondSlave(slave, bond); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := pkgHandle.LinkSetBondSlaveQueueId(slave, 1); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLinkSetBondSlave(t *testing.T) {\n\tminKernelRequired(t, 3, 13)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tconst (\n\t\tbondName     = \"foo\"\n\t\tslaveOneName = \"fooFoo\"\n\t\tslaveTwoName = \"fooBar\"\n\t)\n\n\tbond := NewLinkBond(LinkAttrs{Name: bondName})\n\tbond.Mode = StringToBondModeMap[\"802.3ad\"]\n\tbond.AdSelect = BondAdSelect(BOND_AD_SELECT_BANDWIDTH)\n\tbond.AdActorSysPrio = 1\n\tbond.AdUserPortKey = 1\n\tbond.AdActorSystem, _ = net.ParseMAC(\"06:aa:bb:cc:dd:ee\")\n\n\tif err := LinkAdd(bond); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbondLink, err := LinkByName(bondName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(bondLink)\n\n\tif err := LinkAdd(&Dummy{LinkAttrs{Name: slaveOneName}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tslaveOneLink, err := LinkByName(slaveOneName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(slaveOneLink)\n\n\tif err := LinkAdd(&Dummy{LinkAttrs{Name: slaveTwoName}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tslaveTwoLink, err := LinkByName(slaveTwoName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(slaveTwoLink)\n\n\tif err := LinkSetBondSlave(slaveOneLink, &Bond{LinkAttrs: *bondLink.Attrs()}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetBondSlave(slaveTwoLink, &Bond{LinkAttrs: *bondLink.Attrs()}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Update info about interfaces\n\tslaveOneLink, err = LinkByName(slaveOneName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tslaveTwoLink, err = LinkByName(slaveTwoName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif slaveOneLink.Attrs().MasterIndex != bondLink.Attrs().Index {\n\t\tt.Errorf(\"For %s expected %s to be master\", slaveOneLink.Attrs().Name, bondLink.Attrs().Name)\n\t}\n\n\tif slaveTwoLink.Attrs().MasterIndex != bondLink.Attrs().Index {\n\t\tt.Errorf(\"For %s expected %s to be master\", slaveTwoLink.Attrs().Name, bondLink.Attrs().Name)\n\t}\n}\n\nfunc testFailover(t *testing.T, slaveName, bondName string) {\n\tslaveLink, err := LinkByName(slaveName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbondLink, err := LinkByName(bondName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = LinkSetBondSlaveActive(slaveLink, &Bond{LinkAttrs: *bondLink.Attrs()})\n\tif err != nil {\n\t\tt.Errorf(\"set slave link active failed: %v\", err)\n\t\treturn\n\t}\n\n\tbondLink, err = LinkByName(bondName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbond := bondLink.(*Bond)\n\tif bond.ActiveSlave != slaveLink.Attrs().Index {\n\t\tt.Errorf(\"the current active slave %d is not expected as %d\", bond.ActiveSlave, slaveLink.Attrs().Index)\n\t}\n}\n\nfunc TestLinkFailover(t *testing.T) {\n\tminKernelRequired(t, 3, 13)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tconst (\n\t\tbondName     = \"foo\"\n\t\tslaveOneName = \"fooFoo\"\n\t\tslaveTwoName = \"fooBar\"\n\t)\n\n\tbond := NewLinkBond(LinkAttrs{Name: bondName})\n\tbond.Mode = StringToBondModeMap[\"active-backup\"]\n\tbond.Miimon = 100\n\n\tif err := LinkAdd(bond); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbondLink, err := LinkByName(bondName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(bondLink)\n\n\tif err := LinkAdd(&Dummy{LinkAttrs{Name: slaveOneName}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tslaveOneLink, err := LinkByName(slaveOneName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(slaveOneLink)\n\n\tif err := LinkAdd(&Dummy{LinkAttrs{Name: slaveTwoName}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tslaveTwoLink, err := LinkByName(slaveTwoName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(slaveTwoLink)\n\n\tif err := LinkSetBondSlave(slaveOneLink, &Bond{LinkAttrs: *bondLink.Attrs()}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetBondSlave(slaveTwoLink, &Bond{LinkAttrs: *bondLink.Attrs()}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestFailover(t, slaveOneName, bondName)\n\ttestFailover(t, slaveTwoName, bondName)\n\ttestFailover(t, slaveTwoName, bondName)\n\n\t// del slave from bond\n\tslaveOneLink, err = LinkByName(slaveOneName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = LinkDelBondSlave(slaveOneLink, &Bond{LinkAttrs: *bondLink.Attrs()})\n\tif err != nil {\n\t\tt.Errorf(\"Remove slave %s from bond failed: %v\", slaveOneName, err)\n\t}\n\tslaveOneLink, err = LinkByName(slaveOneName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif slaveOneLink.Attrs().MasterIndex > 0 {\n\t\tt.Errorf(\"The nic %s is still a slave of %d\", slaveOneName, slaveOneLink.Attrs().MasterIndex)\n\t}\n}\n\nfunc TestLinkSetAllmulticast(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Veth{LinkAttrs: LinkAttrs{Name: \"foo\"}, PeerName: \"bar\"}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetAllmulticastOn(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().Allmulti != 1 {\n\t\tt.Fatal(\"IFF_ALLMULTI was not set\")\n\t}\n\n\tif err := LinkSetAllmulticastOff(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().Allmulti != 0 {\n\t\tt.Fatal(\"IFF_ALLMULTI is still set\")\n\t}\n}\n\nfunc TestLinkSetMulticast(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tiface := &Veth{LinkAttrs: LinkAttrs{Name: \"foo\"}, PeerName: \"bar\"}\n\tif err := LinkAdd(iface); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetMulticastOn(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().Multi != 1 {\n\t\tt.Fatal(\"IFF_MULTICAST was not set\")\n\t}\n\n\tif err := LinkSetMulticastOff(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err = LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif link.Attrs().Multi != 0 {\n\t\tt.Fatal(\"IFF_MULTICAST is still set\")\n\t}\n}\n\nfunc TestLinkSetMacvlanMode(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tconst (\n\t\tparentName  = \"foo\"\n\t\tmacvlanName = \"fooFoo\"\n\t\tmacvtapName = \"fooBar\"\n\t)\n\n\tparent := &Dummy{LinkAttrs{Name: parentName}}\n\tif err := LinkAdd(parent); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(parent)\n\n\ttestMacvlanMode := func(link Link, mode MacvlanMode) {\n\t\tif err := LinkSetMacvlanMode(link, mode); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tname := link.Attrs().Name\n\t\tresult, err := LinkByName(name)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvar actual MacvlanMode\n\t\tswitch l := result.(type) {\n\t\tcase *Macvlan:\n\t\t\tactual = l.Mode\n\t\tcase *Macvtap:\n\t\t\tactual = l.Macvlan.Mode\n\t\t}\n\n\t\tif actual != mode {\n\t\t\tt.Fatalf(\"expected %v got %v for %+v\", mode, actual, link)\n\t\t}\n\t}\n\n\tmacvlan := &Macvlan{\n\t\tLinkAttrs: LinkAttrs{Name: macvlanName, ParentIndex: parent.Attrs().Index},\n\t\tMode:      MACVLAN_MODE_BRIDGE,\n\t}\n\tif err := LinkAdd(macvlan); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(macvlan)\n\n\ttestMacvlanMode(macvlan, MACVLAN_MODE_VEPA)\n\ttestMacvlanMode(macvlan, MACVLAN_MODE_PRIVATE)\n\ttestMacvlanMode(macvlan, MACVLAN_MODE_SOURCE)\n\ttestMacvlanMode(macvlan, MACVLAN_MODE_BRIDGE)\n\n\tmacvtap := &Macvtap{\n\t\tMacvlan: Macvlan{\n\t\t\tLinkAttrs: LinkAttrs{Name: macvtapName, ParentIndex: parent.Attrs().Index},\n\t\t\tMode:      MACVLAN_MODE_BRIDGE,\n\t\t},\n\t}\n\tif err := LinkAdd(macvtap); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer LinkDel(macvtap)\n\n\ttestMacvlanMode(macvtap, MACVLAN_MODE_VEPA)\n\ttestMacvlanMode(macvtap, MACVLAN_MODE_PRIVATE)\n\ttestMacvlanMode(macvtap, MACVLAN_MODE_SOURCE)\n\ttestMacvlanMode(macvtap, MACVLAN_MODE_BRIDGE)\n}\n"
        },
        {
          "name": "link_tuntap_linux.go",
          "type": "blob",
          "size": 0.275390625,
          "content": "package netlink\n\n// ideally golang.org/x/sys/unix would define IfReq but it only has\n// IFNAMSIZ, hence this minimalistic implementation\nconst (\n\tSizeOfIfReq = 40\n\tIFNAMSIZ    = 16\n)\n\ntype ifReq struct {\n\tName  [IFNAMSIZ]byte\n\tFlags uint16\n\tpad   [SizeOfIfReq - IFNAMSIZ - 2]byte\n}\n"
        },
        {
          "name": "neigh.go",
          "type": "blob",
          "size": 0.640625,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\n// Neigh represents a link layer neighbor from netlink.\ntype Neigh struct {\n\tLinkIndex    int\n\tFamily       int\n\tState        int\n\tType         int\n\tFlags        int\n\tFlagsExt     int\n\tIP           net.IP\n\tHardwareAddr net.HardwareAddr\n\tLLIPAddr     net.IP //Used in the case of NHRP\n\tVlan         int\n\tVNI          int\n\tMasterIndex  int\n}\n\n// String returns $ip/$hwaddr $label\nfunc (neigh *Neigh) String() string {\n\treturn fmt.Sprintf(\"%s %s\", neigh.IP, neigh.HardwareAddr)\n}\n\n// NeighUpdate is sent when a neighbor changes - type is RTM_NEWNEIGH or RTM_DELNEIGH.\ntype NeighUpdate struct {\n\tType uint16\n\tNeigh\n}\n"
        },
        {
          "name": "neigh_linux.go",
          "type": "blob",
          "size": 12.9736328125,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"syscall\"\n\t\"unsafe\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\tNDA_UNSPEC = iota\n\tNDA_DST\n\tNDA_LLADDR\n\tNDA_CACHEINFO\n\tNDA_PROBES\n\tNDA_VLAN\n\tNDA_PORT\n\tNDA_VNI\n\tNDA_IFINDEX\n\tNDA_MASTER\n\tNDA_LINK_NETNSID\n\tNDA_SRC_VNI\n\tNDA_PROTOCOL\n\tNDA_NH_ID\n\tNDA_FDB_EXT_ATTRS\n\tNDA_FLAGS_EXT\n\tNDA_MAX = NDA_FLAGS_EXT\n)\n\n// Neighbor Cache Entry States.\nconst (\n\tNUD_NONE       = 0x00\n\tNUD_INCOMPLETE = 0x01\n\tNUD_REACHABLE  = 0x02\n\tNUD_STALE      = 0x04\n\tNUD_DELAY      = 0x08\n\tNUD_PROBE      = 0x10\n\tNUD_FAILED     = 0x20\n\tNUD_NOARP      = 0x40\n\tNUD_PERMANENT  = 0x80\n)\n\n// Neighbor Flags\nconst (\n\tNTF_USE         = 0x01\n\tNTF_SELF        = 0x02\n\tNTF_MASTER      = 0x04\n\tNTF_PROXY       = 0x08\n\tNTF_EXT_LEARNED = 0x10\n\tNTF_OFFLOADED   = 0x20\n\tNTF_STICKY      = 0x40\n\tNTF_ROUTER      = 0x80\n)\n\n// Extended Neighbor Flags\nconst (\n\tNTF_EXT_MANAGED = 0x00000001\n)\n\n// Ndmsg is for adding, removing or receiving information about a neighbor table entry\ntype Ndmsg struct {\n\tFamily uint8\n\tIndex  uint32\n\tState  uint16\n\tFlags  uint8\n\tType   uint8\n}\n\nfunc deserializeNdmsg(b []byte) *Ndmsg {\n\tvar dummy Ndmsg\n\treturn (*Ndmsg)(unsafe.Pointer(&b[0:unsafe.Sizeof(dummy)][0]))\n}\n\nfunc (msg *Ndmsg) Serialize() []byte {\n\treturn (*(*[unsafe.Sizeof(*msg)]byte)(unsafe.Pointer(msg)))[:]\n}\n\nfunc (msg *Ndmsg) Len() int {\n\treturn int(unsafe.Sizeof(*msg))\n}\n\n// NeighAdd will add an IP to MAC mapping to the ARP table\n// Equivalent to: `ip neigh add ....`\nfunc NeighAdd(neigh *Neigh) error {\n\treturn pkgHandle.NeighAdd(neigh)\n}\n\n// NeighAdd will add an IP to MAC mapping to the ARP table\n// Equivalent to: `ip neigh add ....`\nfunc (h *Handle) NeighAdd(neigh *Neigh) error {\n\treturn h.neighAdd(neigh, unix.NLM_F_CREATE|unix.NLM_F_EXCL)\n}\n\n// NeighSet will add or replace an IP to MAC mapping to the ARP table\n// Equivalent to: `ip neigh replace....`\nfunc NeighSet(neigh *Neigh) error {\n\treturn pkgHandle.NeighSet(neigh)\n}\n\n// NeighSet will add or replace an IP to MAC mapping to the ARP table\n// Equivalent to: `ip neigh replace....`\nfunc (h *Handle) NeighSet(neigh *Neigh) error {\n\treturn h.neighAdd(neigh, unix.NLM_F_CREATE|unix.NLM_F_REPLACE)\n}\n\n// NeighAppend will append an entry to FDB\n// Equivalent to: `bridge fdb append...`\nfunc NeighAppend(neigh *Neigh) error {\n\treturn pkgHandle.NeighAppend(neigh)\n}\n\n// NeighAppend will append an entry to FDB\n// Equivalent to: `bridge fdb append...`\nfunc (h *Handle) NeighAppend(neigh *Neigh) error {\n\treturn h.neighAdd(neigh, unix.NLM_F_CREATE|unix.NLM_F_APPEND)\n}\n\n// NeighAppend will append an entry to FDB\n// Equivalent to: `bridge fdb append...`\nfunc neighAdd(neigh *Neigh, mode int) error {\n\treturn pkgHandle.neighAdd(neigh, mode)\n}\n\n// NeighAppend will append an entry to FDB\n// Equivalent to: `bridge fdb append...`\nfunc (h *Handle) neighAdd(neigh *Neigh, mode int) error {\n\treq := h.newNetlinkRequest(unix.RTM_NEWNEIGH, mode|unix.NLM_F_ACK)\n\treturn neighHandle(neigh, req)\n}\n\n// NeighDel will delete an IP address from a link device.\n// Equivalent to: `ip addr del $addr dev $link`\nfunc NeighDel(neigh *Neigh) error {\n\treturn pkgHandle.NeighDel(neigh)\n}\n\n// NeighDel will delete an IP address from a link device.\n// Equivalent to: `ip addr del $addr dev $link`\nfunc (h *Handle) NeighDel(neigh *Neigh) error {\n\treq := h.newNetlinkRequest(unix.RTM_DELNEIGH, unix.NLM_F_ACK)\n\treturn neighHandle(neigh, req)\n}\n\nfunc neighHandle(neigh *Neigh, req *nl.NetlinkRequest) error {\n\tvar family int\n\n\tif neigh.Family > 0 {\n\t\tfamily = neigh.Family\n\t} else {\n\t\tfamily = nl.GetIPFamily(neigh.IP)\n\t}\n\n\tmsg := Ndmsg{\n\t\tFamily: uint8(family),\n\t\tIndex:  uint32(neigh.LinkIndex),\n\t\tState:  uint16(neigh.State),\n\t\tType:   uint8(neigh.Type),\n\t\tFlags:  uint8(neigh.Flags),\n\t}\n\treq.AddData(&msg)\n\n\tipData := neigh.IP.To4()\n\tif ipData == nil {\n\t\tipData = neigh.IP.To16()\n\t}\n\n\tdstData := nl.NewRtAttr(NDA_DST, ipData)\n\treq.AddData(dstData)\n\n\tif neigh.LLIPAddr != nil {\n\t\tllIPData := nl.NewRtAttr(NDA_LLADDR, neigh.LLIPAddr.To4())\n\t\treq.AddData(llIPData)\n\t} else if neigh.HardwareAddr != nil {\n\t\thwData := nl.NewRtAttr(NDA_LLADDR, []byte(neigh.HardwareAddr))\n\t\treq.AddData(hwData)\n\t}\n\n\tif neigh.FlagsExt != 0 {\n\t\tflagsExtData := nl.NewRtAttr(NDA_FLAGS_EXT, nl.Uint32Attr(uint32(neigh.FlagsExt)))\n\t\treq.AddData(flagsExtData)\n\t}\n\n\tif neigh.Vlan != 0 {\n\t\tvlanData := nl.NewRtAttr(NDA_VLAN, nl.Uint16Attr(uint16(neigh.Vlan)))\n\t\treq.AddData(vlanData)\n\t}\n\n\tif neigh.VNI != 0 {\n\t\tvniData := nl.NewRtAttr(NDA_VNI, nl.Uint32Attr(uint32(neigh.VNI)))\n\t\treq.AddData(vniData)\n\t}\n\n\tif neigh.MasterIndex != 0 {\n\t\tmasterData := nl.NewRtAttr(NDA_MASTER, nl.Uint32Attr(uint32(neigh.MasterIndex)))\n\t\treq.AddData(masterData)\n\t}\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// NeighList returns a list of IP-MAC mappings in the system (ARP table).\n// Equivalent to: `ip neighbor show`.\n// The list can be filtered by link and ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc NeighList(linkIndex, family int) ([]Neigh, error) {\n\treturn pkgHandle.NeighList(linkIndex, family)\n}\n\n// NeighProxyList returns a list of neighbor proxies in the system.\n// Equivalent to: `ip neighbor show proxy`.\n// The list can be filtered by link and ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc NeighProxyList(linkIndex, family int) ([]Neigh, error) {\n\treturn pkgHandle.NeighProxyList(linkIndex, family)\n}\n\n// NeighList returns a list of IP-MAC mappings in the system (ARP table).\n// Equivalent to: `ip neighbor show`.\n// The list can be filtered by link and ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) NeighList(linkIndex, family int) ([]Neigh, error) {\n\treturn h.NeighListExecute(Ndmsg{\n\t\tFamily: uint8(family),\n\t\tIndex:  uint32(linkIndex),\n\t})\n}\n\n// NeighProxyList returns a list of neighbor proxies in the system.\n// Equivalent to: `ip neighbor show proxy`.\n// The list can be filtered by link, ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) NeighProxyList(linkIndex, family int) ([]Neigh, error) {\n\treturn h.NeighListExecute(Ndmsg{\n\t\tFamily: uint8(family),\n\t\tIndex:  uint32(linkIndex),\n\t\tFlags:  NTF_PROXY,\n\t})\n}\n\n// NeighListExecute returns a list of neighbour entries filtered by link, ip family, flag and state.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc NeighListExecute(msg Ndmsg) ([]Neigh, error) {\n\treturn pkgHandle.NeighListExecute(msg)\n}\n\n// NeighListExecute returns a list of neighbour entries filtered by link, ip family, flag and state.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) NeighListExecute(msg Ndmsg) ([]Neigh, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETNEIGH, unix.NLM_F_DUMP)\n\treq.AddData(&msg)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWNEIGH)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res []Neigh\n\tfor _, m := range msgs {\n\t\tndm := deserializeNdmsg(m)\n\t\tif msg.Index != 0 && ndm.Index != msg.Index {\n\t\t\t// Ignore messages from other interfaces\n\t\t\tcontinue\n\t\t}\n\t\tif msg.Family != 0 && ndm.Family != msg.Family {\n\t\t\tcontinue\n\t\t}\n\t\tif msg.State != 0 && ndm.State != msg.State {\n\t\t\tcontinue\n\t\t}\n\t\tif msg.Type != 0 && ndm.Type != msg.Type {\n\t\t\tcontinue\n\t\t}\n\t\tif msg.Flags != 0 && ndm.Flags != msg.Flags {\n\t\t\tcontinue\n\t\t}\n\n\t\tneigh, err := NeighDeserialize(m)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tres = append(res, *neigh)\n\t}\n\n\treturn res, executeErr\n}\n\nfunc NeighDeserialize(m []byte) (*Neigh, error) {\n\tmsg := deserializeNdmsg(m)\n\n\tneigh := Neigh{\n\t\tLinkIndex: int(msg.Index),\n\t\tFamily:    int(msg.Family),\n\t\tState:     int(msg.State),\n\t\tType:      int(msg.Type),\n\t\tFlags:     int(msg.Flags),\n\t}\n\n\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase NDA_DST:\n\t\t\tneigh.IP = net.IP(attr.Value)\n\t\tcase NDA_LLADDR:\n\t\t\t// BUG: Is this a bug in the netlink library?\n\t\t\t// #define RTA_LENGTH(len) (RTA_ALIGN(sizeof(struct rtattr)) + (len))\n\t\t\t// #define RTA_PAYLOAD(rta) ((int)((rta)->rta_len) - RTA_LENGTH(0))\n\t\t\tattrLen := attr.Attr.Len - unix.SizeofRtAttr\n\t\t\tif attrLen == 4 {\n\t\t\t\tneigh.LLIPAddr = net.IP(attr.Value)\n\t\t\t} else if attrLen == 16 {\n\t\t\t\t// Can be IPv6 or FireWire HWAddr\n\t\t\t\tlink, err := LinkByIndex(neigh.LinkIndex)\n\t\t\t\tif err == nil && link.Attrs().EncapType == \"tunnel6\" {\n\t\t\t\t\tneigh.IP = net.IP(attr.Value)\n\t\t\t\t} else {\n\t\t\t\t\tneigh.HardwareAddr = net.HardwareAddr(attr.Value)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tneigh.HardwareAddr = net.HardwareAddr(attr.Value)\n\t\t\t}\n\t\tcase NDA_FLAGS_EXT:\n\t\t\tneigh.FlagsExt = int(native.Uint32(attr.Value[0:4]))\n\t\tcase NDA_VLAN:\n\t\t\tneigh.Vlan = int(native.Uint16(attr.Value[0:2]))\n\t\tcase NDA_VNI:\n\t\t\tneigh.VNI = int(native.Uint32(attr.Value[0:4]))\n\t\tcase NDA_MASTER:\n\t\t\tneigh.MasterIndex = int(native.Uint32(attr.Value[0:4]))\n\t\t}\n\t}\n\n\treturn &neigh, nil\n}\n\n// NeighSubscribe takes a chan down which notifications will be sent\n// when neighbors are added or deleted. Close the 'done' chan to stop subscription.\nfunc NeighSubscribe(ch chan<- NeighUpdate, done <-chan struct{}) error {\n\treturn neighSubscribeAt(netns.None(), netns.None(), ch, done, nil, false, 0, nil, false)\n}\n\n// NeighSubscribeAt works like NeighSubscribe plus it allows the caller\n// to choose the network namespace in which to subscribe (ns).\nfunc NeighSubscribeAt(ns netns.NsHandle, ch chan<- NeighUpdate, done <-chan struct{}) error {\n\treturn neighSubscribeAt(ns, netns.None(), ch, done, nil, false, 0, nil, false)\n}\n\n// NeighSubscribeOptions contains a set of options to use with\n// NeighSubscribeWithOptions.\ntype NeighSubscribeOptions struct {\n\tNamespace     *netns.NsHandle\n\tErrorCallback func(error)\n\tListExisting  bool\n\n\t// max size is based on value of /proc/sys/net/core/rmem_max\n\tReceiveBufferSize      int\n\tReceiveBufferForceSize bool\n\tReceiveTimeout         *unix.Timeval\n}\n\n// NeighSubscribeWithOptions work like NeighSubscribe but enable to\n// provide additional options to modify the behavior. Currently, the\n// namespace can be provided as well as an error callback.\n//\n// When options.ListExisting is true, options.ErrorCallback may be\n// called with [ErrDumpInterrupted] to indicate that results from\n// the initial dump of links may be inconsistent or incomplete.\nfunc NeighSubscribeWithOptions(ch chan<- NeighUpdate, done <-chan struct{}, options NeighSubscribeOptions) error {\n\tif options.Namespace == nil {\n\t\tnone := netns.None()\n\t\toptions.Namespace = &none\n\t}\n\treturn neighSubscribeAt(*options.Namespace, netns.None(), ch, done, options.ErrorCallback, options.ListExisting,\n\t\toptions.ReceiveBufferSize, options.ReceiveTimeout, options.ReceiveBufferForceSize)\n}\n\nfunc neighSubscribeAt(newNs, curNs netns.NsHandle, ch chan<- NeighUpdate, done <-chan struct{}, cberr func(error), listExisting bool,\n\trcvbuf int, rcvTimeout *unix.Timeval, rcvbufForce bool) error {\n\ts, err := nl.SubscribeAt(newNs, curNs, unix.NETLINK_ROUTE, unix.RTNLGRP_NEIGH)\n\tmakeRequest := func(family int) error {\n\t\treq := pkgHandle.newNetlinkRequest(unix.RTM_GETNEIGH, unix.NLM_F_DUMP)\n\t\tndmsg := &Ndmsg{Family: uint8(family)}\n\t\treq.AddData(ndmsg)\n\t\tif err := s.Send(req); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tif rcvTimeout != nil {\n\t\tif err := s.SetReceiveTimeout(rcvTimeout); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif rcvbuf != 0 {\n\t\terr = s.SetReceiveBufferSize(rcvbuf, rcvbufForce)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif done != nil {\n\t\tgo func() {\n\t\t\t<-done\n\t\t\ts.Close()\n\t\t}()\n\t}\n\tif listExisting {\n\t\tif err := makeRequest(unix.AF_UNSPEC); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// We have to wait for NLMSG_DONE before making AF_BRIDGE request\n\t}\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor {\n\t\t\tmsgs, from, err := s.Receive()\n\t\t\tif err != nil {\n\t\t\t\tif cberr != nil {\n\t\t\t\t\tcberr(err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif from.Pid != nl.PidKernel {\n\t\t\t\tif cberr != nil {\n\t\t\t\t\tcberr(fmt.Errorf(\"Wrong sender portid %d, expected %d\", from.Pid, nl.PidKernel))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, m := range msgs {\n\t\t\t\tif m.Header.Flags&unix.NLM_F_DUMP_INTR != 0 && cberr != nil {\n\t\t\t\t\tcberr(ErrDumpInterrupted)\n\t\t\t\t}\n\t\t\t\tif m.Header.Type == unix.NLMSG_DONE {\n\t\t\t\t\tif listExisting {\n\t\t\t\t\t\t// This will be called after handling AF_UNSPEC\n\t\t\t\t\t\t// list request, we have to wait for NLMSG_DONE\n\t\t\t\t\t\t// before making another request\n\t\t\t\t\t\tif err := makeRequest(unix.AF_BRIDGE); err != nil {\n\t\t\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\t\t\tcberr(err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlistExisting = false\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif m.Header.Type == unix.NLMSG_ERROR {\n\t\t\t\t\tnError := int32(native.Uint32(m.Data[0:4]))\n\t\t\t\t\tif nError == 0 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\tcberr(syscall.Errno(-nError))\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tneigh, err := NeighDeserialize(m.Data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\tcberr(err)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tch <- NeighUpdate{Type: m.Header.Type, Neigh: *neigh}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n"
        },
        {
          "name": "neigh_test.go",
          "type": "blob",
          "size": 13.74609375,
          "content": "// +build linux\n\npackage netlink\n\nimport (\n\t\"net\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\ntype arpEntry struct {\n\tip  net.IP\n\tmac net.HardwareAddr\n}\n\ntype proxyEntry struct {\n\tip  net.IP\n\tdev int\n}\n\nfunc parseMAC(s string) net.HardwareAddr {\n\tm, err := net.ParseMAC(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn m\n}\n\nfunc dumpContains(dump []Neigh, e arpEntry) bool {\n\tfor _, n := range dump {\n\t\tif n.IP.Equal(e.ip) && (n.State&NUD_INCOMPLETE) == 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc dumpContainsNeigh(dump []Neigh, ne Neigh) bool {\n\tfor _, n := range dump {\n\t\tif n.IP.Equal(ne.IP) && n.LLIPAddr.Equal(ne.LLIPAddr) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc dumpContainsState(dump []Neigh, e arpEntry, s uint16) bool {\n\tfor _, n := range dump {\n\t\tif n.IP.Equal(e.ip) && uint16(n.State) == s {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc dumpContainsProxy(dump []Neigh, p proxyEntry) bool {\n\tfor _, n := range dump {\n\t\tif n.IP.Equal(p.ip) && (n.LinkIndex == p.dev) && (n.Flags&NTF_PROXY) == NTF_PROXY {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestNeighAddDelLLIPAddr(t *testing.T) {\n\tsetUpNetlinkTestWithKModule(t, \"ip_gre\")\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tdummy := Gretun{\n\t\tLinkAttrs: LinkAttrs{Name: \"neigh0\"},\n\t\tLocal:     net.IPv4(127, 0, 0, 1),\n\t\tIKey:      1234,\n\t\tOKey:      1234}\n\tif err := LinkAdd(&dummy); err != nil {\n\t\tt.Errorf(\"Failed to create link: %v\", err)\n\t}\n\tensureIndex(dummy.Attrs())\n\n\tentry := Neigh{\n\t\tLinkIndex: dummy.Index,\n\t\tState:     NUD_PERMANENT,\n\t\tIP:        net.IPv4(198, 51, 100, 2),\n\t\tLLIPAddr:  net.IPv4(198, 51, 100, 1),\n\t}\n\n\terr := NeighAdd(&entry)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t}\n\n\t// Dump and see that all added entries are there\n\tdump, err := NeighList(dummy.Index, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighList: %v\", err)\n\t}\n\n\tif !dumpContainsNeigh(dump, entry) {\n\t\tt.Errorf(\"Dump does not contain: %v: %v\", entry, dump)\n\t}\n\n\t// Delete the entry\n\terr = NeighDel(&entry)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighDel: %v\", err)\n\t}\n\n\tif err := LinkDel(&dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestNeighAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tdummy := Dummy{LinkAttrs{Name: \"neigh0\"}}\n\tif err := LinkAdd(&dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tensureIndex(dummy.Attrs())\n\n\tarpTable := []arpEntry{\n\t\t{net.ParseIP(\"10.99.0.1\"), parseMAC(\"aa:bb:cc:dd:00:01\")},\n\t\t{net.ParseIP(\"10.99.0.2\"), parseMAC(\"aa:bb:cc:dd:00:02\")},\n\t\t{net.ParseIP(\"10.99.0.3\"), parseMAC(\"aa:bb:cc:dd:00:03\")},\n\t\t{net.ParseIP(\"10.99.0.4\"), parseMAC(\"aa:bb:cc:dd:00:04\")},\n\t\t{net.ParseIP(\"10.99.0.5\"), parseMAC(\"aa:bb:cc:dd:00:05\")},\n\t}\n\n\t// Add the arpTable\n\tfor _, entry := range arpTable {\n\t\terr := NeighAdd(&Neigh{\n\t\t\tLinkIndex:    dummy.Index,\n\t\t\tState:        NUD_REACHABLE,\n\t\t\tIP:           entry.ip,\n\t\t\tHardwareAddr: entry.mac,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t\t}\n\t}\n\n\t// Dump and see that all added entries are there\n\tdump, err := NeighList(dummy.Index, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighList: %v\", err)\n\t}\n\n\tfor _, entry := range arpTable {\n\t\tif !dumpContains(dump, entry) {\n\t\t\tt.Errorf(\"Dump does not contain: %v\", entry)\n\t\t}\n\t}\n\n\t// Delete the arpTable\n\tfor _, entry := range arpTable {\n\t\terr := NeighDel(&Neigh{\n\t\t\tLinkIndex:    dummy.Index,\n\t\t\tIP:           entry.ip,\n\t\t\tHardwareAddr: entry.mac,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to NeighDel: %v\", err)\n\t\t}\n\t}\n\n\t// TODO: seems not working because of cache\n\t//// Dump and see that none of deleted entries are there\n\t//dump, err = NeighList(dummy.Index, 0)\n\t//if err != nil {\n\t//t.Errorf(\"Failed to NeighList: %v\", err)\n\t//}\n\n\t//for _, entry := range arpTable {\n\t//if dumpContains(dump, entry) {\n\t//t.Errorf(\"Dump contains: %v\", entry)\n\t//}\n\t//}\n\n\tif err := LinkDel(&dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestNeighAddDelProxy(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tdummy := Dummy{LinkAttrs{Name: \"neigh0\"}}\n\tif err := LinkAdd(&dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tensureIndex(dummy.Attrs())\n\n\tproxyTable := []proxyEntry{\n\t\t{net.ParseIP(\"10.99.0.1\"), dummy.Index},\n\t\t{net.ParseIP(\"10.99.0.2\"), dummy.Index},\n\t\t{net.ParseIP(\"10.99.0.3\"), dummy.Index},\n\t\t{net.ParseIP(\"10.99.0.4\"), dummy.Index},\n\t\t{net.ParseIP(\"10.99.0.5\"), dummy.Index},\n\t}\n\n\t// Add the proxyTable\n\tfor _, entry := range proxyTable {\n\t\terr := NeighAdd(&Neigh{\n\t\t\tLinkIndex: dummy.Index,\n\t\t\tFlags:     NTF_PROXY,\n\t\t\tIP:        entry.ip,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t\t}\n\t}\n\n\t// Dump and see that all added entries are there\n\tdump, err := NeighProxyList(dummy.Index, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighList: %v\", err)\n\t}\n\n\tfor _, entry := range proxyTable {\n\t\tif !dumpContainsProxy(dump, entry) {\n\t\t\tt.Errorf(\"Dump does not contain: %v\", entry)\n\t\t}\n\t}\n\n\t// Delete the proxyTable\n\tfor _, entry := range proxyTable {\n\t\terr := NeighDel(&Neigh{\n\t\t\tLinkIndex: dummy.Index,\n\t\t\tFlags:     NTF_PROXY,\n\t\t\tIP:        entry.ip,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to NeighDel: %v\", err)\n\t\t}\n\t}\n\n\t// Dump and see that none of deleted entries are there\n\tdump, err = NeighProxyList(dummy.Index, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighList: %v\", err)\n\t}\n\n\tfor _, entry := range proxyTable {\n\t\tif dumpContainsProxy(dump, entry) {\n\t\t\tt.Errorf(\"Dump contains: %v\", entry)\n\t\t}\n\t}\n\n\tif err := LinkDel(&dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// expectNeighUpdate returns whether the expected updates are received within one second.\nfunc expectNeighUpdate(ch <-chan NeighUpdate, expected []NeighUpdate) bool {\n\tfor {\n\t\ttimeout := time.After(time.Second)\n\t\tselect {\n\t\tcase update := <-ch:\n\t\t\tvar toDelete []int\n\t\t\tfor index, elem := range expected {\n\t\t\t\tif update.Type == elem.Type &&\n\t\t\t\t\tupdate.Neigh.State == elem.Neigh.State &&\n\t\t\t\t\tupdate.Neigh.IP != nil &&\n\t\t\t\t\tupdate.Neigh.IP.Equal(elem.Neigh.IP) {\n\t\t\t\t\ttoDelete = append(toDelete, index)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor done, index := range toDelete {\n\t\t\t\texpected = append(expected[:index-done], expected[index-done+1:]...)\n\t\t\t}\n\t\t\tif len(expected) == 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase <-timeout:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunc TestNeighSubscribe(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tdummy := &Dummy{LinkAttrs{Name: \"neigh0\"}}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Errorf(\"Failed to create link: %v\", err)\n\t}\n\tensureIndex(dummy.Attrs())\n\tdefer func() {\n\t\tif err := LinkDel(dummy); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tch := make(chan NeighUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := NeighSubscribe(ch, done); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tentry := &Neigh{\n\t\tLinkIndex:    dummy.Index,\n\t\tState:        NUD_REACHABLE,\n\t\tIP:           net.IPv4(10, 99, 0, 1),\n\t\tHardwareAddr: parseMAC(\"aa:bb:cc:dd:00:01\"),\n\t}\n\n\tif err := NeighAdd(entry); err != nil {\n\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t}\n\tif !expectNeighUpdate(ch, []NeighUpdate{NeighUpdate{\n\t\tType:  unix.RTM_NEWNEIGH,\n\t\tNeigh: *entry,\n\t}}) {\n\t\tt.Fatalf(\"Add update not received as expected\")\n\t}\n\tif err := NeighDel(entry); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !expectNeighUpdate(ch, []NeighUpdate{NeighUpdate{\n\t\tType: unix.RTM_NEWNEIGH,\n\t\tNeigh: Neigh{\n\t\t\tState: NUD_FAILED,\n\t\t\tIP:    entry.IP},\n\t}}) {\n\t\tt.Fatalf(\"Del update not received as expected\")\n\t}\n}\n\nfunc TestNeighSubscribeWithOptions(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tch := make(chan NeighUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tvar lastError error\n\tdefer func() {\n\t\tif lastError != nil {\n\t\t\tt.Fatalf(\"Fatal error received during subscription: %v\", lastError)\n\t\t}\n\t}()\n\tif err := NeighSubscribeWithOptions(ch, done, NeighSubscribeOptions{\n\t\tErrorCallback: func(err error) {\n\t\t\tlastError = err\n\t\t},\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdummy := &Dummy{LinkAttrs{Name: \"neigh0\"}}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Errorf(\"Failed to create link: %v\", err)\n\t}\n\tensureIndex(dummy.Attrs())\n\tdefer func() {\n\t\tif err := LinkDel(dummy); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tentry := &Neigh{\n\t\tLinkIndex:    dummy.Index,\n\t\tState:        NUD_REACHABLE,\n\t\tIP:           net.IPv4(10, 99, 0, 1),\n\t\tHardwareAddr: parseMAC(\"aa:bb:cc:dd:00:01\"),\n\t}\n\n\terr := NeighAdd(entry)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t}\n\tif !expectNeighUpdate(ch, []NeighUpdate{NeighUpdate{\n\t\tType:  unix.RTM_NEWNEIGH,\n\t\tNeigh: *entry,\n\t}}) {\n\t\tt.Fatalf(\"Add update not received as expected\")\n\t}\n}\n\nfunc TestNeighSubscribeAt(t *testing.T) {\n\tskipUnlessRoot(t)\n\n\t// Create an handle on a custom netns\n\tnewNs, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer newNs.Close()\n\n\tnh, err := NewHandleAt(newNs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer nh.Close()\n\n\t// Subscribe for Neigh events on the custom netns\n\tch := make(chan NeighUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := NeighSubscribeAt(newNs, ch, done); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdummy := &Dummy{LinkAttrs{Name: \"neigh0\"}}\n\tif err := nh.LinkAdd(dummy); err != nil {\n\t\tt.Errorf(\"Failed to create link: %v\", err)\n\t}\n\tensureIndex(dummy.Attrs())\n\tdefer func() {\n\t\tif err := nh.LinkDel(dummy); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tentry := &Neigh{\n\t\tLinkIndex:    dummy.Index,\n\t\tState:        NUD_REACHABLE,\n\t\tIP:           net.IPv4(198, 51, 100, 1),\n\t\tHardwareAddr: parseMAC(\"aa:bb:cc:dd:00:01\"),\n\t}\n\n\terr = nh.NeighAdd(entry)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t}\n\tif !expectNeighUpdate(ch, []NeighUpdate{NeighUpdate{\n\t\tType:  unix.RTM_NEWNEIGH,\n\t\tNeigh: *entry,\n\t}}) {\n\t\tt.Fatalf(\"Add update not received as expected\")\n\t}\n}\n\nfunc TestNeighSubscribeListExisting(t *testing.T) {\n\tskipUnlessRoot(t)\n\n\t// Create an handle on a custom netns\n\tnewNs, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer newNs.Close()\n\n\tnh, err := NewHandleAt(newNs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer nh.Close()\n\n\tdummy := &Dummy{LinkAttrs{Name: \"neigh0\"}}\n\tif err := nh.LinkAdd(dummy); err != nil {\n\t\tt.Errorf(\"Failed to create link: %v\", err)\n\t}\n\tensureIndex(dummy.Attrs())\n\tdefer func() {\n\t\tif err := nh.LinkDel(dummy); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tvxlani := &Vxlan{LinkAttrs: LinkAttrs{Name: \"neigh1\"}, VxlanId: 1}\n\tif err := nh.LinkAdd(vxlani); err != nil {\n\t\tt.Errorf(\"Failed to create link: %v\", err)\n\t}\n\tensureIndex(vxlani.Attrs())\n\tdefer func() {\n\t\tif err := nh.LinkDel(vxlani); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tentry1 := &Neigh{\n\t\tLinkIndex:    dummy.Index,\n\t\tState:        NUD_REACHABLE,\n\t\tIP:           net.IPv4(198, 51, 100, 1),\n\t\tHardwareAddr: parseMAC(\"aa:bb:cc:dd:00:01\"),\n\t}\n\n\tentryBr := &Neigh{\n\t\tFamily:       syscall.AF_BRIDGE,\n\t\tLinkIndex:    vxlani.Index,\n\t\tState:        NUD_PERMANENT,\n\t\tFlags:        NTF_SELF,\n\t\tIP:           net.IPv4(198, 51, 100, 3),\n\t\tHardwareAddr: parseMAC(\"aa:bb:cc:dd:00:03\"),\n\t}\n\n\terr = nh.NeighAdd(entry1)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t}\n\terr = nh.NeighAppend(entryBr)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t}\n\n\t// Subscribe for Neigh events including existing neighbors\n\tch := make(chan NeighUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := NeighSubscribeWithOptions(ch, done, NeighSubscribeOptions{\n\t\tNamespace:    &newNs,\n\t\tListExisting: true},\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectNeighUpdate(ch, []NeighUpdate{\n\t\tNeighUpdate{\n\t\t\tType:  unix.RTM_NEWNEIGH,\n\t\t\tNeigh: *entry1,\n\t\t},\n\t\tNeighUpdate{\n\t\t\tType:  unix.RTM_NEWNEIGH,\n\t\t\tNeigh: *entryBr,\n\t\t},\n\t}) {\n\t\tt.Fatalf(\"Existing add update not received as expected\")\n\t}\n\n\tentry2 := &Neigh{\n\t\tLinkIndex:    dummy.Index,\n\t\tState:        NUD_PERMANENT,\n\t\tIP:           net.IPv4(198, 51, 100, 2),\n\t\tHardwareAddr: parseMAC(\"aa:bb:cc:dd:00:02\"),\n\t}\n\n\terr = nh.NeighAdd(entry2)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t}\n\n\tif !expectNeighUpdate(ch, []NeighUpdate{NeighUpdate{\n\t\tType:  unix.RTM_NEWNEIGH,\n\t\tNeigh: *entry2,\n\t}}) {\n\t\tt.Fatalf(\"Existing add update not received as expected\")\n\t}\n}\n\nfunc TestNeighListExecuteStateFilter(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// Create dummy iface\n\tdummy := Dummy{LinkAttrs{Name: \"neigh0\"}}\n\tif err := LinkAdd(&dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tensureIndex(dummy.Attrs())\n\n\t// Define some entries\n\treachArpTable := []arpEntry{\n\t\t{net.ParseIP(\"198.51.100.1\"), parseMAC(\"44:bb:cc:dd:00:01\")},\n\t\t{net.ParseIP(\"2001:db8::1\"), parseMAC(\"66:bb:cc:dd:00:02\")},\n\t}\n\n\tstaleArpTable := []arpEntry{\n\t\t{net.ParseIP(\"198.51.100.10\"), parseMAC(\"44:bb:cc:dd:00:10\")},\n\t\t{net.ParseIP(\"2001:db8::10\"), parseMAC(\"66:bb:cc:dd:00:10\")},\n\t}\n\n\tentries := append(reachArpTable, staleArpTable...)\n\n\t// Add reachable neigh entries\n\tfor _, entry := range reachArpTable {\n\t\terr := NeighAdd(&Neigh{\n\t\t\tLinkIndex:    dummy.Index,\n\t\t\tState:        NUD_REACHABLE,\n\t\t\tIP:           entry.ip,\n\t\t\tHardwareAddr: entry.mac,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t\t}\n\t}\n\t// Add stale neigh entries\n\tfor _, entry := range staleArpTable {\n\t\terr := NeighAdd(&Neigh{\n\t\t\tLinkIndex:    dummy.Index,\n\t\t\tState:        NUD_STALE,\n\t\t\tIP:           entry.ip,\n\t\t\tHardwareAddr: entry.mac,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to NeighAdd: %v\", err)\n\t\t}\n\t}\n\n\t// Dump reachable and see that all added reachable entries are present and there are no stale entries\n\tdump, err := NeighListExecute(Ndmsg{\n\t\tIndex: uint32(dummy.Index),\n\t\tState: NUD_REACHABLE,\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Failed to NeighListExecute: %v\", err)\n\t}\n\n\tfor _, entry := range reachArpTable {\n\t\tif !dumpContainsState(dump, entry, NUD_REACHABLE) {\n\t\t\tt.Errorf(\"Dump does not contains: %v\", entry)\n\t\t}\n\t}\n\tfor _, entry := range staleArpTable {\n\t\tif dumpContainsState(dump, entry, NUD_STALE) {\n\t\t\tt.Errorf(\"Dump contains: %v\", entry)\n\t\t}\n\t}\n\n\t// Delete all neigh entries\n\tfor _, entry := range entries {\n\t\terr := NeighDel(&Neigh{\n\t\t\tLinkIndex:    dummy.Index,\n\t\t\tIP:           entry.ip,\n\t\t\tHardwareAddr: entry.mac,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to NeighDel: %v\", err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "netlink.go",
          "type": "blob",
          "size": 1.3408203125,
          "content": "// Package netlink provides a simple library for netlink. Netlink is\n// the interface a user-space program in linux uses to communicate with\n// the kernel. It can be used to add and remove interfaces, set up ip\n// addresses and routes, and confiugre ipsec. Netlink communication\n// requires elevated privileges, so in most cases this code needs to\n// be run as root. The low level primitives for netlink are contained\n// in the nl subpackage. This package attempts to provide a high-level\n// interface that is loosly modeled on the iproute2 cli.\npackage netlink\n\nimport (\n\t\"errors\"\n\t\"net\"\n)\n\nvar (\n\t// ErrNotImplemented is returned when a requested feature is not implemented.\n\tErrNotImplemented = errors.New(\"not implemented\")\n)\n\n// ParseIPNet parses a string in ip/net format and returns a net.IPNet.\n// This is valuable because addresses in netlink are often IPNets and\n// ParseCIDR returns an IPNet with the IP part set to the base IP of the\n// range.\nfunc ParseIPNet(s string) (*net.IPNet, error) {\n\tip, ipNet, err := net.ParseCIDR(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tipNet.IP = ip\n\treturn ipNet, nil\n}\n\n// NewIPNet generates an IPNet from an ip address using a netmask of 32 or 128.\nfunc NewIPNet(ip net.IP) *net.IPNet {\n\tif ip.To4() != nil {\n\t\treturn &net.IPNet{IP: ip, Mask: net.CIDRMask(32, 32)}\n\t}\n\treturn &net.IPNet{IP: ip, Mask: net.CIDRMask(128, 128)}\n}\n"
        },
        {
          "name": "netlink_linux.go",
          "type": "blob",
          "size": 0.31640625,
          "content": "package netlink\n\nimport \"github.com/vishvananda/netlink/nl\"\n\n// Family type definitions\nconst (\n\tFAMILY_ALL  = nl.FAMILY_ALL\n\tFAMILY_V4   = nl.FAMILY_V4\n\tFAMILY_V6   = nl.FAMILY_V6\n\tFAMILY_MPLS = nl.FAMILY_MPLS\n)\n\n// ErrDumpInterrupted is an alias for [nl.ErrDumpInterrupted].\nvar ErrDumpInterrupted = nl.ErrDumpInterrupted\n"
        },
        {
          "name": "netlink_test.go",
          "type": "blob",
          "size": 6.1669921875,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\ntype tearDownNetlinkTest func()\n\nfunc skipUnlessRoot(t testing.TB) {\n\tt.Helper()\n\n\tif os.Getuid() != 0 {\n\t\tt.Skip(\"Test requires root privileges.\")\n\t}\n}\n\nfunc skipUnlessKModuleLoaded(t *testing.T, moduleNames ...string) {\n\tt.Helper()\n\tfile, err := ioutil.ReadFile(\"/proc/modules\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open /proc/modules\", err)\n\t}\n\n\tfoundRequiredMods := make(map[string]bool)\n\tlines := strings.Split(string(file), \"\\n\")\n\n\tfor _, name := range moduleNames {\n\t\tfoundRequiredMods[name] = false\n\t\tfor _, line := range lines {\n\t\t\tn := strings.Split(line, \" \")[0]\n\t\t\tif n == name {\n\t\t\t\tfoundRequiredMods[name] = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tfailed := false\n\tfor _, name := range moduleNames {\n\t\tif found, _ := foundRequiredMods[name]; !found {\n\t\t\tt.Logf(\"Test requires missing kmodule %q.\", name)\n\t\t\tfailed = true\n\t\t}\n\t}\n\tif failed {\n\t\tt.SkipNow()\n\t}\n}\n\nfunc setUpNetlinkTest(t testing.TB) tearDownNetlinkTest {\n\tskipUnlessRoot(t)\n\n\t// new temporary namespace so we don't pollute the host\n\t// lock thread since the namespace is thread local\n\truntime.LockOSThread()\n\tvar err error\n\tns, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create newns\", ns)\n\t}\n\n\treturn func() {\n\t\tns.Close()\n\t\truntime.UnlockOSThread()\n\t}\n}\n\n// setUpNamedNetlinkTest create a temporary named names space with a random name\nfunc setUpNamedNetlinkTest(t *testing.T) (string, tearDownNetlinkTest) {\n\tskipUnlessRoot(t)\n\n\torigNS, err := netns.Get()\n\tif err != nil {\n\t\tt.Fatal(\"Failed saving orig namespace\")\n\t}\n\n\t// create a random name\n\trnd := make([]byte, 4)\n\tif _, err := rand.Read(rnd); err != nil {\n\t\tt.Fatal(\"failed creating random ns name\")\n\t}\n\tname := \"netlinktest-\" + hex.EncodeToString(rnd)\n\n\tns, err := netns.NewNamed(name)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create new ns\", err)\n\t}\n\n\truntime.LockOSThread()\n\tcleanup := func() {\n\t\tns.Close()\n\t\tnetns.DeleteNamed(name)\n\t\tnetns.Set(origNS)\n\t\truntime.UnlockOSThread()\n\t}\n\n\tif err := netns.Set(ns); err != nil {\n\t\tcleanup()\n\t\tt.Fatal(\"Failed entering new namespace\", err)\n\t}\n\n\treturn name, cleanup\n}\n\nfunc setUpNetlinkTestWithLoopback(t *testing.T) tearDownNetlinkTest {\n\tskipUnlessRoot(t)\n\n\truntime.LockOSThread()\n\tns, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create new netns\", ns)\n\t}\n\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to find \\\"lo\\\" in new netns: %v\", err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatalf(\"Failed to bring up \\\"lo\\\" in new netns: %v\", err)\n\t}\n\n\treturn func() {\n\t\tns.Close()\n\t\truntime.UnlockOSThread()\n\t}\n}\n\nfunc setUpF(t *testing.T, path, value string) {\n\tfile, err := os.Create(path)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open %s: %s\", path, err)\n\t}\n\tdefer file.Close()\n\tfile.WriteString(value)\n}\n\nfunc setUpMPLSNetlinkTest(t *testing.T) tearDownNetlinkTest {\n\tif _, err := os.Stat(\"/proc/sys/net/mpls/platform_labels\"); err != nil {\n\t\tt.Skip(\"Test requires MPLS support.\")\n\t}\n\tf := setUpNetlinkTest(t)\n\tsetUpF(t, \"/proc/sys/net/mpls/platform_labels\", \"1024\")\n\tsetUpF(t, \"/proc/sys/net/mpls/conf/lo/input\", \"1\")\n\treturn f\n}\n\nfunc setUpSEG6NetlinkTest(t *testing.T) tearDownNetlinkTest {\n\t// check if SEG6 options are enabled in Kernel Config\n\tcmd := exec.Command(\"uname\", \"-r\")\n\tvar out bytes.Buffer\n\tcmd.Stdout = &out\n\tif err := cmd.Run(); err != nil {\n\t\tt.Fatal(\"Failed to run: uname -r\")\n\t}\n\ts := []string{\"/boot/config-\", strings.TrimRight(out.String(), \"\\n\")}\n\tfilename := strings.Join(s, \"\")\n\n\tgrepKey := func(key, fname string) (string, error) {\n\t\tcmd := exec.Command(\"grep\", key, filename)\n\t\tvar out bytes.Buffer\n\t\tcmd.Stdout = &out\n\t\terr := cmd.Run() // \"err != nil\" if no line matched with grep\n\t\treturn strings.TrimRight(out.String(), \"\\n\"), err\n\t}\n\tkey := string(\"CONFIG_IPV6_SEG6_LWTUNNEL=y\")\n\tif _, err := grepKey(key, filename); err != nil {\n\t\tmsg := \"Skipped test because it requires SEG6_LWTUNNEL support.\"\n\t\tlog.Println(msg)\n\t\tt.Skip(msg)\n\t}\n\t// Add CONFIG_IPV6_SEG6_HMAC to support seg6_hamc\n\t// key := string(\"CONFIG_IPV6_SEG6_HMAC=y\")\n\n\treturn setUpNetlinkTest(t)\n}\n\nfunc setUpNetlinkTestWithKModule(t *testing.T, moduleNames ...string) tearDownNetlinkTest {\n\tskipUnlessKModuleLoaded(t, moduleNames...)\n\treturn setUpNetlinkTest(t)\n}\nfunc setUpNamedNetlinkTestWithKModule(t *testing.T, moduleNames ...string) (string, tearDownNetlinkTest) {\n\tfile, err := ioutil.ReadFile(\"/proc/modules\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open /proc/modules\", err)\n\t}\n\n\tfoundRequiredMods := make(map[string]bool)\n\tlines := strings.Split(string(file), \"\\n\")\n\n\tfor _, name := range moduleNames {\n\t\tfoundRequiredMods[name] = false\n\t\tfor _, line := range lines {\n\t\t\tn := strings.Split(line, \" \")[0]\n\t\t\tif n == name {\n\t\t\t\tfoundRequiredMods[name] = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tfailed := false\n\tfor _, name := range moduleNames {\n\t\tif found, _ := foundRequiredMods[name]; !found {\n\t\t\tt.Logf(\"Test requires missing kmodule %q.\", name)\n\t\t\tfailed = true\n\t\t}\n\t}\n\tif failed {\n\t\tt.SkipNow()\n\t}\n\n\treturn setUpNamedNetlinkTest(t)\n}\n\nfunc remountSysfs() error {\n\tif err := unix.Mount(\"\", \"/\", \"none\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\treturn err\n\t}\n\tif err := unix.Unmount(\"/sys\", unix.MNT_DETACH); err != nil {\n\t\treturn err\n\t}\n\treturn unix.Mount(\"\", \"/sys\", \"sysfs\", 0, \"\")\n}\n\nfunc minKernelRequired(t *testing.T, kernel, major int) {\n\tt.Helper()\n\n\tk, m, err := KernelVersion()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif k < kernel || k == kernel && m < major {\n\t\tt.Skipf(\"Host Kernel (%d.%d) does not meet test's minimum required version: (%d.%d)\",\n\t\t\tk, m, kernel, major)\n\t}\n}\n\nfunc KernelVersion() (kernel, major int, err error) {\n\tuts := unix.Utsname{}\n\tif err = unix.Uname(&uts); err != nil {\n\t\treturn\n\t}\n\n\tba := make([]byte, 0, len(uts.Release))\n\tfor _, b := range uts.Release {\n\t\tif b == 0 {\n\t\t\tbreak\n\t\t}\n\t\tba = append(ba, byte(b))\n\t}\n\tvar rest string\n\tif n, _ := fmt.Sscanf(string(ba), \"%d.%d%s\", &kernel, &major, &rest); n < 2 {\n\t\terr = fmt.Errorf(\"can't parse kernel version in %q\", string(ba))\n\t}\n\treturn\n}\n\nfunc TestMain(m *testing.M) {\n\tnl.EnableErrorMessageReporting = true\n\tos.Exit(m.Run())\n}\n"
        },
        {
          "name": "netlink_unspecified.go",
          "type": "blob",
          "size": 5.53515625,
          "content": "// +build !linux\n\npackage netlink\n\nimport \"net\"\n\nfunc LinkSetUp(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetDown(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetMTU(link Link, mtu int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetMaster(link Link, master Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetNsPid(link Link, nspid int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetNsFd(link Link, fd int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetName(link Link, name string) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetAlias(link Link, name string) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetHardwareAddr(link Link, hwaddr net.HardwareAddr) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetVfHardwareAddr(link Link, vf int, hwaddr net.HardwareAddr) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetVfVlan(link Link, vf, vlan int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetVfVlanQos(link Link, vf, vlan, qos int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetVfVlanQosProto(link Link, vf, vlan, qos, proto int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetVfTxRate(link Link, vf, rate int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetVfRate(link Link, vf, minRate, maxRate int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetNoMaster(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetMasterByIndex(link Link, masterIndex int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetXdpFd(link Link, fd int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetXdpFdWithFlags(link Link, fd, flags int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetARPOff(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetARPOn(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkByName(name string) (Link, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc LinkByAlias(alias string) (Link, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc LinkByIndex(index int) (Link, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc LinkSetHairpin(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetGuard(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetFastLeave(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetLearning(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetRootBlock(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetFlood(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetTxQLen(link Link, qlen int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetGSOMaxSize(link Link, maxSize int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetGROMaxSize(link Link, maxSize int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetGSOIPv4MaxSize(link Link, maxSize int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkSetGROIPv4MaxSize(link Link, maxSize int) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkAdd(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkDel(link Link) error {\n\treturn ErrNotImplemented\n}\n\nfunc SetHairpin(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc SetGuard(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc SetFastLeave(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc SetLearning(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc SetRootBlock(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc SetFlood(link Link, mode bool) error {\n\treturn ErrNotImplemented\n}\n\nfunc LinkList() ([]Link, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc AddrAdd(link Link, addr *Addr) error {\n\treturn ErrNotImplemented\n}\n\nfunc AddrReplace(link Link, addr *Addr) error {\n\treturn ErrNotImplemented\n}\n\nfunc AddrDel(link Link, addr *Addr) error {\n\treturn ErrNotImplemented\n}\n\nfunc AddrList(link Link, family int) ([]Addr, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc RouteAdd(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc RouteAppend(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc RouteChange(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc RouteDel(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc RouteGet(destination net.IP) ([]Route, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc RouteList(link Link, family int) ([]Route, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc RouteListFiltered(family int, filter *Route, filterMask uint64) ([]Route, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc RouteReplace(route *Route) error {\n\treturn ErrNotImplemented\n}\n\nfunc XfrmPolicyAdd(policy *XfrmPolicy) error {\n\treturn ErrNotImplemented\n}\n\nfunc XfrmPolicyDel(policy *XfrmPolicy) error {\n\treturn ErrNotImplemented\n}\n\nfunc XfrmPolicyList(family int) ([]XfrmPolicy, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc XfrmPolicyGet(policy *XfrmPolicy) (*XfrmPolicy, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc XfrmStateAdd(policy *XfrmState) error {\n\treturn ErrNotImplemented\n}\n\nfunc XfrmStateDel(policy *XfrmState) error {\n\treturn ErrNotImplemented\n}\n\nfunc XfrmStateList(family int) ([]XfrmState, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc NeighAdd(neigh *Neigh) error {\n\treturn ErrNotImplemented\n}\n\nfunc NeighSet(neigh *Neigh) error {\n\treturn ErrNotImplemented\n}\n\nfunc NeighAppend(neigh *Neigh) error {\n\treturn ErrNotImplemented\n}\n\nfunc NeighDel(neigh *Neigh) error {\n\treturn ErrNotImplemented\n}\n\nfunc NeighList(linkIndex, family int) ([]Neigh, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc NeighDeserialize(m []byte) (*Neigh, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc SocketGet(local, remote net.Addr) (*Socket, error) {\n\treturn nil, ErrNotImplemented\n}\n\nfunc SocketDestroy(local, remote net.Addr) (*Socket, error) {\n\treturn nil, ErrNotImplemented\n}\n"
        },
        {
          "name": "netns_linux.go",
          "type": "blob",
          "size": 4.34765625,
          "content": "package netlink\n\n// Network namespace ID functions\n//\n// The kernel has a weird concept called the network namespace ID.\n// This is different from the file reference in proc (and any bind-mounted\n// namespaces, etc.)\n//\n// Instead, namespaces can be assigned a numeric ID at any time. Once set,\n// the ID is fixed. The ID can either be set manually by the user, or\n// automatically, triggered by certain kernel actions. The most common kernel\n// action that triggers namespace ID creation is moving one end of a veth pair\n// in to that namespace.\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// These can be replaced by the values from sys/unix when it is next released.\nconst (\n\t_ = iota\n\tNETNSA_NSID\n\tNETNSA_PID\n\tNETNSA_FD\n)\n\n// GetNetNsIdByPid looks up the network namespace ID for a given pid (really thread id).\n// Returns -1 if the namespace does not have an ID set.\nfunc (h *Handle) GetNetNsIdByPid(pid int) (int, error) {\n\treturn h.getNetNsId(NETNSA_PID, uint32(pid))\n}\n\n// GetNetNsIdByPid looks up the network namespace ID for a given pid (really thread id).\n// Returns -1 if the namespace does not have an ID set.\nfunc GetNetNsIdByPid(pid int) (int, error) {\n\treturn pkgHandle.GetNetNsIdByPid(pid)\n}\n\n// SetNetNSIdByPid sets the ID of the network namespace for a given pid (really thread id).\n// The ID can only be set for namespaces without an ID already set.\nfunc (h *Handle) SetNetNsIdByPid(pid, nsid int) error {\n\treturn h.setNetNsId(NETNSA_PID, uint32(pid), uint32(nsid))\n}\n\n// SetNetNSIdByPid sets the ID of the network namespace for a given pid (really thread id).\n// The ID can only be set for namespaces without an ID already set.\nfunc SetNetNsIdByPid(pid, nsid int) error {\n\treturn pkgHandle.SetNetNsIdByPid(pid, nsid)\n}\n\n// GetNetNsIdByFd looks up the network namespace ID for a given fd.\n// fd must be an open file descriptor to a namespace file.\n// Returns -1 if the namespace does not have an ID set.\nfunc (h *Handle) GetNetNsIdByFd(fd int) (int, error) {\n\treturn h.getNetNsId(NETNSA_FD, uint32(fd))\n}\n\n// GetNetNsIdByFd looks up the network namespace ID for a given fd.\n// fd must be an open file descriptor to a namespace file.\n// Returns -1 if the namespace does not have an ID set.\nfunc GetNetNsIdByFd(fd int) (int, error) {\n\treturn pkgHandle.GetNetNsIdByFd(fd)\n}\n\n// SetNetNSIdByFd sets the ID of the network namespace for a given fd.\n// fd must be an open file descriptor to a namespace file.\n// The ID can only be set for namespaces without an ID already set.\nfunc (h *Handle) SetNetNsIdByFd(fd, nsid int) error {\n\treturn h.setNetNsId(NETNSA_FD, uint32(fd), uint32(nsid))\n}\n\n// SetNetNSIdByFd sets the ID of the network namespace for a given fd.\n// fd must be an open file descriptor to a namespace file.\n// The ID can only be set for namespaces without an ID already set.\nfunc SetNetNsIdByFd(fd, nsid int) error {\n\treturn pkgHandle.SetNetNsIdByFd(fd, nsid)\n}\n\n// getNetNsId requests the netnsid for a given type-val pair\n// type should be either NETNSA_PID or NETNSA_FD\nfunc (h *Handle) getNetNsId(attrType int, val uint32) (int, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETNSID, unix.NLM_F_REQUEST)\n\n\trtgen := nl.NewRtGenMsg()\n\treq.AddData(rtgen)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, val)\n\tattr := nl.NewRtAttr(attrType, b)\n\treq.AddData(attr)\n\n\tmsgs, err := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWNSID)\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor _, m := range msgs {\n\t\tmsg := nl.DeserializeRtGenMsg(m)\n\n\t\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tfor _, attr := range attrs {\n\t\t\tswitch attr.Attr.Type {\n\t\t\tcase NETNSA_NSID:\n\t\t\t\treturn int(int32(native.Uint32(attr.Value))), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0, fmt.Errorf(\"unexpected empty result\")\n}\n\n// setNetNsId sets the netnsid for a given type-val pair\n// type should be either NETNSA_PID or NETNSA_FD\n// The ID can only be set for namespaces without an ID already set\nfunc (h *Handle) setNetNsId(attrType int, val uint32, newnsid uint32) error {\n\treq := h.newNetlinkRequest(unix.RTM_NEWNSID, unix.NLM_F_REQUEST|unix.NLM_F_ACK)\n\n\trtgen := nl.NewRtGenMsg()\n\treq.AddData(rtgen)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, val)\n\tattr := nl.NewRtAttr(attrType, b)\n\treq.AddData(attr)\n\n\tb1 := make([]byte, 4)\n\tnative.PutUint32(b1, newnsid)\n\tattr1 := nl.NewRtAttr(NETNSA_NSID, b1)\n\treq.AddData(attr1)\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWNSID)\n\treturn err\n}\n"
        },
        {
          "name": "netns_test.go",
          "type": "blob",
          "size": 2.04296875,
          "content": "// +build linux\n\npackage netlink\n\nimport (\n\t\"os\"\n\t\"runtime\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/vishvananda/netns\"\n)\n\n// TestNetNsIdByFd tests setting and getting the network namespace ID\n// by file descriptor. It opens a namespace fd, sets it to a random id,\n// then retrieves the ID.\n// This does not do any namespace switching.\nfunc TestNetNsIdByFd(t *testing.T) {\n\tskipUnlessRoot(t)\n\t// create a network namespace\n\tns, err := netns.New()\n\tCheckErrorFail(t, err)\n\n\t// set its ID\n\t// In an attempt to avoid namespace id collisions, set this to something\n\t// insanely high. When the kernel assigns IDs, it does so starting from 0\n\t// So, just use our pid shifted up 16 bits\n\twantID := os.Getpid() << 16\n\n\th, err := NewHandle()\n\tCheckErrorFail(t, err)\n\terr = h.SetNetNsIdByFd(int(ns), wantID)\n\tCheckErrorFail(t, err)\n\n\t// Get the ID back, make sure it matches\n\thaveID, _ := h.GetNetNsIdByFd(int(ns))\n\tif haveID != wantID {\n\t\tt.Errorf(\"GetNetNsIdByFd returned %d, want %d\", haveID, wantID)\n\t}\n\n\tns.Close()\n}\n\n// TestNetNsIdByPid tests manipulating namespace IDs by pid (really, task / thread id)\n// Does the same as TestNetNsIdByFd, but we need to change namespaces so we\n// actually have a pid in that namespace\nfunc TestNetNsIdByPid(t *testing.T) {\n\tskipUnlessRoot(t)\n\truntime.LockOSThread() // we need a constant OS thread\n\torigNs, _ := netns.Get()\n\n\t// create and enter a new netns\n\tns, err := netns.New()\n\tCheckErrorFail(t, err)\n\terr = netns.Set(ns)\n\tCheckErrorFail(t, err)\n\t// make sure we go back to the original namespace when done\n\tdefer func() {\n\t\terr := netns.Set(origNs)\n\t\tif err != nil {\n\t\t\tpanic(\"failed to restore network ns, bailing\")\n\t\t}\n\t\truntime.UnlockOSThread()\n\t}()\n\n\t// As above, we'll pick a crazy large netnsid to avoid collisions\n\twantID := syscall.Gettid() << 16\n\n\th, err := NewHandle()\n\tCheckErrorFail(t, err)\n\terr = h.SetNetNsIdByPid(syscall.Gettid(), wantID)\n\tCheckErrorFail(t, err)\n\n\t//Get the ID and see if it worked\n\thaveID, _ := h.GetNetNsIdByPid(syscall.Gettid())\n\tif haveID != wantID {\n\t\tt.Errorf(\"GetNetNsIdByPid returned %d, want %d\", haveID, wantID)\n\t}\n}\n"
        },
        {
          "name": "netns_unspecified.go",
          "type": "blob",
          "size": 0.322265625,
          "content": "// +build !linux\n\npackage netlink\n\nfunc GetNetNsIdByPid(pid int) (int, error) {\n\treturn 0, ErrNotImplemented\n}\n\nfunc SetNetNsIdByPid(pid, nsid int) error {\n\treturn ErrNotImplemented\n}\n\nfunc GetNetNsIdByFd(fd int) (int, error) {\n\treturn 0, ErrNotImplemented\n}\n\nfunc SetNetNsIdByFd(fd, nsid int) error {\n\treturn ErrNotImplemented\n}\n"
        },
        {
          "name": "nl",
          "type": "tree",
          "content": null
        },
        {
          "name": "order.go",
          "type": "blob",
          "size": 0.5224609375,
          "content": "package netlink\n\nimport (\n\t\"encoding/binary\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n)\n\nvar (\n\tnative       = nl.NativeEndian()\n\tnetworkOrder = binary.BigEndian\n)\n\nfunc htonl(val uint32) []byte {\n\tbytes := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(bytes, val)\n\treturn bytes\n}\n\nfunc htons(val uint16) []byte {\n\tbytes := make([]byte, 2)\n\tbinary.BigEndian.PutUint16(bytes, val)\n\treturn bytes\n}\n\nfunc ntohl(buf []byte) uint32 {\n\treturn binary.BigEndian.Uint32(buf)\n}\n\nfunc ntohs(buf []byte) uint16 {\n\treturn binary.BigEndian.Uint16(buf)\n}\n"
        },
        {
          "name": "proc_event_linux.go",
          "type": "blob",
          "size": 3.6796875,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst CN_IDX_PROC = 0x1\n\nconst (\n\tPROC_EVENT_NONE     = 0x00000000\n\tPROC_EVENT_FORK     = 0x00000001\n\tPROC_EVENT_EXEC     = 0x00000002\n\tPROC_EVENT_UID      = 0x00000004\n\tPROC_EVENT_GID      = 0x00000040\n\tPROC_EVENT_SID      = 0x00000080\n\tPROC_EVENT_PTRACE   = 0x00000100\n\tPROC_EVENT_COMM     = 0x00000200\n\tPROC_EVENT_COREDUMP = 0x40000000\n\tPROC_EVENT_EXIT     = 0x80000000\n)\n\nconst (\n\tCN_VAL_PROC          = 0x1\n\tPROC_CN_MCAST_LISTEN = 0x1\n)\n\ntype ProcEventMsg interface {\n\tPid() uint32\n\tTgid() uint32\n}\n\ntype ProcEventHeader struct {\n\tWhat      uint32\n\tCPU       uint32\n\tTimestamp uint64\n}\n\ntype ProcEvent struct {\n\tProcEventHeader\n\tMsg ProcEventMsg\n}\n\nfunc (pe *ProcEvent) setHeader(h ProcEventHeader) {\n\tpe.What = h.What\n\tpe.CPU = h.CPU\n\tpe.Timestamp = h.Timestamp\n}\n\ntype ExitProcEvent struct {\n\tProcessPid  uint32\n\tProcessTgid uint32\n\tExitCode    uint32\n\tExitSignal  uint32\n\tParentPid   uint32\n\tParentTgid  uint32\n}\n\nfunc (e *ExitProcEvent) Pid() uint32 {\n\treturn e.ProcessPid\n}\n\nfunc (e *ExitProcEvent) Tgid() uint32 {\n\treturn e.ProcessTgid\n}\n\ntype ExecProcEvent struct {\n\tProcessPid  uint32\n\tProcessTgid uint32\n}\n\nfunc (e *ExecProcEvent) Pid() uint32 {\n\treturn e.ProcessPid\n}\n\nfunc (e *ExecProcEvent) Tgid() uint32 {\n\treturn e.ProcessTgid\n}\n\ntype ForkProcEvent struct {\n\tParentPid  uint32\n\tParentTgid uint32\n\tChildPid   uint32\n\tChildTgid  uint32\n}\n\nfunc (e *ForkProcEvent) Pid() uint32 {\n\treturn e.ParentPid\n}\n\nfunc (e *ForkProcEvent) Tgid() uint32 {\n\treturn e.ParentTgid\n}\n\ntype CommProcEvent struct {\n\tProcessPid  uint32\n\tProcessTgid uint32\n\tComm        [16]byte\n}\n\nfunc (e *CommProcEvent) Pid() uint32 {\n\treturn e.ProcessPid\n}\n\nfunc (e *CommProcEvent) Tgid() uint32 {\n\treturn e.ProcessTgid\n}\n\nfunc ProcEventMonitor(ch chan<- ProcEvent, done <-chan struct{}, errorChan chan<- error) error {\n\th, err := NewHandle()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer h.Delete()\n\n\ts, err := nl.SubscribeAt(netns.None(), netns.None(), unix.NETLINK_CONNECTOR, CN_IDX_PROC)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar nlmsg nl.NetlinkRequest\n\n\tnlmsg.Pid = uint32(os.Getpid())\n\tnlmsg.Type = unix.NLMSG_DONE\n\tnlmsg.Len = uint32(unix.SizeofNlMsghdr)\n\n\tcm := nl.NewCnMsg(CN_IDX_PROC, CN_VAL_PROC, PROC_CN_MCAST_LISTEN)\n\tnlmsg.AddData(cm)\n\n\ts.Send(&nlmsg)\n\n\tif done != nil {\n\t\tgo func() {\n\t\t\t<-done\n\t\t\ts.Close()\n\t\t}()\n\t}\n\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor {\n\t\t\tmsgs, from, err := s.Receive()\n\t\t\tif err != nil {\n\t\t\t\terrorChan <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif from.Pid != nl.PidKernel {\n\t\t\t\terrorChan <- fmt.Errorf(\"Wrong sender portid %d, expected %d\", from.Pid, nl.PidKernel)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor _, m := range msgs {\n\t\t\t\te := parseNetlinkMessage(m)\n\t\t\t\tif e != nil {\n\t\t\t\t\tch <- *e\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc parseNetlinkMessage(m syscall.NetlinkMessage) *ProcEvent {\n\tif m.Header.Type == unix.NLMSG_DONE {\n\t\tbuf := bytes.NewBuffer(m.Data)\n\t\tmsg := &nl.CnMsg{}\n\t\thdr := &ProcEventHeader{}\n\t\tbinary.Read(buf, nl.NativeEndian(), msg)\n\t\tbinary.Read(buf, nl.NativeEndian(), hdr)\n\n\t\tpe := &ProcEvent{}\n\t\tpe.setHeader(*hdr)\n\t\tswitch hdr.What {\n\t\tcase PROC_EVENT_EXIT:\n\t\t\tevent := &ExitProcEvent{}\n\t\t\tbinary.Read(buf, nl.NativeEndian(), event)\n\t\t\tpe.Msg = event\n\t\t\treturn pe\n\t\tcase PROC_EVENT_FORK:\n\t\t\tevent := &ForkProcEvent{}\n\t\t\tbinary.Read(buf, nl.NativeEndian(), event)\n\t\t\tpe.Msg = event\n\t\t\treturn pe\n\t\tcase PROC_EVENT_EXEC:\n\t\t\tevent := &ExecProcEvent{}\n\t\t\tbinary.Read(buf, nl.NativeEndian(), event)\n\t\t\tpe.Msg = event\n\t\t\treturn pe\n\t\tcase PROC_EVENT_COMM:\n\t\t\tevent := &CommProcEvent{}\n\t\t\tbinary.Read(buf, nl.NativeEndian(), event)\n\t\t\tpe.Msg = event\n\t\t\treturn pe\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "proc_event_test.go",
          "type": "blob",
          "size": 1.3564453125,
          "content": "// +build linux\n\npackage netlink\n\nimport (\n\t\"github.com/vishvananda/netns\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"testing\"\n)\n\nfunc TestSubscribeProcEvent(t *testing.T) {\n\tskipUnlessRoot(t)\n\truntime.LockOSThread()\n\tdefer runtime.UnlockOSThread()\n\n\tpid1ns, err := netns.GetFromPid(1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = netns.Set(pid1ns)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tch := make(chan ProcEvent)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\terrChan := make(chan error)\n\n\tif err := ProcEventMonitor(ch, done, errChan); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcmd := exec.Command(\"false\")\n\tif err := cmd.Start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// first we wait for proc - i.e. childTgid is cmd.Process.Pid\n\tfor {\n\t\te := <-ch\n\t\tt.Logf(\"pid: %+v e: %+v\", os.Getpid(), e)\n\t\tif e.Msg.Tgid() == uint32(os.Getpid()) {\n\t\t\tif forkEvent, ok := e.Msg.(*ForkProcEvent); ok {\n\t\t\t\tif forkEvent.ChildTgid == uint32(cmd.Process.Pid) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// wait for exec event\n\tfor {\n\t\te := <-ch\n\t\tif e.Msg.Tgid() == uint32(cmd.Process.Pid) {\n\t\t\tif _, ok := e.Msg.(*ExecProcEvent); ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd.Wait()\n\tfor {\n\t\te := <-ch\n\t\tif e.Msg.Tgid() == uint32(cmd.Process.Pid) {\n\t\t\tif exitEvent, ok := e.Msg.(*ExitProcEvent); ok {\n\t\t\t\tif exitEvent.ExitCode != 256 {\n\t\t\t\t\tt.Errorf(\"Expected error code 256 (-1), but got %+v\", exitEvent)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tdone <- struct{}{}\n}\n"
        },
        {
          "name": "protinfo.go",
          "type": "blob",
          "size": 1.330078125,
          "content": "package netlink\n\nimport (\n\t\"strings\"\n)\n\n// Protinfo represents bridge flags from netlink.\ntype Protinfo struct {\n\tHairpin       bool\n\tGuard         bool\n\tFastLeave     bool\n\tRootBlock     bool\n\tLearning      bool\n\tFlood         bool\n\tProxyArp      bool\n\tProxyArpWiFi  bool\n\tIsolated      bool\n\tNeighSuppress bool\n}\n\n// String returns a list of enabled flags\nfunc (prot *Protinfo) String() string {\n\tif prot == nil {\n\t\treturn \"<nil>\"\n\t}\n\n\tvar boolStrings []string\n\tif prot.Hairpin {\n\t\tboolStrings = append(boolStrings, \"Hairpin\")\n\t}\n\tif prot.Guard {\n\t\tboolStrings = append(boolStrings, \"Guard\")\n\t}\n\tif prot.FastLeave {\n\t\tboolStrings = append(boolStrings, \"FastLeave\")\n\t}\n\tif prot.RootBlock {\n\t\tboolStrings = append(boolStrings, \"RootBlock\")\n\t}\n\tif prot.Learning {\n\t\tboolStrings = append(boolStrings, \"Learning\")\n\t}\n\tif prot.Flood {\n\t\tboolStrings = append(boolStrings, \"Flood\")\n\t}\n\tif prot.ProxyArp {\n\t\tboolStrings = append(boolStrings, \"ProxyArp\")\n\t}\n\tif prot.ProxyArpWiFi {\n\t\tboolStrings = append(boolStrings, \"ProxyArpWiFi\")\n\t}\n\tif prot.Isolated {\n\t\tboolStrings = append(boolStrings, \"Isolated\")\n\t}\n\tif prot.NeighSuppress {\n\t\tboolStrings = append(boolStrings, \"NeighSuppress\")\n\t}\n\treturn strings.Join(boolStrings, \" \")\n}\n\nfunc boolToByte(x bool) []byte {\n\tif x {\n\t\treturn []byte{1}\n\t}\n\treturn []byte{0}\n}\n\nfunc byteToBool(x byte) bool {\n\treturn uint8(x) != 0\n}\n"
        },
        {
          "name": "protinfo_linux.go",
          "type": "blob",
          "size": 2.1982421875,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc LinkGetProtinfo(link Link) (Protinfo, error) {\n\treturn pkgHandle.LinkGetProtinfo(link)\n}\n\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) LinkGetProtinfo(link Link) (Protinfo, error) {\n\tbase := link.Attrs()\n\th.ensureIndex(base)\n\tvar pi Protinfo\n\treq := h.newNetlinkRequest(unix.RTM_GETLINK, unix.NLM_F_DUMP)\n\tmsg := nl.NewIfInfomsg(unix.AF_BRIDGE)\n\treq.AddData(msg)\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, 0)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn pi, executeErr\n\t}\n\n\tfor _, m := range msgs {\n\t\tans := nl.DeserializeIfInfomsg(m)\n\t\tif int(ans.Index) != base.Index {\n\t\t\tcontinue\n\t\t}\n\t\tattrs, err := nl.ParseRouteAttr(m[ans.Len():])\n\t\tif err != nil {\n\t\t\treturn pi, err\n\t\t}\n\t\tfor _, attr := range attrs {\n\t\t\tif attr.Attr.Type != unix.IFLA_PROTINFO|unix.NLA_F_NESTED {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tinfos, err := nl.ParseRouteAttr(attr.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn pi, err\n\t\t\t}\n\t\t\tpi = parseProtinfo(infos)\n\n\t\t\treturn pi, executeErr\n\t\t}\n\t}\n\treturn pi, fmt.Errorf(\"Device with index %d not found\", base.Index)\n}\n\nfunc parseProtinfo(infos []syscall.NetlinkRouteAttr) (pi Protinfo) {\n\tfor _, info := range infos {\n\t\tswitch info.Attr.Type {\n\t\tcase nl.IFLA_BRPORT_MODE:\n\t\t\tpi.Hairpin = byteToBool(info.Value[0])\n\t\tcase nl.IFLA_BRPORT_GUARD:\n\t\t\tpi.Guard = byteToBool(info.Value[0])\n\t\tcase nl.IFLA_BRPORT_FAST_LEAVE:\n\t\t\tpi.FastLeave = byteToBool(info.Value[0])\n\t\tcase nl.IFLA_BRPORT_PROTECT:\n\t\t\tpi.RootBlock = byteToBool(info.Value[0])\n\t\tcase nl.IFLA_BRPORT_LEARNING:\n\t\t\tpi.Learning = byteToBool(info.Value[0])\n\t\tcase nl.IFLA_BRPORT_UNICAST_FLOOD:\n\t\t\tpi.Flood = byteToBool(info.Value[0])\n\t\tcase nl.IFLA_BRPORT_PROXYARP:\n\t\t\tpi.ProxyArp = byteToBool(info.Value[0])\n\t\tcase nl.IFLA_BRPORT_PROXYARP_WIFI:\n\t\t\tpi.ProxyArpWiFi = byteToBool(info.Value[0])\n\t\tcase nl.IFLA_BRPORT_ISOLATED:\n\t\t\tpi.Isolated = byteToBool(info.Value[0])\n\t\tcase nl.IFLA_BRPORT_NEIGH_SUPPRESS:\n\t\t\tpi.NeighSuppress = byteToBool(info.Value[0])\n\t\t}\n\t}\n\treturn\n}\n"
        },
        {
          "name": "protinfo_test.go",
          "type": "blob",
          "size": 5.47265625,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProtinfo(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tmaster := &Bridge{LinkAttrs: LinkAttrs{Name: \"foo\"}}\n\tif err := LinkAdd(master); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tiface1 := &Dummy{LinkAttrs{Name: \"bar1\", MasterIndex: master.Index}}\n\tiface2 := &Dummy{LinkAttrs{Name: \"bar2\", MasterIndex: master.Index}}\n\tiface3 := &Dummy{LinkAttrs{Name: \"bar3\"}}\n\tiface4 := &Dummy{LinkAttrs{Name: \"bar4\", MasterIndex: master.Index}}\n\n\tif err := LinkAdd(iface1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(iface2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(iface3); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkAdd(iface4); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\toldpi1, err := LinkGetProtinfo(iface1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\toldpi2, err := LinkGetProtinfo(iface2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\toldpi4, err := LinkGetProtinfo(iface4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetHairpin(iface1, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetRootBlock(iface1, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpi1, err := LinkGetProtinfo(iface1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !pi1.Hairpin {\n\t\tt.Fatalf(\"Hairpin mode is not enabled for %s, but should\", iface1.Name)\n\t}\n\tif !pi1.RootBlock {\n\t\tt.Fatalf(\"RootBlock is not enabled for %s, but should\", iface1.Name)\n\t}\n\tif pi1.Isolated {\n\t\tt.Fatalf(\"Isolated mode is enabled for %s, but shouldn't\", iface1.Name)\n\t}\n\tif pi1.ProxyArp != oldpi1.ProxyArp {\n\t\tt.Fatalf(\"ProxyArp field was changed for %s but shouldn't\", iface1.Name)\n\t}\n\tif pi1.ProxyArpWiFi != oldpi1.ProxyArp {\n\t\tt.Fatalf(\"ProxyArpWiFi ProxyArp field was changed for %s but shouldn't\", iface1.Name)\n\t}\n\tif pi1.Guard != oldpi1.Guard {\n\t\tt.Fatalf(\"Guard field was changed for %s but shouldn't\", iface1.Name)\n\t}\n\tif pi1.FastLeave != oldpi1.FastLeave {\n\t\tt.Fatalf(\"FastLeave field was changed for %s but shouldn't\", iface1.Name)\n\t}\n\tif pi1.Learning != oldpi1.Learning {\n\t\tt.Fatalf(\"Learning field was changed for %s but shouldn't\", iface1.Name)\n\t}\n\tif pi1.Flood != oldpi1.Flood {\n\t\tt.Fatalf(\"Flood field was changed for %s but shouldn't\", iface1.Name)\n\t}\n\tif pi1.NeighSuppress != oldpi1.NeighSuppress {\n\t\tt.Fatalf(\"NeighSuppress field was changed for %s but shouldn't\", iface1.Name)\n\t}\n\n\tif err := LinkSetGuard(iface2, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetLearning(iface2, false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpi2, err := LinkGetProtinfo(iface2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif pi2.Hairpin {\n\t\tt.Fatalf(\"Hairpin mode is enabled for %s, but shouldn't\", iface2.Name)\n\t}\n\tif !pi2.Guard {\n\t\tt.Fatalf(\"Guard is not enabled for %s, but should\", iface2.Name)\n\t}\n\tif pi2.ProxyArp != oldpi2.ProxyArp {\n\t\tt.Fatalf(\"ProxyArp field was changed for %s but shouldn't\", iface2.Name)\n\t}\n\tif pi2.ProxyArpWiFi != oldpi2.ProxyArpWiFi {\n\t\tt.Fatalf(\"ProxyArpWiFi field was changed for %s but shouldn't\", iface2.Name)\n\t}\n\tif pi2.Learning {\n\t\tt.Fatalf(\"Learning is enabled for %s, but shouldn't\", iface2.Name)\n\t}\n\tif pi2.RootBlock != oldpi2.RootBlock {\n\t\tt.Fatalf(\"RootBlock field was changed for %s but shouldn't\", iface2.Name)\n\t}\n\tif pi2.FastLeave != oldpi2.FastLeave {\n\t\tt.Fatalf(\"FastLeave field was changed for %s but shouldn't\", iface2.Name)\n\t}\n\tif pi2.Flood != oldpi2.Flood {\n\t\tt.Fatalf(\"Flood field was changed for %s but shouldn't\", iface2.Name)\n\t}\n\tif pi2.NeighSuppress != oldpi2.NeighSuppress {\n\t\tt.Fatalf(\"NeighSuppress field was changed for %s but shouldn't\", iface2.Name)\n\t}\n\n\tif err := LinkSetHairpin(iface3, true); err == nil || err.Error() != \"operation not supported\" {\n\t\tt.Fatalf(\"Set protinfo attrs for link without master is not supported, but err: %s\", err)\n\t}\n\n\t// Setting kernel requirement for next tests which require BR_PROXYARP\n\tminKernelRequired(t, 3, 19)\n\n\tif err := LinkSetBrProxyArp(iface4, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetBrProxyArpWiFi(iface4, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpi4, err := LinkGetProtinfo(iface4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif pi4.Hairpin != oldpi4.Hairpin {\n\t\tt.Fatalf(\"Hairpin field was changed for %s but shouldn't\", iface4.Name)\n\t}\n\tif pi4.Guard != oldpi4.Guard {\n\t\tt.Fatalf(\"Guard field was changed for %s but shouldn't\", iface4.Name)\n\t}\n\tif pi4.Learning != oldpi4.Learning {\n\t\tt.Fatalf(\"Learning field was changed for %s but shouldn't\", iface4.Name)\n\t}\n\tif !pi4.ProxyArp {\n\t\tt.Fatalf(\"ProxyArp is not enabled for %s, but should\", iface4.Name)\n\t}\n\tif !pi4.ProxyArpWiFi {\n\t\tt.Fatalf(\"ProxyArpWiFi is not enabled for %s, but should\", iface4.Name)\n\t}\n\tif pi4.RootBlock != oldpi4.RootBlock {\n\t\tt.Fatalf(\"RootBlock field was changed for %s but shouldn't\", iface4.Name)\n\t}\n\tif pi4.FastLeave != oldpi4.FastLeave {\n\t\tt.Fatalf(\"FastLeave field was changed for %s but shouldn't\", iface4.Name)\n\t}\n\tif pi4.Flood != oldpi4.Flood {\n\t\tt.Fatalf(\"Flood field was changed for %s but shouldn't\", iface4.Name)\n\t}\n\n\t// BR_NEIGH_SUPPRESS added on 4.15\n\tminKernelRequired(t, 4, 15)\n\n\tif err := LinkSetBrNeighSuppress(iface1, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpi1, err = LinkGetProtinfo(iface1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !pi1.NeighSuppress {\n\t\tt.Fatalf(\"NeighSuppress is not enabled for %s but should\", iface1.Name)\n\t}\n\n\t// Setting kernel requirement for next tests which require BRPORT_ISOLATED\n\tminKernelRequired(t, 4, 18)\n\n\tif err := LinkSetIsolated(iface1, true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpi1, err = LinkGetProtinfo(iface1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !pi1.Isolated {\n\t\tt.Fatalf(\"Isolated mode is not enabled for %s, but should\", iface1.Name)\n\t}\n}\n"
        },
        {
          "name": "qdisc.go",
          "type": "blob",
          "size": 8.359375,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nconst (\n\tHANDLE_NONE      = 0\n\tHANDLE_INGRESS   = 0xFFFFFFF1\n\tHANDLE_CLSACT    = HANDLE_INGRESS\n\tHANDLE_ROOT      = 0xFFFFFFFF\n\tPRIORITY_MAP_LEN = 16\n)\nconst (\n\tHANDLE_MIN_INGRESS = 0xFFFFFFF2\n\tHANDLE_MIN_EGRESS  = 0xFFFFFFF3\n)\n\nconst (\n\tHORIZON_DROP_POLICY_CAP     = 0\n\tHORIZON_DROP_POLICY_DROP    = 1\n\tHORIZON_DROP_POLICY_DEFAULT = 255\n)\n\ntype Qdisc interface {\n\tAttrs() *QdiscAttrs\n\tType() string\n}\n\ntype QdiscStatistics ClassStatistics\n\n// QdiscAttrs represents a netlink qdisc. A qdisc is associated with a link,\n// has a handle, a parent and a refcnt. The root qdisc of a device should\n// have parent == HANDLE_ROOT.\ntype QdiscAttrs struct {\n\tLinkIndex    int\n\tHandle       uint32\n\tParent       uint32\n\tRefcnt       uint32 // read only\n\tIngressBlock *uint32\n\tStatistics   *QdiscStatistics\n}\n\nfunc (q QdiscAttrs) String() string {\n\treturn fmt.Sprintf(\"{LinkIndex: %d, Handle: %s, Parent: %s, Refcnt: %d}\", q.LinkIndex, HandleStr(q.Handle), HandleStr(q.Parent), q.Refcnt)\n}\n\nfunc MakeHandle(major, minor uint16) uint32 {\n\treturn (uint32(major) << 16) | uint32(minor)\n}\n\nfunc MajorMinor(handle uint32) (uint16, uint16) {\n\treturn uint16((handle & 0xFFFF0000) >> 16), uint16(handle & 0x0000FFFFF)\n}\n\nfunc HandleStr(handle uint32) string {\n\tswitch handle {\n\tcase HANDLE_NONE:\n\t\treturn \"none\"\n\tcase HANDLE_INGRESS:\n\t\treturn \"ingress\"\n\tcase HANDLE_ROOT:\n\t\treturn \"root\"\n\tdefault:\n\t\tmajor, minor := MajorMinor(handle)\n\t\treturn fmt.Sprintf(\"%x:%x\", major, minor)\n\t}\n}\n\nfunc Percentage2u32(percentage float32) uint32 {\n\t// FIXME this is most likely not the best way to convert from % to uint32\n\tif percentage == 100 {\n\t\treturn math.MaxUint32\n\t}\n\treturn uint32(math.MaxUint32 * (percentage / 100))\n}\n\n// PfifoFast is the default qdisc created by the kernel if one has not\n// been defined for the interface\ntype PfifoFast struct {\n\tQdiscAttrs\n\tBands       uint8\n\tPriorityMap [PRIORITY_MAP_LEN]uint8\n}\n\nfunc (qdisc *PfifoFast) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *PfifoFast) Type() string {\n\treturn \"pfifo_fast\"\n}\n\n// Prio is a basic qdisc that works just like PfifoFast\ntype Prio struct {\n\tQdiscAttrs\n\tBands       uint8\n\tPriorityMap [PRIORITY_MAP_LEN]uint8\n}\n\nfunc NewPrio(attrs QdiscAttrs) *Prio {\n\treturn &Prio{\n\t\tQdiscAttrs:  attrs,\n\t\tBands:       3,\n\t\tPriorityMap: [PRIORITY_MAP_LEN]uint8{1, 2, 2, 2, 1, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1},\n\t}\n}\n\nfunc (qdisc *Prio) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *Prio) Type() string {\n\treturn \"prio\"\n}\n\n// Htb is a classful qdisc that rate limits based on tokens\ntype Htb struct {\n\tQdiscAttrs\n\tVersion      uint32\n\tRate2Quantum uint32\n\tDefcls       uint32\n\tDebug        uint32\n\tDirectPkts   uint32\n\tDirectQlen   *uint32\n}\n\nfunc NewHtb(attrs QdiscAttrs) *Htb {\n\treturn &Htb{\n\t\tQdiscAttrs:   attrs,\n\t\tVersion:      3,\n\t\tDefcls:       0,\n\t\tRate2Quantum: 10,\n\t\tDebug:        0,\n\t\tDirectPkts:   0,\n\t\tDirectQlen:   nil,\n\t}\n}\n\nfunc (qdisc *Htb) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *Htb) Type() string {\n\treturn \"htb\"\n}\n\n// Netem is a classless qdisc that rate limits based on tokens\n\ntype NetemQdiscAttrs struct {\n\tLatency       uint32  // in us\n\tDelayCorr     float32 // in %\n\tLimit         uint32\n\tLoss          float32 // in %\n\tLossCorr      float32 // in %\n\tGap           uint32\n\tDuplicate     float32 // in %\n\tDuplicateCorr float32 // in %\n\tJitter        uint32  // in us\n\tReorderProb   float32 // in %\n\tReorderCorr   float32 // in %\n\tCorruptProb   float32 // in %\n\tCorruptCorr   float32 // in %\n\tRate64        uint64\n}\n\nfunc (q NetemQdiscAttrs) String() string {\n\treturn fmt.Sprintf(\n\t\t\"{Latency: %d, Limit: %d, Loss: %f, Gap: %d, Duplicate: %f, Jitter: %d}\",\n\t\tq.Latency, q.Limit, q.Loss, q.Gap, q.Duplicate, q.Jitter,\n\t)\n}\n\ntype Netem struct {\n\tQdiscAttrs\n\tLatency       uint32\n\tDelayCorr     uint32\n\tLimit         uint32\n\tLoss          uint32\n\tLossCorr      uint32\n\tGap           uint32\n\tDuplicate     uint32\n\tDuplicateCorr uint32\n\tJitter        uint32\n\tReorderProb   uint32\n\tReorderCorr   uint32\n\tCorruptProb   uint32\n\tCorruptCorr   uint32\n\tRate64        uint64\n}\n\nfunc (netem *Netem) String() string {\n\treturn fmt.Sprintf(\n\t\t\"{Latency: %v, Limit: %v, Loss: %v, Gap: %v, Duplicate: %v, Jitter: %v}\",\n\t\tnetem.Latency, netem.Limit, netem.Loss, netem.Gap, netem.Duplicate, netem.Jitter,\n\t)\n}\n\nfunc (qdisc *Netem) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *Netem) Type() string {\n\treturn \"netem\"\n}\n\n// Tbf is a classless qdisc that rate limits based on tokens\ntype Tbf struct {\n\tQdiscAttrs\n\tRate     uint64\n\tLimit    uint32\n\tBuffer   uint32\n\tPeakrate uint64\n\tMinburst uint32\n\t// TODO: handle other settings\n}\n\nfunc (qdisc *Tbf) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *Tbf) Type() string {\n\treturn \"tbf\"\n}\n\n// Clsact is a qdisc for adding filters\ntype Clsact struct {\n\tQdiscAttrs\n}\n\nfunc (qdisc *Clsact) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *Clsact) Type() string {\n\treturn \"clsact\"\n}\n\n// Ingress is a qdisc for adding ingress filters\ntype Ingress struct {\n\tQdiscAttrs\n}\n\nfunc (qdisc *Ingress) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *Ingress) Type() string {\n\treturn \"ingress\"\n}\n\n// GenericQdisc qdiscs represent types that are not currently understood\n// by this netlink library.\ntype GenericQdisc struct {\n\tQdiscAttrs\n\tQdiscType string\n}\n\nfunc (qdisc *GenericQdisc) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *GenericQdisc) Type() string {\n\treturn qdisc.QdiscType\n}\n\ntype Hfsc struct {\n\tQdiscAttrs\n\tDefcls uint16\n}\n\nfunc NewHfsc(attrs QdiscAttrs) *Hfsc {\n\treturn &Hfsc{\n\t\tQdiscAttrs: attrs,\n\t\tDefcls:     1,\n\t}\n}\n\nfunc (hfsc *Hfsc) Attrs() *QdiscAttrs {\n\treturn &hfsc.QdiscAttrs\n}\n\nfunc (hfsc *Hfsc) Type() string {\n\treturn \"hfsc\"\n}\n\nfunc (hfsc *Hfsc) String() string {\n\treturn fmt.Sprintf(\n\t\t\"{%v -- default: %d}\",\n\t\thfsc.Attrs(), hfsc.Defcls,\n\t)\n}\n\n// Fq is a classless packet scheduler meant to be mostly used for locally generated traffic.\ntype Fq struct {\n\tQdiscAttrs\n\tPacketLimit     uint32\n\tFlowPacketLimit uint32\n\t// In bytes\n\tQuantum        uint32\n\tInitialQuantum uint32\n\t// called RateEnable under the hood\n\tPacing          uint32\n\tFlowDefaultRate uint32\n\tFlowMaxRate     uint32\n\t// called BucketsLog under the hood\n\tBuckets           uint32\n\tFlowRefillDelay   uint32\n\tLowRateThreshold  uint32\n\tHorizon           uint32\n\tHorizonDropPolicy uint8\n}\n\nfunc (fq *Fq) String() string {\n\treturn fmt.Sprintf(\n\t\t\"{PacketLimit: %v, FlowPacketLimit: %v, Quantum: %v, InitialQuantum: %v, Pacing: %v, FlowDefaultRate: %v, FlowMaxRate: %v, Buckets: %v, FlowRefillDelay: %v,  LowRateThreshold: %v, Horizon: %v, HorizonDropPolicy: %v}\",\n\t\tfq.PacketLimit, fq.FlowPacketLimit, fq.Quantum, fq.InitialQuantum, fq.Pacing, fq.FlowDefaultRate, fq.FlowMaxRate, fq.Buckets, fq.FlowRefillDelay, fq.LowRateThreshold, fq.Horizon, fq.HorizonDropPolicy,\n\t)\n}\n\nfunc NewFq(attrs QdiscAttrs) *Fq {\n\treturn &Fq{\n\t\tQdiscAttrs:        attrs,\n\t\tPacing:            1,\n\t\tHorizonDropPolicy: HORIZON_DROP_POLICY_DEFAULT,\n\t}\n}\n\nfunc (qdisc *Fq) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *Fq) Type() string {\n\treturn \"fq\"\n}\n\n// FQ_Codel (Fair Queuing Controlled Delay) is queuing discipline that combines Fair Queuing with the CoDel AQM scheme.\ntype FqCodel struct {\n\tQdiscAttrs\n\tTarget        uint32\n\tLimit         uint32\n\tInterval      uint32\n\tECN           uint32\n\tFlows         uint32\n\tQuantum       uint32\n\tCEThreshold   uint32\n\tDropBatchSize uint32\n\tMemoryLimit   uint32\n}\n\nfunc (fqcodel *FqCodel) String() string {\n\treturn fmt.Sprintf(\n\t\t\"{%v -- Target: %v, Limit: %v, Interval: %v, ECM: %v, Flows: %v, Quantum: %v}\",\n\t\tfqcodel.Attrs(), fqcodel.Target, fqcodel.Limit, fqcodel.Interval, fqcodel.ECN, fqcodel.Flows, fqcodel.Quantum,\n\t)\n}\n\nfunc NewFqCodel(attrs QdiscAttrs) *FqCodel {\n\treturn &FqCodel{\n\t\tQdiscAttrs: attrs,\n\t\tECN:        1,\n\t}\n}\n\nfunc (qdisc *FqCodel) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *FqCodel) Type() string {\n\treturn \"fq_codel\"\n}\n\ntype Sfq struct {\n\tQdiscAttrs\n\t// TODO: Only the simplified options for SFQ are handled here. Support for the extended one can be added later.\n\tQuantum uint8\n\tPerturb uint8\n\tLimit   uint32\n\tDivisor uint8\n}\n\nfunc (sfq *Sfq) String() string {\n\treturn fmt.Sprintf(\n\t\t\"{%v -- Quantum: %v, Perturb: %v, Limit: %v, Divisor: %v}\",\n\t\tsfq.Attrs(), sfq.Quantum, sfq.Perturb, sfq.Limit, sfq.Divisor,\n\t)\n}\n\nfunc (qdisc *Sfq) Attrs() *QdiscAttrs {\n\treturn &qdisc.QdiscAttrs\n}\n\nfunc (qdisc *Sfq) Type() string {\n\treturn \"sfq\"\n}\n"
        },
        {
          "name": "qdisc_linux.go",
          "type": "blob",
          "size": 21.1474609375,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// NOTE function is here because it uses other linux functions\nfunc NewNetem(attrs QdiscAttrs, nattrs NetemQdiscAttrs) *Netem {\n\tvar limit uint32 = 1000\n\tvar lossCorr, delayCorr, duplicateCorr uint32\n\tvar reorderProb, reorderCorr uint32\n\tvar corruptProb, corruptCorr uint32\n\tvar rate64 uint64\n\n\tlatency := nattrs.Latency\n\tloss := Percentage2u32(nattrs.Loss)\n\tgap := nattrs.Gap\n\tduplicate := Percentage2u32(nattrs.Duplicate)\n\tjitter := nattrs.Jitter\n\n\t// Correlation\n\tif latency > 0 && jitter > 0 {\n\t\tdelayCorr = Percentage2u32(nattrs.DelayCorr)\n\t}\n\tif loss > 0 {\n\t\tlossCorr = Percentage2u32(nattrs.LossCorr)\n\t}\n\tif duplicate > 0 {\n\t\tduplicateCorr = Percentage2u32(nattrs.DuplicateCorr)\n\t}\n\t// FIXME should validate values(like loss/duplicate are percentages...)\n\tlatency = time2Tick(latency)\n\n\tif nattrs.Limit != 0 {\n\t\tlimit = nattrs.Limit\n\t}\n\t// Jitter is only value if latency is > 0\n\tif latency > 0 {\n\t\tjitter = time2Tick(jitter)\n\t}\n\n\treorderProb = Percentage2u32(nattrs.ReorderProb)\n\treorderCorr = Percentage2u32(nattrs.ReorderCorr)\n\n\tif reorderProb > 0 {\n\t\t// ERROR if lantency == 0\n\t\tif gap == 0 {\n\t\t\tgap = 1\n\t\t}\n\t}\n\n\tcorruptProb = Percentage2u32(nattrs.CorruptProb)\n\tcorruptCorr = Percentage2u32(nattrs.CorruptCorr)\n\trate64 = nattrs.Rate64\n\n\treturn &Netem{\n\t\tQdiscAttrs:    attrs,\n\t\tLatency:       latency,\n\t\tDelayCorr:     delayCorr,\n\t\tLimit:         limit,\n\t\tLoss:          loss,\n\t\tLossCorr:      lossCorr,\n\t\tGap:           gap,\n\t\tDuplicate:     duplicate,\n\t\tDuplicateCorr: duplicateCorr,\n\t\tJitter:        jitter,\n\t\tReorderProb:   reorderProb,\n\t\tReorderCorr:   reorderCorr,\n\t\tCorruptProb:   corruptProb,\n\t\tCorruptCorr:   corruptCorr,\n\t\tRate64:        rate64,\n\t}\n}\n\n// QdiscDel will delete a qdisc from the system.\n// Equivalent to: `tc qdisc del $qdisc`\nfunc QdiscDel(qdisc Qdisc) error {\n\treturn pkgHandle.QdiscDel(qdisc)\n}\n\n// QdiscDel will delete a qdisc from the system.\n// Equivalent to: `tc qdisc del $qdisc`\nfunc (h *Handle) QdiscDel(qdisc Qdisc) error {\n\treturn h.qdiscModify(unix.RTM_DELQDISC, 0, qdisc)\n}\n\n// QdiscChange will change a qdisc in place\n// Equivalent to: `tc qdisc change $qdisc`\n// The parent and handle MUST NOT be changed.\nfunc QdiscChange(qdisc Qdisc) error {\n\treturn pkgHandle.QdiscChange(qdisc)\n}\n\n// QdiscChange will change a qdisc in place\n// Equivalent to: `tc qdisc change $qdisc`\n// The parent and handle MUST NOT be changed.\nfunc (h *Handle) QdiscChange(qdisc Qdisc) error {\n\treturn h.qdiscModify(unix.RTM_NEWQDISC, 0, qdisc)\n}\n\n// QdiscReplace will replace a qdisc to the system.\n// Equivalent to: `tc qdisc replace $qdisc`\n// The handle MUST change.\nfunc QdiscReplace(qdisc Qdisc) error {\n\treturn pkgHandle.QdiscReplace(qdisc)\n}\n\n// QdiscReplace will replace a qdisc to the system.\n// Equivalent to: `tc qdisc replace $qdisc`\n// The handle MUST change.\nfunc (h *Handle) QdiscReplace(qdisc Qdisc) error {\n\treturn h.qdiscModify(\n\t\tunix.RTM_NEWQDISC,\n\t\tunix.NLM_F_CREATE|unix.NLM_F_REPLACE,\n\t\tqdisc)\n}\n\n// QdiscAdd will add a qdisc to the system.\n// Equivalent to: `tc qdisc add $qdisc`\nfunc QdiscAdd(qdisc Qdisc) error {\n\treturn pkgHandle.QdiscAdd(qdisc)\n}\n\n// QdiscAdd will add a qdisc to the system.\n// Equivalent to: `tc qdisc add $qdisc`\nfunc (h *Handle) QdiscAdd(qdisc Qdisc) error {\n\treturn h.qdiscModify(\n\t\tunix.RTM_NEWQDISC,\n\t\tunix.NLM_F_CREATE|unix.NLM_F_EXCL,\n\t\tqdisc)\n}\n\nfunc (h *Handle) qdiscModify(cmd, flags int, qdisc Qdisc) error {\n\treq := h.newNetlinkRequest(cmd, flags|unix.NLM_F_ACK)\n\tbase := qdisc.Attrs()\n\tmsg := &nl.TcMsg{\n\t\tFamily:  nl.FAMILY_ALL,\n\t\tIfindex: int32(base.LinkIndex),\n\t\tHandle:  base.Handle,\n\t\tParent:  base.Parent,\n\t}\n\treq.AddData(msg)\n\n\t// When deleting don't bother building the rest of the netlink payload\n\tif cmd != unix.RTM_DELQDISC {\n\t\tif err := qdiscPayload(req, qdisc); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\nfunc qdiscPayload(req *nl.NetlinkRequest, qdisc Qdisc) error {\n\n\treq.AddData(nl.NewRtAttr(nl.TCA_KIND, nl.ZeroTerminated(qdisc.Type())))\n\tif qdisc.Attrs().IngressBlock != nil {\n\t\treq.AddData(nl.NewRtAttr(nl.TCA_INGRESS_BLOCK, nl.Uint32Attr(*qdisc.Attrs().IngressBlock)))\n\t}\n\n\toptions := nl.NewRtAttr(nl.TCA_OPTIONS, nil)\n\n\tswitch qdisc := qdisc.(type) {\n\tcase *Prio:\n\t\ttcmap := nl.TcPrioMap{\n\t\t\tBands:   int32(qdisc.Bands),\n\t\t\tPriomap: qdisc.PriorityMap,\n\t\t}\n\t\toptions = nl.NewRtAttr(nl.TCA_OPTIONS, tcmap.Serialize())\n\tcase *Tbf:\n\t\topt := nl.TcTbfQopt{}\n\t\topt.Rate.Rate = uint32(qdisc.Rate)\n\t\topt.Peakrate.Rate = uint32(qdisc.Peakrate)\n\t\topt.Limit = qdisc.Limit\n\t\topt.Buffer = qdisc.Buffer\n\t\toptions.AddRtAttr(nl.TCA_TBF_PARMS, opt.Serialize())\n\t\tif qdisc.Rate >= uint64(1<<32) {\n\t\t\toptions.AddRtAttr(nl.TCA_TBF_RATE64, nl.Uint64Attr(qdisc.Rate))\n\t\t}\n\t\tif qdisc.Peakrate >= uint64(1<<32) {\n\t\t\toptions.AddRtAttr(nl.TCA_TBF_PRATE64, nl.Uint64Attr(qdisc.Peakrate))\n\t\t}\n\t\tif qdisc.Peakrate > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_TBF_PBURST, nl.Uint32Attr(qdisc.Minburst))\n\t\t}\n\tcase *Htb:\n\t\topt := nl.TcHtbGlob{}\n\t\topt.Version = qdisc.Version\n\t\topt.Rate2Quantum = qdisc.Rate2Quantum\n\t\topt.Defcls = qdisc.Defcls\n\t\t// TODO: Handle Debug properly. For now default to 0\n\t\topt.Debug = qdisc.Debug\n\t\topt.DirectPkts = qdisc.DirectPkts\n\t\toptions.AddRtAttr(nl.TCA_HTB_INIT, opt.Serialize())\n\t\tif qdisc.DirectQlen != nil {\n\t\t\toptions.AddRtAttr(nl.TCA_HTB_DIRECT_QLEN, nl.Uint32Attr(*qdisc.DirectQlen))\n\t\t}\n\tcase *Hfsc:\n\t\topt := nl.TcHfscOpt{}\n\t\topt.Defcls = qdisc.Defcls\n\t\toptions = nl.NewRtAttr(nl.TCA_OPTIONS, opt.Serialize())\n\tcase *Netem:\n\t\topt := nl.TcNetemQopt{}\n\t\topt.Latency = qdisc.Latency\n\t\topt.Limit = qdisc.Limit\n\t\topt.Loss = qdisc.Loss\n\t\topt.Gap = qdisc.Gap\n\t\topt.Duplicate = qdisc.Duplicate\n\t\topt.Jitter = qdisc.Jitter\n\t\toptions = nl.NewRtAttr(nl.TCA_OPTIONS, opt.Serialize())\n\t\t// Correlation\n\t\tcorr := nl.TcNetemCorr{}\n\t\tcorr.DelayCorr = qdisc.DelayCorr\n\t\tcorr.LossCorr = qdisc.LossCorr\n\t\tcorr.DupCorr = qdisc.DuplicateCorr\n\n\t\tif corr.DelayCorr > 0 || corr.LossCorr > 0 || corr.DupCorr > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_NETEM_CORR, corr.Serialize())\n\t\t}\n\t\t// Corruption\n\t\tcorruption := nl.TcNetemCorrupt{}\n\t\tcorruption.Probability = qdisc.CorruptProb\n\t\tcorruption.Correlation = qdisc.CorruptCorr\n\t\tif corruption.Probability > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_NETEM_CORRUPT, corruption.Serialize())\n\t\t}\n\t\t// Reorder\n\t\treorder := nl.TcNetemReorder{}\n\t\treorder.Probability = qdisc.ReorderProb\n\t\treorder.Correlation = qdisc.ReorderCorr\n\t\tif reorder.Probability > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_NETEM_REORDER, reorder.Serialize())\n\t\t}\n\t\t// Rate\n\t\tif qdisc.Rate64 > 0 {\n\t\t\trate := nl.TcNetemRate{}\n\t\t\tif qdisc.Rate64 >= uint64(1<<32) {\n\t\t\t\toptions.AddRtAttr(nl.TCA_NETEM_RATE64, nl.Uint64Attr(qdisc.Rate64))\n\t\t\t\trate.Rate = ^uint32(0)\n\t\t\t} else {\n\t\t\t\trate.Rate = uint32(qdisc.Rate64)\n\t\t\t}\n\t\t\toptions.AddRtAttr(nl.TCA_NETEM_RATE, rate.Serialize())\n\t\t}\n\tcase *Clsact:\n\t\toptions = nil\n\tcase *Ingress:\n\t\t// ingress filters must use the proper handle\n\t\tif qdisc.Attrs().Parent != HANDLE_INGRESS {\n\t\t\treturn fmt.Errorf(\"Ingress filters must set Parent to HANDLE_INGRESS\")\n\t\t}\n\tcase *FqCodel:\n\t\toptions.AddRtAttr(nl.TCA_FQ_CODEL_ECN, nl.Uint32Attr((uint32(qdisc.ECN))))\n\t\tif qdisc.Limit > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_CODEL_LIMIT, nl.Uint32Attr((uint32(qdisc.Limit))))\n\t\t}\n\t\tif qdisc.Interval > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_CODEL_INTERVAL, nl.Uint32Attr((uint32(qdisc.Interval))))\n\t\t}\n\t\tif qdisc.Flows > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_CODEL_FLOWS, nl.Uint32Attr((uint32(qdisc.Flows))))\n\t\t}\n\t\tif qdisc.Quantum > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_CODEL_QUANTUM, nl.Uint32Attr((uint32(qdisc.Quantum))))\n\t\t}\n\t\tif qdisc.CEThreshold > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_CODEL_CE_THRESHOLD, nl.Uint32Attr(qdisc.CEThreshold))\n\t\t}\n\t\tif qdisc.DropBatchSize > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_CODEL_DROP_BATCH_SIZE, nl.Uint32Attr(qdisc.DropBatchSize))\n\t\t}\n\t\tif qdisc.MemoryLimit > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_CODEL_MEMORY_LIMIT, nl.Uint32Attr(qdisc.MemoryLimit))\n\t\t}\n\tcase *Fq:\n\t\toptions.AddRtAttr(nl.TCA_FQ_RATE_ENABLE, nl.Uint32Attr((uint32(qdisc.Pacing))))\n\n\t\tif qdisc.Buckets > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_BUCKETS_LOG, nl.Uint32Attr((uint32(qdisc.Buckets))))\n\t\t}\n\t\tif qdisc.PacketLimit > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_PLIMIT, nl.Uint32Attr((uint32(qdisc.PacketLimit))))\n\t\t}\n\t\tif qdisc.LowRateThreshold > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_LOW_RATE_THRESHOLD, nl.Uint32Attr((uint32(qdisc.LowRateThreshold))))\n\t\t}\n\t\tif qdisc.Quantum > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_QUANTUM, nl.Uint32Attr((uint32(qdisc.Quantum))))\n\t\t}\n\t\tif qdisc.InitialQuantum > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_INITIAL_QUANTUM, nl.Uint32Attr((uint32(qdisc.InitialQuantum))))\n\t\t}\n\t\tif qdisc.FlowRefillDelay > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_FLOW_REFILL_DELAY, nl.Uint32Attr((uint32(qdisc.FlowRefillDelay))))\n\t\t}\n\t\tif qdisc.FlowPacketLimit > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_FLOW_PLIMIT, nl.Uint32Attr((uint32(qdisc.FlowPacketLimit))))\n\t\t}\n\t\tif qdisc.FlowMaxRate > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_FLOW_MAX_RATE, nl.Uint32Attr((uint32(qdisc.FlowMaxRate))))\n\t\t}\n\t\tif qdisc.FlowDefaultRate > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_FLOW_DEFAULT_RATE, nl.Uint32Attr((uint32(qdisc.FlowDefaultRate))))\n\t\t}\n\t\tif qdisc.Horizon > 0 {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_HORIZON, nl.Uint32Attr(qdisc.Horizon))\n\t\t}\n\t\tif qdisc.HorizonDropPolicy != HORIZON_DROP_POLICY_DEFAULT {\n\t\t\toptions.AddRtAttr(nl.TCA_FQ_HORIZON_DROP, nl.Uint8Attr(qdisc.HorizonDropPolicy))\n\t\t}\n\tcase *Sfq:\n\t\topt := nl.TcSfqQoptV1{}\n\t\topt.TcSfqQopt.Quantum = qdisc.Quantum\n\t\topt.TcSfqQopt.Perturb = int32(qdisc.Perturb)\n\t\topt.TcSfqQopt.Limit = qdisc.Limit\n\t\topt.TcSfqQopt.Divisor = qdisc.Divisor\n\n\t\toptions = nl.NewRtAttr(nl.TCA_OPTIONS, opt.Serialize())\n\tdefault:\n\t\toptions = nil\n\t}\n\n\tif options != nil {\n\t\treq.AddData(options)\n\t}\n\treturn nil\n}\n\n// QdiscList gets a list of qdiscs in the system.\n// Equivalent to: `tc qdisc show`.\n// The list can be filtered by link.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc QdiscList(link Link) ([]Qdisc, error) {\n\treturn pkgHandle.QdiscList(link)\n}\n\n// QdiscList gets a list of qdiscs in the system.\n// Equivalent to: `tc qdisc show`.\n// The list can be filtered by link.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) QdiscList(link Link) ([]Qdisc, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETQDISC, unix.NLM_F_DUMP)\n\tindex := int32(0)\n\tif link != nil {\n\t\tbase := link.Attrs()\n\t\th.ensureIndex(base)\n\t\tindex = int32(base.Index)\n\t}\n\tmsg := &nl.TcMsg{\n\t\tFamily:  nl.FAMILY_ALL,\n\t\tIfindex: index,\n\t}\n\treq.AddData(msg)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWQDISC)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res []Qdisc\n\tfor _, m := range msgs {\n\t\tmsg := nl.DeserializeTcMsg(m)\n\n\t\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// skip qdiscs from other interfaces\n\t\tif link != nil && msg.Ifindex != index {\n\t\t\tcontinue\n\t\t}\n\n\t\tbase := QdiscAttrs{\n\t\t\tLinkIndex: int(msg.Ifindex),\n\t\t\tHandle:    msg.Handle,\n\t\t\tParent:    msg.Parent,\n\t\t\tRefcnt:    msg.Info,\n\t\t}\n\t\tvar qdisc Qdisc\n\t\tqdiscType := \"\"\n\t\tfor _, attr := range attrs {\n\t\t\tswitch attr.Attr.Type {\n\t\t\tcase nl.TCA_KIND:\n\t\t\t\tqdiscType = string(attr.Value[:len(attr.Value)-1])\n\t\t\t\tswitch qdiscType {\n\t\t\t\tcase \"pfifo_fast\":\n\t\t\t\t\tqdisc = &PfifoFast{}\n\t\t\t\tcase \"prio\":\n\t\t\t\t\tqdisc = &Prio{}\n\t\t\t\tcase \"tbf\":\n\t\t\t\t\tqdisc = &Tbf{}\n\t\t\t\tcase \"ingress\":\n\t\t\t\t\tqdisc = &Ingress{}\n\t\t\t\tcase \"htb\":\n\t\t\t\t\tqdisc = &Htb{}\n\t\t\t\tcase \"fq\":\n\t\t\t\t\tqdisc = &Fq{}\n\t\t\t\tcase \"hfsc\":\n\t\t\t\t\tqdisc = &Hfsc{}\n\t\t\t\tcase \"fq_codel\":\n\t\t\t\t\tqdisc = &FqCodel{}\n\t\t\t\tcase \"netem\":\n\t\t\t\t\tqdisc = &Netem{}\n\t\t\t\tcase \"sfq\":\n\t\t\t\t\tqdisc = &Sfq{}\n\t\t\t\tcase \"clsact\":\n\t\t\t\t\tqdisc = &Clsact{}\n\t\t\t\tdefault:\n\t\t\t\t\tqdisc = &GenericQdisc{QdiscType: qdiscType}\n\t\t\t\t}\n\t\t\tcase nl.TCA_OPTIONS:\n\t\t\t\tswitch qdiscType {\n\t\t\t\tcase \"pfifo_fast\":\n\t\t\t\t\t// pfifo returns TcPrioMap directly without wrapping it in rtattr\n\t\t\t\t\tif err := parsePfifoFastData(qdisc, attr.Value); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"prio\":\n\t\t\t\t\t// prio returns TcPrioMap directly without wrapping it in rtattr\n\t\t\t\t\tif err := parsePrioData(qdisc, attr.Value); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"tbf\":\n\t\t\t\t\tdata, err := nl.ParseRouteAttr(attr.Value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tif err := parseTbfData(qdisc, data); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"hfsc\":\n\t\t\t\t\tif err := parseHfscData(qdisc, attr.Value); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"htb\":\n\t\t\t\t\tdata, err := nl.ParseRouteAttr(attr.Value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tif err := parseHtbData(qdisc, data); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"fq\":\n\t\t\t\t\tdata, err := nl.ParseRouteAttr(attr.Value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tif err := parseFqData(qdisc, data); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"fq_codel\":\n\t\t\t\t\tdata, err := nl.ParseRouteAttr(attr.Value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tif err := parseFqCodelData(qdisc, data); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"netem\":\n\t\t\t\t\tif err := parseNetemData(qdisc, attr.Value); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\tcase \"sfq\":\n\t\t\t\t\tif err := parseSfqData(qdisc, attr.Value); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\t// no options for ingress\n\t\t\t\t}\n\t\t\tcase nl.TCA_INGRESS_BLOCK:\n\t\t\t\tingressBlock := new(uint32)\n\t\t\t\t*ingressBlock = native.Uint32(attr.Value)\n\t\t\t\tbase.IngressBlock = ingressBlock\n\t\t\tcase nl.TCA_STATS:\n\t\t\t\ts, err := parseTcStats(attr.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tbase.Statistics = (*QdiscStatistics)(s)\n\t\t\tcase nl.TCA_STATS2:\n\t\t\t\ts, err := parseTcStats2(attr.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tbase.Statistics = (*QdiscStatistics)(s)\n\t\t\t}\n\t\t}\n\t\t*qdisc.Attrs() = base\n\t\tres = append(res, qdisc)\n\t}\n\n\treturn res, executeErr\n}\n\nfunc parsePfifoFastData(qdisc Qdisc, value []byte) error {\n\tpfifo := qdisc.(*PfifoFast)\n\ttcmap := nl.DeserializeTcPrioMap(value)\n\tpfifo.PriorityMap = tcmap.Priomap\n\tpfifo.Bands = uint8(tcmap.Bands)\n\treturn nil\n}\n\nfunc parsePrioData(qdisc Qdisc, value []byte) error {\n\tprio := qdisc.(*Prio)\n\ttcmap := nl.DeserializeTcPrioMap(value)\n\tprio.PriorityMap = tcmap.Priomap\n\tprio.Bands = uint8(tcmap.Bands)\n\treturn nil\n}\n\nfunc parseHtbData(qdisc Qdisc, data []syscall.NetlinkRouteAttr) error {\n\thtb := qdisc.(*Htb)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_HTB_INIT:\n\t\t\topt := nl.DeserializeTcHtbGlob(datum.Value)\n\t\t\thtb.Version = opt.Version\n\t\t\thtb.Rate2Quantum = opt.Rate2Quantum\n\t\t\thtb.Defcls = opt.Defcls\n\t\t\thtb.Debug = opt.Debug\n\t\t\thtb.DirectPkts = opt.DirectPkts\n\t\tcase nl.TCA_HTB_DIRECT_QLEN:\n\t\t\tdirectQlen := native.Uint32(datum.Value)\n\t\t\thtb.DirectQlen = &directQlen\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parseFqCodelData(qdisc Qdisc, data []syscall.NetlinkRouteAttr) error {\n\tfqCodel := qdisc.(*FqCodel)\n\tfor _, datum := range data {\n\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_FQ_CODEL_TARGET:\n\t\t\tfqCodel.Target = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_CODEL_LIMIT:\n\t\t\tfqCodel.Limit = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_CODEL_INTERVAL:\n\t\t\tfqCodel.Interval = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_CODEL_ECN:\n\t\t\tfqCodel.ECN = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_CODEL_FLOWS:\n\t\t\tfqCodel.Flows = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_CODEL_QUANTUM:\n\t\t\tfqCodel.Quantum = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_CODEL_CE_THRESHOLD:\n\t\t\tfqCodel.CEThreshold = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_CODEL_DROP_BATCH_SIZE:\n\t\t\tfqCodel.DropBatchSize = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_CODEL_MEMORY_LIMIT:\n\t\t\tfqCodel.MemoryLimit = native.Uint32(datum.Value)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parseHfscData(qdisc Qdisc, data []byte) error {\n\tHfsc := qdisc.(*Hfsc)\n\tHfsc.Defcls = native.Uint16(data)\n\treturn nil\n}\n\nfunc parseFqData(qdisc Qdisc, data []syscall.NetlinkRouteAttr) error {\n\tfq := qdisc.(*Fq)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_FQ_BUCKETS_LOG:\n\t\t\tfq.Buckets = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_LOW_RATE_THRESHOLD:\n\t\t\tfq.LowRateThreshold = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_QUANTUM:\n\t\t\tfq.Quantum = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_RATE_ENABLE:\n\t\t\tfq.Pacing = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_INITIAL_QUANTUM:\n\t\t\tfq.InitialQuantum = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_ORPHAN_MASK:\n\t\t\t// TODO\n\t\tcase nl.TCA_FQ_FLOW_REFILL_DELAY:\n\t\t\tfq.FlowRefillDelay = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_FLOW_PLIMIT:\n\t\t\tfq.FlowPacketLimit = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_PLIMIT:\n\t\t\tfq.PacketLimit = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_FLOW_MAX_RATE:\n\t\t\tfq.FlowMaxRate = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_FLOW_DEFAULT_RATE:\n\t\t\tfq.FlowDefaultRate = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_HORIZON:\n\t\t\tfq.Horizon = native.Uint32(datum.Value)\n\t\tcase nl.TCA_FQ_HORIZON_DROP:\n\t\t\tfq.HorizonDropPolicy = datum.Value[0]\n\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parseNetemData(qdisc Qdisc, value []byte) error {\n\tnetem := qdisc.(*Netem)\n\topt := nl.DeserializeTcNetemQopt(value)\n\tnetem.Latency = opt.Latency\n\tnetem.Limit = opt.Limit\n\tnetem.Loss = opt.Loss\n\tnetem.Gap = opt.Gap\n\tnetem.Duplicate = opt.Duplicate\n\tnetem.Jitter = opt.Jitter\n\tdata, err := nl.ParseRouteAttr(value[nl.SizeofTcNetemQopt:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar rate *nl.TcNetemRate\n\tvar rate64 uint64\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_NETEM_CORR:\n\t\t\topt := nl.DeserializeTcNetemCorr(datum.Value)\n\t\t\tnetem.DelayCorr = opt.DelayCorr\n\t\t\tnetem.LossCorr = opt.LossCorr\n\t\t\tnetem.DuplicateCorr = opt.DupCorr\n\t\tcase nl.TCA_NETEM_CORRUPT:\n\t\t\topt := nl.DeserializeTcNetemCorrupt(datum.Value)\n\t\t\tnetem.CorruptProb = opt.Probability\n\t\t\tnetem.CorruptCorr = opt.Correlation\n\t\tcase nl.TCA_NETEM_REORDER:\n\t\t\topt := nl.DeserializeTcNetemReorder(datum.Value)\n\t\t\tnetem.ReorderProb = opt.Probability\n\t\t\tnetem.ReorderCorr = opt.Correlation\n\t\tcase nl.TCA_NETEM_RATE:\n\t\t\trate = nl.DeserializeTcNetemRate(datum.Value)\n\t\tcase nl.TCA_NETEM_RATE64:\n\t\t\trate64 = native.Uint64(datum.Value)\n\t\t}\n\t}\n\tif rate != nil {\n\t\tnetem.Rate64 = uint64(rate.Rate)\n\t\tif rate64 > 0 {\n\t\t\tnetem.Rate64 = rate64\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc parseTbfData(qdisc Qdisc, data []syscall.NetlinkRouteAttr) error {\n\ttbf := qdisc.(*Tbf)\n\tfor _, datum := range data {\n\t\tswitch datum.Attr.Type {\n\t\tcase nl.TCA_TBF_PARMS:\n\t\t\topt := nl.DeserializeTcTbfQopt(datum.Value)\n\t\t\ttbf.Rate = uint64(opt.Rate.Rate)\n\t\t\ttbf.Peakrate = uint64(opt.Peakrate.Rate)\n\t\t\ttbf.Limit = opt.Limit\n\t\t\ttbf.Buffer = opt.Buffer\n\t\tcase nl.TCA_TBF_RATE64:\n\t\t\ttbf.Rate = native.Uint64(datum.Value[0:8])\n\t\tcase nl.TCA_TBF_PRATE64:\n\t\t\ttbf.Peakrate = native.Uint64(datum.Value[0:8])\n\t\tcase nl.TCA_TBF_PBURST:\n\t\t\ttbf.Minburst = native.Uint32(datum.Value[0:4])\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parseSfqData(qdisc Qdisc, value []byte) error {\n\tsfq := qdisc.(*Sfq)\n\topt := nl.DeserializeTcSfqQoptV1(value)\n\tsfq.Quantum = opt.TcSfqQopt.Quantum\n\tsfq.Perturb = uint8(opt.TcSfqQopt.Perturb)\n\tsfq.Limit = opt.TcSfqQopt.Limit\n\tsfq.Divisor = opt.TcSfqQopt.Divisor\n\n\treturn nil\n}\n\nconst (\n\tTIME_UNITS_PER_SEC = 1000000\n)\n\nvar (\n\ttickInUsec  float64\n\tclockFactor float64\n\thz          float64\n\n\t// Without this, the go race detector may report races.\n\tinitClockMutex sync.Mutex\n)\n\nfunc initClock() {\n\tdata, err := ioutil.ReadFile(\"/proc/net/psched\")\n\tif err != nil {\n\t\treturn\n\t}\n\tparts := strings.Split(strings.TrimSpace(string(data)), \" \")\n\tif len(parts) < 4 {\n\t\treturn\n\t}\n\tvar vals [4]uint64\n\tfor i := range vals {\n\t\tval, err := strconv.ParseUint(parts[i], 16, 32)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tvals[i] = val\n\t}\n\t// compatibility\n\tif vals[2] == 1000000000 {\n\t\tvals[0] = vals[1]\n\t}\n\tclockFactor = float64(vals[2]) / TIME_UNITS_PER_SEC\n\ttickInUsec = float64(vals[0]) / float64(vals[1]) * clockFactor\n\tif vals[2] == 1000000 {\n\t\t// ref https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/tree/lib/utils.c#n963\n\t\thz = float64(vals[3])\n\t} else {\n\t\thz = 100\n\t}\n}\n\nfunc TickInUsec() float64 {\n\tinitClockMutex.Lock()\n\tdefer initClockMutex.Unlock()\n\tif tickInUsec == 0.0 {\n\t\tinitClock()\n\t}\n\treturn tickInUsec\n}\n\nfunc ClockFactor() float64 {\n\tinitClockMutex.Lock()\n\tdefer initClockMutex.Unlock()\n\tif clockFactor == 0.0 {\n\t\tinitClock()\n\t}\n\treturn clockFactor\n}\n\nfunc Hz() float64 {\n\tinitClockMutex.Lock()\n\tdefer initClockMutex.Unlock()\n\tif hz == 0.0 {\n\t\tinitClock()\n\t}\n\treturn hz\n}\n\nfunc time2Tick(time uint32) uint32 {\n\treturn uint32(float64(time) * TickInUsec())\n}\n\nfunc tick2Time(tick uint32) uint32 {\n\treturn uint32(float64(tick) / TickInUsec())\n}\n\nfunc time2Ktime(time uint32) uint32 {\n\treturn uint32(float64(time) * ClockFactor())\n}\n\nfunc ktime2Time(ktime uint32) uint32 {\n\treturn uint32(float64(ktime) / ClockFactor())\n}\n\nfunc burst(rate uint64, buffer uint32) uint32 {\n\treturn uint32(float64(rate) * float64(tick2Time(buffer)) / TIME_UNITS_PER_SEC)\n}\n\nfunc latency(rate uint64, limit, buffer uint32) float64 {\n\treturn TIME_UNITS_PER_SEC*(float64(limit)/float64(rate)) - float64(tick2Time(buffer))\n}\n\nfunc Xmittime(rate uint64, size uint32) uint32 {\n\t// https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/tree/tc/tc_core.c#n62\n\treturn time2Tick(uint32(TIME_UNITS_PER_SEC * (float64(size) / float64(rate))))\n}\n\nfunc Xmitsize(rate uint64, ticks uint32) uint32 {\n\treturn uint32((float64(rate) * float64(tick2Time(ticks))) / TIME_UNITS_PER_SEC)\n}\n"
        },
        {
          "name": "qdisc_test.go",
          "type": "blob",
          "size": 12.6240234375,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTbfAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Tbf{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(1, 0),\n\t\t\tParent:    HANDLE_ROOT,\n\t\t},\n\t\tRate:   131072,\n\t\tLimit:  1220703,\n\t\tBuffer: 16793,\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\ttbf, ok := qdiscs[0].(*Tbf)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif tbf.Rate != qdisc.Rate {\n\t\tt.Fatal(\"Rate doesn't match\")\n\t}\n\tif tbf.Limit != qdisc.Limit {\n\t\tt.Fatal(\"Limit doesn't match\")\n\t}\n\tif tbf.Buffer != qdisc.Buffer {\n\t\tt.Fatal(\"Buffer doesn't match\")\n\t}\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestHtbAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tattrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(1, 0),\n\t\tParent:    HANDLE_ROOT,\n\t}\n\n\tqdisc := NewHtb(attrs)\n\tqdisc.Rate2Quantum = 5\n\tdirectQlen := uint32(10)\n\tqdisc.DirectQlen = &directQlen\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\thtb, ok := qdiscs[0].(*Htb)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif htb.Defcls != qdisc.Defcls {\n\t\tt.Fatal(\"Defcls doesn't match\")\n\t}\n\tif htb.Rate2Quantum != qdisc.Rate2Quantum {\n\t\tt.Fatal(\"Rate2Quantum doesn't match\")\n\t}\n\tif htb.Debug != qdisc.Debug {\n\t\tt.Fatal(\"Debug doesn't match\")\n\t}\n\tif htb.DirectQlen == nil || *htb.DirectQlen != directQlen {\n\t\tt.Fatalf(\"DirectQlen doesn't match. Expected %d, got %v\", directQlen, htb.DirectQlen)\n\t}\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestSfqAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTestWithKModule(t, \"sch_sfq\")\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tattrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(1, 0),\n\t\tParent:    HANDLE_ROOT,\n\t}\n\n\tqdisc := Sfq{\n\t\tQdiscAttrs: attrs,\n\t\tQuantum:    2,\n\t\tPerturb:    11,\n\t\tLimit:      123,\n\t\tDivisor:    4,\n\t}\n\tif err := QdiscAdd(&qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\tsfq, ok := qdiscs[0].(*Sfq)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif sfq.Quantum != qdisc.Quantum {\n\t\tt.Fatal(\"Quantum doesn't match\")\n\t}\n\tif sfq.Perturb != qdisc.Perturb {\n\t\tt.Fatal(\"Perturb doesn't match\")\n\t}\n\tif sfq.Limit != qdisc.Limit {\n\t\tt.Fatal(\"Limit doesn't match\")\n\t}\n\tif sfq.Divisor != qdisc.Divisor {\n\t\tt.Fatal(\"Divisor doesn't match\")\n\t}\n\tif err := QdiscDel(&qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestPrioAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := NewPrio(QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(1, 0),\n\t\tParent:    HANDLE_ROOT,\n\t})\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\t_, ok := qdiscs[0].(*Prio)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestTbfAddHtbReplaceDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Add\n\tattrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(1, 0),\n\t\tParent:    HANDLE_ROOT,\n\t}\n\tqdisc := &Tbf{\n\t\tQdiscAttrs: attrs,\n\t\tRate:       131072,\n\t\tLimit:      1220703,\n\t\tBuffer:     16793,\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\ttbf, ok := qdiscs[0].(*Tbf)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif tbf.Rate != qdisc.Rate {\n\t\tt.Fatal(\"Rate doesn't match\")\n\t}\n\tif tbf.Limit != qdisc.Limit {\n\t\tt.Fatal(\"Limit doesn't match\")\n\t}\n\tif tbf.Buffer != qdisc.Buffer {\n\t\tt.Fatal(\"Buffer doesn't match\")\n\t}\n\t// Replace\n\t// For replace to work, the handle MUST be different that the running one\n\tattrs.Handle = MakeHandle(2, 0)\n\tqdisc2 := NewHtb(attrs)\n\tqdisc2.Rate2Quantum = 5\n\tif err := QdiscReplace(qdisc2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\thtb, ok := qdiscs[0].(*Htb)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif htb.Defcls != qdisc2.Defcls {\n\t\tt.Fatal(\"Defcls doesn't match\")\n\t}\n\tif htb.Rate2Quantum != qdisc2.Rate2Quantum {\n\t\tt.Fatal(\"Rate2Quantum doesn't match\")\n\t}\n\tif htb.Debug != qdisc2.Debug {\n\t\tt.Fatal(\"Debug doesn't match\")\n\t}\n\n\tif err := QdiscDel(qdisc2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestTbfAddTbfChangeDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Add\n\tattrs := QdiscAttrs{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tHandle:    MakeHandle(1, 0),\n\t\tParent:    HANDLE_ROOT,\n\t}\n\tqdisc := &Tbf{\n\t\tQdiscAttrs: attrs,\n\t\tRate:       131072,\n\t\tLimit:      1220703,\n\t\tBuffer:     16793,\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\ttbf, ok := qdiscs[0].(*Tbf)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif tbf.Rate != qdisc.Rate {\n\t\tt.Fatal(\"Rate doesn't match\")\n\t}\n\tif tbf.Limit != qdisc.Limit {\n\t\tt.Fatal(\"Limit doesn't match\")\n\t}\n\tif tbf.Buffer != qdisc.Buffer {\n\t\tt.Fatal(\"Buffer doesn't match\")\n\t}\n\t// Change\n\t// For change to work, the handle MUST not change\n\tqdisc.Rate = 23456\n\tif err := QdiscChange(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\ttbf, ok = qdiscs[0].(*Tbf)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif tbf.Rate != qdisc.Rate {\n\t\tt.Fatal(\"Rate doesn't match\")\n\t}\n\tif tbf.Limit != qdisc.Limit {\n\t\tt.Fatal(\"Limit doesn't match\")\n\t}\n\tif tbf.Buffer != qdisc.Buffer {\n\t\tt.Fatal(\"Buffer doesn't match\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFqAddChangeDel(t *testing.T) {\n\tminKernelRequired(t, 3, 11)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Fq{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(1, 0),\n\t\t\tParent:    HANDLE_ROOT,\n\t\t},\n\t\tFlowPacketLimit: 123,\n\t\tPacing:          0,\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\tfq, ok := qdiscs[0].(*Fq)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif fq.FlowPacketLimit != qdisc.FlowPacketLimit {\n\t\tt.Fatal(\"Flow Packet Limit does not match\")\n\t}\n\tif fq.Pacing != qdisc.Pacing {\n\t\tt.Fatal(\"Pacing does not match\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFqHorizon(t *testing.T) {\n\tminKernelRequired(t, 5, 7)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &Fq{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(1, 0),\n\t\t\tParent:    HANDLE_ROOT,\n\t\t},\n\t\tHorizon:           1000,\n\t\tHorizonDropPolicy: HORIZON_DROP_POLICY_CAP,\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\tfq, ok := qdiscs[0].(*Fq)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif fq.Horizon != qdisc.Horizon {\n\t\tt.Fatal(\"Horizon does not match\")\n\t}\n\tif fq.HorizonDropPolicy != qdisc.HorizonDropPolicy {\n\t\tt.Fatal(\"HorizonDropPolicy does not match\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestFqCodelAddChangeDel(t *testing.T) {\n\tminKernelRequired(t, 3, 4)\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdisc := &FqCodel{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tHandle:    MakeHandle(1, 0),\n\t\t\tParent:    HANDLE_ROOT,\n\t\t},\n\t\tECN:     1,\n\t\tQuantum: 9000,\n\t}\n\tif err := QdiscAdd(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\tfqcodel, ok := qdiscs[0].(*FqCodel)\n\tif !ok {\n\t\tt.Fatal(\"Qdisc is the wrong type\")\n\t}\n\tif fqcodel.Quantum != qdisc.Quantum {\n\t\tt.Fatal(\"Quantum does not match\")\n\t}\n\n\tif err := QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n\nfunc TestIngressAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := LinkAdd(&Ifb{LinkAttrs{Name: \"foo\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tingressBlock := new(uint32)\n\t*ingressBlock = 8\n\tqdisc := &Ingress{\n\t\tQdiscAttrs: QdiscAttrs{\n\t\t\tLinkIndex:    link.Attrs().Index,\n\t\t\tParent:       HANDLE_INGRESS,\n\t\t\tIngressBlock: ingressBlock,\n\t\t},\n\t}\n\terr = QdiscAdd(qdisc)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\tqdiscs, err := SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to list qdisc\")\n\t}\n\tif len(qdiscs) != 1 {\n\t\tt.Fatal(\"Failed to add qdisc\")\n\t}\n\tif *qdiscs[0].Attrs().IngressBlock != *ingressBlock {\n\t\tt.Fatal(\"IngressBlock does not match\")\n\t}\n\tif qdiscs[0].Attrs().Statistics == nil {\n\t\tt.Fatal(\"Statistics is nil\")\n\t}\n\tif qdiscs[0].Attrs().Statistics.Basic.Bytes != 0 || qdiscs[0].Attrs().Statistics.Basic.Packets != 0 {\n\t\tt.Fatal(\"Statistics is not zero\")\n\t}\n\tif err = QdiscDel(qdisc); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tqdiscs, err = SafeQdiscList(link)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(qdiscs) != 0 {\n\t\tt.Fatal(\"Failed to remove qdisc\")\n\t}\n}\n"
        },
        {
          "name": "rdma_link_linux.go",
          "type": "blob",
          "size": 10.0146484375,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// LinkAttrs represents data shared by most link types\ntype RdmaLinkAttrs struct {\n\tIndex           uint32\n\tName            string\n\tFirmwareVersion string\n\tNodeGuid        string\n\tSysImageGuid    string\n}\n\n// Link represents a rdma device from netlink.\ntype RdmaLink struct {\n\tAttrs RdmaLinkAttrs\n}\n\nfunc getProtoField(clientType int, op int) int {\n\treturn ((clientType << nl.RDMA_NL_GET_CLIENT_SHIFT) | op)\n}\n\nfunc uint64ToGuidString(guid uint64) string {\n\t//Convert to byte array\n\tsysGuidBytes := new(bytes.Buffer)\n\tbinary.Write(sysGuidBytes, binary.LittleEndian, guid)\n\n\t//Convert to HardwareAddr\n\tsysGuidNet := net.HardwareAddr(sysGuidBytes.Bytes())\n\n\t//Get the String\n\treturn sysGuidNet.String()\n}\n\nfunc executeOneGetRdmaLink(data []byte) (*RdmaLink, error) {\n\n\tlink := RdmaLink{}\n\n\treader := bytes.NewReader(data)\n\tfor reader.Len() >= 4 {\n\t\t_, attrType, len, value := parseNfAttrTLV(reader)\n\n\t\tswitch attrType {\n\t\tcase nl.RDMA_NLDEV_ATTR_DEV_INDEX:\n\t\t\tvar Index uint32\n\t\t\tr := bytes.NewReader(value)\n\t\t\tbinary.Read(r, nl.NativeEndian(), &Index)\n\t\t\tlink.Attrs.Index = Index\n\t\tcase nl.RDMA_NLDEV_ATTR_DEV_NAME:\n\t\t\tlink.Attrs.Name = string(value[0 : len-1])\n\t\tcase nl.RDMA_NLDEV_ATTR_FW_VERSION:\n\t\t\tlink.Attrs.FirmwareVersion = string(value[0 : len-1])\n\t\tcase nl.RDMA_NLDEV_ATTR_NODE_GUID:\n\t\t\tvar guid uint64\n\t\t\tr := bytes.NewReader(value)\n\t\t\tbinary.Read(r, nl.NativeEndian(), &guid)\n\t\t\tlink.Attrs.NodeGuid = uint64ToGuidString(guid)\n\t\tcase nl.RDMA_NLDEV_ATTR_SYS_IMAGE_GUID:\n\t\t\tvar sysGuid uint64\n\t\t\tr := bytes.NewReader(value)\n\t\t\tbinary.Read(r, nl.NativeEndian(), &sysGuid)\n\t\t\tlink.Attrs.SysImageGuid = uint64ToGuidString(sysGuid)\n\t\t}\n\t\tif (len % 4) != 0 {\n\t\t\t// Skip pad bytes\n\t\t\treader.Seek(int64(4-(len%4)), seekCurrent)\n\t\t}\n\t}\n\treturn &link, nil\n}\n\nfunc execRdmaSetLink(req *nl.NetlinkRequest) error {\n\n\t_, err := req.Execute(unix.NETLINK_RDMA, 0)\n\treturn err\n}\n\n// RdmaLinkList gets a list of RDMA link devices.\n// Equivalent to: `rdma dev show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc RdmaLinkList() ([]*RdmaLink, error) {\n\treturn pkgHandle.RdmaLinkList()\n}\n\n// RdmaLinkList gets a list of RDMA link devices.\n// Equivalent to: `rdma dev show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) RdmaLinkList() ([]*RdmaLink, error) {\n\tproto := getProtoField(nl.RDMA_NL_NLDEV, nl.RDMA_NLDEV_CMD_GET)\n\treq := h.newNetlinkRequest(proto, unix.NLM_F_ACK|unix.NLM_F_DUMP)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_RDMA, 0)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res []*RdmaLink\n\tfor _, m := range msgs {\n\t\tlink, err := executeOneGetRdmaLink(m)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres = append(res, link)\n\t}\n\n\treturn res, executeErr\n}\n\n// RdmaLinkByName finds a link by name and returns a pointer to the object if\n// found and nil error, otherwise returns error code.\n//\n// If the returned error is [ErrDumpInterrupted], the result may be missing or\n// outdated and the caller should retry.\nfunc RdmaLinkByName(name string) (*RdmaLink, error) {\n\treturn pkgHandle.RdmaLinkByName(name)\n}\n\n// RdmaLinkByName finds a link by name and returns a pointer to the object if\n// found and nil error, otherwise returns error code.\n//\n// If the returned error is [ErrDumpInterrupted], the result may be missing or\n// outdated and the caller should retry.\nfunc (h *Handle) RdmaLinkByName(name string) (*RdmaLink, error) {\n\tlinks, err := h.RdmaLinkList()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, link := range links {\n\t\tif link.Attrs.Name == name {\n\t\t\treturn link, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"Rdma device %v not found\", name)\n}\n\n// RdmaLinkSetName sets the name of the rdma link device. Return nil on success\n// or error otherwise.\n// Equivalent to: `rdma dev set $old_devname name $name`\nfunc RdmaLinkSetName(link *RdmaLink, name string) error {\n\treturn pkgHandle.RdmaLinkSetName(link, name)\n}\n\n// RdmaLinkSetName sets the name of the rdma link device. Return nil on success\n// or error otherwise.\n// Equivalent to: `rdma dev set $old_devname name $name`\nfunc (h *Handle) RdmaLinkSetName(link *RdmaLink, name string) error {\n\tproto := getProtoField(nl.RDMA_NL_NLDEV, nl.RDMA_NLDEV_CMD_SET)\n\treq := h.newNetlinkRequest(proto, unix.NLM_F_ACK)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, uint32(link.Attrs.Index))\n\tdata := nl.NewRtAttr(nl.RDMA_NLDEV_ATTR_DEV_INDEX, b)\n\treq.AddData(data)\n\n\tb = make([]byte, len(name)+1)\n\tcopy(b, name)\n\tdata = nl.NewRtAttr(nl.RDMA_NLDEV_ATTR_DEV_NAME, b)\n\treq.AddData(data)\n\n\treturn execRdmaSetLink(req)\n}\n\nfunc netnsModeToString(mode uint8) string {\n\tswitch mode {\n\tcase 0:\n\t\treturn \"exclusive\"\n\tcase 1:\n\t\treturn \"shared\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\nfunc executeOneGetRdmaNetnsMode(data []byte) (string, error) {\n\treader := bytes.NewReader(data)\n\tfor reader.Len() >= 4 {\n\t\t_, attrType, len, value := parseNfAttrTLV(reader)\n\n\t\tswitch attrType {\n\t\tcase nl.RDMA_NLDEV_SYS_ATTR_NETNS_MODE:\n\t\t\tvar mode uint8\n\t\t\tr := bytes.NewReader(value)\n\t\t\tbinary.Read(r, nl.NativeEndian(), &mode)\n\t\t\treturn netnsModeToString(mode), nil\n\t\t}\n\t\tif (len % 4) != 0 {\n\t\t\t// Skip pad bytes\n\t\t\treader.Seek(int64(4-(len%4)), seekCurrent)\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"Invalid netns mode\")\n}\n\n// RdmaSystemGetNetnsMode gets the net namespace mode for RDMA subsystem\n// Returns mode string and error status as nil on success or returns error\n// otherwise.\n// Equivalent to: `rdma system show netns'\nfunc RdmaSystemGetNetnsMode() (string, error) {\n\treturn pkgHandle.RdmaSystemGetNetnsMode()\n}\n\n// RdmaSystemGetNetnsMode gets the net namespace mode for RDMA subsystem\n// Returns mode string and error status as nil on success or returns error\n// otherwise.\n// Equivalent to: `rdma system show netns'\nfunc (h *Handle) RdmaSystemGetNetnsMode() (string, error) {\n\n\tproto := getProtoField(nl.RDMA_NL_NLDEV, nl.RDMA_NLDEV_CMD_SYS_GET)\n\treq := h.newNetlinkRequest(proto, unix.NLM_F_ACK)\n\n\tmsgs, err := req.Execute(unix.NETLINK_RDMA, 0)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif len(msgs) == 0 {\n\t\treturn \"\", fmt.Errorf(\"No valid response from kernel\")\n\t}\n\treturn executeOneGetRdmaNetnsMode(msgs[0])\n}\n\nfunc netnsModeStringToUint8(mode string) (uint8, error) {\n\tswitch mode {\n\tcase \"exclusive\":\n\t\treturn 0, nil\n\tcase \"shared\":\n\t\treturn 1, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"Invalid mode; %q\", mode)\n\t}\n}\n\n// RdmaSystemSetNetnsMode sets the net namespace mode for RDMA subsystem\n// Returns nil on success or appropriate error code.\n// Equivalent to: `rdma system set netns { shared | exclusive }'\nfunc RdmaSystemSetNetnsMode(NewMode string) error {\n\treturn pkgHandle.RdmaSystemSetNetnsMode(NewMode)\n}\n\n// RdmaSystemSetNetnsMode sets the net namespace mode for RDMA subsystem\n// Returns nil on success or appropriate error code.\n// Equivalent to: `rdma system set netns { shared | exclusive }'\nfunc (h *Handle) RdmaSystemSetNetnsMode(NewMode string) error {\n\tvalue, err := netnsModeStringToUint8(NewMode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tproto := getProtoField(nl.RDMA_NL_NLDEV, nl.RDMA_NLDEV_CMD_SYS_SET)\n\treq := h.newNetlinkRequest(proto, unix.NLM_F_ACK)\n\n\tdata := nl.NewRtAttr(nl.RDMA_NLDEV_SYS_ATTR_NETNS_MODE, []byte{value})\n\treq.AddData(data)\n\n\t_, err = req.Execute(unix.NETLINK_RDMA, 0)\n\treturn err\n}\n\n// RdmaLinkSetNsFd puts the RDMA device into a new network namespace. The\n// fd must be an open file descriptor to a network namespace.\n// Similar to: `rdma dev set $dev netns $ns`\nfunc RdmaLinkSetNsFd(link *RdmaLink, fd uint32) error {\n\treturn pkgHandle.RdmaLinkSetNsFd(link, fd)\n}\n\n// RdmaLinkSetNsFd puts the RDMA device into a new network namespace. The\n// fd must be an open file descriptor to a network namespace.\n// Similar to: `rdma dev set $dev netns $ns`\nfunc (h *Handle) RdmaLinkSetNsFd(link *RdmaLink, fd uint32) error {\n\tproto := getProtoField(nl.RDMA_NL_NLDEV, nl.RDMA_NLDEV_CMD_SET)\n\treq := h.newNetlinkRequest(proto, unix.NLM_F_ACK)\n\n\tdata := nl.NewRtAttr(nl.RDMA_NLDEV_ATTR_DEV_INDEX,\n\t\tnl.Uint32Attr(link.Attrs.Index))\n\treq.AddData(data)\n\n\tdata = nl.NewRtAttr(nl.RDMA_NLDEV_NET_NS_FD, nl.Uint32Attr(fd))\n\treq.AddData(data)\n\n\treturn execRdmaSetLink(req)\n}\n\n// RdmaLinkDel deletes an rdma link\n//\n// Similar to: rdma link delete NAME\n// REF: https://man7.org/linux/man-pages/man8/rdma-link.8.html\nfunc RdmaLinkDel(name string) error {\n\treturn pkgHandle.RdmaLinkDel(name)\n}\n\n// RdmaLinkDel deletes an rdma link.\n//\n// If the returned error is [ErrDumpInterrupted], the caller should retry.\nfunc (h *Handle) RdmaLinkDel(name string) error {\n\tlink, err := h.RdmaLinkByName(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tproto := getProtoField(nl.RDMA_NL_NLDEV, nl.RDMA_NLDEV_CMD_DELLINK)\n\treq := h.newNetlinkRequest(proto, unix.NLM_F_ACK)\n\n\tb := make([]byte, 4)\n\tnative.PutUint32(b, link.Attrs.Index)\n\treq.AddData(nl.NewRtAttr(nl.RDMA_NLDEV_ATTR_DEV_INDEX, b))\n\n\t_, err = req.Execute(unix.NETLINK_RDMA, 0)\n\treturn err\n}\n\n// RdmaLinkAdd adds an rdma link for the specified type to the network device.\n// Similar to: rdma link add NAME type TYPE netdev NETDEV\n//\n//\tNAME - specifies the new name of the rdma link to add\n//\tTYPE - specifies which rdma type to use.  Link types:\n//\t\trxe - Soft RoCE driver\n//\t\tsiw - Soft iWARP driver\n//\tNETDEV - specifies the network device to which the link is bound\n//\n// REF: https://man7.org/linux/man-pages/man8/rdma-link.8.html\nfunc RdmaLinkAdd(linkName, linkType, netdev string) error {\n\treturn pkgHandle.RdmaLinkAdd(linkName, linkType, netdev)\n}\n\n// RdmaLinkAdd adds an rdma link for the specified type to the network device.\nfunc (h *Handle) RdmaLinkAdd(linkName string, linkType string, netdev string) error {\n\tproto := getProtoField(nl.RDMA_NL_NLDEV, nl.RDMA_NLDEV_CMD_NEWLINK)\n\treq := h.newNetlinkRequest(proto, unix.NLM_F_ACK)\n\n\treq.AddData(nl.NewRtAttr(nl.RDMA_NLDEV_ATTR_DEV_NAME, nl.ZeroTerminated(linkName)))\n\treq.AddData(nl.NewRtAttr(nl.RDMA_NLDEV_ATTR_LINK_TYPE, nl.ZeroTerminated(linkType)))\n\treq.AddData(nl.NewRtAttr(nl.RDMA_NLDEV_ATTR_NDEV_NAME, nl.ZeroTerminated(netdev)))\n\t_, err := req.Execute(unix.NETLINK_RDMA, 0)\n\treturn err\n}\n"
        },
        {
          "name": "rdma_link_test.go",
          "type": "blob",
          "size": 4.0322265625,
          "content": "// +build linux\n\npackage netlink\n\nimport (\n\t\"io/ioutil\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/vishvananda/netns\"\n)\n\nfunc setupRdmaKModule(t *testing.T, name string) {\n\tskipUnlessRoot(t)\n\tfile, err := ioutil.ReadFile(\"/proc/modules\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open /proc/modules\", err)\n\t}\n\tfor _, line := range strings.Split(string(file), \"\\n\") {\n\t\tn := strings.Split(line, \" \")[0]\n\t\tif n == name {\n\t\t\treturn\n\t\t}\n\n\t}\n\tt.Skipf(\"Test requires kmodule %q.\", name)\n}\n\nfunc TestRdmaGetRdmaLink(t *testing.T) {\n\tminKernelRequired(t, 4, 16)\n\tsetupRdmaKModule(t, \"ib_core\")\n\t_, err := RdmaLinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRdmaSetRdmaLinkName(t *testing.T) {\n\tminKernelRequired(t, 4, 19)\n\tsetupRdmaKModule(t, \"ib_core\")\n\tlink, err := RdmaLinkByName(\"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Set new name\n\terr = RdmaLinkSetName(link, \"bar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Revert back to old name\n\terr = RdmaLinkSetName(link, \"foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRdmaSystemGetNetnsMode(t *testing.T) {\n\tminKernelRequired(t, 5, 2)\n\tsetupRdmaKModule(t, \"ib_core\")\n\n\tmode, err := RdmaSystemGetNetnsMode()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(\"rdma system netns mode =\", mode)\n}\n\nfunc TestRdmaSystemSetNetnsMode(t *testing.T) {\n\tvar newMode string\n\tvar mode string\n\tvar err error\n\n\tminKernelRequired(t, 5, 2)\n\tsetupRdmaKModule(t, \"ib_core\")\n\n\tmode, err = RdmaSystemGetNetnsMode()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(\"current rdma system mode =\", mode)\n\n\terr = RdmaSystemSetNetnsMode(mode)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Flip the mode from current mode\n\tif mode == \"exclusive\" {\n\t\tRdmaSystemSetNetnsMode(\"shared\")\n\t} else {\n\t\tRdmaSystemSetNetnsMode(\"exclusive\")\n\t}\n\tnewMode, err = RdmaSystemGetNetnsMode()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(\"new rdma system mode =\", newMode)\n\n\t// Change back to original mode\n\terr = RdmaSystemSetNetnsMode(mode)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRdmaLinkSetNsFd(t *testing.T) {\n\tminKernelRequired(t, 5, 2)\n\tsetupRdmaKModule(t, \"ib_core\")\n\n\tmode, err := RdmaSystemGetNetnsMode()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(\"current rdma netns mode\", mode)\n\terr = RdmaSystemSetNetnsMode(\"exclusive\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbasens, err := netns.Get()\n\tif err != nil {\n\t\tRdmaSystemSetNetnsMode(mode)\n\t\tt.Fatal(\"Failed to get basens\")\n\t}\n\tdefer basens.Close()\n\n\tnewns, err := netns.New()\n\tif err != nil {\n\t\tRdmaSystemSetNetnsMode(mode)\n\t\tt.Fatal(\"Failed to create newns\")\n\t}\n\n\tnetns.Set(basens)\n\tlink, err := RdmaLinkByName(\"foo\")\n\tif err != nil {\n\t\t// Remove the namespace as RDMA subsystem requires\n\t\t// no namespace to exist when changing net namespace mode\n\t\tnewns.Close()\n\t\tRdmaSystemSetNetnsMode(mode)\n\t\tt.Fatal(err)\n\t}\n\tt.Log(\"rdma link: \", link)\n\n\terr = RdmaLinkSetNsFd(link, uint32(newns))\n\tif err != nil {\n\t\tnewns.Close()\n\t\tRdmaSystemSetNetnsMode(mode)\n\t\tt.Fatal(err)\n\t}\n\n\tnewns.Close()\n\t//Set the old mode back at start of the test\n\terr = RdmaSystemSetNetnsMode(mode)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRdmaLinkList(t *testing.T) {\n\tminKernelRequired(t, 4, 16)\n\tsetupRdmaKModule(t, \"ib_core\")\n\tlinks, err := RdmaLinkList()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(\"RDMA devices:\")\n\tfor _, link := range links {\n\t\tt.Logf(\"%d: %s\", link.Attrs.Index, link.Attrs.Name)\n\t}\n}\n\nfunc TestRdmaLinkAddAndDel(t *testing.T) {\n\t// related commit is https://github.com/torvalds/linux/commit/3856ec4b93c9463d36ee39098dde1fbbd29ec6dd.\n\tminKernelRequired(t, 5, 1)\n\tsetupRdmaKModule(t, \"rdma_rxe\")\n\n\tcheckPresence := func(name string, exist bool) {\n\t\tlinks, err := RdmaLinkList()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfound := false\n\t\tfor _, link := range links {\n\t\t\tif link.Attrs.Name == name {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif found != exist {\n\t\t\tt.Fatalf(\"expected rdma link %s presence=%v, but got presence=%v\", name, exist, found)\n\t\t}\n\t}\n\n\tlinkName := t.Name()\n\n\tif err := RdmaLinkAdd(linkName, \"rxe\", \"lo\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcheckPresence(linkName, true)\n\n\tif err := RdmaLinkDel(linkName); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcheckPresence(linkName, false)\n}\n"
        },
        {
          "name": "route.go",
          "type": "blob",
          "size": 5.6435546875,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\n// Scope is an enum representing a route scope.\ntype Scope uint8\n\ntype NextHopFlag int\n\nconst (\n\tRT_FILTER_PROTOCOL uint64 = 1 << (1 + iota)\n\tRT_FILTER_SCOPE\n\tRT_FILTER_TYPE\n\tRT_FILTER_TOS\n\tRT_FILTER_IIF\n\tRT_FILTER_OIF\n\tRT_FILTER_DST\n\tRT_FILTER_SRC\n\tRT_FILTER_GW\n\tRT_FILTER_TABLE\n\tRT_FILTER_HOPLIMIT\n\tRT_FILTER_PRIORITY\n\tRT_FILTER_MARK\n\tRT_FILTER_MASK\n\tRT_FILTER_REALM\n)\n\ntype Destination interface {\n\tFamily() int\n\tDecode([]byte) error\n\tEncode() ([]byte, error)\n\tString() string\n\tEqual(Destination) bool\n}\n\ntype Encap interface {\n\tType() int\n\tDecode([]byte) error\n\tEncode() ([]byte, error)\n\tString() string\n\tEqual(Encap) bool\n}\n\n//Protocol describe what was the originator of the route\ntype RouteProtocol int\n\n// Route represents a netlink route.\ntype Route struct {\n\tLinkIndex        int\n\tILinkIndex       int\n\tScope            Scope\n\tDst              *net.IPNet\n\tSrc              net.IP\n\tGw               net.IP\n\tMultiPath        []*NexthopInfo\n\tProtocol         RouteProtocol\n\tPriority         int\n\tFamily           int\n\tTable            int\n\tType             int\n\tTos              int\n\tFlags            int\n\tMPLSDst          *int\n\tNewDst           Destination\n\tEncap            Encap\n\tVia              Destination\n\tRealm            int\n\tMTU              int\n\tWindow           int\n\tRtt              int\n\tRttVar           int\n\tSsthresh         int\n\tCwnd             int\n\tAdvMSS           int\n\tReordering       int\n\tHoplimit         int\n\tInitCwnd         int\n\tFeatures         int\n\tRtoMin           int\n\tInitRwnd         int\n\tQuickACK         int\n\tCongctl          string\n\tFastOpenNoCookie int\n}\n\nfunc (r Route) String() string {\n\telems := []string{}\n\tif len(r.MultiPath) == 0 {\n\t\telems = append(elems, fmt.Sprintf(\"Ifindex: %d\", r.LinkIndex))\n\t}\n\tif r.MPLSDst != nil {\n\t\telems = append(elems, fmt.Sprintf(\"Dst: %d\", r.MPLSDst))\n\t} else {\n\t\telems = append(elems, fmt.Sprintf(\"Dst: %s\", r.Dst))\n\t}\n\tif r.NewDst != nil {\n\t\telems = append(elems, fmt.Sprintf(\"NewDst: %s\", r.NewDst))\n\t}\n\tif r.Encap != nil {\n\t\telems = append(elems, fmt.Sprintf(\"Encap: %s\", r.Encap))\n\t}\n\tif r.Via != nil {\n\t\telems = append(elems, fmt.Sprintf(\"Via: %s\", r.Via))\n\t}\n\telems = append(elems, fmt.Sprintf(\"Src: %s\", r.Src))\n\tif len(r.MultiPath) > 0 {\n\t\telems = append(elems, fmt.Sprintf(\"Gw: %s\", r.MultiPath))\n\t} else {\n\t\telems = append(elems, fmt.Sprintf(\"Gw: %s\", r.Gw))\n\t}\n\telems = append(elems, fmt.Sprintf(\"Flags: %s\", r.ListFlags()))\n\telems = append(elems, fmt.Sprintf(\"Table: %d\", r.Table))\n\telems = append(elems, fmt.Sprintf(\"Realm: %d\", r.Realm))\n\treturn fmt.Sprintf(\"{%s}\", strings.Join(elems, \" \"))\n}\n\nfunc (r Route) Equal(x Route) bool {\n\treturn r.LinkIndex == x.LinkIndex &&\n\t\tr.ILinkIndex == x.ILinkIndex &&\n\t\tr.Scope == x.Scope &&\n\t\tipNetEqual(r.Dst, x.Dst) &&\n\t\tr.Src.Equal(x.Src) &&\n\t\tr.Gw.Equal(x.Gw) &&\n\t\tnexthopInfoSlice(r.MultiPath).Equal(x.MultiPath) &&\n\t\tr.Protocol == x.Protocol &&\n\t\tr.Priority == x.Priority &&\n\t\tr.Realm == x.Realm &&\n\t\tr.Table == x.Table &&\n\t\tr.Type == x.Type &&\n\t\tr.Tos == x.Tos &&\n\t\tr.Hoplimit == x.Hoplimit &&\n\t\tr.Flags == x.Flags &&\n\t\t(r.MPLSDst == x.MPLSDst || (r.MPLSDst != nil && x.MPLSDst != nil && *r.MPLSDst == *x.MPLSDst)) &&\n\t\t(r.NewDst == x.NewDst || (r.NewDst != nil && r.NewDst.Equal(x.NewDst))) &&\n\t\t(r.Via == x.Via || (r.Via != nil && r.Via.Equal(x.Via))) &&\n\t\t(r.Encap == x.Encap || (r.Encap != nil && r.Encap.Equal(x.Encap)))\n}\n\nfunc (r *Route) SetFlag(flag NextHopFlag) {\n\tr.Flags |= int(flag)\n}\n\nfunc (r *Route) ClearFlag(flag NextHopFlag) {\n\tr.Flags &^= int(flag)\n}\n\ntype flagString struct {\n\tf NextHopFlag\n\ts string\n}\n\n// RouteUpdate is sent when a route changes - type is RTM_NEWROUTE or RTM_DELROUTE\n\n// NlFlags is only non-zero for RTM_NEWROUTE, the following flags can be set:\n//   - unix.NLM_F_REPLACE - Replace existing matching config object with this request\n//   - unix.NLM_F_EXCL - Don't replace the config object if it already exists\n//   - unix.NLM_F_CREATE - Create config object if it doesn't already exist\n//   - unix.NLM_F_APPEND - Add to the end of the object list\ntype RouteUpdate struct {\n\tType    uint16\n\tNlFlags uint16\n\tRoute\n}\n\ntype NexthopInfo struct {\n\tLinkIndex int\n\tHops      int\n\tGw        net.IP\n\tFlags     int\n\tNewDst    Destination\n\tEncap     Encap\n\tVia       Destination\n}\n\nfunc (n *NexthopInfo) String() string {\n\telems := []string{}\n\telems = append(elems, fmt.Sprintf(\"Ifindex: %d\", n.LinkIndex))\n\tif n.NewDst != nil {\n\t\telems = append(elems, fmt.Sprintf(\"NewDst: %s\", n.NewDst))\n\t}\n\tif n.Encap != nil {\n\t\telems = append(elems, fmt.Sprintf(\"Encap: %s\", n.Encap))\n\t}\n\tif n.Via != nil {\n\t\telems = append(elems, fmt.Sprintf(\"Via: %s\", n.Via))\n\t}\n\telems = append(elems, fmt.Sprintf(\"Weight: %d\", n.Hops+1))\n\telems = append(elems, fmt.Sprintf(\"Gw: %s\", n.Gw))\n\telems = append(elems, fmt.Sprintf(\"Flags: %s\", n.ListFlags()))\n\treturn fmt.Sprintf(\"{%s}\", strings.Join(elems, \" \"))\n}\n\nfunc (n NexthopInfo) Equal(x NexthopInfo) bool {\n\treturn n.LinkIndex == x.LinkIndex &&\n\t\tn.Hops == x.Hops &&\n\t\tn.Gw.Equal(x.Gw) &&\n\t\tn.Flags == x.Flags &&\n\t\t(n.NewDst == x.NewDst || (n.NewDst != nil && n.NewDst.Equal(x.NewDst))) &&\n\t\t(n.Encap == x.Encap || (n.Encap != nil && n.Encap.Equal(x.Encap)))\n}\n\ntype nexthopInfoSlice []*NexthopInfo\n\nfunc (n nexthopInfoSlice) Equal(x []*NexthopInfo) bool {\n\tif len(n) != len(x) {\n\t\treturn false\n\t}\n\tfor i := range n {\n\t\tif n[i] == nil || x[i] == nil {\n\t\t\treturn false\n\t\t}\n\t\tif !n[i].Equal(*x[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// ipNetEqual returns true iff both IPNet are equal\nfunc ipNetEqual(ipn1 *net.IPNet, ipn2 *net.IPNet) bool {\n\tif ipn1 == ipn2 {\n\t\treturn true\n\t}\n\tif ipn1 == nil || ipn2 == nil {\n\t\treturn false\n\t}\n\tm1, _ := ipn1.Mask.Size()\n\tm2, _ := ipn2.Mask.Size()\n\treturn m1 == m2 && ipn1.IP.Equal(ipn2.IP)\n}\n"
        },
        {
          "name": "route_linux.go",
          "type": "blob",
          "size": 49.5927734375,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// RtAttr is shared so it is in netlink_linux.go\n\nconst (\n\tSCOPE_UNIVERSE Scope = unix.RT_SCOPE_UNIVERSE\n\tSCOPE_SITE     Scope = unix.RT_SCOPE_SITE\n\tSCOPE_LINK     Scope = unix.RT_SCOPE_LINK\n\tSCOPE_HOST     Scope = unix.RT_SCOPE_HOST\n\tSCOPE_NOWHERE  Scope = unix.RT_SCOPE_NOWHERE\n)\n\nfunc (s Scope) String() string {\n\tswitch s {\n\tcase SCOPE_UNIVERSE:\n\t\treturn \"universe\"\n\tcase SCOPE_SITE:\n\t\treturn \"site\"\n\tcase SCOPE_LINK:\n\t\treturn \"link\"\n\tcase SCOPE_HOST:\n\t\treturn \"host\"\n\tcase SCOPE_NOWHERE:\n\t\treturn \"nowhere\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\nconst (\n\tFLAG_ONLINK    NextHopFlag = unix.RTNH_F_ONLINK\n\tFLAG_PERVASIVE NextHopFlag = unix.RTNH_F_PERVASIVE\n)\n\nvar testFlags = []flagString{\n\t{f: FLAG_ONLINK, s: \"onlink\"},\n\t{f: FLAG_PERVASIVE, s: \"pervasive\"},\n}\n\nfunc listFlags(flag int) []string {\n\tvar flags []string\n\tfor _, tf := range testFlags {\n\t\tif flag&int(tf.f) != 0 {\n\t\t\tflags = append(flags, tf.s)\n\t\t}\n\t}\n\treturn flags\n}\n\nfunc (r *Route) ListFlags() []string {\n\treturn listFlags(r.Flags)\n}\n\nfunc (n *NexthopInfo) ListFlags() []string {\n\treturn listFlags(n.Flags)\n}\n\ntype MPLSDestination struct {\n\tLabels []int\n}\n\nfunc (d *MPLSDestination) Family() int {\n\treturn nl.FAMILY_MPLS\n}\n\nfunc (d *MPLSDestination) Decode(buf []byte) error {\n\td.Labels = nl.DecodeMPLSStack(buf)\n\treturn nil\n}\n\nfunc (d *MPLSDestination) Encode() ([]byte, error) {\n\treturn nl.EncodeMPLSStack(d.Labels...), nil\n}\n\nfunc (d *MPLSDestination) String() string {\n\ts := make([]string, 0, len(d.Labels))\n\tfor _, l := range d.Labels {\n\t\ts = append(s, fmt.Sprintf(\"%d\", l))\n\t}\n\treturn strings.Join(s, \"/\")\n}\n\nfunc (d *MPLSDestination) Equal(x Destination) bool {\n\to, ok := x.(*MPLSDestination)\n\tif !ok {\n\t\treturn false\n\t}\n\tif d == nil && o == nil {\n\t\treturn true\n\t}\n\tif d == nil || o == nil {\n\t\treturn false\n\t}\n\tif d.Labels == nil && o.Labels == nil {\n\t\treturn true\n\t}\n\tif d.Labels == nil || o.Labels == nil {\n\t\treturn false\n\t}\n\tif len(d.Labels) != len(o.Labels) {\n\t\treturn false\n\t}\n\tfor i := range d.Labels {\n\t\tif d.Labels[i] != o.Labels[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\ntype MPLSEncap struct {\n\tLabels []int\n}\n\nfunc (e *MPLSEncap) Type() int {\n\treturn nl.LWTUNNEL_ENCAP_MPLS\n}\n\nfunc (e *MPLSEncap) Decode(buf []byte) error {\n\tif len(buf) < 4 {\n\t\treturn fmt.Errorf(\"lack of bytes\")\n\t}\n\tl := native.Uint16(buf)\n\tif len(buf) < int(l) {\n\t\treturn fmt.Errorf(\"lack of bytes\")\n\t}\n\tbuf = buf[:l]\n\ttyp := native.Uint16(buf[2:])\n\tif typ != nl.MPLS_IPTUNNEL_DST {\n\t\treturn fmt.Errorf(\"unknown MPLS Encap Type: %d\", typ)\n\t}\n\te.Labels = nl.DecodeMPLSStack(buf[4:])\n\treturn nil\n}\n\nfunc (e *MPLSEncap) Encode() ([]byte, error) {\n\ts := nl.EncodeMPLSStack(e.Labels...)\n\thdr := make([]byte, 4)\n\tnative.PutUint16(hdr, uint16(len(s)+4))\n\tnative.PutUint16(hdr[2:], nl.MPLS_IPTUNNEL_DST)\n\treturn append(hdr, s...), nil\n}\n\nfunc (e *MPLSEncap) String() string {\n\ts := make([]string, 0, len(e.Labels))\n\tfor _, l := range e.Labels {\n\t\ts = append(s, fmt.Sprintf(\"%d\", l))\n\t}\n\treturn strings.Join(s, \"/\")\n}\n\nfunc (e *MPLSEncap) Equal(x Encap) bool {\n\to, ok := x.(*MPLSEncap)\n\tif !ok {\n\t\treturn false\n\t}\n\tif e == nil && o == nil {\n\t\treturn true\n\t}\n\tif e == nil || o == nil {\n\t\treturn false\n\t}\n\tif e.Labels == nil && o.Labels == nil {\n\t\treturn true\n\t}\n\tif e.Labels == nil || o.Labels == nil {\n\t\treturn false\n\t}\n\tif len(e.Labels) != len(o.Labels) {\n\t\treturn false\n\t}\n\tfor i := range e.Labels {\n\t\tif e.Labels[i] != o.Labels[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// SEG6 definitions\ntype SEG6Encap struct {\n\tMode     int\n\tSegments []net.IP\n}\n\nfunc (e *SEG6Encap) Type() int {\n\treturn nl.LWTUNNEL_ENCAP_SEG6\n}\nfunc (e *SEG6Encap) Decode(buf []byte) error {\n\tif len(buf) < 4 {\n\t\treturn fmt.Errorf(\"lack of bytes\")\n\t}\n\t// Get Length(l) & Type(typ) : 2 + 2 bytes\n\tl := native.Uint16(buf)\n\tif len(buf) < int(l) {\n\t\treturn fmt.Errorf(\"lack of bytes\")\n\t}\n\tbuf = buf[:l] // make sure buf size upper limit is Length\n\ttyp := native.Uint16(buf[2:])\n\t// LWTUNNEL_ENCAP_SEG6 has only one attr type SEG6_IPTUNNEL_SRH\n\tif typ != nl.SEG6_IPTUNNEL_SRH {\n\t\treturn fmt.Errorf(\"unknown SEG6 Type: %d\", typ)\n\t}\n\n\tvar err error\n\te.Mode, e.Segments, err = nl.DecodeSEG6Encap(buf[4:])\n\n\treturn err\n}\nfunc (e *SEG6Encap) Encode() ([]byte, error) {\n\ts, err := nl.EncodeSEG6Encap(e.Mode, e.Segments)\n\thdr := make([]byte, 4)\n\tnative.PutUint16(hdr, uint16(len(s)+4))\n\tnative.PutUint16(hdr[2:], nl.SEG6_IPTUNNEL_SRH)\n\treturn append(hdr, s...), err\n}\nfunc (e *SEG6Encap) String() string {\n\tsegs := make([]string, 0, len(e.Segments))\n\t// append segment backwards (from n to 0) since seg#0 is the last segment.\n\tfor i := len(e.Segments); i > 0; i-- {\n\t\tsegs = append(segs, e.Segments[i-1].String())\n\t}\n\tstr := fmt.Sprintf(\"mode %s segs %d [ %s ]\", nl.SEG6EncapModeString(e.Mode),\n\t\tlen(e.Segments), strings.Join(segs, \" \"))\n\treturn str\n}\nfunc (e *SEG6Encap) Equal(x Encap) bool {\n\to, ok := x.(*SEG6Encap)\n\tif !ok {\n\t\treturn false\n\t}\n\tif e == o {\n\t\treturn true\n\t}\n\tif e == nil || o == nil {\n\t\treturn false\n\t}\n\tif e.Mode != o.Mode {\n\t\treturn false\n\t}\n\tif len(e.Segments) != len(o.Segments) {\n\t\treturn false\n\t}\n\tfor i := range e.Segments {\n\t\tif !e.Segments[i].Equal(o.Segments[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// SEG6LocalEncap definitions\ntype SEG6LocalEncap struct {\n\tFlags    [nl.SEG6_LOCAL_MAX]bool\n\tAction   int\n\tSegments []net.IP // from SRH in seg6_local_lwt\n\tTable    int      // table id for End.T and End.DT6\n\tInAddr   net.IP\n\tIn6Addr  net.IP\n\tIif      int\n\tOif      int\n\tbpf      bpfObj\n}\n\nfunc (e *SEG6LocalEncap) SetProg(progFd int, progName string) error {\n\tif progFd <= 0 {\n\t\treturn fmt.Errorf(\"seg6local bpf SetProg: invalid fd\")\n\t}\n\te.bpf.progFd = progFd\n\te.bpf.progName = progName\n\treturn nil\n}\n\nfunc (e *SEG6LocalEncap) Type() int {\n\treturn nl.LWTUNNEL_ENCAP_SEG6_LOCAL\n}\nfunc (e *SEG6LocalEncap) Decode(buf []byte) error {\n\tattrs, err := nl.ParseRouteAttr(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase nl.SEG6_LOCAL_ACTION:\n\t\t\te.Action = int(native.Uint32(attr.Value[0:4]))\n\t\t\te.Flags[nl.SEG6_LOCAL_ACTION] = true\n\t\tcase nl.SEG6_LOCAL_SRH:\n\t\t\te.Segments, err = nl.DecodeSEG6Srh(attr.Value[:])\n\t\t\te.Flags[nl.SEG6_LOCAL_SRH] = true\n\t\tcase nl.SEG6_LOCAL_TABLE:\n\t\t\te.Table = int(native.Uint32(attr.Value[0:4]))\n\t\t\te.Flags[nl.SEG6_LOCAL_TABLE] = true\n\t\tcase nl.SEG6_LOCAL_NH4:\n\t\t\te.InAddr = net.IP(attr.Value[0:4])\n\t\t\te.Flags[nl.SEG6_LOCAL_NH4] = true\n\t\tcase nl.SEG6_LOCAL_NH6:\n\t\t\te.In6Addr = net.IP(attr.Value[0:16])\n\t\t\te.Flags[nl.SEG6_LOCAL_NH6] = true\n\t\tcase nl.SEG6_LOCAL_IIF:\n\t\t\te.Iif = int(native.Uint32(attr.Value[0:4]))\n\t\t\te.Flags[nl.SEG6_LOCAL_IIF] = true\n\t\tcase nl.SEG6_LOCAL_OIF:\n\t\t\te.Oif = int(native.Uint32(attr.Value[0:4]))\n\t\t\te.Flags[nl.SEG6_LOCAL_OIF] = true\n\t\tcase nl.SEG6_LOCAL_BPF:\n\t\t\tvar bpfAttrs []syscall.NetlinkRouteAttr\n\t\t\tbpfAttrs, err = nl.ParseRouteAttr(attr.Value)\n\t\t\tbpfobj := bpfObj{}\n\t\t\tfor _, bpfAttr := range bpfAttrs {\n\t\t\t\tswitch bpfAttr.Attr.Type {\n\t\t\t\tcase nl.LWT_BPF_PROG_FD:\n\t\t\t\t\tbpfobj.progFd = int(native.Uint32(bpfAttr.Value))\n\t\t\t\tcase nl.LWT_BPF_PROG_NAME:\n\t\t\t\t\tbpfobj.progName = string(bpfAttr.Value)\n\t\t\t\tdefault:\n\t\t\t\t\terr = fmt.Errorf(\"seg6local bpf decode: unknown attribute: Type %d\", bpfAttr.Attr)\n\t\t\t\t}\n\t\t\t}\n\t\t\te.bpf = bpfobj\n\t\t\te.Flags[nl.SEG6_LOCAL_BPF] = true\n\t\t}\n\t}\n\treturn err\n}\nfunc (e *SEG6LocalEncap) Encode() ([]byte, error) {\n\tvar err error\n\tres := make([]byte, 8)\n\tnative.PutUint16(res, 8) // length\n\tnative.PutUint16(res[2:], nl.SEG6_LOCAL_ACTION)\n\tnative.PutUint32(res[4:], uint32(e.Action))\n\tif e.Flags[nl.SEG6_LOCAL_SRH] {\n\t\tsrh, err := nl.EncodeSEG6Srh(e.Segments)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tattr := make([]byte, 4)\n\t\tnative.PutUint16(attr, uint16(len(srh)+4))\n\t\tnative.PutUint16(attr[2:], nl.SEG6_LOCAL_SRH)\n\t\tattr = append(attr, srh...)\n\t\tres = append(res, attr...)\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_TABLE] {\n\t\tattr := make([]byte, 8)\n\t\tnative.PutUint16(attr, 8)\n\t\tnative.PutUint16(attr[2:], nl.SEG6_LOCAL_TABLE)\n\t\tnative.PutUint32(attr[4:], uint32(e.Table))\n\t\tres = append(res, attr...)\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_NH4] {\n\t\tattr := make([]byte, 4)\n\t\tnative.PutUint16(attr, 8)\n\t\tnative.PutUint16(attr[2:], nl.SEG6_LOCAL_NH4)\n\t\tipv4 := e.InAddr.To4()\n\t\tif ipv4 == nil {\n\t\t\terr = fmt.Errorf(\"SEG6_LOCAL_NH4 has invalid IPv4 address\")\n\t\t\treturn nil, err\n\t\t}\n\t\tattr = append(attr, ipv4...)\n\t\tres = append(res, attr...)\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_NH6] {\n\t\tattr := make([]byte, 4)\n\t\tnative.PutUint16(attr, 20)\n\t\tnative.PutUint16(attr[2:], nl.SEG6_LOCAL_NH6)\n\t\tattr = append(attr, e.In6Addr...)\n\t\tres = append(res, attr...)\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_IIF] {\n\t\tattr := make([]byte, 8)\n\t\tnative.PutUint16(attr, 8)\n\t\tnative.PutUint16(attr[2:], nl.SEG6_LOCAL_IIF)\n\t\tnative.PutUint32(attr[4:], uint32(e.Iif))\n\t\tres = append(res, attr...)\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_OIF] {\n\t\tattr := make([]byte, 8)\n\t\tnative.PutUint16(attr, 8)\n\t\tnative.PutUint16(attr[2:], nl.SEG6_LOCAL_OIF)\n\t\tnative.PutUint32(attr[4:], uint32(e.Oif))\n\t\tres = append(res, attr...)\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_BPF] {\n\t\tattr := nl.NewRtAttr(nl.SEG6_LOCAL_BPF, []byte{})\n\t\tif e.bpf.progFd != 0 {\n\t\t\tattr.AddRtAttr(nl.LWT_BPF_PROG_FD, nl.Uint32Attr(uint32(e.bpf.progFd)))\n\t\t}\n\t\tif e.bpf.progName != \"\" {\n\t\t\tattr.AddRtAttr(nl.LWT_BPF_PROG_NAME, nl.ZeroTerminated(e.bpf.progName))\n\t\t}\n\t\tres = append(res, attr.Serialize()...)\n\t}\n\treturn res, err\n}\nfunc (e *SEG6LocalEncap) String() string {\n\tstrs := make([]string, 0, nl.SEG6_LOCAL_MAX)\n\tstrs = append(strs, fmt.Sprintf(\"action %s\", nl.SEG6LocalActionString(e.Action)))\n\n\tif e.Flags[nl.SEG6_LOCAL_TABLE] {\n\t\tstrs = append(strs, fmt.Sprintf(\"table %d\", e.Table))\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_NH4] {\n\t\tstrs = append(strs, fmt.Sprintf(\"nh4 %s\", e.InAddr))\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_NH6] {\n\t\tstrs = append(strs, fmt.Sprintf(\"nh6 %s\", e.In6Addr))\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_IIF] {\n\t\tlink, err := LinkByIndex(e.Iif)\n\t\tif err != nil {\n\t\t\tstrs = append(strs, fmt.Sprintf(\"iif %d\", e.Iif))\n\t\t} else {\n\t\t\tstrs = append(strs, fmt.Sprintf(\"iif %s\", link.Attrs().Name))\n\t\t}\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_OIF] {\n\t\tlink, err := LinkByIndex(e.Oif)\n\t\tif err != nil {\n\t\t\tstrs = append(strs, fmt.Sprintf(\"oif %d\", e.Oif))\n\t\t} else {\n\t\t\tstrs = append(strs, fmt.Sprintf(\"oif %s\", link.Attrs().Name))\n\t\t}\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_SRH] {\n\t\tsegs := make([]string, 0, len(e.Segments))\n\t\t// append segment backwards (from n to 0) since seg#0 is the last segment.\n\t\tfor i := len(e.Segments); i > 0; i-- {\n\t\t\tsegs = append(segs, e.Segments[i-1].String())\n\t\t}\n\t\tstrs = append(strs, fmt.Sprintf(\"segs %d [ %s ]\", len(e.Segments), strings.Join(segs, \" \")))\n\t}\n\tif e.Flags[nl.SEG6_LOCAL_BPF] {\n\t\tstrs = append(strs, fmt.Sprintf(\"bpf %s[%d]\", e.bpf.progName, e.bpf.progFd))\n\t}\n\treturn strings.Join(strs, \" \")\n}\nfunc (e *SEG6LocalEncap) Equal(x Encap) bool {\n\to, ok := x.(*SEG6LocalEncap)\n\tif !ok {\n\t\treturn false\n\t}\n\tif e == o {\n\t\treturn true\n\t}\n\tif e == nil || o == nil {\n\t\treturn false\n\t}\n\t// compare all arrays first\n\tfor i := range e.Flags {\n\t\tif e.Flags[i] != o.Flags[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tif len(e.Segments) != len(o.Segments) {\n\t\treturn false\n\t}\n\tfor i := range e.Segments {\n\t\tif !e.Segments[i].Equal(o.Segments[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\t// compare values\n\tif !e.InAddr.Equal(o.InAddr) || !e.In6Addr.Equal(o.In6Addr) {\n\t\treturn false\n\t}\n\tif e.Action != o.Action || e.Table != o.Table || e.Iif != o.Iif || e.Oif != o.Oif || e.bpf != o.bpf {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Encap BPF definitions\ntype bpfObj struct {\n\tprogFd   int\n\tprogName string\n}\ntype BpfEncap struct {\n\tprogs    [nl.LWT_BPF_MAX]bpfObj\n\theadroom int\n}\n\n// SetProg adds a bpf function to the route via netlink RTA_ENCAP. The fd must be a bpf\n// program loaded with bpf(type=BPF_PROG_TYPE_LWT_*) matching the direction the program should\n// be applied to (LWT_BPF_IN, LWT_BPF_OUT, LWT_BPF_XMIT).\nfunc (e *BpfEncap) SetProg(mode, progFd int, progName string) error {\n\tif progFd <= 0 {\n\t\treturn fmt.Errorf(\"lwt bpf SetProg: invalid fd\")\n\t}\n\tif mode <= nl.LWT_BPF_UNSPEC || mode >= nl.LWT_BPF_XMIT_HEADROOM {\n\t\treturn fmt.Errorf(\"lwt bpf SetProg:invalid mode\")\n\t}\n\te.progs[mode].progFd = progFd\n\te.progs[mode].progName = fmt.Sprintf(\"%s[fd:%d]\", progName, progFd)\n\treturn nil\n}\n\n// SetXmitHeadroom sets the xmit headroom (LWT_BPF_MAX_HEADROOM) via netlink RTA_ENCAP.\n// maximum headroom is LWT_BPF_MAX_HEADROOM\nfunc (e *BpfEncap) SetXmitHeadroom(headroom int) error {\n\tif headroom > nl.LWT_BPF_MAX_HEADROOM || headroom < 0 {\n\t\treturn fmt.Errorf(\"invalid headroom size. range is 0 - %d\", nl.LWT_BPF_MAX_HEADROOM)\n\t}\n\te.headroom = headroom\n\treturn nil\n}\n\nfunc (e *BpfEncap) Type() int {\n\treturn nl.LWTUNNEL_ENCAP_BPF\n}\nfunc (e *BpfEncap) Decode(buf []byte) error {\n\tif len(buf) < 4 {\n\t\treturn fmt.Errorf(\"lwt bpf decode: lack of bytes\")\n\t}\n\tnative := nl.NativeEndian()\n\tattrs, err := nl.ParseRouteAttr(buf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"lwt bpf decode: failed parsing attribute. err: %v\", err)\n\t}\n\tfor _, attr := range attrs {\n\t\tif int(attr.Attr.Type) < 1 {\n\t\t\t// nl.LWT_BPF_UNSPEC\n\t\t\tcontinue\n\t\t}\n\t\tif int(attr.Attr.Type) > nl.LWT_BPF_MAX {\n\t\t\treturn fmt.Errorf(\"lwt bpf decode: received unknown attribute type: %d\", attr.Attr.Type)\n\t\t}\n\t\tswitch int(attr.Attr.Type) {\n\t\tcase nl.LWT_BPF_MAX_HEADROOM:\n\t\t\te.headroom = int(native.Uint32(attr.Value))\n\t\tdefault:\n\t\t\tbpfO := bpfObj{}\n\t\t\tparsedAttrs, err := nl.ParseRouteAttr(attr.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"lwt bpf decode: failed parsing route attribute\")\n\t\t\t}\n\t\t\tfor _, parsedAttr := range parsedAttrs {\n\t\t\t\tswitch int(parsedAttr.Attr.Type) {\n\t\t\t\tcase nl.LWT_BPF_PROG_FD:\n\t\t\t\t\tbpfO.progFd = int(native.Uint32(parsedAttr.Value))\n\t\t\t\tcase nl.LWT_BPF_PROG_NAME:\n\t\t\t\t\tbpfO.progName = string(parsedAttr.Value)\n\t\t\t\tdefault:\n\t\t\t\t\treturn fmt.Errorf(\"lwt bpf decode: received unknown attribute: type: %d, len: %d\", parsedAttr.Attr.Type, parsedAttr.Attr.Len)\n\t\t\t\t}\n\t\t\t}\n\t\t\te.progs[attr.Attr.Type] = bpfO\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *BpfEncap) Encode() ([]byte, error) {\n\tbuf := make([]byte, 0)\n\tnative = nl.NativeEndian()\n\tfor index, attr := range e.progs {\n\t\tnlMsg := nl.NewRtAttr(index, []byte{})\n\t\tif attr.progFd != 0 {\n\t\t\tnlMsg.AddRtAttr(nl.LWT_BPF_PROG_FD, nl.Uint32Attr(uint32(attr.progFd)))\n\t\t}\n\t\tif attr.progName != \"\" {\n\t\t\tnlMsg.AddRtAttr(nl.LWT_BPF_PROG_NAME, nl.ZeroTerminated(attr.progName))\n\t\t}\n\t\tif nlMsg.Len() > 4 {\n\t\t\tbuf = append(buf, nlMsg.Serialize()...)\n\t\t}\n\t}\n\tif len(buf) <= 4 {\n\t\treturn nil, fmt.Errorf(\"lwt bpf encode: bpf obj definitions returned empty buffer\")\n\t}\n\tif e.headroom > 0 {\n\t\thRoom := nl.NewRtAttr(nl.LWT_BPF_XMIT_HEADROOM, nl.Uint32Attr(uint32(e.headroom)))\n\t\tbuf = append(buf, hRoom.Serialize()...)\n\t}\n\treturn buf, nil\n}\n\nfunc (e *BpfEncap) String() string {\n\tprogs := make([]string, 0)\n\tfor index, obj := range e.progs {\n\t\tempty := bpfObj{}\n\t\tswitch index {\n\t\tcase nl.LWT_BPF_IN:\n\t\t\tif obj != empty {\n\t\t\t\tprogs = append(progs, fmt.Sprintf(\"in: %s\", obj.progName))\n\t\t\t}\n\t\tcase nl.LWT_BPF_OUT:\n\t\t\tif obj != empty {\n\t\t\t\tprogs = append(progs, fmt.Sprintf(\"out: %s\", obj.progName))\n\t\t\t}\n\t\tcase nl.LWT_BPF_XMIT:\n\t\t\tif obj != empty {\n\t\t\t\tprogs = append(progs, fmt.Sprintf(\"xmit: %s\", obj.progName))\n\t\t\t}\n\t\t}\n\t}\n\tif e.headroom > 0 {\n\t\tprogs = append(progs, fmt.Sprintf(\"xmit headroom: %d\", e.headroom))\n\t}\n\treturn strings.Join(progs, \" \")\n}\n\nfunc (e *BpfEncap) Equal(x Encap) bool {\n\to, ok := x.(*BpfEncap)\n\tif !ok {\n\t\treturn false\n\t}\n\tif e.headroom != o.headroom {\n\t\treturn false\n\t}\n\tfor i := range o.progs {\n\t\tif o.progs[i] != e.progs[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// IP6tnlEncap definition\ntype IP6tnlEncap struct {\n\tID       uint64\n\tDst      net.IP\n\tSrc      net.IP\n\tHoplimit uint8\n\tTC       uint8\n\tFlags    uint16\n}\n\nfunc (e *IP6tnlEncap) Type() int {\n\treturn nl.LWTUNNEL_ENCAP_IP6\n}\n\nfunc (e *IP6tnlEncap) Decode(buf []byte) error {\n\tattrs, err := nl.ParseRouteAttr(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase nl.LWTUNNEL_IP6_ID:\n\t\t\te.ID = uint64(native.Uint64(attr.Value[0:4]))\n\t\tcase nl.LWTUNNEL_IP6_DST:\n\t\t\te.Dst = net.IP(attr.Value[:])\n\t\tcase nl.LWTUNNEL_IP6_SRC:\n\t\t\te.Src = net.IP(attr.Value[:])\n\t\tcase nl.LWTUNNEL_IP6_HOPLIMIT:\n\t\t\te.Hoplimit = attr.Value[0]\n\t\tcase nl.LWTUNNEL_IP6_TC:\n\t\t\t// e.TC = attr.Value[0]\n\t\t\terr = fmt.Errorf(\"decoding TC in IP6tnlEncap is not supported\")\n\t\tcase nl.LWTUNNEL_IP6_FLAGS:\n\t\t\t// e.Flags = uint16(native.Uint16(attr.Value[0:2]))\n\t\t\terr = fmt.Errorf(\"decoding FLAG in IP6tnlEncap is not supported\")\n\t\tcase nl.LWTUNNEL_IP6_PAD:\n\t\t\terr = fmt.Errorf(\"decoding PAD in IP6tnlEncap is not supported\")\n\t\tcase nl.LWTUNNEL_IP6_OPTS:\n\t\t\terr = fmt.Errorf(\"decoding OPTS in IP6tnlEncap is not supported\")\n\t\t}\n\t}\n\treturn err\n}\n\nfunc (e *IP6tnlEncap) Encode() ([]byte, error) {\n\n\tfinal := []byte{}\n\n\tresID := make([]byte, 12)\n\tnative.PutUint16(resID, 12) //  2+2+8\n\tnative.PutUint16(resID[2:], nl.LWTUNNEL_IP6_ID)\n\tnative.PutUint64(resID[4:], 0)\n\tfinal = append(final, resID...)\n\n\tresDst := make([]byte, 4)\n\tnative.PutUint16(resDst, 20) //  2+2+16\n\tnative.PutUint16(resDst[2:], nl.LWTUNNEL_IP6_DST)\n\tresDst = append(resDst, e.Dst...)\n\tfinal = append(final, resDst...)\n\n\tresSrc := make([]byte, 4)\n\tnative.PutUint16(resSrc, 20)\n\tnative.PutUint16(resSrc[2:], nl.LWTUNNEL_IP6_SRC)\n\tresSrc = append(resSrc, e.Src...)\n\tfinal = append(final, resSrc...)\n\n\t// resTc := make([]byte, 5)\n\t// native.PutUint16(resTc, 5)\n\t// native.PutUint16(resTc[2:], nl.LWTUNNEL_IP6_TC)\n\t// resTc[4] = e.TC\n\t// final = append(final,resTc...)\n\n\tresHops := make([]byte, 5)\n\tnative.PutUint16(resHops, 5)\n\tnative.PutUint16(resHops[2:], nl.LWTUNNEL_IP6_HOPLIMIT)\n\tresHops[4] = e.Hoplimit\n\tfinal = append(final, resHops...)\n\n\t// resFlags := make([]byte, 6)\n\t// native.PutUint16(resFlags, 6)\n\t// native.PutUint16(resFlags[2:], nl.LWTUNNEL_IP6_FLAGS)\n\t// native.PutUint16(resFlags[4:], e.Flags)\n\t// final = append(final,resFlags...)\n\n\treturn final, nil\n}\n\nfunc (e *IP6tnlEncap) String() string {\n\treturn fmt.Sprintf(\"id %d src %s dst %s hoplimit %d tc %d flags 0x%.4x\", e.ID, e.Src, e.Dst, e.Hoplimit, e.TC, e.Flags)\n}\n\nfunc (e *IP6tnlEncap) Equal(x Encap) bool {\n\to, ok := x.(*IP6tnlEncap)\n\tif !ok {\n\t\treturn false\n\t}\n\n\tif e.ID != o.ID || e.Flags != o.Flags || e.Hoplimit != o.Hoplimit || e.Src.Equal(o.Src) || e.Dst.Equal(o.Dst) || e.TC != o.TC {\n\t\treturn false\n\t}\n\treturn true\n}\n\ntype Via struct {\n\tAddrFamily int\n\tAddr       net.IP\n}\n\nfunc (v *Via) Equal(x Destination) bool {\n\to, ok := x.(*Via)\n\tif !ok {\n\t\treturn false\n\t}\n\tif v.AddrFamily == x.Family() && v.Addr.Equal(o.Addr) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (v *Via) String() string {\n\treturn fmt.Sprintf(\"Family: %d, Address: %s\", v.AddrFamily, v.Addr.String())\n}\n\nfunc (v *Via) Family() int {\n\treturn v.AddrFamily\n}\n\nfunc (v *Via) Encode() ([]byte, error) {\n\tbuf := &bytes.Buffer{}\n\terr := binary.Write(buf, native, uint16(v.AddrFamily))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = binary.Write(buf, native, v.Addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n\nfunc (v *Via) Decode(b []byte) error {\n\tif len(b) < 6 {\n\t\treturn fmt.Errorf(\"decoding failed: buffer too small (%d bytes)\", len(b))\n\t}\n\tv.AddrFamily = int(native.Uint16(b[0:2]))\n\tif v.AddrFamily == nl.FAMILY_V4 {\n\t\tv.Addr = net.IP(b[2:6])\n\t\treturn nil\n\t} else if v.AddrFamily == nl.FAMILY_V6 {\n\t\tif len(b) < 18 {\n\t\t\treturn fmt.Errorf(\"decoding failed: buffer too small (%d bytes)\", len(b))\n\t\t}\n\t\tv.Addr = net.IP(b[2:])\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"decoding failed: address family %d unknown\", v.AddrFamily)\n}\n\n// RouteAdd will add a route to the system.\n// Equivalent to: `ip route add $route`\nfunc RouteAdd(route *Route) error {\n\treturn pkgHandle.RouteAdd(route)\n}\n\n// RouteAdd will add a route to the system.\n// Equivalent to: `ip route add $route`\nfunc (h *Handle) RouteAdd(route *Route) error {\n\tflags := unix.NLM_F_CREATE | unix.NLM_F_EXCL | unix.NLM_F_ACK\n\treq := h.newNetlinkRequest(unix.RTM_NEWROUTE, flags)\n\t_, err := h.routeHandle(route, req, nl.NewRtMsg())\n\treturn err\n}\n\n// RouteAppend will append a route to the system.\n// Equivalent to: `ip route append $route`\nfunc RouteAppend(route *Route) error {\n\treturn pkgHandle.RouteAppend(route)\n}\n\n// RouteAppend will append a route to the system.\n// Equivalent to: `ip route append $route`\nfunc (h *Handle) RouteAppend(route *Route) error {\n\tflags := unix.NLM_F_CREATE | unix.NLM_F_APPEND | unix.NLM_F_ACK\n\treq := h.newNetlinkRequest(unix.RTM_NEWROUTE, flags)\n\t_, err := h.routeHandle(route, req, nl.NewRtMsg())\n\treturn err\n}\n\n// RouteAddEcmp will add a route to the system.\nfunc RouteAddEcmp(route *Route) error {\n\treturn pkgHandle.RouteAddEcmp(route)\n}\n\n// RouteAddEcmp will add a route to the system.\nfunc (h *Handle) RouteAddEcmp(route *Route) error {\n\tflags := unix.NLM_F_CREATE | unix.NLM_F_ACK\n\treq := h.newNetlinkRequest(unix.RTM_NEWROUTE, flags)\n\t_, err := h.routeHandle(route, req, nl.NewRtMsg())\n\treturn err\n}\n\n// RouteChange will change an existing route in the system.\n// Equivalent to: `ip route change $route`\nfunc RouteChange(route *Route) error {\n\treturn pkgHandle.RouteChange(route)\n}\n\n// RouteChange will change an existing route in the system.\n// Equivalent to: `ip route change $route`\nfunc (h *Handle) RouteChange(route *Route) error {\n\tflags := unix.NLM_F_REPLACE | unix.NLM_F_ACK\n\treq := h.newNetlinkRequest(unix.RTM_NEWROUTE, flags)\n\t_, err := h.routeHandle(route, req, nl.NewRtMsg())\n\treturn err\n}\n\n// RouteReplace will add a route to the system.\n// Equivalent to: `ip route replace $route`\nfunc RouteReplace(route *Route) error {\n\treturn pkgHandle.RouteReplace(route)\n}\n\n// RouteReplace will add a route to the system.\n// Equivalent to: `ip route replace $route`\nfunc (h *Handle) RouteReplace(route *Route) error {\n\tflags := unix.NLM_F_CREATE | unix.NLM_F_REPLACE | unix.NLM_F_ACK\n\treq := h.newNetlinkRequest(unix.RTM_NEWROUTE, flags)\n\t_, err := h.routeHandle(route, req, nl.NewRtMsg())\n\treturn err\n}\n\n// RouteDel will delete a route from the system.\n// Equivalent to: `ip route del $route`\nfunc RouteDel(route *Route) error {\n\treturn pkgHandle.RouteDel(route)\n}\n\n// RouteDel will delete a route from the system.\n// Equivalent to: `ip route del $route`\nfunc (h *Handle) RouteDel(route *Route) error {\n\treq := h.newNetlinkRequest(unix.RTM_DELROUTE, unix.NLM_F_ACK)\n\t_, err := h.routeHandle(route, req, nl.NewRtDelMsg())\n\treturn err\n}\n\nfunc (h *Handle) routeHandle(route *Route, req *nl.NetlinkRequest, msg *nl.RtMsg) ([][]byte, error) {\n\tif err := h.prepareRouteReq(route, req, msg); err != nil {\n\t\treturn nil, err\n\t}\n\treturn req.Execute(unix.NETLINK_ROUTE, 0)\n}\n\nfunc (h *Handle) routeHandleIter(route *Route, req *nl.NetlinkRequest, msg *nl.RtMsg, f func(msg []byte) bool) error {\n\tif err := h.prepareRouteReq(route, req, msg); err != nil {\n\t\treturn err\n\t}\n\treturn req.ExecuteIter(unix.NETLINK_ROUTE, 0, f)\n}\n\nfunc (h *Handle) prepareRouteReq(route *Route, req *nl.NetlinkRequest, msg *nl.RtMsg) error {\n\tif req.NlMsghdr.Type != unix.RTM_GETROUTE && (route.Dst == nil || route.Dst.IP == nil) && route.Src == nil && route.Gw == nil && route.MPLSDst == nil {\n\t\treturn fmt.Errorf(\"either Dst.IP, Src.IP or Gw must be set\")\n\t}\n\n\tfamily := -1\n\tvar rtAttrs []*nl.RtAttr\n\n\tif route.Dst != nil && route.Dst.IP != nil {\n\t\tdstLen, _ := route.Dst.Mask.Size()\n\t\tmsg.Dst_len = uint8(dstLen)\n\t\tdstFamily := nl.GetIPFamily(route.Dst.IP)\n\t\tfamily = dstFamily\n\t\tvar dstData []byte\n\t\tif dstFamily == FAMILY_V4 {\n\t\t\tdstData = route.Dst.IP.To4()\n\t\t} else {\n\t\t\tdstData = route.Dst.IP.To16()\n\t\t}\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_DST, dstData))\n\t} else if route.MPLSDst != nil {\n\t\tfamily = nl.FAMILY_MPLS\n\t\tmsg.Dst_len = uint8(20)\n\t\tmsg.Type = unix.RTN_UNICAST\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_DST, nl.EncodeMPLSStack(*route.MPLSDst)))\n\t}\n\n\tif route.NewDst != nil {\n\t\tif family != -1 && family != route.NewDst.Family() {\n\t\t\treturn fmt.Errorf(\"new destination and destination are not the same address family\")\n\t\t}\n\t\tbuf, err := route.NewDst.Encode()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_NEWDST, buf))\n\t}\n\n\tif route.Encap != nil {\n\t\tbuf := make([]byte, 2)\n\t\tnative.PutUint16(buf, uint16(route.Encap.Type()))\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_ENCAP_TYPE, buf))\n\t\tbuf, err := route.Encap.Encode()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch route.Encap.Type() {\n\t\tcase nl.LWTUNNEL_ENCAP_BPF:\n\t\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_ENCAP|unix.NLA_F_NESTED, buf))\n\t\tdefault:\n\t\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_ENCAP, buf))\n\t\t}\n\n\t}\n\n\tif route.Src != nil {\n\t\tsrcFamily := nl.GetIPFamily(route.Src)\n\t\tif family != -1 && family != srcFamily {\n\t\t\treturn fmt.Errorf(\"source and destination ip are not the same IP family\")\n\t\t}\n\t\tfamily = srcFamily\n\t\tvar srcData []byte\n\t\tif srcFamily == FAMILY_V4 {\n\t\t\tsrcData = route.Src.To4()\n\t\t} else {\n\t\t\tsrcData = route.Src.To16()\n\t\t}\n\t\t// The commonly used src ip for routes is actually PREFSRC\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_PREFSRC, srcData))\n\t}\n\n\tif route.Gw != nil {\n\t\tgwFamily := nl.GetIPFamily(route.Gw)\n\t\tif family != -1 && family != gwFamily {\n\t\t\treturn fmt.Errorf(\"gateway, source, and destination ip are not the same IP family\")\n\t\t}\n\t\tfamily = gwFamily\n\t\tvar gwData []byte\n\t\tif gwFamily == FAMILY_V4 {\n\t\t\tgwData = route.Gw.To4()\n\t\t} else {\n\t\t\tgwData = route.Gw.To16()\n\t\t}\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_GATEWAY, gwData))\n\t}\n\n\tif route.Via != nil {\n\t\tbuf, err := route.Via.Encode()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to encode RTA_VIA: %v\", err)\n\t\t}\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_VIA, buf))\n\t}\n\n\tif len(route.MultiPath) > 0 {\n\t\tbuf := []byte{}\n\t\tfor _, nh := range route.MultiPath {\n\t\t\trtnh := &nl.RtNexthop{\n\t\t\t\tRtNexthop: unix.RtNexthop{\n\t\t\t\t\tHops:    uint8(nh.Hops),\n\t\t\t\t\tIfindex: int32(nh.LinkIndex),\n\t\t\t\t\tFlags:   uint8(nh.Flags),\n\t\t\t\t},\n\t\t\t}\n\t\t\tchildren := []nl.NetlinkRequestData{}\n\t\t\tif nh.Gw != nil {\n\t\t\t\tgwFamily := nl.GetIPFamily(nh.Gw)\n\t\t\t\tif family != -1 && family != gwFamily {\n\t\t\t\t\treturn fmt.Errorf(\"gateway, source, and destination ip are not the same IP family\")\n\t\t\t\t}\n\t\t\t\tif gwFamily == FAMILY_V4 {\n\t\t\t\t\tchildren = append(children, nl.NewRtAttr(unix.RTA_GATEWAY, []byte(nh.Gw.To4())))\n\t\t\t\t} else {\n\t\t\t\t\tchildren = append(children, nl.NewRtAttr(unix.RTA_GATEWAY, []byte(nh.Gw.To16())))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif nh.NewDst != nil {\n\t\t\t\tif family != -1 && family != nh.NewDst.Family() {\n\t\t\t\t\treturn fmt.Errorf(\"new destination and destination are not the same address family\")\n\t\t\t\t}\n\t\t\t\tbuf, err := nh.NewDst.Encode()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tchildren = append(children, nl.NewRtAttr(unix.RTA_NEWDST, buf))\n\t\t\t}\n\t\t\tif nh.Encap != nil {\n\t\t\t\tbuf := make([]byte, 2)\n\t\t\t\tnative.PutUint16(buf, uint16(nh.Encap.Type()))\n\t\t\t\tchildren = append(children, nl.NewRtAttr(unix.RTA_ENCAP_TYPE, buf))\n\t\t\t\tbuf, err := nh.Encap.Encode()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tchildren = append(children, nl.NewRtAttr(unix.RTA_ENCAP, buf))\n\t\t\t}\n\t\t\tif nh.Via != nil {\n\t\t\t\tbuf, err := nh.Via.Encode()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tchildren = append(children, nl.NewRtAttr(unix.RTA_VIA, buf))\n\t\t\t}\n\t\t\trtnh.Children = children\n\t\t\tbuf = append(buf, rtnh.Serialize()...)\n\t\t}\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_MULTIPATH, buf))\n\t}\n\n\tif route.Table > 0 {\n\t\tif route.Table >= 256 {\n\t\t\tmsg.Table = unix.RT_TABLE_UNSPEC\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, uint32(route.Table))\n\t\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_TABLE, b))\n\t\t} else {\n\t\t\tmsg.Table = uint8(route.Table)\n\t\t}\n\t}\n\n\tif route.Priority > 0 {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(route.Priority))\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_PRIORITY, b))\n\t}\n\tif route.Realm > 0 {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(route.Realm))\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_FLOW, b))\n\t}\n\tif route.Tos > 0 {\n\t\tmsg.Tos = uint8(route.Tos)\n\t}\n\tif route.Protocol > 0 {\n\t\tmsg.Protocol = uint8(route.Protocol)\n\t}\n\tif route.Type > 0 {\n\t\tmsg.Type = uint8(route.Type)\n\t}\n\n\tvar metrics []*nl.RtAttr\n\tif route.MTU > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.MTU))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_MTU, b))\n\t}\n\tif route.Window > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.Window))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_WINDOW, b))\n\t}\n\tif route.Rtt > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.Rtt))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_RTT, b))\n\t}\n\tif route.RttVar > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.RttVar))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_RTTVAR, b))\n\t}\n\tif route.Ssthresh > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.Ssthresh))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_SSTHRESH, b))\n\t}\n\tif route.Cwnd > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.Cwnd))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_CWND, b))\n\t}\n\tif route.AdvMSS > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.AdvMSS))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_ADVMSS, b))\n\t}\n\tif route.Reordering > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.Reordering))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_REORDERING, b))\n\t}\n\tif route.Hoplimit > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.Hoplimit))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_HOPLIMIT, b))\n\t}\n\tif route.InitCwnd > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.InitCwnd))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_INITCWND, b))\n\t}\n\tif route.Features > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.Features))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_FEATURES, b))\n\t}\n\tif route.RtoMin > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.RtoMin))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_RTO_MIN, b))\n\t}\n\tif route.InitRwnd > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.InitRwnd))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_INITRWND, b))\n\t}\n\tif route.QuickACK > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.QuickACK))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_QUICKACK, b))\n\t}\n\tif route.Congctl != \"\" {\n\t\tb := nl.ZeroTerminated(route.Congctl)\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_CC_ALGO, b))\n\t}\n\tif route.FastOpenNoCookie > 0 {\n\t\tb := nl.Uint32Attr(uint32(route.FastOpenNoCookie))\n\t\tmetrics = append(metrics, nl.NewRtAttr(unix.RTAX_FASTOPEN_NO_COOKIE, b))\n\t}\n\n\tif metrics != nil {\n\t\tattr := nl.NewRtAttr(unix.RTA_METRICS, nil)\n\t\tfor _, metric := range metrics {\n\t\t\tattr.AddChild(metric)\n\t\t}\n\t\trtAttrs = append(rtAttrs, attr)\n\t}\n\n\tmsg.Flags = uint32(route.Flags)\n\tmsg.Scope = uint8(route.Scope)\n\t// only overwrite family if it was not set in msg\n\tif msg.Family == 0 {\n\t\tmsg.Family = uint8(family)\n\t}\n\treq.AddData(msg)\n\tfor _, attr := range rtAttrs {\n\t\treq.AddData(attr)\n\t}\n\n\tif (req.NlMsghdr.Type != unix.RTM_GETROUTE) || (req.NlMsghdr.Type == unix.RTM_GETROUTE && route.LinkIndex > 0) {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(route.LinkIndex))\n\t\treq.AddData(nl.NewRtAttr(unix.RTA_OIF, b))\n\t}\n\treturn nil\n}\n\n// RouteList gets a list of routes in the system.\n// Equivalent to: `ip route show`.\n// The list can be filtered by link and ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc RouteList(link Link, family int) ([]Route, error) {\n\treturn pkgHandle.RouteList(link, family)\n}\n\n// RouteList gets a list of routes in the system.\n// Equivalent to: `ip route show`.\n// The list can be filtered by link and ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) RouteList(link Link, family int) ([]Route, error) {\n\trouteFilter := &Route{}\n\tif link != nil {\n\t\trouteFilter.LinkIndex = link.Attrs().Index\n\n\t\treturn h.RouteListFiltered(family, routeFilter, RT_FILTER_OIF)\n\t}\n\treturn h.RouteListFiltered(family, routeFilter, 0)\n}\n\n// RouteListFiltered gets a list of routes in the system filtered with specified rules.\n// All rules must be defined in RouteFilter struct\nfunc RouteListFiltered(family int, filter *Route, filterMask uint64) ([]Route, error) {\n\treturn pkgHandle.RouteListFiltered(family, filter, filterMask)\n}\n\n// RouteListFiltered gets a list of routes in the system filtered with specified rules.\n// All rules must be defined in RouteFilter struct\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) RouteListFiltered(family int, filter *Route, filterMask uint64) ([]Route, error) {\n\tvar res []Route\n\terr := h.RouteListFilteredIter(family, filter, filterMask, func(route Route) (cont bool) {\n\t\tres = append(res, route)\n\t\treturn true\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}\n\n// RouteListFilteredIter passes each route that matches the filter to the given iterator func.  Iteration continues\n// until all routes are loaded or the func returns false.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc RouteListFilteredIter(family int, filter *Route, filterMask uint64, f func(Route) (cont bool)) error {\n\treturn pkgHandle.RouteListFilteredIter(family, filter, filterMask, f)\n}\n\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) RouteListFilteredIter(family int, filter *Route, filterMask uint64, f func(Route) (cont bool)) error {\n\treq := h.newNetlinkRequest(unix.RTM_GETROUTE, unix.NLM_F_DUMP)\n\trtmsg := &nl.RtMsg{}\n\trtmsg.Family = uint8(family)\n\n\tvar parseErr error\n\texecuteErr := h.routeHandleIter(filter, req, rtmsg, func(m []byte) bool {\n\t\tmsg := nl.DeserializeRtMsg(m)\n\t\tif family != FAMILY_ALL && msg.Family != uint8(family) {\n\t\t\t// Ignore routes not matching requested family\n\t\t\treturn true\n\t\t}\n\t\tif msg.Flags&unix.RTM_F_CLONED != 0 {\n\t\t\t// Ignore cloned routes\n\t\t\treturn true\n\t\t}\n\t\tif msg.Table != unix.RT_TABLE_MAIN {\n\t\t\tif filter == nil || filterMask&RT_FILTER_TABLE == 0 {\n\t\t\t\t// Ignore non-main tables\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\troute, err := deserializeRoute(m)\n\t\tif err != nil {\n\t\t\tparseErr = err\n\t\t\treturn false\n\t\t}\n\t\tif filter != nil {\n\t\t\tswitch {\n\t\t\tcase filterMask&RT_FILTER_TABLE != 0 && filter.Table != unix.RT_TABLE_UNSPEC && route.Table != filter.Table:\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_PROTOCOL != 0 && route.Protocol != filter.Protocol:\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_SCOPE != 0 && route.Scope != filter.Scope:\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_TYPE != 0 && route.Type != filter.Type:\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_TOS != 0 && route.Tos != filter.Tos:\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_REALM != 0 && route.Realm != filter.Realm:\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_OIF != 0 && route.LinkIndex != filter.LinkIndex:\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_IIF != 0 && route.ILinkIndex != filter.ILinkIndex:\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_GW != 0 && !route.Gw.Equal(filter.Gw):\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_SRC != 0 && !route.Src.Equal(filter.Src):\n\t\t\t\treturn true\n\t\t\tcase filterMask&RT_FILTER_DST != 0:\n\t\t\t\tif filter.MPLSDst == nil || route.MPLSDst == nil || (*filter.MPLSDst) != (*route.MPLSDst) {\n\t\t\t\t\tif filter.Dst == nil {\n\t\t\t\t\t\tfilter.Dst = genZeroIPNet(family)\n\t\t\t\t\t}\n\t\t\t\t\tif !ipNetEqual(route.Dst, filter.Dst) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase filterMask&RT_FILTER_HOPLIMIT != 0 && route.Hoplimit != filter.Hoplimit:\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn f(route)\n\t})\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn executeErr\n\t}\n\tif parseErr != nil {\n\t\treturn parseErr\n\t}\n\treturn executeErr\n}\n\n// deserializeRoute decodes a binary netlink message into a Route struct\nfunc deserializeRoute(m []byte) (Route, error) {\n\tmsg := nl.DeserializeRtMsg(m)\n\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\tif err != nil {\n\t\treturn Route{}, err\n\t}\n\troute := Route{\n\t\tScope:    Scope(msg.Scope),\n\t\tProtocol: RouteProtocol(int(msg.Protocol)),\n\t\tTable:    int(msg.Table),\n\t\tType:     int(msg.Type),\n\t\tTos:      int(msg.Tos),\n\t\tFlags:    int(msg.Flags),\n\t\tFamily:   int(msg.Family),\n\t}\n\n\tvar encap, encapType syscall.NetlinkRouteAttr\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase unix.RTA_GATEWAY:\n\t\t\troute.Gw = net.IP(attr.Value)\n\t\tcase unix.RTA_PREFSRC:\n\t\t\troute.Src = net.IP(attr.Value)\n\t\tcase unix.RTA_DST:\n\t\t\tif msg.Family == nl.FAMILY_MPLS {\n\t\t\t\tstack := nl.DecodeMPLSStack(attr.Value)\n\t\t\t\tif len(stack) == 0 || len(stack) > 1 {\n\t\t\t\t\treturn route, fmt.Errorf(\"invalid MPLS RTA_DST\")\n\t\t\t\t}\n\t\t\t\troute.MPLSDst = &stack[0]\n\t\t\t} else {\n\t\t\t\troute.Dst = &net.IPNet{\n\t\t\t\t\tIP:   attr.Value,\n\t\t\t\t\tMask: net.CIDRMask(int(msg.Dst_len), 8*len(attr.Value)),\n\t\t\t\t}\n\t\t\t}\n\t\tcase unix.RTA_OIF:\n\t\t\troute.LinkIndex = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.RTA_IIF:\n\t\t\troute.ILinkIndex = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.RTA_PRIORITY:\n\t\t\troute.Priority = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.RTA_FLOW:\n\t\t\troute.Realm = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.RTA_TABLE:\n\t\t\troute.Table = int(native.Uint32(attr.Value[0:4]))\n\t\tcase unix.RTA_MULTIPATH:\n\t\t\tparseRtNexthop := func(value []byte) (*NexthopInfo, []byte, error) {\n\t\t\t\tif len(value) < unix.SizeofRtNexthop {\n\t\t\t\t\treturn nil, nil, fmt.Errorf(\"lack of bytes\")\n\t\t\t\t}\n\t\t\t\tnh := nl.DeserializeRtNexthop(value)\n\t\t\t\tif len(value) < int(nh.RtNexthop.Len) {\n\t\t\t\t\treturn nil, nil, fmt.Errorf(\"lack of bytes\")\n\t\t\t\t}\n\t\t\t\tinfo := &NexthopInfo{\n\t\t\t\t\tLinkIndex: int(nh.RtNexthop.Ifindex),\n\t\t\t\t\tHops:      int(nh.RtNexthop.Hops),\n\t\t\t\t\tFlags:     int(nh.RtNexthop.Flags),\n\t\t\t\t}\n\t\t\t\tattrs, err := nl.ParseRouteAttr(value[unix.SizeofRtNexthop:int(nh.RtNexthop.Len)])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil, err\n\t\t\t\t}\n\t\t\t\tvar encap, encapType syscall.NetlinkRouteAttr\n\t\t\t\tfor _, attr := range attrs {\n\t\t\t\t\tswitch attr.Attr.Type {\n\t\t\t\t\tcase unix.RTA_GATEWAY:\n\t\t\t\t\t\tinfo.Gw = net.IP(attr.Value)\n\t\t\t\t\tcase unix.RTA_NEWDST:\n\t\t\t\t\t\tvar d Destination\n\t\t\t\t\t\tswitch msg.Family {\n\t\t\t\t\t\tcase nl.FAMILY_MPLS:\n\t\t\t\t\t\t\td = &MPLSDestination{}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif err := d.Decode(attr.Value); err != nil {\n\t\t\t\t\t\t\treturn nil, nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo.NewDst = d\n\t\t\t\t\tcase unix.RTA_ENCAP_TYPE:\n\t\t\t\t\t\tencapType = attr\n\t\t\t\t\tcase unix.RTA_ENCAP:\n\t\t\t\t\t\tencap = attr\n\t\t\t\t\tcase unix.RTA_VIA:\n\t\t\t\t\t\td := &Via{}\n\t\t\t\t\t\tif err := d.Decode(attr.Value); err != nil {\n\t\t\t\t\t\t\treturn nil, nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo.Via = d\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif len(encap.Value) != 0 && len(encapType.Value) != 0 {\n\t\t\t\t\ttyp := int(native.Uint16(encapType.Value[0:2]))\n\t\t\t\t\tvar e Encap\n\t\t\t\t\tswitch typ {\n\t\t\t\t\tcase nl.LWTUNNEL_ENCAP_MPLS:\n\t\t\t\t\t\te = &MPLSEncap{}\n\t\t\t\t\t\tif err := e.Decode(encap.Value); err != nil {\n\t\t\t\t\t\t\treturn nil, nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinfo.Encap = e\n\t\t\t\t}\n\n\t\t\t\treturn info, value[int(nh.RtNexthop.Len):], nil\n\t\t\t}\n\t\t\trest := attr.Value\n\t\t\tfor len(rest) > 0 {\n\t\t\t\tinfo, buf, err := parseRtNexthop(rest)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn route, err\n\t\t\t\t}\n\t\t\t\troute.MultiPath = append(route.MultiPath, info)\n\t\t\t\trest = buf\n\t\t\t}\n\t\tcase unix.RTA_NEWDST:\n\t\t\tvar d Destination\n\t\t\tswitch msg.Family {\n\t\t\tcase nl.FAMILY_MPLS:\n\t\t\t\td = &MPLSDestination{}\n\t\t\t}\n\t\t\tif err := d.Decode(attr.Value); err != nil {\n\t\t\t\treturn route, err\n\t\t\t}\n\t\t\troute.NewDst = d\n\t\tcase unix.RTA_VIA:\n\t\t\tv := &Via{}\n\t\t\tif err := v.Decode(attr.Value); err != nil {\n\t\t\t\treturn route, err\n\t\t\t}\n\t\t\troute.Via = v\n\t\tcase unix.RTA_ENCAP_TYPE:\n\t\t\tencapType = attr\n\t\tcase unix.RTA_ENCAP:\n\t\t\tencap = attr\n\t\tcase unix.RTA_METRICS:\n\t\t\tmetrics, err := nl.ParseRouteAttr(attr.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn route, err\n\t\t\t}\n\t\t\tfor _, metric := range metrics {\n\t\t\t\tswitch metric.Attr.Type {\n\t\t\t\tcase unix.RTAX_MTU:\n\t\t\t\t\troute.MTU = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_WINDOW:\n\t\t\t\t\troute.Window = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_RTT:\n\t\t\t\t\troute.Rtt = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_RTTVAR:\n\t\t\t\t\troute.RttVar = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_SSTHRESH:\n\t\t\t\t\troute.Ssthresh = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_CWND:\n\t\t\t\t\troute.Cwnd = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_ADVMSS:\n\t\t\t\t\troute.AdvMSS = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_REORDERING:\n\t\t\t\t\troute.Reordering = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_HOPLIMIT:\n\t\t\t\t\troute.Hoplimit = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_INITCWND:\n\t\t\t\t\troute.InitCwnd = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_FEATURES:\n\t\t\t\t\troute.Features = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_RTO_MIN:\n\t\t\t\t\troute.RtoMin = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_INITRWND:\n\t\t\t\t\troute.InitRwnd = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_QUICKACK:\n\t\t\t\t\troute.QuickACK = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\tcase unix.RTAX_CC_ALGO:\n\t\t\t\t\troute.Congctl = nl.BytesToString(metric.Value)\n\t\t\t\tcase unix.RTAX_FASTOPEN_NO_COOKIE:\n\t\t\t\t\troute.FastOpenNoCookie = int(native.Uint32(metric.Value[0:4]))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Same logic to generate \"default\" dst with iproute2 implementation\n\tif route.Dst == nil {\n\t\tvar addLen int\n\t\tvar ip net.IP\n\t\tswitch msg.Family {\n\t\tcase FAMILY_V4:\n\t\t\taddLen = net.IPv4len\n\t\t\tip = net.IPv4zero\n\t\tcase FAMILY_V6:\n\t\t\taddLen = net.IPv6len\n\t\t\tip = net.IPv6zero\n\t\t}\n\n\t\tif addLen != 0 {\n\t\t\troute.Dst = &net.IPNet{\n\t\t\t\tIP:   ip,\n\t\t\t\tMask: net.CIDRMask(int(msg.Dst_len), 8*addLen),\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(encap.Value) != 0 && len(encapType.Value) != 0 {\n\t\ttyp := int(native.Uint16(encapType.Value[0:2]))\n\t\tvar e Encap\n\t\tswitch typ {\n\t\tcase nl.LWTUNNEL_ENCAP_MPLS:\n\t\t\te = &MPLSEncap{}\n\t\t\tif err := e.Decode(encap.Value); err != nil {\n\t\t\t\treturn route, err\n\t\t\t}\n\t\tcase nl.LWTUNNEL_ENCAP_SEG6:\n\t\t\te = &SEG6Encap{}\n\t\t\tif err := e.Decode(encap.Value); err != nil {\n\t\t\t\treturn route, err\n\t\t\t}\n\t\tcase nl.LWTUNNEL_ENCAP_SEG6_LOCAL:\n\t\t\te = &SEG6LocalEncap{}\n\t\t\tif err := e.Decode(encap.Value); err != nil {\n\t\t\t\treturn route, err\n\t\t\t}\n\t\tcase nl.LWTUNNEL_ENCAP_BPF:\n\t\t\te = &BpfEncap{}\n\t\t\tif err := e.Decode(encap.Value); err != nil {\n\t\t\t\treturn route, err\n\t\t\t}\n\t\t}\n\t\troute.Encap = e\n\t}\n\n\treturn route, nil\n}\n\n// RouteGetOptions contains a set of options to use with\n// RouteGetWithOptions\ntype RouteGetOptions struct {\n\tIif      string\n\tIifIndex int\n\tOif      string\n\tVrfName  string\n\tSrcAddr  net.IP\n\tUID      *uint32\n\tMark     uint32\n\tFIBMatch bool\n}\n\n// RouteGetWithOptions gets a route to a specific destination from the host system.\n// Equivalent to: 'ip route get <> vrf <VrfName>'.\nfunc RouteGetWithOptions(destination net.IP, options *RouteGetOptions) ([]Route, error) {\n\treturn pkgHandle.RouteGetWithOptions(destination, options)\n}\n\n// RouteGet gets a route to a specific destination from the host system.\n// Equivalent to: 'ip route get'.\nfunc RouteGet(destination net.IP) ([]Route, error) {\n\treturn pkgHandle.RouteGet(destination)\n}\n\n// RouteGetWithOptions gets a route to a specific destination from the host system.\n// Equivalent to: 'ip route get <> vrf <VrfName>'.\nfunc (h *Handle) RouteGetWithOptions(destination net.IP, options *RouteGetOptions) ([]Route, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETROUTE, unix.NLM_F_REQUEST)\n\tfamily := nl.GetIPFamily(destination)\n\tvar destinationData []byte\n\tvar bitlen uint8\n\tif family == FAMILY_V4 {\n\t\tdestinationData = destination.To4()\n\t\tbitlen = 32\n\t} else {\n\t\tdestinationData = destination.To16()\n\t\tbitlen = 128\n\t}\n\tmsg := &nl.RtMsg{}\n\tmsg.Family = uint8(family)\n\tmsg.Dst_len = bitlen\n\tif options != nil && options.SrcAddr != nil {\n\t\tmsg.Src_len = bitlen\n\t}\n\tmsg.Flags = unix.RTM_F_LOOKUP_TABLE\n\tif options != nil && options.FIBMatch {\n\t\tmsg.Flags |= unix.RTM_F_FIB_MATCH\n\t}\n\treq.AddData(msg)\n\n\trtaDst := nl.NewRtAttr(unix.RTA_DST, destinationData)\n\treq.AddData(rtaDst)\n\n\tif options != nil {\n\t\tif options.VrfName != \"\" {\n\t\t\tlink, err := h.LinkByName(options.VrfName)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, uint32(link.Attrs().Index))\n\n\t\t\treq.AddData(nl.NewRtAttr(unix.RTA_OIF, b))\n\t\t}\n\n\t\tiifIndex := 0\n\t\tif len(options.Iif) > 0 {\n\t\t\tlink, err := h.LinkByName(options.Iif)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tiifIndex = link.Attrs().Index\n\t\t} else if options.IifIndex > 0 {\n\t\t\tiifIndex = options.IifIndex\n\t\t}\n\n\t\tif iifIndex > 0 {\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, uint32(iifIndex))\n\n\t\t\treq.AddData(nl.NewRtAttr(unix.RTA_IIF, b))\n\t\t}\n\n\t\tif len(options.Oif) > 0 {\n\t\t\tlink, err := h.LinkByName(options.Oif)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, uint32(link.Attrs().Index))\n\n\t\t\treq.AddData(nl.NewRtAttr(unix.RTA_OIF, b))\n\t\t}\n\n\t\tif options.SrcAddr != nil {\n\t\t\tvar srcAddr []byte\n\t\t\tif family == FAMILY_V4 {\n\t\t\t\tsrcAddr = options.SrcAddr.To4()\n\t\t\t} else {\n\t\t\t\tsrcAddr = options.SrcAddr.To16()\n\t\t\t}\n\n\t\t\treq.AddData(nl.NewRtAttr(unix.RTA_SRC, srcAddr))\n\t\t}\n\n\t\tif options.UID != nil {\n\t\t\tuid := *options.UID\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, uid)\n\n\t\t\treq.AddData(nl.NewRtAttr(unix.RTA_UID, b))\n\t\t}\n\n\t\tif options.Mark > 0 {\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, options.Mark)\n\n\t\t\treq.AddData(nl.NewRtAttr(unix.RTA_MARK, b))\n\t\t}\n\t}\n\n\tmsgs, err := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWROUTE)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res []Route\n\tfor _, m := range msgs {\n\t\troute, err := deserializeRoute(m)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres = append(res, route)\n\t}\n\treturn res, nil\n}\n\n// RouteGet gets a route to a specific destination from the host system.\n// Equivalent to: 'ip route get'.\nfunc (h *Handle) RouteGet(destination net.IP) ([]Route, error) {\n\treturn h.RouteGetWithOptions(destination, nil)\n}\n\n// RouteSubscribe takes a chan down which notifications will be sent\n// when routes are added or deleted. Close the 'done' chan to stop subscription.\nfunc RouteSubscribe(ch chan<- RouteUpdate, done <-chan struct{}) error {\n\treturn routeSubscribeAt(netns.None(), netns.None(), ch, done, nil, false, 0, nil, false)\n}\n\n// RouteSubscribeAt works like RouteSubscribe plus it allows the caller\n// to choose the network namespace in which to subscribe (ns).\nfunc RouteSubscribeAt(ns netns.NsHandle, ch chan<- RouteUpdate, done <-chan struct{}) error {\n\treturn routeSubscribeAt(ns, netns.None(), ch, done, nil, false, 0, nil, false)\n}\n\n// RouteSubscribeOptions contains a set of options to use with\n// RouteSubscribeWithOptions.\ntype RouteSubscribeOptions struct {\n\tNamespace              *netns.NsHandle\n\tErrorCallback          func(error)\n\tListExisting           bool\n\tReceiveBufferSize      int\n\tReceiveBufferForceSize bool\n\tReceiveTimeout         *unix.Timeval\n}\n\n// RouteSubscribeWithOptions work like RouteSubscribe but enable to\n// provide additional options to modify the behavior. Currently, the\n// namespace can be provided as well as an error callback.\n//\n// When options.ListExisting is true, options.ErrorCallback may be\n// called with [ErrDumpInterrupted] to indicate that results from\n// the initial dump of links may be inconsistent or incomplete.\nfunc RouteSubscribeWithOptions(ch chan<- RouteUpdate, done <-chan struct{}, options RouteSubscribeOptions) error {\n\tif options.Namespace == nil {\n\t\tnone := netns.None()\n\t\toptions.Namespace = &none\n\t}\n\treturn routeSubscribeAt(*options.Namespace, netns.None(), ch, done, options.ErrorCallback, options.ListExisting,\n\t\toptions.ReceiveBufferSize, options.ReceiveTimeout, options.ReceiveBufferForceSize)\n}\n\nfunc routeSubscribeAt(newNs, curNs netns.NsHandle, ch chan<- RouteUpdate, done <-chan struct{}, cberr func(error), listExisting bool,\n\trcvbuf int, rcvTimeout *unix.Timeval, rcvbufForce bool) error {\n\ts, err := nl.SubscribeAt(newNs, curNs, unix.NETLINK_ROUTE, unix.RTNLGRP_IPV4_ROUTE, unix.RTNLGRP_IPV6_ROUTE)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif rcvTimeout != nil {\n\t\tif err := s.SetReceiveTimeout(rcvTimeout); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif rcvbuf != 0 {\n\t\terr = s.SetReceiveBufferSize(rcvbuf, rcvbufForce)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif done != nil {\n\t\tgo func() {\n\t\t\t<-done\n\t\t\ts.Close()\n\t\t}()\n\t}\n\tif listExisting {\n\t\treq := pkgHandle.newNetlinkRequest(unix.RTM_GETROUTE,\n\t\t\tunix.NLM_F_DUMP)\n\t\tinfmsg := nl.NewIfInfomsg(unix.AF_UNSPEC)\n\t\treq.AddData(infmsg)\n\t\tif err := s.Send(req); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor {\n\t\t\tmsgs, from, err := s.Receive()\n\t\t\tif err != nil {\n\t\t\t\tif cberr != nil {\n\t\t\t\t\tcberr(fmt.Errorf(\"Receive failed: %v\",\n\t\t\t\t\t\terr))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif from.Pid != nl.PidKernel {\n\t\t\t\tif cberr != nil {\n\t\t\t\t\tcberr(fmt.Errorf(\"Wrong sender portid %d, expected %d\", from.Pid, nl.PidKernel))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, m := range msgs {\n\t\t\t\tif m.Header.Flags&unix.NLM_F_DUMP_INTR != 0 && cberr != nil {\n\t\t\t\t\tcberr(ErrDumpInterrupted)\n\t\t\t\t}\n\t\t\t\tif m.Header.Type == unix.NLMSG_DONE {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif m.Header.Type == unix.NLMSG_ERROR {\n\t\t\t\t\terror := int32(native.Uint32(m.Data[0:4]))\n\t\t\t\t\tif error == 0 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\tcberr(fmt.Errorf(\"error message: %v\",\n\t\t\t\t\t\t\tsyscall.Errno(-error)))\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\troute, err := deserializeRoute(m.Data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif cberr != nil {\n\t\t\t\t\t\tcberr(err)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tch <- RouteUpdate{\n\t\t\t\t\tType:    m.Header.Type,\n\t\t\t\t\tNlFlags: m.Header.Flags & (unix.NLM_F_REPLACE | unix.NLM_F_EXCL | unix.NLM_F_CREATE | unix.NLM_F_APPEND),\n\t\t\t\t\tRoute:   route,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (p RouteProtocol) String() string {\n\tswitch int(p) {\n\tcase unix.RTPROT_BABEL:\n\t\treturn \"babel\"\n\tcase unix.RTPROT_BGP:\n\t\treturn \"bgp\"\n\tcase unix.RTPROT_BIRD:\n\t\treturn \"bird\"\n\tcase unix.RTPROT_BOOT:\n\t\treturn \"boot\"\n\tcase unix.RTPROT_DHCP:\n\t\treturn \"dhcp\"\n\tcase unix.RTPROT_DNROUTED:\n\t\treturn \"dnrouted\"\n\tcase unix.RTPROT_EIGRP:\n\t\treturn \"eigrp\"\n\tcase unix.RTPROT_GATED:\n\t\treturn \"gated\"\n\tcase unix.RTPROT_ISIS:\n\t\treturn \"isis\"\n\t// case unix.RTPROT_KEEPALIVED:\n\t//\treturn \"keepalived\"\n\tcase unix.RTPROT_KERNEL:\n\t\treturn \"kernel\"\n\tcase unix.RTPROT_MROUTED:\n\t\treturn \"mrouted\"\n\tcase unix.RTPROT_MRT:\n\t\treturn \"mrt\"\n\tcase unix.RTPROT_NTK:\n\t\treturn \"ntk\"\n\tcase unix.RTPROT_OSPF:\n\t\treturn \"ospf\"\n\tcase unix.RTPROT_RA:\n\t\treturn \"ra\"\n\tcase unix.RTPROT_REDIRECT:\n\t\treturn \"redirect\"\n\tcase unix.RTPROT_RIP:\n\t\treturn \"rip\"\n\tcase unix.RTPROT_STATIC:\n\t\treturn \"static\"\n\tcase unix.RTPROT_UNSPEC:\n\t\treturn \"unspec\"\n\tcase unix.RTPROT_XORP:\n\t\treturn \"xorp\"\n\tcase unix.RTPROT_ZEBRA:\n\t\treturn \"zebra\"\n\tdefault:\n\t\treturn strconv.Itoa(int(p))\n\t}\n}\n\n// genZeroIPNet returns 0.0.0.0/0 or ::/0 for IPv4 or IPv6, otherwise nil\nfunc genZeroIPNet(family int) *net.IPNet {\n\tvar addLen int\n\tvar ip net.IP\n\tswitch family {\n\tcase FAMILY_V4:\n\t\taddLen = net.IPv4len\n\t\tip = net.IPv4zero\n\tcase FAMILY_V6:\n\t\taddLen = net.IPv6len\n\t\tip = net.IPv6zero\n\t}\n\tif addLen != 0 {\n\t\treturn &net.IPNet{\n\t\t\tIP:   ip,\n\t\t\tMask: net.CIDRMask(0, 8*addLen),\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "route_test.go",
          "type": "blob",
          "size": 56.986328125,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestRouteAddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\tip := net.IPv4(127, 1, 1, 1)\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err := RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\troutes, err = RouteList(nil, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not listed properly\")\n\t}\n\n\tdstIP := net.IPv4(192, 168, 0, 42)\n\trouteToDstIP, err := RouteGet(dstIP)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(routeToDstIP) == 0 {\n\t\tt.Fatal(\"Default route not present\")\n\t}\n\tif err := RouteDel(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Route not removed properly\")\n\t}\n\n\t// add default route test\n\t// equiv: default dev lo\n\t_, defaultDst, _ := net.ParseCIDR(\"0.0.0.0/0\")\n\troute = Route{Dst: defaultDst, LinkIndex: link.Attrs().Index}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Dev default route not listed properly\")\n\t}\n\tif err := RouteDel(&routes[0]); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Dev default route not removed properly\")\n\t}\n\n\t// equiv: blackhole default\n\troute = Route{Dst: defaultDst, Type: unix.RTN_BLACKHOLE, Family: FAMILY_V4}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(nil, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Logf(\"%+v\", routes)\n\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Blackhole default route not listed properly\")\n\t}\n\n\tif err := RouteDel(&routes[0]); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(nil, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Blackhole default route not removed properly\")\n\t}\n\n\t// equiv: prohibit default\n\troute = Route{Dst: defaultDst, Type: unix.RTN_PROHIBIT}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(nil, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Prohibit default route not listed properly\")\n\t}\n\n\tif err := RouteDel(&routes[0]); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(nil, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Prohibit default route not removed properly\")\n\t}\n}\n\nfunc TestRoute6AddDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// create dummy interface\n\t// IPv6 route added to loopback interface will be unreachable\n\tla := NewLinkAttrs()\n\tla.Name = \"dummy_route6\"\n\tla.TxQLen = 1500\n\tdummy := &Dummy{LinkAttrs: la}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// get dummy interface\n\tlink, err := LinkByName(\"dummy_route6\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// remember number of routes before adding\n\t// typically one route (fe80::/64) will be created when dummy_route6 is created\n\troutes, err := RouteList(link, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tnroutes := len(routes)\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.ParseIP(\"2001:db8::0\"),\n\t\tMask: net.CIDRMask(64, 128),\n\t}\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != nroutes+1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\tdstIP := net.ParseIP(\"2001:db8::1\")\n\trouteToDstIP, err := RouteGet(dstIP)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// cleanup route\n\tif len(routeToDstIP) == 0 {\n\t\tt.Fatal(\"Route not present\")\n\t}\n\tif err := RouteDel(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != nroutes {\n\t\tt.Fatal(\"Route not removed properly\")\n\t}\n\n\t// add a default link route\n\t_, defaultDst, _ := net.ParseCIDR(\"::/0\")\n\troute = Route{LinkIndex: link.Attrs().Index, Dst: defaultDst}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != nroutes+1 {\n\t\tt.Fatal(\"Default route not added properly\")\n\t}\n\n\t// add a default link route\n\tfor _, route := range routes {\n\t\tif route.Dst.String() == defaultDst.String() {\n\t\t\tif err := RouteDel(&route); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n\troutes, err = RouteList(link, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != nroutes {\n\t\tt.Fatal(\"Default route not removed properly\")\n\t}\n\n\t// add blackhole default link route\n\troutes, err = RouteList(nil, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tnroutes = len(routes)\n\n\troute = Route{Type: unix.RTN_BLACKHOLE, Dst: defaultDst}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(nil, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != nroutes+1 {\n\t\tt.Fatal(\"Blackhole default route not added properly\")\n\t}\n\n\t// add blackhole default link route\n\tfor _, route := range routes {\n\t\tif ipNetEqual(route.Dst, defaultDst) {\n\t\t\tif err := RouteDel(&route); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n\troutes, err = RouteList(nil, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != nroutes {\n\t\tt.Fatal(\"Blackhole default route not removed properly\")\n\t}\n\n\t// add prohibit default link route\n\troutes, err = RouteList(nil, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tnroutes = len(routes)\n\n\troute = Route{Type: unix.RTN_BLACKHOLE, Dst: defaultDst}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(nil, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != nroutes+1 {\n\t\tt.Fatal(\"Prohibit default route not added properly\")\n\t}\n\n\t// add prohibit default link route\n\tfor _, route := range routes {\n\t\tif ipNetEqual(route.Dst, defaultDst) {\n\t\t\tif err := RouteDel(&route); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n\troutes, err = RouteList(nil, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != nroutes {\n\t\tt.Fatal(\"Prohibit default route not removed properly\")\n\t}\n\n\t// cleanup dummy interface created for the test\n\tif err := LinkDel(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRouteChange(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\tip := net.IPv4(127, 1, 1, 1)\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\n\tif err := RouteChange(&route); err == nil {\n\t\tt.Fatal(\"Route added while it should fail\")\n\t}\n\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err := RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\tip = net.IPv4(127, 1, 1, 2)\n\troute = Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := RouteChange(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(routes) != 1 || !routes[0].Src.Equal(ip) {\n\t\tt.Fatal(\"Route not changed properly\")\n\t}\n\n\tif err := RouteDel(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Route not removed properly\")\n\t}\n}\n\nfunc TestRouteReplace(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\tip := net.IPv4(127, 1, 1, 1)\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err := RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\tip = net.IPv4(127, 1, 1, 2)\n\troute = Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := RouteReplace(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(routes) != 1 || !routes[0].Src.Equal(ip) {\n\t\tt.Fatal(\"Route not replaced properly\")\n\t}\n\n\tif err := RouteDel(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Route not removed properly\")\n\t}\n}\n\nfunc TestRouteAppend(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\tip := net.IPv4(127, 1, 1, 1)\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err := RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\tip = net.IPv4(127, 1, 1, 2)\n\troute = Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := RouteAppend(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(routes) != 2 || !routes[1].Src.Equal(ip) {\n\t\tt.Fatal(\"Route not append properly\")\n\t}\n\n\tif err := RouteDel(&routes[0]); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := RouteDel(&routes[1]); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Route not removed properly\")\n\t}\n}\n\nfunc TestRouteAddIncomplete(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\troute := Route{LinkIndex: link.Attrs().Index}\n\tif err := RouteAdd(&route); err == nil {\n\t\tt.Fatal(\"Adding incomplete route should fail\")\n\t}\n}\n\n// expectRouteUpdate returns whether the expected updated is received within one minute.\nfunc expectRouteUpdate(ch <-chan RouteUpdate, t, f uint16, dst net.IP) bool {\n\tfor {\n\t\ttimeout := time.After(time.Minute)\n\t\tselect {\n\t\tcase update := <-ch:\n\t\t\tif update.Type == t &&\n\t\t\t\tupdate.NlFlags == f &&\n\t\t\t\tupdate.Route.Dst != nil &&\n\t\t\t\tupdate.Route.Dst.IP.Equal(dst) {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase <-timeout:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunc TestRouteSubscribe(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tch := make(chan RouteUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := RouteSubscribe(ch, done); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\tip := net.IPv4(127, 1, 1, 1)\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectRouteUpdate(ch, unix.RTM_NEWROUTE, unix.NLM_F_EXCL|unix.NLM_F_CREATE, dst.IP) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n\tif err := RouteDel(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !expectRouteUpdate(ch, unix.RTM_DELROUTE, 0, dst.IP) {\n\t\tt.Fatal(\"Del update not received as expected\")\n\t}\n}\n\nfunc TestRouteSubscribeWithOptions(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tch := make(chan RouteUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tvar lastError error\n\tdefer func() {\n\t\tif lastError != nil {\n\t\t\tt.Fatalf(\"Fatal error received during subscription: %v\", lastError)\n\t\t}\n\t}()\n\tif err := RouteSubscribeWithOptions(ch, done, RouteSubscribeOptions{\n\t\tErrorCallback: func(err error) {\n\t\t\tlastError = err\n\t\t},\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\tip := net.IPv4(127, 1, 1, 1)\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectRouteUpdate(ch, unix.RTM_NEWROUTE, unix.NLM_F_EXCL|unix.NLM_F_CREATE, dst.IP) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n}\n\nfunc TestRouteSubscribeAt(t *testing.T) {\n\tskipUnlessRoot(t)\n\n\t// Create an handle on a custom netns\n\tnewNs, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer newNs.Close()\n\n\tnh, err := NewHandleAt(newNs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer nh.Close()\n\n\t// Subscribe for Route events on the custom netns\n\tch := make(chan RouteUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := RouteSubscribeAt(newNs, ch, done); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// get loopback interface\n\tlink, err := nh.LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err = nh.LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 169, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\tip := net.IPv4(127, 100, 1, 1)\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := nh.RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectRouteUpdate(ch, unix.RTM_NEWROUTE, unix.NLM_F_EXCL|unix.NLM_F_CREATE, dst.IP) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n\tif err := nh.RouteDel(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !expectRouteUpdate(ch, unix.RTM_DELROUTE, 0, dst.IP) {\n\t\tt.Fatal(\"Del update not received as expected\")\n\t}\n}\n\nfunc TestRouteSubscribeListExisting(t *testing.T) {\n\tskipUnlessRoot(t)\n\n\t// Create an handle on a custom netns\n\tnewNs, err := netns.New()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer newNs.Close()\n\n\tnh, err := NewHandleAt(newNs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer nh.Close()\n\n\t// get loopback interface\n\tlink, err := nh.LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err = nh.LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route before subscribing\n\tdst10 := &net.IPNet{\n\t\tIP:   net.IPv4(10, 10, 10, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\tip := net.IPv4(127, 100, 1, 1)\n\troute10 := Route{LinkIndex: link.Attrs().Index, Dst: dst10, Src: ip}\n\tif err := nh.RouteAdd(&route10); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Subscribe for Route events including existing routes\n\tch := make(chan RouteUpdate)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tif err := RouteSubscribeWithOptions(ch, done, RouteSubscribeOptions{\n\t\tNamespace:    &newNs,\n\t\tListExisting: true},\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectRouteUpdate(ch, unix.RTM_NEWROUTE, 0, dst10.IP) {\n\t\tt.Fatal(\"Existing add update not received as expected\")\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 169, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst, Src: ip}\n\tif err := nh.RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !expectRouteUpdate(ch, unix.RTM_NEWROUTE, unix.NLM_F_EXCL|unix.NLM_F_CREATE, dst.IP) {\n\t\tt.Fatal(\"Add update not received as expected\")\n\t}\n\tif err := nh.RouteDel(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !expectRouteUpdate(ch, unix.RTM_DELROUTE, 0, dst.IP) {\n\t\tt.Fatal(\"Del update not received as expected\")\n\t}\n\tif err := nh.RouteDel(&route10); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !expectRouteUpdate(ch, unix.RTM_DELROUTE, 0, dst10.IP) {\n\t\tt.Fatal(\"Del update not received as expected\")\n\t}\n}\n\nfunc TestRouteFilterAllTables(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(1, 1, 1, 1),\n\t\tMask: net.CIDRMask(32, 32),\n\t}\n\n\ttables := []int{1000, 1001, 1002}\n\tsrc := net.IPv4(127, 3, 3, 3)\n\tfor _, table := range tables {\n\t\troute := Route{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tDst:       dst,\n\t\t\tSrc:       src,\n\t\t\tScope:     unix.RT_SCOPE_LINK,\n\t\t\tPriority:  13,\n\t\t\tTable:     table,\n\t\t\tType:      unix.RTN_UNICAST,\n\t\t\tTos:       12,\n\t\t\tHoplimit:  100,\n\t\t\tRealm:     328,\n\t\t}\n\t\tif err := RouteAdd(&route); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\troutes, err := RouteListFiltered(FAMILY_V4, &Route{\n\t\tDst:      dst,\n\t\tSrc:      src,\n\t\tScope:    unix.RT_SCOPE_LINK,\n\t\tTable:    unix.RT_TABLE_UNSPEC,\n\t\tType:     unix.RTN_UNICAST,\n\t\tTos:      12,\n\t\tHoplimit: 100,\n\t\tRealm:    328,\n\t}, RT_FILTER_DST|RT_FILTER_SRC|RT_FILTER_SCOPE|RT_FILTER_TABLE|RT_FILTER_TYPE|RT_FILTER_TOS|RT_FILTER_HOPLIMIT|RT_FILTER_REALM)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 3 {\n\t\tt.Fatal(\"Routes not added properly\")\n\t}\n\n\tfor _, route := range routes {\n\t\tif route.Scope != unix.RT_SCOPE_LINK {\n\t\t\tt.Fatal(\"Invalid Scope. Route not added properly\")\n\t\t}\n\t\tif route.Priority != 13 {\n\t\t\tt.Fatal(\"Invalid Priority. Route not added properly\")\n\t\t}\n\t\tif !tableIDIn(tables, route.Table) {\n\t\t\tt.Fatalf(\"Invalid Table %d. Route not added properly\", route.Table)\n\t\t}\n\t\tif route.Type != unix.RTN_UNICAST {\n\t\t\tt.Fatal(\"Invalid Type. Route not added properly\")\n\t\t}\n\t\tif route.Tos != 12 {\n\t\t\tt.Fatal(\"Invalid Tos. Route not added properly\")\n\t\t}\n\t\tif route.Hoplimit != 100 {\n\t\t\tt.Fatal(\"Invalid Hoplimit. Route not added properly\")\n\t\t}\n\t\tif route.Realm != 328 {\n\t\t\tt.Fatal(\"Invalid Realm. Route not added properly\")\n\t\t}\n\t}\n}\n\nfunc TestRouteFilterByFamily(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tconst table int = 999\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a IPv4 gateway route\n\tdst4 := &net.IPNet{\n\t\tIP:   net.IPv4(2, 2, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\troute4 := Route{LinkIndex: link.Attrs().Index, Dst: dst4, Table: table}\n\tif err := RouteAdd(&route4); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a IPv6 gateway route\n\tdst6 := &net.IPNet{\n\t\tIP:   net.ParseIP(\"2001:db9::0\"),\n\t\tMask: net.CIDRMask(64, 128),\n\t}\n\troute6 := Route{LinkIndex: link.Attrs().Index, Dst: dst6, Table: table}\n\tif err := RouteAdd(&route6); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Get routes for both families\n\troutes_all, err := RouteListFiltered(FAMILY_ALL, &Route{Table: table}, RT_FILTER_TABLE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes_all) != 2 {\n\t\tt.Fatal(\"Filtering by FAMILY_ALL doesn't find two routes\")\n\t}\n\n\t// Get IPv4 route\n\troutes_v4, err := RouteListFiltered(FAMILY_V4, &Route{Table: table}, RT_FILTER_TABLE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes_v4) != 1 {\n\t\tt.Fatal(\"Filtering by FAMILY_V4 doesn't find one route\")\n\t}\n\n\t// Get IPv6 route\n\troutes_v6, err := RouteListFiltered(FAMILY_V6, &Route{Table: table}, RT_FILTER_TABLE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes_v6) != 1 {\n\t\tt.Fatal(\"Filtering by FAMILY_V6 doesn't find one route\")\n\t}\n\n\t// Get non-existent routes\n\troutes_non_existent, err := RouteListFiltered(99, &Route{Table: table}, RT_FILTER_TABLE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes_non_existent) != 0 {\n\t\tt.Fatal(\"Filtering by non-existent family find some route\")\n\t}\n}\n\nfunc TestRouteFilterIterCanStop(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(1, 1, 1, 1),\n\t\tMask: net.CIDRMask(32, 32),\n\t}\n\n\tfor i := 0; i < 3; i++ {\n\t\troute := Route{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tDst:       dst,\n\t\t\tScope:     unix.RT_SCOPE_LINK,\n\t\t\tPriority:  1 + i,\n\t\t\tTable:     1000,\n\t\t\tType:      unix.RTN_UNICAST,\n\t\t}\n\t\tif err := RouteAdd(&route); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tvar routes []Route\n\terr = RouteListFilteredIter(FAMILY_V4, &Route{\n\t\tDst:   dst,\n\t\tScope: unix.RT_SCOPE_LINK,\n\t\tTable: 1000,\n\t\tType:  unix.RTN_UNICAST,\n\t}, RT_FILTER_TABLE, func(route Route) (cont bool) {\n\t\troutes = append(routes, route)\n\t\treturn len(routes) < 2\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 2 {\n\t\tt.Fatal(\"Unexpected number of iterations\")\n\t}\n\tfor _, route := range routes {\n\t\tif route.Scope != unix.RT_SCOPE_LINK {\n\t\t\tt.Fatal(\"Invalid Scope. Route not added properly\")\n\t\t}\n\t\tif route.Priority < 1 || route.Priority > 3 {\n\t\t\tt.Fatal(\"Priority outside expected range. Route not added properly\")\n\t\t}\n\t\tif route.Table != 1000 {\n\t\t\tt.Fatalf(\"Invalid Table %d. Route not added properly\", route.Table)\n\t\t}\n\t\tif route.Type != unix.RTN_UNICAST {\n\t\t\tt.Fatal(\"Invalid Type. Route not added properly\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkRouteListFilteredNew(b *testing.B) {\n\ttearDown := setUpNetlinkTest(b)\n\tdefer tearDown()\n\n\tlink, err := setUpRoutesBench(b)\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tvar routes []Route\n\tfor i := 0; i < b.N; i++ {\n\t\troutes, err = pkgHandle.RouteListFiltered(FAMILY_V4, &Route{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t}, RT_FILTER_OIF)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif len(routes) != 65535 {\n\t\t\tb.Fatal(\"Incorrect number of routes.\", len(routes))\n\t\t}\n\t}\n\truntime.KeepAlive(routes)\n}\n\nfunc BenchmarkRouteListIter(b *testing.B) {\n\ttearDown := setUpNetlinkTest(b)\n\tdefer tearDown()\n\n\tlink, err := setUpRoutesBench(b)\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tvar routes int\n\t\terr = RouteListFilteredIter(FAMILY_V4, &Route{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t}, RT_FILTER_OIF, func(route Route) (cont bool) {\n\t\t\troutes++\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif routes != 65535 {\n\t\t\tb.Fatal(\"Incorrect number of routes.\", routes)\n\t\t}\n\t}\n}\n\nfunc setUpRoutesBench(b *testing.B) (Link, error) {\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tfor i := 0; i < 65535; i++ {\n\t\tdst := &net.IPNet{\n\t\t\tIP:   net.IPv4(1, 1, byte(i>>8), byte(i&0xff)),\n\t\t\tMask: net.CIDRMask(32, 32),\n\t\t}\n\t\troute := Route{\n\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\tDst:       dst,\n\t\t\tScope:     unix.RT_SCOPE_LINK,\n\t\t\tPriority:  10,\n\t\t\tType:      unix.RTN_UNICAST,\n\t\t}\n\t\tif err := RouteAdd(&route); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n\treturn link, err\n}\n\nfunc tableIDIn(ids []int, id int) bool {\n\tfor _, v := range ids {\n\t\tif v == id {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestRouteExtraFields(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(1, 1, 1, 1),\n\t\tMask: net.CIDRMask(32, 32),\n\t}\n\n\tsrc := net.IPv4(127, 3, 3, 3)\n\troute := Route{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tDst:       dst,\n\t\tSrc:       src,\n\t\tScope:     unix.RT_SCOPE_LINK,\n\t\tPriority:  13,\n\t\tTable:     unix.RT_TABLE_MAIN,\n\t\tType:      unix.RTN_UNICAST,\n\t\tTos:       12,\n\t\tHoplimit:  100,\n\t\tRealm:     239,\n\t}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err := RouteListFiltered(FAMILY_V4, &Route{\n\t\tDst:      dst,\n\t\tSrc:      src,\n\t\tScope:    unix.RT_SCOPE_LINK,\n\t\tTable:    unix.RT_TABLE_MAIN,\n\t\tType:     unix.RTN_UNICAST,\n\t\tTos:      12,\n\t\tHoplimit: 100,\n\t\tRealm:    239,\n\t}, RT_FILTER_DST|RT_FILTER_SRC|RT_FILTER_SCOPE|RT_FILTER_TABLE|RT_FILTER_TYPE|RT_FILTER_TOS|RT_FILTER_HOPLIMIT|RT_FILTER_REALM)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\tif routes[0].Scope != unix.RT_SCOPE_LINK {\n\t\tt.Fatal(\"Invalid Scope. Route not added properly\")\n\t}\n\tif routes[0].Priority != 13 {\n\t\tt.Fatal(\"Invalid Priority. Route not added properly\")\n\t}\n\tif routes[0].Table != unix.RT_TABLE_MAIN {\n\t\tt.Fatal(\"Invalid Scope. Route not added properly\")\n\t}\n\tif routes[0].Type != unix.RTN_UNICAST {\n\t\tt.Fatal(\"Invalid Type. Route not added properly\")\n\t}\n\tif routes[0].Tos != 12 {\n\t\tt.Fatal(\"Invalid Tos. Route not added properly\")\n\t}\n\tif routes[0].Hoplimit != 100 {\n\t\tt.Fatal(\"Invalid Hoplimit. Route not added properly\")\n\t}\n\tif routes[0].Realm != 239 {\n\t\tt.Fatal(\"Invalid Realm. Route not added properly\")\n\t}\n}\n\nfunc TestRouteMultiPath(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\tidx := link.Attrs().Index\n\troute := Route{Dst: dst, MultiPath: []*NexthopInfo{{LinkIndex: idx}, {LinkIndex: idx}}}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err := RouteList(nil, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"MultiPath Route not added properly\")\n\t}\n\tif len(routes[0].MultiPath) != 2 {\n\t\tt.Fatal(\"MultiPath Route not added properly\")\n\t}\n}\n\nfunc TestRouteIifOption(t *testing.T) {\n\tskipUnlessRoot(t)\n\n\truntime.LockOSThread()\n\tt.Cleanup(runtime.UnlockOSThread)\n\n\trootNs, err := netns.GetFromPid(1)\n\tif err != nil {\n\t\tt.Fatalf(\"could not get root ns: %s\", err)\n\t}\n\tt.Cleanup(func() { rootNs.Close() })\n\n\trootHdl, err := NewHandleAt(rootNs)\n\tif err != nil {\n\t\tt.Fatalf(\"could not create handle for root ns: %s\", err)\n\t}\n\tt.Cleanup(func() { rootHdl.Close() })\n\n\t// setup a veth pair across two namespaces\n\t//   veth1 (2.2.2.3/24) <-> veth2 (2.2.2.4/24)\n\n\t// peer ns for veth pair\n\tns, err := netns.New()\n\tif err != nil {\n\t\tt.Fatalf(\"could not create new ns: %s\", err)\n\t}\n\tt.Cleanup(func() { ns.Close() })\n\n\tl := &Veth{\n\t\tLinkAttrs:     LinkAttrs{Name: \"veth1\"},\n\t\tPeerName:      \"veth2\",\n\t\tPeerNamespace: NsFd(ns),\n\t}\n\tif err = rootHdl.LinkAdd(l); err != nil {\n\t\tt.Fatalf(\"could not add veth interface: %s\", err)\n\t}\n\tt.Cleanup(func() { rootHdl.LinkDel(l) })\n\n\tve1, err := rootHdl.LinkByName(\"veth1\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not get link veth1: %s\", err)\n\t}\n\n\terr = rootHdl.AddrAdd(ve1, &Addr{IPNet: &net.IPNet{IP: net.ParseIP(\"2.2.2.3\"), Mask: net.CIDRMask(24, 32)}})\n\tif err != nil {\n\t\tt.Fatalf(\"could not set address for veth1: %s\", err)\n\t}\n\n\tnh, err := NewHandleAt(ns)\n\tif err != nil {\n\t\tt.Fatalf(\"could not get handle for ns %+v: %s\", ns, err)\n\t}\n\tt.Cleanup(func() { nh.Close() })\n\n\tve2, err := nh.LinkByName(\"veth2\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not get link veth2: %s\", err)\n\t}\n\n\terr = nh.AddrAdd(ve2, &Addr{IPNet: &net.IPNet{IP: net.ParseIP(\"2.2.2.4\"), Mask: net.CIDRMask(24, 32)}})\n\tif err != nil {\n\t\tt.Fatalf(\"could set address for veth2: %s\", err)\n\t}\n\n\tif err = rootHdl.LinkSetUp(ve1); err != nil {\n\t\tt.Fatalf(\"could not set veth1 up: %s\", err)\n\t}\n\n\tif err = nh.LinkSetUp(ve2); err != nil {\n\t\tt.Fatalf(\"could not set veth2 up: %s\", err)\n\t}\n\n\terr = nh.RouteAdd(&Route{\n\t\tDst: &net.IPNet{\n\t\t\tIP:   net.IPv4zero,\n\t\t\tMask: net.CIDRMask(0, 32),\n\t\t},\n\t\tGw: net.ParseIP(\"2.2.2.3\"),\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"could not add default route to ns: %s\", err)\n\t}\n\n\t// setup finished, now do the actual test\n\n\t_, err = rootHdl.RouteGetWithOptions(net.ParseIP(\"8.8.8.8\"), &RouteGetOptions{\n\t\tSrcAddr: net.ParseIP(\"2.2.2.4\"),\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"route get should have resulted in error but did not\")\n\t}\n\n\ttestWithOptions := func(opts *RouteGetOptions) {\n\t\troutes, err := rootHdl.RouteGetWithOptions(net.ParseIP(\"8.8.8.8\"), opts)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not get route: %s\", err)\n\t\t}\n\t\tif len(routes) != 1 {\n\t\t\tt.Fatalf(\"did not get exactly one route, routes: %+v\", routes)\n\t\t}\n\n\t\t// should be the default route\n\t\tr, err := rootHdl.RouteGet(net.ParseIP(\"8.8.8.8\"))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not get default route for 8.8.8.8: %s\", err)\n\t\t}\n\t\tif len(r) != 1 {\n\t\t\tt.Fatalf(\"did not get exactly one route, routes: %+v\", routes)\n\t\t}\n\t\tif !routes[0].Gw.Equal(r[0].Gw) {\n\t\t\tt.Fatalf(\"wrong gateway in route: expected: %s, got: %s\", r[0].Gw, routes[0].Gw)\n\t\t}\n\t\tif routes[0].LinkIndex != r[0].LinkIndex {\n\t\t\tt.Fatalf(\"wrong link in route: expected: %d, got: %d\", r[0].LinkIndex, routes[0].LinkIndex)\n\t\t}\n\t}\n\n\tt.Run(\"with iif\", func(t *testing.T) {\n\t\ttestWithOptions(&RouteGetOptions{\n\t\t\tSrcAddr: net.ParseIP(\"2.2.2.4\"),\n\t\t\tIif:     \"veth1\",\n\t\t})\n\t})\n\n\tt.Run(\"with iifIndex\", func(t *testing.T) {\n\t\ttestWithOptions(&RouteGetOptions{\n\t\t\tSrcAddr:  net.ParseIP(\"2.2.2.4\"),\n\t\t\tIifIndex: ve1.Attrs().Index,\n\t\t})\n\t})\n\n\tt.Run(\"with iif and iifIndex\", func(t *testing.T) {\n\t\ttestWithOptions(&RouteGetOptions{\n\t\t\tSrcAddr:  net.ParseIP(\"2.2.2.4\"),\n\t\t\tIif:      \"veth1\",\n\t\t\tIifIndex: ve2.Attrs().Index, // Iif will supersede here\n\t\t})\n\t})\n}\n\nfunc TestRouteOifOption(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// setup two interfaces: eth0, eth1\n\terr := LinkAdd(&Dummy{LinkAttrs{Name: \"eth0\"}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink1, err := LinkByName(\"eth0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = LinkSetUp(link1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = LinkAdd(&Dummy{LinkAttrs{Name: \"eth1\"}}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink2, err := LinkByName(\"eth1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = LinkSetUp(link2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// config ip addresses on interfaces\n\taddr1 := &Addr{\n\t\tIPNet: &net.IPNet{\n\t\t\tIP:   net.IPv4(192, 168, 1, 1),\n\t\t\tMask: net.CIDRMask(24, 32),\n\t\t},\n\t}\n\n\tif err = AddrAdd(link1, addr1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\taddr2 := &Addr{\n\t\tIPNet: &net.IPNet{\n\t\t\tIP:   net.IPv4(192, 168, 2, 1),\n\t\t\tMask: net.CIDRMask(24, 32),\n\t\t},\n\t}\n\n\tif err = AddrAdd(link2, addr2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add default multipath route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(0, 0, 0, 0),\n\t\tMask: net.CIDRMask(0, 32),\n\t}\n\tgw1 := net.IPv4(192, 168, 1, 254)\n\tgw2 := net.IPv4(192, 168, 2, 254)\n\troute := Route{Dst: dst, MultiPath: []*NexthopInfo{{LinkIndex: link1.Attrs().Index,\n\t\tGw: gw1}, {LinkIndex: link2.Attrs().Index, Gw: gw2}}}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// check getting route from specified Oif\n\tdstIP := net.IPv4(10, 1, 1, 1)\n\troutes, err := RouteGetWithOptions(dstIP, &RouteGetOptions{Oif: \"eth0\"})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(routes) != 1 || routes[0].LinkIndex != link1.Attrs().Index ||\n\t\t!routes[0].Gw.Equal(gw1) {\n\t\tt.Fatal(\"Get route from unmatched interface\")\n\t}\n\n\troutes, err = RouteGetWithOptions(dstIP, &RouteGetOptions{Oif: \"eth1\"})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(routes) != 1 || routes[0].LinkIndex != link2.Attrs().Index ||\n\t\t!routes[0].Gw.Equal(gw2) {\n\t\tt.Fatal(\"Get route from unmatched interface\")\n\t}\n\n}\n\nfunc TestFilterDefaultRoute(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// bring the interface up\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\taddress := &Addr{\n\t\tIPNet: &net.IPNet{\n\t\t\tIP:   net.IPv4(127, 0, 0, 2),\n\t\t\tMask: net.CIDRMask(24, 32),\n\t\t},\n\t}\n\tif err = AddrAdd(link, address); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Add default route\n\tgw := net.IPv4(127, 0, 0, 2)\n\n\tdefaultRoute := Route{\n\t\tDst: nil,\n\t\tGw:  gw,\n\t}\n\n\tif err := RouteAdd(&defaultRoute); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add an extra route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\textraRoute := Route{\n\t\tDst: dst,\n\t\tGw:  gw,\n\t}\n\n\tif err := RouteAdd(&extraRoute); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar filterTests = []struct {\n\t\tfilter   *Route\n\t\tmask     uint64\n\t\texpected net.IP\n\t}{\n\t\t{\n\t\t\t&Route{Dst: nil},\n\t\t\tRT_FILTER_DST,\n\t\t\tgw,\n\t\t},\n\t\t{\n\t\t\t&Route{Dst: dst},\n\t\t\tRT_FILTER_DST,\n\t\t\tgw,\n\t\t},\n\t}\n\n\tfor _, f := range filterTests {\n\t\troutes, err := RouteListFiltered(FAMILY_V4, f.filter, f.mask)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(routes) != 1 {\n\t\t\tt.Fatal(\"Route not filtered properly\")\n\t\t}\n\t\tif !routes[0].Gw.Equal(gw) {\n\t\t\tt.Fatal(\"Unexpected Gateway\")\n\t\t}\n\t}\n\n}\n\nfunc TestMPLSRouteAddDel(t *testing.T) {\n\ttearDown := setUpMPLSNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmplsDst := 100\n\troute := Route{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tMPLSDst:   &mplsDst,\n\t\tNewDst: &MPLSDestination{\n\t\t\tLabels: []int{200, 300},\n\t\t},\n\t}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err := RouteList(link, FAMILY_MPLS)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\tif err := RouteDel(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_MPLS)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Route not removed properly\")\n\t}\n\n}\n\nfunc TestIP6tnlRouteAddDel(t *testing.T) {\n\t_, err := RouteList(nil, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, dst, err := net.ParseCIDR(\"192.168.99.0/24\")\n\tif err != nil {\n\t\tt.Fatalf(\"cannot parse destination prefix: %v\", err)\n\t}\n\n\tencap := IP6tnlEncap{\n\t\tDst: net.ParseIP(\"2001:db8::\"),\n\t\tSrc: net.ParseIP(\"::\"),\n\t}\n\n\troute := &Route{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tDst:       dst,\n\t\tEncap:     &encap,\n\t}\n\n\tif err := RouteAdd(route); err != nil {\n\t\tt.Fatalf(\"Cannot add route: %v\", err)\n\t}\n\troutes, err := RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\tif err := RouteDel(route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Route not removed properly\")\n\t}\n\n}\n\nfunc TestRouteEqual(t *testing.T) {\n\tmplsDst := 100\n\tseg6encap := &SEG6Encap{Mode: nl.SEG6_IPTUN_MODE_ENCAP}\n\tseg6encap.Segments = []net.IP{net.ParseIP(\"fc00:a000::11\")}\n\tcases := []Route{\n\t\t{\n\t\t\tDst: nil,\n\t\t\tGw:  net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 20,\n\t\t\tDst:       nil,\n\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tILinkIndex: 21,\n\t\t\tLinkIndex:  20,\n\t\t\tDst:        nil,\n\t\t\tGw:         net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 20,\n\t\t\tDst:       nil,\n\t\t\tProtocol:  20,\n\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 20,\n\t\t\tDst:       nil,\n\t\t\tPriority:  20,\n\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 20,\n\t\t\tDst:       nil,\n\t\t\tType:      20,\n\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 20,\n\t\t\tDst:       nil,\n\t\t\tTable:     200,\n\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 20,\n\t\t\tDst:       nil,\n\t\t\tTos:       1,\n\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 20,\n\t\t\tDst:       nil,\n\t\t\tHoplimit:  1,\n\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 20,\n\t\t\tDst:       nil,\n\t\t\tRealm:     29,\n\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 20,\n\t\t\tDst:       nil,\n\t\t\tFlags:     int(FLAG_ONLINK),\n\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 10,\n\t\t\tDst: &net.IPNet{\n\t\t\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\t\t\tMask: net.CIDRMask(24, 32),\n\t\t\t},\n\t\t\tSrc: net.IPv4(127, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 10,\n\t\t\tScope:     unix.RT_SCOPE_LINK,\n\t\t\tDst: &net.IPNet{\n\t\t\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\t\t\tMask: net.CIDRMask(24, 32),\n\t\t\t},\n\t\t\tSrc: net.IPv4(127, 1, 1, 1),\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 3,\n\t\t\tDst: &net.IPNet{\n\t\t\t\tIP:   net.IPv4(1, 1, 1, 1),\n\t\t\t\tMask: net.CIDRMask(32, 32),\n\t\t\t},\n\t\t\tSrc:      net.IPv4(127, 3, 3, 3),\n\t\t\tScope:    unix.RT_SCOPE_LINK,\n\t\t\tPriority: 13,\n\t\t\tTable:    unix.RT_TABLE_MAIN,\n\t\t\tType:     unix.RTN_UNICAST,\n\t\t\tTos:      12,\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 3,\n\t\t\tDst: &net.IPNet{\n\t\t\t\tIP:   net.IPv4(1, 1, 1, 1),\n\t\t\t\tMask: net.CIDRMask(32, 32),\n\t\t\t},\n\t\t\tSrc:      net.IPv4(127, 3, 3, 3),\n\t\t\tScope:    unix.RT_SCOPE_LINK,\n\t\t\tPriority: 13,\n\t\t\tTable:    unix.RT_TABLE_MAIN,\n\t\t\tType:     unix.RTN_UNICAST,\n\t\t\tHoplimit: 100,\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 3,\n\t\t\tDst: &net.IPNet{\n\t\t\t\tIP:   net.IPv4(1, 1, 1, 1),\n\t\t\t\tMask: net.CIDRMask(32, 32),\n\t\t\t},\n\t\t\tSrc:      net.IPv4(127, 3, 3, 3),\n\t\t\tScope:    unix.RT_SCOPE_LINK,\n\t\t\tPriority: 13,\n\t\t\tTable:    unix.RT_TABLE_MAIN,\n\t\t\tType:     unix.RTN_UNICAST,\n\t\t\tRealm:    129,\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 10,\n\t\t\tMPLSDst:   &mplsDst,\n\t\t\tNewDst: &MPLSDestination{\n\t\t\t\tLabels: []int{200, 300},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tDst: nil,\n\t\t\tGw:  net.IPv4(1, 1, 1, 1),\n\t\t\tEncap: &MPLSEncap{\n\t\t\t\tLabels: []int{100},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tLinkIndex: 10,\n\t\t\tDst: &net.IPNet{\n\t\t\t\tIP:   net.IPv4(10, 0, 0, 102),\n\t\t\t\tMask: net.CIDRMask(32, 32),\n\t\t\t},\n\t\t\tEncap: seg6encap,\n\t\t},\n\t\t{\n\t\t\tDst:       nil,\n\t\t\tMultiPath: []*NexthopInfo{{LinkIndex: 10}, {LinkIndex: 20}},\n\t\t},\n\t\t{\n\t\t\tDst: nil,\n\t\t\tMultiPath: []*NexthopInfo{{\n\t\t\t\tLinkIndex: 10,\n\t\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t\t}, {LinkIndex: 20}},\n\t\t},\n\t\t{\n\t\t\tDst: nil,\n\t\t\tMultiPath: []*NexthopInfo{{\n\t\t\t\tLinkIndex: 10,\n\t\t\t\tGw:        net.IPv4(1, 1, 1, 1),\n\t\t\t\tEncap: &MPLSEncap{\n\t\t\t\t\tLabels: []int{100},\n\t\t\t\t},\n\t\t\t}, {LinkIndex: 20}},\n\t\t},\n\t\t{\n\t\t\tDst: nil,\n\t\t\tMultiPath: []*NexthopInfo{{\n\t\t\t\tLinkIndex: 10,\n\t\t\t\tNewDst: &MPLSDestination{\n\t\t\t\t\tLabels: []int{200, 300},\n\t\t\t\t},\n\t\t\t}, {LinkIndex: 20}},\n\t\t},\n\t\t{\n\t\t\tDst: nil,\n\t\t\tMultiPath: []*NexthopInfo{{\n\t\t\t\tLinkIndex: 10,\n\t\t\t\tEncap:     seg6encap,\n\t\t\t}, {LinkIndex: 20}},\n\t\t},\n\t}\n\tfor i1 := range cases {\n\t\tfor i2 := range cases {\n\t\t\tgot := cases[i1].Equal(cases[i2])\n\t\t\texpected := i1 == i2\n\t\t\tif got != expected {\n\t\t\t\tt.Errorf(\"Equal(%q,%q) == %s but expected %s\",\n\t\t\t\t\tcases[i1], cases[i2],\n\t\t\t\t\tstrconv.FormatBool(got),\n\t\t\t\t\tstrconv.FormatBool(expected))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIPNetEqual(t *testing.T) {\n\tcases := []string{\n\t\t\"1.1.1.1/24\", \"1.1.1.0/24\", \"1.1.1.1/32\",\n\t\t\"0.0.0.0/0\", \"0.0.0.0/14\",\n\t\t\"2001:db8::/32\", \"2001:db8::/128\",\n\t\t\"2001:db8::caff/32\", \"2001:db8::caff/128\",\n\t\t\"\",\n\t}\n\tfor _, c1 := range cases {\n\t\tvar n1 *net.IPNet\n\t\tif c1 != \"\" {\n\t\t\tvar i1 net.IP\n\t\t\tvar err1 error\n\t\t\ti1, n1, err1 = net.ParseCIDR(c1)\n\t\t\tif err1 != nil {\n\t\t\t\tpanic(err1)\n\t\t\t}\n\t\t\tn1.IP = i1\n\t\t}\n\t\tfor _, c2 := range cases {\n\t\t\tvar n2 *net.IPNet\n\t\t\tif c2 != \"\" {\n\t\t\t\tvar i2 net.IP\n\t\t\t\tvar err2 error\n\t\t\t\ti2, n2, err2 = net.ParseCIDR(c2)\n\t\t\t\tif err2 != nil {\n\t\t\t\t\tpanic(err2)\n\t\t\t\t}\n\t\t\t\tn2.IP = i2\n\t\t\t}\n\n\t\t\tgot := ipNetEqual(n1, n2)\n\t\t\texpected := c1 == c2\n\t\t\tif got != expected {\n\t\t\t\tt.Errorf(\"IPNetEqual(%q,%q) == %s but expected %s\",\n\t\t\t\t\tc1, c2,\n\t\t\t\t\tstrconv.FormatBool(got),\n\t\t\t\t\tstrconv.FormatBool(expected))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSEG6LocalEqual(t *testing.T) {\n\t// Different attributes exists in different Actions. For example, Action\n\t// SEG6_LOCAL_ACTION_END_X has In6Addr, SEG6_LOCAL_ACTION_END_T has Table etc.\n\tsegs := []net.IP{net.ParseIP(\"fc00:a000::11\")}\n\t// set flags for each actions.\n\tvar flags_end [nl.SEG6_LOCAL_MAX]bool\n\tflags_end[nl.SEG6_LOCAL_ACTION] = true\n\tvar flags_end_x [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_x[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_x[nl.SEG6_LOCAL_NH6] = true\n\tvar flags_end_t [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_t[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_t[nl.SEG6_LOCAL_TABLE] = true\n\tvar flags_end_dx2 [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_dx2[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_dx2[nl.SEG6_LOCAL_OIF] = true\n\tvar flags_end_dx6 [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_dx6[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_dx6[nl.SEG6_LOCAL_NH6] = true\n\tvar flags_end_dx4 [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_dx4[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_dx4[nl.SEG6_LOCAL_NH4] = true\n\tvar flags_end_dt6 [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_dt6[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_dt6[nl.SEG6_LOCAL_TABLE] = true\n\tvar flags_end_dt4 [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_dt4[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_dt4[nl.SEG6_LOCAL_TABLE] = true\n\tvar flags_end_b6 [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_b6[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_b6[nl.SEG6_LOCAL_SRH] = true\n\tvar flags_end_b6_encaps [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_b6_encaps[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_b6_encaps[nl.SEG6_LOCAL_SRH] = true\n\tvar flags_end_bpf [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_bpf[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_bpf[nl.SEG6_LOCAL_BPF] = true\n\n\tcases := []SEG6LocalEncap{\n\t\t{\n\t\t\tFlags:  flags_end,\n\t\t\tAction: nl.SEG6_LOCAL_ACTION_END,\n\t\t},\n\t\t{\n\t\t\tFlags:   flags_end_x,\n\t\t\tAction:  nl.SEG6_LOCAL_ACTION_END_X,\n\t\t\tIn6Addr: net.ParseIP(\"2001:db8::1\"),\n\t\t},\n\t\t{\n\t\t\tFlags:  flags_end_t,\n\t\t\tAction: nl.SEG6_LOCAL_ACTION_END_T,\n\t\t\tTable:  10,\n\t\t},\n\t\t{\n\t\t\tFlags:  flags_end_dx2,\n\t\t\tAction: nl.SEG6_LOCAL_ACTION_END_DX2,\n\t\t\tOif:    20,\n\t\t},\n\t\t{\n\t\t\tFlags:   flags_end_dx6,\n\t\t\tAction:  nl.SEG6_LOCAL_ACTION_END_DX6,\n\t\t\tIn6Addr: net.ParseIP(\"2001:db8::1\"),\n\t\t},\n\t\t{\n\t\t\tFlags:  flags_end_dx4,\n\t\t\tAction: nl.SEG6_LOCAL_ACTION_END_DX4,\n\t\t\tInAddr: net.IPv4(192, 168, 10, 10),\n\t\t},\n\t\t{\n\t\t\tFlags:  flags_end_dt6,\n\t\t\tAction: nl.SEG6_LOCAL_ACTION_END_DT6,\n\t\t\tTable:  30,\n\t\t},\n\t\t{\n\t\t\tFlags:  flags_end_dt4,\n\t\t\tAction: nl.SEG6_LOCAL_ACTION_END_DT4,\n\t\t\tTable:  40,\n\t\t},\n\t\t{\n\t\t\tFlags:    flags_end_b6,\n\t\t\tAction:   nl.SEG6_LOCAL_ACTION_END_B6,\n\t\t\tSegments: segs,\n\t\t},\n\t\t{\n\t\t\tFlags:    flags_end_b6_encaps,\n\t\t\tAction:   nl.SEG6_LOCAL_ACTION_END_B6_ENCAPS,\n\t\t\tSegments: segs,\n\t\t},\n\t}\n\n\t// SEG6_LOCAL_ACTION_END_BPF\n\tendBpf := SEG6LocalEncap{\n\t\tFlags:  flags_end_bpf,\n\t\tAction: nl.SEG6_LOCAL_ACTION_END_BPF,\n\t}\n\t_ = endBpf.SetProg(1, \"firewall\")\n\tcases = append(cases, endBpf)\n\n\tfor i1 := range cases {\n\t\tfor i2 := range cases {\n\t\t\tgot := cases[i1].Equal(&cases[i2])\n\t\t\texpected := i1 == i2\n\t\t\tif got != expected {\n\t\t\t\tt.Errorf(\"Equal(%v,%v) == %s but expected %s\",\n\t\t\t\t\tcases[i1], cases[i2],\n\t\t\t\t\tstrconv.FormatBool(got),\n\t\t\t\t\tstrconv.FormatBool(expected))\n\t\t\t}\n\t\t}\n\t}\n}\nfunc TestSEG6RouteAddDel(t *testing.T) {\n\tif os.Getenv(\"CI\") == \"true\" {\n\t\tt.Skipf(\"Fails in CI with: route_test.go:*: Invalid Type. SEG6_IPTUN_MODE_INLINE routes not added properly\")\n\t}\n\t// add/del routes with LWTUNNEL_SEG6 to/from loopback interface.\n\t// Test both seg6 modes: encap (IPv4) & inline (IPv6).\n\ttearDown := setUpSEG6NetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface and bring it up\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst1 := &net.IPNet{ // INLINE mode must be IPv6 route\n\t\tIP:   net.ParseIP(\"2001:db8::1\"),\n\t\tMask: net.CIDRMask(128, 128),\n\t}\n\tdst2 := &net.IPNet{\n\t\tIP:   net.IPv4(10, 0, 0, 102),\n\t\tMask: net.CIDRMask(32, 32),\n\t}\n\tvar s1, s2 []net.IP\n\ts1 = append(s1, net.ParseIP(\"::\")) // inline requires \"::\"\n\ts1 = append(s1, net.ParseIP(\"fc00:a000::12\"))\n\ts1 = append(s1, net.ParseIP(\"fc00:a000::11\"))\n\ts2 = append(s2, net.ParseIP(\"fc00:a000::22\"))\n\ts2 = append(s2, net.ParseIP(\"fc00:a000::21\"))\n\te1 := &SEG6Encap{Mode: nl.SEG6_IPTUN_MODE_INLINE}\n\te2 := &SEG6Encap{Mode: nl.SEG6_IPTUN_MODE_ENCAP}\n\te1.Segments = s1\n\te2.Segments = s2\n\troute1 := Route{LinkIndex: link.Attrs().Index, Dst: dst1, Encap: e1}\n\troute2 := Route{LinkIndex: link.Attrs().Index, Dst: dst2, Encap: e2}\n\n\t// Add SEG6 routes\n\tif err := RouteAdd(&route1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := RouteAdd(&route2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// SEG6_IPTUN_MODE_INLINE\n\troutes, err := RouteList(link, FAMILY_V6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"SEG6 routes not added properly\")\n\t}\n\tfor _, route := range routes {\n\t\tif route.Encap == nil || route.Encap.Type() != nl.LWTUNNEL_ENCAP_SEG6 {\n\t\t\tt.Fatal(\"Invalid Type. SEG6_IPTUN_MODE_INLINE routes not added properly\")\n\t\t}\n\t}\n\t// SEG6_IPTUN_MODE_ENCAP\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"SEG6 routes not added properly\")\n\t}\n\tfor _, route := range routes {\n\t\tif route.Encap.Type() != nl.LWTUNNEL_ENCAP_SEG6 {\n\t\t\tt.Fatal(\"Invalid Type. SEG6_IPTUN_MODE_ENCAP routes not added properly\")\n\t\t}\n\t}\n\n\t// Del (remove) SEG6 routes\n\tif err := RouteDel(&route1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := RouteDel(&route2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"SEG6 routes not removed properly\")\n\t}\n}\n\n// add/del routes with LWTUNNEL_ENCAP_SEG6_LOCAL to/from dummy interface.\nfunc TestSEG6LocalRoute6AddDel(t *testing.T) {\n\tminKernelRequired(t, 4, 14)\n\ttearDown := setUpSEG6NetlinkTest(t)\n\tdefer tearDown()\n\n\t// create dummy interface\n\t// IPv6 route added to loopback interface will be unreachable\n\tla := NewLinkAttrs()\n\tla.Name = \"dummy_route6\"\n\tla.TxQLen = 1500\n\tdummy := &Dummy{LinkAttrs: la}\n\tif err := LinkAdd(dummy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// get dummy interface and bring it up\n\tlink, err := LinkByName(\"dummy_route6\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst1 := &net.IPNet{\n\t\tIP:   net.ParseIP(\"2001:db8::1\"),\n\t\tMask: net.CIDRMask(128, 128),\n\t}\n\n\t// Create Route including Action SEG6_LOCAL_ACTION_END_B6.\n\t// Could be any Action but thought better to have seg list.\n\tvar s1 []net.IP\n\ts1 = append(s1, net.ParseIP(\"fc00:a000::12\"))\n\ts1 = append(s1, net.ParseIP(\"fc00:a000::11\"))\n\tvar flags_end_b6_encaps [nl.SEG6_LOCAL_MAX]bool\n\tflags_end_b6_encaps[nl.SEG6_LOCAL_ACTION] = true\n\tflags_end_b6_encaps[nl.SEG6_LOCAL_SRH] = true\n\te1 := &SEG6LocalEncap{\n\t\tFlags:    flags_end_b6_encaps,\n\t\tAction:   nl.SEG6_LOCAL_ACTION_END_B6,\n\t\tSegments: s1,\n\t}\n\troute1 := Route{LinkIndex: link.Attrs().Index, Dst: dst1, Encap: e1}\n\n\t// Add SEG6Local routes\n\tif err := RouteAdd(&route1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// typically one route (fe80::/64) will be created when dummy_route6 is created.\n\t// Thus you cannot use RouteList() to find the route entry just added.\n\t// Lookup route and confirm it's SEG6Local route just added.\n\troutesFound, err := RouteGet(dst1.IP)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routesFound) != 1 { // should only find 1 route entry\n\t\tt.Fatal(\"SEG6Local route not added correctly\")\n\t}\n\tif !e1.Equal(routesFound[0].Encap) {\n\t\tt.Fatal(\"Encap does not match the original SEG6LocalEncap\")\n\t}\n\n\t// Del SEG6Local routes\n\tif err := RouteDel(&route1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Confirm route is deleted.\n\tif _, err = RouteGet(dst1.IP); err == nil {\n\t\tt.Fatal(\"SEG6Local route still exists.\")\n\t}\n\n\t// cleanup dummy interface created for the test\n\tif err := LinkDel(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBpfEncap(t *testing.T) {\n\ttCase := &BpfEncap{}\n\tif err := tCase.SetProg(nl.LWT_BPF_IN, 0, \"test_in\"); err == nil {\n\t\tt.Fatal(\"BpfEncap: inserting invalid FD did not return error\")\n\t}\n\tif err := tCase.SetProg(nl.LWT_BPF_XMIT_HEADROOM, 23, \"test_nout\"); err == nil {\n\t\tt.Fatal(\"BpfEncap: inserting invalid mode did not return error\")\n\t}\n\tif err := tCase.SetProg(nl.LWT_BPF_XMIT, 12, \"test_xmit\"); err != nil {\n\t\tt.Fatal(\"BpfEncap: inserting valid program option returned error\")\n\t}\n\tif err := tCase.SetXmitHeadroom(12); err != nil {\n\t\tt.Fatal(\"BpfEncap: inserting valid headroom returned error\")\n\t}\n\tif err := tCase.SetXmitHeadroom(nl.LWT_BPF_MAX_HEADROOM + 1); err == nil {\n\t\tt.Fatal(\"BpfEncap: inserting invalid headroom did not return error\")\n\t}\n\ttCase = &BpfEncap{}\n\n\texpected := &BpfEncap{\n\t\tprogs: [nl.LWT_BPF_MAX]bpfObj{\n\t\t\t1: {\n\t\t\t\tprogName: \"test_in[fd:10]\",\n\t\t\t\tprogFd:   10,\n\t\t\t},\n\t\t\t2: {\n\t\t\t\tprogName: \"test_out[fd:11]\",\n\t\t\t\tprogFd:   11,\n\t\t\t},\n\t\t\t3: {\n\t\t\t\tprogName: \"test_xmit[fd:21]\",\n\t\t\t\tprogFd:   21,\n\t\t\t},\n\t\t},\n\t\theadroom: 128,\n\t}\n\n\t_ = tCase.SetProg(1, 10, \"test_in\")\n\t_ = tCase.SetProg(2, 11, \"test_out\")\n\t_ = tCase.SetProg(3, 21, \"test_xmit\")\n\t_ = tCase.SetXmitHeadroom(128)\n\tif !tCase.Equal(expected) {\n\t\tt.Fatal(\"BpfEncap: equal comparison failed\")\n\t}\n\t_ = tCase.SetProg(3, 21, \"test2_xmit\")\n\tif tCase.Equal(expected) {\n\t\tt.Fatal(\"BpfEncap: equal comparison succeeded when attributes differ\")\n\t}\n}\n\nfunc TestMTURouteAddDel(t *testing.T) {\n\t_, err := RouteList(nil, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// get loopback interface\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// bring the interface up\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add a gateway route\n\tdst := &net.IPNet{\n\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\tMask: net.CIDRMask(24, 32),\n\t}\n\n\troute := Route{LinkIndex: link.Attrs().Index, Dst: dst, MTU: 500}\n\tif err := RouteAdd(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err := RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\tif route.MTU != routes[0].MTU {\n\t\tt.Fatal(\"Route mtu not set properly\")\n\t}\n\n\tif err := RouteDel(&route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Route not removed properly\")\n\t}\n}\n\nfunc TestRouteViaAddDel(t *testing.T) {\n\tminKernelRequired(t, 5, 4)\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t_, err := RouteList(nil, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlink, err := LinkByName(\"lo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\troute := &Route{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tDst: &net.IPNet{\n\t\t\tIP:   net.IPv4(192, 168, 0, 0),\n\t\t\tMask: net.CIDRMask(24, 32),\n\t\t},\n\t\tMultiPath: []*NexthopInfo{\n\t\t\t{\n\t\t\t\tLinkIndex: link.Attrs().Index,\n\t\t\t\tVia: &Via{\n\t\t\t\t\tAddrFamily: FAMILY_V6,\n\t\t\t\t\tAddr:       net.ParseIP(\"2001::1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := RouteAdd(route); err != nil {\n\t\tt.Fatalf(\"route: %v, err: %v\", route, err)\n\t}\n\n\troutes, err := RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 {\n\t\tt.Fatal(\"Route not added properly\")\n\t}\n\n\tgot := routes[0].Via\n\twant := route.MultiPath[0].Via\n\tif !want.Equal(got) {\n\t\tt.Fatalf(\"Route Via attribute does not match; got: %s, want: %s\", got, want)\n\t}\n\n\tif err := RouteDel(route); err != nil {\n\t\tt.Fatal(err)\n\t}\n\troutes, err = RouteList(link, FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 0 {\n\t\tt.Fatal(\"Route not removed properly\")\n\t}\n}\n\nfunc TestRouteUIDOption(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// setup eth0 so that network is reachable\n\terr := LinkAdd(&Dummy{LinkAttrs{Name: \"eth0\"}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"eth0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\taddr := &Addr{\n\t\tIPNet: &net.IPNet{\n\t\t\tIP:   net.IPv4(192, 168, 1, 1),\n\t\t\tMask: net.CIDRMask(16, 32),\n\t\t},\n\t}\n\tif err = AddrAdd(link, addr); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// a table different than unix.RT_TABLE_MAIN\n\ttesttable := 1000\n\n\tgw1 := net.IPv4(192, 168, 1, 254)\n\tgw2 := net.IPv4(192, 168, 2, 254)\n\n\t// add default route via gw1 (in main route table by default)\n\tdefaultRouteMain := Route{\n\t\tDst: nil,\n\t\tGw:  gw1,\n\t}\n\tif err := RouteAdd(&defaultRouteMain); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add default route via gw2 in test route table\n\tdefaultRouteTest := Route{\n\t\tDst:   nil,\n\t\tGw:    gw2,\n\t\tTable: testtable,\n\t}\n\tif err := RouteAdd(&defaultRouteTest); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// check the routes are in different tables\n\troutes, err := RouteListFiltered(FAMILY_V4, &Route{\n\t\tDst:   nil,\n\t\tTable: unix.RT_TABLE_UNSPEC,\n\t}, RT_FILTER_DST|RT_FILTER_TABLE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 2 || routes[0].Table == routes[1].Table {\n\t\tt.Fatal(\"Routes not added properly\")\n\t}\n\n\t// add a rule that uidrange match should result in route lookup of test table for uid other than current\n\t// current uid is 0 due to skipUnlessRoot()\n\tvar uid uint32 = 1000\n\trule := NewRule()\n\trule.UIDRange = NewRuleUIDRange(uid, uid)\n\trule.Table = testtable\n\tif err := RuleAdd(rule); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdstIP := net.IPv4(10, 1, 1, 1)\n\n\t// check getting route without UID option\n\troutes, err = RouteGetWithOptions(dstIP, &RouteGetOptions{UID: nil})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// current uid is outside uidrange; rule does not apply; lookup main table\n\tif len(routes) != 1 || !routes[0].Gw.Equal(gw1) {\n\t\tt.Fatal(routes)\n\t}\n\n\t// check getting route with UID option\n\troutes, err = RouteGetWithOptions(dstIP, &RouteGetOptions{UID: &uid})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// option uid is within uidrange; rule applies; lookup test table\n\tif len(routes) != 1 || !routes[0].Gw.Equal(gw2) {\n\t\tt.Fatal(routes)\n\t}\n}\n\nfunc TestRouteFWMarkOption(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\t// setup eth0 so that network is reachable\n\terr := LinkAdd(&Dummy{LinkAttrs{Name: \"eth0\"}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"eth0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\taddr := &Addr{\n\t\tIPNet: &net.IPNet{\n\t\t\tIP:   net.IPv4(192, 168, 1, 1),\n\t\t\tMask: net.CIDRMask(16, 32),\n\t\t},\n\t}\n\tif err = AddrAdd(link, addr); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// a table different than unix.RT_TABLE_MAIN\n\ttestTable0 := 254\n\ttestTable1 := 1000\n\ttestTable2 := 1001\n\n\tgw0 := net.IPv4(192, 168, 1, 254)\n\tgw1 := net.IPv4(192, 168, 2, 254)\n\tgw2 := net.IPv4(192, 168, 3, 254)\n\n\t// add default route via gw0 (in main route table by default)\n\tdefaultRouteMain := Route{\n\t\tDst:   nil,\n\t\tGw:    gw0,\n\t\tTable: testTable0,\n\t}\n\tif err := RouteAdd(&defaultRouteMain); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add default route via gw1 in test route table\n\tdefaultRouteTest1 := Route{\n\t\tDst:   nil,\n\t\tGw:    gw1,\n\t\tTable: testTable1,\n\t}\n\tif err := RouteAdd(&defaultRouteTest1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// add default route via gw2 in test route table\n\tdefaultRouteTest2 := Route{\n\t\tDst:   nil,\n\t\tGw:    gw2,\n\t\tTable: testTable2,\n\t}\n\tif err := RouteAdd(&defaultRouteTest2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// check the routes are in different tables\n\troutes, err := RouteListFiltered(FAMILY_V4, &Route{\n\t\tDst:   nil,\n\t\tTable: unix.RT_TABLE_UNSPEC,\n\t}, RT_FILTER_DST|RT_FILTER_TABLE)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 3 || routes[0].Table == routes[1].Table || routes[1].Table == routes[2].Table ||\n\t\troutes[0].Table == routes[2].Table {\n\t\tt.Fatal(\"Routes not added properly\")\n\t}\n\n\t// add a rule that fwmark match should result in route lookup of test table\n\tfwmark1 := uint32(0xAFFFFFFF)\n\tfwmark2 := uint32(0xBFFFFFFF)\n\n\trule := NewRule()\n\trule.Mark = fwmark1\n\trule.Mask = &[]uint32{0xFFFFFFFF}[0]\n\n\trule.Table = testTable1\n\tif err := RuleAdd(rule); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trule = NewRule()\n\trule.Mark = fwmark2\n\trule.Mask = &[]uint32{0xFFFFFFFF}[0]\n\trule.Table = testTable2\n\tif err := RuleAdd(rule); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trules, err := RuleListFiltered(FAMILY_V4, &Rule{Mark: fwmark1}, RT_FILTER_MARK)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(rules) != 1 || rules[0].Table != testTable1 || rules[0].Mark != fwmark1 {\n\t\tt.Fatal(\"Rules not added properly\")\n\t}\n\n\trules, err = RuleListFiltered(FAMILY_V4, &Rule{Mark: fwmark2}, RT_FILTER_MARK)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(rules) != 1 || rules[0].Table != testTable2 || rules[0].Mark != fwmark2 {\n\t\tt.Fatal(\"Rules not added properly\")\n\t}\n\n\tdstIP := net.IPv4(10, 1, 1, 1)\n\n\t// check getting route without FWMark option\n\troutes, err = RouteGetWithOptions(dstIP, &RouteGetOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 || !routes[0].Gw.Equal(gw0) {\n\t\tt.Fatal(routes)\n\t}\n\n\t// check getting route with FWMark option\n\troutes, err = RouteGetWithOptions(dstIP, &RouteGetOptions{Mark: fwmark1})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 || !routes[0].Gw.Equal(gw1) {\n\t\tt.Fatal(routes)\n\t}\n\n\t// check getting route with FWMark option\n\troutes, err = RouteGetWithOptions(dstIP, &RouteGetOptions{Mark: fwmark2})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(routes) != 1 || !routes[0].Gw.Equal(gw2) {\n\t\tt.Fatal(routes)\n\t}\n}\n\nfunc TestRouteGetFIBMatchOption(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\terr := LinkAdd(&Dummy{LinkAttrs{Name: \"eth0\"}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlink, err := LinkByName(\"eth0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = LinkSetUp(link); err != nil {\n\t\tt.Fatal(err)\n\t}\n\taddr := &Addr{\n\t\tIPNet: &net.IPNet{\n\t\t\tIP:   net.IPv4(192, 168, 0, 2),\n\t\t\tMask: net.CIDRMask(24, 32),\n\t\t},\n\t}\n\tif err = AddrAdd(link, addr); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\troute := &Route{\n\t\tLinkIndex: link.Attrs().Index,\n\t\tGw:        net.IPv4(192, 168, 1, 1),\n\t\tDst: &net.IPNet{\n\t\t\tIP:   net.IPv4(192, 168, 2, 0),\n\t\t\tMask: net.CIDRMask(24, 32),\n\t\t},\n\t\tFlags: int(FLAG_ONLINK),\n\t}\n\n\terr = RouteAdd(route)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\troutes, err := RouteGetWithOptions(net.IPv4(192, 168, 2, 1), &RouteGetOptions{FIBMatch: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(routes) != 1 {\n\t\tt.Fatalf(\"More than one route matched %v\", routes)\n\t}\n\n\tif len(routes[0].ListFlags()) != 1 {\n\t\tt.Fatalf(\"More than one route flag returned %v\", routes[0].ListFlags())\n\t}\n\n\tflag := routes[0].ListFlags()[0]\n\tif flag != \"onlink\" {\n\t\tt.Fatalf(\"Unexpected flag %s returned\", flag)\n\t}\n}\n"
        },
        {
          "name": "route_unspecified.go",
          "type": "blob",
          "size": 0.2998046875,
          "content": "// +build !linux\n\npackage netlink\n\nimport \"strconv\"\n\nfunc (r *Route) ListFlags() []string {\n\treturn []string{}\n}\n\nfunc (n *NexthopInfo) ListFlags() []string {\n\treturn []string{}\n}\n\nfunc (s Scope) String() string {\n\treturn \"unknown\"\n}\n\nfunc (p RouteProtocol) String() string {\n\treturn strconv.Itoa(int(p))\n}\n"
        },
        {
          "name": "rule.go",
          "type": "blob",
          "size": 1.72265625,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\n// Rule represents a netlink rule.\ntype Rule struct {\n\tPriority          int\n\tFamily            int\n\tTable             int\n\tMark              uint32\n\tMask              *uint32\n\tTos               uint\n\tTunID             uint\n\tGoto              int\n\tSrc               *net.IPNet\n\tDst               *net.IPNet\n\tFlow              int\n\tIifName           string\n\tOifName           string\n\tSuppressIfgroup   int\n\tSuppressPrefixlen int\n\tInvert            bool\n\tDport             *RulePortRange\n\tSport             *RulePortRange\n\tIPProto           int\n\tUIDRange          *RuleUIDRange\n\tProtocol          uint8\n\tType              uint8\n}\n\nfunc (r Rule) String() string {\n\tfrom := \"all\"\n\tif r.Src != nil && r.Src.String() != \"<nil>\" {\n\t\tfrom = r.Src.String()\n\t}\n\n\tto := \"all\"\n\tif r.Dst != nil && r.Dst.String() != \"<nil>\" {\n\t\tto = r.Dst.String()\n\t}\n\n\treturn fmt.Sprintf(\"ip rule %d: from %s to %s table %d %s\",\n\t\tr.Priority, from, to, r.Table, r.typeString())\n}\n\n// NewRule return empty rules.\nfunc NewRule() *Rule {\n\treturn &Rule{\n\t\tSuppressIfgroup:   -1,\n\t\tSuppressPrefixlen: -1,\n\t\tPriority:          -1,\n\t\tMark:              0,\n\t\tMask:              nil,\n\t\tGoto:              -1,\n\t\tFlow:              -1,\n\t}\n}\n\n// NewRulePortRange creates rule sport/dport range.\nfunc NewRulePortRange(start, end uint16) *RulePortRange {\n\treturn &RulePortRange{Start: start, End: end}\n}\n\n// RulePortRange represents rule sport/dport range.\ntype RulePortRange struct {\n\tStart uint16\n\tEnd   uint16\n}\n\n// NewRuleUIDRange creates rule uid range.\nfunc NewRuleUIDRange(start, end uint32) *RuleUIDRange {\n\treturn &RuleUIDRange{Start: start, End: end}\n}\n\n// RuleUIDRange represents rule uid range.\ntype RuleUIDRange struct {\n\tStart uint32\n\tEnd   uint32\n}\n"
        },
        {
          "name": "rule_linux.go",
          "type": "blob",
          "size": 10.2255859375,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst FibRuleInvert = 0x2\n\n// RuleAdd adds a rule to the system.\n// Equivalent to: ip rule add\nfunc RuleAdd(rule *Rule) error {\n\treturn pkgHandle.RuleAdd(rule)\n}\n\n// RuleAdd adds a rule to the system.\n// Equivalent to: ip rule add\nfunc (h *Handle) RuleAdd(rule *Rule) error {\n\treq := h.newNetlinkRequest(unix.RTM_NEWRULE, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\treturn ruleHandle(rule, req)\n}\n\n// RuleDel deletes a rule from the system.\n// Equivalent to: ip rule del\nfunc RuleDel(rule *Rule) error {\n\treturn pkgHandle.RuleDel(rule)\n}\n\n// RuleDel deletes a rule from the system.\n// Equivalent to: ip rule del\nfunc (h *Handle) RuleDel(rule *Rule) error {\n\treq := h.newNetlinkRequest(unix.RTM_DELRULE, unix.NLM_F_ACK)\n\treturn ruleHandle(rule, req)\n}\n\nfunc ruleHandle(rule *Rule, req *nl.NetlinkRequest) error {\n\tmsg := nl.NewRtMsg()\n\tmsg.Family = unix.AF_INET\n\tmsg.Protocol = unix.RTPROT_BOOT\n\tmsg.Scope = unix.RT_SCOPE_UNIVERSE\n\tmsg.Table = unix.RT_TABLE_UNSPEC\n\tmsg.Type = rule.Type // usually 0, same as unix.RTN_UNSPEC\n\tif msg.Type == 0 && req.NlMsghdr.Flags&unix.NLM_F_CREATE > 0 {\n\t\tmsg.Type = unix.RTN_UNICAST\n\t}\n\tif rule.Invert {\n\t\tmsg.Flags |= FibRuleInvert\n\t}\n\tif rule.Family != 0 {\n\t\tmsg.Family = uint8(rule.Family)\n\t}\n\tif rule.Table >= 0 && rule.Table < 256 {\n\t\tmsg.Table = uint8(rule.Table)\n\t}\n\tif rule.Tos != 0 {\n\t\tmsg.Tos = uint8(rule.Tos)\n\t}\n\n\tvar dstFamily uint8\n\tvar rtAttrs []*nl.RtAttr\n\tif rule.Dst != nil && rule.Dst.IP != nil {\n\t\tdstLen, _ := rule.Dst.Mask.Size()\n\t\tmsg.Dst_len = uint8(dstLen)\n\t\tmsg.Family = uint8(nl.GetIPFamily(rule.Dst.IP))\n\t\tdstFamily = msg.Family\n\t\tvar dstData []byte\n\t\tif msg.Family == unix.AF_INET {\n\t\t\tdstData = rule.Dst.IP.To4()\n\t\t} else {\n\t\t\tdstData = rule.Dst.IP.To16()\n\t\t}\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_DST, dstData))\n\t}\n\n\tif rule.Src != nil && rule.Src.IP != nil {\n\t\tmsg.Family = uint8(nl.GetIPFamily(rule.Src.IP))\n\t\tif dstFamily != 0 && dstFamily != msg.Family {\n\t\t\treturn fmt.Errorf(\"source and destination ip are not the same IP family\")\n\t\t}\n\t\tsrcLen, _ := rule.Src.Mask.Size()\n\t\tmsg.Src_len = uint8(srcLen)\n\t\tvar srcData []byte\n\t\tif msg.Family == unix.AF_INET {\n\t\t\tsrcData = rule.Src.IP.To4()\n\t\t} else {\n\t\t\tsrcData = rule.Src.IP.To16()\n\t\t}\n\t\trtAttrs = append(rtAttrs, nl.NewRtAttr(unix.RTA_SRC, srcData))\n\t}\n\n\treq.AddData(msg)\n\tfor i := range rtAttrs {\n\t\treq.AddData(rtAttrs[i])\n\t}\n\n\tif rule.Priority >= 0 {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(rule.Priority))\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_PRIORITY, b))\n\t}\n\tif rule.Mark != 0 || rule.Mask != nil {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, rule.Mark)\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_FWMARK, b))\n\t}\n\tif rule.Mask != nil {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, *rule.Mask)\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_FWMASK, b))\n\t}\n\tif rule.Flow >= 0 {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(rule.Flow))\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_FLOW, b))\n\t}\n\tif rule.TunID > 0 {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(rule.TunID))\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_TUN_ID, b))\n\t}\n\tif rule.Table >= 256 {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(rule.Table))\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_TABLE, b))\n\t}\n\tif msg.Table > 0 {\n\t\tif rule.SuppressPrefixlen >= 0 {\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, uint32(rule.SuppressPrefixlen))\n\t\t\treq.AddData(nl.NewRtAttr(nl.FRA_SUPPRESS_PREFIXLEN, b))\n\t\t}\n\t\tif rule.SuppressIfgroup >= 0 {\n\t\t\tb := make([]byte, 4)\n\t\t\tnative.PutUint32(b, uint32(rule.SuppressIfgroup))\n\t\t\treq.AddData(nl.NewRtAttr(nl.FRA_SUPPRESS_IFGROUP, b))\n\t\t}\n\t}\n\tif rule.IifName != \"\" {\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_IIFNAME, []byte(rule.IifName+\"\\x00\")))\n\t}\n\tif rule.OifName != \"\" {\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_OIFNAME, []byte(rule.OifName+\"\\x00\")))\n\t}\n\tif rule.Goto >= 0 {\n\t\tmsg.Type = nl.FR_ACT_GOTO\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(rule.Goto))\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_GOTO, b))\n\t}\n\n\tif rule.IPProto > 0 {\n\t\tb := make([]byte, 4)\n\t\tnative.PutUint32(b, uint32(rule.IPProto))\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_IP_PROTO, b))\n\t}\n\n\tif rule.Dport != nil {\n\t\tb := rule.Dport.toRtAttrData()\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_DPORT_RANGE, b))\n\t}\n\n\tif rule.Sport != nil {\n\t\tb := rule.Sport.toRtAttrData()\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_SPORT_RANGE, b))\n\t}\n\n\tif rule.UIDRange != nil {\n\t\tb := rule.UIDRange.toRtAttrData()\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_UID_RANGE, b))\n\t}\n\n\tif rule.Protocol > 0 {\n\t\treq.AddData(nl.NewRtAttr(nl.FRA_PROTOCOL, nl.Uint8Attr(rule.Protocol)))\n\t}\n\n\t_, err := req.Execute(unix.NETLINK_ROUTE, 0)\n\treturn err\n}\n\n// RuleList lists rules in the system.\n// Equivalent to: ip rule list\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc RuleList(family int) ([]Rule, error) {\n\treturn pkgHandle.RuleList(family)\n}\n\n// RuleList lists rules in the system.\n// Equivalent to: ip rule list\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) RuleList(family int) ([]Rule, error) {\n\treturn h.RuleListFiltered(family, nil, 0)\n}\n\n// RuleListFiltered gets a list of rules in the system filtered by the\n// specified rule template `filter`.\n// Equivalent to: ip rule list\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc RuleListFiltered(family int, filter *Rule, filterMask uint64) ([]Rule, error) {\n\treturn pkgHandle.RuleListFiltered(family, filter, filterMask)\n}\n\n// RuleListFiltered lists rules in the system.\n// Equivalent to: ip rule list\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) RuleListFiltered(family int, filter *Rule, filterMask uint64) ([]Rule, error) {\n\treq := h.newNetlinkRequest(unix.RTM_GETRULE, unix.NLM_F_DUMP|unix.NLM_F_REQUEST)\n\tmsg := nl.NewIfInfomsg(family)\n\treq.AddData(msg)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_ROUTE, unix.RTM_NEWRULE)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res = make([]Rule, 0)\n\tfor i := range msgs {\n\t\tmsg := nl.DeserializeRtMsg(msgs[i])\n\t\tattrs, err := nl.ParseRouteAttr(msgs[i][msg.Len():])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\trule := NewRule()\n\t\trule.Priority = 0 // The default priority from kernel\n\n\t\trule.Invert = msg.Flags&FibRuleInvert > 0\n\t\trule.Family = int(msg.Family)\n\t\trule.Tos = uint(msg.Tos)\n\n\t\tfor j := range attrs {\n\t\t\tswitch attrs[j].Attr.Type {\n\t\t\tcase unix.RTA_TABLE:\n\t\t\t\trule.Table = int(native.Uint32(attrs[j].Value[0:4]))\n\t\t\tcase nl.FRA_SRC:\n\t\t\t\trule.Src = &net.IPNet{\n\t\t\t\t\tIP:   attrs[j].Value,\n\t\t\t\t\tMask: net.CIDRMask(int(msg.Src_len), 8*len(attrs[j].Value)),\n\t\t\t\t}\n\t\t\tcase nl.FRA_DST:\n\t\t\t\trule.Dst = &net.IPNet{\n\t\t\t\t\tIP:   attrs[j].Value,\n\t\t\t\t\tMask: net.CIDRMask(int(msg.Dst_len), 8*len(attrs[j].Value)),\n\t\t\t\t}\n\t\t\tcase nl.FRA_FWMARK:\n\t\t\t\trule.Mark = native.Uint32(attrs[j].Value[0:4])\n\t\t\tcase nl.FRA_FWMASK:\n\t\t\t\tmask := native.Uint32(attrs[j].Value[0:4])\n\t\t\t\trule.Mask = &mask\n\t\t\tcase nl.FRA_TUN_ID:\n\t\t\t\trule.TunID = uint(native.Uint64(attrs[j].Value[0:8]))\n\t\t\tcase nl.FRA_IIFNAME:\n\t\t\t\trule.IifName = string(attrs[j].Value[:len(attrs[j].Value)-1])\n\t\t\tcase nl.FRA_OIFNAME:\n\t\t\t\trule.OifName = string(attrs[j].Value[:len(attrs[j].Value)-1])\n\t\t\tcase nl.FRA_SUPPRESS_PREFIXLEN:\n\t\t\t\ti := native.Uint32(attrs[j].Value[0:4])\n\t\t\t\tif i != 0xffffffff {\n\t\t\t\t\trule.SuppressPrefixlen = int(i)\n\t\t\t\t}\n\t\t\tcase nl.FRA_SUPPRESS_IFGROUP:\n\t\t\t\ti := native.Uint32(attrs[j].Value[0:4])\n\t\t\t\tif i != 0xffffffff {\n\t\t\t\t\trule.SuppressIfgroup = int(i)\n\t\t\t\t}\n\t\t\tcase nl.FRA_FLOW:\n\t\t\t\trule.Flow = int(native.Uint32(attrs[j].Value[0:4]))\n\t\t\tcase nl.FRA_GOTO:\n\t\t\t\trule.Goto = int(native.Uint32(attrs[j].Value[0:4]))\n\t\t\tcase nl.FRA_PRIORITY:\n\t\t\t\trule.Priority = int(native.Uint32(attrs[j].Value[0:4]))\n\t\t\tcase nl.FRA_IP_PROTO:\n\t\t\t\trule.IPProto = int(native.Uint32(attrs[j].Value[0:4]))\n\t\t\tcase nl.FRA_DPORT_RANGE:\n\t\t\t\trule.Dport = NewRulePortRange(native.Uint16(attrs[j].Value[0:2]), native.Uint16(attrs[j].Value[2:4]))\n\t\t\tcase nl.FRA_SPORT_RANGE:\n\t\t\t\trule.Sport = NewRulePortRange(native.Uint16(attrs[j].Value[0:2]), native.Uint16(attrs[j].Value[2:4]))\n\t\t\tcase nl.FRA_UID_RANGE:\n\t\t\t\trule.UIDRange = NewRuleUIDRange(native.Uint32(attrs[j].Value[0:4]), native.Uint32(attrs[j].Value[4:8]))\n\t\t\tcase nl.FRA_PROTOCOL:\n\t\t\t\trule.Protocol = uint8(attrs[j].Value[0])\n\t\t\t}\n\t\t}\n\n\t\tif filter != nil {\n\t\t\tswitch {\n\t\t\tcase filterMask&RT_FILTER_SRC != 0 &&\n\t\t\t\t(rule.Src == nil || rule.Src.String() != filter.Src.String()):\n\t\t\t\tcontinue\n\t\t\tcase filterMask&RT_FILTER_DST != 0 &&\n\t\t\t\t(rule.Dst == nil || rule.Dst.String() != filter.Dst.String()):\n\t\t\t\tcontinue\n\t\t\tcase filterMask&RT_FILTER_TABLE != 0 &&\n\t\t\t\tfilter.Table != unix.RT_TABLE_UNSPEC && rule.Table != filter.Table:\n\t\t\t\tcontinue\n\t\t\tcase filterMask&RT_FILTER_TOS != 0 && rule.Tos != filter.Tos:\n\t\t\t\tcontinue\n\t\t\tcase filterMask&RT_FILTER_PRIORITY != 0 && rule.Priority != filter.Priority:\n\t\t\t\tcontinue\n\t\t\tcase filterMask&RT_FILTER_MARK != 0 && rule.Mark != filter.Mark:\n\t\t\t\tcontinue\n\t\t\tcase filterMask&RT_FILTER_MASK != 0 && !ptrEqual(rule.Mask, filter.Mask):\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tres = append(res, *rule)\n\t}\n\n\treturn res, executeErr\n}\n\nfunc (pr *RulePortRange) toRtAttrData() []byte {\n\tb := [][]byte{make([]byte, 2), make([]byte, 2)}\n\tnative.PutUint16(b[0], pr.Start)\n\tnative.PutUint16(b[1], pr.End)\n\treturn bytes.Join(b, []byte{})\n}\n\nfunc (pr *RuleUIDRange) toRtAttrData() []byte {\n\tb := [][]byte{make([]byte, 4), make([]byte, 4)}\n\tnative.PutUint32(b[0], pr.Start)\n\tnative.PutUint32(b[1], pr.End)\n\treturn bytes.Join(b, []byte{})\n}\n\nfunc ptrEqual(a, b *uint32) bool {\n\tif a == b {\n\t\treturn true\n\t}\n\tif (a == nil) || (b == nil) {\n\t\treturn false\n\t}\n\treturn *a == *b\n}\n\nfunc (r Rule) typeString() string {\n\tswitch r.Type {\n\tcase unix.RTN_UNSPEC: // zero\n\t\treturn \"\"\n\tcase unix.RTN_UNICAST:\n\t\treturn \"\"\n\tcase unix.RTN_LOCAL:\n\t\treturn \"local\"\n\tcase unix.RTN_BROADCAST:\n\t\treturn \"broadcast\"\n\tcase unix.RTN_ANYCAST:\n\t\treturn \"anycast\"\n\tcase unix.RTN_MULTICAST:\n\t\treturn \"multicast\"\n\tcase unix.RTN_BLACKHOLE:\n\t\treturn \"blackhole\"\n\tcase unix.RTN_UNREACHABLE:\n\t\treturn \"unreachable\"\n\tcase unix.RTN_PROHIBIT:\n\t\treturn \"prohibit\"\n\tcase unix.RTN_THROW:\n\t\treturn \"throw\"\n\tcase unix.RTN_NAT:\n\t\treturn \"nat\"\n\tcase unix.RTN_XRESOLVE:\n\t\treturn \"xresolve\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"type(0x%x)\", r.Type)\n\t}\n}\n"
        },
        {
          "name": "rule_nonlinux.go",
          "type": "blob",
          "size": 0.099609375,
          "content": "//go:build !linux\n// +build !linux\n\npackage netlink\n\nfunc (r Rule) typeString() string {\n\treturn \"\"\n}\n"
        },
        {
          "name": "rule_test.go",
          "type": "blob",
          "size": 16.72265625,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestRuleAddDel(t *testing.T) {\n\tskipUnlessRoot(t)\n\tdefer setUpNetlinkTest(t)()\n\n\tsrcNet := &net.IPNet{IP: net.IPv4(172, 16, 0, 1), Mask: net.CIDRMask(16, 32)}\n\tdstNet := &net.IPNet{IP: net.IPv4(172, 16, 1, 1), Mask: net.CIDRMask(24, 32)}\n\n\trulesBegin, err := RuleList(FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trule := NewRule()\n\trule.Family = FAMILY_V4\n\trule.Table = unix.RT_TABLE_MAIN\n\trule.Src = srcNet\n\trule.Dst = dstNet\n\trule.Priority = 5\n\trule.OifName = \"lo\"\n\trule.IifName = \"lo\"\n\trule.Invert = true\n\trule.Tos = 0x10\n\trule.Dport = NewRulePortRange(80, 80)\n\trule.Sport = NewRulePortRange(1000, 1024)\n\trule.IPProto = unix.IPPROTO_UDP\n\trule.UIDRange = NewRuleUIDRange(100, 100)\n\trule.Protocol = unix.RTPROT_KERNEL\n\tif err := RuleAdd(rule); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trules, err := RuleList(FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(rules) != len(rulesBegin)+1 {\n\t\tt.Fatal(\"Rule not added properly\")\n\t}\n\n\t// find this rule\n\tfound := ruleExists(rules, *rule)\n\tif !found {\n\t\tt.Fatal(\"Rule has diffrent options than one added\")\n\t}\n\n\tif err := RuleDel(rule); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trulesEnd, err := RuleList(FAMILY_V4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(rulesEnd) != len(rulesBegin) {\n\t\tt.Fatal(\"Rule not removed properly\")\n\t}\n}\n\nfunc TestRuleListFiltered(t *testing.T) {\n\tskipUnlessRoot(t)\n\tdefer setUpNetlinkTest(t)()\n\n\tt.Run(\"IPv4\", testRuleListFilteredIPv4)\n\tt.Run(\"IPv6\", testRuleListFilteredIPv6)\n}\n\nfunc testRuleListFilteredIPv4(t *testing.T) {\n\tsrcNet := &net.IPNet{IP: net.IPv4(172, 16, 0, 1), Mask: net.CIDRMask(16, 32)}\n\tdstNet := &net.IPNet{IP: net.IPv4(172, 16, 1, 1), Mask: net.CIDRMask(24, 32)}\n\trunRuleListFiltered(t, FAMILY_V4, srcNet, dstNet)\n}\n\nfunc testRuleListFilteredIPv6(t *testing.T) {\n\tip1 := net.ParseIP(\"fd56:6b58:db28:2913::\")\n\tip2 := net.ParseIP(\"fde9:379f:3b35:6635::\")\n\n\tsrcNet := &net.IPNet{IP: ip1, Mask: net.CIDRMask(64, 128)}\n\tdstNet := &net.IPNet{IP: ip2, Mask: net.CIDRMask(96, 128)}\n\trunRuleListFiltered(t, FAMILY_V6, srcNet, dstNet)\n}\n\nfunc runRuleListFiltered(t *testing.T, family int, srcNet, dstNet *net.IPNet) {\n\tdefaultRules, _ := RuleList(family)\n\n\ttests := []struct {\n\t\tname       string\n\t\truleFilter *Rule\n\t\tfilterMask uint64\n\t\tpreRun     func() *Rule // Creates sample rule harness\n\t\tpostRun    func(*Rule)  // Deletes sample rule harness\n\t\tsetupWant  func(*Rule) ([]Rule, bool)\n\t}{\n\t\t{\n\t\t\tname:       \"returns all rules\",\n\t\t\truleFilter: nil,\n\t\t\tfilterMask: 0,\n\t\t\tpreRun:     func() *Rule { return nil },\n\t\t\tpostRun:    func(r *Rule) {},\n\t\t\tsetupWant: func(_ *Rule) ([]Rule, bool) {\n\t\t\t\treturn defaultRules, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns one rule filtered by Src\",\n\t\t\truleFilter: &Rule{Src: srcNet},\n\t\t\tfilterMask: RT_FILTER_SRC,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1 // Must add priority and table otherwise it's auto-assigned\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 1\n\t\t\t\tRuleAdd(r)\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns one rule filtered by Dst\",\n\t\t\truleFilter: &Rule{Dst: dstNet},\n\t\t\tfilterMask: RT_FILTER_DST,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Dst = dstNet\n\t\t\t\tr.Priority = 1 // Must add priority and table otherwise it's auto-assigned\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 1\n\t\t\t\tRuleAdd(r)\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns two rules filtered by Dst\",\n\t\t\truleFilter: &Rule{Dst: dstNet},\n\t\t\tfilterMask: RT_FILTER_DST,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Dst = dstNet\n\t\t\t\tr.Priority = 1 // Must add priority and table otherwise it's auto-assigned\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 1\n\t\t\t\tRuleAdd(r)\n\n\t\t\t\trc := *r // Create almost identical copy\n\t\t\t\trc.Src = srcNet\n\t\t\t\tRuleAdd(&rc)\n\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) {\n\t\t\t\tRuleDel(r)\n\n\t\t\t\trc := *r // Delete the almost identical copy\n\t\t\t\trc.Src = srcNet\n\t\t\t\tRuleDel(&rc)\n\t\t\t},\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\trs := []Rule{}\n\t\t\t\trs = append(rs, *r)\n\n\t\t\t\trc := *r // Append the almost identical copy\n\t\t\t\trc.Src = srcNet\n\t\t\t\trs = append(rs, rc)\n\n\t\t\t\treturn rs, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns one rule filtered by Src when two rules exist\",\n\t\t\truleFilter: &Rule{Src: srcNet},\n\t\t\tfilterMask: RT_FILTER_SRC,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Dst = dstNet\n\t\t\t\tr.Priority = 1 // Must add priority and table otherwise it's auto-assigned\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 1\n\t\t\t\tRuleAdd(r)\n\n\t\t\t\trc := *r // Create almost identical copy\n\t\t\t\trc.Src = srcNet\n\t\t\t\tRuleAdd(&rc)\n\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) {\n\t\t\t\tRuleDel(r)\n\n\t\t\t\trc := *r // Delete the almost identical copy\n\t\t\t\trc.Src = srcNet\n\t\t\t\tRuleDel(&rc)\n\t\t\t},\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\trs := []Rule{}\n\t\t\t\t// Do not append `r`\n\n\t\t\t\trc := *r // Append the almost identical copy\n\t\t\t\trc.Src = srcNet\n\t\t\t\trs = append(rs, rc)\n\n\t\t\t\treturn rs, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns one rule filtered by Priority(0) and Table\",\n\t\t\truleFilter: &Rule{Priority: 0, Table: 1},\n\t\t\tfilterMask: RT_FILTER_PRIORITY | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 0\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 1\n\t\t\t\tRuleAdd(r)\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) {\n\t\t\t\tRuleDel(r)\n\t\t\t},\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns one rule filtered by Priority preceding main-table rule\",\n\t\t\truleFilter: &Rule{Priority: 32765},\n\t\t\tfilterMask: RT_FILTER_PRIORITY,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 1\n\t\t\t\tRuleAdd(r)\n\n\t\t\t\tr.Priority = 32765 // Set priority for assertion\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) {\n\t\t\t\tRuleDel(r)\n\t\t\t},\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules with specific priority\",\n\t\t\truleFilter: &Rule{Priority: 5},\n\t\t\tfilterMask: RT_FILTER_PRIORITY,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 5\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 1\n\t\t\t\tRuleAdd(r)\n\n\t\t\t\tfor i := 2; i < 5; i++ {\n\t\t\t\t\trc := *r // Create almost identical copy\n\t\t\t\t\trc.Table = i\n\t\t\t\t\tRuleAdd(&rc)\n\t\t\t\t}\n\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) {\n\t\t\t\tRuleDel(r)\n\n\t\t\t\tfor i := 2; i < 5; i++ {\n\t\t\t\t\trc := *r // Delete the almost identical copy\n\t\t\t\t\trc.Table = -1\n\t\t\t\t\tRuleDel(&rc)\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\trs := []Rule{}\n\t\t\t\trs = append(rs, *r)\n\n\t\t\t\tfor i := 2; i < 5; i++ {\n\t\t\t\t\trc := *r // Append the almost identical copy\n\t\t\t\t\trc.Table = i\n\t\t\t\t\trs = append(rs, rc)\n\t\t\t\t}\n\n\t\t\t\treturn rs, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by Table\",\n\t\t\truleFilter: &Rule{Table: 199},\n\t\t\tfilterMask: RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1 // Must add priority otherwise it's auto-assigned\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 199\n\t\t\t\tRuleAdd(r)\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by Mask\",\n\t\t\truleFilter: &Rule{Mask: &[]uint32{0x5}[0]},\n\t\t\tfilterMask: RT_FILTER_MASK,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1 // Must add priority and table otherwise it's auto-assigned\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 1\n\t\t\t\tr.Mask = &[]uint32{0x5}[0]\n\t\t\t\tRuleAdd(r)\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by Mark\",\n\t\t\truleFilter: &Rule{Mark: 0xbb},\n\t\t\tfilterMask: RT_FILTER_MARK,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1 // Must add priority, table, mask otherwise it's auto-assigned\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 1\n\t\t\t\tr.Mask = &[]uint32{0xff}[0]\n\t\t\t\tr.Mark = 0xbb\n\t\t\t\tRuleAdd(r)\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by fwmark 0\",\n\t\t\truleFilter: &Rule{Mark: 0, Mask: nil, Table: 100},\n\t\t\tfilterMask: RT_FILTER_MARK | RT_FILTER_MASK | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 100\n\t\t\t\tr.Mark = 0\n\t\t\t\tr.Mask = nil\n\t\t\t\tif err := RuleAdd(r); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by fwmark 0/0xFFFFFFFF\",\n\t\t\truleFilter: &Rule{Mark: 0, Mask: &[]uint32{0xFFFFFFFF}[0], Table: 100},\n\t\t\tfilterMask: RT_FILTER_MARK | RT_FILTER_MASK | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 100\n\t\t\t\tr.Mark = 0\n\t\t\t\tr.Mask = &[]uint32{0xFFFFFFFF}[0]\n\t\t\t\tif err := RuleAdd(r); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by fwmark 0x1234/0\",\n\t\t\truleFilter: &Rule{Mark: 0x1234, Mask: &[]uint32{0}[0], Table: 100},\n\t\t\tfilterMask: RT_FILTER_MARK | RT_FILTER_MASK | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 100\n\t\t\t\tr.Mark = 0x1234\n\t\t\t\tr.Mask = &[]uint32{0}[0]\n\t\t\t\tif err := RuleAdd(r); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by fwmark 0/0xFFFFFFFF\",\n\t\t\truleFilter: &Rule{Mark: 0, Mask: &[]uint32{0xFFFFFFFF}[0], Table: 100},\n\t\t\tfilterMask: RT_FILTER_MARK | RT_FILTER_MASK | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 100\n\t\t\t\tr.Mark = 0\n\t\t\t\tr.Mask = &[]uint32{0xFFFFFFFF}[0]\n\t\t\t\tif err := RuleAdd(r); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by fwmark 0xFFFFFFFF\",\n\t\t\truleFilter: &Rule{Mark: 0xFFFFFFFF, Mask: &[]uint32{0xFFFFFFFF}[0], Table: 100},\n\t\t\tfilterMask: RT_FILTER_MARK | RT_FILTER_MASK | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 100\n\t\t\t\tr.Mark = 0xFFFFFFFF\n\t\t\t\tr.Mask = nil\n\t\t\t\tif err := RuleAdd(r); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by fwmark 0x1234\",\n\t\t\truleFilter: &Rule{Mark: 0x1234, Mask: &[]uint32{0xFFFFFFFF}[0], Table: 100},\n\t\t\tfilterMask: RT_FILTER_MARK | RT_FILTER_MASK | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 100\n\t\t\t\tr.Mark = 0x1234\n\t\t\t\tr.Mask = nil\n\t\t\t\tif err := RuleAdd(r); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by fwmark 0x12345678\",\n\t\t\truleFilter: &Rule{Mark: 0x12345678, Mask: &[]uint32{0xFFFFFFFF}[0], Table: 100},\n\t\t\tfilterMask: RT_FILTER_MARK | RT_FILTER_MASK | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 100\n\t\t\t\tr.Mark = 0x12345678\n\t\t\t\tr.Mask = nil\n\t\t\t\tif err := RuleAdd(r); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by fwmark 0xFFFFFFFF/0\",\n\t\t\truleFilter: &Rule{Mark: 0xFFFFFFFF, Mask: &[]uint32{0}[0], Table: 100},\n\t\t\tfilterMask: RT_FILTER_MARK | RT_FILTER_MASK | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 100\n\t\t\t\tr.Mark = 0xFFFFFFFF\n\t\t\t\tr.Mask = &[]uint32{0}[0]\n\t\t\t\tif err := RuleAdd(r); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by fwmark 0xFFFFFFFF/0xFFFFFFFF\",\n\t\t\truleFilter: &Rule{Mark: 0xFFFFFFFF, Mask: &[]uint32{0xFFFFFFFF}[0], Table: 100},\n\t\t\tfilterMask: RT_FILTER_MARK | RT_FILTER_MASK | RT_FILTER_TABLE,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 100\n\t\t\t\tr.Mark = 0xFFFFFFFF\n\t\t\t\tr.Mask = &[]uint32{0xFFFFFFFF}[0]\n\t\t\t\tif err := RuleAdd(r); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"returns rules filtered by Tos\",\n\t\t\truleFilter: &Rule{Tos: 12},\n\t\t\tfilterMask: RT_FILTER_TOS,\n\t\t\tpreRun: func() *Rule {\n\t\t\t\tr := NewRule()\n\t\t\t\tr.Src = srcNet\n\t\t\t\tr.Priority = 1 // Must add priority, table, mask otherwise it's auto-assigned\n\t\t\t\tr.Family = family\n\t\t\t\tr.Table = 12\n\t\t\t\tr.Tos = 12 // Tos must equal table\n\t\t\t\tRuleAdd(r)\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tpostRun: func(r *Rule) { RuleDel(r) },\n\t\t\tsetupWant: func(r *Rule) ([]Rule, bool) {\n\t\t\t\treturn []Rule{*r}, false\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\trule := tt.preRun()\n\t\t\twantRules, wantErr := tt.setupWant(rule)\n\n\t\t\trules, err := RuleListFiltered(family, tt.ruleFilter, tt.filterMask)\n\t\t\tfor i := 0; i < len(wantRules); i++ {\n\t\t\t\tif len(wantRules) == len(rules) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(1 * time.Second) // wait rule take effect\n\t\t\t\trules, err = RuleListFiltered(family, tt.ruleFilter, tt.filterMask)\n\t\t\t}\n\t\t\ttt.postRun(rule)\n\n\t\t\tif len(wantRules) != len(rules) {\n\t\t\t\tt.Errorf(\"Expected len: %d, got: %d\", len(wantRules), len(rules))\n\t\t\t} else {\n\t\t\t\tfor i := range wantRules {\n\t\t\t\t\tif !ruleEquals(wantRules[i], rules[i]) {\n\t\t\t\t\t\tt.Errorf(\"Rules mismatch, want %v, got %v\", wantRules[i], rules[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (err != nil) != wantErr {\n\t\t\t\tt.Errorf(\"Error expectation not met, want %v, got %v\", (err != nil), wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRuleString(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := map[string]struct {\n\t\tr Rule\n\t\ts string\n\t}{\n\t\t\"empty rule\": {\n\t\t\ts: \"ip rule 0: from all to all table 0 \",\n\t\t},\n\t\t\"rule with src and dst equivalent to <nil>\": {\n\t\t\tr: Rule{\n\t\t\t\tPriority: 100,\n\t\t\t\tSrc:      &net.IPNet{IP: net.IPv4(10, 0, 0, 0)},\n\t\t\t\tDst:      &net.IPNet{IP: net.IPv4(20, 0, 0, 0)},\n\t\t\t\tTable:    99,\n\t\t\t},\n\t\t\ts: \"ip rule 100: from all to all table 99 \",\n\t\t},\n\t\t\"rule with src and dst\": {\n\t\t\tr: Rule{\n\t\t\t\tPriority: 100,\n\t\t\t\tSrc:      &net.IPNet{IP: net.IPv4(10, 0, 0, 0), Mask: net.IPv4Mask(255, 255, 255, 0)},\n\t\t\t\tDst:      &net.IPNet{IP: net.IPv4(20, 0, 0, 0), Mask: net.IPv4Mask(255, 255, 255, 0)},\n\t\t\t\tTable:    99,\n\t\t\t},\n\t\t\ts: \"ip rule 100: from 10.0.0.0/24 to 20.0.0.0/24 table 99 \",\n\t\t},\n\t\t\"rule with type\": {\n\t\t\tr: Rule{\n\t\t\t\tPriority: 101,\n\t\t\t\tType:     unix.RTN_UNREACHABLE,\n\t\t\t},\n\t\t\ts: \"ip rule 101: from all to all table 0 unreachable\",\n\t\t},\n\t}\n\n\tfor name, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\ts := testCase.r.String()\n\n\t\t\tif s != testCase.s {\n\t\t\t\tt.Errorf(\"expected %q but got %q\", testCase.s, s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc ruleExists(rules []Rule, rule Rule) bool {\n\tfor i := range rules {\n\t\tif ruleEquals(rules[i], rule) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc ruleEquals(a, b Rule) bool {\n\treturn a.Table == b.Table &&\n\t\t((a.Src == nil && b.Src == nil) ||\n\t\t\t(a.Src != nil && b.Src != nil && a.Src.String() == b.Src.String())) &&\n\t\t((a.Dst == nil && b.Dst == nil) ||\n\t\t\t(a.Dst != nil && b.Dst != nil && a.Dst.String() == b.Dst.String())) &&\n\t\ta.OifName == b.OifName &&\n\t\ta.Priority == b.Priority &&\n\t\ta.Family == b.Family &&\n\t\ta.IifName == b.IifName &&\n\t\ta.Invert == b.Invert &&\n\t\ta.Tos == b.Tos &&\n\t\ta.Type == b.Type &&\n\t\ta.IPProto == b.IPProto &&\n\t\ta.Protocol == b.Protocol &&\n\t\ta.Mark == b.Mark &&\n\t\t(ptrEqual(a.Mask, b.Mask) || (a.Mark != 0 &&\n\t\t\t(a.Mask == nil && *b.Mask == 0xFFFFFFFF || b.Mask == nil && *a.Mask == 0xFFFFFFFF)))\n}\n"
        },
        {
          "name": "socket.go",
          "type": "blob",
          "size": 2.1796875,
          "content": "package netlink\n\nimport \"net\"\n\n// SocketID identifies a single socket.\ntype SocketID struct {\n\tSourcePort      uint16\n\tDestinationPort uint16\n\tSource          net.IP\n\tDestination     net.IP\n\tInterface       uint32\n\tCookie          [2]uint32\n}\n\n// Socket represents a netlink socket.\ntype Socket struct {\n\tFamily  uint8\n\tState   uint8\n\tTimer   uint8\n\tRetrans uint8\n\tID      SocketID\n\tExpires uint32\n\tRQueue  uint32\n\tWQueue  uint32\n\tUID     uint32\n\tINode   uint32\n}\n\n// UnixSocket represents a netlink unix socket.\ntype UnixSocket struct {\n\tType   uint8\n\tFamily uint8\n\tState  uint8\n\tpad    uint8\n\tINode  uint32\n\tCookie [2]uint32\n}\n\n// XDPSocket represents an XDP socket (and the common diagnosis part in\n// particular). Please note that in contrast to [UnixSocket] the XDPSocket type\n// does not feature State information.\ntype XDPSocket struct {\n\t// xdp_diag_msg\n\t// https://elixir.bootlin.com/linux/v6.2/source/include/uapi/linux/xdp_diag.h#L21\n\tFamily uint8\n\tType   uint8\n\tpad    uint16\n\tIno    uint32\n\tCookie [2]uint32\n}\n\ntype XDPInfo struct {\n\t// XDP_DIAG_INFO/xdp_diag_info\n\t// https://elixir.bootlin.com/linux/v6.2/source/include/uapi/linux/xdp_diag.h#L51\n\tIfindex uint32\n\tQueueID uint32\n\n\t// XDP_DIAG_UID\n\tUID uint32\n\n\t// XDP_RX_RING\n\t// https://elixir.bootlin.com/linux/v6.2/source/include/uapi/linux/xdp_diag.h#L56\n\tRxRingEntries             uint32\n\tTxRingEntries             uint32\n\tUmemFillRingEntries       uint32\n\tUmemCompletionRingEntries uint32\n\n\t// XDR_DIAG_UMEM\n\tUmem *XDPDiagUmem\n\n\t// XDR_DIAG_STATS\n\tStats *XDPDiagStats\n}\n\nconst (\n\tXDP_DU_F_ZEROCOPY = 1 << iota\n)\n\n// XDPDiagUmem describes the umem attached to an XDP socket.\n//\n// https://elixir.bootlin.com/linux/v6.2/source/include/uapi/linux/xdp_diag.h#L62\ntype XDPDiagUmem struct {\n\tSize      uint64\n\tID        uint32\n\tNumPages  uint32\n\tChunkSize uint32\n\tHeadroom  uint32\n\tIfindex   uint32\n\tQueueID   uint32\n\tFlags     uint32\n\tRefs      uint32\n}\n\n// XDPDiagStats contains ring statistics for an XDP socket.\n//\n// https://elixir.bootlin.com/linux/v6.2/source/include/uapi/linux/xdp_diag.h#L74\ntype XDPDiagStats struct {\n\tRxDropped     uint64\n\tRxInvalid     uint64\n\tRxFull        uint64\n\tFillRingEmpty uint64\n\tTxInvalid     uint64\n\tTxRingEmpty   uint64\n}\n"
        },
        {
          "name": "socket_linux.go",
          "type": "blob",
          "size": 17.3447265625,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\tsizeofSocketID          = 0x30\n\tsizeofSocketRequest     = sizeofSocketID + 0x8\n\tsizeofSocket            = sizeofSocketID + 0x18\n\tsizeofUnixSocketRequest = 0x18 // 24 byte\n\tsizeofUnixSocket        = 0x10 // 16 byte\n)\n\ntype socketRequest struct {\n\tFamily   uint8\n\tProtocol uint8\n\tExt      uint8\n\tpad      uint8\n\tStates   uint32\n\tID       SocketID\n}\n\ntype writeBuffer struct {\n\tBytes []byte\n\tpos   int\n}\n\nfunc (b *writeBuffer) Write(c byte) {\n\tb.Bytes[b.pos] = c\n\tb.pos++\n}\n\nfunc (b *writeBuffer) Next(n int) []byte {\n\ts := b.Bytes[b.pos : b.pos+n]\n\tb.pos += n\n\treturn s\n}\n\nfunc (r *socketRequest) Serialize() []byte {\n\tb := writeBuffer{Bytes: make([]byte, sizeofSocketRequest)}\n\tb.Write(r.Family)\n\tb.Write(r.Protocol)\n\tb.Write(r.Ext)\n\tb.Write(r.pad)\n\tnative.PutUint32(b.Next(4), r.States)\n\tnetworkOrder.PutUint16(b.Next(2), r.ID.SourcePort)\n\tnetworkOrder.PutUint16(b.Next(2), r.ID.DestinationPort)\n\tif r.Family == unix.AF_INET6 {\n\t\tcopy(b.Next(16), r.ID.Source)\n\t\tcopy(b.Next(16), r.ID.Destination)\n\t} else {\n\t\tcopy(b.Next(16), r.ID.Source.To4())\n\t\tcopy(b.Next(16), r.ID.Destination.To4())\n\t}\n\tnative.PutUint32(b.Next(4), r.ID.Interface)\n\tnative.PutUint32(b.Next(4), r.ID.Cookie[0])\n\tnative.PutUint32(b.Next(4), r.ID.Cookie[1])\n\treturn b.Bytes\n}\n\nfunc (r *socketRequest) Len() int { return sizeofSocketRequest }\n\n// According to linux/include/uapi/linux/unix_diag.h\ntype unixSocketRequest struct {\n\tFamily   uint8\n\tProtocol uint8\n\tpad      uint16\n\tStates   uint32\n\tINode    uint32\n\tShow     uint32\n\tCookie   [2]uint32\n}\n\nfunc (r *unixSocketRequest) Serialize() []byte {\n\tb := writeBuffer{Bytes: make([]byte, sizeofUnixSocketRequest)}\n\tb.Write(r.Family)\n\tb.Write(r.Protocol)\n\tnative.PutUint16(b.Next(2), r.pad)\n\tnative.PutUint32(b.Next(4), r.States)\n\tnative.PutUint32(b.Next(4), r.INode)\n\tnative.PutUint32(b.Next(4), r.Show)\n\tnative.PutUint32(b.Next(4), r.Cookie[0])\n\tnative.PutUint32(b.Next(4), r.Cookie[1])\n\treturn b.Bytes\n}\n\nfunc (r *unixSocketRequest) Len() int { return sizeofUnixSocketRequest }\n\ntype readBuffer struct {\n\tBytes []byte\n\tpos   int\n}\n\nfunc (b *readBuffer) Read() byte {\n\tc := b.Bytes[b.pos]\n\tb.pos++\n\treturn c\n}\n\nfunc (b *readBuffer) Next(n int) []byte {\n\ts := b.Bytes[b.pos : b.pos+n]\n\tb.pos += n\n\treturn s\n}\n\nfunc (s *Socket) deserialize(b []byte) error {\n\tif len(b) < sizeofSocket {\n\t\treturn fmt.Errorf(\"socket data short read (%d); want %d\", len(b), sizeofSocket)\n\t}\n\trb := readBuffer{Bytes: b}\n\ts.Family = rb.Read()\n\ts.State = rb.Read()\n\ts.Timer = rb.Read()\n\ts.Retrans = rb.Read()\n\ts.ID.SourcePort = networkOrder.Uint16(rb.Next(2))\n\ts.ID.DestinationPort = networkOrder.Uint16(rb.Next(2))\n\tif s.Family == unix.AF_INET6 {\n\t\ts.ID.Source = net.IP(rb.Next(16))\n\t\ts.ID.Destination = net.IP(rb.Next(16))\n\t} else {\n\t\ts.ID.Source = net.IPv4(rb.Read(), rb.Read(), rb.Read(), rb.Read())\n\t\trb.Next(12)\n\t\ts.ID.Destination = net.IPv4(rb.Read(), rb.Read(), rb.Read(), rb.Read())\n\t\trb.Next(12)\n\t}\n\ts.ID.Interface = native.Uint32(rb.Next(4))\n\ts.ID.Cookie[0] = native.Uint32(rb.Next(4))\n\ts.ID.Cookie[1] = native.Uint32(rb.Next(4))\n\ts.Expires = native.Uint32(rb.Next(4))\n\ts.RQueue = native.Uint32(rb.Next(4))\n\ts.WQueue = native.Uint32(rb.Next(4))\n\ts.UID = native.Uint32(rb.Next(4))\n\ts.INode = native.Uint32(rb.Next(4))\n\treturn nil\n}\n\nfunc (u *UnixSocket) deserialize(b []byte) error {\n\tif len(b) < sizeofUnixSocket {\n\t\treturn fmt.Errorf(\"unix diag data short read (%d); want %d\", len(b), sizeofUnixSocket)\n\t}\n\trb := readBuffer{Bytes: b}\n\tu.Type = rb.Read()\n\tu.Family = rb.Read()\n\tu.State = rb.Read()\n\tu.pad = rb.Read()\n\tu.INode = native.Uint32(rb.Next(4))\n\tu.Cookie[0] = native.Uint32(rb.Next(4))\n\tu.Cookie[1] = native.Uint32(rb.Next(4))\n\treturn nil\n}\n\n// SocketGet returns the Socket identified by its local and remote addresses.\n//\n// If the returned error is [ErrDumpInterrupted], the search for a result may\n// be incomplete and the caller should retry.\nfunc (h *Handle) SocketGet(local, remote net.Addr) (*Socket, error) {\n\tvar protocol uint8\n\tvar localIP, remoteIP net.IP\n\tvar localPort, remotePort uint16\n\tswitch l := local.(type) {\n\tcase *net.TCPAddr:\n\t\tr, ok := remote.(*net.TCPAddr)\n\t\tif !ok {\n\t\t\treturn nil, ErrNotImplemented\n\t\t}\n\t\tlocalIP = l.IP\n\t\tlocalPort = uint16(l.Port)\n\t\tremoteIP = r.IP\n\t\tremotePort = uint16(r.Port)\n\t\tprotocol = unix.IPPROTO_TCP\n\tcase *net.UDPAddr:\n\t\tr, ok := remote.(*net.UDPAddr)\n\t\tif !ok {\n\t\t\treturn nil, ErrNotImplemented\n\t\t}\n\t\tlocalIP = l.IP\n\t\tlocalPort = uint16(l.Port)\n\t\tremoteIP = r.IP\n\t\tremotePort = uint16(r.Port)\n\t\tprotocol = unix.IPPROTO_UDP\n\tdefault:\n\t\treturn nil, ErrNotImplemented\n\t}\n\n\tvar family uint8\n\tif localIP.To4() != nil && remoteIP.To4() != nil {\n\t\tfamily = unix.AF_INET\n\t}\n\n\tif family == 0 && localIP.To16() != nil && remoteIP.To16() != nil {\n\t\tfamily = unix.AF_INET6\n\t}\n\n\tif family == 0 {\n\t\treturn nil, ErrNotImplemented\n\t}\n\n\treq := h.newNetlinkRequest(nl.SOCK_DIAG_BY_FAMILY, unix.NLM_F_DUMP)\n\treq.AddData(&socketRequest{\n\t\tFamily:   family,\n\t\tProtocol: protocol,\n\t\tStates:   0xffffffff,\n\t\tID: SocketID{\n\t\t\tSourcePort:      localPort,\n\t\t\tDestinationPort: remotePort,\n\t\t\tSource:          localIP,\n\t\t\tDestination:     remoteIP,\n\t\t\tCookie:          [2]uint32{nl.TCPDIAG_NOCOOKIE, nl.TCPDIAG_NOCOOKIE},\n\t\t},\n\t})\n\n\tmsgs, err := req.Execute(unix.NETLINK_INET_DIAG, nl.SOCK_DIAG_BY_FAMILY)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(msgs) == 0 {\n\t\treturn nil, errors.New(\"no message nor error from netlink\")\n\t}\n\tif len(msgs) > 2 {\n\t\treturn nil, fmt.Errorf(\"multiple (%d) matching sockets\", len(msgs))\n\t}\n\n\tsock := &Socket{}\n\tif err := sock.deserialize(msgs[0]); err != nil {\n\t\treturn nil, err\n\t}\n\treturn sock, nil\n}\n\n// SocketGet returns the Socket identified by its local and remote addresses.\n//\n// If the returned error is [ErrDumpInterrupted], the search for a result may\n// be incomplete and the caller should retry.\nfunc SocketGet(local, remote net.Addr) (*Socket, error) {\n\treturn pkgHandle.SocketGet(local, remote)\n}\n\n// SocketDestroy kills the Socket identified by its local and remote addresses.\nfunc (h *Handle) SocketDestroy(local, remote net.Addr) error {\n\tlocalTCP, ok := local.(*net.TCPAddr)\n\tif !ok {\n\t\treturn ErrNotImplemented\n\t}\n\tremoteTCP, ok := remote.(*net.TCPAddr)\n\tif !ok {\n\t\treturn ErrNotImplemented\n\t}\n\tlocalIP := localTCP.IP.To4()\n\tif localIP == nil {\n\t\treturn ErrNotImplemented\n\t}\n\tremoteIP := remoteTCP.IP.To4()\n\tif remoteIP == nil {\n\t\treturn ErrNotImplemented\n\t}\n\n\ts, err := nl.Subscribe(unix.NETLINK_INET_DIAG)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.Close()\n\treq := h.newNetlinkRequest(nl.SOCK_DESTROY, unix.NLM_F_ACK)\n\treq.AddData(&socketRequest{\n\t\tFamily:   unix.AF_INET,\n\t\tProtocol: unix.IPPROTO_TCP,\n\t\tID: SocketID{\n\t\t\tSourcePort:      uint16(localTCP.Port),\n\t\t\tDestinationPort: uint16(remoteTCP.Port),\n\t\t\tSource:          localIP,\n\t\t\tDestination:     remoteIP,\n\t\t\tCookie:          [2]uint32{nl.TCPDIAG_NOCOOKIE, nl.TCPDIAG_NOCOOKIE},\n\t\t},\n\t})\n\n\t_, err = req.Execute(unix.NETLINK_INET_DIAG, 0)\n\treturn err\n}\n\n// SocketDestroy kills the Socket identified by its local and remote addresses.\nfunc SocketDestroy(local, remote net.Addr) error {\n\treturn pkgHandle.SocketDestroy(local, remote)\n}\n\n// SocketDiagTCPInfo requests INET_DIAG_INFO for TCP protocol for specified family type and return with extension TCP info.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) SocketDiagTCPInfo(family uint8) ([]*InetDiagTCPInfoResp, error) {\n\t// Construct the request\n\treq := h.newNetlinkRequest(nl.SOCK_DIAG_BY_FAMILY, unix.NLM_F_DUMP)\n\treq.AddData(&socketRequest{\n\t\tFamily:   family,\n\t\tProtocol: unix.IPPROTO_TCP,\n\t\tExt:      (1 << (INET_DIAG_VEGASINFO - 1)) | (1 << (INET_DIAG_INFO - 1)),\n\t\tStates:   uint32(0xfff), // all states\n\t})\n\n\t// Do the query and parse the result\n\tvar result []*InetDiagTCPInfoResp\n\texecuteErr := req.ExecuteIter(unix.NETLINK_INET_DIAG, nl.SOCK_DIAG_BY_FAMILY, func(msg []byte) bool {\n\t\tsockInfo := &Socket{}\n\t\tvar err error\n\t\tif err = sockInfo.deserialize(msg); err != nil {\n\t\t\treturn false\n\t\t}\n\t\tvar attrs []syscall.NetlinkRouteAttr\n\t\tif attrs, err = nl.ParseRouteAttr(msg[sizeofSocket:]); err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tvar res *InetDiagTCPInfoResp\n\t\tif res, err = attrsToInetDiagTCPInfoResp(attrs, sockInfo); err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tresult = append(result, res)\n\t\treturn true\n\t})\n\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\treturn result, executeErr\n}\n\n// SocketDiagTCPInfo requests INET_DIAG_INFO for TCP protocol for specified family type and return with extension TCP info.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc SocketDiagTCPInfo(family uint8) ([]*InetDiagTCPInfoResp, error) {\n\treturn pkgHandle.SocketDiagTCPInfo(family)\n}\n\n// SocketDiagTCP requests INET_DIAG_INFO for TCP protocol for specified family type and return related socket.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) SocketDiagTCP(family uint8) ([]*Socket, error) {\n\t// Construct the request\n\treq := h.newNetlinkRequest(nl.SOCK_DIAG_BY_FAMILY, unix.NLM_F_DUMP)\n\treq.AddData(&socketRequest{\n\t\tFamily:   family,\n\t\tProtocol: unix.IPPROTO_TCP,\n\t\tExt:      (1 << (INET_DIAG_VEGASINFO - 1)) | (1 << (INET_DIAG_INFO - 1)),\n\t\tStates:   uint32(0xfff), // all states\n\t})\n\n\t// Do the query and parse the result\n\tvar result []*Socket\n\texecuteErr := req.ExecuteIter(unix.NETLINK_INET_DIAG, nl.SOCK_DIAG_BY_FAMILY, func(msg []byte) bool {\n\t\tsockInfo := &Socket{}\n\t\tif err := sockInfo.deserialize(msg); err != nil {\n\t\t\treturn false\n\t\t}\n\t\tresult = append(result, sockInfo)\n\t\treturn true\n\t})\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\treturn result, executeErr\n}\n\n// SocketDiagTCP requests INET_DIAG_INFO for TCP protocol for specified family type and return related socket.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc SocketDiagTCP(family uint8) ([]*Socket, error) {\n\treturn pkgHandle.SocketDiagTCP(family)\n}\n\n// SocketDiagUDPInfo requests INET_DIAG_INFO for UDP protocol for specified family type and return with extension info.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) SocketDiagUDPInfo(family uint8) ([]*InetDiagUDPInfoResp, error) {\n\t// Construct the request\n\tvar extensions uint8\n\textensions = 1 << (INET_DIAG_VEGASINFO - 1)\n\textensions |= 1 << (INET_DIAG_INFO - 1)\n\textensions |= 1 << (INET_DIAG_MEMINFO - 1)\n\n\treq := h.newNetlinkRequest(nl.SOCK_DIAG_BY_FAMILY, unix.NLM_F_DUMP)\n\treq.AddData(&socketRequest{\n\t\tFamily:   family,\n\t\tProtocol: unix.IPPROTO_UDP,\n\t\tExt:      extensions,\n\t\tStates:   uint32(0xfff), // all states\n\t})\n\n\t// Do the query and parse the result\n\tvar result []*InetDiagUDPInfoResp\n\texecuteErr := req.ExecuteIter(unix.NETLINK_INET_DIAG, nl.SOCK_DIAG_BY_FAMILY, func(msg []byte) bool {\n\t\tsockInfo := &Socket{}\n\t\tif err := sockInfo.deserialize(msg); err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tvar attrs []syscall.NetlinkRouteAttr\n\t\tvar err error\n\t\tif attrs, err = nl.ParseRouteAttr(msg[sizeofSocket:]); err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tvar res *InetDiagUDPInfoResp\n\t\tif res, err = attrsToInetDiagUDPInfoResp(attrs, sockInfo); err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tresult = append(result, res)\n\t\treturn true\n\t})\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\treturn result, executeErr\n}\n\n// SocketDiagUDPInfo requests INET_DIAG_INFO for UDP protocol for specified family type and return with extension info.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc SocketDiagUDPInfo(family uint8) ([]*InetDiagUDPInfoResp, error) {\n\treturn pkgHandle.SocketDiagUDPInfo(family)\n}\n\n// SocketDiagUDP requests INET_DIAG_INFO for UDP protocol for specified family type and return related socket.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) SocketDiagUDP(family uint8) ([]*Socket, error) {\n\t// Construct the request\n\treq := h.newNetlinkRequest(nl.SOCK_DIAG_BY_FAMILY, unix.NLM_F_DUMP)\n\treq.AddData(&socketRequest{\n\t\tFamily:   family,\n\t\tProtocol: unix.IPPROTO_UDP,\n\t\tExt:      (1 << (INET_DIAG_VEGASINFO - 1)) | (1 << (INET_DIAG_INFO - 1)),\n\t\tStates:   uint32(0xfff), // all states\n\t})\n\n\t// Do the query and parse the result\n\tvar result []*Socket\n\texecuteErr := req.ExecuteIter(unix.NETLINK_INET_DIAG, nl.SOCK_DIAG_BY_FAMILY, func(msg []byte) bool {\n\t\tsockInfo := &Socket{}\n\t\tif err := sockInfo.deserialize(msg); err != nil {\n\t\t\treturn false\n\t\t}\n\t\tresult = append(result, sockInfo)\n\t\treturn true\n\t})\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\treturn result, executeErr\n}\n\n// SocketDiagUDP requests INET_DIAG_INFO for UDP protocol for specified family type and return related socket.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc SocketDiagUDP(family uint8) ([]*Socket, error) {\n\treturn pkgHandle.SocketDiagUDP(family)\n}\n\n// UnixSocketDiagInfo requests UNIX_DIAG_INFO for unix sockets and return with extension info.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) UnixSocketDiagInfo() ([]*UnixDiagInfoResp, error) {\n\t// Construct the request\n\tvar extensions uint8\n\textensions = 1 << UNIX_DIAG_NAME\n\textensions |= 1 << UNIX_DIAG_PEER\n\textensions |= 1 << UNIX_DIAG_RQLEN\n\treq := h.newNetlinkRequest(nl.SOCK_DIAG_BY_FAMILY, unix.NLM_F_DUMP)\n\treq.AddData(&unixSocketRequest{\n\t\tFamily: unix.AF_UNIX,\n\t\tStates: ^uint32(0), // all states\n\t\tShow:   uint32(extensions),\n\t})\n\n\tvar result []*UnixDiagInfoResp\n\texecuteErr := req.ExecuteIter(unix.NETLINK_INET_DIAG, nl.SOCK_DIAG_BY_FAMILY, func(msg []byte) bool {\n\t\tsockInfo := &UnixSocket{}\n\t\tif err := sockInfo.deserialize(msg); err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\t// Diagnosis also delivers sockets with AF_INET family, filter those\n\t\tif sockInfo.Family != unix.AF_UNIX {\n\t\t\treturn false\n\t\t}\n\n\t\tvar attrs []syscall.NetlinkRouteAttr\n\t\tvar err error\n\t\tif attrs, err = nl.ParseRouteAttr(msg[sizeofSocket:]); err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tvar res *UnixDiagInfoResp\n\t\tif res, err = attrsToUnixDiagInfoResp(attrs, sockInfo); err != nil {\n\t\t\treturn false\n\t\t}\n\t\tresult = append(result, res)\n\t\treturn true\n\t})\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\treturn result, executeErr\n}\n\n// UnixSocketDiagInfo requests UNIX_DIAG_INFO for unix sockets and return with extension info.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc UnixSocketDiagInfo() ([]*UnixDiagInfoResp, error) {\n\treturn pkgHandle.UnixSocketDiagInfo()\n}\n\n// UnixSocketDiag requests UNIX_DIAG_INFO for unix sockets.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) UnixSocketDiag() ([]*UnixSocket, error) {\n\t// Construct the request\n\treq := h.newNetlinkRequest(nl.SOCK_DIAG_BY_FAMILY, unix.NLM_F_DUMP)\n\treq.AddData(&unixSocketRequest{\n\t\tFamily: unix.AF_UNIX,\n\t\tStates: ^uint32(0), // all states\n\t})\n\n\tvar result []*UnixSocket\n\texecuteErr := req.ExecuteIter(unix.NETLINK_INET_DIAG, nl.SOCK_DIAG_BY_FAMILY, func(msg []byte) bool {\n\t\tsockInfo := &UnixSocket{}\n\t\tif err := sockInfo.deserialize(msg); err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\t// Diagnosis also delivers sockets with AF_INET family, filter those\n\t\tif sockInfo.Family == unix.AF_UNIX {\n\t\t\tresult = append(result, sockInfo)\n\t\t}\n\t\treturn true\n\t})\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\treturn result, executeErr\n}\n\n// UnixSocketDiag requests UNIX_DIAG_INFO for unix sockets.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc UnixSocketDiag() ([]*UnixSocket, error) {\n\treturn pkgHandle.UnixSocketDiag()\n}\n\nfunc attrsToInetDiagTCPInfoResp(attrs []syscall.NetlinkRouteAttr, sockInfo *Socket) (*InetDiagTCPInfoResp, error) {\n\tinfo := &InetDiagTCPInfoResp{\n\t\tInetDiagMsg: sockInfo,\n\t}\n\tfor _, a := range attrs {\n\t\tswitch a.Attr.Type {\n\t\tcase INET_DIAG_INFO:\n\t\t\tinfo.TCPInfo = &TCPInfo{}\n\t\t\tif err := info.TCPInfo.deserialize(a.Value); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase INET_DIAG_BBRINFO:\n\t\t\tinfo.TCPBBRInfo = &TCPBBRInfo{}\n\t\t\tif err := info.TCPBBRInfo.deserialize(a.Value); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn info, nil\n}\n\nfunc attrsToInetDiagUDPInfoResp(attrs []syscall.NetlinkRouteAttr, sockInfo *Socket) (*InetDiagUDPInfoResp, error) {\n\tinfo := &InetDiagUDPInfoResp{\n\t\tInetDiagMsg: sockInfo,\n\t}\n\tfor _, a := range attrs {\n\t\tswitch a.Attr.Type {\n\t\tcase INET_DIAG_MEMINFO:\n\t\t\tinfo.Memory = &MemInfo{}\n\t\t\tif err := info.Memory.deserialize(a.Value); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn info, nil\n}\n\nfunc attrsToUnixDiagInfoResp(attrs []syscall.NetlinkRouteAttr, sockInfo *UnixSocket) (*UnixDiagInfoResp, error) {\n\tinfo := &UnixDiagInfoResp{\n\t\tDiagMsg: sockInfo,\n\t}\n\tfor _, a := range attrs {\n\t\tswitch a.Attr.Type {\n\t\tcase UNIX_DIAG_NAME:\n\t\t\tname := string(a.Value[:a.Attr.Len])\n\t\t\tinfo.Name = &name\n\t\tcase UNIX_DIAG_PEER:\n\t\t\tpeer := native.Uint32(a.Value)\n\t\t\tinfo.Peer = &peer\n\t\tcase UNIX_DIAG_RQLEN:\n\t\t\tinfo.Queue = &QueueInfo{\n\t\t\t\tRQueue: native.Uint32(a.Value[:4]),\n\t\t\t\tWQueue: native.Uint32(a.Value[4:]),\n\t\t\t}\n\t\t\t// default:\n\t\t\t// \tfmt.Println(\"unknown unix attribute type\", a.Attr.Type, \"with data\", a.Value)\n\t\t}\n\t}\n\n\treturn info, nil\n}\n"
        },
        {
          "name": "socket_linux_test.go",
          "type": "blob",
          "size": 2.6796875,
          "content": "package netlink\n\nimport (\n\t\"reflect\"\n\t\"syscall\"\n\t\"testing\"\n)\n\nfunc TestAttrsToInetDiagTCPInfoResp(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tattrs    []syscall.NetlinkRouteAttr\n\t\texpected *InetDiagTCPInfoResp\n\t\twantFail bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty\",\n\t\t\tattrs:    []syscall.NetlinkRouteAttr{},\n\t\t\texpected: &InetDiagTCPInfoResp{},\n\t\t},\n\t\t{\n\t\t\tname: \"BBRInfo Only\",\n\t\t\tattrs: []syscall.NetlinkRouteAttr{\n\t\t\t\t{\n\t\t\t\t\tAttr: syscall.RtAttr{\n\t\t\t\t\t\tLen:  20,\n\t\t\t\t\t\tType: INET_DIAG_BBRINFO,\n\t\t\t\t\t},\n\t\t\t\t\tValue: []byte{\n\t\t\t\t\t\t100, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t\t\t\t111, 0, 0, 0,\n\t\t\t\t\t\t222, 0, 0, 0,\n\t\t\t\t\t\t123, 0, 0, 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &InetDiagTCPInfoResp{\n\t\t\t\tTCPBBRInfo: &TCPBBRInfo{\n\t\t\t\t\tBBRBW:         100,\n\t\t\t\t\tBBRMinRTT:     111,\n\t\t\t\t\tBBRPacingGain: 222,\n\t\t\t\t\tBBRCwndGain:   123,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"TCPInfo Only\",\n\t\t\tattrs: []syscall.NetlinkRouteAttr{\n\t\t\t\t{\n\t\t\t\t\tAttr: syscall.RtAttr{\n\t\t\t\t\t\tLen:  232,\n\t\t\t\t\t\tType: INET_DIAG_INFO,\n\t\t\t\t\t},\n\t\t\t\t\tValue: tcpInfoData,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &InetDiagTCPInfoResp{\n\t\t\t\tTCPInfo: tcpInfo,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"TCPInfo + TCPBBR\",\n\t\t\tattrs: []syscall.NetlinkRouteAttr{\n\t\t\t\t{\n\t\t\t\t\tAttr: syscall.RtAttr{\n\t\t\t\t\t\tLen:  232,\n\t\t\t\t\t\tType: INET_DIAG_INFO,\n\t\t\t\t\t},\n\t\t\t\t\tValue: tcpInfoData,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAttr: syscall.RtAttr{\n\t\t\t\t\t\tLen:  20,\n\t\t\t\t\t\tType: INET_DIAG_BBRINFO,\n\t\t\t\t\t},\n\t\t\t\t\tValue: []byte{\n\t\t\t\t\t\t100, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t\t\t\t111, 0, 0, 0,\n\t\t\t\t\t\t222, 0, 0, 0,\n\t\t\t\t\t\t123, 0, 0, 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &InetDiagTCPInfoResp{\n\t\t\t\tTCPInfo: tcpInfo,\n\t\t\t\tTCPBBRInfo: &TCPBBRInfo{\n\t\t\t\t\tBBRBW:         100,\n\t\t\t\t\tBBRMinRTT:     111,\n\t\t\t\t\tBBRPacingGain: 222,\n\t\t\t\t\tBBRCwndGain:   123,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"TCPBBR + TCPInfo (reverse)\",\n\t\t\tattrs: []syscall.NetlinkRouteAttr{\n\t\t\t\t{\n\t\t\t\t\tAttr: syscall.RtAttr{\n\t\t\t\t\t\tLen:  20,\n\t\t\t\t\t\tType: INET_DIAG_BBRINFO,\n\t\t\t\t\t},\n\t\t\t\t\tValue: []byte{\n\t\t\t\t\t\t100, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t\t\t\t111, 0, 0, 0,\n\t\t\t\t\t\t222, 0, 0, 0,\n\t\t\t\t\t\t123, 0, 0, 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAttr: syscall.RtAttr{\n\t\t\t\t\t\tLen:  232,\n\t\t\t\t\t\tType: INET_DIAG_INFO,\n\t\t\t\t\t},\n\t\t\t\t\tValue: tcpInfoData,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &InetDiagTCPInfoResp{\n\t\t\t\tTCPInfo: tcpInfo,\n\t\t\t\tTCPBBRInfo: &TCPBBRInfo{\n\t\t\t\t\tBBRBW:         100,\n\t\t\t\t\tBBRMinRTT:     111,\n\t\t\t\t\tBBRPacingGain: 222,\n\t\t\t\t\tBBRCwndGain:   123,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tres, err := attrsToInetDiagTCPInfoResp(test.attrs, nil)\n\t\tif err != nil && !test.wantFail {\n\t\t\tt.Errorf(\"Unexpected failure for test %q\", test.name)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil && test.wantFail {\n\t\t\tt.Errorf(\"Unexpected success for test %q\", test.name)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !reflect.DeepEqual(test.expected, res) {\n\t\t\tt.Errorf(\"Unexpected failure for test %q\", test.name)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "socket_test.go",
          "type": "blob",
          "size": 3.8017578125,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os/user\"\n\t\"strconv\"\n\t\"syscall\"\n\t\"testing\"\n)\n\nfunc TestSocketGet(t *testing.T) {\n\tdefer setUpNetlinkTestWithLoopback(t)()\n\n\ttype Addr struct {\n\t\tIP   net.IP\n\t\tPort int\n\t}\n\n\tgetAddr := func(a net.Addr) Addr {\n\t\tvar addr Addr\n\t\tswitch v := a.(type) {\n\t\tcase *net.UDPAddr:\n\t\t\taddr.IP = v.IP\n\t\t\taddr.Port = v.Port\n\t\tcase *net.TCPAddr:\n\t\t\taddr.IP = v.IP\n\t\t\taddr.Port = v.Port\n\t\t}\n\t\treturn addr\n\t}\n\n\tcheckSocket := func(t *testing.T, local, remote net.Addr) {\n\t\tsocket, err := SocketGet(local, remote)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tlocalAddr, remoteAddr := getAddr(local), getAddr(remote)\n\n\t\tif got, want := socket.ID.Source, localAddr.IP; !got.Equal(want) {\n\t\t\tt.Fatalf(\"local ip = %v, want %v\", got, want)\n\t\t}\n\t\tif got, want := socket.ID.Destination, remoteAddr.IP; !got.Equal(want) {\n\t\t\tt.Fatalf(\"remote ip = %v, want %v\", got, want)\n\t\t}\n\t\tif got, want := int(socket.ID.SourcePort), localAddr.Port; got != want {\n\t\t\tt.Fatalf(\"local port = %d, want %d\", got, want)\n\t\t}\n\t\tif got, want := int(socket.ID.DestinationPort), remoteAddr.Port; got != want {\n\t\t\tt.Fatalf(\"remote port = %d, want %d\", got, want)\n\t\t}\n\t\tu, err := user.Current()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif got, want := strconv.Itoa(int(socket.UID)), u.Uid; got != want {\n\t\t\tt.Fatalf(\"UID = %s, want %s\", got, want)\n\t\t}\n\t}\n\n\tfor _, v := range [...]string{\"tcp4\", \"tcp6\"} {\n\t\taddr, err := net.ResolveTCPAddr(v, \"localhost:0\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tl, err := net.ListenTCP(v, addr)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer l.Close()\n\n\t\tconn, err := net.Dial(l.Addr().Network(), l.Addr().String())\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tcheckSocket(t, conn.LocalAddr(), conn.RemoteAddr())\n\t}\n\n\tfor _, v := range [...]string{\"udp4\", \"udp6\"} {\n\t\taddr, err := net.ResolveUDPAddr(v, \"localhost:0\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tl, err := net.ListenUDP(v, addr)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer l.Close()\n\t\tconn, err := net.Dial(l.LocalAddr().Network(), l.LocalAddr().String())\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer conn.Close()\n\n\t\tcheckSocket(t, conn.LocalAddr(), conn.RemoteAddr())\n\t}\n}\n\nfunc TestSocketDestroy(t *testing.T) {\n\tdefer setUpNetlinkTestWithLoopback(t)()\n\n\taddr, err := net.ResolveTCPAddr(\"tcp\", \"localhost:0\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tl, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer l.Close()\n\n\tconn, err := net.Dial(l.Addr().Network(), l.Addr().String())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tlocalAddr := conn.LocalAddr().(*net.TCPAddr)\n\tremoteAddr := conn.RemoteAddr().(*net.TCPAddr)\n\terr = SocketDestroy(localAddr, remoteAddr)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSocketDiagTCPInfo(t *testing.T) {\n\tFamily4 := uint8(syscall.AF_INET)\n\tFamily6 := uint8(syscall.AF_INET6)\n\tfamilies := []uint8{Family4, Family6}\n\tfor _, wantFamily := range families {\n\t\tres, err := SocketDiagTCPInfo(wantFamily)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, i := range res {\n\t\t\tgotFamily := i.InetDiagMsg.Family\n\t\t\tif gotFamily != wantFamily {\n\t\t\t\tt.Fatalf(\"Socket family = %d, want %d\", gotFamily, wantFamily)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSocketDiagUDPnfo(t *testing.T) {\n\tfor _, want := range []uint8{syscall.AF_INET, syscall.AF_INET6} {\n\t\tresult, err := SocketDiagUDPInfo(want)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfor _, r := range result {\n\t\t\tif got := r.InetDiagMsg.Family; got != want {\n\t\t\t\tt.Fatalf(\"protocol family = %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUnixSocketDiagInfo(t *testing.T) {\n\twant := syscall.AF_UNIX\n\tresult, err := UnixSocketDiagInfo()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i, r := range result {\n\t\tfmt.Println(r.DiagMsg)\n\t\tif got := r.DiagMsg.Family; got != uint8(want) {\n\t\t\tt.Fatalf(\"%d: protocol family = %v, want %v\", i, got, want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "socket_xdp_linux.go",
          "type": "blob",
          "size": 5.3515625,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"syscall\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\tsizeofXDPSocketRequest = 1 + 1 + 2 + 4 + 4 + 2*4\n\tsizeofXDPSocket        = 0x10\n)\n\n// https://elixir.bootlin.com/linux/v6.2/source/include/uapi/linux/xdp_diag.h#L12\ntype xdpSocketRequest struct {\n\tFamily   uint8\n\tProtocol uint8\n\tpad      uint16\n\tIno      uint32\n\tShow     uint32\n\tCookie   [2]uint32\n}\n\nfunc (r *xdpSocketRequest) Serialize() []byte {\n\tb := writeBuffer{Bytes: make([]byte, sizeofSocketRequest)}\n\tb.Write(r.Family)\n\tb.Write(r.Protocol)\n\tnative.PutUint16(b.Next(2), r.pad)\n\tnative.PutUint32(b.Next(4), r.Ino)\n\tnative.PutUint32(b.Next(4), r.Show)\n\tnative.PutUint32(b.Next(4), r.Cookie[0])\n\tnative.PutUint32(b.Next(4), r.Cookie[1])\n\treturn b.Bytes\n}\n\nfunc (r *xdpSocketRequest) Len() int { return sizeofXDPSocketRequest }\n\nfunc (s *XDPSocket) deserialize(b []byte) error {\n\tif len(b) < sizeofXDPSocket {\n\t\treturn fmt.Errorf(\"XDP socket data short read (%d); want %d\", len(b), sizeofXDPSocket)\n\t}\n\trb := readBuffer{Bytes: b}\n\ts.Family = rb.Read()\n\ts.Type = rb.Read()\n\ts.pad = native.Uint16(rb.Next(2))\n\ts.Ino = native.Uint32(rb.Next(4))\n\ts.Cookie[0] = native.Uint32(rb.Next(4))\n\ts.Cookie[1] = native.Uint32(rb.Next(4))\n\treturn nil\n}\n\n// SocketXDPGetInfo returns the XDP socket identified by its inode number and/or\n// socket cookie. Specify the cookie as SOCK_ANY_COOKIE if\n//\n// If the returned error is [ErrDumpInterrupted], the caller should retry.\nfunc SocketXDPGetInfo(ino uint32, cookie uint64) (*XDPDiagInfoResp, error) {\n\t// We have a problem here: dumping AF_XDP sockets currently does not support\n\t// filtering. We thus need to dump all XSKs and then only filter afterwards\n\t// :(\n\txsks, err := SocketDiagXDP()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcheckCookie := cookie != SOCK_ANY_COOKIE && cookie != 0\n\tcrumblingCookie := [2]uint32{uint32(cookie), uint32(cookie >> 32)}\n\tcheckIno := ino != 0\n\tvar xskinfo *XDPDiagInfoResp\n\tfor _, xsk := range xsks {\n\t\tif checkIno && xsk.XDPDiagMsg.Ino != ino {\n\t\t\tcontinue\n\t\t}\n\t\tif checkCookie && xsk.XDPDiagMsg.Cookie != crumblingCookie {\n\t\t\tcontinue\n\t\t}\n\t\tif xskinfo != nil {\n\t\t\treturn nil, errors.New(\"multiple matching XDP sockets\")\n\t\t}\n\t\txskinfo = xsk\n\t}\n\tif xskinfo == nil {\n\t\treturn nil, errors.New(\"no matching XDP socket\")\n\t}\n\treturn xskinfo, nil\n}\n\n// SocketDiagXDP requests XDP_DIAG_INFO for XDP family sockets.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc SocketDiagXDP() ([]*XDPDiagInfoResp, error) {\n\tvar result []*XDPDiagInfoResp\n\terr := socketDiagXDPExecutor(func(m syscall.NetlinkMessage) error {\n\t\tsockInfo := &XDPSocket{}\n\t\tif err := sockInfo.deserialize(m.Data); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tattrs, err := nl.ParseRouteAttr(m.Data[sizeofXDPSocket:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tres, err := attrsToXDPDiagInfoResp(attrs, sockInfo)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tresult = append(result, res)\n\t\treturn nil\n\t})\n\tif err != nil && !errors.Is(err, ErrDumpInterrupted) {\n\t\treturn nil, err\n\t}\n\treturn result, err\n}\n\n// socketDiagXDPExecutor requests XDP_DIAG_INFO for XDP family sockets.\nfunc socketDiagXDPExecutor(receiver func(syscall.NetlinkMessage) error) error {\n\ts, err := nl.Subscribe(unix.NETLINK_INET_DIAG)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.Close()\n\n\treq := nl.NewNetlinkRequest(nl.SOCK_DIAG_BY_FAMILY, unix.NLM_F_DUMP)\n\treq.AddData(&xdpSocketRequest{\n\t\tFamily: unix.AF_XDP,\n\t\tShow:   XDP_SHOW_INFO | XDP_SHOW_RING_CFG | XDP_SHOW_UMEM | XDP_SHOW_STATS,\n\t})\n\tif err := s.Send(req); err != nil {\n\t\treturn err\n\t}\n\n\tdumpIntr := false\nloop:\n\tfor {\n\t\tmsgs, from, err := s.Receive()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif from.Pid != nl.PidKernel {\n\t\t\treturn fmt.Errorf(\"Wrong sender portid %d, expected %d\", from.Pid, nl.PidKernel)\n\t\t}\n\t\tif len(msgs) == 0 {\n\t\t\treturn errors.New(\"no message nor error from netlink\")\n\t\t}\n\n\t\tfor _, m := range msgs {\n\t\t\tif m.Header.Flags&unix.NLM_F_DUMP_INTR != 0 {\n\t\t\t\tdumpIntr = true\n\t\t\t}\n\t\t\tswitch m.Header.Type {\n\t\t\tcase unix.NLMSG_DONE:\n\t\t\t\tbreak loop\n\t\t\tcase unix.NLMSG_ERROR:\n\t\t\t\terror := int32(native.Uint32(m.Data[0:4]))\n\t\t\t\treturn syscall.Errno(-error)\n\t\t\t}\n\t\t\tif err := receiver(m); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif dumpIntr {\n\t\treturn ErrDumpInterrupted\n\t}\n\treturn nil\n}\n\nfunc attrsToXDPDiagInfoResp(attrs []syscall.NetlinkRouteAttr, sockInfo *XDPSocket) (*XDPDiagInfoResp, error) {\n\tresp := &XDPDiagInfoResp{\n\t\tXDPDiagMsg: sockInfo,\n\t\tXDPInfo:    &XDPInfo{},\n\t}\n\tfor _, a := range attrs {\n\t\tswitch a.Attr.Type {\n\t\tcase XDP_DIAG_INFO:\n\t\t\tresp.XDPInfo.Ifindex = native.Uint32(a.Value[0:4])\n\t\t\tresp.XDPInfo.QueueID = native.Uint32(a.Value[4:8])\n\t\tcase XDP_DIAG_UID:\n\t\t\tresp.XDPInfo.UID = native.Uint32(a.Value[0:4])\n\t\tcase XDP_DIAG_RX_RING:\n\t\t\tresp.XDPInfo.RxRingEntries = native.Uint32(a.Value[0:4])\n\t\tcase XDP_DIAG_TX_RING:\n\t\t\tresp.XDPInfo.TxRingEntries = native.Uint32(a.Value[0:4])\n\t\tcase XDP_DIAG_UMEM_FILL_RING:\n\t\t\tresp.XDPInfo.UmemFillRingEntries = native.Uint32(a.Value[0:4])\n\t\tcase XDP_DIAG_UMEM_COMPLETION_RING:\n\t\t\tresp.XDPInfo.UmemCompletionRingEntries = native.Uint32(a.Value[0:4])\n\t\tcase XDP_DIAG_UMEM:\n\t\t\tumem := &XDPDiagUmem{}\n\t\t\tif err := umem.deserialize(a.Value); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresp.XDPInfo.Umem = umem\n\t\tcase XDP_DIAG_STATS:\n\t\t\tstats := &XDPDiagStats{}\n\t\t\tif err := stats.deserialize(a.Value); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresp.XDPInfo.Stats = stats\n\t\t}\n\t}\n\treturn resp, nil\n}\n"
        },
        {
          "name": "socket_xdp_linux_test.go",
          "type": "blob",
          "size": 1.0205078125,
          "content": "//go:build linux\n// +build linux\n\npackage netlink\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestSocketXDPGetInfo(t *testing.T) {\n\txdpsockfd, err := unix.Socket(unix.AF_XDP, unix.SOCK_RAW, 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer unix.Close(xdpsockfd)\n\n\twantFamily := unix.AF_XDP\n\n\tvar xdpsockstat unix.Stat_t\n\terr = unix.Fstat(xdpsockfd, &xdpsockstat)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twantIno := xdpsockstat.Ino\n\n\tresult, err := SocketXDPGetInfo(uint32(wantIno), SOCK_ANY_COOKIE)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tt.Skip(\"kernel lacks support for AF_XDP socket diagnosis\")\n\t\t}\n\t\tt.Fatal(err)\n\t}\n\n\tif got := result.XDPDiagMsg.Family; got != uint8(wantFamily) {\n\t\tt.Fatalf(\"protocol family = %v, want %v\", got, wantFamily)\n\t}\n\tif got := result.XDPDiagMsg.Ino; got != uint32(wantIno) {\n\t\tt.Fatalf(\"protocol ino = %v, want %v\", got, wantIno)\n\t}\n\tif result.XDPInfo == nil {\n\t\tt.Fatalf(\"want non-nil XDPInfo, got nil\")\n\t}\n\tif got := result.XDPInfo.Ifindex; got != 0 {\n\t\tt.Fatalf(\"ifindex = %v, want 0\", got)\n\t}\n}\n"
        },
        {
          "name": "tcp.go",
          "type": "blob",
          "size": 2.9677734375,
          "content": "package netlink\n\n// TCP States\nconst (\n\tTCP_ESTABLISHED = iota + 0x01\n\tTCP_SYN_SENT\n\tTCP_SYN_RECV\n\tTCP_FIN_WAIT1\n\tTCP_FIN_WAIT2\n\tTCP_TIME_WAIT\n\tTCP_CLOSE\n\tTCP_CLOSE_WAIT\n\tTCP_LAST_ACK\n\tTCP_LISTEN\n\tTCP_CLOSING\n\tTCP_NEW_SYN_REC\n\tTCP_MAX_STATES\n)\n\ntype TCPInfo struct {\n\tState                     uint8\n\tCa_state                  uint8\n\tRetransmits               uint8\n\tProbes                    uint8\n\tBackoff                   uint8\n\tOptions                   uint8\n\tSnd_wscale                uint8 // no uint4\n\tRcv_wscale                uint8\n\tDelivery_rate_app_limited uint8\n\tFastopen_client_fail      uint8\n\tRto                       uint32\n\tAto                       uint32\n\tSnd_mss                   uint32\n\tRcv_mss                   uint32\n\tUnacked                   uint32\n\tSacked                    uint32\n\tLost                      uint32\n\tRetrans                   uint32\n\tFackets                   uint32\n\tLast_data_sent            uint32\n\tLast_ack_sent             uint32\n\tLast_data_recv            uint32\n\tLast_ack_recv             uint32\n\tPmtu                      uint32\n\tRcv_ssthresh              uint32\n\tRtt                       uint32\n\tRttvar                    uint32\n\tSnd_ssthresh              uint32\n\tSnd_cwnd                  uint32\n\tAdvmss                    uint32\n\tReordering                uint32\n\tRcv_rtt                   uint32\n\tRcv_space                 uint32\n\tTotal_retrans             uint32\n\tPacing_rate               uint64\n\tMax_pacing_rate           uint64\n\tBytes_acked               uint64 /* RFC4898 tcpEStatsAppHCThruOctetsAcked */\n\tBytes_received            uint64 /* RFC4898 tcpEStatsAppHCThruOctetsReceived */\n\tSegs_out                  uint32 /* RFC4898 tcpEStatsPerfSegsOut */\n\tSegs_in                   uint32 /* RFC4898 tcpEStatsPerfSegsIn */\n\tNotsent_bytes             uint32\n\tMin_rtt                   uint32\n\tData_segs_in              uint32 /* RFC4898 tcpEStatsDataSegsIn */\n\tData_segs_out             uint32 /* RFC4898 tcpEStatsDataSegsOut */\n\tDelivery_rate             uint64\n\tBusy_time                 uint64 /* Time (usec) busy sending data */\n\tRwnd_limited              uint64 /* Time (usec) limited by receive window */\n\tSndbuf_limited            uint64 /* Time (usec) limited by send buffer */\n\tDelivered                 uint32\n\tDelivered_ce              uint32\n\tBytes_sent                uint64 /* RFC4898 tcpEStatsPerfHCDataOctetsOut */\n\tBytes_retrans             uint64 /* RFC4898 tcpEStatsPerfOctetsRetrans */\n\tDsack_dups                uint32 /* RFC4898 tcpEStatsStackDSACKDups */\n\tReord_seen                uint32 /* reordering events seen */\n\tRcv_ooopack               uint32 /* Out-of-order packets received */\n\tSnd_wnd                   uint32 /* peer's advertised receive window after * scaling (bytes) */\n}\n\ntype TCPBBRInfo struct {\n\tBBRBW         uint64\n\tBBRMinRTT     uint32\n\tBBRPacingGain uint32\n\tBBRCwndGain   uint32\n}\n\n// According to https://man7.org/linux/man-pages/man7/sock_diag.7.html\ntype MemInfo struct {\n\tRMem uint32\n\tWMem uint32\n\tFMem uint32\n\tTMem uint32\n}\n"
        },
        {
          "name": "tcp_linux.go",
          "type": "blob",
          "size": 5.93359375,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n)\n\nconst (\n\ttcpBBRInfoLen = 20\n\tmemInfoLen    = 16\n)\n\nfunc checkDeserErr(err error) error {\n\tif err == io.EOF {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc (t *TCPInfo) deserialize(b []byte) error {\n\tvar err error\n\trb := bytes.NewBuffer(b)\n\n\tt.State, err = rb.ReadByte()\n\tif err != nil {\n\t\treturn checkDeserErr(err)\n\t}\n\n\tt.Ca_state, err = rb.ReadByte()\n\tif err != nil {\n\t\treturn checkDeserErr(err)\n\t}\n\n\tt.Retransmits, err = rb.ReadByte()\n\tif err != nil {\n\t\treturn checkDeserErr(err)\n\t}\n\n\tt.Probes, err = rb.ReadByte()\n\tif err != nil {\n\t\treturn checkDeserErr(err)\n\t}\n\n\tt.Backoff, err = rb.ReadByte()\n\tif err != nil {\n\t\treturn checkDeserErr(err)\n\t}\n\tt.Options, err = rb.ReadByte()\n\tif err != nil {\n\t\treturn checkDeserErr(err)\n\t}\n\n\tscales, err := rb.ReadByte()\n\tif err != nil {\n\t\treturn checkDeserErr(err)\n\t}\n\tt.Snd_wscale = scales >> 4  // first 4 bits\n\tt.Rcv_wscale = scales & 0xf // last 4 bits\n\n\trateLimAndFastOpen, err := rb.ReadByte()\n\tif err != nil {\n\t\treturn checkDeserErr(err)\n\t}\n\tt.Delivery_rate_app_limited = rateLimAndFastOpen >> 7 // get first bit\n\tt.Fastopen_client_fail = rateLimAndFastOpen >> 5 & 3  // get next two bits\n\n\tnext := rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Rto = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Ato = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Snd_mss = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Rcv_mss = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Unacked = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Sacked = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Lost = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Retrans = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Fackets = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Last_data_sent = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Last_ack_sent = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Last_data_recv = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Last_ack_recv = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Pmtu = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Rcv_ssthresh = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Rtt = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Rttvar = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Snd_ssthresh = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Snd_cwnd = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Advmss = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Reordering = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Rcv_rtt = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Rcv_space = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Total_retrans = native.Uint32(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Pacing_rate = native.Uint64(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Max_pacing_rate = native.Uint64(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Bytes_acked = native.Uint64(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Bytes_received = native.Uint64(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Segs_out = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Segs_in = native.Uint32(next)\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Notsent_bytes = native.Uint32(next)\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Min_rtt = native.Uint32(next)\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Data_segs_in = native.Uint32(next)\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Data_segs_out = native.Uint32(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Delivery_rate = native.Uint64(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Busy_time = native.Uint64(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Rwnd_limited = native.Uint64(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Sndbuf_limited = native.Uint64(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Delivered = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Delivered_ce = native.Uint32(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Bytes_sent = native.Uint64(next)\n\n\tnext = rb.Next(8)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Bytes_retrans = native.Uint64(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Dsack_dups = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Reord_seen = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Rcv_ooopack = native.Uint32(next)\n\n\tnext = rb.Next(4)\n\tif len(next) == 0 {\n\t\treturn nil\n\t}\n\tt.Snd_wnd = native.Uint32(next)\n\treturn nil\n}\n\nfunc (t *TCPBBRInfo) deserialize(b []byte) error {\n\tif len(b) != tcpBBRInfoLen {\n\t\treturn errors.New(\"Invalid length\")\n\t}\n\n\trb := bytes.NewBuffer(b)\n\tt.BBRBW = native.Uint64(rb.Next(8))\n\tt.BBRMinRTT = native.Uint32(rb.Next(4))\n\tt.BBRPacingGain = native.Uint32(rb.Next(4))\n\tt.BBRCwndGain = native.Uint32(rb.Next(4))\n\n\treturn nil\n}\n\nfunc (m *MemInfo) deserialize(b []byte) error {\n\tif len(b) != memInfoLen {\n\t\treturn errors.New(\"Invalid length\")\n\t}\n\n\trb := bytes.NewBuffer(b)\n\tm.RMem = native.Uint32(rb.Next(4))\n\tm.WMem = native.Uint32(rb.Next(4))\n\tm.FMem = native.Uint32(rb.Next(4))\n\tm.TMem = native.Uint32(rb.Next(4))\n\n\treturn nil\n}\n"
        },
        {
          "name": "tcp_linux_test.go",
          "type": "blob",
          "size": 3.32421875,
          "content": "package netlink\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar (\n\ttcpInfoData []byte\n\ttcpInfo     *TCPInfo\n)\n\nfunc init() {\n\ttcpInfoData = []byte{\n\t\t1, 0, 0, 0, 0, 7, 120, 1, 96, 216, 3, 0, 64,\n\t\t156, 0, 0, 120, 5, 0, 0, 64, 3, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 236, 216, 0, 0, 0, 0, 0, 0, 56, 216,\n\t\t0, 0, 144, 39, 0, 0, 220, 5, 0, 0, 88, 250,\n\t\t0, 0, 79, 190, 0, 0, 7, 5, 0, 0, 255, 255,\n\t\t255, 127, 10, 0, 0, 0, 168, 5, 0, 0, 3, 0, 0,\n\t\t0, 0, 0, 0, 0, 144, 56, 0, 0, 0, 0, 0, 0, 1, 197,\n\t\t8, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255,\n\t\t255, 255, 157, 42, 0, 0, 0, 0, 0, 0, 148, 26, 0,\n\t\t0, 0, 0, 0, 0, 181, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0,\n\t\t0, 93, 180, 0, 0, 61, 0, 0, 0, 89, 0, 0, 0, 47, 216,\n\t\t1, 0, 0, 0, 0, 0, 32, 65, 23, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 0, 0,\n\t\t0, 0, 0, 0, 0, 156, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 195, 1, 0,\n\t}\n\ttcpInfo = &TCPInfo{\n\t\tState:           1,\n\t\tOptions:         7,\n\t\tSnd_wscale:      7,\n\t\tRcv_wscale:      8,\n\t\tRto:             252000,\n\t\tAto:             40000,\n\t\tSnd_mss:         1400,\n\t\tRcv_mss:         832,\n\t\tLast_data_sent:  55532,\n\t\tLast_data_recv:  55352,\n\t\tLast_ack_recv:   10128,\n\t\tPmtu:            1500,\n\t\tRcv_ssthresh:    64088,\n\t\tRtt:             48719,\n\t\tRttvar:          1287,\n\t\tSnd_ssthresh:    2147483647,\n\t\tSnd_cwnd:        10,\n\t\tAdvmss:          1448,\n\t\tReordering:      3,\n\t\tRcv_space:       14480,\n\t\tPacing_rate:     574721,\n\t\tMax_pacing_rate: 18446744073709551615,\n\t\tBytes_acked:     10909,\n\t\tBytes_received:  6804,\n\t\tSegs_out:        181,\n\t\tSegs_in:         95,\n\t\tMin_rtt:         46173,\n\t\tData_segs_in:    61,\n\t\tData_segs_out:   89,\n\t\tDelivery_rate:   120879,\n\t\tBusy_time:       1524000,\n\t\tDelivered:       90,\n\t\tBytes_sent:      10908,\n\t\tSnd_wnd:         115456,\n\t}\n}\n\nfunc TestTCPInfoDeserialize(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []byte\n\t\texpected *TCPInfo\n\t\twantFail bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid data\",\n\t\t\tinput:    tcpInfoData,\n\t\t\texpected: tcpInfo,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttcpbbr := &TCPInfo{}\n\t\terr := tcpbbr.deserialize(test.input)\n\t\tif err != nil && !test.wantFail {\n\t\t\tt.Errorf(\"Unexpected failure for test %q\", test.name)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil && test.wantFail {\n\t\t\tcontinue\n\t\t}\n\n\t\tif !reflect.DeepEqual(test.expected, tcpbbr) {\n\t\t\tt.Errorf(\"Unexpected failure for test %q\", test.name)\n\t\t}\n\t}\n}\n\nfunc TestTCPBBRInfoDeserialize(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []byte\n\t\texpected *TCPBBRInfo\n\t\twantFail bool\n\t}{\n\t\t{\n\t\t\tname: \"Valid data\",\n\t\t\tinput: []byte{\n\t\t\t\t100, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t\t111, 0, 0, 0,\n\t\t\t\t222, 0, 0, 0,\n\t\t\t\t123, 0, 0, 0,\n\t\t\t},\n\t\t\texpected: &TCPBBRInfo{\n\t\t\t\tBBRBW:         100,\n\t\t\t\tBBRMinRTT:     111,\n\t\t\t\tBBRPacingGain: 222,\n\t\t\t\tBBRCwndGain:   123,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid length\",\n\t\t\tinput: []byte{\n\t\t\t\t100, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t\t111, 0, 0, 0,\n\t\t\t\t222, 0, 0, 0,\n\t\t\t\t123, 0, 0,\n\t\t\t},\n\t\t\twantFail: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttcpbbr := &TCPBBRInfo{}\n\t\terr := tcpbbr.deserialize(test.input)\n\t\tif err != nil && !test.wantFail {\n\t\t\tt.Errorf(\"Unexpected failure for test %q\", test.name)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil && test.wantFail {\n\t\t\tcontinue\n\t\t}\n\n\t\tif !reflect.DeepEqual(test.expected, tcpbbr) {\n\t\t\tt.Errorf(\"Unexpected failure for test %q\", test.name)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "unix_diag.go",
          "type": "blob",
          "size": 0.4140625,
          "content": "package netlink\n\n// According to linux/include/uapi/linux/unix_diag.h\nconst (\n\tUNIX_DIAG_NAME = iota\n\tUNIX_DIAG_VFS\n\tUNIX_DIAG_PEER\n\tUNIX_DIAG_ICONS\n\tUNIX_DIAG_RQLEN\n\tUNIX_DIAG_MEMINFO\n\tUNIX_DIAG_SHUTDOWN\n\tUNIX_DIAG_UID\n\tUNIX_DIAG_MAX\n)\n\ntype UnixDiagInfoResp struct {\n\tDiagMsg  *UnixSocket\n\tName     *string\n\tPeer     *uint32\n\tQueue    *QueueInfo\n\tShutdown *uint8\n}\n\ntype QueueInfo struct {\n\tRQueue uint32\n\tWQueue uint32\n}\n"
        },
        {
          "name": "vdpa_linux.go",
          "type": "blob",
          "size": 14.23046875,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n)\n\ntype vdpaDevID struct {\n\tName string\n\tID   uint32\n}\n\n// VDPADev contains info about VDPA device\ntype VDPADev struct {\n\tvdpaDevID\n\tVendorID  uint32\n\tMaxVQS    uint32\n\tMaxVQSize uint16\n\tMinVQSize uint16\n}\n\n// VDPADevConfig contains configuration of the VDPA device\ntype VDPADevConfig struct {\n\tvdpaDevID\n\tFeatures           uint64\n\tNegotiatedFeatures uint64\n\tNet                VDPADevConfigNet\n}\n\n// VDPADevVStats conatins vStats for the VDPA device\ntype VDPADevVStats struct {\n\tvdpaDevID\n\tQueueIndex         uint32\n\tVendor             []VDPADevVStatsVendor\n\tNegotiatedFeatures uint64\n}\n\n// VDPADevVStatsVendor conatins name and value for vendor specific vstat option\ntype VDPADevVStatsVendor struct {\n\tName  string\n\tValue uint64\n}\n\n// VDPADevConfigNet conatins status and net config for the VDPA device\ntype VDPADevConfigNet struct {\n\tStatus VDPADevConfigNetStatus\n\tCfg    VDPADevConfigNetCfg\n}\n\n// VDPADevConfigNetStatus contains info about net status\ntype VDPADevConfigNetStatus struct {\n\tLinkUp   bool\n\tAnnounce bool\n}\n\n// VDPADevConfigNetCfg contains net config for the VDPA device\ntype VDPADevConfigNetCfg struct {\n\tMACAddr net.HardwareAddr\n\tMaxVQP  uint16\n\tMTU     uint16\n}\n\n// VDPAMGMTDev conatins info about VDPA management device\ntype VDPAMGMTDev struct {\n\tBusName           string\n\tDevName           string\n\tSupportedClasses  uint64\n\tSupportedFeatures uint64\n\tMaxVQS            uint32\n}\n\n// VDPANewDevParams contains parameters for new VDPA device\n// use SetBits to configure requried features for the device\n// example:\n//\n//\tVDPANewDevParams{Features: SetBits(0, VIRTIO_NET_F_MTU, VIRTIO_NET_F_CTRL_MAC_ADDR)}\ntype VDPANewDevParams struct {\n\tMACAddr  net.HardwareAddr\n\tMaxVQP   uint16\n\tMTU      uint16\n\tFeatures uint64\n}\n\n// SetBits set provided bits in the uint64 input value\n// usage example:\n// features := SetBits(0, VIRTIO_NET_F_MTU, VIRTIO_NET_F_CTRL_MAC_ADDR)\nfunc SetBits(input uint64, pos ...int) uint64 {\n\tfor _, p := range pos {\n\t\tinput |= 1 << uint64(p)\n\t}\n\treturn input\n}\n\n// IsBitSet check if specific bit is set in the uint64 input value\n// usage example:\n// hasNetClass := IsBitSet(mgmtDev, VIRTIO_ID_NET)\nfunc IsBitSet(input uint64, pos int) bool {\n\tval := input & (1 << uint64(pos))\n\treturn val > 0\n}\n\n// VDPANewDev adds new VDPA device\n// Equivalent to: `vdpa dev add name <name> mgmtdev <mgmtBus>/mgmtName [params]`\nfunc VDPANewDev(name, mgmtBus, mgmtName string, params VDPANewDevParams) error {\n\treturn pkgHandle.VDPANewDev(name, mgmtBus, mgmtName, params)\n}\n\n// VDPADelDev removes VDPA device\n// Equivalent to: `vdpa dev del <name>`\nfunc VDPADelDev(name string) error {\n\treturn pkgHandle.VDPADelDev(name)\n}\n\n// VDPAGetDevList returns list of VDPA devices\n// Equivalent to: `vdpa dev show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc VDPAGetDevList() ([]*VDPADev, error) {\n\treturn pkgHandle.VDPAGetDevList()\n}\n\n// VDPAGetDevByName returns VDPA device selected by name\n// Equivalent to: `vdpa dev show <name>`\nfunc VDPAGetDevByName(name string) (*VDPADev, error) {\n\treturn pkgHandle.VDPAGetDevByName(name)\n}\n\n// VDPAGetDevConfigList returns list of VDPA devices configurations\n// Equivalent to: `vdpa dev config show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc VDPAGetDevConfigList() ([]*VDPADevConfig, error) {\n\treturn pkgHandle.VDPAGetDevConfigList()\n}\n\n// VDPAGetDevConfigByName returns VDPA device configuration selected by name\n// Equivalent to: `vdpa dev config show <name>`\nfunc VDPAGetDevConfigByName(name string) (*VDPADevConfig, error) {\n\treturn pkgHandle.VDPAGetDevConfigByName(name)\n}\n\n// VDPAGetDevVStats returns vstats for VDPA device\n// Equivalent to: `vdpa dev vstats show <name> qidx <queueIndex>`\nfunc VDPAGetDevVStats(name string, queueIndex uint32) (*VDPADevVStats, error) {\n\treturn pkgHandle.VDPAGetDevVStats(name, queueIndex)\n}\n\n// VDPAGetMGMTDevList returns list of mgmt devices\n// Equivalent to: `vdpa mgmtdev show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc VDPAGetMGMTDevList() ([]*VDPAMGMTDev, error) {\n\treturn pkgHandle.VDPAGetMGMTDevList()\n}\n\n// VDPAGetMGMTDevByBusAndName returns mgmt devices selected by bus and name\n// Equivalent to: `vdpa mgmtdev show <bus>/<name>`\nfunc VDPAGetMGMTDevByBusAndName(bus, name string) (*VDPAMGMTDev, error) {\n\treturn pkgHandle.VDPAGetMGMTDevByBusAndName(bus, name)\n}\n\ntype vdpaNetlinkMessage []syscall.NetlinkRouteAttr\n\nfunc (id *vdpaDevID) parseIDAttribute(attr syscall.NetlinkRouteAttr) {\n\tswitch attr.Attr.Type {\n\tcase nl.VDPA_ATTR_DEV_NAME:\n\t\tid.Name = nl.BytesToString(attr.Value)\n\tcase nl.VDPA_ATTR_DEV_ID:\n\t\tid.ID = native.Uint32(attr.Value)\n\t}\n}\n\nfunc (netStatus *VDPADevConfigNetStatus) parseStatusAttribute(value []byte) {\n\ta := native.Uint16(value)\n\tnetStatus.Announce = (a & VIRTIO_NET_S_ANNOUNCE) > 0\n\tnetStatus.LinkUp = (a & VIRTIO_NET_S_LINK_UP) > 0\n}\n\nfunc (d *VDPADev) parseAttributes(attrs vdpaNetlinkMessage) {\n\tfor _, a := range attrs {\n\t\td.parseIDAttribute(a)\n\t\tswitch a.Attr.Type {\n\t\tcase nl.VDPA_ATTR_DEV_VENDOR_ID:\n\t\t\td.VendorID = native.Uint32(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_MAX_VQS:\n\t\t\td.MaxVQS = native.Uint32(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_MAX_VQ_SIZE:\n\t\t\td.MaxVQSize = native.Uint16(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_MIN_VQ_SIZE:\n\t\t\td.MinVQSize = native.Uint16(a.Value)\n\t\t}\n\t}\n}\n\nfunc (c *VDPADevConfig) parseAttributes(attrs vdpaNetlinkMessage) {\n\tfor _, a := range attrs {\n\t\tc.parseIDAttribute(a)\n\t\tswitch a.Attr.Type {\n\t\tcase nl.VDPA_ATTR_DEV_NET_CFG_MACADDR:\n\t\t\tc.Net.Cfg.MACAddr = a.Value\n\t\tcase nl.VDPA_ATTR_DEV_NET_STATUS:\n\t\t\tc.Net.Status.parseStatusAttribute(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_NET_CFG_MAX_VQP:\n\t\t\tc.Net.Cfg.MaxVQP = native.Uint16(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_NET_CFG_MTU:\n\t\t\tc.Net.Cfg.MTU = native.Uint16(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_FEATURES:\n\t\t\tc.Features = native.Uint64(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_NEGOTIATED_FEATURES:\n\t\t\tc.NegotiatedFeatures = native.Uint64(a.Value)\n\t\t}\n\t}\n}\n\nfunc (s *VDPADevVStats) parseAttributes(attrs vdpaNetlinkMessage) {\n\tfor _, a := range attrs {\n\t\ts.parseIDAttribute(a)\n\t\tswitch a.Attr.Type {\n\t\tcase nl.VDPA_ATTR_DEV_QUEUE_INDEX:\n\t\t\ts.QueueIndex = native.Uint32(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_VENDOR_ATTR_NAME:\n\t\t\ts.Vendor = append(s.Vendor, VDPADevVStatsVendor{Name: nl.BytesToString(a.Value)})\n\t\tcase nl.VDPA_ATTR_DEV_VENDOR_ATTR_VALUE:\n\t\t\tif len(s.Vendor) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts.Vendor[len(s.Vendor)-1].Value = native.Uint64(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_NEGOTIATED_FEATURES:\n\t\t\ts.NegotiatedFeatures = native.Uint64(a.Value)\n\t\t}\n\t}\n}\n\nfunc (d *VDPAMGMTDev) parseAttributes(attrs vdpaNetlinkMessage) {\n\tfor _, a := range attrs {\n\t\tswitch a.Attr.Type {\n\t\tcase nl.VDPA_ATTR_MGMTDEV_BUS_NAME:\n\t\t\td.BusName = nl.BytesToString(a.Value)\n\t\tcase nl.VDPA_ATTR_MGMTDEV_DEV_NAME:\n\t\t\td.DevName = nl.BytesToString(a.Value)\n\t\tcase nl.VDPA_ATTR_MGMTDEV_SUPPORTED_CLASSES:\n\t\t\td.SupportedClasses = native.Uint64(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_SUPPORTED_FEATURES:\n\t\t\td.SupportedFeatures = native.Uint64(a.Value)\n\t\tcase nl.VDPA_ATTR_DEV_MGMTDEV_MAX_VQS:\n\t\t\td.MaxVQS = native.Uint32(a.Value)\n\t\t}\n\t}\n}\n\nfunc (h *Handle) vdpaRequest(command uint8, extraFlags int, attrs []*nl.RtAttr) ([]vdpaNetlinkMessage, error) {\n\tf, err := h.GenlFamilyGet(nl.VDPA_GENL_NAME)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq := h.newNetlinkRequest(int(f.ID), unix.NLM_F_ACK|extraFlags)\n\treq.AddData(&nl.Genlmsg{\n\t\tCommand: command,\n\t\tVersion: nl.VDPA_GENL_VERSION,\n\t})\n\tfor _, a := range attrs {\n\t\treq.AddData(a)\n\t}\n\n\tresp, executeErr := req.Execute(unix.NETLINK_GENERIC, 0)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tmessages := make([]vdpaNetlinkMessage, 0, len(resp))\n\tfor _, m := range resp {\n\t\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofGenlmsg:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmessages = append(messages, attrs)\n\t}\n\treturn messages, executeErr\n}\n\n// dump all devices if dev is nil\n//\n// If dev is nil and the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) vdpaDevGet(dev *string) ([]*VDPADev, error) {\n\tvar extraFlags int\n\tvar attrs []*nl.RtAttr\n\tif dev != nil {\n\t\tattrs = append(attrs, nl.NewRtAttr(nl.VDPA_ATTR_DEV_NAME, nl.ZeroTerminated(*dev)))\n\t} else {\n\t\textraFlags = extraFlags | unix.NLM_F_DUMP\n\t}\n\tmessages, executeErr := h.vdpaRequest(nl.VDPA_CMD_DEV_GET, extraFlags, attrs)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tdevs := make([]*VDPADev, 0, len(messages))\n\tfor _, m := range messages {\n\t\td := &VDPADev{}\n\t\td.parseAttributes(m)\n\t\tdevs = append(devs, d)\n\t}\n\treturn devs, executeErr\n}\n\n// dump all devices if dev is nil\n//\n// If dev is nil, and the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) vdpaDevConfigGet(dev *string) ([]*VDPADevConfig, error) {\n\tvar extraFlags int\n\tvar attrs []*nl.RtAttr\n\tif dev != nil {\n\t\tattrs = append(attrs, nl.NewRtAttr(nl.VDPA_ATTR_DEV_NAME, nl.ZeroTerminated(*dev)))\n\t} else {\n\t\textraFlags = extraFlags | unix.NLM_F_DUMP\n\t}\n\tmessages, executeErr := h.vdpaRequest(nl.VDPA_CMD_DEV_CONFIG_GET, extraFlags, attrs)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tcfgs := make([]*VDPADevConfig, 0, len(messages))\n\tfor _, m := range messages {\n\t\tcfg := &VDPADevConfig{}\n\t\tcfg.parseAttributes(m)\n\t\tcfgs = append(cfgs, cfg)\n\t}\n\treturn cfgs, executeErr\n}\n\n// dump all devices if dev is nil\n//\n// If dev is nil and the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) vdpaMGMTDevGet(bus, dev *string) ([]*VDPAMGMTDev, error) {\n\tvar extraFlags int\n\tvar attrs []*nl.RtAttr\n\tif dev != nil {\n\t\tattrs = append(attrs,\n\t\t\tnl.NewRtAttr(nl.VDPA_ATTR_MGMTDEV_DEV_NAME, nl.ZeroTerminated(*dev)),\n\t\t)\n\t\tif bus != nil {\n\t\t\tattrs = append(attrs,\n\t\t\t\tnl.NewRtAttr(nl.VDPA_ATTR_MGMTDEV_BUS_NAME, nl.ZeroTerminated(*bus)),\n\t\t\t)\n\t\t}\n\t} else {\n\t\textraFlags = extraFlags | unix.NLM_F_DUMP\n\t}\n\tmessages, executeErr := h.vdpaRequest(nl.VDPA_CMD_MGMTDEV_GET, extraFlags, attrs)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\tcfgs := make([]*VDPAMGMTDev, 0, len(messages))\n\tfor _, m := range messages {\n\t\tcfg := &VDPAMGMTDev{}\n\t\tcfg.parseAttributes(m)\n\t\tcfgs = append(cfgs, cfg)\n\t}\n\treturn cfgs, executeErr\n}\n\n// VDPANewDev adds new VDPA device\n// Equivalent to: `vdpa dev add name <name> mgmtdev <mgmtBus>/mgmtName [params]`\nfunc (h *Handle) VDPANewDev(name, mgmtBus, mgmtName string, params VDPANewDevParams) error {\n\tattrs := []*nl.RtAttr{\n\t\tnl.NewRtAttr(nl.VDPA_ATTR_DEV_NAME, nl.ZeroTerminated(name)),\n\t\tnl.NewRtAttr(nl.VDPA_ATTR_MGMTDEV_DEV_NAME, nl.ZeroTerminated(mgmtName)),\n\t}\n\tif mgmtBus != \"\" {\n\t\tattrs = append(attrs, nl.NewRtAttr(nl.VDPA_ATTR_MGMTDEV_BUS_NAME, nl.ZeroTerminated(mgmtBus)))\n\t}\n\tif len(params.MACAddr) != 0 {\n\t\tattrs = append(attrs, nl.NewRtAttr(nl.VDPA_ATTR_DEV_NET_CFG_MACADDR, params.MACAddr))\n\t}\n\tif params.MaxVQP > 0 {\n\t\tattrs = append(attrs, nl.NewRtAttr(nl.VDPA_ATTR_DEV_NET_CFG_MAX_VQP, nl.Uint16Attr(params.MaxVQP)))\n\t}\n\tif params.MTU > 0 {\n\t\tattrs = append(attrs, nl.NewRtAttr(nl.VDPA_ATTR_DEV_NET_CFG_MTU, nl.Uint16Attr(params.MTU)))\n\t}\n\tif params.Features > 0 {\n\t\tattrs = append(attrs, nl.NewRtAttr(nl.VDPA_ATTR_DEV_FEATURES, nl.Uint64Attr(params.Features)))\n\t}\n\t_, err := h.vdpaRequest(nl.VDPA_CMD_DEV_NEW, 0, attrs)\n\treturn err\n}\n\n// VDPADelDev removes VDPA device\n// Equivalent to: `vdpa dev del <name>`\nfunc (h *Handle) VDPADelDev(name string) error {\n\t_, err := h.vdpaRequest(nl.VDPA_CMD_DEV_DEL, 0, []*nl.RtAttr{\n\t\tnl.NewRtAttr(nl.VDPA_ATTR_DEV_NAME, nl.ZeroTerminated(name))})\n\treturn err\n}\n\n// VDPAGetDevList returns list of VDPA devices\n// Equivalent to: `vdpa dev show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) VDPAGetDevList() ([]*VDPADev, error) {\n\treturn h.vdpaDevGet(nil)\n}\n\n// VDPAGetDevByName returns VDPA device selected by name\n// Equivalent to: `vdpa dev show <name>`\nfunc (h *Handle) VDPAGetDevByName(name string) (*VDPADev, error) {\n\tdevs, err := h.vdpaDevGet(&name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(devs) == 0 {\n\t\treturn nil, fmt.Errorf(\"device not found\")\n\t}\n\treturn devs[0], nil\n}\n\n// VDPAGetDevConfigList returns list of VDPA devices configurations\n// Equivalent to: `vdpa dev config show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) VDPAGetDevConfigList() ([]*VDPADevConfig, error) {\n\treturn h.vdpaDevConfigGet(nil)\n}\n\n// VDPAGetDevConfigByName returns VDPA device configuration selected by name\n// Equivalent to: `vdpa dev config show <name>`\nfunc (h *Handle) VDPAGetDevConfigByName(name string) (*VDPADevConfig, error) {\n\tcfgs, err := h.vdpaDevConfigGet(&name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(cfgs) == 0 {\n\t\treturn nil, fmt.Errorf(\"configuration not found\")\n\t}\n\treturn cfgs[0], nil\n}\n\n// VDPAGetDevVStats returns vstats for VDPA device\n// Equivalent to: `vdpa dev vstats show <name> qidx <queueIndex>`\nfunc (h *Handle) VDPAGetDevVStats(name string, queueIndex uint32) (*VDPADevVStats, error) {\n\tmessages, err := h.vdpaRequest(nl.VDPA_CMD_DEV_VSTATS_GET, 0, []*nl.RtAttr{\n\t\tnl.NewRtAttr(nl.VDPA_ATTR_DEV_NAME, nl.ZeroTerminated(name)),\n\t\tnl.NewRtAttr(nl.VDPA_ATTR_DEV_QUEUE_INDEX, nl.Uint32Attr(queueIndex)),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(messages) == 0 {\n\t\treturn nil, fmt.Errorf(\"stats not found\")\n\t}\n\tstats := &VDPADevVStats{}\n\tstats.parseAttributes(messages[0])\n\treturn stats, nil\n}\n\n// VDPAGetMGMTDevList returns list of mgmt devices\n// Equivalent to: `vdpa mgmtdev show`\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) VDPAGetMGMTDevList() ([]*VDPAMGMTDev, error) {\n\treturn h.vdpaMGMTDevGet(nil, nil)\n}\n\n// VDPAGetMGMTDevByBusAndName returns mgmt devices selected by bus and name\n// Equivalent to: `vdpa mgmtdev show <bus>/<name>`\nfunc (h *Handle) VDPAGetMGMTDevByBusAndName(bus, name string) (*VDPAMGMTDev, error) {\n\tvar busPtr *string\n\tif bus != \"\" {\n\t\tbusPtr = &bus\n\t}\n\tdevs, err := h.vdpaMGMTDevGet(busPtr, &name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(devs) == 0 {\n\t\treturn nil, fmt.Errorf(\"mgmtdev not found\")\n\t}\n\treturn devs[0], nil\n}\n"
        },
        {
          "name": "vdpa_linux_test.go",
          "type": "blob",
          "size": 7.37890625,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n)\n\n// tests in this package require following modules: vdpa, vdpa_sim, vdpa_sim_net\n// The vpda_sim_net module creates virtual VDPA mgmt device with name vdpasim_net.\n\nconst (\n\tvdpaSimMGMTDev     = \"vdpasim_net\"\n\tvdpaTestDeviceName = \"__nl_test_dev\"\n)\n\nvar (\n\tvdapTestReqModules = []string{\"vdpa\", \"vdpa_sim\", \"vdpa_sim_net\"}\n)\n\nfunc setupVDPATest(t *testing.T, reqCommands ...int) func() {\n\tt.Helper()\n\tskipUnlessRoot(t)\n\tskipUnlessKModuleLoaded(t, vdapTestReqModules...)\n\tgFam, err := GenlFamilyGet(nl.VDPA_GENL_NAME)\n\tif err != nil {\n\t\tt.Skip(\"can't check for supported VDPA commands\")\n\t}\n\tfor _, c := range reqCommands {\n\t\tfound := false\n\t\tfor _, supportedOpt := range gFam.Ops {\n\t\t\tif supportedOpt.ID == uint32(c) {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tt.Skip(\"host doesn't support required VDPA command for the test\")\n\t\t}\n\t}\n\treturn func() {\n\t\t_ = VDPADelDev(vdpaTestDeviceName)\n\t}\n}\n\nfunc TestVDPAGetMGMTDevList(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_MGMTDEV_GET)()\n\tmgmtDevs, err := VDPAGetMGMTDevList()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to list VDPA mgmt devs: %v\", err)\n\t}\n\tsimMGMTFound := false\n\tfor _, d := range mgmtDevs {\n\t\tif d.DevName != vdpaSimMGMTDev || d.BusName != \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tsimMGMTFound = true\n\t\tcheckVDPAMGMTDev(t, d)\n\t}\n\tif !simMGMTFound {\n\t\tt.Fatal(\"VDPA vdpasim_net MGMT device not found\")\n\t}\n}\n\nfunc TestVDPAGetMGMTDevByBusAndName(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_MGMTDEV_GET)()\n\tmgmtDev, err := VDPAGetMGMTDevByBusAndName(\"\", vdpaSimMGMTDev)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get VDPA sim mgmt dev: %v\", err)\n\t}\n\tcheckVDPAMGMTDev(t, mgmtDev)\n\tif mgmtDev.DevName != vdpaSimMGMTDev || mgmtDev.BusName != \"\" {\n\t\tt.Fatalf(\"Invalid device received for Get call, expected: %s, actual: %s\", vdpaSimMGMTDev, mgmtDev.DevName)\n\t}\n}\n\nfunc TestVDPAGetMGMTDevByBusAndName_Unknown_Device(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_MGMTDEV_GET)()\n\t_, err := VDPAGetMGMTDevByBusAndName(\"pci\", \"__should_not_exist\")\n\tif !errors.Is(err, syscall.ENODEV) {\n\t\tt.Fatal(\"VDPAGetMGMTDevByBusAndName returns unexpected error for unknown device\")\n\t}\n}\n\nfunc TestVDPANewDev(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_GET, nl.VDPA_CMD_DEV_NEW)()\n\tif err := createVDPATestDev(); err != nil {\n\t\tt.Fatalf(\"failed to create VDPA device: %v\", err)\n\t}\n\t_, err := VDPAGetDevByName(vdpaTestDeviceName)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get created VDPA devvice: %v\", err)\n\t}\n}\n\nfunc TestVDPANewDev_Already_Exist(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_GET, nl.VDPA_CMD_DEV_NEW)()\n\tif err := createVDPATestDev(); err != nil {\n\t\tt.Fatalf(\"failed to create VDPA device: %v\", err)\n\t}\n\terr := createVDPATestDev()\n\tif !errors.Is(err, syscall.EEXIST) {\n\t\tt.Fatal(\"VDPANewDev returns unexpected error for device which is already exist\")\n\t}\n}\n\nfunc TestVDPANewDev_Unknown_MGMT_DEV(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_GET, nl.VDPA_CMD_DEV_NEW)()\n\terr := VDPANewDev(vdpaTestDeviceName, \"\", \"__should_not_exist\", VDPANewDevParams{})\n\tif !errors.Is(err, syscall.ENODEV) {\n\t\tt.Fatal(\"VDPANewDev returns unexpected error for unknown mgmt device\")\n\t}\n}\n\nfunc TestVDPADelDev(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_DEL, nl.VDPA_CMD_DEV_NEW)()\n\tdefer setupVDPATest(t)()\n\tif err := createVDPATestDev(); err != nil {\n\t\tt.Fatalf(\"failed to create VDPA device: %v\", err)\n\t}\n\tif err := VDPADelDev(vdpaTestDeviceName); err != nil {\n\t\tt.Fatalf(\"VDPADelDev failed: %v\", err)\n\t}\n}\n\nfunc TestVDPADelDev_Unknown_Device(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_DEL)()\n\terr := VDPADelDev(\"__should_not_exist\")\n\tif !errors.Is(err, syscall.ENODEV) {\n\t\tt.Fatal(\"VDPADelDev returns unexpected error for unknown device\")\n\t}\n}\n\nfunc TestVDPAGetDevList(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_GET, nl.VDPA_CMD_DEV_NEW)()\n\tif err := createVDPATestDev(); err != nil {\n\t\tt.Fatalf(\"failed to create VDPA device: %v\", err)\n\t}\n\tdevs, err := VDPAGetDevList()\n\tif err != nil {\n\t\tt.Fatalf(\"VDPAGetDevList failed: %v\", err)\n\t}\n\ttestDevFound := false\n\tfor _, d := range devs {\n\t\tif d.Name != vdpaTestDeviceName {\n\t\t\tcontinue\n\t\t}\n\t\ttestDevFound = true\n\t\tcheckVDPADev(t, d)\n\t}\n\tif !testDevFound {\n\t\tt.Fatal(\"VDPA test device not found\")\n\t}\n}\n\nfunc TestVDPAGetDevByName(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_GET, nl.VDPA_CMD_DEV_NEW)()\n\tif err := createVDPATestDev(); err != nil {\n\t\tt.Fatalf(\"failed to create VDPA device: %v\", err)\n\t}\n\tdev, err := VDPAGetDevByName(vdpaTestDeviceName)\n\tif err != nil {\n\t\tt.Fatalf(\"VDPAGetDevByName failed: %v\", err)\n\t}\n\tcheckVDPADev(t, dev)\n\tif dev.Name != vdpaTestDeviceName {\n\t\tt.Fatalf(\"Invalid device received for Get call, expected: %s, actual: %s\", vdpaTestDeviceName, dev.Name)\n\t}\n}\n\nfunc TestVDPAGetDevByName_Unknown(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_GET)()\n\t_, err := VDPAGetDevByName(\"__should_not_exist\")\n\tif !errors.Is(err, syscall.ENODEV) {\n\t\tt.Fatal(\"VDPAGetDevByName returns unexpected error for unknown device\")\n\t}\n}\n\nfunc TestVDPAGetDevConfigList(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_GET, nl.VDPA_CMD_DEV_CONFIG_GET)()\n\tif err := createVDPATestDev(); err != nil {\n\t\tt.Fatalf(\"failed to create VDPA device: %v\", err)\n\t}\n\tdevConfs, err := VDPAGetDevConfigList()\n\tif err != nil {\n\t\tt.Fatalf(\"VDPAGetDevConfigList failed: %v\", err)\n\t}\n\ttestDevConfFound := false\n\tfor _, d := range devConfs {\n\t\tif d.Name != vdpaTestDeviceName {\n\t\t\tcontinue\n\t\t}\n\t\ttestDevConfFound = true\n\t\tcheckVDPADevConf(t, d)\n\t}\n\tif !testDevConfFound {\n\t\tt.Fatal(\"VDPA test device config not found\")\n\t}\n}\n\nfunc TestVDPAGetDevConfigByName(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_GET, nl.VDPA_CMD_DEV_CONFIG_GET)()\n\tif err := createVDPATestDev(); err != nil {\n\t\tt.Fatalf(\"failed to create VDPA device: %v\", err)\n\t}\n\tdev, err := VDPAGetDevConfigByName(vdpaTestDeviceName)\n\tif err != nil {\n\t\tt.Fatalf(\"VDPAGetDevConfigByName failed: %v\", err)\n\t}\n\tcheckVDPADevConf(t, dev)\n\tif dev.Name != vdpaTestDeviceName {\n\t\tt.Fatalf(\"Invalid device received for Get call, expected: %s, actual: %s\", vdpaTestDeviceName, dev.Name)\n\t}\n}\n\nfunc TestVDPAGetDevConfigByName_Unknowm(t *testing.T) {\n\tdefer setupVDPATest(t, nl.VDPA_CMD_DEV_GET, nl.VDPA_CMD_DEV_CONFIG_GET)()\n\t_, err := VDPAGetDevConfigByName(\"__should_not_exist\")\n\tif !errors.Is(err, syscall.ENODEV) {\n\t\tt.Fatal(\"VDPAGetDevConfigByName returns unexpected error for unknown device\")\n\t}\n}\n\nfunc TestSetGetBits(t *testing.T) {\n\tfeatures := SetBits(0, VIRTIO_NET_F_CSUM, VIRTIO_NET_F_MQ)\n\tif !IsBitSet(features, VIRTIO_NET_F_CSUM) || !IsBitSet(features, VIRTIO_NET_F_MQ) {\n\t\tt.Fatal(\"BitSet test failed\")\n\t}\n\tif IsBitSet(features, VIRTIO_NET_F_STATUS) {\n\t\tt.Fatal(\"unexpected bit is set\")\n\t}\n}\n\nfunc createVDPATestDev() error {\n\treturn VDPANewDev(vdpaTestDeviceName, \"\", vdpaSimMGMTDev, VDPANewDevParams{})\n}\n\nfunc checkVDPAMGMTDev(t *testing.T, d *VDPAMGMTDev) {\n\tif d == nil {\n\t\tt.Fatal(\"VDPA MGMT dev is nil\")\n\t}\n\tif d.DevName == \"\" {\n\t\tt.Fatal(\"VDPA MGMT dev name is not set\")\n\t}\n}\n\nfunc checkVDPADev(t *testing.T, d *VDPADev) {\n\tif d == nil {\n\t\tt.Fatal(\"VDPA dev is nil\")\n\t}\n\tif d.Name == \"\" {\n\t\tt.Fatal(\"VDPA dev name is not set\")\n\t}\n\tif d.ID == 0 {\n\t\tt.Fatal(\"VDPA dev ID is not set\")\n\t}\n}\n\nfunc checkVDPADevConf(t *testing.T, d *VDPADevConfig) {\n\tif d == nil {\n\t\tt.Fatal(\"VDPA dev config is nil\")\n\t}\n\tif d.Name == \"\" {\n\t\tt.Fatal(\"VDPA dev name is not set\")\n\t}\n\tif d.ID == 0 {\n\t\tt.Fatal(\"VDPA dev ID is not set\")\n\t}\n}\n"
        },
        {
          "name": "virtio.go",
          "type": "blob",
          "size": 6.6279296875,
          "content": "package netlink\n\n// features for virtio net\nconst (\n\tVIRTIO_NET_F_CSUM                = 0  // Host handles pkts w/ partial csum\n\tVIRTIO_NET_F_GUEST_CSUM          = 1  // Guest handles pkts w/ partial csum\n\tVIRTIO_NET_F_CTRL_GUEST_OFFLOADS = 2  // Dynamic offload configuration.\n\tVIRTIO_NET_F_MTU                 = 3  // Initial MTU advice\n\tVIRTIO_NET_F_MAC                 = 5  // Host has given MAC address.\n\tVIRTIO_NET_F_GUEST_TSO4          = 7  // Guest can handle TSOv4 in.\n\tVIRTIO_NET_F_GUEST_TSO6          = 8  // Guest can handle TSOv6 in.\n\tVIRTIO_NET_F_GUEST_ECN           = 9  // Guest can handle TSO[6] w/ ECN in.\n\tVIRTIO_NET_F_GUEST_UFO           = 10 // Guest can handle UFO in.\n\tVIRTIO_NET_F_HOST_TSO4           = 11 // Host can handle TSOv4 in.\n\tVIRTIO_NET_F_HOST_TSO6           = 12 // Host can handle TSOv6 in.\n\tVIRTIO_NET_F_HOST_ECN            = 13 // Host can handle TSO[6] w/ ECN in.\n\tVIRTIO_NET_F_HOST_UFO            = 14 // Host can handle UFO in.\n\tVIRTIO_NET_F_MRG_RXBUF           = 15 // Host can merge receive buffers.\n\tVIRTIO_NET_F_STATUS              = 16 // virtio_net_config.status available\n\tVIRTIO_NET_F_CTRL_VQ             = 17 // Control channel available\n\tVIRTIO_NET_F_CTRL_RX             = 18 // Control channel RX mode support\n\tVIRTIO_NET_F_CTRL_VLAN           = 19 // Control channel VLAN filtering\n\tVIRTIO_NET_F_CTRL_RX_EXTRA       = 20 // Extra RX mode control support\n\tVIRTIO_NET_F_GUEST_ANNOUNCE      = 21 // Guest can announce device on the* network\n\tVIRTIO_NET_F_MQ                  = 22 // Device supports Receive Flow Steering\n\tVIRTIO_NET_F_CTRL_MAC_ADDR       = 23 // Set MAC address\n\tVIRTIO_NET_F_VQ_NOTF_COAL        = 52 // Device supports virtqueue notification coalescing\n\tVIRTIO_NET_F_NOTF_COAL           = 53 // Device supports notifications coalescing\n\tVIRTIO_NET_F_GUEST_USO4          = 54 // Guest can handle USOv4 in.\n\tVIRTIO_NET_F_GUEST_USO6          = 55 // Guest can handle USOv6 in.\n\tVIRTIO_NET_F_HOST_USO            = 56 // Host can handle USO in.\n\tVIRTIO_NET_F_HASH_REPORT         = 57 // Supports hash report\n\tVIRTIO_NET_F_GUEST_HDRLEN        = 59 // Guest provides the exact hdr_len value.\n\tVIRTIO_NET_F_RSS                 = 60 // Supports RSS RX steering\n\tVIRTIO_NET_F_RSC_EXT             = 61 // extended coalescing info\n\tVIRTIO_NET_F_STANDBY             = 62 // Act as standby for another device with the same MAC.\n\tVIRTIO_NET_F_SPEED_DUPLEX        = 63 // Device set linkspeed and duplex\n\tVIRTIO_NET_F_GSO                 = 6  // Host handles pkts any GSO type\n)\n\n// virtio net status\nconst (\n\tVIRTIO_NET_S_LINK_UP  = 1 // Link is up\n\tVIRTIO_NET_S_ANNOUNCE = 2 // Announcement is needed\n)\n\n// virtio config\nconst (\n\t// Do we get callbacks when the ring is completely used, even if we've\n\t// suppressed them?\n\tVIRTIO_F_NOTIFY_ON_EMPTY = 24\n\t// Can the device handle any descriptor layout?\n\tVIRTIO_F_ANY_LAYOUT = 27\n\t// v1.0 compliant\n\tVIRTIO_F_VERSION_1 = 32\n\t// If clear - device has the platform DMA (e.g. IOMMU) bypass quirk feature.\n\t// If set - use platform DMA tools to access the memory.\n\t// Note the reverse polarity (compared to most other features),\n\t// this is for compatibility with legacy systems.\n\tVIRTIO_F_ACCESS_PLATFORM = 33\n\t// Legacy name for VIRTIO_F_ACCESS_PLATFORM (for compatibility with old userspace)\n\tVIRTIO_F_IOMMU_PLATFORM = VIRTIO_F_ACCESS_PLATFORM\n\t// This feature indicates support for the packed virtqueue layout.\n\tVIRTIO_F_RING_PACKED = 34\n\t// Inorder feature indicates that all buffers are used by the device\n\t// in the same order in which they have been made available.\n\tVIRTIO_F_IN_ORDER = 35\n\t// This feature indicates that memory accesses by the driver and the\n\t// device are ordered in a way described by the platform.\n\tVIRTIO_F_ORDER_PLATFORM = 36\n\t// Does the device support Single Root I/O Virtualization?\n\tVIRTIO_F_SR_IOV = 37\n\t// This feature indicates that the driver passes extra data (besides\n\t// identifying the virtqueue) in its device notifications.\n\tVIRTIO_F_NOTIFICATION_DATA = 38\n\t// This feature indicates that the driver uses the data provided by the device\n\t// as a virtqueue identifier in available buffer notifications.\n\tVIRTIO_F_NOTIF_CONFIG_DATA = 39\n\t// This feature indicates that the driver can reset a queue individually.\n\tVIRTIO_F_RING_RESET = 40\n)\n\n// virtio device ids\nconst (\n\tVIRTIO_ID_NET            = 1  // virtio net\n\tVIRTIO_ID_BLOCK          = 2  // virtio block\n\tVIRTIO_ID_CONSOLE        = 3  // virtio console\n\tVIRTIO_ID_RNG            = 4  // virtio rng\n\tVIRTIO_ID_BALLOON        = 5  // virtio balloon\n\tVIRTIO_ID_IOMEM          = 6  // virtio ioMemory\n\tVIRTIO_ID_RPMSG          = 7  // virtio remote processor messaging\n\tVIRTIO_ID_SCSI           = 8  // virtio scsi\n\tVIRTIO_ID_9P             = 9  // 9p virtio console\n\tVIRTIO_ID_MAC80211_WLAN  = 10 // virtio WLAN MAC\n\tVIRTIO_ID_RPROC_SERIAL   = 11 // virtio remoteproc serial link\n\tVIRTIO_ID_CAIF           = 12 // Virtio caif\n\tVIRTIO_ID_MEMORY_BALLOON = 13 // virtio memory balloon\n\tVIRTIO_ID_GPU            = 16 // virtio GPU\n\tVIRTIO_ID_CLOCK          = 17 // virtio clock/timer\n\tVIRTIO_ID_INPUT          = 18 // virtio input\n\tVIRTIO_ID_VSOCK          = 19 // virtio vsock transport\n\tVIRTIO_ID_CRYPTO         = 20 // virtio crypto\n\tVIRTIO_ID_SIGNAL_DIST    = 21 // virtio signal distribution device\n\tVIRTIO_ID_PSTORE         = 22 // virtio pstore device\n\tVIRTIO_ID_IOMMU          = 23 // virtio IOMMU\n\tVIRTIO_ID_MEM            = 24 // virtio mem\n\tVIRTIO_ID_SOUND          = 25 // virtio sound\n\tVIRTIO_ID_FS             = 26 // virtio filesystem\n\tVIRTIO_ID_PMEM           = 27 // virtio pmem\n\tVIRTIO_ID_RPMB           = 28 // virtio rpmb\n\tVIRTIO_ID_MAC80211_HWSIM = 29 // virtio mac80211-hwsim\n\tVIRTIO_ID_VIDEO_ENCODER  = 30 // virtio video encoder\n\tVIRTIO_ID_VIDEO_DECODER  = 31 // virtio video decoder\n\tVIRTIO_ID_SCMI           = 32 // virtio SCMI\n\tVIRTIO_ID_NITRO_SEC_MOD  = 33 // virtio nitro secure module\n\tVIRTIO_ID_I2C_ADAPTER    = 34 // virtio i2c adapter\n\tVIRTIO_ID_WATCHDOG       = 35 // virtio watchdog\n\tVIRTIO_ID_CAN            = 36 // virtio can\n\tVIRTIO_ID_DMABUF         = 37 // virtio dmabuf\n\tVIRTIO_ID_PARAM_SERV     = 38 // virtio parameter server\n\tVIRTIO_ID_AUDIO_POLICY   = 39 // virtio audio policy\n\tVIRTIO_ID_BT             = 40 // virtio bluetooth\n\tVIRTIO_ID_GPIO           = 41 // virtio gpio\n\t// Virtio Transitional IDs\n\tVIRTIO_TRANS_ID_NET     = 0x1000 // transitional virtio net\n\tVIRTIO_TRANS_ID_BLOCK   = 0x1001 // transitional virtio block\n\tVIRTIO_TRANS_ID_BALLOON = 0x1002 // transitional virtio balloon\n\tVIRTIO_TRANS_ID_CONSOLE = 0x1003 // transitional virtio console\n\tVIRTIO_TRANS_ID_SCSI    = 0x1004 // transitional virtio SCSI\n\tVIRTIO_TRANS_ID_RNG     = 0x1005 // transitional virtio rng\n\tVIRTIO_TRANS_ID_9P      = 0x1009 // transitional virtio 9p console\n)\n"
        },
        {
          "name": "xdp_diag.go",
          "type": "blob",
          "size": 1.0888671875,
          "content": "package netlink\n\nimport \"github.com/vishvananda/netlink/nl\"\n\nconst SOCK_ANY_COOKIE = uint64(nl.TCPDIAG_NOCOOKIE)<<32 + uint64(nl.TCPDIAG_NOCOOKIE)\n\n// XDP diagnosis show flag constants to request particular information elements.\nconst (\n\tXDP_SHOW_INFO = 1 << iota\n\tXDP_SHOW_RING_CFG\n\tXDP_SHOW_UMEM\n\tXDP_SHOW_MEMINFO\n\tXDP_SHOW_STATS\n)\n\n// XDP diag element constants\nconst (\n\tXDP_DIAG_NONE                 = iota\n\tXDP_DIAG_INFO                 // when using XDP_SHOW_INFO\n\tXDP_DIAG_UID                  // when using XDP_SHOW_INFO\n\tXDP_DIAG_RX_RING              // when using XDP_SHOW_RING_CFG\n\tXDP_DIAG_TX_RING              // when using XDP_SHOW_RING_CFG\n\tXDP_DIAG_UMEM                 // when using XDP_SHOW_UMEM\n\tXDP_DIAG_UMEM_FILL_RING       // when using XDP_SHOW_UMEM\n\tXDP_DIAG_UMEM_COMPLETION_RING // when using XDP_SHOW_UMEM\n\tXDP_DIAG_MEMINFO              // when using XDP_SHOW_MEMINFO\n\tXDP_DIAG_STATS                // when using XDP_SHOW_STATS\n)\n\n// https://elixir.bootlin.com/linux/v6.2/source/include/uapi/linux/xdp_diag.h#L21\ntype XDPDiagInfoResp struct {\n\tXDPDiagMsg *XDPSocket\n\tXDPInfo    *XDPInfo\n}\n"
        },
        {
          "name": "xdp_linux.go",
          "type": "blob",
          "size": 1.123046875,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\nconst (\n\txdrDiagUmemLen  = 8 + 8*4\n\txdrDiagStatsLen = 6 * 8\n)\n\nfunc (x *XDPDiagUmem) deserialize(b []byte) error {\n\tif len(b) < xdrDiagUmemLen {\n\t\treturn fmt.Errorf(\"XDP umem diagnosis data short read (%d); want %d\", len(b), xdrDiagUmemLen)\n\t}\n\n\trb := bytes.NewBuffer(b)\n\tx.Size = native.Uint64(rb.Next(8))\n\tx.ID = native.Uint32(rb.Next(4))\n\tx.NumPages = native.Uint32(rb.Next(4))\n\tx.ChunkSize = native.Uint32(rb.Next(4))\n\tx.Headroom = native.Uint32(rb.Next(4))\n\tx.Ifindex = native.Uint32(rb.Next(4))\n\tx.QueueID = native.Uint32(rb.Next(4))\n\tx.Flags = native.Uint32(rb.Next(4))\n\tx.Refs = native.Uint32(rb.Next(4))\n\n\treturn nil\n}\n\nfunc (x *XDPDiagStats) deserialize(b []byte) error {\n\tif len(b) < xdrDiagStatsLen {\n\t\treturn fmt.Errorf(\"XDP diagnosis statistics short read (%d); want %d\", len(b), xdrDiagStatsLen)\n\t}\n\n\trb := bytes.NewBuffer(b)\n\tx.RxDropped = native.Uint64(rb.Next(8))\n\tx.RxInvalid = native.Uint64(rb.Next(8))\n\tx.RxFull = native.Uint64(rb.Next(8))\n\tx.FillRingEmpty = native.Uint64(rb.Next(8))\n\tx.TxInvalid = native.Uint64(rb.Next(8))\n\tx.TxRingEmpty = native.Uint64(rb.Next(8))\n\n\treturn nil\n}\n"
        },
        {
          "name": "xfrm_linux.go",
          "type": "blob",
          "size": 1.4482421875,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// Proto is an enum representing an ipsec protocol.\ntype Proto uint8\n\nconst (\n\tXFRM_PROTO_ROUTE2    Proto = unix.IPPROTO_ROUTING\n\tXFRM_PROTO_ESP       Proto = unix.IPPROTO_ESP\n\tXFRM_PROTO_AH        Proto = unix.IPPROTO_AH\n\tXFRM_PROTO_HAO       Proto = unix.IPPROTO_DSTOPTS\n\tXFRM_PROTO_COMP      Proto = unix.IPPROTO_COMP\n\tXFRM_PROTO_IPSEC_ANY Proto = unix.IPPROTO_RAW\n)\n\nfunc (p Proto) String() string {\n\tswitch p {\n\tcase XFRM_PROTO_ROUTE2:\n\t\treturn \"route2\"\n\tcase XFRM_PROTO_ESP:\n\t\treturn \"esp\"\n\tcase XFRM_PROTO_AH:\n\t\treturn \"ah\"\n\tcase XFRM_PROTO_HAO:\n\t\treturn \"hao\"\n\tcase XFRM_PROTO_COMP:\n\t\treturn \"comp\"\n\tcase XFRM_PROTO_IPSEC_ANY:\n\t\treturn \"ipsec-any\"\n\t}\n\treturn fmt.Sprintf(\"%d\", p)\n}\n\n// Mode is an enum representing an ipsec transport.\ntype Mode uint8\n\nconst (\n\tXFRM_MODE_TRANSPORT Mode = iota\n\tXFRM_MODE_TUNNEL\n\tXFRM_MODE_ROUTEOPTIMIZATION\n\tXFRM_MODE_IN_TRIGGER\n\tXFRM_MODE_BEET\n\tXFRM_MODE_MAX\n)\n\nfunc (m Mode) String() string {\n\tswitch m {\n\tcase XFRM_MODE_TRANSPORT:\n\t\treturn \"transport\"\n\tcase XFRM_MODE_TUNNEL:\n\t\treturn \"tunnel\"\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\t\treturn \"ro\"\n\tcase XFRM_MODE_IN_TRIGGER:\n\t\treturn \"in_trigger\"\n\tcase XFRM_MODE_BEET:\n\t\treturn \"beet\"\n\t}\n\treturn fmt.Sprintf(\"%d\", m)\n}\n\n// XfrmMark represents the mark associated to the state or policy\ntype XfrmMark struct {\n\tValue uint32\n\tMask  uint32\n}\n\nfunc (m *XfrmMark) String() string {\n\treturn fmt.Sprintf(\"(0x%x,0x%x)\", m.Value, m.Mask)\n}\n"
        },
        {
          "name": "xfrm_monitor_linux.go",
          "type": "blob",
          "size": 1.8046875,
          "content": "package netlink\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"github.com/vishvananda/netns\"\n\t\"golang.org/x/sys/unix\"\n)\n\ntype XfrmMsg interface {\n\tType() nl.XfrmMsgType\n}\n\ntype XfrmMsgExpire struct {\n\tXfrmState *XfrmState\n\tHard      bool\n}\n\nfunc (ue *XfrmMsgExpire) Type() nl.XfrmMsgType {\n\treturn nl.XFRM_MSG_EXPIRE\n}\n\nfunc parseXfrmMsgExpire(b []byte) *XfrmMsgExpire {\n\tvar e XfrmMsgExpire\n\n\tmsg := nl.DeserializeXfrmUserExpire(b)\n\te.XfrmState = xfrmStateFromXfrmUsersaInfo(&msg.XfrmUsersaInfo)\n\te.Hard = msg.Hard == 1\n\n\treturn &e\n}\n\nfunc XfrmMonitor(ch chan<- XfrmMsg, done <-chan struct{}, errorChan chan<- error,\n\ttypes ...nl.XfrmMsgType) error {\n\n\tgroups, err := xfrmMcastGroups(types)\n\tif err != nil {\n\t\treturn nil\n\t}\n\ts, err := nl.SubscribeAt(netns.None(), netns.None(), unix.NETLINK_XFRM, groups...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif done != nil {\n\t\tgo func() {\n\t\t\t<-done\n\t\t\ts.Close()\n\t\t}()\n\n\t}\n\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor {\n\t\t\tmsgs, from, err := s.Receive()\n\t\t\tif err != nil {\n\t\t\t\terrorChan <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif from.Pid != nl.PidKernel {\n\t\t\t\terrorChan <- fmt.Errorf(\"Wrong sender portid %d, expected %d\", from.Pid, nl.PidKernel)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor _, m := range msgs {\n\t\t\t\tswitch m.Header.Type {\n\t\t\t\tcase nl.XFRM_MSG_EXPIRE:\n\t\t\t\t\tch <- parseXfrmMsgExpire(m.Data)\n\t\t\t\tdefault:\n\t\t\t\t\terrorChan <- fmt.Errorf(\"unsupported msg type: %x\", m.Header.Type)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc xfrmMcastGroups(types []nl.XfrmMsgType) ([]uint, error) {\n\tgroups := make([]uint, 0)\n\n\tif len(types) == 0 {\n\t\treturn nil, fmt.Errorf(\"no xfrm msg type specified\")\n\t}\n\n\tfor _, t := range types {\n\t\tvar group uint\n\n\t\tswitch t {\n\t\tcase nl.XFRM_MSG_EXPIRE:\n\t\t\tgroup = nl.XFRMNLGRP_EXPIRE\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unsupported group: %x\", t)\n\t\t}\n\n\t\tgroups = append(groups, group)\n\t}\n\n\treturn groups, nil\n}\n"
        },
        {
          "name": "xfrm_monitor_linux_test.go",
          "type": "blob",
          "size": 1.16015625,
          "content": "package netlink\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n)\n\nfunc TestXfrmMonitorExpire(t *testing.T) {\n\tif os.Getenv(\"CI\") == \"true\" {\n\t\tt.Skipf(\"Flaky in CI: Intermittently causes 10 minute timeout\")\n\t}\n\tdefer setUpNetlinkTest(t)()\n\n\tch := make(chan XfrmMsg)\n\tdone := make(chan struct{})\n\tdefer close(done)\n\terrChan := make(chan error)\n\tif err := XfrmMonitor(ch, nil, errChan, nl.XFRM_MSG_EXPIRE); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Program state with limits\n\tstate := getBaseState()\n\tstate.Limits.TimeHard = 2\n\tstate.Limits.TimeSoft = 1\n\tif err := XfrmStateAdd(state); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thardFound := false\n\tsoftFound := false\n\n\tmsg := (<-ch).(*XfrmMsgExpire)\n\tif msg.XfrmState.Spi != state.Spi {\n\t\tt.Fatal(\"Received unexpected msg, spi does not match\")\n\t}\n\thardFound = msg.Hard || hardFound\n\tsoftFound = !msg.Hard || softFound\n\n\tmsg = (<-ch).(*XfrmMsgExpire)\n\tif msg.XfrmState.Spi != state.Spi {\n\t\tt.Fatal(\"Received unexpected msg, spi does not match\")\n\t}\n\thardFound = msg.Hard || hardFound\n\tsoftFound = !msg.Hard || softFound\n\n\tif !hardFound || !softFound {\n\t\tt.Fatal(\"Missing expire msg: hard found:\", hardFound, \"soft found:\", softFound)\n\t}\n}\n"
        },
        {
          "name": "xfrm_policy_linux.go",
          "type": "blob",
          "size": 10.58203125,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// Dir is an enum representing an ipsec template direction.\ntype Dir uint8\n\nconst (\n\tXFRM_DIR_IN Dir = iota\n\tXFRM_DIR_OUT\n\tXFRM_DIR_FWD\n\tXFRM_SOCKET_IN\n\tXFRM_SOCKET_OUT\n\tXFRM_SOCKET_FWD\n)\n\nfunc (d Dir) String() string {\n\tswitch d {\n\tcase XFRM_DIR_IN:\n\t\treturn \"dir in\"\n\tcase XFRM_DIR_OUT:\n\t\treturn \"dir out\"\n\tcase XFRM_DIR_FWD:\n\t\treturn \"dir fwd\"\n\tcase XFRM_SOCKET_IN:\n\t\treturn \"socket in\"\n\tcase XFRM_SOCKET_OUT:\n\t\treturn \"socket out\"\n\tcase XFRM_SOCKET_FWD:\n\t\treturn \"socket fwd\"\n\t}\n\treturn fmt.Sprintf(\"socket %d\", d-XFRM_SOCKET_IN)\n}\n\n// PolicyAction is an enum representing an ipsec policy action.\ntype PolicyAction uint8\n\nconst (\n\tXFRM_POLICY_ALLOW PolicyAction = 0\n\tXFRM_POLICY_BLOCK PolicyAction = 1\n)\n\nfunc (a PolicyAction) String() string {\n\tswitch a {\n\tcase XFRM_POLICY_ALLOW:\n\t\treturn \"allow\"\n\tcase XFRM_POLICY_BLOCK:\n\t\treturn \"block\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"action %d\", a)\n\t}\n}\n\n// XfrmPolicyTmpl encapsulates a rule for the base addresses of an ipsec\n// policy. These rules are matched with XfrmState to determine encryption\n// and authentication algorithms.\ntype XfrmPolicyTmpl struct {\n\tDst      net.IP\n\tSrc      net.IP\n\tProto    Proto\n\tMode     Mode\n\tSpi      int\n\tReqid    int\n\tOptional int\n}\n\nfunc (t XfrmPolicyTmpl) String() string {\n\treturn fmt.Sprintf(\"{Dst: %v, Src: %v, Proto: %s, Mode: %s, Spi: 0x%x, Reqid: 0x%x}\",\n\t\tt.Dst, t.Src, t.Proto, t.Mode, t.Spi, t.Reqid)\n}\n\n// XfrmPolicy represents an ipsec policy. It represents the overlay network\n// and has a list of XfrmPolicyTmpls representing the base addresses of\n// the policy.\ntype XfrmPolicy struct {\n\tDst      *net.IPNet\n\tSrc      *net.IPNet\n\tProto    Proto\n\tDstPort  int\n\tSrcPort  int\n\tDir      Dir\n\tPriority int\n\tIndex    int\n\tAction   PolicyAction\n\tIfindex  int\n\tIfid     int\n\tMark     *XfrmMark\n\tTmpls    []XfrmPolicyTmpl\n}\n\nfunc (p XfrmPolicy) String() string {\n\treturn fmt.Sprintf(\"{Dst: %v, Src: %v, Proto: %s, DstPort: %d, SrcPort: %d, Dir: %s, Priority: %d, Index: %d, Action: %s, Ifindex: %d, Ifid: %d, Mark: %s, Tmpls: %s}\",\n\t\tp.Dst, p.Src, p.Proto, p.DstPort, p.SrcPort, p.Dir, p.Priority, p.Index, p.Action, p.Ifindex, p.Ifid, p.Mark, p.Tmpls)\n}\n\nfunc selFromPolicy(sel *nl.XfrmSelector, policy *XfrmPolicy) {\n\tsel.Family = uint16(nl.FAMILY_V4)\n\tif policy.Dst != nil {\n\t\tsel.Family = uint16(nl.GetIPFamily(policy.Dst.IP))\n\t\tsel.Daddr.FromIP(policy.Dst.IP)\n\t\tprefixlenD, _ := policy.Dst.Mask.Size()\n\t\tsel.PrefixlenD = uint8(prefixlenD)\n\t}\n\tif policy.Src != nil {\n\t\tsel.Saddr.FromIP(policy.Src.IP)\n\t\tprefixlenS, _ := policy.Src.Mask.Size()\n\t\tsel.PrefixlenS = uint8(prefixlenS)\n\t}\n\tsel.Proto = uint8(policy.Proto)\n\tsel.Dport = nl.Swap16(uint16(policy.DstPort))\n\tsel.Sport = nl.Swap16(uint16(policy.SrcPort))\n\tif sel.Dport != 0 {\n\t\tsel.DportMask = ^uint16(0)\n\t}\n\tif sel.Sport != 0 {\n\t\tsel.SportMask = ^uint16(0)\n\t}\n\tsel.Ifindex = int32(policy.Ifindex)\n}\n\n// XfrmPolicyAdd will add an xfrm policy to the system.\n// Equivalent to: `ip xfrm policy add $policy`\nfunc XfrmPolicyAdd(policy *XfrmPolicy) error {\n\treturn pkgHandle.XfrmPolicyAdd(policy)\n}\n\n// XfrmPolicyAdd will add an xfrm policy to the system.\n// Equivalent to: `ip xfrm policy add $policy`\nfunc (h *Handle) XfrmPolicyAdd(policy *XfrmPolicy) error {\n\treturn h.xfrmPolicyAddOrUpdate(policy, nl.XFRM_MSG_NEWPOLICY)\n}\n\n// XfrmPolicyUpdate will update an xfrm policy to the system.\n// Equivalent to: `ip xfrm policy update $policy`\nfunc XfrmPolicyUpdate(policy *XfrmPolicy) error {\n\treturn pkgHandle.XfrmPolicyUpdate(policy)\n}\n\n// XfrmPolicyUpdate will update an xfrm policy to the system.\n// Equivalent to: `ip xfrm policy update $policy`\nfunc (h *Handle) XfrmPolicyUpdate(policy *XfrmPolicy) error {\n\treturn h.xfrmPolicyAddOrUpdate(policy, nl.XFRM_MSG_UPDPOLICY)\n}\n\nfunc (h *Handle) xfrmPolicyAddOrUpdate(policy *XfrmPolicy, nlProto int) error {\n\treq := h.newNetlinkRequest(nlProto, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\n\tmsg := &nl.XfrmUserpolicyInfo{}\n\tselFromPolicy(&msg.Sel, policy)\n\tmsg.Priority = uint32(policy.Priority)\n\tmsg.Index = uint32(policy.Index)\n\tmsg.Dir = uint8(policy.Dir)\n\tmsg.Action = uint8(policy.Action)\n\tmsg.Lft.SoftByteLimit = nl.XFRM_INF\n\tmsg.Lft.HardByteLimit = nl.XFRM_INF\n\tmsg.Lft.SoftPacketLimit = nl.XFRM_INF\n\tmsg.Lft.HardPacketLimit = nl.XFRM_INF\n\treq.AddData(msg)\n\n\ttmplData := make([]byte, nl.SizeofXfrmUserTmpl*len(policy.Tmpls))\n\tfor i, tmpl := range policy.Tmpls {\n\t\tstart := i * nl.SizeofXfrmUserTmpl\n\t\tuserTmpl := nl.DeserializeXfrmUserTmpl(tmplData[start : start+nl.SizeofXfrmUserTmpl])\n\t\tuserTmpl.XfrmId.Daddr.FromIP(tmpl.Dst)\n\t\tuserTmpl.Saddr.FromIP(tmpl.Src)\n\t\tuserTmpl.Family = uint16(nl.GetIPFamily(tmpl.Dst))\n\t\tuserTmpl.XfrmId.Proto = uint8(tmpl.Proto)\n\t\tuserTmpl.XfrmId.Spi = nl.Swap32(uint32(tmpl.Spi))\n\t\tuserTmpl.Mode = uint8(tmpl.Mode)\n\t\tuserTmpl.Reqid = uint32(tmpl.Reqid)\n\t\tuserTmpl.Optional = uint8(tmpl.Optional)\n\t\tuserTmpl.Aalgos = ^uint32(0)\n\t\tuserTmpl.Ealgos = ^uint32(0)\n\t\tuserTmpl.Calgos = ^uint32(0)\n\t}\n\tif len(tmplData) > 0 {\n\t\ttmpls := nl.NewRtAttr(nl.XFRMA_TMPL, tmplData)\n\t\treq.AddData(tmpls)\n\t}\n\tif policy.Mark != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_MARK, writeMark(policy.Mark))\n\t\treq.AddData(out)\n\t}\n\n\tif policy.Ifid != 0 {\n\t\tifId := nl.NewRtAttr(nl.XFRMA_IF_ID, nl.Uint32Attr(uint32(policy.Ifid)))\n\t\treq.AddData(ifId)\n\t}\n\n\t_, err := req.Execute(unix.NETLINK_XFRM, 0)\n\treturn err\n}\n\n// XfrmPolicyDel will delete an xfrm policy from the system. Note that\n// the Tmpls are ignored when matching the policy to delete.\n// Equivalent to: `ip xfrm policy del $policy`\nfunc XfrmPolicyDel(policy *XfrmPolicy) error {\n\treturn pkgHandle.XfrmPolicyDel(policy)\n}\n\n// XfrmPolicyDel will delete an xfrm policy from the system. Note that\n// the Tmpls are ignored when matching the policy to delete.\n// Equivalent to: `ip xfrm policy del $policy`\nfunc (h *Handle) XfrmPolicyDel(policy *XfrmPolicy) error {\n\t_, err := h.xfrmPolicyGetOrDelete(policy, nl.XFRM_MSG_DELPOLICY)\n\treturn err\n}\n\n// XfrmPolicyList gets a list of xfrm policies in the system.\n// Equivalent to: `ip xfrm policy show`.\n// The list can be filtered by ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc XfrmPolicyList(family int) ([]XfrmPolicy, error) {\n\treturn pkgHandle.XfrmPolicyList(family)\n}\n\n// XfrmPolicyList gets a list of xfrm policies in the system.\n// Equivalent to: `ip xfrm policy show`.\n// The list can be filtered by ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) XfrmPolicyList(family int) ([]XfrmPolicy, error) {\n\treq := h.newNetlinkRequest(nl.XFRM_MSG_GETPOLICY, unix.NLM_F_DUMP)\n\n\tmsg := nl.NewIfInfomsg(family)\n\treq.AddData(msg)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_XFRM, nl.XFRM_MSG_NEWPOLICY)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res []XfrmPolicy\n\tfor _, m := range msgs {\n\t\tif policy, err := parseXfrmPolicy(m, family); err == nil {\n\t\t\tres = append(res, *policy)\n\t\t} else if err == familyError {\n\t\t\tcontinue\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn res, executeErr\n}\n\n// XfrmPolicyGet gets a the policy described by the index or selector, if found.\n// Equivalent to: `ip xfrm policy get { SELECTOR | index INDEX } dir DIR [ctx CTX ] [ mark MARK [ mask MASK ] ] [ ptype PTYPE ]`.\nfunc XfrmPolicyGet(policy *XfrmPolicy) (*XfrmPolicy, error) {\n\treturn pkgHandle.XfrmPolicyGet(policy)\n}\n\n// XfrmPolicyGet gets a the policy described by the index or selector, if found.\n// Equivalent to: `ip xfrm policy get { SELECTOR | index INDEX } dir DIR [ctx CTX ] [ mark MARK [ mask MASK ] ] [ ptype PTYPE ]`.\nfunc (h *Handle) XfrmPolicyGet(policy *XfrmPolicy) (*XfrmPolicy, error) {\n\treturn h.xfrmPolicyGetOrDelete(policy, nl.XFRM_MSG_GETPOLICY)\n}\n\n// XfrmPolicyFlush will flush the policies on the system.\n// Equivalent to: `ip xfrm policy flush`\nfunc XfrmPolicyFlush() error {\n\treturn pkgHandle.XfrmPolicyFlush()\n}\n\n// XfrmPolicyFlush will flush the policies on the system.\n// Equivalent to: `ip xfrm policy flush`\nfunc (h *Handle) XfrmPolicyFlush() error {\n\treq := h.newNetlinkRequest(nl.XFRM_MSG_FLUSHPOLICY, unix.NLM_F_ACK)\n\t_, err := req.Execute(unix.NETLINK_XFRM, 0)\n\treturn err\n}\n\nfunc (h *Handle) xfrmPolicyGetOrDelete(policy *XfrmPolicy, nlProto int) (*XfrmPolicy, error) {\n\treq := h.newNetlinkRequest(nlProto, unix.NLM_F_ACK)\n\n\tmsg := &nl.XfrmUserpolicyId{}\n\tselFromPolicy(&msg.Sel, policy)\n\tmsg.Index = uint32(policy.Index)\n\tmsg.Dir = uint8(policy.Dir)\n\treq.AddData(msg)\n\n\tif policy.Mark != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_MARK, writeMark(policy.Mark))\n\t\treq.AddData(out)\n\t}\n\n\tif policy.Ifid != 0 {\n\t\tifId := nl.NewRtAttr(nl.XFRMA_IF_ID, nl.Uint32Attr(uint32(policy.Ifid)))\n\t\treq.AddData(ifId)\n\t}\n\n\tresType := nl.XFRM_MSG_NEWPOLICY\n\tif nlProto == nl.XFRM_MSG_DELPOLICY {\n\t\tresType = 0\n\t}\n\n\tmsgs, err := req.Execute(unix.NETLINK_XFRM, uint16(resType))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif nlProto == nl.XFRM_MSG_DELPOLICY {\n\t\treturn nil, err\n\t}\n\n\treturn parseXfrmPolicy(msgs[0], FAMILY_ALL)\n}\n\nfunc parseXfrmPolicy(m []byte, family int) (*XfrmPolicy, error) {\n\tmsg := nl.DeserializeXfrmUserpolicyInfo(m)\n\n\t// This is mainly for the policy dump\n\tif family != FAMILY_ALL && family != int(msg.Sel.Family) {\n\t\treturn nil, familyError\n\t}\n\n\tvar policy XfrmPolicy\n\n\tpolicy.Dst = msg.Sel.Daddr.ToIPNet(msg.Sel.PrefixlenD, uint16(family))\n\tpolicy.Src = msg.Sel.Saddr.ToIPNet(msg.Sel.PrefixlenS, uint16(family))\n\tpolicy.Proto = Proto(msg.Sel.Proto)\n\tpolicy.DstPort = int(nl.Swap16(msg.Sel.Dport))\n\tpolicy.SrcPort = int(nl.Swap16(msg.Sel.Sport))\n\tpolicy.Ifindex = int(msg.Sel.Ifindex)\n\tpolicy.Priority = int(msg.Priority)\n\tpolicy.Index = int(msg.Index)\n\tpolicy.Dir = Dir(msg.Dir)\n\tpolicy.Action = PolicyAction(msg.Action)\n\n\tattrs, err := nl.ParseRouteAttr(m[msg.Len():])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase nl.XFRMA_TMPL:\n\t\t\tmax := len(attr.Value)\n\t\t\tfor i := 0; i < max; i += nl.SizeofXfrmUserTmpl {\n\t\t\t\tvar resTmpl XfrmPolicyTmpl\n\t\t\t\ttmpl := nl.DeserializeXfrmUserTmpl(attr.Value[i : i+nl.SizeofXfrmUserTmpl])\n\t\t\t\tresTmpl.Dst = tmpl.XfrmId.Daddr.ToIP()\n\t\t\t\tresTmpl.Src = tmpl.Saddr.ToIP()\n\t\t\t\tresTmpl.Proto = Proto(tmpl.XfrmId.Proto)\n\t\t\t\tresTmpl.Mode = Mode(tmpl.Mode)\n\t\t\t\tresTmpl.Spi = int(nl.Swap32(tmpl.XfrmId.Spi))\n\t\t\t\tresTmpl.Reqid = int(tmpl.Reqid)\n\t\t\t\tresTmpl.Optional = int(tmpl.Optional)\n\t\t\t\tpolicy.Tmpls = append(policy.Tmpls, resTmpl)\n\t\t\t}\n\t\tcase nl.XFRMA_MARK:\n\t\t\tmark := nl.DeserializeXfrmMark(attr.Value[:])\n\t\t\tpolicy.Mark = new(XfrmMark)\n\t\t\tpolicy.Mark.Value = mark.Value\n\t\t\tpolicy.Mark.Mask = mark.Mask\n\t\tcase nl.XFRMA_IF_ID:\n\t\t\tpolicy.Ifid = int(native.Uint32(attr.Value))\n\t\t}\n\t}\n\n\treturn &policy, nil\n}\n"
        },
        {
          "name": "xfrm_policy_linux_test.go",
          "type": "blob",
          "size": 6.099609375,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"net\"\n\t\"testing\"\n)\n\nconst zeroCIDR = \"0.0.0.0/0\"\n\nfunc TestXfrmPolicyAddUpdateDel(t *testing.T) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\n\tpolicy := getPolicy()\n\tif err := XfrmPolicyAdd(policy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpolicies, err := XfrmPolicyList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(policies) != 1 {\n\t\tt.Fatal(\"Policy not added properly\")\n\t}\n\n\tif !comparePolicies(policy, &policies[0]) {\n\t\tt.Fatalf(\"unexpected policy returned.\\nExpected: %v.\\nGot %v\", policy, policies[0])\n\t}\n\n\tif policies[0].Ifindex != 0 {\n\t\tt.Fatalf(\"default policy has a non-zero interface index.\\nGot %d\", policies[0].Ifindex)\n\t}\n\n\tif policies[0].Ifid != 0 {\n\t\tt.Fatalf(\"default policy has non-zero if_id.\\nGot %d\", policies[0].Ifid)\n\t}\n\n\tif policies[0].Action != XFRM_POLICY_ALLOW {\n\t\tt.Fatalf(\"default policy has non-allow action.\\nGot %s\", policies[0].Action)\n\t}\n\n\t// Look for a specific policy\n\tsp, err := XfrmPolicyGet(policy)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !comparePolicies(policy, sp) {\n\t\tt.Fatalf(\"unexpected policy returned\")\n\t}\n\n\t// Modify the policy\n\tpolicy.Priority = 100\n\tif err := XfrmPolicyUpdate(policy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsp, err = XfrmPolicyGet(policy)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif sp.Priority != 100 {\n\t\tt.Fatalf(\"failed to modify the policy\")\n\t}\n\n\tif err = XfrmPolicyDel(policy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpolicies, err = XfrmPolicyList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(policies) != 0 {\n\t\tt.Fatal(\"Policy not removed properly\")\n\t}\n\n\t// Src and dst are not mandatory field. Creation should succeed\n\tpolicy.Src = nil\n\tpolicy.Dst = nil\n\tif err = XfrmPolicyAdd(policy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsp, err = XfrmPolicyGet(policy)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !comparePolicies(policy, sp) {\n\t\tt.Fatalf(\"unexpected policy returned\")\n\t}\n\n\tif err = XfrmPolicyDel(policy); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err := XfrmPolicyGet(policy); err == nil {\n\t\tt.Fatalf(\"Unexpected success\")\n\t}\n}\n\nfunc TestXfrmPolicyFlush(t *testing.T) {\n\tdefer setUpNetlinkTest(t)()\n\n\tp1 := getPolicy()\n\tif err := XfrmPolicyAdd(p1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tp1.Dir = XFRM_DIR_IN\n\ts := p1.Src\n\tp1.Src = p1.Dst\n\tp1.Dst = s\n\tif err := XfrmPolicyAdd(p1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpolicies, err := XfrmPolicyList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(policies) != 2 {\n\t\tt.Fatalf(\"unexpected number of policies: %d\", len(policies))\n\t}\n\n\tif err := XfrmPolicyFlush(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpolicies, err = XfrmPolicyList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(policies) != 0 {\n\t\tt.Fatalf(\"unexpected number of policies: %d\", len(policies))\n\t}\n\n}\n\nfunc TestXfrmPolicyBlockWithIfindex(t *testing.T) {\n\tdefer setUpNetlinkTest(t)()\n\n\tpBlock := getPolicy()\n\tpBlock.Action = XFRM_POLICY_BLOCK\n\tpBlock.Ifindex = 1 // loopback interface\n\tif err := XfrmPolicyAdd(pBlock); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpolicies, err := XfrmPolicyList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(policies) != 1 {\n\t\tt.Fatalf(\"unexpected number of policies: %d\", len(policies))\n\t}\n\tif !comparePolicies(pBlock, &policies[0]) {\n\t\tt.Fatalf(\"unexpected policy returned.\\nExpected: %v.\\nGot %v\", pBlock, policies[0])\n\t}\n\tif err = XfrmPolicyDel(pBlock); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestXfrmPolicyWithIfid(t *testing.T) {\n\tminKernelRequired(t, 4, 19)\n\tdefer setUpNetlinkTest(t)()\n\n\tpol := getPolicy()\n\tpol.Ifid = 54321\n\n\tif err := XfrmPolicyAdd(pol); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpolicies, err := XfrmPolicyList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(policies) != 1 {\n\t\tt.Fatalf(\"unexpected number of policies: %d\", len(policies))\n\t}\n\tif !comparePolicies(pol, &policies[0]) {\n\t\tt.Fatalf(\"unexpected policy returned.\\nExpected: %v.\\nGot %v\", pol, policies[0])\n\t}\n\tif err = XfrmPolicyDel(&policies[0]); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestXfrmPolicyWithOptional(t *testing.T) {\n\tminKernelRequired(t, 4, 19)\n\tdefer setUpNetlinkTest(t)()\n\n\tpol := getPolicy()\n\tpol.Dir = XFRM_DIR_IN\n\tpol.Tmpls[0].Optional = 1\n\n\tif err := XfrmPolicyAdd(pol); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpolicies, err := XfrmPolicyList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(policies) != 1 {\n\t\tt.Fatalf(\"unexpected number of policies: %d\", len(policies))\n\t}\n\tif !comparePolicies(pol, &policies[0]) {\n\t\tt.Fatalf(\"unexpected policy returned.\\nExpected: %v.\\nGot %v\", pol, policies[0])\n\t}\n\tif err = XfrmPolicyDel(&policies[0]); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc comparePolicies(a, b *XfrmPolicy) bool {\n\tif a == b {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\t// Do not check Index which is assigned by kernel\n\treturn a.Dir == b.Dir && a.Priority == b.Priority &&\n\t\tcompareIPNet(a.Src, b.Src) && compareIPNet(a.Dst, b.Dst) &&\n\t\ta.Action == b.Action && a.Ifindex == b.Ifindex &&\n\t\ta.Mark.Value == b.Mark.Value && a.Mark.Mask == b.Mark.Mask &&\n\t\ta.Ifid == b.Ifid && compareTemplates(a.Tmpls, b.Tmpls)\n}\n\nfunc compareTemplates(a, b []XfrmPolicyTmpl) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, ta := range a {\n\t\ttb := b[i]\n\t\tif !ta.Dst.Equal(tb.Dst) || !ta.Src.Equal(tb.Src) || ta.Spi != tb.Spi ||\n\t\t\tta.Mode != tb.Mode || ta.Reqid != tb.Reqid || ta.Proto != tb.Proto ||\n\t\t\tta.Optional != tb.Optional {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareIPNet(a, b *net.IPNet) bool {\n\tif a == b {\n\t\treturn true\n\t}\n\t// For unspecified src/dst parseXfrmPolicy would set the zero address cidr\n\tif (a == nil && b.String() == zeroCIDR) || (b == nil && a.String() == zeroCIDR) {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.IP.Equal(b.IP) && bytes.Equal(a.Mask, b.Mask)\n}\n\nfunc getPolicy() *XfrmPolicy {\n\tsrc, _ := ParseIPNet(\"127.1.1.1/32\")\n\tdst, _ := ParseIPNet(\"127.1.1.2/32\")\n\tpolicy := &XfrmPolicy{\n\t\tSrc:     src,\n\t\tDst:     dst,\n\t\tProto:   17,\n\t\tDstPort: 1234,\n\t\tSrcPort: 5678,\n\t\tDir:     XFRM_DIR_OUT,\n\t\tMark: &XfrmMark{\n\t\t\tValue: 0xabff22,\n\t\t\tMask:  0xffffffff,\n\t\t},\n\t\tPriority: 10,\n\t}\n\ttmpl := XfrmPolicyTmpl{\n\t\tSrc:   net.ParseIP(\"127.0.0.1\"),\n\t\tDst:   net.ParseIP(\"127.0.0.2\"),\n\t\tProto: XFRM_PROTO_ESP,\n\t\tMode:  XFRM_MODE_TUNNEL,\n\t\tSpi:   0x1bcdef99,\n\t}\n\tpolicy.Tmpls = append(policy.Tmpls, tmpl)\n\treturn policy\n}\n"
        },
        {
          "name": "xfrm_state_linux.go",
          "type": "blob",
          "size": 19.4189453125,
          "content": "package netlink\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// XfrmStateAlgo represents the algorithm to use for the ipsec encryption.\ntype XfrmStateAlgo struct {\n\tName        string\n\tKey         []byte\n\tTruncateLen int // Auth only\n\tICVLen      int // AEAD only\n}\n\nfunc (a XfrmStateAlgo) String() string {\n\tbase := fmt.Sprintf(\"{Name: %s, Key: 0x%x\", a.Name, a.Key)\n\tif a.TruncateLen != 0 {\n\t\tbase = fmt.Sprintf(\"%s, Truncate length: %d\", base, a.TruncateLen)\n\t}\n\tif a.ICVLen != 0 {\n\t\tbase = fmt.Sprintf(\"%s, ICV length: %d\", base, a.ICVLen)\n\t}\n\treturn fmt.Sprintf(\"%s}\", base)\n}\n\n// EncapType is an enum representing the optional packet encapsulation.\ntype EncapType uint8\n\nconst (\n\tXFRM_ENCAP_ESPINUDP_NONIKE EncapType = iota + 1\n\tXFRM_ENCAP_ESPINUDP\n)\n\nfunc (e EncapType) String() string {\n\tswitch e {\n\tcase XFRM_ENCAP_ESPINUDP_NONIKE:\n\t\treturn \"espinudp-non-ike\"\n\tcase XFRM_ENCAP_ESPINUDP:\n\t\treturn \"espinudp\"\n\t}\n\treturn \"unknown\"\n}\n\n// XfrmStateEncap represents the encapsulation to use for the ipsec encryption.\ntype XfrmStateEncap struct {\n\tType            EncapType\n\tSrcPort         int\n\tDstPort         int\n\tOriginalAddress net.IP\n}\n\nfunc (e XfrmStateEncap) String() string {\n\treturn fmt.Sprintf(\"{Type: %s, Srcport: %d, DstPort: %d, OriginalAddress: %v}\",\n\t\te.Type, e.SrcPort, e.DstPort, e.OriginalAddress)\n}\n\n// XfrmStateLimits represents the configured limits for the state.\ntype XfrmStateLimits struct {\n\tByteSoft    uint64\n\tByteHard    uint64\n\tPacketSoft  uint64\n\tPacketHard  uint64\n\tTimeSoft    uint64\n\tTimeHard    uint64\n\tTimeUseSoft uint64\n\tTimeUseHard uint64\n}\n\n// XfrmStateStats represents the current number of bytes/packets\n// processed by this State, the State's installation and first use\n// time and the replay window counters.\ntype XfrmStateStats struct {\n\tReplayWindow uint32\n\tReplay       uint32\n\tFailed       uint32\n\tBytes        uint64\n\tPackets      uint64\n\tAddTime      uint64\n\tUseTime      uint64\n}\n\n// XfrmReplayState represents the sequence number states for\n// \"legacy\" anti-replay mode.\ntype XfrmReplayState struct {\n\tOSeq   uint32\n\tSeq    uint32\n\tBitMap uint32\n}\n\nfunc (r XfrmReplayState) String() string {\n\treturn fmt.Sprintf(\"{OSeq: 0x%x, Seq: 0x%x, BitMap: 0x%x}\",\n\t\tr.OSeq, r.Seq, r.BitMap)\n}\n\n// XfrmState represents the state of an ipsec policy. It optionally\n// contains an XfrmStateAlgo for encryption and one for authentication.\ntype XfrmState struct {\n\tDst           net.IP\n\tSrc           net.IP\n\tProto         Proto\n\tMode          Mode\n\tSpi           int\n\tReqid         int\n\tReplayWindow  int\n\tLimits        XfrmStateLimits\n\tStatistics    XfrmStateStats\n\tMark          *XfrmMark\n\tOutputMark    *XfrmMark\n\tIfid          int\n\tAuth          *XfrmStateAlgo\n\tCrypt         *XfrmStateAlgo\n\tAead          *XfrmStateAlgo\n\tEncap         *XfrmStateEncap\n\tESN           bool\n\tDontEncapDSCP bool\n\tOSeqMayWrap   bool\n\tReplay        *XfrmReplayState\n\tSelector      *XfrmPolicy\n}\n\nfunc (sa XfrmState) String() string {\n\treturn fmt.Sprintf(\"Dst: %v, Src: %v, Proto: %s, Mode: %s, SPI: 0x%x, ReqID: 0x%x, ReplayWindow: %d, Mark: %v, OutputMark: %v, Ifid: %d, Auth: %v, Crypt: %v, Aead: %v, Encap: %v, ESN: %t, DontEncapDSCP: %t, OSeqMayWrap: %t, Replay: %v\",\n\t\tsa.Dst, sa.Src, sa.Proto, sa.Mode, sa.Spi, sa.Reqid, sa.ReplayWindow, sa.Mark, sa.OutputMark, sa.Ifid, sa.Auth, sa.Crypt, sa.Aead, sa.Encap, sa.ESN, sa.DontEncapDSCP, sa.OSeqMayWrap, sa.Replay)\n}\nfunc (sa XfrmState) Print(stats bool) string {\n\tif !stats {\n\t\treturn sa.String()\n\t}\n\tat := time.Unix(int64(sa.Statistics.AddTime), 0).Format(time.UnixDate)\n\tut := \"-\"\n\tif sa.Statistics.UseTime > 0 {\n\t\tut = time.Unix(int64(sa.Statistics.UseTime), 0).Format(time.UnixDate)\n\t}\n\treturn fmt.Sprintf(\"%s, ByteSoft: %s, ByteHard: %s, PacketSoft: %s, PacketHard: %s, TimeSoft: %d, TimeHard: %d, TimeUseSoft: %d, TimeUseHard: %d, Bytes: %d, Packets: %d, \"+\n\t\t\"AddTime: %s, UseTime: %s, ReplayWindow: %d, Replay: %d, Failed: %d\",\n\t\tsa.String(), printLimit(sa.Limits.ByteSoft), printLimit(sa.Limits.ByteHard), printLimit(sa.Limits.PacketSoft), printLimit(sa.Limits.PacketHard),\n\t\tsa.Limits.TimeSoft, sa.Limits.TimeHard, sa.Limits.TimeUseSoft, sa.Limits.TimeUseHard, sa.Statistics.Bytes, sa.Statistics.Packets, at, ut,\n\t\tsa.Statistics.ReplayWindow, sa.Statistics.Replay, sa.Statistics.Failed)\n}\n\nfunc printLimit(lmt uint64) string {\n\tif lmt == ^uint64(0) {\n\t\treturn \"(INF)\"\n\t}\n\treturn fmt.Sprintf(\"%d\", lmt)\n}\nfunc writeStateAlgo(a *XfrmStateAlgo) []byte {\n\talgo := nl.XfrmAlgo{\n\t\tAlgKeyLen: uint32(len(a.Key) * 8),\n\t\tAlgKey:    a.Key,\n\t}\n\tend := len(a.Name)\n\tif end > 64 {\n\t\tend = 64\n\t}\n\tcopy(algo.AlgName[:end], a.Name)\n\treturn algo.Serialize()\n}\n\nfunc writeStateAlgoAuth(a *XfrmStateAlgo) []byte {\n\talgo := nl.XfrmAlgoAuth{\n\t\tAlgKeyLen:   uint32(len(a.Key) * 8),\n\t\tAlgTruncLen: uint32(a.TruncateLen),\n\t\tAlgKey:      a.Key,\n\t}\n\tend := len(a.Name)\n\tif end > 64 {\n\t\tend = 64\n\t}\n\tcopy(algo.AlgName[:end], a.Name)\n\treturn algo.Serialize()\n}\n\nfunc writeStateAlgoAead(a *XfrmStateAlgo) []byte {\n\talgo := nl.XfrmAlgoAEAD{\n\t\tAlgKeyLen: uint32(len(a.Key) * 8),\n\t\tAlgICVLen: uint32(a.ICVLen),\n\t\tAlgKey:    a.Key,\n\t}\n\tend := len(a.Name)\n\tif end > 64 {\n\t\tend = 64\n\t}\n\tcopy(algo.AlgName[:end], a.Name)\n\treturn algo.Serialize()\n}\n\nfunc writeMark(m *XfrmMark) []byte {\n\tmark := &nl.XfrmMark{\n\t\tValue: m.Value,\n\t\tMask:  m.Mask,\n\t}\n\tif mark.Mask == 0 {\n\t\tmark.Mask = ^uint32(0)\n\t}\n\treturn mark.Serialize()\n}\n\nfunc writeReplayEsn(replayWindow int) []byte {\n\treplayEsn := &nl.XfrmReplayStateEsn{\n\t\tOSeq:         0,\n\t\tSeq:          0,\n\t\tOSeqHi:       0,\n\t\tSeqHi:        0,\n\t\tReplayWindow: uint32(replayWindow),\n\t}\n\n\t// Linux stores the bitmap to identify the already received sequence packets in blocks of uint32 elements.\n\t// Therefore bitmap length is the minimum number of uint32 elements needed. The following is a ceiling operation.\n\tbytesPerElem := int(unsafe.Sizeof(replayEsn.BmpLen)) // Any uint32 variable is good for this\n\treplayEsn.BmpLen = uint32((replayWindow + (bytesPerElem * 8) - 1) / (bytesPerElem * 8))\n\n\treturn replayEsn.Serialize()\n}\n\nfunc writeReplay(r *XfrmReplayState) []byte {\n\treturn (&nl.XfrmReplayState{\n\t\tOSeq:   r.OSeq,\n\t\tSeq:    r.Seq,\n\t\tBitMap: r.BitMap,\n\t}).Serialize()\n}\n\n// XfrmStateAdd will add an xfrm state to the system.\n// Equivalent to: `ip xfrm state add $state`\nfunc XfrmStateAdd(state *XfrmState) error {\n\treturn pkgHandle.XfrmStateAdd(state)\n}\n\n// XfrmStateAdd will add an xfrm state to the system.\n// Equivalent to: `ip xfrm state add $state`\nfunc (h *Handle) XfrmStateAdd(state *XfrmState) error {\n\treturn h.xfrmStateAddOrUpdate(state, nl.XFRM_MSG_NEWSA)\n}\n\n// XfrmStateAllocSpi will allocate an xfrm state in the system.\n// Equivalent to: `ip xfrm state allocspi`\nfunc XfrmStateAllocSpi(state *XfrmState) (*XfrmState, error) {\n\treturn pkgHandle.xfrmStateAllocSpi(state)\n}\n\n// XfrmStateUpdate will update an xfrm state to the system.\n// Equivalent to: `ip xfrm state update $state`\nfunc XfrmStateUpdate(state *XfrmState) error {\n\treturn pkgHandle.XfrmStateUpdate(state)\n}\n\n// XfrmStateUpdate will update an xfrm state to the system.\n// Equivalent to: `ip xfrm state update $state`\nfunc (h *Handle) XfrmStateUpdate(state *XfrmState) error {\n\treturn h.xfrmStateAddOrUpdate(state, nl.XFRM_MSG_UPDSA)\n}\n\nfunc (h *Handle) xfrmStateAddOrUpdate(state *XfrmState, nlProto int) error {\n\n\t// A state with spi 0 can't be deleted so don't allow it to be set\n\tif state.Spi == 0 {\n\t\treturn fmt.Errorf(\"Spi must be set when adding xfrm state\")\n\t}\n\treq := h.newNetlinkRequest(nlProto, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\n\tmsg := xfrmUsersaInfoFromXfrmState(state)\n\n\tif state.ESN {\n\t\tif state.ReplayWindow == 0 {\n\t\t\treturn fmt.Errorf(\"ESN flag set without ReplayWindow\")\n\t\t}\n\t\tmsg.Flags |= nl.XFRM_STATE_ESN\n\t\tmsg.ReplayWindow = 0\n\t}\n\n\tlimitsToLft(state.Limits, &msg.Lft)\n\treq.AddData(msg)\n\n\tif state.Auth != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_ALG_AUTH_TRUNC, writeStateAlgoAuth(state.Auth))\n\t\treq.AddData(out)\n\t}\n\tif state.Crypt != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_ALG_CRYPT, writeStateAlgo(state.Crypt))\n\t\treq.AddData(out)\n\t}\n\tif state.Aead != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_ALG_AEAD, writeStateAlgoAead(state.Aead))\n\t\treq.AddData(out)\n\t}\n\tif state.Encap != nil {\n\t\tencapData := make([]byte, nl.SizeofXfrmEncapTmpl)\n\t\tencap := nl.DeserializeXfrmEncapTmpl(encapData)\n\t\tencap.EncapType = uint16(state.Encap.Type)\n\t\tencap.EncapSport = nl.Swap16(uint16(state.Encap.SrcPort))\n\t\tencap.EncapDport = nl.Swap16(uint16(state.Encap.DstPort))\n\t\tencap.EncapOa.FromIP(state.Encap.OriginalAddress)\n\t\tout := nl.NewRtAttr(nl.XFRMA_ENCAP, encapData)\n\t\treq.AddData(out)\n\t}\n\tif state.Mark != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_MARK, writeMark(state.Mark))\n\t\treq.AddData(out)\n\t}\n\tif state.ESN {\n\t\tout := nl.NewRtAttr(nl.XFRMA_REPLAY_ESN_VAL, writeReplayEsn(state.ReplayWindow))\n\t\treq.AddData(out)\n\t}\n\tif state.OutputMark != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_SET_MARK, nl.Uint32Attr(state.OutputMark.Value))\n\t\treq.AddData(out)\n\t\tif state.OutputMark.Mask != 0 {\n\t\t\tout = nl.NewRtAttr(nl.XFRMA_SET_MARK_MASK, nl.Uint32Attr(state.OutputMark.Mask))\n\t\t\treq.AddData(out)\n\t\t}\n\t}\n\tif state.OSeqMayWrap || state.DontEncapDSCP {\n\t\tvar flags uint32\n\t\tif state.DontEncapDSCP {\n\t\t\tflags |= nl.XFRM_SA_XFLAG_DONT_ENCAP_DSCP\n\t\t}\n\t\tif state.OSeqMayWrap {\n\t\t\tflags |= nl.XFRM_SA_XFLAG_OSEQ_MAY_WRAP\n\t\t}\n\t\tout := nl.NewRtAttr(nl.XFRMA_SA_EXTRA_FLAGS, nl.Uint32Attr(flags))\n\t\treq.AddData(out)\n\t}\n\tif state.Replay != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_REPLAY_VAL, writeReplay(state.Replay))\n\t\treq.AddData(out)\n\t}\n\n\tif state.Ifid != 0 {\n\t\tifId := nl.NewRtAttr(nl.XFRMA_IF_ID, nl.Uint32Attr(uint32(state.Ifid)))\n\t\treq.AddData(ifId)\n\t}\n\n\t_, err := req.Execute(unix.NETLINK_XFRM, 0)\n\treturn err\n}\n\nfunc (h *Handle) xfrmStateAllocSpi(state *XfrmState) (*XfrmState, error) {\n\treq := h.newNetlinkRequest(nl.XFRM_MSG_ALLOCSPI,\n\t\tunix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\n\tmsg := &nl.XfrmUserSpiInfo{}\n\tmsg.XfrmUsersaInfo = *(xfrmUsersaInfoFromXfrmState(state))\n\t// 1-255 is reserved by IANA for future use\n\tmsg.Min = 0x100\n\tmsg.Max = 0xffffffff\n\treq.AddData(msg)\n\tif state.Mark != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_MARK, writeMark(state.Mark))\n\t\treq.AddData(out)\n\t}\n\n\tmsgs, err := req.Execute(unix.NETLINK_XFRM, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn parseXfrmState(msgs[0], FAMILY_ALL)\n}\n\n// XfrmStateDel will delete an xfrm state from the system. Note that\n// the Algos are ignored when matching the state to delete.\n// Equivalent to: `ip xfrm state del $state`\nfunc XfrmStateDel(state *XfrmState) error {\n\treturn pkgHandle.XfrmStateDel(state)\n}\n\n// XfrmStateDel will delete an xfrm state from the system. Note that\n// the Algos are ignored when matching the state to delete.\n// Equivalent to: `ip xfrm state del $state`\nfunc (h *Handle) XfrmStateDel(state *XfrmState) error {\n\t_, err := h.xfrmStateGetOrDelete(state, nl.XFRM_MSG_DELSA)\n\treturn err\n}\n\n// XfrmStateList gets a list of xfrm states in the system.\n// Equivalent to: `ip [-4|-6] xfrm state show`.\n// The list can be filtered by ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc XfrmStateList(family int) ([]XfrmState, error) {\n\treturn pkgHandle.XfrmStateList(family)\n}\n\n// XfrmStateList gets a list of xfrm states in the system.\n// Equivalent to: `ip xfrm state show`.\n// The list can be filtered by ip family.\n//\n// If the returned error is [ErrDumpInterrupted], results may be inconsistent\n// or incomplete.\nfunc (h *Handle) XfrmStateList(family int) ([]XfrmState, error) {\n\treq := h.newNetlinkRequest(nl.XFRM_MSG_GETSA, unix.NLM_F_DUMP)\n\n\tmsgs, executeErr := req.Execute(unix.NETLINK_XFRM, nl.XFRM_MSG_NEWSA)\n\tif executeErr != nil && !errors.Is(executeErr, ErrDumpInterrupted) {\n\t\treturn nil, executeErr\n\t}\n\n\tvar res []XfrmState\n\tfor _, m := range msgs {\n\t\tif state, err := parseXfrmState(m, family); err == nil {\n\t\t\tres = append(res, *state)\n\t\t} else if err == familyError {\n\t\t\tcontinue\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn res, executeErr\n}\n\n// XfrmStateGet gets the xfrm state described by the ID, if found.\n// Equivalent to: `ip xfrm state get ID [ mark MARK [ mask MASK ] ]`.\n// Only the fields which constitue the SA ID must be filled in:\n// ID := [ src ADDR ] [ dst ADDR ] [ proto XFRM-PROTO ] [ spi SPI ]\n// mark is optional\nfunc XfrmStateGet(state *XfrmState) (*XfrmState, error) {\n\treturn pkgHandle.XfrmStateGet(state)\n}\n\n// XfrmStateGet gets the xfrm state described by the ID, if found.\n// Equivalent to: `ip xfrm state get ID [ mark MARK [ mask MASK ] ]`.\n// Only the fields which constitue the SA ID must be filled in:\n// ID := [ src ADDR ] [ dst ADDR ] [ proto XFRM-PROTO ] [ spi SPI ]\n// mark is optional\nfunc (h *Handle) XfrmStateGet(state *XfrmState) (*XfrmState, error) {\n\treturn h.xfrmStateGetOrDelete(state, nl.XFRM_MSG_GETSA)\n}\n\nfunc (h *Handle) xfrmStateGetOrDelete(state *XfrmState, nlProto int) (*XfrmState, error) {\n\treq := h.newNetlinkRequest(nlProto, unix.NLM_F_ACK)\n\n\tmsg := &nl.XfrmUsersaId{}\n\tmsg.Family = uint16(nl.GetIPFamily(state.Dst))\n\tmsg.Daddr.FromIP(state.Dst)\n\tmsg.Proto = uint8(state.Proto)\n\tmsg.Spi = nl.Swap32(uint32(state.Spi))\n\treq.AddData(msg)\n\n\tif state.Mark != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_MARK, writeMark(state.Mark))\n\t\treq.AddData(out)\n\t}\n\tif state.Src != nil {\n\t\tout := nl.NewRtAttr(nl.XFRMA_SRCADDR, state.Src.To16())\n\t\treq.AddData(out)\n\t}\n\n\tif state.Ifid != 0 {\n\t\tifId := nl.NewRtAttr(nl.XFRMA_IF_ID, nl.Uint32Attr(uint32(state.Ifid)))\n\t\treq.AddData(ifId)\n\t}\n\n\tresType := nl.XFRM_MSG_NEWSA\n\tif nlProto == nl.XFRM_MSG_DELSA {\n\t\tresType = 0\n\t}\n\n\tmsgs, err := req.Execute(unix.NETLINK_XFRM, uint16(resType))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif nlProto == nl.XFRM_MSG_DELSA {\n\t\treturn nil, nil\n\t}\n\n\ts, err := parseXfrmState(msgs[0], FAMILY_ALL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s, nil\n}\n\nvar familyError = fmt.Errorf(\"family error\")\n\nfunc xfrmStateFromXfrmUsersaInfo(msg *nl.XfrmUsersaInfo) *XfrmState {\n\tvar state XfrmState\n\tstate.Dst = msg.Id.Daddr.ToIP()\n\tstate.Src = msg.Saddr.ToIP()\n\tstate.Proto = Proto(msg.Id.Proto)\n\tstate.Mode = Mode(msg.Mode)\n\tstate.Spi = int(nl.Swap32(msg.Id.Spi))\n\tstate.Reqid = int(msg.Reqid)\n\tstate.ReplayWindow = int(msg.ReplayWindow)\n\tlftToLimits(&msg.Lft, &state.Limits)\n\tcurToStats(&msg.Curlft, &msg.Stats, &state.Statistics)\n\tstate.Selector = &XfrmPolicy{\n\t\tDst:     msg.Sel.Daddr.ToIPNet(msg.Sel.PrefixlenD, msg.Sel.Family),\n\t\tSrc:     msg.Sel.Saddr.ToIPNet(msg.Sel.PrefixlenS, msg.Sel.Family),\n\t\tProto:   Proto(msg.Sel.Proto),\n\t\tDstPort: int(nl.Swap16(msg.Sel.Dport)),\n\t\tSrcPort: int(nl.Swap16(msg.Sel.Sport)),\n\t\tIfindex: int(msg.Sel.Ifindex),\n\t}\n\n\treturn &state\n}\n\nfunc parseXfrmState(m []byte, family int) (*XfrmState, error) {\n\tmsg := nl.DeserializeXfrmUsersaInfo(m)\n\t// This is mainly for the state dump\n\tif family != FAMILY_ALL && family != int(msg.Family) {\n\t\treturn nil, familyError\n\t}\n\tstate := xfrmStateFromXfrmUsersaInfo(msg)\n\tattrs, err := nl.ParseRouteAttr(m[nl.SizeofXfrmUsersaInfo:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, attr := range attrs {\n\t\tswitch attr.Attr.Type {\n\t\tcase nl.XFRMA_ALG_AUTH, nl.XFRMA_ALG_CRYPT:\n\t\t\tvar resAlgo *XfrmStateAlgo\n\t\t\tif attr.Attr.Type == nl.XFRMA_ALG_AUTH {\n\t\t\t\tif state.Auth == nil {\n\t\t\t\t\tstate.Auth = new(XfrmStateAlgo)\n\t\t\t\t}\n\t\t\t\tresAlgo = state.Auth\n\t\t\t} else {\n\t\t\t\tstate.Crypt = new(XfrmStateAlgo)\n\t\t\t\tresAlgo = state.Crypt\n\t\t\t}\n\t\t\talgo := nl.DeserializeXfrmAlgo(attr.Value[:])\n\t\t\t(*resAlgo).Name = nl.BytesToString(algo.AlgName[:])\n\t\t\t(*resAlgo).Key = algo.AlgKey\n\t\tcase nl.XFRMA_ALG_AUTH_TRUNC:\n\t\t\tif state.Auth == nil {\n\t\t\t\tstate.Auth = new(XfrmStateAlgo)\n\t\t\t}\n\t\t\talgo := nl.DeserializeXfrmAlgoAuth(attr.Value[:])\n\t\t\tstate.Auth.Name = nl.BytesToString(algo.AlgName[:])\n\t\t\tstate.Auth.Key = algo.AlgKey\n\t\t\tstate.Auth.TruncateLen = int(algo.AlgTruncLen)\n\t\tcase nl.XFRMA_ALG_AEAD:\n\t\t\tstate.Aead = new(XfrmStateAlgo)\n\t\t\talgo := nl.DeserializeXfrmAlgoAEAD(attr.Value[:])\n\t\t\tstate.Aead.Name = nl.BytesToString(algo.AlgName[:])\n\t\t\tstate.Aead.Key = algo.AlgKey\n\t\t\tstate.Aead.ICVLen = int(algo.AlgICVLen)\n\t\tcase nl.XFRMA_ENCAP:\n\t\t\tencap := nl.DeserializeXfrmEncapTmpl(attr.Value[:])\n\t\t\tstate.Encap = new(XfrmStateEncap)\n\t\t\tstate.Encap.Type = EncapType(encap.EncapType)\n\t\t\tstate.Encap.SrcPort = int(nl.Swap16(encap.EncapSport))\n\t\t\tstate.Encap.DstPort = int(nl.Swap16(encap.EncapDport))\n\t\t\tstate.Encap.OriginalAddress = encap.EncapOa.ToIP()\n\t\tcase nl.XFRMA_MARK:\n\t\t\tmark := nl.DeserializeXfrmMark(attr.Value[:])\n\t\t\tstate.Mark = new(XfrmMark)\n\t\t\tstate.Mark.Value = mark.Value\n\t\t\tstate.Mark.Mask = mark.Mask\n\t\tcase nl.XFRMA_SA_EXTRA_FLAGS:\n\t\t\tflags := native.Uint32(attr.Value)\n\t\t\tif (flags & nl.XFRM_SA_XFLAG_DONT_ENCAP_DSCP) != 0 {\n\t\t\t\tstate.DontEncapDSCP = true\n\t\t\t}\n\t\t\tif (flags & nl.XFRM_SA_XFLAG_OSEQ_MAY_WRAP) != 0 {\n\t\t\t\tstate.OSeqMayWrap = true\n\t\t\t}\n\t\tcase nl.XFRMA_SET_MARK:\n\t\t\tif state.OutputMark == nil {\n\t\t\t\tstate.OutputMark = new(XfrmMark)\n\t\t\t}\n\t\t\tstate.OutputMark.Value = native.Uint32(attr.Value)\n\t\tcase nl.XFRMA_SET_MARK_MASK:\n\t\t\tif state.OutputMark == nil {\n\t\t\t\tstate.OutputMark = new(XfrmMark)\n\t\t\t}\n\t\t\tstate.OutputMark.Mask = native.Uint32(attr.Value)\n\t\t\tif state.OutputMark.Mask == 0xffffffff {\n\t\t\t\tstate.OutputMark.Mask = 0\n\t\t\t}\n\t\tcase nl.XFRMA_IF_ID:\n\t\t\tstate.Ifid = int(native.Uint32(attr.Value))\n\t\tcase nl.XFRMA_REPLAY_VAL:\n\t\t\tif state.Replay == nil {\n\t\t\t\tstate.Replay = new(XfrmReplayState)\n\t\t\t}\n\t\t\treplay := nl.DeserializeXfrmReplayState(attr.Value[:])\n\t\t\tstate.Replay.OSeq = replay.OSeq\n\t\t\tstate.Replay.Seq = replay.Seq\n\t\t\tstate.Replay.BitMap = replay.BitMap\n\t\t}\n\t}\n\n\treturn state, nil\n}\n\n// XfrmStateFlush will flush the xfrm state on the system.\n// proto = 0 means any transformation protocols\n// Equivalent to: `ip xfrm state flush [ proto XFRM-PROTO ]`\nfunc XfrmStateFlush(proto Proto) error {\n\treturn pkgHandle.XfrmStateFlush(proto)\n}\n\n// XfrmStateFlush will flush the xfrm state on the system.\n// proto = 0 means any transformation protocols\n// Equivalent to: `ip xfrm state flush [ proto XFRM-PROTO ]`\nfunc (h *Handle) XfrmStateFlush(proto Proto) error {\n\treq := h.newNetlinkRequest(nl.XFRM_MSG_FLUSHSA, unix.NLM_F_ACK)\n\n\treq.AddData(&nl.XfrmUsersaFlush{Proto: uint8(proto)})\n\n\t_, err := req.Execute(unix.NETLINK_XFRM, 0)\n\treturn err\n}\n\nfunc limitsToLft(lmts XfrmStateLimits, lft *nl.XfrmLifetimeCfg) {\n\tif lmts.ByteSoft != 0 {\n\t\tlft.SoftByteLimit = lmts.ByteSoft\n\t} else {\n\t\tlft.SoftByteLimit = nl.XFRM_INF\n\t}\n\tif lmts.ByteHard != 0 {\n\t\tlft.HardByteLimit = lmts.ByteHard\n\t} else {\n\t\tlft.HardByteLimit = nl.XFRM_INF\n\t}\n\tif lmts.PacketSoft != 0 {\n\t\tlft.SoftPacketLimit = lmts.PacketSoft\n\t} else {\n\t\tlft.SoftPacketLimit = nl.XFRM_INF\n\t}\n\tif lmts.PacketHard != 0 {\n\t\tlft.HardPacketLimit = lmts.PacketHard\n\t} else {\n\t\tlft.HardPacketLimit = nl.XFRM_INF\n\t}\n\tlft.SoftAddExpiresSeconds = lmts.TimeSoft\n\tlft.HardAddExpiresSeconds = lmts.TimeHard\n\tlft.SoftUseExpiresSeconds = lmts.TimeUseSoft\n\tlft.HardUseExpiresSeconds = lmts.TimeUseHard\n}\n\nfunc lftToLimits(lft *nl.XfrmLifetimeCfg, lmts *XfrmStateLimits) {\n\t*lmts = *(*XfrmStateLimits)(unsafe.Pointer(lft))\n}\n\nfunc curToStats(cur *nl.XfrmLifetimeCur, wstats *nl.XfrmStats, stats *XfrmStateStats) {\n\tstats.Bytes = cur.Bytes\n\tstats.Packets = cur.Packets\n\tstats.AddTime = cur.AddTime\n\tstats.UseTime = cur.UseTime\n\tstats.ReplayWindow = wstats.ReplayWindow\n\tstats.Replay = wstats.Replay\n\tstats.Failed = wstats.IntegrityFailed\n}\n\nfunc xfrmUsersaInfoFromXfrmState(state *XfrmState) *nl.XfrmUsersaInfo {\n\tmsg := &nl.XfrmUsersaInfo{}\n\tmsg.Family = uint16(nl.GetIPFamily(state.Dst))\n\tmsg.Id.Daddr.FromIP(state.Dst)\n\tmsg.Saddr.FromIP(state.Src)\n\tmsg.Id.Proto = uint8(state.Proto)\n\tmsg.Mode = uint8(state.Mode)\n\tmsg.Id.Spi = nl.Swap32(uint32(state.Spi))\n\tmsg.Reqid = uint32(state.Reqid)\n\tmsg.ReplayWindow = uint8(state.ReplayWindow)\n\tmsg.Sel = nl.XfrmSelector{}\n\tif state.Selector != nil {\n\t\tselFromPolicy(&msg.Sel, state.Selector)\n\t}\n\treturn msg\n}\n"
        },
        {
          "name": "xfrm_state_linux_test.go",
          "type": "blob",
          "size": 9.755859375,
          "content": "package netlink\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestXfrmStateAddGetDel(t *testing.T) {\n\tfor _, s := range []*XfrmState{\n\t\tgetBaseState(),\n\t\tgetAeadState(),\n\t\tgetBaseStateV6oV4(),\n\t\tgetBaseStateV4oV6(),\n\t} {\n\t\ttestXfrmStateAddGetDel(t, s)\n\t}\n}\n\nfunc testXfrmStateAddGetDel(t *testing.T, state *XfrmState) {\n\ttearDown := setUpNetlinkTest(t)\n\tdefer tearDown()\n\tif err := XfrmStateAdd(state); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tstates, err := XfrmStateList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(states) != 1 {\n\t\tt.Fatal(\"State not added properly\")\n\t}\n\n\tif !compareStates(state, &states[0]) {\n\t\tt.Fatalf(\"unexpected states returned\")\n\t}\n\n\t// Get specific state\n\tsa, err := XfrmStateGet(state)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !compareStates(state, sa) {\n\t\tt.Fatalf(\"unexpected state returned\")\n\t}\n\n\tif err = XfrmStateDel(state); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstates, err = XfrmStateList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(states) != 0 {\n\t\tt.Fatal(\"State not removed properly\")\n\t}\n\n\tif _, err := XfrmStateGet(state); err == nil {\n\t\tt.Fatalf(\"Unexpected success\")\n\t}\n}\n\nfunc TestXfrmStateAllocSpi(t *testing.T) {\n\tdefer setUpNetlinkTest(t)()\n\n\tstate := getBaseState()\n\tstate.Spi = 0\n\tstate.Auth = nil\n\tstate.Crypt = nil\n\trstate, err := XfrmStateAllocSpi(state)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rstate.Spi == 0 {\n\t\tt.Fatalf(\"SPI is not allocated\")\n\t}\n\trstate.Spi = 0\n\n\tif !compareStates(state, rstate) {\n\t\tt.Fatalf(\"State not properly allocated\")\n\t}\n}\n\nfunc TestXfrmStateFlush(t *testing.T) {\n\tdefer setUpNetlinkTest(t)()\n\n\tstate1 := getBaseState()\n\tstate2 := getBaseState()\n\tstate2.Src = net.ParseIP(\"127.1.0.1\")\n\tstate2.Dst = net.ParseIP(\"127.1.0.2\")\n\tstate2.Proto = XFRM_PROTO_AH\n\tstate2.Mode = XFRM_MODE_TUNNEL\n\tstate2.Spi = 20\n\tstate2.Mark = nil\n\tstate2.Crypt = nil\n\n\tif err := XfrmStateAdd(state1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := XfrmStateAdd(state2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// flushing proto for which no state is present should return silently\n\tif err := XfrmStateFlush(XFRM_PROTO_COMP); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := XfrmStateFlush(XFRM_PROTO_AH); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err := XfrmStateGet(state2); err == nil {\n\t\tt.Fatalf(\"Unexpected success\")\n\t}\n\n\tif err := XfrmStateAdd(state2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := XfrmStateFlush(0); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstates, err := XfrmStateList(FAMILY_ALL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(states) != 0 {\n\t\tt.Fatal(\"State not flushed properly\")\n\t}\n\n}\n\nfunc TestXfrmStateUpdateLimits(t *testing.T) {\n\tdefer setUpNetlinkTest(t)()\n\n\t// Program state with limits\n\tstate := getBaseState()\n\tstate.Limits.TimeHard = 3600\n\tstate.Limits.TimeSoft = 60\n\tstate.Limits.PacketHard = 1000\n\tstate.Limits.PacketSoft = 50\n\tstate.Limits.ByteHard = 1000000\n\tstate.Limits.ByteSoft = 50000\n\tstate.Limits.TimeUseHard = 3000\n\tstate.Limits.TimeUseSoft = 1500\n\tif err := XfrmStateAdd(state); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Verify limits\n\ts, err := XfrmStateGet(state)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !compareLimits(state, s) {\n\t\tt.Fatalf(\"Incorrect time hard/soft retrieved: %s\", s.Print(true))\n\t}\n\n\t// Update limits\n\tstate.Limits.TimeHard = 1800\n\tstate.Limits.TimeSoft = 30\n\tstate.Limits.PacketHard = 500\n\tstate.Limits.PacketSoft = 25\n\tstate.Limits.ByteHard = 500000\n\tstate.Limits.ByteSoft = 25000\n\tstate.Limits.TimeUseHard = 2000\n\tstate.Limits.TimeUseSoft = 1000\n\tif err := XfrmStateUpdate(state); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Verify new limits\n\ts, err = XfrmStateGet(state)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif s.Limits.TimeHard != 1800 || s.Limits.TimeSoft != 30 {\n\t\tt.Fatalf(\"Incorrect time hard retrieved: (%d, %d)\", s.Limits.TimeHard, s.Limits.TimeSoft)\n\t}\n}\n\nfunc TestXfrmStateStats(t *testing.T) {\n\tdefer setUpNetlinkTest(t)()\n\n\t// Program state and record time\n\tstate := getBaseState()\n\tnow := time.Now()\n\tif err := XfrmStateAdd(state); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Retrieve state\n\ts, err := XfrmStateGet(state)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Verify stats: We expect zero counters, same second add time and unset use time\n\tif s.Statistics.Bytes != 0 || s.Statistics.Packets != 0 || s.Statistics.AddTime != uint64(now.Unix()) || s.Statistics.UseTime != 0 {\n\t\tt.Fatalf(\"Unexpected statistics (addTime: %s) for state:\\n%s\", now.Format(time.UnixDate), s.Print(true))\n\t}\n}\n\nfunc TestXfrmStateWithIfid(t *testing.T) {\n\tminKernelRequired(t, 4, 19)\n\tdefer setUpNetlinkTest(t)()\n\n\tstate := getBaseState()\n\tstate.Ifid = 54321\n\tif err := XfrmStateAdd(state); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts, err := XfrmStateGet(state)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !compareStates(state, s) {\n\t\tt.Fatalf(\"unexpected state returned.\\nExpected: %v.\\nGot %v\", state, s)\n\t}\n\tif err = XfrmStateDel(s); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestXfrmStateWithOutputMark(t *testing.T) {\n\tminKernelRequired(t, 4, 14)\n\tdefer setUpNetlinkTest(t)()\n\n\tstate := getBaseState()\n\tstate.OutputMark = &XfrmMark{\n\t\tValue: 0x0000000a,\n\t}\n\tif err := XfrmStateAdd(state); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts, err := XfrmStateGet(state)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !compareStates(state, s) {\n\t\tt.Fatalf(\"unexpected state returned.\\nExpected: %v.\\nGot %v\", state, s)\n\t}\n\tif err = XfrmStateDel(s); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestXfrmStateWithOutputMarkAndMask(t *testing.T) {\n\tminKernelRequired(t, 4, 19)\n\tdefer setUpNetlinkTest(t)()\n\n\tstate := getBaseState()\n\tstate.OutputMark = &XfrmMark{\n\t\tValue: 0x0000000a,\n\t\tMask:  0x0000000f,\n\t}\n\tif err := XfrmStateAdd(state); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts, err := XfrmStateGet(state)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !compareStates(state, s) {\n\t\tt.Fatalf(\"unexpected state returned.\\nExpected: %v.\\nGot %v\", state, s)\n\t}\n\tif err = XfrmStateDel(s); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\nfunc genStateSelectorForV6Payload() *XfrmPolicy {\n\t_, wildcardV6Net, _ := net.ParseCIDR(\"::/0\")\n\treturn &XfrmPolicy{\n\t\tSrc: wildcardV6Net,\n\t\tDst: wildcardV6Net,\n\t}\n}\n\nfunc genStateSelectorForV4Payload() *XfrmPolicy {\n\t_, wildcardV4Net, _ := net.ParseCIDR(\"0.0.0.0/0\")\n\treturn &XfrmPolicy{\n\t\tSrc: wildcardV4Net,\n\t\tDst: wildcardV4Net,\n\t}\n}\n\nfunc getBaseState() *XfrmState {\n\treturn &XfrmState{\n\t\t// Force 4 byte notation for the IPv4 addresses\n\t\tSrc:   net.ParseIP(\"127.0.0.1\").To4(),\n\t\tDst:   net.ParseIP(\"127.0.0.2\").To4(),\n\t\tProto: XFRM_PROTO_ESP,\n\t\tMode:  XFRM_MODE_TUNNEL,\n\t\tSpi:   1,\n\t\tAuth: &XfrmStateAlgo{\n\t\t\tName: \"hmac(sha256)\",\n\t\t\tKey:  []byte(\"abcdefghijklmnopqrstuvwzyzABCDEF\"),\n\t\t},\n\t\tCrypt: &XfrmStateAlgo{\n\t\t\tName: \"cbc(aes)\",\n\t\t\tKey:  []byte(\"abcdefghijklmnopqrstuvwzyzABCDEF\"),\n\t\t},\n\t\tMark: &XfrmMark{\n\t\t\tValue: 0x12340000,\n\t\t\tMask:  0xffff0000,\n\t\t},\n\t}\n}\n\nfunc getBaseStateV4oV6() *XfrmState {\n\treturn &XfrmState{\n\t\t// Force 4 byte notation for the IPv4 addressesd\n\t\tSrc:   net.ParseIP(\"2001:dead::1\").To16(),\n\t\tDst:   net.ParseIP(\"2001:beef::1\").To16(),\n\t\tProto: XFRM_PROTO_ESP,\n\t\tMode:  XFRM_MODE_TUNNEL,\n\t\tSpi:   1,\n\t\tAuth: &XfrmStateAlgo{\n\t\t\tName: \"hmac(sha256)\",\n\t\t\tKey:  []byte(\"abcdefghijklmnopqrstuvwzyzABCDEF\"),\n\t\t},\n\t\tCrypt: &XfrmStateAlgo{\n\t\t\tName: \"cbc(aes)\",\n\t\t\tKey:  []byte(\"abcdefghijklmnopqrstuvwzyzABCDEF\"),\n\t\t},\n\t\tMark: &XfrmMark{\n\t\t\tValue: 0x12340000,\n\t\t\tMask:  0xffff0000,\n\t\t},\n\t\tSelector: genStateSelectorForV4Payload(),\n\t}\n}\n\nfunc getBaseStateV6oV4() *XfrmState {\n\treturn &XfrmState{\n\t\t// Force 4 byte notation for the IPv4 addressesd\n\t\tSrc:   net.ParseIP(\"192.168.1.1\").To4(),\n\t\tDst:   net.ParseIP(\"192.168.2.2\").To4(),\n\t\tProto: XFRM_PROTO_ESP,\n\t\tMode:  XFRM_MODE_TUNNEL,\n\t\tSpi:   1,\n\t\tAuth: &XfrmStateAlgo{\n\t\t\tName: \"hmac(sha256)\",\n\t\t\tKey:  []byte(\"abcdefghijklmnopqrstuvwzyzABCDEF\"),\n\t\t},\n\t\tCrypt: &XfrmStateAlgo{\n\t\t\tName: \"cbc(aes)\",\n\t\t\tKey:  []byte(\"abcdefghijklmnopqrstuvwzyzABCDEF\"),\n\t\t},\n\t\tMark: &XfrmMark{\n\t\t\tValue: 0x12340000,\n\t\t\tMask:  0xffff0000,\n\t\t},\n\t\tSelector: genStateSelectorForV6Payload(),\n\t}\n}\n\nfunc getAeadState() *XfrmState {\n\t// 128 key bits + 32 salt bits\n\tk, _ := hex.DecodeString(\"d0562776bf0e75830ba3f7f8eb6c09b555aa1177\")\n\treturn &XfrmState{\n\t\t// Leave IPv4 addresses in Ipv4 in IPv6 notation\n\t\tSrc:   net.ParseIP(\"192.168.1.1\"),\n\t\tDst:   net.ParseIP(\"192.168.2.2\"),\n\t\tProto: XFRM_PROTO_ESP,\n\t\tMode:  XFRM_MODE_TUNNEL,\n\t\tSpi:   2,\n\t\tAead: &XfrmStateAlgo{\n\t\t\tName:   \"rfc4106(gcm(aes))\",\n\t\t\tKey:    k,\n\t\t\tICVLen: 64,\n\t\t},\n\t}\n}\nfunc compareSelector(a, b *XfrmPolicy) bool {\n\treturn a.Src.String() == b.Src.String() &&\n\t\ta.Dst.String() == b.Dst.String() &&\n\t\ta.Proto == b.Proto &&\n\t\ta.DstPort == b.DstPort &&\n\t\ta.SrcPort == b.SrcPort &&\n\t\ta.Ifindex == b.Ifindex\n}\n\nfunc compareStates(a, b *XfrmState) bool {\n\tif a == b {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.Selector != nil && b.Selector != nil {\n\t\tif !compareSelector(a.Selector, b.Selector) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn a.Src.Equal(b.Src) && a.Dst.Equal(b.Dst) &&\n\t\ta.Mode == b.Mode && a.Spi == b.Spi && a.Proto == b.Proto &&\n\t\ta.Ifid == b.Ifid &&\n\t\tcompareAlgo(a.Auth, b.Auth) &&\n\t\tcompareAlgo(a.Crypt, b.Crypt) &&\n\t\tcompareAlgo(a.Aead, b.Aead) &&\n\t\tcompareMarks(a.Mark, b.Mark) &&\n\t\tcompareMarks(a.OutputMark, b.OutputMark)\n\n}\n\nfunc compareLimits(a, b *XfrmState) bool {\n\treturn a.Limits.TimeHard == b.Limits.TimeHard &&\n\t\ta.Limits.TimeSoft == b.Limits.TimeSoft &&\n\t\ta.Limits.PacketHard == b.Limits.PacketHard &&\n\t\ta.Limits.PacketSoft == b.Limits.PacketSoft &&\n\t\ta.Limits.ByteHard == b.Limits.ByteHard &&\n\t\ta.Limits.ByteSoft == b.Limits.ByteSoft &&\n\t\ta.Limits.TimeUseHard == b.Limits.TimeUseHard &&\n\t\ta.Limits.TimeUseSoft == b.Limits.TimeUseSoft\n}\n\nfunc compareAlgo(a, b *XfrmStateAlgo) bool {\n\tif a == b {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.Name == b.Name && bytes.Equal(a.Key, b.Key) &&\n\t\t(a.TruncateLen == 0 || a.TruncateLen == b.TruncateLen) &&\n\t\t(a.ICVLen == 0 || a.ICVLen == b.ICVLen)\n}\n\nfunc compareMarks(a, b *XfrmMark) bool {\n\tif a == b {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.Value == b.Value && a.Mask == b.Mask\n}\n"
        },
        {
          "name": "xfrm_unspecified.go",
          "type": "blob",
          "size": 0.099609375,
          "content": "//go:build !linux\n// +build !linux\n\npackage netlink\n\ntype XfrmPolicy struct{}\ntype XfrmState struct{}\n"
        }
      ]
    }
  ]
}