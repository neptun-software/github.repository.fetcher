{
  "metadata": {
    "timestamp": 1736567324382,
    "page": 931,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "joohoi/acme-dns",
      "stars": 2234,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0673828125,
          "content": "acme-dns\nacme-dns.db\nacme-dns.log\n.vagrant\ncoverage.out\n.idea/\ndist/\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.28515625,
          "content": "builds:\n  - binary: acme-dns\n    env:\n      - CGO_ENABLED=1\n    goos:\n      - linux\n    goarch:\n      - amd64\n\narchives:\n  - id: tgz\n    format: tar.gz\n    files:\n      - LICENSE\n      - README.md\n      - Dockerfile\n      - config.cfg\n      - acme-dns.service\n\nsigns:\n  - artifacts: checksum\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.5537109375,
          "content": "FROM golang:alpine AS builder\nLABEL maintainer=\"joona@kuori.org\"\n\nRUN apk add --update gcc musl-dev git\n\nENV GOPATH /tmp/buildcache\nRUN git clone https://github.com/joohoi/acme-dns /tmp/acme-dns\nWORKDIR /tmp/acme-dns\nRUN CGO_ENABLED=1 go build\n\nFROM alpine:latest\n\nWORKDIR /root/\nCOPY --from=builder /tmp/acme-dns .\nRUN mkdir -p /etc/acme-dns\nRUN mkdir -p /var/lib/acme-dns\nRUN rm -rf ./config.cfg\nRUN apk --no-cache add ca-certificates && update-ca-certificates\n\nVOLUME [\"/etc/acme-dns\", \"/var/lib/acme-dns\"]\nENTRYPOINT [\"./acme-dns\"]\nEXPOSE 53 80 443\nEXPOSE 53/udp\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2016 Joona Hoikkala\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.462890625,
          "content": "[![Build Status](https://travis-ci.org/joohoi/acme-dns.svg?branch=master)](https://travis-ci.org/joohoi/acme-dns) [![Coverage Status](https://coveralls.io/repos/github/joohoi/acme-dns/badge.svg?branch=master)](https://coveralls.io/github/joohoi/acme-dns?branch=master) [![Go Report Card](https://goreportcard.com/badge/github.com/joohoi/acme-dns)](https://goreportcard.com/report/github.com/joohoi/acme-dns)\n# acme-dns\n\nA simplified DNS server with a RESTful HTTP API to provide a simple way to automate ACME DNS challenges.\n\n## Why?\n\nMany DNS servers do not provide an API to enable automation for the ACME DNS challenges. Those which do, give the keys way too much power.\nLeaving the keys laying around your random boxes is too often a requirement to have a meaningful process automation.\n\nAcme-dns provides a simple API exclusively for TXT record updates and should be used with ACME magic \"\\_acme-challenge\" - subdomain CNAME records. This way, in the unfortunate exposure of API keys, the effects are limited to the subdomain TXT record in question.\n\nSo basically it boils down to **accessibility** and **security**.\n\nFor longer explanation of the underlying issue and other proposed solutions, see a blog post on the topic from EFF deeplinks blog: https://www.eff.org/deeplinks/2018/02/technical-deep-dive-securing-automation-acme-dns-challenge-validation\n\n## Features\n- Simplified DNS server, serving your ACME DNS challenges (TXT)\n- Custom records (have your required A, AAAA, NS, etc. records served)\n- HTTP API automatically acquires and uses Let's Encrypt TLS certificate\n- Limit /update API endpoint access to specific CIDR mask(s), defined in the /register request\n- Supports SQLite & PostgreSQL as DB backends\n- Rolling update of two TXT records to be able to answer to challenges for certificates that have both names: `yourdomain.tld` and `*.yourdomain.tld`, as both of the challenges point to the same subdomain.\n- Simple deployment (it's Go after all)\n\n## Usage\n\nA client application for acme-dns with support for Certbot authentication hooks is available at: [https://github.com/acme-dns/acme-dns-client](https://github.com/acme-dns/acme-dns-client).\n\n[![asciicast](https://asciinema.org/a/94903.png)](https://asciinema.org/a/94903)\n\nUsing acme-dns is a three-step process (provided you already have the self-hosted server set up):\n\n- Get credentials and unique subdomain (simple POST request to eg. https://auth.acme-dns.io/register)\n- Create a (ACME magic) CNAME record to your existing zone, pointing to the subdomain you got from the registration. (eg. `_acme-challenge.domainiwantcertfor.tld. CNAME a097455b-52cc-4569-90c8-7a4b97c6eba8.auth.example.org` )\n- Use your credentials to POST new DNS challenge values to an acme-dns server for the CA to validate from.\n- Crontab and forget.\n\n## API\n\n### Register endpoint\n\nThe method returns a new unique subdomain and credentials needed to update your record.\nFulldomain is where you can point your own `_acme-challenge` subdomain CNAME record to.\nWith the credentials, you can update the TXT response in the service to match the challenge token, later referred as \\_\\_\\_validation\\_token\\_received\\_from\\_the\\_ca\\_\\_\\_, given out by the Certificate Authority.\n\n**Optional:**: You can POST JSON data to limit the `/update` requests to predefined source networks using CIDR notation.\n\n```POST /register```\n\n#### OPTIONAL Example input\n```json\n{\n    \"allowfrom\": [\n        \"192.168.100.1/24\",\n        \"1.2.3.4/32\",\n        \"2002:c0a8:2a00::0/40\"\n    ]\n}\n```\n\n\n```Status: 201 Created```\n```json\n{\n    \"allowfrom\": [\n        \"192.168.100.1/24\",\n        \"1.2.3.4/32\",\n        \"2002:c0a8:2a00::0/40\"\n    ],\n    \"fulldomain\": \"8e5700ea-a4bf-41c7-8a77-e990661dcc6a.auth.acme-dns.io\",\n    \"password\": \"htB9mR9DYgcu9bX_afHF62erXaH2TS7bg9KW3F7Z\",\n    \"subdomain\": \"8e5700ea-a4bf-41c7-8a77-e990661dcc6a\",\n    \"username\": \"c36f50e8-4632-44f0-83fe-e070fef28a10\"\n}\n```\n\n### Update endpoint\n\nThe method allows you to update the TXT answer contents of your unique subdomain. Usually carried automatically by automated ACME client.\n\n```POST /update```\n\n#### Required headers\n| Header name   | Description                                | Example                                               |\n| ------------- |--------------------------------------------|-------------------------------------------------------|\n| X-Api-User    | UUIDv4 username received from registration | `X-Api-User: c36f50e8-4632-44f0-83fe-e070fef28a10`    |\n| X-Api-Key     | Password received from registration        | `X-Api-Key: htB9mR9DYgcu9bX_afHF62erXaH2TS7bg9KW3F7Z` |\n\n#### Example input\n```json\n{\n    \"subdomain\": \"8e5700ea-a4bf-41c7-8a77-e990661dcc6a\",\n    \"txt\": \"___validation_token_received_from_the_ca___\"\n}\n```\n\n#### Response\n\n```Status: 200 OK```\n```json\n{\n    \"txt\": \"___validation_token_received_from_the_ca___\"\n}\n```\n\n### Health check endpoint\n\nThe method can be used to check readiness and/or liveness of the server. It will return status code 200 on success or won't be reachable.\n\n```GET /health```\n\n## Self-hosted\n\nYou are encouraged to run your own acme-dns instance, because you are effectively authorizing the acme-dns server to act on your behalf in providing the answer to the challenging CA, making the instance able to request (and get issued) a TLS certificate for the domain that has CNAME pointing to it.\n\nSee the INSTALL section for information on how to do this.\n\n\n## Installation\n\n1) Install [Go 1.13 or newer](https://golang.org/doc/install).\n\n2) Build acme-dns: \n```\ngit clone https://github.com/joohoi/acme-dns\ncd acme-dns\nexport GOPATH=/tmp/acme-dns\ngo build\n```\n\n3) Move the built acme-dns binary to a directory in your $PATH, for example:\n`sudo mv acme-dns /usr/local/bin`\n\n4) Edit config.cfg to suit your needs (see [configuration](#configuration)). `acme-dns` will read the configuration file from `/etc/acme-dns/config.cfg` or `./config.cfg`, or a location specified with the `-c` flag.\n\n5) If your system has systemd, you can optionally install acme-dns as a service so that it will start on boot and be tracked by systemd. This also allows us to add the `CAP_NET_BIND_SERVICE` capability so that acme-dns can be run by a user other than root.\n\n    1) Make sure that you have moved the configuration file to `/etc/acme-dns/config.cfg` so that acme-dns can access it globally.\n\n    2) Move the acme-dns executable from `~/go/bin/acme-dns` to `/usr/local/bin/acme-dns` (Any location will work, just be sure to change `acme-dns.service` to match).\n\n    3) Create a minimal acme-dns user: `sudo adduser --system --gecos \"acme-dns Service\" --disabled-password --group --home /var/lib/acme-dns acme-dns`.\n\n    4) Move the systemd service unit from `acme-dns.service` to `/etc/systemd/system/acme-dns.service`.\n\n    5) Reload systemd units: `sudo systemctl daemon-reload`.\n\n    6) Enable acme-dns on boot: `sudo systemctl enable acme-dns.service`.\n\n    7) Run acme-dns: `sudo systemctl start acme-dns.service`.\n\n6) If you did not install the systemd service, run `acme-dns`. Please note that acme-dns needs to open a privileged port (53, domain), so it needs to be run with elevated privileges.\n\n### Using Docker\n\n1) Pull the latest acme-dns Docker image: `docker pull joohoi/acme-dns`.\n\n2) Create directories: `config` for the configuration file, and `data` for the sqlite3 database.\n\n3) Copy [configuration template](https://raw.githubusercontent.com/joohoi/acme-dns/master/config.cfg) to `config/config.cfg`.\n\n4) Modify the `config.cfg` to suit your needs.\n\n5) Run Docker, this example expects that you have `port = \"80\"` in your `config.cfg`:\n```\ndocker run --rm --name acmedns                 \\\n -p 53:53                                      \\\n -p 53:53/udp                                  \\\n -p 80:80                                      \\\n -v /path/to/your/config:/etc/acme-dns:ro      \\\n -v /path/to/your/data:/var/lib/acme-dns       \\\n -d joohoi/acme-dns\n```\n\n### Docker Compose\n\n1) Create directories: `config` for the configuration file, and `data` for the sqlite3 database.\n\n2) Copy [configuration template](https://raw.githubusercontent.com/joohoi/acme-dns/master/config.cfg) to `config/config.cfg`.\n\n3) Copy [docker-compose.yml from the project](https://raw.githubusercontent.com/joohoi/acme-dns/master/docker-compose.yml), or create your own.\n\n4) Edit the `config/config.cfg` and `docker-compose.yml` to suit your needs, and run `docker-compose up -d`.\n\n## DNS Records\n\nNote: In this documentation:\n- `auth.example.org` is the hostname of the acme-dns server\n- acme-dns will serve `*.auth.example.org` records\n- `198.51.100.1` is the **public** IP address of the system running acme-dns  \n\nThese values should be changed based on your environment.\n\nYou will need to add some DNS records on your domain's regular DNS server:\n- `NS` record for `auth.example.org` pointing to `auth.example.org` (this means, that `auth.example.org` is responsible for any `*.auth.example.org` records)\n- `A` record for `auth.example.org` pointing to `198.51.100.1`\n- If using IPv6, an `AAAA` record pointing to the IPv6 address.\n- Each domain you will be authenticating will need a `_acme-challenge` `CNAME` subdomain added. The [client](README.md#clients) you use will explain how to do this.\n\n## Testing It Out\n\nYou may want to test that acme-dns is working before using it for real queries.\n\n1) Confirm that DNS lookups for the acme-dns subdomain works as expected: `dig auth.example.org`.\n\n2) Call the `/register` API endpoint to register a test domain:\n```\n$ curl -X POST https://auth.example.org/register\n{\"username\":\"eabcdb41-d89f-4580-826f-3e62e9755ef2\",\"password\":\"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\",\"fulldomain\":\"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.org\",\"subdomain\":\"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\",\"allowfrom\":[]}\n```\n\n3) Call the `/update` API endpoint to set a test TXT record. Pass the `username`, `password` and `subdomain` received from the `register` call performed above:\n```\n$ curl -X POST \\\n  -H \"X-Api-User: eabcdb41-d89f-4580-826f-3e62e9755ef2\" \\\n  -H \"X-Api-Key: pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\" \\\n  -d '{\"subdomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\", \"txt\": \"___validation_token_received_from_the_ca___\"}' \\\n  https://auth.example.org/update\n```\n\nNote: The `txt` field must be exactly 43 characters long, otherwise acme-dns will reject it\n\n4) Perform a DNS lookup to the test subdomain to confirm the updated TXT record is being served:\n```\n$ dig -t txt @auth.example.org d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.org\n```\n\n## Configuration\n\n```bash\n[general]\n# DNS interface. Note that systemd-resolved may reserve port 53 on 127.0.0.53\n# In this case acme-dns will error out and you will need to define the listening interface\n# for example: listen = \"127.0.0.1:53\"\nlisten = \"127.0.0.1:53\"\n# protocol, \"both\", \"both4\", \"both6\", \"udp\", \"udp4\", \"udp6\" or \"tcp\", \"tcp4\", \"tcp6\"\nprotocol = \"both\"\n# domain name to serve the requests off of\ndomain = \"auth.example.org\"\n# zone name server\nnsname = \"auth.example.org\"\n# admin email address, where @Â is substituted with .\nnsadmin = \"admin.example.org\"\n# predefined records served in addition to the TXT\nrecords = [\n    # domain pointing to the public IP of your acme-dns server \n    \"auth.example.org. A 198.51.100.1\",\n    # specify that auth.example.org will resolve any *.auth.example.org records\n    \"auth.example.org. NS auth.example.org.\",\n]\n# debug messages from CORS etc\ndebug = false\n\n[database]\n# Database engine to use, sqlite3 or postgres\nengine = \"sqlite3\"\n# Connection string, filename for sqlite3 and postgres://$username:$password@$host/$db_name for postgres\n# Please note that the default Docker image uses path /var/lib/acme-dns/acme-dns.db for sqlite3\nconnection = \"/var/lib/acme-dns/acme-dns.db\"\n# connection = \"postgres://user:password@localhost/acmedns_db\"\n\n[api]\n# listen ip eg. 127.0.0.1\nip = \"0.0.0.0\"\n# disable registration endpoint\ndisable_registration = false\n# listen port, eg. 443 for default HTTPS\nport = \"443\"\n# possible values: \"letsencrypt\", \"letsencryptstaging\", \"cert\", \"none\"\ntls = \"letsencryptstaging\"\n# only used if tls = \"cert\"\ntls_cert_privkey = \"/etc/tls/example.org/privkey.pem\"\ntls_cert_fullchain = \"/etc/tls/example.org/fullchain.pem\"\n# only used if tls = \"letsencrypt\"\nacme_cache_dir = \"api-certs\"\n# optional e-mail address to which Let's Encrypt will send expiration notices for the API's cert\nnotification_email = \"\"\n# CORS AllowOrigins, wildcards can be used\ncorsorigins = [\n    \"*\"\n]\n# use HTTP header to get the client ip\nuse_header = false\n# header name to pull the ip address / list of ip addresses from\nheader_name = \"X-Forwarded-For\"\n\n[logconfig]\n# logging level: \"error\", \"warning\", \"info\" or \"debug\"\nloglevel = \"debug\"\n# possible values: stdout, TODO file & integrations\nlogtype = \"stdout\"\n# file path for logfile TODO\n# logfile = \"./acme-dns.log\"\n# format, either \"json\" or \"text\"\nlogformat = \"text\"\n```\n\n## HTTPS API\n\nThe RESTful acme-dns API can be exposed over HTTPS in two ways:\n\n1. Using `tls = \"letsencrypt\"` and letting acme-dns issue its own certificate\n   automatically with Let's Encrypt.\n1. Using `tls = \"cert\"` and providing your own HTTPS certificate chain and\n   private key with `tls_cert_fullchain` and `tls_cert_privkey`.\n\nWhere possible the first option is recommended. This is the easiest and safest\nway to have acme-dns expose its API over HTTPS.\n\n**Warning**: If you choose to use `tls = \"cert\"` you must take care that the\ncertificate *does not expire*! If it does and the ACME client you use to issue the\ncertificate depends on the ACME DNS API to update TXT records you will be stuck\nin a position where the API certificate has expired but it can't be renewed\nbecause the ACME client will refuse to connect to the ACME DNS API it needs to\nuse for the renewal.\n\n## Clients\n\n- acme.sh: [https://github.com/Neilpang/acme.sh](https://github.com/Neilpang/acme.sh)\n- Certify The Web: [https://github.com/webprofusion/certify](https://github.com/webprofusion/certify)\n- cert-manager: [https://github.com/jetstack/cert-manager](https://github.com/jetstack/cert-manager)\n- Lego: [https://github.com/xenolf/lego](https://github.com/xenolf/lego)\n- Posh-ACME: [https://github.com/rmbolger/Posh-ACME](https://github.com/rmbolger/Posh-ACME)\n- Sewer: [https://github.com/komuw/sewer](https://github.com/komuw/sewer)\n- Traefik: [https://github.com/containous/traefik](https://github.com/containous/traefik)\n- Windows ACME Simple (WACS): [https://www.win-acme.com](https://www.win-acme.com)\n\n### Authentication hooks\n\n- acme-dns-client with Certbot authentication hook: [https://github.com/acme-dns/acme-dns-client](https://github.com/acme-dns/acme-dns-client)\n- Certbot authentication hook in Python:  [https://github.com/joohoi/acme-dns-certbot-joohoi](https://github.com/joohoi/acme-dns-certbot-joohoi)\n- Certbot authentication hook in Go: [https://github.com/koesie10/acme-dns-certbot-hook](https://github.com/koesie10/acme-dns-certbot-hook)\n\n### Libraries\n\n- Generic client library in Python ([PyPI](https://pypi.python.org/pypi/pyacmedns/)): [https://github.com/joohoi/pyacmedns](https://github.com/joohoi/pyacmedns)\n- Generic client library in Go: [https://github.com/cpu/goacmedns](https://github.com/cpu/goacmedns)\n\n\n## Changelog\n\n- v0.8\n   - NOTE: configuration option: \"api_domain\" deprecated!\n   - New\n      - Automatic HTTP API certificate provisioning using DNS challenges making acme-dns able to acquire certificates even with HTTP api not being accessible from public internet.\n      - Configuration value for \"tls\": \"letsencryptstaging\". Setting it will help you to debug possible issues with HTTP API certificate acquiring process. This is the new default value.\n   - Changed\n      - Fixed: EDNS0 support\n      - Migrated from autocert to [certmagic](https://github.com/mholt/certmagic) for HTTP API certificate handling\n- v0.7.2\n   - Changed\n      - Fixed: Regression error of not being able to answer to incoming random-case requests.\n      - Fixed: SOA record added to a correct header field in NXDOMAIN responses.\n- v0.7.1\n   - Changed\n      - Fixed: SOA record correctly added to the TCP DNS server when using both, UDP and TCP servers.\n- v0.7\n   - New\n      - Added an endpoint to perform health checks\n   - Changed\n      - A new protocol selection for DNS server \"both\", that binds both - UDP and TCP ports.\n      - Refactored DNS server internals.\n      - Handle some aspects of DNS spec better.\n- v0.6\n   - New\n      - Command line flag `-c` to specify location of config file.\n      - Proper refusal of dynamic update requests.\n      - Release signing\n   - Changed\n      - Better error messages for goroutines\n- v0.5\n   - New\n      - Configurable certificate cache directory\n   - Changed\n      - Process wide umask to ensure created files are only readable by the user running acme-dns\n      - Replaced package that handles UUIDs because of a flaw in the original package\n      - Updated dependencies\n      - Better error messages\n- v0.4 Clear error messages for bad TXT record content, proper handling of static CNAME records, fixed IP address parsing from the request, added option to disable registration endpoint in the configuration.\n- v0.3.2 Dockerfile was fixed for users using autocert feature\n- v0.3.1 Added goreleaser for distributing binary builds of the releases\n- v0.3 Changed autocert to use HTTP-01 challenges, as TLS-SNI is disabled by Let's Encrypt\n- v0.2 Now powered by httprouter, support wildcard certificates, Docker images\n- v0.1 Initial release\n\n## TODO\n\n- Logging to a file\n- DNSSEC\n- Want to see something implemented, make a feature request!\n\n## Contributing\n\nacme-dns is open for contributions.\nIf you have an idea for improvement, please open an new issue or feel free to write a PR!\n\n## License\n\nacme-dns is released under the [MIT License](http://www.opensource.org/licenses/MIT).\n"
        },
        {
          "name": "Vagrantfile",
          "type": "blob",
          "size": 1.275390625,
          "content": "# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n# Vagrantfile for running integration tests with PostgreSQL\n\nVAGRANTFILE_API_VERSION = \"2\"\n\n$ubuntu_setup_script = <<SETUP_SCRIPT\napt-get update\napt-get install -y vim build-essential postgresql postgresql-contrib git\necho \"Downloading and installing Go 1.7.3\"\ncurl -s -o /tmp/go.tar.gz https://storage.googleapis.com/golang/go1.7.3.linux-amd64.tar.gz\ntar -C /usr/local -xzf /tmp/go.tar.gz\necho \"export PATH=$PATH:/usr/local/go/bin\" >> /home/vagrant/.profile\necho \"export GOPATH=/home/vagrant\" >> /home/vagrant/.profile\nmkdir -p /home/vagrant/src/acme-dns\nchown -R vagrant /home/vagrant/src\ncp /vagrant/test/run_integration.sh /home/vagrant\nbash /vagrant/test/pgsql.sh\necho \"\\n-------------------------------------------------------------\"\necho \"To run integration tests run, /home/vagrant/run_integration.sh\"\nSETUP_SCRIPT\n\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n\n  config.vm.define \"ad-ubuntu-trusty\", primary: true do |ad_ubuntu_trusty|\n    ad_ubuntu_trusty.vm.box = \"ubuntu/trusty64\"\n    ad_ubuntu_trusty.vm.provision \"shell\", inline: $ubuntu_setup_script\n    ad_ubuntu_trusty.vm.network \"forwarded_port\", guest: 8080, host: 8008\n    ad_ubuntu_trusty\n    ad_ubuntu_trusty.vm.provider \"virtualbox\" do |v|\n      v.memory = 2048\n    end\n  end\n\nend\n"
        },
        {
          "name": "acme-dns.service",
          "type": "blob",
          "size": 0.314453125,
          "content": "[Unit]\nDescription=Limited DNS server with RESTful HTTP API to handle ACME DNS challenges easily and securely\nAfter=network.target\n\n[Service]\nUser=acme-dns\nGroup=acme-dns\nAmbientCapabilities=CAP_NET_BIND_SERVICE\nWorkingDirectory=~\nExecStart=/usr/local/bin/acme-dns\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target\n"
        },
        {
          "name": "acmetxt.go",
          "type": "blob",
          "size": 1.978515625,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net\"\n\n\t\"github.com/google/uuid\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n// ACMETxt is the default structure for the user controlled record\ntype ACMETxt struct {\n\tUsername uuid.UUID\n\tPassword string\n\tACMETxtPost\n\tAllowFrom cidrslice\n}\n\n// ACMETxtPost holds the DNS part of the ACMETxt struct\ntype ACMETxtPost struct {\n\tSubdomain string `json:\"subdomain\"`\n\tValue     string `json:\"txt\"`\n}\n\n// cidrslice is a list of allowed cidr ranges\ntype cidrslice []string\n\nfunc (c *cidrslice) JSON() string {\n\tret, _ := json.Marshal(c.ValidEntries())\n\treturn string(ret)\n}\n\nfunc (c *cidrslice) isValid() error {\n\tfor _, v := range *c {\n\t\t_, _, err := net.ParseCIDR(sanitizeIPv6addr(v))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *cidrslice) ValidEntries() []string {\n\tvalid := []string{}\n\tfor _, v := range *c {\n\t\t_, _, err := net.ParseCIDR(sanitizeIPv6addr(v))\n\t\tif err == nil {\n\t\t\tvalid = append(valid, sanitizeIPv6addr(v))\n\t\t}\n\t}\n\treturn valid\n}\n\n// Check if IP belongs to an allowed net\nfunc (a ACMETxt) allowedFrom(ip string) bool {\n\tremoteIP := net.ParseIP(ip)\n\t// Range not limited\n\tif len(a.AllowFrom.ValidEntries()) == 0 {\n\t\treturn true\n\t}\n\tlog.WithFields(log.Fields{\"ip\": remoteIP}).Debug(\"Checking if update is permitted from IP\")\n\tfor _, v := range a.AllowFrom.ValidEntries() {\n\t\t_, vnet, _ := net.ParseCIDR(v)\n\t\tif vnet.Contains(remoteIP) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Go through list (most likely from headers) to check for the IP.\n// Reason for this is that some setups use reverse proxy in front of acme-dns\nfunc (a ACMETxt) allowedFromList(ips []string) bool {\n\tif len(ips) == 0 {\n\t\t// If no IP provided, check if no whitelist present (everyone has access)\n\t\treturn a.allowedFrom(\"\")\n\t}\n\tfor _, v := range ips {\n\t\tif a.allowedFrom(v) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc newACMETxt() ACMETxt {\n\tvar a = ACMETxt{}\n\tpassword := generatePassword(40)\n\ta.Username = uuid.New()\n\ta.Password = password\n\ta.Subdomain = uuid.New().String()\n\treturn a\n}\n"
        },
        {
          "name": "api.go",
          "type": "blob",
          "size": 3.6357421875,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/julienschmidt/httprouter\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n// RegResponse is a struct for registration response JSON\ntype RegResponse struct {\n\tUsername   string   `json:\"username\"`\n\tPassword   string   `json:\"password\"`\n\tFulldomain string   `json:\"fulldomain\"`\n\tSubdomain  string   `json:\"subdomain\"`\n\tAllowfrom  []string `json:\"allowfrom\"`\n}\n\nfunc webRegisterPost(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {\n\tvar regStatus int\n\tvar reg []byte\n\tvar err error\n\taTXT := ACMETxt{}\n\tbdata, _ := io.ReadAll(r.Body)\n\tif len(bdata) > 0 {\n\t\terr = json.Unmarshal(bdata, &aTXT)\n\t\tif err != nil {\n\t\t\tregStatus = http.StatusBadRequest\n\t\t\treg = jsonError(\"malformed_json_payload\")\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tw.WriteHeader(regStatus)\n\t\t\t_, _ = w.Write(reg)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Fail with malformed CIDR mask in allowfrom\n\terr = aTXT.AllowFrom.isValid()\n\tif err != nil {\n\t\tregStatus = http.StatusBadRequest\n\t\treg = jsonError(\"invalid_allowfrom_cidr\")\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(regStatus)\n\t\t_, _ = w.Write(reg)\n\t\treturn\n\t}\n\n\t// Create new user\n\tnu, err := DB.Register(aTXT.AllowFrom)\n\tif err != nil {\n\t\terrstr := fmt.Sprintf(\"%v\", err)\n\t\treg = jsonError(errstr)\n\t\tregStatus = http.StatusInternalServerError\n\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Debug(\"Error in registration\")\n\t} else {\n\t\tlog.WithFields(log.Fields{\"user\": nu.Username.String()}).Debug(\"Created new user\")\n\t\tregStruct := RegResponse{nu.Username.String(), nu.Password, nu.Subdomain + \".\" + Config.General.Domain, nu.Subdomain, nu.AllowFrom.ValidEntries()}\n\t\tregStatus = http.StatusCreated\n\t\treg, err = json.Marshal(regStruct)\n\t\tif err != nil {\n\t\t\tregStatus = http.StatusInternalServerError\n\t\t\treg = jsonError(\"json_error\")\n\t\t\tlog.WithFields(log.Fields{\"error\": \"json\"}).Debug(\"Could not marshal JSON\")\n\t\t}\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(regStatus)\n\t_, _ = w.Write(reg)\n}\n\nfunc webUpdatePost(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {\n\tvar updStatus int\n\tvar upd []byte\n\t// Get user\n\ta, ok := r.Context().Value(ACMETxtKey).(ACMETxt)\n\tif !ok {\n\t\tlog.WithFields(log.Fields{\"error\": \"context\"}).Error(\"Context error\")\n\t}\n\t// NOTE: An invalid subdomain should not happen - the auth handler should\n\t// reject POSTs with an invalid subdomain before this handler. Reject any\n\t// invalid subdomains anyway as a matter of caution.\n\tif !validSubdomain(a.Subdomain) {\n\t\tlog.WithFields(log.Fields{\"error\": \"subdomain\", \"subdomain\": a.Subdomain, \"txt\": a.Value}).Debug(\"Bad update data\")\n\t\tupdStatus = http.StatusBadRequest\n\t\tupd = jsonError(\"bad_subdomain\")\n\t} else if !validTXT(a.Value) {\n\t\tlog.WithFields(log.Fields{\"error\": \"txt\", \"subdomain\": a.Subdomain, \"txt\": a.Value}).Debug(\"Bad update data\")\n\t\tupdStatus = http.StatusBadRequest\n\t\tupd = jsonError(\"bad_txt\")\n\t} else if validSubdomain(a.Subdomain) && validTXT(a.Value) {\n\t\terr := DB.Update(a.ACMETxtPost)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Debug(\"Error while trying to update record\")\n\t\t\tupdStatus = http.StatusInternalServerError\n\t\t\tupd = jsonError(\"db_error\")\n\t\t} else {\n\t\t\tlog.WithFields(log.Fields{\"subdomain\": a.Subdomain, \"txt\": a.Value}).Debug(\"TXT updated\")\n\t\t\tupdStatus = http.StatusOK\n\t\t\tupd = []byte(\"{\\\"txt\\\": \\\"\" + a.Value + \"\\\"}\")\n\t\t}\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(updStatus)\n\t_, _ = w.Write(upd)\n}\n\n// Endpoint used to check the readiness and/or liveness (health) of the server.\nfunc healthCheck(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {\n\tw.WriteHeader(http.StatusOK)\n}\n"
        },
        {
          "name": "api_test.go",
          "type": "blob",
          "size": 12.4990234375,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/gavv/httpexpect\"\n\t\"github.com/google/uuid\"\n\t\"github.com/julienschmidt/httprouter\"\n\t\"github.com/rs/cors\"\n)\n\n// noAuth function to write ACMETxt model to context while not preforming any validation\nfunc noAuth(update httprouter.Handle) httprouter.Handle {\n\treturn func(w http.ResponseWriter, r *http.Request, p httprouter.Params) {\n\t\tpostData := ACMETxt{}\n\t\tuname := r.Header.Get(\"X-Api-User\")\n\t\tpasswd := r.Header.Get(\"X-Api-Key\")\n\n\t\tdec := json.NewDecoder(r.Body)\n\t\t_ = dec.Decode(&postData)\n\t\t// Set user info to the decoded ACMETxt object\n\t\tpostData.Username, _ = uuid.Parse(uname)\n\t\tpostData.Password = passwd\n\t\t// Set the ACMETxt struct to context to pull in from update function\n\t\tctx := r.Context()\n\t\tctx = context.WithValue(ctx, ACMETxtKey, postData)\n\t\tr = r.WithContext(ctx)\n\t\tupdate(w, r, p)\n\t}\n}\n\nfunc getExpect(t *testing.T, server *httptest.Server) *httpexpect.Expect {\n\treturn httpexpect.WithConfig(httpexpect.Config{\n\t\tBaseURL:  server.URL,\n\t\tReporter: httpexpect.NewAssertReporter(t),\n\t\tPrinters: []httpexpect.Printer{\n\t\t\thttpexpect.NewCurlPrinter(t),\n\t\t\thttpexpect.NewDebugPrinter(t, true),\n\t\t},\n\t})\n}\n\nfunc setupRouter(debug bool, noauth bool) http.Handler {\n\tapi := httprouter.New()\n\tvar dbcfg = dbsettings{\n\t\tEngine:     \"sqlite3\",\n\t\tConnection: \":memory:\"}\n\tvar httpapicfg = httpapi{\n\t\tDomain:      \"\",\n\t\tPort:        \"8080\",\n\t\tTLS:         \"none\",\n\t\tCorsOrigins: []string{\"*\"},\n\t\tUseHeader:   true,\n\t\tHeaderName:  \"X-Forwarded-For\",\n\t}\n\tvar dnscfg = DNSConfig{\n\t\tAPI:      httpapicfg,\n\t\tDatabase: dbcfg,\n\t}\n\tConfig = dnscfg\n\tc := cors.New(cors.Options{\n\t\tAllowedOrigins:     Config.API.CorsOrigins,\n\t\tAllowedMethods:     []string{\"GET\", \"POST\"},\n\t\tOptionsPassthrough: false,\n\t\tDebug:              Config.General.Debug,\n\t})\n\tapi.POST(\"/register\", webRegisterPost)\n\tapi.GET(\"/health\", healthCheck)\n\tif noauth {\n\t\tapi.POST(\"/update\", noAuth(webUpdatePost))\n\t} else {\n\t\tapi.POST(\"/update\", Auth(webUpdatePost))\n\t}\n\treturn c.Handler(api)\n}\n\nfunc TestApiRegister(t *testing.T) {\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\te.POST(\"/register\").Expect().\n\t\tStatus(http.StatusCreated).\n\t\tJSON().Object().\n\t\tContainsKey(\"fulldomain\").\n\t\tContainsKey(\"subdomain\").\n\t\tContainsKey(\"username\").\n\t\tContainsKey(\"password\").\n\t\tNotContainsKey(\"error\")\n\n\tallowfrom := map[string][]interface{}{\n\t\t\"allowfrom\": []interface{}{\"123.123.123.123/32\",\n\t\t\t\"2001:db8:a0b:12f0::1/32\",\n\t\t\t\"[::1]/64\",\n\t\t},\n\t}\n\n\tresponse := e.POST(\"/register\").\n\t\tWithJSON(allowfrom).\n\t\tExpect().\n\t\tStatus(http.StatusCreated).\n\t\tJSON().Object().\n\t\tContainsKey(\"fulldomain\").\n\t\tContainsKey(\"subdomain\").\n\t\tContainsKey(\"username\").\n\t\tContainsKey(\"password\").\n\t\tContainsKey(\"allowfrom\").\n\t\tNotContainsKey(\"error\")\n\n\tresponse.Value(\"allowfrom\").Array().Elements(\"123.123.123.123/32\", \"2001:db8:a0b:12f0::1/32\", \"::1/64\")\n}\n\nfunc TestApiRegisterBadAllowFrom(t *testing.T) {\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\tinvalidVals := []string{\n\t\t\"invalid\",\n\t\t\"1.2.3.4/33\",\n\t\t\"1.2/24\",\n\t\t\"1.2.3.4\",\n\t\t\"12345:db8:a0b:12f0::1/32\",\n\t\t\"1234::123::123::1/32\",\n\t}\n\n\tfor _, v := range invalidVals {\n\n\t\tallowfrom := map[string][]interface{}{\n\t\t\t\"allowfrom\": []interface{}{v}}\n\n\t\tresponse := e.POST(\"/register\").\n\t\t\tWithJSON(allowfrom).\n\t\t\tExpect().\n\t\t\tStatus(http.StatusBadRequest).\n\t\t\tJSON().Object().\n\t\t\tContainsKey(\"error\")\n\n\t\tresponse.Value(\"error\").Equal(\"invalid_allowfrom_cidr\")\n\t}\n}\n\nfunc TestApiRegisterMalformedJSON(t *testing.T) {\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\n\tmalPayloads := []string{\n\t\t\"{\\\"allowfrom': '1.1.1.1/32'}\",\n\t\t\"\\\"allowfrom\\\": \\\"1.1.1.1/32\\\"\",\n\t\t\"{\\\"allowfrom\\\": \\\"[1.1.1.1/32]\\\"\",\n\t\t\"\\\"allowfrom\\\": \\\"1.1.1.1/32\\\"}\",\n\t\t\"{allowfrom: \\\"1.2.3.4\\\"}\",\n\t\t\"{allowfrom: [1.2.3.4]}\",\n\t\t\"whatever that's not a json payload\",\n\t}\n\tfor _, test := range malPayloads {\n\t\te.POST(\"/register\").\n\t\t\tWithBytes([]byte(test)).\n\t\t\tExpect().\n\t\t\tStatus(http.StatusBadRequest).\n\t\t\tJSON().Object().\n\t\t\tContainsKey(\"error\").\n\t\t\tNotContainsKey(\"subdomain\").\n\t\t\tNotContainsKey(\"username\")\n\t}\n}\n\nfunc TestApiRegisterWithMockDB(t *testing.T) {\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\toldDb := DB.GetBackend()\n\tdb, mock, _ := sqlmock.New()\n\tDB.SetBackend(db)\n\tdefer db.Close()\n\tmock.ExpectBegin()\n\tmock.ExpectPrepare(\"INSERT INTO records\").WillReturnError(errors.New(\"error\"))\n\te.POST(\"/register\").Expect().\n\t\tStatus(http.StatusInternalServerError).\n\t\tJSON().Object().\n\t\tContainsKey(\"error\")\n\tDB.SetBackend(oldDb)\n}\n\nfunc TestApiUpdateWithInvalidSubdomain(t *testing.T) {\n\tvalidTxtData := \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n\tupdateJSON := map[string]interface{}{\n\t\t\"subdomain\": \"\",\n\t\t\"txt\":       \"\"}\n\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\tnewUser, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Could not create new user, got error [%v]\", err)\n\t}\n\t// Invalid subdomain data\n\tupdateJSON[\"subdomain\"] = \"example.com\"\n\tupdateJSON[\"txt\"] = validTxtData\n\te.POST(\"/update\").\n\t\tWithJSON(updateJSON).\n\t\tWithHeader(\"X-Api-User\", newUser.Username.String()).\n\t\tWithHeader(\"X-Api-Key\", newUser.Password).\n\t\tExpect().\n\t\tStatus(http.StatusUnauthorized).\n\t\tJSON().Object().\n\t\tContainsKey(\"error\").\n\t\tNotContainsKey(\"txt\").\n\t\tValueEqual(\"error\", \"forbidden\")\n}\n\nfunc TestApiUpdateWithInvalidTxt(t *testing.T) {\n\tinvalidTXTData := \"idk m8 bbl lmao\"\n\n\tupdateJSON := map[string]interface{}{\n\t\t\"subdomain\": \"\",\n\t\t\"txt\":       \"\"}\n\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\tnewUser, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Could not create new user, got error [%v]\", err)\n\t}\n\tupdateJSON[\"subdomain\"] = newUser.Subdomain\n\t// Invalid txt data\n\tupdateJSON[\"txt\"] = invalidTXTData\n\te.POST(\"/update\").\n\t\tWithJSON(updateJSON).\n\t\tWithHeader(\"X-Api-User\", newUser.Username.String()).\n\t\tWithHeader(\"X-Api-Key\", newUser.Password).\n\t\tExpect().\n\t\tStatus(http.StatusBadRequest).\n\t\tJSON().Object().\n\t\tContainsKey(\"error\").\n\t\tNotContainsKey(\"txt\").\n\t\tValueEqual(\"error\", \"bad_txt\")\n}\n\nfunc TestApiUpdateWithoutCredentials(t *testing.T) {\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\te.POST(\"/update\").Expect().\n\t\tStatus(http.StatusUnauthorized).\n\t\tJSON().Object().\n\t\tContainsKey(\"error\").\n\t\tNotContainsKey(\"txt\")\n}\n\nfunc TestApiUpdateWithCredentials(t *testing.T) {\n\tvalidTxtData := \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n\tupdateJSON := map[string]interface{}{\n\t\t\"subdomain\": \"\",\n\t\t\"txt\":       \"\"}\n\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\tnewUser, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Could not create new user, got error [%v]\", err)\n\t}\n\t// Valid data\n\tupdateJSON[\"subdomain\"] = newUser.Subdomain\n\tupdateJSON[\"txt\"] = validTxtData\n\te.POST(\"/update\").\n\t\tWithJSON(updateJSON).\n\t\tWithHeader(\"X-Api-User\", newUser.Username.String()).\n\t\tWithHeader(\"X-Api-Key\", newUser.Password).\n\t\tExpect().\n\t\tStatus(http.StatusOK).\n\t\tJSON().Object().\n\t\tContainsKey(\"txt\").\n\t\tNotContainsKey(\"error\").\n\t\tValueEqual(\"txt\", validTxtData)\n}\n\nfunc TestApiUpdateWithCredentialsMockDB(t *testing.T) {\n\tvalidTxtData := \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\tupdateJSON := map[string]interface{}{\n\t\t\"subdomain\": \"\",\n\t\t\"txt\":       \"\"}\n\n\t// Valid data\n\tupdateJSON[\"subdomain\"] = \"a097455b-52cc-4569-90c8-7a4b97c6eba8\"\n\tupdateJSON[\"txt\"] = validTxtData\n\n\trouter := setupRouter(false, true)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\toldDb := DB.GetBackend()\n\tdb, mock, _ := sqlmock.New()\n\tDB.SetBackend(db)\n\tdefer db.Close()\n\tmock.ExpectBegin()\n\tmock.ExpectPrepare(\"UPDATE records\").WillReturnError(errors.New(\"error\"))\n\te.POST(\"/update\").\n\t\tWithJSON(updateJSON).\n\t\tExpect().\n\t\tStatus(http.StatusInternalServerError).\n\t\tJSON().Object().\n\t\tContainsKey(\"error\")\n\tDB.SetBackend(oldDb)\n}\n\nfunc TestApiManyUpdateWithCredentials(t *testing.T) {\n\tvalidTxtData := \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n\trouter := setupRouter(true, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\t// User without defined CIDR masks\n\tnewUser, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Could not create new user, got error [%v]\", err)\n\t}\n\n\t// User with defined allow from - CIDR masks, all invalid\n\t// (httpexpect doesn't provide a way to mock remote ip)\n\tnewUserWithCIDR, err := DB.Register(cidrslice{\"192.168.1.1/32\", \"invalid\"})\n\tif err != nil {\n\t\tt.Errorf(\"Could not create new user with CIDR, got error [%v]\", err)\n\t}\n\n\t// Another user with valid CIDR mask to match the httpexpect default\n\tnewUserWithValidCIDR, err := DB.Register(cidrslice{\"10.1.2.3/32\", \"invalid\"})\n\tif err != nil {\n\t\tt.Errorf(\"Could not create new user with a valid CIDR, got error [%v]\", err)\n\t}\n\n\tfor _, test := range []struct {\n\t\tuser      string\n\t\tpass      string\n\t\tsubdomain string\n\t\ttxt       interface{}\n\t\tstatus    int\n\t}{\n\t\t{\"non-uuid-user\", \"tooshortpass\", \"non-uuid-subdomain\", validTxtData, 401},\n\t\t{\"a097455b-52cc-4569-90c8-7a4b97c6eba8\", \"tooshortpass\", \"bb97455b-52cc-4569-90c8-7a4b97c6eba8\", validTxtData, 401},\n\t\t{\"a097455b-52cc-4569-90c8-7a4b97c6eba8\", \"LongEnoughPassButNoUserExists___________\", \"bb97455b-52cc-4569-90c8-7a4b97c6eba8\", validTxtData, 401},\n\t\t{newUser.Username.String(), newUser.Password, \"a097455b-52cc-4569-90c8-7a4b97c6eba8\", validTxtData, 401},\n\t\t{newUser.Username.String(), newUser.Password, newUser.Subdomain, \"tooshortfortxt\", 400},\n\t\t{newUser.Username.String(), newUser.Password, newUser.Subdomain, 1234567890, 400},\n\t\t{newUser.Username.String(), newUser.Password, newUser.Subdomain, validTxtData, 200},\n\t\t{newUserWithCIDR.Username.String(), newUserWithCIDR.Password, newUserWithCIDR.Subdomain, validTxtData, 401},\n\t\t{newUserWithValidCIDR.Username.String(), newUserWithValidCIDR.Password, newUserWithValidCIDR.Subdomain, validTxtData, 200},\n\t\t{newUser.Username.String(), \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", newUser.Subdomain, validTxtData, 401},\n\t} {\n\t\tupdateJSON := map[string]interface{}{\n\t\t\t\"subdomain\": test.subdomain,\n\t\t\t\"txt\":       test.txt}\n\t\te.POST(\"/update\").\n\t\t\tWithJSON(updateJSON).\n\t\t\tWithHeader(\"X-Api-User\", test.user).\n\t\t\tWithHeader(\"X-Api-Key\", test.pass).\n\t\t\tWithHeader(\"X-Forwarded-For\", \"10.1.2.3\").\n\t\t\tExpect().\n\t\t\tStatus(test.status)\n\t}\n}\n\nfunc TestApiManyUpdateWithIpCheckHeaders(t *testing.T) {\n\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\t// Use header checks from default header (X-Forwarded-For)\n\tConfig.API.UseHeader = true\n\t// User without defined CIDR masks\n\tnewUser, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Could not create new user, got error [%v]\", err)\n\t}\n\n\tnewUserWithCIDR, err := DB.Register(cidrslice{\"192.168.1.2/32\", \"invalid\"})\n\tif err != nil {\n\t\tt.Errorf(\"Could not create new user with CIDR, got error [%v]\", err)\n\t}\n\n\tnewUserWithIP6CIDR, err := DB.Register(cidrslice{\"2002:c0a8::0/32\"})\n\tif err != nil {\n\t\tt.Errorf(\"Could not create a new user with IP6 CIDR, got error [%v]\", err)\n\t}\n\n\tfor _, test := range []struct {\n\t\tuser        ACMETxt\n\t\theaderValue string\n\t\tstatus      int\n\t}{\n\t\t{newUser, \"whatever goes\", 200},\n\t\t{newUser, \"10.0.0.1, 1.2.3.4 ,3.4.5.6\", 200},\n\t\t{newUserWithCIDR, \"127.0.0.1\", 401},\n\t\t{newUserWithCIDR, \"10.0.0.1, 10.0.0.2, 192.168.1.3\", 401},\n\t\t{newUserWithCIDR, \"10.1.1.1 ,192.168.1.2, 8.8.8.8\", 200},\n\t\t{newUserWithIP6CIDR, \"2002:c0a8:b4dc:0d3::0\", 200},\n\t\t{newUserWithIP6CIDR, \"2002:c0a7:0ff::0\", 401},\n\t\t{newUserWithIP6CIDR, \"2002:c0a8:d3ad:b33f:c0ff:33b4:dc0d:3b4d\", 200},\n\t} {\n\t\tupdateJSON := map[string]interface{}{\n\t\t\t\"subdomain\": test.user.Subdomain,\n\t\t\t\"txt\":       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"}\n\t\te.POST(\"/update\").\n\t\t\tWithJSON(updateJSON).\n\t\t\tWithHeader(\"X-Api-User\", test.user.Username.String()).\n\t\t\tWithHeader(\"X-Api-Key\", test.user.Password).\n\t\t\tWithHeader(\"X-Forwarded-For\", test.headerValue).\n\t\t\tExpect().\n\t\t\tStatus(test.status)\n\t}\n\tConfig.API.UseHeader = false\n}\n\nfunc TestApiHealthCheck(t *testing.T) {\n\trouter := setupRouter(false, false)\n\tserver := httptest.NewServer(router)\n\tdefer server.Close()\n\te := getExpect(t, server)\n\te.GET(\"/health\").Expect().Status(http.StatusOK)\n}\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 2.9150390625,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/julienschmidt/httprouter\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\ntype key int\n\n// ACMETxtKey is a context key for ACMETxt struct\nconst ACMETxtKey key = 0\n\n// Auth middleware for update request\nfunc Auth(update httprouter.Handle) httprouter.Handle {\n\treturn func(w http.ResponseWriter, r *http.Request, p httprouter.Params) {\n\t\tpostData := ACMETxt{}\n\t\tuserOK := false\n\t\tuser, err := getUserFromRequest(r)\n\t\tif err == nil {\n\t\t\tif updateAllowedFromIP(r, user) {\n\t\t\t\tdec := json.NewDecoder(r.Body)\n\t\t\t\terr = dec.Decode(&postData)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.WithFields(log.Fields{\"error\": \"json_error\", \"string\": err.Error()}).Error(\"Decode error\")\n\t\t\t\t}\n\t\t\t\tif user.Subdomain == postData.Subdomain {\n\t\t\t\t\tuserOK = true\n\t\t\t\t} else {\n\t\t\t\t\tlog.WithFields(log.Fields{\"error\": \"subdomain_mismatch\", \"name\": postData.Subdomain, \"expected\": user.Subdomain}).Error(\"Subdomain mismatch\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.WithFields(log.Fields{\"error\": \"ip_unauthorized\"}).Error(\"Update not allowed from IP\")\n\t\t\t}\n\t\t} else {\n\t\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Error(\"Error while trying to get user\")\n\t\t}\n\t\tif userOK {\n\t\t\t// Set user info to the decoded ACMETxt object\n\t\t\tpostData.Username = user.Username\n\t\t\tpostData.Password = user.Password\n\t\t\t// Set the ACMETxt struct to context to pull in from update function\n\t\t\tctx := context.WithValue(r.Context(), ACMETxtKey, postData)\n\t\t\tupdate(w, r.WithContext(ctx), p)\n\t\t} else {\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\t_, _ = w.Write(jsonError(\"forbidden\"))\n\t\t}\n\t}\n}\n\nfunc getUserFromRequest(r *http.Request) (ACMETxt, error) {\n\tuname := r.Header.Get(\"X-Api-User\")\n\tpasswd := r.Header.Get(\"X-Api-Key\")\n\tusername, err := getValidUsername(uname)\n\tif err != nil {\n\t\treturn ACMETxt{}, fmt.Errorf(\"Invalid username: %s: %s\", uname, err.Error())\n\t}\n\tif validKey(passwd) {\n\t\tdbuser, err := DB.GetByUsername(username)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Error(\"Error while trying to get user\")\n\t\t\t// To protect against timed side channel (never gonna give you up)\n\t\t\tcorrectPassword(passwd, \"$2a$10$8JEFVNYYhLoBysjAxe2yBuXrkDojBQBkVpXEQgyQyjn43SvJ4vL36\")\n\n\t\t\treturn ACMETxt{}, fmt.Errorf(\"Invalid username: %s\", uname)\n\t\t}\n\t\tif correctPassword(passwd, dbuser.Password) {\n\t\t\treturn dbuser, nil\n\t\t}\n\t\treturn ACMETxt{}, fmt.Errorf(\"Invalid password for user %s\", uname)\n\t}\n\treturn ACMETxt{}, fmt.Errorf(\"Invalid key for user %s\", uname)\n}\n\nfunc updateAllowedFromIP(r *http.Request, user ACMETxt) bool {\n\tif Config.API.UseHeader {\n\t\tips := getIPListFromHeader(r.Header.Get(Config.API.HeaderName))\n\t\treturn user.allowedFromList(ips)\n\t}\n\thost, _, err := net.SplitHostPort(r.RemoteAddr)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"error\": err.Error(), \"remoteaddr\": r.RemoteAddr}).Error(\"Error while parsing remote address\")\n\t\thost = \"\"\n\t}\n\treturn user.allowedFrom(host)\n}\n"
        },
        {
          "name": "auth_test.go",
          "type": "blob",
          "size": 0.81640625,
          "content": "package main\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestUpdateAllowedFromIP(t *testing.T) {\n\tConfig.API.UseHeader = false\n\tuserWithAllow := newACMETxt()\n\tuserWithAllow.AllowFrom = cidrslice{\"192.168.1.2/32\", \"[::1]/128\"}\n\tuserWithoutAllow := newACMETxt()\n\n\tfor i, test := range []struct {\n\t\tremoteaddr string\n\t\texpected   bool\n\t}{\n\t\t{\"192.168.1.2:1234\", true},\n\t\t{\"192.168.1.1:1234\", false},\n\t\t{\"invalid\", false},\n\t\t{\"[::1]:4567\", true},\n\t} {\n\t\tnewreq, _ := http.NewRequest(\"GET\", \"/whatever\", nil)\n\t\tnewreq.RemoteAddr = test.remoteaddr\n\t\tret := updateAllowedFromIP(newreq, userWithAllow)\n\t\tif test.expected != ret {\n\t\t\tt.Errorf(\"Test %d: Unexpected result for user with allowForm set\", i)\n\t\t}\n\n\t\tif !updateAllowedFromIP(newreq, userWithoutAllow) {\n\t\t\tt.Errorf(\"Test %d: Unexpected result for user without allowForm set\", i)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "challengeprovider.go",
          "type": "blob",
          "size": 1.1103515625,
          "content": "package main\n\nimport (\n\t\"context\"\n\n\t\"github.com/mholt/acmez/v2/acme\"\n)\n\n// ChallengeProvider implements go-acme/lego Provider interface which is used for ACME DNS challenge handling\ntype ChallengeProvider struct {\n\tservers []*DNSServer\n}\n\n// NewChallengeProvider creates a new instance of ChallengeProvider\nfunc NewChallengeProvider(servers []*DNSServer) ChallengeProvider {\n\treturn ChallengeProvider{servers: servers}\n}\n\n// Present is used for making the ACME DNS challenge token available for DNS\nfunc (c *ChallengeProvider) Present(ctx context.Context, challenge acme.Challenge) error {\n\tfor _, s := range c.servers {\n\t\ts.PersonalKeyAuth = challenge.DNS01KeyAuthorization()\n\t}\n\treturn nil\n}\n\n// CleanUp is called after the run to remove the ACME DNS challenge tokens from DNS records\nfunc (c *ChallengeProvider) CleanUp(ctx context.Context, _ acme.Challenge) error {\n\tfor _, s := range c.servers {\n\t\ts.PersonalKeyAuth = \"\"\n\t}\n\treturn nil\n}\n\n// Wait is a dummy function as we are just going to be ready to answer the challenge from the get-go\nfunc (c *ChallengeProvider) Wait(_ context.Context, _ acme.Challenge) error {\n\treturn nil\n}\n"
        },
        {
          "name": "config.cfg",
          "type": "blob",
          "size": 2.296875,
          "content": "[general]\n# DNS interface. Note that systemd-resolved may reserve port 53 on 127.0.0.53\n# In this case acme-dns will error out and you will need to define the listening interface\n# for example: listen = \"127.0.0.1:53\"\nlisten = \"127.0.0.1:53\"\n# protocol, \"both\", \"both4\", \"both6\", \"udp\", \"udp4\", \"udp6\" or \"tcp\", \"tcp4\", \"tcp6\"\nprotocol = \"both\"\n# domain name to serve the requests off of\ndomain = \"auth.example.org\"\n# zone name server\nnsname = \"auth.example.org\"\n# admin email address, where @Â is substituted with .\nnsadmin = \"admin.example.org\"\n# predefined records served in addition to the TXT\nrecords = [\n    # domain pointing to the public IP of your acme-dns server \n    \"auth.example.org. A 198.51.100.1\",\n    # specify that auth.example.org will resolve any *.auth.example.org records\n    \"auth.example.org. NS auth.example.org.\",\n]\n# debug messages from CORS etc\ndebug = false\n\n[database]\n# Database engine to use, sqlite3 or postgres\nengine = \"sqlite3\"\n# Connection string, filename for sqlite3 and postgres://$username:$password@$host/$db_name for postgres\n# Please note that the default Docker image uses path /var/lib/acme-dns/acme-dns.db for sqlite3\nconnection = \"/var/lib/acme-dns/acme-dns.db\"\n# connection = \"postgres://user:password@localhost/acmedns_db\"\n\n[api]\n# listen ip eg. 127.0.0.1\nip = \"0.0.0.0\"\n# disable registration endpoint\ndisable_registration = false\n# listen port, eg. 443 for default HTTPS\nport = \"443\"\n# possible values: \"letsencrypt\", \"letsencryptstaging\", \"cert\", \"none\"\ntls = \"letsencryptstaging\"\n# only used if tls = \"cert\"\ntls_cert_privkey = \"/etc/tls/example.org/privkey.pem\"\ntls_cert_fullchain = \"/etc/tls/example.org/fullchain.pem\"\n# only used if tls = \"letsencrypt\"\nacme_cache_dir = \"api-certs\"\n# optional e-mail address to which Let's Encrypt will send expiration notices for the API's cert\nnotification_email = \"\"\n# CORS AllowOrigins, wildcards can be used\ncorsorigins = [\n    \"*\"\n]\n# use HTTP header to get the client ip\nuse_header = false\n# header name to pull the ip address / list of ip addresses from\nheader_name = \"X-Forwarded-For\"\n\n[logconfig]\n# logging level: \"error\", \"warning\", \"info\" or \"debug\"\nloglevel = \"debug\"\n# possible values: stdout, TODO file & integrations\nlogtype = \"stdout\"\n# file path for logfile TODO\n# logfile = \"./acme-dns.log\"\n# format, either \"json\" or \"text\"\nlogformat = \"text\"\n"
        },
        {
          "name": "db.go",
          "type": "blob",
          "size": 7.765625,
          "content": "package main\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t_ \"github.com/lib/pq\"\n\t_ \"github.com/mattn/go-sqlite3\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// DBVersion shows the database version this code uses. This is used for update checks.\nvar DBVersion = 1\n\nvar acmeTable = `\n\tCREATE TABLE IF NOT EXISTS acmedns(\n\t\tName TEXT,\n\t\tValue TEXT\n\t);`\n\nvar userTable = `\n\tCREATE TABLE IF NOT EXISTS records(\n        Username TEXT UNIQUE NOT NULL PRIMARY KEY,\n        Password TEXT UNIQUE NOT NULL,\n        Subdomain TEXT UNIQUE NOT NULL,\n\t\tAllowFrom TEXT\n    );`\n\nvar txtTable = `\n    CREATE TABLE IF NOT EXISTS txt(\n\t\tSubdomain TEXT NOT NULL,\n\t\tValue   TEXT NOT NULL DEFAULT '',\n\t\tLastUpdate INT\n\t);`\n\nvar txtTablePG = `\n    CREATE TABLE IF NOT EXISTS txt(\n\t\trowid SERIAL,\n\t\tSubdomain TEXT NOT NULL,\n\t\tValue   TEXT NOT NULL DEFAULT '',\n\t\tLastUpdate INT\n\t);`\n\n// getSQLiteStmt replaces all PostgreSQL prepared statement placeholders (eg. $1, $2) with SQLite variant \"?\"\nfunc getSQLiteStmt(s string) string {\n\tre, _ := regexp.Compile(`\\$[0-9]`)\n\treturn re.ReplaceAllString(s, \"?\")\n}\n\nfunc (d *acmedb) Init(engine string, connection string) error {\n\td.Mutex.Lock()\n\tdefer d.Mutex.Unlock()\n\tdb, err := sql.Open(engine, connection)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.DB = db\n\t// Check version first to try to catch old versions without version string\n\tvar versionString string\n\t_ = d.DB.QueryRow(\"SELECT Value FROM acmedns WHERE Name='db_version'\").Scan(&versionString)\n\tif versionString == \"\" {\n\t\tversionString = \"0\"\n\t}\n\t_, _ = d.DB.Exec(acmeTable)\n\t_, _ = d.DB.Exec(userTable)\n\tif Config.Database.Engine == \"sqlite3\" {\n\t\t_, _ = d.DB.Exec(txtTable)\n\t} else {\n\t\t_, _ = d.DB.Exec(txtTablePG)\n\t}\n\t// If everything is fine, handle db upgrade tasks\n\tif err == nil {\n\t\terr = d.checkDBUpgrades(versionString)\n\t}\n\tif err == nil {\n\t\tif versionString == \"0\" {\n\t\t\t// No errors so we should now be in version 1\n\t\t\tinsversion := fmt.Sprintf(\"INSERT INTO acmedns (Name, Value) values('db_version', '%d')\", DBVersion)\n\t\t\t_, err = db.Exec(insversion)\n\t\t}\n\t}\n\treturn err\n}\n\nfunc (d *acmedb) checkDBUpgrades(versionString string) error {\n\tvar err error\n\tversion, err := strconv.Atoi(versionString)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif version != DBVersion {\n\t\treturn d.handleDBUpgrades(version)\n\t}\n\treturn nil\n\n}\n\nfunc (d *acmedb) handleDBUpgrades(version int) error {\n\tif version == 0 {\n\t\treturn d.handleDBUpgradeTo1()\n\t}\n\treturn nil\n}\n\nfunc (d *acmedb) handleDBUpgradeTo1() error {\n\tvar err error\n\tvar subdomains []string\n\trows, err := d.DB.Query(\"SELECT Subdomain FROM records\")\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Error(\"Error in DB upgrade\")\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\tvar subdomain string\n\t\terr = rows.Scan(&subdomain)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Error(\"Error in DB upgrade while reading values\")\n\t\t\treturn err\n\t\t}\n\t\tsubdomains = append(subdomains, subdomain)\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Error(\"Error in DB upgrade while inserting values\")\n\t\treturn err\n\t}\n\ttx, err := d.DB.Begin()\n\t// Rollback if errored, commit if not\n\tdefer func() {\n\t\tif err != nil {\n\t\t\t_ = tx.Rollback()\n\t\t\treturn\n\t\t}\n\t\t_ = tx.Commit()\n\t}()\n\t_, _ = tx.Exec(\"DELETE FROM txt\")\n\tfor _, subdomain := range subdomains {\n\t\tif subdomain != \"\" {\n\t\t\t// Insert two rows for each subdomain to txt table\n\t\t\terr = d.NewTXTValuesInTransaction(tx, subdomain)\n\t\t\tif err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Error(\"Error in DB upgrade while inserting values\")\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\t// SQLite doesn't support dropping columns\n\tif Config.Database.Engine != \"sqlite3\" {\n\t\t_, _ = tx.Exec(\"ALTER TABLE records DROP COLUMN IF EXISTS Value\")\n\t\t_, _ = tx.Exec(\"ALTER TABLE records DROP COLUMN IF EXISTS LastActive\")\n\t}\n\t_, err = tx.Exec(\"UPDATE acmedns SET Value='1' WHERE Name='db_version'\")\n\treturn err\n}\n\n// Create two rows for subdomain to the txt table\nfunc (d *acmedb) NewTXTValuesInTransaction(tx *sql.Tx, subdomain string) error {\n\tvar err error\n\tinstr := fmt.Sprintf(\"INSERT INTO txt (Subdomain, LastUpdate) values('%s', 0)\", subdomain)\n\t_, _ = tx.Exec(instr)\n\t_, _ = tx.Exec(instr)\n\treturn err\n}\n\nfunc (d *acmedb) Register(afrom cidrslice) (ACMETxt, error) {\n\td.Mutex.Lock()\n\tdefer d.Mutex.Unlock()\n\tvar err error\n\ttx, err := d.DB.Begin()\n\t// Rollback if errored, commit if not\n\tdefer func() {\n\t\tif err != nil {\n\t\t\t_ = tx.Rollback()\n\t\t\treturn\n\t\t}\n\t\t_ = tx.Commit()\n\t}()\n\ta := newACMETxt()\n\ta.AllowFrom = cidrslice(afrom.ValidEntries())\n\tpasswordHash, err := bcrypt.GenerateFromPassword([]byte(a.Password), 10)\n\tregSQL := `\n    INSERT INTO records(\n        Username,\n        Password,\n        Subdomain,\n\t\tAllowFrom) \n        values($1, $2, $3, $4)`\n\tif Config.Database.Engine == \"sqlite3\" {\n\t\tregSQL = getSQLiteStmt(regSQL)\n\t}\n\tsm, err := tx.Prepare(regSQL)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Error(\"Database error in prepare\")\n\t\treturn a, errors.New(\"SQL error\")\n\t}\n\tdefer sm.Close()\n\t_, err = sm.Exec(a.Username.String(), passwordHash, a.Subdomain, a.AllowFrom.JSON())\n\tif err == nil {\n\t\terr = d.NewTXTValuesInTransaction(tx, a.Subdomain)\n\t}\n\treturn a, err\n}\n\nfunc (d *acmedb) GetByUsername(u uuid.UUID) (ACMETxt, error) {\n\td.Mutex.Lock()\n\tdefer d.Mutex.Unlock()\n\tvar results []ACMETxt\n\tgetSQL := `\n\tSELECT Username, Password, Subdomain, AllowFrom\n\tFROM records\n\tWHERE Username=$1 LIMIT 1\n\t`\n\tif Config.Database.Engine == \"sqlite3\" {\n\t\tgetSQL = getSQLiteStmt(getSQL)\n\t}\n\n\tsm, err := d.DB.Prepare(getSQL)\n\tif err != nil {\n\t\treturn ACMETxt{}, err\n\t}\n\tdefer sm.Close()\n\trows, err := sm.Query(u.String())\n\tif err != nil {\n\t\treturn ACMETxt{}, err\n\t}\n\tdefer rows.Close()\n\n\t// It will only be one row though\n\tfor rows.Next() {\n\t\ttxt, err := getModelFromRow(rows)\n\t\tif err != nil {\n\t\t\treturn ACMETxt{}, err\n\t\t}\n\t\tresults = append(results, txt)\n\t}\n\tif len(results) > 0 {\n\t\treturn results[0], nil\n\t}\n\treturn ACMETxt{}, errors.New(\"no user\")\n}\n\nfunc (d *acmedb) GetTXTForDomain(domain string) ([]string, error) {\n\td.Mutex.Lock()\n\tdefer d.Mutex.Unlock()\n\tdomain = sanitizeString(domain)\n\tvar txts []string\n\tgetSQL := `\n\tSELECT Value FROM txt WHERE Subdomain=$1 LIMIT 2\n\t`\n\tif Config.Database.Engine == \"sqlite3\" {\n\t\tgetSQL = getSQLiteStmt(getSQL)\n\t}\n\n\tsm, err := d.DB.Prepare(getSQL)\n\tif err != nil {\n\t\treturn txts, err\n\t}\n\tdefer sm.Close()\n\trows, err := sm.Query(domain)\n\tif err != nil {\n\t\treturn txts, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar rtxt string\n\t\terr = rows.Scan(&rtxt)\n\t\tif err != nil {\n\t\t\treturn txts, err\n\t\t}\n\t\ttxts = append(txts, rtxt)\n\t}\n\treturn txts, nil\n}\n\nfunc (d *acmedb) Update(a ACMETxtPost) error {\n\td.Mutex.Lock()\n\tdefer d.Mutex.Unlock()\n\tvar err error\n\t// Data in a is already sanitized\n\ttimenow := time.Now().Unix()\n\n\tupdSQL := `\n\tUPDATE txt SET Value=$1, LastUpdate=$2\n\tWHERE rowid=(\n\t\tSELECT rowid FROM txt WHERE Subdomain=$3 ORDER BY LastUpdate LIMIT 1)\n\t`\n\tif Config.Database.Engine == \"sqlite3\" {\n\t\tupdSQL = getSQLiteStmt(updSQL)\n\t}\n\n\tsm, err := d.DB.Prepare(updSQL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer sm.Close()\n\t_, err = sm.Exec(a.Value, timenow, a.Subdomain)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc getModelFromRow(r *sql.Rows) (ACMETxt, error) {\n\ttxt := ACMETxt{}\n\tafrom := \"\"\n\terr := r.Scan(\n\t\t&txt.Username,\n\t\t&txt.Password,\n\t\t&txt.Subdomain,\n\t\t&afrom)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Error(\"Row scan error\")\n\t}\n\n\tcslice := cidrslice{}\n\terr = json.Unmarshal([]byte(afrom), &cslice)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Error(\"JSON unmarshall error\")\n\t}\n\ttxt.AllowFrom = cslice\n\treturn txt, err\n}\n\nfunc (d *acmedb) Close() {\n\td.DB.Close()\n}\n\nfunc (d *acmedb) GetBackend() *sql.DB {\n\treturn d.DB\n}\n\nfunc (d *acmedb) SetBackend(backend *sql.DB) {\n\td.DB = backend\n}\n"
        },
        {
          "name": "db_test.go",
          "type": "blob",
          "size": 7.8427734375,
          "content": "package main\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"github.com/erikstmartin/go-testdb\"\n\t\"testing\"\n)\n\ntype testResult struct {\n\tlastID       int64\n\taffectedRows int64\n}\n\nfunc (r testResult) LastInsertId() (int64, error) {\n\treturn r.lastID, nil\n}\n\nfunc (r testResult) RowsAffected() (int64, error) {\n\treturn r.affectedRows, nil\n}\n\nfunc TestDBInit(t *testing.T) {\n\tfakeDB := new(acmedb)\n\terr := fakeDB.Init(\"notarealegine\", \"connectionstring\")\n\tif err == nil {\n\t\tt.Errorf(\"Was expecting error, didn't get one.\")\n\t}\n\n\ttestdb.SetExecWithArgsFunc(func(query string, args []driver.Value) (result driver.Result, err error) {\n\t\treturn testResult{1, 0}, errors.New(\"Prepared query error\")\n\t})\n\tdefer testdb.Reset()\n\n\terrorDB := new(acmedb)\n\terr = errorDB.Init(\"testdb\", \"\")\n\tif err == nil {\n\t\tt.Errorf(\"Was expecting DB initiation error but got none\")\n\t}\n\terrorDB.Close()\n}\n\nfunc TestRegisterNoCIDR(t *testing.T) {\n\t// Register tests\n\t_, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Registration failed, got error [%v]\", err)\n\t}\n}\n\nfunc TestRegisterMany(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tinput  cidrslice\n\t\toutput cidrslice\n\t}{\n\t\t{cidrslice{\"127.0.0.1/8\", \"8.8.8.8/32\", \"1.0.0.1/1\"}, cidrslice{\"127.0.0.1/8\", \"8.8.8.8/32\", \"1.0.0.1/1\"}},\n\t\t{cidrslice{\"1.1.1./32\", \"1922.168.42.42/8\", \"1.1.1.1/33\", \"1.2.3.4/\"}, cidrslice{}},\n\t\t{cidrslice{\"7.6.5.4/32\", \"invalid\", \"1.0.0.1/2\"}, cidrslice{\"7.6.5.4/32\", \"1.0.0.1/2\"}},\n\t} {\n\t\tuser, err := DB.Register(test.input)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Test %d: Got error from register method: [%v]\", i, err)\n\t\t}\n\t\tres, err := DB.GetByUsername(user.Username)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Test %d: Got error when fetching username: [%v]\", i, err)\n\t\t}\n\t\tif len(user.AllowFrom) != len(test.output) {\n\t\t\tt.Errorf(\"Test %d: Expected to receive struct with [%d] entries in AllowFrom, but got [%d] records\", i, len(test.output), len(user.AllowFrom))\n\t\t}\n\t\tif len(res.AllowFrom) != len(test.output) {\n\t\t\tt.Errorf(\"Test %d: Expected to receive struct with [%d] entries in AllowFrom, but got [%d] records\", i, len(test.output), len(res.AllowFrom))\n\t\t}\n\n\t}\n}\n\nfunc TestGetByUsername(t *testing.T) {\n\t// Create  reg to refer to\n\treg, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Registration failed, got error [%v]\", err)\n\t}\n\n\tregUser, err := DB.GetByUsername(reg.Username)\n\tif err != nil {\n\t\tt.Errorf(\"Could not get test user, got error [%v]\", err)\n\t}\n\n\tif reg.Username != regUser.Username {\n\t\tt.Errorf(\"GetByUsername username [%q] did not match the original [%q]\", regUser.Username, reg.Username)\n\t}\n\n\tif reg.Subdomain != regUser.Subdomain {\n\t\tt.Errorf(\"GetByUsername subdomain [%q] did not match the original [%q]\", regUser.Subdomain, reg.Subdomain)\n\t}\n\n\t// regUser password already is a bcrypt hash\n\tif !correctPassword(reg.Password, regUser.Password) {\n\t\tt.Errorf(\"The password [%s] does not match the hash [%s]\", reg.Password, regUser.Password)\n\t}\n}\n\nfunc TestPrepareErrors(t *testing.T) {\n\treg, _ := DB.Register(cidrslice{})\n\ttdb, err := sql.Open(\"testdb\", \"\")\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %v\", err)\n\t}\n\toldDb := DB.GetBackend()\n\tDB.SetBackend(tdb)\n\tdefer DB.SetBackend(oldDb)\n\tdefer testdb.Reset()\n\n\t_, err = DB.GetByUsername(reg.Username)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but didn't get one\")\n\t}\n\n\t_, err = DB.GetTXTForDomain(reg.Subdomain)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but didn't get one\")\n\t}\n}\n\nfunc TestQueryExecErrors(t *testing.T) {\n\treg, _ := DB.Register(cidrslice{})\n\ttestdb.SetExecWithArgsFunc(func(query string, args []driver.Value) (result driver.Result, err error) {\n\t\treturn testResult{1, 0}, errors.New(\"Prepared query error\")\n\t})\n\n\ttestdb.SetQueryWithArgsFunc(func(query string, args []driver.Value) (result driver.Rows, err error) {\n\t\tcolumns := []string{\"Username\", \"Password\", \"Subdomain\", \"Value\", \"LastActive\"}\n\t\treturn testdb.RowsFromSlice(columns, [][]driver.Value{}), errors.New(\"Prepared query error\")\n\t})\n\n\tdefer testdb.Reset()\n\n\ttdb, err := sql.Open(\"testdb\", \"\")\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %v\", err)\n\t}\n\toldDb := DB.GetBackend()\n\n\tDB.SetBackend(tdb)\n\tdefer DB.SetBackend(oldDb)\n\n\t_, err = DB.GetByUsername(reg.Username)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error from exec, but got none\")\n\t}\n\n\t_, err = DB.GetTXTForDomain(reg.Subdomain)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error from exec in GetByDomain, but got none\")\n\t}\n\n\t_, err = DB.Register(cidrslice{})\n\tif err == nil {\n\t\tt.Errorf(\"Expected error from exec in Register, but got none\")\n\t}\n\treg.Value = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n\terr = DB.Update(reg.ACMETxtPost)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error from exec in Update, but got none\")\n\t}\n\n}\n\nfunc TestQueryScanErrors(t *testing.T) {\n\treg, _ := DB.Register(cidrslice{})\n\n\ttestdb.SetExecWithArgsFunc(func(query string, args []driver.Value) (result driver.Result, err error) {\n\t\treturn testResult{1, 0}, errors.New(\"Prepared query error\")\n\t})\n\n\ttestdb.SetQueryWithArgsFunc(func(query string, args []driver.Value) (result driver.Rows, err error) {\n\t\tcolumns := []string{\"Only one\"}\n\t\tresultrows := \"this value\"\n\t\treturn testdb.RowsFromCSVString(columns, resultrows), nil\n\t})\n\n\tdefer testdb.Reset()\n\ttdb, err := sql.Open(\"testdb\", \"\")\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %v\", err)\n\t}\n\toldDb := DB.GetBackend()\n\n\tDB.SetBackend(tdb)\n\tdefer DB.SetBackend(oldDb)\n\n\t_, err = DB.GetByUsername(reg.Username)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error from scan in, but got none\")\n\t}\n}\n\nfunc TestBadDBValues(t *testing.T) {\n\treg, _ := DB.Register(cidrslice{})\n\n\ttestdb.SetQueryWithArgsFunc(func(query string, args []driver.Value) (result driver.Rows, err error) {\n\t\tcolumns := []string{\"Username\", \"Password\", \"Subdomain\", \"Value\", \"LastActive\"}\n\t\tresultrows := \"invalid,invalid,invalid,invalid,\"\n\t\treturn testdb.RowsFromCSVString(columns, resultrows), nil\n\t})\n\n\tdefer testdb.Reset()\n\ttdb, err := sql.Open(\"testdb\", \"\")\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %v\", err)\n\t}\n\toldDb := DB.GetBackend()\n\n\tDB.SetBackend(tdb)\n\tdefer DB.SetBackend(oldDb)\n\n\t_, err = DB.GetByUsername(reg.Username)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error from scan in, but got none\")\n\t}\n\n\t_, err = DB.GetTXTForDomain(reg.Subdomain)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error from scan in GetByDomain, but got none\")\n\t}\n}\n\nfunc TestGetTXTForDomain(t *testing.T) {\n\t// Create  reg to refer to\n\treg, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Registration failed, got error [%v]\", err)\n\t}\n\n\ttxtval1 := \"___validation_token_received_from_the_ca___\"\n\ttxtval2 := \"___validation_token_received_YEAH_the_ca___\"\n\n\treg.Value = txtval1\n\t_ = DB.Update(reg.ACMETxtPost)\n\n\treg.Value = txtval2\n\t_ = DB.Update(reg.ACMETxtPost)\n\n\tregDomainSlice, err := DB.GetTXTForDomain(reg.Subdomain)\n\tif err != nil {\n\t\tt.Errorf(\"Could not get test user, got error [%v]\", err)\n\t}\n\tif len(regDomainSlice) == 0 {\n\t\tt.Errorf(\"No rows returned for GetTXTForDomain [%s]\", reg.Subdomain)\n\t}\n\n\tvar val1found = false\n\tvar val2found = false\n\tfor _, v := range regDomainSlice {\n\t\tif v == txtval1 {\n\t\t\tval1found = true\n\t\t}\n\t\tif v == txtval2 {\n\t\t\tval2found = true\n\t\t}\n\t}\n\tif !val1found {\n\t\tt.Errorf(\"No TXT value found for val1\")\n\t}\n\tif !val2found {\n\t\tt.Errorf(\"No TXT value found for val2\")\n\t}\n\n\t// Not found\n\tregNotfound, _ := DB.GetTXTForDomain(\"does-not-exist\")\n\tif len(regNotfound) > 0 {\n\t\tt.Errorf(\"No records should be returned.\")\n\t}\n}\n\nfunc TestUpdate(t *testing.T) {\n\t// Create  reg to refer to\n\treg, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Registration failed, got error [%v]\", err)\n\t}\n\n\tregUser, err := DB.GetByUsername(reg.Username)\n\tif err != nil {\n\t\tt.Errorf(\"Could not get test user, got error [%v]\", err)\n\t}\n\n\t// Set new values (only TXT should be updated) (matches by username and subdomain)\n\n\tvalidTXT := \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n\tregUser.Password = \"nevergonnagiveyouup\"\n\tregUser.Value = validTXT\n\n\terr = DB.Update(regUser.ACMETxtPost)\n\tif err != nil {\n\t\tt.Errorf(\"DB Update failed, got error: [%v]\", err)\n\t}\n}\n"
        },
        {
          "name": "dns.go",
          "type": "blob",
          "size": 6.517578125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/miekg/dns\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Records is a slice of ResourceRecords\ntype Records struct {\n\tRecords []dns.RR\n}\n\n// DNSServer is the main struct for acme-dns DNS server\ntype DNSServer struct {\n\tDB              database\n\tDomain          string\n\tServer          *dns.Server\n\tSOA             dns.RR\n\tPersonalKeyAuth string\n\tDomains         map[string]Records\n}\n\n// NewDNSServer parses the DNS records from config and returns a new DNSServer struct\nfunc NewDNSServer(db database, addr string, proto string, domain string) *DNSServer {\n\tvar server DNSServer\n\tserver.Server = &dns.Server{Addr: addr, Net: proto}\n\tif !strings.HasSuffix(domain, \".\") {\n\t\tdomain = domain + \".\"\n\t}\n\tserver.Domain = strings.ToLower(domain)\n\tserver.DB = db\n\tserver.PersonalKeyAuth = \"\"\n\tserver.Domains = make(map[string]Records)\n\treturn &server\n}\n\n// Start starts the DNSServer\nfunc (d *DNSServer) Start(errorChannel chan error) {\n\t// DNS server part\n\tdns.HandleFunc(\".\", d.handleRequest)\n\tlog.WithFields(log.Fields{\"addr\": d.Server.Addr, \"proto\": d.Server.Net}).Info(\"Listening DNS\")\n\terr := d.Server.ListenAndServe()\n\tif err != nil {\n\t\terrorChannel <- err\n\t}\n}\n\n// ParseRecords parses a slice of DNS record string\nfunc (d *DNSServer) ParseRecords(config DNSConfig) {\n\tfor _, v := range config.General.StaticRecords {\n\t\trr, err := dns.NewRR(strings.ToLower(v))\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"error\": err.Error(), \"rr\": v}).Warning(\"Could not parse RR from config\")\n\t\t\tcontinue\n\t\t}\n\t\t// Add parsed RR\n\t\td.appendRR(rr)\n\t}\n\t// Create serial\n\tserial := time.Now().Format(\"2006010215\")\n\t// Add SOA\n\tSOAstring := fmt.Sprintf(\"%s. SOA %s. %s. %s 28800 7200 604800 86400\", strings.ToLower(config.General.Domain), strings.ToLower(config.General.Nsname), strings.ToLower(config.General.Nsadmin), serial)\n\tsoarr, err := dns.NewRR(SOAstring)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"error\": err.Error(), \"soa\": SOAstring}).Error(\"Error while adding SOA record\")\n\t} else {\n\t\td.appendRR(soarr)\n\t\td.SOA = soarr\n\t}\n}\n\nfunc (d *DNSServer) appendRR(rr dns.RR) {\n\taddDomain := rr.Header().Name\n\t_, ok := d.Domains[addDomain]\n\tif !ok {\n\t\td.Domains[addDomain] = Records{[]dns.RR{rr}}\n\t} else {\n\t\tdrecs := d.Domains[addDomain]\n\t\tdrecs.Records = append(drecs.Records, rr)\n\t\td.Domains[addDomain] = drecs\n\t}\n\tlog.WithFields(log.Fields{\"recordtype\": dns.TypeToString[rr.Header().Rrtype], \"domain\": addDomain}).Debug(\"Adding new record to domain\")\n}\n\nfunc (d *DNSServer) handleRequest(w dns.ResponseWriter, r *dns.Msg) {\n\tm := new(dns.Msg)\n\tm.SetReply(r)\n\n\t// handle edns0\n\topt := r.IsEdns0()\n\tif opt != nil {\n\t\tif opt.Version() != 0 {\n\t\t\t// Only EDNS0 is standardized\n\t\t\tm.MsgHdr.Rcode = dns.RcodeBadVers\n\t\t\tm.SetEdns0(512, false)\n\t\t} else {\n\t\t\t// We can safely do this as we know that we're not setting other OPT RRs within acme-dns.\n\t\t\tm.SetEdns0(512, false)\n\t\t\tif r.Opcode == dns.OpcodeQuery {\n\t\t\t\td.readQuery(m)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif r.Opcode == dns.OpcodeQuery {\n\t\t\td.readQuery(m)\n\t\t}\n\t}\n\t_ = w.WriteMsg(m)\n}\n\nfunc (d *DNSServer) readQuery(m *dns.Msg) {\n\tvar authoritative = false\n\tfor _, que := range m.Question {\n\t\tif rr, rc, auth, err := d.answer(que); err == nil {\n\t\t\tif auth {\n\t\t\t\tauthoritative = auth\n\t\t\t}\n\t\t\tm.MsgHdr.Rcode = rc\n\t\t\tm.Answer = append(m.Answer, rr...)\n\t\t}\n\t}\n\tm.MsgHdr.Authoritative = authoritative\n\tif authoritative {\n\t\tif m.MsgHdr.Rcode == dns.RcodeNameError {\n\t\t\tm.Ns = append(m.Ns, d.SOA)\n\t\t}\n\t}\n}\n\nfunc (d *DNSServer) getRecord(q dns.Question) ([]dns.RR, error) {\n\tvar rr []dns.RR\n\tvar cnames []dns.RR\n\tdomain, ok := d.Domains[strings.ToLower(q.Name)]\n\tif !ok {\n\t\treturn rr, fmt.Errorf(\"No records for domain %s\", q.Name)\n\t}\n\tfor _, ri := range domain.Records {\n\t\tif ri.Header().Rrtype == q.Qtype {\n\t\t\trr = append(rr, ri)\n\t\t}\n\t\tif ri.Header().Rrtype == dns.TypeCNAME {\n\t\t\tcnames = append(cnames, ri)\n\t\t}\n\t}\n\tif len(rr) == 0 {\n\t\treturn cnames, nil\n\t}\n\treturn rr, nil\n}\n\n// answeringForDomain checks if we have any records for a domain\nfunc (d *DNSServer) answeringForDomain(name string) bool {\n\tif d.Domain == strings.ToLower(name) {\n\t\treturn true\n\t}\n\t_, ok := d.Domains[strings.ToLower(name)]\n\treturn ok\n}\n\nfunc (d *DNSServer) isAuthoritative(q dns.Question) bool {\n\tif d.answeringForDomain(q.Name) {\n\t\treturn true\n\t}\n\tdomainParts := strings.Split(strings.ToLower(q.Name), \".\")\n\tfor i := range domainParts {\n\t\tif d.answeringForDomain(strings.Join(domainParts[i:], \".\")) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isOwnChallenge checks if the query is for the domain of this acme-dns instance. Used for answering its own ACME challenges\nfunc (d *DNSServer) isOwnChallenge(name string) bool {\n\tdomainParts := strings.SplitN(name, \".\", 2)\n\tif len(domainParts) == 2 {\n\t\tif strings.ToLower(domainParts[0]) == \"_acme-challenge\" {\n\t\t\tdomain := strings.ToLower(domainParts[1])\n\t\t\tif !strings.HasSuffix(domain, \".\") {\n\t\t\t\tdomain = domain + \".\"\n\t\t\t}\n\t\t\tif domain == d.Domain {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (d *DNSServer) answer(q dns.Question) ([]dns.RR, int, bool, error) {\n\tvar rcode int\n\tvar err error\n\tvar txtRRs []dns.RR\n\tvar authoritative = d.isAuthoritative(q)\n\tif !d.isOwnChallenge(q.Name) && !d.answeringForDomain(q.Name) {\n\t\trcode = dns.RcodeNameError\n\t}\n\tr, _ := d.getRecord(q)\n\tif q.Qtype == dns.TypeTXT {\n\t\tif d.isOwnChallenge(q.Name) {\n\t\t\ttxtRRs, err = d.answerOwnChallenge(q)\n\t\t} else {\n\t\t\ttxtRRs, err = d.answerTXT(q)\n\t\t}\n\t\tif err == nil {\n\t\t\tr = append(r, txtRRs...)\n\t\t}\n\t}\n\tif len(r) > 0 {\n\t\t// Make sure that we return NOERROR if there were dynamic records for the domain\n\t\trcode = dns.RcodeSuccess\n\t}\n\tlog.WithFields(log.Fields{\"qtype\": dns.TypeToString[q.Qtype], \"domain\": q.Name, \"rcode\": dns.RcodeToString[rcode]}).Debug(\"Answering question for domain\")\n\treturn r, rcode, authoritative, nil\n}\n\nfunc (d *DNSServer) answerTXT(q dns.Question) ([]dns.RR, error) {\n\tvar ra []dns.RR\n\tsubdomain := sanitizeDomainQuestion(q.Name)\n\tatxt, err := d.DB.GetTXTForDomain(subdomain)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"error\": err.Error()}).Debug(\"Error while trying to get record\")\n\t\treturn ra, err\n\t}\n\tfor _, v := range atxt {\n\t\tif len(v) > 0 {\n\t\t\tr := new(dns.TXT)\n\t\t\tr.Hdr = dns.RR_Header{Name: q.Name, Rrtype: dns.TypeTXT, Class: dns.ClassINET, Ttl: 1}\n\t\t\tr.Txt = append(r.Txt, v)\n\t\t\tra = append(ra, r)\n\t\t}\n\t}\n\treturn ra, nil\n}\n\n// answerOwnChallenge answers to ACME challenge for acme-dns own certificate\nfunc (d *DNSServer) answerOwnChallenge(q dns.Question) ([]dns.RR, error) {\n\tr := new(dns.TXT)\n\tr.Hdr = dns.RR_Header{Name: q.Name, Rrtype: dns.TypeTXT, Class: dns.ClassINET, Ttl: 1}\n\tr.Txt = append(r.Txt, d.PersonalKeyAuth)\n\treturn []dns.RR{r}, nil\n}\n"
        },
        {
          "name": "dns_test.go",
          "type": "blob",
          "size": 8.0693359375,
          "content": "package main\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/erikstmartin/go-testdb\"\n\t\"github.com/miekg/dns\"\n)\n\ntype resolver struct {\n\tserver string\n}\n\nfunc (r *resolver) lookup(host string, qtype uint16) (*dns.Msg, error) {\n\tmsg := new(dns.Msg)\n\tmsg.Id = dns.Id()\n\tmsg.Question = make([]dns.Question, 1)\n\tmsg.Question[0] = dns.Question{Name: dns.Fqdn(host), Qtype: qtype, Qclass: dns.ClassINET}\n\tin, err := dns.Exchange(msg, r.server)\n\tif err != nil {\n\t\treturn in, fmt.Errorf(\"Error querying the server [%v]\", err)\n\t}\n\tif in != nil && in.Rcode != dns.RcodeSuccess {\n\t\treturn in, fmt.Errorf(\"Received error from the server [%s]\", dns.RcodeToString[in.Rcode])\n\t}\n\n\treturn in, nil\n}\n\nfunc hasExpectedTXTAnswer(answer []dns.RR, cmpTXT string) error {\n\tfor _, record := range answer {\n\t\t// We expect only one answer, so no need to loop through the answer slice\n\t\tif rec, ok := record.(*dns.TXT); ok {\n\t\t\tfor _, txtValue := range rec.Txt {\n\t\t\t\tif txtValue == cmpTXT {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\terrmsg := fmt.Sprintf(\"Got answer of unexpected type [%q]\", answer[0])\n\t\t\treturn errors.New(errmsg)\n\t\t}\n\t}\n\treturn errors.New(\"Expected answer not found\")\n}\n\nfunc TestQuestionDBError(t *testing.T) {\n\ttestdb.SetQueryWithArgsFunc(func(query string, args []driver.Value) (result driver.Rows, err error) {\n\t\tcolumns := []string{\"Username\", \"Password\", \"Subdomain\", \"Value\", \"LastActive\"}\n\t\treturn testdb.RowsFromSlice(columns, [][]driver.Value{}), errors.New(\"Prepared query error\")\n\t})\n\n\tdefer testdb.Reset()\n\n\ttdb, err := sql.Open(\"testdb\", \"\")\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %v\", err)\n\t}\n\toldDb := DB.GetBackend()\n\n\tDB.SetBackend(tdb)\n\tdefer DB.SetBackend(oldDb)\n\n\tq := dns.Question{Name: dns.Fqdn(\"whatever.tld\"), Qtype: dns.TypeTXT, Qclass: dns.ClassINET}\n\t_, err = dnsserver.answerTXT(q)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error but got none\")\n\t}\n}\n\nfunc TestParse(t *testing.T) {\n\tvar testcfg = DNSConfig{\n\t\tGeneral: general{\n\t\t\tDomain:        \")\",\n\t\t\tNsname:        \"ns1.auth.example.org\",\n\t\t\tNsadmin:       \"admin.example.org\",\n\t\t\tStaticRecords: []string{},\n\t\t\tDebug:         false,\n\t\t},\n\t}\n\tdnsserver.ParseRecords(testcfg)\n\tif !loggerHasEntryWithMessage(\"Error while adding SOA record\") {\n\t\tt.Errorf(\"Expected SOA parsing to return error, but did not find one\")\n\t}\n}\n\nfunc TestResolveA(t *testing.T) {\n\tresolv := resolver{server: \"127.0.0.1:15353\"}\n\tanswer, err := resolv.lookup(\"auth.example.org\", dns.TypeA)\n\tif err != nil {\n\t\tt.Errorf(\"%v\", err)\n\t}\n\n\tif len(answer.Answer) == 0 {\n\t\tt.Error(\"No answer for DNS query\")\n\t}\n\n\t_, err = resolv.lookup(\"nonexistent.domain.tld\", dns.TypeA)\n\tif err == nil {\n\t\tt.Errorf(\"Was expecting error because of NXDOMAIN but got none\")\n\t}\n}\n\nfunc TestEDNS(t *testing.T) {\n\tresolv := resolver{server: \"127.0.0.1:15353\"}\n\tanswer, _ := resolv.lookup(\"auth.example.org\", dns.TypeOPT)\n\tif answer.Rcode != dns.RcodeSuccess {\n\t\tt.Errorf(\"Was expecing NOERROR rcode for OPT query, but got [%s] instead.\", dns.RcodeToString[answer.Rcode])\n\t}\n}\n\nfunc TestEDNSA(t *testing.T) {\n\tmsg := new(dns.Msg)\n\tmsg.Id = dns.Id()\n\tmsg.Question = make([]dns.Question, 1)\n\tmsg.Question[0] = dns.Question{Name: dns.Fqdn(\"auth.example.org\"), Qtype: dns.TypeA, Qclass: dns.ClassINET}\n\t// Set EDNS0 with DO=1\n\tmsg.SetEdns0(512, true)\n\tin, err := dns.Exchange(msg, \"127.0.0.1:15353\")\n\tif err != nil {\n\t\tt.Errorf(\"Error querying the server [%v]\", err)\n\t}\n\tif in != nil && in.Rcode != dns.RcodeSuccess {\n\t\tt.Errorf(\"Received error from the server [%s]\", dns.RcodeToString[in.Rcode])\n\t}\n\topt := in.IsEdns0()\n\tif opt == nil {\n\t\tt.Errorf(\"Should have got OPT back\")\n\t}\n}\n\nfunc TestEDNSBADVERS(t *testing.T) {\n\tmsg := new(dns.Msg)\n\tmsg.Id = dns.Id()\n\tmsg.Question = make([]dns.Question, 1)\n\tmsg.Question[0] = dns.Question{Name: dns.Fqdn(\"auth.example.org\"), Qtype: dns.TypeA, Qclass: dns.ClassINET}\n\t// Set EDNS0 with version 1\n\to := new(dns.OPT)\n\to.SetVersion(1)\n\to.Hdr.Name = \".\"\n\to.Hdr.Rrtype = dns.TypeOPT\n\tmsg.Extra = append(msg.Extra, o)\n\tin, err := dns.Exchange(msg, \"127.0.0.1:15353\")\n\tif err != nil {\n\t\tt.Errorf(\"Error querying the server [%v]\", err)\n\t}\n\tif in != nil && in.Rcode != dns.RcodeBadVers {\n\t\tt.Errorf(\"Received unexpected rcode from the server [%s]\", dns.RcodeToString[in.Rcode])\n\t}\n}\n\nfunc TestResolveCNAME(t *testing.T) {\n\tresolv := resolver{server: \"127.0.0.1:15353\"}\n\texpected := \"cn.example.org.\t3600\tIN\tCNAME\tsomething.example.org.\"\n\tanswer, err := resolv.lookup(\"cn.example.org\", dns.TypeCNAME)\n\tif err != nil {\n\t\tt.Errorf(\"Got unexpected error: %s\", err)\n\t}\n\tif len(answer.Answer) != 1 {\n\t\tt.Errorf(\"Expected exactly 1 RR in answer, but got %d instead.\", len(answer.Answer))\n\t}\n\tif answer.Answer[0].Header().Rrtype != dns.TypeCNAME {\n\t\tt.Errorf(\"Expected a CNAME answer, but got [%s] instead.\", dns.TypeToString[answer.Answer[0].Header().Rrtype])\n\t}\n\tif answer.Answer[0].String() != expected {\n\t\tt.Errorf(\"Expected CNAME answer [%s] but got [%s] instead.\", expected, answer.Answer[0].String())\n\t}\n}\n\nfunc TestAuthoritative(t *testing.T) {\n\tresolv := resolver{server: \"127.0.0.1:15353\"}\n\tanswer, _ := resolv.lookup(\"nonexistent.auth.example.org\", dns.TypeA)\n\tif answer.Rcode != dns.RcodeNameError {\n\t\tt.Errorf(\"Was expecing NXDOMAIN rcode, but got [%s] instead.\", dns.RcodeToString[answer.Rcode])\n\t}\n\tif len(answer.Ns) != 1 {\n\t\tt.Errorf(\"Was expecting exactly one answer (SOA) for invalid subdomain, but got %d\", len(answer.Ns))\n\t}\n\tif answer.Ns[0].Header().Rrtype != dns.TypeSOA {\n\t\tt.Errorf(\"Was expecting SOA record as answer for NXDOMAIN but got [%s]\", dns.TypeToString[answer.Ns[0].Header().Rrtype])\n\t}\n\tif !answer.MsgHdr.Authoritative {\n\t\tt.Errorf(\"Was expecting authoritative bit to be set\")\n\t}\n\tnanswer, _ := resolv.lookup(\"nonexsitent.nonauth.tld\", dns.TypeA)\n\tif len(nanswer.Answer) > 0 {\n\t\tt.Errorf(\"Didn't expect answers for non authotitative domain query\")\n\t}\n\tif nanswer.MsgHdr.Authoritative {\n\t\tt.Errorf(\"Authoritative bit should not be set for non-authoritative domain.\")\n\t}\n}\n\nfunc TestResolveTXT(t *testing.T) {\n\tresolv := resolver{server: \"127.0.0.1:15353\"}\n\tvalidTXT := \"______________valid_response_______________\"\n\n\tatxt, err := DB.Register(cidrslice{})\n\tif err != nil {\n\t\tt.Errorf(\"Could not initiate db record: [%v]\", err)\n\t\treturn\n\t}\n\tatxt.Value = validTXT\n\terr = DB.Update(atxt.ACMETxtPost)\n\tif err != nil {\n\t\tt.Errorf(\"Could not update db record: [%v]\", err)\n\t\treturn\n\t}\n\n\tfor i, test := range []struct {\n\t\tsubDomain   string\n\t\texpTXT      string\n\t\tgetAnswer   bool\n\t\tvalidAnswer bool\n\t}{\n\t\t{atxt.Subdomain, validTXT, true, true},\n\t\t{atxt.Subdomain, \"invalid\", true, false},\n\t\t{\"a097455b-52cc-4569-90c8-7a4b97c6eba8\", validTXT, false, false},\n\t} {\n\t\tanswer, err := resolv.lookup(test.subDomain+\".auth.example.org\", dns.TypeTXT)\n\t\tif err != nil {\n\t\t\tif test.getAnswer {\n\t\t\t\tt.Fatalf(\"Test %d: Expected answer but got: %v\", i, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif !test.getAnswer {\n\t\t\t\tt.Errorf(\"Test %d: Expected no answer, but got one.\", i)\n\t\t\t}\n\t\t}\n\n\t\tif len(answer.Answer) > 0 {\n\t\t\tif !test.getAnswer && answer.Answer[0].Header().Rrtype != dns.TypeSOA {\n\t\t\t\tt.Errorf(\"Test %d: Expected no answer, but got: [%q]\", i, answer)\n\t\t\t}\n\t\t\tif test.getAnswer {\n\t\t\t\terr = hasExpectedTXTAnswer(answer.Answer, test.expTXT)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif test.validAnswer {\n\t\t\t\t\t\tt.Errorf(\"Test %d: %v\", i, err)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif !test.validAnswer {\n\t\t\t\t\t\tt.Errorf(\"Test %d: Answer was not expected to be valid, answer [%q], compared to [%s]\", i, answer, test.expTXT)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif test.getAnswer {\n\t\t\t\tt.Errorf(\"Test %d: Expected answer, but didn't get one\", i)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestCaseInsensitiveResolveA(t *testing.T) {\n\tresolv := resolver{server: \"127.0.0.1:15353\"}\n\tanswer, err := resolv.lookup(\"aUtH.eXAmpLe.org\", dns.TypeA)\n\tif err != nil {\n\t\tt.Errorf(\"%v\", err)\n\t}\n\n\tif len(answer.Answer) == 0 {\n\t\tt.Error(\"No answer for DNS query\")\n\t}\n}\n\nfunc TestCaseInsensitiveResolveSOA(t *testing.T) {\n\tresolv := resolver{server: \"127.0.0.1:15353\"}\n\tanswer, _ := resolv.lookup(\"doesnotexist.aUtH.eXAmpLe.org\", dns.TypeSOA)\n\tif answer.Rcode != dns.RcodeNameError {\n\t\tt.Errorf(\"Was expecing NXDOMAIN rcode, but got [%s] instead.\", dns.RcodeToString[answer.Rcode])\n\t}\n\n\tif len(answer.Ns) == 0 {\n\t\tt.Error(\"No SOA answer for DNS query\")\n\t}\n}\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.279296875,
          "content": "version: '2'\nservices:\n  acmedns:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    image: joohoi/acme-dns:latest\n    ports:\n      - \"443:443\"\n      - \"53:53\"\n      - \"53:53/udp\"\n      - \"80:80\"\n    volumes:\n      - ./config:/etc/acme-dns:ro\n      - ./data:/var/lib/acme-dns\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 2.408203125,
          "content": "module github.com/joohoi/acme-dns\n\ngo 1.22\ntoolchain go1.22.0\n\nrequire (\n\tgithub.com/BurntSushi/toml v1.4.0\n\tgithub.com/DATA-DOG/go-sqlmock v1.5.0\n\tgithub.com/caddyserver/certmagic v0.21.4\n\tgithub.com/erikstmartin/go-testdb v0.0.0-20160219214506-8d10e4a1bae5\n\tgithub.com/gavv/httpexpect v2.0.0+incompatible\n\tgithub.com/go-acme/lego/v3 v3.9.0\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/julienschmidt/httprouter v1.3.0\n\tgithub.com/lib/pq v1.10.9\n\tgithub.com/mattn/go-sqlite3 v1.14.24\n\tgithub.com/mholt/acmez/v2 v2.0.3\n\tgithub.com/miekg/dns v1.1.62\n\tgithub.com/rs/cors v1.11.1\n\tgithub.com/sirupsen/logrus v1.9.3\n\tgolang.org/x/crypto v0.31.0\n)\n\nrequire (\n\tgithub.com/ajg/form v1.5.1 // indirect\n\tgithub.com/andybalholm/brotli v1.0.2 // indirect\n\tgithub.com/caddyserver/zerossl v0.1.3 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/fasthttp-contrib/websocket v0.0.0-20160511215533-1f3b11f56072 // indirect\n\tgithub.com/fatih/structs v1.1.0 // indirect\n\tgithub.com/google/go-querystring v1.0.0 // indirect\n\tgithub.com/gorilla/websocket v1.4.2 // indirect\n\tgithub.com/imkira/go-interpol v1.1.0 // indirect\n\tgithub.com/klauspost/compress v1.13.4 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.2.9 // indirect\n\tgithub.com/libdns/libdns v0.2.2 // indirect\n\tgithub.com/mattn/go-colorable v0.1.12 // indirect\n\tgithub.com/moul/http2curl v1.0.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/sergi/go-diff v1.2.0 // indirect\n\tgithub.com/stretchr/testify v1.8.1 // indirect\n\tgithub.com/valyala/bytebufferpool v1.0.0 // indirect\n\tgithub.com/valyala/fasthttp v1.31.0 // indirect\n\tgithub.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f // indirect\n\tgithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect\n\tgithub.com/xeipuuv/gojsonschema v1.2.0 // indirect\n\tgithub.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0 // indirect\n\tgithub.com/yudai/gojsondiff v1.0.0 // indirect\n\tgithub.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 // indirect\n\tgithub.com/yudai/pp v2.0.1+incompatible // indirect\n\tgithub.com/zeebo/blake3 v0.2.4 // indirect\n\tgo.uber.org/multierr v1.11.0 // indirect\n\tgo.uber.org/zap v1.27.0 // indirect\n\tgolang.org/x/mod v0.22.0 // indirect\n\tgolang.org/x/net v0.32.0 // indirect\n\tgolang.org/x/sync v0.10.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgolang.org/x/tools v0.28.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 58.634765625,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=\ncloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=\ncloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=\ncloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=\ncloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=\ncloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=\ncloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=\ncloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=\ncloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=\ncloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=\ncloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=\ncloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=\ncloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=\ncloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=\ncloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=\ncloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=\ncloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=\ncloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=\ncloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=\ncloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=\ncontrib.go.opencensus.io/exporter/ocagent v0.4.12/go.mod h1:450APlNTSR6FrvC3CTRqYosuDstRB9un7SOx2k/9ckA=\ndmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=\ngithub.com/Azure/azure-sdk-for-go v32.4.0+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=\ngithub.com/Azure/go-autorest/autorest v0.1.0/go.mod h1:AKyIcETwSUFxIcs/Wnq/C+kwCtlEYGUVd7FPNb2slmg=\ngithub.com/Azure/go-autorest/autorest v0.5.0/go.mod h1:9HLKlQjVBH6U3oDfsXOeVc56THsLPw1L03yban4xThw=\ngithub.com/Azure/go-autorest/autorest/adal v0.1.0/go.mod h1:MeS4XhScH55IST095THyTxElntu7WqB7pNbZo8Q5G3E=\ngithub.com/Azure/go-autorest/autorest/adal v0.2.0/go.mod h1:MeS4XhScH55IST095THyTxElntu7WqB7pNbZo8Q5G3E=\ngithub.com/Azure/go-autorest/autorest/azure/auth v0.1.0/go.mod h1:Gf7/i2FUpyb/sGBLIFxTBzrNzBo7aPXXE3ZVeDRwdpM=\ngithub.com/Azure/go-autorest/autorest/azure/cli v0.1.0/go.mod h1:Dk8CUAt/b/PzkfeRsWzVG9Yj3ps8mS8ECztu43rdU8U=\ngithub.com/Azure/go-autorest/autorest/date v0.1.0/go.mod h1:plvfp3oPSKwf2DNjlBjWF/7vwR+cUD/ELuzDCXwHUVA=\ngithub.com/Azure/go-autorest/autorest/mocks v0.1.0/go.mod h1:OTyCOPRA2IgIlWxVYxBee2F5Gr4kF2zd2J5cFRaIDN0=\ngithub.com/Azure/go-autorest/autorest/to v0.2.0/go.mod h1:GunWKJp1AEqgMaGLV+iocmRAJWqST1wQYhyyjXJ3SJc=\ngithub.com/Azure/go-autorest/autorest/validation v0.1.0/go.mod h1:Ha3z/SqBeaalWQvokg3NZAlQTalVMtOIAs1aGK7G6u8=\ngithub.com/Azure/go-autorest/logger v0.1.0/go.mod h1:oExouG+K6PryycPJfVSxi/koC6LSNgds39diKLz7Vrc=\ngithub.com/Azure/go-autorest/tracing v0.1.0/go.mod h1:ROEEAFwXycQw7Sn3DXNtEedEvdeRAgDr0izn4z5Ij88=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/toml v1.4.0 h1:kuoIxZQy2WRRk1pttg9asf+WVv6tWQuBNVmK8+nqPr0=\ngithub.com/BurntSushi/toml v1.4.0/go.mod h1:ukJfTF/6rtPPRCnwkur4qwRxa8vTRFBF0uk2lLoLwho=\ngithub.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\ngithub.com/DATA-DOG/go-sqlmock v1.5.0 h1:Shsta01QNfFxHCfpW6YH2STWB0MudeXXEWMr20OEh60=\ngithub.com/DATA-DOG/go-sqlmock v1.5.0/go.mod h1:f/Ixk793poVmq4qj/V1dPUg2JEAKC73Q5eFN3EC/SaM=\ngithub.com/OpenDNS/vegadns2client v0.0.0-20180418235048-a3fa4a771d87/go.mod h1:iGLljf5n9GjT6kc0HBvyI1nOKnGQbNB66VzSNbK5iks=\ngithub.com/Shopify/sarama v1.19.0/go.mod h1:FVkBWblsNy7DGZRfXLU0O9RCGt5g3g3yEuWXgklEdEo=\ngithub.com/Shopify/toxiproxy v2.1.4+incompatible/go.mod h1:OXgGpZ6Cli1/URJOF1DMxUHB2q5Ap20/P/eIdh4G0pI=\ngithub.com/ajg/form v1.5.1 h1:t9c7v8JUKu/XxOGBU0yjNpaMloxGEJhUkqFRq0ibGeU=\ngithub.com/ajg/form v1.5.1/go.mod h1:uL1WgH+h2mgNtvBq0339dVnzXdBETtL2LeUXaIv25UY=\ngithub.com/akamai/AkamaiOPEN-edgegrid-golang v0.9.18/go.mod h1:L+HB2uBoDgi3+r1pJEJcbGwyyHhd2QXaGsKLbDwtm8Q=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/aliyun/alibaba-cloud-sdk-go v1.61.112/go.mod h1:pUKYbK5JQ+1Dfxk80P0qxGqe5dkxDoabbZS7zOcouyA=\ngithub.com/andybalholm/brotli v1.0.2 h1:JKnhI/XQ75uFBTiuzXpzFrUriDPiZjlOSzh6wXogP0E=\ngithub.com/andybalholm/brotli v1.0.2/go.mod h1:loMXtMfwqflxFJPmdbJO0a3KNoPuLBgiu3qAvBg8x/Y=\ngithub.com/apache/thrift v0.12.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=\ngithub.com/aws/aws-sdk-go v1.30.20/go.mod h1:5zCpMtNQVjRREroY7sYe8lOMRSxkhG6MZveU8YkpAk0=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/boombuler/barcode v1.0.1-0.20190219062509-6c824513bacc/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=\ngithub.com/caddyserver/certmagic v0.21.4 h1:e7VobB8rffHv8ZZpSiZtEwnLDHUwLVYLWzWSa1FfKI0=\ngithub.com/caddyserver/certmagic v0.21.4/go.mod h1:swUXjQ1T9ZtMv95qj7/InJvWLXURU85r+CfG0T+ZbDE=\ngithub.com/caddyserver/zerossl v0.1.3 h1:onS+pxp3M8HnHpN5MMbOMyNjmTheJyWRaZYwn+YTAyA=\ngithub.com/caddyserver/zerossl v0.1.3/go.mod h1:CxA0acn7oEGO6//4rtrRjYgEoa4MFw/XofZnrYwGqG4=\ngithub.com/cenkalti/backoff/v4 v4.0.0/go.mod h1:eEew/i+1Q6OrCDZh3WiXYv3+nJwBASZ8Bog/87DQnVg=\ngithub.com/census-instrumentation/opencensus-proto v0.2.0/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cloudflare/cloudflare-go v0.10.2/go.mod h1:qhVI5MKwBGhdNU89ZRz2plgYutcJ5PCekLxXn56w6SY=\ngithub.com/cpu/goacmedns v0.0.2/go.mod h1:4MipLkI+qScwqtVxcNO6okBhbgRrr7/tKXUSgSL0teQ=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/dimchansky/utfbom v1.1.0/go.mod h1:rO41eb7gLfo8SF1jd9F8HplJm1Fewwi4mQvIirEdv+8=\ngithub.com/dnaeon/go-vcr v0.0.0-20180814043457-aafff18a5cc2/go.mod h1:aBB1+wY4s93YsC3HHjMBMrwTj2R9FHDzUr9KyGc8n1E=\ngithub.com/dnsimple/dnsimple-go v0.60.0/go.mod h1:O5TJ0/U6r7AfT8niYNlmohpLbCSG+c71tQlGr9SeGrg=\ngithub.com/eapache/go-resiliency v1.1.0/go.mod h1:kFI+JgMyC7bLPUVY133qvEBtVayf5mFgVsvEsIPBvNs=\ngithub.com/eapache/go-xerial-snappy v0.0.0-20180814174437-776d5712da21/go.mod h1:+020luEh2TKB4/GOp8oxxtq0Daoen/Cii55CzbTV6DU=\ngithub.com/eapache/queue v1.1.0/go.mod h1:6eCeP0CKFpHLu8blIFXhExK/dRa7WDZfr6jVFPTqq+I=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/erikstmartin/go-testdb v0.0.0-20160219214506-8d10e4a1bae5 h1:Yzb9+7DPaBjB8zlTR87/ElzFsnQfuHnVUVqpZZIcV5Y=\ngithub.com/erikstmartin/go-testdb v0.0.0-20160219214506-8d10e4a1bae5/go.mod h1:a2zkGnVExMxdzMo3M0Hi/3sEU+cWnZpSni0O6/Yb/P0=\ngithub.com/exoscale/egoscale v0.18.1/go.mod h1:Z7OOdzzTOz1Q1PjQXumlz9Wn/CddH0zSYdCF3rnBKXE=\ngithub.com/fasthttp-contrib/websocket v0.0.0-20160511215533-1f3b11f56072 h1:DddqAaWDpywytcG8w/qoQ5sAN8X12d3Z3koB0C3Rxsc=\ngithub.com/fasthttp-contrib/websocket v0.0.0-20160511215533-1f3b11f56072/go.mod h1:duJ4Jxv5lDcvg4QuQr0oowTf7dz4/CR8NtyCooz9HL8=\ngithub.com/fatih/structs v1.1.0 h1:Q7juDM0QtcnhCpeyLGQKyg4TOIghuNXrkL32pHAUMxo=\ngithub.com/fatih/structs v1.1.0/go.mod h1:9NiDSp5zOcgEDl+j00MP/WkGVPOlPRLejGD8Ga6PJ7M=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/gavv/httpexpect v2.0.0+incompatible h1:1X9kcRshkSKEjNJJxX9Y9mQ5BRfbxU5kORdjhlA1yX8=\ngithub.com/gavv/httpexpect v2.0.0+incompatible/go.mod h1:x+9tiU1YnrOvnB725RkpoLv1M62hOWzwo5OXotisrKc=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/go-acme/lego/v3 v3.9.0 h1:Kyvg2GGqRJHfK2Stu57M45TDTx0y1bsxLH7lpeP3n0A=\ngithub.com/go-acme/lego/v3 v3.9.0/go.mod h1:va0cvQpxpJ3u2OA534L8TDn+lsr2oujLzPckLOLnUGQ=\ngithub.com/go-cmd/cmd v1.0.5/go.mod h1:y8q8qlK5wQibcw63djSl/ntiHUHXHGdCkPk0j4QeW4s=\ngithub.com/go-errors/errors v1.0.1/go.mod h1:f4zRHt4oKfwPJE5k8C9vpYG+aDHdBFUsgrm6/TyX73Q=\ngithub.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=\ngithub.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/gofrs/uuid v3.2.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.0/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/goji/httpauth v0.0.0-20160601135302-2da839ab0f4d/go.mod h1:nnjvkQ9ptGaCkuDUx6wNykzzlUixGxvkme+H/lnzb+A=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=\ngithub.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/snappy v0.0.0-20180518054509-2e65f85255db/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/golang/snappy v0.0.3/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/go-querystring v1.0.0 h1:Xkwi/a1rcvNg1PPYe5vI8GbeBY/jrVuDX5ASuANWTrk=\ngithub.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=\ngithub.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\ngithub.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=\ngithub.com/gophercloud/gophercloud v0.6.1-0.20191122030953-d8ac278c1c9d/go.mod h1:ozGNgr9KYOVATV5jsgHl/ceCDXGuguqOZAzoQ/2vcNM=\ngithub.com/gophercloud/gophercloud v0.7.0/go.mod h1:gmC5oQqMDOMO1t1gq5DquX/yAU808e/4mzjjDA76+Ss=\ngithub.com/gophercloud/utils v0.0.0-20200508015959-b0167b94122c/go.mod h1:ehWUbLQJPqS0Ep+CxeD559hsm9pthPXadJNKwZkp43w=\ngithub.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1 h1:EGx4pi6eqNxGaHF6qqu48+N2wcFQ5qg5FXgOdqsJ5d8=\ngithub.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=\ngithub.com/gorilla/mux v1.6.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/gorilla/mux v1.7.3/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=\ngithub.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/grpc-ecosystem/grpc-gateway v1.8.5/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=\ngithub.com/h2non/parth v0.0.0-20190131123155-b4df798d6542/go.mod h1:Ow0tF8D4Kplbc8s8sSb3V2oUCygFHVp8gC3Dn6U4MNI=\ngithub.com/hashicorp/go-cleanhttp v0.5.1/go.mod h1:JpRdi6/HCYpAwUzNwuwqhbovhLtngrth3wmdIIUrZ80=\ngithub.com/hashicorp/go-hclog v0.9.2/go.mod h1:5CU+agLiy3J7N7QjHK5d05KxGsuXiQLrjA0H7acj2lQ=\ngithub.com/hashicorp/go-retryablehttp v0.6.6/go.mod h1:vAew36LZh98gCBJNLH42IQ1ER/9wtLZZ8meHqQvEYWY=\ngithub.com/hashicorp/go-uuid v1.0.1/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hpcloud/tail v1.0.0 h1:nfCOvKYfkgYP8hkirhJocXT2+zOD8yUNjXaWfTlyFKI=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/iij/doapi v0.0.0-20190504054126-0bbf12d6d7df/go.mod h1:QMZY7/J/KSQEhKWFeDesPjMj+wCHReeknARU3wqlyN4=\ngithub.com/imkira/go-interpol v1.1.0 h1:KIiKr0VSG2CUW1hl1jpiyuzuJeKUUpC8iM1AIE7N1Vk=\ngithub.com/imkira/go-interpol v1.1.0/go.mod h1:z0h2/2T3XF8kyEPpRgJ3kmNv+C43p+I/CoI+jC3w2iA=\ngithub.com/jmespath/go-jmespath v0.0.0-20180206201540-c2b33e8439af/go.mod h1:Nht3zPeWKUH0NzdCt2Blrr5ys8VGpn0CEB0cQHVjt7k=\ngithub.com/jmespath/go-jmespath v0.3.0/go.mod h1:9QtRXoHjLGCJ5IBSaohpXITPlowMeeYCZ7fLUTSywik=\ngithub.com/json-iterator/go v1.1.5/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/json-iterator/go v1.1.7/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=\ngithub.com/jtolds/gls v4.20.0+incompatible h1:xdiiI2gbIgH/gLH7ADydsJ1uDOEzR8yvV7C0MuV77Wo=\ngithub.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/julienschmidt/httprouter v1.3.0 h1:U0609e9tgbseu3rBINet9P48AI/D3oJs4dN7jwJOQ1U=\ngithub.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.13.4 h1:0zhec2I8zGnjWcKyLl6i3gPqKANCCn5e9xmviEEeX6s=\ngithub.com/klauspost/compress v1.13.4/go.mod h1:8dP1Hq4DHOhN9w426knH3Rhby4rFm6D8eO+e+Dq5Gzg=\ngithub.com/klauspost/cpuid/v2 v2.2.9 h1:66ze0taIn2H33fBvCkXuv9BmCwDfafmiIVpKV9kKGuY=\ngithub.com/klauspost/cpuid/v2 v2.2.9/go.mod h1:rqkxqrZ1EhYM9G+hXH7YdowN5R5RGN6NK4QwQ3WMXF8=\ngithub.com/kolo/xmlrpc v0.0.0-20200310150728-e0350524596b/go.mod h1:o03bZfuBwAXHetKXuInt4S7omeXUu62/A845kiycsSQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.2/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/labbsr0x/bindman-dns-webhook v1.0.2/go.mod h1:p6b+VCXIR8NYKpDr8/dg1HKfQoRHCdcsROXKvmoehKA=\ngithub.com/labbsr0x/goh v1.0.1/go.mod h1:8K2UhVoaWXcCU7Lxoa2omWnC8gyW8px7/lmO61c027w=\ngithub.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=\ngithub.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=\ngithub.com/libdns/libdns v0.2.2 h1:O6ws7bAfRPaBsgAYt8MDe2HcNBGC29hkZ9MX2eUSX3s=\ngithub.com/libdns/libdns v0.2.2/go.mod h1:4Bj9+5CQiNMVGf87wjX4CY3HQJypUHRuLvlsfsZqLWQ=\ngithub.com/linode/linodego v0.10.0/go.mod h1:cziNP7pbvE3mXIPneHj0oRY8L1WtGEIKlZ8LANE4eXA=\ngithub.com/liquidweb/liquidweb-go v1.6.0/go.mod h1:UDcVnAMDkZxpw4Y7NOHkqoeiGacVLEIG/i5J9cyixzQ=\ngithub.com/mattn/go-colorable v0.1.12 h1:jF+Du6AlPIjs2BiUiQlKOX0rt3SujHxPnksPKZbaA40=\ngithub.com/mattn/go-colorable v0.1.12/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=\ngithub.com/mattn/go-isatty v0.0.3/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=\ngithub.com/mattn/go-isatty v0.0.14 h1:yVuAays6BHfxijgZPzw+3Zlu5yQgKGP2/hcQbHb7S9Y=\ngithub.com/mattn/go-isatty v0.0.14/go.mod h1:7GGIvUiUoEMVVmxf/4nioHXj79iQHKdU27kJ6hsGG94=\ngithub.com/mattn/go-runewidth v0.0.2/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.4/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-sqlite3 v1.14.24 h1:tpSp2G2KyMnnQu99ngJ47EIkWVmliIizyZBfPrBWDRM=\ngithub.com/mattn/go-sqlite3 v1.14.24/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=\ngithub.com/mattn/go-tty v0.0.0-20180219170247-931426f7535a/go.mod h1:XPvLUNfbS4fJH25nqRHfWLMa1ONC8Amw+mIA639KxkE=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/mholt/acmez/v2 v2.0.3 h1:CgDBlEwg3QBp6s45tPQmFIBrkRIkBT4rW4orMM6p4sw=\ngithub.com/mholt/acmez/v2 v2.0.3/go.mod h1:pQ1ysaDeGrIMvJ9dfJMk5kJNkn7L2sb3UhyrX6Q91cw=\ngithub.com/miekg/dns v1.1.27/go.mod h1:KNUDUusw/aVsxyTYZM1oqvCicbwhgbNgztCETuNZ7xM=\ngithub.com/miekg/dns v1.1.62 h1:cN8OuEF1/x5Rq6Np+h1epln8OiyPWV+lROx9LxcGgIQ=\ngithub.com/miekg/dns v1.1.62/go.mod h1:mvDlcItzm+br7MToIKqkglaGhlFMHJ9DTNNWONWXbNQ=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/go-vnc v0.0.0-20150629162542-723ed9867aed/go.mod h1:3rdaFaCv4AyBgu5ALFM0+tSuHrBh6v692nyQe3ikrq0=\ngithub.com/mitchellh/mapstructure v1.3.1/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/moul/http2curl v1.0.0 h1:dRMWoAtb+ePxMlLkrCbAqh4TlPHXvoGUSQ323/9Zahs=\ngithub.com/moul/http2curl v1.0.0/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/namedotcom/go v0.0.0-20180403034216-08470befbe04/go.mod h1:5sN+Lt1CaY4wsPvgQH/jsuJi4XO2ssZbdsIizr4CVC8=\ngithub.com/nbio/st v0.0.0-20140626010706-e9e8d9816f32/go.mod h1:9wM+0iRr9ahx58uYLpLIr5fm8diHn0JbqRycJi6w0Ms=\ngithub.com/nrdcg/auroradns v1.0.1/go.mod h1:y4pc0i9QXYlFCWrhWrUSIETnZgrf4KuwjDIWmmXo3JI=\ngithub.com/nrdcg/desec v0.5.0/go.mod h1:2ejvMazkav1VdDbv2HeQO7w+Ta1CGHqzQr27ZBYTuEQ=\ngithub.com/nrdcg/dnspod-go v0.4.0/go.mod h1:vZSoFSFeQVm2gWLMkyX61LZ8HI3BaqtHZWgPTGKr6KQ=\ngithub.com/nrdcg/goinwx v0.7.0/go.mod h1:4tKJOCi/1lTxuw9/yB2Ez0aojwtUCSkckjc22eALpqE=\ngithub.com/nrdcg/namesilo v0.2.1/go.mod h1:lwMvfQTyYq+BbjJd30ylEG4GPSS6PII0Tia4rRpRiyw=\ngithub.com/olekukonko/tablewriter v0.0.1/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.7.0 h1:WSHQ+IS43OoUrWtD1/bbclrwK8TTH5hzp+umCiuxHgs=\ngithub.com/onsi/ginkgo v1.7.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/gomega v1.4.3 h1:RE1xgDvH7imwFD45h+u2SgIfERHlS2yNG4DObb5BSKU=\ngithub.com/onsi/gomega v1.4.3/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=\ngithub.com/openzipkin/zipkin-go v0.1.6/go.mod h1:QgAqvLzwWbR/WpD4A3cGpPtJrZXNIiJc5AZX7/PBEpw=\ngithub.com/oracle/oci-go-sdk v7.0.0+incompatible/go.mod h1:VQb79nF8Z2cwLkLS35ukwStZIg5F66tcBccjip/j888=\ngithub.com/ovh/go-ovh v0.0.0-20181109152953-ba5adb4cf014/go.mod h1:joRatxRJaZBsY3JAOEMcoOp05CnZzsx4scTxi95DHyQ=\ngithub.com/patrickmn/go-cache v2.1.0+incompatible/go.mod h1:3Qf8kWWT7OJRJbdiICTKqZju1ZixQ/KpMGzzAfe6+WQ=\ngithub.com/pierrec/lz4 v2.0.5+incompatible/go.mod h1:pdkljMzZIN41W+lC3N2tnIh5sFi+IEE17M5jbnwPHcY=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pquerna/otp v1.2.0/go.mod h1:dkJfzwRKNiegxyNb54X/3fLwhCynbMspSyWKnvi1AEg=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v0.9.3-0.20190127221311-3c4408c8b829/go.mod h1:p2iRAGwDERtqlqzRXnrOVns+ignqQo//hLXqYxZYVNs=\ngithub.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=\ngithub.com/prometheus/client_golang v1.1.0/go.mod h1:I1FGZT9+L76gKKOs5djB6ezCbFQP1xR9D75/vuwEF3g=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190115171406-56726106282f/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/common v0.2.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.6.0/go.mod h1:eBmuwkDJBwy6iBfxCBob6t6dR6ENT/y+J+Zk0j9GMYc=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.0-20190117184657-bf6a532e95b1/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.0.3/go.mod h1:4A/X28fw3Fc593LaREMrKMqOKvUAntwMDaekg4FpcdQ=\ngithub.com/rainycape/memcache v0.0.0-20150622160815-1031fa0ce2f2/go.mod h1:7tZKcyumwBO6qip7RNQ5r77yrssm9bfCowcLEBcU5IA=\ngithub.com/rcrowley/go-metrics v0.0.0-20181016184325-3113b8401b8a/go.mod h1:bCqnVzQkZxMG4s8nGwiZ5l3QUCyqpo9Y+/ZMZ9VjZe4=\ngithub.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=\ngithub.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\ngithub.com/rs/cors v1.11.1 h1:eU3gRzXLRK57F5rKMGMZURNdIG4EoAmX8k94r9wXWHA=\ngithub.com/rs/cors v1.11.1/go.mod h1:XyqrcTp5zjWr1wsJ8PIRZssZ8b/WMcMf71DJnit4EMU=\ngithub.com/russross/blackfriday/v2 v2.0.1/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/sacloud/libsacloud v1.26.1/go.mod h1:79ZwATmHLIFZIMd7sxA3LwzVy/B77uj3LDoToVTxDoQ=\ngithub.com/sergi/go-diff v1.2.0 h1:XU+rvMAioB0UC3q1MFrIQy4Vo5/4VsRDQQXHsEya6xQ=\ngithub.com/sergi/go-diff v1.2.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=\ngithub.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=\ngithub.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=\ngithub.com/skratchdot/open-golang v0.0.0-20160302144031-75fb7ed4208c/go.mod h1:sUM3LWHvSMaG192sy56D9F7CNvL7jUJVXoqM1QKLnog=\ngithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d h1:zE9ykElWQ6/NYmHa3jpm/yHnI4xSofP+UP6SpjHcSeM=\ngithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\ngithub.com/smartystreets/goconvey v0.0.0-20190330032615-68dc04aab96a/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=\ngithub.com/smartystreets/goconvey v1.6.4 h1:fv0U8FUIMPNf1L9lnHLvLhgicrIVChEkdzIKYqbNC9s=\ngithub.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/timewasted/linode v0.0.0-20160829202747-37e84520dcf7/go.mod h1:imsgLplxEC/etjIhdr3dNzV3JeT27LbVu5pYWm0JCBY=\ngithub.com/transip/gotransip/v6 v6.0.2/go.mod h1:pQZ36hWWRahCUXkFWlx9Hs711gLd8J4qdgLdRzmtY+g=\ngithub.com/uber-go/atomic v1.3.2/go.mod h1:/Ct5t2lcmbJ4OSe/waGBoaVvVqtO0bmtfVNex1PFV8g=\ngithub.com/urfave/cli v1.22.1/go.mod h1:Gos4lmkARVdJ6EkW0WaNv/tZAAMe9V7XWyB60NtXRu0=\ngithub.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/valyala/fasthttp v1.31.0 h1:lrauRLII19afgCs2fnWRJ4M5IkV0lo2FqA61uGkNBfE=\ngithub.com/valyala/fasthttp v1.31.0/go.mod h1:2rsYD01CKFrjjsvFxx75KlEUNpWNBY9JWD3K/7o2Cus=\ngithub.com/valyala/tcplisten v1.0.0/go.mod h1:T0xQ8SeCZGxckz9qRXTfG43PvQ/mcWh7FwZEA7Ioqkc=\ngithub.com/vultr/govultr v0.4.2/go.mod h1:TUuUizMOFc7z+PNMssb6iGjKjQfpw5arIaOLfocVudQ=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f h1:J9EGpcZtP0E/raorCMxlFGSTBrsSlaDGf3jU/qvAE2c=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=\ngithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 h1:EzJWgHovont7NscjpAxXsDA8S8BMYve8Y5+7cuRE7R0=\ngithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=\ngithub.com/xeipuuv/gojsonschema v1.2.0 h1:LhYJRs+L4fBtjZUfuSZIKGeVu0QRy8e5Xi7D17UxZ74=\ngithub.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=\ngithub.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0 h1:6fRhSjgLCkTD3JnJxvaJ4Sj+TYblw757bqYgZaOq5ZY=\ngithub.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0/go.mod h1:/LWChgwKmvncFJFHJ7Gvn9wZArjbV5/FppcK2fKk/tI=\ngithub.com/yudai/gojsondiff v1.0.0 h1:27cbfqXLVEJ1o8I6v3y9lg8Ydm53EKqHXAOMxEGlCOA=\ngithub.com/yudai/gojsondiff v1.0.0/go.mod h1:AY32+k2cwILAkW1fbgxQ5mUmMiZFgLIV+FBNExI05xg=\ngithub.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 h1:BHyfKlQyqbsFN5p3IfnEUduWvb9is428/nNb5L3U01M=\ngithub.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82/go.mod h1:lgjkn3NuSvDfVJdfcVVdX+jpBxNmX4rDAzaS45IcYoM=\ngithub.com/yudai/pp v2.0.1+incompatible h1:Q4//iY4pNF6yPLZIigmvcl7k/bPgrcTPIFIcmawg5bI=\ngithub.com/yudai/pp v2.0.1+incompatible/go.mod h1:PuxR/8QJ7cyCkFp/aUDS+JY727OFEZkTdatxwunjIkc=\ngithub.com/zeebo/assert v1.1.0 h1:hU1L1vLTHsnO8x8c9KAR5GmM5QscxHg5RNU5z5qbUWY=\ngithub.com/zeebo/assert v1.1.0/go.mod h1:Pq9JiuJQpG8JLJdtkwrJESF0Foym2/D9XMU5ciN/wJ0=\ngithub.com/zeebo/blake3 v0.2.4 h1:KYQPkhpRtcqh0ssGYcKLG1JYvddkEA8QwCM/yBqhaZI=\ngithub.com/zeebo/blake3 v0.2.4/go.mod h1:7eeQ6d2iXWRGF6npfaxl2CU+xy2Fjo2gxeyZGCRUjcE=\ngithub.com/zeebo/pcg v1.0.1 h1:lyqfGeWiv4ahac6ttHs+I5hwtH/+1mrhlCtVNQM2kHo=\ngithub.com/zeebo/pcg v1.0.1/go.mod h1:09F0S9iiKrwn9rlI5yjLkmrug154/YRW6KnnXVDM/l4=\ngo.opencensus.io v0.20.1/go.mod h1:6WKK9ahsWS3RSO+PY9ZHZUfv2irvY6gN279GOPZjmmk=\ngo.opencensus.io v0.20.2/go.mod h1:6WKK9ahsWS3RSO+PY9ZHZUfv2irvY6gN279GOPZjmmk=\ngo.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=\ngo.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=\ngo.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.uber.org/atomic v1.3.2/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=\ngo.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=\ngo.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=\ngo.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngo.uber.org/ratelimit v0.0.0-20180316092928-c15da0234277/go.mod h1:2X8KaoNd1J0lZV+PxJk/5+DGbO/tpwLR1m++a7FnB/Y=\ngo.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=\ngo.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=\ngolang.org/x/crypto v0.0.0-20180621125126-a49355c7e3f8/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190418165655-df01cb2cc480/go.mod h1:WFFai1msRO1wXaEeE5yQxYXgSfI8pQAWXbQop6sCtWE=\ngolang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191202143827-86a70503ff7e/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20200302210943-78000ba7a073/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210513164829-c07d793c2f9a/go.mod h1:P+XmwS30IXTQdn5tA2iutPOUgjI07+tq3H3K9MVA1s8=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\ngolang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=\ngolang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=\ngolang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=\ngolang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=\ngolang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\ngolang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=\ngolang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=\ngolang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=\ngolang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=\ngolang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.22.0 h1:D4nJWe9zXqHOmWqj4VMOJhvzj7bEZg4wEYa759z1pH4=\ngolang.org/x/mod v0.22.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=\ngolang.org/x/net v0.0.0-20180611182652-db08ff08e862/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190125091013-d26f9f9a57f3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190613194153-d28f0bde5980/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190923162816-aa69164e4478/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190930134127-c5a3c61f89f3/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20191126235420-ef20fe5d7933/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210510120150-4163338589ed/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.32.0 h1:ZqPmj8Kzc+Y6e0+skZsuACbx+wzMgo5MQsJh9Qd6aYI=\ngolang.org/x/net v0.32.0/go.mod h1:CwU0IoeOlnQQWJ6ioyFrfRuomB8GKF6KbYXZVyeXNfs=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180622082034-63fc586f45fe/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181122145206-62eef0e2fa9b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190403152447-81d4e9dc473e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190801041406-cbf593c0f2f3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190924154521-2837fb4f24fe/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191128015809-6d18c012aee9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210514084401-e8d321eab015/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210927094055-39ccf1dd6fa6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20190921001708-c4c64cad1fd0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20200630173020-3af7569d3a1e/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180828015842-6cd1fcedba52/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191203134012-c197fd4bf371/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191216052735-49a3e744a425/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.28.0 h1:WuB6qZ4RPCQo5aP3WdKZS7i595EdWqWR8vqJTlwTVK8=\ngolang.org/x/tools v0.28.0/go.mod h1:dcIOrVd3mfQKTgrDVQHqCPMWy6lnhfhtX3hLXYVLfRw=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/api v0.3.1/go.mod h1:6wY9I6uQWHQ8EM57III9mq/AjF+i8G65rmVagqKMtkk=\ngoogle.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=\ngoogle.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=\ngoogle.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=\ngoogle.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=\ngoogle.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=\ngoogle.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/grpc v1.17.0/go.mod h1:6QZJwpn2B+Zp71q/5VxRsJ6NXXVCE5NRUHRo+f3cWCs=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.19.1/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=\ngoogle.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/fsnotify.v1 v1.4.7 h1:xOHLXZwVvI9hhs+cLKq5+I5onOuwQLhQwiu63xxlHs4=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/h2non/gock.v1 v1.0.15/go.mod h1:sX4zAkdYX1TRGJ2JY156cFspQn4yRWn6p9EMdODlynE=\ngopkg.in/ini.v1 v1.42.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/ini.v1 v1.51.1/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/ns1/ns1-go.v2 v2.0.0-20190730140822-b51389932cbc/go.mod h1:VV+3haRsgDiVLxyifmMBrBIuCWFBPYKbRssXB9z67Hw=\ngopkg.in/resty.v1 v1.9.1/go.mod h1:vo52Hzryw9PnPHcJfPsBiFW62XhNx5OczbV9y+IMpgc=\ngopkg.in/resty.v1 v1.12.0/go.mod h1:mDo4pnntr5jdWRML875a/NmxYqAlA73dVijT2AXvQQo=\ngopkg.in/square/go-jose.v2 v2.3.1/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/yaml.v2 v2.0.0-20170812160011-eb3733d160e7/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.7/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.8 h1:obN1ZagJSUGI0Ek/LBmuj4SNLPfIny3KsKFopxRdj10=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20180728063816-88497007e858/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=\nhonnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nrsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=\nrsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=\nrsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 5.8603515625,
          "content": "//go:build !test\n// +build !test\n\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"flag\"\n\tstdlog \"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/caddyserver/certmagic\"\n\tlegolog \"github.com/go-acme/lego/v3/log\"\n\t\"github.com/julienschmidt/httprouter\"\n\t\"github.com/rs/cors\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n\t// Created files are not world writable\n\tsyscall.Umask(0077)\n\tconfigPtr := flag.String(\"c\", \"/etc/acme-dns/config.cfg\", \"config file location\")\n\tflag.Parse()\n\t// Read global config\n\tvar err error\n\tif fileIsAccessible(*configPtr) {\n\t\tlog.WithFields(log.Fields{\"file\": *configPtr}).Info(\"Using config file\")\n\t\tConfig, err = readConfig(*configPtr)\n\t} else if fileIsAccessible(\"./config.cfg\") {\n\t\tlog.WithFields(log.Fields{\"file\": \"./config.cfg\"}).Info(\"Using config file\")\n\t\tConfig, err = readConfig(\"./config.cfg\")\n\t} else {\n\t\tlog.Errorf(\"Configuration file not found.\")\n\t\tos.Exit(1)\n\t}\n\tif err != nil {\n\t\tlog.Errorf(\"Encountered an error while trying to read configuration file:  %s\", err)\n\t\tos.Exit(1)\n\t}\n\n\tsetupLogging(Config.Logconfig.Format, Config.Logconfig.Level)\n\n\t// Open database\n\tnewDB := new(acmedb)\n\terr = newDB.Init(Config.Database.Engine, Config.Database.Connection)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not open database [%v]\", err)\n\t\tos.Exit(1)\n\t} else {\n\t\tlog.Info(\"Connected to database\")\n\t}\n\tDB = newDB\n\tdefer DB.Close()\n\n\t// Error channel for servers\n\terrChan := make(chan error, 1)\n\n\t// DNS server\n\tdnsservers := make([]*DNSServer, 0)\n\tif strings.HasPrefix(Config.General.Proto, \"both\") {\n\t\t// Handle the case where DNS server should be started for both udp and tcp\n\t\tudpProto := \"udp\"\n\t\ttcpProto := \"tcp\"\n\t\tif strings.HasSuffix(Config.General.Proto, \"4\") {\n\t\t\tudpProto += \"4\"\n\t\t\ttcpProto += \"4\"\n\t\t} else if strings.HasSuffix(Config.General.Proto, \"6\") {\n\t\t\tudpProto += \"6\"\n\t\t\ttcpProto += \"6\"\n\t\t}\n\t\tdnsServerUDP := NewDNSServer(DB, Config.General.Listen, udpProto, Config.General.Domain)\n\t\tdnsservers = append(dnsservers, dnsServerUDP)\n\t\tdnsServerUDP.ParseRecords(Config)\n\t\tdnsServerTCP := NewDNSServer(DB, Config.General.Listen, tcpProto, Config.General.Domain)\n\t\tdnsservers = append(dnsservers, dnsServerTCP)\n\t\t// No need to parse records from config again\n\t\tdnsServerTCP.Domains = dnsServerUDP.Domains\n\t\tdnsServerTCP.SOA = dnsServerUDP.SOA\n\t\tgo dnsServerUDP.Start(errChan)\n\t\tgo dnsServerTCP.Start(errChan)\n\t} else {\n\t\tdnsServer := NewDNSServer(DB, Config.General.Listen, Config.General.Proto, Config.General.Domain)\n\t\tdnsservers = append(dnsservers, dnsServer)\n\t\tdnsServer.ParseRecords(Config)\n\t\tgo dnsServer.Start(errChan)\n\t}\n\n\t// HTTP API\n\tgo startHTTPAPI(errChan, Config, dnsservers)\n\n\t// block waiting for error\n\tfor {\n\t\terr = <-errChan\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc startHTTPAPI(errChan chan error, config DNSConfig, dnsservers []*DNSServer) {\n\t// Setup http logger\n\tlogger := log.New()\n\tlogwriter := logger.Writer()\n\tdefer logwriter.Close()\n\t// Setup logging for different dependencies to log with logrus\n\t// Certmagic\n\tstdlog.SetOutput(logwriter)\n\t// Lego\n\tlegolog.Logger = logger\n\n\tapi := httprouter.New()\n\tc := cors.New(cors.Options{\n\t\tAllowedOrigins:     Config.API.CorsOrigins,\n\t\tAllowedMethods:     []string{\"GET\", \"POST\"},\n\t\tOptionsPassthrough: false,\n\t\tDebug:              Config.General.Debug,\n\t})\n\tif Config.General.Debug {\n\t\t// Logwriter for saner log output\n\t\tc.Log = stdlog.New(logwriter, \"\", 0)\n\t}\n\tif !Config.API.DisableRegistration {\n\t\tapi.POST(\"/register\", webRegisterPost)\n\t}\n\tapi.POST(\"/update\", Auth(webUpdatePost))\n\tapi.GET(\"/health\", healthCheck)\n\n\thost := Config.API.IP + \":\" + Config.API.Port\n\n\t// TLS specific general settings\n\tcfg := &tls.Config{\n\t\tMinVersion: tls.VersionTLS12,\n\t}\n\tprovider := NewChallengeProvider(dnsservers)\n\tstorage := certmagic.FileStorage{Path: Config.API.ACMECacheDir}\n\n\t// Set up certmagic for getting certificate for acme-dns api\n\tcertmagic.DefaultACME.DNS01Solver = &provider\n\tcertmagic.DefaultACME.Agreed = true\n\tif Config.API.TLS == \"letsencrypt\" {\n\t\tcertmagic.DefaultACME.CA = certmagic.LetsEncryptProductionCA\n\t} else {\n\t\tcertmagic.DefaultACME.CA = certmagic.LetsEncryptStagingCA\n\t}\n\tcertmagic.DefaultACME.Email = Config.API.NotificationEmail\n\tmagicConf := certmagic.NewDefault()\n\tmagicConf.Storage = &storage\n\tmagicConf.DefaultServerName = Config.General.Domain\n\n\tmagicCache := certmagic.NewCache(certmagic.CacheOptions{\n\t\tGetConfigForCert: func(cert certmagic.Certificate) (*certmagic.Config, error) {\n\t\t\treturn magicConf, nil\n\t\t},\n\t})\n\n\tmagic := certmagic.New(magicCache, *magicConf)\n\tvar err error\n\tswitch Config.API.TLS {\n\tcase \"letsencryptstaging\":\n\t\terr = magic.ManageAsync(context.Background(), []string{Config.General.Domain})\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tcfg.GetCertificate = magic.GetCertificate\n\n\t\tsrv := &http.Server{\n\t\t\tAddr:      host,\n\t\t\tHandler:   c.Handler(api),\n\t\t\tTLSConfig: cfg,\n\t\t\tErrorLog:  stdlog.New(logwriter, \"\", 0),\n\t\t}\n\t\tlog.WithFields(log.Fields{\"host\": host, \"domain\": Config.General.Domain}).Info(\"Listening HTTPS\")\n\t\terr = srv.ListenAndServeTLS(\"\", \"\")\n\tcase \"letsencrypt\":\n\t\terr = magic.ManageAsync(context.Background(), []string{Config.General.Domain})\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tcfg.GetCertificate = magic.GetCertificate\n\t\tsrv := &http.Server{\n\t\t\tAddr:      host,\n\t\t\tHandler:   c.Handler(api),\n\t\t\tTLSConfig: cfg,\n\t\t\tErrorLog:  stdlog.New(logwriter, \"\", 0),\n\t\t}\n\t\tlog.WithFields(log.Fields{\"host\": host, \"domain\": Config.General.Domain}).Info(\"Listening HTTPS\")\n\t\terr = srv.ListenAndServeTLS(\"\", \"\")\n\tcase \"cert\":\n\t\tsrv := &http.Server{\n\t\t\tAddr:      host,\n\t\t\tHandler:   c.Handler(api),\n\t\t\tTLSConfig: cfg,\n\t\t\tErrorLog:  stdlog.New(logwriter, \"\", 0),\n\t\t}\n\t\tlog.WithFields(log.Fields{\"host\": host}).Info(\"Listening HTTPS\")\n\t\terr = srv.ListenAndServeTLS(Config.API.TLSCertFullchain, Config.API.TLSCertPrivkey)\n\tdefault:\n\t\tlog.WithFields(log.Fields{\"host\": host}).Info(\"Listening HTTP\")\n\t\terr = http.ListenAndServe(host, c.Handler(api))\n\t}\n\tif err != nil {\n\t\terrChan <- err\n\t}\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 2.314453125,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\n\tlog \"github.com/sirupsen/logrus\"\n\tlogrustest \"github.com/sirupsen/logrus/hooks/test\"\n)\n\nvar loghook = new(logrustest.Hook)\nvar dnsserver *DNSServer\n\nvar (\n\tpostgres = flag.Bool(\"postgres\", false, \"run integration tests against PostgreSQL\")\n)\n\nvar records = []string{\n\t\"auth.example.org. A 192.168.1.100\",\n\t\"ns1.auth.example.org. A 192.168.1.101\",\n\t\"cn.example.org CNAME something.example.org.\",\n\t\"!''b', unparseable \",\n\t\"ns2.auth.example.org. A 192.168.1.102\",\n}\n\nfunc TestMain(m *testing.M) {\n\tsetupTestLogger()\n\tsetupConfig()\n\tflag.Parse()\n\n\tnewDb := new(acmedb)\n\tif *postgres {\n\t\tConfig.Database.Engine = \"postgres\"\n\t\terr := newDb.Init(\"postgres\", \"postgres://acmedns:acmedns@localhost/acmedns\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"PostgreSQL integration tests expect database \\\"acmedns\\\" running in localhost, with username and password set to \\\"acmedns\\\"\")\n\t\t\tos.Exit(1)\n\t\t}\n\t} else {\n\t\tConfig.Database.Engine = \"sqlite3\"\n\t\t_ = newDb.Init(\"sqlite3\", \":memory:\")\n\t}\n\tDB = newDb\n\tdnsserver = NewDNSServer(DB, Config.General.Listen, Config.General.Proto, Config.General.Domain)\n\tdnsserver.ParseRecords(Config)\n\n\t// Make sure that we're not creating a race condition in tests\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tdnsserver.Server.NotifyStartedFunc = func() {\n\t\twg.Done()\n\t}\n\tgo dnsserver.Start(make(chan error, 1))\n\twg.Wait()\n\texitval := m.Run()\n\t_ = dnsserver.Server.Shutdown()\n\tDB.Close()\n\tos.Exit(exitval)\n}\n\nfunc setupConfig() {\n\tvar dbcfg = dbsettings{\n\t\tEngine:     \"sqlite3\",\n\t\tConnection: \":memory:\",\n\t}\n\n\tvar generalcfg = general{\n\t\tDomain:        \"auth.example.org\",\n\t\tListen:        \"127.0.0.1:15353\",\n\t\tProto:         \"udp\",\n\t\tNsname:        \"ns1.auth.example.org\",\n\t\tNsadmin:       \"admin.example.org\",\n\t\tStaticRecords: records,\n\t\tDebug:         false,\n\t}\n\n\tvar httpapicfg = httpapi{\n\t\tDomain:      \"\",\n\t\tPort:        \"8080\",\n\t\tTLS:         \"none\",\n\t\tCorsOrigins: []string{\"*\"},\n\t\tUseHeader:   false,\n\t\tHeaderName:  \"X-Forwarded-For\",\n\t}\n\n\tvar dnscfg = DNSConfig{\n\t\tDatabase: dbcfg,\n\t\tGeneral:  generalcfg,\n\t\tAPI:      httpapicfg,\n\t}\n\n\tConfig = dnscfg\n}\n\nfunc setupTestLogger() {\n\tlog.SetOutput(io.Discard)\n\tlog.AddHook(loghook)\n}\n\nfunc loggerHasEntryWithMessage(message string) bool {\n\tfor _, v := range loghook.Entries {\n\t\tif v.Message == message {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "run_tests.sh",
          "type": "blob",
          "size": 0.1708984375,
          "content": "#!/bin/sh\n# go test doesn't play well with noexec /tmp\nsudo mkdir /gotmp\nsudo mount tmpfs -t tmpfs /gotmp\nTMPDIR=/gotmp go test -v -race\nsudo umount /gotmp\nsudo rm -rf /gotmp\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 1.7646484375,
          "content": "package main\n\nimport (\n\t\"database/sql\"\n\t\"sync\"\n\n\t\"github.com/google/uuid\"\n)\n\n// Config is global configuration struct\nvar Config DNSConfig\n\n// DB is used to access the database functions in acme-dns\nvar DB database\n\n// DNSConfig holds the config structure\ntype DNSConfig struct {\n\tGeneral   general\n\tDatabase  dbsettings\n\tAPI       httpapi\n\tLogconfig logconfig\n}\n\n// Config file general section\ntype general struct {\n\tListen        string\n\tProto         string `toml:\"protocol\"`\n\tDomain        string\n\tNsname        string\n\tNsadmin       string\n\tDebug         bool\n\tStaticRecords []string `toml:\"records\"`\n}\n\ntype dbsettings struct {\n\tEngine     string\n\tConnection string\n}\n\n// API config\ntype httpapi struct {\n\tDomain              string `toml:\"api_domain\"`\n\tIP                  string\n\tDisableRegistration bool   `toml:\"disable_registration\"`\n\tAutocertPort        string `toml:\"autocert_port\"`\n\tPort                string `toml:\"port\"`\n\tTLS                 string\n\tTLSCertPrivkey      string `toml:\"tls_cert_privkey\"`\n\tTLSCertFullchain    string `toml:\"tls_cert_fullchain\"`\n\tACMECacheDir        string `toml:\"acme_cache_dir\"`\n\tNotificationEmail   string `toml:\"notification_email\"`\n\tCorsOrigins         []string\n\tUseHeader           bool   `toml:\"use_header\"`\n\tHeaderName          string `toml:\"header_name\"`\n}\n\n// Logging config\ntype logconfig struct {\n\tLevel   string `toml:\"loglevel\"`\n\tLogtype string `toml:\"logtype\"`\n\tFile    string `toml:\"logfile\"`\n\tFormat  string `toml:\"logformat\"`\n}\n\ntype acmedb struct {\n\tMutex sync.Mutex\n\tDB *sql.DB\n}\n\ntype database interface {\n\tInit(string, string) error\n\tRegister(cidrslice) (ACMETxt, error)\n\tGetByUsername(uuid.UUID) (ACMETxt, error)\n\tGetTXTForDomain(string) ([]string, error)\n\tUpdate(ACMETxtPost) error\n\tGetBackend() *sql.DB\n\tSetBackend(*sql.DB)\n\tClose()\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 2.6865234375,
          "content": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/BurntSushi/toml\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nfunc jsonError(message string) []byte {\n\treturn []byte(fmt.Sprintf(\"{\\\"error\\\": \\\"%s\\\"}\", message))\n}\n\nfunc fileIsAccessible(fname string) bool {\n\t_, err := os.Stat(fname)\n\tif err != nil {\n\t\treturn false\n\t}\n\tf, err := os.Open(fname)\n\tif err != nil {\n\t\treturn false\n\t}\n\tf.Close()\n\treturn true\n}\n\nfunc readConfig(fname string) (DNSConfig, error) {\n\tvar conf DNSConfig\n\t_, err := toml.DecodeFile(fname, &conf)\n\tif err != nil {\n\t\t// Return with config file parsing errors from toml package\n\t\treturn conf, err\n\t}\n\treturn prepareConfig(conf)\n}\n\n// prepareConfig checks that mandatory values exist, and can be used to set default values in the future\nfunc prepareConfig(conf DNSConfig) (DNSConfig, error) {\n\tif conf.Database.Engine == \"\" {\n\t\treturn conf, errors.New(\"missing database configuration option \\\"engine\\\"\")\n\t}\n\tif conf.Database.Connection == \"\" {\n\t\treturn conf, errors.New(\"missing database configuration option \\\"connection\\\"\")\n\t}\n\n\t// Default values for options added to config to keep backwards compatibility with old config\n\tif conf.API.ACMECacheDir == \"\" {\n\t\tconf.API.ACMECacheDir = \"api-certs\"\n\t}\n\n\treturn conf, nil\n}\n\nfunc sanitizeString(s string) string {\n\t// URL safe base64 alphabet without padding as defined in ACME\n\tre, _ := regexp.Compile(`[^A-Za-z\\-\\_0-9]+`)\n\treturn re.ReplaceAllString(s, \"\")\n}\n\nfunc sanitizeIPv6addr(s string) string {\n\t// Remove brackets from IPv6 addresses, net.ParseCIDR needs this\n\tre, _ := regexp.Compile(`[\\[\\]]+`)\n\treturn re.ReplaceAllString(s, \"\")\n}\n\nfunc generatePassword(length int) string {\n\tret := make([]byte, length)\n\tconst alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-_\"\n\talphalen := big.NewInt(int64(len(alphabet)))\n\tfor i := 0; i < length; i++ {\n\t\tc, _ := rand.Int(rand.Reader, alphalen)\n\t\tr := int(c.Int64())\n\t\tret[i] = alphabet[r]\n\t}\n\treturn string(ret)\n}\n\nfunc sanitizeDomainQuestion(d string) string {\n\tdom := strings.ToLower(d)\n\tfirstDot := strings.Index(d, \".\")\n\tif firstDot > 0 {\n\t\tdom = dom[0:firstDot]\n\t}\n\treturn dom\n}\n\nfunc setupLogging(format string, level string) {\n\tif format == \"json\" {\n\t\tlog.SetFormatter(&log.JSONFormatter{})\n\t}\n\tswitch level {\n\tdefault:\n\t\tlog.SetLevel(log.WarnLevel)\n\tcase \"debug\":\n\t\tlog.SetLevel(log.DebugLevel)\n\tcase \"info\":\n\t\tlog.SetLevel(log.InfoLevel)\n\tcase \"error\":\n\t\tlog.SetLevel(log.ErrorLevel)\n\t}\n\t// TODO: file logging\n}\n\nfunc getIPListFromHeader(header string) []string {\n\tiplist := []string{}\n\tfor _, v := range strings.Split(header, \",\") {\n\t\tif len(v) > 0 {\n\t\t\t// Ignore empty values\n\t\t\tiplist = append(iplist, strings.TrimSpace(v))\n\t\t}\n\t}\n\treturn iplist\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 3.771484375,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nfunc TestSetupLogging(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tformat   string\n\t\tlevel    string\n\t\texpected string\n\t}{\n\t\t{\"text\", \"warning\", \"warning\"},\n\t\t{\"json\", \"debug\", \"debug\"},\n\t\t{\"text\", \"info\", \"info\"},\n\t\t{\"json\", \"error\", \"error\"},\n\t\t{\"text\", \"something\", \"warning\"},\n\t} {\n\t\tsetupLogging(test.format, test.level)\n\t\tif log.GetLevel().String() != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected loglevel %s but got %s\", i, test.expected, log.GetLevel().String())\n\t\t}\n\t}\n}\n\nfunc TestReadConfig(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tinFile []byte\n\t\toutput DNSConfig\n\t}{\n\t\t{\n\t\t\t[]byte(\"[general]\\nlisten = \\\":53\\\"\\ndebug = true\\n[api]\\napi_domain = \\\"something.strange\\\"\"),\n\t\t\tDNSConfig{\n\t\t\t\tGeneral: general{\n\t\t\t\t\tListen: \":53\",\n\t\t\t\t\tDebug:  true,\n\t\t\t\t},\n\t\t\t\tAPI: httpapi{\n\t\t\t\t\tDomain: \"something.strange\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t{\n\t\t\t[]byte(\"[\\x00[[[[[[[[[de\\nlisten =]\"),\n\t\t\tDNSConfig{},\n\t\t},\n\t} {\n\t\ttmpfile, err := os.CreateTemp(\"\", \"acmedns\")\n\t\tif err != nil {\n\t\t\tt.Error(\"Could not create temporary file\")\n\t\t}\n\t\tdefer os.Remove(tmpfile.Name())\n\n\t\tif _, err := tmpfile.Write(test.inFile); err != nil {\n\t\t\tt.Error(\"Could not write to temporary file\")\n\t\t}\n\n\t\tif err := tmpfile.Close(); err != nil {\n\t\t\tt.Error(\"Could not close temporary file\")\n\t\t}\n\t\tret, _ := readConfig(tmpfile.Name())\n\t\tif ret.General.Listen != test.output.General.Listen {\n\t\t\tt.Errorf(\"Test %d: Expected listen value %s, but got %s\", i, test.output.General.Listen, ret.General.Listen)\n\t\t}\n\t\tif ret.API.Domain != test.output.API.Domain {\n\t\t\tt.Errorf(\"Test %d: Expected HTTP API domain %s, but got %s\", i, test.output.API.Domain, ret.API.Domain)\n\t\t}\n\t}\n}\n\nfunc TestGetIPListFromHeader(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tinput  string\n\t\toutput []string\n\t}{\n\t\t{\"1.1.1.1, 2.2.2.2\", []string{\"1.1.1.1\", \"2.2.2.2\"}},\n\t\t{\" 1.1.1.1 , 2.2.2.2\", []string{\"1.1.1.1\", \"2.2.2.2\"}},\n\t\t{\",1.1.1.1 ,2.2.2.2\", []string{\"1.1.1.1\", \"2.2.2.2\"}},\n\t} {\n\t\tres := getIPListFromHeader(test.input)\n\t\tif len(res) != len(test.output) {\n\t\t\tt.Errorf(\"Test %d: Expected [%d] items in return list, but got [%d]\", i, len(test.output), len(res))\n\t\t} else {\n\n\t\t\tfor j, vv := range test.output {\n\t\t\t\tif res[j] != vv {\n\t\t\t\t\tt.Errorf(\"Test %d: Expected return value [%v] but got [%v]\", j, test.output, res)\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestFileCheckPermissionDenied(t *testing.T) {\n\ttmpfile, err := os.CreateTemp(\"\", \"acmedns\")\n\tif err != nil {\n\t\tt.Error(\"Could not create temporary file\")\n\t}\n\tdefer os.Remove(tmpfile.Name())\n\t_ = syscall.Chmod(tmpfile.Name(), 0000)\n\tif fileIsAccessible(tmpfile.Name()) {\n\t\tt.Errorf(\"File should not be accessible\")\n\t}\n\t_ = syscall.Chmod(tmpfile.Name(), 0644)\n}\n\nfunc TestFileCheckNotExists(t *testing.T) {\n\tif fileIsAccessible(\"/path/that/does/not/exist\") {\n\t\tt.Errorf(\"File should not be accessible\")\n\t}\n}\n\nfunc TestFileCheckOK(t *testing.T) {\n\ttmpfile, err := os.CreateTemp(\"\", \"acmedns\")\n\tif err != nil {\n\t\tt.Error(\"Could not create temporary file\")\n\t}\n\tdefer os.Remove(tmpfile.Name())\n\tif !fileIsAccessible(tmpfile.Name()) {\n\t\tt.Errorf(\"File should be accessible\")\n\t}\n}\n\nfunc TestPrepareConfig(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tinput       DNSConfig\n\t\tshoulderror bool\n\t}{\n\t\t{DNSConfig{Database: dbsettings{Engine: \"whatever\", Connection: \"whatever_too\"}}, false},\n\t\t{DNSConfig{Database: dbsettings{Engine: \"\", Connection: \"whatever_too\"}}, true},\n\t\t{DNSConfig{Database: dbsettings{Engine: \"whatever\", Connection: \"\"}}, true},\n\t} {\n\t\t_, err := prepareConfig(test.input)\n\t\tif test.shoulderror {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Test %d: Expected error with prepareConfig input data [%v]\", i, test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Test %d: Expected no error with prepareConfig input data [%v]\", i, test.input)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "validation.go",
          "type": "blob",
          "size": 1.0634765625,
          "content": "package main\n\nimport (\n\t\"unicode/utf8\"\n\t\"regexp\"\n\n\t\"github.com/google/uuid\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\nfunc getValidUsername(u string) (uuid.UUID, error) {\n\tuname, err := uuid.Parse(u)\n\tif err != nil {\n\t\treturn uuid.UUID{}, err\n\t}\n\treturn uname, nil\n}\n\nfunc validKey(k string) bool {\n\tkn := sanitizeString(k)\n\tif utf8.RuneCountInString(k) == 40 && utf8.RuneCountInString(kn) == 40 {\n\t\t// Correct length and all chars valid\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc validSubdomain(s string) bool {\n\t// URL safe base64 alphabet without padding as defined in ACME\n\tRegExp := regexp.MustCompile(\"^[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?$\")\n\treturn RegExp.MatchString(s)\n}\n\nfunc validTXT(s string) bool {\n\tsn := sanitizeString(s)\n\tif utf8.RuneCountInString(s) == 43 && utf8.RuneCountInString(sn) == 43 {\n\t\t// 43 chars is the current LE auth key size, but not limited / defined by ACME\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc correctPassword(pw string, hash string) bool {\n\tif err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(pw)); err == nil {\n\t\treturn true\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "validation_test.go",
          "type": "blob",
          "size": 3.521484375,
          "content": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/google/uuid\"\n)\n\nfunc TestGetValidUsername(t *testing.T) {\n\tv1, _ := uuid.Parse(\"a097455b-52cc-4569-90c8-7a4b97c6eba8\")\n\tfor i, test := range []struct {\n\t\tuname     string\n\t\toutput    uuid.UUID\n\t\tshouldErr bool\n\t}{\n\t\t{\"a097455b-52cc-4569-90c8-7a4b97c6eba8\", v1, false},\n\t\t{\"a-97455b-52cc-4569-90c8-7a4b97c6eba8\", uuid.UUID{}, true},\n\t\t{\"\", uuid.UUID{}, true},\n\t\t{\"&!#!25123!%!'%\", uuid.UUID{}, true},\n\t} {\n\t\tret, err := getValidUsername(test.uname)\n\t\tif test.shouldErr && err == nil {\n\t\t\tt.Errorf(\"Test %d: Expected error, but there was none\", i)\n\t\t}\n\t\tif !test.shouldErr && err != nil {\n\t\t\tt.Errorf(\"Test %d: Expected no error, but got [%v]\", i, err)\n\t\t}\n\t\tif ret != test.output {\n\t\t\tt.Errorf(\"Test %d: Expected return value %v, but got %v\", i, test.output, ret)\n\t\t}\n\t}\n}\n\nfunc TestValidKey(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tkey    string\n\t\toutput bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", true},\n\t\t{\"aaaaaaaa-aaa-aaaaaa-aaaaaaaa-aaa_aacaaaa\", true},\n\t\t{\"aaaaaaaa-aaa-aaaaaa#aaaaaaaa-aaa_aacaaaa\", false},\n\t\t{\"aaaaaaaa-aaa-aaaaaa-aaaaaaaa-aaa_aacaaaaa\", false},\n\t} {\n\t\tret := validKey(test.key)\n\t\tif ret != test.output {\n\t\t\tt.Errorf(\"Test %d: Expected return value %t, but got %t\", i, test.output, ret)\n\t\t}\n\t}\n}\n\nfunc TestGetValidSubdomain(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tsubdomain string\n\t\toutput    bool\n\t}{\n\t\t{\"a097455b-52cc-4569-90c8-7a4b97c6eba8\", true},\n\t\t{\"a-97455b-52cc-4569-90c8-7a4b97c6eba8\", true},\n\t\t{\"foo.example.com\", false},\n\t\t{\"foo-example-com\", true},\n\t\t{\"\", false},\n\t\t{\"&!#!25123!%!'%\", false},\n\t} {\n\t\tret := validSubdomain(test.subdomain)\n\t\tif ret != test.output {\n\t\t\tt.Errorf(\"Test %d: Expected return value %t, but got %t\", i, test.output, ret)\n\t\t}\n\t}\n}\n\nfunc TestValidTXT(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ttxt    string\n\t\toutput bool\n\t}{\n\t\t{\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", true},\n\t\t{\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", false},\n\t\t{\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa#aaaaaaaaaaaaaa\", false},\n\t\t{\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", false},\n\t\t{\"\", false},\n\t} {\n\t\tret := validTXT(test.txt)\n\t\tif ret != test.output {\n\t\t\tt.Errorf(\"Test %d: Expected return value %t, but got %t\", i, test.output, ret)\n\t\t}\n\t}\n}\n\nfunc TestCorrectPassword(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tpw     string\n\t\thash   string\n\t\toutput bool\n\t}{\n\t\t{\"PUrNTjU24JYNEOCeS2JcjaJGv1sinT80oV9--dpX\",\n\t\t\t\"$2a$10$ldVoGU5yrdlbPzuPUbUfleVovGjaRelP9tql0IltVUJk778gf.2tu\",\n\t\t\ttrue},\n\t\t{\"PUrNTjU24JYNEOCeS2JcjaJGv1sinT80oV9--dpX\",\n\t\t\t\"$2a$10$ldVoGU5yrdlbPzuPUbUfleVovGjaRelP9tql0IltVUJk778gf.2t\",\n\t\t\tfalse},\n\t\t{\"PUrNTjU24JYNEOCeS2JcjaJGv1sinT80oV9--dp\",\n\t\t\t\"$2a$10$ldVoGU5yrdlbPzuPUbUfleVovGjaRelP9tql0IltVUJk778gf.2tu\",\n\t\t\tfalse},\n\t\t{\"\", \"\", false},\n\t} {\n\t\tret := correctPassword(test.pw, test.hash)\n\t\tif ret != test.output {\n\t\t\tt.Errorf(\"Test %d: Expected return value %t, but got %t\", i, test.output, ret)\n\t\t}\n\t}\n}\n\nfunc TestGetValidCIDRMasks(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tinput  cidrslice\n\t\toutput cidrslice\n\t}{\n\t\t{cidrslice{\"10.0.0.1/24\"}, cidrslice{\"10.0.0.1/24\"}},\n\t\t{cidrslice{\"invalid\", \"127.0.0.1/32\"}, cidrslice{\"127.0.0.1/32\"}},\n\t\t{cidrslice{\"2002:c0a8::0/32\", \"8.8.8.8/32\"}, cidrslice{\"2002:c0a8::0/32\", \"8.8.8.8/32\"}},\n\t} {\n\t\tret := test.input.ValidEntries()\n\t\tif len(ret) == len(test.output) {\n\t\t\tfor i, v := range ret {\n\t\t\t\tif v != test.output[i] {\n\t\t\t\t\tt.Errorf(\"Test %d: Expected %q but got %q\", i, test.output, ret)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"Test %d: Expected %q but got %q\", i, test.output, ret)\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}