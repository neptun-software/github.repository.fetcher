{
  "metadata": {
    "timestamp": 1736566611553,
    "page": 167,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "codegangsta/gin",
      "stars": 4234,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3349609375,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\nlib/test_fixtures/build_success/build_success\n\n# Ignore IDE files\n.idea\n*.iml\n*.ipr\n*.iws\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Jeremy Saenz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.857421875,
          "content": "gin [![wercker status](https://app.wercker.com/status/f413ccbd85cfc4a58a37f03dd7aaa87e \"wercker status\")](https://app.wercker.com/project/bykey/f413ccbd85cfc4a58a37f03dd7aaa87e)\n========\n\n`gin` is a simple command line utility for live-reloading Go web applications.\nJust run `gin` in your app directory and your web app will be served with\n`gin` as a proxy. `gin` will automatically recompile your code when it\ndetects a change. Your app will be restarted the next time it receives an\nHTTP request.\n\n`gin` adheres to the \"silence is golden\" principle, so it will only complain\nif there was a compiler error or if you succesfully compile after an error.\n\n## Installation\n\nAssuming you have a working Go environment and `GOPATH/bin` is in your\n`PATH`, `gin` is a breeze to install:\n\n```shell\ngo install github.com/codegangsta/gin@latest\n```\n\nThen verify that `gin` was installed correctly:\n\n```shell\ngin help\n```\n## Basic usage\n```shell\ngin run main.go\n```\nOptions\n```\n   --laddr value, -l value       listening address for the proxy server\n   --port value, -p value        port for the proxy server (default: 3000)\n   --appPort value, -a value     port for the Go web server (default: 3001)\n   --bin value, -b value         name of generated binary file (default: \"gin-bin\")\n   --path value, -t value        Path to watch files from (default: \".\")\n   --build value, -d value       Path to build files from (defaults to same value as --path)\n   --excludeDir value, -x value  Relative directories to exclude\n   --immediate, -i               run the server immediately after it's built\n   --all                         reloads whenever any file changes, as opposed to reloading only on .go file change\n   --godep, -g                   use godep when building\n   --buildArgs value             Additional go build arguments\n   --certFile value              TLS Certificate\n   --keyFile value               TLS Certificate Key\n   --logPrefix value             Setup custom log prefix\n   --notifications               enable desktop notifications\n   --help, -h                    show help\n   --version, -v                 print the version\n```\n\n## Supporting Gin in Your Web app\n`gin` assumes that your web app binds itself to the `PORT` environment\nvariable so it can properly proxy requests to your app. Web frameworks\nlike [Martini](http://github.com/codegangsta/martini) do this out of\nthe box.\n\n## Using flags?\nWhen you normally start your server with [flags](https://godoc.org/flag)\nif you want to override any of them when running `gin` we suggest you\ninstead use [github.com/namsral/flag](https://github.com/namsral/flag)\nas explained in [this post](http://stackoverflow.com/questions/24873883/organizing-environment-variables-golang/28160665#28160665)\n\nIf you want to still use the standard flag package but support environment variables, you might want to try [github.com/peak6/envflag](https://github.com/peak6/envflag).\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 6.916015625,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/codegangsta/envy/lib\"\n\t\"github.com/codegangsta/gin/lib\"\n\tshellwords \"github.com/mattn/go-shellwords\"\n\t\"github.com/urfave/cli\"\n\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/0xAX/notificator\"\n)\n\nvar (\n\tstartTime     = time.Now()\n\tlogger        = log.New(os.Stdout, \"[gin] \", 0)\n\timmediate     = false\n\tbuildError    error\n\tcolorGreen    = string([]byte{27, 91, 57, 55, 59, 51, 50, 59, 49, 109})\n\tcolorRed      = string([]byte{27, 91, 57, 55, 59, 51, 49, 59, 49, 109})\n\tcolorReset    = string([]byte{27, 91, 48, 109})\n\tnotifier      = notificator.New(notificator.Options{AppName: \"Gin Build\"})\n\tnotifications = false\n)\n\nfunc main() {\n\tapp := cli.NewApp()\n\tapp.Name = \"gin\"\n\tapp.Usage = \"A live reload utility for Go web applications.\"\n\tapp.Action = MainAction\n\tapp.Flags = []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:   \"laddr,l\",\n\t\t\tValue:  \"\",\n\t\t\tEnvVar: \"GIN_LADDR\",\n\t\t\tUsage:  \"listening address for the proxy server\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName:   \"port,p\",\n\t\t\tValue:  3000,\n\t\t\tEnvVar: \"GIN_PORT\",\n\t\t\tUsage:  \"port for the proxy server\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName:   \"appPort,a\",\n\t\t\tValue:  3001,\n\t\t\tEnvVar: \"BIN_APP_PORT\",\n\t\t\tUsage:  \"port for the Go web server\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"bin,b\",\n\t\t\tValue:  \"gin-bin\",\n\t\t\tEnvVar: \"GIN_BIN\",\n\t\t\tUsage:  \"name of generated binary file\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"path,t\",\n\t\t\tValue:  \".\",\n\t\t\tEnvVar: \"GIN_PATH\",\n\t\t\tUsage:  \"Path to watch files from\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"build,d\",\n\t\t\tValue:  \"\",\n\t\t\tEnvVar: \"GIN_BUILD\",\n\t\t\tUsage:  \"Path to build files from (defaults to same value as --path)\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:   \"excludeDir,x\",\n\t\t\tValue:  &cli.StringSlice{},\n\t\t\tEnvVar: \"GIN_EXCLUDE_DIR\",\n\t\t\tUsage:  \"Relative directories to exclude\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:   \"immediate,i\",\n\t\t\tEnvVar: \"GIN_IMMEDIATE\",\n\t\t\tUsage:  \"run the server immediately after it's built\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:   \"all\",\n\t\t\tEnvVar: \"GIN_ALL\",\n\t\t\tUsage:  \"reloads whenever any file changes, as opposed to reloading only on .go file change\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:   \"godep,g\",\n\t\t\tEnvVar: \"GIN_GODEP\",\n\t\t\tUsage:  \"use godep when building\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"buildArgs\",\n\t\t\tEnvVar: \"GIN_BUILD_ARGS\",\n\t\t\tUsage:  \"Additional go build arguments\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"certFile\",\n\t\t\tEnvVar: \"GIN_CERT_FILE\",\n\t\t\tUsage:  \"TLS Certificate\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"keyFile\",\n\t\t\tEnvVar: \"GIN_KEY_FILE\",\n\t\t\tUsage:  \"TLS Certificate Key\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"logPrefix\",\n\t\t\tEnvVar: \"GIN_LOG_PREFIX\",\n\t\t\tUsage:  \"Log prefix\",\n\t\t\tValue:  \"gin\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:   \"notifications\",\n\t\t\tEnvVar: \"GIN_NOTIFICATIONS\",\n\t\t\tUsage:  \"Enables desktop notifications\",\n\t\t},\n\t}\n\tapp.Commands = []cli.Command{\n\t\t{\n\t\t\tName:            \"run\",\n\t\t\tShortName:       \"r\",\n\t\t\tUsage:           \"Run the gin proxy in the current working directory\",\n\t\t\tAction:          MainAction,\n\t\t\tSkipFlagParsing: true,\n\t\t},\n\t\t{\n\t\t\tName:      \"env\",\n\t\t\tShortName: \"e\",\n\t\t\tUsage:     \"Display environment variables set by the .env file\",\n\t\t\tAction:    EnvAction,\n\t\t},\n\t}\n\n\tapp.Run(os.Args)\n}\n\nfunc MainAction(c *cli.Context) {\n\tladdr := c.GlobalString(\"laddr\")\n\tport := c.GlobalInt(\"port\")\n\tall := c.GlobalBool(\"all\")\n\tappPort := strconv.Itoa(c.GlobalInt(\"appPort\"))\n\timmediate = c.GlobalBool(\"immediate\")\n\tkeyFile := c.GlobalString(\"keyFile\")\n\tcertFile := c.GlobalString(\"certFile\")\n\tlogPrefix := c.GlobalString(\"logPrefix\")\n\tnotifications = c.GlobalBool(\"notifications\")\n\n\tlogger.SetPrefix(fmt.Sprintf(\"[%s] \", logPrefix))\n\n\t// Bootstrap the environment\n\tenvy.Bootstrap()\n\n\t// Set the PORT env\n\tos.Setenv(\"PORT\", appPort)\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tlogger.Fatal(err)\n\t}\n\n\tbuildArgs, err := shellwords.Parse(c.GlobalString(\"buildArgs\"))\n\tif err != nil {\n\t\tlogger.Fatal(err)\n\t}\n\n\tbuildPath := c.GlobalString(\"build\")\n\tif buildPath == \"\" {\n\t\tbuildPath = c.GlobalString(\"path\")\n\t}\n\tbuilder := gin.NewBuilder(buildPath, c.GlobalString(\"bin\"), c.GlobalBool(\"godep\"), wd, buildArgs)\n\trunner := gin.NewRunner(filepath.Join(wd, builder.Binary()), c.Args()...)\n\trunner.SetWriter(os.Stdout)\n\tproxy := gin.NewProxy(builder, runner)\n\n\tconfig := &gin.Config{\n\t\tLaddr:    laddr,\n\t\tPort:     port,\n\t\tProxyTo:  \"http://localhost:\" + appPort,\n\t\tKeyFile:  keyFile,\n\t\tCertFile: certFile,\n\t}\n\n\terr = proxy.Run(config)\n\tif err != nil {\n\t\tlogger.Fatal(err)\n\t}\n\n\tif laddr != \"\" {\n\t\tlogger.Printf(\"Listening at %s:%d\\n\", laddr, port)\n\t} else {\n\t\tlogger.Printf(\"Listening on port %d\\n\", port)\n\t}\n\n\tshutdown(runner)\n\n\t// build right now\n\tbuild(builder, runner, logger)\n\n\t// scan for changes\n\tscanChanges(c.GlobalString(\"path\"), c.GlobalStringSlice(\"excludeDir\"), all, func(path string) {\n\t\trunner.Kill()\n\t\tbuild(builder, runner, logger)\n\t})\n}\n\nfunc EnvAction(c *cli.Context) {\n\tlogPrefix := c.GlobalString(\"logPrefix\")\n\tlogger.SetPrefix(fmt.Sprintf(\"[%s] \", logPrefix))\n\n\t// Bootstrap the environment\n\tenv, err := envy.Bootstrap()\n\tif err != nil {\n\t\tlogger.Fatalln(err)\n\t}\n\n\tfor k, v := range env {\n\t\tfmt.Printf(\"%s: %s\\n\", k, v)\n\t}\n\n}\n\nfunc build(builder gin.Builder, runner gin.Runner, logger *log.Logger) {\n\tlogger.Println(\"Building...\")\n\n\tif notifications {\n\t\tnotifier.Push(\"Build Started!\", \"Building \"+builder.Binary()+\"...\", \"\", notificator.UR_NORMAL)\n\t}\n\terr := builder.Build()\n\tif err != nil {\n\t\tbuildError = err\n\t\tlogger.Printf(\"%sBuild failed%s\\n\", colorRed, colorReset)\n\t\tfmt.Println(builder.Errors())\n\t\tbuildErrors := strings.Split(builder.Errors(), \"\\n\")\n\t\tif notifications {\n\t\t\tif err := notifier.Push(\"Build FAILED!\", buildErrors[1], \"\", notificator.UR_CRITICAL); err != nil {\n\t\t\t\tlogger.Println(\"Notification send failed\")\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbuildError = nil\n\t\tlogger.Printf(\"%sBuild finished%s\\n\", colorGreen, colorReset)\n\t\tif immediate {\n\t\t\trunner.Run()\n\t\t}\n\t\tif notifications {\n\t\t\tif err := notifier.Push(\"Build Succeded\", \"Build Finished!\", \"\", notificator.UR_CRITICAL); err != nil {\n\t\t\t\tlogger.Println(\"Notification send failed\")\n\t\t\t}\n\t\t}\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n}\n\ntype scanCallback func(path string)\n\nfunc scanChanges(watchPath string, excludeDirs []string, allFiles bool, cb scanCallback) {\n\tfor {\n\t\tfilepath.Walk(watchPath, func(path string, info os.FileInfo, err error) error {\n\t\t\tif path == \".git\" && info.IsDir() {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\tfor _, x := range excludeDirs {\n\t\t\t\tif x == path {\n\t\t\t\t\treturn filepath.SkipDir\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ignore hidden files\n\t\t\tif filepath.Base(path)[0] == '.' {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif (allFiles || filepath.Ext(path) == \".go\") && info.ModTime().After(startTime) {\n\t\t\t\tcb(path)\n\t\t\t\tstartTime = time.Now()\n\t\t\t\treturn errors.New(\"done\")\n\t\t\t}\n\n\t\t\treturn nil\n\t\t})\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n\nfunc shutdown(runner gin.Runner) {\n\tc := make(chan os.Signal, 2)\n\tsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\ts := <-c\n\t\tlog.Println(\"Got signal: \", s)\n\t\terr := runner.Kill()\n\t\tif err != nil {\n\t\t\tlog.Print(\"Error killing: \", err)\n\t\t}\n\t\tos.Exit(1)\n\t}()\n}\n"
        },
        {
          "name": "wercker.yml",
          "type": "blob",
          "size": 0.01953125,
          "content": "box: wercker/golang\n"
        }
      ]
    }
  ]
}