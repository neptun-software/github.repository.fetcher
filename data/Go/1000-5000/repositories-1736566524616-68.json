{
  "metadata": {
    "timestamp": 1736566524616,
    "page": 68,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gdamore/tcell",
      "stars": 4668,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 0.2685546875,
          "content": "version: 1.0.{build}\nclone_folder: c:\\gopath\\src\\github.com\\gdamore\\tcell\nenvironment:\n  GOPATH: c:\\gopath\nbuild_script:\n- go version\n- go env\n- SET PATH=%LOCALAPPDATA%\\atom\\bin;%GOPATH%\\bin;%PATH%\n- go get -t ./...\n- go build\n- go install ./...\ntest_script:\n- go test ./...\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0126953125,
          "content": "coverage.txt\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2373046875,
          "content": "language: go\n\ngo:\n  - 1.15.x\n  - master\n\narch:\n   - amd64\n   - ppc64le\n\nbefore_install:\n  - go get -t -v ./...\n\nscript:\n  - go test -race -coverprofile=coverage.txt -covermode=atomic\n\nafter_success:\n  - bash <(curl -s https://codecov.io/bash)\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.1513671875,
          "content": "Garrett D'Amore <garrett@damore.org>\nZachary Yedidia <zyedidia@gmail.com>\nJunegunn Choi <junegunn.c@gmail.com>\nStaysail Systems, Inc. <info@staysail.tech>\n"
        },
        {
          "name": "CHANGESv2.md",
          "type": "blob",
          "size": 3.3427734375,
          "content": "## Breaking Changes in _Tcell_ v2\n\nA number of changes were made to _Tcell_ for version two, and some of these are breaking.\n\n### Import Path\n\nThe import path for tcell has changed to `github.com/gdamore/tcell/v2` to reflect a new major version.\n\n### Style Is Not Numeric\n\nThe type `Style` has changed to a structure, to allow us to add additional data such as flags for color setting,\nmore attribute bits, and so forth.\nApplications that relied on this being a number will need to be updated to use the accessor methods.\n\n### Mouse Event Changes\n\nThe middle mouse button was reported as button 2 on Linux, but as button 3 on Windows,\nand the right mouse button was reported the reverse way.\n_Tcell_ now always reports the right mouse button as button 2, and the middle button as button 3.\nTo help make this clearer, new symbols `ButtonPrimary`, `ButtonSecondary`, and\n`ButtonMiddle` are provided.\n(Note that which button is right vs. left may be impacted by user preferences.\nUsually the left button will be considered the Primary, and the right will be the Secondary.)\nApplications may need to adjust their handling of mouse buttons 2 and 3 accordingly.\n\n### Terminals Removed\n\nA number of terminals have been removed.\nThese are mostly ancient definitions unlikely to be used by anyone, such as `adm3a`.\n\n### High Number Function Keys\n\nHistorically terminfo reported function keys with modifiers set as a different\nfunction key altogether.  For example, Shift-F1 was reported as F13 on XTerm.\n_Tcell_ now prefers to report these using the base key (such as F1) with modifiers added.\nThis works on XTerm and VTE based emulators, but some emulators may not support this.\nThe new behavior more closely aligns with behavior on Windows platforms.\n\n## New Features in _Tcell_ v2\n\nThese features are not breaking, but are introduced in version 2.\n\n### Improved Modifier Support\n\nFor terminals that appear to behave like the venerable XTerm, _tcell_\nautomatically adds modifier reporting for ALT, CTRL, SHIFT, and META keys\nwhen the terminal reports them.\n\n### Better Support for Palettes (Themes)\n\nWhen using a color by its name or palette entry, _Tcell_ now tries to\nuse that palette entry as is; this should avoid some inconsistency and respect\nterminal themes correctly.\n\nWhen true fidelity to RGB values is needed, the new `TrueColor()` API can be used\nto create a direct color, which bypasses the palette altogether.\n\n### Automatic TrueColor Detection\n\nFor some terminals, if the `Tc` or `RGB` properties are present in terminfo,\n_Tcell_ will automatically assume the terminal supports 24-bit color.\n\n### ColorReset\n\nA new color value, `ColorReset` can be used on the foreground or background\nto reset the color the default used by the terminal.\n\n### tmux Support\n\n_Tcell_ now has improved support for tmux, when the `$TERM` variable is set to \"tmux\".\n\n### Strikethrough Support\n\n_Tcell_ has support for strikethrough when the terminal supports it, using the new `StrikeThrough()` API.\n\n### Bracketed Paste Support\n\n_Tcell_ provides the long requested capability to discriminate paste event by using the\nbracketed-paste capability present in some terminals.  This is automatically available on\nterminals that support XTerm style mouse handling, but applications must opt-in to this\nby using the new `EnablePaste()` function.  A new `EventPaste` type of event will be\ndelivered when starting and finishing a paste operation."
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README-wasm.md",
          "type": "blob",
          "size": 1.6787109375,
          "content": "# WASM for _Tcell_\n\nYou can build _Tcell_ project into a webpage by compiling it slightly differently. This will result in a _Tcell_ project you can embed into another html page, or use as a standalone page.\n\n## Building your project\n\nWASM needs special build flags in order to work. You can build it by executing\n```sh\nGOOS=js GOARCH=wasm go build -o yourfile.wasm\n```\n\n## Additional files\n\nYou also need 5 other files in the same directory as the wasm. Four (`tcell.html`, `tcell.js`, `termstyle.css`, and `beep.wav`) are provided in the `webfiles` directory. The last one, `wasm_exec.js`, can be copied from GOROOT into the current directory by executing\n```sh\ncp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" ./\n```\n\nIn `tcell.js`, you also need to change the constant\n```js\nconst wasmFilePath = \"yourfile.wasm\"\n```\nto the file you outputted to when building.\n\n## Displaying your project\n\n### Standalone\n\nYou can see the project (with an white background around the terminal) by serving the directory. You can do this using any framework, including another golang project:\n\n```golang\n// server.go\n\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tlog.Fatal(http.ListenAndServe(\":8080\",\n\t\thttp.FileServer(http.Dir(\"/path/to/dir/to/serve\")),\n\t))\n}\n\n```\n\nTo see the webpage with this example, you can type in `localhost:8080/tcell.html` into your browser while `server.go` is running.\n\n### Embedding\nIt is recommended to use an iframe if you want to embed the app into a webpage:\n```html\n<iframe src=\"tcell.html\" title=\"Tcell app\"></iframe>\n```\n\n## Other considerations\n\n### Accessing files\n\n`io.Open(filename)` and other related functions for reading file systems do not work; use `http.Get(filename)` instead."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.626953125,
          "content": "<img src=\"logos/tcell.png\" style=\"float: right\"/>\n\n# Tcell\n\n_Tcell_ is a _Go_ package that provides a cell based view for text terminals, like _XTerm_.\nIt was inspired by _termbox_, but includes many additional improvements.\n\n[![Stand With Ukraine](https://raw.githubusercontent.com/vshymanskyy/StandWithUkraine/main/badges/StandWithUkraine.svg)](https://stand-with-ukraine.pp.ua)\n[![Linux](https://img.shields.io/github/actions/workflow/status/gdamore/tcell/linux.yml?branch=main&logoColor=grey&logo=linux&label=)](https://github.com/gdamore/tcell/actions/workflows/linux.yml)\n[![Windows](https://img.shields.io/github/actions/workflow/status/gdamore/tcell/windows.yml?branch=main&logoColor=grey&logo=windows&label=)](https://github.com/gdamore/tcell/actions/workflows/windows.yml)\n[![Apache License](https://img.shields.io/github/license/gdamore/tcell.svg?logoColor=silver&logo=opensourceinitiative&color=blue&label=)](https://github.com/gdamore/tcell/blob/master/LICENSE)\n[![Docs](https://img.shields.io/badge/godoc-reference-blue.svg?label=&logo=go)](https://pkg.go.dev/github.com/gdamore/tcell/v2)\n[![Discord](https://img.shields.io/discord/639503822733180969?label=&logo=discord)](https://discord.gg/urTTxDN)\n[![Coverage](https://img.shields.io/codecov/c/github/gdamore/tcell?logoColor=grey&logo=codecov&label=)](https://codecov.io/gh/gdamore/tcell)\n[![Go Report Card](https://goreportcard.com/badge/github.com/gdamore/tcell/v2)](https://goreportcard.com/report/github.com/gdamore/tcell/v2)\n\nPlease see [here](UKRAINE.md) for an important message for the people of Russia.\n\nNOTE: This is version 2 of _Tcell_. There are breaking changes relative to version 1.\nVersion 1.x remains available using the import `github.com/gdamore/tcell`.\n\n## Tutorial\n\nA brief, and still somewhat rough, [tutorial](TUTORIAL.md) is available.\n\n## Examples\n\n- [proxima5](https://github.com/gdamore/proxima5) - space shooter ([video](https://youtu.be/jNxKTCmY_bQ))\n- [govisor](https://github.com/gdamore/govisor) - service management UI ([screenshot](http://2.bp.blogspot.com/--OsvnfzSNow/Vf7aqMw3zXI/AAAAAAAAARo/uOMtOvw4Sbg/s1600/Screen%2BShot%2B2015-09-20%2Bat%2B9.08.41%2BAM.png))\n- mouse demo - included mouse test ([screenshot](http://2.bp.blogspot.com/-fWvW5opT0es/VhIdItdKqJI/AAAAAAAAATE/7Ojc0L1SpB0/s1600/Screen%2BShot%2B2015-10-04%2Bat%2B11.47.13%2BPM.png))\n- [gomatrix](https://github.com/gdamore/gomatrix) - converted from Termbox\n- [micro](https://github.com/zyedidia/micro/) - lightweight text editor with syntax-highlighting and themes\n- [godu](https://github.com/viktomas/godu) - utility to discover large files/folders\n- [tview](https://github.com/rivo/tview/) - rich interactive widgets\n- [cview](https://code.rocketnine.space/tslocum/cview) - user interface toolkit (fork of _tview_)\n- [awesome gocui](https://github.com/awesome-gocui/gocui) - Go Console User Interface\n- [gomandelbrot](https://github.com/rgm3/gomandelbrot) - Mandelbrot!\n- [WTF](https://github.com/senorprogrammer/wtf) - personal information dashboard\n- [browsh](https://github.com/browsh-org/browsh) - modern web browser ([video](https://www.youtube.com/watch?v=HZq86XfBoRo))\n- [go-life](https://github.com/sachaos/go-life) - Conway's Game of Life\n- [gowid](https://github.com/gcla/gowid) - compositional widgets for terminal UIs, inspired by _urwid_\n- [termshark](https://termshark.io) - interface for _tshark_, inspired by Wireshark, built on _gowid_\n- [go-tetris](https://github.com/MichaelS11/go-tetris) - Go Tetris with AI option\n- [fzf](https://github.com/junegunn/fzf) - command-line fuzzy finder\n- [ascii-fluid](https://github.com/esimov/ascii-fluid) - fluid simulation controlled by webcam\n- [cbind](https://code.rocketnine.space/tslocum/cbind) - key event encoding, decoding and handling\n- [tpong](https://github.com/spinzed/tpong) - old-school Pong\n- [aerc](https://git.sr.ht/~sircmpwn/aerc) - email client\n- [tblogs](https://github.com/ezeoleaf/tblogs) - development blogs reader\n- [spinc](https://github.com/lallassu/spinc) - _irssi_ inspired chat application for Cisco Spark/WebEx\n- [gorss](https://github.com/lallassu/gorss) - RSS/Atom feed reader\n- [memoryalike](https://github.com/Bios-Marcel/memoryalike) - memorization game\n- [lf](https://github.com/gokcehan/lf) - file manager\n- [goful](https://github.com/anmitsu/goful) - CUI file manager\n- [gokeybr](https://github.com/bunyk/gokeybr) - deliberately practice your typing\n- [gonano](https://github.com/jbaramidze/gonano) - editor, mimics _nano_\n- [uchess](https://github.com/tmountain/uchess) - UCI chess client\n- [min](https://github.com/a-h/min) - Gemini browser\n- [ov](https://github.com/noborus/ov) - file pager\n- [tmux-wormhole](https://github.com/gcla/tmux-wormhole) - _tmux_ plugin to transfer files\n- [gruid-tcell](https://github.com/anaseto/gruid-tcell) - driver for the grid based UI and game framework\n- [aretext](https://github.com/aretext/aretext) - minimalist text editor with _vim_ key bindings\n- [sync](https://github.com/kyprifog/sync) - GitHub repo synchronization tool\n- [statusbar](https://github.com/kyprifog/statusbar) - statusbar motivation tool for tracking periodic tasks/goals\n- [todo](https://github.com/kyprifog/todo) - simple todo app\n- [gosnakego](https://github.com/liweiyi88/gosnakego) - a snake game\n- [gbb](https://github.com/sdemingo/gbb) - A classical bulletin board app for tildes or public unix servers\n- [lil](https://github.com/andrievsky/lil) - A simple and flexible interface for any service by implementing only list and get operations\n- [hero.go](https://github.com/barisbll/hero.go) - 2d monster shooter ([video](https://user-images.githubusercontent.com/40062673/277157369-240d7606-b471-4aa1-8c54-4379a513122b.mp4))\n- [go-tetris](https://github.com/aaronriekenberg/go-tetris) - simple tetris game for native terminal and WASM using github actions+pages\n- [oddshub](https://github.com/dos-2/oddshub) - A TUI designed for analyzing sports betting odds\n\n## Pure Go Terminfo Database\n\n_Tcell_ includes a full parser and expander for terminfo capability strings,\nso that it can avoid hard coding escape strings for formatting. It also favors\nportability, and includes support for all POSIX systems.\n\nThe database is also flexible & extensible, and can be modified by either running\na program to build the entire database, or an entry for just a single terminal.\n\n## More Portable\n\n_Tcell_ is portable to a wide variety of systems, and is pure Go, without\nany need for CGO.\n_Tcell_ is believed to work with mainstream systems officially supported by golang.\n\n## No Async IO\n\n_Tcell_ is able to operate without requiring `SIGIO` signals (unlike _termbox_),\nor asynchronous I/O, and can instead use standard Go file objects and Go routines.\nThis means it should be safe, especially for\nuse with programs that use exec, or otherwise need to manipulate the tty streams.\nThis model is also much closer to idiomatic Go, leading to fewer surprises.\n\n## Rich Unicode & non-Unicode support\n\n_Tcell_ includes enhanced support for Unicode, including wide characters and\ncombining characters, provided your terminal can support them.\nNote that\nWindows terminals generally don't support the full Unicode repertoire.\n\nIt will also convert to and from Unicode locales, so that the program\ncan work with UTF-8 internally, and get reasonable output in other locales.\n_Tcell_ tries hard to convert to native characters on both input and output.\nOn output _Tcell_ even makes use of the alternate character set to facilitate\ndrawing certain characters.\n\n## More Function Keys\n\n_Tcell_ also has richer support for a larger number of special keys that some\nterminals can send.\n\n## Better Color Handling\n\n_Tcell_ will respect your terminal's color space as specified within your terminfo entries.\nFor example attempts to emit color sequences on VT100 terminals\nwon't result in unintended consequences.\n\nIn legacy Windows mode, _Tcell_ supports 16 colors, bold, dim, and reverse,\ninstead of just termbox's 8 colors with reverse. (Note that there is some\nconflation with bold/dim and colors.)\nModern Windows 10 can benefit from much richer colors however.\n\n_Tcell_ maps 16 colors down to 8, for terminals that need it.\n(The upper 8 colors are just brighter versions of the lower 8.)\n\n## Better Mouse Support\n\n_Tcell_ supports enhanced mouse tracking mode, so your application can receive\nregular mouse motion events, and wheel events, if your terminal supports it.\n\n(Note: The Windows 10 Terminal application suffers from a flaw in this regard,\nand does not support mouse interaction. The stock Windows 10 console host\nfired up with cmd.exe or PowerShell works fine however.)\n\n## _Termbox_ Compatibility\n\nA compatibility layer for _termbox_ is provided in the `compat` directory.\nTo use it, try importing `github.com/gdamore/tcell/termbox` instead.\nMost _termbox-go_ programs will probably work without further modification.\n\n## Working With Unicode\n\nInternally _Tcell_ uses UTF-8, just like Go.\nHowever, _Tcell_ understands how to\nconvert to and from other character sets, using the capabilities of\nthe `golang.org/x/text/encoding` packages.\nYour application must supply\nthem, as the full set of the most common ones bloats the program by about 2 MB.\nIf you're lazy, and want them all anyway, see the `encoding` sub-directory.\n\n## Wide & Combining Characters\n\nThe `SetContent()` API takes a primary rune, and an optional list of combining runes.\nIf any of the runes is a wide (East Asian) rune occupying two cells,\nthen the library will skip output from the following cell. Care must be\ntaken in the application to avoid explicitly attempting to set content in the\nnext cell, otherwise the results are undefined. (Normally the wide character\nis displayed, and the other character is not; do not depend on that behavior.)\n\nOlder terminal applications (especially on systems like Windows 8) lack support\nfor advanced Unicode, and thus may not fare well.\n\n## Colors\n\n_Tcell_ assumes the ANSI/XTerm color model, including the 256 color map that\nXTerm uses when it supports 256 colors. The terminfo guidance will be\nhonored, with respect to the number of colors supported. Also, only\nterminals which expose ANSI style `setaf` and `setab` will support color;\nif you have a color terminal that only has `setf` and `setb`, please submit\na ticket.\n\n## 24-bit Color\n\n_Tcell_ _supports 24-bit color!_ (That is, if your terminal can support it.)\n\nNOTE: Technically the approach of using 24-bit RGB values for color is more\naccurately described as \"direct color\", but most people use the term \"true color\".\nWe follow the (inaccurate) common convention.\n\nThere are a few ways you can enable (or disable) true color.\n\n- For many terminals, we can detect it automatically if your terminal\n  includes the `RGB` or `Tc` capabilities (or rather it did when the database\n  was updated.)\n\n- You can force this one by setting the `COLORTERM` environment variable to\n  `24-bit`, `truecolor` or `24bit`. This is the same method used\n  by most other terminal applications that support 24-bit color.\n\n- If you set your `TERM` environment variable to a value with the suffix `-truecolor`\n  then 24-bit color compatible with XTerm and ECMA-48 will be assumed.\n  (This feature is deprecated.\n  It is recommended to use one of other methods listed above.)\n\n- You can disable 24-bit color by setting `TCELL_TRUECOLOR=disable` in your\n  environment.\n\nWhen using TrueColor, programs will display the colors that the programmer\nintended, overriding any \"`themes`\" you may have set in your terminal\nemulator. (For some cases, accurate color fidelity is more important\nthan respecting themes. For other cases, such as typical text apps that\nonly use a few colors, its more desirable to respect the themes that\nthe user has established.)\n\n## Performance\n\nReasonable attempts have been made to minimize sending data to terminals,\navoiding repeated sequences or drawing the same cell on refresh updates.\n\n## Terminfo\n\n(Not relevant for Windows users.)\n\nThe Terminfo implementation operates with a built-in database.\nThis should satisfy most users. However, it can also (on systems\nwith ncurses installed), dynamically parse the output from `infocmp`\nfor terminals it does not already know about.\n\nSee the `terminfo/` directory for more information about generating\nnew entries for the built-in database.\n\n_Tcell_ requires that the terminal support the `cup` mode of cursor addressing.\nAncient terminals without the ability to position the cursor directly\nare not supported.\nThis is unlikely to be a problem; such terminals have not been mass-produced\nsince the early 1970s.\n\n## Mouse Support\n\nMouse support is detected via the `kmous` terminfo variable, however,\nenablement/disablement and decoding mouse events is done using hard coded\nsequences based on the XTerm X11 model. All popular\nterminals with mouse tracking support this model. (Full terminfo support\nis not possible as terminfo sequences are not defined.)\n\nOn Windows, the mouse works normally.\n\nMouse wheel buttons on various terminals are known to work, but the support\nin terminal emulators, as well as support for various buttons and\nlive mouse tracking, varies widely.\nModern _xterm_, macOS _Terminal_, and _iTerm_ all work well.\n\n## Bracketed Paste\n\nTerminals that appear to support the XTerm mouse model also can support\nbracketed paste, for applications that opt-in. See `EnablePaste()` for details.\n\n## Testability\n\nThere is a `SimulationScreen`, that can be used to simulate a real screen\nfor automated testing. The supplied tests do this. The simulation contains\nevent delivery, screen resizing support, and capabilities to inject events\nand examine \"`physical`\" screen contents.\n\n## Platforms\n\n### POSIX (Linux, FreeBSD, macOS, Solaris, etc.)\n\nEverything works using pure Go on mainstream platforms. Some more esoteric\nplatforms (e.g., AIX) may need to be added. Pull requests are welcome!\n\n### Windows\n\nWindows console mode applications are supported.\n\nModern console applications like ConEmu and the Windows 10 terminal,\nsupport all the good features (resize, mouse tracking, etc.)\n\n### WASM\n\nWASM is supported, but needs additional setup detailed in [README-wasm](README-wasm.md).\n\n### Plan9 and others\n\nThese platforms won't work, but compilation stubs are supplied\nfor folks that want to include parts of this in software for those\nplatforms. The Simulation screen works, but as _Tcell_ doesn't know how to\nallocate a real screen object on those platforms, `NewScreen()` will fail.\n\nIf anyone has wisdom about how to improve support for these,\nplease let me know. PRs are especially welcome.\n\n### Commercial Support\n\n_Tcell_ is absolutely free, but if you want to obtain commercial, professional support, there are options.\n\n- [TideLift](https://tidelift.com/) subscriptions include support for _Tcell_, as well as many other open source packages.\n- [Staysail Systems Inc.](mailto:info@staysail.tech) offers direct support, and custom development around _Tcell_ on an hourly basis.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.4873046875,
          "content": "# SECURITY\n\nIt's somewhat unlikely that tcell is in a security sensitive path,\nbut we do take security seriously.\n\n## Vulnerabilityu Response\n\nIf you report a vulnerability, we will respond within 2 business days.\n\n## Report a Vulnerability\n\nIf you wish to report a vulnerability found in tcell, simply send a message\nto garrett@damore.org.  You may also reach us on our discord channel -\nhttps://discord.gg/urTTxDN - a private message to `gdamore` on that channel\nmay be submitted instead of mail.\n"
        },
        {
          "name": "TUTORIAL.md",
          "type": "blob",
          "size": 7.744140625,
          "content": "# _Tcell_ Tutorial\n\n_Tcell_ provides a low-level, portable API for building terminal-based programs.\nA [terminal emulator](https://en.wikipedia.org/wiki/Terminal_emulator)\n(or a real terminal such as a DEC VT-220) is used to interact with such a program.\n\n_Tcell_'s interface is fairly low-level.\nWhile it provides a reasonably portable way of dealing with all the usual terminal\nfeatures, it may be easier to utilize a higher level framework.\nA number of such frameworks are listed on the _Tcell_ main [README](README.md).\n\nThis tutorial provides the details of _Tcell_, and is appropriate for developers\nwishing to create their own application frameworks or needing more direct access\nto the terminal capabilities.\n\n## Resize events\n\nApplications receive an event of type `EventResize` when they are first initialized and each time the terminal is resized.\nThe new size is available as `Size`.\n\n```go\nswitch ev := ev.(type) {\ncase *tcell.EventResize:\n\tw, h := ev.Size()\n\tlogMessage(fmt.Sprintf(\"Resized to %dx%d\", w, h))\n}\n```\n\n## Key events\n\nWhen a key is pressed, applications receive an event of type `EventKey`.\nThis event describes the modifier keys pressed (if any) and the pressed key or rune.\n\nWhen a rune key is pressed, an event with its `Key` set to `KeyRune` is dispatched.\n\nWhen a non-rune key is pressed, it is available as the `Key` of the event.\n\n```go\nswitch ev := ev.(type) {\ncase *tcell.EventKey:\n    mod, key, ch := ev.Mod(), ev.Key(), ev.Rune()\n    logMessage(fmt.Sprintf(\"EventKey Modifiers: %d Key: %d Rune: %d\", mod, key, ch))\n}\n```\n\n### Key event restrictions\n\nTerminal-based programs have less visibility into keyboard activity than graphical applications.\n\nWhen a key is pressed and held, additional key press events are sent by the terminal emulator.\nThe rate of these repeated events depends on the emulator's configuration.\nKey release events are not available.\n\nIt is not possible to distinguish runes typed while holding shift and runes typed using caps lock.\nCapital letters are reported without the Shift modifier.\n\n## Mouse events\n\nApplications receive an event of type `EventMouse` when the mouse moves, or a mouse button is pressed or released.\nMouse events are only delivered if\n`EnableMouse` has been called.\n\nThe mouse buttons being pressed (if any) are available as `Buttons`, and the position of the mouse is available as `Position`.\n\n```go\nswitch ev := ev.(type) {\ncase *tcell.EventMouse:\n\tmod := ev.Modifiers()\n\tbtns := ev.Buttons()\n\tx, y := ev.Position()\n\tlogMessage(fmt.Sprintf(\"EventMouse Modifiers: %d Buttons: %d Position: %d,%d\", mod, btns, x, y))\n}\n```\n\n### Mouse buttons\n\nIdentifier | Alias           | Description\n-----------|-----------------|-----------\nButton1    | ButtonPrimary   | Left button\nButton2    | ButtonSecondary | Right button\nButton3    | ButtonMiddle    | Middle button\nButton4    |                 | Side button (thumb/next)\nButton5    |                 | Side button (thumb/prev)\nWheelUp    |                 | Scroll wheel up\nWheelDown  |                 | Scroll wheel down\nWheelLeft  |                 | Horizontal wheel left\nWheelRight |                 | Horizontal wheel right\n\n## Usage\n\nTo create a _Tcell_ application, first initialize a screen to hold it.\n\n```go\ns, err := tcell.NewScreen()\nif err != nil {\n\tlog.Fatalf(\"%+v\", err)\n}\nif err := s.Init(); err != nil {\n\tlog.Fatalf(\"%+v\", err)\n}\n\n// Set default text style\ndefStyle := tcell.StyleDefault.Background(tcell.ColorReset).Foreground(tcell.ColorReset)\ns.SetStyle(defStyle)\n\n// Clear screen\ns.Clear()\n```\n\nText may be drawn on the screen using `SetContent`.\n\n```go\ns.SetContent(0, 0, 'H', nil, defStyle)\ns.SetContent(1, 0, 'i', nil, defStyle)\ns.SetContent(2, 0, '!', nil, defStyle)\n```\n\nTo draw text more easily, define a render function.\n\n```go\nfunc drawText(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {\n\trow := y1\n\tcol := x1\n\tfor _, r := range []rune(text) {\n\t\ts.SetContent(col, row, r, nil, style)\n\t\tcol++\n\t\tif col >= x2 {\n\t\t\trow++\n\t\t\tcol = x1\n\t\t}\n\t\tif row > y2 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\nLastly, define an event loop to handle user input and update application state.\n\n```go\nquit := func() {\n    s.Fini()\n    os.Exit(0)\n}\nfor {\n    // Update screen\n    s.Show()\n\n    // Poll event\n    ev := s.PollEvent()\n\n    // Process event\n    switch ev := ev.(type) {\n    case *tcell.EventResize:\n        s.Sync()\n    case *tcell.EventKey:\n        if ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {\n            quit()\n        }\n    }\n}\n```\n\n## Demo application\n\nThe following demonstrates how to initialize a screen, draw text/graphics and handle user input.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\nfunc drawText(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {\n\trow := y1\n\tcol := x1\n\tfor _, r := range []rune(text) {\n\t\ts.SetContent(col, row, r, nil, style)\n\t\tcol++\n\t\tif col >= x2 {\n\t\t\trow++\n\t\t\tcol = x1\n\t\t}\n\t\tif row > y2 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc drawBox(s tcell.Screen, x1, y1, x2, y2 int, style tcell.Style, text string) {\n\tif y2 < y1 {\n\t\ty1, y2 = y2, y1\n\t}\n\tif x2 < x1 {\n\t\tx1, x2 = x2, x1\n\t}\n\n\t// Fill background\n\tfor row := y1; row <= y2; row++ {\n\t\tfor col := x1; col <= x2; col++ {\n\t\t\ts.SetContent(col, row, ' ', nil, style)\n\t\t}\n\t}\n\n\t// Draw borders\n\tfor col := x1; col <= x2; col++ {\n\t\ts.SetContent(col, y1, tcell.RuneHLine, nil, style)\n\t\ts.SetContent(col, y2, tcell.RuneHLine, nil, style)\n\t}\n\tfor row := y1 + 1; row < y2; row++ {\n\t\ts.SetContent(x1, row, tcell.RuneVLine, nil, style)\n\t\ts.SetContent(x2, row, tcell.RuneVLine, nil, style)\n\t}\n\n\t// Only draw corners if necessary\n\tif y1 != y2 && x1 != x2 {\n\t\ts.SetContent(x1, y1, tcell.RuneULCorner, nil, style)\n\t\ts.SetContent(x2, y1, tcell.RuneURCorner, nil, style)\n\t\ts.SetContent(x1, y2, tcell.RuneLLCorner, nil, style)\n\t\ts.SetContent(x2, y2, tcell.RuneLRCorner, nil, style)\n\t}\n\n\tdrawText(s, x1+1, y1+1, x2-1, y2-1, style, text)\n}\n\nfunc main() {\n\tdefStyle := tcell.StyleDefault.Background(tcell.ColorReset).Foreground(tcell.ColorReset)\n\tboxStyle := tcell.StyleDefault.Foreground(tcell.ColorWhite).Background(tcell.ColorPurple)\n\n\t// Initialize screen\n\ts, err := tcell.NewScreen()\n\tif err != nil {\n\t\tlog.Fatalf(\"%+v\", err)\n\t}\n\tif err := s.Init(); err != nil {\n\t\tlog.Fatalf(\"%+v\", err)\n\t}\n\ts.SetStyle(defStyle)\n\ts.EnableMouse()\n\ts.EnablePaste()\n\ts.Clear()\n\n\t// Draw initial boxes\n\tdrawBox(s, 1, 1, 42, 7, boxStyle, \"Click and drag to draw a box\")\n\tdrawBox(s, 5, 9, 32, 14, boxStyle, \"Press C to reset\")\n\n\tquit := func() {\n\t\t// You have to catch panics in a defer, clean up, and\n\t\t// re-raise them - otherwise your application can\n\t\t// die without leaving any diagnostic trace.\n\t\tmaybePanic := recover()\n\t\ts.Fini()\n\t\tif maybePanic != nil {\n\t\t\tpanic(maybePanic)\n\t\t}\n\t}\n\tdefer quit()\n\n\t// Here's how to get the screen size when you need it.\n\t// xmax, ymax := s.Size()\n\n\t// Here's an example of how to inject a keystroke where it will\n\t// be picked up by the next PollEvent call.  Note that the\n\t// queue is LIFO, it has a limited length, and PostEvent() can\n\t// return an error.\n\t// s.PostEvent(tcell.NewEventKey(tcell.KeyRune, rune('a'), 0))\n\n\t// Event loop\n\tox, oy := -1, -1\n\tfor {\n\t\t// Update screen\n\t\ts.Show()\n\n\t\t// Poll event\n\t\tev := s.PollEvent()\n\n\t\t// Process event\n\t\tswitch ev := ev.(type) {\n\t\tcase *tcell.EventResize:\n\t\t\ts.Sync()\n\t\tcase *tcell.EventKey:\n\t\t\tif ev.Key() == tcell.KeyEscape || ev.Key() == tcell.KeyCtrlC {\n\t\t\t\treturn\n\t\t\t} else if ev.Key() == tcell.KeyCtrlL {\n\t\t\t\ts.Sync()\n\t\t\t} else if ev.Rune() == 'C' || ev.Rune() == 'c' {\n\t\t\t\ts.Clear()\n\t\t\t}\n\t\tcase *tcell.EventMouse:\n\t\t\tx, y := ev.Position()\n\n\t\t\tswitch ev.Buttons() {\n\t\t\tcase tcell.Button1, tcell.Button2:\n\t\t\t\tif ox < 0 {\n\t\t\t\t\tox, oy = x, y // record location when click started\n\t\t\t\t}\n\n\t\t\tcase tcell.ButtonNone:\n\t\t\t\tif ox >= 0 {\n\t\t\t\t\tlabel := fmt.Sprintf(\"%d,%d to %d,%d\", ox, oy, x, y)\n\t\t\t\t\tdrawBox(s, ox, oy, x, y, boxStyle, label)\n\t\t\t\t\tox, oy = -1, -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n"
        },
        {
          "name": "UKRAINE.md",
          "type": "blob",
          "size": 5.26171875,
          "content": "# Ukraine, Russia, and a World Tragedy\n\n## A message to those inside Russia\n\n### Written March 4, 2022.\n\nIt is with a very heavy heart that I write this.  I am normally opposed to the use of open source\nprojects to communicate political positions or advocate for things outside the immediate relevancy\nto that project.\n\nHowever, the events occurring in Ukraine, and specifically the unprecedented invasion of Ukraine by\nRussian forces operating under orders from Russian President Vladimir Putin compel me to speak out.\n\nThose who know me, know that I have family, friends, and colleagues in Russia, and Ukraine both.  My closest friends\nhave historically been Russian friends my wife's hometown of Chelyabinsk.  I myself have in the past\nfrequently traveled to Russia, and indeed operated a software development firm with offices in St. Petersburg.\nI had a special kinship with Russia and its people.\n\nI say \"had\", because I fear that the actions of Putin, and the massive disinformation campaign that his regime\nhas waged inside Russia, mean that it's likely that I won't see those friends again.  At present, I'm not sure\nmy wife will see her own mother again.  We no longer feel it's safe for either of us to return Russia given\nactions taken by the regime to crack down on those who express disagreement.\n\nRussian citizens are being led to believe it is acting purely defensively, and that only legitimate military\ntargets are being targeted, and that all the information we have received in the West are fakes.\n\nI am confident that nothing could be further from the truth.\n\nThis has caused many in Russia, including people whom I respect and believe to be smarter than this, to\nstand by Putin, and endorse his actions. The claim is that the entirety of NATO is operating at the behest\nof the USA, and that the entirety of Europe was poised to attack Russia. While this is clearly absurd to those\nof us with any understanding of western politics, Russian citizens are being fed this lie, and believing it.\n\nIf you're reading this from inside Russia -- YOU are the person that I hope this message reaches.  Your\ngovernment is LYING to you.  Of course, all governments lie all the time.  But consider this.  Almost the\nentire world has condemned the invasion of Ukraine as criminal, and has applied sanctions.  Even countries\nwhich have poor relations with the US sanctioning Russia, as well as nations which historically have remained\nneutral.  (Famously neutral -- even during World War II, Switzerland has acted to apply sanctions in\nconcert with the rest of the world.)\n\nAsk yourself, why does Putin fear a free press so much, if what he says is true?  Why the crack-downs on\nchildren expressing only a desire for peace with Ukraine?  Why would the entire world unified against him,\nif Putin was in the right?  Why would the only countries that stood with Russia against\nthe UN resolution to condemn these acts as crimes be Belarus, North Korea, and Syria?  Even countries normally\nallied to Russia could not bring themselves to do more than abstain from the vote to condemn it.\n\nTo be clear, I do not claim that the actions taken by the West or by the Ukrainian government were completely\nblameless.  On the contrary, I understand that Western media is biased, and the truth is rarely exactly\nas reported.  I believe that there is a kernel of truth in the claims of fascists and ultra-nationalist\nmilitias operating in Ukraine and specifically Donbas.  However, I am also equally certain that Putin's\nresponse is out of proportion, and that concerns about such militias are principally just a pretext to justify\nan invasion.\n\nEurope is at war, unlike we've seen in my lifetime.  The world is more divided, and closer to nuclear holocaust\nthan it has been since the Cold War. And that is 100% the fault of Putin.\n\nWhile Putin remains in power, there cannot really be any way for Russian international relations to return\nto normal. Putin has set your country on a path to return to the Cold War, likely because he fancies himself\nto be a new Stalin.  However, unlike the Soviet Union, the Russian economy does not have the wherewithal to\nstand on its own, and the invasion of Ukraine has fully ensured that Russia will not find any friends anywhere\nelse in Europe, and probably few places in Asia.\n\nThe *only* paths forward for Russia are either a Russia without Putin (and those who would support his agenda),\nor a complete breakdown of Russian prosperity, likely followed by the increasing international conflict that will\nbe the natural escalation from a country that is isolated and impoverished. Those of us observing from the West are\ngravely concerned, because we cannot see any end to this madness that does not result in nuclear conflict,\nunless from within.\n\nIn the meantime, the worst prices will be paid for by innocents in Ukraine, and by young Russian mean\nforced to carry out the orders of Putin's corrupt regime.\n\nAnd *that* is why I write this -- to appeal to those within Russia to open your eyes, and think with\nyour minds.  It is right and proper to be proud of your country and its rich heritage.  But it is also\nright and proper to look for ways to save it from the ruinous path that its current leadership has set it upon,\nand to recognize when that leadership is no longer acting in interest of the country or its people.\n\n  - Garrett D'Amore, March 4, 2022"
        },
        {
          "name": "_demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "attr.go",
          "type": "blob",
          "size": 1.2265625,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\n// AttrMask represents a mask of text attributes, apart from color.\n// Note that support for attributes may vary widely across terminals.\ntype AttrMask int\n\n// Attributes are not colors, but affect the display of text.  They can\n// be combined, in some cases, but not others. (E.g. you can have Dim Italic,\n// but only CurlyUnderline cannot be mixed with DottedUnderline.)\nconst (\n\tAttrBold AttrMask = 1 << iota\n\tAttrBlink\n\tAttrReverse\n\tAttrUnderline // Deprecated: Use UnderlineStyle\n\tAttrDim\n\tAttrItalic\n\tAttrStrikeThrough\n\tAttrInvalid AttrMask = 1 << 31 // Mark the style or attributes invalid\n\tAttrNone    AttrMask = 0       // Just normal text.\n)\n"
        },
        {
          "name": "cell.go",
          "type": "blob",
          "size": 6.6474609375,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"os\"\n\t\"reflect\"\n\n\trunewidth \"github.com/mattn/go-runewidth\"\n)\n\ntype cell struct {\n\tcurrMain  rune\n\tcurrComb  []rune\n\tcurrStyle Style\n\tlastMain  rune\n\tlastStyle Style\n\tlastComb  []rune\n\twidth     int\n\tlock      bool\n}\n\n// CellBuffer represents a two-dimensional array of character cells.\n// This is primarily intended for use by Screen implementors; it\n// contains much of the common code they need.  To create one, just\n// declare a variable of its type; no explicit initialization is necessary.\n//\n// CellBuffer is not thread safe.\ntype CellBuffer struct {\n\tw     int\n\th     int\n\tcells []cell\n}\n\n// SetContent sets the contents (primary rune, combining runes,\n// and style) for a cell at a given location.  If the background or\n// foreground of the style is set to ColorNone, then the respective\n// color is left un changed.\nfunc (cb *CellBuffer) SetContent(x int, y int,\n\tmainc rune, combc []rune, style Style,\n) {\n\tif x >= 0 && y >= 0 && x < cb.w && y < cb.h {\n\t\tc := &cb.cells[(y*cb.w)+x]\n\n\t\t// Wide characters: we want to mark the \"wide\" cells\n\t\t// dirty as well as the base cell, to make sure we consider\n\t\t// both cells as dirty together.  We only need to do this\n\t\t// if we're changing content\n\t\tif (c.width > 0) && (mainc != c.currMain || len(combc) != len(c.currComb) || (len(combc) > 0 && !reflect.DeepEqual(combc, c.currComb))) {\n\t\t\tfor i := 0; i < c.width; i++ {\n\t\t\t\tcb.SetDirty(x+i, y, true)\n\t\t\t}\n\t\t}\n\n\t\tc.currComb = append([]rune{}, combc...)\n\n\t\tif c.currMain != mainc {\n\t\t\tc.width = runewidth.RuneWidth(mainc)\n\t\t}\n\t\tc.currMain = mainc\n\t\tif style.fg == ColorNone {\n\t\t\tstyle.fg = c.currStyle.fg\n\t\t}\n\t\tif style.bg == ColorNone {\n\t\t\tstyle.bg = c.currStyle.bg\n\t\t}\n\t\tc.currStyle = style\n\t}\n}\n\n// GetContent returns the contents of a character cell, including the\n// primary rune, any combining character runes (which will usually be\n// nil), the style, and the display width in cells.  (The width can be\n// either 1, normally, or 2 for East Asian full-width characters.)\nfunc (cb *CellBuffer) GetContent(x, y int) (rune, []rune, Style, int) {\n\tvar mainc rune\n\tvar combc []rune\n\tvar style Style\n\tvar width int\n\tif x >= 0 && y >= 0 && x < cb.w && y < cb.h {\n\t\tc := &cb.cells[(y*cb.w)+x]\n\t\tmainc, combc, style = c.currMain, c.currComb, c.currStyle\n\t\tif width = c.width; width == 0 || mainc < ' ' {\n\t\t\twidth = 1\n\t\t\tmainc = ' '\n\t\t}\n\t}\n\treturn mainc, combc, style, width\n}\n\n// Size returns the (width, height) in cells of the buffer.\nfunc (cb *CellBuffer) Size() (int, int) {\n\treturn cb.w, cb.h\n}\n\n// Invalidate marks all characters within the buffer as dirty.\nfunc (cb *CellBuffer) Invalidate() {\n\tfor i := range cb.cells {\n\t\tcb.cells[i].lastMain = rune(0)\n\t}\n}\n\n// Dirty checks if a character at the given location needs to be\n// refreshed on the physical display.  This returns true if the cell\n// content is different since the last time it was marked clean.\nfunc (cb *CellBuffer) Dirty(x, y int) bool {\n\tif x >= 0 && y >= 0 && x < cb.w && y < cb.h {\n\t\tc := &cb.cells[(y*cb.w)+x]\n\t\tif c.lock {\n\t\t\treturn false\n\t\t}\n\t\tif c.lastMain == rune(0) {\n\t\t\treturn true\n\t\t}\n\t\tif c.lastMain != c.currMain {\n\t\t\treturn true\n\t\t}\n\t\tif c.lastStyle != c.currStyle {\n\t\t\treturn true\n\t\t}\n\t\tif len(c.lastComb) != len(c.currComb) {\n\t\t\treturn true\n\t\t}\n\t\tfor i := range c.lastComb {\n\t\t\tif c.lastComb[i] != c.currComb[i] {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// SetDirty is normally used to indicate that a cell has\n// been displayed (in which case dirty is false), or to manually\n// force a cell to be marked dirty.\nfunc (cb *CellBuffer) SetDirty(x, y int, dirty bool) {\n\tif x >= 0 && y >= 0 && x < cb.w && y < cb.h {\n\t\tc := &cb.cells[(y*cb.w)+x]\n\t\tif dirty {\n\t\t\tc.lastMain = rune(0)\n\t\t} else {\n\t\t\tif c.currMain == rune(0) {\n\t\t\t\tc.currMain = ' '\n\t\t\t}\n\t\t\tc.lastMain = c.currMain\n\t\t\tc.lastComb = c.currComb\n\t\t\tc.lastStyle = c.currStyle\n\t\t}\n\t}\n}\n\n// LockCell locks a cell from being drawn, effectively marking it \"clean\" until\n// the lock is removed. This can be used to prevent tcell from drawing a given\n// cell, even if the underlying content has changed. For example, when drawing a\n// sixel graphic directly to a TTY screen an implementer must lock the region\n// underneath the graphic to prevent tcell from drawing on top of the graphic.\nfunc (cb *CellBuffer) LockCell(x, y int) {\n\tif x < 0 || y < 0 {\n\t\treturn\n\t}\n\tif x >= cb.w || y >= cb.h {\n\t\treturn\n\t}\n\tc := &cb.cells[(y*cb.w)+x]\n\tc.lock = true\n}\n\n// UnlockCell removes a lock from the cell and marks it as dirty\nfunc (cb *CellBuffer) UnlockCell(x, y int) {\n\tif x < 0 || y < 0 {\n\t\treturn\n\t}\n\tif x >= cb.w || y >= cb.h {\n\t\treturn\n\t}\n\tc := &cb.cells[(y*cb.w)+x]\n\tc.lock = false\n\tcb.SetDirty(x, y, true)\n}\n\n// Resize is used to resize the cells array, with different dimensions,\n// while preserving the original contents.  The cells will be invalidated\n// so that they can be redrawn.\nfunc (cb *CellBuffer) Resize(w, h int) {\n\tif cb.h == h && cb.w == w {\n\t\treturn\n\t}\n\n\tnewc := make([]cell, w*h)\n\tfor y := 0; y < h && y < cb.h; y++ {\n\t\tfor x := 0; x < w && x < cb.w; x++ {\n\t\t\toc := &cb.cells[(y*cb.w)+x]\n\t\t\tnc := &newc[(y*w)+x]\n\t\t\tnc.currMain = oc.currMain\n\t\t\tnc.currComb = oc.currComb\n\t\t\tnc.currStyle = oc.currStyle\n\t\t\tnc.width = oc.width\n\t\t\tnc.lastMain = rune(0)\n\t\t}\n\t}\n\tcb.cells = newc\n\tcb.h = h\n\tcb.w = w\n}\n\n// Fill fills the entire cell buffer array with the specified character\n// and style.  Normally choose ' ' to clear the screen.  This API doesn't\n// support combining characters, or characters with a width larger than one.\n// If either the foreground or background are ColorNone, then the respective\n// color is unchanged.\nfunc (cb *CellBuffer) Fill(r rune, style Style) {\n\tfor i := range cb.cells {\n\t\tc := &cb.cells[i]\n\t\tc.currMain = r\n\t\tc.currComb = nil\n\t\tcs := style\n\t\tif cs.fg == ColorNone {\n\t\t\tcs.fg = c.currStyle.fg\n\t\t}\n\t\tif cs.bg == ColorNone {\n\t\t\tcs.bg = c.currStyle.bg\n\t\t}\n\t\tc.currStyle = cs\n\t\tc.width = 1\n\t}\n}\n\nvar runeConfig *runewidth.Condition\n\nfunc init() {\n\t// The defaults for the runewidth package are poorly chosen for terminal\n\t// applications.  We however will honor the setting in the environment if\n\t// it is set.\n\tif os.Getenv(\"RUNEWIDTH_EASTASIAN\") == \"\" {\n\t\trunewidth.DefaultCondition.EastAsianWidth = false\n\t}\n}\n"
        },
        {
          "name": "charset_stub.go",
          "type": "blob",
          "size": 0.6748046875,
          "content": "//go:build plan9 || nacl\n// +build plan9 nacl\n\n// Copyright 2015 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nfunc getCharset() string {\n\treturn \"\"\n}\n"
        },
        {
          "name": "charset_unix.go",
          "type": "blob",
          "size": 1.4189453125,
          "content": "//go:build !windows && !nacl && !plan9\n// +build !windows,!nacl,!plan9\n\n// Copyright 2016 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"os\"\n\t\"strings\"\n)\n\nfunc getCharset() string {\n\t// Determine the character set.  This can help us later.\n\t// Per POSIX, we search for LC_ALL first, then LC_CTYPE, and\n\t// finally LANG.  First one set wins.\n\tlocale := \"\"\n\tif locale = os.Getenv(\"LC_ALL\"); locale == \"\" {\n\t\tif locale = os.Getenv(\"LC_CTYPE\"); locale == \"\" {\n\t\t\tlocale = os.Getenv(\"LANG\")\n\t\t}\n\t}\n\tif locale == \"POSIX\" || locale == \"C\" {\n\t\treturn \"US-ASCII\"\n\t}\n\tif i := strings.IndexRune(locale, '@'); i >= 0 {\n\t\tlocale = locale[:i]\n\t}\n\tif i := strings.IndexRune(locale, '.'); i >= 0 {\n\t\tlocale = locale[i+1:]\n\t} else {\n\t\t// Default assumption, and on Linux we can see LC_ALL\n\t\t// without a character set, which we assume implies UTF-8.\n\t\treturn \"UTF-8\"\n\t}\n\t// XXX: add support for aliases\n\treturn locale\n}\n"
        },
        {
          "name": "charset_windows.go",
          "type": "blob",
          "size": 0.671875,
          "content": "//go:build windows\n// +build windows\n\n// Copyright 2015 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nfunc getCharset() string {\n\treturn \"UTF-16\"\n}\n"
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 36.6806640625,
          "content": "// Copyright 2023 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"fmt\"\n\tic \"image/color\"\n\t\"strconv\"\n)\n\n// Color represents a color.  The low numeric values are the same as used\n// by ECMA-48, and beyond that XTerm.  A 24-bit RGB value may be used by\n// adding in the ColorIsRGB flag.  For Color names we use the W3C approved\n// color names.\n//\n// We use a 64-bit integer to allow future expansion if we want to add an\n// 8-bit alpha, while still leaving us some room for extra options.\n//\n// Note that on various terminals colors may be approximated however, or\n// not supported at all.  If no suitable representation for a color is known,\n// the library will simply not set any color, deferring to whatever default\n// attributes the terminal uses.\ntype Color uint64\n\nconst (\n\t// ColorDefault is used to leave the Color unchanged from whatever\n\t// system or terminal default may exist.  It's also the zero value.\n\tColorDefault Color = 0\n\n\t// ColorValid is used to indicate the color value is actually\n\t// valid (initialized).  This is useful to permit the zero value\n\t// to be treated as the default.\n\tColorValid Color = 1 << 32\n\n\t// ColorIsRGB is used to indicate that the numeric value is not\n\t// a known color constant, but rather an RGB value.  The lower\n\t// order 3 bytes are RGB.\n\tColorIsRGB Color = 1 << 33\n\n\t// ColorSpecial is a flag used to indicate that the values have\n\t// special meaning, and live outside of the color space(s).\n\tColorSpecial Color = 1 << 34\n)\n\n// Note that the order of these options is important -- it follows the\n// definitions used by ECMA and XTerm.  Hence any further named colors\n// must begin at a value not less than 256.\nconst (\n\tColorBlack = ColorValid + iota\n\tColorMaroon\n\tColorGreen\n\tColorOlive\n\tColorNavy\n\tColorPurple\n\tColorTeal\n\tColorSilver\n\tColorGray\n\tColorRed\n\tColorLime\n\tColorYellow\n\tColorBlue\n\tColorFuchsia\n\tColorAqua\n\tColorWhite\n\tColor16\n\tColor17\n\tColor18\n\tColor19\n\tColor20\n\tColor21\n\tColor22\n\tColor23\n\tColor24\n\tColor25\n\tColor26\n\tColor27\n\tColor28\n\tColor29\n\tColor30\n\tColor31\n\tColor32\n\tColor33\n\tColor34\n\tColor35\n\tColor36\n\tColor37\n\tColor38\n\tColor39\n\tColor40\n\tColor41\n\tColor42\n\tColor43\n\tColor44\n\tColor45\n\tColor46\n\tColor47\n\tColor48\n\tColor49\n\tColor50\n\tColor51\n\tColor52\n\tColor53\n\tColor54\n\tColor55\n\tColor56\n\tColor57\n\tColor58\n\tColor59\n\tColor60\n\tColor61\n\tColor62\n\tColor63\n\tColor64\n\tColor65\n\tColor66\n\tColor67\n\tColor68\n\tColor69\n\tColor70\n\tColor71\n\tColor72\n\tColor73\n\tColor74\n\tColor75\n\tColor76\n\tColor77\n\tColor78\n\tColor79\n\tColor80\n\tColor81\n\tColor82\n\tColor83\n\tColor84\n\tColor85\n\tColor86\n\tColor87\n\tColor88\n\tColor89\n\tColor90\n\tColor91\n\tColor92\n\tColor93\n\tColor94\n\tColor95\n\tColor96\n\tColor97\n\tColor98\n\tColor99\n\tColor100\n\tColor101\n\tColor102\n\tColor103\n\tColor104\n\tColor105\n\tColor106\n\tColor107\n\tColor108\n\tColor109\n\tColor110\n\tColor111\n\tColor112\n\tColor113\n\tColor114\n\tColor115\n\tColor116\n\tColor117\n\tColor118\n\tColor119\n\tColor120\n\tColor121\n\tColor122\n\tColor123\n\tColor124\n\tColor125\n\tColor126\n\tColor127\n\tColor128\n\tColor129\n\tColor130\n\tColor131\n\tColor132\n\tColor133\n\tColor134\n\tColor135\n\tColor136\n\tColor137\n\tColor138\n\tColor139\n\tColor140\n\tColor141\n\tColor142\n\tColor143\n\tColor144\n\tColor145\n\tColor146\n\tColor147\n\tColor148\n\tColor149\n\tColor150\n\tColor151\n\tColor152\n\tColor153\n\tColor154\n\tColor155\n\tColor156\n\tColor157\n\tColor158\n\tColor159\n\tColor160\n\tColor161\n\tColor162\n\tColor163\n\tColor164\n\tColor165\n\tColor166\n\tColor167\n\tColor168\n\tColor169\n\tColor170\n\tColor171\n\tColor172\n\tColor173\n\tColor174\n\tColor175\n\tColor176\n\tColor177\n\tColor178\n\tColor179\n\tColor180\n\tColor181\n\tColor182\n\tColor183\n\tColor184\n\tColor185\n\tColor186\n\tColor187\n\tColor188\n\tColor189\n\tColor190\n\tColor191\n\tColor192\n\tColor193\n\tColor194\n\tColor195\n\tColor196\n\tColor197\n\tColor198\n\tColor199\n\tColor200\n\tColor201\n\tColor202\n\tColor203\n\tColor204\n\tColor205\n\tColor206\n\tColor207\n\tColor208\n\tColor209\n\tColor210\n\tColor211\n\tColor212\n\tColor213\n\tColor214\n\tColor215\n\tColor216\n\tColor217\n\tColor218\n\tColor219\n\tColor220\n\tColor221\n\tColor222\n\tColor223\n\tColor224\n\tColor225\n\tColor226\n\tColor227\n\tColor228\n\tColor229\n\tColor230\n\tColor231\n\tColor232\n\tColor233\n\tColor234\n\tColor235\n\tColor236\n\tColor237\n\tColor238\n\tColor239\n\tColor240\n\tColor241\n\tColor242\n\tColor243\n\tColor244\n\tColor245\n\tColor246\n\tColor247\n\tColor248\n\tColor249\n\tColor250\n\tColor251\n\tColor252\n\tColor253\n\tColor254\n\tColor255\n\tColorAliceBlue            = ColorIsRGB | ColorValid | 0xF0F8FF\n\tColorAntiqueWhite         = ColorIsRGB | ColorValid | 0xFAEBD7\n\tColorAquaMarine           = ColorIsRGB | ColorValid | 0x7FFFD4\n\tColorAzure                = ColorIsRGB | ColorValid | 0xF0FFFF\n\tColorBeige                = ColorIsRGB | ColorValid | 0xF5F5DC\n\tColorBisque               = ColorIsRGB | ColorValid | 0xFFE4C4\n\tColorBlanchedAlmond       = ColorIsRGB | ColorValid | 0xFFEBCD\n\tColorBlueViolet           = ColorIsRGB | ColorValid | 0x8A2BE2\n\tColorBrown                = ColorIsRGB | ColorValid | 0xA52A2A\n\tColorBurlyWood            = ColorIsRGB | ColorValid | 0xDEB887\n\tColorCadetBlue            = ColorIsRGB | ColorValid | 0x5F9EA0\n\tColorChartreuse           = ColorIsRGB | ColorValid | 0x7FFF00\n\tColorChocolate            = ColorIsRGB | ColorValid | 0xD2691E\n\tColorCoral                = ColorIsRGB | ColorValid | 0xFF7F50\n\tColorCornflowerBlue       = ColorIsRGB | ColorValid | 0x6495ED\n\tColorCornsilk             = ColorIsRGB | ColorValid | 0xFFF8DC\n\tColorCrimson              = ColorIsRGB | ColorValid | 0xDC143C\n\tColorDarkBlue             = ColorIsRGB | ColorValid | 0x00008B\n\tColorDarkCyan             = ColorIsRGB | ColorValid | 0x008B8B\n\tColorDarkGoldenrod        = ColorIsRGB | ColorValid | 0xB8860B\n\tColorDarkGray             = ColorIsRGB | ColorValid | 0xA9A9A9\n\tColorDarkGreen            = ColorIsRGB | ColorValid | 0x006400\n\tColorDarkKhaki            = ColorIsRGB | ColorValid | 0xBDB76B\n\tColorDarkMagenta          = ColorIsRGB | ColorValid | 0x8B008B\n\tColorDarkOliveGreen       = ColorIsRGB | ColorValid | 0x556B2F\n\tColorDarkOrange           = ColorIsRGB | ColorValid | 0xFF8C00\n\tColorDarkOrchid           = ColorIsRGB | ColorValid | 0x9932CC\n\tColorDarkRed              = ColorIsRGB | ColorValid | 0x8B0000\n\tColorDarkSalmon           = ColorIsRGB | ColorValid | 0xE9967A\n\tColorDarkSeaGreen         = ColorIsRGB | ColorValid | 0x8FBC8F\n\tColorDarkSlateBlue        = ColorIsRGB | ColorValid | 0x483D8B\n\tColorDarkSlateGray        = ColorIsRGB | ColorValid | 0x2F4F4F\n\tColorDarkTurquoise        = ColorIsRGB | ColorValid | 0x00CED1\n\tColorDarkViolet           = ColorIsRGB | ColorValid | 0x9400D3\n\tColorDeepPink             = ColorIsRGB | ColorValid | 0xFF1493\n\tColorDeepSkyBlue          = ColorIsRGB | ColorValid | 0x00BFFF\n\tColorDimGray              = ColorIsRGB | ColorValid | 0x696969\n\tColorDodgerBlue           = ColorIsRGB | ColorValid | 0x1E90FF\n\tColorFireBrick            = ColorIsRGB | ColorValid | 0xB22222\n\tColorFloralWhite          = ColorIsRGB | ColorValid | 0xFFFAF0\n\tColorForestGreen          = ColorIsRGB | ColorValid | 0x228B22\n\tColorGainsboro            = ColorIsRGB | ColorValid | 0xDCDCDC\n\tColorGhostWhite           = ColorIsRGB | ColorValid | 0xF8F8FF\n\tColorGold                 = ColorIsRGB | ColorValid | 0xFFD700\n\tColorGoldenrod            = ColorIsRGB | ColorValid | 0xDAA520\n\tColorGreenYellow          = ColorIsRGB | ColorValid | 0xADFF2F\n\tColorHoneydew             = ColorIsRGB | ColorValid | 0xF0FFF0\n\tColorHotPink              = ColorIsRGB | ColorValid | 0xFF69B4\n\tColorIndianRed            = ColorIsRGB | ColorValid | 0xCD5C5C\n\tColorIndigo               = ColorIsRGB | ColorValid | 0x4B0082\n\tColorIvory                = ColorIsRGB | ColorValid | 0xFFFFF0\n\tColorKhaki                = ColorIsRGB | ColorValid | 0xF0E68C\n\tColorLavender             = ColorIsRGB | ColorValid | 0xE6E6FA\n\tColorLavenderBlush        = ColorIsRGB | ColorValid | 0xFFF0F5\n\tColorLawnGreen            = ColorIsRGB | ColorValid | 0x7CFC00\n\tColorLemonChiffon         = ColorIsRGB | ColorValid | 0xFFFACD\n\tColorLightBlue            = ColorIsRGB | ColorValid | 0xADD8E6\n\tColorLightCoral           = ColorIsRGB | ColorValid | 0xF08080\n\tColorLightCyan            = ColorIsRGB | ColorValid | 0xE0FFFF\n\tColorLightGoldenrodYellow = ColorIsRGB | ColorValid | 0xFAFAD2\n\tColorLightGray            = ColorIsRGB | ColorValid | 0xD3D3D3\n\tColorLightGreen           = ColorIsRGB | ColorValid | 0x90EE90\n\tColorLightPink            = ColorIsRGB | ColorValid | 0xFFB6C1\n\tColorLightSalmon          = ColorIsRGB | ColorValid | 0xFFA07A\n\tColorLightSeaGreen        = ColorIsRGB | ColorValid | 0x20B2AA\n\tColorLightSkyBlue         = ColorIsRGB | ColorValid | 0x87CEFA\n\tColorLightSlateGray       = ColorIsRGB | ColorValid | 0x778899\n\tColorLightSteelBlue       = ColorIsRGB | ColorValid | 0xB0C4DE\n\tColorLightYellow          = ColorIsRGB | ColorValid | 0xFFFFE0\n\tColorLimeGreen            = ColorIsRGB | ColorValid | 0x32CD32\n\tColorLinen                = ColorIsRGB | ColorValid | 0xFAF0E6\n\tColorMediumAquamarine     = ColorIsRGB | ColorValid | 0x66CDAA\n\tColorMediumBlue           = ColorIsRGB | ColorValid | 0x0000CD\n\tColorMediumOrchid         = ColorIsRGB | ColorValid | 0xBA55D3\n\tColorMediumPurple         = ColorIsRGB | ColorValid | 0x9370DB\n\tColorMediumSeaGreen       = ColorIsRGB | ColorValid | 0x3CB371\n\tColorMediumSlateBlue      = ColorIsRGB | ColorValid | 0x7B68EE\n\tColorMediumSpringGreen    = ColorIsRGB | ColorValid | 0x00FA9A\n\tColorMediumTurquoise      = ColorIsRGB | ColorValid | 0x48D1CC\n\tColorMediumVioletRed      = ColorIsRGB | ColorValid | 0xC71585\n\tColorMidnightBlue         = ColorIsRGB | ColorValid | 0x191970\n\tColorMintCream            = ColorIsRGB | ColorValid | 0xF5FFFA\n\tColorMistyRose            = ColorIsRGB | ColorValid | 0xFFE4E1\n\tColorMoccasin             = ColorIsRGB | ColorValid | 0xFFE4B5\n\tColorNavajoWhite          = ColorIsRGB | ColorValid | 0xFFDEAD\n\tColorOldLace              = ColorIsRGB | ColorValid | 0xFDF5E6\n\tColorOliveDrab            = ColorIsRGB | ColorValid | 0x6B8E23\n\tColorOrange               = ColorIsRGB | ColorValid | 0xFFA500\n\tColorOrangeRed            = ColorIsRGB | ColorValid | 0xFF4500\n\tColorOrchid               = ColorIsRGB | ColorValid | 0xDA70D6\n\tColorPaleGoldenrod        = ColorIsRGB | ColorValid | 0xEEE8AA\n\tColorPaleGreen            = ColorIsRGB | ColorValid | 0x98FB98\n\tColorPaleTurquoise        = ColorIsRGB | ColorValid | 0xAFEEEE\n\tColorPaleVioletRed        = ColorIsRGB | ColorValid | 0xDB7093\n\tColorPapayaWhip           = ColorIsRGB | ColorValid | 0xFFEFD5\n\tColorPeachPuff            = ColorIsRGB | ColorValid | 0xFFDAB9\n\tColorPeru                 = ColorIsRGB | ColorValid | 0xCD853F\n\tColorPink                 = ColorIsRGB | ColorValid | 0xFFC0CB\n\tColorPlum                 = ColorIsRGB | ColorValid | 0xDDA0DD\n\tColorPowderBlue           = ColorIsRGB | ColorValid | 0xB0E0E6\n\tColorRebeccaPurple        = ColorIsRGB | ColorValid | 0x663399\n\tColorRosyBrown            = ColorIsRGB | ColorValid | 0xBC8F8F\n\tColorRoyalBlue            = ColorIsRGB | ColorValid | 0x4169E1\n\tColorSaddleBrown          = ColorIsRGB | ColorValid | 0x8B4513\n\tColorSalmon               = ColorIsRGB | ColorValid | 0xFA8072\n\tColorSandyBrown           = ColorIsRGB | ColorValid | 0xF4A460\n\tColorSeaGreen             = ColorIsRGB | ColorValid | 0x2E8B57\n\tColorSeashell             = ColorIsRGB | ColorValid | 0xFFF5EE\n\tColorSienna               = ColorIsRGB | ColorValid | 0xA0522D\n\tColorSkyblue              = ColorIsRGB | ColorValid | 0x87CEEB\n\tColorSlateBlue            = ColorIsRGB | ColorValid | 0x6A5ACD\n\tColorSlateGray            = ColorIsRGB | ColorValid | 0x708090\n\tColorSnow                 = ColorIsRGB | ColorValid | 0xFFFAFA\n\tColorSpringGreen          = ColorIsRGB | ColorValid | 0x00FF7F\n\tColorSteelBlue            = ColorIsRGB | ColorValid | 0x4682B4\n\tColorTan                  = ColorIsRGB | ColorValid | 0xD2B48C\n\tColorThistle              = ColorIsRGB | ColorValid | 0xD8BFD8\n\tColorTomato               = ColorIsRGB | ColorValid | 0xFF6347\n\tColorTurquoise            = ColorIsRGB | ColorValid | 0x40E0D0\n\tColorViolet               = ColorIsRGB | ColorValid | 0xEE82EE\n\tColorWheat                = ColorIsRGB | ColorValid | 0xF5DEB3\n\tColorWhiteSmoke           = ColorIsRGB | ColorValid | 0xF5F5F5\n\tColorYellowGreen          = ColorIsRGB | ColorValid | 0x9ACD32\n)\n\n// These are aliases for the color gray, because some of us spell\n// it as grey.\nconst (\n\tColorGrey           = ColorGray\n\tColorDimGrey        = ColorDimGray\n\tColorDarkGrey       = ColorDarkGray\n\tColorDarkSlateGrey  = ColorDarkSlateGray\n\tColorLightGrey      = ColorLightGray\n\tColorLightSlateGrey = ColorLightSlateGray\n\tColorSlateGrey      = ColorSlateGray\n)\n\n// ColorValues maps color constants to their RGB values.\nvar ColorValues = map[Color]int32{\n\tColorBlack:                0x000000,\n\tColorMaroon:               0x800000,\n\tColorGreen:                0x008000,\n\tColorOlive:                0x808000,\n\tColorNavy:                 0x000080,\n\tColorPurple:               0x800080,\n\tColorTeal:                 0x008080,\n\tColorSilver:               0xC0C0C0,\n\tColorGray:                 0x808080,\n\tColorRed:                  0xFF0000,\n\tColorLime:                 0x00FF00,\n\tColorYellow:               0xFFFF00,\n\tColorBlue:                 0x0000FF,\n\tColorFuchsia:              0xFF00FF,\n\tColorAqua:                 0x00FFFF,\n\tColorWhite:                0xFFFFFF,\n\tColor16:                   0x000000, // black\n\tColor17:                   0x00005F,\n\tColor18:                   0x000087,\n\tColor19:                   0x0000AF,\n\tColor20:                   0x0000D7,\n\tColor21:                   0x0000FF, // blue\n\tColor22:                   0x005F00,\n\tColor23:                   0x005F5F,\n\tColor24:                   0x005F87,\n\tColor25:                   0x005FAF,\n\tColor26:                   0x005FD7,\n\tColor27:                   0x005FFF,\n\tColor28:                   0x008700,\n\tColor29:                   0x00875F,\n\tColor30:                   0x008787,\n\tColor31:                   0x0087Af,\n\tColor32:                   0x0087D7,\n\tColor33:                   0x0087FF,\n\tColor34:                   0x00AF00,\n\tColor35:                   0x00AF5F,\n\tColor36:                   0x00AF87,\n\tColor37:                   0x00AFAF,\n\tColor38:                   0x00AFD7,\n\tColor39:                   0x00AFFF,\n\tColor40:                   0x00D700,\n\tColor41:                   0x00D75F,\n\tColor42:                   0x00D787,\n\tColor43:                   0x00D7AF,\n\tColor44:                   0x00D7D7,\n\tColor45:                   0x00D7FF,\n\tColor46:                   0x00FF00, // lime\n\tColor47:                   0x00FF5F,\n\tColor48:                   0x00FF87,\n\tColor49:                   0x00FFAF,\n\tColor50:                   0x00FFd7,\n\tColor51:                   0x00FFFF, // aqua\n\tColor52:                   0x5F0000,\n\tColor53:                   0x5F005F,\n\tColor54:                   0x5F0087,\n\tColor55:                   0x5F00AF,\n\tColor56:                   0x5F00D7,\n\tColor57:                   0x5F00FF,\n\tColor58:                   0x5F5F00,\n\tColor59:                   0x5F5F5F,\n\tColor60:                   0x5F5F87,\n\tColor61:                   0x5F5FAF,\n\tColor62:                   0x5F5FD7,\n\tColor63:                   0x5F5FFF,\n\tColor64:                   0x5F8700,\n\tColor65:                   0x5F875F,\n\tColor66:                   0x5F8787,\n\tColor67:                   0x5F87AF,\n\tColor68:                   0x5F87D7,\n\tColor69:                   0x5F87FF,\n\tColor70:                   0x5FAF00,\n\tColor71:                   0x5FAF5F,\n\tColor72:                   0x5FAF87,\n\tColor73:                   0x5FAFAF,\n\tColor74:                   0x5FAFD7,\n\tColor75:                   0x5FAFFF,\n\tColor76:                   0x5FD700,\n\tColor77:                   0x5FD75F,\n\tColor78:                   0x5FD787,\n\tColor79:                   0x5FD7AF,\n\tColor80:                   0x5FD7D7,\n\tColor81:                   0x5FD7FF,\n\tColor82:                   0x5FFF00,\n\tColor83:                   0x5FFF5F,\n\tColor84:                   0x5FFF87,\n\tColor85:                   0x5FFFAF,\n\tColor86:                   0x5FFFD7,\n\tColor87:                   0x5FFFFF,\n\tColor88:                   0x870000,\n\tColor89:                   0x87005F,\n\tColor90:                   0x870087,\n\tColor91:                   0x8700AF,\n\tColor92:                   0x8700D7,\n\tColor93:                   0x8700FF,\n\tColor94:                   0x875F00,\n\tColor95:                   0x875F5F,\n\tColor96:                   0x875F87,\n\tColor97:                   0x875FAF,\n\tColor98:                   0x875FD7,\n\tColor99:                   0x875FFF,\n\tColor100:                  0x878700,\n\tColor101:                  0x87875F,\n\tColor102:                  0x878787,\n\tColor103:                  0x8787AF,\n\tColor104:                  0x8787D7,\n\tColor105:                  0x8787FF,\n\tColor106:                  0x87AF00,\n\tColor107:                  0x87AF5F,\n\tColor108:                  0x87AF87,\n\tColor109:                  0x87AFAF,\n\tColor110:                  0x87AFD7,\n\tColor111:                  0x87AFFF,\n\tColor112:                  0x87D700,\n\tColor113:                  0x87D75F,\n\tColor114:                  0x87D787,\n\tColor115:                  0x87D7AF,\n\tColor116:                  0x87D7D7,\n\tColor117:                  0x87D7FF,\n\tColor118:                  0x87FF00,\n\tColor119:                  0x87FF5F,\n\tColor120:                  0x87FF87,\n\tColor121:                  0x87FFAF,\n\tColor122:                  0x87FFD7,\n\tColor123:                  0x87FFFF,\n\tColor124:                  0xAF0000,\n\tColor125:                  0xAF005F,\n\tColor126:                  0xAF0087,\n\tColor127:                  0xAF00AF,\n\tColor128:                  0xAF00D7,\n\tColor129:                  0xAF00FF,\n\tColor130:                  0xAF5F00,\n\tColor131:                  0xAF5F5F,\n\tColor132:                  0xAF5F87,\n\tColor133:                  0xAF5FAF,\n\tColor134:                  0xAF5FD7,\n\tColor135:                  0xAF5FFF,\n\tColor136:                  0xAF8700,\n\tColor137:                  0xAF875F,\n\tColor138:                  0xAF8787,\n\tColor139:                  0xAF87AF,\n\tColor140:                  0xAF87D7,\n\tColor141:                  0xAF87FF,\n\tColor142:                  0xAFAF00,\n\tColor143:                  0xAFAF5F,\n\tColor144:                  0xAFAF87,\n\tColor145:                  0xAFAFAF,\n\tColor146:                  0xAFAFD7,\n\tColor147:                  0xAFAFFF,\n\tColor148:                  0xAFD700,\n\tColor149:                  0xAFD75F,\n\tColor150:                  0xAFD787,\n\tColor151:                  0xAFD7AF,\n\tColor152:                  0xAFD7D7,\n\tColor153:                  0xAFD7FF,\n\tColor154:                  0xAFFF00,\n\tColor155:                  0xAFFF5F,\n\tColor156:                  0xAFFF87,\n\tColor157:                  0xAFFFAF,\n\tColor158:                  0xAFFFD7,\n\tColor159:                  0xAFFFFF,\n\tColor160:                  0xD70000,\n\tColor161:                  0xD7005F,\n\tColor162:                  0xD70087,\n\tColor163:                  0xD700AF,\n\tColor164:                  0xD700D7,\n\tColor165:                  0xD700FF,\n\tColor166:                  0xD75F00,\n\tColor167:                  0xD75F5F,\n\tColor168:                  0xD75F87,\n\tColor169:                  0xD75FAF,\n\tColor170:                  0xD75FD7,\n\tColor171:                  0xD75FFF,\n\tColor172:                  0xD78700,\n\tColor173:                  0xD7875F,\n\tColor174:                  0xD78787,\n\tColor175:                  0xD787AF,\n\tColor176:                  0xD787D7,\n\tColor177:                  0xD787FF,\n\tColor178:                  0xD7AF00,\n\tColor179:                  0xD7AF5F,\n\tColor180:                  0xD7AF87,\n\tColor181:                  0xD7AFAF,\n\tColor182:                  0xD7AFD7,\n\tColor183:                  0xD7AFFF,\n\tColor184:                  0xD7D700,\n\tColor185:                  0xD7D75F,\n\tColor186:                  0xD7D787,\n\tColor187:                  0xD7D7AF,\n\tColor188:                  0xD7D7D7,\n\tColor189:                  0xD7D7FF,\n\tColor190:                  0xD7FF00,\n\tColor191:                  0xD7FF5F,\n\tColor192:                  0xD7FF87,\n\tColor193:                  0xD7FFAF,\n\tColor194:                  0xD7FFD7,\n\tColor195:                  0xD7FFFF,\n\tColor196:                  0xFF0000, // red\n\tColor197:                  0xFF005F,\n\tColor198:                  0xFF0087,\n\tColor199:                  0xFF00AF,\n\tColor200:                  0xFF00D7,\n\tColor201:                  0xFF00FF, // fuchsia\n\tColor202:                  0xFF5F00,\n\tColor203:                  0xFF5F5F,\n\tColor204:                  0xFF5F87,\n\tColor205:                  0xFF5FAF,\n\tColor206:                  0xFF5FD7,\n\tColor207:                  0xFF5FFF,\n\tColor208:                  0xFF8700,\n\tColor209:                  0xFF875F,\n\tColor210:                  0xFF8787,\n\tColor211:                  0xFF87AF,\n\tColor212:                  0xFF87D7,\n\tColor213:                  0xFF87FF,\n\tColor214:                  0xFFAF00,\n\tColor215:                  0xFFAF5F,\n\tColor216:                  0xFFAF87,\n\tColor217:                  0xFFAFAF,\n\tColor218:                  0xFFAFD7,\n\tColor219:                  0xFFAFFF,\n\tColor220:                  0xFFD700,\n\tColor221:                  0xFFD75F,\n\tColor222:                  0xFFD787,\n\tColor223:                  0xFFD7AF,\n\tColor224:                  0xFFD7D7,\n\tColor225:                  0xFFD7FF,\n\tColor226:                  0xFFFF00, // yellow\n\tColor227:                  0xFFFF5F,\n\tColor228:                  0xFFFF87,\n\tColor229:                  0xFFFFAF,\n\tColor230:                  0xFFFFD7,\n\tColor231:                  0xFFFFFF, // white\n\tColor232:                  0x080808,\n\tColor233:                  0x121212,\n\tColor234:                  0x1C1C1C,\n\tColor235:                  0x262626,\n\tColor236:                  0x303030,\n\tColor237:                  0x3A3A3A,\n\tColor238:                  0x444444,\n\tColor239:                  0x4E4E4E,\n\tColor240:                  0x585858,\n\tColor241:                  0x626262,\n\tColor242:                  0x6C6C6C,\n\tColor243:                  0x767676,\n\tColor244:                  0x808080, // grey\n\tColor245:                  0x8A8A8A,\n\tColor246:                  0x949494,\n\tColor247:                  0x9E9E9E,\n\tColor248:                  0xA8A8A8,\n\tColor249:                  0xB2B2B2,\n\tColor250:                  0xBCBCBC,\n\tColor251:                  0xC6C6C6,\n\tColor252:                  0xD0D0D0,\n\tColor253:                  0xDADADA,\n\tColor254:                  0xE4E4E4,\n\tColor255:                  0xEEEEEE,\n\tColorAliceBlue:            0xF0F8FF,\n\tColorAntiqueWhite:         0xFAEBD7,\n\tColorAquaMarine:           0x7FFFD4,\n\tColorAzure:                0xF0FFFF,\n\tColorBeige:                0xF5F5DC,\n\tColorBisque:               0xFFE4C4,\n\tColorBlanchedAlmond:       0xFFEBCD,\n\tColorBlueViolet:           0x8A2BE2,\n\tColorBrown:                0xA52A2A,\n\tColorBurlyWood:            0xDEB887,\n\tColorCadetBlue:            0x5F9EA0,\n\tColorChartreuse:           0x7FFF00,\n\tColorChocolate:            0xD2691E,\n\tColorCoral:                0xFF7F50,\n\tColorCornflowerBlue:       0x6495ED,\n\tColorCornsilk:             0xFFF8DC,\n\tColorCrimson:              0xDC143C,\n\tColorDarkBlue:             0x00008B,\n\tColorDarkCyan:             0x008B8B,\n\tColorDarkGoldenrod:        0xB8860B,\n\tColorDarkGray:             0xA9A9A9,\n\tColorDarkGreen:            0x006400,\n\tColorDarkKhaki:            0xBDB76B,\n\tColorDarkMagenta:          0x8B008B,\n\tColorDarkOliveGreen:       0x556B2F,\n\tColorDarkOrange:           0xFF8C00,\n\tColorDarkOrchid:           0x9932CC,\n\tColorDarkRed:              0x8B0000,\n\tColorDarkSalmon:           0xE9967A,\n\tColorDarkSeaGreen:         0x8FBC8F,\n\tColorDarkSlateBlue:        0x483D8B,\n\tColorDarkSlateGray:        0x2F4F4F,\n\tColorDarkTurquoise:        0x00CED1,\n\tColorDarkViolet:           0x9400D3,\n\tColorDeepPink:             0xFF1493,\n\tColorDeepSkyBlue:          0x00BFFF,\n\tColorDimGray:              0x696969,\n\tColorDodgerBlue:           0x1E90FF,\n\tColorFireBrick:            0xB22222,\n\tColorFloralWhite:          0xFFFAF0,\n\tColorForestGreen:          0x228B22,\n\tColorGainsboro:            0xDCDCDC,\n\tColorGhostWhite:           0xF8F8FF,\n\tColorGold:                 0xFFD700,\n\tColorGoldenrod:            0xDAA520,\n\tColorGreenYellow:          0xADFF2F,\n\tColorHoneydew:             0xF0FFF0,\n\tColorHotPink:              0xFF69B4,\n\tColorIndianRed:            0xCD5C5C,\n\tColorIndigo:               0x4B0082,\n\tColorIvory:                0xFFFFF0,\n\tColorKhaki:                0xF0E68C,\n\tColorLavender:             0xE6E6FA,\n\tColorLavenderBlush:        0xFFF0F5,\n\tColorLawnGreen:            0x7CFC00,\n\tColorLemonChiffon:         0xFFFACD,\n\tColorLightBlue:            0xADD8E6,\n\tColorLightCoral:           0xF08080,\n\tColorLightCyan:            0xE0FFFF,\n\tColorLightGoldenrodYellow: 0xFAFAD2,\n\tColorLightGray:            0xD3D3D3,\n\tColorLightGreen:           0x90EE90,\n\tColorLightPink:            0xFFB6C1,\n\tColorLightSalmon:          0xFFA07A,\n\tColorLightSeaGreen:        0x20B2AA,\n\tColorLightSkyBlue:         0x87CEFA,\n\tColorLightSlateGray:       0x778899,\n\tColorLightSteelBlue:       0xB0C4DE,\n\tColorLightYellow:          0xFFFFE0,\n\tColorLimeGreen:            0x32CD32,\n\tColorLinen:                0xFAF0E6,\n\tColorMediumAquamarine:     0x66CDAA,\n\tColorMediumBlue:           0x0000CD,\n\tColorMediumOrchid:         0xBA55D3,\n\tColorMediumPurple:         0x9370DB,\n\tColorMediumSeaGreen:       0x3CB371,\n\tColorMediumSlateBlue:      0x7B68EE,\n\tColorMediumSpringGreen:    0x00FA9A,\n\tColorMediumTurquoise:      0x48D1CC,\n\tColorMediumVioletRed:      0xC71585,\n\tColorMidnightBlue:         0x191970,\n\tColorMintCream:            0xF5FFFA,\n\tColorMistyRose:            0xFFE4E1,\n\tColorMoccasin:             0xFFE4B5,\n\tColorNavajoWhite:          0xFFDEAD,\n\tColorOldLace:              0xFDF5E6,\n\tColorOliveDrab:            0x6B8E23,\n\tColorOrange:               0xFFA500,\n\tColorOrangeRed:            0xFF4500,\n\tColorOrchid:               0xDA70D6,\n\tColorPaleGoldenrod:        0xEEE8AA,\n\tColorPaleGreen:            0x98FB98,\n\tColorPaleTurquoise:        0xAFEEEE,\n\tColorPaleVioletRed:        0xDB7093,\n\tColorPapayaWhip:           0xFFEFD5,\n\tColorPeachPuff:            0xFFDAB9,\n\tColorPeru:                 0xCD853F,\n\tColorPink:                 0xFFC0CB,\n\tColorPlum:                 0xDDA0DD,\n\tColorPowderBlue:           0xB0E0E6,\n\tColorRebeccaPurple:        0x663399,\n\tColorRosyBrown:            0xBC8F8F,\n\tColorRoyalBlue:            0x4169E1,\n\tColorSaddleBrown:          0x8B4513,\n\tColorSalmon:               0xFA8072,\n\tColorSandyBrown:           0xF4A460,\n\tColorSeaGreen:             0x2E8B57,\n\tColorSeashell:             0xFFF5EE,\n\tColorSienna:               0xA0522D,\n\tColorSkyblue:              0x87CEEB,\n\tColorSlateBlue:            0x6A5ACD,\n\tColorSlateGray:            0x708090,\n\tColorSnow:                 0xFFFAFA,\n\tColorSpringGreen:          0x00FF7F,\n\tColorSteelBlue:            0x4682B4,\n\tColorTan:                  0xD2B48C,\n\tColorThistle:              0xD8BFD8,\n\tColorTomato:               0xFF6347,\n\tColorTurquoise:            0x40E0D0,\n\tColorViolet:               0xEE82EE,\n\tColorWheat:                0xF5DEB3,\n\tColorWhiteSmoke:           0xF5F5F5,\n\tColorYellowGreen:          0x9ACD32,\n}\n\n// Special colors.\nconst (\n\t// ColorReset is used to indicate that the color should use the\n\t// vanilla terminal colors.  (Basically go back to the defaults.)\n\tColorReset = ColorSpecial | iota\n\n\t// ColorNone indicates that we should not change the color from\n\t// whatever is already displayed.  This can only be used in limited\n\t// circumstances.\n\tColorNone\n)\n\n// ColorNames holds the written names of colors. Useful to present a list of\n// recognized named colors.\nvar ColorNames = map[string]Color{\n\t\"black\":                ColorBlack,\n\t\"maroon\":               ColorMaroon,\n\t\"green\":                ColorGreen,\n\t\"olive\":                ColorOlive,\n\t\"navy\":                 ColorNavy,\n\t\"purple\":               ColorPurple,\n\t\"teal\":                 ColorTeal,\n\t\"silver\":               ColorSilver,\n\t\"gray\":                 ColorGray,\n\t\"red\":                  ColorRed,\n\t\"lime\":                 ColorLime,\n\t\"yellow\":               ColorYellow,\n\t\"blue\":                 ColorBlue,\n\t\"fuchsia\":              ColorFuchsia,\n\t\"aqua\":                 ColorAqua,\n\t\"white\":                ColorWhite,\n\t\"aliceblue\":            ColorAliceBlue,\n\t\"antiquewhite\":         ColorAntiqueWhite,\n\t\"aquamarine\":           ColorAquaMarine,\n\t\"azure\":                ColorAzure,\n\t\"beige\":                ColorBeige,\n\t\"bisque\":               ColorBisque,\n\t\"blanchedalmond\":       ColorBlanchedAlmond,\n\t\"blueviolet\":           ColorBlueViolet,\n\t\"brown\":                ColorBrown,\n\t\"burlywood\":            ColorBurlyWood,\n\t\"cadetblue\":            ColorCadetBlue,\n\t\"chartreuse\":           ColorChartreuse,\n\t\"chocolate\":            ColorChocolate,\n\t\"coral\":                ColorCoral,\n\t\"cornflowerblue\":       ColorCornflowerBlue,\n\t\"cornsilk\":             ColorCornsilk,\n\t\"crimson\":              ColorCrimson,\n\t\"darkblue\":             ColorDarkBlue,\n\t\"darkcyan\":             ColorDarkCyan,\n\t\"darkgoldenrod\":        ColorDarkGoldenrod,\n\t\"darkgray\":             ColorDarkGray,\n\t\"darkgreen\":            ColorDarkGreen,\n\t\"darkkhaki\":            ColorDarkKhaki,\n\t\"darkmagenta\":          ColorDarkMagenta,\n\t\"darkolivegreen\":       ColorDarkOliveGreen,\n\t\"darkorange\":           ColorDarkOrange,\n\t\"darkorchid\":           ColorDarkOrchid,\n\t\"darkred\":              ColorDarkRed,\n\t\"darksalmon\":           ColorDarkSalmon,\n\t\"darkseagreen\":         ColorDarkSeaGreen,\n\t\"darkslateblue\":        ColorDarkSlateBlue,\n\t\"darkslategray\":        ColorDarkSlateGray,\n\t\"darkturquoise\":        ColorDarkTurquoise,\n\t\"darkviolet\":           ColorDarkViolet,\n\t\"deeppink\":             ColorDeepPink,\n\t\"deepskyblue\":          ColorDeepSkyBlue,\n\t\"dimgray\":              ColorDimGray,\n\t\"dodgerblue\":           ColorDodgerBlue,\n\t\"firebrick\":            ColorFireBrick,\n\t\"floralwhite\":          ColorFloralWhite,\n\t\"forestgreen\":          ColorForestGreen,\n\t\"gainsboro\":            ColorGainsboro,\n\t\"ghostwhite\":           ColorGhostWhite,\n\t\"gold\":                 ColorGold,\n\t\"goldenrod\":            ColorGoldenrod,\n\t\"greenyellow\":          ColorGreenYellow,\n\t\"honeydew\":             ColorHoneydew,\n\t\"hotpink\":              ColorHotPink,\n\t\"indianred\":            ColorIndianRed,\n\t\"indigo\":               ColorIndigo,\n\t\"ivory\":                ColorIvory,\n\t\"khaki\":                ColorKhaki,\n\t\"lavender\":             ColorLavender,\n\t\"lavenderblush\":        ColorLavenderBlush,\n\t\"lawngreen\":            ColorLawnGreen,\n\t\"lemonchiffon\":         ColorLemonChiffon,\n\t\"lightblue\":            ColorLightBlue,\n\t\"lightcoral\":           ColorLightCoral,\n\t\"lightcyan\":            ColorLightCyan,\n\t\"lightgoldenrodyellow\": ColorLightGoldenrodYellow,\n\t\"lightgray\":            ColorLightGray,\n\t\"lightgreen\":           ColorLightGreen,\n\t\"lightpink\":            ColorLightPink,\n\t\"lightsalmon\":          ColorLightSalmon,\n\t\"lightseagreen\":        ColorLightSeaGreen,\n\t\"lightskyblue\":         ColorLightSkyBlue,\n\t\"lightslategray\":       ColorLightSlateGray,\n\t\"lightsteelblue\":       ColorLightSteelBlue,\n\t\"lightyellow\":          ColorLightYellow,\n\t\"limegreen\":            ColorLimeGreen,\n\t\"linen\":                ColorLinen,\n\t\"mediumaquamarine\":     ColorMediumAquamarine,\n\t\"mediumblue\":           ColorMediumBlue,\n\t\"mediumorchid\":         ColorMediumOrchid,\n\t\"mediumpurple\":         ColorMediumPurple,\n\t\"mediumseagreen\":       ColorMediumSeaGreen,\n\t\"mediumslateblue\":      ColorMediumSlateBlue,\n\t\"mediumspringgreen\":    ColorMediumSpringGreen,\n\t\"mediumturquoise\":      ColorMediumTurquoise,\n\t\"mediumvioletred\":      ColorMediumVioletRed,\n\t\"midnightblue\":         ColorMidnightBlue,\n\t\"mintcream\":            ColorMintCream,\n\t\"mistyrose\":            ColorMistyRose,\n\t\"moccasin\":             ColorMoccasin,\n\t\"navajowhite\":          ColorNavajoWhite,\n\t\"oldlace\":              ColorOldLace,\n\t\"olivedrab\":            ColorOliveDrab,\n\t\"orange\":               ColorOrange,\n\t\"orangered\":            ColorOrangeRed,\n\t\"orchid\":               ColorOrchid,\n\t\"palegoldenrod\":        ColorPaleGoldenrod,\n\t\"palegreen\":            ColorPaleGreen,\n\t\"paleturquoise\":        ColorPaleTurquoise,\n\t\"palevioletred\":        ColorPaleVioletRed,\n\t\"papayawhip\":           ColorPapayaWhip,\n\t\"peachpuff\":            ColorPeachPuff,\n\t\"peru\":                 ColorPeru,\n\t\"pink\":                 ColorPink,\n\t\"plum\":                 ColorPlum,\n\t\"powderblue\":           ColorPowderBlue,\n\t\"rebeccapurple\":        ColorRebeccaPurple,\n\t\"rosybrown\":            ColorRosyBrown,\n\t\"royalblue\":            ColorRoyalBlue,\n\t\"saddlebrown\":          ColorSaddleBrown,\n\t\"salmon\":               ColorSalmon,\n\t\"sandybrown\":           ColorSandyBrown,\n\t\"seagreen\":             ColorSeaGreen,\n\t\"seashell\":             ColorSeashell,\n\t\"sienna\":               ColorSienna,\n\t\"skyblue\":              ColorSkyblue,\n\t\"slateblue\":            ColorSlateBlue,\n\t\"slategray\":            ColorSlateGray,\n\t\"snow\":                 ColorSnow,\n\t\"springgreen\":          ColorSpringGreen,\n\t\"steelblue\":            ColorSteelBlue,\n\t\"tan\":                  ColorTan,\n\t\"thistle\":              ColorThistle,\n\t\"tomato\":               ColorTomato,\n\t\"turquoise\":            ColorTurquoise,\n\t\"violet\":               ColorViolet,\n\t\"wheat\":                ColorWheat,\n\t\"whitesmoke\":           ColorWhiteSmoke,\n\t\"yellowgreen\":          ColorYellowGreen,\n\t\"grey\":                 ColorGray,\n\t\"dimgrey\":              ColorDimGray,\n\t\"darkgrey\":             ColorDarkGray,\n\t\"darkslategrey\":        ColorDarkSlateGray,\n\t\"lightgrey\":            ColorLightGray,\n\t\"lightslategrey\":       ColorLightSlateGray,\n\t\"slategrey\":            ColorSlateGray,\n}\n\n// Valid indicates the color is a valid value (has been set).\nfunc (c Color) Valid() bool {\n\treturn c&ColorValid != 0\n}\n\n// IsRGB is true if the color is an RGB specific value.\nfunc (c Color) IsRGB() bool {\n\treturn c&(ColorValid|ColorIsRGB) == (ColorValid | ColorIsRGB)\n}\n\n// CSS returns the CSS hex string ( #ABCDEF ) if valid\n// if not a valid color returns empty string\nfunc (c Color) CSS() string {\n\tif !c.Valid() {\n\t\treturn \"\"\n\t}\n\treturn fmt.Sprintf(\"#%06X\", c.Hex())\n}\n\n// String implements fmt.Stringer to return either the\n// W3C name if it has one or the CSS hex string '#ABCDEF'\nfunc (c Color) String() string {\n\tif !c.Valid() {\n\t\tswitch c {\n\t\tcase ColorNone:\n\t\t\treturn \"none\"\n\t\tcase ColorDefault:\n\t\t\treturn \"default\"\n\t\tcase ColorReset:\n\t\t\treturn \"reset\"\n\t\t}\n\t\treturn \"\"\n\t}\n\treturn c.Name(true)\n}\n\n// Name returns W3C name or an empty string if no arguments\n// if passed true as an argument it will falls back to\n// the CSS hex string if no W3C name found '#ABCDEF'\nfunc (c Color) Name(css ...bool) string {\n\tfor name, hex := range ColorNames {\n\t\tif c == hex {\n\t\t\treturn name\n\t\t}\n\t}\n\tif len(css) > 0 && css[0] {\n\t\treturn c.CSS()\n\t}\n\treturn \"\"\n}\n\n// Hex returns the color's hexadecimal RGB 24-bit value with each component\n// consisting of a single byte, R << 16 | G << 8 | B.  If the color\n// is unknown or unset, -1 is returned.\nfunc (c Color) Hex() int32 {\n\tif !c.Valid() {\n\t\treturn -1\n\t}\n\tif c&ColorIsRGB != 0 {\n\t\treturn int32(c & 0xffffff)\n\t}\n\tif v, ok := ColorValues[c]; ok {\n\t\treturn v\n\t}\n\treturn -1\n}\n\n// RGB returns the red, green, and blue components of the color, with\n// each component represented as a value 0-255.  In the event that the\n// color cannot be broken up (not set usually), -1 is returned for each value.\nfunc (c Color) RGB() (int32, int32, int32) {\n\tv := c.Hex()\n\tif v < 0 {\n\t\treturn -1, -1, -1\n\t}\n\treturn (v >> 16) & 0xff, (v >> 8) & 0xff, v & 0xff\n}\n\n// TrueColor returns the true color (RGB) version of the provided color.\n// This is useful for ensuring color accuracy when using named colors.\n// This will override terminal theme colors.\nfunc (c Color) TrueColor() Color {\n\tif !c.Valid() {\n\t\treturn ColorDefault\n\t}\n\tif c&ColorIsRGB != 0 {\n\t\treturn c | ColorValid\n\t}\n\treturn Color(c.Hex()) | ColorIsRGB | ColorValid\n}\n\n// NewRGBColor returns a new color with the given red, green, and blue values.\n// Each value must be represented in the range 0-255.\nfunc NewRGBColor(r, g, b int32) Color {\n\treturn NewHexColor(((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff))\n}\n\n// NewHexColor returns a color using the given 24-bit RGB value.\nfunc NewHexColor(v int32) Color {\n\treturn ColorIsRGB | Color(v) | ColorValid\n}\n\n// GetColor creates a Color from a color name (W3C name). A hex value may\n// be supplied as a string in the format \"#ffffff\".\nfunc GetColor(name string) Color {\n\tif c, ok := ColorNames[name]; ok {\n\t\treturn c\n\t}\n\tif len(name) == 7 && name[0] == '#' {\n\t\tif v, e := strconv.ParseInt(name[1:], 16, 32); e == nil {\n\t\t\treturn NewHexColor(int32(v))\n\t\t}\n\t}\n\treturn ColorDefault\n}\n\n// PaletteColor creates a color based on the palette index.\nfunc PaletteColor(index int) Color {\n\treturn Color(index) | ColorValid\n}\n\n// FromImageColor converts an image/color.Color into tcell.Color.\n// The alpha value is dropped, so it should be tracked separately if it is\n// needed.\nfunc FromImageColor(imageColor ic.Color) Color {\n\tr, g, b, _ := imageColor.RGBA()\n\t// NOTE image/color.Color RGB values range is [0, 0xFFFF] as uint32\n\treturn NewRGBColor(int32(r>>8), int32(g>>8), int32(b>>8))\n}\n"
        },
        {
          "name": "color_test.go",
          "type": "blob",
          "size": 4.7333984375,
          "content": "// Copyright 2023 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\tic \"image/color\"\n\t\"testing\"\n)\n\nfunc TestColorValues(t *testing.T) {\n\tvar values = []struct {\n\t\tcolor Color\n\t\thex   int32\n\t}{\n\t\t{ColorRed, 0xFF0000},\n\t\t{ColorGreen, 0x008000},\n\t\t{ColorLime, 0x00FF00},\n\t\t{ColorBlue, 0x0000FF},\n\t\t{ColorBlack, 0x000000},\n\t\t{ColorWhite, 0xFFFFFF},\n\t\t{ColorSilver, 0xC0C0C0},\n\t\t{ColorNavy, 0x000080},\n\t}\n\n\tfor _, tc := range values {\n\t\tif tc.color.Hex() != tc.hex {\n\t\t\tt.Errorf(\"Color: %x != %x\", tc.color.Hex(), tc.hex)\n\t\t}\n\n\t\tif tc.color.TrueColor().Hex() != tc.hex {\n\t\t\tt.Errorf(\"TrueColor %x != %x\", tc.color.TrueColor().Hex(), tc.hex)\n\t\t}\n\t}\n}\n\nfunc TestColorFitting(t *testing.T) {\n\tvar pal []Color\n\tfor i := 0; i < 255; i++ {\n\t\tpal = append(pal, PaletteColor(i))\n\t}\n\n\t// Exact color fitting on ANSI colors\n\tfor i := 0; i < 7; i++ {\n\t\tif FindColor(PaletteColor(i), pal[:8]) != PaletteColor(i) {\n\t\t\tt.Errorf(\"Color ANSI fit fail at %d\", i)\n\t\t}\n\t}\n\t// Grey is closest to Silver\n\tif FindColor(PaletteColor(8), pal[:8]) != PaletteColor(7) {\n\t\tt.Errorf(\"Grey does not fit to silver\")\n\t}\n\t// Color fitting of upper 8 colors.\n\tfor i := 9; i < 16; i++ {\n\t\tif FindColor(PaletteColor(i), pal[:8]) != PaletteColor(i%8) {\n\t\t\tt.Errorf(\"Color fit fail at %d\", i)\n\t\t}\n\t}\n\t// Imperfect fit\n\tif FindColor(ColorOrangeRed, pal[:16]) != ColorRed ||\n\t\tFindColor(ColorAliceBlue, pal[:16]) != ColorWhite ||\n\t\tFindColor(ColorPink, pal) != Color217 ||\n\t\tFindColor(ColorSienna, pal) != Color173 ||\n\t\tFindColor(GetColor(\"#00FD00\"), pal) != ColorLime {\n\t\tt.Errorf(\"Imperfect color fit\")\n\t}\n\n}\n\nfunc TestColorNameLookup(t *testing.T) {\n\tvar values = []struct {\n\t\tname  string\n\t\tcolor Color\n\t\trgb   bool\n\t}{\n\t\t{\"#FF0000\", ColorRed, true},\n\t\t{\"black\", ColorBlack, false},\n\t\t{\"orange\", ColorOrange, true},\n\t\t{\"door\", ColorDefault, false},\n\t}\n\tfor _, v := range values {\n\t\tc := GetColor(v.name)\n\t\tif c.Hex() != v.color.Hex() {\n\t\t\tt.Errorf(\"Wrong color for %v: %v\", v.name, c.Hex())\n\t\t}\n\t\tif v.rgb {\n\t\t\tif c&ColorIsRGB == 0 {\n\t\t\t\tt.Errorf(\"Color should have RGB: %v\", v.name)\n\t\t\t}\n\t\t} else {\n\t\t\tif c&ColorIsRGB != 0 {\n\t\t\t\tt.Errorf(\"Named color should not be RGB: %v\", v.name)\n\t\t\t}\n\t\t}\n\n\t\tif c.TrueColor().Hex() != v.color.Hex() {\n\t\t\tt.Errorf(\"TrueColor did not match\")\n\t\t}\n\t}\n\n\t// these colors only have strings (for debugging), you cannot use them to create a color\n\tif ColorNone.String() != \"none\" {\n\t\tt.Errorf(\"ColorNone did not match\")\n\t}\n\tif ColorReset.String() != \"reset\" {\n\t\tt.Errorf(\"ColorReset did not match\")\n\t}\n\tif ColorDefault.String() != \"default\" {\n\t\tt.Errorf(\"ColorDefault did not match\")\n\t}\n}\n\nfunc TestColorRGB(t *testing.T) {\n\tr, g, b := GetColor(\"#112233\").RGB()\n\tif r != 0x11 || g != 0x22 || b != 0x33 {\n\t\tt.Errorf(\"RGB wrong (%x, %x, %x)\", r, g, b)\n\t}\n}\n\nfunc TestFromImageColor(t *testing.T) {\n\tred := ic.RGBA{0xFF, 0x00, 0x00, 0x00}\n\twhite := ic.Gray{0xFF}\n\tcyan := ic.CMYK{0xFF, 0x00, 0x00, 0x00}\n\n\tif hex := FromImageColor(red).Hex(); hex != 0xFF0000 {\n\t\tt.Errorf(\"%v is not 0xFF0000\", hex)\n\t}\n\tif hex := FromImageColor(white).Hex(); hex != 0xFFFFFF {\n\t\tt.Errorf(\"%v is not 0xFFFFFF\", hex)\n\t}\n\tif hex := FromImageColor(cyan).Hex(); hex != 0x00FFFF {\n\t\tt.Errorf(\"%v is not 0x00FFFF\", hex)\n\t}\n}\n\nfunc TestColorNone(t *testing.T) {\n\ts := mkTestScreen(t, \"\")\n\ts.Init()\n\ts.SetSize(80, 24)\n\tst := StyleDefault.Foreground(ColorBlack).Background(ColorWhite)\n\ts.Fill(' ', st)\n\tif _, _, s1, _ := s.GetContent(0, 0); s1 != st {\n\t\tt.Errorf(\"Wrong style! fg %s bg %s\", s1.fg.String(), s1.bg.String())\n\t}\n\tst2 := st.Foreground(ColorNone).Background(ColorNone)\n\ts.Fill('X', st2)\n\tif _, _, s1, _ := s.GetContent(0, 0); s1 != st {\n\t\tt.Errorf(\"Wrong style! fg %s bg %s\", s1.fg.String(), s1.bg.String())\n\t}\n\tred := st.Foreground(ColorRed).Background(ColorNone)\n\ts.SetContent(1, 0, ' ', nil, red)\n\tif _, _, s1, _ := s.GetContent(1, 0); s1 != red.Background(st.bg) {\n\t\tt.Errorf(\"Wrong style! fg %s bg %s\", s1.fg.String(), s1.bg.String())\n\t}\n\tif _, _, s1, _ := s.GetContent(0, 0); s1 != st {\n\t\tt.Errorf(\"Wrong style! fg %s bg %s\", s1.fg.String(), s1.bg.String())\n\t}\n\tpink := st.Background(ColorPink).Foreground(ColorNone)\n\ts.SetContent(1, 0, ' ', nil, pink)\n\tcombined := pink.Foreground(ColorRed)\n\n\tif _, _, s1, _ := s.GetContent(1, 0); s1 != combined {\n\t\tt.Errorf(\"Wrong style! fg %s bg %s\", s1.fg.String(), s1.bg.String())\n\t}\n}\n"
        },
        {
          "name": "colorfit.go",
          "type": "blob",
          "size": 1.4072265625,
          "content": "// Copyright 2016 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"math\"\n\n\t\"github.com/lucasb-eyer/go-colorful\"\n)\n\n// FindColor attempts to find a given color, or the best match possible for it,\n// from the palette given.  This is an expensive operation, so results should\n// be cached by the caller.\nfunc FindColor(c Color, palette []Color) Color {\n\tmatch := ColorDefault\n\tdist := float64(0)\n\tr, g, b := c.RGB()\n\tc1 := colorful.Color{\n\t\tR: float64(r) / 255.0,\n\t\tG: float64(g) / 255.0,\n\t\tB: float64(b) / 255.0,\n\t}\n\tfor _, d := range palette {\n\t\tr, g, b = d.RGB()\n\t\tc2 := colorful.Color{\n\t\t\tR: float64(r) / 255.0,\n\t\t\tG: float64(g) / 255.0,\n\t\t\tB: float64(b) / 255.0,\n\t\t}\n\t\t// CIE94 is more accurate, but really really expensive.\n\t\tnd := c1.DistanceCIE76(c2)\n\t\tif math.IsNaN(nd) {\n\t\t\tnd = math.Inf(1)\n\t\t}\n\t\tif match == ColorDefault || nd < dist {\n\t\t\tmatch = d\n\t\t\tdist = nd\n\t\t}\n\t}\n\treturn match\n}\n"
        },
        {
          "name": "console_stub.go",
          "type": "blob",
          "size": 0.8330078125,
          "content": "//go:build !windows\n// +build !windows\n\n// Copyright 2015 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\n// NewConsoleScreen returns a console based screen.  This platform\n// doesn't have support for any, so it returns nil and a suitable error.\nfunc NewConsoleScreen() (Screen, error) {\n\treturn nil, ErrNoScreen\n}\n"
        },
        {
          "name": "console_win.go",
          "type": "blob",
          "size": 30.2763671875,
          "content": "//go:build windows\n// +build windows\n\n// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"unicode/utf16\"\n\t\"unsafe\"\n)\n\ntype cScreen struct {\n\tin         syscall.Handle\n\tout        syscall.Handle\n\tcancelflag syscall.Handle\n\tscandone   chan struct{}\n\tquit       chan struct{}\n\tcurx       int\n\tcury       int\n\tstyle      Style\n\tfini       bool\n\tvten       bool\n\ttruecolor  bool\n\trunning    bool\n\tdisableAlt bool // disable the alternate screen\n\ttitle      string\n\n\tw int\n\th int\n\n\toscreen     consoleInfo\n\tocursor     cursorInfo\n\tcursorStyle CursorStyle\n\tcursorColor Color\n\toimode      uint32\n\toomode      uint32\n\tcells       CellBuffer\n\tfocusEnable bool\n\n\tmouseEnabled bool\n\twg           sync.WaitGroup\n\teventQ       chan Event\n\tstopQ        chan struct{}\n\tfiniOnce     sync.Once\n\n\tsync.Mutex\n}\n\nvar winLock sync.Mutex\n\nvar winPalette = []Color{\n\tColorBlack,\n\tColorMaroon,\n\tColorGreen,\n\tColorNavy,\n\tColorOlive,\n\tColorPurple,\n\tColorTeal,\n\tColorSilver,\n\tColorGray,\n\tColorRed,\n\tColorLime,\n\tColorBlue,\n\tColorYellow,\n\tColorFuchsia,\n\tColorAqua,\n\tColorWhite,\n}\n\nvar winColors = map[Color]Color{\n\tColorBlack:   ColorBlack,\n\tColorMaroon:  ColorMaroon,\n\tColorGreen:   ColorGreen,\n\tColorNavy:    ColorNavy,\n\tColorOlive:   ColorOlive,\n\tColorPurple:  ColorPurple,\n\tColorTeal:    ColorTeal,\n\tColorSilver:  ColorSilver,\n\tColorGray:    ColorGray,\n\tColorRed:     ColorRed,\n\tColorLime:    ColorLime,\n\tColorBlue:    ColorBlue,\n\tColorYellow:  ColorYellow,\n\tColorFuchsia: ColorFuchsia,\n\tColorAqua:    ColorAqua,\n\tColorWhite:   ColorWhite,\n}\n\nvar (\n\tk32 = syscall.NewLazyDLL(\"kernel32.dll\")\n\tu32 = syscall.NewLazyDLL(\"user32.dll\")\n)\n\n// We have to bring in the kernel32 and user32 DLLs directly, so we can get\n// access to some system calls that the core Go API lacks.\n//\n// Note that Windows appends some functions with W to indicate that wide\n// characters (Unicode) are in use.  The documentation refers to them\n// without this suffix, as the resolution is made via preprocessor.\nvar (\n\tprocReadConsoleInput            = k32.NewProc(\"ReadConsoleInputW\")\n\tprocWaitForMultipleObjects      = k32.NewProc(\"WaitForMultipleObjects\")\n\tprocCreateEvent                 = k32.NewProc(\"CreateEventW\")\n\tprocSetEvent                    = k32.NewProc(\"SetEvent\")\n\tprocGetConsoleCursorInfo        = k32.NewProc(\"GetConsoleCursorInfo\")\n\tprocSetConsoleCursorInfo        = k32.NewProc(\"SetConsoleCursorInfo\")\n\tprocSetConsoleCursorPosition    = k32.NewProc(\"SetConsoleCursorPosition\")\n\tprocSetConsoleMode              = k32.NewProc(\"SetConsoleMode\")\n\tprocGetConsoleMode              = k32.NewProc(\"GetConsoleMode\")\n\tprocGetConsoleScreenBufferInfo  = k32.NewProc(\"GetConsoleScreenBufferInfo\")\n\tprocFillConsoleOutputAttribute  = k32.NewProc(\"FillConsoleOutputAttribute\")\n\tprocFillConsoleOutputCharacter  = k32.NewProc(\"FillConsoleOutputCharacterW\")\n\tprocSetConsoleWindowInfo        = k32.NewProc(\"SetConsoleWindowInfo\")\n\tprocSetConsoleScreenBufferSize  = k32.NewProc(\"SetConsoleScreenBufferSize\")\n\tprocSetConsoleTextAttribute     = k32.NewProc(\"SetConsoleTextAttribute\")\n\tprocGetLargestConsoleWindowSize = k32.NewProc(\"GetLargestConsoleWindowSize\")\n\tprocMessageBeep                 = u32.NewProc(\"MessageBeep\")\n)\n\nconst (\n\tw32Infinite    = ^uintptr(0)\n\tw32WaitObject0 = uintptr(0)\n)\n\nconst (\n\t// VT100/XTerm escapes understood by the console\n\tvtShowCursor              = \"\\x1b[?25h\"\n\tvtHideCursor              = \"\\x1b[?25l\"\n\tvtCursorPos               = \"\\x1b[%d;%dH\" // Note that it is Y then X\n\tvtSgr0                    = \"\\x1b[0m\"\n\tvtBold                    = \"\\x1b[1m\"\n\tvtUnderline               = \"\\x1b[4m\"\n\tvtBlink                   = \"\\x1b[5m\" // Not sure if this is processed\n\tvtReverse                 = \"\\x1b[7m\"\n\tvtSetFg                   = \"\\x1b[38;5;%dm\"\n\tvtSetBg                   = \"\\x1b[48;5;%dm\"\n\tvtSetFgRGB                = \"\\x1b[38;2;%d;%d;%dm\" // RGB\n\tvtSetBgRGB                = \"\\x1b[48;2;%d;%d;%dm\" // RGB\n\tvtCursorDefault           = \"\\x1b[0 q\"\n\tvtCursorBlinkingBlock     = \"\\x1b[1 q\"\n\tvtCursorSteadyBlock       = \"\\x1b[2 q\"\n\tvtCursorBlinkingUnderline = \"\\x1b[3 q\"\n\tvtCursorSteadyUnderline   = \"\\x1b[4 q\"\n\tvtCursorBlinkingBar       = \"\\x1b[5 q\"\n\tvtCursorSteadyBar         = \"\\x1b[6 q\"\n\tvtDisableAm               = \"\\x1b[?7l\"\n\tvtEnableAm                = \"\\x1b[?7h\"\n\tvtEnterCA                 = \"\\x1b[?1049h\\x1b[22;0;0t\"\n\tvtExitCA                  = \"\\x1b[?1049l\\x1b[23;0;0t\"\n\tvtDoubleUnderline         = \"\\x1b[4:2m\"\n\tvtCurlyUnderline          = \"\\x1b[4:3m\"\n\tvtDottedUnderline         = \"\\x1b[4:4m\"\n\tvtDashedUnderline         = \"\\x1b[4:5m\"\n\tvtUnderColor              = \"\\x1b[58:5:%dm\"\n\tvtUnderColorRGB           = \"\\x1b[58:2::%d:%d:%dm\"\n\tvtUnderColorReset         = \"\\x1b[59m\"\n\tvtEnterUrl                = \"\\x1b]8;%s;%s\\x1b\\\\\" // NB arg 1 is id, arg 2 is url\n\tvtExitUrl                 = \"\\x1b]8;;\\x1b\\\\\"\n\tvtCursorColorRGB          = \"\\x1b]12;#%02x%02x%02x\\007\"\n\tvtCursorColorReset        = \"\\x1b]112\\007\"\n\tvtSaveTitle               = \"\\x1b[22;2t\"\n\tvtRestoreTitle            = \"\\x1b[23;2t\"\n\tvtSetTitle                = \"\\x1b]2;%s\\x1b\\\\\"\n)\n\nvar vtCursorStyles = map[CursorStyle]string{\n\tCursorStyleDefault:           vtCursorDefault,\n\tCursorStyleBlinkingBlock:     vtCursorBlinkingBlock,\n\tCursorStyleSteadyBlock:       vtCursorSteadyBlock,\n\tCursorStyleBlinkingUnderline: vtCursorBlinkingUnderline,\n\tCursorStyleSteadyUnderline:   vtCursorSteadyUnderline,\n\tCursorStyleBlinkingBar:       vtCursorBlinkingBar,\n\tCursorStyleSteadyBar:         vtCursorSteadyBar,\n}\n\n// NewConsoleScreen returns a Screen for the Windows console associated\n// with the current process.  The Screen makes use of the Windows Console\n// API to display content and read events.\nfunc NewConsoleScreen() (Screen, error) {\n\treturn &baseScreen{screenImpl: &cScreen{}}, nil\n}\n\nfunc (s *cScreen) Init() error {\n\ts.eventQ = make(chan Event, 10)\n\ts.quit = make(chan struct{})\n\ts.scandone = make(chan struct{})\n\tin, e := syscall.Open(\"CONIN$\", syscall.O_RDWR, 0)\n\tif e != nil {\n\t\treturn e\n\t}\n\ts.in = in\n\tout, e := syscall.Open(\"CONOUT$\", syscall.O_RDWR, 0)\n\tif e != nil {\n\t\t_ = syscall.Close(s.in)\n\t\treturn e\n\t}\n\ts.out = out\n\n\ts.truecolor = true\n\n\t// ConEmu handling of colors and scrolling when in VT output mode is extremely poor.\n\t// The color palette will scroll even though characters do not, when\n\t// emitting stuff for the last character.  In the future we might change this to\n\t// look at specific versions of ConEmu if they fix the bug.\n\t// We can also try disabling auto margin mode.\n\ttryVt := true\n\tif os.Getenv(\"ConEmuPID\") != \"\" {\n\t\ts.truecolor = false\n\t\ttryVt = false\n\t}\n\tswitch os.Getenv(\"TCELL_TRUECOLOR\") {\n\tcase \"disable\":\n\t\ts.truecolor = false\n\tcase \"enable\":\n\t\ts.truecolor = true\n\t\ttryVt = true\n\t}\n\n\ts.Lock()\n\n\ts.curx = -1\n\ts.cury = -1\n\ts.style = StyleDefault\n\ts.getCursorInfo(&s.ocursor)\n\ts.getConsoleInfo(&s.oscreen)\n\ts.getOutMode(&s.oomode)\n\ts.getInMode(&s.oimode)\n\ts.resize()\n\n\ts.fini = false\n\ts.setInMode(modeResizeEn | modeExtendFlg)\n\n\t// If a user needs to force old style console, they may do so\n\t// by setting TCELL_VTMODE to disable.  This is an undocumented safety net for now.\n\t// It may be removed in the future.  (This mostly exists because of ConEmu.)\n\tswitch os.Getenv(\"TCELL_VTMODE\") {\n\tcase \"disable\":\n\t\ttryVt = false\n\tcase \"enable\":\n\t\ttryVt = true\n\t}\n\tswitch os.Getenv(\"TCELL_ALTSCREEN\") {\n\tcase \"enable\":\n\t\ts.disableAlt = false // also the default\n\tcase \"disable\":\n\t\ts.disableAlt = true\n\t}\n\tif tryVt {\n\t\ts.setOutMode(modeVtOutput | modeNoAutoNL | modeCookedOut | modeUnderline)\n\t\tvar om uint32\n\t\ts.getOutMode(&om)\n\t\tif om&modeVtOutput == modeVtOutput {\n\t\t\ts.vten = true\n\t\t} else {\n\t\t\ts.truecolor = false\n\t\t\ts.setOutMode(0)\n\t\t}\n\t} else {\n\t\ts.setOutMode(0)\n\t}\n\n\ts.Unlock()\n\n\treturn s.engage()\n}\n\nfunc (s *cScreen) CharacterSet() string {\n\t// We are always UTF-16LE on Windows\n\treturn \"UTF-16LE\"\n}\n\nfunc (s *cScreen) EnableMouse(...MouseFlags) {\n\ts.Lock()\n\ts.mouseEnabled = true\n\ts.enableMouse(true)\n\ts.Unlock()\n}\n\nfunc (s *cScreen) DisableMouse() {\n\ts.Lock()\n\ts.mouseEnabled = false\n\ts.enableMouse(false)\n\ts.Unlock()\n}\n\nfunc (s *cScreen) enableMouse(on bool) {\n\tif on {\n\t\ts.setInMode(modeResizeEn | modeMouseEn | modeExtendFlg)\n\t} else {\n\t\ts.setInMode(modeResizeEn | modeExtendFlg)\n\t}\n}\n\n// Windows lacks bracketed paste (for now)\n\nfunc (s *cScreen) EnablePaste() {}\n\nfunc (s *cScreen) DisablePaste() {}\n\nfunc (s *cScreen) EnableFocus() {\n\ts.Lock()\n\ts.focusEnable = true\n\ts.Unlock()\n}\n\nfunc (s *cScreen) DisableFocus() {\n\ts.Lock()\n\ts.focusEnable = false\n\ts.Unlock()\n}\n\nfunc (s *cScreen) Fini() {\n\ts.finiOnce.Do(func() {\n\t\tclose(s.quit)\n\t\ts.disengage()\n\t})\n}\n\nfunc (s *cScreen) disengage() {\n\ts.Lock()\n\tif !s.running {\n\t\ts.Unlock()\n\t\treturn\n\t}\n\ts.running = false\n\tstopQ := s.stopQ\n\t_, _, _ = procSetEvent.Call(uintptr(s.cancelflag))\n\tclose(stopQ)\n\ts.Unlock()\n\n\ts.wg.Wait()\n\n\tif s.vten {\n\t\ts.emitVtString(vtCursorStyles[CursorStyleDefault])\n\t\ts.emitVtString(vtCursorColorReset)\n\t\ts.emitVtString(vtEnableAm)\n\t\tif !s.disableAlt {\n\t\t\ts.emitVtString(vtRestoreTitle)\n\t\t\ts.emitVtString(vtExitCA)\n\t\t}\n\t} else if !s.disableAlt {\n\t\ts.clearScreen(StyleDefault, s.vten)\n\t\ts.setCursorPos(0, 0, false)\n\t}\n\ts.setCursorInfo(&s.ocursor)\n\ts.setBufferSize(int(s.oscreen.size.x), int(s.oscreen.size.y))\n\ts.setInMode(s.oimode)\n\ts.setOutMode(s.oomode)\n\t_, _, _ = procSetConsoleTextAttribute.Call(\n\t\tuintptr(s.out),\n\t\tuintptr(s.mapStyle(StyleDefault)))\n}\n\nfunc (s *cScreen) engage() error {\n\ts.Lock()\n\tdefer s.Unlock()\n\tif s.running {\n\t\treturn errors.New(\"already engaged\")\n\t}\n\ts.stopQ = make(chan struct{})\n\tcf, _, e := procCreateEvent.Call(\n\t\tuintptr(0),\n\t\tuintptr(1),\n\t\tuintptr(0),\n\t\tuintptr(0))\n\tif cf == uintptr(0) {\n\t\treturn e\n\t}\n\ts.running = true\n\ts.cancelflag = syscall.Handle(cf)\n\ts.enableMouse(s.mouseEnabled)\n\n\tif s.vten {\n\t\ts.setOutMode(modeVtOutput | modeNoAutoNL | modeCookedOut | modeUnderline)\n\t\tif !s.disableAlt {\n\t\t\ts.emitVtString(vtSaveTitle)\n\t\t\ts.emitVtString(vtEnterCA)\n\t\t}\n\t\ts.emitVtString(vtDisableAm)\n\t\tif s.title != \"\" {\n\t\t\ts.emitVtString(fmt.Sprintf(vtSetTitle, s.title))\n\t\t}\n\t} else {\n\t\ts.setOutMode(0)\n\t}\n\n\ts.clearScreen(s.style, s.vten)\n\ts.hideCursor()\n\n\ts.cells.Invalidate()\n\ts.hideCursor()\n\ts.resize()\n\ts.draw()\n\ts.doCursor()\n\n\ts.wg.Add(1)\n\tgo s.scanInput(s.stopQ)\n\treturn nil\n}\n\ntype cursorInfo struct {\n\tsize    uint32\n\tvisible uint32\n}\n\ntype coord struct {\n\tx int16\n\ty int16\n}\n\nfunc (c coord) uintptr() uintptr {\n\t// little endian, put x first\n\treturn uintptr(c.x) | (uintptr(c.y) << 16)\n}\n\ntype rect struct {\n\tleft   int16\n\ttop    int16\n\tright  int16\n\tbottom int16\n}\n\nfunc (s *cScreen) emitVtString(vs string) {\n\tesc := utf16.Encode([]rune(vs))\n\t_ = syscall.WriteConsole(s.out, &esc[0], uint32(len(esc)), nil, nil)\n}\n\nfunc (s *cScreen) showCursor() {\n\tif s.vten {\n\t\ts.emitVtString(vtShowCursor)\n\t\ts.emitVtString(vtCursorStyles[s.cursorStyle])\n\t\tif s.cursorColor == ColorReset {\n\t\t\ts.emitVtString(vtCursorColorReset)\n\t\t} else if s.cursorColor.Valid() {\n\t\t\tr, g, b := s.cursorColor.RGB()\n\t\t\ts.emitVtString(fmt.Sprintf(vtCursorColorRGB, r, g, b))\n\t\t}\n\t} else {\n\t\ts.setCursorInfo(&cursorInfo{size: 100, visible: 1})\n\t}\n}\n\nfunc (s *cScreen) hideCursor() {\n\tif s.vten {\n\t\ts.emitVtString(vtHideCursor)\n\t} else {\n\t\ts.setCursorInfo(&cursorInfo{size: 1, visible: 0})\n\t}\n}\n\nfunc (s *cScreen) ShowCursor(x, y int) {\n\ts.Lock()\n\tif !s.fini {\n\t\ts.curx = x\n\t\ts.cury = y\n\t}\n\ts.doCursor()\n\ts.Unlock()\n}\n\nfunc (s *cScreen) SetCursor(cs CursorStyle, cc Color) {\n\ts.Lock()\n\tif !s.fini {\n\t\tif _, ok := vtCursorStyles[cs]; ok {\n\t\t\ts.cursorStyle = cs\n\t\t\ts.cursorColor = cc\n\t\t\ts.doCursor()\n\t\t}\n\t}\n\ts.Unlock()\n}\n\nfunc (s *cScreen) doCursor() {\n\tx, y := s.curx, s.cury\n\n\tif x < 0 || y < 0 || x >= s.w || y >= s.h {\n\t\ts.hideCursor()\n\t} else {\n\t\ts.setCursorPos(x, y, s.vten)\n\t\ts.showCursor()\n\t}\n}\n\nfunc (s *cScreen) HideCursor() {\n\ts.ShowCursor(-1, -1)\n}\n\ntype inputRecord struct {\n\ttyp  uint16\n\t_    uint16\n\tdata [16]byte\n}\n\nconst (\n\tkeyEvent    uint16 = 1\n\tmouseEvent  uint16 = 2\n\tresizeEvent uint16 = 4\n\tmenuEvent   uint16 = 8 // don't use\n\tfocusEvent  uint16 = 16\n)\n\ntype mouseRecord struct {\n\tx     int16\n\ty     int16\n\tbtns  uint32\n\tmod   uint32\n\tflags uint32\n}\n\ntype focusRecord struct {\n\tfocused int32 // actually BOOL\n}\n\nconst (\n\tmouseHWheeled uint32 = 0x8\n\tmouseVWheeled uint32 = 0x4\n\t// mouseDoubleClick uint32 = 0x2\n\t// mouseMoved       uint32 = 0x1\n)\n\ntype resizeRecord struct {\n\tx int16\n\ty int16\n}\n\ntype keyRecord struct {\n\tisdown int32\n\trepeat uint16\n\tkcode  uint16\n\tscode  uint16\n\tch     uint16\n\tmod    uint32\n}\n\nconst (\n\t// Constants per Microsoft.  We don't put the modifiers\n\t// here.\n\tvkCancel = 0x03\n\tvkBack   = 0x08 // Backspace\n\tvkTab    = 0x09\n\tvkClear  = 0x0c\n\tvkReturn = 0x0d\n\tvkPause  = 0x13\n\tvkEscape = 0x1b\n\tvkSpace  = 0x20\n\tvkPrior  = 0x21 // PgUp\n\tvkNext   = 0x22 // PgDn\n\tvkEnd    = 0x23\n\tvkHome   = 0x24\n\tvkLeft   = 0x25\n\tvkUp     = 0x26\n\tvkRight  = 0x27\n\tvkDown   = 0x28\n\tvkPrint  = 0x2a\n\tvkPrtScr = 0x2c\n\tvkInsert = 0x2d\n\tvkDelete = 0x2e\n\tvkHelp   = 0x2f\n\tvkF1     = 0x70\n\tvkF2     = 0x71\n\tvkF3     = 0x72\n\tvkF4     = 0x73\n\tvkF5     = 0x74\n\tvkF6     = 0x75\n\tvkF7     = 0x76\n\tvkF8     = 0x77\n\tvkF9     = 0x78\n\tvkF10    = 0x79\n\tvkF11    = 0x7a\n\tvkF12    = 0x7b\n\tvkF13    = 0x7c\n\tvkF14    = 0x7d\n\tvkF15    = 0x7e\n\tvkF16    = 0x7f\n\tvkF17    = 0x80\n\tvkF18    = 0x81\n\tvkF19    = 0x82\n\tvkF20    = 0x83\n\tvkF21    = 0x84\n\tvkF22    = 0x85\n\tvkF23    = 0x86\n\tvkF24    = 0x87\n)\n\nvar vkKeys = map[uint16]Key{\n\tvkCancel: KeyCancel,\n\tvkBack:   KeyBackspace,\n\tvkTab:    KeyTab,\n\tvkClear:  KeyClear,\n\tvkPause:  KeyPause,\n\tvkPrint:  KeyPrint,\n\tvkPrtScr: KeyPrint,\n\tvkPrior:  KeyPgUp,\n\tvkNext:   KeyPgDn,\n\tvkReturn: KeyEnter,\n\tvkEnd:    KeyEnd,\n\tvkHome:   KeyHome,\n\tvkLeft:   KeyLeft,\n\tvkUp:     KeyUp,\n\tvkRight:  KeyRight,\n\tvkDown:   KeyDown,\n\tvkInsert: KeyInsert,\n\tvkDelete: KeyDelete,\n\tvkHelp:   KeyHelp,\n\tvkEscape: KeyEscape,\n\tvkSpace:  ' ',\n\tvkF1:     KeyF1,\n\tvkF2:     KeyF2,\n\tvkF3:     KeyF3,\n\tvkF4:     KeyF4,\n\tvkF5:     KeyF5,\n\tvkF6:     KeyF6,\n\tvkF7:     KeyF7,\n\tvkF8:     KeyF8,\n\tvkF9:     KeyF9,\n\tvkF10:    KeyF10,\n\tvkF11:    KeyF11,\n\tvkF12:    KeyF12,\n\tvkF13:    KeyF13,\n\tvkF14:    KeyF14,\n\tvkF15:    KeyF15,\n\tvkF16:    KeyF16,\n\tvkF17:    KeyF17,\n\tvkF18:    KeyF18,\n\tvkF19:    KeyF19,\n\tvkF20:    KeyF20,\n\tvkF21:    KeyF21,\n\tvkF22:    KeyF22,\n\tvkF23:    KeyF23,\n\tvkF24:    KeyF24,\n}\n\n// NB: All Windows platforms are little endian.  We assume this\n// never, ever change.  The following code is endian safe. and does\n// not use unsafe pointers.\nfunc getu32(v []byte) uint32 {\n\treturn uint32(v[0]) + (uint32(v[1]) << 8) + (uint32(v[2]) << 16) + (uint32(v[3]) << 24)\n}\nfunc geti32(v []byte) int32 {\n\treturn int32(getu32(v))\n}\nfunc getu16(v []byte) uint16 {\n\treturn uint16(v[0]) + (uint16(v[1]) << 8)\n}\nfunc geti16(v []byte) int16 {\n\treturn int16(getu16(v))\n}\n\n// Convert windows dwControlKeyState to modifier mask\nfunc mod2mask(cks uint32) ModMask {\n\tmm := ModNone\n\t// Left or right control\n\tctrl := (cks & (0x0008 | 0x0004)) != 0\n\t// Left or right alt\n\talt := (cks & (0x0002 | 0x0001)) != 0\n\t// Filter out ctrl+alt (it means AltGr)\n\tif !(ctrl && alt) {\n\t\tif ctrl {\n\t\t\tmm |= ModCtrl\n\t\t}\n\t\tif alt {\n\t\t\tmm |= ModAlt\n\t\t}\n\t}\n\t// Any shift\n\tif (cks & 0x0010) != 0 {\n\t\tmm |= ModShift\n\t}\n\treturn mm\n}\n\nfunc mrec2btns(mbtns, flags uint32) ButtonMask {\n\tbtns := ButtonNone\n\tif mbtns&0x1 != 0 {\n\t\tbtns |= Button1\n\t}\n\tif mbtns&0x2 != 0 {\n\t\tbtns |= Button2\n\t}\n\tif mbtns&0x4 != 0 {\n\t\tbtns |= Button3\n\t}\n\tif mbtns&0x8 != 0 {\n\t\tbtns |= Button4\n\t}\n\tif mbtns&0x10 != 0 {\n\t\tbtns |= Button5\n\t}\n\tif mbtns&0x20 != 0 {\n\t\tbtns |= Button6\n\t}\n\tif mbtns&0x40 != 0 {\n\t\tbtns |= Button7\n\t}\n\tif mbtns&0x80 != 0 {\n\t\tbtns |= Button8\n\t}\n\n\tif flags&mouseVWheeled != 0 {\n\t\tif mbtns&0x80000000 == 0 {\n\t\t\tbtns |= WheelUp\n\t\t} else {\n\t\t\tbtns |= WheelDown\n\t\t}\n\t}\n\tif flags&mouseHWheeled != 0 {\n\t\tif mbtns&0x80000000 == 0 {\n\t\t\tbtns |= WheelRight\n\t\t} else {\n\t\t\tbtns |= WheelLeft\n\t\t}\n\t}\n\treturn btns\n}\n\nfunc (s *cScreen) postEvent(ev Event) {\n\tselect {\n\tcase s.eventQ <- ev:\n\tcase <-s.quit:\n\t}\n}\n\nfunc (s *cScreen) getConsoleInput() error {\n\t// cancelFlag comes first as WaitForMultipleObjects returns the lowest index\n\t// in the event that both events are signalled.\n\twaitObjects := []syscall.Handle{s.cancelflag, s.in}\n\t// As arrays are contiguous in memory, a pointer to the first object is the\n\t// same as a pointer to the array itself.\n\tpWaitObjects := unsafe.Pointer(&waitObjects[0])\n\n\trv, _, er := procWaitForMultipleObjects.Call(\n\t\tuintptr(len(waitObjects)),\n\t\tuintptr(pWaitObjects),\n\t\tuintptr(0),\n\t\tw32Infinite)\n\t// WaitForMultipleObjects returns WAIT_OBJECT_0 + the index.\n\tswitch rv {\n\tcase w32WaitObject0: // s.cancelFlag\n\t\treturn errors.New(\"cancelled\")\n\tcase w32WaitObject0 + 1: // s.in\n\t\trec := &inputRecord{}\n\t\tvar nrec int32\n\t\trv, _, er := procReadConsoleInput.Call(\n\t\t\tuintptr(s.in),\n\t\t\tuintptr(unsafe.Pointer(rec)),\n\t\t\tuintptr(1),\n\t\t\tuintptr(unsafe.Pointer(&nrec)))\n\t\tif rv == 0 {\n\t\t\treturn er\n\t\t}\n\t\tif nrec != 1 {\n\t\t\treturn nil\n\t\t}\n\t\tswitch rec.typ {\n\t\tcase keyEvent:\n\t\t\tkrec := &keyRecord{}\n\t\t\tkrec.isdown = geti32(rec.data[0:])\n\t\t\tkrec.repeat = getu16(rec.data[4:])\n\t\t\tkrec.kcode = getu16(rec.data[6:])\n\t\t\tkrec.scode = getu16(rec.data[8:])\n\t\t\tkrec.ch = getu16(rec.data[10:])\n\t\t\tkrec.mod = getu32(rec.data[12:])\n\n\t\t\tif krec.isdown == 0 || krec.repeat < 1 {\n\t\t\t\t// it's a key release event, ignore it\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif krec.ch != 0 {\n\t\t\t\t// synthesized key code\n\t\t\t\tfor krec.repeat > 0 {\n\t\t\t\t\t// convert shift+tab to backtab\n\t\t\t\t\tif mod2mask(krec.mod) == ModShift && krec.ch == vkTab {\n\t\t\t\t\t\ts.postEvent(NewEventKey(KeyBacktab, 0, ModNone))\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts.postEvent(NewEventKey(KeyRune, rune(krec.ch), mod2mask(krec.mod)))\n\t\t\t\t\t}\n\t\t\t\t\tkrec.repeat--\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tkey := KeyNUL // impossible on Windows\n\t\t\tok := false\n\t\t\tif key, ok = vkKeys[krec.kcode]; !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tfor krec.repeat > 0 {\n\t\t\t\ts.postEvent(NewEventKey(key, rune(krec.ch), mod2mask(krec.mod)))\n\t\t\t\tkrec.repeat--\n\t\t\t}\n\n\t\tcase mouseEvent:\n\t\t\tvar mrec mouseRecord\n\t\t\tmrec.x = geti16(rec.data[0:])\n\t\t\tmrec.y = geti16(rec.data[2:])\n\t\t\tmrec.btns = getu32(rec.data[4:])\n\t\t\tmrec.mod = getu32(rec.data[8:])\n\t\t\tmrec.flags = getu32(rec.data[12:])\n\t\t\tbtns := mrec2btns(mrec.btns, mrec.flags)\n\t\t\t// we ignore double click, events are delivered normally\n\t\t\ts.postEvent(NewEventMouse(int(mrec.x), int(mrec.y), btns, mod2mask(mrec.mod)))\n\n\t\tcase resizeEvent:\n\t\t\tvar rrec resizeRecord\n\t\t\trrec.x = geti16(rec.data[0:])\n\t\t\trrec.y = geti16(rec.data[2:])\n\t\t\ts.postEvent(NewEventResize(int(rrec.x), int(rrec.y)))\n\n\t\tcase focusEvent:\n\t\t\tvar focus focusRecord\n\t\t\tfocus.focused = geti32(rec.data[0:])\n\t\t\ts.Lock()\n\t\t\tenabled := s.focusEnable\n\t\t\ts.Unlock()\n\t\t\tif enabled {\n\t\t\t\ts.postEvent(NewEventFocus(focus.focused != 0))\n\t\t\t}\n\n\t\tdefault:\n\t\t}\n\tdefault:\n\t\treturn er\n\t}\n\n\treturn nil\n}\n\nfunc (s *cScreen) scanInput(stopQ chan struct{}) {\n\tdefer s.wg.Done()\n\tfor {\n\t\tselect {\n\t\tcase <-stopQ:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t\tif e := s.getConsoleInput(); e != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *cScreen) Colors() int {\n\tif s.vten {\n\t\treturn 1 << 24\n\t}\n\t// Windows console can display 8 colors, in either low or high intensity\n\treturn 16\n}\n\nvar vgaColors = map[Color]uint16{\n\tColorBlack:   0,\n\tColorMaroon:  0x4,\n\tColorGreen:   0x2,\n\tColorNavy:    0x1,\n\tColorOlive:   0x6,\n\tColorPurple:  0x5,\n\tColorTeal:    0x3,\n\tColorSilver:  0x7,\n\tColorGrey:    0x8,\n\tColorRed:     0xc,\n\tColorLime:    0xa,\n\tColorBlue:    0x9,\n\tColorYellow:  0xe,\n\tColorFuchsia: 0xd,\n\tColorAqua:    0xb,\n\tColorWhite:   0xf,\n}\n\n// Windows uses RGB signals\nfunc mapColor2RGB(c Color) uint16 {\n\twinLock.Lock()\n\tif v, ok := winColors[c]; ok {\n\t\tc = v\n\t} else {\n\t\tv = FindColor(c, winPalette)\n\t\twinColors[c] = v\n\t\tc = v\n\t}\n\twinLock.Unlock()\n\n\tif vc, ok := vgaColors[c]; ok {\n\t\treturn vc\n\t}\n\treturn 0\n}\n\n// Map a tcell style to Windows attributes\nfunc (s *cScreen) mapStyle(style Style) uint16 {\n\tf, b, a := style.fg, style.bg, style.attrs\n\tfa := s.oscreen.attrs & 0xf\n\tba := (s.oscreen.attrs) >> 4 & 0xf\n\tif f != ColorDefault && f != ColorReset {\n\t\tfa = mapColor2RGB(f)\n\t}\n\tif b != ColorDefault && b != ColorReset {\n\t\tba = mapColor2RGB(b)\n\t}\n\tvar attr uint16\n\t// We simulate reverse by doing the color swap ourselves.\n\t// Apparently windows cannot really do this except in DBCS\n\t// views.\n\tif a&AttrReverse != 0 {\n\t\tattr = ba\n\t\tattr |= fa << 4\n\t} else {\n\t\tattr = fa\n\t\tattr |= ba << 4\n\t}\n\tif a&AttrBold != 0 {\n\t\tattr |= 0x8\n\t}\n\tif a&AttrDim != 0 {\n\t\tattr &^= 0x8\n\t}\n\tif a&AttrUnderline != 0 {\n\t\t// Best effort -- doesn't seem to work though.\n\t\tattr |= 0x8000\n\t}\n\t// Blink is unsupported\n\treturn attr\n}\n\nfunc (s *cScreen) sendVtStyle(style Style) {\n\tesc := &strings.Builder{}\n\n\tfg, bg, attrs := style.fg, style.bg, style.attrs\n\tus, uc := style.ulStyle, style.ulColor\n\n\tesc.WriteString(vtSgr0)\n\tif attrs&(AttrBold|AttrDim) == AttrBold {\n\t\tesc.WriteString(vtBold)\n\t}\n\tif attrs&AttrBlink != 0 {\n\t\tesc.WriteString(vtBlink)\n\t}\n\tif us != UnderlineStyleNone {\n\t\tif uc == ColorReset {\n\t\t\tesc.WriteString(vtUnderColorReset)\n\t\t} else if uc.IsRGB() {\n\t\t\tr, g, b := uc.RGB()\n\t\t\t_, _ = fmt.Fprintf(esc, vtUnderColorRGB, int(r), int(g), int(b))\n\t\t} else if uc.Valid() {\n\t\t\t_, _ = fmt.Fprintf(esc, vtUnderColor, uc&0xff)\n\t\t}\n\n\t\tesc.WriteString(vtUnderline)\n\t\t// legacy ConHost does not understand these but Terminal does\n\t\tswitch us {\n\t\tcase UnderlineStyleSolid:\n\t\tcase UnderlineStyleDouble:\n\t\t\tesc.WriteString(vtDoubleUnderline)\n\t\tcase UnderlineStyleCurly:\n\t\t\tesc.WriteString(vtCurlyUnderline)\n\t\tcase UnderlineStyleDotted:\n\t\t\tesc.WriteString(vtDottedUnderline)\n\t\tcase UnderlineStyleDashed:\n\t\t\tesc.WriteString(vtDashedUnderline)\n\t\t}\n\t}\n\n\tif attrs&AttrReverse != 0 {\n\t\tesc.WriteString(vtReverse)\n\t}\n\tif fg.IsRGB() {\n\t\tr, g, b := fg.RGB()\n\t\t_, _ = fmt.Fprintf(esc, vtSetFgRGB, r, g, b)\n\t} else if fg.Valid() {\n\t\t_, _ = fmt.Fprintf(esc, vtSetFg, fg&0xff)\n\t}\n\tif bg.IsRGB() {\n\t\tr, g, b := bg.RGB()\n\t\t_, _ = fmt.Fprintf(esc, vtSetBgRGB, r, g, b)\n\t} else if bg.Valid() {\n\t\t_, _ = fmt.Fprintf(esc, vtSetBg, bg&0xff)\n\t}\n\t// URL string can be long, so don't send it unless we really need to\n\tif style.url != \"\" {\n\t\t_, _ = fmt.Fprintf(esc, vtEnterUrl, style.urlId, style.url)\n\t} else {\n\t\tesc.WriteString(vtExitUrl)\n\t}\n\n\ts.emitVtString(esc.String())\n}\n\nfunc (s *cScreen) writeString(x, y int, style Style, ch []uint16) {\n\t// we assume the caller has hidden the cursor\n\tif len(ch) == 0 {\n\t\treturn\n\t}\n\ts.setCursorPos(x, y, s.vten)\n\n\tif s.vten {\n\t\ts.sendVtStyle(style)\n\t} else {\n\t\t_, _, _ = procSetConsoleTextAttribute.Call(\n\t\t\tuintptr(s.out),\n\t\t\tuintptr(s.mapStyle(style)))\n\t}\n\t_ = syscall.WriteConsole(s.out, &ch[0], uint32(len(ch)), nil, nil)\n}\n\nfunc (s *cScreen) draw() {\n\t// allocate a scratch line bit enough for no combining chars.\n\t// if you have combining characters, you may pay for extra allocations.\n\tbuf := make([]uint16, 0, s.w)\n\twcs := buf[:]\n\tlstyle := styleInvalid\n\n\tlx, ly := -1, -1\n\tra := make([]rune, 1)\n\n\tfor y := 0; y < s.h; y++ {\n\t\tfor x := 0; x < s.w; x++ {\n\t\t\tmainc, combc, style, width := s.cells.GetContent(x, y)\n\t\t\tdirty := s.cells.Dirty(x, y)\n\t\t\tif style == StyleDefault {\n\t\t\t\tstyle = s.style\n\t\t\t}\n\n\t\t\tif !dirty || style != lstyle {\n\t\t\t\t// write out any data queued thus far\n\t\t\t\t// because we are going to skip over some\n\t\t\t\t// cells, or because we need to change styles\n\t\t\t\ts.writeString(lx, ly, lstyle, wcs)\n\t\t\t\twcs = buf[0:0]\n\t\t\t\tlstyle = StyleDefault\n\t\t\t\tif !dirty {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif x > s.w-width {\n\t\t\t\tmainc = ' '\n\t\t\t\tcombc = nil\n\t\t\t\twidth = 1\n\t\t\t}\n\t\t\tif len(wcs) == 0 {\n\t\t\t\tlstyle = style\n\t\t\t\tlx = x\n\t\t\t\tly = y\n\t\t\t}\n\t\t\tra[0] = mainc\n\t\t\twcs = append(wcs, utf16.Encode(ra)...)\n\t\t\tif len(combc) != 0 {\n\t\t\t\twcs = append(wcs, utf16.Encode(combc)...)\n\t\t\t}\n\t\t\tfor dx := 0; dx < width; dx++ {\n\t\t\t\ts.cells.SetDirty(x+dx, y, false)\n\t\t\t}\n\t\t\tx += width - 1\n\t\t}\n\t\ts.writeString(lx, ly, lstyle, wcs)\n\t\twcs = buf[0:0]\n\t\tlstyle = styleInvalid\n\t}\n}\n\nfunc (s *cScreen) Show() {\n\ts.Lock()\n\tif !s.fini {\n\t\ts.hideCursor()\n\t\ts.resize()\n\t\ts.draw()\n\t\ts.doCursor()\n\t}\n\ts.Unlock()\n}\n\nfunc (s *cScreen) Sync() {\n\ts.Lock()\n\tif !s.fini {\n\t\ts.cells.Invalidate()\n\t\ts.hideCursor()\n\t\ts.resize()\n\t\ts.draw()\n\t\ts.doCursor()\n\t}\n\ts.Unlock()\n}\n\ntype consoleInfo struct {\n\tsize  coord\n\tpos   coord\n\tattrs uint16\n\twin   rect\n\tmaxsz coord\n}\n\nfunc (s *cScreen) getConsoleInfo(info *consoleInfo) {\n\t_, _, _ = procGetConsoleScreenBufferInfo.Call(\n\t\tuintptr(s.out),\n\t\tuintptr(unsafe.Pointer(info)))\n}\n\nfunc (s *cScreen) getCursorInfo(info *cursorInfo) {\n\t_, _, _ = procGetConsoleCursorInfo.Call(\n\t\tuintptr(s.out),\n\t\tuintptr(unsafe.Pointer(info)))\n}\n\nfunc (s *cScreen) setCursorInfo(info *cursorInfo) {\n\t_, _, _ = procSetConsoleCursorInfo.Call(\n\t\tuintptr(s.out),\n\t\tuintptr(unsafe.Pointer(info)))\n}\n\nfunc (s *cScreen) setCursorPos(x, y int, vtEnable bool) {\n\tif vtEnable {\n\t\t// Note that the string is Y first.  Origin is 1,1.\n\t\ts.emitVtString(fmt.Sprintf(vtCursorPos, y+1, x+1))\n\t} else {\n\t\t_, _, _ = procSetConsoleCursorPosition.Call(\n\t\t\tuintptr(s.out),\n\t\t\tcoord{int16(x), int16(y)}.uintptr())\n\t}\n}\n\nfunc (s *cScreen) setBufferSize(x, y int) {\n\t_, _, _ = procSetConsoleScreenBufferSize.Call(\n\t\tuintptr(s.out),\n\t\tcoord{int16(x), int16(y)}.uintptr())\n}\n\nfunc (s *cScreen) Size() (int, int) {\n\ts.Lock()\n\tw, h := s.w, s.h\n\ts.Unlock()\n\n\treturn w, h\n}\n\nfunc (s *cScreen) SetSize(w, h int) {\n\txy, _, _ := procGetLargestConsoleWindowSize.Call(uintptr(s.out))\n\n\t// xy is little endian packed\n\ty := int(xy >> 16)\n\tx := int(xy & 0xffff)\n\n\tif x == 0 || y == 0 {\n\t\treturn\n\t}\n\n\t// This is a hacky workaround for Windows Terminal.\n\t// Essentially Windows Terminal (Windows 11) does not support application\n\t// initiated resizing.  To detect this, we look for an extremely large size\n\t// for the maximum width.  If it is > 500, then this is almost certainly\n\t// Windows Terminal, and won't support this.  (Note that the legacy console\n\t// does support application resizing.)\n\tif x >= 500 {\n\t\treturn\n\t}\n\n\ts.setBufferSize(x, y)\n\tr := rect{0, 0, int16(w - 1), int16(h - 1)}\n\t_, _, _ = procSetConsoleWindowInfo.Call(\n\t\tuintptr(s.out),\n\t\tuintptr(1),\n\t\tuintptr(unsafe.Pointer(&r)))\n\n\ts.resize()\n}\n\nfunc (s *cScreen) resize() {\n\tinfo := consoleInfo{}\n\ts.getConsoleInfo(&info)\n\n\tw := int((info.win.right - info.win.left) + 1)\n\th := int((info.win.bottom - info.win.top) + 1)\n\n\tif s.w == w && s.h == h {\n\t\treturn\n\t}\n\n\ts.cells.Resize(w, h)\n\ts.w = w\n\ts.h = h\n\n\ts.setBufferSize(w, h)\n\n\tr := rect{0, 0, int16(w - 1), int16(h - 1)}\n\t_, _, _ = procSetConsoleWindowInfo.Call(\n\t\tuintptr(s.out),\n\t\tuintptr(1),\n\t\tuintptr(unsafe.Pointer(&r)))\n\tselect {\n\tcase s.eventQ <- NewEventResize(w, h):\n\tdefault:\n\t}\n}\n\nfunc (s *cScreen) clearScreen(style Style, vtEnable bool) {\n\tif vtEnable {\n\t\ts.sendVtStyle(style)\n\t\trow := strings.Repeat(\" \", s.w)\n\t\tfor y := 0; y < s.h; y++ {\n\t\t\ts.setCursorPos(0, y, vtEnable)\n\t\t\ts.emitVtString(row)\n\t\t}\n\t\ts.setCursorPos(0, 0, vtEnable)\n\n\t} else {\n\t\tpos := coord{0, 0}\n\t\tattr := s.mapStyle(style)\n\t\tx, y := s.w, s.h\n\t\tscratch := uint32(0)\n\t\tcount := uint32(x * y)\n\n\t\t_, _, _ = procFillConsoleOutputAttribute.Call(\n\t\t\tuintptr(s.out),\n\t\t\tuintptr(attr),\n\t\t\tuintptr(count),\n\t\t\tpos.uintptr(),\n\t\t\tuintptr(unsafe.Pointer(&scratch)))\n\t\t_, _, _ = procFillConsoleOutputCharacter.Call(\n\t\t\tuintptr(s.out),\n\t\t\tuintptr(' '),\n\t\t\tuintptr(count),\n\t\t\tpos.uintptr(),\n\t\t\tuintptr(unsafe.Pointer(&scratch)))\n\t}\n}\n\nconst (\n\t// Input modes\n\tmodeExtendFlg uint32 = 0x0080\n\tmodeMouseEn          = 0x0010\n\tmodeResizeEn         = 0x0008\n\t// modeCooked          = 0x0001\n\t// modeVtInput         = 0x0200\n\n\t// Output modes\n\tmodeCookedOut uint32 = 0x0001\n\tmodeVtOutput         = 0x0004\n\tmodeNoAutoNL         = 0x0008\n\tmodeUnderline        = 0x0010 // ENABLE_LVB_GRID_WORLDWIDE, needed for underlines\n\t// modeWrapEOL          = 0x0002\n)\n\nfunc (s *cScreen) setInMode(mode uint32) {\n\t_, _, _ = procSetConsoleMode.Call(\n\t\tuintptr(s.in),\n\t\tuintptr(mode))\n}\n\nfunc (s *cScreen) setOutMode(mode uint32) {\n\t_, _, _ = procSetConsoleMode.Call(\n\t\tuintptr(s.out),\n\t\tuintptr(mode))\n}\n\nfunc (s *cScreen) getInMode(v *uint32) {\n\t_, _, _ = procGetConsoleMode.Call(\n\t\tuintptr(s.in),\n\t\tuintptr(unsafe.Pointer(v)))\n}\n\nfunc (s *cScreen) getOutMode(v *uint32) {\n\t_, _, _ = procGetConsoleMode.Call(\n\t\tuintptr(s.out),\n\t\tuintptr(unsafe.Pointer(v)))\n}\n\nfunc (s *cScreen) SetStyle(style Style) {\n\ts.Lock()\n\ts.style = style\n\ts.Unlock()\n}\n\nfunc (s *cScreen) SetTitle(title string) {\n\ts.Lock()\n\ts.title = title\n\tif s.vten {\n\t\ts.emitVtString(fmt.Sprintf(vtSetTitle, title))\n\t}\n\ts.Unlock()\n}\n\n// No fallback rune support, since we have Unicode.  Yay!\n\nfunc (s *cScreen) RegisterRuneFallback(_ rune, _ string) {\n}\n\nfunc (s *cScreen) UnregisterRuneFallback(_ rune) {\n}\n\nfunc (s *cScreen) CanDisplay(_ rune, _ bool) bool {\n\t// We presume we can display anything -- we're Unicode.\n\t// (Sadly this not precisely true.  Combining characters are especially\n\t// poorly supported under Windows.)\n\treturn true\n}\n\nfunc (s *cScreen) HasMouse() bool {\n\treturn true\n}\n\nfunc (s *cScreen) SetClipboard(_ []byte) {\n}\n\nfunc (s *cScreen) GetClipboard() {\n}\n\nfunc (s *cScreen) Resize(int, int, int, int) {}\n\nfunc (s *cScreen) HasKey(k Key) bool {\n\t// Microsoft has codes for some keys, but they are unusual,\n\t// so we don't include them.  We include all the typical\n\t// 101, 105 key layout keys.\n\tvalid := map[Key]bool{\n\t\tKeyBackspace: true,\n\t\tKeyTab:       true,\n\t\tKeyEscape:    true,\n\t\tKeyPause:     true,\n\t\tKeyPrint:     true,\n\t\tKeyPgUp:      true,\n\t\tKeyPgDn:      true,\n\t\tKeyEnter:     true,\n\t\tKeyEnd:       true,\n\t\tKeyHome:      true,\n\t\tKeyLeft:      true,\n\t\tKeyUp:        true,\n\t\tKeyRight:     true,\n\t\tKeyDown:      true,\n\t\tKeyInsert:    true,\n\t\tKeyDelete:    true,\n\t\tKeyF1:        true,\n\t\tKeyF2:        true,\n\t\tKeyF3:        true,\n\t\tKeyF4:        true,\n\t\tKeyF5:        true,\n\t\tKeyF6:        true,\n\t\tKeyF7:        true,\n\t\tKeyF8:        true,\n\t\tKeyF9:        true,\n\t\tKeyF10:       true,\n\t\tKeyF11:       true,\n\t\tKeyF12:       true,\n\t\tKeyRune:      true,\n\t}\n\n\treturn valid[k]\n}\n\nfunc (s *cScreen) Beep() error {\n\t// A simple beep. If the sound card is not available, the sound is generated\n\t// using the speaker.\n\t//\n\t// Reference:\n\t// https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebeep\n\tconst simpleBeep = 0xffffffff\n\tif rv, _, err := procMessageBeep.Call(simpleBeep); rv == 0 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *cScreen) Suspend() error {\n\ts.disengage()\n\treturn nil\n}\n\nfunc (s *cScreen) Resume() error {\n\treturn s.engage()\n}\n\nfunc (s *cScreen) Tty() (Tty, bool) {\n\treturn nil, false\n}\n\nfunc (s *cScreen) GetCells() *CellBuffer {\n\treturn &s.cells\n}\n\nfunc (s *cScreen) EventQ() chan Event {\n\treturn s.eventQ\n}\n\nfunc (s *cScreen) StopQ() <-chan struct{} {\n\treturn s.quit\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 2.3642578125,
          "content": "// Copyright 2018 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package tcell provides a lower-level, portable API for building\n// programs that interact with terminals or consoles.  It works with\n// both common (and many uncommon!) terminals or terminal emulators,\n// and Windows console implementations.\n//\n// It provides support for up to 256 colors, text attributes, and box drawing\n// elements.  A database of terminals built from a real terminfo database\n// is provided, along with code to generate new database entries.\n//\n// Tcell offers very rich support for mice, dependent upon the terminal\n// of course.  (Windows, XTerm, and iTerm 2 are known to work very well.)\n//\n// If the environment is not Unicode by default, such as an ISO8859 based\n// locale or GB18030, Tcell can convert input and output, so that your\n// terminal can operate in whatever locale is most convenient, while the\n// application program can just assume \"everything is UTF-8\".  Reasonable\n// defaults are used for updating characters to something suitable for\n// display.  Unicode box drawing characters will be converted to use the\n// alternate character set of your terminal, if native conversions are\n// not available.  If no ACS is available, then some ASCII fallbacks will\n// be used.\n//\n// Note that support for non-UTF-8 locales (other than C)  must be enabled\n// by the application using RegisterEncoding() -- we don't have them all\n// enabled by default to avoid bloating the application unnecessarily.\n// (These days UTF-8 is good enough for almost everyone, and nobody should\n// be using legacy locales anymore.)  Also, actual glyphs for various code\n// point will only be displayed if your terminal or emulator (or the font\n// the emulator is using) supports them.\n//\n// A rich set of key codes is supported, with support for up to 65 function\n// keys, and various other special keys.\npackage tcell\n"
        },
        {
          "name": "encoding.go",
          "type": "blob",
          "size": 5.0673828125,
          "content": "// Copyright 2022 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\n\t\"golang.org/x/text/encoding\"\n\n\tgencoding \"github.com/gdamore/encoding\"\n)\n\nvar encodings map[string]encoding.Encoding\nvar encodingLk sync.Mutex\nvar encodingFallback EncodingFallback = EncodingFallbackFail\n\n// RegisterEncoding may be called by the application to register an encoding.\n// The presence of additional encodings will facilitate application usage with\n// terminal environments where the I/O subsystem does not support Unicode.\n//\n// Windows systems use Unicode natively, and do not need any of the encoding\n// subsystem when using Windows Console screens.\n//\n// Please see the Go documentation for golang.org/x/text/encoding -- most of\n// the common ones exist already as stock variables.  For example, ISO8859-15\n// can be registered using the following code:\n//\n//\timport \"golang.org/x/text/encoding/charmap\"\n//\n//\t  ...\n//\t  RegisterEncoding(\"ISO8859-15\", charmap.ISO8859_15)\n//\n// Aliases can be registered as well, for example \"8859-15\" could be an alias\n// for \"ISO8859-15\".\n//\n// For POSIX systems, this package will check the environment variables\n// LC_ALL, LC_CTYPE,  and LANG (in that order) to determine the character set.\n// These are expected to have the following pattern:\n//\n//\t$language[.$codeset[@$variant]\n//\n// We extract only the $codeset part, which will usually be something like\n// UTF-8 or ISO8859-15 or KOI8-R.  Note that if the locale is either \"POSIX\"\n// or \"C\", then we assume US-ASCII (the POSIX 'portable character set'\n// and assume all other characters are somehow invalid.)\n//\n// Modern POSIX systems and terminal emulators may use UTF-8, and for those\n// systems, this API is also unnecessary.  For example, Darwin (MacOS X) and\n// modern Linux running modern xterm generally will out of the box without\n// any of this.  Use of UTF-8 is recommended when possible, as it saves\n// quite a lot processing overhead.\n//\n// Note that some encodings are quite large (for example GB18030 which is a\n// superset of Unicode) and so the application size can be expected to\n// increase quite a bit as each encoding is added.\n\n// The East Asian encodings have been seen to add 100-200K per encoding to the\n// size of the resulting binary.\nfunc RegisterEncoding(charset string, enc encoding.Encoding) {\n\tencodingLk.Lock()\n\tcharset = strings.ToLower(charset)\n\tencodings[charset] = enc\n\tencodingLk.Unlock()\n}\n\n// EncodingFallback describes how the system behaves when the locale\n// requires a character set that we do not support.  The system always\n// supports UTF-8 and US-ASCII. On Windows consoles, UTF-16LE is also\n// supported automatically.  Other character sets must be added using the\n// RegisterEncoding API.  (A large group of nearly all of them can be\n// added using the RegisterAll function in the encoding sub package.)\ntype EncodingFallback int\n\nconst (\n\t// EncodingFallbackFail behavior causes GetEncoding to fail\n\t// when it cannot find an encoding.\n\tEncodingFallbackFail = iota\n\n\t// EncodingFallbackASCII behavior causes GetEncoding to fall back\n\t// to a 7-bit ASCII encoding, if no other encoding can be found.\n\tEncodingFallbackASCII\n\n\t// EncodingFallbackUTF8 behavior causes GetEncoding to assume\n\t// UTF8 can pass unmodified upon failure.  Note that this behavior\n\t// is not recommended, unless you are sure your terminal can cope\n\t// with real UTF8 sequences.\n\tEncodingFallbackUTF8\n)\n\n// SetEncodingFallback changes the behavior of GetEncoding when a suitable\n// encoding is not found.  The default is EncodingFallbackFail, which\n// causes GetEncoding to simply return nil.\nfunc SetEncodingFallback(fb EncodingFallback) {\n\tencodingLk.Lock()\n\tencodingFallback = fb\n\tencodingLk.Unlock()\n}\n\n// GetEncoding is used by Screen implementors who want to locate an encoding\n// for the given character set name.  Note that this will return nil for\n// either the Unicode (UTF-8) or ASCII encodings, since we don't use\n// encodings for them but instead have our own native methods.\nfunc GetEncoding(charset string) encoding.Encoding {\n\tcharset = strings.ToLower(charset)\n\tencodingLk.Lock()\n\tdefer encodingLk.Unlock()\n\tif enc, ok := encodings[charset]; ok {\n\t\treturn enc\n\t}\n\tswitch encodingFallback {\n\tcase EncodingFallbackASCII:\n\t\treturn gencoding.ASCII\n\tcase EncodingFallbackUTF8:\n\t\treturn encoding.Nop\n\t}\n\treturn nil\n}\n\nfunc init() {\n\t// We always support UTF-8 and ASCII.\n\tencodings = make(map[string]encoding.Encoding)\n\tencodings[\"utf-8\"] = gencoding.UTF8\n\tencodings[\"utf8\"] = gencoding.UTF8\n\tencodings[\"us-ascii\"] = gencoding.ASCII\n\tencodings[\"ascii\"] = gencoding.ASCII\n\tencodings[\"iso646\"] = gencoding.ASCII\n}\n"
        },
        {
          "name": "encoding",
          "type": "tree",
          "content": null
        },
        {
          "name": "encoding_test.go",
          "type": "blob",
          "size": 0.857421875,
          "content": "// Copyright 2022 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage tcell\n\nimport (\n\t\"fmt\"\n\n\t\"golang.org/x/text/encoding/simplifiedchinese\"\n)\n\nfunc ExampleRegisterEncoding() {\n\tRegisterEncoding(\"GBK\", simplifiedchinese.GBK)\n\tenc := GetEncoding(\"GBK\")\n\tglyph, _ := enc.NewDecoder().Bytes([]byte{0x82, 0x74})\n\tfmt.Println(string(glyph))\n\t// Output: 倀\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 2.5185546875,
          "content": "// Copyright 2015 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/gdamore/tcell/v2/terminfo\"\n)\n\nvar (\n\t// ErrTermNotFound indicates that a suitable terminal entry could\n\t// not be found.  This can result from either not having TERM set,\n\t// or from the TERM failing to support certain minimal functionality,\n\t// in particular absolute cursor addressability (the cup capability)\n\t// is required.  For example, legacy \"adm3\" lacks this capability,\n\t// whereas the slightly newer \"adm3a\" supports it.  This failure\n\t// occurs most often with \"dumb\".\n\tErrTermNotFound = terminfo.ErrTermNotFound\n\n\t// ErrNoScreen indicates that no suitable screen could be found.\n\t// This may result from attempting to run on a platform where there\n\t// is no support for either termios or console I/O (such as nacl),\n\t// or from running in an environment where there is no access to\n\t// a suitable console/terminal device.  (For example, running on\n\t// without a controlling TTY or with no /dev/tty on POSIX platforms.)\n\tErrNoScreen = errors.New(\"no suitable screen available\")\n\n\t// ErrNoCharset indicates that the locale environment the\n\t// program is not supported by the program, because no suitable\n\t// encoding was found for it.  This problem never occurs if\n\t// the environment is UTF-8 or UTF-16.\n\tErrNoCharset = errors.New(\"character set not supported\")\n\n\t// ErrEventQFull indicates that the event queue is full, and\n\t// cannot accept more events.\n\tErrEventQFull = errors.New(\"event queue full\")\n)\n\n// An EventError is an event representing some sort of error, and carries\n// an error payload.\ntype EventError struct {\n\tt   time.Time\n\terr error\n}\n\n// When returns the time when the event was created.\nfunc (ev *EventError) When() time.Time {\n\treturn ev.t\n}\n\n// Error implements the error.\nfunc (ev *EventError) Error() string {\n\treturn ev.err.Error()\n}\n\n// NewEventError creates an ErrorEvent with the given error payload.\nfunc NewEventError(err error) *EventError {\n\treturn &EventError{t: time.Now(), err: err}\n}\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 1.5166015625,
          "content": "// Copyright 2015 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"time\"\n)\n\n// Event is a generic interface used for passing around Events.\n// Concrete types follow.\ntype Event interface {\n\t// When reports the time when the event was generated.\n\tWhen() time.Time\n}\n\n// EventTime is a simple base event class, suitable for easy reuse.\n// It can be used to deliver actual timer events as well.\ntype EventTime struct {\n\twhen time.Time\n}\n\n// When returns the time stamp when the event occurred.\nfunc (e *EventTime) When() time.Time {\n\treturn e.when\n}\n\n// SetEventTime sets the time of occurrence for the event.\nfunc (e *EventTime) SetEventTime(t time.Time) {\n\te.when = t\n}\n\n// SetEventNow sets the time of occurrence for the event to the current time.\nfunc (e *EventTime) SetEventNow() {\n\te.SetEventTime(time.Now())\n}\n\n// EventHandler is anything that handles events.  If the handler has\n// consumed the event, it should return true.  False otherwise.\ntype EventHandler interface {\n\tHandleEvent(Event) bool\n}\n"
        },
        {
          "name": "event_test.go",
          "type": "blob",
          "size": 2.146484375,
          "content": "// Copyright 2018 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc eventLoop(s Screen, evch chan Event) {\n\tfor {\n\t\tev := s.PollEvent()\n\t\tif ev == nil {\n\t\t\tclose(evch)\n\t\t\treturn\n\t\t}\n\t\tselect {\n\t\tcase evch <- ev:\n\t\tcase <-time.After(time.Second):\n\t\t}\n\t}\n}\n\nfunc TestMouseEvents(t *testing.T) {\n\n\ts := mkTestScreen(t, \"\")\n\tdefer s.Fini()\n\n\ts.EnableMouse()\n\ts.InjectMouse(4, 9, Button1, ModCtrl)\n\tevch := make(chan Event)\n\tem := &EventMouse{}\n\tdone := false\n\tgo eventLoop(s, evch)\n\n\tfor !done {\n\t\tselect {\n\t\tcase ev := <-evch:\n\t\t\tif evm, ok := ev.(*EventMouse); ok {\n\t\t\t\tem = evm\n\t\t\t\tdone = true\n\t\t\t}\n\t\t\tcontinue\n\t\tcase <-time.After(time.Second):\n\t\t\tdone = true\n\t\t}\n\t}\n\n\tif x, y := em.Position(); x != 4 || y != 9 {\n\t\tt.Errorf(\"Mouse position wrong (%v, %v)\", x, y)\n\t}\n\tif em.Buttons() != Button1 {\n\t\tt.Errorf(\"Should be Button1\")\n\t}\n\tif em.Modifiers() != ModCtrl {\n\t\tt.Errorf(\"Modifiers should be control\")\n\t}\n}\n\nfunc TestChannelMouseEvents(t *testing.T) {\n\n\ts := mkTestScreen(t, \"\")\n\tdefer s.Fini()\n\n\ts.EnableMouse()\n\ts.InjectMouse(4, 9, Button1, ModCtrl)\n\tevch := make(chan Event)\n\tquit := make(chan struct{})\n\tem := new(EventMouse)\n\tgo s.ChannelEvents(evch, quit)\n\nloop:\n\tfor {\n\t\tselect {\n\t\tcase ev := <-evch:\n\t\t\tif evm, ok := ev.(*EventMouse); ok {\n\t\t\t\tem = evm\n\t\t\t\tclose(quit)\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tcontinue\n\t\tcase <-time.After(time.Second):\n\t\t\tclose(quit)\n\t\t\tbreak loop\n\t\t}\n\t}\n\n\tif x, y := em.Position(); x != 4 || y != 9 {\n\t\tt.Errorf(\"Mouse position wrong (%v, %v)\", x, y)\n\t}\n\tif em.Buttons() != Button1 {\n\t\tt.Errorf(\"Should be Button1\")\n\t}\n\tif em.Modifiers() != ModCtrl {\n\t\tt.Errorf(\"Modifiers should be control\")\n\t}\n}\n"
        },
        {
          "name": "focus.go",
          "type": "blob",
          "size": 0.8876953125,
          "content": "// Copyright 2023 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\n// EventFocus is a focus event. It is sent when the terminal window (or tab)\n// gets or loses focus.\ntype EventFocus struct {\n\t*EventTime\n\n\t// True if the window received focus, false if it lost focus\n\tFocused bool\n}\n\nfunc NewEventFocus(focused bool) *EventFocus {\n\treturn &EventFocus{Focused: focused}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.291015625,
          "content": "module github.com/gdamore/tcell/v2\n\ngo 1.12\n\nrequire (\n\tgithub.com/gdamore/encoding v1.0.1\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0\n\tgithub.com/mattn/go-runewidth v0.0.16\n\tgithub.com/rivo/uniseg v0.4.3 // indirect\n\tgolang.org/x/sys v0.29.0\n\tgolang.org/x/term v0.28.0\n\tgolang.org/x/text v0.21.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 6.5009765625,
          "content": "github.com/gdamore/encoding v1.0.1 h1:YzKZckdBL6jVt2Gc+5p82qhrGiqMdG/eNs6Wy0u3Uhw=\ngithub.com/gdamore/encoding v1.0.1/go.mod h1:0Z0cMFinngz9kS1QfMjCP8TY7em3bZYeeklsSDPivEo=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.3 h1:utMvzDsuh3suAEnhH0RdHmoPbU648o6CvXxTx4SBMOw=\ngithub.com/rivo/uniseg v0.4.3/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\ngolang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=\ngolang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "interrupt.go",
          "type": "blob",
          "size": 1.19921875,
          "content": "// Copyright 2015 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"time\"\n)\n\n// EventInterrupt is a generic wakeup event.  Its can be used to\n// to request a redraw.  It can carry an arbitrary payload, as well.\ntype EventInterrupt struct {\n\tt time.Time\n\tv interface{}\n}\n\n// When returns the time when this event was created.\nfunc (ev *EventInterrupt) When() time.Time {\n\treturn ev.t\n}\n\n// Data is used to obtain the opaque event payload.\nfunc (ev *EventInterrupt) Data() interface{} {\n\treturn ev.v\n}\n\n// NewEventInterrupt creates an EventInterrupt with the given payload.\nfunc NewEventInterrupt(data interface{}) *EventInterrupt {\n\treturn &EventInterrupt{t: time.Now(), v: data}\n}\n"
        },
        {
          "name": "key.go",
          "type": "blob",
          "size": 11.1181640625,
          "content": "// Copyright 2016 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n)\n\n// EventKey represents a key press.  Usually this is a key press followed\n// by a key release, but since terminal programs don't have a way to report\n// key release events, we usually get just one event.  If a key is held down\n// then the terminal may synthesize repeated key presses at some predefined\n// rate.  We have no control over that, nor visibility into it.\n//\n// In some cases, we can have a modifier key, such as ModAlt, that can be\n// generated with a key press.  (This usually is represented by having the\n// high bit set, or in some cases, by sending an ESC prior to the rune.)\n//\n// If the value of Key() is KeyRune, then the actual key value will be\n// available with the Rune() method.  This will be the case for most keys.\n// In most situations, the modifiers will not be set.  For example, if the\n// rune is 'A', this will be reported without the ModShift bit set, since\n// really can't tell if the Shift key was pressed (it might have been CAPSLOCK,\n// or a terminal that only can send capitals, or keyboard with separate\n// capital letters from lower case letters).\n//\n// Generally, terminal applications have far less visibility into keyboard\n// activity than graphical applications.  Hence, they should avoid depending\n// overly much on availability of modifiers, or the availability of any\n// specific keys.\ntype EventKey struct {\n\tt   time.Time\n\tmod ModMask\n\tkey Key\n\tch  rune\n}\n\n// When returns the time when this Event was created, which should closely\n// match the time when the key was pressed.\nfunc (ev *EventKey) When() time.Time {\n\treturn ev.t\n}\n\n// Rune returns the rune corresponding to the key press, if it makes sense.\n// The result is only defined if the value of Key() is KeyRune.\nfunc (ev *EventKey) Rune() rune {\n\treturn ev.ch\n}\n\n// Key returns a virtual key code.  We use this to identify specific key\n// codes, such as KeyEnter, etc.  Most control and function keys are reported\n// with unique Key values.  Normal alphanumeric and punctuation keys will\n// generally return KeyRune here; the specific key can be further decoded\n// using the Rune() function.\nfunc (ev *EventKey) Key() Key {\n\treturn ev.key\n}\n\n// Modifiers returns the modifiers that were present with the key press.  Note\n// that not all platforms and terminals support this equally well, and some\n// cases we will not not know for sure.  Hence, applications should avoid\n// using this in most circumstances.\nfunc (ev *EventKey) Modifiers() ModMask {\n\treturn ev.mod\n}\n\n// KeyNames holds the written names of special keys. Useful to echo back a key\n// name, or to look up a key from a string value.\nvar KeyNames = map[Key]string{\n\tKeyEnter:          \"Enter\",\n\tKeyBackspace:      \"Backspace\",\n\tKeyTab:            \"Tab\",\n\tKeyBacktab:        \"Backtab\",\n\tKeyEsc:            \"Esc\",\n\tKeyBackspace2:     \"Backspace2\",\n\tKeyDelete:         \"Delete\",\n\tKeyInsert:         \"Insert\",\n\tKeyUp:             \"Up\",\n\tKeyDown:           \"Down\",\n\tKeyLeft:           \"Left\",\n\tKeyRight:          \"Right\",\n\tKeyHome:           \"Home\",\n\tKeyEnd:            \"End\",\n\tKeyUpLeft:         \"UpLeft\",\n\tKeyUpRight:        \"UpRight\",\n\tKeyDownLeft:       \"DownLeft\",\n\tKeyDownRight:      \"DownRight\",\n\tKeyCenter:         \"Center\",\n\tKeyPgDn:           \"PgDn\",\n\tKeyPgUp:           \"PgUp\",\n\tKeyClear:          \"Clear\",\n\tKeyExit:           \"Exit\",\n\tKeyCancel:         \"Cancel\",\n\tKeyPause:          \"Pause\",\n\tKeyPrint:          \"Print\",\n\tKeyF1:             \"F1\",\n\tKeyF2:             \"F2\",\n\tKeyF3:             \"F3\",\n\tKeyF4:             \"F4\",\n\tKeyF5:             \"F5\",\n\tKeyF6:             \"F6\",\n\tKeyF7:             \"F7\",\n\tKeyF8:             \"F8\",\n\tKeyF9:             \"F9\",\n\tKeyF10:            \"F10\",\n\tKeyF11:            \"F11\",\n\tKeyF12:            \"F12\",\n\tKeyF13:            \"F13\",\n\tKeyF14:            \"F14\",\n\tKeyF15:            \"F15\",\n\tKeyF16:            \"F16\",\n\tKeyF17:            \"F17\",\n\tKeyF18:            \"F18\",\n\tKeyF19:            \"F19\",\n\tKeyF20:            \"F20\",\n\tKeyF21:            \"F21\",\n\tKeyF22:            \"F22\",\n\tKeyF23:            \"F23\",\n\tKeyF24:            \"F24\",\n\tKeyF25:            \"F25\",\n\tKeyF26:            \"F26\",\n\tKeyF27:            \"F27\",\n\tKeyF28:            \"F28\",\n\tKeyF29:            \"F29\",\n\tKeyF30:            \"F30\",\n\tKeyF31:            \"F31\",\n\tKeyF32:            \"F32\",\n\tKeyF33:            \"F33\",\n\tKeyF34:            \"F34\",\n\tKeyF35:            \"F35\",\n\tKeyF36:            \"F36\",\n\tKeyF37:            \"F37\",\n\tKeyF38:            \"F38\",\n\tKeyF39:            \"F39\",\n\tKeyF40:            \"F40\",\n\tKeyF41:            \"F41\",\n\tKeyF42:            \"F42\",\n\tKeyF43:            \"F43\",\n\tKeyF44:            \"F44\",\n\tKeyF45:            \"F45\",\n\tKeyF46:            \"F46\",\n\tKeyF47:            \"F47\",\n\tKeyF48:            \"F48\",\n\tKeyF49:            \"F49\",\n\tKeyF50:            \"F50\",\n\tKeyF51:            \"F51\",\n\tKeyF52:            \"F52\",\n\tKeyF53:            \"F53\",\n\tKeyF54:            \"F54\",\n\tKeyF55:            \"F55\",\n\tKeyF56:            \"F56\",\n\tKeyF57:            \"F57\",\n\tKeyF58:            \"F58\",\n\tKeyF59:            \"F59\",\n\tKeyF60:            \"F60\",\n\tKeyF61:            \"F61\",\n\tKeyF62:            \"F62\",\n\tKeyF63:            \"F63\",\n\tKeyF64:            \"F64\",\n\tKeyCtrlA:          \"Ctrl-A\",\n\tKeyCtrlB:          \"Ctrl-B\",\n\tKeyCtrlC:          \"Ctrl-C\",\n\tKeyCtrlD:          \"Ctrl-D\",\n\tKeyCtrlE:          \"Ctrl-E\",\n\tKeyCtrlF:          \"Ctrl-F\",\n\tKeyCtrlG:          \"Ctrl-G\",\n\tKeyCtrlJ:          \"Ctrl-J\",\n\tKeyCtrlK:          \"Ctrl-K\",\n\tKeyCtrlL:          \"Ctrl-L\",\n\tKeyCtrlN:          \"Ctrl-N\",\n\tKeyCtrlO:          \"Ctrl-O\",\n\tKeyCtrlP:          \"Ctrl-P\",\n\tKeyCtrlQ:          \"Ctrl-Q\",\n\tKeyCtrlR:          \"Ctrl-R\",\n\tKeyCtrlS:          \"Ctrl-S\",\n\tKeyCtrlT:          \"Ctrl-T\",\n\tKeyCtrlU:          \"Ctrl-U\",\n\tKeyCtrlV:          \"Ctrl-V\",\n\tKeyCtrlW:          \"Ctrl-W\",\n\tKeyCtrlX:          \"Ctrl-X\",\n\tKeyCtrlY:          \"Ctrl-Y\",\n\tKeyCtrlZ:          \"Ctrl-Z\",\n\tKeyCtrlSpace:      \"Ctrl-Space\",\n\tKeyCtrlUnderscore: \"Ctrl-_\",\n\tKeyCtrlRightSq:    \"Ctrl-]\",\n\tKeyCtrlBackslash:  \"Ctrl-\\\\\",\n\tKeyCtrlCarat:      \"Ctrl-^\",\n}\n\n// Name returns a printable value or the key stroke.  This can be used\n// when printing the event, for example.\nfunc (ev *EventKey) Name() string {\n\ts := \"\"\n\tm := []string{}\n\tif ev.mod&ModShift != 0 {\n\t\tm = append(m, \"Shift\")\n\t}\n\tif ev.mod&ModAlt != 0 {\n\t\tm = append(m, \"Alt\")\n\t}\n\tif ev.mod&ModMeta != 0 {\n\t\tm = append(m, \"Meta\")\n\t}\n\tif ev.mod&ModCtrl != 0 {\n\t\tm = append(m, \"Ctrl\")\n\t}\n\n\tok := false\n\tif s, ok = KeyNames[ev.key]; !ok {\n\t\tif ev.key == KeyRune {\n\t\t\ts = \"Rune[\" + string(ev.ch) + \"]\"\n\t\t} else {\n\t\t\ts = fmt.Sprintf(\"Key[%d,%d]\", ev.key, int(ev.ch))\n\t\t}\n\t}\n\tif len(m) != 0 {\n\t\tif ev.mod&ModCtrl != 0 && strings.HasPrefix(s, \"Ctrl-\") {\n\t\t\ts = s[5:]\n\t\t}\n\t\treturn fmt.Sprintf(\"%s+%s\", strings.Join(m, \"+\"), s)\n\t}\n\treturn s\n}\n\n// NewEventKey attempts to create a suitable event.  It parses the various\n// ASCII control sequences if KeyRune is passed for Key, but if the caller\n// has more precise information it should set that specifically.  Callers\n// that aren't sure about modifier state (most) should just pass ModNone.\nfunc NewEventKey(k Key, ch rune, mod ModMask) *EventKey {\n\tif k == KeyRune && (ch < ' ' || ch == 0x7f) {\n\t\t// Turn specials into proper key codes.  This is for\n\t\t// control characters and the DEL.\n\t\tk = Key(ch)\n\t\tif mod == ModNone && ch < ' ' {\n\t\t\tswitch Key(ch) {\n\t\t\tcase KeyBackspace, KeyTab, KeyEsc, KeyEnter:\n\t\t\t\t// these keys are directly typeable without CTRL\n\t\t\tdefault:\n\t\t\t\t// most likely entered with a CTRL keypress\n\t\t\t\tmod = ModCtrl\n\t\t\t}\n\t\t}\n\t}\n\treturn &EventKey{t: time.Now(), key: k, ch: ch, mod: mod}\n}\n\n// ModMask is a mask of modifier keys.  Note that it will not always be\n// possible to report modifier keys.\ntype ModMask int16\n\n// These are the modifiers keys that can be sent either with a key press,\n// or a mouse event.  Note that as of now, due to the confusion associated\n// with Meta, and the lack of support for it on many/most platforms, the\n// current implementations never use it.  Instead, they use ModAlt, even for\n// events that could possibly have been distinguished from ModAlt.\nconst (\n\tModShift ModMask = 1 << iota\n\tModCtrl\n\tModAlt\n\tModMeta\n\tModNone ModMask = 0\n)\n\n// Key is a generic value for representing keys, and especially special\n// keys (function keys, cursor movement keys, etc.)  For normal keys, like\n// ASCII letters, we use KeyRune, and then expect the application to\n// inspect the Rune() member of the EventKey.\ntype Key int16\n\n// This is the list of named keys.  KeyRune is special however, in that it is\n// a place holder key indicating that a printable character was sent.  The\n// actual value of the rune will be transported in the Rune of the associated\n// EventKey.\nconst (\n\tKeyRune Key = iota + 256\n\tKeyUp\n\tKeyDown\n\tKeyRight\n\tKeyLeft\n\tKeyUpLeft\n\tKeyUpRight\n\tKeyDownLeft\n\tKeyDownRight\n\tKeyCenter\n\tKeyPgUp\n\tKeyPgDn\n\tKeyHome\n\tKeyEnd\n\tKeyInsert\n\tKeyDelete\n\tKeyHelp\n\tKeyExit\n\tKeyClear\n\tKeyCancel\n\tKeyPrint\n\tKeyPause\n\tKeyBacktab\n\tKeyF1\n\tKeyF2\n\tKeyF3\n\tKeyF4\n\tKeyF5\n\tKeyF6\n\tKeyF7\n\tKeyF8\n\tKeyF9\n\tKeyF10\n\tKeyF11\n\tKeyF12\n\tKeyF13\n\tKeyF14\n\tKeyF15\n\tKeyF16\n\tKeyF17\n\tKeyF18\n\tKeyF19\n\tKeyF20\n\tKeyF21\n\tKeyF22\n\tKeyF23\n\tKeyF24\n\tKeyF25\n\tKeyF26\n\tKeyF27\n\tKeyF28\n\tKeyF29\n\tKeyF30\n\tKeyF31\n\tKeyF32\n\tKeyF33\n\tKeyF34\n\tKeyF35\n\tKeyF36\n\tKeyF37\n\tKeyF38\n\tKeyF39\n\tKeyF40\n\tKeyF41\n\tKeyF42\n\tKeyF43\n\tKeyF44\n\tKeyF45\n\tKeyF46\n\tKeyF47\n\tKeyF48\n\tKeyF49\n\tKeyF50\n\tKeyF51\n\tKeyF52\n\tKeyF53\n\tKeyF54\n\tKeyF55\n\tKeyF56\n\tKeyF57\n\tKeyF58\n\tKeyF59\n\tKeyF60\n\tKeyF61\n\tKeyF62\n\tKeyF63\n\tKeyF64\n)\n\nconst (\n\t// These key codes are used internally, and will never appear to applications.\n\tkeyPasteStart Key = iota + 16384\n\tkeyPasteEnd\n)\n\n// These are the control keys.  Note that they overlap with other keys,\n// perhaps.  For example, KeyCtrlH is the same as KeyBackspace.\nconst (\n\tKeyCtrlSpace Key = iota\n\tKeyCtrlA\n\tKeyCtrlB\n\tKeyCtrlC\n\tKeyCtrlD\n\tKeyCtrlE\n\tKeyCtrlF\n\tKeyCtrlG\n\tKeyCtrlH\n\tKeyCtrlI\n\tKeyCtrlJ\n\tKeyCtrlK\n\tKeyCtrlL\n\tKeyCtrlM\n\tKeyCtrlN\n\tKeyCtrlO\n\tKeyCtrlP\n\tKeyCtrlQ\n\tKeyCtrlR\n\tKeyCtrlS\n\tKeyCtrlT\n\tKeyCtrlU\n\tKeyCtrlV\n\tKeyCtrlW\n\tKeyCtrlX\n\tKeyCtrlY\n\tKeyCtrlZ\n\tKeyCtrlLeftSq // Escape\n\tKeyCtrlBackslash\n\tKeyCtrlRightSq\n\tKeyCtrlCarat\n\tKeyCtrlUnderscore\n)\n\n// Special values - these are fixed in an attempt to make it more likely\n// that aliases will encode the same way.\n\n// These are the defined ASCII values for key codes.  They generally match\n// with KeyCtrl values.\nconst (\n\tKeyNUL Key = iota\n\tKeySOH\n\tKeySTX\n\tKeyETX\n\tKeyEOT\n\tKeyENQ\n\tKeyACK\n\tKeyBEL\n\tKeyBS\n\tKeyTAB\n\tKeyLF\n\tKeyVT\n\tKeyFF\n\tKeyCR\n\tKeySO\n\tKeySI\n\tKeyDLE\n\tKeyDC1\n\tKeyDC2\n\tKeyDC3\n\tKeyDC4\n\tKeyNAK\n\tKeySYN\n\tKeyETB\n\tKeyCAN\n\tKeyEM\n\tKeySUB\n\tKeyESC\n\tKeyFS\n\tKeyGS\n\tKeyRS\n\tKeyUS\n\tKeyDEL Key = 0x7F\n)\n\n// These keys are aliases for other names.\nconst (\n\tKeyBackspace  = KeyBS\n\tKeyTab        = KeyTAB\n\tKeyEsc        = KeyESC\n\tKeyEscape     = KeyESC\n\tKeyEnter      = KeyCR\n\tKeyBackspace2 = KeyDEL\n)\n"
        },
        {
          "name": "logos",
          "type": "tree",
          "content": null
        },
        {
          "name": "mouse.go",
          "type": "blob",
          "size": 3.935546875,
          "content": "// Copyright 2020 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"time\"\n)\n\n// EventMouse is a mouse event.  It is sent on either mouse up or mouse down\n// events.  It is also sent on mouse motion events - if the terminal supports\n// it.  We make every effort to ensure that mouse release events are delivered.\n// Hence, click drag can be identified by a motion event with the mouse down,\n// without any intervening button release.  On some terminals only the initiating\n// press and terminating release event will be delivered.\n//\n// Mouse wheel events, when reported, may appear on their own as individual\n// impulses; that is, there will normally not be a release event delivered\n// for mouse wheel movements.\n//\n// Most terminals cannot report the state of more than one button at a time --\n// and some cannot report motion events unless a button is pressed.\n//\n// Applications can inspect the time between events to resolve double or\n// triple clicks.\ntype EventMouse struct {\n\tt   time.Time\n\tbtn ButtonMask\n\tmod ModMask\n\tx   int\n\ty   int\n}\n\n// When returns the time when this EventMouse was created.\nfunc (ev *EventMouse) When() time.Time {\n\treturn ev.t\n}\n\n// Buttons returns the list of buttons that were pressed or wheel motions.\nfunc (ev *EventMouse) Buttons() ButtonMask {\n\treturn ev.btn\n}\n\n// Modifiers returns a list of keyboard modifiers that were pressed\n// with the mouse button(s).\nfunc (ev *EventMouse) Modifiers() ModMask {\n\treturn ev.mod\n}\n\n// Position returns the mouse position in character cells.  The origin\n// 0, 0 is at the upper left corner.\nfunc (ev *EventMouse) Position() (int, int) {\n\treturn ev.x, ev.y\n}\n\n// NewEventMouse is used to create a new mouse event.  Applications\n// shouldn't need to use this; its mostly for screen implementors.\nfunc NewEventMouse(x, y int, btn ButtonMask, mod ModMask) *EventMouse {\n\treturn &EventMouse{t: time.Now(), x: x, y: y, btn: btn, mod: mod}\n}\n\n// ButtonMask is a mask of mouse buttons and wheel events.  Mouse button presses\n// are normally delivered as both press and release events.  Mouse wheel events\n// are normally just single impulse events.  Windows supports up to eight\n// separate buttons plus all four wheel directions, but XTerm can only support\n// mouse buttons 1-3 and wheel up/down.  Its not unheard of for terminals\n// to support only one or two buttons (think Macs).  Old terminals, and true\n// emulations (such as vt100) won't support mice at all, of course.\ntype ButtonMask int16\n\n// These are the actual button values.  Note that tcell version 1.x reversed buttons\n// two and three on *nix based terminals.  We use button 1 as the primary, and\n// button 2 as the secondary, and button 3 (which is often missing) as the middle.\nconst (\n\tButton1 ButtonMask = 1 << iota // Usually the left (primary) mouse button.\n\tButton2                        // Usually the right (secondary) mouse button.\n\tButton3                        // Usually the middle mouse button.\n\tButton4                        // Often a side button (thumb/next).\n\tButton5                        // Often a side button (thumb/prev).\n\tButton6\n\tButton7\n\tButton8\n\tWheelUp                   // Wheel motion up/away from user.\n\tWheelDown                 // Wheel motion down/towards user.\n\tWheelLeft                 // Wheel motion to left.\n\tWheelRight                // Wheel motion to right.\n\tButtonNone ButtonMask = 0 // No button or wheel events.\n\n\tButtonPrimary   = Button1\n\tButtonSecondary = Button2\n\tButtonMiddle    = Button3\n)\n"
        },
        {
          "name": "nonblock_bsd.go",
          "type": "blob",
          "size": 1.314453125,
          "content": "// Copyright 2021 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build darwin || dragonfly || freebsd || netbsd || openbsd\n// +build darwin dragonfly freebsd netbsd openbsd\n\npackage tcell\n\nimport (\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// BSD systems use TIOC style ioctls.\n\n// tcSetBufParams is used by the tty driver on UNIX systems to configure the\n// buffering parameters (minimum character count and minimum wait time in msec.)\n// This also waits for output to drain first.\nfunc tcSetBufParams(fd int, vMin uint8, vTime uint8) error {\n\t_ = syscall.SetNonblock(fd, true)\n\ttio, err := unix.IoctlGetTermios(fd, unix.TIOCGETA)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttio.Cc[unix.VMIN] = vMin\n\ttio.Cc[unix.VTIME] = vTime\n\tif err = unix.IoctlSetTermios(fd, unix.TIOCSETAW, tio); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "nonblock_unix.go",
          "type": "blob",
          "size": 1.234375,
          "content": "// Copyright 2021 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build linux || aix || zos || solaris\n// +build linux aix zos solaris\n\npackage tcell\n\nimport (\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// tcSetBufParams is used by the tty driver on UNIX systems to configure the\n// buffering parameters (minimum character count and minimum wait time in msec.)\n// This also waits for output to drain first.\nfunc tcSetBufParams(fd int, vMin uint8, vTime uint8) error {\n\t_ = syscall.SetNonblock(fd, true)\n\ttio, err := unix.IoctlGetTermios(fd, unix.TCGETS)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttio.Cc[unix.VMIN] = vMin\n\ttio.Cc[unix.VTIME] = vTime\n\tif err = unix.IoctlSetTermios(fd, unix.TCSETSW, tio); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "paste.go",
          "type": "blob",
          "size": 1.9443359375,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"time\"\n)\n\n// EventPaste is used to mark the start and end of a bracketed paste.\n//\n// An event with .Start() true will be sent to mark the start of a bracketed paste,\n// followed by a number of keys (string data) for the content, ending with the\n// an event with .End() true.\ntype EventPaste struct {\n\tstart bool\n\tt     time.Time\n\tdata  []byte\n}\n\n// When returns the time when this EventPaste was created.\nfunc (ev *EventPaste) When() time.Time {\n\treturn ev.t\n}\n\n// Start returns true if this is the start of a paste.\nfunc (ev *EventPaste) Start() bool {\n\treturn ev.start\n}\n\n// End returns true if this is the end of a paste.\nfunc (ev *EventPaste) End() bool {\n\treturn !ev.start\n}\n\n// NewEventPaste returns a new EventPaste.\nfunc NewEventPaste(start bool) *EventPaste {\n\treturn &EventPaste{t: time.Now(), start: start}\n}\n\n// NewEventClipboard returns a new NewEventClipboard with a data payload\nfunc NewEventClipboard(data []byte) *EventClipboard {\n\treturn &EventClipboard{t: time.Now(), data: data}\n}\n\n// EventClipboard represents data from the clipboard,\n// in response to a GetClipboard request.\ntype EventClipboard struct {\n\tt    time.Time\n\tdata []byte\n}\n\n// Data returns the attached binary data.\nfunc (ev *EventClipboard) Data() []byte {\n\treturn ev.data\n}\n\n// When returns the time when this event was created.\nfunc (ev *EventClipboard) When() time.Time {\n\treturn ev.t\n}\n"
        },
        {
          "name": "resize.go",
          "type": "blob",
          "size": 1.8056640625,
          "content": "// Copyright 2015 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"time\"\n)\n\n// EventResize is sent when the window size changes.\ntype EventResize struct {\n\tt  time.Time\n\tws WindowSize\n}\n\n// NewEventResize creates an EventResize with the new updated window size,\n// which is given in character cells.\nfunc NewEventResize(width, height int) *EventResize {\n\tws := WindowSize{\n\t\tWidth:  width,\n\t\tHeight: height,\n\t}\n\treturn &EventResize{t: time.Now(), ws: ws}\n}\n\n// When returns the time when the Event was created.\nfunc (ev *EventResize) When() time.Time {\n\treturn ev.t\n}\n\n// Size returns the new window size as width, height in character cells.\nfunc (ev *EventResize) Size() (int, int) {\n\treturn ev.ws.Width, ev.ws.Height\n}\n\n// PixelSize returns the new window size as width, height in pixels. The size\n// will be 0,0 if the screen doesn't support this feature\nfunc (ev *EventResize) PixelSize() (int, int) {\n\treturn ev.ws.PixelWidth, ev.ws.PixelHeight\n}\n\ntype WindowSize struct {\n\tWidth       int\n\tHeight      int\n\tPixelWidth  int\n\tPixelHeight int\n}\n\n// CellDimensions returns the dimensions of a single cell, in pixels\nfunc (ws WindowSize) CellDimensions() (int, int) {\n\tif ws.PixelWidth == 0 || ws.PixelHeight == 0 {\n\t\treturn 0, 0\n\t}\n\treturn (ws.PixelWidth / ws.Width), (ws.PixelHeight / ws.Height)\n}\n"
        },
        {
          "name": "runes.go",
          "type": "blob",
          "size": 3.3125,
          "content": "// Copyright 2015 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\n// The names of these constants are chosen to match Terminfo names,\n// modulo case, and changing the prefix from ACS_ to Rune.  These are\n// the runes we provide extra special handling for, with ASCII fallbacks\n// for terminals that lack them.\nconst (\n\tRuneSterling = '£'\n\tRuneDArrow   = '↓'\n\tRuneLArrow   = '←'\n\tRuneRArrow   = '→'\n\tRuneUArrow   = '↑'\n\tRuneBullet   = '·'\n\tRuneBoard    = '░'\n\tRuneCkBoard  = '▒'\n\tRuneDegree   = '°'\n\tRuneDiamond  = '◆'\n\tRuneGEqual   = '≥'\n\tRunePi       = 'π'\n\tRuneHLine    = '─'\n\tRuneLantern  = '§'\n\tRunePlus     = '┼'\n\tRuneLEqual   = '≤'\n\tRuneLLCorner = '└'\n\tRuneLRCorner = '┘'\n\tRuneNEqual   = '≠'\n\tRunePlMinus  = '±'\n\tRuneS1       = '⎺'\n\tRuneS3       = '⎻'\n\tRuneS7       = '⎼'\n\tRuneS9       = '⎽'\n\tRuneBlock    = '█'\n\tRuneTTee     = '┬'\n\tRuneRTee     = '┤'\n\tRuneLTee     = '├'\n\tRuneBTee     = '┴'\n\tRuneULCorner = '┌'\n\tRuneURCorner = '┐'\n\tRuneVLine    = '│'\n)\n\n// RuneFallbacks is the default map of fallback strings that will be\n// used to replace a rune when no other more appropriate transformation\n// is available, and the rune cannot be displayed directly.\n//\n// New entries may be added to this map over time, as it becomes clear\n// that such is desirable.  Characters that represent either letters or\n// numbers should not be added to this list unless it is certain that\n// the meaning will still convey unambiguously.\n//\n// As an example, it would be appropriate to add an ASCII mapping for\n// the full width form of the letter 'A', but it would not be appropriate\n// to do so a glyph representing the country China.\n//\n// Programs that desire richer fallbacks may register additional ones,\n// or change or even remove these mappings with Screen.RegisterRuneFallback\n// Screen.UnregisterRuneFallback methods.\n//\n// Note that Unicode is presumed to be able to display all glyphs.\n// This is a pretty poor assumption, but there is no easy way to\n// figure out which glyphs are supported in a given font.  Hence,\n// some care in selecting the characters you support in your application\n// is still appropriate.\nvar RuneFallbacks = map[rune]string{\n\tRuneSterling: \"f\",\n\tRuneDArrow:   \"v\",\n\tRuneLArrow:   \"<\",\n\tRuneRArrow:   \">\",\n\tRuneUArrow:   \"^\",\n\tRuneBullet:   \"o\",\n\tRuneBoard:    \"#\",\n\tRuneCkBoard:  \":\",\n\tRuneDegree:   \"\\\\\",\n\tRuneDiamond:  \"+\",\n\tRuneGEqual:   \">\",\n\tRunePi:       \"*\",\n\tRuneHLine:    \"-\",\n\tRuneLantern:  \"#\",\n\tRunePlus:     \"+\",\n\tRuneLEqual:   \"<\",\n\tRuneLLCorner: \"+\",\n\tRuneLRCorner: \"+\",\n\tRuneNEqual:   \"!\",\n\tRunePlMinus:  \"#\",\n\tRuneS1:       \"~\",\n\tRuneS3:       \"-\",\n\tRuneS7:       \"-\",\n\tRuneS9:       \"_\",\n\tRuneBlock:    \"#\",\n\tRuneTTee:     \"+\",\n\tRuneRTee:     \"+\",\n\tRuneLTee:     \"+\",\n\tRuneBTee:     \"+\",\n\tRuneULCorner: \"+\",\n\tRuneURCorner: \"+\",\n\tRuneVLine:    \"|\",\n}\n"
        },
        {
          "name": "runes_test.go",
          "type": "blob",
          "size": 2.6328125,
          "content": "// Copyright 2018 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCanDisplayUTF8(t *testing.T) {\n\ts := mkTestScreen(t, \"UTF-8\")\n\tdefer s.Fini()\n\n\tif s.CharacterSet() != \"UTF-8\" {\n\t\tt.Errorf(\"Bad charset: %v\", s.CharacterSet())\n\t}\n\tif !s.CanDisplay('a', true) {\n\t\tt.Errorf(\"Should be able to display 'a'\")\n\t}\n\tif !s.CanDisplay(RuneHLine, true) {\n\t\tt.Errorf(\"Should be able to display hline (with fallback)\")\n\t}\n\tif !s.CanDisplay(RuneHLine, false) {\n\t\tt.Errorf(\"Should be able to display hline (no fallback)\")\n\t}\n\tif !s.CanDisplay('⌀', false) {\n\t\tt.Errorf(\"Should be able to display null\")\n\t}\n}\nfunc TestCanDisplayASCII(t *testing.T) {\n\ts := mkTestScreen(t, \"US-ASCII\")\n\tdefer s.Fini()\n\n\tif s.CharacterSet() != \"US-ASCII\" {\n\t\tt.Errorf(\"Wrong character set: %v\", s.CharacterSet())\n\t}\n\tif !s.CanDisplay('a', true) {\n\t\tt.Errorf(\"Should be able to display 'a'\")\n\t}\n\tif !s.CanDisplay(RuneHLine, true) {\n\t\tt.Errorf(\"Should be able to display hline (with fallback)\")\n\t}\n\tif s.CanDisplay(RunePi, false) {\n\t\tt.Errorf(\"Should not be able to display Pi (no fallback)\")\n\t}\n\tif s.CanDisplay('⌀', false) {\n\t\tt.Errorf(\"Should not be able to display null\")\n\t}\n}\n\nfunc TestRuneFallbacks(t *testing.T) {\n\ts := mkTestScreen(t, \"US-ASCII\")\n\tdefer s.Fini()\n\tif s.CharacterSet() != \"US-ASCII\" {\n\t\tt.Errorf(\"Wrong character set: %v\", s.CharacterSet())\n\t}\n\n\t// Test registering a fallback\n\ts.RegisterRuneFallback('⌀', \"o\")\n\tif s.CanDisplay('⌀', false) {\n\t\tt.Errorf(\"Should not be able to display null (no fallback)\")\n\t}\n\tif !s.CanDisplay('⌀', true) {\n\t\tt.Errorf(\"Should be able to display null (with fallback)\")\n\t}\n\n\t// Test unregistering custom fallback\n\ts.UnregisterRuneFallback('⌀')\n\tif s.CanDisplay('⌀', false) {\n\t\tt.Errorf(\"Should not be able to display null (no fallback)\")\n\t}\n\tif s.CanDisplay('⌀', true) {\n\t\tt.Errorf(\"Should not be able to display null (with fallback)\")\n\t}\n\n\t// Test unregistering builtin fallback\n\tif !s.CanDisplay(RuneHLine, true) {\n\t\tt.Errorf(\"Should be able to display hline\")\n\t}\n\ts.UnregisterRuneFallback(RuneHLine)\n\tif s.CanDisplay(RuneHLine, true) {\n\t\tt.Errorf(\"Should not be able to display hline\")\n\t}\n}\n"
        },
        {
          "name": "screen.go",
          "type": "blob",
          "size": 16.5693359375,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport \"sync\"\n\n// Screen represents the physical (or emulated) screen.\n// This can be a terminal window or a physical console.  Platforms implement\n// this differently.\ntype Screen interface {\n\t// Init initializes the screen for use.\n\tInit() error\n\n\t// Fini finalizes the screen also releasing resources.\n\tFini()\n\n\t// Clear logically erases the screen.\n\t// This is effectively a short-cut for Fill(' ', StyleDefault).\n\tClear()\n\n\t// Fill fills the screen with the given character and style.\n\t// The effect of filling the screen is not visible until Show\n\t// is called (or Sync).\n\tFill(rune, Style)\n\n\t// SetCell is an older API, and will be removed.  Please use\n\t// SetContent instead; SetCell is implemented in terms of SetContent.\n\tSetCell(x int, y int, style Style, ch ...rune)\n\n\t// GetContent returns the contents at the given location.  If the\n\t// coordinates are out of range, then the values will be 0, nil,\n\t// StyleDefault.  Note that the contents returned are logical contents\n\t// and may not actually be what is displayed, but rather are what will\n\t// be displayed if Show() or Sync() is called.  The width is the width\n\t// in screen cells; most often this will be 1, but some East Asian\n\t// characters and emoji require two cells.\n\tGetContent(x, y int) (primary rune, combining []rune, style Style, width int)\n\n\t// SetContent sets the contents of the given cell location.  If\n\t// the coordinates are out of range, then the operation is ignored.\n\t//\n\t// The first rune is the primary non-zero width rune.  The array\n\t// that follows is a possible list of combining characters to append,\n\t// and will usually be nil (no combining characters.)\n\t//\n\t// The results are not displayed until Show() or Sync() is called.\n\t//\n\t// Note that wide (East Asian full width and emoji) runes occupy two cells,\n\t// and attempts to place character at next cell to the right will have\n\t// undefined effects.  Wide runes that are printed in the\n\t// last column will be replaced with a single width space on output.\n\tSetContent(x int, y int, primary rune, combining []rune, style Style)\n\n\t// SetStyle sets the default style to use when clearing the screen\n\t// or when StyleDefault is specified.  If it is also StyleDefault,\n\t// then whatever system/terminal default is relevant will be used.\n\tSetStyle(style Style)\n\n\t// ShowCursor is used to display the cursor at a given location.\n\t// If the coordinates -1, -1 are given or are otherwise outside the\n\t// dimensions of the screen, the cursor will be hidden.\n\tShowCursor(x int, y int)\n\n\t// HideCursor is used to hide the cursor.  It's an alias for\n\t// ShowCursor(-1, -1).sim\n\tHideCursor()\n\n\t// SetCursorStyle is used to set the cursor style.  If the style\n\t// is not supported (or cursor styles are not supported at all),\n\t// then this will have no effect.  Color will be changed if supplied,\n\t// and the terminal supports doing so.\n\tSetCursorStyle(CursorStyle, ...Color)\n\n\t// Size returns the screen size as width, height.  This changes in\n\t// response to a call to Clear or Flush.\n\tSize() (width, height int)\n\n\t// ChannelEvents is an infinite loop that waits for an event and\n\t// channels it into the user provided channel ch.  Closing the\n\t// quit channel and calling the Fini method are cancellation\n\t// signals.  When a cancellation signal is received the method\n\t// returns after closing ch.\n\t//\n\t// This method should be used as a goroutine.\n\t//\n\t// NOTE: PollEvent should not be called while this method is running.\n\tChannelEvents(ch chan<- Event, quit <-chan struct{})\n\n\t// PollEvent waits for events to arrive.  Main application loops\n\t// must spin on this to prevent the application from stalling.\n\t// Furthermore, this will return nil if the Screen is finalized.\n\tPollEvent() Event\n\n\t// HasPendingEvent returns true if PollEvent would return an event\n\t// without blocking.  If the screen is stopped and PollEvent would\n\t// return nil, then the return value from this function is unspecified.\n\t// The purpose of this function is to allow multiple events to be collected\n\t// at once, to minimize screen redraws.\n\tHasPendingEvent() bool\n\n\t// PostEvent tries to post an event into the event stream.  This\n\t// can fail if the event queue is full.  In that case, the event\n\t// is dropped, and ErrEventQFull is returned.\n\tPostEvent(ev Event) error\n\n\t// Deprecated: PostEventWait is unsafe, and will be removed\n\t// in the future.\n\t//\n\t// PostEventWait is like PostEvent, but if the queue is full, it\n\t// blocks until there is space in the queue, making delivery\n\t// reliable.  However, it is VERY important that this function\n\t// never be called from within whatever event loop is polling\n\t// with PollEvent(), otherwise a deadlock may arise.\n\t//\n\t// For this reason, when using this function, the use of a\n\t// Goroutine is recommended to ensure no deadlock can occur.\n\tPostEventWait(ev Event)\n\n\t// EnableMouse enables the mouse.  (If your terminal supports it.)\n\t// If no flags are specified, then all events are reported, if the\n\t// terminal supports them.\n\tEnableMouse(...MouseFlags)\n\n\t// DisableMouse disables the mouse.\n\tDisableMouse()\n\n\t// EnablePaste enables bracketed paste mode, if supported.\n\tEnablePaste()\n\n\t// DisablePaste disables bracketed paste mode.\n\tDisablePaste()\n\n\t// EnableFocus enables reporting of focus events, if your terminal supports it.\n\tEnableFocus()\n\n\t// DisableFocus disables reporting of focus events.\n\tDisableFocus()\n\n\t// HasMouse returns true if the terminal (apparently) supports a\n\t// mouse.  Note that the return value of true doesn't guarantee that\n\t// a mouse/pointing device is present; a false return definitely\n\t// indicates no mouse support is available.\n\tHasMouse() bool\n\n\t// Colors returns the number of colors.  All colors are assumed to\n\t// use the ANSI color map.  If a terminal is monochrome, it will\n\t// return 0.\n\tColors() int\n\n\t// Show makes all the content changes made using SetContent() visible\n\t// on the display.\n\t//\n\t// It does so in the most efficient and least visually disruptive\n\t// manner possible.\n\tShow()\n\n\t// Sync works like Show(), but it updates every visible cell on the\n\t// physical display, assuming that it is not synchronized with any\n\t// internal model.  This may be both expensive and visually jarring,\n\t// so it should only be used when believed to actually be necessary.\n\t//\n\t// Typically, this is called as a result of a user-requested redraw\n\t// (e.g. to clear up on-screen corruption caused by some other program),\n\t// or during a resize event.\n\tSync()\n\n\t// CharacterSet returns information about the character set.\n\t// This isn't the full locale, but it does give us the input/output\n\t// character set.  Note that this is just for diagnostic purposes,\n\t// we normally translate input/output to/from UTF-8, regardless of\n\t// what the user's environment is.\n\tCharacterSet() string\n\n\t// RegisterRuneFallback adds a fallback for runes that are not\n\t// part of the character set -- for example one could register\n\t// o as a fallback for ø.  This should be done cautiously for\n\t// characters that might be displayed ordinarily in language\n\t// specific text -- characters that could change the meaning of\n\t// written text would be dangerous.  The intention here is to\n\t// facilitate fallback characters in pseudo-graphical applications.\n\t//\n\t// If the terminal has fallbacks already in place via an alternate\n\t// character set, those are used in preference.  Also, standard\n\t// fallbacks for graphical characters in the alternate character set\n\t// terminfo string are registered implicitly.\n\t//\n\t// The display string should be the same width as original rune.\n\t// This makes it possible to register two character replacements\n\t// for full width East Asian characters, for example.\n\t//\n\t// It is recommended that replacement strings consist only of\n\t// 7-bit ASCII, since other characters may not display everywhere.\n\tRegisterRuneFallback(r rune, subst string)\n\n\t// UnregisterRuneFallback unmaps a replacement.  It will unmap\n\t// the implicit ASCII replacements for alternate characters as well.\n\t// When an unmapped char needs to be displayed, but no suitable\n\t// glyph is available, '?' is emitted instead.  It is not possible\n\t// to \"disable\" the use of alternate characters that are supported\n\t// by your terminal except by changing the terminal database.\n\tUnregisterRuneFallback(r rune)\n\n\t// CanDisplay returns true if the given rune can be displayed on\n\t// this screen.  Note that this is a best-guess effort -- whether\n\t// your fonts support the character or not may be questionable.\n\t// Mostly this is for folks who work outside of Unicode.\n\t//\n\t// If checkFallbacks is true, then if any (possibly imperfect)\n\t// fallbacks are registered, this will return true.  This will\n\t// also return true if the terminal can replace the glyph with\n\t// one that is visually indistinguishable from the one requested.\n\tCanDisplay(r rune, checkFallbacks bool) bool\n\n\t// Resize does nothing, since it's generally not possible to\n\t// ask a screen to resize, but it allows the Screen to implement\n\t// the View interface.\n\tResize(int, int, int, int)\n\n\t// HasKey returns true if the keyboard is believed to have the\n\t// key.  In some cases a keyboard may have keys with this name\n\t// but no support for them, while in others a key may be reported\n\t// as supported but not actually be usable (such as some emulators\n\t// that hijack certain keys).  Its best not to depend to strictly\n\t// on this function, but it can be used for hinting when building\n\t// menus, displayed hot-keys, etc.  Note that KeyRune (literal\n\t// runes) is always true.\n\tHasKey(Key) bool\n\n\t// Suspend pauses input and output processing.  It also restores the\n\t// terminal settings to what they were when the application started.\n\t// This can be used to, for example, run a sub-shell.\n\tSuspend() error\n\n\t// Resume resumes after Suspend().\n\tResume() error\n\n\t// Beep attempts to sound an OS-dependent audible alert and returns an error\n\t// when unsuccessful.\n\tBeep() error\n\n\t// SetSize attempts to resize the window.  It also invalidates the cells and\n\t// calls the resize function.  Note that if the window size is changed, it will\n\t// not be restored upon application exit.\n\t//\n\t// Many terminals cannot support this.  Perversely, the \"modern\" Windows Terminal\n\t// does not support application-initiated resizing, whereas the legacy terminal does.\n\t// Also, some emulators can support this but may have it disabled by default.\n\tSetSize(int, int)\n\n\t// LockRegion sets or unsets a lock on a region of cells. A lock on a\n\t// cell prevents the cell from being redrawn.\n\tLockRegion(x, y, width, height int, lock bool)\n\n\t// Tty returns the underlying Tty. If the screen is not a terminal, the\n\t// returned bool will be false\n\tTty() (Tty, bool)\n\n\t// SetTitle sets a window title on the screen.\n\t// Terminals may be configured to ignore this, or unable to.\n\t// Tcell may attempt to save and restore the window title on entry and exit, but\n\t// the results may vary.  Use of unicode characters may not be supported.\n\tSetTitle(string)\n\n\t// SetClipboard is used to post arbitrary data to the system clipboard.\n\t// This need not be UTF-8 string data.  It's up to the recipient to decode the\n\t// data meaningfully.  Terminals may prevent this for security reasons.\n\tSetClipboard([]byte)\n\n\t// GetClipboard is used to request the clipboard contents.  It may be ignored.\n\t// If the terminal is willing, it will be post the clipboard contents using an\n\t// EventPaste with the clipboard content as the Data() field.  Terminals may\n\t// prevent this for security reasons.\n\tGetClipboard()\n}\n\n// NewScreen returns a default Screen suitable for the user's terminal\n// environment.\nfunc NewScreen() (Screen, error) {\n\t// Windows is happier if we try for a console screen first.\n\tif s, _ := NewConsoleScreen(); s != nil {\n\t\treturn s, nil\n\t} else if s, e := NewTerminfoScreen(); s != nil {\n\t\treturn s, nil\n\t} else {\n\t\treturn nil, e\n\t}\n}\n\n// MouseFlags are options to modify the handling of mouse events.\n// Actual events can be ORed together.\ntype MouseFlags int\n\nconst (\n\tMouseButtonEvents = MouseFlags(1) // Click events only\n\tMouseDragEvents   = MouseFlags(2) // Click-drag events (includes button events)\n\tMouseMotionEvents = MouseFlags(4) // All mouse events (includes click and drag events)\n)\n\n// CursorStyle represents a given cursor style, which can include the shape and\n// whether the cursor blinks or is solid.  Support for changing this is not universal.\ntype CursorStyle int\n\nconst (\n\tCursorStyleDefault = CursorStyle(iota) // The default\n\tCursorStyleBlinkingBlock\n\tCursorStyleSteadyBlock\n\tCursorStyleBlinkingUnderline\n\tCursorStyleSteadyUnderline\n\tCursorStyleBlinkingBar\n\tCursorStyleSteadyBar\n)\n\n// screenImpl is a subset of Screen that can be used with baseScreen to formulate\n// a complete implementation of Screen.  See Screen for doc comments about methods.\ntype screenImpl interface {\n\tInit() error\n\tFini()\n\tSetStyle(style Style)\n\tShowCursor(x int, y int)\n\tHideCursor()\n\tSetCursor(CursorStyle, Color)\n\tSize() (width, height int)\n\tEnableMouse(...MouseFlags)\n\tDisableMouse()\n\tEnablePaste()\n\tDisablePaste()\n\tEnableFocus()\n\tDisableFocus()\n\tHasMouse() bool\n\tColors() int\n\tShow()\n\tSync()\n\tCharacterSet() string\n\tRegisterRuneFallback(r rune, subst string)\n\tUnregisterRuneFallback(r rune)\n\tCanDisplay(r rune, checkFallbacks bool) bool\n\tResize(int, int, int, int)\n\tHasKey(Key) bool\n\tSuspend() error\n\tResume() error\n\tBeep() error\n\tSetSize(int, int)\n\tSetTitle(string)\n\tTty() (Tty, bool)\n\tSetClipboard([]byte)\n\tGetClipboard()\n\n\t// Following methods are not part of the Screen api, but are used for interaction with\n\t// the common layer code.\n\n\t// Locker locks the underlying data structures so that we can access them\n\t// in a thread-safe way.\n\tsync.Locker\n\n\t// GetCells returns a pointer to the underlying CellBuffer that the implementation uses.\n\t// Various methods will write to these for performance, but will use the lock to do so.\n\tGetCells() *CellBuffer\n\n\t// StopQ is closed when the screen is shut down via Fini.  It remains open if the screen\n\t// is merely suspended.\n\tStopQ() <-chan struct{}\n\n\t// EventQ delivers events.  Events are posted to this by the screen in response to\n\t// key presses, resizes, etc.  Application code receives events from this via the\n\t// Screen.PollEvent, Screen.ChannelEvents APIs.\n\tEventQ() chan Event\n}\n\ntype baseScreen struct {\n\tscreenImpl\n}\n\nfunc (b *baseScreen) SetCell(x int, y int, style Style, ch ...rune) {\n\tif len(ch) > 0 {\n\t\tb.SetContent(x, y, ch[0], ch[1:], style)\n\t} else {\n\t\tb.SetContent(x, y, ' ', nil, style)\n\t}\n}\n\nfunc (b *baseScreen) Clear() {\n\tb.Fill(' ', StyleDefault)\n}\n\nfunc (b *baseScreen) Fill(r rune, style Style) {\n\tcb := b.GetCells()\n\tb.Lock()\n\tcb.Fill(r, style)\n\tb.Unlock()\n}\n\nfunc (b *baseScreen) SetContent(x, y int, mainc rune, combc []rune, st Style) {\n\n\tcells := b.GetCells()\n\tb.Lock()\n\tcells.SetContent(x, y, mainc, combc, st)\n\tb.Unlock()\n}\n\nfunc (b *baseScreen) GetContent(x, y int) (rune, []rune, Style, int) {\n\tvar primary rune\n\tvar combining []rune\n\tvar style Style\n\tvar width int\n\tcells := b.GetCells()\n\tb.Lock()\n\tprimary, combining, style, width = cells.GetContent(x, y)\n\tb.Unlock()\n\treturn primary, combining, style, width\n}\n\nfunc (b *baseScreen) LockRegion(x, y, width, height int, lock bool) {\n\tcells := b.GetCells()\n\tb.Lock()\n\tfor j := y; j < (y + height); j += 1 {\n\t\tfor i := x; i < (x + width); i += 1 {\n\t\t\tswitch lock {\n\t\t\tcase true:\n\t\t\t\tcells.LockCell(i, j)\n\t\t\tcase false:\n\t\t\t\tcells.UnlockCell(i, j)\n\t\t\t}\n\t\t}\n\t}\n\tb.Unlock()\n}\n\nfunc (b *baseScreen) ChannelEvents(ch chan<- Event, quit <-chan struct{}) {\n\tdefer close(ch)\n\tfor {\n\t\tselect {\n\t\tcase <-quit:\n\t\t\treturn\n\t\tcase <-b.StopQ():\n\t\t\treturn\n\t\tcase ev := <-b.EventQ():\n\t\t\tselect {\n\t\t\tcase <-quit:\n\t\t\t\treturn\n\t\t\tcase <-b.StopQ():\n\t\t\t\treturn\n\t\t\tcase ch <- ev:\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (b *baseScreen) PollEvent() Event {\n\tselect {\n\tcase <-b.StopQ():\n\t\treturn nil\n\tcase ev := <-b.EventQ():\n\t\treturn ev\n\t}\n}\n\nfunc (b *baseScreen) HasPendingEvent() bool {\n\treturn len(b.EventQ()) > 0\n}\n\nfunc (b *baseScreen) PostEventWait(ev Event) {\n\tselect {\n\tcase b.EventQ() <- ev:\n\tcase <-b.StopQ():\n\t}\n}\n\nfunc (b *baseScreen) PostEvent(ev Event) error {\n\tselect {\n\tcase b.EventQ() <- ev:\n\t\treturn nil\n\tdefault:\n\t\treturn ErrEventQFull\n\t}\n}\n\nfunc (b *baseScreen) SetCursorStyle(cs CursorStyle, ccs ...Color) {\n\tif len(ccs) > 0 {\n\t\tb.SetCursor(cs, ccs[0])\n\t} else {\n\t\tb.SetCursor(cs, ColorNone)\n\t}\n}\n"
        },
        {
          "name": "sim_test.go",
          "type": "blob",
          "size": 4.0224609375,
          "content": "// Copyright 2023 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"testing\"\n)\n\nfunc mkTestScreen(t *testing.T, charset string) SimulationScreen {\n\ts := NewSimulationScreen(charset)\n\tif s == nil {\n\t\tt.Fatalf(\"Failed to get simulation screen\")\n\t}\n\tif e := s.Init(); e != nil {\n\t\tt.Fatalf(\"Failed to initialize screen: %v\", e)\n\t}\n\treturn s\n}\n\nfunc TestInitScreen(t *testing.T) {\n\n\ts := mkTestScreen(t, \"\")\n\tdefer s.Fini()\n\n\tif x, y := s.Size(); x != 80 || y != 25 {\n\t\tt.Fatalf(\"Size should be 80, 25, was %v, %v\", x, y)\n\t}\n\tif s.CharacterSet() != \"UTF-8\" {\n\t\tt.Fatalf(\"Character Set (%v) not UTF-8\", s.CharacterSet())\n\t}\n\tif b, x, y := s.GetContents(); len(b) != x*y || x != 80 || y != 25 {\n\t\tt.Fatalf(\"Contents (%v, %v, %v) wrong\", len(b), x, y)\n\t}\n}\n\nfunc TestClearScreen(t *testing.T) {\n\ts := mkTestScreen(t, \"\")\n\tdefer s.Fini()\n\ts.Clear()\n\tb, x, y := s.GetContents()\n\tif len(b) != x*y || x != 80 || y != 25 {\n\t\tt.Fatalf(\"Contents (%v, %v, %v) wrong\", len(b), x, y)\n\t}\n\tfor i := 0; i < x*y; i++ {\n\t\tif len(b[i].Runes) == 1 && b[i].Runes[0] != ' ' {\n\t\t\tt.Errorf(\"Incorrect contents at %v: %v\", i, b[i].Runes)\n\t\t}\n\t\tif b[i].Style != StyleDefault {\n\t\t\tt.Errorf(\"Incorrect style at %v: %v\", i, b[i].Style)\n\t\t}\n\t}\n}\n\nfunc TestSetCell(t *testing.T) {\n\tst := StyleDefault.Background(ColorRed).Blink(true)\n\ts := mkTestScreen(t, \"\")\n\tdefer s.Fini()\n\ts.SetCell(2, 5, st, '@')\n\tb, _, _ := s.GetContents()\n\ts.Show()\n\tif len(b) != 80*25 {\n\t\tt.Fatalf(\"Wrong content size\")\n\t}\n\tcell := &b[5*80+2]\n\tif len(cell.Runes) != 1 || len(cell.Bytes) != 1 ||\n\t\tcell.Runes[0] != '@' || cell.Bytes[0] != '@' ||\n\t\tcell.Style != st {\n\t\tt.Errorf(\"Incorrect cell content: %v\", cell)\n\t}\n}\n\nfunc TestResize(t *testing.T) {\n\tst := StyleDefault.Background(ColorYellow).Underline(true)\n\ts := mkTestScreen(t, \"\")\n\tdefer s.Fini()\n\ts.SetCell(2, 5, st, '&')\n\tb, x, y := s.GetContents()\n\ts.Show()\n\n\tcell := &b[5*80+2]\n\tif len(cell.Runes) != 1 || len(cell.Bytes) != 1 ||\n\t\tcell.Runes[0] != '&' || cell.Bytes[0] != '&' ||\n\t\tcell.Style != st {\n\t\tt.Errorf(\"Incorrect cell content: %v\", cell)\n\t}\n\ts.SetSize(30, 10)\n\ts.Show()\n\tb2, x2, y2 := s.GetContents()\n\tif len(b2) == len(b) || x2 == x || y2 == y {\n\t\tt.Errorf(\"Screen parameters should not match\")\n\t}\n\n\tcell2 := &b[5*80+2]\n\tif len(cell2.Runes) != 1 || len(cell2.Bytes) != 1 ||\n\t\tcell2.Runes[0] != '&' || cell2.Bytes[0] != '&' ||\n\t\tcell2.Style != st {\n\t\tt.Errorf(\"Incorrect cell content after resize: %v\", cell2)\n\t}\n}\n\nfunc TestBeep(t *testing.T) {\n\ts := mkTestScreen(t, \"\")\n\tdefer s.Fini()\n\n\tb0, x0, y0 := s.GetContents()\n\n\tif err := s.Beep(); err != nil {\n\t\tt.Errorf(\"could not beep: %v\", err)\n\t}\n\ts.Show()\n\n\tb1, x1, y1 := s.GetContents()\n\tif x0 != x1 {\n\t\tt.Fatalf(\"screen width changed unexpectedly from %d to %d\", x0, x1)\n\t}\n\tif y0 != y1 {\n\t\tt.Fatalf(\"screen height changed unexpectedly from %d to %d\", y0, y1)\n\t}\n\tif len(b0) != len(b1) {\n\t\tt.Fatalf(\"screen size changed unexpectedly (had %d cells, has %d cells)\",\n\t\t\tlen(b0), len(b1))\n\t}\n\tfor i := 0; i < len(b0); i++ {\n\t\tcell0 := b0[i]\n\t\tcell1 := b1[i]\n\t\tif len(cell0.Runes) != len(cell1.Runes) {\n\t\t\tt.Errorf(\"incorrect cell content: had %d runes, has %d runes\",\n\t\t\t\tlen(cell0.Runes), len(cell1.Runes))\n\t\t\tcontinue\n\t\t}\n\t\tfor j := 0; j < len(cell0.Runes); j++ {\n\t\t\tr0 := cell0.Runes[j]\n\t\t\tr1 := cell1.Runes[j]\n\t\t\tif r0 != r1 {\n\t\t\t\tt.Errorf(\"incorrect content: cell %d rune %d changed from %v to %v\",\n\t\t\t\t\ti, j, r0, r1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTitle(t *testing.T) {\n\ts := mkTestScreen(t, \"\")\n\tdefer s.Fini()\n\ts.SetTitle(\"My Title\")\n\ts.Show()\n\tif s.GetTitle() != \"My Title\" {\n\t\tt.Errorf(\"Title mismatched\")\n\t}\n}\n"
        },
        {
          "name": "simulation.go",
          "type": "blob",
          "size": 10.419921875,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"sync\"\n\t\"unicode/utf8\"\n\n\t\"golang.org/x/text/transform\"\n)\n\n// NewSimulationScreen returns a SimulationScreen.  Note that\n// SimulationScreen is also a Screen.\nfunc NewSimulationScreen(charset string) SimulationScreen {\n\tif charset == \"\" {\n\t\tcharset = \"UTF-8\"\n\t}\n\tss := &simscreen{charset: charset}\n\tss.Screen = &baseScreen{screenImpl: ss}\n\treturn ss\n}\n\n// SimulationScreen represents a screen simulation.  This is intended to\n// be a superset of normal Screens, but also adds some important interfaces\n// for testing.\ntype SimulationScreen interface {\n\tScreen\n\n\t// InjectKeyBytes injects a stream of bytes corresponding to\n\t// the native encoding (see charset).  It turns true if the entire\n\t// set of bytes were processed and delivered as KeyEvents, false\n\t// if any bytes were not fully understood.  Any bytes that are not\n\t// fully converted are discarded.\n\tInjectKeyBytes(buf []byte) bool\n\n\t// InjectKey injects a key event.  The rune is a UTF-8 rune, post\n\t// any translation.\n\tInjectKey(key Key, r rune, mod ModMask)\n\n\t// InjectMouse injects a mouse event.\n\tInjectMouse(x, y int, buttons ButtonMask, mod ModMask)\n\n\t// GetContents returns screen contents as an array of\n\t// cells, along with the physical width & height.   Note that the\n\t// physical contents will be used until the next time SetSize()\n\t// is called.\n\tGetContents() (cells []SimCell, width int, height int)\n\n\t// GetCursor returns the cursor details.\n\tGetCursor() (x int, y int, visible bool)\n\n\t// GetTitle gets the previously set title.\n\tGetTitle() string\n\n\t// GetClipboardData gets the actual data for the clipboard.\n\tGetClipboardData() []byte\n}\n\n// SimCell represents a simulated screen cell.  The purpose of this\n// is to track on screen content.\ntype SimCell struct {\n\t// Bytes is the actual character bytes.  Normally this is\n\t// rune data, but it could be be data in another encoding system.\n\tBytes []byte\n\n\t// Style is the style used to display the data.\n\tStyle Style\n\n\t// Runes is the list of runes, unadulterated, in UTF-8.\n\tRunes []rune\n}\n\ntype simscreen struct {\n\tphysw int\n\tphysh int\n\tfini  bool\n\tstyle Style\n\tevch  chan Event\n\tquit  chan struct{}\n\n\tfront     []SimCell\n\tback      CellBuffer\n\tclear     bool\n\tcursorx   int\n\tcursory   int\n\tcursorvis bool\n\tmouse     bool\n\tpaste     bool\n\tcharset   string\n\tencoder   transform.Transformer\n\tdecoder   transform.Transformer\n\tfillchar  rune\n\tfillstyle Style\n\tfallback  map[rune]string\n\ttitle     string\n\tclipboard []byte\n\n\tScreen\n\tsync.Mutex\n}\n\nfunc (s *simscreen) Init() error {\n\ts.evch = make(chan Event, 10)\n\ts.quit = make(chan struct{})\n\ts.fillchar = 'X'\n\ts.fillstyle = StyleDefault\n\ts.mouse = false\n\ts.physw = 80\n\ts.physh = 25\n\ts.cursorx = -1\n\ts.cursory = -1\n\ts.style = StyleDefault\n\n\tif enc := GetEncoding(s.charset); enc != nil {\n\t\ts.encoder = enc.NewEncoder()\n\t\ts.decoder = enc.NewDecoder()\n\t} else {\n\t\treturn ErrNoCharset\n\t}\n\n\ts.front = make([]SimCell, s.physw*s.physh)\n\ts.back.Resize(80, 25)\n\n\t// default fallbacks\n\ts.fallback = make(map[rune]string)\n\tfor k, v := range RuneFallbacks {\n\t\ts.fallback[k] = v\n\t}\n\treturn nil\n}\n\nfunc (s *simscreen) Fini() {\n\ts.Lock()\n\ts.fini = true\n\ts.back.Resize(0, 0)\n\ts.Unlock()\n\tif s.quit != nil {\n\t\tclose(s.quit)\n\t}\n\ts.physw = 0\n\ts.physh = 0\n\ts.front = nil\n}\n\nfunc (s *simscreen) SetStyle(style Style) {\n\ts.Lock()\n\ts.style = style\n\ts.Unlock()\n}\n\nfunc (s *simscreen) drawCell(x, y int) int {\n\n\tmainc, combc, style, width := s.back.GetContent(x, y)\n\tif !s.back.Dirty(x, y) {\n\t\treturn width\n\t}\n\tif x >= s.physw || y >= s.physh || x < 0 || y < 0 {\n\t\treturn width\n\t}\n\tsimc := &s.front[(y*s.physw)+x]\n\n\tif style == StyleDefault {\n\t\tstyle = s.style\n\t}\n\tsimc.Style = style\n\tsimc.Runes = append([]rune{mainc}, combc...)\n\n\t// now emit runes - taking care to not overrun width with a\n\t// wide character, and to ensure that we emit exactly one regular\n\t// character followed up by any residual combing characters\n\n\tsimc.Bytes = nil\n\n\tif x > s.physw-width {\n\t\tsimc.Runes = []rune{' '}\n\t\tsimc.Bytes = []byte{' '}\n\t\treturn width\n\t}\n\n\tlbuf := make([]byte, 12)\n\tubuf := make([]byte, 12)\n\tnout := 0\n\n\tfor _, r := range simc.Runes {\n\n\t\tl := utf8.EncodeRune(ubuf, r)\n\n\t\tnout, _, _ = s.encoder.Transform(lbuf, ubuf[:l], true)\n\n\t\tif nout == 0 || lbuf[0] == '\\x1a' {\n\n\t\t\t// skip combining\n\n\t\t\tif subst, ok := s.fallback[r]; ok {\n\t\t\t\tsimc.Bytes = append(simc.Bytes,\n\t\t\t\t\t[]byte(subst)...)\n\n\t\t\t} else if r >= ' ' && r <= '~' {\n\t\t\t\tsimc.Bytes = append(simc.Bytes, byte(r))\n\n\t\t\t} else if simc.Bytes == nil {\n\t\t\t\tsimc.Bytes = append(simc.Bytes, '?')\n\t\t\t}\n\t\t} else {\n\t\t\tsimc.Bytes = append(simc.Bytes, lbuf[:nout]...)\n\t\t}\n\t}\n\ts.back.SetDirty(x, y, false)\n\treturn width\n}\n\nfunc (s *simscreen) ShowCursor(x, y int) {\n\ts.Lock()\n\ts.cursorx, s.cursory = x, y\n\ts.showCursor()\n\ts.Unlock()\n}\n\nfunc (s *simscreen) HideCursor() {\n\ts.ShowCursor(-1, -1)\n}\n\nfunc (s *simscreen) showCursor() {\n\n\tx, y := s.cursorx, s.cursory\n\tif x < 0 || y < 0 || x >= s.physw || y >= s.physh {\n\t\ts.cursorvis = false\n\t} else {\n\t\ts.cursorvis = true\n\t}\n}\n\nfunc (s *simscreen) hideCursor() {\n\t// does not update cursor position\n\ts.cursorvis = false\n}\n\nfunc (s *simscreen) SetCursor(CursorStyle, Color) {}\n\nfunc (s *simscreen) Show() {\n\ts.Lock()\n\ts.resize()\n\ts.draw()\n\ts.Unlock()\n}\n\nfunc (s *simscreen) clearScreen() {\n\t// We emulate a hardware clear by filling with a specific pattern\n\tfor i := range s.front {\n\t\ts.front[i].Style = s.fillstyle\n\t\ts.front[i].Runes = []rune{s.fillchar}\n\t\ts.front[i].Bytes = []byte{byte(s.fillchar)}\n\t}\n\ts.clear = false\n}\n\nfunc (s *simscreen) draw() {\n\ts.hideCursor()\n\tif s.clear {\n\t\ts.clearScreen()\n\t}\n\n\tw, h := s.back.Size()\n\tfor y := 0; y < h; y++ {\n\t\tfor x := 0; x < w; x++ {\n\t\t\twidth := s.drawCell(x, y)\n\t\t\tx += width - 1\n\t\t}\n\t}\n\ts.showCursor()\n}\n\nfunc (s *simscreen) EnableMouse(...MouseFlags) {\n\ts.mouse = true\n}\n\nfunc (s *simscreen) DisableMouse() {\n\ts.mouse = false\n}\n\nfunc (s *simscreen) EnablePaste() {\n\ts.paste = true\n}\n\nfunc (s *simscreen) DisablePaste() {\n\ts.paste = false\n}\n\nfunc (s *simscreen) EnableFocus() {\n}\n\nfunc (s *simscreen) DisableFocus() {\n}\n\nfunc (s *simscreen) Size() (int, int) {\n\ts.Lock()\n\tw, h := s.back.Size()\n\ts.Unlock()\n\treturn w, h\n}\n\nfunc (s *simscreen) resize() {\n\tw, h := s.physw, s.physh\n\tow, oh := s.back.Size()\n\tif w != ow || h != oh {\n\t\ts.back.Resize(w, h)\n\t\tev := NewEventResize(w, h)\n\t\ts.postEvent(ev)\n\t}\n}\n\nfunc (s *simscreen) Colors() int {\n\treturn 256\n}\n\nfunc (s *simscreen) postEvent(ev Event) {\n\tselect {\n\tcase s.evch <- ev:\n\tcase <-s.quit:\n\t}\n}\n\nfunc (s *simscreen) InjectMouse(x, y int, buttons ButtonMask, mod ModMask) {\n\tev := NewEventMouse(x, y, buttons, mod)\n\ts.postEvent(ev)\n}\n\nfunc (s *simscreen) InjectKey(key Key, r rune, mod ModMask) {\n\tev := NewEventKey(key, r, mod)\n\ts.postEvent(ev)\n}\n\nfunc (s *simscreen) InjectKeyBytes(b []byte) bool {\n\tfailed := false\n\nouter:\n\tfor len(b) > 0 {\n\t\tif b[0] >= ' ' && b[0] <= 0x7F {\n\t\t\t// printable ASCII easy to deal with -- no encodings\n\t\t\tev := NewEventKey(KeyRune, rune(b[0]), ModNone)\n\t\t\ts.postEvent(ev)\n\t\t\tb = b[1:]\n\t\t\tcontinue\n\t\t}\n\n\t\tif b[0] < 0x80 {\n\t\t\tmod := ModNone\n\t\t\t// No encodings start with low numbered values\n\t\t\tif Key(b[0]) >= KeyCtrlA && Key(b[0]) <= KeyCtrlZ {\n\t\t\t\tmod = ModCtrl\n\t\t\t}\n\t\t\tev := NewEventKey(Key(b[0]), 0, mod)\n\t\t\ts.postEvent(ev)\n\t\t\tb = b[1:]\n\t\t\tcontinue\n\t\t}\n\n\t\tutfb := make([]byte, len(b)*4) // worst case\n\t\tfor l := 1; l < len(b); l++ {\n\t\t\ts.decoder.Reset()\n\t\t\tnout, nin, _ := s.decoder.Transform(utfb, b[:l], true)\n\n\t\t\tif nout != 0 {\n\t\t\t\tr, _ := utf8.DecodeRune(utfb[:nout])\n\t\t\t\tif r != utf8.RuneError {\n\t\t\t\t\tev := NewEventKey(KeyRune, r, ModNone)\n\t\t\t\t\ts.postEvent(ev)\n\t\t\t\t}\n\t\t\t\tb = b[nin:]\n\t\t\t\tcontinue outer\n\t\t\t}\n\t\t}\n\t\tfailed = true\n\t\tb = b[1:]\n\t\tcontinue\n\t}\n\n\treturn !failed\n}\n\nfunc (s *simscreen) Sync() {\n\ts.Lock()\n\ts.clear = true\n\ts.resize()\n\ts.back.Invalidate()\n\ts.draw()\n\ts.Unlock()\n}\n\nfunc (s *simscreen) CharacterSet() string {\n\treturn s.charset\n}\n\nfunc (s *simscreen) SetSize(w, h int) {\n\ts.Lock()\n\tnewc := make([]SimCell, w*h)\n\tfor row := 0; row < h && row < s.physh; row++ {\n\t\tfor col := 0; col < w && col < s.physw; col++ {\n\t\t\tnewc[(row*w)+col] = s.front[(row*s.physw)+col]\n\t\t}\n\t}\n\ts.cursorx, s.cursory = -1, -1\n\ts.physw, s.physh = w, h\n\ts.front = newc\n\ts.back.Resize(w, h)\n\ts.Unlock()\n}\n\nfunc (s *simscreen) GetContents() ([]SimCell, int, int) {\n\ts.Lock()\n\tcells, w, h := s.front, s.physw, s.physh\n\ts.Unlock()\n\treturn cells, w, h\n}\n\nfunc (s *simscreen) GetCursor() (int, int, bool) {\n\ts.Lock()\n\tx, y, vis := s.cursorx, s.cursory, s.cursorvis\n\ts.Unlock()\n\treturn x, y, vis\n}\n\nfunc (s *simscreen) RegisterRuneFallback(r rune, subst string) {\n\ts.Lock()\n\ts.fallback[r] = subst\n\ts.Unlock()\n}\n\nfunc (s *simscreen) UnregisterRuneFallback(r rune) {\n\ts.Lock()\n\tdelete(s.fallback, r)\n\ts.Unlock()\n}\n\nfunc (s *simscreen) CanDisplay(r rune, checkFallbacks bool) bool {\n\n\tif enc := s.encoder; enc != nil {\n\t\tnb := make([]byte, 6)\n\t\tob := make([]byte, 6)\n\t\tnum := utf8.EncodeRune(ob, r)\n\n\t\tenc.Reset()\n\t\tdst, _, err := enc.Transform(nb, ob[:num], true)\n\t\tif dst != 0 && err == nil && nb[0] != '\\x1A' {\n\t\t\treturn true\n\t\t}\n\t}\n\tif !checkFallbacks {\n\t\treturn false\n\t}\n\tif _, ok := s.fallback[r]; ok {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *simscreen) HasMouse() bool {\n\treturn false\n}\n\nfunc (s *simscreen) Resize(int, int, int, int) {}\n\nfunc (s *simscreen) HasKey(Key) bool {\n\treturn true\n}\n\nfunc (s *simscreen) Beep() error {\n\treturn nil\n}\n\nfunc (s *simscreen) Suspend() error {\n\treturn nil\n}\n\nfunc (s *simscreen) Resume() error {\n\treturn nil\n}\n\nfunc (s *simscreen) Tty() (Tty, bool) {\n\treturn nil, false\n}\n\nfunc (s *simscreen) GetCells() *CellBuffer {\n\treturn &s.back\n}\n\nfunc (s *simscreen) EventQ() chan Event {\n\treturn s.evch\n}\n\nfunc (s *simscreen) StopQ() <-chan struct{} {\n\treturn s.quit\n}\n\nfunc (s *simscreen) SetTitle(title string) {\n\ts.title = title\n}\n\nfunc (s *simscreen) GetTitle() string {\n\treturn s.title\n}\n\nfunc (s *simscreen) SetClipboard(data []byte) {\n\ts.clipboard = data\n}\n\nfunc (s *simscreen) GetClipboard() {\n\tif s.clipboard != nil {\n\t\tev := NewEventClipboard(s.clipboard)\n\t\ts.postEvent(ev)\n\t}\n}\n\nfunc (s *simscreen) GetClipboardData() []byte {\n\treturn s.clipboard\n}\n"
        },
        {
          "name": "stdin_unix.go",
          "type": "blob",
          "size": 4.2353515625,
          "content": "// Copyright 2021 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris || zos\n// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris zos\n\npackage tcell\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strconv\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n\t\"golang.org/x/term\"\n)\n\n// stdIoTty is an implementation of the Tty API based upon stdin/stdout.\ntype stdIoTty struct {\n\tfd    int\n\tin    *os.File\n\tout   *os.File\n\tsaved *term.State\n\tsig   chan os.Signal\n\tcb    func()\n\tstopQ chan struct{}\n\tdev   string\n\twg    sync.WaitGroup\n\tl     sync.Mutex\n}\n\nfunc (tty *stdIoTty) Read(b []byte) (int, error) {\n\treturn tty.in.Read(b)\n}\n\nfunc (tty *stdIoTty) Write(b []byte) (int, error) {\n\treturn tty.out.Write(b)\n}\n\nfunc (tty *stdIoTty) Close() error {\n\treturn nil\n}\n\nfunc (tty *stdIoTty) Start() error {\n\ttty.l.Lock()\n\tdefer tty.l.Unlock()\n\n\t// We open another copy of /dev/tty.  This is a workaround for unusual behavior\n\t// observed in macOS, apparently caused when a sub-shell (for example) closes our\n\t// own tty device (when it exits for example).  Getting a fresh new one seems to\n\t// resolve the problem.  (We believe this is a bug in the macOS tty driver that\n\t// fails to account for dup() references to the same file before applying close()\n\t// related behaviors to the tty.)  We're also holding the original copy we opened\n\t// since closing that might have deleterious effects as well.  The upshot is that\n\t// we will have up to two separate file handles open on /dev/tty.  (Note that when\n\t// using stdin/stdout instead of /dev/tty this problem is not observed.)\n\tvar err error\n\ttty.in = os.Stdin\n\ttty.out = os.Stdout\n\ttty.fd = int(tty.in.Fd())\n\n\tif !term.IsTerminal(tty.fd) {\n\t\treturn errors.New(\"device is not a terminal\")\n\t}\n\n\t_ = tty.in.SetReadDeadline(time.Time{})\n\tsaved, err := term.MakeRaw(tty.fd) // also sets vMin and vTime\n\tif err != nil {\n\t\treturn err\n\t}\n\ttty.saved = saved\n\n\ttty.stopQ = make(chan struct{})\n\ttty.wg.Add(1)\n\tgo func(stopQ chan struct{}) {\n\t\tdefer tty.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-tty.sig:\n\t\t\t\ttty.l.Lock()\n\t\t\t\tcb := tty.cb\n\t\t\t\ttty.l.Unlock()\n\t\t\t\tif cb != nil {\n\t\t\t\t\tcb()\n\t\t\t\t}\n\t\t\tcase <-stopQ:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}(tty.stopQ)\n\n\tsignal.Notify(tty.sig, syscall.SIGWINCH)\n\treturn nil\n}\n\nfunc (tty *stdIoTty) Drain() error {\n\t_ = tty.in.SetReadDeadline(time.Now())\n\tif err := tcSetBufParams(tty.fd, 0, 0); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (tty *stdIoTty) Stop() error {\n\ttty.l.Lock()\n\tif err := term.Restore(tty.fd, tty.saved); err != nil {\n\t\ttty.l.Unlock()\n\t\treturn err\n\t}\n\t_ = tty.in.SetReadDeadline(time.Now())\n\n\tsignal.Stop(tty.sig)\n\tclose(tty.stopQ)\n\ttty.l.Unlock()\n\n\ttty.wg.Wait()\n\n\treturn nil\n}\n\nfunc (tty *stdIoTty) WindowSize() (WindowSize, error) {\n\tsize := WindowSize{}\n\tws, err := unix.IoctlGetWinsize(tty.fd, unix.TIOCGWINSZ)\n\tif err != nil {\n\t\treturn size, err\n\t}\n\tw := int(ws.Col)\n\th := int(ws.Row)\n\tif w == 0 {\n\t\tw, _ = strconv.Atoi(os.Getenv(\"COLUMNS\"))\n\t}\n\tif w == 0 {\n\t\tw = 80 // default\n\t}\n\tif h == 0 {\n\t\th, _ = strconv.Atoi(os.Getenv(\"LINES\"))\n\t}\n\tif h == 0 {\n\t\th = 25 // default\n\t}\n\tsize.Width = w\n\tsize.Height = h\n\tsize.PixelWidth = int(ws.Xpixel)\n\tsize.PixelHeight = int(ws.Ypixel)\n\treturn size, nil\n}\n\nfunc (tty *stdIoTty) NotifyResize(cb func()) {\n\ttty.l.Lock()\n\ttty.cb = cb\n\ttty.l.Unlock()\n}\n\n// NewStdioTty opens a tty using standard input/output.\nfunc NewStdIoTty() (Tty, error) {\n\ttty := &stdIoTty{\n\t\tsig: make(chan os.Signal),\n\t\tin:  os.Stdin,\n\t\tout: os.Stdout,\n\t}\n\tvar err error\n\ttty.fd = int(tty.in.Fd())\n\tif !term.IsTerminal(tty.fd) {\n\t\treturn nil, errors.New(\"not a terminal\")\n\t}\n\tif tty.saved, err = term.GetState(tty.fd); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get state: %w\", err)\n\t}\n\treturn tty, nil\n}\n"
        },
        {
          "name": "style.go",
          "type": "blob",
          "size": 5.337890625,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\n// Style represents a complete text style, including both foreground color,\n// background color, and additional attributes such as \"bold\" or \"underline\".\n//\n// Note that not all terminals can display all colors or attributes, and\n// many might have specific incompatibilities between specific attributes\n// and color combinations.\n//\n// To use Style, just declare a variable of its type.\ntype Style struct {\n\tfg      Color\n\tbg      Color\n\tulStyle UnderlineStyle\n\tulColor Color\n\tattrs   AttrMask\n\turl     string\n\turlId   string\n}\n\n// StyleDefault represents a default style, based upon the context.\n// It is the zero value.\nvar StyleDefault Style\n\n// styleInvalid is just an arbitrary invalid style used internally.\nvar styleInvalid = Style{attrs: AttrInvalid}\n\n// Foreground returns a new style based on s, with the foreground color set\n// as requested.  ColorDefault can be used to select the global default.\nfunc (s Style) Foreground(c Color) Style {\n\ts2 := s\n\ts2.fg = c\n\treturn s2\n}\n\n// Background returns a new style based on s, with the background color set\n// as requested.  ColorDefault can be used to select the global default.\nfunc (s Style) Background(c Color) Style {\n\ts2 := s\n\ts2.bg = c\n\treturn s2\n}\n\n// Decompose breaks a style up, returning the foreground, background,\n// and other attributes.  The URL if set is not included.\n// Deprecated: Applications should not attempt to decompose style,\n// as this content is not sufficient to describe the actual style.\nfunc (s Style) Decompose() (fg Color, bg Color, attr AttrMask) {\n\treturn s.fg, s.bg, s.attrs\n}\n\nfunc (s Style) setAttrs(attrs AttrMask, on bool) Style {\n\ts2 := s\n\tif on {\n\t\ts2.attrs |= attrs\n\t} else {\n\t\ts2.attrs &^= attrs\n\t}\n\treturn s2\n}\n\n// Normal returns the style with all attributes disabled.\nfunc (s Style) Normal() Style {\n\treturn Style{\n\t\tfg: s.fg,\n\t\tbg: s.bg,\n\t}\n}\n\n// Bold returns a new style based on s, with the bold attribute set\n// as requested.\nfunc (s Style) Bold(on bool) Style {\n\treturn s.setAttrs(AttrBold, on)\n}\n\n// Blink returns a new style based on s, with the blink attribute set\n// as requested.\nfunc (s Style) Blink(on bool) Style {\n\treturn s.setAttrs(AttrBlink, on)\n}\n\n// Dim returns a new style based on s, with the dim attribute set\n// as requested.\nfunc (s Style) Dim(on bool) Style {\n\treturn s.setAttrs(AttrDim, on)\n}\n\n// Italic returns a new style based on s, with the italic attribute set\n// as requested.\nfunc (s Style) Italic(on bool) Style {\n\treturn s.setAttrs(AttrItalic, on)\n}\n\n// Reverse returns a new style based on s, with the reverse attribute set\n// as requested.  (Reverse usually changes the foreground and background\n// colors.)\nfunc (s Style) Reverse(on bool) Style {\n\treturn s.setAttrs(AttrReverse, on)\n}\n\n// StrikeThrough sets strikethrough mode.\nfunc (s Style) StrikeThrough(on bool) Style {\n\treturn s.setAttrs(AttrStrikeThrough, on)\n}\n\n// Underline style.  Modern terminals have the option of rendering the\n// underline using different styles, and even different colors.\ntype UnderlineStyle int\n\nconst (\n\tUnderlineStyleNone = UnderlineStyle(iota)\n\tUnderlineStyleSolid\n\tUnderlineStyleDouble\n\tUnderlineStyleCurly\n\tUnderlineStyleDotted\n\tUnderlineStyleDashed\n)\n\n// Underline returns a new style based on s, with the underline attribute set\n// as requested.  The parameters can be:\n//\n// bool: on / off - enables just a simple underline\n// UnderlineStyle: sets a specific style (should not coexist with the bool)\n// Color: the color to use\nfunc (s Style) Underline(params ...interface{}) Style {\n\ts2 := s\n\tfor _, param := range params {\n\t\tswitch v := param.(type) {\n\t\tcase bool:\n\t\t\tif v {\n\t\t\t\ts2.ulStyle = UnderlineStyleSolid\n\t\t\t\ts2.attrs |= AttrUnderline\n\t\t\t} else {\n\t\t\t\ts2.ulStyle = UnderlineStyleNone\n\t\t\t\ts2.attrs &^= AttrUnderline\n\t\t\t}\n\t\tcase UnderlineStyle:\n\t\t\tif v == UnderlineStyleNone {\n\t\t\t\ts2.attrs &^= AttrUnderline\n\t\t\t} else {\n\t\t\t\ts2.attrs |= AttrUnderline\n\t\t\t}\n\t\t\ts2.ulStyle = v\n\t\tcase Color:\n\t\t\ts2.ulColor = v\n\t\tdefault:\n\t\t\tpanic(\"Bad type for underline\")\n\t\t}\n\t}\n\treturn s2\n}\n\n// Attributes returns a new style based on s, with its attributes set as\n// specified.\nfunc (s Style) Attributes(attrs AttrMask) Style {\n\ts2 := s\n\ts2.attrs = attrs\n\treturn s2\n}\n\n// Url returns a style with the Url set.  If the provided Url is not empty,\n// and the terminal supports it, text will typically be marked up as a clickable\n// link to that Url.  If the Url is empty, then this mode is turned off.\nfunc (s Style) Url(url string) Style {\n\ts2 := s\n\ts2.url = url\n\treturn s2\n}\n\n// UrlId returns a style with the UrlId set. If the provided UrlId is not empty,\n// any marked up Url with this style will be given the UrlId also. If the\n// terminal supports it, any text with the same UrlId will be grouped as if it\n// were one Url, even if it spans multiple lines.\nfunc (s Style) UrlId(id string) Style {\n\ts2 := s\n\ts2.urlId = \"id=\" + id\n\treturn s2\n}\n"
        },
        {
          "name": "style_test.go",
          "type": "blob",
          "size": 1.1181640625,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"testing\"\n)\n\nfunc TestStyle(t *testing.T) {\n\ts := mkTestScreen(t, \"\")\n\tdefer s.Fini()\n\n\tstyle := StyleDefault\n\tfg, bg, attr := style.fg, style.bg, style.attrs\n\n\tif fg != ColorDefault || bg != ColorDefault || attr != AttrNone {\n\t\tt.Errorf(\"Bad default style (%v, %v, %v)\", fg, bg, attr)\n\t}\n\n\ts2 := style.\n\t\tBackground(ColorRed).\n\t\tForeground(ColorBlue).\n\t\tBlink(true)\n\n\tfg, bg, attr = s2.fg, s2.bg, s2.attrs\n\tif fg != ColorBlue || bg != ColorRed || attr != AttrBlink {\n\t\tt.Errorf(\"Bad custom style (%v, %v, %v)\", fg, bg, attr)\n\t}\n}\n"
        },
        {
          "name": "termbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "terminfo",
          "type": "tree",
          "content": null
        },
        {
          "name": "terms_default.go",
          "type": "blob",
          "size": 0.7958984375,
          "content": "//go:build !tcell_minimal\n// +build !tcell_minimal\n\n// Copyright 2019 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t// This imports the default terminal entries.  To disable, use the\n\t// tcell_minimal build tag.\n\t_ \"github.com/gdamore/tcell/v2/terminfo/extended\"\n)\n"
        },
        {
          "name": "terms_dynamic.go",
          "type": "blob",
          "size": 1.513671875,
          "content": "//go:build !tcell_minimal && !nacl && !js && !zos && !plan9 && !windows && !android\n// +build !tcell_minimal,!nacl,!js,!zos,!plan9,!windows,!android\n\n// Copyright 2019 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t// This imports a dynamic version of the terminal database, which\n\t// is built using infocmp.  This relies on a working installation\n\t// of infocmp (typically supplied with ncurses).  We only do this\n\t// for systems likely to have that -- i.e. UNIX based hosts.  We\n\t// also don't support Android here, because you really don't want\n\t// to run external programs there.  Generally the android terminals\n\t// will be automatically included anyway.\n\t\"github.com/gdamore/tcell/v2/terminfo\"\n\t\"github.com/gdamore/tcell/v2/terminfo/dynamic\"\n\n\t\"fmt\"\n)\n\nfunc loadDynamicTerminfo(term string) (*terminfo.Terminfo, error) {\n\tif term == \"\" {\n\t\treturn nil, fmt.Errorf(\"%w: term not set\", ErrTermNotFound)\n\t}\n\tti, _, e := dynamic.LoadTerminfo(term)\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\treturn ti, nil\n}\n"
        },
        {
          "name": "terms_static.go",
          "type": "blob",
          "size": 0.9013671875,
          "content": "//go:build tcell_minimal || nacl || zos || plan9 || windows || android || js\n// +build tcell_minimal nacl zos plan9 windows android js\n\n// Copyright 2019 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport (\n\t\"errors\"\n\n\t\"github.com/gdamore/tcell/v2/terminfo\"\n)\n\nfunc loadDynamicTerminfo(_ string) (*terminfo.Terminfo, error) {\n\treturn nil, errors.New(\"terminal type unsupported\")\n}\n"
        },
        {
          "name": "tscreen.go",
          "type": "blob",
          "size": 51.3896484375,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build !(js && wasm)\n// +build !js !wasm\n\npackage tcell\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"golang.org/x/term\"\n\t\"golang.org/x/text/transform\"\n\n\t\"github.com/gdamore/tcell/v2/terminfo\"\n)\n\n// NewTerminfoScreen returns a Screen that uses the stock TTY interface\n// and POSIX terminal control, combined with a terminfo description taken from\n// the $TERM environment variable.  It returns an error if the terminal\n// is not supported for any reason.\n//\n// For terminals that do not support dynamic resize events, the $LINES\n// $COLUMNS environment variables can be set to the actual window size,\n// otherwise defaults taken from the terminal database are used.\nfunc NewTerminfoScreen() (Screen, error) {\n\treturn NewTerminfoScreenFromTty(nil)\n}\n\n// LookupTerminfo attempts to find a definition for the named $TERM falling\n// back to attempting to parse the output from infocmp.\nfunc LookupTerminfo(name string) (ti *terminfo.Terminfo, e error) {\n\tti, e = terminfo.LookupTerminfo(name)\n\tif e != nil {\n\t\tti, e = loadDynamicTerminfo(name)\n\t\tif e != nil {\n\t\t\treturn nil, e\n\t\t}\n\t\tterminfo.AddTerminfo(ti)\n\t}\n\n\treturn\n}\n\n// NewTerminfoScreenFromTtyTerminfo returns a Screen using a custom Tty\n// implementation  and custom terminfo specification.\n// If the passed in tty is nil, then a reasonable default (typically /dev/tty)\n// is presumed, at least on UNIX hosts. (Windows hosts will typically fail this\n// call altogether.)\n// If passed terminfo is nil, then TERM environment variable is queried for\n// terminal specification.\nfunc NewTerminfoScreenFromTtyTerminfo(tty Tty, ti *terminfo.Terminfo) (s Screen, e error) {\n\tif ti == nil {\n\t\tti, e = LookupTerminfo(os.Getenv(\"TERM\"))\n\t\tif e != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tt := &tScreen{ti: ti, tty: tty}\n\n\tt.keyexist = make(map[Key]bool)\n\tt.keycodes = make(map[string]*tKeyCode)\n\tif len(ti.Mouse) > 0 {\n\t\tt.mouse = []byte(ti.Mouse)\n\t}\n\tt.prepareKeys()\n\tt.buildAcsMap()\n\tt.resizeQ = make(chan bool, 1)\n\tt.fallback = make(map[rune]string)\n\tfor k, v := range RuneFallbacks {\n\t\tt.fallback[k] = v\n\t}\n\n\treturn &baseScreen{screenImpl: t}, nil\n}\n\n// NewTerminfoScreenFromTty returns a Screen using a custom Tty implementation.\n// If the passed in tty is nil, then a reasonable default (typically /dev/tty)\n// is presumed, at least on UNIX hosts. (Windows hosts will typically fail this\n// call altogether.)\nfunc NewTerminfoScreenFromTty(tty Tty) (Screen, error) {\n\treturn NewTerminfoScreenFromTtyTerminfo(tty, nil)\n}\n\n// tKeyCode represents a combination of a key code and modifiers.\ntype tKeyCode struct {\n\tkey Key\n\tmod ModMask\n}\n\n// tScreen represents a screen backed by a terminfo implementation.\ntype tScreen struct {\n\tti           *terminfo.Terminfo\n\ttty          Tty\n\th            int\n\tw            int\n\tfini         bool\n\tcells        CellBuffer\n\tbuffering    bool // true if we are collecting writes to buf instead of sending directly to out\n\tbuf          bytes.Buffer\n\tcurstyle     Style\n\tstyle        Style\n\tresizeQ      chan bool\n\tquit         chan struct{}\n\tkeyexist     map[Key]bool\n\tkeycodes     map[string]*tKeyCode\n\tkeychan      chan []byte\n\tkeytimer     *time.Timer\n\tkeyexpire    time.Time\n\tcx           int\n\tcy           int\n\tmouse        []byte\n\tclear        bool\n\tcursorx      int\n\tcursory      int\n\tacs          map[rune]string\n\tcharset      string\n\tencoder      transform.Transformer\n\tdecoder      transform.Transformer\n\tfallback     map[rune]string\n\tcolors       map[Color]Color\n\tpalette      []Color\n\ttruecolor    bool\n\tescaped      bool\n\tbuttondn     bool\n\tfiniOnce     sync.Once\n\tenablePaste  string\n\tdisablePaste string\n\tenterUrl     string\n\texitUrl      string\n\tsetWinSize   string\n\tenableFocus  string\n\tdisableFocus string\n\tdoubleUnder  string\n\tcurlyUnder   string\n\tdottedUnder  string\n\tdashedUnder  string\n\tunderColor   string\n\tunderRGB     string\n\tunderFg      string\n\tcursorStyles map[CursorStyle]string\n\tcursorStyle  CursorStyle\n\tcursorColor  Color\n\tcursorRGB    string\n\tcursorFg     string\n\tsaved        *term.State\n\tstopQ        chan struct{}\n\teventQ       chan Event\n\trunning      bool\n\twg           sync.WaitGroup\n\tmouseFlags   MouseFlags\n\tpasteEnabled bool\n\tfocusEnabled bool\n\tsetTitle     string\n\tsaveTitle    string\n\trestoreTitle string\n\ttitle        string\n\tsetClipboard string\n\n\tsync.Mutex\n}\n\nfunc (t *tScreen) Init() error {\n\tif e := t.initialize(); e != nil {\n\t\treturn e\n\t}\n\n\tt.keychan = make(chan []byte, 10)\n\tt.keytimer = time.NewTimer(time.Millisecond * 50)\n\tt.charset = \"UTF-8\"\n\n\tt.charset = getCharset()\n\tif enc := GetEncoding(t.charset); enc != nil {\n\t\tt.encoder = enc.NewEncoder()\n\t\tt.decoder = enc.NewDecoder()\n\t} else {\n\t\treturn ErrNoCharset\n\t}\n\tti := t.ti\n\n\t// environment overrides\n\tw := ti.Columns\n\th := ti.Lines\n\tif i, _ := strconv.Atoi(os.Getenv(\"LINES\")); i != 0 {\n\t\th = i\n\t}\n\tif i, _ := strconv.Atoi(os.Getenv(\"COLUMNS\")); i != 0 {\n\t\tw = i\n\t}\n\tif t.ti.SetFgBgRGB != \"\" || t.ti.SetFgRGB != \"\" || t.ti.SetBgRGB != \"\" {\n\t\tt.truecolor = true\n\t}\n\t// A user who wants to have his themes honored can\n\t// set this environment variable.\n\tif os.Getenv(\"TCELL_TRUECOLOR\") == \"disable\" {\n\t\tt.truecolor = false\n\t}\n\tnColors := t.nColors()\n\tif nColors > 256 {\n\t\tnColors = 256 // clip to reasonable limits\n\t}\n\tt.colors = make(map[Color]Color, nColors)\n\tt.palette = make([]Color, nColors)\n\tfor i := 0; i < nColors; i++ {\n\t\tt.palette[i] = Color(i) | ColorValid\n\t\t// identity map for our builtin colors\n\t\tt.colors[Color(i)|ColorValid] = Color(i) | ColorValid\n\t}\n\n\tt.quit = make(chan struct{})\n\tt.eventQ = make(chan Event, 10)\n\n\tt.Lock()\n\tt.cx = -1\n\tt.cy = -1\n\tt.style = StyleDefault\n\tt.cells.Resize(w, h)\n\tt.cursorx = -1\n\tt.cursory = -1\n\tt.resize()\n\tt.Unlock()\n\n\tif err := t.engage(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (t *tScreen) prepareKeyMod(key Key, mod ModMask, val string) {\n\tif val != \"\" {\n\t\t// Do not override codes that already exist\n\t\tif _, exist := t.keycodes[val]; !exist {\n\t\t\tt.keyexist[key] = true\n\t\t\tt.keycodes[val] = &tKeyCode{key: key, mod: mod}\n\t\t}\n\t}\n}\n\nfunc (t *tScreen) prepareKeyModReplace(key Key, replace Key, mod ModMask, val string) {\n\tif val != \"\" {\n\t\t// Do not override codes that already exist\n\t\tif old, exist := t.keycodes[val]; !exist || old.key == replace {\n\t\t\tt.keyexist[key] = true\n\t\t\tt.keycodes[val] = &tKeyCode{key: key, mod: mod}\n\t\t}\n\t}\n}\n\nfunc (t *tScreen) prepareKeyModXTerm(key Key, val string) {\n\n\tif strings.HasPrefix(val, \"\\x1b[\") && strings.HasSuffix(val, \"~\") {\n\n\t\t// Drop the trailing ~\n\t\tval = val[:len(val)-1]\n\n\t\t// These suffixes are calculated assuming Xterm style modifier suffixes.\n\t\t// Please see https://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf for\n\t\t// more information (specifically \"PC-Style Function Keys\").\n\t\tt.prepareKeyModReplace(key, key+12, ModShift, val+\";2~\")\n\t\tt.prepareKeyModReplace(key, key+48, ModAlt, val+\";3~\")\n\t\tt.prepareKeyModReplace(key, key+60, ModAlt|ModShift, val+\";4~\")\n\t\tt.prepareKeyModReplace(key, key+24, ModCtrl, val+\";5~\")\n\t\tt.prepareKeyModReplace(key, key+36, ModCtrl|ModShift, val+\";6~\")\n\t\tt.prepareKeyMod(key, ModAlt|ModCtrl, val+\";7~\")\n\t\tt.prepareKeyMod(key, ModShift|ModAlt|ModCtrl, val+\";8~\")\n\t\tt.prepareKeyMod(key, ModMeta, val+\";9~\")\n\t\tt.prepareKeyMod(key, ModMeta|ModShift, val+\";10~\")\n\t\tt.prepareKeyMod(key, ModMeta|ModAlt, val+\";11~\")\n\t\tt.prepareKeyMod(key, ModMeta|ModAlt|ModShift, val+\";12~\")\n\t\tt.prepareKeyMod(key, ModMeta|ModCtrl, val+\";13~\")\n\t\tt.prepareKeyMod(key, ModMeta|ModCtrl|ModShift, val+\";14~\")\n\t\tt.prepareKeyMod(key, ModMeta|ModCtrl|ModAlt, val+\";15~\")\n\t\tt.prepareKeyMod(key, ModMeta|ModCtrl|ModAlt|ModShift, val+\";16~\")\n\t} else if strings.HasPrefix(val, \"\\x1bO\") && len(val) == 3 {\n\t\tval = val[2:]\n\t\tt.prepareKeyModReplace(key, key+12, ModShift, \"\\x1b[1;2\"+val)\n\t\tt.prepareKeyModReplace(key, key+48, ModAlt, \"\\x1b[1;3\"+val)\n\t\tt.prepareKeyModReplace(key, key+24, ModCtrl, \"\\x1b[1;5\"+val)\n\t\tt.prepareKeyModReplace(key, key+36, ModCtrl|ModShift, \"\\x1b[1;6\"+val)\n\t\tt.prepareKeyModReplace(key, key+60, ModAlt|ModShift, \"\\x1b[1;4\"+val)\n\t\tt.prepareKeyMod(key, ModAlt|ModCtrl, \"\\x1b[1;7\"+val)\n\t\tt.prepareKeyMod(key, ModShift|ModAlt|ModCtrl, \"\\x1b[1;8\"+val)\n\t\tt.prepareKeyMod(key, ModMeta, \"\\x1b[1;9\"+val)\n\t\tt.prepareKeyMod(key, ModMeta|ModShift, \"\\x1b[1;10\"+val)\n\t\tt.prepareKeyMod(key, ModMeta|ModAlt, \"\\x1b[1;11\"+val)\n\t\tt.prepareKeyMod(key, ModMeta|ModAlt|ModShift, \"\\x1b[1;12\"+val)\n\t\tt.prepareKeyMod(key, ModMeta|ModCtrl, \"\\x1b[1;13\"+val)\n\t\tt.prepareKeyMod(key, ModMeta|ModCtrl|ModShift, \"\\x1b[1;14\"+val)\n\t\tt.prepareKeyMod(key, ModMeta|ModCtrl|ModAlt, \"\\x1b[1;15\"+val)\n\t\tt.prepareKeyMod(key, ModMeta|ModCtrl|ModAlt|ModShift, \"\\x1b[1;16\"+val)\n\t}\n}\n\nfunc (t *tScreen) prepareXtermModifiers() {\n\tif t.ti.Modifiers != terminfo.ModifiersXTerm {\n\t\treturn\n\t}\n\tt.prepareKeyModXTerm(KeyRight, t.ti.KeyRight)\n\tt.prepareKeyModXTerm(KeyLeft, t.ti.KeyLeft)\n\tt.prepareKeyModXTerm(KeyUp, t.ti.KeyUp)\n\tt.prepareKeyModXTerm(KeyDown, t.ti.KeyDown)\n\tt.prepareKeyModXTerm(KeyInsert, t.ti.KeyInsert)\n\tt.prepareKeyModXTerm(KeyDelete, t.ti.KeyDelete)\n\tt.prepareKeyModXTerm(KeyPgUp, t.ti.KeyPgUp)\n\tt.prepareKeyModXTerm(KeyPgDn, t.ti.KeyPgDn)\n\tt.prepareKeyModXTerm(KeyHome, t.ti.KeyHome)\n\tt.prepareKeyModXTerm(KeyEnd, t.ti.KeyEnd)\n\tt.prepareKeyModXTerm(KeyF1, t.ti.KeyF1)\n\tt.prepareKeyModXTerm(KeyF2, t.ti.KeyF2)\n\tt.prepareKeyModXTerm(KeyF3, t.ti.KeyF3)\n\tt.prepareKeyModXTerm(KeyF4, t.ti.KeyF4)\n\tt.prepareKeyModXTerm(KeyF5, t.ti.KeyF5)\n\tt.prepareKeyModXTerm(KeyF6, t.ti.KeyF6)\n\tt.prepareKeyModXTerm(KeyF7, t.ti.KeyF7)\n\tt.prepareKeyModXTerm(KeyF8, t.ti.KeyF8)\n\tt.prepareKeyModXTerm(KeyF9, t.ti.KeyF9)\n\tt.prepareKeyModXTerm(KeyF10, t.ti.KeyF10)\n\tt.prepareKeyModXTerm(KeyF11, t.ti.KeyF11)\n\tt.prepareKeyModXTerm(KeyF12, t.ti.KeyF12)\n}\n\nfunc (t *tScreen) prepareBracketedPaste() {\n\t// Another workaround for lack of reporting in terminfo.\n\t// We assume if the terminal has a mouse entry, that it\n\t// offers bracketed paste.  But we allow specific overrides\n\t// via our terminal database.\n\tif t.ti.EnablePaste != \"\" {\n\t\tt.enablePaste = t.ti.EnablePaste\n\t\tt.disablePaste = t.ti.DisablePaste\n\t\tt.prepareKey(keyPasteStart, t.ti.PasteStart)\n\t\tt.prepareKey(keyPasteEnd, t.ti.PasteEnd)\n\t} else if t.ti.Mouse != \"\" || t.ti.XTermLike {\n\t\tt.enablePaste = \"\\x1b[?2004h\"\n\t\tt.disablePaste = \"\\x1b[?2004l\"\n\t\tt.prepareKey(keyPasteStart, \"\\x1b[200~\")\n\t\tt.prepareKey(keyPasteEnd, \"\\x1b[201~\")\n\t}\n}\n\nfunc (t *tScreen) prepareUnderlines() {\n\tif t.ti.DoubleUnderline != \"\" {\n\t\tt.doubleUnder = t.ti.DoubleUnderline\n\t} else if t.ti.XTermLike {\n\t\tt.doubleUnder = \"\\x1b[4:2m\"\n\t}\n\tif t.ti.CurlyUnderline != \"\" {\n\t\tt.curlyUnder = t.ti.CurlyUnderline\n\t} else if t.ti.XTermLike {\n\t\tt.curlyUnder = \"\\x1b[4:3m\"\n\t}\n\tif t.ti.DottedUnderline != \"\" {\n\t\tt.dottedUnder = t.ti.DottedUnderline\n\t} else if t.ti.XTermLike {\n\t\tt.dottedUnder = \"\\x1b[4:4m\"\n\t}\n\tif t.ti.DashedUnderline != \"\" {\n\t\tt.dashedUnder = t.ti.DashedUnderline\n\t} else if t.ti.XTermLike {\n\t\tt.dashedUnder = \"\\x1b[4:5m\"\n\t}\n\n\t// Underline colors.  We're not going to rely upon terminfo for this\n\t// Essentially all terminals that support the curly underlines are\n\t// expected to also support coloring them too - which reflects actual\n\t// practice since these were introduced at about the same time.\n\tif t.ti.UnderlineColor != \"\" {\n\t\tt.underColor = t.ti.UnderlineColor\n\t} else if t.ti.CurlyUnderline != \"\" {\n\t\tt.underColor = \"\\x1b[58:5:%p1%dm\"\n\t}\n\tif t.ti.UnderlineColorRGB != \"\" {\n\t\t// An interesting wart here is that in order to facilitate\n\t\t// using just a single parameter, the Setulc parameter takes\n\t\t// the 24-bit color as an integer rather than separate bytes.\n\t\t// This matches the \"new\" style direct color approach that\n\t\t// ncurses took, even though everyone else when another way.\n\t\tt.underRGB = t.ti.UnderlineColorRGB\n\t} else if t.ti.CurlyUnderline != \"\" {\n\t\tt.underRGB = \"\\x1b[58:2::%p1%d:%p2%d:%p3%dm\"\n\t}\n\tif t.ti.UnderlineColorReset != \"\" {\n\t\tt.underFg = t.ti.UnderlineColorReset\n\t} else if t.ti.CurlyUnderline != \"\" {\n\t\tt.underFg = \"\\x1b[59m\"\n\t}\n}\n\nfunc (t *tScreen) prepareExtendedOSC() {\n\t// Linux is a special beast - because it has a mouse entry, but does\n\t// not swallow these OSC commands properly.\n\tif strings.Contains(t.ti.Name, \"linux\") {\n\t\treturn\n\t}\n\t// More stuff for limits in terminfo.  This time we are applying\n\t// the most common OSC (operating system commands).  Generally\n\t// terminals that don't understand these will ignore them.\n\t// Again, we condition this based on mouse capabilities.\n\tif t.ti.EnterUrl != \"\" {\n\t\tt.enterUrl = t.ti.EnterUrl\n\t\tt.exitUrl = t.ti.ExitUrl\n\t} else if t.ti.Mouse != \"\" || t.ti.XTermLike {\n\t\tt.enterUrl = \"\\x1b]8;%p2%s;%p1%s\\x1b\\\\\"\n\t\tt.exitUrl = \"\\x1b]8;;\\x1b\\\\\"\n\t}\n\n\tif t.ti.SetWindowSize != \"\" {\n\t\tt.setWinSize = t.ti.SetWindowSize\n\t} else if t.ti.Mouse != \"\" || t.ti.XTermLike {\n\t\tt.setWinSize = \"\\x1b[8;%p1%p2%d;%dt\"\n\t}\n\n\tif t.ti.EnableFocusReporting != \"\" {\n\t\tt.enableFocus = t.ti.EnableFocusReporting\n\t} else if t.ti.Mouse != \"\" || t.ti.XTermLike {\n\t\tt.enableFocus = \"\\x1b[?1004h\"\n\t}\n\tif t.ti.DisableFocusReporting != \"\" {\n\t\tt.disableFocus = t.ti.DisableFocusReporting\n\t} else if t.ti.Mouse != \"\" || t.ti.XTermLike {\n\t\tt.disableFocus = \"\\x1b[?1004l\"\n\t}\n\n\tif t.ti.SetWindowTitle != \"\" {\n\t\tt.setTitle = t.ti.SetWindowTitle\n\t} else if t.ti.XTermLike {\n\t\tt.saveTitle = \"\\x1b[22;2t\"\n\t\tt.restoreTitle = \"\\x1b[23;2t\"\n\t\t// this also tries to request that UTF-8 is allowed in the title\n\t\tt.setTitle = \"\\x1b[>2t\\x1b]2;%p1%s\\x1b\\\\\"\n\t}\n\n\tif t.setClipboard == \"\" && t.ti.XTermLike {\n\t\t// this string takes a base64 string and sends it to the clipboard.\n\t\t// it will also be able to retrieve the clipboard using \"?\" as the\n\t\t// sent string, when we support that.\n\t\tt.setClipboard = \"\\x1b]52;c;%p1%s\\x1b\\\\\"\n\t}\n}\n\nfunc (t *tScreen) prepareCursorStyles() {\n\t// Another workaround for lack of reporting in terminfo.\n\t// We assume if the terminal has a mouse entry, that it\n\t// offers bracketed paste.  But we allow specific overrides\n\t// via our terminal database.\n\tif t.ti.CursorDefault != \"\" {\n\t\tt.cursorStyles = map[CursorStyle]string{\n\t\t\tCursorStyleDefault:           t.ti.CursorDefault,\n\t\t\tCursorStyleBlinkingBlock:     t.ti.CursorBlinkingBlock,\n\t\t\tCursorStyleSteadyBlock:       t.ti.CursorSteadyBlock,\n\t\t\tCursorStyleBlinkingUnderline: t.ti.CursorBlinkingUnderline,\n\t\t\tCursorStyleSteadyUnderline:   t.ti.CursorSteadyUnderline,\n\t\t\tCursorStyleBlinkingBar:       t.ti.CursorBlinkingBar,\n\t\t\tCursorStyleSteadyBar:         t.ti.CursorSteadyBar,\n\t\t}\n\t} else if t.ti.Mouse != \"\" || t.ti.XTermLike {\n\t\tt.cursorStyles = map[CursorStyle]string{\n\t\t\tCursorStyleDefault:           \"\\x1b[0 q\",\n\t\t\tCursorStyleBlinkingBlock:     \"\\x1b[1 q\",\n\t\t\tCursorStyleSteadyBlock:       \"\\x1b[2 q\",\n\t\t\tCursorStyleBlinkingUnderline: \"\\x1b[3 q\",\n\t\t\tCursorStyleSteadyUnderline:   \"\\x1b[4 q\",\n\t\t\tCursorStyleBlinkingBar:       \"\\x1b[5 q\",\n\t\t\tCursorStyleSteadyBar:         \"\\x1b[6 q\",\n\t\t}\n\t}\n\tif t.ti.CursorColorRGB != \"\" {\n\t\t// if it was X11 style with just a single %p1%s, then convert\n\t\tt.cursorRGB = t.ti.CursorColorRGB\n\t}\n\tif t.ti.CursorColorReset != \"\" {\n\t\tt.cursorFg = t.ti.CursorColorReset\n\t}\n\tif t.cursorRGB == \"\" {\n\t\tt.cursorRGB = \"\\x1b]12;%p1%s\\007\"\n\t\tt.cursorFg = \"\\x1b]112\\007\"\n\t}\n\n\t// convert XTERM style color names to RGB color code.  We have no way to do palette colors\n\tt.cursorRGB = strings.Replace(t.cursorRGB, \"%p1%s\", \"#%p1%02x%p2%02x%p3%02x\", 1)\n}\n\nfunc (t *tScreen) prepareKey(key Key, val string) {\n\tt.prepareKeyMod(key, ModNone, val)\n}\n\nfunc (t *tScreen) prepareKeys() {\n\tti := t.ti\n\tif strings.HasPrefix(ti.Name, \"xterm\") {\n\t\t// assume its some form of XTerm clone\n\t\tt.ti.XTermLike = true\n\t\tti.XTermLike = true\n\t}\n\tt.prepareKey(KeyBackspace, ti.KeyBackspace)\n\tt.prepareKey(KeyF1, ti.KeyF1)\n\tt.prepareKey(KeyF2, ti.KeyF2)\n\tt.prepareKey(KeyF3, ti.KeyF3)\n\tt.prepareKey(KeyF4, ti.KeyF4)\n\tt.prepareKey(KeyF5, ti.KeyF5)\n\tt.prepareKey(KeyF6, ti.KeyF6)\n\tt.prepareKey(KeyF7, ti.KeyF7)\n\tt.prepareKey(KeyF8, ti.KeyF8)\n\tt.prepareKey(KeyF9, ti.KeyF9)\n\tt.prepareKey(KeyF10, ti.KeyF10)\n\tt.prepareKey(KeyF11, ti.KeyF11)\n\tt.prepareKey(KeyF12, ti.KeyF12)\n\tt.prepareKey(KeyF13, ti.KeyF13)\n\tt.prepareKey(KeyF14, ti.KeyF14)\n\tt.prepareKey(KeyF15, ti.KeyF15)\n\tt.prepareKey(KeyF16, ti.KeyF16)\n\tt.prepareKey(KeyF17, ti.KeyF17)\n\tt.prepareKey(KeyF18, ti.KeyF18)\n\tt.prepareKey(KeyF19, ti.KeyF19)\n\tt.prepareKey(KeyF20, ti.KeyF20)\n\tt.prepareKey(KeyF21, ti.KeyF21)\n\tt.prepareKey(KeyF22, ti.KeyF22)\n\tt.prepareKey(KeyF23, ti.KeyF23)\n\tt.prepareKey(KeyF24, ti.KeyF24)\n\tt.prepareKey(KeyF25, ti.KeyF25)\n\tt.prepareKey(KeyF26, ti.KeyF26)\n\tt.prepareKey(KeyF27, ti.KeyF27)\n\tt.prepareKey(KeyF28, ti.KeyF28)\n\tt.prepareKey(KeyF29, ti.KeyF29)\n\tt.prepareKey(KeyF30, ti.KeyF30)\n\tt.prepareKey(KeyF31, ti.KeyF31)\n\tt.prepareKey(KeyF32, ti.KeyF32)\n\tt.prepareKey(KeyF33, ti.KeyF33)\n\tt.prepareKey(KeyF34, ti.KeyF34)\n\tt.prepareKey(KeyF35, ti.KeyF35)\n\tt.prepareKey(KeyF36, ti.KeyF36)\n\tt.prepareKey(KeyF37, ti.KeyF37)\n\tt.prepareKey(KeyF38, ti.KeyF38)\n\tt.prepareKey(KeyF39, ti.KeyF39)\n\tt.prepareKey(KeyF40, ti.KeyF40)\n\tt.prepareKey(KeyF41, ti.KeyF41)\n\tt.prepareKey(KeyF42, ti.KeyF42)\n\tt.prepareKey(KeyF43, ti.KeyF43)\n\tt.prepareKey(KeyF44, ti.KeyF44)\n\tt.prepareKey(KeyF45, ti.KeyF45)\n\tt.prepareKey(KeyF46, ti.KeyF46)\n\tt.prepareKey(KeyF47, ti.KeyF47)\n\tt.prepareKey(KeyF48, ti.KeyF48)\n\tt.prepareKey(KeyF49, ti.KeyF49)\n\tt.prepareKey(KeyF50, ti.KeyF50)\n\tt.prepareKey(KeyF51, ti.KeyF51)\n\tt.prepareKey(KeyF52, ti.KeyF52)\n\tt.prepareKey(KeyF53, ti.KeyF53)\n\tt.prepareKey(KeyF54, ti.KeyF54)\n\tt.prepareKey(KeyF55, ti.KeyF55)\n\tt.prepareKey(KeyF56, ti.KeyF56)\n\tt.prepareKey(KeyF57, ti.KeyF57)\n\tt.prepareKey(KeyF58, ti.KeyF58)\n\tt.prepareKey(KeyF59, ti.KeyF59)\n\tt.prepareKey(KeyF60, ti.KeyF60)\n\tt.prepareKey(KeyF61, ti.KeyF61)\n\tt.prepareKey(KeyF62, ti.KeyF62)\n\tt.prepareKey(KeyF63, ti.KeyF63)\n\tt.prepareKey(KeyF64, ti.KeyF64)\n\tt.prepareKey(KeyInsert, ti.KeyInsert)\n\tt.prepareKey(KeyDelete, ti.KeyDelete)\n\tt.prepareKey(KeyHome, ti.KeyHome)\n\tt.prepareKey(KeyEnd, ti.KeyEnd)\n\tt.prepareKey(KeyUp, ti.KeyUp)\n\tt.prepareKey(KeyDown, ti.KeyDown)\n\tt.prepareKey(KeyLeft, ti.KeyLeft)\n\tt.prepareKey(KeyRight, ti.KeyRight)\n\tt.prepareKey(KeyPgUp, ti.KeyPgUp)\n\tt.prepareKey(KeyPgDn, ti.KeyPgDn)\n\tt.prepareKey(KeyHelp, ti.KeyHelp)\n\tt.prepareKey(KeyPrint, ti.KeyPrint)\n\tt.prepareKey(KeyCancel, ti.KeyCancel)\n\tt.prepareKey(KeyExit, ti.KeyExit)\n\tt.prepareKey(KeyBacktab, ti.KeyBacktab)\n\n\tt.prepareKeyMod(KeyRight, ModShift, ti.KeyShfRight)\n\tt.prepareKeyMod(KeyLeft, ModShift, ti.KeyShfLeft)\n\tt.prepareKeyMod(KeyUp, ModShift, ti.KeyShfUp)\n\tt.prepareKeyMod(KeyDown, ModShift, ti.KeyShfDown)\n\tt.prepareKeyMod(KeyHome, ModShift, ti.KeyShfHome)\n\tt.prepareKeyMod(KeyEnd, ModShift, ti.KeyShfEnd)\n\tt.prepareKeyMod(KeyPgUp, ModShift, ti.KeyShfPgUp)\n\tt.prepareKeyMod(KeyPgDn, ModShift, ti.KeyShfPgDn)\n\n\tt.prepareKeyMod(KeyRight, ModCtrl, ti.KeyCtrlRight)\n\tt.prepareKeyMod(KeyLeft, ModCtrl, ti.KeyCtrlLeft)\n\tt.prepareKeyMod(KeyUp, ModCtrl, ti.KeyCtrlUp)\n\tt.prepareKeyMod(KeyDown, ModCtrl, ti.KeyCtrlDown)\n\tt.prepareKeyMod(KeyHome, ModCtrl, ti.KeyCtrlHome)\n\tt.prepareKeyMod(KeyEnd, ModCtrl, ti.KeyCtrlEnd)\n\n\t// Sadly, xterm handling of keycodes is somewhat erratic.  In\n\t// particular, different codes are sent depending on application\n\t// mode is in use or not, and the entries for many of these are\n\t// simply absent from terminfo on many systems.  So we insert\n\t// a number of escape sequences if they are not already used, in\n\t// order to have the widest correct usage.  Note that prepareKey\n\t// will not inject codes if the escape sequence is already known.\n\t// We also only do this for terminals that have the application\n\t// mode present.\n\n\t// Cursor mode\n\tif ti.EnterKeypad != \"\" {\n\t\tt.prepareKey(KeyUp, \"\\x1b[A\")\n\t\tt.prepareKey(KeyDown, \"\\x1b[B\")\n\t\tt.prepareKey(KeyRight, \"\\x1b[C\")\n\t\tt.prepareKey(KeyLeft, \"\\x1b[D\")\n\t\tt.prepareKey(KeyEnd, \"\\x1b[F\")\n\t\tt.prepareKey(KeyHome, \"\\x1b[H\")\n\t\tt.prepareKey(KeyDelete, \"\\x1b[3~\")\n\t\tt.prepareKey(KeyHome, \"\\x1b[1~\")\n\t\tt.prepareKey(KeyEnd, \"\\x1b[4~\")\n\t\tt.prepareKey(KeyPgUp, \"\\x1b[5~\")\n\t\tt.prepareKey(KeyPgDn, \"\\x1b[6~\")\n\n\t\t// Application mode\n\t\tt.prepareKey(KeyUp, \"\\x1bOA\")\n\t\tt.prepareKey(KeyDown, \"\\x1bOB\")\n\t\tt.prepareKey(KeyRight, \"\\x1bOC\")\n\t\tt.prepareKey(KeyLeft, \"\\x1bOD\")\n\t\tt.prepareKey(KeyHome, \"\\x1bOH\")\n\t}\n\n\tt.prepareKey(keyPasteStart, ti.PasteStart)\n\tt.prepareKey(keyPasteEnd, ti.PasteEnd)\n\tt.prepareXtermModifiers()\n\tt.prepareBracketedPaste()\n\tt.prepareCursorStyles()\n\tt.prepareUnderlines()\n\tt.prepareExtendedOSC()\n\nouter:\n\t// Add key mappings for control keys.\n\tfor i := 0; i < ' '; i++ {\n\t\t// Do not insert direct key codes for ambiguous keys.\n\t\t// For example, ESC is used for lots of other keys, so\n\t\t// when parsing this we don't want to fast path handling\n\t\t// of it, but instead wait a bit before parsing it as in\n\t\t// isolation.\n\t\tfor esc := range t.keycodes {\n\t\t\tif []byte(esc)[0] == byte(i) {\n\t\t\t\tcontinue outer\n\t\t\t}\n\t\t}\n\n\t\tt.keyexist[Key(i)] = true\n\n\t\tmod := ModCtrl\n\t\tswitch Key(i) {\n\t\tcase KeyBS, KeyTAB, KeyESC, KeyCR:\n\t\t\t// directly type-able- no control sequence\n\t\t\tmod = ModNone\n\t\t}\n\t\tt.keycodes[string(rune(i))] = &tKeyCode{key: Key(i), mod: mod}\n\t}\n}\n\nfunc (t *tScreen) Fini() {\n\tt.finiOnce.Do(t.finish)\n}\n\nfunc (t *tScreen) finish() {\n\tclose(t.quit)\n\tt.finalize()\n}\n\nfunc (t *tScreen) SetStyle(style Style) {\n\tt.Lock()\n\tif !t.fini {\n\t\tt.style = style\n\t}\n\tt.Unlock()\n}\n\nfunc (t *tScreen) encodeRune(r rune, buf []byte) []byte {\n\n\tnb := make([]byte, 6)\n\tob := make([]byte, 6)\n\tnum := utf8.EncodeRune(ob, r)\n\tob = ob[:num]\n\tdst := 0\n\tvar err error\n\tif enc := t.encoder; enc != nil {\n\t\tenc.Reset()\n\t\tdst, _, err = enc.Transform(nb, ob, true)\n\t}\n\tif err != nil || dst == 0 || nb[0] == '\\x1a' {\n\t\t// Combining characters are elided\n\t\tif len(buf) == 0 {\n\t\t\tif acs, ok := t.acs[r]; ok {\n\t\t\t\tbuf = append(buf, []byte(acs)...)\n\t\t\t} else if fb, ok := t.fallback[r]; ok {\n\t\t\t\tbuf = append(buf, []byte(fb)...)\n\t\t\t} else {\n\t\t\t\tbuf = append(buf, '?')\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbuf = append(buf, nb[:dst]...)\n\t}\n\n\treturn buf\n}\n\nfunc (t *tScreen) sendFgBg(fg Color, bg Color, attr AttrMask) AttrMask {\n\tti := t.ti\n\tif ti.Colors == 0 {\n\t\t// foreground vs background, we calculate luminance\n\t\t// and possibly do a reverse video\n\t\tif !fg.Valid() {\n\t\t\treturn attr\n\t\t}\n\t\tv, ok := t.colors[fg]\n\t\tif !ok {\n\t\t\tv = FindColor(fg, []Color{ColorBlack, ColorWhite})\n\t\t\tt.colors[fg] = v\n\t\t}\n\t\tswitch v {\n\t\tcase ColorWhite:\n\t\t\treturn attr\n\t\tcase ColorBlack:\n\t\t\treturn attr ^ AttrReverse\n\t\t}\n\t}\n\n\tif fg == ColorReset || bg == ColorReset {\n\t\tt.TPuts(ti.ResetFgBg)\n\t}\n\tif t.truecolor {\n\t\tif ti.SetFgBgRGB != \"\" && fg.IsRGB() && bg.IsRGB() {\n\t\t\tr1, g1, b1 := fg.RGB()\n\t\t\tr2, g2, b2 := bg.RGB()\n\t\t\tt.TPuts(ti.TParm(ti.SetFgBgRGB,\n\t\t\t\tint(r1), int(g1), int(b1),\n\t\t\t\tint(r2), int(g2), int(b2)))\n\t\t\treturn attr\n\t\t}\n\n\t\tif fg.IsRGB() && ti.SetFgRGB != \"\" {\n\t\t\tr, g, b := fg.RGB()\n\t\t\tt.TPuts(ti.TParm(ti.SetFgRGB, int(r), int(g), int(b)))\n\t\t\tfg = ColorDefault\n\t\t}\n\n\t\tif bg.IsRGB() && ti.SetBgRGB != \"\" {\n\t\t\tr, g, b := bg.RGB()\n\t\t\tt.TPuts(ti.TParm(ti.SetBgRGB,\n\t\t\t\tint(r), int(g), int(b)))\n\t\t\tbg = ColorDefault\n\t\t}\n\t}\n\n\tif fg.Valid() {\n\t\tif v, ok := t.colors[fg]; ok {\n\t\t\tfg = v\n\t\t} else {\n\t\t\tv = FindColor(fg, t.palette)\n\t\t\tt.colors[fg] = v\n\t\t\tfg = v\n\t\t}\n\t}\n\n\tif bg.Valid() {\n\t\tif v, ok := t.colors[bg]; ok {\n\t\t\tbg = v\n\t\t} else {\n\t\t\tv = FindColor(bg, t.palette)\n\t\t\tt.colors[bg] = v\n\t\t\tbg = v\n\t\t}\n\t}\n\n\tif fg.Valid() && bg.Valid() && ti.SetFgBg != \"\" {\n\t\tt.TPuts(ti.TParm(ti.SetFgBg, int(fg&0xff), int(bg&0xff)))\n\t} else {\n\t\tif fg.Valid() && ti.SetFg != \"\" {\n\t\t\tt.TPuts(ti.TParm(ti.SetFg, int(fg&0xff)))\n\t\t}\n\t\tif bg.Valid() && ti.SetBg != \"\" {\n\t\t\tt.TPuts(ti.TParm(ti.SetBg, int(bg&0xff)))\n\t\t}\n\t}\n\treturn attr\n}\n\nfunc (t *tScreen) drawCell(x, y int) int {\n\n\tti := t.ti\n\n\tmainc, combc, style, width := t.cells.GetContent(x, y)\n\tif !t.cells.Dirty(x, y) {\n\t\treturn width\n\t}\n\n\tif y == t.h-1 && x == t.w-1 && t.ti.AutoMargin && ti.DisableAutoMargin == \"\" && ti.InsertChar != \"\" {\n\t\t// our solution is somewhat goofy.\n\t\t// we write to the second to the last cell what we want in the last cell, then we\n\t\t// insert a character at that 2nd to last position to shift the last column into\n\t\t// place, then we rewrite that 2nd to last cell.  Old terminals suck.\n\t\tt.TPuts(ti.TGoto(x-1, y))\n\t\tdefer func() {\n\t\t\tt.TPuts(ti.TGoto(x-1, y))\n\t\t\tt.TPuts(ti.InsertChar)\n\t\t\tt.cy = y\n\t\t\tt.cx = x - 1\n\t\t\tt.cells.SetDirty(x-1, y, true)\n\t\t\t_ = t.drawCell(x-1, y)\n\t\t\tt.TPuts(t.ti.TGoto(0, 0))\n\t\t\tt.cy = 0\n\t\t\tt.cx = 0\n\t\t}()\n\t} else if t.cy != y || t.cx != x {\n\t\tt.TPuts(ti.TGoto(x, y))\n\t\tt.cx = x\n\t\tt.cy = y\n\t}\n\n\tif style == StyleDefault {\n\t\tstyle = t.style\n\t}\n\tif style != t.curstyle {\n\t\tfg, bg, attrs := style.fg, style.bg, style.attrs\n\n\t\tt.TPuts(ti.AttrOff)\n\n\t\tattrs = t.sendFgBg(fg, bg, attrs)\n\t\tif attrs&AttrBold != 0 {\n\t\t\tt.TPuts(ti.Bold)\n\t\t}\n\t\tif us, uc := style.ulStyle, style.ulColor; us != UnderlineStyleNone {\n\t\t\tif t.underColor != \"\" || t.underRGB != \"\" {\n\t\t\t\tif uc == ColorReset {\n\t\t\t\t\tt.TPuts(t.underFg)\n\t\t\t\t} else if uc.IsRGB() {\n\t\t\t\t\tif t.underRGB != \"\" {\n\t\t\t\t\t\tr, g, b := uc.RGB()\n\t\t\t\t\t\tt.TPuts(ti.TParm(t.underRGB, int(r), int(g), int(b)))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif v, ok := t.colors[uc]; ok {\n\t\t\t\t\t\t\tuc = v\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tv = FindColor(uc, t.palette)\n\t\t\t\t\t\t\tt.colors[uc] = v\n\t\t\t\t\t\t\tuc = v\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt.TPuts(ti.TParm(t.underColor, int(uc&0xff)))\n\t\t\t\t\t}\n\t\t\t\t} else if uc.Valid() {\n\t\t\t\t\tt.TPuts(ti.TParm(t.underColor, int(uc&0xff)))\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.TPuts(ti.Underline) // to ensure everyone gets at least a basic underline\n\t\t\tswitch us {\n\t\t\tcase UnderlineStyleDouble:\n\t\t\t\tt.TPuts(t.doubleUnder)\n\t\t\tcase UnderlineStyleCurly:\n\t\t\t\tt.TPuts(t.curlyUnder)\n\t\t\tcase UnderlineStyleDotted:\n\t\t\t\tt.TPuts(t.dottedUnder)\n\t\t\tcase UnderlineStyleDashed:\n\t\t\t\tt.TPuts(t.dashedUnder)\n\t\t\t}\n\t\t}\n\t\tif attrs&AttrReverse != 0 {\n\t\t\tt.TPuts(ti.Reverse)\n\t\t}\n\t\tif attrs&AttrBlink != 0 {\n\t\t\tt.TPuts(ti.Blink)\n\t\t}\n\t\tif attrs&AttrDim != 0 {\n\t\t\tt.TPuts(ti.Dim)\n\t\t}\n\t\tif attrs&AttrItalic != 0 {\n\t\t\tt.TPuts(ti.Italic)\n\t\t}\n\t\tif attrs&AttrStrikeThrough != 0 {\n\t\t\tt.TPuts(ti.StrikeThrough)\n\t\t}\n\n\t\t// URL string can be long, so don't send it unless we really need to\n\t\tif t.enterUrl != \"\" && t.curstyle != style {\n\t\t\tif style.url != \"\" {\n\t\t\t\tt.TPuts(ti.TParm(t.enterUrl, style.url, style.urlId))\n\t\t\t} else {\n\t\t\t\tt.TPuts(t.exitUrl)\n\t\t\t}\n\t\t}\n\n\t\tt.curstyle = style\n\t}\n\n\t// now emit runes - taking care to not overrun width with a\n\t// wide character, and to ensure that we emit exactly one regular\n\t// character followed up by any residual combing characters\n\n\tif width < 1 {\n\t\twidth = 1\n\t}\n\n\tvar str string\n\n\tbuf := make([]byte, 0, 6)\n\n\tbuf = t.encodeRune(mainc, buf)\n\tfor _, r := range combc {\n\t\tbuf = t.encodeRune(r, buf)\n\t}\n\n\tstr = string(buf)\n\tif width > 1 && str == \"?\" {\n\t\t// No FullWidth character support\n\t\tstr = \"? \"\n\t\tt.cx = -1\n\t}\n\n\tif x > t.w-width {\n\t\t// too wide to fit; emit a single space instead\n\t\twidth = 1\n\t\tstr = \" \"\n\t}\n\tt.writeString(str)\n\tt.cx += width\n\tt.cells.SetDirty(x, y, false)\n\tif width > 1 {\n\t\tt.cx = -1\n\t}\n\n\treturn width\n}\n\nfunc (t *tScreen) ShowCursor(x, y int) {\n\tt.Lock()\n\tt.cursorx = x\n\tt.cursory = y\n\tt.Unlock()\n}\n\nfunc (t *tScreen) SetCursor(cs CursorStyle, cc Color) {\n\tt.Lock()\n\tt.cursorStyle = cs\n\tt.cursorColor = cc\n\tt.Unlock()\n}\n\nfunc (t *tScreen) HideCursor() {\n\tt.ShowCursor(-1, -1)\n}\n\nfunc (t *tScreen) showCursor() {\n\n\tx, y := t.cursorx, t.cursory\n\tw, h := t.cells.Size()\n\tif x < 0 || y < 0 || x >= w || y >= h {\n\t\tt.hideCursor()\n\t\treturn\n\t}\n\tt.TPuts(t.ti.TGoto(x, y))\n\tt.TPuts(t.ti.ShowCursor)\n\tif t.cursorStyles != nil {\n\t\tif esc, ok := t.cursorStyles[t.cursorStyle]; ok {\n\t\t\tt.TPuts(esc)\n\t\t}\n\t}\n\tif t.cursorRGB != \"\" {\n\t\tif t.cursorColor == ColorReset {\n\t\t\tt.TPuts(t.cursorFg)\n\t\t} else if t.cursorColor.Valid() {\n\t\t\tr, g, b := t.cursorColor.RGB()\n\t\t\tt.TPuts(t.ti.TParm(t.cursorRGB, int(r), int(g), int(b)))\n\t\t}\n\t}\n\tt.cx = x\n\tt.cy = y\n}\n\n// writeString sends a string to the terminal. The string is sent as-is and\n// this function does not expand inline padding indications (of the form\n// $<[delay]> where [delay] is msec). In order to have these expanded, use\n// TPuts. If the screen is \"buffering\", the string is collected in a buffer,\n// with the intention that the entire buffer be sent to the terminal in one\n// write operation at some point later.\nfunc (t *tScreen) writeString(s string) {\n\tif t.buffering {\n\t\t_, _ = io.WriteString(&t.buf, s)\n\t} else {\n\t\t_, _ = io.WriteString(t.tty, s)\n\t}\n}\n\nfunc (t *tScreen) TPuts(s string) {\n\tif t.buffering {\n\t\tt.ti.TPuts(&t.buf, s)\n\t} else {\n\t\tt.ti.TPuts(t.tty, s)\n\t}\n}\n\nfunc (t *tScreen) Show() {\n\tt.Lock()\n\tif !t.fini {\n\t\tt.resize()\n\t\tt.draw()\n\t}\n\tt.Unlock()\n}\n\nfunc (t *tScreen) clearScreen() {\n\tt.TPuts(t.ti.AttrOff)\n\tt.TPuts(t.exitUrl)\n\t_ = t.sendFgBg(t.style.fg, t.style.bg, AttrNone)\n\tt.TPuts(t.ti.Clear)\n\tt.clear = false\n}\n\nfunc (t *tScreen) hideCursor() {\n\t// does not update cursor position\n\tif t.ti.HideCursor != \"\" {\n\t\tt.TPuts(t.ti.HideCursor)\n\t} else {\n\t\t// No way to hide cursor, stick it\n\t\t// at bottom right of screen\n\t\tt.cx, t.cy = t.cells.Size()\n\t\tt.TPuts(t.ti.TGoto(t.cx, t.cy))\n\t}\n}\n\nfunc (t *tScreen) draw() {\n\t// clobber cursor position, because we're going to change it all\n\tt.cx = -1\n\tt.cy = -1\n\t// make no style assumptions\n\tt.curstyle = styleInvalid\n\n\tt.buf.Reset()\n\tt.buffering = true\n\tdefer func() {\n\t\tt.buffering = false\n\t}()\n\n\t// hide the cursor while we move stuff around\n\tt.hideCursor()\n\n\tif t.clear {\n\t\tt.clearScreen()\n\t}\n\n\tfor y := 0; y < t.h; y++ {\n\t\tfor x := 0; x < t.w; x++ {\n\t\t\twidth := t.drawCell(x, y)\n\t\t\tif width > 1 {\n\t\t\t\tif x+1 < t.w {\n\t\t\t\t\t// this is necessary so that if we ever\n\t\t\t\t\t// go back to drawing that cell, we\n\t\t\t\t\t// actually will *draw* it.\n\t\t\t\t\tt.cells.SetDirty(x+1, y, true)\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += width - 1\n\t\t}\n\t}\n\n\t// restore the cursor\n\tt.showCursor()\n\n\t_, _ = t.buf.WriteTo(t.tty)\n}\n\nfunc (t *tScreen) EnableMouse(flags ...MouseFlags) {\n\tvar f MouseFlags\n\tflagsPresent := false\n\tfor _, flag := range flags {\n\t\tf |= flag\n\t\tflagsPresent = true\n\t}\n\tif !flagsPresent {\n\t\tf = MouseMotionEvents | MouseDragEvents | MouseButtonEvents\n\t}\n\n\tt.Lock()\n\tt.mouseFlags = f\n\tt.enableMouse(f)\n\tt.Unlock()\n}\n\nfunc (t *tScreen) enableMouse(f MouseFlags) {\n\t// Rather than using terminfo to find mouse escape sequences, we rely on the fact that\n\t// pretty much *every* terminal that supports mouse tracking follows the\n\t// XTerm standards (the modern ones).\n\tif len(t.mouse) != 0 {\n\t\t// start by disabling all tracking.\n\t\tt.TPuts(\"\\x1b[?1000l\\x1b[?1002l\\x1b[?1003l\\x1b[?1006l\")\n\t\tif f&MouseButtonEvents != 0 {\n\t\t\tt.TPuts(\"\\x1b[?1000h\")\n\t\t}\n\t\tif f&MouseDragEvents != 0 {\n\t\t\tt.TPuts(\"\\x1b[?1002h\")\n\t\t}\n\t\tif f&MouseMotionEvents != 0 {\n\t\t\tt.TPuts(\"\\x1b[?1003h\")\n\t\t}\n\t\tif f&(MouseButtonEvents|MouseDragEvents|MouseMotionEvents) != 0 {\n\t\t\tt.TPuts(\"\\x1b[?1006h\")\n\t\t}\n\t}\n\n}\n\nfunc (t *tScreen) DisableMouse() {\n\tt.Lock()\n\tt.mouseFlags = 0\n\tt.enableMouse(0)\n\tt.Unlock()\n}\n\nfunc (t *tScreen) EnablePaste() {\n\tt.Lock()\n\tt.pasteEnabled = true\n\tt.enablePasting(true)\n\tt.Unlock()\n}\n\nfunc (t *tScreen) DisablePaste() {\n\tt.Lock()\n\tt.pasteEnabled = false\n\tt.enablePasting(false)\n\tt.Unlock()\n}\n\nfunc (t *tScreen) enablePasting(on bool) {\n\tvar s string\n\tif on {\n\t\ts = t.enablePaste\n\t} else {\n\t\ts = t.disablePaste\n\t}\n\tif s != \"\" {\n\t\tt.TPuts(s)\n\t}\n}\n\nfunc (t *tScreen) EnableFocus() {\n\tt.Lock()\n\tt.focusEnabled = true\n\tt.enableFocusReporting()\n\tt.Unlock()\n}\n\nfunc (t *tScreen) DisableFocus() {\n\tt.Lock()\n\tt.focusEnabled = false\n\tt.disableFocusReporting()\n\tt.Unlock()\n}\n\nfunc (t *tScreen) enableFocusReporting() {\n\tif t.enableFocus != \"\" {\n\t\tt.TPuts(t.enableFocus)\n\t}\n}\n\nfunc (t *tScreen) disableFocusReporting() {\n\tif t.disableFocus != \"\" {\n\t\tt.TPuts(t.disableFocus)\n\t}\n}\n\nfunc (t *tScreen) Size() (int, int) {\n\tt.Lock()\n\tw, h := t.w, t.h\n\tt.Unlock()\n\treturn w, h\n}\n\nfunc (t *tScreen) resize() {\n\tws, err := t.tty.WindowSize()\n\tif err != nil {\n\t\treturn\n\t}\n\tif ws.Width == t.w && ws.Height == t.h {\n\t\treturn\n\t}\n\tt.cx = -1\n\tt.cy = -1\n\n\tt.cells.Resize(ws.Width, ws.Height)\n\tt.cells.Invalidate()\n\tt.h = ws.Height\n\tt.w = ws.Width\n\tev := &EventResize{t: time.Now(), ws: ws}\n\tselect {\n\tcase t.eventQ <- ev:\n\tdefault:\n\t}\n}\n\nfunc (t *tScreen) Colors() int {\n\t// this doesn't change, no need for lock\n\tif t.truecolor {\n\t\treturn 1 << 24\n\t}\n\treturn t.ti.Colors\n}\n\n// nColors returns the size of the built-in palette.\n// This is distinct from Colors(), as it will generally\n// always be a small number. (<= 256)\nfunc (t *tScreen) nColors() int {\n\treturn t.ti.Colors\n}\n\n// vtACSNames is a map of bytes defined by terminfo that are used in\n// the terminals Alternate Character Set to represent other glyphs.\n// For example, the upper left corner of the box drawing set can be\n// displayed by printing \"l\" while in the alternate character set.\n// It's not quite that simple, since the \"l\" is the terminfo name,\n// and it may be necessary to use a different character based on\n// the terminal implementation (or the terminal may lack support for\n// this altogether).  See buildAcsMap below for detail.\nvar vtACSNames = map[byte]rune{\n\t'+': RuneRArrow,\n\t',': RuneLArrow,\n\t'-': RuneUArrow,\n\t'.': RuneDArrow,\n\t'0': RuneBlock,\n\t'`': RuneDiamond,\n\t'a': RuneCkBoard,\n\t'b': '␉', // VT100, Not defined by terminfo\n\t'c': '␌', // VT100, Not defined by terminfo\n\t'd': '␋', // VT100, Not defined by terminfo\n\t'e': '␊', // VT100, Not defined by terminfo\n\t'f': RuneDegree,\n\t'g': RunePlMinus,\n\t'h': RuneBoard,\n\t'i': RuneLantern,\n\t'j': RuneLRCorner,\n\t'k': RuneURCorner,\n\t'l': RuneULCorner,\n\t'm': RuneLLCorner,\n\t'n': RunePlus,\n\t'o': RuneS1,\n\t'p': RuneS3,\n\t'q': RuneHLine,\n\t'r': RuneS7,\n\t's': RuneS9,\n\t't': RuneLTee,\n\t'u': RuneRTee,\n\t'v': RuneBTee,\n\t'w': RuneTTee,\n\t'x': RuneVLine,\n\t'y': RuneLEqual,\n\t'z': RuneGEqual,\n\t'{': RunePi,\n\t'|': RuneNEqual,\n\t'}': RuneSterling,\n\t'~': RuneBullet,\n}\n\n// buildAcsMap builds a map of characters that we translate from Unicode to\n// alternate character encodings.  To do this, we use the standard VT100 ACS\n// maps.  This is only done if the terminal lacks support for Unicode; we\n// always prefer to emit Unicode glyphs when we are able.\nfunc (t *tScreen) buildAcsMap() {\n\tacsstr := t.ti.AltChars\n\tt.acs = make(map[rune]string)\n\tfor len(acsstr) > 2 {\n\t\tsrcv := acsstr[0]\n\t\tdstv := string(acsstr[1])\n\t\tif r, ok := vtACSNames[srcv]; ok {\n\t\t\tt.acs[r] = t.ti.EnterAcs + dstv + t.ti.ExitAcs\n\t\t}\n\t\tacsstr = acsstr[2:]\n\t}\n}\n\nfunc (t *tScreen) clip(x, y int) (int, int) {\n\tw, h := t.cells.Size()\n\tif x < 0 {\n\t\tx = 0\n\t}\n\tif y < 0 {\n\t\ty = 0\n\t}\n\tif x > w-1 {\n\t\tx = w - 1\n\t}\n\tif y > h-1 {\n\t\ty = h - 1\n\t}\n\treturn x, y\n}\n\n// buildMouseEvent returns an event based on the supplied coordinates and button\n// state. Note that the screen's mouse button state is updated based on the\n// input to this function (i.e. it mutates the receiver).\nfunc (t *tScreen) buildMouseEvent(x, y, btn int) *EventMouse {\n\n\t// XTerm mouse events only report at most one button at a time,\n\t// which may include a wheel button.  Wheel motion events are\n\t// reported as single impulses, while other button events are reported\n\t// as separate press & release events.\n\n\tbutton := ButtonNone\n\tmod := ModNone\n\n\t// Mouse wheel has bit 6 set, no release events.  It should be noted\n\t// that wheel events are sometimes misdelivered as mouse button events\n\t// during a click-drag, so we debounce these, considering them to be\n\t// button press events unless we see an intervening release event.\n\tswitch btn & 0x43 {\n\tcase 0:\n\t\tbutton = Button1\n\tcase 1:\n\t\tbutton = Button3 // Note we prefer to treat right as button 2\n\tcase 2:\n\t\tbutton = Button2 // And the middle button as button 3\n\tcase 3:\n\t\tbutton = ButtonNone\n\tcase 0x40:\n\t\tbutton = WheelUp\n\tcase 0x41:\n\t\tbutton = WheelDown\n\t}\n\n\tif btn&0x4 != 0 {\n\t\tmod |= ModShift\n\t}\n\tif btn&0x8 != 0 {\n\t\tmod |= ModAlt\n\t}\n\tif btn&0x10 != 0 {\n\t\tmod |= ModCtrl\n\t}\n\n\t// Some terminals will report mouse coordinates outside the\n\t// screen, especially with click-drag events.  Clip the coordinates\n\t// to the screen in that case.\n\tx, y = t.clip(x, y)\n\n\treturn NewEventMouse(x, y, button, mod)\n}\n\n// parseSgrMouse attempts to locate an SGR mouse record at the start of the\n// buffer.  It returns true, true if it found one, and the associated bytes\n// be removed from the buffer.  It returns true, false if the buffer might\n// contain such an event, but more bytes are necessary (partial match), and\n// false, false if the content is definitely *not* an SGR mouse record.\nfunc (t *tScreen) parseSgrMouse(buf *bytes.Buffer, evs *[]Event) (bool, bool) {\n\n\tb := buf.Bytes()\n\n\tvar x, y, btn, state int\n\tdig := false\n\tneg := false\n\tmotion := false\n\tscroll := false\n\ti := 0\n\tval := 0\n\n\tfor i = range b {\n\t\tswitch b[i] {\n\t\tcase '\\x1b':\n\t\t\tif state != 0 {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tstate = 1\n\n\t\tcase '\\x9b':\n\t\t\tif state != 0 {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tstate = 2\n\n\t\tcase '[':\n\t\t\tif state != 1 {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tstate = 2\n\n\t\tcase '<':\n\t\t\tif state != 2 {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tval = 0\n\t\t\tdig = false\n\t\t\tneg = false\n\t\t\tstate = 3\n\n\t\tcase '-':\n\t\t\tif state != 3 && state != 4 && state != 5 {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tif dig || neg {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tneg = true // stay in state\n\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tif state != 3 && state != 4 && state != 5 {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tval *= 10\n\t\t\tval += int(b[i] - '0')\n\t\t\tdig = true // stay in state\n\n\t\tcase ';':\n\t\t\tif neg {\n\t\t\t\tval = -val\n\t\t\t}\n\t\t\tswitch state {\n\t\t\tcase 3:\n\t\t\t\tbtn, val = val, 0\n\t\t\t\tneg, dig, state = false, false, 4\n\t\t\tcase 4:\n\t\t\t\tx, val = val-1, 0\n\t\t\t\tneg, dig, state = false, false, 5\n\t\t\tdefault:\n\t\t\t\treturn false, false\n\t\t\t}\n\n\t\tcase 'm', 'M':\n\t\t\tif state != 5 {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tif neg {\n\t\t\t\tval = -val\n\t\t\t}\n\t\t\ty = val - 1\n\n\t\t\tmotion = (btn & 32) != 0\n\t\t\tscroll = (btn & 0x42) == 0x40\n\t\t\tbtn &^= 32\n\t\t\tif b[i] == 'm' {\n\t\t\t\t// mouse release, clear all buttons\n\t\t\t\tbtn |= 3\n\t\t\t\tbtn &^= 0x40\n\t\t\t\tt.buttondn = false\n\t\t\t} else if motion {\n\t\t\t\t/*\n\t\t\t\t * Some broken terminals appear to send\n\t\t\t\t * mouse button one motion events, instead of\n\t\t\t\t * encoding 35 (no buttons) into these events.\n\t\t\t\t * We resolve these by looking for a non-motion\n\t\t\t\t * event first.\n\t\t\t\t */\n\t\t\t\tif !t.buttondn {\n\t\t\t\t\tbtn |= 3\n\t\t\t\t\tbtn &^= 0x40\n\t\t\t\t}\n\t\t\t} else if !scroll {\n\t\t\t\tt.buttondn = true\n\t\t\t}\n\t\t\t// consume the event bytes\n\t\t\tfor i >= 0 {\n\t\t\t\t_, _ = buf.ReadByte()\n\t\t\t\ti--\n\t\t\t}\n\t\t\t*evs = append(*evs, t.buildMouseEvent(x, y, btn))\n\t\t\treturn true, true\n\t\t}\n\t}\n\n\t// incomplete & inconclusive at this point\n\treturn true, false\n}\n\nfunc (t *tScreen) parseFocus(buf *bytes.Buffer, evs *[]Event) (bool, bool) {\n\tstate := 0\n\tb := buf.Bytes()\n\tfor i := range b {\n\t\tswitch state {\n\t\tcase 0:\n\t\t\tif b[i] != '\\x1b' {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tstate = 1\n\t\tcase 1:\n\t\t\tif b[i] != '[' {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tstate = 2\n\t\tcase 2:\n\t\t\tif b[i] != 'I' && b[i] != 'O' {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\t*evs = append(*evs, NewEventFocus(b[i] == 'I'))\n\t\t\t_, _ = buf.ReadByte()\n\t\t\t_, _ = buf.ReadByte()\n\t\t\t_, _ = buf.ReadByte()\n\t\t\treturn true, true\n\t\t}\n\t}\n\treturn true, false\n}\n\nfunc (t *tScreen) parseClipboard(buf *bytes.Buffer, evs *[]Event) (bool, bool) {\n\tb := buf.Bytes()\n\tstate := 0\n\tprefix := []byte(\"\\x1b]52;c;\")\n\n\tif len(prefix) >= len(b) {\n\t\tif bytes.HasPrefix(prefix, b) {\n\t\t\t// inconclusive so far\n\t\t\treturn true, false\n\t\t}\n\t\t// definitely not a match\n\t\treturn false, false\n\t}\n\tb = b[len(prefix):]\n\n\tfor _, c := range b {\n\t\t// valid base64 digits\n\t\tif (state == 0) {\n\t\t\tif (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c == '+') || (c == '/') || (c == '=') {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (c == '\\x1b') {\n\t\t\t\tstate = 1\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (c == '\\a') {\n\t\t\t\t// matched with BEL instead of ST\n\t\t\t\tb = b[:len(b)-1] // drop the trailing BEL\n\t\t\t\tdecoded := make([]byte, base64.StdEncoding.DecodedLen(len(b)))\n\t\t\t\tif num, err := base64.StdEncoding.Decode(decoded, b); err == nil {\n\t\t\t\t\t*evs = append(*evs, NewEventClipboard(decoded[:num]))\n\t\t\t\t}\n\t\t\t\t_, _ = buf.ReadBytes('\\a')\n\t\t\t\treturn true, true\n\t\t\t}\n\t\t\treturn false, false\n\t\t}\n\t\tif (state == 1)  {\n\t\t\tif (c == '\\\\') {\n\t\t\t\tb = b[:len(b)-2] // drop the trailing ST (\\x1b\\\\)\n\t\t\t\t// now decode the data\n\t\t\t\tdecoded := make([]byte, base64.StdEncoding.DecodedLen(len(b)))\n\t\t\t\tif num, err := base64.StdEncoding.Decode(decoded, b); err == nil {\n\t\t\t\t\t*evs = append(*evs, NewEventClipboard(decoded[:num]))\n\t\t\t\t}\n\t\t\t\t_, _ = buf.ReadBytes('\\\\')\n\t\t\t\treturn true, true\n\t\t\t}\n\t\t\treturn false, false\n\t\t}\n\t}\n\t// not enough data yet (not terminated)\n\treturn true, false\n}\n\n// parseXtermMouse is like parseSgrMouse, but it parses a legacy\n// X11 mouse record.\nfunc (t *tScreen) parseXtermMouse(buf *bytes.Buffer, evs *[]Event) (bool, bool) {\n\n\tb := buf.Bytes()\n\n\tstate := 0\n\tbtn := 0\n\tx := 0\n\ty := 0\n\n\tfor i := range b {\n\t\tswitch state {\n\t\tcase 0:\n\t\t\tswitch b[i] {\n\t\t\tcase '\\x1b':\n\t\t\t\tstate = 1\n\t\t\tcase '\\x9b':\n\t\t\t\tstate = 2\n\t\t\tdefault:\n\t\t\t\treturn false, false\n\t\t\t}\n\t\tcase 1:\n\t\t\tif b[i] != '[' {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tstate = 2\n\t\tcase 2:\n\t\t\tif b[i] != 'M' {\n\t\t\t\treturn false, false\n\t\t\t}\n\t\t\tstate++\n\t\tcase 3:\n\t\t\tbtn = int(b[i])\n\t\t\tstate++\n\t\tcase 4:\n\t\t\tx = int(b[i]) - 32 - 1\n\t\t\tstate++\n\t\tcase 5:\n\t\t\ty = int(b[i]) - 32 - 1\n\t\t\tfor i >= 0 {\n\t\t\t\t_, _ = buf.ReadByte()\n\t\t\t\ti--\n\t\t\t}\n\t\t\t*evs = append(*evs, t.buildMouseEvent(x, y, btn))\n\t\t\treturn true, true\n\t\t}\n\t}\n\treturn true, false\n}\n\nfunc (t *tScreen) parseFunctionKey(buf *bytes.Buffer, evs *[]Event) (bool, bool) {\n\tb := buf.Bytes()\n\tpartial := false\n\tfor e, k := range t.keycodes {\n\t\tesc := []byte(e)\n\t\tif (len(esc) == 1) && (esc[0] == '\\x1b') {\n\t\t\tcontinue\n\t\t}\n\t\tif bytes.HasPrefix(b, esc) {\n\t\t\t// matched\n\t\t\tvar r rune\n\t\t\tif len(esc) == 1 {\n\t\t\t\tr = rune(b[0])\n\t\t\t}\n\t\t\tmod := k.mod\n\t\t\tif t.escaped {\n\t\t\t\tmod |= ModAlt\n\t\t\t\tt.escaped = false\n\t\t\t}\n\t\t\tswitch k.key {\n\t\t\tcase keyPasteStart:\n\t\t\t\t*evs = append(*evs, NewEventPaste(true))\n\t\t\tcase keyPasteEnd:\n\t\t\t\t*evs = append(*evs, NewEventPaste(false))\n\t\t\tdefault:\n\t\t\t\t*evs = append(*evs, NewEventKey(k.key, r, mod))\n\t\t\t}\n\t\t\tfor i := 0; i < len(esc); i++ {\n\t\t\t\t_, _ = buf.ReadByte()\n\t\t\t}\n\t\t\treturn true, true\n\t\t}\n\t\tif bytes.HasPrefix(esc, b) {\n\t\t\tpartial = true\n\t\t}\n\t}\n\treturn partial, false\n}\n\nfunc (t *tScreen) parseRune(buf *bytes.Buffer, evs *[]Event) (bool, bool) {\n\tb := buf.Bytes()\n\tif b[0] >= ' ' && b[0] <= 0x7F {\n\t\t// printable ASCII easy to deal with -- no encodings\n\t\tmod := ModNone\n\t\tif t.escaped {\n\t\t\tmod = ModAlt\n\t\t\tt.escaped = false\n\t\t}\n\t\t*evs = append(*evs, NewEventKey(KeyRune, rune(b[0]), mod))\n\t\t_, _ = buf.ReadByte()\n\t\treturn true, true\n\t}\n\n\tif b[0] < 0x80 {\n\t\t// Low numbered values are control keys, not runes.\n\t\treturn false, false\n\t}\n\n\tutf := make([]byte, 12)\n\tfor l := 1; l <= len(b); l++ {\n\t\tt.decoder.Reset()\n\t\tnOut, nIn, e := t.decoder.Transform(utf, b[:l], true)\n\t\tif e == transform.ErrShortSrc {\n\t\t\tcontinue\n\t\t}\n\t\tif nOut != 0 {\n\t\t\tr, _ := utf8.DecodeRune(utf[:nOut])\n\t\t\tif r != utf8.RuneError {\n\t\t\t\tmod := ModNone\n\t\t\t\tif t.escaped {\n\t\t\t\t\tmod = ModAlt\n\t\t\t\t\tt.escaped = false\n\t\t\t\t}\n\t\t\t\t*evs = append(*evs, NewEventKey(KeyRune, r, mod))\n\t\t\t}\n\t\t\tfor nIn > 0 {\n\t\t\t\t_, _ = buf.ReadByte()\n\t\t\t\tnIn--\n\t\t\t}\n\t\t\treturn true, true\n\t\t}\n\t}\n\t// Looks like potential escape\n\treturn true, false\n}\n\nfunc (t *tScreen) scanInput(buf *bytes.Buffer, expire bool) {\n\tevs := t.collectEventsFromInput(buf, expire)\n\n\tfor _, ev := range evs {\n\t\tselect {\n\t\tcase t.eventQ <- ev:\n\t\tcase <-t.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Return an array of Events extracted from the supplied buffer. This is done\n// while holding the screen's lock - the events can then be queued for\n// application processing with the lock released.\nfunc (t *tScreen) collectEventsFromInput(buf *bytes.Buffer, expire bool) []Event {\n\n\tres := make([]Event, 0, 20)\n\n\tt.Lock()\n\tdefer t.Unlock()\n\n\tfor {\n\t\tb := buf.Bytes()\n\t\tif len(b) == 0 {\n\t\t\tbuf.Reset()\n\t\t\treturn res\n\t\t}\n\n\t\tpartials := 0\n\n\t\tif part, comp := t.parseRune(buf, &res); comp {\n\t\t\tcontinue\n\t\t} else if part {\n\t\t\tpartials++\n\t\t}\n\n\t\tif part, comp := t.parseFunctionKey(buf, &res); comp {\n\t\t\tcontinue\n\t\t} else if part {\n\t\t\tpartials++\n\t\t}\n\n\t\tif part, comp := t.parseFocus(buf, &res); comp {\n\t\t\tcontinue\n\t\t} else if part {\n\t\t\tpartials++\n\t\t}\n\n\t\t// Only parse mouse records if this term claims to have\n\t\t// mouse support\n\n\t\tif t.ti.Mouse != \"\" {\n\t\t\tif part, comp := t.parseXtermMouse(buf, &res); comp {\n\t\t\t\tcontinue\n\t\t\t} else if part {\n\t\t\t\tpartials++\n\t\t\t}\n\n\t\t\tif part, comp := t.parseSgrMouse(buf, &res); comp {\n\t\t\t\tcontinue\n\t\t\t} else if part {\n\t\t\t\tpartials++\n\t\t\t}\n\t\t}\n\n\t\tif t.setClipboard != \"\" {\n\t\t\tif part, comp := t.parseClipboard(buf, &res); comp {\n\t\t\t\tcontinue\n\t\t\t} else if part {\n\t\t\t\tpartials++\n\t\t\t}\n\t\t}\n\n\t\tif partials == 0 || expire {\n\t\t\tif b[0] == '\\x1b' {\n\t\t\t\tif len(b) == 1 {\n\t\t\t\t\tres = append(res, NewEventKey(KeyEsc, 0, ModNone))\n\t\t\t\t\tt.escaped = false\n\t\t\t\t} else {\n\t\t\t\t\tt.escaped = true\n\t\t\t\t}\n\t\t\t\t_, _ = buf.ReadByte()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Nothing was going to match, or we timed-out\n\t\t\t// waiting for more data -- just deliver the characters\n\t\t\t// to the app & let them sort it out.  Possibly we\n\t\t\t// should only do this for control characters like ESC.\n\t\t\tby, _ := buf.ReadByte()\n\t\t\tmod := ModNone\n\t\t\tif t.escaped {\n\t\t\t\tt.escaped = false\n\t\t\t\tmod = ModAlt\n\t\t\t}\n\t\t\tres = append(res, NewEventKey(KeyRune, rune(by), mod))\n\t\t\tcontinue\n\t\t}\n\n\t\t// well we have some partial data, wait until we get\n\t\t// some more\n\t\tbreak\n\t}\n\n\treturn res\n}\n\nfunc (t *tScreen) mainLoop(stopQ chan struct{}) {\n\tdefer t.wg.Done()\n\tbuf := &bytes.Buffer{}\n\tfor {\n\t\tselect {\n\t\tcase <-stopQ:\n\t\t\treturn\n\t\tcase <-t.quit:\n\t\t\treturn\n\t\tcase <-t.resizeQ:\n\t\t\tt.Lock()\n\t\t\tt.cx = -1\n\t\t\tt.cy = -1\n\t\t\tt.resize()\n\t\t\tt.cells.Invalidate()\n\t\t\tt.draw()\n\t\t\tt.Unlock()\n\t\t\tcontinue\n\t\tcase <-t.keytimer.C:\n\t\t\t// If the timer fired, and the current time\n\t\t\t// is after the expiration of the escape sequence,\n\t\t\t// then we assume the escape sequence reached its\n\t\t\t// conclusion, and process the chunk independently.\n\t\t\t// This lets us detect conflicts such as a lone ESC.\n\t\t\tif buf.Len() > 0 {\n\t\t\t\tif time.Now().After(t.keyexpire) {\n\t\t\t\t\tt.scanInput(buf, true)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif buf.Len() > 0 {\n\t\t\t\tif !t.keytimer.Stop() {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-t.keytimer.C:\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.keytimer.Reset(time.Millisecond * 50)\n\t\t\t}\n\t\tcase chunk := <-t.keychan:\n\t\t\tbuf.Write(chunk)\n\t\t\tt.keyexpire = time.Now().Add(time.Millisecond * 50)\n\t\t\tt.scanInput(buf, false)\n\t\t\tif !t.keytimer.Stop() {\n\t\t\t\tselect {\n\t\t\t\tcase <-t.keytimer.C:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t\tif buf.Len() > 0 {\n\t\t\t\tt.keytimer.Reset(time.Millisecond * 50)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (t *tScreen) inputLoop(stopQ chan struct{}) {\n\n\tdefer t.wg.Done()\n\tfor {\n\t\tselect {\n\t\tcase <-stopQ:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t\tchunk := make([]byte, 128)\n\t\tn, e := t.tty.Read(chunk)\n\t\tswitch e {\n\t\tcase nil:\n\t\tdefault:\n\t\t\tt.Lock()\n\t\t\trunning := t.running\n\t\t\tt.Unlock()\n\t\t\tif running {\n\t\t\t\tselect {\n\t\t\t\tcase t.eventQ <- NewEventError(e):\n\t\t\t\tcase <-t.quit:\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif n > 0 {\n\t\t\tt.keychan <- chunk[:n]\n\t\t}\n\t}\n}\n\nfunc (t *tScreen) Sync() {\n\tt.Lock()\n\tt.cx = -1\n\tt.cy = -1\n\tif !t.fini {\n\t\tt.resize()\n\t\tt.clear = true\n\t\tt.cells.Invalidate()\n\t\tt.draw()\n\t}\n\tt.Unlock()\n}\n\nfunc (t *tScreen) CharacterSet() string {\n\treturn t.charset\n}\n\nfunc (t *tScreen) RegisterRuneFallback(orig rune, fallback string) {\n\tt.Lock()\n\tt.fallback[orig] = fallback\n\tt.Unlock()\n}\n\nfunc (t *tScreen) UnregisterRuneFallback(orig rune) {\n\tt.Lock()\n\tdelete(t.fallback, orig)\n\tt.Unlock()\n}\n\nfunc (t *tScreen) CanDisplay(r rune, checkFallbacks bool) bool {\n\n\tif enc := t.encoder; enc != nil {\n\t\tnb := make([]byte, 6)\n\t\tob := make([]byte, 6)\n\t\tnum := utf8.EncodeRune(ob, r)\n\n\t\tenc.Reset()\n\t\tdst, _, err := enc.Transform(nb, ob[:num], true)\n\t\tif dst != 0 && err == nil && nb[0] != '\\x1A' {\n\t\t\treturn true\n\t\t}\n\t}\n\t// Terminal fallbacks always permitted, since we assume they are\n\t// basically nearly perfect renditions.\n\tif _, ok := t.acs[r]; ok {\n\t\treturn true\n\t}\n\tif !checkFallbacks {\n\t\treturn false\n\t}\n\tif _, ok := t.fallback[r]; ok {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (t *tScreen) HasMouse() bool {\n\treturn len(t.mouse) != 0\n}\n\nfunc (t *tScreen) HasKey(k Key) bool {\n\tif k == KeyRune {\n\t\treturn true\n\t}\n\treturn t.keyexist[k]\n}\n\nfunc (t *tScreen) SetSize(w, h int) {\n\tif t.setWinSize != \"\" {\n\t\tt.TPuts(t.ti.TParm(t.setWinSize, w, h))\n\t}\n\tt.cells.Invalidate()\n\tt.resize()\n}\n\nfunc (t *tScreen) Resize(int, int, int, int) {}\n\nfunc (t *tScreen) Suspend() error {\n\tt.disengage()\n\treturn nil\n}\n\nfunc (t *tScreen) Resume() error {\n\treturn t.engage()\n}\n\nfunc (t *tScreen) Tty() (Tty, bool) {\n\treturn t.tty, true\n}\n\n// engage is used to place the terminal in raw mode and establish screen size, etc.\n// Think of this is as tcell \"engaging\" the clutch, as it's going to be driving the\n// terminal interface.\nfunc (t *tScreen) engage() error {\n\tt.Lock()\n\tdefer t.Unlock()\n\tif t.tty == nil {\n\t\treturn ErrNoScreen\n\t}\n\tt.tty.NotifyResize(func() {\n\t\tselect {\n\t\tcase t.resizeQ <- true:\n\t\tdefault:\n\t\t}\n\t})\n\tif t.running {\n\t\treturn errors.New(\"already engaged\")\n\t}\n\tif err := t.tty.Start(); err != nil {\n\t\treturn err\n\t}\n\tt.running = true\n\tif ws, err := t.tty.WindowSize(); err == nil && ws.Width != 0 && ws.Height != 0 {\n\t\tt.cells.Resize(ws.Width, ws.Height)\n\t}\n\tstopQ := make(chan struct{})\n\tt.stopQ = stopQ\n\tt.enableMouse(t.mouseFlags)\n\tt.enablePasting(t.pasteEnabled)\n\tif t.focusEnabled {\n\t\tt.enableFocusReporting()\n\t}\n\n\tti := t.ti\n\tif os.Getenv(\"TCELL_ALTSCREEN\") != \"disable\" {\n\t\t// Technically this may not be right, but every terminal we know about\n\t\t// (even Wyse 60) uses this to enter the alternate screen buffer, and\n\t\t// possibly save and restore the window title and/or icon.\n\t\t// (In theory there could be terminals that don't support X,Y cursor\n\t\t// positions without a setup command, but we don't support them.)\n\t\tt.TPuts(ti.EnterCA)\n\t\tif t.saveTitle != \"\" {\n\t\t\tt.TPuts(t.saveTitle)\n\t\t}\n\t}\n\tt.TPuts(ti.EnterKeypad)\n\tt.TPuts(ti.HideCursor)\n\tt.TPuts(ti.EnableAcs)\n\tt.TPuts(ti.DisableAutoMargin)\n\tt.TPuts(ti.Clear)\n\tif t.title != \"\" && t.setTitle != \"\" {\n\t\tt.TPuts(t.ti.TParm(t.setTitle, t.title))\n\t}\n\n\tt.wg.Add(2)\n\tgo t.inputLoop(stopQ)\n\tgo t.mainLoop(stopQ)\n\treturn nil\n}\n\n// disengage is used to release the terminal back to support from the caller.\n// Think of this as tcell disengaging the clutch, so that another application\n// can take over the terminal interface.  This restores the TTY mode that was\n// present when the application was first started.\nfunc (t *tScreen) disengage() {\n\n\tt.Lock()\n\tif !t.running {\n\t\tt.Unlock()\n\t\treturn\n\t}\n\tt.running = false\n\tstopQ := t.stopQ\n\tclose(stopQ)\n\t_ = t.tty.Drain()\n\tt.Unlock()\n\n\tt.tty.NotifyResize(nil)\n\t// wait for everything to shut down\n\tt.wg.Wait()\n\n\t// shutdown the screen and disable special modes (e.g. mouse and bracketed paste)\n\tti := t.ti\n\tt.cells.Resize(0, 0)\n\tt.TPuts(ti.ShowCursor)\n\tif t.cursorStyles != nil && t.cursorStyle != CursorStyleDefault {\n\t\tt.TPuts(t.cursorStyles[CursorStyleDefault])\n\t}\n\tif t.cursorFg != \"\" && t.cursorColor.Valid() {\n\t\tt.TPuts(t.cursorFg)\n\t}\n\tt.TPuts(ti.ResetFgBg)\n\tt.TPuts(ti.AttrOff)\n\tt.TPuts(ti.ExitKeypad)\n\tt.TPuts(ti.EnableAutoMargin)\n\tif os.Getenv(\"TCELL_ALTSCREEN\") != \"disable\" {\n\t\tif t.restoreTitle != \"\" {\n\t\t\tt.TPuts(t.restoreTitle)\n\t\t}\n\t\tt.TPuts(ti.Clear) // only needed if ExitCA is empty\n\t\tt.TPuts(ti.ExitCA)\n\t}\n\tt.enableMouse(0)\n\tt.enablePasting(false)\n\tt.disableFocusReporting()\n\n\t_ = t.tty.Stop()\n}\n\n// Beep emits a beep to the terminal.\nfunc (t *tScreen) Beep() error {\n\tt.writeString(string(byte(7)))\n\treturn nil\n}\n\n// finalize is used to at application shutdown, and restores the terminal\n// to it's initial state.  It should not be called more than once.\nfunc (t *tScreen) finalize() {\n\tt.disengage()\n\t_ = t.tty.Close()\n}\n\nfunc (t *tScreen) StopQ() <-chan struct{} {\n\treturn t.quit\n}\n\nfunc (t *tScreen) EventQ() chan Event {\n\treturn t.eventQ\n}\n\nfunc (t *tScreen) GetCells() *CellBuffer {\n\treturn &t.cells\n}\n\nfunc (t *tScreen) SetTitle(title string) {\n\tt.Lock()\n\tt.title = title\n\tif t.setTitle != \"\" && t.running {\n\t\tt.TPuts(t.ti.TParm(t.setTitle, title))\n\t}\n\tt.Unlock()\n}\n\nfunc (t *tScreen) SetClipboard(data []byte) {\n\t// Post binary data to the system clipboard.  It might be UTF-8, it might not be.\n\tt.Lock()\n\tif t.setClipboard != \"\" {\n\t\tencoded := base64.StdEncoding.EncodeToString(data)\n\t\tt.TPuts(t.ti.TParm(t.setClipboard, encoded))\n\t}\n\tt.Unlock()\n}\n\nfunc (t *tScreen) GetClipboard() {\n\tt.Lock()\n\tif t.setClipboard != \"\" {\n\t\tt.TPuts(t.ti.TParm(t.setClipboard, \"?\"))\n\t}\n\tt.Unlock()\n}\n"
        },
        {
          "name": "tscreen_stub.go",
          "type": "blob",
          "size": 1.083984375,
          "content": "//go:build plan9 || windows\n// +build plan9 windows\n\n// Copyright 2022 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\n// NB: We might someday wish to move Windows to this model.   However,\n// that would probably mean sacrificing some of the richer key reporting\n// that we can obtain with the console API present on Windows.\n\nfunc (t *tScreen) initialize() error {\n\tif t.tty == nil {\n\t\treturn ErrNoScreen\n\t}\n\t// If a tty was supplied (custom), it should work.\n\t// Custom screen implementations will need to provide a TTY\n\t// implementation that we can use.\n\treturn nil\n}\n"
        },
        {
          "name": "tscreen_unix.go",
          "type": "blob",
          "size": 1.2060546875,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris || zos\n// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris zos\n\npackage tcell\n\nimport (\n\t// import the stock terminals\n\t_ \"github.com/gdamore/tcell/v2/terminfo/base\"\n)\n\n// initialize is used at application startup, and sets up the initial values\n// including file descriptors used for terminals and saving the initial state\n// so that it can be restored when the application terminates.\nfunc (t *tScreen) initialize() error {\n\tvar err error\n\tif t.tty == nil {\n\t\tt.tty, err = NewDevTty()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "tty.go",
          "type": "blob",
          "size": 2.76953125,
          "content": "// Copyright 2021 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage tcell\n\nimport \"io\"\n\n// Tty is an abstraction of a tty (traditionally \"teletype\").  This allows applications to\n// provide for alternate backends, as there are situations where the traditional /dev/tty\n// does not work, or where more flexible handling is required.  This interface is for use\n// with the terminfo-style based API.  It extends the io.ReadWriter API.  It is reasonable\n// that the implementation might choose to use different underlying files for the Reader\n// and Writer sides of this API, as part of it's internal implementation.\ntype Tty interface {\n\t// Start is used to activate the Tty for use.  Upon return the terminal should be\n\t// in raw mode, non-blocking, etc.  The implementation should take care of saving\n\t// any state that is required so that it may be restored when Stop is called.\n\tStart() error\n\n\t// Stop is used to stop using this Tty instance.  This may be a suspend, so that other\n\t// terminal based applications can run in the foreground.  Implementations should\n\t// restore any state collected at Start(), and return to ordinary blocking mode, etc.\n\t// Drain is called first to drain the input.  Once this is called, no more Read\n\t// or Write calls will be made until Start is called again.\n\tStop() error\n\n\t// Drain is called before Stop, and ensures that the reader will wake up appropriately\n\t// if it was blocked.  This workaround is required for /dev/tty on certain UNIX systems\n\t// to ensure that Read() does not block forever.  This typically arranges for the tty driver\n\t// to send data immediately (e.g. VMIN and VTIME both set zero) and sets a deadline on input.\n\t// Implementations may reasonably make this a no-op.  There will still be control sequences\n\t// emitted between the time this is called, and when Stop is called.\n\tDrain() error\n\n\t// NotifyResize is used register a callback when the tty thinks the dimensions have\n\t// changed.  The standard UNIX implementation links this to a handler for SIGWINCH.\n\t// If the supplied callback is nil, then any handler should be unregistered.\n\tNotifyResize(cb func())\n\n\t// WindowSize is called to determine the terminal dimensions.  This might be determined\n\t// by an ioctl or other means.\n\tWindowSize() (WindowSize, error)\n\n\tio.ReadWriteCloser\n}\n"
        },
        {
          "name": "tty_unix.go",
          "type": "blob",
          "size": 4.61328125,
          "content": "// Copyright 2021 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris || zos\n// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris zos\n\npackage tcell\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strconv\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n\t\"golang.org/x/term\"\n)\n\n// devTty is an implementation of the Tty API based upon /dev/tty.\ntype devTty struct {\n\tfd    int\n\tf     *os.File\n\tof    *os.File // the first open of /dev/tty\n\tsaved *term.State\n\tsig   chan os.Signal\n\tcb    func()\n\tstopQ chan struct{}\n\tdev   string\n\twg    sync.WaitGroup\n\tl     sync.Mutex\n}\n\nfunc (tty *devTty) Read(b []byte) (int, error) {\n\treturn tty.f.Read(b)\n}\n\nfunc (tty *devTty) Write(b []byte) (int, error) {\n\treturn tty.f.Write(b)\n}\n\nfunc (tty *devTty) Close() error {\n\treturn tty.f.Close()\n}\n\nfunc (tty *devTty) Start() error {\n\ttty.l.Lock()\n\tdefer tty.l.Unlock()\n\n\t// We open another copy of /dev/tty.  This is a workaround for unusual behavior\n\t// observed in macOS, apparently caused when a subshell (for example) closes our\n\t// own tty device (when it exits for example).  Getting a fresh new one seems to\n\t// resolve the problem.  (We believe this is a bug in the macOS tty driver that\n\t// fails to account for dup() references to the same file before applying close()\n\t// related behaviors to the tty.)  We're also holding the original copy we opened\n\t// since closing that might have deleterious effects as well.  The upshot is that\n\t// we will have up to two separate file handles open on /dev/tty.  (Note that when\n\t// using stdin/stdout instead of /dev/tty this problem is not observed.)\n\tvar err error\n\tif tty.f, err = os.OpenFile(tty.dev, os.O_RDWR, 0); err != nil {\n\t\treturn err\n\t}\n\n\tif !term.IsTerminal(tty.fd) {\n\t\treturn errors.New(\"device is not a terminal\")\n\t}\n\n\t_ = tty.f.SetReadDeadline(time.Time{})\n\tsaved, err := term.MakeRaw(tty.fd) // also sets vMin and vTime\n\tif err != nil {\n\t\treturn err\n\t}\n\ttty.saved = saved\n\n\ttty.stopQ = make(chan struct{})\n\ttty.wg.Add(1)\n\tgo func(stopQ chan struct{}) {\n\t\tdefer tty.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-tty.sig:\n\t\t\t\ttty.l.Lock()\n\t\t\t\tcb := tty.cb\n\t\t\t\ttty.l.Unlock()\n\t\t\t\tif cb != nil {\n\t\t\t\t\tcb()\n\t\t\t\t}\n\t\t\tcase <-stopQ:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}(tty.stopQ)\n\n\tsignal.Notify(tty.sig, syscall.SIGWINCH)\n\treturn nil\n}\n\nfunc (tty *devTty) Drain() error {\n\t_ = tty.f.SetReadDeadline(time.Now())\n\tif err := tcSetBufParams(tty.fd, 0, 0); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (tty *devTty) Stop() error {\n\ttty.l.Lock()\n\tif err := term.Restore(tty.fd, tty.saved); err != nil {\n\t\ttty.l.Unlock()\n\t\treturn err\n\t}\n\t_ = tty.f.SetReadDeadline(time.Now())\n\n\tsignal.Stop(tty.sig)\n\tclose(tty.stopQ)\n\ttty.l.Unlock()\n\n\ttty.wg.Wait()\n\n\t// close our tty device -- we'll get another one if we Start again later.\n\t_ = tty.f.Close()\n\n\treturn nil\n}\n\nfunc (tty *devTty) WindowSize() (WindowSize, error) {\n\tsize := WindowSize{}\n\tws, err := unix.IoctlGetWinsize(tty.fd, unix.TIOCGWINSZ)\n\tif err != nil {\n\t\treturn size, err\n\t}\n\tw := int(ws.Col)\n\th := int(ws.Row)\n\tif w == 0 {\n\t\tw, _ = strconv.Atoi(os.Getenv(\"COLUMNS\"))\n\t}\n\tif w == 0 {\n\t\tw = 80 // default\n\t}\n\tif h == 0 {\n\t\th, _ = strconv.Atoi(os.Getenv(\"LINES\"))\n\t}\n\tif h == 0 {\n\t\th = 25 // default\n\t}\n\tsize.Width = w\n\tsize.Height = h\n\tsize.PixelWidth = int(ws.Xpixel)\n\tsize.PixelHeight = int(ws.Ypixel)\n\treturn size, nil\n}\n\nfunc (tty *devTty) NotifyResize(cb func()) {\n\ttty.l.Lock()\n\ttty.cb = cb\n\ttty.l.Unlock()\n}\n\n// NewDevTty opens a /dev/tty based Tty.\nfunc NewDevTty() (Tty, error) {\n\treturn NewDevTtyFromDev(\"/dev/tty\")\n}\n\n// NewDevTtyFromDev opens a tty device given a path.  This can be useful to bind to other nodes.\nfunc NewDevTtyFromDev(dev string) (Tty, error) {\n\ttty := &devTty{\n\t\tdev: dev,\n\t\tsig: make(chan os.Signal),\n\t}\n\tvar err error\n\tif tty.of, err = os.OpenFile(dev, os.O_RDWR, 0); err != nil {\n\t\treturn nil, err\n\t}\n\ttty.fd = int(tty.of.Fd())\n\tif !term.IsTerminal(tty.fd) {\n\t\t_ = tty.f.Close()\n\t\treturn nil, errors.New(\"not a terminal\")\n\t}\n\tif tty.saved, err = term.GetState(tty.fd); err != nil {\n\t\t_ = tty.f.Close()\n\t\treturn nil, fmt.Errorf(\"failed to get state: %w\", err)\n\t}\n\treturn tty, nil\n}\n"
        },
        {
          "name": "views",
          "type": "tree",
          "content": null
        },
        {
          "name": "webfiles",
          "type": "tree",
          "content": null
        },
        {
          "name": "wscreen.go",
          "type": "blob",
          "size": 15.2060546875,
          "content": "// Copyright 2024 The TCell Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use file except in compliance with the License.\n// You may obtain a copy of the license at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build js && wasm\n// +build js,wasm\n\npackage tcell\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall/js\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gdamore/tcell/v2/terminfo\"\n)\n\nfunc NewTerminfoScreen() (Screen, error) {\n\tt := &wScreen{}\n\tt.fallback = make(map[rune]string)\n\n\treturn &baseScreen{screenImpl: t}, nil\n}\n\ntype wScreen struct {\n\tw, h  int\n\tstyle Style\n\tcells CellBuffer\n\n\trunning      bool\n\tclear        bool\n\tflagsPresent bool\n\tpasteEnabled bool\n\tmouseFlags   MouseFlags\n\n\tcursorStyle CursorStyle\n\n\tquit     chan struct{}\n\tevch     chan Event\n\tfallback map[rune]string\n\tfiniOnce sync.Once\n\n\tsync.Mutex\n}\n\nfunc (t *wScreen) Init() error {\n\tt.w, t.h = 80, 24 // default for html as of now\n\tt.evch = make(chan Event, 10)\n\tt.quit = make(chan struct{})\n\n\tt.Lock()\n\tt.running = true\n\tt.style = StyleDefault\n\tt.cells.Resize(t.w, t.h)\n\tt.Unlock()\n\n\tjs.Global().Set(\"onKeyEvent\", js.FuncOf(t.onKeyEvent))\n\tjs.Global().Set(\"onMouseClick\", js.FuncOf(t.unset))\n\tjs.Global().Set(\"onMouseMove\", js.FuncOf(t.unset))\n\tjs.Global().Set(\"onFocus\", js.FuncOf(t.unset))\n\n\treturn nil\n}\n\nfunc (t *wScreen) Fini() {\n\tt.finiOnce.Do(func() {\n\t\tclose(t.quit)\n\t})\n}\n\nfunc (t *wScreen) SetStyle(style Style) {\n\tt.Lock()\n\tt.style = style\n\tt.Unlock()\n}\n\n// paletteColor gives a more natural palette color actually matching\n// typical XTerm.  We might in the future want to permit styling these\n// via CSS.\n\nvar palette = map[Color]int32{\n\tColorBlack:   0x000000,\n\tColorMaroon:  0xcd0000,\n\tColorGreen:   0x00cd00,\n\tColorOlive:   0xcdcd00,\n\tColorNavy:    0x0000ee,\n\tColorPurple:  0xcd00cd,\n\tColorTeal:    0x00cdcd,\n\tColorSilver:  0xe5e5e5,\n\tColorGray:    0x7f7f7f,\n\tColorRed:     0xff0000,\n\tColorLime:    0x00ff00,\n\tColorYellow:  0xffff00,\n\tColorBlue:    0x5c5cff,\n\tColorFuchsia: 0xff00ff,\n\tColorAqua:    0x00ffff,\n\tColorWhite:   0xffffff,\n}\n\nfunc paletteColor(c Color) int32 {\n\tif c.IsRGB() {\n\t\treturn int32(c & 0xffffff)\n\t}\n\tif c >= ColorBlack && c <= ColorWhite {\n\t\treturn palette[c]\n\t}\n\treturn c.Hex()\n}\n\nfunc (t *wScreen) drawCell(x, y int) int {\n\tmainc, combc, style, width := t.cells.GetContent(x, y)\n\n\tif !t.cells.Dirty(x, y) {\n\t\treturn width\n\t}\n\n\tif style == StyleDefault {\n\t\tstyle = t.style\n\t}\n\n\tfg, bg := paletteColor(style.fg), paletteColor(style.bg)\n\tif fg == -1 {\n\t\tfg = 0xe5e5e5\n\t}\n\tif bg == -1 {\n\t\tbg = 0x000000\n\t}\n\tus, uc := style.ulStyle, paletteColor(style.ulColor)\n\tif uc == -1 {\n\t\tuc = 0x000000\n\t}\n\n\ts := \"\"\n\tif len(combc) > 0 {\n\t\tb := make([]rune, 0, 1 + len(combc))\n\t\tb = append(b, mainc)\n\t\tb = append(b, combc...)\n\t\ts = string(b)\n\t} else {\n\t\ts = string(mainc)\n\t}\n\n\tt.cells.SetDirty(x, y, false)\n\tjs.Global().Call(\"drawCell\", x, y, s, fg, bg, int(style.attrs), int(us), int(uc))\n\n\treturn width\n}\n\nfunc (t *wScreen) ShowCursor(x, y int) {\n\tt.Lock()\n\tjs.Global().Call(\"showCursor\", x, y)\n\tt.Unlock()\n}\n\nfunc (t *wScreen) SetCursor(cs CursorStyle, cc Color) {\n\tif !cc.Valid() {\n\t\tcc = ColorLightGray\n\t}\n\tt.Lock()\n\tjs.Global().Call(\"setCursorStyle\", curStyleClasses[cs], fmt.Sprintf(\"#%06x\", cc.Hex()))\n\tt.Unlock()\n}\n\nfunc (t *wScreen) HideCursor() {\n\tt.ShowCursor(-1, -1)\n}\n\nfunc (t *wScreen) Show() {\n\tt.Lock()\n\tt.resize()\n\tt.draw()\n\tt.Unlock()\n}\n\nfunc (t *wScreen) clearScreen() {\n\tjs.Global().Call(\"clearScreen\", t.style.fg.Hex(), t.style.bg.Hex())\n\tt.clear = false\n}\n\nfunc (t *wScreen) draw() {\n\tif t.clear {\n\t\tt.clearScreen()\n\t}\n\n\tfor y := 0; y < t.h; y++ {\n\t\tfor x := 0; x < t.w; x++ {\n\t\t\twidth := t.drawCell(x, y)\n\t\t\tx += width - 1\n\t\t}\n\t}\n\n\tjs.Global().Call(\"show\")\n}\n\nfunc (t *wScreen) EnableMouse(flags ...MouseFlags) {\n\tvar f MouseFlags\n\tflagsPresent := false\n\tfor _, flag := range flags {\n\t\tf |= flag\n\t\tflagsPresent = true\n\t}\n\tif !flagsPresent {\n\t\tf = MouseMotionEvents | MouseDragEvents | MouseButtonEvents\n\t}\n\n\tt.Lock()\n\tt.mouseFlags = f\n\tt.enableMouse(f)\n\tt.Unlock()\n}\n\nfunc (t *wScreen) enableMouse(f MouseFlags) {\n\tif f&MouseButtonEvents != 0 {\n\t\tjs.Global().Set(\"onMouseClick\", js.FuncOf(t.onMouseEvent))\n\t} else {\n\t\tjs.Global().Set(\"onMouseClick\", js.FuncOf(t.unset))\n\t}\n\n\tif f&MouseDragEvents != 0 || f&MouseMotionEvents != 0 {\n\t\tjs.Global().Set(\"onMouseMove\", js.FuncOf(t.onMouseEvent))\n\t} else {\n\t\tjs.Global().Set(\"onMouseMove\", js.FuncOf(t.unset))\n\t}\n}\n\nfunc (t *wScreen) DisableMouse() {\n\tt.Lock()\n\tt.mouseFlags = 0\n\tt.enableMouse(0)\n\tt.Unlock()\n}\n\nfunc (t *wScreen) EnablePaste() {\n\tt.Lock()\n\tt.pasteEnabled = true\n\tt.enablePasting(true)\n\tt.Unlock()\n}\n\nfunc (t *wScreen) DisablePaste() {\n\tt.Lock()\n\tt.pasteEnabled = false\n\tt.enablePasting(false)\n\tt.Unlock()\n}\n\nfunc (t *wScreen) enablePasting(on bool) {\n\tif on {\n\t\tjs.Global().Set(\"onPaste\", js.FuncOf(t.onPaste))\n\t} else {\n\t\tjs.Global().Set(\"onPaste\", js.FuncOf(t.unset))\n\t}\n}\n\nfunc (t *wScreen) EnableFocus() {\n\tt.Lock()\n\tjs.Global().Set(\"onFocus\", js.FuncOf(t.onFocus))\n\tt.Unlock()\n}\n\nfunc (t *wScreen) DisableFocus() {\n\tt.Lock()\n\tjs.Global().Set(\"onFocus\", js.FuncOf(t.unset))\n\tt.Unlock()\n}\n\nfunc (t *wScreen) Size() (int, int) {\n\tt.Lock()\n\tw, h := t.w, t.h\n\tt.Unlock()\n\treturn w, h\n}\n\n// resize does nothing, as asking the web window to resize\n// without a specified width or height will cause no change.\nfunc (t *wScreen) resize() {}\n\nfunc (t *wScreen) Colors() int {\n\treturn 16777216 // 256 ^ 3\n}\n\nfunc (t *wScreen) clip(x, y int) (int, int) {\n\tw, h := t.cells.Size()\n\tif x < 0 {\n\t\tx = 0\n\t}\n\tif y < 0 {\n\t\ty = 0\n\t}\n\tif x > w-1 {\n\t\tx = w - 1\n\t}\n\tif y > h-1 {\n\t\ty = h - 1\n\t}\n\treturn x, y\n}\n\nfunc (t *wScreen) postEvent(ev Event) {\n\tselect {\n\tcase t.evch <- ev:\n\tcase <-t.quit:\n\t}\n}\n\nfunc (t *wScreen) onMouseEvent(this js.Value, args []js.Value) interface{} {\n\tmod := ModNone\n\tbutton := ButtonNone\n\n\tswitch args[2].Int() {\n\tcase 0:\n\t\tif t.mouseFlags&MouseMotionEvents == 0 {\n\t\t\t// don't want this event! is a mouse motion event, but user has asked not.\n\t\t\treturn nil\n\t\t}\n\t\tbutton = ButtonNone\n\tcase 1:\n\t\tbutton = Button1\n\tcase 2:\n\t\tbutton = Button3 // Note we prefer to treat right as button 2\n\tcase 3:\n\t\tbutton = Button2 // And the middle button as button 3\n\t}\n\n\tif args[3].Bool() { // mod shift\n\t\tmod |= ModShift\n\t}\n\n\tif args[4].Bool() { // mod alt\n\t\tmod |= ModAlt\n\t}\n\n\tif args[5].Bool() { // mod ctrl\n\t\tmod |= ModCtrl\n\t}\n\n\tt.postEvent(NewEventMouse(args[0].Int(), args[1].Int(), button, mod))\n\treturn nil\n}\n\nfunc (t *wScreen) onKeyEvent(this js.Value, args []js.Value) interface{} {\n\tkey := args[0].String()\n\n\t// don't accept any modifier keys as their own\n\tif key == \"Control\" || key == \"Alt\" || key == \"Meta\" || key == \"Shift\" {\n\t\treturn nil\n\t}\n\n\tmod := ModNone\n\tif args[1].Bool() { // mod shift\n\t\tmod |= ModShift\n\t}\n\n\tif args[2].Bool() { // mod alt\n\t\tmod |= ModAlt\n\t}\n\n\tif args[3].Bool() { // mod ctrl\n\t\tmod |= ModCtrl\n\t}\n\n\tif args[4].Bool() { // mod meta\n\t\tmod |= ModMeta\n\t}\n\n\t// check for special case of Ctrl + key\n\tif mod == ModCtrl {\n\t\tif k, ok := WebKeyNames[\"Ctrl-\"+strings.ToLower(key)]; ok {\n\t\t\tt.postEvent(NewEventKey(k, 0, mod))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// next try function keys\n\tif k, ok := WebKeyNames[key]; ok {\n\t\tt.postEvent(NewEventKey(k, 0, mod))\n\t\treturn nil\n\t}\n\n\t// finally try normal, printable chars\n\tr, _ := utf8.DecodeRuneInString(key)\n\tt.postEvent(NewEventKey(KeyRune, r, mod))\n\treturn nil\n}\n\nfunc (t *wScreen) onPaste(this js.Value, args []js.Value) interface{} {\n\tt.postEvent(NewEventPaste(args[0].Bool()))\n\treturn nil\n}\n\nfunc (t *wScreen) onFocus(this js.Value, args []js.Value) interface{} {\n\tt.postEvent(NewEventFocus(args[0].Bool()))\n\treturn nil\n}\n\n// unset is a dummy function for js when we want nothing to\n// happen when javascript calls a function (for example, when\n// mouse input is disabled, when onMouseEvent() is called from\n// js, it redirects here and does nothing).\nfunc (t *wScreen) unset(this js.Value, args []js.Value) interface{} {\n\treturn nil\n}\n\nfunc (t *wScreen) Sync() {\n\tt.Lock()\n\tt.resize()\n\tt.clear = true\n\tt.cells.Invalidate()\n\tt.draw()\n\tt.Unlock()\n}\n\nfunc (t *wScreen) CharacterSet() string {\n\treturn \"UTF-8\"\n}\n\nfunc (t *wScreen) RegisterRuneFallback(orig rune, fallback string) {\n\tt.Lock()\n\tt.fallback[orig] = fallback\n\tt.Unlock()\n}\n\nfunc (t *wScreen) UnregisterRuneFallback(orig rune) {\n\tt.Lock()\n\tdelete(t.fallback, orig)\n\tt.Unlock()\n}\n\nfunc (t *wScreen) CanDisplay(r rune, checkFallbacks bool) bool {\n\tif utf8.ValidRune(r) {\n\t\treturn true\n\t}\n\tif !checkFallbacks {\n\t\treturn false\n\t}\n\tif _, ok := t.fallback[r]; ok {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (t *wScreen) HasMouse() bool {\n\treturn true\n}\n\nfunc (t *wScreen) HasKey(k Key) bool {\n\treturn true\n}\n\nfunc (t *wScreen) SetSize(w, h int) {\n\tif w == t.w && h == t.h {\n\t\treturn\n\t}\n\n\tt.cells.Invalidate()\n\tt.cells.Resize(w, h)\n\tjs.Global().Call(\"resize\", w, h)\n\tt.w, t.h = w, h\n\tt.postEvent(NewEventResize(w, h))\n}\n\nfunc (t *wScreen) Resize(int, int, int, int) {}\n\n// Suspend simply pauses all input and output, and clears the screen.\n// There isn't a \"default terminal\" to go back to.\nfunc (t *wScreen) Suspend() error {\n\tt.Lock()\n\tif !t.running {\n\t\tt.Unlock()\n\t\treturn nil\n\t}\n\tt.running = false\n\tt.clearScreen()\n\tt.enableMouse(0)\n\tt.enablePasting(false)\n\tjs.Global().Set(\"onKeyEvent\", js.FuncOf(t.unset)) // stop keypresses\n\treturn nil\n}\n\nfunc (t *wScreen) Resume() error {\n\tt.Lock()\n\n\tif t.running {\n\t\treturn errors.New(\"already engaged\")\n\t}\n\tt.running = true\n\n\tt.enableMouse(t.mouseFlags)\n\tt.enablePasting(t.pasteEnabled)\n\n\tjs.Global().Set(\"onKeyEvent\", js.FuncOf(t.onKeyEvent))\n\n\tt.Unlock()\n\treturn nil\n}\n\nfunc (t *wScreen) Beep() error {\n\tjs.Global().Call(\"beep\")\n\treturn nil\n}\n\nfunc (t *wScreen) Tty() (Tty, bool) {\n\treturn nil, false\n}\n\nfunc (t *wScreen) GetCells() *CellBuffer {\n\treturn &t.cells\n}\n\nfunc (t *wScreen) EventQ() chan Event {\n\treturn t.evch\n}\n\nfunc (t *wScreen) StopQ() <-chan struct{} {\n\treturn t.quit\n}\n\nfunc (t *wScreen) SetTitle(title string) {\n\tjs.Global().Call(\"setTitle\", title)\n}\n\n// WebKeyNames maps string names reported from HTML\n// (KeyboardEvent.key) to tcell accepted keys.\nvar WebKeyNames = map[string]Key{\n\t\"Enter\":      KeyEnter,\n\t\"Backspace\":  KeyBackspace,\n\t\"Tab\":        KeyTab,\n\t\"Backtab\":    KeyBacktab,\n\t\"Escape\":     KeyEsc,\n\t\"Backspace2\": KeyBackspace2,\n\t\"Delete\":     KeyDelete,\n\t\"Insert\":     KeyInsert,\n\t\"ArrowUp\":    KeyUp,\n\t\"ArrowDown\":  KeyDown,\n\t\"ArrowLeft\":  KeyLeft,\n\t\"ArrowRight\": KeyRight,\n\t\"Home\":       KeyHome,\n\t\"End\":        KeyEnd,\n\t\"UpLeft\":     KeyUpLeft,    // not supported by HTML\n\t\"UpRight\":    KeyUpRight,   // not supported by HTML\n\t\"DownLeft\":   KeyDownLeft,  // not supported by HTML\n\t\"DownRight\":  KeyDownRight, // not supported by HTML\n\t\"Center\":     KeyCenter,\n\t\"PgDn\":       KeyPgDn,\n\t\"PgUp\":       KeyPgUp,\n\t\"Clear\":      KeyClear,\n\t\"Exit\":       KeyExit,\n\t\"Cancel\":     KeyCancel,\n\t\"Pause\":      KeyPause,\n\t\"Print\":      KeyPrint,\n\t\"F1\":         KeyF1,\n\t\"F2\":         KeyF2,\n\t\"F3\":         KeyF3,\n\t\"F4\":         KeyF4,\n\t\"F5\":         KeyF5,\n\t\"F6\":         KeyF6,\n\t\"F7\":         KeyF7,\n\t\"F8\":         KeyF8,\n\t\"F9\":         KeyF9,\n\t\"F10\":        KeyF10,\n\t\"F11\":        KeyF11,\n\t\"F12\":        KeyF12,\n\t\"F13\":        KeyF13,\n\t\"F14\":        KeyF14,\n\t\"F15\":        KeyF15,\n\t\"F16\":        KeyF16,\n\t\"F17\":        KeyF17,\n\t\"F18\":        KeyF18,\n\t\"F19\":        KeyF19,\n\t\"F20\":        KeyF20,\n\t\"F21\":        KeyF21,\n\t\"F22\":        KeyF22,\n\t\"F23\":        KeyF23,\n\t\"F24\":        KeyF24,\n\t\"F25\":        KeyF25,\n\t\"F26\":        KeyF26,\n\t\"F27\":        KeyF27,\n\t\"F28\":        KeyF28,\n\t\"F29\":        KeyF29,\n\t\"F30\":        KeyF30,\n\t\"F31\":        KeyF31,\n\t\"F32\":        KeyF32,\n\t\"F33\":        KeyF33,\n\t\"F34\":        KeyF34,\n\t\"F35\":        KeyF35,\n\t\"F36\":        KeyF36,\n\t\"F37\":        KeyF37,\n\t\"F38\":        KeyF38,\n\t\"F39\":        KeyF39,\n\t\"F40\":        KeyF40,\n\t\"F41\":        KeyF41,\n\t\"F42\":        KeyF42,\n\t\"F43\":        KeyF43,\n\t\"F44\":        KeyF44,\n\t\"F45\":        KeyF45,\n\t\"F46\":        KeyF46,\n\t\"F47\":        KeyF47,\n\t\"F48\":        KeyF48,\n\t\"F49\":        KeyF49,\n\t\"F50\":        KeyF50,\n\t\"F51\":        KeyF51,\n\t\"F52\":        KeyF52,\n\t\"F53\":        KeyF53,\n\t\"F54\":        KeyF54,\n\t\"F55\":        KeyF55,\n\t\"F56\":        KeyF56,\n\t\"F57\":        KeyF57,\n\t\"F58\":        KeyF58,\n\t\"F59\":        KeyF59,\n\t\"F60\":        KeyF60,\n\t\"F61\":        KeyF61,\n\t\"F62\":        KeyF62,\n\t\"F63\":        KeyF63,\n\t\"F64\":        KeyF64,\n\t\"Ctrl-a\":     KeyCtrlA,          // not reported by HTML- need to do special check\n\t\"Ctrl-b\":     KeyCtrlB,          // not reported by HTML- need to do special check\n\t\"Ctrl-c\":     KeyCtrlC,          // not reported by HTML- need to do special check\n\t\"Ctrl-d\":     KeyCtrlD,          // not reported by HTML- need to do special check\n\t\"Ctrl-e\":     KeyCtrlE,          // not reported by HTML- need to do special check\n\t\"Ctrl-f\":     KeyCtrlF,          // not reported by HTML- need to do special check\n\t\"Ctrl-g\":     KeyCtrlG,          // not reported by HTML- need to do special check\n\t\"Ctrl-j\":     KeyCtrlJ,          // not reported by HTML- need to do special check\n\t\"Ctrl-k\":     KeyCtrlK,          // not reported by HTML- need to do special check\n\t\"Ctrl-l\":     KeyCtrlL,          // not reported by HTML- need to do special check\n\t\"Ctrl-n\":     KeyCtrlN,          // not reported by HTML- need to do special check\n\t\"Ctrl-o\":     KeyCtrlO,          // not reported by HTML- need to do special check\n\t\"Ctrl-p\":     KeyCtrlP,          // not reported by HTML- need to do special check\n\t\"Ctrl-q\":     KeyCtrlQ,          // not reported by HTML- need to do special check\n\t\"Ctrl-r\":     KeyCtrlR,          // not reported by HTML- need to do special check\n\t\"Ctrl-s\":     KeyCtrlS,          // not reported by HTML- need to do special check\n\t\"Ctrl-t\":     KeyCtrlT,          // not reported by HTML- need to do special check\n\t\"Ctrl-u\":     KeyCtrlU,          // not reported by HTML- need to do special check\n\t\"Ctrl-v\":     KeyCtrlV,          // not reported by HTML- need to do special check\n\t\"Ctrl-w\":     KeyCtrlW,          // not reported by HTML- need to do special check\n\t\"Ctrl-x\":     KeyCtrlX,          // not reported by HTML- need to do special check\n\t\"Ctrl-y\":     KeyCtrlY,          // not reported by HTML- need to do special check\n\t\"Ctrl-z\":     KeyCtrlZ,          // not reported by HTML- need to do special check\n\t\"Ctrl- \":     KeyCtrlSpace,      // not reported by HTML- need to do special check\n\t\"Ctrl-_\":     KeyCtrlUnderscore, // not reported by HTML- need to do special check\n\t\"Ctrl-]\":     KeyCtrlRightSq,    // not reported by HTML- need to do special check\n\t\"Ctrl-\\\\\":    KeyCtrlBackslash,  // not reported by HTML- need to do special check\n\t\"Ctrl-^\":     KeyCtrlCarat,      // not reported by HTML- need to do special check\n}\n\nvar curStyleClasses = map[CursorStyle]string{\n\tCursorStyleDefault:           \"cursor-blinking-block\",\n\tCursorStyleBlinkingBlock:     \"cursor-blinking-block\",\n\tCursorStyleSteadyBlock:       \"cursor-steady-block\",\n\tCursorStyleBlinkingUnderline: \"cursor-blinking-underline\",\n\tCursorStyleSteadyUnderline:   \"cursor-steady-underline\",\n\tCursorStyleBlinkingBar:       \"cursor-blinking-bar\",\n\tCursorStyleSteadyBar:         \"cursor-steady-bar\",\n}\n\nfunc LookupTerminfo(name string) (ti *terminfo.Terminfo, e error) {\n\treturn nil, errors.New(\"LookupTermInfo not supported\")\n}\n"
        }
      ]
    }
  ]
}