{
  "metadata": {
    "timestamp": 1736566474157,
    "page": 21,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "asticode/go-astilectron",
      "stars": 4898,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0625,
          "content": ".DS_Store\nThumbs.db\n.idea/\ncover*\nexample/vendor\ntestdata/tmp/*\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017 Quentin RENARD\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.1435546875,
          "content": "[![GoReportCard](http://goreportcard.com/badge/github.com/asticode/go-astilectron)](http://goreportcard.com/report/github.com/asticode/go-astilectron)\n[![GoDoc](https://godoc.org/github.com/asticode/go-astilectron?status.svg)](https://godoc.org/github.com/asticode/go-astilectron)\n[![Test](https://github.com/asticode/go-astilectron/actions/workflows/test.yml/badge.svg)](https://github.com/asticode/go-astilectron/actions/workflows/test.yml)\n[![Coveralls](https://coveralls.io/repos/github/asticode/go-astilectron/badge.svg?branch=master)](https://coveralls.io/github/asticode/go-astilectron)\n\nThanks to `go-astilectron` build cross platform GUI apps with GO and HTML/JS/CSS. It is the official GO bindings of [astilectron](https://github.com/asticode/astilectron) and is powered by [Electron](https://github.com/electron/electron).\n\n# Warning\n\nThis project is not maintained anymore.\n\n# Demo\n\nTo see a minimal Astilectron app, checkout out the [demo](https://github.com/asticode/go-astilectron-demo).\n\nIt uses the [bootstrap](https://github.com/asticode/go-astilectron-bootstrap) and the [bundler](https://github.com/asticode/go-astilectron-bundler).\n\nIf you're looking for a minimalistic example, run `go run example/main.go -v`.\n\n# Real-life examples\n\nHere's a list of awesome projects using `go-astilectron` (if you're using `go-astilectron` and want your project to be listed here please submit a PR):\n\n- [go-astivid](https://github.com/asticode/go-astivid) Video tools written in GO\n- [GroupMatcher](https://github.com/veecue/GroupMatcher) Program to allocate persons to groups while trying to fulfill all the given wishes as good as possible\n- [Stellite GUI Miner](https://github.com/stellitecoin/GUI-miner) An easy to use GUI cryptocurrency miner for Stellite\n\n# Bootstrap\n\nFor convenience purposes, a [bootstrap](https://github.com/asticode/go-astilectron-bootstrap) has been implemented.\n\nThe bootstrap allows you to quickly create a one-window application.\n\nThere's no obligation to use it, but it's strongly recommended.\n\nIf you decide to use it, read thoroughly the documentation as you'll have to structure your project in a specific way.\n\n# Bundler\n\nStill for convenience purposes, a [bundler](https://github.com/asticode/go-astilectron-bundler) has been implemented.\n\nThe bundler allows you to bundle your app for every os/arch combinations and get a nice set of files to send your users.\n\n# Quick start\n\nWARNING: the code below doesn't handle errors for readibility purposes. However you SHOULD!\n\n## Import `go-astilectron`\n\nTo import `go-astilectron` run:\n\n    $ go get -u github.com/asticode/go-astilectron\n\n## Start `go-astilectron`\n\n```go\n// Initialize astilectron\nvar a, _ = astilectron.New(log.New(os.Stderr, \"\", 0), astilectron.Options{\n    AppName: \"<your app name>\",\n    AppIconDefaultPath: \"<your .png icon>\", // If path is relative, it must be relative to the data directory\n    AppIconDarwinPath:  \"<your .icns icon>\", // Same here\n    BaseDirectoryPath: \"<where you want the provisioner to install the dependencies>\",\n    VersionAstilectron: \"<version of Astilectron to utilize such as `0.33.0`>\",\n    VersionElectron: \"<version of Electron to utilize such as `4.0.1` | `6.1.2`>\",\n})\ndefer a.Close()\n\n// Start astilectron\na.Start()\n\n// Blocking pattern\na.Wait()\n```\n\nFor everything to work properly we need to fetch 2 dependencies : [astilectron](https://github.com/asticode/astilectron) and [Electron](https://github.com/electron/electron). `.Start()` takes care of it by downloading the sources and setting them up properly.\n\nIn case you want to embed the sources in the binary to keep a unique binary you can use the **NewDisembedderProvisioner** function to get the proper **Provisioner** and attach it to `go-astilectron` with `.SetProvisioner(p Provisioner)`. Or you can use the [bootstrap](https://github.com/asticode/go-astilectron-bootstrap) and the [bundler](https://github.com/asticode/go-astilectron-bundler). Check out the [demo](https://github.com/asticode/go-astilectron-demo) to see how to use them.\n\nBeware when trying to add your own app icon as you'll need 2 icons : one compatible with MacOSX (.icns) and one compatible with the rest (.png for instance).\n\nIf no BaseDirectoryPath is provided, it defaults to the executable's directory path.\n\nThe majority of methods are asynchronous which means that when executing them `go-astilectron` will block until it receives a specific Electron event or until the overall context is cancelled. This is the case of `.Start()` which will block until it receives the `app.event.ready` `astilectron` event or until the overall context is cancelled.\n\n### HTML paths\nNB! All paths in HTML (and Javascript) must be relative, otherwise the files will not be found.\nTo make this happen in React for example, just set the homepage property of your package.json to \"./\".\n\n``` { \"homepage\": \"./\" }```\n\n## Create a window\n\n```go\n// Create a new window\nvar w, _ = a.NewWindow(\"http://127.0.0.1:4000\", &astilectron.WindowOptions{\n    Center: astikit.BoolPtr(true),\n    Height: astikit.IntPtr(600),\n    Width:  astikit.IntPtr(600),\n})\nw.Create()\n```\n    \nWhen creating a window you need to indicate a URL as well as options such as position, size, etc.\n\nThis is pretty straightforward except the `astilectron.Ptr*` methods so let me explain: GO doesn't do optional fields when json encoding unless you use pointers whereas Electron does handle optional fields. Therefore I added helper methods to convert int, bool and string into pointers and used pointers in structs sent to Electron.\n\n## Open the dev tools\n\nWhen developing in JS, it's very convenient to debug your code using the browser window's dev tools:\n\n````go\n// Open dev tools\nw.OpenDevTools()\n\n// Close dev tools\nw.CloseDevTools()\n````\n\n## Add listeners\n\n```go\n// Add a listener on Astilectron\na.On(astilectron.EventNameAppCrash, func(e astilectron.Event) (deleteListener bool) {\n    log.Println(\"App has crashed\")\n    return\n})\n\n// Add a listener on the window\nw.On(astilectron.EventNameWindowEventResize, func(e astilectron.Event) (deleteListener bool) {\n    log.Println(\"Window resized\")\n    return\n})\n```\n    \nNothing much to say here either except that you can add listeners to Astilectron as well.\n\n## Play with the window\n\n```go\n// Play with the window\nw.Resize(200, 200)\ntime.Sleep(time.Second)\nw.Maximize()\n```\n    \nCheck out the [Window doc](https://godoc.org/github.com/asticode/go-astilectron#Window) for a list of all exported methods\n\n## Send messages from GO to Javascript\n\n### Javascript\n\n```javascript\n// This will wait for the astilectron namespace to be ready\ndocument.addEventListener('astilectron-ready', function() {\n    // This will listen to messages sent by GO\n    astilectron.onMessage(function(message) {\n        // Process message\n        if (message === \"hello\") {\n            return \"world\";\n        }\n    });\n})\n```\n\n### GO\n\n```go\n// This will send a message and execute a callback\n// Callbacks are optional\nw.SendMessage(\"hello\", func(m *astilectron.EventMessage) {\n        // Unmarshal\n        var s string\n        m.Unmarshal(&s)\n\n        // Process message\n        log.Printf(\"received %s\\n\", s)\n})\n```\n\nThis will print `received world` in the GO output\n\n## Send messages from Javascript to GO\n\n### GO\n\n```go\n// This will listen to messages sent by Javascript\nw.OnMessage(func(m *astilectron.EventMessage) interface{} {\n        // Unmarshal\n        var s string\n        m.Unmarshal(&s)\n\n        // Process message\n        if s == \"hello\" {\n                return \"world\"\n        }\n        return nil\n})\n```\n\n### Javascript\n\n```javascript\n// This will wait for the astilectron namespace to be ready\ndocument.addEventListener('astilectron-ready', function() {\n    // This will send a message to GO\n    astilectron.sendMessage(\"hello\", function(message) {\n        console.log(\"received \" + message)\n    });\n})\n```\n\nThis will print \"received world\" in the Javascript output\n\n## Play with the window's session\n\n```go\n// Clear window's HTTP cache\nw.Session.ClearCache()\n```\n\n## Handle several screens/displays\n\n```go\n// If several displays, move the window to the second display\nvar displays = a.Displays()\nif len(displays) > 1 {\n    time.Sleep(time.Second)\n    w.MoveInDisplay(displays[1], 50, 50)\n}\n```\n\n## Menus\n\n```go\n// Init a new app menu\n// You can do the same thing with a window\nvar m = a.NewMenu([]*astilectron.MenuItemOptions{\n    {\n        Label: astikit.StrPtr(\"Separator\"),\n        SubMenu: []*astilectron.MenuItemOptions{\n            {Label: astikit.StrPtr(\"Normal 1\")},\n            {\n                Label: astikit.StrPtr(\"Normal 2\"),\n                OnClick: func(e astilectron.Event) (deleteListener bool) {\n                    log.Println(\"Normal 2 item has been clicked\")\n                    return\n                },\n            },\n            {Type: astilectron.MenuItemTypeSeparator},\n            {Label: astikit.StrPtr(\"Normal 3\")},\n        },\n    },\n    {\n        Label: astikit.StrPtr(\"Checkbox\"),\n        SubMenu: []*astilectron.MenuItemOptions{\n            {Checked: astikit.BoolPtr(true), Label: astikit.StrPtr(\"Checkbox 1\"), Type: astilectron.MenuItemTypeCheckbox},\n            {Label: astikit.StrPtr(\"Checkbox 2\"), Type: astilectron.MenuItemTypeCheckbox},\n            {Label: astikit.StrPtr(\"Checkbox 3\"), Type: astilectron.MenuItemTypeCheckbox},\n        },\n    },\n    {\n        Label: astikit.StrPtr(\"Radio\"),\n        SubMenu: []*astilectron.MenuItemOptions{\n            {Checked: astikit.BoolPtr(true), Label: astikit.StrPtr(\"Radio 1\"), Type: astilectron.MenuItemTypeRadio},\n            {Label: astikit.StrPtr(\"Radio 2\"), Type: astilectron.MenuItemTypeRadio},\n            {Label: astikit.StrPtr(\"Radio 3\"), Type: astilectron.MenuItemTypeRadio},\n        },\n    },\n    {\n        Label: astikit.StrPtr(\"Roles\"),\n        SubMenu: []*astilectron.MenuItemOptions{\n            {Label: astikit.StrPtr(\"Minimize\"), Role: astilectron.MenuItemRoleMinimize},\n            {Label: astikit.StrPtr(\"Close\"), Role: astilectron.MenuItemRoleClose},\n        },\n    },\n})\n\n// Retrieve a menu item\n// This will retrieve the \"Checkbox 1\" item\nmi, _ := m.Item(1, 0)\n\n// Add listener manually\n// An OnClick listener has already been added in the options directly for another menu item\nmi.On(astilectron.EventNameMenuItemEventClicked, func(e astilectron.Event) bool {\n    log.Printf(\"Menu item has been clicked. 'Checked' status is now %t\\n\", *e.MenuItemOptions.Checked)\n    return false\n})\n\n// Create the menu\nm.Create()\n\n// Manipulate a menu item\nmi.SetChecked(true)\n\n// Init a new menu item\nvar ni = m.NewItem(&astilectron.MenuItemOptions{\n    Label: astikit.StrPtr(\"Inserted\"),\n    SubMenu: []*astilectron.MenuItemOptions{\n        {Label: astikit.StrPtr(\"Inserted 1\")},\n        {Label: astikit.StrPtr(\"Inserted 2\")},\n    },\n})\n\n// Insert the menu item at position \"1\"\nm.Insert(1, ni)\n\n// Fetch a sub menu\ns, _ := m.SubMenu(0)\n\n// Init a new menu item\nni = s.NewItem(&astilectron.MenuItemOptions{\n    Label: astikit.StrPtr(\"Appended\"),\n    SubMenu: []*astilectron.MenuItemOptions{\n        {Label: astikit.StrPtr(\"Appended 1\")},\n        {Label: astikit.StrPtr(\"Appended 2\")},\n    },\n})\n\n// Append menu item dynamically\ns.Append(ni)\n\n// Pop up sub menu as a context menu\ns.Popup(&astilectron.MenuPopupOptions{PositionOptions: astilectron.PositionOptions{X: astikit.IntPtr(50), Y: astikit.IntPtr(50)}})\n\n// Close popup\ns.ClosePopup()\n\n// Destroy the menu\nm.Destroy()\n```\n\nA few things to know:\n\n* when assigning a role to a menu item, `go-astilectron` won't be able to capture its click event\n* on MacOS there's no such thing as a window menu, only app menus therefore my advice is to stick to one global app menu instead of creating separate window menus\n* on MacOS MenuItem without SubMenu is not displayed\n\n## Tray\n\n```go\n// New tray\nvar t = a.NewTray(&astilectron.TrayOptions{\n    Image:   astikit.StrPtr(\"/path/to/image.png\"),\n    Tooltip: astikit.StrPtr(\"Tray's tooltip\"),\n})\n\n// Create tray\nt.Create()\n\n// New tray menu\nvar m = t.NewMenu([]*astilectron.MenuItemOptions{\n    {\n        Label: astikit.StrPtr(\"Root 1\"),\n        SubMenu: []*astilectron.MenuItemOptions{\n            {Label: astikit.StrPtr(\"Item 1\")},\n            {Label: astikit.StrPtr(\"Item 2\")},\n            {Type: astilectron.MenuItemTypeSeparator},\n            {Label: astikit.StrPtr(\"Item 3\")},\n        },\n    },\n    {\n        Label: astikit.StrPtr(\"Root 2\"),\n        SubMenu: []*astilectron.MenuItemOptions{\n            {Label: astikit.StrPtr(\"Item 1\")},\n            {Label: astikit.StrPtr(\"Item 2\")},\n        },\n    },\n})\n\n// Create the menu\nm.Create()\n\n// Change tray's image\ntime.Sleep(time.Second)\nt.SetImage(\"/path/to/image-2.png\")\n```\n\n## Notifications\n\n```go\n// Create the notification\nvar n = a.NewNotification(&astilectron.NotificationOptions{\n\tBody: \"My Body\",\n\tHasReply: astikit.BoolPtr(true), // Only MacOSX\n\tIcon: \"/path/to/icon\",\n\tReplyPlaceholder: \"type your reply here\", // Only MacOSX\n\tTitle: \"My title\",\n})\n\n// Add listeners\nn.On(astilectron.EventNameNotificationEventClicked, func(e astilectron.Event) (deleteListener bool) {\n\tlog.Println(\"the notification has been clicked!\")\n\treturn\n})\n// Only for MacOSX\nn.On(astilectron.EventNameNotificationEventReplied, func(e astilectron.Event) (deleteListener bool) {\n\tlog.Printf(\"the user has replied to the notification: %s\\n\", e.Reply)\n\treturn\n})\n\n// Create notification\nn.Create()\n\n// Show notification\nn.Show()\n```\n\n## Dock (MacOSX only)\n\n```go\n// Get the dock\nvar d = a.Dock()\n\n// Hide and show the dock\nd.Hide()\nd.Show()\n\n// Make the Dock bounce\nid, _ := d.Bounce(astilectron.DockBounceTypeCritical)\n\n// Cancel the bounce\nd.CancelBounce(id)\n\n// Update badge and icon\nd.SetBadge(\"test\")\nd.SetIcon(\"/path/to/icon\")\n\n// New dock menu\nvar m = d.NewMenu([]*astilectron.MenuItemOptions{\n    {\n        Label: astikit.StrPtr(\"Root 1\"),\n        SubMenu: []*astilectron.MenuItemOptions{\n            {Label: astikit.StrPtr(\"Item 1\")},\n            {Label: astikit.StrPtr(\"Item 2\")},\n            {Type: astilectron.MenuItemTypeSeparator},\n            {Label: astikit.StrPtr(\"Item 3\")},\n        },\n    },\n        {\n        Label: astikit.StrPtr(\"Root 2\"),\n        SubMenu: []*astilectron.MenuItemOptions{\n            {Label: astikit.StrPtr(\"Item 1\")},\n            {Label: astikit.StrPtr(\"Item 2\")},\n        },\n    },\n})\n\n// Create the menu\nm.Create()\n```\n\n## Global Shortcuts\n\nRegistering a global shortcut.\n\n```go\n// Register a new global shortcut\nisRegistered, _ := a.GlobalShortcuts().Register(\"CmdOrCtrl+x\", func() {\n    fmt.Println(\"CmdOrCtrl+x is pressed\")\n})\nfmt.Println(\"CmdOrCtrl+x is registered:\", isRegistered)  // true\n\n// Check if a global shortcut is registered\nisRegistered, _ = a.GlobalShortcuts().IsRegistered(\"Shift+Y\") // false\n\n// Unregister a global shortcut\na.GlobalShortcuts().Unregister(\"CmdOrCtrl+x\")\n\n// Unregister all global shortcuts\na.GlobalShortcuts().UnregisterAll()\n```\n\n## Dialogs\n\nAdd the following line at the top of your javascript file :\n\n```javascript\nconst { dialog } = require('electron').remote\n```\n\nUse the available [methods](https://github.com/electron/electron/blob/v7.1.10/docs/api/dialog.md).\n\n## Basic auth\n\n```go\n// Listen to login events\nw.OnLogin(func(i astilectron.Event) (username, password string, err error) {\n\t// Process the request and auth info\n\tif i.Request.Method == \"GET\" && i.AuthInfo.Scheme == \"http://\" {\n\t\tusername = \"username\"\n\t\tpassword = \"password\"\n\t}\n    return\n})\n```\n\n# Features and roadmap\n\n- [x] custom branding (custom app name, app icon, etc.)\n- [x] window basic methods (create, show, close, resize, minimize, maximize, ...)\n- [x] window basic events (close, blur, focus, unresponsive, crashed, ...)\n- [x] remote messaging (messages between GO and Javascript)\n- [x] single binary distribution\n- [x] multi screens/displays\n- [x] menu methods and events (create, insert, append, popup, clicked, ...)\n- [x] bootstrap\n- [x] dialogs (open or save file, alerts, ...)\n- [x] tray\n- [x] bundler\n- [x] session\n- [x] accelerators (shortcuts)\n- [x] dock\n- [x] notifications\n- [ ] loader\n- [ ] file methods (drag & drop, ...)\n- [ ] clipboard methods\n- [ ] power monitor events (suspend, resume, ...)\n- [ ] desktop capturer (audio and video)\n- [ ] window advanced options (add missing ones)\n- [ ] window advanced methods (add missing ones)\n- [ ] window advanced events (add missing ones)\n- [ ] child windows\n\n# Cheers to\n\n[go-thrust](https://github.com/miketheprogrammer/go-thrust) which is awesome but unfortunately not maintained anymore. It inspired this project.\n"
        },
        {
          "name": "accelerator.go",
          "type": "blob",
          "size": 0.7783203125,
          "content": "package astilectron\n\nimport (\n\t\"strings\"\n)\n\n// Accelerator separator\nconst acceleratorSeparator = \"+\"\n\n// Accelerator represents an accelerator\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/accelerator.md\ntype Accelerator []string\n\n// NewAccelerator creates a new accelerator\nfunc NewAccelerator(items ...string) (a *Accelerator) {\n\ta = &Accelerator{}\n\tfor _, i := range items {\n\t\t*a = append(*a, i)\n\t}\n\treturn\n}\n\n// MarshalText implements the encoding.TextMarshaler interface\nfunc (a *Accelerator) MarshalText() ([]byte, error) {\n\treturn []byte(strings.Join(*a, acceleratorSeparator)), nil\n}\n\n// UnmarshalText implements the encoding.TextUnmarshaler interface\nfunc (a *Accelerator) UnmarshalText(b []byte) error {\n\t*a = strings.Split(string(b), acceleratorSeparator)\n\treturn nil\n}\n"
        },
        {
          "name": "accelerator_test.go",
          "type": "blob",
          "size": 0.333984375,
          "content": "package astilectron\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAccelerator(t *testing.T) {\n\tvar tb = []byte(\"1+2+3\")\n\tvar a Accelerator\n\terr := a.UnmarshalText(tb)\n\tassert.NoError(t, err)\n\tassert.Equal(t, Accelerator{\"1\", \"2\", \"3\"}, a)\n\tb, err := a.MarshalText()\n\tassert.NoError(t, err)\n\tassert.Equal(t, tb, b)\n}\n"
        },
        {
          "name": "astilectron.go",
          "type": "blob",
          "size": 12.4228515625,
          "content": "package astilectron\n\nimport (\n\t\"fmt\"\n\t\"github.com/asticode/go-astikit\"\n\t\"net\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"time\"\n)\n\n// Versions\nconst (\n\tDefaultAcceptTCPTimeout   = 30 * time.Second\n\tDefaultVersionAstilectron = \"0.58.0\"\n\tDefaultVersionElectron    = \"11.4.3\"\n)\n\n// Misc vars\nvar (\n\tvalidOSes = map[string]bool{\n\t\t\"darwin\":  true,\n\t\t\"linux\":   true,\n\t\t\"windows\": true,\n\t}\n)\n\n// App event names\nconst (\n\tEventNameAppClose               = \"app.close\"\n\tEventNameAppCmdQuit             = \"app.cmd.quit\" // Sends an event to Electron to properly quit the app\n\tEventNameAppCmdStop             = \"app.cmd.stop\" // Cancel the context which results in exiting abruptly Electron's app\n\tEventNameAppCrash               = \"app.crash\"\n\tEventNameAppErrorAccept         = \"app.error.accept\"\n\tEventNameAppEventReady          = \"app.event.ready\"\n\tEventNameAppEventSecondInstance = \"app.event.second.instance\"\n\tEventNameAppNoAccept            = \"app.no.accept\"\n\tEventNameAppTooManyAccept       = \"app.too.many.accept\"\n)\n\n// Astilectron represents an object capable of interacting with Astilectron\ntype Astilectron struct {\n\tdispatcher      *dispatcher\n\tdisplayPool     *displayPool\n\tdock            *Dock\n\texecuter        Executer\n\tglobalShortcuts *GlobalShortcuts\n\tidentifier      *identifier\n\tl               astikit.SeverityLogger\n\tlistener        net.Listener\n\toptions         Options\n\tpaths           *Paths\n\tprovisioner     Provisioner\n\treader          *reader\n\tstderrWriter    *astikit.WriterAdapter\n\tstdoutWriter    *astikit.WriterAdapter\n\tsupported       *Supported\n\tworker          *astikit.Worker\n\twriter          *writer\n}\n\n// Options represents Astilectron options\ntype Options struct {\n\tAcceptTCPTimeout   time.Duration\n\tAppName            string\n\tAppIconDarwinPath  string // Darwin systems requires a specific .icns file\n\tAppIconDefaultPath string\n\tCustomElectronPath string\n\tBaseDirectoryPath  string\n\tDataDirectoryPath  string\n\tElectronSwitches   []string\n\tSingleInstance     bool\n\tSkipSetup          bool // If true, the user must handle provisioning and executing astilectron.\n\tTCPPort            *int // The port to listen on.\n\tVersionAstilectron string\n\tVersionElectron    string\n}\n\n// Supported represents Astilectron supported features\ntype Supported struct {\n\tNotification *bool `json:\"notification\"`\n}\n\n// New creates a new Astilectron instance\nfunc New(l astikit.StdLogger, o Options) (a *Astilectron, err error) {\n\t// Validate the OS\n\tif !IsValidOS(runtime.GOOS) {\n\t\terr = fmt.Errorf(\"OS %s is invalid\", runtime.GOOS)\n\t\treturn\n\t}\n\n\tif o.VersionAstilectron == \"\" {\n\t\to.VersionAstilectron = DefaultVersionAstilectron\n\t}\n\tif o.VersionElectron == \"\" {\n\t\to.VersionElectron = DefaultVersionElectron\n\t}\n\n\t// Init\n\ta = &Astilectron{\n\t\tdispatcher:  newDispatcher(),\n\t\tdisplayPool: newDisplayPool(),\n\t\texecuter:    DefaultExecuter,\n\t\tidentifier:  newIdentifier(),\n\t\tl:           astikit.AdaptStdLogger(l),\n\t\toptions:     o,\n\t\tprovisioner: newDefaultProvisioner(l),\n\t\tworker:      astikit.NewWorker(astikit.WorkerOptions{Logger: l}),\n\t}\n\n\t// Set paths\n\tif a.paths, err = newPaths(runtime.GOOS, runtime.GOARCH, o); err != nil {\n\t\terr = fmt.Errorf(\"creating new paths failed: %w\", err)\n\t\treturn\n\t}\n\n\t// Add default listeners\n\ta.On(EventNameAppCmdStop, func(e Event) (deleteListener bool) {\n\t\ta.Stop()\n\t\treturn\n\t})\n\ta.On(EventNameDisplayEventAdded, func(e Event) (deleteListener bool) {\n\t\ta.displayPool.update(e.Displays)\n\t\treturn\n\t})\n\ta.On(EventNameDisplayEventMetricsChanged, func(e Event) (deleteListener bool) {\n\t\ta.displayPool.update(e.Displays)\n\t\treturn\n\t})\n\ta.On(EventNameDisplayEventRemoved, func(e Event) (deleteListener bool) {\n\t\ta.displayPool.update(e.Displays)\n\t\treturn\n\t})\n\ta.On(EventNameAppCmdQuit, func(e Event) (deleteListener bool) {\n\t\ta.Stop()\n\t\treturn\n\t})\n\treturn\n}\n\n// IsValidOS validates the OS\nfunc IsValidOS(os string) (ok bool) {\n\t_, ok = validOSes[os]\n\treturn\n}\n\n// SetProvisioner sets the provisioner\nfunc (a *Astilectron) SetProvisioner(p Provisioner) *Astilectron {\n\ta.provisioner = p\n\treturn a\n}\n\n// SetExecuter sets the executer\nfunc (a *Astilectron) SetExecuter(e Executer) *Astilectron {\n\ta.executer = e\n\treturn a\n}\n\n// GlobalShortcuts gets the global shortcuts\nfunc (a *Astilectron) GlobalShortcuts() *GlobalShortcuts {\n\treturn a.globalShortcuts\n}\n\n// On implements the Listenable interface\nfunc (a *Astilectron) On(eventName string, l Listener) {\n\ta.dispatcher.addListener(targetIDApp, eventName, l)\n}\n\n// Start starts Astilectron\nfunc (a *Astilectron) Start() (err error) {\n\t// Log\n\ta.l.Debug(\"Starting...\")\n\n\t// Provision\n\tif !a.options.SkipSetup {\n\t\tif err = a.provision(); err != nil {\n\t\t\treturn fmt.Errorf(\"provisioning failed: %w\", err)\n\t\t}\n\t}\n\n\t// Unfortunately communicating with Electron through stdin/stdout doesn't work on Windows so all communications\n\t// will be done through TCP\n\tif err = a.listenTCP(); err != nil {\n\t\treturn fmt.Errorf(\"listening failed: %w\", err)\n\t}\n\n\t// Execute\n\tif !a.options.SkipSetup {\n\t\tif err = a.execute(); err != nil {\n\t\t\treturn fmt.Errorf(\"executing failed: %w\", err)\n\t\t}\n\t} else {\n\t\tsynchronousFunc(a.worker.Context(), a, nil, \"app.event.ready\")\n\t}\n\treturn nil\n}\n\n// provision provisions Astilectron\nfunc (a *Astilectron) provision() error {\n\ta.l.Debug(\"Provisioning...\")\n\treturn a.provisioner.Provision(a.worker.Context(), a.options.AppName, runtime.GOOS, runtime.GOARCH, a.options.VersionAstilectron, a.options.VersionElectron, *a.paths)\n}\n\n// listenTCP creates a TCP server for astilectron to connect to\n// and listens to the first TCP connection coming its way (this should be Astilectron).\nfunc (a *Astilectron) listenTCP() (err error) {\n\t// Log\n\ta.l.Debug(\"Listening...\")\n\n\taddr := \"127.0.0.1:\"\n\tif a.options.TCPPort != nil {\n\t\taddr += fmt.Sprint(*a.options.TCPPort)\n\t}\n\t// Listen\n\tif a.listener, err = net.Listen(\"tcp\", addr); err != nil {\n\t\treturn fmt.Errorf(\"tcp net.Listen failed: %w\", err)\n\t}\n\n\t// Check a connection has been accepted quickly enough\n\tvar chanAccepted = make(chan bool)\n\tgo a.watchNoAccept(a.options.AcceptTCPTimeout, chanAccepted)\n\n\t// Accept connections\n\tgo a.acceptTCP(chanAccepted)\n\treturn\n}\n\n// watchNoAccept checks whether a TCP connection is accepted quickly enough\nfunc (a *Astilectron) watchNoAccept(timeout time.Duration, chanAccepted chan bool) {\n\t// check timeout\n\tif timeout == 0 {\n\t\ttimeout = DefaultAcceptTCPTimeout\n\t}\n\tvar t = time.NewTimer(timeout)\n\tdefer t.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-chanAccepted:\n\t\t\treturn\n\t\tcase <-t.C:\n\t\t\ta.l.Errorf(\"No TCP connection has been accepted in the past %s\", timeout)\n\t\t\ta.dispatcher.dispatch(Event{Name: EventNameAppNoAccept, TargetID: targetIDApp})\n\t\t\ta.dispatcher.dispatch(Event{Name: EventNameAppCmdStop, TargetID: targetIDApp})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// watchAcceptTCP accepts TCP connections\nfunc (a *Astilectron) acceptTCP(chanAccepted chan bool) {\n\tfor i := 0; i <= 1; i++ {\n\t\t// Accept\n\t\tvar conn net.Conn\n\t\tvar err error\n\t\tif conn, err = a.listener.Accept(); err != nil {\n\t\t\ta.l.Errorf(\"%s while TCP accepting\", err)\n\t\t\ta.dispatcher.dispatch(Event{Name: EventNameAppErrorAccept, TargetID: targetIDApp})\n\t\t\ta.dispatcher.dispatch(Event{Name: EventNameAppCmdStop, TargetID: targetIDApp})\n\t\t\treturn\n\t\t}\n\n\t\t// We only accept the first connection which should be Astilectron, close the next one and stop\n\t\t// the app\n\t\tif i > 0 {\n\t\t\ta.l.Errorf(\"Too many TCP connections\")\n\t\t\ta.dispatcher.dispatch(Event{Name: EventNameAppTooManyAccept, TargetID: targetIDApp})\n\t\t\ta.dispatcher.dispatch(Event{Name: EventNameAppCmdStop, TargetID: targetIDApp})\n\t\t\tconn.Close()\n\t\t\treturn\n\t\t}\n\n\t\t// Let the timer know a connection has been accepted\n\t\tchanAccepted <- true\n\n\t\t// Create reader and writer\n\t\ta.writer = newWriter(conn, a.l)\n\t\ta.reader = newReader(a.worker.Context(), a.l, a.dispatcher, conn)\n\t\tgo a.reader.read()\n\t}\n}\n\n// execute executes Astilectron in Electron\nfunc (a *Astilectron) execute() (err error) {\n\t// Log\n\ta.l.Debug(\"Executing...\")\n\n\t// Create command\n\tvar singleInstance string\n\tif a.options.SingleInstance {\n\t\tsingleInstance = \"true\"\n\t} else {\n\t\tsingleInstance = \"false\"\n\t}\n\tvar cmd = exec.CommandContext(a.worker.Context(), a.paths.AppExecutable(), append([]string{a.paths.AstilectronApplication(), a.listener.Addr().String(), singleInstance}, a.options.ElectronSwitches...)...)\n\ta.stderrWriter = astikit.NewWriterAdapter(astikit.WriterAdapterOptions{\n\t\tCallback: func(i []byte) { a.l.Debugf(\"Stderr says: %s\", i) },\n\t\tSplit:    []byte(\"\\n\"),\n\t})\n\ta.stdoutWriter = astikit.NewWriterAdapter(astikit.WriterAdapterOptions{\n\t\tCallback: func(i []byte) { a.l.Debugf(\"Stdout says: %s\", i) },\n\t\tSplit:    []byte(\"\\n\"),\n\t})\n\tcmd.Stderr = a.stderrWriter\n\tcmd.Stdout = a.stdoutWriter\n\n\t// Execute command\n\tif err = a.executeCmd(cmd); err != nil {\n\t\treturn fmt.Errorf(\"executing cmd failed: %w\", err)\n\t}\n\treturn\n}\n\n// executeCmd executes the command\nfunc (a *Astilectron) executeCmd(cmd *exec.Cmd) (err error) {\n\t// Execute\n\tvar e Event\n\tif e, err = synchronousFunc(a.worker.Context(), a, func() error { return a.executer(a.l, a, cmd) }, EventNameAppEventReady); err != nil {\n\t\terr = fmt.Errorf(\"executer failed: %w\", err)\n\t\treturn\n\t}\n\n\t// Update display pool\n\tif e.Displays != nil {\n\t\ta.displayPool.update(e.Displays)\n\t}\n\n\t// Create dock\n\ta.dock = newDock(a.worker.Context(), a.dispatcher, a.identifier, a.writer)\n\n\t// Create global shortcuts\n\ta.globalShortcuts = newGlobalShortcuts(a.worker.Context(), a.dispatcher, a.identifier, a.writer)\n\n\t// Update supported features\n\ta.supported = e.Supported\n\treturn\n}\n\n// watchCmd watches the cmd execution\nfunc (a *Astilectron) watchCmd(cmd *exec.Cmd) {\n\ta.worker.NewTask().Do(func() {\n\t\t// Wait\n\t\tif err := cmd.Wait(); err != nil {\n\t\t\ta.l.Errorf(\"'%v' exited with code: %v\", cmd.Path, cmd.ProcessState.ExitCode())\n\t\t}\n\n\t\t// Check the context to determine whether it was a crash\n\t\tif a.worker.Context().Err() == nil {\n\t\t\ta.l.Debug(\"App has crashed\")\n\t\t\ta.dispatcher.dispatch(Event{Name: EventNameAppCrash, TargetID: targetIDApp})\n\t\t} else {\n\t\t\ta.l.Debug(\"App has closed\")\n\t\t\ta.dispatcher.dispatch(Event{Name: EventNameAppClose, TargetID: targetIDApp})\n\t\t}\n\t\ta.dispatcher.dispatch(Event{Name: EventNameAppCmdStop, TargetID: targetIDApp})\n\t})\n}\n\n// Close closes Astilectron properly\nfunc (a *Astilectron) Close() {\n\ta.l.Debug(\"Closing...\")\n\ta.worker.Stop()\n\tif a.listener != nil {\n\t\ta.listener.Close()\n\t}\n\tif a.reader != nil {\n\t\ta.reader.close()\n\t}\n\tif a.stderrWriter != nil {\n\t\ta.stderrWriter.Close()\n\t}\n\tif a.stdoutWriter != nil {\n\t\ta.stdoutWriter.Close()\n\t}\n\tif a.writer != nil {\n\t\ta.writer.close()\n\t}\n}\n\n// HandleSignals handles signals\nfunc (a *Astilectron) HandleSignals(hs ...astikit.SignalHandler) {\n\ta.worker.HandleSignals(hs...)\n}\n\n// Stop orders Astilectron to stop\nfunc (a *Astilectron) Stop() {\n\ta.l.Debug(\"Stopping...\")\n\ta.worker.Stop()\n}\n\n// Wait is a blocking pattern\nfunc (a *Astilectron) Wait() {\n\ta.worker.Wait()\n}\n\n// Quit quits the app\nfunc (a *Astilectron) Quit() error {\n\treturn a.writer.write(Event{Name: EventNameAppCmdQuit})\n}\n\n// Paths returns the paths\nfunc (a *Astilectron) Paths() Paths {\n\treturn *a.paths\n}\n\n// Displays returns the displays\nfunc (a *Astilectron) Displays() []*Display {\n\treturn a.displayPool.all()\n}\n\n// Dock returns the dock\nfunc (a *Astilectron) Dock() *Dock {\n\treturn a.dock\n}\n\n// PrimaryDisplay returns the primary display\nfunc (a *Astilectron) PrimaryDisplay() *Display {\n\treturn a.displayPool.primary()\n}\n\n// NewMenu creates a new app menu\nfunc (a *Astilectron) NewMenu(i []*MenuItemOptions) *Menu {\n\treturn newMenu(a.worker.Context(), targetIDApp, i, a.dispatcher, a.identifier, a.writer)\n}\n\n// NewWindow creates a new window\nfunc (a *Astilectron) NewWindow(url string, o *WindowOptions) (*Window, error) {\n\treturn newWindow(a.worker.Context(), a.l, a.options, a.Paths(), url, o, a.dispatcher, a.identifier, a.writer)\n}\n\n// NewWindowInDisplay creates a new window in a specific display\n// This overrides the center attribute\nfunc (a *Astilectron) NewWindowInDisplay(d *Display, url string, o *WindowOptions) (*Window, error) {\n\tif o.X != nil {\n\t\t*o.X += d.Bounds().X\n\t} else {\n\t\to.X = astikit.IntPtr(d.Bounds().X)\n\t}\n\tif o.Y != nil {\n\t\t*o.Y += d.Bounds().Y\n\t} else {\n\t\to.Y = astikit.IntPtr(d.Bounds().Y)\n\t}\n\treturn newWindow(a.worker.Context(), a.l, a.options, a.Paths(), url, o, a.dispatcher, a.identifier, a.writer)\n}\n\n// NewTray creates a new tray\nfunc (a *Astilectron) NewTray(o *TrayOptions) *Tray {\n\treturn newTray(a.worker.Context(), o, a.dispatcher, a.identifier, a.writer)\n}\n\n// NewNotification creates a new notification\nfunc (a *Astilectron) NewNotification(o *NotificationOptions) *Notification {\n\treturn newNotification(a.worker.Context(), o, a.supported != nil && a.supported.Notification != nil && *a.supported.Notification, a.dispatcher, a.identifier, a.writer)\n}\n"
        },
        {
          "name": "astilectron_test.go",
          "type": "blob",
          "size": 4.4462890625,
          "content": "package astilectron\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype logger struct{}\n\nfunc (l *logger) Debug(v ...interface{})                 {}\nfunc (l *logger) Debugf(format string, v ...interface{}) {}\nfunc (l *logger) Error(v ...interface{})                 {}\nfunc (l *logger) Errorf(format string, v ...interface{}) {}\nfunc (l *logger) Info(v ...interface{})                  {}\nfunc (l *logger) Infof(format string, v ...interface{})  {}\nfunc (l *logger) Warn(v ...interface{})                  {}\nfunc (l *logger) Warnf(format string, v ...interface{})  {}\nfunc (l *logger) Fatal(v ...interface{})                 {}\nfunc (l *logger) Fatalf(format string, v ...interface{}) {}\n\nfunc TestAstilectron_Provision(t *testing.T) {\n\t// Init\n\tvar o = Options{\n\t\tBaseDirectoryPath:  mockedTempPath(),\n\t\tVersionAstilectron: \"0.35.1\",\n\t}\n\tdefer os.RemoveAll(o.BaseDirectoryPath)\n\ta, err := New(nil, o)\n\tassert.NoError(t, err)\n\ta.SetProvisioner(NewDisembedderProvisioner(mockedDisembedder, \"astilectron\", \"electron/linux\", nil))\n\n\t// Test provision is successful\n\terr = a.provision()\n\tassert.NoError(t, err)\n}\n\nfunc TestAstilectron_WatchNoAccept(t *testing.T) {\n\t// Init\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\tvar isStopped bool\n\tvar wg = &sync.WaitGroup{}\n\ta.On(EventNameAppCmdStop, func(e Event) bool {\n\t\tisStopped = true\n\t\twg.Done()\n\t\treturn false\n\t})\n\tc := make(chan bool)\n\n\t// Test success\n\tgo func() {\n\t\ttime.Sleep(50 * time.Microsecond)\n\t\tc <- true\n\t}()\n\ta.watchNoAccept(time.Second, c)\n\tassert.False(t, isStopped)\n\n\t// Test failure\n\twg.Add(1)\n\ta.watchNoAccept(time.Nanosecond, c)\n\twg.Wait()\n\tassert.True(t, isStopped)\n}\n\n// mockedListener implements the net.Listener interface\ntype mockedListener struct {\n\tc chan bool\n\te chan bool\n}\n\nfunc (l mockedListener) Accept() (net.Conn, error) {\n\tfor {\n\t\tselect {\n\t\tcase <-l.c:\n\t\t\treturn mockedConn{}, nil\n\t\tcase <-l.e:\n\t\t\treturn nil, errors.New(\"invalid\")\n\t\t}\n\t}\n}\nfunc (l mockedListener) Close() error   { return nil }\nfunc (l mockedListener) Addr() net.Addr { return nil }\n\n// mockedConn implements the net.Conn interface\ntype mockedConn struct{}\n\nfunc (c mockedConn) Read(b []byte) (n int, err error)   { return }\nfunc (c mockedConn) Write(b []byte) (n int, err error)  { return }\nfunc (c mockedConn) Close() error                       { return nil }\nfunc (c mockedConn) LocalAddr() net.Addr                { return nil }\nfunc (c mockedConn) RemoteAddr() net.Addr               { return nil }\nfunc (c mockedConn) SetDeadline(t time.Time) error      { return nil }\nfunc (c mockedConn) SetReadDeadline(t time.Time) error  { return nil }\nfunc (c mockedConn) SetWriteDeadline(t time.Time) error { return nil }\n\nfunc TestAstilectron_AcceptTCP(t *testing.T) {\n\t// Init\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\tdefer a.Close()\n\tvar l = &mockedListener{c: make(chan bool), e: make(chan bool)}\n\ta.listener = l\n\tvar isStopped bool\n\tvar wg = &sync.WaitGroup{}\n\ta.On(EventNameAppCmdStop, func(e Event) bool {\n\t\tisStopped = true\n\t\twg.Done()\n\t\treturn false\n\t})\n\tc := make(chan bool)\n\tvar isAccepted bool\n\tgo func() {\n\t\t<-c\n\t\tisAccepted = true\n\t\twg.Done()\n\t}()\n\tgo a.acceptTCP(c)\n\n\t// Test accepted\n\twg.Add(1)\n\tl.c <- true\n\twg.Wait()\n\tassert.True(t, isAccepted)\n\tassert.False(t, isStopped)\n\n\t// Test refused\n\tisAccepted = false\n\twg.Add(1)\n\tl.c <- true\n\twg.Wait()\n\tassert.False(t, isAccepted)\n\tassert.True(t, isStopped)\n\n\t// Test error accept\n\tgo a.acceptTCP(c)\n\tisStopped = false\n\twg.Add(1)\n\tl.e <- true\n\twg.Wait()\n\tassert.False(t, isAccepted)\n\tassert.True(t, isStopped)\n}\n\nfunc TestIsValidOS(t *testing.T) {\n\tassert.True(t, IsValidOS(\"darwin\"))\n\tassert.True(t, IsValidOS(\"linux\"))\n\tassert.True(t, IsValidOS(\"windows\"))\n\tassert.False(t, IsValidOS(\"invalid\"))\n}\n\nfunc TestAstilectron_Wait(t *testing.T) {\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\ta.HandleSignals()\n\tgo func() {\n\t\ttime.Sleep(20 * time.Microsecond)\n\t\tp, err := os.FindProcess(os.Getpid())\n\t\tassert.NoError(t, err)\n\t\tp.Signal(os.Interrupt)\n\t}()\n\ta.Wait()\n}\n\nfunc TestAstilectron_NewMenu(t *testing.T) {\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\tm := a.NewMenu([]*MenuItemOptions{})\n\tassert.Equal(t, targetIDApp, m.rootID)\n}\n\nfunc TestAstilectron_Actions(t *testing.T) {\n\t// Init\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\tdefer a.Close()\n\twrt := &mockedWriter{}\n\ta.writer = newWriter(wrt, &logger{})\n\n\t// Actions\n\terr = a.Quit()\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"{\\\"name\\\":\\\"app.cmd.quit\\\"}\\n\"}, wrt.w)\n}\n"
        },
        {
          "name": "dialog.go",
          "type": "blob",
          "size": 1.2109375,
          "content": "package astilectron\n\n// Message box types\nconst (\n\tMessageBoxTypeError    = \"error\"\n\tMessageBoxTypeInfo     = \"info\"\n\tMessageBoxTypeNone     = \"none\"\n\tMessageBoxTypeQuestion = \"question\"\n\tMessageBoxTypeWarning  = \"warning\"\n)\n\n// MessageBoxOptions represents message box options\n// We must use pointers since GO doesn't handle optional fields whereas NodeJS does. Use astikit.BoolPtr, astikit.IntPtr or astikit.StrPtr\n// to fill the struct\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/dialog.md#dialogshowmessageboxbrowserwindow-options-callback\ntype MessageBoxOptions struct {\n\tButtons         []string `json:\"buttons,omitempty\"`\n\tCancelID        *int     `json:\"cancelId,omitempty\"`\n\tCheckboxChecked *bool    `json:\"checkboxChecked,omitempty\"`\n\tCheckboxLabel   string   `json:\"checkboxLabel,omitempty\"`\n\tConfirmID       *int     `json:\"confirmId,omitempty\"`\n\tDefaultID       *int     `json:\"defaultId,omitempty\"`\n\tDetail          string   `json:\"detail,omitempty\"`\n\tIcon            string   `json:\"icon,omitempty\"`\n\tMessage         string   `json:\"message,omitempty\"`\n\tNoLink          *bool    `json:\"noLink,omitempty\"`\n\tTitle           string   `json:\"title,omitempty\"`\n\tType            string   `json:\"type,omitempty\"`\n}\n"
        },
        {
          "name": "dispatcher.go",
          "type": "blob",
          "size": 2.072265625,
          "content": "package astilectron\n\nimport \"sync\"\n\n// Listener represents a listener executed when an event is dispatched\ntype Listener func(e Event) (deleteListener bool)\n\n// listenable represents an object that can listen\ntype listenable interface {\n\tOn(eventName string, l Listener)\n}\n\n// dispatcher represents an object capable of dispatching events\ntype dispatcher struct {\n\tid int\n\t// Indexed by target ID then by event name then be listener id\n\t// We use a map[int]Listener so that deletion is as smooth as possible\n\t// It means it doesn't store listeners in order\n\tl map[string]map[string]map[int]Listener\n\tm sync.Mutex\n}\n\n// newDispatcher creates a new dispatcher\nfunc newDispatcher() *dispatcher {\n\treturn &dispatcher{\n\t\tl: make(map[string]map[string]map[int]Listener),\n\t}\n}\n\n// addListener adds a listener\nfunc (d *dispatcher) addListener(targetID, eventName string, l Listener) {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tif _, ok := d.l[targetID]; !ok {\n\t\td.l[targetID] = make(map[string]map[int]Listener)\n\t}\n\tif _, ok := d.l[targetID][eventName]; !ok {\n\t\td.l[targetID][eventName] = make(map[int]Listener)\n\t}\n\td.id++\n\td.l[targetID][eventName][d.id] = l\n}\n\n// delListener delete a specific listener\nfunc (d *dispatcher) delListener(targetID, eventName string, id int) {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tif _, ok := d.l[targetID]; !ok {\n\t\treturn\n\t}\n\tif _, ok := d.l[targetID][eventName]; !ok {\n\t\treturn\n\t}\n\tdelete(d.l[targetID][eventName], id)\n}\n\n// Dispatch dispatches an event\nfunc (d *dispatcher) dispatch(e Event) {\n\t// needed so dispatches of events triggered in the listeners can be received without blocking\n\tgo func() {\n\t\tfor id, l := range d.listeners(e.TargetID, e.Name) {\n\t\t\tif l(e) {\n\t\t\t\td.delListener(e.TargetID, e.Name, id)\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// listeners returns the listeners for a target ID and an event name\nfunc (d *dispatcher) listeners(targetID, eventName string) (l map[int]Listener) {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tl = map[int]Listener{}\n\tif _, ok := d.l[targetID]; !ok {\n\t\treturn\n\t}\n\tif _, ok := d.l[targetID][eventName]; !ok {\n\t\treturn\n\t}\n\tfor k, v := range d.l[targetID][eventName] {\n\t\tl[k] = v\n\t}\n\treturn\n}\n"
        },
        {
          "name": "dispatcher_test.go",
          "type": "blob",
          "size": 1.1220703125,
          "content": "package astilectron\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDispatcher(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar wg = sync.WaitGroup{}\n\tvar dispatched = []int{}\n\tvar m sync.Mutex\n\n\t// Test adding listener\n\td.addListener(\"1\", \"1\", func(e Event) (deleteListener bool) {\n\t\tm.Lock()\n\t\tdispatched = append(dispatched, 1)\n\t\tm.Unlock()\n\t\twg.Done()\n\t\treturn\n\t})\n\td.addListener(\"1\", \"1\", func(e Event) (deleteListener bool) {\n\t\tm.Lock()\n\t\tdispatched = append(dispatched, 2)\n\t\tm.Unlock()\n\t\twg.Done()\n\t\treturn true\n\t})\n\td.addListener(\"1\", \"1\", func(e Event) (deleteListener bool) {\n\t\tm.Lock()\n\t\tdispatched = append(dispatched, 3)\n\t\tm.Unlock()\n\t\twg.Done()\n\t\treturn true\n\t})\n\td.addListener(\"1\", \"2\", func(e Event) (deleteListener bool) {\n\t\tm.Lock()\n\t\tdispatched = append(dispatched, 4)\n\t\tm.Unlock()\n\t\twg.Done()\n\t\treturn\n\t})\n\tassert.Len(t, d.l[\"1\"][\"1\"], 3)\n\n\t// Test dispatch\n\twg.Add(4)\n\td.dispatch(Event{Name: \"2\", TargetID: \"1\"})\n\td.dispatch(Event{Name: \"1\", TargetID: \"1\"})\n\twg.Wait()\n\tfor _, v := range []int{1, 2, 3, 4} {\n\t\tassert.Contains(t, dispatched, v)\n\t}\n\tassert.Len(t, d.listeners(\"1\", \"1\"), 1)\n}\n"
        },
        {
          "name": "display.go",
          "type": "blob",
          "size": 2.55078125,
          "content": "package astilectron\n\n// Display event names\nconst (\n\tEventNameDisplayEventAdded          = \"display.event.added\"\n\tEventNameDisplayEventMetricsChanged = \"display.event.metrics.changed\"\n\tEventNameDisplayEventRemoved        = \"display.event.removed\"\n)\n\n// Display represents a display\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/structures/display.md\ntype Display struct {\n\to       *DisplayOptions\n\tprimary bool\n}\n\n// DisplayOptions represents display options\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/structures/display.md\ntype DisplayOptions struct {\n\tBounds       *RectangleOptions `json:\"bounds,omitempty\"`\n\tID           *int64            `json:\"id,omitempty\"`\n\tRotation     *int              `json:\"rotation,omitempty\"` // 0, 90, 180 or 270\n\tScaleFactor  *float64          `json:\"scaleFactor,omitempty\"`\n\tSize         *SizeOptions      `json:\"size,omitempty\"`\n\tTouchSupport *string           `json:\"touchSupport,omitempty\"` // available, unavailable or unknown\n\tWorkArea     *RectangleOptions `json:\"workArea,omitempty\"`\n\tWorkAreaSize *SizeOptions      `json:\"workAreaSize,omitempty\"`\n}\n\n// newDisplay creates a displays\nfunc newDisplay(o *DisplayOptions, primary bool) *Display { return &Display{o: o, primary: primary} }\n\n// Bounds returns the display bounds\nfunc (d Display) Bounds() Rectangle {\n\treturn Rectangle{\n\t\tPosition: Position{X: *d.o.Bounds.X, Y: *d.o.Bounds.Y},\n\t\tSize:     Size{Height: *d.o.Bounds.Height, Width: *d.o.Bounds.Width},\n\t}\n}\n\n// ID returns the display's ID\nfunc (d Display) ID() int64 {\n\treturn *d.o.ID\n}\n\n// IsPrimary checks whether the display is the primary display\nfunc (d Display) IsPrimary() bool {\n\treturn d.primary\n}\n\n// IsTouchAvailable checks whether touch is available on this display\nfunc (d Display) IsTouchAvailable() bool {\n\treturn *d.o.TouchSupport == \"available\"\n}\n\n// Rotation returns the display rotation\nfunc (d Display) Rotation() int {\n\treturn *d.o.Rotation\n}\n\n// ScaleFactor returns the display scale factor\nfunc (d Display) ScaleFactor() float64 {\n\treturn *d.o.ScaleFactor\n}\n\n// Size returns the display size\nfunc (d Display) Size() Size {\n\treturn Size{Height: *d.o.Size.Height, Width: *d.o.Size.Width}\n}\n\n// WorkArea returns the display work area\nfunc (d Display) WorkArea() Rectangle {\n\treturn Rectangle{\n\t\tPosition: Position{X: *d.o.WorkArea.X, Y: *d.o.WorkArea.Y},\n\t\tSize:     Size{Height: *d.o.WorkArea.Height, Width: *d.o.WorkArea.Width},\n\t}\n}\n\n// WorkAreaSize returns the display work area size\nfunc (d Display) WorkAreaSize() Size {\n\treturn Size{Height: *d.o.WorkAreaSize.Height, Width: *d.o.WorkAreaSize.Width}\n}\n"
        },
        {
          "name": "display_pool.go",
          "type": "blob",
          "size": 1.1728515625,
          "content": "package astilectron\n\nimport \"sync\"\n\n// displayPool represents a display pool\ntype displayPool struct {\n\td map[int64]*Display\n\tm *sync.Mutex\n}\n\n// newDisplayPool creates a new display pool\nfunc newDisplayPool() *displayPool {\n\treturn &displayPool{\n\t\td: make(map[int64]*Display),\n\t\tm: &sync.Mutex{},\n\t}\n}\n\n// all returns all the displays\nfunc (p *displayPool) all() (ds []*Display) {\n\tp.m.Lock()\n\tdefer p.m.Unlock()\n\tds = []*Display{}\n\tfor _, d := range p.d {\n\t\tds = append(ds, d)\n\t}\n\treturn\n}\n\n// primary returns the primary display\n// It defaults to the last display\nfunc (p *displayPool) primary() (d *Display) {\n\tp.m.Lock()\n\tdefer p.m.Unlock()\n\tfor _, d = range p.d {\n\t\tif d.primary {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// update updates the pool based on event displays\nfunc (p *displayPool) update(e *EventDisplays) {\n\tp.m.Lock()\n\tdefer p.m.Unlock()\n\tvar ids = make(map[int64]bool)\n\tfor _, o := range e.All {\n\t\tids[*o.ID] = true\n\t\tvar primary bool\n\t\tif *o.ID == *e.Primary.ID {\n\t\t\tprimary = true\n\t\t}\n\t\tif d, ok := p.d[*o.ID]; ok {\n\t\t\td.primary = primary\n\t\t\t*d.o = *o\n\t\t} else {\n\t\t\tp.d[*o.ID] = newDisplay(o, primary)\n\t\t}\n\t}\n\tfor id := range p.d {\n\t\tif _, ok := ids[id]; !ok {\n\t\t\tdelete(p.d, id)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "display_pool_test.go",
          "type": "blob",
          "size": 1.0634765625,
          "content": "package astilectron\n\nimport (\n\t\"testing\"\n\n\t\"github.com/asticode/go-astikit\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDisplayPool(t *testing.T) {\n\t// Init\n\tvar dp = newDisplayPool()\n\n\t// Test update\n\tdp.update(&EventDisplays{\n\t\tAll: []*DisplayOptions{\n\t\t\t{ID: astikit.Int64Ptr(1), Rotation: astikit.IntPtr(1)},\n\t\t\t{ID: astikit.Int64Ptr(2)},\n\t\t},\n\t\tPrimary: &DisplayOptions{ID: astikit.Int64Ptr(2)},\n\t})\n\tassert.Len(t, dp.all(), 2)\n\tassert.Equal(t, int64(2), *dp.primary().o.ID)\n\n\t// Test removing one display\n\tdp.update(&EventDisplays{\n\t\tAll: []*DisplayOptions{\n\t\t\t{ID: astikit.Int64Ptr(1), Rotation: astikit.IntPtr(2)},\n\t\t},\n\t\tPrimary: &DisplayOptions{ID: astikit.Int64Ptr(1)},\n\t})\n\tassert.Len(t, dp.all(), 1)\n\tassert.Equal(t, 2, dp.all()[0].Rotation())\n\tassert.Equal(t, int64(1), *dp.primary().o.ID)\n\n\t// Test adding a new one\n\tdp.update(&EventDisplays{\n\t\tAll: []*DisplayOptions{\n\t\t\t{ID: astikit.Int64Ptr(1)},\n\t\t\t{ID: astikit.Int64Ptr(3)},\n\t\t},\n\t\tPrimary: &DisplayOptions{ID: astikit.Int64Ptr(1)},\n\t})\n\tassert.Len(t, dp.all(), 2)\n\tassert.Equal(t, int64(1), *dp.primary().o.ID)\n}\n"
        },
        {
          "name": "display_test.go",
          "type": "blob",
          "size": 1.580078125,
          "content": "package astilectron\n\nimport (\n\t\"testing\"\n\n\t\"github.com/asticode/go-astikit\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// TestDisplay tests display\nfunc TestDisplay(t *testing.T) {\n\tvar o = &DisplayOptions{\n\t\tBounds:       &RectangleOptions{PositionOptions: PositionOptions{X: astikit.IntPtr(1), Y: astikit.IntPtr(2)}, SizeOptions: SizeOptions{Height: astikit.IntPtr(3), Width: astikit.IntPtr(4)}},\n\t\tID:           astikit.Int64Ptr(1234),\n\t\tRotation:     astikit.IntPtr(5),\n\t\tScaleFactor:  astikit.Float64Ptr(6),\n\t\tSize:         &SizeOptions{Height: astikit.IntPtr(7), Width: astikit.IntPtr(8)},\n\t\tTouchSupport: astikit.StrPtr(\"available\"),\n\t\tWorkArea:     &RectangleOptions{PositionOptions: PositionOptions{X: astikit.IntPtr(9), Y: astikit.IntPtr(10)}, SizeOptions: SizeOptions{Height: astikit.IntPtr(11), Width: astikit.IntPtr(12)}},\n\t\tWorkAreaSize: &SizeOptions{Height: astikit.IntPtr(13), Width: astikit.IntPtr(14)},\n\t}\n\tvar d = newDisplay(o, true)\n\tassert.Equal(t, Rectangle{Position: Position{X: 1, Y: 2}, Size: Size{Height: 3, Width: 4}}, d.Bounds())\n\tassert.Equal(t, int64(1234), d.ID())\n\tassert.True(t, d.IsPrimary())\n\tassert.Equal(t, 5, d.Rotation())\n\tassert.Equal(t, float64(6), d.ScaleFactor())\n\tassert.Equal(t, Size{Height: 7, Width: 8}, d.Size())\n\tassert.True(t, d.IsTouchAvailable())\n\tassert.Equal(t, Rectangle{Position: Position{X: 9, Y: 10}, Size: Size{Height: 11, Width: 12}}, d.WorkArea())\n\tassert.Equal(t, Size{Height: 13, Width: 14}, d.WorkAreaSize())\n\to.TouchSupport = astikit.StrPtr(\"unavailable\")\n\td = newDisplay(o, false)\n\tassert.False(t, d.IsPrimary())\n\tassert.False(t, d.IsTouchAvailable())\n}\n"
        },
        {
          "name": "dock.go",
          "type": "blob",
          "size": 3.5126953125,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// Dock event names\nconst (\n\teventNameDockCmdBounce              = \"dock.cmd.bounce\"\n\teventNameDockCmdBounceDownloads     = \"dock.cmd.bounce.downloads\"\n\teventNameDockCmdCancelBounce        = \"dock.cmd.cancel.bounce\"\n\teventNameDockCmdHide                = \"dock.cmd.hide\"\n\teventNameDockCmdSetBadge            = \"dock.cmd.set.badge\"\n\teventNameDockCmdSetIcon             = \"dock.cmd.set.icon\"\n\teventNameDockCmdShow                = \"dock.cmd.show\"\n\teventNameDockEventBadgeSet          = \"dock.event.badge.set\"\n\teventNameDockEventBouncing          = \"dock.event.bouncing\"\n\teventNameDockEventBouncingCancelled = \"dock.event.bouncing.cancelled\"\n\teventNameDockEventDownloadsBouncing = \"dock.event.download.bouncing\"\n\teventNameDockEventHidden            = \"dock.event.hidden\"\n\teventNameDockEventIconSet           = \"dock.event.icon.set\"\n\teventNameDockEventShown             = \"dock.event.shown\"\n)\n\n// Dock bounce types\nconst (\n\tDockBounceTypeCritical      = \"critical\"\n\tDockBounceTypeInformational = \"informational\"\n)\n\n// Dock represents a dock\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/app.md#appdockbouncetype-macos\ntype Dock struct {\n\t*object\n}\n\nfunc newDock(ctx context.Context, d *dispatcher, i *identifier, wrt *writer) *Dock {\n\treturn &Dock{object: newObject(ctx, d, i, wrt, targetIDDock)}\n}\n\n// Bounce bounces the dock\nfunc (d *Dock) Bounce(bounceType string) (id int, err error) {\n\tif err = d.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tvar e Event\n\tif e, err = synchronousEvent(d.ctx, d, d.w, Event{Name: eventNameDockCmdBounce, TargetID: d.id, BounceType: bounceType}, eventNameDockEventBouncing); err != nil {\n\t\treturn\n\t}\n\tif e.ID != nil {\n\t\tid = *e.ID\n\t}\n\treturn\n}\n\n// BounceDownloads bounces the downloads part of the dock\nfunc (d *Dock) BounceDownloads(filePath string) (err error) {\n\tif err = d.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(d.ctx, d, d.w, Event{Name: eventNameDockCmdBounceDownloads, TargetID: d.id, FilePath: filePath}, eventNameDockEventDownloadsBouncing)\n\treturn\n}\n\n// CancelBounce cancels the dock bounce\nfunc (d *Dock) CancelBounce(id int) (err error) {\n\tif err = d.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(d.ctx, d, d.w, Event{Name: eventNameDockCmdCancelBounce, TargetID: d.id, ID: astikit.IntPtr(id)}, eventNameDockEventBouncingCancelled)\n\treturn\n}\n\n// Hide hides the dock\nfunc (d *Dock) Hide() (err error) {\n\tif err = d.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(d.ctx, d, d.w, Event{Name: eventNameDockCmdHide, TargetID: d.id}, eventNameDockEventHidden)\n\treturn\n}\n\n// NewMenu creates a new dock menu\nfunc (d *Dock) NewMenu(i []*MenuItemOptions) *Menu {\n\treturn newMenu(d.ctx, d.id, i, d.d, d.i, d.w)\n}\n\n// SetBadge sets the badge of the dock\nfunc (d *Dock) SetBadge(badge string) (err error) {\n\tif err = d.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(d.ctx, d, d.w, Event{Name: eventNameDockCmdSetBadge, TargetID: d.id, Badge: &badge}, eventNameDockEventBadgeSet)\n\treturn\n}\n\n// SetIcon sets the icon of the dock\nfunc (d *Dock) SetIcon(image string) (err error) {\n\tif err = d.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(d.ctx, d, d.w, Event{Name: eventNameDockCmdSetIcon, TargetID: d.id, Image: image}, eventNameDockEventIconSet)\n\treturn\n}\n\n// Show shows the dock\nfunc (d *Dock) Show() (err error) {\n\tif err = d.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(d.ctx, d, d.w, Event{Name: eventNameDockCmdShow, TargetID: d.id}, eventNameDockEventShown)\n\treturn\n}\n"
        },
        {
          "name": "dock_test.go",
          "type": "blob",
          "size": 2.0693359375,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDock_Actions(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar i = newIdentifier()\n\tvar wrt = &mockedWriter{}\n\tvar w = newWriter(wrt, &logger{})\n\tvar dck = newDock(context.Background(), d, i, w)\n\n\t// Actions\n\ttestObjectAction(t, func() error {\n\t\t_, err := dck.Bounce(DockBounceTypeCritical)\n\t\treturn err\n\t}, dck.object, wrt, \"{\\\"name\\\":\\\"\"+eventNameDockCmdBounce+\"\\\",\\\"targetID\\\":\\\"\"+dck.id+\"\\\",\\\"bounceType\\\":\\\"critical\\\"}\\n\", eventNameDockEventBouncing, nil)\n\ttestObjectAction(t, func() error { return dck.BounceDownloads(\"/path/to/file\") }, dck.object, wrt, \"{\\\"name\\\":\\\"\"+eventNameDockCmdBounceDownloads+\"\\\",\\\"targetID\\\":\\\"\"+dck.id+\"\\\",\\\"filePath\\\":\\\"/path/to/file\\\"}\\n\", eventNameDockEventDownloadsBouncing, nil)\n\ttestObjectAction(t, func() error { return dck.CancelBounce(1) }, dck.object, wrt, \"{\\\"name\\\":\\\"\"+eventNameDockCmdCancelBounce+\"\\\",\\\"targetID\\\":\\\"\"+dck.id+\"\\\",\\\"id\\\":1}\\n\", eventNameDockEventBouncingCancelled, nil)\n\ttestObjectAction(t, func() error { return dck.Hide() }, dck.object, wrt, \"{\\\"name\\\":\\\"\"+eventNameDockCmdHide+\"\\\",\\\"targetID\\\":\\\"\"+dck.id+\"\\\"}\\n\", eventNameDockEventHidden, nil)\n\ttestObjectAction(t, func() error { return dck.SetBadge(\"badge\") }, dck.object, wrt, \"{\\\"name\\\":\\\"\"+eventNameDockCmdSetBadge+\"\\\",\\\"targetID\\\":\\\"\"+dck.id+\"\\\",\\\"badge\\\":\\\"badge\\\"}\\n\", eventNameDockEventBadgeSet, nil)\n\ttestObjectAction(t, func() error { return dck.SetIcon(\"/path/to/icon\") }, dck.object, wrt, \"{\\\"name\\\":\\\"\"+eventNameDockCmdSetIcon+\"\\\",\\\"targetID\\\":\\\"\"+dck.id+\"\\\",\\\"image\\\":\\\"/path/to/icon\\\"}\\n\", eventNameDockEventIconSet, nil)\n\ttestObjectAction(t, func() error { return dck.Show() }, dck.object, wrt, \"{\\\"name\\\":\\\"\"+eventNameDockCmdShow+\"\\\",\\\"targetID\\\":\\\"\"+dck.id+\"\\\"}\\n\", eventNameDockEventShown, nil)\n}\n\nfunc TestDock_NewMenu(t *testing.T) {\n\tvar d = newDispatcher()\n\tvar i = newIdentifier()\n\tvar wrt = &mockedWriter{}\n\tvar w = newWriter(wrt, &logger{})\n\tvar dck = newDock(context.Background(), d, i, w)\n\tm := dck.NewMenu([]*MenuItemOptions{})\n\tassert.Equal(t, dck.id, m.rootID)\n}\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 5.1943359375,
          "content": "package astilectron\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n)\n\n// Target IDs\nconst (\n\ttargetIDApp  = \"app\"\n\ttargetIDDock = \"dock\"\n)\n\n// Event represents an event\ntype Event struct {\n\t// This is the base of the event\n\tName     string `json:\"name\"`\n\tTargetID string `json:\"targetID,omitempty\"`\n\n\t// This is a list of all possible payloads.\n\t// A choice was made not to use interfaces since it's a pain in the ass asserting each an every payload afterwards\n\t// We use pointers so that omitempty works\n\tAuthInfo            *EventAuthInfo        `json:\"authInfo,omitempty\"`\n\tBadge               *string               `json:\"badge,omitempty\"`\n\tBounceType          string                `json:\"bounceType,omitempty\"`\n\tBounds              *RectangleOptions     `json:\"bounds,omitempty\"`\n\tCallbackID          string                `json:\"callbackId,omitempty\"`\n\tCode                string                `json:\"code,omitempty\"`\n\tDisplays            *EventDisplays        `json:\"displays,omitempty\"`\n\tEnable              *bool                 `json:\"enable,omitempty\"`\n\tFilePath            string                `json:\"filePath,omitempty\"`\n\tGlobalShortcuts     *EventGlobalShortcuts `json:\"globalShortcuts,omitempty\"`\n\tID                  *int                  `json:\"id,omitempty\"`\n\tImage               string                `json:\"image,omitempty\"`\n\tIndex               *int                  `json:\"index,omitempty\"`\n\tMenu                *EventMenu            `json:\"menu,omitempty\"`\n\tMenuItem            *EventMenuItem        `json:\"menuItem,omitempty\"`\n\tMenuItemOptions     *MenuItemOptions      `json:\"menuItemOptions,omitempty\"`\n\tMenuItemPosition    *int                  `json:\"menuItemPosition,omitempty\"`\n\tMenuPopupOptions    *MenuPopupOptions     `json:\"menuPopupOptions,omitempty\"`\n\tMessage             *EventMessage         `json:\"message,omitempty\"`\n\tNotificationOptions *NotificationOptions  `json:\"notificationOptions,omitempty\"`\n\tPassword            string                `json:\"password,omitempty\"`\n\tPath                string                `json:\"path,omitempty\"`\n\tReply               string                `json:\"reply,omitempty\"`\n\tRequest             *EventRequest         `json:\"request,omitempty\"`\n\tSecondInstance      *EventSecondInstance  `json:\"secondInstance,omitempty\"`\n\tSessionID           string                `json:\"sessionId,omitempty\"`\n\tSupported           *Supported            `json:\"supported,omitempty\"`\n\tTrayOptions         *TrayOptions          `json:\"trayOptions,omitempty\"`\n\tURL                 string                `json:\"url,omitempty\"`\n\tURLNew              string                `json:\"newUrl,omitempty\"`\n\tURLOld              string                `json:\"oldUrl,omitempty\"`\n\tUsername            string                `json:\"username,omitempty\"`\n\tWindowID            string                `json:\"windowId,omitempty\"`\n\tWindowOptions       *WindowOptions        `json:\"windowOptions,omitempty\"`\n}\n\n// EventAuthInfo represents an event auth info\ntype EventAuthInfo struct {\n\tHost    string `json:\"host,omitempty\"`\n\tIsProxy *bool  `json:\"isProxy,omitempty\"`\n\tPort    *int   `json:\"port,omitempty\"`\n\tRealm   string `json:\"realm,omitempty\"`\n\tScheme  string `json:\"scheme,omitempty\"`\n}\n\n// EventDisplays represents events displays\ntype EventDisplays struct {\n\tAll     []*DisplayOptions `json:\"all,omitempty\"`\n\tPrimary *DisplayOptions   `json:\"primary,omitempty\"`\n}\n\n// EventGlobalShortcuts represents event global shortcuts\ntype EventGlobalShortcuts struct {\n\tAccelerator  string `json:\"accelerator,omitempty\"`\n\tIsRegistered bool   `json:\"isRegistered,omitempty\"`\n}\n\n// EventMessage represents an event message\ntype EventMessage struct {\n\ti interface{}\n}\n\n// newEventMessage creates a new event message\nfunc newEventMessage(i interface{}) *EventMessage {\n\treturn &EventMessage{i: i}\n}\n\n// MarshalJSON implements the JSONMarshaler interface\nfunc (p *EventMessage) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(p.i)\n}\n\n// Unmarshal unmarshals the payload into the given interface\nfunc (p *EventMessage) Unmarshal(i interface{}) error {\n\tif b, ok := p.i.([]byte); ok {\n\t\treturn json.Unmarshal(b, i)\n\t}\n\treturn errors.New(\"event message should []byte\")\n}\n\n// UnmarshalJSON implements the JSONUnmarshaler interface\nfunc (p *EventMessage) UnmarshalJSON(i []byte) error {\n\tp.i = i\n\treturn nil\n}\n\n// EventMenu represents an event menu\ntype EventMenu struct {\n\t*EventSubMenu\n}\n\n// EventMenuItem represents an event menu item\ntype EventMenuItem struct {\n\tID      string           `json:\"id\"`\n\tOptions *MenuItemOptions `json:\"options,omitempty\"`\n\tRootID  string           `json:\"rootId\"`\n\tSubMenu *EventSubMenu    `json:\"submenu,omitempty\"`\n}\n\n// EventRequest represents an event request\ntype EventRequest struct {\n\tMethod   string `json:\"method,omitempty\"`\n\tReferrer string `json:\"referrer,omitempty\"`\n\tURL      string `json:\"url,omitempty\"`\n}\n\n// EventSecondInstance represents data related to a second instance of the app being started\ntype EventSecondInstance struct {\n\tCommandLine      []string `json:\"commandLine,omitempty\"`\n\tWorkingDirectory string   `json:\"workingDirectory,omitempty\"`\n}\n\n// EventSubMenu represents a sub menu event\ntype EventSubMenu struct {\n\tID     string           `json:\"id\"`\n\tItems  []*EventMenuItem `json:\"items,omitempty\"`\n\tRootID string           `json:\"rootId\"`\n}\n"
        },
        {
          "name": "event_test.go",
          "type": "blob",
          "size": 0.4912109375,
          "content": "package astilectron\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEventMessage(t *testing.T) {\n\t// Init\n\tvar em = newEventMessage(false)\n\n\t// Test marshal\n\tvar b, err = json.Marshal(em)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"false\", string(b))\n\n\t// Test unmarshal\n\terr = json.Unmarshal([]byte(\"true\"), em)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []byte(\"true\"), em.i)\n\tvar v bool\n\terr = em.Unmarshal(&v)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, v)\n}\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "executer.go",
          "type": "blob",
          "size": 0.6474609375,
          "content": "package astilectron\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// Executer represents an object capable of executing Astilectron run command\ntype Executer func(l astikit.SeverityLogger, a *Astilectron, cmd *exec.Cmd) (err error)\n\n// DefaultExecuter represents the default executer\nfunc DefaultExecuter(l astikit.SeverityLogger, a *Astilectron, cmd *exec.Cmd) (err error) {\n\t// Start command\n\tl.Debugf(\"Starting cmd %s\", strings.Join(cmd.Args, \" \"))\n\tif err = cmd.Start(); err != nil {\n\t\terr = fmt.Errorf(\"starting cmd %s failed: %w\", strings.Join(cmd.Args, \" \"), err)\n\t\treturn\n\t}\n\n\t// Watch command\n\tgo a.watchCmd(cmd)\n\treturn\n}\n"
        },
        {
          "name": "global_shortcuts.go",
          "type": "blob",
          "size": 4.0224609375,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\nconst (\n\tEventNameGlobalShortcutsCmdRegister          = \"global.shortcuts.cmd.register\"\n\tEventNameGlobalShortcutsCmdIsRegistered      = \"global.shortcuts.cmd.is.registered\"\n\tEventNameGlobalShortcutsCmdUnregister        = \"global.shortcuts.cmd.unregister\"\n\tEventNameGlobalShortcutsCmdUnregisterAll     = \"global.shortcuts.cmd.unregister.all\"\n\tEventNameGlobalShortcutsEventRegistered      = \"global.shortcuts.event.registered\"\n\tEventNameGlobalShortcutsEventIsRegistered    = \"global.shortcuts.event.is.registered\"\n\tEventNameGlobalShortcutsEventUnregistered    = \"global.shortcuts.event.unregistered\"\n\tEventNameGlobalShortcutsEventUnregisteredAll = \"global.shortcuts.event.unregistered.all\"\n\tEventNameGlobalShortcutEventTriggered        = \"global.shortcuts.event.triggered\"\n)\n\ntype globalShortcutsCallback func()\n\n// GlobalShortcuts represents global shortcuts\ntype GlobalShortcuts struct {\n\t*object\n\tm         *sync.Mutex\n\tcallbacks map[string]globalShortcutsCallback\n}\n\nfunc newGlobalShortcuts(ctx context.Context, d *dispatcher, i *identifier, w *writer) (gs *GlobalShortcuts) {\n\tgs = &GlobalShortcuts{\n\t\tobject:    newObject(ctx, d, i, w, i.new()),\n\t\tm:         new(sync.Mutex),\n\t\tcallbacks: make(map[string]globalShortcutsCallback),\n\t}\n\tgs.On(EventNameGlobalShortcutEventTriggered, func(e Event) (deleteListener bool) { // Register the listener for the triggered event\n\t\tgs.m.Lock()\n\t\tcallback, ok := gs.callbacks[e.GlobalShortcuts.Accelerator]\n\t\tgs.m.Unlock()\n\t\tif ok {\n\t\t\t(callback)()\n\t\t}\n\t\treturn\n\t})\n\treturn\n}\n\n// Register registers a global shortcut\nfunc (gs *GlobalShortcuts) Register(accelerator string, callback globalShortcutsCallback) (isRegistered bool, err error) {\n\tif err = gs.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\n\t// Send an event to astilectron to register the global shortcut\n\tresult, err := synchronousEvent(gs.ctx, gs, gs.w, Event{Name: EventNameGlobalShortcutsCmdRegister, TargetID: gs.id, GlobalShortcuts: &EventGlobalShortcuts{Accelerator: accelerator}}, EventNameGlobalShortcutsEventRegistered)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// If registered successfully, add the callback to the map\n\tif result.GlobalShortcuts != nil {\n\t\tif result.GlobalShortcuts.IsRegistered {\n\t\t\tgs.m.Lock()\n\t\t\tgs.callbacks[accelerator] = callback\n\t\t\tgs.m.Unlock()\n\t\t}\n\t\tisRegistered = result.GlobalShortcuts.IsRegistered\n\t}\n\treturn\n}\n\n// IsRegistered checks whether a global shortcut is registered\nfunc (gs *GlobalShortcuts) IsRegistered(accelerator string) (isRegistered bool, err error) {\n\tif err = gs.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\n\t// Send an event to astilectron to check if global shortcut is registered\n\tresult, err := synchronousEvent(gs.ctx, gs, gs.w, Event{Name: EventNameGlobalShortcutsCmdIsRegistered, TargetID: gs.id, GlobalShortcuts: &EventGlobalShortcuts{Accelerator: accelerator}}, EventNameGlobalShortcutsEventIsRegistered)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif result.GlobalShortcuts != nil {\n\t\tisRegistered = result.GlobalShortcuts.IsRegistered\n\t}\n\treturn\n}\n\n// Unregister unregisters a global shortcut\nfunc (gs *GlobalShortcuts) Unregister(accelerator string) (err error) {\n\tif err = gs.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\n\t// Send an event to astilectron to unregister the global shortcut\n\t_, err = synchronousEvent(gs.ctx, gs, gs.w, Event{Name: EventNameGlobalShortcutsCmdUnregister, TargetID: gs.id, GlobalShortcuts: &EventGlobalShortcuts{Accelerator: accelerator}}, EventNameGlobalShortcutsEventUnregistered)\n\tif err != nil {\n\t\treturn\n\t}\n\tgs.m.Lock()\n\tdelete(gs.callbacks, accelerator)\n\tgs.m.Unlock()\n\treturn\n}\n\n// UnregisterAll unregisters all global shortcuts\nfunc (gs *GlobalShortcuts) UnregisterAll() (err error) {\n\tif err = gs.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\n\t// Send an event to astilectron to unregister all global shortcuts\n\t_, err = synchronousEvent(gs.ctx, gs, gs.w, Event{Name: EventNameGlobalShortcutsCmdUnregisterAll, TargetID: gs.id}, EventNameGlobalShortcutsEventUnregisteredAll)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tgs.m.Lock()\n\tgs.callbacks = make(map[string]globalShortcutsCallback) // Clear the map\n\tgs.m.Unlock()\n\n\treturn\n}\n"
        },
        {
          "name": "global_shortcuts_test.go",
          "type": "blob",
          "size": 1.60546875,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestGlobalShortcut_Actions(t *testing.T) {\n\tvar d = newDispatcher()\n\tvar i = newIdentifier()\n\tvar wrt = &mockedWriter{}\n\tvar w = newWriter(wrt, &logger{})\n\n\tvar gs = newGlobalShortcuts(context.Background(), d, i, w)\n\n\t// Register\n\ttestObjectAction(t, func() error {\n\t\t_, e := gs.Register(\"Ctrl+X\", func() {})\n\t\treturn e\n\t}, gs.object, wrt, fmt.Sprintf(`{\"name\":\"%s\",\"targetID\":\"%s\",\"globalShortcuts\":{\"accelerator\":\"Ctrl+X\"}}%s`, EventNameGlobalShortcutsCmdRegister, gs.id, \"\\n\"),\n\t\tEventNameGlobalShortcutsEventRegistered, &Event{GlobalShortcuts: &EventGlobalShortcuts{Accelerator: \"Ctrl+X\", IsRegistered: true}})\n\n\t// IsRegistered\n\ttestObjectAction(t, func() error {\n\t\t_, e := gs.IsRegistered(\"Ctrl+Y\")\n\t\treturn e\n\t}, gs.object, wrt, fmt.Sprintf(`{\"name\":\"%s\",\"targetID\":\"%s\",\"globalShortcuts\":{\"accelerator\":\"Ctrl+Y\"}}%s`, EventNameGlobalShortcutsCmdIsRegistered, gs.id, \"\\n\"),\n\t\tEventNameGlobalShortcutsEventIsRegistered, &Event{GlobalShortcuts: &EventGlobalShortcuts{Accelerator: \"Ctrl+Y\", IsRegistered: false}})\n\n\t// Unregister\n\ttestObjectAction(t, func() error {\n\t\treturn gs.Unregister(\"Ctrl+Z\")\n\t}, gs.object, wrt, fmt.Sprintf(`{\"name\":\"%s\",\"targetID\":\"%s\",\"globalShortcuts\":{\"accelerator\":\"Ctrl+Z\"}}%s`, EventNameGlobalShortcutsCmdUnregister, gs.id, \"\\n\"),\n\t\tEventNameGlobalShortcutsEventUnregistered, nil)\n\n\t// UnregisterAll\n\ttestObjectAction(t, func() error {\n\t\treturn gs.UnregisterAll()\n\t}, gs.object, wrt, fmt.Sprintf(`{\"name\":\"%s\",\"targetID\":\"%s\"}%s`, EventNameGlobalShortcutsCmdUnregisterAll, gs.id, \"\\n\"),\n\t\tEventNameGlobalShortcutsEventUnregisteredAll, nil)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.13671875,
          "content": "module github.com/asticode/go-astilectron\n\ngo 1.13\n\nrequire (\n\tgithub.com/asticode/go-astikit v0.29.1\n\tgithub.com/stretchr/testify v1.4.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.1220703125,
          "content": "github.com/asticode/go-astikit v0.29.1 h1:w27sLYXK84mDwArf/Vw1BiD5dfD5PBDB+iHoIcpYq0w=\ngithub.com/asticode/go-astikit v0.29.1/go.mod h1:h4ly7idim1tNhaVkdVBeXQZEE3L0xblP7fCWbgwipF0=\ngithub.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n"
        },
        {
          "name": "helper.go",
          "type": "blob",
          "size": 4.078125,
          "content": "package astilectron\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// Download is a cancellable function that downloads a src into a dst using a specific *http.Client and cleans up on\n// failed downloads\nfunc Download(ctx context.Context, l astikit.SeverityLogger, d *astikit.HTTPDownloader, src, dst string) (err error) {\n\t// Log\n\tl.Debugf(\"Downloading %s into %s\", src, dst)\n\n\t// Destination already exists\n\tif _, err = os.Stat(dst); err == nil {\n\t\tl.Debugf(\"%s already exists, skipping download...\", dst)\n\t\treturn\n\t} else if !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"stating %s failed: %w\", dst, err)\n\t}\n\terr = nil\n\n\t// Clean up on error\n\tdefer func(err *error) {\n\t\tif *err != nil || ctx.Err() != nil {\n\t\t\tl.Debugf(\"Removing %s...\", dst)\n\t\t\tos.Remove(dst)\n\t\t}\n\t}(&err)\n\n\t// Make sure the dst directory  exists\n\tif err = os.MkdirAll(filepath.Dir(dst), 0775); err != nil {\n\t\treturn fmt.Errorf(\"mkdirall %s failed: %w\", filepath.Dir(dst), err)\n\t}\n\n\t// Download\n\tif err = d.DownloadInFile(ctx, dst, astikit.HTTPDownloaderSrc{URL: src}); err != nil {\n\t\treturn fmt.Errorf(\"DownloadInFile failed: %w\", err)\n\t}\n\treturn\n}\n\n// Disembed is a cancellable disembed of an src to a dst using a custom Disembedder\nfunc Disembed(ctx context.Context, l astikit.SeverityLogger, d Disembedder, src, dst string) (err error) {\n\t// Log\n\tl.Debugf(\"Disembedding %s into %s...\", src, dst)\n\n\t// No need to disembed\n\tif _, err = os.Stat(dst); err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"stating %s failed: %w\", dst, err)\n\t} else if err == nil {\n\t\tl.Debugf(\"%s already exists, skipping disembed...\", dst)\n\t\treturn\n\t}\n\terr = nil\n\n\t// Clean up on error\n\tdefer func(err *error) {\n\t\tif *err != nil || ctx.Err() != nil {\n\t\t\tl.Debugf(\"Removing %s...\", dst)\n\t\t\tos.Remove(dst)\n\t\t}\n\t}(&err)\n\n\t// Make sure directory exists\n\tvar dirPath = filepath.Dir(dst)\n\tl.Debugf(\"Creating %s\", dirPath)\n\tif err = os.MkdirAll(dirPath, 0755); err != nil {\n\t\treturn fmt.Errorf(\"mkdirall %s failed: %w\", dirPath, err)\n\t}\n\n\t// Create dst\n\tvar f *os.File\n\tl.Debugf(\"Creating %s\", dst)\n\tif f, err = os.Create(dst); err != nil {\n\t\treturn fmt.Errorf(\"creating %s failed: %w\", dst, err)\n\t}\n\tdefer f.Close()\n\n\t// Disembed\n\tvar b []byte\n\tl.Debugf(\"Disembedding %s\", src)\n\tif b, err = d(src); err != nil {\n\t\treturn fmt.Errorf(\"disembedding %s failed: %w\", src, err)\n\t}\n\n\t// Copy\n\tl.Debugf(\"Copying disembedded data to %s\", dst)\n\tif _, err = astikit.Copy(ctx, f, bytes.NewReader(b)); err != nil {\n\t\treturn fmt.Errorf(\"copying disembedded data into %s failed: %w\", dst, err)\n\t}\n\treturn\n}\n\n// Unzip unzips a src into a dst.\n// Possible src formats are /path/to/zip.zip or /path/to/zip.zip/internal/path.\nfunc Unzip(ctx context.Context, l astikit.SeverityLogger, src, dst string) (err error) {\n\t// Clean up on error\n\tdefer func(err *error) {\n\t\tif *err != nil || ctx.Err() != nil {\n\t\t\tl.Debugf(\"Removing %s...\", dst)\n\t\t\tos.RemoveAll(dst)\n\t\t}\n\t}(&err)\n\n\t// Unzipping\n\tl.Debugf(\"Unzipping %s into %s\", src, dst)\n\tif err = astikit.Unzip(ctx, dst, src); err != nil {\n\t\terr = fmt.Errorf(\"unzipping %s into %s failed: %w\", src, dst, err)\n\t\treturn\n\t}\n\treturn\n}\n\n// synchronousFunc executes a function, blocks until it has received a specific event or the context has been\n// cancelled and returns the corresponding event\nfunc synchronousFunc(parentCtx context.Context, l listenable, fn func() error, eventNameDone string) (e Event, err error) {\n\tctx, cancel := context.WithCancel(parentCtx)\n\tdefer cancel()\n\tl.On(eventNameDone, func(i Event) (deleteListener bool) {\n\t\tif ctx.Err() == nil {\n\t\t\te = i\n\t\t}\n\t\tcancel()\n\t\treturn true\n\t})\n\tif fn != nil {\n\t\tif err = fn(); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\t<-ctx.Done()\n\treturn\n}\n\n// synchronousEvent sends an event, blocks until it has received a specific event or the context has been cancelled\n// and returns the corresponding event\nfunc synchronousEvent(ctx context.Context, l listenable, w *writer, i Event, eventNameDone string) (Event, error) {\n\treturn synchronousFunc(ctx, l, func() (err error) {\n\t\tif err = w.write(i); err != nil {\n\t\t\terr = fmt.Errorf(\"writing %+v event failed: %w\", i, err)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}, eventNameDone)\n}\n"
        },
        {
          "name": "helper_test.go",
          "type": "blob",
          "size": 4.693359375,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/asticode/go-astikit\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// mockedHandler is a mocked handler\ntype mockedHandler struct {\n\te bool\n}\n\nfunc (h *mockedHandler) readFile(rw http.ResponseWriter, path string) {\n\tvar b, err = ioutil.ReadFile(path)\n\tif err != nil {\n\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\trw.Write(b)\n}\n\n// ServeHTTP implements the http.Handler interface\nfunc (h *mockedHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\tif h.e {\n\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tswitch r.URL.Path {\n\tcase \"/provisioner/astilectron\":\n\t\th.readFile(rw, \"testdata/provisioner/astilectron/astilectron.zip\")\n\tcase \"/provisioner/electron/darwin\":\n\t\th.readFile(rw, \"testdata/provisioner/electron/darwin/electron.zip\")\n\tcase \"/provisioner/electron/linux\":\n\t\th.readFile(rw, \"testdata/provisioner/electron/linux/electron.zip\")\n\tcase \"/provisioner/electron/windows\":\n\t\th.readFile(rw, \"testdata/provisioner/electron/windows/electron.zip\")\n\tdefault:\n\t\trw.Write([]byte(\"body\"))\n\t}\n}\n\nvar tempPathCount int\n\nfunc mockedTempPath() string {\n\ttempPathCount++\n\treturn fmt.Sprintf(\"testdata/tmp/%d\", tempPathCount)\n}\n\nfunc TestDownload(t *testing.T) {\n\t// Init\n\tvar mh = &mockedHandler{e: true}\n\tvar s = httptest.NewServer(mh)\n\tvar dst = mockedTempPath()\n\tvar d = astikit.NewHTTPDownloader(astikit.HTTPDownloaderOptions{})\n\n\t// Test failed download\n\terr := Download(context.Background(), &logger{}, d, s.URL, dst)\n\tassert.Error(t, err)\n\t_, err = os.Stat(dst)\n\tassert.True(t, os.IsNotExist(err))\n\n\t// Test successful download\n\tmh.e = false\n\terr = Download(context.Background(), &logger{}, d, s.URL, dst)\n\tassert.NoError(t, err)\n\tdefer os.Remove(dst)\n\tb, err := ioutil.ReadFile(dst)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"body\", string(b))\n}\n\n// mockedDisembedder is a mocked disembedder\nfunc mockedDisembedder(src string) ([]byte, error) {\n\tswitch src {\n\tcase \"astilectron\":\n\t\treturn ioutil.ReadFile(\"testdata/provisioner/astilectron/disembedder.zip\")\n\tcase \"electron/linux\":\n\t\treturn ioutil.ReadFile(\"testdata/provisioner/electron/linux/electron.zip\")\n\tcase \"test\":\n\t\treturn []byte(\"body\"), nil\n\tdefault:\n\t\treturn []byte{}, errors.New(\"invalid\")\n\t}\n}\n\nfunc TestDisembed(t *testing.T) {\n\t// Init\n\tvar dst = mockedTempPath()\n\n\t// Test failed disembed\n\terr := Disembed(context.Background(), &logger{}, mockedDisembedder, \"invalid\", dst)\n\tassert.EqualError(t, err, \"disembedding invalid failed: invalid\")\n\n\t// Test successful disembed\n\terr = Disembed(context.Background(), &logger{}, mockedDisembedder, \"test\", dst)\n\tassert.NoError(t, err)\n\tdefer os.Remove(dst)\n\tb, err := ioutil.ReadFile(dst)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"body\", string(b))\n}\n\nfunc TestPtr(t *testing.T) {\n\tassert.Equal(t, true, *astikit.BoolPtr(true))\n\tassert.Equal(t, 1, *astikit.IntPtr(1))\n\tassert.Equal(t, \"1\", *astikit.StrPtr(\"1\"))\n}\n\n// mockedListenable is a mocked listenable\ntype mockedListenable struct {\n\td  *dispatcher\n\tid string\n}\n\n// On implements the listenable interface\nfunc (m *mockedListenable) On(eventName string, l Listener) {\n\tm.d.addListener(m.id, eventName, l)\n}\n\nfunc TestSynchronousFunc(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar l = &mockedListenable{d: d, id: \"1\"}\n\tvar done bool\n\tvar m sync.Mutex\n\tl.On(\"done\", func(e Event) bool {\n\t\tm.Lock()\n\t\tdefer m.Unlock()\n\t\tdone = true\n\t\treturn false\n\t})\n\n\t// Test canceller cancel\n\tctx, cancel := context.WithCancel(context.Background())\n\tsynchronousFunc(ctx, l, func() error {\n\t\tcancel()\n\t\treturn nil\n\t}, \"done\")\n\tassert.False(t, done)\n\n\t// Test done event\n\tvar ed = Event{Name: \"done\", TargetID: \"1\"}\n\te, err := synchronousFunc(context.Background(), l, func() error {\n\t\td.dispatch(ed)\n\t\treturn nil\n\t}, \"done\")\n\tassert.NoError(t, err)\n\tm.Lock()\n\tassert.True(t, done)\n\tm.Unlock()\n\tassert.Equal(t, ed, e)\n\n\t// Test error\n\t_, err = synchronousFunc(context.Background(), l, func() error { return errors.New(\"invalid\") }, \"done\")\n\tassert.Error(t, err)\n}\n\nfunc TestSynchronousEvent(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar ed = Event{Name: \"done\", TargetID: \"1\"}\n\tvar mw = &mockedWriter{fn: func() { d.dispatch(ed) }}\n\tvar w = newWriter(mw, &logger{})\n\tvar l = &mockedListenable{d: d, id: \"1\"}\n\tvar done bool\n\tvar m sync.Mutex\n\tl.On(\"done\", func(e Event) bool {\n\t\tm.Lock()\n\t\tdefer m.Unlock()\n\t\tdone = true\n\t\treturn false\n\t})\n\tvar ei = Event{Name: \"order\", TargetID: \"1\"}\n\n\t// Test successful synchronous event\n\tvar e, err = synchronousEvent(context.Background(), l, w, ei, \"done\")\n\tassert.NoError(t, err)\n\tm.Lock()\n\tassert.True(t, done)\n\tm.Unlock()\n\tassert.Equal(t, ed, e)\n\tassert.Equal(t, []string{\"{\\\"name\\\":\\\"order\\\",\\\"targetID\\\":\\\"1\\\"}\\n\"}, mw.w)\n}\n"
        },
        {
          "name": "identifier.go",
          "type": "blob",
          "size": 0.4130859375,
          "content": "package astilectron\n\nimport (\n\t\"strconv\"\n\t\"sync\"\n)\n\n// identifier is in charge of delivering a unique identifier\ntype identifier struct {\n\ti int\n\tm *sync.Mutex\n}\n\n// newIdentifier creates a new identifier\nfunc newIdentifier() *identifier {\n\treturn &identifier{m: &sync.Mutex{}}\n}\n\n// new returns a new unique identifier\nfunc (i *identifier) new() string {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\ti.i++\n\treturn strconv.Itoa(i.i)\n}\n"
        },
        {
          "name": "identifier_test.go",
          "type": "blob",
          "size": 0.2333984375,
          "content": "package astilectron\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIdentifier(t *testing.T) {\n\tvar i = newIdentifier()\n\tassert.Equal(t, \"1\", i.new())\n\tassert.Equal(t, \"2\", i.new())\n\tassert.Equal(t, \"3\", i.new())\n}\n"
        },
        {
          "name": "menu.go",
          "type": "blob",
          "size": 1.4609375,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n)\n\n// Menu event names\nconst (\n\tEventNameMenuCmdCreate      = \"menu.cmd.create\"\n\tEventNameMenuCmdDestroy     = \"menu.cmd.destroy\"\n\tEventNameMenuEventCreated   = \"menu.event.created\"\n\tEventNameMenuEventDestroyed = \"menu.event.destroyed\"\n)\n\n// Menu represents a menu\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/menu.md\ntype Menu struct {\n\t*subMenu\n}\n\n// newMenu creates a new menu\nfunc newMenu(ctx context.Context, rootID string, items []*MenuItemOptions, d *dispatcher, i *identifier, w *writer) (m *Menu) {\n\t// Init\n\tm = &Menu{newSubMenu(ctx, rootID, items, d, i, w)}\n\n\t// Make sure the menu's context is cancelled once the destroyed event is received\n\tm.On(EventNameMenuEventDestroyed, func(e Event) (deleteListener bool) {\n\t\tm.cancel()\n\t\treturn true\n\t})\n\treturn\n}\n\n// toEvent returns the menu in the proper event format\nfunc (m *Menu) toEvent() *EventMenu {\n\treturn &EventMenu{m.subMenu.toEvent()}\n}\n\n// Create creates the menu\nfunc (m *Menu) Create() (err error) {\n\tif err = m.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(m.ctx, m, m.w, Event{Name: EventNameMenuCmdCreate, TargetID: m.id, Menu: m.toEvent()}, EventNameMenuEventCreated)\n\treturn\n}\n\n// Destroy destroys the menu\nfunc (m *Menu) Destroy() (err error) {\n\tif err = m.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(m.ctx, m, m.w, Event{Name: EventNameMenuCmdDestroy, TargetID: m.id, Menu: m.toEvent()}, EventNameMenuEventDestroyed)\n\treturn\n}\n"
        },
        {
          "name": "menu_item.go",
          "type": "blob",
          "size": 6.205078125,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// Menu item event names\nconst (\n\tEventNameMenuItemCmdSetChecked   = \"menu.item.cmd.set.checked\"\n\tEventNameMenuItemCmdSetEnabled   = \"menu.item.cmd.set.enabled\"\n\tEventNameMenuItemCmdSetLabel     = \"menu.item.cmd.set.label\"\n\tEventNameMenuItemCmdSetVisible   = \"menu.item.cmd.set.visible\"\n\tEventNameMenuItemEventCheckedSet = \"menu.item.event.checked.set\"\n\tEventNameMenuItemEventClicked    = \"menu.item.event.clicked\"\n\tEventNameMenuItemEventEnabledSet = \"menu.item.event.enabled.set\"\n\tEventNameMenuItemEventLabelSet   = \"menu.item.event.label.set\"\n\tEventNameMenuItemEventVisibleSet = \"menu.item.event.visible.set\"\n)\n\n// Menu item roles\nvar (\n\t// All\n\tMenuItemRoleClose              = astikit.StrPtr(\"close\")\n\tMenuItemRoleCopy               = astikit.StrPtr(\"copy\")\n\tMenuItemRoleCut                = astikit.StrPtr(\"cut\")\n\tMenuItemRoleDelete             = astikit.StrPtr(\"delete\")\n\tMenuItemRoleEditMenu           = astikit.StrPtr(\"editMenu\")\n\tMenuItemRoleForceReload        = astikit.StrPtr(\"forcereload\")\n\tMenuItemRoleMinimize           = astikit.StrPtr(\"minimize\")\n\tMenuItemRolePaste              = astikit.StrPtr(\"paste\")\n\tMenuItemRolePasteAndMatchStyle = astikit.StrPtr(\"pasteandmatchstyle\")\n\tMenuItemRoleQuit               = astikit.StrPtr(\"quit\")\n\tMenuItemRoleRedo               = astikit.StrPtr(\"redo\")\n\tMenuItemRoleReload             = astikit.StrPtr(\"reload\")\n\tMenuItemRoleResetZoom          = astikit.StrPtr(\"resetzoom\")\n\tMenuItemRoleSelectAll          = astikit.StrPtr(\"selectall\")\n\tMenuItemRoleToggleDevTools     = astikit.StrPtr(\"toggledevtools\")\n\tMenuItemRoleToggleFullScreen   = astikit.StrPtr(\"togglefullscreen\")\n\tMenuItemRoleUndo               = astikit.StrPtr(\"undo\")\n\tMenuItemRoleWindowMenu         = astikit.StrPtr(\"windowMenu\")\n\tMenuItemRoleZoomOut            = astikit.StrPtr(\"zoomout\")\n\tMenuItemRoleZoomIn             = astikit.StrPtr(\"zoomin\")\n\n\t// MacOSX\n\tMenuItemRoleAbout         = astikit.StrPtr(\"about\")\n\tMenuItemRoleHide          = astikit.StrPtr(\"hide\")\n\tMenuItemRoleHideOthers    = astikit.StrPtr(\"hideothers\")\n\tMenuItemRoleUnhide        = astikit.StrPtr(\"unhide\")\n\tMenuItemRoleStartSpeaking = astikit.StrPtr(\"startspeaking\")\n\tMenuItemRoleStopSpeaking  = astikit.StrPtr(\"stopspeaking\")\n\tMenuItemRoleFront         = astikit.StrPtr(\"front\")\n\tMenuItemRoleZoom          = astikit.StrPtr(\"zoom\")\n\tMenuItemRoleWindow        = astikit.StrPtr(\"window\")\n\tMenuItemRoleHelp          = astikit.StrPtr(\"help\")\n\tMenuItemRoleServices      = astikit.StrPtr(\"services\")\n)\n\n// Menu item types\nvar (\n\tMenuItemTypeNormal    = astikit.StrPtr(\"normal\")\n\tMenuItemTypeSeparator = astikit.StrPtr(\"separator\")\n\tMenuItemTypeCheckbox  = astikit.StrPtr(\"checkbox\")\n\tMenuItemTypeRadio     = astikit.StrPtr(\"radio\")\n)\n\n// MenuItem represents a menu item\ntype MenuItem struct {\n\t*object\n\to *MenuItemOptions\n\t// We must store the root ID since everytime we update a sub menu we need to set the root menu all over again in electron\n\trootID string\n\ts      *SubMenu\n}\n\n// MenuItemOptions represents menu item options\n// We must use pointers since GO doesn't handle optional fields whereas NodeJS does. Use astikit.BoolPtr, astikit.IntPtr or astikit.StrPtr\n// to fill the struct\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/menu-item.md\ntype MenuItemOptions struct {\n\tAccelerator *Accelerator       `json:\"accelerator,omitempty\"`\n\tChecked     *bool              `json:\"checked,omitempty\"`\n\tEnabled     *bool              `json:\"enabled,omitempty\"`\n\tIcon        *string            `json:\"icon,omitempty\"`\n\tLabel       *string            `json:\"label,omitempty\"`\n\tOnClick     Listener           `json:\"-\"`\n\tPosition    *string            `json:\"position,omitempty\"`\n\tRole        *string            `json:\"role,omitempty\"`\n\tSubLabel    *string            `json:\"sublabel,omitempty\"`\n\tSubMenu     []*MenuItemOptions `json:\"-\"`\n\tType        *string            `json:\"type,omitempty\"`\n\tVisible     *bool              `json:\"visible,omitempty\"`\n}\n\n// newMenu creates a new menu item\nfunc newMenuItem(ctx context.Context, rootID string, o *MenuItemOptions, d *dispatcher, i *identifier, w *writer) (m *MenuItem) {\n\tm = &MenuItem{\n\t\to:      o,\n\t\tobject: newObject(ctx, d, i, w, i.new()),\n\t\trootID: rootID,\n\t}\n\tif o.OnClick != nil {\n\t\tm.On(EventNameMenuItemEventClicked, o.OnClick)\n\t}\n\tif len(o.SubMenu) > 0 {\n\t\tm.s = &SubMenu{newSubMenu(ctx, rootID, o.SubMenu, d, i, w)}\n\t}\n\treturn\n}\n\n// toEvent returns the menu item in the proper event format\nfunc (i *MenuItem) toEvent() (e *EventMenuItem) {\n\te = &EventMenuItem{\n\t\tID:      i.id,\n\t\tOptions: i.o,\n\t\tRootID:  i.rootID,\n\t}\n\tif i.s != nil {\n\t\te.SubMenu = i.s.toEvent()\n\t}\n\treturn\n}\n\n// SubMenu returns the menu item sub menu\nfunc (i *MenuItem) SubMenu() *SubMenu {\n\treturn i.s\n}\n\n// SetChecked sets the checked attribute\nfunc (i *MenuItem) SetChecked(checked bool) (err error) {\n\tif err = i.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\ti.o.Checked = astikit.BoolPtr(checked)\n\t_, err = synchronousEvent(i.ctx, i, i.w, Event{Name: EventNameMenuItemCmdSetChecked, TargetID: i.id, MenuItemOptions: &MenuItemOptions{Checked: i.o.Checked}}, EventNameMenuItemEventCheckedSet)\n\treturn\n}\n\n// SetEnabled sets the enabled attribute\nfunc (i *MenuItem) SetEnabled(enabled bool) (err error) {\n\tif err = i.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\ti.o.Enabled = astikit.BoolPtr(enabled)\n\t_, err = synchronousEvent(i.ctx, i, i.w, Event{Name: EventNameMenuItemCmdSetEnabled, TargetID: i.id, MenuItemOptions: &MenuItemOptions{Enabled: i.o.Enabled}}, EventNameMenuItemEventEnabledSet)\n\treturn\n}\n\n// SetLabel sets the label attribute\nfunc (i *MenuItem) SetLabel(label string) (err error) {\n\tif err = i.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\ti.o.Label = astikit.StrPtr(label)\n\t_, err = synchronousEvent(i.ctx, i, i.w, Event{Name: EventNameMenuItemCmdSetLabel, TargetID: i.id, MenuItemOptions: &MenuItemOptions{Label: i.o.Label}}, EventNameMenuItemEventLabelSet)\n\treturn\n}\n\n// SetVisible sets the visible attribute\nfunc (i *MenuItem) SetVisible(visible bool) (err error) {\n\tif err = i.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\ti.o.Visible = astikit.BoolPtr(visible)\n\t_, err = synchronousEvent(i.ctx, i, i.w, Event{Name: EventNameMenuItemCmdSetVisible, TargetID: i.id, MenuItemOptions: &MenuItemOptions{Visible: i.o.Visible}}, EventNameMenuItemEventVisibleSet)\n\treturn\n}\n"
        },
        {
          "name": "menu_item_test.go",
          "type": "blob",
          "size": 2.00390625,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/asticode/go-astikit\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMenuItem_ToEvent(t *testing.T) {\n\tvar o = &MenuItemOptions{Label: astikit.StrPtr(\"1\"), SubMenu: []*MenuItemOptions{{Label: astikit.StrPtr(\"2\")}, {Label: astikit.StrPtr(\"3\")}}}\n\tvar mi = newMenuItem(context.Background(), targetIDApp, o, nil, newIdentifier(), nil)\n\te := mi.toEvent()\n\tassert.Equal(t, &EventMenuItem{ID: \"1\", RootID: targetIDApp, Options: o, SubMenu: &EventSubMenu{ID: \"2\", Items: []*EventMenuItem{{ID: \"3\", Options: &MenuItemOptions{Label: astikit.StrPtr(\"2\")}, RootID: targetIDApp}, {ID: \"4\", Options: &MenuItemOptions{Label: astikit.StrPtr(\"3\")}, RootID: targetIDApp}}, RootID: targetIDApp}}, e)\n\tassert.Len(t, mi.SubMenu().items, 2)\n}\n\nfunc TestMenuItem_Actions(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar i = newIdentifier()\n\tvar wrt = &mockedWriter{}\n\tvar w = newWriter(wrt, &logger{})\n\tvar mi = newMenuItem(context.Background(), targetIDApp, &MenuItemOptions{Label: astikit.StrPtr(\"label\")}, d, i, w)\n\n\t// Actions\n\ttestObjectAction(t, func() error { return mi.SetChecked(true) }, mi.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameMenuItemCmdSetChecked+\"\\\",\\\"targetID\\\":\\\"\"+mi.id+\"\\\",\\\"menuItemOptions\\\":{\\\"checked\\\":true}}\\n\", EventNameMenuItemEventCheckedSet, nil)\n\ttestObjectAction(t, func() error { return mi.SetEnabled(true) }, mi.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameMenuItemCmdSetEnabled+\"\\\",\\\"targetID\\\":\\\"\"+mi.id+\"\\\",\\\"menuItemOptions\\\":{\\\"enabled\\\":true}}\\n\", EventNameMenuItemEventEnabledSet, nil)\n\ttestObjectAction(t, func() error { return mi.SetLabel(\"test\") }, mi.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameMenuItemCmdSetLabel+\"\\\",\\\"targetID\\\":\\\"\"+mi.id+\"\\\",\\\"menuItemOptions\\\":{\\\"label\\\":\\\"test\\\"}}\\n\", EventNameMenuItemEventLabelSet, nil)\n\ttestObjectAction(t, func() error { return mi.SetVisible(true) }, mi.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameMenuItemCmdSetVisible+\"\\\",\\\"targetID\\\":\\\"\"+mi.id+\"\\\",\\\"menuItemOptions\\\":{\\\"visible\\\":true}}\\n\", EventNameMenuItemEventVisibleSet, nil)\n\n}\n"
        },
        {
          "name": "menu_test.go",
          "type": "blob",
          "size": 1.7529296875,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/asticode/go-astikit\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMenu_ToEvent(t *testing.T) {\n\tvar m = newMenu(context.Background(), targetIDApp, []*MenuItemOptions{{Label: astikit.StrPtr(\"1\")}, {Label: astikit.StrPtr(\"2\")}}, newDispatcher(), newIdentifier(), nil)\n\te := m.toEvent()\n\tassert.Equal(t, &EventMenu{EventSubMenu: &EventSubMenu{ID: \"1\", Items: []*EventMenuItem{{ID: \"2\", Options: &MenuItemOptions{Label: astikit.StrPtr(\"1\")}, RootID: targetIDApp}, {ID: \"3\", Options: &MenuItemOptions{Label: astikit.StrPtr(\"2\")}, RootID: targetIDApp}}, RootID: targetIDApp}}, e)\n}\n\nfunc TestMenu_Actions(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar i = newIdentifier()\n\tvar wrt = &mockedWriter{}\n\tvar w = newWriter(wrt, &logger{})\n\tvar m = newMenu(context.Background(), targetIDApp, []*MenuItemOptions{{Label: astikit.StrPtr(\"1\")}, {Label: astikit.StrPtr(\"2\")}}, d, i, w)\n\n\t// Actions\n\ttestObjectAction(t, func() error { return m.Create() }, m.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameMenuCmdCreate+\"\\\",\\\"targetID\\\":\\\"\"+m.id+\"\\\",\\\"menu\\\":{\\\"id\\\":\\\"1\\\",\\\"items\\\":[{\\\"id\\\":\\\"2\\\",\\\"options\\\":{\\\"label\\\":\\\"1\\\"},\\\"rootId\\\":\\\"\"+targetIDApp+\"\\\"},{\\\"id\\\":\\\"3\\\",\\\"options\\\":{\\\"label\\\":\\\"2\\\"},\\\"rootId\\\":\\\"\"+targetIDApp+\"\\\"}],\\\"rootId\\\":\\\"\"+targetIDApp+\"\\\"}}\\n\", EventNameMenuEventCreated, nil)\n\ttestObjectAction(t, func() error { return m.Destroy() }, m.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameMenuCmdDestroy+\"\\\",\\\"targetID\\\":\\\"\"+m.id+\"\\\",\\\"menu\\\":{\\\"id\\\":\\\"1\\\",\\\"items\\\":[{\\\"id\\\":\\\"2\\\",\\\"options\\\":{\\\"label\\\":\\\"1\\\"},\\\"rootId\\\":\\\"\"+targetIDApp+\"\\\"},{\\\"id\\\":\\\"3\\\",\\\"options\\\":{\\\"label\\\":\\\"2\\\"},\\\"rootId\\\":\\\"\"+targetIDApp+\"\\\"}],\\\"rootId\\\":\\\"\"+targetIDApp+\"\\\"}}\\n\", EventNameMenuEventDestroyed, nil)\n\tassert.True(t, m.ctx.Err() != nil)\n}\n"
        },
        {
          "name": "notification.go",
          "type": "blob",
          "size": 2.1025390625,
          "content": "package astilectron\n\nimport \"context\"\n\n// Notification event names\nconst (\n\teventNameNotificationCmdCreate    = \"notification.cmd.create\"\n\teventNameNotificationCmdShow      = \"notification.cmd.show\"\n\tEventNameNotificationEventClicked = \"notification.event.clicked\"\n\tEventNameNotificationEventClosed  = \"notification.event.closed\"\n\tEventNameNotificationEventCreated = \"notification.event.created\"\n\tEventNameNotificationEventReplied = \"notification.event.replied\"\n\tEventNameNotificationEventShown   = \"notification.event.shown\"\n)\n\n// Notification represents a notification\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/notification.md\ntype Notification struct {\n\tisSupported bool\n\to           *NotificationOptions\n\t*object\n}\n\n// NotificationOptions represents notification options\ntype NotificationOptions struct {\n\tBody             string `json:\"body,omitempty\"`\n\tHasReply         *bool  `json:\"hasReply,omitempty\"`\n\tIcon             string `json:\"icon,omitempty\"`\n\tReplyPlaceholder string `json:\"replyPlaceholder,omitempty\"`\n\tSilent           *bool  `json:\"silent,omitempty\"`\n\tSound            string `json:\"sound,omitempty\"`\n\tSubtitle         string `json:\"subtitle,omitempty\"`\n\tTitle            string `json:\"title,omitempty\"`\n}\n\nfunc newNotification(ctx context.Context, o *NotificationOptions, isSupported bool, d *dispatcher, i *identifier, wrt *writer) *Notification {\n\treturn &Notification{\n\t\tisSupported: isSupported,\n\t\to:           o,\n\t\tobject:      newObject(ctx, d, i, wrt, i.new()),\n\t}\n}\n\n// Create creates the notification\nfunc (n *Notification) Create() (err error) {\n\tif !n.isSupported {\n\t\treturn\n\t}\n\tif err = n.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(n.ctx, n, n.w, Event{Name: eventNameNotificationCmdCreate, TargetID: n.id, NotificationOptions: n.o}, EventNameNotificationEventCreated)\n\treturn\n}\n\n// Show shows the notification\nfunc (n *Notification) Show() (err error) {\n\tif !n.isSupported {\n\t\treturn\n\t}\n\tif err = n.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(n.ctx, n, n.w, Event{Name: eventNameNotificationCmdShow, TargetID: n.id}, EventNameNotificationEventShown)\n\treturn\n}\n"
        },
        {
          "name": "notification_test.go",
          "type": "blob",
          "size": 1.1953125,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\nfunc TestNotification_Actions(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar i = newIdentifier()\n\tvar wrt = &mockedWriter{}\n\tvar w = newWriter(wrt, &logger{})\n\tvar n = newNotification(context.Background(), &NotificationOptions{\n\t\tBody:             \"body\",\n\t\tHasReply:         astikit.BoolPtr(true),\n\t\tIcon:             \"/path/to/icon\",\n\t\tReplyPlaceholder: \"placeholder\",\n\t\tSilent:           astikit.BoolPtr(true),\n\t\tSound:            \"sound\",\n\t\tSubtitle:         \"subtitle\",\n\t\tTitle:            \"title\",\n\t}, true, d, i, w)\n\n\t// Actions\n\ttestObjectAction(t, func() error { return n.Create() }, n.object, wrt, \"{\\\"name\\\":\\\"\"+eventNameNotificationCmdCreate+\"\\\",\\\"targetID\\\":\\\"\"+n.id+\"\\\",\\\"notificationOptions\\\":{\\\"body\\\":\\\"body\\\",\\\"hasReply\\\":true,\\\"icon\\\":\\\"/path/to/icon\\\",\\\"replyPlaceholder\\\":\\\"placeholder\\\",\\\"silent\\\":true,\\\"sound\\\":\\\"sound\\\",\\\"subtitle\\\":\\\"subtitle\\\",\\\"title\\\":\\\"title\\\"}}\\n\", EventNameNotificationEventCreated, nil)\n\ttestObjectAction(t, func() error { return n.Show() }, n.object, wrt, \"{\\\"name\\\":\\\"\"+eventNameNotificationCmdShow+\"\\\",\\\"targetID\\\":\\\"\"+n.id+\"\\\"}\\n\", EventNameNotificationEventShown, nil)\n}\n"
        },
        {
          "name": "object.go",
          "type": "blob",
          "size": 0.5927734375,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n)\n\n// object represents a base object\ntype object struct {\n\tcancel context.CancelFunc\n\tctx    context.Context\n\td      *dispatcher\n\ti      *identifier\n\tid     string\n\tw      *writer\n}\n\n// newObject returns a new base object\nfunc newObject(ctx context.Context, d *dispatcher, i *identifier, w *writer, id string) (o *object) {\n\to = &object{\n\t\td:  d,\n\t\ti:  i,\n\t\tid: id,\n\t\tw:  w,\n\t}\n\to.ctx, o.cancel = context.WithCancel(ctx)\n\treturn\n}\n\n// On implements the Listenable interface\nfunc (o *object) On(eventName string, l Listener) {\n\to.d.addListener(o.id, eventName, l)\n}\n"
        },
        {
          "name": "object_test.go",
          "type": "blob",
          "size": 0.6708984375,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc testObjectAction(t *testing.T, fn func() error, o *object, wrt *mockedWriter, sentEvent, eventNameDone string, receivedEvent *Event) {\n\twrt.w = []string{}\n\to.cancel()\n\terr := fn()\n\tassert.EqualError(t, err, context.Canceled.Error())\n\to.ctx, o.cancel = context.WithCancel(context.Background())\n\tif eventNameDone != \"\" {\n\t\twrt.fn = func() {\n\t\t\tvar event Event\n\t\t\tif receivedEvent != nil {\n\t\t\t\tevent = *receivedEvent\n\t\t\t}\n\t\t\tevent.Name = eventNameDone\n\t\t\tevent.TargetID = o.id\n\n\t\t\to.d.dispatch(event)\n\t\t}\n\t}\n\terr = fn()\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{sentEvent}, wrt.w)\n}\n"
        },
        {
          "name": "paths.go",
          "type": "blob",
          "size": 7.2939453125,
          "content": "package astilectron\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Paths represents the set of paths needed by Astilectron\ntype Paths struct {\n\tappExecutable          string\n\tappIconDarwinSrc       string\n\tappIconDefaultSrc      string\n\tastilectronApplication string\n\tastilectronDirectory   string\n\tastilectronDownloadSrc string\n\tastilectronDownloadDst string\n\tastilectronUnzipSrc    string\n\tbaseDirectory          string\n\tdataDirectory          string\n\telectronDirectory      string\n\telectronDownloadSrc    string\n\telectronDownloadDst    string\n\telectronUnzipSrc       string\n\tprovisionStatus        string\n\tvendorDirectory        string\n}\n\n// newPaths creates new paths\nfunc newPaths(os, arch string, o Options) (p *Paths, err error) {\n\n\t// Init base directory path\n\tp = &Paths{}\n\tif err = p.initBaseDirectory(o.BaseDirectoryPath); err != nil {\n\t\terr = fmt.Errorf(\"initializing base directory failed: %w\", err)\n\t\treturn\n\t}\n\n\t// Init data directory path\n\tif err = p.initDataDirectory(o.DataDirectoryPath, o.AppName); err != nil {\n\t\terr = fmt.Errorf(\"initializing data directory failed: %w\", err)\n\t\treturn\n\t}\n\n\t// Init other paths\n\t//!\\\\ Order matters\n\tp.appIconDarwinSrc = o.AppIconDarwinPath\n\tif len(p.appIconDarwinSrc) > 0 && !filepath.IsAbs(p.appIconDarwinSrc) {\n\t\tp.appIconDarwinSrc = filepath.Join(p.dataDirectory, p.appIconDarwinSrc)\n\t}\n\tp.appIconDefaultSrc = o.AppIconDefaultPath\n\tif len(p.appIconDefaultSrc) > 0 && !filepath.IsAbs(p.appIconDefaultSrc) {\n\t\tp.appIconDefaultSrc = filepath.Join(p.dataDirectory, p.appIconDefaultSrc)\n\t}\n\tp.vendorDirectory = filepath.Join(p.dataDirectory, \"vendor\")\n\tp.provisionStatus = filepath.Join(p.vendorDirectory, \"status.json\")\n\tp.astilectronDirectory = filepath.Join(p.vendorDirectory, \"astilectron\")\n\tp.astilectronApplication = filepath.Join(p.astilectronDirectory, \"main.js\")\n\tp.astilectronDownloadSrc = AstilectronDownloadSrc(o.VersionAstilectron)\n\tp.astilectronDownloadDst = filepath.Join(p.vendorDirectory, fmt.Sprintf(\"astilectron-v%s.zip\", o.VersionAstilectron))\n\tp.astilectronUnzipSrc = filepath.Join(p.astilectronDownloadDst, fmt.Sprintf(\"astilectron-%s\", o.VersionAstilectron))\n\tif o.CustomElectronPath == \"\" {\n\t\tp.electronDirectory = filepath.Join(p.vendorDirectory, fmt.Sprintf(\"electron-%s-%s\", os, arch))\n\t\tp.electronDownloadSrc = ElectronDownloadSrc(os, arch, o.VersionElectron)\n\t\tp.electronDownloadDst = filepath.Join(p.vendorDirectory, fmt.Sprintf(\"electron-%s-%s-v%s.zip\", os, arch, o.VersionElectron))\n\t\tp.electronUnzipSrc = p.electronDownloadDst\n\t\tp.initAppExecutable(os, o.AppName)\n\t} else {\n\t\tp.appExecutable = o.CustomElectronPath\n\t}\n\treturn\n}\n\n// initBaseDirectory initializes the base directory path\nfunc (p *Paths) initBaseDirectory(baseDirectoryPath string) (err error) {\n\t// No path specified in the options\n\tp.baseDirectory = baseDirectoryPath\n\tif len(p.baseDirectory) == 0 {\n\t\t// Retrieve executable path\n\t\tvar ep string\n\t\tif ep, err = os.Executable(); err != nil {\n\t\t\terr = fmt.Errorf(\"retrieving executable path failed: %w\", err)\n\t\t\treturn\n\t\t}\n\t\tp.baseDirectory = filepath.Dir(ep)\n\t}\n\n\t// We need the absolute path\n\tif p.baseDirectory, err = filepath.Abs(p.baseDirectory); err != nil {\n\t\terr = fmt.Errorf(\"computing absolute path failed: %w\", err)\n\t\treturn\n\t}\n\treturn\n}\n\nfunc (p *Paths) initDataDirectory(dataDirectoryPath, appName string) (err error) {\n\t// Path is specified in the options\n\tif len(dataDirectoryPath) > 0 {\n\t\t// We need the absolute path\n\t\tif p.dataDirectory, err = filepath.Abs(dataDirectoryPath); err != nil {\n\t\t\terr = fmt.Errorf(\"computing absolute path of %s failed: %w\", dataDirectoryPath, err)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\n\t// If the APPDATA env exists, we use it\n\tif v := os.Getenv(\"APPDATA\"); len(v) > 0 {\n\t\tp.dataDirectory = filepath.Join(v, appName)\n\t\treturn\n\t}\n\n\t// Default to base directory path\n\tp.dataDirectory = p.baseDirectory\n\treturn\n}\n\n// AstilectronDownloadSrc returns the download URL of the (currently platform-independent) astilectron zip file\nfunc AstilectronDownloadSrc(versionAstilectron string) string {\n\treturn fmt.Sprintf(\"https://github.com/asticode/astilectron/archive/v%s.zip\", versionAstilectron)\n}\n\n// ElectronDownloadSrc returns the download URL of the platform-dependant electron zipfile\nfunc ElectronDownloadSrc(os, arch, versionElectron string) string {\n\t// Get OS name\n\tvar o string\n\tswitch strings.ToLower(os) {\n\tcase \"darwin\":\n\t\to = \"darwin\"\n\tcase \"linux\":\n\t\to = \"linux\"\n\tcase \"windows\":\n\t\to = \"win32\"\n\t}\n\n\t// Get arch name\n\tvar a = \"ia32\"\n\tif strings.ToLower(arch) == \"amd64\" {\n\t\ta = \"x64\"\n\t} else if strings.ToLower(arch) == \"arm\" && o == \"linux\" {\n\t\ta = \"armv7l\"\n\t} else if strings.ToLower(arch) == \"arm64\" {\n\t\ta = \"arm64\"\n\t}\n\n\t// Return url\n\treturn fmt.Sprintf(\"https://github.com/electron/electron/releases/download/v%s/electron-v%s-%s-%s.zip\", versionElectron, versionElectron, o, a)\n}\n\n// initAppExecutable initializes the app executable path\nfunc (p *Paths) initAppExecutable(os, appName string) {\n\tswitch os {\n\tcase \"darwin\":\n\t\tif appName == \"\" {\n\t\t\tappName = \"Electron\"\n\t\t}\n\t\tp.appExecutable = filepath.Join(p.electronDirectory, appName+\".app\", \"Contents\", \"MacOS\", appName)\n\tcase \"linux\":\n\t\tp.appExecutable = filepath.Join(p.electronDirectory, \"electron\")\n\tcase \"windows\":\n\t\tp.appExecutable = filepath.Join(p.electronDirectory, \"electron.exe\")\n\t}\n}\n\n// AppExecutable returns the app executable path\nfunc (p Paths) AppExecutable() string {\n\treturn p.appExecutable\n}\n\n// AppIconDarwinSrc returns the darwin app icon path\nfunc (p Paths) AppIconDarwinSrc() string {\n\treturn p.appIconDarwinSrc\n}\n\n// AppIconDefaultSrc returns the default app icon path\nfunc (p Paths) AppIconDefaultSrc() string {\n\treturn p.appIconDefaultSrc\n}\n\n// BaseDirectory returns the base directory path\nfunc (p Paths) BaseDirectory() string {\n\treturn p.baseDirectory\n}\n\n// AstilectronApplication returns the astilectron application path\nfunc (p Paths) AstilectronApplication() string {\n\treturn p.astilectronApplication\n}\n\n// AstilectronDirectory returns the astilectron directory path\nfunc (p Paths) AstilectronDirectory() string {\n\treturn p.astilectronDirectory\n}\n\n// AstilectronDownloadDst returns the astilectron download destination path\nfunc (p Paths) AstilectronDownloadDst() string {\n\treturn p.astilectronDownloadDst\n}\n\n// AstilectronDownloadSrc returns the astilectron download source path\nfunc (p Paths) AstilectronDownloadSrc() string {\n\treturn p.astilectronDownloadSrc\n}\n\n// AstilectronUnzipSrc returns the astilectron unzip source path\nfunc (p Paths) AstilectronUnzipSrc() string {\n\treturn p.astilectronUnzipSrc\n}\n\n// DataDirectory returns the data directory path\nfunc (p Paths) DataDirectory() string {\n\treturn p.dataDirectory\n}\n\n// ElectronDirectory returns the electron directory path\nfunc (p Paths) ElectronDirectory() string {\n\treturn p.electronDirectory\n}\n\n// ElectronDownloadDst returns the electron download destination path\nfunc (p Paths) ElectronDownloadDst() string {\n\treturn p.electronDownloadDst\n}\n\n// ElectronDownloadSrc returns the electron download source path\nfunc (p Paths) ElectronDownloadSrc() string {\n\treturn p.electronDownloadSrc\n}\n\n// ElectronUnzipSrc returns the electron unzip source path\nfunc (p Paths) ElectronUnzipSrc() string {\n\treturn p.electronUnzipSrc\n}\n\n// ProvisionStatus returns the provision status path\nfunc (p Paths) ProvisionStatus() string {\n\treturn p.provisionStatus\n}\n\n// VendorDirectory returns the vendor directory path\nfunc (p Paths) VendorDirectory() string {\n\treturn p.vendorDirectory\n}\n"
        },
        {
          "name": "paths_test.go",
          "type": "blob",
          "size": 5.271484375,
          "content": "package astilectron\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPaths(t *testing.T) {\n\tconst k = \"APPDATA\"\n\n\tad := os.Getenv(k)\n\tos.Setenv(k, \"\")\n\tep, err := os.Executable()\n\tep = filepath.Dir(ep)\n\tassert.NoError(t, err)\n\n\to := Options{VersionAstilectron: DefaultVersionAstilectron, VersionElectron: DefaultVersionElectron}\n\tp, err := newPaths(\"linux\", \"amd64\", o)\n\tassert.NoError(t, err)\n\tassert.Equal(t, ep+\"/vendor/electron-linux-amd64/electron\", p.AppExecutable())\n\tassert.Equal(t, \"\", p.AppIconDarwinSrc())\n\tassert.Equal(t, ep, p.BaseDirectory())\n\tassert.Equal(t, ep, p.DataDirectory())\n\tassert.Equal(t, ep+\"/vendor/astilectron/main.js\", p.AstilectronApplication())\n\tassert.Equal(t, ep+\"/vendor/astilectron\", p.AstilectronDirectory())\n\tassert.Equal(t, ep+\"/vendor/astilectron-v\"+o.VersionAstilectron+\".zip\", p.AstilectronDownloadDst())\n\tassert.Equal(t, \"https://github.com/asticode/astilectron/archive/v\"+o.VersionAstilectron+\".zip\", p.AstilectronDownloadSrc())\n\tassert.Equal(t, ep+\"/vendor/astilectron-v\"+o.VersionAstilectron+\".zip/astilectron-\"+o.VersionAstilectron, p.AstilectronUnzipSrc())\n\tassert.Equal(t, ep+\"/vendor/electron-linux-amd64\", p.ElectronDirectory())\n\tassert.Equal(t, ep+\"/vendor/electron-linux-amd64-v\"+o.VersionElectron+\".zip\", p.ElectronDownloadDst())\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-linux-x64.zip\", p.ElectronDownloadSrc())\n\tassert.Equal(t, ep+\"/vendor/electron-linux-amd64-v\"+o.VersionElectron+\".zip\", p.ElectronUnzipSrc())\n\tassert.Equal(t, ep+\"/vendor/status.json\", p.ProvisionStatus())\n\tassert.Equal(t, ep+\"/vendor\", p.VendorDirectory())\n\tp, err = newPaths(\"linux\", \"\", o)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-linux-ia32.zip\", p.ElectronDownloadSrc())\n\tp, err = newPaths(\"linux\", \"arm\", o)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-linux-armv7l.zip\", p.ElectronDownloadSrc())\n\tp, err = newPaths(\"linux\", \"arm64\", o)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-linux-arm64.zip\", p.ElectronDownloadSrc())\n\tp, err = newPaths(\"darwin\", \"\", Options{BaseDirectoryPath: \"/path/to/base/directory\", AppIconDarwinPath: \"/path/to/darwin/icon\", AppIconDefaultPath: \"icon\", VersionAstilectron: DefaultVersionAstilectron, VersionElectron: DefaultVersionElectron})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"/path/to/base/directory/vendor/electron-darwin-/Electron.app/Contents/MacOS/Electron\", p.AppExecutable())\n\tassert.Equal(t, \"/path/to/darwin/icon\", p.AppIconDarwinSrc())\n\tassert.Equal(t, \"/path/to/base/directory/icon\", p.AppIconDefaultSrc())\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-darwin-ia32.zip\", p.ElectronDownloadSrc())\n\tp, err = newPaths(\"darwin\", \"amd64\", Options{AppName: \"Test app\", BaseDirectoryPath: \"/path/to/base/directory\", DataDirectoryPath: \"/path/to/data/directory\", VersionAstilectron: DefaultVersionAstilectron, VersionElectron: DefaultVersionElectron})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"/path/to/data/directory\", p.DataDirectory())\n\tassert.Equal(t, \"/path/to/data/directory/vendor/electron-darwin-amd64/Test app.app/Contents/MacOS/Test app\", p.AppExecutable())\n\tassert.Equal(t, \"/path/to/data/directory/vendor/electron-darwin-amd64-v\"+o.VersionElectron+\".zip\", p.ElectronDownloadDst())\n\tassert.Equal(t, \"/path/to/data/directory/vendor/electron-darwin-amd64-v\"+o.VersionElectron+\".zip\", p.ElectronUnzipSrc())\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-darwin-x64.zip\", p.ElectronDownloadSrc())\n\tp, err = newPaths(\"darwin\", \"arm64\", o)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-darwin-arm64.zip\", p.ElectronDownloadSrc())\n\tconst pad = \"/path/to/appdata\"\n\tos.Setenv(k, pad)\n\tp, err = newPaths(\"windows\", \"amd64\", o)\n\tassert.NoError(t, err)\n\tassert.Equal(t, pad, p.DataDirectory())\n\tassert.Equal(t, pad+\"/vendor\", p.VendorDirectory())\n\tassert.Equal(t, pad+\"/vendor/electron-windows-amd64/electron.exe\", p.AppExecutable())\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-win32-x64.zip\", p.ElectronDownloadSrc())\n\tassert.Equal(t, pad+\"/vendor/electron-windows-amd64-v\"+o.VersionElectron+\".zip\", p.ElectronDownloadDst())\n\tassert.Equal(t, pad+\"/vendor/electron-windows-amd64-v\"+o.VersionElectron+\".zip\", p.ElectronUnzipSrc())\n\tp, err = newPaths(\"windows\", \"\", o)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-win32-ia32.zip\", p.ElectronDownloadSrc())\n\tp, err = newPaths(\"windows\", \"arm64\", o)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"https://github.com/electron/electron/releases/download/v\"+o.VersionElectron+\"/electron-v\"+o.VersionElectron+\"-win32-arm64.zip\", p.ElectronDownloadSrc())\n\tos.Setenv(k, ad)\n}\n"
        },
        {
          "name": "power.go",
          "type": "blob",
          "size": 0.609375,
          "content": "package astilectron\n\n// Power event names\nconst (\n\tEventNamePowerSuspend             = \"power.event.suspend\"\n\tEventNamePowerResume              = \"power.event.resume\"\n\tEventNamePowerOnAC                = \"power.event.on.ac\"\n\tEventNamePowerOnBattery           = \"power.event.on.battery\"\n\tEventNamePowerShutdown            = \"power.event.shutdown\"\n\tEventNamePowerLockScreen          = \"power.event.lock.screen\"\n\tEventNamePowerUnlockScreen        = \"power.event.unlock.screen\"\n\tEventNamePowerUserDidBecomeActive = \"power.event.user.did.become.active\"\n\tEventNamePowerUserDidResignActive = \"power.event.user.did.resign.active\"\n)\n"
        },
        {
          "name": "provisioner.go",
          "type": "blob",
          "size": 14.5068359375,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// Var\nvar (\n\tregexpDarwinInfoPList = regexp.MustCompile(\"<string>Electron\")\n)\n\n// Provisioner represents an object capable of provisioning Astilectron\ntype Provisioner interface {\n\tProvision(ctx context.Context, appName, os, arch, versionAstilectron, versionElectron string, p Paths) error\n}\n\n// mover is a function that moves a package\ntype mover func(ctx context.Context, p Paths) (func() error, error)\n\n// defaultProvisioner represents the default provisioner\ntype defaultProvisioner struct {\n\tl                astikit.SeverityLogger\n\tmoverAstilectron mover\n\tmoverElectron    mover\n}\n\nfunc newDefaultProvisioner(l astikit.StdLogger) (dp *defaultProvisioner) {\n\td := astikit.NewHTTPDownloader(astikit.HTTPDownloaderOptions{\n\t\tSender: astikit.HTTPSenderOptions{\n\t\t\tLogger: l,\n\t\t},\n\t})\n\tdp = &defaultProvisioner{l: astikit.AdaptStdLogger(l)}\n\tdp.moverAstilectron = func(ctx context.Context, p Paths) (closeFunc func() error, err error) {\n\t\tif err = Download(ctx, dp.l, d, p.AstilectronDownloadSrc(), p.AstilectronDownloadDst()); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"downloading %s into %s failed: %w\", p.AstilectronDownloadSrc(), p.AstilectronDownloadDst(), err)\n\t\t}\n\t\treturn func() (err error) {\n\t\t\tdp.l.Debugf(\"removing %s\", p.AstilectronDownloadDst())\n\t\t\tif err = os.Remove(p.AstilectronDownloadDst()); err != nil {\n\t\t\t\treturn fmt.Errorf(\"removing %s failed: %w\", p.AstilectronDownloadDst(), err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}, err\n\t}\n\tdp.moverElectron = func(ctx context.Context, p Paths) (closeFunc func() error, err error) {\n\t\tif err = Download(ctx, dp.l, d, p.ElectronDownloadSrc(), p.ElectronDownloadDst()); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"downloading %s into %s failed: %w\", p.ElectronDownloadSrc(), p.ElectronDownloadDst(), err)\n\t\t}\n\t\treturn func() (err error) {\n\t\t\tdp.l.Debugf(\"removing %s\", p.ElectronDownloadDst())\n\t\t\tif err = os.Remove(p.ElectronDownloadDst()); err != nil {\n\t\t\t\treturn fmt.Errorf(\"removing %s failed: %w\", p.ElectronDownloadDst(), err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}, err\n\t}\n\treturn\n}\n\n// provisionStatusElectronKey returns the electron's provision status key\nfunc provisionStatusElectronKey(os, arch string) string {\n\treturn fmt.Sprintf(\"%s-%s\", os, arch)\n}\n\n// Provision implements the provisioner interface\n// TODO Package app using electron instead of downloading Electron + Astilectron separately\nfunc (p *defaultProvisioner) Provision(ctx context.Context, appName, os, arch, versionAstilectron, versionElectron string, paths Paths) (err error) {\n\t// Retrieve provision status\n\tvar s ProvisionStatus\n\tif s, err = p.ProvisionStatus(paths); err != nil {\n\t\terr = fmt.Errorf(\"retrieving provisioning status failed: %w\", err)\n\t\treturn\n\t}\n\tdefer p.updateProvisionStatus(paths, &s)\n\n\t// Provision astilectron\n\tif err = p.provisionAstilectron(ctx, paths, s, versionAstilectron); err != nil {\n\t\terr = fmt.Errorf(\"provisioning astilectron failed: %w\", err)\n\t\treturn\n\t}\n\ts.Astilectron = &ProvisionStatusPackage{Version: versionAstilectron}\n\n\t// Provision electron\n\tif err = p.provisionElectron(ctx, paths, s, appName, os, arch, versionElectron); err != nil {\n\t\terr = fmt.Errorf(\"provisioning electron failed: %w\", err)\n\t\treturn\n\t}\n\ts.Electron[provisionStatusElectronKey(os, arch)] = &ProvisionStatusPackage{Version: versionElectron}\n\treturn\n}\n\n// ProvisionStatus represents the provision status\ntype ProvisionStatus struct {\n\tAstilectron *ProvisionStatusPackage            `json:\"astilectron,omitempty\"`\n\tElectron    map[string]*ProvisionStatusPackage `json:\"electron,omitempty\"`\n}\n\n// ProvisionStatusPackage represents the provision status of a package\ntype ProvisionStatusPackage struct {\n\tVersion string `json:\"version\"`\n}\n\n// ProvisionStatus returns the provision status\nfunc (p *defaultProvisioner) ProvisionStatus(paths Paths) (s ProvisionStatus, err error) {\n\t// Open the file\n\tvar f *os.File\n\ts.Electron = make(map[string]*ProvisionStatusPackage)\n\tif f, err = os.Open(paths.ProvisionStatus()); err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\terr = fmt.Errorf(\"opening file %s failed: %w\", paths.ProvisionStatus(), err)\n\t\t} else {\n\t\t\terr = nil\n\t\t}\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\t// Unmarshal\n\tif errLocal := json.NewDecoder(f).Decode(&s); errLocal != nil {\n\t\t// For backward compatibility purposes, if there's an unmarshal error we delete the status file and make the\n\t\t// assumption that provisioning has to be done all over again\n\t\tp.l.Error(fmt.Errorf(\"json decoding from %s failed: %w\", paths.ProvisionStatus(), errLocal))\n\t\tp.l.Debugf(\"Removing %s\", f.Name())\n\t\tif errLocal = os.RemoveAll(f.Name()); errLocal != nil {\n\t\t\tp.l.Error(fmt.Errorf(\"removing %s failed: %w\", f.Name(), errLocal))\n\t\t}\n\t\treturn\n\t}\n\treturn\n}\n\n// ProvisionStatus updates the provision status\nfunc (p *defaultProvisioner) updateProvisionStatus(paths Paths, s *ProvisionStatus) (err error) {\n\t// Create the file\n\tvar f *os.File\n\tif f, err = os.Create(paths.ProvisionStatus()); err != nil {\n\t\terr = fmt.Errorf(\"creating file %s failed: %w\", paths.ProvisionStatus(), err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\t// Marshal\n\tif err = json.NewEncoder(f).Encode(s); err != nil {\n\t\terr = fmt.Errorf(\"json encoding into %s failed: %w\", paths.ProvisionStatus(), err)\n\t\treturn\n\t}\n\treturn\n}\n\n// provisionAstilectron provisions astilectron\nfunc (p *defaultProvisioner) provisionAstilectron(ctx context.Context, paths Paths, s ProvisionStatus, versionAstilectron string) error {\n\treturn p.provisionPackage(ctx, paths, s.Astilectron, p.moverAstilectron, \"Astilectron\", versionAstilectron, paths.AstilectronUnzipSrc(), paths.AstilectronDirectory(), nil)\n}\n\n// provisionElectron provisions electron\nfunc (p *defaultProvisioner) provisionElectron(ctx context.Context, paths Paths, s ProvisionStatus, appName, os, arch, versionElectron string) error {\n\tif paths.ElectronUnzipSrc() == \"\" {\n\t\treturn nil\n\t}\n\treturn p.provisionPackage(ctx, paths, s.Electron[provisionStatusElectronKey(os, arch)], p.moverElectron, \"Electron\", versionElectron, paths.ElectronUnzipSrc(), paths.ElectronDirectory(), func() (err error) {\n\t\tswitch os {\n\t\tcase \"darwin\":\n\t\t\tif err = p.provisionElectronFinishDarwin(appName, paths); err != nil {\n\t\t\t\treturn fmt.Errorf(\"finishing provisioning electron for darwin systems failed: %w\", err)\n\t\t\t}\n\t\tdefault:\n\t\t\tp.l.Debug(\"System doesn't require finshing provisioning electron, moving on...\")\n\t\t}\n\t\treturn\n\t})\n}\n\n// provisionPackage provisions a package\nfunc (p *defaultProvisioner) provisionPackage(ctx context.Context, paths Paths, s *ProvisionStatusPackage, m mover, name, version, pathUnzipSrc, pathDirectory string, finish func() error) (err error) {\n\t// Package has already been provisioned\n\tif s != nil && s.Version == version {\n\t\tp.l.Debugf(\"%s has already been provisioned to version %s, moving on...\", name, version)\n\t\treturn\n\t}\n\tp.l.Debugf(\"Provisioning %s...\", name)\n\n\t// Remove previous install\n\tp.l.Debugf(\"Removing directory %s\", pathDirectory)\n\tif err = os.RemoveAll(pathDirectory); err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"removing %s failed: %w\", pathDirectory, err)\n\t}\n\n\t// Move\n\tvar closeFunc func() error\n\tif closeFunc, err = m(ctx, paths); err != nil {\n\t\treturn fmt.Errorf(\"moving %s failed: %w\", name, err)\n\t}\n\n\t// Make sure to close\n\tdefer func() {\n\t\tif closeFunc == nil {\n\t\t\treturn\n\t\t}\n\t\tif err := closeFunc(); err != nil {\n\t\t\t// Only log the error\n\t\t\tp.l.Error(fmt.Errorf(\"closing failed: %w\", err))\n\t\t\treturn\n\t\t}\n\t}()\n\n\t// Create directory\n\tp.l.Debugf(\"Creating directory %s\", pathDirectory)\n\tif err = os.MkdirAll(pathDirectory, 0755); err != nil {\n\t\treturn fmt.Errorf(\"mkdirall %s failed: %w\", pathDirectory, err)\n\t}\n\n\t// Unzip\n\tif err = Unzip(ctx, p.l, pathUnzipSrc, pathDirectory); err != nil {\n\t\treturn fmt.Errorf(\"unzipping %s into %s failed: %w\", pathUnzipSrc, pathDirectory, err)\n\t}\n\n\t// Finish\n\tif finish != nil {\n\t\tif err = finish(); err != nil {\n\t\t\treturn fmt.Errorf(\"finishing failed: %w\", err)\n\t\t}\n\t}\n\treturn\n}\n\n// provisionElectronFinishDarwin finishes provisioning electron for Darwin systems\n// https://github.com/electron/electron/blob/v1.8.1/docs/tutorial/application-distribution.md#macos\nfunc (p *defaultProvisioner) provisionElectronFinishDarwin(appName string, paths Paths) (err error) {\n\t// Log\n\tp.l.Debug(\"Finishing provisioning electron for darwin system\")\n\n\t// Custom app icon\n\tif paths.AppIconDarwinSrc() != \"\" {\n\t\tif err = p.provisionElectronFinishDarwinCopy(paths); err != nil {\n\t\t\treturn fmt.Errorf(\"copying for darwin system finish failed: %w\", err)\n\t\t}\n\t}\n\n\t// Custom app name\n\tif appName != \"\" {\n\t\t// Replace\n\t\tif err = p.provisionElectronFinishDarwinReplace(appName, paths); err != nil {\n\t\t\treturn fmt.Errorf(\"replacing for darwin system finish failed: %w\", err)\n\t\t}\n\n\t\t// Rename\n\t\tif err = p.provisionElectronFinishDarwinRename(appName, paths); err != nil {\n\t\t\treturn fmt.Errorf(\"renaming for darwin system finish failed: %w\", err)\n\t\t}\n\t}\n\treturn\n}\n\n// provisionElectronFinishDarwinCopy copies the proper darwin files\nfunc (p *defaultProvisioner) provisionElectronFinishDarwinCopy(paths Paths) (err error) {\n\t// Icon\n\tvar src, dst = paths.AppIconDarwinSrc(), filepath.Join(paths.ElectronDirectory(), \"Electron.app\", \"Contents\", \"Resources\", \"electron.icns\")\n\tif src != \"\" {\n\t\tp.l.Debugf(\"Copying %s to %s\", src, dst)\n\t\tif err = astikit.CopyFile(context.Background(), dst, src, astikit.LocalCopyFileFunc); err != nil {\n\t\t\treturn fmt.Errorf(\"copying %s to %s failed: %w\", src, dst, err)\n\t\t}\n\t}\n\treturn\n}\n\n// provisionElectronFinishDarwinReplace makes the proper replacements in the proper darwin files\nfunc (p *defaultProvisioner) provisionElectronFinishDarwinReplace(appName string, paths Paths) (err error) {\n\tfor _, path := range []string{\n\t\tfilepath.Join(paths.electronDirectory, \"Electron.app\", \"Contents\", \"Info.plist\"),\n\t\tfilepath.Join(paths.electronDirectory, \"Electron.app\", \"Contents\", \"Frameworks\", \"Electron Helper.app\", \"Contents\", \"Info.plist\"),\n\t\tfilepath.Join(paths.electronDirectory, \"Electron.app\", \"Contents\", \"Frameworks\", \"Electron Helper (Renderer).app\", \"Contents\", \"Info.plist\"),\n\t\tfilepath.Join(paths.electronDirectory, \"Electron.app\", \"Contents\", \"Frameworks\", \"Electron Helper (Plugin).app\", \"Contents\", \"Info.plist\"),\n\t\tfilepath.Join(paths.electronDirectory, \"Electron.app\", \"Contents\", \"Frameworks\", \"Electron Helper (GPU).app\", \"Contents\", \"Info.plist\"),\n\t} {\n\t\t// Log\n\t\tp.l.Debugf(\"Replacing in %s\", path)\n\n\t\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Read file\n\t\tvar b []byte\n\t\tif b, err = ioutil.ReadFile(path); err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s failed: %w\", path, err)\n\t\t}\n\n\t\t// Open and truncate file\n\t\tvar f *os.File\n\t\tif f, err = os.Create(path); err != nil {\n\t\t\treturn fmt.Errorf(\"creating %s failed: %w\", path, err)\n\t\t}\n\t\tdefer f.Close()\n\n\t\t// Replace\n\t\tb = regexpDarwinInfoPList.ReplaceAll(b, []byte(\"<string>\"+appName))\n\n\t\t// Write\n\t\tif _, err = f.Write(b); err != nil {\n\t\t\treturn fmt.Errorf(\"writing to %s failed: %w\", path, err)\n\t\t}\n\t}\n\treturn\n}\n\n// rename represents a rename\ntype rename struct {\n\tsrc, dst string\n}\n\n// provisionElectronFinishDarwinRename renames the proper darwin folders\nfunc (p *defaultProvisioner) provisionElectronFinishDarwinRename(appName string, paths Paths) (err error) {\n\tvar appDirectory = filepath.Join(paths.electronDirectory, appName+\".app\")\n\tvar frameworksDirectory = filepath.Join(appDirectory, \"Contents\", \"Frameworks\")\n\tvar helper = filepath.Join(frameworksDirectory, appName+\" Helper.app\")\n\tvar helperRenderer = filepath.Join(frameworksDirectory, appName+\" Helper (Renderer).app\")\n\tvar helperPlugin = filepath.Join(frameworksDirectory, appName+\" Helper (Plugin).app\")\n\tvar helperGPU = filepath.Join(frameworksDirectory, appName+\" Helper (GPU).app\")\n\tfor _, r := range []rename{\n\t\t{src: filepath.Join(paths.electronDirectory, \"Electron.app\"), dst: appDirectory},\n\t\t{src: filepath.Join(appDirectory, \"Contents\", \"MacOS\", \"Electron\"), dst: paths.AppExecutable()},\n\t\t{src: filepath.Join(frameworksDirectory, \"Electron Helper.app\"), dst: filepath.Join(helper)},\n\t\t{src: filepath.Join(frameworksDirectory, \"Electron Helper (Renderer).app\"), dst: filepath.Join(helperRenderer)},\n\t\t{src: filepath.Join(frameworksDirectory, \"Electron Helper (Plugin).app\"), dst: filepath.Join(helperPlugin)},\n\t\t{src: filepath.Join(frameworksDirectory, \"Electron Helper (GPU).app\"), dst: filepath.Join(helperGPU)},\n\t\t{src: filepath.Join(helper, \"Contents\", \"MacOS\", \"Electron Helper\"), dst: filepath.Join(helper, \"Contents\", \"MacOS\", appName+\" Helper\")},\n\t\t{src: filepath.Join(helperRenderer, \"Contents\", \"MacOS\", \"Electron Helper (Renderer)\"), dst: filepath.Join(helperRenderer, \"Contents\", \"MacOS\", appName+\" Helper (Renderer)\")},\n\t\t{src: filepath.Join(helperPlugin, \"Contents\", \"MacOS\", \"Electron Helper (Plugin)\"), dst: filepath.Join(helperPlugin, \"Contents\", \"MacOS\", appName+\" Helper (Plugin)\")},\n\t\t{src: filepath.Join(helperGPU, \"Contents\", \"MacOS\", \"Electron Helper (GPU)\"), dst: filepath.Join(helperGPU, \"Contents\", \"MacOS\", appName+\" Helper (GPU)\")},\n\t} {\n\t\tp.l.Debugf(\"Renaming %s into %s\", r.src, r.dst)\n\t\tif _, err := os.Stat(r.src); os.IsNotExist(err) {\n\t\t\tcontinue\n\t\t}\n\t\tif err = os.Rename(r.src, r.dst); err != nil {\n\t\t\treturn fmt.Errorf(\"renaming %s into %s failed: %w\", r.src, r.dst, err)\n\t\t}\n\t}\n\treturn\n}\n\n// Disembedder is a functions that allows to disembed data from a path\ntype Disembedder func(src string) ([]byte, error)\n\n// NewDisembedderProvisioner creates a provisioner that can provision based on embedded data\nfunc NewDisembedderProvisioner(d Disembedder, pathAstilectron, pathElectron string, l astikit.StdLogger) Provisioner {\n\tdp := &defaultProvisioner{l: astikit.AdaptStdLogger(l)}\n\tdp.moverAstilectron = func(ctx context.Context, p Paths) (closeFunc func() error, err error) {\n\t\tif err = Disembed(ctx, dp.l, d, pathAstilectron, p.AstilectronDownloadDst()); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"disembedding %s into %s failed: %w\", pathAstilectron, p.AstilectronDownloadDst(), err)\n\t\t}\n\t\treturn func() (err error) {\n\t\t\tdp.l.Debugf(\"removing %s\", p.AstilectronDownloadDst())\n\t\t\tif err = os.Remove(p.AstilectronDownloadDst()); err != nil {\n\t\t\t\treturn fmt.Errorf(\"removing %s failed: %w\", p.AstilectronDownloadDst(), err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}, err\n\t}\n\tdp.moverElectron = func(ctx context.Context, p Paths) (closeFunc func() error, err error) {\n\t\tif err = Disembed(ctx, dp.l, d, pathElectron, p.ElectronDownloadDst()); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"disembedding %s into %s failed: %w\", pathElectron, p.ElectronDownloadDst(), err)\n\t\t}\n\t\treturn func() (err error) {\n\t\t\tdp.l.Debugf(\"removing %s\", p.ElectronDownloadDst())\n\t\t\tif err = os.Remove(p.ElectronDownloadDst()); err != nil {\n\t\t\t\treturn fmt.Errorf(\"removing %s failed: %w\", p.ElectronDownloadDst(), err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}, err\n\t}\n\treturn dp\n}\n"
        },
        {
          "name": "provisioner_test.go",
          "type": "blob",
          "size": 6.671875,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"github.com/asticode/go-astikit\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"io/ioutil\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc testProvisionerSuccessful(t *testing.T, p Paths, osName, arch, versionAstilectron, versionElectron string) {\n\t_, err := os.Stat(p.AstilectronApplication())\n\tassert.NoError(t, err)\n\t_, err = os.Stat(p.AppExecutable())\n\tassert.NoError(t, err)\n\tb, err := ioutil.ReadFile(p.ProvisionStatus())\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"{\\\"astilectron\\\":{\\\"version\\\":\\\"\"+versionAstilectron+\"\\\"},\\\"electron\\\":{\\\"\"+provisionStatusElectronKey(osName, arch)+\"\\\":{\\\"version\\\":\\\"\"+versionElectron+\"\\\"}}}\\n\", string(b))\n}\n\nfunc TestDefaultProvisioner(t *testing.T) {\n\t// Init\n\tvar o = Options{BaseDirectoryPath: mockedTempPath()}\n\tdefer os.RemoveAll(o.BaseDirectoryPath)\n\tvar mh = &mockedHandler{}\n\tvar s = httptest.NewServer(mh)\n\n\t// Test linux\n\tp, err := newPaths(\"linux\", \"amd64\", o)\n\tassert.NoError(t, err)\n\tp.astilectronUnzipSrc = filepath.Join(p.astilectronDownloadDst, \"astilectron\")\n\tp.astilectronDownloadSrc = s.URL + \"/provisioner/astilectron\"\n\tp.electronDownloadSrc = s.URL + \"/provisioner/electron/linux\"\n\terr = newDefaultProvisioner(nil).Provision(context.Background(), \"\", \"linux\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron, *p)\n\tassert.NoError(t, err)\n\ttestProvisionerSuccessful(t, *p, \"linux\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron)\n\n\t// Test nothing happens if provision status is up to date\n\tmh.e = true\n\tos.Remove(p.AstilectronDownloadDst())\n\tos.Remove(p.ElectronDownloadDst())\n\terr = newDefaultProvisioner(nil).Provision(context.Background(), \"\", \"linux\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron, *p)\n\tassert.NoError(t, err)\n\ttestProvisionerSuccessful(t, *p, \"linux\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron)\n\n\t// Test windows\n\tmh.e = false\n\tos.RemoveAll(o.BaseDirectoryPath)\n\tp, err = newPaths(\"windows\", \"amd64\", o)\n\tassert.NoError(t, err)\n\tp.astilectronUnzipSrc = filepath.Join(p.astilectronDownloadDst, \"astilectron\")\n\tp.astilectronDownloadSrc = s.URL + \"/provisioner/astilectron\"\n\tp.electronDownloadSrc = s.URL + \"/provisioner/electron/windows\"\n\terr = newDefaultProvisioner(nil).Provision(context.Background(), \"\", \"windows\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron, *p)\n\tassert.NoError(t, err)\n\ttestProvisionerSuccessful(t, *p, \"windows\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron)\n\n\t// Test darwin without custom app name + icon\n\tos.RemoveAll(o.BaseDirectoryPath)\n\tp, err = newPaths(\"darwin\", \"amd64\", o)\n\tassert.NoError(t, err)\n\tp.astilectronUnzipSrc = filepath.Join(p.astilectronDownloadDst, \"astilectron\")\n\tp.astilectronDownloadSrc = s.URL + \"/provisioner/astilectron\"\n\tp.electronDownloadSrc = s.URL + \"/provisioner/electron/darwin\"\n\terr = newDefaultProvisioner(nil).Provision(context.Background(), \"\", \"darwin\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron, *p)\n\tassert.NoError(t, err)\n\ttestProvisionerSuccessful(t, *p, \"darwin\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron)\n\n\t// Test darwin with custom app name + icon\n\tos.RemoveAll(o.BaseDirectoryPath)\n\to.AppName = \"Test app\"\n\twd, err := os.Getwd()\n\tassert.NoError(t, err)\n\to.AppIconDarwinPath = filepath.Join(wd, \"testdata\", \"provisioner\", \"icon.icns\")\n\tp, err = newPaths(\"darwin\", \"amd64\", o)\n\tassert.NoError(t, err)\n\tp.astilectronUnzipSrc = filepath.Join(p.astilectronDownloadDst, \"astilectron\")\n\tp.astilectronDownloadSrc = s.URL + \"/provisioner/astilectron\"\n\tp.electronDownloadSrc = s.URL + \"/provisioner/electron/darwin\"\n\terr = newDefaultProvisioner(nil).Provision(context.Background(), o.AppName, \"darwin\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron, *p)\n\tassert.NoError(t, err)\n\ttestProvisionerSuccessful(t, *p, \"darwin\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron)\n\t// Rename\n\t_, err = os.Stat(filepath.Join(p.ElectronDirectory(), o.AppName+\".app\"))\n\tassert.NoError(t, err)\n\t_, err = os.Stat(filepath.Join(p.ElectronDirectory(), o.AppName+\".app\", \"Contents\", \"MacOS\", o.AppName))\n\tassert.NoError(t, err)\n\t_, err = os.Stat(filepath.Join(p.ElectronDirectory(), o.AppName+\".app\", \"Contents\", \"Frameworks\", o.AppName+\" Helper.app\"))\n\tassert.NoError(t, err)\n\t_, err = os.Stat(filepath.Join(p.ElectronDirectory(), o.AppName+\".app\", \"Contents\", \"Frameworks\", o.AppName+\" Helper.app\", \"Contents\", \"MacOS\", o.AppName+\" Helper\"))\n\tassert.NoError(t, err)\n\t// Icon\n\tb, err := ioutil.ReadFile(filepath.Join(p.ElectronDirectory(), o.AppName+\".app\", \"Contents\", \"Resources\", \"electron.icns\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"body\", string(b))\n\t// Replace\n\tb, err = ioutil.ReadFile(filepath.Join(p.ElectronDirectory(), o.AppName+\".app\", \"Contents\", \"Info.plist\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"<string>\"+o.AppName+\" Test</string>\", string(b))\n\tb, err = ioutil.ReadFile(filepath.Join(p.ElectronDirectory(), o.AppName+\".app\", \"Contents\", \"Frameworks\", o.AppName+\" Helper.app\", \"Contents\", \"Info.plist\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"<string>\"+o.AppName+\" Test</string>\", string(b))\n}\n\nfunc TestNewDisembedderProvisioner(t *testing.T) {\n\t// Init\n\tvar o = Options{BaseDirectoryPath: mockedTempPath()}\n\tdefer os.RemoveAll(o.BaseDirectoryPath)\n\tp, err := newPaths(\"linux\", \"amd64\", o)\n\tassert.NoError(t, err)\n\tp.astilectronUnzipSrc = filepath.Join(p.astilectronDownloadDst, \"astilectron-0.35.1\")\n\tpvb := NewDisembedderProvisioner(mockedDisembedder, \"astilectron\", \"electron/linux\", nil)\n\n\t// Test provision\n\terr = pvb.Provision(context.Background(), \"\", \"linux\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron, *p)\n\tassert.NoError(t, err)\n\ttestProvisionerSuccessful(t, *p, \"linux\", \"amd64\", DefaultVersionAstilectron, DefaultVersionElectron)\n}\n\nfunc TestRemoveDownloadDst(t *testing.T) {\n\tvar o = Options{\n\t\tDataDirectoryPath: mockedTempPath(),\n\t}\n\n\t// Make sure the test directory doesn't exist.\n\tif err := os.RemoveAll(o.DataDirectoryPath); err != nil && !os.IsNotExist(err) {\n\t\tt.Fatalf(\"main: removing %s failed: %s\", o.DataDirectoryPath, err)\n\t}\n\tdefer os.RemoveAll(o.DataDirectoryPath)\n\n\ta, err := New(astikit.AdaptTestLogger(t), o)\n\tif err != nil {\n\t\tt.Fatalf(\"main: creating astilectron failed: %s\", err)\n\t}\n\n\tp := a.Paths()\n\n\tif err = a.provision(); err != nil {\n\t\tt.Fatalf(\"main: provisionning failed: %s\", err)\n\t}\n\n\t// Check UnZip successful\n\tif _, err := os.Stat(p.AstilectronDirectory()); os.IsNotExist(err) {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\n\tif _, err := os.Stat(p.ElectronDirectory()); os.IsNotExist(err) {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\n\t// Check Zip doesn't exist\n\tif _, err := os.Stat(p.AstilectronDownloadDst()); !os.IsNotExist(err) {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\n\tif _, err := os.Stat(p.ElectronDownloadDst()); !os.IsNotExist(err) {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n}\n"
        },
        {
          "name": "reader.go",
          "type": "blob",
          "size": 1.435546875,
          "content": "package astilectron\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// reader represents an object capable of reading in the TCP server\ntype reader struct {\n\tctx context.Context\n\td   *dispatcher\n\tl   astikit.SeverityLogger\n\tr   io.ReadCloser\n}\n\n// newReader creates a new reader\nfunc newReader(ctx context.Context, l astikit.SeverityLogger, d *dispatcher, r io.ReadCloser) *reader {\n\treturn &reader{\n\t\tctx: ctx,\n\t\td:   d,\n\t\tl:   l,\n\t\tr:   r,\n\t}\n}\n\n// close closes the reader properly\nfunc (r *reader) close() error {\n\treturn r.r.Close()\n}\n\n// isEOFErr checks whether the error is an EOF error\n// wsarecv is the error sent on Windows when the client closes its connection\nfunc (r *reader) isEOFErr(err error) bool {\n\treturn err == io.EOF || strings.Contains(strings.ToLower(err.Error()), \"wsarecv:\")\n}\n\n// read reads from stdout\nfunc (r *reader) read() {\n\tvar reader = bufio.NewReader(r.r)\n\tfor {\n\t\t// Check context error\n\t\tif r.ctx.Err() != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// Read next line\n\t\tvar b []byte\n\t\tvar err error\n\t\tif b, err = reader.ReadBytes('\\n'); err != nil {\n\t\t\tif !r.isEOFErr(err) {\n\t\t\t\tr.l.Errorf(\"%s while reading\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tb = bytes.TrimSpace(b)\n\t\tr.l.Debugf(\"Astilectron says: %s\", b)\n\n\t\t// Unmarshal\n\t\tvar e Event\n\t\tif err = json.Unmarshal(b, &e); err != nil {\n\t\t\tr.l.Errorf(\"%s while unmarshaling %s\", err, b)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Dispatch\n\t\tr.d.dispatch(e)\n\t}\n}\n"
        },
        {
          "name": "reader_test.go",
          "type": "blob",
          "size": 1.58203125,
          "content": "package astilectron\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// mockedReader represents a mocked reader\ntype mockedReader struct {\n\t*bytes.Buffer\n\tc bool\n}\n\n// Close implements the io.Close interface\nfunc (r *mockedReader) Close() error {\n\tr.c = true\n\treturn nil\n}\n\nfunc TestReader_IsEOFErr(t *testing.T) {\n\tvar r = newReader(context.Background(), &logger{}, &dispatcher{}, ioutil.NopCloser(&bytes.Buffer{}))\n\tassert.True(t, r.isEOFErr(io.EOF))\n\tassert.True(t, r.isEOFErr(errors.New(\"read tcp 127.0.0.1:56093->127.0.0.1:56092: wsarecv: An existing connection was forcibly closed by the remote host.\")))\n\tassert.False(t, r.isEOFErr(errors.New(\"random error\")))\n}\n\nfunc TestReader(t *testing.T) {\n\t// Init\n\tvar mr = &mockedReader{Buffer: bytes.NewBuffer([]byte(\"{\\\"name\\\":\\\"1\\\",\\\"targetId\\\":\\\"1\\\"}\\n{\\n{\\\"name\\\":\\\"2\\\",\\\"targetId\\\":\\\"2\\\"}\\n\"))}\n\tvar d = newDispatcher()\n\tvar wg = &sync.WaitGroup{}\n\tvar dispatched = []int{}\n\tvar dispatchedMutex = sync.Mutex{}\n\td.addListener(\"1\", \"1\", func(e Event) (deleteListener bool) {\n\t\tdispatchedMutex.Lock()\n\t\tdispatched = append(dispatched, 1)\n\t\tdispatchedMutex.Unlock()\n\t\twg.Done()\n\t\treturn\n\t})\n\td.addListener(\"2\", \"2\", func(e Event) (deleteListener bool) {\n\t\tdispatchedMutex.Lock()\n\t\tdispatched = append(dispatched, 2)\n\t\tdispatchedMutex.Unlock()\n\t\twg.Done()\n\t\treturn\n\t})\n\twg.Add(2)\n\tvar r = newReader(context.Background(), &logger{}, d, mr)\n\n\t// Test read\n\tgo r.read()\n\twg.Wait()\n\tassert.Contains(t, dispatched, 1)\n\tassert.Contains(t, dispatched, 2)\n\n\t// Test close\n\tr.close()\n\tassert.True(t, mr.c)\n}\n"
        },
        {
          "name": "rectangle.go",
          "type": "blob",
          "size": 0.6171875,
          "content": "package astilectron\n\n// Position represents a position\ntype Position struct {\n\tX, Y int\n}\n\n// PositionOptions represents position options\ntype PositionOptions struct {\n\tX *int `json:\"x,omitempty\"`\n\tY *int `json:\"y,omitempty\"`\n}\n\n// Size represents a size\ntype Size struct {\n\tHeight, Width int\n}\n\n// SizeOptions represents size options\ntype SizeOptions struct {\n\tHeight *int `json:\"height,omitempty\"`\n\tWidth  *int `json:\"width,omitempty\"`\n}\n\n// Rectangle represents a rectangle\ntype Rectangle struct {\n\tPosition\n\tSize\n}\n\n// RectangleOptions represents rectangle options\ntype RectangleOptions struct {\n\tPositionOptions\n\tSizeOptions\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 1.81640625,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n)\n\n// Session event names\nconst (\n\tEventNameSessionCmdClearCache      \t = \"session.cmd.clear.cache\"\n\tEventNameSessionEventClearedCache  \t = \"session.event.cleared.cache\"\n\tEventNameSessionCmdFlushStorage    \t = \"session.cmd.flush.storage\"\n\tEventNameSessionEventFlushedStorage\t = \"session.event.flushed.storage\"\n\tEventNameSessionCmdLoadExtension   \t = \"session.cmd.load.extension\"\n\tEventNameSessionEventLoadedExtension \t = \"session.event.loaded.extension\"\n\tEventNameSessionEventWillDownload  \t = \"session.event.will.download\"\n)\n\n// Session represents a session\n// TODO Add missing session methods\n// TODO Add missing session events\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/session.md\ntype Session struct {\n\t*object\n}\n\n// newSession creates a new session\nfunc newSession(ctx context.Context, d *dispatcher, i *identifier, w *writer) *Session {\n\treturn &Session{object: newObject(ctx, d, i, w, i.new())}\n}\n\n// ClearCache clears the Session's HTTP cache\nfunc (s *Session) ClearCache() (err error) {\n\tif err = s.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(s.ctx, s, s.w, Event{Name: EventNameSessionCmdClearCache, TargetID: s.id}, EventNameSessionEventClearedCache)\n\treturn\n}\n\n// FlushStorage writes any unwritten DOMStorage data to disk\nfunc (s *Session) FlushStorage() (err error) {\n\tif err = s.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(s.ctx, s, s.w, Event{Name: EventNameSessionCmdFlushStorage, TargetID: s.id}, EventNameSessionEventFlushedStorage)\n\treturn\n}\n\n// Loads a chrome extension\nfunc (s *Session) LoadExtension(path string) (err error) {\t\n\tif err = s.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(s.ctx, s, s.w, Event{Name: EventNameSessionCmdLoadExtension, Path: path, TargetID: s.id}, EventNameSessionEventLoadedExtension)\n\treturn\n}\n"
        },
        {
          "name": "session_test.go",
          "type": "blob",
          "size": 0.6318359375,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\nfunc TestSession_Actions(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar i = newIdentifier()\n\tvar wrt = &mockedWriter{}\n\tvar w = newWriter(wrt, &logger{})\n\tvar s = newSession(context.Background(), d, i, w)\n\n\t// Actions\n\ttestObjectAction(t, func() error { return s.ClearCache() }, s.object, wrt, \"{\\\"name\\\":\\\"session.cmd.clear.cache\\\",\\\"targetID\\\":\\\"1\\\"}\\n\", EventNameSessionEventClearedCache, nil)\n\ttestObjectAction(t, func() error { return s.FlushStorage() }, s.object, wrt, \"{\\\"name\\\":\\\"session.cmd.flush.storage\\\",\\\"targetID\\\":\\\"1\\\"}\\n\", EventNameSessionEventFlushedStorage, nil)\n}\n"
        },
        {
          "name": "sub_menu.go",
          "type": "blob",
          "size": 5.0546875,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// Sub menu event names\nconst (\n\tEventNameSubMenuCmdAppend        = \"sub.menu.cmd.append\"\n\tEventNameSubMenuCmdClosePopup    = \"sub.menu.cmd.close.popup\"\n\tEventNameSubMenuCmdInsert        = \"sub.menu.cmd.insert\"\n\tEventNameSubMenuCmdPopup         = \"sub.menu.cmd.popup\"\n\tEventNameSubMenuEventAppended    = \"sub.menu.event.appended\"\n\tEventNameSubMenuEventClosedPopup = \"sub.menu.event.closed.popup\"\n\tEventNameSubMenuEventInserted    = \"sub.menu.event.inserted\"\n\tEventNameSubMenuEventPoppedUp    = \"sub.menu.event.popped.up\"\n)\n\n// SubMenu represents an exported sub menu\ntype SubMenu struct {\n\t*subMenu\n}\n\n// subMenu represents an internal sub menu\n// We use this internal subMenu in SubMenu and Menu since all functions of subMenu should be in SubMenu and Menu but\n// some functions of Menu shouldn't be in SubMenu and vice versa\ntype subMenu struct {\n\t*object\n\titems []*MenuItem\n\t// We must store the root ID since everytime we update a sub menu we need to set the root menu all over again in electron\n\trootID string\n}\n\n// newSubMenu creates a new sub menu\nfunc newSubMenu(ctx context.Context, rootID string, items []*MenuItemOptions, d *dispatcher, i *identifier, w *writer) *subMenu {\n\t// Init\n\tvar m = &subMenu{\n\t\tobject: newObject(ctx, d, i, w, i.new()),\n\t\trootID: rootID,\n\t}\n\n\t// Parse items\n\tfor _, o := range items {\n\t\tm.items = append(m.items, newMenuItem(m.ctx, rootID, o, d, i, w))\n\t}\n\treturn m\n}\n\n// toEvent returns the sub menu in the proper event format\nfunc (m *subMenu) toEvent() (e *EventSubMenu) {\n\te = &EventSubMenu{\n\t\tID:     m.id,\n\t\tRootID: m.rootID,\n\t}\n\tfor _, i := range m.items {\n\t\te.Items = append(e.Items, i.toEvent())\n\t}\n\treturn\n}\n\n// NewItem returns a new menu item\nfunc (m *subMenu) NewItem(o *MenuItemOptions) *MenuItem {\n\treturn newMenuItem(m.ctx, m.rootID, o, m.d, m.i, m.w)\n}\n\n// SubMenu returns the sub menu at the specified indexes\nfunc (m *subMenu) SubMenu(indexes ...int) (s *SubMenu, err error) {\n\tvar is = m\n\tvar processedIndexes = []string{}\n\tfor _, index := range indexes {\n\t\tif index >= len(is.items) {\n\t\t\treturn nil, fmt.Errorf(\"submenu at %s has %d items, invalid index %d\", strings.Join(processedIndexes, \":\"), len(is.items), index)\n\t\t}\n\t\ts = is.items[index].s\n\t\tprocessedIndexes = append(processedIndexes, strconv.Itoa(index))\n\t\tif s == nil {\n\t\t\treturn nil, fmt.Errorf(\"no submenu at %s\", strings.Join(processedIndexes, \":\"))\n\t\t}\n\t\tis = s.subMenu\n\t}\n\treturn\n}\n\n// Item returns the item at the specified indexes\nfunc (m *subMenu) Item(indexes ...int) (mi *MenuItem, err error) {\n\tvar is = m\n\tif len(indexes) > 1 {\n\t\tvar s *SubMenu\n\t\tif s, err = m.SubMenu(indexes[:len(indexes)-1]...); err != nil {\n\t\t\treturn\n\t\t}\n\t\tis = s.subMenu\n\t}\n\tvar index = indexes[len(indexes)-1]\n\tif index >= len(is.items) {\n\t\treturn nil, fmt.Errorf(\"submenu has %d items, invalid index %d\", len(is.items), index)\n\t}\n\tmi = is.items[index]\n\treturn\n}\n\n// Append appends a menu item into the sub menu\nfunc (m *subMenu) Append(i *MenuItem) (err error) {\n\tif err = m.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tif _, err = synchronousEvent(m.ctx, m, m.w, Event{Name: EventNameSubMenuCmdAppend, TargetID: m.id, MenuItem: i.toEvent()}, EventNameSubMenuEventAppended); err != nil {\n\t\treturn\n\t}\n\tm.items = append(m.items, i)\n\treturn\n}\n\n// Insert inserts a menu item to the position of the sub menu\nfunc (m *subMenu) Insert(pos int, i *MenuItem) (err error) {\n\tif err = m.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tif pos > len(m.items) {\n\t\terr = fmt.Errorf(\"submenu has %d items, position %d is invalid\", len(m.items), pos)\n\t\treturn\n\t}\n\tif _, err = synchronousEvent(m.ctx, m, m.w, Event{Name: EventNameSubMenuCmdInsert, TargetID: m.id, MenuItem: i.toEvent(), MenuItemPosition: astikit.IntPtr(pos)}, EventNameSubMenuEventInserted); err != nil {\n\t\treturn\n\t}\n\tm.items = append(m.items[:pos], append([]*MenuItem{i}, m.items[pos:]...)...)\n\treturn\n}\n\n// MenuPopupOptions represents menu pop options\ntype MenuPopupOptions struct {\n\tPositionOptions\n\tPositioningItem *int `json:\"positioningItem,omitempty\"`\n}\n\n// Popup pops up the menu as a context menu in the focused window\nfunc (m *subMenu) Popup(o *MenuPopupOptions) error {\n\treturn m.PopupInWindow(nil, o)\n}\n\n// PopupInWindow pops up the menu as a context menu in the specified window\nfunc (m *subMenu) PopupInWindow(w *Window, o *MenuPopupOptions) (err error) {\n\tif err = m.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tvar e = Event{Name: EventNameSubMenuCmdPopup, TargetID: m.id, MenuPopupOptions: o}\n\tif w != nil {\n\t\te.WindowID = w.id\n\t}\n\t_, err = synchronousEvent(m.ctx, m, m.w, e, EventNameSubMenuEventPoppedUp)\n\treturn\n}\n\n// ClosePopup close the context menu in the focused window\nfunc (m *subMenu) ClosePopup() error {\n\treturn m.ClosePopupInWindow(nil)\n}\n\n// ClosePopupInWindow close the context menu in the specified window\nfunc (m *subMenu) ClosePopupInWindow(w *Window) (err error) {\n\tif err = m.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tvar e = Event{Name: EventNameSubMenuCmdClosePopup, TargetID: m.id}\n\tif w != nil {\n\t\te.WindowID = w.id\n\t}\n\t_, err = synchronousEvent(m.ctx, m, m.w, e, EventNameSubMenuEventClosedPopup)\n\treturn\n}\n"
        },
        {
          "name": "sub_menu_test.go",
          "type": "blob",
          "size": 5.1826171875,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/asticode/go-astikit\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubMenu_ToEvent(t *testing.T) {\n\t// App sub menu\n\tvar s = newSubMenu(context.Background(), targetIDApp, []*MenuItemOptions{{Label: astikit.StrPtr(\"1\")}, {Label: astikit.StrPtr(\"2\")}}, newDispatcher(), newIdentifier(), nil)\n\te := s.toEvent()\n\tassert.Equal(t, &EventSubMenu{ID: \"1\", Items: []*EventMenuItem{{ID: \"2\", Options: &MenuItemOptions{Label: astikit.StrPtr(\"1\")}, RootID: targetIDApp}, {ID: \"3\", Options: &MenuItemOptions{Label: astikit.StrPtr(\"2\")}, RootID: targetIDApp}}, RootID: targetIDApp}, e)\n\n\t// Window sub menu\n\tvar i = newIdentifier()\n\tw, err := newWindow(context.Background(), nil, Options{}, Paths{}, \"http://test.com\", &WindowOptions{}, newDispatcher(), i, nil)\n\tassert.NoError(t, err)\n\ts = newSubMenu(context.Background(), w.id, []*MenuItemOptions{{Label: astikit.StrPtr(\"1\")}, {Label: astikit.StrPtr(\"2\")}}, newDispatcher(), i, nil)\n\te = s.toEvent()\n\tassert.Equal(t, &EventSubMenu{ID: \"3\", Items: []*EventMenuItem{{ID: \"4\", Options: &MenuItemOptions{Label: astikit.StrPtr(\"1\")}, RootID: \"1\"}, {ID: \"5\", Options: &MenuItemOptions{Label: astikit.StrPtr(\"2\")}, RootID: \"1\"}}, RootID: \"1\"}, e)\n}\n\nfunc TestSubMenu_SubMenu(t *testing.T) {\n\tvar o = []*MenuItemOptions{\n\t\t{},\n\t\t{SubMenu: []*MenuItemOptions{\n\t\t\t{},\n\t\t\t{SubMenu: []*MenuItemOptions{\n\t\t\t\t{},\n\t\t\t\t{},\n\t\t\t\t{},\n\t\t\t}},\n\t\t\t{},\n\t\t}},\n\t\t{},\n\t}\n\tvar m = newMenu(context.Background(), targetIDApp, o, newDispatcher(), newIdentifier(), nil)\n\t_, err := m.SubMenu(0, 1)\n\tassert.EqualError(t, err, \"no submenu at 0\")\n\ts, err := m.SubMenu(1)\n\tassert.NoError(t, err)\n\tassert.Len(t, s.items, 3)\n\t_, err = m.SubMenu(1, 0)\n\tassert.EqualError(t, err, \"no submenu at 1:0\")\n\ts, err = m.SubMenu(1, 1)\n\tassert.NoError(t, err)\n\tassert.Len(t, s.items, 3)\n\t_, err = m.SubMenu(1, 3)\n\tassert.EqualError(t, err, \"submenu at 1 has 3 items, invalid index 3\")\n}\n\nfunc TestSubMenu_Item(t *testing.T) {\n\tvar o = []*MenuItemOptions{\n\t\t{Label: astikit.StrPtr(\"1\")},\n\t\t{Label: astikit.StrPtr(\"2\"), SubMenu: []*MenuItemOptions{\n\t\t\t{Label: astikit.StrPtr(\"2-1\")},\n\t\t\t{Label: astikit.StrPtr(\"2-2\"), SubMenu: []*MenuItemOptions{\n\t\t\t\t{Label: astikit.StrPtr(\"2-2-1\")},\n\t\t\t\t{Label: astikit.StrPtr(\"2-2-2\")},\n\t\t\t\t{Label: astikit.StrPtr(\"2-2-3\")},\n\t\t\t}},\n\t\t\t{Label: astikit.StrPtr(\"2-3\")},\n\t\t}},\n\t\t{Label: astikit.StrPtr(\"3\")},\n\t}\n\tvar m = newMenu(context.Background(), targetIDApp, o, newDispatcher(), newIdentifier(), nil)\n\t_, err := m.Item(3)\n\tassert.EqualError(t, err, \"submenu has 3 items, invalid index 3\")\n\ti, err := m.Item(0)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"1\", *i.o.Label)\n\t_, err = m.Item(1, 3)\n\tassert.EqualError(t, err, \"submenu has 3 items, invalid index 3\")\n\ti, err = m.Item(1, 2)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"2-3\", *i.o.Label)\n\ti, err = m.Item(1, 1, 0)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"2-2-1\", *i.o.Label)\n}\n\nfunc TestSubMenu_Actions(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar i = newIdentifier()\n\tvar wrt = &mockedWriter{}\n\tvar w = newWriter(wrt, &logger{})\n\tvar s = newSubMenu(context.Background(), targetIDApp, []*MenuItemOptions{{Label: astikit.StrPtr(\"0\")}}, d, i, w)\n\n\t// Actions\n\tvar mi = s.NewItem(&MenuItemOptions{Label: astikit.StrPtr(\"1\")})\n\ttestObjectAction(t, func() error { return s.Append(mi) }, s.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameSubMenuCmdAppend+\"\\\",\\\"targetID\\\":\\\"\"+s.id+\"\\\",\\\"menuItem\\\":{\\\"id\\\":\\\"3\\\",\\\"options\\\":{\\\"label\\\":\\\"1\\\"},\\\"rootId\\\":\\\"\"+targetIDApp+\"\\\"}}\\n\", EventNameSubMenuEventAppended, nil)\n\tassert.Len(t, s.items, 2)\n\tassert.Equal(t, \"1\", *s.items[1].o.Label)\n\tmi = s.NewItem(&MenuItemOptions{Label: astikit.StrPtr(\"2\")})\n\terr := s.Insert(3, mi)\n\tassert.EqualError(t, err, \"submenu has 2 items, position 3 is invalid\")\n\ttestObjectAction(t, func() error { return s.Insert(1, mi) }, s.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameSubMenuCmdInsert+\"\\\",\\\"targetID\\\":\\\"\"+s.id+\"\\\",\\\"menuItem\\\":{\\\"id\\\":\\\"4\\\",\\\"options\\\":{\\\"label\\\":\\\"2\\\"},\\\"rootId\\\":\\\"\"+targetIDApp+\"\\\"},\\\"menuItemPosition\\\":1}\\n\", EventNameSubMenuEventInserted, nil)\n\tassert.Len(t, s.items, 3)\n\tassert.Equal(t, \"2\", *s.items[1].o.Label)\n\ttestObjectAction(t, func() error {\n\t\treturn s.Popup(&MenuPopupOptions{PositionOptions: PositionOptions{X: astikit.IntPtr(1), Y: astikit.IntPtr(2)}})\n\t}, s.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameSubMenuCmdPopup+\"\\\",\\\"targetID\\\":\\\"\"+s.id+\"\\\",\\\"menuPopupOptions\\\":{\\\"x\\\":1,\\\"y\\\":2}}\\n\", EventNameSubMenuEventPoppedUp, nil)\n\ttestObjectAction(t, func() error {\n\t\treturn s.PopupInWindow(&Window{object: &object{id: \"2\"}}, &MenuPopupOptions{PositionOptions: PositionOptions{X: astikit.IntPtr(1), Y: astikit.IntPtr(2)}})\n\t}, s.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameSubMenuCmdPopup+\"\\\",\\\"targetID\\\":\\\"\"+s.id+\"\\\",\\\"menuPopupOptions\\\":{\\\"x\\\":1,\\\"y\\\":2},\\\"windowId\\\":\\\"2\\\"}\\n\", EventNameSubMenuEventPoppedUp, nil)\n\ttestObjectAction(t, func() error { return s.ClosePopup() }, s.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameSubMenuCmdClosePopup+\"\\\",\\\"targetID\\\":\\\"\"+s.id+\"\\\"}\\n\", EventNameSubMenuEventClosedPopup, nil)\n\ttestObjectAction(t, func() error { return s.ClosePopupInWindow(&Window{object: &object{id: \"2\"}}) }, s.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameSubMenuCmdClosePopup+\"\\\",\\\"targetID\\\":\\\"\"+s.id+\"\\\",\\\"windowId\\\":\\\"2\\\"}\\n\", EventNameSubMenuEventClosedPopup, nil)\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tray.go",
          "type": "blob",
          "size": 3.5478515625,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// Tray event names\nconst (\n\tEventNameTrayCmdCreate                = \"tray.cmd.create\"\n\tEventNameTrayCmdDestroy               = \"tray.cmd.destroy\"\n\tEventNameTrayCmdSetImage              = \"tray.cmd.set.image\"\n\tEventNameTrayCmdPopupContextMenu      = \"tray.cmd.popup.context.menu\"\n\tEventNameTrayEventClicked             = \"tray.event.clicked\"\n\tEventNameTrayEventCreated             = \"tray.event.created\"\n\tEventNameTrayEventDestroyed           = \"tray.event.destroyed\"\n\tEventNameTrayEventDoubleClicked       = \"tray.event.double.clicked\"\n\tEventNameTrayEventImageSet            = \"tray.event.image.set\"\n\tEventNameTrayEventRightClicked        = \"tray.event.right.clicked\"\n\tEventNameTrayEventContextMenuPoppedUp = \"tray.event.context.menu.popped.up\"\n)\n\n// Tray represents a tray\ntype Tray struct {\n\t*object\n\to *TrayOptions\n}\n\n// TrayOptions represents tray options\n// We must use pointers since GO doesn't handle optional fields whereas NodeJS does. Use astikit.BoolPtr, astikit.IntPtr or astikit.StrPtr\n// to fill the struct\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/tray.md\ntype TrayOptions struct {\n\tImage   *string `json:\"image,omitempty\"`\n\tTooltip *string `json:\"tooltip,omitempty\"`\n}\n\n// TrayPopUpOptions represents Tray PopUpContextMenu options\ntype TrayPopUpOptions struct {\n\tMenu     *Menu\n\tPosition *PositionOptions\n}\n\n// newTray creates a new tray\nfunc newTray(ctx context.Context, o *TrayOptions, d *dispatcher, i *identifier, wrt *writer) (t *Tray) {\n\t// Init\n\tt = &Tray{\n\t\to:      o,\n\t\tobject: newObject(ctx, d, i, wrt, i.new()),\n\t}\n\n\t// Make sure the tray's context is cancelled once the destroyed event is received\n\tt.On(EventNameTrayEventDestroyed, func(e Event) (deleteListener bool) {\n\t\tt.cancel()\n\t\treturn true\n\t})\n\treturn\n}\n\n// Create creates the tray\nfunc (t *Tray) Create() (err error) {\n\tif err = t.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tvar e = Event{Name: EventNameTrayCmdCreate, TargetID: t.id, TrayOptions: t.o}\n\t_, err = synchronousEvent(t.ctx, t, t.w, e, EventNameTrayEventCreated)\n\treturn\n}\n\n// Destroy destroys the tray\nfunc (t *Tray) Destroy() (err error) {\n\tif err = t.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(t.ctx, t, t.w, Event{Name: EventNameTrayCmdDestroy, TargetID: t.id}, EventNameTrayEventDestroyed)\n\treturn\n}\n\n// NewMenu creates a new tray menu\nfunc (t *Tray) NewMenu(i []*MenuItemOptions) *Menu {\n\treturn newMenu(t.ctx, t.id, i, t.d, t.i, t.w)\n}\n\n// SetImage sets the tray image\nfunc (t *Tray) SetImage(image string) (err error) {\n\tif err = t.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tt.o.Image = astikit.StrPtr(image)\n\t_, err = synchronousEvent(t.ctx, t, t.w, Event{Name: EventNameTrayCmdSetImage, Image: image, TargetID: t.id}, EventNameTrayEventImageSet)\n\treturn\n}\n\n// PopUpContextMenu pops up the context menu of the tray icon.\n// When menu is passed, the menu will be shown instead of the tray icon's context menu.\n// The position is only available on Windows, and it is (0, 0) by default.\n// https://www.electronjs.org/docs/latest/api/tray#traypopupcontextmenumenu-position-macos-windows\nfunc (t *Tray) PopUpContextMenu(p *TrayPopUpOptions) (err error) {\n\tvar em *EventMenu\n\tvar mp *MenuPopupOptions\n\tif err = t.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tif p.Menu != nil {\n\t\tem = p.Menu.toEvent()\n\t}\n\tif p.Position != nil {\n\t\tmp = &MenuPopupOptions{PositionOptions: *p.Position}\n\t}\n\tvar e = Event{Name: EventNameTrayCmdPopupContextMenu, TargetID: t.id, Menu: em, MenuPopupOptions: mp}\n\t_, err = synchronousEvent(t.ctx, t, t.w, e, EventNameTrayEventContextMenuPoppedUp)\n\treturn\n}\n"
        },
        {
          "name": "tray_test.go",
          "type": "blob",
          "size": 3.712890625,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/asticode/go-astikit\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTray_Actions(t *testing.T) {\n\t// Init\n\tvar d = newDispatcher()\n\tvar i = newIdentifier()\n\tvar wrt = &mockedWriter{}\n\tvar w = newWriter(wrt, &logger{})\n\tvar tr = newTray(context.Background(), &TrayOptions{\n\t\tImage:   astikit.StrPtr(\"/path/to/image\"),\n\t\tTooltip: astikit.StrPtr(\"tooltip\"),\n\t}, d, i, w)\n\tvar m = tr.NewMenu([]*MenuItemOptions{\n\t\t{\n\t\t\tLabel: astikit.StrPtr(\"Root 1\"),\n\t\t\tSubMenu: []*MenuItemOptions{\n\t\t\t\t{Label: astikit.StrPtr(\"Item 1\")},\n\t\t\t\t{Label: astikit.StrPtr(\"Item 2\")},\n\t\t\t\t{Type: MenuItemTypeSeparator},\n\t\t\t\t{Label: astikit.StrPtr(\"Item 3\")},\n\t\t\t},\n\t\t}})\n\tvar p = &PositionOptions{\n\t\tX: astikit.IntPtr(250),\n\t\tY: astikit.IntPtr(250),\n\t}\n\n\t// Actions\n\ttestObjectAction(t, func() error { return tr.Create() }, tr.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameTrayCmdCreate+\"\\\",\\\"targetID\\\":\\\"\"+tr.id+\"\\\",\\\"trayOptions\\\":{\\\"image\\\":\\\"/path/to/image\\\",\\\"tooltip\\\":\\\"tooltip\\\"}}\\n\", EventNameTrayEventCreated, nil)\n\ttestObjectAction(t, func() error { return tr.SetImage(\"test\") }, tr.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameTrayCmdSetImage+\"\\\",\\\"targetID\\\":\\\"\"+tr.id+\"\\\",\\\"image\\\":\\\"test\\\"}\\n\", EventNameTrayEventImageSet, nil)\n\ttestObjectAction(t, func() error { return tr.PopUpContextMenu(&TrayPopUpOptions{}) }, tr.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameTrayCmdPopupContextMenu+\"\\\",\\\"targetID\\\":\\\"\"+tr.id+\"\\\"}\\n\", EventNameTrayEventContextMenuPoppedUp, nil)\n\ttestObjectAction(t, func() error { return tr.PopUpContextMenu(&TrayPopUpOptions{Position: p}) }, tr.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameTrayCmdPopupContextMenu+\"\\\",\\\"targetID\\\":\\\"\"+tr.id+\"\\\",\\\"menuPopupOptions\\\":{\\\"x\\\":250,\\\"y\\\":250}}\\n\", EventNameTrayEventContextMenuPoppedUp, nil)\n\ttestObjectAction(t, func() error { return tr.PopUpContextMenu(&TrayPopUpOptions{Menu: m}) }, tr.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameTrayCmdPopupContextMenu+\"\\\",\\\"targetID\\\":\\\"\"+tr.id+\"\\\",\\\"menu\\\":{\\\"id\\\":\\\"\"+m.id+\"\\\",\\\"items\\\":[{\\\"id\\\":\\\"3\\\",\\\"options\\\":{\\\"label\\\":\\\"Root 1\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\",\\\"submenu\\\":{\\\"id\\\":\\\"4\\\",\\\"items\\\":[{\\\"id\\\":\\\"5\\\",\\\"options\\\":{\\\"label\\\":\\\"Item 1\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"},{\\\"id\\\":\\\"6\\\",\\\"options\\\":{\\\"label\\\":\\\"Item 2\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"},{\\\"id\\\":\\\"7\\\",\\\"options\\\":{\\\"type\\\":\\\"separator\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"},{\\\"id\\\":\\\"8\\\",\\\"options\\\":{\\\"label\\\":\\\"Item 3\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"}],\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"}}],\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"}}\\n\", EventNameTrayEventContextMenuPoppedUp, nil)\n\ttestObjectAction(t, func() error { return tr.PopUpContextMenu(&TrayPopUpOptions{Menu: m, Position: p}) }, tr.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameTrayCmdPopupContextMenu+\"\\\",\\\"targetID\\\":\\\"\"+tr.id+\"\\\",\\\"menu\\\":{\\\"id\\\":\\\"\"+m.id+\"\\\",\\\"items\\\":[{\\\"id\\\":\\\"3\\\",\\\"options\\\":{\\\"label\\\":\\\"Root 1\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\",\\\"submenu\\\":{\\\"id\\\":\\\"4\\\",\\\"items\\\":[{\\\"id\\\":\\\"5\\\",\\\"options\\\":{\\\"label\\\":\\\"Item 1\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"},{\\\"id\\\":\\\"6\\\",\\\"options\\\":{\\\"label\\\":\\\"Item 2\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"},{\\\"id\\\":\\\"7\\\",\\\"options\\\":{\\\"type\\\":\\\"separator\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"},{\\\"id\\\":\\\"8\\\",\\\"options\\\":{\\\"label\\\":\\\"Item 3\\\"},\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"}],\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"}}],\\\"rootId\\\":\\\"\"+m.rootID+\"\\\"},\\\"menuPopupOptions\\\":{\\\"x\\\":250,\\\"y\\\":250}}\\n\", EventNameTrayEventContextMenuPoppedUp, nil)\n\ttestObjectAction(t, func() error { return tr.Destroy() }, tr.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameTrayCmdDestroy+\"\\\",\\\"targetID\\\":\\\"\"+tr.id+\"\\\"}\\n\", EventNameTrayEventDestroyed, nil)\n\tassert.True(t, tr.ctx.Err() != nil)\n}\n\nfunc TestTray_NewMenu(t *testing.T) {\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\ttr := a.NewTray(&TrayOptions{})\n\tm := tr.NewMenu([]*MenuItemOptions{})\n\tassert.Equal(t, tr.id, m.rootID)\n}\n"
        },
        {
          "name": "window.go",
          "type": "blob",
          "size": 26.6435546875,
          "content": "package astilectron\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tstdUrl \"net/url\"\n\t\"path/filepath\"\n\t\"sync\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// Window event names\nconst (\n\tEventNameWebContentsEventLogin                    = \"web.contents.event.login\"\n\tEventNameWebContentsEventLoginCallback            = \"web.contents.event.login.callback\"\n\tEventNameWindowCmdBlur                            = \"window.cmd.blur\"\n\tEventNameWindowCmdCenter                          = \"window.cmd.center\"\n\tEventNameWindowCmdClose                           = \"window.cmd.close\"\n\tEventNameWindowCmdCreate                          = \"window.cmd.create\"\n\tEventNameWindowCmdDestroy                         = \"window.cmd.destroy\"\n\tEventNameWindowCmdFocus                           = \"window.cmd.focus\"\n\tEventNameWindowCmdHide                            = \"window.cmd.hide\"\n\tEventNameWindowCmdLog                             = \"window.cmd.log\"\n\tEventNameWindowCmdMaximize                        = \"window.cmd.maximize\"\n\teventNameWindowCmdMessage                         = \"window.cmd.message\"\n\teventNameWindowCmdMessageCallback                 = \"window.cmd.message.callback\"\n\tEventNameWindowCmdMinimize                        = \"window.cmd.minimize\"\n\tEventNameWindowCmdMove                            = \"window.cmd.move\"\n\tEventNameWindowCmdMoveTop                         = \"window.cmd.move.top\"\n\tEventNameWindowCmdResize                          = \"window.cmd.resize\"\n\tEventNameWindowCmdResizeContent                   = \"window.cmd.resize.content\"\n\tEventNameWindowCmdSetBounds                       = \"window.cmd.set.bounds\"\n\tEventNameWindowCmdRestore                         = \"window.cmd.restore\"\n\tEventNameWindowCmdSetContentProtection            = \"window.cmd.set.content.protection\"\n\tEventNameWindowCmdShow                            = \"window.cmd.show\"\n\tEventNameWindowCmdUnmaximize                      = \"window.cmd.unmaximize\"\n\tEventNameWindowCmdUpdateCustomOptions             = \"window.cmd.update.custom.options\"\n\tEventNameWindowCmdWebContentsCloseDevTools        = \"window.cmd.web.contents.close.dev.tools\"\n\tEventNameWindowCmdWebContentsOpenDevTools         = \"window.cmd.web.contents.open.dev.tools\"\n\tEventNameWindowCmdWebContentsExecuteJavaScript    = \"window.cmd.web.contents.execute.javascript\"\n\tEventNameWindowCmdSetAlwaysOnTop                  = \"window.cmd.set.always.on.top\"\n\tEventNameWindowCmdSetFullScreen                   = \"window.cmd.set.full.screen\"\n\tEventNameWindowEventBlur                          = \"window.event.blur\"\n\tEventNameWindowEventClosed                        = \"window.event.closed\"\n\tEventNameWindowEventContentProtectionSet          = \"window.event.content.protection.set\"\n\tEventNameWindowEventDidFinishLoad                 = \"window.event.did.finish.load\"\n\tEventNameWindowEventEnterFullScreen               = \"window.event.enter.full.screen\"\n\tEventNameWindowEventFocus                         = \"window.event.focus\"\n\tEventNameWindowEventHide                          = \"window.event.hide\"\n\tEventNameWindowEventLeaveFullScreen               = \"window.event.leave.full.screen\"\n\tEventNameWindowEventMaximize                      = \"window.event.maximize\"\n\teventNameWindowEventMessage                       = \"window.event.message\"\n\teventNameWindowEventMessageCallback               = \"window.event.message.callback\"\n\tEventNameWindowEventMinimize                      = \"window.event.minimize\"\n\tEventNameWindowEventMove                          = \"window.event.move\"\n\tEventNameWindowEventMoved                         = \"window.event.moved\"\n\tEventNameWindowEventMovedTop                      = \"window.event.moved.top\"\n\tEventNameWindowEventReadyToShow                   = \"window.event.ready.to.show\"\n\tEventNameWindowEventResize                        = \"window.event.resize\"\n\tEventNameWindowEventResizeContent                 = \"window.event.resize.content\"\n\tEventNameWindowEventRestore                       = \"window.event.restore\"\n\tEventNameWindowEventShow                          = \"window.event.show\"\n\tEventNameWindowEventUnmaximize                    = \"window.event.unmaximize\"\n\tEventNameWindowEventUnresponsive                  = \"window.event.unresponsive\"\n\tEventNameWindowEventDidGetRedirectRequest         = \"window.event.did.get.redirect.request\"\n\tEventNameWindowEventWebContentsExecutedJavaScript = \"window.event.web.contents.executed.javascript\"\n\tEventNameWindowEventWillMove                      = \"window.event.will.move\"\n\tEventNameWindowEventWillNavigate                  = \"window.event.will.navigate\"\n\tEventNameWindowEventUpdatedCustomOptions          = \"window.event.updated.custom.options\"\n\tEventNameWindowEventAlwaysOnTopChanged            = \"window.event.always.on.top.changed\"\n)\n\n// Title bar styles\nvar (\n\tTitleBarStyleDefault     = astikit.StrPtr(\"default\")\n\tTitleBarStyleHidden      = astikit.StrPtr(\"hidden\")\n\tTitleBarStyleHiddenInset = astikit.StrPtr(\"hidden-inset\")\n)\n\n// Window represents a window\n// TODO Add missing window options\n// TODO Add missing window methods\n// TODO Add missing window events\ntype Window struct {\n\t*object\n\tcallbackIdentifier *identifier\n\tl                  astikit.SeverityLogger\n\tm                  sync.Mutex // Locks o\n\to                  *WindowOptions\n\tonMessageOnce      sync.Once\n\tSession            *Session\n\turl                *stdUrl.URL\n}\n\n// WindowOptions represents window options\n// We must use pointers since GO doesn't handle optional fields whereas NodeJS does. Use astikit.BoolPtr, astikit.IntPtr or astikit.StrPtr\n// to fill the struct\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/browser-window.md\ntype WindowOptions struct {\n\tAcceptFirstMouse       *bool                 `json:\"acceptFirstMouse,omitempty\"`\n\tAlwaysOnTop            *bool                 `json:\"alwaysOnTop,omitempty\"`\n\tAutoHideMenuBar        *bool                 `json:\"autoHideMenuBar,omitempty\"`\n\tBackgroundColor        *string               `json:\"backgroundColor,omitempty\"`\n\tCenter                 *bool                 `json:\"center,omitempty\"`\n\tClosable               *bool                 `json:\"closable,omitempty\"`\n\tDisableAutoHideCursor  *bool                 `json:\"disableAutoHideCursor,omitempty\"`\n\tEnableLargerThanScreen *bool                 `json:\"enableLargerThanScreen,omitempty\"`\n\tFocusable              *bool                 `json:\"focusable,omitempty\"`\n\tFrame                  *bool                 `json:\"frame,omitempty\"`\n\tFullscreen             *bool                 `json:\"fullscreen,omitempty\"`\n\tFullscreenable         *bool                 `json:\"fullscreenable,omitempty\"`\n\tHasShadow              *bool                 `json:\"hasShadow,omitempty\"`\n\tHeight                 *int                  `json:\"height,omitempty\"`\n\tIcon                   *string               `json:\"icon,omitempty\"`\n\tKiosk                  *bool                 `json:\"kiosk,omitempty\"`\n\tMaxHeight              *int                  `json:\"maxHeight,omitempty\"`\n\tMaximizable            *bool                 `json:\"maximizable,omitempty\"`\n\tMaxWidth               *int                  `json:\"maxWidth,omitempty\"`\n\tMinHeight              *int                  `json:\"minHeight,omitempty\"`\n\tMinimizable            *bool                 `json:\"minimizable,omitempty\"`\n\tMinWidth               *int                  `json:\"minWidth,omitempty\"`\n\tModal                  *bool                 `json:\"modal,omitempty\"`\n\tMovable                *bool                 `json:\"movable,omitempty\"`\n\tResizable              *bool                 `json:\"resizable,omitempty\"`\n\tShow                   *bool                 `json:\"show,omitempty\"`\n\tSkipTaskbar            *bool                 `json:\"skipTaskbar,omitempty\"`\n\tTitle                  *string               `json:\"title,omitempty\"`\n\tTitleBarStyle          *string               `json:\"titleBarStyle,omitempty\"`\n\tTrafficLightPosition   *TrafficLightPosition `json:\"trafficLightPosition,omitempty\"`\n\tTransparent            *bool                 `json:\"transparent,omitempty\"`\n\tUseContentSize         *bool                 `json:\"useContentSize,omitempty\"`\n\tWebPreferences         *WebPreferences       `json:\"webPreferences,omitempty\"`\n\tWidth                  *int                  `json:\"width,omitempty\"`\n\tX                      *int                  `json:\"x,omitempty\"`\n\tY                      *int                  `json:\"y,omitempty\"`\n\n\t// Additional options\n\tAppDetails *WindowAppDetails    `json:\"appDetails,omitempty\"`\n\tCustom     *WindowCustomOptions `json:\"custom,omitempty\"`\n\tLoad       *WindowLoadOptions   `json:\"load,omitempty\"`\n\tProxy      *WindowProxyOptions  `json:\"proxy,omitempty\"`\n}\n\n// WindowAppDetails represents window app details\n// https://github.com/electron/electron/blob/v4.0.1/docs/api/browser-window.md#winsetappdetailsoptions-windows\ntype WindowAppDetails struct {\n\tAppID               *string `json:\"appId,omitempty\"`\n\tAppIconPath         *string `json:\"appIconPath,omitempty\"`\n\tRelaunchCommand     *string `json:\"relaunchCommand,omitempty\"`\n\tAppIconIndex        *int    `json:\"appIconIndex,omitempty\"`\n\tRelaunchDisplayName *string `json:\"relaunchDisplayName,omitempty\"`\n}\n\n// WindowCustomOptions represents window custom options\ntype WindowCustomOptions struct {\n\tHideOnClose       *bool              `json:\"hideOnClose,omitempty\"`\n\tMessageBoxOnClose *MessageBoxOptions `json:\"messageBoxOnClose,omitempty\"`\n\tMinimizeOnClose   *bool              `json:\"minimizeOnClose,omitempty\"`\n\tScript            string             `json:\"script,omitempty\"`\n}\n\n// WindowLoadOptions represents window load options\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/browser-window.md#winloadurlurl-options\ntype WindowLoadOptions struct {\n\tExtraHeaders string `json:\"extraHeaders,omitempty\"`\n\tHTTPReferer  string `json:\"httpReferrer,omitempty\"`\n\tUserAgent    string `json:\"userAgent,omitempty\"`\n}\n\n// WindowProxyOptions represents window proxy options\n// https://github.com/electron/electron/blob/v1.8.1/docs/api/session.md#sessetproxyconfig-callback\ntype WindowProxyOptions struct {\n\tBypassRules string `json:\"proxyBypassRules,omitempty\"`\n\tPACScript   string `json:\"pacScript,omitempty\"`\n\tRules       string `json:\"proxyRules,omitempty\"`\n}\n\n// WebPreferences represents web preferences in window options.\n// We must use pointers since GO doesn't handle optional fields whereas NodeJS does.\n// Use astikit.BoolPtr, astikit.IntPtr or astikit.StrPtr to fill the struct\ntype WebPreferences struct {\n\tAllowRunningInsecureContent *bool   `json:\"allowRunningInsecureContent,omitempty\"`\n\tBackgroundThrottling        *bool   `json:\"backgroundThrottling,omitempty\"`\n\tBlinkFeatures               *string `json:\"blinkFeatures,omitempty\"`\n\t// This attribute needs to be false at all time\n\t// ContextIsolation            *bool                  `json:\"contextIsolation,omitempty\"`\n\tDefaultEncoding            *string                `json:\"defaultEncoding,omitempty\"`\n\tDefaultFontFamily          map[string]interface{} `json:\"defaultFontFamily,omitempty\"`\n\tDefaultFontSize            *int                   `json:\"defaultFontSize,omitempty\"`\n\tDefaultMonospaceFontSize   *int                   `json:\"defaultMonospaceFontSize,omitempty\"`\n\tDevTools                   *bool                  `json:\"devTools,omitempty\"`\n\tDisableBlinkFeatures       *string                `json:\"disableBlinkFeatures,omitempty\"`\n\tEnableRemoteModule         *bool                  `json:\"enableRemoteModule,omitempty\"`\n\tExperimentalCanvasFeatures *bool                  `json:\"experimentalCanvasFeatures,omitempty\"`\n\tExperimentalFeatures       *bool                  `json:\"experimentalFeatures,omitempty\"`\n\tImages                     *bool                  `json:\"images,omitempty\"`\n\tJavascript                 *bool                  `json:\"javascript,omitempty\"`\n\tMinimumFontSize            *int                   `json:\"minimumFontSize,omitempty\"`\n\t// This attribute needs to be true at all time\n\t// NodeIntegration             *bool                  `json:\"nodeIntegration,omitempty\"`\n\tNodeIntegrationInWorker *bool                  `json:\"nodeIntegrationInWorker,omitempty\"`\n\tOffscreen               *bool                  `json:\"offscreen,omitempty\"`\n\tPartition               *string                `json:\"partition,omitempty\"`\n\tPlugins                 *bool                  `json:\"plugins,omitempty\"`\n\tPreload                 *string                `json:\"preload,omitempty\"`\n\tSandbox                 *bool                  `json:\"sandbox,omitempty\"`\n\tScrollBounce            *bool                  `json:\"scrollBounce,omitempty\"`\n\tSession                 map[string]interface{} `json:\"session,omitempty\"`\n\tTextAreasAreResizable   *bool                  `json:\"textAreasAreResizable,omitempty\"`\n\tWebaudio                *bool                  `json:\"webaudio,omitempty\"`\n\tWebgl                   *bool                  `json:\"webgl,omitempty\"`\n\tWebSecurity             *bool                  `json:\"webSecurity,omitempty\"`\n\tWebviewTag              *bool                  `json:\"webviewTag,omitempty\"`\n\tZoomFactor              *float64               `json:\"zoomFactor,omitempty\"`\n}\n\n// TrafficLightPosition represents traffic light positions (macOS only)\n// https://www.electronjs.org/docs/latest/tutorial/window-customization#create-frameless-windows\ntype TrafficLightPosition struct {\n\tX *int `json:\"x,omitempty\"`\n\tY *int `json:\"y,omitempty\"`\n}\n\n// newWindow creates a new window\nfunc newWindow(ctx context.Context, l astikit.SeverityLogger, o Options, p Paths, url string, wo *WindowOptions, d *dispatcher, i *identifier, wrt *writer) (w *Window, err error) {\n\t// Init\n\tw = &Window{\n\t\tcallbackIdentifier: newIdentifier(),\n\t\tl:                  l,\n\t\to:                  wo,\n\t\tobject:             newObject(ctx, d, i, wrt, i.new()),\n\t}\n\tw.Session = newSession(w.ctx, d, i, wrt)\n\n\t// Check app details\n\tif wo.Icon == nil && p.AppIconDefaultSrc() != \"\" {\n\t\two.Icon = astikit.StrPtr(p.AppIconDefaultSrc())\n\t}\n\tif wo.Title == nil && o.AppName != \"\" {\n\t\two.Title = astikit.StrPtr(o.AppName)\n\t}\n\n\t// Make sure the window's context is cancelled once the closed event is received\n\tw.On(EventNameWindowEventClosed, func(e Event) (deleteListener bool) {\n\t\tw.cancel()\n\t\treturn true\n\t})\n\n\t// Fullscreen state\n\tw.On(EventNameWindowEventEnterFullScreen, func(e Event) (deleteListener bool) {\n\t\tw.m.Lock()\n\t\tdefer w.m.Unlock()\n\t\tw.o.Fullscreen = astikit.BoolPtr(true)\n\t\treturn\n\t})\n\tw.On(EventNameWindowEventLeaveFullScreen, func(e Event) (deleteListener bool) {\n\t\tw.m.Lock()\n\t\tdefer w.m.Unlock()\n\t\tw.o.Fullscreen = astikit.BoolPtr(false)\n\t\treturn\n\t})\n\n\t// Show\n\tw.On(EventNameWindowEventHide, func(e Event) (deleteListener bool) {\n\t\tw.m.Lock()\n\t\tdefer w.m.Unlock()\n\t\tw.o.Show = astikit.BoolPtr(false)\n\t\treturn\n\t})\n\tw.On(EventNameWindowEventShow, func(e Event) (deleteListener bool) {\n\t\tw.m.Lock()\n\t\tdefer w.m.Unlock()\n\t\tw.o.Show = astikit.BoolPtr(true)\n\t\treturn\n\t})\n\n\t// Bounds change handling, updates the internal WindowOption's bounds\n\tupdateBoundsFunc := func(w *Window) func(e Event) (deleteListener bool) {\n\t\treturn func(e Event) (deleteListener bool) {\n\t\t\tw.m.Lock()\n\t\t\tdefer w.m.Unlock()\n\t\t\tif w.o != nil && e.Bounds != nil {\n\t\t\t\tw.o.X = e.Bounds.X\n\t\t\t\tw.o.Y = e.Bounds.Y\n\t\t\t\tw.o.Width = e.Bounds.Width\n\t\t\t\tw.o.Height = e.Bounds.Height\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.On(EventNameWindowEventDidFinishLoad, updateBoundsFunc(w))\n\tw.On(EventNameWindowEventMaximize, updateBoundsFunc(w))\n\tw.On(EventNameWindowEventMove, updateBoundsFunc(w))\n\tw.On(EventNameWindowEventMoved, updateBoundsFunc(w))\n\tw.On(EventNameWindowEventResize, updateBoundsFunc(w))\n\tw.On(EventNameWindowEventResizeContent, updateBoundsFunc(w))\n\tw.On(EventNameWindowEventUnmaximize, updateBoundsFunc(w))\n\tw.On(EventNameWindowEventWillMove, updateBoundsFunc(w))\n\n\t// Basic parse\n\tif w.url, err = stdUrl.Parse(url); err != nil {\n\t\terr = fmt.Errorf(\"std parsing of url %s failed: %w\", url, err)\n\t\treturn\n\t}\n\n\t// File\n\tif w.url.Scheme == \"\" {\n\t\t// Get absolute path\n\t\tif url, err = filepath.Abs(url); err != nil {\n\t\t\terr = fmt.Errorf(\"getting absolute path of %s failed: %w\", url, err)\n\t\t\treturn\n\t\t}\n\n\t\t// Set url\n\t\tw.url = &stdUrl.URL{Path: filepath.ToSlash(url), Scheme: \"file\"}\n\t}\n\n\treturn\n}\n\n// NewMenu creates a new window menu\nfunc (w *Window) NewMenu(i []*MenuItemOptions) *Menu {\n\treturn newMenu(w.ctx, w.id, i, w.d, w.i, w.w)\n}\n\n// Blur blurs the window\nfunc (w *Window) Blur() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdBlur, TargetID: w.id}, EventNameWindowEventBlur)\n\treturn\n}\n\n// Bounds return the window bounds\nfunc (w *Window) Bounds() (rect Rectangle, err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tw.m.Lock()\n\tdefer w.m.Unlock()\n\n\tif w.o.Width != nil && w.o.Height != nil {\n\t\trect.Size.Width = *w.o.Width\n\t\trect.Size.Height = *w.o.Height\n\t}\n\n\tif w.o.X != nil && w.o.Y != nil {\n\t\trect.Position.X = *w.o.X\n\t\trect.Position.Y = *w.o.Y\n\t}\n\treturn\n}\n\n// Center centers the window\nfunc (w *Window) Center() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdCenter, TargetID: w.id}, EventNameWindowEventMove)\n\treturn\n}\n\n// Close closes the window\nfunc (w *Window) Close() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdClose, TargetID: w.id}, EventNameWindowEventClosed)\n\treturn\n}\n\n// CloseDevTools closes the dev tools\nfunc (w *Window) CloseDevTools() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\treturn w.w.write(Event{Name: EventNameWindowCmdWebContentsCloseDevTools, TargetID: w.id})\n}\n\n// Create creates the window\n// We wait for EventNameWindowEventDidFinishLoad since we need the web content to be fully loaded before being able to\n// send messages to it\nfunc (w *Window) Create() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdCreate, SessionID: w.Session.id, TargetID: w.id, URL: w.url.String(), WindowOptions: w.o}, EventNameWindowEventDidFinishLoad)\n\treturn\n}\n\n// Destroy destroys the window\nfunc (w *Window) Destroy() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdDestroy, TargetID: w.id}, EventNameWindowEventClosed)\n\treturn\n}\n\n// ExecuteJavaScript executes some js\nfunc (w *Window) ExecuteJavaScript(code string) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdWebContentsExecuteJavaScript, TargetID: w.id, Code: code}, EventNameWindowEventWebContentsExecutedJavaScript)\n\treturn\n}\n\n// Focus focuses on the window\nfunc (w *Window) Focus() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdFocus, TargetID: w.id}, EventNameWindowEventFocus)\n\treturn\n}\n\n// Hide hides the window\nfunc (w *Window) Hide() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdHide, TargetID: w.id}, EventNameWindowEventHide)\n\treturn\n}\n\n// IsFullScreen returns whether the window is in full screen mode\nfunc (w *Window) IsFullScreen() bool {\n\tif w.ctx.Err() != nil {\n\t\treturn false\n\t}\n\tw.m.Lock()\n\tdefer w.m.Unlock()\n\treturn w.o.Fullscreen != nil && *w.o.Fullscreen\n}\n\n// IsShown returns whether the window is shown\nfunc (w *Window) IsShown() bool {\n\tif w.ctx.Err() != nil {\n\t\treturn false\n\t}\n\tw.m.Lock()\n\tdefer w.m.Unlock()\n\treturn w.o.Show != nil && *w.o.Show\n}\n\n// Log logs a message in the JS console of the window\nfunc (w *Window) Log(message string) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\treturn w.w.write(Event{Message: newEventMessage(message), Name: EventNameWindowCmdLog, TargetID: w.id})\n}\n\n// Maximize maximizes the window\nfunc (w *Window) Maximize() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdMaximize, TargetID: w.id}, EventNameWindowEventMaximize)\n\treturn\n}\n\n// Minimize minimizes the window\nfunc (w *Window) Minimize() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdMinimize, TargetID: w.id}, EventNameWindowEventMinimize)\n\treturn\n}\n\n// Move moves the window\nfunc (w *Window) Move(x, y int) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdMove, TargetID: w.id, WindowOptions: &WindowOptions{X: astikit.IntPtr(x), Y: astikit.IntPtr(y)}}, EventNameWindowEventMove)\n\treturn\n}\n\n// MoveTop moves window to top (z-order) regardless of focus\nfunc (w *Window) MoveTop() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdMoveTop, TargetID: w.id}, EventNameWindowEventMovedTop)\n\treturn\n}\n\n// MoveInDisplay moves the window in the proper display\nfunc (w *Window) MoveInDisplay(d *Display, x, y int) error {\n\treturn w.Move(d.Bounds().X+x, d.Bounds().Y+y)\n}\n\nfunc (w *Window) OnLogin(fn func(i Event) (username, password string, err error)) {\n\tw.On(EventNameWebContentsEventLogin, func(i Event) (deleteListener bool) {\n\t\t// Get username and password\n\t\tusername, password, err := fn(i)\n\t\tif err != nil {\n\t\t\tw.l.Error(fmt.Errorf(\"getting username and password failed: %w\", err))\n\t\t\treturn\n\t\t}\n\n\t\t// No auth\n\t\tif len(username) == 0 && len(password) == 0 {\n\t\t\treturn\n\t\t}\n\n\t\t// Send message back\n\t\tif err = w.w.write(Event{CallbackID: i.CallbackID, Name: EventNameWebContentsEventLoginCallback, Password: password, TargetID: w.id, Username: username}); err != nil {\n\t\t\tw.l.Error(fmt.Errorf(\"writing login callback message failed: %w\", err))\n\t\t\treturn\n\t\t}\n\t\treturn\n\t})\n}\n\n// ListenerMessage represents a message listener executed when receiving a message from the JS\ntype ListenerMessage func(m *EventMessage) (v interface{})\n\n// OnMessage adds a specific listener executed when receiving a message from the JS\n// This method can be called only once\nfunc (w *Window) OnMessage(l ListenerMessage) {\n\tw.onMessageOnce.Do(func() {\n\t\tw.On(eventNameWindowEventMessage, func(i Event) (deleteListener bool) {\n\t\t\tv := l(i.Message)\n\t\t\tif len(i.CallbackID) > 0 {\n\t\t\t\to := Event{CallbackID: i.CallbackID, Name: eventNameWindowCmdMessageCallback, TargetID: w.id}\n\t\t\t\tif v != nil {\n\t\t\t\t\to.Message = newEventMessage(v)\n\t\t\t\t}\n\t\t\t\tif err := w.w.write(o); err != nil {\n\t\t\t\t\tw.l.Error(fmt.Errorf(\"writing callback message failed: %w\", err))\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t})\n\t})\n}\n\n// OpenDevTools opens the dev tools\nfunc (w *Window) OpenDevTools() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\treturn w.w.write(Event{Name: EventNameWindowCmdWebContentsOpenDevTools, TargetID: w.id})\n}\n\n// SetAlwaysOnTop sets whether the window should show always on top of other windows.\nfunc (w *Window) SetAlwaysOnTop(flag bool) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tw.m.Lock()\n\tw.o.AlwaysOnTop = astikit.BoolPtr(flag)\n\tw.m.Unlock()\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdSetAlwaysOnTop, TargetID: w.id, Enable: astikit.BoolPtr(flag)}, EventNameWindowEventAlwaysOnTopChanged)\n\treturn\n}\n\n// Resize resizes the window\nfunc (w *Window) Resize(width, height int) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdResize, TargetID: w.id, WindowOptions: &WindowOptions{Height: astikit.IntPtr(height), Width: astikit.IntPtr(width)}}, EventNameWindowEventResize)\n\treturn\n}\n\n// ResizeContent resizes the content viewport\nfunc (w *Window) ResizeContent(width, height int) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdResizeContent, TargetID: w.id, WindowOptions: &WindowOptions{Height: astikit.IntPtr(height), Width: astikit.IntPtr(width)}}, EventNameWindowEventResizeContent)\n\treturn\n}\n\n// SetBounds set bounds of the window\nfunc (w *Window) SetBounds(r RectangleOptions) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdSetBounds, TargetID: w.id, Bounds: &r}, EventNameWindowEventResize)\n\treturn\n}\n\n// Enable content protection on the window\nfunc (w *Window) SetContentProtection(enable bool) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdSetContentProtection, TargetID: w.id, Enable: astikit.BoolPtr(enable)}, EventNameWindowEventContentProtectionSet)\n\treturn\n}\n\n// SetFullScreen sets the fullscreen flag of the window\nfunc (w *Window) SetFullScreen(enable bool) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\n\tvar eventNameDone string\n\tif enable {\n\t\teventNameDone = EventNameWindowEventEnterFullScreen\n\t} else {\n\t\teventNameDone = EventNameWindowEventLeaveFullScreen\n\t}\n\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdSetFullScreen, TargetID: w.id, Enable: astikit.BoolPtr(enable)}, eventNameDone)\n\treturn\n}\n\n// Restore restores the window\nfunc (w *Window) Restore() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdRestore, TargetID: w.id}, EventNameWindowEventRestore)\n\treturn\n}\n\n// CallbackMessage represents a message callback\ntype CallbackMessage func(m *EventMessage)\n\n// SendMessage sends a message to the JS window and execute optional callbacks upon receiving a response from the JS\n// Use astilectron.onMessage method to capture those messages in JS\nfunc (w *Window) SendMessage(message interface{}, callbacks ...CallbackMessage) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tvar e = Event{Message: newEventMessage(message), Name: eventNameWindowCmdMessage, TargetID: w.id}\n\tif len(callbacks) > 0 {\n\t\te.CallbackID = w.callbackIdentifier.new()\n\t\tw.On(eventNameWindowEventMessageCallback, func(i Event) (deleteListener bool) {\n\t\t\tif i.CallbackID == e.CallbackID {\n\t\t\t\tfor _, c := range callbacks {\n\t\t\t\t\tc(i.Message)\n\t\t\t\t}\n\t\t\t\tdeleteListener = true\n\t\t\t}\n\t\t\treturn\n\t\t})\n\t}\n\treturn w.w.write(e)\n}\n\n// Show shows the window\nfunc (w *Window) Show() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdShow, TargetID: w.id}, EventNameWindowEventShow)\n\treturn\n}\n\n// Unmaximize unmaximize the window\nfunc (w *Window) Unmaximize() (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{Name: EventNameWindowCmdUnmaximize, TargetID: w.id}, EventNameWindowEventUnmaximize)\n\treturn\n}\n\n// UpdateCustomOptions updates the window custom options\nfunc (w *Window) UpdateCustomOptions(o WindowCustomOptions) (err error) {\n\tif err = w.ctx.Err(); err != nil {\n\t\treturn\n\t}\n\tw.m.Lock()\n\tw.o.Custom = &o\n\tw.m.Unlock()\n\t_, err = synchronousEvent(w.ctx, w, w.w, Event{WindowOptions: w.o, Name: EventNameWindowCmdUpdateCustomOptions, TargetID: w.id}, EventNameWindowEventUpdatedCustomOptions)\n\treturn\n}\n"
        },
        {
          "name": "window_test.go",
          "type": "blob",
          "size": 11.9912109375,
          "content": "package astilectron\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/asticode/go-astikit\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewWindow(t *testing.T) {\n\t// Init\n\ta, err := New(nil, Options{AppName: \"app name\", AppIconDefaultPath: \"/path/to/default/icon\"})\n\tassert.NoError(t, err)\n\tw, err := a.NewWindow(\"http://test.com\", &WindowOptions{})\n\tassert.NoError(t, err)\n\n\t// Test app name + icon\n\tassert.Equal(t, \"app name\", *w.o.Title)\n\tassert.Equal(t, \"/path/to/default/icon\", *w.o.Icon)\n\n\t// Test in display\n\tw, err = a.NewWindowInDisplay(newDisplay(&DisplayOptions{Bounds: &RectangleOptions{PositionOptions: PositionOptions{X: astikit.IntPtr(1), Y: astikit.IntPtr(2)}, SizeOptions: SizeOptions{Height: astikit.IntPtr(5), Width: astikit.IntPtr(6)}}}, true), \"http://test.com\", &WindowOptions{X: astikit.IntPtr(3), Y: astikit.IntPtr(4)})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 4, *w.o.X)\n\tassert.Equal(t, 6, *w.o.Y)\n\tw, err = a.NewWindowInDisplay(newDisplay(&DisplayOptions{Bounds: &RectangleOptions{PositionOptions: PositionOptions{X: astikit.IntPtr(1), Y: astikit.IntPtr(2)}, SizeOptions: SizeOptions{Height: astikit.IntPtr(5), Width: astikit.IntPtr(6)}}}, true), \"http://test.com\", &WindowOptions{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 1, *w.o.X)\n\tassert.Equal(t, 2, *w.o.Y)\n}\n\nfunc TestWindow_Actions(t *testing.T) {\n\t// Init\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\tdefer a.Close()\n\twrt := &mockedWriter{}\n\ta.writer = newWriter(wrt, &logger{})\n\tw, err := a.NewWindow(\"http://test.com\", &WindowOptions{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, false, w.IsShown())\n\n\t// Actions\n\ttestObjectAction(t, func() error { return w.Blur() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdBlur+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventBlur, nil)\n\ttestObjectAction(t, func() error { return w.Center() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdCenter+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventMove, &Event{Bounds: &RectangleOptions{\n\t\tPositionOptions: PositionOptions{X: astikit.IntPtr(3), Y: astikit.IntPtr(4)},\n\t\tSizeOptions:     SizeOptions{Height: astikit.IntPtr(1), Width: astikit.IntPtr(1)},\n\t}})\n\tbounds, err := w.Bounds()\n\tassert.NoError(t, err)\n\tassert.Equal(t, Rectangle{Position: Position{X: 3, Y: 4}, Size: Size{Height: 1, Width: 1}}, bounds)\n\ttestObjectAction(t, func() error { return w.Close() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdClose+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventClosed, nil)\n\tassert.True(t, w.ctx.Err() != nil)\n\tw, err = a.NewWindow(\"http://test.com\", &WindowOptions{Center: astikit.BoolPtr(true)})\n\tassert.NoError(t, err)\n\ttestObjectAction(t, func() error { return w.CloseDevTools() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdWebContentsCloseDevTools+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", \"\", nil)\n\ttestObjectAction(t, func() error { return w.Create() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdCreate+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"sessionId\\\":\\\"4\\\",\\\"url\\\":\\\"http://test.com\\\",\\\"windowOptions\\\":{\\\"center\\\":true}}\\n\", EventNameWindowEventDidFinishLoad, &Event{Bounds: &RectangleOptions{\n\t\tPositionOptions: PositionOptions{X: astikit.IntPtr(3), Y: astikit.IntPtr(4)},\n\t\tSizeOptions:     SizeOptions{Height: astikit.IntPtr(1), Width: astikit.IntPtr(1)},\n\t}})\n\tbounds, err = w.Bounds()\n\tassert.NoError(t, err)\n\tassert.Equal(t, Rectangle{Position: Position{X: 3, Y: 4}, Size: Size{Height: 1, Width: 1}}, bounds)\n\ttestObjectAction(t, func() error { return w.Destroy() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdDestroy+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventClosed, nil)\n\tassert.True(t, w.ctx.Err() != nil)\n\tw, err = a.NewWindow(\"http://test.com\", &WindowOptions{})\n\tassert.NoError(t, err)\n\ttestObjectAction(t, func() error { return w.Focus() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdFocus+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventFocus, nil)\n\ttestObjectAction(t, func() error { return w.Hide() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdHide+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventHide, nil)\n\tassert.Equal(t, false, w.IsShown())\n\ttestObjectAction(t, func() error { return w.Log(\"message\") }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdLog+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"message\\\":\\\"message\\\"}\\n\", \"\", nil)\n\ttestObjectAction(t, func() error { return w.Maximize() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdMaximize+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventMaximize, &Event{Bounds: &RectangleOptions{\n\t\tPositionOptions: PositionOptions{X: astikit.IntPtr(0), Y: astikit.IntPtr(0)},\n\t\tSizeOptions:     SizeOptions{Height: astikit.IntPtr(100), Width: astikit.IntPtr(200)},\n\t}})\n\tbounds, err = w.Bounds()\n\tassert.NoError(t, err)\n\tassert.Equal(t, Rectangle{Position: Position{X: 0, Y: 0}, Size: Size{Height: 100, Width: 200}}, bounds)\n\ttestObjectAction(t, func() error { return w.Minimize() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdMinimize+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventMinimize, nil)\n\ttestObjectAction(t, func() error { return w.OpenDevTools() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdWebContentsOpenDevTools+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", \"\", nil)\n\ttestObjectAction(t, func() error { return w.Move(3, 4) }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdMove+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"windowOptions\\\":{\\\"x\\\":3,\\\"y\\\":4}}\\n\", EventNameWindowEventMove, &Event{Bounds: &RectangleOptions{\n\t\tPositionOptions: PositionOptions{X: astikit.IntPtr(5), Y: astikit.IntPtr(6)},\n\t\tSizeOptions:     SizeOptions{Height: astikit.IntPtr(2), Width: astikit.IntPtr(2)},\n\t}})\n\tbounds, err = w.Bounds()\n\tassert.NoError(t, err)\n\tassert.Equal(t, Rectangle{Position: Position{X: 5, Y: 6}, Size: Size{Height: 2, Width: 2}}, bounds)\n\tvar d = newDisplay(&DisplayOptions{Bounds: &RectangleOptions{PositionOptions: PositionOptions{X: astikit.IntPtr(1), Y: astikit.IntPtr(2)}, SizeOptions: SizeOptions{Height: astikit.IntPtr(1), Width: astikit.IntPtr(2)}}}, true)\n\ttestObjectAction(t, func() error { return w.MoveInDisplay(d, 3, 4) }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdMove+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"windowOptions\\\":{\\\"x\\\":4,\\\"y\\\":6}}\\n\", EventNameWindowEventMove, &Event{Bounds: &RectangleOptions{\n\t\tPositionOptions: PositionOptions{X: astikit.IntPtr(5), Y: astikit.IntPtr(6)},\n\t\tSizeOptions:     SizeOptions{Height: astikit.IntPtr(2), Width: astikit.IntPtr(2)},\n\t}})\n\tbounds, err = w.Bounds()\n\tassert.NoError(t, err)\n\tassert.Equal(t, Rectangle{Position: Position{X: 5, Y: 6}, Size: Size{Height: 2, Width: 2}}, bounds)\n\ttestObjectAction(t, func() error { return w.Resize(1, 2) }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdResize+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"windowOptions\\\":{\\\"height\\\":2,\\\"width\\\":1}}\\n\", EventNameWindowEventResize, &Event{Bounds: &RectangleOptions{\n\t\tPositionOptions: PositionOptions{X: astikit.IntPtr(5), Y: astikit.IntPtr(6)},\n\t\tSizeOptions:     SizeOptions{Height: astikit.IntPtr(4), Width: astikit.IntPtr(4)},\n\t}})\n\tbounds, err = w.Bounds()\n\tassert.NoError(t, err)\n\tassert.Equal(t, Rectangle{Position: Position{X: 5, Y: 6}, Size: Size{Height: 4, Width: 4}}, bounds)\n\ttestObjectAction(t, func() error { return w.ResizeContent(1, 2) }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdResizeContent+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"windowOptions\\\":{\\\"height\\\":2,\\\"width\\\":1}}\\n\", EventNameWindowEventResizeContent, &Event{Bounds: &RectangleOptions{\n\t\tPositionOptions: PositionOptions{X: astikit.IntPtr(4), Y: astikit.IntPtr(6)},\n\t\tSizeOptions:     SizeOptions{Height: astikit.IntPtr(2), Width: astikit.IntPtr(1)},\n\t}})\n\tbounds, err = w.Bounds()\n\tassert.NoError(t, err)\n\tassert.Equal(t, Rectangle{Position: Position{X: 4, Y: 6}, Size: Size{Height: 2, Width: 1}}, bounds)\n\ttestObjectAction(t, func() error { return w.Restore() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdRestore+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventRestore, nil)\n\ttestObjectAction(t, func() error { return w.SetAlwaysOnTop(true) }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdSetAlwaysOnTop+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"enable\\\":true}\\n\", EventNameWindowEventAlwaysOnTopChanged, nil)\n\ttestObjectAction(t, func() error { return w.Show() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdShow+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventShow, nil)\n\tassert.Equal(t, true, w.IsShown())\n\ttestObjectAction(t, func() error { return w.UpdateCustomOptions(WindowCustomOptions{HideOnClose: astikit.BoolPtr(true)}) }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdUpdateCustomOptions+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"windowOptions\\\":{\\\"alwaysOnTop\\\":true,\\\"height\\\":2,\\\"show\\\":true,\\\"width\\\":1,\\\"x\\\":4,\\\"y\\\":6,\\\"custom\\\":{\\\"hideOnClose\\\":true}}}\\n\", EventNameWindowEventUpdatedCustomOptions, nil)\n\ttestObjectAction(t, func() error { return w.Unmaximize() }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdUnmaximize+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\"}\\n\", EventNameWindowEventUnmaximize, nil)\n\ttestObjectAction(t, func() error { return w.SetFullScreen(true) }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdSetFullScreen+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"enable\\\":true}\\n\", EventNameWindowEventEnterFullScreen, &Event{WindowOptions: &WindowOptions{Fullscreen: astikit.BoolPtr(true)}})\n\tassert.Equal(t, true, w.IsFullScreen())\n\ttestObjectAction(t, func() error { return w.SetFullScreen(false) }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdSetFullScreen+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"enable\\\":false}\\n\", EventNameWindowEventLeaveFullScreen, &Event{WindowOptions: &WindowOptions{Fullscreen: astikit.BoolPtr(false)}})\n\tassert.Equal(t, false, w.IsFullScreen())\n\ttestObjectAction(t, func() error { return w.ExecuteJavaScript(\"console.log('test');\") }, w.object, wrt, \"{\\\"name\\\":\\\"\"+EventNameWindowCmdWebContentsExecuteJavaScript+\"\\\",\\\"targetID\\\":\\\"\"+w.id+\"\\\",\\\"code\\\":\\\"console.log('test');\\\"}\\n\", EventNameWindowEventWebContentsExecutedJavaScript, nil)\n}\n\nfunc TestWindow_OnLogin(t *testing.T) {\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\tdefer a.Close()\n\twrt := &mockedWriter{wg: &sync.WaitGroup{}}\n\ta.writer = newWriter(wrt, &logger{})\n\tw, err := a.NewWindow(\"http://test.com\", &WindowOptions{})\n\tassert.NoError(t, err)\n\tw.OnLogin(func(i Event) (username, password string, err error) {\n\t\treturn \"username\", \"password\", nil\n\t})\n\twrt.wg.Add(1)\n\ta.dispatcher.dispatch(Event{CallbackID: \"1\", Name: EventNameWebContentsEventLogin, TargetID: w.id})\n\twrt.wg.Wait()\n\tassert.Equal(t, []string{\"{\\\"name\\\":\\\"web.contents.event.login.callback\\\",\\\"targetID\\\":\\\"1\\\",\\\"callbackId\\\":\\\"1\\\",\\\"password\\\":\\\"password\\\",\\\"username\\\":\\\"username\\\"}\\n\"}, wrt.w)\n}\n\nfunc TestWindow_OnMessage(t *testing.T) {\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\tdefer a.Close()\n\twrt := &mockedWriter{wg: &sync.WaitGroup{}}\n\ta.writer = newWriter(wrt, &logger{})\n\tw, err := a.NewWindow(\"http://test.com\", &WindowOptions{})\n\tassert.NoError(t, err)\n\tw.OnMessage(func(m *EventMessage) interface{} {\n\t\treturn \"test\"\n\t})\n\twrt.wg.Add(1)\n\ta.dispatcher.dispatch(Event{CallbackID: \"1\", Name: eventNameWindowEventMessage, TargetID: w.id})\n\twrt.wg.Wait()\n\tassert.Equal(t, []string{\"{\\\"name\\\":\\\"window.cmd.message.callback\\\",\\\"targetID\\\":\\\"1\\\",\\\"callbackId\\\":\\\"1\\\",\\\"message\\\":\\\"test\\\"}\\n\"}, wrt.w)\n}\n\nfunc TestWindow_SendMessage(t *testing.T) {\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\tdefer a.Close()\n\twrt := &mockedWriter{}\n\ta.writer = newWriter(wrt, &logger{})\n\tw, err := a.NewWindow(\"http://test.com\", &WindowOptions{})\n\tassert.NoError(t, err)\n\twrt.fn = func() {\n\t\ta.dispatcher.dispatch(Event{CallbackID: \"1\", Message: newEventMessage([]byte(\"\\\"bar\\\"\")), Name: eventNameWindowEventMessageCallback, TargetID: w.id})\n\t\twrt.fn = nil\n\t}\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tvar s string\n\tw.SendMessage(\"foo\", func(m *EventMessage) {\n\t\tm.Unmarshal(&s)\n\t\twg.Done()\n\t})\n\twg.Wait()\n\tassert.Equal(t, []string{\"{\\\"name\\\":\\\"window.cmd.message\\\",\\\"targetID\\\":\\\"1\\\",\\\"callbackId\\\":\\\"1\\\",\\\"message\\\":\\\"foo\\\"}\\n\"}, wrt.w)\n\tassert.Equal(t, \"bar\", s)\n}\n\nfunc TestWindow_NewMenu(t *testing.T) {\n\ta, err := New(nil, Options{})\n\tassert.NoError(t, err)\n\tw, err := a.NewWindow(\"http://test.com\", &WindowOptions{})\n\tassert.NoError(t, err)\n\tm := w.NewMenu([]*MenuItemOptions{})\n\tassert.Equal(t, w.id, m.rootID)\n}\n"
        },
        {
          "name": "writer.go",
          "type": "blob",
          "size": 0.828125,
          "content": "package astilectron\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/asticode/go-astikit\"\n)\n\n// writer represents an object capable of writing in the TCP server\ntype writer struct {\n\tl astikit.SeverityLogger\n\tw io.WriteCloser\n}\n\n// newWriter creates a new writer\nfunc newWriter(w io.WriteCloser, l astikit.SeverityLogger) *writer {\n\treturn &writer{\n\t\tl: l,\n\t\tw: w,\n\t}\n}\n\n// close closes the writer properly\nfunc (w *writer) close() error {\n\treturn w.w.Close()\n}\n\n// write writes to the stdin\nfunc (w *writer) write(e Event) (err error) {\n\t// Marshal\n\tvar b []byte\n\tif b, err = json.Marshal(e); err != nil {\n\t\treturn fmt.Errorf(\"marshaling %+v failed: %w\", e, err)\n\t}\n\n\t// Write\n\tw.l.Debugf(\"Sending to Astilectron: %s\", b)\n\tif _, err = w.w.Write(append(b, '\\n')); err != nil {\n\t\treturn fmt.Errorf(\"writing %s failed: %w\", b, err)\n\t}\n\treturn\n}\n"
        },
        {
          "name": "writer_test.go",
          "type": "blob",
          "size": 0.9150390625,
          "content": "package astilectron\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// mockedWriter represents a mocked writer\ntype mockedWriter struct {\n\tc  bool\n\tfn func()\n\tw  []string\n\twg *sync.WaitGroup\n}\n\n// Close implements the io.Closer interface\nfunc (w *mockedWriter) Close() error {\n\tw.c = true\n\treturn nil\n}\n\n// Write implements io.Writer interface\nfunc (w *mockedWriter) Write(p []byte) (int, error) {\n\tw.w = append(w.w, string(p))\n\tif w.fn != nil {\n\t\tw.fn()\n\t}\n\tif w.wg != nil {\n\t\tw.wg.Done()\n\t}\n\treturn len(p), nil\n}\n\n// TestWriter tests the writer\nfunc TestWriter(t *testing.T) {\n\t// Init\n\tvar mw = &mockedWriter{}\n\tvar w = newWriter(mw, &logger{})\n\n\t// Test write\n\terr := w.write(Event{Name: \"test\", TargetID: \"target_id\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"{\\\"name\\\":\\\"test\\\",\\\"targetID\\\":\\\"target_id\\\"}\\n\"}, mw.w)\n\n\t// Test close\n\terr = w.close()\n\tassert.NoError(t, err)\n\tassert.True(t, mw.c)\n}\n"
        }
      ]
    }
  ]
}