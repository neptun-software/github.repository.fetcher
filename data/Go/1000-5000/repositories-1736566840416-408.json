{
  "metadata": {
    "timestamp": 1736566840416,
    "page": 408,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "getlantern/systray",
      "stars": 3376,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1328125,
          "content": "example/example\nwebview_example/webview_example\n*~\n*.swp\n**/*.exe\nRelease\nDebug\n*.sdf\ndll/systray_unsigned.dll\nout.txt\n.vs\non_exit*.txt\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 9.8310546875,
          "content": "# Changelog\n\n## [v1.2.0](https://github.com/getlantern/systray/tree/v1.2.0) (2022-02-24)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/v1.1.0...v1.2.0)\n\n** Merged pull requests:**\n\n- On Linux, set the title in addition to the label [\\#200](https://github.com/getlantern/systray/pull/200) ([cocotyty](https://github.com/cocotyty))\n- Fix hiding/showing items with submenus on Windows [\\#204](https://github.com/getlantern/systray/pull/204) ([simonlindholm](https://github.com/simonlindholm))\n- Fix delFromVisibleItems [\\#205](https://github.com/getlantern/systray/pull/205) ([simonlindholm](https://github.com/simonlindholm))\n- Create menu before calling onReady on Windows [\\#206](https://github.com/getlantern/systray/pull/206) ([simonlindholm](https://github.com/simonlindholm))\n- Support libayatana-appindicator on Linux [\\#225](https://github.com/getlantern/systray/pull/225) ([Crosse](https://github.com/Crosse))\n\n## [v1.1.0](https://github.com/getlantern/systray/tree/v1.1.0) (2020-11-18)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/v1.0.5...v1.1.0)\n\n**Merged pull requests:**\n\n- Add submenu support for Linux [\\#183](https://github.com/getlantern/systray/pull/183) ([fbrinker](https://github.com/fbrinker))\n- Add checkbox support for Linux [\\#181](https://github.com/getlantern/systray/pull/181) ([fbrinker](https://github.com/fbrinker))\n- fix SetTitle documentation [\\#179](https://github.com/getlantern/systray/pull/179) ([delthas](https://github.com/delthas))\n\n## [v1.0.5](https://github.com/getlantern/systray/tree/v1.0.5) (2020-10-19)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/v1.0.4...v1.0.5)\n\n**Merged pull requests:**\n\n- start menu ID with positive, and change the type to uint32 [\\#173](https://github.com/getlantern/systray/pull/173) ([joesis](https://github.com/joesis))\n- Allows disabling items in submenu on macOS [\\#172](https://github.com/getlantern/systray/pull/172) ([joesis](https://github.com/joesis))\n- Does not use the template icon for regular icons [\\#171](https://github.com/getlantern/systray/pull/171) ([sithembiso](https://github.com/sithembiso))\n\n## [v1.0.4](https://github.com/getlantern/systray/tree/v1.0.4) (2020-07-21)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/1.0.3...v1.0.4)\n\n**Merged pull requests:**\n\n- protect shared data structures with proper mutexes [\\#162](https://github.com/getlantern/systray/pull/162) ([joesis](https://github.com/joesis))\n\n## [1.0.3](https://github.com/getlantern/systray/tree/1.0.3) (2020-06-11)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/v1.0.3...1.0.3)\n\n## [v1.0.3](https://github.com/getlantern/systray/tree/v1.0.3) (2020-06-11)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/v1.0.2...v1.0.3)\n\n**Merged pull requests:**\n\n- have a workaround to avoid crash on old macOS versions [\\#153](https://github.com/getlantern/systray/pull/153) ([joesis](https://github.com/joesis))\n- Fix bug on darwin of setting icon for menu [\\#147](https://github.com/getlantern/systray/pull/147) ([mangalaman93](https://github.com/mangalaman93))\n\n## [v1.0.2](https://github.com/getlantern/systray/tree/v1.0.2) (2020-05-19)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/v1.0.1...v1.0.2)\n\n**Merged pull requests:**\n\n- remove unused dependencies [\\#145](https://github.com/getlantern/systray/pull/145) ([joesis](https://github.com/joesis))\n\n## [v1.0.1](https://github.com/getlantern/systray/tree/v1.0.1) (2020-05-18)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/1.0.1...v1.0.1)\n\n## [1.0.1](https://github.com/getlantern/systray/tree/1.0.1) (2020-05-18)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/1.0.0...1.0.1)\n\n**Merged pull requests:**\n\n- Unlock menuItemsLock before changing UI [\\#144](https://github.com/getlantern/systray/pull/144) ([joesis](https://github.com/joesis))\n\n## [1.0.0](https://github.com/getlantern/systray/tree/1.0.0) (2020-05-18)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/v1.0.0...1.0.0)\n\n## [v1.0.0](https://github.com/getlantern/systray/tree/v1.0.0) (2020-05-18)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/0.9.0...v1.0.0)\n\n**Merged pull requests:**\n\n- Check if the menu item is nil [\\#137](https://github.com/getlantern/systray/pull/137) ([myleshorton](https://github.com/myleshorton))\n\n## [0.9.0](https://github.com/getlantern/systray/tree/0.9.0) (2020-03-24)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/v0.9.0...0.9.0)\n\n## [v0.9.0](https://github.com/getlantern/systray/tree/v0.9.0) (2020-03-24)\n\n[Full Changelog](https://github.com/getlantern/systray/compare/8e63b37ef27d94f6db79c4ffb941608e8f0dc2f9...v0.9.0)\n\n**Merged pull requests:**\n\n- Backport all features and fixes from master [\\#140](https://github.com/getlantern/systray/pull/140) ([joesis](https://github.com/joesis))\n- Nested menu windows [\\#132](https://github.com/getlantern/systray/pull/132) ([joesis](https://github.com/joesis))\n- Support for nested sub-menus on OS X [\\#131](https://github.com/getlantern/systray/pull/131) ([oxtoacart](https://github.com/oxtoacart))\n- Use temp directory for walk resource manager [\\#129](https://github.com/getlantern/systray/pull/129) ([max-b](https://github.com/max-b))\n- Added support for template icons on macOS [\\#119](https://github.com/getlantern/systray/pull/119) ([oxtoacart](https://github.com/oxtoacart))\n- When launching app window on macOS, make application a foreground app… [\\#118](https://github.com/getlantern/systray/pull/118) ([oxtoacart](https://github.com/oxtoacart))\n- Include stdlib.h in systray\\_browser\\_linux to explicitly declare funct… [\\#114](https://github.com/getlantern/systray/pull/114) ([oxtoacart](https://github.com/oxtoacart))\n- Fix panic when resources root path is not the working directory [\\#112](https://github.com/getlantern/systray/pull/112) ([ksubileau](https://github.com/ksubileau))\n- Don't print close reason to console [\\#111](https://github.com/getlantern/systray/pull/111) ([ksubileau](https://github.com/ksubileau))\n- Systray icon could not be changed dynamically [\\#110](https://github.com/getlantern/systray/pull/110) ([ksubileau](https://github.com/ksubileau))\n- Preventing deadlock on menu item ClickeCh when no one is listening, c… [\\#105](https://github.com/getlantern/systray/pull/105) ([oxtoacart](https://github.com/oxtoacart))\n- Reverted deadlock fix \\(Affected other receivers\\) [\\#104](https://github.com/getlantern/systray/pull/104) ([ldstein](https://github.com/ldstein))\n- Fix Deadlock and item ordering in Windows [\\#103](https://github.com/getlantern/systray/pull/103) ([ldstein](https://github.com/ldstein))\n- Minor README improvements \\(go modules, example app, screenshot\\) [\\#98](https://github.com/getlantern/systray/pull/98) ([tstromberg](https://github.com/tstromberg))\n- Add support for app window [\\#97](https://github.com/getlantern/systray/pull/97) ([oxtoacart](https://github.com/oxtoacart))\n- systray\\_darwin.m: Compare Mac OS min version with value instead of macro [\\#94](https://github.com/getlantern/systray/pull/94) ([teddywing](https://github.com/teddywing))\n- Attempt to fix https://github.com/getlantern/systray/issues/75 [\\#92](https://github.com/getlantern/systray/pull/92) ([mikeschinkel](https://github.com/mikeschinkel))\n- Fix application path for MacOS in README [\\#91](https://github.com/getlantern/systray/pull/91) ([zereraz](https://github.com/zereraz))\n- Document cross-platform console window details [\\#81](https://github.com/getlantern/systray/pull/81) ([michaelsanford](https://github.com/michaelsanford))\n- Fix bad-looking system tray icon in Windows [\\#78](https://github.com/getlantern/systray/pull/78) ([juja256](https://github.com/juja256))\n- Add the separator to the visible items [\\#76](https://github.com/getlantern/systray/pull/76) ([meskio](https://github.com/meskio))\n- keep track of hidden items [\\#74](https://github.com/getlantern/systray/pull/74) ([kalikaneko](https://github.com/kalikaneko))\n- Support macOS older than 10.13 [\\#73](https://github.com/getlantern/systray/pull/73) ([swznd](https://github.com/swznd))\n- define ERROR\\_SUCCESS as syscall.Errno [\\#69](https://github.com/getlantern/systray/pull/69) ([joesis](https://github.com/joesis))\n- Bug/fix broken menuitem show [\\#68](https://github.com/getlantern/systray/pull/68) ([kalikaneko](https://github.com/kalikaneko))\n- Fix mac deprecations [\\#66](https://github.com/getlantern/systray/pull/66) ([jefvel](https://github.com/jefvel))\n- Made it possible to add icons to menu items on Mac [\\#65](https://github.com/getlantern/systray/pull/65) ([jefvel](https://github.com/jefvel))\n- linux: delete temp files as soon as they are not needed [\\#63](https://github.com/getlantern/systray/pull/63) ([meskio](https://github.com/meskio))\n- Merge changes from amkulikov to remove DLL for windows [\\#56](https://github.com/getlantern/systray/pull/56) ([oxtoacart](https://github.com/oxtoacart))\n- Revert \"Use templated icons for the menu bar in macOS\" [\\#51](https://github.com/getlantern/systray/pull/51) ([stoggi](https://github.com/stoggi))\n- Use templated icons for the menu bar in macOS [\\#46](https://github.com/getlantern/systray/pull/46) ([stoggi](https://github.com/stoggi))\n- Syscalls instead of custom DLLs [\\#44](https://github.com/getlantern/systray/pull/44) ([amkulikov](https://github.com/amkulikov))\n- On quit exit main loop on linux [\\#41](https://github.com/getlantern/systray/pull/41) ([meskio](https://github.com/meskio))\n- Fixed hide show in linux \\(\\#37\\) [\\#39](https://github.com/getlantern/systray/pull/39) ([meskio](https://github.com/meskio))\n- fix: linux compilation warning [\\#36](https://github.com/getlantern/systray/pull/36) ([novln](https://github.com/novln))\n- Added separator functionality [\\#32](https://github.com/getlantern/systray/pull/32) ([oxtoacart](https://github.com/oxtoacart))\n\n\n\n\\* *This Changelog was automatically generated by [github_changelog_generator](https://github.com/github-changelog-generator/github-changelog-generator)*\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0966796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2014 Brave New Software Project, Inc.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.5908203125,
          "content": "tag-changelog: require-version require-gh-token\n\techo \"Tagging...\" && \\\n\tgit tag -a \"$$VERSION\" -f --annotate -m\"Tagged $$VERSION\" && \\\n\tgit push --tags -f && \\\n\tgit checkout master && \\\n\tgit pull && \\\n\tgithub_changelog_generator --no-issues --max-issues 100 --token \"${GH_TOKEN}\" --user getlantern --project systray && \\\n\tgit add CHANGELOG.md && \\\n\tgit commit -m \"Updated changelog for $$VERSION\" && \\\n\tgit push origin HEAD && \\\n\tgit checkout -\n\nguard-%:\n\t @ if [ -z '${${*}}' ]; then echo 'Environment variable $* not set' && exit 1; fi\n\nrequire-version: guard-VERSION\n\nrequire-gh-token: guard-GH_TOKEN\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.419921875,
          "content": "# systray\n\nsystray is a cross-platform Go library to place an icon and menu in the notification area.\n\n## Features\n\n* Supported on Windows, macOS, and Linux\n* Menu items can be checked and/or disabled\n* Most functions may be called from any goroutine\n\n## API\n\n```go\nfunc main() {\n\tsystray.Run(onReady, onExit)\n}\n\nfunc onReady() {\n\tsystray.SetIcon(icon.Data)\n\tsystray.SetTitle(\"Awesome App\")\n\tsystray.SetTooltip(\"Pretty awesome超级棒\")\n\tmQuit := systray.AddMenuItem(\"Quit\", \"Quit the whole app\")\n\n\t// Sets the icon of a menu item. Only available on Mac and Windows.\n\tmQuit.SetIcon(icon.Data)\n}\n\nfunc onExit() {\n\t// clean up here\n}\n```\n\nSee [![full API](https://pkg.go.dev/badge/github.com/getlantern/systray.svg)](https://pkg.go.dev/github.com/getlantern/systray) as well as [CHANGELOG](https://github.com/getlantern/systray/tree/master/CHANGELOG.md).\n\nNote: this package requires cgo, so make sure you set `CGO_ENABLED=1` before building.\n\n## Try the example app!\n\nHave go v1.12+ or higher installed? Here's an example to get started on macOS:\n\n```sh\ngit clone https://github.com/getlantern/systray\ncd systray/example\nenv GO111MODULE=on go build\n./example\n```\n\nOn Windows, you should build like this:\n\n```\nenv GO111MODULE=on go build -ldflags \"-H=windowsgui\"\n```\n\nNow look for *Awesome App* in your menu bar!\n\n![Awesome App screenshot](example/screenshot.png)\n\n## The Webview example\n\nThe code under `webview_example` is to demostrate how it can co-exist with other UI elements. Note that the example doesn't work on macOS versions older than 10.15 Catalina.\n\n## Platform notes\n\n### Linux\n\n* Building apps requires gcc as well as the `gtk3` and `libayatana-appindicator3` development headers to be installed. For Debian or Ubuntu, you may install these using:\n\n```sh\nsudo apt-get install gcc libgtk-3-dev libayatana-appindicator3-dev\n```\n\nOn Linux Mint, `libxapp-dev` is also required.\n\nIf you need to support the older `libappindicator3` library instead, you can pass the build flag `legacy_appindicator`\nwhen building. For example:\n\n```\ngo build -tags=legacy_appindicator\n```\n\nTo build `webview_example`, you also need to install `libwebkit2gtk-4.0-dev` and remove `webview_example/rsrc.syso` which is required on Windows.\n\n### Windows\n\n* To avoid opening a console at application startup, use these compile flags:\n\n```sh\ngo build -ldflags -H=windowsgui\n```\n\n### macOS\n\nOn macOS, you will need to create an application bundle to wrap the binary; simply folders with the following minimal structure and assets:\n\n```\nSystrayApp.app/\n  Contents/\n    Info.plist\n    MacOS/\n      go-executable\n    Resources/\n      SystrayApp.icns\n```\n\nWhen running as an app bundle, you may want to add one or both of the following to your Info.plist:\n\n```xml\n<!-- avoid having a blurry icon and text -->\n\t<key>NSHighResolutionCapable</key>\n\t<string>True</string>\n\n\t<!-- avoid showing the app on the Dock -->\n\t<key>LSUIElement</key>\n\t<string>1</string>\n```\n\nConsult the [Official Apple Documentation here](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html#//apple_ref/doc/uid/10000123i-CH101-SW1).\n\nOn macOS, it's possible to set the underlying\n[`NSStatusItemBehavior`](https://developer.apple.com/documentation/appkit/nsstatusitembehavior?language=objc)\nwith `systray.SetRemovalAllowed(true)`. When enabled, the user can cmd-drag the\nicon off the menu bar.\n\n## Credits\n\n- https://github.com/xilp/systray\n- https://github.com/cratonica/trayhost\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.380859375,
          "content": "module github.com/getlantern/systray\n\ngo 1.13\n\nrequire (\n\tgithub.com/getlantern/golog v0.0.0-20190830074920-4ef2e798c2d7\n\tgithub.com/lxn/walk v0.0.0-20210112085537-c389da54e794\n\tgithub.com/lxn/win v0.0.0-20210218163916-a377121e959e // indirect\n\tgithub.com/skratchdot/open-golang v0.0.0-20200116055534-eef842397966\n\tgolang.org/x/sys v0.1.0\n\tgopkg.in/Knetic/govaluate.v3 v3.0.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.39453125,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/getlantern/context v0.0.0-20190109183933-c447772a6520 h1:NRUJuo3v3WGC/g5YiyF790gut6oQr5f3FBI88Wv0dx4=\ngithub.com/getlantern/context v0.0.0-20190109183933-c447772a6520/go.mod h1:L+mq6/vvYHKjCX2oez0CgEAJmbq1fbb/oNJIWQkBybY=\ngithub.com/getlantern/errors v0.0.0-20190325191628-abdb3e3e36f7 h1:6uJ+sZ/e03gkbqZ0kUG6mfKoqDb4XMAzMIwlajq19So=\ngithub.com/getlantern/errors v0.0.0-20190325191628-abdb3e3e36f7/go.mod h1:l+xpFBrCtDLpK9qNjxs+cHU6+BAdlBaxHqikB6Lku3A=\ngithub.com/getlantern/golog v0.0.0-20190830074920-4ef2e798c2d7 h1:guBYzEaLz0Vfc/jv0czrr2z7qyzTOGC9hiQ0VC+hKjk=\ngithub.com/getlantern/golog v0.0.0-20190830074920-4ef2e798c2d7/go.mod h1:zx/1xUUeYPy3Pcmet8OSXLbF47l+3y6hIPpyLWoR9oc=\ngithub.com/getlantern/hex v0.0.0-20190417191902-c6586a6fe0b7 h1:micT5vkcr9tOVk1FiH8SWKID8ultN44Z+yzd2y/Vyb0=\ngithub.com/getlantern/hex v0.0.0-20190417191902-c6586a6fe0b7/go.mod h1:dD3CgOrwlzca8ed61CsZouQS5h5jIzkK9ZWrTcf0s+o=\ngithub.com/getlantern/hidden v0.0.0-20190325191715-f02dbb02be55 h1:XYzSdCbkzOC0FDNrgJqGRo8PCMFOBFL9py72DRs7bmc=\ngithub.com/getlantern/hidden v0.0.0-20190325191715-f02dbb02be55/go.mod h1:6mmzY2kW1TOOrVy+r41Za2MxXM+hhqTtY3oBKd2AgFA=\ngithub.com/getlantern/ops v0.0.0-20190325191751-d70cb0d6f85f h1:wrYrQttPS8FHIRSlsrcuKazukx/xqO/PpLZzZXsF+EA=\ngithub.com/getlantern/ops v0.0.0-20190325191751-d70cb0d6f85f/go.mod h1:D5ao98qkA6pxftxoqzibIBBrLSUli+kYnJqrgBf9cIA=\ngithub.com/go-stack/stack v1.8.0 h1:5SgMzNM5HxrEjV0ww2lTmX6E2Izsfxas4+YHWRs3Lsk=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/lxn/walk v0.0.0-20210112085537-c389da54e794 h1:NVRJ0Uy0SOFcXSKLsS65OmI1sgCCfiDUPj+cwnH7GZw=\ngithub.com/lxn/walk v0.0.0-20210112085537-c389da54e794/go.mod h1:E23UucZGqpuUANJooIbHWCufXvOcT6E7Stq81gU+CSQ=\ngithub.com/lxn/win v0.0.0-20210218163916-a377121e959e h1:H+t6A/QJMbhCSEH5rAuRxh+CtW96g0Or0Fxa9IKr4uc=\ngithub.com/lxn/win v0.0.0-20210218163916-a377121e959e/go.mod h1:KxxjdtRkfNoYDCUP5ryK7XJJNTnpC8atvtmTheChOtk=\ngithub.com/oxtoacart/bpool v0.0.0-20190530202638-03653db5a59c h1:rp5dCmg/yLR3mgFuSOe4oEnDDmGLROTvMragMUXpTQw=\ngithub.com/oxtoacart/bpool v0.0.0-20190530202638-03653db5a59c/go.mod h1:X07ZCGwUbLaax7L0S3Tw4hpejzu63ZrrQiUe6W0hcy0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/skratchdot/open-golang v0.0.0-20200116055534-eef842397966 h1:JIAuq3EEf9cgbU6AtGPK4CTG3Zf6CKMNqf0MHTggAUA=\ngithub.com/skratchdot/open-golang v0.0.0-20200116055534-eef842397966/go.mod h1:sUM3LWHvSMaG192sy56D9F7CNvL7jUJVXoqM1QKLnog=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngolang.org/x/sys v0.0.0-20201018230417-eeed37f84f13/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.1.0 h1:kunALQeHf1/185U1i0GOB/fy1IPRDDpuoOOqRReG57U=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngopkg.in/Knetic/govaluate.v3 v3.0.0 h1:18mUyIt4ZlRlFZAAfVetz4/rzlJs9yhN+U02F4u1AOc=\ngopkg.in/Knetic/govaluate.v3 v3.0.0/go.mod h1:csKLBORsPbafmSCGTEh3U7Ozmsuq8ZSIlKk1bcqph0E=\n"
        },
        {
          "name": "systray.go",
          "type": "blob",
          "size": 6.3447265625,
          "content": "/*\nPackage systray is a cross-platform Go library to place an icon and menu in the notification area.\n*/\npackage systray\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/getlantern/golog\"\n)\n\nvar (\n\tlog = golog.LoggerFor(\"systray\")\n\n\tsystrayReady  func()\n\tsystrayExit   func()\n\tmenuItems     = make(map[uint32]*MenuItem)\n\tmenuItemsLock sync.RWMutex\n\n\tcurrentID = uint32(0)\n\tquitOnce  sync.Once\n)\n\nfunc init() {\n\truntime.LockOSThread()\n}\n\n// MenuItem is used to keep track each menu item of systray.\n// Don't create it directly, use the one systray.AddMenuItem() returned\ntype MenuItem struct {\n\t// ClickedCh is the channel which will be notified when the menu item is clicked\n\tClickedCh chan struct{}\n\n\t// id uniquely identify a menu item, not supposed to be modified\n\tid uint32\n\t// title is the text shown on menu item\n\ttitle string\n\t// tooltip is the text shown when pointing to menu item\n\ttooltip string\n\t// disabled menu item is grayed out and has no effect when clicked\n\tdisabled bool\n\t// checked menu item has a tick before the title\n\tchecked bool\n\t// has the menu item a checkbox (Linux)\n\tisCheckable bool\n\t// parent item, for sub menus\n\tparent *MenuItem\n}\n\nfunc (item *MenuItem) String() string {\n\tif item.parent == nil {\n\t\treturn fmt.Sprintf(\"MenuItem[%d, %q]\", item.id, item.title)\n\t}\n\treturn fmt.Sprintf(\"MenuItem[%d, parent %d, %q]\", item.id, item.parent.id, item.title)\n}\n\n// newMenuItem returns a populated MenuItem object\nfunc newMenuItem(title string, tooltip string, parent *MenuItem) *MenuItem {\n\treturn &MenuItem{\n\t\tClickedCh:   make(chan struct{}),\n\t\tid:          atomic.AddUint32(&currentID, 1),\n\t\ttitle:       title,\n\t\ttooltip:     tooltip,\n\t\tdisabled:    false,\n\t\tchecked:     false,\n\t\tisCheckable: false,\n\t\tparent:      parent,\n\t}\n}\n\n// Run initializes GUI and starts the event loop, then invokes the onReady callback. It blocks until\n// systray.Quit() is called. It must be run from the main thread on macOS.\nfunc Run(onReady func(), onExit func()) {\n\tRegister(onReady, onExit)\n\tnativeLoop()\n}\n\n// Register initializes GUI and registers the callbacks but relies on the\n// caller to run the event loop somewhere else. It's useful if the program\n// needs to show other UI elements, for example, webview.\n// To overcome some OS weirdness, On macOS versions before Catalina, calling\n// this does exactly the same as Run().\nfunc Register(onReady func(), onExit func()) {\n\tif onReady == nil {\n\t\tsystrayReady = func() {}\n\t} else {\n\t\t// Run onReady on separate goroutine to avoid blocking event loop\n\t\treadyCh := make(chan interface{})\n\t\tgo func() {\n\t\t\t<-readyCh\n\t\t\tonReady()\n\t\t}()\n\t\tsystrayReady = func() {\n\t\t\tclose(readyCh)\n\t\t}\n\t}\n\t// unlike onReady, onExit runs in the event loop to make sure it has time to\n\t// finish before the process terminates\n\tif onExit == nil {\n\t\tonExit = func() {}\n\t}\n\tsystrayExit = onExit\n\tregisterSystray()\n}\n\n// Quit the systray. This can be called from any goroutine.\nfunc Quit() {\n\tquitOnce.Do(quit)\n}\n\n// AddMenuItem adds a menu item with the designated title and tooltip.\n// It can be safely invoked from different goroutines.\n// Created menu items are checkable on Windows and OSX by default. For Linux you have to use AddMenuItemCheckbox\nfunc AddMenuItem(title string, tooltip string) *MenuItem {\n\titem := newMenuItem(title, tooltip, nil)\n\titem.update()\n\treturn item\n}\n\n// AddMenuItemCheckbox adds a menu item with the designated title and tooltip and a checkbox for Linux.\n// It can be safely invoked from different goroutines.\n// On Windows and OSX this is the same as calling AddMenuItem\nfunc AddMenuItemCheckbox(title string, tooltip string, checked bool) *MenuItem {\n\titem := newMenuItem(title, tooltip, nil)\n\titem.isCheckable = true\n\titem.checked = checked\n\titem.update()\n\treturn item\n}\n\n// AddSeparator adds a separator bar to the menu\nfunc AddSeparator() {\n\taddSeparator(atomic.AddUint32(&currentID, 1))\n}\n\n// AddSubMenuItem adds a nested sub-menu item with the designated title and tooltip.\n// It can be safely invoked from different goroutines.\n// Created menu items are checkable on Windows and OSX by default. For Linux you have to use AddSubMenuItemCheckbox\nfunc (item *MenuItem) AddSubMenuItem(title string, tooltip string) *MenuItem {\n\tchild := newMenuItem(title, tooltip, item)\n\tchild.update()\n\treturn child\n}\n\n// AddSubMenuItemCheckbox adds a nested sub-menu item with the designated title and tooltip and a checkbox for Linux.\n// It can be safely invoked from different goroutines.\n// On Windows and OSX this is the same as calling AddSubMenuItem\nfunc (item *MenuItem) AddSubMenuItemCheckbox(title string, tooltip string, checked bool) *MenuItem {\n\tchild := newMenuItem(title, tooltip, item)\n\tchild.isCheckable = true\n\tchild.checked = checked\n\tchild.update()\n\treturn child\n}\n\n// SetTitle set the text to display on a menu item\nfunc (item *MenuItem) SetTitle(title string) {\n\titem.title = title\n\titem.update()\n}\n\n// SetTooltip set the tooltip to show when mouse hover\nfunc (item *MenuItem) SetTooltip(tooltip string) {\n\titem.tooltip = tooltip\n\titem.update()\n}\n\n// Disabled checks if the menu item is disabled\nfunc (item *MenuItem) Disabled() bool {\n\treturn item.disabled\n}\n\n// Enable a menu item regardless if it's previously enabled or not\nfunc (item *MenuItem) Enable() {\n\titem.disabled = false\n\titem.update()\n}\n\n// Disable a menu item regardless if it's previously disabled or not\nfunc (item *MenuItem) Disable() {\n\titem.disabled = true\n\titem.update()\n}\n\n// Hide hides a menu item\nfunc (item *MenuItem) Hide() {\n\thideMenuItem(item)\n}\n\n// Show shows a previously hidden menu item\nfunc (item *MenuItem) Show() {\n\tshowMenuItem(item)\n}\n\n// Checked returns if the menu item has a check mark\nfunc (item *MenuItem) Checked() bool {\n\treturn item.checked\n}\n\n// Check a menu item regardless if it's previously checked or not\nfunc (item *MenuItem) Check() {\n\titem.checked = true\n\titem.update()\n}\n\n// Uncheck a menu item regardless if it's previously unchecked or not\nfunc (item *MenuItem) Uncheck() {\n\titem.checked = false\n\titem.update()\n}\n\n// update propagates changes on a menu item to systray\nfunc (item *MenuItem) update() {\n\tmenuItemsLock.Lock()\n\tmenuItems[item.id] = item\n\tmenuItemsLock.Unlock()\n\taddOrUpdateMenuItem(item)\n}\n\nfunc systrayMenuItemSelected(id uint32) {\n\tmenuItemsLock.RLock()\n\titem, ok := menuItems[id]\n\tmenuItemsLock.RUnlock()\n\tif !ok {\n\t\tlog.Errorf(\"No menu item with ID %v\", id)\n\t\treturn\n\t}\n\tselect {\n\tcase item.ClickedCh <- struct{}{}:\n\t// in case no one waiting for the channel\n\tdefault:\n\t}\n}\n"
        },
        {
          "name": "systray.h",
          "type": "blob",
          "size": 0.6650390625,
          "content": "#include \"stdbool.h\"\n\nextern void systray_ready();\nextern void systray_on_exit();\nextern void systray_menu_item_selected(int menu_id);\nvoid registerSystray(void);\nint nativeLoop(void);\n\nvoid setIcon(const char* iconBytes, int length, bool template);\nvoid setMenuItemIcon(const char* iconBytes, int length, int menuId, bool template);\nvoid setTitle(char* title);\nvoid setTooltip(char* tooltip);\nvoid setRemovalAllowed(bool allowed);\nvoid add_or_update_menu_item(int menuId, int parentMenuId, char* title, char* tooltip, short disabled, short checked, short isCheckable);\nvoid add_separator(int menuId);\nvoid hide_menu_item(int menuId);\nvoid show_menu_item(int menuId);\nvoid quit();\n"
        },
        {
          "name": "systray_darwin.go",
          "type": "blob",
          "size": 1.61328125,
          "content": "package systray\n\n/*\n#cgo darwin CFLAGS: -DDARWIN -x objective-c -fobjc-arc\n#cgo darwin LDFLAGS: -framework Cocoa -framework WebKit\n\n#include \"systray.h\"\n*/\nimport \"C\"\n\nimport (\n\t\"unsafe\"\n)\n\n// SetTemplateIcon sets the systray icon as a template icon (on Mac), falling back\n// to a regular icon on other platforms.\n// templateIconBytes and regularIconBytes should be the content of .ico for windows and\n// .ico/.jpg/.png for other platforms.\nfunc SetTemplateIcon(templateIconBytes []byte, regularIconBytes []byte) {\n\tcstr := (*C.char)(unsafe.Pointer(&templateIconBytes[0]))\n\tC.setIcon(cstr, (C.int)(len(templateIconBytes)), true)\n}\n\n// SetIcon sets the icon of a menu item. Only works on macOS and Windows.\n// iconBytes should be the content of .ico/.jpg/.png\nfunc (item *MenuItem) SetIcon(iconBytes []byte) {\n\tcstr := (*C.char)(unsafe.Pointer(&iconBytes[0]))\n\tC.setMenuItemIcon(cstr, (C.int)(len(iconBytes)), C.int(item.id), false)\n}\n\n// SetTemplateIcon sets the icon of a menu item as a template icon (on macOS). On Windows, it\n// falls back to the regular icon bytes and on Linux it does nothing.\n// templateIconBytes and regularIconBytes should be the content of .ico for windows and\n// .ico/.jpg/.png for other platforms.\nfunc (item *MenuItem) SetTemplateIcon(templateIconBytes []byte, regularIconBytes []byte) {\n\tcstr := (*C.char)(unsafe.Pointer(&templateIconBytes[0]))\n\tC.setMenuItemIcon(cstr, (C.int)(len(templateIconBytes)), C.int(item.id), true)\n}\n\n// SetRemovalAllowed sets whether a user can remove the systray icon or not.\n// This is only supported on macOS.\nfunc SetRemovalAllowed(allowed bool) {\n\tC.setRemovalAllowed((C.bool)(allowed))\n}\n"
        },
        {
          "name": "systray_darwin.m",
          "type": "blob",
          "size": 8.8671875,
          "content": "#import <Cocoa/Cocoa.h>\n#include \"systray.h\"\n\n#if __MAC_OS_X_VERSION_MIN_REQUIRED < 101400\n\n    #ifndef NSControlStateValueOff\n      #define NSControlStateValueOff NSOffState\n    #endif\n\n    #ifndef NSControlStateValueOn\n      #define NSControlStateValueOn NSOnState\n    #endif\n\n#endif\n\n@interface MenuItem : NSObject\n{\n  @public\n    NSNumber* menuId;\n    NSNumber* parentMenuId;\n    NSString* title;\n    NSString* tooltip;\n    short disabled;\n    short checked;\n}\n-(id) initWithId: (int)theMenuId\nwithParentMenuId: (int)theParentMenuId\n       withTitle: (const char*)theTitle\n     withTooltip: (const char*)theTooltip\n    withDisabled: (short)theDisabled\n     withChecked: (short)theChecked;\n     @end\n     @implementation MenuItem\n     -(id) initWithId: (int)theMenuId\n     withParentMenuId: (int)theParentMenuId\n            withTitle: (const char*)theTitle\n          withTooltip: (const char*)theTooltip\n         withDisabled: (short)theDisabled\n          withChecked: (short)theChecked\n{\n  menuId = [NSNumber numberWithInt:theMenuId];\n  parentMenuId = [NSNumber numberWithInt:theParentMenuId];\n  title = [[NSString alloc] initWithCString:theTitle\n                                   encoding:NSUTF8StringEncoding];\n  tooltip = [[NSString alloc] initWithCString:theTooltip\n                                     encoding:NSUTF8StringEncoding];\n  disabled = theDisabled;\n  checked = theChecked;\n  return self;\n}\n@end\n\n@interface AppDelegate: NSObject <NSApplicationDelegate>\n  - (void) add_or_update_menu_item:(MenuItem*) item;\n  - (IBAction)menuHandler:(id)sender;\n  @property (assign) IBOutlet NSWindow *window;\n  @end\n\n  @implementation AppDelegate\n{\n  NSStatusItem *statusItem;\n  NSMenu *menu;\n  NSCondition* cond;\n}\n\n@synthesize window = _window;\n\n- (void)applicationDidFinishLaunching:(NSNotification *)aNotification\n{\n  self->statusItem = [[NSStatusBar systemStatusBar] statusItemWithLength:NSVariableStatusItemLength];\n  self->menu = [[NSMenu alloc] init];\n  [self->menu setAutoenablesItems: FALSE];\n  [self->statusItem setMenu:self->menu];\n  // Once the user has removed it, the item needs to be explicitly brought back,\n  // even restarting the application is insufficient.\n  // Since the interface from Go is relatively simple, for now we ensure it's always\n  // visible at application startup.\n  self->statusItem.visible = TRUE;\n  systray_ready();\n}\n\n- (void)applicationWillTerminate:(NSNotification *)aNotification\n{\n  systray_on_exit();\n}\n\n- (void)setRemovalAllowed:(BOOL)allowed {\n  NSStatusItemBehavior behavior = [self->statusItem behavior];\n  if (allowed) {\n    behavior |= NSStatusItemBehaviorRemovalAllowed;\n  } else {\n    behavior &= ~NSStatusItemBehaviorRemovalAllowed;\n  }\n  self->statusItem.behavior = behavior;\n}\n\n- (void)setIcon:(NSImage *)image {\n  statusItem.button.image = image;\n  [self updateTitleButtonStyle];\n}\n\n- (void)setTitle:(NSString *)title {\n  statusItem.button.title = title;\n  [self updateTitleButtonStyle];\n}\n\n-(void)updateTitleButtonStyle {\n  if (statusItem.button.image != nil) {\n    if ([statusItem.button.title length] == 0) {\n      statusItem.button.imagePosition = NSImageOnly;\n    } else {\n      statusItem.button.imagePosition = NSImageLeft;\n    }\n  } else {\n    statusItem.button.imagePosition = NSNoImage;\n  }\n}\n\n\n- (void)setTooltip:(NSString *)tooltip {\n  statusItem.button.toolTip = tooltip;\n}\n\n- (IBAction)menuHandler:(id)sender\n{\n  NSNumber* menuId = [sender representedObject];\n  systray_menu_item_selected(menuId.intValue);\n}\n\n- (void)add_or_update_menu_item:(MenuItem *)item {\n  NSMenu *theMenu = self->menu;\n  NSMenuItem *parentItem;\n  if ([item->parentMenuId integerValue] > 0) {\n    parentItem = find_menu_item(menu, item->parentMenuId);\n    if (parentItem.hasSubmenu) {\n      theMenu = parentItem.submenu;\n    } else {\n      theMenu = [[NSMenu alloc] init];\n      [theMenu setAutoenablesItems:NO];\n      [parentItem setSubmenu:theMenu];\n    }\n  }\n  \n  NSMenuItem *menuItem;\n  menuItem = find_menu_item(theMenu, item->menuId);\n  if (menuItem == NULL) {\n    menuItem = [theMenu addItemWithTitle:item->title\n                               action:@selector(menuHandler:)\n                        keyEquivalent:@\"\"];\n    [menuItem setRepresentedObject:item->menuId];\n  }\n  [menuItem setTitle:item->title];\n  [menuItem setTag:[item->menuId integerValue]];\n  [menuItem setTarget:self];\n  [menuItem setToolTip:item->tooltip];\n  if (item->disabled == 1) {\n    menuItem.enabled = FALSE;\n  } else {\n    menuItem.enabled = TRUE;\n  }\n  if (item->checked == 1) {\n    menuItem.state = NSControlStateValueOn;\n  } else {\n    menuItem.state = NSControlStateValueOff;\n  }\n}\n\nNSMenuItem *find_menu_item(NSMenu *ourMenu, NSNumber *menuId) {\n  NSMenuItem *foundItem = [ourMenu itemWithTag:[menuId integerValue]];\n  if (foundItem != NULL) {\n    return foundItem;\n  }\n  NSArray *menu_items = ourMenu.itemArray;\n  int i;\n  for (i = 0; i < [menu_items count]; i++) {\n    NSMenuItem *i_item = [menu_items objectAtIndex:i];\n    if (i_item.hasSubmenu) {\n      foundItem = find_menu_item(i_item.submenu, menuId);\n      if (foundItem != NULL) {\n        return foundItem;\n      }\n    }\n  }\n\n  return NULL;\n};\n\n- (void) add_separator:(NSNumber*) menuId\n{\n  [menu addItem: [NSMenuItem separatorItem]];\n}\n\n- (void) hide_menu_item:(NSNumber*) menuId\n{\n  NSMenuItem* menuItem = find_menu_item(menu, menuId);\n  if (menuItem != NULL) {\n    [menuItem setHidden:TRUE];\n  }\n}\n\n- (void) setMenuItemIcon:(NSArray*)imageAndMenuId {\n  NSImage* image = [imageAndMenuId objectAtIndex:0];\n  NSNumber* menuId = [imageAndMenuId objectAtIndex:1];\n\n  NSMenuItem* menuItem;\n  menuItem = find_menu_item(menu, menuId);\n  if (menuItem == NULL) {\n    return;\n  }\n  menuItem.image = image;\n}\n\n- (void) show_menu_item:(NSNumber*) menuId\n{\n  NSMenuItem* menuItem = find_menu_item(menu, menuId);\n  if (menuItem != NULL) {\n    [menuItem setHidden:FALSE];\n  }\n}\n\n- (void) quit\n{\n  [NSApp terminate:self];\n}\n\n@end\n\nvoid registerSystray(void) {\n  AppDelegate *delegate = [[AppDelegate alloc] init];\n  [[NSApplication sharedApplication] setDelegate:delegate];\n  // A workaround to avoid crashing on macOS versions before Catalina. Somehow\n  // SIGSEGV would happen inside AppKit if [NSApp run] is called from a\n  // different function, even if that function is called right after this.\n  if (floor(NSAppKitVersionNumber) <= /*NSAppKitVersionNumber10_14*/ 1671){\n    [NSApp run];\n  }\n}\n\nint nativeLoop(void) {\n  if (floor(NSAppKitVersionNumber) > /*NSAppKitVersionNumber10_14*/ 1671){\n    [NSApp run];\n  }\n  return EXIT_SUCCESS;\n}\n\nvoid runInMainThread(SEL method, id object) {\n  [(AppDelegate*)[NSApp delegate]\n    performSelectorOnMainThread:method\n                     withObject:object\n                  waitUntilDone: YES];\n}\n\nvoid setIcon(const char* iconBytes, int length, bool template) {\n  NSData* buffer = [NSData dataWithBytes: iconBytes length:length];\n  NSImage *image = [[NSImage alloc] initWithData:buffer];\n  [image setSize:NSMakeSize(16, 16)];\n  image.template = template;\n  runInMainThread(@selector(setIcon:), (id)image);\n}\n\nvoid setMenuItemIcon(const char* iconBytes, int length, int menuId, bool template) {\n  NSData* buffer = [NSData dataWithBytes: iconBytes length:length];\n  NSImage *image = [[NSImage alloc] initWithData:buffer];\n  [image setSize:NSMakeSize(16, 16)];\n  image.template = template;\n  NSNumber *mId = [NSNumber numberWithInt:menuId];\n  runInMainThread(@selector(setMenuItemIcon:), @[image, (id)mId]);\n}\n\nvoid setTitle(char* ctitle) {\n  NSString* title = [[NSString alloc] initWithCString:ctitle\n                                             encoding:NSUTF8StringEncoding];\n  free(ctitle);\n  runInMainThread(@selector(setTitle:), (id)title);\n}\n\nvoid setTooltip(char* ctooltip) {\n  NSString* tooltip = [[NSString alloc] initWithCString:ctooltip\n                                               encoding:NSUTF8StringEncoding];\n  free(ctooltip);\n  runInMainThread(@selector(setTooltip:), (id)tooltip);\n}\n\nvoid setRemovalAllowed(bool allowed) {\n  // must use an object wrapper for the bool, to use with performSelectorOnMainThread:\n  NSNumber *allow = [NSNumber numberWithBool:(BOOL)allowed];\n  runInMainThread(@selector(setRemovalAllowed:), (id)allow);\n}\n\nvoid add_or_update_menu_item(int menuId, int parentMenuId, char* title, char* tooltip, short disabled, short checked, short isCheckable) {\n  MenuItem* item = [[MenuItem alloc] initWithId: menuId withParentMenuId: parentMenuId withTitle: title withTooltip: tooltip withDisabled: disabled withChecked: checked];\n  free(title);\n  free(tooltip);\n  runInMainThread(@selector(add_or_update_menu_item:), (id)item);\n}\n\nvoid add_separator(int menuId) {\n  NSNumber *mId = [NSNumber numberWithInt:menuId];\n  runInMainThread(@selector(add_separator:), (id)mId);\n}\n\nvoid hide_menu_item(int menuId) {\n  NSNumber *mId = [NSNumber numberWithInt:menuId];\n  runInMainThread(@selector(hide_menu_item:), (id)mId);\n}\n\nvoid show_menu_item(int menuId) {\n  NSNumber *mId = [NSNumber numberWithInt:menuId];\n  runInMainThread(@selector(show_menu_item:), (id)mId);\n}\n\nvoid quit() {\n  runInMainThread(@selector(quit), nil);\n}\n"
        },
        {
          "name": "systray_linux.c",
          "type": "blob",
          "size": 7.8291015625,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n\n#ifdef USE_LEGACY_APPINDICATOR\n#include <libappindicator/app-indicator.h>\n#else\n#include <libayatana-appindicator/app-indicator.h>\n#endif\n\n#include \"systray.h\"\n\nstatic AppIndicator *global_app_indicator;\nstatic GtkWidget *global_tray_menu = NULL;\nstatic GList *global_menu_items = NULL;\nstatic char temp_file_name[PATH_MAX] = \"\";\n\ntypedef struct {\n\tGtkWidget *menu_item;\n\tint menu_id;\n\tlong signalHandlerId;\n} MenuItemNode;\n\ntypedef struct {\n\tint menu_id;\n\tint parent_menu_id;\n\tchar* title;\n\tchar* tooltip;\n\tshort disabled;\n\tshort checked;\n\tshort isCheckable;\n} MenuItemInfo;\n\nvoid registerSystray(void) {\n\tgtk_init(0, NULL);\n\tglobal_app_indicator = app_indicator_new(\"systray\", \"\", APP_INDICATOR_CATEGORY_APPLICATION_STATUS);\n\tapp_indicator_set_status(global_app_indicator, APP_INDICATOR_STATUS_ACTIVE);\n\tglobal_tray_menu = gtk_menu_new();\n\tapp_indicator_set_menu(global_app_indicator, GTK_MENU(global_tray_menu));\n\tsystray_ready();\n}\n\nint nativeLoop(void) {\n\tgtk_main();\n\tsystray_on_exit();\n\treturn 0;\n}\n\nvoid _unlink_temp_file() {\n\tif (strlen(temp_file_name) != 0) {\n\t\tint ret = unlink(temp_file_name);\n\t\tif (ret == -1) {\n\t\t\tprintf(\"failed to remove temp icon file %s: %s\\n\", temp_file_name, strerror(errno));\n\t\t}\n\t\ttemp_file_name[0] = '\\0';\n\t}\n}\n\n// runs in main thread, should always return FALSE to prevent gtk to execute it again\ngboolean do_set_icon(gpointer data) {\n\t_unlink_temp_file();\n\tchar *tmpdir = getenv(\"TMPDIR\");\n\tif (NULL == tmpdir) {\n\t\ttmpdir = \"/tmp\";\n\t}\n\tstrncpy(temp_file_name, tmpdir, PATH_MAX-1);\n\tstrncat(temp_file_name, \"/systray_XXXXXX\", PATH_MAX-1);\n\ttemp_file_name[PATH_MAX-1] = '\\0';\n\n\tGBytes* bytes = (GBytes*)data;\n\tint fd = mkstemp(temp_file_name);\n\tif (fd == -1) {\n\t\tprintf(\"failed to create temp icon file %s: %s\\n\", temp_file_name, strerror(errno));\n\t\treturn FALSE;\n\t}\n\tgsize size = 0;\n\tgconstpointer icon_data = g_bytes_get_data(bytes, &size);\n\tssize_t written = write(fd, icon_data, size);\n\tclose(fd);\n\tif(written != size) {\n\t\tprintf(\"failed to write temp icon file %s: %s\\n\", temp_file_name, strerror(errno));\n\t\treturn FALSE;\n\t}\n\tapp_indicator_set_icon_full(global_app_indicator, temp_file_name, \"\");\n\tapp_indicator_set_attention_icon_full(global_app_indicator, temp_file_name, \"\");\n\tg_bytes_unref(bytes);\n\treturn FALSE;\n}\n\nvoid _systray_menu_item_selected(int *id) {\n\tsystray_menu_item_selected(*id);\n}\n\nGtkMenuItem* find_menu_by_id(int id) {\n\tGList* it;\n\tfor(it = global_menu_items; it != NULL; it = it->next) {\n\t\tMenuItemNode* item = (MenuItemNode*)(it->data);\n\t\tif(item->menu_id == id) {\n\t\t\treturn GTK_MENU_ITEM(item->menu_item);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n// runs in main thread, should always return FALSE to prevent gtk to execute it again\ngboolean do_add_or_update_menu_item(gpointer data) {\n\tMenuItemInfo *mii = (MenuItemInfo*)data;\n\tGList* it;\n\tfor(it = global_menu_items; it != NULL; it = it->next) {\n\t\tMenuItemNode* item = (MenuItemNode*)(it->data);\n\t\tif(item->menu_id == mii->menu_id) {\n\t\t\tgtk_menu_item_set_label(GTK_MENU_ITEM(item->menu_item), mii->title);\n\n\t\t\tif (mii->isCheckable) {\n\t\t\t\t// We need to block the \"activate\" event, to emulate the same behaviour as in the windows version\n\t\t\t\t// A Check/Uncheck does change the checkbox, but does not trigger the checkbox menuItem channel\n\t\t\t\tg_signal_handler_block(GTK_CHECK_MENU_ITEM(item->menu_item), item->signalHandlerId);\n\t\t\t\tgtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(item->menu_item), mii->checked == 1);\n\t\t\t\tg_signal_handler_unblock(GTK_CHECK_MENU_ITEM(item->menu_item), item->signalHandlerId);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// menu id doesn't exist, add new item\n\tif(it == NULL) {\n\t\tGtkWidget *menu_item;\n\t\tif (mii->isCheckable) {\n\t\t\tmenu_item = gtk_check_menu_item_new_with_label(mii->title);\n\t\t\tgtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menu_item), mii->checked == 1);\n\t\t} else {\n\t\t\tmenu_item = gtk_menu_item_new_with_label(mii->title);\n\t\t}\n\t\tint *id = malloc(sizeof(int));\n\t\t*id = mii->menu_id;\n\t\tlong signalHandlerId = g_signal_connect_swapped(\n\t\t\tG_OBJECT(menu_item),\n\t\t\t\"activate\",\n\t\t\tG_CALLBACK(_systray_menu_item_selected),\n\t\t\tid\n\t\t);\n\n\t\tif (mii->parent_menu_id == 0) {\n\t\t\tgtk_menu_shell_append(GTK_MENU_SHELL(global_tray_menu), menu_item);\n\t\t} else {\n\t\t\tGtkMenuItem* parentMenuItem = find_menu_by_id(mii->parent_menu_id);\n\t\t\tGtkWidget* parentMenu = gtk_menu_item_get_submenu(parentMenuItem);\n\n\t\t\tif(parentMenu == NULL) {\n\t\t\t\tparentMenu = gtk_menu_new();\n\t\t\t\tgtk_menu_item_set_submenu(parentMenuItem, parentMenu);\n\t\t\t}\n\n\t\t\tgtk_menu_shell_append(GTK_MENU_SHELL(parentMenu), menu_item);\n\t\t}\n\n\t\tMenuItemNode* new_item = malloc(sizeof(MenuItemNode));\n\t\tnew_item->menu_id = mii->menu_id;\n\t\tnew_item->signalHandlerId = signalHandlerId;\n\t\tnew_item->menu_item = menu_item;\n\t\tGList* new_node = malloc(sizeof(GList));\n\t\tnew_node->data = new_item;\n\t\tnew_node->next = global_menu_items;\n\t\tif(global_menu_items != NULL) {\n\t\t\tglobal_menu_items->prev = new_node;\n\t\t}\n\t\tglobal_menu_items = new_node;\n\t\tit = new_node;\n\t}\n\tGtkWidget* menu_item = GTK_WIDGET(((MenuItemNode*)(it->data))->menu_item);\n\tgtk_widget_set_sensitive(menu_item, mii->disabled != 1);\n\tgtk_widget_show(menu_item);\n\n\tfree(mii->title);\n\tfree(mii->tooltip);\n\tfree(mii);\n\treturn FALSE;\n}\n\ngboolean do_add_separator(gpointer data) {\n\tGtkWidget *separator = gtk_separator_menu_item_new();\n\tgtk_menu_shell_append(GTK_MENU_SHELL(global_tray_menu), separator);\n\tgtk_widget_show(separator);\n\treturn FALSE;\n}\n\n// runs in main thread, should always return FALSE to prevent gtk to execute it again\ngboolean do_hide_menu_item(gpointer data) {\n\tMenuItemInfo *mii = (MenuItemInfo*)data;\n\tGList* it;\n\tfor(it = global_menu_items; it != NULL; it = it->next) {\n\t\tMenuItemNode* item = (MenuItemNode*)(it->data);\n\t\tif(item->menu_id == mii->menu_id){\n\t\t\tgtk_widget_hide(GTK_WIDGET(item->menu_item));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n// runs in main thread, should always return FALSE to prevent gtk to execute it again\ngboolean do_show_menu_item(gpointer data) {\n\tMenuItemInfo *mii = (MenuItemInfo*)data;\n\tGList* it;\n\tfor(it = global_menu_items; it != NULL; it = it->next) {\n\t\tMenuItemNode* item = (MenuItemNode*)(it->data);\n\t\tif(item->menu_id == mii->menu_id){\n\t\t\tgtk_widget_show(GTK_WIDGET(item->menu_item));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n// runs in main thread, should always return FALSE to prevent gtk to execute it again\ngboolean do_quit(gpointer data) {\n\t_unlink_temp_file();\n\t// app indicator doesn't provide a way to remove it, hide it as a workaround\n\tapp_indicator_set_status(global_app_indicator, APP_INDICATOR_STATUS_PASSIVE);\n\tgtk_main_quit();\n\treturn FALSE;\n}\n\nvoid setIcon(const char* iconBytes, int length, bool template) {\n\tGBytes* bytes = g_bytes_new_static(iconBytes, length);\n\tg_idle_add(do_set_icon, bytes);\n}\n\nvoid setTitle(char* ctitle) {\n\tapp_indicator_set_title(global_app_indicator, ctitle);\n\tapp_indicator_set_label(global_app_indicator, ctitle, \"\");\n\tfree(ctitle);\n}\n\nvoid setTooltip(char* ctooltip) {\n\tfree(ctooltip);\n}\n\nvoid setMenuItemIcon(const char* iconBytes, int length, int menuId, bool template) {\n}\n\nvoid add_or_update_menu_item(int menu_id, int parent_menu_id, char* title, char* tooltip, short disabled, short checked, short isCheckable) {\n\tMenuItemInfo *mii = malloc(sizeof(MenuItemInfo));\n\tmii->menu_id = menu_id;\n\tmii->parent_menu_id = parent_menu_id;\n\tmii->title = title;\n\tmii->tooltip = tooltip;\n\tmii->disabled = disabled;\n\tmii->checked = checked;\n\tmii->isCheckable = isCheckable;\n\tg_idle_add(do_add_or_update_menu_item, mii);\n}\n\nvoid add_separator(int menu_id) {\n\tMenuItemInfo *mii = malloc(sizeof(MenuItemInfo));\n\tmii->menu_id = menu_id;\n\tg_idle_add(do_add_separator, mii);\n}\n\nvoid hide_menu_item(int menu_id) {\n\tMenuItemInfo *mii = malloc(sizeof(MenuItemInfo));\n\tmii->menu_id = menu_id;\n\tg_idle_add(do_hide_menu_item, mii);\n}\n\nvoid show_menu_item(int menu_id) {\n\tMenuItemInfo *mii = malloc(sizeof(MenuItemInfo));\n\tmii->menu_id = menu_id;\n\tg_idle_add(do_show_menu_item, mii);\n}\n\nvoid quit() {\n\tg_idle_add(do_quit, NULL);\n}\n"
        },
        {
          "name": "systray_linux.go",
          "type": "blob",
          "size": 1.060546875,
          "content": "package systray\n\n// SetTemplateIcon sets the systray icon as a template icon (on macOS), falling back\n// to a regular icon on other platforms.\n// templateIconBytes and iconBytes should be the content of .ico for windows and\n// .ico/.jpg/.png for other platforms.\nfunc SetTemplateIcon(templateIconBytes []byte, regularIconBytes []byte) {\n\tSetIcon(regularIconBytes)\n}\n\n// SetRemovalAllowed sets whether a user can remove the systray icon or not.\n// This is only supported on macOS.\nfunc SetRemovalAllowed(allowed bool) {\n}\n\n// SetIcon sets the icon of a menu item. Only works on macOS and Windows.\n// iconBytes should be the content of .ico/.jpg/.png\nfunc (item *MenuItem) SetIcon(iconBytes []byte) {\n}\n\n// SetTemplateIcon sets the icon of a menu item as a template icon (on macOS). On Windows, it\n// falls back to the regular icon bytes and on Linux it does nothing.\n// templateIconBytes and regularIconBytes should be the content of .ico for windows and\n// .ico/.jpg/.png for other platforms.\nfunc (item *MenuItem) SetTemplateIcon(templateIconBytes []byte, regularIconBytes []byte) {\n}\n"
        },
        {
          "name": "systray_linux_appindicator.go",
          "type": "blob",
          "size": 0.2138671875,
          "content": "// +build linux,legacy_appindicator\n//go:build linux && legacy_appindicator\n\npackage systray\n\n/*\n#cgo linux pkg-config: appindicator3-0.1\n#cgo linux CFLAGS: -DUSE_LEGACY_APPINDICATOR\n\n#include \"systray.h\"\n*/\nimport \"C\"\n"
        },
        {
          "name": "systray_linux_ayatana.go",
          "type": "blob",
          "size": 0.1796875,
          "content": "// +build linux,!legacy_appindicator\n//go:build linux && !legacy_appindicator\n\npackage systray\n\n/*\n#cgo linux pkg-config: ayatana-appindicator3-0.1\n\n#include \"systray.h\"\n*/\nimport \"C\"\n"
        },
        {
          "name": "systray_nonwindows.go",
          "type": "blob",
          "size": 1.7255859375,
          "content": "// +build !windows\n// go:build !windows\n\npackage systray\n\n// #include \"systray.h\"\nimport \"C\"\n\nimport (\n\t\"unsafe\"\n)\n\nfunc registerSystray() {\n\tC.registerSystray()\n}\n\nfunc nativeLoop() {\n\tC.nativeLoop()\n}\n\nfunc quit() {\n\tC.quit()\n}\n\n// SetIcon sets the systray icon.\n// iconBytes should be the content of .ico for windows and .ico/.jpg/.png\n// for other platforms.\nfunc SetIcon(iconBytes []byte) {\n\tcstr := (*C.char)(unsafe.Pointer(&iconBytes[0]))\n\tC.setIcon(cstr, (C.int)(len(iconBytes)), false)\n}\n\n// SetTitle sets the systray title, only available on Mac and Linux.\nfunc SetTitle(title string) {\n\tC.setTitle(C.CString(title))\n}\n\n// SetTooltip sets the systray tooltip to display on mouse hover of the tray icon,\n// only available on Mac and Windows.\nfunc SetTooltip(tooltip string) {\n\tC.setTooltip(C.CString(tooltip))\n}\n\nfunc addOrUpdateMenuItem(item *MenuItem) {\n\tvar disabled C.short\n\tif item.disabled {\n\t\tdisabled = 1\n\t}\n\tvar checked C.short\n\tif item.checked {\n\t\tchecked = 1\n\t}\n\tvar isCheckable C.short\n\tif item.isCheckable {\n\t\tisCheckable = 1\n\t}\n\tvar parentID uint32 = 0\n\tif item.parent != nil {\n\t\tparentID = item.parent.id\n\t}\n\tC.add_or_update_menu_item(\n\t\tC.int(item.id),\n\t\tC.int(parentID),\n\t\tC.CString(item.title),\n\t\tC.CString(item.tooltip),\n\t\tdisabled,\n\t\tchecked,\n\t\tisCheckable,\n\t)\n}\n\nfunc addSeparator(id uint32) {\n\tC.add_separator(C.int(id))\n}\n\nfunc hideMenuItem(item *MenuItem) {\n\tC.hide_menu_item(\n\t\tC.int(item.id),\n\t)\n}\n\nfunc showMenuItem(item *MenuItem) {\n\tC.show_menu_item(\n\t\tC.int(item.id),\n\t)\n}\n\n//export systray_ready\nfunc systray_ready() {\n\tsystrayReady()\n}\n\n//export systray_on_exit\nfunc systray_on_exit() {\n\tsystrayExit()\n}\n\n//export systray_menu_item_selected\nfunc systray_menu_item_selected(cID C.int) {\n\tsystrayMenuItemSelected(uint32(cID))\n}\n"
        },
        {
          "name": "systray_windows.go",
          "type": "blob",
          "size": 24.8115234375,
          "content": "// +build windows\n\npackage systray\n\nimport (\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"sync\"\n\t\"syscall\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\n// Helpful sources: https://github.com/golang/exp/blob/master/shiny/driver/internal/win32\n\nvar (\n\tg32                     = windows.NewLazySystemDLL(\"Gdi32.dll\")\n\tpCreateCompatibleBitmap = g32.NewProc(\"CreateCompatibleBitmap\")\n\tpCreateCompatibleDC     = g32.NewProc(\"CreateCompatibleDC\")\n\tpDeleteDC               = g32.NewProc(\"DeleteDC\")\n\tpSelectObject           = g32.NewProc(\"SelectObject\")\n\n\tk32              = windows.NewLazySystemDLL(\"Kernel32.dll\")\n\tpGetModuleHandle = k32.NewProc(\"GetModuleHandleW\")\n\n\ts32              = windows.NewLazySystemDLL(\"Shell32.dll\")\n\tpShellNotifyIcon = s32.NewProc(\"Shell_NotifyIconW\")\n\n\tu32                    = windows.NewLazySystemDLL(\"User32.dll\")\n\tpCreateMenu            = u32.NewProc(\"CreateMenu\")\n\tpCreatePopupMenu       = u32.NewProc(\"CreatePopupMenu\")\n\tpCreateWindowEx        = u32.NewProc(\"CreateWindowExW\")\n\tpDefWindowProc         = u32.NewProc(\"DefWindowProcW\")\n\tpRemoveMenu            = u32.NewProc(\"RemoveMenu\")\n\tpDestroyWindow         = u32.NewProc(\"DestroyWindow\")\n\tpDispatchMessage       = u32.NewProc(\"DispatchMessageW\")\n\tpDrawIconEx            = u32.NewProc(\"DrawIconEx\")\n\tpGetCursorPos          = u32.NewProc(\"GetCursorPos\")\n\tpGetDC                 = u32.NewProc(\"GetDC\")\n\tpGetMessage            = u32.NewProc(\"GetMessageW\")\n\tpGetSystemMetrics      = u32.NewProc(\"GetSystemMetrics\")\n\tpInsertMenuItem        = u32.NewProc(\"InsertMenuItemW\")\n\tpLoadCursor            = u32.NewProc(\"LoadCursorW\")\n\tpLoadIcon              = u32.NewProc(\"LoadIconW\")\n\tpLoadImage             = u32.NewProc(\"LoadImageW\")\n\tpPostMessage           = u32.NewProc(\"PostMessageW\")\n\tpPostQuitMessage       = u32.NewProc(\"PostQuitMessage\")\n\tpRegisterClass         = u32.NewProc(\"RegisterClassExW\")\n\tpRegisterWindowMessage = u32.NewProc(\"RegisterWindowMessageW\")\n\tpReleaseDC             = u32.NewProc(\"ReleaseDC\")\n\tpSetForegroundWindow   = u32.NewProc(\"SetForegroundWindow\")\n\tpSetMenuInfo           = u32.NewProc(\"SetMenuInfo\")\n\tpSetMenuItemInfo       = u32.NewProc(\"SetMenuItemInfoW\")\n\tpShowWindow            = u32.NewProc(\"ShowWindow\")\n\tpTrackPopupMenu        = u32.NewProc(\"TrackPopupMenu\")\n\tpTranslateMessage      = u32.NewProc(\"TranslateMessage\")\n\tpUnregisterClass       = u32.NewProc(\"UnregisterClassW\")\n\tpUpdateWindow          = u32.NewProc(\"UpdateWindow\")\n)\n\n// Contains window class information.\n// It is used with the RegisterClassEx and GetClassInfoEx functions.\n// https://msdn.microsoft.com/en-us/library/ms633577.aspx\ntype wndClassEx struct {\n\tSize, Style                        uint32\n\tWndProc                            uintptr\n\tClsExtra, WndExtra                 int32\n\tInstance, Icon, Cursor, Background windows.Handle\n\tMenuName, ClassName                *uint16\n\tIconSm                             windows.Handle\n}\n\n// Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function.\n// https://msdn.microsoft.com/en-us/library/ms633587.aspx\nfunc (w *wndClassEx) register() error {\n\tw.Size = uint32(unsafe.Sizeof(*w))\n\tres, _, err := pRegisterClass.Call(uintptr(unsafe.Pointer(w)))\n\tif res == 0 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Unregisters a window class, freeing the memory required for the class.\n// https://msdn.microsoft.com/en-us/library/ms644899.aspx\nfunc (w *wndClassEx) unregister() error {\n\tres, _, err := pUnregisterClass.Call(\n\t\tuintptr(unsafe.Pointer(w.ClassName)),\n\t\tuintptr(w.Instance),\n\t)\n\tif res == 0 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Contains information that the system needs to display notifications in the notification area.\n// Used by Shell_NotifyIcon.\n// https://msdn.microsoft.com/en-us/library/windows/desktop/bb773352(v=vs.85).aspx\n// https://msdn.microsoft.com/en-us/library/windows/desktop/bb762159\ntype notifyIconData struct {\n\tSize                       uint32\n\tWnd                        windows.Handle\n\tID, Flags, CallbackMessage uint32\n\tIcon                       windows.Handle\n\tTip                        [128]uint16\n\tState, StateMask           uint32\n\tInfo                       [256]uint16\n\tTimeout, Version           uint32\n\tInfoTitle                  [64]uint16\n\tInfoFlags                  uint32\n\tGuidItem                   windows.GUID\n\tBalloonIcon                windows.Handle\n}\n\nfunc (nid *notifyIconData) add() error {\n\tconst NIM_ADD = 0x00000000\n\tres, _, err := pShellNotifyIcon.Call(\n\t\tuintptr(NIM_ADD),\n\t\tuintptr(unsafe.Pointer(nid)),\n\t)\n\tif res == 0 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (nid *notifyIconData) modify() error {\n\tconst NIM_MODIFY = 0x00000001\n\tres, _, err := pShellNotifyIcon.Call(\n\t\tuintptr(NIM_MODIFY),\n\t\tuintptr(unsafe.Pointer(nid)),\n\t)\n\tif res == 0 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (nid *notifyIconData) delete() error {\n\tconst NIM_DELETE = 0x00000002\n\tres, _, err := pShellNotifyIcon.Call(\n\t\tuintptr(NIM_DELETE),\n\t\tuintptr(unsafe.Pointer(nid)),\n\t)\n\tif res == 0 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Contains information about a menu item.\n// https://msdn.microsoft.com/en-us/library/windows/desktop/ms647578(v=vs.85).aspx\ntype menuItemInfo struct {\n\tSize, Mask, Type, State     uint32\n\tID                          uint32\n\tSubMenu, Checked, Unchecked windows.Handle\n\tItemData                    uintptr\n\tTypeData                    *uint16\n\tCch                         uint32\n\tBMPItem                     windows.Handle\n}\n\n// The POINT structure defines the x- and y- coordinates of a point.\n// https://msdn.microsoft.com/en-us/library/windows/desktop/dd162805(v=vs.85).aspx\ntype point struct {\n\tX, Y int32\n}\n\n// Contains information about loaded resources\ntype winTray struct {\n\tinstance,\n\ticon,\n\tcursor,\n\twindow windows.Handle\n\n\tloadedImages   map[string]windows.Handle\n\tmuLoadedImages sync.RWMutex\n\t// menus keeps track of the submenus keyed by the menu item ID, plus 0\n\t// which corresponds to the main popup menu.\n\tmenus   map[uint32]windows.Handle\n\tmuMenus sync.RWMutex\n\t// menuOf keeps track of the menu each menu item belongs to.\n\tmenuOf   map[uint32]windows.Handle\n\tmuMenuOf sync.RWMutex\n\t// menuItemIcons maintains the bitmap of each menu item (if applies). It's\n\t// needed to show the icon correctly when showing a previously hidden menu\n\t// item again.\n\tmenuItemIcons   map[uint32]windows.Handle\n\tmuMenuItemIcons sync.RWMutex\n\tvisibleItems    map[uint32][]uint32\n\tmuVisibleItems  sync.RWMutex\n\n\tnid   *notifyIconData\n\tmuNID sync.RWMutex\n\twcex  *wndClassEx\n\n\twmSystrayMessage,\n\twmTaskbarCreated uint32\n}\n\n// Loads an image from file and shows it in tray.\n// Shell_NotifyIcon: https://msdn.microsoft.com/en-us/library/windows/desktop/bb762159(v=vs.85).aspx\nfunc (t *winTray) setIcon(src string) error {\n\tconst NIF_ICON = 0x00000002\n\n\th, err := t.loadIconFrom(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt.muNID.Lock()\n\tdefer t.muNID.Unlock()\n\tt.nid.Icon = h\n\tt.nid.Flags |= NIF_ICON\n\tt.nid.Size = uint32(unsafe.Sizeof(*t.nid))\n\n\treturn t.nid.modify()\n}\n\n// Sets tooltip on icon.\n// Shell_NotifyIcon: https://msdn.microsoft.com/en-us/library/windows/desktop/bb762159(v=vs.85).aspx\nfunc (t *winTray) setTooltip(src string) error {\n\tconst NIF_TIP = 0x00000004\n\tb, err := windows.UTF16FromString(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt.muNID.Lock()\n\tdefer t.muNID.Unlock()\n\tcopy(t.nid.Tip[:], b[:])\n\tt.nid.Flags |= NIF_TIP\n\tt.nid.Size = uint32(unsafe.Sizeof(*t.nid))\n\n\treturn t.nid.modify()\n}\n\nvar wt winTray\n\n// WindowProc callback function that processes messages sent to a window.\n// https://msdn.microsoft.com/en-us/library/windows/desktop/ms633573(v=vs.85).aspx\nfunc (t *winTray) wndProc(hWnd windows.Handle, message uint32, wParam, lParam uintptr) (lResult uintptr) {\n\tconst (\n\t\tWM_RBUTTONUP  = 0x0205\n\t\tWM_LBUTTONUP  = 0x0202\n\t\tWM_COMMAND    = 0x0111\n\t\tWM_ENDSESSION = 0x0016\n\t\tWM_CLOSE      = 0x0010\n\t\tWM_DESTROY    = 0x0002\n\t)\n\tswitch message {\n\tcase WM_COMMAND:\n\t\tmenuItemId := int32(wParam)\n\t\t// https://docs.microsoft.com/en-us/windows/win32/menurc/wm-command#menus\n\t\tif menuItemId != -1 {\n\t\t\tsystrayMenuItemSelected(uint32(wParam))\n\t\t}\n\tcase WM_CLOSE:\n\t\tpDestroyWindow.Call(uintptr(t.window))\n\t\tt.wcex.unregister()\n\tcase WM_DESTROY:\n\t\t// same as WM_ENDSESSION, but throws 0 exit code after all\n\t\tdefer pPostQuitMessage.Call(uintptr(int32(0)))\n\t\tfallthrough\n\tcase WM_ENDSESSION:\n\t\tt.muNID.Lock()\n\t\tif t.nid != nil {\n\t\t\tt.nid.delete()\n\t\t}\n\t\tt.muNID.Unlock()\n\t\tsystrayExit()\n\tcase t.wmSystrayMessage:\n\t\tswitch lParam {\n\t\tcase WM_RBUTTONUP, WM_LBUTTONUP:\n\t\t\tt.showMenu()\n\t\t}\n\tcase t.wmTaskbarCreated: // on explorer.exe restarts\n\t\tt.muNID.Lock()\n\t\tt.nid.add()\n\t\tt.muNID.Unlock()\n\tdefault:\n\t\t// Calls the default window procedure to provide default processing for any window messages that an application does not process.\n\t\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms633572(v=vs.85).aspx\n\t\tlResult, _, _ = pDefWindowProc.Call(\n\t\t\tuintptr(hWnd),\n\t\t\tuintptr(message),\n\t\t\tuintptr(wParam),\n\t\t\tuintptr(lParam),\n\t\t)\n\t}\n\treturn\n}\n\nfunc (t *winTray) initInstance() error {\n\tconst IDI_APPLICATION = 32512\n\tconst IDC_ARROW = 32512 // Standard arrow\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms633548(v=vs.85).aspx\n\tconst SW_HIDE = 0\n\tconst CW_USEDEFAULT = 0x80000000\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600(v=vs.85).aspx\n\tconst (\n\t\tWS_CAPTION     = 0x00C00000\n\t\tWS_MAXIMIZEBOX = 0x00010000\n\t\tWS_MINIMIZEBOX = 0x00020000\n\t\tWS_OVERLAPPED  = 0x00000000\n\t\tWS_SYSMENU     = 0x00080000\n\t\tWS_THICKFRAME  = 0x00040000\n\n\t\tWS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX\n\t)\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ff729176\n\tconst (\n\t\tCS_HREDRAW = 0x0002\n\t\tCS_VREDRAW = 0x0001\n\t)\n\tconst NIF_MESSAGE = 0x00000001\n\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms644931(v=vs.85).aspx\n\tconst WM_USER = 0x0400\n\n\tconst (\n\t\tclassName  = \"SystrayClass\"\n\t\twindowName = \"\"\n\t)\n\n\tt.wmSystrayMessage = WM_USER + 1\n\tt.visibleItems = make(map[uint32][]uint32)\n\tt.menus = make(map[uint32]windows.Handle)\n\tt.menuOf = make(map[uint32]windows.Handle)\n\tt.menuItemIcons = make(map[uint32]windows.Handle)\n\n\ttaskbarEventNamePtr, _ := windows.UTF16PtrFromString(\"TaskbarCreated\")\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms644947\n\tres, _, err := pRegisterWindowMessage.Call(\n\t\tuintptr(unsafe.Pointer(taskbarEventNamePtr)),\n\t)\n\tt.wmTaskbarCreated = uint32(res)\n\n\tt.loadedImages = make(map[string]windows.Handle)\n\n\tinstanceHandle, _, err := pGetModuleHandle.Call(0)\n\tif instanceHandle == 0 {\n\t\treturn err\n\t}\n\tt.instance = windows.Handle(instanceHandle)\n\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms648072(v=vs.85).aspx\n\ticonHandle, _, err := pLoadIcon.Call(0, uintptr(IDI_APPLICATION))\n\tif iconHandle == 0 {\n\t\treturn err\n\t}\n\tt.icon = windows.Handle(iconHandle)\n\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms648391(v=vs.85).aspx\n\tcursorHandle, _, err := pLoadCursor.Call(0, uintptr(IDC_ARROW))\n\tif cursorHandle == 0 {\n\t\treturn err\n\t}\n\tt.cursor = windows.Handle(cursorHandle)\n\n\tclassNamePtr, err := windows.UTF16PtrFromString(className)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twindowNamePtr, err := windows.UTF16PtrFromString(windowName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt.wcex = &wndClassEx{\n\t\tStyle:      CS_HREDRAW | CS_VREDRAW,\n\t\tWndProc:    windows.NewCallback(t.wndProc),\n\t\tInstance:   t.instance,\n\t\tIcon:       t.icon,\n\t\tCursor:     t.cursor,\n\t\tBackground: windows.Handle(6), // (COLOR_WINDOW + 1)\n\t\tClassName:  classNamePtr,\n\t\tIconSm:     t.icon,\n\t}\n\tif err := t.wcex.register(); err != nil {\n\t\treturn err\n\t}\n\n\twindowHandle, _, err := pCreateWindowEx.Call(\n\t\tuintptr(0),\n\t\tuintptr(unsafe.Pointer(classNamePtr)),\n\t\tuintptr(unsafe.Pointer(windowNamePtr)),\n\t\tuintptr(WS_OVERLAPPEDWINDOW),\n\t\tuintptr(CW_USEDEFAULT),\n\t\tuintptr(CW_USEDEFAULT),\n\t\tuintptr(CW_USEDEFAULT),\n\t\tuintptr(CW_USEDEFAULT),\n\t\tuintptr(0),\n\t\tuintptr(0),\n\t\tuintptr(t.instance),\n\t\tuintptr(0),\n\t)\n\tif windowHandle == 0 {\n\t\treturn err\n\t}\n\tt.window = windows.Handle(windowHandle)\n\n\tpShowWindow.Call(\n\t\tuintptr(t.window),\n\t\tuintptr(SW_HIDE),\n\t)\n\n\tpUpdateWindow.Call(\n\t\tuintptr(t.window),\n\t)\n\n\tt.muNID.Lock()\n\tdefer t.muNID.Unlock()\n\tt.nid = &notifyIconData{\n\t\tWnd:             windows.Handle(t.window),\n\t\tID:              100,\n\t\tFlags:           NIF_MESSAGE,\n\t\tCallbackMessage: t.wmSystrayMessage,\n\t}\n\tt.nid.Size = uint32(unsafe.Sizeof(*t.nid))\n\n\treturn t.nid.add()\n}\n\nfunc (t *winTray) createMenu() error {\n\tconst MIM_APPLYTOSUBMENUS = 0x80000000 // Settings apply to the menu and all of its submenus\n\n\tmenuHandle, _, err := pCreatePopupMenu.Call()\n\tif menuHandle == 0 {\n\t\treturn err\n\t}\n\tt.menus[0] = windows.Handle(menuHandle)\n\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms647575(v=vs.85).aspx\n\tmi := struct {\n\t\tSize, Mask, Style, Max uint32\n\t\tBackground             windows.Handle\n\t\tContextHelpID          uint32\n\t\tMenuData               uintptr\n\t}{\n\t\tMask: MIM_APPLYTOSUBMENUS,\n\t}\n\tmi.Size = uint32(unsafe.Sizeof(mi))\n\n\tres, _, err := pSetMenuInfo.Call(\n\t\tuintptr(t.menus[0]),\n\t\tuintptr(unsafe.Pointer(&mi)),\n\t)\n\tif res == 0 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (t *winTray) convertToSubMenu(menuItemId uint32) (windows.Handle, error) {\n\tconst MIIM_SUBMENU = 0x00000004\n\n\tres, _, err := pCreateMenu.Call()\n\tif res == 0 {\n\t\treturn 0, err\n\t}\n\tmenu := windows.Handle(res)\n\n\tmi := menuItemInfo{Mask: MIIM_SUBMENU, SubMenu: menu}\n\tmi.Size = uint32(unsafe.Sizeof(mi))\n\tt.muMenuOf.RLock()\n\thMenu := t.menuOf[menuItemId]\n\tt.muMenuOf.RUnlock()\n\tres, _, err = pSetMenuItemInfo.Call(\n\t\tuintptr(hMenu),\n\t\tuintptr(menuItemId),\n\t\t0,\n\t\tuintptr(unsafe.Pointer(&mi)),\n\t)\n\tif res == 0 {\n\t\treturn 0, err\n\t}\n\tt.muMenus.Lock()\n\tt.menus[menuItemId] = menu\n\tt.muMenus.Unlock()\n\treturn menu, nil\n}\n\nfunc (t *winTray) addOrUpdateMenuItem(menuItemId uint32, parentId uint32, title string, disabled, checked bool) error {\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms647578(v=vs.85).aspx\n\tconst (\n\t\tMIIM_FTYPE   = 0x00000100\n\t\tMIIM_BITMAP  = 0x00000080\n\t\tMIIM_STRING  = 0x00000040\n\t\tMIIM_SUBMENU = 0x00000004\n\t\tMIIM_ID      = 0x00000002\n\t\tMIIM_STATE   = 0x00000001\n\t)\n\tconst MFT_STRING = 0x00000000\n\tconst (\n\t\tMFS_CHECKED  = 0x00000008\n\t\tMFS_DISABLED = 0x00000003\n\t)\n\ttitlePtr, err := windows.UTF16PtrFromString(title)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmi := menuItemInfo{\n\t\tMask:     MIIM_FTYPE | MIIM_STRING | MIIM_ID | MIIM_STATE,\n\t\tType:     MFT_STRING,\n\t\tID:       uint32(menuItemId),\n\t\tTypeData: titlePtr,\n\t\tCch:      uint32(len(title)),\n\t}\n\tmi.Size = uint32(unsafe.Sizeof(mi))\n\tif disabled {\n\t\tmi.State |= MFS_DISABLED\n\t}\n\tif checked {\n\t\tmi.State |= MFS_CHECKED\n\t}\n\tt.muMenuItemIcons.RLock()\n\thIcon := t.menuItemIcons[menuItemId]\n\tt.muMenuItemIcons.RUnlock()\n\tif hIcon > 0 {\n\t\tmi.Mask |= MIIM_BITMAP\n\t\tmi.BMPItem = hIcon\n\t}\n\n\tvar res uintptr\n\tt.muMenus.RLock()\n\tmenu, exists := t.menus[parentId]\n\tt.muMenus.RUnlock()\n\tif !exists {\n\t\tmenu, err = t.convertToSubMenu(parentId)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tt.muMenus.Lock()\n\t\tt.menus[parentId] = menu\n\t\tt.muMenus.Unlock()\n\t} else if t.getVisibleItemIndex(parentId, menuItemId) != -1 {\n\t\t// We set the menu item info based on the menuID\n\t\tres, _, err = pSetMenuItemInfo.Call(\n\t\t\tuintptr(menu),\n\t\t\tuintptr(menuItemId),\n\t\t\t0,\n\t\t\tuintptr(unsafe.Pointer(&mi)),\n\t\t)\n\t}\n\n\tif res == 0 {\n\t\t// Menu item does not already exist, create it\n\t\tt.muMenus.RLock()\n\t\tsubmenu, exists := t.menus[menuItemId]\n\t\tt.muMenus.RUnlock()\n\t\tif exists {\n\t\t\tmi.Mask |= MIIM_SUBMENU\n\t\t\tmi.SubMenu = submenu\n\t\t}\n\t\tt.addToVisibleItems(parentId, menuItemId)\n\t\tposition := t.getVisibleItemIndex(parentId, menuItemId)\n\t\tres, _, err = pInsertMenuItem.Call(\n\t\t\tuintptr(menu),\n\t\t\tuintptr(position),\n\t\t\t1,\n\t\t\tuintptr(unsafe.Pointer(&mi)),\n\t\t)\n\t\tif res == 0 {\n\t\t\tt.delFromVisibleItems(parentId, menuItemId)\n\t\t\treturn err\n\t\t}\n\t\tt.muMenuOf.Lock()\n\t\tt.menuOf[menuItemId] = menu\n\t\tt.muMenuOf.Unlock()\n\t}\n\n\treturn nil\n}\n\nfunc (t *winTray) addSeparatorMenuItem(menuItemId, parentId uint32) error {\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms647578(v=vs.85).aspx\n\tconst (\n\t\tMIIM_FTYPE = 0x00000100\n\t\tMIIM_ID    = 0x00000002\n\t\tMIIM_STATE = 0x00000001\n\t)\n\tconst MFT_SEPARATOR = 0x00000800\n\n\tmi := menuItemInfo{\n\t\tMask: MIIM_FTYPE | MIIM_ID | MIIM_STATE,\n\t\tType: MFT_SEPARATOR,\n\t\tID:   uint32(menuItemId),\n\t}\n\n\tmi.Size = uint32(unsafe.Sizeof(mi))\n\n\tt.addToVisibleItems(parentId, menuItemId)\n\tposition := t.getVisibleItemIndex(parentId, menuItemId)\n\tt.muMenus.RLock()\n\tmenu := uintptr(t.menus[parentId])\n\tt.muMenus.RUnlock()\n\tres, _, err := pInsertMenuItem.Call(\n\t\tmenu,\n\t\tuintptr(position),\n\t\t1,\n\t\tuintptr(unsafe.Pointer(&mi)),\n\t)\n\tif res == 0 {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (t *winTray) hideMenuItem(menuItemId, parentId uint32) error {\n\t// https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-removemenu\n\tconst MF_BYCOMMAND = 0x00000000\n\tconst ERROR_SUCCESS syscall.Errno = 0\n\n\tt.muMenus.RLock()\n\tmenu := uintptr(t.menus[parentId])\n\tt.muMenus.RUnlock()\n\tres, _, err := pRemoveMenu.Call(\n\t\tmenu,\n\t\tuintptr(menuItemId),\n\t\tMF_BYCOMMAND,\n\t)\n\tif res == 0 && err.(syscall.Errno) != ERROR_SUCCESS {\n\t\treturn err\n\t}\n\tt.delFromVisibleItems(parentId, menuItemId)\n\n\treturn nil\n}\n\nfunc (t *winTray) showMenu() error {\n\tconst (\n\t\tTPM_BOTTOMALIGN = 0x0020\n\t\tTPM_LEFTALIGN   = 0x0000\n\t)\n\tp := point{}\n\tres, _, err := pGetCursorPos.Call(uintptr(unsafe.Pointer(&p)))\n\tif res == 0 {\n\t\treturn err\n\t}\n\tpSetForegroundWindow.Call(uintptr(t.window))\n\n\tres, _, err = pTrackPopupMenu.Call(\n\t\tuintptr(t.menus[0]),\n\t\tTPM_BOTTOMALIGN|TPM_LEFTALIGN,\n\t\tuintptr(p.X),\n\t\tuintptr(p.Y),\n\t\t0,\n\t\tuintptr(t.window),\n\t\t0,\n\t)\n\tif res == 0 {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (t *winTray) delFromVisibleItems(parent, val uint32) {\n\tt.muVisibleItems.Lock()\n\tdefer t.muVisibleItems.Unlock()\n\tvisibleItems := t.visibleItems[parent]\n\tfor i, itemval := range visibleItems {\n\t\tif val == itemval {\n\t\t\tt.visibleItems[parent] = append(visibleItems[:i], visibleItems[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (t *winTray) addToVisibleItems(parent, val uint32) {\n\tt.muVisibleItems.Lock()\n\tdefer t.muVisibleItems.Unlock()\n\tif visibleItems, exists := t.visibleItems[parent]; !exists {\n\t\tt.visibleItems[parent] = []uint32{val}\n\t} else {\n\t\tnewvisible := append(visibleItems, val)\n\t\tsort.Slice(newvisible, func(i, j int) bool { return newvisible[i] < newvisible[j] })\n\t\tt.visibleItems[parent] = newvisible\n\t}\n}\n\nfunc (t *winTray) getVisibleItemIndex(parent, val uint32) int {\n\tt.muVisibleItems.RLock()\n\tdefer t.muVisibleItems.RUnlock()\n\tfor i, itemval := range t.visibleItems[parent] {\n\t\tif val == itemval {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// Loads an image from file to be shown in tray or menu item.\n// LoadImage: https://msdn.microsoft.com/en-us/library/windows/desktop/ms648045(v=vs.85).aspx\nfunc (t *winTray) loadIconFrom(src string) (windows.Handle, error) {\n\tconst IMAGE_ICON = 1               // Loads an icon\n\tconst LR_LOADFROMFILE = 0x00000010 // Loads the stand-alone image from the file\n\tconst LR_DEFAULTSIZE = 0x00000040  // Loads default-size icon for windows(SM_CXICON x SM_CYICON) if cx, cy are set to zero\n\n\t// Save and reuse handles of loaded images\n\tt.muLoadedImages.RLock()\n\th, ok := t.loadedImages[src]\n\tt.muLoadedImages.RUnlock()\n\tif !ok {\n\t\tsrcPtr, err := windows.UTF16PtrFromString(src)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tres, _, err := pLoadImage.Call(\n\t\t\t0,\n\t\t\tuintptr(unsafe.Pointer(srcPtr)),\n\t\t\tIMAGE_ICON,\n\t\t\t0,\n\t\t\t0,\n\t\t\tLR_LOADFROMFILE|LR_DEFAULTSIZE,\n\t\t)\n\t\tif res == 0 {\n\t\t\treturn 0, err\n\t\t}\n\t\th = windows.Handle(res)\n\t\tt.muLoadedImages.Lock()\n\t\tt.loadedImages[src] = h\n\t\tt.muLoadedImages.Unlock()\n\t}\n\treturn h, nil\n}\n\nfunc (t *winTray) iconToBitmap(hIcon windows.Handle) (windows.Handle, error) {\n\tconst SM_CXSMICON = 49\n\tconst SM_CYSMICON = 50\n\tconst DI_NORMAL = 0x3\n\thDC, _, err := pGetDC.Call(uintptr(0))\n\tif hDC == 0 {\n\t\treturn 0, err\n\t}\n\tdefer pReleaseDC.Call(uintptr(0), hDC)\n\thMemDC, _, err := pCreateCompatibleDC.Call(hDC)\n\tif hMemDC == 0 {\n\t\treturn 0, err\n\t}\n\tdefer pDeleteDC.Call(hMemDC)\n\tcx, _, _ := pGetSystemMetrics.Call(SM_CXSMICON)\n\tcy, _, _ := pGetSystemMetrics.Call(SM_CYSMICON)\n\thMemBmp, _, err := pCreateCompatibleBitmap.Call(hDC, cx, cy)\n\tif hMemBmp == 0 {\n\t\treturn 0, err\n\t}\n\thOriginalBmp, _, _ := pSelectObject.Call(hMemDC, hMemBmp)\n\tdefer pSelectObject.Call(hMemDC, hOriginalBmp)\n\tres, _, err := pDrawIconEx.Call(hMemDC, 0, 0, uintptr(hIcon), cx, cy, 0, uintptr(0), DI_NORMAL)\n\tif res == 0 {\n\t\treturn 0, err\n\t}\n\treturn windows.Handle(hMemBmp), nil\n}\n\nfunc registerSystray() {\n\tif err := wt.initInstance(); err != nil {\n\t\tlog.Errorf(\"Unable to init instance: %v\", err)\n\t\treturn\n\t}\n\n\tif err := wt.createMenu(); err != nil {\n\t\tlog.Errorf(\"Unable to create menu: %v\", err)\n\t\treturn\n\t}\n\n\tsystrayReady()\n}\n\nfunc nativeLoop() {\n\t// Main message pump.\n\tm := &struct {\n\t\tWindowHandle windows.Handle\n\t\tMessage      uint32\n\t\tWparam       uintptr\n\t\tLparam       uintptr\n\t\tTime         uint32\n\t\tPt           point\n\t}{}\n\tfor {\n\t\tret, _, err := pGetMessage.Call(uintptr(unsafe.Pointer(m)), 0, 0, 0)\n\n\t\t// If the function retrieves a message other than WM_QUIT, the return value is nonzero.\n\t\t// If the function retrieves the WM_QUIT message, the return value is zero.\n\t\t// If there is an error, the return value is -1\n\t\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms644936(v=vs.85).aspx\n\t\tswitch int32(ret) {\n\t\tcase -1:\n\t\t\tlog.Errorf(\"Error at message loop: %v\", err)\n\t\t\treturn\n\t\tcase 0:\n\t\t\treturn\n\t\tdefault:\n\t\t\tpTranslateMessage.Call(uintptr(unsafe.Pointer(m)))\n\t\t\tpDispatchMessage.Call(uintptr(unsafe.Pointer(m)))\n\t\t}\n\t}\n}\n\nfunc quit() {\n\tconst WM_CLOSE = 0x0010\n\n\tpPostMessage.Call(\n\t\tuintptr(wt.window),\n\t\tWM_CLOSE,\n\t\t0,\n\t\t0,\n\t)\n}\n\nfunc iconBytesToFilePath(iconBytes []byte) (string, error) {\n\tbh := md5.Sum(iconBytes)\n\tdataHash := hex.EncodeToString(bh[:])\n\ticonFilePath := filepath.Join(os.TempDir(), \"systray_temp_icon_\"+dataHash)\n\n\tif _, err := os.Stat(iconFilePath); os.IsNotExist(err) {\n\t\tif err := ioutil.WriteFile(iconFilePath, iconBytes, 0644); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn iconFilePath, nil\n}\n\n// SetIcon sets the systray icon.\n// iconBytes should be the content of .ico for windows and .ico/.jpg/.png\n// for other platforms.\nfunc SetIcon(iconBytes []byte) {\n\ticonFilePath, err := iconBytesToFilePath(iconBytes)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to write icon data to temp file: %v\", err)\n\t\treturn\n\t}\n\tif err := wt.setIcon(iconFilePath); err != nil {\n\t\tlog.Errorf(\"Unable to set icon: %v\", err)\n\t\treturn\n\t}\n}\n\n// SetTemplateIcon sets the systray icon as a template icon (on macOS), falling back\n// to a regular icon on other platforms.\n// templateIconBytes and iconBytes should be the content of .ico for windows and\n// .ico/.jpg/.png for other platforms.\nfunc SetTemplateIcon(templateIconBytes []byte, regularIconBytes []byte) {\n\tSetIcon(regularIconBytes)\n}\n\n// SetTitle sets the systray title, only available on Mac and Linux.\nfunc SetTitle(title string) {\n\t// do nothing\n}\n\nfunc (item *MenuItem) parentId() uint32 {\n\tif item.parent != nil {\n\t\treturn uint32(item.parent.id)\n\t}\n\treturn 0\n}\n\n// SetIcon sets the icon of a menu item. Only works on macOS and Windows.\n// iconBytes should be the content of .ico/.jpg/.png\nfunc (item *MenuItem) SetIcon(iconBytes []byte) {\n\ticonFilePath, err := iconBytesToFilePath(iconBytes)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to write icon data to temp file: %v\", err)\n\t\treturn\n\t}\n\n\th, err := wt.loadIconFrom(iconFilePath)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to load icon from temp file: %v\", err)\n\t\treturn\n\t}\n\n\th, err = wt.iconToBitmap(h)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to convert icon to bitmap: %v\", err)\n\t\treturn\n\t}\n\twt.muMenuItemIcons.Lock()\n\twt.menuItemIcons[uint32(item.id)] = h\n\twt.muMenuItemIcons.Unlock()\n\n\terr = wt.addOrUpdateMenuItem(uint32(item.id), item.parentId(), item.title, item.disabled, item.checked)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to addOrUpdateMenuItem: %v\", err)\n\t\treturn\n\t}\n}\n\n// SetTooltip sets the systray tooltip to display on mouse hover of the tray icon,\n// only available on Mac and Windows.\nfunc SetTooltip(tooltip string) {\n\tif err := wt.setTooltip(tooltip); err != nil {\n\t\tlog.Errorf(\"Unable to set tooltip: %v\", err)\n\t\treturn\n\t}\n}\n\n// SetRemovalAllowed sets whether a user can remove the systray icon or not.\n// This is only supported on macOS.\nfunc SetRemovalAllowed(allowed bool) {\n}\n\nfunc addOrUpdateMenuItem(item *MenuItem) {\n\terr := wt.addOrUpdateMenuItem(uint32(item.id), item.parentId(), item.title, item.disabled, item.checked)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to addOrUpdateMenuItem: %v\", err)\n\t\treturn\n\t}\n}\n\n// SetTemplateIcon sets the icon of a menu item as a template icon (on macOS). On Windows, it\n// falls back to the regular icon bytes and on Linux it does nothing.\n// templateIconBytes and regularIconBytes should be the content of .ico for windows and\n// .ico/.jpg/.png for other platforms.\nfunc (item *MenuItem) SetTemplateIcon(templateIconBytes []byte, regularIconBytes []byte) {\n\titem.SetIcon(regularIconBytes)\n}\n\nfunc addSeparator(id uint32) {\n\terr := wt.addSeparatorMenuItem(id, 0)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to addSeparator: %v\", err)\n\t\treturn\n\t}\n}\n\nfunc hideMenuItem(item *MenuItem) {\n\terr := wt.hideMenuItem(uint32(item.id), item.parentId())\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to hideMenuItem: %v\", err)\n\t\treturn\n\t}\n}\n\nfunc showMenuItem(item *MenuItem) {\n\taddOrUpdateMenuItem(item)\n}\n"
        },
        {
          "name": "systray_windows_test.go",
          "type": "blob",
          "size": 2.9033203125,
          "content": "// +build windows\n\npackage systray\n\nimport (\n\t\"io/ioutil\"\n\t\"runtime\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\nconst iconFilePath = \"example/icon/iconwin.ico\"\n\nfunc TestBaseWindowsTray(t *testing.T) {\n\tsystrayReady = func() {}\n\tsystrayExit = func() {}\n\n\truntime.LockOSThread()\n\n\tif err := wt.initInstance(); err != nil {\n\t\tt.Fatalf(\"initInstance failed: %s\", err)\n\t}\n\n\tif err := wt.createMenu(); err != nil {\n\t\tt.Fatalf(\"createMenu failed: %s\", err)\n\t}\n\n\tdefer func() {\n\t\tpDestroyWindow.Call(uintptr(wt.window))\n\t\twt.wcex.unregister()\n\t}()\n\n\tif err := wt.setIcon(iconFilePath); err != nil {\n\t\tt.Errorf(\"SetIcon failed: %s\", err)\n\t}\n\n\tif err := wt.setTooltip(\"Cyrillic tooltip тест:)\"); err != nil {\n\t\tt.Errorf(\"SetIcon failed: %s\", err)\n\t}\n\n\tvar id int32 = 0\n\terr := wt.addOrUpdateMenuItem(atomic.AddInt32(&id, 1), \"Simple enabled\", false, false)\n\tif err != nil {\n\t\tt.Errorf(\"mergeMenuItem failed: %s\", err)\n\t}\n\terr = wt.addOrUpdateMenuItem(atomic.AddInt32(&id, 1), \"Simple disabled\", true, false)\n\tif err != nil {\n\t\tt.Errorf(\"mergeMenuItem failed: %s\", err)\n\t}\n\terr = wt.addSeparatorMenuItem(atomic.AddInt32(&id, 1))\n\tif err != nil {\n\t\tt.Errorf(\"addSeparatorMenuItem failed: %s\", err)\n\t}\n\terr = wt.addOrUpdateMenuItem(atomic.AddInt32(&id, 1), \"Simple checked enabled\", false, true)\n\tif err != nil {\n\t\tt.Errorf(\"mergeMenuItem failed: %s\", err)\n\t}\n\terr = wt.addOrUpdateMenuItem(atomic.AddInt32(&id, 1), \"Simple checked disabled\", true, true)\n\tif err != nil {\n\t\tt.Errorf(\"mergeMenuItem failed: %s\", err)\n\t}\n\n\terr = wt.hideMenuItem(1)\n\tif err != nil {\n\t\tt.Errorf(\"hideMenuItem failed: %s\", err)\n\t}\n\n\terr = wt.hideMenuItem(100)\n\tif err == nil {\n\t\tt.Error(\"hideMenuItem failed: must return error on invalid item id\")\n\t}\n\n\terr = wt.addOrUpdateMenuItem(2, \"Simple disabled update\", true, false)\n\tif err != nil {\n\t\tt.Errorf(\"mergeMenuItem failed: %s\", err)\n\t}\n\n\ttime.AfterFunc(1*time.Second, quit)\n\n\tm := struct {\n\t\tWindowHandle windows.Handle\n\t\tMessage      uint32\n\t\tWparam       uintptr\n\t\tLparam       uintptr\n\t\tTime         uint32\n\t\tPt           point\n\t}{}\n\tfor {\n\t\tret, _, err := pGetMessage.Call(uintptr(unsafe.Pointer(&m)), 0, 0, 0)\n\t\tres := int32(ret)\n\t\tif res == -1 {\n\t\t\tt.Errorf(\"win32 GetMessage failed: %v\", err)\n\t\t\treturn\n\t\t} else if res == 0 {\n\t\t\tbreak\n\t\t}\n\t\tpTranslateMessage.Call(uintptr(unsafe.Pointer(&m)))\n\t\tpDispatchMessage.Call(uintptr(unsafe.Pointer(&m)))\n\t}\n}\n\nfunc TestWindowsRun(t *testing.T) {\n\tonReady := func() {\n\t\tb, err := ioutil.ReadFile(iconFilePath)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Can't load icon file: %v\", err)\n\t\t}\n\t\tSetIcon(b)\n\t\tSetTitle(\"Test title с кириллицей\")\n\n\t\tbSomeBtn := AddMenuItem(\"Йа кнопко\", \"\")\n\t\tbSomeBtn.Check()\n\t\tAddSeparator()\n\t\tbQuit := AddMenuItem(\"Quit\", \"Quit the whole app\")\n\t\tgo func() {\n\t\t\t<-bQuit.ClickedCh\n\t\t\tt.Log(\"Quit reqested\")\n\t\t\tQuit()\n\t\t}()\n\t\ttime.AfterFunc(1*time.Second, Quit)\n\t}\n\n\tonExit := func() {\n\t\tt.Log(\"Exit success\")\n\t}\n\n\tRun(onReady, onExit)\n}\n"
        },
        {
          "name": "webview_example",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}