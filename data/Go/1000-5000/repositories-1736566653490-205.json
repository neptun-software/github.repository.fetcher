{
  "metadata": {
    "timestamp": 1736566653490,
    "page": 205,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "qustavo/httplab",
      "stars": 4062,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0205078125,
          "content": "*_amd64\n.httplab\ndist"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.201171875,
          "content": "builds:\n  - binary: httplab\n  - main: cmd/httplab/main.go\n    goos:\n      - windows\n      - darwin\n      - linux\narchive:\n  wrap_in_directory: true\n  format_overrides:\n    - goos: windows\n      format: zip\n"
        },
        {
          "name": ".httplab.sample",
          "type": "blob",
          "size": 0.453125,
          "content": "{\n  \"Responses\": {\n    \"ok\": {\n      \"Status\": 200,\n      \"Delay\": 0,\n      \"Body\": \"Hello, World\",\n      \"Headers\": {\n        \"X-Server\": \"HTTPLab\"\n      }\n    },\n    \"create\": {\n      \"Status\": 201,\n      \"Delay\": 1000,\n      \"Body\": \"{\\\"created\\\":\\\"ok\\\"}\",\n      \"Headers\": {\n        \"Content-Type\": \"application/json\"\n      }\n    },\n    \"notfound\": {\n      \"Status\": 404,\n      \"Delay\": 0,\n      \"Body\": \"Page Not Found\",\n      \"Headers\": {\n      }\n    }\n  }\n}"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.326171875,
          "content": "language: go\ngo:\n    - 1.9.x\n    - 1.10.x\n    - 1.11.x\n    - 1.12.x\n    - tip\n\ninstall:\n  - go get golang.org/x/lint/golint\n  - go get -t ./...\n\nscript:\n  - golint $(go list ./... | grep -v /vendor/)\n  - go test $(go list ./...| grep -v /vendor/)\n\nafter_success:\n  - test -n \"$TRAVIS_TAG\" && curl -sL https://git.io/goreleaser | bash\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.255859375,
          "content": "## v0.5.0-dev\n* Configure response with flags\n* Add response auto-update support\n\n## v0.4.0\n* Display CORS request by default (issue #42)\n* Add short flags support (@dnguy078, issue #49)\n* Display request headers in a sorted way on the client (@waleoyediran, issue #47)\n* [bugfix] Location header not rendered to client (@vjeantet, issue #44)\n* CORS support via `-cors` (issue #39)\n* Add graceful shutdown (@maciekmm, issue #66)\n\n## v0.3.0\n* Enable Line Wrapping (issue #38)\n* Add mouse support\n* Save Requests payload into a file (ctrl+f)\n* Compact UI\n* Make ui a package\n* Responses can be deleted with 'd'\n* [fix] Truncate .http file before saving\n* [fix] startup error handling\n* Split cmd and lib\n\n## v0.2.1 (2017-06-04)\n* [fix] Open File dialog bugs\n\n## v0.2.0 (2017-04-04)\n* Ctrl+R reset/clears the request history\n* Toggle response builder\n* Expand body's file path\n* Implement File Body response\n* UI bug fixes & refactor\n* Add -version flag [@pradeepchhetri]\n\n## v0.1.0 (2017-03-02)\n* Parameterized config file.\n  * Use the -config flag to specify a custom config file.\n  * By default, lookup for `.httplab` on the current dir, if not found fallback to `$HOME/.httplab`.\n* Request Scrolling.\n* Display bindings when invoked with -h|help.\n\n## v0.0.1 (2017-02-08)\nFirst Release\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.751953125,
          "content": "# Contributing to HTTPLab\nWelcome and thanks for showing interest in contributing to the project.\nHTTPLab is an opensource so its success depend on your help. Your contributions are going to help many HTTPLab users directly.\n\nThere are many ways you can contribute, here's how:\n\n- [Asking aquestions](#asking-question)\n- [Writing code](#writing-code)\n- [Improving documentation](#improving-documentation)\n- [Reporting Bugs](#reporting-bugs)\n\n## Asking questions\nWhat seems obvious for one person might not be for other, there's different backgrounds, context and way of thinking.\nDon't be shy if something is not clear, just ask.\nWe use the [issue](https://github.com/gchaincl/httplab/issues) tracker for this,\nso please *make sure your question hasn't been replied* before opening a new issue.\n\n## Writing code\nIf you fix a bug, or introduce a new feature, make sure that:\n* **No one else is already working on that**. Review the open pull requests (see [#In Progress](https://github.com/gchaincl/httplab/issues?q=is%3Aopen+is%3Aissue+label%3A%22In+Progress%22) issues)  before start working on it.\n* Whenever is possible, **add tests**\n* Try to follow the conventions\n* Keep the pull request small\n* Document the public API.\n\n## Improving documentation\nDocumentation is as important as code, undocumented features are unexisting features.\nIf you think documentation is insufficient or imprecise, please open a [pull request](https://github.com/gchaincl/httplab/pulls).\nWe treat documentation problems as bugs, so make sure you've read the [Fixing bugs](#fixing-bugs) before.\n\n## Reporting bugs\nBug reports are valuable information, and will help make HTTPLab better.\nBe expressive enough to make developer's job as easy as possible, so make sure the report includes the step to reproduce it.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2017 Gustavo Cha√≠n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.1591796875,
          "content": "![HTTPLAB](https://github.com/gchaincl/httplab/blob/master/images/httplab_logo.png)\n\n[![Build Status](https://travis-ci.org/gchaincl/httplab.svg?branch=master)](https://travis-ci.org/gchaincl/httplab) [![Go Report Card](https://goreportcard.com/badge/github.com/gchaincl/httplab)](https://goreportcard.com/report/gchaincl/httplab) [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](http://makeapullrequest.com)\n\n\nThe interactive web server.\n\nHTTPLabs let you inspect HTTP requests and forge responses.\n\n---\n![screencast](images/screencast.gif)\n\n# Install\n### Golang\n```bash\ngo install github.com/gchaincl/httplab/cmd/httplab@latest\n```\n\n### Archlinux\n```\nyaourt httplab\n```\n\n### ~Snap~ [FIXME](https://github.com/gchaincl/httplab/issues/78)\nOn [systems](https://snapcraft.io/docs/core/install) where snap is supported:\n```\nsnap install httplab\n```\n\n### Binary distribution\nEach release provides pre-built binaries for different architectures, you can download them here: https://github.com/gchaincl/httplab/releases/latest\n\n## Help\n```\nUsage of httplab:\n  -a, --auto-update       Auto-updates response when fields change. (default true)\n  -b, --body string       Specifies the inital response body. (default \"Hello, World\")\n  -c, --config string     Specifies custom config path.\n      --cors              Enable CORS.\n      --cors-display      Display CORS requests. (default true)\n  -d, --delay int         Specifies the initial response delay in ms.\n  -H, --headers strings   Specifies the initial response headers. (default [X-Server:HTTPLab])\n  -p, --port int          Specifies the port where HTTPLab will bind to. (default 10080)\n  -s, --status string     Specifies the initial response status. (default \"200\")\n  -v, --version           Prints current version.\n```\n\n### Key Bindings\nKey                                     | Description\n----------------------------------------|---------------------------------------\n<kbd>Tab</kbd>                          | Next Input\n<kbd>Shift+Tab</kbd>                    | Previous Input\n<kbd>Ctrl+a</kbd>                       | Apply Response changes\n<kbd>Ctrl+r</kbd>                       | Resets Request history\n<kbd>Ctrl+s</kbd>                       | Save Response as\n<kbd>Ctrl+f</kbd>                       | Save Request as\n<kbd>Ctrl+l</kbd>                       | Toggle Responses list\n<kbd>Ctrl+t</kbd>                       | Toggle Response builder\n<kbd>Ctrl+o</kbd>                       | Open Body file\n<kbd>Ctrl+b</kbd>                       | Switch Body mode\n<kbd>Ctrl+h</kbd>                       | Toggle Help\n<kbd>Ctrl+w</kbd>                       | Toggle line wrapping\n<kbd>q</kbd>                            | Close popup\n<kbd>PgUp</kbd>                         | Previous Request\n<kbd>PgDown</kbd>                       | Next Request\n<kbd>Ctrl+c</kbd>                       | Quit\n\nHTTPLab uses file to store pre-built responses, it will look for a file called `.httplab` on the current directory if not found it will fallback to `$HOME`.\nA sample file can be found [here](https://github.com/gchaincl/httplab/blob/master/.httplab.sample).\n\n_HTTPLab is heavily inspired by [wuzz](https://github.com/asciimoo/wuzz)_\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "dump.go",
          "type": "blob",
          "size": 1.6259765625,
          "content": "package httplab\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n)\n\nvar decolorizeRegex = regexp.MustCompile(\"\\x1b\\\\[0;\\\\d+m\")\n\n// Decolorize remove the color escape sequences from a []byte encoded string\nfunc Decolorize(s []byte) []byte {\n\treturn decolorizeRegex.ReplaceAll(s, nil)\n}\n\nfunc valueOrDefault(value, def string) string {\n\tif value == \"\" {\n\t\treturn def\n\t}\n\treturn value\n}\n\nfunc withColor(color int, text string) string {\n\treturn fmt.Sprintf(\"\\x1b[0;%dm%s\\x1b[0;0m\", color, text)\n}\n\nfunc writeBody(buf *bytes.Buffer, req *http.Request) error {\n\tbody, err := io.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(body) > 0 {\n\t\tbuf.WriteRune('\\n')\n\t}\n\n\tif strings.Contains(req.Header.Get(\"Content-Type\"), \"application/json\") {\n\t\tif err := json.Indent(buf, body, \"\", \"  \"); err == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t_, err = buf.Write(body)\n\treturn err\n}\n\n// DumpRequest pretty prints an http.Request\nfunc DumpRequest(req *http.Request) ([]byte, error) {\n\tbuf := bytes.NewBuffer(nil)\n\n\treqURI := req.RequestURI\n\tif reqURI == \"\" {\n\t\treqURI = req.URL.RequestURI()\n\t}\n\n\tfmt.Fprintf(buf, \"%s %s %s/%d.%d\\n\",\n\t\twithColor(35, valueOrDefault(req.Method, \"GET\")),\n\t\treqURI,\n\t\twithColor(35, \"HTTP\"),\n\t\treq.ProtoMajor,\n\t\treq.ProtoMinor,\n\t)\n\n\tkeys := sortedHeaderKeys(req)\n\tfor _, key := range keys {\n\t\tval := req.Header.Get(key)\n\t\tfmt.Fprintf(buf, \"%s: %s\\n\", withColor(31, key), withColor(32, val))\n\t}\n\n\terr := writeBody(buf, req)\n\treturn buf.Bytes(), err\n}\n\nfunc sortedHeaderKeys(req *http.Request) []string {\n\tvar keys []string\n\tfor k := range req.Header {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\treturn keys\n}\n"
        },
        {
          "name": "dump_test.go",
          "type": "blob",
          "size": 1.521484375,
          "content": "package httplab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestDumpRequestWithJSON(t *testing.T) {\n\tt.Run(\"should be indented\", func(t *testing.T) {\n\t\treq, _ := http.NewRequest(\"GET\", \"/withJSON\", bytes.NewBuffer(\n\t\t\t[]byte(`{\"foo\": \"bar\", \"a\": [1,2,3]}`),\n\t\t))\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t\tbuf, err := DumpRequest(req)\n\t\trequire.NoError(t, err)\n\t\tfmt.Printf(\"%s\\n\", buf)\n\t})\n\n\tt.Run(\"should be displayed as is\", func(t *testing.T) {\n\t\treq, _ := http.NewRequest(\"GET\", \"/invalidJSON\", bytes.NewBuffer(\n\t\t\t[]byte(`invalid json`),\n\t\t))\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t\tbuf, err := DumpRequest(req)\n\t\trequire.NoError(t, err)\n\t\tfmt.Printf(\"%s\\n\", buf)\n\t})\n}\n\nfunc TestDumpRequestHeaders(t *testing.T) {\n\tt.Run(\"request headers should be dumped in sorted order\", func(t *testing.T) {\n\n\t\tkeys := []string{\"B\", \"A\", \"C\", \"D\", \"E\", \"F\", \"H\", \"G\", \"I\"}\n\t\treq, _ := http.NewRequest(\"GET\", \"/\", bytes.NewBuffer(nil))\n\t\tfor _, k := range keys {\n\t\t\treq.Header.Set(k, \"\")\n\t\t}\n\n\t\tbuf, err := DumpRequest(req)\n\t\trequire.NoError(t, err)\n\t\tsort.Strings(keys)\n\n\t\tstartLine := \"GET / HTTP/1.1\\n\"\n\t\tresponse := startLine + strings.Join(keys, \": \\n\") + \": \\n\"\n\n\t\tassert.Contains(t, response, string(Decolorize(buf)))\n\t})\n}\n\nfunc TestDecolorization(t *testing.T) {\n\tfor i := range [107]struct{}{} {\n\t\ttext := \"Some Text\"\n\t\tnocolor := Decolorize([]byte(withColor(i, text)))\n\t\tassert.Equal(t, text, string(nocolor))\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5087890625,
          "content": "module github.com/gchaincl/httplab\n\ngo 1.20\n\nrequire (\n\tgithub.com/jroimartin/gocui v0.5.0\n\tgithub.com/rs/cors v0.0.0-20170529160756-bf64c5349c0f\n\tgithub.com/spf13/pflag v0.0.0-20170901120850-7aff26db30c1\n\tgithub.com/stretchr/testify v0.0.0-20170130113145-4d4bfba8f1d1\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.14 // indirect\n\tgithub.com/nsf/termbox-go v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rivo/uniseg v0.4.4 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.82421875,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/jroimartin/gocui v0.5.0 h1:DCZc97zY9dMnHXJSJLLmx9VqiEnAj0yh0eTNpuEtG/4=\ngithub.com/jroimartin/gocui v0.5.0/go.mod h1:l7Hz8DoYoL6NoYnlnaX6XCNR62G7J5FfSW5jEogzaxE=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.14 h1:+xnbZSEeDbOIg5/mE6JF0w6n9duR1l3/WmbinWVwUuU=\ngithub.com/mattn/go-runewidth v0.0.14/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/nsf/termbox-go v1.1.1 h1:nksUPLCb73Q++DwbYUBEglYBRPZyoXJdrj5L+TkjyZY=\ngithub.com/nsf/termbox-go v1.1.1/go.mod h1:T0cTdVuOwf7pHQNtfhnEbzHbcNyCEcVU4YPpouCbVxo=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.4 h1:8TfxU8dW6PdqD27gjM8MVNuicgxIjxpm4K7x4jp8sis=\ngithub.com/rivo/uniseg v0.4.4/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/rs/cors v0.0.0-20170529160756-bf64c5349c0f h1:XQnRgDvz3XfY8aX6ydJmG8l5BEbLGL5OVs6QvP2zVC8=\ngithub.com/rs/cors v0.0.0-20170529160756-bf64c5349c0f/go.mod h1:gFx+x8UowdsKA9AchylcLynDq+nNFfI8FkUZdN/jGCU=\ngithub.com/spf13/pflag v0.0.0-20170901120850-7aff26db30c1 h1:TRYBd3V/2jfUifd2vqT9S1O6mTgEwmgxgfRpI5zx6FU=\ngithub.com/spf13/pflag v0.0.0-20170901120850-7aff26db30c1/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/stretchr/testify v0.0.0-20170130113145-4d4bfba8f1d1 h1:Zx8Rp9ozC4FPFxfEKRSUu8+Ay3sZxEUZ7JrCWMbGgvE=\ngithub.com/stretchr/testify v0.0.0-20170130113145-4d4bfba8f1d1/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 7.6748046875,
          "content": "package httplab\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// BodyMode represent the current Body mode\ntype BodyMode uint\n\n// String to satisfy interface fmt.Stringer\nfunc (m BodyMode) String() string {\n\tswitch m {\n\tcase BodyInput:\n\t\treturn \"Input\"\n\tcase BodyFile:\n\t\treturn \"File\"\n\t}\n\treturn \"\"\n}\n\nconst (\n\t// BodyInput takes the body input from input box\n\tBodyInput BodyMode = iota + 1\n\t// BodyFile takes  the body input from a file\n\tBodyFile\n)\n\n// Body is our response body content, that will either reference an local file or a runtime-supplied []byte.\ntype Body struct {\n\tMode  BodyMode\n\tInput []byte\n\tFile  *os.File\n}\n\n// Payload reads out a []byte payload according to it's configuration in Body.BodyMode.\nfunc (body *Body) Payload() []byte {\n\tswitch body.Mode {\n\tcase BodyInput:\n\t\treturn body.Input\n\tcase BodyFile:\n\t\tif body.File == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// XXX: Handle this error\n\t\tbytes, _ := io.ReadAll(body.File)\n\t\tbody.File.Seek(0, 0)\n\t\treturn bytes\n\t}\n\treturn nil\n}\n\n// Info returns some basic info on the body.\nfunc (body *Body) Info() []byte {\n\tswitch body.Mode {\n\tcase BodyInput:\n\t\treturn body.Input\n\tcase BodyFile:\n\t\tif body.File == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// XXX: Handle this error\n\t\tstats, _ := body.File.Stat()\n\t\tw := &bytes.Buffer{}\n\t\tfmt.Fprintf(w, \"file: %s\\n\", body.File.Name())\n\t\tfmt.Fprintf(w, \"size: %d bytes\\n\", stats.Size())\n\t\tfmt.Fprintf(w, \"perm: %s\\n\", stats.Mode())\n\t\treturn w.Bytes()\n\t}\n\treturn nil\n}\n\n// SetFile set a new source file for the body, if it exists.\nfunc (body *Body) SetFile(path string) error {\n\tfile, err := os.Open(ExpandPath(path))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbody.File = file\n\tbody.Mode = BodyFile\n\treturn nil\n}\n\n// Response is the the preconfigured HTTP response that will be returned to the client.\ntype Response struct {\n\tStatus  int\n\tHeaders http.Header\n\tBody    Body\n\tDelay   time.Duration\n}\n\n// UnmarshalJSON inflates the Response from []byte representing JSON.\nfunc (r *Response) UnmarshalJSON(data []byte) error {\n\ttype alias Response\n\tv := struct {\n\t\talias\n\t\tBody    string\n\t\tFile    string\n\t\tHeaders map[string]string\n\t}{}\n\tif err := json.Unmarshal(data, &v); err != nil {\n\t\treturn err\n\t}\n\n\tr.Status = v.Status\n\tr.Delay = v.Delay\n\tr.Body.Input = []byte(v.Body)\n\tif v.File != \"\" {\n\t\tif err := r.Body.SetFile(v.File); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif r.Body.File != nil {\n\t\tr.Body.Mode = BodyFile\n\t} else {\n\t\tr.Body.Mode = BodyInput\n\t}\n\n\tif r.Headers == nil {\n\t\tr.Headers = http.Header{}\n\t}\n\tfor key := range v.Headers {\n\t\tr.Headers.Set(key, v.Headers[key])\n\t}\n\n\treturn nil\n}\n\n// MarshalJSON serializes the response into a JSON []byte.\nfunc (r *Response) MarshalJSON() ([]byte, error) {\n\ttype alias Response\n\tv := struct {\n\t\talias\n\t\tBody    string\n\t\tFile    string\n\t\tHeaders map[string]string\n\t}{\n\t\tHeaders: make(map[string]string),\n\t}\n\n\tv.Delay = time.Duration(r.Delay) / time.Millisecond\n\tv.Status = r.Status\n\n\tif len(r.Body.Input) > 0 {\n\t\tv.Body = string(r.Body.Input)\n\t}\n\n\tif r.Body.File != nil {\n\t\tv.File = r.Body.File.Name()\n\t}\n\n\tfor key := range r.Headers {\n\t\tv.Headers[key] = r.Headers.Get(key)\n\t}\n\n\treturn json.MarshalIndent(v, \"\", \"  \")\n}\n\n// NewResponse configures a new response. An empty status will be interpreted as 200 OK.\nfunc NewResponse(status, headers, body string) (*Response, error) {\n\t// Parse Status\n\tstatus = strings.Trim(status, \" \\r\\n\")\n\tif status == \"\" {\n\t\tstatus = \"200\"\n\t}\n\tcode, err := strconv.Atoi(status)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Status: %v\", err)\n\t}\n\n\tif code < 100 || code > 599 {\n\t\treturn nil, fmt.Errorf(\"Status should be between 100 and 599\")\n\t}\n\n\t// Parse Headers\n\thdr := http.Header{}\n\tlines := strings.Split(headers, \"\\n\")\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tkv := strings.SplitN(line, \":\", 2)\n\t\tif len(kv) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tkey := strings.TrimSpace(kv[0])\n\t\tval := strings.TrimSpace(kv[1])\n\t\thdr.Set(key, val)\n\t}\n\n\treturn &Response{\n\t\tStatus:  code,\n\t\tHeaders: hdr,\n\t\tBody: Body{\n\t\t\tMode:  BodyInput,\n\t\t\tInput: []byte(body),\n\t\t},\n\t}, nil\n}\n\n// Write flushes the body into the ResponseWriter, hence sending it over the wire.\nfunc (r *Response) Write(w http.ResponseWriter) error {\n\tfor key := range r.Headers {\n\t\tw.Header().Set(key, r.Headers.Get(key))\n\t}\n\tw.WriteHeader(r.Status)\n\t_, err := w.Write(r.Body.Payload())\n\n\treturn err\n}\n\n// ResponsesList holds the multiple configured responses.\ntype ResponsesList struct {\n\tList    map[string]*Response\n\tkeys    []string\n\tcurrent int\n}\n\n// NewResponsesList creates a new empty response list and returns it.\nfunc NewResponsesList() *ResponsesList {\n\treturn (&ResponsesList{}).reset()\n}\n\nfunc (rl *ResponsesList) reset() *ResponsesList {\n\trl.current = 0\n\trl.List = make(map[string]*Response)\n\trl.keys = nil\n\treturn rl\n}\n\nfunc (rl *ResponsesList) load(path string) (map[string]*Response, error) {\n\tf, err := openConfigFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trs := struct {\n\t\tResponses map[string]*Response\n\t}{}\n\n\tif err := json.NewDecoder(f).Decode(&rs); err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn rs.Responses, nil\n}\n\n// Load loads a response list from a local JSON document.\nfunc (rl *ResponsesList) Load(path string) error {\n\trs, err := rl.load(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trl.reset()\n\tif rs != nil {\n\t\trl.List = rs\n\t}\n\n\tfor key := range rs {\n\t\trl.keys = append(rl.keys, key)\n\t}\n\tsort.Strings(rl.keys)\n\n\treturn nil\n}\n\n// Save saves the current response list to a JSON document on local disk.\nfunc (rl *ResponsesList) Save(path string) error {\n\tf, err := openConfigFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tstat, err := f.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := f.Truncate(stat.Size()); err != nil {\n\t\treturn err\n\t}\n\n\tbuf, err := json.MarshalIndent(struct {\n\t\tResponses map[string]*Response\n\t}{rl.List}, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := f.Write(buf); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Next iterates to the next item in the response list.\nfunc (rl *ResponsesList) Next() { rl.current = (rl.current + 1) % len(rl.keys) }\n\n// Prev iterates to the previous item in the response list.\nfunc (rl *ResponsesList) Prev() { rl.current = (rl.current - 1 + len(rl.keys)) % len(rl.keys) }\n\n// Cur retrieves the current response from the response list.\nfunc (rl *ResponsesList) Cur() *Response { return rl.List[rl.keys[rl.current]] }\n\n// Index retrieves the index of the current item in the response list.\nfunc (rl *ResponsesList) Index() int { return rl.current }\n\n// Len reports the length of the response list.\nfunc (rl *ResponsesList) Len() int { return len(rl.keys) }\n\n// Keys retrieves an []string of all keys in the response list.\nfunc (rl *ResponsesList) Keys() []string { return rl.keys }\n\n// Get retrieves a specific response by name from the response list.\nfunc (rl *ResponsesList) Get(key string) *Response { return rl.List[key] }\n\n// Add appends a response item to the list. You need to supply a key for the item.\nfunc (rl *ResponsesList) Add(key string, r *Response) *ResponsesList {\n\trl.keys = append(rl.keys, key)\n\tsort.Strings(rl.keys)\n\trl.List[key] = r\n\treturn rl\n}\n\n// Del removes an item spceified by its key from the response list. It returns false if the item didn't exist at all.\nfunc (rl *ResponsesList) Del(key string) bool {\n\tif _, ok := rl.List[key]; !ok {\n\t\treturn false\n\t}\n\tdelete(rl.List, key)\n\n\ti := sort.SearchStrings(rl.keys, key)\n\trl.keys = append(rl.keys[:i], rl.keys[i+1:]...)\n\n\treturn true\n}\n\n// ExpandPath expands a given path by replacing '~' with $HOME of the current user.\nfunc ExpandPath(path string) string {\n\tif path[0] == '~' {\n\t\tpath = \"$HOME\" + path[1:]\n\t}\n\treturn os.ExpandEnv(path)\n}\n\nfunc openConfigFile(path string) (*os.File, error) {\n\treturn os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0666)\n}\n"
        },
        {
          "name": "response_test.go",
          "type": "blob",
          "size": 4.455078125,
          "content": "package httplab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestResponseStatus(t *testing.T) {\n\t// only status between 100 and 599 are valid\n\tfor i := 100; i < 600; i++ {\n\t\tstatus := strconv.Itoa(i)\n\t\t_, err := NewResponse(status, \"\", \"\")\n\t\tassert.NoError(t, err)\n\t}\n\n\tfor _, status := range []string{\"600\", \"99\", \"foo\", \"2xx\"} {\n\t\t_, err := NewResponse(status, \"\", \"\")\n\t\tassert.Error(t, err, fmt.Sprintf(\"status '%s' should be invalid\", status))\n\t}\n\n\tfor _, format := range []string{\" %d \", \"%d\\n\", \" %d \\n\", \"%d\\r\\r\"} {\n\t\tstatus := fmt.Sprintf(format, 200)\n\t\t_, err := NewResponse(status, \"\", \"\")\n\t\tassert.NoError(t, err)\n\t}\n\n\t// default value\n\tt.Run(\"Default Value\", func(t *testing.T) {\n\t\tresp, err := NewResponse(\"\", \"\", \"\")\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, 200, resp.Status)\n\t})\n}\n\nfunc TestResponseHeaders(t *testing.T) {\n\theaders := `\n\tContent-Type: application/json\n\tX-MyHeader: value\n\tLocation: http://foo.bar:8000\n\tX-Empty: \n\tInvalid\n\t`\n\n\tresp, err := NewResponse(\"\", headers, \"\")\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"application/json\", resp.Headers.Get(\"Content-Type\"))\n\tassert.Equal(t, \"value\", resp.Headers.Get(\"X-MyHeader\"))\n\tassert.Equal(t, \"\", resp.Headers.Get(\"X-Empty\"))\n\tassert.Equal(t, \"http://foo.bar:8000\", resp.Headers.Get(\"Location\"))\n\tassert.Contains(t, resp.Headers, \"X-Empty\")\n\tassert.NotContains(t, resp.Headers, \"Invalid\")\n}\n\nfunc TestResponseWrite(t *testing.T) {\n\trec := httptest.NewRecorder()\n\tresp := &Response{\n\t\tStatus: 201,\n\t\tHeaders: http.Header{\n\t\t\t\"X-Foo\": []string{\"bar\"},\n\t\t},\n\t\tBody: Body{\n\t\t\tInput: []byte(\"Hello, World\"),\n\t\t},\n\t}\n\n\tresp.Write(rec)\n\n\tassert.Equal(t, resp.Status, rec.Code)\n\tassert.Equal(t, resp.Headers.Get(\"X-Foo\"), rec.Header().Get(\"X-Foo\"))\n\tassert.Equal(t, resp.Body.Payload(), rec.Body.Bytes())\n}\n\nfunc TestResponsesList(t *testing.T) {\n\trl := NewResponsesList()\n\trl.Add(\"200\", &Response{Status: 200}).\n\t\tAdd(\"201\", &Response{Status: 201}).\n\t\tAdd(\"404\", &Response{Status: 404}).\n\t\tAdd(\"500\", &Response{Status: 500})\n\n\tt.Run(\"Len()\", func(t *testing.T) {\n\t\tassert.Equal(t, 4, rl.Len())\n\t})\n\n\tt.Run(\"Get()\", func(t *testing.T) {\n\t\tassert.Equal(t, 200, rl.Get(\"200\").Status)\n\t\tassert.Equal(t, 201, rl.Get(\"201\").Status)\n\t\tassert.Equal(t, 404, rl.Get(\"404\").Status)\n\t\tassert.Equal(t, 500, rl.Get(\"500\").Status)\n\t})\n\n\tt.Run(\"Indexing\", func(t *testing.T) {\n\t\tassert.Equal(t, 200, rl.Cur().Status)\n\t\tassert.Equal(t, 0, rl.Index())\n\n\t\trl.Next()\n\t\tassert.Equal(t, 201, rl.Cur().Status)\n\t\tassert.Equal(t, 1, rl.Index())\n\n\t\trl.Next()\n\t\tassert.Equal(t, 404, rl.Cur().Status)\n\t\tassert.Equal(t, 2, rl.Index())\n\n\t\trl.Next()\n\t\tassert.Equal(t, 500, rl.Cur().Status)\n\t\tassert.Equal(t, 3, rl.Index())\n\n\t\trl.Next()\n\t\tassert.Equal(t, 200, rl.Cur().Status)\n\t\tassert.Equal(t, 0, rl.Index())\n\n\t\trl.Prev()\n\t\tassert.Equal(t, 500, rl.Cur().Status)\n\t\tassert.Equal(t, 3, rl.Index())\n\n\t\trl.Prev()\n\t\tassert.Equal(t, 404, rl.Cur().Status)\n\t\tassert.Equal(t, 2, rl.Index())\n\t})\n\n\tt.Run(\"Del()\", func(t *testing.T) {\n\t\tfor _, status := range []string{\"200\", \"201\", \"404\", \"500\"} {\n\t\t\tassert.NotNil(t, rl.Get(status))\n\t\t\trl.Del(status)\n\t\t\tassert.Nil(t, rl.Get(status))\n\t\t}\n\t})\n}\n\nfunc TestLoadFromJSON(t *testing.T) {\n\trl := NewResponsesList()\n\trequire.NoError(t, rl.Load(\"./testdata/httplab.json\"))\n\n\tr := rl.Get(\"t1\")\n\trequire.NotNil(t, r)\n\tassert.Equal(t, 200, r.Status)\n\tassert.Equal(t, time.Duration(1000), r.Delay)\n\tassert.Equal(t, \"value\", r.Headers.Get(\"X-MyHeader\"))\n\n\tr.Body.Mode = BodyInput\n\tassert.Equal(t, []byte(\"xxx\"), r.Body.Payload())\n\tassert.Equal(t, []byte(\"xxx\"), r.Body.Info())\n\n\tr.Body.Mode = BodyFile\n\tassert.Equal(t, []byte(\"<html></html>\"), r.Body.Payload())\n\n\tt.Run(\"When config file is empty\", func(t *testing.T) {\n\t\tpath := string(time.Now().UnixNano())\n\t\tdefer os.Remove(path)\n\n\t\trequire.NoError(t, rl.Load(path))\n\t\tassert.Equal(t, 0, rl.Len())\n\n\t\t// file has to be created\n\t\t_, err := os.Stat(path)\n\t\tassert.NoError(t, err)\n\t})\n}\n\nfunc TestExpandPathExpansion(t *testing.T) {\n\tdefer os.Setenv(\"HOME\", os.Getenv(\"HOME\"))\n\n\tfor key, val := range map[string]string{\n\t\t\"HOME\": \"/home/gchaincl\",\n\t\t\"ENV1\": \"env1\",\n\t\t\"ENV2\": \"env2\",\n\t} {\n\t\tos.Setenv(key, val)\n\t}\n\n\tpaths := []struct {\n\t\texpr     string\n\t\texpected string\n\t}{\n\t\t{\"~/foo\", \"/home/gchaincl/foo\"},\n\t\t{\"./foo/~/bar\", \"./foo/~/bar\"},\n\t\t{\"/$ENV1/foo/$ENV2\", \"/env1/foo/env2\"},\n\t\t{\"$NOTDEFINED/foo\", \"/foo\"},\n\t}\n\n\tfor _, path := range paths {\n\t\tassert.Equal(t, path.expected, ExpandPath(path.expr))\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "ui",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}