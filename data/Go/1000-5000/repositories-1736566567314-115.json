{
  "metadata": {
    "timestamp": 1736566567314,
    "page": 115,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "faiface/pixel",
      "stars": 4468,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01171875,
          "content": "test\n.vscode"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.6650390625,
          "content": "language: go\n# https://github.com/golang/go/issues/31293\ndist: xenial\nsudo: false\naddons:\n    apt:\n        packages:\n            - xorg-dev\n            - libx11-dev\n            - libxrandr-dev\n            - libxinerama-dev\n            - libxcursor-dev\n            - libxi-dev\n            - libopenal-dev\n            - libasound2-dev\n            - libgl1-mesa-dev\n\nservices:\n    - xvfb\n\nenv:\n    - GO111MODULE=on\n\ngo:\n    - tip\n    - 1.12.x\n\ninstall:\n    - # Do nothing. This is needed to prevent the default install action\n      # \"go get -t -v ./...\" from happening here because we want it to happen\n      # inside script step.\n\nscript:\n    - go test -v -race -mod=readonly ./...\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.5166015625,
          "content": "# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n- Add AnchorPos struct and functions #252\n- Add Clipboard Support\n- Fix SIGSEGV on text.NewAtlas if glyph absent \n- Use slice for range in Drawer.Dirty(), to improve performance\n- GLTriangle's fragment shader is used when rendered by the Canvas.\n- Add MSAA support\n\n## [v0.10.0] 2020-08-22\n- Add AnchorPos struct and functions\n- Gamepad API added\n- Support setting an initial window position\n- Support hiding the window initially\n- Support creating maximized windows\n- Support waiting for events to reduce CPU load\n- Adding clipping rectangle support in GLTriangles\n\n## [v0.10.0-beta] 2020-05-10\n- Add `WindowConfig.TransparentFramebuffer` option to support window transparency onto the background\n- Fixed Line intersects failing on lines passing through (0, 0)\n\n## [v0.10.0-alpha] 2020-05-08\n- Upgrade to GLFW 3.3! :tada:\n  - Closes https://github.com/faiface/pixel/issues/137\n- Add support for glfw's DisableCursor\n  - Closes https://github.com/faiface/pixel/issues/213\n\n## [v0.9.0] - 2020-05-02\n- Added feature from https://github.com/faiface/pixel/pull/219\n  - Exposing Window.SwapBuffers so buffers can be swapped without polling input\n- Add more examples\n- Add position as out variable from vertex shader\n- Add experimental joystick support\n- Add mouse cursor operations\n- Add `Vec.Floor(…)` function\n- Add circle geometry\n- Fix `Matrix.Unproject(…)` for rotated matrix\n- Add 2D Line geometry\n- Add floating point round error correction\n- Performance improvements\n- Fix race condition in `NewGLTriangles(…)`\n- Add `TriangleData` benchmarks and improvements\n- Add zero rectangle variable for utility and consistency\n- Add support for Go Modules\n- Add `NoIconify` and `AlwaysOnTop` window hints\n\n\n## [v0.8.0] - 2018-10-10\nChangelog for this and older versions can be found on the corresponding [GitHub\nreleases](https://github.com/faiface/pixel/releases).\n\n[Unreleased]: https://github.com/faiface/pixel/compare/v0.10.0...HEAD\n[v0.10.0]: https://github.com/faiface/pixel/compare/v0.10.0-beta...v0.10.0\n[v0.10.0-beta]: https://github.com/faiface/pixel/compare/v0.10.0-alpha...v0.10.0-beta\n[v0.10.0-alpha]: https://github.com/faiface/pixel/compare/v0.9.0...v0.10.0-alpha\n[v0.9.0]: https://github.com/faiface/pixel/compare/v0.8.0...v0.9.0\n[v0.8.0]: https://github.com/faiface/pixel/releases/tag/v0.8.0\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.12890625,
          "content": "# Contributing to Pixel\n\n:tada: Hi! I'm really glad you're considering contributing to Pixel! :tada:\n\n## Here are a few ways you can contribute\n\n1. **Make a community example** and place it inside the `community` folder of the [examples repository][examples].\n2. **Add tests**. There only few tests in Pixel at the moment. Take a look at them and make some similar.\n3. **Add a small feature or an improvement**. Feel like some small feature is missing? Just make a PR. Be ready that I might reject it, though, if I don't find it particularly appealing.\n4. **Join the big development** by joining the discussion on our [Discord Server](https://discord.gg/q2DK4MP), where we can discuss bigger changes and implement them after that.\n\n## How to make a pull request\n\nGo gives you a nice surprise when attempting to make a PR on Github. The thing is, that when user _xyz_ forks Pixel on Github, it ends up in _github.com/xyz/pixel_, which fucks up your import paths. Here's how you deal with that: https://www.reddit.com/r/golang/comments/2jdcw1/how_do_you_deal_with_github_forking/.\n\n[examples]: https://github.com/faiface/pixel-examples/tree/master/community\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2016 Michal Štrba\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.763671875,
          "content": "# \\*\\*\\*\\*\\*NOTICE\\*\\*\\*\\*\\* \n\nThis repo is not under active development anymore and has been archived. Continued development has been migrated to [Pixel2](https://github.com/gopxl/pixel). A big thank you to [faiface](https://github.com/faiface) for creating this awesome library and for all the hard work put into it. We encourage old and new users to check out the new repo and contribute to it.\n\n\n\n<p align=\"center\"><img src=\"logo/LOGOTYPE-HORIZONTAL-BLUE.png\"></p>\n\n# Pixel [![Build Status](https://travis-ci.org/faiface/pixel.svg?branch=master)](https://travis-ci.org/faiface/pixel) [![GoDoc](https://godoc.org/github.com/faiface/pixel?status.svg)](https://godoc.org/github.com/faiface/pixel) [![Go Report Card](https://goreportcard.com/badge/github.com/faiface/pixel)](https://goreportcard.com/report/github.com/faiface/pixel) [![Join the chat at https://gitter.im/pixellib/Lobby](https://badges.gitter.im/pixellib/Lobby.svg)](https://gitter.im/pixellib/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![Discord Chat](https://img.shields.io/discord/699679031603494954)](https://discord.gg/q2DK4MP)  \n\nA hand-crafted 2D game library in Go. Take a look into the [features](#features) to see what it can\ndo.\n\n```\ngo get github.com/faiface/pixel\n```\n\nIf you are using Modules (Go 1.11 or higher) and want a mutable copy of the source code:\n\n```\ngit clone https://github.com/faiface/pixel # clone outside of $GOPATH\ncd pixel\ngo install ./...\n```\n\nSee [requirements](#requirements) for the list of libraries necessary for compilation.\n\nAll significant changes are documented in [CHANGELOG.md](CHANGELOG.md).\n\n## Tutorial\n\nThe [Wiki of this repo](https://github.com/faiface/pixel/wiki) contains an extensive tutorial\ncovering several topics of Pixel. Here's the content of the tutorial parts so far:\n\n- [Creating a Window](https://github.com/faiface/pixel/wiki/Creating-a-Window)\n- [Drawing a Sprite](https://github.com/faiface/pixel/wiki/Drawing-a-Sprite)\n- [Moving, scaling and rotating with Matrix](https://github.com/faiface/pixel/wiki/Moving,-scaling-and-rotating-with-Matrix)\n- [Pressing keys and clicking mouse](https://github.com/faiface/pixel/wiki/Pressing-keys-and-clicking-mouse)\n- [Drawing efficiently with Batch](https://github.com/faiface/pixel/wiki/Drawing-efficiently-with-Batch)\n- [Drawing shapes with IMDraw](https://github.com/faiface/pixel/wiki/Drawing-shapes-with-IMDraw)\n- [Typing text on the screen](https://github.com/faiface/pixel/wiki/Typing-text-on-the-screen)\n- [Using a custom fragment shader](https://github.com/faiface/pixel/wiki/Using-a-custom-fragment-shader)\n\n## [Examples](https://github.com/faiface/pixel-examples)\n\nThe [examples](https://github.com/faiface/pixel-examples) repository contains a few\nexamples demonstrating Pixel's functionality.\n\n**To run an example**, navigate to it's directory, then `go run` the `main.go` file. For example:\n\n```\n$ cd pixel-examples/platformer\n$ go run main.go\n```\n\nHere are some screenshots from the examples!\n\n| [Lights](https://github.com/faiface/pixel-examples/blob/master/lights) | [Platformer](https://github.com/faiface/pixel-examples/blob/master/platformer) |\n| --- | --- |\n| ![Lights](https://github.com/faiface/pixel-examples/blob/master/lights/screenshot.png) | ![Platformer](https://github.com/faiface/pixel-examples/blob/master/platformer/screenshot.png) |\n\n| [Smoke](https://github.com/faiface/pixel-examples/blob/master/smoke) | [Typewriter](https://github.com/faiface/pixel-examples/blob/master/typewriter) |\n| --- | --- |\n| ![Smoke](https://github.com/faiface/pixel-examples/blob/master/smoke/screenshot.png) | ![Typewriter](https://github.com/faiface/pixel-examples/blob/master/typewriter/screenshot.png) |\n\n| [Raycaster](https://github.com/faiface/pixel-examples/blob/master/community/raycaster) | [Gizmo](https://github.com/Lallassu/gizmo) |\n| --- | --- |\n| ![Raycaster](https://github.com/faiface/pixel-examples/blob/master/community/raycaster/screenshot.png) | ![Gizmo](https://github.com/Lallassu/gizmo/blob/master/preview.png) |\n\n## Features\n\nHere's the list of the main features in Pixel. Although Pixel is still under heavy development,\n**there should be no major breakage in the API.** This is not a 100% guarantee, though.\n\n- Fast 2D graphics\n  - Sprites\n  - Primitive shapes with immediate mode style\n    [IMDraw](https://github.com/faiface/pixel/wiki/Drawing-shapes-with-IMDraw) (circles, rectangles,\n    lines, ...)\n  - Optimized drawing with [Batch](https://github.com/faiface/pixel/wiki/Drawing-efficiently-with-Batch)\n  - Text drawing with [text](https://godoc.org/github.com/faiface/pixel/text) package\n- Audio through a separate [Beep](https://github.com/faiface/beep) library.\n- Simple and convenient API\n  - Drawing a sprite to a window is as simple as `sprite.Draw(window, matrix)`\n  - Wanna know where the center of a window is? `window.Bounds().Center()`\n  - [...](https://godoc.org/github.com/faiface/pixel)\n- Full documentation and tutorial\n- Works on Linux, macOS and Windows\n- Window creation and manipulation (resizing, fullscreen, multiple windows, ...)\n- Keyboard (key presses, text input) and mouse input without events\n- Well integrated with the Go standard library\n  - Use `\"image\"` package for loading pictures\n  - Use `\"time\"` package for measuring delta time and FPS\n  - Use `\"image/color\"` for colors, or use Pixel's own `color.Color` format, which supports easy\n    multiplication and a few more features\n  - Pixel uses `float64` throughout the library, compatible with `\"math\"` package\n- Geometry transformations with\n  [Matrix](https://github.com/faiface/pixel/wiki/Moving,-scaling-and-rotating-with-Matrix)\n  - Moving, scaling, rotating\n  - Easy camera implementation\n- Off-screen drawing to Canvas or any other target (Batch, IMDraw, ...)\n- Fully garbage collected, no `Close` or `Dispose` methods\n- Full [Porter-Duff](http://ssp.impulsetrain.com/porterduff.html) composition, which enables\n  - 2D lighting\n  - Cutting holes into objects\n  - Much more...\n- Pixel let's you draw stuff and do your job, it doesn't impose any particular style or paradigm\n- Platform and backend independent [core](https://godoc.org/github.com/faiface/pixel)\n- Core Target/Triangles/Picture pattern makes it easy to create new drawing targets that do\n  arbitrarily crazy stuff (e.g. graphical effects)\n- Small codebase, ~5K lines of code, including the backend [glhf](https://github.com/faiface/glhf)\n  package\n\n ## Related repositories\n\n Here are some packages which use Pixel:\n - [TilePix](https://github.com/bcvery1/tilepix) Makes handling TMX files built with [Tiled](https://www.mapeditor.org/) trivially easy to work with using Pixel.\n - [spriteplus](https://github.com/cebarks/spriteplus) Basic `SpriteSheet` and `Animation` implementations\n - [PixelUI](https://github.com/dusk125/pixelui) Imgui-based GUIs for Pixel\n - [pixelutils](https://github.com/dusk125/pixelutils) Variety of game related utilities (sprite packer, id generator, ticker, sprite loader, voronoia diagrams)\n\n## Missing features\n\nPixel is in development and still missing few critical features. Here're the most critical ones.\n\n- ~~Audio~~\n- ~~Drawing text~~\n- Antialiasing (filtering is supported, though)\n- ~~Advanced window manipulation (cursor hiding, window icon, ...)~~\n- Better support for Hi-DPI displays\n- Mobile (and perhaps HTML5?) backend\n- ~~More advanced graphical effects (e.g. blur)~~ (solved with the addition of GLSL effects)\n- Tests and benchmarks\n- Vulkan support\n\n**Implementing these features will get us to the 1.0 release.** Contribute, so that it's as soon as\npossible!\n\n## Requirements\n\nIf you're using Windows and having trouble building Pixel, please check [this\nguide](https://github.com/faiface/pixel/wiki/Building-Pixel-on-Windows) on the\n[wiki](https://github.com/faiface/pixel/wiki).\n\n[PixelGL](https://godoc.org/github.com/faiface/pixel/pixelgl) backend uses OpenGL to render\ngraphics. Because of that, OpenGL development libraries are needed for compilation. The dependencies\nare same as for [GLFW](https://github.com/go-gl/glfw).\n\nThe OpenGL version used is **OpenGL 3.3**.\n\n- On macOS, you need Xcode or Command Line Tools for Xcode (`xcode-select --install`) for required\n  headers and libraries.\n- On Ubuntu/Debian-like Linux distributions, you need `libgl1-mesa-dev` and `xorg-dev` packages.\n- On CentOS/Fedora-like Linux distributions, you need `libX11-devel libXcursor-devel libXrandr-devel\n  libXinerama-devel mesa-libGL-devel libXi-devel libXxf86vm-devel` packages.\n- See [here](http://www.glfw.org/docs/latest/compile.html#compile_deps) for full details.\n\n**The combination of Go 1.8, macOS and latest XCode seems to be problematic** as mentioned in issue\n[#7](https://github.com/faiface/pixel/issues/7). This issue is probably not related to Pixel.\n**Upgrading to Go 1.8.1 fixes the issue.**\n\n## Contributing\n\nJoin us in the [Discord Chat!](https://discord.gg/q2DK4MP)\n\nPixel is in, let's say, mid-stage of development. Many of the important features are here, some are\nmissing. That's why **contributions are very important and welcome!** All alone, I will be able to\nfinish the library, but it'll take a lot of time. With your help, it'll take much less. I encourage\neveryone to contribute, even with just an idea. Especially welcome are **issues** and **pull\nrequests**.\n\n**However, I won't accept everything. Pixel is being developed with thought and care.** Each\ncomponent was designed and re-designed multiple times. Code and API quality is very important here.\nAPI is focused on simplicity and expressiveness.\n\nWhen contributing, keep these goals in mind. It doesn't mean that I'll only accept perfect pull\nrequests. It just means that I might not like your idea. Or that your pull requests could need some\nrewriting. That's perfectly fine, don't let it put you off. In the end, we'll just end up with a\nbetter result.\n\nTake a look at [CONTRIBUTING.md](CONTRIBUTING.md) for further information.\n\n## License\n\n[MIT](LICENSE)\n"
        },
        {
          "name": "batch.go",
          "type": "blob",
          "size": 3.8486328125,
          "content": "package pixel\n\nimport (\n\t\"fmt\"\n\t\"image/color\"\n)\n\n// Batch is a Target that allows for efficient drawing of many objects with the same Picture.\n//\n// To put an object into a Batch, just draw it onto it:\n//   object.Draw(batch)\ntype Batch struct {\n\tcont Drawer\n\n\tmat Matrix\n\tcol RGBA\n}\n\nvar _ BasicTarget = (*Batch)(nil)\n\n// NewBatch creates an empty Batch with the specified Picture and container.\n//\n// The container is where objects get accumulated. Batch will support precisely those Triangles\n// properties, that the supplied container supports. If you retain access to the container and\n// change it, call Dirty to notify Batch about the change.\n//\n// Note, that if the container does not support TrianglesColor, color masking will not work.\nfunc NewBatch(container Triangles, pic Picture) *Batch {\n\tb := &Batch{cont: Drawer{Triangles: container, Picture: pic, Cached: true}}\n\tb.SetMatrix(IM)\n\tb.SetColorMask(Alpha(1))\n\treturn b\n}\n\n// Dirty notifies Batch about an external modification of it's container. If you retain access to\n// the Batch's container and change it, call Dirty to notify Batch about the change.\n//\n//   container := &pixel.TrianglesData{}\n//   batch := pixel.NewBatch(container, nil)\n//   container.SetLen(10) // container changed from outside of Batch\n//   batch.Dirty()        // notify Batch about the change\nfunc (b *Batch) Dirty() {\n\tb.cont.Dirty()\n}\n\n// Clear removes all objects from the Batch.\nfunc (b *Batch) Clear() {\n\tb.cont.Triangles.SetLen(0)\n\tb.cont.Dirty()\n}\n\n// Draw draws all objects that are currently in the Batch onto another Target.\nfunc (b *Batch) Draw(t Target) {\n\tb.cont.Draw(t)\n}\n\n// SetMatrix sets a Matrix that every point will be projected by.\nfunc (b *Batch) SetMatrix(m Matrix) {\n\tb.mat = m\n}\n\n// SetColorMask sets a mask color used in the following draws onto the Batch.\nfunc (b *Batch) SetColorMask(c color.Color) {\n\tif c == nil {\n\t\tb.col = Alpha(1)\n\t\treturn\n\t}\n\tb.col = ToRGBA(c)\n}\n\n// MakeTriangles returns a specialized copy of the provided Triangles that draws onto this Batch.\nfunc (b *Batch) MakeTriangles(t Triangles) TargetTriangles {\n\tbt := &batchTriangles{\n\t\ttri: t.Copy(),\n\t\ttmp: MakeTrianglesData(t.Len()),\n\t\tdst: b,\n\t}\n\treturn bt\n}\n\n// MakePicture returns a specialized copy of the provided Picture that draws onto this Batch.\nfunc (b *Batch) MakePicture(p Picture) TargetPicture {\n\tif p != b.cont.Picture {\n\t\tpanic(fmt.Errorf(\"(%T).MakePicture: Picture is not the Batch's Picture\", b))\n\t}\n\tbp := &batchPicture{\n\t\tpic: p,\n\t\tdst: b,\n\t}\n\treturn bp\n}\n\ntype batchTriangles struct {\n\ttri Triangles\n\ttmp *TrianglesData\n\tdst *Batch\n}\n\nfunc (bt *batchTriangles) Len() int {\n\treturn bt.tri.Len()\n}\n\nfunc (bt *batchTriangles) SetLen(len int) {\n\tbt.tri.SetLen(len)\n\tbt.tmp.SetLen(len)\n}\n\nfunc (bt *batchTriangles) Slice(i, j int) Triangles {\n\treturn &batchTriangles{\n\t\ttri: bt.tri.Slice(i, j),\n\t\ttmp: bt.tmp.Slice(i, j).(*TrianglesData),\n\t\tdst: bt.dst,\n\t}\n}\n\nfunc (bt *batchTriangles) Update(t Triangles) {\n\tbt.tri.Update(t)\n}\n\nfunc (bt *batchTriangles) Copy() Triangles {\n\treturn &batchTriangles{\n\t\ttri: bt.tri.Copy(),\n\t\ttmp: bt.tmp.Copy().(*TrianglesData),\n\t\tdst: bt.dst,\n\t}\n}\n\nfunc (bt *batchTriangles) draw(bp *batchPicture) {\n\tbt.tmp.Update(bt.tri)\n\n\tfor i := range *bt.tmp {\n\t\t(*bt.tmp)[i].Position = bt.dst.mat.Project((*bt.tmp)[i].Position)\n\t\t(*bt.tmp)[i].Color = bt.dst.col.Mul((*bt.tmp)[i].Color)\n\t}\n\n\tcont := bt.dst.cont.Triangles\n\tcont.SetLen(cont.Len() + bt.tri.Len())\n\tadded := cont.Slice(cont.Len()-bt.tri.Len(), cont.Len())\n\tadded.Update(bt.tri)\n\tadded.Update(bt.tmp)\n\tbt.dst.cont.Dirty()\n}\n\nfunc (bt *batchTriangles) Draw() {\n\tbt.draw(nil)\n}\n\ntype batchPicture struct {\n\tpic Picture\n\tdst *Batch\n}\n\nfunc (bp *batchPicture) Bounds() Rect {\n\treturn bp.pic.Bounds()\n}\n\nfunc (bp *batchPicture) Draw(t TargetTriangles) {\n\tbt := t.(*batchTriangles)\n\tif bp.dst != bt.dst {\n\t\tpanic(fmt.Errorf(\"(%T).Draw: TargetTriangles generated by different Batch\", bp))\n\t}\n\tbt.draw(bp)\n}\n"
        },
        {
          "name": "circle.go",
          "type": "blob",
          "size": 10.4375,
          "content": "package pixel\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// Circle is a 2D circle. It is defined by two properties:\n//  - Center vector\n//  - Radius float64\ntype Circle struct {\n\tCenter Vec\n\tRadius float64\n}\n\n// C returns a new Circle with the given radius and center coordinates.\n//\n// Note that a negative radius is valid.\nfunc C(center Vec, radius float64) Circle {\n\treturn Circle{\n\t\tCenter: center,\n\t\tRadius: radius,\n\t}\n}\n\n// String returns the string representation of the Circle.\n//\n//  c := pixel.C(10.1234, pixel.ZV)\n//  c.String()     // returns \"Circle(10.12, Vec(0, 0))\"\n//  fmt.Println(c) // Circle(10.12, Vec(0, 0))\nfunc (c Circle) String() string {\n\treturn fmt.Sprintf(\"Circle(%s, %.2f)\", c.Center, c.Radius)\n}\n\n// Norm returns the Circle in normalized form - this sets the radius to its absolute value.\n//\n// c := pixel.C(-10, pixel.ZV)\n// c.Norm() // returns pixel.Circle{pixel.Vec{0, 0}, 10}\nfunc (c Circle) Norm() Circle {\n\treturn Circle{\n\t\tCenter: c.Center,\n\t\tRadius: math.Abs(c.Radius),\n\t}\n}\n\n// Area returns the area of the Circle.\nfunc (c Circle) Area() float64 {\n\treturn math.Pi * math.Pow(c.Radius, 2)\n}\n\n// Moved returns the Circle moved by the given vector delta.\nfunc (c Circle) Moved(delta Vec) Circle {\n\treturn Circle{\n\t\tCenter: c.Center.Add(delta),\n\t\tRadius: c.Radius,\n\t}\n}\n\n// Resized returns the Circle resized by the given delta.  The Circles center is use as the anchor.\n//\n// c := pixel.C(pixel.ZV, 10)\n// c.Resized(-5) // returns pixel.Circle{pixel.Vec{0, 0}, 5}\n// c.Resized(25) // returns pixel.Circle{pixel.Vec{0, 0}, 35}\nfunc (c Circle) Resized(radiusDelta float64) Circle {\n\treturn Circle{\n\t\tCenter: c.Center,\n\t\tRadius: c.Radius + radiusDelta,\n\t}\n}\n\n// Contains checks whether a vector `u` is contained within this Circle (including it's perimeter).\nfunc (c Circle) Contains(u Vec) bool {\n\ttoCenter := c.Center.To(u)\n\treturn c.Radius >= toCenter.Len()\n}\n\n// Formula returns the values of h and k, for the equation of the circle: (x-h)^2 + (y-k)^2 = r^2\n// where r is the radius of the circle.\nfunc (c Circle) Formula() (h, k float64) {\n\treturn c.Center.X, c.Center.Y\n}\n\n// maxCircle will return the larger circle based on the radius.\nfunc maxCircle(c, d Circle) Circle {\n\tif c.Radius < d.Radius {\n\t\treturn d\n\t}\n\treturn c\n}\n\n// minCircle will return the smaller circle based on the radius.\nfunc minCircle(c, d Circle) Circle {\n\tif c.Radius < d.Radius {\n\t\treturn c\n\t}\n\treturn d\n}\n\n// Union returns the minimal Circle which covers both `c` and `d`.\nfunc (c Circle) Union(d Circle) Circle {\n\tbiggerC := maxCircle(c.Norm(), d.Norm())\n\tsmallerC := minCircle(c.Norm(), d.Norm())\n\n\t// Get distance between centers\n\tdist := c.Center.To(d.Center).Len()\n\n\t// If the bigger Circle encompasses the smaller one, we have the result\n\tif dist+smallerC.Radius <= biggerC.Radius {\n\t\treturn biggerC\n\t}\n\n\t// Calculate radius for encompassing Circle\n\tr := (dist + biggerC.Radius + smallerC.Radius) / 2\n\n\t// Calculate center for encompassing Circle\n\ttheta := .5 + (biggerC.Radius-smallerC.Radius)/(2*dist)\n\tcenter := Lerp(smallerC.Center, biggerC.Center, theta)\n\n\treturn Circle{\n\t\tCenter: center,\n\t\tRadius: r,\n\t}\n}\n\n// Intersect returns the maximal Circle which is covered by both `c` and `d`.\n//\n// If `c` and `d` don't overlap, this function returns a zero-sized circle at the centerpoint between the two Circle's\n// centers.\nfunc (c Circle) Intersect(d Circle) Circle {\n\t// Check if one of the circles encompasses the other; if so, return that one\n\tbiggerC := maxCircle(c.Norm(), d.Norm())\n\tsmallerC := minCircle(c.Norm(), d.Norm())\n\n\tif biggerC.Radius >= biggerC.Center.To(smallerC.Center).Len()+smallerC.Radius {\n\t\treturn biggerC\n\t}\n\n\t// Calculate the midpoint between the two radii\n\t// Distance between centers\n\tdist := c.Center.To(d.Center).Len()\n\t// Difference between radii\n\tdiff := dist - (c.Radius + d.Radius)\n\t// Distance from c.Center to the weighted midpoint\n\tdistToMidpoint := c.Radius + 0.5*diff\n\t// Weighted midpoint\n\tcenter := Lerp(c.Center, d.Center, distToMidpoint/dist)\n\n\t// No need to calculate radius if the circles do not overlap\n\tif c.Center.To(d.Center).Len() >= c.Radius+d.Radius {\n\t\treturn C(center, 0)\n\t}\n\n\tradius := c.Center.To(d.Center).Len() - (c.Radius + d.Radius)\n\n\treturn Circle{\n\t\tCenter: center,\n\t\tRadius: math.Abs(radius),\n\t}\n}\n\n// IntersectLine will return the shortest Vec such that if the Circle is moved by the Vec returned, the Line and Rect no\n// longer intersect.\nfunc (c Circle) IntersectLine(l Line) Vec {\n\treturn l.IntersectCircle(c).Scaled(-1)\n}\n\n// IntersectRect returns a minimal required Vector, such that moving the circle by that vector would stop the Circle\n// and the Rect intersecting.  This function returns a zero-vector if the Circle and Rect do not overlap, and if only\n// the perimeters touch.\n//\n// This function will return a non-zero vector if:\n//  - The Rect contains the Circle, partially or fully\n//  - The Circle contains the Rect, partially of fully\nfunc (c Circle) IntersectRect(r Rect) Vec {\n\t// Checks if the c.Center is not in the diagonal quadrants of the rectangle\n\tif (r.Min.X <= c.Center.X && c.Center.X <= r.Max.X) || (r.Min.Y <= c.Center.Y && c.Center.Y <= r.Max.Y) {\n\t\t// 'grow' the Rect by c.Radius in each orthagonal\n\t\tgrown := Rect{Min: r.Min.Sub(V(c.Radius, c.Radius)), Max: r.Max.Add(V(c.Radius, c.Radius))}\n\t\tif !grown.Contains(c.Center) {\n\t\t\t// c.Center not close enough to overlap, return zero-vector\n\t\t\treturn ZV\n\t\t}\n\n\t\t// Get minimum distance to travel out of Rect\n\t\trToC := r.Center().To(c.Center)\n\t\th := c.Radius - math.Abs(rToC.X) + (r.W() / 2)\n\t\tv := c.Radius - math.Abs(rToC.Y) + (r.H() / 2)\n\n\t\tif rToC.X < 0 {\n\t\t\th = -h\n\t\t}\n\t\tif rToC.Y < 0 {\n\t\t\tv = -v\n\t\t}\n\n\t\t// No intersect\n\t\tif h == 0 && v == 0 {\n\t\t\treturn ZV\n\t\t}\n\n\t\tif math.Abs(h) > math.Abs(v) {\n\t\t\t// Vertical distance shorter\n\t\t\treturn V(0, v)\n\t\t}\n\t\treturn V(h, 0)\n\t} else {\n\t\t// The center is in the diagonal quadrants\n\n\t\t// Helper points to make code below easy to read.\n\t\trectTopLeft := V(r.Min.X, r.Max.Y)\n\t\trectBottomRight := V(r.Max.X, r.Min.Y)\n\n\t\t// Check for overlap.\n\t\tif !(c.Contains(r.Min) || c.Contains(r.Max) || c.Contains(rectTopLeft) || c.Contains(rectBottomRight)) {\n\t\t\t// No overlap.\n\t\t\treturn ZV\n\t\t}\n\n\t\tvar centerToCorner Vec\n\t\tif c.Center.To(r.Min).Len() <= c.Radius {\n\t\t\t// Closest to bottom-left\n\t\t\tcenterToCorner = c.Center.To(r.Min)\n\t\t}\n\t\tif c.Center.To(r.Max).Len() <= c.Radius {\n\t\t\t// Closest to top-right\n\t\t\tcenterToCorner = c.Center.To(r.Max)\n\t\t}\n\t\tif c.Center.To(rectTopLeft).Len() <= c.Radius {\n\t\t\t// Closest to top-left\n\t\t\tcenterToCorner = c.Center.To(rectTopLeft)\n\t\t}\n\t\tif c.Center.To(rectBottomRight).Len() <= c.Radius {\n\t\t\t// Closest to bottom-right\n\t\t\tcenterToCorner = c.Center.To(rectBottomRight)\n\t\t}\n\n\t\tcornerToCircumferenceLen := c.Radius - centerToCorner.Len()\n\n\t\treturn centerToCorner.Unit().Scaled(cornerToCircumferenceLen)\n\t}\n}\n\n// IntersectionPoints returns all the points where the Circle intersects with the line provided.  This can be zero, one or\n// two points, depending on the location of the shapes.  The points of intersection will be returned in order of\n// closest-to-l.A to closest-to-l.B.\nfunc (c Circle) IntersectionPoints(l Line) []Vec {\n\tcContainsA := c.Contains(l.A)\n\tcContainsB := c.Contains(l.B)\n\n\t// Special case for both endpoint being contained within the circle\n\tif cContainsA && cContainsB {\n\t\treturn []Vec{}\n\t}\n\n\t// Get closest point on the line to this circles' center\n\tclosestToCenter := l.Closest(c.Center)\n\n\t// If the distance to the closest point is greater than the radius, there are no points of intersection\n\tif closestToCenter.To(c.Center).Len() > c.Radius {\n\t\treturn []Vec{}\n\t}\n\n\t// If the distance to the closest point is equal to the radius, the line is tangent and the closest point is the\n\t// point at which it touches the circle.\n\tif closestToCenter.To(c.Center).Len() == c.Radius {\n\t\treturn []Vec{closestToCenter}\n\t}\n\n\t// Special case for endpoint being on the circles' center\n\tif c.Center == l.A || c.Center == l.B {\n\t\totherEnd := l.B\n\t\tif c.Center == l.B {\n\t\t\totherEnd = l.A\n\t\t}\n\t\tintersect := c.Center.Add(c.Center.To(otherEnd).Unit().Scaled(c.Radius))\n\t\treturn []Vec{intersect}\n\t}\n\n\t// This means the distance to the closest point is less than the radius, so there is at least one intersection,\n\t// possibly two.\n\n\t// If one of the end points exists within the circle, there is only one intersection\n\tif cContainsA || cContainsB {\n\t\tcontainedPoint := l.A\n\t\totherEnd := l.B\n\t\tif cContainsB {\n\t\t\tcontainedPoint = l.B\n\t\t\totherEnd = l.A\n\t\t}\n\n\t\t// Use trigonometry to get the length of the line between the contained point and the intersection point.\n\t\t// The following is used to describe the triangle formed:\n\t\t//  - a is the side between contained point and circle center\n\t\t//  - b is the side between the center and the intersection point (radius)\n\t\t//  - c is the side between the contained point and the intersection point\n\t\t// The captials of these letters are used as the angles opposite the respective sides.\n\t\t// a and b are known\n\t\ta := containedPoint.To(c.Center).Len()\n\t\tb := c.Radius\n\t\t// B can be calculated by subtracting the angle of b (to the x-axis) from the angle of c (to the x-axis)\n\t\tB := containedPoint.To(c.Center).Angle() - containedPoint.To(otherEnd).Angle()\n\t\t// Using the Sin rule we can get A\n\t\tA := math.Asin((a * math.Sin(B)) / b)\n\t\t// Using the rule that there are 180 degrees (or Pi radians) in a triangle, we can now get C\n\t\tC := math.Pi - A + B\n\t\t// If C is zero, the line segment is in-line with the center-intersect line.\n\t\tvar c float64\n\t\tif C == 0 {\n\t\t\tc = b - a\n\t\t} else {\n\t\t\t// Using the Sine rule again, we can now get c\n\t\t\tc = (a * math.Sin(C)) / math.Sin(A)\n\t\t}\n\t\t// Travelling from the contained point to the other end by length of a will provide the intersection point.\n\t\treturn []Vec{\n\t\t\tcontainedPoint.Add(containedPoint.To(otherEnd).Unit().Scaled(c)),\n\t\t}\n\t}\n\n\t// Otherwise the endpoints exist outside of the circle, and the line segment intersects in two locations.\n\t// The vector formed by going from the closest point to the center of the circle will be perpendicular to the line;\n\t// this forms a right-angled triangle with the intersection points, with the radius as the hypotenuse.\n\t// Calculate the other triangles' sides' length.\n\ta := math.Sqrt(math.Pow(c.Radius, 2) - math.Pow(closestToCenter.To(c.Center).Len(), 2))\n\n\t// Travelling in both directions from the closest point by length of a will provide the two intersection points.\n\tfirst := closestToCenter.Add(closestToCenter.To(l.A).Unit().Scaled(a))\n\tsecond := closestToCenter.Add(closestToCenter.To(l.B).Unit().Scaled(a))\n\n\tif first.To(l.A).Len() < second.To(l.A).Len() {\n\t\treturn []Vec{first, second}\n\t}\n\treturn []Vec{second, first}\n}\n"
        },
        {
          "name": "circle_test.go",
          "type": "blob",
          "size": 11.2587890625,
          "content": "package pixel_test\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/faiface/pixel\"\n)\n\nfunc TestC(t *testing.T) {\n\ttype args struct {\n\t\tradius float64\n\t\tcenter pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant pixel.Circle\n\t}{\n\t\t{\n\t\t\tname: \"C(): positive radius\",\n\t\t\targs: args{radius: 10, center: pixel.ZV},\n\t\t\twant: pixel.Circle{Radius: 10, Center: pixel.ZV},\n\t\t},\n\t\t{\n\t\t\tname: \"C(): zero radius\",\n\t\t\targs: args{radius: 0, center: pixel.ZV},\n\t\t\twant: pixel.Circle{Radius: 0, Center: pixel.ZV},\n\t\t},\n\t\t{\n\t\t\tname: \"C(): negative radius\",\n\t\t\targs: args{radius: -5, center: pixel.ZV},\n\t\t\twant: pixel.Circle{Radius: -5, Center: pixel.ZV},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := pixel.C(tt.args.center, tt.args.radius); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"C() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCircle_String(t *testing.T) {\n\ttype fields struct {\n\t\tradius float64\n\t\tcenter pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   string\n\t}{\n\t\t{\n\t\t\tname:   \"Circle.String(): positive radius\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\twant:   \"Circle(Vec(0, 0), 10.00)\",\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.String(): zero radius\",\n\t\t\tfields: fields{radius: 0, center: pixel.ZV},\n\t\t\twant:   \"Circle(Vec(0, 0), 0.00)\",\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.String(): negative radius\",\n\t\t\tfields: fields{radius: -5, center: pixel.ZV},\n\t\t\twant:   \"Circle(Vec(0, 0), -5.00)\",\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.String(): irrational radius\",\n\t\t\tfields: fields{radius: math.Pi, center: pixel.ZV},\n\t\t\twant:   \"Circle(Vec(0, 0), 3.14)\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := pixel.C(tt.fields.center, tt.fields.radius)\n\t\t\tif got := c.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Circle.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCircle_Norm(t *testing.T) {\n\ttype fields struct {\n\t\tradius float64\n\t\tcenter pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   pixel.Circle\n\t}{\n\t\t{\n\t\t\tname:   \"Circle.Norm(): positive radius\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\twant:   pixel.C(pixel.ZV, 10),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Norm(): zero radius\",\n\t\t\tfields: fields{radius: 0, center: pixel.ZV},\n\t\t\twant:   pixel.C(pixel.ZV, 0),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Norm(): negative radius\",\n\t\t\tfields: fields{radius: -5, center: pixel.ZV},\n\t\t\twant:   pixel.C(pixel.ZV, 5),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := pixel.C(tt.fields.center, tt.fields.radius)\n\t\t\tif got := c.Norm(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Circle.Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCircle_Area(t *testing.T) {\n\ttype fields struct {\n\t\tradius float64\n\t\tcenter pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   float64\n\t}{\n\t\t{\n\t\t\tname:   \"Circle.Area(): positive radius\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\twant:   100 * math.Pi,\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Area(): zero radius\",\n\t\t\tfields: fields{radius: 0, center: pixel.ZV},\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Area(): negative radius\",\n\t\t\tfields: fields{radius: -5, center: pixel.ZV},\n\t\t\twant:   25 * math.Pi,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := pixel.C(tt.fields.center, tt.fields.radius)\n\t\t\tif got := c.Area(); got != tt.want {\n\t\t\t\tt.Errorf(\"Circle.Area() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCircle_Moved(t *testing.T) {\n\ttype fields struct {\n\t\tradius float64\n\t\tcenter pixel.Vec\n\t}\n\ttype args struct {\n\t\tdelta pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Circle\n\t}{\n\t\t{\n\t\t\tname:   \"Circle.Moved(): positive movement\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\targs:   args{delta: pixel.V(10, 20)},\n\t\t\twant:   pixel.C(pixel.V(10, 20), 10),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Moved(): zero movement\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\targs:   args{delta: pixel.ZV},\n\t\t\twant:   pixel.C(pixel.V(0, 0), 10),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Moved(): negative movement\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\targs:   args{delta: pixel.V(-5, -10)},\n\t\t\twant:   pixel.C(pixel.V(-5, -10), 10),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := pixel.C(tt.fields.center, tt.fields.radius)\n\t\t\tif got := c.Moved(tt.args.delta); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Circle.Moved() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCircle_Resized(t *testing.T) {\n\ttype fields struct {\n\t\tradius float64\n\t\tcenter pixel.Vec\n\t}\n\ttype args struct {\n\t\tradiusDelta float64\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Circle\n\t}{\n\t\t{\n\t\t\tname:   \"Circle.Resized(): positive delta\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\targs:   args{radiusDelta: 5},\n\t\t\twant:   pixel.C(pixel.V(0, 0), 15),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Resized(): zero delta\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\targs:   args{radiusDelta: 0},\n\t\t\twant:   pixel.C(pixel.V(0, 0), 10),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Resized(): negative delta\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\targs:   args{radiusDelta: -5},\n\t\t\twant:   pixel.C(pixel.V(0, 0), 5),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := pixel.C(tt.fields.center, tt.fields.radius)\n\t\t\tif got := c.Resized(tt.args.radiusDelta); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Circle.Resized() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCircle_Contains(t *testing.T) {\n\ttype fields struct {\n\t\tradius float64\n\t\tcenter pixel.Vec\n\t}\n\ttype args struct {\n\t\tu pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"Circle.Contains(): point on cicles' center\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\targs:   args{u: pixel.ZV},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Contains(): point offcenter\",\n\t\t\tfields: fields{radius: 10, center: pixel.V(5, 0)},\n\t\t\targs:   args{u: pixel.ZV},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Contains(): point on circumference\",\n\t\t\tfields: fields{radius: 10, center: pixel.V(10, 0)},\n\t\t\targs:   args{u: pixel.ZV},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Contains(): point outside circle\",\n\t\t\tfields: fields{radius: 10, center: pixel.V(15, 0)},\n\t\t\targs:   args{u: pixel.ZV},\n\t\t\twant:   false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := pixel.C(tt.fields.center, tt.fields.radius)\n\t\t\tif got := c.Contains(tt.args.u); got != tt.want {\n\t\t\t\tt.Errorf(\"Circle.Contains() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCircle_Union(t *testing.T) {\n\ttype fields struct {\n\t\tradius float64\n\t\tcenter pixel.Vec\n\t}\n\ttype args struct {\n\t\td pixel.Circle\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Circle\n\t}{\n\t\t{\n\t\t\tname:   \"Circle.Union(): overlapping circles\",\n\t\t\tfields: fields{radius: 5, center: pixel.ZV},\n\t\t\targs:   args{d: pixel.C(pixel.ZV, 5)},\n\t\t\twant:   pixel.C(pixel.ZV, 5),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Union(): separate circles\",\n\t\t\tfields: fields{radius: 1, center: pixel.ZV},\n\t\t\targs:   args{d: pixel.C(pixel.V(0, 2), 1)},\n\t\t\twant:   pixel.C(pixel.V(0, 1), 2),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := pixel.C(tt.fields.center, tt.fields.radius)\n\t\t\tif got := c.Union(tt.args.d); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Circle.Union() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCircle_Intersect(t *testing.T) {\n\ttype fields struct {\n\t\tradius float64\n\t\tcenter pixel.Vec\n\t}\n\ttype args struct {\n\t\td pixel.Circle\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Circle\n\t}{\n\t\t{\n\t\t\tname:   \"Circle.Intersect(): intersecting circles\",\n\t\t\tfields: fields{radius: 1, center: pixel.ZV},\n\t\t\targs:   args{d: pixel.C(pixel.V(1, 0), 1)},\n\t\t\twant:   pixel.C(pixel.V(0.5, 0), 1),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Intersect(): non-intersecting circles\",\n\t\t\tfields: fields{radius: 1, center: pixel.ZV},\n\t\t\targs:   args{d: pixel.C(pixel.V(3, 3), 1)},\n\t\t\twant:   pixel.C(pixel.V(1.5, 1.5), 0),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Intersect(): first circle encompassing second\",\n\t\t\tfields: fields{radius: 10, center: pixel.ZV},\n\t\t\targs:   args{d: pixel.C(pixel.V(3, 3), 1)},\n\t\t\twant:   pixel.C(pixel.ZV, 10),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Intersect(): second circle encompassing first\",\n\t\t\tfields: fields{radius: 1, center: pixel.V(-1, -4)},\n\t\t\targs:   args{d: pixel.C(pixel.ZV, 10)},\n\t\t\twant:   pixel.C(pixel.ZV, 10),\n\t\t},\n\t\t{\n\t\t\tname:   \"Circle.Intersect(): matching circles\",\n\t\t\tfields: fields{radius: 1, center: pixel.ZV},\n\t\t\targs:   args{d: pixel.C(pixel.ZV, 1)},\n\t\t\twant:   pixel.C(pixel.ZV, 1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := pixel.C(\n\t\t\t\ttt.fields.center,\n\t\t\t\ttt.fields.radius,\n\t\t\t)\n\t\t\tif got := c.Intersect(tt.args.d); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Circle.Intersect() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCircle_IntersectPoints(t *testing.T) {\n\ttype fields struct {\n\t\tCenter pixel.Vec\n\t\tRadius float64\n\t}\n\ttype args struct {\n\t\tl pixel.Line\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   []pixel.Vec\n\t}{\n\t\t{\n\t\t\tname:   \"Line intersects circle at two points\",\n\t\t\tfields: fields{Center: pixel.V(2, 2), Radius: 1},\n\t\t\targs:   args{pixel.L(pixel.V(0, 0), pixel.V(10, 10))},\n\t\t\twant:   []pixel.Vec{pixel.V(1.292, 1.292), pixel.V(2.707, 2.707)},\n\t\t},\n\t\t{\n\t\t\tname:   \"Line intersects circle at one point\",\n\t\t\tfields: fields{Center: pixel.V(-0.5, -0.5), Radius: 1},\n\t\t\targs:   args{pixel.L(pixel.V(0, 0), pixel.V(10, 10))},\n\t\t\twant:   []pixel.Vec{pixel.V(0.207, 0.207)},\n\t\t},\n\t\t{\n\t\t\tname:   \"Line endpoint is circle center\",\n\t\t\tfields: fields{Center: pixel.V(0, 0), Radius: 1},\n\t\t\targs:   args{pixel.L(pixel.V(0, 0), pixel.V(10, 10))},\n\t\t\twant:   []pixel.Vec{pixel.V(0.707, 0.707)},\n\t\t},\n\t\t{\n\t\t\tname:   \"Both line endpoints within circle\",\n\t\t\tfields: fields{Center: pixel.V(0, 0), Radius: 1},\n\t\t\targs:   args{pixel.L(pixel.V(0.2, 0.2), pixel.V(0.5, 0.5))},\n\t\t\twant:   []pixel.Vec{},\n\t\t},\n\t\t{\n\t\t\tname:   \"Line does not intersect circle\",\n\t\t\tfields: fields{Center: pixel.V(10, 0), Radius: 1},\n\t\t\targs:   args{pixel.L(pixel.V(0, 0), pixel.V(10, 10))},\n\t\t\twant:   []pixel.Vec{},\n\t\t},\n\t\t{\n\t\t\tname:   \"Horizontal line intersects circle at two points\",\n\t\t\tfields: fields{Center: pixel.V(5, 5), Radius: 1},\n\t\t\targs:   args{pixel.L(pixel.V(0, 5), pixel.V(10, 5))},\n\t\t\twant:   []pixel.Vec{pixel.V(4, 5), pixel.V(6, 5)},\n\t\t},\n\t\t{\n\t\t\tname:   \"Vertical line intersects circle at two points\",\n\t\t\tfields: fields{Center: pixel.V(5, 5), Radius: 1},\n\t\t\targs:   args{pixel.L(pixel.V(5, 0), pixel.V(5, 10))},\n\t\t\twant:   []pixel.Vec{pixel.V(5, 4), pixel.V(5, 6)},\n\t\t},\n\t\t{\n\t\t\tname:   \"Left and down line intersects circle at two points\",\n\t\t\tfields: fields{Center: pixel.V(5, 5), Radius: 1},\n\t\t\targs:   args{pixel.L(pixel.V(10, 10), pixel.V(0, 0))},\n\t\t\twant:   []pixel.Vec{pixel.V(5.707, 5.707), pixel.V(4.292, 4.292)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := pixel.Circle{\n\t\t\t\tCenter: tt.fields.Center,\n\t\t\t\tRadius: tt.fields.Radius,\n\t\t\t}\n\t\t\tgot := c.IntersectionPoints(tt.args.l)\n\t\t\tfor i, v := range got {\n\t\t\t\tif !closeEnough(v.X, tt.want[i].X, 2) || !closeEnough(v.Y, tt.want[i].Y, 2) {\n\t\t\t\t\tt.Errorf(\"Circle.IntersectPoints() = %v, want %v\", v, tt.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 2.330078125,
          "content": "package pixel\n\nimport \"image/color\"\n\n// RGBA represents an alpha-premultiplied RGBA color with components within range [0, 1].\n//\n// The difference between color.RGBA is that the value range is [0, 1] and the values are floats.\ntype RGBA struct {\n\tR, G, B, A float64\n}\n\n// RGB returns a fully opaque RGBA color with the given RGB values.\n//\n// A common way to construct a transparent color is to create one with RGB constructor, then\n// multiply it by a color obtained from the Alpha constructor.\nfunc RGB(r, g, b float64) RGBA {\n\treturn RGBA{r, g, b, 1}\n}\n\n// Alpha returns a white RGBA color with the given alpha component.\nfunc Alpha(a float64) RGBA {\n\treturn RGBA{a, a, a, a}\n}\n\n// Add adds color d to color c component-wise and returns the result (the components are not\n// clamped).\nfunc (c RGBA) Add(d RGBA) RGBA {\n\treturn RGBA{\n\t\tR: c.R + d.R,\n\t\tG: c.G + d.G,\n\t\tB: c.B + d.B,\n\t\tA: c.A + d.A,\n\t}\n}\n\n// Sub subtracts color d from color c component-wise and returns the result (the components\n// are not clamped).\nfunc (c RGBA) Sub(d RGBA) RGBA {\n\treturn RGBA{\n\t\tR: c.R - d.R,\n\t\tG: c.G - d.G,\n\t\tB: c.B - d.B,\n\t\tA: c.A - d.A,\n\t}\n}\n\n// Mul multiplies color c by color d component-wise (the components are not clamped).\nfunc (c RGBA) Mul(d RGBA) RGBA {\n\treturn RGBA{\n\t\tR: c.R * d.R,\n\t\tG: c.G * d.G,\n\t\tB: c.B * d.B,\n\t\tA: c.A * d.A,\n\t}\n}\n\n// Scaled multiplies each component of color c by scale and returns the result (the components\n// are not clamped).\nfunc (c RGBA) Scaled(scale float64) RGBA {\n\treturn RGBA{\n\t\tR: c.R * scale,\n\t\tG: c.G * scale,\n\t\tB: c.B * scale,\n\t\tA: c.A * scale,\n\t}\n}\n\n// RGBA returns alpha-premultiplied red, green, blue and alpha components of the RGBA color.\nfunc (c RGBA) RGBA() (r, g, b, a uint32) {\n\tr = uint32(0xffff * c.R)\n\tg = uint32(0xffff * c.G)\n\tb = uint32(0xffff * c.B)\n\ta = uint32(0xffff * c.A)\n\treturn\n}\n\n// ToRGBA converts a color to RGBA format. Using this function is preferred to using RGBAModel, for\n// performance (using RGBAModel introduces additional unnecessary allocations).\nfunc ToRGBA(c color.Color) RGBA {\n\tif c, ok := c.(RGBA); ok {\n\t\treturn c\n\t}\n\tr, g, b, a := c.RGBA()\n\treturn RGBA{\n\t\tfloat64(r) / 0xffff,\n\t\tfloat64(g) / 0xffff,\n\t\tfloat64(b) / 0xffff,\n\t\tfloat64(a) / 0xffff,\n\t}\n}\n\n// RGBAModel converts colors to RGBA format.\nvar RGBAModel = color.ModelFunc(rgbaModel)\n\nfunc rgbaModel(c color.Color) color.Color {\n\treturn ToRGBA(c)\n}\n"
        },
        {
          "name": "color_test.go",
          "type": "blob",
          "size": 0.4775390625,
          "content": "package pixel_test\n\nimport (\n\t\"fmt\"\n\t\"image/color\"\n\t\"testing\"\n\n\t\"github.com/faiface/pixel\"\n)\n\nfunc BenchmarkColorToRGBA(b *testing.B) {\n\ttypes := []color.Color{\n\t\tcolor.NRGBA{R: 124, G: 14, B: 230, A: 42}, // slowest\n\t\tcolor.RGBA{R: 62, G: 32, B: 14, A: 63},    // faster\n\t\tpixel.RGB(0.8, 0.2, 0.5).Scaled(0.712),    // fastest\n\t}\n\tfor _, col := range types {\n\t\tb.Run(fmt.Sprintf(\"From %T\", col), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = pixel.ToRGBA(col)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "compose.go",
          "type": "blob",
          "size": 1.330078125,
          "content": "package pixel\n\nimport \"errors\"\n\n// ComposeTarget is a BasicTarget capable of Porter-Duff composition.\ntype ComposeTarget interface {\n\tBasicTarget\n\n\t// SetComposeMethod sets a Porter-Duff composition method to be used.\n\tSetComposeMethod(ComposeMethod)\n}\n\n// ComposeMethod is a Porter-Duff composition method.\ntype ComposeMethod int\n\n// Here's the list of all available Porter-Duff composition methods. Use ComposeOver for the basic\n// alpha blending.\nconst (\n\tComposeOver ComposeMethod = iota\n\tComposeIn\n\tComposeOut\n\tComposeAtop\n\tComposeRover\n\tComposeRin\n\tComposeRout\n\tComposeRatop\n\tComposeXor\n\tComposePlus\n\tComposeCopy\n)\n\n// Compose composes two colors together according to the ComposeMethod. A is the foreground, B is\n// the background.\nfunc (cm ComposeMethod) Compose(a, b RGBA) RGBA {\n\tvar fa, fb float64\n\n\tswitch cm {\n\tcase ComposeOver:\n\t\tfa, fb = 1, 1-a.A\n\tcase ComposeIn:\n\t\tfa, fb = b.A, 0\n\tcase ComposeOut:\n\t\tfa, fb = 1-b.A, 0\n\tcase ComposeAtop:\n\t\tfa, fb = b.A, 1-a.A\n\tcase ComposeRover:\n\t\tfa, fb = 1-b.A, 1\n\tcase ComposeRin:\n\t\tfa, fb = 0, a.A\n\tcase ComposeRout:\n\t\tfa, fb = 0, 1-a.A\n\tcase ComposeRatop:\n\t\tfa, fb = 1-b.A, a.A\n\tcase ComposeXor:\n\t\tfa, fb = 1-b.A, 1-a.A\n\tcase ComposePlus:\n\t\tfa, fb = 1, 1\n\tcase ComposeCopy:\n\t\tfa, fb = 1, 0\n\tdefault:\n\t\tpanic(errors.New(\"Compose: invalid ComposeMethod\"))\n\t}\n\n\treturn a.Mul(Alpha(fa)).Add(b.Mul(Alpha(fb)))\n}\n"
        },
        {
          "name": "data.go",
          "type": "blob",
          "size": 7.462890625,
          "content": "package pixel\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/draw\"\n\t\"math\"\n)\n\n// zeroValueTriangleData is the default value of a TriangleData element\nvar zeroValueTriangleData = struct {\n\tPosition  Vec\n\tColor     RGBA\n\tPicture   Vec\n\tIntensity float64\n\tClipRect  Rect\n\tIsClipped bool\n}{Color: RGBA{1, 1, 1, 1}}\n\n// TrianglesData specifies a list of Triangles vertices with three common properties:\n// TrianglesPosition, TrianglesColor and TrianglesPicture.\ntype TrianglesData []struct {\n\tPosition  Vec\n\tColor     RGBA\n\tPicture   Vec\n\tIntensity float64\n\tClipRect  Rect\n\tIsClipped bool\n}\n\n// MakeTrianglesData creates TrianglesData of length len initialized with default property values.\n//\n// Prefer this function to make(TrianglesData, len), because make zeros them, while this function\n// does the correct intialization.\nfunc MakeTrianglesData(len int) *TrianglesData {\n\ttd := make(TrianglesData, len)\n\tfor i := 0; i < len; i++ {\n\t\ttd[i] = zeroValueTriangleData\n\t}\n\treturn &td\n}\n\n// Len returns the number of vertices in TrianglesData.\nfunc (td *TrianglesData) Len() int {\n\treturn len(*td)\n}\n\n// SetLen resizes TrianglesData to len, while keeping the original content.\n//\n// If len is greater than TrianglesData's current length, the new data is filled with default\n// values ((0, 0), white, (0, 0), 0).\nfunc (td *TrianglesData) SetLen(len int) {\n\tif len > td.Len() {\n\t\tneedAppend := len - td.Len()\n\t\tfor i := 0; i < needAppend; i++ {\n\t\t\t*td = append(*td, zeroValueTriangleData)\n\t\t}\n\t}\n\tif len < td.Len() {\n\t\t*td = (*td)[:len]\n\t}\n}\n\n// Slice returns a sub-Triangles of this TrianglesData.\nfunc (td *TrianglesData) Slice(i, j int) Triangles {\n\ts := TrianglesData((*td)[i:j])\n\treturn &s\n}\n\nfunc (td *TrianglesData) updateData(t Triangles) {\n\t// fast path optimization\n\tif t, ok := t.(*TrianglesData); ok {\n\t\tcopy(*td, *t)\n\t\treturn\n\t}\n\n\t// slow path manual copy\n\tif t, ok := t.(TrianglesPosition); ok {\n\t\tfor i := range *td {\n\t\t\t(*td)[i].Position = t.Position(i)\n\t\t}\n\t}\n\tif t, ok := t.(TrianglesColor); ok {\n\t\tfor i := range *td {\n\t\t\t(*td)[i].Color = t.Color(i)\n\t\t}\n\t}\n\tif t, ok := t.(TrianglesPicture); ok {\n\t\tfor i := range *td {\n\t\t\t(*td)[i].Picture, (*td)[i].Intensity = t.Picture(i)\n\t\t}\n\t}\n\tif t, ok := t.(TrianglesClipped); ok {\n\t\tfor i := range *td {\n\t\t\t(*td)[i].ClipRect, (*td)[i].IsClipped = t.ClipRect(i)\n\t\t}\n\t}\n}\n\n// Update copies vertex properties from the supplied Triangles into this TrianglesData.\n//\n// TrianglesPosition, TrianglesColor and TrianglesTexture are supported.\nfunc (td *TrianglesData) Update(t Triangles) {\n\tif td.Len() != t.Len() {\n\t\tpanic(fmt.Errorf(\"(%T).Update: invalid triangles length\", td))\n\t}\n\ttd.updateData(t)\n}\n\n// Copy returns an exact independent copy of this TrianglesData.\nfunc (td *TrianglesData) Copy() Triangles {\n\tcopyTd := MakeTrianglesData(td.Len())\n\tcopyTd.Update(td)\n\treturn copyTd\n}\n\n// Position returns the position property of i-th vertex.\nfunc (td *TrianglesData) Position(i int) Vec {\n\treturn (*td)[i].Position\n}\n\n// Color returns the color property of i-th vertex.\nfunc (td *TrianglesData) Color(i int) RGBA {\n\treturn (*td)[i].Color\n}\n\n// Picture returns the picture property of i-th vertex.\nfunc (td *TrianglesData) Picture(i int) (pic Vec, intensity float64) {\n\treturn (*td)[i].Picture, (*td)[i].Intensity\n}\n\n// ClipRect returns the clipping rectangle property of the i-th vertex.\nfunc (td *TrianglesData) ClipRect(i int) (rect Rect, has bool) {\n\treturn (*td)[i].ClipRect, (*td)[i].IsClipped\n}\n\n// PictureData specifies an in-memory rectangular area of pixels and implements Picture and\n// PictureColor.\n//\n// Pixels are small rectangles of unit size of form (x, y, x+1, y+1), where x and y are integers.\n// PictureData contains and assigns a color to all pixels that are at least partially contained\n// within it's Bounds (Rect).\n//\n// The struct's innards are exposed for convenience, manual modification is at your own risk.\n//\n// The format of the pixels is color.RGBA and not pixel.RGBA for a very serious reason:\n// pixel.RGBA takes up 8x more memory than color.RGBA.\ntype PictureData struct {\n\tPix    []color.RGBA\n\tStride int\n\tRect   Rect\n}\n\n// MakePictureData creates a zero-initialized PictureData covering the given rectangle.\nfunc MakePictureData(rect Rect) *PictureData {\n\tw := int(math.Ceil(rect.Max.X)) - int(math.Floor(rect.Min.X))\n\th := int(math.Ceil(rect.Max.Y)) - int(math.Floor(rect.Min.Y))\n\tpd := &PictureData{\n\t\tStride: w,\n\t\tRect:   rect,\n\t}\n\tpd.Pix = make([]color.RGBA, w*h)\n\treturn pd\n}\n\nfunc verticalFlip(rgba *image.RGBA) {\n\tbounds := rgba.Bounds()\n\twidth := bounds.Dx()\n\n\ttmpRow := make([]uint8, width*4)\n\tfor i, j := 0, bounds.Dy()-1; i < j; i, j = i+1, j-1 {\n\t\tiRow := rgba.Pix[i*rgba.Stride : i*rgba.Stride+width*4]\n\t\tjRow := rgba.Pix[j*rgba.Stride : j*rgba.Stride+width*4]\n\n\t\tcopy(tmpRow, iRow)\n\t\tcopy(iRow, jRow)\n\t\tcopy(jRow, tmpRow)\n\t}\n}\n\n// PictureDataFromImage converts an image.Image into PictureData.\n//\n// The resulting PictureData's Bounds will be the equivalent of the supplied image.Image's Bounds.\nfunc PictureDataFromImage(img image.Image) *PictureData {\n\trgba := image.NewRGBA(img.Bounds())\n\tdraw.Draw(rgba, rgba.Bounds(), img, img.Bounds().Min, draw.Src)\n\n\tverticalFlip(rgba)\n\n\tpd := MakePictureData(R(\n\t\tfloat64(rgba.Bounds().Min.X),\n\t\tfloat64(rgba.Bounds().Min.Y),\n\t\tfloat64(rgba.Bounds().Max.X),\n\t\tfloat64(rgba.Bounds().Max.Y),\n\t))\n\n\tfor i := range pd.Pix {\n\t\tpd.Pix[i].R = rgba.Pix[i*4+0]\n\t\tpd.Pix[i].G = rgba.Pix[i*4+1]\n\t\tpd.Pix[i].B = rgba.Pix[i*4+2]\n\t\tpd.Pix[i].A = rgba.Pix[i*4+3]\n\t}\n\n\treturn pd\n}\n\n// PictureDataFromPicture converts an arbitrary Picture into PictureData (the conversion may be\n// lossy, because PictureData works with unit-sized pixels).\n//\n// Bounds are preserved.\nfunc PictureDataFromPicture(pic Picture) *PictureData {\n\tif pd, ok := pic.(*PictureData); ok {\n\t\treturn pd\n\t}\n\n\tbounds := pic.Bounds()\n\tpd := MakePictureData(bounds)\n\n\tif pic, ok := pic.(PictureColor); ok {\n\t\tfor y := math.Floor(bounds.Min.Y); y < bounds.Max.Y; y++ {\n\t\t\tfor x := math.Floor(bounds.Min.X); x < bounds.Max.X; x++ {\n\t\t\t\t// this together with the Floor is a trick to get all of the pixels\n\t\t\t\tat := V(\n\t\t\t\t\tmath.Max(x, bounds.Min.X),\n\t\t\t\t\tmath.Max(y, bounds.Min.Y),\n\t\t\t\t)\n\t\t\t\tcol := pic.Color(at)\n\t\t\t\tpd.Pix[pd.Index(at)] = color.RGBA{\n\t\t\t\t\tR: uint8(col.R * 255),\n\t\t\t\t\tG: uint8(col.G * 255),\n\t\t\t\t\tB: uint8(col.B * 255),\n\t\t\t\t\tA: uint8(col.A * 255),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pd\n}\n\n// Image converts PictureData into an image.RGBA.\n//\n// The resulting image.RGBA's Bounds will be equivalent of the PictureData's Bounds.\nfunc (pd *PictureData) Image() *image.RGBA {\n\tbounds := image.Rect(\n\t\tint(math.Floor(pd.Rect.Min.X)),\n\t\tint(math.Floor(pd.Rect.Min.Y)),\n\t\tint(math.Ceil(pd.Rect.Max.X)),\n\t\tint(math.Ceil(pd.Rect.Max.Y)),\n\t)\n\trgba := image.NewRGBA(bounds)\n\n\ti := 0\n\tfor y := bounds.Min.Y; y < bounds.Max.Y; y++ {\n\t\tfor x := bounds.Min.X; x < bounds.Max.X; x++ {\n\t\t\toff := pd.Index(V(float64(x), float64(y)))\n\t\t\trgba.Pix[i*4+0] = pd.Pix[off].R\n\t\t\trgba.Pix[i*4+1] = pd.Pix[off].G\n\t\t\trgba.Pix[i*4+2] = pd.Pix[off].B\n\t\t\trgba.Pix[i*4+3] = pd.Pix[off].A\n\t\t\ti++\n\t\t}\n\t}\n\n\tverticalFlip(rgba)\n\n\treturn rgba\n}\n\n// Index returns the index of the pixel at the specified position inside the Pix slice.\nfunc (pd *PictureData) Index(at Vec) int {\n\tat = at.Sub(pd.Rect.Min.Map(math.Floor))\n\tx, y := int(at.X), int(at.Y)\n\treturn y*pd.Stride + x\n}\n\n// Bounds returns the bounds of this PictureData.\nfunc (pd *PictureData) Bounds() Rect {\n\treturn pd.Rect\n}\n\n// Color returns the color located at the given position.\nfunc (pd *PictureData) Color(at Vec) RGBA {\n\tif !pd.Rect.Contains(at) {\n\t\treturn RGBA{0, 0, 0, 0}\n\t}\n\treturn ToRGBA(pd.Pix[pd.Index(at)])\n}\n"
        },
        {
          "name": "data_test.go",
          "type": "blob",
          "size": 5.3759765625,
          "content": "package pixel_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/faiface/pixel\"\n)\n\nfunc BenchmarkMakeTrianglesData(b *testing.B) {\n\ttests := []struct {\n\t\tname string\n\t\tlen  int\n\t}{\n\t\t{\n\t\t\tname: \"Small slice\",\n\t\t\tlen:  10,\n\t\t},\n\t\t{\n\t\t\tname: \"Large slice\",\n\t\t\tlen:  10000,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = pixel.MakeTrianglesData(tt.len)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTrianglesData_Len(b *testing.B) {\n\ttests := []struct {\n\t\tname  string\n\t\ttData *pixel.TrianglesData\n\t}{\n\t\t{\n\t\t\tname:  \"Small slice\",\n\t\t\ttData: pixel.MakeTrianglesData(10),\n\t\t},\n\t\t{\n\t\t\tname:  \"Large slice\",\n\t\t\ttData: pixel.MakeTrianglesData(10000),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = tt.tData.Len()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTrianglesData_SetLen(b *testing.B) {\n\ttests := []struct {\n\t\tname        string\n\t\ttData       *pixel.TrianglesData\n\t\tnextLenFunc func(int, int) (int, int)\n\t}{\n\t\t{\n\t\t\tname:        \"Stay same size\",\n\t\t\ttData:       pixel.MakeTrianglesData(50),\n\t\t\tnextLenFunc: func(i, j int) (int, int) { return 50, 0 },\n\t\t},\n\t\t{\n\t\t\tname:  \"Change size\",\n\t\t\ttData: pixel.MakeTrianglesData(50),\n\t\t\tnextLenFunc: func(i, j int) (int, int) {\n\t\t\t\t// 0 is shrink\n\t\t\t\tif j == 0 {\n\t\t\t\t\tnext := i - 1\n\t\t\t\t\tif next < 1 {\n\t\t\t\t\t\treturn 2, 1\n\t\t\t\t\t}\n\t\t\t\t\treturn next, 0\n\t\t\t\t}\n\n\t\t\t\t// other than 0 is grow\n\t\t\t\tnext := i + 1\n\t\t\t\tif next == 100 {\n\t\t\t\t\treturn next, 0\n\t\t\t\t}\n\t\t\t\treturn next, 1\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tvar newLen int\n\t\t\tvar c int\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tnewLen, c = tt.nextLenFunc(newLen, c)\n\t\t\t\ttt.tData.SetLen(newLen)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTrianglesData_Slice(b *testing.B) {\n\ttests := []struct {\n\t\tname  string\n\t\ttData *pixel.TrianglesData\n\t}{\n\t\t{\n\t\t\tname:  \"Basic slice\",\n\t\t\ttData: pixel.MakeTrianglesData(100),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = tt.tData.Slice(25, 50)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTrianglesData_Update(b *testing.B) {\n\ttests := []struct {\n\t\tname  string\n\t\ttData *pixel.TrianglesData\n\t\tt     pixel.Triangles\n\t}{\n\t\t{\n\t\t\tname:  \"Small Triangles\",\n\t\t\ttData: pixel.MakeTrianglesData(20),\n\t\t\tt:     pixel.MakeTrianglesData(20),\n\t\t},\n\t\t{\n\t\t\tname:  \"Large Triangles\",\n\t\t\ttData: pixel.MakeTrianglesData(10000),\n\t\t\tt:     pixel.MakeTrianglesData(10000),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\ttt.tData.Update(tt.t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTrianglesData_Copy(b *testing.B) {\n\ttests := []struct {\n\t\tname  string\n\t\ttData *pixel.TrianglesData\n\t}{\n\t\t{\n\t\t\tname:  \"Small copy\",\n\t\t\ttData: pixel.MakeTrianglesData(20),\n\t\t},\n\t\t{\n\t\t\tname:  \"Large copy\",\n\t\t\ttData: pixel.MakeTrianglesData(10000),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = tt.tData.Copy()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTrianglesData_Position(b *testing.B) {\n\ttests := []struct {\n\t\tname     string\n\t\ttData    *pixel.TrianglesData\n\t\tposition int\n\t}{\n\t\t{\n\t\t\tname:     \"Getting beginning position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Getting middle position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 500,\n\t\t},\n\t\t{\n\t\t\tname:     \"Getting end position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 999,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = tt.tData.Position(tt.position)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTrianglesData_Color(b *testing.B) {\n\ttests := []struct {\n\t\tname     string\n\t\ttData    *pixel.TrianglesData\n\t\tposition int\n\t}{\n\t\t{\n\t\t\tname:     \"Getting beginning position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Getting middle position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 500,\n\t\t},\n\t\t{\n\t\t\tname:     \"Getting end position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 999,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = tt.tData.Color(tt.position)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTrianglesData_Picture(b *testing.B) {\n\ttests := []struct {\n\t\tname     string\n\t\ttData    *pixel.TrianglesData\n\t\tposition int\n\t}{\n\t\t{\n\t\t\tname:     \"Getting beginning position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Getting middle position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 500,\n\t\t},\n\t\t{\n\t\t\tname:     \"Getting end position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 999,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_, _ = tt.tData.Picture(tt.position)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTrianglesData_ClipRect(b *testing.B) {\n\ttests := []struct {\n\t\tname     string\n\t\ttData    *pixel.TrianglesData\n\t\tposition int\n\t}{\n\t\t{\n\t\t\tname:     \"Getting beginning position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Getting middle position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 500,\n\t\t},\n\t\t{\n\t\t\tname:     \"Getting end position\",\n\t\t\ttData:    pixel.MakeTrianglesData(1000),\n\t\t\tposition: 999,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_, _ = tt.tData.ClipRect(tt.position)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.3525390625,
          "content": "// Package pixel implements platform and backend agnostic core of the Pixel game development\n// library.\n//\n// It specifies the core Target, Triangles, Picture pattern and implements standard elements, such\n// as Sprite, Batch, Vec, Matrix and RGBA in addition to the basic Triangles and Picture\n// implementations: TrianglesData and PictureData.\npackage pixel\n"
        },
        {
          "name": "drawer.go",
          "type": "blob",
          "size": 2.357421875,
          "content": "package pixel\n\n// Drawer glues all the fundamental interfaces (Target, Triangles, Picture) into a coherent and the\n// only intended usage pattern.\n//\n// Drawer makes it possible to draw any combination of Triangles and Picture onto any Target\n// efficiently.\n//\n// To create a Drawer, just assign it's Triangles and Picture fields:\n//\n//   d := pixel.Drawer{Triangles: t, Picture: p}\n//\n// If Triangles is nil, nothing will be drawn. If Picture is nil, Triangles will be drawn without a\n// Picture.\n//\n// Whenever you change the Triangles, call Dirty to notify Drawer that Triangles changed. You don't\n// need to notify Drawer about a change of the Picture.\n//\n// Note, that Drawer caches the results of MakePicture from Targets it's drawn to for each Picture\n// it's set to. What it means is that using a Drawer with an unbounded number of Pictures leads to a\n// memory leak, since Drawer caches them and never forgets. In such a situation, create a new Drawer\n// for each Picture.\ntype Drawer struct {\n\tTriangles Triangles\n\tPicture   Picture\n\tCached    bool\n\n\ttargets    map[Target]*drawerTarget\n\tallTargets []*drawerTarget\n\tinited     bool\n}\n\ntype drawerTarget struct {\n\ttris  TargetTriangles\n\tpics  map[Picture]TargetPicture\n\tclean bool\n}\n\nfunc (d *Drawer) lazyInit() {\n\tif !d.inited {\n\t\td.targets = make(map[Target]*drawerTarget)\n\t\td.inited = true\n\t}\n}\n\n// Dirty marks the Triangles of this Drawer as changed. If not called, changes will not be visible\n// when drawing.\nfunc (d *Drawer) Dirty() {\n\td.lazyInit()\n\n\tfor _, t := range d.allTargets {\n\t\tt.clean = false\n\t}\n}\n\n// Draw efficiently draws Triangles with Picture onto the provided Target.\n//\n// If Triangles is nil, nothing will be drawn. If Picture is nil, Triangles will be drawn without a\n// Picture.\nfunc (d *Drawer) Draw(t Target) {\n\td.lazyInit()\n\n\tif d.Triangles == nil {\n\t\treturn\n\t}\n\n\tdt := d.targets[t]\n\tif dt == nil {\n\t\tdt = &drawerTarget{\n\t\t\tpics: make(map[Picture]TargetPicture),\n\t\t}\n\t\td.targets[t] = dt\n\t\td.allTargets = append(d.allTargets, dt)\n\t}\n\n\tif dt.tris == nil {\n\t\tdt.tris = t.MakeTriangles(d.Triangles)\n\t\tdt.clean = true\n\t}\n\n\tif !dt.clean {\n\t\tdt.tris.SetLen(d.Triangles.Len())\n\t\tdt.tris.Update(d.Triangles)\n\t\tdt.clean = true\n\t}\n\n\tif d.Picture == nil {\n\t\tdt.tris.Draw()\n\t\treturn\n\t}\n\n\tpic := dt.pics[d.Picture]\n\tif pic == nil {\n\t\tpic = t.MakePicture(d.Picture)\n\n\t\tif d.Cached {\n\t\t\tdt.pics[d.Picture] = pic\n\t\t}\n\t}\n\n\tpic.Draw(dt.tris)\n}\n"
        },
        {
          "name": "drawer_test.go",
          "type": "blob",
          "size": 0.37890625,
          "content": "package pixel_test\n\nimport (\n\t\"image\"\n\t\"testing\"\n\n\t\"github.com/faiface/pixel\"\n)\n\nfunc BenchmarkSpriteDrawBatch(b *testing.B) {\n\timg := image.NewRGBA(image.Rect(0, 0, 64, 64))\n\tpic := pixel.PictureDataFromImage(img)\n\tsprite := pixel.NewSprite(pic, pixel.R(0, 0, 64, 64))\n\tbatch := pixel.NewBatch(&pixel.TrianglesData{}, pic)\n\tfor i := 0; i < b.N; i++ {\n\t\tsprite.Draw(batch, pixel.IM)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.48046875,
          "content": "module github.com/faiface/pixel\n\ngo 1.12\n\nrequire (\n\tgithub.com/faiface/glhf v0.0.0-20211013000516-57b20770c369\n\tgithub.com/faiface/mainthread v0.0.0-20171120011319-8b78f0a41ae3\n\tgithub.com/go-gl/gl v0.0.0-20210905235341-f7a045908259\n\tgithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20210727001814-0db043d8d5be\n\tgithub.com/go-gl/mathgl v1.0.0\n\tgithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/stretchr/testify v1.7.0\n\tgolang.org/x/image v0.5.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.275390625,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/faiface/glhf v0.0.0-20211013000516-57b20770c369 h1:gv4BgP50atccdK/1tZHDyP6rMwiiutR2HPreR/OyLzI=\ngithub.com/faiface/glhf v0.0.0-20211013000516-57b20770c369/go.mod h1:dDdUO+G9ZnJ9sc8nIUvhLkE45k8PEKW6+A3TdWsfpV0=\ngithub.com/faiface/mainthread v0.0.0-20171120011319-8b78f0a41ae3 h1:baVdMKlASEHrj19iqjARrPbaRisD7EuZEVJj6ZMLl1Q=\ngithub.com/faiface/mainthread v0.0.0-20171120011319-8b78f0a41ae3/go.mod h1:VEPNJUlxl5KdWjDvz6Q1l+rJlxF2i6xqDeGuGAxa87M=\ngithub.com/go-gl/gl v0.0.0-20210905235341-f7a045908259 h1:8q7+xl2D2qHPLTII1t4vSMNP2VKwDcn+Avf2WXvdB1A=\ngithub.com/go-gl/gl v0.0.0-20210905235341-f7a045908259/go.mod h1:wjpnOv6ONl2SuJSxqCPVaPZibGFdSci9HFocT9qtVYM=\ngithub.com/go-gl/glfw v0.0.0-20210727001814-0db043d8d5be h1:UVW91pfMB1GRQfVwC7//RGVbqX6Ea8jURmJhlANak1M=\ngithub.com/go-gl/glfw v0.0.0-20210727001814-0db043d8d5be/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20210727001814-0db043d8d5be h1:vEIVIuBApEBQTEJt19GfhoU+zFSV+sNTa9E9FdnRYfk=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20210727001814-0db043d8d5be/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-gl/mathgl v1.0.0 h1:t9DznWJlXxxjeeKLIdovCOVJQk/GzDEL7h/h+Ro2B68=\ngithub.com/go-gl/mathgl v1.0.0/go.mod h1:yhpkQzEiH9yPyxDUGzkmgScbaBVlhC06qodikEM0ZwQ=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 h1:DACJavvAHhabrF08vX0COfcOBJRhZ8lUbR+ZWIs0Y5g=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/image v0.0.0-20190321063152-3fc05d484e9f/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\ngolang.org/x/image v0.5.0 h1:5JMiNunQeQw++mMOz48/ISeNu3Iweh/JaZU8ZLqHRrI=\ngolang.org/x/image v0.5.0/go.mod h1:FVC7BI/5Ym8R25iw5OLsgshdUBbT1h5jZTpA+mvAdZ4=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "imdraw",
          "type": "tree",
          "content": null
        },
        {
          "name": "interface.go",
          "type": "blob",
          "size": 5.287109375,
          "content": "package pixel\n\nimport \"image/color\"\n\n// Target is something that can be drawn onto, such as a window, a canvas, and so on.\n//\n// You can notice, that there are no \"drawing\" methods in a Target. That's because all drawing\n// happens indirectly through Triangles and Picture instances generated via MakeTriangles and\n// MakePicture method.\ntype Target interface {\n\t// MakeTriangles generates a specialized copy of the provided Triangles.\n\t//\n\t// When calling Draw method on the returned TargetTriangles, the TargetTriangles will be\n\t// drawn onto the Target that generated them.\n\t//\n\t// Note, that not every Target has to recognize all possible types of Triangles. Some may\n\t// only recognize TrianglesPosition and TrianglesColor and ignore all other properties (if\n\t// present) when making new TargetTriangles. This varies from Target to Target.\n\tMakeTriangles(Triangles) TargetTriangles\n\n\t// MakePicture generates a specialized copy of the provided Picture.\n\t//\n\t// When calling Draw method on the returned TargetPicture, the TargetPicture will be drawn\n\t// onto the Target that generated it together with the TargetTriangles supplied to the Draw\n\t// method.\n\tMakePicture(Picture) TargetPicture\n}\n\n// BasicTarget is a Target with additional basic adjustment methods.\ntype BasicTarget interface {\n\tTarget\n\n\t// SetMatrix sets a Matrix that every point will be projected by.\n\tSetMatrix(Matrix)\n\n\t// SetColorMask sets a color that will be multiplied with the TrianglesColor property of all\n\t// Triangles.\n\tSetColorMask(color.Color)\n}\n\n// Triangles represents a list of vertices, where each three vertices form a triangle. (First,\n// second and third is the first triangle, fourth, fifth and sixth is the second triangle, etc.)\ntype Triangles interface {\n\t// Len returns the number of vertices. The number of triangles is the number of vertices\n\t// divided by 3.\n\tLen() int\n\n\t// SetLen resizes Triangles to len vertices. If Triangles B were obtained by calling Slice\n\t// method on Triangles A, the relationship between A and B is undefined after calling SetLen\n\t// on either one of them.\n\tSetLen(len int)\n\n\t// Slice returns a sub-Triangles of this Triangles, covering vertices in range [i, j).\n\t//\n\t// If Triangles B were obtained by calling Slice(4, 9) on Triangles A, then A and B must\n\t// share the same underlying data. Modifying B must change the contents of A in range\n\t// [4, 9). The vertex with index 0 at B is the vertex with index 4 in A, and so on.\n\t//\n\t// Returned Triangles must have the same underlying type.\n\tSlice(i, j int) Triangles\n\n\t// Update copies vertex properties from the supplied Triangles into this Triangles.\n\t//\n\t// Properies not supported by these Triangles should be ignored. Properties not supported by\n\t// the supplied Triangles should be left untouched.\n\t//\n\t// The two Triangles must have the same Len.\n\tUpdate(Triangles)\n\n\t// Copy creates an exact independent copy of this Triangles (with the same underlying type).\n\tCopy() Triangles\n}\n\n// TargetTriangles are Triangles generated by a Target with MakeTriangles method. They can be drawn\n// onto that (no other) Target.\ntype TargetTriangles interface {\n\tTriangles\n\n\t// Draw draws Triangles onto an associated Target.\n\tDraw()\n}\n\n// TrianglesPosition specifies Triangles with Position property.\ntype TrianglesPosition interface {\n\tTriangles\n\tPosition(i int) Vec\n}\n\n// TrianglesColor specifies Triangles with Color property.\ntype TrianglesColor interface {\n\tTriangles\n\tColor(i int) RGBA\n}\n\n// TrianglesPicture specifies Triangles with Picture property.\n//\n// The first value returned from Picture method is Picture coordinates. The second one specifies the\n// weight of the Picture. Value of 0 means, that Picture should be completely ignored, 1 means that\n// is should be fully included and anything in between means anything in between.\ntype TrianglesPicture interface {\n\tTriangles\n\tPicture(i int) (pic Vec, intensity float64)\n}\n\n// TrianglesClipped specifies Triangles with Clipping Rectangle property.\n//\n// The first value returned from ClipRect method is the clipping rectangle. The second one specifies\n// if the triangle is clipped.\ntype TrianglesClipped interface {\n\tTriangles\n\tClipRect(i int) (rect Rect, is bool)\n}\n\n// Picture represents a rectangular area of raster data, such as a color. It has Bounds which\n// specify the rectangle where data is located.\ntype Picture interface {\n\t// Bounds returns the rectangle of the Picture. All data is located within this rectangle.\n\t// Querying properties outside the rectangle should return default value of that property.\n\tBounds() Rect\n}\n\n// TargetPicture is a Picture generated by a Target using MakePicture method. This Picture can be drawn onto\n// that (no other) Target together with a TargetTriangles generated by the same Target.\n//\n// The TargetTriangles specify where, shape and how the Picture should be drawn.\ntype TargetPicture interface {\n\tPicture\n\n\t// Draw draws the supplied TargetTriangles (which must be generated by the same Target as\n\t// this TargetPicture) with this TargetPicture. The TargetTriangles should utilize the data\n\t// from this TargetPicture in some way.\n\tDraw(TargetTriangles)\n}\n\n// PictureColor specifies Picture with Color property, so that every position inside the Picture's\n// Bounds has a color.\n//\n// Positions outside the Picture's Bounds must return full transparent (Alpha(0)).\ntype PictureColor interface {\n\tPicture\n\tColor(at Vec) RGBA\n}\n"
        },
        {
          "name": "line_test.go",
          "type": "blob",
          "size": 15.890625,
          "content": "package pixel_test\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/faiface/pixel\"\n)\n\nfunc TestLine_Bounds(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   pixel.Rect\n\t}{\n\t\t{\n\t\t\tname:   \"Positive slope\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\twant:   pixel.R(0, 0, 10, 10),\n\t\t},\n\t\t{\n\t\t\tname:   \"Negative slope\",\n\t\t\tfields: fields{A: pixel.V(10, 10), B: pixel.V(0, 0)},\n\t\t\twant:   pixel.R(0, 0, 10, 10),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.Bounds(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Line.Bounds() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_Center(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   pixel.Vec\n\t}{\n\t\t{\n\t\t\tname:   \"Positive slope\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\twant:   pixel.V(5, 5),\n\t\t},\n\t\t{\n\t\t\tname:   \"Negative slope\",\n\t\t\tfields: fields{A: pixel.V(10, 10), B: pixel.V(0, 0)},\n\t\t\twant:   pixel.V(5, 5),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.Center(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Line.Center() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_Closest(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttype args struct {\n\t\tv pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Vec\n\t}{\n\t\t{\n\t\t\tname:   \"Point on line\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{v: pixel.V(5, 5)},\n\t\t\twant:   pixel.V(5, 5),\n\t\t},\n\t\t{\n\t\t\tname:   \"Point on next to line\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{v: pixel.V(0, 10)},\n\t\t\twant:   pixel.V(5, 5),\n\t\t},\n\t\t{\n\t\t\tname:   \"Point on next to vertical line\",\n\t\t\tfields: fields{A: pixel.V(5, 0), B: pixel.V(5, 10)},\n\t\t\targs:   args{v: pixel.V(6, 5)},\n\t\t\twant:   pixel.V(5, 5),\n\t\t},\n\t\t{\n\t\t\tname:   \"Point on next to horizontal line\",\n\t\t\tfields: fields{A: pixel.V(0, 5), B: pixel.V(10, 5)},\n\t\t\targs:   args{v: pixel.V(5, 6)},\n\t\t\twant:   pixel.V(5, 5),\n\t\t},\n\t\t{\n\t\t\tname:   \"Point far from line\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{v: pixel.V(80, -70)},\n\t\t\twant:   pixel.V(5, 5),\n\t\t},\n\t\t{\n\t\t\tname:   \"Point on inline with line\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{v: pixel.V(20, 20)},\n\t\t\twant:   pixel.V(10, 10),\n\t\t},\n\t\t{\n\t\t\tname:   \"Vertical line\",\n\t\t\tfields: fields{A: pixel.V(0, -10), B: pixel.V(0, 10)},\n\t\t\targs:   args{v: pixel.V(-1, 0)},\n\t\t\twant:   pixel.V(0, 0),\n\t\t},\n\t\t{\n\t\t\tname:   \"Horizontal line\",\n\t\t\tfields: fields{A: pixel.V(-10, 0), B: pixel.V(10, 0)},\n\t\t\targs:   args{v: pixel.V(0, -1)},\n\t\t\twant:   pixel.V(0, 0),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.Closest(tt.args.v); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Line.Closest() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_Contains(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttype args struct {\n\t\tv pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"Point on line\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{v: pixel.V(5, 5)},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Point on negative sloped line\",\n\t\t\tfields: fields{A: pixel.V(0, 10), B: pixel.V(10, 0)},\n\t\t\targs:   args{v: pixel.V(5, 5)},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Point not on line\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{v: pixel.V(0, 10)},\n\t\t\twant:   false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.Contains(tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Line.Contains() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_Formula(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twantM  float64\n\t\twantB  float64\n\t}{\n\t\t{\n\t\t\tname:   \"Getting formula - 45 degs\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\twantM:  1,\n\t\t\twantB:  0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Getting formula - 90 degs\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(0, 10)},\n\t\t\twantM:  math.Inf(1),\n\t\t\twantB:  math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname:   \"Getting formula - 0 degs\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 0)},\n\t\t\twantM:  0,\n\t\t\twantB:  0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tgotM, gotB := l.Formula()\n\t\t\tif gotM != tt.wantM {\n\t\t\t\tt.Errorf(\"Line.Formula() gotM = %v, want %v\", gotM, tt.wantM)\n\t\t\t}\n\t\t\tif gotB != tt.wantB {\n\t\t\t\tif math.IsNaN(tt.wantB) && !math.IsNaN(gotB) {\n\t\t\t\t\tt.Errorf(\"Line.Formula() gotB = %v, want %v\", gotB, tt.wantB)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_Intersect(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttype args struct {\n\t\tk pixel.Line\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Vec\n\t\twant1  bool\n\t}{\n\t\t{\n\t\t\tname:   \"Lines intersect\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{k: pixel.L(pixel.V(0, 10), pixel.V(10, 0))},\n\t\t\twant:   pixel.V(5, 5),\n\t\t\twant1:  true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Lines intersect 2\",\n\t\t\tfields: fields{A: pixel.V(5, 1), B: pixel.V(1, 1)},\n\t\t\targs:   args{k: pixel.L(pixel.V(2, 0), pixel.V(2, 3))},\n\t\t\twant:   pixel.V(2, 1),\n\t\t\twant1:  true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Line intersect with vertical\",\n\t\t\tfields: fields{A: pixel.V(5, 0), B: pixel.V(5, 10)},\n\t\t\targs:   args{k: pixel.L(pixel.V(0, 0), pixel.V(10, 10))},\n\t\t\twant:   pixel.V(5, 5),\n\t\t\twant1:  true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Line intersect with horizontal\",\n\t\t\tfields: fields{A: pixel.V(0, 5), B: pixel.V(10, 5)},\n\t\t\targs:   args{k: pixel.L(pixel.V(0, 0), pixel.V(10, 10))},\n\t\t\twant:   pixel.V(5, 5),\n\t\t\twant1:  true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Lines don't intersect\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{k: pixel.L(pixel.V(0, 10), pixel.V(1, 20))},\n\t\t\twant:   pixel.ZV,\n\t\t\twant1:  false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Lines don't intersect 2\",\n\t\t\tfields: fields{A: pixel.V(1, 1), B: pixel.V(1, 5)},\n\t\t\targs:   args{k: pixel.L(pixel.V(-5, 0), pixel.V(-2, 2))},\n\t\t\twant:   pixel.ZV,\n\t\t\twant1:  false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Lines don't intersect 3\",\n\t\t\tfields: fields{A: pixel.V(2, 0), B: pixel.V(2, 3)},\n\t\t\targs:   args{k: pixel.L(pixel.V(1, 5), pixel.V(5, 5))},\n\t\t\twant:   pixel.ZV,\n\t\t\twant1:  false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Lines parallel\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{k: pixel.L(pixel.V(0, 1), pixel.V(10, 11))},\n\t\t\twant:   pixel.ZV,\n\t\t\twant1:  false,\n\t\t}, {\n\t\t\tname:   \"Lines intersect\",\n\t\t\tfields: fields{A: pixel.V(600, 600), B: pixel.V(925, 150)},\n\t\t\targs:   args{k: pixel.L(pixel.V(740, 255), pixel.V(925, 255))},\n\t\t\twant:   pixel.V(849.1666666666666, 255),\n\t\t\twant1:  true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Lines intersect\",\n\t\t\tfields: fields{A: pixel.V(600, 600), B: pixel.V(925, 150)},\n\t\t\targs:   args{k: pixel.L(pixel.V(740, 255), pixel.V(925, 255.0001))},\n\t\t\twant:   pixel.V(849.1666240490657, 255.000059008986),\n\t\t\twant1:  true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tgot, got1 := l.Intersect(tt.args.k)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Line.Intersect() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"Line.Intersect() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_IntersectCircle(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttype args struct {\n\t\tc pixel.Circle\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Vec\n\t}{\n\t\t{\n\t\t\tname:   \"Cirle intersects\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(6, 4), 2)},\n\t\t\twant:   pixel.V(0.5857864376269049, -0.5857864376269049),\n\t\t},\n\t\t{\n\t\t\tname:   \"Cirle doesn't intersects\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(0, 5), 1)},\n\t\t\twant:   pixel.ZV,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.IntersectCircle(tt.args.c); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Line.IntersectCircle() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_IntersectRect(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttype args struct {\n\t\tr pixel.Rect\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Vec\n\t}{\n\t\t{\n\t\t\tname:   \"Line through rect vertically\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(0, 10)},\n\t\t\targs:   args{r: pixel.R(-1, 1, 5, 5)},\n\t\t\twant:   pixel.V(-1, 0),\n\t\t},\n\t\t{\n\t\t\tname:   \"Line through rect horizontally\",\n\t\t\tfields: fields{A: pixel.V(0, 1), B: pixel.V(10, 1)},\n\t\t\targs:   args{r: pixel.R(1, 0, 5, 5)},\n\t\t\twant:   pixel.V(0, -1),\n\t\t},\n\t\t{\n\t\t\tname:   \"Line through rect diagonally bottom and left edges\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{r: pixel.R(0, 2, 3, 3)},\n\t\t\twant:   pixel.V(-1, 1),\n\t\t},\n\t\t{\n\t\t\tname:   \"Line through rect diagonally top and right edges\",\n\t\t\tfields: fields{A: pixel.V(10, 0), B: pixel.V(0, 10)},\n\t\t\targs:   args{r: pixel.R(5, 0, 8, 3)},\n\t\t\twant:   pixel.V(-2.5, -2.5),\n\t\t},\n\t\t{\n\t\t\tname:   \"Line with not rect intersect\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{r: pixel.R(20, 20, 21, 21)},\n\t\t\twant:   pixel.ZV,\n\t\t},\n\t\t{\n\t\t\tname:   \"Line intersects at 0,0\",\n\t\t\tfields: fields{A: pixel.V(0, -10), B: pixel.V(0, 10)},\n\t\t\targs:   args{r: pixel.R(-1, 0, 2, 2)},\n\t\t\twant:   pixel.V(-1, 0),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.IntersectRect(tt.args.r); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Line.IntersectRect() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_Len(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   float64\n\t}{\n\t\t{\n\t\t\tname:   \"End right-up of start\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(3, 4)},\n\t\t\twant:   5,\n\t\t},\n\t\t{\n\t\t\tname:   \"End left-up of start\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(-3, 4)},\n\t\t\twant:   5,\n\t\t},\n\t\t{\n\t\t\tname:   \"End right-down of start\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(3, -4)},\n\t\t\twant:   5,\n\t\t},\n\t\t{\n\t\t\tname:   \"End left-down of start\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(-3, -4)},\n\t\t\twant:   5,\n\t\t},\n\t\t{\n\t\t\tname:   \"End same as start\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(0, 0)},\n\t\t\twant:   0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.Len(); got != tt.want {\n\t\t\t\tt.Errorf(\"Line.Len() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_Rotated(t *testing.T) {\n\t// round returns the nearest integer, rounding ties away from zero.\n\t// This is required because `math.Round` wasn't introduced until Go1.10\n\tround := func(x float64) float64 {\n\t\tt := math.Trunc(x)\n\t\tif math.Abs(x-t) >= 0.5 {\n\t\t\treturn t + math.Copysign(1, x)\n\t\t}\n\t\treturn t\n\t}\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttype args struct {\n\t\taround pixel.Vec\n\t\tangle  float64\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Line\n\t}{\n\t\t{\n\t\t\tname:   \"Rotating around line center\",\n\t\t\tfields: fields{A: pixel.V(1, 1), B: pixel.V(3, 3)},\n\t\t\targs:   args{around: pixel.V(2, 2), angle: math.Pi},\n\t\t\twant:   pixel.L(pixel.V(3, 3), pixel.V(1, 1)),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rotating around x-y origin\",\n\t\t\tfields: fields{A: pixel.V(1, 1), B: pixel.V(3, 3)},\n\t\t\targs:   args{around: pixel.V(0, 0), angle: math.Pi},\n\t\t\twant:   pixel.L(pixel.V(-1, -1), pixel.V(-3, -3)),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rotating around line end\",\n\t\t\tfields: fields{A: pixel.V(1, 1), B: pixel.V(3, 3)},\n\t\t\targs:   args{around: pixel.V(1, 1), angle: math.Pi},\n\t\t\twant:   pixel.L(pixel.V(1, 1), pixel.V(-1, -1)),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\t// Have to round the results, due to floating-point in accuracies.  Results are correct to approximately\n\t\t\t// 10 decimal places.\n\t\t\tgot := l.Rotated(tt.args.around, tt.args.angle)\n\t\t\tif round(got.A.X) != tt.want.A.X ||\n\t\t\t\tround(got.B.X) != tt.want.B.X ||\n\t\t\t\tround(got.A.Y) != tt.want.A.Y ||\n\t\t\t\tround(got.B.Y) != tt.want.B.Y {\n\t\t\t\tt.Errorf(\"Line.Rotated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_Scaled(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttype args struct {\n\t\tscale float64\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Line\n\t}{\n\t\t{\n\t\t\tname:   \"Scaling by 1\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{scale: 1},\n\t\t\twant:   pixel.L(pixel.V(0, 0), pixel.V(10, 10)),\n\t\t},\n\t\t{\n\t\t\tname:   \"Scaling by >1\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{scale: 2},\n\t\t\twant:   pixel.L(pixel.V(-5, -5), pixel.V(15, 15)),\n\t\t},\n\t\t{\n\t\t\tname:   \"Scaling by <1\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{scale: 0.5},\n\t\t\twant:   pixel.L(pixel.V(2.5, 2.5), pixel.V(7.5, 7.5)),\n\t\t},\n\t\t{\n\t\t\tname:   \"Scaling by -1\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{scale: -1},\n\t\t\twant:   pixel.L(pixel.V(10, 10), pixel.V(0, 0)),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.Scaled(tt.args.scale); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Line.Scaled() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_ScaledXY(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttype args struct {\n\t\taround pixel.Vec\n\t\tscale  float64\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Line\n\t}{\n\t\t{\n\t\t\tname:   \"Scaling by 1 around origin\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{around: pixel.ZV, scale: 1},\n\t\t\twant:   pixel.L(pixel.V(0, 0), pixel.V(10, 10)),\n\t\t},\n\t\t{\n\t\t\tname:   \"Scaling by >1 around origin\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{around: pixel.ZV, scale: 2},\n\t\t\twant:   pixel.L(pixel.V(0, 0), pixel.V(20, 20)),\n\t\t},\n\t\t{\n\t\t\tname:   \"Scaling by <1 around origin\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{around: pixel.ZV, scale: 0.5},\n\t\t\twant:   pixel.L(pixel.V(0, 0), pixel.V(5, 5)),\n\t\t},\n\t\t{\n\t\t\tname:   \"Scaling by -1 around origin\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(10, 10)},\n\t\t\targs:   args{around: pixel.ZV, scale: -1},\n\t\t\twant:   pixel.L(pixel.V(0, 0), pixel.V(-10, -10)),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.ScaledXY(tt.args.around, tt.args.scale); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Line.ScaledXY() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLine_String(t *testing.T) {\n\ttype fields struct {\n\t\tA pixel.Vec\n\t\tB pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   string\n\t}{\n\t\t{\n\t\t\tname:   \"Getting string\",\n\t\t\tfields: fields{A: pixel.V(0, 0), B: pixel.V(1, 1)},\n\t\t\twant:   \"Line(Vec(0, 0), Vec(1, 1))\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tl := pixel.Line{\n\t\t\t\tA: tt.fields.A,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := l.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Line.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "logo",
          "type": "tree",
          "content": null
        },
        {
          "name": "math.go",
          "type": "blob",
          "size": 0.2919921875,
          "content": "package pixel\n\n// Clamp returns x clamped to the interval [min, max].\n//\n// If x is less than min, min is returned. If x is more than max, max is returned. Otherwise, x is\n// returned.\nfunc Clamp(x, min, max float64) float64 {\n\tif x < min {\n\t\treturn min\n\t}\n\tif x > max {\n\t\treturn max\n\t}\n\treturn x\n}\n"
        },
        {
          "name": "math_test.go",
          "type": "blob",
          "size": 1.267578125,
          "content": "package pixel_test\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/faiface/pixel\"\n)\n\n// closeEnough will shift the decimal point by the accuracy required, truncates the results and compares them.\n// Effectively this compares two floats to a given decimal point.\n//  Example:\n//  closeEnough(100.125342432, 100.125, 2) == true\n//  closeEnough(math.Pi, 3.14, 2) == true\n//  closeEnough(0.1234, 0.1245, 3) == false\nfunc closeEnough(got, expected float64, decimalAccuracy int) bool {\n\tgotShifted := got * math.Pow10(decimalAccuracy)\n\texpectedShifted := expected * math.Pow10(decimalAccuracy)\n\n\treturn math.Trunc(gotShifted) == math.Trunc(expectedShifted)\n}\n\ntype clampTest struct {\n\tnumber   float64\n\tmin      float64\n\tmax      float64\n\texpected float64\n}\n\nfunc TestClamp(t *testing.T) {\n\ttests := []clampTest{\n\t\t{number: 1, min: 0, max: 5, expected: 1},\n\t\t{number: 2, min: 0, max: 5, expected: 2},\n\t\t{number: 8, min: 0, max: 5, expected: 5},\n\t\t{number: -5, min: 0, max: 5, expected: 0},\n\t\t{number: -5, min: -4, max: 5, expected: -4},\n\t}\n\n\tfor _, tc := range tests {\n\t\tresult := pixel.Clamp(tc.number, tc.min, tc.max)\n\t\tif result != tc.expected {\n\t\t\tt.Error(fmt.Sprintf(\"Clamping %v with min %v and max %v should have given %v, but gave %v\", tc.number, tc.min, tc.max, tc.expected, result))\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "matrix.go",
          "type": "blob",
          "size": 2.86328125,
          "content": "package pixel\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// Matrix is a 2x3 affine matrix that can be used for all kinds of spatial transforms, such\n// as movement, scaling and rotations.\n//\n// Matrix has a handful of useful methods, each of which adds a transformation to the matrix. For\n// example:\n//\n//   pixel.IM.Moved(pixel.V(100, 200)).Rotated(pixel.ZV, math.Pi/2)\n//\n// This code creates a Matrix that first moves everything by 100 units horizontally and 200 units\n// vertically and then rotates everything by 90 degrees around the origin.\n//\n// Layout is:\n// [0] [2] [4]\n// [1] [3] [5]\n//  0   0   1  (implicit row)\ntype Matrix [6]float64\n\n// IM stands for identity matrix. Does nothing, no transformation.\nvar IM = Matrix{1, 0, 0, 1, 0, 0}\n\n// String returns a string representation of the Matrix.\n//\n//   m := pixel.IM\n//   fmt.Println(m) // Matrix(1 0 0 | 0 1 0)\nfunc (m Matrix) String() string {\n\treturn fmt.Sprintf(\n\t\t\"Matrix(%v %v %v | %v %v %v)\",\n\t\tm[0], m[2], m[4],\n\t\tm[1], m[3], m[5],\n\t)\n}\n\n// Moved moves everything by the delta vector.\nfunc (m Matrix) Moved(delta Vec) Matrix {\n\tm[4], m[5] = m[4]+delta.X, m[5]+delta.Y\n\treturn m\n}\n\n// ScaledXY scales everything around a given point by the scale factor in each axis respectively.\nfunc (m Matrix) ScaledXY(around Vec, scale Vec) Matrix {\n\tm[4], m[5] = m[4]-around.X, m[5]-around.Y\n\tm[0], m[2], m[4] = m[0]*scale.X, m[2]*scale.X, m[4]*scale.X\n\tm[1], m[3], m[5] = m[1]*scale.Y, m[3]*scale.Y, m[5]*scale.Y\n\tm[4], m[5] = m[4]+around.X, m[5]+around.Y\n\treturn m\n}\n\n// Scaled scales everything around a given point by the scale factor.\nfunc (m Matrix) Scaled(around Vec, scale float64) Matrix {\n\treturn m.ScaledXY(around, V(scale, scale))\n}\n\n// Rotated rotates everything around a given point by the given angle in radians.\nfunc (m Matrix) Rotated(around Vec, angle float64) Matrix {\n\tsint, cost := math.Sincos(angle)\n\tm[4], m[5] = m[4]-around.X, m[5]-around.Y\n\tm = m.Chained(Matrix{cost, sint, -sint, cost, 0, 0})\n\tm[4], m[5] = m[4]+around.X, m[5]+around.Y\n\treturn m\n}\n\n// Chained adds another Matrix to this one. All tranformations by the next Matrix will be applied\n// after the transformations of this Matrix.\nfunc (m Matrix) Chained(next Matrix) Matrix {\n\treturn Matrix{\n\t\tnext[0]*m[0] + next[2]*m[1],\n\t\tnext[1]*m[0] + next[3]*m[1],\n\t\tnext[0]*m[2] + next[2]*m[3],\n\t\tnext[1]*m[2] + next[3]*m[3],\n\t\tnext[0]*m[4] + next[2]*m[5] + next[4],\n\t\tnext[1]*m[4] + next[3]*m[5] + next[5],\n\t}\n}\n\n// Project applies all transformations added to the Matrix to a vector u and returns the result.\n//\n// Time complexity is O(1).\nfunc (m Matrix) Project(u Vec) Vec {\n\treturn Vec{m[0]*u.X + m[2]*u.Y + m[4], m[1]*u.X + m[3]*u.Y + m[5]}\n}\n\n// Unproject does the inverse operation to Project.\n//\n// Time complexity is O(1).\nfunc (m Matrix) Unproject(u Vec) Vec {\n\tdet := m[0]*m[3] - m[2]*m[1]\n\treturn Vec{\n\t\t(m[3]*(u.X-m[4]) - m[2]*(u.Y-m[5])) / det,\n\t\t(-m[1]*(u.X-m[4]) + m[0]*(u.Y-m[5])) / det,\n\t}\n}\n"
        },
        {
          "name": "matrix_test.go",
          "type": "blob",
          "size": 4.2197265625,
          "content": "package pixel_test\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"github.com/faiface/pixel\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc BenchmarkMatrix(b *testing.B) {\n\tb.Run(\"Moved\", func(b *testing.B) {\n\t\tm := pixel.IM\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tm = m.Moved(pixel.V(4.217, -132.99))\n\t\t}\n\t})\n\tb.Run(\"ScaledXY\", func(b *testing.B) {\n\t\tm := pixel.IM\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tm = m.ScaledXY(pixel.V(-5.1, 9.3), pixel.V(2.1, 0.98))\n\t\t}\n\t})\n\tb.Run(\"Rotated\", func(b *testing.B) {\n\t\tm := pixel.IM\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tm = m.Rotated(pixel.V(-5.1, 9.3), 1.4)\n\t\t}\n\t})\n\tb.Run(\"Chained\", func(b *testing.B) {\n\t\tvar m1, m2 pixel.Matrix\n\t\tfor i := range m1 {\n\t\t\tm1[i] = rand.Float64()\n\t\t\tm2[i] = rand.Float64()\n\t\t}\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tm1 = m1.Chained(m2)\n\t\t}\n\t})\n\tb.Run(\"Project\", func(b *testing.B) {\n\t\tvar m pixel.Matrix\n\t\tfor i := range m {\n\t\t\tm[i] = rand.Float64()\n\t\t}\n\t\tu := pixel.V(1, 1)\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tu = m.Project(u)\n\t\t}\n\t})\n\tb.Run(\"Unproject\", func(b *testing.B) {\n\tagain:\n\t\tvar m pixel.Matrix\n\t\tfor i := range m {\n\t\t\tm[i] = rand.Float64()\n\t\t}\n\t\tif (m[0]*m[3])-(m[1]*m[2]) == 0 { // zero determinant, not invertible\n\t\t\tgoto again\n\t\t}\n\t\tu := pixel.V(1, 1)\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tu = m.Unproject(u)\n\t\t}\n\t})\n}\n\nfunc TestMatrix_Unproject(t *testing.T) {\n\tconst delta = 1e-15\n\tt.Run(\"for rotated matrix\", func(t *testing.T) {\n\t\tmatrix := pixel.IM.\n\t\t\tRotated(pixel.ZV, math.Pi/2)\n\t\tunprojected := matrix.Unproject(pixel.V(0, 1))\n\t\tassert.InDelta(t, unprojected.X, 1, delta)\n\t\tassert.InDelta(t, unprojected.Y, 0, delta)\n\t})\n\tt.Run(\"for moved matrix\", func(t *testing.T) {\n\t\tmatrix := pixel.IM.\n\t\t\tMoved(pixel.V(1, 2))\n\t\tunprojected := matrix.Unproject(pixel.V(2, 5))\n\t\tassert.InDelta(t, unprojected.X, 1, delta)\n\t\tassert.InDelta(t, unprojected.Y, 3, delta)\n\t})\n\tt.Run(\"for scaled matrix\", func(t *testing.T) {\n\t\tmatrix := pixel.IM.\n\t\t\tScaled(pixel.ZV, 2)\n\t\tunprojected := matrix.Unproject(pixel.V(2, 4))\n\t\tassert.InDelta(t, unprojected.X, 1, delta)\n\t\tassert.InDelta(t, unprojected.Y, 2, delta)\n\t})\n\tt.Run(\"for scaled, rotated and moved matrix\", func(t *testing.T) {\n\t\tmatrix := pixel.IM.\n\t\t\tScaled(pixel.ZV, 2).\n\t\t\tRotated(pixel.ZV, math.Pi/2).\n\t\t\tMoved(pixel.V(2, 2))\n\t\tunprojected := matrix.Unproject(pixel.V(-2, 6))\n\t\tassert.InDelta(t, unprojected.X, 2, delta)\n\t\tassert.InDelta(t, unprojected.Y, 2, delta)\n\t})\n\tt.Run(\"for rotated and moved matrix\", func(t *testing.T) {\n\t\tmatrix := pixel.IM.\n\t\t\tRotated(pixel.ZV, math.Pi/2).\n\t\t\tMoved(pixel.V(1, 1))\n\t\tunprojected := matrix.Unproject(pixel.V(1, 2))\n\t\tassert.InDelta(t, unprojected.X, 1, delta)\n\t\tassert.InDelta(t, unprojected.Y, 0, delta)\n\t})\n\tt.Run(\"for projected vertices using all kinds of matrices\", func(t *testing.T) {\n\t\tnamedMatrices := map[string]pixel.Matrix{\n\t\t\t\"IM\":                        pixel.IM,\n\t\t\t\"Scaled\":                    pixel.IM.Scaled(pixel.ZV, 0.5),\n\t\t\t\"Scaled x 2\":                pixel.IM.Scaled(pixel.ZV, 2),\n\t\t\t\"Rotated\":                   pixel.IM.Rotated(pixel.ZV, math.Pi/4),\n\t\t\t\"Moved\":                     pixel.IM.Moved(pixel.V(0.5, 1)),\n\t\t\t\"Moved 2\":                   pixel.IM.Moved(pixel.V(-1, -0.5)),\n\t\t\t\"Scaled and Rotated\":        pixel.IM.Scaled(pixel.ZV, 0.5).Rotated(pixel.ZV, math.Pi/4),\n\t\t\t\"Scaled, Rotated and Moved\": pixel.IM.Scaled(pixel.ZV, 0.5).Rotated(pixel.ZV, math.Pi/4).Moved(pixel.V(1, 2)),\n\t\t\t\"Rotated and Moved\":         pixel.IM.Rotated(pixel.ZV, math.Pi/4).Moved(pixel.V(1, 2)),\n\t\t}\n\t\tvertices := [...]pixel.Vec{\n\t\t\tpixel.V(0, 0),\n\t\t\tpixel.V(5, 0),\n\t\t\tpixel.V(5, 10),\n\t\t\tpixel.V(0, 10),\n\t\t\tpixel.V(-5, 10),\n\t\t\tpixel.V(-5, 0),\n\t\t\tpixel.V(-5, -10),\n\t\t\tpixel.V(0, -10),\n\t\t\tpixel.V(5, -10),\n\t\t}\n\t\tfor matrixName, matrix := range namedMatrices {\n\t\t\tfor _, vertex := range vertices {\n\t\t\t\ttestCase := fmt.Sprintf(\"for matrix %s and vertex %v\", matrixName, vertex)\n\t\t\t\tt.Run(testCase, func(t *testing.T) {\n\t\t\t\t\tprojected := matrix.Project(vertex)\n\t\t\t\t\tunprojected := matrix.Unproject(projected)\n\t\t\t\t\tassert.InDelta(t, vertex.X, unprojected.X, delta)\n\t\t\t\t\tassert.InDelta(t, vertex.Y, unprojected.Y, delta)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"for singular matrix\", func(t *testing.T) {\n\t\tmatrix := pixel.Matrix{0, 0, 0, 0, 0, 0}\n\t\tunprojected := matrix.Unproject(pixel.ZV)\n\t\tassert.True(t, math.IsNaN(unprojected.X))\n\t\tassert.True(t, math.IsNaN(unprojected.Y))\n\t})\n}\n"
        },
        {
          "name": "pixel_test.go",
          "type": "blob",
          "size": 3.15625,
          "content": "package pixel_test\n\nimport (\n\t\"bytes\"\n\t\"image\"\n\t\"os\"\n\t\"testing\"\n\n\t_ \"image/png\"\n\n\t\"github.com/faiface/pixel\"\n\t\"github.com/faiface/pixel/pixelgl\"\n)\n\n// onePixelImage is the byte representation of a 1x1 solid white png file\nvar onePixelImage = []byte{\n\t137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 1, 0, 0, 0, 1, 8, 2,\n\t0, 0, 0, 144, 119, 83, 222, 0, 0, 1, 130, 105, 67, 67, 80, 73, 67, 67, 32, 112, 114, 111, 102, 105, 108, 101, 0,\n\t0, 40, 145, 125, 145, 59, 72, 3, 65, 20, 69, 143, 73, 68, 17, 37, 133, 41, 68, 44, 182, 80, 43, 5, 81, 17, 75,\n\t141, 66, 16, 34, 132, 168, 96, 212, 194, 221, 141, 137, 66, 118, 13, 187, 9, 54, 150, 130, 109, 192, 194, 79,\n\t227, 175, 176, 177, 214, 214, 194, 86, 16, 4, 63, 32, 54, 182, 86, 138, 54, 18, 214, 55, 73, 32, 65, 140, 3,\n\t195, 28, 238, 188, 123, 121, 243, 6, 124, 71, 25, 211, 114, 3, 3, 96, 217, 57, 39, 30, 9, 107, 243, 137, 5, 173,\n\t233, 149, 0, 65, 90, 104, 0, 221, 116, 179, 227, 177, 88, 148, 186, 235, 235, 94, 213, 193, 93, 191, 202, 170,\n\t95, 247, 231, 106, 75, 174, 184, 38, 52, 104, 194, 99, 102, 214, 201, 9, 47, 11, 143, 108, 228, 178, 138, 247,\n\t132, 67, 230, 170, 158, 20, 62, 23, 238, 115, 164, 65, 225, 71, 165, 27, 101, 126, 83, 156, 46, 177, 79, 101,\n\t134, 156, 217, 248, 132, 112, 72, 88, 75, 215, 176, 81, 195, 230, 170, 99, 9, 15, 11, 119, 39, 45, 91, 242, 125,\n\t243, 101, 78, 42, 222, 84, 108, 101, 242, 102, 165, 79, 245, 194, 214, 21, 123, 110, 70, 233, 178, 187, 136, 48,\n\t197, 52, 49, 52, 12, 242, 172, 145, 33, 71, 191, 156, 182, 40, 46, 113, 185, 15, 215, 241, 119, 150, 252, 49,\n\t113, 25, 226, 90, 195, 20, 199, 36, 235, 88, 232, 37, 63, 234, 15, 126, 207, 214, 77, 13, 13, 150, 147, 90, 195,\n\t208, 248, 226, 121, 31, 61, 208, 180, 3, 197, 130, 231, 125, 31, 123, 94, 241, 4, 252, 207, 112, 101, 87, 253,\n\t235, 71, 48, 250, 41, 122, 161, 170, 117, 31, 66, 112, 11, 46, 174, 171, 154, 177, 11, 151, 219, 208, 241, 148,\n\t213, 29, 189, 36, 249, 101, 251, 82, 41, 120, 63, 147, 111, 74, 64, 251, 45, 180, 44, 150, 231, 86, 185, 231,\n\t244, 1, 102, 101, 86, 209, 27, 216, 63, 128, 222, 180, 100, 47, 213, 121, 119, 115, 237, 220, 254, 173, 169,\n\t204, 239, 7, 178, 211, 114, 90, 10, 150, 157, 65, 0, 0, 0, 9, 112, 72, 89, 115, 0, 0, 46, 35, 0, 0, 46, 35, 1,\n\t120, 165, 63, 118, 0, 0, 0, 7, 116, 73, 77, 69, 7, 227, 4, 15, 10, 5, 36, 189, 4, 224, 88, 0, 0, 0, 25, 116, 69,\n\t88, 116, 67, 111, 109, 109, 101, 110, 116, 0, 67, 114, 101, 97, 116, 101, 100, 32, 119, 105, 116, 104, 32, 71,\n\t73, 77, 80, 87, 129, 14, 23, 0, 0, 0, 12, 73, 68, 65, 84, 8, 215, 99, 120, 241, 226, 61, 0, 5, 123, 2, 192, 194,\n\t77, 211, 95, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130,\n}\n\nfunc TestMain(m *testing.M) {\n\tpixelgl.Run(func() {\n\t\tos.Exit(m.Run())\n\t})\n}\n\nfunc TestSprite_Draw(t *testing.T) {\n\timg, _, err := image.Decode(bytes.NewReader(onePixelImage))\n\tif err != nil {\n\t\tt.Fatalf(\"Could not decode image: %v\", err)\n\t}\n\tpic := pixel.PictureDataFromImage(img)\n\n\tsprite := pixel.NewSprite(pic, pic.Bounds())\n\n\tcfg := pixelgl.WindowConfig{\n\t\tTitle:     \"testing\",\n\t\tBounds:    pixel.R(0, 0, 150, 150),\n\t\tInvisible: true,\n\t}\n\n\twin, err := pixelgl.NewWindow(cfg)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not create window: %v\", err)\n\t}\n\n\tsprite.Draw(win, pixel.IM)\n}\n"
        },
        {
          "name": "pixelgl",
          "type": "tree",
          "content": null
        },
        {
          "name": "rectangle.go",
          "type": "blob",
          "size": 7.7587890625,
          "content": "package pixel\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// Rect is a 2D rectangle aligned with the axes of the coordinate system. It is defined by two\n// points, Min and Max.\n//\n// The invariant should hold, that Max's components are greater or equal than Min's components\n// respectively.\ntype Rect struct {\n\tMin, Max Vec\n}\n\n// ZR is a zero rectangle.\nvar ZR = Rect{Min: ZV, Max: ZV}\n\n// R returns a new Rect with given the Min and Max coordinates.\n//\n// Note that the returned rectangle is not automatically normalized.\nfunc R(minX, minY, maxX, maxY float64) Rect {\n\treturn Rect{\n\t\tMin: Vec{minX, minY},\n\t\tMax: Vec{maxX, maxY},\n\t}\n}\n\n// String returns the string representation of the Rect.\n//\n//   r := pixel.R(100, 50, 200, 300)\n//   r.String()     // returns \"Rect(100, 50, 200, 300)\"\n//   fmt.Println(r) // Rect(100, 50, 200, 300)\nfunc (r Rect) String() string {\n\treturn fmt.Sprintf(\"Rect(%v, %v, %v, %v)\", r.Min.X, r.Min.Y, r.Max.X, r.Max.Y)\n}\n\n// Norm returns the Rect in normal form, such that Max is component-wise greater or equal than Min.\nfunc (r Rect) Norm() Rect {\n\treturn Rect{\n\t\tMin: Vec{\n\t\t\tmath.Min(r.Min.X, r.Max.X),\n\t\t\tmath.Min(r.Min.Y, r.Max.Y),\n\t\t},\n\t\tMax: Vec{\n\t\t\tmath.Max(r.Min.X, r.Max.X),\n\t\t\tmath.Max(r.Min.Y, r.Max.Y),\n\t\t},\n\t}\n}\n\n// W returns the width of the Rect.\nfunc (r Rect) W() float64 {\n\treturn r.Max.X - r.Min.X\n}\n\n// H returns the height of the Rect.\nfunc (r Rect) H() float64 {\n\treturn r.Max.Y - r.Min.Y\n}\n\n// Size returns the vector of width and height of the Rect.\nfunc (r Rect) Size() Vec {\n\treturn V(r.W(), r.H())\n}\n\n// Area returns the area of r. If r is not normalized, area may be negative.\nfunc (r Rect) Area() float64 {\n\treturn r.W() * r.H()\n}\n\n// Edges will return the four lines which make up the edges of the rectangle.\nfunc (r Rect) Edges() [4]Line {\n\tcorners := r.Vertices()\n\n\treturn [4]Line{\n\t\t{A: corners[0], B: corners[1]},\n\t\t{A: corners[1], B: corners[2]},\n\t\t{A: corners[2], B: corners[3]},\n\t\t{A: corners[3], B: corners[0]},\n\t}\n}\n\n// Anchor is a vector used to define anchors, such as `Center`, `Top`, `TopRight`, etc.\ntype Anchor Vec\n\nvar (\n\tCenter      = Anchor{0.5, 0.5}\n\tTop         = Anchor{0.5, 0}\n\tTopRight    = Anchor{0, 0}\n\tRight       = Anchor{0, 0.5}\n\tBottomRight = Anchor{0, 1}\n\tBottom      = Anchor{0.5, 1}\n\tBottomLeft  = Anchor{1, 1}\n\tLeft        = Anchor{1, 0.5}\n\tTopLeft     = Anchor{1, 0}\n)\n\nvar anchorStrings map[Anchor]string = map[Anchor]string{\n\tCenter:      \"center\",\n\tTop:         \"top\",\n\tTopRight:    \"top-right\",\n\tRight:       \"right\",\n\tBottomRight: \"bottom-right\",\n\tBottom:      \"bottom\",\n\tBottomLeft:  \"bottom-left\",\n\tLeft:        \"left\",\n\tTopLeft:     \"top-left\",\n}\n\n// String returns the string representation of an anchor.\nfunc (anchor Anchor) String() string {\n\treturn anchorStrings[anchor]\n}\n\nvar oppositeAnchors map[Anchor]Anchor = map[Anchor]Anchor{\n\tCenter:      Center,\n\tTop:         Bottom,\n\tBottom:      Top,\n\tRight:       Left,\n\tLeft:        Right,\n\tTopRight:    BottomLeft,\n\tBottomLeft:  TopRight,\n\tBottomRight: TopLeft,\n\tTopLeft:     BottomRight,\n}\n\n// Opposite returns the opposite position of the anchor (ie. Top -> Bottom; BottomLeft -> TopRight, etc.).\nfunc (anchor Anchor) Opposite() Anchor {\n\treturn oppositeAnchors[anchor]\n}\n\n// AnchorPos returns the relative position of the given anchor.\nfunc (r Rect) AnchorPos(anchor Anchor) Vec {\n\treturn r.Size().ScaledXY(V(0, 0).Sub(Vec(anchor)))\n}\n\n// AlignedTo returns the rect moved by the given anchor.\nfunc (rect Rect) AlignedTo(anchor Anchor) Rect {\n\treturn rect.Moved(rect.AnchorPos(anchor))\n}\n\n// Center returns the position of the center of the Rect.\n// `rect.Center()` is equivalent to `rect.Anchor(pixel.Anchor.Center)`\nfunc (r Rect) Center() Vec {\n\treturn Lerp(r.Min, r.Max, 0.5)\n}\n\n// Moved returns the Rect moved (both Min and Max) by the given vector delta.\nfunc (r Rect) Moved(delta Vec) Rect {\n\treturn Rect{\n\t\tMin: r.Min.Add(delta),\n\t\tMax: r.Max.Add(delta),\n\t}\n}\n\n// Resized returns the Rect resized to the given size while keeping the position of the given\n// anchor.\n//\n//   r.Resized(r.Min, size)      // resizes while keeping the position of the lower-left corner\n//   r.Resized(r.Max, size)      // same with the top-right corner\n//   r.Resized(r.Center(), size) // resizes around the center\n//\n// This function does not make sense for resizing a rectangle of zero area and will panic. Use\n// ResizedMin in the case of zero area.\nfunc (r Rect) Resized(anchor, size Vec) Rect {\n\tif r.W()*r.H() == 0 {\n\t\tpanic(fmt.Errorf(\"(%T).Resize: zero area\", r))\n\t}\n\tfraction := Vec{size.X / r.W(), size.Y / r.H()}\n\treturn Rect{\n\t\tMin: anchor.Add(r.Min.Sub(anchor).ScaledXY(fraction)),\n\t\tMax: anchor.Add(r.Max.Sub(anchor).ScaledXY(fraction)),\n\t}\n}\n\n// ResizedMin returns the Rect resized to the given size while keeping the position of the Rect's\n// Min.\n//\n// Sizes of zero area are safe here.\nfunc (r Rect) ResizedMin(size Vec) Rect {\n\treturn Rect{\n\t\tMin: r.Min,\n\t\tMax: r.Min.Add(size),\n\t}\n}\n\n// Contains checks whether a vector u is contained within this Rect (including it's borders).\nfunc (r Rect) Contains(u Vec) bool {\n\treturn r.Min.X <= u.X && u.X <= r.Max.X && r.Min.Y <= u.Y && u.Y <= r.Max.Y\n}\n\n// Union returns the minimal Rect which covers both r and s. Rects r and s must be normalized.\nfunc (r Rect) Union(s Rect) Rect {\n\treturn R(\n\t\tmath.Min(r.Min.X, s.Min.X),\n\t\tmath.Min(r.Min.Y, s.Min.Y),\n\t\tmath.Max(r.Max.X, s.Max.X),\n\t\tmath.Max(r.Max.Y, s.Max.Y),\n\t)\n}\n\n// Intersect returns the maximal Rect which is covered by both r and s. Rects r and s must be normalized.\n//\n// If r and s don't overlap, this function returns a zero-rectangle.\nfunc (r Rect) Intersect(s Rect) Rect {\n\tt := R(\n\t\tmath.Max(r.Min.X, s.Min.X),\n\t\tmath.Max(r.Min.Y, s.Min.Y),\n\t\tmath.Min(r.Max.X, s.Max.X),\n\t\tmath.Min(r.Max.Y, s.Max.Y),\n\t)\n\tif t.Min.X >= t.Max.X || t.Min.Y >= t.Max.Y {\n\t\treturn ZR\n\t}\n\treturn t\n}\n\n// Intersects returns whether or not the given Rect intersects at any point with this Rect.\n//\n// This function is overall about 5x faster than Intersect, so it is better\n// to use if you have no need for the returned Rect from Intersect.\nfunc (r Rect) Intersects(s Rect) bool {\n\treturn !(s.Max.X <= r.Min.X ||\n\t\ts.Min.X >= r.Max.X ||\n\t\ts.Max.Y <= r.Min.Y ||\n\t\ts.Min.Y >= r.Max.Y)\n}\n\n// IntersectCircle returns a minimal required Vector, such that moving the rect by that vector would stop the Circle\n// and the Rect intersecting.  This function returns a zero-vector if the Circle and Rect do not overlap, and if only\n// the perimeters touch.\n//\n// This function will return a non-zero vector if:\n//  - The Rect contains the Circle, partially or fully\n//  - The Circle contains the Rect, partially of fully\nfunc (r Rect) IntersectCircle(c Circle) Vec {\n\treturn c.IntersectRect(r).Scaled(-1)\n}\n\n// IntersectLine will return the shortest Vec such that if the Rect is moved by the Vec returned, the Line and Rect no\n// longer intersect.\nfunc (r Rect) IntersectLine(l Line) Vec {\n\treturn l.IntersectRect(r).Scaled(-1)\n}\n\n// IntersectionPoints returns all the points where the Rect intersects with the line provided.  This can be zero, one or\n// two points, depending on the location of the shapes.  The points of intersection will be returned in order of\n// closest-to-l.A to closest-to-l.B.\nfunc (r Rect) IntersectionPoints(l Line) []Vec {\n\t// Use map keys to ensure unique points\n\tpointMap := make(map[Vec]struct{})\n\n\tfor _, edge := range r.Edges() {\n\t\tif intersect, ok := l.Intersect(edge); ok {\n\t\t\tpointMap[intersect] = struct{}{}\n\t\t}\n\t}\n\n\tpoints := make([]Vec, 0, len(pointMap))\n\tfor point := range pointMap {\n\t\tpoints = append(points, point)\n\t}\n\n\t// Order the points\n\tif len(points) == 2 {\n\t\tif points[1].To(l.A).Len() < points[0].To(l.A).Len() {\n\t\t\treturn []Vec{points[1], points[0]}\n\t\t}\n\t}\n\n\treturn points\n}\n\n// Vertices returns a slice of the four corners which make up the rectangle.\nfunc (r Rect) Vertices() [4]Vec {\n\treturn [4]Vec{\n\t\tr.Min,\n\t\tV(r.Min.X, r.Max.Y),\n\t\tr.Max,\n\t\tV(r.Max.X, r.Min.Y),\n\t}\n}\n"
        },
        {
          "name": "rectangle_test.go",
          "type": "blob",
          "size": 11.01171875,
          "content": "package pixel_test\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/faiface/pixel\"\n)\n\nfunc TestRect_Resize(t *testing.T) {\n\ttype rectTestTransform struct {\n\t\tname string\n\t\tf    func(pixel.Rect) pixel.Rect\n\t}\n\n\t// rectangles\n\tsquareAroundOrigin := pixel.R(-10, -10, 10, 10)\n\tsquareAround2020 := pixel.R(10, 10, 30, 30)\n\trectangleAroundOrigin := pixel.R(-20, -10, 20, 10)\n\trectangleAround2020 := pixel.R(0, 10, 40, 30)\n\n\t// resize transformations\n\tresizeByHalfAroundCenter := rectTestTransform{\"by half around center\", func(rect pixel.Rect) pixel.Rect {\n\t\treturn rect.Resized(rect.Center(), rect.Size().Scaled(0.5))\n\t}}\n\tresizeByHalfAroundMin := rectTestTransform{\"by half around Min\", func(rect pixel.Rect) pixel.Rect {\n\t\treturn rect.Resized(rect.Min, rect.Size().Scaled(0.5))\n\t}}\n\tresizeByHalfAroundMax := rectTestTransform{\"by half around Max\", func(rect pixel.Rect) pixel.Rect {\n\t\treturn rect.Resized(rect.Max, rect.Size().Scaled(0.5))\n\t}}\n\tresizeByHalfAroundMiddleOfLeftSide := rectTestTransform{\"by half around middle of left side\", func(rect pixel.Rect) pixel.Rect {\n\t\treturn rect.Resized(pixel.V(rect.Min.X, rect.Center().Y), rect.Size().Scaled(0.5))\n\t}}\n\tresizeByHalfAroundOrigin := rectTestTransform{\"by half around the origin\", func(rect pixel.Rect) pixel.Rect {\n\t\treturn rect.Resized(pixel.ZV, rect.Size().Scaled(0.5))\n\t}}\n\n\ttestCases := []struct {\n\t\tinput     pixel.Rect\n\t\ttransform rectTestTransform\n\t\tanswer    pixel.Rect\n\t}{\n\t\t{squareAroundOrigin, resizeByHalfAroundCenter, pixel.R(-5, -5, 5, 5)},\n\t\t{squareAround2020, resizeByHalfAroundCenter, pixel.R(15, 15, 25, 25)},\n\t\t{rectangleAroundOrigin, resizeByHalfAroundCenter, pixel.R(-10, -5, 10, 5)},\n\t\t{rectangleAround2020, resizeByHalfAroundCenter, pixel.R(10, 15, 30, 25)},\n\n\t\t{squareAroundOrigin, resizeByHalfAroundMin, pixel.R(-10, -10, 0, 0)},\n\t\t{squareAround2020, resizeByHalfAroundMin, pixel.R(10, 10, 20, 20)},\n\t\t{rectangleAroundOrigin, resizeByHalfAroundMin, pixel.R(-20, -10, 0, 0)},\n\t\t{rectangleAround2020, resizeByHalfAroundMin, pixel.R(0, 10, 20, 20)},\n\n\t\t{squareAroundOrigin, resizeByHalfAroundMax, pixel.R(0, 0, 10, 10)},\n\t\t{squareAround2020, resizeByHalfAroundMax, pixel.R(20, 20, 30, 30)},\n\t\t{rectangleAroundOrigin, resizeByHalfAroundMax, pixel.R(0, 0, 20, 10)},\n\t\t{rectangleAround2020, resizeByHalfAroundMax, pixel.R(20, 20, 40, 30)},\n\n\t\t{squareAroundOrigin, resizeByHalfAroundMiddleOfLeftSide, pixel.R(-10, -5, 0, 5)},\n\t\t{squareAround2020, resizeByHalfAroundMiddleOfLeftSide, pixel.R(10, 15, 20, 25)},\n\t\t{rectangleAroundOrigin, resizeByHalfAroundMiddleOfLeftSide, pixel.R(-20, -5, 0, 5)},\n\t\t{rectangleAround2020, resizeByHalfAroundMiddleOfLeftSide, pixel.R(0, 15, 20, 25)},\n\n\t\t{squareAroundOrigin, resizeByHalfAroundOrigin, pixel.R(-5, -5, 5, 5)},\n\t\t{squareAround2020, resizeByHalfAroundOrigin, pixel.R(5, 5, 15, 15)},\n\t\t{rectangleAroundOrigin, resizeByHalfAroundOrigin, pixel.R(-10, -5, 10, 5)},\n\t\t{rectangleAround2020, resizeByHalfAroundOrigin, pixel.R(0, 5, 20, 15)},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Resize %v %s\", testCase.input, testCase.transform.name), func(t *testing.T) {\n\t\t\ttestResult := testCase.transform.f(testCase.input)\n\t\t\tif testResult != testCase.answer {\n\t\t\t\tt.Errorf(\"Got: %v, wanted: %v\\n\", testResult, testCase.answer)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRect_Edges(t *testing.T) {\n\ttype fields struct {\n\t\tMin pixel.Vec\n\t\tMax pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   [4]pixel.Line\n\t}{\n\t\t{\n\t\t\tname:   \"Get edges\",\n\t\t\tfields: fields{Min: pixel.V(0, 0), Max: pixel.V(10, 10)},\n\t\t\twant: [4]pixel.Line{\n\t\t\t\tpixel.L(pixel.V(0, 0), pixel.V(0, 10)),\n\t\t\t\tpixel.L(pixel.V(0, 10), pixel.V(10, 10)),\n\t\t\t\tpixel.L(pixel.V(10, 10), pixel.V(10, 0)),\n\t\t\t\tpixel.L(pixel.V(10, 0), pixel.V(0, 0)),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := pixel.Rect{\n\t\t\t\tMin: tt.fields.Min,\n\t\t\t\tMax: tt.fields.Max,\n\t\t\t}\n\t\t\tif got := r.Edges(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Rect.Edges() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRect_Vertices(t *testing.T) {\n\ttype fields struct {\n\t\tMin pixel.Vec\n\t\tMax pixel.Vec\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   [4]pixel.Vec\n\t}{\n\t\t{\n\t\t\tname:   \"Get corners\",\n\t\t\tfields: fields{Min: pixel.V(0, 0), Max: pixel.V(10, 10)},\n\t\t\twant: [4]pixel.Vec{\n\t\t\t\tpixel.V(0, 0),\n\t\t\t\tpixel.V(0, 10),\n\t\t\t\tpixel.V(10, 10),\n\t\t\t\tpixel.V(10, 0),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := pixel.Rect{\n\t\t\t\tMin: tt.fields.Min,\n\t\t\t\tMax: tt.fields.Max,\n\t\t\t}\n\t\t\tif got := r.Vertices(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Rect.Vertices() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRect_IntersectCircle(t *testing.T) {\n\ttype fields struct {\n\t\tMin pixel.Vec\n\t\tMax pixel.Vec\n\t}\n\ttype args struct {\n\t\tc pixel.Circle\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pixel.Vec\n\t}{\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): no overlap\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(50, 50), 1)},\n\t\t\twant:   pixel.ZV,\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle contains rect\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(5, 5), 10)},\n\t\t\twant:   pixel.V(-15, 0),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): rect contains circle\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(5, 5), 1)},\n\t\t\twant:   pixel.V(-6, 0),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle overlaps bottom-left corner\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(-0.5, -0.5), 1)},\n\t\t\twant:   pixel.V(-0.2, -0.2),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle overlaps top-left corner\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(-0.5, 10.5), 1)},\n\t\t\twant:   pixel.V(-0.2, 0.2),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle overlaps bottom-right corner\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(10.5, -0.5), 1)},\n\t\t\twant:   pixel.V(0.2, -0.2),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle overlaps top-right corner\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(10.5, 10.5), 1)},\n\t\t\twant:   pixel.V(0.2, 0.2),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle overlaps two corners\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(0, 5), 6)},\n\t\t\twant:   pixel.V(6, 0),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle overlaps left edge\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(0, 5), 1)},\n\t\t\twant:   pixel.V(1, 0),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle overlaps bottom edge\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(5, 0), 1)},\n\t\t\twant:   pixel.V(0, 1),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle overlaps right edge\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(10, 5), 1)},\n\t\t\twant:   pixel.V(-1, 0),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle overlaps top edge\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(5, 10), 1)},\n\t\t\twant:   pixel.V(0, -1),\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): edge is tangent of left side\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(-1, 5), 1)},\n\t\t\twant:   pixel.ZV,\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): edge is tangent of top side\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(5, -1), 1)},\n\t\t\twant:   pixel.ZV,\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle above rectangle\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(5, 12), 1)},\n\t\t\twant:   pixel.ZV,\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle below rectangle\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(5, -2), 1)},\n\t\t\twant:   pixel.ZV,\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle left of rectangle\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(-1, 5), 1)},\n\t\t\twant:   pixel.ZV,\n\t\t},\n\t\t{\n\t\t\tname:   \"Rect.IntersectCircle(): circle right of rectangle\",\n\t\t\tfields: fields{Min: pixel.ZV, Max: pixel.V(10, 10)},\n\t\t\targs:   args{c: pixel.C(pixel.V(11, 5), 1)},\n\t\t\twant:   pixel.ZV,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := pixel.Rect{\n\t\t\t\tMin: tt.fields.Min,\n\t\t\t\tMax: tt.fields.Max,\n\t\t\t}\n\t\t\tgot := r.IntersectCircle(tt.args.c)\n\t\t\tif !closeEnough(got.X, tt.want.X, 2) || !closeEnough(got.Y, tt.want.Y, 2) {\n\t\t\t\tt.Errorf(\"Rect.IntersectCircle() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRect_IntersectionPoints(t *testing.T) {\n\ttype fields struct {\n\t\tMin pixel.Vec\n\t\tMax pixel.Vec\n\t}\n\ttype args struct {\n\t\tl pixel.Line\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   []pixel.Vec\n\t}{\n\t\t{\n\t\t\tname:   \"No intersection points\",\n\t\t\tfields: fields{Min: pixel.V(1, 1), Max: pixel.V(5, 5)},\n\t\t\targs:   args{l: pixel.L(pixel.V(-5, 0), pixel.V(-2, 2))},\n\t\t\twant:   []pixel.Vec{},\n\t\t},\n\t\t{\n\t\t\tname:   \"One intersection point\",\n\t\t\tfields: fields{Min: pixel.V(1, 1), Max: pixel.V(5, 5)},\n\t\t\targs:   args{l: pixel.L(pixel.V(2, 0), pixel.V(2, 3))},\n\t\t\twant:   []pixel.Vec{pixel.V(2, 1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"Two intersection points\",\n\t\t\tfields: fields{Min: pixel.V(1, 1), Max: pixel.V(5, 5)},\n\t\t\targs:   args{l: pixel.L(pixel.V(0, 2), pixel.V(6, 2))},\n\t\t\twant:   []pixel.Vec{pixel.V(1, 2), pixel.V(5, 2)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := pixel.Rect{\n\t\t\t\tMin: tt.fields.Min,\n\t\t\t\tMax: tt.fields.Max,\n\t\t\t}\n\t\t\tif got := r.IntersectionPoints(tt.args.l); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Rect.IntersectPoints() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar rectIntTests = []struct {\n\tname      string\n\tr1, r2    pixel.Rect\n\twant      pixel.Rect\n\tintersect bool\n}{\n\t{\n\t\tname: \"Nothing touching\",\n\t\tr1:   pixel.R(0, 0, 10, 10),\n\t\tr2:   pixel.R(21, 21, 40, 40),\n\t\twant: pixel.ZR,\n\t},\n\t{\n\t\tname: \"Edge touching\",\n\t\tr1:   pixel.R(0, 0, 10, 10),\n\t\tr2:   pixel.R(10, 10, 20, 20),\n\t\twant: pixel.ZR,\n\t},\n\t{\n\t\tname:      \"Bit of overlap\",\n\t\tr1:        pixel.R(0, 0, 10, 10),\n\t\tr2:        pixel.R(0, 9, 20, 20),\n\t\twant:      pixel.R(0, 9, 10, 10),\n\t\tintersect: true,\n\t},\n\t{\n\t\tname:      \"Fully overlapped\",\n\t\tr1:        pixel.R(0, 0, 10, 10),\n\t\tr2:        pixel.R(0, 0, 10, 10),\n\t\twant:      pixel.R(0, 0, 10, 10),\n\t\tintersect: true,\n\t},\n}\n\nfunc TestRect_Intersect(t *testing.T) {\n\tfor _, tt := range rectIntTests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.r1.Intersect(tt.r2); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Rect.Intersect() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRect_Intersects(t *testing.T) {\n\tfor _, tt := range rectIntTests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.r1.Intersects(tt.r2); got != tt.intersect {\n\t\t\t\tt.Errorf(\"Rect.Intersects() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "sprite.go",
          "type": "blob",
          "size": 3.1484375,
          "content": "package pixel\n\nimport \"image/color\"\n\n// Sprite is a drawable frame of a Picture. It's anchored by the center of it's Picture's frame.\n//\n// Frame specifies a rectangular portion of the Picture that will be drawn. For example, this\n// creates a Sprite that draws the whole Picture:\n//\n//   sprite := pixel.NewSprite(pic, pic.Bounds())\n//\n// Note, that Sprite caches the results of MakePicture from Targets it's drawn to for each Picture\n// it's set to. What it means is that using a Sprite with an unbounded number of Pictures leads to a\n// memory leak, since Sprite caches them and never forgets. In such a situation, create a new Sprite\n// for each Picture.\ntype Sprite struct {\n\ttri   *TrianglesData\n\tframe Rect\n\td     Drawer\n\n\tmatrix Matrix\n\tmask   RGBA\n}\n\n// NewSprite creates a Sprite from the supplied frame of a Picture.\nfunc NewSprite(pic Picture, frame Rect) *Sprite {\n\ttri := MakeTrianglesData(6)\n\ts := &Sprite{\n\t\ttri: tri,\n\t\td:   Drawer{Triangles: tri, Cached: true},\n\t}\n\ts.matrix = IM\n\ts.mask = Alpha(1)\n\ts.Set(pic, frame)\n\treturn s\n}\n\n// Set sets a new frame of a Picture for this Sprite.\nfunc (s *Sprite) Set(pic Picture, frame Rect) {\n\ts.d.Picture = pic\n\tif frame != s.frame {\n\t\ts.frame = frame\n\t\ts.calcData()\n\t}\n}\n\n// SetCached makes the sprite cache all the\n// incoming pictures if the argument is true, and\n// doesn't make it do that if the argument is false.\nfunc (s *Sprite) SetCached(cached bool) {\n\ts.d.Cached = cached\n}\n\n// Picture returns the current Sprite's Picture.\nfunc (s *Sprite) Picture() Picture {\n\treturn s.d.Picture\n}\n\n// Frame returns the current Sprite's frame.\nfunc (s *Sprite) Frame() Rect {\n\treturn s.frame\n}\n\n// Draw draws the Sprite onto the provided Target. The Sprite will be transformed by the given Matrix.\n//\n// This method is equivalent to calling DrawColorMask with nil color mask.\nfunc (s *Sprite) Draw(t Target, matrix Matrix) {\n\ts.DrawColorMask(t, matrix, nil)\n}\n\n// DrawColorMask draws the Sprite onto the provided Target. The Sprite will be transformed by the\n// given Matrix and all of it's color will be multiplied by the given mask.\n//\n// If the mask is nil, a fully opaque white mask will be used, which causes no effect.\nfunc (s *Sprite) DrawColorMask(t Target, matrix Matrix, mask color.Color) {\n\tdirty := false\n\tif matrix != s.matrix {\n\t\ts.matrix = matrix\n\t\tdirty = true\n\t}\n\tif mask == nil {\n\t\tmask = Alpha(1)\n\t}\n\trgba := ToRGBA(mask)\n\tif rgba != s.mask {\n\t\ts.mask = rgba\n\t\tdirty = true\n\t}\n\n\tif dirty {\n\t\ts.calcData()\n\t}\n\n\ts.d.Draw(t)\n}\n\nfunc (s *Sprite) calcData() {\n\tvar (\n\t\tcenter     = s.frame.Center()\n\t\thorizontal = V(s.frame.W()/2, 0)\n\t\tvertical   = V(0, s.frame.H()/2)\n\t)\n\n\t(*s.tri)[0].Position = Vec{}.Sub(horizontal).Sub(vertical)\n\t(*s.tri)[1].Position = Vec{}.Add(horizontal).Sub(vertical)\n\t(*s.tri)[2].Position = Vec{}.Add(horizontal).Add(vertical)\n\t(*s.tri)[3].Position = Vec{}.Sub(horizontal).Sub(vertical)\n\t(*s.tri)[4].Position = Vec{}.Add(horizontal).Add(vertical)\n\t(*s.tri)[5].Position = Vec{}.Sub(horizontal).Add(vertical)\n\n\tfor i := range *s.tri {\n\t\t(*s.tri)[i].Color = s.mask\n\t\t(*s.tri)[i].Picture = center.Add((*s.tri)[i].Position)\n\t\t(*s.tri)[i].Intensity = 1\n\t\t(*s.tri)[i].Position = s.matrix.Project((*s.tri)[i].Position)\n\t}\n\n\ts.d.Dirty()\n}\n"
        },
        {
          "name": "text",
          "type": "tree",
          "content": null
        },
        {
          "name": "vector.go",
          "type": "blob",
          "size": 11.3916015625,
          "content": "package pixel\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// Vec is a 2D vector type with X and Y coordinates.\n//\n// Create vectors with the V constructor:\n//\n//   u := pixel.V(1, 2)\n//   v := pixel.V(8, -3)\n//\n// Use various methods to manipulate them:\n//\n//   w := u.Add(v)\n//   fmt.Println(w)        // Vec(9, -1)\n//   fmt.Println(u.Sub(v)) // Vec(-7, 5)\n//   u = pixel.V(2, 3)\n//   v = pixel.V(8, 1)\n//   if u.X < 0 {\n//\t     fmt.Println(\"this won't happen\")\n//   }\n//   x := u.Unit().Dot(v.Unit())\ntype Vec struct {\n\tX, Y float64\n}\n\n// ZV is a zero vector.\nvar ZV = Vec{0, 0}\n\n// V returns a new 2D vector with the given coordinates.\nfunc V(x, y float64) Vec {\n\treturn Vec{x, y}\n}\n\n// nearlyEqual compares two float64s and returns whether they are equal, accounting for rounding errors.At worst, the\n// result is correct to 7 significant digits.\nfunc nearlyEqual(a, b float64) bool {\n\tepsilon := 0.000001\n\n\tif a == b {\n\t\treturn true\n\t}\n\n\tdiff := math.Abs(a - b)\n\n\tif a == 0.0 || b == 0.0 || diff < math.SmallestNonzeroFloat64 {\n\t\treturn diff < (epsilon * math.SmallestNonzeroFloat64)\n\t}\n\n\tabsA := math.Abs(a)\n\tabsB := math.Abs(b)\n\n\treturn diff/math.Min(absA+absB, math.MaxFloat64) < epsilon\n}\n\n// Eq will compare two vectors and return whether they are equal accounting for rounding errors.  At worst, the result\n// is correct to 7 significant digits.\nfunc (u Vec) Eq(v Vec) bool {\n\treturn nearlyEqual(u.X, v.X) && nearlyEqual(u.Y, v.Y)\n}\n\n// Unit returns a vector of length 1 facing the given angle.\nfunc Unit(angle float64) Vec {\n\treturn Vec{1, 0}.Rotated(angle)\n}\n\n// String returns the string representation of the vector u.\n//\n//   u := pixel.V(4.5, -1.3)\n//   u.String()     // returns \"Vec(4.5, -1.3)\"\n//   fmt.Println(u) // Vec(4.5, -1.3)\nfunc (u Vec) String() string {\n\treturn fmt.Sprintf(\"Vec(%v, %v)\", u.X, u.Y)\n}\n\n// XY returns the components of the vector in two return values.\nfunc (u Vec) XY() (x, y float64) {\n\treturn u.X, u.Y\n}\n\n// Add returns the sum of vectors u and v.\nfunc (u Vec) Add(v Vec) Vec {\n\treturn Vec{\n\t\tu.X + v.X,\n\t\tu.Y + v.Y,\n\t}\n}\n\n// Sub returns the difference betweeen vectors u and v.\nfunc (u Vec) Sub(v Vec) Vec {\n\treturn Vec{\n\t\tu.X - v.X,\n\t\tu.Y - v.Y,\n\t}\n}\n\n// Floor converts x and y to their integer equivalents.\nfunc (u Vec) Floor() Vec {\n\treturn Vec{\n\t\tmath.Floor(u.X),\n\t\tmath.Floor(u.Y),\n\t}\n}\n\n// To returns the vector from u to v. Equivalent to v.Sub(u).\nfunc (u Vec) To(v Vec) Vec {\n\treturn Vec{\n\t\tv.X - u.X,\n\t\tv.Y - u.Y,\n\t}\n}\n\n// Scaled returns the vector u multiplied by c.\nfunc (u Vec) Scaled(c float64) Vec {\n\treturn Vec{u.X * c, u.Y * c}\n}\n\n// ScaledXY returns the vector u multiplied by the vector v component-wise.\nfunc (u Vec) ScaledXY(v Vec) Vec {\n\treturn Vec{u.X * v.X, u.Y * v.Y}\n}\n\n// Len returns the length of the vector u.\nfunc (u Vec) Len() float64 {\n\treturn math.Hypot(u.X, u.Y)\n}\n\n// SqLen returns the squared length of the vector u (faster to compute than Len).\nfunc (u Vec) SqLen() float64 {\n\treturn u.X*u.X + u.Y*u.Y\n}\n\n// Angle returns the angle between the vector u and the x-axis. The result is in range [-Pi, Pi].\nfunc (u Vec) Angle() float64 {\n\treturn math.Atan2(u.Y, u.X)\n}\n\n// Unit returns a vector of length 1 facing the direction of u (has the same angle).\nfunc (u Vec) Unit() Vec {\n\tif u.X == 0 && u.Y == 0 {\n\t\treturn Vec{1, 0}\n\t}\n\treturn u.Scaled(1 / u.Len())\n}\n\n// Rotated returns the vector u rotated by the given angle in radians.\nfunc (u Vec) Rotated(angle float64) Vec {\n\tsin, cos := math.Sincos(angle)\n\treturn Vec{\n\t\tu.X*cos - u.Y*sin,\n\t\tu.X*sin + u.Y*cos,\n\t}\n}\n\n// Normal returns a vector normal to u. Equivalent to u.Rotated(math.Pi / 2), but faster.\nfunc (u Vec) Normal() Vec {\n\treturn Vec{-u.Y, u.X}\n}\n\n// Dot returns the dot product of vectors u and v.\nfunc (u Vec) Dot(v Vec) float64 {\n\treturn u.X*v.X + u.Y*v.Y\n}\n\n// Cross return the cross product of vectors u and v.\nfunc (u Vec) Cross(v Vec) float64 {\n\treturn u.X*v.Y - v.X*u.Y\n}\n\n// Project returns a projection (or component) of vector u in the direction of vector v.\n//\n// Behaviour is undefined if v is a zero vector.\nfunc (u Vec) Project(v Vec) Vec {\n\tlen := u.Dot(v) / v.Len()\n\treturn v.Unit().Scaled(len)\n}\n\n// Map applies the function f to both x and y components of the vector u and returns the modified\n// vector.\n//\n//   u := pixel.V(10.5, -1.5)\n//   v := u.Map(math.Floor)   // v is Vec(10, -2), both components of u floored\nfunc (u Vec) Map(f func(float64) float64) Vec {\n\treturn Vec{\n\t\tf(u.X),\n\t\tf(u.Y),\n\t}\n}\n\n// Lerp returns a linear interpolation between vectors a and b.\n//\n// This function basically returns a point along the line between a and b and t chooses which one.\n// If t is 0, then a will be returned, if t is 1, b will be returned. Anything between 0 and 1 will\n// return the appropriate point between a and b and so on.\nfunc Lerp(a, b Vec, t float64) Vec {\n\treturn a.Scaled(1 - t).Add(b.Scaled(t))\n}\n\n// Line is a 2D line segment, between points A and B.\ntype Line struct {\n\tA, B Vec\n}\n\n// L creates and returns a new Line.\nfunc L(from, to Vec) Line {\n\treturn Line{\n\t\tA: from,\n\t\tB: to,\n\t}\n}\n\n// Bounds returns the lines bounding box.  This is in the form of a normalized Rect.\nfunc (l Line) Bounds() Rect {\n\treturn R(l.A.X, l.A.Y, l.B.X, l.B.Y).Norm()\n}\n\n// Center will return the point at center of the line; that is, the point equidistant from either end.\nfunc (l Line) Center() Vec {\n\treturn l.A.Add(l.A.To(l.B).Scaled(0.5))\n}\n\n// Closest will return the point on the line which is closest to the Vec provided.\nfunc (l Line) Closest(v Vec) Vec {\n\t// between is a helper function which determines whether x is greater than min(a, b) and less than max(a, b)\n\tbetween := func(a, b, x float64) bool {\n\t\tmin := math.Min(a, b)\n\t\tmax := math.Max(a, b)\n\t\treturn min < x && x < max\n\t}\n\n\t// Closest point will be on a line which perpendicular to this line.\n\t// If and only if the infinite perpendicular line intersects the segment.\n\tm, b := l.Formula()\n\n\t// Account for horizontal lines\n\tif m == 0 {\n\t\tx := v.X\n\t\ty := l.A.Y\n\n\t\t// check if the X coordinate of v is on the line\n\t\tif between(l.A.X, l.B.X, v.X) {\n\t\t\treturn V(x, y)\n\t\t}\n\n\t\t// Otherwise get the closest endpoint\n\t\tif l.A.To(v).Len() < l.B.To(v).Len() {\n\t\t\treturn l.A\n\t\t}\n\t\treturn l.B\n\t}\n\n\t// Account for vertical lines\n\tif math.IsInf(math.Abs(m), 1) {\n\t\tx := l.A.X\n\t\ty := v.Y\n\n\t\t// check if the Y coordinate of v is on the line\n\t\tif between(l.A.Y, l.B.Y, v.Y) {\n\t\t\treturn V(x, y)\n\t\t}\n\n\t\t// Otherwise get the closest endpoint\n\t\tif l.A.To(v).Len() < l.B.To(v).Len() {\n\t\t\treturn l.A\n\t\t}\n\t\treturn l.B\n\t}\n\n\tperpendicularM := -1 / m\n\tperpendicularB := v.Y - (perpendicularM * v.X)\n\n\t// Coordinates of intersect (of infinite lines)\n\tx := (perpendicularB - b) / (m - perpendicularM)\n\ty := m*x + b\n\n\t// Check if the point lies between the x and y bounds of the segment\n\tif !between(l.A.X, l.B.X, x) && !between(l.A.Y, l.B.Y, y) {\n\t\t// Not within bounding box\n\t\ttoStart := v.To(l.A)\n\t\ttoEnd := v.To(l.B)\n\n\t\tif toStart.Len() < toEnd.Len() {\n\t\t\treturn l.A\n\t\t}\n\t\treturn l.B\n\t}\n\n\treturn V(x, y)\n}\n\n// Contains returns whether the provided Vec lies on the line.\nfunc (l Line) Contains(v Vec) bool {\n\treturn l.Closest(v).Eq(v)\n}\n\n// Formula will return the values that represent the line in the formula: y = mx + b\n// This function will return math.Inf+, math.Inf- for a vertical line.\nfunc (l Line) Formula() (m, b float64) {\n\t// Account for horizontal lines\n\tif l.B.Y == l.A.Y {\n\t\treturn 0, l.A.Y\n\t}\n\n\tm = (l.B.Y - l.A.Y) / (l.B.X - l.A.X)\n\tb = l.A.Y - (m * l.A.X)\n\n\treturn m, b\n}\n\n// Intersect will return the point of intersection for the two line segments.  If the line segments do not intersect,\n// this function will return the zero-vector and false.\nfunc (l Line) Intersect(k Line) (Vec, bool) {\n\t// Check if the lines are parallel\n\tlDir := l.A.To(l.B)\n\tkDir := k.A.To(k.B)\n\tif lDir.X == kDir.X && lDir.Y == kDir.Y {\n\t\treturn ZV, false\n\t}\n\n\t// The lines intersect - but potentially not within the line segments.\n\t// Get the intersection point for the lines if they were infinitely long, check if the point exists on both of the\n\t// segments\n\tlm, lb := l.Formula()\n\tkm, kb := k.Formula()\n\n\t// Account for vertical lines\n\tif math.IsInf(math.Abs(lm), 1) && math.IsInf(math.Abs(km), 1) {\n\t\t// Both vertical, therefore parallel\n\t\treturn ZV, false\n\t}\n\n\tvar x, y float64\n\n\tif math.IsInf(math.Abs(lm), 1) || math.IsInf(math.Abs(km), 1) {\n\t\t// One line is vertical\n\t\tintersectM := lm\n\t\tintersectB := lb\n\t\tverticalLine := k\n\n\t\tif math.IsInf(math.Abs(lm), 1) {\n\t\t\tintersectM = km\n\t\t\tintersectB = kb\n\t\t\tverticalLine = l\n\t\t}\n\n\t\ty = intersectM*verticalLine.A.X + intersectB\n\t\tx = verticalLine.A.X\n\t} else {\n\t\t// Coordinates of intersect\n\t\tx = (kb - lb) / (lm - km)\n\t\ty = lm*x + lb\n\t}\n\n\tif l.Contains(V(x, y)) && k.Contains(V(x, y)) {\n\t\t// The intersect point is on both line segments, they intersect.\n\t\treturn V(x, y), true\n\t}\n\n\treturn ZV, false\n}\n\n// IntersectCircle will return the shortest Vec such that moving the Line by that Vec will cause the Line and Circle\n// to no longer intesect.  If they do not intersect at all, this function will return a zero-vector.\nfunc (l Line) IntersectCircle(c Circle) Vec {\n\t// Get the point on the line closest to the center of the circle.\n\tclosest := l.Closest(c.Center)\n\tcirToClosest := c.Center.To(closest)\n\n\tif cirToClosest.Len() >= c.Radius {\n\t\treturn ZV\n\t}\n\n\treturn cirToClosest.Scaled(cirToClosest.Len() - c.Radius)\n}\n\n// IntersectRect will return the shortest Vec such that moving the Line by that Vec will cause  the Line and Rect to\n// no longer intesect.  If they do not intersect at all, this function will return a zero-vector.\nfunc (l Line) IntersectRect(r Rect) Vec {\n\t// Check if either end of the line segment are within the rectangle\n\tif r.Contains(l.A) || r.Contains(l.B) {\n\t\t// Use the Rect.Intersect to get minimal return value\n\t\trIntersect := l.Bounds().Intersect(r)\n\t\tif rIntersect.H() > rIntersect.W() {\n\t\t\t// Go vertical\n\t\t\treturn V(0, rIntersect.H())\n\t\t}\n\t\treturn V(rIntersect.W(), 0)\n\t}\n\n\t// Check if any of the rectangles' edges intersect with this line.\n\tfor _, edge := range r.Edges() {\n\t\tif _, ok := l.Intersect(edge); ok {\n\t\t\t// Get the closest points on the line to each corner, where:\n\t\t\t//  - the point is contained by the rectangle\n\t\t\t//  - the point is not the corner itself\n\t\t\tcorners := r.Vertices()\n\t\t\tvar closest *Vec\n\t\t\tclosestCorner := corners[0]\n\t\t\tfor _, c := range corners {\n\t\t\t\tcc := l.Closest(c)\n\t\t\t\tif closest == nil || (closest.Len() > cc.Len() && r.Contains(cc)) {\n\t\t\t\t\tclosest = &cc\n\t\t\t\t\tclosestCorner = c\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn closest.To(closestCorner)\n\t\t}\n\t}\n\n\t// No intersect\n\treturn ZV\n}\n\n// Len returns the length of the line segment.\nfunc (l Line) Len() float64 {\n\treturn l.A.To(l.B).Len()\n}\n\n// Moved will return a line moved by the delta Vec provided.\nfunc (l Line) Moved(delta Vec) Line {\n\treturn Line{\n\t\tA: l.A.Add(delta),\n\t\tB: l.B.Add(delta),\n\t}\n}\n\n// Rotated will rotate the line around the provided Vec.\nfunc (l Line) Rotated(around Vec, angle float64) Line {\n\t// Move the line so we can use `Vec.Rotated`\n\tlineShifted := l.Moved(around.Scaled(-1))\n\n\tlineRotated := Line{\n\t\tA: lineShifted.A.Rotated(angle),\n\t\tB: lineShifted.B.Rotated(angle),\n\t}\n\n\treturn lineRotated.Moved(around)\n}\n\n// Scaled will return the line scaled around the center point.\nfunc (l Line) Scaled(scale float64) Line {\n\treturn l.ScaledXY(l.Center(), scale)\n}\n\n// ScaledXY will return the line scaled around the Vec provided.\nfunc (l Line) ScaledXY(around Vec, scale float64) Line {\n\ttoA := around.To(l.A).Scaled(scale)\n\ttoB := around.To(l.B).Scaled(scale)\n\n\treturn Line{\n\t\tA: around.Add(toA),\n\t\tB: around.Add(toB),\n\t}\n}\n\nfunc (l Line) String() string {\n\treturn fmt.Sprintf(\"Line(%v, %v)\", l.A, l.B)\n}\n"
        },
        {
          "name": "vector_test.go",
          "type": "blob",
          "size": 0.4716796875,
          "content": "package pixel_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/faiface/pixel\"\n)\n\ntype floorTest struct {\n\tinput    pixel.Vec\n\texpected pixel.Vec\n}\n\nfunc TestFloor(t *testing.T) {\n\ttests := []floorTest{\n\t\t{input: pixel.V(4.50, 6.70), expected: pixel.V(4, 6)},\n\t\t{input: pixel.V(9.0, 6.70), expected: pixel.V(9, 6)},\n\t}\n\n\tfor _, tc := range tests {\n\t\tresult := tc.input.Floor()\n\t\tif result != tc.expected {\n\t\t\tt.Error(fmt.Sprintf(\"Expected %v but got %v\", tc.expected, result))\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}