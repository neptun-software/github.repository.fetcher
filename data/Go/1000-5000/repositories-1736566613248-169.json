{
  "metadata": {
    "timestamp": 1736566613248,
    "page": 169,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "schollz/progressbar",
      "stars": 4223,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.279296875,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n.idea/\n*.tar.gz\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.26171875,
          "content": "run:\n  timeout: 5m\n  exclude-dirs:\n    - vendor\n    - examples\n\nlinters:\n  enable:\n    - errcheck\n    - gocyclo\n    - gofmt\n    - goimports\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n\nlinters-settings:\n  gocyclo:\n    min-complexity: 20"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.046875,
          "content": "language: go\n\ngo:\n  - tip\n\nscript: go test -v .\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0361328125,
          "content": "MIT License\n\nCopyright (c) 2017 Zack\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.853515625,
          "content": "# progressbar\n\n[![CI](https://github.com/schollz/progressbar/actions/workflows/ci.yml/badge.svg?branch=main&event=push)](https://github.com/schollz/progressbar/actions/workflows/ci.yml)\n[![go report card](https://goreportcard.com/badge/github.com/schollz/progressbar)](https://goreportcard.com/report/github.com/schollz/progressbar) \n[![coverage](https://img.shields.io/badge/coverage-84%25-brightgreen.svg)](https://gocover.io/github.com/schollz/progressbar)\n[![godocs](https://godoc.org/github.com/schollz/progressbar?status.svg)](https://godoc.org/github.com/schollz/progressbar/v3) \n\nA very simple thread-safe progress bar which should work on every OS without problems. I needed a progressbar for [croc](https://github.com/schollz/croc) and everything I tried had problems, so I made another one. In order to be OS agnostic I do not plan to support [multi-line outputs](https://github.com/schollz/progressbar/issues/6).\n\n\n## Install\n\n```\ngo get -u github.com/schollz/progressbar/v3\n```\n\n## Usage \n\n### Basic usage\n\n```golang\nbar := progressbar.Default(100)\nfor i := 0; i < 100; i++ {\n    bar.Add(1)\n    time.Sleep(40 * time.Millisecond)\n}\n```\n\nwhich looks like:\n\n![Example of basic bar](examples/basic/basic.gif)\n\n\n### I/O operations\n\nThe `progressbar` implements an `io.Writer` so it can automatically detect the number of bytes written to a stream, so you can use it as a progressbar for an `io.Reader`.\n\n```golang\nreq, _ := http.NewRequest(\"GET\", \"https://dl.google.com/go/go1.14.2.src.tar.gz\", nil)\nresp, _ := http.DefaultClient.Do(req)\ndefer resp.Body.Close()\n\nf, _ := os.OpenFile(\"go1.14.2.src.tar.gz\", os.O_CREATE|os.O_WRONLY, 0644)\ndefer f.Close()\n\nbar := progressbar.DefaultBytes(\n    resp.ContentLength,\n    \"downloading\",\n)\nio.Copy(io.MultiWriter(f, bar), resp.Body)\n```\n\nwhich looks like:\n\n![Example of download bar](examples/download/download.gif)\n\n\n### Progress bar with unknown length\n\nA progressbar with unknown length is a spinner. Any bar with -1 length will automatically convert it to a spinner with a customizable spinner type. For example, the above code can be run and set the `resp.ContentLength` to `-1`.\n\nwhich looks like:\n\n![Example of download bar with unknown length](examples/download-unknown/download-unknown.gif)\n\n\n### Customization\n\nThere is a lot of customization that you can do - change the writer, the color, the width, description, theme, etc. See [all the options](https://pkg.go.dev/github.com/schollz/progressbar/v3?tab=doc#Option).\n\n```golang\nbar := progressbar.NewOptions(1000,\n    progressbar.OptionSetWriter(ansi.NewAnsiStdout()), //you should install \"github.com/k0kubun/go-ansi\"\n    progressbar.OptionEnableColorCodes(true),\n    progressbar.OptionShowBytes(true),\n    progressbar.OptionSetWidth(15),\n    progressbar.OptionSetDescription(\"[cyan][1/3][reset] Writing moshable file...\"),\n    progressbar.OptionSetTheme(progressbar.Theme{\n        Saucer:        \"[green]=[reset]\",\n        SaucerHead:    \"[green]>[reset]\",\n        SaucerPadding: \" \",\n        BarStart:      \"[\",\n        BarEnd:        \"]\",\n    }))\nfor i := 0; i < 1000; i++ {\n    bar.Add(1)\n    time.Sleep(5 * time.Millisecond)\n}\n```\n\nwhich looks like:\n\n![Example of customized bar](examples/customization/customization.gif)\n\n\n## Contributing\n\nPull requests are welcome. Feel free to...\n\n- Revise documentation\n- Add new features\n- Fix bugs\n- Suggest improvements\n\n## Thanks\n\nThanks [@Dynom](https://github.com/dynom) for massive improvements in version 2.0!\n\nThanks [@CrushedPixel](https://github.com/CrushedPixel) for adding descriptions and color code support!\n\nThanks [@MrMe42](https://github.com/MrMe42) for adding some minor features!\n\nThanks [@tehstun](https://github.com/tehstun) for some great PRs!\n\nThanks [@Benzammour](https://github.com/Benzammour) and [@haseth](https://github.com/haseth) for helping create v3!\n\nThanks [@briandowns](https://github.com/briandowns) for compiling the list of spinners.\n\n## License\n\nMIT\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.599609375,
          "content": "module github.com/schollz/progressbar/v3\n\nrequire (\n\tgithub.com/chengxilo/virtualterm v1.0.4\n\tgithub.com/k0kubun/go-ansi v0.0.0-20180517002512-3bf9e2903213\n\tgithub.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db\n\tgithub.com/rivo/uniseg v0.4.7\n\tgithub.com/stretchr/testify v1.9.0\n\tgolang.org/x/term v0.28.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.16 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n\ngo 1.22\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.7587890625,
          "content": "github.com/chengxilo/virtualterm v1.0.4 h1:Z6IpERbRVlfB8WkOmtbHiDbBANU7cimRIof7mk9/PwM=\ngithub.com/chengxilo/virtualterm v1.0.4/go.mod h1:DyxxBZz/x1iqJjFxTFcr6/x+jSpqN0iwWCOK1q10rlY=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/k0kubun/go-ansi v0.0.0-20180517002512-3bf9e2903213 h1:qGQQKEcAR99REcMpsXCp3lJ03zYT1PkRd3kQGPn9GVg=\ngithub.com/k0kubun/go-ansi v0.0.0-20180517002512-3bf9e2903213/go.mod h1:vNUNkEQ1e29fT/6vq2aBdFsgNPmy8qMdSay1npru+Sw=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db h1:62I3jR2EmQ4l5rM/4FEfDWcRD+abF5XlKShorW5LRoQ=\ngithub.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db/go.mod h1:l0dey0ia/Uv7NcFFVbCLtqEBQbrT4OCwCSKTEv6enCw=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.26.0 h1:WEQa6V3Gja/BhNxg540hBip/kkaYtRg3cxg4oXSw4AU=\ngolang.org/x/term v0.26.0/go.mod h1:Si5m1o57C5nBNQo5z1iq+XDijt21BDBDp2bK0QI8e3E=\ngolang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=\ngolang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "progressbar.go",
          "type": "blob",
          "size": 39.19921875,
          "content": "package progressbar\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"math\"\n\t\"net/http\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/mitchellh/colorstring\"\n\t\"github.com/rivo/uniseg\"\n\t\"golang.org/x/term\"\n)\n\n// ProgressBar is a thread-safe, simple\n// progress bar\ntype ProgressBar struct {\n\tstate  state\n\tconfig config\n\tlock   sync.Mutex\n}\n\n// State is the basic properties of the bar\ntype State struct {\n\tMax            int64\n\tCurrentNum     int64\n\tCurrentPercent float64\n\tCurrentBytes   float64\n\tSecondsSince   float64\n\tSecondsLeft    float64\n\tKBsPerSecond   float64\n\tDescription    string\n}\n\ntype state struct {\n\tcurrentNum        int64\n\tcurrentPercent    int\n\tlastPercent       int\n\tcurrentSaucerSize int\n\tisAltSaucerHead   bool\n\n\tlastShown time.Time\n\tstartTime time.Time // time when the progress bar start working\n\n\tcounterTime         time.Time\n\tcounterNumSinceLast int64\n\tcounterLastTenRates []float64\n\tspinnerIdx          int // the index of spinner\n\n\tmaxLineWidth int\n\tcurrentBytes float64\n\tfinished     bool\n\texit         bool // Progress bar exit halfway\n\n\tdetails []string // details to show,only used when detail row is set to more than 0\n\n\trendered string\n}\n\ntype config struct {\n\tmax                  int64 // max number of the counter\n\tmaxHumanized         string\n\tmaxHumanizedSuffix   string\n\twidth                int\n\twriter               io.Writer\n\ttheme                Theme\n\trenderWithBlankState bool\n\tdescription          string\n\titerationString      string\n\tignoreLength         bool // ignoreLength if max bytes not known\n\n\t// whether the output is expected to contain color codes\n\tcolorCodes bool\n\n\t// show rate of change in kB/sec or MB/sec\n\tshowBytes bool\n\t// show the iterations per second\n\tshowIterationsPerSecond bool\n\tshowIterationsCount     bool\n\n\t// whether the progress bar should show the total bytes (e.g. 23/24 or 23/-, vs. just 23).\n\tshowTotalBytes bool\n\n\t// whether the progress bar should show elapsed time.\n\t// always enabled if predictTime is true.\n\telapsedTime bool\n\n\tshowElapsedTimeOnFinish bool\n\n\t// whether the progress bar should attempt to predict the finishing\n\t// time of the progress based on the start time and the average\n\t// number of seconds between  increments.\n\tpredictTime bool\n\n\t// minimum time to wait in between updates\n\tthrottleDuration time.Duration\n\n\t// clear bar once finished\n\tclearOnFinish bool\n\n\t// spinnerType should be a number between 0-75\n\tspinnerType int\n\n\t// spinnerTypeOptionUsed remembers if the spinnerType was changed manually\n\tspinnerTypeOptionUsed bool\n\n\t// spinnerChangeInterval the change interval of spinner\n\t// if set this attribute to 0, the spinner only change when renderProgressBar was called\n\t// for example, each time when Add() was called,which will call renderProgressBar function\n\tspinnerChangeInterval time.Duration\n\n\t// spinner represents the spinner as a slice of string\n\tspinner []string\n\n\t// fullWidth specifies whether to measure and set the bar to a specific width\n\tfullWidth bool\n\n\t// invisible doesn't render the bar at all, useful for debugging\n\tinvisible bool\n\n\tonCompletion func()\n\n\t// whether the render function should make use of ANSI codes to reduce console I/O\n\tuseANSICodes bool\n\n\t// whether to use the IEC units (e.g. MiB) instead of the default SI units (e.g. MB)\n\tuseIECUnits bool\n\n\t// showDescriptionAtLineEnd specifies whether description should be written at line end instead of line start\n\tshowDescriptionAtLineEnd bool\n\n\t// specifies how many rows of details to show,default value is 0 and no details will be shown\n\tmaxDetailRow int\n\n\tstdBuffer bytes.Buffer\n}\n\n// Theme defines the elements of the bar\ntype Theme struct {\n\tSaucer        string\n\tAltSaucerHead string\n\tSaucerHead    string\n\tSaucerPadding string\n\tBarStart      string\n\tBarEnd        string\n\n\t// BarStartFilled is used after the Bar starts filling, if set. Otherwise, it defaults to BarStart.\n\tBarStartFilled string\n\n\t// BarEndFilled is used once the Bar finishes, if set. Otherwise, it defaults to BarEnd.\n\tBarEndFilled string\n}\n\nvar (\n\t// ThemeDefault is given by default (if not changed with OptionSetTheme), and it looks like \"|████     |\".\n\tThemeDefault = Theme{Saucer: \"█\", SaucerPadding: \" \", BarStart: \"|\", BarEnd: \"|\"}\n\n\t// ThemeASCII is a predefined Theme that uses ASCII symbols. It looks like \"[===>...]\".\n\t// Configure it with OptionSetTheme(ThemeASCII).\n\tThemeASCII = Theme{\n\t\tSaucer:        \"=\",\n\t\tSaucerHead:    \">\",\n\t\tSaucerPadding: \".\",\n\t\tBarStart:      \"[\",\n\t\tBarEnd:        \"]\",\n\t}\n\n\t// ThemeUnicode is a predefined Theme that uses Unicode characters, displaying a graphic bar.\n\t// It looks like \"\" (rendering will depend on font being used).\n\t// It requires special symbols usually found in \"nerd fonts\" [2], or in Fira Code [1], and other sources.\n\t// Configure it with OptionSetTheme(ThemeUnicode).\n\t//\n\t// [1] https://github.com/tonsky/FiraCode\n\t// [2] https://www.nerdfonts.com/\n\tThemeUnicode = Theme{\n\t\tSaucer:         \"\\uEE04\", // \n\t\tSaucerHead:     \"\\uEE04\", // \n\t\tSaucerPadding:  \"\\uEE01\", // \n\t\tBarStart:       \"\\uEE00\", // \n\t\tBarStartFilled: \"\\uEE03\", // \n\t\tBarEnd:         \"\\uEE02\", // \n\t\tBarEndFilled:   \"\\uEE05\", // \n\t}\n)\n\n// Option is the type all options need to adhere to\ntype Option func(p *ProgressBar)\n\n// OptionSetWidth sets the width of the bar\nfunc OptionSetWidth(s int) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.width = s\n\t}\n}\n\n// OptionSetSpinnerChangeInterval sets the spinner change interval\n// the spinner will change according to this value.\n// By default, this value is 100 * time.Millisecond\n// If you don't want to let this progressbar update by specified time interval\n// you can  set this value to zero, then the spinner will change each time rendered,\n// such as when Add() or Describe() was called\nfunc OptionSetSpinnerChangeInterval(interval time.Duration) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.spinnerChangeInterval = interval\n\t}\n}\n\n// OptionSpinnerType sets the type of spinner used for indeterminate bars\nfunc OptionSpinnerType(spinnerType int) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.spinnerTypeOptionUsed = true\n\t\tp.config.spinnerType = spinnerType\n\t}\n}\n\n// OptionSpinnerCustom sets the spinner used for indeterminate bars to the passed\n// slice of string\nfunc OptionSpinnerCustom(spinner []string) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.spinner = spinner\n\t}\n}\n\n// OptionSetTheme sets the elements the bar is constructed with.\n// There are two pre-defined themes you can use: ThemeASCII and ThemeUnicode.\nfunc OptionSetTheme(t Theme) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.theme = t\n\t}\n}\n\n// OptionSetVisibility sets the visibility\nfunc OptionSetVisibility(visibility bool) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.invisible = !visibility\n\t}\n}\n\n// OptionFullWidth sets the bar to be full width\nfunc OptionFullWidth() Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.fullWidth = true\n\t}\n}\n\n// OptionSetWriter sets the output writer (defaults to os.StdOut)\nfunc OptionSetWriter(w io.Writer) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.writer = w\n\t}\n}\n\n// OptionSetRenderBlankState sets whether or not to render a 0% bar on construction\nfunc OptionSetRenderBlankState(r bool) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.renderWithBlankState = r\n\t}\n}\n\n// OptionSetDescription sets the description of the bar to render in front of it\nfunc OptionSetDescription(description string) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.description = description\n\t}\n}\n\n// OptionEnableColorCodes enables or disables support for color codes\n// using mitchellh/colorstring\nfunc OptionEnableColorCodes(colorCodes bool) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.colorCodes = colorCodes\n\t}\n}\n\n// OptionSetElapsedTime will enable elapsed time. Always enabled if OptionSetPredictTime is true.\nfunc OptionSetElapsedTime(elapsedTime bool) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.elapsedTime = elapsedTime\n\t}\n}\n\n// OptionSetPredictTime will also attempt to predict the time remaining.\nfunc OptionSetPredictTime(predictTime bool) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.predictTime = predictTime\n\t}\n}\n\n// OptionShowCount will also print current count out of total\nfunc OptionShowCount() Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.showIterationsCount = true\n\t}\n}\n\n// OptionShowIts will also print the iterations/second\nfunc OptionShowIts() Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.showIterationsPerSecond = true\n\t}\n}\n\n// OptionShowElapsedTimeOnFinish will keep the display of elapsed time on finish.\nfunc OptionShowElapsedTimeOnFinish() Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.showElapsedTimeOnFinish = true\n\t}\n}\n\n// OptionShowTotalBytes will keep the display of total bytes.\nfunc OptionShowTotalBytes(flag bool) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.showTotalBytes = flag\n\t}\n}\n\n// OptionSetItsString sets what's displayed for iterations a second. The default is \"it\" which would display: \"it/s\"\nfunc OptionSetItsString(iterationString string) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.iterationString = iterationString\n\t}\n}\n\n// OptionThrottle will wait the specified duration before updating again. The default\n// duration is 0 seconds.\nfunc OptionThrottle(duration time.Duration) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.throttleDuration = duration\n\t}\n}\n\n// OptionClearOnFinish will clear the bar once its finished.\nfunc OptionClearOnFinish() Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.clearOnFinish = true\n\t}\n}\n\n// OptionOnCompletion will invoke cmpl function once its finished\nfunc OptionOnCompletion(cmpl func()) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.onCompletion = cmpl\n\t}\n}\n\n// OptionShowBytes will update the progress bar\n// configuration settings to display/hide kBytes/Sec\nfunc OptionShowBytes(val bool) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.showBytes = val\n\t}\n}\n\n// OptionUseANSICodes will use more optimized terminal i/o.\n//\n// Only useful in environments with support for ANSI escape sequences.\nfunc OptionUseANSICodes(val bool) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.useANSICodes = val\n\t}\n}\n\n// OptionUseIECUnits will enable IEC units (e.g. MiB) instead of the default\n// SI units (e.g. MB).\nfunc OptionUseIECUnits(val bool) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.useIECUnits = val\n\t}\n}\n\n// OptionShowDescriptionAtLineEnd defines whether description should be written at line end instead of line start\nfunc OptionShowDescriptionAtLineEnd() Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.showDescriptionAtLineEnd = true\n\t}\n}\n\n// OptionSetMaxDetailRow sets the max row of details\n// the row count should be less than the terminal height, otherwise it will not give you the output you want\nfunc OptionSetMaxDetailRow(row int) Option {\n\treturn func(p *ProgressBar) {\n\t\tp.config.maxDetailRow = row\n\t}\n}\n\n// NewOptions constructs a new instance of ProgressBar, with any options you specify\nfunc NewOptions(max int, options ...Option) *ProgressBar {\n\treturn NewOptions64(int64(max), options...)\n}\n\n// NewOptions64 constructs a new instance of ProgressBar, with any options you specify\nfunc NewOptions64(max int64, options ...Option) *ProgressBar {\n\tb := ProgressBar{\n\t\tstate: state{\n\t\t\tstartTime:   time.Time{},\n\t\t\tlastShown:   time.Time{},\n\t\t\tcounterTime: time.Time{},\n\t\t},\n\t\tconfig: config{\n\t\t\twriter:                os.Stdout,\n\t\t\ttheme:                 ThemeDefault,\n\t\t\titerationString:       \"it\",\n\t\t\twidth:                 40,\n\t\t\tmax:                   max,\n\t\t\tthrottleDuration:      0 * time.Nanosecond,\n\t\t\telapsedTime:           max == -1,\n\t\t\tpredictTime:           true,\n\t\t\tspinnerType:           9,\n\t\t\tinvisible:             false,\n\t\t\tspinnerChangeInterval: 100 * time.Millisecond,\n\t\t\tshowTotalBytes:        true,\n\t\t},\n\t}\n\n\tfor _, o := range options {\n\t\to(&b)\n\t}\n\n\tif b.config.spinnerType < 0 || b.config.spinnerType > 75 {\n\t\tpanic(\"invalid spinner type, must be between 0 and 75\")\n\t}\n\n\tif b.config.maxDetailRow < 0 {\n\t\tpanic(\"invalid max detail row, must be greater than 0\")\n\t}\n\n\t// ignoreLength if max bytes not known\n\tif b.config.max == -1 {\n\t\tb.lengthUnknown()\n\t}\n\n\tb.config.maxHumanized, b.config.maxHumanizedSuffix = humanizeBytes(float64(b.config.max),\n\t\tb.config.useIECUnits)\n\n\tif b.config.renderWithBlankState {\n\t\tb.RenderBlank()\n\t}\n\n\t// if the render time interval attribute is set\n\tif b.config.spinnerChangeInterval != 0 && !b.config.invisible && b.config.ignoreLength {\n\t\tgo func() {\n\t\t\tticker := time.NewTicker(b.config.spinnerChangeInterval)\n\t\t\tdefer ticker.Stop()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\tif b.IsFinished() {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif b.IsStarted() {\n\t\t\t\t\t\tb.lock.Lock()\n\t\t\t\t\t\tb.render()\n\t\t\t\t\t\tb.lock.Unlock()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn &b\n}\n\nfunc getBasicState() state {\n\tnow := time.Now()\n\treturn state{\n\t\tstartTime:   now,\n\t\tlastShown:   now,\n\t\tcounterTime: now,\n\t}\n}\n\n// New returns a new ProgressBar\n// with the specified maximum\nfunc New(max int) *ProgressBar {\n\treturn NewOptions(max)\n}\n\n// DefaultBytes provides a progressbar to measure byte\n// throughput with recommended defaults.\n// Set maxBytes to -1 to use as a spinner.\nfunc DefaultBytes(maxBytes int64, description ...string) *ProgressBar {\n\tdesc := \"\"\n\tif len(description) > 0 {\n\t\tdesc = description[0]\n\t}\n\treturn NewOptions64(\n\t\tmaxBytes,\n\t\tOptionSetDescription(desc),\n\t\tOptionSetWriter(os.Stderr),\n\t\tOptionShowBytes(true),\n\t\tOptionShowTotalBytes(true),\n\t\tOptionSetWidth(10),\n\t\tOptionThrottle(65*time.Millisecond),\n\t\tOptionShowCount(),\n\t\tOptionOnCompletion(func() {\n\t\t\tfmt.Fprint(os.Stderr, \"\\n\")\n\t\t}),\n\t\tOptionSpinnerType(14),\n\t\tOptionFullWidth(),\n\t\tOptionSetRenderBlankState(true),\n\t)\n}\n\n// DefaultBytesSilent is the same as DefaultBytes, but does not output anywhere.\n// String() can be used to get the output instead.\nfunc DefaultBytesSilent(maxBytes int64, description ...string) *ProgressBar {\n\t// Mostly the same bar as DefaultBytes\n\n\tdesc := \"\"\n\tif len(description) > 0 {\n\t\tdesc = description[0]\n\t}\n\treturn NewOptions64(\n\t\tmaxBytes,\n\t\tOptionSetDescription(desc),\n\t\tOptionSetWriter(io.Discard),\n\t\tOptionShowBytes(true),\n\t\tOptionShowTotalBytes(true),\n\t\tOptionSetWidth(10),\n\t\tOptionThrottle(65*time.Millisecond),\n\t\tOptionShowCount(),\n\t\tOptionSpinnerType(14),\n\t\tOptionFullWidth(),\n\t)\n}\n\n// Default provides a progressbar with recommended defaults.\n// Set max to -1 to use as a spinner.\nfunc Default(max int64, description ...string) *ProgressBar {\n\tdesc := \"\"\n\tif len(description) > 0 {\n\t\tdesc = description[0]\n\t}\n\treturn NewOptions64(\n\t\tmax,\n\t\tOptionSetDescription(desc),\n\t\tOptionSetWriter(os.Stderr),\n\t\tOptionSetWidth(10),\n\t\tOptionShowTotalBytes(true),\n\t\tOptionThrottle(65*time.Millisecond),\n\t\tOptionShowCount(),\n\t\tOptionShowIts(),\n\t\tOptionOnCompletion(func() {\n\t\t\tfmt.Fprint(os.Stderr, \"\\n\")\n\t\t}),\n\t\tOptionSpinnerType(14),\n\t\tOptionFullWidth(),\n\t\tOptionSetRenderBlankState(true),\n\t)\n}\n\n// DefaultSilent is the same as Default, but does not output anywhere.\n// String() can be used to get the output instead.\nfunc DefaultSilent(max int64, description ...string) *ProgressBar {\n\t// Mostly the same bar as Default\n\n\tdesc := \"\"\n\tif len(description) > 0 {\n\t\tdesc = description[0]\n\t}\n\treturn NewOptions64(\n\t\tmax,\n\t\tOptionSetDescription(desc),\n\t\tOptionSetWriter(io.Discard),\n\t\tOptionSetWidth(10),\n\t\tOptionShowTotalBytes(true),\n\t\tOptionThrottle(65*time.Millisecond),\n\t\tOptionShowCount(),\n\t\tOptionShowIts(),\n\t\tOptionSpinnerType(14),\n\t\tOptionFullWidth(),\n\t)\n}\n\n// String returns the current rendered version of the progress bar.\n// It will never return an empty string while the progress bar is running.\nfunc (p *ProgressBar) String() string {\n\treturn p.state.rendered\n}\n\n// RenderBlank renders the current bar state, you can use this to render a 0% state\nfunc (p *ProgressBar) RenderBlank() error {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\tif p.config.invisible {\n\t\treturn nil\n\t}\n\tif p.state.currentNum == 0 {\n\t\tp.state.lastShown = time.Time{}\n\t}\n\treturn p.render()\n}\n\n// StartWithoutRender will start the progress bar without rendering it\n// this method is created for the use case where you want to start the progress\n// but don't want to render it immediately.\n// If you want to start the progress and render it immediately, use RenderBlank instead,\n// or maybe you can use Add to start it automatically, but it will make the time calculation less precise.\nfunc (p *ProgressBar) StartWithoutRender() {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\tif p.IsStarted() {\n\t\treturn\n\t}\n\n\tp.state.startTime = time.Now()\n\t// the counterTime should be set to the current time\n\tp.state.counterTime = time.Now()\n}\n\n// Reset will reset the clock that is used\n// to calculate current time and the time left.\nfunc (p *ProgressBar) Reset() {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\tp.state = getBasicState()\n}\n\n// Finish will fill the bar to full\nfunc (p *ProgressBar) Finish() error {\n\tp.lock.Lock()\n\tp.state.currentNum = p.config.max\n\tif !p.config.ignoreLength {\n\t\tp.state.currentBytes = float64(p.config.max)\n\t}\n\tp.lock.Unlock()\n\treturn p.Add(0)\n}\n\n// Exit will exit the bar to keep current state\nfunc (p *ProgressBar) Exit() error {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\tp.state.exit = true\n\tif p.config.onCompletion != nil {\n\t\tp.config.onCompletion()\n\t}\n\treturn nil\n}\n\n// Add will add the specified amount to the progressbar\nfunc (p *ProgressBar) Add(num int) error {\n\treturn p.Add64(int64(num))\n}\n\n// Set will set the bar to a current number\nfunc (p *ProgressBar) Set(num int) error {\n\treturn p.Set64(int64(num))\n}\n\n// Set64 will set the bar to a current number\nfunc (p *ProgressBar) Set64(num int64) error {\n\tp.lock.Lock()\n\ttoAdd := num - int64(p.state.currentBytes)\n\tp.lock.Unlock()\n\treturn p.Add64(toAdd)\n}\n\n// Add64 will add the specified amount to the progressbar\nfunc (p *ProgressBar) Add64(num int64) error {\n\tif p.config.invisible {\n\t\treturn nil\n\t}\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\tif p.state.exit {\n\t\treturn nil\n\t}\n\n\t// error out since OptionSpinnerCustom will always override a manually set spinnerType\n\tif p.config.spinnerTypeOptionUsed && len(p.config.spinner) > 0 {\n\t\treturn errors.New(\"OptionSpinnerType and OptionSpinnerCustom cannot be used together\")\n\t}\n\n\tif p.config.max == 0 {\n\t\treturn errors.New(\"max must be greater than 0\")\n\t}\n\n\tif p.state.currentNum < p.config.max {\n\t\tif p.config.ignoreLength {\n\t\t\tp.state.currentNum = (p.state.currentNum + num) % p.config.max\n\t\t} else {\n\t\t\tp.state.currentNum += num\n\t\t}\n\t}\n\n\tp.state.currentBytes += float64(num)\n\n\tif p.state.counterTime.IsZero() {\n\t\tp.state.counterTime = time.Now()\n\t}\n\n\t// reset the countdown timer every second to take rolling average\n\tp.state.counterNumSinceLast += num\n\tif time.Since(p.state.counterTime).Seconds() > 0.5 {\n\t\tp.state.counterLastTenRates = append(p.state.counterLastTenRates, float64(p.state.counterNumSinceLast)/time.Since(p.state.counterTime).Seconds())\n\t\tif len(p.state.counterLastTenRates) > 10 {\n\t\t\tp.state.counterLastTenRates = p.state.counterLastTenRates[1:]\n\t\t}\n\t\tp.state.counterTime = time.Now()\n\t\tp.state.counterNumSinceLast = 0\n\t}\n\n\tpercent := float64(p.state.currentNum) / float64(p.config.max)\n\tp.state.currentSaucerSize = int(percent * float64(p.config.width))\n\tp.state.currentPercent = int(percent * 100)\n\tupdateBar := p.state.currentPercent != p.state.lastPercent && p.state.currentPercent > 0\n\n\tp.state.lastPercent = p.state.currentPercent\n\tif p.state.currentNum > p.config.max {\n\t\treturn errors.New(\"current number exceeds max\")\n\t}\n\n\t// always update if show bytes/second or its/second\n\tif updateBar || p.config.showIterationsPerSecond || p.config.showIterationsCount {\n\t\treturn p.render()\n\t}\n\n\treturn nil\n}\n\n// AddDetail adds a detail to the progress bar. Only used when maxDetailRow is set to a value greater than 0\nfunc (p *ProgressBar) AddDetail(detail string) error {\n\tif p.config.maxDetailRow == 0 {\n\t\treturn errors.New(\"maxDetailRow is set to 0, cannot add detail\")\n\t}\n\tif p.IsFinished() {\n\t\treturn errors.New(\"cannot add detail to a finished progress bar\")\n\t}\n\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tif p.state.details == nil {\n\t\t// if we add a detail before the first add, it will be weird that we have detail but don't have the progress bar in the top.\n\t\t// so when we add the first detail, we will render the progress bar first.\n\t\tif err := p.render(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tp.state.details = append(p.state.details, detail)\n\tif len(p.state.details) > p.config.maxDetailRow {\n\t\tp.state.details = p.state.details[1:]\n\t}\n\tif err := p.renderDetails(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// renderDetails renders the details of the progress bar\nfunc (p *ProgressBar) renderDetails() error {\n\tif p.config.invisible {\n\t\treturn nil\n\t}\n\tif p.state.finished {\n\t\treturn nil\n\t}\n\tif p.config.maxDetailRow == 0 {\n\t\treturn nil\n\t}\n\n\tb := strings.Builder{}\n\tb.WriteString(\"\\n\")\n\n\t// render the details row\n\tfor _, detail := range p.state.details {\n\t\tb.WriteString(fmt.Sprintf(\"\\u001B[K\\r%s\\n\", detail))\n\t}\n\t// add empty lines to fill the maxDetailRow\n\tfor i := len(p.state.details); i < p.config.maxDetailRow; i++ {\n\t\tb.WriteString(\"\\u001B[K\\n\")\n\t}\n\n\t// move the cursor up to the start of the details row\n\tb.WriteString(fmt.Sprintf(\"\\u001B[%dF\", p.config.maxDetailRow+1))\n\n\twriteString(p.config, b.String())\n\n\treturn nil\n}\n\n// Clear erases the progress bar from the current line\nfunc (p *ProgressBar) Clear() error {\n\treturn clearProgressBar(p.config, p.state)\n}\n\n// Describe will change the description shown before the progress, which\n// can be changed on the fly (as for a slow running process).\nfunc (p *ProgressBar) Describe(description string) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tp.config.description = description\n\tif p.config.invisible {\n\t\treturn\n\t}\n\tp.render()\n}\n\n// New64 returns a new ProgressBar\n// with the specified maximum\nfunc New64(max int64) *ProgressBar {\n\treturn NewOptions64(max)\n}\n\n// GetMax returns the max of a bar\nfunc (p *ProgressBar) GetMax() int {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\treturn int(p.config.max)\n}\n\n// GetMax64 returns the current max\nfunc (p *ProgressBar) GetMax64() int64 {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\treturn p.config.max\n}\n\n// ChangeMax takes in a int\n// and changes the max value\n// of the progress bar\nfunc (p *ProgressBar) ChangeMax(newMax int) {\n\tp.ChangeMax64(int64(newMax))\n}\n\n// ChangeMax64 is basically\n// the same as ChangeMax,\n// but takes in a int64\n// to avoid casting\nfunc (p *ProgressBar) ChangeMax64(newMax int64) {\n\tp.lock.Lock()\n\n\tp.config.max = newMax\n\n\tif p.config.showBytes {\n\t\tp.config.maxHumanized, p.config.maxHumanizedSuffix = humanizeBytes(float64(p.config.max),\n\t\t\tp.config.useIECUnits)\n\t}\n\n\tif newMax == -1 {\n\t\tp.lengthUnknown()\n\t} else {\n\t\tp.lengthKnown(newMax)\n\t}\n\tp.lock.Unlock() // so p.Add can lock\n\n\tp.Add(0) // re-render\n}\n\n// AddMax takes in a int\n// and adds it to the max\n// value of the progress bar\nfunc (p *ProgressBar) AddMax(added int) {\n\tp.AddMax64(int64(added))\n}\n\n// AddMax64 is basically\n// the same as AddMax,\n// but takes in a int64\n// to avoid casting\nfunc (p *ProgressBar) AddMax64(added int64) {\n\tp.lock.Lock()\n\n\tp.config.max += added\n\n\tif p.config.showBytes {\n\t\tp.config.maxHumanized, p.config.maxHumanizedSuffix = humanizeBytes(float64(p.config.max),\n\t\t\tp.config.useIECUnits)\n\t}\n\n\tif p.config.max == -1 {\n\t\tp.lengthUnknown()\n\t} else {\n\t\tp.lengthKnown(p.config.max)\n\t}\n\tp.lock.Unlock() // so p.Add can lock\n\n\tp.Add(0) // re-render\n}\n\n// IsFinished returns true if progress bar is completed\nfunc (p *ProgressBar) IsFinished() bool {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\treturn p.state.finished\n}\n\n// IsStarted returns true if progress bar is started\nfunc (p *ProgressBar) IsStarted() bool {\n\treturn !p.state.startTime.IsZero()\n}\n\n// render renders the progress bar, updating the maximum\n// rendered line width. this function is not thread-safe,\n// so it must be called with an acquired lock.\nfunc (p *ProgressBar) render() error {\n\t// make sure that the rendering is not happening too quickly\n\t// but always show if the currentNum reaches the max\n\tif !p.IsStarted() {\n\t\tp.state.startTime = time.Now()\n\t} else if time.Since(p.state.lastShown).Nanoseconds() < p.config.throttleDuration.Nanoseconds() &&\n\t\tp.state.currentNum < p.config.max {\n\t\treturn nil\n\t}\n\n\tif !p.config.useANSICodes {\n\t\t// first, clear the existing progress bar, if not yet finished.\n\t\tif !p.state.finished {\n\t\t\terr := clearProgressBar(p.config, p.state)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\t// check if the progress bar is finished\n\tif !p.state.finished && p.state.currentNum >= p.config.max {\n\t\tp.state.finished = true\n\t\tif !p.config.clearOnFinish {\n\t\t\tio.Copy(p.config.writer, &p.config.stdBuffer)\n\t\t\trenderProgressBar(p.config, &p.state)\n\t\t}\n\t\tif p.config.maxDetailRow > 0 {\n\t\t\tp.renderDetails()\n\t\t\t// put the cursor back to the last line of the details\n\t\t\twriteString(p.config, fmt.Sprintf(\"\\u001B[%dB\\r\\u001B[%dC\", p.config.maxDetailRow, len(p.state.details[len(p.state.details)-1])))\n\t\t}\n\t\tif p.config.onCompletion != nil {\n\t\t\tp.config.onCompletion()\n\t\t}\n\t}\n\tif p.state.finished {\n\t\t// when using ANSI codes we don't pre-clean the current line\n\t\tif p.config.useANSICodes && p.config.clearOnFinish {\n\t\t\terr := clearProgressBar(p.config, p.state)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\t// then, re-render the current progress bar\n\tio.Copy(p.config.writer, &p.config.stdBuffer)\n\tw, err := renderProgressBar(p.config, &p.state)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif w > p.state.maxLineWidth {\n\t\tp.state.maxLineWidth = w\n\t}\n\n\tp.state.lastShown = time.Now()\n\n\treturn nil\n}\n\n// lengthUnknown sets the progress bar to ignore the length\nfunc (p *ProgressBar) lengthUnknown() {\n\tp.config.ignoreLength = true\n\tp.config.max = int64(p.config.width)\n\tp.config.predictTime = false\n}\n\n// lengthKnown sets the progress bar to do not ignore the length\nfunc (p *ProgressBar) lengthKnown(max int64) {\n\tp.config.ignoreLength = false\n\tp.config.max = max\n\tp.config.predictTime = true\n}\n\n// State returns the current state\nfunc (p *ProgressBar) State() State {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\ts := State{}\n\ts.CurrentNum = p.state.currentNum\n\ts.Max = p.config.max\n\tif p.config.ignoreLength {\n\t\ts.Max = -1\n\t}\n\ts.CurrentPercent = float64(p.state.currentNum) / float64(p.config.max)\n\ts.CurrentBytes = p.state.currentBytes\n\tif p.IsStarted() {\n\t\ts.SecondsSince = time.Since(p.state.startTime).Seconds()\n\t} else {\n\t\ts.SecondsSince = 0\n\t}\n\n\tif p.state.currentNum > 0 {\n\t\ts.SecondsLeft = s.SecondsSince / float64(p.state.currentNum) * (float64(p.config.max) - float64(p.state.currentNum))\n\t}\n\ts.KBsPerSecond = float64(p.state.currentBytes) / 1024.0 / s.SecondsSince\n\ts.Description = p.config.description\n\treturn s\n}\n\n// StartHTTPServer starts an HTTP server dedicated to serving progress bar updates. This allows you to\n// display the status in various UI elements, such as an OS status bar with an `xbar` extension.\n// It is recommended to run this function in a separate goroutine to avoid blocking the main thread.\n//\n// hostPort specifies the address and port to bind the server to, for example, \"0.0.0.0:19999\".\nfunc (p *ProgressBar) StartHTTPServer(hostPort string) {\n\t// for advanced users, we can return the data as json\n\thttp.HandleFunc(\"/state\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/json\")\n\t\t// since the state is a simple struct, we can just ignore the error\n\t\tbs, _ := json.Marshal(p.State())\n\t\tw.Write(bs)\n\t})\n\t// for others, we just return the description in a plain text format\n\thttp.HandleFunc(\"/desc\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tfmt.Fprintf(w,\n\t\t\t\"%d/%d, %.2f%%, %s left\",\n\t\t\tp.State().CurrentNum, p.State().Max, p.State().CurrentPercent*100,\n\t\t\t(time.Second * time.Duration(p.State().SecondsLeft)).String(),\n\t\t)\n\t})\n\tlog.Fatal(http.ListenAndServe(hostPort, nil))\n}\n\n// regex matching ansi escape codes\nvar ansiRegex = regexp.MustCompile(`\\x1b\\[[0-9;]*[a-zA-Z]`)\n\nfunc getStringWidth(c config, str string, colorize bool) int {\n\tif c.colorCodes {\n\t\t// convert any color codes in the progress bar into the respective ANSI codes\n\t\tstr = colorstring.Color(str)\n\t}\n\n\t// the width of the string, if printed to the console\n\t// does not include the carriage return character\n\tcleanString := strings.Replace(str, \"\\r\", \"\", -1)\n\n\tif c.colorCodes {\n\t\t// the ANSI codes for the colors do not take up space in the console output,\n\t\t// so they do not count towards the output string width\n\t\tcleanString = ansiRegex.ReplaceAllString(cleanString, \"\")\n\t}\n\n\t// get the amount of runes in the string instead of the\n\t// character count of the string, as some runes span multiple characters.\n\t// see https://stackoverflow.com/a/12668840/2733724\n\tstringWidth := uniseg.StringWidth(cleanString)\n\treturn stringWidth\n}\n\nfunc renderProgressBar(c config, s *state) (int, error) {\n\tvar sb strings.Builder\n\n\taverageRate := average(s.counterLastTenRates)\n\tif len(s.counterLastTenRates) == 0 || s.finished {\n\t\t// if no average samples, or if finished,\n\t\t// then average rate should be the total rate\n\t\tif t := time.Since(s.startTime).Seconds(); t > 0 {\n\t\t\taverageRate = s.currentBytes / t\n\t\t} else {\n\t\t\taverageRate = 0\n\t\t}\n\t}\n\n\t// show iteration count in \"current/total\" iterations format\n\tif c.showIterationsCount {\n\t\tif sb.Len() == 0 {\n\t\t\tsb.WriteString(\"(\")\n\t\t} else {\n\t\t\tsb.WriteString(\", \")\n\t\t}\n\t\tif !c.ignoreLength {\n\t\t\tif c.showBytes {\n\t\t\t\tcurrentHumanize, currentSuffix := humanizeBytes(s.currentBytes, c.useIECUnits)\n\t\t\t\tif currentSuffix == c.maxHumanizedSuffix {\n\t\t\t\t\tif c.showTotalBytes {\n\t\t\t\t\t\tsb.WriteString(fmt.Sprintf(\"%s/%s%s\",\n\t\t\t\t\t\t\tcurrentHumanize, c.maxHumanized, c.maxHumanizedSuffix))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.WriteString(fmt.Sprintf(\"%s%s\",\n\t\t\t\t\t\t\tcurrentHumanize, c.maxHumanizedSuffix))\n\t\t\t\t\t}\n\t\t\t\t} else if c.showTotalBytes {\n\t\t\t\t\tsb.WriteString(fmt.Sprintf(\"%s%s/%s%s\",\n\t\t\t\t\t\tcurrentHumanize, currentSuffix, c.maxHumanized, c.maxHumanizedSuffix))\n\t\t\t\t} else {\n\t\t\t\t\tsb.WriteString(fmt.Sprintf(\"%s%s\", currentHumanize, currentSuffix))\n\t\t\t\t}\n\t\t\t} else if c.showTotalBytes {\n\t\t\t\tsb.WriteString(fmt.Sprintf(\"%.0f/%d\", s.currentBytes, c.max))\n\t\t\t} else {\n\t\t\t\tsb.WriteString(fmt.Sprintf(\"%.0f\", s.currentBytes))\n\t\t\t}\n\t\t} else {\n\t\t\tif c.showBytes {\n\t\t\t\tcurrentHumanize, currentSuffix := humanizeBytes(s.currentBytes, c.useIECUnits)\n\t\t\t\tsb.WriteString(fmt.Sprintf(\"%s%s\", currentHumanize, currentSuffix))\n\t\t\t} else if c.showTotalBytes {\n\t\t\t\tsb.WriteString(fmt.Sprintf(\"%.0f/%s\", s.currentBytes, \"-\"))\n\t\t\t} else {\n\t\t\t\tsb.WriteString(fmt.Sprintf(\"%.0f\", s.currentBytes))\n\t\t\t}\n\t\t}\n\t}\n\n\t// show rolling average rate\n\tif c.showBytes && averageRate > 0 && !math.IsInf(averageRate, 1) {\n\t\tif sb.Len() == 0 {\n\t\t\tsb.WriteString(\"(\")\n\t\t} else {\n\t\t\tsb.WriteString(\", \")\n\t\t}\n\t\tcurrentHumanize, currentSuffix := humanizeBytes(averageRate, c.useIECUnits)\n\t\tsb.WriteString(fmt.Sprintf(\"%s%s/s\", currentHumanize, currentSuffix))\n\t}\n\n\t// show iterations rate\n\tif c.showIterationsPerSecond {\n\t\tif sb.Len() == 0 {\n\t\t\tsb.WriteString(\"(\")\n\t\t} else {\n\t\t\tsb.WriteString(\", \")\n\t\t}\n\t\tif averageRate > 1 {\n\t\t\tsb.WriteString(fmt.Sprintf(\"%0.0f %s/s\", averageRate, c.iterationString))\n\t\t} else if averageRate*60 > 1 {\n\t\t\tsb.WriteString(fmt.Sprintf(\"%0.0f %s/min\", 60*averageRate, c.iterationString))\n\t\t} else {\n\t\t\tsb.WriteString(fmt.Sprintf(\"%0.0f %s/hr\", 3600*averageRate, c.iterationString))\n\t\t}\n\t}\n\tif sb.Len() > 0 {\n\t\tsb.WriteString(\")\")\n\t}\n\n\tleftBrac, rightBrac, saucer, saucerHead := \"\", \"\", \"\", \"\"\n\tbarStart, barEnd := c.theme.BarStart, c.theme.BarEnd\n\tif s.finished && c.theme.BarEndFilled != \"\" {\n\t\tbarEnd = c.theme.BarEndFilled\n\t}\n\n\t// show time prediction in \"current/total\" seconds format\n\tswitch {\n\tcase c.predictTime:\n\t\trightBracNum := (time.Duration((1/averageRate)*(float64(c.max)-float64(s.currentNum))) * time.Second)\n\t\tif rightBracNum.Seconds() < 0 {\n\t\t\trightBracNum = 0 * time.Second\n\t\t}\n\t\trightBrac = rightBracNum.String()\n\t\tfallthrough\n\tcase c.elapsedTime || c.showElapsedTimeOnFinish:\n\t\tleftBrac = (time.Duration(time.Since(s.startTime).Seconds()) * time.Second).String()\n\t}\n\n\tif c.fullWidth && !c.ignoreLength {\n\t\twidth, err := termWidth()\n\t\tif err != nil {\n\t\t\twidth = 80\n\t\t}\n\n\t\tamend := 1 // an extra space at eol\n\t\tswitch {\n\t\tcase leftBrac != \"\" && rightBrac != \"\":\n\t\t\tamend = 4 // space, square brackets and colon\n\t\tcase leftBrac != \"\" && rightBrac == \"\":\n\t\t\tamend = 4 // space and square brackets and another space\n\t\tcase leftBrac == \"\" && rightBrac != \"\":\n\t\t\tamend = 3 // space and square brackets\n\t\t}\n\t\tif c.showDescriptionAtLineEnd {\n\t\t\tamend += 1 // another space\n\t\t}\n\n\t\tc.width = width - getStringWidth(c, c.description, true) - 10 - amend - sb.Len() - len(leftBrac) - len(rightBrac)\n\t\ts.currentSaucerSize = int(float64(s.currentPercent) / 100.0 * float64(c.width))\n\t}\n\tif (s.currentSaucerSize > 0 || s.currentPercent > 0) && c.theme.BarStartFilled != \"\" {\n\t\tbarStart = c.theme.BarStartFilled\n\t}\n\tif s.currentSaucerSize > 0 {\n\t\tif c.ignoreLength {\n\t\t\tsaucer = strings.Repeat(c.theme.SaucerPadding, s.currentSaucerSize-1)\n\t\t} else {\n\t\t\tsaucer = strings.Repeat(c.theme.Saucer, s.currentSaucerSize-1)\n\t\t}\n\n\t\t// Check if an alternate saucer head is set for animation\n\t\tif c.theme.AltSaucerHead != \"\" && s.isAltSaucerHead {\n\t\t\tsaucerHead = c.theme.AltSaucerHead\n\t\t\ts.isAltSaucerHead = false\n\t\t} else if c.theme.SaucerHead == \"\" || s.currentSaucerSize == c.width {\n\t\t\t// use the saucer for the saucer head if it hasn't been set\n\t\t\t// to preserve backwards compatibility\n\t\t\tsaucerHead = c.theme.Saucer\n\t\t} else {\n\t\t\tsaucerHead = c.theme.SaucerHead\n\t\t\ts.isAltSaucerHead = true\n\t\t}\n\t}\n\n\t/*\n\t\tProgress Bar format\n\t\tDescription % |------        |  (kb/s) (iteration count) (iteration rate) (predict time)\n\n\t\tor if showDescriptionAtLineEnd is enabled\n\t\t% |------        |  (kb/s) (iteration count) (iteration rate) (predict time) Description\n\t*/\n\n\trepeatAmount := c.width - s.currentSaucerSize\n\tif repeatAmount < 0 {\n\t\trepeatAmount = 0\n\t}\n\n\tstr := \"\"\n\n\tif c.ignoreLength {\n\t\tselectedSpinner := spinners[c.spinnerType]\n\t\tif len(c.spinner) > 0 {\n\t\t\tselectedSpinner = c.spinner\n\t\t}\n\n\t\tvar spinner string\n\t\tif c.spinnerChangeInterval != 0 {\n\t\t\t// if the spinner is changed according to an interval, calculate it\n\t\t\tspinner = selectedSpinner[int(math.Round(math.Mod(float64(time.Since(s.startTime).Nanoseconds()/c.spinnerChangeInterval.Nanoseconds()), float64(len(selectedSpinner)))))]\n\t\t} else {\n\t\t\t// if the spinner is changed according to the number render was called\n\t\t\tspinner = selectedSpinner[s.spinnerIdx]\n\t\t\ts.spinnerIdx = (s.spinnerIdx + 1) % len(selectedSpinner)\n\t\t}\n\t\tif c.elapsedTime {\n\t\t\tif c.showDescriptionAtLineEnd {\n\t\t\t\tstr = fmt.Sprintf(\"\\r%s %s [%s] %s \",\n\t\t\t\t\tspinner,\n\t\t\t\t\tsb.String(),\n\t\t\t\t\tleftBrac,\n\t\t\t\t\tc.description)\n\t\t\t} else {\n\t\t\t\tstr = fmt.Sprintf(\"\\r%s %s %s [%s] \",\n\t\t\t\t\tspinner,\n\t\t\t\t\tc.description,\n\t\t\t\t\tsb.String(),\n\t\t\t\t\tleftBrac)\n\t\t\t}\n\t\t} else {\n\t\t\tif c.showDescriptionAtLineEnd {\n\t\t\t\tstr = fmt.Sprintf(\"\\r%s %s %s \",\n\t\t\t\t\tspinner,\n\t\t\t\t\tsb.String(),\n\t\t\t\t\tc.description)\n\t\t\t} else {\n\t\t\t\tstr = fmt.Sprintf(\"\\r%s %s %s \",\n\t\t\t\t\tspinner,\n\t\t\t\t\tc.description,\n\t\t\t\t\tsb.String())\n\t\t\t}\n\t\t}\n\t} else if rightBrac == \"\" {\n\t\tstr = fmt.Sprintf(\"%4d%% %s%s%s%s%s %s\",\n\t\t\ts.currentPercent,\n\t\t\tbarStart,\n\t\t\tsaucer,\n\t\t\tsaucerHead,\n\t\t\tstrings.Repeat(c.theme.SaucerPadding, repeatAmount),\n\t\t\tbarEnd,\n\t\t\tsb.String())\n\t\tif (s.currentPercent == 100 && c.showElapsedTimeOnFinish) || c.elapsedTime {\n\t\t\tstr = fmt.Sprintf(\"%s [%s]\", str, leftBrac)\n\t\t}\n\n\t\tif c.showDescriptionAtLineEnd {\n\t\t\tstr = fmt.Sprintf(\"\\r%s %s \", str, c.description)\n\t\t} else {\n\t\t\tstr = fmt.Sprintf(\"\\r%s%s \", c.description, str)\n\t\t}\n\t} else {\n\t\tif s.currentPercent == 100 {\n\t\t\tstr = fmt.Sprintf(\"%4d%% %s%s%s%s%s %s\",\n\t\t\t\ts.currentPercent,\n\t\t\t\tbarStart,\n\t\t\t\tsaucer,\n\t\t\t\tsaucerHead,\n\t\t\t\tstrings.Repeat(c.theme.SaucerPadding, repeatAmount),\n\t\t\t\tbarEnd,\n\t\t\t\tsb.String())\n\n\t\t\tif c.showElapsedTimeOnFinish {\n\t\t\t\tstr = fmt.Sprintf(\"%s [%s]\", str, leftBrac)\n\t\t\t}\n\n\t\t\tif c.showDescriptionAtLineEnd {\n\t\t\t\tstr = fmt.Sprintf(\"\\r%s %s\", str, c.description)\n\t\t\t} else {\n\t\t\t\tstr = fmt.Sprintf(\"\\r%s%s\", c.description, str)\n\t\t\t}\n\t\t} else {\n\t\t\tstr = fmt.Sprintf(\"%4d%% %s%s%s%s%s %s [%s:%s]\",\n\t\t\t\ts.currentPercent,\n\t\t\t\tbarStart,\n\t\t\t\tsaucer,\n\t\t\t\tsaucerHead,\n\t\t\t\tstrings.Repeat(c.theme.SaucerPadding, repeatAmount),\n\t\t\t\tbarEnd,\n\t\t\t\tsb.String(),\n\t\t\t\tleftBrac,\n\t\t\t\trightBrac)\n\n\t\t\tif c.showDescriptionAtLineEnd {\n\t\t\t\tstr = fmt.Sprintf(\"\\r%s %s\", str, c.description)\n\t\t\t} else {\n\t\t\t\tstr = fmt.Sprintf(\"\\r%s%s\", c.description, str)\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.colorCodes {\n\t\t// convert any color codes in the progress bar into the respective ANSI codes\n\t\tstr = colorstring.Color(str)\n\t}\n\n\ts.rendered = str\n\n\treturn getStringWidth(c, str, false), writeString(c, str)\n}\n\nfunc clearProgressBar(c config, s state) error {\n\tif s.maxLineWidth == 0 {\n\t\treturn nil\n\t}\n\tif c.useANSICodes {\n\t\t// write the \"clear current line\" ANSI escape sequence\n\t\treturn writeString(c, \"\\033[2K\\r\")\n\t}\n\t// fill the empty content\n\t// to overwrite the progress bar and jump\n\t// back to the beginning of the line\n\tstr := fmt.Sprintf(\"\\r%s\\r\", strings.Repeat(\" \", s.maxLineWidth))\n\treturn writeString(c, str)\n\t// the following does not show correctly if the previous line is longer than subsequent line\n\t// return writeString(c, \"\\r\")\n}\n\nfunc writeString(c config, str string) error {\n\tif _, err := io.WriteString(c.writer, str); err != nil {\n\t\treturn err\n\t}\n\n\tif f, ok := c.writer.(*os.File); ok {\n\t\t// ignore any errors in Sync(), as stdout\n\t\t// can't be synced on some operating systems\n\t\t// like Debian 9 (Stretch)\n\t\tf.Sync()\n\t}\n\n\treturn nil\n}\n\n// Reader is the progressbar io.Reader struct\ntype Reader struct {\n\tio.Reader\n\tbar *ProgressBar\n}\n\n// NewReader return a new Reader with a given progress bar.\nfunc NewReader(r io.Reader, bar *ProgressBar) Reader {\n\treturn Reader{\n\t\tReader: r,\n\t\tbar:    bar,\n\t}\n}\n\n// Read will read the data and add the number of bytes to the progressbar\nfunc (r *Reader) Read(p []byte) (n int, err error) {\n\tn, err = r.Reader.Read(p)\n\tr.bar.Add(n)\n\treturn\n}\n\n// Close the reader when it implements io.Closer\nfunc (r *Reader) Close() (err error) {\n\tif closer, ok := r.Reader.(io.Closer); ok {\n\t\treturn closer.Close()\n\t}\n\tr.bar.Finish()\n\treturn\n}\n\n// Write implement io.Writer\nfunc (p *ProgressBar) Write(b []byte) (n int, err error) {\n\tn = len(b)\n\terr = p.Add(n)\n\treturn\n}\n\n// Read implement io.Reader\nfunc (p *ProgressBar) Read(b []byte) (n int, err error) {\n\tn = len(b)\n\terr = p.Add(n)\n\treturn\n}\n\nfunc (p *ProgressBar) Close() (err error) {\n\terr = p.Finish()\n\treturn\n}\n\nfunc average(xs []float64) float64 {\n\ttotal := 0.0\n\tfor _, v := range xs {\n\t\ttotal += v\n\t}\n\treturn total / float64(len(xs))\n}\n\nfunc humanizeBytes(s float64, iec bool) (string, string) {\n\tsizes := []string{\" B\", \" kB\", \" MB\", \" GB\", \" TB\", \" PB\", \" EB\"}\n\tbase := 1000.0\n\n\tif iec {\n\t\tsizes = []string{\" B\", \" KiB\", \" MiB\", \" GiB\", \" TiB\", \" PiB\", \" EiB\"}\n\t\tbase = 1024.0\n\t}\n\n\tif s < 10 {\n\t\treturn fmt.Sprintf(\"%2.0f\", s), sizes[0]\n\t}\n\te := math.Floor(logn(float64(s), base))\n\tsuffix := sizes[int(e)]\n\tval := math.Floor(float64(s)/math.Pow(base, e)*10+0.5) / 10\n\tf := \"%.0f\"\n\tif val < 10 {\n\t\tf = \"%.1f\"\n\t}\n\n\treturn fmt.Sprintf(f, val), suffix\n}\n\nfunc logn(n, b float64) float64 {\n\treturn math.Log(n) / math.Log(b)\n}\n\n// termWidth function returns the visible width of the current terminal\n// and can be redefined for testing\nvar termWidth = func() (width int, err error) {\n\twidth, _, err = term.GetSize(int(os.Stdout.Fd()))\n\tif err == nil {\n\t\treturn width, nil\n\t}\n\n\treturn 0, err\n}\n\nfunc shouldCacheOutput(pb *ProgressBar) bool {\n\treturn !pb.state.finished && !pb.state.exit && !pb.config.invisible\n}\n\nfunc Bprintln(pb *ProgressBar, a ...interface{}) (int, error) {\n\tpb.lock.Lock()\n\tdefer pb.lock.Unlock()\n\tif !shouldCacheOutput(pb) {\n\t\treturn fmt.Fprintln(pb.config.writer, a...)\n\t} else {\n\t\treturn fmt.Fprintln(&pb.config.stdBuffer, a...)\n\t}\n}\n\nfunc Bprintf(pb *ProgressBar, format string, a ...interface{}) (int, error) {\n\tpb.lock.Lock()\n\tdefer pb.lock.Unlock()\n\tif !shouldCacheOutput(pb) {\n\t\treturn fmt.Fprintf(pb.config.writer, format, a...)\n\t} else {\n\t\treturn fmt.Fprintf(&pb.config.stdBuffer, format, a...)\n\t}\n}\n"
        },
        {
          "name": "progressbar_test.go",
          "type": "blob",
          "size": 31.70703125,
          "content": "package progressbar\n\nimport (\n\t\"bytes\"\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/chengxilo/virtualterm\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMain(m *testing.M) {\n\ttermWidth = func() (int, error) {\n\t\treturn 0, os.ErrPermission\n\t}\n\tos.Exit(m.Run())\n}\n\nfunc BenchmarkRender(b *testing.B) {\n\tbar := NewOptions64(100000000,\n\t\tOptionSetWriter(os.Stderr),\n\t\tOptionShowIts(),\n\t)\n\tfor i := 0; i < b.N; i++ {\n\t\tbar.Add(1)\n\t}\n}\n\nfunc ExampleProgressBar() {\n\tbar := New(100)\n\tbar.Add(10)\n\t// Output:\n\t// 10% |████                                    |  [0s:0s]\n}\n\nfunc ExampleProgressBar_Set() {\n\tbar := New(100)\n\tbar.Set(10)\n\t// Output:\n\t// 10% |████                                    |  [0s:0s]\n}\n\nfunc ExampleProgressBar_Set64() {\n\tbar := New(100)\n\tbar.Set64(10)\n\t// Output:\n\t// 10% |████                                    |  [0s:0s]\n}\n\nfunc ExampleProgressBar_basic() {\n\tbar := NewOptions(100, OptionSetWidth(10))\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(10)\n\t// Output:\n\t// 10% |█         |  [1s:9s]\n}\n\nfunc ExampleProgressBar_invisible() {\n\tbar := NewOptions(100, OptionSetWidth(10), OptionSetRenderBlankState(true), OptionSetVisibility(false))\n\tbar.Reset()\n\tfmt.Println(\"hello, world\")\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(10)\n\t// Output:\n\t// hello, world\n}\n\nfunc ExampleOptionThrottle() {\n\tbar := NewOptions(100, OptionSetWidth(10), OptionThrottle(100*time.Millisecond))\n\tbar.Reset()\n\tbar.Add(5)\n\ttime.Sleep(150 * time.Millisecond)\n\tbar.Add(5)\n\tbar.Add(10)\n\t// Output:\n\t// 10% |█         |  [0s:1s]\n}\n\nfunc ExampleOptionClearOnFinish() {\n\tbar := NewOptions(100, OptionSetWidth(10), OptionClearOnFinish())\n\tbar.Reset()\n\tbar.Finish()\n\tfmt.Println(\"Finished\")\n\t// Output:\n\t// Finished\n}\n\nfunc TestSpinnerClearOnFinish(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(-1, OptionSetWidth(100), OptionShowCount(), OptionShowBytes(true), OptionShowIts(), OptionClearOnFinish(), OptionSetWriter(&buf))\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(10)\n\ttime.Sleep(1 * time.Second)\n\tbar.Finish()\n\tresult, _ := virtualterm.Process(buf.String())\n\texpect := \"                                \"\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc ExampleProgressBar_Finish() {\n\tbar := NewOptions(100, OptionSetWidth(10), OptionShowCount(), OptionShowBytes(true), OptionShowIts())\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Finish()\n\t// Output:\n\t// 100% |██████████| (100/100 B, 100 B/s, 100 it/s)\n}\n\nfunc TestSpinnerFinish(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(-1, OptionSetWidth(100), OptionShowCount(), OptionShowBytes(true), OptionShowIts(), OptionSetWriter(&buf))\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(10)\n\ttime.Sleep(1 * time.Second)\n\tbar.Finish()\n\tresult, err := virtualterm.Process(buf.String())\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\t// the \"\\r \\r\"\n\texpect := \"|  (10 B,  5 B/s, 5 it/s) [2s]  \"\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc Example_xOutOfY() {\n\tbar := NewOptions(100, OptionSetPredictTime(true))\n\n\tfor i := 0; i < 100; i++ {\n\t\tbar.Add(1)\n\t\ttime.Sleep(1 * time.Millisecond)\n\t}\n}\n\nfunc ExampleOptionShowIts_count() {\n\tbar := NewOptions(100, OptionSetWidth(10), OptionShowIts(), OptionShowCount())\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(10)\n\t// Output:\n\t// 10% |█         | (10/100, 10 it/s) [1s:9s]\n}\n\nfunc ExampleOptionShowIts() {\n\tbar := NewOptions(100, OptionSetWidth(10), OptionShowIts(), OptionSetPredictTime(false))\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(10)\n\t// Output:\n\t// 10% |█         | (10 it/s)\n}\n\nfunc ExampleOptionShowCount_minuscule() {\n\tbar := NewOptions(10000, OptionSetWidth(10), OptionShowCount(), OptionSetPredictTime(false))\n\tbar.Add(1)\n\t// Output:\n\t// 0% |          | (1/10000)\n}\n\nfunc ExampleOptionSetPredictTime() {\n\tbar := NewOptions(100, OptionSetWidth(10), OptionSetPredictTime(false))\n\t_ = bar.Add(10)\n\t// Output:\n\t// 10% |█         |\n}\n\nfunc ExampleOptionShowDescriptionAtLineEnd() {\n\tbar := NewOptions(100, OptionSetWidth(10), OptionShowDescriptionAtLineEnd(), OptionSetDescription(\"hello\"))\n\t_ = bar.Add(10)\n\t// Output:\n\t// 10% |█         |  [0s:0s] hello\n}\n\nfunc ExampleOptionShowDescriptionAtLineEnd_spinner() {\n\tbar := NewOptions(-1, OptionSetWidth(10), OptionShowDescriptionAtLineEnd(), OptionSetDescription(\"hello\"))\n\t_ = bar.Add(1)\n\t// Output:\n\t// |  [0s] hello\n}\n\nfunc ExampleDefault() {\n\tbar := Default(100)\n\tfor i := 0; i < 50; i++ {\n\t\tbar.Add(1)\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\t// Output:\n\t//\n}\n\nfunc ExampleProgressBar_ChangeMax() {\n\tbar := NewOptions(100, OptionSetWidth(10), OptionSetPredictTime(false))\n\tbar.ChangeMax(50)\n\tbar.Add(50)\n\t// Output:\n\t// 100% |██████████|\n}\n\nfunc ExampleProgressBar_AddMax() {\n\tbar := NewOptions(50, OptionSetWidth(10), OptionSetPredictTime(false))\n\tbar.AddMax(50)\n\tbar.Add(100)\n\t// Output:\n\t// 100% |██████████|\n}\n\nfunc ExampleOptionShowIts_spinner() {\n\t/*\n\t\tSpinner test with iteration count and iteration rate\n\t*/\n\tvt := virtualterm.NewDefault()\n\tbar := NewOptions(-1,\n\t\tOptionSetWidth(10),\n\t\tOptionShowIts(),\n\t\tOptionShowCount(),\n\t\tOptionSetWriter(&vt),\n\t)\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(5)\n\tbar.lock.Lock()\n\ts, err := vt.String()\n\tbar.lock.Unlock()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Print(s)\n\t// Output:\n\t// -  (5/-, 5 it/s) [1s]\n}\n\nfunc TestSpinnerType(t *testing.T) {\n\tbar := NewOptions(-1,\n\t\tOptionSetWidth(10),\n\t\tOptionSetDescription(\"indeterminate spinner\"),\n\t\tOptionShowIts(),\n\t\tOptionShowCount(),\n\t\tOptionSpinnerType(9),\n\t)\n\tbar.Reset()\n\tfor i := 0; i < 10; i++ {\n\t\ttime.Sleep(120 * time.Millisecond)\n\t\terr := bar.Add(1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Successfully tested one spinner option can be used.\")\n\t\t}\n\t}\n\tif false {\n\t\tt.Errorf(\"error\")\n\t}\n}\n\nfunc TestSpinnerCustom(t *testing.T) {\n\tbar := NewOptions(-1,\n\t\tOptionSetWidth(10),\n\t\tOptionSetDescription(\"indeterminate spinner\"),\n\t\tOptionShowIts(),\n\t\tOptionShowCount(),\n\t\tOptionSpinnerCustom([]string{\"🐰\", \"🐰\", \"🥕\", \"🥕\"}),\n\t)\n\tbar.Reset()\n\tfor i := 0; i < 10; i++ {\n\t\ttime.Sleep(120 * time.Millisecond)\n\t\terr := bar.Add(1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Successfully tested one spinner option can be used.\")\n\t\t}\n\t}\n\tif false {\n\t\tt.Errorf(\"error\")\n\t}\n}\n\nfunc TestSpinnerTypeAndCustom(t *testing.T) {\n\tbar := NewOptions(-1,\n\t\tOptionSetWidth(10),\n\t\tOptionSetDescription(\"indeterminate spinner\"),\n\t\tOptionShowIts(),\n\t\tOptionShowCount(),\n\t\tOptionSpinnerCustom([]string{\"🐰\", \"🐰\", \"🥕\", \"🥕\"}),\n\t\tOptionSpinnerType(9),\n\t)\n\tbar.Reset()\n\tfor i := 0; i < 10; i++ {\n\t\ttime.Sleep(120 * time.Millisecond)\n\t\terr := bar.Add(1)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Successfully tested both spinner options cannot be used together.\")\n\t\t}\n\t}\n}\n\nfunc Test_IsFinished(t *testing.T) {\n\tisCalled := false\n\tbar := NewOptions(72, OptionOnCompletion(func() {\n\t\tisCalled = true\n\t}))\n\n\t// Test1: If bar is not fully completed.\n\tbar.Add(5)\n\tif bar.IsFinished() || isCalled {\n\t\tt.Errorf(\"Successfully tested bar is not yet finished.\")\n\t}\n\n\t// Test2: Bar fully completed.\n\tbar.Add(67)\n\tif !bar.IsFinished() || !isCalled {\n\t\tt.Errorf(\"Successfully tested bar is finished.\")\n\t}\n\n\t// Test3: If increases maximum bytes error should be thrown and\n\t// bar finished will remain false.\n\tbar.Reset()\n\terr := bar.Add(73)\n\tif err == nil || bar.IsFinished() {\n\t\tt.Errorf(\"Successfully got error when bytes increases max bytes, bar finished: %v\", bar.IsFinished())\n\t}\n}\n\nfunc ExampleOptionShowBytes_spinner() {\n\t/*\n\t\tSpinner test with iterations and count\n\t*/\n\tbuf := strings.Builder{}\n\tbar := NewOptions(-1,\n\t\tOptionSetWidth(10),\n\t\tOptionShowBytes(true),\n\t\tOptionSetWriter(&buf),\n\t)\n\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\t// since 10 is the width and we don't know the max bytes\n\t// it will do a infinite scrolling.\n\tbar.Add(11)\n\tbar.lock.Lock()\n\tresult, _ := virtualterm.Process(buf.String())\n\tbar.lock.Unlock()\n\tfmt.Print(result)\n\t// Output:\n\t// -  (11 B/s) [1s]\n}\n\nfunc TestBarSlowAdd(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(100, OptionSetWidth(10), OptionShowIts(), OptionSetWriter(&buf))\n\tbar.Reset()\n\ttime.Sleep(3 * time.Second)\n\tbar.Add(1)\n\tif !strings.Contains(buf.String(), \"1%\") {\n\t\tt.Errorf(\"wrong string: %s\", buf.String())\n\t}\n\tif !strings.Contains(buf.String(), \"20 it/min\") {\n\t\tt.Errorf(\"wrong string: %s\", buf.String())\n\t}\n\tif !strings.Contains(buf.String(), \"[3s:\") {\n\t\tt.Errorf(\"wrong string: %s\", buf.String())\n\t}\n\t// Output:\n\t// 1% |          | (20 it/min) [3s:4m57s]\n}\n\nfunc TestBarSmallBytes(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions64(100000000, OptionShowBytes(true), OptionShowCount(), OptionSetWidth(10), OptionSetWriter(&buf))\n\tfor i := 1; i < 10; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tbar.Add(1000)\n\t}\n\tif !strings.Contains(buf.String(), \"9.0 kB/100 MB\") {\n\t\tt.Errorf(\"wrong string: %s\", buf.String())\n\t}\n\tfor i := 1; i < 10; i++ {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tbar.Add(1000000)\n\t}\n\tif !strings.Contains(buf.String(), \"9.0/100 MB\") {\n\t\tt.Errorf(\"wrong string: %s\", buf.String())\n\t}\n}\n\nfunc TestBarFastBytes(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions64(1e8, OptionShowBytes(true), OptionShowCount(), OptionSetWidth(10), OptionSetWriter(&buf))\n\tbar.StartWithoutRender()\n\ttime.Sleep(time.Millisecond)\n\tbar.Add(1e7)\n\tif !strings.Contains(buf.String(), \" GB/s)\") {\n\t\tt.Errorf(\"wrong string: %s\", buf.String())\n\t}\n}\n\nfunc TestBar(t *testing.T) {\n\tbar := New(0)\n\tif err := bar.Add(1); err == nil {\n\t\tt.Error(\"should have an error for 0 bar\")\n\t}\n\tbar = New(10)\n\tif err := bar.Add(11); err == nil {\n\t\tt.Error(\"should have an error for adding > bar\")\n\t}\n}\n\nfunc TestState(t *testing.T) {\n\tbar := NewOptions(100, OptionSetWidth(10))\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(10)\n\ts := bar.State()\n\tif s.CurrentPercent != 0.1 {\n\t\tt.Error(s)\n\t}\n}\n\nfunc ExampleOptionSetRenderBlankState() {\n\tNewOptions(10, OptionSetWidth(10), OptionSetRenderBlankState(true))\n\t// Output:\n\t// 0% |          |  [0s:0s]\n}\n\nfunc TestBasicSets(t *testing.T) {\n\tb := NewOptions(\n\t\t999,\n\t\tOptionSetWidth(888),\n\t\tOptionSetRenderBlankState(true),\n\t\tOptionSetWriter(io.Discard), // suppressing output for this test\n\t)\n\n\ttc := b.config\n\n\tif tc.max != 999 {\n\t\tt.Errorf(\"Expected %s to be %d, instead I got %d\\n%+v\", \"max\", 999, tc.max, b)\n\t}\n\n\tif tc.width != 888 {\n\t\tt.Errorf(\"Expected %s to be %d, instead I got %d\\n%+v\", \"width\", 999, tc.max, b)\n\t}\n\n\tif !tc.renderWithBlankState {\n\t\tt.Errorf(\"Expected %s to be %t, instead I got %t\\n%+v\", \"renderWithBlankState\", true, tc.renderWithBlankState, b)\n\t}\n}\n\nfunc TestOptionSetTheme(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(\n\t\t10,\n\t\tOptionSetTheme(\n\t\t\tTheme{Saucer: \"#\", SaucerPadding: \"-\",\n\t\t\t\tBarStart: \">\", BarEnd: \"<\"}),\n\t\tOptionSetWidth(10),\n\t\tOptionSetWriter(&buf),\n\t)\n\tbar.RenderBlank()\n\tresult := strings.TrimSpace(buf.String())\n\texpect := \"0% >----------<\"\n\tif strings.Index(result, expect) == -1 {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n\tbuf.Reset()\n\n\tbar.Add(5)\n\tresult = strings.TrimSpace(buf.String())\n\texpect = \"50% >#####-----<  [0s:0s]\"\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n\tbuf.Reset()\n\n\tbar.Finish()\n\tresult = strings.TrimSpace(buf.String())\n\texpect = \"100% >##########<\"\n\tif strings.Index(result, expect) == -1 {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc TestOptionSetThemeFilled(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(\n\t\t10,\n\t\tOptionSetTheme(\n\t\t\tTheme{Saucer: \"#\", SaucerPadding: \"-\",\n\t\t\t\tBarStart: \">\", BarStartFilled: \"]\",\n\t\t\t\tBarEnd: \"<\", BarEndFilled: \"[\"}),\n\t\tOptionSetWidth(10),\n\t\tOptionSetWriter(&buf),\n\t)\n\tbar.RenderBlank()\n\tresult := strings.TrimSpace(buf.String())\n\texpect := \"0% >----------<\"\n\tif strings.Index(result, expect) == -1 {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n\tbuf.Reset()\n\n\tbar.Add(5)\n\tresult = strings.TrimSpace(buf.String())\n\texpect = \"50% ]#####-----<  [0s:0s]\"\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n\tbuf.Reset()\n\n\tbar.Finish()\n\tresult = strings.TrimSpace(buf.String())\n\texpect = \"100% ]##########[\"\n\tif strings.Index(result, expect) == -1 {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\n// TestOptionSetPredictTime ensures that when predict time is turned off, the progress\n// bar is showing the total steps completed of the given max, otherwise the predicted\n// time in seconds is specified.\nfunc TestOptionSetPredictTime(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(\n\t\t10,\n\t\tOptionSetPredictTime(false),\n\t\tOptionSetWidth(10),\n\t\tOptionSetWriter(&buf),\n\t)\n\n\t_ = bar.Add(2)\n\tresult := strings.TrimSpace(buf.String())\n\texpect := \"20% |██        |\"\n\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n\n\tbar.Reset()\n\tbar.config.predictTime = true\n\tbuf.Reset()\n\n\t_ = bar.Add(7)\n\tresult = strings.TrimSpace(buf.String())\n\texpect = \"70% |███████   |  [0s:0s]\"\n\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc TestOptionSetElapsedTime_spinner(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(-1,\n\t\tOptionSetWidth(10),\n\t\tOptionSetWriter(&buf),\n\t\tOptionShowIts(),\n\t\tOptionShowCount(),\n\t\tOptionSetElapsedTime(false),\n\t)\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(5)\n\tbar.lock.Lock()\n\tresult, err := virtualterm.Process(buf.String())\n\tbar.lock.Unlock()\n\tresult = strings.TrimSpace(result)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpect := \"-  (5/-, 5 it/s)\"\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc TestOptionSetElapsedTime(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(\n\t\t10,\n\t\tOptionSetElapsedTime(false),\n\t\tOptionSetPredictTime(false),\n\t\tOptionSetWidth(10),\n\t\tOptionSetWriter(&buf),\n\t)\n\n\t_ = bar.Add(2)\n\tresult := strings.TrimSpace(buf.String())\n\texpect := \"20% |██        |\"\n\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n\n\tbar.Reset()\n\tbar.config.elapsedTime = true\n\tbuf.Reset()\n\n\t_ = bar.Add(7)\n\tresult = strings.TrimSpace(buf.String())\n\texpect = \"70% |███████   |  [0s]\"\n\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc TestShowElapsedTimeOnFinish(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(10,\n\t\tOptionShowElapsedTimeOnFinish(),\n\t\tOptionSetWidth(10),\n\t\tOptionSetWriter(&buf),\n\t)\n\tbar.Reset()\n\ttime.Sleep(3 * time.Second)\n\tbar.Add(10)\n\tresult := strings.TrimSpace(buf.String())\n\texpect := \"100% |██████████|  [3s]\"\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc TestSpinnerState(t *testing.T) {\n\tbar := NewOptions(\n\t\t-1,\n\t\tOptionSetWidth(100),\n\t)\n\tbar.Reset()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(10)\n\n\tstate := bar.State()\n\tif state.Max != -1 {\n\t\tt.Errorf(\"Max mismatched gotMax %d wantMax %d\", state.Max, -1)\n\t}\n\tif state.CurrentNum != 10 {\n\t\tt.Errorf(\"Number mismatched gotNum %d wantNum %d\", state.CurrentNum, 10)\n\t}\n\tif state.CurrentBytes != 10.0 {\n\t\tt.Errorf(\"Number of bytes mismatched gotBytes %f wantBytes %f\", state.CurrentBytes, 10.0)\n\t}\n\tif state.CurrentPercent != 0.1 {\n\t\tt.Errorf(\"Percent of bar mismatched got %f want %f\", state.CurrentPercent, 0.1)\n\t}\n\n\tkbPerSec := fmt.Sprintf(\"%2.2f\", state.KBsPerSecond)\n\tif kbPerSec != \"0.01\" {\n\t\tt.Errorf(\"Speed mismatched got %s want %s\", kbPerSec, \"0.01\")\n\t}\n}\n\nfunc TestReaderToBuffer(t *testing.T) {\n\tif testing.Short() {\n\t\tt.SkipNow()\n\t}\n\n\turlToGet := \"https://dl.google.com/go/go1.14.1.src.tar.gz\"\n\treq, err := http.NewRequest(\"GET\", urlToGet, nil)\n\tassert.Nil(t, err)\n\tresp, err := http.DefaultClient.Do(req)\n\tassert.Nil(t, err)\n\tdefer resp.Body.Close()\n\n\tbuf := new(bytes.Buffer)\n\tbar := NewOptions(int(resp.ContentLength), OptionShowBytes(true), OptionShowCount())\n\tout := io.MultiWriter(buf, bar)\n\t_, err = io.Copy(out, resp.Body)\n\tassert.Nil(t, err)\n\n\tmd5, err := md5sum(buf)\n\tassert.Nil(t, err)\n\tassert.Equal(t, \"d441819a800f8c90825355dfbede7266\", md5)\n}\n\nfunc TestReaderToFile(t *testing.T) {\n\tif testing.Short() {\n\t\tt.SkipNow()\n\t}\n\n\turlToGet := \"https://dl.google.com/go/go1.14.1.src.tar.gz\"\n\treq, err := http.NewRequest(\"GET\", urlToGet, nil)\n\tassert.Nil(t, err)\n\tresp, err := http.DefaultClient.Do(req)\n\tassert.Nil(t, err)\n\tdefer resp.Body.Close()\n\n\tf, err := os.CreateTemp(\"\", \"progressbar_testfile\")\n\tif err != nil {\n\t\tt.Fatal()\n\t}\n\tdefer os.Remove(f.Name())\n\tdefer f.Close()\n\n\trealStdout := os.Stdout\n\tdefer func() { os.Stdout = realStdout }()\n\tr, fakeStdout, err := os.Pipe()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tos.Stdout = fakeStdout\n\n\tbar := DefaultBytes(resp.ContentLength)\n\tout := io.MultiWriter(f, bar)\n\t_, err = io.Copy(out, resp.Body)\n\tassert.Nil(t, err)\n\tf.Sync()\n\tf.Seek(0, 0)\n\n\tif err := fakeStdout.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tb, err := io.ReadAll(r)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := r.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.Equal(t, \"\", string(b))\n\n\tmd5, err := md5sum(f)\n\tassert.Nil(t, err)\n\tassert.Equal(t, \"d441819a800f8c90825355dfbede7266\", md5)\n}\n\nfunc TestReaderToFileUnknownLength(t *testing.T) {\n\tif testing.Short() {\n\t\tt.SkipNow()\n\t}\n\n\turlToGet := \"https://dl.google.com/go/go1.14.1.src.tar.gz\"\n\treq, err := http.NewRequest(\"GET\", urlToGet, nil)\n\tassert.Nil(t, err)\n\tresp, err := http.DefaultClient.Do(req)\n\tassert.Nil(t, err)\n\tdefer resp.Body.Close()\n\n\tf, err := os.CreateTemp(\"\", \"progressbar_testfile\")\n\tif err != nil {\n\t\tt.Fatal()\n\t}\n\tdefer os.Remove(f.Name())\n\tdefer f.Close()\n\n\trealStdout := os.Stdout\n\tdefer func() { os.Stdout = realStdout }()\n\tr, fakeStdout, err := os.Pipe()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tos.Stdout = fakeStdout\n\n\tbar := DefaultBytes(-1, \" downloading\")\n\tout := io.MultiWriter(f, bar)\n\t_, err = io.Copy(out, resp.Body)\n\tassert.Nil(t, err)\n\tf.Sync()\n\tf.Seek(0, 0)\n\n\tif err := fakeStdout.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tb, err := io.ReadAll(r)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := r.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.Equal(t, \"\", string(b))\n\n\tmd5, err := md5sum(f)\n\tassert.Nil(t, err)\n\tassert.Equal(t, \"d441819a800f8c90825355dfbede7266\", md5)\n}\n\nfunc TestConcurrency(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(\n\t\t1000,\n\t\tOptionSetWriter(&buf),\n\t)\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 900; i++ {\n\t\twg.Add(1)\n\t\tgo func(b *ProgressBar, wg *sync.WaitGroup) {\n\t\t\tbar.Add(1)\n\t\t\twg.Done()\n\t\t}(bar, &wg)\n\t}\n\twg.Wait()\n\tresult := bar.state.currentNum\n\texpect := int64(900)\n\tassert.Equal(t, expect, result)\n}\n\nfunc TestIterationNames(t *testing.T) {\n\tb := Default(20)\n\ttc := b.config\n\n\t// Checking for the default iterations per second or \"it/s\"\n\tif tc.iterationString != \"it\" {\n\t\tt.Errorf(\"Expected %s to be %s, instead I got %s\", \"iterationString\", \"it\", tc.iterationString)\n\t}\n\n\t// Change the default \"it/s\" to provide context, downloads per second or \"dl/s\"\n\tb = NewOptions(20, OptionSetItsString(\"dl\"))\n\ttc = b.config\n\n\tif tc.iterationString != \"dl\" {\n\t\tt.Errorf(\"Expected %s to be %s, instead I got %s\", \"iterationString\", \"dl\", tc.iterationString)\n\t}\n}\n\nfunc md5sum(r io.Reader) (string, error) {\n\thash := md5.New()\n\t_, err := io.Copy(hash, r)\n\treturn hex.EncodeToString(hash.Sum(nil)), err\n}\n\nfunc TestProgressBar_Describe(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(100, OptionSetWidth(10), OptionSetWriter(&buf))\n\tbar.Describe(\"performing axial adjustments\")\n\tbar.Add(10)\n\tresult := buf.String()\n\texpect := \"\" +\n\t\t\"\\rperforming axial adjustments   0% |          |  [0s:0s]\" +\n\t\t\"\\r                                                       \\r\" +\n\t\t\"\\rperforming axial adjustments  10% |█         |  [0s:0s]\"\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc TestRenderBlankStateWithThrottle(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(100, OptionSetWidth(10), OptionSetRenderBlankState(true), OptionThrottle(time.Millisecond), OptionSetWriter(&buf))\n\tresult := strings.TrimSpace(buf.String())\n\texpect := \"0% |          |  [0s:0s]\"\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc TestOptionFullWidth(t *testing.T) {\n\tvar tests = []struct {\n\t\topts     []Option\n\t\texpected string\n\t}{\n\t\t{ // 1\n\t\t\t[]Option{},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |██████                                                        |  [1s:9s]\" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |██████████████████████████████████████████████████████████████| \",\n\t\t},\n\t\t{ // 2\n\t\t\t[]Option{OptionSetDescription(\"Progress:\")},\n\t\t\t\"\" +\n\t\t\t\t\"\\rProgress:  10% |█████                                                |  [1s:9s]\" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\rProgress: 100% |█████████████████████████████████████████████████████| \",\n\t\t},\n\t\t{ // 3\n\t\t\t[]Option{OptionSetDescription(\"<1/5>\"), OptionShowDescriptionAtLineEnd()},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |█████                                                   |  [1s:9s] <1/5>\" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |████████████████████████████████████████████████████████|  <1/5>\",\n\t\t},\n\t\t{ // 4\n\t\t\t[]Option{OptionSetPredictTime(false)},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |██████                                                               |  \" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |█████████████████████████████████████████████████████████████████████|  \",\n\t\t},\n\t\t{ // 5\n\t\t\t[]Option{OptionSetPredictTime(false), OptionShowElapsedTimeOnFinish()},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |██████                                                          |  \" +\n\t\t\t\t\"\\r                                                                          \\r\" +\n\t\t\t\t\"\\r 100% |████████████████████████████████████████████████████████████████|  [2s] \",\n\t\t},\n\t\t{ // 6\n\t\t\t[]Option{OptionSetPredictTime(false), OptionSetElapsedTime(false)},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |██████                                                               |  \" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |█████████████████████████████████████████████████████████████████████|  \",\n\t\t},\n\t\t{ // 7\n\t\t\t[]Option{OptionShowIts()},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |█████                                                | (10 it/s) [1s:9s]\" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |█████████████████████████████████████████████████████| (50 it/s)\",\n\t\t},\n\t\t{ // 8\n\t\t\t[]Option{OptionShowCount()},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |█████                                                 | (10/100) [1s:9s]\" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |█████████████████████████████████████████████████████| (100/100)\",\n\t\t},\n\t\t{ // 9\n\t\t\t[]Option{OptionShowIts(), OptionShowCount(), OptionShowElapsedTimeOnFinish()},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |████                                         | (10/100, 10 it/s) [1s:9s]\" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |████████████████████████████████████████████| (100/100, 50 it/s) [2s]\",\n\t\t},\n\t\t{ // 10\n\t\t\t[]Option{OptionSetDescription(\"Progress:\"), OptionShowIts(), OptionShowCount()},\n\t\t\t\"\" +\n\t\t\t\t\"\\rProgress:  10% |███                                 | (10/100, 10 it/s) [1s:9s]\" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\rProgress: 100% |███████████████████████████████████| (100/100, 50 it/s)\",\n\t\t},\n\t\t{ // 11\n\t\t\t[]Option{OptionSetDescription(\"<3/5>\"), OptionShowIts(), OptionShowCount(), OptionShowElapsedTimeOnFinish(), OptionShowDescriptionAtLineEnd()},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |███                                    | (10/100, 10 it/s) [1s:9s] <3/5>\" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |██████████████████████████████████████| (100/100, 50 it/s) [2s] <3/5>\",\n\t\t},\n\t\t{ // 12\n\t\t\t[]Option{OptionShowIts(), OptionShowCount(), OptionSetPredictTime(false)},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |█████                                               | (10/100, 10 it/s) \" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |███████████████████████████████████████████████████| (100/100, 50 it/s) \",\n\t\t},\n\t\t{ // 13\n\t\t\t[]Option{OptionShowIts(), OptionShowCount(), OptionSetPredictTime(false), OptionShowElapsedTimeOnFinish()},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |████                                           | (10/100, 10 it/s) \" +\n\t\t\t\t\"\\r                                                                          \\r\" +\n\t\t\t\t\"\\r 100% |██████████████████████████████████████████████| (100/100, 50 it/s) [2s] \",\n\t\t},\n\t\t{ // 14\n\t\t\t[]Option{OptionShowIts(), OptionShowCount(), OptionSetPredictTime(false), OptionSetElapsedTime(false)},\n\t\t\t\"\" +\n\t\t\t\t\"\\r  10% |█████                                               | (10/100, 10 it/s) \" +\n\t\t\t\t\"\\r                                                                               \\r\" +\n\t\t\t\t\"\\r 100% |███████████████████████████████████████████████████| (100/100, 50 it/s) \",\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%d\", i+1), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tbuf := strings.Builder{}\n\t\t\tbar := NewOptions(100, append(test.opts, []Option{OptionFullWidth(), OptionSetWriter(&buf)}...)...)\n\t\t\tbar.StartWithoutRender()\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tbar.Add(10)\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tbar.Add(90)\n\t\t\tassert.Equal(t, test.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestHumanizeBytesSI(t *testing.T) {\n\tamount, suffix := humanizeBytes(float64(12.34)*1000*1000, false)\n\tassert.Equal(t, \"12 MB\", fmt.Sprintf(\"%s%s\", amount, suffix))\n\n\tamount, suffix = humanizeBytes(float64(56.78)*1000*1000*1000, false)\n\tassert.Equal(t, \"57 GB\", fmt.Sprintf(\"%s%s\", amount, suffix))\n}\n\nfunc TestHumanizeBytesIEC(t *testing.T) {\n\tamount, suffix := humanizeBytes(float64(12.34)*1024*1024, true)\n\tassert.Equal(t, \"12 MiB\", fmt.Sprintf(\"%s%s\", amount, suffix))\n\n\tamount, suffix = humanizeBytes(float64(56.78)*1024*1024*1024, true)\n\tassert.Equal(t, \"57 GiB\", fmt.Sprintf(\"%s%s\", amount, suffix))\n}\n\nfunc TestProgressBar_StartWithoutRender(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(100, OptionSetWriter(&buf))\n\ttime.Sleep(1 * time.Second)\n\tbar.StartWithoutRender()\n\ttime.Sleep(1 * time.Second)\n\tbar.Add(10)\n\tresult := strings.TrimSpace(buf.String())\n\texpect := \"10% |████                                    |  [1s:9s]\"\n\tif result != expect {\n\t\tt.Errorf(\"Render miss-match\\nResult: '%s'\\nExpect: '%s'\\n%+v\", result, expect, bar)\n\t}\n}\n\nfunc TestOptionSetSpinnerChangeInterval(t *testing.T) {\n\tinterval := 1000 * time.Millisecond\n\tvt := virtualterm.NewDefault()\n\tactuals := make([]string, 0, 8)\n\texpecteds := []string{\n\t\t\"◐ test  [0s]\",\n\t\t\"◓ test  [1s]\",\n\t\t\"◑ test  [2s]\",\n\t\t\"◒ test  [3s]\",\n\t\t\"◐ test  [4s]\",\n\t\t\"◓ test  [5s]\",\n\t\t\"◑ test  [6s]\",\n\t\t\"◒ test  [7s]\",\n\t}\n\tbar := NewOptions(-1,\n\t\tOptionSetDescription(\"test\"),\n\t\tOptionSpinnerType(7),\n\t\tOptionSetWriter(&vt),\n\t\tOptionSetSpinnerChangeInterval(interval))\n\tbar.Add(1)\n\tfor i := 0; i < 8; i++ {\n\t\tbar.lock.Lock()\n\t\ts, _ := vt.String()\n\t\tbar.lock.Unlock()\n\t\ts = strings.TrimSpace(s)\n\t\tactuals = append(actuals, s)\n\t\t// sleep 50 ms more to make sure to go to next interval each time\n\t\ttime.Sleep(1050 * time.Millisecond)\n\t}\n\tfor i := range actuals {\n\t\tassert.Equal(t, expecteds[i], actuals[i])\n\t}\n}\n\nfunc TestOptionSetSpinnerChangeIntervalZero(t *testing.T) {\n\tvt := virtualterm.NewDefault()\n\tbar := NewOptions(-1,\n\t\tOptionSetDescription(\"test\"),\n\t\tOptionSpinnerType(7),\n\t\tOptionSetWriter(&vt),\n\t\tOptionSetSpinnerChangeInterval(0))\n\tactuals := make([]string, 0, 5)\n\texpected := []string{\n\t\t\"◐ test  [0s]\",\n\t\t\"◓ test  [1s]\",\n\t\t\"◑ test  [2s]\",\n\t\t\"◒ test  [3s]\",\n\t\t\"◐ test  [4s]\",\n\t}\n\tfor i := 0; i < 5; i++ {\n\t\tbar.Add(1)\n\t\tbar.lock.Lock()\n\t\ts, _ := vt.String()\n\t\tbar.lock.Unlock()\n\t\ts = strings.TrimSpace(s)\n\t}\n\tfor i := range actuals {\n\t\tassert.Equal(t, expected[i], actuals[i])\n\t}\n}\n\nfunc TestOptionShowTotalFalseDeterminate(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions64(\n\t\t100000000,\n\t\tOptionShowBytes(true),\n\t\tOptionShowCount(),\n\t\tOptionSetWidth(10),\n\t\tOptionShowTotalBytes(false),\n\t\tOptionSetWriter(&buf),\n\t)\n\n\tbar.Add(10000)\n\tif !strings.Contains(buf.String(), \"10 kB, \") {\n\t\tt.Errorf(\"wrong string: %s\", buf.String())\n\t}\n}\n\nfunc TestOptionShowTotalFalseIndeterminate(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(-1,\n\t\tOptionSetWidth(10),\n\t\tOptionSetDescription(\"indeterminate spinner\"),\n\t\tOptionShowIts(),\n\t\tOptionShowCount(),\n\t\tOptionSpinnerType(9),\n\t\tOptionShowTotalBytes(false),\n\t\tOptionSetWriter(&buf),\n\t)\n\tbar.Add(10)\n\tif !strings.Contains(buf.String(), \"10, \") {\n\t\tt.Errorf(\"wrong string: %s\", buf.String())\n\t}\n}\n\nfunc TestOptionShowTotalTrueIndeterminate(t *testing.T) {\n\tbuf := strings.Builder{}\n\tbar := NewOptions(-1,\n\t\tOptionSetWidth(10),\n\t\tOptionSetDescription(\"indeterminate spinner\"),\n\t\tOptionShowIts(),\n\t\tOptionShowCount(),\n\t\tOptionSpinnerType(9),\n\t\tOptionShowTotalBytes(true),\n\t\tOptionSetWriter(&buf),\n\t)\n\tbar.Add(10)\n\tif !strings.Contains(buf.String(), \"10/-, \") {\n\t\tt.Errorf(\"wrong string: %s\", buf.String())\n\t}\n}\n\nfunc TestStartHTTPServer(t *testing.T) {\n\tbar := Default(10, \"test\")\n\tbar.Add(1)\n\n\thostPort := \"localhost:9696\"\n\tgo bar.StartHTTPServer(hostPort)\n\n\t// check plain text\n\tresp, err := http.Get(fmt.Sprintf(\"http://%s/desc\", hostPort))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tgot, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif string(got) != \"1/10, 10.00%, 0s left\" {\n\t\tt.Errorf(\"wrong string: %s\", string(got))\n\t}\n\n\t// check json\n\tresp, err = http.Get(fmt.Sprintf(\"http://%s/state\", hostPort))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tgot, err = io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tvar result State\n\terr = json.Unmarshal(got, &result)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif result.Max != bar.State().Max || result.CurrentNum != bar.State().CurrentNum {\n\t\tt.Errorf(\"wrong state: %v\", result)\n\t}\n}\n"
        },
        {
          "name": "spinners.go",
          "type": "blob",
          "size": 6.638671875,
          "content": "package progressbar\n\nvar spinners = map[int][]string{\n\t0:  {\"←\", \"↖\", \"↑\", \"↗\", \"→\", \"↘\", \"↓\", \"↙\"},\n\t1:  {\"▁\", \"▃\", \"▄\", \"▅\", \"▆\", \"▇\", \"█\", \"▇\", \"▆\", \"▅\", \"▄\", \"▃\", \"▁\"},\n\t2:  {\"▖\", \"▘\", \"▝\", \"▗\"},\n\t3:  {\"┤\", \"┘\", \"┴\", \"└\", \"├\", \"┌\", \"┬\", \"┐\"},\n\t4:  {\"◢\", \"◣\", \"◤\", \"◥\"},\n\t5:  {\"◰\", \"◳\", \"◲\", \"◱\"},\n\t6:  {\"◴\", \"◷\", \"◶\", \"◵\"},\n\t7:  {\"◐\", \"◓\", \"◑\", \"◒\"},\n\t8:  {\".\", \"o\", \"O\", \"@\", \"*\"},\n\t9:  {\"|\", \"/\", \"-\", \"\\\\\"},\n\t10: {\"◡◡\", \"⊙⊙\", \"◠◠\"},\n\t11: {\"⣾\", \"⣽\", \"⣻\", \"⢿\", \"⡿\", \"⣟\", \"⣯\", \"⣷\"},\n\t12: {\">))'>\", \" >))'>\", \"  >))'>\", \"   >))'>\", \"    >))'>\", \"   <'((<\", \"  <'((<\", \" <'((<\"},\n\t13: {\"⠁\", \"⠂\", \"⠄\", \"⡀\", \"⢀\", \"⠠\", \"⠐\", \"⠈\"},\n\t14: {\"⠋\", \"⠙\", \"⠹\", \"⠸\", \"⠼\", \"⠴\", \"⠦\", \"⠧\", \"⠇\", \"⠏\"},\n\t15: {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"},\n\t16: {\"▉\", \"▊\", \"▋\", \"▌\", \"▍\", \"▎\", \"▏\", \"▎\", \"▍\", \"▌\", \"▋\", \"▊\", \"▉\"},\n\t17: {\"■\", \"□\", \"▪\", \"▫\"},\n\t18: {\"←\", \"↑\", \"→\", \"↓\"},\n\t19: {\"╫\", \"╪\"},\n\t20: {\"⇐\", \"⇖\", \"⇑\", \"⇗\", \"⇒\", \"⇘\", \"⇓\", \"⇙\"},\n\t21: {\"⠁\", \"⠁\", \"⠉\", \"⠙\", \"⠚\", \"⠒\", \"⠂\", \"⠂\", \"⠒\", \"⠲\", \"⠴\", \"⠤\", \"⠄\", \"⠄\", \"⠤\", \"⠠\", \"⠠\", \"⠤\", \"⠦\", \"⠖\", \"⠒\", \"⠐\", \"⠐\", \"⠒\", \"⠓\", \"⠋\", \"⠉\", \"⠈\", \"⠈\"},\n\t22: {\"⠈\", \"⠉\", \"⠋\", \"⠓\", \"⠒\", \"⠐\", \"⠐\", \"⠒\", \"⠖\", \"⠦\", \"⠤\", \"⠠\", \"⠠\", \"⠤\", \"⠦\", \"⠖\", \"⠒\", \"⠐\", \"⠐\", \"⠒\", \"⠓\", \"⠋\", \"⠉\", \"⠈\"},\n\t23: {\"⠁\", \"⠉\", \"⠙\", \"⠚\", \"⠒\", \"⠂\", \"⠂\", \"⠒\", \"⠲\", \"⠴\", \"⠤\", \"⠄\", \"⠄\", \"⠤\", \"⠴\", \"⠲\", \"⠒\", \"⠂\", \"⠂\", \"⠒\", \"⠚\", \"⠙\", \"⠉\", \"⠁\"},\n\t24: {\"⠋\", \"⠙\", \"⠚\", \"⠒\", \"⠂\", \"⠂\", \"⠒\", \"⠲\", \"⠴\", \"⠦\", \"⠖\", \"⠒\", \"⠐\", \"⠐\", \"⠒\", \"⠓\", \"⠋\"},\n\t25: {\"ｦ\", \"ｧ\", \"ｨ\", \"ｩ\", \"ｪ\", \"ｫ\", \"ｬ\", \"ｭ\", \"ｮ\", \"ｯ\", \"ｱ\", \"ｲ\", \"ｳ\", \"ｴ\", \"ｵ\", \"ｶ\", \"ｷ\", \"ｸ\", \"ｹ\", \"ｺ\", \"ｻ\", \"ｼ\", \"ｽ\", \"ｾ\", \"ｿ\", \"ﾀ\", \"ﾁ\", \"ﾂ\", \"ﾃ\", \"ﾄ\", \"ﾅ\", \"ﾆ\", \"ﾇ\", \"ﾈ\", \"ﾉ\", \"ﾊ\", \"ﾋ\", \"ﾌ\", \"ﾍ\", \"ﾎ\", \"ﾏ\", \"ﾐ\", \"ﾑ\", \"ﾒ\", \"ﾓ\", \"ﾔ\", \"ﾕ\", \"ﾖ\", \"ﾗ\", \"ﾘ\", \"ﾙ\", \"ﾚ\", \"ﾛ\", \"ﾜ\", \"ﾝ\"},\n\t26: {\".\", \"..\", \"...\"},\n\t27: {\"▁\", \"▂\", \"▃\", \"▄\", \"▅\", \"▆\", \"▇\", \"█\", \"▉\", \"▊\", \"▋\", \"▌\", \"▍\", \"▎\", \"▏\", \"▏\", \"▎\", \"▍\", \"▌\", \"▋\", \"▊\", \"▉\", \"█\", \"▇\", \"▆\", \"▅\", \"▄\", \"▃\", \"▂\", \"▁\"},\n\t28: {\".\", \"o\", \"O\", \"°\", \"O\", \"o\", \".\"},\n\t29: {\"+\", \"x\"},\n\t30: {\"v\", \"<\", \"^\", \">\"},\n\t31: {\">>--->\", \" >>--->\", \"  >>--->\", \"   >>--->\", \"    >>--->\", \"    <---<<\", \"   <---<<\", \"  <---<<\", \" <---<<\", \"<---<<\"},\n\t32: {\"|\", \"||\", \"|||\", \"||||\", \"|||||\", \"|||||||\", \"||||||||\", \"|||||||\", \"||||||\", \"|||||\", \"||||\", \"|||\", \"||\", \"|\"},\n\t33: {\"[          ]\", \"[=         ]\", \"[==        ]\", \"[===       ]\", \"[====      ]\", \"[=====     ]\", \"[======    ]\", \"[=======   ]\", \"[========  ]\", \"[========= ]\", \"[==========]\"},\n\t34: {\"(*---------)\", \"(-*--------)\", \"(--*-------)\", \"(---*------)\", \"(----*-----)\", \"(-----*----)\", \"(------*---)\", \"(-------*--)\", \"(--------*-)\", \"(---------*)\"},\n\t35: {\"█▒▒▒▒▒▒▒▒▒\", \"███▒▒▒▒▒▒▒\", \"█████▒▒▒▒▒\", \"███████▒▒▒\", \"██████████\"},\n\t36: {\"[                    ]\", \"[=>                  ]\", \"[===>                ]\", \"[=====>              ]\", \"[======>             ]\", \"[========>           ]\", \"[==========>         ]\", \"[============>       ]\", \"[==============>     ]\", \"[================>   ]\", \"[==================> ]\", \"[===================>]\"},\n\t37: {\"ဝ\", \"၀\"},\n\t38: {\"▌\", \"▀\", \"▐▄\"},\n\t39: {\"🌍\", \"🌎\", \"🌏\"},\n\t40: {\"◜\", \"◝\", \"◞\", \"◟\"},\n\t41: {\"⬒\", \"⬔\", \"⬓\", \"⬕\"},\n\t42: {\"⬖\", \"⬘\", \"⬗\", \"⬙\"},\n\t43: {\"[>>>          >]\", \"[]>>>>        []\", \"[]  >>>>      []\", \"[]    >>>>    []\", \"[]      >>>>  []\", \"[]        >>>>[]\", \"[>>          >>]\"},\n\t44: {\"♠\", \"♣\", \"♥\", \"♦\"},\n\t45: {\"➞\", \"➟\", \"➠\", \"➡\", \"➠\", \"➟\"},\n\t46: {\"  |  \", ` \\   `, \"_    \", ` \\   `, \"  |  \", \"   / \", \"    _\", \"   / \"},\n\t47: {\"  . . . .\", \".   . . .\", \". .   . .\", \". . .   .\", \". . . .  \", \". . . . .\"},\n\t48: {\" |     \", \"  /    \", \"   _   \", `    \\  `, \"     | \", `    \\  `, \"   _   \", \"  /    \"},\n\t49: {\"⎺\", \"⎻\", \"⎼\", \"⎽\", \"⎼\", \"⎻\"},\n\t50: {\"▹▹▹▹▹\", \"▸▹▹▹▹\", \"▹▸▹▹▹\", \"▹▹▸▹▹\", \"▹▹▹▸▹\", \"▹▹▹▹▸\"},\n\t51: {\"[    ]\", \"[   =]\", \"[  ==]\", \"[ ===]\", \"[====]\", \"[=== ]\", \"[==  ]\", \"[=   ]\"},\n\t52: {\"( ●    )\", \"(  ●   )\", \"(   ●  )\", \"(    ● )\", \"(     ●)\", \"(    ● )\", \"(   ●  )\", \"(  ●   )\", \"( ●    )\"},\n\t53: {\"✶\", \"✸\", \"✹\", \"✺\", \"✹\", \"✷\"},\n\t54: {\"▐|\\\\____________▌\", \"▐_|\\\\___________▌\", \"▐__|\\\\__________▌\", \"▐___|\\\\_________▌\", \"▐____|\\\\________▌\", \"▐_____|\\\\_______▌\", \"▐______|\\\\______▌\", \"▐_______|\\\\_____▌\", \"▐________|\\\\____▌\", \"▐_________|\\\\___▌\", \"▐__________|\\\\__▌\", \"▐___________|\\\\_▌\", \"▐____________|\\\\▌\", \"▐____________/|▌\", \"▐___________/|_▌\", \"▐__________/|__▌\", \"▐_________/|___▌\", \"▐________/|____▌\", \"▐_______/|_____▌\", \"▐______/|______▌\", \"▐_____/|_______▌\", \"▐____/|________▌\", \"▐___/|_________▌\", \"▐__/|__________▌\", \"▐_/|___________▌\", \"▐/|____________▌\"},\n\t55: {\"▐⠂       ▌\", \"▐⠈       ▌\", \"▐ ⠂      ▌\", \"▐ ⠠      ▌\", \"▐  ⡀     ▌\", \"▐  ⠠     ▌\", \"▐   ⠂    ▌\", \"▐   ⠈    ▌\", \"▐    ⠂   ▌\", \"▐    ⠠   ▌\", \"▐     ⡀  ▌\", \"▐     ⠠  ▌\", \"▐      ⠂ ▌\", \"▐      ⠈ ▌\", \"▐       ⠂▌\", \"▐       ⠠▌\", \"▐       ⡀▌\", \"▐      ⠠ ▌\", \"▐      ⠂ ▌\", \"▐     ⠈  ▌\", \"▐     ⠂  ▌\", \"▐    ⠠   ▌\", \"▐    ⡀   ▌\", \"▐   ⠠    ▌\", \"▐   ⠂    ▌\", \"▐  ⠈     ▌\", \"▐  ⠂     ▌\", \"▐ ⠠      ▌\", \"▐ ⡀      ▌\", \"▐⠠       ▌\"},\n\t56: {\"¿\", \"?\"},\n\t57: {\"⢹\", \"⢺\", \"⢼\", \"⣸\", \"⣇\", \"⡧\", \"⡗\", \"⡏\"},\n\t58: {\"⢄\", \"⢂\", \"⢁\", \"⡁\", \"⡈\", \"⡐\", \"⡠\"},\n\t59: {\".  \", \".. \", \"...\", \" ..\", \"  .\", \"   \"},\n\t60: {\".\", \"o\", \"O\", \"°\", \"O\", \"o\", \".\"},\n\t61: {\"▓\", \"▒\", \"░\"},\n\t62: {\"▌\", \"▀\", \"▐\", \"▄\"},\n\t63: {\"⊶\", \"⊷\"},\n\t64: {\"▪\", \"▫\"},\n\t65: {\"□\", \"■\"},\n\t66: {\"▮\", \"▯\"},\n\t67: {\"-\", \"=\", \"≡\"},\n\t68: {\"d\", \"q\", \"p\", \"b\"},\n\t69: {\"∙∙∙\", \"●∙∙\", \"∙●∙\", \"∙∙●\", \"∙∙∙\"},\n\t70: {\"🌑 \", \"🌒 \", \"🌓 \", \"🌔 \", \"🌕 \", \"🌖 \", \"🌗 \", \"🌘 \"},\n\t71: {\"☗\", \"☖\"},\n\t72: {\"⧇\", \"⧆\"},\n\t73: {\"◉\", \"◎\"},\n\t74: {\"㊂\", \"㊀\", \"㊁\"},\n\t75: {\"⦾\", \"⦿\"},\n}\n"
        }
      ]
    }
  ]
}