{
  "metadata": {
    "timestamp": 1736566760273,
    "page": 313,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cheggaaa/pb",
      "stars": 3658,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0068359375,
          "content": ".idea/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2666015625,
          "content": "language: go\narch:\n    - amd64\n    - ppc64le\ngo:\n  - 1.12.x\n  - 1.15.x\nsudo: false\nos:\n  - linux\n  - osx\nbefore_install:\n  - go get github.com/mattn/goveralls\nscript:\n  - $GOPATH/bin/goveralls -package github.com/cheggaaa/pb/v3 -repotoken QT1y5Iujb8ete6JOiE0ytKFlBDv9vheWc\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4453125,
          "content": "Copyright (c) 2012-2024, Sergey Cherepanov\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n* Neither the name of the author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.6181640625,
          "content": "# Terminal progress bar for Go\n\n[![Coverage Status](https://coveralls.io/repos/github/cheggaaa/pb/badge.svg)](https://coveralls.io/github/cheggaaa/pb)\n\n## Installation\n\n```\ngo get github.com/cheggaaa/pb/v3\n```\n\nDocumentation for v1 bar available [here](README_V1.md).\n\n## Quick start\n\n```Go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/cheggaaa/pb/v3\"\n)\n\nfunc main() {\n\tcount := 100000\n\n\t// create and start new bar\n\tbar := pb.StartNew(count)\n\n\t// start bar from 'default' template\n\t// bar := pb.Default.Start(count)\n\n\t// start bar from 'simple' template\n\t// bar := pb.Simple.Start(count)\n\n\t// start bar from 'full' template\n\t// bar := pb.Full.Start(count)\n\n\tfor i := 0; i < count; i++ {\n\t\tbar.Increment()\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\n\t// finish bar\n\tbar.Finish()\n}\n```\n\nResult will be like this:\n\n```\n> go run test.go\n37158 / 100000 [---------------->_______________________________] 37.16% 916 p/s\n```\n\n## Settings\n\n```Go\n// create bar\nbar := pb.New(count)\n\n// refresh info every second (default 200ms)\nbar.SetRefreshRate(time.Second)\n\n// force set io.Writer, by default it's os.Stderr\nbar.SetWriter(os.Stdout)\n\n// bar will format numbers as bytes (B, KiB, MiB, etc)\nbar.Set(pb.Bytes, true)\n\n// bar use SI bytes prefix names (B, kB) instead of IEC (B, KiB)\nbar.Set(pb.SIBytesPrefix, true)\n\n// set custom bar template\nbar.SetTemplateString(myTemplate)\n\n// check for error after template set\nif err := bar.Err(); err != nil {\n    return\n}\n\n// start bar\nbar.Start()\n```\n\n## Progress bar for IO Operations\n\n```Go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"io\"\n\t\"io/ioutil\"\n\n\t\"github.com/cheggaaa/pb/v3\"\n)\n\nfunc main() {\n\tvar limit int64 = 1024 * 1024 * 500\n\n\t// we will copy 500 MiB from /dev/rand to /dev/null\n\treader := io.LimitReader(rand.Reader, limit)\n\twriter := ioutil.Discard\n\n\t// start new bar\n\tbar := pb.Full.Start64(limit)\n\n\t// create proxy reader\n\tbarReader := bar.NewProxyReader(reader)\n\n\t// copy from proxy reader\n\tio.Copy(writer, barReader)\n\n\t// finish bar\n\tbar.Finish()\n}\n```\n\n## Custom Progress Bar templates\n\nRendering based on builtin [text/template](https://pkg.go.dev/text/template) package. You can use existing pb's elements or create you own.\n\nAll available elements are described in the [element.go](v3/element.go) file.\n\n#### All in one example:\n\n```Go\ntmpl := `{{ red \"With funcs:\" }} {{ bar . \"<\" \"-\" (cycle . \"↖\" \"↗\" \"↘\" \"↙\" ) \".\" \">\"}} {{speed . | rndcolor }} {{percent .}} {{string . \"my_green_string\" | green}} {{string . \"my_blue_string\" | blue}}`\n\n// start bar based on our template\nbar := pb.ProgressBarTemplate(tmpl).Start64(limit)\n\n// set values for string elements\nbar.Set(\"my_green_string\", \"green\").Set(\"my_blue_string\", \"blue\")\n```\n"
        },
        {
          "name": "README_V1.md",
          "type": "blob",
          "size": 3.0107421875,
          "content": "# Terminal progress bar for Go  \n\nSimple progress bar for console programs.    \n\n## Installation\n\n```\ngo get github.com/cheggaaa/pb\n```   \n\n## Usage   \n\n```Go\npackage main\n\nimport (\n\t\"github.com/cheggaaa/pb\"\n\t\"time\"\n)\n\nfunc main() {\n\tcount := 100000\n\tbar := pb.StartNew(count)\n\tfor i := 0; i < count; i++ {\n\t\tbar.Increment()\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\tbar.FinishPrint(\"The End!\")\n}\n\n```\n\nResult will be like this:\n\n```\n> go run test.go\n37158 / 100000 [================>_______________________________] 37.16% 1m11s\n```\n\n## Customization\n\n```Go  \n// create bar\nbar := pb.New(count)\n\n// refresh info every second (default 200ms)\nbar.SetRefreshRate(time.Second)\n\n// show percents (by default already true)\nbar.ShowPercent = true\n\n// show bar (by default already true)\nbar.ShowBar = true\n\n// no counters\nbar.ShowCounters = false\n\n// show \"time left\"\nbar.ShowTimeLeft = true\n\n// show average speed\nbar.ShowSpeed = true\n\n// sets the width of the progress bar\nbar.SetWidth(80)\n\n// sets the width of the progress bar, but if terminal size smaller will be ignored\nbar.SetMaxWidth(80)\n\n// convert output to readable format (like KB, MB)\nbar.SetUnits(pb.U_BYTES)\n\n// and start\nbar.Start()\n``` \n\n## Progress bar for IO Operations\n\n```go\n// create and start bar\nbar := pb.New(myDataLen).SetUnits(pb.U_BYTES)\nbar.Start()\n\n// my io.Reader\nr := myReader\n\n// my io.Writer\nw := myWriter\n\n// create proxy reader\nreader := bar.NewProxyReader(r)\n\n// and copy from pb reader\nio.Copy(w, reader)\n\n```\n\n```go\n// create and start bar\nbar := pb.New(myDataLen).SetUnits(pb.U_BYTES)\nbar.Start()\n\n// my io.Reader\nr := myReader\n\n// my io.Writer\nw := myWriter\n\n// create multi writer\nwriter := io.MultiWriter(w, bar)\n\n// and copy\nio.Copy(writer, r)\n\nbar.Finish()\n```\n\n## Custom Progress Bar Look-and-feel\n\n```go\nbar.Format(\"<.- >\")\n```\n\n## Multiple Progress Bars (experimental and unstable)\n\nDo not print to terminal while pool is active.\n\n```go\npackage main\n\nimport (\n    \"math/rand\"\n    \"sync\"\n    \"time\"\n\n    \"github.com/cheggaaa/pb\"\n)\n\nfunc main() {\n    // create bars\n    first := pb.New(200).Prefix(\"First \")\n    second := pb.New(200).Prefix(\"Second \")\n    third := pb.New(200).Prefix(\"Third \")\n    // start pool\n    pool, err := pb.StartPool(first, second, third)\n    if err != nil {\n        panic(err)\n    }\n    // update bars\n    wg := new(sync.WaitGroup)\n    for _, bar := range []*pb.ProgressBar{first, second, third} {\n        wg.Add(1)\n        go func(cb *pb.ProgressBar) {\n            for n := 0; n < 200; n++ {\n                cb.Increment()\n                time.Sleep(time.Millisecond * time.Duration(rand.Intn(100)))\n            }\n            cb.Finish()\n            wg.Done()\n        }(bar)\n    }\n    wg.Wait()\n    // close pool\n    pool.Stop()\n}\n```\n\nThe result will be as follows:\n\n```\n$ go run example/multiple.go \nFirst  34 / 200 [=========>---------------------------------------------]  17.00% 00m08s\nSecond  42 / 200 [===========>------------------------------------------]  21.00% 00m06s\nThird  36 / 200 [=========>---------------------------------------------]  18.00% 00m08s\n```\n"
        },
        {
          "name": "example_copy_test.go",
          "type": "blob",
          "size": 1.5595703125,
          "content": "package pb_test\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/cheggaaa/pb\"\n)\n\nfunc Example_copy() {\n\t// check args\n\tif len(os.Args) < 3 {\n\t\tprintUsage()\n\t\treturn\n\t}\n\tsourceName, destName := os.Args[1], os.Args[2]\n\n\t// check source\n\tvar source io.Reader\n\tvar sourceSize int64\n\tif strings.HasPrefix(sourceName, \"http://\") {\n\t\t// open as url\n\t\tresp, err := http.Get(sourceName)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Can't get %s: %v\\n\", sourceName, err)\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tfmt.Printf(\"Server return non-200 status: %v\\n\", resp.Status)\n\t\t\treturn\n\t\t}\n\t\ti, _ := strconv.Atoi(resp.Header.Get(\"Content-Length\"))\n\t\tsourceSize = int64(i)\n\t\tsource = resp.Body\n\t} else {\n\t\t// open as file\n\t\ts, err := os.Open(sourceName)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Can't open %s: %v\\n\", sourceName, err)\n\t\t\treturn\n\t\t}\n\t\tdefer s.Close()\n\t\t// get source size\n\t\tsourceStat, err := s.Stat()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Can't stat %s: %v\\n\", sourceName, err)\n\t\t\treturn\n\t\t}\n\t\tsourceSize = sourceStat.Size()\n\t\tsource = s\n\t}\n\n\t// create dest\n\tdest, err := os.Create(destName)\n\tif err != nil {\n\t\tfmt.Printf(\"Can't create %s: %v\\n\", destName, err)\n\t\treturn\n\t}\n\tdefer dest.Close()\n\n\t// create bar\n\tbar := pb.New(int(sourceSize)).SetUnits(pb.U_BYTES).SetRefreshRate(time.Millisecond * 10)\n\tbar.ShowSpeed = true\n\tbar.Start()\n\n\t// create proxy reader\n\treader := bar.NewProxyReader(source)\n\n\t// and copy from reader\n\tio.Copy(dest, reader)\n\tbar.Finish()\n}\n\nfunc printUsage() {\n\tfmt.Println(\"copy [source file or url] [dest file]\")\n}\n"
        },
        {
          "name": "example_multiple_test.go",
          "type": "blob",
          "size": 0.6767578125,
          "content": "package pb_test\n\nimport (\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/cheggaaa/pb\"\n)\n\nfunc Example_multiple() {\n\t// create bars\n\tfirst := pb.New(200).Prefix(\"First \")\n\tsecond := pb.New(200).Prefix(\"Second \")\n\tthird := pb.New(200).Prefix(\"Third \")\n\t// start pool\n\tpool, err := pb.StartPool(first, second, third)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// update bars\n\twg := new(sync.WaitGroup)\n\tfor _, bar := range []*pb.ProgressBar{first, second, third} {\n\t\twg.Add(1)\n\t\tgo func(cb *pb.ProgressBar) {\n\t\t\tfor n := 0; n < 200; n++ {\n\t\t\t\tcb.Increment()\n\t\t\t\ttime.Sleep(time.Millisecond * time.Duration(rand.Intn(100)))\n\t\t\t}\n\t\t\tcb.Finish()\n\t\t\twg.Done()\n\t\t}(bar)\n\t}\n\twg.Wait()\n\t// close pool\n\tpool.Stop()\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 0.4296875,
          "content": "package pb_test\n\nimport (\n\t\"time\"\n\n\t\"github.com/cheggaaa/pb\"\n)\n\nfunc Example() {\n\tcount := 5000\n\tbar := pb.New(count)\n\n\t// show percents (by default already true)\n\tbar.ShowPercent = true\n\n\t// show bar (by default already true)\n\tbar.ShowBar = true\n\n\tbar.ShowCounters = true\n\n\tbar.ShowTimeLeft = true\n\n\t// and start\n\tbar.Start()\n\tfor i := 0; i < count; i++ {\n\t\tbar.Increment()\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\tbar.FinishPrint(\"The End!\")\n}\n"
        },
        {
          "name": "format.go",
          "type": "blob",
          "size": 2.4873046875,
          "content": "package pb\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Units int\n\nconst (\n\t// U_NO are default units, they represent a simple value and are not formatted at all.\n\tU_NO Units = iota\n\t// U_BYTES units are formatted in a human readable way (B, KiB, MiB, ...)\n\tU_BYTES\n\t// U_BYTES_DEC units are like U_BYTES, but base 10 (B, KB, MB, ...)\n\tU_BYTES_DEC\n\t// U_DURATION units are formatted in a human readable way (3h14m15s)\n\tU_DURATION\n)\n\nconst (\n\tKiB = 1024\n\tMiB = 1048576\n\tGiB = 1073741824\n\tTiB = 1099511627776\n\n\tKB = 1e3\n\tMB = 1e6\n\tGB = 1e9\n\tTB = 1e12\n)\n\nfunc Format(i int64) *formatter {\n\treturn &formatter{n: i}\n}\n\ntype formatter struct {\n\tn      int64\n\tunit   Units\n\twidth  int\n\tperSec bool\n}\n\nfunc (f *formatter) To(unit Units) *formatter {\n\tf.unit = unit\n\treturn f\n}\n\nfunc (f *formatter) Width(width int) *formatter {\n\tf.width = width\n\treturn f\n}\n\nfunc (f *formatter) PerSec() *formatter {\n\tf.perSec = true\n\treturn f\n}\n\nfunc (f *formatter) String() (out string) {\n\tswitch f.unit {\n\tcase U_BYTES:\n\t\tout = formatBytes(f.n)\n\tcase U_BYTES_DEC:\n\t\tout = formatBytesDec(f.n)\n\tcase U_DURATION:\n\t\tout = formatDuration(f.n)\n\tdefault:\n\t\tout = fmt.Sprintf(fmt.Sprintf(\"%%%dd\", f.width), f.n)\n\t}\n\tif f.perSec {\n\t\tout += \"/s\"\n\t}\n\treturn\n}\n\n// Convert bytes to human readable string. Like 2 MiB, 64.2 KiB, 52 B\nfunc formatBytes(i int64) (result string) {\n\tswitch {\n\tcase i >= TiB:\n\t\tresult = fmt.Sprintf(\"%.02f TiB\", float64(i)/TiB)\n\tcase i >= GiB:\n\t\tresult = fmt.Sprintf(\"%.02f GiB\", float64(i)/GiB)\n\tcase i >= MiB:\n\t\tresult = fmt.Sprintf(\"%.02f MiB\", float64(i)/MiB)\n\tcase i >= KiB:\n\t\tresult = fmt.Sprintf(\"%.02f KiB\", float64(i)/KiB)\n\tdefault:\n\t\tresult = fmt.Sprintf(\"%d B\", i)\n\t}\n\treturn\n}\n\n// Convert bytes to base-10 human readable string. Like 2 MB, 64.2 KB, 52 B\nfunc formatBytesDec(i int64) (result string) {\n\tswitch {\n\tcase i >= TB:\n\t\tresult = fmt.Sprintf(\"%.02f TB\", float64(i)/TB)\n\tcase i >= GB:\n\t\tresult = fmt.Sprintf(\"%.02f GB\", float64(i)/GB)\n\tcase i >= MB:\n\t\tresult = fmt.Sprintf(\"%.02f MB\", float64(i)/MB)\n\tcase i >= KB:\n\t\tresult = fmt.Sprintf(\"%.02f KB\", float64(i)/KB)\n\tdefault:\n\t\tresult = fmt.Sprintf(\"%d B\", i)\n\t}\n\treturn\n}\n\nfunc formatDuration(n int64) (result string) {\n\td := time.Duration(n)\n\tif d > time.Hour*24 {\n\t\tresult = fmt.Sprintf(\"%dd\", d/24/time.Hour)\n\t\td -= (d / time.Hour / 24) * (time.Hour * 24)\n\t}\n\tif d > time.Hour {\n\t\tresult = fmt.Sprintf(\"%s%dh\", result, d/time.Hour)\n\t\td -= d / time.Hour * time.Hour\n\t}\n\tm := d / time.Minute\n\td -= m * time.Minute\n\ts := d / time.Second\n\tresult = fmt.Sprintf(\"%s%02dm%02ds\", result, m, s)\n\treturn\n}\n"
        },
        {
          "name": "format_test.go",
          "type": "blob",
          "size": 2.01953125,
          "content": "package pb\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc Test_DefaultsToInteger(t *testing.T) {\n\tvalue := int64(1000)\n\texpected := strconv.Itoa(int(value))\n\tactual := Format(value).String()\n\n\tif actual != expected {\n\t\tt.Errorf(\"Expected {%s} was {%s}\", expected, actual)\n\t}\n}\n\nfunc Test_CanFormatAsInteger(t *testing.T) {\n\tvalue := int64(1000)\n\texpected := strconv.Itoa(int(value))\n\tactual := Format(value).To(U_NO).String()\n\n\tif actual != expected {\n\t\tt.Errorf(\"Expected {%s} was {%s}\", expected, actual)\n\t}\n}\n\nfunc Test_CanFormatAsBytes(t *testing.T) {\n\tinputs := []struct {\n\t\tv int64\n\t\te string\n\t}{\n\t\t{v: 1000, e: \"1000 B\"},\n\t\t{v: 1024, e: \"1.00 KiB\"},\n\t\t{v: 3*MiB + 140*KiB, e: \"3.14 MiB\"},\n\t\t{v: 2 * GiB, e: \"2.00 GiB\"},\n\t\t{v: 2048 * GiB, e: \"2.00 TiB\"},\n\t}\n\n\tfor _, input := range inputs {\n\t\tactual := Format(input.v).To(U_BYTES).String()\n\t\tif actual != input.e {\n\t\t\tt.Errorf(\"Expected {%s} was {%s}\", input.e, actual)\n\t\t}\n\t}\n}\n\nfunc Test_CanFormatAsBytesDec(t *testing.T) {\n\tinputs := []struct {\n\t\tv int64\n\t\te string\n\t}{\n\t\t{v: 999, e: \"999 B\"},\n\t\t{v: 1024, e: \"1.02 KB\"},\n\t\t{v: 3*MB + 140*KB, e: \"3.14 MB\"},\n\t\t{v: 2 * GB, e: \"2.00 GB\"},\n\t\t{v: 2048 * GB, e: \"2.05 TB\"},\n\t}\n\n\tfor _, input := range inputs {\n\t\tactual := Format(input.v).To(U_BYTES_DEC).String()\n\t\tif actual != input.e {\n\t\t\tt.Errorf(\"Expected {%s} was {%s}\", input.e, actual)\n\t\t}\n\t}\n}\n\nfunc Test_CanFormatDuration(t *testing.T) {\n\tvalue := 10 * time.Minute\n\texpected := \"10m00s\"\n\tactual := Format(int64(value)).To(U_DURATION).String()\n\tif actual != expected {\n\t\tt.Errorf(\"Expected {%s} was {%s}\", expected, actual)\n\t}\n}\n\nfunc Test_CanFormatLongDuration(t *testing.T) {\n\tvalue := 62 * time.Hour + 13 * time.Second\n\texpected := \"2d14h00m13s\"\n\tactual := Format(int64(value)).To(U_DURATION).String()\n\tif actual != expected {\n\t\tt.Errorf(\"Expected {%s} was {%s}\", expected, actual)\n\t}\n}\n\nfunc Test_DefaultUnitsWidth(t *testing.T) {\n\tvalue := 10\n\texpected := \"     10\"\n\tactual := Format(int64(value)).Width(7).String()\n\tif actual != expected {\n\t\tt.Errorf(\"Expected {%s} was {%s}\", expected, actual)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1796875,
          "content": "module github.com/cheggaaa/pb\n\nrequire (\n\tgithub.com/fatih/color v1.9.0\n\tgithub.com/mattn/go-colorable v0.1.4\n\tgithub.com/mattn/go-runewidth v0.0.4\n\tgolang.org/x/sys v0.1.0\n)\n\ngo 1.12\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.1171875,
          "content": "github.com/fatih/color v1.9.0 h1:8xPHl4/q1VyqGIPif1F+1V3Y3lSmrq01EabUW3CoW5s=\ngithub.com/fatih/color v1.9.0/go.mod h1:eQcE1qtQxscV5RaZvpXrrb8Drkc3/DdQ+uUYCNjL+zU=\ngithub.com/mattn/go-colorable v0.1.4 h1:snbPLB8fVfU9iwbbo30TPtbLRzwWu6aJS6Xh4eaaviA=\ngithub.com/mattn/go-colorable v0.1.4/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.11 h1:FxPOTFNqGkuDUGi3H/qkUbQO4ZiBa2brKq5r0l8TGeM=\ngithub.com/mattn/go-isatty v0.0.11/go.mod h1:PhnuNfih5lzO57/f3n+odYbM4JtupLOxQOAqxQCu2WE=\ngithub.com/mattn/go-runewidth v0.0.4 h1:2BvfKmzob6Bmd4YsL0zygOqfdFnK7GR4QL06Do4/p7Y=\ngithub.com/mattn/go-runewidth v0.0.4/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.1.0 h1:kunALQeHf1/185U1i0GOB/fy1IPRDDpuoOOqRReG57U=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n"
        },
        {
          "name": "pb.go",
          "type": "blob",
          "size": 11.7294921875,
          "content": "// Simple console progress bars\npackage pb\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\t\"unicode/utf8\"\n)\n\n// Current version\nconst Version = \"1.0.29\"\n\nconst (\n\t// Default refresh rate - 200ms\n\tDEFAULT_REFRESH_RATE = time.Millisecond * 200\n\tFORMAT               = \"[=>-]\"\n)\n\n// DEPRECATED\n// variables for backward compatibility, from now do not work\n// use pb.Format and pb.SetRefreshRate\nvar (\n\tDefaultRefreshRate                         = DEFAULT_REFRESH_RATE\n\tBarStart, BarEnd, Empty, Current, CurrentN string\n)\n\n// Create new progress bar object\nfunc New(total int) *ProgressBar {\n\treturn New64(int64(total))\n}\n\n// Create new progress bar object using int64 as total\nfunc New64(total int64) *ProgressBar {\n\tpb := &ProgressBar{\n\t\tTotal:           total,\n\t\tRefreshRate:     DEFAULT_REFRESH_RATE,\n\t\tShowPercent:     true,\n\t\tShowCounters:    true,\n\t\tShowBar:         true,\n\t\tShowTimeLeft:    true,\n\t\tShowElapsedTime: false,\n\t\tShowFinalTime:   true,\n\t\tUnits:           U_NO,\n\t\tManualUpdate:    false,\n\t\tfinish:          make(chan struct{}),\n\t}\n\treturn pb.Format(FORMAT)\n}\n\n// Create new object and start\nfunc StartNew(total int) *ProgressBar {\n\treturn New(total).Start()\n}\n\n// Callback for custom output\n// For example:\n// bar.Callback = func(s string) {\n//     mySuperPrint(s)\n// }\n//\ntype Callback func(out string)\n\ntype ProgressBar struct {\n\tcurrent  int64 // current must be first member of struct (https://code.google.com/p/go/issues/detail?id=5278)\n\tprevious int64\n\n\tTotal                            int64\n\tRefreshRate                      time.Duration\n\tShowPercent, ShowCounters        bool\n\tShowSpeed, ShowTimeLeft, ShowBar bool\n\tShowFinalTime, ShowElapsedTime   bool\n\tHideCountersTotal                bool\n\tOutput                           io.Writer\n\tCallback                         Callback\n\tNotPrint                         bool\n\tUnits                            Units\n\tWidth                            int\n\tForceWidth                       bool\n\tManualUpdate                     bool\n\tAutoStat                         bool\n\n\t// Default width for the time box.\n\tUnitsWidth   int\n\tTimeBoxWidth int\n\n\tfinishOnce sync.Once //Guards isFinish\n\tfinish     chan struct{}\n\tisFinish   bool\n\n\tstartTime  time.Time\n\tstartValue int64\n\n\tchangeTime time.Time\n\n\tprefix, postfix string\n\n\tmu        sync.Mutex\n\tlastPrint string\n\n\tBarStart string\n\tBarEnd   string\n\tEmpty    string\n\tCurrent  string\n\tCurrentN string\n\n\tAlwaysUpdate bool\n}\n\n// Start print\nfunc (pb *ProgressBar) Start() *ProgressBar {\n\tpb.startTime = time.Now()\n\tpb.startValue = atomic.LoadInt64(&pb.current)\n\tif atomic.LoadInt64(&pb.Total) == 0 {\n\t\tpb.ShowTimeLeft = false\n\t\tpb.ShowPercent = false\n\t\tpb.AutoStat = false\n\t}\n\tif !pb.ManualUpdate {\n\t\tpb.Update() // Initial printing of the bar before running the bar refresher.\n\t\tgo pb.refresher()\n\t}\n\treturn pb\n}\n\n// Increment current value\nfunc (pb *ProgressBar) Increment() int {\n\treturn pb.Add(1)\n}\n\n// Get current value\nfunc (pb *ProgressBar) Get() int64 {\n\tc := atomic.LoadInt64(&pb.current)\n\treturn c\n}\n\n// Set current value\nfunc (pb *ProgressBar) Set(current int) *ProgressBar {\n\treturn pb.Set64(int64(current))\n}\n\n// Set64 sets the current value as int64\nfunc (pb *ProgressBar) Set64(current int64) *ProgressBar {\n\tatomic.StoreInt64(&pb.current, current)\n\treturn pb\n}\n\n// Add to current value\nfunc (pb *ProgressBar) Add(add int) int {\n\treturn int(pb.Add64(int64(add)))\n}\n\nfunc (pb *ProgressBar) Add64(add int64) int64 {\n\treturn atomic.AddInt64(&pb.current, add)\n}\n\n// Set prefix string\nfunc (pb *ProgressBar) Prefix(prefix string) *ProgressBar {\n\tpb.mu.Lock()\n\tdefer pb.mu.Unlock()\n\tpb.prefix = prefix\n\treturn pb\n}\n\n// Set postfix string\nfunc (pb *ProgressBar) Postfix(postfix string) *ProgressBar {\n\tpb.mu.Lock()\n\tdefer pb.mu.Unlock()\n\tpb.postfix = postfix\n\treturn pb\n}\n\n// Set custom format for bar\n// Example: bar.Format(\"[=>_]\")\n// Example: bar.Format(\"[\\x00=\\x00>\\x00-\\x00]\") // \\x00 is the delimiter\nfunc (pb *ProgressBar) Format(format string) *ProgressBar {\n\tvar formatEntries []string\n\tif utf8.RuneCountInString(format) == 5 {\n\t\tformatEntries = strings.Split(format, \"\")\n\t} else {\n\t\tformatEntries = strings.Split(format, \"\\x00\")\n\t}\n\tif len(formatEntries) == 5 {\n\t\tpb.BarStart = formatEntries[0]\n\t\tpb.BarEnd = formatEntries[4]\n\t\tpb.Empty = formatEntries[3]\n\t\tpb.Current = formatEntries[1]\n\t\tpb.CurrentN = formatEntries[2]\n\t}\n\treturn pb\n}\n\n// Set bar refresh rate\nfunc (pb *ProgressBar) SetRefreshRate(rate time.Duration) *ProgressBar {\n\tpb.RefreshRate = rate\n\treturn pb\n}\n\n// Set units\n// bar.SetUnits(U_NO) - by default\n// bar.SetUnits(U_BYTES) - for Mb, Kb, etc\nfunc (pb *ProgressBar) SetUnits(units Units) *ProgressBar {\n\tpb.Units = units\n\treturn pb\n}\n\n// Set max width, if width is bigger than terminal width, will be ignored\nfunc (pb *ProgressBar) SetMaxWidth(width int) *ProgressBar {\n\tpb.Width = width\n\tpb.ForceWidth = false\n\treturn pb\n}\n\n// Set bar width\nfunc (pb *ProgressBar) SetWidth(width int) *ProgressBar {\n\tpb.Width = width\n\tpb.ForceWidth = true\n\treturn pb\n}\n\n// End print\nfunc (pb *ProgressBar) Finish() {\n\t//Protect multiple calls\n\tpb.finishOnce.Do(func() {\n\t\tclose(pb.finish)\n\t\tpb.write(atomic.LoadInt64(&pb.Total), atomic.LoadInt64(&pb.current))\n\t\tpb.mu.Lock()\n\t\tdefer pb.mu.Unlock()\n\t\tswitch {\n\t\tcase pb.Output != nil:\n\t\t\tfmt.Fprintln(pb.Output)\n\t\tcase !pb.NotPrint:\n\t\t\tfmt.Println()\n\t\t}\n\t\tpb.isFinish = true\n\t})\n}\n\n// IsFinished return boolean\nfunc (pb *ProgressBar) IsFinished() bool {\n\tpb.mu.Lock()\n\tdefer pb.mu.Unlock()\n\treturn pb.isFinish\n}\n\n// End print and write string 'str'\nfunc (pb *ProgressBar) FinishPrint(str string) {\n\tpb.Finish()\n\tif pb.Output != nil {\n\t\tfmt.Fprintln(pb.Output, str)\n\t} else {\n\t\tfmt.Println(str)\n\t}\n}\n\n// implement io.Writer\nfunc (pb *ProgressBar) Write(p []byte) (n int, err error) {\n\tn = len(p)\n\tpb.Add(n)\n\treturn\n}\n\n// implement io.Reader\nfunc (pb *ProgressBar) Read(p []byte) (n int, err error) {\n\tn = len(p)\n\tpb.Add(n)\n\treturn\n}\n\n// Create new proxy reader over bar\n// Takes io.Reader or io.ReadCloser\nfunc (pb *ProgressBar) NewProxyReader(r io.Reader) *Reader {\n\treturn &Reader{r, pb}\n}\n\n// Create new proxy writer over bar\n// Takes io.Writer or io.WriteCloser\nfunc (pb *ProgressBar) NewProxyWriter(r io.Writer) *Writer {\n\treturn &Writer{r, pb}\n}\n\nfunc (pb *ProgressBar) write(total, current int64) {\n\tpb.mu.Lock()\n\tdefer pb.mu.Unlock()\n\twidth := pb.GetWidth()\n\n\tvar percentBox, countersBox, timeLeftBox, timeSpentBox, speedBox, barBox, end, out string\n\n\t// percents\n\tif pb.ShowPercent {\n\t\tvar percent float64\n\t\tif total > 0 {\n\t\t\tpercent = float64(current) / (float64(total) / float64(100))\n\t\t} else {\n\t\t\tpercent = float64(current) / float64(100)\n\t\t}\n\t\tpercentBox = fmt.Sprintf(\" %6.02f%%\", percent)\n\t}\n\n\t// counters\n\tif pb.ShowCounters {\n\t\tcurrent := Format(current).To(pb.Units).Width(pb.UnitsWidth)\n\t\tif total > 0 {\n\t\t\tif pb.HideCountersTotal {\n\t\t\t\tcountersBox = fmt.Sprintf(\" %s \", current)\n\t\t\t} else {\n\t\t\t\ttotalS := Format(total).To(pb.Units).Width(pb.UnitsWidth)\n\t\t\t\tcountersBox = fmt.Sprintf(\" %s / %s \", current, totalS)\n\t\t\t}\n\t\t} else {\n\t\t\tif pb.HideCountersTotal {\n\t\t\t\tcountersBox = fmt.Sprintf(\" %s \", current)\n\t\t\t} else {\n\t\t\t\tcountersBox = fmt.Sprintf(\" %s / ? \", current)\n\t\t\t}\n\t\t}\n\t}\n\n\t// time left\n\tcurrentFromStart := current - pb.startValue\n\tfromStart := time.Since(pb.startTime)\n\tlastChangeTime := pb.changeTime\n\tfromChange := lastChangeTime.Sub(pb.startTime)\n\n\tif pb.ShowElapsedTime {\n\t\ttimeSpentBox = fmt.Sprintf(\" %s \", (fromStart/time.Second)*time.Second)\n\t}\n\n\tselect {\n\tcase <-pb.finish:\n\t\tif pb.ShowFinalTime {\n\t\t\tvar left = (fromStart / time.Second) * time.Second\n\t\t\ttimeLeftBox = fmt.Sprintf(\" %s\", left.String())\n\t\t}\n\tdefault:\n\t\tif pb.ShowTimeLeft && currentFromStart > 0 {\n\t\t\tperEntry := fromChange / time.Duration(currentFromStart)\n\t\t\tvar left time.Duration\n\t\t\tif total > 0 {\n\t\t\t\tleft = time.Duration(total-current) * perEntry\n\t\t\t\tleft -= time.Since(lastChangeTime)\n\t\t\t\tleft = (left / time.Second) * time.Second\n\t\t\t}\n\t\t\tif left > 0 {\n\t\t\t\ttimeLeft := Format(int64(left)).To(U_DURATION).String()\n\t\t\t\ttimeLeftBox = fmt.Sprintf(\" %s\", timeLeft)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(timeLeftBox) < pb.TimeBoxWidth {\n\t\ttimeLeftBox = fmt.Sprintf(\"%s%s\", strings.Repeat(\" \", pb.TimeBoxWidth-len(timeLeftBox)), timeLeftBox)\n\t}\n\n\t// speed\n\tif pb.ShowSpeed && currentFromStart > 0 {\n\t\tfromStart := time.Since(pb.startTime)\n\t\tspeed := float64(currentFromStart) / (float64(fromStart) / float64(time.Second))\n\t\tspeedBox = \" \" + Format(int64(speed)).To(pb.Units).Width(pb.UnitsWidth).PerSec().String()\n\t}\n\n\tbarWidth := escapeAwareRuneCountInString(countersBox + pb.BarStart + pb.BarEnd + percentBox + timeSpentBox + timeLeftBox + speedBox + pb.prefix + pb.postfix)\n\t// bar\n\tif pb.ShowBar {\n\t\tsize := width - barWidth\n\t\tif size > 0 {\n\t\t\tif total > 0 {\n\t\t\t\tcurSize := int(math.Ceil((float64(current) / float64(total)) * float64(size)))\n\t\t\t\temptySize := size - curSize\n\t\t\t\tbarBox = pb.BarStart\n\t\t\t\tif emptySize < 0 {\n\t\t\t\t\temptySize = 0\n\t\t\t\t}\n\t\t\t\tif curSize > size {\n\t\t\t\t\tcurSize = size\n\t\t\t\t}\n\n\t\t\t\tcursorLen := escapeAwareRuneCountInString(pb.Current)\n\t\t\t\tif emptySize <= 0 {\n\t\t\t\t\tbarBox += strings.Repeat(pb.Current, curSize/cursorLen)\n\t\t\t\t} else if curSize > 0 {\n\t\t\t\t\tcursorEndLen := escapeAwareRuneCountInString(pb.CurrentN)\n\t\t\t\t\tcursorRepetitions := (curSize - cursorEndLen) / cursorLen\n\t\t\t\t\tbarBox += strings.Repeat(pb.Current, cursorRepetitions)\n\t\t\t\t\tbarBox += pb.CurrentN\n\t\t\t\t}\n\n\t\t\t\temptyLen := escapeAwareRuneCountInString(pb.Empty)\n\t\t\t\tbarBox += strings.Repeat(pb.Empty, emptySize/emptyLen)\n\t\t\t\tbarBox += pb.BarEnd\n\t\t\t} else {\n\t\t\t\tpos := size - int(current)%int(size)\n\t\t\t\tbarBox = pb.BarStart\n\t\t\t\tif pos-1 > 0 {\n\t\t\t\t\tbarBox += strings.Repeat(pb.Empty, pos-1)\n\t\t\t\t}\n\t\t\t\tbarBox += pb.Current\n\t\t\t\tif size-pos-1 > 0 {\n\t\t\t\t\tbarBox += strings.Repeat(pb.Empty, size-pos-1)\n\t\t\t\t}\n\t\t\t\tbarBox += pb.BarEnd\n\t\t\t}\n\t\t}\n\t}\n\n\t// check len\n\tout = pb.prefix + timeSpentBox + countersBox + barBox + percentBox + speedBox + timeLeftBox + pb.postfix\n\n\tif cl := escapeAwareRuneCountInString(out); cl < width {\n\t\tend = strings.Repeat(\" \", width-cl)\n\t}\n\n\t// and print!\n\tpb.lastPrint = out + end\n\tisFinish := pb.isFinish\n\n\tswitch {\n\tcase isFinish:\n\t\treturn\n\tcase pb.Output != nil:\n\t\tfmt.Fprint(pb.Output, \"\\r\"+out+end)\n\tcase pb.Callback != nil:\n\t\tpb.Callback(out + end)\n\tcase !pb.NotPrint:\n\t\tfmt.Print(\"\\r\" + out + end)\n\t}\n}\n\n// GetTerminalWidth - returns terminal width for all platforms.\nfunc GetTerminalWidth() (int, error) {\n\treturn terminalWidth()\n}\n\nfunc (pb *ProgressBar) GetWidth() int {\n\tif pb.ForceWidth {\n\t\treturn pb.Width\n\t}\n\n\twidth := pb.Width\n\ttermWidth, _ := terminalWidth()\n\tif width == 0 || termWidth <= width {\n\t\twidth = termWidth\n\t}\n\n\treturn width\n}\n\n// Write the current state of the progressbar\nfunc (pb *ProgressBar) Update() {\n\tc := atomic.LoadInt64(&pb.current)\n\tp := atomic.LoadInt64(&pb.previous)\n\tt := atomic.LoadInt64(&pb.Total)\n\tif p != c {\n\t\tpb.mu.Lock()\n\t\tpb.changeTime = time.Now()\n\t\tpb.mu.Unlock()\n\t\tatomic.StoreInt64(&pb.previous, c)\n\t}\n\tpb.write(t, c)\n\tif pb.AutoStat {\n\t\tif c == 0 {\n\t\t\tpb.startTime = time.Now()\n\t\t\tpb.startValue = 0\n\t\t} else if c >= t && !pb.isFinish{\n\t\t\tpb.Finish()\n\t\t}\n\t}\n}\n\n// String return the last bar print\nfunc (pb *ProgressBar) String() string {\n\tpb.mu.Lock()\n\tdefer pb.mu.Unlock()\n\treturn pb.lastPrint\n}\n\n// SetTotal atomically sets new total count\nfunc (pb *ProgressBar) SetTotal(total int) *ProgressBar {\n\treturn pb.SetTotal64(int64(total))\n}\n\n// SetTotal64 atomically sets new total count\nfunc (pb *ProgressBar) SetTotal64(total int64) *ProgressBar {\n\tatomic.StoreInt64(&pb.Total, total)\n\treturn pb\n}\n\n// Reset bar and set new total count\n// Does effect only on finished bar\nfunc (pb *ProgressBar) Reset(total int) *ProgressBar {\n\tpb.mu.Lock()\n\tdefer pb.mu.Unlock()\n\tif pb.isFinish {\n\t\tpb.SetTotal(total).Set(0)\n\t\tatomic.StoreInt64(&pb.previous, 0)\n\t}\n\treturn pb\n}\n\n// Internal loop for refreshing the progressbar\nfunc (pb *ProgressBar) refresher() {\n\tfor {\n\t\tselect {\n\t\tcase <-pb.finish:\n\t\t\treturn\n\t\tcase <-time.After(pb.RefreshRate):\n\t\t\tpb.Update()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "pb_appengine.go",
          "type": "blob",
          "size": 0.2705078125,
          "content": "// +build appengine js\n\npackage pb\n\nimport \"errors\"\n\n// terminalWidth returns width of the terminal, which is not supported\n// and should always failed on appengine classic which is a sandboxed PaaS.\nfunc terminalWidth() (int, error) {\n\treturn 0, errors.New(\"Not supported\")\n}\n"
        },
        {
          "name": "pb_plan9.go",
          "type": "blob",
          "size": 1.240234375,
          "content": "package pb\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\t\"syscall\"\n)\n\nvar ErrPoolWasStarted = errors.New(\"Bar pool was started\")\n\nvar (\n\techoLockMutex sync.Mutex\n\tconsctl       *os.File\n)\n\n// terminalWidth returns width of the terminal.\nfunc terminalWidth() (int, error) {\n\treturn 0, errors.New(\"Not Supported\")\n}\n\nfunc lockEcho() (shutdownCh chan struct{}, err error) {\n\techoLockMutex.Lock()\n\tdefer echoLockMutex.Unlock()\n\n\tif consctl != nil {\n\t\treturn nil, ErrPoolWasStarted\n\t}\n\tconsctl, err = os.OpenFile(\"/dev/consctl\", os.O_WRONLY, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_, err = consctl.WriteString(\"rawon\")\n\tif err != nil {\n\t\tconsctl.Close()\n\t\tconsctl = nil\n\t\treturn nil, err\n\t}\n\tshutdownCh = make(chan struct{})\n\tgo catchTerminate(shutdownCh)\n\treturn\n}\n\nfunc unlockEcho() error {\n\techoLockMutex.Lock()\n\tdefer echoLockMutex.Unlock()\n\n\tif consctl == nil {\n\t\treturn nil\n\t}\n\tif err := consctl.Close(); err != nil {\n\t\treturn err\n\t}\n\tconsctl = nil\n\treturn nil\n}\n\n// listen exit signals and restore terminal state\nfunc catchTerminate(shutdownCh chan struct{}) {\n\tsig := make(chan os.Signal, 1)\n\tsignal.Notify(sig, os.Interrupt, syscall.SIGTERM, syscall.SIGKILL)\n\tdefer signal.Stop(sig)\n\tselect {\n\tcase <-shutdownCh:\n\t\tunlockEcho()\n\tcase <-sig:\n\t\tunlockEcho()\n\t}\n}\n"
        },
        {
          "name": "pb_test.go",
          "type": "blob",
          "size": 3.037109375,
          "content": "package pb\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/mattn/go-colorable\"\n)\n\nfunc Test_IncrementAddsOne(t *testing.T) {\n\tcount := 5000\n\tbar := New(count)\n\texpected := 1\n\tactual := bar.Increment()\n\n\tif actual != expected {\n\t\tt.Errorf(\"Expected {%d} was {%d}\", expected, actual)\n\t}\n}\n\nfunc Test_Width(t *testing.T) {\n\tcount := 5000\n\tbar := New(count)\n\twidth := 100\n\tbar.SetWidth(100).Callback = func(out string) {\n\t\tif len(out) != width {\n\t\t\tt.Errorf(\"Bar width expected {%d} was {%d}\", len(out), width)\n\t\t}\n\t}\n\tbar.Start()\n\tbar.Increment()\n\tbar.Finish()\n}\n\nfunc Test_MultipleFinish(t *testing.T) {\n\tbar := New(5000)\n\tbar.Add(2000)\n\tbar.Finish()\n\tbar.Finish()\n}\n\nfunc TestWriteRace(t *testing.T) {\n\toutBuffer := &bytes.Buffer{}\n\ttotalCount := 20\n\tbar := New(totalCount)\n\tbar.Output = outBuffer\n\tbar.Start()\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < totalCount; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tbar.Increment()\n\t\t\ttime.Sleep(250 * time.Millisecond)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tbar.Finish()\n}\n\nfunc Test_Format(t *testing.T) {\n\tbar := New(5000).Format(strings.Join([]string{\n\t\tcolor.GreenString(\"[\"),\n\t\tcolor.New(color.BgGreen).SprintFunc()(\"o\"),\n\t\tcolor.New(color.BgHiGreen).SprintFunc()(\"o\"),\n\t\tcolor.New(color.BgRed).SprintFunc()(\"o\"),\n\t\tcolor.GreenString(\"]\"),\n\t}, \"\\x00\"))\n\tw := colorable.NewColorableStdout()\n\tbar.Callback = func(out string) {\n\t\tw.Write([]byte(out))\n\t}\n\tbar.Add(2000)\n\tbar.Finish()\n\tbar.Finish()\n}\n\nfunc Test_MultiCharacter(t *testing.T) {\n\tbar := New(5).Format(strings.Join([]string{\"[[[\", \"---\", \">>\", \"....\", \"]]\"}, \"\\x00\"))\n\tbar.Start()\n\tfor i := 0; i < 5; i++ {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\tbar.Increment()\n\t}\n\n\ttime.Sleep(500 * time.Millisecond)\n\tbar.Finish()\n}\n\nfunc Test_AutoStat(t *testing.T) {\n\tbar := New(5)\n\tbar.AutoStat = true\n\tbar.Start()\n\ttime.Sleep(2 * time.Second)\n\t//real start work\n\tfor i := 0; i < 5; i++ {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\tbar.Increment()\n\t}\n\t//real finish work\n\ttime.Sleep(2 * time.Second)\n\tbar.Finish()\n}\n\nfunc Test_Finish_PrintNewline(t *testing.T) {\n\tbar := New(5)\n\tbuf := &bytes.Buffer{}\n\tbar.Output = buf\n\tbar.Finish()\n\n\texpected := \"\\n\"\n\tactual := buf.String()\n\t//Finish should write newline to bar.Output\n\tif !strings.HasSuffix(actual, expected) {\n\t\tt.Errorf(\"Expected %q to have suffix %q\", expected, actual)\n\t}\n}\n\nfunc Test_FinishPrint(t *testing.T) {\n\tbar := New(5)\n\tbuf := &bytes.Buffer{}\n\tbar.Output = buf\n\tbar.FinishPrint(\"foo\")\n\n\texpected := \"foo\\n\"\n\tactual := buf.String()\n\t//FinishPrint should write to bar.Output\n\tif !strings.HasSuffix(actual, expected) {\n\t\tt.Errorf(\"Expected %q to have suffix %q\", expected, actual)\n\t}\n}\n\nfunc Test_Reset(t *testing.T) {\n\tbar := StartNew(5)\n\tfor i := 0; i < 5; i++ {\n\t\tbar.Increment()\n\t}\n\tif actual := bar.Get(); actual != 5 {\n\t\tt.Errorf(\"Expected: %d; actual: %d\", 5, actual)\n\t}\n\tbar.Finish()\n\tbar.Reset(10).Start()\n\tdefer bar.Finish()\n\tif actual := bar.Get(); actual != 0 {\n\t\tt.Errorf(\"Expected: %d; actual: %d\", 0, actual)\n\t}\n\tif actual := bar.Total; actual != 10 {\n\t\tt.Errorf(\"Expected: %d; actual: %d\", 10, actual)\n\t}\n}\n"
        },
        {
          "name": "pb_win.go",
          "type": "blob",
          "size": 4.115234375,
          "content": "// +build windows\n\npackage pb\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nvar tty = os.Stdin\n\nvar (\n\tkernel32 = syscall.NewLazyDLL(\"kernel32.dll\")\n\n\t// GetConsoleScreenBufferInfo retrieves information about the\n\t// specified console screen buffer.\n\t// http://msdn.microsoft.com/en-us/library/windows/desktop/ms683171(v=vs.85).aspx\n\tprocGetConsoleScreenBufferInfo = kernel32.NewProc(\"GetConsoleScreenBufferInfo\")\n\n\t// GetConsoleMode retrieves the current input mode of a console's\n\t// input buffer or the current output mode of a console screen buffer.\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms683167(v=vs.85).aspx\n\tgetConsoleMode = kernel32.NewProc(\"GetConsoleMode\")\n\n\t// SetConsoleMode sets the input mode of a console's input buffer\n\t// or the output mode of a console screen buffer.\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms686033(v=vs.85).aspx\n\tsetConsoleMode = kernel32.NewProc(\"SetConsoleMode\")\n\n\t// SetConsoleCursorPosition sets the cursor position in the\n\t// specified console screen buffer.\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms686025(v=vs.85).aspx\n\tsetConsoleCursorPosition = kernel32.NewProc(\"SetConsoleCursorPosition\")\n)\n\ntype (\n\t// Defines the coordinates of the upper left and lower right corners\n\t// of a rectangle.\n\t// See\n\t// http://msdn.microsoft.com/en-us/library/windows/desktop/ms686311(v=vs.85).aspx\n\tsmallRect struct {\n\t\tLeft, Top, Right, Bottom int16\n\t}\n\n\t// Defines the coordinates of a character cell in a console screen\n\t// buffer. The origin of the coordinate system (0,0) is at the top, left cell\n\t// of the buffer.\n\t// See\n\t// http://msdn.microsoft.com/en-us/library/windows/desktop/ms682119(v=vs.85).aspx\n\tcoordinates struct {\n\t\tX, Y int16\n\t}\n\n\tword int16\n\n\t// Contains information about a console screen buffer.\n\t// http://msdn.microsoft.com/en-us/library/windows/desktop/ms682093(v=vs.85).aspx\n\tconsoleScreenBufferInfo struct {\n\t\tdwSize              coordinates\n\t\tdwCursorPosition    coordinates\n\t\twAttributes         word\n\t\tsrWindow            smallRect\n\t\tdwMaximumWindowSize coordinates\n\t}\n)\n\n// terminalWidth returns width of the terminal.\nfunc terminalWidth() (width int, err error) {\n\tvar info consoleScreenBufferInfo\n\t_, _, e := syscall.Syscall(procGetConsoleScreenBufferInfo.Addr(), 2, uintptr(syscall.Stdout), uintptr(unsafe.Pointer(&info)), 0)\n\tif e != 0 {\n\t\treturn 0, error(e)\n\t}\n\treturn int(info.dwSize.X) - 1, nil\n}\n\nfunc getCursorPos() (pos coordinates, err error) {\n\tvar info consoleScreenBufferInfo\n\t_, _, e := syscall.Syscall(procGetConsoleScreenBufferInfo.Addr(), 2, uintptr(syscall.Stdout), uintptr(unsafe.Pointer(&info)), 0)\n\tif e != 0 {\n\t\treturn info.dwCursorPosition, error(e)\n\t}\n\treturn info.dwCursorPosition, nil\n}\n\nfunc setCursorPos(pos coordinates) error {\n\t_, _, e := syscall.Syscall(setConsoleCursorPosition.Addr(), 2, uintptr(syscall.Stdout), uintptr(uint32(uint16(pos.Y))<<16|uint32(uint16(pos.X))), 0)\n\tif e != 0 {\n\t\treturn error(e)\n\t}\n\treturn nil\n}\n\nvar ErrPoolWasStarted = errors.New(\"Bar pool was started\")\n\nvar echoLocked bool\nvar echoLockMutex sync.Mutex\n\nvar oldState word\n\nfunc lockEcho() (shutdownCh chan struct{}, err error) {\n\techoLockMutex.Lock()\n\tdefer echoLockMutex.Unlock()\n\tif echoLocked {\n\t\terr = ErrPoolWasStarted\n\t\treturn\n\t}\n\techoLocked = true\n\n\tif _, _, e := syscall.Syscall(getConsoleMode.Addr(), 2, uintptr(syscall.Stdout), uintptr(unsafe.Pointer(&oldState)), 0); e != 0 {\n\t\terr = fmt.Errorf(\"Can't get terminal settings: %v\", e)\n\t\treturn\n\t}\n\n\tnewState := oldState\n\tconst ENABLE_ECHO_INPUT = 0x0004\n\tconst ENABLE_LINE_INPUT = 0x0002\n\tnewState = newState & (^(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT))\n\tif _, _, e := syscall.Syscall(setConsoleMode.Addr(), 2, uintptr(syscall.Stdout), uintptr(newState), 0); e != 0 {\n\t\terr = fmt.Errorf(\"Can't set terminal settings: %v\", e)\n\t\treturn\n\t}\n\n\tshutdownCh = make(chan struct{})\n\treturn\n}\n\nfunc unlockEcho() (err error) {\n\techoLockMutex.Lock()\n\tdefer echoLockMutex.Unlock()\n\tif !echoLocked {\n\t\treturn\n\t}\n\techoLocked = false\n\tif _, _, e := syscall.Syscall(setConsoleMode.Addr(), 2, uintptr(syscall.Stdout), uintptr(oldState), 0); e != 0 {\n\t\terr = fmt.Errorf(\"Can't set terminal settings\")\n\t}\n\treturn\n}\n"
        },
        {
          "name": "pb_x.go",
          "type": "blob",
          "size": 2.3173828125,
          "content": "// +build linux darwin freebsd netbsd openbsd solaris dragonfly aix zos\n// +build !appengine !js\n\npackage pb\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nvar ErrPoolWasStarted = errors.New(\"Bar pool was started\")\n\nvar (\n\techoLockMutex    sync.Mutex\n\torigTermStatePtr *unix.Termios\n\ttty              *os.File\n\tistty            bool\n)\n\nfunc init() {\n\techoLockMutex.Lock()\n\tdefer echoLockMutex.Unlock()\n\n\tvar err error\n\ttty, err = os.Open(\"/dev/tty\")\n\tistty = true\n\tif err != nil {\n\t\ttty = os.Stdin\n\t\tistty = false\n\t}\n}\n\n// terminalWidth returns width of the terminal.\nfunc terminalWidth() (int, error) {\n\tif !istty {\n\t\treturn 0, errors.New(\"Not Supported\")\n\t}\n\techoLockMutex.Lock()\n\tdefer echoLockMutex.Unlock()\n\n\tfd := int(tty.Fd())\n\n\tws, err := unix.IoctlGetWinsize(fd, unix.TIOCGWINSZ)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn int(ws.Col), nil\n}\n\nfunc lockEcho() (shutdownCh chan struct{}, err error) {\n\techoLockMutex.Lock()\n\tdefer echoLockMutex.Unlock()\n\tif istty {\n\t\tif origTermStatePtr != nil {\n\t\t\treturn shutdownCh, ErrPoolWasStarted\n\t\t}\n\n\t\tfd := int(tty.Fd())\n\n\t\torigTermStatePtr, err = unix.IoctlGetTermios(fd, ioctlReadTermios)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Can't get terminal settings: %v\", err)\n\t\t}\n\n\t\toldTermios := *origTermStatePtr\n\t\tnewTermios := oldTermios\n\t\tnewTermios.Lflag &^= syscall.ECHO\n\t\tnewTermios.Lflag |= syscall.ICANON | syscall.ISIG\n\t\tnewTermios.Iflag |= syscall.ICRNL\n\t\tif err := unix.IoctlSetTermios(fd, ioctlWriteTermios, &newTermios); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Can't set terminal settings: %v\", err)\n\t\t}\n\n\t}\n\tshutdownCh = make(chan struct{})\n\tgo catchTerminate(shutdownCh)\n\treturn\n}\n\nfunc unlockEcho() error {\n\techoLockMutex.Lock()\n\tdefer echoLockMutex.Unlock()\n\tif istty {\n\t\tif origTermStatePtr == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tfd := int(tty.Fd())\n\n\t\tif err := unix.IoctlSetTermios(fd, ioctlWriteTermios, origTermStatePtr); err != nil {\n\t\t\treturn fmt.Errorf(\"Can't set terminal settings: %v\", err)\n\t\t}\n\n\t}\n\torigTermStatePtr = nil\n\n\treturn nil\n}\n\n// listen exit signals and restore terminal state\nfunc catchTerminate(shutdownCh chan struct{}) {\n\tsig := make(chan os.Signal, 1)\n\tsignal.Notify(sig, os.Interrupt, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGKILL)\n\tdefer signal.Stop(sig)\n\tselect {\n\tcase <-shutdownCh:\n\t\tunlockEcho()\n\tcase <-sig:\n\t\tunlockEcho()\n\t}\n}\n"
        },
        {
          "name": "pool.go",
          "type": "blob",
          "size": 1.7626953125,
          "content": "// +build linux darwin freebsd netbsd openbsd solaris dragonfly windows plan9 aix zos\n\npackage pb\n\nimport (\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Create and start new pool with given bars\n// You need call pool.Stop() after work\nfunc StartPool(pbs ...*ProgressBar) (pool *Pool, err error) {\n\tpool = new(Pool)\n\tif err = pool.Start(); err != nil {\n\t\treturn\n\t}\n\tpool.Add(pbs...)\n\treturn\n}\n\n// NewPool initialises a pool with progress bars, but\n// doesn't start it. You need to call Start manually\nfunc NewPool(pbs ...*ProgressBar) (pool *Pool) {\n\tpool = new(Pool)\n\tpool.Add(pbs...)\n\treturn\n}\n\ntype Pool struct {\n\tOutput        io.Writer\n\tRefreshRate   time.Duration\n\tbars          []*ProgressBar\n\tlastBarsCount int\n\tshutdownCh    chan struct{}\n\tworkerCh      chan struct{}\n\tm             sync.Mutex\n\tfinishOnce    sync.Once\n}\n\n// Add progress bars.\nfunc (p *Pool) Add(pbs ...*ProgressBar) {\n\tp.m.Lock()\n\tdefer p.m.Unlock()\n\tfor _, bar := range pbs {\n\t\tbar.ManualUpdate = true\n\t\tbar.NotPrint = true\n\t\tbar.Start()\n\t\tp.bars = append(p.bars, bar)\n\t}\n}\n\nfunc (p *Pool) Start() (err error) {\n\tp.RefreshRate = DefaultRefreshRate\n\tp.shutdownCh, err = lockEcho()\n\tif err != nil {\n\t\treturn\n\t}\n\tp.workerCh = make(chan struct{})\n\tgo p.writer()\n\treturn\n}\n\nfunc (p *Pool) writer() {\n\tvar first = true\n\tdefer func() {\n\t\tif !first {\n\t\t\tp.print(false)\n\t\t} else {\n\t\t\tp.print(true)\n\t\t\tp.print(false)\n\t\t}\n\t\tclose(p.workerCh)\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(p.RefreshRate):\n\t\t\tif p.print(first) {\n\t\t\t\tp.print(false)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfirst = false\n\t\tcase <-p.shutdownCh:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Stop Restore terminal state and close pool\nfunc (p *Pool) Stop() error {\n\tp.finishOnce.Do(func() {\n\t\tif p.shutdownCh != nil {\n\t\t\tclose(p.shutdownCh)\n\t\t}\n\t})\n\n\t// Wait for the worker to complete\n\t<-p.workerCh\n\n\n\treturn unlockEcho()\n}\n"
        },
        {
          "name": "pool_win.go",
          "type": "blob",
          "size": 0.6748046875,
          "content": "// +build windows\n\npackage pb\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc (p *Pool) print(first bool) bool {\n\tp.m.Lock()\n\tdefer p.m.Unlock()\n\tvar out string\n\tif !first {\n\t\tcoords, err := getCursorPos()\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\t\tcoords.Y -= int16(p.lastBarsCount)\n\t\tif coords.Y < 0 {\n\t\t\tcoords.Y = 0\n\t\t}\n\t\tcoords.X = 0\n\n\t\terr = setCursorPos(coords)\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\t}\n\tisFinished := true\n\tfor _, bar := range p.bars {\n\t\tif !bar.IsFinished() {\n\t\t\tisFinished = false\n\t\t}\n\t\tbar.Update()\n\t\tout += fmt.Sprintf(\"\\r%s\\n\", bar.String())\n\t}\n\tif p.Output != nil {\n\t\tfmt.Fprint(p.Output, out)\n\t} else {\n\t\tfmt.Print(out)\n\t}\n\tp.lastBarsCount = len(p.bars)\n\treturn isFinished\n}\n"
        },
        {
          "name": "pool_x.go",
          "type": "blob",
          "size": 0.541015625,
          "content": "// +build linux darwin freebsd netbsd openbsd solaris dragonfly plan9 aix zos\n\npackage pb\n\nimport \"fmt\"\n\nfunc (p *Pool) print(first bool) bool {\n\tp.m.Lock()\n\tdefer p.m.Unlock()\n\tvar out string\n\tif !first {\n\t\tout = fmt.Sprintf(\"\\033[%dA\", p.lastBarsCount)\n\t}\n\tisFinished := true\n\tfor _, bar := range p.bars {\n\t\tif !bar.IsFinished() {\n\t\t\tisFinished = false\n\t\t}\n\t\tbar.Update()\n\t\tout += fmt.Sprintf(\"\\r%s\\n\", bar.String())\n\t}\n\tif p.Output != nil {\n\t\tfmt.Fprint(p.Output, out)\n\t} else {\n\t\tfmt.Print(out)\n\t}\n\tp.lastBarsCount = len(p.bars)\n\treturn isFinished\n}\n"
        },
        {
          "name": "reader.go",
          "type": "blob",
          "size": 0.40625,
          "content": "package pb\n\nimport (\n\t\"io\"\n)\n\n// It's proxy reader, implement io.Reader\ntype Reader struct {\n\tio.Reader\n\tbar *ProgressBar\n}\n\nfunc (r *Reader) Read(p []byte) (n int, err error) {\n\tn, err = r.Reader.Read(p)\n\tr.bar.Add(n)\n\treturn\n}\n\n// Close the reader when it implements io.Closer\nfunc (r *Reader) Close() (err error) {\n\tr.bar.Finish()\n\tif closer, ok := r.Reader.(io.Closer); ok {\n\t\treturn closer.Close()\n\t}\n\treturn\n}\n"
        },
        {
          "name": "runecount.go",
          "type": "blob",
          "size": 0.35546875,
          "content": "package pb\n\nimport (\n\t\"github.com/mattn/go-runewidth\"\n\t\"regexp\"\n)\n\n// Finds the control character sequences (like colors)\nvar ctrlFinder = regexp.MustCompile(\"\\x1b\\x5b[0-9]+\\x6d\")\n\nfunc escapeAwareRuneCountInString(s string) int {\n\tn := runewidth.StringWidth(s)\n\tfor _, sm := range ctrlFinder.FindAllString(s, -1) {\n\t\tn -= runewidth.StringWidth(sm)\n\t}\n\treturn n\n}\n"
        },
        {
          "name": "runecount_test.go",
          "type": "blob",
          "size": 0.49609375,
          "content": "package pb\n\nimport \"testing\"\n\nfunc Test_RuneCount(t *testing.T) {\n\ts := string([]byte{\n\t\t27, 91, 51, 49, 109, // {Red}\n\t\t72, 101, 108, 108, 111, // Hello\n\t\t44, 32, // ,\n\t\t112, 108, 97, 121, 103, 114, 111, 117, 110, 100, // Playground\n\t\t27, 91, 48, 109, // {Reset}\n\t})\n\tif e, l := 17, escapeAwareRuneCountInString(s); l != e {\n\t\tt.Errorf(\"Invalid length %d, expected %d\", l, e)\n\t}\n\ts = \"進捗 \"\n\tif e, l := 5, escapeAwareRuneCountInString(s); l != e {\n\t\tt.Errorf(\"Invalid length %d, expected %d\", l, e)\n\t}\n}\n"
        },
        {
          "name": "termios_bsd.go",
          "type": "blob",
          "size": 0.1826171875,
          "content": "// +build darwin freebsd netbsd openbsd dragonfly\n// +build !appengine\n\npackage pb\n\nimport \"syscall\"\n\nconst ioctlReadTermios = syscall.TIOCGETA\nconst ioctlWriteTermios = syscall.TIOCSETA\n"
        },
        {
          "name": "termios_sysv.go",
          "type": "blob",
          "size": 0.1689453125,
          "content": "// +build linux solaris aix zos\n// +build !appengine\n\npackage pb\n\nimport \"golang.org/x/sys/unix\"\n\nconst ioctlReadTermios = unix.TCGETS\nconst ioctlWriteTermios = unix.TCSETS\n"
        },
        {
          "name": "v3",
          "type": "tree",
          "content": null
        },
        {
          "name": "writer.go",
          "type": "blob",
          "size": 0.408203125,
          "content": "package pb\n\nimport (\n\t\"io\"\n)\n\n// It's proxy Writer, implement io.Writer\ntype Writer struct {\n\tio.Writer\n\tbar *ProgressBar\n}\n\nfunc (r *Writer) Write(p []byte) (n int, err error) {\n\tn, err = r.Writer.Write(p)\n\tr.bar.Add(n)\n\treturn\n}\n\n// Close the reader when it implements io.Closer\nfunc (r *Writer) Close() (err error) {\n\tr.bar.Finish()\n\tif closer, ok := r.Writer.(io.Closer); ok {\n\t\treturn closer.Close()\n\t}\n\treturn\n}\n"
        }
      ]
    }
  ]
}