{
  "metadata": {
    "timestamp": 1736567278060,
    "page": 876,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "valyala/fastjson",
      "stars": 2329,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0048828125,
          "content": "tags\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.4013671875,
          "content": "language: go\n\ngo:\n  - 1.10.x\n\nscript:\n  # build test for supported platforms\n  - GOOS=linux go build\n  - GOOS=darwin go build\n  - GOOS=freebsd go build\n  - GOOS=windows go build\n\n  # run tests on a standard platform\n  - go test -v ./... -coverprofile=coverage.txt -covermode=atomic\n  - go test -v ./... -race\n\nafter_success:\n  # Upload coverage results to codecov.io\n  - bash <(curl -s https://codecov.io/bash)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2018 Aliaksandr Valialkin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.44140625,
          "content": "[![Build Status](https://travis-ci.org/valyala/fastjson.svg)](https://travis-ci.org/valyala/fastjson)\n[![GoDoc](https://godoc.org/github.com/valyala/fastjson?status.svg)](http://godoc.org/github.com/valyala/fastjson)\n[![Go Report](https://goreportcard.com/badge/github.com/valyala/fastjson)](https://goreportcard.com/report/github.com/valyala/fastjson)\n[![codecov](https://codecov.io/gh/valyala/fastjson/branch/master/graph/badge.svg)](https://codecov.io/gh/valyala/fastjson)\n\n# fastjson - fast JSON parser and validator for Go\n\n\n## Features\n\n  * Fast. As usual, up to 15x faster than the standard [encoding/json](https://golang.org/pkg/encoding/json/).\n    See [benchmarks](#benchmarks).\n  * Parses arbitrary JSON without schema, reflection, struct magic and code generation\n    contrary to [easyjson](https://github.com/mailru/easyjson).\n  * Provides simple [API](http://godoc.org/github.com/valyala/fastjson).\n  * Outperforms [jsonparser](https://github.com/buger/jsonparser) and [gjson](https://github.com/tidwall/gjson)\n    when accessing multiple unrelated fields, since `fastjson` parses the input JSON only once.\n  * Validates the parsed JSON unlike [jsonparser](https://github.com/buger/jsonparser)\n    and [gjson](https://github.com/tidwall/gjson).\n  * May quickly extract a part of the original JSON with `Value.Get(...).MarshalTo` and modify it\n    with [Del](https://godoc.org/github.com/valyala/fastjson#Value.Del)\n    and [Set](https://godoc.org/github.com/valyala/fastjson#Value.Set) functions.\n  * May parse array containing values with distinct types (aka non-homogenous types).\n    For instance, `fastjson` easily parses the following JSON array `[123, \"foo\", [456], {\"k\": \"v\"}, null]`.\n  * `fastjson` preserves the original order of object items when calling\n    [Object.Visit](https://godoc.org/github.com/valyala/fastjson#Object.Visit).\n\n\n## Known limitations\n\n  * Requies extra care to work with - references to certain objects recursively\n    returned by [Parser](https://godoc.org/github.com/valyala/fastjson#Parser)\n    must be released before the next call to [Parse](https://godoc.org/github.com/valyala/fastjson#Parser.Parse).\n    Otherwise the program may work improperly. The same applies to objects returned by [Arena](https://godoc.org/github.com/valyala/fastjson#Arena).\n    Adhere recommendations from [docs](https://godoc.org/github.com/valyala/fastjson).\n  * Cannot parse JSON from `io.Reader`. There is [Scanner](https://godoc.org/github.com/valyala/fastjson#Scanner)\n    for parsing stream of JSON values from a string.\n\n\n## Usage\n\nOne-liner accessing a single field:\n```go\n\ts := []byte(`{\"foo\": [123, \"bar\"]}`)\n\tfmt.Printf(\"foo.0=%d\\n\", fastjson.GetInt(s, \"foo\", \"0\"))\n\n\t// Output:\n\t// foo.0=123\n```\n\nAccessing multiple fields with error handling:\n```go\n        var p fastjson.Parser\n        v, err := p.Parse(`{\n                \"str\": \"bar\",\n                \"int\": 123,\n                \"float\": 1.23,\n                \"bool\": true,\n                \"arr\": [1, \"foo\", {}]\n        }`)\n        if err != nil {\n                log.Fatal(err)\n        }\n        fmt.Printf(\"foo=%s\\n\", v.GetStringBytes(\"str\"))\n        fmt.Printf(\"int=%d\\n\", v.GetInt(\"int\"))\n        fmt.Printf(\"float=%f\\n\", v.GetFloat64(\"float\"))\n        fmt.Printf(\"bool=%v\\n\", v.GetBool(\"bool\"))\n        fmt.Printf(\"arr.1=%s\\n\", v.GetStringBytes(\"arr\", \"1\"))\n\n        // Output:\n        // foo=bar\n        // int=123\n        // float=1.230000\n        // bool=true\n        // arr.1=foo\n```\n\nSee also [examples](https://godoc.org/github.com/valyala/fastjson#pkg-examples).\n\n\n## Security\n\n  * `fastjson` shouldn't crash or panic when parsing input strings specially crafted\n    by an attacker. It must return error on invalid input JSON.\n  * `fastjson` requires up to `sizeof(Value) * len(inputJSON)` bytes of memory\n    for parsing `inputJSON` string. Limit the maximum size of the `inputJSON`\n    before parsing it in order to limit the maximum memory usage.\n\n\n## Performance optimization tips\n\n  * Re-use [Parser](https://godoc.org/github.com/valyala/fastjson#Parser) and [Scanner](https://godoc.org/github.com/valyala/fastjson#Scanner)\n    for parsing many JSONs. This reduces memory allocations overhead.\n    [ParserPool](https://godoc.org/github.com/valyala/fastjson#ParserPool) may be useful in this case.\n  * Prefer calling `Value.Get*` on the value returned from [Parser](https://godoc.org/github.com/valyala/fastjson#Parser)\n    instead of calling `Get*` one-liners when multiple fields\n    must be obtained from JSON, since each `Get*` one-liner re-parses\n    the input JSON again.\n  * Prefer calling once [Value.Get](https://godoc.org/github.com/valyala/fastjson#Value.Get)\n    for common prefix paths and then calling `Value.Get*` on the returned value\n    for distinct suffix paths.\n  * Prefer iterating over array returned from [Value.GetArray](https://godoc.org/github.com/valyala/fastjson#Object.Visit)\n    with a range loop instead of calling `Value.Get*` for each array item.\n\n## Fuzzing\nInstall [go-fuzz](https://github.com/dvyukov/go-fuzz) & optionally the go-fuzz-corpus.\n\n```bash\ngo get -u github.com/dvyukov/go-fuzz/go-fuzz github.com/dvyukov/go-fuzz/go-fuzz-build\n```\n\nBuild using `go-fuzz-build` and run `go-fuzz` with an optional corpus.\n\n```bash\nmkdir -p workdir/corpus\ncp $GOPATH/src/github.com/dvyukov/go-fuzz-corpus/json/corpus/* workdir/corpus\ngo-fuzz-build github.com/valyala/fastjson\ngo-fuzz -bin=fastjson-fuzz.zip -workdir=workdir\n```\n\n## Benchmarks\n\nGo 1.12 has been used for benchmarking.\n\nLegend:\n\n  * `small` - parse [small.json](testdata/small.json) (190 bytes).\n  * `medium` - parse [medium.json](testdata/medium.json) (2.3KB).\n  * `large` - parse [large.json](testdata/large.json) (28KB).\n  * `canada` - parse [canada.json](testdata/canada.json) (2.2MB).\n  * `citm` - parse [citm_catalog.json](testdata/citm_catalog.json) (1.7MB).\n  * `twitter` - parse [twitter.json](testdata/twitter.json) (617KB).\n\n  * `stdjson-map` - parse into a `map[string]interface{}` using `encoding/json`.\n  * `stdjson-struct` - parse into a struct containing\n    a subset of fields of the parsed JSON, using `encoding/json`.\n  * `stdjson-empty-struct` - parse into an empty struct using `encoding/json`.\n    This is the fastest possible solution for `encoding/json`, may be used\n    for json validation. See also benchmark results for json validation.\n  * `fastjson` - parse using `fastjson` without fields access.\n  * `fastjson-get` - parse using `fastjson` with fields access similar to `stdjson-struct`.\n\n```\n$ GOMAXPROCS=1 go test github.com/valyala/fastjson -bench='Parse$'\ngoos: linux\ngoarch: amd64\npkg: github.com/valyala/fastjson\nBenchmarkParse/small/stdjson-map         \t  200000\t      7305 ns/op\t  26.01 MB/s\t     960 B/op\t      51 allocs/op\nBenchmarkParse/small/stdjson-struct      \t  500000\t      3431 ns/op\t  55.37 MB/s\t     224 B/op\t       4 allocs/op\nBenchmarkParse/small/stdjson-empty-struct         \t  500000\t      2273 ns/op\t  83.58 MB/s\t     168 B/op\t       2 allocs/op\nBenchmarkParse/small/fastjson                     \t 5000000\t       347 ns/op\t 547.53 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkParse/small/fastjson-get                 \t 2000000\t       620 ns/op\t 306.39 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkParse/medium/stdjson-map                 \t   30000\t     40672 ns/op\t  57.26 MB/s\t   10196 B/op\t     208 allocs/op\nBenchmarkParse/medium/stdjson-struct              \t   30000\t     47792 ns/op\t  48.73 MB/s\t    9174 B/op\t     258 allocs/op\nBenchmarkParse/medium/stdjson-empty-struct        \t  100000\t     22096 ns/op\t 105.40 MB/s\t     280 B/op\t       5 allocs/op\nBenchmarkParse/medium/fastjson                    \t  500000\t      3025 ns/op\t 769.90 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkParse/medium/fastjson-get                \t  500000\t      3211 ns/op\t 725.20 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkParse/large/stdjson-map                  \t    2000\t    614079 ns/op\t  45.79 MB/s\t  210734 B/op\t    2785 allocs/op\nBenchmarkParse/large/stdjson-struct               \t    5000\t    298554 ns/op\t  94.18 MB/s\t   15616 B/op\t     353 allocs/op\nBenchmarkParse/large/stdjson-empty-struct         \t    5000\t    268577 ns/op\t 104.69 MB/s\t     280 B/op\t       5 allocs/op\nBenchmarkParse/large/fastjson                     \t   50000\t     35210 ns/op\t 798.56 MB/s\t       5 B/op\t       0 allocs/op\nBenchmarkParse/large/fastjson-get                 \t   50000\t     35171 ns/op\t 799.46 MB/s\t       5 B/op\t       0 allocs/op\nBenchmarkParse/canada/stdjson-map                 \t      20\t  68147307 ns/op\t  33.03 MB/s\t12260502 B/op\t  392539 allocs/op\nBenchmarkParse/canada/stdjson-struct              \t      20\t  68044518 ns/op\t  33.08 MB/s\t12260123 B/op\t  392534 allocs/op\nBenchmarkParse/canada/stdjson-empty-struct        \t     100\t  17709250 ns/op\t 127.11 MB/s\t     280 B/op\t       5 allocs/op\nBenchmarkParse/canada/fastjson                    \t     300\t   4182404 ns/op\t 538.22 MB/s\t  254902 B/op\t     381 allocs/op\nBenchmarkParse/canada/fastjson-get                \t     300\t   4274744 ns/op\t 526.60 MB/s\t  254902 B/op\t     381 allocs/op\nBenchmarkParse/citm/stdjson-map                   \t      50\t  27772612 ns/op\t  62.19 MB/s\t 5214163 B/op\t   95402 allocs/op\nBenchmarkParse/citm/stdjson-struct                \t     100\t  14936191 ns/op\t 115.64 MB/s\t    1989 B/op\t      75 allocs/op\nBenchmarkParse/citm/stdjson-empty-struct          \t     100\t  14946034 ns/op\t 115.56 MB/s\t     280 B/op\t       5 allocs/op\nBenchmarkParse/citm/fastjson                      \t    1000\t   1879714 ns/op\t 918.87 MB/s\t   17628 B/op\t      30 allocs/op\nBenchmarkParse/citm/fastjson-get                  \t    1000\t   1881598 ns/op\t 917.94 MB/s\t   17628 B/op\t      30 allocs/op\nBenchmarkParse/twitter/stdjson-map                \t     100\t  11289146 ns/op\t  55.94 MB/s\t 2187878 B/op\t   31266 allocs/op\nBenchmarkParse/twitter/stdjson-struct             \t     300\t   5779442 ns/op\t 109.27 MB/s\t     408 B/op\t       6 allocs/op\nBenchmarkParse/twitter/stdjson-empty-struct       \t     300\t   5738504 ns/op\t 110.05 MB/s\t     408 B/op\t       6 allocs/op\nBenchmarkParse/twitter/fastjson                   \t    2000\t    774042 ns/op\t 815.86 MB/s\t    2541 B/op\t       2 allocs/op\nBenchmarkParse/twitter/fastjson-get               \t    2000\t    777833 ns/op\t 811.89 MB/s\t    2541 B/op\t       2 allocs/op\n```\n\nBenchmark results for json validation:\n\n```\n$ GOMAXPROCS=1 go test github.com/valyala/fastjson -bench='Validate$'\ngoos: linux\ngoarch: amd64\npkg: github.com/valyala/fastjson\nBenchmarkValidate/small/stdjson \t 2000000\t       955 ns/op\t 198.83 MB/s\t      72 B/op\t       2 allocs/op\nBenchmarkValidate/small/fastjson         \t 5000000\t       384 ns/op\t 493.60 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkValidate/medium/stdjson         \t  200000\t     10799 ns/op\t 215.66 MB/s\t     184 B/op\t       5 allocs/op\nBenchmarkValidate/medium/fastjson        \t  300000\t      3809 ns/op\t 611.30 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkValidate/large/stdjson          \t   10000\t    133064 ns/op\t 211.31 MB/s\t     184 B/op\t       5 allocs/op\nBenchmarkValidate/large/fastjson         \t   30000\t     45268 ns/op\t 621.14 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkValidate/canada/stdjson         \t     200\t   8470904 ns/op\t 265.74 MB/s\t     184 B/op\t       5 allocs/op\nBenchmarkValidate/canada/fastjson        \t     500\t   2973377 ns/op\t 757.07 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkValidate/citm/stdjson           \t     200\t   7273172 ns/op\t 237.48 MB/s\t     184 B/op\t       5 allocs/op\nBenchmarkValidate/citm/fastjson          \t    1000\t   1684430 ns/op\t1025.39 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkValidate/twitter/stdjson        \t     500\t   2849439 ns/op\t 221.63 MB/s\t     312 B/op\t       6 allocs/op\nBenchmarkValidate/twitter/fastjson       \t    2000\t   1036796 ns/op\t 609.10 MB/s\t       0 B/op\t       0 allocs/op\n```\n\n## FAQ\n\n  * Q: _There are a ton of other high-perf packages for JSON parsing in Go. Why creating yet another package?_\n    A: Because other packages require either rigid JSON schema via struct magic\n       and code generation or perform poorly when multiple unrelated fields\n       must be obtained from the parsed JSON.\n       Additionally, `fastjson` provides nicer [API](http://godoc.org/github.com/valyala/fastjson).\n\n  * Q: _What is the main purpose for `fastjson`?_\n    A: High-perf JSON parsing for [RTB](https://www.iab.com/wp-content/uploads/2015/05/OpenRTB_API_Specification_Version_2_3_1.pdf)\n       and other [JSON-RPC](https://en.wikipedia.org/wiki/JSON-RPC) services.\n\n  * Q: _Why fastjson doesn't provide fast marshaling (serialization)?_\n    A: Actually it provides some sort of marshaling - see [Value.MarshalTo](https://godoc.org/github.com/valyala/fastjson#Value.MarshalTo).\n       But I'd recommend using [quicktemplate](https://github.com/valyala/quicktemplate#use-cases)\n       for high-performance JSON marshaling :)\n\n  * Q: _`fastjson` crashes my program!_\n    A: There is high probability of improper use.\n       * Make sure you don't hold references to objects recursively returned by `Parser` / `Scanner`\n         beyond the next `Parser.Parse` / `Scanner.Next` call\n         if such restriction is mentioned in [docs](https://github.com/valyala/fastjson/issues/new).\n       * Make sure you don't access `fastjson` objects from concurrently running goroutines\n         if such restriction is mentioned in [docs](https://github.com/valyala/fastjson/issues/new).\n       * Build and run your program with [-race](https://golang.org/doc/articles/race_detector.html) flag.\n         Make sure the race detector detects zero races.\n       * If your program continue crashing after fixing issues mentioned above, [file a bug](https://github.com/valyala/fastjson/issues/new).\n"
        },
        {
          "name": "arena.go",
          "type": "blob",
          "size": 2.9267578125,
          "content": "package fastjson\n\nimport (\n\t\"strconv\"\n)\n\n// Arena may be used for fast creation and re-use of Values.\n//\n// Typical Arena lifecycle:\n//\n//     1) Construct Values via the Arena and Value.Set* calls.\n//     2) Marshal the constructed Values with Value.MarshalTo call.\n//     3) Reset all the constructed Values at once by Arena.Reset call.\n//     4) Go to 1 and re-use the Arena.\n//\n// It is unsafe calling Arena methods from concurrent goroutines.\n// Use per-goroutine Arenas or ArenaPool instead.\ntype Arena struct {\n\tb []byte\n\tc cache\n}\n\n// Reset resets all the Values allocated by a.\n//\n// Values previously allocated by a cannot be used after the Reset call.\nfunc (a *Arena) Reset() {\n\ta.b = a.b[:0]\n\ta.c.reset()\n}\n\n// NewObject returns new empty object value.\n//\n// New entries may be added to the returned object via Set call.\n//\n// The returned object is valid until Reset is called on a.\nfunc (a *Arena) NewObject() *Value {\n\tv := a.c.getValue()\n\tv.t = TypeObject\n\tv.o.reset()\n\treturn v\n}\n\n// NewArray returns new empty array value.\n//\n// New entries may be added to the returned array via Set* calls.\n//\n// The returned array is valid until Reset is called on a.\nfunc (a *Arena) NewArray() *Value {\n\tv := a.c.getValue()\n\tv.t = TypeArray\n\tv.a = v.a[:0]\n\treturn v\n}\n\n// NewString returns new string value containing s.\n//\n// The returned string is valid until Reset is called on a.\nfunc (a *Arena) NewString(s string) *Value {\n\tv := a.c.getValue()\n\tv.t = typeRawString\n\tbLen := len(a.b)\n\ta.b = escapeString(a.b, s)\n\tv.s = b2s(a.b[bLen+1 : len(a.b)-1])\n\treturn v\n}\n\n// NewStringBytes returns new string value containing b.\n//\n// The returned string is valid until Reset is called on a.\nfunc (a *Arena) NewStringBytes(b []byte) *Value {\n\tv := a.c.getValue()\n\tv.t = typeRawString\n\tbLen := len(a.b)\n\ta.b = escapeString(a.b, b2s(b))\n\tv.s = b2s(a.b[bLen+1 : len(a.b)-1])\n\treturn v\n}\n\n// NewNumberFloat64 returns new number value containing f.\n//\n// The returned number is valid until Reset is called on a.\nfunc (a *Arena) NewNumberFloat64(f float64) *Value {\n\tv := a.c.getValue()\n\tv.t = TypeNumber\n\tbLen := len(a.b)\n\ta.b = strconv.AppendFloat(a.b, f, 'g', -1, 64)\n\tv.s = b2s(a.b[bLen:])\n\treturn v\n}\n\n// NewNumberInt returns new number value containing n.\n//\n// The returned number is valid until Reset is called on a.\nfunc (a *Arena) NewNumberInt(n int) *Value {\n\tv := a.c.getValue()\n\tv.t = TypeNumber\n\tbLen := len(a.b)\n\ta.b = strconv.AppendInt(a.b, int64(n), 10)\n\tv.s = b2s(a.b[bLen:])\n\treturn v\n}\n\n// NewNumberString returns new number value containing s.\n//\n// The returned number is valid until Reset is called on a.\nfunc (a *Arena) NewNumberString(s string) *Value {\n\tv := a.c.getValue()\n\tv.t = TypeNumber\n\tv.s = s\n\treturn v\n}\n\n// NewNull returns null value.\nfunc (a *Arena) NewNull() *Value {\n\treturn valueNull\n}\n\n// NewTrue returns true value.\nfunc (a *Arena) NewTrue() *Value {\n\treturn valueTrue\n}\n\n// NewFalse return false value.\nfunc (a *Arena) NewFalse() *Value {\n\treturn valueFalse\n}\n"
        },
        {
          "name": "arena_test.go",
          "type": "blob",
          "size": 1.5390625,
          "content": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestArena(t *testing.T) {\n\tt.Run(\"serial\", func(t *testing.T) {\n\t\tvar a Arena\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif err := testArena(&a); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\ta.Reset()\n\t\t}\n\t})\n\tt.Run(\"concurrent\", func(t *testing.T) {\n\t\tvar ap ArenaPool\n\t\tworkers := 4\n\t\tch := make(chan error, workers)\n\t\tfor i := 0; i < workers; i++ {\n\t\t\tgo func() {\n\t\t\t\ta := ap.Get()\n\t\t\t\tdefer ap.Put(a)\n\t\t\t\tvar err error\n\t\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t\tif err = testArena(a); err != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch <- err\n\t\t\t}()\n\t\t}\n\t\tfor i := 0; i < workers; i++ {\n\t\t\tselect {\n\t\t\tcase err := <-ch:\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tt.Fatalf(\"timeout\")\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc testArena(a *Arena) error {\n\to := a.NewObject()\n\to.Set(\"nil1\", a.NewNull())\n\to.Set(\"nil2\", nil)\n\to.Set(\"false\", a.NewFalse())\n\to.Set(\"true\", a.NewTrue())\n\tni := a.NewNumberInt(123)\n\to.Set(\"ni\", ni)\n\to.Set(\"nf\", a.NewNumberFloat64(1.23))\n\to.Set(\"ns\", a.NewNumberString(\"34.43\"))\n\ts := a.NewString(\"foo\")\n\to.Set(\"str1\", s)\n\to.Set(\"str2\", a.NewStringBytes([]byte(\"xx\")))\n\n\taa := a.NewArray()\n\taa.SetArrayItem(0, s)\n\taa.Set(\"1\", ni)\n\to.Set(\"a\", aa)\n\tobj := a.NewObject()\n\tobj.Set(\"s\", s)\n\to.Set(\"obj\", obj)\n\n\tstr := o.String()\n\tstrExpected := `{\"nil1\":null,\"nil2\":null,\"false\":false,\"true\":true,\"ni\":123,\"nf\":1.23,\"ns\":34.43,\"str1\":\"foo\",\"str2\":\"xx\",\"a\":[\"foo\",123],\"obj\":{\"s\":\"foo\"}}`\n\tif str != strExpected {\n\t\treturn fmt.Errorf(\"unexpected json\\ngot\\n%s\\nwant\\n%s\", str, strExpected)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "arena_timing_test.go",
          "type": "blob",
          "size": 0.8828125,
          "content": "package fastjson\n\nimport (\n\t\"sync/atomic\"\n\t\"testing\"\n)\n\nfunc BenchmarkArenaTypicalUse(b *testing.B) {\n\t// Determine the length of created object\n\tvar aa Arena\n\tobj := benchCreateArenaObject(&aa)\n\tobjLen := len(obj.String())\n\tb.SetBytes(int64(objLen))\n\tb.ReportAllocs()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar buf []byte\n\t\tvar a Arena\n\t\tvar sink int\n\t\tfor pb.Next() {\n\t\t\tobj := benchCreateArenaObject(&a)\n\t\t\tbuf = obj.MarshalTo(buf[:0])\n\t\t\ta.Reset()\n\t\t\tsink += len(buf)\n\t\t}\n\t\tatomic.AddUint64(&Sink, uint64(sink))\n\t})\n}\n\nfunc benchCreateArenaObject(a *Arena) *Value {\n\to := a.NewObject()\n\to.Set(\"key1\", a.NewNumberInt(123))\n\to.Set(\"key2\", a.NewNumberFloat64(-1.23))\n\n\t// Create a string only once and use multuple times as a performance optimization.\n\ts := a.NewString(\"foobar\")\n\taa := a.NewArray()\n\tfor i := 0; i < 10; i++ {\n\t\taa.SetArrayItem(i, s)\n\t}\n\to.Set(\"key3\", aa)\n\treturn o\n}\n\nvar Sink uint64\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.2353515625,
          "content": "/*\nPackage fastjson provides fast JSON parsing.\n\nArbitrary JSON may be parsed by fastjson without the need for creating structs\nor for generating go code. Just parse JSON and get the required fields with\nGet* functions.\n\n*/\npackage fastjson\n"
        },
        {
          "name": "fastfloat",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz.go",
          "type": "blob",
          "size": 0.267578125,
          "content": "// +build gofuzz\n\npackage fastjson\n\nfunc Fuzz(data []byte) int {\n\terr := ValidateBytes(data)\n\tif err != nil {\n\t\treturn 0\n\t}\n\n\tv := MustParseBytes(data)\n\n\tdst := make([]byte, 0)\n\tdst = v.MarshalTo(dst)\n\n\terr = ValidateBytes(dst)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn 1\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.04296875,
          "content": "module github.com/valyala/fastjson\n\ngo 1.12\n"
        },
        {
          "name": "handy.go",
          "type": "blob",
          "size": 4.0068359375,
          "content": "package fastjson\n\nvar handyPool ParserPool\n\n// GetString returns string value for the field identified by keys path\n// in JSON data.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// An empty string is returned on error. Use Parser for proper error handling.\n//\n// Parser is faster for obtaining multiple fields from JSON.\nfunc GetString(data []byte, keys ...string) string {\n\tp := handyPool.Get()\n\tv, err := p.ParseBytes(data)\n\tif err != nil {\n\t\thandyPool.Put(p)\n\t\treturn \"\"\n\t}\n\tsb := v.GetStringBytes(keys...)\n\tstr := string(sb)\n\thandyPool.Put(p)\n\treturn str\n}\n\n// GetBytes returns string value for the field identified by keys path\n// in JSON data.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// nil is returned on error. Use Parser for proper error handling.\n//\n// Parser is faster for obtaining multiple fields from JSON.\nfunc GetBytes(data []byte, keys ...string) []byte {\n\tp := handyPool.Get()\n\tv, err := p.ParseBytes(data)\n\tif err != nil {\n\t\thandyPool.Put(p)\n\t\treturn nil\n\t}\n\tsb := v.GetStringBytes(keys...)\n\n\t// Make a copy of sb, since sb belongs to p.\n\tvar b []byte\n\tif sb != nil {\n\t\tb = append(b, sb...)\n\t}\n\n\thandyPool.Put(p)\n\treturn b\n}\n\n// GetInt returns int value for the field identified by keys path\n// in JSON data.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// 0 is returned on error. Use Parser for proper error handling.\n//\n// Parser is faster for obtaining multiple fields from JSON.\nfunc GetInt(data []byte, keys ...string) int {\n\tp := handyPool.Get()\n\tv, err := p.ParseBytes(data)\n\tif err != nil {\n\t\thandyPool.Put(p)\n\t\treturn 0\n\t}\n\tn := v.GetInt(keys...)\n\thandyPool.Put(p)\n\treturn n\n}\n\n// GetFloat64 returns float64 value for the field identified by keys path\n// in JSON data.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// 0 is returned on error. Use Parser for proper error handling.\n//\n// Parser is faster for obtaining multiple fields from JSON.\nfunc GetFloat64(data []byte, keys ...string) float64 {\n\tp := handyPool.Get()\n\tv, err := p.ParseBytes(data)\n\tif err != nil {\n\t\thandyPool.Put(p)\n\t\treturn 0\n\t}\n\tf := v.GetFloat64(keys...)\n\thandyPool.Put(p)\n\treturn f\n}\n\n// GetBool returns boolean value for the field identified by keys path\n// in JSON data.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// False is returned on error. Use Parser for proper error handling.\n//\n// Parser is faster for obtaining multiple fields from JSON.\nfunc GetBool(data []byte, keys ...string) bool {\n\tp := handyPool.Get()\n\tv, err := p.ParseBytes(data)\n\tif err != nil {\n\t\thandyPool.Put(p)\n\t\treturn false\n\t}\n\tb := v.GetBool(keys...)\n\thandyPool.Put(p)\n\treturn b\n}\n\n// Exists returns true if the field identified by keys path exists in JSON data.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// False is returned on error. Use Parser for proper error handling.\n//\n// Parser is faster when multiple fields must be checked in the JSON.\nfunc Exists(data []byte, keys ...string) bool {\n\tp := handyPool.Get()\n\tv, err := p.ParseBytes(data)\n\tif err != nil {\n\t\thandyPool.Put(p)\n\t\treturn false\n\t}\n\tok := v.Exists(keys...)\n\thandyPool.Put(p)\n\treturn ok\n}\n\n// Parse parses json string s.\n//\n// The function is slower than the Parser.Parse for re-used Parser.\nfunc Parse(s string) (*Value, error) {\n\tvar p Parser\n\treturn p.Parse(s)\n}\n\n// MustParse parses json string s.\n//\n// The function panics if s cannot be parsed.\n// The function is slower than the Parser.Parse for re-used Parser.\nfunc MustParse(s string) *Value {\n\tv, err := Parse(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn v\n}\n\n// ParseBytes parses b containing json.\n//\n// The function is slower than the Parser.ParseBytes for re-used Parser.\nfunc ParseBytes(b []byte) (*Value, error) {\n\tvar p Parser\n\treturn p.ParseBytes(b)\n}\n\n// MustParseBytes parses b containing json.\n//\n// The function panics if b cannot be parsed.\n// The function is slower than the Parser.ParseBytes for re-used Parser.\nfunc MustParseBytes(b []byte) *Value {\n\tv, err := ParseBytes(b)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn v\n}\n"
        },
        {
          "name": "handy_example_test.go",
          "type": "blob",
          "size": 1.2197265625,
          "content": "package fastjson_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc ExampleGetString() {\n\tdata := []byte(`{\"foo\":{\"bar\":[123,\"baz\"]}}`)\n\n\ts := fastjson.GetString(data, \"foo\", \"bar\", \"1\")\n\tfmt.Printf(\"data.foo.bar[1] = %s\", s)\n\n\t// Output:\n\t// data.foo.bar[1] = baz\n}\n\nfunc ExampleGetInt() {\n\tdata := []byte(`{\"foo\": [233,true, {\"bar\": [2343]} ]}`)\n\n\tn1 := fastjson.GetInt(data, \"foo\", \"0\")\n\tfmt.Printf(\"data.foo[0] = %d\\n\", n1)\n\n\tn2 := fastjson.GetInt(data, \"foo\", \"2\", \"bar\", \"0\")\n\tfmt.Printf(\"data.foo[2].bar[0] = %d\\n\", n2)\n\n\t// Output:\n\t// data.foo[0] = 233\n\t// data.foo[2].bar[0] = 2343\n}\n\nfunc ExampleExists() {\n\tdata := []byte(`{\"foo\": [1.23,{\"bar\":33,\"baz\":null}]}`)\n\n\tfmt.Printf(\"exists(data.foo) = %v\\n\", fastjson.Exists(data, \"foo\"))\n\tfmt.Printf(\"exists(data.foo[0]) = %v\\n\", fastjson.Exists(data, \"foo\", \"0\"))\n\tfmt.Printf(\"exists(data.foo[1].baz) = %v\\n\", fastjson.Exists(data, \"foo\", \"1\", \"baz\"))\n\tfmt.Printf(\"exists(data.foobar) = %v\\n\", fastjson.Exists(data, \"foobar\"))\n\tfmt.Printf(\"exists(data.foo.bar) = %v\\n\", fastjson.Exists(data, \"foo\", \"bar\"))\n\n\t// Output:\n\t// exists(data.foo) = true\n\t// exists(data.foo[0]) = true\n\t// exists(data.foo[1].baz) = true\n\t// exists(data.foobar) = false\n\t// exists(data.foo.bar) = false\n}\n"
        },
        {
          "name": "handy_test.go",
          "type": "blob",
          "size": 5.837890625,
          "content": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestGetStringConcurrent(t *testing.T) {\n\tconst concurrency = 4\n\tdata := []byte(largeFixture)\n\n\tch := make(chan error, concurrency)\n\n\tfor i := 0; i < concurrency; i++ {\n\t\tgo func() {\n\t\t\ts := GetString(data, \"non-existing-key\")\n\t\t\tif s != \"\" {\n\t\t\t\tch <- fmt.Errorf(\"unexpected non-empty string got: %q\", s)\n\t\t\t}\n\t\t\tch <- nil\n\t\t}()\n\t}\n\n\tfor i := 0; i < concurrency; i++ {\n\t\tselect {\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"timeout\")\n\t\tcase err := <-ch:\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestGetBytesConcurrent(t *testing.T) {\n\tconst concurrency = 4\n\tdata := []byte(largeFixture)\n\n\tch := make(chan error, concurrency)\n\n\tfor i := 0; i < concurrency; i++ {\n\t\tgo func() {\n\t\t\tb := GetBytes(data, \"non-existing-key\")\n\t\t\tif b != nil {\n\t\t\t\tch <- fmt.Errorf(\"unexpected non-empty string got: %q\", b)\n\t\t\t}\n\t\t\tch <- nil\n\t\t}()\n\t}\n\n\tfor i := 0; i < concurrency; i++ {\n\t\tselect {\n\t\tcase <-time.After(time.Second * 5):\n\t\t\tt.Fatalf(\"timeout\")\n\t\tcase err := <-ch:\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestGetString(t *testing.T) {\n\tdata := []byte(`{\"foo\":\"bar\", \"baz\": 1234}`)\n\n\t// normal path\n\ts := GetString(data, \"foo\")\n\tif s != \"bar\" {\n\t\tt.Fatalf(\"unexpected value obtained; got %q; want %q\", s, \"bar\")\n\t}\n\n\t// non-existing path\n\ts = GetString(data, \"foo\", \"zzz\")\n\tif s != \"\" {\n\t\tt.Fatalf(\"unexpected non-empty value obtained: %q\", s)\n\t}\n\n\t// invalid type\n\ts = GetString(data, \"baz\")\n\tif s != \"\" {\n\t\tt.Fatalf(\"unexpected non-empty value obtained: %q\", s)\n\t}\n\n\t// invalid json\n\ts = GetString([]byte(\"invalid json\"), \"foobar\", \"baz\")\n\tif s != \"\" {\n\t\tt.Fatalf(\"unexpected non-empty value obtained: %q\", s)\n\t}\n}\n\nfunc TestGetBytes(t *testing.T) {\n\tdata := []byte(`{\"foo\":\"bar\", \"baz\": 1234}`)\n\n\t// normal path\n\tb := GetBytes(data, \"foo\")\n\tif string(b) != \"bar\" {\n\t\tt.Fatalf(\"unexpected value obtained; got %q; want %q\", b, \"bar\")\n\t}\n\n\t// non-existing path\n\tb = GetBytes(data, \"foo\", \"zzz\")\n\tif b != nil {\n\t\tt.Fatalf(\"unexpected non-empty value obtained: %q\", b)\n\t}\n\n\t// invalid type\n\tb = GetBytes(data, \"baz\")\n\tif b != nil {\n\t\tt.Fatalf(\"unexpected non-empty value obtained: %q\", b)\n\t}\n\n\t// invalid json\n\tb = GetBytes([]byte(\"invalid json\"), \"foobar\", \"baz\")\n\tif b != nil {\n\t\tt.Fatalf(\"unexpected non-empty value obtained: %q\", b)\n\t}\n}\n\nfunc TestGetInt(t *testing.T) {\n\tdata := []byte(`{\"foo\":\"bar\", \"baz\": 1234}`)\n\n\t// normal path\n\tn := GetInt(data, \"baz\")\n\tif n != 1234 {\n\t\tt.Fatalf(\"unexpected value obtained; got %d; want %d\", n, 1234)\n\t}\n\n\t// non-existing path\n\tn = GetInt(data, \"foo\", \"zzz\")\n\tif n != 0 {\n\t\tt.Fatalf(\"unexpected non-zero value obtained: %d\", n)\n\t}\n\n\t// invalid type\n\tn = GetInt(data, \"foo\")\n\tif n != 0 {\n\t\tt.Fatalf(\"unexpected non-zero value obtained: %d\", n)\n\t}\n\n\t// invalid json\n\tn = GetInt([]byte(\"invalid json\"), \"foobar\", \"baz\")\n\tif n != 0 {\n\t\tt.Fatalf(\"unexpected non-empty value obtained: %d\", n)\n\t}\n}\n\nfunc TestGetFloat64(t *testing.T) {\n\tdata := []byte(`{\"foo\":\"bar\", \"baz\": 12.34}`)\n\n\t// normal path\n\tf := GetFloat64(data, \"baz\")\n\tif f != 12.34 {\n\t\tt.Fatalf(\"unexpected value obtained; got %f; want %f\", f, 12.34)\n\t}\n\n\t// non-existing path\n\tf = GetFloat64(data, \"foo\", \"zzz\")\n\tif f != 0 {\n\t\tt.Fatalf(\"unexpected non-zero value obtained: %f\", f)\n\t}\n\n\t// invalid type\n\tf = GetFloat64(data, \"foo\")\n\tif f != 0 {\n\t\tt.Fatalf(\"unexpected non-zero value obtained: %f\", f)\n\t}\n\n\t// invalid json\n\tf = GetFloat64([]byte(\"invalid json\"), \"foobar\", \"baz\")\n\tif f != 0 {\n\t\tt.Fatalf(\"unexpected non-empty value obtained: %f\", f)\n\t}\n}\n\nfunc TestGetBool(t *testing.T) {\n\tdata := []byte(`{\"foo\":\"bar\", \"baz\": true}`)\n\n\t// normal path\n\tb := GetBool(data, \"baz\")\n\tif !b {\n\t\tt.Fatalf(\"unexpected value obtained; got %v; want %v\", b, true)\n\t}\n\n\t// non-existing path\n\tb = GetBool(data, \"foo\", \"zzz\")\n\tif b {\n\t\tt.Fatalf(\"unexpected true value obtained\")\n\t}\n\n\t// invalid type\n\tb = GetBool(data, \"foo\")\n\tif b {\n\t\tt.Fatalf(\"unexpected true value obtained\")\n\t}\n\n\t// invalid json\n\tb = GetBool([]byte(\"invalid json\"), \"foobar\", \"baz\")\n\tif b {\n\t\tt.Fatalf(\"unexpected true value obtained\")\n\t}\n}\n\nfunc TestExists(t *testing.T) {\n\tdata := []byte(`{\"foo\": [{\"bar\": 1234, \"baz\": 0}]}`)\n\n\tif !Exists(data, \"foo\") {\n\t\tt.Fatalf(\"cannot find foo\")\n\t}\n\tif !Exists(data, \"foo\", \"0\") {\n\t\tt.Fatalf(\"cannot find foo[0]\")\n\t}\n\tif !Exists(data, \"foo\", \"0\", \"baz\") {\n\t\tt.Fatalf(\"cannot find foo[0].baz\")\n\t}\n\n\tif Exists(data, \"foobar\") {\n\t\tt.Fatalf(\"found unexpected foobar\")\n\t}\n\tif Exists(data, \"foo\", \"1\") {\n\t\tt.Fatalf(\"found unexpected foo[1]\")\n\t}\n\tif Exists(data, \"foo\", \"0\", \"234\") {\n\t\tt.Fatalf(\"found unexpected foo[0][234]\")\n\t}\n\tif Exists(data, \"foo\", \"bar\") {\n\t\tt.Fatalf(\"found unexpected foo.bar\")\n\t}\n\n\tif Exists([]byte(`invalid JSON`), \"foo\", \"bar\") {\n\t\tt.Fatalf(\"Exists returned true on invalid json\")\n\t}\n}\n\nfunc TestParse(t *testing.T) {\n\tv, err := Parse(`{\"foo\": \"bar\"}`)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tstr := v.String()\n\tif str != `{\"foo\":\"bar\"}` {\n\t\tt.Fatalf(\"unexpected value parsed: %q; want %q\", str, `{\"foo\":\"bar\"}`)\n\t}\n}\n\nfunc TestParseBytes(t *testing.T) {\n\tv, err := ParseBytes([]byte(`{\"foo\": \"bar\"}`))\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tstr := v.String()\n\tif str != `{\"foo\":\"bar\"}` {\n\t\tt.Fatalf(\"unexpected value parsed: %q; want %q\", str, `{\"foo\":\"bar\"}`)\n\t}\n}\n\nfunc TestMustParse(t *testing.T) {\n\ts := `{\"foo\":\"bar\"}`\n\tv := MustParse(s)\n\tstr := v.String()\n\tif str != s {\n\t\tt.Fatalf(\"unexpected value parsed; %q; want %q\", str, s)\n\t}\n\n\tv = MustParseBytes([]byte(s))\n\tif str != s {\n\t\tt.Fatalf(\"unexpected value parsed; %q; want %q\", str, s)\n\t}\n\n\tif !causesPanic(func() { v = MustParse(`[`) }) {\n\t\tt.Fatalf(\"expected MustParse to panic\")\n\t}\n\n\tif !causesPanic(func() { v = MustParseBytes([]byte(`[`)) }) {\n\t\tt.Fatalf(\"expected MustParse to panic\")\n\t}\n}\n\nfunc causesPanic(fn func()) (p bool) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tp = true\n\t\t}\n\t}()\n\tfn()\n\treturn\n}\n"
        },
        {
          "name": "parser.go",
          "type": "blob",
          "size": 21.916015625,
          "content": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"github.com/valyala/fastjson/fastfloat\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf16\"\n)\n\n// Parser parses JSON.\n//\n// Parser may be re-used for subsequent parsing.\n//\n// Parser cannot be used from concurrent goroutines.\n// Use per-goroutine parsers or ParserPool instead.\ntype Parser struct {\n\t// b contains working copy of the string to be parsed.\n\tb []byte\n\n\t// c is a cache for json values.\n\tc cache\n}\n\n// Parse parses s containing JSON.\n//\n// The returned value is valid until the next call to Parse*.\n//\n// Use Scanner if a stream of JSON values must be parsed.\nfunc (p *Parser) Parse(s string) (*Value, error) {\n\ts = skipWS(s)\n\tp.b = append(p.b[:0], s...)\n\tp.c.reset()\n\n\tv, tail, err := parseValue(b2s(p.b), &p.c, 0)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot parse JSON: %s; unparsed tail: %q\", err, startEndString(tail))\n\t}\n\ttail = skipWS(tail)\n\tif len(tail) > 0 {\n\t\treturn nil, fmt.Errorf(\"unexpected tail: %q\", startEndString(tail))\n\t}\n\treturn v, nil\n}\n\n// ParseBytes parses b containing JSON.\n//\n// The returned Value is valid until the next call to Parse*.\n//\n// Use Scanner if a stream of JSON values must be parsed.\nfunc (p *Parser) ParseBytes(b []byte) (*Value, error) {\n\treturn p.Parse(b2s(b))\n}\n\ntype cache struct {\n\tvs []Value\n}\n\nfunc (c *cache) reset() {\n\tc.vs = c.vs[:0]\n}\n\nfunc (c *cache) getValue() *Value {\n\tif cap(c.vs) > len(c.vs) {\n\t\tc.vs = c.vs[:len(c.vs)+1]\n\t} else {\n\t\tc.vs = append(c.vs, Value{})\n\t}\n\t// Do not reset the value, since the caller must properly init it.\n\treturn &c.vs[len(c.vs)-1]\n}\n\nfunc skipWS(s string) string {\n\tif len(s) == 0 || s[0] > 0x20 {\n\t\t// Fast path.\n\t\treturn s\n\t}\n\treturn skipWSSlow(s)\n}\n\nfunc skipWSSlow(s string) string {\n\tif len(s) == 0 || s[0] != 0x20 && s[0] != 0x0A && s[0] != 0x09 && s[0] != 0x0D {\n\t\treturn s\n\t}\n\tfor i := 1; i < len(s); i++ {\n\t\tif s[i] != 0x20 && s[i] != 0x0A && s[i] != 0x09 && s[i] != 0x0D {\n\t\t\treturn s[i:]\n\t\t}\n\t}\n\treturn \"\"\n}\n\ntype kv struct {\n\tk string\n\tv *Value\n}\n\n// MaxDepth is the maximum depth for nested JSON.\nconst MaxDepth = 300\n\nfunc parseValue(s string, c *cache, depth int) (*Value, string, error) {\n\tif len(s) == 0 {\n\t\treturn nil, s, fmt.Errorf(\"cannot parse empty string\")\n\t}\n\tdepth++\n\tif depth > MaxDepth {\n\t\treturn nil, s, fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)\n\t}\n\n\tif s[0] == '{' {\n\t\tv, tail, err := parseObject(s[1:], c, depth)\n\t\tif err != nil {\n\t\t\treturn nil, tail, fmt.Errorf(\"cannot parse object: %s\", err)\n\t\t}\n\t\treturn v, tail, nil\n\t}\n\tif s[0] == '[' {\n\t\tv, tail, err := parseArray(s[1:], c, depth)\n\t\tif err != nil {\n\t\t\treturn nil, tail, fmt.Errorf(\"cannot parse array: %s\", err)\n\t\t}\n\t\treturn v, tail, nil\n\t}\n\tif s[0] == '\"' {\n\t\tss, tail, err := parseRawString(s[1:])\n\t\tif err != nil {\n\t\t\treturn nil, tail, fmt.Errorf(\"cannot parse string: %s\", err)\n\t\t}\n\t\tv := c.getValue()\n\t\tv.t = typeRawString\n\t\tv.s = ss\n\t\treturn v, tail, nil\n\t}\n\tif s[0] == 't' {\n\t\tif len(s) < len(\"true\") || s[:len(\"true\")] != \"true\" {\n\t\t\treturn nil, s, fmt.Errorf(\"unexpected value found: %q\", s)\n\t\t}\n\t\treturn valueTrue, s[len(\"true\"):], nil\n\t}\n\tif s[0] == 'f' {\n\t\tif len(s) < len(\"false\") || s[:len(\"false\")] != \"false\" {\n\t\t\treturn nil, s, fmt.Errorf(\"unexpected value found: %q\", s)\n\t\t}\n\t\treturn valueFalse, s[len(\"false\"):], nil\n\t}\n\tif s[0] == 'n' {\n\t\tif len(s) < len(\"null\") || s[:len(\"null\")] != \"null\" {\n\t\t\t// Try parsing NaN\n\t\t\tif len(s) >= 3 && strings.EqualFold(s[:3], \"nan\") {\n\t\t\t\tv := c.getValue()\n\t\t\t\tv.t = TypeNumber\n\t\t\t\tv.s = s[:3]\n\t\t\t\treturn v, s[3:], nil\n\t\t\t}\n\t\t\treturn nil, s, fmt.Errorf(\"unexpected value found: %q\", s)\n\t\t}\n\t\treturn valueNull, s[len(\"null\"):], nil\n\t}\n\n\tns, tail, err := parseRawNumber(s)\n\tif err != nil {\n\t\treturn nil, tail, fmt.Errorf(\"cannot parse number: %s\", err)\n\t}\n\tv := c.getValue()\n\tv.t = TypeNumber\n\tv.s = ns\n\treturn v, tail, nil\n}\n\nfunc parseArray(s string, c *cache, depth int) (*Value, string, error) {\n\ts = skipWS(s)\n\tif len(s) == 0 {\n\t\treturn nil, s, fmt.Errorf(\"missing ']'\")\n\t}\n\n\tif s[0] == ']' {\n\t\tv := c.getValue()\n\t\tv.t = TypeArray\n\t\tv.a = v.a[:0]\n\t\treturn v, s[1:], nil\n\t}\n\n\ta := c.getValue()\n\ta.t = TypeArray\n\ta.a = a.a[:0]\n\tfor {\n\t\tvar v *Value\n\t\tvar err error\n\n\t\ts = skipWS(s)\n\t\tv, s, err = parseValue(s, c, depth)\n\t\tif err != nil {\n\t\t\treturn nil, s, fmt.Errorf(\"cannot parse array value: %s\", err)\n\t\t}\n\t\ta.a = append(a.a, v)\n\n\t\ts = skipWS(s)\n\t\tif len(s) == 0 {\n\t\t\treturn nil, s, fmt.Errorf(\"unexpected end of array\")\n\t\t}\n\t\tif s[0] == ',' {\n\t\t\ts = s[1:]\n\t\t\tcontinue\n\t\t}\n\t\tif s[0] == ']' {\n\t\t\ts = s[1:]\n\t\t\treturn a, s, nil\n\t\t}\n\t\treturn nil, s, fmt.Errorf(\"missing ',' after array value\")\n\t}\n}\n\nfunc parseObject(s string, c *cache, depth int) (*Value, string, error) {\n\ts = skipWS(s)\n\tif len(s) == 0 {\n\t\treturn nil, s, fmt.Errorf(\"missing '}'\")\n\t}\n\n\tif s[0] == '}' {\n\t\tv := c.getValue()\n\t\tv.t = TypeObject\n\t\tv.o.reset()\n\t\treturn v, s[1:], nil\n\t}\n\n\to := c.getValue()\n\to.t = TypeObject\n\to.o.reset()\n\tfor {\n\t\tvar err error\n\t\tkv := o.o.getKV()\n\n\t\t// Parse key.\n\t\ts = skipWS(s)\n\t\tif len(s) == 0 || s[0] != '\"' {\n\t\t\treturn nil, s, fmt.Errorf(`cannot find opening '\"\" for object key`)\n\t\t}\n\t\tkv.k, s, err = parseRawKey(s[1:])\n\t\tif err != nil {\n\t\t\treturn nil, s, fmt.Errorf(\"cannot parse object key: %s\", err)\n\t\t}\n\t\ts = skipWS(s)\n\t\tif len(s) == 0 || s[0] != ':' {\n\t\t\treturn nil, s, fmt.Errorf(\"missing ':' after object key\")\n\t\t}\n\t\ts = s[1:]\n\n\t\t// Parse value\n\t\ts = skipWS(s)\n\t\tkv.v, s, err = parseValue(s, c, depth)\n\t\tif err != nil {\n\t\t\treturn nil, s, fmt.Errorf(\"cannot parse object value: %s\", err)\n\t\t}\n\t\ts = skipWS(s)\n\t\tif len(s) == 0 {\n\t\t\treturn nil, s, fmt.Errorf(\"unexpected end of object\")\n\t\t}\n\t\tif s[0] == ',' {\n\t\t\ts = s[1:]\n\t\t\tcontinue\n\t\t}\n\t\tif s[0] == '}' {\n\t\t\treturn o, s[1:], nil\n\t\t}\n\t\treturn nil, s, fmt.Errorf(\"missing ',' after object value\")\n\t}\n}\n\nfunc escapeString(dst []byte, s string) []byte {\n\tif !hasSpecialChars(s) {\n\t\t// Fast path - nothing to escape.\n\t\tdst = append(dst, '\"')\n\t\tdst = append(dst, s...)\n\t\tdst = append(dst, '\"')\n\t\treturn dst\n\t}\n\n\t// Slow path.\n\treturn strconv.AppendQuote(dst, s)\n}\n\nfunc hasSpecialChars(s string) bool {\n\tif strings.IndexByte(s, '\"') >= 0 || strings.IndexByte(s, '\\\\') >= 0 {\n\t\treturn true\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] < 0x20 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc unescapeStringBestEffort(s string) string {\n\tn := strings.IndexByte(s, '\\\\')\n\tif n < 0 {\n\t\t// Fast path - nothing to unescape.\n\t\treturn s\n\t}\n\n\t// Slow path - unescape string.\n\tb := s2b(s) // It is safe to do, since s points to a byte slice in Parser.b.\n\tb = b[:n]\n\ts = s[n+1:]\n\tfor len(s) > 0 {\n\t\tch := s[0]\n\t\ts = s[1:]\n\t\tswitch ch {\n\t\tcase '\"':\n\t\t\tb = append(b, '\"')\n\t\tcase '\\\\':\n\t\t\tb = append(b, '\\\\')\n\t\tcase '/':\n\t\t\tb = append(b, '/')\n\t\tcase 'b':\n\t\t\tb = append(b, '\\b')\n\t\tcase 'f':\n\t\t\tb = append(b, '\\f')\n\t\tcase 'n':\n\t\t\tb = append(b, '\\n')\n\t\tcase 'r':\n\t\t\tb = append(b, '\\r')\n\t\tcase 't':\n\t\t\tb = append(b, '\\t')\n\t\tcase 'u':\n\t\t\tif len(s) < 4 {\n\t\t\t\t// Too short escape sequence. Just store it unchanged.\n\t\t\t\tb = append(b, \"\\\\u\"...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\txs := s[:4]\n\t\t\tx, err := strconv.ParseUint(xs, 16, 16)\n\t\t\tif err != nil {\n\t\t\t\t// Invalid escape sequence. Just store it unchanged.\n\t\t\t\tb = append(b, \"\\\\u\"...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts = s[4:]\n\t\t\tif !utf16.IsSurrogate(rune(x)) {\n\t\t\t\tb = append(b, string(rune(x))...)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Surrogate.\n\t\t\t// See https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n\t\t\tif len(s) < 6 || s[0] != '\\\\' || s[1] != 'u' {\n\t\t\t\tb = append(b, \"\\\\u\"...)\n\t\t\t\tb = append(b, xs...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tx1, err := strconv.ParseUint(s[2:6], 16, 16)\n\t\t\tif err != nil {\n\t\t\t\tb = append(b, \"\\\\u\"...)\n\t\t\t\tb = append(b, xs...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tr := utf16.DecodeRune(rune(x), rune(x1))\n\t\t\tb = append(b, string(r)...)\n\t\t\ts = s[6:]\n\t\tdefault:\n\t\t\t// Unknown escape sequence. Just store it unchanged.\n\t\t\tb = append(b, '\\\\', ch)\n\t\t}\n\t\tn = strings.IndexByte(s, '\\\\')\n\t\tif n < 0 {\n\t\t\tb = append(b, s...)\n\t\t\tbreak\n\t\t}\n\t\tb = append(b, s[:n]...)\n\t\ts = s[n+1:]\n\t}\n\treturn b2s(b)\n}\n\n// parseRawKey is similar to parseRawString, but is optimized\n// for small-sized keys without escape sequences.\nfunc parseRawKey(s string) (string, string, error) {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == '\"' {\n\t\t\t// Fast path.\n\t\t\treturn s[:i], s[i+1:], nil\n\t\t}\n\t\tif s[i] == '\\\\' {\n\t\t\t// Slow path.\n\t\t\treturn parseRawString(s)\n\t\t}\n\t}\n\treturn s, \"\", fmt.Errorf(`missing closing '\"'`)\n}\n\nfunc parseRawString(s string) (string, string, error) {\n\tn := strings.IndexByte(s, '\"')\n\tif n < 0 {\n\t\treturn s, \"\", fmt.Errorf(`missing closing '\"'`)\n\t}\n\tif n == 0 || s[n-1] != '\\\\' {\n\t\t// Fast path. No escaped \".\n\t\treturn s[:n], s[n+1:], nil\n\t}\n\n\t// Slow path - possible escaped \" found.\n\tss := s\n\tfor {\n\t\ti := n - 1\n\t\tfor i > 0 && s[i-1] == '\\\\' {\n\t\t\ti--\n\t\t}\n\t\tif uint(n-i)%2 == 0 {\n\t\t\treturn ss[:len(ss)-len(s)+n], s[n+1:], nil\n\t\t}\n\t\ts = s[n+1:]\n\n\t\tn = strings.IndexByte(s, '\"')\n\t\tif n < 0 {\n\t\t\treturn ss, \"\", fmt.Errorf(`missing closing '\"'`)\n\t\t}\n\t\tif n == 0 || s[n-1] != '\\\\' {\n\t\t\treturn ss[:len(ss)-len(s)+n], s[n+1:], nil\n\t\t}\n\t}\n}\n\nfunc parseRawNumber(s string) (string, string, error) {\n\t// The caller must ensure len(s) > 0\n\n\t// Find the end of the number.\n\tfor i := 0; i < len(s); i++ {\n\t\tch := s[i]\n\t\tif (ch >= '0' && ch <= '9') || ch == '.' || ch == '-' || ch == 'e' || ch == 'E' || ch == '+' {\n\t\t\tcontinue\n\t\t}\n\t\tif i == 0 || i == 1 && (s[0] == '-' || s[0] == '+') {\n\t\t\tif len(s[i:]) >= 3 {\n\t\t\t\txs := s[i : i+3]\n\t\t\t\tif strings.EqualFold(xs, \"inf\") || strings.EqualFold(xs, \"nan\") {\n\t\t\t\t\treturn s[:i+3], s[i+3:], nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"\", s, fmt.Errorf(\"unexpected char: %q\", s[:1])\n\t\t}\n\t\tns := s[:i]\n\t\ts = s[i:]\n\t\treturn ns, s, nil\n\t}\n\treturn s, \"\", nil\n}\n\n// Object represents JSON object.\n//\n// Object cannot be used from concurrent goroutines.\n// Use per-goroutine parsers or ParserPool instead.\ntype Object struct {\n\tkvs           []kv\n\tkeysUnescaped bool\n}\n\nfunc (o *Object) reset() {\n\to.kvs = o.kvs[:0]\n\to.keysUnescaped = false\n}\n\n// MarshalTo appends marshaled o to dst and returns the result.\nfunc (o *Object) MarshalTo(dst []byte) []byte {\n\tdst = append(dst, '{')\n\tfor i, kv := range o.kvs {\n\t\tif o.keysUnescaped {\n\t\t\tdst = escapeString(dst, kv.k)\n\t\t} else {\n\t\t\tdst = append(dst, '\"')\n\t\t\tdst = append(dst, kv.k...)\n\t\t\tdst = append(dst, '\"')\n\t\t}\n\t\tdst = append(dst, ':')\n\t\tdst = kv.v.MarshalTo(dst)\n\t\tif i != len(o.kvs)-1 {\n\t\t\tdst = append(dst, ',')\n\t\t}\n\t}\n\tdst = append(dst, '}')\n\treturn dst\n}\n\n// String returns string representation for the o.\n//\n// This function is for debugging purposes only. It isn't optimized for speed.\n// See MarshalTo instead.\nfunc (o *Object) String() string {\n\tb := o.MarshalTo(nil)\n\t// It is safe converting b to string without allocation, since b is no longer\n\t// reachable after this line.\n\treturn b2s(b)\n}\n\nfunc (o *Object) getKV() *kv {\n\tif cap(o.kvs) > len(o.kvs) {\n\t\to.kvs = o.kvs[:len(o.kvs)+1]\n\t} else {\n\t\to.kvs = append(o.kvs, kv{})\n\t}\n\treturn &o.kvs[len(o.kvs)-1]\n}\n\nfunc (o *Object) unescapeKeys() {\n\tif o.keysUnescaped {\n\t\treturn\n\t}\n\tkvs := o.kvs\n\tfor i := range kvs {\n\t\tkv := &kvs[i]\n\t\tkv.k = unescapeStringBestEffort(kv.k)\n\t}\n\to.keysUnescaped = true\n}\n\n// Len returns the number of items in the o.\nfunc (o *Object) Len() int {\n\treturn len(o.kvs)\n}\n\n// Get returns the value for the given key in the o.\n//\n// Returns nil if the value for the given key isn't found.\n//\n// The returned value is valid until Parse is called on the Parser returned o.\nfunc (o *Object) Get(key string) *Value {\n\tif !o.keysUnescaped && strings.IndexByte(key, '\\\\') < 0 {\n\t\t// Fast path - try searching for the key without object keys unescaping.\n\t\tfor _, kv := range o.kvs {\n\t\t\tif kv.k == key {\n\t\t\t\treturn kv.v\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slow path - unescape object keys.\n\to.unescapeKeys()\n\n\tfor _, kv := range o.kvs {\n\t\tif kv.k == key {\n\t\t\treturn kv.v\n\t\t}\n\t}\n\treturn nil\n}\n\n// Visit calls f for each item in the o in the original order\n// of the parsed JSON.\n//\n// f cannot hold key and/or v after returning.\nfunc (o *Object) Visit(f func(key []byte, v *Value)) {\n\tif o == nil {\n\t\treturn\n\t}\n\n\to.unescapeKeys()\n\n\tfor _, kv := range o.kvs {\n\t\tf(s2b(kv.k), kv.v)\n\t}\n}\n\n// Value represents any JSON value.\n//\n// Call Type in order to determine the actual type of the JSON value.\n//\n// Value cannot be used from concurrent goroutines.\n// Use per-goroutine parsers or ParserPool instead.\ntype Value struct {\n\to Object\n\ta []*Value\n\ts string\n\tt Type\n}\n\n// MarshalTo appends marshaled v to dst and returns the result.\nfunc (v *Value) MarshalTo(dst []byte) []byte {\n\tswitch v.t {\n\tcase typeRawString:\n\t\tdst = append(dst, '\"')\n\t\tdst = append(dst, v.s...)\n\t\tdst = append(dst, '\"')\n\t\treturn dst\n\tcase TypeObject:\n\t\treturn v.o.MarshalTo(dst)\n\tcase TypeArray:\n\t\tdst = append(dst, '[')\n\t\tfor i, vv := range v.a {\n\t\t\tdst = vv.MarshalTo(dst)\n\t\t\tif i != len(v.a)-1 {\n\t\t\t\tdst = append(dst, ',')\n\t\t\t}\n\t\t}\n\t\tdst = append(dst, ']')\n\t\treturn dst\n\tcase TypeString:\n\t\treturn escapeString(dst, v.s)\n\tcase TypeNumber:\n\t\treturn append(dst, v.s...)\n\tcase TypeTrue:\n\t\treturn append(dst, \"true\"...)\n\tcase TypeFalse:\n\t\treturn append(dst, \"false\"...)\n\tcase TypeNull:\n\t\treturn append(dst, \"null\"...)\n\tdefault:\n\t\tpanic(fmt.Errorf(\"BUG: unexpected Value type: %d\", v.t))\n\t}\n}\n\n// String returns string representation of the v.\n//\n// The function is for debugging purposes only. It isn't optimized for speed.\n// See MarshalTo instead.\n//\n// Don't confuse this function with StringBytes, which must be called\n// for obtaining the underlying JSON string for the v.\nfunc (v *Value) String() string {\n\tb := v.MarshalTo(nil)\n\t// It is safe converting b to string without allocation, since b is no longer\n\t// reachable after this line.\n\treturn b2s(b)\n}\n\n// Type represents JSON type.\ntype Type int\n\nconst (\n\t// TypeNull is JSON null.\n\tTypeNull Type = 0\n\n\t// TypeObject is JSON object type.\n\tTypeObject Type = 1\n\n\t// TypeArray is JSON array type.\n\tTypeArray Type = 2\n\n\t// TypeString is JSON string type.\n\tTypeString Type = 3\n\n\t// TypeNumber is JSON number type.\n\tTypeNumber Type = 4\n\n\t// TypeTrue is JSON true.\n\tTypeTrue Type = 5\n\n\t// TypeFalse is JSON false.\n\tTypeFalse Type = 6\n\n\ttypeRawString Type = 7\n)\n\n// String returns string representation of t.\nfunc (t Type) String() string {\n\tswitch t {\n\tcase TypeObject:\n\t\treturn \"object\"\n\tcase TypeArray:\n\t\treturn \"array\"\n\tcase TypeString:\n\t\treturn \"string\"\n\tcase TypeNumber:\n\t\treturn \"number\"\n\tcase TypeTrue:\n\t\treturn \"true\"\n\tcase TypeFalse:\n\t\treturn \"false\"\n\tcase TypeNull:\n\t\treturn \"null\"\n\n\t// typeRawString is skipped intentionally,\n\t// since it shouldn't be visible to user.\n\tdefault:\n\t\tpanic(fmt.Errorf(\"BUG: unknown Value type: %d\", t))\n\t}\n}\n\n// Type returns the type of the v.\nfunc (v *Value) Type() Type {\n\tif v.t == typeRawString {\n\t\tv.s = unescapeStringBestEffort(v.s)\n\t\tv.t = TypeString\n\t}\n\treturn v.t\n}\n\n// Exists returns true if the field exists for the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\nfunc (v *Value) Exists(keys ...string) bool {\n\tv = v.Get(keys...)\n\treturn v != nil\n}\n\n// Get returns value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// nil is returned for non-existing keys path.\n//\n// The returned value is valid until Parse is called on the Parser returned v.\nfunc (v *Value) Get(keys ...string) *Value {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tfor _, key := range keys {\n\t\tif v.t == TypeObject {\n\t\t\tv = v.o.Get(key)\n\t\t\tif v == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t} else if v.t == TypeArray {\n\t\t\tn, err := strconv.Atoi(key)\n\t\t\tif err != nil || n < 0 || n >= len(v.a) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tv = v.a[n]\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn v\n}\n\n// GetObject returns object value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// nil is returned for non-existing keys path or for invalid value type.\n//\n// The returned object is valid until Parse is called on the Parser returned v.\nfunc (v *Value) GetObject(keys ...string) *Object {\n\tv = v.Get(keys...)\n\tif v == nil || v.t != TypeObject {\n\t\treturn nil\n\t}\n\treturn &v.o\n}\n\n// GetArray returns array value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// nil is returned for non-existing keys path or for invalid value type.\n//\n// The returned array is valid until Parse is called on the Parser returned v.\nfunc (v *Value) GetArray(keys ...string) []*Value {\n\tv = v.Get(keys...)\n\tif v == nil || v.t != TypeArray {\n\t\treturn nil\n\t}\n\treturn v.a\n}\n\n// GetFloat64 returns float64 value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// 0 is returned for non-existing keys path or for invalid value type.\nfunc (v *Value) GetFloat64(keys ...string) float64 {\n\tv = v.Get(keys...)\n\tif v == nil || v.Type() != TypeNumber {\n\t\treturn 0\n\t}\n\treturn fastfloat.ParseBestEffort(v.s)\n}\n\n// GetInt returns int value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// 0 is returned for non-existing keys path or for invalid value type.\nfunc (v *Value) GetInt(keys ...string) int {\n\tv = v.Get(keys...)\n\tif v == nil || v.Type() != TypeNumber {\n\t\treturn 0\n\t}\n\tn := fastfloat.ParseInt64BestEffort(v.s)\n\tnn := int(n)\n\tif int64(nn) != n {\n\t\treturn 0\n\t}\n\treturn nn\n}\n\n// GetUint returns uint value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// 0 is returned for non-existing keys path or for invalid value type.\nfunc (v *Value) GetUint(keys ...string) uint {\n\tv = v.Get(keys...)\n\tif v == nil || v.Type() != TypeNumber {\n\t\treturn 0\n\t}\n\tn := fastfloat.ParseUint64BestEffort(v.s)\n\tnn := uint(n)\n\tif uint64(nn) != n {\n\t\treturn 0\n\t}\n\treturn nn\n}\n\n// GetInt64 returns int64 value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// 0 is returned for non-existing keys path or for invalid value type.\nfunc (v *Value) GetInt64(keys ...string) int64 {\n\tv = v.Get(keys...)\n\tif v == nil || v.Type() != TypeNumber {\n\t\treturn 0\n\t}\n\treturn fastfloat.ParseInt64BestEffort(v.s)\n}\n\n// GetUint64 returns uint64 value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// 0 is returned for non-existing keys path or for invalid value type.\nfunc (v *Value) GetUint64(keys ...string) uint64 {\n\tv = v.Get(keys...)\n\tif v == nil || v.Type() != TypeNumber {\n\t\treturn 0\n\t}\n\treturn fastfloat.ParseUint64BestEffort(v.s)\n}\n\n// GetStringBytes returns string value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// nil is returned for non-existing keys path or for invalid value type.\n//\n// The returned string is valid until Parse is called on the Parser returned v.\nfunc (v *Value) GetStringBytes(keys ...string) []byte {\n\tv = v.Get(keys...)\n\tif v == nil || v.Type() != TypeString {\n\t\treturn nil\n\t}\n\treturn s2b(v.s)\n}\n\n// GetBool returns bool value by the given keys path.\n//\n// Array indexes may be represented as decimal numbers in keys.\n//\n// false is returned for non-existing keys path or for invalid value type.\nfunc (v *Value) GetBool(keys ...string) bool {\n\tv = v.Get(keys...)\n\tif v != nil && v.t == TypeTrue {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Object returns the underlying JSON object for the v.\n//\n// The returned object is valid until Parse is called on the Parser returned v.\n//\n// Use GetObject if you don't need error handling.\nfunc (v *Value) Object() (*Object, error) {\n\tif v.t != TypeObject {\n\t\treturn nil, fmt.Errorf(\"value doesn't contain object; it contains %s\", v.Type())\n\t}\n\treturn &v.o, nil\n}\n\n// Array returns the underlying JSON array for the v.\n//\n// The returned array is valid until Parse is called on the Parser returned v.\n//\n// Use GetArray if you don't need error handling.\nfunc (v *Value) Array() ([]*Value, error) {\n\tif v.t != TypeArray {\n\t\treturn nil, fmt.Errorf(\"value doesn't contain array; it contains %s\", v.Type())\n\t}\n\treturn v.a, nil\n}\n\n// StringBytes returns the underlying JSON string for the v.\n//\n// The returned string is valid until Parse is called on the Parser returned v.\n//\n// Use GetStringBytes if you don't need error handling.\nfunc (v *Value) StringBytes() ([]byte, error) {\n\tif v.Type() != TypeString {\n\t\treturn nil, fmt.Errorf(\"value doesn't contain string; it contains %s\", v.Type())\n\t}\n\treturn s2b(v.s), nil\n}\n\n// Float64 returns the underlying JSON number for the v.\n//\n// Use GetFloat64 if you don't need error handling.\nfunc (v *Value) Float64() (float64, error) {\n\tif v.Type() != TypeNumber {\n\t\treturn 0, fmt.Errorf(\"value doesn't contain number; it contains %s\", v.Type())\n\t}\n\treturn fastfloat.Parse(v.s)\n}\n\n// Int returns the underlying JSON int for the v.\n//\n// Use GetInt if you don't need error handling.\nfunc (v *Value) Int() (int, error) {\n\tif v.Type() != TypeNumber {\n\t\treturn 0, fmt.Errorf(\"value doesn't contain number; it contains %s\", v.Type())\n\t}\n\tn, err := fastfloat.ParseInt64(v.s)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tnn := int(n)\n\tif int64(nn) != n {\n\t\treturn 0, fmt.Errorf(\"number %q doesn't fit int\", v.s)\n\t}\n\treturn nn, nil\n}\n\n// Uint returns the underlying JSON uint for the v.\n//\n// Use GetInt if you don't need error handling.\nfunc (v *Value) Uint() (uint, error) {\n\tif v.Type() != TypeNumber {\n\t\treturn 0, fmt.Errorf(\"value doesn't contain number; it contains %s\", v.Type())\n\t}\n\tn, err := fastfloat.ParseUint64(v.s)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tnn := uint(n)\n\tif uint64(nn) != n {\n\t\treturn 0, fmt.Errorf(\"number %q doesn't fit uint\", v.s)\n\t}\n\treturn nn, nil\n}\n\n// Int64 returns the underlying JSON int64 for the v.\n//\n// Use GetInt64 if you don't need error handling.\nfunc (v *Value) Int64() (int64, error) {\n\tif v.Type() != TypeNumber {\n\t\treturn 0, fmt.Errorf(\"value doesn't contain number; it contains %s\", v.Type())\n\t}\n\treturn fastfloat.ParseInt64(v.s)\n}\n\n// Uint64 returns the underlying JSON uint64 for the v.\n//\n// Use GetInt64 if you don't need error handling.\nfunc (v *Value) Uint64() (uint64, error) {\n\tif v.Type() != TypeNumber {\n\t\treturn 0, fmt.Errorf(\"value doesn't contain number; it contains %s\", v.Type())\n\t}\n\treturn fastfloat.ParseUint64(v.s)\n}\n\n// Bool returns the underlying JSON bool for the v.\n//\n// Use GetBool if you don't need error handling.\nfunc (v *Value) Bool() (bool, error) {\n\tif v.t == TypeTrue {\n\t\treturn true, nil\n\t}\n\tif v.t == TypeFalse {\n\t\treturn false, nil\n\t}\n\treturn false, fmt.Errorf(\"value doesn't contain bool; it contains %s\", v.Type())\n}\n\nvar (\n\tvalueTrue  = &Value{t: TypeTrue}\n\tvalueFalse = &Value{t: TypeFalse}\n\tvalueNull  = &Value{t: TypeNull}\n)\n"
        },
        {
          "name": "parser_example_test.go",
          "type": "blob",
          "size": 4.1376953125,
          "content": "package fastjson_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/valyala/fastjson\"\n\t\"log\"\n\t\"strconv\"\n)\n\nfunc ExampleParser_Parse() {\n\tvar p fastjson.Parser\n\tv, err := p.Parse(`{\"foo\":\"bar\", \"baz\": 123}`)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot parse json: %s\", err)\n\t}\n\n\tfmt.Printf(\"foo=%s, baz=%d\", v.GetStringBytes(\"foo\"), v.GetInt(\"baz\"))\n\n\t// Output:\n\t// foo=bar, baz=123\n}\n\nfunc ExampleParser_Parse_reuse() {\n\tvar p fastjson.Parser\n\n\t// p may be re-used for parsing multiple json strings.\n\t// This improves parsing speed by reducing the number\n\t// of memory allocations.\n\t//\n\t// Parse call invalidates all the objects previously obtained from p,\n\t// so don't hold these objects after parsing the next json.\n\n\tfor i := 0; i < 3; i++ {\n\t\ts := fmt.Sprintf(`[\"foo_%d\",\"bar_%d\",\"%d\"]`, i, i, i)\n\t\tv, err := p.Parse(s)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"cannot parse json: %s\", err)\n\t\t}\n\t\tkey := strconv.Itoa(i)\n\t\tfmt.Printf(\"a[%d]=%s\\n\", i, v.GetStringBytes(key))\n\t}\n\n\t// Output:\n\t// a[0]=foo_0\n\t// a[1]=bar_1\n\t// a[2]=2\n}\n\nfunc ExampleValue_MarshalTo() {\n\ts := `{\n\t\t\"name\": \"John\",\n\t\t\"items\": [\n\t\t\t{\n\t\t\t\t\"key\": \"foo\",\n\t\t\t\t\"value\": 123.456,\n\t\t\t\t\"arr\": [1, \"foo\"]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"key\": \"bar\",\n\t\t\t\t\"field\": [3, 4, 5]\n\t\t\t}\n\t\t]\n\t}`\n\tvar p fastjson.Parser\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot parse json: %s\", err)\n\t}\n\n\t// Marshal items.0 into newly allocated buffer.\n\tbuf := v.Get(\"items\", \"0\").MarshalTo(nil)\n\tfmt.Printf(\"items.0 = %s\\n\", buf)\n\n\t// Re-use buf for marshaling items.1.\n\tbuf = v.Get(\"items\", \"1\").MarshalTo(buf[:0])\n\tfmt.Printf(\"items.1 = %s\\n\", buf)\n\n\t// Output:\n\t// items.0 = {\"key\":\"foo\",\"value\":123.456,\"arr\":[1,\"foo\"]}\n\t// items.1 = {\"key\":\"bar\",\"field\":[3,4,5]}\n}\n\nfunc ExampleValue_Get() {\n\ts := `{\"foo\":[{\"bar\":{\"baz\":123,\"x\":\"434\"},\"y\":[]},[null, false]],\"qwe\":true}`\n\tvar p fastjson.Parser\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot parse json: %s\", err)\n\t}\n\n\tvv := v.Get(\"foo\", \"0\", \"bar\", \"x\")\n\tfmt.Printf(\"foo[0].bar.x=%s\\n\", vv.GetStringBytes())\n\n\tvv = v.Get(\"qwe\")\n\tfmt.Printf(\"qwe=%v\\n\", vv.GetBool())\n\n\tvv = v.Get(\"foo\", \"1\")\n\tfmt.Printf(\"foo[1]=%s\\n\", vv)\n\n\tvv = v.Get(\"foo\").Get(\"1\").Get(\"1\")\n\tfmt.Printf(\"foo[1][1]=%s\\n\", vv)\n\n\t// non-existing key\n\tvv = v.Get(\"foo\").Get(\"bar\").Get(\"baz\", \"1234\")\n\tfmt.Printf(\"foo.bar.baz[1234]=%v\\n\", vv)\n\n\t// Output:\n\t// foo[0].bar.x=434\n\t// qwe=true\n\t// foo[1]=[null,false]\n\t// foo[1][1]=false\n\t// foo.bar.baz[1234]=<nil>\n}\n\nfunc ExampleValue_Type() {\n\ts := `{\n\t\t\"object\": {},\n\t\t\"array\": [],\n\t\t\"string\": \"foobar\",\n\t\t\"number\": 123.456,\n\t\t\"true\": true,\n\t\t\"false\": false,\n\t\t\"null\": null\n\t}`\n\n\tvar p fastjson.Parser\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot parse json: %s\", err)\n\t}\n\n\tfmt.Printf(\"%s\\n\", v.Get(\"object\").Type())\n\tfmt.Printf(\"%s\\n\", v.Get(\"array\").Type())\n\tfmt.Printf(\"%s\\n\", v.Get(\"string\").Type())\n\tfmt.Printf(\"%s\\n\", v.Get(\"number\").Type())\n\tfmt.Printf(\"%s\\n\", v.Get(\"true\").Type())\n\tfmt.Printf(\"%s\\n\", v.Get(\"false\").Type())\n\tfmt.Printf(\"%s\\n\", v.Get(\"null\").Type())\n\n\t// Output:\n\t// object\n\t// array\n\t// string\n\t// number\n\t// true\n\t// false\n\t// null\n}\n\nfunc ExampleObject_Visit() {\n\ts := `{\n\t\t\"obj\": { \"foo\": 1234 },\n\t\t\"arr\": [ 23,4, \"bar\" ],\n\t\t\"str\": \"foobar\"\n\t}`\n\n\tvar p fastjson.Parser\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot parse json: %s\", err)\n\t}\n\to, err := v.Object()\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot obtain object from json value: %s\", err)\n\t}\n\n\to.Visit(func(k []byte, v *fastjson.Value) {\n\t\tswitch string(k) {\n\t\tcase \"obj\":\n\t\t\tfmt.Printf(\"object %s\\n\", v)\n\t\tcase \"arr\":\n\t\t\tfmt.Printf(\"array %s\\n\", v)\n\t\tcase \"str\":\n\t\t\tfmt.Printf(\"string %s\\n\", v)\n\t\t}\n\t})\n\n\t// Output:\n\t// object {\"foo\":1234}\n\t// array [23,4,\"bar\"]\n\t// string \"foobar\"\n}\n\nfunc ExampleValue_GetStringBytes() {\n\ts := `[\n\t\t{\"foo\": \"bar\"},\n\t\t[123, \"baz\"]\n\t]`\n\n\tvar p fastjson.Parser\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot parse json: %s\", err)\n\t}\n\tfmt.Printf(\"v[0].foo = %q\\n\", v.GetStringBytes(\"0\", \"foo\"))\n\tfmt.Printf(\"v[1][1] = %q\\n\", v.GetStringBytes(\"1\", \"1\"))\n\tfmt.Printf(\"v[1][0] = %q\\n\", v.GetStringBytes(\"1\", \"0\"))\n\tfmt.Printf(\"v.foo.bar.baz = %q\\n\", v.GetStringBytes(\"foo\", \"bar\", \"baz\"))\n\n\t// Output:\n\t// v[0].foo = \"bar\"\n\t// v[1][1] = \"baz\"\n\t// v[1][0] = \"\"\n\t// v.foo.bar.baz = \"\"\n}\n"
        },
        {
          "name": "parser_test.go",
          "type": "blob",
          "size": 31.9814453125,
          "content": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tf := func(s, expectedRN, expectedTail string) {\n\t\t\tt.Helper()\n\n\t\t\trn, tail, err := parseRawNumber(s)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t\tif rn != expectedRN {\n\t\t\t\tt.Fatalf(\"unexpected raw number; got %q; want %q\", rn, expectedRN)\n\t\t\t}\n\t\t\tif tail != expectedTail {\n\t\t\t\tt.Fatalf(\"unexpected tail; got %q; want %q\", tail, expectedTail)\n\t\t\t}\n\t\t}\n\n\t\tf(\"0\", \"0\", \"\")\n\t\tf(\"0tail\", \"0\", \"tail\")\n\t\tf(\"123\", \"123\", \"\")\n\t\tf(\"123tail\", \"123\", \"tail\")\n\t\tf(\"-123tail\", \"-123\", \"tail\")\n\t\tf(\"-12.345tail\", \"-12.345\", \"tail\")\n\t\tf(\"-12.345e67tail\", \"-12.345e67\", \"tail\")\n\t\tf(\"-12.345E+67 tail\", \"-12.345E+67\", \" tail\")\n\t\tf(\"-12.345E-67,tail\", \"-12.345E-67\", \",tail\")\n\t\tf(\"-1234567.8e+90tail\", \"-1234567.8e+90\", \"tail\")\n\t\tf(\"12.tail\", \"12.\", \"tail\")\n\t\tf(\".2tail\", \".2\", \"tail\")\n\t\tf(\"-.2tail\", \"-.2\", \"tail\")\n\t\tf(\"NaN\", \"NaN\", \"\")\n\t\tf(\"nantail\", \"nan\", \"tail\")\n\t\tf(\"inf\", \"inf\", \"\")\n\t\tf(\"Inftail\", \"Inf\", \"tail\")\n\t\tf(\"-INF\", \"-INF\", \"\")\n\t\tf(\"-Inftail\", \"-Inf\", \"tail\")\n\t})\n\n\tt.Run(\"error\", func(t *testing.T) {\n\t\tf := func(s, expectedTail string) {\n\t\t\tt.Helper()\n\n\t\t\t_, tail, err := parseRawNumber(s)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"expecting non-nil error\")\n\t\t\t}\n\t\t\tif tail != expectedTail {\n\t\t\t\tt.Fatalf(\"unexpected tail; got %q; want %q\", tail, expectedTail)\n\t\t\t}\n\t\t}\n\n\t\tf(\"xyz\", \"xyz\")\n\t\tf(\" \", \" \")\n\t\tf(\"[\", \"[\")\n\t\tf(\",\", \",\")\n\t\tf(\"{\", \"{\")\n\t\tf(\"\\\"\", \"\\\"\")\n\t})\n}\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\ttestUnescapeStringBestEffort(t, ``, ``)\n\t\ttestUnescapeStringBestEffort(t, `\\\"`, `\"`)\n\t\ttestUnescapeStringBestEffort(t, `\\\\`, `\\`)\n\t\ttestUnescapeStringBestEffort(t, `\\\\\\\"`, `\\\"`)\n\t\ttestUnescapeStringBestEffort(t, `\\\\\\\"`, `\\\"`)\n\t\ttestUnescapeStringBestEffort(t, `\\n\\\"\\\\Y`, \"\\n\\\"\\\\Y\")\n\t\ttestUnescapeStringBestEffort(t, `q\\u1234we`, \"q\\u1234we\")\n\t\ttestUnescapeStringBestEffort(t, `\\ud83e\\udd2d`, \"\")\n\t})\n\n\tt.Run(\"error\", func(t *testing.T) {\n\t\ttestUnescapeStringBestEffort(t, `\\`, ``)\n\t\ttestUnescapeStringBestEffort(t, `foo\\qwe`, `foo\\qwe`)\n\t\ttestUnescapeStringBestEffort(t, `\\\"x\\uyz\\\"`, `\"x\\uyz\"`)\n\t\ttestUnescapeStringBestEffort(t, `\\u12\\\"w`, `\\u12\"w`)\n\t\ttestUnescapeStringBestEffort(t, `\\ud83e`, \"\\\\ud83e\")\n\t})\n}\n\nfunc testUnescapeStringBestEffort(t *testing.T, s, expectedS string) {\n\tt.Helper()\n\n\t// unescapeString modifies the original s, so call it\n\t// on a byte slice copy.\n\tb := append([]byte{}, s...)\n\tus := unescapeStringBestEffort(b2s(b))\n\tif us != expectedS {\n\t\tt.Fatalf(\"unexpected unescaped string; got %q; want %q\", us, expectedS)\n\t}\n}\n\nfunc TestParseRawString(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tf := func(s, expectedRS, expectedTail string) {\n\t\t\tt.Helper()\n\n\t\t\trs, tail, err := parseRawString(s[1:])\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error on parseRawString: %s\", err)\n\t\t\t}\n\t\t\tif rs != expectedRS {\n\t\t\t\tt.Fatalf(\"unexpected string on parseRawString; got %q; want %q\", rs, expectedRS)\n\t\t\t}\n\t\t\tif tail != expectedTail {\n\t\t\t\tt.Fatalf(\"unexpected tail on parseRawString; got %q; want %q\", tail, expectedTail)\n\t\t\t}\n\n\t\t\t// parseRawKey results must be identical to parseRawString.\n\t\t\trs, tail, err = parseRawKey(s[1:])\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error on parseRawKey: %s\", err)\n\t\t\t}\n\t\t\tif rs != expectedRS {\n\t\t\t\tt.Fatalf(\"unexpected string on parseRawKey; got %q; want %q\", rs, expectedRS)\n\t\t\t}\n\t\t\tif tail != expectedTail {\n\t\t\t\tt.Fatalf(\"unexpected tail on parseRawKey; got %q; want %q\", tail, expectedTail)\n\t\t\t}\n\t\t}\n\n\t\tf(`\"\"`, \"\", \"\")\n\t\tf(`\"\"xx`, \"\", \"xx\")\n\t\tf(`\"foobar\"`, \"foobar\", \"\")\n\t\tf(`\"foobar\"baz`, \"foobar\", \"baz\")\n\t\tf(`\"\\\"\"`, `\\\"`, \"\")\n\t\tf(`\"\\\"\"tail`, `\\\"`, \"tail\")\n\t\tf(`\"\\\\\"`, `\\\\`, \"\")\n\t\tf(`\"\\\\\"tail`, `\\\\`, \"tail\")\n\t\tf(`\"x\\\\\"`, `x\\\\`, \"\")\n\t\tf(`\"x\\\\\"tail`, `x\\\\`, \"tail\")\n\t\tf(`\"x\\\\y\"`, `x\\\\y`, \"\")\n\t\tf(`\"x\\\\y\"tail`, `x\\\\y`, \"tail\")\n\t\tf(`\"\\\\\\\"\\n\\\"\"tail`, `\\\\\\\"\\n\\\"`, \"tail\")\n\t\tf(`\"\\\\\\\\\\\\\\\\\"tail`, `\\\\\\\\\\\\\\\\`, \"tail\")\n\n\t})\n\n\tt.Run(\"error\", func(t *testing.T) {\n\t\tf := func(s, expectedTail string) {\n\t\t\tt.Helper()\n\n\t\t\t_, tail, err := parseRawString(s[1:])\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"expecting non-nil error on parseRawString\")\n\t\t\t}\n\t\t\tif tail != expectedTail {\n\t\t\t\tt.Fatalf(\"unexpected tail on parseRawString; got %q; want %q\", tail, expectedTail)\n\t\t\t}\n\n\t\t\t// parseRawKey results must be identical to parseRawString.\n\t\t\t_, tail, err = parseRawKey(s[1:])\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"expecting non-nil error on parseRawKey\")\n\t\t\t}\n\t\t\tif tail != expectedTail {\n\t\t\t\tt.Fatalf(\"unexpected tail on parseRawKey; got %q; want %q\", tail, expectedTail)\n\t\t\t}\n\t\t}\n\n\t\tf(`\"`, \"\")\n\t\tf(`\"unclosed string`, \"\")\n\t\tf(`\"\\\"`, \"\")\n\t\tf(`\"\\\"unclosed`, \"\")\n\t\tf(`\"foo\\\\\\\\\\\"\\n\\r\\t`, \"\")\n\t})\n}\n\nfunc TestParserPool(t *testing.T) {\n\tvar pp ParserPool\n\tfor i := 0; i < 10; i++ {\n\t\tp := pp.Get()\n\t\tif _, err := p.Parse(\"null\"); err != nil {\n\t\t\tt.Fatalf(\"cannot parse null: %s\", err)\n\t\t}\n\t\tpp.Put(p)\n\t}\n}\n\nfunc TestValueInvalidTypeConversion(t *testing.T) {\n\tvar p Parser\n\n\tv, err := p.Parse(`[{},[],\"\",123.45,true,null]`)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\ta := v.GetArray()\n\n\t// object\n\t_, err = a[0].Object()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error when obtaining object: %s\", err)\n\t}\n\t_, err = a[0].Array()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain array from object\")\n\t}\n\n\t// array\n\t_, err = a[1].Array()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error when obtaining array: %s\", err)\n\t}\n\t_, err = a[1].Object()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain object from array\")\n\t}\n\n\t// string\n\t_, err = a[2].StringBytes()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error when obtaining string: %s\", err)\n\t}\n\t_, err = a[2].Int()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain int from string\")\n\t}\n\t_, err = a[2].Int64()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain int64 from string\")\n\t}\n\t_, err = a[2].Uint()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain uint from string\")\n\t}\n\t_, err = a[2].Uint64()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain uint64 from string\")\n\t}\n\t_, err = a[2].Float64()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain float64 from string\")\n\t}\n\n\t// number\n\t_, err = a[3].Float64()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error when obtaining float64: %s\", err)\n\t}\n\t_, err = a[3].StringBytes()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain string from number\")\n\t}\n\n\t// true\n\t_, err = a[4].Bool()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error when obtaining bool: %s\", err)\n\t}\n\t_, err = a[4].StringBytes()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain string from bool\")\n\t}\n\n\t// null\n\t_, err = a[5].Bool()\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error when trying to obtain bool from null\")\n\t}\n}\n\nfunc TestValueGetTyped(t *testing.T) {\n\tvar p Parser\n\n\tv, err := p.Parse(`{\"foo\": 123, \"bar\": \"433\", \"baz\": true, \"obj\":{}, \"arr\":[1,2,3],\n\t\t\"zero_float1\": 0.00,\n\t\t\"zero_float2\": -0e123,\n\t\t\"inf_float\": Inf,\n\t\t\"minus_inf_float\": -Inf,\n\t\t\"nan\": nan\n\t}`)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tif !v.Exists(\"foo\") {\n\t\tt.Fatalf(\"foo must exist in the v\")\n\t}\n\tif v.Exists(\"foo\", \"bar\") {\n\t\tt.Fatalf(\"foo.bar mustn't exist in the v\")\n\t}\n\tif v.Exists(\"foobar\") {\n\t\tt.Fatalf(\"foobar mustn't exist in the v\")\n\t}\n\n\to := v.GetObject(\"obj\")\n\tos := o.String()\n\tif os != \"{}\" {\n\t\tt.Fatalf(\"unexpected object; got %s; want %s\", os, \"{}\")\n\t}\n\to = v.GetObject(\"arr\")\n\tif o != nil {\n\t\tt.Fatalf(\"unexpected non-nil object: %s\", o)\n\t}\n\to = v.GetObject(\"foo\", \"bar\")\n\tif o != nil {\n\t\tt.Fatalf(\"unexpected non-nil object: %s\", o)\n\t}\n\ta := v.GetArray(\"arr\")\n\tif len(a) != 3 {\n\t\tt.Fatalf(\"unexpected array len; got %d; want %d\", len(a), 3)\n\t}\n\ta = v.GetArray(\"obj\")\n\tif a != nil {\n\t\tt.Fatalf(\"unexpected non-nil array: %s\", a)\n\t}\n\ta = v.GetArray(\"foo\", \"bar\")\n\tif a != nil {\n\t\tt.Fatalf(\"unexpected non-nil array: %s\", a)\n\t}\n\tn := v.GetInt(\"foo\")\n\tif n != 123 {\n\t\tt.Fatalf(\"unexpected value; got %d; want %d\", n, 123)\n\t}\n\tn64 := v.GetInt64(\"foo\")\n\tif n != 123 {\n\t\tt.Fatalf(\"unexpected value; got %d; want %d\", n64, 123)\n\t}\n\tun := v.GetUint(\"foo\")\n\tif un != 123 {\n\t\tt.Fatalf(\"unexpected value; got %d; want %d\", un, 123)\n\t}\n\tun64 := v.GetUint64(\"foo\")\n\tif un != 123 {\n\t\tt.Fatalf(\"unexpected value; got %d; want %d\", un64, 123)\n\t}\n\tn = v.GetInt(\"bar\")\n\tif n != 0 {\n\t\tt.Fatalf(\"unexpected non-zero value; got %d\", n)\n\t}\n\tn64 = v.GetInt64(\"bar\")\n\tif n != 0 {\n\t\tt.Fatalf(\"unexpected non-zero value; got %d\", n64)\n\t}\n\tun = v.GetUint(\"bar\")\n\tif n != 0 {\n\t\tt.Fatalf(\"unexpected non-zero value; got %d\", un)\n\t}\n\tun64 = v.GetUint64(\"bar\")\n\tif n != 0 {\n\t\tt.Fatalf(\"unexpected non-zero value; got %d\", n64)\n\t}\n\tf := v.GetFloat64(\"foo\")\n\tif f != 123.0 {\n\t\tt.Fatalf(\"unexpected value; got %f; want %f\", f, 123.0)\n\t}\n\tf = v.GetFloat64(\"bar\")\n\tif f != 0 {\n\t\tt.Fatalf(\"unexpected value; got %f; want %f\", f, 0.0)\n\t}\n\tf = v.GetFloat64(\"foooo\", \"bar\")\n\tif f != 0 {\n\t\tt.Fatalf(\"unexpected value; got %f; want %f\", f, 0.0)\n\t}\n\tf = v.GetFloat64()\n\tif f != 0 {\n\t\tt.Fatalf(\"unexpected value; got %f; want %f\", f, 0.0)\n\t}\n\tsb := v.GetStringBytes(\"bar\")\n\tif string(sb) != \"433\" {\n\t\tt.Fatalf(\"unexpected value; got %q; want %q\", sb, \"443\")\n\t}\n\tsb = v.GetStringBytes(\"foo\")\n\tif sb != nil {\n\t\tt.Fatalf(\"unexpected value; got %q; want %q\", sb, []byte(nil))\n\t}\n\tbv := v.GetBool(\"baz\")\n\tif !bv {\n\t\tt.Fatalf(\"unexpected value; got %v; want %v\", bv, true)\n\t}\n\tbv = v.GetBool(\"bar\")\n\tif bv {\n\t\tt.Fatalf(\"unexpected value; got %v; want %v\", bv, false)\n\t}\n\n\tzv := v.Get(\"zero_float1\")\n\tzf, err := zv.Float64()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tif zf != 0 {\n\t\tt.Fatalf(\"unexpected zero_float1 value: %f. Expecting 0\", zf)\n\t}\n\n\tzv = v.Get(\"zero_float2\")\n\tzf, err = zv.Float64()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tif zf != 0 {\n\t\tt.Fatalf(\"unexpected zero_float1 value: %f. Expecting 0\", zf)\n\t}\n\n\tinfv := v.Get(\"inf_float\")\n\tinff, err := infv.Float64()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tif !math.IsInf(inff, 1) {\n\t\tt.Fatalf(\"unexpected inf_float value: %f. Expecting %f\", inff, math.Inf(1))\n\t}\n\n\tninfv := v.Get(\"minus_inf_float\")\n\tninff, err := ninfv.Float64()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tif !math.IsInf(ninff, -1) {\n\t\tt.Fatalf(\"unexpected inf_float value: %f. Expecting %f\", ninff, math.Inf(-11))\n\t}\n\n\tnanv := v.Get(\"nan\")\n\tnanf, err := nanv.Float64()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tif !math.IsNaN(nanf) {\n\t\tt.Fatalf(\"unexpected nan value: %f. Expecting %f\", nanf, math.NaN())\n\t}\n}\n\nfunc TestVisitNil(t *testing.T) {\n\tvar p Parser\n\tv, err := p.Parse(`{}`)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\to := v.GetObject(\"non-existing-key\")\n\tif o != nil {\n\t\tt.Fatalf(\"obtained an object for non-existing key: %#v\", o)\n\t}\n\to.Visit(func(k []byte, v *Value) {\n\t\tt.Fatalf(\"unexpected visit call; k=%q; v=%s\", k, v)\n\t})\n}\n\nfunc TestValueGet(t *testing.T) {\n\tvar pp ParserPool\n\n\tp := pp.Get()\n\tv, err := p.ParseBytes([]byte(`{\"xx\":33.33,\"foo\":[123,{\"bar\":[\"baz\"],\"x\":\"y\"}], \"\": \"empty-key\", \"empty-value\": \"\"}`))\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tt.Run(\"positive\", func(t *testing.T) {\n\t\tsb := v.GetStringBytes(\"\")\n\t\tif string(sb) != \"empty-key\" {\n\t\t\tt.Fatalf(\"unexpected value for empty key; got %q; want %q\", sb, \"empty-key\")\n\t\t}\n\t\tsb = v.GetStringBytes(\"empty-value\")\n\t\tif string(sb) != \"\" {\n\t\t\tt.Fatalf(\"unexpected non-empty value: %q\", sb)\n\t\t}\n\n\t\tvv := v.Get(\"foo\", \"1\")\n\t\tif vv == nil {\n\t\t\tt.Fatalf(\"cannot find the required value\")\n\t\t}\n\t\to, err := vv.Object()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain object: %s\", err)\n\t\t}\n\n\t\tn := 0\n\t\to.Visit(func(k []byte, v *Value) {\n\t\t\tn++\n\t\t\tswitch string(k) {\n\t\t\tcase \"bar\":\n\t\t\t\tif v.Type() != TypeArray {\n\t\t\t\t\tt.Fatalf(\"unexpected value type; got %d; want %d\", v.Type(), TypeArray)\n\t\t\t\t}\n\t\t\t\ts := v.String()\n\t\t\t\tif s != `[\"baz\"]` {\n\t\t\t\t\tt.Fatalf(\"unexpected array; got %q; want %q\", s, `[\"baz\"]`)\n\t\t\t\t}\n\t\t\tcase \"x\":\n\t\t\t\tsb, err := v.StringBytes()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"cannot obtain string: %s\", err)\n\t\t\t\t}\n\t\t\t\tif string(sb) != \"y\" {\n\t\t\t\t\tt.Fatalf(\"unexpected string; got %q; want %q\", sb, \"y\")\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"unknown key: %s\", k)\n\t\t\t}\n\t\t})\n\t\tif n != 2 {\n\t\t\tt.Fatalf(\"unexpected number of items visited in the array; got %d; want %d\", n, 2)\n\t\t}\n\t})\n\n\tt.Run(\"negative\", func(t *testing.T) {\n\t\tvv := v.Get(\"nonexisting\", \"path\")\n\t\tif vv != nil {\n\t\t\tt.Fatalf(\"expecting nil value for nonexisting path. Got %#v\", vv)\n\t\t}\n\t\tvv = v.Get(\"foo\", \"bar\", \"baz\")\n\t\tif vv != nil {\n\t\t\tt.Fatalf(\"expecting nil value for nonexisting path. Got %#v\", vv)\n\t\t}\n\t\tvv = v.Get(\"foo\", \"-123\")\n\t\tif vv != nil {\n\t\t\tt.Fatalf(\"expecting nil value for nonexisting path. Got %#v\", vv)\n\t\t}\n\t\tvv = v.Get(\"foo\", \"234\")\n\t\tif vv != nil {\n\t\t\tt.Fatalf(\"expecting nil value for nonexisting path. Got %#v\", vv)\n\t\t}\n\t\tvv = v.Get(\"xx\", \"yy\")\n\t\tif vv != nil {\n\t\t\tt.Fatalf(\"expecting nil value for nonexisting path. Got %#v\", vv)\n\t\t}\n\t})\n\n\tpp.Put(p)\n}\n\nfunc TestParserParse(t *testing.T) {\n\tvar p Parser\n\n\tt.Run(\"complex-string\", func(t *testing.T) {\n\t\tv, err := p.Parse(`{\"\":1, \"\\\\\\\"\\\"\":2, \"\\\\\\\"\\u1234x\":\"\\\\f\\\\\\\\\"}`)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tn := v.GetInt(\"\")\n\t\tif n != 1 {\n\t\t\tt.Fatalf(\"unexpected int; got %d; want %d\", n, 1)\n\t\t}\n\t\tn = v.GetInt(`\\\"\"`)\n\t\tif n != 2 {\n\t\t\tt.Fatalf(\"unexpected int; got %d; want %d\", n, 2)\n\t\t}\n\t\tsb := v.GetStringBytes(\"\\\\\\\"\\u1234x\")\n\t\tif string(sb) != `\\f\\\\` {\n\t\t\tt.Fatalf(\"unexpected string; got %q; want %q\", sb, `\\f\\\\`)\n\t\t}\n\t})\n\n\tt.Run(\"invalid-string-escape\", func(t *testing.T) {\n\t\tv, err := p.Parse(`\"fo\\u\"`)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error when parsing string\")\n\t\t}\n\t\t// Make sure only valid string part remains\n\t\tsb, err := v.StringBytes()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain string: %s\", err)\n\t\t}\n\t\tif string(sb) != \"fo\\\\u\" {\n\t\t\tt.Fatalf(\"unexpected string; got %q; want %q\", sb, \"fo\\\\u\")\n\t\t}\n\n\t\tv, err = p.Parse(`\"foo\\ubarz2134\"`)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error when parsing string\")\n\t\t}\n\t\tsb, err = v.StringBytes()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain string: %s\", err)\n\t\t}\n\t\tif string(sb) != \"foo\\\\ubarz2134\" {\n\t\t\tt.Fatalf(\"unexpected string; got %q; want %q\", sb, \"foo\")\n\t\t}\n\n\t\tv, err = p.Parse(`\"fo` + \"\\x19\" + `\\u\"`)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error when parsing string\")\n\t\t}\n\t\tsb, err = v.StringBytes()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain string: %s\", err)\n\t\t}\n\t\tif string(sb) != \"fo\\x19\\\\u\" {\n\t\t\tt.Fatalf(\"unexpected string; got %q; want %q\", sb, \"fo\\x19\\\\u\")\n\t\t}\n\t})\n\n\tt.Run(\"invalid-number\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"123+456\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error when parsing int\")\n\t\t}\n\n\t\t// Make sure invalid int isn't parsed.\n\t\tn, err := v.Int()\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expecting non-nil error\")\n\t\t}\n\t\tif n != 0 {\n\t\t\tt.Fatalf(\"unexpected int; got %d; want %d\", n, 0)\n\t\t}\n\t})\n\n\tt.Run(\"empty-json\", func(t *testing.T) {\n\t\t_, err := p.Parse(\"\")\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expecting non-nil error when parsing empty json\")\n\t\t}\n\t\t_, err = p.Parse(\"\\n\\t    \\n\")\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expecting non-nil error when parsing empty json\")\n\t\t}\n\t})\n\n\tt.Run(\"invalid-tail\", func(t *testing.T) {\n\t\t_, err := p.Parse(\"123 456\")\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expecting non-nil error when parsing invalid tail\")\n\t\t}\n\t\t_, err = p.Parse(\"[] 1223\")\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expecting non-nil error when parsing invalid tail\")\n\t\t}\n\t})\n\n\tt.Run(\"invalid-json\", func(t *testing.T) {\n\t\tf := func(s string) {\n\t\t\tt.Helper()\n\t\t\tif _, err := p.Parse(s); err == nil {\n\t\t\t\tt.Fatalf(\"expecting non-nil error when parsing invalid json %q\", s)\n\t\t\t}\n\t\t}\n\n\t\tf(\"free\")\n\t\tf(\"tree\")\n\t\tf(\"\\x00\\x10123\")\n\t\tf(\"1 \\n\\x01\")\n\t\tf(\"{\\x00}\")\n\t\tf(\"[\\x00]\")\n\t\tf(\"\\\"foo\\\"\\x00\")\n\t\tf(\"{\\\"foo\\\"\\x00:123}\")\n\t\tf(\"nil\")\n\t\tf(\"[foo]\")\n\t\tf(\"{foo}\")\n\t\tf(\"[123 34]\")\n\t\tf(`{\"foo\" \"bar\"}`)\n\t\tf(`{\"foo\":123 \"bar\":\"baz\"}`)\n\t\tf(\"-2134.453eec+43\")\n\n\t\tif _, err := p.Parse(\"-2134.453E+43\"); err != nil {\n\t\t\tt.Fatalf(\"unexpected error when parsing number: %s\", err)\n\t\t}\n\n\t\t// Incomplete object key key.\n\t\tf(`{\"foo: 123}`)\n\n\t\t// Incomplete string.\n\t\tf(`\"{\\\"foo\\\": 123}`)\n\n\t\tv, err := p.Parse(`\"{\\\"foo\\\": 123}\"`)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error when parsing json string: %s\", err)\n\t\t}\n\t\tsb := v.GetStringBytes()\n\t\tif string(sb) != `{\"foo\": 123}` {\n\t\t\tt.Fatalf(\"unexpected string value; got %q; want %q\", sb, `{\"foo\": 123}`)\n\t\t}\n\t})\n\n\tt.Run(\"incomplete-object\", func(t *testing.T) {\n\t\tf := func(s string) {\n\t\t\tt.Helper()\n\t\t\tif _, err := p.Parse(s); err == nil {\n\t\t\t\tt.Fatalf(\"expecting non-nil error when parsing incomplete object %q\", s)\n\t\t\t}\n\t\t}\n\n\t\tf(\" {  \")\n\t\tf(`{\"foo\"`)\n\t\tf(`{\"foo\":`)\n\t\tf(`{\"foo\":null`)\n\t\tf(`{\"foo\":null,`)\n\t\tf(`{\"foo\":null,}`)\n\t\tf(`{\"foo\":null,\"bar\"}`)\n\n\t\tif _, err := p.Parse(`{\"foo\":null,\"bar\":\"baz\"}`); err != nil {\n\t\t\tt.Fatalf(\"unexpected error when parsing object: %s\", err)\n\t\t}\n\t})\n\n\tt.Run(\"incomplete-array\", func(t *testing.T) {\n\t\tf := func(s string) {\n\t\t\tt.Helper()\n\t\t\tif _, err := p.Parse(s); err == nil {\n\t\t\t\tt.Fatalf(\"expecting non-nil error when parsing incomplete array %q\", s)\n\t\t\t}\n\t\t}\n\n\t\tf(\"  [ \")\n\t\tf(\"[123\")\n\t\tf(\"[123,\")\n\t\tf(\"[123,]\")\n\t\tf(\"[123,{}\")\n\t\tf(\"[123,{},]\")\n\n\t\tif _, err := p.Parse(\"[123,{},[]]\"); err != nil {\n\t\t\tt.Fatalf(\"unexpected error when parsing array: %s\", err)\n\t\t}\n\t})\n\n\tt.Run(\"incomplete-string\", func(t *testing.T) {\n\t\tf := func(s string) {\n\t\t\tt.Helper()\n\t\t\tif _, err := p.Parse(s); err == nil {\n\t\t\t\tt.Fatalf(\"expecting non-nil error when parsing incomplete string %q\", s)\n\t\t\t}\n\t\t}\n\n\t\tf(`  \"foo`)\n\t\tf(`\"foo\\`)\n\t\tf(`\"foo\\\"`)\n\t\tf(`\"foo\\\\\\\"`)\n\t\tf(`\"foo'`)\n\t\tf(`\"foo'bar'`)\n\n\t\tif _, err := p.Parse(`\"foo\\\\\\\"\"`); err != nil {\n\t\t\tt.Fatalf(\"unexpected error when parsing string: %s\", err)\n\t\t}\n\t})\n\n\tt.Run(\"empty-object\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"{}\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse empty object: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeObject || tp.String() != \"object\" {\n\t\t\tt.Fatalf(\"unexpected value obtained for empty object: %#v\", v)\n\t\t}\n\t\to, err := v.Object()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain object: %s\", err)\n\t\t}\n\t\tn := o.Len()\n\t\tif n != 0 {\n\t\t\tt.Fatalf(\"unexpected number of items in empty object: %d; want 0\", n)\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"{}\" {\n\t\t\tt.Fatalf(\"unexpected string representation of empty object: got %q; want %q\", s, \"{}\")\n\t\t}\n\t})\n\n\tt.Run(\"empty-array\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"[]\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse empty array: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeArray || tp.String() != \"array\" {\n\t\t\tt.Fatalf(\"unexpected value obtained for empty array: %#v\", v)\n\t\t}\n\t\ta, err := v.Array()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tn := len(a)\n\t\tif n != 0 {\n\t\t\tt.Fatalf(\"unexpected number of items in empty array: %d; want 0\", n)\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"[]\" {\n\t\t\tt.Fatalf(\"unexpected string representation of empty array: got %q; want %q\", s, \"[]\")\n\t\t}\n\t})\n\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"null\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse null: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeNull || tp.String() != \"null\" {\n\t\t\tt.Fatalf(\"unexpected value obtained for null: %#v\", v)\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"null\" {\n\t\t\tt.Fatalf(\"unexpected string representation of null; got %q; want %q\", s, \"null\")\n\t\t}\n\t})\n\n\tt.Run(\"true\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"true\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse true: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeTrue || tp.String() != \"true\" {\n\t\t\tt.Fatalf(\"unexpected value obtained for true: %#v\", v)\n\t\t}\n\t\tb, err := v.Bool()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tif !b {\n\t\t\tt.Fatalf(\"expecting true; got false\")\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"true\" {\n\t\t\tt.Fatalf(\"unexpected string representation of true; got %q; want %q\", s, \"true\")\n\t\t}\n\t})\n\n\tt.Run(\"false\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"false\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse false: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeFalse || tp.String() != \"false\" {\n\t\t\tt.Fatalf(\"unexpected value obtained for false: %#v\", v)\n\t\t}\n\t\tb, err := v.Bool()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tif b {\n\t\t\tt.Fatalf(\"expecting false; got true\")\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"false\" {\n\t\t\tt.Fatalf(\"unexpected string representation of false; got %q; want %q\", s, \"false\")\n\t\t}\n\t})\n\n\tt.Run(\"integer\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"12345\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse integer: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeNumber || tp.String() != \"number\" {\n\t\t\tt.Fatalf(\"unexpected type obtained for integer: %#v\", v)\n\t\t}\n\t\tn, err := v.Int()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain int: %s\", err)\n\t\t}\n\t\tif n != 12345 {\n\t\t\tt.Fatalf(\"unexpected value obtained for integer; got %d; want %d\", n, 12345)\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"12345\" {\n\t\t\tt.Fatalf(\"unexpected string representation of integer; got %q; want %q\", s, \"12345\")\n\t\t}\n\t})\n\n\tt.Run(\"int64\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"-8838840643388017390\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse int64: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeNumber || tp.String() != \"number\" {\n\t\t\tt.Fatalf(\"unexpected type obtained for int64: %#v\", v)\n\t\t}\n\t\tn, err := v.Int64()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain int64: %s\", err)\n\t\t}\n\t\tif n != int64(-8838840643388017390) {\n\t\t\tt.Fatalf(\"unexpected value obtained for int64; got %d; want %d\", n, int64(-8838840643388017390))\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"-8838840643388017390\" {\n\t\t\tt.Fatalf(\"unexpected string representation of int64; got %q; want %q\", s, \"-8838840643388017390\")\n\t\t}\n\t})\n\n\tt.Run(\"uint\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"18446744073709551615\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse uint: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeNumber || tp.String() != \"number\" {\n\t\t\tt.Fatalf(\"unexpected type obtained for uint: %#v\", v)\n\t\t}\n\t\tn, err := v.Uint64()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain uint64: %s\", err)\n\t\t}\n\t\tif n != uint64(18446744073709551615) {\n\t\t\tt.Fatalf(\"unexpected value obtained for uint; got %d; want %d\", n, uint64(18446744073709551615))\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"18446744073709551615\" {\n\t\t\tt.Fatalf(\"unexpected string representation of uint; got %q; want %q\", s, \"18446744073709551615\")\n\t\t}\n\t})\n\n\tt.Run(\"uint64\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"18446744073709551615\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse uint64: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeNumber || tp.String() != \"number\" {\n\t\t\tt.Fatalf(\"unexpected type obtained for uint64: %#v\", v)\n\t\t}\n\t\tn, err := v.Uint64()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain uint64: %s\", err)\n\t\t}\n\t\tif n != 18446744073709551615 {\n\t\t\tt.Fatalf(\"unexpected value obtained for uint64; got %d; want %d\", n, uint64(18446744073709551615))\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"18446744073709551615\" {\n\t\t\tt.Fatalf(\"unexpected string representation of uint64; got %q; want %q\", s, \"18446744073709551615\")\n\t\t}\n\t})\n\n\tt.Run(\"float\", func(t *testing.T) {\n\t\tv, err := p.Parse(\"-12.345\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse integer: %s\", err)\n\t\t}\n\t\tn, err := v.Float64()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeNumber || tp.String() != \"number\" {\n\t\t\tt.Fatalf(\"unexpected type obtained for integer: %#v\", v)\n\t\t}\n\t\tif n != -12.345 {\n\t\t\tt.Fatalf(\"unexpected value obtained for integer; got %f; want %f\", n, -12.345)\n\t\t}\n\t\ts := v.String()\n\t\tif s != \"-12.345\" {\n\t\t\tt.Fatalf(\"unexpected string representation of integer; got %q; want %q\", s, \"-12.345\")\n\t\t}\n\t})\n\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tv, err := p.Parse(`\"foo bar\"`)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse string: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeString || tp.String() != \"string\" {\n\t\t\tt.Fatalf(\"unexpected type obtained for string: %#v\", v)\n\t\t}\n\t\tsb, err := v.StringBytes()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain string: %s\", err)\n\t\t}\n\t\tif string(sb) != \"foo bar\" {\n\t\t\tt.Fatalf(\"unexpected value obtained for string; got %q; want %q\", sb, \"foo bar\")\n\t\t}\n\t\tss := v.String()\n\t\tif ss != `\"foo bar\"` {\n\t\t\tt.Fatalf(\"unexpected string representation of string; got %q; want %q\", ss, `\"foo bar\"`)\n\t\t}\n\t})\n\n\tt.Run(\"string-escaped\", func(t *testing.T) {\n\t\tv, err := p.Parse(`\"\\n\\t\\\\foo\\\"bar\\u3423x\\/\\b\\f\\r\\\\\"`)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse string: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeString {\n\t\t\tt.Fatalf(\"unexpected type obtained for string: %#v\", v)\n\t\t}\n\t\tsb, err := v.StringBytes()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain string: %s\", err)\n\t\t}\n\t\tif string(sb) != \"\\n\\t\\\\foo\\\"bar\\u3423x/\\b\\f\\r\\\\\" {\n\t\t\tt.Fatalf(\"unexpected value obtained for string; got %q; want %q\", sb, \"\\n\\t\\\\foo\\\"bar\\u3423x/\\b\\f\\r\\\\\")\n\t\t}\n\t\tss := v.String()\n\t\tif ss != `\"\\n\\t\\\\foo\\\"barx/\\b\\f\\r\\\\\"` {\n\t\t\tt.Fatalf(\"unexpected string representation of string; got %q; want %q\", ss, `\"\\n\\t\\\\foo\\\"barx/\\b\\f\\r\\\\\"`)\n\t\t}\n\t})\n\n\tt.Run(\"object-one-element\", func(t *testing.T) {\n\t\tv, err := p.Parse(`  {\n\t\"foo\"   : \"bar\"  }\t `)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse object: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeObject {\n\t\t\tt.Fatalf(\"unexpected type obtained for object: %#v\", v)\n\t\t}\n\t\to, err := v.Object()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain object: %s\", err)\n\t\t}\n\t\tvv := o.Get(\"foo\")\n\t\tif vv.Type() != TypeString {\n\t\t\tt.Fatalf(\"unexpected type for foo item: got %d; want %d\", vv.Type(), TypeString)\n\t\t}\n\t\tvv = o.Get(\"non-existing key\")\n\t\tif vv != nil {\n\t\t\tt.Fatalf(\"unexpected value obtained for non-existing key: %#v\", vv)\n\t\t}\n\n\t\ts := v.String()\n\t\tif s != `{\"foo\":\"bar\"}` {\n\t\t\tt.Fatalf(\"unexpected string representation for object; got %q; want %q\", s, `{\"foo\":\"bar\"}`)\n\t\t}\n\t})\n\n\tt.Run(\"object-multi-elements\", func(t *testing.T) {\n\t\tv, err := p.Parse(`{\"foo\": [1,2,3  ]  ,\"bar\":{},\"baz\":123.456}`)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse object: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeObject {\n\t\t\tt.Fatalf(\"unexpected type obtained for object: %#v\", v)\n\t\t}\n\t\to, err := v.Object()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain object: %s\", err)\n\t\t}\n\t\tvv := o.Get(\"foo\")\n\t\tif vv.Type() != TypeArray {\n\t\t\tt.Fatalf(\"unexpected type for foo item; got %d; want %d\", vv.Type(), TypeArray)\n\t\t}\n\t\tvv = o.Get(\"bar\")\n\t\tif vv.Type() != TypeObject {\n\t\t\tt.Fatalf(\"unexpected type for bar item; got %d; want %d\", vv.Type(), TypeObject)\n\t\t}\n\t\tvv = o.Get(\"baz\")\n\t\tif vv.Type() != TypeNumber {\n\t\t\tt.Fatalf(\"unexpected type for baz item; got %d; want %d\", vv.Type(), TypeNumber)\n\t\t}\n\t\tvv = o.Get(\"non-existing-key\")\n\t\tif vv != nil {\n\t\t\tt.Fatalf(\"unexpected value obtained for non-existing key: %#v\", vv)\n\t\t}\n\n\t\ts := v.String()\n\t\tif s != `{\"foo\":[1,2,3],\"bar\":{},\"baz\":123.456}` {\n\t\t\tt.Fatalf(\"unexpected string representation for object; got %q; want %q\", s, `{\"foo\":[1,2,3],\"bar\":{},\"baz\":123.456}`)\n\t\t}\n\t})\n\n\tt.Run(\"array-one-element\", func(t *testing.T) {\n\t\tv, err := p.Parse(`   [{\"bar\":[  [],[[]]   ]} ]  `)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse array: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeArray {\n\t\t\tt.Fatalf(\"unexpected type obtained for array: %#v\", v)\n\t\t}\n\t\ta, err := v.Array()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tif len(a) != 1 {\n\t\t\tt.Fatalf(\"unexpected array len; got %d; want %d\", len(a), 1)\n\t\t}\n\t\tif a[0].Type() != TypeObject {\n\t\t\tt.Fatalf(\"unexpected type for a[0]; got %d; want %d\", a[0].Type(), TypeObject)\n\t\t}\n\n\t\ts := v.String()\n\t\tif s != `[{\"bar\":[[],[[]]]}]` {\n\t\t\tt.Fatalf(\"unexpected string representation for array; got %q; want %q\", s, `[{\"bar\":[[],[[]]]}]`)\n\t\t}\n\t})\n\n\tt.Run(\"array-multi-elements\", func(t *testing.T) {\n\t\tv, err := p.Parse(`   [1,\"foo\",{\"bar\":[     ],\"baz\":\"\"}    ,[  \"x\" ,\t\"y\"   ]     ]   `)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse array: %s\", err)\n\t\t}\n\t\ttp := v.Type()\n\t\tif tp != TypeArray {\n\t\t\tt.Fatalf(\"unexpected type obtained for array: %#v\", v)\n\t\t}\n\t\ta, err := v.Array()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tif len(a) != 4 {\n\t\t\tt.Fatalf(\"unexpected array len; got %d; want %d\", len(a), 4)\n\t\t}\n\t\tif a[0].Type() != TypeNumber {\n\t\t\tt.Fatalf(\"unexpected type for a[0]; got %d; want %d\", a[0].Type(), TypeNumber)\n\t\t}\n\t\tif a[1].Type() != TypeString {\n\t\t\tt.Fatalf(\"unexpected type for a[1]; got %d; want %d\", a[1].Type(), TypeString)\n\t\t}\n\t\tif a[2].Type() != TypeObject {\n\t\t\tt.Fatalf(\"unexpected type for a[2]; got %d; want %d\", a[2].Type(), TypeObject)\n\t\t}\n\t\tif a[3].Type() != TypeArray {\n\t\t\tt.Fatalf(\"unexpected type for a[3]; got %d; want %d\", a[3].Type(), TypeArray)\n\t\t}\n\n\t\ts := v.String()\n\t\tif s != `[1,\"foo\",{\"bar\":[],\"baz\":\"\"},[\"x\",\"y\"]]` {\n\t\t\tt.Fatalf(\"unexpected string representation for array; got %q; want %q\", s, `[1,\"foo\",{\"bar\":[],\"baz\":\"\"},[\"x\",\"y\"]]`)\n\t\t}\n\t})\n\n\tt.Run(\"complex-object\", func(t *testing.T) {\n\t\ts := `{\"foo\":[-1.345678,[[[[[]]]],{}],\"bar\"],\"baz\":{\"bbb\":123}}`\n\t\tv, err := p.Parse(s)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse complex object: %s\", err)\n\t\t}\n\t\tif v.Type() != TypeObject {\n\t\t\tt.Fatalf(\"unexpected type obtained for object: %#v\", v)\n\t\t}\n\n\t\tss := v.String()\n\t\tif ss != s {\n\t\t\tt.Fatalf(\"unexpected string representation for object; got %q; want %q\", ss, s)\n\t\t}\n\n\t\ts = strings.TrimSpace(largeFixture)\n\t\tv, err = p.Parse(s)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse largeFixture: %s\", err)\n\t\t}\n\t\tss = v.String()\n\t\tif ss != s {\n\t\t\tt.Fatalf(\"unexpected string representation for object; got\\n%q; want\\n%q\", ss, s)\n\t\t}\n\t})\n\n\tt.Run(\"complex-object-visit-all\", func(t *testing.T) {\n\t\tn := 0\n\t\tvar f func(k []byte, v *Value)\n\t\tf = func(k []byte, v *Value) {\n\t\t\tswitch v.Type() {\n\t\t\tcase TypeObject:\n\t\t\t\to, err := v.Object()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"cannot obtain object: %s\", err)\n\t\t\t\t}\n\t\t\t\to.Visit(f)\n\t\t\tcase TypeArray:\n\t\t\t\ta, err := v.Array()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t\t\t}\n\t\t\t\tfor _, vv := range a {\n\t\t\t\t\tf(nil, vv)\n\t\t\t\t}\n\t\t\tcase TypeString:\n\t\t\t\tsb, err := v.StringBytes()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"cannot obtain string: %s\", err)\n\t\t\t\t}\n\t\t\t\tn += len(sb)\n\t\t\tcase TypeNumber:\n\t\t\t\tnn, err := v.Int()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"cannot obtain int: %s\", err)\n\t\t\t\t}\n\t\t\t\tn += nn\n\t\t\t}\n\t\t}\n\n\t\ts := strings.TrimSpace(largeFixture)\n\t\tv, err := p.Parse(s)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot parse largeFixture: %s\", err)\n\t\t}\n\t\to, err := v.Object()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot obtain object: %s\", err)\n\t\t}\n\t\to.Visit(f)\n\n\t\tif n != 21473 {\n\t\t\tt.Fatalf(\"unexpected n; got %d; want %d\", n, 21473)\n\t\t}\n\n\t\t// Make sure the json remains valid after visiting all the items.\n\t\tss := v.String()\n\t\tif ss != s {\n\t\t\tt.Fatalf(\"unexpected string representation for object; got\\n%q; want\\n%q\", ss, s)\n\t\t}\n\n\t})\n}\n\nfunc TestParseBigObject(t *testing.T) {\n\tconst itemsCount = 10000\n\n\t// build big json object\n\tvar ss []string\n\tfor i := 0; i < itemsCount; i++ {\n\t\ts := fmt.Sprintf(`\"key_%d\": \"value_%d\"`, i, i)\n\t\tss = append(ss, s)\n\t}\n\ts := \"{\" + strings.Join(ss, \",\") + \"}\"\n\n\t// parse it\n\tvar p Parser\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// Look up object items\n\tfor i := 0; i < itemsCount; i++ {\n\t\tk := fmt.Sprintf(\"key_%d\", i)\n\t\texpectedV := fmt.Sprintf(\"value_%d\", i)\n\t\tsb := v.GetStringBytes(k)\n\t\tif string(sb) != expectedV {\n\t\t\tt.Fatalf(\"unexpected value obtained; got %q; want %q\", sb, expectedV)\n\t\t}\n\t}\n\n\t// verify non-existing key returns nil\n\tsb := v.GetStringBytes(\"non-existing-key\")\n\tif sb != nil {\n\t\tt.Fatalf(\"unexpected non-nil value for non-existing-key: %q\", sb)\n\t}\n}\n\nfunc TestParseGetConcurrent(t *testing.T) {\n\tconcurrency := 10\n\tch := make(chan error, concurrency)\n\ts := `{\"foo\": \"bar\", \"empty_obj\": {}}`\n\tfor i := 0; i < concurrency; i++ {\n\t\tgo func() {\n\t\t\tch <- testParseGetSerial(s)\n\t\t}()\n\t}\n\tfor i := 0; i < concurrency; i++ {\n\t\tselect {\n\t\tcase err := <-ch:\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error during concurrent test: %s\", err)\n\t\t\t}\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatalf(\"timeout\")\n\t\t}\n\t}\n}\n\nfunc testParseGetSerial(s string) error {\n\tvar p Parser\n\tfor i := 0; i < 100; i++ {\n\t\tv, err := p.Parse(s)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot parse %q: %s\", s, err)\n\t\t}\n\t\tsb := v.GetStringBytes(\"foo\")\n\t\tif string(sb) != \"bar\" {\n\t\t\treturn fmt.Errorf(\"unexpected value for key=%q; got %q; want %q\", \"foo\", sb, \"bar\")\n\t\t}\n\t\tvv := v.Get(\"empty_obj\", \"non-existing-key\")\n\t\tif vv != nil {\n\t\t\treturn fmt.Errorf(\"unexpected non-nil value got: %s\", vv)\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "parser_timing_test.go",
          "type": "blob",
          "size": 7.671875,
          "content": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc BenchmarkParseRawString(b *testing.B) {\n\tfor _, s := range []string{`\"\"`, `\"a\"`, `\"abcd\"`, `\"abcdefghijk\"`, `\"qwertyuiopasdfghjklzxcvb\"`} {\n\t\tb.Run(s, func(b *testing.B) {\n\t\t\tbenchmarkParseRawString(b, s)\n\t\t})\n\t}\n}\n\nfunc benchmarkParseRawString(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\ts = s[1:] // skip the opening '\"'\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\trs, tail, err := parseRawString(s)\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"cannot parse %q: %s\", s, err))\n\t\t\t}\n\t\t\tif rs != s[:len(s)-1] {\n\t\t\t\tpanic(fmt.Errorf(\"invalid string obtained; got %q; want %q\", rs, s[:len(s)-1]))\n\t\t\t}\n\t\t\tif len(tail) > 0 {\n\t\t\t\tpanic(fmt.Errorf(\"non-empty tail got: %q\", tail))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkParseRawNumber(b *testing.B) {\n\tfor _, s := range []string{\"1\", \"1234\", \"123456\", \"-1234\", \"1234567890.1234567\", \"-1.32434e+12\"} {\n\t\tb.Run(s, func(b *testing.B) {\n\t\t\tbenchmarkParseRawNumber(b, s)\n\t\t})\n\t}\n}\n\nfunc benchmarkParseRawNumber(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\trn, tail, err := parseRawNumber(s)\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"cannot parse %q: %s\", s, err))\n\t\t\t}\n\t\t\tif rn != s {\n\t\t\t\tpanic(fmt.Errorf(\"invalid number obtained; got %q; want %q\", rn, s))\n\t\t\t}\n\t\t\tif len(tail) > 0 {\n\t\t\t\tpanic(fmt.Errorf(\"non-empty tail got: %q\", tail))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkObjectGet(b *testing.B) {\n\tfor _, itemsCount := range []int{10, 100, 1000, 10000, 100000} {\n\t\tb.Run(fmt.Sprintf(\"items_%d\", itemsCount), func(b *testing.B) {\n\t\t\tfor _, lookupsCount := range []int{0, 1, 2, 4, 8, 16, 32, 64} {\n\t\t\t\tb.Run(fmt.Sprintf(\"lookups_%d\", lookupsCount), func(b *testing.B) {\n\t\t\t\t\tbenchmarkObjectGet(b, itemsCount, lookupsCount)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc benchmarkObjectGet(b *testing.B, itemsCount, lookupsCount int) {\n\tb.StopTimer()\n\tvar ss []string\n\tfor i := 0; i < itemsCount; i++ {\n\t\ts := fmt.Sprintf(`\"key_%d\": \"value_%d\"`, i, i)\n\t\tss = append(ss, s)\n\t}\n\ts := \"{\" + strings.Join(ss, \",\") + \"}\"\n\tkey := fmt.Sprintf(\"key_%d\", len(ss)/2)\n\texpectedValue := fmt.Sprintf(\"value_%d\", len(ss)/2)\n\tb.StartTimer()\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tp := benchPool.Get()\n\t\tfor pb.Next() {\n\t\t\tv, err := p.Parse(s)\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"unexpected error: %s\", err))\n\t\t\t}\n\t\t\to := v.GetObject()\n\t\t\tfor i := 0; i < lookupsCount; i++ {\n\t\t\t\tsb := o.Get(key).GetStringBytes()\n\t\t\t\tif string(sb) != expectedValue {\n\t\t\t\t\tpanic(fmt.Errorf(\"unexpected value; got %q; want %q\", sb, expectedValue))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbenchPool.Put(p)\n\t})\n}\n\nfunc BenchmarkMarshalTo(b *testing.B) {\n\tb.Run(\"small\", func(b *testing.B) {\n\t\tbenchmarkMarshalTo(b, smallFixture)\n\t})\n\tb.Run(\"medium\", func(b *testing.B) {\n\t\tbenchmarkMarshalTo(b, mediumFixture)\n\t})\n\tb.Run(\"large\", func(b *testing.B) {\n\t\tbenchmarkMarshalTo(b, largeFixture)\n\t})\n\tb.Run(\"canada\", func(b *testing.B) {\n\t\tbenchmarkMarshalTo(b, canadaFixture)\n\t})\n\tb.Run(\"citm\", func(b *testing.B) {\n\t\tbenchmarkMarshalTo(b, citmFixture)\n\t})\n\tb.Run(\"twitter\", func(b *testing.B) {\n\t\tbenchmarkMarshalTo(b, twitterFixture)\n\t})\n}\n\nfunc benchmarkMarshalTo(b *testing.B, s string) {\n\tp := benchPool.Get()\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"unexpected error: %s\", err))\n\t}\n\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar b []byte\n\t\tfor pb.Next() {\n\t\t\t// It is ok calling v.MarshalTo from concurrent\n\t\t\t// goroutines, since MarshalTo doesn't modify v.\n\t\t\tb = v.MarshalTo(b[:0])\n\t\t}\n\t})\n\tbenchPool.Put(p)\n}\n\nfunc BenchmarkParse(b *testing.B) {\n\tb.Run(\"small\", func(b *testing.B) {\n\t\tbenchmarkParse(b, smallFixture)\n\t})\n\tb.Run(\"medium\", func(b *testing.B) {\n\t\tbenchmarkParse(b, mediumFixture)\n\t})\n\tb.Run(\"large\", func(b *testing.B) {\n\t\tbenchmarkParse(b, largeFixture)\n\t})\n\tb.Run(\"canada\", func(b *testing.B) {\n\t\tbenchmarkParse(b, canadaFixture)\n\t})\n\tb.Run(\"citm\", func(b *testing.B) {\n\t\tbenchmarkParse(b, citmFixture)\n\t})\n\tb.Run(\"twitter\", func(b *testing.B) {\n\t\tbenchmarkParse(b, twitterFixture)\n\t})\n}\n\nvar (\n\t// small, medium and large fixtures are from https://github.com/buger/jsonparser/blob/f04e003e4115787c6272636780bc206e5ffad6c4/benchmark/benchmark.go\n\tsmallFixture  = getFromFile(\"testdata/small.json\")\n\tmediumFixture = getFromFile(\"testdata/medium.json\")\n\tlargeFixture  = getFromFile(\"testdata/large.json\")\n\n\t// canada, citm and twitter fixtures are from https://github.com/serde-rs/json-benchmark/tree/0db02e043b3ae87dc5065e7acb8654c1f7670c43/data\n\tcanadaFixture  = getFromFile(\"testdata/canada.json\")\n\tcitmFixture    = getFromFile(\"testdata/citm_catalog.json\")\n\ttwitterFixture = getFromFile(\"testdata/twitter.json\")\n)\n\nfunc getFromFile(filename string) string {\n\tdata, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"cannot read %s: %s\", filename, err))\n\t}\n\treturn string(data)\n}\n\nfunc benchmarkParse(b *testing.B, s string) {\n\tb.Run(\"stdjson-map\", func(b *testing.B) {\n\t\tbenchmarkStdJSONParseMap(b, s)\n\t})\n\tb.Run(\"stdjson-struct\", func(b *testing.B) {\n\t\tbenchmarkStdJSONParseStruct(b, s)\n\t})\n\tb.Run(\"stdjson-empty-struct\", func(b *testing.B) {\n\t\tbenchmarkStdJSONParseEmptyStruct(b, s)\n\t})\n\tb.Run(\"fastjson\", func(b *testing.B) {\n\t\tbenchmarkFastJSONParse(b, s)\n\t})\n\tb.Run(\"fastjson-get\", func(b *testing.B) {\n\t\tbenchmarkFastJSONParseGet(b, s)\n\t})\n}\n\nfunc benchmarkFastJSONParse(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tp := benchPool.Get()\n\t\tfor pb.Next() {\n\t\t\tv, err := p.Parse(s)\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"unexpected error: %s\", err))\n\t\t\t}\n\t\t\tif v.Type() != TypeObject {\n\t\t\t\tpanic(fmt.Errorf(\"unexpected value type; got %s; want %s\", v.Type(), TypeObject))\n\t\t\t}\n\t\t}\n\t\tbenchPool.Put(p)\n\t})\n}\n\nfunc benchmarkFastJSONParseGet(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tp := benchPool.Get()\n\t\tvar n int\n\t\tfor pb.Next() {\n\t\t\tv, err := p.Parse(s)\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"unexpected error: %s\", err))\n\t\t\t}\n\t\t\tn += v.GetInt(\"sid\")\n\t\t\tn += len(v.GetStringBytes(\"uuid\"))\n\t\t\tp := v.Get(\"person\")\n\t\t\tif p != nil {\n\t\t\t\tn++\n\t\t\t}\n\t\t\tc := v.Get(\"company\")\n\t\t\tif c != nil {\n\t\t\t\tn++\n\t\t\t}\n\t\t\tu := v.Get(\"users\")\n\t\t\tif u != nil {\n\t\t\t\tn++\n\t\t\t}\n\t\t\ta := v.GetArray(\"features\")\n\t\t\tn += len(a)\n\t\t\ta = v.GetArray(\"topicSubTopics\")\n\t\t\tn += len(a)\n\t\t\to := v.Get(\"search_metadata\")\n\t\t\tif o != nil {\n\t\t\t\tn++\n\t\t\t}\n\t\t}\n\t\tbenchPool.Put(p)\n\t})\n}\n\nvar benchPool ParserPool\n\nfunc benchmarkStdJSONParseMap(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tbb := s2b(s)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar m map[string]interface{}\n\t\tfor pb.Next() {\n\t\t\tif err := json.Unmarshal(bb, &m); err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"unexpected error: %s\", err))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc benchmarkStdJSONParseStruct(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tbb := s2b(s)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar m struct {\n\t\t\tSid            int\n\t\t\tUUID           string\n\t\t\tPerson         map[string]interface{}\n\t\t\tCompany        map[string]interface{}\n\t\t\tUsers          []interface{}\n\t\t\tFeatures       []map[string]interface{}\n\t\t\tTopicSubTopics map[string]interface{}\n\t\t\tSearchMetadata map[string]interface{}\n\t\t}\n\t\tfor pb.Next() {\n\t\t\tif err := json.Unmarshal(bb, &m); err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"unexpected error: %s\", err))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc benchmarkStdJSONParseEmptyStruct(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tbb := s2b(s)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar m struct{}\n\t\tfor pb.Next() {\n\t\t\tif err := json.Unmarshal(bb, &m); err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"unexpected error: %s\", err))\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "pool.go",
          "type": "blob",
          "size": 0.9580078125,
          "content": "package fastjson\n\nimport (\n\t\"sync\"\n)\n\n// ParserPool may be used for pooling Parsers for similarly typed JSONs.\ntype ParserPool struct {\n\tpool sync.Pool\n}\n\n// Get returns a Parser from pp.\n//\n// The Parser must be Put to pp after use.\nfunc (pp *ParserPool) Get() *Parser {\n\tv := pp.pool.Get()\n\tif v == nil {\n\t\treturn &Parser{}\n\t}\n\treturn v.(*Parser)\n}\n\n// Put returns p to pp.\n//\n// p and objects recursively returned from p cannot be used after p\n// is put into pp.\nfunc (pp *ParserPool) Put(p *Parser) {\n\tpp.pool.Put(p)\n}\n\n// ArenaPool may be used for pooling Arenas for similarly typed JSONs.\ntype ArenaPool struct {\n\tpool sync.Pool\n}\n\n// Get returns an Arena from ap.\n//\n// The Arena must be Put to ap after use.\nfunc (ap *ArenaPool) Get() *Arena {\n\tv := ap.pool.Get()\n\tif v == nil {\n\t\treturn &Arena{}\n\t}\n\treturn v.(*Arena)\n}\n\n// Put returns a to ap.\n//\n// a and objects created by a cannot be used after a is put into ap.\nfunc (ap *ArenaPool) Put(a *Arena) {\n\tap.pool.Put(a)\n}\n"
        },
        {
          "name": "scanner.go",
          "type": "blob",
          "size": 1.8828125,
          "content": "package fastjson\n\nimport (\n\t\"errors\"\n)\n\n// Scanner scans a series of JSON values. Values may be delimited by whitespace.\n//\n// Scanner may parse JSON lines ( http://jsonlines.org/ ).\n//\n// Scanner may be re-used for subsequent parsing.\n//\n// Scanner cannot be used from concurrent goroutines.\n//\n// Use Parser for parsing only a single JSON value.\ntype Scanner struct {\n\t// b contains a working copy of json value passed to Init.\n\tb []byte\n\n\t// s points to the next JSON value to parse.\n\ts string\n\n\t// err contains the last error.\n\terr error\n\n\t// v contains the last parsed JSON value.\n\tv *Value\n\n\t// c is used for caching JSON values.\n\tc cache\n}\n\n// Init initializes sc with the given s.\n//\n// s may contain multiple JSON values, which may be delimited by whitespace.\nfunc (sc *Scanner) Init(s string) {\n\tsc.b = append(sc.b[:0], s...)\n\tsc.s = b2s(sc.b)\n\tsc.err = nil\n\tsc.v = nil\n}\n\n// InitBytes initializes sc with the given b.\n//\n// b may contain multiple JSON values, which may be delimited by whitespace.\nfunc (sc *Scanner) InitBytes(b []byte) {\n\tsc.Init(b2s(b))\n}\n\n// Next parses the next JSON value from s passed to Init.\n//\n// Returns true on success. The parsed value is available via Value call.\n//\n// Returns false either on error or on the end of s.\n// Call Error in order to determine the cause of the returned false.\nfunc (sc *Scanner) Next() bool {\n\tif sc.err != nil {\n\t\treturn false\n\t}\n\n\tsc.s = skipWS(sc.s)\n\tif len(sc.s) == 0 {\n\t\tsc.err = errEOF\n\t\treturn false\n\t}\n\n\tsc.c.reset()\n\tv, tail, err := parseValue(sc.s, &sc.c, 0)\n\tif err != nil {\n\t\tsc.err = err\n\t\treturn false\n\t}\n\n\tsc.s = tail\n\tsc.v = v\n\treturn true\n}\n\n// Error returns the last error.\nfunc (sc *Scanner) Error() error {\n\tif sc.err == errEOF {\n\t\treturn nil\n\t}\n\treturn sc.err\n}\n\n// Value returns the last parsed value.\n//\n// The value is valid until the Next call.\nfunc (sc *Scanner) Value() *Value {\n\treturn sc.v\n}\n\nvar errEOF = errors.New(\"end of s\")\n"
        },
        {
          "name": "scanner_example_test.go",
          "type": "blob",
          "size": 0.8349609375,
          "content": "package fastjson_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/valyala/fastjson\"\n\t\"log\"\n)\n\nfunc ExampleScanner() {\n\tvar sc fastjson.Scanner\n\n\tsc.Init(`   {\"foo\":  \"bar\"  }[  ]\n\t\t12345\"xyz\" true false null    `)\n\n\tfor sc.Next() {\n\t\tfmt.Printf(\"%s\\n\", sc.Value())\n\t}\n\tif err := sc.Error(); err != nil {\n\t\tlog.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// Output:\n\t// {\"foo\":\"bar\"}\n\t// []\n\t// 12345\n\t// \"xyz\"\n\t// true\n\t// false\n\t// null\n}\n\nfunc ExampleScanner_reuse() {\n\tvar sc fastjson.Scanner\n\n\t// The sc may be re-used in order to reduce the number\n\t// of memory allocations.\n\tfor i := 0; i < 3; i++ {\n\t\ts := fmt.Sprintf(`[%d] \"%d\"`, i, i)\n\t\tsc.Init(s)\n\t\tfor sc.Next() {\n\t\t\tfmt.Printf(\"%s,\", sc.Value())\n\t\t}\n\t\tif err := sc.Error(); err != nil {\n\t\t\tlog.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tfmt.Printf(\"\\n\")\n\t}\n\n\t// Output:\n\t// [0],\"0\",\n\t// [1],\"1\",\n\t// [2],\"2\",\n}\n"
        },
        {
          "name": "scanner_test.go",
          "type": "blob",
          "size": 0.6982421875,
          "content": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestScanner(t *testing.T) {\n\tvar sc Scanner\n\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tsc.InitBytes([]byte(`[] {} \"\" 123`))\n\t\tvar bb bytes.Buffer\n\t\tfor sc.Next() {\n\t\t\tv := sc.Value()\n\t\t\tfmt.Fprintf(&bb, \"%s\", v)\n\t\t}\n\t\tif err := sc.Error(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\ts := bb.String()\n\t\tif s != `[]{}\"\"123` {\n\t\t\tt.Fatalf(\"unexpected string obtained; got %q; want %q\", s, `[]{}\"\"123`)\n\t\t}\n\t})\n\n\tt.Run(\"error\", func(t *testing.T) {\n\t\tsc.Init(`[] sdfdsfdf`)\n\t\tfor sc.Next() {\n\t\t}\n\t\tif err := sc.Error(); err == nil {\n\t\t\tt.Fatalf(\"expecting non-nil error\")\n\t\t}\n\t\tif sc.Next() {\n\t\t\tt.Fatalf(\"Next must return false\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "update.go",
          "type": "blob",
          "size": 2.0185546875,
          "content": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Del deletes the entry with the given key from o.\nfunc (o *Object) Del(key string) {\n\tif o == nil {\n\t\treturn\n\t}\n\tif !o.keysUnescaped && strings.IndexByte(key, '\\\\') < 0 {\n\t\t// Fast path - try searching for the key without object keys unescaping.\n\t\tfor i, kv := range o.kvs {\n\t\t\tif kv.k == key {\n\t\t\t\to.kvs = append(o.kvs[:i], o.kvs[i+1:]...)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slow path - unescape object keys before item search.\n\to.unescapeKeys()\n\n\tfor i, kv := range o.kvs {\n\t\tif kv.k == key {\n\t\t\to.kvs = append(o.kvs[:i], o.kvs[i+1:]...)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Del deletes the entry with the given key from array or object v.\nfunc (v *Value) Del(key string) {\n\tif v == nil {\n\t\treturn\n\t}\n\tif v.t == TypeObject {\n\t\tv.o.Del(key)\n\t\treturn\n\t}\n\tif v.t == TypeArray {\n\t\tn, err := strconv.Atoi(key)\n\t\tif err != nil || n < 0 || n >= len(v.a) {\n\t\t\treturn\n\t\t}\n\t\tv.a = append(v.a[:n], v.a[n+1:]...)\n\t}\n}\n\n// Set sets (key, value) entry in the o.\n//\n// The value must be unchanged during o lifetime.\nfunc (o *Object) Set(key string, value *Value) {\n\tif o == nil {\n\t\treturn\n\t}\n\tif value == nil {\n\t\tvalue = valueNull\n\t}\n\to.unescapeKeys()\n\n\t// Try substituting already existing entry with the given key.\n\tfor i := range o.kvs {\n\t\tkv := &o.kvs[i]\n\t\tif kv.k == key {\n\t\t\tkv.v = value\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Add new entry.\n\tkv := o.getKV()\n\tkv.k = key\n\tkv.v = value\n}\n\n// Set sets (key, value) entry in the array or object v.\n//\n// The value must be unchanged during v lifetime.\nfunc (v *Value) Set(key string, value *Value) {\n\tif v == nil {\n\t\treturn\n\t}\n\tif v.t == TypeObject {\n\t\tv.o.Set(key, value)\n\t\treturn\n\t}\n\tif v.t == TypeArray {\n\t\tidx, err := strconv.Atoi(key)\n\t\tif err != nil || idx < 0 {\n\t\t\treturn\n\t\t}\n\t\tv.SetArrayItem(idx, value)\n\t}\n}\n\n// SetArrayItem sets the value in the array v at idx position.\n//\n// The value must be unchanged during v lifetime.\nfunc (v *Value) SetArrayItem(idx int, value *Value) {\n\tif v == nil || v.t != TypeArray {\n\t\treturn\n\t}\n\tfor idx >= len(v.a) {\n\t\tv.a = append(v.a, valueNull)\n\t}\n\tv.a[idx] = value\n}\n"
        },
        {
          "name": "update_example_test.go",
          "type": "blob",
          "size": 1.337890625,
          "content": "package fastjson_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc ExampleObject_Del() {\n\tv := fastjson.MustParse(`{\"foo\": 123, \"bar\": [1,2], \"baz\": \"xyz\"}`)\n\to, err := v.Object()\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot otain object: %s\", err)\n\t}\n\tfmt.Printf(\"%s\\n\", o)\n\n\to.Del(\"bar\")\n\tfmt.Printf(\"%s\\n\", o)\n\n\to.Del(\"foo\")\n\tfmt.Printf(\"%s\\n\", o)\n\n\to.Del(\"baz\")\n\tfmt.Printf(\"%s\\n\", o)\n\n\t// Output:\n\t// {\"foo\":123,\"bar\":[1,2],\"baz\":\"xyz\"}\n\t// {\"foo\":123,\"baz\":\"xyz\"}\n\t// {\"baz\":\"xyz\"}\n\t// {}\n}\n\nfunc ExampleValue_Del() {\n\tv := fastjson.MustParse(`{\"foo\": 123, \"bar\": [1,2], \"baz\": \"xyz\"}`)\n\tfmt.Printf(\"%s\\n\", v)\n\n\tv.Del(\"foo\")\n\tfmt.Printf(\"%s\\n\", v)\n\n\tv.Get(\"bar\").Del(\"0\")\n\tfmt.Printf(\"%s\\n\", v)\n\n\t// Output:\n\t// {\"foo\":123,\"bar\":[1,2],\"baz\":\"xyz\"}\n\t// {\"bar\":[1,2],\"baz\":\"xyz\"}\n\t// {\"bar\":[2],\"baz\":\"xyz\"}\n}\n\nfunc ExampleValue_Set() {\n\tv := fastjson.MustParse(`{\"foo\":1,\"bar\":[2,3]}`)\n\n\t// Replace `foo` value with \"xyz\"\n\tv.Set(\"foo\", fastjson.MustParse(`\"xyz\"`))\n\t// Add \"newv\":123\n\tv.Set(\"newv\", fastjson.MustParse(`123`))\n\tfmt.Printf(\"%s\\n\", v)\n\n\t// Replace `bar.1` with {\"x\":\"y\"}\n\tv.Get(\"bar\").Set(\"1\", fastjson.MustParse(`{\"x\":\"y\"}`))\n\t// Add `bar.3=\"qwe\"\n\tv.Get(\"bar\").Set(\"3\", fastjson.MustParse(`\"qwe\"`))\n\tfmt.Printf(\"%s\\n\", v)\n\n\t// Output:\n\t// {\"foo\":\"xyz\",\"bar\":[2,3],\"newv\":123}\n\t// {\"foo\":\"xyz\",\"bar\":[2,{\"x\":\"y\"},null,\"qwe\"],\"newv\":123}\n}\n"
        },
        {
          "name": "update_test.go",
          "type": "blob",
          "size": 2.220703125,
          "content": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectDelSet(t *testing.T) {\n\tvar p Parser\n\tvar o *Object\n\n\to.Del(\"xx\")\n\n\tv, err := p.Parse(`{\"fo\\no\": \"bar\", \"x\": [1,2,3]}`)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error during parse: %s\", err)\n\t}\n\to, err = v.Object()\n\tif err != nil {\n\t\tt.Fatalf(\"cannot obtain object: %s\", err)\n\t}\n\n\t// Delete x\n\to.Del(\"x\")\n\tif o.Len() != 1 {\n\t\tt.Fatalf(\"unexpected number of items left; got %d; want %d\", o.Len(), 1)\n\t}\n\n\t// Try deleting non-existing value\n\to.Del(\"xxx\")\n\tif o.Len() != 1 {\n\t\tt.Fatalf(\"unexpected number of items left; got %d; want %d\", o.Len(), 1)\n\t}\n\n\t// Set new value\n\tvNew := MustParse(`{\"foo\":[1,2,3]}`)\n\to.Set(\"new_key\", vNew)\n\n\t// Delete item with escaped key\n\to.Del(\"fo\\no\")\n\tif o.Len() != 1 {\n\t\tt.Fatalf(\"unexpected number of items left; got %d; want %d\", o.Len(), 1)\n\t}\n\n\tstr := o.String()\n\tstrExpected := `{\"new_key\":{\"foo\":[1,2,3]}}`\n\tif str != strExpected {\n\t\tt.Fatalf(\"unexpected string representation for o: got %q; want %q\", str, strExpected)\n\t}\n\n\t// Set and Del function as no-op on nil value\n\to = nil\n\to.Del(\"x\")\n\to.Set(\"x\", MustParse(`[3]`))\n}\n\nfunc TestValueDelSet(t *testing.T) {\n\tvar p Parser\n\tv, err := p.Parse(`{\"xx\": 123, \"x\": [1,2,3]}`)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error during parse: %s\", err)\n\t}\n\n\t// Delete xx\n\tv.Del(\"xx\")\n\tn := v.GetObject().Len()\n\tif n != 1 {\n\t\tt.Fatalf(\"unexpected number of items left; got %d; want %d\", n, 1)\n\t}\n\n\t// Try deleting non-existing value in the array\n\tva := v.Get(\"x\")\n\tva.Del(\"foobar\")\n\n\t// Delete middle element in the array\n\tva.Del(\"1\")\n\ta := v.GetArray(\"x\")\n\tif len(a) != 2 {\n\t\tt.Fatalf(\"unexpected number of items left in the array; got %d; want %d\", len(a), 2)\n\t}\n\n\t// Update the first element in the array\n\tvNew := MustParse(`\"foobar\"`)\n\tva.Set(\"0\", vNew)\n\n\t// Add third element to the array\n\tvNew = MustParse(`[3]`)\n\tva.Set(\"3\", vNew)\n\n\t// Add invalid array index to the array\n\tva.Set(\"invalid\", MustParse(`\"nonsense\"`))\n\n\tstr := v.String()\n\tstrExpected := `{\"x\":[\"foobar\",3,null,[3]]}`\n\tif str != strExpected {\n\t\tt.Fatalf(\"unexpected string representation for o: got %q; want %q\", str, strExpected)\n\t}\n\n\t// Set and Del function as no-op on nil value\n\tv = nil\n\tv.Del(\"x\")\n\tv.Set(\"x\", MustParse(`[]`))\n\tv.SetArrayItem(1, MustParse(`[]`))\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 0.5078125,
          "content": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"unsafe\"\n)\n\nfunc b2s(b []byte) string {\n\treturn *(*string)(unsafe.Pointer(&b))\n}\n\nfunc s2b(s string) (b []byte) {\n\tstrh := (*reflect.StringHeader)(unsafe.Pointer(&s))\n\tsh := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n\tsh.Data = strh.Data\n\tsh.Len = strh.Len\n\tsh.Cap = strh.Len\n\treturn b\n}\n\nconst maxStartEndStringLen = 80\n\nfunc startEndString(s string) string {\n\tif len(s) <= maxStartEndStringLen {\n\t\treturn s\n\t}\n\tstart := s[:40]\n\tend := s[len(s)-40:]\n\treturn start + \"...\" + end\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 0.76171875,
          "content": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestStartEndString(t *testing.T) {\n\tf := func(s, expectedResult string) {\n\t\tt.Helper()\n\t\tresult := startEndString(s)\n\t\tif result != expectedResult {\n\t\t\tt.Fatalf(\"unexpected result for startEndString(%q); got %q; want %q\", s, result, expectedResult)\n\t\t}\n\t}\n\tf(\"\", \"\")\n\tf(\"foo\", \"foo\")\n\n\tgetString := func(n int) string {\n\t\tb := make([]byte, 0, n)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tb = append(b, 'a'+byte(i%26))\n\t\t}\n\t\treturn string(b)\n\t}\n\ts := getString(maxStartEndStringLen)\n\tf(s, s)\n\n\tf(getString(maxStartEndStringLen+1), \"abcdefghijklmnopqrstuvwxyzabcdefghijklmn...pqrstuvwxyzabcdefghijklmnopqrstuvwxyzabc\")\n\tf(getString(100*maxStartEndStringLen), \"abcdefghijklmnopqrstuvwxyzabcdefghijklmn...efghijklmnopqrstuvwxyzabcdefghijklmnopqr\")\n}\n"
        },
        {
          "name": "validate.go",
          "type": "blob",
          "size": 6.48828125,
          "content": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Validate validates JSON s.\nfunc Validate(s string) error {\n\ts = skipWS(s)\n\n\ttail, err := validateValue(s)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"cannot parse JSON: %s; unparsed tail: %q\", err, startEndString(tail))\n\t}\n\ttail = skipWS(tail)\n\tif len(tail) > 0 {\n\t\treturn fmt.Errorf(\"unexpected tail: %q\", startEndString(tail))\n\t}\n\treturn nil\n}\n\n// ValidateBytes validates JSON b.\nfunc ValidateBytes(b []byte) error {\n\treturn Validate(b2s(b))\n}\n\nfunc validateValue(s string) (string, error) {\n\tif len(s) == 0 {\n\t\treturn s, fmt.Errorf(\"cannot parse empty string\")\n\t}\n\n\tif s[0] == '{' {\n\t\ttail, err := validateObject(s[1:])\n\t\tif err != nil {\n\t\t\treturn tail, fmt.Errorf(\"cannot parse object: %s\", err)\n\t\t}\n\t\treturn tail, nil\n\t}\n\tif s[0] == '[' {\n\t\ttail, err := validateArray(s[1:])\n\t\tif err != nil {\n\t\t\treturn tail, fmt.Errorf(\"cannot parse array: %s\", err)\n\t\t}\n\t\treturn tail, nil\n\t}\n\tif s[0] == '\"' {\n\t\tsv, tail, err := validateString(s[1:])\n\t\tif err != nil {\n\t\t\treturn tail, fmt.Errorf(\"cannot parse string: %s\", err)\n\t\t}\n\t\t// Scan the string for control chars.\n\t\tfor i := 0; i < len(sv); i++ {\n\t\t\tif sv[i] < 0x20 {\n\t\t\t\treturn tail, fmt.Errorf(\"string cannot contain control char 0x%02X\", sv[i])\n\t\t\t}\n\t\t}\n\t\treturn tail, nil\n\t}\n\tif s[0] == 't' {\n\t\tif len(s) < len(\"true\") || s[:len(\"true\")] != \"true\" {\n\t\t\treturn s, fmt.Errorf(\"unexpected value found: %q\", s)\n\t\t}\n\t\treturn s[len(\"true\"):], nil\n\t}\n\tif s[0] == 'f' {\n\t\tif len(s) < len(\"false\") || s[:len(\"false\")] != \"false\" {\n\t\t\treturn s, fmt.Errorf(\"unexpected value found: %q\", s)\n\t\t}\n\t\treturn s[len(\"false\"):], nil\n\t}\n\tif s[0] == 'n' {\n\t\tif len(s) < len(\"null\") || s[:len(\"null\")] != \"null\" {\n\t\t\treturn s, fmt.Errorf(\"unexpected value found: %q\", s)\n\t\t}\n\t\treturn s[len(\"null\"):], nil\n\t}\n\n\ttail, err := validateNumber(s)\n\tif err != nil {\n\t\treturn tail, fmt.Errorf(\"cannot parse number: %s\", err)\n\t}\n\treturn tail, nil\n}\n\nfunc validateArray(s string) (string, error) {\n\ts = skipWS(s)\n\tif len(s) == 0 {\n\t\treturn s, fmt.Errorf(\"missing ']'\")\n\t}\n\tif s[0] == ']' {\n\t\treturn s[1:], nil\n\t}\n\n\tfor {\n\t\tvar err error\n\n\t\ts = skipWS(s)\n\t\ts, err = validateValue(s)\n\t\tif err != nil {\n\t\t\treturn s, fmt.Errorf(\"cannot parse array value: %s\", err)\n\t\t}\n\n\t\ts = skipWS(s)\n\t\tif len(s) == 0 {\n\t\t\treturn s, fmt.Errorf(\"unexpected end of array\")\n\t\t}\n\t\tif s[0] == ',' {\n\t\t\ts = s[1:]\n\t\t\tcontinue\n\t\t}\n\t\tif s[0] == ']' {\n\t\t\ts = s[1:]\n\t\t\treturn s, nil\n\t\t}\n\t\treturn s, fmt.Errorf(\"missing ',' after array value\")\n\t}\n}\n\nfunc validateObject(s string) (string, error) {\n\ts = skipWS(s)\n\tif len(s) == 0 {\n\t\treturn s, fmt.Errorf(\"missing '}'\")\n\t}\n\tif s[0] == '}' {\n\t\treturn s[1:], nil\n\t}\n\n\tfor {\n\t\tvar err error\n\n\t\t// Parse key.\n\t\ts = skipWS(s)\n\t\tif len(s) == 0 || s[0] != '\"' {\n\t\t\treturn s, fmt.Errorf(`cannot find opening '\"\" for object key`)\n\t\t}\n\n\t\tvar key string\n\t\tkey, s, err = validateKey(s[1:])\n\t\tif err != nil {\n\t\t\treturn s, fmt.Errorf(\"cannot parse object key: %s\", err)\n\t\t}\n\t\t// Scan the key for control chars.\n\t\tfor i := 0; i < len(key); i++ {\n\t\t\tif key[i] < 0x20 {\n\t\t\t\treturn s, fmt.Errorf(\"object key cannot contain control char 0x%02X\", key[i])\n\t\t\t}\n\t\t}\n\t\ts = skipWS(s)\n\t\tif len(s) == 0 || s[0] != ':' {\n\t\t\treturn s, fmt.Errorf(\"missing ':' after object key\")\n\t\t}\n\t\ts = s[1:]\n\n\t\t// Parse value\n\t\ts = skipWS(s)\n\t\ts, err = validateValue(s)\n\t\tif err != nil {\n\t\t\treturn s, fmt.Errorf(\"cannot parse object value: %s\", err)\n\t\t}\n\t\ts = skipWS(s)\n\t\tif len(s) == 0 {\n\t\t\treturn s, fmt.Errorf(\"unexpected end of object\")\n\t\t}\n\t\tif s[0] == ',' {\n\t\t\ts = s[1:]\n\t\t\tcontinue\n\t\t}\n\t\tif s[0] == '}' {\n\t\t\treturn s[1:], nil\n\t\t}\n\t\treturn s, fmt.Errorf(\"missing ',' after object value\")\n\t}\n}\n\n// validateKey is similar to validateString, but is optimized\n// for typical object keys, which are quite small and have no escape sequences.\nfunc validateKey(s string) (string, string, error) {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == '\"' {\n\t\t\t// Fast path - the key doesn't contain escape sequences.\n\t\t\treturn s[:i], s[i+1:], nil\n\t\t}\n\t\tif s[i] == '\\\\' {\n\t\t\t// Slow path - the key contains escape sequences.\n\t\t\treturn validateString(s)\n\t\t}\n\t}\n\treturn \"\", s, fmt.Errorf(`missing closing '\"'`)\n}\n\nfunc validateString(s string) (string, string, error) {\n\t// Try fast path - a string without escape sequences.\n\tif n := strings.IndexByte(s, '\"'); n >= 0 && strings.IndexByte(s[:n], '\\\\') < 0 {\n\t\treturn s[:n], s[n+1:], nil\n\t}\n\n\t// Slow path - escape sequences are present.\n\trs, tail, err := parseRawString(s)\n\tif err != nil {\n\t\treturn rs, tail, err\n\t}\n\tfor {\n\t\tn := strings.IndexByte(rs, '\\\\')\n\t\tif n < 0 {\n\t\t\treturn rs, tail, nil\n\t\t}\n\t\tn++\n\t\tif n >= len(rs) {\n\t\t\treturn rs, tail, fmt.Errorf(\"BUG: parseRawString returned invalid string with trailing backslash: %q\", rs)\n\t\t}\n\t\tch := rs[n]\n\t\trs = rs[n+1:]\n\t\tswitch ch {\n\t\tcase '\"', '\\\\', '/', 'b', 'f', 'n', 'r', 't':\n\t\t\t// Valid escape sequences - see http://json.org/\n\t\t\tbreak\n\t\tcase 'u':\n\t\t\tif len(rs) < 4 {\n\t\t\t\treturn rs, tail, fmt.Errorf(`too short escape sequence: \\u%s`, rs)\n\t\t\t}\n\t\t\txs := rs[:4]\n\t\t\t_, err := strconv.ParseUint(xs, 16, 16)\n\t\t\tif err != nil {\n\t\t\t\treturn rs, tail, fmt.Errorf(`invalid escape sequence \\u%s: %s`, xs, err)\n\t\t\t}\n\t\t\trs = rs[4:]\n\t\tdefault:\n\t\t\treturn rs, tail, fmt.Errorf(`unknown escape sequence \\%c`, ch)\n\t\t}\n\t}\n}\n\nfunc validateNumber(s string) (string, error) {\n\tif len(s) == 0 {\n\t\treturn s, fmt.Errorf(\"zero-length number\")\n\t}\n\tif s[0] == '-' {\n\t\ts = s[1:]\n\t\tif len(s) == 0 {\n\t\t\treturn s, fmt.Errorf(\"missing number after minus\")\n\t\t}\n\t}\n\ti := 0\n\tfor i < len(s) {\n\t\tif s[i] < '0' || s[i] > '9' {\n\t\t\tbreak\n\t\t}\n\t\ti++\n\t}\n\tif i <= 0 {\n\t\treturn s, fmt.Errorf(\"expecting 0..9 digit, got %c\", s[0])\n\t}\n\tif s[0] == '0' && i != 1 {\n\t\treturn s, fmt.Errorf(\"unexpected number starting from 0\")\n\t}\n\tif i >= len(s) {\n\t\treturn \"\", nil\n\t}\n\tif s[i] == '.' {\n\t\t// Validate fractional part\n\t\ts = s[i+1:]\n\t\tif len(s) == 0 {\n\t\t\treturn s, fmt.Errorf(\"missing fractional part\")\n\t\t}\n\t\ti = 0\n\t\tfor i < len(s) {\n\t\t\tif s[i] < '0' || s[i] > '9' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\tif i == 0 {\n\t\t\treturn s, fmt.Errorf(\"expecting 0..9 digit in fractional part, got %c\", s[0])\n\t\t}\n\t\tif i >= len(s) {\n\t\t\treturn \"\", nil\n\t\t}\n\t}\n\tif s[i] == 'e' || s[i] == 'E' {\n\t\t// Validate exponent part\n\t\ts = s[i+1:]\n\t\tif len(s) == 0 {\n\t\t\treturn s, fmt.Errorf(\"missing exponent part\")\n\t\t}\n\t\tif s[0] == '-' || s[0] == '+' {\n\t\t\ts = s[1:]\n\t\t\tif len(s) == 0 {\n\t\t\t\treturn s, fmt.Errorf(\"missing exponent part\")\n\t\t\t}\n\t\t}\n\t\ti = 0\n\t\tfor i < len(s) {\n\t\t\tif s[i] < '0' || s[i] > '9' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\tif i == 0 {\n\t\t\treturn s, fmt.Errorf(\"expecting 0..9 digit in exponent part, got %c\", s[0])\n\t\t}\n\t\tif i >= len(s) {\n\t\t\treturn \"\", nil\n\t\t}\n\t}\n\treturn s[i:], nil\n}\n"
        },
        {
          "name": "validate_test.go",
          "type": "blob",
          "size": 2.8818359375,
          "content": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestValidateSimple(t *testing.T) {\n\tif err := Validate(`123`); err != nil {\n\t\tt.Fatalf(\"cannot validate number: %s\", err)\n\t}\n\tif err := Validate(`\"foobar\"`); err != nil {\n\t\tt.Fatalf(\"cannot validate string: %s\", err)\n\t}\n\tif err := Validate(`null`); err != nil {\n\t\tt.Fatalf(\"cannot validate null: %s\", err)\n\t}\n\tif err := Validate(`true`); err != nil {\n\t\tt.Fatalf(\"cannot validate true: %s\", err)\n\t}\n\tif err := Validate(`false`); err != nil {\n\t\tt.Fatalf(\"cannot validate false: %s\", err)\n\t}\n\tif err := Validate(`foobar`); err == nil {\n\t\tt.Fatalf(\"validation unexpectedly passed\")\n\t}\n\tif err := Validate(`XDF`); err == nil {\n\t\tt.Fatalf(\"validation unexpectedly passed\")\n\t}\n\n\tif err := ValidateBytes([]byte(`{\"foo\":[\"bar\", 123]}`)); err != nil {\n\t\tt.Fatalf(\"cannot validate valid JSON: %s\", err)\n\t}\n\tif err := ValidateBytes([]byte(`{\"foo\": bar`)); err == nil {\n\t\tt.Fatalf(\"validation unexpectedly passed\")\n\t}\n}\n\nfunc TestValidateNumberZeroLen(t *testing.T) {\n\ttail, err := validateNumber(\"\")\n\tif err == nil {\n\t\tt.Fatalf(\"expecting non-nil error\")\n\t}\n\tif tail != \"\" {\n\t\tt.Fatalf(\"unexpected non-empty tail: %q\", tail)\n\t}\n}\n\nfunc TestValidate(t *testing.T) {\n\tvar tests = []string{\n\t\t\"\",\n\t\t\"   \",\n\t\t\" z\",\n\t\t\" 1  1\",\n\t\t\" 1  {}\",\n\t\t\" 1  []\",\n\t\t\" 1  true\",\n\t\t\" 1  null\",\n\t\t\" 1  \\\"n\\\"\",\n\n\t\t// string\n\t\t`\"foo\"`,\n\t\t\"\\\"\\xe2\\x80\\xa8\\xe2\\x80\\xa9\\\"\", // line-sep and paragraph-sep\n\t\t` \"\\uaaaa\" `,\n\t\t`\"\\uz\"`,\n\t\t` \"\\`,\n\t\t` \"\\z`,\n\t\t\" \\\"f\\x00o\\\"\",  // control char\n\t\t\"\\\"foo\\nbar\\\"\", // control char\n\t\t`\"foo\\qw\"`,     // unknown escape sequence\n\t\t` \"foo`,\n\t\t` \"\\uazaa\" `,\n\t\t`\"\\\"\\\\\\/\\b\\f\\n\\r\\t\"`,\n\n\t\t// number\n\t\t\"1\",\n\t\t\"  0 \",\n\t\t\" 0e1 \",\n\t\t\" 0e+0 \",\n\t\t\" -0e+0 \",\n\t\t\"-0\",\n\t\t\"1e6\",\n\t\t\"1e+6\",\n\t\t\"-1e+6\",\n\t\t\"-0e+6\",\n\t\t\" -103e+1 \",\n\t\t\"-0.01e+006\",\n\t\t\"-z\",\n\t\t\"-\",\n\t\t\"1e\",\n\t\t\"1e+\",\n\t\t\" 03e+1 \",\n\t\t\" 1e.1 \",\n\t\t\" 00 \",\n\t\t\"1.e3\",\n\t\t\"01e+6\",\n\t\t\"-0.01e+0.6\",\n\t\t\"123.\",\n\t\t\"123.345\",\n\t\t\"001 \",\n\t\t\"001\",\n\n\t\t// object\n\t\t\"{}\",\n\t\t`{\"foo\": 3}`,\n\t\t\"{\\\"f\\x00oo\\\": 3}\",\n\t\t`{\"foo\\WW\": 4}`, // unknown escape sequence\n\t\t`{\"foo\": 3 \"bar\"}`,\n\t\t` {}    `,\n\t\tstrings.Repeat(`{\"f\":`, 1000) + \"{}\" + strings.Repeat(\"}\", 1000),\n\t\t`{\"foo\": [{\"\":3, \"4\": \"3\"}, 4, {}], \"t_wo\": 1}`,\n\t\t` {\"foo\": 2,\"fudge}`,\n\t\t`{{\"foo\": }}`,\n\t\t`{{\"foo\": [{\"\":3, 4: \"3\"}, 4, \"5\": {4}]}, \"t_wo\": 1}`,\n\t\t\"{\",\n\t\t`{\"foo\"`,\n\t\t`{\"foo\",f}`,\n\t\t`{\"foo\",`,\n\t\t`{\"foo\"f`,\n\t\t\"{}}\",\n\t\t`{\"foo\": 234`,\n\t\t`{\"foo\\\"bar\": 123}`,\n\t\t\"{\\n\\t\\\"foo\\\"  \\n\\b\\f: \\t123}\",\n\n\t\t// array\n\t\t`[]`,\n\t\t`[ 1, {}]`,\n\t\tstrings.Repeat(\"[\", 1000) + strings.Repeat(\"]\", 1000),\n\t\t`[1, 2, 3, 4, {}]`,\n\t\t`[`,\n\t\t`[1,`,\n\t\t`[1a`,\n\t\t`[]]`,\n\t\t`[1  `,\n\n\t\t// boolean\n\t\t\"true\",\n\t\t\"   true \",\n\t\t\"tree\",\n\t\t\"false\",\n\t\t\"  true f\",\n\t\t\"fals\",\n\t\t\"falsee\",\n\n\t\t// null\n\t\t\"null \",\n\t\t\" null \",\n\t\t\" nulll \",\n\t\t\"no\",\n\t}\n\tfor i, test := range tests {\n\t\tin := []byte(test)\n\t\tgot := ValidateBytes(in) == nil\n\t\texp := json.Valid(in)\n\n\t\tif got != exp {\n\t\t\tt.Errorf(\"#%d: %q got valid? %v, exp? %v\", i, in, got, exp)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "validate_timing_test.go",
          "type": "blob",
          "size": 1.2822265625,
          "content": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc BenchmarkValidate(b *testing.B) {\n\tb.Run(\"small\", func(b *testing.B) {\n\t\tbenchmarkValidate(b, smallFixture)\n\t})\n\tb.Run(\"medium\", func(b *testing.B) {\n\t\tbenchmarkValidate(b, mediumFixture)\n\t})\n\tb.Run(\"large\", func(b *testing.B) {\n\t\tbenchmarkValidate(b, largeFixture)\n\t})\n\tb.Run(\"canada\", func(b *testing.B) {\n\t\tbenchmarkValidate(b, canadaFixture)\n\t})\n\tb.Run(\"citm\", func(b *testing.B) {\n\t\tbenchmarkValidate(b, citmFixture)\n\t})\n\tb.Run(\"twitter\", func(b *testing.B) {\n\t\tbenchmarkValidate(b, twitterFixture)\n\t})\n}\n\nfunc benchmarkValidate(b *testing.B, s string) {\n\tb.Run(\"stdjson\", func(b *testing.B) {\n\t\tbenchmarkValidateStdJSON(b, s)\n\t})\n\tb.Run(\"fastjson\", func(b *testing.B) {\n\t\tbenchmarkValidateFastJSON(b, s)\n\t})\n}\n\nfunc benchmarkValidateStdJSON(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tbb := s2b(s)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tif !json.Valid(bb) {\n\t\t\t\tpanic(\"json.Valid unexpectedly returned false\")\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc benchmarkValidateFastJSON(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tif err := Validate(s); err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"unexpected error: %s\", err))\n\t\t\t}\n\t\t}\n\t})\n}\n"
        }
      ]
    }
  ]
}