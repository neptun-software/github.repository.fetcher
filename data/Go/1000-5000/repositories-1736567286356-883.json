{
  "metadata": {
    "timestamp": 1736567286356,
    "page": 883,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-gorm/gen",
      "stars": 2313,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.337890625,
          "content": "*.o\n*.a\n*.so\n_obj\n_test\n*.[568vq]\n[568vq].out\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n_testmain.go\n*.exe\n*.exe~\n*.test\n*.prof\n*.rar\n*.zip\n*.gz\n*.psd\n*.bmd\n*.cfg\n*.pptx\n*.log\n*nohup.out\n*settings.pyc\n*.sublime-project\n*.sublime-workspace\n!.gitkeep\n.DS_Store\n/.idea\n/.vscode\n__debug_bin\n/test/\n**/go.work\n**/go.work.sum\n\n*.db\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.486328125,
          "content": "run:\n  deadline: 30s\n  tests: false\n  skip-dirs-use-default: true\n  skip-dirs:\n    - test\n\nlinters-settings:\n  gofmt:\n    simplify: true\n  govet:\n    check-shadowing: true\n  goimports:\n    local-prefixes: gorm.io,gorm.io/gen\n  unused:\n    check-exported: false\n  revive:\n      min-confidence: 0.8\n\nlinters:\n  presets:\n    - unused\n  enable:\n    - govet\n    - revive\n    - bodyclose\n    - errcheck\n    - exportloopref\n    - staticcheck\n  disable:\n    - gofumpt\n\nissues:\n  exclude-use-default: false\n"
        },
        {
          "name": "License",
          "type": "blob",
          "size": 1.0712890625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2021-NOW  Jinzhu <wosmvp@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.7353515625,
          "content": "# GORM Gen\n\nFriendly & Safer GORM powered by Code Generation.\n\n[![Release](https://img.shields.io/github/v/release/go-gorm/gen)](https://github.com/go-gorm/gen/releases)\n[![Go Report Card](https://goreportcard.com/badge/github.com/go-gorm/gen)](https://goreportcard.com/report/github.com/go-gorm/gen)\n[![MIT license](https://img.shields.io/badge/license-MIT-brightgreen.svg)](https://opensource.org/licenses/MIT)\n[![OpenIssue](https://img.shields.io/github/issues/go-gorm/gen)](https://github.com/go-gorm/gen/issues?q=is%3Aopen+is%3Aissue)\n[![ClosedIssue](https://img.shields.io/github/issues-closed/go-gorm/gen)](https://github.com/go-gorm/gen/issues?q=is%3Aissue+is%3Aclosed)\n[![TODOs](https://badgen.net/https/api.tickgit.com/badgen/github.com/go-gorm/gen)](https://www.tickgit.com/browse?repo=github.com/go-gorm/gen)\n[![Go.Dev reference](https://img.shields.io/badge/go.dev-reference-blue?logo=go&logoColor=white)](https://pkg.go.dev/gorm.io/gen?tab=doc)\n\n## Overview\n\n- Idiomatic & Reusable API from Dynamic Raw SQL\n- 100% Type-safe DAO API without `interface{}`\n- Database To Struct follows GORM conventions\n- GORM under the hood, supports all features, plugins, DBMS that GORM supports\n\n## Getting Started\n\n* Gen Guides [https://gorm.io/gen/index.html](https://gorm.io/gen/index.html)\n* GORM Guides [http://gorm.io/docs](http://gorm.io/docs)\n\n## Maintainers\n\n[@riverchu](https://github.com/riverchu) [@iDer](https://github.com/idersec) [@qqxhb](https://github.com/qqxhb) [@dino-ma](https://github.com/dino-ma)\n\n[@jinzhu](https://github.com/jinzhu)\n\n## Contributing\n\n[You can help to deliver a better GORM/Gen, check out things you can do](https://gorm.io/contribute.html)\n\n## License\n\nReleased under the [MIT License](https://github.com/go-gorm/gen/blob/master/License)\n"
        },
        {
          "name": "condition.go",
          "type": "blob",
          "size": 1.5166015625,
          "content": "package gen\n\nimport (\n\t\"fmt\"\n\n\t\"gorm.io/datatypes\"\n\t\"gorm.io/gen/field\"\n\t\"gorm.io/gorm/clause\"\n)\n\n// Cond convert expression array to condition array\nfunc Cond(exprs ...clause.Expression) []Condition {\n\treturn exprToCondition(exprs...)\n}\n\nvar _ Condition = &condContainer{}\n\ntype condContainer struct {\n\tvalue interface{}\n\terr   error\n}\n\nfunc (c *condContainer) BeCond() interface{} { return c.value }\nfunc (c *condContainer) CondError() error    { return c.err }\n\nfunc exprToCondition(exprs ...clause.Expression) []Condition {\n\tconds := make([]Condition, 0, len(exprs))\n\tfor _, e := range exprs {\n\t\tswitch e := e.(type) {\n\t\tcase *datatypes.JSONQueryExpression, *datatypes.JSONOverlapsExpression, *datatypes.JSONArrayExpression:\n\t\t\tconds = append(conds, &condContainer{value: e})\n\t\tdefault:\n\t\t\tconds = append(conds, &condContainer{err: fmt.Errorf(\"unsupported Expression %T to converted to Condition\", e)})\n\t\t}\n\t}\n\treturn conds\n}\n\nfunc condToExpression(conds []Condition) ([]clause.Expression, error) {\n\tif len(conds) == 0 {\n\t\treturn nil, nil\n\t}\n\texprs := make([]clause.Expression, 0, len(conds))\n\tfor _, cond := range conds {\n\t\tif cond == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := cond.CondError(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch cond.(type) {\n\t\tcase *condContainer, field.Expr, SubQuery:\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unsupported condition: %+v\", cond)\n\t\t}\n\n\t\tswitch e := cond.BeCond().(type) {\n\t\tcase []clause.Expression:\n\t\t\texprs = append(exprs, e...)\n\t\tcase clause.Expression:\n\t\t\texprs = append(exprs, e)\n\t\t}\n\t}\n\treturn exprs, nil\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 5.330078125,
          "content": "package gen\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/utils/tests\"\n\n\t\"gorm.io/gen/internal/model\"\n)\n\n// GenerateMode generate mode\ntype GenerateMode uint\n\nconst (\n\t// WithDefaultQuery create default query in generated code\n\tWithDefaultQuery GenerateMode = 1 << iota\n\n\t// WithoutContext generate code without context constrain\n\tWithoutContext\n\n\t// WithQueryInterface generate code with exported interface object\n\tWithQueryInterface\n)\n\n// Config generator's basic configuration\ntype Config struct {\n\tdb *gorm.DB // db connection\n\n\tOutPath      string // query code path\n\tOutFile      string // query code file name, default: gen.go\n\tModelPkgPath string // generated model code's package name\n\tWithUnitTest bool   // generate unit test for query code\n\n\t// generate model global configuration\n\tFieldNullable     bool // generate pointer when field is nullable\n\tFieldCoverable    bool // generate pointer when field has default value, to fix problem zero value cannot be assign: https://gorm.io/docs/create.html#Default-Values\n\tFieldSignable     bool // detect integer field's unsigned type, adjust generated data type\n\tFieldWithIndexTag bool // generate with gorm index tag\n\tFieldWithTypeTag  bool // generate with gorm column type tag\n\n\tMode GenerateMode // generate mode\n\n\tqueryPkgName   string // generated query code's package name\n\tmodelPkgPath   string // model pkg path in target project\n\tdbNameOpts     []model.SchemaNameOpt\n\timportPkgPaths []string\n\n\t// name strategy for syncing table from db\n\ttableNameNS func(tableName string) (targetTableName string)\n\tmodelNameNS func(tableName string) (modelName string)\n\tfileNameNS  func(tableName string) (fileName string)\n\n\tdataTypeMap    map[string]func(columnType gorm.ColumnType) (dataType string)\n\tfieldJSONTagNS func(columnName string) (tagContent string)\n\n\tmodelOpts []ModelOpt\n}\n\n// WithOpts set global  model options\nfunc (cfg *Config) WithOpts(opts ...ModelOpt) {\n\tif cfg.modelOpts == nil {\n\t\tcfg.modelOpts = opts\n\t} else {\n\t\tcfg.modelOpts = append(cfg.modelOpts, opts...)\n\t}\n}\n\n// WithDbNameOpts set get database name function\nfunc (cfg *Config) WithDbNameOpts(opts ...model.SchemaNameOpt) {\n\tif cfg.dbNameOpts == nil {\n\t\tcfg.dbNameOpts = opts\n\t} else {\n\t\tcfg.dbNameOpts = append(cfg.dbNameOpts, opts...)\n\t}\n}\n\n// WithTableNameStrategy specify table name naming strategy, only work when syncing table from db\nfunc (cfg *Config) WithTableNameStrategy(ns func(tableName string) (targetTableName string)) {\n\tcfg.tableNameNS = ns\n}\n\n// WithModelNameStrategy specify model struct name naming strategy, only work when syncing table from db\nfunc (cfg *Config) WithModelNameStrategy(ns func(tableName string) (modelName string)) {\n\tcfg.modelNameNS = ns\n}\n\n// WithFileNameStrategy specify file name naming strategy, only work when syncing table from db\nfunc (cfg *Config) WithFileNameStrategy(ns func(tableName string) (fileName string)) {\n\tcfg.fileNameNS = ns\n}\n\n// WithDataTypeMap specify data type mapping relationship, only work when syncing table from db\nfunc (cfg *Config) WithDataTypeMap(newMap map[string]func(columnType gorm.ColumnType) (dataType string)) {\n\tcfg.dataTypeMap = newMap\n}\n\n// WithJSONTagNameStrategy specify json tag naming strategy\nfunc (cfg *Config) WithJSONTagNameStrategy(ns func(columnName string) (tagContent string)) {\n\tcfg.fieldJSONTagNS = ns\n}\n\n// WithImportPkgPath specify import package path\nfunc (cfg *Config) WithImportPkgPath(paths ...string) {\n\tfor i, path := range paths {\n\t\tpath = strings.TrimSpace(path)\n\t\tif len(path) > 0 && path[0] != '\"' && path[len(path)-1] != '\"' { // without quote\n\t\t\tpath = `\"` + path + `\"`\n\t\t}\n\t\tpaths[i] = path\n\t}\n\tcfg.importPkgPaths = append(cfg.importPkgPaths, paths...)\n}\n\n// WithDataTypesNullType configures the types of fields to use their datatypes nullable counterparts.\n/**\n *\n * @param {boolean} all - If true, all basic types of fields will be replaced with their `datatypes.Null[T]` types.\n *                        If false, only fields that are allowed to be null will be replaced with `datatypes.Null[T]` types.\n *\n * Examples:\n *\n * When `all` is true:\n * - `int64` will be replaced with `datatypes.NullInt64`\n * - `string` will be replaced with `datatypes.NullString`\n *\n * When `all` is false:\n * - Only fields that can be null (e.g., `*string` or `*int`) will be replaced with `datatypes.Null[T]` types.\n *\n * Note:\n * Ensure that proper error handling is implemented when converting\n * fields to their `datatypes.Null[T]` types to avoid runtime issues.\n */\nfunc (cfg *Config) WithDataTypesNullType(all bool) {\n\tcfg.WithOpts(WithDataTypesNullType(all))\n}\n\n// Revise format path and db\nfunc (cfg *Config) Revise() (err error) {\n\tif strings.TrimSpace(cfg.ModelPkgPath) == \"\" {\n\t\tcfg.ModelPkgPath = model.DefaultModelPkg\n\t}\n\n\tcfg.OutPath, err = filepath.Abs(cfg.OutPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"outpath is invalid: %w\", err)\n\t}\n\tif cfg.OutPath == \"\" {\n\t\tcfg.OutPath = fmt.Sprintf(\".%squery%s\", string(os.PathSeparator), string(os.PathSeparator))\n\t}\n\tif cfg.OutFile == \"\" {\n\t\tcfg.OutFile = filepath.Join(cfg.OutPath, \"gen.go\")\n\t} else if !strings.Contains(cfg.OutFile, string(os.PathSeparator)) {\n\t\tcfg.OutFile = filepath.Join(cfg.OutPath, cfg.OutFile)\n\t}\n\tcfg.queryPkgName = filepath.Base(cfg.OutPath)\n\n\tif cfg.db == nil {\n\t\tcfg.db, _ = gorm.Open(tests.DummyDialector{})\n\t}\n\n\treturn nil\n}\n\nfunc (cfg *Config) judgeMode(mode GenerateMode) bool { return cfg.Mode&mode != 0 }\n"
        },
        {
          "name": "do.go",
          "type": "blob",
          "size": 27.65234375,
          "content": "package gen\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/callbacks\"\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/schema\"\n\n\t\"gorm.io/gen/field\"\n\t\"gorm.io/gen/helper\"\n)\n\n// ResultInfo query/execute info\ntype ResultInfo struct {\n\tRowsAffected int64\n\tError        error\n}\n\nvar _ Dao = new(DO)\n\n// DO (data object): implement basic query methods\n// the structure embedded with a *gorm.DB, and has a element item \"alias\" will be used when used as a sub query\ntype DO struct {\n\t*DOConfig\n\tdb        *gorm.DB\n\talias     string // for subquery\n\tmodelType reflect.Type\n\ttableName string\n\n\tbackfillData interface{}\n}\n\nfunc (d DO) getInstance(db *gorm.DB) *DO {\n\td.db = db\n\treturn &d\n}\n\ntype doOptions func(*gorm.DB) *gorm.DB\n\nvar (\n\t// Debug use DB in debug mode\n\tDebug doOptions = func(db *gorm.DB) *gorm.DB { return db.Debug() }\n)\n\n// UseDB specify a db connection(*gorm.DB)\nfunc (d *DO) UseDB(db *gorm.DB, opts ...DOOption) {\n\tdb = db.Session(&gorm.Session{Context: context.Background()})\n\td.db = db\n\tconfig := &DOConfig{}\n\tfor _, opt := range opts {\n\t\tif opt != nil {\n\t\t\tif applyErr := opt.Apply(config); applyErr != nil {\n\t\t\t\tpanic(applyErr)\n\t\t\t}\n\t\t}\n\t}\n\td.DOConfig = config\n}\n\n// ReplaceDB replace db connection\nfunc (d *DO) ReplaceDB(db *gorm.DB) {\n\td.db = db.Session(&gorm.Session{})\n}\n\n// ReplaceConnPool replace db connection pool\nfunc (d *DO) ReplaceConnPool(pool gorm.ConnPool) {\n\td.db = d.db.Session(&gorm.Session{Initialized: true}).Session(&gorm.Session{})\n\td.db.Statement.ConnPool = pool\n}\n\n// UseModel specify a data model structure as a source for table name\nfunc (d *DO) UseModel(model interface{}) {\n\td.modelType = d.indirect(model)\n\td.db = d.db.Model(model).Session(&gorm.Session{})\n\terr := d.db.Statement.Parse(model)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"Cannot parse model: %+v\\n%w\", model, err))\n\t}\n\td.tableName = d.db.Statement.Schema.Table\n}\n\nfunc (d *DO) indirect(value interface{}) reflect.Type {\n\tmt := reflect.TypeOf(value)\n\tif mt.Kind() == reflect.Ptr {\n\t\tmt = mt.Elem()\n\t}\n\treturn mt\n}\n\n// UseTable specify table name\nfunc (d *DO) UseTable(tableName string) {\n\td.db = d.db.Table(tableName).Session(new(gorm.Session))\n\t//d.db.Statement.Schema.Table=tableName\n\td.tableName = tableName\n}\n\n// TableName return table name\nfunc (d DO) TableName() string {\n\treturn d.tableName\n}\n\n// Returning backfill data\nfunc (d DO) Returning(value interface{}, columns ...string) Dao {\n\td.backfillData = value\n\n\tvar targetCulumns []clause.Column\n\tfor _, column := range columns {\n\t\ttargetCulumns = append(targetCulumns, clause.Column{Name: column})\n\t}\n\td.db = d.db.Clauses(clause.Returning{Columns: targetCulumns})\n\treturn &d\n}\n\n// Session replace db with new session\nfunc (d *DO) Session(config *gorm.Session) Dao { return d.getInstance(d.db.Session(config)) }\n\n// UnderlyingDB return the underlying database connection\nfunc (d *DO) UnderlyingDB() *gorm.DB { return d.underlyingDB() }\n\n// Quote return qutoed data\nfunc (d *DO) Quote(raw string) string { return d.db.Statement.Quote(raw) }\n\n// Build implement the interface of claues.Expression\n// only call WHERE clause's Build\nfunc (d *DO) Build(builder clause.Builder) {\n\tfor _, e := range d.buildCondition() {\n\t\te.Build(builder)\n\t}\n}\n\nfunc (d *DO) buildCondition() []clause.Expression {\n\treturn d.db.Statement.BuildCondition(d.db)\n}\n\n// underlyingDO return self\nfunc (d *DO) underlyingDO() *DO { return d }\n\n// underlyingDB return self.db\nfunc (d *DO) underlyingDB() *gorm.DB { return d.db }\n\nfunc (d *DO) withError(err error) *DO {\n\tif err == nil {\n\t\treturn d\n\t}\n\n\tnewDB := d.db.Session(new(gorm.Session))\n\t_ = newDB.AddError(err)\n\treturn d.getInstance(newDB)\n}\n\n// BeCond implements Condition\nfunc (d *DO) BeCond() interface{} { return d.buildCondition() }\n\n// CondError implements Condition\nfunc (d *DO) CondError() error { return nil }\n\n// Debug return a DO with db in debug mode\nfunc (d *DO) Debug() Dao { return d.getInstance(d.db.Debug()) }\n\n// WithContext return a DO with db with context\nfunc (d *DO) WithContext(ctx context.Context) Dao { return d.getInstance(d.db.WithContext(ctx)) }\n\n// Clauses specify Clauses\nfunc (d *DO) Clauses(conds ...clause.Expression) Dao {\n\tif err := checkConds(conds); err != nil {\n\t\tnewDB := d.db.Session(new(gorm.Session))\n\t\t_ = newDB.AddError(err)\n\t\treturn d.getInstance(newDB)\n\t}\n\treturn d.getInstance(d.db.Clauses(conds...))\n}\n\n// As alias cannot be heired, As must used on tail\nfunc (d DO) As(alias string) Dao {\n\td.alias = alias\n\td.db = d.db.Table(fmt.Sprintf(\"%s AS %s\", d.Quote(d.TableName()), d.Quote(alias)))\n\treturn &d\n}\n\n// Alias return alias name\nfunc (d *DO) Alias() string { return d.alias }\n\n// Columns return columns for Subquery\nfunc (*DO) Columns(cols ...field.Expr) Columns { return cols }\n\n// ======================== chainable api ========================\n\n// Not ...\nfunc (d *DO) Not(conds ...Condition) Dao {\n\texprs, err := condToExpression(conds)\n\tif err != nil {\n\t\treturn d.withError(err)\n\t}\n\tif len(exprs) == 0 {\n\t\treturn d\n\t}\n\treturn d.getInstance(d.db.Clauses(clause.Where{Exprs: []clause.Expression{clause.Not(exprs...)}}))\n}\n\n// Or ...\nfunc (d *DO) Or(conds ...Condition) Dao {\n\texprs, err := condToExpression(conds)\n\tif err != nil {\n\t\treturn d.withError(err)\n\t}\n\tif len(exprs) == 0 {\n\t\treturn d\n\t}\n\treturn d.getInstance(d.db.Clauses(clause.Where{Exprs: []clause.Expression{clause.Or(clause.And(exprs...))}}))\n}\n\n// Select ...\nfunc (d *DO) Select(columns ...field.Expr) Dao {\n\tif len(columns) == 0 {\n\t\treturn d.getInstance(d.db.Clauses(clause.Select{}))\n\t}\n\tquery, args := buildExpr4Select(d.db.Statement, columns...)\n\treturn d.getInstance(d.db.Select(query, args...))\n}\n\n// Where ...\nfunc (d *DO) Where(conds ...Condition) Dao {\n\texprs, err := condToExpression(conds)\n\tif err != nil {\n\t\treturn d.withError(err)\n\t}\n\tif len(exprs) == 0 {\n\t\treturn d\n\t}\n\treturn d.getInstance(d.db.Clauses(clause.Where{Exprs: exprs}))\n}\n\n// Order ...\nfunc (d *DO) Order(columns ...field.Expr) Dao {\n\t// lazy build Columns\n\t// if c, ok := d.db.Statement.Clauses[clause.OrderBy{}.Name()]; ok {\n\t// \tif order, ok := c.Expression.(clause.OrderBy); ok {\n\t// \t\tif expr, ok := order.Expression.(clause.CommaExpression); ok {\n\t// \t\t\texpr.Exprs = append(expr.Exprs, toExpression(columns)...)\n\t// \t\t\treturn d.newInstance(d.db.Clauses(clause.OrderBy{Expression: expr}))\n\t// \t\t}\n\t// \t}\n\t// }\n\t// return d.newInstance(d.db.Clauses(clause.OrderBy{Expression: clause.CommaExpression{Exprs: toExpression(columns)}}))\n\tif len(columns) == 0 {\n\t\treturn d\n\t}\n\treturn d.getInstance(d.db.Order(d.toOrderValue(columns...)))\n}\n\nfunc (d *DO) toOrderValue(columns ...field.Expr) string {\n\t// eager build Columns\n\tstmt := &gorm.Statement{DB: d.db.Statement.DB, Table: d.db.Statement.Table, Schema: d.db.Statement.Schema}\n\n\tfor i, c := range columns {\n\t\tif i != 0 {\n\t\t\tstmt.WriteByte(',')\n\t\t}\n\t\tc.Build(stmt)\n\t}\n\n\treturn d.db.Dialector.Explain(stmt.SQL.String(), stmt.Vars...)\n}\n\n// Distinct ...\nfunc (d *DO) Distinct(columns ...field.Expr) Dao {\n\treturn d.getInstance(d.db.Distinct(toInterfaceSlice(toColExprFullName(d.db.Statement, columns...))...))\n}\n\n// Omit ...\nfunc (d *DO) Omit(columns ...field.Expr) Dao {\n\tif len(columns) == 0 {\n\t\treturn d\n\t}\n\treturn d.getInstance(d.db.Omit(getColumnName(columns...)...))\n}\n\n// Group ...\nfunc (d *DO) Group(columns ...field.Expr) Dao {\n\tif len(columns) == 0 {\n\t\treturn d\n\t}\n\n\tstmt := &gorm.Statement{DB: d.db.Statement.DB, Table: d.db.Statement.Table, Schema: d.db.Statement.Schema}\n\n\tfor i, c := range columns {\n\t\tif i != 0 {\n\t\t\tstmt.WriteByte(',')\n\t\t}\n\t\tc.Build(stmt)\n\t}\n\n\treturn d.getInstance(d.db.Group(stmt.SQL.String()))\n}\n\n// Having ...\nfunc (d *DO) Having(conds ...Condition) Dao {\n\texprs, err := condToExpression(conds)\n\tif err != nil {\n\t\treturn d.withError(err)\n\t}\n\tif len(exprs) == 0 {\n\t\treturn d\n\t}\n\treturn d.getInstance(d.db.Clauses(clause.GroupBy{Having: exprs}))\n}\n\n// Limit ...\nfunc (d *DO) Limit(limit int) Dao {\n\treturn d.getInstance(d.db.Limit(limit))\n}\n\n// Offset ...\nfunc (d *DO) Offset(offset int) Dao {\n\treturn d.getInstance(d.db.Offset(offset))\n}\n\n// Scopes ...\nfunc (d *DO) Scopes(funcs ...func(Dao) Dao) Dao {\n\tfcs := make([]func(*gorm.DB) *gorm.DB, len(funcs))\n\tfor i, f := range funcs {\n\t\tsf := f\n\t\tfcs[i] = func(tx *gorm.DB) *gorm.DB { return sf(d.getInstance(tx)).(*DO).db }\n\t}\n\treturn d.getInstance(d.db.Scopes(fcs...))\n}\n\n// Unscoped ...\nfunc (d *DO) Unscoped() Dao {\n\treturn d.getInstance(d.db.Unscoped())\n}\n\n// Join ...\nfunc (d *DO) Join(table schema.Tabler, conds ...field.Expr) Dao {\n\treturn d.join(table, clause.InnerJoin, conds)\n}\n\n// LeftJoin ...\nfunc (d *DO) LeftJoin(table schema.Tabler, conds ...field.Expr) Dao {\n\treturn d.join(table, clause.LeftJoin, conds)\n}\n\n// RightJoin ...\nfunc (d *DO) RightJoin(table schema.Tabler, conds ...field.Expr) Dao {\n\treturn d.join(table, clause.RightJoin, conds)\n}\n\nfunc (d *DO) join(table schema.Tabler, joinType clause.JoinType, conds []field.Expr) Dao {\n\tif len(conds) == 0 {\n\t\treturn d.withError(ErrEmptyCondition)\n\t}\n\n\tjoin := clause.Join{\n\t\tType:  joinType,\n\t\tTable: clause.Table{Name: table.TableName()},\n\t\tON:    clause.Where{Exprs: toExpression(conds...)},\n\t}\n\tif do, ok := table.(Dao); ok {\n\t\tjoin.Expression = helper.NewJoinTblExpr(join, Table(do).underlyingDB().Statement.TableExpr)\n\t}\n\tif al, ok := table.(interface{ Alias() string }); ok {\n\t\tjoin.Table.Alias = al.Alias()\n\t}\n\n\tfrom := getFromClause(d.db)\n\tfrom.Joins = append(from.Joins, join)\n\treturn d.getInstance(d.db.Clauses(from))\n}\n\n// Attrs ...\nfunc (d *DO) Attrs(attrs ...field.AssignExpr) Dao {\n\tif len(attrs) == 0 {\n\t\treturn d\n\t}\n\treturn d.getInstance(d.db.Attrs(d.attrsValue(attrs)...))\n}\n\n// Assign ...\nfunc (d *DO) Assign(attrs ...field.AssignExpr) Dao {\n\tif len(attrs) == 0 {\n\t\treturn d\n\t}\n\treturn d.getInstance(d.db.Assign(d.attrsValue(attrs)...))\n}\n\nfunc (d *DO) attrsValue(attrs []field.AssignExpr) []interface{} {\n\tvalues := make([]interface{}, 0, len(attrs))\n\tfor _, attr := range attrs {\n\t\tif expr, ok := attr.AssignExpr().(field.IValues); ok {\n\t\t\tvalues = append(values, expr.Values())\n\t\t} else if expr, ok := attr.AssignExpr().(clause.Eq); ok {\n\t\t\tvalues = append(values, expr)\n\t\t}\n\t}\n\treturn values\n}\n\n// Joins ...\nfunc (d *DO) Joins(field field.RelationField) Dao {\n\tvar args []interface{}\n\n\tif conds := field.GetConds(); len(conds) > 0 {\n\t\tvar exprs []clause.Expression\n\t\tfor _, oe := range toExpression(conds...) {\n\t\t\tswitch e := oe.(type) {\n\t\t\tcase clause.Eq:\n\t\t\t\tif c, ok := e.Column.(clause.Column); ok {\n\t\t\t\t\tc.Table = field.Name()\n\t\t\t\t\te.Column = c\n\t\t\t\t}\n\t\t\t\texprs = append(exprs, e)\n\t\t\tcase clause.Neq:\n\t\t\t\tif c, ok := e.Column.(clause.Column); ok {\n\t\t\t\t\tc.Table = field.Name()\n\t\t\t\t\te.Column = c\n\t\t\t\t}\n\t\t\t\texprs = append(exprs, e)\n\t\t\tcase clause.Gt:\n\t\t\t\tif c, ok := e.Column.(clause.Column); ok {\n\t\t\t\t\tc.Table = field.Name()\n\t\t\t\t\te.Column = c\n\t\t\t\t}\n\t\t\t\texprs = append(exprs, e)\n\t\t\tcase clause.Gte:\n\t\t\t\tif c, ok := e.Column.(clause.Column); ok {\n\t\t\t\t\tc.Table = field.Name()\n\t\t\t\t\te.Column = c\n\t\t\t\t}\n\t\t\t\texprs = append(exprs, e)\n\t\t\tcase clause.Lt:\n\t\t\t\tif c, ok := e.Column.(clause.Column); ok {\n\t\t\t\t\tc.Table = field.Name()\n\t\t\t\t\te.Column = c\n\t\t\t\t}\n\t\t\t\texprs = append(exprs, e)\n\t\t\tcase clause.Lte:\n\t\t\t\tif c, ok := e.Column.(clause.Column); ok {\n\t\t\t\t\tc.Table = field.Name()\n\t\t\t\t\te.Column = c\n\t\t\t\t}\n\t\t\t\texprs = append(exprs, e)\n\t\t\tcase clause.Like:\n\t\t\t\tif c, ok := e.Column.(clause.Column); ok {\n\t\t\t\t\tc.Table = field.Name()\n\t\t\t\t\te.Column = c\n\t\t\t\t}\n\t\t\t\texprs = append(exprs, e)\n\t\t\t}\n\t\t}\n\n\t\targs = append(args, d.db.Clauses(clause.Where{\n\t\t\tExprs: exprs,\n\t\t}))\n\t}\n\tif columns := field.GetSelects(); len(columns) > 0 {\n\t\tcolNames := make([]string, len(columns))\n\t\tfor i, c := range columns {\n\t\t\tcolNames[i] = string(c.ColumnName())\n\t\t}\n\t\targs = append(args, func(db *gorm.DB) *gorm.DB {\n\t\t\treturn db.Select(colNames)\n\t\t})\n\t}\n\tif columns := field.GetOrderCol(); len(columns) > 0 {\n\t\tvar os []string\n\t\tfor _, oe := range columns {\n\t\t\tswitch e := oe.RawExpr().(type) {\n\t\t\tcase clause.Expr:\n\t\t\t\tvs := []interface{}{}\n\t\t\t\tfor _, v := range e.Vars {\n\t\t\t\t\tif c, ok := v.(clause.Column); ok {\n\t\t\t\t\t\tvs = append(vs, clause.Column{\n\t\t\t\t\t\t\tTable: field.Name(),\n\t\t\t\t\t\t\tName:  c.Name,\n\t\t\t\t\t\t\tAlias: c.Alias,\n\t\t\t\t\t\t\tRaw:   c.Raw,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te.Vars = vs\n\t\t\t\tnewStmt := &gorm.Statement{DB: d.db.Statement.DB, Table: d.db.Statement.Table, Schema: d.db.Statement.Schema}\n\t\t\t\te.Build(newStmt)\n\t\t\t\tos = append(os, newStmt.SQL.String())\n\t\t\t}\n\t\t}\n\t\targs = append(args, d.db.Order(strings.Join(os, \",\")))\n\t}\n\tif clauses := field.GetClauses(); len(clauses) > 0 {\n\t\targs = append(args, func(db *gorm.DB) *gorm.DB {\n\t\t\treturn db.Clauses(clauses...)\n\t\t})\n\t}\n\tif funcs := field.GetScopes(); len(funcs) > 0 {\n\t\tfor _, f := range funcs {\n\t\t\targs = append(args, (func(*gorm.DB) *gorm.DB)(f))\n\t\t}\n\t}\n\tif offset, limit := field.GetPage(); offset|limit != 0 {\n\t\targs = append(args, func(db *gorm.DB) *gorm.DB {\n\t\t\treturn db.Offset(offset).Limit(limit)\n\t\t})\n\t}\n\n\treturn d.getInstance(d.db.Joins(field.Path(), args...))\n}\n\n// Preload ...\nfunc (d *DO) Preload(field field.RelationField) Dao {\n\tvar args []interface{}\n\tif conds := field.GetConds(); len(conds) > 0 {\n\t\targs = append(args, toExpressionInterface(conds...)...)\n\t}\n\tif columns := field.GetSelects(); len(columns) > 0 {\n\t\tcolNames := make([]string, len(columns))\n\t\tfor i, c := range columns {\n\t\t\tcolNames[i] = string(c.ColumnName())\n\t\t}\n\t\targs = append(args, func(db *gorm.DB) *gorm.DB {\n\t\t\treturn db.Select(colNames)\n\t\t})\n\t}\n\tif columns := field.GetOrderCol(); len(columns) > 0 {\n\t\targs = append(args, func(db *gorm.DB) *gorm.DB {\n\t\t\treturn db.Order(d.toOrderValue(columns...))\n\t\t})\n\t}\n\tif clauses := field.GetClauses(); len(clauses) > 0 {\n\t\targs = append(args, func(db *gorm.DB) *gorm.DB {\n\t\t\treturn db.Clauses(clauses...)\n\t\t})\n\t}\n\tif funcs := field.GetScopes(); len(funcs) > 0 {\n\t\tfor _, f := range funcs {\n\t\t\targs = append(args, (func(*gorm.DB) *gorm.DB)(f))\n\t\t}\n\t}\n\tif offset, limit := field.GetPage(); offset|limit != 0 {\n\t\targs = append(args, func(db *gorm.DB) *gorm.DB {\n\t\t\treturn db.Offset(offset).Limit(limit)\n\t\t})\n\t}\n\treturn d.getInstance(d.db.Preload(field.Path(), args...))\n}\n\n// UpdateFrom specify update sub query\nfunc (d *DO) UpdateFrom(q SubQuery) Dao {\n\tvar tableName strings.Builder\n\td.db.Statement.QuoteTo(&tableName, d.TableName())\n\tif d.alias != \"\" {\n\t\ttableName.WriteString(\" AS \")\n\t\td.db.Statement.QuoteTo(&tableName, d.alias)\n\t}\n\n\ttableName.WriteByte(',')\n\tif _, ok := q.underlyingDB().Statement.Clauses[\"SELECT\"]; ok || len(q.underlyingDB().Statement.Selects) > 0 {\n\t\ttableName.WriteString(\"(\" + q.underlyingDB().ToSQL(func(tx *gorm.DB) *gorm.DB { return tx.Table(q.underlyingDO().TableName()).Find(nil) }) + \")\")\n\t} else {\n\t\td.db.Statement.QuoteTo(&tableName, q.underlyingDO().TableName())\n\t}\n\tif alias := q.underlyingDO().alias; alias != \"\" {\n\t\ttableName.WriteString(\" AS \")\n\t\td.db.Statement.QuoteTo(&tableName, alias)\n\t}\n\n\treturn d.getInstance(d.db.Clauses(clause.Update{Table: clause.Table{Name: tableName.String(), Raw: true}}))\n}\n\nfunc getFromClause(db *gorm.DB) *clause.From {\n\tif db == nil || db.Statement == nil {\n\t\treturn &clause.From{}\n\t}\n\tc, ok := db.Statement.Clauses[clause.From{}.Name()]\n\tif !ok || c.Expression == nil {\n\t\treturn &clause.From{}\n\t}\n\tfrom, ok := c.Expression.(clause.From)\n\tif !ok {\n\t\treturn &clause.From{}\n\t}\n\treturn &from\n}\n\n// ======================== finisher api ========================\n\n// Create ...\nfunc (d *DO) Create(value interface{}) error {\n\treturn d.db.Create(value).Error\n}\n\n// CreateInBatches ...\nfunc (d *DO) CreateInBatches(value interface{}, batchSize int) error {\n\treturn d.db.CreateInBatches(value, batchSize).Error\n}\n\n// Save ...\nfunc (d *DO) Save(value interface{}) error {\n\treturn d.db.Clauses(clause.OnConflict{UpdateAll: true}).Create(value).Error\n}\n\n// First ...\nfunc (d *DO) First() (result interface{}, err error) {\n\treturn d.singleQuery(d.db.First)\n}\n\n// Take ...\nfunc (d *DO) Take() (result interface{}, err error) {\n\treturn d.singleQuery(d.db.Take)\n}\n\n// Last ...\nfunc (d *DO) Last() (result interface{}, err error) {\n\treturn d.singleQuery(d.db.Last)\n}\n\nfunc (d *DO) singleQuery(query func(dest interface{}, conds ...interface{}) *gorm.DB) (result interface{}, err error) {\n\tif d.modelType == nil {\n\t\treturn d.singleScan()\n\t}\n\n\tresult = d.newResultPointer()\n\tif err := query(result).Error; err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc (d *DO) singleScan() (result interface{}, err error) {\n\tresult = map[string]interface{}{}\n\terr = d.db.Scan(result).Error\n\treturn\n}\n\n// Find ...\nfunc (d *DO) Find() (results interface{}, err error) {\n\treturn d.multiQuery(d.db.Find)\n}\n\nfunc (d *DO) multiQuery(query func(dest interface{}, conds ...interface{}) *gorm.DB) (results interface{}, err error) {\n\tif d.modelType == nil {\n\t\treturn d.findToMap()\n\t}\n\n\tresultsPtr := d.newResultSlicePointer()\n\terr = query(resultsPtr).Error\n\treturn reflect.Indirect(reflect.ValueOf(resultsPtr)).Interface(), err\n}\n\nfunc (d *DO) findToMap() (interface{}, error) {\n\tvar results []map[string]interface{}\n\terr := d.db.Find(&results).Error\n\treturn results, err\n}\n\n// FindInBatches ...\nfunc (d *DO) FindInBatches(dest interface{}, batchSize int, fc func(tx Dao, batch int) error) error {\n\treturn d.db.FindInBatches(dest, batchSize, func(tx *gorm.DB, batch int) error { return fc(d.getInstance(tx), batch) }).Error\n}\n\n// FirstOrInit ...\nfunc (d *DO) FirstOrInit() (result interface{}, err error) {\n\treturn d.singleQuery(d.db.FirstOrInit)\n}\n\n// FirstOrCreate ...\nfunc (d *DO) FirstOrCreate() (result interface{}, err error) {\n\treturn d.singleQuery(d.db.FirstOrCreate)\n}\n\n// Update ...\nfunc (d *DO) Update(column field.Expr, value interface{}) (info ResultInfo, err error) {\n\ttx := d.db.Model(d.newResultPointer())\n\tcolumnStr := column.BuildColumn(d.db.Statement, field.WithoutQuote).String()\n\n\tvar result *gorm.DB\n\tswitch value := value.(type) {\n\tcase field.AssignExpr:\n\t\tresult = tx.Update(columnStr, value.AssignExpr())\n\tcase SubQuery:\n\t\tresult = tx.Update(columnStr, value.underlyingDB())\n\tdefault:\n\t\tresult = tx.Update(columnStr, value)\n\t}\n\treturn ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error\n}\n\n// UpdateSimple ...\nfunc (d *DO) UpdateSimple(columns ...field.AssignExpr) (info ResultInfo, err error) {\n\tif len(columns) == 0 {\n\t\treturn\n\t}\n\n\tresult := d.db.Model(d.newResultPointer()).Clauses(d.assignSet(columns)).Omit(\"*\").Updates(map[string]interface{}{})\n\treturn ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error\n}\n\n// Updates ...\nfunc (d *DO) Updates(value interface{}) (info ResultInfo, err error) {\n\tvar rawTyp, valTyp reflect.Type\n\n\trawTyp = reflect.TypeOf(value)\n\tif rawTyp.Kind() == reflect.Ptr {\n\t\tvalTyp = rawTyp.Elem()\n\t} else {\n\t\tvalTyp = rawTyp\n\t}\n\n\ttx := d.db.Model(d.newResultPointer())\n\tif d.backfillData != nil {\n\t\ttx = tx.Model(d.backfillData)\n\t}\n\tswitch {\n\tcase valTyp != d.modelType: // different type with model\n\t\tif d.backfillData == nil {\n\t\t\ttx = tx.Model(d.newResultPointer())\n\t\t}\n\tcase rawTyp.Kind() == reflect.Ptr: // ignore ptr value\n\tdefault: // for fixing \"reflect.Value.Addr of unaddressable value\" panic\n\t\tptr := reflect.New(d.modelType)\n\t\tptr.Elem().Set(reflect.ValueOf(value))\n\t\tvalue = ptr.Interface()\n\t}\n\tresult := tx.Updates(value)\n\treturn ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error\n}\n\n// UpdateColumn ...\nfunc (d *DO) UpdateColumn(column field.Expr, value interface{}) (info ResultInfo, err error) {\n\ttx := d.db.Model(d.newResultPointer())\n\tcolumnStr := column.BuildColumn(d.db.Statement, field.WithoutQuote).String()\n\n\tvar result *gorm.DB\n\tswitch value := value.(type) {\n\tcase field.Expr:\n\t\tresult = tx.UpdateColumn(columnStr, value.RawExpr())\n\tcase SubQuery:\n\t\tresult = d.db.UpdateColumn(columnStr, value.underlyingDB())\n\tdefault:\n\t\tresult = d.db.UpdateColumn(columnStr, value)\n\t}\n\treturn ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error\n}\n\n// UpdateColumnSimple ...\nfunc (d *DO) UpdateColumnSimple(columns ...field.AssignExpr) (info ResultInfo, err error) {\n\tif len(columns) == 0 {\n\t\treturn\n\t}\n\n\tresult := d.db.Model(d.newResultPointer()).Clauses(d.assignSet(columns)).Omit(\"*\").UpdateColumns(map[string]interface{}{})\n\treturn ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error\n}\n\n// UpdateColumns ...\nfunc (d *DO) UpdateColumns(value interface{}) (info ResultInfo, err error) {\n\tresult := d.db.Model(d.newResultPointer()).UpdateColumns(value)\n\treturn ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error\n}\n\n// assignSet fetch all set\nfunc (d *DO) assignSet(exprs []field.AssignExpr) (set clause.Set) {\n\tfor _, expr := range exprs {\n\t\tcolumn := clause.Column{Table: d.alias, Name: string(expr.ColumnName())}\n\t\tswitch e := expr.AssignExpr().(type) {\n\t\tcase clause.Expr:\n\t\t\tset = append(set, clause.Assignment{Column: column, Value: e})\n\t\tcase clause.Eq:\n\t\t\tset = append(set, clause.Assignment{Column: column, Value: e.Value})\n\t\tcase clause.Set:\n\t\t\tset = append(set, e...)\n\t\t}\n\t}\n\n\tstmt := d.db.Session(&gorm.Session{}).Statement\n\tstmt.Dest = map[string]interface{}{}\n\treturn append(set, callbacks.ConvertToAssignments(stmt)...)\n}\n\n// Delete ...\nfunc (d *DO) Delete(models ...interface{}) (info ResultInfo, err error) {\n\tvar result *gorm.DB\n\tif len(models) == 0 || reflect.ValueOf(models[0]).Len() == 0 {\n\t\tresult = d.db.Model(d.newResultPointer()).Delete(reflect.New(d.modelType).Interface())\n\t} else {\n\t\ttargets := reflect.MakeSlice(reflect.SliceOf(reflect.PtrTo(d.modelType)), 0, len(models))\n\t\tvalue := reflect.ValueOf(models[0])\n\t\tfor i := 0; i < value.Len(); i++ {\n\t\t\ttargets = reflect.Append(targets, value.Index(i))\n\t\t}\n\t\tresult = d.db.Delete(targets.Interface())\n\t}\n\treturn ResultInfo{RowsAffected: result.RowsAffected, Error: result.Error}, result.Error\n}\n\n// Count ...\nfunc (d *DO) Count() (count int64, err error) {\n\treturn count, d.db.Session(&gorm.Session{}).Model(d.newResultPointer()).Count(&count).Error\n}\n\n// Row ...\nfunc (d *DO) Row() *sql.Row {\n\treturn d.db.Model(d.newResultPointer()).Row()\n}\n\n// Rows ...\nfunc (d *DO) Rows() (*sql.Rows, error) {\n\treturn d.db.Model(d.newResultPointer()).Rows()\n}\n\n// Scan ...\nfunc (d *DO) Scan(dest interface{}) error {\n\treturn d.db.Model(d.newResultPointer()).Scan(dest).Error\n}\n\n// Pluck ...\nfunc (d *DO) Pluck(column field.Expr, dest interface{}) error {\n\treturn d.db.Model(d.newResultPointer()).Pluck(column.ColumnName().String(), dest).Error\n}\n\n// ScanRows ...\nfunc (d *DO) ScanRows(rows *sql.Rows, dest interface{}) error {\n\treturn d.db.Model(d.newResultPointer()).ScanRows(rows, dest)\n}\n\n// WithResult ...\nfunc (d DO) WithResult(fc func(tx Dao)) ResultInfo {\n\td.db = d.db.Set(\"\", \"\")\n\tfc(&d)\n\treturn ResultInfo{RowsAffected: d.db.RowsAffected, Error: d.db.Error}\n}\n\nfunc (d *DO) newResultPointer() interface{} {\n\tif d.backfillData != nil {\n\t\treturn d.backfillData\n\t}\n\tif d.modelType == nil {\n\t\treturn nil\n\t}\n\treturn reflect.New(d.modelType).Interface()\n}\n\nfunc (d *DO) newResultSlicePointer() interface{} {\n\treturn reflect.New(reflect.SliceOf(reflect.PtrTo(d.modelType))).Interface()\n}\n\nfunc (d *DO) AddError(err error) error {\n\treturn d.underlyingDB().AddError(err)\n}\n\nfunc toColExprFullName(stmt *gorm.Statement, columns ...field.Expr) []string {\n\treturn buildColExpr(stmt, columns, field.WithAll)\n}\n\nfunc getColumnName(columns ...field.Expr) (result []string) {\n\tfor _, c := range columns {\n\t\tresult = append(result, c.ColumnName().String())\n\t}\n\treturn result\n}\n\nfunc buildColExpr(stmt *gorm.Statement, cols []field.Expr, opts ...field.BuildOpt) []string {\n\tresults := make([]string, len(cols))\n\tfor i, c := range cols {\n\t\tswitch c.RawExpr().(type) {\n\t\tcase clause.Column:\n\t\t\tresults[i] = c.BuildColumn(stmt, opts...).String()\n\t\tcase clause.Expression:\n\t\t\tsql, args := c.BuildWithArgs(stmt)\n\t\t\tresults[i] = stmt.Dialector.Explain(sql.String(), args...)\n\t\t}\n\t}\n\treturn results\n}\n\nfunc buildExpr4Select(stmt *gorm.Statement, exprs ...field.Expr) (query string, args []interface{}) {\n\tif len(exprs) == 0 {\n\t\treturn \"\", nil\n\t}\n\n\tvar queryItems []string\n\tfor _, e := range exprs {\n\t\tsql, vars := e.BuildWithArgs(stmt)\n\t\tqueryItems = append(queryItems, sql.String())\n\t\targs = append(args, vars...)\n\t}\n\tif len(args) == 0 {\n\t\treturn queryItems[0], toInterfaceSlice(queryItems[1:])\n\t}\n\treturn strings.Join(queryItems, \",\"), args\n}\n\nfunc toExpression(exprs ...field.Expr) []clause.Expression {\n\tresult := make([]clause.Expression, len(exprs))\n\tfor i, e := range exprs {\n\t\tresult[i] = singleExpr(e)\n\t}\n\treturn result\n}\n\nfunc toExpressionInterface(exprs ...field.Expr) []interface{} {\n\tresult := make([]interface{}, len(exprs))\n\tfor i, e := range exprs {\n\t\tresult[i] = singleExpr(e)\n\t}\n\treturn result\n}\n\nfunc singleExpr(e field.Expr) clause.Expression {\n\tswitch v := e.RawExpr().(type) {\n\tcase clause.Expression:\n\t\treturn v\n\tcase clause.Column:\n\t\treturn clause.NamedExpr{SQL: \"?\", Vars: []interface{}{v}}\n\tdefault:\n\t\treturn clause.Expr{}\n\t}\n}\n\nfunc toInterfaceSlice(value interface{}) []interface{} {\n\tswitch v := value.(type) {\n\tcase string:\n\t\treturn []interface{}{v}\n\tcase []string:\n\t\tres := make([]interface{}, len(v))\n\t\tfor i, item := range v {\n\t\t\tres[i] = item\n\t\t}\n\t\treturn res\n\tcase []clause.Column:\n\t\tres := make([]interface{}, len(v))\n\t\tfor i, item := range v {\n\t\t\tres[i] = item\n\t\t}\n\t\treturn res\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// ======================== New Table ========================\n\n// Table return a new table produced by subquery,\n// the return value has to be used as root node\n//\n//\tTable(u.Select(u.ID, u.Name).Where(u.Age.Gt(18))).Select()\n//\n// the above usage is equivalent to SQL statement:\n//\n//\tSELECT * FROM (SELECT `id`, `name` FROM `users_info` WHERE `age` > ?)\"\nfunc Table(subQueries ...SubQuery) Dao {\n\tif len(subQueries) == 0 {\n\t\treturn &DO{}\n\t}\n\n\ttablePlaceholder := make([]string, len(subQueries))\n\ttableExprs := make([]interface{}, len(subQueries))\n\tfor i, query := range subQueries {\n\t\ttablePlaceholder[i] = \"(?)\"\n\n\t\tdo := query.underlyingDO()\n\t\t// ignore alias, or will misuse with sub query alias\n\t\ttableExprs[i] = do.db.Table(do.TableName())\n\t\tif do.alias != \"\" {\n\t\t\ttablePlaceholder[i] += \" AS \" + do.Quote(do.alias)\n\t\t}\n\t}\n\n\treturn &DO{\n\t\tdb: subQueries[0].underlyingDO().db.Session(&gorm.Session{NewDB: true}).\n\t\t\tTable(strings.Join(tablePlaceholder, \", \"), tableExprs...),\n\t}\n}\n\n// Exists EXISTS expression\n// SELECT * FROM table WHERE EXISTS (SELECT NAME FROM users WHERE id = 1)\nfunc Exists(subQuery SubQuery) Condition {\n\treturn field.CompareSubQuery(field.ExistsOp, nil, subQuery.underlyingDB())\n}\n\n// ======================== sub query method ========================\n\n// Columns columns array\ntype Columns []field.Expr\n\n// Set assign value by subquery\nfunc (cs Columns) Set(query SubQuery) field.AssignExpr {\n\treturn field.AssignSubQuery(cs, query.underlyingDB())\n}\n\n// In accept query or value\nfunc (cs Columns) In(queryOrValue Condition) field.Expr {\n\tif len(cs) == 0 {\n\t\treturn field.EmptyExpr()\n\t}\n\n\tswitch query := queryOrValue.(type) {\n\tcase field.Value:\n\t\treturn field.ContainsValue(cs, query)\n\tcase SubQuery:\n\t\treturn field.ContainsSubQuery(cs, query.underlyingDB())\n\tdefault:\n\t\treturn field.EmptyExpr()\n\t}\n}\n\n// NotIn ...\nfunc (cs Columns) NotIn(queryOrValue Condition) field.Expr {\n\treturn field.Not(cs.In(queryOrValue))\n}\n\n// Eq ...\nfunc (cs Columns) Eq(query SubQuery) field.Expr {\n\tif len(cs) == 0 {\n\t\treturn field.EmptyExpr()\n\t}\n\treturn field.CompareSubQuery(field.EqOp, cs[0], query.underlyingDB())\n}\n\n// Neq ...\nfunc (cs Columns) Neq(query SubQuery) field.Expr {\n\tif len(cs) == 0 {\n\t\treturn field.EmptyExpr()\n\t}\n\treturn field.CompareSubQuery(field.NeqOp, cs[0], query.underlyingDB())\n}\n\n// Gt ...\nfunc (cs Columns) Gt(query SubQuery) field.Expr {\n\tif len(cs) == 0 {\n\t\treturn field.EmptyExpr()\n\t}\n\treturn field.CompareSubQuery(field.GtOp, cs[0], query.underlyingDB())\n}\n\n// Gte ...\nfunc (cs Columns) Gte(query SubQuery) field.Expr {\n\tif len(cs) == 0 {\n\t\treturn field.EmptyExpr()\n\t}\n\treturn field.CompareSubQuery(field.GteOp, cs[0], query.underlyingDB())\n}\n\n// Lt ...\nfunc (cs Columns) Lt(query SubQuery) field.Expr {\n\tif len(cs) == 0 {\n\t\treturn field.EmptyExpr()\n\t}\n\treturn field.CompareSubQuery(field.LtOp, cs[0], query.underlyingDB())\n}\n\n// Lte ...\nfunc (cs Columns) Lte(query SubQuery) field.Expr {\n\tif len(cs) == 0 {\n\t\treturn field.EmptyExpr()\n\t}\n\treturn field.CompareSubQuery(field.LteOp, cs[0], query.underlyingDB())\n}\n"
        },
        {
          "name": "do_options.go",
          "type": "blob",
          "size": 0.4052734375,
          "content": "package gen\n\n// DOOption gorm option interface\ntype DOOption interface {\n\tApply(*DOConfig) error\n\tAfterInitialize(*DO) error\n}\n\ntype DOConfig struct {\n}\n\n// Apply update config to new config\nfunc (c *DOConfig) Apply(config *DOConfig) error {\n\tif config != c {\n\t\t*config = *c\n\t}\n\treturn nil\n}\n\n// AfterInitialize initialize plugins after db connected\nfunc (c *DOConfig) AfterInitialize(db *DO) error {\n\treturn nil\n}\n"
        },
        {
          "name": "do_test.go",
          "type": "blob",
          "size": 14.5966796875,
          "content": "package gen\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"gorm.io/datatypes\"\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/hints\"\n\n\t\"gorm.io/gen/field\"\n)\n\nvar (\n\tcreateClauses = []string{\"INSERT\", \"VALUES\", \"ON CONFLICT\"}\n\tqueryClauses  = []string{\"SELECT\", \"FROM\", \"WHERE\", \"GROUP BY\", \"ORDER BY\", \"LIMIT\", \"FOR\"}\n\tupdateClauses = []string{\"UPDATE\", \"SET\", \"WHERE\"}\n\tdeleteClauses = []string{\"DELETE\", \"FROM\", \"WHERE\"}\n)\n\ntype stmtOpt func(*gorm.Statement) *gorm.Statement\n\nvar (\n\t// withFROM add FROM clause\n\twithFROM stmtOpt = func(stmt *gorm.Statement) *gorm.Statement {\n\t\tstmt.AddClause(clause.From{})\n\t\treturn stmt\n\t}\n\n\t// // withSELECT add SELECT clause\n\t// withSELECT stmtOpt = func(stmt *gorm.Statement) *gorm.Statement {\n\t// \tif _, ok := stmt.Clauses[\"SELECT\"]; !ok {\n\t// \t\tstmt.AddClause(clause.Select{Distinct: stmt.Distinct})\n\t// \t}\n\t// \treturn stmt\n\t// }\n)\n\nfunc checkBuildExpr(t *testing.T, e SubQuery, opts []stmtOpt, result string, vars []interface{}) {\n\tstmt := build(e.underlyingDB().Statement, opts...)\n\n\tsql := strings.TrimSpace(stmt.SQL.String())\n\tif sql != result {\n\t\tt.Errorf(\"SQL expects %v got %v\", result, sql)\n\t}\n\n\tif !reflect.DeepEqual(stmt.Vars, vars) {\n\t\tt.Errorf(\"Vars expects %+v got %v\", vars, stmt.Vars)\n\t}\n}\n\nfunc build(stmt *gorm.Statement, opts ...stmtOpt) *gorm.Statement {\n\tfor _, opt := range opts {\n\t\tstmt = opt(stmt)\n\t}\n\n\tif _, ok := stmt.Clauses[\"SELECT\"]; !ok && len(stmt.Selects) > 0 {\n\t\tstmt.AddClause(clause.Select{Distinct: stmt.Distinct, Expression: clause.Expr{SQL: strings.Join(stmt.Selects, \",\")}})\n\t}\n\n\tfindClauses := func() []string {\n\t\tfor _, cs := range [][]string{createClauses, queryClauses, updateClauses, deleteClauses} {\n\t\t\tif _, ok := stmt.Clauses[cs[0]]; ok {\n\t\t\t\treturn cs\n\t\t\t}\n\t\t}\n\t\treturn queryClauses\n\t}\n\n\tstmt.Build(findClauses()...)\n\treturn stmt\n}\n\nfunc TestDO_methods(t *testing.T) {\n\ttestcases := []struct {\n\t\tExpr         SubQuery\n\t\tOpts         []stmtOpt\n\t\tExpectedVars []interface{}\n\t\tResult       string\n\t}{\n\t\t{\n\t\t\tExpr:   u.Select(),\n\t\t\tResult: \"SELECT *\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Select(u.ID, u.Name),\n\t\t\tResult: \"SELECT `id`,`name`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Distinct(u.Name),\n\t\t\tResult: \"SELECT DISTINCT `name`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Distinct(teacher.ID, teacher.Name),\n\t\t\tResult: \"SELECT DISTINCT `teacher`.`id`,`teacher`.`name`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Select(teacher.ID, teacher.Name).Distinct(),\n\t\t\tResult: \"SELECT DISTINCT `teacher`.`id`,`teacher`.`name`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Distinct().Select(teacher.ID, teacher.Name),\n\t\t\tResult: \"SELECT DISTINCT `teacher`.`id`,`teacher`.`name`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Select(teacher.Name.As(\"n\")).Distinct(),\n\t\t\tResult: \"SELECT DISTINCT `teacher`.`name` AS `n`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Select(field.ALL),\n\t\t\tResult: \"SELECT *\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Select(field.ALL.Count()),\n\t\t\tResult: \"SELECT COUNT(*)\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Select(field.ALL.Distinct().Count()),\n\t\t\tResult: \"SELECT COUNT(DISTINCT *)\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Select(teacher.ALL),\n\t\t\tResult: \"SELECT `teacher`.*\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Select(teacher.ALL.Count()),\n\t\t\tResult: \"SELECT COUNT(`teacher`.*)\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Select(teacher.ALL.Distinct().Count()),\n\t\t\tResult: \"SELECT COUNT(DISTINCT `teacher`.*)\",\n\t\t},\n\t\t{\n\t\t\tExpr:   teacher.Select(teacher.ID.As(\"i\"), teacher.Name.As(\"n\")).Distinct(),\n\t\t\tResult: \"SELECT DISTINCT `teacher`.`id` AS `i`,`teacher`.`name` AS `n`\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.ID.Eq(10)),\n\t\t\tExpectedVars: []interface{}{uint(10)},\n\t\t\tResult:       \"WHERE `id` = ?\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Where(u.Name.Substring(1)),\n\t\t\tResult: \"WHERE SUBSTRING(`name`,1)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Name.Substring(1, 6), u.ID.Eq(10)),\n\t\t\tExpectedVars: []interface{}{uint(10)},\n\t\t\tResult:       \"WHERE SUBSTRING(`name`,1,6) AND `id` = ?\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Name.Substr(1), u.ID.Eq(10)),\n\t\t\tExpectedVars: []interface{}{uint(10)},\n\t\t\tResult:       \"WHERE SUBSTR(`name`,1) AND `id` = ?\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Where(u.Name.Substr(1, 6)),\n\t\t\tResult: \"WHERE SUBSTR(`name`,1,6)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Name.Eq(\"tom\"), u.Age.Gt(18)),\n\t\t\tExpectedVars: []interface{}{\"tom\", 18},\n\t\t\tResult:       \"WHERE `name` = ? AND `age` > ?\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Order(u.ID),\n\t\t\tResult: \"ORDER BY `id`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Order(u.ID.Desc()),\n\t\t\tResult: \"ORDER BY `id` DESC\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Order(u.ID.Desc(), u.Age),\n\t\t\tResult: \"ORDER BY `id` DESC,`age`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Order(u.ID.Desc()).Order(u.Age),\n\t\t\tResult: \"ORDER BY `id` DESC,`age`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Order(u.ID.Asc()),\n\t\t\tResult: \"ORDER BY `id` ASC\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Order(u.ID.Asc(), u.Age),\n\t\t\tResult: \"ORDER BY `id` ASC,`age`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Order(u.ID.Asc()).Order(u.Age),\n\t\t\tResult: \"ORDER BY `id` ASC,`age`\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Clauses(hints.New(\"hint\")).Select(),\n\t\t\tResult: \"SELECT /*+ hint */ *\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Clauses(hints.Comment(\"select\", \"hint\")).Select(),\n\t\t\tResult: \"SELECT /* hint */ *\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Clauses(hints.CommentBefore(\"select\", \"hint\")).Select(),\n\t\t\tResult: \"/* hint */ SELECT *\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Clauses(hints.CommentAfter(\"select\", \"hint\")).Select(),\n\t\t\tResult: \"SELECT * /* hint */\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Clauses(hints.CommentAfter(\"where\", \"hint\")).Select().Where(u.ID.Gt(0)),\n\t\t\tExpectedVars: []interface{}{uint(0)},\n\t\t\tResult:       \"SELECT * WHERE `id` > ? /* hint */\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Clauses(hints.UseIndex(\"user_name\")).Select(),\n\t\t\tOpts:   []stmtOpt{withFROM},\n\t\t\tResult: \"SELECT * FROM `users_info` USE INDEX (`user_name`)\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Clauses(hints.ForceIndex(\"user_name\", \"user_id\").ForJoin()).Select(),\n\t\t\tOpts:   []stmtOpt{withFROM},\n\t\t\tResult: \"SELECT * FROM `users_info` FORCE INDEX FOR JOIN (`user_name`,`user_id`)\",\n\t\t},\n\t\t{\n\t\t\tExpr: u.Clauses(\n\t\t\t\thints.ForceIndex(\"user_name\", \"user_id\").ForJoin(),\n\t\t\t\thints.IgnoreIndex(\"user_name\").ForGroupBy(),\n\t\t\t).Select(),\n\t\t\tOpts:   []stmtOpt{withFROM},\n\t\t\tResult: \"SELECT * FROM `users_info` FORCE INDEX FOR JOIN (`user_name`,`user_id`) IGNORE INDEX FOR GROUP BY (`user_name`)\",\n\t\t},\n\t\t// ======================== where conditions ========================\n\t\t{\n\t\t\tExpr:         u.Where(u.Where(u.ID.Neq(0)), u.Where(u.Age.Gt(18))),\n\t\t\tExpectedVars: []interface{}{uint(0), 18},\n\t\t\tResult:       \"WHERE `id` <> ? AND `age` > ?\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Age.Lte(18)).Or(u.Where(u.Name.Eq(\"tom\"))),\n\t\t\tExpectedVars: []interface{}{18, \"tom\"},\n\t\t\tResult:       \"WHERE `age` <= ? OR `name` = ?\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Age.Lte(18)).Or(u.Name.Eq(\"tom\"), u.Famous.Is(true)),\n\t\t\tExpectedVars: []interface{}{18, \"tom\", true},\n\t\t\tResult:       \"WHERE `age` <= ? OR (`name` = ? AND `famous` = ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Columns(u.ID, u.Age).In(field.Values([][]int{{1, 18}, {2, 19}}))),\n\t\t\tExpectedVars: []interface{}{1, 18, 2, 19},\n\t\t\tResult:       \"WHERE (`id`, `age`) IN ((?,?),(?,?))\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Columns(u.ID, u.Age).NotIn(field.Values([][]int{{1, 18}, {2, 19}}))),\n\t\t\tExpectedVars: []interface{}{1, 18, 2, 19},\n\t\t\tResult:       \"WHERE NOT (`id`, `age`) IN ((?,?),(?,?))\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Columns(u.ID, u.Name).In(field.Values([][]interface{}{{1, \"modi\"}, {2, \"tom\"}}))),\n\t\t\tExpectedVars: []interface{}{1, \"modi\", 2, \"tom\"},\n\t\t\tResult:       \"WHERE (`id`, `name`) IN ((?,?),(?,?))\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Where(u.Name.Eq(\"tom\"), u.Famous.Is(true))).Or(u.Age.Lte(18)),\n\t\t\tExpectedVars: []interface{}{\"tom\", true, 18},\n\t\t\tResult:       \"WHERE (`name` = ? AND `famous` = ?) OR `age` <= ?\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Name.Eq(\"tom\")).Where(u.Where(u.Famous.Is(true)).Or(u.Age.Lte(18))),\n\t\t\tExpectedVars: []interface{}{\"tom\", true, 18},\n\t\t\tResult:       \"WHERE `name` = ? AND (`famous` = ? OR `age` <= ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(u.Name.Eq(\"tom\"), field.Or(u.Famous.Is(true), u.Age.Lte(18))),\n\t\t\tExpectedVars: []interface{}{\"tom\", true, 18},\n\t\t\tResult:       \"WHERE `name` = ? AND (`famous` = ? OR `age` <= ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Where(Cond(datatypes.JSONQuery(\"attributes\").HasKey(\"role\", \"name\"))...),\n\t\t\tExpectedVars: []interface{}{\"$.role.name\"},\n\t\t\tResult:       \"WHERE JSON_EXTRACT(`attributes`,?) IS NOT NULL\",\n\t\t},\n\t\t{\n\t\t\tExpr: u.Where(\n\t\t\t\tu.Where(u.ID.Neq(0)).Where(u.Score.Gt(89.9)),\n\t\t\t\tu.Where(u.Age.Gt(18)).Where(u.Address.Eq(\"New York\")),\n\t\t\t),\n\t\t\tExpectedVars: []interface{}{uint(0), 89.9, 18, \"New York\"},\n\t\t\tResult:       \"WHERE (`id` <> ? AND `score` > ?) AND (`age` > ? AND `address` = ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr: u.Where(\n\t\t\t\tu.Where(u.Age.Gt(18)).Where(u.Where(u.Famous.Is(true)).Or(u.Score.Gte(100.0))),\n\t\t\t).Or(\n\t\t\t\tu.Where(u.Age.Lte(18)).Where(u.Name.Eq(\"tom\")),\n\t\t\t),\n\t\t\tExpectedVars: []interface{}{18, true, 100.0, 18, \"tom\"},\n\t\t\tResult:       \"WHERE (`age` > ? AND (`famous` = ? OR `score` >= ?)) OR (`age` <= ? AND `name` = ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Select(u.ID, u.Name).Where(u.Age.Gt(18), u.Score.Gte(100)),\n\t\t\tExpectedVars: []interface{}{18, 100.0},\n\t\t\tResult:       \"SELECT `id`,`name` WHERE `age` > ? AND `score` >= ?\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Select().Where(Cond(datatypes.JSONQuery(\"attributes\").HasKey(\"role\"))...),\n\t\t\tOpts:         []stmtOpt{withFROM},\n\t\t\tExpectedVars: []interface{}{\"$.role\"},\n\t\t\tResult:       \"SELECT * FROM `users_info` WHERE JSON_EXTRACT(`attributes`,?) IS NOT NULL\",\n\t\t},\n\t\t// ======================== subquery ========================\n\t\t{\n\t\t\tExpr:   u.Select().Where(u.Columns(u.ID).Eq(u.Select(u.ID.Max()))),\n\t\t\tResult: \"SELECT * WHERE `id` = (SELECT MAX(`id`) FROM `users_info`)\",\n\t\t},\n\t\t{\n\t\t\tExpr: u.Select().Where(\n\t\t\t\tu.Columns(u.ID).Eq(\n\t\t\t\t\tu.Select(u.ID).Where(\n\t\t\t\t\t\tu.Columns(u.Name).Eq(\n\t\t\t\t\t\t\tstudent.Select(student.Name).Where(student.ID.Eq(1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t)),\n\t\t\tExpectedVars: []interface{}{int64(1)},\n\t\t\tResult:       \"SELECT * WHERE `id` = (SELECT `id` FROM `users_info` WHERE `name` = (SELECT `student`.`name` FROM `student` WHERE `student`.`id` = ?))\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Select().Where(u.Columns(u.ID).Neq(u.Select(u.ID.Max()))),\n\t\t\tResult: \"SELECT * WHERE `id` <> (SELECT MAX(`id`) FROM `users_info`)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Select(u.ID).Where(u.Columns(u.Score.Mul(2)).Lte(u.Select(u.Score.Avg()))),\n\t\t\tExpectedVars: []interface{}{2.0},\n\t\t\tResult:       \"SELECT `id` WHERE `score`*? <= (SELECT AVG(`score`) FROM `users_info`)\",\n\t\t},\n\t\t{\n\t\t\tExpr:   u.Select(u.ID).Where(u.Columns(u.Score).Gt(u.Select(u.Score.Avg()))),\n\t\t\tResult: \"SELECT `id` WHERE `score` > (SELECT AVG(`score`) FROM `users_info`)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Select(u.ID, u.Name).Where(u.Columns(u.Score).Lte(u.Select(u.Score.Avg()).Where(u.Age.Gte(18)))),\n\t\t\tExpectedVars: []interface{}{18},\n\t\t\tResult:       \"SELECT `id`,`name` WHERE `score` <= (SELECT AVG(`score`) FROM `users_info` WHERE `age` >= ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Select(u.ID).Where(u.Columns(u.Score).In(u.Select(u.Score).Where(u.Age.Gte(18)))),\n\t\t\tExpectedVars: []interface{}{18},\n\t\t\tResult:       \"SELECT `id` WHERE `score` IN (SELECT `score` FROM `users_info` WHERE `age` >= ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Select(u.ID).Where(u.Columns(u.ID, u.Age).In(u.Select(u.ID, u.Age).Where(u.Score.Eq(100)))),\n\t\t\tExpectedVars: []interface{}{100.0},\n\t\t\tResult:       \"SELECT `id` WHERE (`id`,`age`) IN (SELECT `id`,`age` FROM `users_info` WHERE `score` = ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         u.Select(u.Age.Avg().As(\"avgage\")).Group(u.Name).Having(u.Columns(u.Age.Avg()).Gt(u.Select(u.Age.Avg()).Where(u.Name.Like(\"name%\")))),\n\t\t\tOpts:         []stmtOpt{withFROM},\n\t\t\tExpectedVars: []interface{}{\"name%\"},\n\t\t\tResult:       \"SELECT AVG(`age`) AS `avgage` FROM `users_info` GROUP BY `name` HAVING AVG(`age`) > (SELECT AVG(`age`) FROM `users_info` WHERE `name` LIKE ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:   student.Select().LeftJoin(teacher, teacher.ID.EqCol(student.Instructor)).Group(student.ID),\n\t\t\tResult: \"SELECT * FROM `student` LEFT JOIN `teacher` ON `teacher`.`id` = `student`.`instructor` GROUP BY `student`.`id`\",\n\t\t},\n\t\t// ======================== from subquery ========================\n\t\t{\n\t\t\tExpr:         Table(u.Select(u.ID, u.Name).Where(u.Age.Gt(18))).Select(),\n\t\t\tOpts:         []stmtOpt{withFROM},\n\t\t\tExpectedVars: []interface{}{18},\n\t\t\tResult:       \"SELECT * FROM (SELECT `id`,`name` FROM `users_info` WHERE `age` > ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         Table(u.Select(u.ID).Where(u.Age.Gt(18)), u.Select(u.ID).Where(u.Score.Gte(100))).Select(),\n\t\t\tOpts:         []stmtOpt{withFROM},\n\t\t\tExpectedVars: []interface{}{18, 100.0},\n\t\t\tResult:       \"SELECT * FROM (SELECT `id` FROM `users_info` WHERE `age` > ?), (SELECT `id` FROM `users_info` WHERE `score` >= ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         Table(u.Select().Where(u.Age.Gt(18)), u.Where(u.Score.Gte(100))).Select(),\n\t\t\tOpts:         []stmtOpt{withFROM},\n\t\t\tExpectedVars: []interface{}{18, 100.0},\n\t\t\tResult:       \"SELECT * FROM (SELECT * FROM `users_info` WHERE `age` > ?), (SELECT * FROM `users_info` WHERE `score` >= ?)\",\n\t\t},\n\t\t{\n\t\t\tExpr:         Table(u.Select().Where(u.Age.Gt(18)).As(\"a\"), u.Where(u.Score.Gte(100)).As(\"b\")).Select(),\n\t\t\tOpts:         []stmtOpt{withFROM},\n\t\t\tExpectedVars: []interface{}{18, 100.0},\n\t\t\tResult:       \"SELECT * FROM (SELECT * FROM `users_info` WHERE `age` > ?) AS `a`, (SELECT * FROM `users_info` WHERE `score` >= ?) AS `b`\",\n\t\t},\n\n\t\t// ======================== join subquery ========================\n\t\t{\n\t\t\tExpr:   student.Join(teacher, student.Instructor.EqCol(teacher.ID)).Select(),\n\t\t\tResult: \"SELECT * FROM `student` INNER JOIN `teacher` ON `student`.`instructor` = `teacher`.`id`\",\n\t\t},\n\t\t{\n\t\t\tExpr:         student.LeftJoin(teacher, student.Instructor.EqCol(teacher.ID)).Where(teacher.ID.Gt(0)).Select(student.Name, teacher.Name),\n\t\t\tResult:       \"SELECT `student`.`name`,`teacher`.`name` FROM `student` LEFT JOIN `teacher` ON `student`.`instructor` = `teacher`.`id` WHERE `teacher`.`id` > ?\",\n\t\t\tExpectedVars: []interface{}{int64(0)},\n\t\t},\n\t\t{\n\t\t\tExpr:         student.RightJoin(teacher, student.Instructor.EqCol(teacher.ID), student.ID.Eq(666)).Select(),\n\t\t\tResult:       \"SELECT * FROM `student` RIGHT JOIN `teacher` ON `student`.`instructor` = `teacher`.`id` AND `student`.`id` = ?\",\n\t\t\tExpectedVars: []interface{}{int64(666)},\n\t\t},\n\t\t{\n\t\t\tExpr:         student.Join(teacher, student.Instructor.EqCol(teacher.ID)).LeftJoin(teacher, student.ID.Gt(100)).Select(student.ID, student.Name, teacher.Name.As(\"teacher_name\")),\n\t\t\tResult:       \"SELECT `student`.`id`,`student`.`name`,`teacher`.`name` AS `teacher_name` FROM `student` INNER JOIN `teacher` ON `student`.`instructor` = `teacher`.`id` LEFT JOIN `teacher` ON `student`.`id` > ?\",\n\t\t\tExpectedVars: []interface{}{int64(100)},\n\t\t},\n\t}\n\n\t// _ = u.Update(u.Age, u.Age.Add(1))\n\t// _ = u.Update(u.Age, gorm.Expr(\"age+1\"))\n\t// _ = u.UpdateSimple(u.Age.Add(1))\n\n\t// _ = u.Find(u.ID.In(1, 2, 3))\n\n\tfor _, testcase := range testcases {\n\t\tcheckBuildExpr(t, testcase.Expr, testcase.Opts, testcase.Result, testcase.ExpectedVars)\n\t}\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.1240234375,
          "content": "package gen\n\nimport \"errors\"\n\nvar (\n\t// ErrEmptyCondition empty condition\n\tErrEmptyCondition = errors.New(\"empty condition\")\n)\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "field",
          "type": "tree",
          "content": null
        },
        {
          "name": "field_options.go",
          "type": "blob",
          "size": 9.1279296875,
          "content": "package gen\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"gorm.io/gen/field\"\n\t\"gorm.io/gen/internal/generate\"\n\t\"gorm.io/gen/internal/model\"\n\t\"gorm.io/gorm/schema\"\n)\n\n// ModelOpt field option\ntype ModelOpt = model.Option\n\n// Field exported model.Field\ntype Field = *model.Field\n\nvar ns = schema.NamingStrategy{}\n\nvar (\n\tFieldModify = func(opt func(Field) Field) model.ModifyFieldOpt {\n\t\treturn func(f *model.Field) *model.Field {\n\t\t\treturn opt(f)\n\t\t}\n\t}\n\n\t// WithDataTypesNullType configures the types of fields to use their datatypes nullable counterparts.\n\t/**\n\t *\n\t * @param {boolean} all - If true, all basic types of fields will be replaced with their `datatypes.Null[T]` types.\n\t *                        If false, only fields that are allowed to be null will be replaced with `datatypes.Null[T]` types.\n\t *\n\t * Examples:\n\t *\n\t * When `all` is true:\n\t * - `int64` will be replaced with `datatypes.NullInt64`\n\t * - `string` will be replaced with `datatypes.NullString`\n\t *\n\t * When `all` is false:\n\t * - Only fields that can be null (e.g., `*string` or `*int`) will be replaced with `datatypes.Null[T]` types.\n\t *\n\t * Note:\n\t * Ensure that proper error handling is implemented when converting\n\t * fields to their `datatypes.Null[T]` types to avoid runtime issues.\n\t */\n\tWithDataTypesNullType = func(all bool) model.ModifyFieldOpt {\n\t\treturn func(f *model.Field) *model.Field {\n\t\t\tft := f.Type\n\t\t\tnullable := false\n\t\t\tif strings.HasPrefix(ft, \"*\") {\n\t\t\t\tnullable = true\n\t\t\t\tft = strings.TrimLeft(ft, \"*\")\n\t\t\t}\n\t\t\tif !all && !nullable {\n\t\t\t\treturn f\n\t\t\t}\n\t\t\tswitch ft {\n\t\t\tcase \"time.Time\", \"string\", \"int\", \"int8\", \"int16\",\n\t\t\t\t\"int32\", \"int64\", \"uint\", \"uint8\", \"uint16\", \"uint32\",\n\t\t\t\t\"uint64\", \"float64\", \"float32\", \"byte\", \"bool\":\n\t\t\t\tft = fmt.Sprintf(\"datatypes.Null[%s]\", ft)\n\t\t\tdefault:\n\t\t\t\treturn f\n\t\t\t}\n\t\t\tf.CustomGenType = f.GenType()\n\t\t\tf.Type = ft\n\t\t\treturn f\n\t\t}\n\t}\n\n\t// FieldNew add new field (any type your want)\n\tFieldNew = func(fieldName, fieldType string, fieldTag field.Tag) model.CreateFieldOpt {\n\t\treturn func(*model.Field) *model.Field {\n\t\t\treturn &model.Field{\n\t\t\t\tName: fieldName,\n\t\t\t\tType: fieldType,\n\t\t\t\tTag:  fieldTag,\n\t\t\t}\n\t\t}\n\t}\n\t// FieldIgnore ignore some columns by name\n\tFieldIgnore = func(columnNames ...string) model.FilterFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tfor _, name := range columnNames {\n\t\t\t\tif m.ColumnName == name {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldIgnoreReg ignore some columns by RegExp\n\tFieldIgnoreReg = func(columnNameRegs ...string) model.FilterFieldOpt {\n\t\tregs := make([]regexp.Regexp, len(columnNameRegs))\n\t\tfor i, reg := range columnNameRegs {\n\t\t\tregs[i] = *regexp.MustCompile(reg)\n\t\t}\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tfor _, reg := range regs {\n\t\t\t\tif reg.MatchString(m.ColumnName) {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldRename specify field name in generated struct\n\tFieldRename = func(columnName string, newName string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif m.ColumnName == columnName {\n\t\t\t\tm.Name = newName\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldComment specify field comment in generated struct\n\tFieldComment = func(columnName string, comment string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif m.ColumnName == columnName {\n\t\t\t\tm.ColumnComment = comment\n\t\t\t\tm.MultilineComment = strings.Contains(comment, \"\\n\")\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldType specify field type in generated struct\n\tFieldType = func(columnName string, newType string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif m.ColumnName == columnName {\n\t\t\t\tm.Type = newType\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldTypeReg specify field type in generated struct by RegExp\n\tFieldTypeReg = func(columnNameReg string, newType string) model.ModifyFieldOpt {\n\t\treg := regexp.MustCompile(columnNameReg)\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif reg.MatchString(m.ColumnName) {\n\t\t\t\tm.Type = newType\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldGenType specify field gen type in generated dao\n\tFieldGenType = func(columnName string, newType string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif m.ColumnName == columnName {\n\t\t\t\tm.CustomGenType = newType\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldGenTypeReg specify field gen type in generated dao  by RegExp\n\tFieldGenTypeReg = func(columnNameReg string, newType string) model.ModifyFieldOpt {\n\t\treg := regexp.MustCompile(columnNameReg)\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif reg.MatchString(m.ColumnName) {\n\t\t\t\tm.CustomGenType = newType\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldTag specify GORM tag and JSON tag\n\tFieldTag = func(columnName string, tagFunc func(tag field.Tag) field.Tag) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif m.ColumnName == columnName {\n\t\t\t\tm.Tag = tagFunc(m.Tag)\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldJSONTag specify JSON tag\n\tFieldJSONTag = func(columnName string, jsonTag string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif m.ColumnName == columnName {\n\t\t\t\tm.Tag.Set(field.TagKeyJson, jsonTag)\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldJSONTagWithNS specify JSON tag with name strategy\n\tFieldJSONTagWithNS = func(schemaName func(columnName string) (tagContent string)) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif schemaName != nil {\n\t\t\t\tm.Tag.Set(field.TagKeyJson, schemaName(m.ColumnName))\n\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldGORMTag specify GORM tag\n\tFieldGORMTag = func(columnName string, gormTag func(tag field.GormTag) field.GormTag) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif m.ColumnName == columnName {\n\t\t\t\tm.GORMTag = gormTag(m.GORMTag)\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldGORMTagReg specify GORM tag by RegExp\n\tFieldGORMTagReg = func(columnNameReg string, gormTag func(tag field.GormTag) field.GormTag) model.ModifyFieldOpt {\n\t\treg := regexp.MustCompile(columnNameReg)\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif reg.MatchString(m.ColumnName) {\n\t\t\t\tm.GORMTag = gormTag(m.GORMTag)\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldNewTag add new tag\n\tFieldNewTag = func(columnName string, newTag field.Tag) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif m.ColumnName == columnName {\n\t\t\t\tfor k, v := range newTag {\n\t\t\t\t\tm.Tag.Set(k, v)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldNewTagWithNS add new tag with name strategy\n\tFieldNewTagWithNS = func(tagName string, schemaName func(columnName string) string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tif schemaName == nil {\n\t\t\t\tschemaName = func(name string) string { return name }\n\t\t\t}\n\t\t\tm.Tag.Set(tagName, schemaName(m.ColumnName))\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldTrimPrefix trim column name's prefix\n\tFieldTrimPrefix = func(prefix string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tm.Name = strings.TrimPrefix(m.Name, prefix)\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldTrimSuffix trim column name's suffix\n\tFieldTrimSuffix = func(suffix string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tm.Name = strings.TrimSuffix(m.Name, suffix)\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldAddPrefix add prefix to struct's memeber name\n\tFieldAddPrefix = func(prefix string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tm.Name = prefix + m.Name\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldAddSuffix add suffix to struct's memeber name\n\tFieldAddSuffix = func(suffix string) model.ModifyFieldOpt {\n\t\treturn func(m *model.Field) *model.Field {\n\t\t\tm.Name += suffix\n\t\t\treturn m\n\t\t}\n\t}\n\t// FieldRelate relate to table in database\n\tFieldRelate = func(relationship field.RelationshipType, fieldName string, table *generate.QueryStructMeta, config *field.RelateConfig) model.CreateFieldOpt {\n\t\tif config == nil {\n\t\t\tconfig = &field.RelateConfig{}\n\t\t}\n\n\t\treturn func(*model.Field) *model.Field {\n\t\t\treturn &model.Field{\n\t\t\t\tName:    fieldName,\n\t\t\t\tType:    config.RelateFieldPrefix(relationship) + table.StructInfo.Type,\n\t\t\t\tTag:     config.GetTag(fieldName),\n\t\t\t\tGORMTag: config.GORMTag,\n\t\t\t\tRelation: field.NewRelationWithType(\n\t\t\t\t\trelationship, fieldName, table.StructInfo.Package+\".\"+table.StructInfo.Type,\n\t\t\t\t\ttable.Relations()...),\n\t\t\t}\n\t\t}\n\t}\n\t// FieldRelateModel relate to exist table model\n\tFieldRelateModel = func(relationship field.RelationshipType, fieldName string, relModel interface{}, config *field.RelateConfig) model.CreateFieldOpt {\n\t\tst := reflect.TypeOf(relModel)\n\t\tif st.Kind() == reflect.Ptr {\n\t\t\tst = st.Elem()\n\t\t}\n\t\tfieldType := st.String()\n\n\t\tif config == nil {\n\t\t\tconfig = &field.RelateConfig{}\n\t\t}\n\n\t\treturn func(*model.Field) *model.Field {\n\t\t\treturn &model.Field{\n\t\t\t\tName:     fieldName,\n\t\t\t\tType:     config.RelateFieldPrefix(relationship) + fieldType,\n\t\t\t\tGORMTag:  config.GORMTag,\n\t\t\t\tTag:      config.GetTag(fieldName),\n\t\t\t\tRelation: field.NewRelationWithModel(relationship, fieldName, fieldType, relModel),\n\t\t\t}\n\t\t}\n\t}\n\n\t// WithMethod add custom method for table model\n\tWithMethod = func(methods ...interface{}) model.AddMethodOpt {\n\t\treturn func() []interface{} { return methods }\n\t}\n)\n\nvar (\n\tDefaultMethodTableWithNamer = (&defaultModel{}).TableName\n)\n\ntype defaultModel struct {\n}\n\nfunc (*defaultModel) TableName(namer schema.Namer) string {\n\tif namer == nil {\n\t\treturn \"@@table\"\n\t}\n\treturn namer.TableName(\"@@table\")\n}\n"
        },
        {
          "name": "generator.go",
          "type": "blob",
          "size": 16.16015625,
          "content": "package gen\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/template\"\n\n\t\"golang.org/x/tools/go/packages\"\n\t\"golang.org/x/tools/imports\"\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/schema\"\n\n\t\"gorm.io/gen/helper\"\n\t\"gorm.io/gen/internal/generate\"\n\t\"gorm.io/gen/internal/model\"\n\t\"gorm.io/gen/internal/parser\"\n\ttmpl \"gorm.io/gen/internal/template\"\n\t\"gorm.io/gen/internal/utils/pools\"\n)\n\n// T generic type\ntype T interface{}\n\n// M map[string]interface{}\ntype M map[string]interface{}\n\n// SQLResult sql.result\ntype SQLResult sql.Result\n\n// SQLRow sql.Row\ntype SQLRow sql.Row\n\n// SQLRows sql.Rows\ntype SQLRows sql.Rows\n\n// RowsAffected execute affected raws\ntype RowsAffected int64\n\nvar concurrent = runtime.NumCPU()\n\n// NewGenerator create a new generator\nfunc NewGenerator(cfg Config) *Generator {\n\tif err := cfg.Revise(); err != nil {\n\t\tpanic(fmt.Errorf(\"create generator fail: %w\", err))\n\t}\n\n\treturn &Generator{\n\t\tConfig: cfg,\n\t\tData:   make(map[string]*genInfo),\n\t\tmodels: make(map[string]*generate.QueryStructMeta),\n\t}\n}\n\n// genInfo info about generated code\ntype genInfo struct {\n\t*generate.QueryStructMeta\n\tInterfaces []*generate.InterfaceMethod\n}\n\nfunc (i *genInfo) appendMethods(methods []*generate.InterfaceMethod) {\n\tfor _, newMethod := range methods {\n\t\tif i.methodInGenInfo(newMethod) {\n\t\t\tcontinue\n\t\t}\n\t\ti.Interfaces = append(i.Interfaces, newMethod)\n\t}\n}\n\nfunc (i *genInfo) methodInGenInfo(m *generate.InterfaceMethod) bool {\n\tfor _, method := range i.Interfaces {\n\t\tif method.IsRepeatFromSameInterface(m) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Generator code generator\ntype Generator struct {\n\tConfig\n\n\tData   map[string]*genInfo                  //gen query data\n\tmodels map[string]*generate.QueryStructMeta //gen model data\n}\n\n// UseDB set db connection\nfunc (g *Generator) UseDB(db *gorm.DB) {\n\tif db != nil {\n\t\tg.db = db\n\t}\n}\n\n/*\n** The feature of mapping table from database server to Golang struct\n** Provided by @qqxhb\n */\n\n// GenerateModel catch table info from db, return a BaseStruct\nfunc (g *Generator) GenerateModel(tableName string, opts ...ModelOpt) *generate.QueryStructMeta {\n\treturn g.GenerateModelAs(tableName, g.db.Config.NamingStrategy.SchemaName(tableName), opts...)\n}\n\n// GenerateModelAs catch table info from db, return a BaseStruct\nfunc (g *Generator) GenerateModelAs(tableName string, modelName string, opts ...ModelOpt) *generate.QueryStructMeta {\n\tmeta, err := generate.GetQueryStructMeta(g.db, g.genModelConfig(tableName, modelName, opts))\n\tif err != nil {\n\t\tg.db.Logger.Error(context.Background(), \"generate struct from table fail: %s\", err)\n\t\tpanic(\"generate struct fail\")\n\t}\n\tif meta == nil {\n\t\tg.info(fmt.Sprintf(\"ignore table <%s>\", tableName))\n\t\treturn nil\n\t}\n\tg.models[meta.ModelStructName] = meta\n\n\tg.info(fmt.Sprintf(\"got %d columns from table <%s>\", len(meta.Fields), meta.TableName))\n\treturn meta\n}\n\n// GenerateAllTable generate all tables in db\nfunc (g *Generator) GenerateAllTable(opts ...ModelOpt) (tableModels []interface{}) {\n\ttableList, err := g.db.Migrator().GetTables()\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"get all tables fail: %w\", err))\n\t}\n\n\tg.info(fmt.Sprintf(\"find %d table from db: %s\", len(tableList), tableList))\n\n\ttableModels = make([]interface{}, len(tableList))\n\tfor i, tableName := range tableList {\n\t\ttableModels[i] = g.GenerateModel(tableName, opts...)\n\t}\n\treturn tableModels\n}\n\n// GenerateModelFrom generate model from object\nfunc (g *Generator) GenerateModelFrom(obj helper.Object) *generate.QueryStructMeta {\n\ts, err := generate.GetQueryStructMetaFromObject(obj, g.genModelObjConfig())\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"generate struct from object fail: %w\", err))\n\t}\n\tg.models[s.ModelStructName] = s\n\n\tg.info(fmt.Sprintf(\"parse object %s\", obj.StructName()))\n\treturn s\n}\n\nfunc (g *Generator) genModelConfig(tableName string, modelName string, modelOpts []ModelOpt) *model.Config {\n\tif modelOpts == nil {\n\t\tmodelOpts = g.modelOpts\n\t} else {\n\t\tmodelOpts = append(modelOpts, g.modelOpts...)\n\t}\n\treturn &model.Config{\n\t\tModelPkg:       g.Config.ModelPkgPath,\n\t\tTablePrefix:    g.getTablePrefix(),\n\t\tTableName:      tableName,\n\t\tModelName:      modelName,\n\t\tImportPkgPaths: g.importPkgPaths,\n\t\tModelOpts:      modelOpts,\n\t\tNameStrategy: model.NameStrategy{\n\t\t\tSchemaNameOpts: g.dbNameOpts,\n\t\t\tTableNameNS:    g.tableNameNS,\n\t\t\tModelNameNS:    g.modelNameNS,\n\t\t\tFileNameNS:     g.fileNameNS,\n\t\t},\n\t\tFieldConfig: model.FieldConfig{\n\t\t\tDataTypeMap: g.dataTypeMap,\n\n\t\t\tFieldSignable:     g.FieldSignable,\n\t\t\tFieldNullable:     g.FieldNullable,\n\t\t\tFieldCoverable:    g.FieldCoverable,\n\t\t\tFieldWithIndexTag: g.FieldWithIndexTag,\n\t\t\tFieldWithTypeTag:  g.FieldWithTypeTag,\n\n\t\t\tFieldJSONTagNS: g.fieldJSONTagNS,\n\t\t},\n\t}\n}\n\nfunc (g *Generator) getTablePrefix() string {\n\tif ns, ok := g.db.NamingStrategy.(schema.NamingStrategy); ok {\n\t\treturn ns.TablePrefix\n\t}\n\treturn \"\"\n}\n\nfunc (g *Generator) genModelObjConfig() *model.Config {\n\treturn &model.Config{\n\t\tModelPkg:       g.Config.ModelPkgPath,\n\t\tImportPkgPaths: g.importPkgPaths,\n\t\tNameStrategy: model.NameStrategy{\n\t\t\tTableNameNS: g.tableNameNS,\n\t\t\tModelNameNS: g.modelNameNS,\n\t\t\tFileNameNS:  g.fileNameNS,\n\t\t},\n\t}\n}\n\n// ApplyBasic specify models which will implement basic .diy_method\nfunc (g *Generator) ApplyBasic(models ...interface{}) {\n\tg.ApplyInterface(func() {}, models...)\n}\n\n// ApplyInterface specifies .diy_method interfaces on structures, implment codes will be generated after calling g.Execute()\n// eg: g.ApplyInterface(func(model.Method){}, model.User{}, model.Company{})\nfunc (g *Generator) ApplyInterface(fc interface{}, models ...interface{}) {\n\tstructs, err := generate.ConvertStructs(g.db, models...)\n\tif err != nil {\n\t\tg.db.Logger.Error(context.Background(), \"check struct fail: %v\", err)\n\t\tpanic(\"check struct fail\")\n\t}\n\tg.apply(fc, structs)\n}\n\nfunc (g *Generator) apply(fc interface{}, structs []*generate.QueryStructMeta) {\n\tinterfacePaths, err := parser.GetInterfacePath(fc)\n\tif err != nil {\n\t\tg.db.Logger.Error(context.Background(), \"get interface name or file fail: %s\", err)\n\t\tpanic(\"check interface fail\")\n\t}\n\n\treadInterface := new(parser.InterfaceSet)\n\terr = readInterface.ParseFile(interfacePaths, generate.GetStructNames(structs))\n\tif err != nil {\n\t\tg.db.Logger.Error(context.Background(), \"parser interface file fail: %s\", err)\n\t\tpanic(\"parser interface file fail\")\n\t}\n\n\tfor _, interfaceStructMeta := range structs {\n\t\tif g.judgeMode(WithoutContext) {\n\t\t\tinterfaceStructMeta.ReviseFieldNameFor(model.GormKeywords)\n\t\t}\n\t\tinterfaceStructMeta.ReviseFieldNameFor(model.DOKeywords)\n\n\t\tgenInfo, err := g.pushQueryStructMeta(interfaceStructMeta)\n\t\tif err != nil {\n\t\t\tg.db.Logger.Error(context.Background(), \"gen struct fail: %v\", err)\n\t\t\tpanic(\"gen struct fail\")\n\t\t}\n\n\t\tfunctions, err := generate.BuildDIYMethod(readInterface, interfaceStructMeta, genInfo.Interfaces)\n\t\tif err != nil {\n\t\t\tg.db.Logger.Error(context.Background(), \"check interface fail: %v\", err)\n\t\t\tpanic(\"check interface fail\")\n\t\t}\n\t\tgenInfo.appendMethods(functions)\n\t}\n}\n\n// Execute generate code to output path\nfunc (g *Generator) Execute() {\n\tg.info(\"Start generating code.\")\n\n\tif err := g.generateModelFile(); err != nil {\n\t\tg.db.Logger.Error(context.Background(), \"generate model struct fail: %s\", err)\n\t\tpanic(\"generate model struct fail\")\n\t}\n\n\tif err := g.generateQueryFile(); err != nil {\n\t\tg.db.Logger.Error(context.Background(), \"generate query code fail: %s\", err)\n\t\tpanic(\"generate query code fail\")\n\t}\n\n\tg.info(\"Generate code done.\")\n}\n\n// info logger\nfunc (g *Generator) info(logInfos ...string) {\n\tfor _, l := range logInfos {\n\t\tg.db.Logger.Info(context.Background(), l)\n\t\tlog.Println(l)\n\t}\n}\n\n// generateQueryFile generate query code and save to file\nfunc (g *Generator) generateQueryFile() (err error) {\n\tif len(g.Data) == 0 {\n\t\treturn nil\n\t}\n\n\tif err = os.MkdirAll(g.OutPath, os.ModePerm); err != nil {\n\t\treturn fmt.Errorf(\"make dir outpath(%s) fail: %s\", g.OutPath, err)\n\t}\n\n\terrChan := make(chan error)\n\tpool := pools.NewPool(concurrent)\n\t// generate query code for all struct\n\tfor _, info := range g.Data {\n\t\tpool.Wait()\n\t\tgo func(info *genInfo) {\n\t\t\tdefer pool.Done()\n\t\t\terr := g.generateSingleQueryFile(info)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t}\n\n\t\t\tif g.WithUnitTest {\n\t\t\t\terr = g.generateQueryUnitTestFile(info)\n\t\t\t\tif err != nil { // do not panic\n\t\t\t\t\tg.db.Logger.Error(context.Background(), \"generate unit test fail: %s\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}(info)\n\t}\n\tselect {\n\tcase err = <-errChan:\n\t\treturn err\n\tcase <-pool.AsyncWaitAll():\n\t}\n\n\t// generate query file\n\tvar buf bytes.Buffer\n\terr = render(tmpl.Header, &buf, map[string]interface{}{\n\t\t\"Package\":        g.queryPkgName,\n\t\t\"ImportPkgPaths\": importList.Add(g.importPkgPaths...).Paths(),\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif g.judgeMode(WithDefaultQuery) {\n\t\terr = render(tmpl.DefaultQuery, &buf, g)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\terr = render(tmpl.QueryMethod, &buf, g)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = g.output(g.OutFile, buf.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\tg.info(\"generate query file: \" + g.OutFile)\n\n\t// generate query unit test file\n\tif g.WithUnitTest {\n\t\tbuf.Reset()\n\n\t\terr = render(tmpl.Header, &buf, map[string]interface{}{\n\t\t\t\"Package\":        g.queryPkgName,\n\t\t\t\"ImportPkgPaths\": unitTestImportList.Add(g.importPkgPaths...).Paths(),\n\t\t})\n\t\tif err != nil {\n\t\t\tg.db.Logger.Error(context.Background(), \"generate query unit test fail: %s\", err)\n\t\t\treturn nil\n\t\t}\n\t\terr = render(tmpl.DIYMethodTestBasic, &buf, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = render(tmpl.QueryMethodTest, &buf, g)\n\t\tif err != nil {\n\t\t\tg.db.Logger.Error(context.Background(), \"generate query unit test fail: %s\", err)\n\t\t\treturn nil\n\t\t}\n\t\tfileName := strings.TrimSuffix(g.OutFile, \".go\") + \"_test.go\"\n\t\terr = g.output(fileName, buf.Bytes())\n\t\tif err != nil {\n\t\t\tg.db.Logger.Error(context.Background(), \"generate query unit test fail: %s\", err)\n\t\t\treturn nil\n\t\t}\n\t\tg.info(\"generate unit test file: \" + fileName)\n\t}\n\n\treturn nil\n}\n\n// generateSingleQueryFile generate query code and save to file\nfunc (g *Generator) generateSingleQueryFile(data *genInfo) (err error) {\n\tvar buf bytes.Buffer\n\n\tstructPkgPath := data.StructInfo.PkgPath\n\tif structPkgPath == \"\" {\n\t\tstructPkgPath = g.modelPkgPath\n\t}\n\terr = render(tmpl.Header, &buf, map[string]interface{}{\n\t\t\"Package\":        g.queryPkgName,\n\t\t\"ImportPkgPaths\": importList.Add(g.importPkgPaths...).Add(structPkgPath).Add(getImportPkgPaths(data)...).Paths(),\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdata.QueryStructMeta = data.QueryStructMeta.IfaceMode(g.judgeMode(WithQueryInterface))\n\n\tstructTmpl := tmpl.TableQueryStructWithContext\n\tif g.judgeMode(WithoutContext) {\n\t\tstructTmpl = tmpl.TableQueryStruct\n\t}\n\terr = render(structTmpl, &buf, data.QueryStructMeta)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif g.judgeMode(WithQueryInterface) {\n\t\terr = render(tmpl.TableQueryIface, &buf, data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor _, method := range data.Interfaces {\n\t\terr = render(tmpl.DIYMethod, &buf, method)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = render(tmpl.CRUDMethod, &buf, data.QueryStructMeta)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer g.info(fmt.Sprintf(\"generate query file: %s%s%s.gen.go\", g.OutPath, string(os.PathSeparator), data.FileName))\n\treturn g.output(fmt.Sprintf(\"%s%s%s.gen.go\", g.OutPath, string(os.PathSeparator), data.FileName), buf.Bytes())\n}\n\n// generateQueryUnitTestFile generate unit test file for query\nfunc (g *Generator) generateQueryUnitTestFile(data *genInfo) (err error) {\n\tvar buf bytes.Buffer\n\n\tstructPkgPath := data.StructInfo.PkgPath\n\tif structPkgPath == \"\" {\n\t\tstructPkgPath = g.modelPkgPath\n\t}\n\terr = render(tmpl.Header, &buf, map[string]interface{}{\n\t\t\"Package\":        g.queryPkgName,\n\t\t\"ImportPkgPaths\": unitTestImportList.Add(structPkgPath).Add(data.ImportPkgPaths...).Paths(),\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = render(tmpl.CRUDMethodTest, &buf, data.QueryStructMeta)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, method := range data.Interfaces {\n\t\terr = render(tmpl.DIYMethodTest, &buf, method)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tdefer g.info(fmt.Sprintf(\"generate unit test file: %s%s%s.gen_test.go\", g.OutPath, string(os.PathSeparator), data.FileName))\n\treturn g.output(fmt.Sprintf(\"%s%s%s.gen_test.go\", g.OutPath, string(os.PathSeparator), data.FileName), buf.Bytes())\n}\n\n// generateModelFile generate model structures and save to file\nfunc (g *Generator) generateModelFile() error {\n\tif len(g.models) == 0 {\n\t\treturn nil\n\t}\n\n\tmodelOutPath, err := g.getModelOutputPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.MkdirAll(modelOutPath, os.ModePerm); err != nil {\n\t\treturn fmt.Errorf(\"create model pkg path(%s) fail: %s\", modelOutPath, err)\n\t}\n\n\terrChan := make(chan error)\n\tpool := pools.NewPool(concurrent)\n\tfor _, data := range g.models {\n\t\tif data == nil || !data.Generated {\n\t\t\tcontinue\n\t\t}\n\t\tpool.Wait()\n\t\tgo func(data *generate.QueryStructMeta) {\n\t\t\tdefer pool.Done()\n\n\t\t\tvar buf bytes.Buffer\n\t\t\terr := render(tmpl.Model, &buf, data)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor _, method := range data.ModelMethods {\n\t\t\t\terr = render(tmpl.ModelMethod, &buf, method)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrChan <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmodelFile := modelOutPath + data.FileName + \".gen.go\"\n\t\t\terr = g.output(modelFile, buf.Bytes())\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tg.info(fmt.Sprintf(\"generate model file(table <%s> -> {%s.%s}): %s\", data.TableName, data.StructInfo.Package, data.StructInfo.Type, modelFile))\n\t\t}(data)\n\t}\n\tselect {\n\tcase err = <-errChan:\n\t\treturn err\n\tcase <-pool.AsyncWaitAll():\n\t\tg.fillModelPkgPath(modelOutPath)\n\t}\n\treturn nil\n}\n\nfunc (g *Generator) getModelOutputPath() (outPath string, err error) {\n\tif strings.Contains(g.ModelPkgPath, string(os.PathSeparator)) {\n\t\toutPath, err = filepath.Abs(g.ModelPkgPath)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"cannot parse model pkg path: %w\", err)\n\t\t}\n\t} else {\n\t\toutPath = filepath.Join(filepath.Dir(g.OutPath), g.ModelPkgPath)\n\t}\n\treturn outPath + string(os.PathSeparator), nil\n}\n\nfunc (g *Generator) fillModelPkgPath(filePath string) {\n\tpkgs, err := packages.Load(&packages.Config{\n\t\tMode: packages.NeedName,\n\t\tDir:  filePath,\n\t})\n\tif err != nil {\n\t\tg.db.Logger.Warn(context.Background(), \"parse model pkg path fail: %s\", err)\n\t\treturn\n\t}\n\tif len(pkgs) == 0 {\n\t\tg.db.Logger.Warn(context.Background(), \"parse model pkg path fail: got 0 packages\")\n\t\treturn\n\t}\n\tg.Config.modelPkgPath = pkgs[0].PkgPath\n}\n\n// output format and output\nfunc (g *Generator) output(fileName string, content []byte) error {\n\tresult, err := imports.Process(fileName, content, nil)\n\tif err != nil {\n\t\tlines := strings.Split(string(content), \"\\n\")\n\t\terrLine, _ := strconv.Atoi(strings.Split(err.Error(), \":\")[1])\n\t\tstartLine, endLine := errLine-5, errLine+5\n\t\tfmt.Println(\"Format fail:\", errLine, err)\n\t\tif startLine < 0 {\n\t\t\tstartLine = 0\n\t\t}\n\t\tif endLine > len(lines)-1 {\n\t\t\tendLine = len(lines) - 1\n\t\t}\n\t\tfor i := startLine; i <= endLine; i++ {\n\t\t\tfmt.Println(i, lines[i])\n\t\t}\n\t\treturn fmt.Errorf(\"cannot format file: %w\", err)\n\t}\n\treturn os.WriteFile(fileName, result, 0640)\n}\n\nfunc (g *Generator) pushQueryStructMeta(meta *generate.QueryStructMeta) (*genInfo, error) {\n\tstructName := meta.ModelStructName\n\tif g.Data[structName] == nil {\n\t\tg.Data[structName] = &genInfo{QueryStructMeta: meta}\n\t}\n\tif g.Data[structName].Source != meta.Source {\n\t\treturn nil, fmt.Errorf(\"cannot generate struct with the same name from different source:%s.%s and %s.%s\",\n\t\t\tmeta.StructInfo.Package, meta.ModelStructName, g.Data[structName].StructInfo.Package, g.Data[structName].ModelStructName)\n\t}\n\treturn g.Data[structName], nil\n}\n\nfunc render(tmpl string, wr io.Writer, data interface{}) error {\n\tt, err := template.New(tmpl).Parse(tmpl)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn t.Execute(wr, data)\n}\n\nfunc getImportPkgPaths(data *genInfo) []string {\n\timportPathMap := make(map[string]struct{})\n\tfor _, path := range data.ImportPkgPaths {\n\t\timportPathMap[path] = struct{}{}\n\t}\n\t// imports.Process (called in Generator.output) will guess missing imports, and will be\n\t// much faster if import path is already specified. So add all imports from DIY interface package.\n\tfor _, method := range data.Interfaces {\n\t\tfor _, param := range method.Params {\n\t\t\timportPathMap[param.PkgPath] = struct{}{}\n\t\t}\n\t}\n\timportPkgPaths := make([]string, 0, len(importPathMap))\n\tfor importPath := range importPathMap {\n\t\timportPkgPaths = append(importPkgPaths, importPath)\n\t}\n\treturn importPkgPaths\n}\n"
        },
        {
          "name": "generator_test.go",
          "type": "blob",
          "size": 6.189453125,
          "content": "package gen\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/callbacks\"\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/schema\"\n\t\"gorm.io/gorm/utils/tests\"\n\n\t\"gorm.io/gen/field\"\n)\n\nfunc TestConfig(t *testing.T) {\n\t_ = &Config{\n\t\tdb: nil,\n\n\t\tOutPath: \"path\",\n\t\tOutFile: \"\",\n\n\t\tModelPkgPath: \"models\",\n\n\t\tqueryPkgName: \"query\",\n\t}\n}\n\n// test data\ntype mysqlDialectors struct{ tests.DummyDialector }\n\nfunc (mysqlDialectors) Name() string {\n\treturn \"mysql\"\n}\n\nvar db, _ = gorm.Open(mysqlDialectors{}, nil)\n\nfunc init() {\n\tdb = db.Debug()\n\n\tcallbacks.RegisterDefaultCallbacks(db, &callbacks.Config{\n\t\tUpdateClauses: []string{\"UPDATE\", \"SET\", \"WHERE\", \"ORDER BY\", \"LIMIT\"},\n\t\tDeleteClauses: []string{\"DELETE\", \"FROM\", \"WHERE\", \"ORDER BY\", \"LIMIT\"},\n\t})\n}\n\n// User user data struct\ntype User struct {\n\tID         uint `gorm:\"primary_key\"`\n\tName       string\n\tAge        int\n\tScore      float64\n\tAddress    string\n\tFamous     bool\n\tRegisterAt time.Time\n}\n\nfunc (User) TableName() string {\n\treturn \"users_info\"\n}\n\n// StudentRaw student data struct\ntype StudentRaw struct {\n\tID         int64 `gorm:\"primary_key\"`\n\tName       string\n\tAge        int\n\tInstructor int64 //\n}\n\nfunc (StudentRaw) TableName() string {\n\treturn \"student\"\n}\n\n// Teacher teacher data struct\ntype TeacherRaw struct {\n\tID   int64 `gorm:\"primary_key\"`\n\tName string\n}\n\nfunc (TeacherRaw) TableName() string {\n\treturn \"teacher\"\n}\n\ntype user struct {\n\tuserDo\n\n\tALL        field.Asterisk\n\tID         field.Uint\n\tName       field.String\n\tAge        field.Int\n\tScore      field.Float64\n\tAddress    field.String\n\tFamous     field.Bool\n\tRegisterAt field.Time\n}\n\ntype userDo struct{ DO }\n\nfunc (u userDo) Debug() *userDo {\n\tu.DO = *u.DO.Debug().(*DO)\n\treturn &u\n}\n\nfunc (u userDo) WithContext(ctx context.Context) *userDo {\n\tu.DO = *u.DO.WithContext(ctx).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Clauses(conds ...clause.Expression) *userDo {\n\tu.DO = *u.DO.Clauses(conds...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Not(conds ...Condition) *userDo {\n\tu.DO = *u.DO.Not(conds...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Or(conds ...Condition) *userDo {\n\tu.DO = *u.DO.Or(conds...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Select(conds ...field.Expr) *userDo {\n\tu.DO = *u.DO.Select(conds...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Where(conds ...Condition) *userDo {\n\tu.DO = *u.DO.Where(conds...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Order(conds ...field.Expr) *userDo {\n\tu.DO = *u.DO.Order(conds...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Distinct(cols ...field.Expr) *userDo {\n\tu.DO = *u.DO.Distinct(cols...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Omit(cols ...field.Expr) *userDo {\n\tu.DO = *u.DO.Omit(cols...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Join(table schema.Tabler, on ...field.Expr) *userDo {\n\tu.DO = *u.DO.Join(table, on...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) LeftJoin(table schema.Tabler, on ...field.Expr) *userDo {\n\tu.DO = *u.DO.LeftJoin(table, on...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) RightJoin(table schema.Tabler, on ...field.Expr) *userDo {\n\tu.DO = *u.DO.RightJoin(table, on...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Group(col field.Expr) *userDo {\n\tu.DO = *u.DO.Group(col).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Having(conds ...Condition) *userDo {\n\tu.DO = *u.DO.Having(conds...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Limit(limit int) *userDo {\n\tu.DO = *u.DO.Limit(limit).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Offset(offset int) *userDo {\n\tu.DO = *u.DO.Offset(offset).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Scopes(funcs ...func(Dao) Dao) *userDo {\n\tu.DO = *u.DO.Scopes(funcs...).(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Unscoped() *userDo {\n\tu.DO = *u.DO.Unscoped().(*DO)\n\treturn &u\n}\n\nfunc (u userDo) Create(values ...*user) error {\n\tif len(values) == 0 {\n\t\treturn nil\n\t}\n\treturn u.DO.Create(values)\n}\n\nfunc (u userDo) CreateInBatches(values []*user, batchSize int) error {\n\treturn u.DO.CreateInBatches(values, batchSize)\n}\n\nfunc (u userDo) Save(values ...*user) error {\n\tif len(values) == 0 {\n\t\treturn nil\n\t}\n\treturn u.DO.Save(values)\n}\n\nfunc (u userDo) First() (*user, error) {\n\tif result, err := u.DO.First(); err != nil {\n\t\treturn nil, err\n\t} else {\n\t\treturn result.(*user), nil\n\t}\n}\n\nfunc (u userDo) Take() (*user, error) {\n\tif result, err := u.DO.Take(); err != nil {\n\t\treturn nil, err\n\t} else {\n\t\treturn result.(*user), nil\n\t}\n}\n\nfunc (u userDo) Last() (*user, error) {\n\tif result, err := u.DO.Last(); err != nil {\n\t\treturn nil, err\n\t} else {\n\t\treturn result.(*user), nil\n\t}\n}\n\nfunc (u userDo) Find() ([]*user, error) {\n\tresult, err := u.DO.Find()\n\treturn result.([]*user), err\n}\n\nfunc (u userDo) FindInBatches(result []*user, batchSize int, fc func(tx Dao, batch int) error) error {\n\treturn u.DO.FindInBatches(&result, batchSize, fc)\n}\n\nfunc (u userDo) FindByPage(offset int, limit int) (result []*user, count int64, err error) {\n\tcount, err = u.Count()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tresult, err = u.Offset(offset).Limit(limit).Find()\n\treturn\n}\n\nvar u = func() *user {\n\tu := user{\n\t\tALL:        field.NewAsterisk(\"\"),\n\t\tID:         field.NewUint(\"\", \"id\"),\n\t\tName:       field.NewString(\"\", \"name\"),\n\t\tAge:        field.NewInt(\"\", \"age\"),\n\t\tScore:      field.NewFloat64(\"\", \"score\"),\n\t\tAddress:    field.NewString(\"\", \"address\"),\n\t\tFamous:     field.NewBool(\"\", \"famous\"),\n\t\tRegisterAt: field.NewTime(\"\", \"register_at\"),\n\t}\n\tu.UseDB(db.Session(&gorm.Session{Context: context.Background(), DryRun: true}))\n\tu.UseModel(User{})\n\treturn &u\n}()\n\ntype Student struct {\n\tDO\n\n\tALL        field.Asterisk\n\tID         field.Int64\n\tName       field.String\n\tAge        field.Int\n\tInstructor field.Int64\n}\n\nvar student = func() *Student {\n\ts := Student{\n\t\tALL:        field.NewAsterisk(\"student\"),\n\t\tID:         field.NewInt64(\"student\", \"id\"),\n\t\tName:       field.NewString(\"student\", \"name\"),\n\t\tAge:        field.NewInt(\"student\", \"age\"),\n\t\tInstructor: field.NewInt64(\"student\", \"instructor\"),\n\t}\n\ts.UseDB(db.Session(&gorm.Session{Context: context.Background(), DryRun: true}))\n\ts.UseModel(StudentRaw{})\n\treturn &s\n}()\n\ntype Teacher struct {\n\tDO\n\n\tALL  field.Asterisk\n\tID   field.Int64\n\tName field.String\n}\n\nvar teacher = func() Teacher {\n\tt := Teacher{\n\t\tALL:  field.NewAsterisk(\"teacher\"),\n\t\tID:   field.NewInt64(\"teacher\", \"id\"),\n\t\tName: field.NewString(\"teacher\", \"name\"),\n\t}\n\tt.UseDB(db.Session(&gorm.Session{Context: context.Background(), DryRun: true}))\n\tt.UseModel(TeacherRaw{})\n\treturn t\n}()\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.521484375,
          "content": "module gorm.io/gen\n\ngo 1.18\n\nrequire (\n\tgolang.org/x/tools v0.17.0\n\tgorm.io/datatypes v1.2.4\n\tgorm.io/gorm v1.25.11\n\tgorm.io/hints v1.1.0\n\tgorm.io/plugin/dbresolver v1.5.0\n)\n\nrequire (\n\tfilippo.io/edwards25519 v1.1.0 // indirect\n\tgithub.com/go-sql-driver/mysql v1.8.1 // indirect\n\tgithub.com/google/uuid v1.3.0 // indirect\n\tgithub.com/jinzhu/inflection v1.0.0 // indirect\n\tgithub.com/jinzhu/now v1.1.5 // indirect\n\tgolang.org/x/mod v0.14.0 // indirect\n\tgolang.org/x/text v0.14.0 // indirect\n\tgorm.io/driver/mysql v1.5.6 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.7333984375,
          "content": "filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\nfilippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-sql-driver/mysql v1.6.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=\ngithub.com/go-sql-driver/mysql v1.7.0/go.mod h1:OXbVy3sEdcQ2Doequ6Z5BW6fXNQTmx+9S1MCJN5yJMI=\ngithub.com/go-sql-driver/mysql v1.8.1 h1:LedoTUt/eveggdHS9qUFC1EFSa8bU2+1pZjSRpvNJ1Y=\ngithub.com/go-sql-driver/mysql v1.8.1/go.mod h1:wEBSXgmK//2ZFJyE+qWnIsVGmvmEKlqwuVSjsCm7DZg=\ngithub.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 h1:au07oEsX2xN0ktxqI+Sida1w446QrXBRJ0nee3SNZlA=\ngithub.com/golang-sql/sqlexp v0.1.0 h1:ZCD6MBpcuOVfGVqsEmY5/4FtYiKz6tSyUv9LPEDei6A=\ngithub.com/google/uuid v1.3.0 h1:t6JiXgmwXMjEs8VusXIJk2BXHsn+wx8BZdTaoZ5fu7I=\ngithub.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=\ngithub.com/jackc/pgservicefile v0.0.0-20231201235250-de7065d80cb9 h1:L0QtFUgDarD7Fpv9jeVMgy/+Ec0mtnmYuImjTz6dtDA=\ngithub.com/jackc/pgx/v5 v5.5.5 h1:amBjrZVmksIdNjxGW/IiIMzxMKZFelXbUoPNb+8sjQw=\ngithub.com/jackc/puddle/v2 v2.2.1 h1:RhxXJtFG022u4ibrCSMSiu5aOq1i77R3OHKNJj77OAk=\ngithub.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=\ngithub.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=\ngithub.com/jinzhu/now v1.1.2/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=\ngithub.com/jinzhu/now v1.1.4/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=\ngithub.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=\ngithub.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=\ngithub.com/mattn/go-sqlite3 v1.14.8/go.mod h1:NyWgC/yNuGj7Q9rpYnZvas74GogHl5/Z4A/KQRfk6bU=\ngithub.com/mattn/go-sqlite3 v1.14.15 h1:vfoHhTN1af61xCRSWzFIWzx2YskyMTwHLrExkBOjvxI=\ngithub.com/microsoft/go-mssqldb v0.17.0 h1:Fto83dMZPnYv1Zwx5vHHxpNraeEaUlQ/hhHLgZiaenE=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngolang.org/x/crypto v0.22.0 h1:g1v0xeRhjcugydODzvb3mEM9SQ0HGp9s/nh3COQ/C30=\ngolang.org/x/mod v0.14.0 h1:dGoOF9QVLYng8IHTm7BAyWqCqSheQ5pYWGhzW00YJr0=\ngolang.org/x/mod v0.14.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/sync v0.6.0 h1:5BMeUDZ7vkXGfEr1x9B4bRcTH4lpkTkpdh0T/J+qjbQ=\ngolang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/tools v0.17.0 h1:FvmRgNOcs3kOa+T20R1uhfP9F6HgG2mfxDv1vrx1Htc=\ngolang.org/x/tools v0.17.0/go.mod h1:xsh6VxdV005rRVaS6SSAf9oiAqljS7UZUacMZ8Bnsps=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngorm.io/datatypes v1.2.4 h1:uZmGAcK/QZ0uyfCuVg0VQY1ZmV9h1fuG0tMwKByO1z4=\ngorm.io/datatypes v1.2.4/go.mod h1:f4BsLcFAX67szSv8svwLRjklArSHAvHLeE3pXAS5DZI=\ngorm.io/driver/mysql v1.4.3/go.mod h1:sSIebwZAVPiT+27jK9HIwvsqOGKx3YMPmrA3mBJR10c=\ngorm.io/driver/mysql v1.5.6 h1:Ld4mkIickM+EliaQZQx3uOJDJHtrd70MxAUqWqlx3Y8=\ngorm.io/driver/mysql v1.5.6/go.mod h1:sEtPWMiqiN1N1cMXoXmBbd8C6/l+TESwriotuRRpkDM=\ngorm.io/driver/postgres v1.5.0 h1:u2FXTy14l45qc3UeCJ7QaAXZmZfDDv0YrthvmRq1l0U=\ngorm.io/driver/sqlite v1.1.6/go.mod h1:W8LmC/6UvVbHKah0+QOC7Ja66EaZXHwUTjgXY8YNWX8=\ngorm.io/driver/sqlite v1.4.3 h1:HBBcZSDnWi5BW3B3rwvVTc510KGkBkexlOg0QrmLUuU=\ngorm.io/driver/sqlserver v1.4.1 h1:t4r4r6Jam5E6ejqP7N82qAJIJAht27EGT41HyPfXRw0=\ngorm.io/gorm v1.21.15/go.mod h1:F+OptMscr0P2F2qU97WT1WimdH9GaQPoDW7AYd5i2Y0=\ngorm.io/gorm v1.22.2/go.mod h1:F+OptMscr0P2F2qU97WT1WimdH9GaQPoDW7AYd5i2Y0=\ngorm.io/gorm v1.23.8/go.mod h1:l2lP/RyAtc1ynaTjFksBde/O8v9oOGIApu2/xRitmZk=\ngorm.io/gorm v1.25.2/go.mod h1:L4uxeKpfBml98NYqVqwAdmV1a2nBtAec/cf3fpucW/k=\ngorm.io/gorm v1.25.7/go.mod h1:hbnx/Oo0ChWMn1BIhpy1oYozzpM15i4YPuHDmfYtwg8=\ngorm.io/gorm v1.25.11 h1:/Wfyg1B/je1hnDx3sMkX+gAlxrlZpn6X0BXRlwXlvHg=\ngorm.io/gorm v1.25.11/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=\ngorm.io/hints v1.1.0 h1:Lp4z3rxREufSdxn4qmkK3TLDltrM10FLTHiuqwDPvXw=\ngorm.io/hints v1.1.0/go.mod h1:lKQ0JjySsPBj3uslFzY3JhYDtqEwzm+G1hv8rWujB6Y=\ngorm.io/plugin/dbresolver v1.5.0 h1:XVHLxh775eP0CqVh3vcfJtYqja3uFl5Wr3cKlY8jgDY=\ngorm.io/plugin/dbresolver v1.5.0/go.mod h1:l4Cn87EHLEYuqUncpEeTC2tTJQkjngPSD+lo8hIvcT0=\n"
        },
        {
          "name": "helper",
          "type": "tree",
          "content": null
        },
        {
          "name": "import.go",
          "type": "blob",
          "size": 1.06640625,
          "content": "package gen\n\nimport \"strings\"\n\nvar (\n\timportList = new(importPkgS).Add(\n\t\t\"context\",\n\t\t\"database/sql\",\n\t\t\"strings\",\n\t\t\"\",\n\t\t\"gorm.io/gorm\",\n\t\t\"gorm.io/gorm/schema\",\n\t\t\"gorm.io/gorm/clause\",\n\t\t\"\",\n\t\t\"gorm.io/gen\",\n\t\t\"gorm.io/gen/field\",\n\t\t\"gorm.io/gen/helper\",\n\t\t\"\",\n\t\t\"gorm.io/plugin/dbresolver\",\n\t)\n\tunitTestImportList = new(importPkgS).Add(\n\t\t\"context\",\n\t\t\"fmt\",\n\t\t\"strconv\",\n\t\t\"testing\",\n\t\t\"\",\n\t\t\"gorm.io/driver/sqlite\",\n\t\t\"gorm.io/gorm\",\n\t)\n)\n\ntype importPkgS struct {\n\tpaths []string\n}\n\nfunc (ip importPkgS) Add(paths ...string) *importPkgS {\n\tpurePaths := make([]string, 0, len(paths)+1)\n\tfor _, p := range paths {\n\t\tp = strings.TrimSpace(p)\n\t\tif p == \"\" {\n\t\t\tpurePaths = append(purePaths, p)\n\t\t\tcontinue\n\t\t}\n\n\t\tif p[len(p)-1] != '\"' {\n\t\t\tp = `\"` + p + `\"`\n\t\t}\n\n\t\tvar exists bool\n\t\tfor _, existsP := range ip.paths {\n\t\t\tif p == existsP {\n\t\t\t\texists = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !exists {\n\t\t\tpurePaths = append(purePaths, p)\n\t\t}\n\t}\n\tpurePaths = append(purePaths, \"\")\n\n\tip.paths = append(ip.paths, purePaths...)\n\n\treturn &ip\n}\n\nfunc (ip importPkgS) Paths() []string { return ip.paths }\n"
        },
        {
          "name": "interface.go",
          "type": "blob",
          "size": 2.4892578125,
          "content": "package gen\n\nimport (\n\t\"database/sql\"\n\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/schema\"\n\n\t\"gorm.io/gen/field\"\n)\n\ntype (\n\t// Condition query condition\n\t// field.Expr and subquery are expect value\n\tCondition interface {\n\t\tBeCond() interface{}\n\t\tCondError() error\n\t}\n)\n\nvar (\n\t_ Condition = (field.Expr)(nil)\n\t_ Condition = (field.Value)(nil)\n\t_ Condition = (SubQuery)(nil)\n\t_ Condition = (Dao)(nil)\n)\n\n// SubQuery sub query interface\ntype SubQuery interface {\n\tunderlyingDB() *gorm.DB\n\tunderlyingDO() *DO\n\n\tCondition\n}\n\n// Dao CRUD methods\ntype Dao interface {\n\tSubQuery\n\tschema.Tabler\n\tAs(alias string) Dao\n\n\tNot(conds ...Condition) Dao\n\tOr(conds ...Condition) Dao\n\n\tSelect(columns ...field.Expr) Dao\n\tWhere(conds ...Condition) Dao\n\tOrder(columns ...field.Expr) Dao\n\tDistinct(columns ...field.Expr) Dao\n\tOmit(columns ...field.Expr) Dao\n\tJoin(table schema.Tabler, conds ...field.Expr) Dao\n\tLeftJoin(table schema.Tabler, conds ...field.Expr) Dao\n\tRightJoin(table schema.Tabler, conds ...field.Expr) Dao\n\tGroup(columns ...field.Expr) Dao\n\tHaving(conds ...Condition) Dao\n\tLimit(limit int) Dao\n\tOffset(offset int) Dao\n\tScopes(funcs ...func(Dao) Dao) Dao\n\tUnscoped() Dao\n\tAttrs(attrs ...field.AssignExpr) Dao\n\tAssign(attrs ...field.AssignExpr) Dao\n\tJoins(field field.RelationField) Dao\n\tPreload(field field.RelationField) Dao\n\tClauses(conds ...clause.Expression) Dao\n\n\tCreate(value interface{}) error\n\tCreateInBatches(value interface{}, batchSize int) error\n\tSave(value interface{}) error\n\tFirst() (result interface{}, err error)\n\tTake() (result interface{}, err error)\n\tLast() (result interface{}, err error)\n\tFind() (results interface{}, err error)\n\tFindInBatches(dest interface{}, batchSize int, fc func(tx Dao, batch int) error) error\n\tFirstOrInit() (result interface{}, err error)\n\tFirstOrCreate() (result interface{}, err error)\n\tUpdate(column field.Expr, value interface{}) (info ResultInfo, err error)\n\tUpdateSimple(columns ...field.AssignExpr) (info ResultInfo, err error)\n\tUpdates(values interface{}) (info ResultInfo, err error)\n\tUpdateColumn(column field.Expr, value interface{}) (info ResultInfo, err error)\n\tUpdateColumns(values interface{}) (info ResultInfo, err error)\n\tUpdateColumnSimple(columns ...field.AssignExpr) (info ResultInfo, err error)\n\tDelete(...interface{}) (info ResultInfo, err error)\n\tCount() (int64, error)\n\tRow() *sql.Row\n\tRows() (*sql.Rows, error)\n\tScan(dest interface{}) error\n\tPluck(column field.Expr, dest interface{}) error\n\tScanRows(rows *sql.Rows, dest interface{}) error\n\n\tAddError(err error) error\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "sec_check.go",
          "type": "blob",
          "size": 2.8212890625,
          "content": "package gen\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/hints\"\n\t\"gorm.io/plugin/dbresolver\"\n)\n\nfunc checkConds(conds []clause.Expression) error {\n\tfor _, cond := range conds {\n\t\tif err := CheckClause(cond); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nvar banClauses = map[string]bool{\n\t// \"INSERT\": true,\n\t\"VALUES\": true,\n\t// \"ON CONFLICT\": true,\n\t\"SELECT\":   true,\n\t\"FROM\":     true,\n\t\"WHERE\":    true,\n\t\"GROUP BY\": true,\n\t\"ORDER BY\": true,\n\t\"LIMIT\":    true,\n\t// \"FOR\":      true,\n\t\"UPDATE\": true,\n\t\"SET\":    true,\n\t\"DELETE\": true,\n}\n\n// CheckClause check security of Expression\nfunc CheckClause(cond clause.Expression) error {\n\tswitch cond := cond.(type) {\n\tcase hints.Hints, hints.IndexHint, dbresolver.Operation:\n\t\treturn nil\n\tcase clause.OnConflict:\n\t\treturn checkOnConflict(cond)\n\tcase clause.Locking:\n\t\treturn checkLocking(cond)\n\tcase clause.Insert:\n\t\treturn checkInsert(cond)\n\tcase clause.Interface:\n\t\tif banClauses[cond.Name()] {\n\t\t\treturn fmt.Errorf(\"clause %s is banned\", cond.Name())\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown clause %v\", cond)\n}\n\nfunc checkOnConflict(c clause.OnConflict) error {\n\tfor _, item := range c.DoUpdates {\n\t\tswitch item.Value.(type) {\n\t\tcase clause.Expr, *clause.Expr:\n\t\t\treturn errors.New(\"OnConflict clause assignment with gorm.Expr is banned for security reasons for now\")\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc checkLocking(c clause.Locking) error {\n\tif strength := strings.ToUpper(strings.TrimSpace(c.Strength)); strength != \"UPDATE\" && strength != \"SHARE\" {\n\t\treturn errors.New(\"Locking clause's Strength only allow assignments of UPDATE/SHARE\")\n\t}\n\tif c.Table.Raw {\n\t\treturn errors.New(\"Locking clause's Table cannot be set Raw==true\")\n\t}\n\tif options := strings.ToUpper(strings.TrimSpace(c.Options)); options != \"\" && options != \"NOWAIT\" && options != \"SKIP LOCKED\" {\n\t\treturn errors.New(\"Locking clause's Options only allow assignments of NOWAIT/SKIP LOCKED for now\")\n\t}\n\treturn nil\n}\n\n// checkInsert check if clause.Insert is safe\n// https://dev.mysql.com/doc/refman/8.0/en/sql-statements.html#insert\nfunc checkInsert(c clause.Insert) error {\n\tif c.Table.Raw == true {\n\t\treturn errors.New(\"Table Raw cannot be true\")\n\t}\n\n\tif c.Modifier == \"\" {\n\t\treturn nil\n\t}\n\n\tvar priority, ignore string\n\tif modifiers := strings.SplitN(strings.ToUpper(strings.TrimSpace(c.Modifier)), \" \", 2); len(modifiers) == 2 {\n\t\tpriority, ignore = strings.TrimSpace(modifiers[0]), strings.TrimSpace(modifiers[1])\n\t} else {\n\t\tignore = strings.TrimSpace(modifiers[0])\n\t}\n\tif priority != \"\" && !in(priority, \"LOW_PRIORITY\", \"DELAYED\", \"HIGH_PRIORITY\") {\n\t\treturn errors.New(\"invalid priority value\")\n\t}\n\tif ignore != \"\" && ignore != \"IGNORE\" {\n\t\treturn errors.New(\"invalid modifiers value, should be IGNORE\")\n\t}\n\treturn nil\n}\n\nfunc in(s string, v ...string) bool {\n\tfor _, vv := range v {\n\t\tif vv == s {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}