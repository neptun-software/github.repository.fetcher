{
  "metadata": {
    "timestamp": 1736567086237,
    "page": 676,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rs/cors",
      "stars": 2708,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "Copyright (c) 2014 Olivier Poitrey <rs@dailymotion.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.6796875,
          "content": "# Go CORS handler [![godoc](http://img.shields.io/badge/godoc-reference-blue.svg?style=flat)](https://godoc.org/github.com/rs/cors) [![license](http://img.shields.io/badge/license-MIT-red.svg?style=flat)](https://raw.githubusercontent.com/rs/cors/master/LICENSE) [![Go Coverage](https://github.com/rs/cors/wiki/coverage.svg)](https://raw.githack.com/wiki/rs/cors/coverage.html)\n\nCORS is a `net/http` handler implementing [Cross Origin Resource Sharing W3 specification](http://www.w3.org/TR/cors/) in Golang.\n\n## Getting Started\n\nAfter installing Go and setting up your [GOPATH](http://golang.org/doc/code.html#GOPATH), create your first `.go` file. We'll call it `server.go`.\n\n```go\npackage main\n\nimport (\n    \"net/http\"\n\n    \"github.com/rs/cors\"\n)\n\nfunc main() {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.Write([]byte(\"{\\\"hello\\\": \\\"world\\\"}\"))\n    })\n\n    // cors.Default() setup the middleware with default options being\n    // all origins accepted with simple methods (GET, POST). See\n    // documentation below for more options.\n    handler := cors.Default().Handler(mux)\n    http.ListenAndServe(\":8080\", handler)\n}\n```\n\nInstall `cors`:\n\n    go get github.com/rs/cors\n\nThen run your server:\n\n    go run server.go\n\nThe server now runs on `localhost:8080`:\n\n    $ curl -D - -H 'Origin: http://foo.com' http://localhost:8080/\n    HTTP/1.1 200 OK\n    Access-Control-Allow-Origin: foo.com\n    Content-Type: application/json\n    Date: Sat, 25 Oct 2014 03:43:57 GMT\n    Content-Length: 18\n\n    {\"hello\": \"world\"}\n\n### Allow * With Credentials Security Protection\n\nThis library has been modified to avoid a well known security issue when configured with `AllowedOrigins` to `*` and `AllowCredentials` to `true`. Such setup used to make the library reflects the request `Origin` header value, working around a security protection embedded into the standard that makes clients to refuse such configuration. This behavior has been removed with [#55](https://github.com/rs/cors/issues/55) and [#57](https://github.com/rs/cors/issues/57).\n\nIf you depend on this behavior and understand the implications, you can restore it using the `AllowOriginFunc` with `func(origin string) {return true}`.\n\nPlease refer to [#55](https://github.com/rs/cors/issues/55) for more information about the security implications.\n\n### More Examples\n\n* `net/http`: [examples/nethttp/server.go](https://github.com/rs/cors/blob/master/examples/nethttp/server.go)\n* [Goji](https://goji.io): [examples/goji/server.go](https://github.com/rs/cors/blob/master/examples/goji/server.go)\n* [Martini](http://martini.codegangsta.io): [examples/martini/server.go](https://github.com/rs/cors/blob/master/examples/martini/server.go)\n* [Negroni](https://github.com/codegangsta/negroni): [examples/negroni/server.go](https://github.com/rs/cors/blob/master/examples/negroni/server.go)\n* [Alice](https://github.com/justinas/alice): [examples/alice/server.go](https://github.com/rs/cors/blob/master/examples/alice/server.go)\n* [HttpRouter](https://github.com/julienschmidt/httprouter): [examples/httprouter/server.go](https://github.com/rs/cors/blob/master/examples/httprouter/server.go)\n* [Gorilla](http://www.gorillatoolkit.org/pkg/mux): [examples/gorilla/server.go](https://github.com/rs/cors/blob/master/examples/gorilla/server.go)\n* [Buffalo](https://gobuffalo.io): [examples/buffalo/server.go](https://github.com/rs/cors/blob/master/examples/buffalo/server.go)\n* [Gin](https://gin-gonic.github.io/gin): [examples/gin/server.go](https://github.com/rs/cors/blob/master/examples/gin/server.go)\n* [Chi](https://github.com/go-chi/chi): [examples/chi/server.go](https://github.com/rs/cors/blob/master/examples/chi/server.go)\n\n## Parameters\n\nParameters are passed to the middleware thru the `cors.New` method as follow:\n\n```go\nc := cors.New(cors.Options{\n    AllowedOrigins: []string{\"http://foo.com\", \"http://foo.com:8080\"},\n    AllowCredentials: true,\n    // Enable Debugging for testing, consider disabling in production\n    Debug: true,\n})\n\n// Insert the middleware\nhandler = c.Handler(handler)\n```\n\n* **AllowedOrigins** `[]string`: A list of origins a cross-domain request can be executed from. If the special `*` value is present in the list, all origins will be allowed. An origin may contain a wildcard (`*`) to replace 0 or more characters (i.e.: `http://*.domain.com`). Usage of wildcards implies a small performance penality. Only one wildcard can be used per origin. The default value is `*`.\n* **AllowOriginFunc** `func (origin string) bool`: A custom function to validate the origin. It takes the origin as an argument and returns true if allowed, or false otherwise. If this option is set, the content of `AllowedOrigins` is ignored.\n* **AllowOriginRequestFunc** `func (r *http.Request, origin string) bool`: A custom function to validate the origin. It takes the HTTP Request object and the origin as argument and returns true if allowed or false otherwise. If this option is set, the contents of `AllowedOrigins` and `AllowOriginFunc` are ignored.\nDeprecated: use `AllowOriginVaryRequestFunc` instead.\n* **AllowOriginVaryRequestFunc** `func(r *http.Request, origin string) (bool, []string)`: A custom function to validate the origin. It takes the HTTP Request object and the origin as argument and returns true if allowed or false otherwise with a list of headers used to take that decision if any so they can be added to the Vary header. If this option is set, the contents of `AllowedOrigins`, `AllowOriginFunc` and `AllowOriginRequestFunc` are ignored.\n* **AllowedMethods** `[]string`: A list of methods the client is allowed to use with cross-domain requests. Default value is simple methods (`GET` and `POST`).\n* **AllowedHeaders** `[]string`: A list of non simple headers the client is allowed to use with cross-domain requests.\n* **ExposedHeaders** `[]string`: Indicates which headers are safe to expose to the API of a CORS API specification.\n* **AllowCredentials** `bool`: Indicates whether the request can include user credentials like cookies, HTTP authentication or client side SSL certificates. The default is `false`.\n* **AllowPrivateNetwork** `bool`: Indicates whether to accept cross-origin requests over a private network.\n* **MaxAge** `int`: Indicates how long (in seconds) the results of a preflight request can be cached. The default is `0` which stands for no max age.\n* **OptionsPassthrough** `bool`: Instructs preflight to let other potential next handlers to process the `OPTIONS` method. Turn this on if your application handles `OPTIONS`.\n* **OptionsSuccessStatus** `int`: Provides a status code to use for successful OPTIONS requests. Default value is `http.StatusNoContent` (`204`).\n* **Debug** `bool`: Debugging flag adds additional output to debug server side CORS issues.\n\nSee [API documentation](http://godoc.org/github.com/rs/cors) for more info.\n\n## Benchmarks\n\n```\ngoos: darwin\ngoarch: arm64\npkg: github.com/rs/cors\nBenchmarkWithout-10            \t135325480\t         8.124 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkDefault-10            \t24082140\t        51.40 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkAllowedOrigin-10      \t16424518\t        88.25 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkPreflight-10          \t 8010259\t       147.3 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkPreflightHeader-10    \t 6850962\t       175.0 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkWildcard/match-10     \t253275342\t         4.714 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkWildcard/too_short-10 \t1000000000\t         0.6235 ns/op\t       0 B/op\t       0 allocs/op\nPASS\nok  \tgithub.com/rs/cors\t99.131s\n```\n\n## Licenses\n\nAll source code is licensed under the [MIT License](https://raw.github.com/rs/cors/master/LICENSE).\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 2.8583984375,
          "content": "package cors\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype FakeResponse struct {\n\theader http.Header\n}\n\nfunc (r FakeResponse) Header() http.Header {\n\treturn r.header\n}\n\nfunc (r FakeResponse) WriteHeader(n int) {\n}\n\nfunc (r FakeResponse) Write(b []byte) (n int, err error) {\n\treturn len(b), nil\n}\n\nconst (\n\theaderOrigin  = \"Origin\"\n\theaderACRM    = \"Access-Control-Request-Method\"\n\theaderACRH    = \"Access-Control-Request-Headers\"\n\tdummyEndpoint = \"http://example.com/foo\"\n\tdummyOrigin   = \"https://somedomain.com\"\n)\n\nfunc BenchmarkWithout(b *testing.B) {\n\tresps := makeFakeResponses(b.N)\n\treq, _ := http.NewRequest(http.MethodGet, dummyEndpoint, nil)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttestHandler.ServeHTTP(resps[i], req)\n\t}\n}\n\nfunc BenchmarkDefault(b *testing.B) {\n\tresps := makeFakeResponses(b.N)\n\treq, _ := http.NewRequest(http.MethodGet, dummyEndpoint, nil)\n\treq.Header.Add(headerOrigin, dummyOrigin)\n\thandler := Default().Handler(testHandler)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\thandler.ServeHTTP(resps[i], req)\n\t}\n}\n\nfunc BenchmarkAllowedOrigin(b *testing.B) {\n\tresps := makeFakeResponses(b.N)\n\treq, _ := http.NewRequest(http.MethodGet, dummyEndpoint, nil)\n\treq.Header.Add(headerOrigin, dummyOrigin)\n\tc := New(Options{\n\t\tAllowedOrigins: []string{dummyOrigin},\n\t})\n\thandler := c.Handler(testHandler)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\thandler.ServeHTTP(resps[i], req)\n\t}\n}\n\nfunc BenchmarkPreflight(b *testing.B) {\n\tresps := makeFakeResponses(b.N)\n\treq, _ := http.NewRequest(http.MethodOptions, dummyEndpoint, nil)\n\treq.Header.Add(headerOrigin, dummyOrigin)\n\treq.Header.Add(headerACRM, http.MethodGet)\n\thandler := Default().Handler(testHandler)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\thandler.ServeHTTP(resps[i], req)\n\t}\n}\n\nfunc BenchmarkPreflightHeader(b *testing.B) {\n\tresps := makeFakeResponses(b.N)\n\treq, _ := http.NewRequest(http.MethodOptions, dummyEndpoint, nil)\n\treq.Header.Add(headerOrigin, dummyOrigin)\n\treq.Header.Add(headerACRM, http.MethodGet)\n\treq.Header.Add(headerACRH, \"accept\")\n\thandler := Default().Handler(testHandler)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\thandler.ServeHTTP(resps[i], req)\n\t}\n}\n\nfunc BenchmarkPreflightAdversarialACRH(b *testing.B) {\n\tresps := makeFakeResponses(b.N)\n\treq, _ := http.NewRequest(http.MethodOptions, dummyEndpoint, nil)\n\treq.Header.Add(headerOrigin, dummyOrigin)\n\treq.Header.Add(headerACRM, http.MethodGet)\n\treq.Header.Add(headerACRH, strings.Repeat(\",\", 1024))\n\thandler := Default().Handler(testHandler)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\thandler.ServeHTTP(resps[i], req)\n\t}\n}\n\nfunc makeFakeResponses(n int) []*FakeResponse {\n\tresps := make([]*FakeResponse, n)\n\tfor i := 0; i < n; i++ {\n\t\tresps[i] = &FakeResponse{http.Header{\n\t\t\t\"Content-Type\": []string{\"text/plain\"},\n\t\t}}\n\t}\n\treturn resps\n}\n"
        },
        {
          "name": "cors.go",
          "type": "blob",
          "size": 17.236328125,
          "content": "/*\nPackage cors is net/http handler to handle CORS related requests\nas defined by http://www.w3.org/TR/cors/\n\nYou can configure it by passing an option struct to cors.New:\n\n\tc := cors.New(cors.Options{\n\t    AllowedOrigins:   []string{\"foo.com\"},\n\t    AllowedMethods:   []string{http.MethodGet, http.MethodPost, http.MethodDelete},\n\t    AllowCredentials: true,\n\t})\n\nThen insert the handler in the chain:\n\n\thandler = c.Handler(handler)\n\nSee Options documentation for more options.\n\nThe resulting handler is a standard net/http handler.\n*/\npackage cors\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/rs/cors/internal\"\n)\n\nvar headerVaryOrigin = []string{\"Origin\"}\nvar headerOriginAll = []string{\"*\"}\nvar headerTrue = []string{\"true\"}\n\n// Options is a configuration container to setup the CORS middleware.\ntype Options struct {\n\t// AllowedOrigins is a list of origins a cross-domain request can be executed from.\n\t// If the special \"*\" value is present in the list, all origins will be allowed.\n\t// An origin may contain a wildcard (*) to replace 0 or more characters\n\t// (i.e.: http://*.domain.com). Usage of wildcards implies a small performance penalty.\n\t// Only one wildcard can be used per origin.\n\t// Default value is [\"*\"]\n\tAllowedOrigins []string\n\t// AllowOriginFunc is a custom function to validate the origin. It take the\n\t// origin as argument and returns true if allowed or false otherwise. If\n\t// this option is set, the content of `AllowedOrigins` is ignored.\n\tAllowOriginFunc func(origin string) bool\n\t// AllowOriginRequestFunc is a custom function to validate the origin. It\n\t// takes the HTTP Request object and the origin as argument and returns true\n\t// if allowed or false otherwise. If headers are used take the decision,\n\t// consider using AllowOriginVaryRequestFunc instead. If this option is set,\n\t// the contents of `AllowedOrigins`, `AllowOriginFunc` are ignored.\n\t//\n\t// Deprecated: use `AllowOriginVaryRequestFunc` instead.\n\tAllowOriginRequestFunc func(r *http.Request, origin string) bool\n\t// AllowOriginVaryRequestFunc is a custom function to validate the origin.\n\t// It takes the HTTP Request object and the origin as argument and returns\n\t// true if allowed or false otherwise with a list of headers used to take\n\t// that decision if any so they can be added to the Vary header. If this\n\t// option is set, the contents of `AllowedOrigins`, `AllowOriginFunc` and\n\t// `AllowOriginRequestFunc` are ignored.\n\tAllowOriginVaryRequestFunc func(r *http.Request, origin string) (bool, []string)\n\t// AllowedMethods is a list of methods the client is allowed to use with\n\t// cross-domain requests. Default value is simple methods (HEAD, GET and POST).\n\tAllowedMethods []string\n\t// AllowedHeaders is list of non simple headers the client is allowed to use with\n\t// cross-domain requests.\n\t// If the special \"*\" value is present in the list, all headers will be allowed.\n\t// Default value is [].\n\tAllowedHeaders []string\n\t// ExposedHeaders indicates which headers are safe to expose to the API of a CORS\n\t// API specification\n\tExposedHeaders []string\n\t// MaxAge indicates how long (in seconds) the results of a preflight request\n\t// can be cached. Default value is 0, which stands for no\n\t// Access-Control-Max-Age header to be sent back, resulting in browsers\n\t// using their default value (5s by spec). If you need to force a 0 max-age,\n\t// set `MaxAge` to a negative value (ie: -1).\n\tMaxAge int\n\t// AllowCredentials indicates whether the request can include user credentials like\n\t// cookies, HTTP authentication or client side SSL certificates.\n\tAllowCredentials bool\n\t// AllowPrivateNetwork indicates whether to accept cross-origin requests over a\n\t// private network.\n\tAllowPrivateNetwork bool\n\t// OptionsPassthrough instructs preflight to let other potential next handlers to\n\t// process the OPTIONS method. Turn this on if your application handles OPTIONS.\n\tOptionsPassthrough bool\n\t// Provides a status code to use for successful OPTIONS requests.\n\t// Default value is http.StatusNoContent (204).\n\tOptionsSuccessStatus int\n\t// Debugging flag adds additional output to debug server side CORS issues\n\tDebug bool\n\t// Adds a custom logger, implies Debug is true\n\tLogger Logger\n}\n\n// Logger generic interface for logger\ntype Logger interface {\n\tPrintf(string, ...interface{})\n}\n\n// Cors http handler\ntype Cors struct {\n\t// Debug logger\n\tLog Logger\n\t// Normalized list of plain allowed origins\n\tallowedOrigins []string\n\t// List of allowed origins containing wildcards\n\tallowedWOrigins []wildcard\n\t// Optional origin validator function\n\tallowOriginFunc func(r *http.Request, origin string) (bool, []string)\n\t// Normalized list of allowed headers\n\t// Note: the Fetch standard guarantees that CORS-unsafe request-header names\n\t// (i.e. the values listed in the Access-Control-Request-Headers header)\n\t// are unique and sorted;\n\t// see https://fetch.spec.whatwg.org/#cors-unsafe-request-header-names.\n\tallowedHeaders internal.SortedSet\n\t// Normalized list of allowed methods\n\tallowedMethods []string\n\t// Pre-computed normalized list of exposed headers\n\texposedHeaders []string\n\t// Pre-computed maxAge header value\n\tmaxAge []string\n\t// Set to true when allowed origins contains a \"*\"\n\tallowedOriginsAll bool\n\t// Set to true when allowed headers contains a \"*\"\n\tallowedHeadersAll bool\n\t// Status code to use for successful OPTIONS requests\n\toptionsSuccessStatus int\n\tallowCredentials     bool\n\tallowPrivateNetwork  bool\n\toptionPassthrough    bool\n\tpreflightVary        []string\n}\n\n// New creates a new Cors handler with the provided options.\nfunc New(options Options) *Cors {\n\tc := &Cors{\n\t\tallowCredentials:    options.AllowCredentials,\n\t\tallowPrivateNetwork: options.AllowPrivateNetwork,\n\t\toptionPassthrough:   options.OptionsPassthrough,\n\t\tLog:                 options.Logger,\n\t}\n\tif options.Debug && c.Log == nil {\n\t\tc.Log = log.New(os.Stdout, \"[cors] \", log.LstdFlags)\n\t}\n\n\t// Allowed origins\n\tswitch {\n\tcase options.AllowOriginVaryRequestFunc != nil:\n\t\tc.allowOriginFunc = options.AllowOriginVaryRequestFunc\n\tcase options.AllowOriginRequestFunc != nil:\n\t\tc.allowOriginFunc = func(r *http.Request, origin string) (bool, []string) {\n\t\t\treturn options.AllowOriginRequestFunc(r, origin), nil\n\t\t}\n\tcase options.AllowOriginFunc != nil:\n\t\tc.allowOriginFunc = func(r *http.Request, origin string) (bool, []string) {\n\t\t\treturn options.AllowOriginFunc(origin), nil\n\t\t}\n\tcase len(options.AllowedOrigins) == 0:\n\t\tif c.allowOriginFunc == nil {\n\t\t\t// Default is all origins\n\t\t\tc.allowedOriginsAll = true\n\t\t}\n\tdefault:\n\t\tc.allowedOrigins = []string{}\n\t\tc.allowedWOrigins = []wildcard{}\n\t\tfor _, origin := range options.AllowedOrigins {\n\t\t\t// Note: for origins matching, the spec requires a case-sensitive matching.\n\t\t\t// As it may error prone, we chose to ignore the spec here.\n\t\t\torigin = strings.ToLower(origin)\n\t\t\tif origin == \"*\" {\n\t\t\t\t// If \"*\" is present in the list, turn the whole list into a match all\n\t\t\t\tc.allowedOriginsAll = true\n\t\t\t\tc.allowedOrigins = nil\n\t\t\t\tc.allowedWOrigins = nil\n\t\t\t\tbreak\n\t\t\t} else if i := strings.IndexByte(origin, '*'); i >= 0 {\n\t\t\t\t// Split the origin in two: start and end string without the *\n\t\t\t\tw := wildcard{origin[0:i], origin[i+1:]}\n\t\t\t\tc.allowedWOrigins = append(c.allowedWOrigins, w)\n\t\t\t} else {\n\t\t\t\tc.allowedOrigins = append(c.allowedOrigins, origin)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Allowed Headers\n\t// Note: the Fetch standard guarantees that CORS-unsafe request-header names\n\t// (i.e. the values listed in the Access-Control-Request-Headers header)\n\t// are lowercase; see https://fetch.spec.whatwg.org/#cors-unsafe-request-header-names.\n\tif len(options.AllowedHeaders) == 0 {\n\t\t// Use sensible defaults\n\t\tc.allowedHeaders = internal.NewSortedSet(\"accept\", \"content-type\", \"x-requested-with\")\n\t} else {\n\t\tnormalized := convert(options.AllowedHeaders, strings.ToLower)\n\t\tc.allowedHeaders = internal.NewSortedSet(normalized...)\n\t\tfor _, h := range options.AllowedHeaders {\n\t\t\tif h == \"*\" {\n\t\t\t\tc.allowedHeadersAll = true\n\t\t\t\tc.allowedHeaders = internal.SortedSet{}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Allowed Methods\n\tif len(options.AllowedMethods) == 0 {\n\t\t// Default is spec's \"simple\" methods\n\t\tc.allowedMethods = []string{http.MethodGet, http.MethodPost, http.MethodHead}\n\t} else {\n\t\tc.allowedMethods = options.AllowedMethods\n\t}\n\n\t// Options Success Status Code\n\tif options.OptionsSuccessStatus == 0 {\n\t\tc.optionsSuccessStatus = http.StatusNoContent\n\t} else {\n\t\tc.optionsSuccessStatus = options.OptionsSuccessStatus\n\t}\n\n\t// Pre-compute exposed headers header value\n\tif len(options.ExposedHeaders) > 0 {\n\t\tc.exposedHeaders = []string{strings.Join(convert(options.ExposedHeaders, http.CanonicalHeaderKey), \", \")}\n\t}\n\n\t// Pre-compute prefight Vary header to save allocations\n\tif c.allowPrivateNetwork {\n\t\tc.preflightVary = []string{\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers, Access-Control-Request-Private-Network\"}\n\t} else {\n\t\tc.preflightVary = []string{\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"}\n\t}\n\n\t// Precompute max-age\n\tif options.MaxAge > 0 {\n\t\tc.maxAge = []string{strconv.Itoa(options.MaxAge)}\n\t} else if options.MaxAge < 0 {\n\t\tc.maxAge = []string{\"0\"}\n\t}\n\n\treturn c\n}\n\n// Default creates a new Cors handler with default options.\nfunc Default() *Cors {\n\treturn New(Options{})\n}\n\n// AllowAll create a new Cors handler with permissive configuration allowing all\n// origins with all standard methods with any header and credentials.\nfunc AllowAll() *Cors {\n\treturn New(Options{\n\t\tAllowedOrigins: []string{\"*\"},\n\t\tAllowedMethods: []string{\n\t\t\thttp.MethodHead,\n\t\t\thttp.MethodGet,\n\t\t\thttp.MethodPost,\n\t\t\thttp.MethodPut,\n\t\t\thttp.MethodPatch,\n\t\t\thttp.MethodDelete,\n\t\t},\n\t\tAllowedHeaders:   []string{\"*\"},\n\t\tAllowCredentials: false,\n\t})\n}\n\n// Handler apply the CORS specification on the request, and add relevant CORS headers\n// as necessary.\nfunc (c *Cors) Handler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == http.MethodOptions && r.Header.Get(\"Access-Control-Request-Method\") != \"\" {\n\t\t\tc.logf(\"Handler: Preflight request\")\n\t\t\tc.handlePreflight(w, r)\n\t\t\t// Preflight requests are standalone and should stop the chain as some other\n\t\t\t// middleware may not handle OPTIONS requests correctly. One typical example\n\t\t\t// is authentication middleware ; OPTIONS requests won't carry authentication\n\t\t\t// headers (see #1)\n\t\t\tif c.optionPassthrough {\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t} else {\n\t\t\t\tw.WriteHeader(c.optionsSuccessStatus)\n\t\t\t}\n\t\t} else {\n\t\t\tc.logf(\"Handler: Actual request\")\n\t\t\tc.handleActualRequest(w, r)\n\t\t\th.ServeHTTP(w, r)\n\t\t}\n\t})\n}\n\n// HandlerFunc provides Martini compatible handler\nfunc (c *Cors) HandlerFunc(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodOptions && r.Header.Get(\"Access-Control-Request-Method\") != \"\" {\n\t\tc.logf(\"HandlerFunc: Preflight request\")\n\t\tc.handlePreflight(w, r)\n\n\t\tw.WriteHeader(c.optionsSuccessStatus)\n\t} else {\n\t\tc.logf(\"HandlerFunc: Actual request\")\n\t\tc.handleActualRequest(w, r)\n\t}\n}\n\n// Negroni compatible interface\nfunc (c *Cors) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\tif r.Method == http.MethodOptions && r.Header.Get(\"Access-Control-Request-Method\") != \"\" {\n\t\tc.logf(\"ServeHTTP: Preflight request\")\n\t\tc.handlePreflight(w, r)\n\t\t// Preflight requests are standalone and should stop the chain as some other\n\t\t// middleware may not handle OPTIONS requests correctly. One typical example\n\t\t// is authentication middleware ; OPTIONS requests won't carry authentication\n\t\t// headers (see #1)\n\t\tif c.optionPassthrough {\n\t\t\tnext(w, r)\n\t\t} else {\n\t\t\tw.WriteHeader(c.optionsSuccessStatus)\n\t\t}\n\t} else {\n\t\tc.logf(\"ServeHTTP: Actual request\")\n\t\tc.handleActualRequest(w, r)\n\t\tnext(w, r)\n\t}\n}\n\n// handlePreflight handles pre-flight CORS requests\nfunc (c *Cors) handlePreflight(w http.ResponseWriter, r *http.Request) {\n\theaders := w.Header()\n\torigin := r.Header.Get(\"Origin\")\n\n\tif r.Method != http.MethodOptions {\n\t\tc.logf(\"  Preflight aborted: %s!=OPTIONS\", r.Method)\n\t\treturn\n\t}\n\t// Always set Vary headers\n\t// see https://github.com/rs/cors/issues/10,\n\t//     https://github.com/rs/cors/commit/dbdca4d95feaa7511a46e6f1efb3b3aa505bc43f#commitcomment-12352001\n\tif vary, found := headers[\"Vary\"]; found {\n\t\theaders[\"Vary\"] = append(vary, c.preflightVary[0])\n\t} else {\n\t\theaders[\"Vary\"] = c.preflightVary\n\t}\n\tallowed, additionalVaryHeaders := c.isOriginAllowed(r, origin)\n\tif len(additionalVaryHeaders) > 0 {\n\t\theaders.Add(\"Vary\", strings.Join(convert(additionalVaryHeaders, http.CanonicalHeaderKey), \", \"))\n\t}\n\n\tif origin == \"\" {\n\t\tc.logf(\"  Preflight aborted: empty origin\")\n\t\treturn\n\t}\n\tif !allowed {\n\t\tc.logf(\"  Preflight aborted: origin '%s' not allowed\", origin)\n\t\treturn\n\t}\n\n\treqMethod := r.Header.Get(\"Access-Control-Request-Method\")\n\tif !c.isMethodAllowed(reqMethod) {\n\t\tc.logf(\"  Preflight aborted: method '%s' not allowed\", reqMethod)\n\t\treturn\n\t}\n\t// Note: the Fetch standard guarantees that at most one\n\t// Access-Control-Request-Headers header is present in the preflight request;\n\t// see step 5.2 in https://fetch.spec.whatwg.org/#cors-preflight-fetch-0.\n\t// However, some gateways split that header into multiple headers of the same name;\n\t// see https://github.com/rs/cors/issues/184.\n\treqHeaders, found := r.Header[\"Access-Control-Request-Headers\"]\n\tif found && !c.allowedHeadersAll && !c.allowedHeaders.Accepts(reqHeaders) {\n\t\tc.logf(\"  Preflight aborted: headers '%v' not allowed\", reqHeaders)\n\t\treturn\n\t}\n\tif c.allowedOriginsAll {\n\t\theaders[\"Access-Control-Allow-Origin\"] = headerOriginAll\n\t} else {\n\t\theaders[\"Access-Control-Allow-Origin\"] = r.Header[\"Origin\"]\n\t}\n\t// Spec says: Since the list of methods can be unbounded, simply returning the method indicated\n\t// by Access-Control-Request-Method (if supported) can be enough\n\theaders[\"Access-Control-Allow-Methods\"] = r.Header[\"Access-Control-Request-Method\"]\n\tif found && len(reqHeaders[0]) > 0 {\n\t\t// Spec says: Since the list of headers can be unbounded, simply returning supported headers\n\t\t// from Access-Control-Request-Headers can be enough\n\t\theaders[\"Access-Control-Allow-Headers\"] = reqHeaders\n\t}\n\tif c.allowCredentials {\n\t\theaders[\"Access-Control-Allow-Credentials\"] = headerTrue\n\t}\n\tif c.allowPrivateNetwork && r.Header.Get(\"Access-Control-Request-Private-Network\") == \"true\" {\n\t\theaders[\"Access-Control-Allow-Private-Network\"] = headerTrue\n\t}\n\tif len(c.maxAge) > 0 {\n\t\theaders[\"Access-Control-Max-Age\"] = c.maxAge\n\t}\n\tc.logf(\"  Preflight response headers: %v\", headers)\n}\n\n// handleActualRequest handles simple cross-origin requests, actual request or redirects\nfunc (c *Cors) handleActualRequest(w http.ResponseWriter, r *http.Request) {\n\theaders := w.Header()\n\torigin := r.Header.Get(\"Origin\")\n\n\tallowed, additionalVaryHeaders := c.isOriginAllowed(r, origin)\n\n\t// Always set Vary, see https://github.com/rs/cors/issues/10\n\tif vary := headers[\"Vary\"]; vary == nil {\n\t\theaders[\"Vary\"] = headerVaryOrigin\n\t} else {\n\t\theaders[\"Vary\"] = append(vary, headerVaryOrigin[0])\n\t}\n\tif len(additionalVaryHeaders) > 0 {\n\t\theaders.Add(\"Vary\", strings.Join(convert(additionalVaryHeaders, http.CanonicalHeaderKey), \", \"))\n\t}\n\tif origin == \"\" {\n\t\tc.logf(\"  Actual request no headers added: missing origin\")\n\t\treturn\n\t}\n\tif !allowed {\n\t\tc.logf(\"  Actual request no headers added: origin '%s' not allowed\", origin)\n\t\treturn\n\t}\n\n\t// Note that spec does define a way to specifically disallow a simple method like GET or\n\t// POST. Access-Control-Allow-Methods is only used for pre-flight requests and the\n\t// spec doesn't instruct to check the allowed methods for simple cross-origin requests.\n\t// We think it's a nice feature to be able to have control on those methods though.\n\tif !c.isMethodAllowed(r.Method) {\n\t\tc.logf(\"  Actual request no headers added: method '%s' not allowed\", r.Method)\n\t\treturn\n\t}\n\tif c.allowedOriginsAll {\n\t\theaders[\"Access-Control-Allow-Origin\"] = headerOriginAll\n\t} else {\n\t\theaders[\"Access-Control-Allow-Origin\"] = r.Header[\"Origin\"]\n\t}\n\tif len(c.exposedHeaders) > 0 {\n\t\theaders[\"Access-Control-Expose-Headers\"] = c.exposedHeaders\n\t}\n\tif c.allowCredentials {\n\t\theaders[\"Access-Control-Allow-Credentials\"] = headerTrue\n\t}\n\tc.logf(\"  Actual response added headers: %v\", headers)\n}\n\n// convenience method. checks if a logger is set.\nfunc (c *Cors) logf(format string, a ...interface{}) {\n\tif c.Log != nil {\n\t\tc.Log.Printf(format, a...)\n\t}\n}\n\n// check the Origin of a request. No origin at all is also allowed.\nfunc (c *Cors) OriginAllowed(r *http.Request) bool {\n\torigin := r.Header.Get(\"Origin\")\n\tallowed, _ := c.isOriginAllowed(r, origin)\n\treturn allowed\n}\n\n// isOriginAllowed checks if a given origin is allowed to perform cross-domain requests\n// on the endpoint\nfunc (c *Cors) isOriginAllowed(r *http.Request, origin string) (allowed bool, varyHeaders []string) {\n\tif c.allowOriginFunc != nil {\n\t\treturn c.allowOriginFunc(r, origin)\n\t}\n\tif c.allowedOriginsAll {\n\t\treturn true, nil\n\t}\n\torigin = strings.ToLower(origin)\n\tfor _, o := range c.allowedOrigins {\n\t\tif o == origin {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\tfor _, w := range c.allowedWOrigins {\n\t\tif w.match(origin) {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// isMethodAllowed checks if a given method can be used as part of a cross-domain request\n// on the endpoint\nfunc (c *Cors) isMethodAllowed(method string) bool {\n\tif len(c.allowedMethods) == 0 {\n\t\t// If no method allowed, always return false, even for preflight request\n\t\treturn false\n\t}\n\tif method == http.MethodOptions {\n\t\t// Always allow preflight requests\n\t\treturn true\n\t}\n\tfor _, m := range c.allowedMethods {\n\t\tif m == method {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "cors_test.go",
          "type": "blob",
          "size": 21.5947265625,
          "content": "package cors\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"regexp\"\n\t\"slices\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar testResponse = []byte(\"bar\")\nvar testHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t_, _ = w.Write(testResponse)\n})\n\n// For each key-value pair of this map, the value indicates whether the key\n// is a list-based field (i.e. not a singleton field);\n// see https://httpwg.org/specs/rfc9110.html#abnf.extension.\nvar allRespHeaders = map[string]bool{\n\t// see https://www.rfc-editor.org/rfc/rfc9110#section-12.5.5\n\t\"Vary\": true,\n\t// see https://fetch.spec.whatwg.org/#http-new-header-syntax\n\t\"Access-Control-Allow-Origin\":      false,\n\t\"Access-Control-Allow-Credentials\": false,\n\t\"Access-Control-Allow-Methods\":     true,\n\t\"Access-Control-Allow-Headers\":     true,\n\t\"Access-Control-Max-Age\":           false,\n\t\"Access-Control-Expose-Headers\":    true,\n\t// see https://wicg.github.io/private-network-access/\n\t\"Access-Control-Allow-Private-Network\": false,\n}\n\nfunc assertHeaders(t *testing.T, resHeaders http.Header, expHeaders http.Header) {\n\tt.Helper()\n\tfor name, listBased := range allRespHeaders {\n\t\tgot := resHeaders[name]\n\t\twant := expHeaders[name]\n\t\tif !listBased && !slices.Equal(got, want) {\n\t\t\tt.Errorf(\"Response header %q = %q, want %q\", name, got, want)\n\t\t\tcontinue\n\t\t}\n\t\tif listBased && !slices.Equal(normalize(got), normalize(want)) {\n\t\t\tt.Errorf(\"Response header %q = %q, want %q\", name, got, want)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\n// normalize normalizes a list-based field value,\n// preserving both empty elements and the order of elements.\nfunc normalize(s []string) (res []string) {\n\tfor _, v := range s {\n\t\tfor _, e := range strings.Split(v, \",\") {\n\t\t\te = strings.Trim(e, \" \\t\")\n\t\t\tres = append(res, e)\n\t\t}\n\t}\n\treturn\n}\n\nfunc assertResponse(t *testing.T, res *httptest.ResponseRecorder, responseCode int) {\n\tt.Helper()\n\tif responseCode != res.Code {\n\t\tt.Errorf(\"assertResponse: expected response code to be %d but got %d. \", responseCode, res.Code)\n\t}\n}\n\nfunc TestSpec(t *testing.T) {\n\tcases := []struct {\n\t\tname          string\n\t\toptions       Options\n\t\tmethod        string\n\t\treqHeaders    http.Header\n\t\tresHeaders    http.Header\n\t\toriginAllowed bool\n\t}{\n\t\t{\n\t\t\t\"NoConfig\",\n\t\t\tOptions{\n\t\t\t\t// Intentionally left blank.\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\": {\"Origin\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"MatchAllOrigin\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"*\"},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                        {\"Origin\"},\n\t\t\t\t\"Access-Control-Allow-Origin\": {\"*\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"MatchAllOriginWithCredentials\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins:   []string{\"*\"},\n\t\t\t\tAllowCredentials: true,\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                             {\"Origin\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":      {\"*\"},\n\t\t\t\t\"Access-Control-Allow-Credentials\": {\"true\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"AllowedOrigin\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                        {\"Origin\"},\n\t\t\t\t\"Access-Control-Allow-Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"WildcardOrigin\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://*.bar.com\"},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://foo.bar.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                        {\"Origin\"},\n\t\t\t\t\"Access-Control-Allow-Origin\": {\"http://foo.bar.com\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"DisallowedOrigin\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://barbaz.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\": {\"Origin\"},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"DisallowedWildcardOrigin\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://*.bar.com\"},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://foo.baz.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\": {\"Origin\"},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"AllowedOriginFuncMatch\",\n\t\t\tOptions{\n\t\t\t\tAllowOriginFunc: func(o string) bool {\n\t\t\t\t\treturn regexp.MustCompile(\"^http://foo\").MatchString(o)\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                        {\"Origin\"},\n\t\t\t\t\"Access-Control-Allow-Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"AllowOriginRequestFuncMatch\",\n\t\t\tOptions{\n\t\t\t\tAllowOriginRequestFunc: func(r *http.Request, o string) bool {\n\t\t\t\t\treturn regexp.MustCompile(\"^http://foo\").MatchString(o) && r.Header.Get(\"Authorization\") == \"secret\"\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":        {\"http://foobar.com\"},\n\t\t\t\t\"Authorization\": {\"secret\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                        {\"Origin\"},\n\t\t\t\t\"Access-Control-Allow-Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"AllowOriginVaryRequestFuncMatch\",\n\t\t\tOptions{\n\t\t\t\tAllowOriginVaryRequestFunc: func(r *http.Request, o string) (bool, []string) {\n\t\t\t\t\treturn regexp.MustCompile(\"^http://foo\").MatchString(o) && r.Header.Get(\"Authorization\") == \"secret\", []string{\"Authorization\"}\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":        {\"http://foobar.com\"},\n\t\t\t\t\"Authorization\": {\"secret\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                        {\"Origin, Authorization\"},\n\t\t\t\t\"Access-Control-Allow-Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"AllowOriginRequestFuncNotMatch\",\n\t\t\tOptions{\n\t\t\t\tAllowOriginRequestFunc: func(r *http.Request, o string) bool {\n\t\t\t\t\treturn regexp.MustCompile(\"^http://foo\").MatchString(o) && r.Header.Get(\"Authorization\") == \"secret\"\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":        {\"http://foobar.com\"},\n\t\t\t\t\"Authorization\": {\"not-secret\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\": {\"Origin\"},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"MaxAge\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://example.com\"},\n\t\t\t\tAllowedMethods: []string{\"GET\"},\n\t\t\t\tMaxAge:         10,\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                        {\"http://example.com\"},\n\t\t\t\t\"Access-Control-Request-Method\": {\"GET\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"http://example.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"GET\"},\n\t\t\t\t\"Access-Control-Max-Age\":       {\"10\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"MaxAgeNegative\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://example.com\"},\n\t\t\t\tAllowedMethods: []string{\"GET\"},\n\t\t\t\tMaxAge:         -1,\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                        {\"http://example.com\"},\n\t\t\t\t\"Access-Control-Request-Method\": {\"GET\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"http://example.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"GET\"},\n\t\t\t\t\"Access-Control-Max-Age\":       {\"0\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"AllowedMethod\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t\tAllowedMethods: []string{\"PUT\", \"DELETE\"},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                        {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\": {\"PUT\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"PUT\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"DisallowedMethod\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t\tAllowedMethods: []string{\"PUT\", \"DELETE\"},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                        {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\": {\"PATCH\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\": {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"AllowedHeaders\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t\tAllowedHeaders: []string{\"X-Header-1\", \"x-header-2\", \"X-HEADER-3\"},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                         {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\":  {\"GET\"},\n\t\t\t\t\"Access-Control-Request-Headers\": {\"x-header-1,x-header-2\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"GET\"},\n\t\t\t\t\"Access-Control-Allow-Headers\": {\"x-header-1,x-header-2\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"DefaultAllowedHeaders\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t\tAllowedHeaders: []string{},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                         {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\":  {\"GET\"},\n\t\t\t\t\"Access-Control-Request-Headers\": {\"x-requested-with\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"GET\"},\n\t\t\t\t\"Access-Control-Allow-Headers\": {\"x-requested-with\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"AllowedWildcardHeader\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t\tAllowedHeaders: []string{\"*\"},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                         {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\":  {\"GET\"},\n\t\t\t\t\"Access-Control-Request-Headers\": {\"x-header-1,x-header-2\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"GET\"},\n\t\t\t\t\"Access-Control-Allow-Headers\": {\"x-header-1,x-header-2\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"DisallowedHeader\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t\tAllowedHeaders: []string{\"X-Header-1\", \"x-header-2\"},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                         {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\":  {\"GET\"},\n\t\t\t\t\"Access-Control-Request-Headers\": {\"x-header-1,x-header-3\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\": {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"ExposedHeader\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t\tExposedHeaders: []string{\"X-Header-1\", \"x-header-2\"},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                          {\"Origin\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":   {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Expose-Headers\": {\"X-Header-1, X-Header-2\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"AllowedCredentials\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins:   []string{\"http://foobar.com\"},\n\t\t\t\tAllowCredentials: true,\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                        {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\": {\"GET\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                             {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":      {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\":     {\"GET\"},\n\t\t\t\t\"Access-Control-Allow-Credentials\": {\"true\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"AllowedPrivateNetwork\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins:      []string{\"http://foobar.com\"},\n\t\t\t\tAllowPrivateNetwork: true,\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                                 {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\":          {\"GET\"},\n\t\t\t\t\"Access-Control-Request-Private-Network\": {\"true\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                                 {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers, Access-Control-Request-Private-Network\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":          {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\":         {\"GET\"},\n\t\t\t\t\"Access-Control-Allow-Private-Network\": {\"true\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"DisallowedPrivateNetwork\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                                {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\":         {\"GET\"},\n\t\t\t\t\"Access-Control-Request-PrivateNetwork\": {\"true\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"GET\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"OptionPassthrough\",\n\t\t\tOptions{\n\t\t\t\tOptionsPassthrough: true,\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                        {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\": {\"GET\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"*\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"GET\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"NonPreflightOptions\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                        {\"Origin\"},\n\t\t\t\t\"Access-Control-Allow-Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t}, {\n\t\t\t\"AllowedOriginsPlusAllowOriginFunc\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"*\"},\n\t\t\t\tAllowOriginFunc: func(origin string) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"GET\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                        {\"Origin\"},\n\t\t\t\t\"Access-Control-Allow-Origin\": {\"http://foobar.com\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"MultipleACRHHeaders\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t\tAllowedHeaders: []string{\"Content-Type\", \"Authorization\"},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                         {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\":  {\"GET\"},\n\t\t\t\t\"Access-Control-Request-Headers\": {\"authorization\", \"content-type\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"GET\"},\n\t\t\t\t\"Access-Control-Allow-Headers\": {\"authorization\", \"content-type\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"MultipleACRHHeadersWithOWSAndEmptyElements\",\n\t\t\tOptions{\n\t\t\t\tAllowedOrigins: []string{\"http://foobar.com\"},\n\t\t\t\tAllowedHeaders: []string{\"Content-Type\", \"Authorization\"},\n\t\t\t},\n\t\t\t\"OPTIONS\",\n\t\t\thttp.Header{\n\t\t\t\t\"Origin\":                         {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Request-Method\":  {\"GET\"},\n\t\t\t\t\"Access-Control-Request-Headers\": {\"authorization\\t\", \" \", \" content-type\"},\n\t\t\t},\n\t\t\thttp.Header{\n\t\t\t\t\"Vary\":                         {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t\t\t\t\"Access-Control-Allow-Origin\":  {\"http://foobar.com\"},\n\t\t\t\t\"Access-Control-Allow-Methods\": {\"GET\"},\n\t\t\t\t\"Access-Control-Allow-Headers\": {\"authorization\\t\", \" \", \" content-type\"},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t}\n\tfor i := range cases {\n\t\ttc := cases[i]\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ts := New(tc.options)\n\n\t\t\treq, _ := http.NewRequest(tc.method, \"http://example.com/foo\", nil)\n\t\t\tfor name, values := range tc.reqHeaders {\n\t\t\t\tfor _, value := range values {\n\t\t\t\t\treq.Header.Add(name, value)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt.Run(\"OriginAllowed\", func(t *testing.T) {\n\t\t\t\tif have, want := s.OriginAllowed(req), tc.originAllowed; have != want {\n\t\t\t\t\tt.Errorf(\"OriginAllowed have: %t want: %t\", have, want)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"Handler\", func(t *testing.T) {\n\t\t\t\tres := httptest.NewRecorder()\n\t\t\t\ts.Handler(testHandler).ServeHTTP(res, req)\n\t\t\t\tassertHeaders(t, res.Header(), tc.resHeaders)\n\t\t\t})\n\t\t\tt.Run(\"HandlerFunc\", func(t *testing.T) {\n\t\t\t\tres := httptest.NewRecorder()\n\t\t\t\ts.HandlerFunc(res, req)\n\t\t\t\tassertHeaders(t, res.Header(), tc.resHeaders)\n\t\t\t})\n\t\t\tt.Run(\"Negroni\", func(t *testing.T) {\n\t\t\t\tres := httptest.NewRecorder()\n\t\t\t\ts.ServeHTTP(res, req, testHandler)\n\t\t\t\tassertHeaders(t, res.Header(), tc.resHeaders)\n\t\t\t})\n\n\t\t})\n\t}\n}\n\nfunc TestDebug(t *testing.T) {\n\ts := New(Options{\n\t\tDebug: true,\n\t})\n\n\tif s.Log == nil {\n\t\tt.Error(\"Logger not created when debug=true\")\n\t}\n}\n\ntype testLogger struct {\n\tbuf *bytes.Buffer\n}\n\nfunc (l *testLogger) Printf(format string, v ...interface{}) {\n\tfmt.Fprintf(l.buf, format, v...)\n}\n\nfunc TestLogger(t *testing.T) {\n\tlogger := &testLogger{buf: &bytes.Buffer{}}\n\ts := New(Options{\n\t\tLogger: logger,\n\t})\n\n\tif s.Log == nil {\n\t\tt.Error(\"Logger not created when Logger is set\")\n\t}\n\ts.logf(\"test\")\n\tif logger.buf.String() != \"test\" {\n\t\tt.Error(\"Logger not used\")\n\t}\n}\n\nfunc TestDefault(t *testing.T) {\n\ts := Default()\n\tif s.Log != nil {\n\t\tt.Error(\"c.log should be nil when Default\")\n\t}\n\tif !s.allowedOriginsAll {\n\t\tt.Error(\"c.allowedOriginsAll should be true when Default\")\n\t}\n\tif s.allowedHeaders.Size() == 0 {\n\t\tt.Error(\"c.allowedHeaders should be empty when Default\")\n\t}\n\tif s.allowedMethods == nil {\n\t\tt.Error(\"c.allowedMethods should be nil when Default\")\n\t}\n}\n\nfunc TestHandlePreflightInvalidOriginAbortion(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedOrigins: []string{\"http://foo.com\"},\n\t})\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"OPTIONS\", \"http://example.com/foo\", nil)\n\treq.Header.Add(\"Origin\", \"http://example.com\")\n\n\ts.handlePreflight(res, req)\n\n\tassertHeaders(t, res.Header(), http.Header{\n\t\t\"Vary\": {\"Origin, Access-Control-Request-Method, Access-Control-Request-Headers\"},\n\t})\n}\n\nfunc TestHandlePreflightNoOptionsAbortion(t *testing.T) {\n\ts := New(Options{\n\t\t// Intentionally left blank.\n\t})\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"http://example.com/foo\", nil)\n\n\ts.handlePreflight(res, req)\n\n\tassertHeaders(t, res.Header(), http.Header{})\n}\n\nfunc TestHandleActualRequestInvalidOriginAbortion(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedOrigins: []string{\"http://foo.com\"},\n\t})\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"http://example.com/foo\", nil)\n\treq.Header.Add(\"Origin\", \"http://example.com\")\n\n\ts.handleActualRequest(res, req)\n\n\tassertHeaders(t, res.Header(), http.Header{\n\t\t\"Vary\": {\"Origin\"},\n\t})\n}\n\nfunc TestHandleActualRequestInvalidMethodAbortion(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedMethods:   []string{\"POST\"},\n\t\tAllowCredentials: true,\n\t})\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"http://example.com/foo\", nil)\n\treq.Header.Add(\"Origin\", \"http://example.com\")\n\n\ts.handleActualRequest(res, req)\n\n\tassertHeaders(t, res.Header(), http.Header{\n\t\t\"Vary\": {\"Origin\"},\n\t})\n}\n\nfunc TestIsMethodAllowedReturnsFalseWithNoMethods(t *testing.T) {\n\ts := New(Options{\n\t\t// Intentionally left blank.\n\t})\n\ts.allowedMethods = []string{}\n\tif s.isMethodAllowed(\"\") {\n\t\tt.Error(\"IsMethodAllowed should return false when c.allowedMethods is nil.\")\n\t}\n}\n\nfunc TestIsMethodAllowedReturnsTrueWithOptions(t *testing.T) {\n\ts := New(Options{\n\t\t// Intentionally left blank.\n\t})\n\tif !s.isMethodAllowed(\"OPTIONS\") {\n\t\tt.Error(\"IsMethodAllowed should return true when c.allowedMethods is nil.\")\n\t}\n}\n\nfunc TestOptionsSuccessStatusCodeDefault(t *testing.T) {\n\ts := New(Options{\n\t\t// Intentionally left blank.\n\t})\n\n\treq, _ := http.NewRequest(\"OPTIONS\", \"http://example.com/foo\", nil)\n\treq.Header.Add(\"Access-Control-Request-Method\", \"GET\")\n\n\tt.Run(\"Handler\", func(t *testing.T) {\n\t\tres := httptest.NewRecorder()\n\t\ts.Handler(testHandler).ServeHTTP(res, req)\n\t\tassertResponse(t, res, http.StatusNoContent)\n\t})\n\tt.Run(\"HandlerFunc\", func(t *testing.T) {\n\t\tres := httptest.NewRecorder()\n\t\ts.HandlerFunc(res, req)\n\t\tassertResponse(t, res, http.StatusNoContent)\n\t})\n\tt.Run(\"Negroni\", func(t *testing.T) {\n\t\tres := httptest.NewRecorder()\n\t\ts.ServeHTTP(res, req, testHandler)\n\t\tassertResponse(t, res, http.StatusNoContent)\n\t})\n}\n\nfunc TestOptionsSuccessStatusCodeOverride(t *testing.T) {\n\ts := New(Options{\n\t\tOptionsSuccessStatus: http.StatusOK,\n\t})\n\n\treq, _ := http.NewRequest(\"OPTIONS\", \"http://example.com/foo\", nil)\n\treq.Header.Add(\"Access-Control-Request-Method\", \"GET\")\n\n\tt.Run(\"Handler\", func(t *testing.T) {\n\t\tres := httptest.NewRecorder()\n\t\ts.Handler(testHandler).ServeHTTP(res, req)\n\t\tassertResponse(t, res, http.StatusOK)\n\t})\n\tt.Run(\"HandlerFunc\", func(t *testing.T) {\n\t\tres := httptest.NewRecorder()\n\t\ts.HandlerFunc(res, req)\n\t\tassertResponse(t, res, http.StatusOK)\n\t})\n\tt.Run(\"Negroni\", func(t *testing.T) {\n\t\tres := httptest.NewRecorder()\n\t\ts.ServeHTTP(res, req, testHandler)\n\t\tassertResponse(t, res, http.StatusOK)\n\t})\n}\n\nfunc TestAccessControlExposeHeadersPresence(t *testing.T) {\n\tcases := []struct {\n\t\tname    string\n\t\toptions Options\n\t\twant    bool\n\t}{\n\t\t{\n\t\t\tname:    \"omit\",\n\t\t\toptions: Options{},\n\t\t\twant:    false,\n\t\t},\n\t\t{\n\t\t\tname: \"include\",\n\t\t\toptions: Options{\n\t\t\t\tExposedHeaders: []string{\"X-Something\"},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\n\tfor _, tt := range cases {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ts := New(tt.options)\n\n\t\t\treq, _ := http.NewRequest(\"GET\", \"http://example.com/foo\", nil)\n\t\t\treq.Header.Add(\"Origin\", \"http://foobar.com\")\n\n\t\t\tassertExposeHeaders := func(t *testing.T, resHeaders http.Header) {\n\t\t\t\tif _, have := resHeaders[\"Access-Control-Expose-Headers\"]; have != tt.want {\n\t\t\t\t\tt.Errorf(\"Access-Control-Expose-Headers have: %t want: %t\", have, tt.want)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt.Run(\"Handler\", func(t *testing.T) {\n\t\t\t\tres := httptest.NewRecorder()\n\t\t\t\ts.Handler(testHandler).ServeHTTP(res, req)\n\t\t\t\tassertExposeHeaders(t, res.Header())\n\t\t\t})\n\t\t\tt.Run(\"HandlerFunc\", func(t *testing.T) {\n\t\t\t\tres := httptest.NewRecorder()\n\t\t\t\ts.HandlerFunc(res, req)\n\t\t\t\tassertExposeHeaders(t, res.Header())\n\t\t\t})\n\t\t\tt.Run(\"Negroni\", func(t *testing.T) {\n\t\t\t\tres := httptest.NewRecorder()\n\t\t\t\ts.ServeHTTP(res, req, testHandler)\n\t\t\t\tassertExposeHeaders(t, res.Header())\n\t\t\t})\n\t\t})\n\t}\n\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0361328125,
          "content": "module github.com/rs/cors\n\ngo 1.23.0\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 0.462890625,
          "content": "package cors\n\nimport (\n\t\"strings\"\n)\n\ntype wildcard struct {\n\tprefix string\n\tsuffix string\n}\n\nfunc (w wildcard) match(s string) bool {\n\treturn len(s) >= len(w.prefix)+len(w.suffix) &&\n\t\tstrings.HasPrefix(s, w.prefix) &&\n\t\tstrings.HasSuffix(s, w.suffix)\n}\n\n// convert converts a list of string using the passed converter function\nfunc convert(s []string, f func(string) string) []string {\n\tout := make([]string, len(s))\n\tfor i := range s {\n\t\tout[i] = f(s[i])\n\t}\n\treturn out\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 0.9140625,
          "content": "package cors\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestWildcard(t *testing.T) {\n\tw := wildcard{\"foo\", \"bar\"}\n\tif !w.match(\"foobar\") {\n\t\tt.Error(\"foo*bar should match foobar\")\n\t}\n\tif !w.match(\"foobazbar\") {\n\t\tt.Error(\"foo*bar should match foobazbar\")\n\t}\n\tif w.match(\"foobaz\") {\n\t\tt.Error(\"foo*bar should not match foobaz\")\n\t}\n\n\tw = wildcard{\"foo\", \"oof\"}\n\tif w.match(\"foof\") {\n\t\tt.Error(\"foo*oof should not match foof\")\n\t}\n}\n\nfunc TestConvert(t *testing.T) {\n\ts := convert([]string{\"A\", \"b\", \"C\"}, strings.ToLower)\n\te := []string{\"a\", \"b\", \"c\"}\n\tif s[0] != e[0] || s[1] != e[1] || s[2] != e[2] {\n\t\tt.Errorf(\"%v != %v\", s, e)\n\t}\n}\n\nfunc BenchmarkWildcard(b *testing.B) {\n\tw := wildcard{\"foo\", \"bar\"}\n\tb.Run(\"match\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tw.match(\"foobazbar\")\n\t\t}\n\t})\n\tb.Run(\"too short\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tw.match(\"fobar\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "wrapper",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}