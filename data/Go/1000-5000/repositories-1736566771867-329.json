{
  "metadata": {
    "timestamp": 1736566771867,
    "page": 329,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "spf13/cast",
      "stars": 3588,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.26171875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n\n*.bench\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Steve Francia\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.091796875,
          "content": "GOVERSION := $(shell go version | cut -d ' ' -f 3 | cut -d '.' -f 2)\n\n.PHONY: check fmt lint test test-race vet test-cover-html help\n.DEFAULT_GOAL := help\n\ncheck: test-race fmt vet lint ## Run tests and linters\n\ntest: ## Run tests\n\tgo test ./...\n\ntest-race: ## Run tests with race detector\n\tgo test -race ./...\n\nfmt: ## Run gofmt linter\nifeq \"$(GOVERSION)\" \"12\"\n\t@for d in `go list` ; do \\\n\t\tif [ \"`gofmt -l -s $$GOPATH/src/$$d | tee /dev/stderr`\" ]; then \\\n\t\t\techo \"^ improperly formatted go files\" && echo && exit 1; \\\n\t\tfi \\\n\tdone\nendif\n\nlint: ## Run golint linter\n\t@for d in `go list` ; do \\\n\t\tif [ \"`golint $$d | tee /dev/stderr`\" ]; then \\\n\t\t\techo \"^ golint errors!\" && echo && exit 1; \\\n\t\tfi \\\n\tdone\n\nvet: ## Run go vet linter\n\t@if [ \"`go vet | tee /dev/stderr`\" ]; then \\\n\t\techo \"^ go vet errors!\" && echo && exit 1; \\\n\tfi\n\ntest-cover-html: ## Generate test coverage report\n\tgo test -coverprofile=coverage.out -covermode=count\n\tgo tool cover -func=coverage.out\n\nhelp:\n\t@grep -E '^[a-zA-Z0-9_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}'\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.0498046875,
          "content": "# cast\n\n[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/spf13/cast/test.yaml?branch=master&style=flat-square)](https://github.com/spf13/cast/actions/workflows/test.yaml)\n[![PkgGoDev](https://pkg.go.dev/badge/mod/github.com/spf13/cast)](https://pkg.go.dev/mod/github.com/spf13/cast)\n![Go Version](https://img.shields.io/badge/go%20version-%3E=1.16-61CFDD.svg?style=flat-square)\n[![Go Report Card](https://goreportcard.com/badge/github.com/spf13/cast?style=flat-square)](https://goreportcard.com/report/github.com/spf13/cast)\n\nEasy and safe casting from one type to another in Go\n\nDon’t Panic! ... Cast\n\n## What is Cast?\n\nCast is a library to convert between different go types in a consistent and easy way.\n\nCast provides simple functions to easily convert a number to a string, an\ninterface into a bool, etc. Cast does this intelligently when an obvious\nconversion is possible. It doesn’t make any attempts to guess what you meant,\nfor example you can only convert a string to an int when it is a string\nrepresentation of an int such as “8”. Cast was developed for use in\n[Hugo](https://gohugo.io), a website engine which uses YAML, TOML or JSON\nfor meta data.\n\n## Why use Cast?\n\nWhen working with dynamic data in Go you often need to cast or convert the data\nfrom one type into another. Cast goes beyond just using type assertion (though\nit uses that when possible) to provide a very straightforward and convenient\nlibrary.\n\nIf you are working with interfaces to handle things like dynamic content\nyou’ll need an easy way to convert an interface into a given type. This\nis the library for you.\n\nIf you are taking in data from YAML, TOML or JSON or other formats which lack\nfull types, then Cast is the library for you.\n\n## Usage\n\nCast provides a handful of To_____ methods. These methods will always return\nthe desired type. **If input is provided that will not convert to that type, the\n0 or nil value for that type will be returned**.\n\nCast also provides identical methods To_____E. These return the same result as\nthe To_____ methods, plus an additional error which tells you if it successfully\nconverted. Using these methods you can tell the difference between when the\ninput matched the zero value or when the conversion failed and the zero value\nwas returned.\n\nThe following examples are merely a sample of what is available. Please review\nthe code for a complete set.\n\n### Example ‘ToString’:\n\n    cast.ToString(\"mayonegg\")         // \"mayonegg\"\n    cast.ToString(8)                  // \"8\"\n    cast.ToString(8.31)               // \"8.31\"\n    cast.ToString([]byte(\"one time\")) // \"one time\"\n    cast.ToString(nil)                // \"\"\n\n\tvar foo interface{} = \"one more time\"\n    cast.ToString(foo)                // \"one more time\"\n\n\n### Example ‘ToInt’:\n\n    cast.ToInt(8)                  // 8\n    cast.ToInt(8.31)               // 8\n    cast.ToInt(\"8\")                // 8\n    cast.ToInt(true)               // 1\n    cast.ToInt(false)              // 0\n\n\tvar eight interface{} = 8\n    cast.ToInt(eight)              // 8\n    cast.ToInt(nil)                // 0\n"
        },
        {
          "name": "cast.go",
          "type": "blob",
          "size": 3.9111328125,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n// Package cast provides easy and safe casting in Go.\npackage cast\n\nimport \"time\"\n\n// ToBool casts an interface to a bool type.\nfunc ToBool(i interface{}) bool {\n\tv, _ := ToBoolE(i)\n\treturn v\n}\n\n// ToTime casts an interface to a time.Time type.\nfunc ToTime(i interface{}) time.Time {\n\tv, _ := ToTimeE(i)\n\treturn v\n}\n\nfunc ToTimeInDefaultLocation(i interface{}, location *time.Location) time.Time {\n\tv, _ := ToTimeInDefaultLocationE(i, location)\n\treturn v\n}\n\n// ToDuration casts an interface to a time.Duration type.\nfunc ToDuration(i interface{}) time.Duration {\n\tv, _ := ToDurationE(i)\n\treturn v\n}\n\n// ToFloat64 casts an interface to a float64 type.\nfunc ToFloat64(i interface{}) float64 {\n\tv, _ := ToFloat64E(i)\n\treturn v\n}\n\n// ToFloat32 casts an interface to a float32 type.\nfunc ToFloat32(i interface{}) float32 {\n\tv, _ := ToFloat32E(i)\n\treturn v\n}\n\n// ToInt64 casts an interface to an int64 type.\nfunc ToInt64(i interface{}) int64 {\n\tv, _ := ToInt64E(i)\n\treturn v\n}\n\n// ToInt32 casts an interface to an int32 type.\nfunc ToInt32(i interface{}) int32 {\n\tv, _ := ToInt32E(i)\n\treturn v\n}\n\n// ToInt16 casts an interface to an int16 type.\nfunc ToInt16(i interface{}) int16 {\n\tv, _ := ToInt16E(i)\n\treturn v\n}\n\n// ToInt8 casts an interface to an int8 type.\nfunc ToInt8(i interface{}) int8 {\n\tv, _ := ToInt8E(i)\n\treturn v\n}\n\n// ToInt casts an interface to an int type.\nfunc ToInt(i interface{}) int {\n\tv, _ := ToIntE(i)\n\treturn v\n}\n\n// ToUint casts an interface to a uint type.\nfunc ToUint(i interface{}) uint {\n\tv, _ := ToUintE(i)\n\treturn v\n}\n\n// ToUint64 casts an interface to a uint64 type.\nfunc ToUint64(i interface{}) uint64 {\n\tv, _ := ToUint64E(i)\n\treturn v\n}\n\n// ToUint32 casts an interface to a uint32 type.\nfunc ToUint32(i interface{}) uint32 {\n\tv, _ := ToUint32E(i)\n\treturn v\n}\n\n// ToUint16 casts an interface to a uint16 type.\nfunc ToUint16(i interface{}) uint16 {\n\tv, _ := ToUint16E(i)\n\treturn v\n}\n\n// ToUint8 casts an interface to a uint8 type.\nfunc ToUint8(i interface{}) uint8 {\n\tv, _ := ToUint8E(i)\n\treturn v\n}\n\n// ToString casts an interface to a string type.\nfunc ToString(i interface{}) string {\n\tv, _ := ToStringE(i)\n\treturn v\n}\n\n// ToStringMapString casts an interface to a map[string]string type.\nfunc ToStringMapString(i interface{}) map[string]string {\n\tv, _ := ToStringMapStringE(i)\n\treturn v\n}\n\n// ToStringMapStringSlice casts an interface to a map[string][]string type.\nfunc ToStringMapStringSlice(i interface{}) map[string][]string {\n\tv, _ := ToStringMapStringSliceE(i)\n\treturn v\n}\n\n// ToStringMapBool casts an interface to a map[string]bool type.\nfunc ToStringMapBool(i interface{}) map[string]bool {\n\tv, _ := ToStringMapBoolE(i)\n\treturn v\n}\n\n// ToStringMapInt casts an interface to a map[string]int type.\nfunc ToStringMapInt(i interface{}) map[string]int {\n\tv, _ := ToStringMapIntE(i)\n\treturn v\n}\n\n// ToStringMapInt64 casts an interface to a map[string]int64 type.\nfunc ToStringMapInt64(i interface{}) map[string]int64 {\n\tv, _ := ToStringMapInt64E(i)\n\treturn v\n}\n\n// ToStringMap casts an interface to a map[string]interface{} type.\nfunc ToStringMap(i interface{}) map[string]interface{} {\n\tv, _ := ToStringMapE(i)\n\treturn v\n}\n\n// ToSlice casts an interface to a []interface{} type.\nfunc ToSlice(i interface{}) []interface{} {\n\tv, _ := ToSliceE(i)\n\treturn v\n}\n\n// ToBoolSlice casts an interface to a []bool type.\nfunc ToBoolSlice(i interface{}) []bool {\n\tv, _ := ToBoolSliceE(i)\n\treturn v\n}\n\n// ToStringSlice casts an interface to a []string type.\nfunc ToStringSlice(i interface{}) []string {\n\tv, _ := ToStringSliceE(i)\n\treturn v\n}\n\n// ToIntSlice casts an interface to a []int type.\nfunc ToIntSlice(i interface{}) []int {\n\tv, _ := ToIntSliceE(i)\n\treturn v\n}\n\n// ToDurationSlice casts an interface to a []time.Duration type.\nfunc ToDurationSlice(i interface{}) []time.Duration {\n\tv, _ := ToDurationSliceE(i)\n\treturn v\n}\n"
        },
        {
          "name": "cast_test.go",
          "type": "blob",
          "size": 36.3681640625,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage cast\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"path\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\ntype testStep struct {\n\tinput  interface{}\n\texpect interface{}\n\tiserr  bool\n}\n\nfunc createNumberTestSteps(zero, one, eight, eightnegative, eightpoint31, eightpoint31negative interface{}) []testStep {\n\tvar jeight, jminuseight, jfloateight json.Number\n\t_ = json.Unmarshal([]byte(\"8\"), &jeight)\n\t_ = json.Unmarshal([]byte(\"-8\"), &jminuseight)\n\t_ = json.Unmarshal([]byte(\"8.0\"), &jfloateight)\n\n\tkind := reflect.TypeOf(zero).Kind()\n\tisUint := kind == reflect.Uint || kind == reflect.Uint8 || kind == reflect.Uint16 || kind == reflect.Uint32 || kind == reflect.Uint64\n\n\t// Some precision is lost when converting from float64 to float32.\n\teightpoint31_32 := eightpoint31\n\teightpoint31negative_32 := eightpoint31negative\n\tif kind == reflect.Float64 {\n\t\teightpoint31_32 = float64(float32(eightpoint31.(float64)))\n\t\teightpoint31negative_32 = float64(float32(eightpoint31negative.(float64)))\n\t}\n\n\treturn []testStep{\n\t\t{int(8), eight, false},\n\t\t{int8(8), eight, false},\n\t\t{int16(8), eight, false},\n\t\t{int32(8), eight, false},\n\t\t{int64(8), eight, false},\n\t\t{time.Weekday(8), eight, false},\n\t\t{time.Month(8), eight, false},\n\t\t{uint(8), eight, false},\n\t\t{uint8(8), eight, false},\n\t\t{uint16(8), eight, false},\n\t\t{uint32(8), eight, false},\n\t\t{uint64(8), eight, false},\n\t\t{float32(8.31), eightpoint31_32, false},\n\t\t{float64(8.31), eightpoint31, false},\n\t\t{true, one, false},\n\t\t{false, zero, false},\n\t\t{\"8\", eight, false},\n\t\t{nil, zero, false},\n\t\t{int(-8), eightnegative, isUint},\n\t\t{int8(-8), eightnegative, isUint},\n\t\t{int16(-8), eightnegative, isUint},\n\t\t{int32(-8), eightnegative, isUint},\n\t\t{int64(-8), eightnegative, isUint},\n\t\t{float32(-8.31), eightpoint31negative_32, isUint},\n\t\t{float64(-8.31), eightpoint31negative, isUint},\n\t\t{\"-8\", eightnegative, isUint},\n\t\t{jeight, eight, false},\n\t\t{jminuseight, eightnegative, isUint},\n\t\t{jfloateight, eight, false},\n\t\t{\"test\", zero, true},\n\t\t{testing.T{}, zero, true},\n\t}\n}\n\n// Maybe Go 1.18 generics will make this less ugly?\nfunc runNumberTest(c *qt.C, tests []testStep, tove func(interface{}) (interface{}, error), tov func(interface{}) interface{}) {\n\tc.Helper()\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i)\n\n\t\tv, err := tove(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil, errmsg)\n\t\t\tcontinue\n\t\t}\n\t\tc.Assert(err, qt.IsNil, errmsg)\n\t\tc.Assert(v, qt.Equals, test.expect, errmsg)\n\n\t\t// Non-E test:\n\t\tv = tov(test.input)\n\t\tc.Assert(v, qt.Equals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToUintE(t *testing.T) {\n\ttests := createNumberTestSteps(uint(0), uint(1), uint(8), uint(0), uint(8), uint(8))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToUintE(v) },\n\t\tfunc(v interface{}) interface{} { return ToUint(v) },\n\t)\n}\n\nfunc TestToUint64E(t *testing.T) {\n\ttests := createNumberTestSteps(uint64(0), uint64(1), uint64(8), uint64(0), uint64(8), uint64(8))\n\n\t// Maximum value of uint64\n\ttests = append(tests,\n\t\ttestStep{\"18446744073709551615\", uint64(18446744073709551615), false},\n\t\ttestStep{\"18446744073709551616\", uint64(0), true},\n\t)\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToUint64E(v) },\n\t\tfunc(v interface{}) interface{} { return ToUint64(v) },\n\t)\n}\n\nfunc TestToUint32E(t *testing.T) {\n\ttests := createNumberTestSteps(uint32(0), uint32(1), uint32(8), uint32(0), uint32(8), uint32(8))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToUint32E(v) },\n\t\tfunc(v interface{}) interface{} { return ToUint32(v) },\n\t)\n}\n\nfunc TestToUint16E(t *testing.T) {\n\ttests := createNumberTestSteps(uint16(0), uint16(1), uint16(8), uint16(0), uint16(8), uint16(8))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToUint16E(v) },\n\t\tfunc(v interface{}) interface{} { return ToUint16(v) },\n\t)\n}\n\nfunc TestToUint8E(t *testing.T) {\n\ttests := createNumberTestSteps(uint8(0), uint8(1), uint8(8), uint8(0), uint8(8), uint8(8))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToUint8E(v) },\n\t\tfunc(v interface{}) interface{} { return ToUint8(v) },\n\t)\n}\nfunc TestToIntE(t *testing.T) {\n\ttests := createNumberTestSteps(int(0), int(1), int(8), int(-8), int(8), int(-8))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToIntE(v) },\n\t\tfunc(v interface{}) interface{} { return ToInt(v) },\n\t)\n}\n\nfunc TestToInt64E(t *testing.T) {\n\ttests := createNumberTestSteps(int64(0), int64(1), int64(8), int64(-8), int64(8), int64(-8))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToInt64E(v) },\n\t\tfunc(v interface{}) interface{} { return ToInt64(v) },\n\t)\n}\n\nfunc TestToInt32E(t *testing.T) {\n\ttests := createNumberTestSteps(int32(0), int32(1), int32(8), int32(-8), int32(8), int32(-8))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToInt32E(v) },\n\t\tfunc(v interface{}) interface{} { return ToInt32(v) },\n\t)\n}\n\nfunc TestToInt16E(t *testing.T) {\n\ttests := createNumberTestSteps(int16(0), int16(1), int16(8), int16(-8), int16(8), int16(-8))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToInt16E(v) },\n\t\tfunc(v interface{}) interface{} { return ToInt16(v) },\n\t)\n}\n\nfunc TestToInt8E(t *testing.T) {\n\ttests := createNumberTestSteps(int8(0), int8(1), int8(8), int8(-8), int8(8), int8(-8))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToInt8E(v) },\n\t\tfunc(v interface{}) interface{} { return ToInt8(v) },\n\t)\n}\n\nfunc TestToFloat64E(t *testing.T) {\n\ttests := createNumberTestSteps(float64(0), float64(1), float64(8), float64(-8), float64(8.31), float64(-8.31))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToFloat64E(v) },\n\t\tfunc(v interface{}) interface{} { return ToFloat64(v) },\n\t)\n}\n\nfunc TestToFloat32E(t *testing.T) {\n\ttests := createNumberTestSteps(float32(0), float32(1), float32(8), float32(-8), float32(8.31), float32(-8.31))\n\n\trunNumberTest(\n\t\tqt.New(t),\n\t\ttests,\n\t\tfunc(v interface{}) (interface{}, error) { return ToFloat32E(v) },\n\t\tfunc(v interface{}) interface{} { return ToFloat32(v) },\n\t)\n}\n\nfunc TestToStringE(t *testing.T) {\n\tc := qt.New(t)\n\n\tvar jn json.Number\n\t_ = json.Unmarshal([]byte(\"8\"), &jn)\n\ttype Key struct {\n\t\tk string\n\t}\n\tkey := &Key{\"foo\"}\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect string\n\t\tiserr  bool\n\t}{\n\t\t{int(8), \"8\", false},\n\t\t{int8(8), \"8\", false},\n\t\t{int16(8), \"8\", false},\n\t\t{int32(8), \"8\", false},\n\t\t{int64(8), \"8\", false},\n\t\t{uint(8), \"8\", false},\n\t\t{uint8(8), \"8\", false},\n\t\t{uint16(8), \"8\", false},\n\t\t{uint32(8), \"8\", false},\n\t\t{uint64(8), \"8\", false},\n\t\t{float32(8.31), \"8.31\", false},\n\t\t{float64(8.31), \"8.31\", false},\n\t\t{jn, \"8\", false},\n\t\t{true, \"true\", false},\n\t\t{false, \"false\", false},\n\t\t{nil, \"\", false},\n\t\t{[]byte(\"one time\"), \"one time\", false},\n\t\t{\"one more time\", \"one more time\", false},\n\t\t{template.HTML(\"one time\"), \"one time\", false},\n\t\t{template.URL(\"http://somehost.foo\"), \"http://somehost.foo\", false},\n\t\t{template.JS(\"(1+2)\"), \"(1+2)\", false},\n\t\t{template.CSS(\"a\"), \"a\", false},\n\t\t{template.HTMLAttr(\"a\"), \"a\", false},\n\t\t// errors\n\t\t{testing.T{}, \"\", true},\n\t\t{key, \"\", true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToStringE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil, errmsg)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil, errmsg)\n\t\tc.Assert(v, qt.Equals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToString(test.input)\n\t\tc.Assert(v, qt.Equals, test.expect, errmsg)\n\t}\n}\n\ntype foo struct {\n\tval string\n}\n\nfunc (x foo) String() string {\n\treturn x.val\n}\n\nfunc TestStringerToString(t *testing.T) {\n\tc := qt.New(t)\n\n\tvar x foo\n\tx.val = \"bar\"\n\tc.Assert(ToString(x), qt.Equals, \"bar\")\n}\n\ntype fu struct {\n\tval string\n}\n\nfunc (x fu) Error() string {\n\treturn x.val\n}\n\nfunc TestErrorToString(t *testing.T) {\n\tc := qt.New(t)\n\n\tvar x fu\n\tx.val = \"bar\"\n\tc.Assert(ToString(x), qt.Equals, \"bar\")\n}\n\nfunc TestStringMapStringSliceE(t *testing.T) {\n\tc := qt.New(t)\n\n\t// ToStringMapString inputs/outputs\n\tvar stringMapString = map[string]string{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}\n\tvar stringMapInterface = map[string]interface{}{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}\n\tvar interfaceMapString = map[interface{}]string{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}\n\tvar interfaceMapInterface = map[interface{}]interface{}{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}\n\n\t// ToStringMapStringSlice inputs/outputs\n\tvar stringMapStringSlice = map[string][]string{\"key 1\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 2\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 3\": {\"value 1\", \"value 2\", \"value 3\"}}\n\tvar stringMapInterfaceSlice = map[string][]interface{}{\"key 1\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 2\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 3\": {\"value 1\", \"value 2\", \"value 3\"}}\n\tvar stringMapInterfaceInterfaceSlice = map[string]interface{}{\"key 1\": []interface{}{\"value 1\", \"value 2\", \"value 3\"}, \"key 2\": []interface{}{\"value 1\", \"value 2\", \"value 3\"}, \"key 3\": []interface{}{\"value 1\", \"value 2\", \"value 3\"}}\n\tvar stringMapStringSingleSliceFieldsResult = map[string][]string{\"key 1\": {\"value\", \"1\"}, \"key 2\": {\"value\", \"2\"}, \"key 3\": {\"value\", \"3\"}}\n\tvar interfaceMapStringSlice = map[interface{}][]string{\"key 1\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 2\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 3\": {\"value 1\", \"value 2\", \"value 3\"}}\n\tvar interfaceMapInterfaceSlice = map[interface{}][]interface{}{\"key 1\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 2\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 3\": {\"value 1\", \"value 2\", \"value 3\"}}\n\n\tvar stringMapStringSliceMultiple = map[string][]string{\"key 1\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 2\": {\"value 1\", \"value 2\", \"value 3\"}, \"key 3\": {\"value 1\", \"value 2\", \"value 3\"}}\n\tvar stringMapStringSliceSingle = map[string][]string{\"key 1\": {\"value 1\"}, \"key 2\": {\"value 2\"}, \"key 3\": {\"value 3\"}}\n\n\tvar stringMapInterface1 = map[string]interface{}{\"key 1\": []string{\"value 1\"}, \"key 2\": []string{\"value 2\"}}\n\tvar stringMapInterfaceResult1 = map[string][]string{\"key 1\": {\"value 1\"}, \"key 2\": {\"value 2\"}}\n\n\tvar jsonStringMapString = `{\"key 1\": \"value 1\", \"key 2\": \"value 2\"}`\n\tvar jsonStringMapStringArray = `{\"key 1\": [\"value 1\"], \"key 2\": [\"value 2\", \"value 3\"]}`\n\tvar jsonStringMapStringArrayResult = map[string][]string{\"key 1\": {\"value 1\"}, \"key 2\": {\"value 2\", \"value 3\"}}\n\n\ttype Key struct {\n\t\tk string\n\t}\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect map[string][]string\n\t\tiserr  bool\n\t}{\n\t\t{stringMapStringSlice, stringMapStringSlice, false},\n\t\t{stringMapInterfaceSlice, stringMapStringSlice, false},\n\t\t{stringMapInterfaceInterfaceSlice, stringMapStringSlice, false},\n\t\t{stringMapStringSliceMultiple, stringMapStringSlice, false},\n\t\t{stringMapStringSliceMultiple, stringMapStringSlice, false},\n\t\t{stringMapString, stringMapStringSliceSingle, false},\n\t\t{stringMapInterface, stringMapStringSliceSingle, false},\n\t\t{stringMapInterface1, stringMapInterfaceResult1, false},\n\t\t{interfaceMapStringSlice, stringMapStringSlice, false},\n\t\t{interfaceMapInterfaceSlice, stringMapStringSlice, false},\n\t\t{interfaceMapString, stringMapStringSingleSliceFieldsResult, false},\n\t\t{interfaceMapInterface, stringMapStringSingleSliceFieldsResult, false},\n\t\t{jsonStringMapStringArray, jsonStringMapStringArrayResult, false},\n\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t\t{map[interface{}]interface{}{\"foo\": testing.T{}}, nil, true},\n\t\t{map[interface{}]interface{}{Key{\"foo\"}: \"bar\"}, nil, true}, // ToStringE(Key{\"foo\"}) should fail\n\t\t{jsonStringMapString, nil, true},\n\t\t{\"\", nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToStringMapStringSliceE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil, errmsg)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil, errmsg)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToStringMapStringSlice(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToStringMapE(t *testing.T) {\n\tc := qt.New(t)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect map[string]interface{}\n\t\tiserr  bool\n\t}{\n\t\t{map[interface{}]interface{}{\"tag\": \"tags\", \"group\": \"groups\"}, map[string]interface{}{\"tag\": \"tags\", \"group\": \"groups\"}, false},\n\t\t{map[string]interface{}{\"tag\": \"tags\", \"group\": \"groups\"}, map[string]interface{}{\"tag\": \"tags\", \"group\": \"groups\"}, false},\n\t\t{`{\"tag\": \"tags\", \"group\": \"groups\"}`, map[string]interface{}{\"tag\": \"tags\", \"group\": \"groups\"}, false},\n\t\t{`{\"tag\": \"tags\", \"group\": true}`, map[string]interface{}{\"tag\": \"tags\", \"group\": true}, false},\n\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t\t{\"\", nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToStringMapE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil, errmsg)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil, errmsg)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToStringMap(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToStringMapBoolE(t *testing.T) {\n\tc := qt.New(t)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect map[string]bool\n\t\tiserr  bool\n\t}{\n\t\t{map[interface{}]interface{}{\"v1\": true, \"v2\": false}, map[string]bool{\"v1\": true, \"v2\": false}, false},\n\t\t{map[string]interface{}{\"v1\": true, \"v2\": false}, map[string]bool{\"v1\": true, \"v2\": false}, false},\n\t\t{map[string]bool{\"v1\": true, \"v2\": false}, map[string]bool{\"v1\": true, \"v2\": false}, false},\n\t\t{`{\"v1\": true, \"v2\": false}`, map[string]bool{\"v1\": true, \"v2\": false}, false},\n\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t\t{\"\", nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToStringMapBoolE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil, errmsg)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil, errmsg)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToStringMapBool(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToStringMapIntE(t *testing.T) {\n\tc := qt.New(t)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect map[string]int\n\t\tiserr  bool\n\t}{\n\t\t{map[interface{}]interface{}{\"v1\": 1, \"v2\": 222}, map[string]int{\"v1\": 1, \"v2\": 222}, false},\n\t\t{map[string]interface{}{\"v1\": 342, \"v2\": 5141}, map[string]int{\"v1\": 342, \"v2\": 5141}, false},\n\t\t{map[string]int{\"v1\": 33, \"v2\": 88}, map[string]int{\"v1\": 33, \"v2\": 88}, false},\n\t\t{map[string]int32{\"v1\": int32(33), \"v2\": int32(88)}, map[string]int{\"v1\": 33, \"v2\": 88}, false},\n\t\t{map[string]uint16{\"v1\": uint16(33), \"v2\": uint16(88)}, map[string]int{\"v1\": 33, \"v2\": 88}, false},\n\t\t{map[string]float64{\"v1\": float64(8.22), \"v2\": float64(43.32)}, map[string]int{\"v1\": 8, \"v2\": 43}, false},\n\t\t{`{\"v1\": 67, \"v2\": 56}`, map[string]int{\"v1\": 67, \"v2\": 56}, false},\n\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t\t{\"\", nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToStringMapIntE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil, errmsg)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil, errmsg)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToStringMapInt(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToStringMapInt64E(t *testing.T) {\n\tc := qt.New(t)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect map[string]int64\n\t\tiserr  bool\n\t}{\n\t\t{map[interface{}]interface{}{\"v1\": int32(8), \"v2\": int32(888)}, map[string]int64{\"v1\": int64(8), \"v2\": int64(888)}, false},\n\t\t{map[string]interface{}{\"v1\": int64(45), \"v2\": int64(67)}, map[string]int64{\"v1\": 45, \"v2\": 67}, false},\n\t\t{map[string]int64{\"v1\": 33, \"v2\": 88}, map[string]int64{\"v1\": 33, \"v2\": 88}, false},\n\t\t{map[string]int{\"v1\": 33, \"v2\": 88}, map[string]int64{\"v1\": 33, \"v2\": 88}, false},\n\t\t{map[string]int32{\"v1\": int32(33), \"v2\": int32(88)}, map[string]int64{\"v1\": 33, \"v2\": 88}, false},\n\t\t{map[string]uint16{\"v1\": uint16(33), \"v2\": uint16(88)}, map[string]int64{\"v1\": 33, \"v2\": 88}, false},\n\t\t{map[string]float64{\"v1\": float64(8.22), \"v2\": float64(43.32)}, map[string]int64{\"v1\": 8, \"v2\": 43}, false},\n\t\t{`{\"v1\": 67, \"v2\": 56}`, map[string]int64{\"v1\": 67, \"v2\": 56}, false},\n\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t\t{\"\", nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToStringMapInt64E(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToStringMapInt64(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToStringMapStringE(t *testing.T) {\n\tc := qt.New(t)\n\n\tvar stringMapString = map[string]string{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}\n\tvar stringMapInterface = map[string]interface{}{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}\n\tvar interfaceMapString = map[interface{}]string{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}\n\tvar interfaceMapInterface = map[interface{}]interface{}{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}\n\tvar jsonString = `{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}`\n\tvar invalidJsonString = `{\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"`\n\tvar emptyString = \"\"\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect map[string]string\n\t\tiserr  bool\n\t}{\n\t\t{stringMapString, stringMapString, false},\n\t\t{stringMapInterface, stringMapString, false},\n\t\t{interfaceMapString, stringMapString, false},\n\t\t{interfaceMapInterface, stringMapString, false},\n\t\t{jsonString, stringMapString, false},\n\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t\t{invalidJsonString, nil, true},\n\t\t{emptyString, nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToStringMapStringE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToStringMapString(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToBoolSliceE(t *testing.T) {\n\tc := qt.New(t)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect []bool\n\t\tiserr  bool\n\t}{\n\t\t{[]bool{true, false, true}, []bool{true, false, true}, false},\n\t\t{[]interface{}{true, false, true}, []bool{true, false, true}, false},\n\t\t{[]int{1, 0, 1}, []bool{true, false, true}, false},\n\t\t{[]string{\"true\", \"false\", \"true\"}, []bool{true, false, true}, false},\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t\t{[]string{\"foo\", \"bar\"}, nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToBoolSliceE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToBoolSlice(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToIntSliceE(t *testing.T) {\n\tc := qt.New(t)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect []int\n\t\tiserr  bool\n\t}{\n\t\t{[]int{1, 3}, []int{1, 3}, false},\n\t\t{[]interface{}{1.2, 3.2}, []int{1, 3}, false},\n\t\t{[]string{\"2\", \"3\"}, []int{2, 3}, false},\n\t\t{[2]string{\"2\", \"3\"}, []int{2, 3}, false},\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t\t{[]string{\"foo\", \"bar\"}, nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToIntSliceE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToIntSlice(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToSliceE(t *testing.T) {\n\tc := qt.New(t)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect []interface{}\n\t\tiserr  bool\n\t}{\n\t\t{[]interface{}{1, 3}, []interface{}{1, 3}, false},\n\t\t{[]map[string]interface{}{{\"k1\": 1}, {\"k2\": 2}}, []interface{}{map[string]interface{}{\"k1\": 1}, map[string]interface{}{\"k2\": 2}}, false},\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToSliceE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToSlice(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToStringSliceE(t *testing.T) {\n\tc := qt.New(t)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect []string\n\t\tiserr  bool\n\t}{\n\t\t{[]int{1, 2}, []string{\"1\", \"2\"}, false},\n\t\t{[]int8{int8(1), int8(2)}, []string{\"1\", \"2\"}, false},\n\t\t{[]int32{int32(1), int32(2)}, []string{\"1\", \"2\"}, false},\n\t\t{[]int64{int64(1), int64(2)}, []string{\"1\", \"2\"}, false},\n\t\t{[]float32{float32(1.01), float32(2.01)}, []string{\"1.01\", \"2.01\"}, false},\n\t\t{[]float64{float64(1.01), float64(2.01)}, []string{\"1.01\", \"2.01\"}, false},\n\t\t{[]string{\"a\", \"b\"}, []string{\"a\", \"b\"}, false},\n\t\t{[]interface{}{1, 3}, []string{\"1\", \"3\"}, false},\n\t\t{interface{}(1), []string{\"1\"}, false},\n\t\t{[]error{errors.New(\"a\"), errors.New(\"b\")}, []string{\"a\", \"b\"}, false},\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToStringSliceE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToStringSlice(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToDurationSliceE(t *testing.T) {\n\tc := qt.New(t)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect []time.Duration\n\t\tiserr  bool\n\t}{\n\t\t{[]string{\"1s\", \"1m\"}, []time.Duration{time.Second, time.Minute}, false},\n\t\t{[]int{1, 2}, []time.Duration{1, 2}, false},\n\t\t{[]interface{}{1, 3}, []time.Duration{1, 3}, false},\n\t\t{[]time.Duration{1, 3}, []time.Duration{1, 3}, false},\n\n\t\t// errors\n\t\t{nil, nil, true},\n\t\t{testing.T{}, nil, true},\n\t\t{[]string{\"invalid\"}, nil, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToDurationSliceE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToDurationSlice(test.input)\n\t\tc.Assert(v, qt.DeepEquals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToBoolE(t *testing.T) {\n\tc := qt.New(t)\n\n\tvar jf, jt, je json.Number\n\t_ = json.Unmarshal([]byte(\"0\"), &jf)\n\t_ = json.Unmarshal([]byte(\"1\"), &jt)\n\t_ = json.Unmarshal([]byte(\"1.0\"), &je)\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect bool\n\t\tiserr  bool\n\t}{\n\t\t{0, false, false},\n\t\t{int64(0), false, false},\n\t\t{int32(0), false, false},\n\t\t{int16(0), false, false},\n\t\t{int8(0), false, false},\n\t\t{uint(0), false, false},\n\t\t{uint64(0), false, false},\n\t\t{uint32(0), false, false},\n\t\t{uint16(0), false, false},\n\t\t{uint8(0), false, false},\n\t\t{float64(0), false, false},\n\t\t{float32(0), false, false},\n\t\t{time.Duration(0), false, false},\n\t\t{jf, false, false},\n\t\t{nil, false, false},\n\t\t{\"false\", false, false},\n\t\t{\"FALSE\", false, false},\n\t\t{\"False\", false, false},\n\t\t{\"f\", false, false},\n\t\t{\"F\", false, false},\n\t\t{false, false, false},\n\n\t\t{\"true\", true, false},\n\t\t{\"TRUE\", true, false},\n\t\t{\"True\", true, false},\n\t\t{\"t\", true, false},\n\t\t{\"T\", true, false},\n\t\t{1, true, false},\n\t\t{int64(1), true, false},\n\t\t{int32(1), true, false},\n\t\t{int16(1), true, false},\n\t\t{int8(1), true, false},\n\t\t{uint(1), true, false},\n\t\t{uint64(1), true, false},\n\t\t{uint32(1), true, false},\n\t\t{uint16(1), true, false},\n\t\t{uint8(1), true, false},\n\t\t{float64(1), true, false},\n\t\t{float32(1), true, false},\n\t\t{time.Duration(1), true, false},\n\t\t{jt, true, false},\n\t\t{je, true, false},\n\t\t{true, true, false},\n\t\t{-1, true, false},\n\t\t{int64(-1), true, false},\n\t\t{int32(-1), true, false},\n\t\t{int16(-1), true, false},\n\t\t{int8(-1), true, false},\n\n\t\t// errors\n\t\t{\"test\", false, true},\n\t\t{testing.T{}, false, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToBoolE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToBool(test.input)\n\t\tc.Assert(v, qt.Equals, test.expect, errmsg)\n\t}\n}\n\nfunc BenchmarkTooBool(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tif !ToBool(true) {\n\t\t\tb.Fatal(\"ToBool returned false\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkTooInt(b *testing.B) {\n\tconvert := func(num52 interface{}) {\n\t\tif v := ToInt(num52); v != 52 {\n\t\t\tb.Fatalf(\"ToInt returned wrong value, got %d, want %d\", v, 32)\n\t\t}\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tconvert(\"52\")\n\t\tconvert(52.0)\n\t\tconvert(uint64(52))\n\t}\n}\n\nfunc BenchmarkTrimZeroDecimal(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\ttrimZeroDecimal(\"\")\n\t\ttrimZeroDecimal(\"123\")\n\t\ttrimZeroDecimal(\"120\")\n\t\ttrimZeroDecimal(\"120.00\")\n\t}\n}\n\nfunc BenchmarkCommonTimeLayouts(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, commonLayout := range []string{\"2019-04-29\", \"2017-05-30T00:00:00Z\"} {\n\t\t\t_, err := StringToDateInDefaultLocation(commonLayout, time.UTC)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIndirectPointers(t *testing.T) {\n\tc := qt.New(t)\n\n\tx := 13\n\ty := &x\n\tz := &y\n\n\tc.Assert(ToInt(y), qt.Equals, 13)\n\tc.Assert(ToInt(z), qt.Equals, 13)\n\n}\n\nfunc TestToTime(t *testing.T) {\n\tc := qt.New(t)\n\n\tvar jntime, jnetime json.Number\n\t_ = json.Unmarshal([]byte(\"1234567890\"), &jntime)\n\t_ = json.Unmarshal([]byte(\"123.4567890\"), &jnetime)\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect time.Time\n\t\tiserr  bool\n\t}{\n\t\t{\"2009-11-10 23:00:00 +0000 UTC\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},   // Time.String()\n\t\t{\"Tue Nov 10 23:00:00 2009\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},        // ANSIC\n\t\t{\"Tue Nov 10 23:00:00 UTC 2009\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},    // UnixDate\n\t\t{\"Tue Nov 10 23:00:00 +0000 2009\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},  // RubyDate\n\t\t{\"10 Nov 09 23:00 UTC\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},             // RFC822\n\t\t{\"10 Nov 09 23:00 +0000\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},           // RFC822Z\n\t\t{\"Tuesday, 10-Nov-09 23:00:00 UTC\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false}, // RFC850\n\t\t{\"Tue, 10 Nov 2009 23:00:00 UTC\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},   // RFC1123\n\t\t{\"Tue, 10 Nov 2009 23:00:00 +0000\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false}, // RFC1123Z\n\t\t{\"2009-11-10T23:00:00Z\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},            // RFC3339\n\t\t{\"2018-10-21T23:21:29+0200\", time.Date(2018, 10, 21, 21, 21, 29, 0, time.UTC), false},      // RFC3339 without timezone hh:mm colon\n\t\t{\"2009-11-10T23:00:00Z\", time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC), false},            // RFC3339Nano\n\t\t{\"11:00PM\", time.Date(0, 1, 1, 23, 0, 0, 0, time.UTC), false},                              // Kitchen\n\t\t{\"Nov 10 23:00:00\", time.Date(0, 11, 10, 23, 0, 0, 0, time.UTC), false},                    // Stamp\n\t\t{\"Nov 10 23:00:00.000\", time.Date(0, 11, 10, 23, 0, 0, 0, time.UTC), false},                // StampMilli\n\t\t{\"Nov 10 23:00:00.000000\", time.Date(0, 11, 10, 23, 0, 0, 0, time.UTC), false},             // StampMicro\n\t\t{\"Nov 10 23:00:00.000000000\", time.Date(0, 11, 10, 23, 0, 0, 0, time.UTC), false},          // StampNano\n\t\t{\"2016-03-06 15:28:01-00:00\", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},        // RFC3339 without T\n\t\t{\"2016-03-06 15:28:01-0000\", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},         // RFC3339 without T or timezone hh:mm colon\n\t\t{\"2016-03-06 15:28:01\", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},\n\t\t{\"2016-03-06 15:28:01 -0000\", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},\n\t\t{\"2016-03-06 15:28:01 -00:00\", time.Date(2016, 3, 6, 15, 28, 1, 0, time.UTC), false},\n\t\t{\"2016-03-06 15:28:01 +0900\", time.Date(2016, 3, 6, 6, 28, 1, 0, time.UTC), false},\n\t\t{\"2016-03-06 15:28:01 +09:00\", time.Date(2016, 3, 6, 6, 28, 1, 0, time.UTC), false},\n\t\t{\"2006-01-02\", time.Date(2006, 1, 2, 0, 0, 0, 0, time.UTC), false},\n\t\t{\"02 Jan 2006\", time.Date(2006, 1, 2, 0, 0, 0, 0, time.UTC), false},\n\t\t{1472574600, time.Date(2016, 8, 30, 16, 30, 0, 0, time.UTC), false},\n\t\t{int(1482597504), time.Date(2016, 12, 24, 16, 38, 24, 0, time.UTC), false},\n\t\t{int64(1234567890), time.Date(2009, 2, 13, 23, 31, 30, 0, time.UTC), false},\n\t\t{int32(1234567890), time.Date(2009, 2, 13, 23, 31, 30, 0, time.UTC), false},\n\t\t{uint(1482597504), time.Date(2016, 12, 24, 16, 38, 24, 0, time.UTC), false},\n\t\t{uint64(1234567890), time.Date(2009, 2, 13, 23, 31, 30, 0, time.UTC), false},\n\t\t{uint32(1234567890), time.Date(2009, 2, 13, 23, 31, 30, 0, time.UTC), false},\n\t\t{jntime, time.Date(2009, 2, 13, 23, 31, 30, 0, time.UTC), false},\n\t\t{time.Date(2009, 2, 13, 23, 31, 30, 0, time.UTC), time.Date(2009, 2, 13, 23, 31, 30, 0, time.UTC), false},\n\t\t// errors\n\t\t{\"2006\", time.Time{}, true},\n\t\t{jnetime, time.Time{}, true},\n\t\t{testing.T{}, time.Time{}, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToTimeE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v.UTC(), qt.Equals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToTime(test.input)\n\t\tc.Assert(v.UTC(), qt.Equals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToDurationE(t *testing.T) {\n\tc := qt.New(t)\n\n\tvar td time.Duration = 5\n\tvar jn json.Number\n\t_ = json.Unmarshal([]byte(\"5\"), &jn)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\texpect time.Duration\n\t\tiserr  bool\n\t}{\n\t\t{time.Duration(5), td, false},\n\t\t{int(5), td, false},\n\t\t{int64(5), td, false},\n\t\t{int32(5), td, false},\n\t\t{int16(5), td, false},\n\t\t{int8(5), td, false},\n\t\t{uint(5), td, false},\n\t\t{uint64(5), td, false},\n\t\t{uint32(5), td, false},\n\t\t{uint16(5), td, false},\n\t\t{uint8(5), td, false},\n\t\t{float64(5), td, false},\n\t\t{float32(5), td, false},\n\t\t{jn, td, false},\n\t\t{string(\"5\"), td, false},\n\t\t{string(\"5ns\"), td, false},\n\t\t{string(\"5us\"), time.Microsecond * td, false},\n\t\t{string(\"5µs\"), time.Microsecond * td, false},\n\t\t{string(\"5ms\"), time.Millisecond * td, false},\n\t\t{string(\"5s\"), time.Second * td, false},\n\t\t{string(\"5m\"), time.Minute * td, false},\n\t\t{string(\"5h\"), time.Hour * td, false},\n\t\t// errors\n\t\t{\"test\", 0, true},\n\t\t{testing.T{}, 0, true},\n\t}\n\n\tfor i, test := range tests {\n\t\terrmsg := qt.Commentf(\"i = %d\", i) // assert helper message\n\n\t\tv, err := ToDurationE(test.input)\n\t\tif test.iserr {\n\t\t\tc.Assert(err, qt.IsNotNil)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, test.expect, errmsg)\n\n\t\t// Non-E test\n\t\tv = ToDuration(test.input)\n\t\tc.Assert(v, qt.Equals, test.expect, errmsg)\n\t}\n}\n\nfunc TestToTimeWithTimezones(t *testing.T) {\n\tc := qt.New(t)\n\n\test, err := time.LoadLocation(\"EST\")\n\tc.Assert(err, qt.IsNil)\n\n\tirn, err := time.LoadLocation(\"Iran\")\n\tc.Assert(err, qt.IsNil)\n\n\tswd, err := time.LoadLocation(\"Europe/Stockholm\")\n\tc.Assert(err, qt.IsNil)\n\n\t// Test same local time in different timezones\n\tutc2016 := time.Date(2016, time.January, 1, 0, 0, 0, 0, time.UTC)\n\test2016 := time.Date(2016, time.January, 1, 0, 0, 0, 0, est)\n\tirn2016 := time.Date(2016, time.January, 1, 0, 0, 0, 0, irn)\n\tswd2016 := time.Date(2016, time.January, 1, 0, 0, 0, 0, swd)\n\tloc2016 := time.Date(2016, time.January, 1, 0, 0, 0, 0, time.Local)\n\n\tfor i, format := range timeFormats {\n\t\tformat := format\n\t\tif format.typ == timeFormatTimeOnly {\n\t\t\tcontinue\n\t\t}\n\n\t\tnameBase := fmt.Sprintf(\"%d;timeFormatType=%d;%s\", i, format.typ, format.format)\n\n\t\tt.Run(path.Join(nameBase), func(t *testing.T) {\n\t\t\test2016str := est2016.Format(format.format)\n\t\t\tswd2016str := swd2016.Format(format.format)\n\n\t\t\tt.Run(\"without default location\", func(t *testing.T) {\n\t\t\t\tc := qt.New(t)\n\t\t\t\tconverted, err := ToTimeE(est2016str)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tif format.hasTimezone() {\n\t\t\t\t\t// Converting inputs with a timezone should preserve it\n\t\t\t\t\tassertTimeEqual(t, est2016, converted)\n\t\t\t\t\tassertLocationEqual(t, est, converted.Location())\n\t\t\t\t} else {\n\t\t\t\t\t// Converting inputs without a timezone should be interpreted\n\t\t\t\t\t// as a local time in UTC.\n\t\t\t\t\tassertTimeEqual(t, utc2016, converted)\n\t\t\t\t\tassertLocationEqual(t, time.UTC, converted.Location())\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"local timezone without a default location\", func(t *testing.T) {\n\t\t\t\tc := qt.New(t)\n\t\t\t\tconverted, err := ToTimeE(swd2016str)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tif format.hasTimezone() {\n\t\t\t\t\t// Converting inputs with a timezone should preserve it\n\t\t\t\t\tassertTimeEqual(t, swd2016, converted)\n\t\t\t\t\tassertLocationEqual(t, swd, converted.Location())\n\t\t\t\t} else {\n\t\t\t\t\t// Converting inputs without a timezone should be interpreted\n\t\t\t\t\t// as a local time in UTC.\n\t\t\t\t\tassertTimeEqual(t, utc2016, converted)\n\t\t\t\t\tassertLocationEqual(t, time.UTC, converted.Location())\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"nil default location\", func(t *testing.T) {\n\t\t\t\tc := qt.New(t)\n\n\t\t\t\tconverted, err := ToTimeInDefaultLocationE(est2016str, nil)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tif format.hasTimezone() {\n\t\t\t\t\t// Converting inputs with a timezone should preserve it\n\t\t\t\t\tassertTimeEqual(t, est2016, converted)\n\t\t\t\t\tassertLocationEqual(t, est, converted.Location())\n\t\t\t\t} else {\n\t\t\t\t\t// Converting inputs without a timezone should be interpreted\n\t\t\t\t\t// as a local time in the local timezone.\n\t\t\t\t\tassertTimeEqual(t, loc2016, converted)\n\t\t\t\t\tassertLocationEqual(t, time.Local, converted.Location())\n\t\t\t\t}\n\n\t\t\t})\n\n\t\t\tt.Run(\"default location not UTC\", func(t *testing.T) {\n\t\t\t\tc := qt.New(t)\n\n\t\t\t\tconverted, err := ToTimeInDefaultLocationE(est2016str, irn)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tif format.hasTimezone() {\n\t\t\t\t\t// Converting inputs with a timezone should preserve it\n\t\t\t\t\tassertTimeEqual(t, est2016, converted)\n\t\t\t\t\tassertLocationEqual(t, est, converted.Location())\n\t\t\t\t} else {\n\t\t\t\t\t// Converting inputs without a timezone should be interpreted\n\t\t\t\t\t// as a local time in the given location.\n\t\t\t\t\tassertTimeEqual(t, irn2016, converted)\n\t\t\t\t\tassertLocationEqual(t, irn, converted.Location())\n\t\t\t\t}\n\n\t\t\t})\n\n\t\t\tt.Run(\"time in the local timezone default location not UTC\", func(t *testing.T) {\n\t\t\t\tc := qt.New(t)\n\n\t\t\t\tconverted, err := ToTimeInDefaultLocationE(swd2016str, irn)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tif format.hasTimezone() {\n\t\t\t\t\t// Converting inputs with a timezone should preserve it\n\t\t\t\t\tassertTimeEqual(t, swd2016, converted)\n\t\t\t\t\tassertLocationEqual(t, swd, converted.Location())\n\t\t\t\t} else {\n\t\t\t\t\t// Converting inputs without a timezone should be interpreted\n\t\t\t\t\t// as a local time in the given location.\n\t\t\t\t\tassertTimeEqual(t, irn2016, converted)\n\t\t\t\t\tassertLocationEqual(t, irn, converted.Location())\n\t\t\t\t}\n\n\t\t\t})\n\n\t\t})\n\n\t}\n}\n\nfunc TestTrimZeroDecimal(t *testing.T) {\n\tc := qt.New(t)\n\n\tc.Assert(trimZeroDecimal(\"10.0\"), qt.Equals, \"10\")\n\tc.Assert(trimZeroDecimal(\"10.00\"), qt.Equals, \"10\")\n\tc.Assert(trimZeroDecimal(\"10.010\"), qt.Equals, \"10.010\")\n\tc.Assert(trimZeroDecimal(\"0.0000000000\"), qt.Equals, \"0\")\n\tc.Assert(trimZeroDecimal(\"0.00000000001\"), qt.Equals, \"0.00000000001\")\n\n}\n\nfunc assertTimeEqual(t *testing.T, expected, actual time.Time) {\n\tt.Helper()\n\t// Compare the dates using a numeric zone as there are cases where\n\t// time.Parse will assign a dummy location.\n\tqt.Assert(t, actual.Format(time.RFC1123Z), qt.Equals, expected.Format(time.RFC1123Z))\n}\n\nfunc assertLocationEqual(t *testing.T, expected, actual *time.Location) {\n\tt.Helper()\n\tqt.Assert(t, locationEqual(expected, actual), qt.IsTrue)\n}\n\nfunc locationEqual(a, b *time.Location) bool {\n\t// A note about comparring time.Locations:\n\t//   - can't only compare pointers\n\t//   - can't compare loc.String() because locations with the same\n\t//     name can have different offsets\n\t//   - can't use reflect.DeepEqual because time.Location has internal\n\t//     caches\n\n\tif a == b {\n\t\treturn true\n\t} else if a == nil || b == nil {\n\t\treturn false\n\t}\n\n\t// Check if they're equal by parsing times with a format that doesn't\n\t// include a timezone, which will interpret it as being a local time in\n\t// the given zone, and comparing the resulting local times.\n\ttA, err := time.ParseInLocation(\"2006-01-02\", \"2016-01-01\", a)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\ttB, err := time.ParseInLocation(\"2006-01-02\", \"2016-01-01\", b)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn tA.Equal(tB)\n}\n"
        },
        {
          "name": "caste.go",
          "type": "blob",
          "size": 32.9990234375,
          "content": "// Copyright © 2014 Steve Francia <spf@spf13.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage cast\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar errNegativeNotAllowed = errors.New(\"unable to cast negative value\")\n\ntype float64EProvider interface {\n\tFloat64() (float64, error)\n}\n\ntype float64Provider interface {\n\tFloat64() float64\n}\n\n// ToTimeE casts an interface to a time.Time type.\nfunc ToTimeE(i interface{}) (tim time.Time, err error) {\n\treturn ToTimeInDefaultLocationE(i, time.UTC)\n}\n\n// ToTimeInDefaultLocationE casts an empty interface to time.Time,\n// interpreting inputs without a timezone to be in the given location,\n// or the local timezone if nil.\nfunc ToTimeInDefaultLocationE(i interface{}, location *time.Location) (tim time.Time, err error) {\n\ti = indirect(i)\n\n\tswitch v := i.(type) {\n\tcase time.Time:\n\t\treturn v, nil\n\tcase string:\n\t\treturn StringToDateInDefaultLocation(v, location)\n\tcase json.Number:\n\t\ts, err1 := ToInt64E(v)\n\t\tif err1 != nil {\n\t\t\treturn time.Time{}, fmt.Errorf(\"unable to cast %#v of type %T to Time\", i, i)\n\t\t}\n\t\treturn time.Unix(s, 0), nil\n\tcase int:\n\t\treturn time.Unix(int64(v), 0), nil\n\tcase int64:\n\t\treturn time.Unix(v, 0), nil\n\tcase int32:\n\t\treturn time.Unix(int64(v), 0), nil\n\tcase uint:\n\t\treturn time.Unix(int64(v), 0), nil\n\tcase uint64:\n\t\treturn time.Unix(int64(v), 0), nil\n\tcase uint32:\n\t\treturn time.Unix(int64(v), 0), nil\n\tdefault:\n\t\treturn time.Time{}, fmt.Errorf(\"unable to cast %#v of type %T to Time\", i, i)\n\t}\n}\n\n// ToDurationE casts an interface to a time.Duration type.\nfunc ToDurationE(i interface{}) (d time.Duration, err error) {\n\ti = indirect(i)\n\n\tswitch s := i.(type) {\n\tcase time.Duration:\n\t\treturn s, nil\n\tcase int, int64, int32, int16, int8, uint, uint64, uint32, uint16, uint8:\n\t\td = time.Duration(ToInt64(s))\n\t\treturn\n\tcase float32, float64:\n\t\td = time.Duration(ToFloat64(s))\n\t\treturn\n\tcase string:\n\t\tif strings.ContainsAny(s, \"nsuµmh\") {\n\t\t\td, err = time.ParseDuration(s)\n\t\t} else {\n\t\t\td, err = time.ParseDuration(s + \"ns\")\n\t\t}\n\t\treturn\n\tcase float64EProvider:\n\t\tvar v float64\n\t\tv, err = s.Float64()\n\t\td = time.Duration(v)\n\t\treturn\n\tcase float64Provider:\n\t\td = time.Duration(s.Float64())\n\t\treturn\n\tdefault:\n\t\terr = fmt.Errorf(\"unable to cast %#v of type %T to Duration\", i, i)\n\t\treturn\n\t}\n}\n\n// ToBoolE casts an interface to a bool type.\nfunc ToBoolE(i interface{}) (bool, error) {\n\ti = indirect(i)\n\n\tswitch b := i.(type) {\n\tcase bool:\n\t\treturn b, nil\n\tcase nil:\n\t\treturn false, nil\n\tcase int:\n\t\treturn b != 0, nil\n\tcase int64:\n\t\treturn b != 0, nil\n\tcase int32:\n\t\treturn b != 0, nil\n\tcase int16:\n\t\treturn b != 0, nil\n\tcase int8:\n\t\treturn b != 0, nil\n\tcase uint:\n\t\treturn b != 0, nil\n\tcase uint64:\n\t\treturn b != 0, nil\n\tcase uint32:\n\t\treturn b != 0, nil\n\tcase uint16:\n\t\treturn b != 0, nil\n\tcase uint8:\n\t\treturn b != 0, nil\n\tcase float64:\n\t\treturn b != 0, nil\n\tcase float32:\n\t\treturn b != 0, nil\n\tcase time.Duration:\n\t\treturn b != 0, nil\n\tcase string:\n\t\treturn strconv.ParseBool(i.(string))\n\tcase json.Number:\n\t\tv, err := ToInt64E(b)\n\t\tif err == nil {\n\t\t\treturn v != 0, nil\n\t\t}\n\t\treturn false, fmt.Errorf(\"unable to cast %#v of type %T to bool\", i, i)\n\tdefault:\n\t\treturn false, fmt.Errorf(\"unable to cast %#v of type %T to bool\", i, i)\n\t}\n}\n\n// ToFloat64E casts an interface to a float64 type.\nfunc ToFloat64E(i interface{}) (float64, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\treturn float64(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase float64:\n\t\treturn s, nil\n\tcase float32:\n\t\treturn float64(s), nil\n\tcase int64:\n\t\treturn float64(s), nil\n\tcase int32:\n\t\treturn float64(s), nil\n\tcase int16:\n\t\treturn float64(s), nil\n\tcase int8:\n\t\treturn float64(s), nil\n\tcase uint:\n\t\treturn float64(s), nil\n\tcase uint64:\n\t\treturn float64(s), nil\n\tcase uint32:\n\t\treturn float64(s), nil\n\tcase uint16:\n\t\treturn float64(s), nil\n\tcase uint8:\n\t\treturn float64(s), nil\n\tcase string:\n\t\tv, err := strconv.ParseFloat(s, 64)\n\t\tif err == nil {\n\t\t\treturn v, nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to float64\", i, i)\n\tcase float64EProvider:\n\t\tv, err := s.Float64()\n\t\tif err == nil {\n\t\t\treturn v, nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to float64\", i, i)\n\tcase float64Provider:\n\t\treturn s.Float64(), nil\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to float64\", i, i)\n\t}\n}\n\n// ToFloat32E casts an interface to a float32 type.\nfunc ToFloat32E(i interface{}) (float32, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\treturn float32(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase float64:\n\t\treturn float32(s), nil\n\tcase float32:\n\t\treturn s, nil\n\tcase int64:\n\t\treturn float32(s), nil\n\tcase int32:\n\t\treturn float32(s), nil\n\tcase int16:\n\t\treturn float32(s), nil\n\tcase int8:\n\t\treturn float32(s), nil\n\tcase uint:\n\t\treturn float32(s), nil\n\tcase uint64:\n\t\treturn float32(s), nil\n\tcase uint32:\n\t\treturn float32(s), nil\n\tcase uint16:\n\t\treturn float32(s), nil\n\tcase uint8:\n\t\treturn float32(s), nil\n\tcase string:\n\t\tv, err := strconv.ParseFloat(s, 32)\n\t\tif err == nil {\n\t\t\treturn float32(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to float32\", i, i)\n\tcase float64EProvider:\n\t\tv, err := s.Float64()\n\t\tif err == nil {\n\t\t\treturn float32(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to float32\", i, i)\n\tcase float64Provider:\n\t\treturn float32(s.Float64()), nil\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to float32\", i, i)\n\t}\n}\n\n// ToInt64E casts an interface to an int64 type.\nfunc ToInt64E(i interface{}) (int64, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\treturn int64(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase int64:\n\t\treturn s, nil\n\tcase int32:\n\t\treturn int64(s), nil\n\tcase int16:\n\t\treturn int64(s), nil\n\tcase int8:\n\t\treturn int64(s), nil\n\tcase uint:\n\t\treturn int64(s), nil\n\tcase uint64:\n\t\treturn int64(s), nil\n\tcase uint32:\n\t\treturn int64(s), nil\n\tcase uint16:\n\t\treturn int64(s), nil\n\tcase uint8:\n\t\treturn int64(s), nil\n\tcase float64:\n\t\treturn int64(s), nil\n\tcase float32:\n\t\treturn int64(s), nil\n\tcase string:\n\t\tv, err := strconv.ParseInt(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\treturn v, nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int64\", i, i)\n\tcase json.Number:\n\t\treturn ToInt64E(string(s))\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int64\", i, i)\n\t}\n}\n\n// ToInt32E casts an interface to an int32 type.\nfunc ToInt32E(i interface{}) (int32, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\treturn int32(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase int64:\n\t\treturn int32(s), nil\n\tcase int32:\n\t\treturn s, nil\n\tcase int16:\n\t\treturn int32(s), nil\n\tcase int8:\n\t\treturn int32(s), nil\n\tcase uint:\n\t\treturn int32(s), nil\n\tcase uint64:\n\t\treturn int32(s), nil\n\tcase uint32:\n\t\treturn int32(s), nil\n\tcase uint16:\n\t\treturn int32(s), nil\n\tcase uint8:\n\t\treturn int32(s), nil\n\tcase float64:\n\t\treturn int32(s), nil\n\tcase float32:\n\t\treturn int32(s), nil\n\tcase string:\n\t\tv, err := strconv.ParseInt(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\treturn int32(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int32\", i, i)\n\tcase json.Number:\n\t\treturn ToInt32E(string(s))\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int32\", i, i)\n\t}\n}\n\n// ToInt16E casts an interface to an int16 type.\nfunc ToInt16E(i interface{}) (int16, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\treturn int16(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase int64:\n\t\treturn int16(s), nil\n\tcase int32:\n\t\treturn int16(s), nil\n\tcase int16:\n\t\treturn s, nil\n\tcase int8:\n\t\treturn int16(s), nil\n\tcase uint:\n\t\treturn int16(s), nil\n\tcase uint64:\n\t\treturn int16(s), nil\n\tcase uint32:\n\t\treturn int16(s), nil\n\tcase uint16:\n\t\treturn int16(s), nil\n\tcase uint8:\n\t\treturn int16(s), nil\n\tcase float64:\n\t\treturn int16(s), nil\n\tcase float32:\n\t\treturn int16(s), nil\n\tcase string:\n\t\tv, err := strconv.ParseInt(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\treturn int16(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int16\", i, i)\n\tcase json.Number:\n\t\treturn ToInt16E(string(s))\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int16\", i, i)\n\t}\n}\n\n// ToInt8E casts an interface to an int8 type.\nfunc ToInt8E(i interface{}) (int8, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\treturn int8(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase int64:\n\t\treturn int8(s), nil\n\tcase int32:\n\t\treturn int8(s), nil\n\tcase int16:\n\t\treturn int8(s), nil\n\tcase int8:\n\t\treturn s, nil\n\tcase uint:\n\t\treturn int8(s), nil\n\tcase uint64:\n\t\treturn int8(s), nil\n\tcase uint32:\n\t\treturn int8(s), nil\n\tcase uint16:\n\t\treturn int8(s), nil\n\tcase uint8:\n\t\treturn int8(s), nil\n\tcase float64:\n\t\treturn int8(s), nil\n\tcase float32:\n\t\treturn int8(s), nil\n\tcase string:\n\t\tv, err := strconv.ParseInt(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\treturn int8(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int8\", i, i)\n\tcase json.Number:\n\t\treturn ToInt8E(string(s))\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int8\", i, i)\n\t}\n}\n\n// ToIntE casts an interface to an int type.\nfunc ToIntE(i interface{}) (int, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\treturn intv, nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase int64:\n\t\treturn int(s), nil\n\tcase int32:\n\t\treturn int(s), nil\n\tcase int16:\n\t\treturn int(s), nil\n\tcase int8:\n\t\treturn int(s), nil\n\tcase uint:\n\t\treturn int(s), nil\n\tcase uint64:\n\t\treturn int(s), nil\n\tcase uint32:\n\t\treturn int(s), nil\n\tcase uint16:\n\t\treturn int(s), nil\n\tcase uint8:\n\t\treturn int(s), nil\n\tcase float64:\n\t\treturn int(s), nil\n\tcase float32:\n\t\treturn int(s), nil\n\tcase string:\n\t\tv, err := strconv.ParseInt(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\treturn int(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int64\", i, i)\n\tcase json.Number:\n\t\treturn ToIntE(string(s))\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to int\", i, i)\n\t}\n}\n\n// ToUintE casts an interface to a uint type.\nfunc ToUintE(i interface{}) (uint, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\tif intv < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase string:\n\t\tv, err := strconv.ParseInt(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\tif v < 0 {\n\t\t\t\treturn 0, errNegativeNotAllowed\n\t\t\t}\n\t\t\treturn uint(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint\", i, i)\n\tcase json.Number:\n\t\treturn ToUintE(string(s))\n\tcase int64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint(s), nil\n\tcase int32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint(s), nil\n\tcase int16:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint(s), nil\n\tcase int8:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint(s), nil\n\tcase uint:\n\t\treturn s, nil\n\tcase uint64:\n\t\treturn uint(s), nil\n\tcase uint32:\n\t\treturn uint(s), nil\n\tcase uint16:\n\t\treturn uint(s), nil\n\tcase uint8:\n\t\treturn uint(s), nil\n\tcase float64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint(s), nil\n\tcase float32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint(s), nil\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint\", i, i)\n\t}\n}\n\n// ToUint64E casts an interface to a uint64 type.\nfunc ToUint64E(i interface{}) (uint64, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\tif intv < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint64(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase string:\n\t\tv, err := strconv.ParseUint(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\tif v < 0 {\n\t\t\t\treturn 0, errNegativeNotAllowed\n\t\t\t}\n\t\t\treturn v, nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint64\", i, i)\n\tcase json.Number:\n\t\treturn ToUint64E(string(s))\n\tcase int64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint64(s), nil\n\tcase int32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint64(s), nil\n\tcase int16:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint64(s), nil\n\tcase int8:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint64(s), nil\n\tcase uint:\n\t\treturn uint64(s), nil\n\tcase uint64:\n\t\treturn s, nil\n\tcase uint32:\n\t\treturn uint64(s), nil\n\tcase uint16:\n\t\treturn uint64(s), nil\n\tcase uint8:\n\t\treturn uint64(s), nil\n\tcase float32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint64(s), nil\n\tcase float64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint64(s), nil\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint64\", i, i)\n\t}\n}\n\n// ToUint32E casts an interface to a uint32 type.\nfunc ToUint32E(i interface{}) (uint32, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\tif intv < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint32(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase string:\n\t\tv, err := strconv.ParseInt(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\tif v < 0 {\n\t\t\t\treturn 0, errNegativeNotAllowed\n\t\t\t}\n\t\t\treturn uint32(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint32\", i, i)\n\tcase json.Number:\n\t\treturn ToUint32E(string(s))\n\tcase int64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint32(s), nil\n\tcase int32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint32(s), nil\n\tcase int16:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint32(s), nil\n\tcase int8:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint32(s), nil\n\tcase uint:\n\t\treturn uint32(s), nil\n\tcase uint64:\n\t\treturn uint32(s), nil\n\tcase uint32:\n\t\treturn s, nil\n\tcase uint16:\n\t\treturn uint32(s), nil\n\tcase uint8:\n\t\treturn uint32(s), nil\n\tcase float64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint32(s), nil\n\tcase float32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint32(s), nil\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint32\", i, i)\n\t}\n}\n\n// ToUint16E casts an interface to a uint16 type.\nfunc ToUint16E(i interface{}) (uint16, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\tif intv < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint16(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase string:\n\t\tv, err := strconv.ParseInt(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\tif v < 0 {\n\t\t\t\treturn 0, errNegativeNotAllowed\n\t\t\t}\n\t\t\treturn uint16(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint16\", i, i)\n\tcase json.Number:\n\t\treturn ToUint16E(string(s))\n\tcase int64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint16(s), nil\n\tcase int32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint16(s), nil\n\tcase int16:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint16(s), nil\n\tcase int8:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint16(s), nil\n\tcase uint:\n\t\treturn uint16(s), nil\n\tcase uint64:\n\t\treturn uint16(s), nil\n\tcase uint32:\n\t\treturn uint16(s), nil\n\tcase uint16:\n\t\treturn s, nil\n\tcase uint8:\n\t\treturn uint16(s), nil\n\tcase float64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint16(s), nil\n\tcase float32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint16(s), nil\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint16\", i, i)\n\t}\n}\n\n// ToUint8E casts an interface to a uint type.\nfunc ToUint8E(i interface{}) (uint8, error) {\n\ti = indirect(i)\n\n\tintv, ok := toInt(i)\n\tif ok {\n\t\tif intv < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint8(intv), nil\n\t}\n\n\tswitch s := i.(type) {\n\tcase string:\n\t\tv, err := strconv.ParseInt(trimZeroDecimal(s), 0, 0)\n\t\tif err == nil {\n\t\t\tif v < 0 {\n\t\t\t\treturn 0, errNegativeNotAllowed\n\t\t\t}\n\t\t\treturn uint8(v), nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint8\", i, i)\n\tcase json.Number:\n\t\treturn ToUint8E(string(s))\n\tcase int64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint8(s), nil\n\tcase int32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint8(s), nil\n\tcase int16:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint8(s), nil\n\tcase int8:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint8(s), nil\n\tcase uint:\n\t\treturn uint8(s), nil\n\tcase uint64:\n\t\treturn uint8(s), nil\n\tcase uint32:\n\t\treturn uint8(s), nil\n\tcase uint16:\n\t\treturn uint8(s), nil\n\tcase uint8:\n\t\treturn s, nil\n\tcase float64:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint8(s), nil\n\tcase float32:\n\t\tif s < 0 {\n\t\t\treturn 0, errNegativeNotAllowed\n\t\t}\n\t\treturn uint8(s), nil\n\tcase bool:\n\t\tif s {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn 0, nil\n\tcase nil:\n\t\treturn 0, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unable to cast %#v of type %T to uint8\", i, i)\n\t}\n}\n\n// From html/template/content.go\n// Copyright 2011 The Go Authors. All rights reserved.\n// indirect returns the value, after dereferencing as many times\n// as necessary to reach the base type (or nil).\nfunc indirect(a interface{}) interface{} {\n\tif a == nil {\n\t\treturn nil\n\t}\n\tif t := reflect.TypeOf(a); t.Kind() != reflect.Ptr {\n\t\t// Avoid creating a reflect.Value if it's not a pointer.\n\t\treturn a\n\t}\n\tv := reflect.ValueOf(a)\n\tfor v.Kind() == reflect.Ptr && !v.IsNil() {\n\t\tv = v.Elem()\n\t}\n\treturn v.Interface()\n}\n\n// From html/template/content.go\n// Copyright 2011 The Go Authors. All rights reserved.\n// indirectToStringerOrError returns the value, after dereferencing as many times\n// as necessary to reach the base type (or nil) or an implementation of fmt.Stringer\n// or error,\nfunc indirectToStringerOrError(a interface{}) interface{} {\n\tif a == nil {\n\t\treturn nil\n\t}\n\n\terrorType := reflect.TypeOf((*error)(nil)).Elem()\n\tfmtStringerType := reflect.TypeOf((*fmt.Stringer)(nil)).Elem()\n\n\tv := reflect.ValueOf(a)\n\tfor !v.Type().Implements(fmtStringerType) && !v.Type().Implements(errorType) && v.Kind() == reflect.Ptr && !v.IsNil() {\n\t\tv = v.Elem()\n\t}\n\treturn v.Interface()\n}\n\n// ToStringE casts an interface to a string type.\nfunc ToStringE(i interface{}) (string, error) {\n\ti = indirectToStringerOrError(i)\n\n\tswitch s := i.(type) {\n\tcase string:\n\t\treturn s, nil\n\tcase bool:\n\t\treturn strconv.FormatBool(s), nil\n\tcase float64:\n\t\treturn strconv.FormatFloat(s, 'f', -1, 64), nil\n\tcase float32:\n\t\treturn strconv.FormatFloat(float64(s), 'f', -1, 32), nil\n\tcase int:\n\t\treturn strconv.Itoa(s), nil\n\tcase int64:\n\t\treturn strconv.FormatInt(s, 10), nil\n\tcase int32:\n\t\treturn strconv.Itoa(int(s)), nil\n\tcase int16:\n\t\treturn strconv.FormatInt(int64(s), 10), nil\n\tcase int8:\n\t\treturn strconv.FormatInt(int64(s), 10), nil\n\tcase uint:\n\t\treturn strconv.FormatUint(uint64(s), 10), nil\n\tcase uint64:\n\t\treturn strconv.FormatUint(uint64(s), 10), nil\n\tcase uint32:\n\t\treturn strconv.FormatUint(uint64(s), 10), nil\n\tcase uint16:\n\t\treturn strconv.FormatUint(uint64(s), 10), nil\n\tcase uint8:\n\t\treturn strconv.FormatUint(uint64(s), 10), nil\n\tcase json.Number:\n\t\treturn s.String(), nil\n\tcase []byte:\n\t\treturn string(s), nil\n\tcase template.HTML:\n\t\treturn string(s), nil\n\tcase template.URL:\n\t\treturn string(s), nil\n\tcase template.JS:\n\t\treturn string(s), nil\n\tcase template.CSS:\n\t\treturn string(s), nil\n\tcase template.HTMLAttr:\n\t\treturn string(s), nil\n\tcase nil:\n\t\treturn \"\", nil\n\tcase fmt.Stringer:\n\t\treturn s.String(), nil\n\tcase error:\n\t\treturn s.Error(), nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unable to cast %#v of type %T to string\", i, i)\n\t}\n}\n\n// ToStringMapStringE casts an interface to a map[string]string type.\nfunc ToStringMapStringE(i interface{}) (map[string]string, error) {\n\tm := map[string]string{}\n\n\tswitch v := i.(type) {\n\tcase map[string]string:\n\t\treturn v, nil\n\tcase map[string]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToString(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[interface{}]string:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToString(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[interface{}]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToString(val)\n\t\t}\n\t\treturn m, nil\n\tcase string:\n\t\terr := jsonStringToObject(v, &m)\n\t\treturn m, err\n\tdefault:\n\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]string\", i, i)\n\t}\n}\n\n// ToStringMapStringSliceE casts an interface to a map[string][]string type.\nfunc ToStringMapStringSliceE(i interface{}) (map[string][]string, error) {\n\tm := map[string][]string{}\n\n\tswitch v := i.(type) {\n\tcase map[string][]string:\n\t\treturn v, nil\n\tcase map[string][]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToStringSlice(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[string]string:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = []string{val}\n\t\t}\n\tcase map[string]interface{}:\n\t\tfor k, val := range v {\n\t\t\tswitch vt := val.(type) {\n\t\t\tcase []interface{}:\n\t\t\t\tm[ToString(k)] = ToStringSlice(vt)\n\t\t\tcase []string:\n\t\t\t\tm[ToString(k)] = vt\n\t\t\tdefault:\n\t\t\t\tm[ToString(k)] = []string{ToString(val)}\n\t\t\t}\n\t\t}\n\t\treturn m, nil\n\tcase map[interface{}][]string:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToStringSlice(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[interface{}]string:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToStringSlice(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[interface{}][]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToStringSlice(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[interface{}]interface{}:\n\t\tfor k, val := range v {\n\t\t\tkey, err := ToStringE(k)\n\t\t\tif err != nil {\n\t\t\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string][]string\", i, i)\n\t\t\t}\n\t\t\tvalue, err := ToStringSliceE(val)\n\t\t\tif err != nil {\n\t\t\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string][]string\", i, i)\n\t\t\t}\n\t\t\tm[key] = value\n\t\t}\n\tcase string:\n\t\terr := jsonStringToObject(v, &m)\n\t\treturn m, err\n\tdefault:\n\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string][]string\", i, i)\n\t}\n\treturn m, nil\n}\n\n// ToStringMapBoolE casts an interface to a map[string]bool type.\nfunc ToStringMapBoolE(i interface{}) (map[string]bool, error) {\n\tm := map[string]bool{}\n\n\tswitch v := i.(type) {\n\tcase map[interface{}]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToBool(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[string]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToBool(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[string]bool:\n\t\treturn v, nil\n\tcase string:\n\t\terr := jsonStringToObject(v, &m)\n\t\treturn m, err\n\tdefault:\n\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]bool\", i, i)\n\t}\n}\n\n// ToStringMapE casts an interface to a map[string]interface{} type.\nfunc ToStringMapE(i interface{}) (map[string]interface{}, error) {\n\tm := map[string]interface{}{}\n\n\tswitch v := i.(type) {\n\tcase map[interface{}]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = val\n\t\t}\n\t\treturn m, nil\n\tcase map[string]interface{}:\n\t\treturn v, nil\n\tcase string:\n\t\terr := jsonStringToObject(v, &m)\n\t\treturn m, err\n\tdefault:\n\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]interface{}\", i, i)\n\t}\n}\n\n// ToStringMapIntE casts an interface to a map[string]int{} type.\nfunc ToStringMapIntE(i interface{}) (map[string]int, error) {\n\tm := map[string]int{}\n\tif i == nil {\n\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]int\", i, i)\n\t}\n\n\tswitch v := i.(type) {\n\tcase map[interface{}]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToInt(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[string]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[k] = ToInt(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[string]int:\n\t\treturn v, nil\n\tcase string:\n\t\terr := jsonStringToObject(v, &m)\n\t\treturn m, err\n\t}\n\n\tif reflect.TypeOf(i).Kind() != reflect.Map {\n\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]int\", i, i)\n\t}\n\n\tmVal := reflect.ValueOf(m)\n\tv := reflect.ValueOf(i)\n\tfor _, keyVal := range v.MapKeys() {\n\t\tval, err := ToIntE(v.MapIndex(keyVal).Interface())\n\t\tif err != nil {\n\t\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]int\", i, i)\n\t\t}\n\t\tmVal.SetMapIndex(keyVal, reflect.ValueOf(val))\n\t}\n\treturn m, nil\n}\n\n// ToStringMapInt64E casts an interface to a map[string]int64{} type.\nfunc ToStringMapInt64E(i interface{}) (map[string]int64, error) {\n\tm := map[string]int64{}\n\tif i == nil {\n\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]int64\", i, i)\n\t}\n\n\tswitch v := i.(type) {\n\tcase map[interface{}]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[ToString(k)] = ToInt64(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[string]interface{}:\n\t\tfor k, val := range v {\n\t\t\tm[k] = ToInt64(val)\n\t\t}\n\t\treturn m, nil\n\tcase map[string]int64:\n\t\treturn v, nil\n\tcase string:\n\t\terr := jsonStringToObject(v, &m)\n\t\treturn m, err\n\t}\n\n\tif reflect.TypeOf(i).Kind() != reflect.Map {\n\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]int64\", i, i)\n\t}\n\tmVal := reflect.ValueOf(m)\n\tv := reflect.ValueOf(i)\n\tfor _, keyVal := range v.MapKeys() {\n\t\tval, err := ToInt64E(v.MapIndex(keyVal).Interface())\n\t\tif err != nil {\n\t\t\treturn m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]int64\", i, i)\n\t\t}\n\t\tmVal.SetMapIndex(keyVal, reflect.ValueOf(val))\n\t}\n\treturn m, nil\n}\n\n// ToSliceE casts an interface to a []interface{} type.\nfunc ToSliceE(i interface{}) ([]interface{}, error) {\n\tvar s []interface{}\n\n\tswitch v := i.(type) {\n\tcase []interface{}:\n\t\treturn append(s, v...), nil\n\tcase []map[string]interface{}:\n\t\tfor _, u := range v {\n\t\t\ts = append(s, u)\n\t\t}\n\t\treturn s, nil\n\tdefault:\n\t\treturn s, fmt.Errorf(\"unable to cast %#v of type %T to []interface{}\", i, i)\n\t}\n}\n\n// ToBoolSliceE casts an interface to a []bool type.\nfunc ToBoolSliceE(i interface{}) ([]bool, error) {\n\tif i == nil {\n\t\treturn []bool{}, fmt.Errorf(\"unable to cast %#v of type %T to []bool\", i, i)\n\t}\n\n\tswitch v := i.(type) {\n\tcase []bool:\n\t\treturn v, nil\n\t}\n\n\tkind := reflect.TypeOf(i).Kind()\n\tswitch kind {\n\tcase reflect.Slice, reflect.Array:\n\t\ts := reflect.ValueOf(i)\n\t\ta := make([]bool, s.Len())\n\t\tfor j := 0; j < s.Len(); j++ {\n\t\t\tval, err := ToBoolE(s.Index(j).Interface())\n\t\t\tif err != nil {\n\t\t\t\treturn []bool{}, fmt.Errorf(\"unable to cast %#v of type %T to []bool\", i, i)\n\t\t\t}\n\t\t\ta[j] = val\n\t\t}\n\t\treturn a, nil\n\tdefault:\n\t\treturn []bool{}, fmt.Errorf(\"unable to cast %#v of type %T to []bool\", i, i)\n\t}\n}\n\n// ToStringSliceE casts an interface to a []string type.\nfunc ToStringSliceE(i interface{}) ([]string, error) {\n\tvar a []string\n\n\tswitch v := i.(type) {\n\tcase []interface{}:\n\t\tfor _, u := range v {\n\t\t\ta = append(a, ToString(u))\n\t\t}\n\t\treturn a, nil\n\tcase []string:\n\t\treturn v, nil\n\tcase []int8:\n\t\tfor _, u := range v {\n\t\t\ta = append(a, ToString(u))\n\t\t}\n\t\treturn a, nil\n\tcase []int:\n\t\tfor _, u := range v {\n\t\t\ta = append(a, ToString(u))\n\t\t}\n\t\treturn a, nil\n\tcase []int32:\n\t\tfor _, u := range v {\n\t\t\ta = append(a, ToString(u))\n\t\t}\n\t\treturn a, nil\n\tcase []int64:\n\t\tfor _, u := range v {\n\t\t\ta = append(a, ToString(u))\n\t\t}\n\t\treturn a, nil\n\tcase []float32:\n\t\tfor _, u := range v {\n\t\t\ta = append(a, ToString(u))\n\t\t}\n\t\treturn a, nil\n\tcase []float64:\n\t\tfor _, u := range v {\n\t\t\ta = append(a, ToString(u))\n\t\t}\n\t\treturn a, nil\n\tcase string:\n\t\treturn strings.Fields(v), nil\n\tcase []error:\n\t\tfor _, err := range i.([]error) {\n\t\t\ta = append(a, err.Error())\n\t\t}\n\t\treturn a, nil\n\tcase interface{}:\n\t\tstr, err := ToStringE(v)\n\t\tif err != nil {\n\t\t\treturn a, fmt.Errorf(\"unable to cast %#v of type %T to []string\", i, i)\n\t\t}\n\t\treturn []string{str}, nil\n\tdefault:\n\t\treturn a, fmt.Errorf(\"unable to cast %#v of type %T to []string\", i, i)\n\t}\n}\n\n// ToIntSliceE casts an interface to a []int type.\nfunc ToIntSliceE(i interface{}) ([]int, error) {\n\tif i == nil {\n\t\treturn []int{}, fmt.Errorf(\"unable to cast %#v of type %T to []int\", i, i)\n\t}\n\n\tswitch v := i.(type) {\n\tcase []int:\n\t\treturn v, nil\n\t}\n\n\tkind := reflect.TypeOf(i).Kind()\n\tswitch kind {\n\tcase reflect.Slice, reflect.Array:\n\t\ts := reflect.ValueOf(i)\n\t\ta := make([]int, s.Len())\n\t\tfor j := 0; j < s.Len(); j++ {\n\t\t\tval, err := ToIntE(s.Index(j).Interface())\n\t\t\tif err != nil {\n\t\t\t\treturn []int{}, fmt.Errorf(\"unable to cast %#v of type %T to []int\", i, i)\n\t\t\t}\n\t\t\ta[j] = val\n\t\t}\n\t\treturn a, nil\n\tdefault:\n\t\treturn []int{}, fmt.Errorf(\"unable to cast %#v of type %T to []int\", i, i)\n\t}\n}\n\n// ToDurationSliceE casts an interface to a []time.Duration type.\nfunc ToDurationSliceE(i interface{}) ([]time.Duration, error) {\n\tif i == nil {\n\t\treturn []time.Duration{}, fmt.Errorf(\"unable to cast %#v of type %T to []time.Duration\", i, i)\n\t}\n\n\tswitch v := i.(type) {\n\tcase []time.Duration:\n\t\treturn v, nil\n\t}\n\n\tkind := reflect.TypeOf(i).Kind()\n\tswitch kind {\n\tcase reflect.Slice, reflect.Array:\n\t\ts := reflect.ValueOf(i)\n\t\ta := make([]time.Duration, s.Len())\n\t\tfor j := 0; j < s.Len(); j++ {\n\t\t\tval, err := ToDurationE(s.Index(j).Interface())\n\t\t\tif err != nil {\n\t\t\t\treturn []time.Duration{}, fmt.Errorf(\"unable to cast %#v of type %T to []time.Duration\", i, i)\n\t\t\t}\n\t\t\ta[j] = val\n\t\t}\n\t\treturn a, nil\n\tdefault:\n\t\treturn []time.Duration{}, fmt.Errorf(\"unable to cast %#v of type %T to []time.Duration\", i, i)\n\t}\n}\n\n// StringToDate attempts to parse a string into a time.Time type using a\n// predefined list of formats.  If no suitable format is found, an error is\n// returned.\nfunc StringToDate(s string) (time.Time, error) {\n\treturn parseDateWith(s, time.UTC, timeFormats)\n}\n\n// StringToDateInDefaultLocation casts an empty interface to a time.Time,\n// interpreting inputs without a timezone to be in the given location,\n// or the local timezone if nil.\nfunc StringToDateInDefaultLocation(s string, location *time.Location) (time.Time, error) {\n\treturn parseDateWith(s, location, timeFormats)\n}\n\ntype timeFormatType int\n\nconst (\n\ttimeFormatNoTimezone timeFormatType = iota\n\ttimeFormatNamedTimezone\n\ttimeFormatNumericTimezone\n\ttimeFormatNumericAndNamedTimezone\n\ttimeFormatTimeOnly\n)\n\ntype timeFormat struct {\n\tformat string\n\ttyp    timeFormatType\n}\n\nfunc (f timeFormat) hasTimezone() bool {\n\t// We don't include the formats with only named timezones, see\n\t// https://github.com/golang/go/issues/19694#issuecomment-289103522\n\treturn f.typ >= timeFormatNumericTimezone && f.typ <= timeFormatNumericAndNamedTimezone\n}\n\nvar timeFormats = []timeFormat{\n\t// Keep common formats at the top.\n\t{\"2006-01-02\", timeFormatNoTimezone},\n\t{time.RFC3339, timeFormatNumericTimezone},\n\t{\"2006-01-02T15:04:05\", timeFormatNoTimezone}, // iso8601 without timezone\n\t{time.RFC1123Z, timeFormatNumericTimezone},\n\t{time.RFC1123, timeFormatNamedTimezone},\n\t{time.RFC822Z, timeFormatNumericTimezone},\n\t{time.RFC822, timeFormatNamedTimezone},\n\t{time.RFC850, timeFormatNamedTimezone},\n\t{\"2006-01-02 15:04:05.999999999 -0700 MST\", timeFormatNumericAndNamedTimezone}, // Time.String()\n\t{\"2006-01-02T15:04:05-0700\", timeFormatNumericTimezone},                        // RFC3339 without timezone hh:mm colon\n\t{\"2006-01-02 15:04:05Z0700\", timeFormatNumericTimezone},                        // RFC3339 without T or timezone hh:mm colon\n\t{\"2006-01-02 15:04:05\", timeFormatNoTimezone},\n\t{time.ANSIC, timeFormatNoTimezone},\n\t{time.UnixDate, timeFormatNamedTimezone},\n\t{time.RubyDate, timeFormatNumericTimezone},\n\t{\"2006-01-02 15:04:05Z07:00\", timeFormatNumericTimezone},\n\t{\"02 Jan 2006\", timeFormatNoTimezone},\n\t{\"2006-01-02 15:04:05 -07:00\", timeFormatNumericTimezone},\n\t{\"2006-01-02 15:04:05 -0700\", timeFormatNumericTimezone},\n\t{time.Kitchen, timeFormatTimeOnly},\n\t{time.Stamp, timeFormatTimeOnly},\n\t{time.StampMilli, timeFormatTimeOnly},\n\t{time.StampMicro, timeFormatTimeOnly},\n\t{time.StampNano, timeFormatTimeOnly},\n}\n\nfunc parseDateWith(s string, location *time.Location, formats []timeFormat) (d time.Time, e error) {\n\tfor _, format := range formats {\n\t\tif d, e = time.Parse(format.format, s); e == nil {\n\n\t\t\t// Some time formats have a zone name, but no offset, so it gets\n\t\t\t// put in that zone name (not the default one passed in to us), but\n\t\t\t// without that zone's offset. So set the location manually.\n\t\t\tif format.typ <= timeFormatNamedTimezone {\n\t\t\t\tif location == nil {\n\t\t\t\t\tlocation = time.Local\n\t\t\t\t}\n\t\t\t\tyear, month, day := d.Date()\n\t\t\t\thour, min, sec := d.Clock()\n\t\t\t\td = time.Date(year, month, day, hour, min, sec, d.Nanosecond(), location)\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\t}\n\treturn d, fmt.Errorf(\"unable to parse date: %s\", s)\n}\n\n// jsonStringToObject attempts to unmarshall a string as JSON into\n// the object passed as pointer.\nfunc jsonStringToObject(s string, v interface{}) error {\n\tdata := []byte(s)\n\treturn json.Unmarshal(data, v)\n}\n\n// toInt returns the int value of v if v or v's underlying type\n// is an int.\n// Note that this will return false for int64 etc. types.\nfunc toInt(v interface{}) (int, bool) {\n\tswitch v := v.(type) {\n\tcase int:\n\t\treturn v, true\n\tcase time.Weekday:\n\t\treturn int(v), true\n\tcase time.Month:\n\t\treturn int(v), true\n\tdefault:\n\t\treturn 0, false\n\t}\n}\n\nfunc trimZeroDecimal(s string) string {\n\tvar foundZero bool\n\tfor i := len(s); i > 0; i-- {\n\t\tswitch s[i-1] {\n\t\tcase '.':\n\t\t\tif foundZero {\n\t\t\t\treturn s[:i-1]\n\t\t\t}\n\t\tcase '0':\n\t\t\tfoundZero = true\n\t\tdefault:\n\t\t\treturn s\n\t\t}\n\t}\n\treturn s\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2685546875,
          "content": "module github.com/spf13/cast\n\ngo 1.19\n\nrequire github.com/frankban/quicktest v1.14.6\n\nrequire (\n\tgithub.com/google/go-cmp v0.5.9 // indirect\n\tgithub.com/kr/pretty v0.3.1 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgithub.com/rogpeppe/go-internal v1.9.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.0107421875,
          "content": "github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=\ngithub.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\n"
        },
        {
          "name": "timeformattype_string.go",
          "type": "blob",
          "size": 0.912109375,
          "content": "// Code generated by \"stringer -type timeFormatType\"; DO NOT EDIT.\n\npackage cast\n\nimport \"strconv\"\n\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[timeFormatNoTimezone-0]\n\t_ = x[timeFormatNamedTimezone-1]\n\t_ = x[timeFormatNumericTimezone-2]\n\t_ = x[timeFormatNumericAndNamedTimezone-3]\n\t_ = x[timeFormatTimeOnly-4]\n}\n\nconst _timeFormatType_name = \"timeFormatNoTimezonetimeFormatNamedTimezonetimeFormatNumericTimezonetimeFormatNumericAndNamedTimezonetimeFormatTimeOnly\"\n\nvar _timeFormatType_index = [...]uint8{0, 20, 43, 68, 101, 119}\n\nfunc (i timeFormatType) String() string {\n\tif i < 0 || i >= timeFormatType(len(_timeFormatType_index)-1) {\n\t\treturn \"timeFormatType(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _timeFormatType_name[_timeFormatType_index[i]:_timeFormatType_index[i+1]]\n}\n"
        }
      ]
    }
  ]
}