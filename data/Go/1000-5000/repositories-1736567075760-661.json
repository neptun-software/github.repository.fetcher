{
  "metadata": {
    "timestamp": 1736567075760,
    "page": 661,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "git-chglog/git-chglog",
      "stars": 2731,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".chglog",
          "type": "tree",
          "content": null
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2216796875,
          "content": "root = true\n\n[*]\ncharset = utf-8\nindent_size = 2\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[*.md]\ninsert_final_newline = false\ntrim_trailing_whitespace = false\n\n[Makefile]\nindent_style = tab\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.1064453125,
          "content": "/tmp\n/.tmp\n/dist\n\n# Created by https://www.gitignore.io/api/osx,macos,go\n\n### Go ###\n# Binaries for programs and plugins\n*.exe\n*.dll\n*.so\n*.dylib\n/git-chglog\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n.glide/\n\n# in https://github.com/git-chglog/git-chglog/pull/85 we moved from dep to gomod\nvendor\n\n### macOS ###\n*.DS_Store\n.AppleDouble\n.LSOverride\n\n# Icon must end with two \\r\nIcon\n\n# Thumbnails\n._*\n\n# Intellij IDEA\n*.iml\n.idea\n\n# vscode IDE\n.vscode\n\n# Files that might appear in the root of a volume\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n.com.apple.timemachine.donotpresent\n\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n\n### OSX ###\n\n# Icon must end with two \\r\n\n# Thumbnails\n\n# Files that might appear in the root of a volume\n\n# Directories potentially created on remote AFP share\n\n\n# End of https://www.gitignore.io/api/osx,macos,go\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 4.7109375,
          "content": "# https://golangci-lint.run/usage/configuration/\nrun:\n  timeout: 10m\n  deadline: 5m\n\n  tests: true\n\noutput:\n  format: tab\n\nlinters-settings:\n  govet:\n    # report about shadowed variables\n    check-shadowing: true\n\n  golint:\n    # minimal confidence for issues, default is 0.8\n    min-confidence: 0.8\n\n  gofmt:\n    # simplify code: gofmt with `-s` option, true by default\n    simplify: true\n\n  goimports:\n    # put imports beginning with prefix after 3rd-party packages;\n    # it's a comma-separated list of prefixes\n    local-prefixes: github.com/git-chglog/git-chglog\n\n  gocyclo:\n    # minimal code complexity to report, 30 by default (but we recommend 10-20)\n    min-complexity: 10\n\n  maligned:\n    # print struct with more effective memory layout or not, false by default\n    suggest-new: true\n\n  dupl:\n    # tokens count to trigger issue, 150 by default\n    threshold: 100\n\n  goconst:\n    # minimal length of string constant, 3 by default\n    min-len: 3\n    # minimal occurrences count to trigger, 3 by default\n    min-occurrences: 5\n\n  lll:\n    # tab width in spaces. Default to 1.\n    tab-width: 1\n\n  unused:\n    # treat code as a program (not a library) and report unused exported identifiers; default is false.\n    # XXX: if you enable this setting, unused will report a lot of false-positives in text editors:\n    # if it's called for subdir of a project it can't find funcs usages. All text editor integrations\n    # with golangci-lint call it on a directory with the changed file.\n    check-exported: false\n\n  unparam:\n    # Inspect exported functions, default is false. Set to true if no external program/library imports your code.\n    # XXX: if you enable this setting, unparam will report a lot of false-positives in text editors:\n    # if it's called for subdir of a project it can't find external interfaces. All text editor integrations\n    # with golangci-lint call it on a directory with the changed file.\n    check-exported: false\n\n  nakedret:\n    # make an issue if func has more lines of code than this setting and it has naked returns; default is 30\n    max-func-lines: 30\n\n  prealloc:\n    # XXX: we don't recommend using this linter before doing performance profiling.\n    # For most programs usage of prealloc will be a premature optimization.\n\n    # Report preallocation suggestions only on simple loops that have no returns/breaks/continues/gotos in them.\n    # True by default.\n    simple: true\n    range-loops: true # Report preallocation suggestions on range loops, true by default\n    for-loops: false # Report preallocation suggestions on for loops, false by default\n\n  gocritic:\n    # Enable multiple checks by tags, run `GL_DEBUG=gocritic golangci-lint` run to see all tags and checks.\n    # Empty list by default. See https://github.com/go-critic/go-critic#usage -> section \"Tags\".\n    enabled-tags:\n      - performance\n\n    settings: # settings passed to gocritic\n      captLocal: # must be valid enabled check name\n        paramsOnly: true\n      rangeValCopy:\n        sizeThreshold: 32\n\n  misspell:\n    locale: US\n\nlinters:\n  enable:\n    - megacheck\n    - govet\n    - gocyclo\n    - gocritic\n    - interfacer\n    - goconst\n    - goimports\n    - gofmt  # We enable this as well as goimports for its simplify mode.\n    - prealloc\n    - golint\n    - unconvert\n    - misspell\n    - nakedret\n    - dupl\n    - depguard\n\n  presets:\n    - bugs\n    - unused\n  fast: false\n\nissues:\n  # Excluding configuration per-path and per-linter\n  exclude-rules:\n    # Exclude some linters from running on tests files.\n    - path: _test(ing)?\\.go\n      linters:\n        - gocyclo\n        - errcheck\n        - dupl\n        - gosec\n        - scopelint\n        - unparam\n\n    # These are performance optimisations rather than style issues per se.\n    # They warn when function arguments or range values copy a lot of memory\n    # rather than using a pointer.\n    - text: \"(hugeParam|rangeValCopy):\"\n      linters:\n      - gocritic\n\n  # Independently from option `exclude` we use default exclude patterns,\n  # it can be disabled by this option. To list all\n  # excluded by default patterns execute `golangci-lint run --help`.\n  # Default value for this option is true.\n  exclude-use-default: false\n\n  # Show only new issues: if there are unstaged changes or untracked files,\n  # only those changes are analyzed, else only changes in HEAD~ are analyzed.\n  # It's a super-useful option for integration of golangci-lint into existing\n  # large codebase. It's not practical to fix all existing issues at the moment\n  # of integration: much better don't allow issues in new code.\n  # Default is false.\n  new: false\n\n  # Maximum issues count per one linter. Set to 0 to disable. Default is 50.\n  max-per-linter: 0\n\n  # Maximum count of issues with the same text. Set to 0 to disable. Default is 3.\n  max-same-issues: 0\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 1.080078125,
          "content": "# This is an example .goreleaser.yml file with some sane defaults.\n# Make sure to check the documentation at http://goreleaser.com\nproject_name: git-chglog\n\nbefore:\n  hooks:\n    # You may remove this if you don't use go modules.\n    - go mod download\n\nbuilds:\n  - dir: cmd/git-chglog\n    env:\n      - CGO_ENABLED=0\n    goos:\n      - linux\n      - windows\n      - darwin\n    goarch:\n      - 386\n      - amd64\n      - arm\n      - arm64\n\narchives:\n  - format_overrides:\n      - goos: windows\n        format: zip\n\nchecksum:\n  name_template: \"checksums.txt\"\n\nchangelog:\n  sort: desc\n  filters:\n    exclude:\n      - \"^Merge\"\n\nsnapshot:\n  name_template: \"{{ .Tag }}-next\"\n\ndockers:\n  - image_templates:\n      - \"quay.io/git-chglog/git-chglog:{{ .RawVersion }}\"\n      - \"quay.io/git-chglog/git-chglog:latest\"\n\nbrews:\n  - tap:\n      owner: git-chglog\n      name: homebrew-git-chglog\n    homepage: \"https://godoc.org/github.com/git-chglog/git-chglog\"\n    description: \"CHANGELOG generator implemented in Go (Golang).\"\n    test: |\n      system \"#{bin}/git-chglog --help\"\n    install: |\n      bin.install \"git-chglog\"\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 17.5771484375,
          "content": "<a name=\"unreleased\"></a>\n## [Unreleased]\n\n\n<a name=\"v0.15.4\"></a>\n## [v0.15.4] - 2023-02-15\n### Bug Fixes\n- release process ([#231](https://github.com/git-chglog/git-chglog/issues/231))\n- **ci:** add integration test with docker image ([#226](https://github.com/git-chglog/git-chglog/issues/226))\n- **deps:** update module github.com/urfave/cli/v2 to v2.24.3 ([#227](https://github.com/git-chglog/git-chglog/issues/227))\n- **deps:** update module github.com/fatih/color to v1.14.1 ([#224](https://github.com/git-chglog/git-chglog/issues/224))\n- **deps:** update all non-major dependencies ([#223](https://github.com/git-chglog/git-chglog/issues/223))\n\n### Chores\n- new release due to shecksum mismatch. Closes [#232](https://github.com/git-chglog/git-chglog/issues/232)\n- update changelog for v0.15.3\n- update changelog for v0.15.3\n- bump docker/login-action to v2. Closes [#206](https://github.com/git-chglog/git-chglog/issues/206)\n- bump goreleaser/goreleaser-action to v4. Closes [#208](https://github.com/git-chglog/git-chglog/issues/208)\n\n\n<a name=\"v0.15.2\"></a>\n## [v0.15.2] - 2023-01-22\n### Bug Fixes\n- typo in readme ([#196](https://github.com/git-chglog/git-chglog/issues/196))\n- **deps:** update module gopkg.in/yaml.v2 to v3 ([#221](https://github.com/git-chglog/git-chglog/issues/221))\n\n### Chores\n- update changelog for v0.15.2\n- update changelog for v0.15.2\n- update Go install instructions ([#205](https://github.com/git-chglog/git-chglog/issues/205))\n- bump golang to 1.19 ([#218](https://github.com/git-chglog/git-chglog/issues/218))\n- **deps:** update all non-major dependencies ([#220](https://github.com/git-chglog/git-chglog/issues/220))\n\n\n<a name=\"v0.15.1\"></a>\n## [v0.15.1] - 2021-12-14\n### Bug Fixes\n- **deps:** update all non-major dependencies ([#179](https://github.com/git-chglog/git-chglog/issues/179))\n- **deps:** update module github.com/andygrunwald/go-jira to v1.14.0 ([#167](https://github.com/git-chglog/git-chglog/issues/167))\n- **deps:** update module github.com/alecaivazis/survey/v2 to v2.2.16 ([#165](https://github.com/git-chglog/git-chglog/issues/165))\n- **deps:** update module github.com/alecaivazis/survey/v2 to v2.2.15 ([#163](https://github.com/git-chglog/git-chglog/issues/163))\n\n### Chores\n- update changelog for v0.15.1\n- ignore .vscode\n- **deps:** update all non-major dependencies docker tags ([#168](https://github.com/git-chglog/git-chglog/issues/168))\n\n\n<a name=\"v0.15.0\"></a>\n## [v0.15.0] - 2021-07-09\n### Bug Fixes\n- **deps:** update module github.com/alecaivazis/survey/v2 to v2.2.14 ([#158](https://github.com/git-chglog/git-chglog/issues/158))\n- **deps:** update module github.com/alecaivazis/survey/v2 to v2.2.13 ([#156](https://github.com/git-chglog/git-chglog/issues/156))\n- **deps:** update module github.com/fatih/color to v1.12.0 ([#150](https://github.com/git-chglog/git-chglog/issues/150))\n- **deps:** update module github.com/fatih/color to v1.11.0 ([#149](https://github.com/git-chglog/git-chglog/issues/149))\n- **deps:** update module github.com/alecaivazis/survey/v2 to v2.2.12 ([#147](https://github.com/git-chglog/git-chglog/issues/147))\n\n### Chores\n- update changelog for v0.15.0\n- **deps:** update alpine docker tag to v3.14.0 ([#153](https://github.com/git-chglog/git-chglog/issues/153))\n\n### Features\n- Automatic link for gitlab merge requests ([#160](https://github.com/git-chglog/git-chglog/issues/160))\n\n\n<a name=\"v0.14.2\"></a>\n## [v0.14.2] - 2021-04-16\n### Bug Fixes\n- add CommitGroupTitleOrder back to Options ([#143](https://github.com/git-chglog/git-chglog/issues/143))\n\n### Chores\n- update changelog for v0.14.2\n- **deps:** update alpine docker tag to v3.13.5 ([#144](https://github.com/git-chglog/git-chglog/issues/144))\n\n\n<a name=\"v0.14.1\"></a>\n## [v0.14.1] - 2021-04-13\n### Bug Fixes\n- **template:** address regression in string functions for template engine ([#142](https://github.com/git-chglog/git-chglog/issues/142))\n\n### Chores\n- update changelog for v0.14.1\n- add docker target to Makefile ([#138](https://github.com/git-chglog/git-chglog/issues/138))\n- add make release target ([#130](https://github.com/git-chglog/git-chglog/issues/130))\n- **deps:** update alpine docker tag to v3.13.4 ([#136](https://github.com/git-chglog/git-chglog/issues/136))\n\n### Features\n- add docker image on release and master ([#135](https://github.com/git-chglog/git-chglog/issues/135))\n\n\n<a name=\"v0.14.0\"></a>\n## [v0.14.0] - 2021-03-28\n### Chores\n- update changelog for v0.14.0\n- **CHANGELOG:** regenerate CHANGELOG with type-scope and KAC template ([#129](https://github.com/git-chglog/git-chglog/issues/129))\n\n### Features\n- add sprig template functions support ([#131](https://github.com/git-chglog/git-chglog/issues/131))\n- add `--sort [TYPE]` flag  ([#78](https://github.com/git-chglog/git-chglog/issues/78))\n\n\n<a name=\"v0.13.0\"></a>\n## [v0.13.0] - 2021-03-23\n### Chores\n- update changelog for v0.13.0\n- use ldflags to pass version to build process ([#127](https://github.com/git-chglog/git-chglog/issues/127))\n\n### Features\n- add support for rendering .Body after .Subject as part of list ([#121](https://github.com/git-chglog/git-chglog/issues/121))\n\n\n<a name=\"v0.12.0\"></a>\n## [v0.12.0] - 2021-03-20\n### Chores\n- update changelog for v0.12.0\n- bumps version to v0.12.0\n- bump golang to 1.16 ([#118](https://github.com/git-chglog/git-chglog/issues/118))\n- **ci:** add golangci-lint action and apply linting changes ([#120](https://github.com/git-chglog/git-chglog/issues/120))\n\n### Features\n- allow tag sorting by semver ([#124](https://github.com/git-chglog/git-chglog/issues/124))\n\n### BREAKING CHANGE\n\n`JiraIssueId` has been renamed to `JiraIssueID`. This impacts the value for `pattern_maps` in `config.yml`.\n\n* chore(ci): add golangci-lint action\n\n* chore(lint): address errcheck lint failures\n\n* chore(lint): address misspell lint failures\n\n* chore(lint): address gocritic lint failures\n\n* chore(lint): address golint lint failures\n\n* chore(lint): address structcheck lint failures\n\n* chore(lint): address gosimple lint failures\n\n* chore(lint): address gofmt lint failures\n\n* chore(ci): port to official golangci-lint github action\n\n* Update golangci configuration for better coverage\n\n\n<a name=\"v0.11.2\"></a>\n## [v0.11.2] - 2021-03-13\n### Bug Fixes\n- `--template` and `--repository-url` flags not being used ([#119](https://github.com/git-chglog/git-chglog/issues/119))\n\n### Chores\n- update changelog for v0.11.2\n- bumps version to v0.11.2\n\n\n<a name=\"v0.11.1\"></a>\n## [v0.11.1] - 2021-03-12\n### Bug Fixes\n- **short flags:** correctly define cli flags with shorthands ([#117](https://github.com/git-chglog/git-chglog/issues/117))\n\n### Chores\n- update readme and changelog for v0.11.1\n- bumps version to v0.11.1\n\n\n<a name=\"v0.11.0\"></a>\n## [v0.11.0] - 2021-03-12\n### Bug Fixes\n- **deps:** update all non-major dependencies ([#115](https://github.com/git-chglog/git-chglog/issues/115))\n- **deps:** update module gopkg.in/kyokomi/emoji.v1 to github.com/kyokomi/emoji/v2 ([#109](https://github.com/git-chglog/git-chglog/issues/109))\n- **deps:** update module github.com/urfave/cli to v2 ([#107](https://github.com/git-chglog/git-chglog/issues/107))\n- **deps:** update module github.com/stretchr/testify to v1.7.0 ([#103](https://github.com/git-chglog/git-chglog/issues/103))\n- **deps:** update module gopkg.in/alecaivazis/survey.v1 to github.com/AlecAivazis/survey/v2 ([#108](https://github.com/git-chglog/git-chglog/issues/108))\n- **init:** support OptionAnswer form in survey/v2 ([#113](https://github.com/git-chglog/git-chglog/issues/113))\n\n### Chores\n- update changelog for v0.11.0\n- bumps version to v0.11.0\n- **deps:** add initial renovatebot configuration ([#102](https://github.com/git-chglog/git-chglog/issues/102))\n\n### Features\n- add Jira integration ([#52](https://github.com/git-chglog/git-chglog/issues/52))\n- **flag:** --path filtering - refs ([#62](https://github.com/git-chglog/git-chglog/issues/62)). Closes [#35](https://github.com/git-chglog/git-chglog/issues/35)\n\n\n<a name=\"v0.10.0\"></a>\n## [v0.10.0] - 2021-01-16\n### Bug Fixes\n- ignore only git-chglog binary in root and not subfolder\n\n### Chores\n- update changelog for v0.10.0\n- bumps version to v0.10.0\n- sorts changelog desc and excludes Merge commits\n- fix Makefile typo ([#82](https://github.com/git-chglog/git-chglog/issues/82))\n- **asdf:** add asdf install support to README ([#79](https://github.com/git-chglog/git-chglog/issues/79))\n\n### Features\n- Adds 'Custom' sort_type to CommitGroup ([#69](https://github.com/git-chglog/git-chglog/issues/69))\n- enable tag_filter_pattern in config options ([#72](https://github.com/git-chglog/git-chglog/issues/72))\n- switch from dep to go mod ([#85](https://github.com/git-chglog/git-chglog/issues/85))\n- add option to filter commits in a case insensitive way\n- add upperFirst template function\n- Add emoji format and some formatters in variables\n\n### Reverts\n- Revert \"ci: switches to personal GH Token for brew cross repo releases\"\n- ci: switches to personal GH Token for brew cross repo releases\n\n### Pull Requests\n- Merge pull request [#65](https://github.com/git-chglog/git-chglog/issues/65) from barryib/case-sensitive-option\n- Merge pull request [#59](https://github.com/git-chglog/git-chglog/issues/59) from momotaro98/feature/add-emoji-template-in-init\n- Merge pull request [#66](https://github.com/git-chglog/git-chglog/issues/66) from barryib/add-upper-first-func\n- Merge pull request [#68](https://github.com/git-chglog/git-chglog/issues/68) from unixorn/tweak-readme\n\n\n<a name=\"0.9.1\"></a>\n## [0.9.1] - 2019-09-23\n\n<a name=\"0.9.0\"></a>\n## [0.9.0] - 2019-09-23\n### Bug Fixes\n- Fixing tests on windows\n\n### Features\n- Add --tag-filter-pattern flag.\n\n### Pull Requests\n- Merge pull request [#44](https://github.com/git-chglog/git-chglog/issues/44) from evanchaoli/tag-filter\n- Merge pull request [#41](https://github.com/git-chglog/git-chglog/issues/41) from StanleyGoldman/fixing-tests-windows\n- Merge pull request [#37](https://github.com/git-chglog/git-chglog/issues/37) from ForkingSyndrome/master\n\n\n<a name=\"0.8.0\"></a>\n## [0.8.0] - 2019-02-23\n### Features\n- add the contains, hasPrefix, hasSuffix, replace, lower and upper functions to the template functions map\n\n### Pull Requests\n- Merge pull request [#34](https://github.com/git-chglog/git-chglog/issues/34) from atosatto/template-functions\n\n\n<a name=\"0.7.1\"></a>\n## [0.7.1] - 2018-11-10\n### Bug Fixes\n- Panic occured when exec --next-tag with HEAD with tag\n\n### Pull Requests\n- Merge pull request [#31](https://github.com/git-chglog/git-chglog/issues/31) from drubin/patch-1\n- Merge pull request [#30](https://github.com/git-chglog/git-chglog/issues/30) from vvakame/fix-panic\n\n\n<a name=\"0.7.0\"></a>\n## [0.7.0] - 2018-05-06\n### Bug Fixes\n- Remove accidentally added `Unreleased.Tag`\n\n### Chores\n- Update `changelog` task in Makefile\n\n### Features\n- Add URL of output example for template style\n- Add `--next-tag` flag (experimental)\n\n### Pull Requests\n- Merge pull request [#22](https://github.com/git-chglog/git-chglog/issues/22) from git-chglog/feat/add-preview-style-link\n- Merge pull request [#21](https://github.com/git-chglog/git-chglog/issues/21) from git-chglog/feat/next-tag\n\n\n<a name=\"0.6.0\"></a>\n## [0.6.0] - 2018-05-04\n### Chores\n- Update CHANGELOG template format\n\n### Features\n- Add tag name header id for keep-a-changelog template\n\n### Pull Requests\n- Merge pull request [#20](https://github.com/git-chglog/git-chglog/issues/20) from git-chglog/feat/kac-template-title-id\n\n\n<a name=\"0.5.0\"></a>\n## [0.5.0] - 2018-05-04\n### Bug Fixes\n- Add unreleased commits section to keep-a-changelog template [#15](https://github.com/git-chglog/git-chglog/issues/15)\n\n### Chores\n- Update CHANGELOG template format\n\n### Features\n- Update template format to human readable\n- Add `Unreleased` field to `RenderData`\n\n### Pull Requests\n- Merge pull request [#19](https://github.com/git-chglog/git-chglog/issues/19) from git-chglog/fix/unreleased-commits\n- Merge pull request [#18](https://github.com/git-chglog/git-chglog/issues/18) from ringohub/master\n\n\n<a name=\"0.4.0\"></a>\n## [0.4.0] - 2018-04-14\n### Features\n- Add support for Bitbucket\n\n### Pull Requests\n- Merge pull request [#17](https://github.com/git-chglog/git-chglog/issues/17) from git-chglog/feat/bitbucket\n\n\n<a name=\"0.3.3\"></a>\n## [0.3.3] - 2018-04-07\n### Features\n- Change to kindly error message when git-tag does not exist\n\n### Pull Requests\n- Merge pull request [#16](https://github.com/git-chglog/git-chglog/issues/16) from git-chglog/fix/empty-tag-handling\n\n\n<a name=\"0.3.2\"></a>\n## [0.3.2] - 2018-04-02\n### Bug Fixes\n- Fix color output bug in windows help command\n\n### Pull Requests\n- Merge pull request [#14](https://github.com/git-chglog/git-chglog/issues/14) from git-chglog/fix/windows-help-color\n\n\n<a name=\"0.3.1\"></a>\n## [0.3.1] - 2018-03-15\n### Bug Fixes\n- fix preview string of commit subject\n\n### Pull Requests\n- Merge pull request [#13](https://github.com/git-chglog/git-chglog/issues/13) from kt3k/feature/fix-preview\n\n\n<a name=\"0.3.0\"></a>\n## [0.3.0] - 2018-03-12\n### Chores\n- Add helper task for generate CHANGELOG\n\n### Features\n- Add support for GitLab\n\n### Pull Requests\n- Merge pull request [#12](https://github.com/git-chglog/git-chglog/issues/12) from git-chglog/feat/gitlab\n\n\n<a name=\"0.2.0\"></a>\n## [0.2.0] - 2018-03-02\n### Chores\n- Fix release flow (retry)\n- Add AppVeyor config\n\n### Features\n- Add template for `Keep a changelog` to the `--init` option\n- Supports vim like `j/k` keybind with item selection of `--init`\n\n### Pull Requests\n- Merge pull request [#11](https://github.com/git-chglog/git-chglog/issues/11) from git-chglog/develop\n- Merge pull request [#10](https://github.com/git-chglog/git-chglog/issues/10) from mattn/fix-test\n- Merge pull request [#9](https://github.com/git-chglog/git-chglog/issues/9) from mattn/windows-color\n\n\n<a name=\"0.1.0\"></a>\n## [0.1.0] - 2018-02-25\n### Bug Fixes\n- Fix a bug that `Commit.Revert.Header` is not converted by `GitHubProcessor`\n- Fix error message when `Tag` can not be acquired\n- Fix `Revert` of template created by Initializer\n\n### Chores\n- Fix release scripts\n- Remove unnecessary task\n- Add coverage measurement task for local confirmation\n- Change release method of git tag on TravisCI\n\n### Code Refactoring\n- Refactor `Initializer` to testable\n\n### Features\n- Supports annotated git-tag and adds `Tag.Subject` field [#3](https://github.com/git-chglog/git-chglog/issues/3)\n- Remove commit message preview on select format\n- Add Git Basic to commit message format\n- Add preview to the commit message format of `--init` option\n\n### Pull Requests\n- Merge pull request [#8](https://github.com/git-chglog/git-chglog/issues/8) from git-chglog/feat/0.0.3\n- Merge pull request [#6](https://github.com/git-chglog/git-chglog/issues/6) from git-chglog/chore/coverage\n- Merge pull request [#4](https://github.com/git-chglog/git-chglog/issues/4) from paralax/patch-1\n- Merge pull request [#5](https://github.com/git-chglog/git-chglog/issues/5) from git-chglog/develop\n- Merge pull request [#1](https://github.com/git-chglog/git-chglog/issues/1) from git-chglog/develop\n\n\n<a name=\"0.0.2\"></a>\n## [0.0.2] - 2018-02-18\n### Chores\n- Fix release script\n- Add release process\n\n\n<a name=\"0.0.1\"></a>\n## 0.0.1 - 2018-02-18\n### Bug Fixes\n- Fix parsing of revert and body\n\n### Chores\n- Fix timezone in TravisCI\n- Add travis configuration\n- Add Makefile for task management\n- Fix testcase depending on datetime\n- Update vendor packages\n- Add e2e tests\n- Setup gitignore\n- Initial commit\n- **editor:** Add Editorconfig\n\n### Code Refactoring\n- Fix typo\n- Change to return an error if corresponding commit is empty\n- Refactor the main logic\n\n### Features\n- Add cli client\n- Add commits in commit version struct\n- Add config normalize process\n- Add Next and Previous in Tag\n- Add MergeCommits and RevertCommits\n- First implement\n\n\n[Unreleased]: https://github.com/git-chglog/git-chglog/compare/v0.15.4...HEAD\n[v0.15.4]: https://github.com/git-chglog/git-chglog/compare/v0.15.2...v0.15.4\n[v0.15.2]: https://github.com/git-chglog/git-chglog/compare/v0.15.1...v0.15.2\n[v0.15.1]: https://github.com/git-chglog/git-chglog/compare/v0.15.0...v0.15.1\n[v0.15.0]: https://github.com/git-chglog/git-chglog/compare/v0.14.2...v0.15.0\n[v0.14.2]: https://github.com/git-chglog/git-chglog/compare/v0.14.1...v0.14.2\n[v0.14.1]: https://github.com/git-chglog/git-chglog/compare/v0.14.0...v0.14.1\n[v0.14.0]: https://github.com/git-chglog/git-chglog/compare/v0.13.0...v0.14.0\n[v0.13.0]: https://github.com/git-chglog/git-chglog/compare/v0.12.0...v0.13.0\n[v0.12.0]: https://github.com/git-chglog/git-chglog/compare/v0.11.2...v0.12.0\n[v0.11.2]: https://github.com/git-chglog/git-chglog/compare/v0.11.1...v0.11.2\n[v0.11.1]: https://github.com/git-chglog/git-chglog/compare/v0.11.0...v0.11.1\n[v0.11.0]: https://github.com/git-chglog/git-chglog/compare/v0.10.0...v0.11.0\n[v0.10.0]: https://github.com/git-chglog/git-chglog/compare/0.9.1...v0.10.0\n[0.9.1]: https://github.com/git-chglog/git-chglog/compare/0.9.0...0.9.1\n[0.9.0]: https://github.com/git-chglog/git-chglog/compare/0.8.0...0.9.0\n[0.8.0]: https://github.com/git-chglog/git-chglog/compare/0.7.1...0.8.0\n[0.7.1]: https://github.com/git-chglog/git-chglog/compare/0.7.0...0.7.1\n[0.7.0]: https://github.com/git-chglog/git-chglog/compare/0.6.0...0.7.0\n[0.6.0]: https://github.com/git-chglog/git-chglog/compare/0.5.0...0.6.0\n[0.5.0]: https://github.com/git-chglog/git-chglog/compare/0.4.0...0.5.0\n[0.4.0]: https://github.com/git-chglog/git-chglog/compare/0.3.3...0.4.0\n[0.3.3]: https://github.com/git-chglog/git-chglog/compare/0.3.2...0.3.3\n[0.3.2]: https://github.com/git-chglog/git-chglog/compare/0.3.1...0.3.2\n[0.3.1]: https://github.com/git-chglog/git-chglog/compare/0.3.0...0.3.1\n[0.3.0]: https://github.com/git-chglog/git-chglog/compare/0.2.0...0.3.0\n[0.2.0]: https://github.com/git-chglog/git-chglog/compare/0.1.0...0.2.0\n[0.1.0]: https://github.com/git-chglog/git-chglog/compare/0.0.2...0.1.0\n[0.0.2]: https://github.com/git-chglog/git-chglog/compare/0.0.1...0.0.2\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.67578125,
          "content": "# Contributing `git-chglog`\n\nThank you for contributing `git-chglog` :tada:\n\n## Templates\n\nPlease use issue/PR templates which are inserted automatically.\n\n## Found a Bug?\n\nIf you find a bug in the source code, you can help us by [submitting an issue]\nto our [GitHub Repository]. Even better, you can submit a Pull Request with a\nfix.\n\n## Commit Message Format\n\nA format influenced by [Angular commit message].\n\n```text\n<type>: <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n```\n\n### Type\n\nMust be one of the following:\n\n- **docs:** Documention only changes\n- **ci:** Changes to our CI configuration files and scripts\n- **chore:** Updating Makefile etc, no production code changes\n- **feat:** A new feature\n- **fix:** A bug fix\n- **perf:** A code change that improves performance\n- **refactor:** A code change that neither fixes a bug nor adds a feature\n- **style:** Changes that do not affect the meaning of the code\n- **test:** Adding missing tests or correcting existing tests\n\n### Footer\n\nThe footer should contain a [closing reference to an issue] if any.\n\nThe **footer** should contain any information about **Breaking Changes** and is\nalso the place to reference GitHub issues that this commit **Closes**.\n\n**Breaking Changes** should start with the word `BREAKING CHANGE:` with a space\nor two newlines. The rest of the commit message is then used for this.\n\n[submitting an issue]: https://github.com/git-chglog/git-chglog/issues\n[GitHub Repository]: https://github.com/git-chglog/git-chglog\n[Angular commit message]: https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit-message-format\n[closing reference to an issue]: https://help.github.com/articles/closing-issues-via-commit-messages/"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.259765625,
          "content": "FROM alpine\n\nRUN apk add --no-cache git && \\\n    mkdir /workdir && \\\n    git config --global --add safe.directory /workdir\n\nCOPY git-chglog /usr/local/bin/git-chglog\n\nWORKDIR /workdir\nRUN chmod +x /usr/local/bin/git-chglog\n\nENTRYPOINT [ \"/usr/local/bin/git-chglog\" ]"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2018 tsuyoshiwada\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.3779296875,
          "content": "# Build variables\nVERSION ?= $(shell git describe --tags --always)\n\n# Go variables\nGO      ?= go\nGOOS    ?= $(shell $(GO) env GOOS)\nGOARCH  ?= $(shell $(GO) env GOARCH)\nGOHOST  ?= GOOS=$(GOOS) GOARCH=$(GOARCH) $(GO)\n\nLDFLAGS ?= \"-X main.version=$(VERSION)\"\n\n# Docker variables\nDEFAULT_TAG  ?= $(shell echo \"$(VERSION)\" | tr -d 'v')\nDOCKER_IMAGE := quay.io/git-chglog/git-chglog\nDOCKER_TAG   ?= $(DEFAULT_TAG)\n\n.PHONY: all\nall: help\n\n###############\n##@ Development\n\n.PHONY: clean\nclean:   ## Clean workspace\n\t@ $(MAKE) --no-print-directory log-$@\n\trm -rf ./dist/\n\trm -rf ./git-chglog\n\trm -rf $(GOPATH)/bin/git-chglog\n\trm -rf cover.out\n\n.PHONY: test\ntest:   ## Run tests\n\t@ $(MAKE) --no-print-directory log-$@\n\t$(GOHOST) test -covermode atomic -coverprofile cover.out -v ./...\n\n.PHONY: lint\nlint:   ## Run linters\n\t@ $(MAKE) --no-print-directory log-$@\n\tgolangci-lint run\n\n#########\n##@ Build\n\n.PHONY: build\nbuild:   ## Build git-chglog\n\t@ $(MAKE) --no-print-directory log-$@\n\tCGO_ENABLED=0 $(GOHOST) build -ldflags=$(LDFLAGS) -o git-chglog ./cmd/git-chglog\n\n.PHONY: install\ninstall:   ## Install git-chglog\n\t@ $(MAKE) --no-print-directory log-$@\n\t$(GOHOST) install ./cmd/git-chglog\n\n.PHONY: docker\ndocker: build   ## Build Docker image\n\t@ $(MAKE) --no-print-directory log-$@\n\tdocker build --pull --tag $(DOCKER_IMAGE):$(DOCKER_TAG) .\n\n.PHONY: push\npush:   ## Push Docker image\n\t@ $(MAKE) --no-print-directory log-$@\n\tdocker push $(DOCKER_IMAGE):$(DOCKER_TAG)\n\n###########\n##@ Release\n\n.PHONY: changelog\nchangelog: build   ## Generate changelog\n\t@ $(MAKE) --no-print-directory log-$@\n\t./git-chglog --next-tag $(VERSION) -o CHANGELOG.md\n\n.PHONY: release\nrelease: changelog   ## Release a new tag\n\t@ $(MAKE) --no-print-directory log-$@\n\tgit add CHANGELOG.md\n\tgit commit -m \"chore: update changelog for $(VERSION)\"\n\tgit tag $(VERSION)\n\tgit push origin master $(VERSION)\n\n########\n##@ Help\n\n.PHONY: help\nhelp:   ## Display this help\n\t@awk \\\n\t\t-v \"col=\\033[36m\" -v \"nocol=\\033[0m\" \\\n\t\t' \\\n\t\t\tBEGIN { \\\n\t\t\t\tFS = \":.*##\" ; \\\n\t\t\t\tprintf \"Usage:\\n  make %s<target>%s\\n\", col, nocol \\\n\t\t\t} \\\n\t\t\t/^[a-zA-Z_-]+:.*?##/ { \\\n\t\t\t\tprintf \"  %s%-12s%s %s\\n\", col, $$1, nocol, $$2 \\\n\t\t\t} \\\n\t\t\t/^##@/ { \\\n\t\t\t\tprintf \"\\n%s%s%s\\n\", nocol, substr($$0, 5), nocol \\\n\t\t\t} \\\n\t\t' $(MAKEFILE_LIST)\n\nlog-%:\n\t@grep -h -E '^$*:.*?## .*$$' $(MAKEFILE_LIST) | \\\n\t\tawk \\\n\t\t\t'BEGIN { \\\n\t\t\t\tFS = \":.*?## \" \\\n\t\t\t}; \\\n\t\t\t{ \\\n\t\t\t\tprintf \"\\033[36m==> %s\\033[0m\\n\", $$2 \\\n\t\t\t}'\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 26.4951171875,
          "content": "# git-chglog\n\n![git-chglog](https://raw.githubusercontent.com/git-chglog/artwork/master/repo-banner%402x.png)\n\n[![godoc.org](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](https://godoc.org/github.com/git-chglog/git-chglog)\n[![Actions Status](https://github.com/git-chglog/git-chglog/workflows/tests/badge.svg)](https://github.com/git-chglog/git-chglog/actions)\n[![Coverage Status](https://img.shields.io/coveralls/github/git-chglog/git-chglog.svg?style=flat-square)](https://coveralls.io/github/git-chglog/git-chglog?branch=master)\n[![MIT License](http://img.shields.io/badge/license-MIT-blue.svg?style=flat-square)](https://github.com/git-chglog/git-chglog/blob/master/LICENSE)\n\n> CHANGELOG generator implemented in Go (Golang).\n> _Anytime, anywhere, Write your CHANGELOG._\n\n## Table of Contents\n\n- [git-chglog](#git-chglog)\n  - [Table of Contents](#table-of-contents)\n  - [Features](#features)\n  - [How it works](#how-it-works)\n  - [Getting Started](#getting-started)\n    - [Installation](#installation)\n      - [Homebrew (for macOS users)](#homebrew-for-macos-users)\n      - [Scoop (for Windows users)](#scoop-for-windows-users)\n      - [asdf](#asdf)\n      - [Go users](#go-users)\n    - [Docker](#docker)\n    - [Test Installation](#test-installation)\n    - [Quick Start](#quick-start)\n  - [CLI Usage](#cli-usage)\n    - [`tag query`](#tag-query)\n  - [Configuration](#configuration)\n    - [`bin`](#bin)\n    - [`style`](#style)\n    - [`template`](#template)\n    - [`info`](#info)\n    - [`options`](#options)\n      - [`options.sort`](#optionssort)\n      - [`options.commits`](#optionscommits)\n      - [`options.commit_groups`](#optionscommit_groups)\n      - [`options.header`](#optionsheader)\n      - [`options.issues`](#optionsissues)\n      - [`options.refs`](#optionsrefs)\n      - [`options.merges`](#optionsmerges)\n      - [`options.reverts`](#optionsreverts)\n      - [`options.notes`](#optionsnotes)\n  - [Templates](#templates)\n  - [Supported Styles](#supported-styles)\n  - [Jira Integration](#jira-integration)\n    - [1. Change the header parse pattern to recognize Jira issue id in the configure file](#1-change-the-header-parse-pattern-to-recognize-jira-issue-id-in-the-configure-file)\n    - [2. Add Jira configuration to the configure file](#2-add-jira-configuration-to-the-configure-file)\n    - [3. Update the template to show Jira data](#3-update-the-template-to-show-jira-data)\n  - [FAQ](#faq)\n  - [TODO](#todo)\n  - [Thanks](#thanks)\n  - [Contributing](#contributing)\n  - [Development](#development)\n  - [Release Process](#release-process)\n  - [Feedback](#feedback)\n  - [CHANGELOG](#changelog)\n  - [Related Projects](#related-projects)\n  - [License](#license)\n\n## Features\n\n- :recycle: High portability\n  - It works with single binary. Therefore, any project (environment) can be used.\n- :beginner: Simple usability\n  - The CLI usage is very simple and has low learning costs.\n  - For example, the simplest command is `$ git-chglog`.\n- :rocket: High flexibility\n  - Commit message format and ...\n  - CHANGELOG's style (Template) and ...\n  - etc ...\n\n## How it works\n\n`git-chglog` internally uses the `git` command to get data to include in the\nCHANGELOG. The basic steps are as follows.\n\n1. Get all the tags.\n1. Get the commits contained between `tagA` and `tagB`.\n1. Execute with all tags corresponding to [tag query](#tag-query) that were specified in Step 1 and 2.\n\n## Getting Started\n\nWe will start with installation and introduce the steps up to the automatic generation\nof the configuration file and template.\n\n### Installation\n\nPlease install `git-chglog` in a way that matches your environment.\n\n#### [Homebrew](https://brew.sh) (for macOS users)\n\n```bash\nbrew tap git-chglog/git-chglog\nbrew install git-chglog\n```\n\n#### [Scoop](https://scoop.sh) (for Windows users)\n\n```bash\nscoop install git-chglog\n```\n\n#### [asdf](https://asdf-vm.com/)\n\n```bash\nasdf plugin-add git-chglog https://github.com/GoodwayGroup/asdf-git-chglog.git\nasdf install git-chglog latest\n```\n\n#### Go users\n\n```bash\ngo install github.com/git-chglog/git-chglog/cmd/git-chglog@latest\n```\n\n### [Docker](https://www.docker.com/)\nThe compiled docker images are maintained on [quay.io](https://quay.io/repository/git-chglog/git-chglog). \nWe maintain the following tags:\n- `edge`: Image that is build from the current `HEAD` of the main line branch.\n- `latest`: Image that is built from the [latest released version](https://github.com/git-chglog/git-chglog/releases)\n- `x.y.y` (versions): Images that are build from the tagged versions within Github.\n```bash\ndocker pull quay.io/git-chglog/git-chglog:latest\ndocker run -v \"$PWD\":/workdir quay.io/git-chglog/git-chglog --version\n```\n---\n\nIf you are using another platform, you can download a binary from the [releases page]\nand place it in a directory in your `$PATH`.\n\n### Test Installation\n\nYou can check with the following command whether the `git-chglog` command was\nincluded in a directory that is in your `$PATH`.\n\n```bash\n$ git-chglog --version\n# outputs the git-chglog version\n```\n\n### Quick Start\n\n`git-chglog` requires configuration files and templates to generate a CHANGELOG.\n\nHowever, it is a waste of time to create configuration files and templates from scratch.\n\nTherefore we recommend using the `--init` option which will create them interactively :+1:\n\n```bash\ngit-chglog --init\n```\n\n![init option demo](./docs/assets/init.gif)\n\n---\n\nYou are now ready for configuration files and templates!\n\nLet's immediately generate a CHANGELOG of your project.\nBy doing the following simple command, Markdown for your CHANGELOG is displayed\non stdout.\n\n```bash\ngit-chglog\n```\n\nUse `-o` (`--output`) option if you want to output to a file instead of stdout.\n\n```bash\ngit-chglog -o CHANGELOG.md\n```\n\n---\n\nYou now know basic usage of `git-chglog`!\n\nIn order to make a better CHANGELOG, please refer to the following document and\ncustomize it.\n\n## CLI Usage\n\n```bash\n$ git-chglog --help\n\nUSAGE:\n  git-chglog [options] <tag query>\n\n    There are the following specification methods for <tag query>.\n\n    1. <old>..<new> - Commit contained in <old> tags from <new>.\n    2. <name>..     - Commit from the <name> to the latest tag.\n    3. ..<name>     - Commit from the oldest tag to <name>.\n    4. <name>       - Commit contained in <name>.\n\nOPTIONS:\n  --init                      generate the git-chglog configuration file in interactive (default: false)\n  --path value                Filter commits by path(s). Can use multiple times.\n  --config value, -c value    specifies a different configuration file to pick up (default: \".chglog/config.yml\")\n  --template value, -t value  specifies a template file to pick up. If not specified, use the one in config\n  --repository-url value      specifies git repo URL. If not specified, use 'repository_url' in config\n  --output value, -o value    output path and filename for the changelogs. If not specified, output to stdout\n  --next-tag value            treat unreleased commits as specified tags (EXPERIMENTAL)\n  --silent                    disable stdout output (default: false)\n  --no-color                  disable color output (default: false) [$NO_COLOR]\n  --no-emoji                  disable emoji output (default: false) [$NO_EMOJI]\n  --no-case                   disable case sensitive filters (default: false)\n  --tag-filter-pattern value  Regular expression of tag filter. Is specified, only matched tags will be picked\n  --jira-url value            Jira URL [$JIRA_URL]\n  --jira-username value       Jira username [$JIRA_USERNAME]\n  --jira-token value          Jira token [$JIRA_TOKEN]\n  --sort value                Specify how to sort tags; currently supports \"date\" or by \"semver\" (default: date)\n  --help, -h                  show help (default: false)\n  --version, -v               print the version (default: false)\n\nEXAMPLE:\n\n  $ git-chglog\n\n    If <tag query> is not specified, it corresponds to all tags.\n    This is the simplest example.\n\n  $ git-chglog 1.0.0..2.0.0\n\n    The above is a command to generate CHANGELOG including commit of 1.0.0 to 2.0.0.\n\n  $ git-chglog 1.0.0\n\n    The above is a command to generate CHANGELOG including commit of only 1.0.0.\n\n  $ git-chglog $(git describe --tags $(git rev-list --tags --max-count=1))\n\n    The above is a command to generate CHANGELOG with the commit included in the latest tag.\n\n  $ git-chglog --output CHANGELOG.md\n\n    The above is a command to output to CHANGELOG.md instead of standard output.\n\n  $ git-chglog --config custom/dir/config.yml\n\n    The above is a command that uses a configuration file placed other than \".chglog/config.yml\".\n\n  $ git-chglog --path path/to/my/component --output CHANGELOG.component.md\n\n    Filter commits by specific paths or files in git and output to a component specific changelog.\n```\n\n### `tag query`\n\nYou can specify which commits to include in the generation of CHANGELOG using `<tag query>`.\n\nThe table below shows Query patterns and summaries, and Query examples.\n\n| Query          | Description                                    | Example                     |\n|:---------------|:-----------------------------------------------|:----------------------------|\n| `<old>..<new>` | Commit contained in `<new>` tags from `<old>`. | `$ git-chglog 1.0.0..2.0.0` |\n| `<name>..`     | Commit from the `<name>` to the latest tag.    | `$ git-chglog 1.0.0..`      |\n| `..<name>`     | Commit from the oldest tag to `<name>`.        | `$ git-chglog ..2.0.0`      |\n| `<name>`       | Commit contained in `<name>`.                  | `$ git-chglog 1.0.0`        |\n\n## Configuration\n\nThe `git-chglog` configuration is a yaml file. The default location is\n`.chglog/config.yml`.\n\nBelow is a complete list that you can use with `git-chglog`.\n\n```yaml\nbin: git\nstyle: \"\"\ntemplate: CHANGELOG.tpl.md\ninfo:\n  title: CHANGELOG\n  repository_url: https://github.com/git-chglog/git-chglog\n\noptions:\n  tag_filter_pattern: '^v'\n  sort: \"date\"\n\n  commits:\n    filters:\n      Type:\n        - feat\n    sort_by: Scope\n\n  commit_groups:\n    group_by: Type\n    sort_by: Title\n    title_order:\n      - feat\n    title_maps:\n      feat: Features\n\n  header:\n    pattern: \"<regexp>\"\n    pattern_maps:\n      - PropName\n\n  issues:\n    prefix:\n      - #\n\n  refs:\n    actions:\n      - Closes\n      - Fixes\n\n  merges:\n    pattern: \"^Merge branch '(\\\\w+)'$\"\n    pattern_maps:\n      - Source\n\n  reverts:\n    pattern: \"^Revert \\\"([\\\\s\\\\S]*)\\\"$\"\n    pattern_maps:\n      - Header\n\n  notes:\n    keywords:\n      - BREAKING CHANGE\n```\n\n### `bin`\n\nGit execution command.\n\n| Required | Type   | Default | Description |\n|:---------|:-------|:--------|:------------|\n| N        | String | `\"git\"` | -           |\n\n### `style`\n\nCHANGELOG style. Automatic linking of issues and notices, initial value setting\nsuch as merges etc. are done automatically.\n\n| Required | Type   | Default  | Description                                            |\n|:---------|:-------|:---------|:-------------------------------------------------------|\n| N        | String | `\"none\"` | Should be `\"github\"` `\"gitlab\"` `\"bitbucket\"` `\"none\"` |\n\n### `template`\n\nPath for the template file. It is specified by a relative path from the setting\nfile. Absolute paths are also ok.\n\n| Required | Type   | Default              | Description |\n|:---------|:-------|:---------------------|:------------|\n| N        | String | `\"CHANGELOG.tpl.md\"` | -           |\n\n### `info`\n\nMetadata for CHANGELOG. Depending on Style, it is sometimes used in processing,\nso it is recommended to specify it.\n\n| Key              | Required | Type   | Default       | Description            |\n|:-----------------|:---------|:-------|:--------------|:-----------------------|\n| `title`          | N        | String | `\"CHANGELOG\"` | Title of CHANGELOG.    |\n| `repository_url` | N        | String | none          | URL of git repository. |\n\n### `options`\n\nOptions used to process commits.\n\n#### `options.sort`\n\nOptions concerning the acquisition and sort of commits.\n\n| Required | Type        | Default   | Description                                                                                                         |\n|:---------|:------------|:----------|:--------------------------------------------------------------------------------------------------------------------|\n| N        | String      | `\"date\"` | Defines how tags are sorted in the generated change log. Values: \"date\", \"semver\". |\n\n#### `options.commits`\n\nOptions concerning the acquisition and sort of commits.\n\n| Key       | Required | Type        | Default   | Description                                                                                         |\n|:----------|:---------|:------------|:----------|:----------------------------------------------------------------------------------------------------|\n| `filters` | N        | Map in List | none      | Filter by using `Commit` properties and values. Filtering is not done by specifying an empty value. |\n| `sort_by` | N        | String      | `\"Scope\"` | Property name to use for sorting `Commit`. See [Commit].                                            |\n\n#### `options.commit_groups`\n\nOptions for groups of commits.\n\n| Key           | Required | Type        | Default   | Description                                                                                |\n|:--------------|:---------|:------------|:----------|:-------------------------------------------------------------------------------------------|\n| `group_by`    | N        | String      | `\"Type\"`  | Property name of `Commit` to be grouped into `CommitGroup`. See [CommitGroup][doc-commit]. |\n| `sort_by`     | N        | String      | `\"Title\"` | Property name to use for sorting `CommitGroup`. See [CommitGroup][doc-commit-group].       |\n| `title_order` | N        | List        | none      | Predefined order of titles to use for sorting `CommitGroup`. Only if `sort_by` is `Custom` |\n| `title_maps`  | N        | Map in List | none      | Map for `CommitGroup` title conversion.                                                    |\n\n#### `options.header`\n\nThis option is used for parsing the commit header.\n\n| Key            | Required | Type   | Default | Description                                                                                             |\n|:---------------|:---------|:-------|:--------|:--------------------------------------------------------------------------------------------------------|\n| `pattern`      | Y        | String | none    | A regular expression to use for parsing the commit header.                                              |\n| `pattern_maps` | Y        | List   | none    | A rule for mapping the result of `HeaderPattern` to the property of `Commit`. See [Commit][doc-commit]. |\n\n#### `options.issues`\n\nThis option is used to detect issues.\n\n| Key      | Required | Type | Default | Description                                |\n|:---------|:---------|:-----|:--------|:-------------------------------------------|\n| `prefix` | N        | List | none    | Prefix used for issues. (e.g. `#`, `#gh-`) |\n\n#### `options.refs`\n\nThis option is for parsing references.\n\n| Key       | Required | Type | Default | Description                                    |\n|:----------|:---------|:-----|:--------|:-----------------------------------------------|\n| `actions` | N        | List | none    | Word list of `Ref.Action`. See [Ref][doc-ref]. |\n\n#### `options.merges`\n\nOptions to detect and parse merge commits.\n\n| Key            | Required | Type   | Default | Description                               |\n|:---------------|:---------|:-------|:--------|:------------------------------------------|\n| `pattern`      | N        | String | none    | Similar to `options.header.pattern`.      |\n| `pattern_maps` | N        | List   | none    | Similar to `options.header.pattern_maps`. |\n\n#### `options.reverts`\n\nOptions to detect and parse revert commits.\n\n| Key            | Required | Type   | Default | Description                               |\n|:---------------|:---------|:-------|:--------|:------------------------------------------|\n| `pattern`      | N        | String | none    | Similar to `options.header.pattern`.      |\n| `pattern_maps` | N        | List   | none    | Similar to `options.header.pattern_maps`. |\n\n#### `options.notes`\n\nOptions to detect notes contained in commit bodies.\n\n| Key        | Required | Type | Default | Description                                                                                          |\n|:-----------|:---------|:-----|:--------|:-----------------------------------------------------------------------------------------------------|\n| `keywords` | N        | List | none    | Keyword list to find `Note`. A semicolon is a separator, like `<keyword>:` (e.g. `BREAKING CHANGE`). |\n\n## Templates\n\nThe `git-chglog` template uses the `text/template` package and enhanced templating functions provided by [Sprig]. For basic usage please refer to the following.\n\n- [text/template](https://golang.org/pkg/text/template/)\n- [Sprig]\n\nWe have implemented the following custom template functions. These override functions provided by [Sprig].\n\n| Name         | Signature                                     | Description                                                                   |\n| :----------- | :-------------------------------------------- | :---------------------------------------------------------------------------- |\n| `contains`   | `func(s, substr string) bool`                 | Reports whether `substr` is within `s` using `strings.Contains`               |\n| `datetime`   | `func(layout string, input time.Time) string` | Generate a formatted Date string based on layout                              |\n| `hasPrefix`  | `func(s, prefix string) bool`                 | Tests whether the string `s` begins with `prefix` using `strings.HasPrefix`   |\n| `hasSuffix`  | `func(s, suffix string) bool`                 | Tests whether the string `s` ends with `suffix`. using `strings.HasPrefix`    |\n| `indent`     | `func(s string, n int) string`                | Indent all lines of `s` by `n` spaces                                         |\n| `replace`    | `func(s, old, new string, n int) string`      | Replace `old` with `new` within string `s`, `n` times using `strings.Replace` |\n| `upperFirst` | `func(s string) string`                       | Upper case the first character of a string                                    |\n\nIf you are not satisfied with the prepared template please try customizing one.\n\n---\n\nThe basic templates are as follows.\n\n**Example:**\n\n```markdown\n{{ if .Versions -}}\n<a name=\"unreleased\"></a>\n## [Unreleased]\n\n{{ if .Unreleased.CommitGroups -}}\n{{ range .Unreleased.CommitGroups -}}\n### {{ .Title }}\n{{ range .Commits -}}\n- {{ if .Scope }}**{{ .Scope }}:** {{ end }}{{ .Subject }}\n{{ end }}\n{{ end -}}\n{{ end -}}\n{{ end -}}\n\n{{ range .Versions }}\n<a name=\"{{ .Tag.Name }}\"></a>\n## {{ if .Tag.Previous }}[{{ .Tag.Name }}]{{ else }}{{ .Tag.Name }}{{ end }} - {{ datetime \"2006-01-02\" .Tag.Date }}\n{{ range .CommitGroups -}}\n### {{ .Title }}\n{{ range .Commits -}}\n- {{ if .Scope }}**{{ .Scope }}:** {{ end }}{{ .Subject }}\n{{ end }}\n{{ end -}}\n\n{{- if .RevertCommits -}}\n### Reverts\n{{ range .RevertCommits -}}\n- {{ .Revert.Header }}\n{{ end }}\n{{ end -}}\n\n{{- if .MergeCommits -}}\n### Pull Requests\n{{ range .MergeCommits -}}\n- {{ .Header }}\n{{ end }}\n{{ end -}}\n\n{{- if .NoteGroups -}}\n{{ range .NoteGroups -}}\n### {{ .Title }}\n{{ range .Notes }}\n{{ .Body }}\n{{ end }}\n{{ end -}}\n{{ end -}}\n{{ end -}}\n\n{{- if .Versions }}\n[Unreleased]: {{ .Info.RepositoryURL }}/compare/{{ $latest := index .Versions 0 }}{{ $latest.Tag.Name }}...HEAD\n{{ range .Versions -}}\n{{ if .Tag.Previous -}}\n[{{ .Tag.Name }}]: {{ $.Info.RepositoryURL }}/compare/{{ .Tag.Previous.Name }}...{{ .Tag.Name }}\n{{ end -}}\n{{ end -}}\n{{ end -}}\n```\n\nSee the godoc [RenderData][doc-render-data] documentation for available variables.\n\n## Supported Styles\n\n| Name                                       | Status             | Features                                               |\n|:-------------------------------------------|:-------------------|:-------------------------------------------------------|\n| [GitHub](https://github.com/)              | :white_check_mark: | Mentions automatic link. Automatic link to references. |\n| [GitLab](https://about.gitlab.com/)        | :white_check_mark: | Mentions automatic link. Automatic link to references. |\n| [Bitbucket](https://bitbucket.org/product) | :white_check_mark: | Mentions automatic link. Automatic link to references. |\n\n> :memo: Even with styles that are not yet supported, it is possible to make\nordinary CHANGELOG.\n\n## Jira Integration\n\nJira is a popular project management tool. When a project uses Jira to track\nfeature development and bug fixes, it may also want to generate change log based\ninformation stored in Jira. With embedding a Jira story id in git commit header,\nthe git-chglog tool may automatically fetch data of the story from Jira, those\ndata then can be used to render the template.\n\nTake the following steps to add Jira integration:\n\n### 1. Change the header parse pattern to recognize Jira issue id in the configure file\n\n__Where Jira issue is identical Jira story.__\n\nThe following is a sample pattern:\n\n  ```yaml\n  header:\n    pattern: \"^(?:(\\\\w*)|(?:\\\\[(.*)\\\\])?)\\\\:\\\\s(.*)$\"\n    pattern_maps:\n      - Type\n      - JiraIssueID\n      - Subject\n  ```\n\nThis sample pattern can match both forms of commit headers:\n\n- `feat: new feature of something`\n- `[JIRA-ID]: something`\n\n### 2. Add Jira configuration to the configure file\n\nThe following is a sample:\n\n  ```yaml\n  jira:\n    info:\n      username: u\n      token: p\n      url: https://jira.com\n    issue:\n      type_maps:\n        Task: fix\n        Story: feat\n      description_pattern: \"<changelog>(.*)</changelog>\"\n  ```\n\nHere you need to define Jira URL, access username and token (password). If you\ndon't want to write your Jira access credential in configure file, you may define\nthem with environment variables: `JIRA_URL`, `JIRA_USERNAME` and `JIRA_TOKEN`.\n\nYou also needs to define a issue type map. In above sample, Jira issue type `Task`\nwill be mapped to `fix` and `Story` will be mapped to `feat`.\n\nAs a Jira story's description could be very long, you might not want to include\nthe entire description into change log. In that case, you may define `description_pattern`\nlike above, so that only content embraced with `<changelog> ... </changelog>`\nwill be included.\n\n### 3. Update the template to show Jira data\n\nIn the template, if a commit contains a Jira issue id, then you may show Jira\ndata. For example:\n\n```markdown\n{{ range .CommitGroups -}}\n### {{ .Title }}\n{{ range .Commits -}}\n- {{ if .Scope }}**{{ .Scope }}:** {{ end }}{{ .Subject }}\n{{ if .JiraIssue }} {{ .JiraIssue.Description }}\n{{ end }}\n{{ end }}\n{{ end -}}\n```\n\nWithin a `Commit`, the following Jira data can be used in template:\n\n- `.JiraIssue.Summary` - Summary of the Jira story\n- `.JiraIssue.Description` - Description of the Jira story\n- `.JiraIssue.Type` - Original type of the Jira story, and `.Type` will be mapped type.\n- `.JiraIssue.Labels` - A list of strings, each is a Jira label.\n\n## FAQ\n\n<details>\n  <summary>Why do not you output files by default?</summary>\n  This is not for the purpose of completely automating the generation of CHANGELOG\n  files, it is only for assisting generation.\n\n  It is ideal to describe everything included in CHANGELOG in your commits. But\n  actually it is very difficult to do it perfectly.\n\n  There are times when you need to edit the generated output to write a great CHANGELOG.\n\n  By displaying it on the standard output, it makes it easy to change the contents.\n</details>\n\n<details>\n  <summary>Can I commit CHANGELOG changes before creating tags?</summary>\n\n  Yes, it can be solved by using the `--next-tag` flag.\n\n  For example, let's say you want to upgrade your project to `2.0.0`.\n  You can create CHANGELOG containing `2.0.0` as follows.\n\n  ```bash\n  git-chglog --next-tag 2.0.0 -o CHANGELOG.md\n  git commit -am \"release 2.0.0\"\n  git tag 2.0.0\n  ```\n\n  The point to notice is that before actually creating a tag with `git`, it is\n  conveying the next version with `--next-tag` :+1:\n\n  This is a step that is necessary for project operation in many cases.\n</details>\n\n<details>\n  <summary>Can I generate a CHANGELOG based on certain tags?</summary>\n\n  Yes, it can be solved by use the `--tag-filter-pattern` flag.\n\n  For example, the following command will only include tags starting with \"v\":\n\n  ```bash\n  git-chglog --tag-filter-pattern '^v'\n  ```\n\n</details>\n\n## TODO\n\n- [x] Windows Support\n- [x] More styles (GitHub, GitLab, Bitbucket :tada:)\n- [ ] Snippetization of configuration files (improvement of reusability)\n- [ ] More test test test ... (and example)\n\n## Thanks\n\n`git-chglog` is inspired by [conventional-changelog]. Thank you!\n\n## Contributing\n\nWe always welcome your contributions :clap:\n\n## Development\n\n1. Use Golang version `>= 1.19`\n1. Fork (https://github.com/git-chglog/git-chglog) :tada:\n1. Create a feature branch :coffee:\n1. Run test suite with the `$ make test` command and confirm that it passes :zap:\n1. Run linters with the `$ make lint` command and confirm it passes :broom:\n   - The project uses [golangci-lint]\n1. Commit your changes :memo:\n1. Rebase your local changes against the `master` branch :bulb:\n1. Create new Pull Request :love_letter:\n\nBugs, feature requests and comments are more than welcome in the [issues].\n\n## Release Process\n\nThere is a `release` target within the Makefile that wraps up the steps to\nrelease a new version.\n\n> NOTE: Pass the `VERSION` variable when running the command to properly set\n> the tag version for the release.\n\n```bash\n$ VERSION=vX.Y.Z make release\n# EXAMPLE:\n$ VERSION=v0.11.3 make release\n```\n\nOnce the `tag` has been pushed, the `goreleaser` github action will take care\nof the rest.\n\n## Feedback\n\nI would like to make `git-chglog` a better tool.\nThe goal is to be able to use in various projects.\n\nTherefore, your feedback is very useful.\nI am very happy to tell you your opinions on Issues and PR :heart:\n\n## CHANGELOG\n\nSee [CHANGELOG.md](./CHANGELOG.md)\n\n## Related Projects\n\n- [git-chglog/artwork] - Assets for `git-chglog`.\n\n## License\n\n[MIT © tsuyoshiwada](./LICENSE)\n\n[releases page]: https://github.com/git-chglog/git-chglog/releases\n[Commit]: https://godoc.org/github.com/git-chglog/git-chglog#Commit\n[doc-commit]: https://godoc.org/github.com/git-chglog/git-chglog#Commit\n[doc-commit-group]: https://godoc.org/github.com/git-chglog/git-chglog#CommitGroup\n[doc-ref]: https://godoc.org/github.com/git-chglog/git-chglog#Ref\n[doc-render-data]: https://godoc.org/github.com/git-chglog/git-chglog#RenderData\n[conventional-changelog]: https://github.com/conventional-changelog/conventional-changelog\n[golangci-lint]: https://golangci-lint.run/usage/install/#local-installation\n[issues]: https://github.com/git-chglog/git-chglog/issues\n[git-chglog/artwork]: https://github.com/git-chglog/artwork\n[Sprig]: http://masterminds.github.io/sprig\n"
        },
        {
          "name": "chglog.go",
          "type": "blob",
          "size": 9.7646484375,
          "content": "// Package chglog implements main logic for the CHANGELOG generate.\npackage chglog\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/Masterminds/sprig/v3\"\n\t\"github.com/tsuyoshiwada/go-gitcmd\"\n)\n\n// Options is an option used to process commits\ntype Options struct {\n\tProcessor                   Processor\n\tNextTag                     string              // Treat unreleased commits as specified tags (EXPERIMENTAL)\n\tTagFilterPattern            string              // Filter tag by regexp\n\tSort                        string              // Specify how to sort tags; currently supports \"date\" (default) or by \"semver\".\n\tNoCaseSensitive             bool                // Filter commits in a case insensitive way\n\tCommitFilters               map[string][]string // Filter by using `Commit` properties and values. Filtering is not done by specifying an empty value\n\tCommitSortBy                string              // Property name to use for sorting `Commit` (e.g. `Scope`)\n\tCommitGroupBy               string              // Property name of `Commit` to be grouped into `CommitGroup` (e.g. `Type`)\n\tCommitGroupSortBy           string              // Property name to use for sorting `CommitGroup` (e.g. `Title`)\n\tCommitGroupTitleOrder       []string            // Predefined sorted list of titles to use for sorting `CommitGroup`. Only if `CommitGroupSortBy` is `Custom`\n\tCommitGroupTitleMaps        map[string]string   // Map for `CommitGroup` title conversion\n\tHeaderPattern               string              // A regular expression to use for parsing the commit header\n\tHeaderPatternMaps           []string            // A rule for mapping the result of `HeaderPattern` to the property of `Commit`\n\tIssuePrefix                 []string            // Prefix used for issues (e.g. `#`, `gh-`)\n\tRefActions                  []string            // Word list of `Ref.Action`\n\tMergePattern                string              // A regular expression to use for parsing the merge commit\n\tMergePatternMaps            []string            // Similar to `HeaderPatternMaps`\n\tRevertPattern               string              // A regular expression to use for parsing the revert commit\n\tRevertPatternMaps           []string            // Similar to `HeaderPatternMaps`\n\tNoteKeywords                []string            // Keyword list to find `Note`. A semicolon is a separator, like `<keyword>:` (e.g. `BREAKING CHANGE`)\n\tJiraUsername                string\n\tJiraToken                   string\n\tJiraURL                     string\n\tJiraTypeMaps                map[string]string\n\tJiraIssueDescriptionPattern string\n\tPaths                       []string // Path filter\n}\n\n// Info is metadata related to CHANGELOG\ntype Info struct {\n\tTitle         string // Title of CHANGELOG\n\tRepositoryURL string // URL of git repository\n}\n\n// RenderData is the data passed to the template\ntype RenderData struct {\n\tInfo       *Info\n\tUnreleased *Unreleased\n\tVersions   []*Version\n}\n\n// Config for generating CHANGELOG\ntype Config struct {\n\tBin        string // Git execution command\n\tWorkingDir string // Working directory\n\tTemplate   string // Path for template file. If a relative path is specified, it depends on the value of `WorkingDir`.\n\tInfo       *Info\n\tOptions    *Options\n}\n\nfunc normalizeConfig(config *Config) {\n\topts := config.Options\n\n\tif opts.HeaderPattern == \"\" {\n\t\topts.HeaderPattern = \"^(.*)$\"\n\t\topts.HeaderPatternMaps = []string{\n\t\t\t\"Subject\",\n\t\t}\n\t}\n\n\tif opts.MergePattern == \"\" {\n\t\topts.MergePattern = \"^Merge branch '(\\\\w+)'$\"\n\t\topts.MergePatternMaps = []string{\n\t\t\t\"Source\",\n\t\t}\n\t}\n\n\tif opts.RevertPattern == \"\" {\n\t\topts.RevertPattern = \"^Revert \\\"([\\\\s\\\\S]*)\\\"$\"\n\t\topts.RevertPatternMaps = []string{\n\t\t\t\"Header\",\n\t\t}\n\t}\n\n\tconfig.Options = opts\n}\n\n// Generator of CHANGELOG\ntype Generator struct {\n\tclient          gitcmd.Client\n\tconfig          *Config\n\ttagReader       *tagReader\n\ttagSelector     *tagSelector\n\tcommitParser    *commitParser\n\tcommitExtractor *commitExtractor\n}\n\n// NewGenerator receives `Config` and create an new `Generator`\nfunc NewGenerator(logger *Logger, config *Config) *Generator {\n\tclient := gitcmd.New(&gitcmd.Config{\n\t\tBin: config.Bin,\n\t})\n\n\tjiraClient := NewJiraClient(config)\n\n\tif config.Options.Processor != nil {\n\t\tconfig.Options.Processor.Bootstrap(config)\n\t}\n\n\tnormalizeConfig(config)\n\n\treturn &Generator{\n\t\tclient:          client,\n\t\tconfig:          config,\n\t\ttagReader:       newTagReader(client, config.Options.TagFilterPattern, config.Options.Sort),\n\t\ttagSelector:     newTagSelector(),\n\t\tcommitParser:    newCommitParser(logger, client, jiraClient, config),\n\t\tcommitExtractor: newCommitExtractor(config.Options),\n\t}\n}\n\n// Generate gets the commit based on the specified tag `query` and writes the result to `io.Writer`\n//\n// tag `query` can be specified with the following rule\n//\n//\t<old>..<new> - Commit contained in `<new>` tags from `<old>` (e.g. `1.0.0..2.0.0`)\n//\t<tagname>..  - Commit from the `<tagname>` to the latest tag (e.g. `1.0.0..`)\n//\t..<tagname>  - Commit from the oldest tag to `<tagname>` (e.g. `..1.0.0`)\n//\t<tagname>    - Commit contained in `<tagname>` (e.g. `1.0.0`)\nfunc (gen *Generator) Generate(w io.Writer, query string) error {\n\tback, err := gen.workdir()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err = back(); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\ttags, first, err := gen.getTags(query)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tunreleased, err := gen.readUnreleased(tags)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tversions, err := gen.readVersions(tags, first)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(versions) == 0 {\n\t\treturn fmt.Errorf(\"commits corresponding to \\\"%s\\\" was not found\", query)\n\t}\n\n\treturn gen.render(w, unreleased, versions)\n}\n\nfunc (gen *Generator) readVersions(tags []*Tag, first string) ([]*Version, error) {\n\tnext := gen.config.Options.NextTag\n\tversions := []*Version{}\n\n\tfor i, tag := range tags {\n\t\tvar (\n\t\t\tisNext = next == tag.Name\n\t\t\trev    string\n\t\t)\n\n\t\tif isNext {\n\t\t\tif tag.Previous != nil {\n\t\t\t\trev = tag.Previous.Name + \"..HEAD\"\n\t\t\t} else {\n\t\t\t\trev = \"HEAD\"\n\t\t\t}\n\t\t} else {\n\t\t\tif i+1 < len(tags) {\n\t\t\t\trev = tags[i+1].Name + \"..\" + tag.Name\n\t\t\t} else {\n\t\t\t\tif first != \"\" {\n\t\t\t\t\trev = first + \"..\" + tag.Name\n\t\t\t\t} else {\n\t\t\t\t\trev = tag.Name\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcommits, err := gen.commitParser.Parse(rev)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcommitGroups, mergeCommits, revertCommits, noteGroups := gen.commitExtractor.Extract(commits)\n\n\t\tversions = append(versions, &Version{\n\t\t\tTag:           tag,\n\t\t\tCommitGroups:  commitGroups,\n\t\t\tCommits:       commits,\n\t\t\tMergeCommits:  mergeCommits,\n\t\t\tRevertCommits: revertCommits,\n\t\t\tNoteGroups:    noteGroups,\n\t\t})\n\n\t\t// Instead of `getTags()`, assign the date to the tag\n\t\tif isNext && len(commits) != 0 {\n\t\t\ttag.Date = commits[0].Author.Date\n\t\t}\n\t}\n\n\treturn versions, nil\n}\n\nfunc (gen *Generator) readUnreleased(tags []*Tag) (*Unreleased, error) {\n\tif gen.config.Options.NextTag != \"\" {\n\t\treturn &Unreleased{}, nil\n\t}\n\n\trev := \"HEAD\"\n\n\tif len(tags) > 0 {\n\t\trev = tags[0].Name + \"..HEAD\"\n\t}\n\n\tcommits, err := gen.commitParser.Parse(rev)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcommitGroups, mergeCommits, revertCommits, noteGroups := gen.commitExtractor.Extract(commits)\n\n\tunreleased := &Unreleased{\n\t\tCommitGroups:  commitGroups,\n\t\tCommits:       commits,\n\t\tMergeCommits:  mergeCommits,\n\t\tRevertCommits: revertCommits,\n\t\tNoteGroups:    noteGroups,\n\t}\n\n\treturn unreleased, nil\n}\n\nfunc (gen *Generator) getTags(query string) ([]*Tag, string, error) {\n\ttags, err := gen.tagReader.ReadAll()\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tnext := gen.config.Options.NextTag\n\tif next != \"\" {\n\t\tfor _, tag := range tags {\n\t\t\tif next == tag.Name {\n\t\t\t\treturn nil, \"\", fmt.Errorf(\"\\\"%s\\\" tag already exists\", next)\n\t\t\t}\n\t\t}\n\n\t\tvar previous *RelateTag\n\t\tif len(tags) > 0 {\n\t\t\tprevious = &RelateTag{\n\t\t\t\tName:    tags[0].Name,\n\t\t\t\tSubject: tags[0].Subject,\n\t\t\t\tDate:    tags[0].Date,\n\t\t\t}\n\t\t}\n\n\t\t// Assign the date with `readVersions()`\n\t\ttags = append([]*Tag{\n\t\t\t{\n\t\t\t\tName:     next,\n\t\t\t\tSubject:  next,\n\t\t\t\tPrevious: previous,\n\t\t\t},\n\t\t}, tags...)\n\t}\n\n\tif len(tags) == 0 {\n\t\treturn nil, \"\", errors.New(\"git-tag does not exist\")\n\t}\n\n\tfirst := \"\"\n\tif query != \"\" {\n\t\ttags, first, err = gen.tagSelector.Select(tags, query)\n\t\tif err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t}\n\n\treturn tags, first, nil\n}\n\nfunc (gen *Generator) workdir() (func() error, error) {\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = os.Chdir(gen.config.WorkingDir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn func() error {\n\t\treturn os.Chdir(cwd)\n\t}, nil\n}\n\nfunc (gen *Generator) render(w io.Writer, unreleased *Unreleased, versions []*Version) error {\n\tif _, err := os.Stat(gen.config.Template); err != nil {\n\t\treturn err\n\t}\n\n\tfmap := template.FuncMap{\n\t\t// format the input time according to layout\n\t\t\"datetime\": func(layout string, input time.Time) string {\n\t\t\treturn input.Format(layout)\n\t\t},\n\t\t// upper case the first character of a string\n\t\t\"upperFirst\": func(s string) string {\n\t\t\tif len(s) > 0 {\n\t\t\t\treturn strings.ToUpper(string(s[0])) + s[1:]\n\t\t\t}\n\t\t\treturn \"\"\n\t\t},\n\t\t// indent all lines of s n spaces\n\t\t\"indent\": func(s string, n int) string {\n\t\t\tif len(s) == 0 {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\tpad := strings.Repeat(\" \", n)\n\t\t\treturn pad + strings.ReplaceAll(s, \"\\n\", \"\\n\"+pad)\n\t\t},\n\t\t// While Sprig provides these functions, they change the standard input\n\t\t// order which leads to a regression. For an example see:\n\t\t// https://github.com/Masterminds/sprig/blob/master/functions.go#L149\n\t\t\"contains\":  strings.Contains,\n\t\t\"hasPrefix\": strings.HasPrefix,\n\t\t\"hasSuffix\": strings.HasSuffix,\n\t\t\"replace\":   strings.Replace,\n\t}\n\n\tfname := filepath.Base(gen.config.Template)\n\n\tt := template.Must(template.New(fname).Funcs(sprig.TxtFuncMap()).Funcs(fmap).ParseFiles(gen.config.Template))\n\n\treturn t.Execute(w, &RenderData{\n\t\tInfo:       gen.config.Info,\n\t\tUnreleased: unreleased,\n\t\tVersions:   versions,\n\t})\n}\n"
        },
        {
          "name": "chglog_test.go",
          "type": "blob",
          "size": 15.5244140625,
          "content": "package chglog\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\tgitcmd \"github.com/tsuyoshiwada/go-gitcmd\"\n)\n\nvar (\n\tcwd                string\n\ttestRepoRoot       = \".tmp\"\n\tinternalTimeFormat = \"2006-01-02 15:04:05\"\n)\n\ntype commitFunc = func(date, subject, body string)\ntype tagFunc = func(name string)\n\nfunc TestMain(m *testing.M) {\n\tcwd, _ = os.Getwd()\n\tcleanup()\n\tcode := m.Run()\n\tcleanup()\n\tos.Exit(code)\n}\n\nfunc setup(dir string, setupRepo func(commitFunc, tagFunc, gitcmd.Client)) {\n\ttestDir := filepath.Join(cwd, testRepoRoot, dir)\n\n\t_ = os.RemoveAll(testDir)\n\t_ = os.MkdirAll(testDir, os.ModePerm)\n\t_ = os.Chdir(testDir)\n\n\tloc, _ := time.LoadLocation(\"UTC\")\n\ttime.Local = loc\n\n\tgit := gitcmd.New(nil)\n\t_, _ = git.Exec(\"init\")\n\t_, _ = git.Exec(\"config\", \"user.name\", \"test_user\")\n\t_, _ = git.Exec(\"config\", \"user.email\", \"test@example.com\")\n\n\tvar commit = func(date, subject, body string) {\n\t\tmsg := subject\n\t\tif body != \"\" {\n\t\t\tmsg += \"\\n\\n\" + body\n\t\t}\n\t\tt, _ := time.Parse(internalTimeFormat, date)\n\t\td := t.Format(\"Mon Jan 2 15:04:05 2006 +0000\")\n\t\t_, _ = git.Exec(\"commit\", \"--allow-empty\", \"--date\", d, \"-m\", msg)\n\t}\n\n\tvar tag = func(name string) {\n\t\t_, _ = git.Exec(\"tag\", name)\n\t}\n\n\tsetupRepo(commit, tag, git)\n\n\t_ = os.Chdir(cwd)\n}\n\nfunc cleanup() {\n\t_ = os.Chdir(cwd)\n\t_ = os.RemoveAll(filepath.Join(cwd, testRepoRoot))\n}\n\nfunc TestGeneratorNotFoundTags(t *testing.T) {\n\tassert := assert.New(t)\n\ttestName := \"not_found\"\n\n\tsetup(testName, func(commit commitFunc, _ tagFunc, _ gitcmd.Client) {\n\t\tcommit(\"2018-01-01 00:00:00\", \"feat(*): New feature\", \"\")\n\t})\n\n\tgen := NewGenerator(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\t&Config{\n\t\t\tBin:        \"git\",\n\t\t\tWorkingDir: filepath.Join(testRepoRoot, testName),\n\t\t\tTemplate:   filepath.Join(cwd, \"testdata\", testName+\".md\"),\n\t\t\tInfo: &Info{\n\t\t\t\tRepositoryURL: \"https://github.com/git-chglog/git-chglog\",\n\t\t\t},\n\t\t\tOptions: &Options{},\n\t\t})\n\n\tbuf := &bytes.Buffer{}\n\terr := gen.Generate(buf, \"\")\n\texpected := strings.TrimSpace(buf.String())\n\n\tassert.Error(err)\n\tassert.Contains(err.Error(), \"git-tag does not exist\")\n\tassert.Equal(\"\", expected)\n}\n\nfunc TestGeneratorNotFoundCommits(t *testing.T) {\n\tassert := assert.New(t)\n\ttestName := \"not_found\"\n\n\tsetup(testName, func(commit commitFunc, tag tagFunc, _ gitcmd.Client) {\n\t\tcommit(\"2018-01-01 00:00:00\", \"feat(*): New feature\", \"\")\n\t\ttag(\"1.0.0\")\n\t})\n\n\tgen := NewGenerator(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\t&Config{\n\t\t\tBin:        \"git\",\n\t\t\tWorkingDir: filepath.Join(testRepoRoot, testName),\n\t\t\tTemplate:   filepath.Join(cwd, \"testdata\", testName+\".md\"),\n\t\t\tInfo: &Info{\n\t\t\t\tRepositoryURL: \"https://github.com/git-chglog/git-chglog\",\n\t\t\t},\n\t\t\tOptions: &Options{},\n\t\t})\n\n\tbuf := &bytes.Buffer{}\n\terr := gen.Generate(buf, \"foo\")\n\texpected := strings.TrimSpace(buf.String())\n\n\tassert.Error(err)\n\tassert.Equal(\"\", expected)\n}\n\nfunc TestGeneratorNotFoundCommitsOne(t *testing.T) {\n\tassert := assert.New(t)\n\ttestName := \"not_found\"\n\n\tsetup(testName, func(commit commitFunc, tag tagFunc, _ gitcmd.Client) {\n\t\tcommit(\"2018-01-01 00:00:00\", \"chore(*): First commit\", \"\")\n\t\ttag(\"1.0.0\")\n\t})\n\n\tgen := NewGenerator(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\t&Config{\n\t\t\tBin:        \"git\",\n\t\t\tWorkingDir: filepath.Join(testRepoRoot, testName),\n\t\t\tTemplate:   filepath.Join(cwd, \"testdata\", testName+\".md\"),\n\t\t\tInfo: &Info{\n\t\t\t\tRepositoryURL: \"https://github.com/git-chglog/git-chglog\",\n\t\t\t},\n\t\t\tOptions: &Options{\n\t\t\t\tCommitFilters:        map[string][]string{},\n\t\t\t\tCommitSortBy:         \"Scope\",\n\t\t\t\tCommitGroupBy:        \"Type\",\n\t\t\t\tCommitGroupSortBy:    \"Title\",\n\t\t\t\tCommitGroupTitleMaps: map[string]string{},\n\t\t\t\tHeaderPattern:        \"^(\\\\w*)(?:\\\\(([\\\\w\\\\$\\\\.\\\\-\\\\*\\\\s]*)\\\\))?\\\\:\\\\s(.*)$\",\n\t\t\t\tHeaderPatternMaps: []string{\n\t\t\t\t\t\"Type\",\n\t\t\t\t\t\"Scope\",\n\t\t\t\t\t\"Subject\",\n\t\t\t\t},\n\t\t\t\tIssuePrefix: []string{\n\t\t\t\t\t\"#\",\n\t\t\t\t\t\"gh-\",\n\t\t\t\t},\n\t\t\t\tRefActions:   []string{},\n\t\t\t\tMergePattern: \"^Merge pull request #(\\\\d+) from (.*)$\",\n\t\t\t\tMergePatternMaps: []string{\n\t\t\t\t\t\"Ref\",\n\t\t\t\t\t\"Source\",\n\t\t\t\t},\n\t\t\t\tRevertPattern: \"^Revert \\\"([\\\\s\\\\S]*)\\\"$\",\n\t\t\t\tRevertPatternMaps: []string{\n\t\t\t\t\t\"Header\",\n\t\t\t\t},\n\t\t\t\tNoteKeywords: []string{\n\t\t\t\t\t\"BREAKING CHANGE\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tbuf := &bytes.Buffer{}\n\terr := gen.Generate(buf, \"foo\")\n\texpected := strings.TrimSpace(buf.String())\n\n\tassert.Error(err)\n\tassert.Contains(err.Error(), \"\\\"foo\\\" was not found\")\n\tassert.Equal(\"\", expected)\n}\n\nfunc TestGeneratorWithTypeScopeSubject(t *testing.T) {\n\tassert := assert.New(t)\n\ttestName := \"type_scope_subject\"\n\n\tsetup(testName, func(commit commitFunc, tag tagFunc, _ gitcmd.Client) {\n\t\tcommit(\"2018-01-01 00:00:00\", \"chore(*): First commit\", \"\")\n\t\tcommit(\"2018-01-01 00:01:00\", \"feat(core): Add foo bar\", \"\")\n\t\tcommit(\"2018-01-01 00:02:00\", \"docs(readme): Update usage #123\", \"\")\n\t\ttag(\"1.0.0\")\n\n\t\tcommit(\"2018-01-02 00:00:00\", \"feat(parser): New some super options #333\", \"\")\n\t\tcommit(\"2018-01-02 00:01:00\", \"Merge pull request #999 from tsuyoshiwada/patch-1\", \"\")\n\t\tcommit(\"2018-01-02 00:02:00\", \"Merge pull request #1000 from tsuyoshiwada/patch-1\", \"\")\n\t\tcommit(\"2018-01-02 00:03:00\", \"Revert \\\"feat(core): Add foo bar @mention and issue #987\\\"\", \"\")\n\t\ttag(\"1.1.0\")\n\n\t\tcommit(\"2018-01-03 00:00:00\", \"feat(context): Online breaking change\", \"BREAKING CHANGE: Online breaking change message.\")\n\t\tcommit(\"2018-01-03 00:01:00\", \"feat(router): Multiple breaking change\", `This is body,\n\nBREAKING CHANGE:\nMultiple\nbreaking\nchange message.`)\n\t\ttag(\"2.0.0-beta.0\")\n\n\t\tcommit(\"2018-01-04 00:00:00\", \"refactor(context): gofmt\", \"\")\n\t\tcommit(\"2018-01-04 00:01:00\", \"fix(core): Fix commit\\n\\nThis is body message.\", \"\")\n\t})\n\n\tgen := NewGenerator(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\t&Config{\n\t\t\tBin:        \"git\",\n\t\t\tWorkingDir: filepath.Join(testRepoRoot, testName),\n\t\t\tTemplate:   filepath.Join(cwd, \"testdata\", testName+\".md\"),\n\t\t\tInfo: &Info{\n\t\t\t\tTitle:         \"CHANGELOG Example\",\n\t\t\t\tRepositoryURL: \"https://github.com/git-chglog/git-chglog\",\n\t\t\t},\n\t\t\tOptions: &Options{\n\t\t\t\tSort: \"date\",\n\t\t\t\tCommitFilters: map[string][]string{\n\t\t\t\t\t\"Type\": {\n\t\t\t\t\t\t\"feat\",\n\t\t\t\t\t\t\"fix\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommitSortBy:      \"Scope\",\n\t\t\t\tCommitGroupBy:     \"Type\",\n\t\t\t\tCommitGroupSortBy: \"Title\",\n\t\t\t\tCommitGroupTitleMaps: map[string]string{\n\t\t\t\t\t\"feat\": \"Features\",\n\t\t\t\t\t\"fix\":  \"Bug Fixes\",\n\t\t\t\t},\n\t\t\t\tHeaderPattern: \"^(\\\\w*)(?:\\\\(([\\\\w\\\\$\\\\.\\\\-\\\\*\\\\s]*)\\\\))?\\\\:\\\\s(.*)$\",\n\t\t\t\tHeaderPatternMaps: []string{\n\t\t\t\t\t\"Type\",\n\t\t\t\t\t\"Scope\",\n\t\t\t\t\t\"Subject\",\n\t\t\t\t},\n\t\t\t\tIssuePrefix: []string{\n\t\t\t\t\t\"#\",\n\t\t\t\t\t\"gh-\",\n\t\t\t\t},\n\t\t\t\tRefActions:   []string{},\n\t\t\t\tMergePattern: \"^Merge pull request #(\\\\d+) from (.*)$\",\n\t\t\t\tMergePatternMaps: []string{\n\t\t\t\t\t\"Ref\",\n\t\t\t\t\t\"Source\",\n\t\t\t\t},\n\t\t\t\tRevertPattern: \"^Revert \\\"([\\\\s\\\\S]*)\\\"$\",\n\t\t\t\tRevertPatternMaps: []string{\n\t\t\t\t\t\"Header\",\n\t\t\t\t},\n\t\t\t\tNoteKeywords: []string{\n\t\t\t\t\t\"BREAKING CHANGE\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tbuf := &bytes.Buffer{}\n\terr := gen.Generate(buf, \"\")\n\texpected := strings.TrimSpace(buf.String())\n\n\tassert.Nil(err)\n\tassert.Equal(`<a name=\"unreleased\"></a>\n## [Unreleased]\n\n### Bug Fixes\n- **core:** Fix commit\n\n\n<a name=\"2.0.0-beta.0\"></a>\n## [2.0.0-beta.0] - 2018-01-03\n### Features\n- **context:** Online breaking change\n- **router:** Multiple breaking change\n\n### BREAKING CHANGE\n\nMultiple\nbreaking\nchange message.\n\nOnline breaking change message.\n\n\n<a name=\"1.1.0\"></a>\n## [1.1.0] - 2018-01-02\n### Features\n- **parser:** New some super options #333\n\n### Reverts\n- feat(core): Add foo bar @mention and issue #987\n\n### Pull Requests\n- Merge pull request #1000 from tsuyoshiwada/patch-1\n- Merge pull request #999 from tsuyoshiwada/patch-1\n\n\n<a name=\"1.0.0\"></a>\n## 1.0.0 - 2018-01-01\n### Features\n- **core:** Add foo bar\n\n\n[Unreleased]: https://github.com/git-chglog/git-chglog/compare/2.0.0-beta.0...HEAD\n[2.0.0-beta.0]: https://github.com/git-chglog/git-chglog/compare/1.1.0...2.0.0-beta.0\n[1.1.0]: https://github.com/git-chglog/git-chglog/compare/1.0.0...1.1.0`, expected)\n}\n\nfunc TestGeneratorWithNextTag(t *testing.T) {\n\tassert := assert.New(t)\n\ttestName := \"type_scope_subject\"\n\n\tsetup(testName, func(commit commitFunc, tag tagFunc, _ gitcmd.Client) {\n\t\tcommit(\"2018-01-01 00:00:00\", \"feat(core): version 1.0.0\", \"\")\n\t\ttag(\"1.0.0\")\n\n\t\tcommit(\"2018-02-01 00:00:00\", \"feat(core): version 2.0.0\", \"\")\n\t\ttag(\"2.0.0\")\n\n\t\tcommit(\"2018-03-01 00:00:00\", \"feat(core): version 3.0.0\", \"\")\n\t})\n\n\tgen := NewGenerator(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\t&Config{\n\t\t\tBin:        \"git\",\n\t\t\tWorkingDir: filepath.Join(testRepoRoot, testName),\n\t\t\tTemplate:   filepath.Join(cwd, \"testdata\", testName+\".md\"),\n\t\t\tInfo: &Info{\n\t\t\t\tTitle:         \"CHANGELOG Example\",\n\t\t\t\tRepositoryURL: \"https://github.com/git-chglog/git-chglog\",\n\t\t\t},\n\t\t\tOptions: &Options{\n\t\t\t\tSort:    \"date\",\n\t\t\t\tNextTag: \"3.0.0\",\n\t\t\t\tCommitFilters: map[string][]string{\n\t\t\t\t\t\"Type\": {\n\t\t\t\t\t\t\"feat\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommitSortBy:      \"Scope\",\n\t\t\t\tCommitGroupBy:     \"Type\",\n\t\t\t\tCommitGroupSortBy: \"Title\",\n\t\t\t\tCommitGroupTitleMaps: map[string]string{\n\t\t\t\t\t\"feat\": \"Features\",\n\t\t\t\t},\n\t\t\t\tHeaderPattern: \"^(\\\\w*)(?:\\\\(([\\\\w\\\\$\\\\.\\\\-\\\\*\\\\s]*)\\\\))?\\\\:\\\\s(.*)$\",\n\t\t\t\tHeaderPatternMaps: []string{\n\t\t\t\t\t\"Type\",\n\t\t\t\t\t\"Scope\",\n\t\t\t\t\t\"Subject\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tbuf := &bytes.Buffer{}\n\terr := gen.Generate(buf, \"\")\n\texpected := strings.TrimSpace(buf.String())\n\n\tassert.Nil(err)\n\tassert.Equal(`<a name=\"unreleased\"></a>\n## [Unreleased]\n\n\n<a name=\"3.0.0\"></a>\n## [3.0.0] - 2018-03-01\n### Features\n- **core:** version 3.0.0\n\n\n<a name=\"2.0.0\"></a>\n## [2.0.0] - 2018-02-01\n### Features\n- **core:** version 2.0.0\n\n\n<a name=\"1.0.0\"></a>\n## 1.0.0 - 2018-01-01\n### Features\n- **core:** version 1.0.0\n\n\n[Unreleased]: https://github.com/git-chglog/git-chglog/compare/3.0.0...HEAD\n[3.0.0]: https://github.com/git-chglog/git-chglog/compare/2.0.0...3.0.0\n[2.0.0]: https://github.com/git-chglog/git-chglog/compare/1.0.0...2.0.0`, expected)\n\n\tbuf = &bytes.Buffer{}\n\terr = gen.Generate(buf, \"3.0.0\")\n\texpected = strings.TrimSpace(buf.String())\n\n\tassert.Nil(err)\n\tassert.Equal(`<a name=\"unreleased\"></a>\n## [Unreleased]\n\n\n<a name=\"3.0.0\"></a>\n## [3.0.0] - 2018-03-01\n### Features\n- **core:** version 3.0.0\n\n\n[Unreleased]: https://github.com/git-chglog/git-chglog/compare/3.0.0...HEAD\n[3.0.0]: https://github.com/git-chglog/git-chglog/compare/2.0.0...3.0.0`, expected)\n}\n\nfunc TestGeneratorWithTagFiler(t *testing.T) {\n\tassert := assert.New(t)\n\ttestName := \"type_scope_subject\"\n\n\tsetup(testName, func(commit commitFunc, tag tagFunc, _ gitcmd.Client) {\n\t\tcommit(\"2018-01-01 00:00:00\", \"feat(core): version dev-1.0.0\", \"\")\n\t\ttag(\"dev-1.0.0\")\n\n\t\tcommit(\"2018-02-01 00:00:00\", \"feat(core): version v1.0.0\", \"\")\n\t\ttag(\"v1.0.0\")\n\t})\n\n\tgen := NewGenerator(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\t&Config{\n\t\t\tBin:        \"git\",\n\t\t\tWorkingDir: filepath.Join(testRepoRoot, testName),\n\t\t\tTemplate:   filepath.Join(cwd, \"testdata\", testName+\".md\"),\n\t\t\tInfo: &Info{\n\t\t\t\tTitle:         \"CHANGELOG Example\",\n\t\t\t\tRepositoryURL: \"https://github.com/git-chglog/git-chglog\",\n\t\t\t},\n\t\t\tOptions: &Options{\n\t\t\t\tTagFilterPattern: \"^v\",\n\t\t\t\tCommitFilters: map[string][]string{\n\t\t\t\t\t\"Type\": {\n\t\t\t\t\t\t\"feat\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommitSortBy:      \"Scope\",\n\t\t\t\tCommitGroupBy:     \"Type\",\n\t\t\t\tCommitGroupSortBy: \"Title\",\n\t\t\t\tCommitGroupTitleMaps: map[string]string{\n\t\t\t\t\t\"feat\": \"Features\",\n\t\t\t\t},\n\t\t\t\tHeaderPattern: \"^(\\\\w*)(?:\\\\(([\\\\w\\\\$\\\\.\\\\-\\\\*\\\\s]*)\\\\))?\\\\:\\\\s(.*)$\",\n\t\t\t\tHeaderPatternMaps: []string{\n\t\t\t\t\t\"Type\",\n\t\t\t\t\t\"Scope\",\n\t\t\t\t\t\"Subject\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tbuf := &bytes.Buffer{}\n\terr := gen.Generate(buf, \"\")\n\texpected := strings.TrimSpace(buf.String())\n\n\tassert.Nil(err)\n\tassert.Equal(`<a name=\"unreleased\"></a>\n## [Unreleased]\n\n\n<a name=\"v1.0.0\"></a>\n## v1.0.0 - 2018-02-01\n### Features\n- **core:** version v1.0.0\n- **core:** version dev-1.0.0\n\n\n[Unreleased]: https://github.com/git-chglog/git-chglog/compare/v1.0.0...HEAD`, expected)\n\n}\n\nfunc TestGeneratorWithTrimmedBody(t *testing.T) {\n\tassert := assert.New(t)\n\ttestName := \"trimmed_body\"\n\n\tsetup(testName, func(commit commitFunc, tag tagFunc, _ gitcmd.Client) {\n\t\tcommit(\"2018-01-01 00:00:00\", \"feat: single line commit\", \"\")\n\t\tcommit(\"2018-01-01 00:01:00\", \"feat: multi-line commit\", `\nMore details about the change and why it went in.\n\nBREAKING CHANGE:\n\nWhen using .TrimmedBody Notes are not included and can only appear in the Notes section.\n\nSigned-off-by: First Last <first.last@mail.com>\n\nCo-authored-by: dependabot-preview[bot] <27856297+dependabot-preview[bot]@users.noreply.github.com>`)\n\n\t\tcommit(\"2018-01-01 00:00:00\", \"feat: another single line commit\", \"\")\n\t\ttag(\"1.0.0\")\n\t})\n\n\tgen := NewGenerator(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\t&Config{\n\t\t\tBin:        \"git\",\n\t\t\tWorkingDir: filepath.Join(testRepoRoot, testName),\n\t\t\tTemplate:   filepath.Join(cwd, \"testdata\", testName+\".md\"),\n\t\t\tInfo: &Info{\n\t\t\t\tTitle:         \"CHANGELOG Example\",\n\t\t\t\tRepositoryURL: \"https://github.com/git-chglog/git-chglog\",\n\t\t\t},\n\t\t\tOptions: &Options{\n\t\t\t\tCommitFilters: map[string][]string{\n\t\t\t\t\t\"Type\": {\n\t\t\t\t\t\t\"feat\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommitSortBy:      \"Scope\",\n\t\t\t\tCommitGroupBy:     \"Type\",\n\t\t\t\tCommitGroupSortBy: \"Title\",\n\t\t\t\tCommitGroupTitleMaps: map[string]string{\n\t\t\t\t\t\"feat\": \"Features\",\n\t\t\t\t},\n\t\t\t\tHeaderPattern: \"^(\\\\w*)(?:\\\\(([\\\\w\\\\$\\\\.\\\\-\\\\*\\\\s]*)\\\\))?\\\\:\\\\s(.*)$\",\n\t\t\t\tHeaderPatternMaps: []string{\n\t\t\t\t\t\"Type\",\n\t\t\t\t\t\"Scope\",\n\t\t\t\t\t\"Subject\",\n\t\t\t\t},\n\t\t\t\tNoteKeywords: []string{\n\t\t\t\t\t\"BREAKING CHANGE\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tbuf := &bytes.Buffer{}\n\terr := gen.Generate(buf, \"\")\n\texpected := strings.TrimSpace(buf.String())\n\n\tassert.Nil(err)\n\tassert.Equal(`<a name=\"unreleased\"></a>\n## [Unreleased]\n\n\n<a name=\"1.0.0\"></a>\n## 1.0.0 - 2018-01-01\n### Features\n- another single line commit\n- multi-line commit\n  More details about the change and why it went in.\n- single line commit\n\n### BREAKING CHANGE\n\nWhen using .TrimmedBody Notes are not included and can only appear in the Notes section.\n\n\n[Unreleased]: https://github.com/git-chglog/git-chglog/compare/1.0.0...HEAD`, expected)\n}\n\nfunc TestGeneratorWithSprig(t *testing.T) {\n\tassert := assert.New(t)\n\ttestName := \"with_sprig\"\n\n\tsetup(testName, func(commit commitFunc, tag tagFunc, _ gitcmd.Client) {\n\t\tcommit(\"2018-01-01 00:00:00\", \"feat(core): version 1.0.0\", \"\")\n\t\ttag(\"1.0.0\")\n\n\t\tcommit(\"2018-02-01 00:00:00\", \"feat(core): version 2.0.0\", \"\")\n\t\ttag(\"2.0.0\")\n\n\t\tcommit(\"2018-03-01 00:00:00\", \"feat(core): version 3.0.0\", \"\")\n\t})\n\n\tgen := NewGenerator(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\t&Config{\n\t\t\tBin:        \"git\",\n\t\t\tWorkingDir: filepath.Join(testRepoRoot, testName),\n\t\t\tTemplate:   filepath.Join(cwd, \"testdata\", testName+\".md\"),\n\t\t\tInfo: &Info{\n\t\t\t\tTitle:         \"CHANGELOG Example\",\n\t\t\t\tRepositoryURL: \"https://github.com/git-chglog/git-chglog\",\n\t\t\t},\n\t\t\tOptions: &Options{\n\t\t\t\tSort:    \"date\",\n\t\t\t\tNextTag: \"3.0.0\",\n\t\t\t\tCommitFilters: map[string][]string{\n\t\t\t\t\t\"Type\": {\n\t\t\t\t\t\t\"feat\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommitSortBy:      \"Scope\",\n\t\t\t\tCommitGroupBy:     \"Type\",\n\t\t\t\tCommitGroupSortBy: \"Title\",\n\t\t\t\tCommitGroupTitleMaps: map[string]string{\n\t\t\t\t\t\"feat\": \"Features\",\n\t\t\t\t},\n\t\t\t\tHeaderPattern: \"^(\\\\w*)(?:\\\\(([\\\\w\\\\$\\\\.\\\\-\\\\*\\\\s]*)\\\\))?\\\\:\\\\s(.*)$\",\n\t\t\t\tHeaderPatternMaps: []string{\n\t\t\t\t\t\"Type\",\n\t\t\t\t\t\"Scope\",\n\t\t\t\t\t\"Subject\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tbuf := &bytes.Buffer{}\n\terr := gen.Generate(buf, \"\")\n\texpected := strings.TrimSpace(buf.String())\n\n\tassert.Nil(err)\n\tassert.Equal(`My Changelog\n<a name=\"unreleased\"></a>\n## [Unreleased]\n\n\n<a name=\"3.0.0\"></a>\n## [3.0.0] - 2018-03-01\n### Features\n- **CORE:** version 3.0.0\n\n\n<a name=\"2.0.0\"></a>\n## [2.0.0] - 2018-02-01\n### Features\n- **CORE:** version 2.0.0\n\n\n<a name=\"1.0.0\"></a>\n## 1.0.0 - 2018-01-01\n### Features\n- **CORE:** version 1.0.0\n\n\n[Unreleased]: https://github.com/git-chglog/git-chglog/compare/3.0.0...HEAD\n[3.0.0]: https://github.com/git-chglog/git-chglog/compare/2.0.0...3.0.0\n[2.0.0]: https://github.com/git-chglog/git-chglog/compare/1.0.0...2.0.0`, expected)\n\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "commit_extractor.go",
          "type": "blob",
          "size": 4.7490234375,
          "content": "package chglog\n\nimport (\n\t\"sort\"\n\t\"strings\"\n)\n\ntype commitExtractor struct {\n\topts *Options\n}\n\nfunc newCommitExtractor(opts *Options) *commitExtractor {\n\treturn &commitExtractor{\n\t\topts: opts,\n\t}\n}\n\nfunc (e *commitExtractor) Extract(commits []*Commit) ([]*CommitGroup, []*Commit, []*Commit, []*NoteGroup) {\n\tcommitGroups := []*CommitGroup{}\n\tnoteGroups := []*NoteGroup{}\n\tmergeCommits := []*Commit{}\n\trevertCommits := []*Commit{}\n\n\tfilteredCommits := commitFilter(commits, e.opts.CommitFilters, e.opts.NoCaseSensitive)\n\n\tfor _, commit := range commits {\n\t\tif commit.Merge != nil {\n\t\t\tmergeCommits = append(mergeCommits, commit)\n\t\t\tcontinue\n\t\t}\n\n\t\tif commit.Revert != nil {\n\t\t\trevertCommits = append(revertCommits, commit)\n\t\t\tcontinue\n\t\t}\n\t}\n\n\tfor _, commit := range filteredCommits {\n\t\tif commit.Merge == nil && commit.Revert == nil {\n\t\t\te.processCommitGroups(&commitGroups, commit, e.opts.NoCaseSensitive)\n\t\t}\n\n\t\te.processNoteGroups(&noteGroups, commit)\n\t}\n\n\te.sortCommitGroups(commitGroups)\n\te.sortNoteGroups(noteGroups)\n\n\treturn commitGroups, mergeCommits, revertCommits, noteGroups\n}\n\nfunc (e *commitExtractor) processCommitGroups(groups *[]*CommitGroup, commit *Commit, noCaseSensitive bool) {\n\tvar group *CommitGroup\n\n\t// commit group\n\traw, ttl := e.commitGroupTitle(commit)\n\n\tfor _, g := range *groups {\n\t\trawTitleTmp := g.RawTitle\n\t\tif noCaseSensitive {\n\t\t\trawTitleTmp = strings.ToLower(g.RawTitle)\n\t\t}\n\n\t\trawTmp := raw\n\t\tif noCaseSensitive {\n\t\t\trawTmp = strings.ToLower(raw)\n\t\t}\n\t\tif rawTitleTmp == rawTmp {\n\t\t\tgroup = g\n\t\t}\n\t}\n\n\tif group != nil {\n\t\tgroup.Commits = append(group.Commits, commit)\n\t} else if raw != \"\" {\n\t\t*groups = append(*groups, &CommitGroup{\n\t\t\tRawTitle: raw,\n\t\t\tTitle:    ttl,\n\t\t\tCommits:  []*Commit{commit},\n\t\t})\n\t}\n}\n\nfunc (e *commitExtractor) processNoteGroups(groups *[]*NoteGroup, commit *Commit) {\n\tif len(commit.Notes) != 0 {\n\t\tfor _, note := range commit.Notes {\n\t\t\te.appendNoteToNoteGroups(groups, note)\n\t\t}\n\t}\n}\n\nfunc (e *commitExtractor) appendNoteToNoteGroups(groups *[]*NoteGroup, note *Note) {\n\texist := false\n\n\tfor _, g := range *groups {\n\t\tif g.Title == note.Title {\n\t\t\texist = true\n\t\t\tg.Notes = append(g.Notes, note)\n\t\t}\n\t}\n\n\tif !exist {\n\t\t*groups = append(*groups, &NoteGroup{\n\t\t\tTitle: note.Title,\n\t\t\tNotes: []*Note{note},\n\t\t})\n\t}\n}\n\nfunc (e *commitExtractor) commitGroupTitle(commit *Commit) (string, string) {\n\tvar (\n\t\traw string\n\t\tttl string\n\t)\n\n\tif title, ok := dotGet(commit, e.opts.CommitGroupBy); ok {\n\t\tif v, ok := title.(string); ok {\n\t\t\traw = v\n\t\t\tif t, ok := e.opts.CommitGroupTitleMaps[v]; ok {\n\t\t\t\tttl = t\n\t\t\t} else {\n\t\t\t\t//nolint:staticcheck\n\t\t\t\tttl = strings.Title(raw)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn raw, ttl\n}\n\nfunc (e *commitExtractor) sortCommitGroups(groups []*CommitGroup) { //nolint:gocyclo\n\t// NOTE(khos2ow): this function is over our cyclomatic complexity goal.\n\t// Be wary when adding branches, and look for functionality that could\n\t// be reasonably moved into an injected dependency.\n\n\torder := make(map[string]int)\n\tif e.opts.CommitGroupSortBy == \"Custom\" {\n\t\tfor i, t := range e.opts.CommitGroupTitleOrder {\n\t\t\torder[t] = i\n\t\t}\n\t}\n\n\t// groups\n\t// TODO(khos2ow): move the inline sort function to\n\t// conceret implementation of sort.Interface in order\n\t// to reduce cyclomatic complaxity.\n\tsort.Slice(groups, func(i, j int) bool {\n\t\tif e.opts.CommitGroupSortBy == \"Custom\" {\n\t\t\treturn order[groups[i].RawTitle] < order[groups[j].RawTitle]\n\t\t}\n\n\t\tvar (\n\t\t\ta, b interface{}\n\t\t\tok   bool\n\t\t)\n\n\t\ta, ok = dotGet(groups[i], e.opts.CommitGroupSortBy)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tb, ok = dotGet(groups[j], e.opts.CommitGroupSortBy)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tres, err := compare(a, \"<\", b)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn res\n\t})\n\n\t// commits\n\tfor _, group := range groups {\n\t\tgroup := group // pin group to avoid potential bugs with passing group to lower functions\n\n\t\t// TODO(khos2ow): move the inline sort function to\n\t\t// conceret implementation of sort.Interface in order\n\t\t// to reduce cyclomatic complaxity.\n\t\tsort.Slice(group.Commits, func(i, j int) bool {\n\t\t\tvar (\n\t\t\t\ta, b interface{}\n\t\t\t\tok   bool\n\t\t\t)\n\n\t\t\ta, ok = dotGet(group.Commits[i], e.opts.CommitSortBy)\n\t\t\tif !ok {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tb, ok = dotGet(group.Commits[j], e.opts.CommitSortBy)\n\t\t\tif !ok {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tres, err := compare(a, \"<\", b)\n\t\t\tif err != nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn res\n\t\t})\n\t}\n}\n\nfunc (e *commitExtractor) sortNoteGroups(groups []*NoteGroup) {\n\t// groups\n\tsort.Slice(groups, func(i, j int) bool {\n\t\treturn strings.ToLower(groups[i].Title) < strings.ToLower(groups[j].Title)\n\t})\n\n\t// notes\n\tfor _, group := range groups {\n\t\tgroup := group // pin group to avoid potential bugs with passing group to lower functions\n\t\tsort.Slice(group.Notes, func(i, j int) bool {\n\t\t\treturn strings.ToLower(group.Notes[i].Title) < strings.ToLower(group.Notes[j].Title)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "commit_extractor_test.go",
          "type": "blob",
          "size": 4.119140625,
          "content": "package chglog\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCommitExtractor(t *testing.T) {\n\tassert := assert.New(t)\n\n\textractor := newCommitExtractor(&Options{\n\t\tCommitSortBy:      \"Scope\",\n\t\tCommitGroupBy:     \"Type\",\n\t\tCommitGroupSortBy: \"Title\",\n\t\tCommitGroupTitleMaps: map[string]string{\n\t\t\t\"bar\": \"BAR\",\n\t\t},\n\t})\n\n\tfixtures := []*Commit{\n\t\t// [0]\n\t\t{\n\t\t\tType:   \"foo\",\n\t\t\tScope:  \"c\",\n\t\t\tHeader: \"1\",\n\t\t\tNotes:  []*Note{},\n\t\t},\n\t\t// [1]\n\t\t{\n\t\t\tType:   \"foo\",\n\t\t\tScope:  \"b\",\n\t\t\tHeader: \"2\",\n\t\t\tNotes: []*Note{\n\t\t\t\t{\"note1-title\", \"note1-body\"},\n\t\t\t\t{\"note2-title\", \"note2-body\"},\n\t\t\t},\n\t\t},\n\t\t// [2]\n\t\t{\n\t\t\tType:   \"bar\",\n\t\t\tScope:  \"d\",\n\t\t\tHeader: \"3\",\n\t\t\tNotes: []*Note{\n\t\t\t\t{\"note1-title\", \"note1-body\"},\n\t\t\t\t{\"note3-title\", \"note3-body\"},\n\t\t\t},\n\t\t},\n\t\t// [3]\n\t\t{\n\t\t\tType:   \"foo\",\n\t\t\tScope:  \"a\",\n\t\t\tHeader: \"4\",\n\t\t\tNotes: []*Note{\n\t\t\t\t{\"note4-title\", \"note4-body\"},\n\t\t\t},\n\t\t},\n\t\t// [4]\n\t\t{\n\t\t\tType:   \"\",\n\t\t\tScope:  \"\",\n\t\t\tHeader: \"Merge1\",\n\t\t\tNotes:  []*Note{},\n\t\t\tMerge: &Merge{\n\t\t\t\tRef:    \"123\",\n\t\t\t\tSource: \"merges/merge1\",\n\t\t\t},\n\t\t},\n\t\t// [5]\n\t\t{\n\t\t\tType:   \"\",\n\t\t\tScope:  \"\",\n\t\t\tHeader: \"Revert1\",\n\t\t\tNotes:  []*Note{},\n\t\t\tRevert: &Revert{\n\t\t\t\tHeader: \"REVERT1\",\n\t\t\t},\n\t\t},\n\t}\n\n\tcommitGroups, mergeCommits, revertCommits, noteGroups := extractor.Extract(fixtures)\n\n\tassert.Equal([]*CommitGroup{\n\t\t{\n\t\t\tRawTitle: \"bar\",\n\t\t\tTitle:    \"BAR\",\n\t\t\tCommits: []*Commit{\n\t\t\t\tfixtures[2],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tRawTitle: \"foo\",\n\t\t\tTitle:    \"Foo\",\n\t\t\tCommits: []*Commit{\n\t\t\t\tfixtures[3],\n\t\t\t\tfixtures[1],\n\t\t\t\tfixtures[0],\n\t\t\t},\n\t\t},\n\t}, commitGroups)\n\n\tassert.Equal([]*Commit{\n\t\tfixtures[4],\n\t}, mergeCommits)\n\n\tassert.Equal([]*Commit{\n\t\tfixtures[5],\n\t}, revertCommits)\n\n\tassert.Equal([]*NoteGroup{\n\t\t{\n\t\t\tTitle: \"note1-title\",\n\t\t\tNotes: []*Note{\n\t\t\t\tfixtures[1].Notes[0],\n\t\t\t\tfixtures[2].Notes[0],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tTitle: \"note2-title\",\n\t\t\tNotes: []*Note{\n\t\t\t\tfixtures[1].Notes[1],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tTitle: \"note3-title\",\n\t\t\tNotes: []*Note{\n\t\t\t\tfixtures[2].Notes[1],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tTitle: \"note4-title\",\n\t\t\tNotes: []*Note{\n\t\t\t\tfixtures[3].Notes[0],\n\t\t\t},\n\t\t},\n\t}, noteGroups)\n}\n\nfunc TestCommitOrderExtractor(t *testing.T) {\n\tassert := assert.New(t)\n\n\textractor := newCommitExtractor(&Options{\n\t\tCommitSortBy:          \"Scope\",\n\t\tCommitGroupBy:         \"Type\",\n\t\tCommitGroupSortBy:     \"Custom\",\n\t\tCommitGroupTitleOrder: []string{\"foo\", \"bar\"},\n\t\tCommitGroupTitleMaps: map[string]string{\n\t\t\t\"bar\": \"BAR\",\n\t\t},\n\t})\n\n\tfixtures := []*Commit{\n\t\t// [0]\n\t\t{\n\t\t\tType:   \"foo\",\n\t\t\tScope:  \"c\",\n\t\t\tHeader: \"1\",\n\t\t\tNotes:  []*Note{},\n\t\t},\n\t\t// [1]\n\t\t{\n\t\t\tType:   \"foo\",\n\t\t\tScope:  \"b\",\n\t\t\tHeader: \"2\",\n\t\t\tNotes: []*Note{\n\t\t\t\t{\"note1-title\", \"note1-body\"},\n\t\t\t\t{\"note2-title\", \"note2-body\"},\n\t\t\t},\n\t\t},\n\t\t// [2]\n\t\t{\n\t\t\tType:   \"bar\",\n\t\t\tScope:  \"d\",\n\t\t\tHeader: \"3\",\n\t\t\tNotes: []*Note{\n\t\t\t\t{\"note1-title\", \"note1-body\"},\n\t\t\t\t{\"note3-title\", \"note3-body\"},\n\t\t\t},\n\t\t},\n\t\t// [3]\n\t\t{\n\t\t\tType:   \"foo\",\n\t\t\tScope:  \"a\",\n\t\t\tHeader: \"4\",\n\t\t\tNotes: []*Note{\n\t\t\t\t{\"note4-title\", \"note4-body\"},\n\t\t\t},\n\t\t},\n\t\t// [4]\n\t\t{\n\t\t\tType:   \"\",\n\t\t\tScope:  \"\",\n\t\t\tHeader: \"Merge1\",\n\t\t\tNotes:  []*Note{},\n\t\t\tMerge: &Merge{\n\t\t\t\tRef:    \"123\",\n\t\t\t\tSource: \"merges/merge1\",\n\t\t\t},\n\t\t},\n\t\t// [5]\n\t\t{\n\t\t\tType:   \"\",\n\t\t\tScope:  \"\",\n\t\t\tHeader: \"Revert1\",\n\t\t\tNotes:  []*Note{},\n\t\t\tRevert: &Revert{\n\t\t\t\tHeader: \"REVERT1\",\n\t\t\t},\n\t\t},\n\t}\n\n\tcommitGroups, mergeCommits, revertCommits, noteGroups := extractor.Extract(fixtures)\n\n\tassert.Equal([]*CommitGroup{\n\t\t{\n\t\t\tRawTitle: \"foo\",\n\t\t\tTitle:    \"Foo\",\n\t\t\tCommits: []*Commit{\n\t\t\t\tfixtures[3],\n\t\t\t\tfixtures[1],\n\t\t\t\tfixtures[0],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tRawTitle: \"bar\",\n\t\t\tTitle:    \"BAR\",\n\t\t\tCommits: []*Commit{\n\t\t\t\tfixtures[2],\n\t\t\t},\n\t\t},\n\t}, commitGroups)\n\n\tassert.Equal([]*Commit{\n\t\tfixtures[4],\n\t}, mergeCommits)\n\n\tassert.Equal([]*Commit{\n\t\tfixtures[5],\n\t}, revertCommits)\n\n\tassert.Equal([]*NoteGroup{\n\t\t{\n\t\t\tTitle: \"note1-title\",\n\t\t\tNotes: []*Note{\n\t\t\t\tfixtures[1].Notes[0],\n\t\t\t\tfixtures[2].Notes[0],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tTitle: \"note2-title\",\n\t\t\tNotes: []*Note{\n\t\t\t\tfixtures[1].Notes[1],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tTitle: \"note3-title\",\n\t\t\tNotes: []*Note{\n\t\t\t\tfixtures[2].Notes[1],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tTitle: \"note4-title\",\n\t\t\tNotes: []*Note{\n\t\t\t\tfixtures[3].Notes[0],\n\t\t\t},\n\t\t},\n\t}, noteGroups)\n}\n"
        },
        {
          "name": "commit_filter.go",
          "type": "blob",
          "size": 1.015625,
          "content": "package chglog\n\nimport (\n\t\"strings\"\n)\n\nfunc commitFilter(commits []*Commit, filters map[string][]string, noCaseSensitive bool) []*Commit { //nolint:gocyclo\n\t// NOTE(khos2ow): this function is over our cyclomatic complexity goal.\n\t// Be wary when adding branches, and look for functionality that could\n\t// be reasonably moved into an injected dependency.\n\n\tres := []*Commit{}\n\n\tfor _, commit := range commits {\n\t\tinclude := false\n\n\t\tif len(filters) == 0 {\n\t\t\tinclude = true\n\t\t}\n\n\t\tfor key, values := range filters {\n\t\t\tprop, ok := dotGet(commit, key)\n\t\t\tif !ok {\n\t\t\t\tinclude = false\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tstr, ok := prop.(string)\n\t\t\tif !ok {\n\t\t\t\tinclude = false\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif noCaseSensitive {\n\t\t\t\tstr = strings.ToLower(str)\n\t\t\t}\n\n\t\t\texist := false\n\n\t\t\tfor _, val := range values {\n\t\t\t\tif noCaseSensitive {\n\t\t\t\t\tval = strings.ToLower(val)\n\t\t\t\t}\n\n\t\t\t\tif str == val {\n\t\t\t\t\texist = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !exist {\n\t\t\t\tinclude = false\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tinclude = true\n\t\t}\n\n\t\tif include {\n\t\t\tres = append(res, commit)\n\t\t}\n\t}\n\n\treturn res\n}\n"
        },
        {
          "name": "commit_filter_test.go",
          "type": "blob",
          "size": 2.0830078125,
          "content": "package chglog\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCommitFilter(t *testing.T) {\n\tassert := assert.New(t)\n\n\tpickCommitSubjects := func(arr []*Commit) []string {\n\t\tres := make([]string, len(arr))\n\t\tfor i, commit := range arr {\n\t\t\tres[i] = commit.Subject\n\t\t}\n\t\treturn res\n\t}\n\n\tfixtures := []*Commit{\n\t\t{\n\t\t\tType:    \"foo\",\n\t\t\tScope:   \"hoge\",\n\t\t\tSubject: \"1\",\n\t\t},\n\t\t{\n\t\t\tType:    \"foo\",\n\t\t\tScope:   \"fuga\",\n\t\t\tSubject: \"2\",\n\t\t},\n\t\t{\n\t\t\tType:    \"bar\",\n\t\t\tScope:   \"hoge\",\n\t\t\tSubject: \"3\",\n\t\t},\n\t\t{\n\t\t\tType:    \"bar\",\n\t\t\tScope:   \"fuga\",\n\t\t\tSubject: \"4\",\n\t\t},\n\t\t{\n\t\t\tType:    \"Bar\",\n\t\t\tScope:   \"hogera\",\n\t\t\tSubject: \"5\",\n\t\t},\n\t}\n\n\tassert.Equal(\n\t\t[]string{\n\t\t\t\"1\",\n\t\t\t\"2\",\n\t\t\t\"3\",\n\t\t\t\"4\",\n\t\t\t\"5\",\n\t\t},\n\t\tpickCommitSubjects(commitFilter(fixtures, map[string][]string{}, false)),\n\t)\n\n\tassert.Equal(\n\t\t[]string{\n\t\t\t\"1\",\n\t\t\t\"2\",\n\t\t\t\"3\",\n\t\t\t\"4\",\n\t\t},\n\t\tpickCommitSubjects(commitFilter(fixtures, map[string][]string{\n\t\t\t\"Type\": {\"foo\", \"bar\"},\n\t\t}, false)),\n\t)\n\n\tassert.Equal(\n\t\t[]string{\n\t\t\t\"1\",\n\t\t\t\"2\",\n\t\t\t\"3\",\n\t\t\t\"4\",\n\t\t\t\"5\",\n\t\t},\n\t\tpickCommitSubjects(commitFilter(fixtures, map[string][]string{\n\t\t\t\"Type\": {\"foo\", \"bar\"},\n\t\t}, true)),\n\t)\n\n\tassert.Equal(\n\t\t[]string{\n\t\t\t\"1\",\n\t\t\t\"2\",\n\t\t},\n\t\tpickCommitSubjects(commitFilter(fixtures, map[string][]string{\n\t\t\t\"Type\": {\"foo\"},\n\t\t}, false)),\n\t)\n\n\tassert.Equal(\n\t\t[]string{\n\t\t\t\"3\",\n\t\t\t\"4\",\n\t\t},\n\t\tpickCommitSubjects(commitFilter(fixtures, map[string][]string{\n\t\t\t\"Type\": {\"bar\"},\n\t\t}, false)),\n\t)\n\n\tassert.Equal(\n\t\t[]string{\n\t\t\t\"3\",\n\t\t\t\"4\",\n\t\t\t\"5\",\n\t\t},\n\t\tpickCommitSubjects(commitFilter(fixtures, map[string][]string{\n\t\t\t\"Type\": {\"bar\"},\n\t\t}, true)),\n\t)\n\n\tassert.Equal(\n\t\t[]string{\n\t\t\t\"2\",\n\t\t\t\"4\",\n\t\t},\n\t\tpickCommitSubjects(commitFilter(fixtures, map[string][]string{\n\t\t\t\"Scope\": {\"fuga\"},\n\t\t}, false)),\n\t)\n\n\tassert.Equal(\n\t\t[]string{\n\t\t\t\"3\",\n\t\t},\n\t\tpickCommitSubjects(commitFilter(fixtures, map[string][]string{\n\t\t\t\"Type\":  {\"bar\"},\n\t\t\t\"Scope\": {\"hoge\"},\n\t\t}, false)),\n\t)\n\n\tassert.Equal(\n\t\t[]string{\n\t\t\t\"1\",\n\t\t\t\"2\",\n\t\t},\n\t\tpickCommitSubjects(commitFilter(fixtures, map[string][]string{\n\t\t\t\"Type\":  {\"foo\"},\n\t\t\t\"Scope\": {\"fuga\", \"hoge\"},\n\t\t}, false)),\n\t)\n}\n"
        },
        {
          "name": "commit_parser.go",
          "type": "blob",
          "size": 10.578125,
          "content": "package chglog\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/tsuyoshiwada/go-gitcmd\"\n)\n\nvar (\n\t// constants\n\tseparator = \"@@__CHGLOG__@@\"\n\tdelimiter = \"@@__CHGLOG_DELIMITER__@@\"\n\n\t// fields\n\thashField      = \"HASH\"\n\tauthorField    = \"AUTHOR\"\n\tcommitterField = \"COMMITTER\"\n\tsubjectField   = \"SUBJECT\"\n\tbodyField      = \"BODY\"\n\n\t// formats\n\thashFormat      = hashField + \":%H\\t%h\"\n\tauthorFormat    = authorField + \":%an\\t%ae\\t%at\"\n\tcommitterFormat = committerField + \":%cn\\t%ce\\t%ct\"\n\tsubjectFormat   = subjectField + \":%s\"\n\tbodyFormat      = bodyField + \":%b\"\n\n\t// log\n\tlogFormat = separator + strings.Join([]string{\n\t\thashFormat,\n\t\tauthorFormat,\n\t\tcommitterFormat,\n\t\tsubjectFormat,\n\t\tbodyFormat,\n\t}, delimiter)\n)\n\nfunc joinAndQuoteMeta(list []string, sep string) string {\n\tarr := make([]string, len(list))\n\tfor i, s := range list {\n\t\tarr[i] = regexp.QuoteMeta(s)\n\t}\n\treturn strings.Join(arr, sep)\n}\n\ntype commitParser struct {\n\tlogger                 *Logger\n\tclient                 gitcmd.Client\n\tjiraClient             JiraClient\n\tconfig                 *Config\n\treHeader               *regexp.Regexp\n\treMerge                *regexp.Regexp\n\treRevert               *regexp.Regexp\n\treRef                  *regexp.Regexp\n\treIssue                *regexp.Regexp\n\treNotes                *regexp.Regexp\n\treMention              *regexp.Regexp\n\treSignOff              *regexp.Regexp\n\treCoAuthor             *regexp.Regexp\n\treJiraIssueDescription *regexp.Regexp\n}\n\nfunc newCommitParser(logger *Logger, client gitcmd.Client, jiraClient JiraClient, config *Config) *commitParser {\n\topts := config.Options\n\n\tjoinedRefActions := joinAndQuoteMeta(opts.RefActions, \"|\")\n\tjoinedIssuePrefix := joinAndQuoteMeta(opts.IssuePrefix, \"|\")\n\tjoinedNoteKeywords := joinAndQuoteMeta(opts.NoteKeywords, \"|\")\n\n\treturn &commitParser{\n\t\tlogger:                 logger,\n\t\tclient:                 client,\n\t\tjiraClient:             jiraClient,\n\t\tconfig:                 config,\n\t\treHeader:               regexp.MustCompile(opts.HeaderPattern),\n\t\treMerge:                regexp.MustCompile(opts.MergePattern),\n\t\treRevert:               regexp.MustCompile(opts.RevertPattern),\n\t\treRef:                  regexp.MustCompile(\"(?i)(\" + joinedRefActions + \")\\\\s?([\\\\w/\\\\.\\\\-]+)?(?:\" + joinedIssuePrefix + \")(\\\\d+)\"),\n\t\treIssue:                regexp.MustCompile(\"(?:\" + joinedIssuePrefix + \")(\\\\d+)\"),\n\t\treNotes:                regexp.MustCompile(\"^(?i)\\\\s*(\" + joinedNoteKeywords + \")[:\\\\s]+(.*)\"),\n\t\treMention:              regexp.MustCompile(`@([\\w-]+)`),\n\t\treSignOff:              regexp.MustCompile(`Signed-off-by:\\s+([\\p{L}\\s\\-\\[\\]]+)\\s+<([\\w+\\-\\[\\].@]+)>`),\n\t\treCoAuthor:             regexp.MustCompile(`Co-authored-by:\\s+([\\p{L}\\s\\-\\[\\]]+)\\s+<([\\w+\\-\\[\\].@]+)>`),\n\t\treJiraIssueDescription: regexp.MustCompile(opts.JiraIssueDescriptionPattern),\n\t}\n}\n\nfunc (p *commitParser) Parse(rev string) ([]*Commit, error) {\n\tpaths := p.config.Options.Paths\n\n\targs := []string{\n\t\trev,\n\t\t\"--no-decorate\",\n\t\t\"--pretty=\" + logFormat,\n\t}\n\n\tif len(paths) > 0 {\n\t\targs = append(args, \"--\")\n\t\targs = append(args, paths...)\n\t}\n\n\tout, err := p.client.Exec(\"log\", args...)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tprocessor := p.config.Options.Processor\n\tlines := strings.Split(out, separator)\n\tlines = lines[1:]\n\tcommits := make([]*Commit, len(lines))\n\n\tfor i, line := range lines {\n\t\tcommit := p.parseCommit(line)\n\n\t\tif processor != nil {\n\t\t\tcommit = processor.ProcessCommit(commit)\n\t\t\tif commit == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tcommits[i] = commit\n\t}\n\n\treturn commits, nil\n}\n\nfunc (p *commitParser) parseCommit(input string) *Commit {\n\tcommit := &Commit{}\n\ttokens := strings.Split(input, delimiter)\n\n\tfor _, token := range tokens {\n\t\tfirstSep := strings.Index(token, \":\")\n\t\tfield := token[0:firstSep]\n\t\tvalue := strings.TrimSpace(token[firstSep+1:])\n\n\t\tswitch field {\n\t\tcase hashField:\n\t\t\tcommit.Hash = p.parseHash(value)\n\t\tcase authorField:\n\t\t\tcommit.Author = p.parseAuthor(value)\n\t\tcase committerField:\n\t\t\tcommit.Committer = p.parseCommitter(value)\n\t\tcase subjectField:\n\t\t\tp.processHeader(commit, value)\n\t\tcase bodyField:\n\t\t\tp.processBody(commit, value)\n\t\t}\n\t}\n\n\tcommit.Refs = p.uniqRefs(commit.Refs)\n\tcommit.Mentions = p.uniqMentions(commit.Mentions)\n\n\treturn commit\n}\n\nfunc (p *commitParser) parseHash(input string) *Hash {\n\tarr := strings.Split(input, \"\\t\")\n\n\treturn &Hash{\n\t\tLong:  arr[0],\n\t\tShort: arr[1],\n\t}\n}\n\nfunc (p *commitParser) parseAuthor(input string) *Author {\n\tarr := strings.Split(input, \"\\t\")\n\tts, err := strconv.Atoi(arr[2])\n\tif err != nil {\n\t\tts = 0\n\t}\n\n\treturn &Author{\n\t\tName:  arr[0],\n\t\tEmail: arr[1],\n\t\tDate:  time.Unix(int64(ts), 0),\n\t}\n}\n\nfunc (p *commitParser) parseCommitter(input string) *Committer {\n\tauthor := p.parseAuthor(input)\n\n\treturn &Committer{\n\t\tName:  author.Name,\n\t\tEmail: author.Email,\n\t\tDate:  author.Date,\n\t}\n}\n\nfunc (p *commitParser) processHeader(commit *Commit, input string) {\n\topts := p.config.Options\n\n\t// header (raw)\n\tcommit.Header = input\n\n\tvar res [][]string\n\n\t// Type, Scope, Subject etc ...\n\tres = p.reHeader.FindAllStringSubmatch(input, -1)\n\tif len(res) > 0 {\n\t\tassignDynamicValues(commit, opts.HeaderPatternMaps, res[0][1:])\n\t}\n\n\t// Merge\n\tres = p.reMerge.FindAllStringSubmatch(input, -1)\n\tif len(res) > 0 {\n\t\tmerge := &Merge{}\n\t\tassignDynamicValues(merge, opts.MergePatternMaps, res[0][1:])\n\t\tcommit.Merge = merge\n\t}\n\n\t// Revert\n\tres = p.reRevert.FindAllStringSubmatch(input, -1)\n\tif len(res) > 0 {\n\t\trevert := &Revert{}\n\t\tassignDynamicValues(revert, opts.RevertPatternMaps, res[0][1:])\n\t\tcommit.Revert = revert\n\t}\n\n\t// refs & mentions\n\tcommit.Refs = p.parseRefs(input)\n\tcommit.Mentions = p.parseMentions(input)\n\n\t// Jira\n\tif commit.JiraIssueID != \"\" {\n\t\tp.processJiraIssue(commit, commit.JiraIssueID)\n\t}\n}\n\nfunc (p *commitParser) extractLineMetadata(commit *Commit, line string) bool {\n\tmeta := false\n\n\trefs := p.parseRefs(line)\n\tif len(refs) > 0 {\n\t\tmeta = true\n\t\tcommit.Refs = append(commit.Refs, refs...)\n\t}\n\n\tmentions := p.parseMentions(line)\n\tif len(mentions) > 0 {\n\t\tmeta = true\n\t\tcommit.Mentions = append(commit.Mentions, mentions...)\n\t}\n\n\tcoAuthors := p.parseCoAuthors(line)\n\tif len(coAuthors) > 0 {\n\t\tmeta = true\n\t\tcommit.CoAuthors = append(commit.CoAuthors, coAuthors...)\n\t}\n\n\tsigners := p.parseSigners(line)\n\tif len(signers) > 0 {\n\t\tmeta = true\n\t\tcommit.Signers = append(commit.Signers, signers...)\n\t}\n\n\treturn meta\n}\n\nfunc (p *commitParser) processBody(commit *Commit, input string) {\n\tinput = convNewline(input, \"\\n\")\n\n\t// body\n\tcommit.Body = input\n\n\t// notes & refs & mentions\n\tcommit.Notes = []*Note{}\n\tinNote := false\n\ttrim := false\n\tfenceDetector := newMdFenceDetector()\n\tlines := strings.Split(input, \"\\n\")\n\n\t// body without notes & refs & mentions\n\ttrimmedBody := make([]string, 0, len(lines))\n\n\tfor _, line := range lines {\n\t\tif !inNote {\n\t\t\ttrim = false\n\t\t}\n\t\tfenceDetector.Update(line)\n\n\t\tif !fenceDetector.InCodeblock() && p.extractLineMetadata(commit, line) {\n\t\t\ttrim = true\n\t\t\tinNote = false\n\t\t}\n\t\t// Q: should this check also only be outside of code blocks?\n\t\tres := p.reNotes.FindAllStringSubmatch(line, -1)\n\n\t\tif len(res) > 0 {\n\t\t\tinNote = true\n\t\t\ttrim = true\n\t\t\tfor _, r := range res {\n\t\t\t\tcommit.Notes = append(commit.Notes, &Note{\n\t\t\t\t\tTitle: r[1],\n\t\t\t\t\tBody:  r[2],\n\t\t\t\t})\n\t\t\t}\n\t\t} else if inNote {\n\t\t\tlast := commit.Notes[len(commit.Notes)-1]\n\t\t\tlast.Body = last.Body + \"\\n\" + line\n\t\t}\n\n\t\tif !trim {\n\t\t\ttrimmedBody = append(trimmedBody, line)\n\t\t}\n\t}\n\n\tcommit.TrimmedBody = strings.TrimSpace(strings.Join(trimmedBody, \"\\n\"))\n\tp.trimSpaceInNotes(commit)\n}\n\nfunc (*commitParser) trimSpaceInNotes(commit *Commit) {\n\tfor _, note := range commit.Notes {\n\t\tnote.Body = strings.TrimSpace(note.Body)\n\t}\n}\n\nfunc (p *commitParser) parseRefs(input string) []*Ref {\n\trefs := []*Ref{}\n\n\t// references\n\tres := p.reRef.FindAllStringSubmatch(input, -1)\n\n\tfor _, r := range res {\n\t\trefs = append(refs, &Ref{\n\t\t\tAction: r[1],\n\t\t\tSource: r[2],\n\t\t\tRef:    r[3],\n\t\t})\n\t}\n\n\t// issues\n\tres = p.reIssue.FindAllStringSubmatch(input, -1)\n\tfor _, r := range res {\n\t\tduplicate := false\n\t\tfor _, ref := range refs {\n\t\t\tif ref.Ref == r[1] {\n\t\t\t\tduplicate = true\n\t\t\t}\n\t\t}\n\t\tif !duplicate {\n\t\t\trefs = append(refs, &Ref{\n\t\t\t\tAction: \"\",\n\t\t\t\tSource: \"\",\n\t\t\t\tRef:    r[1],\n\t\t\t})\n\t\t}\n\t}\n\n\treturn refs\n}\n\nfunc (p *commitParser) parseSigners(input string) []Contact {\n\tres := p.reSignOff.FindAllStringSubmatch(input, -1)\n\tcontacts := make([]Contact, len(res))\n\n\tfor i, r := range res {\n\t\tcontacts[i].Name = r[1]\n\t\tcontacts[i].Email = r[2]\n\t}\n\n\treturn contacts\n}\n\nfunc (p *commitParser) parseCoAuthors(input string) []Contact {\n\tres := p.reCoAuthor.FindAllStringSubmatch(input, -1)\n\tcontacts := make([]Contact, len(res))\n\n\tfor i, r := range res {\n\t\tcontacts[i].Name = r[1]\n\t\tcontacts[i].Email = r[2]\n\t}\n\n\treturn contacts\n}\n\nfunc (p *commitParser) parseMentions(input string) []string {\n\tres := p.reMention.FindAllStringSubmatch(input, -1)\n\tmentions := make([]string, len(res))\n\n\tfor i, r := range res {\n\t\tmentions[i] = r[1]\n\t}\n\n\treturn mentions\n}\n\nfunc (p *commitParser) uniqRefs(refs []*Ref) []*Ref {\n\tarr := []*Ref{}\n\n\tfor _, ref := range refs {\n\t\texist := false\n\t\tfor _, r := range arr {\n\t\t\tif ref.Ref == r.Ref && ref.Action == r.Action && ref.Source == r.Source {\n\t\t\t\texist = true\n\t\t\t}\n\t\t}\n\t\tif !exist {\n\t\t\tarr = append(arr, ref)\n\t\t}\n\t}\n\n\treturn arr\n}\n\nfunc (p *commitParser) uniqMentions(mentions []string) []string {\n\tarr := []string{}\n\n\tfor _, mention := range mentions {\n\t\texist := false\n\t\tfor _, m := range arr {\n\t\t\tif mention == m {\n\t\t\t\texist = true\n\t\t\t}\n\t\t}\n\t\tif !exist {\n\t\t\tarr = append(arr, mention)\n\t\t}\n\t}\n\n\treturn arr\n}\n\nfunc (p *commitParser) processJiraIssue(commit *Commit, issueID string) {\n\tissue, err := p.jiraClient.GetJiraIssue(commit.JiraIssueID)\n\tif err != nil {\n\t\tp.logger.Error(fmt.Sprintf(\"Failed to parse Jira story %s: %s\\n\", issueID, err))\n\t\treturn\n\t}\n\tcommit.Type = p.config.Options.JiraTypeMaps[issue.Fields.Type.Name]\n\tcommit.JiraIssue = &JiraIssue{\n\t\tType:        issue.Fields.Type.Name,\n\t\tSummary:     issue.Fields.Summary,\n\t\tDescription: issue.Fields.Description,\n\t\tLabels:      issue.Fields.Labels,\n\t}\n\n\tif p.config.Options.JiraIssueDescriptionPattern != \"\" {\n\t\tres := p.reJiraIssueDescription.FindStringSubmatch(commit.JiraIssue.Description)\n\t\tif len(res) > 1 {\n\t\t\tcommit.JiraIssue.Description = res[1]\n\t\t}\n\t}\n}\n\nvar (\n\tfenceTypes = []string{\n\t\t\"```\",\n\t\t\"~~~\",\n\t\t\"    \",\n\t\t\"\\t\",\n\t}\n)\n\ntype mdFenceDetector struct {\n\tfence int\n}\n\nfunc newMdFenceDetector() *mdFenceDetector {\n\treturn &mdFenceDetector{\n\t\tfence: -1,\n\t}\n}\n\nfunc (d *mdFenceDetector) InCodeblock() bool {\n\treturn d.fence > -1\n}\n\nfunc (d *mdFenceDetector) Update(input string) {\n\tfor i, s := range fenceTypes {\n\t\tif d.fence < 0 {\n\t\t\tif strings.Index(input, s) == 0 {\n\t\t\t\td.fence = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tif strings.Index(input, s) == 0 && i == d.fence {\n\t\t\t\td.fence = -1\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "commit_parser_test.go",
          "type": "blob",
          "size": 9.3876953125,
          "content": "package chglog\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\tagjira \"github.com/andygrunwald/go-jira\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCommitParserParse(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.True(true)\n\n\tmock := &mockClient{\n\t\tReturnExec: func(subcmd string, args ...string) (string, error) {\n\t\t\tif subcmd != \"log\" {\n\t\t\t\treturn \"\", errors.New(\"\")\n\t\t\t}\n\n\t\t\tbytes, _ := os.ReadFile(filepath.Join(\"testdata\", \"gitlog.txt\"))\n\n\t\t\treturn string(bytes), nil\n\t\t},\n\t}\n\n\tparser := newCommitParser(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\tmock, nil, &Config{\n\t\t\tOptions: &Options{\n\t\t\t\tCommitFilters: map[string][]string{\n\t\t\t\t\t\"Type\": {\n\t\t\t\t\t\t\"feat\",\n\t\t\t\t\t\t\"fix\",\n\t\t\t\t\t\t\"perf\",\n\t\t\t\t\t\t\"refactor\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tHeaderPattern: \"^(\\\\w*)(?:\\\\(([\\\\w\\\\$\\\\.\\\\-\\\\*\\\\s]*)\\\\))?\\\\:\\\\s(.*)$\",\n\t\t\t\tHeaderPatternMaps: []string{\n\t\t\t\t\t\"Type\",\n\t\t\t\t\t\"Scope\",\n\t\t\t\t\t\"Subject\",\n\t\t\t\t},\n\t\t\t\tIssuePrefix: []string{\n\t\t\t\t\t\"#\",\n\t\t\t\t\t\"gh-\",\n\t\t\t\t},\n\t\t\t\tRefActions: []string{\n\t\t\t\t\t\"close\",\n\t\t\t\t\t\"closes\",\n\t\t\t\t\t\"closed\",\n\t\t\t\t\t\"fix\",\n\t\t\t\t\t\"fixes\",\n\t\t\t\t\t\"fixed\",\n\t\t\t\t\t\"resolve\",\n\t\t\t\t\t\"resolves\",\n\t\t\t\t\t\"resolved\",\n\t\t\t\t},\n\t\t\t\tMergePattern: \"^Merge pull request #(\\\\d+) from (.*)$\",\n\t\t\t\tMergePatternMaps: []string{\n\t\t\t\t\t\"Ref\",\n\t\t\t\t\t\"Source\",\n\t\t\t\t},\n\t\t\t\tRevertPattern: \"^Revert \\\"([\\\\s\\\\S]*)\\\"$\",\n\t\t\t\tRevertPatternMaps: []string{\n\t\t\t\t\t\"Header\",\n\t\t\t\t},\n\t\t\t\tNoteKeywords: []string{\n\t\t\t\t\t\"BREAKING CHANGE\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tcommits, err := parser.Parse(\"HEAD\")\n\tassert.Nil(err)\n\tassert.Equal([]*Commit{\n\t\t{\n\t\t\tHash: &Hash{\n\t\t\t\tLong:  \"65cf1add9735dcc4810dda3312b0792236c97c4e\",\n\t\t\t\tShort: \"65cf1add\",\n\t\t\t},\n\t\t\tAuthor: &Author{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1514808000), 0),\n\t\t\t},\n\t\t\tCommitter: &Committer{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1514808000), 0),\n\t\t\t},\n\t\t\tMerge:  nil,\n\t\t\tRevert: nil,\n\t\t\tRefs: []*Ref{\n\t\t\t\t{\n\t\t\t\t\tAction: \"\",\n\t\t\t\t\tRef:    \"123\",\n\t\t\t\t\tSource: \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tNotes:       []*Note{},\n\t\t\tMentions:    []string{},\n\t\t\tHeader:      \"feat(*): Add new feature #123\",\n\t\t\tType:        \"feat\",\n\t\t\tScope:       \"*\",\n\t\t\tSubject:     \"Add new feature #123\",\n\t\t\tBody:        \"\",\n\t\t\tTrimmedBody: \"\",\n\t\t},\n\t\t{\n\t\t\tHash: &Hash{\n\t\t\t\tLong:  \"14ef0b6d386c5432af9292eab3c8314fa3001bc7\",\n\t\t\t\tShort: \"14ef0b6d\",\n\t\t\t},\n\t\t\tAuthor: &Author{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1515153600), 0),\n\t\t\t},\n\t\t\tCommitter: &Committer{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1515153600), 0),\n\t\t\t},\n\t\t\tMerge: &Merge{\n\t\t\t\tRef:    \"3\",\n\t\t\t\tSource: \"username/branchname\",\n\t\t\t},\n\t\t\tRevert: nil,\n\t\t\tRefs: []*Ref{\n\t\t\t\t{\n\t\t\t\t\tAction: \"\",\n\t\t\t\t\tRef:    \"3\",\n\t\t\t\t\tSource: \"\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAction: \"Fixes\",\n\t\t\t\t\tRef:    \"3\",\n\t\t\t\t\tSource: \"\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAction: \"Closes\",\n\t\t\t\t\tRef:    \"1\",\n\t\t\t\t\tSource: \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tNotes: []*Note{\n\t\t\t\t{\n\t\t\t\t\tTitle: \"BREAKING CHANGE\",\n\t\t\t\t\tBody:  \"This is breaking point message.\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tMentions: []string{},\n\t\t\tHeader:   \"Merge pull request #3 from username/branchname\",\n\t\t\tType:     \"\",\n\t\t\tScope:    \"\",\n\t\t\tSubject:  \"\",\n\t\t\tBody: `This is body message.\n\nFixes #3\n\nCloses #1\n\nBREAKING CHANGE: This is breaking point message.`,\n\t\t\tTrimmedBody: `This is body message.`,\n\t\t},\n\t\t{\n\t\t\tHash: &Hash{\n\t\t\t\tLong:  \"809a8280ffd0dadb0f4e7ba9fc835e63c37d6af6\",\n\t\t\t\tShort: \"809a8280\",\n\t\t\t},\n\t\t\tAuthor: &Author{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1517486400), 0),\n\t\t\t},\n\t\t\tCommitter: &Committer{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1517486400), 0),\n\t\t\t},\n\t\t\tMerge:  nil,\n\t\t\tRevert: nil,\n\t\t\tRefs:   []*Ref{},\n\t\t\tNotes:  []*Note{},\n\t\t\tMentions: []string{\n\t\t\t\t\"tsuyoshiwada\",\n\t\t\t\t\"hogefuga\",\n\t\t\t\t\"FooBarBaz\",\n\t\t\t},\n\t\t\tHeader:  \"fix(controller): Fix cors configure\",\n\t\t\tType:    \"fix\",\n\t\t\tScope:   \"controller\",\n\t\t\tSubject: \"Fix cors configure\",\n\t\t\tBody: `Has mention body\n\n@tsuyoshiwada\n@hogefuga\n@FooBarBaz`,\n\t\t\tTrimmedBody: `Has mention body`,\n\t\t},\n\t\t{\n\t\t\tHash: &Hash{\n\t\t\t\tLong:  \"74824d6bd1470b901ec7123d13a76a1b8938d8d0\",\n\t\t\t\tShort: \"74824d6b\",\n\t\t\t},\n\t\t\tAuthor: &Author{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1517488587), 0),\n\t\t\t},\n\t\t\tCommitter: &Committer{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1517488587), 0),\n\t\t\t},\n\t\t\tMerge:  nil,\n\t\t\tRevert: nil,\n\t\t\tRefs: []*Ref{\n\t\t\t\t{\n\t\t\t\t\tAction: \"Fixes\",\n\t\t\t\t\tRef:    \"123\",\n\t\t\t\t\tSource: \"\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAction: \"Closes\",\n\t\t\t\t\tRef:    \"456\",\n\t\t\t\t\tSource: \"username/repository\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tNotes: []*Note{\n\t\t\t\t{\n\t\t\t\t\tTitle: \"BREAKING CHANGE\",\n\t\t\t\t\tBody: fmt.Sprintf(`This is multiline breaking change note.\nIt is treated as the body of the Note until a mention or reference appears.\n\nWe also allow blank lines :)\n\nExample:\n\n%sjavascript\nimport { Controller } from 'hoge-fuga';\n\n@autobind\nclass MyController extends Controller {\n  constructor() {\n    super();\n  }\n}\n%s`, \"```\", \"```\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMentions: []string{},\n\t\t\tHeader:   \"fix(model): Remove hoge attributes\",\n\t\t\tType:     \"fix\",\n\t\t\tScope:    \"model\",\n\t\t\tSubject:  \"Remove hoge attributes\",\n\t\t\tBody: fmt.Sprintf(`This mixed body message.\n\nBREAKING CHANGE:\nThis is multiline breaking change note.\nIt is treated as the body of the Note until a mention or reference appears.\n\nWe also allow blank lines :)\n\nExample:\n\n%sjavascript\nimport { Controller } from 'hoge-fuga';\n\n@autobind\nclass MyController extends Controller {\n  constructor() {\n    super();\n  }\n}\n%s\n\nFixes #123\nCloses username/repository#456`, \"```\", \"```\"),\n\t\t\tTrimmedBody: `This mixed body message.`,\n\t\t},\n\t\t{\n\t\t\tHash: &Hash{\n\t\t\t\tLong:  \"123456789735dcc4810dda3312b0792236c97c4e\",\n\t\t\t\tShort: \"12345678\",\n\t\t\t},\n\t\t\tAuthor: &Author{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1517488587), 0),\n\t\t\t},\n\t\t\tCommitter: &Committer{\n\t\t\t\tName:  \"tsuyoshi wada\",\n\t\t\t\tEmail: \"mail@example.com\",\n\t\t\t\tDate:  time.Unix(int64(1517488587), 0),\n\t\t\t},\n\t\t\tMerge: nil,\n\t\t\tRevert: &Revert{\n\t\t\t\tHeader: \"fix(core): commit message\",\n\t\t\t},\n\t\t\tRefs:        []*Ref{},\n\t\t\tNotes:       []*Note{},\n\t\t\tMentions:    []string{},\n\t\t\tHeader:      \"Revert \\\"fix(core): commit message\\\"\",\n\t\t\tType:        \"\",\n\t\t\tScope:       \"\",\n\t\t\tSubject:     \"\",\n\t\t\tBody:        \"This reverts commit f755db78dcdf461dc42e709b3ab728ceba353d1d.\",\n\t\t\tTrimmedBody: \"This reverts commit f755db78dcdf461dc42e709b3ab728ceba353d1d.\",\n\t\t},\n\t}, commits)\n}\n\ntype mockJiraClient struct {\n}\n\nfunc (jira mockJiraClient) GetJiraIssue(id string) (*agjira.Issue, error) {\n\treturn &agjira.Issue{\n\t\tID: id,\n\t\tFields: &agjira.IssueFields{\n\t\t\tExpand:                        \"\",\n\t\t\tType:                          agjira.IssueType{Name: \"Story\"},\n\t\t\tProject:                       agjira.Project{},\n\t\t\tResolution:                    nil,\n\t\t\tPriority:                      nil,\n\t\t\tResolutiondate:                agjira.Time{},\n\t\t\tCreated:                       agjira.Time{},\n\t\t\tDuedate:                       agjira.Date{},\n\t\t\tWatches:                       nil,\n\t\t\tAssignee:                      nil,\n\t\t\tUpdated:                       agjira.Time{},\n\t\t\tDescription:                   fmt.Sprintf(\"description of %s\", id),\n\t\t\tSummary:                       fmt.Sprintf(\"summary of %s\", id),\n\t\t\tCreator:                       nil,\n\t\t\tReporter:                      nil,\n\t\t\tComponents:                    nil,\n\t\t\tStatus:                        nil,\n\t\t\tProgress:                      nil,\n\t\t\tAggregateProgress:             nil,\n\t\t\tTimeTracking:                  nil,\n\t\t\tTimeSpent:                     0,\n\t\t\tTimeEstimate:                  0,\n\t\t\tTimeOriginalEstimate:          0,\n\t\t\tWorklog:                       nil,\n\t\t\tIssueLinks:                    nil,\n\t\t\tComments:                      nil,\n\t\t\tFixVersions:                   nil,\n\t\t\tAffectsVersions:               nil,\n\t\t\tLabels:                        []string{\"GA\"},\n\t\t\tSubtasks:                      nil,\n\t\t\tAttachments:                   nil,\n\t\t\tEpic:                          nil,\n\t\t\tSprint:                        nil,\n\t\t\tParent:                        nil,\n\t\t\tAggregateTimeOriginalEstimate: 0,\n\t\t\tAggregateTimeSpent:            0,\n\t\t\tAggregateTimeEstimate:         0,\n\t\t\tUnknowns:                      nil,\n\t\t},\n\t}, nil\n}\n\nfunc TestCommitParserParseWithJira(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.True(true)\n\n\tmock := &mockClient{\n\t\tReturnExec: func(subcmd string, args ...string) (string, error) {\n\t\t\tif subcmd != \"log\" {\n\t\t\t\treturn \"\", errors.New(\"\")\n\t\t\t}\n\n\t\t\tbytes, _ := os.ReadFile(filepath.Join(\"testdata\", \"gitlog_jira.txt\"))\n\n\t\t\treturn string(bytes), nil\n\t\t},\n\t}\n\n\tparser := newCommitParser(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\tmock, mockJiraClient{}, &Config{\n\t\t\tOptions: &Options{\n\t\t\t\tCommitFilters: map[string][]string{\n\t\t\t\t\t\"Type\": {\n\t\t\t\t\t\t\"feat\",\n\t\t\t\t\t\t\"fix\",\n\t\t\t\t\t\t\"perf\",\n\t\t\t\t\t\t\"refactor\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tHeaderPattern: \"^(?:(\\\\w*)|(?:\\\\[(.*)\\\\])?)\\\\:\\\\s(.*)$\",\n\t\t\t\tHeaderPatternMaps: []string{\n\t\t\t\t\t\"Type\",\n\t\t\t\t\t\"JiraIssueID\",\n\t\t\t\t\t\"Subject\",\n\t\t\t\t},\n\t\t\t\tJiraTypeMaps: map[string]string{\n\t\t\t\t\t\"Story\": \"feat\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tcommits, err := parser.Parse(\"HEAD\")\n\tassert.Nil(err)\n\tcommit := commits[0]\n\tassert.Equal(commit.JiraIssueID, \"JIRA-1111\")\n\tassert.Equal(commit.JiraIssue.Type, \"Story\")\n\tassert.Equal(commit.JiraIssue.Summary, \"summary of JIRA-1111\")\n\tassert.Equal(commit.JiraIssue.Description, \"description of JIRA-1111\")\n\tassert.Equal(commit.JiraIssue.Labels, []string{\"GA\"})\n\tassert.Equal(commit.Type, \"feat\")\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.16015625,
          "content": "package chglog\n\nimport \"errors\"\n\nvar (\n\terrNotFoundTag      = errors.New(\"could not find the tag\")\n\terrFailedQueryParse = errors.New(\"failed to parse the query\")\n)\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 1.298828125,
          "content": "package chglog\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc Example() {\n\tgen := NewGenerator(NewLogger(os.Stdout, os.Stderr, false, true),\n\t\t&Config{\n\t\t\tBin:        \"git\",\n\t\t\tWorkingDir: \".\",\n\t\t\tTemplate:   \"CHANGELOG.tpl.md\",\n\t\t\tInfo: &Info{\n\t\t\t\tTitle:         \"CHANGELOG\",\n\t\t\t\tRepositoryURL: \"https://github.com/git-chglog/git-chglog\",\n\t\t\t},\n\t\t\tOptions: &Options{\n\t\t\t\tCommitFilters: map[string][]string{\n\t\t\t\t\t\"Type\": {\n\t\t\t\t\t\t\"feat\",\n\t\t\t\t\t\t\"fix\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommitSortBy:      \"Scope\",\n\t\t\t\tCommitGroupBy:     \"Type\",\n\t\t\t\tCommitGroupSortBy: \"Title\",\n\t\t\t\tCommitGroupTitleMaps: map[string]string{\n\t\t\t\t\t\"feat\": \"Features\",\n\t\t\t\t\t\"fix\":  \"Bug Fixes\",\n\t\t\t\t},\n\t\t\t\tHeaderPattern: \"^(\\\\w*)(?:\\\\(([\\\\w\\\\$\\\\.\\\\-\\\\*\\\\s]*)\\\\))?\\\\:\\\\s(.*)$\",\n\t\t\t\tHeaderPatternMaps: []string{\n\t\t\t\t\t\"Type\",\n\t\t\t\t\t\"Scope\",\n\t\t\t\t\t\"Subject\",\n\t\t\t\t},\n\t\t\t\tIssuePrefix: []string{\n\t\t\t\t\t\"#\",\n\t\t\t\t\t\"gh-\",\n\t\t\t\t},\n\t\t\t\tRefActions:   []string{},\n\t\t\t\tMergePattern: \"^Merge pull request #(\\\\d+) from (.*)$\",\n\t\t\t\tMergePatternMaps: []string{\n\t\t\t\t\t\"Ref\",\n\t\t\t\t\t\"Source\",\n\t\t\t\t},\n\t\t\t\tRevertPattern: \"^Revert \\\"([\\\\s\\\\S]*)\\\"$\",\n\t\t\t\tRevertPatternMaps: []string{\n\t\t\t\t\t\"Header\",\n\t\t\t\t},\n\t\t\t\tNoteKeywords: []string{\n\t\t\t\t\t\"BREAKING CHANGE\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tbuf := &bytes.Buffer{}\n\terr := gen.Generate(buf, \"\")\n\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tfmt.Println(buf.String())\n}\n"
        },
        {
          "name": "fields.go",
          "type": "blob",
          "size": 3.1630859375,
          "content": "package chglog\n\nimport \"time\"\n\n// Hash of commit\ntype Hash struct {\n\tLong  string\n\tShort string\n}\n\n// Contact of co-authors and signers\ntype Contact struct {\n\tName  string\n\tEmail string\n}\n\n// Author of commit\ntype Author struct {\n\tName  string\n\tEmail string\n\tDate  time.Time\n}\n\n// Committer of commit\ntype Committer struct {\n\tName  string\n\tEmail string\n\tDate  time.Time\n}\n\n// Merge info for commit\ntype Merge struct {\n\tRef    string\n\tSource string\n}\n\n// Revert info for commit\ntype Revert struct {\n\tHeader string\n}\n\n// Ref is abstract data related to commit. (e.g. `Issues`, `Pull Request`)\ntype Ref struct {\n\tAction string // (e.g. `Closes`)\n\tRef    string // (e.g. `123`)\n\tSource string // (e.g. `owner/repository`)\n}\n\n// Note of commit\ntype Note struct {\n\tTitle string // (e.g. `BREAKING CHANGE`)\n\tBody  string // `Note` content body\n}\n\n// NoteGroup is a collection of `Note` grouped by titles\ntype NoteGroup struct {\n\tTitle string\n\tNotes []*Note\n}\n\n// JiraIssue is information about a jira ticket (type, summary, description, and labels)\ntype JiraIssue struct {\n\tType        string\n\tSummary     string\n\tDescription string\n\tLabels      []string\n}\n\n// Commit data\ntype Commit struct {\n\tHash        *Hash\n\tAuthor      *Author\n\tCommitter   *Committer\n\tMerge       *Merge  // If it is not a merge commit, `nil` is assigned\n\tRevert      *Revert // If it is not a revert commit, `nil` is assigned\n\tRefs        []*Ref\n\tNotes       []*Note\n\tMentions    []string   // Name of the user included in the commit header or body\n\tCoAuthors   []Contact  // (e.g. `Co-authored-by: user <user@email>`)\n\tSigners     []Contact  // (e.g. `Signed-off-by: user <user@email>`)\n\tJiraIssue   *JiraIssue // If no issue id found in header, `nil` is assigned\n\tHeader      string     // (e.g. `feat(core)[RNWY-310]: Add new feature`)\n\tType        string     // (e.g. `feat`)\n\tScope       string     // (e.g. `core`)\n\tSubject     string     // (e.g. `Add new feature`)\n\tJiraIssueID string     // (e.g. `RNWY-310`)\n\tBody        string\n\tTrimmedBody string // Body without any Notes/Refs/Mentions/CoAuthors/Signers\n}\n\n// CommitGroup is a collection of commits grouped according to the `CommitGroupBy` option\ntype CommitGroup struct {\n\tRawTitle string // Raw title before conversion (e.g. `build`)\n\tTitle    string // Conversion by `CommitGroupTitleMaps` option, or title converted in title case (e.g. `Build`)\n\tCommits  []*Commit\n}\n\n// RelateTag is sibling tag data of `Tag`.\n// If you give `Tag`, the reference hierarchy will be deepened.\n// This struct is used to minimize the hierarchy of references\ntype RelateTag struct {\n\tName    string\n\tSubject string\n\tDate    time.Time\n}\n\n// Tag is data of git-tag\ntype Tag struct {\n\tName     string\n\tSubject  string\n\tDate     time.Time\n\tNext     *RelateTag\n\tPrevious *RelateTag\n}\n\n// Version is a tag-separeted datset to be included in CHANGELOG\ntype Version struct {\n\tTag           *Tag\n\tCommitGroups  []*CommitGroup\n\tCommits       []*Commit\n\tMergeCommits  []*Commit\n\tRevertCommits []*Commit\n\tNoteGroups    []*NoteGroup\n}\n\n// Unreleased is unreleased commit dataset\ntype Unreleased struct {\n\tCommitGroups  []*CommitGroup\n\tCommits       []*Commit\n\tMergeCommits  []*Commit\n\tRevertCommits []*Commit\n\tNoteGroups    []*NoteGroup\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.79296875,
          "content": "module github.com/git-chglog/git-chglog\n\ngo 1.19\n\nrequire (\n\tgithub.com/AlecAivazis/survey/v2 v2.3.7\n\tgithub.com/Masterminds/sprig/v3 v3.2.3\n\tgithub.com/andygrunwald/go-jira v1.16.0\n\tgithub.com/coreos/go-semver v0.3.1\n\tgithub.com/fatih/color v1.16.0\n\tgithub.com/imdario/mergo v0.3.16\n\tgithub.com/kyokomi/emoji/v2 v2.2.12\n\tgithub.com/mattn/go-colorable v0.1.13\n\tgithub.com/stretchr/testify v1.8.4\n\tgithub.com/tsuyoshiwada/go-gitcmd v0.0.0-20180205145712-5f1f5f9475df\n\tgithub.com/urfave/cli/v2 v2.27.1\n\tgopkg.in/yaml.v2 v2.4.0\n)\n\nrequire (\n\tgithub.com/Masterminds/goutils v1.1.1 // indirect\n\tgithub.com/Masterminds/semver/v3 v3.2.0 // indirect\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.2 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/fatih/structs v1.1.0 // indirect\n\tgithub.com/golang-jwt/jwt/v4 v4.4.2 // indirect\n\tgithub.com/google/go-querystring v1.1.0 // indirect\n\tgithub.com/google/uuid v1.1.1 // indirect\n\tgithub.com/huandu/xstrings v1.3.3 // indirect\n\tgithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b // indirect\n\tgithub.com/mitchellh/copystructure v1.0.0 // indirect\n\tgithub.com/mitchellh/reflectwalk v1.0.0 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n\tgithub.com/shopspring/decimal v1.2.0 // indirect\n\tgithub.com/spf13/cast v1.3.1 // indirect\n\tgithub.com/trivago/tgo v1.0.7 // indirect\n\tgithub.com/xrash/smetrics v0.0.0-20201216005158-039620a65673 // indirect\n\tgolang.org/x/crypto v0.3.0 // indirect\n\tgolang.org/x/sys v0.14.0 // indirect\n\tgolang.org/x/term v0.2.0 // indirect\n\tgolang.org/x/text v0.4.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 11.7412109375,
          "content": "github.com/AlecAivazis/survey/v2 v2.3.7 h1:6I/u8FvytdGsgonrYsVn2t8t4QiRnh6QSTqkkhIiSjQ=\ngithub.com/AlecAivazis/survey/v2 v2.3.7/go.mod h1:xUTIdE4KCOIjsBAE1JYsUPoCqYdZ1reCfTwbto0Fduo=\ngithub.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\ngithub.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\ngithub.com/Masterminds/semver/v3 v3.2.0 h1:3MEsd0SM6jqZojhjLWWeBY+Kcjy9i6MQAeY7YgDP83g=\ngithub.com/Masterminds/semver/v3 v3.2.0/go.mod h1:qvl/7zhW3nngYb5+80sSMF+FG2BjYrf8m9wsX0PNOMQ=\ngithub.com/Masterminds/sprig/v3 v3.2.3 h1:eL2fZNezLomi0uOLqjQoN6BfsDD+fyLtgbJMAj9n6YA=\ngithub.com/Masterminds/sprig/v3 v3.2.3/go.mod h1:rXcFaZ2zZbLRJv/xSysmlgIM1u11eBaRMhvYXJNkGuM=\ngithub.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2 h1:+vx7roKuyA63nhn5WAunQHLTznkw5W8b1Xc0dNjp83s=\ngithub.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2/go.mod h1:HBCaDeC1lPdgDeDbhX8XFpy1jqjK0IBG8W5K+xYqA0w=\ngithub.com/andygrunwald/go-jira v1.16.0 h1:PU7C7Fkk5L96JvPc6vDVIrd99vdPnYudHu4ju2c2ikQ=\ngithub.com/andygrunwald/go-jira v1.16.0/go.mod h1:UQH4IBVxIYWbgagc0LF/k9FRs9xjIiQ8hIcC6HfLwFU=\ngithub.com/coreos/go-semver v0.3.1 h1:yi21YpKnrx1gt5R+la8n5WgS0kCrsPp33dmEyHReZr4=\ngithub.com/coreos/go-semver v0.3.1/go.mod h1:irMmmIw/7yzSRPWryHsK7EYSg09caPQL03VsM8rvUec=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.2 h1:p1EgwI/C7NhT0JmVkwCD2ZBK8j4aeHQX2pMHHBfMQ6w=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.2/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/creack/pty v1.1.17 h1:QeVUsEDNrLBW4tMgZHvxy18sKtr6VI492kBhUfhDJNI=\ngithub.com/creack/pty v1.1.17/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fatih/color v1.16.0 h1:zmkK9Ngbjj+K0yRhTVONQh1p/HknKYSlNT+vZCzyokM=\ngithub.com/fatih/color v1.16.0/go.mod h1:fL2Sau1YI5c0pdGEVCbKQbLXB6edEj1ZgiY4NijnWvE=\ngithub.com/fatih/structs v1.1.0 h1:Q7juDM0QtcnhCpeyLGQKyg4TOIghuNXrkL32pHAUMxo=\ngithub.com/fatih/structs v1.1.0/go.mod h1:9NiDSp5zOcgEDl+j00MP/WkGVPOlPRLejGD8Ga6PJ7M=\ngithub.com/golang-jwt/jwt/v4 v4.4.2 h1:rcc4lwaZgFMCZ5jxF9ABolDcIHdBytAFgqFPbSJQAYs=\ngithub.com/golang-jwt/jwt/v4 v4.4.2/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.8 h1:e6P7q2lk1O+qJJb4BtCQXlK8vWEO8V1ZeuEdJNOqZyg=\ngithub.com/google/go-cmp v0.5.8/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/go-querystring v1.1.0 h1:AnCroh3fv4ZBgVIf1Iwtovgjaw/GiKJo8M8yD/fhyJ8=\ngithub.com/google/go-querystring v1.1.0/go.mod h1:Kcdr2DB4koayq7X8pmAG4sNG59So17icRSOU623lUBU=\ngithub.com/google/uuid v1.1.1 h1:Gkbcsh/GbpXz7lPftLA3P6TYMwjCLYm83jiFQZF/3gY=\ngithub.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/hinshun/vt10x v0.0.0-20220119200601-820417d04eec h1:qv2VnGeEQHchGaZ/u7lxST/RaJw+cv273q79D81Xbog=\ngithub.com/hinshun/vt10x v0.0.0-20220119200601-820417d04eec/go.mod h1:Q48J4R4DvxnHolD5P8pOtXigYlRuPLGl6moFx3ulM68=\ngithub.com/huandu/xstrings v1.3.3 h1:/Gcsuc1x8JVbJ9/rlye4xZnVAbEkGauT8lbebqcQws4=\ngithub.com/huandu/xstrings v1.3.3/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=\ngithub.com/imdario/mergo v0.3.11/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=\ngithub.com/imdario/mergo v0.3.16 h1:wwQJbIsHYGMUyLSPrEq1CT16AhnhNJQ51+4fdHUnCl4=\ngithub.com/imdario/mergo v0.3.16/go.mod h1:WBLT9ZmE3lPoWsEzCh9LPo3TiwVN+ZKEjmz+hD27ysY=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=\ngithub.com/kyokomi/emoji/v2 v2.2.12 h1:sSVA5nH9ebR3Zji1o31wu3yOwD1zKXQA2z0zUyeit60=\ngithub.com/kyokomi/emoji/v2 v2.2.12/go.mod h1:JUcn42DTdsXJo1SWanHh4HKDEyPaR5CqkmoirZZP9qE=\ngithub.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b h1:j7+1HpAFS1zy5+Q4qx1fWh90gTKwiN4QCGoY9TWyyO4=\ngithub.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b/go.mod h1:01TrycV0kFyexm33Z7vhZRXopbI8J3TDReVlkTgMUxE=\ngithub.com/mitchellh/copystructure v1.0.0 h1:Laisrj+bAB6b/yJwB5Bt3ITZhGJdqmxquMKeZ+mmkFQ=\ngithub.com/mitchellh/copystructure v1.0.0/go.mod h1:SNtv71yrdKgLRyLFxmLdkAbkKEFWgYaq1OVrnRcwhnw=\ngithub.com/mitchellh/reflectwalk v1.0.0 h1:9D+8oIskB4VJBN5SFlmc27fSlIBZaov1Wpk/IfikLNY=\ngithub.com/mitchellh/reflectwalk v1.0.0/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/shopspring/decimal v1.2.0 h1:abSATXmQEYyShuxI4/vyW3tV1MrKAJzCZ/0zLUXYbsQ=\ngithub.com/shopspring/decimal v1.2.0/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=\ngithub.com/spf13/cast v1.3.1 h1:nFm6S0SMdyzrzcmThSipiEubIDy8WEXKNZ0UOgiRpng=\ngithub.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/trivago/tgo v1.0.7 h1:uaWH/XIy9aWYWpjm2CU3RpcqZXmX2ysQ9/Go+d9gyrM=\ngithub.com/trivago/tgo v1.0.7/go.mod h1:w4dpD+3tzNIIiIfkWWa85w5/B77tlvdZckQ+6PkFnhc=\ngithub.com/tsuyoshiwada/go-gitcmd v0.0.0-20180205145712-5f1f5f9475df h1:Y2l28Jr3vOEeYtxfVbMtVfOdAwuUqWaP9fvNKiBVeXY=\ngithub.com/tsuyoshiwada/go-gitcmd v0.0.0-20180205145712-5f1f5f9475df/go.mod h1:pnyouUty/nBr/zm3GYwTIt+qFTLWbdjeLjZmJdzJOu8=\ngithub.com/urfave/cli/v2 v2.27.1 h1:8xSQ6szndafKVRmfyeUMxkNUJQMjL1F2zmsZ+qHpfho=\ngithub.com/urfave/cli/v2 v2.27.1/go.mod h1:8qnjx1vcq5s2/wpsqoZFndg2CE5tNFyrTvS6SinrnYQ=\ngithub.com/xrash/smetrics v0.0.0-20201216005158-039620a65673 h1:bAn7/zixMGCfxrRTfdpNzjtPYqr8smhKouy9mxVdGPU=\ngithub.com/xrash/smetrics v0.0.0-20201216005158-039620a65673/go.mod h1:N3UwUGtsrSj3ccvlPHLoLsHnpR27oXr4ZE984MbSER8=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.3.0 h1:a06MkbcxBrEFc0w0QIZWXrH/9cCX6KJyWbBOIwAn+7A=\ngolang.org/x/crypto v0.3.0/go.mod h1:hebNnKkNXi2UzZN1eVRvBB7co0a+JxK6XbPiWVs/3J4=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.2.0/go.mod h1:KqCZLdyyvdV855qA2rE3GC2aiw5xGR5TEjj8smXukLY=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220330033206-e17cdc41300f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.14.0 h1:Vz7Qs629MkJkGyHxUlRHizWJRG2j8fbQKjELVSNhy7Q=\ngolang.org/x/sys v0.14.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210220032956-6a3ed077a48d/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.2.0 h1:z85xZCsEl7bi/KwbNADeBYoOP0++7W1ipu+aGnpwzRM=\ngolang.org/x/term v0.2.0/go.mod h1:TVmDHMZPmdnySmBfhjOoOdhjzdE1h4u1VwSiw2l1Nuc=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.4.0 h1:BrVqGRd7+k1DiOgtnFvAkoQEWQvBc25ouMJM6429SFg=\ngolang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "jira.go",
          "type": "blob",
          "size": 0.80859375,
          "content": "package chglog\n\nimport (\n\tagjira \"github.com/andygrunwald/go-jira\"\n)\n\n// JiraClient is an HTTP client for Jira\ntype JiraClient interface {\n\tGetJiraIssue(id string) (*agjira.Issue, error)\n}\n\ntype jiraClient struct {\n\tusername string\n\ttoken    string\n\turl      string\n}\n\n// NewJiraClient returns an instance of JiraClient\nfunc NewJiraClient(config *Config) JiraClient {\n\treturn jiraClient{\n\t\tusername: config.Options.JiraUsername,\n\t\ttoken:    config.Options.JiraToken,\n\t\turl:      config.Options.JiraURL,\n\t}\n}\n\nfunc (jira jiraClient) GetJiraIssue(id string) (*agjira.Issue, error) {\n\ttp := agjira.BasicAuthTransport{\n\t\tUsername: jira.username,\n\t\tPassword: jira.token,\n\t}\n\tclient, err := agjira.NewClient(tp.Client(), jira.url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tissue, _, err := client.Issue.Get(id, nil)\n\treturn issue, err\n}\n"
        },
        {
          "name": "jira_test.go",
          "type": "blob",
          "size": 1.0927734375,
          "content": "package chglog\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestJira(t *testing.T) {\n\tassert := assert.New(t)\n\n\tconfig := &Config{\n\t\tOptions: &Options{\n\t\t\tProcessor:                   nil,\n\t\t\tNextTag:                     \"\",\n\t\t\tTagFilterPattern:            \"\",\n\t\t\tCommitFilters:               nil,\n\t\t\tCommitSortBy:                \"\",\n\t\t\tCommitGroupBy:               \"\",\n\t\t\tCommitGroupSortBy:           \"\",\n\t\t\tCommitGroupTitleMaps:        nil,\n\t\t\tHeaderPattern:               \"\",\n\t\t\tHeaderPatternMaps:           nil,\n\t\t\tIssuePrefix:                 nil,\n\t\t\tRefActions:                  nil,\n\t\t\tMergePattern:                \"\",\n\t\t\tMergePatternMaps:            nil,\n\t\t\tRevertPattern:               \"\",\n\t\t\tRevertPatternMaps:           nil,\n\t\t\tNoteKeywords:                nil,\n\t\t\tJiraUsername:                \"uuu\",\n\t\t\tJiraToken:                   \"ppp\",\n\t\t\tJiraURL:                     \"http://jira.com\",\n\t\t\tJiraTypeMaps:                nil,\n\t\t\tJiraIssueDescriptionPattern: \"\",\n\t\t},\n\t}\n\n\tjira := NewJiraClient(config)\n\tissue, err := jira.GetJiraIssue(\"fake\")\n\tassert.Nil(issue)\n\tassert.Error(err)\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 1.060546875,
          "content": "package chglog\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"regexp\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/kyokomi/emoji/v2\"\n)\n\n// Logger ...\ntype Logger struct {\n\tstdout  io.Writer\n\tstderr  io.Writer\n\tsilent  bool\n\tnoEmoji bool\n\treEmoji *regexp.Regexp\n}\n\n// NewLogger ...\nfunc NewLogger(stdout, stderr io.Writer, silent, noEmoji bool) *Logger {\n\treturn &Logger{\n\t\tstdout:  stdout,\n\t\tstderr:  stderr,\n\t\tsilent:  silent,\n\t\tnoEmoji: noEmoji,\n\t\treEmoji: regexp.MustCompile(`:[\\w\\+_\\-]+:\\s?`),\n\t}\n}\n\n// Log ...\nfunc (l *Logger) Log(msg string) {\n\tif !l.silent {\n\t\tl.log(l.stdout, msg+\"\\n\")\n\t}\n}\n\n// Error ...\nfunc (l *Logger) Error(msg string) {\n\tprefix := color.New(color.FgWhite, color.BgRed, color.Bold).SprintFunc()\n\tl.log(l.stderr, fmt.Sprintf(\"%s %s\\n\", prefix(\" ERROR \"), color.RedString(msg)))\n}\n\nfunc (l *Logger) log(w io.Writer, msg string) {\n\tvar printer func(io.Writer, ...interface{}) (int, error)\n\n\tif l.noEmoji {\n\t\tmsg = l.reEmoji.ReplaceAllString(msg, \"\")\n\t\tprinter = fmt.Fprint\n\t} else {\n\t\tprinter = emoji.Fprint\n\t}\n\n\tif _, err := printer(w, msg); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 1.9375,
          "content": "package chglog\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/fatih/color\"\n\temoji \"github.com/kyokomi/emoji/v2\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestLoggerLogSilent(t *testing.T) {\n\tcolor.NoColor = false\n\tassert := assert.New(t)\n\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tlogger := NewLogger(stdout, stderr, true, false)\n\tlogger.Log(\":+1:Hello, World! :)\")\n\tassert.Equal(\"\", stdout.String())\n}\n\nfunc TestLoggerLog(t *testing.T) {\n\tcolor.NoColor = false\n\tassert := assert.New(t)\n\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tlogger := NewLogger(stdout, stderr, false, false)\n\tlogger.Log(\":+1:Hello, World! :)\")\n\tassert.Equal(emoji.Sprint(\":+1:Hello, World! :)\\n\"), stdout.String())\n}\n\nfunc TestLoggerLogNoEmoji(t *testing.T) {\n\tcolor.NoColor = false\n\tassert := assert.New(t)\n\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tlogger := NewLogger(stdout, stderr, false, true)\n\tlogger.Log(\":+1:Hello, World! :)\")\n\tassert.Equal(fmt.Sprint(\"Hello, World! :)\\n\"), stdout.String()) //nolint:gosimple\n}\n\nfunc TestLoggerError(t *testing.T) {\n\tcolor.NoColor = false\n\tassert := assert.New(t)\n\n\tprefix := color.New(color.FgWhite, color.BgRed, color.Bold).SprintFunc()\n\n\t// Basic\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tlogger := NewLogger(stdout, stderr, false, false)\n\tlogger.Error(\"This is error message!! :dog:\")\n\tassert.Equal(\"\", stdout.String())\n\tassert.Equal(emoji.Sprint(fmt.Sprintf(\"%s %s\\n\", prefix(\" ERROR \"), color.RedString(\"This is error message!! :dog:\"))), stderr.String())\n\n\t// Silent\n\tstdout = &bytes.Buffer{}\n\tstderr = &bytes.Buffer{}\n\tlogger = NewLogger(stdout, stderr, true, false)\n\tlogger.Error(\"Foo\")\n\tassert.Equal(\"\", stdout.String())\n\tassert.NotEqual(\"\", stderr.String())\n\n\t// NoEmoji\n\tstdout = &bytes.Buffer{}\n\tstderr = &bytes.Buffer{}\n\tlogger = NewLogger(stdout, stderr, true, true)\n\tlogger.Error(\"HOGE :hand:\")\n\tassert.Equal(\"\", stdout.String())\n\tassert.NotContains(stderr.String(), emoji.Sprint(\":hand:\"))\n}\n"
        },
        {
          "name": "mock_test.go",
          "type": "blob",
          "size": 0.2705078125,
          "content": "package chglog\n\nimport gitcmd \"github.com/tsuyoshiwada/go-gitcmd\"\n\ntype mockClient struct {\n\tgitcmd.Client\n\tReturnExec func(string, ...string) (string, error)\n}\n\nfunc (m *mockClient) Exec(subcmd string, args ...string) (string, error) {\n\treturn m.ReturnExec(subcmd, args...)\n}\n"
        },
        {
          "name": "processor.go",
          "type": "blob",
          "size": 5.0595703125,
          "content": "package chglog\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\n// Processor hooks the internal processing of `Generator`, it is possible to adjust the contents\ntype Processor interface {\n\tBootstrap(*Config)\n\tProcessCommit(*Commit) *Commit\n}\n\n// GitHubProcessor is optimized for CHANGELOG used in GitHub\n//\n// The following processing is performed\n//   - Mentions automatic link (@tsuyoshiwada -> [@tsuyoshiwada](https://github.com/tsuyoshiwada))\n//   - Automatic link to references (#123 -> [#123](https://github.com/owner/repo/issues/123))\ntype GitHubProcessor struct {\n\tHost      string // Host name used for link destination. Note: You must include the protocol (e.g. \"https://github.com\")\n\tconfig    *Config\n\treMention *regexp.Regexp\n\treIssue   *regexp.Regexp\n}\n\n// Bootstrap ...\nfunc (p *GitHubProcessor) Bootstrap(config *Config) {\n\tp.config = config\n\n\tif p.Host == \"\" {\n\t\tp.Host = \"https://github.com\"\n\t} else {\n\t\tp.Host = strings.TrimRight(p.Host, \"/\")\n\t}\n\n\tp.reMention = regexp.MustCompile(`@(\\w+)`)\n\tp.reIssue = regexp.MustCompile(`(?i)(#|gh-)(\\d+)`)\n}\n\n// ProcessCommit ...\nfunc (p *GitHubProcessor) ProcessCommit(commit *Commit) *Commit {\n\tcommit.Header = p.addLinks(commit.Header)\n\tcommit.Subject = p.addLinks(commit.Subject)\n\tcommit.Body = p.addLinks(commit.Body)\n\n\tfor _, note := range commit.Notes {\n\t\tnote.Body = p.addLinks(note.Body)\n\t}\n\n\tif commit.Revert != nil {\n\t\tcommit.Revert.Header = p.addLinks(commit.Revert.Header)\n\t}\n\n\treturn commit\n}\n\nfunc (p *GitHubProcessor) addLinks(input string) string {\n\trepoURL := strings.TrimRight(p.config.Info.RepositoryURL, \"/\")\n\n\t// mentions\n\tinput = p.reMention.ReplaceAllString(input, \"[@$1](\"+p.Host+\"/$1)\")\n\n\t// issues\n\tinput = p.reIssue.ReplaceAllString(input, \"[$1$2](\"+repoURL+\"/issues/$2)\")\n\n\treturn input\n}\n\n// GitLabProcessor is optimized for CHANGELOG used in GitLab\n//\n// The following processing is performed\n//   - Mentions automatic link (@tsuyoshiwada -> [@tsuyoshiwada](https://gitlab.com/tsuyoshiwada))\n//   - Automatic link to references issues (#123 -> [#123](https://gitlab.com/owner/repo/issues/123))\n//   - Automatic link to references merge request (!123 -> [#123](https://gitlab.com/owner/repo/merge_requests/123))\ntype GitLabProcessor struct {\n\tHost           string // Host name used for link destination. Note: You must include the protocol (e.g. \"https://gitlab.com\")\n\tconfig         *Config\n\treMention      *regexp.Regexp\n\treIssue        *regexp.Regexp\n\treMergeRequest *regexp.Regexp\n}\n\n// Bootstrap ...\nfunc (p *GitLabProcessor) Bootstrap(config *Config) {\n\tp.config = config\n\n\tif p.Host == \"\" {\n\t\tp.Host = \"https://gitlab.com\"\n\t} else {\n\t\tp.Host = strings.TrimRight(p.Host, \"/\")\n\t}\n\n\tp.reMention = regexp.MustCompile(`@(\\w+)`)\n\tp.reIssue = regexp.MustCompile(`(?i)#(\\d+)`)\n\tp.reMergeRequest = regexp.MustCompile(`(?i)!(\\d+)`)\n}\n\n// ProcessCommit ...\nfunc (p *GitLabProcessor) ProcessCommit(commit *Commit) *Commit {\n\tcommit.Header = p.addLinks(commit.Header)\n\tcommit.Subject = p.addLinks(commit.Subject)\n\tcommit.Body = p.addLinks(commit.Body)\n\n\tfor _, note := range commit.Notes {\n\t\tnote.Body = p.addLinks(note.Body)\n\t}\n\n\tif commit.Revert != nil {\n\t\tcommit.Revert.Header = p.addLinks(commit.Revert.Header)\n\t}\n\n\treturn commit\n}\n\nfunc (p *GitLabProcessor) addLinks(input string) string {\n\trepoURL := strings.TrimRight(p.config.Info.RepositoryURL, \"/\")\n\n\t// mentions\n\tinput = p.reMention.ReplaceAllString(input, \"[@$1](\"+p.Host+\"/$1)\")\n\n\t// issues\n\tinput = p.reIssue.ReplaceAllString(input, \"[#$1](\"+repoURL+\"/issues/$1)\")\n\n\t// merge requests\n\tinput = p.reMergeRequest.ReplaceAllString(input, \"[!$1](\"+repoURL+\"/merge_requests/$1)\")\n\n\treturn input\n}\n\n// BitbucketProcessor is optimized for CHANGELOG used in Bitbucket\n//\n// The following processing is performed\n//   - Mentions automatic link (@tsuyoshiwada -> [@tsuyoshiwada](https://bitbucket.org/tsuyoshiwada/))\n//   - Automatic link to references (#123 -> [#123](https://bitbucket.org/owner/repo/issues/123/))\ntype BitbucketProcessor struct {\n\tHost      string // Host name used for link destination. Note: You must include the protocol (e.g. \"https://bitbucket.org\")\n\tconfig    *Config\n\treMention *regexp.Regexp\n\treIssue   *regexp.Regexp\n}\n\n// Bootstrap ...\nfunc (p *BitbucketProcessor) Bootstrap(config *Config) {\n\tp.config = config\n\n\tif p.Host == \"\" {\n\t\tp.Host = \"https://bitbucket.org\"\n\t} else {\n\t\tp.Host = strings.TrimRight(p.Host, \"/\")\n\t}\n\n\tp.reMention = regexp.MustCompile(`@(\\w+)`)\n\tp.reIssue = regexp.MustCompile(`(?i)#(\\d+)`)\n}\n\n// ProcessCommit ...\nfunc (p *BitbucketProcessor) ProcessCommit(commit *Commit) *Commit {\n\tcommit.Header = p.addLinks(commit.Header)\n\tcommit.Subject = p.addLinks(commit.Subject)\n\tcommit.Body = p.addLinks(commit.Body)\n\n\tfor _, note := range commit.Notes {\n\t\tnote.Body = p.addLinks(note.Body)\n\t}\n\n\tif commit.Revert != nil {\n\t\tcommit.Revert.Header = p.addLinks(commit.Revert.Header)\n\t}\n\n\treturn commit\n}\n\nfunc (p *BitbucketProcessor) addLinks(input string) string {\n\trepoURL := strings.TrimRight(p.config.Info.RepositoryURL, \"/\")\n\n\t// mentions\n\tinput = p.reMention.ReplaceAllString(input, \"[@$1](\"+p.Host+\"/$1/)\")\n\n\t// issues\n\tinput = p.reIssue.ReplaceAllString(input, \"[#$1](\"+repoURL+\"/issues/$1/)\")\n\n\treturn input\n}\n"
        },
        {
          "name": "processor_test.go",
          "type": "blob",
          "size": 4.3515625,
          "content": "package chglog\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGitHubProcessor(t *testing.T) {\n\tassert := assert.New(t)\n\n\tconfig := &Config{\n\t\tInfo: &Info{\n\t\t\tRepositoryURL: \"https://example.com\",\n\t\t},\n\t}\n\n\tprocessor := &GitHubProcessor{}\n\n\tprocessor.Bootstrap(config)\n\n\tassert.Equal(\n\t\t&Commit{\n\t\t\tHeader:  \"message [@foo](https://github.com/foo) [#123](https://example.com/issues/123)\",\n\t\t\tSubject: \"message [@foo](https://github.com/foo) [#123](https://example.com/issues/123)\",\n\t\t\tBody: `issue [#456](https://example.com/issues/456)\nmultiline [#789](https://example.com/issues/789)\n[@foo](https://github.com/foo), [@bar](https://github.com/bar)`,\n\t\t\tNotes: []*Note{\n\t\t\t\t{\n\t\t\t\t\tBody: `issue1 [#11](https://example.com/issues/11)\nissue2 [#22](https://example.com/issues/22)\n[gh-56](https://example.com/issues/56) hoge fuga`,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tprocessor.ProcessCommit(\n\t\t\t&Commit{\n\t\t\t\tHeader:  \"message @foo #123\",\n\t\t\t\tSubject: \"message @foo #123\",\n\t\t\t\tBody: `issue #456\nmultiline #789\n@foo, @bar`,\n\t\t\t\tNotes: []*Note{\n\t\t\t\t\t{\n\t\t\t\t\t\tBody: `issue1 #11\nissue2 #22\ngh-56 hoge fuga`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n\n\tassert.Equal(\n\t\t&Commit{\n\t\t\tRevert: &Revert{\n\t\t\t\tHeader: \"revert header [@mention](https://github.com/mention) [#123](https://example.com/issues/123)\",\n\t\t\t},\n\t\t},\n\t\tprocessor.ProcessCommit(\n\t\t\t&Commit{\n\t\t\t\tRevert: &Revert{\n\t\t\t\t\tHeader: \"revert header @mention #123\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n}\n\nfunc TestGitLabProcessor(t *testing.T) {\n\tassert := assert.New(t)\n\n\tconfig := &Config{\n\t\tInfo: &Info{\n\t\t\tRepositoryURL: \"https://example.com\",\n\t\t},\n\t}\n\n\tprocessor := &GitLabProcessor{}\n\n\tprocessor.Bootstrap(config)\n\n\tassert.Equal(\n\t\t&Commit{\n\t\t\tHeader:  \"message [@foo](https://gitlab.com/foo) [#123](https://example.com/issues/123) [!345](https://example.com/merge_requests/345)\",\n\t\t\tSubject: \"message [@foo](https://gitlab.com/foo) [#123](https://example.com/issues/123) [!345](https://example.com/merge_requests/345)\",\n\t\t\tBody: `issue [#456](https://example.com/issues/456)\nmultiline [#789](https://example.com/issues/789)\nmerge request [!345](https://example.com/merge_requests/345)\n[@foo](https://gitlab.com/foo), [@bar](https://gitlab.com/bar)`,\n\t\t\tNotes: []*Note{\n\t\t\t\t{\n\t\t\t\t\tBody: `issue1 [#11](https://example.com/issues/11) [!33](https://example.com/merge_requests/33)\nissue2 [#22](https://example.com/issues/22)\nmerge request [!33](https://example.com/merge_requests/33)\ngh-56 hoge fuga`,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tprocessor.ProcessCommit(\n\t\t\t&Commit{\n\t\t\t\tHeader:  \"message @foo #123 !345\",\n\t\t\t\tSubject: \"message @foo #123 !345\",\n\t\t\t\tBody: `issue #456\nmultiline #789\nmerge request !345\n@foo, @bar`,\n\t\t\t\tNotes: []*Note{\n\t\t\t\t\t{\n\t\t\t\t\t\tBody: `issue1 #11 !33\nissue2 #22\nmerge request !33\ngh-56 hoge fuga`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n\n\tassert.Equal(\n\t\t&Commit{\n\t\t\tRevert: &Revert{\n\t\t\t\tHeader: \"revert header [@mention](https://gitlab.com/mention) [#123](https://example.com/issues/123) [!345](https://example.com/merge_requests/345)\",\n\t\t\t},\n\t\t},\n\t\tprocessor.ProcessCommit(\n\t\t\t&Commit{\n\t\t\t\tRevert: &Revert{\n\t\t\t\t\tHeader: \"revert header @mention #123 !345\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n}\n\nfunc TestBitbucketProcessor(t *testing.T) {\n\tassert := assert.New(t)\n\n\tconfig := &Config{\n\t\tInfo: &Info{\n\t\t\tRepositoryURL: \"https://example.com\",\n\t\t},\n\t}\n\n\tprocessor := &BitbucketProcessor{}\n\n\tprocessor.Bootstrap(config)\n\n\tassert.Equal(\n\t\t&Commit{\n\t\t\tHeader:  \"message [@foo](https://bitbucket.org/foo/) [#123](https://example.com/issues/123/)\",\n\t\t\tSubject: \"message [@foo](https://bitbucket.org/foo/) [#123](https://example.com/issues/123/)\",\n\t\t\tBody: `issue [#456](https://example.com/issues/456/)\nmultiline [#789](https://example.com/issues/789/)\n[@foo](https://bitbucket.org/foo/), [@bar](https://bitbucket.org/bar/)`,\n\t\t\tNotes: []*Note{\n\t\t\t\t{\n\t\t\t\t\tBody: `issue1 [#11](https://example.com/issues/11/)\nissue2 [#22](https://example.com/issues/22/)\ngh-56 hoge fuga`,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tprocessor.ProcessCommit(\n\t\t\t&Commit{\n\t\t\t\tHeader:  \"message @foo #123\",\n\t\t\t\tSubject: \"message @foo #123\",\n\t\t\t\tBody: `issue #456\nmultiline #789\n@foo, @bar`,\n\t\t\t\tNotes: []*Note{\n\t\t\t\t\t{\n\t\t\t\t\t\tBody: `issue1 #11\nissue2 #22\ngh-56 hoge fuga`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n\n\tassert.Equal(\n\t\t&Commit{\n\t\t\tRevert: &Revert{\n\t\t\t\tHeader: \"revert header [@mention](https://bitbucket.org/mention/) [#123](https://example.com/issues/123/)\",\n\t\t\t},\n\t\t},\n\t\tprocessor.ProcessCommit(\n\t\t\t&Commit{\n\t\t\t\tRevert: &Revert{\n\t\t\t\t\tHeader: \"revert header @mention #123\",\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t)\n}\n"
        },
        {
          "name": "tag_reader.go",
          "type": "blob",
          "size": 3.1083984375,
          "content": "package chglog\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/coreos/go-semver/semver\"\n\tgitcmd \"github.com/tsuyoshiwada/go-gitcmd\"\n)\n\ntype tagReader struct {\n\tclient    gitcmd.Client\n\tseparator string\n\treFilter  *regexp.Regexp\n\tsortBy    string\n}\n\nfunc newTagReader(client gitcmd.Client, filterPattern string, sort string) *tagReader {\n\treturn &tagReader{\n\t\tclient:    client,\n\t\tseparator: \"@@__CHGLOG__@@\",\n\t\treFilter:  regexp.MustCompile(filterPattern),\n\t\tsortBy:    sort,\n\t}\n}\n\nfunc (r *tagReader) ReadAll() ([]*Tag, error) {\n\tout, err := r.client.Exec(\n\t\t\"for-each-ref\",\n\t\t\"--format\",\n\t\t\"%(refname)\"+r.separator+\"%(subject)\"+r.separator+\"%(taggerdate)\"+r.separator+\"%(authordate)\",\n\t\t\"refs/tags\",\n\t)\n\n\ttags := []*Tag{}\n\n\tif err != nil {\n\t\treturn tags, fmt.Errorf(\"failed to get git-tag: %w\", err)\n\t}\n\n\tlines := strings.Split(out, \"\\n\")\n\n\tfor _, line := range lines {\n\t\ttokens := strings.Split(line, r.separator)\n\n\t\tif len(tokens) != 4 {\n\t\t\tcontinue\n\t\t}\n\n\t\tname := r.parseRefname(tokens[0])\n\t\tsubject := r.parseSubject(tokens[1])\n\t\tdate, err := r.parseDate(tokens[2])\n\t\tif err != nil {\n\t\t\tt, err2 := r.parseDate(tokens[3])\n\t\t\tif err2 != nil {\n\t\t\t\treturn nil, err2\n\t\t\t}\n\t\t\tdate = t\n\t\t}\n\n\t\tif r.reFilter != nil {\n\t\t\tif !r.reFilter.MatchString(name) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\ttags = append(tags, &Tag{\n\t\t\tName:    name,\n\t\t\tSubject: subject,\n\t\t\tDate:    date,\n\t\t})\n\t}\n\n\tswitch r.sortBy {\n\tcase \"date\":\n\t\tr.sortTags(tags)\n\tcase \"semver\":\n\t\tr.filterSemVerTags(&tags)\n\t\tr.sortTagsBySemver(tags)\n\t}\n\tr.assignPreviousAndNextTag(tags)\n\n\treturn tags, nil\n}\n\nfunc (*tagReader) filterSemVerTags(tags *[]*Tag) {\n\t// filter out any non-semver tags\n\tfor i, t := range *tags {\n\t\t// remove leading v, since its so\n\t\t// common.\n\t\tname := strings.TrimPrefix(t.Name, \"v\")\n\n\t\t// attempt semver parse, if not successful\n\t\t// remove it from tags slice.\n\t\tif _, err := semver.NewVersion(name); err != nil {\n\t\t\t*tags = append((*tags)[:i], (*tags)[i+1:]...)\n\t\t}\n\t}\n}\n\nfunc (*tagReader) parseRefname(input string) string {\n\treturn strings.Replace(input, \"refs/tags/\", \"\", 1)\n}\n\nfunc (*tagReader) parseSubject(input string) string {\n\treturn strings.TrimSpace(input)\n}\n\nfunc (*tagReader) parseDate(input string) (time.Time, error) {\n\treturn time.Parse(\"Mon Jan 2 15:04:05 2006 -0700\", input)\n}\n\nfunc (*tagReader) assignPreviousAndNextTag(tags []*Tag) {\n\ttotal := len(tags)\n\n\tfor i, tag := range tags {\n\t\tvar (\n\t\t\tnext *RelateTag\n\t\t\tprev *RelateTag\n\t\t)\n\n\t\tif i > 0 {\n\t\t\tnext = &RelateTag{\n\t\t\t\tName:    tags[i-1].Name,\n\t\t\t\tSubject: tags[i-1].Subject,\n\t\t\t\tDate:    tags[i-1].Date,\n\t\t\t}\n\t\t}\n\n\t\tif i+1 < total {\n\t\t\tprev = &RelateTag{\n\t\t\t\tName:    tags[i+1].Name,\n\t\t\t\tSubject: tags[i+1].Subject,\n\t\t\t\tDate:    tags[i+1].Date,\n\t\t\t}\n\t\t}\n\n\t\ttag.Next = next\n\t\ttag.Previous = prev\n\t}\n}\n\nfunc (*tagReader) sortTags(tags []*Tag) {\n\tsort.Slice(tags, func(i, j int) bool {\n\t\treturn !tags[i].Date.Before(tags[j].Date)\n\t})\n}\n\nfunc (*tagReader) sortTagsBySemver(tags []*Tag) {\n\tsort.Slice(tags, func(i, j int) bool {\n\t\tsemver1 := strings.TrimPrefix(tags[i].Name, \"v\")\n\t\tsemver2 := strings.TrimPrefix(tags[j].Name, \"v\")\n\t\tv1 := semver.New(semver1)\n\t\tv2 := semver.New(semver2)\n\t\treturn v2.LessThan(*v1)\n\t})\n}\n"
        },
        {
          "name": "tag_reader_test.go",
          "type": "blob",
          "size": 6.32421875,
          "content": "package chglog\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTagReader(t *testing.T) {\n\tassert := assert.New(t)\n\tclient := &mockClient{\n\t\tReturnExec: func(subcmd string, args ...string) (string, error) {\n\t\t\tif subcmd != \"for-each-ref\" {\n\t\t\t\treturn \"\", errors.New(\"\")\n\t\t\t}\n\t\t\treturn strings.Join([]string{\n\t\t\t\t\"\",\n\t\t\t\t\"refs/tags/v2.0.4-beta.1@@__CHGLOG__@@Release v2.0.4-beta.1@@__CHGLOG__@@Thu Feb 1 00:00:00 2018 +0000@@__CHGLOG__@@\",\n\t\t\t\t\"refs/tags/4.4.3@@__CHGLOG__@@This is tag subject@@__CHGLOG__@@@@__CHGLOG__@@Fri Feb 2 00:00:00 2018 +0000\",\n\t\t\t\t\"refs/tags/4.4.4@@__CHGLOG__@@Release 4.4.4@@__CHGLOG__@@Fri Feb 2 10:00:40 2018 +0000@@__CHGLOG__@@\",\n\t\t\t\t\"refs/tags/v2.0.4-beta.2@@__CHGLOG__@@Release v2.0.4-beta.2@@__CHGLOG__@@Sat Feb 3 12:15:00 2018 +0000@@__CHGLOG__@@\",\n\t\t\t\t\"refs/tags/5.0.0-rc.0@@__CHGLOG__@@Release 5.0.0-rc.0@@__CHGLOG__@@Sat Feb 3 12:30:10 2018 +0000@@__CHGLOG__@@\",\n\t\t\t\t\"refs/tags/hoge_fuga@@__CHGLOG__@@Invalid semver tag name@@__CHGLOG__@@Mon Mar 12 12:30:10 2018 +0000@@__CHGLOG__@@\",\n\t\t\t\t\"hoge@@__CHGLOG__@@\",\n\t\t\t}, \"\\n\"), nil\n\t\t},\n\t}\n\n\tactual, err := newTagReader(client, \"\", \"date\").ReadAll()\n\tassert.Nil(err)\n\n\tassert.Equal(\n\t\t[]*Tag{\n\t\t\t{\n\t\t\t\tName:    \"hoge_fuga\",\n\t\t\t\tSubject: \"Invalid semver tag name\",\n\t\t\t\tDate:    time.Date(2018, 3, 12, 12, 30, 10, 0, time.UTC),\n\t\t\t\tNext:    nil,\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"5.0.0-rc.0\",\n\t\t\t\t\tSubject: \"Release 5.0.0-rc.0\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 30, 10, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"5.0.0-rc.0\",\n\t\t\t\tSubject: \"Release 5.0.0-rc.0\",\n\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 30, 10, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"hoge_fuga\",\n\t\t\t\t\tSubject: \"Invalid semver tag name\",\n\t\t\t\t\tDate:    time.Date(2018, 3, 12, 12, 30, 10, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"v2.0.4-beta.2\",\n\t\t\t\t\tSubject: \"Release v2.0.4-beta.2\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 15, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"v2.0.4-beta.2\",\n\t\t\t\tSubject: \"Release v2.0.4-beta.2\",\n\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 15, 0, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"5.0.0-rc.0\",\n\t\t\t\t\tSubject: \"Release 5.0.0-rc.0\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 30, 10, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"4.4.4\",\n\t\t\t\t\tSubject: \"Release 4.4.4\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 2, 10, 0, 40, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"4.4.4\",\n\t\t\t\tSubject: \"Release 4.4.4\",\n\t\t\t\tDate:    time.Date(2018, 2, 2, 10, 0, 40, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"v2.0.4-beta.2\",\n\t\t\t\t\tSubject: \"Release v2.0.4-beta.2\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 15, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"4.4.3\",\n\t\t\t\t\tSubject: \"This is tag subject\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 2, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"4.4.3\",\n\t\t\t\tSubject: \"This is tag subject\",\n\t\t\t\tDate:    time.Date(2018, 2, 2, 0, 0, 0, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"4.4.4\",\n\t\t\t\t\tSubject: \"Release 4.4.4\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 2, 10, 0, 40, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"v2.0.4-beta.1\",\n\t\t\t\t\tSubject: \"Release v2.0.4-beta.1\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 1, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"v2.0.4-beta.1\",\n\t\t\t\tSubject: \"Release v2.0.4-beta.1\",\n\t\t\t\tDate:    time.Date(2018, 2, 1, 0, 0, 0, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"4.4.3\",\n\t\t\t\t\tSubject: \"This is tag subject\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 2, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: nil,\n\t\t\t},\n\t\t},\n\t\tactual,\n\t)\n\n\tactual, err = newTagReader(client, \"\", \"semver\").ReadAll()\n\tassert.Nil(err)\n\n\tassert.Equal(\n\t\t[]*Tag{\n\t\t\t{\n\t\t\t\tName:    \"5.0.0-rc.0\",\n\t\t\t\tSubject: \"Release 5.0.0-rc.0\",\n\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 30, 10, 0, time.UTC),\n\t\t\t\tNext:    nil,\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"4.4.4\",\n\t\t\t\t\tSubject: \"Release 4.4.4\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 2, 10, 0, 40, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"4.4.4\",\n\t\t\t\tSubject: \"Release 4.4.4\",\n\t\t\t\tDate:    time.Date(2018, 2, 2, 10, 0, 40, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"5.0.0-rc.0\",\n\t\t\t\t\tSubject: \"Release 5.0.0-rc.0\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 30, 10, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"4.4.3\",\n\t\t\t\t\tSubject: \"This is tag subject\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 2, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"4.4.3\",\n\t\t\t\tSubject: \"This is tag subject\",\n\t\t\t\tDate:    time.Date(2018, 2, 2, 0, 0, 0, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"4.4.4\",\n\t\t\t\t\tSubject: \"Release 4.4.4\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 2, 10, 0, 40, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"v2.0.4-beta.2\",\n\t\t\t\t\tSubject: \"Release v2.0.4-beta.2\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 15, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"v2.0.4-beta.2\",\n\t\t\t\tSubject: \"Release v2.0.4-beta.2\",\n\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 15, 0, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"4.4.3\",\n\t\t\t\t\tSubject: \"This is tag subject\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 2, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"v2.0.4-beta.1\",\n\t\t\t\t\tSubject: \"Release v2.0.4-beta.1\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 1, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"v2.0.4-beta.1\",\n\t\t\t\tSubject: \"Release v2.0.4-beta.1\",\n\t\t\t\tDate:    time.Date(2018, 2, 1, 0, 0, 0, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"v2.0.4-beta.2\",\n\t\t\t\t\tSubject: \"Release v2.0.4-beta.2\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 15, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: nil,\n\t\t\t},\n\t\t},\n\t\tactual,\n\t)\n\n\tactualFiltered, errFiltered := newTagReader(client, \"^v\", \"date\").ReadAll()\n\tassert.Nil(errFiltered)\n\tassert.Equal(\n\t\t[]*Tag{\n\t\t\t{\n\t\t\t\tName:    \"v2.0.4-beta.2\",\n\t\t\t\tSubject: \"Release v2.0.4-beta.2\",\n\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 15, 0, 0, time.UTC),\n\t\t\t\tNext:    nil,\n\t\t\t\tPrevious: &RelateTag{\n\t\t\t\t\tName:    \"v2.0.4-beta.1\",\n\t\t\t\t\tSubject: \"Release v2.0.4-beta.1\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 1, 0, 0, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"v2.0.4-beta.1\",\n\t\t\t\tSubject: \"Release v2.0.4-beta.1\",\n\t\t\t\tDate:    time.Date(2018, 2, 1, 0, 0, 0, 0, time.UTC),\n\t\t\t\tNext: &RelateTag{\n\t\t\t\t\tName:    \"v2.0.4-beta.2\",\n\t\t\t\t\tSubject: \"Release v2.0.4-beta.2\",\n\t\t\t\t\tDate:    time.Date(2018, 2, 3, 12, 15, 0, 0, time.UTC),\n\t\t\t\t},\n\t\t\t\tPrevious: nil,\n\t\t\t},\n\t\t},\n\t\tactualFiltered,\n\t)\n}\n"
        },
        {
          "name": "tag_selector.go",
          "type": "blob",
          "size": 2.2578125,
          "content": "package chglog\n\nimport (\n\t\"strings\"\n)\n\ntype tagSelector struct{}\n\nfunc newTagSelector() *tagSelector {\n\treturn &tagSelector{}\n}\n\nfunc (s *tagSelector) Select(tags []*Tag, query string) ([]*Tag, string, error) {\n\ttokens := strings.Split(query, \"..\")\n\n\tswitch len(tokens) {\n\tcase 1:\n\t\treturn s.selectSingleTag(tags, tokens[0])\n\tcase 2:\n\t\told := tokens[0]\n\t\tnew := tokens[1]\n\t\tswitch {\n\t\tcase old == \"\" && new == \"\":\n\t\t\treturn nil, \"\", nil\n\t\tcase old == \"\":\n\t\t\treturn s.selectBeforeTags(tags, new)\n\t\tcase new == \"\":\n\t\t\treturn s.selectAfterTags(tags, old)\n\t\tdefault:\n\t\t\treturn s.selectRangeTags(tags, tokens[0], tokens[1])\n\t\t}\n\t}\n\n\treturn nil, \"\", errFailedQueryParse\n}\n\nfunc (s *tagSelector) selectSingleTag(tags []*Tag, token string) ([]*Tag, string, error) {\n\tvar from string\n\n\tfor i, tag := range tags {\n\t\tif tag.Name == token {\n\t\t\tif i+1 < len(tags) {\n\t\t\t\tfrom = tags[i+1].Name\n\t\t\t}\n\t\t\treturn []*Tag{tag}, from, nil\n\t\t}\n\t}\n\n\treturn nil, \"\", nil\n}\n\nfunc (*tagSelector) selectBeforeTags(tags []*Tag, token string) ([]*Tag, string, error) {\n\tvar (\n\t\tres    []*Tag\n\t\tfrom   string\n\t\tenable bool\n\t)\n\n\tfor i, tag := range tags {\n\t\tif tag.Name == token {\n\t\t\tenable = true\n\t\t}\n\n\t\tif enable {\n\t\t\tres = append(res, tag)\n\t\t\tfrom = \"\"\n\t\t\tif i+1 < len(tags) {\n\t\t\t\tfrom = tags[i+1].Name\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(res) == 0 {\n\t\treturn res, \"\", errNotFoundTag\n\t}\n\n\treturn res, from, nil\n}\n\nfunc (*tagSelector) selectAfterTags(tags []*Tag, token string) ([]*Tag, string, error) {\n\t// NOTE(clok): the res slice can range in size based on the token passed in.\n\tvar ( //nolint:prealloc\n\t\tres  []*Tag\n\t\tfrom string\n\t)\n\n\tfor i, tag := range tags {\n\t\tres = append(res, tag)\n\t\tfrom = \"\"\n\t\tif i+1 < len(tags) {\n\t\t\tfrom = tags[i+1].Name\n\t\t}\n\n\t\tif tag.Name == token {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif len(res) == 0 {\n\t\treturn res, \"\", errNotFoundTag\n\t}\n\n\treturn res, from, nil\n}\n\nfunc (s *tagSelector) selectRangeTags(tags []*Tag, old string, new string) ([]*Tag, string, error) {\n\tvar (\n\t\tres    []*Tag\n\t\tfrom   string\n\t\tenable bool\n\t)\n\n\tfor i, tag := range tags {\n\t\tif tag.Name == new {\n\t\t\tenable = true\n\t\t}\n\n\t\tif enable {\n\t\t\tfrom = \"\"\n\t\t\tif i+1 < len(tags) {\n\t\t\t\tfrom = tags[i+1].Name\n\t\t\t}\n\t\t\tres = append(res, tag)\n\t\t}\n\n\t\tif tag.Name == old {\n\t\t\tenable = false\n\t\t}\n\t}\n\n\tif len(res) == 0 {\n\t\treturn res, \"\", errNotFoundTag\n\t}\n\n\treturn res, from, nil\n}\n"
        },
        {
          "name": "tag_selector_test.go",
          "type": "blob",
          "size": 1.5166015625,
          "content": "package chglog\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTagSelector(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.True(true)\n\tselector := newTagSelector()\n\n\tfixtures := []*Tag{\n\t\t{Name: \"2.2.12-rc.12\"},\n\t\t{Name: \"2.1.0\"},\n\t\t{Name: \"v2.0.0-beta.1\"},\n\t\t{Name: \"v1.2.9\"},\n\t\t{Name: \"v1.0.0\"},\n\t}\n\n\ttable := map[string][]string{\n\t\t// Single\n\t\t\"2.2.12-rc.12\": {\n\t\t\t\"2.2.12-rc.12\",\n\t\t\t\"2.1.0\",\n\t\t},\n\t\t\"v2.0.0-beta.1\": {\n\t\t\t\"v2.0.0-beta.1\",\n\t\t\t\"v1.2.9\",\n\t\t},\n\t\t\"v1.0.0\": {\n\t\t\t\"v1.0.0\",\n\t\t\t\"\",\n\t\t},\n\t\t// ~ <tag>\n\t\t\"..2.1.0\": {\n\t\t\t\"2.1.0\",\n\t\t\t\"v2.0.0-beta.1\",\n\t\t\t\"v1.2.9\",\n\t\t\t\"v1.0.0\",\n\t\t\t\"\",\n\t\t},\n\t\t\"..v1.0.0\": {\n\t\t\t\"v1.0.0\",\n\t\t\t\"\",\n\t\t},\n\t\t// <tag> ~\n\t\t\"v2.0.0-beta.1..\": {\n\t\t\t\"2.2.12-rc.12\",\n\t\t\t\"2.1.0\",\n\t\t\t\"v2.0.0-beta.1\",\n\t\t\t\"v1.2.9\",\n\t\t},\n\t\t\"2.2.12-rc.12..\": {\n\t\t\t\"2.2.12-rc.12\",\n\t\t\t\"2.1.0\",\n\t\t},\n\t\t\"v1.0.0..\": {\n\t\t\t\"2.2.12-rc.12\",\n\t\t\t\"2.1.0\",\n\t\t\t\"v2.0.0-beta.1\",\n\t\t\t\"v1.2.9\",\n\t\t\t\"v1.0.0\",\n\t\t\t\"\",\n\t\t},\n\t\t// <tag> ~ <tag>\n\t\t\"v1.0.0..2.2.12-rc.12\": {\n\t\t\t\"2.2.12-rc.12\",\n\t\t\t\"2.1.0\",\n\t\t\t\"v2.0.0-beta.1\",\n\t\t\t\"v1.2.9\",\n\t\t\t\"v1.0.0\",\n\t\t\t\"\",\n\t\t},\n\t\t\"v1.0.0..v2.0.0-beta.1\": {\n\t\t\t\"v2.0.0-beta.1\",\n\t\t\t\"v1.2.9\",\n\t\t\t\"v1.0.0\",\n\t\t\t\"\",\n\t\t},\n\t\t\"v1.2.9..2.1.0\": {\n\t\t\t\"2.1.0\",\n\t\t\t\"v2.0.0-beta.1\",\n\t\t\t\"v1.2.9\",\n\t\t\t\"v1.0.0\",\n\t\t},\n\t}\n\n\tfor query, expected := range table {\n\t\tlist, from, err := selector.Select(fixtures, query)\n\t\tactual := make([]string, len(list))\n\t\tfor i, tag := range list {\n\t\t\tactual[i] = tag.Name\n\t\t}\n\n\t\tassert.Nil(err)\n\t\tassert.Equal(expected[0:len(expected)-1], actual)\n\t\tassert.Equal(expected[len(expected)-1], from)\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 2.0478515625,
          "content": "package chglog\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc dotGet(target interface{}, prop string) (interface{}, bool) {\n\tpath := strings.Split(prop, \".\")\n\n\tif len(path) == 0 {\n\t\treturn nil, false\n\t}\n\n\tfor _, key := range path {\n\t\tvar value reflect.Value\n\n\t\tif reflect.TypeOf(target).Kind() == reflect.Ptr {\n\t\t\tvalue = reflect.ValueOf(target).Elem()\n\t\t} else {\n\t\t\tvalue = reflect.ValueOf(target)\n\t\t}\n\n\t\t//nolint:staticcheck\n\t\tfield := value.FieldByName(strings.Title(key))\n\t\tif !field.IsValid() {\n\t\t\treturn nil, false\n\t\t}\n\n\t\ttarget = field.Interface()\n\t}\n\n\treturn target, true\n}\n\n// TODO: dotSet ...\n\nfunc assignDynamicValues(target interface{}, attrs []string, values []string) {\n\trv := reflect.ValueOf(target).Elem()\n\trt := rv.Type()\n\n\tfor i, field := range attrs {\n\t\tif f, ok := rt.FieldByName(field); ok {\n\t\t\trv.FieldByIndex(f.Index).SetString(values[i])\n\t\t}\n\t}\n}\n\nfunc compare(a interface{}, operator string, b interface{}) (bool, error) {\n\tat := reflect.TypeOf(a).String()\n\tbt := reflect.TypeOf(a).String()\n\tif at != bt {\n\t\treturn false, fmt.Errorf(\"\\\"%s\\\" and \\\"%s\\\" can not be compared\", at, bt)\n\t}\n\n\tswitch at {\n\tcase \"string\":\n\t\taa := a.(string)\n\t\tbb := b.(string)\n\t\treturn compareString(aa, operator, bb), nil\n\tcase \"int\":\n\t\taa := a.(int)\n\t\tbb := b.(int)\n\t\treturn compareInt(aa, operator, bb), nil\n\tcase \"time.Time\":\n\t\taa := a.(time.Time)\n\t\tbb := b.(time.Time)\n\t\treturn compareTime(aa, operator, bb), nil\n\t}\n\n\treturn false, nil\n}\n\nfunc compareString(a string, operator string, b string) bool {\n\tswitch operator {\n\tcase \"<\":\n\t\treturn a < b\n\tcase \">\":\n\t\treturn a > b\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareInt(a int, operator string, b int) bool {\n\tswitch operator {\n\tcase \"<\":\n\t\treturn a < b\n\tcase \">\":\n\t\treturn a > b\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareTime(a time.Time, operator string, b time.Time) bool {\n\tswitch operator {\n\tcase \"<\":\n\t\treturn !a.After(b)\n\tcase \">\":\n\t\treturn a.After(b)\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc convNewline(str, nlcode string) string {\n\treturn strings.NewReplacer(\n\t\t\"\\r\\n\", nlcode,\n\t\t\"\\r\", nlcode,\n\t\t\"\\n\", nlcode,\n\t).Replace(str)\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 1.8359375,
          "content": "package chglog\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDotGet(t *testing.T) {\n\tassert := assert.New(t)\n\tnow := time.Now()\n\n\ttype Nest struct {\n\t\tStr  string\n\t\tInt  int\n\t\tTime time.Time\n\t}\n\n\ttype Sample struct {\n\t\tStr  string\n\t\tInt  int\n\t\tDate time.Time\n\t\tNest Nest\n\t}\n\n\tsample := Sample{\n\t\tStr:  \"sample_string\",\n\t\tInt:  12,\n\t\tDate: now,\n\t\tNest: Nest{\n\t\t\tStr:  \"nest_string\",\n\t\t\tInt:  34,\n\t\t\tTime: now,\n\t\t},\n\t}\n\n\tvar val interface{}\n\tvar ok bool\n\n\t// .Str\n\tval, ok = dotGet(&sample, \"Str\")\n\tassert.True(ok)\n\tassert.Equal(val, \"sample_string\")\n\n\t// Lowercase\n\tval, ok = dotGet(&sample, \"str\")\n\tassert.True(ok)\n\tassert.Equal(val, \"sample_string\")\n\n\t// Int\n\tval, ok = dotGet(&sample, \"Int\")\n\tassert.True(ok)\n\tassert.Equal(val, 12)\n\n\t// Time\n\tval, ok = dotGet(&sample, \"Date\")\n\tassert.True(ok)\n\tassert.Equal(val, now)\n\n\t// Nest\n\tval, ok = dotGet(&sample, \"Nest.Str\")\n\tassert.True(ok)\n\tassert.Equal(val, \"nest_string\")\n\n\tval, ok = dotGet(&sample, \"Nest.Int\")\n\tassert.True(ok)\n\tassert.Equal(val, 34)\n\n\tval, ok = dotGet(&sample, \"Nest.Time\")\n\tassert.True(ok)\n\tassert.Equal(val, now)\n\n\tval, ok = dotGet(&sample, \"nest.int\")\n\tassert.True(ok)\n\tassert.Equal(val, 34)\n\n\t// Notfound\n\tval, ok = dotGet(&sample, \"not.found\")\n\tassert.False(ok)\n\tassert.Nil(val)\n}\n\nfunc TestCompare(t *testing.T) {\n\tassert := assert.New(t)\n\n\ttype sample struct {\n\t\ta        interface{}\n\t\top       string\n\t\tb        interface{}\n\t\texpected bool\n\t}\n\n\ttable := []sample{\n\t\t{0, \"<\", 1, true},\n\t\t{0, \">\", 1, false},\n\t\t{1, \">\", 0, true},\n\t\t{1, \"<\", 0, false},\n\t\t{\"a\", \"<\", \"b\", true},\n\t\t{\"a\", \">\", \"b\", false},\n\t\t{time.Unix(1518018017, 0), \"<\", time.Unix(1518018043, 0), true},\n\t\t{time.Unix(1518018017, 0), \">\", time.Unix(1518018043, 0), false},\n\t}\n\n\tfor _, sa := range table {\n\t\tactual, err := compare(sa.a, sa.op, sa.b)\n\t\tassert.Nil(err)\n\t\tassert.Equal(sa.expected, actual)\n\t}\n}\n"
        }
      ]
    }
  ]
}