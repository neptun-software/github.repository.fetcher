{
  "metadata": {
    "timestamp": 1736567289943,
    "page": 889,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fatih/gomodifytags",
      "stars": 2299,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.009765625,
          "content": ".DS_Store\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.447265625,
          "content": "Copyright (c) 2017, Fatih Arslan\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of gomodifytags nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.7294921875,
          "content": "# gomodifytags [![](https://github.com/fatih/gomodifytags/workflows/build/badge.svg)](https://github.com/fatih/gomodifytags/actions)\n\nGo tool to modify/update field tags in structs. `gomodifytags` makes it easy to\nupdate, add or delete the tags in a struct field. You can easily add new tags,\nupdate existing tags (such as appending a new key, i.e: `db`, `xml`, etc..) or\nremove existing tags. It also allows you to add and remove tag options. It's\nintended to be used by an editor, but also has modes to run it from the\nterminal. Read the usage section below for more information.\n\n![gomodifytags](https://user-images.githubusercontent.com/438920/32691304-a1c7e47c-c716-11e7-977c-f4d0f8c616be.gif)\n\n\n# Install\n\n```bash\ngo install github.com/fatih/gomodifytags@latest\n```\n\n# Supported editors\n\n* [vim-go](https://github.com/fatih/vim-go) with `:GoAddTags` and `:GoRemoveTags`\n* [go-plus (atom)](https://github.com/joefitzgerald/go-plus) with commands `golang:add-tags` and `golang:remove-tags`\n* [vscode-go](https://github.com/golang/vscode-go) with commands `Go: Add Tags` and `Go: Remove Tags`\n* [A (Acme)](https://github.com/davidrjenni/A) with commands `addtags` and `rmtags`\n* [emacs-go-tag](https://github.com/brantou/emacs-go-tag) with commands `go-tag-add` and `go-tag-remove`\n* [TextMate2](https://github.com/vigo/textmate2-gomodifytags)\n\n# Usage\n\n`gomodifytags` has multiple ways to modify a tag. Let's start with an example package:\n\n```go\npackage main\n\ntype Server struct {\n\tName        string\n\tPort        int\n\tEnableLogs  bool\n\tBaseDomain  string\n\tCredentials struct {\n\t\tUsername string\n\t\tPassword string\n\t}\n}\n```\n\nWe have to first pass a file. For that we can use the `-file` flag:\n\n```sh\n$ gomodifytags -file demo.go\n-line, -offset, -struct or -all is not passed\n```\n\nWhat are these? There are four different ways of defining **which** field tags\nto change:\n\n* `-struct`: This accepts the struct name. i.e: `-struct Server`. The name\n  should be a valid type name. The `-struct` flag selects the whole struct, and\n  thus it will operate on all fields.\n* `-field`: This accepts a field name. i.e: `-field Address`. Useful to select\n  a certain field. The name should be a valid field name. The `-struct` flag is required.\n* `-offset`: This accepts a byte offset of the file. Useful for editors to pass\n  the position under the cursor. i.e: `-offset 548`. The offset has to be\n  inside a valid struct. The `-offset` selects the whole struct. If you need\n  more granular option see `-line`\n* `-line`: This accepts a string that defines the line or lines of which fields\n  should be changed. I.e: `-line 4` or `-line 5,8`\n* `-all`: This is a boolean. The `-all` flag selects all structs of the given file.\n\nLet's continue by using the `-struct` tag:\n\n```\n$ gomodifytags -file demo.go -struct Server\none of [-add-tags, -add-options, -remove-tags, -remove-options, -clear-tags, -clear-options] should be defined\n```\n\n## Adding tags & options\n\nThere are many options on how you can change the struct. Let us start by adding\ntags. The following will add the `json` key to all fields. The value will be\nautomatically inherited from the field name and transformed to `snake_case`:\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags json\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\"`\n\tPort        int    `json:\"port\"`\n\tEnableLogs  bool   `json:\"enable_logs\"`\n\tBaseDomain  string `json:\"base_domain\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\"`\n\t\tPassword string `json:\"password\"`\n\t} `json:\"credentials\"`\n}\n```\n\nBy default changes will be printed to stdout and can be used for dry-run your\nchanges before making destructive changes. If you want to change it permanently,\npass the `-w` (write) flag.\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags json -w\n```\n\nYou can disable printing the results to stdout with the `--quiet` flag:\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags json -w --quiet\n```\n\nYou can pass multiple keys to add tags. The following will add `json` and `xml`\nkeys:\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags json,xml\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\" xml:\"name\"`\n\tPort        int    `json:\"port\" xml:\"port\"`\n\tEnableLogs  bool   `json:\"enable_logs\" xml:\"enable_logs\"`\n\tBaseDomain  string `json:\"base_domain\" xml:\"base_domain\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\" xml:\"username\"`\n\t\tPassword string `json:\"password\" xml:\"password\"`\n\t} `json:\"credentials\" xml:\"credentials\"`\n}\n```\n\nIf you prefer to use `camelCase` instead of `snake_case` for the values, you\ncan use the `-transform` flag to define a different transformation rule. The\nfollowing example uses the `camelcase` transformation rule:\n\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags json,xml -transform camelcase\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\" xml:\"name\"`\n\tPort        int    `json:\"port\" xml:\"port\"`\n\tEnableLogs  bool   `json:\"enableLogs\" xml:\"enableLogs\"`\n\tBaseDomain  string `json:\"baseDomain\" xml:\"baseDomain\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\" xml:\"username\"`\n\t\tPassword string `json:\"password\" xml:\"password\"`\n\t} `json:\"credentials\" xml:\"credentials\"`\n}\n```\n\n### Formatting tag values\n\nBy default a struct tag's value is transformed from a struct's field and used\ndirectly. As an example for the field `Server string`, we generate a tag in the\nform: `json:\"server\"` (assuming `-add-tags=json` is used).\n\nHowever, some third party libraries use tags in a different way and might\nrequire to them to have a particular formatting, such as is the case of\nprefixing them (`field_name=<your_value>`). The `--template` flag allows you to\nspecify a custom format for the tag value to be applied.\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags gaum -template \"field_name={field}\" \n```\n\n```go\npackage main\n\ntype Server struct {\n\tName        string `gaum:\"field_name=name\"`\n\tPort        int    `gaum:\"field_name=port\"`\n\tEnableLogs  bool   `gaum:\"field_name=enableLogs\"`\n\tBaseDomain  string `gaum:\"field_name=baseDomain\"`\n}\n```\n\nThe `{field}` word is a special keyword that is replaced by the struct tag's value\n**after** the [transformation](https://github.com/fatih/gomodifytags#transformations). \n\n### Transformations\n\nWe currently support the following transformations:\n\n* `snakecase`: `\"BaseDomain\"` -> `\"base_domain\"`\n* `camelcase`: `\"BaseDomain\"` -> `\"baseDomain\"`\n* `lispcase`:  `\"BaseDomain\"` -> `\"base-domain\"`\n* `pascalcase`:  `\"BaseDomain\"` -> `\"BaseDomain\"`\n* `titlecase`:  `\"BaseDomain\"` -> `\"Base Domain\"`\n* `keep`:  keeps the original field name\n\nYou can also pass a static value for each fields. This is useful if you use Go\npackages that validates the struct fields or extract values for certain\noperations. The following example adds the `json` key, a `validate` key with\nthe value set to `gt=1` and the `scope` key with the value `read-only`:\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags json,validate:gt=1,scope:read-only\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\" validate:\"gt=1\" scope:\"read-only\"`\n\tPort        int    `json:\"port\" validate:\"gt=1\" scope:\"read-only\"`\n\tEnableLogs  bool   `json:\"enable_logs\" validate:\"gt=1\" scope:\"read-only\"`\n\tBaseDomain  string `json:\"base_domain\" validate:\"gt=1\" scope:\"read-only\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\" validate:\"gt=1\" scope:\"read-only\"`\n\t\tPassword string `json:\"password\" validate:\"gt=1\" scope:\"read-only\"`\n\t} `json:\"credentials\" validate:\"gt=1\" scope:\"read-only\"`\n}\n```\n\nTo add `options` to for a given key, we use the `-add-options` flag. In the\nexample below we're going to add the `json` key and the `omitempty` option to\nall json keys:\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags json -add-options json=omitempty\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name,omitempty\"`\n\tPort        int    `json:\"port,omitempty\"`\n\tEnableLogs  bool   `json:\"enable_logs,omitempty\"`\n\tBaseDomain  string `json:\"base_domain,omitempty\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username,omitempty\"`\n\t\tPassword string `json:\"password,omitempty\"`\n\t} `json:\"credentials,omitempty\"`\n}\n```\n\nIf the key already exists you don't have to use `-add-tags`\n\n\n### Skipping unexported fields\n\nBy default all fields are processed. This main reason for this is to allow\nstructs to evolve with time and be ready in case a field is exported in the\nfuture. However if you don't like this behavior, you can skip it by passing the\n`--skip-unexported` flag:\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags json --skip-unexported\n```\n```go\npackage main\n\ntype Server struct {\n        Name       string `json:\"name\"`\n        Port       int    `json:\"port\"`\n        enableLogs bool\n        baseDomain string\n}\n```\n\n## Removing tags & options\n\nLet's continue with removing tags. We're going to use the following simple package:\n\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name,omitempty\" xml:\"name,attr,cdata\"`\n\tPort        int    `json:\"port,omitempty\" xml:\"port,attr,cdata\"`\n\tEnableLogs  bool   `json:\"enable_logs,omitempty\" xml:\"enable_logs,attr,cdata\"`\n\tBaseDomain  string `json:\"base_domain,omitempty\" xml:\"base_domain,attr,cdata\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username,omitempty\" xml:\"username,attr,cdata\"`\n\t\tPassword string `json:\"password,omitempty\" xml:\"password,attr,cdata\"`\n\t} `json:\"credentials,omitempty\" xml:\"credentials,attr,cdata\"`\n}\n```\n\nTo remove the xml tags, we're going to use the `-remove-tags` flag:\n\n```\n$ gomodifytags -file demo.go -struct Server -remove-tags xml\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\"`\n\tPort        int    `json:\"port\"`\n\tEnableLogs  bool   `json:\"enable_logs\"`\n\tBaseDomain  string `json:\"base_domain\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\"`\n\t\tPassword string `json:\"password\"`\n\t} `json:\"credentials\"`\n}\n```\n\nYou can also remove multiple tags. The example below removs `json` and `xml`:\n\n```\n$ gomodifytags -file demo.go -struct Server -remove-tags json,xml\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string\n\tPort        int\n\tEnableLogs  bool\n\tBaseDomain  string\n\tCredentials struct {\n\t\tUsername string\n\t\tPassword string\n\t}\n}\n```\n\nIf you want to remove all keys, we can also use the `-clear-tags` flag. This\nflag removes all tags and doesn't require to explicitly pass the key names:\n\n```\n$ gomodifytags -file demo.go -struct Server -clear-tags\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string\n\tPort        int\n\tEnableLogs  bool\n\tBaseDomain  string\n\tCredentials struct {\n\t\tUsername string\n\t\tPassword string\n\t}\n}\n```\n\nTo remove any option, we can use the `-remove-options` flag. The following will\nremove all `omitempty` flags from the `json` key:\n\n```\n$ gomodifytags -file demo.go -struct Server -remove-options json=omitempty\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\" xml:\"name,attr,cdata\"`\n\tPort        int    `json:\"port\" xml:\"port,attr,cdata\"`\n\tEnableLogs  bool   `json:\"enable_logs\" xml:\"enable_logs,attr,cdata\"`\n\tBaseDomain  string `json:\"base_domain\" xml:\"base_domain,attr,cdata\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\" xml:\"username,attr,cdata\"`\n\t\tPassword string `json:\"password\" xml:\"password,attr,cdata\"`\n\t} `json:\"credentials\" xml:\"credentials,attr,cdata\"`\n}\n```\n\nTo remove multiple options from multiple tags just add another options:\n\n```\n$ gomodifytags -file demo.go -struct Server -remove-options json=omitempty,xml=cdata\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\" xml:\"name,attr\"`\n\tPort        int    `json:\"port\" xml:\"port,attr\"`\n\tEnableLogs  bool   `json:\"enable_logs\" xml:\"enable_logs,attr\"`\n\tBaseDomain  string `json:\"base_domain\" xml:\"base_domain,attr\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\" xml:\"username,attr\"`\n\t\tPassword string `json:\"password\" xml:\"password,attr\"`\n\t} `json:\"credentials\" xml:\"credentials,attr\"`\n}\n```\n\nLastly, to remove all options without explicitly defining the keys and names,\nwe can use the `-clear-options` flag. The following example will remove all\noptions for the given struct:\n\n```\n$ gomodifytags -file demo.go -struct Server -clear-options\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\" xml:\"name\"`\n\tPort        int    `json:\"port\" xml:\"port\"`\n\tEnableLogs  bool   `json:\"enable_logs\" xml:\"enable_logs\"`\n\tBaseDomain  string `json:\"base_domain\" xml:\"base_domain\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\" xml:\"username\"`\n\t\tPassword string `json:\"password\" xml:\"password\"`\n\t} `json:\"credentials\" xml:\"credentials\"`\n}\n```\n\n## Line based modification\n\nSo far all examples used the `-struct` flag. However we also can pass the line\nnumbers to only change certain files. Suppose we only want to remove the tags\nfor the `Credentials` struct (including the fields) for the following code (lines are included):\n\n```go\n01  package main\n02  \n03  type Server struct {\n04  \tName        string `json:\"name\" xml:\"name\"`\n05  \tPort        int    `json:\"port\" xml:\"port\"`\n06  \tEnableLogs  bool   `json:\"enable_logs\" xml:\"enable_logs\"`\n07  \tBaseDomain  string `json:\"base_domain\" xml:\"base_domain\"`\n08  \tCredentials struct {\n09  \t\tUsername string `json:\"username\" xml:\"username\"`\n10  \t\tPassword string `json:\"password\" xml:\"password\"`\n11  \t} `json:\"credentials\" xml:\"credentials\"`\n12  }\n```\n\nTo remove the tags for the credentials we're going to pass the `-line` flag:\n\n```\n$ gomodifytags -file demo.go -line 8,11 -clear-tags xml\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\" xml:\"name\"`\n\tPort        int    `json:\"port\" xml:\"port\"`\n\tEnableLogs  bool   `json:\"enable_logs\" xml:\"enable_logs\"`\n\tBaseDomain  string `json:\"base_domain\" xml:\"base_domain\"`\n\tCredentials struct {\n\t\tUsername string\n\t\tPassword string\n\t}\n}\n```\n\nFor removing the xml tags for certain lines, we can use the `-remove-tags`\nfield. The following example will remove the `xml` tags for the lines 6 and 7\n(fields with names of `EnableLogs` and `BaseDomain`):\n\n```\n$ gomodifytags -file demo.go -line 6,7 -remove-tags xml\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\" xml:\"name\"`\n\tPort        int    `json:\"port\" xml:\"port\"`\n\tEnableLogs  bool   `json:\"enable_logs\"`\n\tBaseDomain  string `json:\"base_domain\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\" xml:\"username\"`\n\t\tPassword string `json:\"password\" xml:\"password\"`\n\t} `json:\"credentials\" xml:\"credentials\"`\n}\n```\n\nThe same logic applies to adding tags or any other option as well. To add the\n`bson` tag to the lines between 5 and 7, we can use the following example:\n\n```\n$ gomodifytags -file demo.go -line 5,7 -add-tags bson\n```\n```go\npackage main\n\ntype Server struct {\n\tName        string `json:\"name\" xml:\"name\"`\n\tPort        int    `json:\"port\" xml:\"port\" bson:\"port\"`\n\tEnableLogs  bool   `json:\"enable_logs\" xml:\"enable_logs\" bson:\"enable_logs\"`\n\tBaseDomain  string `json:\"base_domain\" xml:\"base_domain\" bson:\"base_domain\"`\n\tCredentials struct {\n\t\tUsername string `json:\"username\" xml:\"username\"`\n\t\tPassword string `json:\"password\" xml:\"password\"`\n\t} `json:\"credentials\" xml:\"credentials\"`\n}\n```\n\n## Editor integration\n\nEditors can use the tool by calling the tool and then either replace the buffer\nwith the stdout or use the `-w` flag.\n\nAlso `-line` and `-offset` flags should be preferred to be used with editors.\nAn editor can select a range of lines and then pass it to `-line` flag. The\neditor also can pass the offset under the cursor if it's inside the struct to\n`-offset`\n\nEditors also can use the `-format` flag to output a json output with the\nchanged lines. This is useful if you want to explicitly replace the buffer with\nthe given lines. For the file below:\n\n\n```go\npackage main\n\ntype Server struct {\n\tName        string\n\tPort        int\n\tEnableLogs  bool\n\tBaseDomain  string\n\tCredentials struct {\n\t\tUsername string\n\t\tPassword string\n\t}\n}\n```\n\nIf we add the `xml` tag and tell to output the format in json  with the\n`-format` flag, the following will be printed:\n\n```\n$ gomodifytags -file demo.go -struct Server -add-tags xml -format json\n```\n```json\n{\n  \"start\": 3,\n  \"end\": 12,\n  \"lines\": [\n    \"type Server struct {\",\n    \"\\tName        string `xml:\\\"name\\\"`\",\n    \"\\tPort        int    `xml:\\\"port\\\"`\",\n    \"\\tEnableLogs  bool   `xml:\\\"enable_logs\\\"`\",\n    \"\\tBaseDomain  string `xml:\\\"base_domain\\\"`\",\n    \"\\tCredentials struct {\",\n    \"\\t\\tUsername string `xml:\\\"username\\\"`\",\n    \"\\t\\tPassword string `xml:\\\"password\\\"`\",\n    \"\\t} `xml:\\\"credentials\\\"`\",\n    \"}\"\n  ]\n}\n```\n\nThe output is defined with the following Go struct:\n\n```go\ntype output struct {\n\tStart int      `json:\"start\"`\n\tEnd   int      `json:\"end\"`\n\tLines []string `json:\"lines\"`\n}\n```\n\nThe `start` and `end` specifies the positions in the file the `lines` will\napply.  With this information, you can replace the editor buffer by iterating\nover the `lines` and set it for the given range. An example how it's done in\nvim-go in Vimscript is:\n\n```viml\nlet index = 0\nfor line_number in range(start, end)\n  call setline(line_number, lines[index])\n  let index += 1\nendfor\n```\n\n### Unsaved files\n\nEditors can supply `gomodifytags` with the contents of unsaved buffers by using\nthe `-modified` flag and writing an archive to stdin.  Files in the archive\nwill be preferred over those on disk.\n\nEach archive entry consists of:\n - the file name, followed by a newline\n - the (decimal) file size, followed by a newline\n - the contents of the file\n\n# Development\n\nAt least Go `v1.11.x` is required. Older versions might work, but it's not\nrecommended. First, checkout the repository:\n\n```\ngit clone https://github.com/fatih/gomodifytags.git\n```\n\nStart developing the code. To build a binary, execute:\n\n```\ngo build\n```\n\nThis will create a `gomodifytags` binary in the current directory. To test the\npackage, run the following:\n\n```\ngo test -v\n```\n\nIf everything works fine, feel free to open a pull request with your changes.\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1533203125,
          "content": "module github.com/fatih/gomodifytags\n\nrequire (\n\tgithub.com/fatih/camelcase v1.0.0\n\tgithub.com/fatih/structtag v1.2.0\n\tgolang.org/x/tools v0.23.0\n)\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 6.4150390625,
          "content": "github.com/fatih/camelcase v1.0.0 h1:hxNvNX/xYBp0ovncs8WyWZrOrpBNub/JfaMvbURyft8=\ngithub.com/fatih/camelcase v1.0.0/go.mod h1:yN2Sb0lFhZJUdVvtELVWefmrXpuZESvPmqwoZc+/fpc=\ngithub.com/fatih/structtag v1.2.0 h1:/OdNE99OxoI/PqaW/SuSK9uxxT3f/tcSZgon/ssNSx4=\ngithub.com/fatih/structtag v1.2.0/go.mod h1:mBJUNpUnHmRKrKlQQlmCrh5PuhftFbNv8Ys4/aAZl94=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\ngolang.org/x/crypto v0.25.0/go.mod h1:T+wALwcMOSE0kXgUAnPAHqTLW+XHgcELELW8VaDgm/M=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.19.0 h1:fEdghXQSo20giMthA7cd28ZC+jts4amQ3YMXiP5oMQ8=\ngolang.org/x/mod v0.19.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/net v0.27.0/go.mod h1:dDi0PyhWNoiUOrAS8uXv/vnScO4wnHQO4mj9fn/RytE=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.7.0 h1:YsImfSBoP9QPYL0xyKJPq0gcaJdG3rInoqxTWbfQu9M=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.22.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\ngolang.org/x/telemetry v0.0.0-20240521205824-bda55230c457/go.mod h1:pRgIJT+bRLFKnoM1ldnzKoxTIn14Yxz928LQRYYgIN0=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\ngolang.org/x/term v0.22.0/go.mod h1:F3qCibpT5AMpCRfhfT53vVJwhLtIVHhB9XDjfFvnMI4=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/tools v0.23.0 h1:SGsXPZ+2l4JsgaCKkx+FQ9YZ5XEtA1GZYuoDjenLjvg=\ngolang.org/x/tools v0.23.0/go.mod h1:pnu6ufv6vQkll6szChhK3C3L/ruaIv5eBeztNG8wtsI=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 20.9970703125,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/format\"\n\t\"go/parser\"\n\t\"go/printer\"\n\t\"go/token\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/fatih/camelcase\"\n\t\"github.com/fatih/structtag\"\n\t\"golang.org/x/tools/go/buildutil\"\n)\n\n// structType contains a structType node and it's name. It's a convenient\n// helper type, because *ast.StructType doesn't contain the name of the struct\ntype structType struct {\n\tname string\n\tnode *ast.StructType\n}\n\n// output is used usually by editors\ntype output struct {\n\tStart  int      `json:\"start\"`\n\tEnd    int      `json:\"end\"`\n\tLines  []string `json:\"lines\"`\n\tErrors []string `json:\"errors,omitempty\"`\n}\n\n// config defines how tags should be modified\ntype config struct {\n\tfile     string\n\toutput   string\n\tquiet    bool\n\twrite    bool\n\tmodified io.Reader\n\n\toffset     int\n\tstructName string\n\tfieldName  string\n\tline       string\n\tstart, end int\n\tall        bool\n\n\tfset *token.FileSet\n\n\tremove        []string\n\tremoveOptions []string\n\n\tadd                  []string\n\taddOptions           []string\n\toverride             bool\n\tskipUnexportedFields bool\n\n\ttransform   string\n\tsort        bool\n\tvalueFormat string\n\tclear       bool\n\tclearOption bool\n}\n\nfunc main() {\n\tif err := realMain(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err.Error())\n\t\tos.Exit(1)\n\t}\n}\n\nfunc realMain() error {\n\tcfg, err := parseConfig(os.Args[1:])\n\tif err != nil {\n\t\tif err == flag.ErrHelp {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\terr = cfg.validate()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnode, err := cfg.parse()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstart, end, err := cfg.findSelection(node)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trewrittenNode, errs := cfg.rewrite(node, start, end)\n\tif errs != nil {\n\t\tif _, ok := errs.(*rewriteErrors); !ok {\n\t\t\treturn errs\n\t\t}\n\t}\n\n\tout, err := cfg.format(rewrittenNode, errs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !cfg.quiet {\n\t\tfmt.Println(out)\n\t}\n\treturn nil\n}\n\nfunc parseConfig(args []string) (*config, error) {\n\tvar (\n\t\t// file flags\n\t\tflagFile  = flag.String(\"file\", \"\", \"Filename to be parsed\")\n\t\tflagWrite = flag.Bool(\"w\", false, \"Write results to (source) file\")\n\t\tflagQuiet = flag.Bool(\"quiet\", false, \"Don't print result to stdout\")\n\n\t\tflagOutput = flag.String(\"format\", \"source\", \"Output format.\"+\n\t\t\t\"By default it's the whole file. Options: [source, json]\")\n\t\tflagModified = flag.Bool(\"modified\", false, \"read an archive of modified files from standard input\")\n\n\t\t// processing modes\n\t\tflagOffset = flag.Int(\"offset\", 0,\n\t\t\t\"Byte offset of the cursor position inside a struct.\"+\n\t\t\t\t\"Can be anwhere from the comment until closing bracket\")\n\t\tflagLine = flag.String(\"line\", \"\",\n\t\t\t\"Line number of the field or a range of line. i.e: 4 or 4,8\")\n\t\tflagStruct = flag.String(\"struct\", \"\", \"Struct name to be processed\")\n\t\tflagField  = flag.String(\"field\", \"\", \"Field name to be processed\")\n\t\tflagAll    = flag.Bool(\"all\", false, \"Select all structs to be processed\")\n\n\t\t// tag flags\n\t\tflagRemoveTags = flag.String(\"remove-tags\", \"\",\n\t\t\t\"Remove tags for the comma separated list of keys\")\n\t\tflagClearTags = flag.Bool(\"clear-tags\", false,\n\t\t\t\"Clear all tags\")\n\t\tflagAddTags = flag.String(\"add-tags\", \"\",\n\t\t\t\"Adds tags for the comma separated list of keys.\"+\n\t\t\t\t\"Keys can contain a static value, i,e: json:foo\")\n\t\tflagOverride             = flag.Bool(\"override\", false, \"Override current tags when adding tags\")\n\t\tflagSkipUnexportedFields = flag.Bool(\"skip-unexported\", false, \"Skip unexported fields\")\n\t\tflagTransform            = flag.String(\"transform\", \"snakecase\",\n\t\t\t\"Transform adds a transform rule when adding tags.\"+\n\t\t\t\t\" Current options: [snakecase, camelcase, lispcase, pascalcase, titlecase, keep]\")\n\t\tflagSort = flag.Bool(\"sort\", false,\n\t\t\t\"Sort sorts the tags in increasing order according to the key name\")\n\n\t\t// formatting\n\t\tflagFormatting = flag.String(\"template\", \"\",\n\t\t\t\"Format the given tag's value. i.e: \\\"column:{field}\\\", \\\"field_name={field}\\\"\")\n\n\t\t// option flags\n\t\tflagRemoveOptions = flag.String(\"remove-options\", \"\",\n\t\t\t\"Remove the comma separated list of options from the given keys, \"+\n\t\t\t\t\"i.e: json=omitempty,hcl=squash\")\n\t\tflagClearOptions = flag.Bool(\"clear-options\", false,\n\t\t\t\"Clear all tag options\")\n\t\tflagAddOptions = flag.String(\"add-options\", \"\",\n\t\t\t\"Add the options per given key. i.e: json=omitempty,hcl=squash\")\n\t)\n\n\t// this fails if there are flags re-defined with the same name.\n\tif err := flag.CommandLine.Parse(args); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif flag.NFlag() == 0 {\n\t\tfmt.Fprintf(os.Stderr, \"Usage of %s:\\n\", os.Args[0])\n\t\tflag.PrintDefaults()\n\t\treturn nil, flag.ErrHelp\n\t}\n\n\tcfg := &config{\n\t\tfile:                 *flagFile,\n\t\tline:                 *flagLine,\n\t\tstructName:           *flagStruct,\n\t\tfieldName:            *flagField,\n\t\toffset:               *flagOffset,\n\t\tall:                  *flagAll,\n\t\toutput:               *flagOutput,\n\t\twrite:                *flagWrite,\n\t\tquiet:                *flagQuiet,\n\t\tclear:                *flagClearTags,\n\t\tclearOption:          *flagClearOptions,\n\t\ttransform:            *flagTransform,\n\t\tsort:                 *flagSort,\n\t\tvalueFormat:          *flagFormatting,\n\t\toverride:             *flagOverride,\n\t\tskipUnexportedFields: *flagSkipUnexportedFields,\n\t}\n\n\tif *flagModified {\n\t\tcfg.modified = os.Stdin\n\t}\n\n\tif *flagAddTags != \"\" {\n\t\tcfg.add = strings.Split(*flagAddTags, \",\")\n\t}\n\n\tif *flagAddOptions != \"\" {\n\t\tcfg.addOptions = strings.Split(*flagAddOptions, \",\")\n\t}\n\n\tif *flagRemoveTags != \"\" {\n\t\tcfg.remove = strings.Split(*flagRemoveTags, \",\")\n\t}\n\n\tif *flagRemoveOptions != \"\" {\n\t\tcfg.removeOptions = strings.Split(*flagRemoveOptions, \",\")\n\t}\n\n\treturn cfg, nil\n\n}\n\nfunc (c *config) parse() (ast.Node, error) {\n\tc.fset = token.NewFileSet()\n\tvar contents interface{}\n\tif c.modified != nil {\n\t\tarchive, err := buildutil.ParseOverlayArchive(c.modified)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse -modified archive: %v\", err)\n\t\t}\n\t\tfc, ok := archive[c.file]\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"couldn't find %s in archive\", c.file)\n\t\t}\n\t\tcontents = fc\n\t}\n\n\treturn parser.ParseFile(c.fset, c.file, contents, parser.ParseComments)\n}\n\n// findSelection returns the start and end position of the fields that are\n// suspect to change. It depends on the line, struct or offset selection.\nfunc (c *config) findSelection(node ast.Node) (int, int, error) {\n\tif c.line != \"\" {\n\t\treturn c.lineSelection(node)\n\t} else if c.offset != 0 {\n\t\treturn c.offsetSelection(node)\n\t} else if c.structName != \"\" {\n\t\treturn c.structSelection(node)\n\t} else if c.all {\n\t\treturn c.allSelection(node)\n\t} else {\n\t\treturn 0, 0, errors.New(\"-line, -offset, -struct or -all is not passed\")\n\t}\n}\n\nfunc (c *config) process(fieldName, tagVal string) (string, error) {\n\tvar tag string\n\tif tagVal != \"\" {\n\t\tvar err error\n\t\ttag, err = strconv.Unquote(tagVal)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\ttags, err := structtag.Parse(tag)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ttags = c.removeTags(tags)\n\ttags, err = c.removeTagOptions(tags)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ttags = c.clearTags(tags)\n\ttags = c.clearOptions(tags)\n\n\ttags, err = c.addTags(fieldName, tags)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ttags, err = c.addTagOptions(tags)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif c.sort {\n\t\tsort.Sort(tags)\n\t}\n\n\tres := tags.String()\n\tif res != \"\" {\n\t\tres = quote(tags.String())\n\t}\n\n\treturn res, nil\n}\n\nfunc (c *config) removeTags(tags *structtag.Tags) *structtag.Tags {\n\tif c.remove == nil || len(c.remove) == 0 {\n\t\treturn tags\n\t}\n\n\ttags.Delete(c.remove...)\n\treturn tags\n}\n\nfunc (c *config) clearTags(tags *structtag.Tags) *structtag.Tags {\n\tif !c.clear {\n\t\treturn tags\n\t}\n\n\ttags.Delete(tags.Keys()...)\n\treturn tags\n}\n\nfunc (c *config) clearOptions(tags *structtag.Tags) *structtag.Tags {\n\tif !c.clearOption {\n\t\treturn tags\n\t}\n\n\tfor _, t := range tags.Tags() {\n\t\tt.Options = nil\n\t}\n\n\treturn tags\n}\n\nfunc (c *config) removeTagOptions(tags *structtag.Tags) (*structtag.Tags, error) {\n\tif c.removeOptions == nil || len(c.removeOptions) == 0 {\n\t\treturn tags, nil\n\t}\n\n\tfor _, val := range c.removeOptions {\n\t\t// syntax key=option\n\t\tsplitted := strings.Split(val, \"=\")\n\t\tif len(splitted) < 2 {\n\t\t\treturn nil, errors.New(\"wrong syntax to remove an option. i.e key=option\")\n\t\t}\n\n\t\tkey := splitted[0]\n\t\toption := strings.Join(splitted[1:], \"=\")\n\n\t\ttags.DeleteOptions(key, option)\n\t}\n\n\treturn tags, nil\n}\n\nfunc (c *config) addTagOptions(tags *structtag.Tags) (*structtag.Tags, error) {\n\tif c.addOptions == nil || len(c.addOptions) == 0 {\n\t\treturn tags, nil\n\t}\n\n\tfor _, val := range c.addOptions {\n\t\t// syntax key=option\n\t\tsplitted := strings.Split(val, \"=\")\n\t\tif len(splitted) < 2 {\n\t\t\treturn nil, errors.New(\"wrong syntax to add an option. i.e key=option\")\n\t\t}\n\n\t\tkey := splitted[0]\n\t\toption := strings.Join(splitted[1:], \"=\")\n\n\t\ttags.AddOptions(key, option)\n\t}\n\n\treturn tags, nil\n}\n\nfunc (c *config) addTags(fieldName string, tags *structtag.Tags) (*structtag.Tags, error) {\n\tif c.add == nil || len(c.add) == 0 {\n\t\treturn tags, nil\n\t}\n\n\tsplitted := camelcase.Split(fieldName)\n\tname := \"\"\n\n\tunknown := false\n\tswitch c.transform {\n\tcase \"snakecase\":\n\t\tvar lowerSplitted []string\n\t\tfor _, s := range splitted {\n\t\t\ts = strings.Trim(s, \"_\")\n\t\t\tif s == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlowerSplitted = append(lowerSplitted, strings.ToLower(s))\n\t\t}\n\n\t\tname = strings.Join(lowerSplitted, \"_\")\n\tcase \"lispcase\":\n\t\tvar lowerSplitted []string\n\t\tfor _, s := range splitted {\n\t\t\tlowerSplitted = append(lowerSplitted, strings.ToLower(s))\n\t\t}\n\n\t\tname = strings.Join(lowerSplitted, \"-\")\n\tcase \"camelcase\":\n\t\tvar titled []string\n\t\tfor _, s := range splitted {\n\t\t\ttitled = append(titled, strings.Title(s))\n\t\t}\n\n\t\ttitled[0] = strings.ToLower(titled[0])\n\n\t\tname = strings.Join(titled, \"\")\n\tcase \"pascalcase\":\n\t\tvar titled []string\n\t\tfor _, s := range splitted {\n\t\t\ttitled = append(titled, strings.Title(s))\n\t\t}\n\n\t\tname = strings.Join(titled, \"\")\n\tcase \"titlecase\":\n\t\tvar titled []string\n\t\tfor _, s := range splitted {\n\t\t\ttitled = append(titled, strings.Title(s))\n\t\t}\n\n\t\tname = strings.Join(titled, \" \")\n\tcase \"keep\":\n\t\tname = fieldName\n\tdefault:\n\t\tunknown = true\n\t}\n\n\tif c.valueFormat != \"\" {\n\t\tprevName := name\n\t\tname = strings.ReplaceAll(c.valueFormat, \"{field}\", name)\n\t\tif name == c.valueFormat {\n\t\t\t// support old style for backward compatibility\n\t\t\tname = strings.ReplaceAll(c.valueFormat, \"$field\", prevName)\n\t\t}\n\t}\n\n\tfor _, key := range c.add {\n\t\tsplitted = strings.SplitN(key, \":\", 2)\n\t\tif len(splitted) >= 2 {\n\t\t\tkey = splitted[0]\n\t\t\tname = strings.Join(splitted[1:], \"\")\n\t\t} else if unknown {\n\t\t\t// the user didn't pass any value but want to use an unknown\n\t\t\t// transform. We don't return above in the default as the user\n\t\t\t// might pass a value\n\t\t\treturn nil, fmt.Errorf(\"unknown transform option %q\", c.transform)\n\t\t}\n\n\t\ttag, err := tags.Get(key)\n\t\tif err != nil {\n\t\t\t// tag doesn't exist, create a new one\n\t\t\ttag = &structtag.Tag{\n\t\t\t\tKey:  key,\n\t\t\t\tName: name,\n\t\t\t}\n\t\t} else if c.override {\n\t\t\ttag.Name = name\n\t\t}\n\n\t\tif err := tags.Set(tag); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn tags, nil\n}\n\n// collectStructs collects and maps structType nodes to their positions\nfunc collectStructs(node ast.Node) map[token.Pos]*structType {\n\tstructs := make(map[token.Pos]*structType, 0)\n\n\tcollectStructs := func(n ast.Node) bool {\n\t\tvar t ast.Expr\n\t\tvar structName string\n\n\t\tswitch x := n.(type) {\n\t\tcase *ast.TypeSpec:\n\t\t\tif x.Type == nil {\n\t\t\t\treturn true\n\n\t\t\t}\n\n\t\t\tstructName = x.Name.Name\n\t\t\tt = x.Type\n\t\tcase *ast.CompositeLit:\n\t\t\tt = x.Type\n\t\tcase *ast.ValueSpec:\n\t\t\tstructName = x.Names[0].Name\n\t\t\tt = x.Type\n\t\tcase *ast.Field:\n\t\t\t// this case also catches struct fields and the structName\n\t\t\t// therefore might contain the field name (which is wrong)\n\t\t\t// because `x.Type` in this case is not a *ast.StructType.\n\t\t\t//\n\t\t\t// We're OK with it, because, in our case *ast.Field represents\n\t\t\t// a parameter declaration, i.e:\n\t\t\t//\n\t\t\t//   func test(arg struct {\n\t\t\t//   \tField int\n\t\t\t//   }) {\n\t\t\t//   }\n\t\t\t//\n\t\t\t// and hence the struct name will be `arg`.\n\t\t\tif len(x.Names) != 0 {\n\t\t\t\tstructName = x.Names[0].Name\n\t\t\t}\n\t\t\tt = x.Type\n\t\t}\n\n\t\t// if expression is in form \"*T\" or \"[]T\", dereference to check if \"T\"\n\t\t// contains a struct expression\n\t\tt = deref(t)\n\n\t\tx, ok := t.(*ast.StructType)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\n\t\tstructs[x.Pos()] = &structType{\n\t\t\tname: structName,\n\t\t\tnode: x,\n\t\t}\n\t\treturn true\n\t}\n\n\tast.Inspect(node, collectStructs)\n\treturn structs\n}\n\nfunc (c *config) format(file ast.Node, rwErrs error) (string, error) {\n\tswitch c.output {\n\tcase \"source\":\n\t\tvar buf bytes.Buffer\n\t\terr := format.Node(&buf, c.fset, file)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif c.write {\n\t\t\terr = ioutil.WriteFile(c.file, buf.Bytes(), 0)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\n\t\treturn buf.String(), nil\n\tcase \"json\":\n\t\t// NOTE(arslan): print first the whole file and then cut out our\n\t\t// selection. The reason we don't directly print the struct is that the\n\t\t// printer is not capable of printing loosy comments, comments that are\n\t\t// not part of any field inside a struct. Those are part of *ast.File\n\t\t// and only printed inside a struct if we print the whole file. This\n\t\t// approach is the sanest and simplest way to get a struct printed\n\t\t// back. Second, our cursor might intersect two different structs with\n\t\t// other declarations in between them. Printing the file and cutting\n\t\t// the selection is the easier and simpler to do.\n\t\tvar buf bytes.Buffer\n\n\t\t// this is the default config from `format.Node()`, but we add\n\t\t// `printer.SourcePos` to get the original source position of the\n\t\t// modified lines\n\t\tcfg := printer.Config{Mode: printer.SourcePos | printer.UseSpaces | printer.TabIndent, Tabwidth: 8}\n\t\terr := cfg.Fprint(&buf, c.fset, file)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tlines, err := parseLines(&buf)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\t// prevent selection to be larger than the actual number of lines\n\t\tif c.start > len(lines) || c.end > len(lines) {\n\t\t\treturn \"\", errors.New(\"line selection is invalid\")\n\t\t}\n\n\t\tout := &output{\n\t\t\tStart: c.start,\n\t\t\tEnd:   c.end,\n\t\t\tLines: lines[c.start-1 : c.end],\n\t\t}\n\n\t\tif rwErrs != nil {\n\t\t\tif r, ok := rwErrs.(*rewriteErrors); ok {\n\t\t\t\tfor _, err := range r.errs {\n\t\t\t\t\tout.Errors = append(out.Errors, err.Error())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\to, err := json.MarshalIndent(out, \"\", \"  \")\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn string(o), nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unknown output mode: %s\", c.output)\n\t}\n}\n\nfunc (c *config) lineSelection(file ast.Node) (int, int, error) {\n\tvar err error\n\tsplitted := strings.Split(c.line, \",\")\n\n\tstart, err := strconv.Atoi(splitted[0])\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tend := start\n\tif len(splitted) == 2 {\n\t\tend, err = strconv.Atoi(splitted[1])\n\t\tif err != nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\t}\n\n\tif start > end {\n\t\treturn 0, 0, errors.New(\"wrong range. start line cannot be larger than end line\")\n\t}\n\n\treturn start, end, nil\n}\n\nfunc (c *config) structSelection(file ast.Node) (int, int, error) {\n\tstructs := collectStructs(file)\n\n\tvar encStruct *ast.StructType\n\tfor _, st := range structs {\n\t\tif st.name == c.structName {\n\t\t\tencStruct = st.node\n\t\t}\n\t}\n\n\tif encStruct == nil {\n\t\treturn 0, 0, errors.New(\"struct name does not exist\")\n\t}\n\n\t// if field name has been specified as well, only select the given field\n\tif c.fieldName != \"\" {\n\t\treturn c.fieldSelection(encStruct)\n\t}\n\n\tstart := c.fset.Position(encStruct.Pos()).Line\n\tend := c.fset.Position(encStruct.End()).Line\n\n\treturn start, end, nil\n}\n\nfunc (c *config) fieldSelection(st *ast.StructType) (int, int, error) {\n\tvar encField *ast.Field\n\tfor _, f := range st.Fields.List {\n\t\tfor _, field := range f.Names {\n\t\t\tif field.Name == c.fieldName {\n\t\t\t\tencField = f\n\t\t\t}\n\t\t}\n\t}\n\n\tif encField == nil {\n\t\treturn 0, 0, fmt.Errorf(\"struct %q doesn't have field name %q\",\n\t\t\tc.structName, c.fieldName)\n\t}\n\n\tstart := c.fset.Position(encField.Pos()).Line\n\tend := c.fset.Position(encField.End()).Line\n\n\treturn start, end, nil\n}\n\nfunc (c *config) offsetSelection(file ast.Node) (int, int, error) {\n\tstructs := collectStructs(file)\n\n\tvar encStruct *ast.StructType\n\tfor _, st := range structs {\n\t\tstructBegin := c.fset.Position(st.node.Pos()).Offset\n\t\tstructEnd := c.fset.Position(st.node.End()).Offset\n\n\t\tif structBegin <= c.offset && c.offset <= structEnd {\n\t\t\tencStruct = st.node\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif encStruct == nil {\n\t\treturn 0, 0, errors.New(\"offset is not inside a struct\")\n\t}\n\n\t// offset selects all fields\n\tstart := c.fset.Position(encStruct.Pos()).Line\n\tend := c.fset.Position(encStruct.End()).Line\n\n\treturn start, end, nil\n}\n\n// allSelection selects all structs inside a file\nfunc (c *config) allSelection(file ast.Node) (int, int, error) {\n\tstart := 1\n\tend := c.fset.File(file.Pos()).LineCount()\n\n\treturn start, end, nil\n}\n\nfunc isPublicName(name string) bool {\n\tfor _, c := range name {\n\t\treturn unicode.IsUpper(c)\n\t}\n\treturn false\n}\n\n// rewrite rewrites the node for structs between the start and end\n// positions\nfunc (c *config) rewrite(node ast.Node, start, end int) (ast.Node, error) {\n\terrs := &rewriteErrors{errs: make([]error, 0)}\n\n\trewriteFunc := func(n ast.Node) bool {\n\t\tx, ok := n.(*ast.StructType)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\n\t\tfor _, f := range x.Fields.List {\n\t\t\tline := c.fset.Position(f.Pos()).Line\n\n\t\t\tif !(start <= line && line <= end) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfieldName := \"\"\n\t\t\tif len(f.Names) != 0 {\n\t\t\t\tfor _, field := range f.Names {\n\t\t\t\t\tif !c.skipUnexportedFields || isPublicName(field.Name) {\n\t\t\t\t\t\tfieldName = field.Name\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// anonymous field\n\t\t\tif f.Names == nil {\n\t\t\t\tident, ok := f.Type.(*ast.Ident)\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif !c.skipUnexportedFields {\n\t\t\t\t\tfieldName = ident.Name\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// nothing to process, continue with next line\n\t\t\tif fieldName == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif f.Tag == nil {\n\t\t\t\tf.Tag = &ast.BasicLit{}\n\t\t\t}\n\n\t\t\tres, err := c.process(fieldName, f.Tag.Value)\n\t\t\tif err != nil {\n\t\t\t\terrs.Append(fmt.Errorf(\"%s:%d:%d:%s\",\n\t\t\t\t\tc.fset.Position(f.Pos()).Filename,\n\t\t\t\t\tc.fset.Position(f.Pos()).Line,\n\t\t\t\t\tc.fset.Position(f.Pos()).Column,\n\t\t\t\t\terr))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tf.Tag.Value = res\n\t\t}\n\n\t\treturn true\n\t}\n\n\tast.Inspect(node, rewriteFunc)\n\n\tc.start = start\n\tc.end = end\n\n\tif len(errs.errs) == 0 {\n\t\treturn node, nil\n\t}\n\n\treturn node, errs\n}\n\n// validate validates whether the config is valid or not\nfunc (c *config) validate() error {\n\tif c.file == \"\" {\n\t\treturn errors.New(\"no file is passed\")\n\t}\n\n\tif c.line == \"\" && c.offset == 0 && c.structName == \"\" && !c.all {\n\t\treturn errors.New(\"-line, -offset, -struct or -all is not passed\")\n\t}\n\n\tif c.line != \"\" && c.offset != 0 ||\n\t\tc.line != \"\" && c.structName != \"\" ||\n\t\tc.offset != 0 && c.structName != \"\" {\n\t\treturn errors.New(\"-line, -offset or -struct cannot be used together. pick one\")\n\t}\n\n\tif (c.add == nil || len(c.add) == 0) &&\n\t\t(c.addOptions == nil || len(c.addOptions) == 0) &&\n\t\t!c.clear &&\n\t\t!c.clearOption &&\n\t\t(c.removeOptions == nil || len(c.removeOptions) == 0) &&\n\t\t(c.remove == nil || len(c.remove) == 0) {\n\t\treturn errors.New(\"one of \" +\n\t\t\t\"[-add-tags, -add-options, -remove-tags, -remove-options, -clear-tags, -clear-options]\" +\n\t\t\t\" should be defined\")\n\t}\n\n\tif c.fieldName != \"\" && c.structName == \"\" {\n\t\treturn errors.New(\"-field is requiring -struct\")\n\t}\n\n\treturn nil\n}\n\nfunc quote(tag string) string {\n\treturn \"`\" + tag + \"`\"\n}\n\ntype rewriteErrors struct {\n\terrs []error\n}\n\nfunc (r *rewriteErrors) Error() string {\n\tvar buf bytes.Buffer\n\tfor _, e := range r.errs {\n\t\tbuf.WriteString(fmt.Sprintf(\"%s\\n\", e.Error()))\n\t}\n\treturn buf.String()\n}\n\nfunc (r *rewriteErrors) Append(err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tr.errs = append(r.errs, err)\n}\n\n// parseLines parses the given buffer and returns a slice of lines\nfunc parseLines(buf io.Reader) ([]string, error) {\n\tvar lines []string\n\tscanner := bufio.NewScanner(buf)\n\tfor scanner.Scan() {\n\t\ttxt := scanner.Text()\n\n\t\t// check for any line directive and store it for next iteration to\n\t\t// re-construct the original file. If it's not a line directive,\n\t\t// continue consturcting the original file\n\t\tif !strings.HasPrefix(txt, \"//line\") {\n\t\t\tlines = append(lines, txt)\n\t\t\tcontinue\n\t\t}\n\n\t\tlineNr, err := split(txt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor i := len(lines); i < lineNr-1; i++ {\n\t\t\tlines = append(lines, \"\")\n\t\t}\n\n\t\tlines = lines[:lineNr-1]\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid scanner inputl: %s\", err)\n\t}\n\n\treturn lines, nil\n}\n\n// split splits the given line directive and returns the line number\n// see https://golang.org/cmd/compile/#hdr-Compiler_Directives for more\n// information\n// NOTE(arslan): this only splits the line directive that the go.Parser\n// outputs. If the go parser changes the format of the line directive, make\n// sure to fix it in the below function\nfunc split(line string) (int, error) {\n\tfor i := len(line) - 1; i >= 0; i-- {\n\t\tif line[i] != ':' {\n\t\t\tcontinue\n\t\t}\n\n\t\tnr, err := strconv.Atoi(line[i+1:])\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\treturn nr, nil\n\t}\n\n\treturn 0, fmt.Errorf(\"couldn't parse line: '%s'\", line)\n}\n\n// deref takes an expression, and removes all its leading \"*\" and \"[]\"\n// operator. Uuse case : if found expression is a \"*t\" or \"[]t\", we need to\n// check if \"t\" contains a struct expression.\nfunc deref(x ast.Expr) ast.Expr {\n\tswitch t := x.(type) {\n\tcase *ast.StarExpr:\n\t\treturn deref(t.X)\n\tcase *ast.ArrayType:\n\t\treturn deref(t.Elt)\n\t}\n\treturn x\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 18.0283203125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar update = flag.Bool(\"update\", false, \"update golden (.out) files\")\n\n// This is the directory where our test fixtures are.\nconst fixtureDir = \"./test-fixtures\"\n\nfunc TestRewrite(t *testing.T) {\n\ttest := []struct {\n\t\tcfg  *config\n\t\tfile string\n\t}{\n\t\t{\n\t\t\tfile: \"struct_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:        []string{\"json\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t\ttransform:  \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"struct_add_underscore\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:        []string{\"json\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t\ttransform:  \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"struct_add_existing\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:        []string{\"json\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t\ttransform:  \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"struct_format\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:         []string{\"gaum\"},\n\t\t\t\toutput:      \"source\",\n\t\t\t\tstructName:  \"foo\",\n\t\t\t\ttransform:   \"snakecase\",\n\t\t\t\tvalueFormat: \"field_name={field}\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"struct_format_existing\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:         []string{\"gaum\"},\n\t\t\t\toutput:      \"source\",\n\t\t\t\tstructName:  \"foo\",\n\t\t\t\ttransform:   \"snakecase\",\n\t\t\t\tvalueFormat: \"field_name={field}\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"struct_format_oldstyle\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:         []string{\"gaum\"},\n\t\t\t\toutput:      \"source\",\n\t\t\t\tstructName:  \"foo\",\n\t\t\t\ttransform:   \"snakecase\",\n\t\t\t\tvalueFormat: \"field_name=$field\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"struct_format_existing_oldstyle\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:         []string{\"gaum\"},\n\t\t\t\toutput:      \"source\",\n\t\t\t\tstructName:  \"foo\",\n\t\t\t\ttransform:   \"snakecase\",\n\t\t\t\tvalueFormat: \"field_name=$field\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"struct_remove\",\n\t\t\tcfg: &config{\n\t\t\t\tremove:     []string{\"json\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"struct_clear_tags\",\n\t\t\tcfg: &config{\n\t\t\t\tclear:      true,\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"struct_clear_options\",\n\t\t\tcfg: &config{\n\t\t\t\tclearOption: true,\n\t\t\t\toutput:      \"source\",\n\t\t\t\tstructName:  \"foo\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_override\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,5\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t\toverride:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_override_column\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json:MyBar:bar\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,4\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t\toverride:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_override_mixed_column_and_equal\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json:MyBar:bar:foo=qux\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,4\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t\toverride:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_override_multi_equal\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json:MyBar=bar=foo\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,4\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t\toverride:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_override_multi_column\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json:MyBar:bar:foo\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,4\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t\toverride:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_no_override\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,5\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_outside\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"2,8\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_outside_partial_start\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"2,5\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_outside_partial_end\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"5,8\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_intersect_partial\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"5,11\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_comment\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"6,7\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_option\",\n\t\t\tcfg: &config{\n\t\t\t\taddOptions: []string{\"json=omitempty\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tline:       \"4,7\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_option_existing\",\n\t\t\tcfg: &config{\n\t\t\t\taddOptions: []string{\"json=omitempty\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tline:       \"6,8\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_multiple_option\",\n\t\t\tcfg: &config{\n\t\t\t\taddOptions: []string{\"json=omitempty\", \"hcl=squash\"},\n\t\t\t\tadd:        []string{\"hcl\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tline:       \"4,7\",\n\t\t\t\ttransform:  \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_add_option_with_equal\",\n\t\t\tcfg: &config{\n\t\t\t\taddOptions: []string{\"validate=max=32\"},\n\t\t\t\tadd:        []string{\"validate\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tline:       \"4,7\",\n\t\t\t\ttransform:  \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_remove\",\n\t\t\tcfg: &config{\n\t\t\t\tremove: []string{\"json\"},\n\t\t\t\toutput: \"source\",\n\t\t\t\tline:   \"5,7\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_remove_option\",\n\t\t\tcfg: &config{\n\t\t\t\tremoveOptions: []string{\"hcl=squash\"},\n\t\t\t\toutput:        \"source\",\n\t\t\t\tline:          \"4,8\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_remove_options\",\n\t\t\tcfg: &config{\n\t\t\t\tremoveOptions: []string{\"json=omitempty\", \"hcl=omitnested\"},\n\t\t\t\toutput:        \"source\",\n\t\t\t\tline:          \"4,7\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_remove_option_with_equal\",\n\t\t\tcfg: &config{\n\t\t\t\tremoveOptions: []string{\"validate=max=32\"},\n\t\t\t\toutput:        \"source\",\n\t\t\t\tline:          \"4,7\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_multiple_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"5,6\",\n\t\t\t\ttransform: \"camelcase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_lispcase_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,6\",\n\t\t\t\ttransform: \"lispcase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_camelcase_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,5\",\n\t\t\t\ttransform: \"camelcase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_camelcase_add_embedded\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,6\",\n\t\t\t\ttransform: \"camelcase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_value_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:    []string{\"json:foo\"},\n\t\t\t\toutput: \"source\",\n\t\t\t\tline:   \"4,6\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"offset_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\toffset:    32,\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"offset_add_composite\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\toffset:    40,\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"offset_add_duplicate\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\toffset:    209,\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"offset_add_literal_in\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\toffset:    46,\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"offset_add_literal_out\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\toffset:    32,\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"errors\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,7\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_pascalcase_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,5\",\n\t\t\t\ttransform: \"pascalcase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_pascalcase_add_embedded\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,6\",\n\t\t\t\ttransform: \"pascalcase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"not_formatted\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"3,4\",\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"skip_private\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:                  []string{\"json\"},\n\t\t\t\toutput:               \"source\",\n\t\t\t\tstructName:           \"foo\",\n\t\t\t\ttransform:            \"snakecase\",\n\t\t\t\tskipUnexportedFields: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"skip_private_multiple_names\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:                  []string{\"json\"},\n\t\t\t\toutput:               \"source\",\n\t\t\t\tstructName:           \"foo\",\n\t\t\t\ttransform:            \"snakecase\",\n\t\t\t\tskipUnexportedFields: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"skip_embedded\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:                  []string{\"json\"},\n\t\t\t\toutput:               \"source\",\n\t\t\t\tstructName:           \"StationCreated\",\n\t\t\t\ttransform:            \"snakecase\",\n\t\t\t\tskipUnexportedFields: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"all_structs\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tall:       true,\n\t\t\t\ttransform: \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_titlecase_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,6\",\n\t\t\t\ttransform: \"titlecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"line_titlecase_add_embedded\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\tline:      \"4,6\",\n\t\t\t\ttransform: \"titlecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"field_add\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:        []string{\"json\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t\tfieldName:  \"bar\",\n\t\t\t\ttransform:  \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"field_add_same_line\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:        []string{\"json\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t\tfieldName:  \"qux\",\n\t\t\t\ttransform:  \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"field_add_existing\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:        []string{\"json\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t\tfieldName:  \"bar\",\n\t\t\t\ttransform:  \"snakecase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"field_clear_tags\",\n\t\t\tcfg: &config{\n\t\t\t\tclear:      true,\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t\tfieldName:  \"bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"field_clear_options\",\n\t\t\tcfg: &config{\n\t\t\t\tclearOption: true,\n\t\t\t\toutput:      \"source\",\n\t\t\t\tstructName:  \"foo\",\n\t\t\t\tfieldName:   \"bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"field_remove\",\n\t\t\tcfg: &config{\n\t\t\t\tremove:     []string{\"json\"},\n\t\t\t\toutput:     \"source\",\n\t\t\t\tstructName: \"foo\",\n\t\t\t\tfieldName:  \"bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"offset_anonymous_struct\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\toffset:    45,\n\t\t\t\ttransform: \"camelcase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"offset_star_struct\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\toffset:    35,\n\t\t\t\ttransform: \"camelcase\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"offset_array_struct\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:       []string{\"json\"},\n\t\t\t\toutput:    \"source\",\n\t\t\t\toffset:    35,\n\t\t\t\ttransform: \"camelcase\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, ts := range test {\n\t\tt.Run(ts.file, func(t *testing.T) {\n\t\t\tts.cfg.file = filepath.Join(fixtureDir, fmt.Sprintf(\"%s.input\", ts.file))\n\n\t\t\tnode, err := ts.cfg.parse()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tstart, end, err := ts.cfg.findSelection(node)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\trewrittenNode, err := ts.cfg.rewrite(node, start, end)\n\t\t\tif err != nil {\n\t\t\t\tif _, ok := err.(*rewriteErrors); !ok {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout, err := ts.cfg.format(rewrittenNode, err)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tgot := []byte(out)\n\n\t\t\t// update golden file if necessary\n\t\t\tgolden := filepath.Join(fixtureDir, fmt.Sprintf(\"%s.golden\", ts.file))\n\t\t\tif *update {\n\t\t\t\terr := ioutil.WriteFile(golden, got, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// get golden file\n\t\t\twant, err := ioutil.ReadFile(golden)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tvar from []byte\n\t\t\tif ts.cfg.modified != nil {\n\t\t\t\tfrom, err = ioutil.ReadAll(ts.cfg.modified)\n\t\t\t} else {\n\t\t\t\tfrom, err = ioutil.ReadFile(ts.cfg.file)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\t// compare\n\t\t\tif !bytes.Equal(got, want) {\n\t\t\t\tt.Errorf(\"case %s\\ngot:\\n====\\n\\n%s\\nwant:\\n=====\\n\\n%s\\nfrom:\\n=====\\n\\n%s\\n\",\n\t\t\t\t\tts.file, got, want, from)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestJSON(t *testing.T) {\n\ttest := []struct {\n\t\tcfg  *config\n\t\tfile string\n\t\terr  error\n\t}{\n\t\t{\n\t\t\tfile: \"json_single\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:  []string{\"json\"},\n\t\t\t\tline: \"5\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"json_full\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:  []string{\"json\"},\n\t\t\t\tline: \"4,6\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"json_intersection\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:  []string{\"json\"},\n\t\t\t\tline: \"5,16\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// both small & end range larger than file\n\t\t\tfile: \"json_single\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:  []string{\"json\"},\n\t\t\t\tline: \"30,32\", // invalid selection\n\t\t\t},\n\t\t\terr: errors.New(\"line selection is invalid\"),\n\t\t},\n\t\t{\n\t\t\t// end range larger than file\n\t\t\tfile: \"json_single\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:  []string{\"json\"},\n\t\t\t\tline: \"4,50\", // invalid selection\n\t\t\t},\n\t\t\terr: errors.New(\"line selection is invalid\"),\n\t\t},\n\t\t{\n\t\t\tfile: \"json_errors\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:  []string{\"json\"},\n\t\t\t\tline: \"4,7\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"json_not_formatted\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:  []string{\"json\"},\n\t\t\t\tline: \"3,4\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"json_not_formatted_2\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:  []string{\"json\"},\n\t\t\t\tline: \"3,3\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"json_not_formatted_3\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:    []string{\"json\"},\n\t\t\t\toffset: 23,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"json_not_formatted_4\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:    []string{\"json\"},\n\t\t\t\toffset: 51,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"json_not_formatted_5\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:    []string{\"json\"},\n\t\t\t\toffset: 29,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"json_not_formatted_6\",\n\t\t\tcfg: &config{\n\t\t\t\tadd:  []string{\"json\"},\n\t\t\t\tline: \"2,54\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfile: \"json_all_structs\",\n\t\t\tcfg: &config{\n\t\t\t\tadd: []string{\"json\"},\n\t\t\t\tall: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, ts := range test {\n\t\tt.Run(ts.file, func(t *testing.T) {\n\t\t\tts.cfg.file = filepath.Join(fixtureDir, fmt.Sprintf(\"%s.input\", ts.file))\n\t\t\t// these are explicit and shouldn't be changed for this particular\n\t\t\t// main test\n\t\t\tts.cfg.output = \"json\"\n\t\t\tts.cfg.transform = \"camelcase\"\n\n\t\t\tnode, err := ts.cfg.parse()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tstart, end, err := ts.cfg.findSelection(node)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\trewrittenNode, err := ts.cfg.rewrite(node, start, end)\n\t\t\tif err != nil {\n\t\t\t\tif _, ok := err.(*rewriteErrors); !ok {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout, err := ts.cfg.format(rewrittenNode, err)\n\t\t\tif !reflect.DeepEqual(err, ts.err) {\n\t\t\t\tt.Logf(\"want: %v\", ts.err)\n\t\t\t\tt.Logf(\"got: %v\", err)\n\t\t\t\tt.Fatalf(\"unexpected error\")\n\t\t\t}\n\n\t\t\tif ts.err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot := []byte(out)\n\n\t\t\t// update golden file if necessary\n\t\t\tgolden := filepath.Join(fixtureDir, fmt.Sprintf(\"%s.golden\", ts.file))\n\t\t\tif *update {\n\t\t\t\terr := ioutil.WriteFile(golden, got, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// get golden file\n\t\t\twant, err := ioutil.ReadFile(golden)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tfrom, err := ioutil.ReadFile(ts.cfg.file)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\t// compare\n\t\t\tif !bytes.Equal(got, want) {\n\t\t\t\tt.Errorf(\"case %s\\ngot:\\n====\\n\\n%s\\nwant:\\n=====\\n\\n%s\\nfrom:\\n=====\\n\\n%s\\n\",\n\t\t\t\t\tts.file, got, want, from)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestModifiedRewrite(t *testing.T) {\n\tcfg := &config{\n\t\tadd:        []string{\"json\"},\n\t\toutput:     \"source\",\n\t\tstructName: \"foo\",\n\t\ttransform:  \"snakecase\",\n\t\tfile:       \"struct_add_modified\",\n\t\tmodified: strings.NewReader(`struct_add_modified\n55\npackage foo\n\ntype foo struct {\n\tbar string\n\tt   bool\n}\n`),\n\t}\n\n\tnode, err := cfg.parse()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstart, end, err := cfg.findSelection(node)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trewrittenNode, err := cfg.rewrite(node, start, end)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tgot, err := cfg.format(rewrittenNode, err)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tgolden := filepath.Join(fixtureDir, \"struct_add.golden\")\n\twant, err := ioutil.ReadFile(golden)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// compare\n\tif !bytes.Equal([]byte(got), want) {\n\t\tt.Errorf(\"got:\\n====\\n%s\\nwant:\\n====\\n%s\\n\", got, want)\n\t}\n}\n\nfunc TestModifiedFileMissing(t *testing.T) {\n\tcfg := &config{\n\t\tadd:        []string{\"json\"},\n\t\toutput:     \"source\",\n\t\tstructName: \"foo\",\n\t\ttransform:  \"snakecase\",\n\t\tfile:       \"struct_add_modified\",\n\t\tmodified: strings.NewReader(`file_that_doesnt_exist\n55\npackage foo\n\ntype foo struct {\n\tbar string\n\tt   bool\n}\n`),\n\t}\n\n\t_, err := cfg.parse()\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestParseLines(t *testing.T) {\n\tvar tests = []struct {\n\t\tfile string\n\t}{\n\t\t{file: \"line_directive_unix\"},\n\t\t{file: \"line_directive_windows\"},\n\t}\n\n\tfor _, ts := range tests {\n\t\tts := ts\n\n\t\tt.Run(ts.file, func(t *testing.T) {\n\t\t\tfilePath := filepath.Join(fixtureDir, fmt.Sprintf(\"%s.input\", ts.file))\n\n\t\t\tfile, err := os.Open(filePath)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer file.Close()\n\n\t\t\tout, err := parseLines(file)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\ttoBytes := func(lines []string) []byte {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\tfor _, line := range lines {\n\t\t\t\t\tbuf.WriteString(line + \"\\n\")\n\t\t\t\t}\n\t\t\t\treturn buf.Bytes()\n\t\t\t}\n\n\t\t\tgot := toBytes(out)\n\n\t\t\t// update golden file if necessary\n\t\t\tgolden := filepath.Join(fixtureDir, fmt.Sprintf(\"%s.golden\", ts.file))\n\n\t\t\tif *update {\n\t\t\t\terr := ioutil.WriteFile(golden, got, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// get golden file\n\t\t\twant, err := ioutil.ReadFile(golden)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tfrom, err := ioutil.ReadFile(filePath)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\t// compare\n\t\t\tif !bytes.Equal(got, want) {\n\t\t\t\tt.Errorf(\"case %s\\ngot:\\n====\\n\\n%s\\nwant:\\n=====\\n\\n%s\\nfrom:\\n=====\\n\\n%s\\n\",\n\t\t\t\t\tts.file, got, want, from)\n\t\t\t}\n\n\t\t})\n\t}\n}\n\nfunc TestParseConfig(t *testing.T) {\n\t// don't output help message during the test\n\tflag.CommandLine.SetOutput(ioutil.Discard)\n\n\t// The flag.CommandLine.Parse() call fails if there are flags re-defined\n\t// with the same name. If there are duplicates, parseConfig() will return\n\t// an error.\n\t_, err := parseConfig([]string{\"test\"})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "test-fixtures",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}