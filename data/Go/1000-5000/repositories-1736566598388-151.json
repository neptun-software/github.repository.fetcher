{
  "metadata": {
    "timestamp": 1736566598388,
    "page": 151,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "deckarep/golang-set",
      "stars": 4321,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2509765625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n.idea"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.140625,
          "content": "Open Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.9873046875,
          "content": "![example workflow](https://github.com/deckarep/golang-set/actions/workflows/ci.yml/badge.svg)\n[![Go Report Card](https://goreportcard.com/badge/github.com/deckarep/golang-set/v2)](https://goreportcard.com/report/github.com/deckarep/golang-set/v2)\n[![GoDoc](https://godoc.org/github.com/deckarep/golang-set/v2?status.svg)](http://godoc.org/github.com/deckarep/golang-set/v2)\n\n# golang-set\n\nThe missing `generic` set collection for the Go language.  Until Go has sets built-in...use this.\n\n## Psst\n* Hi there, ðŸ‘‹! Do you use or have interest in the [Zig programming language](https://ziglang.org/) created by Andrew Kelley? If so, the golang-set project has a new sibling project: [ziglang-set](https://github.com/deckarep/ziglang-set)! Come check it out!\n\n## Update 12/3/2024\n* Packaged version: `2.7.0` fixes a long-standing bug with *JSON Unmarshaling*. A large refactor in the interest of performance\nintroduced this bug and there was no way around it but to revert the code back to how it was previously. The performance\ndifference was likely negligible to begin with. JSON Marshaling and Unmarshaling is now properly supported again without\nneeding to do workarounds.\n\n## Update 3/5/2023\n* Packaged version: `2.2.0` release includes a refactor to minimize pointer indirection, better method documentation standards and a few constructor convenience methods to increase ergonomics when appending items `Append` or creating a new set from an exist `Map`.\n* supports `new generic` syntax\n* Go `1.18.0` or higher\n* Workflow tested on Go `1.20`\n\n![With Generics](new_improved.jpeg)\n\nComing from Python one of the things I miss is the superbly wonderful set collection.  This is my attempt to mimic the primary features of the set collection from Python.\nYou can of course argue that there is no need for a set in Go, otherwise the creators would have added one to the standard library.  To those I say simply ignore this repository and carry-on and to the rest that find this useful please contribute in helping me make it better by contributing with suggestions or PRs.\n\n## Install\n\nUse `go get` to install this package.\n\n```shell\ngo get github.com/deckarep/golang-set/v2\n```\n\n## Features\n\n* *NEW* [Generics](https://go.dev/doc/tutorial/generics) based implementation (requires [Go 1.18](https://go.dev/blog/go1.18beta1) or higher)\n* One common *interface* to both implementations\n  * a **non threadsafe** implementation favoring *performance*\n  * a **threadsafe** implementation favoring *concurrent* use\n* Feature complete set implementation modeled after [Python's set implementation](https://docs.python.org/3/library/stdtypes.html#set).\n* Exhaustive unit-test and benchmark suite\n\n## Trusted by\n\nThis package is trusted by many companies and thousands of open-source packages. Here are just a few sample users of this package.\n\n* Notable projects/companies using this package\n  * Ethereum\n  * Docker\n  * 1Password\n  * Hashicorp\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=deckarep/golang-set&type=Date)](https://star-history.com/#deckarep/golang-set&Date)\n\n\n## Usage\n\nThe code below demonstrates how a Set collection can better manage data and actually minimize boilerplate and needless loops in code. This package now fully supports *generic* syntax so you are now able to instantiate a collection for any [comparable](https://flaviocopes.com/golang-comparing-values/) type object.\n\nWhat is considered comparable in Go? \n* `Booleans`, `integers`, `strings`, `floats` or basically primitive types.\n* `Pointers`\n* `Arrays`\n* `Structs` if *all of their fields* are also comparable independently\n\nUsing this library is as simple as creating either a threadsafe or non-threadsafe set and providing a `comparable` type for instantiation of the collection.\n\n```go\n// Syntax example, doesn't compile.\nmySet := mapset.NewSet[T]() // where T is some concrete comparable type.\n\n// Therefore this code creates an int set\nmySet := mapset.NewSet[int]()\n\n// Or perhaps you want a string set\nmySet := mapset.NewSet[string]()\n\ntype myStruct struct {\n  name string\n  age uint8\n}\n\n// Alternatively a set of structs\nmySet := mapset.NewSet[myStruct]()\n\n// Lastly a set that can hold anything using the any or empty interface keyword: interface{}. This is effectively removes type safety.\nmySet := mapset.NewSet[any]()\n```\n\n## Comprehensive Example\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n  mapset \"github.com/deckarep/golang-set/v2\"\n)\n\nfunc main() {\n  // Create a string-based set of required classes.\n  required := mapset.NewSet[string]()\n  required.Add(\"cooking\")\n  required.Add(\"english\")\n  required.Add(\"math\")\n  required.Add(\"biology\")\n\n  // Create a string-based set of science classes.\n  sciences := mapset.NewSet[string]()\n  sciences.Add(\"biology\")\n  sciences.Add(\"chemistry\")\n  \n  // Create a string-based set of electives.\n  electives := mapset.NewSet[string]()\n  electives.Add(\"welding\")\n  electives.Add(\"music\")\n  electives.Add(\"automotive\")\n\n  // Create a string-based set of bonus programming classes.\n  bonus := mapset.NewSet[string]()\n  bonus.Add(\"beginner go\")\n  bonus.Add(\"python for dummies\")\n}\n```\n\nCreate a set of all unique classes.\nSets will *automatically* deduplicate the same data.\n\n```go\n  all := required\n    .Union(sciences)\n    .Union(electives)\n    .Union(bonus)\n  \n  fmt.Println(all)\n```\n\nOutput:\n```sh\nSet{cooking, english, math, chemistry, welding, biology, music, automotive, beginner go, python for dummies}\n```\n\nIs cooking considered a science class?\n```go\nresult := sciences.Contains(\"cooking\")\nfmt.Println(result)\n```\n\nOutput:\n```false\nfalse\n```\n\nShow me all classes that are not science classes, since I don't enjoy science.\n```go\nnotScience := all.Difference(sciences)\nfmt.Println(notScience)\n```\n\n```sh\nSet{ music, automotive, beginner go, python for dummies, cooking, english, math, welding }\n```\n\nWhich science classes are also required classes?\n```go\nreqScience := sciences.Intersect(required)\n```\n\nOutput:\n```sh\nSet{biology}\n```\n\nHow many bonus classes do you offer?\n```go\nfmt.Println(bonus.Cardinality())\n```\nOutput:\n```sh\n2\n```\n\nThanks for visiting!\n\n-deckarep\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 17.4765625,
          "content": "/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n)\n\nfunc nrand(n int) []int {\n\ti := make([]int, n)\n\tfor ind := range i {\n\t\ti[ind] = rand.Int()\n\t}\n\treturn i\n}\n\nfunc benchAdd(b *testing.B, n int, newSet func(...int) Set[int]) {\n\tnums := nrand(n)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts := newSet()\n\t\tfor _, v := range nums {\n\t\t\ts.Add(v)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAddSafe(b *testing.B) {\n\tbenchAdd(b, 1000, NewSet[int])\n}\n\nfunc BenchmarkAddUnsafe(b *testing.B) {\n\tbenchAdd(b, 1000, NewThreadUnsafeSet[int])\n}\n\nfunc benchRemove(b *testing.B, s Set[int]) {\n\tnums := nrand(b.N)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor _, v := range nums {\n\t\ts.Remove(v)\n\t}\n}\n\nfunc BenchmarkRemoveSafe(b *testing.B) {\n\tbenchRemove(b, NewSet[int]())\n}\n\nfunc BenchmarkRemoveUnsafe(b *testing.B) {\n\tbenchRemove(b, NewThreadUnsafeSet[int]())\n}\n\nfunc benchCardinality(b *testing.B, s Set[int]) {\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Cardinality()\n\t}\n}\n\nfunc BenchmarkCardinalitySafe(b *testing.B) {\n\tbenchCardinality(b, NewSet[int]())\n}\n\nfunc BenchmarkCardinalityUnsafe(b *testing.B) {\n\tbenchCardinality(b, NewThreadUnsafeSet[int]())\n}\n\nfunc benchClear(b *testing.B, s Set[int]) {\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Clear()\n\t}\n}\n\nfunc BenchmarkClearSafe(b *testing.B) {\n\tbenchClear(b, NewSet[int]())\n}\n\nfunc BenchmarkClearUnsafe(b *testing.B) {\n\tbenchClear(b, NewThreadUnsafeSet[int]())\n}\n\nfunc benchClone(b *testing.B, n int, s Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Clone()\n\t}\n}\n\nfunc BenchmarkClone1Safe(b *testing.B) {\n\tbenchClone(b, 1, NewSet[int]())\n}\n\nfunc BenchmarkClone1Unsafe(b *testing.B) {\n\tbenchClone(b, 1, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkClone10Safe(b *testing.B) {\n\tbenchClone(b, 10, NewSet[int]())\n}\n\nfunc BenchmarkClone10Unsafe(b *testing.B) {\n\tbenchClone(b, 10, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkClone100Safe(b *testing.B) {\n\tbenchClone(b, 100, NewSet[int]())\n}\n\nfunc BenchmarkClone100Unsafe(b *testing.B) {\n\tbenchClone(b, 100, NewThreadUnsafeSet[int]())\n}\n\nfunc benchContains(b *testing.B, n int, s Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tnums[n-1] = -1 // Definitely not in s\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Contains(nums...)\n\t}\n}\n\nfunc BenchmarkContains1Safe(b *testing.B) {\n\tbenchContains(b, 1, NewSet[int]())\n}\n\nfunc BenchmarkContains1Unsafe(b *testing.B) {\n\tbenchContains(b, 1, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkContains10Safe(b *testing.B) {\n\tbenchContains(b, 10, NewSet[int]())\n}\n\nfunc BenchmarkContains10Unsafe(b *testing.B) {\n\tbenchContains(b, 10, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkContains100Safe(b *testing.B) {\n\tbenchContains(b, 100, NewSet[int]())\n}\n\nfunc BenchmarkContains100Unsafe(b *testing.B) {\n\tbenchContains(b, 100, NewThreadUnsafeSet[int]())\n}\n\nfunc benchContainsOne(b *testing.B, n int, s Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.ContainsOne(-1)\n\t}\n}\n\nfunc BenchmarkContainsOne1Safe(b *testing.B) {\n\tbenchContainsOne(b, 1, NewSet[int]())\n}\n\nfunc BenchmarkContainsOne1Unsafe(b *testing.B) {\n\tbenchContainsOne(b, 1, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkContainsOne10Safe(b *testing.B) {\n\tbenchContainsOne(b, 10, NewSet[int]())\n}\n\nfunc BenchmarkContainsOne10Unsafe(b *testing.B) {\n\tbenchContainsOne(b, 10, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkContainsOne100Safe(b *testing.B) {\n\tbenchContainsOne(b, 100, NewSet[int]())\n}\n\nfunc BenchmarkContainsOne100Unsafe(b *testing.B) {\n\tbenchContainsOne(b, 100, NewThreadUnsafeSet[int]())\n}\n\n// In this scenario, Contains argument escapes to the heap, while ContainsOne does not.\nfunc benchContainsComparison(b *testing.B, n int, s Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tb.Run(\"Contains\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfor _, v := range nums {\n\t\t\t\ts.Contains(v) // 1 allocation, v is moved to the heap\n\t\t\t}\n\t\t}\n\t})\n\tb.Run(\"Contains slice\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfor i := range nums {\n\t\t\t\ts.Contains(nums[i : i+1]...) // no allocations, using heap-allocated slice\n\t\t\t}\n\t\t}\n\t})\n\tb.Run(\"ContainsOne\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfor _, v := range nums {\n\t\t\t\ts.ContainsOne(v) // no allocations, using stack-allocated v\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkContainsComparison1Unsafe(b *testing.B) {\n\tbenchContainsComparison(b, 1, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkContainsComparison1Safe(b *testing.B) {\n\tbenchContainsComparison(b, 1, NewSet[int]())\n}\n\nfunc BenchmarkContainsComparison10Unsafe(b *testing.B) {\n\tbenchContainsComparison(b, 10, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkContainsComparison10Safe(b *testing.B) {\n\tbenchContainsComparison(b, 10, NewSet[int]())\n}\n\nfunc BenchmarkContainsComparison100Unsafe(b *testing.B) {\n\tbenchContainsComparison(b, 100, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkContainsComparison100Safe(b *testing.B) {\n\tbenchContainsComparison(b, 100, NewSet[int]())\n}\n\nfunc benchEqual(b *testing.B, n int, s, t Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t\tt.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Equal(t)\n\t}\n}\n\nfunc BenchmarkEqual1Safe(b *testing.B) {\n\tbenchEqual(b, 1, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkEqual1Unsafe(b *testing.B) {\n\tbenchEqual(b, 1, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkEqual10Safe(b *testing.B) {\n\tbenchEqual(b, 10, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkEqual10Unsafe(b *testing.B) {\n\tbenchEqual(b, 10, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkEqual100Safe(b *testing.B) {\n\tbenchEqual(b, 100, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkEqual100Unsafe(b *testing.B) {\n\tbenchEqual(b, 100, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc benchDifference(b *testing.B, n int, s, t Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\tfor _, v := range nums[:n/2] {\n\t\tt.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Difference(t)\n\t}\n}\n\nfunc benchIsSubset(b *testing.B, n int, s, t Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t\tt.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.IsSubset(t)\n\t}\n}\n\nfunc BenchmarkIsSubset1Safe(b *testing.B) {\n\tbenchIsSubset(b, 1, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsSubset1Unsafe(b *testing.B) {\n\tbenchIsSubset(b, 1, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIsSubset10Safe(b *testing.B) {\n\tbenchIsSubset(b, 10, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsSubset10Unsafe(b *testing.B) {\n\tbenchIsSubset(b, 10, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIsSubset100Safe(b *testing.B) {\n\tbenchIsSubset(b, 100, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsSubset100Unsafe(b *testing.B) {\n\tbenchIsSubset(b, 100, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc benchIsSuperset(b *testing.B, n int, s, t Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t\tt.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.IsSuperset(t)\n\t}\n}\n\nfunc BenchmarkIsSuperset1Safe(b *testing.B) {\n\tbenchIsSuperset(b, 1, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsSuperset1Unsafe(b *testing.B) {\n\tbenchIsSuperset(b, 1, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIsSuperset10Safe(b *testing.B) {\n\tbenchIsSuperset(b, 10, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsSuperset10Unsafe(b *testing.B) {\n\tbenchIsSuperset(b, 10, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIsSuperset100Safe(b *testing.B) {\n\tbenchIsSuperset(b, 100, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsSuperset100Unsafe(b *testing.B) {\n\tbenchIsSuperset(b, 100, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc benchIsProperSubset(b *testing.B, n int, s, t Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t\tt.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.IsProperSubset(t)\n\t}\n}\n\nfunc BenchmarkIsProperSubset1Safe(b *testing.B) {\n\tbenchIsProperSubset(b, 1, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsProperSubset1Unsafe(b *testing.B) {\n\tbenchIsProperSubset(b, 1, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIsProperSubset10Safe(b *testing.B) {\n\tbenchIsProperSubset(b, 10, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsProperSubset10Unsafe(b *testing.B) {\n\tbenchIsProperSubset(b, 10, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIsProperSubset100Safe(b *testing.B) {\n\tbenchIsProperSubset(b, 100, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsProperSubset100Unsafe(b *testing.B) {\n\tbenchIsProperSubset(b, 100, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc benchIsProperSuperset(b *testing.B, n int, s, t Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t\tt.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.IsProperSuperset(t)\n\t}\n}\n\nfunc BenchmarkIsProperSuperset1Safe(b *testing.B) {\n\tbenchIsProperSuperset(b, 1, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsProperSuperset1Unsafe(b *testing.B) {\n\tbenchIsProperSuperset(b, 1, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIsProperSuperset10Safe(b *testing.B) {\n\tbenchIsProperSuperset(b, 10, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsProperSuperset10Unsafe(b *testing.B) {\n\tbenchIsProperSuperset(b, 10, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIsProperSuperset100Safe(b *testing.B) {\n\tbenchIsProperSuperset(b, 100, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIsProperSuperset100Unsafe(b *testing.B) {\n\tbenchIsProperSuperset(b, 100, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkDifference1Safe(b *testing.B) {\n\tbenchDifference(b, 1, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkDifference1Unsafe(b *testing.B) {\n\tbenchDifference(b, 1, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkDifference10Safe(b *testing.B) {\n\tbenchDifference(b, 10, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkDifference10Unsafe(b *testing.B) {\n\tbenchDifference(b, 10, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkDifference100Safe(b *testing.B) {\n\tbenchDifference(b, 100, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkDifference100Unsafe(b *testing.B) {\n\tbenchDifference(b, 100, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc benchIntersect(b *testing.B, n int, s, t Set[int]) {\n\tnums := nrand(int(float64(n) * float64(1.5)))\n\tfor _, v := range nums[:n] {\n\t\ts.Add(v)\n\t}\n\tfor _, v := range nums[n/2:] {\n\t\tt.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Intersect(t)\n\t}\n}\n\nfunc BenchmarkIntersect1Safe(b *testing.B) {\n\tbenchIntersect(b, 1, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIntersect1Unsafe(b *testing.B) {\n\tbenchIntersect(b, 1, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIntersect10Safe(b *testing.B) {\n\tbenchIntersect(b, 10, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIntersect10Unsafe(b *testing.B) {\n\tbenchIntersect(b, 10, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIntersect100Safe(b *testing.B) {\n\tbenchIntersect(b, 100, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkIntersect100Unsafe(b *testing.B) {\n\tbenchIntersect(b, 100, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc benchSymmetricDifference(b *testing.B, n int, s, t Set[int]) {\n\tnums := nrand(int(float64(n) * float64(1.5)))\n\tfor _, v := range nums[:n] {\n\t\ts.Add(v)\n\t}\n\tfor _, v := range nums[n/2:] {\n\t\tt.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.SymmetricDifference(t)\n\t}\n}\n\nfunc BenchmarkSymmetricDifference1Safe(b *testing.B) {\n\tbenchSymmetricDifference(b, 1, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkSymmetricDifference1Unsafe(b *testing.B) {\n\tbenchSymmetricDifference(b, 1, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkSymmetricDifference10Safe(b *testing.B) {\n\tbenchSymmetricDifference(b, 10, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkSymmetricDifference10Unsafe(b *testing.B) {\n\tbenchSymmetricDifference(b, 10, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkSymmetricDifference100Safe(b *testing.B) {\n\tbenchSymmetricDifference(b, 100, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkSymmetricDifference100Unsafe(b *testing.B) {\n\tbenchSymmetricDifference(b, 100, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc benchUnion(b *testing.B, n int, s, t Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums[:n/2] {\n\t\ts.Add(v)\n\t}\n\tfor _, v := range nums[n/2:] {\n\t\tt.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Union(t)\n\t}\n}\n\nfunc BenchmarkUnion1Safe(b *testing.B) {\n\tbenchUnion(b, 1, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkUnion1Unsafe(b *testing.B) {\n\tbenchUnion(b, 1, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkUnion10Safe(b *testing.B) {\n\tbenchUnion(b, 10, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkUnion10Unsafe(b *testing.B) {\n\tbenchUnion(b, 10, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkUnion100Safe(b *testing.B) {\n\tbenchUnion(b, 100, NewSet[int](), NewSet[int]())\n}\n\nfunc BenchmarkUnion100Unsafe(b *testing.B) {\n\tbenchUnion(b, 100, NewThreadUnsafeSet[int](), NewThreadUnsafeSet[int]())\n}\n\nfunc benchEach(b *testing.B, n int, s Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Each(func(elem int) bool {\n\t\t\treturn false\n\t\t})\n\t}\n}\n\nfunc BenchmarkEach1Safe(b *testing.B) {\n\tbenchEach(b, 1, NewSet[int]())\n}\n\nfunc BenchmarkEach1Unsafe(b *testing.B) {\n\tbenchEach(b, 1, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkEach10Safe(b *testing.B) {\n\tbenchEach(b, 10, NewSet[int]())\n}\n\nfunc BenchmarkEach10Unsafe(b *testing.B) {\n\tbenchEach(b, 10, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkEach100Safe(b *testing.B) {\n\tbenchEach(b, 100, NewSet[int]())\n}\n\nfunc BenchmarkEach100Unsafe(b *testing.B) {\n\tbenchEach(b, 100, NewThreadUnsafeSet[int]())\n}\n\nfunc benchIter(b *testing.B, n int, s Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tc := s.Iter()\n\t\tfor range c {\n\n\t\t}\n\t}\n}\n\nfunc BenchmarkIter1Safe(b *testing.B) {\n\tbenchIter(b, 1, NewSet[int]())\n}\n\nfunc BenchmarkIter1Unsafe(b *testing.B) {\n\tbenchIter(b, 1, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIter10Safe(b *testing.B) {\n\tbenchIter(b, 10, NewSet[int]())\n}\n\nfunc BenchmarkIter10Unsafe(b *testing.B) {\n\tbenchIter(b, 10, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIter100Safe(b *testing.B) {\n\tbenchIter(b, 100, NewSet[int]())\n}\n\nfunc BenchmarkIter100Unsafe(b *testing.B) {\n\tbenchIter(b, 100, NewThreadUnsafeSet[int]())\n}\n\nfunc benchIterator(b *testing.B, n int, s Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tc := s.Iterator().C\n\t\tfor range c {\n\n\t\t}\n\t}\n}\n\nfunc BenchmarkIterator1Safe(b *testing.B) {\n\tbenchIterator(b, 1, NewSet[int]())\n}\n\nfunc BenchmarkIterator1Unsafe(b *testing.B) {\n\tbenchIterator(b, 1, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIterator10Safe(b *testing.B) {\n\tbenchIterator(b, 10, NewSet[int]())\n}\n\nfunc BenchmarkIterator10Unsafe(b *testing.B) {\n\tbenchIterator(b, 10, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkIterator100Safe(b *testing.B) {\n\tbenchIterator(b, 100, NewSet[int]())\n}\n\nfunc BenchmarkIterator100Unsafe(b *testing.B) {\n\tbenchIterator(b, 100, NewThreadUnsafeSet[int]())\n}\n\nfunc benchString(b *testing.B, n int, s Set[int]) {\n\tnums := nrand(n)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = s.String()\n\t}\n}\n\nfunc BenchmarkString1Safe(b *testing.B) {\n\tbenchString(b, 1, NewSet[int]())\n}\n\nfunc BenchmarkString1Unsafe(b *testing.B) {\n\tbenchString(b, 1, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkString10Safe(b *testing.B) {\n\tbenchString(b, 10, NewSet[int]())\n}\n\nfunc BenchmarkString10Unsafe(b *testing.B) {\n\tbenchString(b, 10, NewThreadUnsafeSet[int]())\n}\n\nfunc BenchmarkString100Safe(b *testing.B) {\n\tbenchString(b, 100, NewSet[int]())\n}\n\nfunc BenchmarkString100Unsafe(b *testing.B) {\n\tbenchString(b, 100, NewThreadUnsafeSet[int]())\n}\n\nfunc benchToSlice(b *testing.B, s Set[int]) {\n\tnums := nrand(b.N)\n\tfor _, v := range nums {\n\t\ts.Add(v)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.ToSlice()\n\t}\n}\n\nfunc BenchmarkToSliceSafe(b *testing.B) {\n\tbenchToSlice(b, NewSet[int]())\n}\n\nfunc BenchmarkToSliceUnsafe(b *testing.B) {\n\tbenchToSlice(b, NewThreadUnsafeSet[int]())\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.048828125,
          "content": "module github.com/deckarep/golang-set/v2\n\ngo 1.18\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "iterator.go",
          "type": "blob",
          "size": 1.97265625,
          "content": "/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\n// Iterator defines an iterator over a Set, its C channel can be used to range over the Set's\n// elements.\ntype Iterator[T comparable] struct {\n\tC    <-chan T\n\tstop chan struct{}\n}\n\n// Stop stops the Iterator, no further elements will be received on C, C will be closed.\nfunc (i *Iterator[T]) Stop() {\n\t// Allows for Stop() to be called multiple times\n\t// (close() panics when called on already closed channel)\n\tdefer func() {\n\t\trecover()\n\t}()\n\n\tclose(i.stop)\n\n\t// Exhaust any remaining elements.\n\tfor range i.C {\n\t}\n}\n\n// newIterator returns a new Iterator instance together with its item and stop channels.\nfunc newIterator[T comparable]() (*Iterator[T], chan<- T, <-chan struct{}) {\n\titemChan := make(chan T)\n\tstopChan := make(chan struct{})\n\treturn &Iterator[T]{\n\t\tC:    itemChan,\n\t\tstop: stopChan,\n\t}, itemChan, stopChan\n}\n"
        },
        {
          "name": "iterator_example_test.go",
          "type": "blob",
          "size": 1.64453125,
          "content": "/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\nimport (\n\t\"testing\"\n)\n\ntype yourType struct {\n\tname string\n}\n\nfunc Test_ExampleIterator(t *testing.T) {\n\n\ts := NewSet(\n\t\t[]*yourType{\n\t\t\t{name: \"Alise\"},\n\t\t\t{name: \"Bob\"},\n\t\t\t{name: \"John\"},\n\t\t\t{name: \"Nick\"},\n\t\t}...,\n\t)\n\n\tvar found *yourType\n\tit := s.Iterator()\n\n\tfor elem := range it.C {\n\t\tif elem.name == \"John\" {\n\t\t\tfound = elem\n\t\t\tit.Stop()\n\t\t}\n\t}\n\n\tif found == nil || found.name != \"John\" {\n\t\tt.Fatalf(\"expected iterator to have found `John` record but got nil or something else\")\n\t}\n}\n"
        },
        {
          "name": "new_improved.jpeg",
          "type": "blob",
          "size": 118.1005859375,
          "content": null
        },
        {
          "name": "set.go",
          "type": "blob",
          "size": 8.3525390625,
          "content": "/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// Package mapset implements a simple and  set collection.\n// Items stored within it are unordered and unique. It supports\n// typical set operations: membership testing, intersection, union,\n// difference, symmetric difference and cloning.\n//\n// Package mapset provides two implementations of the Set\n// interface. The default implementation is safe for concurrent\n// access, but a non-thread-safe implementation is also provided for\n// programs that can benefit from the slight speed improvement and\n// that can enforce mutual exclusion through other means.\npackage mapset\n\n// Set is the primary interface provided by the mapset package.  It\n// represents an unordered set of data and a large number of\n// operations that can be applied to that set.\ntype Set[T comparable] interface {\n\t// Add adds an element to the set. Returns whether\n\t// the item was added.\n\tAdd(val T) bool\n\n\t// Append multiple elements to the set. Returns\n\t// the number of elements added.\n\tAppend(val ...T) int\n\n\t// Cardinality returns the number of elements in the set.\n\tCardinality() int\n\n\t// Clear removes all elements from the set, leaving\n\t// the empty set.\n\tClear()\n\n\t// Clone returns a clone of the set using the same\n\t// implementation, duplicating all keys.\n\tClone() Set[T]\n\n\t// Contains returns whether the given items\n\t// are all in the set.\n\tContains(val ...T) bool\n\n\t// ContainsOne returns whether the given item\n\t// is in the set.\n\t//\n\t// Contains may cause the argument to escape to the heap.\n\t// See: https://github.com/deckarep/golang-set/issues/118\n\tContainsOne(val T) bool\n\n\t// ContainsAny returns whether at least one of the\n\t// given items are in the set.\n\tContainsAny(val ...T) bool\n\n\t// ContainsAnyElement returns whether at least one of the\n\t// given element are in the set.\n\tContainsAnyElement(other Set[T]) bool\n\n\t// Difference returns the difference between this set\n\t// and other. The returned set will contain\n\t// all elements of this set that are not also\n\t// elements of other.\n\t//\n\t// Note that the argument to Difference\n\t// must be of the same type as the receiver\n\t// of the method. Otherwise, Difference will\n\t// panic.\n\tDifference(other Set[T]) Set[T]\n\n\t// Equal determines if two sets are equal to each\n\t// other. If they have the same cardinality\n\t// and contain the same elements, they are\n\t// considered equal. The order in which\n\t// the elements were added is irrelevant.\n\t//\n\t// Note that the argument to Equal must be\n\t// of the same type as the receiver of the\n\t// method. Otherwise, Equal will panic.\n\tEqual(other Set[T]) bool\n\n\t// Intersect returns a new set containing only the elements\n\t// that exist only in both sets.\n\t//\n\t// Note that the argument to Intersect\n\t// must be of the same type as the receiver\n\t// of the method. Otherwise, Intersect will\n\t// panic.\n\tIntersect(other Set[T]) Set[T]\n\n\t// IsEmpty determines if there are elements in the set.\n\tIsEmpty() bool\n\n\t// IsProperSubset determines if every element in this set is in\n\t// the other set but the two sets are not equal.\n\t//\n\t// Note that the argument to IsProperSubset\n\t// must be of the same type as the receiver\n\t// of the method. Otherwise, IsProperSubset\n\t// will panic.\n\tIsProperSubset(other Set[T]) bool\n\n\t// IsProperSuperset determines if every element in the other set\n\t// is in this set but the two sets are not\n\t// equal.\n\t//\n\t// Note that the argument to IsSuperset\n\t// must be of the same type as the receiver\n\t// of the method. Otherwise, IsSuperset will\n\t// panic.\n\tIsProperSuperset(other Set[T]) bool\n\n\t// IsSubset determines if every element in this set is in\n\t// the other set.\n\t//\n\t// Note that the argument to IsSubset\n\t// must be of the same type as the receiver\n\t// of the method. Otherwise, IsSubset will\n\t// panic.\n\tIsSubset(other Set[T]) bool\n\n\t// IsSuperset determines if every element in the other set\n\t// is in this set.\n\t//\n\t// Note that the argument to IsSuperset\n\t// must be of the same type as the receiver\n\t// of the method. Otherwise, IsSuperset will\n\t// panic.\n\tIsSuperset(other Set[T]) bool\n\n\t// Each iterates over elements and executes the passed func against each element.\n\t// If passed func returns true, stop iteration at the time.\n\tEach(func(T) bool)\n\n\t// Iter returns a channel of elements that you can\n\t// range over.\n\tIter() <-chan T\n\n\t// Iterator returns an Iterator object that you can\n\t// use to range over the set.\n\tIterator() *Iterator[T]\n\n\t// Remove removes a single element from the set.\n\tRemove(i T)\n\n\t// RemoveAll removes multiple elements from the set.\n\tRemoveAll(i ...T)\n\n\t// String provides a convenient string representation\n\t// of the current state of the set.\n\tString() string\n\n\t// SymmetricDifference returns a new set with all elements which are\n\t// in either this set or the other set but not in both.\n\t//\n\t// Note that the argument to SymmetricDifference\n\t// must be of the same type as the receiver\n\t// of the method. Otherwise, SymmetricDifference\n\t// will panic.\n\tSymmetricDifference(other Set[T]) Set[T]\n\n\t// Union returns a new set with all elements in both sets.\n\t//\n\t// Note that the argument to Union must be of the\n\t// same type as the receiver of the method.\n\t// Otherwise, Union will panic.\n\tUnion(other Set[T]) Set[T]\n\n\t// Pop removes and returns an arbitrary item from the set.\n\tPop() (T, bool)\n\n\t// ToSlice returns the members of the set as a slice.\n\tToSlice() []T\n\n\t// MarshalJSON will marshal the set into a JSON-based representation.\n\tMarshalJSON() ([]byte, error)\n\n\t// UnmarshalJSON will unmarshal a JSON-based byte slice into a full Set datastructure.\n\t// For this to work, set subtypes must implemented the Marshal/Unmarshal interface.\n\tUnmarshalJSON(b []byte) error\n}\n\n// NewSet creates and returns a new set with the given elements.\n// Operations on the resulting set are thread-safe.\nfunc NewSet[T comparable](vals ...T) Set[T] {\n\ts := newThreadSafeSetWithSize[T](len(vals))\n\tfor _, item := range vals {\n\t\ts.Add(item)\n\t}\n\treturn s\n}\n\n// NewSetWithSize creates and returns a reference to an empty set with a specified\n// capacity. Operations on the resulting set are thread-safe.\nfunc NewSetWithSize[T comparable](cardinality int) Set[T] {\n\ts := newThreadSafeSetWithSize[T](cardinality)\n\treturn s\n}\n\n// NewThreadUnsafeSet creates and returns a new set with the given elements.\n// Operations on the resulting set are not thread-safe.\nfunc NewThreadUnsafeSet[T comparable](vals ...T) Set[T] {\n\ts := newThreadUnsafeSetWithSize[T](len(vals))\n\tfor _, item := range vals {\n\t\ts.Add(item)\n\t}\n\treturn s\n}\n\n// NewThreadUnsafeSetWithSize creates and returns a reference to an empty set with\n// a specified capacity. Operations on the resulting set are not thread-safe.\nfunc NewThreadUnsafeSetWithSize[T comparable](cardinality int) Set[T] {\n\ts := newThreadUnsafeSetWithSize[T](cardinality)\n\treturn s\n}\n\n// NewSetFromMapKeys creates and returns a new set with the given keys of the map.\n// Operations on the resulting set are thread-safe.\nfunc NewSetFromMapKeys[T comparable, V any](val map[T]V) Set[T] {\n\ts := NewSetWithSize[T](len(val))\n\n\tfor k := range val {\n\t\ts.Add(k)\n\t}\n\n\treturn s\n}\n\n// NewThreadUnsafeSetFromMapKeys creates and returns a new set with the given keys of the map.\n// Operations on the resulting set are not thread-safe.\nfunc NewThreadUnsafeSetFromMapKeys[T comparable, V any](val map[T]V) Set[T] {\n\ts := NewThreadUnsafeSetWithSize[T](len(val))\n\n\tfor k := range val {\n\t\ts.Add(k)\n\t}\n\n\treturn s\n}\n"
        },
        {
          "name": "set_test.go",
          "type": "blob",
          "size": 27.6611328125,
          "content": "/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\nimport (\n\t\"testing\"\n)\n\nfunc makeSetInt(ints []int) Set[int] {\n\ts := NewSet[int]()\n\tfor _, i := range ints {\n\t\ts.Add(i)\n\t}\n\treturn s\n}\n\nfunc makeUnsafeSetInt(ints []int) Set[int] {\n\ts := NewThreadUnsafeSet[int]()\n\tfor _, i := range ints {\n\t\ts.Add(i)\n\t}\n\treturn s\n}\n\nfunc makeSetIntWithAppend(ints ...int) Set[int] {\n\ts := NewSet[int]()\n\ts.Append(ints...)\n\treturn s\n}\n\nfunc makeUnsafeSetIntWithAppend(ints ...int) Set[int] {\n\ts := NewThreadUnsafeSet[int]()\n\ts.Append(ints...)\n\treturn s\n}\n\nfunc assertEqual[T comparable](a, b Set[T], t *testing.T) {\n\tif !a.Equal(b) {\n\t\tt.Errorf(\"%v != %v\\n\", a, b)\n\t}\n}\n\nfunc Test_NewSet(t *testing.T) {\n\ta := NewSet[int]()\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"NewSet should start out as an empty set\")\n\t}\n\n\tassertEqual(NewSet([]int{}...), NewSet[int](), t)\n\tassertEqual(NewSet([]int{1}...), NewSet(1), t)\n\tassertEqual(NewSet([]int{1, 2}...), NewSet(1, 2), t)\n\tassertEqual(NewSet([]string{\"a\"}...), NewSet(\"a\"), t)\n\tassertEqual(NewSet([]string{\"a\", \"b\"}...), NewSet(\"a\", \"b\"), t)\n}\n\nfunc Test_NewUnsafeSet(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"NewSet should start out as an empty set\")\n\t}\n}\n\nfunc Test_AddSet(t *testing.T) {\n\ta := makeSetInt([]int{1, 2, 3})\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"AddSet does not have a size of 3 even though 3 items were added to a new set\")\n\t}\n}\n\nfunc Test_AddUnsafeSet(t *testing.T) {\n\ta := makeUnsafeSetInt([]int{1, 2, 3})\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"AddSet does not have a size of 3 even though 3 items were added to a new set\")\n\t}\n}\n\nfunc Test_AppendSet(t *testing.T) {\n\ta := makeSetIntWithAppend(1, 2, 3)\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"AppendSet does not have a size of 3 even though 3 items were added to a new set\")\n\t}\n}\n\nfunc Test_AppendUnsafeSet(t *testing.T) {\n\ta := makeUnsafeSetIntWithAppend(1, 2, 3)\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"AppendSet does not have a size of 3 even though 3 items were added to a new set\")\n\t}\n}\n\nfunc Test_AddSetNoDuplicate(t *testing.T) {\n\ta := makeSetInt([]int{7, 5, 3, 7})\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"AddSetNoDuplicate set should have 3 elements since 7 is a duplicate\")\n\t}\n\n\tif !(a.Contains(7) && a.Contains(5) && a.Contains(3)) {\n\t\tt.Error(\"AddSetNoDuplicate set should have a 7, 5, and 3 in it.\")\n\t}\n}\n\nfunc Test_AddUnsafeSetNoDuplicate(t *testing.T) {\n\ta := makeUnsafeSetInt([]int{7, 5, 3, 7})\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"AddSetNoDuplicate set should have 3 elements since 7 is a duplicate\")\n\t}\n\n\tif !(a.Contains(7) && a.Contains(5) && a.Contains(3)) {\n\t\tt.Error(\"AddSetNoDuplicate set should have a 7, 5, and 3 in it.\")\n\t}\n}\n\nfunc Test_AppendSetNoDuplicate(t *testing.T) {\n\ta := makeSetIntWithAppend(7, 5, 3, 7)\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"AppendSetNoDuplicate set should have 3 elements since 7 is a duplicate\")\n\t}\n\n\tif !(a.Contains(7) && a.Contains(5) && a.Contains(3)) {\n\t\tt.Error(\"AppendSetNoDuplicate set should have a 7, 5, and 3 in it.\")\n\t}\n}\n\nfunc Test_AppendUnsafeSetNoDuplicate(t *testing.T) {\n\ta := makeUnsafeSetIntWithAppend(7, 5, 3, 7)\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"AppendSetNoDuplicate set should have 3 elements since 7 is a duplicate\")\n\t}\n\n\tif !(a.Contains(7) && a.Contains(5) && a.Contains(3)) {\n\t\tt.Error(\"AppendSetNoDuplicate set should have a 7, 5, and 3 in it.\")\n\t}\n}\n\nfunc Test_RemoveSet(t *testing.T) {\n\ta := makeSetInt([]int{6, 3, 1})\n\n\ta.Remove(3)\n\n\tif a.Cardinality() != 2 {\n\t\tt.Error(\"RemoveSet should only have 2 items in the set\")\n\t}\n\n\tif !(a.Contains(6) && a.Contains(1)) {\n\t\tt.Error(\"RemoveSet should have only items 6 and 1 in the set\")\n\t}\n\n\ta.Remove(6)\n\ta.Remove(1)\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"RemoveSet should be an empty set after removing 6 and 1\")\n\t}\n}\n\nfunc Test_RemoveAllSet(t *testing.T) {\n\ta := makeSetInt([]int{6, 3, 1, 8, 9})\n\n\ta.RemoveAll(3, 1)\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"RemoveAll should only have 2 items in the set\")\n\t}\n\n\tif !a.Contains(6, 8, 9) {\n\t\tt.Error(\"RemoveAll should have only items (6,8,9) in the set\")\n\t}\n\n\ta.RemoveAll(6, 8, 9)\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"RemoveSet should be an empty set after removing 6 and 1\")\n\t}\n}\n\nfunc Test_RemoveUnsafeSet(t *testing.T) {\n\ta := makeUnsafeSetInt([]int{6, 3, 1})\n\n\ta.Remove(3)\n\n\tif a.Cardinality() != 2 {\n\t\tt.Error(\"RemoveSet should only have 2 items in the set\")\n\t}\n\n\tif !(a.Contains(6) && a.Contains(1)) {\n\t\tt.Error(\"RemoveSet should have only items 6 and 1 in the set\")\n\t}\n\n\ta.Remove(6)\n\ta.Remove(1)\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"RemoveSet should be an empty set after removing 6 and 1\")\n\t}\n}\n\nfunc Test_RemoveAllUnsafeSet(t *testing.T) {\n\ta := makeUnsafeSetInt([]int{6, 3, 1, 8, 9})\n\n\ta.RemoveAll(3, 1)\n\n\tif a.Cardinality() != 3 {\n\t\tt.Error(\"RemoveAll should only have 2 items in the set\")\n\t}\n\n\tif !a.Contains(6, 8, 9) {\n\t\tt.Error(\"RemoveAll should have only items (6,8,9) in the set\")\n\t}\n\n\ta.RemoveAll(6, 8, 9)\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"RemoveSet should be an empty set after removing 6 and 1\")\n\t}\n}\n\nfunc Test_ContainsSet(t *testing.T) {\n\ta := NewSet[int]()\n\n\ta.Add(71)\n\n\tif !a.Contains(71) {\n\t\tt.Error(\"ContainsSet should contain 71\")\n\t}\n\n\ta.Remove(71)\n\n\tif a.Contains(71) {\n\t\tt.Error(\"ContainsSet should not contain 71\")\n\t}\n\n\ta.Add(13)\n\ta.Add(7)\n\ta.Add(1)\n\n\tif !(a.Contains(13) && a.Contains(7) && a.Contains(1)) {\n\t\tt.Error(\"ContainsSet should contain 13, 7, 1\")\n\t}\n}\n\nfunc Test_ContainsUnsafeSet(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\n\ta.Add(71)\n\n\tif !a.Contains(71) {\n\t\tt.Error(\"ContainsSet should contain 71\")\n\t}\n\n\ta.Remove(71)\n\n\tif a.Contains(71) {\n\t\tt.Error(\"ContainsSet should not contain 71\")\n\t}\n\n\ta.Add(13)\n\ta.Add(7)\n\ta.Add(1)\n\n\tif !(a.Contains(13) && a.Contains(7) && a.Contains(1)) {\n\t\tt.Error(\"ContainsSet should contain 13, 7, 1\")\n\t}\n}\n\nfunc Test_ContainsMultipleSet(t *testing.T) {\n\ta := makeSetInt([]int{8, 6, 7, 5, 3, 0, 9})\n\n\tif !a.Contains(8, 6, 7, 5, 3, 0, 9) {\n\t\tt.Error(\"ContainsAll should contain Jenny's phone number\")\n\t}\n\n\tif a.Contains(8, 6, 11, 5, 3, 0, 9) {\n\t\tt.Error(\"ContainsAll should not have all of these numbers\")\n\t}\n}\n\nfunc Test_ContainsMultipleUnsafeSet(t *testing.T) {\n\ta := makeUnsafeSetInt([]int{8, 6, 7, 5, 3, 0, 9})\n\n\tif !a.Contains(8, 6, 7, 5, 3, 0, 9) {\n\t\tt.Error(\"ContainsAll should contain Jenny's phone number\")\n\t}\n\n\tif a.Contains(8, 6, 11, 5, 3, 0, 9) {\n\t\tt.Error(\"ContainsAll should not have all of these numbers\")\n\t}\n}\n\nfunc Test_ContainsOneSet(t *testing.T) {\n\ta := NewSet[int]()\n\n\ta.Add(71)\n\n\tif !a.ContainsOne(71) {\n\t\tt.Error(\"ContainsSet should contain 71\")\n\t}\n\n\ta.Remove(71)\n\n\tif a.ContainsOne(71) {\n\t\tt.Error(\"ContainsSet should not contain 71\")\n\t}\n\n\ta.Add(13)\n\ta.Add(7)\n\ta.Add(1)\n\n\tif !(a.ContainsOne(13) && a.ContainsOne(7) && a.ContainsOne(1)) {\n\t\tt.Error(\"ContainsSet should contain 13, 7, 1\")\n\t}\n}\n\nfunc Test_ContainsOneUnsafeSet(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\n\ta.Add(71)\n\n\tif !a.ContainsOne(71) {\n\t\tt.Error(\"ContainsSet should contain 71\")\n\t}\n\n\ta.Remove(71)\n\n\tif a.ContainsOne(71) {\n\t\tt.Error(\"ContainsSet should not contain 71\")\n\t}\n\n\ta.Add(13)\n\ta.Add(7)\n\ta.Add(1)\n\n\tif !(a.ContainsOne(13) && a.ContainsOne(7) && a.ContainsOne(1)) {\n\t\tt.Error(\"ContainsSet should contain 13, 7, 1\")\n\t}\n}\n\nfunc Test_ContainsAnySet(t *testing.T) {\n\ta := NewSet[int]()\n\n\ta.Add(71)\n\n\tif !a.ContainsAny(71) {\n\t\tt.Error(\"ContainsSet should contain 71\")\n\t}\n\n\tif !a.ContainsAny(71, 10) {\n\t\tt.Error(\"ContainsSet should contain 71 or 10\")\n\t}\n\n\ta.Remove(71)\n\n\tif a.ContainsAny(71) {\n\t\tt.Error(\"ContainsSet should not contain 71\")\n\t}\n\n\tif a.ContainsAny(71, 10) {\n\t\tt.Error(\"ContainsSet should not contain 71 or 10\")\n\t}\n\n\ta.Add(13)\n\ta.Add(7)\n\ta.Add(1)\n\n\tif !(a.ContainsAny(13, 17, 10)) {\n\t\tt.Error(\"ContainsSet should contain 13, 17, or 10\")\n\t}\n}\n\nfunc Test_ContainsAnyElement(t *testing.T) {\n\ta := NewSet[int]()\n\ta.Add(1)\n\ta.Add(3)\n\ta.Add(5)\n\n\tb := NewSet[int]()\n\ta.Add(2)\n\ta.Add(4)\n\ta.Add(6)\n\n\tif ret := a.ContainsAnyElement(b); ret {\n\t\tt.Errorf(\"set a not contain any element in set b\")\n\t}\n\n\ta.Add(10)\n\n\tif ret := a.ContainsAnyElement(b); ret {\n\t\tt.Errorf(\"set a not contain any element in set b\")\n\t}\n\n\tb.Add(10)\n\n\tif ret := a.ContainsAnyElement(b); !ret {\n\t\tt.Errorf(\"set a contain 10\")\n\t}\n}\nfunc Test_ClearSet(t *testing.T) {\n\ta := makeSetInt([]int{2, 5, 9, 10})\n\n\ta.Clear()\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"ClearSet should be an empty set\")\n\t}\n}\n\nfunc Test_ClearUnsafeSet(t *testing.T) {\n\ta := makeUnsafeSetInt([]int{2, 5, 9, 10})\n\n\ta.Clear()\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"ClearSet should be an empty set\")\n\t}\n}\n\nfunc Test_CardinalitySet(t *testing.T) {\n\ta := NewSet[int]()\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"set should be an empty set\")\n\t}\n\n\ta.Add(1)\n\n\tif a.Cardinality() != 1 {\n\t\tt.Error(\"set should have a size of 1\")\n\t}\n\n\ta.Remove(1)\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"set should be an empty set\")\n\t}\n\n\ta.Add(9)\n\n\tif a.Cardinality() != 1 {\n\t\tt.Error(\"set should have a size of 1\")\n\t}\n\n\ta.Clear()\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"set should have a size of 1\")\n\t}\n}\n\nfunc Test_CardinalityUnsafeSet(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"set should be an empty set\")\n\t}\n\n\ta.Add(1)\n\n\tif a.Cardinality() != 1 {\n\t\tt.Error(\"set should have a size of 1\")\n\t}\n\n\ta.Remove(1)\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"set should be an empty set\")\n\t}\n\n\ta.Add(9)\n\n\tif a.Cardinality() != 1 {\n\t\tt.Error(\"set should have a size of 1\")\n\t}\n\n\ta.Clear()\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"set should have a size of 1\")\n\t}\n}\n\nfunc Test_SetIsSubset(t *testing.T) {\n\ta := makeSetInt([]int{1, 2, 3, 5, 7})\n\n\tb := NewSet[int]()\n\tb.Add(3)\n\tb.Add(5)\n\tb.Add(7)\n\n\tif !b.IsSubset(a) {\n\t\tt.Error(\"set b should be a subset of set a\")\n\t}\n\n\tb.Add(72)\n\n\tif b.IsSubset(a) {\n\t\tt.Error(\"set b should not be a subset of set a because it contains 72 which is not in the set of a\")\n\t}\n}\n\nfunc Test_SetIsProperSubset(t *testing.T) {\n\ta := makeSetInt([]int{1, 2, 3, 5, 7})\n\tb := makeSetInt([]int{7, 5, 3, 2, 1})\n\n\tif !a.IsSubset(b) {\n\t\tt.Error(\"set a should be a subset of set b\")\n\t}\n\tif a.IsProperSubset(b) {\n\t\tt.Error(\"set a should not be a proper subset of set b (they're equal)\")\n\t}\n\n\tb.Add(72)\n\n\tif !a.IsSubset(b) {\n\t\tt.Error(\"set a should be a subset of set b\")\n\t}\n\tif !a.IsProperSubset(b) {\n\t\tt.Error(\"set a should be a proper subset of set b\")\n\t}\n}\n\nfunc Test_UnsafeSetIsSubset(t *testing.T) {\n\ta := makeUnsafeSetInt([]int{1, 2, 3, 5, 7})\n\n\tb := NewThreadUnsafeSet[int]()\n\tb.Add(3)\n\tb.Add(5)\n\tb.Add(7)\n\n\tif !b.IsSubset(a) {\n\t\tt.Error(\"set b should be a subset of set a\")\n\t}\n\n\tb.Add(72)\n\n\tif b.IsSubset(a) {\n\t\tt.Error(\"set b should not be a subset of set a because it contains 72 which is not in the set of a\")\n\t}\n}\n\nfunc Test_UnsafeSetIsProperSubset(t *testing.T) {\n\ta := makeUnsafeSetInt([]int{1, 2, 3, 5, 7})\n\tb := NewThreadUnsafeSet[int]()\n\tb.Add(7)\n\tb.Add(1)\n\tb.Add(5)\n\tb.Add(3)\n\tb.Add(2)\n\n\tif !a.IsSubset(b) {\n\t\tt.Error(\"set a should be a subset of set b\")\n\t}\n\tif a.IsProperSubset(b) {\n\t\tt.Error(\"set a should not be a proper subset of set b (they're equal)\")\n\t}\n\n\tb.Add(72)\n\n\tif !a.IsSubset(b) {\n\t\tt.Error(\"set a should be a subset of set b\")\n\t}\n\tif !a.IsProperSubset(b) {\n\t\tt.Error(\"set a should be a proper subset of set b because set b has 72\")\n\t}\n}\n\nfunc Test_SetIsSuperset(t *testing.T) {\n\ta := NewSet[int]()\n\ta.Add(9)\n\ta.Add(5)\n\ta.Add(2)\n\ta.Add(1)\n\ta.Add(11)\n\n\tb := NewSet[int]()\n\tb.Add(5)\n\tb.Add(2)\n\tb.Add(11)\n\n\tif !a.IsSuperset(b) {\n\t\tt.Error(\"set a should be a superset of set b\")\n\t}\n\n\tb.Add(42)\n\n\tif a.IsSuperset(b) {\n\t\tt.Error(\"set a should not be a superset of set b because set b has a 42\")\n\t}\n}\n\nfunc Test_SetIsProperSuperset(t *testing.T) {\n\ta := NewSet[int]()\n\ta.Add(5)\n\ta.Add(2)\n\ta.Add(11)\n\n\tb := NewSet[int]()\n\tb.Add(2)\n\tb.Add(5)\n\tb.Add(11)\n\n\tif !a.IsSuperset(b) {\n\t\tt.Error(\"set a should be a superset of set b\")\n\t}\n\tif a.IsProperSuperset(b) {\n\t\tt.Error(\"set a should not be a proper superset of set b (they're equal)\")\n\t}\n\n\ta.Add(9)\n\n\tif !a.IsSuperset(b) {\n\t\tt.Error(\"set a should be a superset of set b\")\n\t}\n\tif !a.IsProperSuperset(b) {\n\t\tt.Error(\"set a not be a proper superset of set b because set a has a 9\")\n\t}\n\n\tb.Add(42)\n\n\tif a.IsSuperset(b) {\n\t\tt.Error(\"set a should not be a superset of set b because set b has a 42\")\n\t}\n\tif a.IsProperSuperset(b) {\n\t\tt.Error(\"set a should not be a proper superset of set b because set b has a 42\")\n\t}\n}\n\nfunc Test_UnsafeSetIsSuperset(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\ta.Add(9)\n\ta.Add(5)\n\ta.Add(2)\n\ta.Add(1)\n\ta.Add(11)\n\n\tb := NewThreadUnsafeSet[int]()\n\tb.Add(5)\n\tb.Add(2)\n\tb.Add(11)\n\n\tif !a.IsSuperset(b) {\n\t\tt.Error(\"set a should be a superset of set b\")\n\t}\n\n\tb.Add(42)\n\n\tif a.IsSuperset(b) {\n\t\tt.Error(\"set a should not be a superset of set b because set a has a 42\")\n\t}\n}\n\nfunc Test_UnsafeSetIsProperSuperset(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\ta.Add(5)\n\ta.Add(2)\n\ta.Add(11)\n\n\tb := NewThreadUnsafeSet[int]()\n\tb.Add(2)\n\tb.Add(5)\n\tb.Add(11)\n\n\tif !a.IsSuperset(b) {\n\t\tt.Error(\"set a should be a superset of set b\")\n\t}\n\tif a.IsProperSuperset(b) {\n\t\tt.Error(\"set a should not be a proper superset of set b (they're equal)\")\n\t}\n\n\ta.Add(9)\n\n\tif !a.IsSuperset(b) {\n\t\tt.Error(\"set a should be a superset of set b\")\n\t}\n\tif !a.IsProperSuperset(b) {\n\t\tt.Error(\"set a not be a proper superset of set b because set a has a 9\")\n\t}\n\n\tb.Add(42)\n\n\tif a.IsSuperset(b) {\n\t\tt.Error(\"set a should not be a superset of set b because set b has a 42\")\n\t}\n\tif a.IsProperSuperset(b) {\n\t\tt.Error(\"set a should not be a proper superset of set b because set b has a 42\")\n\t}\n}\n\nfunc Test_SetUnion(t *testing.T) {\n\ta := NewSet[int]()\n\n\tb := NewSet[int]()\n\tb.Add(1)\n\tb.Add(2)\n\tb.Add(3)\n\tb.Add(4)\n\tb.Add(5)\n\n\tc := a.Union(b)\n\n\tif c.Cardinality() != 5 {\n\t\tt.Error(\"set c is unioned with an empty set and therefore should have 5 elements in it\")\n\t}\n\n\td := NewSet[int]()\n\td.Add(10)\n\td.Add(14)\n\td.Add(0)\n\n\te := c.Union(d)\n\tif e.Cardinality() != 8 {\n\t\tt.Error(\"set e should have 8 elements in it after being unioned with set c to d\")\n\t}\n\n\tf := NewSet[int]()\n\tf.Add(14)\n\tf.Add(3)\n\n\tg := f.Union(e)\n\tif g.Cardinality() != 8 {\n\t\tt.Error(\"set g should still have 8 elements in it after being unioned with set f that has duplicates\")\n\t}\n}\n\nfunc Test_UnsafeSetUnion(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\n\tb := NewThreadUnsafeSet[int]()\n\tb.Add(1)\n\tb.Add(2)\n\tb.Add(3)\n\tb.Add(4)\n\tb.Add(5)\n\n\tc := a.Union(b)\n\n\tif c.Cardinality() != 5 {\n\t\tt.Error(\"set c is unioned with an empty set and therefore should have 5 elements in it\")\n\t}\n\n\td := NewThreadUnsafeSet[int]()\n\td.Add(10)\n\td.Add(14)\n\td.Add(0)\n\n\te := c.Union(d)\n\tif e.Cardinality() != 8 {\n\t\tt.Error(\"set e should have 8 elements in it after being unioned with set c to d\")\n\t}\n\n\tf := NewThreadUnsafeSet[int]()\n\tf.Add(14)\n\tf.Add(3)\n\n\tg := f.Union(e)\n\tif g.Cardinality() != 8 {\n\t\tt.Error(\"set g should still have 8 elements in it after being unioned with set f that has duplicates\")\n\t}\n}\n\nfunc Test_SetIntersect(t *testing.T) {\n\ta := NewSet[int]()\n\ta.Add(1)\n\ta.Add(3)\n\ta.Add(5)\n\n\tb := NewSet[int]()\n\ta.Add(2)\n\ta.Add(4)\n\ta.Add(6)\n\n\tc := a.Intersect(b)\n\n\tif c.Cardinality() != 0 {\n\t\tt.Error(\"set c should be the empty set because there is no common items to intersect\")\n\t}\n\n\ta.Add(10)\n\tb.Add(10)\n\n\td := a.Intersect(b)\n\n\tif !(d.Cardinality() == 1 && d.Contains(10)) {\n\t\tt.Error(\"set d should have a size of 1 and contain the item 10\")\n\t}\n}\n\nfunc Test_UnsafeSetIntersect(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\ta.Add(1)\n\ta.Add(3)\n\ta.Add(5)\n\n\tb := NewThreadUnsafeSet[int]()\n\ta.Add(2)\n\ta.Add(4)\n\ta.Add(6)\n\n\tc := a.Intersect(b)\n\n\tif c.Cardinality() != 0 {\n\t\tt.Error(\"set c should be the empty set because there is no common items to intersect\")\n\t}\n\n\ta.Add(10)\n\tb.Add(10)\n\n\td := a.Intersect(b)\n\n\tif !(d.Cardinality() == 1 && d.Contains(10)) {\n\t\tt.Error(\"set d should have a size of 1 and contain the item 10\")\n\t}\n}\n\nfunc Test_SetDifference(t *testing.T) {\n\ta := NewSet[int]()\n\ta.Add(1)\n\ta.Add(2)\n\ta.Add(3)\n\n\tb := NewSet[int]()\n\tb.Add(1)\n\tb.Add(3)\n\tb.Add(4)\n\tb.Add(5)\n\tb.Add(6)\n\tb.Add(99)\n\n\tc := a.Difference(b)\n\n\tif !(c.Cardinality() == 1 && c.Contains(2)) {\n\t\tt.Error(\"the difference of set a to b is the set of 1 item: 2\")\n\t}\n}\n\nfunc Test_UnsafeSetDifference(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\ta.Add(1)\n\ta.Add(2)\n\ta.Add(3)\n\n\tb := NewThreadUnsafeSet[int]()\n\tb.Add(1)\n\tb.Add(3)\n\tb.Add(4)\n\tb.Add(5)\n\tb.Add(6)\n\tb.Add(99)\n\n\tc := a.Difference(b)\n\n\tif !(c.Cardinality() == 1 && c.Contains(2)) {\n\t\tt.Error(\"the difference of set a to b is the set of 1 item: 2\")\n\t}\n}\n\nfunc Test_SetSymmetricDifference(t *testing.T) {\n\ta := NewSet[int]()\n\ta.Add(1)\n\ta.Add(2)\n\ta.Add(3)\n\ta.Add(45)\n\n\tb := NewSet[int]()\n\tb.Add(1)\n\tb.Add(3)\n\tb.Add(4)\n\tb.Add(5)\n\tb.Add(6)\n\tb.Add(99)\n\n\tc := a.SymmetricDifference(b)\n\n\tif !(c.Cardinality() == 6 && c.Contains(2) && c.Contains(45) && c.Contains(4) && c.Contains(5) && c.Contains(6) && c.Contains(99)) {\n\t\tt.Error(\"the symmetric difference of set a to b is the set of 6 items: 2, 45, 4, 5, 6, 99\")\n\t}\n}\n\nfunc Test_UnsafeSetSymmetricDifference(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\ta.Add(1)\n\ta.Add(2)\n\ta.Add(3)\n\ta.Add(45)\n\n\tb := NewThreadUnsafeSet[int]()\n\tb.Add(1)\n\tb.Add(3)\n\tb.Add(4)\n\tb.Add(5)\n\tb.Add(6)\n\tb.Add(99)\n\n\tc := a.SymmetricDifference(b)\n\n\tif !(c.Cardinality() == 6 && c.Contains(2) && c.Contains(45) && c.Contains(4) && c.Contains(5) && c.Contains(6) && c.Contains(99)) {\n\t\tt.Error(\"the symmetric difference of set a to b is the set of 6 items: 2, 45, 4, 5, 6, 99\")\n\t}\n}\n\nfunc Test_SetEqual(t *testing.T) {\n\ta := NewSet[int]()\n\tb := NewSet[int]()\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"Both a and b are empty sets, and should be equal\")\n\t}\n\n\ta.Add(10)\n\n\tif a.Equal(b) {\n\t\tt.Error(\"a should not be equal to b because b is empty and a has item 1 in it\")\n\t}\n\n\tb.Add(10)\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"a is now equal again to b because both have the item 10 in them\")\n\t}\n\n\tb.Add(8)\n\tb.Add(3)\n\tb.Add(47)\n\n\tif a.Equal(b) {\n\t\tt.Error(\"b has 3 more elements in it so therefore should not be equal to a\")\n\t}\n\n\ta.Add(8)\n\ta.Add(3)\n\ta.Add(47)\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"a and b should be equal with the same number of elements\")\n\t}\n}\n\nfunc Test_UnsafeSetEqual(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\tb := NewThreadUnsafeSet[int]()\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"Both a and b are empty sets, and should be equal\")\n\t}\n\n\ta.Add(10)\n\n\tif a.Equal(b) {\n\t\tt.Error(\"a should not be equal to b because b is empty and a has item 1 in it\")\n\t}\n\n\tb.Add(10)\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"a is now equal again to b because both have the item 10 in them\")\n\t}\n\n\tb.Add(8)\n\tb.Add(3)\n\tb.Add(47)\n\n\tif a.Equal(b) {\n\t\tt.Error(\"b has 3 more elements in it so therefore should not be equal to a\")\n\t}\n\n\ta.Add(8)\n\ta.Add(3)\n\ta.Add(47)\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"a and b should be equal with the same number of elements\")\n\t}\n}\n\nfunc Test_SetClone(t *testing.T) {\n\ta := NewSet[int]()\n\ta.Add(1)\n\ta.Add(2)\n\n\tb := a.Clone()\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"Clones should be equal\")\n\t}\n\n\ta.Add(3)\n\tif a.Equal(b) {\n\t\tt.Error(\"a contains one more element, they should not be equal\")\n\t}\n\n\tc := a.Clone()\n\tc.Remove(1)\n\n\tif a.Equal(c) {\n\t\tt.Error(\"C contains one element less, they should not be equal\")\n\t}\n}\n\nfunc Test_UnsafeSetClone(t *testing.T) {\n\ta := NewThreadUnsafeSet[int]()\n\ta.Add(1)\n\ta.Add(2)\n\n\tb := a.Clone()\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"Clones should be equal\")\n\t}\n\n\ta.Add(3)\n\tif a.Equal(b) {\n\t\tt.Error(\"a contains one more element, they should not be equal\")\n\t}\n\n\tc := a.Clone()\n\tc.Remove(1)\n\n\tif a.Equal(c) {\n\t\tt.Error(\"C contains one element less, they should not be equal\")\n\t}\n}\n\nfunc Test_Each(t *testing.T) {\n\ta := NewSet[string]()\n\n\ta.Add(\"Z\")\n\ta.Add(\"Y\")\n\ta.Add(\"X\")\n\ta.Add(\"W\")\n\n\tb := NewSet[string]()\n\ta.Each(func(elem string) bool {\n\t\tb.Add(elem)\n\t\treturn false\n\t})\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"The sets are not equal after iterating (Each) through the first set\")\n\t}\n\n\tvar count int\n\ta.Each(func(elem string) bool {\n\t\tif count == 2 {\n\t\t\treturn true\n\t\t}\n\t\tcount++\n\t\treturn false\n\t})\n\tif count != 2 {\n\t\tt.Error(\"Iteration should stop on the way\")\n\t}\n}\n\nfunc Test_Iter(t *testing.T) {\n\ta := NewSet[string]()\n\n\ta.Add(\"Z\")\n\ta.Add(\"Y\")\n\ta.Add(\"X\")\n\ta.Add(\"W\")\n\n\tb := NewSet[string]()\n\tfor val := range a.Iter() {\n\t\tb.Add(val)\n\t}\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"The sets are not equal after iterating (Iter) through the first set\")\n\t}\n}\n\nfunc Test_UnsafeIter(t *testing.T) {\n\ta := NewThreadUnsafeSet[string]()\n\n\ta.Add(\"Z\")\n\ta.Add(\"Y\")\n\ta.Add(\"X\")\n\ta.Add(\"W\")\n\n\tb := NewThreadUnsafeSet[string]()\n\tfor val := range a.Iter() {\n\t\tb.Add(val)\n\t}\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"The sets are not equal after iterating (Iter) through the first set\")\n\t}\n}\n\nfunc Test_Iterator(t *testing.T) {\n\ta := NewSet[string]()\n\n\ta.Add(\"Z\")\n\ta.Add(\"Y\")\n\ta.Add(\"X\")\n\ta.Add(\"W\")\n\n\tb := NewSet[string]()\n\tfor val := range a.Iterator().C {\n\t\tb.Add(val)\n\t}\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"The sets are not equal after iterating (Iterator) through the first set\")\n\t}\n}\n\nfunc Test_UnsafeIterator(t *testing.T) {\n\ta := NewThreadUnsafeSet[string]()\n\n\ta.Add(\"Z\")\n\ta.Add(\"Y\")\n\ta.Add(\"X\")\n\ta.Add(\"W\")\n\n\tb := NewThreadUnsafeSet[string]()\n\tfor val := range a.Iterator().C {\n\t\tb.Add(val)\n\t}\n\n\tif !a.Equal(b) {\n\t\tt.Error(\"The sets are not equal after iterating (Iterator) through the first set\")\n\t}\n}\n\nfunc Test_IteratorStop(t *testing.T) {\n\ta := NewSet[string]()\n\n\ta.Add(\"Z\")\n\ta.Add(\"Y\")\n\ta.Add(\"X\")\n\ta.Add(\"W\")\n\n\tit := a.Iterator()\n\tit.Stop()\n\tfor range it.C {\n\t\tt.Error(\"The iterating (Iterator) did not stop after Stop() has been called\")\n\t}\n}\n\nfunc Test_PopSafe(t *testing.T) {\n\ta := NewSet[string]()\n\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\ta.Add(\"c\")\n\ta.Add(\"d\")\n\n\taPop := func() (v string) {\n\t\tv, _ = a.Pop()\n\t\treturn\n\t}\n\n\tcaptureSet := NewSet[string]()\n\tcaptureSet.Add(aPop())\n\tcaptureSet.Add(aPop())\n\tcaptureSet.Add(aPop())\n\tcaptureSet.Add(aPop())\n\tfinalNil := aPop()\n\n\tif captureSet.Cardinality() != 4 {\n\t\tt.Error(\"unexpected captureSet cardinality; should be 4\")\n\t}\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"unepxected a cardinality; should be zero\")\n\t}\n\n\tif !captureSet.Contains(\"c\", \"a\", \"d\", \"b\") {\n\t\tt.Error(\"unexpected result set; should be a,b,c,d (any order is fine\")\n\t}\n\n\tif finalNil != \"\" {\n\t\tt.Error(\"when original set is empty, further pops should result in nil\")\n\t}\n}\n\nfunc Test_PopUnsafe(t *testing.T) {\n\ta := NewThreadUnsafeSet[string]()\n\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\ta.Add(\"c\")\n\ta.Add(\"d\")\n\n\taPop := func() (v string) {\n\t\tv, _ = a.Pop()\n\t\treturn\n\t}\n\n\tcaptureSet := NewThreadUnsafeSet[string]()\n\tcaptureSet.Add(aPop())\n\tcaptureSet.Add(aPop())\n\tcaptureSet.Add(aPop())\n\tcaptureSet.Add(aPop())\n\tfinalNil := aPop()\n\n\tif captureSet.Cardinality() != 4 {\n\t\tt.Error(\"unexpected captureSet cardinality; should be 4\")\n\t}\n\n\tif a.Cardinality() != 0 {\n\t\tt.Error(\"unepxected a cardinality; should be zero\")\n\t}\n\n\tif !captureSet.Contains(\"c\", \"a\", \"d\", \"b\") {\n\t\tt.Error(\"unexpected result set; should be a,b,c,d (any order is fine\")\n\t}\n\n\tif finalNil != \"\" {\n\t\tt.Error(\"when original set is empty, further pops should result in nil\")\n\t}\n}\n\nfunc Test_EmptySetProperties(t *testing.T) {\n\tempty := NewSet[string]()\n\n\ta := NewSet[string]()\n\ta.Add(\"1\")\n\ta.Add(\"foo\")\n\ta.Add(\"bar\")\n\n\tb := NewSet[string]()\n\tb.Add(\"one\")\n\tb.Add(\"two\")\n\tb.Add(\"3\")\n\tb.Add(\"4\")\n\n\tif !empty.IsSubset(a) || !empty.IsSubset(b) {\n\t\tt.Error(\"The empty set is supposed to be a subset of all sets\")\n\t}\n\n\tif !a.IsSuperset(empty) || !b.IsSuperset(empty) {\n\t\tt.Error(\"All sets are supposed to be a superset of the empty set\")\n\t}\n\n\tif !empty.IsSubset(empty) || !empty.IsSuperset(empty) {\n\t\tt.Error(\"The empty set is supposed to be a subset and a superset of itself\")\n\t}\n\n\tc := a.Union(empty)\n\tif !c.Equal(a) {\n\t\tt.Error(\"The union of any set with the empty set is supposed to be equal to itself\")\n\t}\n\n\tc = a.Intersect(empty)\n\tif !c.Equal(empty) {\n\t\tt.Error(\"The intersection of any set with the empty set is supposed to be the empty set\")\n\t}\n\n\tif empty.Cardinality() != 0 {\n\t\tt.Error(\"Cardinality of the empty set is supposed to be zero\")\n\t}\n}\n\nfunc Test_ToSliceUnthreadsafe(t *testing.T) {\n\ts := makeUnsafeSetInt([]int{1, 2, 3})\n\tsetAsSlice := s.ToSlice()\n\tif len(setAsSlice) != s.Cardinality() {\n\t\tt.Errorf(\"Set length is incorrect: %v\", len(setAsSlice))\n\t}\n\n\tfor _, i := range setAsSlice {\n\t\tif !s.Contains(i) {\n\t\t\tt.Errorf(\"Set is missing element: %v\", i)\n\t\t}\n\t}\n}\n\nfunc Test_NewSetFromMapKey_Ints(t *testing.T) {\n\tm := map[int]int{\n\t\t5: 5,\n\t\t2: 3,\n\t}\n\n\ts := NewSetFromMapKeys(m)\n\n\tif len(m) != s.Cardinality() {\n\t\tt.Errorf(\"Length of Set is not the same as the map. Expected: %d. Actual: %d\", len(m), s.Cardinality())\n\t}\n\n\tfor k := range m {\n\t\tif !s.Contains(k) {\n\t\t\tt.Errorf(\"Element %d not found in map: %v\", k, m)\n\t\t}\n\t}\n}\n\nfunc Test_NewSetFromMapKey_Strings(t *testing.T) {\n\tm := map[int]int{\n\t\t5: 5,\n\t\t2: 3,\n\t}\n\n\ts := NewSetFromMapKeys(m)\n\n\tif len(m) != s.Cardinality() {\n\t\tt.Errorf(\"Length of Set is not the same as the map. Expected: %d. Actual: %d\", len(m), s.Cardinality())\n\t}\n\n\tfor k := range m {\n\t\tif !s.Contains(k) {\n\t\t\tt.Errorf(\"Element %q not found in map: %v\", k, m)\n\t\t}\n\t}\n}\n\nfunc Test_NewThreadUnsafeSetFromMapKey_Ints(t *testing.T) {\n\tm := map[int]int{\n\t\t5: 5,\n\t\t2: 3,\n\t}\n\n\ts := NewThreadUnsafeSetFromMapKeys(m)\n\n\tif len(m) != s.Cardinality() {\n\t\tt.Errorf(\"Length of Set is not the same as the map. Expected: %d. Actual: %d\", len(m), s.Cardinality())\n\t}\n\n\tfor k := range m {\n\t\tif !s.Contains(k) {\n\t\t\tt.Errorf(\"Element %d not found in map: %v\", k, m)\n\t\t}\n\t}\n}\n\nfunc Test_NewThreadUnsafeSetFromMapKey_Strings(t *testing.T) {\n\tm := map[int]int{\n\t\t5: 5,\n\t\t2: 3,\n\t}\n\n\ts := NewThreadUnsafeSetFromMapKeys(m)\n\n\tif len(m) != s.Cardinality() {\n\t\tt.Errorf(\"Length of Set is not the same as the map. Expected: %d. Actual: %d\", len(m), s.Cardinality())\n\t}\n\n\tfor k := range m {\n\t\tif !s.Contains(k) {\n\t\t\tt.Errorf(\"Element %q not found in map: %v\", k, m)\n\t\t}\n\t}\n}\n\nfunc Test_Example(t *testing.T) {\n\t/*\n\t   requiredClasses := NewSet()\n\t   requiredClasses.Add(\"Cooking\")\n\t   requiredClasses.Add(\"English\")\n\t   requiredClasses.Add(\"Math\")\n\t   requiredClasses.Add(\"Biology\")\n\n\t   scienceSlice := []interface{}{\"Biology\", \"Chemistry\"}\n\t   scienceClasses := NewSet(scienceSlice)\n\n\t   electiveClasses := NewSet()\n\t   electiveClasses.Add(\"Welding\")\n\t   electiveClasses.Add(\"Music\")\n\t   electiveClasses.Add(\"Automotive\")\n\n\t   bonusClasses := NewSet()\n\t   bonusClasses.Add(\"Go Programming\")\n\t   bonusClasses.Add(\"Python Programming\")\n\n\t   //Show me all the available classes I can take\n\t   allClasses := requiredClasses.Union(scienceClasses).Union(electiveClasses).Union(bonusClasses)\n\t   fmt.Println(allClasses) //Set{English, Chemistry, Automotive, Cooking, Math, Biology, Welding, Music, Go Programming}\n\n\t   //Is cooking considered a science class?\n\t   fmt.Println(scienceClasses.Contains(\"Cooking\")) //false\n\n\t   //Show me all classes that are not science classes, since I hate science.\n\t   fmt.Println(allClasses.Difference(scienceClasses)) //Set{English, Automotive, Cooking, Math, Welding, Music, Go Programming}\n\n\t   //Which science classes are also required classes?\n\t   fmt.Println(scienceClasses.Intersect(requiredClasses)) //Set{Biology}\n\n\t   //How many bonus classes do you offer?\n\t   fmt.Println(bonusClasses.Cardinality()) //2\n\n\t   //Do you have the following classes? Welding, Automotive and English?\n\t   fmt.Println(allClasses.ContainsAll(\"Welding\", \"Automotive\", \"English\"))\n\t*/\n}\n"
        },
        {
          "name": "sorted.go",
          "type": "blob",
          "size": 1.474609375,
          "content": "//go:build go1.21\n// +build go1.21\n\n/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2023 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\nimport (\n\t\"cmp\"\n\t\"slices\"\n)\n\n// Sorted returns a sorted slice of a set of any ordered type in ascending order.\n// When sorting floating-point numbers, NaNs are ordered before other values.\nfunc Sorted[E cmp.Ordered](set Set[E]) []E {\n\ts := set.ToSlice()\n\tslices.Sort(s)\n\treturn s\n}\n"
        },
        {
          "name": "sorted_test.go",
          "type": "blob",
          "size": 1.9697265625,
          "content": "//go:build go1.21\n// +build go1.21\n\n/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_Sorted(t *testing.T) {\n\ttest := func(t *testing.T, ctor func(vals ...string) Set[string]) {\n\t\tset := ctor(\"apple\", \"banana\", \"pear\")\n\t\tsorted := Sorted(set)\n\n\t\tif len(sorted) != set.Cardinality() {\n\t\t\tt.Errorf(\"Length of slice is not the same as the set. Expected: %d. Actual: %d\", set.Cardinality(), len(sorted))\n\t\t}\n\n\t\tif sorted[0] != \"apple\" {\n\t\t\tt.Errorf(\"Element 0 was not equal to apple: %s\", sorted[0])\n\t\t}\n\t\tif sorted[1] != \"banana\" {\n\t\t\tt.Errorf(\"Element 1 was not equal to banana: %s\", sorted[1])\n\t\t}\n\t\tif sorted[2] != \"pear\" {\n\t\t\tt.Errorf(\"Element 2 was not equal to pear: %s\", sorted[2])\n\t\t}\n\t}\n\n\tt.Run(\"Safe\", func(t *testing.T) {\n\t\ttest(t, NewSet[string])\n\t})\n\tt.Run(\"Unsafe\", func(t *testing.T) {\n\t\ttest(t, NewThreadUnsafeSet[string])\n\t})\n}\n"
        },
        {
          "name": "threadsafe.go",
          "type": "blob",
          "size": 5.9208984375,
          "content": "/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\nimport \"sync\"\n\ntype threadSafeSet[T comparable] struct {\n\tsync.RWMutex\n\tuss *threadUnsafeSet[T]\n}\n\nfunc newThreadSafeSet[T comparable]() *threadSafeSet[T] {\n\treturn &threadSafeSet[T]{\n\t\tuss: newThreadUnsafeSet[T](),\n\t}\n}\n\nfunc newThreadSafeSetWithSize[T comparable](cardinality int) *threadSafeSet[T] {\n\treturn &threadSafeSet[T]{\n\t\tuss: newThreadUnsafeSetWithSize[T](cardinality),\n\t}\n}\n\nfunc (t *threadSafeSet[T]) Add(v T) bool {\n\tt.Lock()\n\tret := t.uss.Add(v)\n\tt.Unlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) Append(v ...T) int {\n\tt.Lock()\n\tret := t.uss.Append(v...)\n\tt.Unlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) Contains(v ...T) bool {\n\tt.RLock()\n\tret := t.uss.Contains(v...)\n\tt.RUnlock()\n\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) ContainsOne(v T) bool {\n\tt.RLock()\n\tret := t.uss.ContainsOne(v)\n\tt.RUnlock()\n\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) ContainsAny(v ...T) bool {\n\tt.RLock()\n\tret := t.uss.ContainsAny(v...)\n\tt.RUnlock()\n\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) ContainsAnyElement(other Set[T]) bool {\n\to := other.(*threadSafeSet[T])\n\n\tt.RLock()\n\to.RLock()\n\n\tret := t.uss.ContainsAnyElement(o.uss)\n\n\tt.RUnlock()\n\to.RUnlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) IsEmpty() bool {\n\treturn t.Cardinality() == 0\n}\n\nfunc (t *threadSafeSet[T]) IsSubset(other Set[T]) bool {\n\to := other.(*threadSafeSet[T])\n\n\tt.RLock()\n\to.RLock()\n\n\tret := t.uss.IsSubset(o.uss)\n\tt.RUnlock()\n\to.RUnlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) IsProperSubset(other Set[T]) bool {\n\to := other.(*threadSafeSet[T])\n\n\tt.RLock()\n\tdefer t.RUnlock()\n\to.RLock()\n\tdefer o.RUnlock()\n\n\treturn t.uss.IsProperSubset(o.uss)\n}\n\nfunc (t *threadSafeSet[T]) IsSuperset(other Set[T]) bool {\n\treturn other.IsSubset(t)\n}\n\nfunc (t *threadSafeSet[T]) IsProperSuperset(other Set[T]) bool {\n\treturn other.IsProperSubset(t)\n}\n\nfunc (t *threadSafeSet[T]) Union(other Set[T]) Set[T] {\n\to := other.(*threadSafeSet[T])\n\n\tt.RLock()\n\to.RLock()\n\n\tunsafeUnion := t.uss.Union(o.uss).(*threadUnsafeSet[T])\n\tret := &threadSafeSet[T]{uss: unsafeUnion}\n\tt.RUnlock()\n\to.RUnlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) Intersect(other Set[T]) Set[T] {\n\to := other.(*threadSafeSet[T])\n\n\tt.RLock()\n\to.RLock()\n\n\tunsafeIntersection := t.uss.Intersect(o.uss).(*threadUnsafeSet[T])\n\tret := &threadSafeSet[T]{uss: unsafeIntersection}\n\tt.RUnlock()\n\to.RUnlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) Difference(other Set[T]) Set[T] {\n\to := other.(*threadSafeSet[T])\n\n\tt.RLock()\n\to.RLock()\n\n\tunsafeDifference := t.uss.Difference(o.uss).(*threadUnsafeSet[T])\n\tret := &threadSafeSet[T]{uss: unsafeDifference}\n\tt.RUnlock()\n\to.RUnlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) SymmetricDifference(other Set[T]) Set[T] {\n\to := other.(*threadSafeSet[T])\n\n\tt.RLock()\n\to.RLock()\n\n\tunsafeDifference := t.uss.SymmetricDifference(o.uss).(*threadUnsafeSet[T])\n\tret := &threadSafeSet[T]{uss: unsafeDifference}\n\tt.RUnlock()\n\to.RUnlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) Clear() {\n\tt.Lock()\n\tt.uss.Clear()\n\tt.Unlock()\n}\n\nfunc (t *threadSafeSet[T]) Remove(v T) {\n\tt.Lock()\n\tdelete(*t.uss, v)\n\tt.Unlock()\n}\n\nfunc (t *threadSafeSet[T]) RemoveAll(i ...T) {\n\tt.Lock()\n\tt.uss.RemoveAll(i...)\n\tt.Unlock()\n}\n\nfunc (t *threadSafeSet[T]) Cardinality() int {\n\tt.RLock()\n\tdefer t.RUnlock()\n\treturn len(*t.uss)\n}\n\nfunc (t *threadSafeSet[T]) Each(cb func(T) bool) {\n\tt.RLock()\n\tfor elem := range *t.uss {\n\t\tif cb(elem) {\n\t\t\tbreak\n\t\t}\n\t}\n\tt.RUnlock()\n}\n\nfunc (t *threadSafeSet[T]) Iter() <-chan T {\n\tch := make(chan T)\n\tgo func() {\n\t\tt.RLock()\n\n\t\tfor elem := range *t.uss {\n\t\t\tch <- elem\n\t\t}\n\t\tclose(ch)\n\t\tt.RUnlock()\n\t}()\n\n\treturn ch\n}\n\nfunc (t *threadSafeSet[T]) Iterator() *Iterator[T] {\n\titerator, ch, stopCh := newIterator[T]()\n\n\tgo func() {\n\t\tt.RLock()\n\tL:\n\t\tfor elem := range *t.uss {\n\t\t\tselect {\n\t\t\tcase <-stopCh:\n\t\t\t\tbreak L\n\t\t\tcase ch <- elem:\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t\tt.RUnlock()\n\t}()\n\n\treturn iterator\n}\n\nfunc (t *threadSafeSet[T]) Equal(other Set[T]) bool {\n\to := other.(*threadSafeSet[T])\n\n\tt.RLock()\n\to.RLock()\n\n\tret := t.uss.Equal(o.uss)\n\tt.RUnlock()\n\to.RUnlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) Clone() Set[T] {\n\tt.RLock()\n\n\tunsafeClone := t.uss.Clone().(*threadUnsafeSet[T])\n\tret := &threadSafeSet[T]{uss: unsafeClone}\n\tt.RUnlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) String() string {\n\tt.RLock()\n\tret := t.uss.String()\n\tt.RUnlock()\n\treturn ret\n}\n\nfunc (t *threadSafeSet[T]) Pop() (T, bool) {\n\tt.Lock()\n\tdefer t.Unlock()\n\treturn t.uss.Pop()\n}\n\nfunc (t *threadSafeSet[T]) ToSlice() []T {\n\tkeys := make([]T, 0, t.Cardinality())\n\tt.RLock()\n\tfor elem := range *t.uss {\n\t\tkeys = append(keys, elem)\n\t}\n\tt.RUnlock()\n\treturn keys\n}\n\nfunc (t *threadSafeSet[T]) MarshalJSON() ([]byte, error) {\n\tt.RLock()\n\tb, err := t.uss.MarshalJSON()\n\tt.RUnlock()\n\n\treturn b, err\n}\n\nfunc (t *threadSafeSet[T]) UnmarshalJSON(p []byte) error {\n\tt.RLock()\n\terr := t.uss.UnmarshalJSON(p)\n\tt.RUnlock()\n\n\treturn err\n}\n"
        },
        {
          "name": "threadsafe_test.go",
          "type": "blob",
          "size": 10.46875,
          "content": "/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\nimport (\n\t\"encoding/json\"\n\t\"math/rand\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n)\n\nconst N = 1000\n\nfunc Test_AddConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\n\tvar wg sync.WaitGroup\n\twg.Add(len(ints))\n\tfor i := 0; i < len(ints); i++ {\n\t\tgo func(i int) {\n\t\t\ts.Add(i)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfor _, i := range ints {\n\t\tif !s.Contains(i) {\n\t\t\tt.Errorf(\"Set is missing element: %v\", i)\n\t\t}\n\t}\n}\n\nfunc Test_AppendConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\n\tn := len(ints) >> 1\n\tvar wg sync.WaitGroup\n\twg.Add(n)\n\tfor i := 0; i < n; i++ {\n\t\tgo func(i int) {\n\t\t\ts.Append(i, N-i-1)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tfor _, i := range ints {\n\t\tif !s.Contains(i) {\n\t\t\tt.Errorf(\"Set is missing element: %v\", i)\n\t\t}\n\t}\n}\n\nfunc Test_CardinalityConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\telems := s.Cardinality()\n\t\tfor i := 0; i < N; i++ {\n\t\t\tnewElems := s.Cardinality()\n\t\t\tif newElems < elems {\n\t\t\t\tt.Errorf(\"Cardinality shrunk from %v to %v\", elems, newElems)\n\t\t\t}\n\t\t}\n\t\twg.Done()\n\t}()\n\n\tfor i := 0; i < N; i++ {\n\t\ts.Add(rand.Int())\n\t}\n\twg.Wait()\n}\n\nfunc Test_ClearConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\n\tvar wg sync.WaitGroup\n\twg.Add(len(ints))\n\tfor i := 0; i < len(ints); i++ {\n\t\tgo func() {\n\t\t\ts.Clear()\n\t\t\twg.Done()\n\t\t}()\n\t\tgo func(i int) {\n\t\t\ts.Add(i)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n}\n\nfunc Test_CloneConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(len(ints))\n\tfor i := range ints {\n\t\tgo func(i int) {\n\t\t\ts.Remove(i)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\ts.Clone()\n\twg.Wait()\n}\n\nfunc Test_ContainsConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\tintegers := make([]int, 0)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tintegers = append(integers, v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.Contains(integers...)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_ContainsOneConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor _, v := range ints {\n\t\tnumber := v\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.ContainsOne(number)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_ContainsAnyConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\tintegers := make([]int, 0)\n\tfor _, v := range ints {\n\t\tif v%N == 0 {\n\t\t\ts.Add(v)\n\t\t}\n\t\tintegers = append(integers, v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.ContainsAny(integers...)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_ContainsAnyElementConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts, ss := NewSet[int](), NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tss.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.ContainsAnyElement(ss)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_DifferenceConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts, ss := NewSet[int](), NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tss.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.Difference(ss)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_EqualConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts, ss := NewSet[int](), NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tss.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.Equal(ss)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_IntersectConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts, ss := NewSet[int](), NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tss.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.Intersect(ss)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_IsEmptyConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tfor i := 0; i < N; i++ {\n\t\t\tsize := s.Cardinality()\n\t\t\tif s.IsEmpty() && size > 0 {\n\t\t\t\tt.Errorf(\"Is Empty should be return false\")\n\t\t\t}\n\t\t}\n\t\twg.Done()\n\t}()\n\n\tfor i := 0; i < N; i++ {\n\t\ts.Add(rand.Int())\n\t}\n\twg.Wait()\n}\n\nfunc Test_IsSubsetConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts, ss := NewSet[int](), NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tss.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.IsSubset(ss)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_IsProperSubsetConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts, ss := NewSet[int](), NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tss.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.IsProperSubset(ss)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_IsSupersetConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts, ss := NewSet[int](), NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tss.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.IsSuperset(ss)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_IsProperSupersetConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts, ss := NewSet[int](), NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tss.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.IsProperSuperset(ss)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_EachConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\tconcurrent := 10\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t}\n\n\tvar count int64\n\twg := new(sync.WaitGroup)\n\twg.Add(concurrent)\n\tfor n := 0; n < concurrent; n++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\ts.Each(func(elem int) bool {\n\t\t\t\tatomic.AddInt64(&count, 1)\n\t\t\t\treturn false\n\t\t\t})\n\t\t}()\n\t}\n\twg.Wait()\n\n\tif count != int64(N*concurrent) {\n\t\tt.Errorf(\"%v != %v\", count, int64(N*concurrent))\n\t}\n}\n\nfunc Test_IterConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t}\n\n\tcs := make([]<-chan int, 0)\n\tfor range ints {\n\t\tcs = append(cs, s.Iter())\n\t}\n\n\tc := make(chan interface{})\n\tgo func() {\n\t\tfor n := 0; n < len(ints)*N; {\n\t\t\tfor _, d := range cs {\n\t\t\t\tselect {\n\t\t\t\tcase <-d:\n\t\t\t\t\tn++\n\t\t\t\t\tc <- nil\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(c)\n\t}()\n\n\tfor range c {\n\t}\n}\n\nfunc Test_RemoveConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(len(ints))\n\tfor _, v := range ints {\n\t\tgo func(i int) {\n\t\t\ts.Remove(i)\n\t\t\twg.Done()\n\t\t}(v)\n\t}\n\twg.Wait()\n\n\tif s.Cardinality() != 0 {\n\t\tt.Errorf(\"Expected cardinality 0; got %v\", s.Cardinality())\n\t}\n}\n\nfunc Test_StringConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(len(ints))\n\tfor range ints {\n\t\tgo func() {\n\t\t\t_ = s.String()\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_SymmetricDifferenceConcurrent(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts, ss := NewSet[int](), NewSet[int]()\n\tints := rand.Perm(N)\n\tfor _, v := range ints {\n\t\ts.Add(v)\n\t\tss.Add(v)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor range ints {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\ts.SymmetricDifference(ss)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_ToSlice(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\ts := NewSet[int]()\n\tints := rand.Perm(N)\n\n\tvar wg sync.WaitGroup\n\twg.Add(len(ints))\n\tfor i := 0; i < len(ints); i++ {\n\t\tgo func(i int) {\n\t\t\ts.Add(i)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tsetAsSlice := s.ToSlice()\n\tif len(setAsSlice) != s.Cardinality() {\n\t\tt.Errorf(\"Set length is incorrect: %v\", len(setAsSlice))\n\t}\n\n\tfor _, i := range setAsSlice {\n\t\tif !s.Contains(i) {\n\t\t\tt.Errorf(\"Set is missing element: %v\", i)\n\t\t}\n\t}\n}\n\n// Test_ToSliceDeadlock - fixes issue: https://github.com/deckarep/golang-set/issues/36\n// This code reveals the deadlock however it doesn't happen consistently.\nfunc Test_ToSliceDeadlock(t *testing.T) {\n\truntime.GOMAXPROCS(2)\n\n\tvar wg sync.WaitGroup\n\tset := NewSet[int]()\n\tworkers := 10\n\twg.Add(workers)\n\tfor i := 1; i <= workers; i++ {\n\t\tgo func() {\n\t\t\tfor j := 0; j < 1000; j++ {\n\t\t\t\tset.Add(1)\n\t\t\t\tset.ToSlice()\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc Test_UnmarshalJSON(t *testing.T) {\n\ts := []byte(`[\"test\", \"1\", \"2\", \"3\"]`) //,[\"4,5,6\"]]`)\n\texpected := NewSet(\n\t\t[]string{\n\t\t\tstring(json.Number(\"1\")),\n\t\t\tstring(json.Number(\"2\")),\n\t\t\tstring(json.Number(\"3\")),\n\t\t\t\"test\",\n\t\t}...,\n\t)\n\n\tactual := NewSet[string]()\n\terr := json.Unmarshal(s, actual)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\n\tif !expected.Equal(actual) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expected.Difference(actual))\n\t}\n}\n\nfunc Test_MarshalJSON(t *testing.T) {\n\texpected := NewSet(\n\t\t[]string{\n\t\t\tstring(json.Number(\"1\")),\n\t\t\t\"test\",\n\t\t}...,\n\t)\n\n\tb, err := json.Marshal(\n\t\tNewSet(\n\t\t\t[]string{\n\t\t\t\t\"1\",\n\t\t\t\t\"test\",\n\t\t\t}...,\n\t\t),\n\t)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\n\tactual := NewSet[string]()\n\terr = json.Unmarshal(b, actual)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\n\tif !expected.Equal(actual) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expected.Difference(actual))\n\t}\n}\n"
        },
        {
          "name": "threadunsafe.go",
          "type": "blob",
          "size": 7.4345703125,
          "content": "/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype threadUnsafeSet[T comparable] map[T]struct{}\n\n// Assert concrete type:threadUnsafeSet adheres to Set interface.\nvar _ Set[string] = (*threadUnsafeSet[string])(nil)\n\nfunc newThreadUnsafeSet[T comparable]() *threadUnsafeSet[T] {\n\tt := make(threadUnsafeSet[T])\n\treturn &t\n}\n\nfunc newThreadUnsafeSetWithSize[T comparable](cardinality int) *threadUnsafeSet[T] {\n\tt := make(threadUnsafeSet[T], cardinality)\n\treturn &t\n}\n\nfunc (s threadUnsafeSet[T]) Add(v T) bool {\n\tprevLen := len(s)\n\ts[v] = struct{}{}\n\treturn prevLen != len(s)\n}\n\nfunc (s *threadUnsafeSet[T]) Append(v ...T) int {\n\tprevLen := len(*s)\n\tfor _, val := range v {\n\t\t(*s)[val] = struct{}{}\n\t}\n\treturn len(*s) - prevLen\n}\n\n// private version of Add which doesn't return a value\nfunc (s *threadUnsafeSet[T]) add(v T) {\n\t(*s)[v] = struct{}{}\n}\n\nfunc (s *threadUnsafeSet[T]) Cardinality() int {\n\treturn len(*s)\n}\n\nfunc (s *threadUnsafeSet[T]) Clear() {\n\t// Constructions like this are optimised by compiler, and replaced by\n\t// mapclear() function, defined in\n\t// https://github.com/golang/go/blob/29bbca5c2c1ad41b2a9747890d183b6dd3a4ace4/src/runtime/map.go#L993)\n\tfor key := range *s {\n\t\tdelete(*s, key)\n\t}\n}\n\nfunc (s *threadUnsafeSet[T]) Clone() Set[T] {\n\tclonedSet := newThreadUnsafeSetWithSize[T](s.Cardinality())\n\tfor elem := range *s {\n\t\tclonedSet.add(elem)\n\t}\n\treturn clonedSet\n}\n\nfunc (s *threadUnsafeSet[T]) Contains(v ...T) bool {\n\tfor _, val := range v {\n\t\tif _, ok := (*s)[val]; !ok {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (s *threadUnsafeSet[T]) ContainsOne(v T) bool {\n\t_, ok := (*s)[v]\n\treturn ok\n}\n\nfunc (s *threadUnsafeSet[T]) ContainsAny(v ...T) bool {\n\tfor _, val := range v {\n\t\tif _, ok := (*s)[val]; ok {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *threadUnsafeSet[T]) ContainsAnyElement(other Set[T]) bool {\n\to := other.(*threadUnsafeSet[T])\n\n\t// loop over smaller set\n\tif s.Cardinality() < other.Cardinality() {\n\t\tfor elem := range *s {\n\t\t\tif o.contains(elem) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor elem := range *o {\n\t\t\tif s.contains(elem) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// private version of Contains for a single element v\nfunc (s *threadUnsafeSet[T]) contains(v T) (ok bool) {\n\t_, ok = (*s)[v]\n\treturn ok\n}\n\nfunc (s *threadUnsafeSet[T]) Difference(other Set[T]) Set[T] {\n\to := other.(*threadUnsafeSet[T])\n\n\tdiff := newThreadUnsafeSet[T]()\n\tfor elem := range *s {\n\t\tif !o.contains(elem) {\n\t\t\tdiff.add(elem)\n\t\t}\n\t}\n\treturn diff\n}\n\nfunc (s *threadUnsafeSet[T]) Each(cb func(T) bool) {\n\tfor elem := range *s {\n\t\tif cb(elem) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (s *threadUnsafeSet[T]) Equal(other Set[T]) bool {\n\to := other.(*threadUnsafeSet[T])\n\n\tif s.Cardinality() != other.Cardinality() {\n\t\treturn false\n\t}\n\tfor elem := range *s {\n\t\tif !o.contains(elem) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (s *threadUnsafeSet[T]) Intersect(other Set[T]) Set[T] {\n\to := other.(*threadUnsafeSet[T])\n\n\tintersection := newThreadUnsafeSet[T]()\n\t// loop over smaller set\n\tif s.Cardinality() < other.Cardinality() {\n\t\tfor elem := range *s {\n\t\t\tif o.contains(elem) {\n\t\t\t\tintersection.add(elem)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor elem := range *o {\n\t\t\tif s.contains(elem) {\n\t\t\t\tintersection.add(elem)\n\t\t\t}\n\t\t}\n\t}\n\treturn intersection\n}\n\nfunc (s *threadUnsafeSet[T]) IsEmpty() bool {\n\treturn s.Cardinality() == 0\n}\n\nfunc (s *threadUnsafeSet[T]) IsProperSubset(other Set[T]) bool {\n\treturn s.Cardinality() < other.Cardinality() && s.IsSubset(other)\n}\n\nfunc (s *threadUnsafeSet[T]) IsProperSuperset(other Set[T]) bool {\n\treturn s.Cardinality() > other.Cardinality() && s.IsSuperset(other)\n}\n\nfunc (s *threadUnsafeSet[T]) IsSubset(other Set[T]) bool {\n\to := other.(*threadUnsafeSet[T])\n\tif s.Cardinality() > other.Cardinality() {\n\t\treturn false\n\t}\n\tfor elem := range *s {\n\t\tif !o.contains(elem) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (s *threadUnsafeSet[T]) IsSuperset(other Set[T]) bool {\n\treturn other.IsSubset(s)\n}\n\nfunc (s *threadUnsafeSet[T]) Iter() <-chan T {\n\tch := make(chan T)\n\tgo func() {\n\t\tfor elem := range *s {\n\t\t\tch <- elem\n\t\t}\n\t\tclose(ch)\n\t}()\n\n\treturn ch\n}\n\nfunc (s *threadUnsafeSet[T]) Iterator() *Iterator[T] {\n\titerator, ch, stopCh := newIterator[T]()\n\n\tgo func() {\n\tL:\n\t\tfor elem := range *s {\n\t\t\tselect {\n\t\t\tcase <-stopCh:\n\t\t\t\tbreak L\n\t\t\tcase ch <- elem:\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\n\treturn iterator\n}\n\n// Pop returns a popped item in case set is not empty, or nil-value of T\n// if set is already empty\nfunc (s *threadUnsafeSet[T]) Pop() (v T, ok bool) {\n\tfor item := range *s {\n\t\tdelete(*s, item)\n\t\treturn item, true\n\t}\n\treturn v, false\n}\n\nfunc (s threadUnsafeSet[T]) Remove(v T) {\n\tdelete(s, v)\n}\n\nfunc (s threadUnsafeSet[T]) RemoveAll(i ...T) {\n\tfor _, elem := range i {\n\t\tdelete(s, elem)\n\t}\n}\n\nfunc (s threadUnsafeSet[T]) String() string {\n\titems := make([]string, 0, len(s))\n\n\tfor elem := range s {\n\t\titems = append(items, fmt.Sprintf(\"%v\", elem))\n\t}\n\treturn fmt.Sprintf(\"Set{%s}\", strings.Join(items, \", \"))\n}\n\nfunc (s *threadUnsafeSet[T]) SymmetricDifference(other Set[T]) Set[T] {\n\to := other.(*threadUnsafeSet[T])\n\n\tsd := newThreadUnsafeSet[T]()\n\tfor elem := range *s {\n\t\tif !o.contains(elem) {\n\t\t\tsd.add(elem)\n\t\t}\n\t}\n\tfor elem := range *o {\n\t\tif !s.contains(elem) {\n\t\t\tsd.add(elem)\n\t\t}\n\t}\n\treturn sd\n}\n\nfunc (s threadUnsafeSet[T]) ToSlice() []T {\n\tkeys := make([]T, 0, s.Cardinality())\n\tfor elem := range s {\n\t\tkeys = append(keys, elem)\n\t}\n\n\treturn keys\n}\n\nfunc (s threadUnsafeSet[T]) Union(other Set[T]) Set[T] {\n\to := other.(*threadUnsafeSet[T])\n\n\tn := s.Cardinality()\n\tif o.Cardinality() > n {\n\t\tn = o.Cardinality()\n\t}\n\tunionedSet := make(threadUnsafeSet[T], n)\n\n\tfor elem := range s {\n\t\tunionedSet.add(elem)\n\t}\n\tfor elem := range *o {\n\t\tunionedSet.add(elem)\n\t}\n\treturn &unionedSet\n}\n\n// MarshalJSON creates a JSON array from the set, it marshals all elements\nfunc (s threadUnsafeSet[T]) MarshalJSON() ([]byte, error) {\n\titems := make([]string, 0, s.Cardinality())\n\n\tfor elem := range s {\n\t\tb, err := json.Marshal(elem)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\titems = append(items, string(b))\n\t}\n\n\treturn []byte(fmt.Sprintf(\"[%s]\", strings.Join(items, \",\"))), nil\n}\n\n// UnmarshalJSON recreates a set from a JSON array, it only decodes\n// primitive types. Numbers are decoded as json.Number.\nfunc (s *threadUnsafeSet[T]) UnmarshalJSON(b []byte) error {\n\tvar i []T\n\terr := json.Unmarshal(b, &i)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.Append(i...)\n\n\treturn nil\n}\n"
        },
        {
          "name": "threadunsafe_test.go",
          "type": "blob",
          "size": 4.7412109375,
          "content": "/*\nOpen Source Initiative OSI - The MIT License (MIT):Licensing\n\nThe MIT License (MIT)\nCopyright (c) 2013 - 2022 Ralph Caraveo (deckarep@gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npackage mapset\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestThreadUnsafeSet_MarshalJSON(t *testing.T) {\n\texpected := NewThreadUnsafeSet[int64](1, 2, 3)\n\tactual := newThreadUnsafeSet[int64]()\n\n\t// test Marshal from Set method\n\tb, err := expected.MarshalJSON()\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\n\terr = json.Unmarshal(b, actual)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\n\tif !expected.Equal(actual) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expected.Difference(actual))\n\t}\n\n\t// test Marshal from json package\n\tb, err = json.Marshal(expected)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\n\terr = json.Unmarshal(b, actual)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\n\tif !expected.Equal(actual) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expected.Difference(actual))\n\t}\n}\n\nfunc TestThreadUnsafeSet_UnmarshalJSON(t *testing.T) {\n\texpected := NewThreadUnsafeSet[int64](1, 2, 3)\n\tactual := NewThreadUnsafeSet[int64]()\n\n\t// test Unmarshal from Set method\n\terr := actual.UnmarshalJSON([]byte(`[1, 2, 3]`))\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\tif !expected.Equal(actual) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expected.Difference(actual))\n\t}\n\n\t// test Unmarshal from json package\n\tactual = NewThreadUnsafeSet[int64]()\n\terr = json.Unmarshal([]byte(`[1, 2, 3]`), actual)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\tif !expected.Equal(actual) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expected.Difference(actual))\n\t}\n}\n\nfunc TestThreadUnsafeSet_MarshalJSON_Struct(t *testing.T) {\n\texpected := &testStruct{\"test\", NewThreadUnsafeSet(\"a\")}\n\n\tb, err := json.Marshal(&testStruct{\"test\", NewThreadUnsafeSet(\"a\")})\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\n\tactual := &testStruct{}\n\terr = json.Unmarshal(b, actual)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\n\tif !expected.Set.Equal(actual.Set) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expected.Set.Difference(actual.Set))\n\t}\n}\nfunc TestThreadUnsafeSet_UnmarshalJSON_Struct(t *testing.T) {\n\texpected := &testStruct{\"test\", NewThreadUnsafeSet(\"a\", \"b\", \"c\")}\n\tactual := &testStruct{}\n\n\terr := json.Unmarshal([]byte(`{\"other\":\"test\", \"set\":[\"a\", \"b\", \"c\"]}`), actual)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\tif !expected.Set.Equal(actual.Set) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expected.Set.Difference(actual.Set))\n\t}\n\n\texpectedComplex := NewThreadUnsafeSet(struct{ Val string }{Val: \"a\"}, struct{ Val string }{Val: \"b\"})\n\tactualComplex := NewThreadUnsafeSet[struct{ Val string }]()\n\n\terr = actualComplex.UnmarshalJSON([]byte(`[{\"Val\": \"a\"}, {\"Val\": \"b\"}]`))\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\tif !expectedComplex.Equal(actualComplex) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expectedComplex.Difference(actualComplex))\n\t}\n\n\tactualComplex = NewThreadUnsafeSet[struct{ Val string }]()\n\terr = json.Unmarshal([]byte(`[{\"Val\": \"a\"}, {\"Val\": \"b\"}]`), actualComplex)\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil: %v\", err)\n\t}\n\tif !expectedComplex.Equal(actualComplex) {\n\t\tt.Errorf(\"Expected no difference, got: %v\", expectedComplex.Difference(actualComplex))\n\t}\n}\n\n// this serves as an example of how to correctly unmarshal a struct with a Set property\ntype testStruct struct {\n\tOther string\n\tSet   Set[string]\n}\n\nfunc (t *testStruct) UnmarshalJSON(b []byte) error {\n\traw := struct {\n\t\tOther string\n\t\tSet   []string\n\t}{}\n\n\terr := json.Unmarshal(b, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tt.Other = raw.Other\n\tt.Set = NewThreadUnsafeSet(raw.Set...)\n\n\treturn nil\n}\n"
        }
      ]
    }
  ]
}