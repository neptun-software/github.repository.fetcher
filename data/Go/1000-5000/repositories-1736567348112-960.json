{
  "metadata": {
    "timestamp": 1736567348112,
    "page": 960,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fsouza/go-dockerclient",
      "stars": 2190,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0185546875,
          "content": "* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0517578125,
          "content": "# temporary symlink for testing\ntesting/data/symlink\n"
        },
        {
          "name": ".golangci.yaml",
          "type": "blob",
          "size": 0.087890625,
          "content": "run:\n  deadline: 5m\n\nlinters:\n  disable-all: true\n  enable:\n    - gofumpt\n    - goimports\n"
        },
        {
          "name": "DOCKER-LICENSE",
          "type": "blob",
          "size": 0.267578125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\nYou can find the Docker license at the following link:\nhttps://raw.githubusercontent.com/docker/docker/HEAD/LICENSE\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.26953125,
          "content": "Copyright (c) go-dockerclient authors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.55859375,
          "content": "ifeq \"$(strip $(shell go env GOARCH))\" \"amd64\"\nRACE_FLAG := -race\nendif\n\n.PHONY: test\ntest: pretest gotest\n\n.PHONY: golangci-lint\ngolangci-lint:\n\tgo install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\tgolangci-lint run\n\n.PHONY: staticcheck\nstaticcheck:\n\tgo install honnef.co/go/tools/cmd/staticcheck@master\n\tstaticcheck ./...\n\n.PHONY: lint\nlint: golangci-lint staticcheck\n\n.PHONY: pretest\npretest: lint\n\n.PHONY: gotest\ngotest:\n\tgo test $(RACE_FLAG) -vet all ./...\n\n.PHONY: integration\nintegration:\n\tgo test -tags docker_integration -run TestIntegration -v\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.1533203125,
          "content": "# go-dockerclient\n\n[![Build Status](https://github.com/fsouza/go-dockerclient/workflows/Build/badge.svg)](https://github.com/fsouza/go-dockerclient/actions?query=branch:main+workflow:Build)\n[![GoDoc](https://img.shields.io/badge/api-Godoc-blue.svg?style=flat-square)](https://pkg.go.dev/github.com/fsouza/go-dockerclient)\n\nThis package presents a client for the Docker remote API. It also provides\nsupport for the extensions in the [Swarm API](https://docs.docker.com/swarm/swarm-api/).\n\nThis package also provides support for docker's network API, which is a simple\npassthrough to the libnetwork remote API.\n\nFor more details, check the [remote API\ndocumentation](https://docs.docker.com/engine/api/latest/).\n\n## Difference between go-dockerclient and the official SDK\n\nLink for the official SDK: https://docs.docker.com/develop/sdk/\n\ngo-dockerclient was created before Docker had an official Go SDK and is\nstill maintained and active because it's still used out there. New features in\nthe Docker API do not get automatically implemented here: it's based on demand,\nif someone wants it, they can file an issue or a PR and the feature may get\nimplemented/merged.\n\nFor new projects, using the official SDK is probably more appropriate as\ngo-dockerclient lags behind the official SDK.\n\n## Example\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\tdocker \"github.com/fsouza/go-dockerclient\"\n)\n\nfunc main() {\n\tclient, err := docker.NewClientFromEnv()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\timgs, err := client.ListImages(docker.ListImagesOptions{All: false})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfor _, img := range imgs {\n\t\tfmt.Println(\"ID: \", img.ID)\n\t\tfmt.Println(\"RepoTags: \", img.RepoTags)\n\t\tfmt.Println(\"Created: \", img.Created)\n\t\tfmt.Println(\"Size: \", img.Size)\n\t\tfmt.Println(\"VirtualSize: \", img.VirtualSize)\n\t\tfmt.Println(\"ParentId: \", img.ParentID)\n\t}\n}\n```\n\n## Using with TLS\n\nIn order to instantiate the client for a TLS-enabled daemon, you should use\nNewTLSClient, passing the endpoint and path for key and certificates as\nparameters.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\tdocker \"github.com/fsouza/go-dockerclient\"\n)\n\nfunc main() {\n\tconst endpoint = \"tcp://[ip]:[port]\"\n\tpath := os.Getenv(\"DOCKER_CERT_PATH\")\n\tca := fmt.Sprintf(\"%s/ca.pem\", path)\n\tcert := fmt.Sprintf(\"%s/cert.pem\", path)\n\tkey := fmt.Sprintf(\"%s/key.pem\", path)\n\tclient, _ := docker.NewTLSClient(endpoint, cert, key, ca)\n\t// use client\n}\n```\n\nIf using [docker-machine](https://docs.docker.com/machine/), or another\napplication that exports environment variables `DOCKER_HOST`,\n`DOCKER_TLS_VERIFY`, `DOCKER_CERT_PATH`, `DOCKER_API_VERSION`, you can use\nNewClientFromEnv.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\tdocker \"github.com/fsouza/go-dockerclient\"\n)\n\nfunc main() {\n\tclient, err := docker.NewClientFromEnv()\n\tif err != nil {\n\t\t// handle err\n\t}\n\t// use client\n}\n```\n\nSee the documentation for more details.\n\n## Developing\n\nAll development commands can be seen in the [Makefile](Makefile).\n\nCommitted code must pass:\n\n* [golangci-lint](https://github.com/golangci/golangci-lint)\n* [go test](https://golang.org/cmd/go/#hdr-Test_packages)\n* [staticcheck](https://staticcheck.io/)\n\nRunning ``make test`` will run all checks, as well as install any required\ndependencies.\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 10.7841796875,
          "content": "// Copyright 2015 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"strings\"\n)\n\n// ErrCannotParseDockercfg is the error returned by NewAuthConfigurations when the dockercfg cannot be parsed.\nvar ErrCannotParseDockercfg = errors.New(\"failed to read authentication from dockercfg\")\n\n// AuthConfiguration represents authentication options to use in the PushImage\n// method. It represents the authentication in the Docker index server.\ntype AuthConfiguration struct {\n\tUsername      string `json:\"username,omitempty\"`\n\tPassword      string `json:\"password,omitempty\"`\n\tEmail         string `json:\"email,omitempty\"`\n\tServerAddress string `json:\"serveraddress,omitempty\"`\n\n\t// IdentityToken can be supplied with the identitytoken response of the AuthCheck call\n\t// see https://pkg.go.dev/github.com/docker/docker/api/types?tab=doc#AuthConfig\n\t// It can be used in place of password not in conjunction with it\n\tIdentityToken string `json:\"identitytoken,omitempty\"`\n\n\t// RegistryToken can be supplied with the registrytoken\n\tRegistryToken string `json:\"registrytoken,omitempty\"`\n}\n\nfunc (c AuthConfiguration) isEmpty() bool {\n\treturn c == AuthConfiguration{}\n}\n\nfunc (c AuthConfiguration) headerKey() string {\n\treturn \"X-Registry-Auth\"\n}\n\n// AuthConfigurations represents authentication options to use for the\n// PushImage method accommodating the new X-Registry-Config header\ntype AuthConfigurations struct {\n\tConfigs map[string]AuthConfiguration `json:\"configs\"`\n}\n\nfunc (c AuthConfigurations) isEmpty() bool {\n\treturn len(c.Configs) == 0\n}\n\nfunc (AuthConfigurations) headerKey() string {\n\treturn \"X-Registry-Config\"\n}\n\n// merge updates the configuration. If a key is defined in both maps, the one\n// in c.Configs takes precedence.\nfunc (c *AuthConfigurations) merge(other AuthConfigurations) {\n\tfor k, v := range other.Configs {\n\t\tif c.Configs == nil {\n\t\t\tc.Configs = make(map[string]AuthConfiguration)\n\t\t}\n\t\tif _, ok := c.Configs[k]; !ok {\n\t\t\tc.Configs[k] = v\n\t\t}\n\t}\n}\n\n// AuthConfigurations119 is used to serialize a set of AuthConfigurations\n// for Docker API >= 1.19.\ntype AuthConfigurations119 map[string]AuthConfiguration\n\nfunc (c AuthConfigurations119) isEmpty() bool {\n\treturn len(c) == 0\n}\n\nfunc (c AuthConfigurations119) headerKey() string {\n\treturn \"X-Registry-Config\"\n}\n\n// dockerConfig represents a registry authentation configuration from the\n// .dockercfg file.\ntype dockerConfig struct {\n\tAuth          string `json:\"auth\"`\n\tEmail         string `json:\"email\"`\n\tIdentityToken string `json:\"identitytoken\"`\n\tRegistryToken string `json:\"registrytoken\"`\n}\n\n// NewAuthConfigurationsFromFile returns AuthConfigurations from a path containing JSON\n// in the same format as the .dockercfg file.\nfunc NewAuthConfigurationsFromFile(path string) (*AuthConfigurations, error) {\n\tr, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewAuthConfigurations(r)\n}\n\nfunc cfgPaths(dockerConfigEnv string, homeEnv string) []string {\n\tif dockerConfigEnv != \"\" {\n\t\treturn []string{\n\t\t\tpath.Join(dockerConfigEnv, \"plaintext-passwords.json\"),\n\t\t\tpath.Join(dockerConfigEnv, \"config.json\"),\n\t\t}\n\t}\n\tif homeEnv != \"\" {\n\t\treturn []string{\n\t\t\tpath.Join(homeEnv, \".docker\", \"plaintext-passwords.json\"),\n\t\t\tpath.Join(homeEnv, \".docker\", \"config.json\"),\n\t\t\tpath.Join(homeEnv, \".dockercfg\"),\n\t\t}\n\t}\n\treturn nil\n}\n\n// NewAuthConfigurationsFromDockerCfg returns AuthConfigurations from system\n// config files. The following files are checked in the order listed:\n//\n// If the environment variable DOCKER_CONFIG is set to a non-empty string:\n//\n// - $DOCKER_CONFIG/plaintext-passwords.json\n// - $DOCKER_CONFIG/config.json\n//\n// Otherwise, it looks for files in the $HOME directory and the legacy\n// location:\n//\n// - $HOME/.docker/plaintext-passwords.json\n// - $HOME/.docker/config.json\n// - $HOME/.dockercfg\nfunc NewAuthConfigurationsFromDockerCfg() (*AuthConfigurations, error) {\n\tpathsToTry := cfgPaths(os.Getenv(\"DOCKER_CONFIG\"), os.Getenv(\"HOME\"))\n\tif len(pathsToTry) < 1 {\n\t\treturn nil, errors.New(\"no docker configuration found\")\n\t}\n\treturn newAuthConfigurationsFromDockerCfg(pathsToTry)\n}\n\nfunc newAuthConfigurationsFromDockerCfg(pathsToTry []string) (*AuthConfigurations, error) {\n\tvar result *AuthConfigurations\n\tvar auths *AuthConfigurations\n\tvar err error\n\tfor _, path := range pathsToTry {\n\t\tauths, err = NewAuthConfigurationsFromFile(path)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif result == nil {\n\t\t\tresult = auths\n\t\t} else {\n\t\t\tresult.merge(*auths)\n\t\t}\n\t}\n\n\tif result != nil {\n\t\treturn result, nil\n\t}\n\treturn result, err\n}\n\n// NewAuthConfigurations returns AuthConfigurations from a JSON encoded string in the\n// same format as the .dockercfg file.\nfunc NewAuthConfigurations(r io.Reader) (*AuthConfigurations, error) {\n\tvar auth *AuthConfigurations\n\tconfs, err := parseDockerConfig(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tauth, err = authConfigs(confs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn auth, nil\n}\n\nfunc parseDockerConfig(r io.Reader) (map[string]dockerConfig, error) {\n\tbuf := new(bytes.Buffer)\n\tbuf.ReadFrom(r)\n\tbyteData := buf.Bytes()\n\n\tconfsWrapper := struct {\n\t\tAuths map[string]dockerConfig `json:\"auths\"`\n\t}{}\n\tif err := json.Unmarshal(byteData, &confsWrapper); err == nil {\n\t\tif len(confsWrapper.Auths) > 0 {\n\t\t\treturn confsWrapper.Auths, nil\n\t\t}\n\t}\n\n\tvar confs map[string]dockerConfig\n\tif err := json.Unmarshal(byteData, &confs); err != nil {\n\t\treturn nil, err\n\t}\n\treturn confs, nil\n}\n\n// authConfigs converts a dockerConfigs map to a AuthConfigurations object.\nfunc authConfigs(confs map[string]dockerConfig) (*AuthConfigurations, error) {\n\tc := &AuthConfigurations{\n\t\tConfigs: make(map[string]AuthConfiguration),\n\t}\n\n\tfor reg, conf := range confs {\n\t\tif conf.Auth == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// support both padded and unpadded encoding\n\t\tdata, err := base64.StdEncoding.DecodeString(conf.Auth)\n\t\tif err != nil {\n\t\t\tdata, err = base64.StdEncoding.WithPadding(base64.NoPadding).DecodeString(conf.Auth)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(\"error decoding plaintext credentials\")\n\t\t}\n\n\t\tuserpass := strings.SplitN(string(data), \":\", 2)\n\t\tif len(userpass) != 2 {\n\t\t\treturn nil, ErrCannotParseDockercfg\n\t\t}\n\n\t\tauthConfig := AuthConfiguration{\n\t\t\tEmail:         conf.Email,\n\t\t\tUsername:      userpass[0],\n\t\t\tPassword:      userpass[1],\n\t\t\tServerAddress: reg,\n\t\t}\n\n\t\t// if identitytoken provided then zero the password and set it\n\t\tif conf.IdentityToken != \"\" {\n\t\t\tauthConfig.Password = \"\"\n\t\t\tauthConfig.IdentityToken = conf.IdentityToken\n\t\t}\n\n\t\t// if registrytoken provided then zero the password and set it\n\t\tif conf.RegistryToken != \"\" {\n\t\t\tauthConfig.Password = \"\"\n\t\t\tauthConfig.RegistryToken = conf.RegistryToken\n\t\t}\n\t\tc.Configs[reg] = authConfig\n\t}\n\n\treturn c, nil\n}\n\n// AuthStatus returns the authentication status for Docker API versions >= 1.23.\ntype AuthStatus struct {\n\tStatus        string `json:\"Status,omitempty\" yaml:\"Status,omitempty\" toml:\"Status,omitempty\"`\n\tIdentityToken string `json:\"IdentityToken,omitempty\" yaml:\"IdentityToken,omitempty\" toml:\"IdentityToken,omitempty\"`\n}\n\n// AuthCheck validates the given credentials. It returns nil if successful.\n//\n// For Docker API versions >= 1.23, the AuthStatus struct will be populated, otherwise it will be empty.`\n//\n// See https://goo.gl/6nsZkH for more details.\nfunc (c *Client) AuthCheck(conf *AuthConfiguration) (AuthStatus, error) {\n\treturn c.AuthCheckWithContext(conf, context.TODO())\n}\n\n// AuthCheckWithContext validates the given credentials. It returns nil if successful. The context object\n// can be used to cancel the request.\n//\n// For Docker API versions >= 1.23, the AuthStatus struct will be populated, otherwise it will be empty.\n//\n// See https://goo.gl/6nsZkH for more details.\nfunc (c *Client) AuthCheckWithContext(conf *AuthConfiguration, ctx context.Context) (AuthStatus, error) {\n\tvar authStatus AuthStatus\n\tif conf == nil {\n\t\treturn authStatus, errors.New(\"conf is nil\")\n\t}\n\tresp, err := c.do(http.MethodPost, \"/auth\", doOptions{data: conf, context: ctx})\n\tif err != nil {\n\t\treturn authStatus, err\n\t}\n\tdefer resp.Body.Close()\n\tdata, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn authStatus, err\n\t}\n\tif len(data) == 0 {\n\t\treturn authStatus, nil\n\t}\n\tif err := json.Unmarshal(data, &authStatus); err != nil {\n\t\treturn authStatus, err\n\t}\n\treturn authStatus, nil\n}\n\n// helperCredentials represents credentials commit from an helper\ntype helperCredentials struct {\n\tUsername string `json:\"Username,omitempty\"`\n\tSecret   string `json:\"Secret,omitempty\"`\n}\n\n// NewAuthConfigurationsFromCredsHelpers returns AuthConfigurations from\n// installed credentials helpers\nfunc NewAuthConfigurationsFromCredsHelpers(registry string) (*AuthConfiguration, error) {\n\t// Load docker configuration file in order to find a possible helper provider\n\tpathsToTry := cfgPaths(os.Getenv(\"DOCKER_CONFIG\"), os.Getenv(\"HOME\"))\n\tif len(pathsToTry) < 1 {\n\t\treturn nil, errors.New(\"no docker configuration found\")\n\t}\n\n\tprovider, err := getHelperProviderFromDockerCfg(pathsToTry, registry)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc, err := getCredentialsFromHelper(provider, registry)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcreds := new(AuthConfiguration)\n\tcreds.Username = c.Username\n\tcreds.Password = c.Secret\n\treturn creds, nil\n}\n\nfunc getHelperProviderFromDockerCfg(pathsToTry []string, registry string) (string, error) {\n\tfor _, path := range pathsToTry {\n\t\tcontent, err := os.ReadFile(path)\n\t\tif err != nil {\n\t\t\t// if we can't read the file keep going\n\t\t\tcontinue\n\t\t}\n\n\t\tprovider, err := parseCredsDockerConfig(content, registry)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif provider != \"\" {\n\t\t\treturn provider, nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no docker credentials provider found\")\n}\n\nfunc parseCredsDockerConfig(config []byte, registry string) (string, error) {\n\tcreds := struct {\n\t\tCredsStore  string            `json:\"credsStore,omitempty\"`\n\t\tCredHelpers map[string]string `json:\"credHelpers,omitempty\"`\n\t}{}\n\terr := json.Unmarshal(config, &creds)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tprovider, ok := creds.CredHelpers[registry]\n\tif ok {\n\t\treturn provider, nil\n\t}\n\treturn creds.CredsStore, nil\n}\n\n// Run and parse the found credential helper\nfunc getCredentialsFromHelper(provider string, registry string) (*helperCredentials, error) {\n\thelpercreds, err := runDockerCredentialsHelper(provider, registry)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := new(helperCredentials)\n\terr = json.Unmarshal(helpercreds, c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c, nil\n}\n\nfunc runDockerCredentialsHelper(provider string, registry string) ([]byte, error) {\n\tcmd := exec.Command(\"docker-credential-\"+provider, \"get\")\n\n\tvar stdout bytes.Buffer\n\n\tcmd.Stdin = bytes.NewBuffer([]byte(registry))\n\tcmd.Stdout = &stdout\n\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn stdout.Bytes(), nil\n}\n"
        },
        {
          "name": "auth_test.go",
          "type": "blob",
          "size": 14.0654296875,
          "content": "// Copyright 2015 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestAuthConfigurationSearchPath(t *testing.T) {\n\tt.Parallel()\n\ttestData := []struct {\n\t\tdockerConfigEnv string\n\t\thomeEnv         string\n\t\texpectedPaths   []string\n\t}{\n\t\t{\"\", \"\", []string{}},\n\t\t{\"\", \"home\", []string{path.Join(\"home\", \".docker\", \"plaintext-passwords.json\"), path.Join(\"home\", \".docker\", \"config.json\"), path.Join(\"home\", \".dockercfg\")}},\n\t\t{\"docker_config\", \"\", []string{path.Join(\"docker_config\", \"plaintext-passwords.json\"), path.Join(\"docker_config\", \"config.json\")}},\n\t\t{\"a\", \"b\", []string{path.Join(\"a\", \"plaintext-passwords.json\"), path.Join(\"a\", \"config.json\")}},\n\t}\n\tfor _, tt := range testData {\n\t\ttt := tt\n\t\tt.Run(tt.dockerConfigEnv+tt.homeEnv, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tpaths := cfgPaths(tt.dockerConfigEnv, tt.homeEnv)\n\t\t\tif got, want := strings.Join(paths, \",\"), strings.Join(tt.expectedPaths, \",\"); got != want {\n\t\t\t\tt.Errorf(\"cfgPaths: wrong result. Want: %s. Got: %s\", want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAuthConfigurationsFromFile(t *testing.T) {\n\tt.Parallel()\n\ttmpDir, err := os.MkdirTemp(\"\", \"go-dockerclient-auth-test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create temporary directory for TestAuthConfigurationsFromFile: %s\", err)\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\tauthString := base64.StdEncoding.EncodeToString([]byte(\"user:pass\"))\n\tcontent := fmt.Sprintf(`{\"auths\":{\"foo\": {\"auth\": \"%s\"}}}`, authString)\n\tconfigFile := path.Join(tmpDir, \"docker_config\")\n\tif err = os.WriteFile(configFile, []byte(content), 0o600); err != nil {\n\t\tt.Errorf(\"Error writing auth config for TestAuthConfigurationsFromFile: %s\", err)\n\t}\n\tauths, err := NewAuthConfigurationsFromFile(configFile)\n\tif err != nil {\n\t\tt.Errorf(\"Error calling NewAuthConfigurationsFromFile: %s\", err)\n\t}\n\tif _, hasKey := auths.Configs[\"foo\"]; !hasKey {\n\t\tt.Errorf(\"Returned auths did not include expected auth key foo\")\n\t}\n}\n\nfunc TestAuthConfigurationsFromDockerCfg(t *testing.T) {\n\tt.Parallel()\n\ttmpDir, err := os.MkdirTemp(\"\", \"go-dockerclient-auth-dockercfg-test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create temporary directory for TestAuthConfigurationsFromDockerCfg: %s\", err)\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\n\tkeys := []string{\n\t\t\"docker.io\",\n\t\t\"us.gcr.io\",\n\t}\n\tpathsToTry := []string{\"some/unknown/path\"}\n\tfor i, key := range keys {\n\t\tauthString := base64.StdEncoding.EncodeToString([]byte(\"user:pass\"))\n\t\tcontent := fmt.Sprintf(`{\"auths\":{\"%s\": {\"auth\": \"%s\"}}}`, key, authString)\n\t\tconfigFile := path.Join(tmpDir, fmt.Sprintf(\"docker_config_%d.json\", i))\n\t\tif err = os.WriteFile(configFile, []byte(content), 0o600); err != nil {\n\t\t\tt.Errorf(\"Error writing auth config for TestAuthConfigurationsFromFile: %s\", err)\n\t\t}\n\t\tpathsToTry = append(pathsToTry, configFile)\n\t}\n\tauths, err := newAuthConfigurationsFromDockerCfg(pathsToTry)\n\tif err != nil {\n\t\tt.Errorf(\"Error calling NewAuthConfigurationsFromFile: %s\", err)\n\t}\n\n\tfor _, key := range keys {\n\t\tif _, hasKey := auths.Configs[key]; !hasKey {\n\t\t\tt.Errorf(\"Returned auths did not include expected auth key %q\", key)\n\t\t}\n\t}\n}\n\nfunc TestAuthConfigurationsFromDockerCfgError(t *testing.T) {\n\tt.Parallel()\n\tauths, err := newAuthConfigurationsFromDockerCfg([]string{\"this/doesnt/exist.json\"})\n\tif err == nil {\n\t\tt.Fatalf(\"unexpected <nil> error, returned auth config: %#v\", auths)\n\t}\n}\n\nfunc TestAuthLegacyConfig(t *testing.T) {\n\tt.Parallel()\n\tauth := base64.StdEncoding.EncodeToString([]byte(\"user:pa:ss\"))\n\tread := strings.NewReader(fmt.Sprintf(`{\"docker.io\":{\"auth\":\"%s\",\"email\":\"user@example.com\"}}`, auth))\n\tac, err := NewAuthConfigurations(read)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tc, ok := ac.Configs[\"docker.io\"]\n\tif !ok {\n\t\tt.Error(\"NewAuthConfigurations: Expected Configs to contain docker.io\")\n\t}\n\tif got, want := c.Email, \"user@example.com\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Email: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.Username, \"user\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Username: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.Password, \"pa:ss\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Password: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.ServerAddress, \"docker.io\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].ServerAddress: wrong result. Want %q. Got %q`, want, got)\n\t}\n}\n\nfunc TestAuthBadConfig(t *testing.T) {\n\tt.Parallel()\n\tauth := base64.StdEncoding.EncodeToString([]byte(\"userpass\"))\n\tread := strings.NewReader(fmt.Sprintf(`{\"docker.io\":{\"auth\":\"%s\",\"email\":\"user@example.com\"}}`, auth))\n\tac, err := NewAuthConfigurations(read)\n\tif !errors.Is(err, ErrCannotParseDockercfg) {\n\t\tt.Errorf(\"Incorrect error returned %v\\n\", err)\n\t}\n\tif ac != nil {\n\t\tt.Errorf(\"Invalid auth configuration returned, should be nil %v\\n\", ac)\n\t}\n}\n\nfunc TestAuthMixedWithKeyChain(t *testing.T) {\n\tt.Parallel()\n\tauth := base64.StdEncoding.EncodeToString([]byte(\"user:pass\"))\n\tread := strings.NewReader(fmt.Sprintf(`{\"auths\":{\"docker.io\":{},\"localhost:5000\":{\"auth\":\"%s\"}},\"credsStore\":\"osxkeychain\"}`, auth))\n\tac, err := NewAuthConfigurations(read)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tc, ok := ac.Configs[\"localhost:5000\"]\n\tif !ok {\n\t\tt.Error(\"NewAuthConfigurations: Expected Configs to contain localhost:5000\")\n\t}\n\tif got, want := c.Username, \"user\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Username: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.Password, \"pass\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Password: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.ServerAddress, \"localhost:5000\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"localhost:5000\"].ServerAddress: wrong result. Want %q. Got %q`, want, got)\n\t}\n}\n\nfunc TestAuthAndOtherFields(t *testing.T) {\n\tt.Parallel()\n\tauth := base64.StdEncoding.EncodeToString([]byte(\"user:pass\"))\n\tread := strings.NewReader(fmt.Sprintf(`{\n\t\t\"auths\":{\"docker.io\":{\"auth\":\"%s\",\"email\":\"user@example.com\"}},\n\t\t\"detachKeys\": \"ctrl-e,e\",\n\t\t\"HttpHeaders\": { \"MyHeader\": \"MyValue\" }}`, auth))\n\n\tac, err := NewAuthConfigurations(read)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tc, ok := ac.Configs[\"docker.io\"]\n\tif !ok {\n\t\tt.Error(\"NewAuthConfigurations: Expected Configs to contain docker.io\")\n\t}\n\tif got, want := c.Email, \"user@example.com\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Email: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.Username, \"user\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Username: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.Password, \"pass\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Password: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.ServerAddress, \"docker.io\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].ServerAddress: wrong result. Want %q. Got %q`, want, got)\n\t}\n}\n\nfunc TestAuthConfig(t *testing.T) {\n\tt.Parallel()\n\tauth := base64.StdEncoding.EncodeToString([]byte(\"user:pass\"))\n\tread := strings.NewReader(fmt.Sprintf(`{\"auths\":{\"docker.io\":{\"auth\":\"%s\",\"email\":\"user@example.com\"}}}`, auth))\n\tac, err := NewAuthConfigurations(read)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tc, ok := ac.Configs[\"docker.io\"]\n\tif !ok {\n\t\tt.Error(\"NewAuthConfigurations: Expected Configs to contain docker.io\")\n\t}\n\tif got, want := c.Email, \"user@example.com\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Email: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.Username, \"user\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Username: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.Password, \"pass\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Password: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.ServerAddress, \"docker.io\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].ServerAddress: wrong result. Want %q. Got %q`, want, got)\n\t}\n}\n\nfunc TestAuthConfigIdentityToken(t *testing.T) {\n\tt.Parallel()\n\tauth := base64.StdEncoding.EncodeToString([]byte(\"someuser:\"))\n\tread := strings.NewReader(fmt.Sprintf(`{\"auths\":{\"docker.io\":{\"auth\":\"%s\",\"identitytoken\":\"sometoken\"}}}`, auth))\n\tac, err := NewAuthConfigurations(read)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tc, ok := ac.Configs[\"docker.io\"]\n\tif !ok {\n\t\tt.Error(\"NewAuthConfigurations: Expected Configs to contain docker.io\")\n\t}\n\tif got, want := c.Username, \"someuser\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Username: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.IdentityToken, \"sometoken\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].IdentityToken: wrong result. Want %q. Got %q`, want, got)\n\t}\n}\n\nfunc TestAuthConfigRegistryToken(t *testing.T) {\n\tt.Parallel()\n\tauth := base64.StdEncoding.EncodeToString([]byte(\"someuser:\"))\n\tread := strings.NewReader(fmt.Sprintf(`{\"auths\":{\"docker.io\":{\"auth\":\"%s\",\"registrytoken\":\"sometoken\"}}}`, auth))\n\tac, err := NewAuthConfigurations(read)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tc, ok := ac.Configs[\"docker.io\"]\n\tif !ok {\n\t\tt.Error(\"NewAuthConfigurations: Expected Configs to contain docker.io\")\n\t}\n\tif got, want := c.Username, \"someuser\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].Username: wrong result. Want %q. Got %q`, want, got)\n\t}\n\tif got, want := c.RegistryToken, \"sometoken\"; got != want {\n\t\tt.Errorf(`AuthConfigurations.Configs[\"docker.io\"].RegistryToken: wrong result. Want %q. Got %q`, want, got)\n\t}\n}\n\nfunc TestAuthCheck(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tif _, err := client.AuthCheck(nil); err == nil {\n\t\tt.Fatalf(\"expected error on nil auth config\")\n\t}\n\t// test good auth\n\tif _, err := client.AuthCheck(&AuthConfiguration{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t*fakeRT = FakeRoundTripper{status: http.StatusUnauthorized}\n\tif _, err := client.AuthCheck(&AuthConfiguration{}); err == nil {\n\t\tt.Fatal(\"expected failure from unauthorized auth\")\n\t}\n}\n\nfunc TestAuthConfigurationsMerge(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname     string\n\t\tleft     AuthConfigurations\n\t\tright    AuthConfigurations\n\t\texpected AuthConfigurations\n\t}{\n\t\t{\n\t\t\tname:     \"empty configs\",\n\t\t\texpected: AuthConfigurations{},\n\t\t},\n\t\t{\n\t\t\tname: \"empty left config\",\n\t\t\tright: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"docker.io\": {Email: \"user@example.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"docker.io\": {Email: \"user@example.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"empty right config\",\n\t\t\tleft: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"docker.io\": {Email: \"user@example.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"docker.io\": {Email: \"user@example.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no conflicts\",\n\t\t\tleft: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"docker.io\": {Email: \"user@example.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tright: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"us.gcr.io\": {Email: \"user@google.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"docker.io\": {Email: \"user@example.com\"},\n\t\t\t\t\t\"us.gcr.io\": {Email: \"user@google.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no conflicts\",\n\t\t\tleft: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"docker.io\": {Email: \"user@example.com\"},\n\t\t\t\t\t\"us.gcr.io\": {Email: \"google-user@example.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tright: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"us.gcr.io\": {Email: \"user@google.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: AuthConfigurations{\n\t\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\t\"docker.io\": {Email: \"user@example.com\"},\n\t\t\t\t\t\"us.gcr.io\": {Email: \"google-user@example.com\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ttest.left.merge(test.right)\n\n\t\t\tif !reflect.DeepEqual(test.left, test.expected) {\n\t\t\t\tt.Errorf(\"wrong configuration map after merge\\nwant %#v\\ngot  %#v\", test.expected, test.left)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetHelperProviderFromDockerCfg(t *testing.T) {\n\tt.Parallel()\n\ttmpDir, err := os.MkdirTemp(\"\", \"go-dockerclient-creds-test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create temporary directory for TestGetHelperProviderFromDockerCfg: %s\", err)\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\texpectedProvider := \"ecr-login-test\"\n\tcontent := fmt.Sprintf(`{\"credsStore\": \"ecr-login\",\"credHelpers\":{\"docker.io\":\"%s\"}}`, expectedProvider)\n\tconfigFile := path.Join(tmpDir, \"docker_config\")\n\tif err = os.WriteFile(configFile, []byte(content), 0o600); err != nil {\n\t\tt.Errorf(\"Error writing auth config for TestGetHelperProviderFromDockerCfg: %s\", err)\n\t}\n\n\tconfigFileNotExists := path.Join(tmpDir, \"do_not_exists\")\n\n\tprovider, err := getHelperProviderFromDockerCfg([]string{configFileNotExists, configFile}, \"docker.io\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif provider != expectedProvider {\n\t\tt.Errorf(\"wrong provider found: \\nwant %s\\ngot  %s\", expectedProvider, provider)\n\t}\n}\n\nfunc TestParseCredsDockerConfig(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tconfig   []byte\n\t\tprovider string\n\t\tregistry string\n\t}{\n\t\t{\n\t\t\tconfig:   []byte(`{\"credsStore\": \"ecr-login\"}`),\n\t\t\tprovider: \"ecr-login\",\n\t\t\tregistry: \"docker.io\",\n\t\t},\n\t\t{\n\t\t\tconfig:   []byte(`{\"credsStore\": \"ecr-login\",\"credHelpers\":{\"docker.io\":\"ecr-login-test\"}}`),\n\t\t\tprovider: \"ecr-login-test\",\n\t\t\tregistry: \"docker.io\",\n\t\t},\n\t\t{\n\t\t\tconfig:   []byte(`{\"credsStore\": \"ecr-login\",\"credHelpers\":{\"docker.io\":\"ecr-login-test\"}}`),\n\t\t\tprovider: \"ecr-login\",\n\t\t\tregistry: \"docker.io2\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tprovider, err := parseCredsDockerConfig(test.config, test.registry)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif provider != test.provider {\n\t\t\tt.Errorf(\"wrong provider found: \\nwant %s\\ngot  %s\", test.provider, provider)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "build_test.go",
          "type": "blob",
          "size": 4.0078125,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/pkg/archive\"\n)\n\nfunc TestBuildImageMultipleContextsError(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := BuildImageOptions{\n\t\tName:                \"testImage\",\n\t\tNoCache:             true,\n\t\tCacheFrom:           []string{\"a\", \"b\", \"c\"},\n\t\tSuppressOutput:      true,\n\t\tRmTmpContainer:      true,\n\t\tForceRmTmpContainer: true,\n\t\tInputStream:         &buf,\n\t\tOutputStream:        &buf,\n\t\tContextDir:          \"testing/data\",\n\t}\n\terr := client.BuildImage(opts)\n\tif !errors.Is(err, ErrMultipleContexts) {\n\t\tt.Errorf(\"BuildImage: providing both InputStream and ContextDir should produce an error\")\n\t}\n}\n\nfunc TestBuildImageContextDirDockerignoreParsing(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\n\tif err := os.Symlink(\"doesnotexist\", \"testing/data/symlink\"); err != nil {\n\t\tt.Errorf(\"error creating symlink on demand: %s\", err)\n\t}\n\tdefer func() {\n\t\tif err := os.Remove(\"testing/data/symlink\"); err != nil {\n\t\t\tt.Errorf(\"error removing symlink on demand: %s\", err)\n\t\t}\n\t}()\n\tworkingdir, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar buf bytes.Buffer\n\topts := BuildImageOptions{\n\t\tName:                \"testImage\",\n\t\tNoCache:             true,\n\t\tCacheFrom:           []string{\"a\", \"b\", \"c\"},\n\t\tSuppressOutput:      true,\n\t\tRmTmpContainer:      true,\n\t\tForceRmTmpContainer: true,\n\t\tOutputStream:        &buf,\n\t\tContextDir:          filepath.Join(workingdir, \"testing\", \"data\"),\n\t}\n\terr = client.BuildImage(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treqBody := fakeRT.requests[0].Body\n\ttmpdir, err := unpackBodyTarball(reqBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer func() {\n\t\tif err = os.RemoveAll(tmpdir); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tfiles, err := os.ReadDir(tmpdir)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfoundFiles := []string{}\n\tfor _, file := range files {\n\t\tfoundFiles = append(foundFiles, file.Name())\n\t}\n\n\texpectedFiles := []string{\n\t\t\".dockerignore\",\n\t\t\"Dockerfile\",\n\t\t\"barfile\",\n\t\t\"ca.pem\",\n\t\t\"cert.pem\",\n\t\t\"key.pem\",\n\t\t\"server.pem\",\n\t\t\"serverkey.pem\",\n\t\t\"symlink\",\n\t}\n\n\tif !reflect.DeepEqual(expectedFiles, foundFiles) {\n\t\tt.Errorf(\n\t\t\t\"BuildImage: incorrect files sent in tarball to docker server\\nexpected %+v, found %+v\",\n\t\t\texpectedFiles, foundFiles,\n\t\t)\n\t}\n}\n\nfunc TestBuildImageSendXRegistryConfig(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := BuildImageOptions{\n\t\tName:                \"testImage\",\n\t\tNoCache:             true,\n\t\tSuppressOutput:      true,\n\t\tRmTmpContainer:      true,\n\t\tForceRmTmpContainer: true,\n\t\tOutputStream:        &buf,\n\t\tContextDir:          \"testing/data\",\n\t\tAuthConfigs: AuthConfigurations{\n\t\t\tConfigs: map[string]AuthConfiguration{\n\t\t\t\t\"quay.io\": {\n\t\t\t\t\tUsername:      \"foo\",\n\t\t\t\t\tPassword:      \"bar\",\n\t\t\t\t\tEmail:         \"baz\",\n\t\t\t\t\tServerAddress: \"quay.io\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tencodedConfig := \"eyJjb25maWdzIjp7InF1YXkuaW8iOnsidXNlcm5hbWUiOiJmb28iLCJwYXNzd29yZCI6ImJhciIsImVtYWlsIjoiYmF6Iiwic2VydmVyYWRkcmVzcyI6InF1YXkuaW8ifX19\"\n\tif err := client.BuildImage(opts); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\txRegistryConfig := fakeRT.requests[0].Header.Get(\"X-Registry-Config\")\n\tif xRegistryConfig != encodedConfig {\n\t\tt.Errorf(\n\t\t\t\"BuildImage: X-Registry-Config not set currectly: expected %q, got %q\",\n\t\t\tencodedConfig,\n\t\t\txRegistryConfig,\n\t\t)\n\t}\n}\n\nfunc unpackBodyTarball(req io.Reader) (tmpdir string, err error) {\n\ttmpdir, err = os.MkdirTemp(\"\", \"go-dockerclient-test\")\n\tif err != nil {\n\t\treturn\n\t}\n\terr = archive.Untar(req, tmpdir, &archive.TarOptions{\n\t\tCompression: archive.Uncompressed,\n\t\tNoLchown:    true,\n\t})\n\treturn\n}\n"
        },
        {
          "name": "change.go",
          "type": "blob",
          "size": 0.921875,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport \"fmt\"\n\n// ChangeType is a type for constants indicating the type of change\n// in a container\ntype ChangeType int\n\nconst (\n\t// ChangeModify is the ChangeType for container modifications\n\tChangeModify ChangeType = iota\n\n\t// ChangeAdd is the ChangeType for additions to a container\n\tChangeAdd\n\n\t// ChangeDelete is the ChangeType for deletions from a container\n\tChangeDelete\n)\n\n// Change represents a change in a container.\n//\n// See https://goo.gl/Wo0JJp for more details.\ntype Change struct {\n\tPath string\n\tKind ChangeType\n}\n\nfunc (change *Change) String() string {\n\tvar kind string\n\tswitch change.Kind {\n\tcase ChangeModify:\n\t\tkind = \"C\"\n\tcase ChangeAdd:\n\t\tkind = \"A\"\n\tcase ChangeDelete:\n\t\tkind = \"D\"\n\t}\n\treturn fmt.Sprintf(\"%s %s\", kind, change.Path)\n}\n"
        },
        {
          "name": "change_test.go",
          "type": "blob",
          "size": 0.7626953125,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport \"testing\"\n\nfunc TestChangeString(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tchange   Change\n\t\texpected string\n\t}{\n\t\t{Change{\"/etc/passwd\", ChangeModify}, \"C /etc/passwd\"},\n\t\t{Change{\"/etc/passwd\", ChangeAdd}, \"A /etc/passwd\"},\n\t\t{Change{\"/etc/passwd\", ChangeDelete}, \"D /etc/passwd\"},\n\t\t{Change{\"/etc/passwd\", 33}, \" /etc/passwd\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif got := test.change.String(); got != test.expected {\n\t\t\t\tt.Errorf(\"Change.String(): want %q. Got %q.\", test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 31.7763671875,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package docker provides a client for the Docker remote API.\n//\n// See https://goo.gl/o2v3rk for more details on the remote API.\npackage docker\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/docker/docker/pkg/homedir\"\n\t\"github.com/docker/docker/pkg/jsonmessage\"\n\t\"github.com/docker/docker/pkg/stdcopy\"\n)\n\nconst (\n\tuserAgent = \"go-dockerclient\"\n\n\tunixProtocol      = \"unix\"\n\tnamedPipeProtocol = \"npipe\"\n)\n\nvar (\n\t// ErrInvalidEndpoint is returned when the endpoint is not a valid HTTP URL.\n\tErrInvalidEndpoint = errors.New(\"invalid endpoint\")\n\n\t// ErrConnectionRefused is returned when the client cannot connect to the given endpoint.\n\tErrConnectionRefused = errors.New(\"cannot connect to Docker endpoint\")\n\n\t// ErrInactivityTimeout is returned when a streamable call has been inactive for some time.\n\tErrInactivityTimeout = errors.New(\"inactivity time exceeded timeout\")\n\n\tapiVersion112, _ = NewAPIVersion(\"1.12\")\n\tapiVersion118, _ = NewAPIVersion(\"1.18\")\n\tapiVersion119, _ = NewAPIVersion(\"1.19\")\n\tapiVersion121, _ = NewAPIVersion(\"1.21\")\n\tapiVersion124, _ = NewAPIVersion(\"1.24\")\n\tapiVersion125, _ = NewAPIVersion(\"1.25\")\n\tapiVersion135, _ = NewAPIVersion(\"1.35\")\n)\n\n// APIVersion is an internal representation of a version of the Remote API.\ntype APIVersion []int\n\n// NewAPIVersion returns an instance of APIVersion for the given string.\n//\n// The given string must be in the form <major>.<minor>.<patch>, where <major>,\n// <minor> and <patch> are integer numbers.\nfunc NewAPIVersion(input string) (APIVersion, error) {\n\tif !strings.Contains(input, \".\") {\n\t\treturn nil, fmt.Errorf(\"unable to parse version %q\", input)\n\t}\n\traw := strings.Split(input, \"-\")\n\tarr := strings.Split(raw[0], \".\")\n\tret := make(APIVersion, len(arr))\n\tvar err error\n\tfor i, val := range arr {\n\t\tret[i], err = strconv.Atoi(val)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to parse version %q: %q is not an integer\", input, val)\n\t\t}\n\t}\n\treturn ret, nil\n}\n\nfunc (version APIVersion) String() string {\n\tparts := make([]string, len(version))\n\tfor i, val := range version {\n\t\tparts[i] = strconv.Itoa(val)\n\t}\n\treturn strings.Join(parts, \".\")\n}\n\n// LessThan is a function for comparing APIVersion structs.\nfunc (version APIVersion) LessThan(other APIVersion) bool {\n\treturn version.compare(other) < 0\n}\n\n// LessThanOrEqualTo is a function for comparing APIVersion structs.\nfunc (version APIVersion) LessThanOrEqualTo(other APIVersion) bool {\n\treturn version.compare(other) <= 0\n}\n\n// GreaterThan is a function for comparing APIVersion structs.\nfunc (version APIVersion) GreaterThan(other APIVersion) bool {\n\treturn version.compare(other) > 0\n}\n\n// GreaterThanOrEqualTo is a function for comparing APIVersion structs.\nfunc (version APIVersion) GreaterThanOrEqualTo(other APIVersion) bool {\n\treturn version.compare(other) >= 0\n}\n\nfunc (version APIVersion) compare(other APIVersion) int {\n\tfor i, v := range version {\n\t\tif i <= len(other)-1 {\n\t\t\totherVersion := other[i]\n\n\t\t\tif v < otherVersion {\n\t\t\t\treturn -1\n\t\t\t} else if v > otherVersion {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t}\n\t}\n\tif len(version) > len(other) {\n\t\treturn 1\n\t}\n\tif len(version) < len(other) {\n\t\treturn -1\n\t}\n\treturn 0\n}\n\n// Client is the basic type of this package. It provides methods for\n// interaction with the API.\ntype Client struct {\n\tSkipServerVersionCheck bool\n\tHTTPClient             *http.Client\n\tTLSConfig              *tls.Config\n\tDialer                 Dialer\n\n\tendpoint            string\n\tendpointURL         *url.URL\n\teventMonitor        *eventMonitoringState\n\trequestedAPIVersion APIVersion\n\tserverAPIVersion    APIVersion\n\texpectedAPIVersion  APIVersion\n}\n\n// Dialer is an interface that allows network connections to be dialed\n// (net.Dialer fulfills this interface) and named pipes (a shim using\n// winio.DialPipe)\ntype Dialer interface {\n\tDial(network, address string) (net.Conn, error)\n}\n\n// NewClient returns a Client instance ready for communication with the given\n// server endpoint. It will use the latest remote API version available in the\n// server.\nfunc NewClient(endpoint string) (*Client, error) {\n\tclient, err := NewVersionedClient(endpoint, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.SkipServerVersionCheck = true\n\treturn client, nil\n}\n\n// NewTLSClient returns a Client instance ready for TLS communications with the givens\n// server endpoint, key and certificates . It will use the latest remote API version\n// available in the server.\nfunc NewTLSClient(endpoint string, cert, key, ca string) (*Client, error) {\n\tclient, err := NewVersionedTLSClient(endpoint, cert, key, ca, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.SkipServerVersionCheck = true\n\treturn client, nil\n}\n\n// NewTLSClientFromBytes returns a Client instance ready for TLS communications with the givens\n// server endpoint, key and certificates (passed inline to the function as opposed to being\n// read from a local file). It will use the latest remote API version available in the server.\nfunc NewTLSClientFromBytes(endpoint string, certPEMBlock, keyPEMBlock, caPEMCert []byte) (*Client, error) {\n\tclient, err := NewVersionedTLSClientFromBytes(endpoint, certPEMBlock, keyPEMBlock, caPEMCert, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.SkipServerVersionCheck = true\n\treturn client, nil\n}\n\n// NewVersionedClient returns a Client instance ready for communication with\n// the given server endpoint, using a specific remote API version.\nfunc NewVersionedClient(endpoint string, apiVersionString string) (*Client, error) {\n\tu, err := parseEndpoint(endpoint, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar requestedAPIVersion APIVersion\n\tif strings.Contains(apiVersionString, \".\") {\n\t\trequestedAPIVersion, err = NewAPIVersion(apiVersionString)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tc := &Client{\n\t\tHTTPClient:          defaultClient(),\n\t\tDialer:              &net.Dialer{},\n\t\tendpoint:            endpoint,\n\t\tendpointURL:         u,\n\t\teventMonitor:        new(eventMonitoringState),\n\t\trequestedAPIVersion: requestedAPIVersion,\n\t}\n\tc.initializeNativeClient(defaultTransport)\n\treturn c, nil\n}\n\n// WithTransport replaces underlying HTTP client of Docker Client by accepting\n// a function that returns pointer to a transport object.\nfunc (c *Client) WithTransport(trFunc func() *http.Transport) {\n\tc.initializeNativeClient(trFunc)\n}\n\n// NewVersionnedTLSClient is like NewVersionedClient, but with ann extra n.\n//\n// Deprecated: Use NewVersionedTLSClient instead.\nfunc NewVersionnedTLSClient(endpoint string, cert, key, ca, apiVersionString string) (*Client, error) {\n\treturn NewVersionedTLSClient(endpoint, cert, key, ca, apiVersionString)\n}\n\n// NewVersionedTLSClient returns a Client instance ready for TLS communications with the givens\n// server endpoint, key and certificates, using a specific remote API version.\nfunc NewVersionedTLSClient(endpoint string, cert, key, ca, apiVersionString string) (*Client, error) {\n\tvar certPEMBlock []byte\n\tvar keyPEMBlock []byte\n\tvar caPEMCert []byte\n\tif _, err := os.Stat(cert); !os.IsNotExist(err) {\n\t\tcertPEMBlock, err = os.ReadFile(cert)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif _, err := os.Stat(key); !os.IsNotExist(err) {\n\t\tkeyPEMBlock, err = os.ReadFile(key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif _, err := os.Stat(ca); !os.IsNotExist(err) {\n\t\tcaPEMCert, err = os.ReadFile(ca)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn NewVersionedTLSClientFromBytes(endpoint, certPEMBlock, keyPEMBlock, caPEMCert, apiVersionString)\n}\n\n// NewClientFromEnv returns a Client instance ready for communication created from\n// Docker's default logic for the environment variables DOCKER_HOST, DOCKER_TLS_VERIFY, DOCKER_CERT_PATH,\n// and DOCKER_API_VERSION.\n//\n// See https://github.com/docker/docker/blob/1f963af697e8df3a78217f6fdbf67b8123a7db94/docker/docker.go#L68.\n// See https://github.com/docker/compose/blob/81707ef1ad94403789166d2fe042c8a718a4c748/compose/cli/docker_client.py#L7.\n// See https://github.com/moby/moby/blob/28d7dba41d0c0d9c7f0dafcc79d3c59f2b3f5dc3/client/options.go#L51\nfunc NewClientFromEnv() (*Client, error) {\n\tapiVersionString := os.Getenv(\"DOCKER_API_VERSION\")\n\tclient, err := NewVersionedClientFromEnv(apiVersionString)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.SkipServerVersionCheck = apiVersionString == \"\"\n\treturn client, nil\n}\n\n// NewVersionedClientFromEnv returns a Client instance ready for TLS communications created from\n// Docker's default logic for the environment variables DOCKER_HOST, DOCKER_TLS_VERIFY, and DOCKER_CERT_PATH,\n// and using a specific remote API version.\n//\n// See https://github.com/docker/docker/blob/1f963af697e8df3a78217f6fdbf67b8123a7db94/docker/docker.go#L68.\n// See https://github.com/docker/compose/blob/81707ef1ad94403789166d2fe042c8a718a4c748/compose/cli/docker_client.py#L7.\nfunc NewVersionedClientFromEnv(apiVersionString string) (*Client, error) {\n\tdockerEnv, err := getDockerEnv()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdockerHost := dockerEnv.dockerHost\n\tif dockerEnv.dockerTLSVerify {\n\t\tparts := strings.SplitN(dockerEnv.dockerHost, \"://\", 2)\n\t\tif len(parts) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"could not split %s into two parts by ://\", dockerHost)\n\t\t}\n\t\tcert := filepath.Join(dockerEnv.dockerCertPath, \"cert.pem\")\n\t\tkey := filepath.Join(dockerEnv.dockerCertPath, \"key.pem\")\n\t\tca := filepath.Join(dockerEnv.dockerCertPath, \"ca.pem\")\n\t\treturn NewVersionedTLSClient(dockerEnv.dockerHost, cert, key, ca, apiVersionString)\n\t}\n\treturn NewVersionedClient(dockerEnv.dockerHost, apiVersionString)\n}\n\n// NewVersionedTLSClientFromBytes returns a Client instance ready for TLS communications with the givens\n// server endpoint, key and certificates (passed inline to the function as opposed to being\n// read from a local file), using a specific remote API version.\nfunc NewVersionedTLSClientFromBytes(endpoint string, certPEMBlock, keyPEMBlock, caPEMCert []byte, apiVersionString string) (*Client, error) {\n\tu, err := parseEndpoint(endpoint, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar requestedAPIVersion APIVersion\n\tif strings.Contains(apiVersionString, \".\") {\n\t\trequestedAPIVersion, err = NewAPIVersion(apiVersionString)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\ttlsConfig := &tls.Config{MinVersion: tls.VersionTLS12}\n\tif certPEMBlock != nil && keyPEMBlock != nil {\n\t\ttlsCert, err := tls.X509KeyPair(certPEMBlock, keyPEMBlock)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttlsConfig.Certificates = []tls.Certificate{tlsCert}\n\t}\n\tif caPEMCert == nil {\n\t\ttlsConfig.InsecureSkipVerify = true\n\t} else {\n\t\tcaPool := x509.NewCertPool()\n\t\tif !caPool.AppendCertsFromPEM(caPEMCert) {\n\t\t\treturn nil, errors.New(\"could not add RootCA pem\")\n\t\t}\n\t\ttlsConfig.RootCAs = caPool\n\t}\n\ttr := defaultTransport()\n\ttr.TLSClientConfig = tlsConfig\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc := &Client{\n\t\tHTTPClient:          &http.Client{Transport: tr},\n\t\tTLSConfig:           tlsConfig,\n\t\tDialer:              &net.Dialer{},\n\t\tendpoint:            endpoint,\n\t\tendpointURL:         u,\n\t\teventMonitor:        new(eventMonitoringState),\n\t\trequestedAPIVersion: requestedAPIVersion,\n\t}\n\tc.initializeNativeClient(defaultTransport)\n\treturn c, nil\n}\n\n// SetTimeout takes a timeout and applies it to the HTTPClient. It should not\n// be called concurrently with any other Client methods.\nfunc (c *Client) SetTimeout(t time.Duration) {\n\tif c.HTTPClient != nil {\n\t\tc.HTTPClient.Timeout = t\n\t}\n}\n\nfunc (c *Client) checkAPIVersion() error {\n\tserverAPIVersionString, err := c.getServerAPIVersionString()\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.serverAPIVersion, err = NewAPIVersion(serverAPIVersionString)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.requestedAPIVersion == nil {\n\t\tc.expectedAPIVersion = c.serverAPIVersion\n\t} else {\n\t\tc.expectedAPIVersion = c.requestedAPIVersion\n\t}\n\treturn nil\n}\n\n// Endpoint returns the current endpoint. It's useful for getting the endpoint\n// when using functions that get this data from the environment (like\n// NewClientFromEnv.\nfunc (c *Client) Endpoint() string {\n\treturn c.endpoint\n}\n\n// Ping pings the docker server\n//\n// See https://goo.gl/wYfgY1 for more details.\nfunc (c *Client) Ping() error {\n\treturn c.PingWithContext(context.TODO())\n}\n\n// PingWithContext pings the docker server\n// The context object can be used to cancel the ping request.\n//\n// See https://goo.gl/wYfgY1 for more details.\nfunc (c *Client) PingWithContext(ctx context.Context) error {\n\tpath := \"/_ping\"\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: ctx})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn newError(resp)\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\nfunc (c *Client) getServerAPIVersionString() (version string, err error) {\n\tresp, err := c.do(http.MethodGet, \"/version\", doOptions{})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"received unexpected status %d while trying to retrieve the server version\", resp.StatusCode)\n\t}\n\tvar versionResponse map[string]any\n\tif err := json.NewDecoder(resp.Body).Decode(&versionResponse); err != nil {\n\t\treturn \"\", err\n\t}\n\tif version, ok := (versionResponse[\"ApiVersion\"]).(string); ok {\n\t\treturn version, nil\n\t}\n\treturn \"\", nil\n}\n\ntype doOptions struct {\n\tdata      any\n\tforceJSON bool\n\theaders   map[string]string\n\tcontext   context.Context\n}\n\nfunc (c *Client) do(method, path string, doOptions doOptions) (*http.Response, error) {\n\tvar params io.Reader\n\tif doOptions.data != nil || doOptions.forceJSON {\n\t\tbuf, err := json.Marshal(doOptions.data)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tparams = bytes.NewBuffer(buf)\n\t}\n\tif path != \"/version\" && !c.SkipServerVersionCheck && c.expectedAPIVersion == nil {\n\t\terr := c.checkAPIVersion()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tprotocol := c.endpointURL.Scheme\n\tvar u string\n\tswitch protocol {\n\tcase unixProtocol, namedPipeProtocol:\n\t\tu = c.getFakeNativeURL(path)\n\tdefault:\n\t\tu = c.getURL(path)\n\t}\n\n\treq, err := http.NewRequest(method, u, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tif doOptions.data != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t} else if method == http.MethodPost {\n\t\treq.Header.Set(\"Content-Type\", \"plain/text\")\n\t}\n\n\tfor k, v := range doOptions.headers {\n\t\treq.Header.Set(k, v)\n\t}\n\n\tctx := doOptions.context\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\n\tresp, err := c.HTTPClient.Do(req.WithContext(ctx))\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"connection refused\") {\n\t\t\treturn nil, ErrConnectionRefused\n\t\t}\n\n\t\treturn nil, chooseError(ctx, err)\n\t}\n\tif resp.StatusCode < http.StatusOK || resp.StatusCode >= http.StatusBadRequest {\n\t\treturn nil, newError(resp)\n\t}\n\treturn resp, nil\n}\n\ntype streamOptions struct {\n\tsetRawTerminal bool\n\trawJSONStream  bool\n\tuseJSONDecoder bool\n\theaders        map[string]string\n\tin             io.Reader\n\tstdout         io.Writer\n\tstderr         io.Writer\n\treqSent        chan struct{}\n\t// timeout is the initial connection timeout\n\ttimeout time.Duration\n\t// Timeout with no data is received, it's reset every time new data\n\t// arrives\n\tinactivityTimeout time.Duration\n\tcontext           context.Context\n}\n\nfunc chooseError(ctx context.Context, err error) error {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn context.Cause(ctx)\n\tdefault:\n\t\treturn err\n\t}\n}\n\nfunc (c *Client) stream(method, path string, streamOptions streamOptions) error {\n\tif (method == http.MethodPost || method == http.MethodPut) && streamOptions.in == nil {\n\t\tstreamOptions.in = bytes.NewReader(nil)\n\t}\n\tif path != \"/version\" && !c.SkipServerVersionCheck && c.expectedAPIVersion == nil {\n\t\terr := c.checkAPIVersion()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn c.streamURL(method, c.getURL(path), streamOptions)\n}\n\nfunc (c *Client) streamURL(method, url string, streamOptions streamOptions) error {\n\tif (method == http.MethodPost || method == http.MethodPut) && streamOptions.in == nil {\n\t\tstreamOptions.in = bytes.NewReader(nil)\n\t}\n\tif !c.SkipServerVersionCheck && c.expectedAPIVersion == nil {\n\t\terr := c.checkAPIVersion()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// make a sub-context so that our active cancellation does not affect parent\n\tctx := streamOptions.context\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\tsubCtx, cancelRequest := context.WithCancel(ctx)\n\tdefer cancelRequest()\n\n\treq, err := http.NewRequestWithContext(ctx, method, url, streamOptions.in)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"User-Agent\", userAgent)\n\tif method == http.MethodPost {\n\t\treq.Header.Set(\"Content-Type\", \"plain/text\")\n\t}\n\tfor key, val := range streamOptions.headers {\n\t\treq.Header.Set(key, val)\n\t}\n\tvar resp *http.Response\n\tprotocol := c.endpointURL.Scheme\n\taddress := c.endpointURL.Path\n\tif streamOptions.stdout == nil {\n\t\tstreamOptions.stdout = io.Discard\n\t}\n\tif streamOptions.stderr == nil {\n\t\tstreamOptions.stderr = io.Discard\n\t}\n\n\tif protocol == unixProtocol || protocol == namedPipeProtocol {\n\t\tvar dial net.Conn\n\t\tdial, err = c.Dialer.Dial(protocol, address)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgo func() {\n\t\t\t<-subCtx.Done()\n\t\t\tdial.Close()\n\t\t}()\n\t\tbreader := bufio.NewReader(dial)\n\t\terr = req.Write(dial)\n\t\tif err != nil {\n\t\t\treturn chooseError(subCtx, err)\n\t\t}\n\n\t\t// ReadResponse may hang if server does not replay\n\t\tif streamOptions.timeout > 0 {\n\t\t\tdial.SetDeadline(time.Now().Add(streamOptions.timeout))\n\t\t}\n\n\t\tif streamOptions.reqSent != nil {\n\t\t\tclose(streamOptions.reqSent)\n\t\t}\n\t\tif resp, err = http.ReadResponse(breader, req); err != nil {\n\t\t\t// Cancel timeout for future I/O operations\n\t\t\tif streamOptions.timeout > 0 {\n\t\t\t\tdial.SetDeadline(time.Time{})\n\t\t\t}\n\t\t\tif strings.Contains(err.Error(), \"connection refused\") {\n\t\t\t\treturn ErrConnectionRefused\n\t\t\t}\n\n\t\t\treturn chooseError(subCtx, err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\t} else {\n\t\tif resp, err = c.HTTPClient.Do(req.WithContext(subCtx)); err != nil {\n\t\t\tif strings.Contains(err.Error(), \"connection refused\") {\n\t\t\t\treturn ErrConnectionRefused\n\t\t\t}\n\t\t\treturn chooseError(subCtx, err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tif streamOptions.reqSent != nil {\n\t\t\tclose(streamOptions.reqSent)\n\t\t}\n\t}\n\tif resp.StatusCode < 200 || resp.StatusCode >= 400 {\n\t\treturn newError(resp)\n\t}\n\tvar canceled uint32\n\tif streamOptions.inactivityTimeout > 0 {\n\t\tvar ch chan<- struct{}\n\t\tresp.Body, ch = handleInactivityTimeout(resp.Body, streamOptions.inactivityTimeout, cancelRequest, &canceled)\n\t\tdefer close(ch)\n\t}\n\terr = handleStreamResponse(resp, &streamOptions)\n\tif err != nil {\n\t\tif atomic.LoadUint32(&canceled) != 0 {\n\t\t\treturn ErrInactivityTimeout\n\t\t}\n\t\treturn chooseError(subCtx, err)\n\t}\n\treturn nil\n}\n\nfunc handleStreamResponse(resp *http.Response, streamOptions *streamOptions) error {\n\tvar err error\n\tif !streamOptions.useJSONDecoder && resp.Header.Get(\"Content-Type\") != \"application/json\" {\n\t\tif streamOptions.setRawTerminal {\n\t\t\t_, err = io.Copy(streamOptions.stdout, resp.Body)\n\t\t} else {\n\t\t\t_, err = stdcopy.StdCopy(streamOptions.stdout, streamOptions.stderr, resp.Body)\n\t\t}\n\t\treturn err\n\t}\n\t// if we want to get raw json stream, just copy it back to output\n\t// without decoding it\n\tif streamOptions.rawJSONStream {\n\t\t_, err = io.Copy(streamOptions.stdout, resp.Body)\n\t\treturn err\n\t}\n\tif st, ok := streamOptions.stdout.(stream); ok {\n\t\terr = jsonmessage.DisplayJSONMessagesToStream(resp.Body, st, nil)\n\t} else {\n\t\terr = jsonmessage.DisplayJSONMessagesStream(resp.Body, streamOptions.stdout, 0, false, nil)\n\t}\n\treturn err\n}\n\ntype stream interface {\n\tio.Writer\n\tFD() uintptr\n\tIsTerminal() bool\n}\n\ntype proxyReader struct {\n\tio.ReadCloser\n\tcalls uint64\n}\n\nfunc (p *proxyReader) callCount() uint64 {\n\treturn atomic.LoadUint64(&p.calls)\n}\n\nfunc (p *proxyReader) Read(data []byte) (int, error) {\n\tatomic.AddUint64(&p.calls, 1)\n\treturn p.ReadCloser.Read(data)\n}\n\nfunc handleInactivityTimeout(reader io.ReadCloser, timeout time.Duration, cancelRequest func(), canceled *uint32) (io.ReadCloser, chan<- struct{}) {\n\tdone := make(chan struct{})\n\tproxyReader := &proxyReader{ReadCloser: reader}\n\tgo func() {\n\t\tvar lastCallCount uint64\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(timeout):\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurCallCount := proxyReader.callCount()\n\t\t\tif curCallCount == lastCallCount {\n\t\t\t\tatomic.AddUint32(canceled, 1)\n\t\t\t\tcancelRequest()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlastCallCount = curCallCount\n\t\t}\n\t}()\n\treturn proxyReader, done\n}\n\ntype hijackOptions struct {\n\tsuccess        chan struct{}\n\tsetRawTerminal bool\n\tin             io.Reader\n\tstdout         io.Writer\n\tstderr         io.Writer\n\tdata           any\n}\n\n// CloseWaiter is an interface with methods for closing the underlying resource\n// and then waiting for it to finish processing.\ntype CloseWaiter interface {\n\tio.Closer\n\tWait() error\n}\n\ntype waiterFunc func() error\n\nfunc (w waiterFunc) Wait() error { return w() }\n\ntype closerFunc func() error\n\nfunc (c closerFunc) Close() error { return c() }\n\nfunc (c *Client) hijack(method, path string, hijackOptions hijackOptions) (CloseWaiter, error) {\n\tif path != \"/version\" && !c.SkipServerVersionCheck && c.expectedAPIVersion == nil {\n\t\terr := c.checkAPIVersion()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tvar params io.Reader\n\tif hijackOptions.data != nil {\n\t\tbuf, err := json.Marshal(hijackOptions.data)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tparams = bytes.NewBuffer(buf)\n\t}\n\treq, err := http.NewRequest(method, c.getURL(path), params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Connection\", \"Upgrade\")\n\treq.Header.Set(\"Upgrade\", \"tcp\")\n\tprotocol := c.endpointURL.Scheme\n\taddress := c.endpointURL.Path\n\tif protocol != unixProtocol && protocol != namedPipeProtocol {\n\t\tprotocol = \"tcp\"\n\t\taddress = c.endpointURL.Host\n\t}\n\tvar dial net.Conn\n\tif c.TLSConfig != nil && protocol != unixProtocol && protocol != namedPipeProtocol {\n\t\tnetDialer, ok := c.Dialer.(*net.Dialer)\n\t\tif !ok {\n\t\t\treturn nil, ErrTLSNotSupported\n\t\t}\n\t\tdial, err = tlsDialWithDialer(netDialer, protocol, address, c.TLSConfig)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tdial, err = c.Dialer.Dial(protocol, address)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\terrs := make(chan error, 1)\n\tquit := make(chan struct{})\n\tgo func() {\n\t\t//lint:ignore SA1019 the alternative doesn't quite work, so keep using the deprecated thing.\n\t\tclientconn := httputil.NewClientConn(dial, nil)\n\t\tdefer clientconn.Close()\n\t\tclientconn.Do(req)\n\t\tif hijackOptions.success != nil {\n\t\t\thijackOptions.success <- struct{}{}\n\t\t\t<-hijackOptions.success\n\t\t}\n\t\trwc, br := clientconn.Hijack()\n\t\tdefer rwc.Close()\n\n\t\terrChanOut := make(chan error, 1)\n\t\terrChanIn := make(chan error, 2)\n\t\tif hijackOptions.stdout == nil && hijackOptions.stderr == nil {\n\t\t\tclose(errChanOut)\n\t\t} else {\n\t\t\t// Only copy if hijackOptions.stdout and/or hijackOptions.stderr is actually set.\n\t\t\t// Otherwise, if the only stream you care about is stdin, your attach session\n\t\t\t// will \"hang\" until the container terminates, even though you're not reading\n\t\t\t// stdout/stderr\n\t\t\tif hijackOptions.stdout == nil {\n\t\t\t\thijackOptions.stdout = io.Discard\n\t\t\t}\n\t\t\tif hijackOptions.stderr == nil {\n\t\t\t\thijackOptions.stderr = io.Discard\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif hijackOptions.in != nil {\n\t\t\t\t\t\tif closer, ok := hijackOptions.in.(io.Closer); ok {\n\t\t\t\t\t\t\tcloser.Close()\n\t\t\t\t\t\t}\n\t\t\t\t\t\terrChanIn <- nil\n\t\t\t\t\t}\n\t\t\t\t}()\n\n\t\t\t\tvar err error\n\t\t\t\tif hijackOptions.setRawTerminal {\n\t\t\t\t\t_, err = io.Copy(hijackOptions.stdout, br)\n\t\t\t\t} else {\n\t\t\t\t\t_, err = stdcopy.StdCopy(hijackOptions.stdout, hijackOptions.stderr, br)\n\t\t\t\t}\n\t\t\t\terrChanOut <- err\n\t\t\t}()\n\t\t}\n\n\t\tgo func() {\n\t\t\tvar err error\n\t\t\tif hijackOptions.in != nil {\n\t\t\t\t_, err = io.Copy(rwc, hijackOptions.in)\n\t\t\t}\n\t\t\terrChanIn <- err\n\t\t\trwc.(interface {\n\t\t\t\tCloseWrite() error\n\t\t\t}).CloseWrite()\n\t\t}()\n\n\t\tvar errIn error\n\t\tselect {\n\t\tcase errIn = <-errChanIn:\n\t\tcase <-quit:\n\t\t}\n\n\t\tvar errOut error\n\t\tselect {\n\t\tcase errOut = <-errChanOut:\n\t\tcase <-quit:\n\t\t}\n\n\t\tif errIn != nil {\n\t\t\terrs <- errIn\n\t\t} else {\n\t\t\terrs <- errOut\n\t\t}\n\t}()\n\n\treturn struct {\n\t\tcloserFunc\n\t\twaiterFunc\n\t}{\n\t\tcloserFunc(func() error { close(quit); return nil }),\n\t\twaiterFunc(func() error { return <-errs }),\n\t}, nil\n}\n\nfunc (c *Client) getURL(path string) string {\n\turlStr := strings.TrimRight(c.endpointURL.String(), \"/\")\n\tif c.endpointURL.Scheme == unixProtocol || c.endpointURL.Scheme == namedPipeProtocol {\n\t\turlStr = \"\"\n\t}\n\tif c.requestedAPIVersion != nil {\n\t\treturn fmt.Sprintf(\"%s/v%s%s\", urlStr, c.requestedAPIVersion, path)\n\t}\n\treturn fmt.Sprintf(\"%s%s\", urlStr, path)\n}\n\nfunc (c *Client) getPath(basepath string, opts any) (string, error) {\n\tqueryStr, requiredAPIVersion := queryStringVersion(opts)\n\treturn c.pathVersionCheck(basepath, queryStr, requiredAPIVersion)\n}\n\nfunc (c *Client) pathVersionCheck(basepath, queryStr string, requiredAPIVersion APIVersion) (string, error) {\n\turlStr := strings.TrimRight(c.endpointURL.String(), \"/\")\n\tif c.endpointURL.Scheme == unixProtocol || c.endpointURL.Scheme == namedPipeProtocol {\n\t\turlStr = \"\"\n\t}\n\tif c.requestedAPIVersion != nil {\n\t\tif c.requestedAPIVersion.GreaterThanOrEqualTo(requiredAPIVersion) {\n\t\t\treturn fmt.Sprintf(\"%s/v%s%s?%s\", urlStr, c.requestedAPIVersion, basepath, queryStr), nil\n\t\t}\n\t\treturn \"\", fmt.Errorf(\"API %s requires version %s, requested version %s is insufficient\",\n\t\t\tbasepath, requiredAPIVersion, c.requestedAPIVersion)\n\t}\n\tif requiredAPIVersion != nil {\n\t\treturn fmt.Sprintf(\"%s/v%s%s?%s\", urlStr, requiredAPIVersion, basepath, queryStr), nil\n\t}\n\treturn fmt.Sprintf(\"%s%s?%s\", urlStr, basepath, queryStr), nil\n}\n\n// getFakeNativeURL returns the URL needed to make an HTTP request over a UNIX\n// domain socket to the given path.\nfunc (c *Client) getFakeNativeURL(path string) string {\n\tu := *c.endpointURL // Copy.\n\n\t// Override URL so that net/http will not complain.\n\tu.Scheme = \"http\"\n\tu.Host = \"unix.sock\" // Doesn't matter what this is - it's not used.\n\tu.Path = \"\"\n\turlStr := strings.TrimRight(u.String(), \"/\")\n\tif c.requestedAPIVersion != nil {\n\t\treturn fmt.Sprintf(\"%s/v%s%s\", urlStr, c.requestedAPIVersion, path)\n\t}\n\treturn fmt.Sprintf(\"%s%s\", urlStr, path)\n}\n\nfunc queryStringVersion(opts any) (string, APIVersion) {\n\tif opts == nil {\n\t\treturn \"\", nil\n\t}\n\tvalue := reflect.ValueOf(opts)\n\tif value.Kind() == reflect.Ptr {\n\t\tvalue = value.Elem()\n\t}\n\tif value.Kind() != reflect.Struct {\n\t\treturn \"\", nil\n\t}\n\tvar apiVersion APIVersion\n\titems := url.Values(map[string][]string{})\n\tfor i := 0; i < value.NumField(); i++ {\n\t\tfield := value.Type().Field(i)\n\t\tif field.PkgPath != \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tkey := field.Tag.Get(\"qs\")\n\t\tif key == \"\" {\n\t\t\tkey = strings.ToLower(field.Name)\n\t\t} else if key == \"-\" {\n\t\t\tcontinue\n\t\t}\n\t\tif addQueryStringValue(items, key, value.Field(i)) {\n\t\t\tverstr := field.Tag.Get(\"ver\")\n\t\t\tif verstr != \"\" {\n\t\t\t\tver, _ := NewAPIVersion(verstr)\n\t\t\t\tif apiVersion == nil {\n\t\t\t\t\tapiVersion = ver\n\t\t\t\t} else if ver.GreaterThan(apiVersion) {\n\t\t\t\t\tapiVersion = ver\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items.Encode(), apiVersion\n}\n\nfunc queryString(opts any) string {\n\ts, _ := queryStringVersion(opts)\n\treturn s\n}\n\nfunc addQueryStringValue(items url.Values, key string, v reflect.Value) bool {\n\tswitch v.Kind() {\n\tcase reflect.Bool:\n\t\tif v.Bool() {\n\t\t\titems.Add(key, \"1\")\n\t\t\treturn true\n\t\t}\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tif v.Int() > 0 {\n\t\t\titems.Add(key, strconv.FormatInt(v.Int(), 10))\n\t\t\treturn true\n\t\t}\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tif v.Uint() > 0 {\n\t\t\titems.Add(key, strconv.FormatUint(v.Uint(), 10))\n\t\t\treturn true\n\t\t}\n\tcase reflect.Float32, reflect.Float64:\n\t\tif v.Float() > 0 {\n\t\t\titems.Add(key, strconv.FormatFloat(v.Float(), 'f', -1, 64))\n\t\t\treturn true\n\t\t}\n\tcase reflect.String:\n\t\tif v.String() != \"\" {\n\t\t\titems.Add(key, v.String())\n\t\t\treturn true\n\t\t}\n\tcase reflect.Ptr:\n\t\tif !v.IsNil() {\n\t\t\tif b, err := json.Marshal(v.Interface()); err == nil {\n\t\t\t\titems.Add(key, string(b))\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase reflect.Map:\n\t\tif len(v.MapKeys()) > 0 {\n\t\t\tif b, err := json.Marshal(v.Interface()); err == nil {\n\t\t\t\titems.Add(key, string(b))\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase reflect.Array, reflect.Slice:\n\t\tvLen := v.Len()\n\t\tvar valuesAdded int\n\t\tif vLen > 0 {\n\t\t\tfor i := 0; i < vLen; i++ {\n\t\t\t\tif addQueryStringValue(items, key, v.Index(i)) {\n\t\t\t\t\tvaluesAdded++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn valuesAdded > 0\n\t}\n\treturn false\n}\n\n// Error represents failures in the API. It represents a failure from the API.\ntype Error struct {\n\tStatus  int\n\tMessage string\n}\n\nfunc newError(resp *http.Response) *Error {\n\ttype ErrMsg struct {\n\t\tMessage string `json:\"message\"`\n\t}\n\tdefer resp.Body.Close()\n\tdata, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn &Error{Status: resp.StatusCode, Message: fmt.Sprintf(\"cannot read body, err: %v\", err)}\n\t}\n\tvar emsg ErrMsg\n\terr = json.Unmarshal(data, &emsg)\n\tif err != nil {\n\t\treturn &Error{Status: resp.StatusCode, Message: string(data)}\n\t}\n\treturn &Error{Status: resp.StatusCode, Message: emsg.Message}\n}\n\nfunc (e *Error) Error() string {\n\treturn fmt.Sprintf(\"API error (%d): %s\", e.Status, e.Message)\n}\n\nfunc parseEndpoint(endpoint string, tls bool) (*url.URL, error) {\n\tif endpoint != \"\" && !strings.Contains(endpoint, \"://\") {\n\t\tendpoint = \"tcp://\" + endpoint\n\t}\n\tu, err := url.Parse(endpoint)\n\tif err != nil {\n\t\treturn nil, ErrInvalidEndpoint\n\t}\n\tif tls && u.Scheme != \"unix\" {\n\t\tu.Scheme = \"https\"\n\t}\n\tswitch u.Scheme {\n\tcase unixProtocol, namedPipeProtocol:\n\t\treturn u, nil\n\tcase \"http\", \"https\", \"tcp\":\n\t\t_, port, err := net.SplitHostPort(u.Host)\n\t\tif err != nil {\n\t\t\tvar e *net.AddrError\n\t\t\tif errors.As(err, &e) {\n\t\t\t\tif e.Err == \"missing port in address\" {\n\t\t\t\t\treturn u, nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, ErrInvalidEndpoint\n\t\t}\n\t\tnumber, err := strconv.ParseInt(port, 10, 64)\n\t\tif err == nil && number > 0 && number < 65536 {\n\t\t\tif u.Scheme == \"tcp\" {\n\t\t\t\tif tls {\n\t\t\t\t\tu.Scheme = \"https\"\n\t\t\t\t} else {\n\t\t\t\t\tu.Scheme = \"http\"\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn u, nil\n\t\t}\n\t\treturn nil, ErrInvalidEndpoint\n\tdefault:\n\t\treturn nil, ErrInvalidEndpoint\n\t}\n}\n\ntype dockerEnv struct {\n\tdockerHost      string\n\tdockerTLSVerify bool\n\tdockerCertPath  string\n}\n\nfunc getDockerEnv() (*dockerEnv, error) {\n\tdockerHost := os.Getenv(\"DOCKER_HOST\")\n\tvar err error\n\tif dockerHost == \"\" {\n\t\tdockerHost = defaultHost\n\t}\n\tdockerTLSVerify := os.Getenv(\"DOCKER_TLS_VERIFY\") != \"\"\n\tvar dockerCertPath string\n\tif dockerTLSVerify {\n\t\tdockerCertPath = os.Getenv(\"DOCKER_CERT_PATH\")\n\t\tif dockerCertPath == \"\" {\n\t\t\thome := homedir.Get()\n\t\t\tif home == \"\" {\n\t\t\t\treturn nil, errors.New(\"environment variable HOME must be set if DOCKER_CERT_PATH is not set\")\n\t\t\t}\n\t\t\tdockerCertPath = filepath.Join(home, \".docker\")\n\t\t\tdockerCertPath, err = filepath.Abs(dockerCertPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\treturn &dockerEnv{\n\t\tdockerHost:      dockerHost,\n\t\tdockerTLSVerify: dockerTLSVerify,\n\t\tdockerCertPath:  dockerCertPath,\n\t}, nil\n}\n\n// defaultTransport returns a new http.Transport with similar default values to\n// http.DefaultTransport, but with idle connections and keepalives disabled.\nfunc defaultTransport() *http.Transport {\n\ttransport := defaultPooledTransport()\n\ttransport.DisableKeepAlives = true\n\ttransport.MaxIdleConnsPerHost = -1\n\treturn transport\n}\n\n// defaultPooledTransport returns a new http.Transport with similar default\n// values to http.DefaultTransport. Do not use this for transient transports as\n// it can leak file descriptors over time. Only use this for transports that\n// will be re-used for the same host(s).\nfunc defaultPooledTransport() *http.Transport {\n\ttransport := &http.Transport{\n\t\tProxy: http.ProxyFromEnvironment,\n\t\tDialContext: (&net.Dialer{\n\t\t\tTimeout:   30 * time.Second,\n\t\t\tKeepAlive: 30 * time.Second,\n\t\t}).DialContext,\n\t\tMaxIdleConns:          100,\n\t\tIdleConnTimeout:       90 * time.Second,\n\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\tExpectContinueTimeout: 1 * time.Second,\n\t\tMaxIdleConnsPerHost:   runtime.GOMAXPROCS(0) + 1,\n\t}\n\treturn transport\n}\n\n// defaultClient returns a new http.Client with similar default values to\n// http.Client, but with a non-shared Transport, idle connections disabled, and\n// keepalives disabled.\nfunc defaultClient() *http.Client {\n\treturn &http.Client{\n\t\tTransport: defaultTransport(),\n\t}\n}\n"
        },
        {
          "name": "client_stress_test.go",
          "type": "blob",
          "size": 3.63671875,
          "content": "// Copyright 2017 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build !windows\n\npackage docker\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"reflect\"\n\t\"slices\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestClientDoConcurrentStress(t *testing.T) {\n\tt.Parallel()\n\tvar reqs []*http.Request\n\tvar mu sync.Mutex\n\thandler := http.HandlerFunc(func(_ http.ResponseWriter, r *http.Request) {\n\t\tmu.Lock()\n\t\treqs = append(reqs, r)\n\t\tmu.Unlock()\n\t})\n\tvar nativeSrvs []*httptest.Server\n\tfor i := 0; i < 3; i++ {\n\t\tsrv, cleanup, err := newNativeServer(handler)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer cleanup()\n\t\tnativeSrvs = append(nativeSrvs, srv)\n\t}\n\ttests := []struct {\n\t\ttestCase      string\n\t\tsrv           *httptest.Server\n\t\tscheme        string\n\t\twithTimeout   bool\n\t\twithTLSServer bool\n\t\twithTLSClient bool\n\t}{\n\t\t{testCase: \"http server\", srv: httptest.NewUnstartedServer(handler), scheme: \"http\"},\n\t\t{testCase: \"native server\", srv: nativeSrvs[0], scheme: nativeProtocol},\n\t\t{testCase: \"http with timeout\", srv: httptest.NewUnstartedServer(handler), scheme: \"http\", withTimeout: true},\n\t\t{testCase: \"native with timeout\", srv: nativeSrvs[1], scheme: nativeProtocol, withTimeout: true},\n\t\t{testCase: \"http with tls\", srv: httptest.NewUnstartedServer(handler), scheme: \"https\", withTLSServer: true, withTLSClient: true},\n\t\t{testCase: \"native with client-only tls\", srv: nativeSrvs[2], scheme: nativeProtocol, withTLSServer: false, withTLSClient: nativeProtocol == unixProtocol}, // TLS client only works with unix protocol\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.testCase, func(t *testing.T) {\n\t\t\treqs = nil\n\t\t\tvar client *Client\n\t\t\tvar err error\n\t\t\tendpoint := tt.scheme + \"://\" + tt.srv.Listener.Addr().String()\n\t\t\tif tt.withTLSServer {\n\t\t\t\ttt.srv.StartTLS()\n\t\t\t} else {\n\t\t\t\ttt.srv.Start()\n\t\t\t}\n\t\t\tdefer tt.srv.Close()\n\t\t\tif tt.withTLSClient {\n\t\t\t\tcertPEMBlock, certErr := os.ReadFile(\"testing/data/cert.pem\")\n\t\t\t\tif certErr != nil {\n\t\t\t\t\tt.Fatal(certErr)\n\t\t\t\t}\n\t\t\t\tkeyPEMBlock, certErr := os.ReadFile(\"testing/data/key.pem\")\n\t\t\t\tif certErr != nil {\n\t\t\t\t\tt.Fatal(certErr)\n\t\t\t\t}\n\t\t\t\tclient, err = NewTLSClientFromBytes(endpoint, certPEMBlock, keyPEMBlock, nil)\n\t\t\t} else {\n\t\t\t\tclient, err = NewClient(endpoint)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif tt.withTimeout {\n\t\t\t\tclient.SetTimeout(time.Minute)\n\t\t\t}\n\t\t\tn := 50\n\t\t\twg := sync.WaitGroup{}\n\t\t\tvar paths []string\n\t\t\terrsCh := make(chan error, 3*n)\n\t\t\twaiters := make(chan CloseWaiter, n)\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\tpath := fmt.Sprintf(\"/%05d\", i)\n\t\t\t\tpaths = append(paths, http.MethodGet+path)\n\t\t\t\tpaths = append(paths, http.MethodPost+path)\n\t\t\t\tpaths = append(paths, \"HEAD\"+path)\n\t\t\t\twg.Add(1)\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer wg.Done()\n\t\t\t\t\t_, clientErr := client.do(http.MethodGet, path, doOptions{})\n\t\t\t\t\tif clientErr != nil {\n\t\t\t\t\t\terrsCh <- clientErr\n\t\t\t\t\t}\n\t\t\t\t\tclientErr = client.stream(http.MethodPost, path, streamOptions{})\n\t\t\t\t\tif clientErr != nil {\n\t\t\t\t\t\terrsCh <- clientErr\n\t\t\t\t\t}\n\t\t\t\t\tcw, clientErr := client.hijack(\"HEAD\", path, hijackOptions{})\n\t\t\t\t\tif clientErr != nil {\n\t\t\t\t\t\terrsCh <- clientErr\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaiters <- cw\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\twg.Wait()\n\t\t\tclose(errsCh)\n\t\t\tclose(waiters)\n\t\t\tfor cw := range waiters {\n\t\t\t\tcw.Wait()\n\t\t\t\tcw.Close()\n\t\t\t}\n\t\t\tfor err = range errsCh {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tvar reqPaths []string\n\t\t\tfor _, r := range reqs {\n\t\t\t\treqPaths = append(reqPaths, r.Method+r.URL.Path)\n\t\t\t}\n\t\t\tslices.Sort(paths)\n\t\t\tslices.Sort(reqPaths)\n\t\t\tif !reflect.DeepEqual(reqPaths, paths) {\n\t\t\t\tt.Fatalf(\"expected server request paths to equal %v, got: %v\", paths, reqPaths)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 30.0302734375,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/term\"\n)\n\nfunc TestNewAPIClient(t *testing.T) {\n\tt.Parallel()\n\tendpoint := \"http://localhost:4243\"\n\tclient, err := NewClient(endpoint)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif client.endpoint != endpoint {\n\t\tt.Errorf(\"Expected endpoint %s. Got %s.\", endpoint, client.endpoint)\n\t}\n\t// test native endpoints\n\tendpoint = nativeRealEndpoint\n\tclient, err = NewClient(endpoint)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif client.endpoint != endpoint {\n\t\tt.Errorf(\"Expected endpoint %s. Got %s.\", endpoint, client.endpoint)\n\t}\n\tif !client.SkipServerVersionCheck {\n\t\tt.Error(\"Expected SkipServerVersionCheck to be true, got false\")\n\t}\n\tif client.requestedAPIVersion != nil {\n\t\tt.Errorf(\"Expected requestedAPIVersion to be nil, got %#v.\", client.requestedAPIVersion)\n\t}\n}\n\nfunc newTLSClient(endpoint string) (*Client, error) {\n\treturn NewTLSClient(endpoint,\n\t\t\"testing/data/cert.pem\",\n\t\t\"testing/data/key.pem\",\n\t\t\"testing/data/ca.pem\")\n}\n\nfunc TestNewTSLAPIClient(t *testing.T) {\n\tt.Parallel()\n\tendpoint := \"https://localhost:4243\"\n\tclient, err := newTLSClient(endpoint)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif client.endpoint != endpoint {\n\t\tt.Errorf(\"Expected endpoint %s. Got %s.\", endpoint, client.endpoint)\n\t}\n\tif !client.SkipServerVersionCheck {\n\t\tt.Error(\"Expected SkipServerVersionCheck to be true, got false\")\n\t}\n\tif client.requestedAPIVersion != nil {\n\t\tt.Errorf(\"Expected requestedAPIVersion to be nil, got %#v.\", client.requestedAPIVersion)\n\t}\n}\n\nfunc TestNewVersionedClient(t *testing.T) {\n\tt.Parallel()\n\tendpoint := \"http://localhost:4243\"\n\tclient, err := NewVersionedClient(endpoint, \"1.12\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif client.endpoint != endpoint {\n\t\tt.Errorf(\"Expected endpoint %s. Got %s.\", endpoint, client.endpoint)\n\t}\n\tif reqVersion := client.requestedAPIVersion.String(); reqVersion != \"1.12\" {\n\t\tt.Errorf(\"Wrong requestAPIVersion. Want %q. Got %q.\", \"1.12\", reqVersion)\n\t}\n\tif client.SkipServerVersionCheck {\n\t\tt.Error(\"Expected SkipServerVersionCheck to be false, got true\")\n\t}\n}\n\nfunc TestNewVersionedClientFromEnv(t *testing.T) {\n\tendpoint := \"tcp://localhost:2376\"\n\tendpointURL := \"http://localhost:2376\"\n\tt.Setenv(\"DOCKER_HOST\", endpoint)\n\tt.Setenv(\"DOCKER_TLS_VERIFY\", \"\")\n\tclient, err := NewVersionedClientFromEnv(\"1.12\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif client.endpoint != endpoint {\n\t\tt.Errorf(\"Expected endpoint %q. Got %q.\", endpoint, client.endpoint)\n\t}\n\tif client.endpointURL.String() != endpointURL {\n\t\tt.Errorf(\"Expected endpointURL %q. Got %q.\", endpointURL, client.endpointURL.String())\n\t}\n\tconst expectedReqVersion = \"1.12\"\n\tif reqVersion := client.requestedAPIVersion.String(); reqVersion != expectedReqVersion {\n\t\tt.Errorf(\"Wrong requestAPIVersion. Want %q. Got %q.\", expectedReqVersion, reqVersion)\n\t}\n\tif client.SkipServerVersionCheck {\n\t\tt.Error(\"Expected SkipServerVersionCheck to be false, got true\")\n\t}\n}\n\nfunc TestNewVersionedClientFromEnvTLS(t *testing.T) {\n\tendpoint := \"tcp://localhost:2376\"\n\tendpointURL := \"https://localhost:2376\"\n\tbase, _ := os.Getwd()\n\tt.Setenv(\"DOCKER_CERT_PATH\", filepath.Join(base, \"/testing/data/\"))\n\tt.Setenv(\"DOCKER_HOST\", endpoint)\n\tt.Setenv(\"DOCKER_TLS_VERIFY\", \"1\")\n\tclient, err := NewVersionedClientFromEnv(\"1.12\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif client.endpoint != endpoint {\n\t\tt.Errorf(\"Expected endpoint %s. Got %s.\", endpoint, client.endpoint)\n\t}\n\tif client.endpointURL.String() != endpointURL {\n\t\tt.Errorf(\"Expected endpointURL %s. Got %s.\", endpoint, client.endpoint)\n\t}\n\tif reqVersion := client.requestedAPIVersion.String(); reqVersion != \"1.12\" {\n\t\tt.Errorf(\"Wrong requestAPIVersion. Want %q. Got %q.\", \"1.12\", reqVersion)\n\t}\n\tif client.SkipServerVersionCheck {\n\t\tt.Error(\"Expected SkipServerVersionCheck to be false, got true\")\n\t}\n}\n\nfunc TestNewTLSVersionedClient(t *testing.T) {\n\tt.Parallel()\n\tcertPath := \"testing/data/cert.pem\"\n\tkeyPath := \"testing/data/key.pem\"\n\tcaPath := \"testing/data/ca.pem\"\n\tendpoint := \"https://localhost:4243\"\n\tclient, err := NewVersionedTLSClient(endpoint, certPath, keyPath, caPath, \"1.14\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif client.endpoint != endpoint {\n\t\tt.Errorf(\"Expected endpoint %s. Got %s.\", endpoint, client.endpoint)\n\t}\n\tif reqVersion := client.requestedAPIVersion.String(); reqVersion != \"1.14\" {\n\t\tt.Errorf(\"Wrong requestAPIVersion. Want %q. Got %q.\", \"1.14\", reqVersion)\n\t}\n\tif client.SkipServerVersionCheck {\n\t\tt.Error(\"Expected SkipServerVersionCheck to be false, got true\")\n\t}\n}\n\nfunc TestNewTLSVersionedClientNoClientCert(t *testing.T) {\n\tt.Parallel()\n\tcertPath := \"testing/data/cert_doesnotexist.pem\"\n\tkeyPath := \"testing/data/key_doesnotexist.pem\"\n\tcaPath := \"testing/data/ca.pem\"\n\tendpoint := \"https://localhost:4243\"\n\tclient, err := NewVersionedTLSClient(endpoint, certPath, keyPath, caPath, \"1.14\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif client.endpoint != endpoint {\n\t\tt.Errorf(\"Expected endpoint %s. Got %s.\", endpoint, client.endpoint)\n\t}\n\tif reqVersion := client.requestedAPIVersion.String(); reqVersion != \"1.14\" {\n\t\tt.Errorf(\"Wrong requestAPIVersion. Want %q. Got %q.\", \"1.14\", reqVersion)\n\t}\n\tif client.SkipServerVersionCheck {\n\t\tt.Error(\"Expected SkipServerVersionCheck to be false, got true\")\n\t}\n}\n\nfunc TestNewTLSVersionedClientInvalidCA(t *testing.T) {\n\tt.Parallel()\n\tcertPath := \"testing/data/cert.pem\"\n\tkeyPath := \"testing/data/key.pem\"\n\tcaPath := \"testing/data/key.pem\"\n\tendpoint := \"https://localhost:4243\"\n\t_, err := NewVersionedTLSClient(endpoint, certPath, keyPath, caPath, \"1.14\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected invalid ca at %s\", caPath)\n\t}\n}\n\nfunc TestNewTLSVersionedClientInvalidCANoClientCert(t *testing.T) {\n\tt.Parallel()\n\tcertPath := \"testing/data/cert_doesnotexist.pem\"\n\tkeyPath := \"testing/data/key_doesnotexist.pem\"\n\tcaPath := \"testing/data/key.pem\"\n\tendpoint := \"https://localhost:4243\"\n\t_, err := NewVersionedTLSClient(endpoint, certPath, keyPath, caPath, \"1.14\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected invalid ca at %s\", caPath)\n\t}\n}\n\nfunc TestNewClientInvalidEndpoint(t *testing.T) {\n\tt.Parallel()\n\tcases := []string{\n\t\t\"htp://localhost:3243\", \"http://localhost:a\",\n\t\t\"\", \"http://localhost:8080:8383\", \"http://localhost:65536\",\n\t\t\"https://localhost:-20\",\n\t}\n\tfor _, c := range cases {\n\t\ttestCase := c\n\t\tt.Run(testCase, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tclient, err := NewClient(testCase)\n\t\t\tif client != nil {\n\t\t\t\tt.Errorf(\"Want <nil> client for invalid endpoint, got %#v.\", client)\n\t\t\t}\n\t\t\tif !errors.Is(err, ErrInvalidEndpoint) {\n\t\t\t\tt.Errorf(\"NewClient(%q): Got invalid error for invalid endpoint. Want %#v. Got %#v.\", testCase, ErrInvalidEndpoint, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewClientNoSchemeEndpoint(t *testing.T) {\n\tt.Parallel()\n\tcases := []string{\"localhost\", \"localhost:8080\"}\n\tfor _, c := range cases {\n\t\ttestCase := c\n\t\tt.Run(testCase, func(t *testing.T) {\n\t\t\tclient, err := NewClient(testCase)\n\t\t\tif client == nil {\n\t\t\t\tt.Errorf(\"Want client for scheme-less endpoint, got <nil>\")\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Got unexpected error scheme-less endpoint: %q\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewTLSClient(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tendpoint string\n\t\texpected string\n\t}{\n\t\t{\"tcp://localhost:2376\", \"https\"},\n\t\t{\"tcp://localhost:2375\", \"https\"},\n\t\t{\"tcp://localhost:4000\", \"https\"},\n\t\t{\"http://localhost:4000\", \"https\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.endpoint, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tclient, err := newTLSClient(test.endpoint)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tgot := client.endpointURL.Scheme\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"endpointURL.Scheme: Got %s. Want %s.\", got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEndpoint(t *testing.T) {\n\tt.Parallel()\n\tclient, err := NewVersionedClient(\"http://localhost:4243\", \"1.12\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif endpoint := client.Endpoint(); endpoint != client.endpoint {\n\t\tt.Errorf(\"Client.Endpoint(): want %q. Got %q\", client.endpoint, endpoint)\n\t}\n}\n\nfunc TestGetURL(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tendpoint string\n\t\tpath     string\n\t\texpected string\n\t}{\n\t\t{\"http://localhost:4243/\", \"/\", \"http://localhost:4243/\"},\n\t\t{\"http://localhost:4243\", \"/\", \"http://localhost:4243/\"},\n\t\t{\"http://localhost:4243\", \"/containers/ps\", \"http://localhost:4243/containers/ps\"},\n\t\t{\"tcp://localhost:4243\", \"/containers/ps\", \"http://localhost:4243/containers/ps\"},\n\t\t{\"http://localhost:4243/////\", \"/\", \"http://localhost:4243/\"},\n\t\t{nativeRealEndpoint, \"/containers\", \"/containers\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.endpoint+test.path, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tclient, _ := NewClient(test.endpoint)\n\t\t\tclient.endpoint = test.endpoint\n\t\t\tclient.SkipServerVersionCheck = true\n\t\t\tgot := client.getURL(test.path)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"getURL(%q): Got %s. Want %s.\", test.path, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetFakeNativeURL(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tendpoint string\n\t\tpath     string\n\t\texpected string\n\t}{\n\t\t{nativeRealEndpoint, \"/\", \"http://unix.sock/\"},\n\t\t{nativeRealEndpoint, \"/\", \"http://unix.sock/\"},\n\t\t{nativeRealEndpoint, \"/containers/ps\", \"http://unix.sock/containers/ps\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.path, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tclient, _ := NewClient(test.endpoint)\n\t\t\tclient.endpoint = test.endpoint\n\t\t\tclient.SkipServerVersionCheck = true\n\t\t\tgot := client.getFakeNativeURL(test.path)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"getURL(%q): Got %s. Want %s.\", test.path, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestError(t *testing.T) {\n\tt.Parallel()\n\tfakeBody := io.NopCloser(bytes.NewBufferString(\"bad parameter\"))\n\tresp := &http.Response{\n\t\tStatusCode: 400,\n\t\tBody:       fakeBody,\n\t}\n\terr := newError(resp)\n\texpected := Error{Status: 400, Message: \"bad parameter\"}\n\tif !reflect.DeepEqual(expected, *err) {\n\t\tt.Errorf(\"Wrong error type. Want %#v. Got %#v.\", expected, *err)\n\t}\n\tmessage := \"API error (400): bad parameter\"\n\tif err.Error() != message {\n\t\tt.Errorf(\"Wrong error message. Want %q. Got %q.\", message, err.Error())\n\t}\n}\n\nfunc TestQueryString(t *testing.T) {\n\tt.Parallel()\n\tv := float32(2.4)\n\tf32QueryString := fmt.Sprintf(\"w=%s&x=10&y=10.35\", strconv.FormatFloat(float64(v), 'f', -1, 64))\n\tjsonPerson := url.QueryEscape(`{\"Name\":\"gopher\",\"age\":4}`)\n\ttests := []struct {\n\t\tinput   any\n\t\twant    string\n\t\twantAPI APIVersion\n\t}{\n\t\t{&ListContainersOptions{All: true}, \"all=1\", nil},\n\t\t{ListContainersOptions{All: true}, \"all=1\", nil},\n\t\t{ListContainersOptions{Before: \"something\"}, \"before=something\", nil},\n\t\t{ListContainersOptions{Before: \"something\", Since: \"other\"}, \"before=something&since=other\", nil},\n\t\t{ListContainersOptions{Filters: map[string][]string{\"status\": {\"paused\", \"running\"}}}, \"filters=%7B%22status%22%3A%5B%22paused%22%2C%22running%22%5D%7D\", nil},\n\t\t{dumb{X: 10, Y: 10.35000}, \"x=10&y=10.35\", apiVersion119},\n\t\t{dumb{W: v, X: 10, Y: 10.35000}, f32QueryString, apiVersion124},\n\t\t{dumb{X: 10, Y: 10.35000, Z: 10}, \"x=10&y=10.35&zee=10\", apiVersion119},\n\t\t{dumb{v: 4, X: 10, Y: 10.35000}, \"x=10&y=10.35\", apiVersion119},\n\t\t{dumb{T: 10, Y: 10.35000}, \"y=10.35\", nil},\n\t\t{dumb{Person: &person{Name: \"gopher\", Age: 4}}, \"p=\" + jsonPerson, nil},\n\t\t{nil, \"\", nil},\n\t\t{10, \"\", nil},\n\t\t{\"not_a_struct\", \"\", nil},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tgot := queryString(test.input)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"queryString(%v). Want %q. Got %q.\", test.input, test.want, got)\n\t\t\t}\n\t\t\tgotstring, gotAPI := queryStringVersion(test.input)\n\t\t\tif gotstring != test.want {\n\t\t\t\tt.Errorf(\"queryStringVersion(%v). Want %q. Got %q.\", test.input, test.want, gotstring)\n\t\t\t}\n\t\t\tif gotAPI.compare(test.wantAPI) != 0 {\n\t\t\t\tt.Errorf(\"queryStringVersion(%v). Want API %q. Got API %q.\", test.input, test.wantAPI, gotAPI)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAPIVersions(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\ta                              string\n\t\tb                              string\n\t\texpectedALessThanB             bool\n\t\texpectedALessThanOrEqualToB    bool\n\t\texpectedAGreaterThanB          bool\n\t\texpectedAGreaterThanOrEqualToB bool\n\t}{\n\t\t{\"1.11\", \"1.11\", false, true, false, true},\n\t\t{\"1.10\", \"1.11\", true, true, false, false},\n\t\t{\"1.11\", \"1.10\", false, false, true, true},\n\n\t\t{\"1.11-ubuntu0\", \"1.11\", false, true, false, true},\n\t\t{\"1.10\", \"1.11-el7\", true, true, false, false},\n\n\t\t{\"1.9\", \"1.11\", true, true, false, false},\n\t\t{\"1.11\", \"1.9\", false, false, true, true},\n\n\t\t{\"1.1.1\", \"1.1\", false, false, true, true},\n\t\t{\"1.1\", \"1.1.1\", true, true, false, false},\n\n\t\t{\"2.1\", \"1.1.1\", false, false, true, true},\n\t\t{\"2.1\", \"1.3.1\", false, false, true, true},\n\t\t{\"1.1.1\", \"2.1\", true, true, false, false},\n\t\t{\"1.3.1\", \"2.1\", true, true, false, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.a+test.b, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ta, _ := NewAPIVersion(test.a)\n\t\t\tb, _ := NewAPIVersion(test.b)\n\n\t\t\tif test.expectedALessThanB && !a.LessThan(b) {\n\t\t\t\tt.Errorf(\"Expected %#v < %#v\", a, b)\n\t\t\t}\n\t\t\tif test.expectedALessThanOrEqualToB && !a.LessThanOrEqualTo(b) {\n\t\t\t\tt.Errorf(\"Expected %#v <= %#v\", a, b)\n\t\t\t}\n\t\t\tif test.expectedAGreaterThanB && !a.GreaterThan(b) {\n\t\t\t\tt.Errorf(\"Expected %#v > %#v\", a, b)\n\t\t\t}\n\t\t\tif test.expectedAGreaterThanOrEqualToB && !a.GreaterThanOrEqualTo(b) {\n\t\t\t\tt.Errorf(\"Expected %#v >= %#v\", a, b)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPing(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\terr := client.Ping()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestPingFailing(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusInternalServerError}\n\tclient := newTestClient(fakeRT)\n\terr := client.Ping()\n\tif err == nil {\n\t\tt.Fatal(\"Expected non nil error, got nil\")\n\t}\n\texpectedErrMsg := \"API error (500): \"\n\tif err.Error() != expectedErrMsg {\n\t\tt.Fatalf(\"Expected error to be %q, got: %q\", expectedErrMsg, err.Error())\n\t}\n}\n\nfunc TestPingFailingWrongStatus(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusAccepted}\n\tclient := newTestClient(fakeRT)\n\terr := client.Ping()\n\tif err == nil {\n\t\tt.Fatal(\"Expected non nil error, got nil\")\n\t}\n\texpectedErrMsg := \"API error (202): \"\n\tif err.Error() != expectedErrMsg {\n\t\tt.Fatalf(\"Expected error to be %q, got: %q\", expectedErrMsg, err.Error())\n\t}\n}\n\nfunc TestPingErrorWithNativeClient(t *testing.T) {\n\tt.Parallel()\n\tsrv, cleanup, err := newNativeServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(\"aaaaaaaaaaa-invalid-aaaaaaaaaaa\"))\n\t}))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer cleanup()\n\tsrv.Start()\n\tdefer srv.Close()\n\tendpoint := nativeBadEndpoint\n\tclient, err := NewClient(endpoint)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = client.Ping()\n\tif err == nil {\n\t\tt.Fatal(\"Expected non nil error, got nil\")\n\t}\n}\n\nfunc TestClientStreamTimeoutNotHit(t *testing.T) {\n\tt.Parallel()\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Fprintf(w, \"%d\\n\", i)\n\t\t\tif f, ok := w.(http.Flusher); ok {\n\t\t\t\tf.Flush()\n\t\t\t}\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}))\n\tdefer srv.Close()\n\tclient, err := NewClient(srv.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar w bytes.Buffer\n\terr = client.stream(http.MethodPost, \"/image/create\", streamOptions{\n\t\tsetRawTerminal:    true,\n\t\tstdout:            &w,\n\t\tinactivityTimeout: 300 * time.Millisecond,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"0\\n1\\n2\\n3\\n4\\n\"\n\tresult := w.String()\n\tif result != expected {\n\t\tt.Fatalf(\"expected stream result %q, got: %q\", expected, result)\n\t}\n}\n\nfunc TestClientStreamInactivityTimeout(t *testing.T) {\n\tt.Parallel()\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Fprintf(w, \"%d\\n\", i)\n\t\t\tif f, ok := w.(http.Flusher); ok {\n\t\t\t\tf.Flush()\n\t\t\t}\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\t}))\n\tdefer srv.Close()\n\tclient, err := NewClient(srv.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar w bytes.Buffer\n\terr = client.stream(http.MethodPost, \"/image/create\", streamOptions{\n\t\tsetRawTerminal:    true,\n\t\tstdout:            &w,\n\t\tinactivityTimeout: 100 * time.Millisecond,\n\t})\n\tif !errors.Is(err, ErrInactivityTimeout) {\n\t\tt.Fatalf(\"expected request canceled error, got: %s\", err)\n\t}\n\texpected := \"0\\n\"\n\tresult := w.String()\n\tif result != expected {\n\t\tt.Fatalf(\"expected stream result %q, got: %q\", expected, result)\n\t}\n}\n\nfunc TestClientStreamContextDeadline(t *testing.T) {\n\tt.Parallel()\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tfmt.Fprint(w, \"abc\\n\")\n\t\tif f, ok := w.(http.Flusher); ok {\n\t\t\tf.Flush()\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Fprint(w, \"def\\n\")\n\t\tif f, ok := w.(http.Flusher); ok {\n\t\t\tf.Flush()\n\t\t}\n\t}))\n\tdefer srv.Close()\n\tclient, err := NewClient(srv.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar w bytes.Buffer\n\tctx, cancel := context.WithTimeout(context.Background(), 400*time.Millisecond)\n\tdefer cancel()\n\terr = client.stream(http.MethodPost, \"/image/create\", streamOptions{\n\t\tsetRawTerminal: true,\n\t\tstdout:         &w,\n\t\tcontext:        ctx,\n\t})\n\tif !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Fatalf(\"expected %s, got: %s\", context.DeadlineExceeded, err)\n\t}\n\texpected := \"abc\\n\"\n\tresult := w.String()\n\tif result != expected {\n\t\tt.Fatalf(\"expected stream result %q, got: %q\", expected, result)\n\t}\n}\n\nfunc TestClientStreamContextCancel(t *testing.T) {\n\tt.Parallel()\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tfmt.Fprint(w, \"abc\\n\")\n\t\tif f, ok := w.(http.Flusher); ok {\n\t\t\tf.Flush()\n\t\t}\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\tfmt.Fprint(w, \"def\\n\")\n\t\tif f, ok := w.(http.Flusher); ok {\n\t\t\tf.Flush()\n\t\t}\n\t}))\n\tdefer srv.Close()\n\tclient, err := NewClient(srv.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar w bytes.Buffer\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\ttime.Sleep(200 * time.Millisecond)\n\t\tcancel()\n\t}()\n\terr = client.stream(http.MethodPost, \"/image/create\", streamOptions{\n\t\tsetRawTerminal: true,\n\t\tstdout:         &w,\n\t\tcontext:        ctx,\n\t})\n\tif !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"expected %s, got: %s\", context.Canceled, err)\n\t}\n\texpected := \"abc\\n\"\n\tresult := w.String()\n\tif result != expected {\n\t\tt.Fatalf(\"expected stream result %q, got: %q\", expected, result)\n\t}\n}\n\nvar mockPullOutput = `{\"status\":\"Pulling from tsuru/static\",\"id\":\"latest\"}\n{\"status\":\"Already exists\",\"progressDetail\":{},\"id\":\"a6aa3b66376f\"}\n{\"status\":\"Pulling fs layer\",\"progressDetail\":{},\"id\":\"106572778bf7\"}\n{\"status\":\"Pulling fs layer\",\"progressDetail\":{},\"id\":\"bac681833e51\"}\n{\"status\":\"Pulling fs layer\",\"progressDetail\":{},\"id\":\"7302e23ef08a\"}\n{\"status\":\"Downloading\",\"progressDetail\":{\"current\":621,\"total\":621},\"progress\":\"[==================================================\\u003e]    621 B/621 B\",\"id\":\"bac681833e51\"}\n{\"status\":\"Verifying Checksum\",\"progressDetail\":{},\"id\":\"bac681833e51\"}\n{\"status\":\"Download complete\",\"progressDetail\":{},\"id\":\"bac681833e51\"}\n{\"status\":\"Downloading\",\"progressDetail\":{\"current\":1854,\"total\":1854},\"progress\":\"[==================================================\\u003e] 1.854 kB/1.854 kB\",\"id\":\"106572778bf7\"}\n{\"status\":\"Verifying Checksum\",\"progressDetail\":{},\"id\":\"106572778bf7\"}\n{\"status\":\"Download complete\",\"progressDetail\":{},\"id\":\"106572778bf7\"}\n{\"status\":\"Extracting\",\"progressDetail\":{\"current\":1854,\"total\":1854},\"progress\":\"[==================================================\\u003e] 1.854 kB/1.854 kB\",\"id\":\"106572778bf7\"}\n{\"status\":\"Extracting\",\"progressDetail\":{\"current\":1854,\"total\":1854},\"progress\":\"[==================================================\\u003e] 1.854 kB/1.854 kB\",\"id\":\"106572778bf7\"}\n{\"status\":\"Downloading\",\"progressDetail\":{\"current\":233019,\"total\":21059403},\"progress\":\"[\\u003e                                                  ]   233 kB/21.06 MB\",\"id\":\"7302e23ef08a\"}\n{\"status\":\"Downloading\",\"progressDetail\":{\"current\":462395,\"total\":21059403},\"progress\":\"[=\\u003e                                                 ] 462.4 kB/21.06 MB\",\"id\":\"7302e23ef08a\"}\n{\"status\":\"Downloading\",\"progressDetail\":{\"current\":8490555,\"total\":21059403},\"progress\":\"[====================\\u003e                              ] 8.491 MB/21.06 MB\",\"id\":\"7302e23ef08a\"}\n{\"status\":\"Downloading\",\"progressDetail\":{\"current\":20876859,\"total\":21059403},\"progress\":\"[=================================================\\u003e ] 20.88 MB/21.06 MB\",\"id\":\"7302e23ef08a\"}\n{\"status\":\"Verifying Checksum\",\"progressDetail\":{},\"id\":\"7302e23ef08a\"}\n{\"status\":\"Download complete\",\"progressDetail\":{},\"id\":\"7302e23ef08a\"}\n{\"status\":\"Pull complete\",\"progressDetail\":{},\"id\":\"106572778bf7\"}\n{\"status\":\"Extracting\",\"progressDetail\":{\"current\":621,\"total\":621},\"progress\":\"[==================================================\\u003e]    621 B/621 B\",\"id\":\"bac681833e51\"}\n{\"status\":\"Extracting\",\"progressDetail\":{\"current\":621,\"total\":621},\"progress\":\"[==================================================\\u003e]    621 B/621 B\",\"id\":\"bac681833e51\"}\n{\"status\":\"Pull complete\",\"progressDetail\":{},\"id\":\"bac681833e51\"}\n{\"status\":\"Extracting\",\"progressDetail\":{\"current\":229376,\"total\":21059403},\"progress\":\"[\\u003e                                                  ] 229.4 kB/21.06 MB\",\"id\":\"7302e23ef08a\"}\n{\"status\":\"Extracting\",\"progressDetail\":{\"current\":458752,\"total\":21059403},\"progress\":\"[=\\u003e                                                 ] 458.8 kB/21.06 MB\",\"id\":\"7302e23ef08a\"}\n{\"status\":\"Extracting\",\"progressDetail\":{\"current\":11239424,\"total\":21059403},\"progress\":\"[==========================\\u003e                        ] 11.24 MB/21.06 MB\",\"id\":\"7302e23ef08a\"}\n{\"status\":\"Extracting\",\"progressDetail\":{\"current\":21059403,\"total\":21059403},\"progress\":\"[==================================================\\u003e] 21.06 MB/21.06 MB\",\"id\":\"7302e23ef08a\"}\n{\"status\":\"Pull complete\",\"progressDetail\":{},\"id\":\"7302e23ef08a\"}\n{\"status\":\"Digest: sha256:b754472891aa7e33fc0214e3efa988174f2c2289285fcae868b7ec8b6675fc77\"}\n{\"status\":\"Status: Downloaded newer image for 192.168.50.4:5000/tsuru/static\"}\n`\n\nfunc TestClientStreamJSONDecode(t *testing.T) {\n\tt.Parallel()\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(mockPullOutput))\n\t}))\n\tdefer srv.Close()\n\tclient, err := NewClient(srv.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar w bytes.Buffer\n\terr = client.stream(http.MethodPost, \"/image/create\", streamOptions{\n\t\tstdout:         &w,\n\t\tuseJSONDecoder: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := `latest: Pulling from tsuru/static\na6aa3b66376f: Already exists\n106572778bf7: Pulling fs layer\nbac681833e51: Pulling fs layer\n7302e23ef08a: Pulling fs layer\nbac681833e51: Verifying Checksum\nbac681833e51: Download complete\n106572778bf7: Verifying Checksum\n106572778bf7: Download complete\n7302e23ef08a: Verifying Checksum\n7302e23ef08a: Download complete\n106572778bf7: Pull complete\nbac681833e51: Pull complete\n7302e23ef08a: Pull complete\nDigest: sha256:b754472891aa7e33fc0214e3efa988174f2c2289285fcae868b7ec8b6675fc77\nStatus: Downloaded newer image for 192.168.50.4:5000/tsuru/static\n`\n\tresult := w.String()\n\tif result != expected {\n\t\tt.Fatalf(\"expected stream result %q, got: %q\", expected, result)\n\t}\n}\n\ntype terminalBuffer struct {\n\tbytes.Buffer\n}\n\nfunc (b *terminalBuffer) FD() uintptr {\n\treturn os.Stdout.Fd()\n}\n\nfunc (b *terminalBuffer) IsTerminal() bool {\n\treturn true\n}\n\nfunc TestClientStreamJSONDecodeWithTerminal(t *testing.T) {\n\tif !term.IsTerminal(int(os.Stdout.Fd())) {\n\t\tt.Skip(\"requires a terminal\")\n\t}\n\tt.Parallel()\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(mockPullOutput))\n\t}))\n\tdefer srv.Close()\n\tclient, err := NewClient(srv.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar w terminalBuffer\n\terr = client.stream(http.MethodPost, \"/image/create\", streamOptions{\n\t\tstdout:         &w,\n\t\tuseJSONDecoder: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconst expected = \"latest: Pulling from tsuru/static\\n\\n\" +\n\t\t\"\\x1b[1A\\x1b[2K\\ra6aa3b66376f: Already exists \\r\\x1b[1B\\n\" +\n\t\t\"\\x1b[1A\\x1b[2K\\r106572778bf7: Pulling fs layer \\r\\x1b[1B\\n\" +\n\t\t\"\\x1b[1A\\x1b[2K\\rbac681833e51: Pulling fs layer \\r\\x1b[1B\\n\" +\n\t\t\"\\x1b[1A\\x1b[2K\\r7302e23ef08a: Pulling fs layer \\r\\x1b[1B\\x1b[2A\\x1b[2K\\rbac681833e51: Downloading [==================================================>]     621B/621B\\r\\x1b[2B\\x1b[2A\\x1b[2K\\rbac681833e51: Verifying Checksum \\r\\x1b[2B\\x1b[2A\\x1b[2K\\rbac681833e51: Download complete \\r\\x1b[2B\\x1b[3A\\x1b[2K\\r106572778bf7: Downloading [==================================================>]  1.854kB/1.854kB\\r\\x1b[3B\\x1b[3A\\x1b[2K\\r106572778bf7: Verifying Checksum \\r\\x1b[3B\\x1b[3A\\x1b[2K\\r106572778bf7: Download complete \\r\\x1b[3B\\x1b[3A\\x1b[2K\\r106572778bf7: Extracting [==================================================>]  1.854kB/1.854kB\\r\\x1b[3B\\x1b[3A\\x1b[2K\\r106572778bf7: Extracting [==================================================>]  1.854kB/1.854kB\\r\\x1b[3B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Downloading [>                                                  ]    233kB/21.06MB\\r\\x1b[1B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Downloading [=>                                                 ]  462.4kB/21.06MB\\r\\x1b[1B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Downloading [====================>                              ]  8.491MB/21.06MB\\r\\x1b[1B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Downloading [=================================================> ]  20.88MB/21.06MB\\r\\x1b[1B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Verifying Checksum \\r\\x1b[1B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Download complete \\r\\x1b[1B\\x1b[3A\\x1b[2K\\r106572778bf7: Pull complete \\r\\x1b[3B\\x1b[2A\\x1b[2K\\rbac681833e51: Extracting [==================================================>]     621B/621B\\r\\x1b[2B\\x1b[2A\\x1b[2K\\rbac681833e51: Extracting [==================================================>]     621B/621B\\r\\x1b[2B\\x1b[2A\\x1b[2K\\rbac681833e51: Pull complete \\r\\x1b[2B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Extracting [>                                                  ]  229.4kB/21.06MB\\r\\x1b[1B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Extracting [=>                                                 ]  458.8kB/21.06MB\\r\\x1b[1B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Extracting [==========================>                        ]  11.24MB/21.06MB\\r\\x1b[1B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Extracting [==================================================>]  21.06MB/21.06MB\\r\\x1b[1B\\x1b[1A\\x1b[2K\\r7302e23ef08a: Pull complete \\r\\x1b[1BDigest: sha256:b754472891aa7e33fc0214e3efa988174f2c2289285fcae868b7ec8b6675fc77\\n\" +\n\t\t\"Status: Downloaded newer image for 192.168.50.4:5000/tsuru/static\\n\"\n\tresult := w.String()\n\tif result != expected {\n\t\tt.Fatalf(\"wrong stream result\\nwant %q\\ngot:  %q\", expected, result)\n\t}\n}\n\nfunc TestClientDoContextDeadline(t *testing.T) {\n\tt.Parallel()\n\tsrv := httptest.NewServer(http.HandlerFunc(func(http.ResponseWriter, *http.Request) {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}))\n\tdefer srv.Close()\n\tclient, err := NewClient(srv.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\t_, err = client.do(http.MethodPost, \"/image/create\", doOptions{\n\t\tcontext: ctx,\n\t})\n\tif !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Fatalf(\"expected %s, got: %s\", context.DeadlineExceeded, err)\n\t}\n}\n\nfunc TestClientDoContextCancel(t *testing.T) {\n\tt.Parallel()\n\tsrv := httptest.NewServer(http.HandlerFunc(func(http.ResponseWriter, *http.Request) {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}))\n\tdefer srv.Close()\n\tclient, err := NewClient(srv.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tcancel()\n\t}()\n\t_, err = client.do(http.MethodPost, \"/image/create\", doOptions{\n\t\tcontext: ctx,\n\t})\n\tif !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"expected %s, got: %s\", context.Canceled, err)\n\t}\n}\n\nfunc TestClientStreamTimeoutNativeClient(t *testing.T) {\n\tt.Parallel()\n\tsrv, cleanup, err := newNativeServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tfmt.Fprintf(w, \"%d\\n\", i)\n\t\t\tif f, ok := w.(http.Flusher); ok {\n\t\t\t\tf.Flush()\n\t\t\t}\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\t}))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer cleanup()\n\tsrv.Start()\n\tdefer srv.Close()\n\tclient, err := NewClient(nativeProtocol + \"://\" + srv.Listener.Addr().String())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar w bytes.Buffer\n\terr = client.stream(http.MethodPost, \"/image/create\", streamOptions{\n\t\tsetRawTerminal:    true,\n\t\tstdout:            &w,\n\t\tinactivityTimeout: 50 * time.Millisecond,\n\t})\n\tif !errors.Is(err, ErrInactivityTimeout) {\n\t\tt.Fatalf(\"expected request canceled error, got: %s\", err)\n\t}\n\texpected := \"0\\n\"\n\tresult := w.String()\n\tif result != expected {\n\t\tt.Fatalf(\"expected stream result %q, got: %q\", expected, result)\n\t}\n}\n\nfunc TestClientStreamJSONDecoderEOFOutputWriter(t *testing.T) {\n\tt.Parallel()\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tfmt.Fprint(w, \"{}\")\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}))\n\tdefer srv.Close()\n\tclient, err := NewClient(srv.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar w eofWriter\n\terr = client.stream(http.MethodPost, \"/image/create\", streamOptions{\n\t\tsetRawTerminal: true,\n\t\tuseJSONDecoder: true,\n\t\tstdout:         &w,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\ntype eofWriter struct{}\n\nfunc (w eofWriter) Write(b []byte) (int, error) { return len(b), io.EOF }\n\ntype FakeRoundTripper struct {\n\tmessage  string\n\tstatus   int\n\theader   map[string]string\n\trequests []*http.Request\n}\n\nfunc (rt *FakeRoundTripper) RoundTrip(r *http.Request) (*http.Response, error) {\n\tbody := strings.NewReader(rt.message)\n\trt.requests = append(rt.requests, r)\n\tres := &http.Response{\n\t\tStatusCode: rt.status,\n\t\tBody:       io.NopCloser(body),\n\t\tHeader:     make(http.Header),\n\t}\n\tfor k, v := range rt.header {\n\t\tres.Header.Set(k, v)\n\t}\n\treturn res, nil\n}\n\nfunc (rt *FakeRoundTripper) Reset() {\n\trt.requests = nil\n}\n\ntype person struct {\n\tName string\n\tAge  int `json:\"age\"`\n}\n\ntype dumb struct {\n\tT      int `qs:\"-\"`\n\tv      int\n\tW      float32 `ver:\"1.24\"`\n\tX      int     `ver:\"1.19\"`\n\tY      float64\n\tZ      int     `qs:\"zee\"`\n\tPerson *person `qs:\"p\"`\n}\n"
        },
        {
          "name": "client_unix.go",
          "type": "blob",
          "size": 0.7490234375,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build !windows\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n)\n\nconst defaultHost = \"unix:///var/run/docker.sock\"\n\n// initializeNativeClient initializes the native Unix domain socket client on\n// Unix-style operating systems\nfunc (c *Client) initializeNativeClient(trFunc func() *http.Transport) {\n\tif c.endpointURL.Scheme != unixProtocol {\n\t\treturn\n\t}\n\tsockPath := c.endpointURL.Path\n\n\ttr := trFunc()\n\ttr.Proxy = nil\n\ttr.DialContext = func(_ context.Context, network, addr string) (net.Conn, error) {\n\t\treturn c.Dialer.Dial(unixProtocol, sockPath)\n\t}\n\tc.HTTPClient.Transport = tr\n}\n"
        },
        {
          "name": "client_unix_test.go",
          "type": "blob",
          "size": 1.6279296875,
          "content": "//go:build !windows\n\n// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nconst (\n\tnativeProtocol     = unixProtocol\n\tnativeRealEndpoint = \"unix:///var/run/docker.sock\"\n\tnativeBadEndpoint  = \"unix:///tmp/echo.sock\"\n)\n\nfunc TestNewTSLAPIClientUnixEndpoint(t *testing.T) {\n\tt.Parallel()\n\tsrv, cleanup, err := newNativeServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(\"ok\"))\n\t}))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer cleanup()\n\tsrv.Start()\n\tdefer srv.Close()\n\tendpoint := nativeProtocol + \"://\" + srv.Listener.Addr().String()\n\tclient, err := newTLSClient(endpoint)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif client.endpoint != endpoint {\n\t\tt.Errorf(\"Expected endpoint %s. Got %s.\", endpoint, client.endpoint)\n\t}\n\trsp, err := client.do(http.MethodGet, \"/\", doOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdata, err := io.ReadAll(rsp.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(data) != \"ok\" {\n\t\tt.Fatalf(\"Expected response to be %q, got: %q\", \"ok\", string(data))\n\t}\n}\n\nfunc newNativeServer(handler http.Handler) (*httptest.Server, func(), error) {\n\ttmpdir, err := os.MkdirTemp(\"\", \"socket\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tsocketPath := filepath.Join(tmpdir, \"docker_test_stress.sock\")\n\tl, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tsrv := httptest.NewUnstartedServer(handler)\n\tsrv.Listener = l\n\treturn srv, func() { os.RemoveAll(tmpdir) }, nil\n}\n"
        },
        {
          "name": "client_windows.go",
          "type": "blob",
          "size": 1.1650390625,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\twinio \"github.com/Microsoft/go-winio\"\n)\n\nconst (\n\tdefaultHost             = \"npipe:////./pipe/docker_engine\"\n\tnamedPipeConnectTimeout = 2 * time.Second\n)\n\ntype pipeDialer struct {\n\tdialFunc func(network, addr string) (net.Conn, error)\n}\n\nfunc (p pipeDialer) Dial(network, address string) (net.Conn, error) {\n\treturn p.dialFunc(network, address)\n}\n\n// initializeNativeClient initializes the native Named Pipe client for Windows\nfunc (c *Client) initializeNativeClient(trFunc func() *http.Transport) {\n\tif c.endpointURL.Scheme != namedPipeProtocol {\n\t\treturn\n\t}\n\tnamedPipePath := c.endpointURL.Path\n\tdialFunc := func(_, addr string) (net.Conn, error) {\n\t\ttimeout := namedPipeConnectTimeout\n\t\treturn winio.DialPipe(namedPipePath, &timeout)\n\t}\n\ttr := trFunc()\n\ttr.Proxy = nil\n\ttr.DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\treturn dialFunc(network, addr)\n\t}\n\tc.Dialer = &pipeDialer{dialFunc}\n\tc.HTTPClient.Transport = tr\n}\n"
        },
        {
          "name": "client_windows_test.go",
          "type": "blob",
          "size": 1.0986328125,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"sync\"\n\n\twinio \"github.com/Microsoft/go-winio\"\n)\n\nconst (\n\tnativeProtocol     = namedPipeProtocol\n\tnativeRealEndpoint = \"npipe:////./pipe/docker_engine\"\n\tnativeBadEndpoint  = \"npipe:////./pipe/godockerclient_test_echo\"\n)\n\nvar (\n\t// namedPipeCount is used to provide uniqueness in the named pipes generated\n\t// by newNativeServer\n\tnamedPipeCount int\n\t// namedPipesAllocateLock protects namedPipeCount\n\tnamedPipeAllocateLock sync.Mutex\n)\n\nfunc newNativeServer(handler http.Handler) (*httptest.Server, func(), error) {\n\tnamedPipeAllocateLock.Lock()\n\tdefer namedPipeAllocateLock.Unlock()\n\tpipeName := fmt.Sprintf(\"//./pipe/godockerclient_test_%d\", namedPipeCount)\n\tnamedPipeCount++\n\tl, err := winio.ListenPipe(pipeName, &winio.PipeConfig{MessageMode: true})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tsrv := httptest.NewUnstartedServer(handler)\n\tsrv.Listener = l\n\treturn srv, func() {}, nil\n}\n"
        },
        {
          "name": "container.go",
          "type": "blob",
          "size": 38.576171875,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tunits \"github.com/docker/go-units\"\n)\n\n// APIPort is a type that represents a port mapping returned by the Docker API\ntype APIPort struct {\n\tPrivatePort int64  `json:\"PrivatePort,omitempty\" yaml:\"PrivatePort,omitempty\" toml:\"PrivatePort,omitempty\"`\n\tPublicPort  int64  `json:\"PublicPort,omitempty\" yaml:\"PublicPort,omitempty\" toml:\"PublicPort,omitempty\"`\n\tType        string `json:\"Type,omitempty\" yaml:\"Type,omitempty\" toml:\"Type,omitempty\"`\n\tIP          string `json:\"IP,omitempty\" yaml:\"IP,omitempty\" toml:\"IP,omitempty\"`\n}\n\n// APIMount represents a mount point for a container.\ntype APIMount struct {\n\tName        string `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tSource      string `json:\"Source,omitempty\" yaml:\"Source,omitempty\" toml:\"Source,omitempty\"`\n\tDestination string `json:\"Destination,omitempty\" yaml:\"Destination,omitempty\" toml:\"Destination,omitempty\"`\n\tDriver      string `json:\"Driver,omitempty\" yaml:\"Driver,omitempty\" toml:\"Driver,omitempty\"`\n\tMode        string `json:\"Mode,omitempty\" yaml:\"Mode,omitempty\" toml:\"Mode,omitempty\"`\n\tRW          bool   `json:\"RW,omitempty\" yaml:\"RW,omitempty\" toml:\"RW,omitempty\"`\n\tPropagation string `json:\"Propagation,omitempty\" yaml:\"Propagation,omitempty\" toml:\"Propagation,omitempty\"`\n\tType        string `json:\"Type,omitempty\" yaml:\"Type,omitempty\" toml:\"Type,omitempty\"`\n}\n\n// APIContainers represents each container in the list returned by\n// ListContainers.\ntype APIContainers struct {\n\tID         string            `json:\"Id\" yaml:\"Id\" toml:\"Id\"`\n\tImage      string            `json:\"Image,omitempty\" yaml:\"Image,omitempty\" toml:\"Image,omitempty\"`\n\tCommand    string            `json:\"Command,omitempty\" yaml:\"Command,omitempty\" toml:\"Command,omitempty\"`\n\tCreated    int64             `json:\"Created,omitempty\" yaml:\"Created,omitempty\" toml:\"Created,omitempty\"`\n\tState      string            `json:\"State,omitempty\" yaml:\"State,omitempty\" toml:\"State,omitempty\"`\n\tStatus     string            `json:\"Status,omitempty\" yaml:\"Status,omitempty\" toml:\"Status,omitempty\"`\n\tPorts      []APIPort         `json:\"Ports,omitempty\" yaml:\"Ports,omitempty\" toml:\"Ports,omitempty\"`\n\tSizeRw     int64             `json:\"SizeRw,omitempty\" yaml:\"SizeRw,omitempty\" toml:\"SizeRw,omitempty\"`\n\tSizeRootFs int64             `json:\"SizeRootFs,omitempty\" yaml:\"SizeRootFs,omitempty\" toml:\"SizeRootFs,omitempty\"`\n\tNames      []string          `json:\"Names,omitempty\" yaml:\"Names,omitempty\" toml:\"Names,omitempty\"`\n\tLabels     map[string]string `json:\"Labels,omitempty\" yaml:\"Labels,omitempty\" toml:\"Labels,omitempty\"`\n\tNetworks   NetworkList       `json:\"NetworkSettings,omitempty\" yaml:\"NetworkSettings,omitempty\" toml:\"NetworkSettings,omitempty\"`\n\tMounts     []APIMount        `json:\"Mounts,omitempty\" yaml:\"Mounts,omitempty\" toml:\"Mounts,omitempty\"`\n}\n\n// NetworkList encapsulates a map of networks, as returned by the Docker API in\n// ListContainers.\ntype NetworkList struct {\n\tNetworks map[string]ContainerNetwork `json:\"Networks\" yaml:\"Networks,omitempty\" toml:\"Networks,omitempty\"`\n}\n\n// Port represents the port number and the protocol, in the form\n// <number>/<protocol>. For example: 80/tcp.\ntype Port string\n\n// Port returns the number of the port.\nfunc (p Port) Port() string {\n\treturn strings.Split(string(p), \"/\")[0]\n}\n\n// Proto returns the name of the protocol.\nfunc (p Port) Proto() string {\n\tparts := strings.Split(string(p), \"/\")\n\tif len(parts) == 1 {\n\t\treturn \"tcp\"\n\t}\n\treturn parts[1]\n}\n\n// HealthCheck represents one check of health.\ntype HealthCheck struct {\n\tStart    time.Time `json:\"Start,omitempty\" yaml:\"Start,omitempty\" toml:\"Start,omitempty\"`\n\tEnd      time.Time `json:\"End,omitempty\" yaml:\"End,omitempty\" toml:\"End,omitempty\"`\n\tExitCode int       `json:\"ExitCode,omitempty\" yaml:\"ExitCode,omitempty\" toml:\"ExitCode,omitempty\"`\n\tOutput   string    `json:\"Output,omitempty\" yaml:\"Output,omitempty\" toml:\"Output,omitempty\"`\n}\n\n// Health represents the health of a container.\ntype Health struct {\n\tStatus        string        `json:\"Status,omitempty\" yaml:\"Status,omitempty\" toml:\"Status,omitempty\"`\n\tFailingStreak int           `json:\"FailingStreak,omitempty\" yaml:\"FailingStreak,omitempty\" toml:\"FailingStreak,omitempty\"`\n\tLog           []HealthCheck `json:\"Log,omitempty\" yaml:\"Log,omitempty\" toml:\"Log,omitempty\"`\n}\n\n// State represents the state of a container.\ntype State struct {\n\tStatus            string    `json:\"Status,omitempty\" yaml:\"Status,omitempty\" toml:\"Status,omitempty\"`\n\tRunning           bool      `json:\"Running,omitempty\" yaml:\"Running,omitempty\" toml:\"Running,omitempty\"`\n\tPaused            bool      `json:\"Paused,omitempty\" yaml:\"Paused,omitempty\" toml:\"Paused,omitempty\"`\n\tRestarting        bool      `json:\"Restarting,omitempty\" yaml:\"Restarting,omitempty\" toml:\"Restarting,omitempty\"`\n\tOOMKilled         bool      `json:\"OOMKilled,omitempty\" yaml:\"OOMKilled,omitempty\" toml:\"OOMKilled,omitempty\"`\n\tRemovalInProgress bool      `json:\"RemovalInProgress,omitempty\" yaml:\"RemovalInProgress,omitempty\" toml:\"RemovalInProgress,omitempty\"`\n\tDead              bool      `json:\"Dead,omitempty\" yaml:\"Dead,omitempty\" toml:\"Dead,omitempty\"`\n\tPid               int       `json:\"Pid,omitempty\" yaml:\"Pid,omitempty\" toml:\"Pid,omitempty\"`\n\tExitCode          int       `json:\"ExitCode,omitempty\" yaml:\"ExitCode,omitempty\" toml:\"ExitCode,omitempty\"`\n\tError             string    `json:\"Error,omitempty\" yaml:\"Error,omitempty\" toml:\"Error,omitempty\"`\n\tStartedAt         time.Time `json:\"StartedAt,omitempty\" yaml:\"StartedAt,omitempty\" toml:\"StartedAt,omitempty\"`\n\tFinishedAt        time.Time `json:\"FinishedAt,omitempty\" yaml:\"FinishedAt,omitempty\" toml:\"FinishedAt,omitempty\"`\n\tHealth            Health    `json:\"Health,omitempty\" yaml:\"Health,omitempty\" toml:\"Health,omitempty\"`\n}\n\n// String returns a human-readable description of the state\nfunc (s *State) String() string {\n\tif s.Running {\n\t\tif s.Paused {\n\t\t\treturn fmt.Sprintf(\"Up %s (Paused)\", units.HumanDuration(time.Now().UTC().Sub(s.StartedAt)))\n\t\t}\n\t\tif s.Restarting {\n\t\t\treturn fmt.Sprintf(\"Restarting (%d) %s ago\", s.ExitCode, units.HumanDuration(time.Now().UTC().Sub(s.FinishedAt)))\n\t\t}\n\n\t\treturn fmt.Sprintf(\"Up %s\", units.HumanDuration(time.Now().UTC().Sub(s.StartedAt)))\n\t}\n\n\tif s.RemovalInProgress {\n\t\treturn \"Removal In Progress\"\n\t}\n\n\tif s.Dead {\n\t\treturn \"Dead\"\n\t}\n\n\tif s.StartedAt.IsZero() {\n\t\treturn \"Created\"\n\t}\n\n\tif s.FinishedAt.IsZero() {\n\t\treturn \"\"\n\t}\n\n\treturn fmt.Sprintf(\"Exited (%d) %s ago\", s.ExitCode, units.HumanDuration(time.Now().UTC().Sub(s.FinishedAt)))\n}\n\n// StateString returns a single string to describe state\nfunc (s *State) StateString() string {\n\tif s.Running {\n\t\tif s.Paused {\n\t\t\treturn \"paused\"\n\t\t}\n\t\tif s.Restarting {\n\t\t\treturn \"restarting\"\n\t\t}\n\t\treturn \"running\"\n\t}\n\n\tif s.Dead {\n\t\treturn \"dead\"\n\t}\n\n\tif s.StartedAt.IsZero() {\n\t\treturn \"created\"\n\t}\n\n\treturn \"exited\"\n}\n\n// PortBinding represents the host/container port mapping as returned in the\n// `docker inspect` json\ntype PortBinding struct {\n\tHostIP   string `json:\"HostIp,omitempty\" yaml:\"HostIp,omitempty\" toml:\"HostIp,omitempty\"`\n\tHostPort string `json:\"HostPort,omitempty\" yaml:\"HostPort,omitempty\" toml:\"HostPort,omitempty\"`\n}\n\n// PortMapping represents a deprecated field in the `docker inspect` output,\n// and its value as found in NetworkSettings should always be nil\ntype PortMapping map[string]string\n\n// ContainerNetwork represents the networking settings of a container per network.\ntype ContainerNetwork struct {\n\tAliases             []string `json:\"Aliases,omitempty\" yaml:\"Aliases,omitempty\" toml:\"Aliases,omitempty\"`\n\tMacAddress          string   `json:\"MacAddress,omitempty\" yaml:\"MacAddress,omitempty\" toml:\"MacAddress,omitempty\"`\n\tGlobalIPv6PrefixLen int      `json:\"GlobalIPv6PrefixLen,omitempty\" yaml:\"GlobalIPv6PrefixLen,omitempty\" toml:\"GlobalIPv6PrefixLen,omitempty\"`\n\tGlobalIPv6Address   string   `json:\"GlobalIPv6Address,omitempty\" yaml:\"GlobalIPv6Address,omitempty\" toml:\"GlobalIPv6Address,omitempty\"`\n\tIPv6Gateway         string   `json:\"IPv6Gateway,omitempty\" yaml:\"IPv6Gateway,omitempty\" toml:\"IPv6Gateway,omitempty\"`\n\tIPPrefixLen         int      `json:\"IPPrefixLen,omitempty\" yaml:\"IPPrefixLen,omitempty\" toml:\"IPPrefixLen,omitempty\"`\n\tIPAddress           string   `json:\"IPAddress,omitempty\" yaml:\"IPAddress,omitempty\" toml:\"IPAddress,omitempty\"`\n\tGateway             string   `json:\"Gateway,omitempty\" yaml:\"Gateway,omitempty\" toml:\"Gateway,omitempty\"`\n\tEndpointID          string   `json:\"EndpointID,omitempty\" yaml:\"EndpointID,omitempty\" toml:\"EndpointID,omitempty\"`\n\tNetworkID           string   `json:\"NetworkID,omitempty\" yaml:\"NetworkID,omitempty\" toml:\"NetworkID,omitempty\"`\n}\n\n// NetworkSettings contains network-related information about a container\ntype NetworkSettings struct {\n\tNetworks               map[string]ContainerNetwork `json:\"Networks,omitempty\" yaml:\"Networks,omitempty\" toml:\"Networks,omitempty\"`\n\tIPAddress              string                      `json:\"IPAddress,omitempty\" yaml:\"IPAddress,omitempty\" toml:\"IPAddress,omitempty\"`\n\tIPPrefixLen            int                         `json:\"IPPrefixLen,omitempty\" yaml:\"IPPrefixLen,omitempty\" toml:\"IPPrefixLen,omitempty\"`\n\tMacAddress             string                      `json:\"MacAddress,omitempty\" yaml:\"MacAddress,omitempty\" toml:\"MacAddress,omitempty\"`\n\tGateway                string                      `json:\"Gateway,omitempty\" yaml:\"Gateway,omitempty\" toml:\"Gateway,omitempty\"`\n\tBridge                 string                      `json:\"Bridge,omitempty\" yaml:\"Bridge,omitempty\" toml:\"Bridge,omitempty\"`\n\tPortMapping            map[string]PortMapping      `json:\"PortMapping,omitempty\" yaml:\"PortMapping,omitempty\" toml:\"PortMapping,omitempty\"`\n\tPorts                  map[Port][]PortBinding      `json:\"Ports,omitempty\" yaml:\"Ports,omitempty\" toml:\"Ports,omitempty\"`\n\tNetworkID              string                      `json:\"NetworkID,omitempty\" yaml:\"NetworkID,omitempty\" toml:\"NetworkID,omitempty\"`\n\tEndpointID             string                      `json:\"EndpointID,omitempty\" yaml:\"EndpointID,omitempty\" toml:\"EndpointID,omitempty\"`\n\tSandboxKey             string                      `json:\"SandboxKey,omitempty\" yaml:\"SandboxKey,omitempty\" toml:\"SandboxKey,omitempty\"`\n\tGlobalIPv6Address      string                      `json:\"GlobalIPv6Address,omitempty\" yaml:\"GlobalIPv6Address,omitempty\" toml:\"GlobalIPv6Address,omitempty\"`\n\tGlobalIPv6PrefixLen    int                         `json:\"GlobalIPv6PrefixLen,omitempty\" yaml:\"GlobalIPv6PrefixLen,omitempty\" toml:\"GlobalIPv6PrefixLen,omitempty\"`\n\tIPv6Gateway            string                      `json:\"IPv6Gateway,omitempty\" yaml:\"IPv6Gateway,omitempty\" toml:\"IPv6Gateway,omitempty\"`\n\tLinkLocalIPv6Address   string                      `json:\"LinkLocalIPv6Address,omitempty\" yaml:\"LinkLocalIPv6Address,omitempty\" toml:\"LinkLocalIPv6Address,omitempty\"`\n\tLinkLocalIPv6PrefixLen int                         `json:\"LinkLocalIPv6PrefixLen,omitempty\" yaml:\"LinkLocalIPv6PrefixLen,omitempty\" toml:\"LinkLocalIPv6PrefixLen,omitempty\"`\n\tSecondaryIPAddresses   []string                    `json:\"SecondaryIPAddresses,omitempty\" yaml:\"SecondaryIPAddresses,omitempty\" toml:\"SecondaryIPAddresses,omitempty\"`\n\tSecondaryIPv6Addresses []string                    `json:\"SecondaryIPv6Addresses,omitempty\" yaml:\"SecondaryIPv6Addresses,omitempty\" toml:\"SecondaryIPv6Addresses,omitempty\"`\n}\n\n// PortMappingAPI translates the port mappings as contained in NetworkSettings\n// into the format in which they would appear when returned by the API\nfunc (settings *NetworkSettings) PortMappingAPI() []APIPort {\n\tvar mapping []APIPort\n\tfor port, bindings := range settings.Ports {\n\t\tp, _ := parsePort(port.Port())\n\t\tif len(bindings) == 0 {\n\t\t\tmapping = append(mapping, APIPort{\n\t\t\t\tPrivatePort: int64(p),\n\t\t\t\tType:        port.Proto(),\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\t\tfor _, binding := range bindings {\n\t\t\tp, _ := parsePort(port.Port())\n\t\t\th, _ := parsePort(binding.HostPort)\n\t\t\tmapping = append(mapping, APIPort{\n\t\t\t\tPrivatePort: int64(p),\n\t\t\t\tPublicPort:  int64(h),\n\t\t\t\tType:        port.Proto(),\n\t\t\t\tIP:          binding.HostIP,\n\t\t\t})\n\t\t}\n\t}\n\treturn mapping\n}\n\nfunc parsePort(rawPort string) (int, error) {\n\tport, err := strconv.ParseUint(rawPort, 10, 16)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int(port), nil\n}\n\n// Config is the list of configuration options used when creating a container.\n// Config does not contain the options that are specific to starting a container on a\n// given host.  Those are contained in HostConfig\ntype Config struct {\n\tHostname          string              `json:\"Hostname,omitempty\" yaml:\"Hostname,omitempty\" toml:\"Hostname,omitempty\"`\n\tDomainname        string              `json:\"Domainname,omitempty\" yaml:\"Domainname,omitempty\" toml:\"Domainname,omitempty\"`\n\tUser              string              `json:\"User,omitempty\" yaml:\"User,omitempty\" toml:\"User,omitempty\"`\n\tMemory            int64               `json:\"Memory,omitempty\" yaml:\"Memory,omitempty\" toml:\"Memory,omitempty\"`\n\tMemorySwap        int64               `json:\"MemorySwap,omitempty\" yaml:\"MemorySwap,omitempty\" toml:\"MemorySwap,omitempty\"`\n\tMemoryReservation int64               `json:\"MemoryReservation,omitempty\" yaml:\"MemoryReservation,omitempty\" toml:\"MemoryReservation,omitempty\"`\n\tKernelMemory      int64               `json:\"KernelMemory,omitempty\" yaml:\"KernelMemory,omitempty\" toml:\"KernelMemory,omitempty\"`\n\tCPUShares         int64               `json:\"CpuShares,omitempty\" yaml:\"CpuShares,omitempty\" toml:\"CpuShares,omitempty\"`\n\tCPUSet            string              `json:\"Cpuset,omitempty\" yaml:\"Cpuset,omitempty\" toml:\"Cpuset,omitempty\"`\n\tPortSpecs         []string            `json:\"PortSpecs,omitempty\" yaml:\"PortSpecs,omitempty\" toml:\"PortSpecs,omitempty\"`\n\tExposedPorts      map[Port]struct{}   `json:\"ExposedPorts,omitempty\" yaml:\"ExposedPorts,omitempty\" toml:\"ExposedPorts,omitempty\"`\n\tPublishService    string              `json:\"PublishService,omitempty\" yaml:\"PublishService,omitempty\" toml:\"PublishService,omitempty\"`\n\tStopSignal        string              `json:\"StopSignal,omitempty\" yaml:\"StopSignal,omitempty\" toml:\"StopSignal,omitempty\"`\n\tStopTimeout       int                 `json:\"StopTimeout,omitempty\" yaml:\"StopTimeout,omitempty\" toml:\"StopTimeout,omitempty\"`\n\tEnv               []string            `json:\"Env,omitempty\" yaml:\"Env,omitempty\" toml:\"Env,omitempty\"`\n\tCmd               []string            `json:\"Cmd\" yaml:\"Cmd\" toml:\"Cmd\"`\n\tShell             []string            `json:\"Shell,omitempty\" yaml:\"Shell,omitempty\" toml:\"Shell,omitempty\"`\n\tHealthcheck       *HealthConfig       `json:\"Healthcheck,omitempty\" yaml:\"Healthcheck,omitempty\" toml:\"Healthcheck,omitempty\"`\n\tDNS               []string            `json:\"Dns,omitempty\" yaml:\"Dns,omitempty\" toml:\"Dns,omitempty\"` // For Docker API v1.9 and below only\n\tImage             string              `json:\"Image,omitempty\" yaml:\"Image,omitempty\" toml:\"Image,omitempty\"`\n\tVolumes           map[string]struct{} `json:\"Volumes,omitempty\" yaml:\"Volumes,omitempty\" toml:\"Volumes,omitempty\"`\n\tVolumeDriver      string              `json:\"VolumeDriver,omitempty\" yaml:\"VolumeDriver,omitempty\" toml:\"VolumeDriver,omitempty\"`\n\tWorkingDir        string              `json:\"WorkingDir,omitempty\" yaml:\"WorkingDir,omitempty\" toml:\"WorkingDir,omitempty\"`\n\tMacAddress        string              `json:\"MacAddress,omitempty\" yaml:\"MacAddress,omitempty\" toml:\"MacAddress,omitempty\"`\n\tEntrypoint        []string            `json:\"Entrypoint\" yaml:\"Entrypoint\" toml:\"Entrypoint\"`\n\tSecurityOpts      []string            `json:\"SecurityOpts,omitempty\" yaml:\"SecurityOpts,omitempty\" toml:\"SecurityOpts,omitempty\"`\n\tOnBuild           []string            `json:\"OnBuild,omitempty\" yaml:\"OnBuild,omitempty\" toml:\"OnBuild,omitempty\"`\n\tMounts            []Mount             `json:\"Mounts,omitempty\" yaml:\"Mounts,omitempty\" toml:\"Mounts,omitempty\"`\n\tLabels            map[string]string   `json:\"Labels,omitempty\" yaml:\"Labels,omitempty\" toml:\"Labels,omitempty\"`\n\tAttachStdin       bool                `json:\"AttachStdin,omitempty\" yaml:\"AttachStdin,omitempty\" toml:\"AttachStdin,omitempty\"`\n\tAttachStdout      bool                `json:\"AttachStdout,omitempty\" yaml:\"AttachStdout,omitempty\" toml:\"AttachStdout,omitempty\"`\n\tAttachStderr      bool                `json:\"AttachStderr,omitempty\" yaml:\"AttachStderr,omitempty\" toml:\"AttachStderr,omitempty\"`\n\tArgsEscaped       bool                `json:\"ArgsEscaped,omitempty\" yaml:\"ArgsEscaped,omitempty\" toml:\"ArgsEscaped,omitempty\"`\n\tTty               bool                `json:\"Tty,omitempty\" yaml:\"Tty,omitempty\" toml:\"Tty,omitempty\"`\n\tOpenStdin         bool                `json:\"OpenStdin,omitempty\" yaml:\"OpenStdin,omitempty\" toml:\"OpenStdin,omitempty\"`\n\tStdinOnce         bool                `json:\"StdinOnce,omitempty\" yaml:\"StdinOnce,omitempty\" toml:\"StdinOnce,omitempty\"`\n\tNetworkDisabled   bool                `json:\"NetworkDisabled,omitempty\" yaml:\"NetworkDisabled,omitempty\" toml:\"NetworkDisabled,omitempty\"`\n\n\t// This is no longer used and has been kept here for backward\n\t// compatibility, please use HostConfig.VolumesFrom.\n\tVolumesFrom string `json:\"VolumesFrom,omitempty\" yaml:\"VolumesFrom,omitempty\" toml:\"VolumesFrom,omitempty\"`\n}\n\n// HostMount represents a mount point in the container in HostConfig.\n//\n// It has been added in the version 1.25 of the Docker API\ntype HostMount struct {\n\tTarget        string         `json:\"Target,omitempty\" yaml:\"Target,omitempty\" toml:\"Target,omitempty\"`\n\tSource        string         `json:\"Source,omitempty\" yaml:\"Source,omitempty\" toml:\"Source,omitempty\"`\n\tType          string         `json:\"Type,omitempty\" yaml:\"Type,omitempty\" toml:\"Type,omitempty\"`\n\tReadOnly      bool           `json:\"ReadOnly,omitempty\" yaml:\"ReadOnly,omitempty\" toml:\"ReadOnly,omitempty\"`\n\tBindOptions   *BindOptions   `json:\"BindOptions,omitempty\" yaml:\"BindOptions,omitempty\" toml:\"BindOptions,omitempty\"`\n\tVolumeOptions *VolumeOptions `json:\"VolumeOptions,omitempty\" yaml:\"VolumeOptions,omitempty\" toml:\"VolumeOptions,omitempty\"`\n\tTempfsOptions *TempfsOptions `json:\"TmpfsOptions,omitempty\" yaml:\"TmpfsOptions,omitempty\" toml:\"TmpfsOptions,omitempty\"`\n}\n\n// BindOptions contains optional configuration for the bind type\ntype BindOptions struct {\n\tPropagation string `json:\"Propagation,omitempty\" yaml:\"Propagation,omitempty\" toml:\"Propagation,omitempty\"`\n}\n\n// VolumeOptions contains optional configuration for the volume type\ntype VolumeOptions struct {\n\tNoCopy       bool               `json:\"NoCopy,omitempty\" yaml:\"NoCopy,omitempty\" toml:\"NoCopy,omitempty\"`\n\tLabels       map[string]string  `json:\"Labels,omitempty\" yaml:\"Labels,omitempty\" toml:\"Labels,omitempty\"`\n\tDriverConfig VolumeDriverConfig `json:\"DriverConfig,omitempty\" yaml:\"DriverConfig,omitempty\" toml:\"DriverConfig,omitempty\"`\n}\n\n// TempfsOptions contains optional configuration for the tempfs type\ntype TempfsOptions struct {\n\tSizeBytes int64      `json:\"SizeBytes,omitempty\" yaml:\"SizeBytes,omitempty\" toml:\"SizeBytes,omitempty\"`\n\tMode      int        `json:\"Mode,omitempty\" yaml:\"Mode,omitempty\" toml:\"Mode,omitempty\"`\n\tOptions   [][]string `json:\"Options,omitempty\" yaml:\"Options,omitempty\" toml:\"Options,omitempty\"`\n}\n\n// VolumeDriverConfig holds a map of volume driver specific options\ntype VolumeDriverConfig struct {\n\tName    string            `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tOptions map[string]string `json:\"Options,omitempty\" yaml:\"Options,omitempty\" toml:\"Options,omitempty\"`\n}\n\n// Mount represents a mount point in the container.\n//\n// It has been added in the version 1.20 of the Docker API, available since\n// Docker 1.8.\ntype Mount struct {\n\tName        string\n\tSource      string\n\tDestination string\n\tDriver      string\n\tMode        string\n\tRW          bool\n}\n\n// LogConfig defines the log driver type and the configuration for it.\ntype LogConfig struct {\n\tType   string            `json:\"Type,omitempty\" yaml:\"Type,omitempty\" toml:\"Type,omitempty\"`\n\tConfig map[string]string `json:\"Config,omitempty\" yaml:\"Config,omitempty\" toml:\"Config,omitempty\"`\n}\n\n// ULimit defines system-wide resource limitations This can help a lot in\n// system administration, e.g. when a user starts too many processes and\n// therefore makes the system unresponsive for other users.\ntype ULimit struct {\n\tName string `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tSoft int64  `json:\"Soft,omitempty\" yaml:\"Soft,omitempty\" toml:\"Soft,omitempty\"`\n\tHard int64  `json:\"Hard,omitempty\" yaml:\"Hard,omitempty\" toml:\"Hard,omitempty\"`\n}\n\n// SwarmNode containers information about which Swarm node the container is on.\ntype SwarmNode struct {\n\tID     string            `json:\"ID,omitempty\" yaml:\"ID,omitempty\" toml:\"ID,omitempty\"`\n\tIP     string            `json:\"IP,omitempty\" yaml:\"IP,omitempty\" toml:\"IP,omitempty\"`\n\tAddr   string            `json:\"Addr,omitempty\" yaml:\"Addr,omitempty\" toml:\"Addr,omitempty\"`\n\tName   string            `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tCPUs   int64             `json:\"CPUs,omitempty\" yaml:\"CPUs,omitempty\" toml:\"CPUs,omitempty\"`\n\tMemory int64             `json:\"Memory,omitempty\" yaml:\"Memory,omitempty\" toml:\"Memory,omitempty\"`\n\tLabels map[string]string `json:\"Labels,omitempty\" yaml:\"Labels,omitempty\" toml:\"Labels,omitempty\"`\n}\n\n// GraphDriver contains information about the GraphDriver used by the\n// container.\ntype GraphDriver struct {\n\tName string            `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tData map[string]string `json:\"Data,omitempty\" yaml:\"Data,omitempty\" toml:\"Data,omitempty\"`\n}\n\n// HealthConfig holds configuration settings for the HEALTHCHECK feature\n//\n// It has been added in the version 1.24 of the Docker API, available since\n// Docker 1.12.\ntype HealthConfig struct {\n\t// Test is the test to perform to check that the container is healthy.\n\t// An empty slice means to inherit the default.\n\t// The options are:\n\t// {} : inherit healthcheck\n\t// {\"NONE\"} : disable healthcheck\n\t// {\"CMD\", args...} : exec arguments directly\n\t// {\"CMD-SHELL\", command} : run command with system's default shell\n\tTest []string `json:\"Test,omitempty\" yaml:\"Test,omitempty\" toml:\"Test,omitempty\"`\n\n\t// Zero means to inherit. Durations are expressed as integer nanoseconds.\n\tInterval      time.Duration `json:\"Interval,omitempty\" yaml:\"Interval,omitempty\" toml:\"Interval,omitempty\"`                // Interval is the time to wait between checks.\n\tTimeout       time.Duration `json:\"Timeout,omitempty\" yaml:\"Timeout,omitempty\" toml:\"Timeout,omitempty\"`                   // Timeout is the time to wait before considering the check to have hung.\n\tStartPeriod   time.Duration `json:\"StartPeriod,omitempty\" yaml:\"StartPeriod,omitempty\" toml:\"StartPeriod,omitempty\"`       // The start period for the container to initialize before the retries starts to count down.\n\tStartInterval time.Duration `json:\"StartInterval,omitempty\" yaml:\"StartInterval,omitempty\" toml:\"StartInterval,omitempty\"` // The start interval is the time to wait between checks during the start period.\n\n\t// Retries is the number of consecutive failures needed to consider a container as unhealthy.\n\t// Zero means inherit.\n\tRetries int `json:\"Retries,omitempty\" yaml:\"Retries,omitempty\" toml:\"Retries,omitempty\"`\n}\n\n// Container is the type encompasing everything about a container - its config,\n// hostconfig, etc.\ntype Container struct {\n\tID string `json:\"Id\" yaml:\"Id\" toml:\"Id\"`\n\n\tCreated time.Time `json:\"Created,omitempty\" yaml:\"Created,omitempty\" toml:\"Created,omitempty\"`\n\n\tPath string   `json:\"Path,omitempty\" yaml:\"Path,omitempty\" toml:\"Path,omitempty\"`\n\tArgs []string `json:\"Args,omitempty\" yaml:\"Args,omitempty\" toml:\"Args,omitempty\"`\n\n\tConfig *Config `json:\"Config,omitempty\" yaml:\"Config,omitempty\" toml:\"Config,omitempty\"`\n\tState  State   `json:\"State,omitempty\" yaml:\"State,omitempty\" toml:\"State,omitempty\"`\n\tImage  string  `json:\"Image,omitempty\" yaml:\"Image,omitempty\" toml:\"Image,omitempty\"`\n\n\tNode *SwarmNode `json:\"Node,omitempty\" yaml:\"Node,omitempty\" toml:\"Node,omitempty\"`\n\n\tNetworkSettings *NetworkSettings `json:\"NetworkSettings,omitempty\" yaml:\"NetworkSettings,omitempty\" toml:\"NetworkSettings,omitempty\"`\n\n\tSysInitPath    string  `json:\"SysInitPath,omitempty\" yaml:\"SysInitPath,omitempty\" toml:\"SysInitPath,omitempty\"`\n\tResolvConfPath string  `json:\"ResolvConfPath,omitempty\" yaml:\"ResolvConfPath,omitempty\" toml:\"ResolvConfPath,omitempty\"`\n\tHostnamePath   string  `json:\"HostnamePath,omitempty\" yaml:\"HostnamePath,omitempty\" toml:\"HostnamePath,omitempty\"`\n\tHostsPath      string  `json:\"HostsPath,omitempty\" yaml:\"HostsPath,omitempty\" toml:\"HostsPath,omitempty\"`\n\tLogPath        string  `json:\"LogPath,omitempty\" yaml:\"LogPath,omitempty\" toml:\"LogPath,omitempty\"`\n\tName           string  `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tDriver         string  `json:\"Driver,omitempty\" yaml:\"Driver,omitempty\" toml:\"Driver,omitempty\"`\n\tMounts         []Mount `json:\"Mounts,omitempty\" yaml:\"Mounts,omitempty\" toml:\"Mounts,omitempty\"`\n\n\tVolumes     map[string]string `json:\"Volumes,omitempty\" yaml:\"Volumes,omitempty\" toml:\"Volumes,omitempty\"`\n\tVolumesRW   map[string]bool   `json:\"VolumesRW,omitempty\" yaml:\"VolumesRW,omitempty\" toml:\"VolumesRW,omitempty\"`\n\tHostConfig  *HostConfig       `json:\"HostConfig,omitempty\" yaml:\"HostConfig,omitempty\" toml:\"HostConfig,omitempty\"`\n\tExecIDs     []string          `json:\"ExecIDs,omitempty\" yaml:\"ExecIDs,omitempty\" toml:\"ExecIDs,omitempty\"`\n\tGraphDriver *GraphDriver      `json:\"GraphDriver,omitempty\" yaml:\"GraphDriver,omitempty\" toml:\"GraphDriver,omitempty\"`\n\n\tRestartCount int `json:\"RestartCount,omitempty\" yaml:\"RestartCount,omitempty\" toml:\"RestartCount,omitempty\"`\n\n\tAppArmorProfile string `json:\"AppArmorProfile,omitempty\" yaml:\"AppArmorProfile,omitempty\" toml:\"AppArmorProfile,omitempty\"`\n\n\tMountLabel   string `json:\"MountLabel,omitempty\" yaml:\"MountLabel,omitempty\" toml:\"MountLabel,omitempty\"`\n\tProcessLabel string `json:\"ProcessLabel,omitempty\" yaml:\"ProcessLabel,omitempty\" toml:\"ProcessLabel,omitempty\"`\n\tPlatform     string `json:\"Platform,omitempty\" yaml:\"Platform,omitempty\" toml:\"Platform,omitempty\"`\n\tSizeRw       int64  `json:\"SizeRw,omitempty\" yaml:\"SizeRw,omitempty\" toml:\"SizeRw,omitempty\"`\n\tSizeRootFs   int64  `json:\"SizeRootFs,omitempty\" yaml:\"SizeRootFs,omitempty\" toml:\"SizeRootFs,omitempty\"`\n}\n\n// KeyValuePair is a type for generic key/value pairs as used in the Lxc\n// configuration\ntype KeyValuePair struct {\n\tKey   string `json:\"Key,omitempty\" yaml:\"Key,omitempty\" toml:\"Key,omitempty\"`\n\tValue string `json:\"Value,omitempty\" yaml:\"Value,omitempty\" toml:\"Value,omitempty\"`\n}\n\n// Device represents a device mapping between the Docker host and the\n// container.\ntype Device struct {\n\tPathOnHost        string `json:\"PathOnHost,omitempty\" yaml:\"PathOnHost,omitempty\" toml:\"PathOnHost,omitempty\"`\n\tPathInContainer   string `json:\"PathInContainer,omitempty\" yaml:\"PathInContainer,omitempty\" toml:\"PathInContainer,omitempty\"`\n\tCgroupPermissions string `json:\"CgroupPermissions,omitempty\" yaml:\"CgroupPermissions,omitempty\" toml:\"CgroupPermissions,omitempty\"`\n}\n\n// DeviceRequest represents a request for device that's sent to device drivers.\ntype DeviceRequest struct {\n\tDriver       string            `json:\"Driver,omitempty\" yaml:\"Driver,omitempty\" toml:\"Driver,omitempty\"`\n\tCount        int               `json:\"Count,omitempty\" yaml:\"Count,omitempty\" toml:\"Count,omitempty\"`\n\tDeviceIDs    []string          `json:\"DeviceIDs,omitempty\" yaml:\"DeviceIDs,omitempty\" toml:\"DeviceIDs,omitempty\"`\n\tCapabilities [][]string        `json:\"Capabilities,omitempty\" yaml:\"Capabilities,omitempty\" toml:\"Capabilities,omitempty\"`\n\tOptions      map[string]string `json:\"Options,omitempty\" yaml:\"Options,omitempty\" toml:\"Options,omitempty\"`\n}\n\n// BlockWeight represents a relative device weight for an individual device inside\n// of a container\ntype BlockWeight struct {\n\tPath   string `json:\"Path,omitempty\"`\n\tWeight string `json:\"Weight,omitempty\"`\n}\n\n// BlockLimit represents a read/write limit in IOPS or Bandwidth for a device\n// inside of a container\ntype BlockLimit struct {\n\tPath string `json:\"Path,omitempty\"`\n\tRate int64  `json:\"Rate,omitempty\"`\n}\n\n// HostConfig contains the container options related to starting a container on\n// a given host\ntype HostConfig struct {\n\tBinds                []string               `json:\"Binds,omitempty\" yaml:\"Binds,omitempty\" toml:\"Binds,omitempty\"`\n\tCapAdd               []string               `json:\"CapAdd,omitempty\" yaml:\"CapAdd,omitempty\" toml:\"CapAdd,omitempty\"`\n\tCapDrop              []string               `json:\"CapDrop,omitempty\" yaml:\"CapDrop,omitempty\" toml:\"CapDrop,omitempty\"`\n\tCapabilities         []string               `json:\"Capabilities,omitempty\" yaml:\"Capabilities,omitempty\" toml:\"Capabilities,omitempty\"` // Mutually exclusive w.r.t. CapAdd and CapDrop API v1.40\n\tGroupAdd             []string               `json:\"GroupAdd,omitempty\" yaml:\"GroupAdd,omitempty\" toml:\"GroupAdd,omitempty\"`\n\tContainerIDFile      string                 `json:\"ContainerIDFile,omitempty\" yaml:\"ContainerIDFile,omitempty\" toml:\"ContainerIDFile,omitempty\"`\n\tLxcConf              []KeyValuePair         `json:\"LxcConf,omitempty\" yaml:\"LxcConf,omitempty\" toml:\"LxcConf,omitempty\"`\n\tPortBindings         map[Port][]PortBinding `json:\"PortBindings,omitempty\" yaml:\"PortBindings,omitempty\" toml:\"PortBindings,omitempty\"`\n\tLinks                []string               `json:\"Links,omitempty\" yaml:\"Links,omitempty\" toml:\"Links,omitempty\"`\n\tDNS                  []string               `json:\"Dns,omitempty\" yaml:\"Dns,omitempty\" toml:\"Dns,omitempty\"` // For Docker API v1.10 and above only\n\tDNSOptions           []string               `json:\"DnsOptions,omitempty\" yaml:\"DnsOptions,omitempty\" toml:\"DnsOptions,omitempty\"`\n\tDNSSearch            []string               `json:\"DnsSearch,omitempty\" yaml:\"DnsSearch,omitempty\" toml:\"DnsSearch,omitempty\"`\n\tExtraHosts           []string               `json:\"ExtraHosts,omitempty\" yaml:\"ExtraHosts,omitempty\" toml:\"ExtraHosts,omitempty\"`\n\tVolumesFrom          []string               `json:\"VolumesFrom,omitempty\" yaml:\"VolumesFrom,omitempty\" toml:\"VolumesFrom,omitempty\"`\n\tUsernsMode           string                 `json:\"UsernsMode,omitempty\" yaml:\"UsernsMode,omitempty\" toml:\"UsernsMode,omitempty\"`\n\tNetworkMode          string                 `json:\"NetworkMode,omitempty\" yaml:\"NetworkMode,omitempty\" toml:\"NetworkMode,omitempty\"`\n\tIpcMode              string                 `json:\"IpcMode,omitempty\" yaml:\"IpcMode,omitempty\" toml:\"IpcMode,omitempty\"`\n\tIsolation            string                 `json:\"Isolation,omitempty\" yaml:\"Isolation,omitempty\" toml:\"Isolation,omitempty\"`       // Windows only\n\tConsoleSize          [2]int                 `json:\"ConsoleSize,omitempty\" yaml:\"ConsoleSize,omitempty\" toml:\"ConsoleSize,omitempty\"` // Windows only height x width\n\tPidMode              string                 `json:\"PidMode,omitempty\" yaml:\"PidMode,omitempty\" toml:\"PidMode,omitempty\"`\n\tUTSMode              string                 `json:\"UTSMode,omitempty\" yaml:\"UTSMode,omitempty\" toml:\"UTSMode,omitempty\"`\n\tRestartPolicy        RestartPolicy          `json:\"RestartPolicy,omitempty\" yaml:\"RestartPolicy,omitempty\" toml:\"RestartPolicy,omitempty\"`\n\tDevices              []Device               `json:\"Devices,omitempty\" yaml:\"Devices,omitempty\" toml:\"Devices,omitempty\"`\n\tDeviceCgroupRules    []string               `json:\"DeviceCgroupRules,omitempty\" yaml:\"DeviceCgroupRules,omitempty\" toml:\"DeviceCgroupRules,omitempty\"`\n\tDeviceRequests       []DeviceRequest        `json:\"DeviceRequests,omitempty\" yaml:\"DeviceRequests,omitempty\" toml:\"DeviceRequests,omitempty\"`\n\tLogConfig            LogConfig              `json:\"LogConfig,omitempty\" yaml:\"LogConfig,omitempty\" toml:\"LogConfig,omitempty\"`\n\tSecurityOpt          []string               `json:\"SecurityOpt,omitempty\" yaml:\"SecurityOpt,omitempty\" toml:\"SecurityOpt,omitempty\"`\n\tCgroupnsMode         string                 `json:\"CgroupnsMode,omitempty\" yaml:\"CgroupnsMode,omitempty\" toml:\"CgroupnsMode,omitempty\"` // v1.40+\n\tCgroup               string                 `json:\"Cgroup,omitempty\" yaml:\"Cgroup,omitempty\" toml:\"Cgroup,omitempty\"`\n\tCgroupParent         string                 `json:\"CgroupParent,omitempty\" yaml:\"CgroupParent,omitempty\" toml:\"CgroupParent,omitempty\"`\n\tMemory               int64                  `json:\"Memory,omitempty\" yaml:\"Memory,omitempty\" toml:\"Memory,omitempty\"`\n\tMemoryReservation    int64                  `json:\"MemoryReservation,omitempty\" yaml:\"MemoryReservation,omitempty\" toml:\"MemoryReservation,omitempty\"`\n\tKernelMemory         int64                  `json:\"KernelMemory,omitempty\" yaml:\"KernelMemory,omitempty\" toml:\"KernelMemory,omitempty\"`\n\tMemorySwap           int64                  `json:\"MemorySwap,omitempty\" yaml:\"MemorySwap,omitempty\" toml:\"MemorySwap,omitempty\"`\n\tCPUShares            int64                  `json:\"CpuShares,omitempty\" yaml:\"CpuShares,omitempty\" toml:\"CpuShares,omitempty\"`\n\tCPUSet               string                 `json:\"Cpuset,omitempty\" yaml:\"Cpuset,omitempty\" toml:\"Cpuset,omitempty\"`\n\tCPUSetCPUs           string                 `json:\"CpusetCpus,omitempty\" yaml:\"CpusetCpus,omitempty\" toml:\"CpusetCpus,omitempty\"`\n\tCPUSetMEMs           string                 `json:\"CpusetMems,omitempty\" yaml:\"CpusetMems,omitempty\" toml:\"CpusetMems,omitempty\"`\n\tCPUQuota             int64                  `json:\"CpuQuota,omitempty\" yaml:\"CpuQuota,omitempty\" toml:\"CpuQuota,omitempty\"`\n\tCPUPeriod            int64                  `json:\"CpuPeriod,omitempty\" yaml:\"CpuPeriod,omitempty\" toml:\"CpuPeriod,omitempty\"`\n\tCPURealtimePeriod    int64                  `json:\"CpuRealtimePeriod,omitempty\" yaml:\"CpuRealtimePeriod,omitempty\" toml:\"CpuRealtimePeriod,omitempty\"`\n\tCPURealtimeRuntime   int64                  `json:\"CpuRealtimeRuntime,omitempty\" yaml:\"CpuRealtimeRuntime,omitempty\" toml:\"CpuRealtimeRuntime,omitempty\"`\n\tNanoCPUs             int64                  `json:\"NanoCpus,omitempty\" yaml:\"NanoCpus,omitempty\" toml:\"NanoCpus,omitempty\"`\n\tBlkioWeight          int64                  `json:\"BlkioWeight,omitempty\" yaml:\"BlkioWeight,omitempty\" toml:\"BlkioWeight,omitempty\"`\n\tBlkioWeightDevice    []BlockWeight          `json:\"BlkioWeightDevice,omitempty\" yaml:\"BlkioWeightDevice,omitempty\" toml:\"BlkioWeightDevice,omitempty\"`\n\tBlkioDeviceReadBps   []BlockLimit           `json:\"BlkioDeviceReadBps,omitempty\" yaml:\"BlkioDeviceReadBps,omitempty\" toml:\"BlkioDeviceReadBps,omitempty\"`\n\tBlkioDeviceReadIOps  []BlockLimit           `json:\"BlkioDeviceReadIOps,omitempty\" yaml:\"BlkioDeviceReadIOps,omitempty\" toml:\"BlkioDeviceReadIOps,omitempty\"`\n\tBlkioDeviceWriteBps  []BlockLimit           `json:\"BlkioDeviceWriteBps,omitempty\" yaml:\"BlkioDeviceWriteBps,omitempty\" toml:\"BlkioDeviceWriteBps,omitempty\"`\n\tBlkioDeviceWriteIOps []BlockLimit           `json:\"BlkioDeviceWriteIOps,omitempty\" yaml:\"BlkioDeviceWriteIOps,omitempty\" toml:\"BlkioDeviceWriteIOps,omitempty\"`\n\tUlimits              []ULimit               `json:\"Ulimits,omitempty\" yaml:\"Ulimits,omitempty\" toml:\"Ulimits,omitempty\"`\n\tVolumeDriver         string                 `json:\"VolumeDriver,omitempty\" yaml:\"VolumeDriver,omitempty\" toml:\"VolumeDriver,omitempty\"`\n\tOomScoreAdj          int                    `json:\"OomScoreAdj,omitempty\" yaml:\"OomScoreAdj,omitempty\" toml:\"OomScoreAdj,omitempty\"`\n\tMemorySwappiness     *int64                 `json:\"MemorySwappiness,omitempty\" yaml:\"MemorySwappiness,omitempty\" toml:\"MemorySwappiness,omitempty\"`\n\tPidsLimit            *int64                 `json:\"PidsLimit,omitempty\" yaml:\"PidsLimit,omitempty\" toml:\"PidsLimit,omitempty\"`\n\tOOMKillDisable       *bool                  `json:\"OomKillDisable,omitempty\" yaml:\"OomKillDisable,omitempty\" toml:\"OomKillDisable,omitempty\"`\n\tShmSize              int64                  `json:\"ShmSize,omitempty\" yaml:\"ShmSize,omitempty\" toml:\"ShmSize,omitempty\"`\n\tTmpfs                map[string]string      `json:\"Tmpfs,omitempty\" yaml:\"Tmpfs,omitempty\" toml:\"Tmpfs,omitempty\"`\n\tStorageOpt           map[string]string      `json:\"StorageOpt,omitempty\" yaml:\"StorageOpt,omitempty\" toml:\"StorageOpt,omitempty\"`\n\tSysctls              map[string]string      `json:\"Sysctls,omitempty\" yaml:\"Sysctls,omitempty\" toml:\"Sysctls,omitempty\"`\n\tCPUCount             int64                  `json:\"CpuCount,omitempty\" yaml:\"CpuCount,omitempty\"`\n\tCPUPercent           int64                  `json:\"CpuPercent,omitempty\" yaml:\"CpuPercent,omitempty\"`\n\tIOMaximumBandwidth   int64                  `json:\"IOMaximumBandwidth,omitempty\" yaml:\"IOMaximumBandwidth,omitempty\"`\n\tIOMaximumIOps        int64                  `json:\"IOMaximumIOps,omitempty\" yaml:\"IOMaximumIOps,omitempty\"`\n\tMounts               []HostMount            `json:\"Mounts,omitempty\" yaml:\"Mounts,omitempty\" toml:\"Mounts,omitempty\"`\n\tMaskedPaths          []string               `json:\"MaskedPaths,omitempty\" yaml:\"MaskedPaths,omitempty\" toml:\"MaskedPaths,omitempty\"`\n\tReadonlyPaths        []string               `json:\"ReadonlyPaths,omitempty\" yaml:\"ReadonlyPaths,omitempty\" toml:\"ReadonlyPaths,omitempty\"`\n\tRuntime              string                 `json:\"Runtime,omitempty\" yaml:\"Runtime,omitempty\" toml:\"Runtime,omitempty\"`\n\tInit                 bool                   `json:\",omitempty\" yaml:\",omitempty\"`\n\tPrivileged           bool                   `json:\"Privileged,omitempty\" yaml:\"Privileged,omitempty\" toml:\"Privileged,omitempty\"`\n\tPublishAllPorts      bool                   `json:\"PublishAllPorts,omitempty\" yaml:\"PublishAllPorts,omitempty\" toml:\"PublishAllPorts,omitempty\"`\n\tReadonlyRootfs       bool                   `json:\"ReadonlyRootfs,omitempty\" yaml:\"ReadonlyRootfs,omitempty\" toml:\"ReadonlyRootfs,omitempty\"`\n\tAutoRemove           bool                   `json:\"AutoRemove,omitempty\" yaml:\"AutoRemove,omitempty\" toml:\"AutoRemove,omitempty\"`\n\tAnnotations          map[string]string      `json:\"Annotations,omitempty\" yaml:\"Annotations,omitempty\" toml:\"Annotations,omitempty\"`\n}\n\n// NetworkingConfig represents the container's networking configuration for each of its interfaces\n// Carries the networking configs specified in the `docker run` and `docker network connect` commands\ntype NetworkingConfig struct {\n\tEndpointsConfig map[string]*EndpointConfig `json:\"EndpointsConfig\" yaml:\"EndpointsConfig\" toml:\"EndpointsConfig\"` // Endpoint configs for each connecting network\n}\n\n// NoSuchContainer is the error returned when a given container does not exist.\ntype NoSuchContainer struct {\n\tID  string\n\tErr error\n}\n\nfunc (err *NoSuchContainer) Error() string {\n\tif err.Err != nil {\n\t\treturn err.Err.Error()\n\t}\n\treturn \"No such container: \" + err.ID\n}\n\n// ContainerAlreadyRunning is the error returned when a given container is\n// already running.\ntype ContainerAlreadyRunning struct {\n\tID string\n}\n\nfunc (err *ContainerAlreadyRunning) Error() string {\n\treturn \"Container already running: \" + err.ID\n}\n\n// ContainerNotRunning is the error returned when a given container is not\n// running.\ntype ContainerNotRunning struct {\n\tID string\n}\n\nfunc (err *ContainerNotRunning) Error() string {\n\treturn \"Container not running: \" + err.ID\n}\n"
        },
        {
          "name": "container_archive.go",
          "type": "blob",
          "size": 1.7509765625,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// UploadToContainerOptions is the set of options that can be used when\n// uploading an archive into a container.\n//\n// See https://goo.gl/g25o7u for more details.\ntype UploadToContainerOptions struct {\n\tInputStream          io.Reader `json:\"-\" qs:\"-\"`\n\tPath                 string    `qs:\"path\"`\n\tNoOverwriteDirNonDir bool      `qs:\"noOverwriteDirNonDir\"`\n\tContext              context.Context\n}\n\n// UploadToContainer uploads a tar archive to be extracted to a path in the\n// filesystem of the container.\n//\n// See https://goo.gl/g25o7u for more details.\nfunc (c *Client) UploadToContainer(id string, opts UploadToContainerOptions) error {\n\turl := fmt.Sprintf(\"/containers/%s/archive?\", id) + queryString(opts)\n\n\treturn c.stream(http.MethodPut, url, streamOptions{\n\t\tin:      opts.InputStream,\n\t\tcontext: opts.Context,\n\t})\n}\n\n// DownloadFromContainerOptions is the set of options that can be used when\n// downloading resources from a container.\n//\n// See https://goo.gl/W49jxK for more details.\ntype DownloadFromContainerOptions struct {\n\tOutputStream      io.Writer     `json:\"-\" qs:\"-\"`\n\tPath              string        `qs:\"path\"`\n\tInactivityTimeout time.Duration `qs:\"-\"`\n\tContext           context.Context\n}\n\n// DownloadFromContainer downloads a tar archive of files or folders in a container.\n//\n// See https://goo.gl/W49jxK for more details.\nfunc (c *Client) DownloadFromContainer(id string, opts DownloadFromContainerOptions) error {\n\turl := fmt.Sprintf(\"/containers/%s/archive?\", id) + queryString(opts)\n\n\treturn c.stream(http.MethodGet, url, streamOptions{\n\t\tsetRawTerminal:    true,\n\t\tstdout:            opts.OutputStream,\n\t\tinactivityTimeout: opts.InactivityTimeout,\n\t\tcontext:           opts.Context,\n\t})\n}\n"
        },
        {
          "name": "container_archive_test.go",
          "type": "blob",
          "size": 1.41796875,
          "content": "package docker\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestUploadToContainer(t *testing.T) {\n\tt.Parallel()\n\tcontent := \"File content\"\n\tin := stdinMock{bytes.NewBufferString(content)}\n\tfakeRT := &FakeRoundTripper{status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := UploadToContainerOptions{\n\t\tPath:        \"abc\",\n\t\tInputStream: in,\n\t}\n\terr := client.UploadToContainer(\"a123456\", opts)\n\tif err != nil {\n\t\tt.Errorf(\"UploadToContainer: caught error %#v while uploading archive to container, expected nil\", err)\n\t}\n\n\treq := fakeRT.requests[0]\n\n\tif req.Method != http.MethodPut {\n\t\tt.Errorf(\"UploadToContainer{Path:abc}: Wrong HTTP method.  Want PUT. Got %s\", req.Method)\n\t}\n\n\tif pathParam := req.URL.Query().Get(\"path\"); pathParam != \"abc\" {\n\t\tt.Errorf(\"ListImages({Path:abc}): Wrong parameter. Want path=abc.  Got path=%s\", pathParam)\n\t}\n}\n\nfunc TestDownloadFromContainer(t *testing.T) {\n\tt.Parallel()\n\tfilecontent := \"File content\"\n\tclient := newTestClient(&FakeRoundTripper{message: filecontent, status: http.StatusOK})\n\n\tvar out bytes.Buffer\n\topts := DownloadFromContainerOptions{\n\t\tOutputStream: &out,\n\t}\n\terr := client.DownloadFromContainer(\"a123456\", opts)\n\tif err != nil {\n\t\tt.Errorf(\"DownloadFromContainer: caught error %#v while downloading from container, expected nil\", err.Error())\n\t}\n\tif out.String() != filecontent {\n\t\tt.Errorf(\"DownloadFromContainer: wrong stdout. Want %#v. Got %#v.\", filecontent, out.String())\n\t}\n}\n"
        },
        {
          "name": "container_attach.go",
          "type": "blob",
          "size": 1.984375,
          "content": "package docker\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\n// AttachToContainerOptions is the set of options that can be used when\n// attaching to a container.\n//\n// See https://goo.gl/JF10Zk for more details.\ntype AttachToContainerOptions struct {\n\tContainer    string    `qs:\"-\"`\n\tInputStream  io.Reader `qs:\"-\"`\n\tOutputStream io.Writer `qs:\"-\"`\n\tErrorStream  io.Writer `qs:\"-\"`\n\n\t// If set, after a successful connect, a sentinel will be sent and then the\n\t// client will block on receive before continuing.\n\t//\n\t// It must be an unbuffered channel. Using a buffered channel can lead\n\t// to unexpected behavior.\n\tSuccess chan struct{}\n\n\t// Override the key sequence for detaching a container.\n\tDetachKeys string\n\n\t// Use raw terminal? Usually true when the container contains a TTY.\n\tRawTerminal bool `qs:\"-\"`\n\n\t// Get container logs, sending it to OutputStream.\n\tLogs bool\n\n\t// Stream the response?\n\tStream bool\n\n\t// Attach to stdin, and use InputStream.\n\tStdin bool\n\n\t// Attach to stdout, and use OutputStream.\n\tStdout bool\n\n\t// Attach to stderr, and use ErrorStream.\n\tStderr bool\n}\n\n// AttachToContainer attaches to a container, using the given options.\n//\n// See https://goo.gl/JF10Zk for more details.\nfunc (c *Client) AttachToContainer(opts AttachToContainerOptions) error {\n\tcw, err := c.AttachToContainerNonBlocking(opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn cw.Wait()\n}\n\n// AttachToContainerNonBlocking attaches to a container, using the given options.\n// This function does not block.\n//\n// See https://goo.gl/NKpkFk for more details.\nfunc (c *Client) AttachToContainerNonBlocking(opts AttachToContainerOptions) (CloseWaiter, error) {\n\tif opts.Container == \"\" {\n\t\treturn nil, &NoSuchContainer{ID: opts.Container}\n\t}\n\tpath := \"/containers/\" + opts.Container + \"/attach?\" + queryString(opts)\n\treturn c.hijack(http.MethodPost, path, hijackOptions{\n\t\tsuccess:        opts.Success,\n\t\tsetRawTerminal: opts.RawTerminal,\n\t\tin:             opts.InputStream,\n\t\tstdout:         opts.OutputStream,\n\t\tstderr:         opts.ErrorStream,\n\t})\n}\n"
        },
        {
          "name": "container_attach_test.go",
          "type": "blob",
          "size": 7.69140625,
          "content": "package docker\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestAttachToContainerLogs(t *testing.T) {\n\tt.Parallel()\n\tvar req http.Request\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte{1, 0, 0, 0, 0, 0, 0, 19})\n\t\tw.Write([]byte(\"something happened!\"))\n\t\treq = *r\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar buf bytes.Buffer\n\topts := AttachToContainerOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: &buf,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tLogs:         true,\n\t}\n\terr := client.AttachToContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"something happened!\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"AttachToContainer for logs: wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"AttachToContainer: wrong HTTP method. Want POST. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/containers/a123456/attach\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"AttachToContainer for logs: wrong HTTP path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpectedQs := map[string][]string{\n\t\t\"logs\":   {\"1\"},\n\t\t\"stdout\": {\"1\"},\n\t\t\"stderr\": {\"1\"},\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expectedQs) {\n\t\tt.Errorf(\"AttachToContainer: wrong query string. Want %#v. Got %#v.\", expectedQs, got)\n\t}\n}\n\nfunc TestAttachToContainer(t *testing.T) {\n\tt.Parallel()\n\treader := strings.NewReader(\"send value\")\n\tvar req http.Request\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte{1, 0, 0, 0, 0, 0, 0, 5})\n\t\tw.Write([]byte(\"hello\"))\n\t\treq = *r\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar stdout, stderr bytes.Buffer\n\topts := AttachToContainerOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: &stdout,\n\t\tErrorStream:  &stderr,\n\t\tInputStream:  reader,\n\t\tStdin:        true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tStream:       true,\n\t\tRawTerminal:  true,\n\t}\n\terr := client.AttachToContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := map[string][]string{\n\t\t\"stdin\":  {\"1\"},\n\t\t\"stdout\": {\"1\"},\n\t\t\"stderr\": {\"1\"},\n\t\t\"stream\": {\"1\"},\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"AttachToContainer: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n}\n\nfunc TestAttachToContainerSentinel(t *testing.T) {\n\tt.Parallel()\n\treader := strings.NewReader(\"send value\")\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte{1, 0, 0, 0, 0, 0, 0, 5})\n\t\tw.Write([]byte(\"hello\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar stdout, stderr bytes.Buffer\n\tsuccess := make(chan struct{})\n\topts := AttachToContainerOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: &stdout,\n\t\tErrorStream:  &stderr,\n\t\tInputStream:  reader,\n\t\tStdin:        true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tStream:       true,\n\t\tRawTerminal:  true,\n\t\tSuccess:      success,\n\t}\n\terrCh := make(chan error)\n\tgo func() {\n\t\terrCh <- client.AttachToContainer(opts)\n\t}()\n\tsuccess <- <-success\n\tif err := <-errCh; err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestAttachToContainerNilStdout(t *testing.T) {\n\tt.Parallel()\n\treader := strings.NewReader(\"send value\")\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte{1, 0, 0, 0, 0, 0, 0, 5})\n\t\tw.Write([]byte(\"hello\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar stderr bytes.Buffer\n\topts := AttachToContainerOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: nil,\n\t\tErrorStream:  &stderr,\n\t\tInputStream:  reader,\n\t\tStdin:        true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tStream:       true,\n\t\tRawTerminal:  true,\n\t}\n\terr := client.AttachToContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestAttachToContainerNilStderr(t *testing.T) {\n\tt.Parallel()\n\treader := strings.NewReader(\"send value\")\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte{1, 0, 0, 0, 0, 0, 0, 5})\n\t\tw.Write([]byte(\"hello\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar stdout bytes.Buffer\n\topts := AttachToContainerOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: &stdout,\n\t\tInputStream:  reader,\n\t\tStdin:        true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tStream:       true,\n\t\tRawTerminal:  true,\n\t}\n\terr := client.AttachToContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestAttachToContainerStdinOnly(t *testing.T) {\n\tt.Parallel()\n\treader := strings.NewReader(\"send value\")\n\tserverFinished := make(chan struct{})\n\tclientFinished := make(chan struct{})\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\thj, ok := w.(http.Hijacker)\n\t\tif !ok {\n\t\t\tt.Fatal(\"cannot hijack server connection\")\n\t\t}\n\t\tconn, _, err := hj.Hijack()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// wait for client to indicate it's finished\n\t\t<-clientFinished\n\t\t// inform test that the server has finished\n\t\tclose(serverFinished)\n\t\tconn.Close()\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tsuccess := make(chan struct{})\n\topts := AttachToContainerOptions{\n\t\tContainer:   \"a123456\",\n\t\tInputStream: reader,\n\t\tStdin:       true,\n\t\tStdout:      false,\n\t\tStderr:      false,\n\t\tStream:      true,\n\t\tRawTerminal: false,\n\t\tSuccess:     success,\n\t}\n\tgo func() {\n\t\tif err := client.AttachToContainer(opts); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\t// client's attach session is over\n\t\tclose(clientFinished)\n\t}()\n\tsuccess <- <-success\n\t// wait for server to finish handling attach\n\t<-serverFinished\n}\n\nfunc TestAttachToContainerRawTerminalFalse(t *testing.T) {\n\tt.Parallel()\n\tinput := strings.NewReader(\"send value\")\n\tvar req http.Request\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\treq = *r\n\t\tw.WriteHeader(http.StatusOK)\n\t\thj, ok := w.(http.Hijacker)\n\t\tif !ok {\n\t\t\tt.Fatal(\"cannot hijack server connection\")\n\t\t}\n\t\tconn, _, err := hj.Hijack()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tconn.Write([]byte{1, 0, 0, 0, 0, 0, 0, 5})\n\t\tconn.Write([]byte(\"hello\"))\n\t\tconn.Write([]byte{2, 0, 0, 0, 0, 0, 0, 6})\n\t\tconn.Write([]byte(\"hello!\"))\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tconn.Close()\n\t}))\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar stdout, stderr bytes.Buffer\n\topts := AttachToContainerOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: &stdout,\n\t\tErrorStream:  &stderr,\n\t\tInputStream:  input,\n\t\tStdin:        true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tStream:       true,\n\t\tRawTerminal:  false,\n\t}\n\tclient.AttachToContainer(opts)\n\texpected := map[string][]string{\n\t\t\"stdin\":  {\"1\"},\n\t\t\"stdout\": {\"1\"},\n\t\t\"stderr\": {\"1\"},\n\t\t\"stream\": {\"1\"},\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\tserver.Close()\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"AttachToContainer: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n\tif stdout.String() != \"hello\" {\n\t\tt.Errorf(\"AttachToContainer: wrong content written to stdout. Want %q. Got %q.\", \"hello\", stdout.String())\n\t}\n\tif stderr.String() != \"hello!\" {\n\t\tt.Errorf(\"AttachToContainer: wrong content written to stderr. Want %q. Got %q.\", \"hello!\", stderr.String())\n\t}\n}\n\nfunc TestAttachToContainerWithoutContainer(t *testing.T) {\n\tt.Parallel()\n\tvar client Client\n\terr := client.AttachToContainer(AttachToContainerOptions{})\n\texpectNoSuchContainer(t, \"\", err)\n}\n"
        },
        {
          "name": "container_changes.go",
          "type": "blob",
          "size": 0.658203125,
          "content": "package docker\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\n// ContainerChanges returns changes in the filesystem of the given container.\n//\n// See https://goo.gl/15KKzh for more details.\nfunc (c *Client) ContainerChanges(id string) ([]Change, error) {\n\tpath := \"/containers/\" + id + \"/changes\"\n\tresp, err := c.do(http.MethodGet, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchContainer{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar changes []Change\n\tif err := json.NewDecoder(resp.Body).Decode(&changes); err != nil {\n\t\treturn nil, err\n\t}\n\treturn changes, nil\n}\n"
        },
        {
          "name": "container_changes_test.go",
          "type": "blob",
          "size": 1.9150390625,
          "content": "package docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestContainerChanges(t *testing.T) {\n\tt.Parallel()\n\tjsonChanges := `[\n     {\n             \"Path\":\"/dev\",\n             \"Kind\":0\n     },\n     {\n             \"Path\":\"/dev/kmsg\",\n             \"Kind\":1\n     },\n     {\n             \"Path\":\"/test\",\n             \"Kind\":1\n     }\n]`\n\tvar expected []Change\n\terr := json.Unmarshal([]byte(jsonChanges), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonChanges, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c678\"\n\tchanges, err := client.ContainerChanges(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(changes, expected) {\n\t\tt.Errorf(\"ContainerChanges(%q): Expected %#v. Got %#v.\", id, expected, changes)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/4fa6e0f0c678/changes\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"ContainerChanges(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestContainerChangesFailure(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"server error\", status: 500})\n\texpected := Error{Status: 500, Message: \"server error\"}\n\tchanges, err := client.ContainerChanges(\"abe033\")\n\tif changes != nil {\n\t\tt.Errorf(\"ContainerChanges: Expected <nil> changes, got %#v\", changes)\n\t}\n\tif !reflect.DeepEqual(expected, *err.(*Error)) {\n\t\tt.Errorf(\"ContainerChanges: Wrong error information. Want %#v. Got %#v.\", expected, err)\n\t}\n}\n\nfunc TestContainerChangesNotFound(t *testing.T) {\n\tt.Parallel()\n\tconst containerID = \"abe033\"\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: 404})\n\tchanges, err := client.ContainerChanges(containerID)\n\tif changes != nil {\n\t\tt.Errorf(\"ContainerChanges: Expected <nil> changes, got %#v\", changes)\n\t}\n\texpectNoSuchContainer(t, containerID, err)\n}\n"
        },
        {
          "name": "container_commit.go",
          "type": "blob",
          "size": 1.0986328125,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\n// CommitContainerOptions aggregates parameters to the CommitContainer method.\n//\n// See https://goo.gl/CzIguf for more details.\ntype CommitContainerOptions struct {\n\tContainer  string\n\tRepository string `qs:\"repo\"`\n\tTag        string\n\tMessage    string `qs:\"comment\"`\n\tAuthor     string\n\tChanges    []string `qs:\"changes\"`\n\tRun        *Config  `qs:\"-\"`\n\tContext    context.Context\n}\n\n// CommitContainer creates a new image from a container's changes.\n//\n// See https://goo.gl/CzIguf for more details.\nfunc (c *Client) CommitContainer(opts CommitContainerOptions) (*Image, error) {\n\tpath := \"/commit?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\tdata:    opts.Run,\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchContainer{ID: opts.Container}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar image Image\n\tif err := json.NewDecoder(resp.Body).Decode(&image); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &image, nil\n}\n"
        },
        {
          "name": "container_commit_test.go",
          "type": "blob",
          "size": 2.8408203125,
          "content": "package docker\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCommitContainer(t *testing.T) {\n\tt.Parallel()\n\tresponse := `{\"Id\":\"596069db4bf5\"}`\n\tclient := newTestClient(&FakeRoundTripper{message: response, status: http.StatusOK})\n\tid := \"596069db4bf5\"\n\timage, err := client.CommitContainer(CommitContainerOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif image.ID != id {\n\t\tt.Errorf(\"CommitContainer: Wrong image id. Want %q. Got %q.\", id, image.ID)\n\t}\n}\n\nfunc TestCommitContainerParams(t *testing.T) {\n\tt.Parallel()\n\tcfg := Config{Memory: 67108864}\n\tjson, _ := json.Marshal(&cfg)\n\ttests := []struct {\n\t\tinput  CommitContainerOptions\n\t\tparams map[string][]string\n\t\tbody   []byte\n\t}{\n\t\t{CommitContainerOptions{}, map[string][]string{}, nil},\n\t\t{CommitContainerOptions{Container: \"44c004db4b17\"}, map[string][]string{\"container\": {\"44c004db4b17\"}}, nil},\n\t\t{\n\t\t\tCommitContainerOptions{Container: \"44c004db4b17\", Repository: \"tsuru/python\", Message: \"something\"},\n\t\t\tmap[string][]string{\"container\": {\"44c004db4b17\"}, \"repo\": {\"tsuru/python\"}, \"comment\": {\"something\"}},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\tCommitContainerOptions{Container: \"44c004db4b17\", Run: &cfg},\n\t\t\tmap[string][]string{\"container\": {\"44c004db4b17\"}},\n\t\t\tjson,\n\t\t},\n\t}\n\tconst expectedPath = \"/commit\"\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tfakeRT := &FakeRoundTripper{message: \"{}\", status: http.StatusOK}\n\t\t\tclient := newTestClient(fakeRT)\n\t\t\tif _, err := client.CommitContainer(test.input); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tgot := map[string][]string(fakeRT.requests[0].URL.Query())\n\t\t\tif !reflect.DeepEqual(got, test.params) {\n\t\t\t\tt.Errorf(\"Expected %#v, got %#v.\", test.params, got)\n\t\t\t}\n\t\t\tif path := fakeRT.requests[0].URL.Path; path != expectedPath {\n\t\t\t\tt.Errorf(\"Wrong path on request. Want %q. Got %q.\", expectedPath, path)\n\t\t\t}\n\t\t\tif meth := fakeRT.requests[0].Method; meth != http.MethodPost {\n\t\t\t\tt.Errorf(\"Wrong HTTP method. Want POST. Got %s.\", meth)\n\t\t\t}\n\t\t\tif test.body != nil {\n\t\t\t\tif requestBody, err := io.ReadAll(fakeRT.requests[0].Body); err == nil {\n\t\t\t\t\tif !bytes.Equal(requestBody, test.body) {\n\t\t\t\t\t\tt.Errorf(\"Expected body %#v, got %#v\", test.body, requestBody)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"Error reading request body: %#v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommitContainerFailure(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusInternalServerError})\n\t_, err := client.CommitContainer(CommitContainerOptions{})\n\tif err == nil {\n\t\tt.Error(\"Expected non-nil error, got <nil>.\")\n\t}\n}\n\nfunc TestCommitContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\t_, err := client.CommitContainer(CommitContainerOptions{})\n\texpectNoSuchContainer(t, \"\", err)\n}\n"
        },
        {
          "name": "container_copy.go",
          "type": "blob",
          "size": 1.3701171875,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// CopyFromContainerOptions contains the set of options used for copying\n// files from a container.\n//\n// Deprecated: Use DownloadFromContainerOptions and DownloadFromContainer instead.\ntype CopyFromContainerOptions struct {\n\tOutputStream io.Writer `json:\"-\"`\n\tContainer    string    `json:\"-\"`\n\tResource     string\n\tContext      context.Context `json:\"-\"`\n}\n\n// CopyFromContainer copies files from a container.\n//\n// Deprecated: Use DownloadFromContainer and DownloadFromContainer instead.\nfunc (c *Client) CopyFromContainer(opts CopyFromContainerOptions) error {\n\tif opts.Container == \"\" {\n\t\treturn &NoSuchContainer{ID: opts.Container}\n\t}\n\tif c.serverAPIVersion == nil {\n\t\tc.checkAPIVersion()\n\t}\n\tif c.serverAPIVersion != nil && c.serverAPIVersion.GreaterThanOrEqualTo(apiVersion124) {\n\t\treturn errors.New(\"go-dockerclient: CopyFromContainer is no longer available in Docker >= 1.12, use DownloadFromContainer instead\")\n\t}\n\turl := fmt.Sprintf(\"/containers/%s/copy\", opts.Container)\n\tresp, err := c.do(http.MethodPost, url, doOptions{\n\t\tdata:    opts,\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchContainer{ID: opts.Container}\n\t\t}\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\t_, err = io.Copy(opts.OutputStream, resp.Body)\n\treturn err\n}\n"
        },
        {
          "name": "container_copy_test.go",
          "type": "blob",
          "size": 1.5263671875,
          "content": "package docker\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestCopyFromContainer(t *testing.T) {\n\tt.Parallel()\n\tcontent := \"File content\"\n\tout := stdoutMock{bytes.NewBufferString(content)}\n\tclient := newTestClient(&FakeRoundTripper{status: http.StatusOK})\n\topts := CopyFromContainerOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: &out,\n\t}\n\terr := client.CopyFromContainer(opts)\n\tif err != nil {\n\t\tt.Errorf(\"CopyFromContainer: caught error %#v while copying from container, expected nil\", err.Error())\n\t}\n\tif out.String() != content {\n\t\tt.Errorf(\"CopyFromContainer: wrong stdout. Want %#v. Got %#v.\", content, out.String())\n\t}\n}\n\nfunc TestCopyFromContainerEmptyContainer(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{status: http.StatusOK})\n\terr := client.CopyFromContainer(CopyFromContainerOptions{})\n\t_, ok := err.(*NoSuchContainer)\n\tif !ok {\n\t\tt.Errorf(\"CopyFromContainer: invalid error returned. Want NoSuchContainer, got %#v.\", err)\n\t}\n}\n\nfunc TestCopyFromContainerDockerAPI124(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{status: http.StatusOK})\n\tclient.serverAPIVersion = apiVersion124\n\topts := CopyFromContainerOptions{\n\t\tContainer: \"a123456\",\n\t}\n\terr := client.CopyFromContainer(opts)\n\tif err == nil {\n\t\tt.Fatal(\"got unexpected <nil> error\")\n\t}\n\texpectedMsg := \"go-dockerclient: CopyFromContainer is no longer available in Docker >= 1.12, use DownloadFromContainer instead\"\n\tif err.Error() != expectedMsg {\n\t\tt.Errorf(\"wrong error message\\nWant %q\\nGot  %q\", expectedMsg, err.Error())\n\t}\n}\n"
        },
        {
          "name": "container_create.go",
          "type": "blob",
          "size": 2.2490234375,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// ErrContainerAlreadyExists is the error returned by CreateContainer when the\n// container already exists.\nvar ErrContainerAlreadyExists = errors.New(\"container already exists\")\n\n// CreateContainerOptions specify parameters to the CreateContainer function.\n//\n// See https://goo.gl/tyzwVM for more details.\ntype CreateContainerOptions struct {\n\tName             string\n\tPlatform         string\n\tConfig           *Config           `qs:\"-\"`\n\tHostConfig       *HostConfig       `qs:\"-\"`\n\tNetworkingConfig *NetworkingConfig `qs:\"-\"`\n\tContext          context.Context\n}\n\n// CreateContainer creates a new container, returning the container instance,\n// or an error in case of failure.\n//\n// The returned container instance contains only the container ID. To get more\n// details about the container after creating it, use InspectContainer.\n//\n// See https://goo.gl/tyzwVM for more details.\nfunc (c *Client) CreateContainer(opts CreateContainerOptions) (*Container, error) {\n\tpath := \"/containers/create?\" + queryString(opts)\n\tresp, err := c.do(\n\t\thttp.MethodPost,\n\t\tpath,\n\t\tdoOptions{\n\t\t\tdata: struct {\n\t\t\t\t*Config\n\t\t\t\tHostConfig       *HostConfig       `json:\"HostConfig,omitempty\" yaml:\"HostConfig,omitempty\" toml:\"HostConfig,omitempty\"`\n\t\t\t\tNetworkingConfig *NetworkingConfig `json:\"NetworkingConfig,omitempty\" yaml:\"NetworkingConfig,omitempty\" toml:\"NetworkingConfig,omitempty\"`\n\t\t\t}{\n\t\t\t\topts.Config,\n\t\t\t\topts.HostConfig,\n\t\t\t\topts.NetworkingConfig,\n\t\t\t},\n\t\t\tcontext: opts.Context,\n\t\t},\n\t)\n\n\tvar e *Error\n\tif errors.As(err, &e) {\n\t\tif e.Status == http.StatusNotFound && strings.Contains(e.Message, \"No such image\") {\n\t\t\treturn nil, ErrNoSuchImage\n\t\t}\n\t\tif e.Status == http.StatusConflict {\n\t\t\treturn nil, ErrContainerAlreadyExists\n\t\t}\n\t\t// Workaround for 17.09 bug returning 400 instead of 409.\n\t\t// See https://github.com/moby/moby/issues/35021\n\t\tif e.Status == http.StatusBadRequest && strings.Contains(e.Message, \"Conflict.\") {\n\t\t\treturn nil, ErrContainerAlreadyExists\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar container Container\n\tif err := json.NewDecoder(resp.Body).Decode(&container); err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontainer.Name = opts.Name\n\n\treturn &container, nil\n}\n"
        },
        {
          "name": "container_create_test.go",
          "type": "blob",
          "size": 5.24609375,
          "content": "package docker\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestCreateContainer(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\n             \"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\",\n\t     \"Warnings\": []\n}`\n\tvar expected Container\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tconfig := Config{AttachStdout: true, AttachStdin: true}\n\topts := CreateContainerOptions{Name: \"TestCreateContainer\", Config: &config}\n\tcontainer, err := client.CreateContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tif container.ID != id {\n\t\tt.Errorf(\"CreateContainer: wrong ID. Want %q. Got %q.\", id, container.ID)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"CreateContainer: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/create\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"CreateContainer: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\tvar gotBody Config\n\terr = json.NewDecoder(req.Body).Decode(&gotBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestCreateContainerImageNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"No such image: whatever\", status: http.StatusNotFound})\n\tconfig := Config{AttachStdout: true, AttachStdin: true}\n\tcontainer, err := client.CreateContainer(CreateContainerOptions{Config: &config})\n\tif container != nil {\n\t\tt.Errorf(\"CreateContainer: expected <nil> container, got %#v.\", container)\n\t}\n\tif !errors.Is(err, ErrNoSuchImage) {\n\t\tt.Errorf(\"CreateContainer: Wrong error type. Want %#v. Got %#v.\", ErrNoSuchImage, err)\n\t}\n}\n\nfunc TestCreateContainerDuplicateName(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"No such image\", status: http.StatusConflict})\n\tconfig := Config{AttachStdout: true, AttachStdin: true}\n\tcontainer, err := client.CreateContainer(CreateContainerOptions{Config: &config})\n\tif container != nil {\n\t\tt.Errorf(\"CreateContainer: expected <nil> container, got %#v.\", container)\n\t}\n\tif !errors.Is(err, ErrContainerAlreadyExists) {\n\t\tt.Errorf(\"CreateContainer: Wrong error type. Want %#v. Got %#v.\", ErrContainerAlreadyExists, err)\n\t}\n}\n\n// Workaround for 17.09 bug returning 400 instead of 409.\n// See https://github.com/moby/moby/issues/35021\nfunc TestCreateContainerDuplicateNameWorkaroundDocker17_09(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: `{\"message\":\"Conflict. The container name \\\"/c1\\\" is already in use by container \\\"2ce137e165dfca5e087f247b5d05a2311f91ef3da4bb7772168446a1a47e2f68\\\". You have to remove (or rename) that container to be able to reuse that name.\"}`, status: http.StatusBadRequest})\n\tconfig := Config{AttachStdout: true, AttachStdin: true}\n\tcontainer, err := client.CreateContainer(CreateContainerOptions{Config: &config})\n\tif container != nil {\n\t\tt.Errorf(\"CreateContainer: expected <nil> container, got %#v.\", container)\n\t}\n\tif !errors.Is(err, ErrContainerAlreadyExists) {\n\t\tt.Errorf(\"CreateContainer: Wrong error type. Want %#v. Got %#v.\", ErrContainerAlreadyExists, err)\n\t}\n}\n\nfunc TestCreateContainerWithHostConfig(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"{}\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tconfig := Config{}\n\thostConfig := HostConfig{PublishAllPorts: true}\n\topts := CreateContainerOptions{Name: \"TestCreateContainerWithHostConfig\", Config: &config, HostConfig: &hostConfig}\n\t_, err := client.CreateContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tvar gotBody map[string]any\n\terr = json.NewDecoder(req.Body).Decode(&gotBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, ok := gotBody[\"HostConfig\"]; !ok {\n\t\tt.Errorf(\"CreateContainer: wrong body. HostConfig was not serialized\")\n\t}\n}\n\nfunc TestPassingNameOptToCreateContainerReturnsItInContainer(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\n             \"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\",\n\t     \"Warnings\": []\n}`\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tconfig := Config{AttachStdout: true, AttachStdin: true}\n\topts := CreateContainerOptions{Name: \"TestCreateContainer\", Config: &config}\n\tcontainer, err := client.CreateContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif container.Name != \"TestCreateContainer\" {\n\t\tt.Errorf(\"Container name expected to be TestCreateContainer, was %s\", container.Name)\n\t}\n}\n\nfunc TestPassingPlatformOpt(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"{}\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tconfig := Config{}\n\topts := CreateContainerOptions{Name: \"TestCreateContainerWithPlatform\", Platform: \"darwin/arm64\", Config: &config}\n\t_, err := client.CreateContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tgotQs := req.URL.Query().Get(\"platform\")\n\tif gotQs != \"darwin/arm64\" {\n\t\tt.Errorf(\"CreateContainer: missing expected platform query string (%v)\", req.URL.RequestURI())\n\t}\n}\n"
        },
        {
          "name": "container_export.go",
          "type": "blob",
          "size": 0.916015625,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ExportContainerOptions is the set of parameters to the ExportContainer\n// method.\n//\n// See https://goo.gl/yGJCIh for more details.\ntype ExportContainerOptions struct {\n\tID                string\n\tOutputStream      io.Writer\n\tInactivityTimeout time.Duration `qs:\"-\"`\n\tContext           context.Context\n}\n\n// ExportContainer export the contents of container id as tar archive\n// and prints the exported contents to stdout.\n//\n// See https://goo.gl/yGJCIh for more details.\nfunc (c *Client) ExportContainer(opts ExportContainerOptions) error {\n\tif opts.ID == \"\" {\n\t\treturn &NoSuchContainer{ID: opts.ID}\n\t}\n\turl := fmt.Sprintf(\"/containers/%s/export\", opts.ID)\n\treturn c.stream(http.MethodGet, url, streamOptions{\n\t\tsetRawTerminal:    true,\n\t\tstdout:            opts.OutputStream,\n\t\tinactivityTimeout: opts.InactivityTimeout,\n\t\tcontext:           opts.Context,\n\t})\n}\n"
        },
        {
          "name": "container_export_test.go",
          "type": "blob",
          "size": 1.0166015625,
          "content": "package docker\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestExportContainer(t *testing.T) {\n\tt.Parallel()\n\tcontent := \"exported container tar content\"\n\tout := stdoutMock{bytes.NewBufferString(content)}\n\tclient := newTestClient(&FakeRoundTripper{status: http.StatusOK})\n\topts := ExportContainerOptions{ID: \"4fa6e0f0c678\", OutputStream: out}\n\terr := client.ExportContainer(opts)\n\tif err != nil {\n\t\tt.Errorf(\"ExportContainer: caugh error %#v while exporting container, expected nil\", err.Error())\n\t}\n\tif out.String() != content {\n\t\tt.Errorf(\"ExportContainer: wrong stdout. Want %#v. Got %#v.\", content, out.String())\n\t}\n}\n\nfunc TestExportContainerNoId(t *testing.T) {\n\tt.Parallel()\n\tclient := Client{}\n\tout := stdoutMock{bytes.NewBufferString(\"\")}\n\terr := client.ExportContainer(ExportContainerOptions{OutputStream: out})\n\te, ok := err.(*NoSuchContainer)\n\tif !ok {\n\t\tt.Errorf(\"ExportContainer: wrong error. Want NoSuchContainer. Got %#v.\", e)\n\t}\n\tif e.ID != \"\" {\n\t\tt.Errorf(\"ExportContainer: wrong ID. Want %q. Got %q\", \"\", e.ID)\n\t}\n}\n"
        },
        {
          "name": "container_inspect.go",
          "type": "blob",
          "size": 1.638671875,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\n// InspectContainer returns information about a container by its ID.\n//\n// Deprecated: Use InspectContainerWithOptions instead.\nfunc (c *Client) InspectContainer(id string) (*Container, error) {\n\treturn c.InspectContainerWithOptions(InspectContainerOptions{ID: id})\n}\n\n// InspectContainerWithContext returns information about a container by its ID.\n// The context object can be used to cancel the inspect request.\n//\n// Deprecated: Use InspectContainerWithOptions instead.\nfunc (c *Client) InspectContainerWithContext(id string, ctx context.Context) (*Container, error) {\n\treturn c.InspectContainerWithOptions(InspectContainerOptions{ID: id, Context: ctx})\n}\n\n// InspectContainerWithOptions returns information about a container by its ID.\n//\n// See https://goo.gl/FaI5JT for more details.\nfunc (c *Client) InspectContainerWithOptions(opts InspectContainerOptions) (*Container, error) {\n\tpath := \"/containers/\" + opts.ID + \"/json?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchContainer{ID: opts.ID}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar container Container\n\tif err := json.NewDecoder(resp.Body).Decode(&container); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &container, nil\n}\n\n// InspectContainerOptions specifies parameters for InspectContainerWithOptions.\n//\n// See https://goo.gl/FaI5JT for more details.\ntype InspectContainerOptions struct {\n\tContext context.Context\n\tID      string `qs:\"-\"`\n\tSize    bool\n}\n"
        },
        {
          "name": "container_inspect_test.go",
          "type": "blob",
          "size": 26.7724609375,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestInspectContainer(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\n             \"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\",\n             \"AppArmorProfile\": \"Profile\",\n             \"Created\": \"2013-05-07T14:51:42.087658+02:00\",\n             \"Path\": \"date\",\n             \"Args\": [],\n             \"Config\": {\n                     \"Hostname\": \"4fa6e0f0c678\",\n                     \"User\": \"\",\n                     \"Memory\": 17179869184,\n                     \"MemorySwap\": 34359738368,\n                     \"AttachStdin\": false,\n                     \"AttachStdout\": true,\n                     \"AttachStderr\": true,\n                     \"PortSpecs\": null,\n                     \"Tty\": false,\n                     \"OpenStdin\": false,\n                     \"StdinOnce\": false,\n                     \"Env\": null,\n                     \"Cmd\": [\n                             \"date\"\n                     ],\n                     \"Image\": \"base\",\n                     \"Volumes\": {},\n                     \"VolumesFrom\": \"\",\n                     \"SecurityOpt\": [\n                         \"label:user:USER\"\n                      ],\n                      \"Ulimits\": [\n                          { \"Name\": \"nofile\", \"Soft\": 1024, \"Hard\": 2048 }\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t\t\"Shell\": [\n                         \"/bin/sh\", \"-c\"\n\t\t\t\t\t\t\t\t\t\t\t]\n             },\n             \"State\": {\n                     \"Running\": false,\n                     \"Pid\": 0,\n                     \"ExitCode\": 0,\n                     \"StartedAt\": \"2013-05-07T14:51:42.087658+02:00\",\n                     \"Ghost\": false\n             },\n             \"Node\": {\n                  \"ID\": \"4I4E:QR4I:Z733:QEZK:5X44:Q4T7:W2DD:JRDY:KB2O:PODO:Z5SR:XRB6\",\n                  \"IP\": \"192.168.99.105\",\n                  \"Addra\": \"192.168.99.105:2376\",\n                  \"Name\": \"node-01\",\n                  \"Cpus\": 4,\n                  \"Memory\": 1048436736,\n                  \"Labels\": {\n                      \"executiondriver\": \"native-0.2\",\n                      \"kernelversion\": \"3.18.5-tinycore64\",\n                      \"operatingsystem\": \"Boot2Docker 1.5.0 (TCL 5.4); master : a66bce5 - Tue Feb 10 23:31:27 UTC 2015\",\n                      \"provider\": \"virtualbox\",\n                      \"storagedriver\": \"aufs\"\n                  }\n              },\n             \"Image\": \"b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\",\n             \"NetworkSettings\": {\n                     \"IpAddress\": \"\",\n                     \"IpPrefixLen\": 0,\n                     \"Gateway\": \"\",\n                     \"Bridge\": \"\",\n                     \"PortMapping\": null\n             },\n             \"SysInitPath\": \"/home/kitty/go/src/github.com/dotcloud/docker/bin/docker\",\n             \"ResolvConfPath\": \"/etc/resolv.conf\",\n             \"Volumes\": {},\n             \"HostConfig\": {\n               \"Binds\": null,\n               \"ContainerIDFile\": \"\",\n               \"LxcConf\": [],\n               \"Privileged\": false,\n               \"PortBindings\": {\n                 \"80/tcp\": [\n                   {\n                     \"HostIp\": \"0.0.0.0\",\n                     \"HostPort\": \"49153\"\n                   }\n                 ]\n               },\n               \"Links\": null,\n               \"PublishAllPorts\": false,\n               \"CgroupParent\": \"/mesos\",\n               \"Memory\": 17179869184,\n               \"MemorySwap\": 34359738368,\n               \"GroupAdd\": [\"fake\", \"12345\"],\n               \"OomScoreAdj\": 642\n             }\n}`\n\tvar expected Container\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c678\"\n\tcontainer, err := client.InspectContainer(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*container, expected) {\n\t\tt.Errorf(\"InspectContainer(%q): Expected %#v. Got %#v.\", id, expected, container)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/4fa6e0f0c678/json\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"InspectContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestInspectContainerWithContext(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\n             \"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\",\n             \"AppArmorProfile\": \"Profile\",\n             \"Created\": \"2013-05-07T14:51:42.087658+02:00\",\n             \"Path\": \"date\",\n             \"Args\": [],\n             \"Config\": {\n                     \"Hostname\": \"4fa6e0f0c678\",\n                     \"User\": \"\",\n                     \"Memory\": 17179869184,\n                     \"MemorySwap\": 34359738368,\n                     \"AttachStdin\": false,\n                     \"AttachStdout\": true,\n                     \"AttachStderr\": true,\n                     \"PortSpecs\": null,\n                     \"Tty\": false,\n                     \"OpenStdin\": false,\n                     \"StdinOnce\": false,\n                     \"Env\": null,\n                     \"Cmd\": [\n                             \"date\"\n                     ],\n                     \"Image\": \"base\",\n                     \"Volumes\": {},\n                     \"VolumesFrom\": \"\",\n                     \"SecurityOpt\": [\n                         \"label:user:USER\"\n                      ],\n                      \"Ulimits\": [\n                          { \"Name\": \"nofile\", \"Soft\": 1024, \"Hard\": 2048 }\n                      ]\n             },\n             \"State\": {\n                     \"Running\": false,\n                     \"Pid\": 0,\n                     \"ExitCode\": 0,\n                     \"StartedAt\": \"2013-05-07T14:51:42.087658+02:00\",\n                     \"Ghost\": false\n             },\n             \"Node\": {\n                  \"ID\": \"4I4E:QR4I:Z733:QEZK:5X44:Q4T7:W2DD:JRDY:KB2O:PODO:Z5SR:XRB6\",\n                  \"IP\": \"192.168.99.105\",\n                  \"Addra\": \"192.168.99.105:2376\",\n                  \"Name\": \"node-01\",\n                  \"Cpus\": 4,\n                  \"Memory\": 1048436736,\n                  \"Labels\": {\n                      \"executiondriver\": \"native-0.2\",\n                      \"kernelversion\": \"3.18.5-tinycore64\",\n                      \"operatingsystem\": \"Boot2Docker 1.5.0 (TCL 5.4); master : a66bce5 - Tue Feb 10 23:31:27 UTC 2015\",\n                      \"provider\": \"virtualbox\",\n                      \"storagedriver\": \"aufs\"\n                  }\n              },\n             \"Image\": \"b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\",\n             \"NetworkSettings\": {\n                     \"IpAddress\": \"\",\n                     \"IpPrefixLen\": 0,\n                     \"Gateway\": \"\",\n                     \"Bridge\": \"\",\n                     \"PortMapping\": null\n             },\n             \"SysInitPath\": \"/home/kitty/go/src/github.com/dotcloud/docker/bin/docker\",\n             \"ResolvConfPath\": \"/etc/resolv.conf\",\n             \"Volumes\": {},\n             \"HostConfig\": {\n               \"Binds\": null,\n               \"BlkioDeviceReadIOps\": [\n                   {\n                       \"Path\": \"/dev/sdb\",\n                       \"Rate\": 100\n                   }\n               ],\n               \"BlkioDeviceWriteBps\": [\n                   {\n                       \"Path\": \"/dev/sdb\",\n                       \"Rate\": 5000\n                   }\n               ],\n               \"ContainerIDFile\": \"\",\n               \"LxcConf\": [],\n               \"Privileged\": false,\n               \"PortBindings\": {\n                 \"80/tcp\": [\n                   {\n                     \"HostIp\": \"0.0.0.0\",\n                     \"HostPort\": \"49153\"\n                   }\n                 ]\n               },\n               \"Links\": null,\n               \"PublishAllPorts\": false,\n               \"CgroupParent\": \"/mesos\",\n               \"Memory\": 17179869184,\n               \"MemorySwap\": 34359738368,\n               \"GroupAdd\": [\"fake\", \"12345\"],\n               \"OomScoreAdj\": 642\n             }\n}`\n\tvar expected Container\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c678\"\n\n\tctx, cancel := context.WithTimeout(context.TODO(), 1*time.Second)\n\tdefer cancel()\n\n\tinspectError := make(chan error)\n\t// Invoke InspectContainer in a goroutine. The response is sent to the 'inspectError'\n\t// channel.\n\tgo func() {\n\t\tcontainer, err := client.InspectContainer(id)\n\t\tif err != nil {\n\t\t\tinspectError <- err\n\t\t\treturn\n\t\t}\n\t\tif !reflect.DeepEqual(*container, expected) {\n\t\t\tinspectError <- fmt.Errorf(\"inspectContainer(%q): Expected %#v. Got %#v\", id, expected, container)\n\t\t\treturn\n\t\t}\n\t\texpectedURL, _ := url.Parse(client.getURL(\"/containers/4fa6e0f0c678/json\"))\n\t\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\t\tinspectError <- fmt.Errorf(\"inspectContainer(%q): Wrong path in request. Want %q. Got %q\", id, expectedURL.Path, gotPath)\n\t\t\treturn\n\t\t}\n\t\t// No errors to tbe reported. Send 'nil'\n\t\tinspectError <- nil\n\t}()\n\t// Wait for either the inspect response or for the context.\n\tselect {\n\tcase err := <-inspectError:\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error inspecting container with context: %v\", err)\n\t\t}\n\tcase <-ctx.Done():\n\t\t// Context was canceled unexpectedly. Report the same.\n\t\tt.Fatalf(\"Context canceled when waiting for inspect container response: %v\", ctx.Err())\n\t}\n}\n\nfunc TestInspectContainerWithOptions(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\n             \"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\",\n             \"AppArmorProfile\": \"Profile\",\n             \"Created\": \"2013-05-07T14:51:42.087658+02:00\",\n             \"Path\": \"date\",\n             \"Args\": [],\n             \"Config\": {\n                     \"Hostname\": \"4fa6e0f0c678\",\n                     \"User\": \"\",\n                     \"Memory\": 17179869184,\n                     \"MemorySwap\": 34359738368,\n                     \"AttachStdin\": false,\n                     \"AttachStdout\": true,\n                     \"AttachStderr\": true,\n                     \"PortSpecs\": null,\n                     \"Tty\": false,\n                     \"OpenStdin\": false,\n                     \"StdinOnce\": false,\n                     \"Env\": null,\n                     \"Cmd\": [\n                             \"date\"\n                     ],\n                     \"Image\": \"base\",\n                     \"Volumes\": {},\n                     \"VolumesFrom\": \"\",\n                     \"SecurityOpt\": [\n                         \"label:user:USER\"\n                      ],\n                      \"Ulimits\": [\n                          { \"Name\": \"nofile\", \"Soft\": 1024, \"Hard\": 2048 }\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t\t\"Shell\": [\n                         \"/bin/sh\", \"-c\"\n\t\t\t\t\t\t\t\t\t\t\t]\n             },\n             \"State\": {\n                     \"Running\": false,\n                     \"Pid\": 0,\n                     \"ExitCode\": 0,\n                     \"StartedAt\": \"2013-05-07T14:51:42.087658+02:00\",\n                     \"Ghost\": false\n             },\n             \"Node\": {\n                  \"ID\": \"4I4E:QR4I:Z733:QEZK:5X44:Q4T7:W2DD:JRDY:KB2O:PODO:Z5SR:XRB6\",\n                  \"IP\": \"192.168.99.105\",\n                  \"Addra\": \"192.168.99.105:2376\",\n                  \"Name\": \"node-01\",\n                  \"Cpus\": 4,\n                  \"Memory\": 1048436736,\n                  \"Labels\": {\n                      \"executiondriver\": \"native-0.2\",\n                      \"kernelversion\": \"3.18.5-tinycore64\",\n                      \"operatingsystem\": \"Boot2Docker 1.5.0 (TCL 5.4); master : a66bce5 - Tue Feb 10 23:31:27 UTC 2015\",\n                      \"provider\": \"virtualbox\",\n                      \"storagedriver\": \"aufs\"\n                  }\n              },\n             \"Image\": \"b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\",\n             \"NetworkSettings\": {\n                     \"IpAddress\": \"\",\n                     \"IpPrefixLen\": 0,\n                     \"Gateway\": \"\",\n                     \"Bridge\": \"\",\n                     \"PortMapping\": null\n             },\n             \"SysInitPath\": \"/home/kitty/go/src/github.com/dotcloud/docker/bin/docker\",\n             \"ResolvConfPath\": \"/etc/resolv.conf\",\n             \"Volumes\": {},\n             \"HostConfig\": {\n               \"Binds\": null,\n               \"ContainerIDFile\": \"\",\n               \"LxcConf\": [],\n               \"Privileged\": false,\n               \"PortBindings\": {\n                 \"80/tcp\": [\n                   {\n                     \"HostIp\": \"0.0.0.0\",\n                     \"HostPort\": \"49153\"\n                   }\n                 ]\n               },\n               \"Links\": null,\n               \"PublishAllPorts\": false,\n               \"CgroupParent\": \"/mesos\",\n               \"Memory\": 17179869184,\n               \"MemorySwap\": 34359738368,\n               \"GroupAdd\": [\"fake\", \"12345\"],\n               \"OomScoreAdj\": 642,\n               \"SizeRw\": 3,\n               \"SizeRootFs\": 5552693\n             }\n}`\n\tvar expected Container\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tconst id = \"4fa6e0f0c678\"\n\tcontainer, err := client.InspectContainerWithOptions(InspectContainerOptions{\n\t\tID:   id,\n\t\tSize: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*container, expected) {\n\t\tt.Errorf(\"InspectContainer(%q): Expected %#v. Got %#v.\", id, expected, container)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/4fa6e0f0c678/json?size=true\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"InspectContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestInspectContainerNetwork(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\n            \"Id\": \"81e1bbe20b5508349e1c804eb08b7b6ca8366751dbea9f578b3ea0773fa66c1c\",\n            \"Created\": \"2015-11-12T14:54:04.791485659Z\",\n            \"Path\": \"consul-template\",\n            \"Args\": [\n                \"-config=/tmp/haproxy.json\",\n                \"-consul=192.168.99.120:8500\"\n            ],\n            \"State\": {\n                \"Status\": \"running\",\n                \"Running\": true,\n                \"Paused\": false,\n                \"Restarting\": false,\n                \"OOMKilled\": false,\n                \"Dead\": false,\n                \"Pid\": 3196,\n                \"ExitCode\": 0,\n                \"Error\": \"\",\n                \"StartedAt\": \"2015-11-12T14:54:05.026747471Z\",\n                \"FinishedAt\": \"0001-01-01T00:00:00Z\"\n            },\n            \"Image\": \"4921c5917fc117df3dec32f4c1976635dc6c56ccd3336fe1db3477f950e78bf7\",\n            \"ResolvConfPath\": \"/mnt/sda1/var/lib/docker/containers/81e1bbe20b5508349e1c804eb08b7b6ca8366751dbea9f578b3ea0773fa66c1c/resolv.conf\",\n            \"HostnamePath\": \"/mnt/sda1/var/lib/docker/containers/81e1bbe20b5508349e1c804eb08b7b6ca8366751dbea9f578b3ea0773fa66c1c/hostname\",\n            \"HostsPath\": \"/mnt/sda1/var/lib/docker/containers/81e1bbe20b5508349e1c804eb08b7b6ca8366751dbea9f578b3ea0773fa66c1c/hosts\",\n            \"LogPath\": \"/mnt/sda1/var/lib/docker/containers/81e1bbe20b5508349e1c804eb08b7b6ca8366751dbea9f578b3ea0773fa66c1c/81e1bbe20b5508349e1c804eb08b7b6ca8366751dbea9f578b3ea0773fa66c1c-json.log\",\n            \"Node\": {\n                \"ID\": \"AUIB:LFOT:3LSF:SCFS:OYDQ:NLXD:JZNE:4INI:3DRC:ZFBB:GWCY:DWJK\",\n                \"IP\": \"192.168.99.121\",\n                \"Addr\": \"192.168.99.121:2376\",\n                \"Name\": \"swl-demo1\",\n                \"Cpus\": 1,\n                \"Memory\": 2099945472,\n                \"Labels\": {\n                    \"executiondriver\": \"native-0.2\",\n                    \"kernelversion\": \"4.1.12-boot2docker\",\n                    \"operatingsystem\": \"Boot2Docker 1.9.0 (TCL 6.4); master : 16e4a2a - Tue Nov  3 19:49:22 UTC 2015\",\n                    \"provider\": \"virtualbox\",\n                    \"storagedriver\": \"aufs\"\n                }\n            },\n            \"Name\": \"/docker-proxy.swl-demo1\",\n            \"RestartCount\": 0,\n            \"Driver\": \"aufs\",\n            \"ExecDriver\": \"native-0.2\",\n            \"MountLabel\": \"\",\n            \"ProcessLabel\": \"\",\n            \"AppArmorProfile\": \"\",\n            \"ExecIDs\": null,\n            \"HostConfig\": {\n                \"Binds\": null,\n                \"ContainerIDFile\": \"\",\n                \"LxcConf\": [],\n                \"Memory\": 0,\n                \"MemoryReservation\": 0,\n                \"MemorySwap\": 0,\n                \"KernelMemory\": 0,\n                \"CpuShares\": 0,\n                \"CpuPeriod\": 0,\n                \"CpusetCpus\": \"\",\n                \"CpusetMems\": \"\",\n                \"CpuQuota\": 0,\n                \"BlkioWeight\": 0,\n                \"OomKillDisable\": false,\n                \"MemorySwappiness\": -1,\n                \"Privileged\": false,\n                \"PortBindings\": {\n                    \"443/tcp\": [\n                        {\n                            \"HostIp\": \"\",\n                            \"HostPort\": \"443\"\n                        }\n                    ]\n                },\n                \"Links\": null,\n                \"PublishAllPorts\": false,\n                \"Dns\": null,\n                \"DnsOptions\": null,\n                \"DnsSearch\": null,\n                \"ExtraHosts\": null,\n                \"VolumesFrom\": null,\n                \"Devices\": [],\n                \"NetworkMode\": \"swl-net\",\n                \"IpcMode\": \"\",\n                \"PidMode\": \"\",\n                \"UTSMode\": \"\",\n                \"CapAdd\": null,\n                \"CapDrop\": null,\n                \"GroupAdd\": null,\n                \"RestartPolicy\": {\n                    \"Name\": \"no\",\n                    \"MaximumRetryCount\": 0\n                },\n                \"SecurityOpt\": null,\n                \"ReadonlyRootfs\": false,\n                \"Ulimits\": null,\n                \"LogConfig\": {\n                    \"Type\": \"json-file\",\n                    \"Config\": {}\n                },\n                \"CgroupParent\": \"\",\n                \"ConsoleSize\": [\n                    0,\n                    0\n                ],\n                \"VolumeDriver\": \"\"\n            },\n            \"GraphDriver\": {\n                \"Name\": \"aufs\",\n                \"Data\": null\n            },\n            \"Mounts\": [],\n            \"Config\": {\n                \"Hostname\": \"81e1bbe20b55\",\n                \"Domainname\": \"\",\n                \"User\": \"\",\n                \"AttachStdin\": false,\n                \"AttachStdout\": false,\n                \"AttachStderr\": false,\n                \"ExposedPorts\": {\n                    \"443/tcp\": {}\n                },\n                \"Tty\": false,\n                \"OpenStdin\": false,\n                \"StdinOnce\": false,\n                \"Env\": [\n                    \"DOMAIN=local.auto\",\n                    \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n                    \"CONSUL_TEMPLATE_VERSION=0.11.1\"\n                ],\n                \"Cmd\": [\n                    \"-consul=192.168.99.120:8500\"\n                ],\n                \"Image\": \"docker-proxy:latest\",\n                \"Volumes\": null,\n                \"WorkingDir\": \"\",\n                \"Entrypoint\": [\n                    \"consul-template\",\n                    \"-config=/tmp/haproxy.json\"\n                ],\n                \"OnBuild\": null,\n                \"Labels\": {},\n                \"StopSignal\": \"SIGTERM\"\n            },\n            \"NetworkSettings\": {\n                \"Bridge\": \"\",\n                \"SandboxID\": \"c6b903dc5c1a96113a22dbc44709e30194079bd2d262eea1eb4f38d85821f6e1\",\n                \"HairpinMode\": false,\n                \"LinkLocalIPv6Address\": \"\",\n                \"LinkLocalIPv6PrefixLen\": 0,\n                \"Ports\": {\n                    \"443/tcp\": [\n                        {\n                            \"HostIp\": \"192.168.99.121\",\n                            \"HostPort\": \"443\"\n                        }\n                    ]\n                },\n                \"SandboxKey\": \"/var/run/docker/netns/c6b903dc5c1a\",\n                \"SecondaryIPAddresses\": null,\n                \"SecondaryIPv6Addresses\": null,\n                \"EndpointID\": \"\",\n                \"Gateway\": \"\",\n                \"GlobalIPv6Address\": \"\",\n                \"GlobalIPv6PrefixLen\": 0,\n                \"IPAddress\": \"\",\n                \"IPPrefixLen\": 0,\n                \"IPv6Gateway\": \"\",\n                \"MacAddress\": \"\",\n                \"Networks\": {\n                    \"swl-net\": {\n\t\t\t\t\t\t\"Aliases\": [\n\t\t\t\t\t\t\t\"testalias\",\n\t\t\t\t\t\t\t\"81e1bbe20b55\"\n\t\t\t\t\t\t],\n                        \"NetworkID\": \"7ea29fc1412292a2d7bba362f9253545fecdfa8ce9a6e37dd10ba8bee7129812\",\n                        \"EndpointID\": \"683e3092275782a53c3b0968cc7e3a10f23264022ded9cb20490902f96fc5981\",\n                        \"Gateway\": \"\",\n                        \"IPAddress\": \"10.0.0.3\",\n                        \"IPPrefixLen\": 24,\n                        \"IPv6Gateway\": \"\",\n                        \"GlobalIPv6Address\": \"\",\n                        \"GlobalIPv6PrefixLen\": 0,\n                        \"MacAddress\": \"02:42:0a:00:00:03\"\n                    }\n                }\n            }\n}`\n\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"81e1bbe20b55\"\n\texpIP := \"10.0.0.3\"\n\texpNetworkID := \"7ea29fc1412292a2d7bba362f9253545fecdfa8ce9a6e37dd10ba8bee7129812\"\n\texpectedAliases := []string{\"testalias\", \"81e1bbe20b55\"}\n\n\tcontainer, err := client.InspectContainer(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ts := reflect.Indirect(reflect.ValueOf(container.NetworkSettings))\n\tnetworks := s.FieldByName(\"Networks\")\n\tif networks.IsValid() {\n\t\tvar ip string\n\t\tfor _, net := range networks.MapKeys() {\n\t\t\tif net.Interface().(string) == container.HostConfig.NetworkMode {\n\t\t\t\tip = networks.MapIndex(net).FieldByName(\"IPAddress\").Interface().(string)\n\t\t\t\tt.Logf(\"%s %v\", net, ip)\n\t\t\t}\n\t\t}\n\t\tif ip != expIP {\n\t\t\tt.Errorf(\"InspectContainerNetworks(%q): Expected %#v. Got %#v.\", id, expIP, ip)\n\t\t}\n\n\t\tvar networkID string\n\t\tfor _, net := range networks.MapKeys() {\n\t\t\tif net.Interface().(string) == container.HostConfig.NetworkMode {\n\t\t\t\tnetworkID = networks.MapIndex(net).FieldByName(\"NetworkID\").Interface().(string)\n\t\t\t\tt.Logf(\"%s %v\", net, networkID)\n\t\t\t}\n\t\t}\n\n\t\tvar aliases []string\n\t\tfor _, net := range networks.MapKeys() {\n\t\t\tif net.Interface().(string) == container.HostConfig.NetworkMode {\n\t\t\t\taliases = networks.MapIndex(net).FieldByName(\"Aliases\").Interface().([]string)\n\t\t\t}\n\t\t}\n\t\tif !reflect.DeepEqual(aliases, expectedAliases) {\n\t\t\tt.Errorf(\"InspectContainerNetworks(%q): Expected Aliases %#v. Got %#v.\", id, expectedAliases, aliases)\n\t\t}\n\n\t\tif networkID != expNetworkID {\n\t\t\tt.Errorf(\"InspectContainerNetworks(%q): Expected %#v. Got %#v.\", id, expNetworkID, networkID)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"InspectContainerNetworks(%q): No method Networks for NetworkSettings\", id)\n\t}\n}\n\nfunc TestInspectContainerNegativeSwap(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\n             \"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\",\n             \"Created\": \"2013-05-07T14:51:42.087658+02:00\",\n             \"Path\": \"date\",\n             \"Args\": [],\n             \"Config\": {\n                     \"Hostname\": \"4fa6e0f0c678\",\n                     \"User\": \"\",\n                     \"Memory\": 17179869184,\n                     \"MemorySwap\": -1,\n                     \"AttachStdin\": false,\n                     \"AttachStdout\": true,\n                     \"AttachStderr\": true,\n                     \"PortSpecs\": null,\n                     \"Tty\": false,\n                     \"OpenStdin\": false,\n                     \"StdinOnce\": false,\n                     \"Env\": null,\n                     \"Cmd\": [\n                             \"date\"\n                     ],\n                     \"Image\": \"base\",\n                     \"Volumes\": {},\n                     \"VolumesFrom\": \"\"\n             },\n             \"State\": {\n                     \"Running\": false,\n                     \"Pid\": 0,\n                     \"ExitCode\": 0,\n                     \"StartedAt\": \"2013-05-07T14:51:42.087658+02:00\",\n                     \"Ghost\": false\n             },\n             \"Image\": \"b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\",\n             \"NetworkSettings\": {\n                     \"IpAddress\": \"\",\n                     \"IpPrefixLen\": 0,\n                     \"Gateway\": \"\",\n                     \"Bridge\": \"\",\n                     \"PortMapping\": null\n             },\n             \"SysInitPath\": \"/home/kitty/go/src/github.com/dotcloud/docker/bin/docker\",\n             \"ResolvConfPath\": \"/etc/resolv.conf\",\n             \"Volumes\": {},\n             \"HostConfig\": {\n               \"Binds\": null,\n               \"ContainerIDFile\": \"\",\n               \"LxcConf\": [],\n               \"Privileged\": false,\n               \"PortBindings\": {\n                 \"80/tcp\": [\n                   {\n                     \"HostIp\": \"0.0.0.0\",\n                     \"HostPort\": \"49153\"\n                   }\n                 ]\n               },\n               \"Links\": null,\n               \"PublishAllPorts\": false\n             }\n}`\n\tvar expected Container\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c678\"\n\tcontainer, err := client.InspectContainer(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*container, expected) {\n\t\tt.Errorf(\"InspectContainer(%q): Expected %#v. Got %#v.\", id, expected, container)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/4fa6e0f0c678/json\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"InspectContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestInspectContainerFailure(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"server error\", status: 500})\n\texpected := Error{Status: 500, Message: \"server error\"}\n\tcontainer, err := client.InspectContainer(\"abe033\")\n\tif container != nil {\n\t\tt.Errorf(\"InspectContainer: Expected <nil> container, got %#v\", container)\n\t}\n\tif !reflect.DeepEqual(expected, *err.(*Error)) {\n\t\tt.Errorf(\"InspectContainer: Wrong error information. Want %#v. Got %#v.\", expected, err)\n\t}\n}\n\nfunc TestInspectContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tconst containerID = \"abe033\"\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: 404})\n\tcontainer, err := client.InspectContainer(containerID)\n\tif container != nil {\n\t\tt.Errorf(\"InspectContainer: Expected <nil> container, got %#v\", container)\n\t}\n\texpectNoSuchContainer(t, containerID, err)\n}\n\nfunc TestInspectContainerWhenContextTimesOut(t *testing.T) {\n\tt.Parallel()\n\trt := sleepyRoudTripper{sleepDuration: 200 * time.Millisecond}\n\n\tclient := newTestClient(&rt)\n\n\tctx, cancel := context.WithTimeout(context.TODO(), 100*time.Millisecond)\n\tdefer cancel()\n\n\t_, err := client.InspectContainerWithContext(\"id\", ctx)\n\tif !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Errorf(\"Expected 'DeadlineExceededError', got: %#v\", err)\n\t}\n}\n"
        },
        {
          "name": "container_kill.go",
          "type": "blob",
          "size": 1.064453125,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n)\n\n// KillContainerOptions represents the set of options that can be used in a\n// call to KillContainer.\n//\n// See https://goo.gl/JnTxXZ for more details.\ntype KillContainerOptions struct {\n\t// The ID of the container.\n\tID string `qs:\"-\"`\n\n\t// The signal to send to the container. When omitted, Docker server\n\t// will assume SIGKILL.\n\tSignal  Signal\n\tContext context.Context\n}\n\n// KillContainer sends a signal to a container, returning an error in case of\n// failure.\n//\n// See https://goo.gl/JnTxXZ for more details.\nfunc (c *Client) KillContainer(opts KillContainerOptions) error {\n\tpath := \"/containers/\" + opts.ID + \"/kill\" + \"?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif !errors.As(err, &e) {\n\t\t\treturn err\n\t\t}\n\t\tswitch e.Status {\n\t\tcase http.StatusNotFound:\n\t\t\treturn &NoSuchContainer{ID: opts.ID}\n\t\tcase http.StatusConflict:\n\t\t\treturn &ContainerNotRunning{ID: opts.ID}\n\t\tdefault:\n\t\t\treturn err\n\t\t}\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n"
        },
        {
          "name": "container_kill_test.go",
          "type": "blob",
          "size": 2.212890625,
          "content": "package docker\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestKillContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.KillContainer(KillContainerOptions{ID: id})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"KillContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/kill\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"KillContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestKillContainerSignal(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.KillContainer(KillContainerOptions{ID: id, Signal: SIGTERM})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"KillContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\tif signal := req.URL.Query().Get(\"signal\"); signal != \"15\" {\n\t\tt.Errorf(\"KillContainer(%q): Wrong query string in request. Want %q. Got %q.\", id, \"15\", signal)\n\t}\n}\n\nfunc TestKillContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\terr := client.KillContainer(KillContainerOptions{ID: \"a2334\"})\n\texpectNoSuchContainer(t, \"a2334\", err)\n}\n\nfunc TestKillContainerNotRunning(t *testing.T) {\n\tt.Parallel()\n\tid := \"abcd1234567890\"\n\tmsg := fmt.Sprintf(\"Cannot kill container: %[1]s: Container %[1]s is not running\", id)\n\tclient := newTestClient(&FakeRoundTripper{message: msg, status: http.StatusConflict})\n\terr := client.KillContainer(KillContainerOptions{ID: id})\n\texpected := &ContainerNotRunning{ID: id}\n\tif !reflect.DeepEqual(err, expected) {\n\t\tt.Errorf(\"KillContainer: Wrong error returned. Want %#v. Got %#v.\", expected, err)\n\t}\n}\n"
        },
        {
          "name": "container_list.go",
          "type": "blob",
          "size": 0.890625,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\n// ListContainersOptions specify parameters to the ListContainers function.\n//\n// See https://goo.gl/kaOHGw for more details.\ntype ListContainersOptions struct {\n\tAll     bool\n\tSize    bool\n\tLimit   int\n\tSince   string\n\tBefore  string\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// ListContainers returns a slice of containers matching the given criteria.\n//\n// See https://goo.gl/kaOHGw for more details.\nfunc (c *Client) ListContainers(opts ListContainersOptions) ([]APIContainers, error) {\n\tpath := \"/containers/json?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar containers []APIContainers\n\tif err := json.NewDecoder(resp.Body).Decode(&containers); err != nil {\n\t\treturn nil, err\n\t}\n\treturn containers, nil\n}\n"
        },
        {
          "name": "container_list_test.go",
          "type": "blob",
          "size": 4.1591796875,
          "content": "package docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestListContainers(t *testing.T) {\n\tt.Parallel()\n\tjsonContainers := `[\n     {\n             \"Id\": \"8dfafdbc3a40\",\n             \"Image\": \"base:latest\",\n             \"Command\": \"echo 1\",\n             \"Created\": 1367854155,\n             \"Ports\":[{\"PrivatePort\": 2222, \"PublicPort\": 3333, \"Type\": \"tcp\"}],\n             \"Status\": \"Exit 0\"\n     },\n     {\n             \"Id\": \"9cd87474be90\",\n             \"Image\": \"base:latest\",\n             \"Command\": \"echo 222222\",\n             \"Created\": 1367854155,\n             \"Ports\":[{\"PrivatePort\": 2222, \"PublicPort\": 3333, \"Type\": \"tcp\"}],\n             \"Status\": \"Exit 0\"\n     },\n     {\n             \"Id\": \"3176a2479c92\",\n             \"Image\": \"base:latest\",\n             \"Command\": \"echo 3333333333333333\",\n             \"Created\": 1367854154,\n             \"Ports\":[{\"PrivatePort\": 2221, \"PublicPort\": 3331, \"Type\": \"tcp\"}],\n             \"Status\": \"Exit 0\"\n     },\n     {\n             \"Id\": \"4cb07b47f9fb\",\n             \"Image\": \"base:latest\",\n             \"Command\": \"echo 444444444444444444444444444444444\",\n             \"Ports\":[{\"PrivatePort\": 2223, \"PublicPort\": 3332, \"Type\": \"tcp\"}],\n             \"Created\": 1367854152,\n             \"Status\": \"Exit 0\"\n     }\n]`\n\tvar expected []APIContainers\n\terr := json.Unmarshal([]byte(jsonContainers), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: jsonContainers, status: http.StatusOK})\n\tcontainers, err := client.ListContainers(ListContainersOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(containers, expected) {\n\t\tt.Errorf(\"ListContainers: Expected %#v. Got %#v.\", expected, containers)\n\t}\n}\n\nfunc TestListContainersParams(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput  ListContainersOptions\n\t\tparams map[string][]string\n\t}{\n\t\t{ListContainersOptions{}, map[string][]string{}},\n\t\t{ListContainersOptions{All: true}, map[string][]string{\"all\": {\"1\"}}},\n\t\t{ListContainersOptions{All: true, Limit: 10}, map[string][]string{\"all\": {\"1\"}, \"limit\": {\"10\"}}},\n\t\t{\n\t\t\tListContainersOptions{All: true, Limit: 10, Since: \"adf9983\", Before: \"abdeef\"},\n\t\t\tmap[string][]string{\"all\": {\"1\"}, \"limit\": {\"10\"}, \"since\": {\"adf9983\"}, \"before\": {\"abdeef\"}},\n\t\t},\n\t\t{\n\t\t\tListContainersOptions{Filters: map[string][]string{\"status\": {\"paused\", \"running\"}}},\n\t\t\tmap[string][]string{\"filters\": {\"{\\\"status\\\":[\\\"paused\\\",\\\"running\\\"]}\"}},\n\t\t},\n\t\t{\n\t\t\tListContainersOptions{All: true, Filters: map[string][]string{\"exited\": {\"0\"}, \"status\": {\"exited\"}}},\n\t\t\tmap[string][]string{\"all\": {\"1\"}, \"filters\": {\"{\\\"exited\\\":[\\\"0\\\"],\\\"status\\\":[\\\"exited\\\"]}\"}},\n\t\t},\n\t}\n\tconst expectedPath = \"/containers/json\"\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tfakeRT := &FakeRoundTripper{message: \"[]\", status: http.StatusOK}\n\t\t\tclient := newTestClient(fakeRT)\n\t\t\tif _, err := client.ListContainers(test.input); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tgot := map[string][]string(fakeRT.requests[0].URL.Query())\n\t\t\tif !reflect.DeepEqual(got, test.params) {\n\t\t\t\tt.Errorf(\"Expected %#v, got %#v.\", test.params, got)\n\t\t\t}\n\t\t\tif path := fakeRT.requests[0].URL.Path; path != expectedPath {\n\t\t\t\tt.Errorf(\"Wrong path on request. Want %q. Got %q.\", expectedPath, path)\n\t\t\t}\n\t\t\tif meth := fakeRT.requests[0].Method; meth != http.MethodGet {\n\t\t\t\tt.Errorf(\"Wrong HTTP method. Want GET. Got %s.\", meth)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestListContainersFailure(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tstatus  int\n\t\tmessage string\n\t}{\n\t\t{400, \"bad parameter\"},\n\t\t{500, \"internal server error\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(strconv.Itoa(test.status), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tclient := newTestClient(&FakeRoundTripper{message: test.message, status: test.status})\n\t\t\texpected := Error{Status: test.status, Message: test.message}\n\t\t\tcontainers, err := client.ListContainers(ListContainersOptions{})\n\t\t\tif !reflect.DeepEqual(expected, *err.(*Error)) {\n\t\t\t\tt.Errorf(\"Wrong error in ListContainers. Want %#v. Got %#v.\", expected, err)\n\t\t\t}\n\t\t\tif len(containers) > 0 {\n\t\t\t\tt.Errorf(\"ListContainers failure. Expected empty list. Got %#v.\", containers)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "container_logs.go",
          "type": "blob",
          "size": 1.6103515625,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// LogsOptions represents the set of options used when getting logs from a\n// container.\n//\n// See https://goo.gl/krK0ZH for more details.\ntype LogsOptions struct {\n\tContext           context.Context\n\tContainer         string        `qs:\"-\"`\n\tOutputStream      io.Writer     `qs:\"-\"`\n\tErrorStream       io.Writer     `qs:\"-\"`\n\tInactivityTimeout time.Duration `qs:\"-\"`\n\tTail              string\n\n\tSince      int64\n\tFollow     bool\n\tStdout     bool\n\tStderr     bool\n\tTimestamps bool\n\n\t// Use raw terminal? Usually true when the container contains a TTY.\n\tRawTerminal bool `qs:\"-\"`\n}\n\n// Logs gets stdout and stderr logs from the specified container.\n//\n// When LogsOptions.RawTerminal is set to false, go-dockerclient will multiplex\n// the streams and send the containers stdout to LogsOptions.OutputStream, and\n// stderr to LogsOptions.ErrorStream.\n//\n// When LogsOptions.RawTerminal is true, callers will get the raw stream on\n// LogsOptions.OutputStream. The caller can use libraries such as dlog\n// (github.com/ahmetalpbalkan/dlog).\n//\n// See https://goo.gl/krK0ZH for more details.\nfunc (c *Client) Logs(opts LogsOptions) error {\n\tif opts.Container == \"\" {\n\t\treturn &NoSuchContainer{ID: opts.Container}\n\t}\n\tif opts.Tail == \"\" {\n\t\topts.Tail = \"all\"\n\t}\n\tpath := \"/containers/\" + opts.Container + \"/logs?\" + queryString(opts)\n\treturn c.stream(http.MethodGet, path, streamOptions{\n\t\tsetRawTerminal:    opts.RawTerminal,\n\t\tstdout:            opts.OutputStream,\n\t\tstderr:            opts.ErrorStream,\n\t\tinactivityTimeout: opts.InactivityTimeout,\n\t\tcontext:           opts.Context,\n\t})\n}\n"
        },
        {
          "name": "container_logs_test.go",
          "type": "blob",
          "size": 4.78515625,
          "content": "package docker\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogs(t *testing.T) {\n\tt.Parallel()\n\tvar req http.Request\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tprefix := []byte{1, 0, 0, 0, 0, 0, 0, 19}\n\t\tw.Write(prefix)\n\t\tw.Write([]byte(\"something happened!\"))\n\t\treq = *r\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar buf bytes.Buffer\n\topts := LogsOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: &buf,\n\t\tFollow:       true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tTimestamps:   true,\n\t}\n\terr := client.Logs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"something happened!\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"Logs: wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"Logs: wrong HTTP method. Want GET. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/containers/a123456/logs\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"AttachToContainer for logs: wrong HTTP path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpectedQs := map[string][]string{\n\t\t\"follow\":     {\"1\"},\n\t\t\"stdout\":     {\"1\"},\n\t\t\"stderr\":     {\"1\"},\n\t\t\"timestamps\": {\"1\"},\n\t\t\"tail\":       {\"all\"},\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expectedQs) {\n\t\tt.Errorf(\"Logs: wrong query string. Want %#v. Got %#v.\", expectedQs, got)\n\t}\n}\n\nfunc TestLogsNilStdoutDoesntFail(t *testing.T) {\n\tt.Parallel()\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tprefix := []byte{1, 0, 0, 0, 0, 0, 0, 19}\n\t\tw.Write(prefix)\n\t\tw.Write([]byte(\"something happened!\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\topts := LogsOptions{\n\t\tContainer:  \"a123456\",\n\t\tFollow:     true,\n\t\tStdout:     true,\n\t\tStderr:     true,\n\t\tTimestamps: true,\n\t}\n\terr := client.Logs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLogsNilStderrDoesntFail(t *testing.T) {\n\tt.Parallel()\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tprefix := []byte{2, 0, 0, 0, 0, 0, 0, 19}\n\t\tw.Write(prefix)\n\t\tw.Write([]byte(\"something happened!\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\topts := LogsOptions{\n\t\tContainer:  \"a123456\",\n\t\tFollow:     true,\n\t\tStdout:     true,\n\t\tStderr:     true,\n\t\tTimestamps: true,\n\t}\n\terr := client.Logs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLogsSpecifyingTail(t *testing.T) {\n\tt.Parallel()\n\tvar req http.Request\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tprefix := []byte{1, 0, 0, 0, 0, 0, 0, 19}\n\t\tw.Write(prefix)\n\t\tw.Write([]byte(\"something happened!\"))\n\t\treq = *r\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar buf bytes.Buffer\n\topts := LogsOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: &buf,\n\t\tFollow:       true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tTimestamps:   true,\n\t\tTail:         \"100\",\n\t}\n\terr := client.Logs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"something happened!\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"Logs: wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"Logs: wrong HTTP method. Want GET. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/containers/a123456/logs\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"AttachToContainer for logs: wrong HTTP path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpectedQs := map[string][]string{\n\t\t\"follow\":     {\"1\"},\n\t\t\"stdout\":     {\"1\"},\n\t\t\"stderr\":     {\"1\"},\n\t\t\"timestamps\": {\"1\"},\n\t\t\"tail\":       {\"100\"},\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expectedQs) {\n\t\tt.Errorf(\"Logs: wrong query string. Want %#v. Got %#v.\", expectedQs, got)\n\t}\n}\n\nfunc TestLogsRawTerminal(t *testing.T) {\n\tt.Parallel()\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(\"something happened!\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar buf bytes.Buffer\n\topts := LogsOptions{\n\t\tContainer:    \"a123456\",\n\t\tOutputStream: &buf,\n\t\tFollow:       true,\n\t\tRawTerminal:  true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tTimestamps:   true,\n\t\tTail:         \"100\",\n\t}\n\terr := client.Logs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"something happened!\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"Logs: wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n}\n\nfunc TestLogsNoContainer(t *testing.T) {\n\tt.Parallel()\n\tvar client Client\n\terr := client.Logs(LogsOptions{})\n\texpectNoSuchContainer(t, \"\", err)\n}\n"
        },
        {
          "name": "container_pause.go",
          "type": "blob",
          "size": 0.4775390625,
          "content": "package docker\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// PauseContainer pauses the given container.\n//\n// See https://goo.gl/D1Yaii for more details.\nfunc (c *Client) PauseContainer(id string) error {\n\tpath := fmt.Sprintf(\"/containers/%s/pause\", id)\n\tresp, err := c.do(http.MethodPost, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchContainer{ID: id}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n"
        },
        {
          "name": "container_pause_test.go",
          "type": "blob",
          "size": 1.0009765625,
          "content": "package docker\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestPauseContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.PauseContainer(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"PauseContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/pause\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"PauseContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestPauseContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\terr := client.PauseContainer(\"a2334\")\n\texpectNoSuchContainer(t, \"a2334\", err)\n}\n"
        },
        {
          "name": "container_prune.go",
          "type": "blob",
          "size": 1.0283203125,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\n// PruneContainersOptions specify parameters to the PruneContainers function.\n//\n// See https://goo.gl/wnkgDT for more details.\ntype PruneContainersOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// PruneContainersResults specify results from the PruneContainers function.\n//\n// See https://goo.gl/wnkgDT for more details.\ntype PruneContainersResults struct {\n\tContainersDeleted []string\n\tSpaceReclaimed    int64\n}\n\n// PruneContainers deletes containers which are stopped.\n//\n// See https://goo.gl/wnkgDT for more details.\nfunc (c *Client) PruneContainers(opts PruneContainersOptions) (*PruneContainersResults, error) {\n\tpath := \"/containers/prune?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar results PruneContainersResults\n\tif err := json.NewDecoder(resp.Body).Decode(&results); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &results, nil\n}\n"
        },
        {
          "name": "container_prune_test.go",
          "type": "blob",
          "size": 0.6298828125,
          "content": "package docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestPruneContainers(t *testing.T) {\n\tt.Parallel()\n\tresults := `{\n\t\t\"ContainersDeleted\": [\n\t\t\t\"a\", \"b\", \"c\"\n\t\t],\n\t\t\"SpaceReclaimed\": 123\n\t}`\n\n\texpected := &PruneContainersResults{}\n\terr := json.Unmarshal([]byte(results), expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: results, status: http.StatusOK})\n\tgot, err := client.PruneContainers(PruneContainersOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"PruneContainers: Expected %#v. Got %#v.\", expected, got)\n\t}\n}\n"
        },
        {
          "name": "container_remove.go",
          "type": "blob",
          "size": 1.0439453125,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n)\n\n// RemoveContainerOptions encapsulates options to remove a container.\n//\n// See https://goo.gl/hL5IPC for more details.\ntype RemoveContainerOptions struct {\n\t// The ID of the container.\n\tID string `qs:\"-\"`\n\n\t// A flag that indicates whether Docker should remove the volumes\n\t// associated to the container.\n\tRemoveVolumes bool `qs:\"v\"`\n\n\t// A flag that indicates whether Docker should remove the container\n\t// even if it is currently running.\n\tForce   bool\n\tContext context.Context\n}\n\n// RemoveContainer removes a container, returning an error in case of failure.\n//\n// See https://goo.gl/hL5IPC for more details.\nfunc (c *Client) RemoveContainer(opts RemoveContainerOptions) error {\n\tpath := \"/containers/\" + opts.ID + \"?\" + queryString(opts)\n\tresp, err := c.do(http.MethodDelete, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchContainer{ID: opts.ID}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n"
        },
        {
          "name": "container_remove_test.go",
          "type": "blob",
          "size": 1.693359375,
          "content": "package docker\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestRemoveContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\topts := RemoveContainerOptions{ID: id}\n\terr := client.RemoveContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodDelete {\n\t\tt.Errorf(\"RemoveContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodDelete, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"RemoveContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestRemoveContainerRemoveVolumes(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\topts := RemoveContainerOptions{ID: id, RemoveVolumes: true}\n\terr := client.RemoveContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tparams := map[string][]string(req.URL.Query())\n\texpected := map[string][]string{\"v\": {\"1\"}}\n\tif !reflect.DeepEqual(params, expected) {\n\t\tt.Errorf(\"RemoveContainer(%q): wrong parameters. Want %#v. Got %#v.\", id, expected, params)\n\t}\n}\n\nfunc TestRemoveContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\terr := client.RemoveContainer(RemoveContainerOptions{ID: \"a2334\"})\n\texpectNoSuchContainer(t, \"a2334\", err)\n}\n"
        },
        {
          "name": "container_rename.go",
          "type": "blob",
          "size": 0.74609375,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// RenameContainerOptions specify parameters to the RenameContainer function.\n//\n// See https://goo.gl/46inai for more details.\ntype RenameContainerOptions struct {\n\t// ID of container to rename\n\tID string `qs:\"-\"`\n\n\t// New name\n\tName    string `json:\"name,omitempty\" yaml:\"name,omitempty\"`\n\tContext context.Context\n}\n\n// RenameContainer updates and existing containers name\n//\n// See https://goo.gl/46inai for more details.\nfunc (c *Client) RenameContainer(opts RenameContainerOptions) error {\n\tresp, err := c.do(http.MethodPost, fmt.Sprintf(\"/containers/\"+opts.ID+\"/rename?%s\", queryString(opts)), doOptions{\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n"
        },
        {
          "name": "container_rename_test.go",
          "type": "blob",
          "size": 1.0244140625,
          "content": "package docker\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestRenameContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := RenameContainerOptions{ID: \"something_old\", Name: \"something_new\"}\n\terr := client.RenameContainer(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"RenameContainer: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/something_old/rename?name=something_new\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"RenameContainer: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\texpectedValues := expectedURL.Query()[\"name\"]\n\tactualValues := req.URL.Query()[\"name\"]\n\tif len(actualValues) != 1 || expectedValues[0] != actualValues[0] {\n\t\tt.Errorf(\"RenameContainer: Wrong params in request. Want %q. Got %q.\", expectedValues, actualValues)\n\t}\n}\n"
        },
        {
          "name": "container_resize.go",
          "type": "blob",
          "size": 0.513671875,
          "content": "package docker\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\n// ResizeContainerTTY resizes the terminal to the given height and width.\n//\n// See https://goo.gl/FImjeq for more details.\nfunc (c *Client) ResizeContainerTTY(id string, height, width int) error {\n\tparams := make(url.Values)\n\tparams.Set(\"h\", strconv.Itoa(height))\n\tparams.Set(\"w\", strconv.Itoa(width))\n\tresp, err := c.do(http.MethodPost, \"/containers/\"+id+\"/resize?\"+params.Encode(), doOptions{})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n"
        },
        {
          "name": "container_resize_test.go",
          "type": "blob",
          "size": 1.0078125,
          "content": "package docker\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestResizeContainerTTY(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.ResizeContainerTTY(id, 40, 80)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"ResizeContainerTTY(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/resize\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"ResizeContainerTTY(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\texpectedParams := map[string][]string{\n\t\t\"w\": {\"80\"},\n\t\t\"h\": {\"40\"},\n\t}\n\tif !reflect.DeepEqual(got, expectedParams) {\n\t\tt.Errorf(\"Expected %#v, got %#v.\", expectedParams, got)\n\t}\n}\n"
        },
        {
          "name": "container_restart.go",
          "type": "blob",
          "size": 2.2041015625,
          "content": "package docker\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// RestartPolicy represents the policy for automatically restarting a container.\n//\n// Possible values are:\n//\n//   - always: the docker daemon will always restart the container\n//   - on-failure: the docker daemon will restart the container on failures, at\n//     most MaximumRetryCount times\n//   - unless-stopped: the docker daemon will always restart the container except\n//     when user has manually stopped the container\n//   - no: the docker daemon will not restart the container automatically\ntype RestartPolicy struct {\n\tName              string `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tMaximumRetryCount int    `json:\"MaximumRetryCount,omitempty\" yaml:\"MaximumRetryCount,omitempty\" toml:\"MaximumRetryCount,omitempty\"`\n}\n\n// AlwaysRestart returns a restart policy that tells the Docker daemon to\n// always restart the container.\nfunc AlwaysRestart() RestartPolicy {\n\treturn RestartPolicy{Name: \"always\"}\n}\n\n// RestartOnFailure returns a restart policy that tells the Docker daemon to\n// restart the container on failures, trying at most maxRetry times.\nfunc RestartOnFailure(maxRetry int) RestartPolicy {\n\treturn RestartPolicy{Name: \"on-failure\", MaximumRetryCount: maxRetry}\n}\n\n// RestartUnlessStopped returns a restart policy that tells the Docker daemon to\n// always restart the container except when user has manually stopped the container.\nfunc RestartUnlessStopped() RestartPolicy {\n\treturn RestartPolicy{Name: \"unless-stopped\"}\n}\n\n// NeverRestart returns a restart policy that tells the Docker daemon to never\n// restart the container on failures.\nfunc NeverRestart() RestartPolicy {\n\treturn RestartPolicy{Name: \"no\"}\n}\n\n// RestartContainer stops a container, killing it after the given timeout (in\n// seconds), during the stop process.\n//\n// See https://goo.gl/MrAKQ5 for more details.\nfunc (c *Client) RestartContainer(id string, timeout uint) error {\n\tpath := fmt.Sprintf(\"/containers/%s/restart?t=%d\", id, timeout)\n\tresp, err := c.do(http.MethodPost, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchContainer{ID: id}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n"
        },
        {
          "name": "container_restart_test.go",
          "type": "blob",
          "size": 2.4677734375,
          "content": "package docker\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestRestartContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.RestartContainer(id, 10)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"RestartContainer(%q, 10): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/restart\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"RestartContainer(%q, 10): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestRestartContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\terr := client.RestartContainer(\"a2334\", 10)\n\texpectNoSuchContainer(t, \"a2334\", err)\n}\n\nfunc TestAlwaysRestart(t *testing.T) {\n\tt.Parallel()\n\tpolicy := AlwaysRestart()\n\tif policy.Name != \"always\" {\n\t\tt.Errorf(\"AlwaysRestart(): wrong policy name. Want %q. Got %q\", \"always\", policy.Name)\n\t}\n\tif policy.MaximumRetryCount != 0 {\n\t\tt.Errorf(\"AlwaysRestart(): wrong MaximumRetryCount. Want 0. Got %d\", policy.MaximumRetryCount)\n\t}\n}\n\nfunc TestRestartOnFailure(t *testing.T) {\n\tt.Parallel()\n\tconst retry = 5\n\tpolicy := RestartOnFailure(retry)\n\tif policy.Name != \"on-failure\" {\n\t\tt.Errorf(\"RestartOnFailure(%d): wrong policy name. Want %q. Got %q\", retry, \"on-failure\", policy.Name)\n\t}\n\tif policy.MaximumRetryCount != retry {\n\t\tt.Errorf(\"RestartOnFailure(%d): wrong MaximumRetryCount. Want %d. Got %d\", retry, retry, policy.MaximumRetryCount)\n\t}\n}\n\nfunc TestRestartUnlessStopped(t *testing.T) {\n\tt.Parallel()\n\tpolicy := RestartUnlessStopped()\n\tif policy.Name != \"unless-stopped\" {\n\t\tt.Errorf(\"RestartUnlessStopped(): wrong policy name. Want %q. Got %q\", \"unless-stopped\", policy.Name)\n\t}\n\tif policy.MaximumRetryCount != 0 {\n\t\tt.Errorf(\"RestartUnlessStopped(): wrong MaximumRetryCount. Want 0. Got %d\", policy.MaximumRetryCount)\n\t}\n}\n\nfunc TestNeverRestart(t *testing.T) {\n\tt.Parallel()\n\tpolicy := NeverRestart()\n\tif policy.Name != \"no\" {\n\t\tt.Errorf(\"NeverRestart(): wrong policy name. Want %q. Got %q\", \"always\", policy.Name)\n\t}\n\tif policy.MaximumRetryCount != 0 {\n\t\tt.Errorf(\"NeverRestart(): wrong MaximumRetryCount. Want 0. Got %d\", policy.MaximumRetryCount)\n\t}\n}\n"
        },
        {
          "name": "container_start.go",
          "type": "blob",
          "size": 1.8603515625,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n)\n\n// StartContainer starts a container, returning an error in case of failure.\n//\n// Passing the HostConfig to this method has been deprecated in Docker API 1.22\n// (Docker Engine 1.10.x) and totally removed in Docker API 1.24 (Docker Engine\n// 1.12.x). The client will ignore the parameter when communicating with Docker\n// API 1.24 or greater.\n//\n// See https://goo.gl/fbOSZy for more details.\nfunc (c *Client) StartContainer(id string, hostConfig *HostConfig) error {\n\treturn c.startContainer(id, hostConfig, doOptions{})\n}\n\n// StartContainerWithContext starts a container, returning an error in case of\n// failure. The context can be used to cancel the outstanding start container\n// request.\n//\n// Passing the HostConfig to this method has been deprecated in Docker API 1.22\n// (Docker Engine 1.10.x) and totally removed in Docker API 1.24 (Docker Engine\n// 1.12.x). The client will ignore the parameter when communicating with Docker\n// API 1.24 or greater.\n//\n// See https://goo.gl/fbOSZy for more details.\nfunc (c *Client) StartContainerWithContext(id string, hostConfig *HostConfig, ctx context.Context) error {\n\treturn c.startContainer(id, hostConfig, doOptions{context: ctx})\n}\n\nfunc (c *Client) startContainer(id string, hostConfig *HostConfig, opts doOptions) error {\n\tpath := \"/containers/\" + id + \"/start\"\n\tif c.serverAPIVersion == nil {\n\t\tc.checkAPIVersion()\n\t}\n\tif c.serverAPIVersion != nil && c.serverAPIVersion.LessThan(apiVersion124) {\n\t\topts.data = hostConfig\n\t\topts.forceJSON = true\n\t}\n\tresp, err := c.do(http.MethodPost, path, opts)\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchContainer{ID: id, Err: err}\n\t\t}\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode == http.StatusNotModified {\n\t\treturn &ContainerAlreadyRunning{ID: id}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "container_start_test.go",
          "type": "blob",
          "size": 5.7021484375,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestStartContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.StartContainer(id, &HostConfig{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"StartContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/start\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"StartContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"StartContainer(%q): Wrong content-type in request. Want %q. Got %q.\", id, expectedContentType, contentType)\n\t}\n}\n\nfunc TestStartContainerHostConfigAPI124(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tclient.serverAPIVersion = apiVersion124\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.StartContainer(id, &HostConfig{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"StartContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/start\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"StartContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n\tnotAcceptedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType == notAcceptedContentType {\n\t\tt.Errorf(\"StartContainer(%q): Unepected %q Content-Type in request.\", id, contentType)\n\t}\n\tif req.Body != nil {\n\t\tdata, _ := io.ReadAll(req.Body)\n\t\tt.Errorf(\"StartContainer(%q): Unexpected data sent: %s\", id, data)\n\t}\n}\n\nfunc TestStartContainerNilHostConfig(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.StartContainer(id, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"StartContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/start\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"StartContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"StartContainer(%q): Wrong content-type in request. Want %q. Got %q.\", id, expectedContentType, contentType)\n\t}\n\tvar buf [4]byte\n\treq.Body.Read(buf[:])\n\tif string(buf[:]) != \"null\" {\n\t\tt.Errorf(\"Startcontainer(%q): Wrong body. Want null. Got %s\", id, buf[:])\n\t}\n}\n\nfunc TestStartContainerWithContext(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\n\tctx, cancel := context.WithTimeout(context.TODO(), 1*time.Second)\n\tdefer cancel()\n\n\tstartError := make(chan error)\n\tgo func() {\n\t\tstartError <- client.StartContainerWithContext(id, &HostConfig{}, ctx)\n\t}()\n\tselect {\n\tcase err := <-startError:\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treq := fakeRT.requests[0]\n\t\tif req.Method != http.MethodPost {\n\t\t\tt.Errorf(\"StartContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t\t}\n\t\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/start\"))\n\t\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\t\tt.Errorf(\"StartContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t\t}\n\t\texpectedContentType := \"application/json\"\n\t\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\t\tt.Errorf(\"StartContainer(%q): Wrong content-type in request. Want %q. Got %q.\", id, expectedContentType, contentType)\n\t\t}\n\tcase <-ctx.Done():\n\t\t// Context was canceled unexpectedly. Report the same.\n\t\tt.Fatalf(\"Context canceled when waiting for start container response: %v\", ctx.Err())\n\t}\n}\n\nfunc TestStartContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\terr := client.StartContainer(\"a2344\", &HostConfig{})\n\texpectNoSuchContainer(t, \"a2344\", err)\n}\n\nfunc TestStartContainerAlreadyRunning(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"container already running\", status: http.StatusNotModified})\n\terr := client.StartContainer(\"a2334\", &HostConfig{})\n\texpected := &ContainerAlreadyRunning{ID: \"a2334\"}\n\tif !reflect.DeepEqual(err, expected) {\n\t\tt.Errorf(\"StartContainer: Wrong error returned. Want %#v. Got %#v.\", expected, err)\n\t}\n}\n\nfunc TestStartContainerWhenContextTimesOut(t *testing.T) {\n\tt.Parallel()\n\trt := sleepyRoudTripper{sleepDuration: 200 * time.Millisecond}\n\n\tclient := newTestClient(&rt)\n\n\tctx, cancel := context.WithTimeout(context.TODO(), 100*time.Millisecond)\n\tdefer cancel()\n\n\terr := client.StartContainerWithContext(\"id\", nil, ctx)\n\tif !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Errorf(\"Expected 'DeadlineExceededError', got: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "container_stats.go",
          "type": "blob",
          "size": 15.734375,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// Stats represents container statistics, returned by /containers/<id>/stats.\n//\n// See https://goo.gl/Dk3Xio for more details.\ntype Stats struct {\n\tRead      time.Time `json:\"read,omitempty\" yaml:\"read,omitempty\" toml:\"read,omitempty\"`\n\tPreRead   time.Time `json:\"preread,omitempty\" yaml:\"preread,omitempty\" toml:\"preread,omitempty\"`\n\tNumProcs  uint32    `json:\"num_procs\" yaml:\"num_procs\" toml:\"num_procs\"`\n\tPidsStats struct {\n\t\tCurrent uint64 `json:\"current,omitempty\" yaml:\"current,omitempty\"`\n\t} `json:\"pids_stats,omitempty\" yaml:\"pids_stats,omitempty\" toml:\"pids_stats,omitempty\"`\n\tNetwork     NetworkStats            `json:\"network,omitempty\" yaml:\"network,omitempty\" toml:\"network,omitempty\"`\n\tNetworks    map[string]NetworkStats `json:\"networks,omitempty\" yaml:\"networks,omitempty\" toml:\"networks,omitempty\"`\n\tMemoryStats struct {\n\t\tStats struct {\n\t\t\tTotalPgmafault          uint64 `json:\"total_pgmafault,omitempty\" yaml:\"total_pgmafault,omitempty\" toml:\"total_pgmafault,omitempty\"`\n\t\t\tCache                   uint64 `json:\"cache,omitempty\" yaml:\"cache,omitempty\" toml:\"cache,omitempty\"`\n\t\t\tMappedFile              uint64 `json:\"mapped_file,omitempty\" yaml:\"mapped_file,omitempty\" toml:\"mapped_file,omitempty\"`\n\t\t\tTotalInactiveFile       uint64 `json:\"total_inactive_file,omitempty\" yaml:\"total_inactive_file,omitempty\" toml:\"total_inactive_file,omitempty\"`\n\t\t\tPgpgout                 uint64 `json:\"pgpgout,omitempty\" yaml:\"pgpgout,omitempty\" toml:\"pgpgout,omitempty\"`\n\t\t\tRss                     uint64 `json:\"rss,omitempty\" yaml:\"rss,omitempty\" toml:\"rss,omitempty\"`\n\t\t\tTotalMappedFile         uint64 `json:\"total_mapped_file,omitempty\" yaml:\"total_mapped_file,omitempty\" toml:\"total_mapped_file,omitempty\"`\n\t\t\tWriteback               uint64 `json:\"writeback,omitempty\" yaml:\"writeback,omitempty\" toml:\"writeback,omitempty\"`\n\t\t\tUnevictable             uint64 `json:\"unevictable,omitempty\" yaml:\"unevictable,omitempty\" toml:\"unevictable,omitempty\"`\n\t\t\tPgpgin                  uint64 `json:\"pgpgin,omitempty\" yaml:\"pgpgin,omitempty\" toml:\"pgpgin,omitempty\"`\n\t\t\tTotalUnevictable        uint64 `json:\"total_unevictable,omitempty\" yaml:\"total_unevictable,omitempty\" toml:\"total_unevictable,omitempty\"`\n\t\t\tPgmajfault              uint64 `json:\"pgmajfault,omitempty\" yaml:\"pgmajfault,omitempty\" toml:\"pgmajfault,omitempty\"`\n\t\t\tTotalRss                uint64 `json:\"total_rss,omitempty\" yaml:\"total_rss,omitempty\" toml:\"total_rss,omitempty\"`\n\t\t\tTotalRssHuge            uint64 `json:\"total_rss_huge,omitempty\" yaml:\"total_rss_huge,omitempty\" toml:\"total_rss_huge,omitempty\"`\n\t\t\tTotalWriteback          uint64 `json:\"total_writeback,omitempty\" yaml:\"total_writeback,omitempty\" toml:\"total_writeback,omitempty\"`\n\t\t\tTotalInactiveAnon       uint64 `json:\"total_inactive_anon,omitempty\" yaml:\"total_inactive_anon,omitempty\" toml:\"total_inactive_anon,omitempty\"`\n\t\t\tRssHuge                 uint64 `json:\"rss_huge,omitempty\" yaml:\"rss_huge,omitempty\" toml:\"rss_huge,omitempty\"`\n\t\t\tHierarchicalMemoryLimit uint64 `json:\"hierarchical_memory_limit,omitempty\" yaml:\"hierarchical_memory_limit,omitempty\" toml:\"hierarchical_memory_limit,omitempty\"`\n\t\t\tTotalPgfault            uint64 `json:\"total_pgfault,omitempty\" yaml:\"total_pgfault,omitempty\" toml:\"total_pgfault,omitempty\"`\n\t\t\tTotalActiveFile         uint64 `json:\"total_active_file,omitempty\" yaml:\"total_active_file,omitempty\" toml:\"total_active_file,omitempty\"`\n\t\t\tActiveAnon              uint64 `json:\"active_anon,omitempty\" yaml:\"active_anon,omitempty\" toml:\"active_anon,omitempty\"`\n\t\t\tTotalActiveAnon         uint64 `json:\"total_active_anon,omitempty\" yaml:\"total_active_anon,omitempty\" toml:\"total_active_anon,omitempty\"`\n\t\t\tTotalPgpgout            uint64 `json:\"total_pgpgout,omitempty\" yaml:\"total_pgpgout,omitempty\" toml:\"total_pgpgout,omitempty\"`\n\t\t\tTotalCache              uint64 `json:\"total_cache,omitempty\" yaml:\"total_cache,omitempty\" toml:\"total_cache,omitempty\"`\n\t\t\tInactiveAnon            uint64 `json:\"inactive_anon,omitempty\" yaml:\"inactive_anon,omitempty\" toml:\"inactive_anon,omitempty\"`\n\t\t\tActiveFile              uint64 `json:\"active_file,omitempty\" yaml:\"active_file,omitempty\" toml:\"active_file,omitempty\"`\n\t\t\tPgfault                 uint64 `json:\"pgfault,omitempty\" yaml:\"pgfault,omitempty\" toml:\"pgfault,omitempty\"`\n\t\t\tInactiveFile            uint64 `json:\"inactive_file,omitempty\" yaml:\"inactive_file,omitempty\" toml:\"inactive_file,omitempty\"`\n\t\t\tTotalPgpgin             uint64 `json:\"total_pgpgin,omitempty\" yaml:\"total_pgpgin,omitempty\" toml:\"total_pgpgin,omitempty\"`\n\t\t\tHierarchicalMemswLimit  uint64 `json:\"hierarchical_memsw_limit,omitempty\" yaml:\"hierarchical_memsw_limit,omitempty\" toml:\"hierarchical_memsw_limit,omitempty\"`\n\t\t\tSwap                    uint64 `json:\"swap,omitempty\" yaml:\"swap,omitempty\" toml:\"swap,omitempty\"`\n\t\t\tAnon                    uint64 `json:\"anon,omitempty\" yaml:\"anon,omitempty\" toml:\"anon,omitempty\"`\n\t\t\tAnonThp                 uint64 `json:\"anon_thp,omitempty\" yaml:\"anon_thp,omitempty\" toml:\"anon_thp,omitempty\"`\n\t\t\tFile                    uint64 `json:\"file,omitempty\" yaml:\"file,omitempty\" toml:\"file,omitempty\"`\n\t\t\tFileDirty               uint64 `json:\"file_dirty,omitempty\" yaml:\"file_dirty,omitempty\" toml:\"file_dirty,omitempty\"`\n\t\t\tFileMapped              uint64 `json:\"file_mapped,omitempty\" yaml:\"file_mapped,omitempty\" toml:\"file_mapped,omitempty\"`\n\t\t\tFileWriteback           uint64 `json:\"file_writeback,omitempty\" yaml:\"file_writeback,omitempty\" toml:\"file_writeback,omitempty\"`\n\t\t\tKernelStack             uint64 `json:\"kernel_stack,omitempty\" yaml:\"kernel_stack,omitempty\" toml:\"kernel_stack,omitempty\"`\n\t\t\tPgactivate              uint64 `json:\"pgactivate,omitempty\" yaml:\"pgactivate,omitempty\" toml:\"pgactivate,omitempty\"`\n\t\t\tPgdeactivate            uint64 `json:\"pgdeactivate,omitempty\" yaml:\"pgdeactivate,omitempty\" toml:\"pgdeactivate,omitempty\"`\n\t\t\tPglazyfree              uint64 `json:\"pglazyfree,omitempty\" yaml:\"pglazyfree,omitempty\" toml:\"pglazyfree,omitempty\"`\n\t\t\tPglazyfreed             uint64 `json:\"pglazyfreed,omitempty\" yaml:\"pglazyfreed,omitempty\" toml:\"pglazyfreed,omitempty\"`\n\t\t\tPgrefill                uint64 `json:\"pgrefill,omitempty\" yaml:\"pgrefill,omitempty\" toml:\"pgrefill,omitempty\"`\n\t\t\tPgscan                  uint64 `json:\"pgscan,omitempty\" yaml:\"pgscan,omitempty\" toml:\"pgscan,omitempty\"`\n\t\t\tPgsteal                 uint64 `json:\"pgsteal,omitempty\" yaml:\"pgsteal,omitempty\" toml:\"pgsteal,omitempty\"`\n\t\t\tShmem                   uint64 `json:\"shmem,omitempty\" yaml:\"shmem,omitempty\" toml:\"shmem,omitempty\"`\n\t\t\tSlab                    uint64 `json:\"slab,omitempty\" yaml:\"slab,omitempty\" toml:\"slab,omitempty\"`\n\t\t\tSlabReclaimable         uint64 `json:\"slab_reclaimable,omitempty\" yaml:\"slab_reclaimable,omitempty\" toml:\"slab_reclaimable,omitempty\"`\n\t\t\tSlabUnreclaimable       uint64 `json:\"slab_unreclaimable,omitempty\" yaml:\"slab_unreclaimable,omitempty\" toml:\"slab_unreclaimable,omitempty\"`\n\t\t\tSock                    uint64 `json:\"sock,omitempty\" yaml:\"sock,omitempty\" toml:\"sock,omitempty\"`\n\t\t\tThpCollapseAlloc        uint64 `json:\"thp_collapse_alloc,omitempty\" yaml:\"thp_collapse_alloc,omitempty\" toml:\"thp_collapse_alloc,omitempty\"`\n\t\t\tThpFaultAlloc           uint64 `json:\"thp_fault_alloc,omitempty\" yaml:\"thp_fault_alloc,omitempty\" toml:\"thp_fault_alloc,omitempty\"`\n\t\t\tWorkingsetActivate      uint64 `json:\"workingset_activate,omitempty\" yaml:\"workingset_activate,omitempty\" toml:\"workingset_activate,omitempty\"`\n\t\t\tWorkingsetNodereclaim   uint64 `json:\"workingset_nodereclaim,omitempty\" yaml:\"workingset_nodereclaim,omitempty\" toml:\"workingset_nodereclaim,omitempty\"`\n\t\t\tWorkingsetRefault       uint64 `json:\"workingset_refault,omitempty\" yaml:\"workingset_refault,omitempty\" toml:\"workingset_refault,omitempty\"`\n\t\t} `json:\"stats,omitempty\" yaml:\"stats,omitempty\" toml:\"stats,omitempty\"`\n\t\tMaxUsage          uint64 `json:\"max_usage,omitempty\" yaml:\"max_usage,omitempty\" toml:\"max_usage,omitempty\"`\n\t\tUsage             uint64 `json:\"usage,omitempty\" yaml:\"usage,omitempty\" toml:\"usage,omitempty\"`\n\t\tFailcnt           uint64 `json:\"failcnt,omitempty\" yaml:\"failcnt,omitempty\" toml:\"failcnt,omitempty\"`\n\t\tLimit             uint64 `json:\"limit,omitempty\" yaml:\"limit,omitempty\" toml:\"limit,omitempty\"`\n\t\tCommit            uint64 `json:\"commitbytes,omitempty\" yaml:\"commitbytes,omitempty\" toml:\"privateworkingset,omitempty\"`\n\t\tCommitPeak        uint64 `json:\"commitpeakbytes,omitempty\" yaml:\"commitpeakbytes,omitempty\" toml:\"commitpeakbytes,omitempty\"`\n\t\tPrivateWorkingSet uint64 `json:\"privateworkingset,omitempty\" yaml:\"privateworkingset,omitempty\" toml:\"privateworkingset,omitempty\"`\n\t} `json:\"memory_stats,omitempty\" yaml:\"memory_stats,omitempty\" toml:\"memory_stats,omitempty\"`\n\tBlkioStats struct {\n\t\tIOServiceBytesRecursive []BlkioStatsEntry `json:\"io_service_bytes_recursive,omitempty\" yaml:\"io_service_bytes_recursive,omitempty\" toml:\"io_service_bytes_recursive,omitempty\"`\n\t\tIOServicedRecursive     []BlkioStatsEntry `json:\"io_serviced_recursive,omitempty\" yaml:\"io_serviced_recursive,omitempty\" toml:\"io_serviced_recursive,omitempty\"`\n\t\tIOQueueRecursive        []BlkioStatsEntry `json:\"io_queue_recursive,omitempty\" yaml:\"io_queue_recursive,omitempty\" toml:\"io_queue_recursive,omitempty\"`\n\t\tIOServiceTimeRecursive  []BlkioStatsEntry `json:\"io_service_time_recursive,omitempty\" yaml:\"io_service_time_recursive,omitempty\" toml:\"io_service_time_recursive,omitempty\"`\n\t\tIOWaitTimeRecursive     []BlkioStatsEntry `json:\"io_wait_time_recursive,omitempty\" yaml:\"io_wait_time_recursive,omitempty\" toml:\"io_wait_time_recursive,omitempty\"`\n\t\tIOMergedRecursive       []BlkioStatsEntry `json:\"io_merged_recursive,omitempty\" yaml:\"io_merged_recursive,omitempty\" toml:\"io_merged_recursive,omitempty\"`\n\t\tIOTimeRecursive         []BlkioStatsEntry `json:\"io_time_recursive,omitempty\" yaml:\"io_time_recursive,omitempty\" toml:\"io_time_recursive,omitempty\"`\n\t\tSectorsRecursive        []BlkioStatsEntry `json:\"sectors_recursive,omitempty\" yaml:\"sectors_recursive,omitempty\" toml:\"sectors_recursive,omitempty\"`\n\t} `json:\"blkio_stats,omitempty\" yaml:\"blkio_stats,omitempty\" toml:\"blkio_stats,omitempty\"`\n\tCPUStats     CPUStats `json:\"cpu_stats,omitempty\" yaml:\"cpu_stats,omitempty\" toml:\"cpu_stats,omitempty\"`\n\tPreCPUStats  CPUStats `json:\"precpu_stats,omitempty\"`\n\tStorageStats struct {\n\t\tReadCountNormalized  uint64 `json:\"read_count_normalized,omitempty\" yaml:\"read_count_normalized,omitempty\" toml:\"read_count_normalized,omitempty\"`\n\t\tReadSizeBytes        uint64 `json:\"read_size_bytes,omitempty\" yaml:\"read_size_bytes,omitempty\" toml:\"read_size_bytes,omitempty\"`\n\t\tWriteCountNormalized uint64 `json:\"write_count_normalized,omitempty\" yaml:\"write_count_normalized,omitempty\" toml:\"write_count_normalized,omitempty\"`\n\t\tWriteSizeBytes       uint64 `json:\"write_size_bytes,omitempty\" yaml:\"write_size_bytes,omitempty\" toml:\"write_size_bytes,omitempty\"`\n\t} `json:\"storage_stats,omitempty\" yaml:\"storage_stats,omitempty\" toml:\"storage_stats,omitempty\"`\n}\n\n// NetworkStats is a stats entry for network stats\ntype NetworkStats struct {\n\tRxDropped uint64 `json:\"rx_dropped,omitempty\" yaml:\"rx_dropped,omitempty\" toml:\"rx_dropped,omitempty\"`\n\tRxBytes   uint64 `json:\"rx_bytes,omitempty\" yaml:\"rx_bytes,omitempty\" toml:\"rx_bytes,omitempty\"`\n\tRxErrors  uint64 `json:\"rx_errors,omitempty\" yaml:\"rx_errors,omitempty\" toml:\"rx_errors,omitempty\"`\n\tTxPackets uint64 `json:\"tx_packets,omitempty\" yaml:\"tx_packets,omitempty\" toml:\"tx_packets,omitempty\"`\n\tTxDropped uint64 `json:\"tx_dropped,omitempty\" yaml:\"tx_dropped,omitempty\" toml:\"tx_dropped,omitempty\"`\n\tRxPackets uint64 `json:\"rx_packets,omitempty\" yaml:\"rx_packets,omitempty\" toml:\"rx_packets,omitempty\"`\n\tTxErrors  uint64 `json:\"tx_errors,omitempty\" yaml:\"tx_errors,omitempty\" toml:\"tx_errors,omitempty\"`\n\tTxBytes   uint64 `json:\"tx_bytes,omitempty\" yaml:\"tx_bytes,omitempty\" toml:\"tx_bytes,omitempty\"`\n}\n\n// CPUStats is a stats entry for cpu stats\ntype CPUStats struct {\n\tCPUUsage struct {\n\t\tPercpuUsage       []uint64 `json:\"percpu_usage,omitempty\" yaml:\"percpu_usage,omitempty\" toml:\"percpu_usage,omitempty\"`\n\t\tUsageInUsermode   uint64   `json:\"usage_in_usermode,omitempty\" yaml:\"usage_in_usermode,omitempty\" toml:\"usage_in_usermode,omitempty\"`\n\t\tTotalUsage        uint64   `json:\"total_usage,omitempty\" yaml:\"total_usage,omitempty\" toml:\"total_usage,omitempty\"`\n\t\tUsageInKernelmode uint64   `json:\"usage_in_kernelmode,omitempty\" yaml:\"usage_in_kernelmode,omitempty\" toml:\"usage_in_kernelmode,omitempty\"`\n\t} `json:\"cpu_usage,omitempty\" yaml:\"cpu_usage,omitempty\" toml:\"cpu_usage,omitempty\"`\n\tSystemCPUUsage uint64 `json:\"system_cpu_usage,omitempty\" yaml:\"system_cpu_usage,omitempty\" toml:\"system_cpu_usage,omitempty\"`\n\tOnlineCPUs     uint64 `json:\"online_cpus,omitempty\" yaml:\"online_cpus,omitempty\" toml:\"online_cpus,omitempty\"`\n\tThrottlingData struct {\n\t\tPeriods          uint64 `json:\"periods,omitempty\"`\n\t\tThrottledPeriods uint64 `json:\"throttled_periods,omitempty\"`\n\t\tThrottledTime    uint64 `json:\"throttled_time,omitempty\"`\n\t} `json:\"throttling_data,omitempty\" yaml:\"throttling_data,omitempty\" toml:\"throttling_data,omitempty\"`\n}\n\n// BlkioStatsEntry is a stats entry for blkio_stats\ntype BlkioStatsEntry struct {\n\tMajor uint64 `json:\"major,omitempty\" yaml:\"major,omitempty\" toml:\"major,omitempty\"`\n\tMinor uint64 `json:\"minor,omitempty\" yaml:\"minor,omitempty\" toml:\"minor,omitempty\"`\n\tOp    string `json:\"op,omitempty\" yaml:\"op,omitempty\" toml:\"op,omitempty\"`\n\tValue uint64 `json:\"value,omitempty\" yaml:\"value,omitempty\" toml:\"value,omitempty\"`\n}\n\n// StatsOptions specify parameters to the Stats function.\n//\n// See https://goo.gl/Dk3Xio for more details.\ntype StatsOptions struct {\n\tID     string\n\tStats  chan<- *Stats\n\tStream bool\n\t// A flag that enables stopping the stats operation\n\tDone <-chan bool\n\t// Initial connection timeout\n\tTimeout time.Duration\n\t// Timeout with no data is received, it's reset every time new data\n\t// arrives\n\tInactivityTimeout time.Duration `qs:\"-\"`\n\tContext           context.Context\n}\n\n// Stats sends container statistics for the given container to the given channel.\n//\n// This function is blocking, similar to a streaming call for logs, and should be run\n// on a separate goroutine from the caller. Note that this function will block until\n// the given container is removed, not just exited. When finished, this function\n// will close the given channel. Alternatively, function can be stopped by\n// signaling on the Done channel.\n//\n// See https://goo.gl/Dk3Xio for more details.\nfunc (c *Client) Stats(opts StatsOptions) (retErr error) {\n\terrC := make(chan error, 1)\n\treadCloser, writeCloser := io.Pipe()\n\n\tdefer func() {\n\t\tclose(opts.Stats)\n\n\t\tif err := <-errC; err != nil && retErr == nil {\n\t\t\tretErr = err\n\t\t}\n\n\t\tif err := readCloser.Close(); err != nil && retErr == nil {\n\t\t\tretErr = err\n\t\t}\n\t}()\n\n\treqSent := make(chan struct{})\n\tgo func() {\n\t\tdefer close(errC)\n\t\terr := c.stream(http.MethodGet, fmt.Sprintf(\"/containers/%s/stats?stream=%v\", opts.ID, opts.Stream), streamOptions{\n\t\t\trawJSONStream:     true,\n\t\t\tuseJSONDecoder:    true,\n\t\t\tstdout:            writeCloser,\n\t\t\ttimeout:           opts.Timeout,\n\t\t\tinactivityTimeout: opts.InactivityTimeout,\n\t\t\tcontext:           opts.Context,\n\t\t\treqSent:           reqSent,\n\t\t})\n\t\tif err != nil {\n\t\t\tvar dockerError *Error\n\t\t\tif errors.As(err, &dockerError) {\n\t\t\t\tif dockerError.Status == http.StatusNotFound {\n\t\t\t\t\terr = &NoSuchContainer{ID: opts.ID}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif closeErr := writeCloser.Close(); closeErr != nil && err == nil {\n\t\t\terr = closeErr\n\t\t}\n\t\terrC <- err\n\t}()\n\n\tquit := make(chan struct{})\n\tdefer close(quit)\n\tgo func() {\n\t\t// block here waiting for the signal to stop function\n\t\tselect {\n\t\tcase <-opts.Done:\n\t\t\treadCloser.Close()\n\t\tcase <-quit:\n\t\t\treturn\n\t\t}\n\t}()\n\n\tdecoder := json.NewDecoder(readCloser)\n\tstats := new(Stats)\n\t<-reqSent\n\tfor err := decoder.Decode(stats); !errors.Is(err, io.EOF); err = decoder.Decode(stats) {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topts.Stats <- stats\n\t\tstats = new(Stats)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "container_stats_test.go",
          "type": "blob",
          "size": 16.638671875,
          "content": "package docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\n// The test for Docker Stat API of the host uses cgroup\nfunc TestStatsV1(t *testing.T) {\n\tt.Parallel()\n\tjsonStats1 := `{\n       \"read\" : \"2015-01-08T22:57:31.547920715Z\",\n       \"network\" : {\n          \"rx_dropped\" : 0,\n          \"rx_bytes\" : 648,\n          \"rx_errors\" : 0,\n          \"tx_packets\" : 8,\n          \"tx_dropped\" : 0,\n          \"rx_packets\" : 8,\n          \"tx_errors\" : 0,\n          \"tx_bytes\" : 648\n       },\n\t   \"networks\" : {\n\t\t   \"eth0\":{\n\t\t\t   \"rx_dropped\" : 0,\n\t\t\t   \"rx_bytes\" : 648,\n\t\t\t   \"rx_errors\" : 0,\n\t\t\t   \"tx_packets\" : 8,\n\t\t\t   \"tx_dropped\" : 0,\n\t\t\t   \"rx_packets\" : 8,\n\t\t\t   \"tx_errors\" : 0,\n\t\t\t   \"tx_bytes\" : 648\n\t\t   }\n\t   },\n       \"memory_stats\" : {\n          \"stats\" : {\n             \"total_pgmajfault\" : 0,\n             \"cache\" : 0,\n             \"mapped_file\" : 0,\n             \"total_inactive_file\" : 0,\n             \"pgpgout\" : 414,\n             \"rss\" : 6537216,\n             \"total_mapped_file\" : 0,\n             \"writeback\" : 0,\n             \"unevictable\" : 0,\n             \"pgpgin\" : 477,\n             \"total_unevictable\" : 0,\n             \"pgmajfault\" : 0,\n             \"total_rss\" : 6537216,\n             \"total_rss_huge\" : 6291456,\n             \"total_writeback\" : 0,\n             \"total_inactive_anon\" : 0,\n             \"rss_huge\" : 6291456,\n\t     \"hierarchical_memory_limit\": 189204833,\n             \"total_pgfault\" : 964,\n             \"total_active_file\" : 0,\n             \"active_anon\" : 6537216,\n             \"total_active_anon\" : 6537216,\n             \"total_pgpgout\" : 414,\n             \"total_cache\" : 0,\n             \"inactive_anon\" : 0,\n             \"active_file\" : 0,\n             \"pgfault\" : 964,\n             \"inactive_file\" : 0,\n             \"total_pgpgin\" : 477,\n             \"swap\" : 47312896,\n             \"hierarchical_memsw_limit\" : 1610612736\n          },\n          \"max_usage\" : 6651904,\n          \"usage\" : 6537216,\n          \"failcnt\" : 0,\n          \"limit\" : 67108864\n       },\n       \"blkio_stats\": {\n          \"io_service_bytes_recursive\": [\n             {\n                \"major\": 8,\n                \"minor\": 0,\n                \"op\": \"Read\",\n                \"value\": 428795731968\n             },\n             {\n                \"major\": 8,\n                \"minor\": 0,\n                \"op\": \"Write\",\n                \"value\": 388177920\n             }\n          ],\n          \"io_serviced_recursive\": [\n             {\n                \"major\": 8,\n                \"minor\": 0,\n                \"op\": \"Read\",\n                \"value\": 25994442\n             },\n             {\n                \"major\": 8,\n                \"minor\": 0,\n                \"op\": \"Write\",\n                \"value\": 1734\n             }\n          ],\n          \"io_queue_recursive\": [],\n          \"io_service_time_recursive\": [],\n          \"io_wait_time_recursive\": [],\n          \"io_merged_recursive\": [],\n          \"io_time_recursive\": [],\n          \"sectors_recursive\": []\n       },\n       \"cpu_stats\" : {\n          \"cpu_usage\" : {\n             \"percpu_usage\" : [\n                16970827,\n                1839451,\n                7107380,\n                10571290\n             ],\n             \"usage_in_usermode\" : 10000000,\n             \"total_usage\" : 36488948,\n             \"usage_in_kernelmode\" : 20000000\n          },\n          \"system_cpu_usage\" : 20091722000000000,\n\t\t  \"online_cpus\": 4\n       },\n       \"precpu_stats\" : {\n          \"cpu_usage\" : {\n             \"percpu_usage\" : [\n                16970827,\n                1839451,\n                7107380,\n                10571290\n             ],\n             \"usage_in_usermode\" : 10000000,\n             \"total_usage\" : 36488948,\n             \"usage_in_kernelmode\" : 20000000\n          },\n          \"system_cpu_usage\" : 20091722000000000,\n\t\t  \"online_cpus\": 4\n       }\n    }`\n\t// 1 second later, cache is 100\n\tjsonStats2 := `{\n       \"read\" : \"2015-01-08T22:57:32.547920715Z\",\n\t   \"networks\" : {\n\t\t   \"eth0\":{\n\t\t\t   \"rx_dropped\" : 0,\n\t\t\t   \"rx_bytes\" : 648,\n\t\t\t   \"rx_errors\" : 0,\n\t\t\t   \"tx_packets\" : 8,\n\t\t\t   \"tx_dropped\" : 0,\n\t\t\t   \"rx_packets\" : 8,\n\t\t\t   \"tx_errors\" : 0,\n\t\t\t   \"tx_bytes\" : 648\n\t\t   }\n\t   },\n\t   \"memory_stats\" : {\n          \"stats\" : {\n             \"total_pgmajfault\" : 0,\n             \"cache\" : 100,\n             \"mapped_file\" : 0,\n             \"total_inactive_file\" : 0,\n             \"pgpgout\" : 414,\n             \"rss\" : 6537216,\n             \"total_mapped_file\" : 0,\n             \"writeback\" : 0,\n             \"unevictable\" : 0,\n             \"pgpgin\" : 477,\n             \"total_unevictable\" : 0,\n             \"pgmajfault\" : 0,\n             \"total_rss\" : 6537216,\n             \"total_rss_huge\" : 6291456,\n             \"total_writeback\" : 0,\n             \"total_inactive_anon\" : 0,\n             \"rss_huge\" : 6291456,\n             \"total_pgfault\" : 964,\n             \"total_active_file\" : 0,\n             \"active_anon\" : 6537216,\n             \"total_active_anon\" : 6537216,\n             \"total_pgpgout\" : 414,\n             \"total_cache\" : 0,\n             \"inactive_anon\" : 0,\n             \"active_file\" : 0,\n             \"pgfault\" : 964,\n             \"inactive_file\" : 0,\n             \"total_pgpgin\" : 477,\n             \"swap\" : 47312896,\n             \"hierarchical_memsw_limit\" : 1610612736\n          },\n          \"max_usage\" : 6651904,\n          \"usage\" : 6537216,\n          \"failcnt\" : 0,\n          \"limit\" : 67108864\n       },\n       \"blkio_stats\": {\n          \"io_service_bytes_recursive\": [\n             {\n                \"major\": 8,\n                \"minor\": 0,\n                \"op\": \"Read\",\n                \"value\": 428795731968\n             },\n             {\n                \"major\": 8,\n                \"minor\": 0,\n                \"op\": \"Write\",\n                \"value\": 388177920\n             }\n          ],\n          \"io_serviced_recursive\": [\n             {\n                \"major\": 8,\n                \"minor\": 0,\n                \"op\": \"Read\",\n                \"value\": 25994442\n             },\n             {\n                \"major\": 8,\n                \"minor\": 0,\n                \"op\": \"Write\",\n                \"value\": 1734\n             }\n          ],\n          \"io_queue_recursive\": [],\n          \"io_service_time_recursive\": [],\n          \"io_wait_time_recursive\": [],\n          \"io_merged_recursive\": [],\n          \"io_time_recursive\": [],\n          \"sectors_recursive\": []\n       },\n       \"cpu_stats\" : {\n          \"cpu_usage\" : {\n             \"percpu_usage\" : [\n                16970827,\n                1839451,\n                7107380,\n                10571290\n             ],\n             \"usage_in_usermode\" : 10000000,\n             \"total_usage\" : 36488948,\n             \"usage_in_kernelmode\" : 20000000\n          },\n          \"system_cpu_usage\" : 20091722000000000,\n\t\t  \"online_cpus\": 4\n       },\n       \"precpu_stats\" : {\n          \"cpu_usage\" : {\n             \"percpu_usage\" : [\n                16970827,\n                1839451,\n                7107380,\n                10571290\n             ],\n             \"usage_in_usermode\" : 10000000,\n             \"total_usage\" : 36488948,\n             \"usage_in_kernelmode\" : 20000000\n          },\n          \"system_cpu_usage\" : 20091722000000000,\n\t\t  \"online_cpus\": 4\n       }\n    }`\n\tvar expected1 Stats\n\tvar expected2 Stats\n\terr := json.Unmarshal([]byte(jsonStats1), &expected1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = json.Unmarshal([]byte(jsonStats2), &expected2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tid := \"4fa6e0f0\"\n\n\tvar req http.Request\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(jsonStats1))\n\t\tw.Write([]byte(jsonStats2))\n\t\treq = *r\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\terrC := make(chan error, 1)\n\tstatsC := make(chan *Stats)\n\tdone := make(chan bool)\n\tdefer close(done)\n\tgo func() {\n\t\terrC <- client.Stats(StatsOptions{ID: id, Stats: statsC, Stream: true, Done: done})\n\t\tclose(errC)\n\t}()\n\tvar resultStats []*Stats\n\tfor {\n\t\tstats, ok := <-statsC\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tresultStats = append(resultStats, stats)\n\t}\n\terr = <-errC\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(resultStats) != 2 {\n\t\tt.Fatalf(\"Stats: Expected 2 results. Got %d.\", len(resultStats))\n\t}\n\tif !reflect.DeepEqual(resultStats[0], &expected1) {\n\t\tt.Errorf(\"Stats: Expected:\\n%+v\\nGot:\\n%+v\", expected1, resultStats[0])\n\t}\n\tif !reflect.DeepEqual(resultStats[1], &expected2) {\n\t\tt.Errorf(\"Stats: Expected:\\n%+v\\nGot:\\n%+v\", expected2, resultStats[1])\n\t}\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"Stats: wrong HTTP method. Want GET. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/stats\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"Stats: wrong HTTP path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n}\n\n// The test for Docker Stat API of the host uses cgroup2\nfunc TestStatsV2(t *testing.T) {\n\tt.Parallel()\n\tjsonStats1 := `{\n      \"read\": \"2022-05-18T14:37:18.175989615Z\",\n      \"preread\": \"2022-05-18T14:37:17.171501052Z\",\n      \"pids_stats\": {\n        \"current\": 29,\n        \"limit\": 76948\n      },\n      \"blkio_stats\": {\n        \"io_service_bytes_recursive\": [\n          {\n            \"major\": 259,\n            \"minor\": 0,\n            \"op\": \"read\",\n            \"value\": 11390976\n          },\n          {\n            \"major\": 259,\n            \"minor\": 0,\n            \"op\": \"write\",\n            \"value\": 0\n          }\n        ],\n        \"io_serviced_recursive\": null,\n        \"io_queue_recursive\": null,\n        \"io_service_time_recursive\": null,\n        \"io_wait_time_recursive\": null,\n        \"io_merged_recursive\": null,\n        \"io_time_recursive\": null,\n        \"sectors_recursive\": null\n      },\n      \"num_procs\": 0,\n      \"storage_stats\": {},\n      \"cpu_stats\": {\n        \"cpu_usage\": {\n          \"total_usage\": 185266562000,\n          \"usage_in_kernelmode\": 37912635000,\n          \"usage_in_usermode\": 147353926000\n        },\n        \"system_cpu_usage\": 26707255190000000,\n        \"online_cpus\": 24,\n        \"throttling_data\": {\n          \"periods\": 0,\n          \"throttled_periods\": 0,\n          \"throttled_time\": 0\n        }\n      },\n      \"precpu_stats\": {\n        \"cpu_usage\": {\n          \"total_usage\": 185266562000,\n          \"usage_in_kernelmode\": 37912635000,\n          \"usage_in_usermode\": 147353926000\n        },\n        \"system_cpu_usage\": 26707231080000000,\n        \"online_cpus\": 24,\n        \"throttling_data\": {\n          \"periods\": 0,\n          \"throttled_periods\": 0,\n          \"throttled_time\": 0\n        }\n      },\n      \"memory_stats\": {\n        \"usage\": 28557312,\n        \"stats\": {\n          \"active_anon\": 4096,\n          \"active_file\": 7446528,\n          \"anon\": 16572416,\n          \"anon_thp\": 0,\n          \"file\": 10829824,\n          \"file_dirty\": 0,\n          \"file_mapped\": 9740288,\n          \"file_writeback\": 0,\n          \"inactive_anon\": 8069120,\n          \"inactive_file\": 11882496,\n          \"kernel_stack\": 475136,\n          \"pgactivate\": 241,\n          \"pgdeactivate\": 253,\n          \"pgfault\": 7714,\n          \"pglazyfree\": 3042,\n          \"pglazyfreed\": 967,\n          \"pgmajfault\": 155,\n          \"pgrefill\": 301,\n          \"pgscan\": 1802,\n          \"pgsteal\": 1100,\n          \"shmem\": 0,\n          \"slab\": 488920,\n          \"slab_reclaimable\": 159664,\n          \"slab_unreclaimable\": 329256,\n          \"sock\": 0,\n          \"thp_collapse_alloc\": 0,\n          \"thp_fault_alloc\": 0,\n          \"unevictable\": 0,\n          \"workingset_activate\": 0,\n          \"workingset_nodereclaim\": 0,\n          \"workingset_refault\": 0\n        },\n        \"limit\": 67353382912\n      },\n      \"networks\": {\n        \"eth0\": {\n          \"rx_bytes\": 96802652,\n          \"rx_packets\": 623704,\n          \"rx_errors\": 0,\n          \"rx_dropped\": 0,\n          \"tx_bytes\": 16597749,\n          \"tx_packets\": 91982,\n          \"tx_errors\": 0,\n          \"tx_dropped\": 0\n        }\n      }\n    }`\n\t// 1 second later, shmem is 100\n\tjsonStats2 := `{\n      \"read\": \"2022-05-18T14:37:18.175989615Z\",\n      \"preread\": \"2022-05-18T14:37:17.171501052Z\",\n      \"pids_stats\": {\n        \"current\": 29,\n        \"limit\": 76948\n      },\n      \"blkio_stats\": {\n        \"io_service_bytes_recursive\": [\n          {\n            \"major\": 259,\n            \"minor\": 0,\n            \"op\": \"read\",\n            \"value\": 11390976\n          },\n          {\n            \"major\": 259,\n            \"minor\": 0,\n            \"op\": \"write\",\n            \"value\": 0\n          }\n        ],\n        \"io_serviced_recursive\": null,\n        \"io_queue_recursive\": null,\n        \"io_service_time_recursive\": null,\n        \"io_wait_time_recursive\": null,\n        \"io_merged_recursive\": null,\n        \"io_time_recursive\": null,\n        \"sectors_recursive\": null\n      },\n      \"num_procs\": 0,\n      \"storage_stats\": {},\n      \"cpu_stats\": {\n        \"cpu_usage\": {\n          \"total_usage\": 185266562000,\n          \"usage_in_kernelmode\": 37912635000,\n          \"usage_in_usermode\": 147353926000\n        },\n        \"system_cpu_usage\": 26707255190000000,\n        \"online_cpus\": 24,\n        \"throttling_data\": {\n          \"periods\": 0,\n          \"throttled_periods\": 0,\n          \"throttled_time\": 0\n        }\n      },\n      \"precpu_stats\": {\n        \"cpu_usage\": {\n          \"total_usage\": 185266562000,\n          \"usage_in_kernelmode\": 37912635000,\n          \"usage_in_usermode\": 147353926000\n        },\n        \"system_cpu_usage\": 26707231080000000,\n        \"online_cpus\": 24,\n        \"throttling_data\": {\n          \"periods\": 0,\n          \"throttled_periods\": 0,\n          \"throttled_time\": 0\n        }\n      },\n      \"memory_stats\": {\n        \"usage\": 28557312,\n        \"stats\": {\n          \"active_anon\": 4096,\n          \"active_file\": 7446528,\n          \"anon\": 16572416,\n          \"anon_thp\": 0,\n          \"file\": 10829824,\n          \"file_dirty\": 0,\n          \"file_mapped\": 9740288,\n          \"file_writeback\": 0,\n          \"inactive_anon\": 8069120,\n          \"inactive_file\": 11882496,\n          \"kernel_stack\": 475136,\n          \"pgactivate\": 241,\n          \"pgdeactivate\": 253,\n          \"pgfault\": 7714,\n          \"pglazyfree\": 3042,\n          \"pglazyfreed\": 967,\n          \"pgmajfault\": 155,\n          \"pgrefill\": 301,\n          \"pgscan\": 1802,\n          \"pgsteal\": 1100,\n          \"shmem\": 100,\n          \"slab\": 488920,\n          \"slab_reclaimable\": 159664,\n          \"slab_unreclaimable\": 329256,\n          \"sock\": 0,\n          \"thp_collapse_alloc\": 0,\n          \"thp_fault_alloc\": 0,\n          \"unevictable\": 0,\n          \"workingset_activate\": 0,\n          \"workingset_nodereclaim\": 0,\n          \"workingset_refault\": 0\n        },\n        \"limit\": 67353382912\n      },\n      \"networks\": {\n        \"eth0\": {\n          \"rx_bytes\": 96802652,\n          \"rx_packets\": 623704,\n          \"rx_errors\": 0,\n          \"rx_dropped\": 0,\n          \"tx_bytes\": 16597749,\n          \"tx_packets\": 91982,\n          \"tx_errors\": 0,\n          \"tx_dropped\": 0\n        }\n      }\n    }`\n\tvar expected1 Stats\n\tvar expected2 Stats\n\terr := json.Unmarshal([]byte(jsonStats1), &expected1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = json.Unmarshal([]byte(jsonStats2), &expected2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tid := \"4fa6e0f0\"\n\n\tvar req http.Request\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(jsonStats1))\n\t\tw.Write([]byte(jsonStats2))\n\t\treq = *r\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\terrC := make(chan error, 1)\n\tstatsC := make(chan *Stats)\n\tdone := make(chan bool)\n\tdefer close(done)\n\tgo func() {\n\t\terrC <- client.Stats(StatsOptions{ID: id, Stats: statsC, Stream: true, Done: done})\n\t\tclose(errC)\n\t}()\n\tvar resultStats []*Stats\n\tfor {\n\t\tstats, ok := <-statsC\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tresultStats = append(resultStats, stats)\n\t}\n\terr = <-errC\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(resultStats) != 2 {\n\t\tt.Fatalf(\"Stats: Expected 2 results. Got %d.\", len(resultStats))\n\t}\n\tif !reflect.DeepEqual(resultStats[0], &expected1) {\n\t\tt.Errorf(\"Stats: Expected:\\n%+v\\nGot:\\n%+v\", expected1, resultStats[0])\n\t}\n\tif !reflect.DeepEqual(resultStats[1], &expected2) {\n\t\tt.Errorf(\"Stats: Expected:\\n%+v\\nGot:\\n%+v\", expected2, resultStats[1])\n\t}\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"Stats: wrong HTTP method. Want GET. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/stats\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"Stats: wrong HTTP path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestStatsContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\tstatsC := make(chan *Stats)\n\tdone := make(chan bool)\n\tdefer close(done)\n\terr := client.Stats(StatsOptions{ID: \"abef348\", Stats: statsC, Stream: true, Done: done})\n\texpectNoSuchContainer(t, \"abef348\", err)\n}\n"
        },
        {
          "name": "container_stop.go",
          "type": "blob",
          "size": 1.13671875,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// StopContainer stops a container, killing it after the given timeout (in\n// seconds).\n//\n// See https://goo.gl/R9dZcV for more details.\nfunc (c *Client) StopContainer(id string, timeout uint) error {\n\treturn c.stopContainer(id, timeout, doOptions{})\n}\n\n// StopContainerWithContext stops a container, killing it after the given\n// timeout (in seconds). The context can be used to cancel the stop\n// container request.\n//\n// See https://goo.gl/R9dZcV for more details.\nfunc (c *Client) StopContainerWithContext(id string, timeout uint, ctx context.Context) error {\n\treturn c.stopContainer(id, timeout, doOptions{context: ctx})\n}\n\nfunc (c *Client) stopContainer(id string, timeout uint, opts doOptions) error {\n\tpath := fmt.Sprintf(\"/containers/%s/stop?t=%d\", id, timeout)\n\tresp, err := c.do(http.MethodPost, path, opts)\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchContainer{ID: id}\n\t\t}\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode == http.StatusNotModified {\n\t\treturn &ContainerNotRunning{ID: id}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "container_stop_test.go",
          "type": "blob",
          "size": 2.9306640625,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestStopContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.StopContainer(id, 10)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"StopContainer(%q, 10): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/stop\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"StopContainer(%q, 10): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestStopContainerWithContext(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\n\tctx, cancel := context.WithTimeout(context.TODO(), 1*time.Second)\n\tdefer cancel()\n\n\tstopError := make(chan error)\n\tgo func() {\n\t\tstopError <- client.StopContainerWithContext(id, 10, ctx)\n\t}()\n\tselect {\n\tcase err := <-stopError:\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treq := fakeRT.requests[0]\n\t\tif req.Method != http.MethodPost {\n\t\t\tt.Errorf(\"StopContainer(%q, 10): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t\t}\n\t\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/stop\"))\n\t\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\t\tt.Errorf(\"StopContainer(%q, 10): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t\t}\n\tcase <-ctx.Done():\n\t\t// Context was canceled unexpectedly. Report the same.\n\t\tt.Fatalf(\"Context canceled when waiting for stop container response: %v\", ctx.Err())\n\t}\n}\n\nfunc TestStopContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\terr := client.StopContainer(\"a2334\", 10)\n\texpectNoSuchContainer(t, \"a2334\", err)\n}\n\nfunc TestStopContainerNotRunning(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"container not running\", status: http.StatusNotModified})\n\terr := client.StopContainer(\"a2334\", 10)\n\texpected := &ContainerNotRunning{ID: \"a2334\"}\n\tif !reflect.DeepEqual(err, expected) {\n\t\tt.Errorf(\"StopContainer: Wrong error returned. Want %#v. Got %#v.\", expected, err)\n\t}\n}\n\nfunc TestStopContainerWhenContextTimesOut(t *testing.T) {\n\tt.Parallel()\n\trt := sleepyRoudTripper{sleepDuration: 300 * time.Millisecond}\n\n\tclient := newTestClient(&rt)\n\n\tctx, cancel := context.WithTimeout(context.TODO(), 50*time.Millisecond)\n\tdefer cancel()\n\n\terr := client.StopContainerWithContext(\"id\", 10, ctx)\n\tif !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Errorf(\"Expected 'DeadlineExceededError', got: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "container_test.go",
          "type": "blob",
          "size": 2.8134765625,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestStateString(t *testing.T) {\n\tt.Parallel()\n\tstarted := time.Now().Add(-3 * time.Hour)\n\ttests := []struct {\n\t\tname     string\n\t\tinput    State\n\t\texpected string\n\t}{\n\t\t{\"paused\", State{Running: true, Paused: true, StartedAt: started}, \"Up 3 hours (Paused)\"},\n\t\t{\"restarting\", State{Running: true, Restarting: true, ExitCode: 7, FinishedAt: started}, \"Restarting (7) 3 hours ago\"},\n\t\t{\"up\", State{Running: true, StartedAt: started}, \"Up 3 hours\"},\n\t\t{\"being removed\", State{RemovalInProgress: true}, \"Removal In Progress\"},\n\t\t{\"dead\", State{Dead: true}, \"Dead\"},\n\t\t{\"created\", State{}, \"Created\"},\n\t\t{\"no creation info\", State{StartedAt: started}, \"\"},\n\t\t{\"erro code\", State{ExitCode: 7, StartedAt: started, FinishedAt: started}, \"Exited (7) 3 hours ago\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif got := test.input.String(); got != test.expected {\n\t\t\t\tt.Errorf(\"State.String(): wrong result. Want %q. Got %q.\", test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestStateStateString(t *testing.T) {\n\tt.Parallel()\n\tstarted := time.Now().Add(-3 * time.Hour)\n\ttests := []struct {\n\t\tinput    State\n\t\texpected string\n\t}{\n\t\t{State{Running: true, Paused: true}, \"paused\"},\n\t\t{State{Running: true, Restarting: true}, \"restarting\"},\n\t\t{State{Running: true}, \"running\"},\n\t\t{State{Dead: true}, \"dead\"},\n\t\t{State{}, \"created\"},\n\t\t{State{StartedAt: started}, \"exited\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif got := test.input.StateString(); got != test.expected {\n\t\t\t\tt.Errorf(\"State.String(): wrong result. Want %q. Got %q.\", test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// sleepyRoundTripper implements the http.RoundTripper interface. It sleeps\n// for the 'sleep' duration and then returns an error for RoundTrip method.\ntype sleepyRoudTripper struct {\n\tsleepDuration time.Duration\n}\n\nfunc (rt *sleepyRoudTripper) RoundTrip(r *http.Request) (*http.Response, error) {\n\ttime.Sleep(rt.sleepDuration)\n\treturn nil, errors.New(\"Can't complete round trip\")\n}\n\nfunc TestNoSuchContainerError(t *testing.T) {\n\tt.Parallel()\n\terr := &NoSuchContainer{ID: \"i345\"}\n\texpected := \"No such container: i345\"\n\tif got := err.Error(); got != expected {\n\t\tt.Errorf(\"NoSuchContainer: wrong message. Want %q. Got %q.\", expected, got)\n\t}\n}\n\nfunc TestNoSuchContainerErrorMessage(t *testing.T) {\n\tt.Parallel()\n\terr := &NoSuchContainer{ID: \"i345\", Err: errors.New(\"some advanced error info\")}\n\texpected := \"some advanced error info\"\n\tif got := err.Error(); got != expected {\n\t\tt.Errorf(\"NoSuchContainer: wrong message. Want %q. Got %q.\", expected, got)\n\t}\n}\n"
        },
        {
          "name": "container_top.go",
          "type": "blob",
          "size": 0.943359375,
          "content": "package docker\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// TopResult represents the list of processes running in a container, as\n// returned by /containers/<id>/top.\n//\n// See https://goo.gl/FLwpPl for more details.\ntype TopResult struct {\n\tTitles    []string\n\tProcesses [][]string\n}\n\n// TopContainer returns processes running inside a container\n//\n// See https://goo.gl/FLwpPl for more details.\nfunc (c *Client) TopContainer(id string, psArgs string) (TopResult, error) {\n\tvar args string\n\tvar result TopResult\n\tif psArgs != \"\" {\n\t\targs = fmt.Sprintf(\"?ps_args=%s\", psArgs)\n\t}\n\tpath := fmt.Sprintf(\"/containers/%s/top%s\", id, args)\n\tresp, err := c.do(http.MethodGet, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn result, &NoSuchContainer{ID: id}\n\t\t}\n\t\treturn result, err\n\t}\n\tdefer resp.Body.Close()\n\terr = json.NewDecoder(resp.Body).Decode(&result)\n\treturn result, err\n}\n"
        },
        {
          "name": "container_top_test.go",
          "type": "blob",
          "size": 2.107421875,
          "content": "package docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestTopContainer(t *testing.T) {\n\tt.Parallel()\n\tjsonTop := `{\n  \"Processes\": [\n    [\n      \"ubuntu\",\n      \"3087\",\n      \"815\",\n      \"0\",\n      \"01:44\",\n      \"?\",\n      \"00:00:00\",\n      \"cmd1\"\n    ],\n    [\n      \"root\",\n      \"3158\",\n      \"3087\",\n      \"0\",\n      \"01:44\",\n      \"?\",\n      \"00:00:01\",\n      \"cmd2\"\n    ]\n  ],\n  \"Titles\": [\n    \"UID\",\n    \"PID\",\n    \"PPID\",\n    \"C\",\n    \"STIME\",\n    \"TTY\",\n    \"TIME\",\n    \"CMD\"\n  ]\n}`\n\tvar expected TopResult\n\terr := json.Unmarshal([]byte(jsonTop), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tid := \"4fa6e0f0\"\n\tfakeRT := &FakeRoundTripper{message: jsonTop, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tprocesses, err := client.TopContainer(id, \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(processes, expected) {\n\t\tt.Errorf(\"TopContainer: Expected %#v. Got %#v.\", expected, processes)\n\t}\n\tif len(processes.Processes) != 2 || len(processes.Processes[0]) != 8 ||\n\t\tprocesses.Processes[0][7] != \"cmd1\" {\n\t\tt.Errorf(\"TopContainer: Process list to include cmd1. Got %#v.\", processes)\n\t}\n\texpectedURI := \"/containers/\" + id + \"/top\"\n\tif !strings.HasSuffix(fakeRT.requests[0].URL.String(), expectedURI) {\n\t\tt.Errorf(\"TopContainer: Expected URI to have %q. Got %q.\", expectedURI, fakeRT.requests[0].URL.String())\n\t}\n}\n\nfunc TestTopContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\t_, err := client.TopContainer(\"abef348\", \"\")\n\texpectNoSuchContainer(t, \"abef348\", err)\n}\n\nfunc TestTopContainerWithPsArgs(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound}\n\tclient := newTestClient(fakeRT)\n\t_, err := client.TopContainer(\"abef348\", \"aux\")\n\texpectNoSuchContainer(t, \"abef348\", err)\n\n\texpectedURI := \"/containers/abef348/top?ps_args=aux\"\n\tif !strings.HasSuffix(fakeRT.requests[0].URL.String(), expectedURI) {\n\t\tt.Errorf(\"TopContainer: Expected URI to have %q. Got %q.\", expectedURI, fakeRT.requests[0].URL.String())\n\t}\n}\n"
        },
        {
          "name": "container_unix_test.go",
          "type": "blob",
          "size": 3.7080078125,
          "content": "//go:build !windows\n\n// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestExportContainerViaUnixSocket(t *testing.T) {\n\tt.Parallel()\n\tcontent := \"exported container tar content\"\n\tvar buf []byte\n\tout := bytes.NewBuffer(buf)\n\ttempSocket := tempfile(\"export_socket\")\n\tdefer os.Remove(tempSocket)\n\tendpoint := \"unix://\" + tempSocket\n\tu, _ := parseEndpoint(endpoint, false)\n\tclient := Client{\n\t\tHTTPClient:             defaultClient(),\n\t\tDialer:                 &net.Dialer{},\n\t\tendpoint:               endpoint,\n\t\tendpointURL:            u,\n\t\tSkipServerVersionCheck: true,\n\t}\n\tlistening := make(chan string)\n\tdone := make(chan int)\n\tcontainerID := \"4fa6e0f0c678\"\n\tgo runStreamConnServer(t, \"unix\", tempSocket, listening, done, containerID)\n\t<-listening // wait for server to start\n\topts := ExportContainerOptions{ID: containerID, OutputStream: out}\n\terr := client.ExportContainer(opts)\n\t<-done // make sure server stopped\n\tif err != nil {\n\t\tt.Errorf(\"ExportContainer: caugh error %#v while exporting container, expected nil\", err.Error())\n\t}\n\tif out.String() != content {\n\t\tt.Errorf(\"ExportContainer: wrong stdout. Want %#v. Got %#v.\", content, out.String())\n\t}\n}\n\nfunc TestStatsTimeoutUnixSocket(t *testing.T) {\n\tt.Parallel()\n\ttmpdir, err := os.MkdirTemp(\"\", \"socket\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tmpdir)\n\tsocketPath := filepath.Join(tmpdir, \"docker_test.sock\")\n\tt.Logf(\"socketPath=%s\", socketPath)\n\tl, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treceived := make(chan bool)\n\tdefer l.Close()\n\tgo func() {\n\t\tconn, connErr := l.Accept()\n\t\tif connErr != nil {\n\t\t\tt.Logf(\"Failed to accept connection: %s\", connErr)\n\t\t\treturn\n\t\t}\n\t\tbreader := bufio.NewReader(conn)\n\t\treq, connErr := http.ReadRequest(breader)\n\t\tif connErr != nil {\n\t\t\tt.Logf(\"Failed to read request: %s\", connErr)\n\t\t\treturn\n\t\t}\n\t\tif req.URL.Path != \"/containers/c/stats\" {\n\t\t\tt.Logf(\"Wrong URL path for stats: %q\", req.URL.Path)\n\t\t\treturn\n\t\t}\n\t\treceived <- true\n\t\ttime.Sleep(2 * time.Second)\n\t}()\n\tclient, _ := NewClient(\"unix://\" + socketPath)\n\tclient.SkipServerVersionCheck = true\n\terrC := make(chan error, 1)\n\tstatsC := make(chan *Stats)\n\tdone := make(chan bool)\n\tdefer close(done)\n\tgo func() {\n\t\terrC <- client.Stats(StatsOptions{ID: \"c\", Stats: statsC, Stream: true, Done: done, Timeout: time.Millisecond})\n\t\tclose(errC)\n\t}()\n\terr = <-errC\n\te, ok := err.(net.Error)\n\tif !ok || !e.Timeout() {\n\t\tt.Errorf(\"Failed to receive timeout error, got %#v\", err)\n\t}\n\trecvTimeout := 2 * time.Second\n\tselect {\n\tcase <-received:\n\t\treturn\n\tcase <-time.After(recvTimeout):\n\t\tt.Fatalf(\"Timeout waiting to receive message after %v\", recvTimeout)\n\t}\n}\n\nfunc runStreamConnServer(t *testing.T, network, laddr string, listening chan<- string, done chan<- int, containerID string) {\n\tdefer close(done)\n\tl, err := net.Listen(network, laddr)\n\tif err != nil {\n\t\tt.Errorf(\"Listen(%q, %q) failed: %v\", network, laddr, err)\n\t\tlistening <- \"<nil>\"\n\t\treturn\n\t}\n\tdefer l.Close()\n\tlistening <- l.Addr().String()\n\tc, err := l.Accept()\n\tif err != nil {\n\t\tt.Logf(\"Accept failed: %v\", err)\n\t\treturn\n\t}\n\tdefer c.Close()\n\tbreader := bufio.NewReader(c)\n\treq, err := http.ReadRequest(breader)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tif path := \"/containers/\" + containerID + \"/export\"; req.URL.Path != path {\n\t\tt.Errorf(\"wrong path. Want %q. Got %q\", path, req.URL.Path)\n\t\treturn\n\t}\n\tc.Write([]byte(\"HTTP/1.1 200 OK\\n\\nexported container tar content\"))\n}\n\nfunc tempfile(filename string) string {\n\treturn os.TempDir() + \"/\" + filename + \".\" + strconv.Itoa(os.Getpid())\n}\n"
        },
        {
          "name": "container_unpause.go",
          "type": "blob",
          "size": 0.4853515625,
          "content": "package docker\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// UnpauseContainer unpauses the given container.\n//\n// See https://goo.gl/sZ2faO for more details.\nfunc (c *Client) UnpauseContainer(id string) error {\n\tpath := fmt.Sprintf(\"/containers/%s/unpause\", id)\n\tresp, err := c.do(http.MethodPost, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchContainer{ID: id}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n"
        },
        {
          "name": "container_unpause_test.go",
          "type": "blob",
          "size": 1.0107421875,
          "content": "package docker\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestUnpauseContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.UnpauseContainer(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"PauseContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/unpause\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"PauseContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestUnpauseContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\terr := client.UnpauseContainer(\"a2334\")\n\texpectNoSuchContainer(t, \"a2334\", err)\n}\n"
        },
        {
          "name": "container_update.go",
          "type": "blob",
          "size": 1.3857421875,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// UpdateContainerOptions specify parameters to the UpdateContainer function.\n//\n// See https://goo.gl/Y6fXUy for more details.\ntype UpdateContainerOptions struct {\n\tBlkioWeight        int           `json:\"BlkioWeight\"`\n\tCPUShares          int           `json:\"CpuShares\"`\n\tCPUPeriod          int           `json:\"CpuPeriod\"`\n\tCPURealtimePeriod  int64         `json:\"CpuRealtimePeriod\"`\n\tCPURealtimeRuntime int64         `json:\"CpuRealtimeRuntime\"`\n\tCPUQuota           int           `json:\"CpuQuota\"`\n\tCpusetCpus         string        `json:\"CpusetCpus\"`\n\tCpusetMems         string        `json:\"CpusetMems\"`\n\tMemory             int           `json:\"Memory\"`\n\tMemorySwap         int           `json:\"MemorySwap\"`\n\tMemoryReservation  int           `json:\"MemoryReservation\"`\n\tKernelMemory       int           `json:\"KernelMemory\"`\n\tRestartPolicy      RestartPolicy `json:\"RestartPolicy,omitempty\"`\n\tContext            context.Context\n}\n\n// UpdateContainer updates the container at ID with the options\n//\n// See https://goo.gl/Y6fXUy for more details.\nfunc (c *Client) UpdateContainer(id string, opts UpdateContainerOptions) error {\n\tresp, err := c.do(http.MethodPost, fmt.Sprintf(\"/containers/\"+id+\"/update\"), doOptions{\n\t\tdata:      opts,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\treturn nil\n}\n"
        },
        {
          "name": "container_update_test.go",
          "type": "blob",
          "size": 1.3095703125,
          "content": "package docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestUpdateContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tupdate := UpdateContainerOptions{Memory: 12345, CpusetMems: \"0,1\"}\n\terr := client.UpdateContainer(id, update)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"UpdateContainer: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/update\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"UpdateContainer: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"UpdateContainer: Wrong content-type in request. Want %q. Got %q.\", expectedContentType, contentType)\n\t}\n\tvar out UpdateContainerOptions\n\tif err := json.NewDecoder(req.Body).Decode(&out); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(out, update) {\n\t\tt.Errorf(\"UpdateContainer: wrong body, got: %#v, want %#v\", out, update)\n\t}\n}\n"
        },
        {
          "name": "container_wait.go",
          "type": "blob",
          "size": 1.1474609375,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n)\n\n// WaitContainer blocks until the given container stops, return the exit code\n// of the container status.\n//\n// See https://goo.gl/4AGweZ for more details.\nfunc (c *Client) WaitContainer(id string) (int, error) {\n\treturn c.waitContainer(id, doOptions{})\n}\n\n// WaitContainerWithContext blocks until the given container stops, return the exit code\n// of the container status. The context object can be used to cancel the\n// inspect request.\n//\n// See https://goo.gl/4AGweZ for more details.\nfunc (c *Client) WaitContainerWithContext(id string, ctx context.Context) (int, error) {\n\treturn c.waitContainer(id, doOptions{context: ctx})\n}\n\nfunc (c *Client) waitContainer(id string, opts doOptions) (int, error) {\n\tresp, err := c.do(http.MethodPost, \"/containers/\"+id+\"/wait\", opts)\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn 0, &NoSuchContainer{ID: id}\n\t\t}\n\t\treturn 0, err\n\t}\n\tdefer resp.Body.Close()\n\tvar r struct{ StatusCode int }\n\tif err := json.NewDecoder(resp.Body).Decode(&r); err != nil {\n\t\treturn 0, err\n\t}\n\treturn r.StatusCode, nil\n}\n"
        },
        {
          "name": "container_wait_test.go",
          "type": "blob",
          "size": 2.7861328125,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestWaitContainer(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: `{\"StatusCode\": 56}`, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tstatus, err := client.WaitContainer(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif status != 56 {\n\t\tt.Errorf(\"WaitContainer(%q): wrong return. Want 56. Got %d.\", id, status)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"WaitContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/wait\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"WaitContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestWaitContainerWithContext(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: `{\"StatusCode\": 56}`, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\n\tctx, cancel := context.WithTimeout(context.TODO(), 1*time.Second)\n\tdefer cancel()\n\n\tvar status int\n\twaitError := make(chan error)\n\tgo func() {\n\t\tvar err error\n\t\tstatus, err = client.WaitContainerWithContext(id, ctx)\n\t\twaitError <- err\n\t}()\n\tselect {\n\tcase err := <-waitError:\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif status != 56 {\n\t\t\tt.Errorf(\"WaitContainer(%q): wrong return. Want 56. Got %d.\", id, status)\n\t\t}\n\t\treq := fakeRT.requests[0]\n\t\tif req.Method != http.MethodPost {\n\t\t\tt.Errorf(\"WaitContainer(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodPost, req.Method)\n\t\t}\n\t\texpectedURL, _ := url.Parse(client.getURL(\"/containers/\" + id + \"/wait\"))\n\t\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\t\tt.Errorf(\"WaitContainer(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t\t}\n\tcase <-ctx.Done():\n\t\t// Context was canceled unexpectedly. Report the same.\n\t\tt.Fatalf(\"Context canceled when waiting for wait container response: %v\", ctx.Err())\n\t}\n}\n\nfunc TestWaitContainerNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such container\", status: http.StatusNotFound})\n\t_, err := client.WaitContainer(\"a2334\")\n\texpectNoSuchContainer(t, \"a2334\", err)\n}\n\nfunc TestWaitContainerWhenContextTimesOut(t *testing.T) {\n\tt.Parallel()\n\trt := sleepyRoudTripper{sleepDuration: 200 * time.Millisecond}\n\n\tclient := newTestClient(&rt)\n\n\tctx, cancel := context.WithTimeout(context.TODO(), 100*time.Millisecond)\n\tdefer cancel()\n\n\t_, err := client.WaitContainerWithContext(\"id\", ctx)\n\tif !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Errorf(\"Expected 'DeadlineExceededError', got: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "distribution.go",
          "type": "blob",
          "size": 0.7939453125,
          "content": "// Copyright 2017 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/docker/docker/api/types/registry\"\n)\n\n// InspectDistribution returns image digest and platform information by contacting the registry\nfunc (c *Client) InspectDistribution(name string) (*registry.DistributionInspect, error) {\n\tpath := \"/distribution/\" + name + \"/json\"\n\tresp, err := c.do(http.MethodGet, path, doOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar distributionInspect registry.DistributionInspect\n\tif err := json.NewDecoder(resp.Body).Decode(&distributionInspect); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &distributionInspect, nil\n}\n"
        },
        {
          "name": "distribution_test.go",
          "type": "blob",
          "size": 1.3896484375,
          "content": "// Copyright 2017 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types/registry\"\n)\n\nfunc TestInspectDistribution(t *testing.T) {\n\tt.Parallel()\n\tjsonDistribution := `{\n   \"Descriptor\": {\n    \"MediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n    \"Digest\": \"sha256:c0537ff6a5218ef531ece93d4984efc99bbf3f7497c0a7726c88e2bb7584dc96\",\n    \"Size\": 3987495,\n    \"URLs\": [\n      \"\"\n    ]\n  },\n  \"Platforms\": [\n    {\n      \"Architecture\": \"amd64\",\n      \"OS\": \"linux\",\n      \"OSVersion\": \"\",\n      \"OSFeatures\": [\n        \"\"\n      ],\n      \"Variant\": \"\",\n      \"Features\": [\n        \"\"\n      ]\n    }\n  ]\n}`\n\n\tvar expected registry.DistributionInspect\n\terr := json.Unmarshal([]byte(jsonDistribution), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonDistribution, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\t// image name/tag is not present in the reply, so it can be omitted for testing purposes\n\tdistributionInspect, err := client.InspectDistribution(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*distributionInspect, expected) {\n\t\tt.Errorf(\"InspectDistribution(%q): Expected %#v. Got %#v.\", \"\", expected, distributionInspect)\n\t}\n}\n"
        },
        {
          "name": "env.go",
          "type": "blob",
          "size": 4.4384765625,
          "content": "// Copyright 2014 Docker authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the DOCKER-LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Env represents a list of key-pair represented in the form KEY=VALUE.\ntype Env []string\n\n// Get returns the string value of the given key.\nfunc (env *Env) Get(key string) (value string) {\n\treturn env.Map()[key]\n}\n\n// Exists checks whether the given key is defined in the internal Env\n// representation.\nfunc (env *Env) Exists(key string) bool {\n\t_, exists := env.Map()[key]\n\treturn exists\n}\n\n// GetBool returns a boolean representation of the given key. The key is false\n// whenever its value if 0, no, false, none or an empty string. Any other value\n// will be interpreted as true.\nfunc (env *Env) GetBool(key string) (value bool) {\n\ts := strings.ToLower(strings.Trim(env.Get(key), \" \\t\"))\n\tif s == \"\" || s == \"0\" || s == \"no\" || s == \"false\" || s == \"none\" {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// SetBool defines a boolean value to the given key.\nfunc (env *Env) SetBool(key string, value bool) {\n\tif value {\n\t\tenv.Set(key, \"1\")\n\t} else {\n\t\tenv.Set(key, \"0\")\n\t}\n}\n\n// GetInt returns the value of the provided key, converted to int.\n//\n// It the value cannot be represented as an integer, it returns -1.\nfunc (env *Env) GetInt(key string) int {\n\treturn int(env.GetInt64(key))\n}\n\n// SetInt defines an integer value to the given key.\nfunc (env *Env) SetInt(key string, value int) {\n\tenv.Set(key, strconv.Itoa(value))\n}\n\n// GetInt64 returns the value of the provided key, converted to int64.\n//\n// It the value cannot be represented as an integer, it returns -1.\nfunc (env *Env) GetInt64(key string) int64 {\n\ts := strings.Trim(env.Get(key), \" \\t\")\n\tval, err := strconv.ParseInt(s, 10, 64)\n\tif err != nil {\n\t\treturn -1\n\t}\n\treturn val\n}\n\n// SetInt64 defines an integer (64-bit wide) value to the given key.\nfunc (env *Env) SetInt64(key string, value int64) {\n\tenv.Set(key, strconv.FormatInt(value, 10))\n}\n\n// GetJSON unmarshals the value of the provided key in the provided iface.\n//\n// iface is a value that can be provided to the json.Unmarshal function.\nfunc (env *Env) GetJSON(key string, iface any) error {\n\tsval := env.Get(key)\n\tif sval == \"\" {\n\t\treturn nil\n\t}\n\treturn json.Unmarshal([]byte(sval), iface)\n}\n\n// SetJSON marshals the given value to JSON format and stores it using the\n// provided key.\nfunc (env *Env) SetJSON(key string, value any) error {\n\tsval, err := json.Marshal(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenv.Set(key, string(sval))\n\treturn nil\n}\n\n// GetList returns a list of strings matching the provided key. It handles the\n// list as a JSON representation of a list of strings.\n//\n// If the given key matches to a single string, it will return a list\n// containing only the value that matches the key.\nfunc (env *Env) GetList(key string) []string {\n\tsval := env.Get(key)\n\tif sval == \"\" {\n\t\treturn nil\n\t}\n\tvar l []string\n\tif err := json.Unmarshal([]byte(sval), &l); err != nil {\n\t\tl = append(l, sval)\n\t}\n\treturn l\n}\n\n// SetList stores the given list in the provided key, after serializing it to\n// JSON format.\nfunc (env *Env) SetList(key string, value []string) error {\n\treturn env.SetJSON(key, value)\n}\n\n// Set defines the value of a key to the given string.\nfunc (env *Env) Set(key, value string) {\n\t*env = append(*env, key+\"=\"+value)\n}\n\n// Decode decodes `src` as a json dictionary, and adds each decoded key-value\n// pair to the environment.\n//\n// If `src` cannot be decoded as a json dictionary, an error is returned.\nfunc (env *Env) Decode(src io.Reader) error {\n\tm := make(map[string]any)\n\tif err := json.NewDecoder(src).Decode(&m); err != nil {\n\t\treturn err\n\t}\n\tfor k, v := range m {\n\t\tenv.SetAuto(k, v)\n\t}\n\treturn nil\n}\n\n// SetAuto will try to define the Set* method to call based on the given value.\nfunc (env *Env) SetAuto(key string, value any) {\n\tif fval, ok := value.(float64); ok {\n\t\tenv.SetInt64(key, int64(fval))\n\t} else if sval, ok := value.(string); ok {\n\t\tenv.Set(key, sval)\n\t} else if val, err := json.Marshal(value); err == nil {\n\t\tenv.Set(key, string(val))\n\t} else {\n\t\tenv.Set(key, fmt.Sprintf(\"%v\", value))\n\t}\n}\n\n// Map returns the map representation of the env.\nfunc (env *Env) Map() map[string]string {\n\tif env == nil || len(*env) == 0 {\n\t\treturn nil\n\t}\n\tm := make(map[string]string)\n\tfor _, kv := range *env {\n\t\tparts := strings.SplitN(kv, \"=\", 2)\n\t\tif len(parts) == 1 {\n\t\t\tm[parts[0]] = \"\"\n\t\t} else {\n\t\t\tm[parts[0]] = parts[1]\n\t\t}\n\t}\n\treturn m\n}\n"
        },
        {
          "name": "env_test.go",
          "type": "blob",
          "size": 9.7412109375,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the DOCKER-LICENSE file.\n\npackage docker\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"reflect\"\n\t\"slices\"\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    []string\n\t\tquery    string\n\t\texpected string\n\t}{\n\t\t{[]string{\"PATH=/usr/bin:/bin\", \"PYTHONPATH=/usr/local\"}, \"PATH\", \"/usr/bin:/bin\"},\n\t\t{[]string{\"PATH=/usr/bin:/bin\", \"PYTHONPATH=/usr/local\"}, \"PYTHONPATH\", \"/usr/local\"},\n\t\t{[]string{\"PATH=/usr/bin:/bin\", \"PYTHONPATH=/usr/local\"}, \"PYTHONPATHI\", \"\"},\n\t\t{[]string{\"WAT=\"}, \"WAT\", \"\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tenv := Env(test.input)\n\t\t\tgot := env.Get(test.query)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"Env.Get(%q): wrong result. Want %q. Got %q\", test.query, test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExists(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    []string\n\t\tquery    string\n\t\texpected bool\n\t}{\n\t\t{[]string{\"WAT=\", \"PYTHONPATH=/usr/local\"}, \"WAT\", true},\n\t\t{[]string{\"PATH=/usr/bin:/bin\", \"PYTHONPATH=/usr/local\"}, \"PYTHONPATH\", true},\n\t\t{[]string{\"PATH=/usr/bin:/bin\", \"PYTHONPATH=/usr/local\"}, \"PYTHONPATHI\", false},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tenv := Env(test.input)\n\t\t\tgot := env.Exists(test.query)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"Env.Exists(%q): wrong result. Want %v. Got %v\", test.query, test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetBool(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"EMPTY_VAR\", false},\n\t\t{\"ZERO_VAR\", false},\n\t\t{\"NO_VAR\", false},\n\t\t{\"FALSE_VAR\", false},\n\t\t{\"NONE_VAR\", false},\n\t\t{\"TRUE_VAR\", true},\n\t\t{\"WAT\", true},\n\t\t{\"PATH\", true},\n\t\t{\"ONE_VAR\", true},\n\t\t{\"NO_VAR_TAB\", false},\n\t}\n\tenv := Env([]string{\n\t\t\"EMPTY_VAR=\", \"ZERO_VAR=0\", \"NO_VAR=no\", \"FALSE_VAR=false\",\n\t\t\"NONE_VAR=none\", \"TRUE_VAR=true\", \"WAT=wat\", \"PATH=/usr/bin:/bin\",\n\t\t\"ONE_VAR=1\", \"NO_VAR_TAB=0 \\t\\t\\t\",\n\t})\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tgot := env.GetBool(test.input)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"Env.GetBool(%q): wrong result. Want %v. Got %v.\", test.input, test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetBool(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    bool\n\t\texpected string\n\t}{\n\t\t{true, \"1\"},\n\t\t{false, \"0\"},\n\t}\n\tfor _, tt := range tests {\n\t\tvar env Env\n\t\tenv.SetBool(\"SOME\", tt.input)\n\t\tif got := env.Get(\"SOME\"); got != tt.expected {\n\t\t\tt.Errorf(\"Env.SetBool(%v): wrong result. Want %q. Got %q\", tt.input, tt.expected, got)\n\t\t}\n\t}\n}\n\nfunc TestGetInt(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    string\n\t\texpected int\n\t}{\n\t\t{\"NEGATIVE_INTEGER\", -10},\n\t\t{\"NON_INTEGER\", -1},\n\t\t{\"ONE\", 1},\n\t\t{\"TWO\", 2},\n\t}\n\tenv := Env([]string{\"NEGATIVE_INTEGER=-10\", \"NON_INTEGER=wat\", \"ONE=1\", \"TWO=2\"})\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tgot := env.GetInt(test.input)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"Env.GetInt(%q): wrong result. Want %d. Got %d\", test.input, test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetInt(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    int\n\t\texpected string\n\t}{\n\t\t{10, \"10\"},\n\t\t{13, \"13\"},\n\t\t{7, \"7\"},\n\t\t{33, \"33\"},\n\t\t{0, \"0\"},\n\t\t{-34, \"-34\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar env Env\n\t\t\tenv.SetInt(\"SOME\", test.input)\n\t\t\tif got := env.Get(\"SOME\"); got != test.expected {\n\t\t\t\tt.Errorf(\"Env.SetBool(%d): wrong result. Want %q. Got %q\", test.input, test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetInt64(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    string\n\t\texpected int64\n\t}{\n\t\t{\"NEGATIVE_INTEGER\", -10},\n\t\t{\"NON_INTEGER\", -1},\n\t\t{\"ONE\", 1},\n\t\t{\"TWO\", 2},\n\t}\n\tenv := Env([]string{\"NEGATIVE_INTEGER=-10\", \"NON_INTEGER=wat\", \"ONE=1\", \"TWO=2\"})\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tgot := env.GetInt64(test.input)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"Env.GetInt64(%q): wrong result. Want %d. Got %d\", test.input, test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetInt64(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    int64\n\t\texpected string\n\t}{\n\t\t{10, \"10\"},\n\t\t{13, \"13\"},\n\t\t{7, \"7\"},\n\t\t{33, \"33\"},\n\t\t{0, \"0\"},\n\t\t{-34, \"-34\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar env Env\n\t\t\tenv.SetInt64(\"SOME\", test.input)\n\t\t\tif got := env.Get(\"SOME\"); got != test.expected {\n\t\t\t\tt.Errorf(\"Env.SetBool(%d): wrong result. Want %q. Got %q\", test.input, test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetJSON(t *testing.T) {\n\tt.Parallel()\n\tvar p struct {\n\t\tName string `json:\"name\"`\n\t\tAge  int    `json:\"age\"`\n\t}\n\tvar env Env\n\tenv.Set(\"person\", `{\"name\":\"Gopher\",\"age\":5}`)\n\terr := env.GetJSON(\"person\", &p)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif p.Name != \"Gopher\" {\n\t\tt.Errorf(\"Env.GetJSON(%q): wrong name. Want %q. Got %q\", \"person\", \"Gopher\", p.Name)\n\t}\n\tif p.Age != 5 {\n\t\tt.Errorf(\"Env.GetJSON(%q): wrong age. Want %d. Got %d\", \"person\", 5, p.Age)\n\t}\n}\n\nfunc TestGetJSONAbsent(t *testing.T) {\n\tt.Parallel()\n\tvar l []string\n\tvar env Env\n\terr := env.GetJSON(\"person\", &l)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif l != nil {\n\t\tt.Errorf(\"Env.GetJSON(): get unexpected list %v\", l)\n\t}\n}\n\nfunc TestGetJSONFailure(t *testing.T) {\n\tt.Parallel()\n\tvar p []string\n\tvar env Env\n\tenv.Set(\"list-person\", `{\"name\":\"Gopher\",\"age\":5}`)\n\terr := env.GetJSON(\"list-person\", &p)\n\tif err == nil {\n\t\tt.Errorf(\"Env.GetJSON(%q): got unexpected <nil> error.\", \"list-person\")\n\t}\n}\n\nfunc TestSetJSON(t *testing.T) {\n\tt.Parallel()\n\tp1 := struct {\n\t\tName string `json:\"name\"`\n\t\tAge  int    `json:\"age\"`\n\t}{Name: \"Gopher\", Age: 5}\n\tvar env Env\n\terr := env.SetJSON(\"person\", p1)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tvar p2 struct {\n\t\tName string `json:\"name\"`\n\t\tAge  int    `json:\"age\"`\n\t}\n\terr = env.GetJSON(\"person\", &p2)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !reflect.DeepEqual(p1, p2) {\n\t\tt.Errorf(\"Env.SetJSON(%q): wrong result. Want %v. Got %v\", \"person\", p1, p2)\n\t}\n}\n\nfunc TestSetJSONFailure(t *testing.T) {\n\tt.Parallel()\n\tvar env Env\n\terr := env.SetJSON(\"person\", unmarshable{})\n\tif err == nil {\n\t\tt.Error(\"Env.SetJSON(): got unexpected <nil> error\")\n\t}\n\tif env.Exists(\"person\") {\n\t\tt.Errorf(\"Env.SetJSON(): should not define the key %q, but did\", \"person\")\n\t}\n}\n\nfunc TestGetList(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []string\n\t}{\n\t\t{\"WAT=wat\", []string{\"wat\"}},\n\t\t{`WAT=[\"wat\",\"wet\",\"wit\",\"wot\",\"wut\"]`, []string{\"wat\", \"wet\", \"wit\", \"wot\", \"wut\"}},\n\t\t{\"WAT=\", nil},\n\t}\n\tfor _, tt := range tests {\n\t\tenv := Env([]string{tt.input})\n\t\tgot := env.GetList(\"WAT\")\n\t\tif !reflect.DeepEqual(got, tt.expected) {\n\t\t\tt.Errorf(\"Env.GetList(%q): wrong result. Want %v. Got %v\", \"WAT\", tt.expected, got)\n\t\t}\n\t}\n}\n\nfunc TestSetList(t *testing.T) {\n\tt.Parallel()\n\tlist := []string{\"a\", \"b\", \"c\"}\n\tvar env Env\n\tif err := env.SetList(\"SOME\", list); err != nil {\n\t\tt.Error(err)\n\t}\n\tif got := env.GetList(\"SOME\"); !reflect.DeepEqual(got, list) {\n\t\tt.Errorf(\"Env.SetList(%v): wrong result. Got %v\", list, got)\n\t}\n}\n\nfunc TestSet(t *testing.T) {\n\tt.Parallel()\n\tvar env Env\n\tenv.Set(\"PATH\", \"/home/bin:/bin\")\n\tenv.Set(\"SOMETHING\", \"/usr/bin\")\n\tenv.Set(\"PATH\", \"/bin\")\n\tif expected, got := \"/usr/bin\", env.Get(\"SOMETHING\"); got != expected {\n\t\tt.Errorf(\"Env.Set(%q): wrong result. Want %q. Got %q\", expected, expected, got)\n\t}\n\tif expected, got := \"/bin\", env.Get(\"PATH\"); got != expected {\n\t\tt.Errorf(\"Env.Set(%q): wrong result. Want %q. Got %q\", expected, expected, got)\n\t}\n}\n\nfunc TestDecode(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedOut []string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\t`{\"PATH\":\"/usr/bin:/bin\",\"containers\":54,\"wat\":[\"123\",\"345\"]}`,\n\t\t\t[]string{\"PATH=/usr/bin:/bin\", \"containers=54\", `wat=[\"123\",\"345\"]`},\n\t\t\tfalse,\n\t\t},\n\t\t{\"}}\", nil, true},\n\t\t{`{}`, nil, false},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar env Env\n\t\t\terr := env.Decode(bytes.NewBufferString(test.input))\n\t\t\tif !test.expectedErr && err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t} else if test.expectedErr && err == nil {\n\t\t\t\tt.Error(\"Env.Decode(): unexpected <nil> error\")\n\t\t\t}\n\t\t\tgot := []string(env)\n\t\t\tslices.Sort(got)\n\t\t\tslices.Sort(test.expectedOut)\n\t\t\tif !reflect.DeepEqual(got, test.expectedOut) {\n\t\t\t\tt.Errorf(\"Env.Decode(): wrong result. Want %v. Got %v.\", test.expectedOut, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetAuto(t *testing.T) {\n\tt.Parallel()\n\tbuf := bytes.NewBufferString(\"oi\")\n\ttests := []struct {\n\t\tinput    any\n\t\texpected string\n\t}{\n\t\t{10, \"10\"},\n\t\t{10.3, \"10\"},\n\t\t{\"oi\", \"oi\"},\n\t\t{buf, \"{}\"},\n\t\t{unmarshable{}, \"{}\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar env Env\n\t\t\tenv.SetAuto(\"SOME\", test.input)\n\t\t\tif got := env.Get(\"SOME\"); got != test.expected {\n\t\t\t\tt.Errorf(\"Env.SetAuto(%v): wrong result. Want %q. Got %q\", test.input, test.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMap(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected map[string]string\n\t}{\n\t\t{[]string{\"PATH=/usr/bin:/bin\", \"PYTHONPATH=/usr/local\"}, map[string]string{\"PATH\": \"/usr/bin:/bin\", \"PYTHONPATH\": \"/usr/local\"}},\n\t\t{[]string{\"ENABLE_LOGGING\", \"PYTHONPATH=/usr/local\"}, map[string]string{\"ENABLE_LOGGING\": \"\", \"PYTHONPATH\": \"/usr/local\"}},\n\t\t{nil, nil},\n\t}\n\tfor _, tt := range tests {\n\t\tenv := Env(tt.input)\n\t\tgot := env.Map()\n\t\tif !reflect.DeepEqual(got, tt.expected) {\n\t\t\tt.Errorf(\"Env.Map(): wrong result. Want %v. Got %v\", tt.expected, got)\n\t\t}\n\t}\n}\n\ntype unmarshable struct{}\n\nfunc (unmarshable) MarshalJSON() ([]byte, error) {\n\treturn nil, errors.New(\"cannot marshal\")\n}\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 13.00390625,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// EventsOptions to filter events\n// See https://docs.docker.com/engine/api/v1.41/#operation/SystemEvents for more details.\ntype EventsOptions struct {\n\t// Show events created since this timestamp then stream new events.\n\tSince string\n\n\t// Show events created until this timestamp then stop streaming.\n\tUntil string\n\n\t// Filter for events. For example:\n\t//  map[string][]string{\"type\": {\"container\"}, \"event\": {\"start\", \"die\"}}\n\t// will return events when container was started and stopped or killed\n\t//\n\t// Available filters:\n\t//  config=<string> config name or ID\n\t//  container=<string> container name or ID\n\t//  daemon=<string> daemon name or ID\n\t//  event=<string> event type\n\t//  image=<string> image name or ID\n\t//  label=<string> image or container label\n\t//  network=<string> network name or ID\n\t//  node=<string> node ID\n\t//  plugin= plugin name or ID\n\t//  scope= local or swarm\n\t//  secret=<string> secret name or ID\n\t//  service=<string> service name or ID\n\t//  type=<string> container, image, volume, network, daemon, plugin, node, service, secret or config\n\t//  volume=<string> volume name\n\tFilters map[string][]string\n}\n\n// APIEvents represents events coming from the Docker API\n// The fields in the Docker API changed in API version 1.22, and\n// events for more than images and containers are now fired off.\n// To maintain forward and backward compatibility, go-dockerclient\n// replicates the event in both the new and old format as faithfully as possible.\n//\n// For events that only exist in 1.22 in later, `Status` is filled in as\n// `\"Type:Action\"` instead of just `Action` to allow for older clients to\n// differentiate and not break if they rely on the pre-1.22 Status types.\n//\n// The transformEvent method can be consulted for more information about how\n// events are translated from new/old API formats\ntype APIEvents struct {\n\t// New API Fields in 1.22\n\tAction string   `json:\"action,omitempty\"`\n\tType   string   `json:\"type,omitempty\"`\n\tActor  APIActor `json:\"actor,omitempty\"`\n\n\t// Old API fields for < 1.22\n\tStatus string `json:\"status,omitempty\"`\n\tID     string `json:\"id,omitempty\"`\n\tFrom   string `json:\"from,omitempty\"`\n\n\t// Fields in both\n\tTime     int64 `json:\"time,omitempty\"`\n\tTimeNano int64 `json:\"timeNano,omitempty\"`\n}\n\n// APIActor represents an actor that accomplishes something for an event\ntype APIActor struct {\n\tID         string            `json:\"id,omitempty\"`\n\tAttributes map[string]string `json:\"attributes,omitempty\"`\n}\n\ntype eventMonitoringState struct {\n\t// `sync/atomic` expects the first word in an allocated struct to be 64-bit\n\t// aligned on both ARM and x86-32. See https://goo.gl/zW7dgq for more details.\n\tlastSeen int64\n\tsync.RWMutex\n\tsync.WaitGroup\n\tenabled   bool\n\tC         chan *APIEvents\n\terrC      chan error\n\tlisteners []chan<- *APIEvents\n\tcloseConn func()\n}\n\nconst (\n\tmaxMonitorConnRetries = 5\n\tretryInitialWaitTime  = 10.\n)\n\nvar (\n\t// ErrNoListeners is the error returned when no listeners are available\n\t// to receive an event.\n\tErrNoListeners = errors.New(\"no listeners present to receive event\")\n\n\t// ErrListenerAlreadyExists is the error returned when the listerner already\n\t// exists.\n\tErrListenerAlreadyExists = errors.New(\"listener already exists for docker events\")\n\n\t// ErrTLSNotSupported is the error returned when the client does not support\n\t// TLS (this applies to the Windows named pipe client).\n\tErrTLSNotSupported = errors.New(\"tls not supported by this client\")\n\n\t// EOFEvent is sent when the event listener receives an EOF error.\n\tEOFEvent = &APIEvents{\n\t\tType:   \"EOF\",\n\t\tStatus: \"EOF\",\n\t}\n)\n\n// AddEventListener adds a new listener to container events in the Docker API.\n//\n// The parameter is a channel through which events will be sent.\nfunc (c *Client) AddEventListener(listener chan<- *APIEvents) error {\n\treturn c.AddEventListenerWithOptions(EventsOptions{}, listener)\n}\n\n// AddEventListener adds a new listener to container events in the Docker API.\n// See https://docs.docker.com/engine/api/v1.41/#operation/SystemEvents for more details.\n//\n// The listener parameter is a channel through which events will be sent.\nfunc (c *Client) AddEventListenerWithOptions(options EventsOptions, listener chan<- *APIEvents) error {\n\tvar err error\n\tif !c.eventMonitor.isEnabled() {\n\t\terr = c.eventMonitor.enableEventMonitoring(c, options)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn c.eventMonitor.addListener(listener)\n}\n\n// RemoveEventListener removes a listener from the monitor.\nfunc (c *Client) RemoveEventListener(listener chan *APIEvents) error {\n\terr := c.eventMonitor.removeListener(listener)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.eventMonitor.listernersCount() == 0 {\n\t\tc.eventMonitor.disableEventMonitoring()\n\t}\n\treturn nil\n}\n\nfunc (eventState *eventMonitoringState) addListener(listener chan<- *APIEvents) error {\n\teventState.Lock()\n\tdefer eventState.Unlock()\n\tif listenerExists(listener, &eventState.listeners) {\n\t\treturn ErrListenerAlreadyExists\n\t}\n\teventState.Add(1)\n\teventState.listeners = append(eventState.listeners, listener)\n\treturn nil\n}\n\nfunc (eventState *eventMonitoringState) removeListener(listener chan<- *APIEvents) error {\n\teventState.Lock()\n\tdefer eventState.Unlock()\n\tif listenerExists(listener, &eventState.listeners) {\n\t\tvar newListeners []chan<- *APIEvents\n\t\tfor _, l := range eventState.listeners {\n\t\t\tif l != listener {\n\t\t\t\tnewListeners = append(newListeners, l)\n\t\t\t}\n\t\t}\n\t\teventState.listeners = newListeners\n\t\teventState.Add(-1)\n\t}\n\treturn nil\n}\n\nfunc (eventState *eventMonitoringState) closeListeners() {\n\tfor _, l := range eventState.listeners {\n\t\tclose(l)\n\t\teventState.Add(-1)\n\t}\n\teventState.listeners = nil\n}\n\nfunc (eventState *eventMonitoringState) listernersCount() int {\n\teventState.RLock()\n\tdefer eventState.RUnlock()\n\treturn len(eventState.listeners)\n}\n\nfunc listenerExists(a chan<- *APIEvents, list *[]chan<- *APIEvents) bool {\n\tfor _, b := range *list {\n\t\tif b == a {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (eventState *eventMonitoringState) enableEventMonitoring(c *Client, opts EventsOptions) error {\n\teventState.Lock()\n\tdefer eventState.Unlock()\n\tif !eventState.enabled {\n\t\teventState.enabled = true\n\t\tatomic.StoreInt64(&eventState.lastSeen, 0)\n\t\teventState.C = make(chan *APIEvents, 100)\n\t\teventState.errC = make(chan error, 1)\n\t\tgo eventState.monitorEvents(c, opts)\n\t}\n\treturn nil\n}\n\nfunc (eventState *eventMonitoringState) disableEventMonitoring() {\n\teventState.Lock()\n\tdefer eventState.Unlock()\n\n\teventState.closeListeners()\n\n\teventState.Wait()\n\n\tif eventState.enabled {\n\t\teventState.enabled = false\n\t\tclose(eventState.C)\n\t\tclose(eventState.errC)\n\n\t\tif eventState.closeConn != nil {\n\t\t\teventState.closeConn()\n\t\t\teventState.closeConn = nil\n\t\t}\n\t}\n}\n\nfunc (eventState *eventMonitoringState) monitorEvents(c *Client, opts EventsOptions) {\n\tconst (\n\t\tnoListenersTimeout  = 5 * time.Second\n\t\tnoListenersInterval = 10 * time.Millisecond\n\t\tnoListenersMaxTries = noListenersTimeout / noListenersInterval\n\t)\n\n\tvar err error\n\tfor i := time.Duration(0); i < noListenersMaxTries && eventState.noListeners(); i++ {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\tif eventState.noListeners() {\n\t\t// terminate if no listener is available after 5 seconds.\n\t\t// Prevents goroutine leak when RemoveEventListener is called\n\t\t// right after AddEventListener.\n\t\teventState.disableEventMonitoring()\n\t\treturn\n\t}\n\n\tif err = eventState.connectWithRetry(c, opts); err != nil {\n\t\t// terminate if connect failed\n\t\teventState.disableEventMonitoring()\n\t\treturn\n\t}\n\tfor eventState.isEnabled() {\n\t\ttimeout := time.After(100 * time.Millisecond)\n\t\tselect {\n\t\tcase ev, ok := <-eventState.C:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif ev == EOFEvent {\n\t\t\t\teventState.disableEventMonitoring()\n\t\t\t\treturn\n\t\t\t}\n\t\t\teventState.updateLastSeen(ev)\n\t\t\teventState.sendEvent(ev)\n\t\tcase err = <-eventState.errC:\n\t\t\tif errors.Is(err, ErrNoListeners) {\n\t\t\t\teventState.disableEventMonitoring()\n\t\t\t\treturn\n\t\t\t} else if err != nil {\n\t\t\t\tdefer func() { go eventState.monitorEvents(c, opts) }()\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-timeout:\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc (eventState *eventMonitoringState) connectWithRetry(c *Client, opts EventsOptions) error {\n\tvar retries int\n\teventState.RLock()\n\teventChan := eventState.C\n\terrChan := eventState.errC\n\teventState.RUnlock()\n\tcloseConn, err := c.eventHijack(opts, atomic.LoadInt64(&eventState.lastSeen), eventChan, errChan)\n\tfor ; err != nil && retries < maxMonitorConnRetries; retries++ {\n\t\twaitTime := int64(retryInitialWaitTime * math.Pow(2, float64(retries)))\n\t\ttime.Sleep(time.Duration(waitTime) * time.Millisecond)\n\t\teventState.RLock()\n\t\teventChan = eventState.C\n\t\terrChan = eventState.errC\n\t\teventState.RUnlock()\n\t\tcloseConn, err = c.eventHijack(opts, atomic.LoadInt64(&eventState.lastSeen), eventChan, errChan)\n\t}\n\teventState.Lock()\n\tdefer eventState.Unlock()\n\teventState.closeConn = closeConn\n\treturn err\n}\n\nfunc (eventState *eventMonitoringState) noListeners() bool {\n\teventState.RLock()\n\tdefer eventState.RUnlock()\n\treturn len(eventState.listeners) == 0\n}\n\nfunc (eventState *eventMonitoringState) isEnabled() bool {\n\teventState.RLock()\n\tdefer eventState.RUnlock()\n\treturn eventState.enabled\n}\n\nfunc (eventState *eventMonitoringState) sendEvent(event *APIEvents) {\n\teventState.RLock()\n\tdefer eventState.RUnlock()\n\teventState.Add(1)\n\tdefer eventState.Done()\n\tif eventState.enabled {\n\t\tif len(eventState.listeners) == 0 {\n\t\t\teventState.errC <- ErrNoListeners\n\t\t\treturn\n\t\t}\n\n\t\tfor _, listener := range eventState.listeners {\n\t\t\tselect {\n\t\t\tcase listener <- event:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (eventState *eventMonitoringState) updateLastSeen(e *APIEvents) {\n\teventState.Lock()\n\tdefer eventState.Unlock()\n\tif atomic.LoadInt64(&eventState.lastSeen) < e.Time {\n\t\tatomic.StoreInt64(&eventState.lastSeen, e.Time)\n\t}\n}\n\nfunc (c *Client) eventHijack(opts EventsOptions, startTime int64, eventChan chan *APIEvents, errChan chan error) (closeConn func(), err error) {\n\t// on reconnect override initial Since with last event seen time\n\tif startTime != 0 {\n\t\topts.Since = strconv.FormatInt(startTime, 10)\n\t}\n\turi := \"/events?\" + queryString(opts)\n\tprotocol := c.endpointURL.Scheme\n\taddress := c.endpointURL.Path\n\tif protocol != \"unix\" && protocol != \"npipe\" {\n\t\tprotocol = \"tcp\"\n\t\taddress = c.endpointURL.Host\n\t}\n\tvar dial net.Conn\n\tif c.TLSConfig == nil {\n\t\tdial, err = c.Dialer.Dial(protocol, address)\n\t} else {\n\t\tnetDialer, ok := c.Dialer.(*net.Dialer)\n\t\tif !ok {\n\t\t\treturn nil, ErrTLSNotSupported\n\t\t}\n\t\tdial, err = tlsDialWithDialer(netDialer, protocol, address, c.TLSConfig)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t//lint:ignore SA1019 the alternative doesn't quite work, so keep using the deprecated thing.\n\tconn := httputil.NewClientConn(dial, nil)\n\treq, err := http.NewRequest(http.MethodGet, uri, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres, err := conn.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeepRunning := int32(1)\n\t//lint:ignore SA1019 the alternative doesn't quite work, so keep using the deprecated thing.\n\tgo func(res *http.Response, conn *httputil.ClientConn) {\n\t\tdefer conn.Close()\n\t\tdefer res.Body.Close()\n\t\tdecoder := json.NewDecoder(res.Body)\n\t\tfor atomic.LoadInt32(&keepRunning) == 1 {\n\t\t\tvar event APIEvents\n\t\t\tif err := decoder.Decode(&event); err != nil {\n\t\t\t\tif errors.Is(err, io.EOF) || errors.Is(err, io.ErrUnexpectedEOF) {\n\t\t\t\t\tc.eventMonitor.RLock()\n\t\t\t\t\tif c.eventMonitor.enabled && c.eventMonitor.C == eventChan {\n\t\t\t\t\t\t// Signal that we're exiting.\n\t\t\t\t\t\teventChan <- EOFEvent\n\t\t\t\t\t}\n\t\t\t\t\tc.eventMonitor.RUnlock()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\terrChan <- err\n\t\t\t}\n\t\t\tif event.Time == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttransformEvent(&event)\n\t\t\tc.eventMonitor.RLock()\n\t\t\tif c.eventMonitor.enabled && c.eventMonitor.C == eventChan {\n\t\t\t\teventChan <- &event\n\t\t\t}\n\t\t\tc.eventMonitor.RUnlock()\n\t\t}\n\t}(res, conn)\n\treturn func() {\n\t\tatomic.StoreInt32(&keepRunning, 0)\n\t}, nil\n}\n\n// transformEvent takes an event and determines what version it is from\n// then populates both versions of the event\nfunc transformEvent(event *APIEvents) {\n\t// if event version is <= 1.21 there will be no Action and no Type\n\tif event.Action == \"\" && event.Type == \"\" {\n\t\tevent.Action = event.Status\n\t\tevent.Actor.ID = event.ID\n\t\tevent.Actor.Attributes = map[string]string{}\n\t\tswitch event.Status {\n\t\tcase \"delete\", \"import\", \"pull\", \"push\", \"tag\", \"untag\":\n\t\t\tevent.Type = \"image\"\n\t\tdefault:\n\t\t\tevent.Type = \"container\"\n\t\t\tif event.From != \"\" {\n\t\t\t\tevent.Actor.Attributes[\"image\"] = event.From\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif event.Status == \"\" {\n\t\t\tif event.Type == \"image\" || event.Type == \"container\" {\n\t\t\t\tevent.Status = event.Action\n\t\t\t} else {\n\t\t\t\t// Because just the Status has been overloaded with different Types\n\t\t\t\t// if an event is not for an image or a container, we prepend the type\n\t\t\t\t// to avoid problems for people relying on actions being only for\n\t\t\t\t// images and containers\n\t\t\t\tevent.Status = event.Type + \":\" + event.Action\n\t\t\t}\n\t\t}\n\t\tif event.ID == \"\" {\n\t\t\tevent.ID = event.Actor.ID\n\t\t}\n\t\tif event.From == \"\" {\n\t\t\tevent.From = event.Actor.Attributes[\"image\"]\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "event_test.go",
          "type": "blob",
          "size": 8.234375,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"bufio\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestEventListeners(t *testing.T) {\n\tt.Parallel()\n\ttestEventListeners(\"TestEventListeners\", t, httptest.NewServer, NewClient)\n}\n\nfunc TestTLSEventListeners(t *testing.T) {\n\tt.Parallel()\n\ttestEventListeners(\"TestTLSEventListeners\", t, func(handler http.Handler) *httptest.Server {\n\t\tserver := httptest.NewUnstartedServer(handler)\n\n\t\tcert, err := tls.LoadX509KeyPair(\"testing/data/server.pem\", \"testing/data/serverkey.pem\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error loading server key pair: %s\", err)\n\t\t}\n\n\t\tcaCert, err := os.ReadFile(\"testing/data/ca.pem\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error loading ca certificate: %s\", err)\n\t\t}\n\t\tcaPool := x509.NewCertPool()\n\t\tif !caPool.AppendCertsFromPEM(caCert) {\n\t\t\tt.Fatalf(\"Could not add ca certificate\")\n\t\t}\n\n\t\tserver.TLS = &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tRootCAs:      caPool,\n\t\t}\n\t\tserver.StartTLS()\n\t\treturn server\n\t}, func(url string) (*Client, error) {\n\t\treturn NewTLSClient(url, \"testing/data/cert.pem\", \"testing/data/key.pem\", \"testing/data/ca.pem\")\n\t})\n}\n\nfunc testEventListeners(testName string, t *testing.T, buildServer func(http.Handler) *httptest.Server, buildClient func(string) (*Client, error)) {\n\tresponse := `{\"action\":\"pull\",\"type\":\"image\",\"actor\":{\"id\":\"busybox:latest\",\"attributes\":{}},\"time\":1442421700,\"timeNano\":1442421700598988358}\n{\"action\":\"create\",\"type\":\"container\",\"actor\":{\"id\":\"5745704abe9caa5\",\"attributes\":{\"image\":\"busybox\"}},\"time\":1442421716,\"timeNano\":1442421716853979870}\n{\"action\":\"attach\",\"type\":\"container\",\"actor\":{\"id\":\"5745704abe9caa5\",\"attributes\":{\"image\":\"busybox\"}},\"time\":1442421716,\"timeNano\":1442421716894759198}\n{\"action\":\"start\",\"type\":\"container\",\"actor\":{\"id\":\"5745704abe9caa5\",\"attributes\":{\"image\":\"busybox\"}},\"time\":1442421716,\"timeNano\":1442421716983607193}\n{\"status\":\"create\",\"id\":\"dfdf82bd3881\",\"from\":\"base:latest\",\"time\":1374067924}\n{\"status\":\"start\",\"id\":\"dfdf82bd3881\",\"from\":\"base:latest\",\"time\":1374067924}\n{\"status\":\"stop\",\"id\":\"dfdf82bd3881\",\"from\":\"base:latest\",\"time\":1374067966}\n{\"status\":\"destroy\",\"id\":\"dfdf82bd3881\",\"from\":\"base:latest\",\"time\":1374067970}\n{\"Action\":\"create\",\"Actor\":{\"Attributes\":{\"HAProxyMode\":\"http\",\"HealthCheck\":\"HttpGet\",\"HealthCheckArgs\":\"http://127.0.0.1:39051/status/check\",\"ServicePort_8080\":\"17801\",\"image\":\"datanerd.us/siteeng/sample-app-go:latest\",\"name\":\"sample-app-client-go-69818c1223ddb5\"},\"ID\":\"a925eaf4084d5c3bcf337b2abb05f566ebb94276dff34f6effb00d8ecd380e16\"},\"Type\":\"container\",\"from\":\"datanerd.us/siteeng/sample-app-go:latest\",\"id\":\"a925eaf4084d5c3bcf337b2abb05f566ebb94276dff34f6effb00d8ecd380e16\",\"status\":\"create\",\"time\":1459133932,\"timeNano\":1459133932961735842}`\n\n\tserver := buildServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\trsc := bufio.NewScanner(strings.NewReader(response))\n\t\tfor rsc.Scan() {\n\t\t\tw.Write(rsc.Bytes())\n\t\t\tw.(http.Flusher).Flush()\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}))\n\tdefer server.Close()\n\n\twantedEvents := []APIEvents{\n\t\t{\n\t\t\tAction: \"pull\",\n\t\t\tType:   \"image\",\n\t\t\tActor: APIActor{\n\t\t\t\tID:         \"busybox:latest\",\n\t\t\t\tAttributes: map[string]string{},\n\t\t\t},\n\n\t\t\tStatus: \"pull\",\n\t\t\tID:     \"busybox:latest\",\n\n\t\t\tTime:     1442421700,\n\t\t\tTimeNano: 1442421700598988358,\n\t\t},\n\t\t{\n\t\t\tAction: \"create\",\n\t\t\tType:   \"container\",\n\t\t\tActor: APIActor{\n\t\t\t\tID: \"5745704abe9caa5\",\n\t\t\t\tAttributes: map[string]string{\n\t\t\t\t\t\"image\": \"busybox\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tStatus: \"create\",\n\t\t\tID:     \"5745704abe9caa5\",\n\t\t\tFrom:   \"busybox\",\n\n\t\t\tTime:     1442421716,\n\t\t\tTimeNano: 1442421716853979870,\n\t\t},\n\t\t{\n\t\t\tAction: \"attach\",\n\t\t\tType:   \"container\",\n\t\t\tActor: APIActor{\n\t\t\t\tID: \"5745704abe9caa5\",\n\t\t\t\tAttributes: map[string]string{\n\t\t\t\t\t\"image\": \"busybox\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tStatus: \"attach\",\n\t\t\tID:     \"5745704abe9caa5\",\n\t\t\tFrom:   \"busybox\",\n\n\t\t\tTime:     1442421716,\n\t\t\tTimeNano: 1442421716894759198,\n\t\t},\n\t\t{\n\t\t\tAction: \"start\",\n\t\t\tType:   \"container\",\n\t\t\tActor: APIActor{\n\t\t\t\tID: \"5745704abe9caa5\",\n\t\t\t\tAttributes: map[string]string{\n\t\t\t\t\t\"image\": \"busybox\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tStatus: \"start\",\n\t\t\tID:     \"5745704abe9caa5\",\n\t\t\tFrom:   \"busybox\",\n\n\t\t\tTime:     1442421716,\n\t\t\tTimeNano: 1442421716983607193,\n\t\t},\n\n\t\t{\n\t\t\tAction: \"create\",\n\t\t\tType:   \"container\",\n\t\t\tActor: APIActor{\n\t\t\t\tID: \"dfdf82bd3881\",\n\t\t\t\tAttributes: map[string]string{\n\t\t\t\t\t\"image\": \"base:latest\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tStatus: \"create\",\n\t\t\tID:     \"dfdf82bd3881\",\n\t\t\tFrom:   \"base:latest\",\n\n\t\t\tTime: 1374067924,\n\t\t},\n\t\t{\n\t\t\tAction: \"start\",\n\t\t\tType:   \"container\",\n\t\t\tActor: APIActor{\n\t\t\t\tID: \"dfdf82bd3881\",\n\t\t\t\tAttributes: map[string]string{\n\t\t\t\t\t\"image\": \"base:latest\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tStatus: \"start\",\n\t\t\tID:     \"dfdf82bd3881\",\n\t\t\tFrom:   \"base:latest\",\n\n\t\t\tTime: 1374067924,\n\t\t},\n\t\t{\n\t\t\tAction: \"stop\",\n\t\t\tType:   \"container\",\n\t\t\tActor: APIActor{\n\t\t\t\tID: \"dfdf82bd3881\",\n\t\t\t\tAttributes: map[string]string{\n\t\t\t\t\t\"image\": \"base:latest\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tStatus: \"stop\",\n\t\t\tID:     \"dfdf82bd3881\",\n\t\t\tFrom:   \"base:latest\",\n\n\t\t\tTime: 1374067966,\n\t\t},\n\t\t{\n\t\t\tAction: \"destroy\",\n\t\t\tType:   \"container\",\n\t\t\tActor: APIActor{\n\t\t\t\tID: \"dfdf82bd3881\",\n\t\t\t\tAttributes: map[string]string{\n\t\t\t\t\t\"image\": \"base:latest\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tStatus: \"destroy\",\n\t\t\tID:     \"dfdf82bd3881\",\n\t\t\tFrom:   \"base:latest\",\n\n\t\t\tTime: 1374067970,\n\t\t},\n\t\t{\n\t\t\tAction:   \"create\",\n\t\t\tType:     \"container\",\n\t\t\tStatus:   \"create\",\n\t\t\tFrom:     \"datanerd.us/siteeng/sample-app-go:latest\",\n\t\t\tID:       \"a925eaf4084d5c3bcf337b2abb05f566ebb94276dff34f6effb00d8ecd380e16\",\n\t\t\tTime:     1459133932,\n\t\t\tTimeNano: 1459133932961735842,\n\t\t\tActor: APIActor{\n\t\t\t\tID: \"a925eaf4084d5c3bcf337b2abb05f566ebb94276dff34f6effb00d8ecd380e16\",\n\t\t\t\tAttributes: map[string]string{\n\t\t\t\t\t\"HAProxyMode\":      \"http\",\n\t\t\t\t\t\"HealthCheck\":      \"HttpGet\",\n\t\t\t\t\t\"HealthCheckArgs\":  \"http://127.0.0.1:39051/status/check\",\n\t\t\t\t\t\"ServicePort_8080\": \"17801\",\n\t\t\t\t\t\"image\":            \"datanerd.us/siteeng/sample-app-go:latest\",\n\t\t\t\t\t\"name\":             \"sample-app-client-go-69818c1223ddb5\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tclient, err := buildClient(server.URL)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to create client: %s\", err)\n\t}\n\tclient.SkipServerVersionCheck = true\n\n\tlistener := make(chan *APIEvents, len(wantedEvents)+1)\n\tdefer func() {\n\t\tif err = client.RemoveEventListener(listener); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\tfilters := map[string][]string{\n\t\t\"type\":  {\"container\"},\n\t\t\"event\": {\"create\", \"destroy\", \"start\", \"stop\", \"pull\", \"attach\"},\n\t}\n\topts := EventsOptions{Since: \"1374067970\", Until: \"1442421700\", Filters: filters}\n\terr = client.AddEventListenerWithOptions(opts, listener)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to add event listener: %s\", err)\n\t}\n\n\ttimeout := time.After(5 * time.Second)\n\tevents := make([]APIEvents, 0, len(wantedEvents))\n\nloop:\n\tfor i := range wantedEvents {\n\t\tselect {\n\t\tcase msg, ok := <-listener:\n\t\t\tif !ok {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tevents = append(events, *msg)\n\t\tcase <-timeout:\n\t\t\tt.Fatalf(\"%s: timed out waiting on events after %d events\", testName, i)\n\t\t}\n\t}\n\tcmpr := cmp.Comparer(func(e1, e2 APIEvents) bool {\n\t\treturn e1.Action == e2.Action && e1.Actor.ID == e2.Actor.ID\n\t})\n\tif dff := cmp.Diff(events, wantedEvents, cmpr); dff != \"\" {\n\t\tt.Errorf(\"wrong events:\\n%s\", dff)\n\t}\n}\n\nfunc TestEventListenerReAdding(t *testing.T) {\n\tt.Parallel()\n\tendChan := make(chan bool)\n\tserver := httptest.NewServer(http.HandlerFunc(func(http.ResponseWriter, *http.Request) {\n\t\t<-endChan\n\t}))\n\n\tclient, err := NewClient(server.URL)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to create client: %s\", err)\n\t}\n\n\tlistener := make(chan *APIEvents, 10)\n\tif err := client.AddEventListener(listener); err != nil {\n\t\tt.Errorf(\"Failed to add event listener: %s\", err)\n\t}\n\n\t// Make sure eventHijack() is started with the current eventMonitoringState.\n\ttime.Sleep(10 * time.Millisecond)\n\n\tif err := client.RemoveEventListener(listener); err != nil {\n\t\tt.Errorf(\"Failed to remove event listener: %s\", err)\n\t}\n\n\tif err := client.AddEventListener(listener); err != nil {\n\t\tt.Errorf(\"Failed to add event listener: %s\", err)\n\t}\n\n\tendChan <- true\n\n\t// Give the goroutine of the first eventHijack() time to handle the EOF.\n\ttime.Sleep(10 * time.Millisecond)\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 2.6669921875,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker_test\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\tdocker \"github.com/fsouza/go-dockerclient\"\n)\n\nfunc ExampleClient_AttachToContainer() {\n\tclient, err := docker.NewClient(\"http://localhost:4243\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient.SkipServerVersionCheck = true\n\t// Reading logs from container a84849 and sending them to buf.\n\tvar buf bytes.Buffer\n\terr = client.AttachToContainer(docker.AttachToContainerOptions{\n\t\tContainer:    \"a84849\",\n\t\tOutputStream: &buf,\n\t\tLogs:         true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Println(buf.String())\n\tbuf.Reset()\n\terr = client.AttachToContainer(docker.AttachToContainerOptions{\n\t\tContainer:    \"a84849\",\n\t\tOutputStream: &buf,\n\t\tStdout:       true,\n\t\tStream:       true,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Println(buf.String())\n}\n\nfunc ExampleClient_BuildImage() {\n\tclient, err := docker.NewClient(\"http://localhost:4243\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tt := time.Now()\n\tinputbuf, outputbuf := bytes.NewBuffer(nil), bytes.NewBuffer(nil)\n\ttr := tar.NewWriter(inputbuf)\n\ttr.WriteHeader(&tar.Header{Name: \"Dockerfile\", Size: 10, ModTime: t, AccessTime: t, ChangeTime: t})\n\ttr.Write([]byte(\"FROM base\\n\"))\n\ttr.Close()\n\topts := docker.BuildImageOptions{\n\t\tName:         \"test\",\n\t\tInputStream:  inputbuf,\n\t\tOutputStream: outputbuf,\n\t}\n\tif err := client.BuildImage(opts); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc ExampleClient_AddEventListener() {\n\tclient, err := docker.NewClient(\"http://localhost:4243\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlistener := make(chan *docker.APIEvents)\n\terr = client.AddEventListener(listener)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdefer func() {\n\t\terr = client.RemoveEventListener(listener)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\ttimeout := time.After(1 * time.Second)\n\n\tfor {\n\t\tselect {\n\t\tcase msg := <-listener:\n\t\t\tlog.Println(msg)\n\t\tcase <-timeout:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc ExampleEnv_Map() {\n\te := docker.Env([]string{\"A=1\", \"B=2\", \"C=3\"})\n\tenvs := e.Map()\n\tfor k, v := range envs {\n\t\tfmt.Printf(\"%s=%q\\n\", k, v)\n\t}\n}\n\nfunc ExampleEnv_SetJSON() {\n\ttype Person struct {\n\t\tName string\n\t\tAge  int\n\t}\n\tp := Person{Name: \"Gopher\", Age: 4}\n\tvar e docker.Env\n\terr := e.SetJSON(\"person\", p)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc ExampleEnv_GetJSON() {\n\ttype Person struct {\n\t\tName string\n\t\tAge  int\n\t}\n\tp := Person{Name: \"Gopher\", Age: 4}\n\tvar e docker.Env\n\te.Set(\"person\", `{\"name\":\"Gopher\",\"age\":4}`)\n\terr := e.GetJSON(\"person\", &p)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "exec.go",
          "type": "blob",
          "size": 8.5107421875,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\n// Exec is the type representing a `docker exec` instance and containing the\n// instance ID\ntype Exec struct {\n\tID string `json:\"Id,omitempty\" yaml:\"Id,omitempty\"`\n}\n\n// CreateExecOptions specify parameters to the CreateExecContainer function.\n//\n// See https://goo.gl/60TeBP for more details\ntype CreateExecOptions struct {\n\tEnv          []string        `json:\"Env,omitempty\" yaml:\"Env,omitempty\" toml:\"Env,omitempty\"`\n\tCmd          []string        `json:\"Cmd,omitempty\" yaml:\"Cmd,omitempty\" toml:\"Cmd,omitempty\"`\n\tContainer    string          `json:\"Container,omitempty\" yaml:\"Container,omitempty\" toml:\"Container,omitempty\"`\n\tUser         string          `json:\"User,omitempty\" yaml:\"User,omitempty\" toml:\"User,omitempty\"`\n\tWorkingDir   string          `json:\"WorkingDir,omitempty\" yaml:\"WorkingDir,omitempty\" toml:\"WorkingDir,omitempty\"`\n\tDetachKeys   string          `json:\"DetachKeys,omitempty\" yaml:\"DetachKeys,omitempty\" toml:\"DetachKeys,omitempty\"`\n\tContext      context.Context `json:\"-\"`\n\tAttachStdin  bool            `json:\"AttachStdin,omitempty\" yaml:\"AttachStdin,omitempty\" toml:\"AttachStdin,omitempty\"`\n\tAttachStdout bool            `json:\"AttachStdout,omitempty\" yaml:\"AttachStdout,omitempty\" toml:\"AttachStdout,omitempty\"`\n\tAttachStderr bool            `json:\"AttachStderr,omitempty\" yaml:\"AttachStderr,omitempty\" toml:\"AttachStderr,omitempty\"`\n\tTty          bool            `json:\"Tty,omitempty\" yaml:\"Tty,omitempty\" toml:\"Tty,omitempty\"`\n\tPrivileged   bool            `json:\"Privileged,omitempty\" yaml:\"Privileged,omitempty\" toml:\"Privileged,omitempty\"`\n}\n\n// CreateExec sets up an exec instance in a running container `id`, returning the exec\n// instance, or an error in case of failure.\n//\n// See https://goo.gl/60TeBP for more details\nfunc (c *Client) CreateExec(opts CreateExecOptions) (*Exec, error) {\n\tif c.serverAPIVersion == nil {\n\t\tc.checkAPIVersion()\n\t}\n\tif len(opts.Env) > 0 && c.serverAPIVersion.LessThan(apiVersion125) {\n\t\treturn nil, errors.New(\"exec configuration Env is only supported in API#1.25 and above\")\n\t}\n\tif len(opts.WorkingDir) > 0 && c.serverAPIVersion.LessThan(apiVersion135) {\n\t\treturn nil, errors.New(\"exec configuration WorkingDir is only supported in API#1.35 and above\")\n\t}\n\tpath := fmt.Sprintf(\"/containers/%s/exec\", opts.Container)\n\tresp, err := c.do(http.MethodPost, path, doOptions{data: opts, context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchContainer{ID: opts.Container}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar exec Exec\n\tif err := json.NewDecoder(resp.Body).Decode(&exec); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &exec, nil\n}\n\n// StartExecOptions specify parameters to the StartExecContainer function.\n//\n// See https://goo.gl/1EeDWi for more details\ntype StartExecOptions struct {\n\tInputStream  io.Reader `qs:\"-\"`\n\tOutputStream io.Writer `qs:\"-\"`\n\tErrorStream  io.Writer `qs:\"-\"`\n\n\tDetach bool `json:\"Detach,omitempty\" yaml:\"Detach,omitempty\" toml:\"Detach,omitempty\"`\n\tTty    bool `json:\"Tty,omitempty\" yaml:\"Tty,omitempty\" toml:\"Tty,omitempty\"`\n\n\t// Use raw terminal? Usually true when the container contains a TTY.\n\tRawTerminal bool `qs:\"-\"`\n\n\t// If set, after a successful connect, a sentinel will be sent and then the\n\t// client will block on receive before continuing.\n\t//\n\t// It must be an unbuffered channel. Using a buffered channel can lead\n\t// to unexpected behavior.\n\tSuccess chan struct{} `json:\"-\"`\n\n\tContext context.Context `json:\"-\"`\n}\n\n// StartExec starts a previously set up exec instance id. If opts.Detach is\n// true, it returns after starting the exec command. Otherwise, it sets up an\n// interactive session with the exec command.\n//\n// See https://goo.gl/1EeDWi for more details\nfunc (c *Client) StartExec(id string, opts StartExecOptions) error {\n\tcw, err := c.StartExecNonBlocking(id, opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cw != nil {\n\t\treturn cw.Wait()\n\t}\n\treturn nil\n}\n\n// StartExecNonBlocking starts a previously set up exec instance id. If opts.Detach is\n// true, it returns after starting the exec command. Otherwise, it sets up an\n// interactive session with the exec command.\n//\n// See https://goo.gl/1EeDWi for more details\nfunc (c *Client) StartExecNonBlocking(id string, opts StartExecOptions) (CloseWaiter, error) {\n\tif id == \"\" {\n\t\treturn nil, &NoSuchExec{ID: id}\n\t}\n\n\tpath := fmt.Sprintf(\"/exec/%s/start\", id)\n\n\tif opts.Detach {\n\t\tresp, err := c.do(http.MethodPost, path, doOptions{data: opts, context: opts.Context})\n\t\tif err != nil {\n\t\t\tvar e *Error\n\t\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\t\treturn nil, &NoSuchExec{ID: id}\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\treturn nil, nil\n\t}\n\n\treturn c.hijack(http.MethodPost, path, hijackOptions{\n\t\tsuccess:        opts.Success,\n\t\tsetRawTerminal: opts.RawTerminal,\n\t\tin:             opts.InputStream,\n\t\tstdout:         opts.OutputStream,\n\t\tstderr:         opts.ErrorStream,\n\t\tdata:           opts,\n\t})\n}\n\n// ResizeExecTTY resizes the tty session used by the exec command id. This API\n// is valid only if Tty was specified as part of creating and starting the exec\n// command.\n//\n// See https://goo.gl/Mo5bxx for more details\nfunc (c *Client) ResizeExecTTY(id string, height, width int) error {\n\tparams := make(url.Values)\n\tparams.Set(\"h\", strconv.Itoa(height))\n\tparams.Set(\"w\", strconv.Itoa(width))\n\n\tpath := fmt.Sprintf(\"/exec/%s/resize?%s\", id, params.Encode())\n\tresp, err := c.do(http.MethodPost, path, doOptions{})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// ExecProcessConfig is a type describing the command associated to a Exec\n// instance. It's used in the ExecInspect type.\ntype ExecProcessConfig struct {\n\tUser       string   `json:\"user,omitempty\" yaml:\"user,omitempty\" toml:\"user,omitempty\"`\n\tPrivileged bool     `json:\"privileged,omitempty\" yaml:\"privileged,omitempty\" toml:\"privileged,omitempty\"`\n\tTty        bool     `json:\"tty,omitempty\" yaml:\"tty,omitempty\" toml:\"tty,omitempty\"`\n\tEntryPoint string   `json:\"entrypoint,omitempty\" yaml:\"entrypoint,omitempty\" toml:\"entrypoint,omitempty\"`\n\tArguments  []string `json:\"arguments,omitempty\" yaml:\"arguments,omitempty\" toml:\"arguments,omitempty\"`\n}\n\n// ExecInspect is a type with details about a exec instance, including the\n// exit code if the command has finished running. It's returned by a api\n// call to /exec/(id)/json\n//\n// See https://goo.gl/ctMUiW for more details\ntype ExecInspect struct {\n\tID            string            `json:\"ID,omitempty\" yaml:\"ID,omitempty\" toml:\"ID,omitempty\"`\n\tExitCode      int               `json:\"ExitCode,omitempty\" yaml:\"ExitCode,omitempty\" toml:\"ExitCode,omitempty\"`\n\tProcessConfig ExecProcessConfig `json:\"ProcessConfig,omitempty\" yaml:\"ProcessConfig,omitempty\" toml:\"ProcessConfig,omitempty\"`\n\tContainerID   string            `json:\"ContainerID,omitempty\" yaml:\"ContainerID,omitempty\" toml:\"ContainerID,omitempty\"`\n\tDetachKeys    string            `json:\"DetachKeys,omitempty\" yaml:\"DetachKeys,omitempty\" toml:\"DetachKeys,omitempty\"`\n\tRunning       bool              `json:\"Running,omitempty\" yaml:\"Running,omitempty\" toml:\"Running,omitempty\"`\n\tOpenStdin     bool              `json:\"OpenStdin,omitempty\" yaml:\"OpenStdin,omitempty\" toml:\"OpenStdin,omitempty\"`\n\tOpenStderr    bool              `json:\"OpenStderr,omitempty\" yaml:\"OpenStderr,omitempty\" toml:\"OpenStderr,omitempty\"`\n\tOpenStdout    bool              `json:\"OpenStdout,omitempty\" yaml:\"OpenStdout,omitempty\" toml:\"OpenStdout,omitempty\"`\n\tCanRemove     bool              `json:\"CanRemove,omitempty\" yaml:\"CanRemove,omitempty\" toml:\"CanRemove,omitempty\"`\n}\n\n// InspectExec returns low-level information about the exec command id.\n//\n// See https://goo.gl/ctMUiW for more details\nfunc (c *Client) InspectExec(id string) (*ExecInspect, error) {\n\tpath := fmt.Sprintf(\"/exec/%s/json\", id)\n\tresp, err := c.do(http.MethodGet, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchExec{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar exec ExecInspect\n\tif err := json.NewDecoder(resp.Body).Decode(&exec); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &exec, nil\n}\n\n// NoSuchExec is the error returned when a given exec instance does not exist.\ntype NoSuchExec struct {\n\tID string\n}\n\nfunc (err *NoSuchExec) Error() string {\n\treturn \"No such exec instance: \" + err.ID\n}\n"
        },
        {
          "name": "exec_test.go",
          "type": "blob",
          "size": 9.2236328125,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestExecCreate(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"}`\n\tvar expected struct{ ID string }\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tconfig := CreateExecOptions{\n\t\tContainer:    \"test\",\n\t\tAttachStdin:  true,\n\t\tAttachStdout: true,\n\t\tAttachStderr: false,\n\t\tTty:          false,\n\t\tCmd:          []string{\"touch\", \"/tmp/file\"},\n\t\tUser:         \"a-user\",\n\t}\n\texecObj, err := client.CreateExec(config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpectedID := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tif execObj.ID != expectedID {\n\t\tt.Errorf(\"ExecCreate: wrong ID. Want %q. Got %q.\", expectedID, execObj.ID)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"ExecCreate: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/containers/test/exec\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"ExecCreate: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\tvar gotBody struct{ ID string }\n\terr = json.NewDecoder(req.Body).Decode(&gotBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestExecCreateWithEnvErr(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"}`\n\tvar expected struct{ ID string }\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tconfig := CreateExecOptions{\n\t\tContainer:    \"test\",\n\t\tAttachStdin:  true,\n\t\tAttachStdout: true,\n\t\tAttachStderr: false,\n\t\tTty:          false,\n\t\tEnv:          []string{\"foo=bar\"},\n\t\tCmd:          []string{\"touch\", \"/tmp/file\"},\n\t\tUser:         \"a-user\",\n\t}\n\t_, err = client.CreateExec(config)\n\tif err == nil || err.Error() != \"exec configuration Env is only supported in API#1.25 and above\" {\n\t\tt.Error(\"CreateExec: options contain Env for unsupported api version\")\n\t}\n}\n\nfunc TestExecCreateWithEnv(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"}`\n\tvar expected struct{ ID string }\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tendpoint := \"http://localhost:4243\"\n\tu, _ := parseEndpoint(\"http://localhost:4243\", false)\n\ttestAPIVersion, _ := NewAPIVersion(\"1.25\")\n\tclient := Client{\n\t\tHTTPClient:             &http.Client{Transport: fakeRT},\n\t\tDialer:                 &net.Dialer{},\n\t\tendpoint:               endpoint,\n\t\tendpointURL:            u,\n\t\tSkipServerVersionCheck: true,\n\t\tserverAPIVersion:       testAPIVersion,\n\t}\n\tconfig := CreateExecOptions{\n\t\tContainer:    \"test\",\n\t\tAttachStdin:  true,\n\t\tAttachStdout: true,\n\t\tAttachStderr: false,\n\t\tTty:          false,\n\t\tEnv:          []string{\"foo=bar\"},\n\t\tCmd:          []string{\"touch\", \"/tmp/file\"},\n\t\tUser:         \"a-user\",\n\t}\n\t_, err = client.CreateExec(config)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestExecCreateWithWorkingDirErr(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"}`\n\tvar expected struct{ ID string }\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tconfig := CreateExecOptions{\n\t\tContainer:    \"test\",\n\t\tAttachStdin:  true,\n\t\tAttachStdout: true,\n\t\tAttachStderr: false,\n\t\tTty:          false,\n\t\tWorkingDir:   \"/tmp\",\n\t\tCmd:          []string{\"touch\", \"file\"},\n\t\tUser:         \"a-user\",\n\t}\n\t_, err = client.CreateExec(config)\n\tif err == nil || err.Error() != \"exec configuration WorkingDir is only supported in API#1.35 and above\" {\n\t\tt.Error(\"CreateExec: options contain WorkingDir for unsupported api version\")\n\t}\n}\n\nfunc TestExecCreateWithWorkingDir(t *testing.T) {\n\tt.Parallel()\n\tjsonContainer := `{\"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"}`\n\tvar expected struct{ ID string }\n\terr := json.Unmarshal([]byte(jsonContainer), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonContainer, status: http.StatusOK}\n\tendpoint := \"http://localhost:4243\"\n\tu, _ := parseEndpoint(\"http://localhost:4243\", false)\n\ttestAPIVersion, _ := NewAPIVersion(\"1.35\")\n\tclient := Client{\n\t\tHTTPClient:             &http.Client{Transport: fakeRT},\n\t\tDialer:                 &net.Dialer{},\n\t\tendpoint:               endpoint,\n\t\tendpointURL:            u,\n\t\tSkipServerVersionCheck: true,\n\t\tserverAPIVersion:       testAPIVersion,\n\t}\n\tconfig := CreateExecOptions{\n\t\tContainer:    \"test\",\n\t\tAttachStdin:  true,\n\t\tAttachStdout: true,\n\t\tAttachStderr: false,\n\t\tTty:          false,\n\t\tWorkingDir:   \"/tmp\",\n\t\tCmd:          []string{\"touch\", \"file\"},\n\t\tUser:         \"a-user\",\n\t}\n\t_, err = client.CreateExec(config)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestExecStartDetached(t *testing.T) {\n\tt.Parallel()\n\texecID := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tfakeRT := &FakeRoundTripper{status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tconfig := StartExecOptions{\n\t\tDetach: true,\n\t}\n\terr := client.StartExec(execID, config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"ExecStart: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/exec/\" + execID + \"/start\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"ExecCreate: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\tt.Log(req.Body)\n\tvar gotBody struct{ Detach bool }\n\terr = json.NewDecoder(req.Body).Decode(&gotBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !gotBody.Detach {\n\t\tt.Fatal(\"Expected Detach in StartExecOptions to be true\")\n\t}\n}\n\nfunc TestExecStartAndAttach(t *testing.T) {\n\treader := strings.NewReader(\"send value\")\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte{1, 0, 0, 0, 0, 0, 0, 5})\n\t\tw.Write([]byte(\"hello\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar stdout, stderr bytes.Buffer\n\tsuccess := make(chan struct{})\n\texecID := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\topts := StartExecOptions{\n\t\tOutputStream: &stdout,\n\t\tErrorStream:  &stderr,\n\t\tInputStream:  reader,\n\t\tRawTerminal:  true,\n\t\tSuccess:      success,\n\t}\n\tgo func() {\n\t\tif err := client.StartExec(execID, opts); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\t<-success\n}\n\nfunc TestExecResize(t *testing.T) {\n\tt.Parallel()\n\texecID := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tfakeRT := &FakeRoundTripper{status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\terr := client.ResizeExecTTY(execID, 10, 20)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"ExecStart: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/exec/\" + execID + \"/resize?h=10&w=20\"))\n\tif gotPath := req.URL.RequestURI(); gotPath != expectedURL.RequestURI() {\n\t\tt.Errorf(\"ExecCreate: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestExecInspect(t *testing.T) {\n\tt.Parallel()\n\tjsonExec := `{\n\t  \"CanRemove\": false,\n\t  \"ContainerID\": \"b53ee82b53a40c7dca428523e34f741f3abc51d9f297a14ff874bf761b995126\",\n\t  \"DetachKeys\": \"\",\n\t  \"ExitCode\": 2,\n\t  \"ID\": \"f33bbfb39f5b142420f4759b2348913bd4a8d1a6d7fd56499cb41a1bb91d7b3b\",\n\t  \"OpenStderr\": true,\n\t  \"OpenStdin\": true,\n\t  \"OpenStdout\": true,\n\t  \"ProcessConfig\": {\n\t    \"arguments\": [\n\t      \"-c\",\n\t      \"exit 2\"\n\t    ],\n\t    \"entrypoint\": \"sh\",\n\t    \"privileged\": false,\n\t    \"tty\": true,\n\t    \"user\": \"1000\"\n\t  },\n\t  \"Running\": false\n\t}`\n\tvar expected ExecInspect\n\terr := json.Unmarshal([]byte(jsonExec), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonExec, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\texpectedID := \"b53ee82b53a40c7dca428523e34f741f3abc51d9f297a14ff874bf761b995126\"\n\texecObj, err := client.InspectExec(expectedID)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*execObj, expected) {\n\t\tt.Errorf(\"ExecInspect: Expected %#v. Got %#v.\", expected, *execObj)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"ExecInspect: wrong HTTP method. Want %q. Got %q.\", http.MethodGet, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/exec/\" + expectedID + \"/json\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"ExecInspect: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.3193359375,
          "content": "module github.com/fsouza/go-dockerclient\n\ngo 1.22\n\nrequire (\n\tgithub.com/Microsoft/go-winio v0.6.2\n\tgithub.com/docker/docker v27.4.1+incompatible\n\tgithub.com/docker/go-units v0.5.0\n\tgithub.com/google/go-cmp v0.6.0\n\tgithub.com/gorilla/mux v1.8.1\n\tgithub.com/moby/patternmatcher v0.6.0\n\tgolang.org/x/term v0.28.0\n)\n\nrequire (\n\tgithub.com/AdaLogics/go-fuzz-headers v0.0.0-20210715213245-6c3934b029d8 // indirect\n\tgithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect\n\tgithub.com/containerd/log v0.1.0 // indirect\n\tgithub.com/docker/go-connections v0.4.0 // indirect\n\tgithub.com/gogo/protobuf v1.3.2 // indirect\n\tgithub.com/klauspost/compress v1.15.9 // indirect\n\tgithub.com/moby/docker-image-spec v1.3.1 // indirect\n\tgithub.com/moby/sys/sequential v0.5.0 // indirect\n\tgithub.com/moby/sys/user v0.1.0 // indirect\n\tgithub.com/moby/sys/userns v0.1.0 // indirect\n\tgithub.com/moby/term v0.0.0-20210619224110-3f7ff695adc6 // indirect\n\tgithub.com/morikuni/aec v1.0.0 // indirect\n\tgithub.com/opencontainers/go-digest v1.0.0 // indirect\n\tgithub.com/opencontainers/image-spec v1.1.0-rc2.0.20221005185240-3a7f492d3f1b // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/sirupsen/logrus v1.9.3 // indirect\n\tgithub.com/stretchr/testify v1.8.4 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgotest.tools/v3 v3.5.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 9.44140625,
          "content": "github.com/AdaLogics/go-fuzz-headers v0.0.0-20210715213245-6c3934b029d8 h1:V8krnnfGj4pV65YLUm3C0/8bl7V5Nry2Pwvy3ru/wLc=\ngithub.com/AdaLogics/go-fuzz-headers v0.0.0-20210715213245-6c3934b029d8/go.mod h1:CzsSbkDixRphAF5hS6wbMKq0eI6ccJRb7/A0M6JBnwg=\ngithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOElx5B5HZ4hJQsoJ/PvUvKRhJHDQXO8P8=\ngithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=\ngithub.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=\ngithub.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=\ngithub.com/containerd/log v0.1.0 h1:TCJt7ioM2cr/tfR8GPbGf9/VRAX8D2B4PjzCpfX540I=\ngithub.com/containerd/log v0.1.0/go.mod h1:VRRf09a7mHDIRezVKTRCrOq78v577GXq3bSa3EhrzVo=\ngithub.com/creack/pty v1.1.11 h1:07n33Z8lZxZ2qwegKbObQohDhXDQxiMMz1NOUGYlesw=\ngithub.com/creack/pty v1.1.11/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/docker/docker v27.4.1+incompatible h1:ZJvcY7gfwHn1JF48PfbyXg7Jyt9ZCWDW+GGXOIxEwp4=\ngithub.com/docker/docker v27.4.1+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=\ngithub.com/docker/go-connections v0.4.0 h1:El9xVISelRB7BuFusrZozjnkIM5YnzCViNKohAFqRJQ=\ngithub.com/docker/go-connections v0.4.0/go.mod h1:Gbd7IOopHjR8Iph03tsViu4nIes5XhDvyHbTtUxmeec=\ngithub.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=\ngithub.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=\ngithub.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.15.9 h1:wKRjX6JRtDdrE9qwa4b/Cip7ACOshUI4smpCQanqjSY=\ngithub.com/klauspost/compress v1.15.9/go.mod h1:PhcZ0MbTNciWF3rruxRgKxI5NkcHHrHUDtV4Yw2GlzU=\ngithub.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=\ngithub.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=\ngithub.com/moby/patternmatcher v0.6.0 h1:GmP9lR19aU5GqSSFko+5pRqHi+Ohk1O69aFiKkVGiPk=\ngithub.com/moby/patternmatcher v0.6.0/go.mod h1:hDPoyOpDY7OrrMDLaYoY3hf52gNCR/YOUYxkhApJIxc=\ngithub.com/moby/sys/sequential v0.5.0 h1:OPvI35Lzn9K04PBbCLW0g4LcFAJgHsvXsRyewg5lXtc=\ngithub.com/moby/sys/sequential v0.5.0/go.mod h1:tH2cOOs5V9MlPiXcQzRC+eEyab644PWKGRYaaV5ZZlo=\ngithub.com/moby/sys/user v0.1.0 h1:WmZ93f5Ux6het5iituh9x2zAG7NFY9Aqi49jjE1PaQg=\ngithub.com/moby/sys/user v0.1.0/go.mod h1:fKJhFOnsCN6xZ5gSfbM6zaHGgDJMrqt9/reuj4T7MmU=\ngithub.com/moby/sys/userns v0.1.0 h1:tVLXkFOxVu9A64/yh59slHVv9ahO9UIev4JZusOLG/g=\ngithub.com/moby/sys/userns v0.1.0/go.mod h1:IHUYgu/kao6N8YZlp9Cf444ySSvCmDlmzUcYfDHOl28=\ngithub.com/moby/term v0.0.0-20210619224110-3f7ff695adc6 h1:dcztxKSvZ4Id8iPpHERQBbIJfabdt4wUm5qy3wOL2Zc=\ngithub.com/moby/term v0.0.0-20210619224110-3f7ff695adc6/go.mod h1:E2VnQOmVuvZB6UYnnDB0qG5Nq/1tD9acaOpo6xmt0Kw=\ngithub.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=\ngithub.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=\ngithub.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=\ngithub.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=\ngithub.com/opencontainers/image-spec v1.1.0-rc2.0.20221005185240-3a7f492d3f1b h1:YWuSjZCQAPM8UUBLkYUk1e+rZcvWHJmFb6i6rM44Xs8=\ngithub.com/opencontainers/image-spec v1.1.0-rc2.0.20221005185240-3a7f492d3f1b/go.mod h1:3OVijpioIKYWTqjiG0zfF6wvoJ4fAXGbjdZuI2NgsRQ=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=\ngithub.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=\ngolang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190624222133-a101b041ded4/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngotest.tools/v3 v3.0.2/go.mod h1:3SzNCllyD9/Y+b5r9JIKQ474KzkZyqLqEfYqMsX94Bk=\ngotest.tools/v3 v3.5.0 h1:Ljk6PdHdOhAb5aDMWXjDLMMhph+BpztA4v1QdqEW2eY=\ngotest.tools/v3 v3.5.0/go.mod h1:isy3WKz7GK6uNw/sbHzfKBLvlvXwUyV06n6brMxxopU=\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 1.5498046875,
          "content": "// Copyright 2020 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc expectNoSuchContainer(t *testing.T, id string, err error) {\n\tt.Helper()\n\tvar containerErr *NoSuchContainer\n\tif !errors.As(err, &containerErr) {\n\t\tt.Fatalf(\"Container: Wrong error information. Want %#v. Got %#v.\", containerErr, err)\n\t}\n\tif containerErr.ID != id {\n\t\tt.Errorf(\"Container: wrong container in error\\nWant %q\\ngot  %q\", id, containerErr.ID)\n\t}\n}\n\nfunc expectNoSuchNode(t *testing.T, nodeID string, err error) {\n\tt.Helper()\n\tvar nodeErr *NoSuchNode\n\tif !errors.As(err, &nodeErr) {\n\t\tt.Fatalf(\"Node: Wrong error information. Want %#v. Got %#v.\", nodeErr, err)\n\t}\n\tif nodeErr.ID != nodeID {\n\t\tt.Errorf(\"Node: wrong node in error\\nWant %q\\ngot  %q\", nodeID, nodeErr.ID)\n\t}\n}\n\nfunc expectNoSuchSecret(t *testing.T, secretID string, err error) {\n\tt.Helper()\n\tvar nodeErr *NoSuchSecret\n\tif !errors.As(err, &nodeErr) {\n\t\tt.Fatalf(\"Secret: Wrong error information. Want %#v. Got %#v.\", nodeErr, err)\n\t}\n\tif nodeErr.ID != secretID {\n\t\tt.Errorf(\"Secret: wrong secret in error\\nWant %q\\ngot  %q\", secretID, nodeErr.ID)\n\t}\n}\n\nfunc expectNoSuchConfig(t *testing.T, secretID string, err error) {\n\tt.Helper()\n\tvar nodeErr *NoSuchConfig\n\tif !errors.As(err, &nodeErr) {\n\t\tt.Fatalf(\"Config: Wrong error information. Want %#v. Got %#v.\", nodeErr, err)\n\t}\n\tif nodeErr.ID != secretID {\n\t\tt.Errorf(\"Config: wrong secret in error\\nWant %q\\ngot  %q\", secretID, nodeErr.ID)\n\t}\n}\n"
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 24.4765625,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\n// APIImages represent an image returned in the ListImages call.\ntype APIImages struct {\n\tID          string            `json:\"Id\" yaml:\"Id\" toml:\"Id\"`\n\tRepoTags    []string          `json:\"RepoTags,omitempty\" yaml:\"RepoTags,omitempty\" toml:\"RepoTags,omitempty\"`\n\tCreated     int64             `json:\"Created,omitempty\" yaml:\"Created,omitempty\" toml:\"Created,omitempty\"`\n\tSize        int64             `json:\"Size,omitempty\" yaml:\"Size,omitempty\" toml:\"Size,omitempty\"`\n\tVirtualSize int64             `json:\"VirtualSize,omitempty\" yaml:\"VirtualSize,omitempty\" toml:\"VirtualSize,omitempty\"`\n\tParentID    string            `json:\"ParentId,omitempty\" yaml:\"ParentId,omitempty\" toml:\"ParentId,omitempty\"`\n\tRepoDigests []string          `json:\"RepoDigests,omitempty\" yaml:\"RepoDigests,omitempty\" toml:\"RepoDigests,omitempty\"`\n\tLabels      map[string]string `json:\"Labels,omitempty\" yaml:\"Labels,omitempty\" toml:\"Labels,omitempty\"`\n}\n\n// RootFS represents the underlying layers used by an image\ntype RootFS struct {\n\tType   string   `json:\"Type,omitempty\" yaml:\"Type,omitempty\" toml:\"Type,omitempty\"`\n\tLayers []string `json:\"Layers,omitempty\" yaml:\"Layers,omitempty\" toml:\"Layers,omitempty\"`\n}\n\n// Image is the type representing a docker image and its various properties\ntype Image struct {\n\tID              string    `json:\"Id\" yaml:\"Id\" toml:\"Id\"`\n\tRepoTags        []string  `json:\"RepoTags,omitempty\" yaml:\"RepoTags,omitempty\" toml:\"RepoTags,omitempty\"`\n\tParent          string    `json:\"Parent,omitempty\" yaml:\"Parent,omitempty\" toml:\"Parent,omitempty\"`\n\tComment         string    `json:\"Comment,omitempty\" yaml:\"Comment,omitempty\" toml:\"Comment,omitempty\"`\n\tCreated         time.Time `json:\"Created,omitempty\" yaml:\"Created,omitempty\" toml:\"Created,omitempty\"`\n\tContainer       string    `json:\"Container,omitempty\" yaml:\"Container,omitempty\" toml:\"Container,omitempty\"`\n\tContainerConfig Config    `json:\"ContainerConfig,omitempty\" yaml:\"ContainerConfig,omitempty\" toml:\"ContainerConfig,omitempty\"`\n\tDockerVersion   string    `json:\"DockerVersion,omitempty\" yaml:\"DockerVersion,omitempty\" toml:\"DockerVersion,omitempty\"`\n\tAuthor          string    `json:\"Author,omitempty\" yaml:\"Author,omitempty\" toml:\"Author,omitempty\"`\n\tConfig          *Config   `json:\"Config,omitempty\" yaml:\"Config,omitempty\" toml:\"Config,omitempty\"`\n\tArchitecture    string    `json:\"Architecture,omitempty\" yaml:\"Architecture,omitempty\"`\n\tSize            int64     `json:\"Size,omitempty\" yaml:\"Size,omitempty\" toml:\"Size,omitempty\"`\n\tVirtualSize     int64     `json:\"VirtualSize,omitempty\" yaml:\"VirtualSize,omitempty\" toml:\"VirtualSize,omitempty\"`\n\tRepoDigests     []string  `json:\"RepoDigests,omitempty\" yaml:\"RepoDigests,omitempty\" toml:\"RepoDigests,omitempty\"`\n\tRootFS          *RootFS   `json:\"RootFS,omitempty\" yaml:\"RootFS,omitempty\" toml:\"RootFS,omitempty\"`\n\tOS              string    `json:\"Os,omitempty\" yaml:\"Os,omitempty\" toml:\"Os,omitempty\"`\n}\n\n// ImagePre012 serves the same purpose as the Image type except that it is for\n// earlier versions of the Docker API (pre-012 to be specific)\ntype ImagePre012 struct {\n\tID              string    `json:\"id\"`\n\tParent          string    `json:\"parent,omitempty\"`\n\tComment         string    `json:\"comment,omitempty\"`\n\tCreated         time.Time `json:\"created\"`\n\tContainer       string    `json:\"container,omitempty\"`\n\tContainerConfig Config    `json:\"container_config,omitempty\"`\n\tDockerVersion   string    `json:\"docker_version,omitempty\"`\n\tAuthor          string    `json:\"author,omitempty\"`\n\tConfig          *Config   `json:\"config,omitempty\"`\n\tArchitecture    string    `json:\"architecture,omitempty\"`\n\tSize            int64     `json:\"size,omitempty\"`\n}\n\nvar (\n\t// ErrNoSuchImage is the error returned when the image does not exist.\n\tErrNoSuchImage = errors.New(\"no such image\")\n\n\t// ErrMissingRepo is the error returned when the remote repository is\n\t// missing.\n\tErrMissingRepo = errors.New(\"missing remote repository e.g. 'github.com/user/repo'\")\n\n\t// ErrMissingOutputStream is the error returned when no output stream\n\t// is provided to some calls, like BuildImage.\n\tErrMissingOutputStream = errors.New(\"missing output stream\")\n\n\t// ErrMultipleContexts is the error returned when both a ContextDir and\n\t// InputStream are provided in BuildImageOptions\n\tErrMultipleContexts = errors.New(\"image build may not be provided BOTH context dir and input stream\")\n\n\t// ErrMustSpecifyNames is the error returned when the Names field on\n\t// ExportImagesOptions is nil or empty\n\tErrMustSpecifyNames = errors.New(\"must specify at least one name to export\")\n)\n\n// ListImagesOptions specify parameters to the ListImages function.\n//\n// See https://goo.gl/BVzauZ for more details.\ntype ListImagesOptions struct {\n\tFilters map[string][]string\n\tAll     bool\n\tDigests bool\n\tFilter  string\n\tContext context.Context\n}\n\n// ListImages returns the list of available images in the server.\n//\n// See https://goo.gl/BVzauZ for more details.\nfunc (c *Client) ListImages(opts ListImagesOptions) ([]APIImages, error) {\n\tpath := \"/images/json?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar images []APIImages\n\tif err := json.NewDecoder(resp.Body).Decode(&images); err != nil {\n\t\treturn nil, err\n\t}\n\treturn images, nil\n}\n\n// ImageHistory represent a layer in an image's history returned by the\n// ImageHistory call.\ntype ImageHistory struct {\n\tID        string   `json:\"Id\" yaml:\"Id\" toml:\"Id\"`\n\tTags      []string `json:\"Tags,omitempty\" yaml:\"Tags,omitempty\" toml:\"Tags,omitempty\"`\n\tCreated   int64    `json:\"Created,omitempty\" yaml:\"Created,omitempty\" toml:\"Tags,omitempty\"`\n\tCreatedBy string   `json:\"CreatedBy,omitempty\" yaml:\"CreatedBy,omitempty\" toml:\"CreatedBy,omitempty\"`\n\tSize      int64    `json:\"Size,omitempty\" yaml:\"Size,omitempty\" toml:\"Size,omitempty\"`\n\tComment   string   `json:\"Comment,omitempty\" yaml:\"Comment,omitempty\" toml:\"Comment,omitempty\"`\n}\n\n// ImageHistory returns the history of the image by its name or ID.\n//\n// See https://goo.gl/fYtxQa for more details.\nfunc (c *Client) ImageHistory(name string) ([]ImageHistory, error) {\n\tresp, err := c.do(http.MethodGet, \"/images/\"+name+\"/history\", doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, ErrNoSuchImage\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar history []ImageHistory\n\tif err := json.NewDecoder(resp.Body).Decode(&history); err != nil {\n\t\treturn nil, err\n\t}\n\treturn history, nil\n}\n\n// RemoveImage removes an image by its name or ID.\n//\n// See https://goo.gl/Vd2Pck for more details.\nfunc (c *Client) RemoveImage(name string) error {\n\tresp, err := c.do(http.MethodDelete, \"/images/\"+name, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn ErrNoSuchImage\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// RemoveImageOptions present the set of options available for removing an image\n// from a registry.\n//\n// See https://goo.gl/Vd2Pck for more details.\ntype RemoveImageOptions struct {\n\tForce   bool `qs:\"force\"`\n\tNoPrune bool `qs:\"noprune\"`\n\tContext context.Context\n}\n\n// RemoveImageExtended removes an image by its name or ID.\n// Extra params can be passed, see RemoveImageOptions\n//\n// See https://goo.gl/Vd2Pck for more details.\nfunc (c *Client) RemoveImageExtended(name string, opts RemoveImageOptions) error {\n\turi := fmt.Sprintf(\"/images/%s?%s\", name, queryString(&opts))\n\tresp, err := c.do(http.MethodDelete, uri, doOptions{context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn ErrNoSuchImage\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// InspectImage returns an image by its name or ID.\n//\n// See https://goo.gl/ncLTG8 for more details.\nfunc (c *Client) InspectImage(name string) (*Image, error) {\n\tresp, err := c.do(http.MethodGet, \"/images/\"+name+\"/json\", doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, ErrNoSuchImage\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar image Image\n\n\t// if the caller elected to skip checking the server's version, assume it's the latest\n\tif c.SkipServerVersionCheck || c.expectedAPIVersion.GreaterThanOrEqualTo(apiVersion112) {\n\t\tif err := json.NewDecoder(resp.Body).Decode(&image); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tvar imagePre012 ImagePre012\n\t\tif err := json.NewDecoder(resp.Body).Decode(&imagePre012); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\timage.ID = imagePre012.ID\n\t\timage.Parent = imagePre012.Parent\n\t\timage.Comment = imagePre012.Comment\n\t\timage.Created = imagePre012.Created\n\t\timage.Container = imagePre012.Container\n\t\timage.ContainerConfig = imagePre012.ContainerConfig\n\t\timage.DockerVersion = imagePre012.DockerVersion\n\t\timage.Author = imagePre012.Author\n\t\timage.Config = imagePre012.Config\n\t\timage.Architecture = imagePre012.Architecture\n\t\timage.Size = imagePre012.Size\n\t}\n\n\treturn &image, nil\n}\n\n// PushImageOptions represents options to use in the PushImage method.\n//\n// See https://goo.gl/BZemGg for more details.\ntype PushImageOptions struct {\n\t// Name of the image\n\tName string\n\n\t// Tag of the image\n\tTag string\n\n\t// Registry server to push the image\n\tRegistry string\n\n\tOutputStream      io.Writer     `qs:\"-\"`\n\tRawJSONStream     bool          `qs:\"-\"`\n\tInactivityTimeout time.Duration `qs:\"-\"`\n\n\tContext context.Context\n}\n\n// PushImage pushes an image to a remote registry, logging progress to w.\n//\n// An empty instance of AuthConfiguration may be used for unauthenticated\n// pushes.\n//\n// See https://goo.gl/BZemGg for more details.\nfunc (c *Client) PushImage(opts PushImageOptions, auth AuthConfiguration) error {\n\tif opts.Name == \"\" {\n\t\treturn ErrNoSuchImage\n\t}\n\theaders, err := headersWithAuth(auth)\n\tif err != nil {\n\t\treturn err\n\t}\n\tname := opts.Name\n\topts.Name = \"\"\n\tpath := \"/images/\" + name + \"/push?\" + queryString(&opts)\n\treturn c.stream(http.MethodPost, path, streamOptions{\n\t\tsetRawTerminal:    true,\n\t\trawJSONStream:     opts.RawJSONStream,\n\t\theaders:           headers,\n\t\tstdout:            opts.OutputStream,\n\t\tinactivityTimeout: opts.InactivityTimeout,\n\t\tcontext:           opts.Context,\n\t})\n}\n\n// PullImageOptions present the set of options available for pulling an image\n// from a registry.\n//\n// See https://goo.gl/qkoSsn for more details.\ntype PullImageOptions struct {\n\tAll        bool\n\tRepository string `qs:\"fromImage\"`\n\tTag        string\n\tPlatform   string `ver:\"1.32\"`\n\n\t// Only required for Docker Engine 1.9 or 1.10 w/ Remote API < 1.21\n\t// and Docker Engine < 1.9\n\t// This parameter was removed in Docker Engine 1.11\n\tRegistry string\n\n\tOutputStream      io.Writer     `qs:\"-\"`\n\tRawJSONStream     bool          `qs:\"-\"`\n\tInactivityTimeout time.Duration `qs:\"-\"`\n\tContext           context.Context\n}\n\n// PullImage pulls an image from a remote registry, logging progress to\n// opts.OutputStream.\n//\n// See https://goo.gl/qkoSsn for more details.\nfunc (c *Client) PullImage(opts PullImageOptions, auth AuthConfiguration) error {\n\tif opts.Repository == \"\" {\n\t\treturn ErrNoSuchImage\n\t}\n\n\theaders, err := headersWithAuth(auth)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif opts.Tag == \"\" && strings.Contains(opts.Repository, \"@\") {\n\t\tparts := strings.SplitN(opts.Repository, \"@\", 2)\n\t\topts.Repository = parts[0]\n\t\topts.Tag = parts[1]\n\t}\n\treturn c.createImage(&opts, headers, nil, opts.OutputStream, opts.RawJSONStream, opts.InactivityTimeout, opts.Context)\n}\n\nfunc (c *Client) createImage(opts any, headers map[string]string, in io.Reader, w io.Writer, rawJSONStream bool, timeout time.Duration, context context.Context) error {\n\turl, err := c.getPath(\"/images/create\", opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.streamURL(http.MethodPost, url, streamOptions{\n\t\tsetRawTerminal:    true,\n\t\theaders:           headers,\n\t\tin:                in,\n\t\tstdout:            w,\n\t\trawJSONStream:     rawJSONStream,\n\t\tinactivityTimeout: timeout,\n\t\tcontext:           context,\n\t})\n}\n\n// LoadImageOptions represents the options for LoadImage Docker API Call\n//\n// See https://goo.gl/rEsBV3 for more details.\ntype LoadImageOptions struct {\n\tInputStream  io.Reader\n\tOutputStream io.Writer\n\tContext      context.Context\n}\n\n// LoadImage imports a tarball docker image\n//\n// See https://goo.gl/rEsBV3 for more details.\nfunc (c *Client) LoadImage(opts LoadImageOptions) error {\n\treturn c.stream(http.MethodPost, \"/images/load\", streamOptions{\n\t\tsetRawTerminal: true,\n\t\tin:             opts.InputStream,\n\t\tstdout:         opts.OutputStream,\n\t\tcontext:        opts.Context,\n\t})\n}\n\n// ExportImageOptions represent the options for ExportImage Docker API call.\n//\n// See https://goo.gl/AuySaA for more details.\ntype ExportImageOptions struct {\n\tName              string\n\tOutputStream      io.Writer\n\tInactivityTimeout time.Duration\n\tContext           context.Context\n}\n\n// ExportImage exports an image (as a tar file) into the stream.\n//\n// See https://goo.gl/AuySaA for more details.\nfunc (c *Client) ExportImage(opts ExportImageOptions) error {\n\treturn c.stream(http.MethodGet, fmt.Sprintf(\"/images/%s/get\", opts.Name), streamOptions{\n\t\tsetRawTerminal:    true,\n\t\tstdout:            opts.OutputStream,\n\t\tinactivityTimeout: opts.InactivityTimeout,\n\t\tcontext:           opts.Context,\n\t})\n}\n\n// ExportImagesOptions represent the options for ExportImages Docker API call\n//\n// See https://goo.gl/N9XlDn for more details.\ntype ExportImagesOptions struct {\n\tNames             []string\n\tOutputStream      io.Writer     `qs:\"-\"`\n\tInactivityTimeout time.Duration `qs:\"-\"`\n\tContext           context.Context\n}\n\n// ExportImages exports one or more images (as a tar file) into the stream\n//\n// See https://goo.gl/N9XlDn for more details.\nfunc (c *Client) ExportImages(opts ExportImagesOptions) error {\n\tif len(opts.Names) == 0 {\n\t\treturn ErrMustSpecifyNames\n\t}\n\t// API < 1.25 allows multiple name values\n\t// 1.25 says name must be a comma separated list\n\tvar err error\n\tvar exporturl string\n\tif c.requestedAPIVersion.GreaterThanOrEqualTo(apiVersion125) {\n\t\tstr := opts.Names[0]\n\t\tfor _, val := range opts.Names[1:] {\n\t\t\tstr += \",\" + val\n\t\t}\n\t\texporturl, err = c.getPath(\"/images/get\", ExportImagesOptions{\n\t\t\tNames:             []string{str},\n\t\t\tOutputStream:      opts.OutputStream,\n\t\t\tInactivityTimeout: opts.InactivityTimeout,\n\t\t\tContext:           opts.Context,\n\t\t})\n\t} else {\n\t\texporturl, err = c.getPath(\"/images/get\", &opts)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.streamURL(http.MethodGet, exporturl, streamOptions{\n\t\tsetRawTerminal:    true,\n\t\tstdout:            opts.OutputStream,\n\t\tinactivityTimeout: opts.InactivityTimeout,\n\t})\n}\n\n// ImportImageOptions present the set of informations available for importing\n// an image from a source file or the stdin.\n//\n// See https://goo.gl/qkoSsn for more details.\ntype ImportImageOptions struct {\n\tRepository string `qs:\"repo\"`\n\tSource     string `qs:\"fromSrc\"`\n\tTag        string `qs:\"tag\"`\n\n\tInputStream       io.Reader     `qs:\"-\"`\n\tOutputStream      io.Writer     `qs:\"-\"`\n\tRawJSONStream     bool          `qs:\"-\"`\n\tInactivityTimeout time.Duration `qs:\"-\"`\n\tContext           context.Context\n}\n\n// ImportImage imports an image from a url, a file or stdin\n//\n// See https://goo.gl/qkoSsn for more details.\nfunc (c *Client) ImportImage(opts ImportImageOptions) error {\n\tif opts.Repository == \"\" {\n\t\treturn ErrNoSuchImage\n\t}\n\tif opts.Source != \"-\" {\n\t\topts.InputStream = nil\n\t}\n\tif opts.Source != \"-\" && !isURL(opts.Source) {\n\t\tf, err := os.Open(opts.Source)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topts.InputStream = f\n\t\topts.Source = \"-\"\n\t}\n\treturn c.createImage(&opts, nil, opts.InputStream, opts.OutputStream, opts.RawJSONStream, opts.InactivityTimeout, opts.Context)\n}\n\n// BuilderVersion represents either the BuildKit or V1 (\"classic\") builder.\ntype BuilderVersion string\n\nconst (\n\tBuilderV1       BuilderVersion = \"1\"\n\tBuilderBuildKit BuilderVersion = \"2\"\n)\n\n// BuildImageOptions present the set of informations available for building an\n// image from a tarfile with a Dockerfile in it.\n//\n// For more details about the Docker building process, see\n// https://goo.gl/4nYHwV.\ntype BuildImageOptions struct {\n\tContext             context.Context\n\tName                string   `qs:\"t\"`\n\tDockerfile          string   `ver:\"1.25\"`\n\tExtraHosts          string   `ver:\"1.28\"`\n\tCacheFrom           []string `qs:\"-\" ver:\"1.25\"`\n\tMemory              int64\n\tMemswap             int64\n\tShmSize             int64\n\tCPUShares           int64\n\tCPUQuota            int64 `ver:\"1.21\"`\n\tCPUPeriod           int64 `ver:\"1.21\"`\n\tCPUSetCPUs          string\n\tLabels              map[string]string\n\tInputStream         io.Reader `qs:\"-\"`\n\tOutputStream        io.Writer `qs:\"-\"`\n\tRemote              string\n\tAuth                AuthConfiguration  `qs:\"-\"` // for older docker X-Registry-Auth header\n\tAuthConfigs         AuthConfigurations `qs:\"-\"` // for newer docker X-Registry-Config header\n\tContextDir          string             `qs:\"-\"`\n\tUlimits             []ULimit           `qs:\"-\" ver:\"1.18\"`\n\tBuildArgs           []BuildArg         `qs:\"-\" ver:\"1.21\"`\n\tNetworkMode         string             `ver:\"1.25\"`\n\tPlatform            string             `ver:\"1.32\"`\n\tInactivityTimeout   time.Duration      `qs:\"-\"`\n\tCgroupParent        string\n\tSecurityOpt         []string\n\tTarget              string\n\tOutputs             string `ver:\"1.40\"`\n\tNoCache             bool\n\tSuppressOutput      bool           `qs:\"q\"`\n\tPull                bool           `ver:\"1.16\"`\n\tRmTmpContainer      bool           `qs:\"rm\"`\n\tForceRmTmpContainer bool           `qs:\"forcerm\" ver:\"1.12\"`\n\tRawJSONStream       bool           `qs:\"-\"`\n\tVersion             BuilderVersion `qs:\"version\" ver:\"1.39\"`\n}\n\n// BuildArg represents arguments that can be passed to the image when building\n// it from a Dockerfile.\n//\n// For more details about the Docker building process, see\n// https://goo.gl/4nYHwV.\ntype BuildArg struct {\n\tName  string `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tValue string `json:\"Value,omitempty\" yaml:\"Value,omitempty\" toml:\"Value,omitempty\"`\n}\n\n// BuildImage builds an image from a tarball's url or a Dockerfile in the input\n// stream.\n//\n// See https://goo.gl/4nYHwV for more details.\nfunc (c *Client) BuildImage(opts BuildImageOptions) error {\n\tif opts.OutputStream == nil {\n\t\treturn ErrMissingOutputStream\n\t}\n\theaders, err := headersWithAuth(opts.Auth, c.versionedAuthConfigs(opts.AuthConfigs))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif opts.Remote != \"\" && opts.Name == \"\" {\n\t\topts.Name = opts.Remote\n\t}\n\tif opts.InputStream != nil || opts.ContextDir != \"\" {\n\t\theaders[\"Content-Type\"] = \"application/tar\"\n\t} else if opts.Remote == \"\" {\n\t\treturn ErrMissingRepo\n\t}\n\tif opts.ContextDir != \"\" {\n\t\tif opts.InputStream != nil {\n\t\t\treturn ErrMultipleContexts\n\t\t}\n\t\tvar err error\n\t\tif opts.InputStream, err = createTarStream(opts.ContextDir, opts.Dockerfile); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tqs, ver := queryStringVersion(&opts)\n\n\tif len(opts.CacheFrom) > 0 {\n\t\tif b, err := json.Marshal(opts.CacheFrom); err == nil {\n\t\t\titem := url.Values(map[string][]string{})\n\t\t\titem.Add(\"cachefrom\", string(b))\n\t\t\tqs = fmt.Sprintf(\"%s&%s\", qs, item.Encode())\n\t\t\tif ver == nil || apiVersion125.GreaterThan(ver) {\n\t\t\t\tver = apiVersion125\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(opts.Ulimits) > 0 {\n\t\tif b, err := json.Marshal(opts.Ulimits); err == nil {\n\t\t\titem := url.Values(map[string][]string{})\n\t\t\titem.Add(\"ulimits\", string(b))\n\t\t\tqs = fmt.Sprintf(\"%s&%s\", qs, item.Encode())\n\t\t\tif ver == nil || apiVersion118.GreaterThan(ver) {\n\t\t\t\tver = apiVersion118\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(opts.BuildArgs) > 0 {\n\t\tv := make(map[string]string)\n\t\tfor _, arg := range opts.BuildArgs {\n\t\t\tv[arg.Name] = arg.Value\n\t\t}\n\t\tif b, err := json.Marshal(v); err == nil {\n\t\t\titem := url.Values(map[string][]string{})\n\t\t\titem.Add(\"buildargs\", string(b))\n\t\t\tqs = fmt.Sprintf(\"%s&%s\", qs, item.Encode())\n\t\t\tif ver == nil || apiVersion121.GreaterThan(ver) {\n\t\t\t\tver = apiVersion121\n\t\t\t}\n\t\t}\n\t}\n\n\tbuildURL, err := c.pathVersionCheck(\"/build\", qs, ver)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn c.streamURL(http.MethodPost, buildURL, streamOptions{\n\t\tsetRawTerminal:    true,\n\t\trawJSONStream:     opts.RawJSONStream,\n\t\theaders:           headers,\n\t\tin:                opts.InputStream,\n\t\tstdout:            opts.OutputStream,\n\t\tinactivityTimeout: opts.InactivityTimeout,\n\t\tcontext:           opts.Context,\n\t})\n}\n\nfunc (c *Client) versionedAuthConfigs(authConfigs AuthConfigurations) registryAuth {\n\tif c.serverAPIVersion == nil {\n\t\tc.checkAPIVersion()\n\t}\n\tif c.serverAPIVersion != nil && c.serverAPIVersion.GreaterThanOrEqualTo(apiVersion119) {\n\t\treturn AuthConfigurations119(authConfigs.Configs)\n\t}\n\treturn authConfigs\n}\n\n// TagImageOptions present the set of options to tag an image.\n//\n// See https://goo.gl/prHrvo for more details.\ntype TagImageOptions struct {\n\tRepo    string\n\tTag     string\n\tForce   bool\n\tContext context.Context\n}\n\n// TagImage adds a tag to the image identified by the given name.\n//\n// See https://goo.gl/prHrvo for more details.\nfunc (c *Client) TagImage(name string, opts TagImageOptions) error {\n\tif name == \"\" {\n\t\treturn ErrNoSuchImage\n\t}\n\tresp, err := c.do(http.MethodPost, \"/images/\"+name+\"/tag?\"+queryString(&opts), doOptions{\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusNotFound {\n\t\treturn ErrNoSuchImage\n\t}\n\n\treturn err\n}\n\nfunc isURL(u string) bool {\n\tp, err := url.Parse(u)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn p.Scheme == \"http\" || p.Scheme == \"https\"\n}\n\nfunc headersWithAuth(auths ...registryAuth) (map[string]string, error) {\n\theaders := make(map[string]string)\n\n\tfor _, auth := range auths {\n\t\tif auth.isEmpty() {\n\t\t\tcontinue\n\t\t}\n\t\tdata, err := json.Marshal(auth)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\theaders[auth.headerKey()] = base64.URLEncoding.EncodeToString(data)\n\t}\n\n\treturn headers, nil\n}\n\n// APIImageSearch reflect the result of a search on the Docker Hub.\n//\n// See https://goo.gl/KLO9IZ for more details.\ntype APIImageSearch struct {\n\tDescription string `json:\"description,omitempty\" yaml:\"description,omitempty\" toml:\"description,omitempty\"`\n\tIsOfficial  bool   `json:\"is_official,omitempty\" yaml:\"is_official,omitempty\" toml:\"is_official,omitempty\"`\n\tIsAutomated bool   `json:\"is_automated,omitempty\" yaml:\"is_automated,omitempty\" toml:\"is_automated,omitempty\"`\n\tName        string `json:\"name,omitempty\" yaml:\"name,omitempty\" toml:\"name,omitempty\"`\n\tStarCount   int    `json:\"star_count,omitempty\" yaml:\"star_count,omitempty\" toml:\"star_count,omitempty\"`\n}\n\n// SearchImages search the docker hub with a specific given term.\n//\n// See https://goo.gl/KLO9IZ for more details.\nfunc (c *Client) SearchImages(term string) ([]APIImageSearch, error) {\n\tresp, err := c.do(http.MethodGet, \"/images/search?term=\"+term, doOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar searchResult []APIImageSearch\n\tif err := json.NewDecoder(resp.Body).Decode(&searchResult); err != nil {\n\t\treturn nil, err\n\t}\n\treturn searchResult, nil\n}\n\n// SearchImagesEx search the docker hub with a specific given term and authentication.\n//\n// See https://goo.gl/KLO9IZ for more details.\nfunc (c *Client) SearchImagesEx(term string, auth AuthConfiguration) ([]APIImageSearch, error) {\n\theaders, err := headersWithAuth(auth)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := c.do(http.MethodGet, \"/images/search?term=\"+term, doOptions{\n\t\theaders: headers,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tvar searchResult []APIImageSearch\n\tif err := json.NewDecoder(resp.Body).Decode(&searchResult); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn searchResult, nil\n}\n\n// PruneImagesOptions specify parameters to the PruneImages function.\n//\n// See https://goo.gl/qfZlbZ for more details.\ntype PruneImagesOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// PruneImagesResults specify results from the PruneImages function.\n//\n// See https://goo.gl/qfZlbZ for more details.\ntype PruneImagesResults struct {\n\tImagesDeleted  []struct{ Untagged, Deleted string }\n\tSpaceReclaimed int64\n}\n\n// PruneImages deletes images which are unused.\n//\n// See https://goo.gl/qfZlbZ for more details.\nfunc (c *Client) PruneImages(opts PruneImagesOptions) (*PruneImagesResults, error) {\n\tpath := \"/images/prune?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar results PruneImagesResults\n\tif err := json.NewDecoder(resp.Body).Decode(&results); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &results, nil\n}\n"
        },
        {
          "name": "image_test.go",
          "type": "blob",
          "size": 34.6494140625,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc newTestClient(rt http.RoundTripper) Client {\n\tendpoint := \"http://localhost:4243\"\n\tu, _ := parseEndpoint(\"http://localhost:4243\", false)\n\ttestAPIVersion, _ := NewAPIVersion(\"1.17\")\n\tclient := Client{\n\t\tHTTPClient:             &http.Client{Transport: rt},\n\t\tDialer:                 &net.Dialer{},\n\t\tendpoint:               endpoint,\n\t\tendpointURL:            u,\n\t\tSkipServerVersionCheck: true,\n\t\tserverAPIVersion:       testAPIVersion,\n\t}\n\treturn client\n}\n\ntype stdoutMock struct {\n\t*bytes.Buffer\n}\n\nfunc (m stdoutMock) Close() error {\n\treturn nil\n}\n\ntype stdinMock struct {\n\t*bytes.Buffer\n}\n\nfunc (m stdinMock) Close() error {\n\treturn nil\n}\n\nfunc TestListImages(t *testing.T) {\n\tt.Parallel()\n\tbody := `[\n     {\n             \"Repository\":\"base\",\n             \"Tag\":\"ubuntu-12.10\",\n             \"Id\":\"b750fe79269d\",\n             \"Created\":1364102658\n     },\n     {\n             \"Repository\":\"base\",\n             \"Tag\":\"ubuntu-quantal\",\n             \"Id\":\"b750fe79269d\",\n             \"Created\":1364102658\n     },\n     {\n             \"RepoTag\": [\n             \"ubuntu:12.04\",\n             \"ubuntu:precise\",\n             \"ubuntu:latest\"\n             ],\n             \"Id\": \"8dbd9e392a964c\",\n             \"Created\": 1365714795,\n             \"Size\": 131506275,\n             \"VirtualSize\": 131506275\n      },\n      {\n             \"RepoTag\": [\n             \"ubuntu:12.10\",\n             \"ubuntu:quantal\"\n             ],\n             \"ParentId\": \"27cf784147099545\",\n             \"Id\": \"b750fe79269d2e\",\n             \"Created\": 1364102658,\n             \"Size\": 24653,\n             \"VirtualSize\": 180116135\n      }\n]`\n\tvar expected []APIImages\n\terr := json.Unmarshal([]byte(body), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: body, status: http.StatusOK})\n\timages, err := client.ListImages(ListImagesOptions{})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !reflect.DeepEqual(images, expected) {\n\t\tt.Errorf(\"ListImages: Wrong return value. Want %#v. Got %#v.\", expected, images)\n\t}\n}\n\nfunc TestListImagesParameters(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"null\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\t_, err := client.ListImages(ListImagesOptions{All: false})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"ListImages({All: false}: Wrong HTTP method. Want GET. Got %s.\", req.Method)\n\t}\n\tif all := req.URL.Query().Get(\"all\"); all != \"0\" && all != \"\" {\n\t\tt.Errorf(\"ListImages({All: false}): Wrong parameter. Want all=0 or not present at all. Got all=%s\", all)\n\t}\n\tfakeRT.Reset()\n\t_, err = client.ListImages(ListImagesOptions{All: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq = fakeRT.requests[0]\n\tif all := req.URL.Query().Get(\"all\"); all != \"1\" {\n\t\tt.Errorf(\"ListImages({All: true}): Wrong parameter. Want all=1. Got all=%s\", all)\n\t}\n\tfakeRT.Reset()\n\t_, err = client.ListImages(ListImagesOptions{Filters: map[string][]string{\n\t\t\"dangling\": {\"true\"},\n\t}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq = fakeRT.requests[0]\n\tbody := req.URL.Query().Get(\"filters\")\n\tvar filters map[string][]string\n\terr = json.Unmarshal([]byte(body), &filters)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(filters[\"dangling\"]) != 1 || filters[\"dangling\"][0] != \"true\" {\n\t\tt.Errorf(\"ListImages(dangling=[true]): Wrong filter map. Want dangling=[true], got dangling=%v\", filters[\"dangling\"])\n\t}\n}\n\nfunc TestImageHistory(t *testing.T) {\n\tt.Parallel()\n\tbody := `[\n\t{\n\t\t\"Id\": \"25daec02219d2d852f7526137213a9b199926b4b24e732eab5b8bc6c49bd470e\",\n\t\t\"Tags\": [\n\t\t\t\"debian:7.6\",\n\t\t\t\"debian:latest\",\n\t\t\t\"debian:7\",\n\t\t\t\"debian:wheezy\"\n\t\t],\n\t\t\"Created\": 1409856216,\n\t\t\"CreatedBy\": \"/bin/sh -c #(nop) CMD [/bin/bash]\"\n\t},\n\t{\n\t\t\"Id\": \"41026a5347fb5be6ed16115bf22df8569697139f246186de9ae8d4f67c335dce\",\n\t\t\"Created\": 1409856213,\n\t\t\"CreatedBy\": \"/bin/sh -c #(nop) ADD file:1ee9e97209d00e3416a4543b23574cc7259684741a46bbcbc755909b8a053a38 in /\",\n\t\t\"Size\": 85178663\n\t},\n\t{\n\t\t\"Id\": \"511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158\",\n\t\t\"Tags\": [\n\t\t\t\"scratch:latest\"\n\t\t],\n\t\t\"Created\": 1371157430\n\t}\n]`\n\tvar expected []ImageHistory\n\terr := json.Unmarshal([]byte(body), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: body, status: http.StatusOK})\n\thistory, err := client.ImageHistory(\"debian:latest\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !reflect.DeepEqual(history, expected) {\n\t\tt.Errorf(\"ImageHistory: Wrong return value. Want %#v. Got %#v.\", expected, history)\n\t}\n}\n\nfunc TestRemoveImage(t *testing.T) {\n\tt.Parallel()\n\tname := \"test\"\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\terr := client.RemoveImage(name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodDelete\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"RemoveImage(%q): Wrong HTTP method. Want %s. Got %s.\", name, expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/images/\" + name))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"RemoveImage(%q): Wrong request path. Want %q. Got %q.\", name, u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestRemoveImageNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such image\", status: http.StatusNotFound})\n\terr := client.RemoveImage(\"test:\")\n\tif !errors.Is(err, ErrNoSuchImage) {\n\t\tt.Errorf(\"RemoveImage: wrong error. Want %#v. Got %#v.\", ErrNoSuchImage, err)\n\t}\n}\n\nfunc TestRemoveImageExtended(t *testing.T) {\n\tt.Parallel()\n\tname := \"test\"\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\terr := client.RemoveImageExtended(name, RemoveImageOptions{Force: true, NoPrune: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodDelete\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"RemoveImage(%q): Wrong HTTP method. Want %s. Got %s.\", name, expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/images/\" + name))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"RemoveImage(%q): Wrong request path. Want %q. Got %q.\", name, u.Path, req.URL.Path)\n\t}\n\texpectedQuery := \"force=1&noprune=1\"\n\tif query := req.URL.Query().Encode(); query != expectedQuery {\n\t\tt.Errorf(\"PushImage: Wrong query string. Want %q. Got %q.\", expectedQuery, query)\n\t}\n}\n\nfunc TestInspectImage(t *testing.T) {\n\tt.Parallel()\n\tbody := `{\n     \"Id\":\"b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\",\n     \"Parent\":\"27cf784147099545\",\n     \"Created\":\"2013-03-23T22:24:18.818426Z\",\n     \"Container\":\"3d67245a8d72ecf13f33dffac9f79dcdf70f75acb84d308770391510e0c23ad0\",\n     \"ContainerConfig\":{\"Memory\":1},\n     \"VirtualSize\":12345,\n     \"RootFS\": {\n       \"Type\": \"layers\",\n       \"Layers\": [\n         \"sha256:05a0deb2e405eb3095ab646dc1695a26bffe8bd4071e3af90efcf16e9d3f6d93\",\n         \"sha256:4c5db681b9aa9ab1cf666ec969a810c8ff4410e70e06394670dc4f3bf595532f\"\n       ]\n    }\n}`\n\n\tcreated, err := time.Parse(time.RFC3339Nano, \"2013-03-23T22:24:18.818426Z\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := Image{\n\t\tID:        \"b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\",\n\t\tParent:    \"27cf784147099545\",\n\t\tCreated:   created,\n\t\tContainer: \"3d67245a8d72ecf13f33dffac9f79dcdf70f75acb84d308770391510e0c23ad0\",\n\t\tContainerConfig: Config{\n\t\t\tMemory: 1,\n\t\t},\n\t\tVirtualSize: 12345,\n\t\tRootFS: &RootFS{\n\t\t\tType: \"layers\",\n\t\t\tLayers: []string{\n\t\t\t\t\"sha256:05a0deb2e405eb3095ab646dc1695a26bffe8bd4071e3af90efcf16e9d3f6d93\",\n\t\t\t\t\"sha256:4c5db681b9aa9ab1cf666ec969a810c8ff4410e70e06394670dc4f3bf595532f\",\n\t\t\t},\n\t\t},\n\t}\n\tfakeRT := &FakeRoundTripper{message: body, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\timage, err := client.InspectImage(expected.ID)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*image, expected) {\n\t\tt.Errorf(\"InspectImage(%q): Wrong image returned. Want %#v. Got %#v.\", expected.ID, expected, *image)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"InspectImage(%q): Wrong HTTP method. Want GET. Got %s.\", expected.ID, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/images/\" + expected.ID + \"/json\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"InspectImage(%q): Wrong request URL. Want %q. Got %q.\", expected.ID, u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestInspectImageNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such image\", status: http.StatusNotFound})\n\tname := \"test\"\n\timage, err := client.InspectImage(name)\n\tif image != nil {\n\t\tt.Errorf(\"InspectImage(%q): expected <nil> image, got %#v.\", name, image)\n\t}\n\tif !errors.Is(err, ErrNoSuchImage) {\n\t\tt.Errorf(\"InspectImage(%q): wrong error. Want %#v. Got %#v.\", name, ErrNoSuchImage, err)\n\t}\n}\n\nfunc TestPushImage(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"Pushing 1/100\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\terr := client.PushImage(PushImageOptions{Name: \"test\", OutputStream: &buf}, AuthConfiguration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"Pushing 1/100\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"PushImage: Wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"PushImage: Wrong HTTP method. Want POST. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/images/test/push\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"PushImage: Wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\tif query := req.URL.Query().Encode(); query != \"\" {\n\t\tt.Errorf(\"PushImage: Wrong query string. Want no parameters, got %q.\", query)\n\t}\n\n\tauthHeader, ok := req.Header[\"X-Registry-Auth\"]\n\tif ok {\n\t\tt.Errorf(\"PushImage: unexpected non-empty X-Registry-Auth header: %v\", authHeader)\n\t}\n}\n\nfunc TestPushImageWithRawJSON(t *testing.T) {\n\tt.Parallel()\n\tbody := `\n\t{\"status\":\"Pushing...\"}\n\t{\"status\":\"Pushing\", \"progress\":\"1/? (n/a)\", \"progressDetail\":{\"current\":1}}}\n\t{\"status\":\"Image successfully pushed\"}\n\t`\n\tfakeRT := &FakeRoundTripper{\n\t\tmessage: body,\n\t\tstatus:  http.StatusOK,\n\t\theader: map[string]string{\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t},\n\t}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\n\terr := client.PushImage(PushImageOptions{\n\t\tName:          \"test\",\n\t\tOutputStream:  &buf,\n\t\tRawJSONStream: true,\n\t}, AuthConfiguration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif buf.String() != body {\n\t\tt.Errorf(\"PushImage: Wrong raw output. Want %q. Got %q.\", body, buf.String())\n\t}\n}\n\nfunc TestPushImageWithAuthentication(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"Pushing 1/100\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\tinputAuth := AuthConfiguration{\n\t\tUsername: \"gopher\",\n\t\tPassword: \"gopher123\",\n\t\tEmail:    \"gopher@tsuru.io\",\n\t}\n\terr := client.PushImage(PushImageOptions{Name: \"test\", OutputStream: &buf}, inputAuth)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tvar gotAuth AuthConfiguration\n\n\tauth, err := base64.URLEncoding.DecodeString(req.Header.Get(\"X-Registry-Auth\"))\n\tif err != nil {\n\t\tt.Errorf(\"PushImage: caught error decoding auth. %#v\", err.Error())\n\t}\n\n\terr = json.Unmarshal(auth, &gotAuth)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(gotAuth, inputAuth) {\n\t\tt.Errorf(\"PushImage: wrong auth configuration. Want %#v. Got %#v.\", inputAuth, gotAuth)\n\t}\n}\n\nfunc TestPushImageCustomRegistry(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"Pushing 1/100\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar authConfig AuthConfiguration\n\tvar buf bytes.Buffer\n\topts := PushImageOptions{\n\t\tName: \"test\", Registry: \"docker.tsuru.io\",\n\t\tOutputStream: &buf,\n\t}\n\terr := client.PushImage(opts, authConfig)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedQuery := \"registry=docker.tsuru.io\"\n\tif query := req.URL.Query().Encode(); query != expectedQuery {\n\t\tt.Errorf(\"PushImage: Wrong query string. Want %q. Got %q.\", expectedQuery, query)\n\t}\n}\n\nfunc TestPushImageNoName(t *testing.T) {\n\tt.Parallel()\n\tclient := Client{}\n\terr := client.PushImage(PushImageOptions{}, AuthConfiguration{})\n\tif !errors.Is(err, ErrNoSuchImage) {\n\t\tt.Errorf(\"PushImage: got wrong error. Want %#v. Got %#v.\", ErrNoSuchImage, err)\n\t}\n}\n\nfunc TestPullImage(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"Pulling 1/100\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\terr := client.PullImage(PullImageOptions{Repository: \"base\", OutputStream: &buf},\n\t\tAuthConfiguration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"Pulling 1/100\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"PullImage: Wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"PullImage: Wrong HTTP method. Want POST. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/images/create\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"PullImage: Wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpectedQuery := \"fromImage=base\"\n\tif query := req.URL.Query().Encode(); query != expectedQuery {\n\t\tt.Errorf(\"PullImage: Wrong query strin. Want %q. Got %q.\", expectedQuery, query)\n\t}\n}\n\nfunc TestPullImageWithDigest(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"Pulling 1/100\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\terr := client.PullImage(PullImageOptions{\n\t\tRepository:   \"tsuru/bs:latest@sha256:504a2f04aa5d07768e4f7467ddd2618b07dd6013cfabca7dc527a3d9fa786580\",\n\t\tOutputStream: &buf,\n\t}, AuthConfiguration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"Pulling 1/100\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"PullImage: Wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"PullImage: Wrong HTTP method. Want POST. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/images/create\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"PullImage: Wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpectedQuery := url.Values{\n\t\t\"fromImage\": {\"tsuru/bs:latest\"},\n\t\t\"tag\":       {\"sha256:504a2f04aa5d07768e4f7467ddd2618b07dd6013cfabca7dc527a3d9fa786580\"},\n\t}\n\tif !reflect.DeepEqual(req.URL.Query(), expectedQuery) {\n\t\tt.Errorf(\"PullImage: Wrong query string\\nWant %#v\\nGot  %#v\", expectedQuery, req.URL.Query())\n\t}\n}\n\nfunc TestPullImageWithDigestAndTag(t *testing.T) {\n\t// This is probably a wrong use of the Docker API, but let's let users\n\t// send the request to the API. And also changing this behavior would\n\t// be a breaking change on go-dockerclient.\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"Pulling 1/100\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\terr := client.PullImage(PullImageOptions{\n\t\tRepository:   \"tsuru/bs:latest@sha256:504a2f04aa5d07768e4f7467ddd2618b07dd6013cfabca7dc527a3d9fa786580\",\n\t\tTag:          \"latest\",\n\t\tOutputStream: &buf,\n\t}, AuthConfiguration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"Pulling 1/100\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"PullImage: Wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"PullImage: Wrong HTTP method. Want POST. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/images/create\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"PullImage: Wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpectedQuery := url.Values{\n\t\t\"fromImage\": {\"tsuru/bs:latest@sha256:504a2f04aa5d07768e4f7467ddd2618b07dd6013cfabca7dc527a3d9fa786580\"},\n\t\t\"tag\":       {\"latest\"},\n\t}\n\tif !reflect.DeepEqual(req.URL.Query(), expectedQuery) {\n\t\tt.Errorf(\"PullImage: Wrong query string\\nWant %#vGot  %#v\", expectedQuery, req.URL.Query())\n\t}\n}\n\nfunc TestPullImageWithRawJSON(t *testing.T) {\n\tt.Parallel()\n\tbody := `\n\t{\"status\":\"Pulling...\"}\n\t{\"status\":\"Pulling\", \"progress\":\"1 B/ 100 B\", \"progressDetail\":{\"current\":1, \"total\":100}}\n\t`\n\tfakeRT := &FakeRoundTripper{\n\t\tmessage: body,\n\t\tstatus:  http.StatusOK,\n\t\theader: map[string]string{\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t},\n\t}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\terr := client.PullImage(PullImageOptions{\n\t\tRepository:    \"base\",\n\t\tOutputStream:  &buf,\n\t\tRawJSONStream: true,\n\t}, AuthConfiguration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif buf.String() != body {\n\t\tt.Errorf(\"PullImage: Wrong raw output. Want %q. Got %q\", body, buf.String())\n\t}\n}\n\nfunc TestPullImageWithoutOutputStream(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"Pulling 1/100\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := PullImageOptions{\n\t\tRepository: \"base\",\n\t\tRegistry:   \"docker.tsuru.io\",\n\t}\n\terr := client.PullImage(opts, AuthConfiguration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\"fromImage\": {\"base\"}, \"registry\": {\"docker.tsuru.io\"}}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"PullImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n}\n\nfunc TestPullImageCustomRegistry(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"Pulling 1/100\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := PullImageOptions{\n\t\tRepository:   \"base\",\n\t\tRegistry:     \"docker.tsuru.io\",\n\t\tOutputStream: &buf,\n\t}\n\terr := client.PullImage(opts, AuthConfiguration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\"fromImage\": {\"base\"}, \"registry\": {\"docker.tsuru.io\"}}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"PullImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n}\n\nfunc TestPullImageTag(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"Pulling 1/100\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := PullImageOptions{\n\t\tRepository:   \"base\",\n\t\tRegistry:     \"docker.tsuru.io\",\n\t\tTag:          \"latest\",\n\t\tOutputStream: &buf,\n\t}\n\terr := client.PullImage(opts, AuthConfiguration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\"fromImage\": {\"base\"}, \"registry\": {\"docker.tsuru.io\"}, \"tag\": {\"latest\"}}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"PullImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n}\n\nfunc TestPullImageNoRepository(t *testing.T) {\n\tt.Parallel()\n\tvar opts PullImageOptions\n\tclient := Client{}\n\terr := client.PullImage(opts, AuthConfiguration{})\n\tif !errors.Is(err, ErrNoSuchImage) {\n\t\tt.Errorf(\"PullImage: got wrong error. Want %#v. Got %#v.\", ErrNoSuchImage, err)\n\t}\n}\n\nfunc TestImportImageFromUrl(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := ImportImageOptions{\n\t\tSource:       \"http://mycompany.com/file.tar\",\n\t\tRepository:   \"testimage\",\n\t\tTag:          \"tag\",\n\t\tOutputStream: &buf,\n\t}\n\terr := client.ImportImage(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\"fromSrc\": {opts.Source}, \"repo\": {opts.Repository}, \"tag\": {opts.Tag}}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"ImportImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n}\n\nfunc TestImportImageFromInput(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tin := bytes.NewBufferString(\"tar content\")\n\tvar buf bytes.Buffer\n\topts := ImportImageOptions{\n\t\tSource: \"-\", Repository: \"testimage\",\n\t\tInputStream: in, OutputStream: &buf,\n\t\tTag: \"tag\",\n\t}\n\terr := client.ImportImage(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\"fromSrc\": {opts.Source}, \"repo\": {opts.Repository}, \"tag\": {opts.Tag}}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"ImportImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n\tbody, err := io.ReadAll(req.Body)\n\tif err != nil {\n\t\tt.Errorf(\"ImportImage: caugth error while reading body %#v\", err.Error())\n\t}\n\te := \"tar content\"\n\tif string(body) != e {\n\t\tt.Errorf(\"ImportImage: wrong body. Want %#v. Got %#v.\", e, string(body))\n\t}\n}\n\nfunc TestImportImageDoesNotPassInputIfSourceIsNotDash(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\tin := bytes.NewBufferString(\"foo\")\n\topts := ImportImageOptions{\n\t\tSource: \"http://test.com/container.tar\", Repository: \"testimage\",\n\t\tInputStream: in, OutputStream: &buf,\n\t}\n\terr := client.ImportImage(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\"fromSrc\": {opts.Source}, \"repo\": {opts.Repository}}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"ImportImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n\tbody, err := io.ReadAll(req.Body)\n\tif err != nil {\n\t\tt.Errorf(\"ImportImage: caugth error while reading body %#v\", err.Error())\n\t}\n\tif string(body) != \"\" {\n\t\tt.Errorf(\"ImportImage: wrong body. Want nothing. Got %#v.\", string(body))\n\t}\n}\n\nfunc TestImportImageShouldPassTarContentToBodyWhenSourceIsFilePath(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\ttarPath := \"testing/data/container.tar\"\n\topts := ImportImageOptions{\n\t\tSource: tarPath, Repository: \"testimage\",\n\t\tOutputStream: &buf,\n\t}\n\terr := client.ImportImage(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttar, err := os.Open(tarPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\ttarContent, err := io.ReadAll(tar)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbody, err := io.ReadAll(req.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(tarContent, body) {\n\t\tt.Errorf(\"ImportImage: wrong body. Want %#v content. Got %#v.\", tarPath, body)\n\t}\n}\n\nfunc TestImportImageShouldChangeSourceToDashWhenItsAFilePath(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\ttarPath := \"testing/data/container.tar\"\n\topts := ImportImageOptions{\n\t\tSource: tarPath, Repository: \"testimage\",\n\t\tOutputStream: &buf,\n\t}\n\terr := client.ImportImage(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\"fromSrc\": {\"-\"}, \"repo\": {opts.Repository}}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"ImportImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n}\n\nfunc TestBuildImageParameters(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := BuildImageOptions{\n\t\tName:                \"testImage\",\n\t\tNoCache:             true,\n\t\tCacheFrom:           []string{\"test1\", \"test2\"},\n\t\tSuppressOutput:      true,\n\t\tPull:                true,\n\t\tRmTmpContainer:      true,\n\t\tForceRmTmpContainer: true,\n\t\tMemory:              1024,\n\t\tMemswap:             2048,\n\t\tCPUShares:           10,\n\t\tCPUQuota:            7500,\n\t\tCPUPeriod:           100000,\n\t\tCPUSetCPUs:          \"0-3\",\n\t\tUlimits:             []ULimit{{Name: \"nofile\", Soft: 100, Hard: 200}},\n\t\tBuildArgs:           []BuildArg{{Name: \"SOME_VAR\", Value: \"some_value\"}},\n\t\tInputStream:         &buf,\n\t\tOutputStream:        &buf,\n\t\tLabels:              map[string]string{\"k\": \"v\"},\n\t\tNetworkMode:         \"host\",\n\t\tCgroupParent:        \"cgparent\",\n\t\tSecurityOpt:         []string{\"securityoptions\"},\n\t}\n\terr := client.BuildImage(opts)\n\tif err != nil && !strings.Contains(err.Error(), \"build image fail\") {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\n\t\t\"t\":            {opts.Name},\n\t\t\"nocache\":      {\"1\"},\n\t\t\"cachefrom\":    {`[\"test1\",\"test2\"]`},\n\t\t\"q\":            {\"1\"},\n\t\t\"pull\":         {\"1\"},\n\t\t\"rm\":           {\"1\"},\n\t\t\"forcerm\":      {\"1\"},\n\t\t\"memory\":       {\"1024\"},\n\t\t\"memswap\":      {\"2048\"},\n\t\t\"cpushares\":    {\"10\"},\n\t\t\"cpuquota\":     {\"7500\"},\n\t\t\"cpuperiod\":    {\"100000\"},\n\t\t\"cpusetcpus\":   {\"0-3\"},\n\t\t\"labels\":       {`{\"k\":\"v\"}`},\n\t\t\"ulimits\":      {`[{\"Name\":\"nofile\",\"Soft\":100,\"Hard\":200}]`},\n\t\t\"buildargs\":    {`{\"SOME_VAR\":\"some_value\"}`},\n\t\t\"networkmode\":  {\"host\"},\n\t\t\"cgroupparent\": {\"cgparent\"},\n\t\t\"securityopt\":  {\"securityoptions\"},\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"BuildImage: wrong query string. Want %#v.\\n Got %#v.\", expected, got)\n\t}\n\texpectedPrefix := \"http://localhost:4243/v1.25/\"\n\tif !strings.HasPrefix(req.URL.String(), expectedPrefix) {\n\t\tt.Errorf(\"BuildImage: wrong URL version Want Prefix %s.\\n Got URL: %s\", expectedPrefix, req.URL.String())\n\t}\n}\n\nfunc TestBuildImageParametersForRemoteBuild(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := BuildImageOptions{\n\t\tName:           \"testImage\",\n\t\tRemote:         \"testing/data/container.tar\",\n\t\tSuppressOutput: true,\n\t\tOutputStream:   &buf,\n\t}\n\terr := client.BuildImage(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\"t\": {opts.Name}, \"remote\": {opts.Remote}, \"q\": {\"1\"}}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"BuildImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n}\n\nfunc TestBuildImageMissingRepoAndNilInput(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := BuildImageOptions{\n\t\tName:           \"testImage\",\n\t\tSuppressOutput: true,\n\t\tOutputStream:   &buf,\n\t}\n\terr := client.BuildImage(opts)\n\tif !errors.Is(err, ErrMissingRepo) {\n\t\tt.Errorf(\"BuildImage: wrong error returned. Want %#v. Got %#v.\", ErrMissingRepo, err)\n\t}\n}\n\nfunc TestBuildImageMissingOutputStream(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := BuildImageOptions{Name: \"testImage\"}\n\terr := client.BuildImage(opts)\n\tif !errors.Is(err, ErrMissingOutputStream) {\n\t\tt.Errorf(\"BuildImage: wrong error returned. Want %#v. Got %#v.\", ErrMissingOutputStream, err)\n\t}\n}\n\nfunc TestBuildImageWithRawJSON(t *testing.T) {\n\tt.Parallel()\n\tbody := `\n\t{\"stream\":\"Step 0 : FROM ubuntu:latest\\n\"}\n\t{\"stream\":\" ---\\u003e 4300eb9d3c8d\\n\"}\n\t{\"stream\":\"Step 1 : MAINTAINER docker <eng@docker.com>\\n\"}\n\t{\"stream\":\" ---\\u003e Using cache\\n\"}\n\t{\"stream\":\" ---\\u003e 3a3ed758c370\\n\"}\n\t{\"stream\":\"Step 2 : CMD /usr/bin/top\\n\"}\n\t{\"stream\":\" ---\\u003e Running in 36b1479cc2e4\\n\"}\n\t{\"stream\":\" ---\\u003e 4b6188aebe39\\n\"}\n\t{\"stream\":\"Removing intermediate container 36b1479cc2e4\\n\"}\n\t{\"stream\":\"Successfully built 4b6188aebe39\\n\"}\n    `\n\tfakeRT := &FakeRoundTripper{\n\t\tmessage: body,\n\t\tstatus:  http.StatusOK,\n\t\theader: map[string]string{\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t},\n\t}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := BuildImageOptions{\n\t\tName:           \"testImage\",\n\t\tRmTmpContainer: true,\n\t\tInputStream:    &buf,\n\t\tOutputStream:   &buf,\n\t\tRawJSONStream:  true,\n\t}\n\terr := client.BuildImage(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif buf.String() != body {\n\t\tt.Errorf(\"BuildImage: Wrong raw output. Want %q. Got %q.\", body, buf.String())\n\t}\n}\n\nfunc TestBuildImageRemoteWithoutName(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvar buf bytes.Buffer\n\topts := BuildImageOptions{\n\t\tRemote:         \"testing/data/container.tar\",\n\t\tSuppressOutput: true,\n\t\tOutputStream:   &buf,\n\t}\n\terr := client.BuildImage(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := map[string][]string{\"t\": {opts.Remote}, \"remote\": {opts.Remote}, \"q\": {\"1\"}}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"BuildImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n}\n\nfunc TestTagImageParameters(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := TagImageOptions{Repo: \"testImage\"}\n\terr := client.TagImage(\"base\", opts)\n\tif err != nil && !strings.Contains(err.Error(), \"tag image fail\") {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpected := \"http://localhost:4243/images/base/tag?repo=testImage\"\n\tgot := req.URL.String()\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"TagImage: wrong query string. Want %#v. Got %#v.\", expected, got)\n\t}\n}\n\nfunc TestTagImageMissingRepo(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := TagImageOptions{Repo: \"testImage\"}\n\terr := client.TagImage(\"\", opts)\n\tif !errors.Is(err, ErrNoSuchImage) {\n\t\tt.Errorf(\"TestTag: wrong error returned. Want %#v. Got %#v.\",\n\t\t\tErrNoSuchImage, err)\n\t}\n}\n\nfunc TestIsUrl(t *testing.T) {\n\tt.Parallel()\n\turl := \"http://foo.bar/\"\n\tresult := isURL(url)\n\tif !result {\n\t\tt.Errorf(\"isURL: wrong match. Expected %#v to be a url. Got %#v.\", url, result)\n\t}\n\turl = \"/foo/bar.tar\"\n\tresult = isURL(url)\n\tif result {\n\t\tt.Errorf(\"isURL: wrong match. Expected %#v to not be a url. Got %#v\", url, result)\n\t}\n}\n\nfunc TestLoadImage(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\ttar, err := os.Open(\"testing/data/container.tar\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t} else {\n\t\tdefer tar.Close()\n\t}\n\topts := LoadImageOptions{InputStream: tar}\n\terr = client.LoadImage(opts)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"LoadImage: wrong method. Expected %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\tif req.URL.Path != \"/images/load\" {\n\t\tt.Errorf(\"LoadImage: wrong URL. Expected %q. Got %q.\", \"/images/load\", req.URL.Path)\n\t}\n}\n\nfunc TestExportImage(t *testing.T) {\n\tt.Parallel()\n\tvar buf bytes.Buffer\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := ExportImageOptions{Name: \"testimage\", OutputStream: &buf}\n\terr := client.ExportImage(opts)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"ExportImage: wrong method. Expected %q. Got %q.\", http.MethodGet, req.Method)\n\t}\n\texpectedPath := \"/images/testimage/get\"\n\tif req.URL.Path != expectedPath {\n\t\tt.Errorf(\"ExportIMage: wrong path. Expected %q. Got %q.\", expectedPath, req.URL.Path)\n\t}\n}\n\nfunc TestExportImages(t *testing.T) {\n\tt.Parallel()\n\tvar buf bytes.Buffer\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tclient.requestedAPIVersion = apiVersion125\n\topts := ExportImagesOptions{Names: []string{\"testimage1\", \"testimage2:latest\"}, OutputStream: &buf}\n\terr := client.ExportImages(opts)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"ExportImages: wrong method. Expected %q. Got %q.\", http.MethodGet, req.Method)\n\t}\n\texpected := \"http://localhost:4243/v1.25/images/get?names=testimage1%2Ctestimage2%3Alatest\"\n\tgot := req.URL.String()\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"ExportImages: wrong path. Expected %q. Got %q.\", expected, got)\n\t}\n\n\tclient.requestedAPIVersion = apiVersion124\n\terr = client.ExportImages(opts)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\treq = fakeRT.requests[1]\n\texpected = \"http://localhost:4243/v1.24/images/get?names=testimage1&names=testimage2%3Alatest\"\n\tgot = req.URL.String()\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"ExportImages: wrong path. Expected %q. Got %q.\", expected, got)\n\t}\n}\n\nfunc TestExportImagesNoNames(t *testing.T) {\n\tt.Parallel()\n\tvar buf bytes.Buffer\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := ExportImagesOptions{Names: []string{}, OutputStream: &buf}\n\terr := client.ExportImages(opts)\n\tif err == nil {\n\t\tt.Error(\"Expected an error\")\n\t}\n\tif !errors.Is(err, ErrMustSpecifyNames) {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSearchImages(t *testing.T) {\n\tt.Parallel()\n\tbody := `[\n\t{\n\t\t\"description\":\"A container with Cassandra 2.0.3\",\n\t\t\"is_official\":true,\n\t\t\"is_automated\":true,\n\t\t\"name\":\"poklet/cassandra\",\n\t\t\"star_count\":17\n\t},\n\t{\n\t\t\"description\":\"A container with Cassandra 2.0.3\",\n\t\t\"is_official\":true,\n\t\t\"is_automated\":false,\n\t\t\"name\":\"poklet/cassandra\",\n\t\t\"star_count\":17\n\t}\n\t,\n\t{\n\t\t\"description\":\"A container with Cassandra 2.0.3\",\n\t\t\"is_official\":false,\n\t\t\"is_automated\":true,\n\t\t\"name\":\"poklet/cassandra\",\n\t\t\"star_count\":17\n\t}\n]`\n\tvar expected []APIImageSearch\n\terr := json.Unmarshal([]byte(body), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: body, status: http.StatusOK})\n\tresult, err := client.SearchImages(\"cassandra\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"SearchImages: Wrong return value. Want %#v. Got %#v.\", expected, result)\n\t}\n}\n\nfunc TestSearchImagesEx(t *testing.T) {\n\tt.Parallel()\n\tbody := `[\n\t{\n\t\t\"description\":\"A container with Cassandra 2.0.3\",\n\t\t\"is_official\":true,\n\t\t\"is_automated\":true,\n\t\t\"name\":\"poklet/cassandra\",\n\t\t\"star_count\":17\n\t},\n\t{\n\t\t\"description\":\"A container with Cassandra 2.0.3\",\n\t\t\"is_official\":true,\n\t\t\"is_automated\":false,\n\t\t\"name\":\"poklet/cassandra\",\n\t\t\"star_count\":17\n\t}\n\t,\n\t{\n\t\t\"description\":\"A container with Cassandra 2.0.3\",\n\t\t\"is_official\":false,\n\t\t\"is_automated\":true,\n\t\t\"name\":\"poklet/cassandra\",\n\t\t\"star_count\":17\n\t}\n]`\n\tvar expected []APIImageSearch\n\terr := json.Unmarshal([]byte(body), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: body, status: http.StatusOK})\n\tauth := AuthConfiguration{}\n\tresult, err := client.SearchImagesEx(\"cassandra\", auth)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"SearchImages: Wrong return value. Want %#v. Got %#v.\", expected, result)\n\t}\n}\n\nfunc TestPruneImages(t *testing.T) {\n\tt.Parallel()\n\tresults := `{\n\t\t\"ImagesDeleted\": [\n\t\t\t{\"Deleted\": \"a\"},\n\t\t\t{\"Deleted\": \"b\"},\n\t\t\t{\"Deleted\": \"c\"}\n\t\t],\n\t\t\"SpaceReclaimed\": 123\n\t}`\n\n\texpected := &PruneImagesResults{}\n\terr := json.Unmarshal([]byte(results), expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: results, status: http.StatusOK})\n\tgot, err := client.PruneImages(PruneImagesOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"PruneImages: Expected %#v. Got %#v.\", expected, got)\n\t}\n}\n"
        },
        {
          "name": "integration_test.go",
          "type": "blob",
          "size": 2.162109375,
          "content": "// Copyright 2015 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build docker_integration\n\npackage docker\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestIntegrationPullCreateStartLogs(t *testing.T) {\n\timageName := pullImage(t)\n\tclient, err := NewClientFromEnv()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\thostConfig := HostConfig{PublishAllPorts: true}\n\tcreateOpts := integrationCreateContainerOpts(imageName, &hostConfig)\n\tcontainer, err := client.CreateContainer(createOpts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = client.StartContainer(container.ID, &hostConfig)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tstatus, err := client.WaitContainer(container.ID)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif status != 0 {\n\t\tt.Errorf(\"WaitContainer(%q): wrong status. Want 0. Got %d\", container.ID, status)\n\t}\n\tvar stdout, stderr bytes.Buffer\n\tlogsOpts := LogsOptions{\n\t\tContainer:    container.ID,\n\t\tOutputStream: &stdout,\n\t\tErrorStream:  &stderr,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t}\n\terr = client.Logs(logsOpts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif stderr.String() != \"\" {\n\t\tt.Errorf(\"Got unexpected stderr from logs: %q\", stderr.String())\n\t}\n\t// split stdout by lines to make sure the test is the same on Windows\n\t// and Linux. Life is hard.\n\texpected := []string{\n\t\t\"hello hello\",\n\t}\n\tif stdoutLines := getLines(&stdout); !reflect.DeepEqual(stdoutLines, expected) {\n\t\tt.Errorf(\"Got wrong stdout from logs.\\nWant:\\n%#v.\\n\\nGot:\\n%#v.\", expected, stdoutLines)\n\t}\n}\n\nfunc getLines(buf *bytes.Buffer) []string {\n\tvar lines []string\n\tfor _, line := range strings.Split(buf.String(), \"\\n\") {\n\t\tline = strings.TrimSpace(line)\n\t\tif line != \"\" {\n\t\t\tlines = append(lines, line)\n\t\t}\n\t}\n\treturn lines\n}\n\nfunc pullImage(t *testing.T) string {\n\timageName := integrationDockerImage\n\tvar buf bytes.Buffer\n\tpullOpts := PullImageOptions{\n\t\tRepository:   imageName,\n\t\tOutputStream: &buf,\n\t}\n\tclient, err := NewClientFromEnv()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = client.PullImage(pullOpts, AuthConfiguration{})\n\tif err != nil {\n\t\tt.Logf(\"Pull output: %s\", buf.String())\n\t\tt.Fatal(err)\n\t}\n\treturn imageName\n}\n"
        },
        {
          "name": "integration_unix_test.go",
          "type": "blob",
          "size": 0.5283203125,
          "content": "// Copyright 2019 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build docker_integration && !windows\n\npackage docker\n\nconst integrationDockerImage = \"alpine:latest\"\n\nfunc integrationCreateContainerOpts(imageName string, hostConfig *HostConfig) CreateContainerOptions {\n\treturn CreateContainerOptions{\n\t\tConfig: &Config{\n\t\t\tImage: imageName,\n\t\t\tCmd:   []string{\"sh\", \"-c\", `echo \"hello hello\"`},\n\t\t},\n\t\tHostConfig: hostConfig,\n\t}\n}\n"
        },
        {
          "name": "integration_windows_test.go",
          "type": "blob",
          "size": 0.5673828125,
          "content": "// Copyright 2019 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build docker_integration\n\npackage docker\n\nconst integrationDockerImage = \"mcr.microsoft.com/windows/servercore:ltsc2022\"\n\nfunc integrationCreateContainerOpts(imageName string, hostConfig *HostConfig) CreateContainerOptions {\n\treturn CreateContainerOptions{\n\t\tConfig: &Config{\n\t\t\tImage: imageName,\n\t\t\tCmd:   []string{\"powershell\", \"-Command\", `Write-Host \"hello hello\"`},\n\t\t},\n\t\tHostConfig: hostConfig,\n\t}\n}\n"
        },
        {
          "name": "misc.go",
          "type": "blob",
          "size": 5.3173828125,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\n// Version returns version information about the docker server.\n//\n// See https://goo.gl/mU7yje for more details.\nfunc (c *Client) Version() (*Env, error) {\n\treturn c.VersionWithContext(context.TODO())\n}\n\n// VersionWithContext returns version information about the docker server.\nfunc (c *Client) VersionWithContext(ctx context.Context) (*Env, error) {\n\tresp, err := c.do(http.MethodGet, \"/version\", doOptions{context: ctx})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar env Env\n\tif err := env.Decode(resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &env, nil\n}\n\n// DockerInfo contains information about the Docker server\n//\n// See https://goo.gl/bHUoz9 for more details.\ntype DockerInfo struct {\n\tID                 string\n\tContainers         int\n\tContainersRunning  int\n\tContainersPaused   int\n\tContainersStopped  int\n\tImages             int\n\tDriver             string\n\tDriverStatus       [][2]string\n\tSystemStatus       [][2]string\n\tPlugins            PluginsInfo\n\tNFd                int\n\tNGoroutines        int\n\tSystemTime         string\n\tExecutionDriver    string\n\tLoggingDriver      string\n\tCgroupDriver       string\n\tNEventsListener    int\n\tKernelVersion      string\n\tOperatingSystem    string\n\tOSType             string\n\tArchitecture       string\n\tIndexServerAddress string\n\tRegistryConfig     *ServiceConfig\n\tSecurityOptions    []string\n\tNCPU               int\n\tMemTotal           int64\n\tDockerRootDir      string\n\tHTTPProxy          string `json:\"HttpProxy\"`\n\tHTTPSProxy         string `json:\"HttpsProxy\"`\n\tNoProxy            string\n\tName               string\n\tLabels             []string\n\tServerVersion      string\n\tClusterStore       string\n\tRuntimes           map[string]Runtime\n\tClusterAdvertise   string\n\tIsolation          string\n\tInitBinary         string\n\tDefaultRuntime     string\n\tSwarm              swarm.Info\n\tLiveRestoreEnabled bool\n\tMemoryLimit        bool\n\tSwapLimit          bool\n\tKernelMemory       bool\n\tCPUCfsPeriod       bool `json:\"CpuCfsPeriod\"`\n\tCPUCfsQuota        bool `json:\"CpuCfsQuota\"`\n\tCPUShares          bool\n\tCPUSet             bool\n\tIPv4Forwarding     bool\n\tBridgeNfIptables   bool\n\tBridgeNfIP6tables  bool `json:\"BridgeNfIp6tables\"`\n\tDebug              bool\n\tOomKillDisable     bool\n\tExperimentalBuild  bool\n}\n\n// Runtime describes an OCI runtime\n//\n// for more information, see: https://dockr.ly/2NKM8qq\ntype Runtime struct {\n\tPath string\n\tArgs []string `json:\"runtimeArgs\"`\n}\n\n// PluginsInfo is a struct with the plugins registered with the docker daemon\n//\n// for more information, see: https://goo.gl/bHUoz9\ntype PluginsInfo struct {\n\t// List of Volume plugins registered\n\tVolume []string\n\t// List of Network plugins registered\n\tNetwork []string\n\t// List of Authorization plugins registered\n\tAuthorization []string\n}\n\n// ServiceConfig stores daemon registry services configuration.\n//\n// for more information, see: https://goo.gl/7iFFDz\ntype ServiceConfig struct {\n\tInsecureRegistryCIDRs []*NetIPNet\n\tIndexConfigs          map[string]*IndexInfo\n\tMirrors               []string\n}\n\n// NetIPNet is the net.IPNet type, which can be marshalled and\n// unmarshalled to JSON.\n//\n// for more information, see: https://goo.gl/7iFFDz\ntype NetIPNet net.IPNet\n\n// MarshalJSON returns the JSON representation of the IPNet.\nfunc (ipnet *NetIPNet) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal((*net.IPNet)(ipnet).String())\n}\n\n// UnmarshalJSON sets the IPNet from a byte array of JSON.\nfunc (ipnet *NetIPNet) UnmarshalJSON(b []byte) (err error) {\n\tvar ipnetStr string\n\tif err = json.Unmarshal(b, &ipnetStr); err == nil {\n\t\tvar cidr *net.IPNet\n\t\tif _, cidr, err = net.ParseCIDR(ipnetStr); err == nil {\n\t\t\t*ipnet = NetIPNet(*cidr)\n\t\t}\n\t}\n\treturn\n}\n\n// IndexInfo contains information about a registry.\n//\n// for more information, see: https://goo.gl/7iFFDz\ntype IndexInfo struct {\n\tName     string\n\tMirrors  []string\n\tSecure   bool\n\tOfficial bool\n}\n\n// Info returns system-wide information about the Docker server.\n//\n// See https://goo.gl/ElTHi2 for more details.\nfunc (c *Client) Info() (*DockerInfo, error) {\n\tresp, err := c.do(http.MethodGet, \"/info\", doOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar info DockerInfo\n\tif err := json.NewDecoder(resp.Body).Decode(&info); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &info, nil\n}\n\n// ParseRepositoryTag gets the name of the repository and returns it splitted\n// in two parts: the repository and the tag. It ignores the digest when it is\n// present.\n//\n// Some examples:\n//\n//\tlocalhost.localdomain:5000/samalba/hipache:latest -> localhost.localdomain:5000/samalba/hipache, latest\n//\tlocalhost.localdomain:5000/samalba/hipache -> localhost.localdomain:5000/samalba/hipache, \"\"\n//\tbusybox:latest@sha256:4a731fb46adc5cefe3ae374a8b6020fc1b6ad667a279647766e9a3cd89f6fa92 -> busybox, latest\nfunc ParseRepositoryTag(repoTag string) (repository string, tag string) {\n\tparts := strings.SplitN(repoTag, \"@\", 2)\n\trepoTag = parts[0]\n\tn := strings.LastIndex(repoTag, \":\")\n\tif n < 0 {\n\t\treturn repoTag, \"\"\n\t}\n\tif tag := repoTag[n+1:]; !strings.Contains(tag, \"/\") {\n\t\treturn repoTag[:n], tag\n\t}\n\treturn repoTag, \"\"\n}\n"
        },
        {
          "name": "misc_test.go",
          "type": "blob",
          "size": 5.6279296875,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype DockerVersion struct {\n\tVersion   string\n\tGitCommit string\n\tGoVersion string\n}\n\nfunc TestVersion(t *testing.T) {\n\tt.Parallel()\n\tbody := `{\n     \"Version\":\"0.2.2\",\n     \"GitCommit\":\"5a2a5cc+CHANGES\",\n     \"GoVersion\":\"go1.0.3\"\n}`\n\tfakeRT := FakeRoundTripper{message: body, status: http.StatusOK}\n\tclient := newTestClient(&fakeRT)\n\texpected := DockerVersion{\n\t\tVersion:   \"0.2.2\",\n\t\tGitCommit: \"5a2a5cc+CHANGES\",\n\t\tGoVersion: \"go1.0.3\",\n\t}\n\tversion, err := client.Version()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif result := version.Get(\"Version\"); result != expected.Version {\n\t\tt.Errorf(\"Version(): Wrong result. Want %#v. Got %#v.\", expected.Version, version.Get(\"Version\"))\n\t}\n\tif result := version.Get(\"GitCommit\"); result != expected.GitCommit {\n\t\tt.Errorf(\"GitCommit(): Wrong result. Want %#v. Got %#v.\", expected.GitCommit, version.Get(\"GitCommit\"))\n\t}\n\tif result := version.Get(\"GoVersion\"); result != expected.GoVersion {\n\t\tt.Errorf(\"GoVersion(): Wrong result. Want %#v. Got %#v.\", expected.GoVersion, version.Get(\"GoVersion\"))\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"Version(): wrong request method. Want GET. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/version\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"Version(): wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestVersionError(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"internal error\", status: http.StatusInternalServerError}\n\tclient := newTestClient(fakeRT)\n\tversion, err := client.Version()\n\tif version != nil {\n\t\tt.Errorf(\"Version(): expected <nil> value, got %#v.\", version)\n\t}\n\tif err == nil {\n\t\tt.Error(\"Version(): unexpected <nil> error\")\n\t}\n}\n\nfunc TestInfo(t *testing.T) {\n\tt.Parallel()\n\tbody := `{\n     \"Containers\":11,\n     \"Images\":16,\n     \"Debug\":false,\n     \"NFd\":11,\n     \"NGoroutines\":21,\n     \"MemoryLimit\":true,\n     \"SwapLimit\":false,\n     \"RegistryConfig\":{\n       \"InsecureRegistryCIDRs\":[\"127.0.0.0/8\"],\n       \"IndexConfigs\":{\n         \"docker.io\":{\n           \"Name\":\"docker.io\",\n           \"Mirrors\":null,\n           \"Secure\":true,\n           \"Official\":true\n         }\n       },\n       \"Mirrors\":null\n     },\n     \"SecurityOptions\": [\n     \t\"name=apparmor\",\n     \t\"name=seccomp\",\n     \t\"profile=default\"\n     ],\n\t \"Runtimes\": {\n\t\t\"runc\": {\n\t\t  \"path\": \"docker-runc\"\n\t\t},\n\t\t\"custom\": {\n\t\t  \"path\": \"/usr/local/bin/my-oci-runtime\",\n\t\t  \"runtimeArgs\": [\n\t\t    \"--debug\",\n\t\t    \"--systemd-cgroup=false\"\n\t\t    ]\n\t\t  }\n\t  }\n}`\n\tfakeRT := FakeRoundTripper{message: body, status: http.StatusOK}\n\tclient := newTestClient(&fakeRT)\n\texpected := &DockerInfo{\n\t\tContainers:  11,\n\t\tImages:      16,\n\t\tDebug:       false,\n\t\tNFd:         11,\n\t\tNGoroutines: 21,\n\t\tMemoryLimit: true,\n\t\tSwapLimit:   false,\n\t\tRegistryConfig: &ServiceConfig{\n\t\t\tInsecureRegistryCIDRs: []*NetIPNet{\n\t\t\t\t{\n\t\t\t\t\tMask: net.CIDRMask(8, 32),\n\t\t\t\t\tIP:   net.ParseIP(\"127.0.0.0\").To4(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tIndexConfigs: map[string]*IndexInfo{\n\t\t\t\t\"docker.io\": {\n\t\t\t\t\tName:     \"docker.io\",\n\t\t\t\t\tSecure:   true,\n\t\t\t\t\tOfficial: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tSecurityOptions: []string{\n\t\t\t\"name=apparmor\",\n\t\t\t\"name=seccomp\",\n\t\t\t\"profile=default\",\n\t\t},\n\t\tRuntimes: map[string]Runtime{\n\t\t\t\"runc\": {\n\t\t\t\tPath: \"docker-runc\",\n\t\t\t},\n\t\t\t\"custom\": {\n\t\t\t\tPath: \"/usr/local/bin/my-oci-runtime\",\n\t\t\t\tArgs: []string{\n\t\t\t\t\t\"--debug\",\n\t\t\t\t\t\"--systemd-cgroup=false\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tinfo, err := client.Info()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(expected, info) {\n\t\tt.Errorf(\"Info(): Wrong result.\\nWant %#v.\\nGot %#v.\", expected, info)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"Info(): Wrong HTTP method. Want GET. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/info\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"Info(): Wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestInfoError(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"internal error\", status: http.StatusInternalServerError}\n\tclient := newTestClient(fakeRT)\n\tversion, err := client.Info()\n\tif version != nil {\n\t\tt.Errorf(\"Info(): expected <nil> value, got %#v.\", version)\n\t}\n\tif err == nil {\n\t\tt.Error(\"Info(): unexpected <nil> error\")\n\t}\n}\n\nfunc TestParseRepositoryTag(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedRepo string\n\t\texpectedTag  string\n\t}{\n\t\t{\n\t\t\t\"localhost.localdomain:5000/samalba/hipache:latest\",\n\t\t\t\"localhost.localdomain:5000/samalba/hipache\",\n\t\t\t\"latest\",\n\t\t},\n\t\t{\n\t\t\t\"localhost.localdomain:5000/samalba/hipache\",\n\t\t\t\"localhost.localdomain:5000/samalba/hipache\",\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"tsuru/python\",\n\t\t\t\"tsuru/python\",\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"tsuru/python:2.7\",\n\t\t\t\"tsuru/python\",\n\t\t\t\"2.7\",\n\t\t},\n\t\t{\n\t\t\t\"busybox@sha256:4a731fb46adc5cefe3ae374a8b6020fc1b6ad667a279647766e9a3cd89f6fa92\",\n\t\t\t\"busybox\",\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"localhost.localdomain:5000/samalba/hipache:v1@sha256:4a731fb46adc5cefe3ae374a8b6020fc1b6ad667a279647766e9a3cd89f6fa92\",\n\t\t\t\"localhost.localdomain:5000/samalba/hipache\",\n\t\t\t\"v1\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttest := tt\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trepo, tag := ParseRepositoryTag(test.input)\n\t\t\tif repo != test.expectedRepo {\n\t\t\t\tt.Errorf(\"ParseRepositoryTag(%q): wrong repository. Want %q. Got %q\", test.input, test.expectedRepo, repo)\n\t\t\t}\n\t\t\tif tag != test.expectedTag {\n\t\t\t\tt.Errorf(\"ParseRepositoryTag(%q): wrong tag. Want %q. Got %q\", test.input, test.expectedTag, tag)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "network.go",
          "type": "blob",
          "size": 11.171875,
          "content": "// Copyright 2015 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// ErrNetworkAlreadyExists is the error returned by CreateNetwork when the\n// network already exists.\nvar ErrNetworkAlreadyExists = errors.New(\"network already exists\")\n\n// Network represents a network.\n//\n// See https://goo.gl/6GugX3 for more details.\ntype Network struct {\n\tName       string\n\tID         string `json:\"Id\"`\n\tScope      string\n\tDriver     string\n\tIPAM       IPAMOptions\n\tContainers map[string]Endpoint\n\tOptions    map[string]string\n\tInternal   bool\n\tEnableIPv6 bool `json:\"EnableIPv6\"`\n\tLabels     map[string]string\n}\n\n// Endpoint contains network resources allocated and used for a container in a network\n//\n// See https://goo.gl/6GugX3 for more details.\ntype Endpoint struct {\n\tName        string\n\tID          string `json:\"EndpointID\"`\n\tMacAddress  string\n\tIPv4Address string\n\tIPv6Address string\n}\n\n// ListNetworks returns all networks.\n//\n// See https://goo.gl/6GugX3 for more details.\nfunc (c *Client) ListNetworks() ([]Network, error) {\n\tresp, err := c.do(http.MethodGet, \"/networks\", doOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar networks []Network\n\tif err := json.NewDecoder(resp.Body).Decode(&networks); err != nil {\n\t\treturn nil, err\n\t}\n\treturn networks, nil\n}\n\n// NetworkFilterOpts is an aggregation of key=value that Docker\n// uses to filter networks\ntype NetworkFilterOpts map[string]map[string]bool\n\n// FilteredListNetworks returns all networks with the filters applied\n//\n// See goo.gl/zd2mx4 for more details.\nfunc (c *Client) FilteredListNetworks(opts NetworkFilterOpts) ([]Network, error) {\n\tparams, err := json.Marshal(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tqs := make(url.Values)\n\tqs.Add(\"filters\", string(params))\n\tpath := \"/networks?\" + qs.Encode()\n\tresp, err := c.do(http.MethodGet, path, doOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar networks []Network\n\tif err := json.NewDecoder(resp.Body).Decode(&networks); err != nil {\n\t\treturn nil, err\n\t}\n\treturn networks, nil\n}\n\n// NetworkInfo returns information about a network by its ID.\n//\n// See https://goo.gl/6GugX3 for more details.\nfunc (c *Client) NetworkInfo(id string) (*Network, error) {\n\tpath := \"/networks/\" + id\n\tresp, err := c.do(http.MethodGet, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchNetwork{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar network Network\n\tif err := json.NewDecoder(resp.Body).Decode(&network); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &network, nil\n}\n\n// CreateNetworkOptions specify parameters to the CreateNetwork function and\n// (for now) is the expected body of the \"create network\" http request message\n//\n// See https://goo.gl/6GugX3 for more details.\ntype CreateNetworkOptions struct {\n\tName           string             `json:\"Name\" yaml:\"Name\" toml:\"Name\"`\n\tDriver         string             `json:\"Driver\" yaml:\"Driver\" toml:\"Driver\"`\n\tScope          string             `json:\"Scope\" yaml:\"Scope\" toml:\"Scope\"`\n\tIPAM           *IPAMOptions       `json:\"IPAM,omitempty\" yaml:\"IPAM\" toml:\"IPAM\"`\n\tConfigFrom     *NetworkConfigFrom `json:\"ConfigFrom,omitempty\" yaml:\"ConfigFrom\" toml:\"ConfigFrom\"`\n\tOptions        map[string]any     `json:\"Options\" yaml:\"Options\" toml:\"Options\"`\n\tLabels         map[string]string  `json:\"Labels\" yaml:\"Labels\" toml:\"Labels\"`\n\tCheckDuplicate bool               `json:\"CheckDuplicate\" yaml:\"CheckDuplicate\" toml:\"CheckDuplicate\"`\n\tInternal       bool               `json:\"Internal\" yaml:\"Internal\" toml:\"Internal\"`\n\tEnableIPv6     bool               `json:\"EnableIPv6\" yaml:\"EnableIPv6\" toml:\"EnableIPv6\"`\n\tAttachable     bool               `json:\"Attachable\" yaml:\"Attachable\" toml:\"Attachable\"`\n\tConfigOnly     bool               `json:\"ConfigOnly\" yaml:\"ConfigOnly\" toml:\"ConfigOnly\"`\n\tIngress        bool               `json:\"Ingress\" yaml:\"Ingress\" toml:\"Ingress\"`\n\tContext        context.Context    `json:\"-\"`\n}\n\n// NetworkConfigFrom is used in network creation for specifying the source of a\n// network configuration.\ntype NetworkConfigFrom struct {\n\tNetwork string `json:\"Network\" yaml:\"Network\" toml:\"Network\"`\n}\n\n// IPAMOptions controls IP Address Management when creating a network\n//\n// See https://goo.gl/T8kRVH for more details.\ntype IPAMOptions struct {\n\tDriver  string            `json:\"Driver\" yaml:\"Driver\" toml:\"Driver\"`\n\tConfig  []IPAMConfig      `json:\"Config\" yaml:\"Config\" toml:\"Config\"`\n\tOptions map[string]string `json:\"Options\" yaml:\"Options\" toml:\"Options\"`\n}\n\n// IPAMConfig represents IPAM configurations\n//\n// See https://goo.gl/T8kRVH for more details.\ntype IPAMConfig struct {\n\tSubnet     string            `json:\",omitempty\"`\n\tIPRange    string            `json:\",omitempty\"`\n\tGateway    string            `json:\",omitempty\"`\n\tAuxAddress map[string]string `json:\"AuxiliaryAddresses,omitempty\"`\n}\n\n// CreateNetwork creates a new network, returning the network instance,\n// or an error in case of failure.\n//\n// See https://goo.gl/6GugX3 for more details.\nfunc (c *Client) CreateNetwork(opts CreateNetworkOptions) (*Network, error) {\n\tresp, err := c.do(\n\t\thttp.MethodPost,\n\t\t\"/networks/create\",\n\t\tdoOptions{\n\t\t\tdata:    opts,\n\t\t\tcontext: opts.Context,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\ttype createNetworkResponse struct {\n\t\tID string\n\t}\n\tvar (\n\t\tnetwork Network\n\t\tcnr     createNetworkResponse\n\t)\n\tif err := json.NewDecoder(resp.Body).Decode(&cnr); err != nil {\n\t\treturn nil, err\n\t}\n\n\tnetwork.Name = opts.Name\n\tnetwork.ID = cnr.ID\n\tnetwork.Driver = opts.Driver\n\n\treturn &network, nil\n}\n\n// RemoveNetwork removes a network or returns an error in case of failure.\n//\n// See https://goo.gl/6GugX3 for more details.\nfunc (c *Client) RemoveNetwork(id string) error {\n\tresp, err := c.do(http.MethodDelete, \"/networks/\"+id, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchNetwork{ID: id}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// NetworkConnectionOptions specify parameters to the ConnectNetwork and\n// DisconnectNetwork function.\n//\n// See https://goo.gl/RV7BJU for more details.\ntype NetworkConnectionOptions struct {\n\tContainer string\n\n\t// EndpointConfig is only applicable to the ConnectNetwork call\n\tEndpointConfig *EndpointConfig `json:\"EndpointConfig,omitempty\"`\n\n\t// Force is only applicable to the DisconnectNetwork call\n\tForce bool\n\n\tContext context.Context `json:\"-\"`\n}\n\n// EndpointConfig stores network endpoint details\n//\n// See https://goo.gl/RV7BJU for more details.\ntype EndpointConfig struct {\n\tIPAMConfig          *EndpointIPAMConfig `json:\"IPAMConfig,omitempty\" yaml:\"IPAMConfig,omitempty\" toml:\"IPAMConfig,omitempty\"`\n\tLinks               []string            `json:\"Links,omitempty\" yaml:\"Links,omitempty\" toml:\"Links,omitempty\"`\n\tAliases             []string            `json:\"Aliases,omitempty\" yaml:\"Aliases,omitempty\" toml:\"Aliases,omitempty\"`\n\tNetworkID           string              `json:\"NetworkID,omitempty\" yaml:\"NetworkID,omitempty\" toml:\"NetworkID,omitempty\"`\n\tEndpointID          string              `json:\"EndpointID,omitempty\" yaml:\"EndpointID,omitempty\" toml:\"EndpointID,omitempty\"`\n\tGateway             string              `json:\"Gateway,omitempty\" yaml:\"Gateway,omitempty\" toml:\"Gateway,omitempty\"`\n\tIPAddress           string              `json:\"IPAddress,omitempty\" yaml:\"IPAddress,omitempty\" toml:\"IPAddress,omitempty\"`\n\tIPPrefixLen         int                 `json:\"IPPrefixLen,omitempty\" yaml:\"IPPrefixLen,omitempty\" toml:\"IPPrefixLen,omitempty\"`\n\tIPv6Gateway         string              `json:\"IPv6Gateway,omitempty\" yaml:\"IPv6Gateway,omitempty\" toml:\"IPv6Gateway,omitempty\"`\n\tGlobalIPv6Address   string              `json:\"GlobalIPv6Address,omitempty\" yaml:\"GlobalIPv6Address,omitempty\" toml:\"GlobalIPv6Address,omitempty\"`\n\tGlobalIPv6PrefixLen int                 `json:\"GlobalIPv6PrefixLen,omitempty\" yaml:\"GlobalIPv6PrefixLen,omitempty\" toml:\"GlobalIPv6PrefixLen,omitempty\"`\n\tMacAddress          string              `json:\"MacAddress,omitempty\" yaml:\"MacAddress,omitempty\" toml:\"MacAddress,omitempty\"`\n\tDriverOpts          map[string]string   `json:\"DriverOpts,omitempty\" yaml:\"DriverOpts,omitempty\" toml:\"DriverOpts,omitempty\"`\n}\n\n// EndpointIPAMConfig represents IPAM configurations for an\n// endpoint\n//\n// See https://goo.gl/RV7BJU for more details.\ntype EndpointIPAMConfig struct {\n\tIPv4Address string `json:\",omitempty\" yaml:\"IPv4Address,omitempty\"`\n\tIPv6Address string `json:\",omitempty\" yaml:\"IPv6Address,omitempty\"`\n}\n\n// ConnectNetwork adds a container to a network or returns an error in case of\n// failure.\n//\n// See https://goo.gl/6GugX3 for more details.\nfunc (c *Client) ConnectNetwork(id string, opts NetworkConnectionOptions) error {\n\tresp, err := c.do(http.MethodPost, \"/networks/\"+id+\"/connect\", doOptions{\n\t\tdata:    opts,\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchNetworkOrContainer{NetworkID: id, ContainerID: opts.Container}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// DisconnectNetwork removes a container from a network or returns an error in\n// case of failure.\n//\n// See https://goo.gl/6GugX3 for more details.\nfunc (c *Client) DisconnectNetwork(id string, opts NetworkConnectionOptions) error {\n\tresp, err := c.do(http.MethodPost, \"/networks/\"+id+\"/disconnect\", doOptions{data: opts})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchNetworkOrContainer{NetworkID: id, ContainerID: opts.Container}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// PruneNetworksOptions specify parameters to the PruneNetworks function.\n//\n// See https://goo.gl/kX0S9h for more details.\ntype PruneNetworksOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// PruneNetworksResults specify results from the PruneNetworks function.\n//\n// See https://goo.gl/kX0S9h for more details.\ntype PruneNetworksResults struct {\n\tNetworksDeleted []string\n}\n\n// PruneNetworks deletes networks which are unused.\n//\n// See https://goo.gl/kX0S9h for more details.\nfunc (c *Client) PruneNetworks(opts PruneNetworksOptions) (*PruneNetworksResults, error) {\n\tpath := \"/networks/prune?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar results PruneNetworksResults\n\tif err := json.NewDecoder(resp.Body).Decode(&results); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &results, nil\n}\n\n// NoSuchNetwork is the error returned when a given network does not exist.\ntype NoSuchNetwork struct {\n\tID string\n}\n\nfunc (err *NoSuchNetwork) Error() string {\n\treturn fmt.Sprintf(\"No such network: %s\", err.ID)\n}\n\n// NoSuchNetworkOrContainer is the error returned when a given network or\n// container does not exist.\ntype NoSuchNetworkOrContainer struct {\n\tNetworkID   string\n\tContainerID string\n}\n\nfunc (err *NoSuchNetworkOrContainer) Error() string {\n\treturn fmt.Sprintf(\"No such network (%s) or container (%s)\", err.NetworkID, err.ContainerID)\n}\n"
        },
        {
          "name": "network_test.go",
          "type": "blob",
          "size": 8.4267578125,
          "content": "// Copyright 2015 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListNetworks(t *testing.T) {\n\tt.Parallel()\n\tjsonNetworks := `[\n     {\n             \"ID\": \"8dfafdbc3a40\",\n             \"Name\": \"blah\",\n             \"Type\": \"bridge\",\n             \"Endpoints\":[{\"ID\": \"918c11c8288a\", \"Name\": \"dsafdsaf\", \"Network\": \"8dfafdbc3a40\"}]\n     },\n     {\n             \"ID\": \"9fb1e39c\",\n             \"Name\": \"foo\",\n             \"Type\": \"bridge\",\n             \"Endpoints\":[{\"ID\": \"c080be979dda\", \"Name\": \"lllll2222\", \"Network\": \"9fb1e39c\"}]\n     }\n]`\n\tvar expected []Network\n\terr := json.Unmarshal([]byte(jsonNetworks), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: jsonNetworks, status: http.StatusOK})\n\tcontainers, err := client.ListNetworks()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(containers, expected) {\n\t\tt.Errorf(\"ListNetworks: Expected %#v. Got %#v.\", expected, containers)\n\t}\n}\n\nfunc TestFilteredListNetworks(t *testing.T) {\n\tt.Parallel()\n\tjsonNetworks := `[\n     {\n             \"ID\": \"9fb1e39c\",\n             \"Name\": \"foo\",\n             \"Type\": \"bridge\",\n             \"Endpoints\":[{\"ID\": \"c080be979dda\", \"Name\": \"lllll2222\", \"Network\": \"9fb1e39c\"}]\n     }\n]`\n\tvar expected []Network\n\terr := json.Unmarshal([]byte(jsonNetworks), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twantQuery := url.Values{\n\t\t\"filters\": []string{`{\"name\":{\"blah\":true}}`},\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonNetworks, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := NetworkFilterOpts{\n\t\t\"name\": map[string]bool{\"blah\": true},\n\t}\n\tcontainers, err := client.FilteredListNetworks(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(containers, expected) {\n\t\tt.Errorf(\"ListNetworks: Expected %#v. Got %#v.\", expected, containers)\n\t}\n\tquery := fakeRT.requests[0].URL.Query()\n\tif !reflect.DeepEqual(query, wantQuery) {\n\t\tt.Errorf(\"FilteredListNetworks: wrong query\\nWant %#v\\nGot  %#v\", wantQuery, query)\n\t}\n}\n\nfunc TestNetworkInfo(t *testing.T) {\n\tt.Parallel()\n\tjsonNetwork := `{\n             \"ID\": \"8dfafdbc3a40\",\n             \"Name\": \"blah\",\n             \"Type\": \"bridge\",\n             \"Endpoints\":[{\"ID\": \"918c11c8288a\", \"Name\": \"dsafdsaf\", \"Network\": \"8dfafdbc3a40\"}]\n        }`\n\tvar expected Network\n\terr := json.Unmarshal([]byte(jsonNetwork), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonNetwork, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"8dfafdbc3a40\"\n\tnetwork, err := client.NetworkInfo(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*network, expected) {\n\t\tt.Errorf(\"NetworkInfo(%q): Expected %#v. Got %#v.\", id, expected, network)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/networks/8dfafdbc3a40\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"NetworkInfo(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestNetworkCreate(t *testing.T) {\n\tjsonID := `{\"ID\": \"8dfafdbc3a40\"}`\n\tjsonNetwork := `{\n             \"ID\": \"8dfafdbc3a40\",\n             \"Name\": \"foobar\",\n             \"Driver\": \"bridge\"\n        }`\n\tvar expected Network\n\terr := json.Unmarshal([]byte(jsonNetwork), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tclient := newTestClient(&FakeRoundTripper{message: jsonID, status: http.StatusOK})\n\topts := CreateNetworkOptions{Name: \"foobar\", Driver: \"bridge\"}\n\tnetwork, err := client.CreateNetwork(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !reflect.DeepEqual(*network, expected) {\n\t\tt.Errorf(\"CreateNetwork: Expected %#v. Got %#v.\", expected, network)\n\t}\n}\n\nfunc TestNetworkRemove(t *testing.T) {\n\tt.Parallel()\n\tid := \"8dfafdbc3a40\"\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\terr := client.RemoveNetwork(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodDelete\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"RemoveNetwork(%q): Wrong HTTP method. Want %s. Got %s.\", id, expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/networks/\" + id))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"RemoveNetwork(%q): Wrong request path. Want %q. Got %q.\", id, u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestNetworkConnect(t *testing.T) {\n\tt.Parallel()\n\tid := \"8dfafdbc3a40\"\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\topts := NetworkConnectionOptions{Container: \"foobar\"}\n\terr := client.ConnectNetwork(id, opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodPost\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"ConnectNetwork(%q): Wrong HTTP method. Want %s. Got %s.\", id, expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/networks/\" + id + \"/connect\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"ConnectNetwork(%q): Wrong request path. Want %q. Got %q.\", id, u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestNetworkConnectWithEndpoint(t *testing.T) {\n\tt.Parallel()\n\twantJSON := `{\"Container\":\"foobar\",\"EndpointConfig\":{\"IPAMConfig\":{\"IPv4Address\":\"8.8.8.8\"},\"Links\":null,\"Aliases\":null},\"Force\":false}`\n\tvar wantObj NetworkConnectionOptions\n\tjson.NewDecoder(bytes.NewBuffer([]byte(wantJSON))).Decode(&wantObj)\n\tid := \"8dfafdbc3a40\"\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\topts := NetworkConnectionOptions{\n\t\tContainer: \"foobar\",\n\t\tEndpointConfig: &EndpointConfig{\n\t\t\tIPAMConfig: &EndpointIPAMConfig{\n\t\t\t\tIPv4Address: \"8.8.8.8\",\n\t\t\t},\n\t\t},\n\t}\n\terr := client.ConnectNetwork(id, opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodPost\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"ConnectNetwork(%q): Wrong HTTP method. Want %s. Got %s.\", id, expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/networks/\" + id + \"/connect\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"ConnectNetwork(%q): Wrong request path. Want %q. Got %q.\", id, u.Path, req.URL.Path)\n\t}\n\tvar in NetworkConnectionOptions\n\tif err := json.NewDecoder(req.Body).Decode(&in); err != nil {\n\t\tt.Errorf(\"ConnectNetwork: error parsing JSON data sent: %q\", err)\n\t}\n\tif !reflect.DeepEqual(in, wantObj) {\n\t\tt.Errorf(\"ConnectNetwork: wanted %#v send, got: %#v\", wantObj, in)\n\t}\n}\n\nfunc TestNetworkConnectNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such network container\", status: http.StatusNotFound})\n\topts := NetworkConnectionOptions{Container: \"foobar\"}\n\terr := client.ConnectNetwork(\"8dfafdbc3a40\", opts)\n\tvar serr *NoSuchNetworkOrContainer\n\tif !errors.As(err, &serr) {\n\t\tt.Errorf(\"ConnectNetwork: wrong error type: %s.\", serr)\n\t}\n}\n\nfunc TestNetworkDisconnect(t *testing.T) {\n\tt.Parallel()\n\tid := \"8dfafdbc3a40\"\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\topts := NetworkConnectionOptions{Container: \"foobar\"}\n\terr := client.DisconnectNetwork(id, opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodPost\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"DisconnectNetwork(%q): Wrong HTTP method. Want %s. Got %s.\", id, expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/networks/\" + id + \"/disconnect\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"DisconnectNetwork(%q): Wrong request path. Want %q. Got %q.\", id, u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestNetworkDisconnectNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such network container\", status: http.StatusNotFound})\n\topts := NetworkConnectionOptions{Container: \"foobar\"}\n\terr := client.DisconnectNetwork(\"8dfafdbc3a40\", opts)\n\tvar serr *NoSuchNetworkOrContainer\n\tif !errors.As(err, &serr) {\n\t\tt.Errorf(\"DisconnectNetwork: wrong error type: %s.\", serr)\n\t}\n}\n\nfunc TestPruneNetworks(t *testing.T) {\n\tt.Parallel()\n\tresults := `{\n\t\t\"NetworksDeleted\": [\n\t\t\t\"a\", \"b\", \"c\"\n\t\t]\n\t}`\n\n\texpected := &PruneNetworksResults{}\n\terr := json.Unmarshal([]byte(results), expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: results, status: http.StatusOK})\n\tgot, err := client.PruneNetworks(PruneNetworksOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"PruneNetworks: Expected %#v. Got %#v.\", expected, got)\n\t}\n}\n"
        },
        {
          "name": "plugin.go",
          "type": "blob",
          "size": 14.626953125,
          "content": "// Copyright 2018 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// PluginPrivilege represents a privilege for a plugin.\ntype PluginPrivilege struct {\n\tName        string   `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tDescription string   `json:\"Description,omitempty\" yaml:\"Description,omitempty\" toml:\"Description,omitempty\"`\n\tValue       []string `json:\"Value,omitempty\" yaml:\"Value,omitempty\" toml:\"Value,omitempty\"`\n}\n\n// InstallPluginOptions specify parameters to the InstallPlugins function.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype InstallPluginOptions struct {\n\tRemote  string\n\tName    string\n\tPlugins []PluginPrivilege `qs:\"-\"`\n\n\tAuth AuthConfiguration\n\n\tContext context.Context\n}\n\n// InstallPlugins installs a plugin or returns an error in case of failure.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) InstallPlugins(opts InstallPluginOptions) error {\n\theaders, err := headersWithAuth(opts.Auth)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpath := \"/plugins/pull?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\tdata:    opts.Plugins,\n\t\tcontext: opts.Context,\n\t\theaders: headers,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\t// PullPlugin streams back the progress of the pull, we must consume the whole body\n\t// otherwise the pull will be canceled on the engine.\n\tif _, err := io.ReadAll(resp.Body); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// PluginSettings stores plugin settings.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginSettings struct {\n\tEnv     []string `json:\"Env,omitempty\" yaml:\"Env,omitempty\" toml:\"Env,omitempty\"`\n\tArgs    []string `json:\"Args,omitempty\" yaml:\"Args,omitempty\" toml:\"Args,omitempty\"`\n\tDevices []string `json:\"Devices,omitempty\" yaml:\"Devices,omitempty\" toml:\"Devices,omitempty\"`\n}\n\n// PluginInterface stores plugin interface.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginInterface struct {\n\tTypes  []string `json:\"Types,omitempty\" yaml:\"Types,omitempty\" toml:\"Types,omitempty\"`\n\tSocket string   `json:\"Socket,omitempty\" yaml:\"Socket,omitempty\" toml:\"Socket,omitempty\"`\n}\n\n// PluginNetwork stores plugin network type.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginNetwork struct {\n\tType string `json:\"Type,omitempty\" yaml:\"Type,omitempty\" toml:\"Type,omitempty\"`\n}\n\n// PluginLinux stores plugin linux setting.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginLinux struct {\n\tCapabilities    []string             `json:\"Capabilities,omitempty\" yaml:\"Capabilities,omitempty\" toml:\"Capabilities,omitempty\"`\n\tAllowAllDevices bool                 `json:\"AllowAllDevices,omitempty\" yaml:\"AllowAllDevices,omitempty\" toml:\"AllowAllDevices,omitempty\"`\n\tDevices         []PluginLinuxDevices `json:\"Devices,omitempty\" yaml:\"Devices,omitempty\" toml:\"Devices,omitempty\"`\n}\n\n// PluginLinuxDevices stores plugin linux device setting.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginLinuxDevices struct {\n\tName        string   `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tDescription string   `json:\"Documentation,omitempty\" yaml:\"Documentation,omitempty\" toml:\"Documentation,omitempty\"`\n\tSettable    []string `json:\"Settable,omitempty\" yaml:\"Settable,omitempty\" toml:\"Settable,omitempty\"`\n\tPath        string   `json:\"Path,omitempty\" yaml:\"Path,omitempty\" toml:\"Path,omitempty\"`\n}\n\n// PluginEnv stores plugin environment.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginEnv struct {\n\tName        string   `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tDescription string   `json:\"Description,omitempty\" yaml:\"Description,omitempty\" toml:\"Description,omitempty\"`\n\tSettable    []string `json:\"Settable,omitempty\" yaml:\"Settable,omitempty\" toml:\"Settable,omitempty\"`\n\tValue       string   `json:\"Value,omitempty\" yaml:\"Value,omitempty\" toml:\"Value,omitempty\"`\n}\n\n// PluginArgs stores plugin arguments.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginArgs struct {\n\tName        string   `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tDescription string   `json:\"Description,omitempty\" yaml:\"Description,omitempty\" toml:\"Description,omitempty\"`\n\tSettable    []string `json:\"Settable,omitempty\" yaml:\"Settable,omitempty\" toml:\"Settable,omitempty\"`\n\tValue       []string `json:\"Value,omitempty\" yaml:\"Value,omitempty\" toml:\"Value,omitempty\"`\n}\n\n// PluginUser stores plugin user.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginUser struct {\n\tUID int32 `json:\"UID,omitempty\" yaml:\"UID,omitempty\" toml:\"UID,omitempty\"`\n\tGID int32 `json:\"GID,omitempty\" yaml:\"GID,omitempty\" toml:\"GID,omitempty\"`\n}\n\n// PluginConfig stores plugin config.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginConfig struct {\n\tDescription     string `json:\"Description,omitempty\" yaml:\"Description,omitempty\" toml:\"Description,omitempty\"`\n\tDocumentation   string\n\tInterface       PluginInterface `json:\"Interface,omitempty\" yaml:\"Interface,omitempty\" toml:\"Interface,omitempty\"`\n\tEntrypoint      []string        `json:\"Entrypoint,omitempty\" yaml:\"Entrypoint,omitempty\" toml:\"Entrypoint,omitempty\"`\n\tWorkDir         string          `json:\"WorkDir,omitempty\" yaml:\"WorkDir,omitempty\" toml:\"WorkDir,omitempty\"`\n\tUser            PluginUser      `json:\"User,omitempty\" yaml:\"User,omitempty\" toml:\"User,omitempty\"`\n\tNetwork         PluginNetwork   `json:\"Network,omitempty\" yaml:\"Network,omitempty\" toml:\"Network,omitempty\"`\n\tLinux           PluginLinux     `json:\"Linux,omitempty\" yaml:\"Linux,omitempty\" toml:\"Linux,omitempty\"`\n\tPropagatedMount string          `json:\"PropagatedMount,omitempty\" yaml:\"PropagatedMount,omitempty\" toml:\"PropagatedMount,omitempty\"`\n\tMounts          []Mount         `json:\"Mounts,omitempty\" yaml:\"Mounts,omitempty\" toml:\"Mounts,omitempty\"`\n\tEnv             []PluginEnv     `json:\"Env,omitempty\" yaml:\"Env,omitempty\" toml:\"Env,omitempty\"`\n\tArgs            PluginArgs      `json:\"Args,omitempty\" yaml:\"Args,omitempty\" toml:\"Args,omitempty\"`\n}\n\n// PluginDetail specify results from the ListPlugins function.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PluginDetail struct {\n\tID       string         `json:\"Id,omitempty\" yaml:\"Id,omitempty\" toml:\"Id,omitempty\"`\n\tName     string         `json:\"Name,omitempty\" yaml:\"Name,omitempty\" toml:\"Name,omitempty\"`\n\tTag      string         `json:\"Tag,omitempty\" yaml:\"Tag,omitempty\" toml:\"Tag,omitempty\"`\n\tActive   bool           `json:\"Enabled,omitempty\" yaml:\"Active,omitempty\" toml:\"Active,omitempty\"`\n\tSettings PluginSettings `json:\"Settings,omitempty\" yaml:\"Settings,omitempty\" toml:\"Settings,omitempty\"`\n\tConfig   PluginConfig   `json:\"Config,omitempty\" yaml:\"Config,omitempty\" toml:\"Config,omitempty\"`\n}\n\n// ListPlugins returns pluginDetails or an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) ListPlugins(ctx context.Context) ([]PluginDetail, error) {\n\tresp, err := c.do(http.MethodGet, \"/plugins\", doOptions{\n\t\tcontext: ctx,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tpluginDetails := make([]PluginDetail, 0)\n\tif err := json.NewDecoder(resp.Body).Decode(&pluginDetails); err != nil {\n\t\treturn nil, err\n\t}\n\treturn pluginDetails, nil\n}\n\n// ListFilteredPluginsOptions specify parameters to the ListFilteredPlugins function.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype ListFilteredPluginsOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// ListFilteredPlugins returns pluginDetails or an error.\n//\n// See https://goo.gl/rmdmWg for more details.\nfunc (c *Client) ListFilteredPlugins(opts ListFilteredPluginsOptions) ([]PluginDetail, error) {\n\tpath := \"/plugins/json?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tpluginDetails := make([]PluginDetail, 0)\n\tif err := json.NewDecoder(resp.Body).Decode(&pluginDetails); err != nil {\n\t\treturn nil, err\n\t}\n\treturn pluginDetails, nil\n}\n\n// GetPluginPrivileges returns pluginPrivileges or an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) GetPluginPrivileges(remote string, ctx context.Context) ([]PluginPrivilege, error) {\n\treturn c.GetPluginPrivilegesWithOptions(\n\t\tGetPluginPrivilegesOptions{\n\t\t\tRemote:  remote,\n\t\t\tContext: ctx,\n\t\t})\n}\n\n// GetPluginPrivilegesOptions specify parameters to the GetPluginPrivilegesWithOptions function.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype GetPluginPrivilegesOptions struct {\n\tRemote  string\n\tAuth    AuthConfiguration\n\tContext context.Context\n}\n\n// GetPluginPrivilegesWithOptions returns pluginPrivileges or an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) GetPluginPrivilegesWithOptions(opts GetPluginPrivilegesOptions) ([]PluginPrivilege, error) {\n\theaders, err := headersWithAuth(opts.Auth)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpath := \"/plugins/privileges?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{\n\t\tcontext: opts.Context,\n\t\theaders: headers,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar pluginPrivileges []PluginPrivilege\n\tif err := json.NewDecoder(resp.Body).Decode(&pluginPrivileges); err != nil {\n\t\treturn nil, err\n\t}\n\treturn pluginPrivileges, nil\n}\n\n// InspectPlugins returns a pluginDetail or an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) InspectPlugins(name string, ctx context.Context) (*PluginDetail, error) {\n\tresp, err := c.do(http.MethodGet, \"/plugins/\"+name+\"/json\", doOptions{\n\t\tcontext: ctx,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchPlugin{ID: name}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar pluginDetail PluginDetail\n\tif err := json.NewDecoder(resp.Body).Decode(&pluginDetail); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pluginDetail, nil\n}\n\n// RemovePluginOptions specify parameters to the RemovePlugin function.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype RemovePluginOptions struct {\n\t// The Name of the plugin.\n\tName string `qs:\"-\"`\n\n\tForce   bool `qs:\"force\"`\n\tContext context.Context\n}\n\n// RemovePlugin returns a PluginDetail or an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) RemovePlugin(opts RemovePluginOptions) (*PluginDetail, error) {\n\tpath := \"/plugins/\" + opts.Name + \"?\" + queryString(opts)\n\tresp, err := c.do(http.MethodDelete, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchPlugin{ID: opts.Name}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(body) == 0 {\n\t\t// Seems like newer docker versions won't return the plugindetail after removal\n\t\treturn nil, nil\n\t}\n\n\tvar pluginDetail PluginDetail\n\tif err := json.Unmarshal(body, &pluginDetail); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pluginDetail, nil\n}\n\n// EnablePluginOptions specify parameters to the EnablePlugin function.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype EnablePluginOptions struct {\n\t// The Name of the plugin.\n\tName    string `qs:\"-\"`\n\tTimeout int64  `qs:\"timeout\"`\n\n\tContext context.Context\n}\n\n// EnablePlugin enables plugin that opts point or returns an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) EnablePlugin(opts EnablePluginOptions) error {\n\tpath := \"/plugins/\" + opts.Name + \"/enable?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// DisablePluginOptions specify parameters to the DisablePlugin function.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype DisablePluginOptions struct {\n\t// The Name of the plugin.\n\tName string `qs:\"-\"`\n\n\tContext context.Context\n}\n\n// DisablePlugin disables plugin that opts point or returns an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) DisablePlugin(opts DisablePluginOptions) error {\n\tpath := \"/plugins/\" + opts.Name + \"/disable\"\n\tresp, err := c.do(http.MethodPost, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// CreatePluginOptions specify parameters to the CreatePlugin function.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype CreatePluginOptions struct {\n\t// The Name of the plugin.\n\tName string `qs:\"name\"`\n\t// Path to tar containing plugin\n\tPath string `qs:\"-\"`\n\n\tContext context.Context\n}\n\n// CreatePlugin creates plugin that opts point or returns an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) CreatePlugin(opts CreatePluginOptions) (string, error) {\n\tpath := \"/plugins/create?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\tdata:    opts.Path,\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tcontainerNameBytes, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(containerNameBytes), nil\n}\n\n// PushPluginOptions specify parameters to PushPlugin function.\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype PushPluginOptions struct {\n\t// The Name of the plugin.\n\tName string\n\n\tContext context.Context\n}\n\n// PushPlugin pushes plugin that opts point or returns an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) PushPlugin(opts PushPluginOptions) error {\n\tpath := \"/plugins/\" + opts.Name + \"/push\"\n\tresp, err := c.do(http.MethodPost, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// ConfigurePluginOptions specify parameters to the ConfigurePlugin\n//\n// See https://goo.gl/C4t7Tz for more details.\ntype ConfigurePluginOptions struct {\n\t// The Name of the plugin.\n\tName string `qs:\"name\"`\n\tEnvs []string\n\n\tContext context.Context\n}\n\n// ConfigurePlugin configures plugin that opts point or returns an error.\n//\n// See https://goo.gl/C4t7Tz for more details.\nfunc (c *Client) ConfigurePlugin(opts ConfigurePluginOptions) error {\n\tpath := \"/plugins/\" + opts.Name + \"/set\"\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\tdata:    opts.Envs,\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchPlugin{ID: opts.Name}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// NoSuchPlugin is the error returned when a given plugin does not exist.\ntype NoSuchPlugin struct {\n\tID  string\n\tErr error\n}\n\nfunc (err *NoSuchPlugin) Error() string {\n\tif err.Err != nil {\n\t\treturn err.Err.Error()\n\t}\n\treturn \"No such plugin: \" + err.ID\n}\n"
        },
        {
          "name": "plugin_test.go",
          "type": "blob",
          "size": 9.6162109375,
          "content": "// Copyright 2018 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar expectPluginDetail = PluginDetail{\n\tID:     \"5724e2c8652da337ab2eedd19fc6fc0ec908e4bd907c7421bf6a8dfc70c4c078\",\n\tName:   \"tiborvass/sample-volume-plugin\",\n\tTag:    \"latest\",\n\tActive: true,\n\tSettings: PluginSettings{\n\t\tEnv:     []string{\"DEBUG=0\"},\n\t\tArgs:    nil,\n\t\tDevices: nil,\n\t},\n\tConfig: PluginConfig{\n\t\tDescription:   \"A sample volume plugin for Docker\",\n\t\tDocumentation: \"https://docs.docker.com/engine/extend/plugins/\",\n\t\tInterface: PluginInterface{\n\t\t\tTypes:  []string{\"docker.volumedriver/1.0\"},\n\t\t\tSocket: \"plugins.sock\",\n\t\t},\n\t\tEntrypoint: []string{\n\t\t\t\"/usr/bin/sample-volume-plugin\",\n\t\t\t\"/data\",\n\t\t},\n\t\tWorkDir:         \"\",\n\t\tUser:            PluginUser{},\n\t\tNetwork:         PluginNetwork{Type: \"\"},\n\t\tLinux:           PluginLinux{Capabilities: nil, AllowAllDevices: false, Devices: nil},\n\t\tMounts:          nil,\n\t\tPropagatedMount: \"/data\",\n\t\tEnv: []PluginEnv{\n\t\t\t{\n\t\t\t\tName:        \"DEBUG\",\n\t\t\t\tDescription: \"If set, prints debug messages\",\n\t\t\t\tSettable:    nil,\n\t\t\t\tValue:       \"0\",\n\t\t\t},\n\t\t},\n\t\tArgs: PluginArgs{\n\t\t\tName:        \"args\",\n\t\t\tDescription: \"command line arguments\",\n\t\t\tSettable:    nil,\n\t\t\tValue:       []string{},\n\t\t},\n\t},\n}\n\nconst jsonPluginDetail = `{\n    \"Id\": \"5724e2c8652da337ab2eedd19fc6fc0ec908e4bd907c7421bf6a8dfc70c4c078\",\n    \"Name\": \"tiborvass/sample-volume-plugin\",\n    \"Tag\": \"latest\",\n    \"Enabled\": true,\n    \"Settings\": {\n      \"Env\": [\n        \"DEBUG=0\"\n      ],\n      \"Args\": null,\n      \"Devices\": null\n    },\n    \"Config\": {\n      \"Description\": \"A sample volume plugin for Docker\",\n      \"Documentation\": \"https://docs.docker.com/engine/extend/plugins/\",\n      \"Interface\": {\n        \"Types\": [\n          \"docker.volumedriver/1.0\"\n        ],\n        \"Socket\": \"plugins.sock\"\n      },\n      \"Entrypoint\": [\n        \"/usr/bin/sample-volume-plugin\",\n        \"/data\"\n      ],\n      \"WorkDir\": \"\",\n      \"User\": {},\n      \"Network\": {\n        \"Type\": \"\"\n      },\n      \"Linux\": {\n        \"Capabilities\": null,\n        \"AllowAllDevices\": false,\n        \"Devices\": null\n      },\n      \"Mounts\": null,\n      \"PropagatedMount\": \"/data\",\n      \"Env\": [\n        {\n          \"Name\": \"DEBUG\",\n          \"Description\": \"If set, prints debug messages\",\n          \"Settable\": null,\n          \"Value\": \"0\"\n        }\n      ],\n      \"Args\": {\n        \"Name\": \"args\",\n        \"Description\": \"command line arguments\",\n        \"Settable\": null,\n        \"Value\": []\n      }\n    }\n  }`\n\nfunc TestListPlugins(t *testing.T) {\n\tt.Parallel()\n\tjsonPlugins := fmt.Sprintf(\"[%s]\", jsonPluginDetail)\n\tvar expected []PluginDetail\n\terr := json.Unmarshal([]byte(jsonPlugins), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: jsonPlugins, status: http.StatusOK})\n\tpluginDetails, err := client.ListPlugins(context.Background())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(pluginDetails, expected) {\n\t\tt.Errorf(\"ListPlugins: Expected %#v. Got %#v.\", expected, pluginDetails)\n\t}\n}\n\nfunc TestListFilteredPlugins(t *testing.T) {\n\tt.Parallel()\n\tjsonPlugins := fmt.Sprintf(\"[%s]\", jsonPluginDetail)\n\tvar expected []PluginDetail\n\terr := json.Unmarshal([]byte(jsonPlugins), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: jsonPlugins, status: http.StatusOK})\n\n\tpluginDetails, err := client.ListFilteredPlugins(\n\t\tListFilteredPluginsOptions{\n\t\t\tFilters: map[string][]string{\n\t\t\t\t\"capability\": {\"volumedriver\"},\n\t\t\t\t\"enabled\":    {\"true\"},\n\t\t\t},\n\t\t\tContext: context.Background(),\n\t\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(pluginDetails, expected) {\n\t\tt.Errorf(\"ListPlugins: Expected %#v. Got %#v.\", expected, pluginDetails)\n\t}\n}\n\nfunc TestListFilteredPluginsFailure(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tstatus  int\n\t\tmessage string\n\t}{\n\t\t{400, \"bad parameter\"},\n\t\t{500, \"internal server error\"},\n\t}\n\tfor _, tt := range tests {\n\t\tclient := newTestClient(&FakeRoundTripper{message: tt.message, status: tt.status})\n\t\texpected := Error{Status: tt.status, Message: tt.message}\n\t\tpluginDetails, err := client.ListFilteredPlugins(ListFilteredPluginsOptions{})\n\t\tif !reflect.DeepEqual(expected, *err.(*Error)) {\n\t\t\tt.Errorf(\"Wrong error in ListFilteredPlugins. Want %#v. Got %#v.\", expected, err)\n\t\t}\n\t\tif len(pluginDetails) > 0 {\n\t\t\tt.Errorf(\"ListFilteredPlugins failure. Expected empty list. Got %#v.\", pluginDetails)\n\t\t}\n\t}\n}\n\nfunc TestGetPluginPrivileges(t *testing.T) {\n\tt.Parallel()\n\tname := \"test_plugin\"\n\tjsonPluginPrivileges := `[ { \"Name\": \"network\", \"Description\": \"\", \"Value\": [ \"host\" ] }]`\n\tfakeRT := &FakeRoundTripper{message: jsonPluginPrivileges, status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\texpected := []PluginPrivilege{\n\t\t{\n\t\t\tName:        \"network\",\n\t\t\tDescription: \"\",\n\t\t\tValue:       []string{\"host\"},\n\t\t},\n\t}\n\tpluginPrivileges, err := client.GetPluginPrivileges(name, context.Background())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(pluginPrivileges, expected) {\n\t\tt.Errorf(\"PluginPrivileges: Expected %#v. Got %#v.\", expected, pluginPrivileges)\n\t}\n}\n\nfunc TestGetPluginPrivilegesWithOptions(t *testing.T) {\n\tt.Parallel()\n\tremote := \"test_plugin\"\n\tjsonPluginPrivileges := `[ { \"Name\": \"network\", \"Description\": \"\", \"Value\": [ \"host\" ] }]`\n\tfakeRT := &FakeRoundTripper{message: jsonPluginPrivileges, status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\texpected := []PluginPrivilege{\n\t\t{\n\t\t\tName:        \"network\",\n\t\t\tDescription: \"\",\n\t\t\tValue:       []string{\"host\"},\n\t\t},\n\t}\n\tpluginPrivileges, err := client.GetPluginPrivilegesWithOptions(GetPluginPrivilegesOptions{\n\t\tRemote:  remote,\n\t\tContext: context.Background(),\n\t\tAuth:    AuthConfiguration{Username: \"XY\"},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(pluginPrivileges, expected) {\n\t\tt.Errorf(\"PluginPrivileges: Expected %#v. Got %#v.\", expected, pluginPrivileges)\n\t}\n\treq := fakeRT.requests[0]\n\tauthHeader := req.Header.Get(\"X-Registry-Auth\")\n\tif authHeader == \"\" {\n\t\tt.Errorf(\"InstallImage: unexpected empty X-Registry-Auth header: %v\", authHeader)\n\t}\n}\n\nfunc TestInstallPlugins(t *testing.T) {\n\topts := InstallPluginOptions{\n\t\tRemote: \"\", Name: \"test\",\n\t\tPlugins: []PluginPrivilege{\n\t\t\t{\n\t\t\t\tName:        \"network\",\n\t\t\t\tDescription: \"\",\n\t\t\t\tValue:       []string{\"host\"},\n\t\t\t},\n\t\t},\n\t\tContext: context.Background(),\n\t\tAuth:    AuthConfiguration{Username: \"XY\"},\n\t}\n\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\terr := client.InstallPlugins(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq := fakeRT.requests[0]\n\tauthHeader := req.Header.Get(\"X-Registry-Auth\")\n\tif authHeader == \"\" {\n\t\tt.Errorf(\"InstallImage: unexpected empty X-Registry-Auth header: %v\", authHeader)\n\t}\n}\n\nfunc TestInspectPlugin(t *testing.T) {\n\tname := \"test_plugin\"\n\tfakeRT := &FakeRoundTripper{message: jsonPluginDetail, status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tpluginPrivileges, err := client.InspectPlugins(name, context.Background())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(pluginPrivileges, &expectPluginDetail) {\n\t\tt.Errorf(\"InspectPlugins: Expected %#v. Got %#v.\", &expectPluginDetail, pluginPrivileges)\n\t}\n}\n\nfunc TestRemovePlugin(t *testing.T) {\n\topts := RemovePluginOptions{\n\t\tName:    \"test_plugin\",\n\t\tForce:   false,\n\t\tContext: context.Background(),\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonPluginDetail, status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tpluginPrivileges, err := client.RemovePlugin(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(pluginPrivileges, &expectPluginDetail) {\n\t\tt.Errorf(\"RemovePlugin: Expected %#v. Got %#v.\", &expectPluginDetail, pluginPrivileges)\n\t}\n}\n\nfunc TestRemovePluginNoResponse(t *testing.T) {\n\topts := RemovePluginOptions{\n\t\tName:    \"test_plugin\",\n\t\tForce:   false,\n\t\tContext: context.Background(),\n\t}\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tplugindetails, err := client.RemovePlugin(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif plugindetails != nil {\n\t\tt.Errorf(\"RemovePlugin: Expected %#v. Got %#v.\", nil, plugindetails)\n\t}\n}\n\nfunc TestEnablePlugin(t *testing.T) {\n\topts := EnablePluginOptions{\n\t\tName:    \"test\",\n\t\tTimeout: 5,\n\t\tContext: context.Background(),\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusOK})\n\terr := client.EnablePlugin(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDisablePlugin(t *testing.T) {\n\topts := DisablePluginOptions{\n\t\tName:    \"test\",\n\t\tContext: context.Background(),\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusOK})\n\terr := client.DisablePlugin(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestCreatePlugin(t *testing.T) {\n\topts := CreatePluginOptions{\n\t\tName:    \"test\",\n\t\tPath:    \"\",\n\t\tContext: context.Background(),\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusOK})\n\t_, err := client.CreatePlugin(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestPushPlugin(t *testing.T) {\n\topts := PushPluginOptions{\n\t\tName:    \"test\",\n\t\tContext: context.Background(),\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusOK})\n\terr := client.PushPlugin(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestConfigurePlugin(t *testing.T) {\n\topts := ConfigurePluginOptions{\n\t\tName:    \"test\",\n\t\tEnvs:    []string{},\n\t\tContext: context.Background(),\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusOK})\n\terr := client.ConfigurePlugin(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "registry_auth.go",
          "type": "blob",
          "size": 0.2470703125,
          "content": "// Copyright 2013 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\ntype registryAuth interface {\n\tisEmpty() bool\n\theaderKey() string\n}\n"
        },
        {
          "name": "signal.go",
          "type": "blob",
          "size": 1.2607421875,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\n// Signal represents a signal that can be send to the container on\n// KillContainer call.\ntype Signal int\n\n// These values represent all signals available on Linux, where containers will\n// be running.\nconst (\n\tSIGABRT   = Signal(0x6)\n\tSIGALRM   = Signal(0xe)\n\tSIGBUS    = Signal(0x7)\n\tSIGCHLD   = Signal(0x11)\n\tSIGCLD    = Signal(0x11)\n\tSIGCONT   = Signal(0x12)\n\tSIGFPE    = Signal(0x8)\n\tSIGHUP    = Signal(0x1)\n\tSIGILL    = Signal(0x4)\n\tSIGINT    = Signal(0x2)\n\tSIGIO     = Signal(0x1d)\n\tSIGIOT    = Signal(0x6)\n\tSIGKILL   = Signal(0x9)\n\tSIGPIPE   = Signal(0xd)\n\tSIGPOLL   = Signal(0x1d)\n\tSIGPROF   = Signal(0x1b)\n\tSIGPWR    = Signal(0x1e)\n\tSIGQUIT   = Signal(0x3)\n\tSIGSEGV   = Signal(0xb)\n\tSIGSTKFLT = Signal(0x10)\n\tSIGSTOP   = Signal(0x13)\n\tSIGSYS    = Signal(0x1f)\n\tSIGTERM   = Signal(0xf)\n\tSIGTRAP   = Signal(0x5)\n\tSIGTSTP   = Signal(0x14)\n\tSIGTTIN   = Signal(0x15)\n\tSIGTTOU   = Signal(0x16)\n\tSIGUNUSED = Signal(0x1f)\n\tSIGURG    = Signal(0x17)\n\tSIGUSR1   = Signal(0xa)\n\tSIGUSR2   = Signal(0xc)\n\tSIGVTALRM = Signal(0x1a)\n\tSIGWINCH  = Signal(0x1c)\n\tSIGXCPU   = Signal(0x18)\n\tSIGXFSZ   = Signal(0x19)\n)\n"
        },
        {
          "name": "swarm.go",
          "type": "blob",
          "size": 4.546875,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\nvar (\n\t// ErrNodeAlreadyInSwarm is the error returned by InitSwarm and JoinSwarm\n\t// when the node is already part of a Swarm.\n\tErrNodeAlreadyInSwarm = errors.New(\"node already in a Swarm\")\n\n\t// ErrNodeNotInSwarm is the error returned by LeaveSwarm and UpdateSwarm\n\t// when the node is not part of a Swarm.\n\tErrNodeNotInSwarm = errors.New(\"node is not in a Swarm\")\n)\n\n// InitSwarmOptions specify parameters to the InitSwarm function.\n// See https://goo.gl/hzkgWu for more details.\ntype InitSwarmOptions struct {\n\tswarm.InitRequest\n\tContext context.Context\n}\n\n// InitSwarm initializes a new Swarm and returns the node ID.\n// See https://goo.gl/ZWyG1M for more details.\nfunc (c *Client) InitSwarm(opts InitSwarmOptions) (string, error) {\n\tpath := \"/swarm/init\"\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\tdata:      opts.InitRequest,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && (e.Status == http.StatusNotAcceptable || e.Status == http.StatusServiceUnavailable) {\n\t\t\treturn \"\", ErrNodeAlreadyInSwarm\n\t\t}\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tvar response string\n\tif err := json.NewDecoder(resp.Body).Decode(&response); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn response, nil\n}\n\n// JoinSwarmOptions specify parameters to the JoinSwarm function.\n// See https://goo.gl/TdhJWU for more details.\ntype JoinSwarmOptions struct {\n\tswarm.JoinRequest\n\tContext context.Context\n}\n\n// JoinSwarm joins an existing Swarm.\n// See https://goo.gl/N59IP1 for more details.\nfunc (c *Client) JoinSwarm(opts JoinSwarmOptions) error {\n\tpath := \"/swarm/join\"\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\tdata:      opts.JoinRequest,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && (e.Status == http.StatusNotAcceptable || e.Status == http.StatusServiceUnavailable) {\n\t\t\treturn ErrNodeAlreadyInSwarm\n\t\t}\n\t}\n\tresp.Body.Close()\n\treturn err\n}\n\n// LeaveSwarmOptions specify parameters to the LeaveSwarm function.\n// See https://goo.gl/UWDlLg for more details.\ntype LeaveSwarmOptions struct {\n\tForce   bool\n\tContext context.Context\n}\n\n// LeaveSwarm leaves a Swarm.\n// See https://goo.gl/FTX1aD for more details.\nfunc (c *Client) LeaveSwarm(opts LeaveSwarmOptions) error {\n\tparams := make(url.Values)\n\tparams.Set(\"force\", strconv.FormatBool(opts.Force))\n\tpath := \"/swarm/leave?\" + params.Encode()\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && (e.Status == http.StatusNotAcceptable || e.Status == http.StatusServiceUnavailable) {\n\t\t\treturn ErrNodeNotInSwarm\n\t\t}\n\t}\n\tresp.Body.Close()\n\treturn err\n}\n\n// UpdateSwarmOptions specify parameters to the UpdateSwarm function.\n// See https://goo.gl/vFbq36 for more details.\ntype UpdateSwarmOptions struct {\n\tVersion            int\n\tRotateWorkerToken  bool\n\tRotateManagerToken bool\n\tSwarm              swarm.Spec\n\tContext            context.Context\n}\n\n// UpdateSwarm updates a Swarm.\n// See https://goo.gl/iJFnsw for more details.\nfunc (c *Client) UpdateSwarm(opts UpdateSwarmOptions) error {\n\tparams := make(url.Values)\n\tparams.Set(\"version\", strconv.Itoa(opts.Version))\n\tparams.Set(\"rotateWorkerToken\", strconv.FormatBool(opts.RotateWorkerToken))\n\tparams.Set(\"rotateManagerToken\", strconv.FormatBool(opts.RotateManagerToken))\n\tpath := \"/swarm/update?\" + params.Encode()\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\tdata:      opts.Swarm,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && (e.Status == http.StatusNotAcceptable || e.Status == http.StatusServiceUnavailable) {\n\t\t\treturn ErrNodeNotInSwarm\n\t\t}\n\t}\n\tresp.Body.Close()\n\treturn err\n}\n\n// InspectSwarm inspects a Swarm.\n// See https://goo.gl/MFwgX9 for more details.\nfunc (c *Client) InspectSwarm(ctx context.Context) (swarm.Swarm, error) {\n\tresponse := swarm.Swarm{}\n\tresp, err := c.do(http.MethodGet, \"/swarm\", doOptions{\n\t\tcontext: ctx,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && (e.Status == http.StatusNotAcceptable || e.Status == http.StatusServiceUnavailable) {\n\t\t\treturn response, ErrNodeNotInSwarm\n\t\t}\n\t\treturn response, err\n\t}\n\tdefer resp.Body.Close()\n\terr = json.NewDecoder(resp.Body).Decode(&response)\n\treturn response, err\n}\n"
        },
        {
          "name": "swarm_configs.go",
          "type": "blob",
          "size": 4.482421875,
          "content": "// Copyright 2017 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\n// NoSuchConfig is the error returned when a given config does not exist.\ntype NoSuchConfig struct {\n\tID  string\n\tErr error\n}\n\nfunc (err *NoSuchConfig) Error() string {\n\tif err.Err != nil {\n\t\treturn err.Err.Error()\n\t}\n\treturn \"No such config: \" + err.ID\n}\n\n// CreateConfigOptions specify parameters to the CreateConfig function.\n//\n// See https://goo.gl/KrVjHz for more details.\ntype CreateConfigOptions struct {\n\tAuth AuthConfiguration `qs:\"-\"`\n\tswarm.ConfigSpec\n\tContext context.Context\n}\n\n// CreateConfig creates a new config, returning the config instance\n// or an error in case of failure.\n//\n// See https://goo.gl/KrVjHz for more details.\nfunc (c *Client) CreateConfig(opts CreateConfigOptions) (*swarm.Config, error) {\n\theaders, err := headersWithAuth(opts.Auth)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpath := \"/configs/create?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\theaders:   headers,\n\t\tdata:      opts.ConfigSpec,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar config swarm.Config\n\tif err := json.NewDecoder(resp.Body).Decode(&config); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &config, nil\n}\n\n// RemoveConfigOptions encapsulates options to remove a config.\n//\n// See https://goo.gl/Tqrtya for more details.\ntype RemoveConfigOptions struct {\n\tID      string `qs:\"-\"`\n\tContext context.Context\n}\n\n// RemoveConfig removes a config, returning an error in case of failure.\n//\n// See https://goo.gl/Tqrtya for more details.\nfunc (c *Client) RemoveConfig(opts RemoveConfigOptions) error {\n\tpath := \"/configs/\" + opts.ID\n\tresp, err := c.do(http.MethodDelete, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchConfig{ID: opts.ID}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// UpdateConfigOptions specify parameters to the UpdateConfig function.\n//\n// See https://goo.gl/wu3MmS for more details.\ntype UpdateConfigOptions struct {\n\tAuth AuthConfiguration `qs:\"-\"`\n\tswarm.ConfigSpec\n\tContext context.Context\n\tVersion uint64\n}\n\n// UpdateConfig updates the config at ID with the options\n//\n// Only label can be updated\n// https://docs.docker.com/engine/api/v1.33/#operation/ConfigUpdate\n// See https://goo.gl/wu3MmS for more details.\nfunc (c *Client) UpdateConfig(id string, opts UpdateConfigOptions) error {\n\theaders, err := headersWithAuth(opts.Auth)\n\tif err != nil {\n\t\treturn err\n\t}\n\tparams := make(url.Values)\n\tparams.Set(\"version\", strconv.FormatUint(opts.Version, 10))\n\tresp, err := c.do(http.MethodPost, \"/configs/\"+id+\"/update?\"+params.Encode(), doOptions{\n\t\theaders:   headers,\n\t\tdata:      opts.ConfigSpec,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchConfig{ID: id}\n\t\t}\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\treturn nil\n}\n\n// InspectConfig returns information about a config by its ID.\n//\n// See https://goo.gl/dHmr75 for more details.\nfunc (c *Client) InspectConfig(id string) (*swarm.Config, error) {\n\tpath := \"/configs/\" + id\n\tresp, err := c.do(http.MethodGet, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchConfig{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar config swarm.Config\n\tif err := json.NewDecoder(resp.Body).Decode(&config); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &config, nil\n}\n\n// ListConfigsOptions specify parameters to the ListConfigs function.\n//\n// See https://goo.gl/DwvNMd for more details.\ntype ListConfigsOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// ListConfigs returns a slice of configs matching the given criteria.\n//\n// See https://goo.gl/DwvNMd for more details.\nfunc (c *Client) ListConfigs(opts ListConfigsOptions) ([]swarm.Config, error) {\n\tpath := \"/configs?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar configs []swarm.Config\n\tif err := json.NewDecoder(resp.Body).Decode(&configs); err != nil {\n\t\treturn nil, err\n\t}\n\treturn configs, nil\n}\n"
        },
        {
          "name": "swarm_configs_test.go",
          "type": "blob",
          "size": 7.5634765625,
          "content": "// Copyright 2017 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\nfunc TestCreateConfig(t *testing.T) {\n\tt.Parallel()\n\tresult := `{\n  \"Id\": \"d1c00f91353ab0fe368363fab76d124cc764f2db8e11832f89f5ce21c2ece675\"\n}`\n\tvar expected swarm.Config\n\terr := json.Unmarshal([]byte(result), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: result, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := CreateConfigOptions{}\n\tconfig, err := client.CreateConfig(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tid := \"d1c00f91353ab0fe368363fab76d124cc764f2db8e11832f89f5ce21c2ece675\"\n\tif config.ID != id {\n\t\tt.Errorf(\"CreateConfig: wrong ID. Want %q. Got %q.\", id, config.ID)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"CreateConfig: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/configs/create\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"CreateConfig: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\tvar gotBody Config\n\terr = json.NewDecoder(req.Body).Decode(&gotBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRemoveConfig(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"d1c00f91353ab0fe368363fab76d124cc764f2db8e11832f89f5ce21c2ece675\"\n\topts := RemoveConfigOptions{ID: id}\n\terr := client.RemoveConfig(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodDelete {\n\t\tt.Errorf(\"RemoveConfig(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodDelete, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/configs/\" + id))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"RemoveConfig(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestRemoveConfigNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such config\", status: http.StatusNotFound})\n\terr := client.RemoveConfig(RemoveConfigOptions{ID: \"a2334\"})\n\texpectNoSuchConfig(t, \"a2334\", err)\n}\n\nfunc TestUpdateConfig(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"d1c00f91353ab0fe368363fab76d124cc764f2db8e11832f89f5ce21c2ece675\"\n\tupdate := UpdateConfigOptions{Version: 23}\n\terr := client.UpdateConfig(id, update)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"UpdateConfig: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/configs/\" + id + \"/update?version=23\"))\n\tif gotURI := req.URL.RequestURI(); gotURI != expectedURL.RequestURI() {\n\t\tt.Errorf(\"UpdateConfig: Wrong path in request. Want %q. Got %q.\", expectedURL.RequestURI(), gotURI)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"UpdateConfig: Wrong content-type in request. Want %q. Got %q.\", expectedContentType, contentType)\n\t}\n\tvar out UpdateConfigOptions\n\tif err := json.NewDecoder(req.Body).Decode(&out); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tupdate.Version = 0\n\tif !reflect.DeepEqual(out, update) {\n\t\tt.Errorf(\"UpdateConfig: wrong body\\ngot  %#v\\nwant %#v\", out, update)\n\t}\n}\n\nfunc TestUpdateConfigWithAuthentication(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"d1c00f91353ab0fe368363fab76d124cc764f2db8e11832f89f5ce21c2ece675\"\n\tupdate := UpdateConfigOptions{Version: 23}\n\tupdate.Auth = AuthConfiguration{\n\t\tUsername: \"gopher\",\n\t\tPassword: \"gopher123\",\n\t\tEmail:    \"gopher@tsuru.io\",\n\t}\n\n\terr := client.UpdateConfig(id, update)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"UpdateConfig: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/configs/\" + id + \"/update?version=23\"))\n\tif gotURI := req.URL.RequestURI(); gotURI != expectedURL.RequestURI() {\n\t\tt.Errorf(\"UpdateConfig: Wrong path in request. Want %q. Got %q.\", expectedURL.RequestURI(), gotURI)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"UpdateConfig: Wrong content-type in request. Want %q. Got %q.\", expectedContentType, contentType)\n\t}\n\tvar out UpdateConfigOptions\n\tif err := json.NewDecoder(req.Body).Decode(&out); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar updateAuth AuthConfiguration\n\n\tauth, err := base64.URLEncoding.DecodeString(req.Header.Get(\"X-Registry-Auth\"))\n\tif err != nil {\n\t\tt.Errorf(\"UpdateConfig: caught error decoding auth. %#v\", err.Error())\n\t}\n\n\terr = json.Unmarshal(auth, &updateAuth)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !reflect.DeepEqual(updateAuth, update.Auth) {\n\t\tt.Errorf(\"UpdateConfig: wrong auth configuration. Want %#v. Got %#v\", update.Auth, updateAuth)\n\t}\n}\n\nfunc TestUpdateConfigNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such Config\", status: http.StatusNotFound})\n\tupdate := UpdateConfigOptions{}\n\terr := client.UpdateConfig(\"notfound\", update)\n\texpectNoSuchConfig(t, \"notfound\", err)\n}\n\nfunc TestInspectConfigNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such config\", status: http.StatusNotFound})\n\tconfig, err := client.InspectConfig(\"notfound\")\n\tif config != nil {\n\t\tt.Errorf(\"InspectConfig: Expected <nil> Config, got %#v\", config)\n\t}\n\texpectNoSuchConfig(t, \"notfound\", err)\n}\n\nfunc TestInspectConfig(t *testing.T) {\n\tt.Parallel()\n\tjsonConfig := `{\n\t\t\"ID\": \"ktnbjxoalbkvbvedmg1urrz8h\",\n\t\t\"Version\": {\n\t\t\t\"Index\": 11\n\t\t},\n\t\t\"CreatedAt\": \"2016-11-05T01:20:17.327670065Z\",\n\t\t\"UpdatedAt\": \"2016-11-05T01:20:17.327670065Z\",\n\t\t\"Spec\": {\n\t\t\t\"Name\": \"app-dev.crt\"\n\t\t}\n}`\n\tvar expected swarm.Config\n\terr := json.Unmarshal([]byte(jsonConfig), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonConfig, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"ktnbjxoalbkvbvedmg1urrz8h\"\n\tconfig, err := client.InspectConfig(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*config, expected) {\n\t\tt.Errorf(\"InspectConfig(%q): Expected %#v. Got %#v.\", id, expected, config)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/configs/ktnbjxoalbkvbvedmg1urrz8h\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"InspectConfig(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestListConfigs(t *testing.T) {\n\tt.Parallel()\n\tjsonConfigs := `[\n\t\t{\n\t\t\t\"ID\": \"ktnbjxoalbkvbvedmg1urrz8h\",\n\t\t\t\"Version\": {\n\t\t\t\t\"Index\": 11\n\t\t\t},\n\t\t\t\"CreatedAt\": \"2016-11-05T01:20:17.327670065Z\",\n\t\t\t\"UpdatedAt\": \"2016-11-05T01:20:17.327670065Z\",\n\t\t\t\"Spec\": {\n\t\t\t\t\"Name\": \"server.conf\"\n\t\t\t}\n\t\t}\n]`\n\tvar expected []swarm.Config\n\terr := json.Unmarshal([]byte(jsonConfigs), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: jsonConfigs, status: http.StatusOK})\n\tconfigs, err := client.ListConfigs(ListConfigsOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(configs, expected) {\n\t\tt.Errorf(\"ListConfigs: Expected %#v. Got %#v.\", expected, configs)\n\t}\n}\n"
        },
        {
          "name": "swarm_node.go",
          "type": "blob",
          "size": 3.27734375,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\n// NoSuchNode is the error returned when a given node does not exist.\ntype NoSuchNode struct {\n\tID  string\n\tErr error\n}\n\nfunc (err *NoSuchNode) Error() string {\n\tif err.Err != nil {\n\t\treturn err.Err.Error()\n\t}\n\treturn \"No such node: \" + err.ID\n}\n\n// ListNodesOptions specify parameters to the ListNodes function.\n//\n// See http://goo.gl/3K4GwU for more details.\ntype ListNodesOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// ListNodes returns a slice of nodes matching the given criteria.\n//\n// See http://goo.gl/3K4GwU for more details.\nfunc (c *Client) ListNodes(opts ListNodesOptions) ([]swarm.Node, error) {\n\tpath := \"/nodes?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar nodes []swarm.Node\n\tif err := json.NewDecoder(resp.Body).Decode(&nodes); err != nil {\n\t\treturn nil, err\n\t}\n\treturn nodes, nil\n}\n\n// InspectNode returns information about a node by its ID.\n//\n// See http://goo.gl/WjkTOk for more details.\nfunc (c *Client) InspectNode(id string) (*swarm.Node, error) {\n\tresp, err := c.do(http.MethodGet, \"/nodes/\"+id, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchNode{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar node swarm.Node\n\tif err := json.NewDecoder(resp.Body).Decode(&node); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &node, nil\n}\n\n// UpdateNodeOptions specify parameters to the NodeUpdate function.\n//\n// See http://goo.gl/VPBFgA for more details.\ntype UpdateNodeOptions struct {\n\tswarm.NodeSpec\n\tVersion uint64\n\tContext context.Context\n}\n\n// UpdateNode updates a node.\n//\n// See http://goo.gl/VPBFgA for more details.\nfunc (c *Client) UpdateNode(id string, opts UpdateNodeOptions) error {\n\tparams := make(url.Values)\n\tparams.Set(\"version\", strconv.FormatUint(opts.Version, 10))\n\tpath := \"/nodes/\" + id + \"/update?\" + params.Encode()\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\tcontext:   opts.Context,\n\t\tforceJSON: true,\n\t\tdata:      opts.NodeSpec,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchNode{ID: id}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// RemoveNodeOptions specify parameters to the RemoveNode function.\n//\n// See http://goo.gl/0SNvYg for more details.\ntype RemoveNodeOptions struct {\n\tID      string\n\tForce   bool\n\tContext context.Context\n}\n\n// RemoveNode removes a node.\n//\n// See http://goo.gl/0SNvYg for more details.\nfunc (c *Client) RemoveNode(opts RemoveNodeOptions) error {\n\tparams := make(url.Values)\n\tparams.Set(\"force\", strconv.FormatBool(opts.Force))\n\tpath := \"/nodes/\" + opts.ID + \"?\" + params.Encode()\n\tresp, err := c.do(http.MethodDelete, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchNode{ID: opts.ID}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n"
        },
        {
          "name": "swarm_node_test.go",
          "type": "blob",
          "size": 6.4111328125,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\nfunc TestListNodes(t *testing.T) {\n\tt.Parallel()\n\tjsonNodes := `[\n  {\n    \"ID\": \"24ifsmvkjbyhk\",\n    \"Version\": {\n      \"Index\": 8\n    },\n    \"CreatedAt\": \"2016-06-07T20:31:11.853781916Z\",\n    \"UpdatedAt\": \"2016-06-07T20:31:11.999868824Z\",\n    \"Spec\": {\n      \"Name\": \"my-node\",\n      \"Role\": \"manager\",\n      \"Availability\": \"active\",\n      \"Labels\": {\n          \"foo\": \"bar\"\n      }\n    },\n    \"Description\": {\n      \"Hostname\": \"bf3067039e47\",\n      \"Platform\": {\n        \"Architecture\": \"x86_64\",\n        \"OS\": \"linux\"\n      },\n      \"Resources\": {\n        \"NanoCPUs\": 4000000000,\n        \"MemoryBytes\": 8272408576\n      },\n      \"Engine\": {\n        \"EngineVersion\": \"1.12.0-dev\",\n        \"Labels\": {\n            \"foo\": \"bar\"\n        },\n        \"Plugins\": [\n          {\n            \"Type\": \"Volume\",\n            \"Name\": \"local\"\n          },\n          {\n            \"Type\": \"Network\",\n            \"Name\": \"bridge\"\n          },\n          {\n            \"Type\": \"Network\",\n            \"Name\": \"null\"\n          },\n          {\n            \"Type\": \"Network\",\n            \"Name\": \"overlay\"\n          }\n        ]\n      }\n    },\n    \"Status\": {\n      \"State\": \"ready\"\n    },\n    \"ManagerStatus\": {\n      \"Leader\": true,\n      \"Reachability\": \"reachable\",\n      \"Addr\": \"172.17.0.2:2377\"\n    }\n  }\n]`\n\tvar expected []swarm.Node\n\terr := json.Unmarshal([]byte(jsonNodes), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: jsonNodes, status: http.StatusOK})\n\tnodes, err := client.ListNodes(ListNodesOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(nodes, expected) {\n\t\tt.Errorf(\"ListNodes: Expected %#v. Got %#v.\", expected, nodes)\n\t}\n}\n\nfunc TestInspectNode(t *testing.T) {\n\tt.Parallel()\n\tjsonNode := `{\n  \"ID\": \"24ifsmvkjbyhk\",\n  \"Version\": {\n    \"Index\": 8\n  },\n  \"CreatedAt\": \"2016-06-07T20:31:11.853781916Z\",\n  \"UpdatedAt\": \"2016-06-07T20:31:11.999868824Z\",\n  \"Spec\": {\n    \"Name\": \"my-node\",\n    \"Role\": \"manager\",\n    \"Availability\": \"active\",\n    \"Labels\": {\n        \"foo\": \"bar\"\n    }\n  },\n  \"Description\": {\n    \"Hostname\": \"bf3067039e47\",\n    \"Platform\": {\n      \"Architecture\": \"x86_64\",\n      \"OS\": \"linux\"\n    },\n    \"Resources\": {\n      \"NanoCPUs\": 4000000000,\n      \"MemoryBytes\": 8272408576\n    },\n    \"Engine\": {\n      \"EngineVersion\": \"1.12.0-dev\",\n      \"Labels\": {\n          \"foo\": \"bar\"\n      },\n      \"Plugins\": [\n        {\n          \"Type\": \"Volume\",\n          \"Name\": \"local\"\n        },\n        {\n          \"Type\": \"Network\",\n          \"Name\": \"bridge\"\n        },\n        {\n          \"Type\": \"Network\",\n          \"Name\": \"null\"\n        },\n        {\n          \"Type\": \"Network\",\n          \"Name\": \"overlay\"\n        }\n      ]\n    }\n  },\n  \"Status\": {\n    \"State\": \"ready\"\n  },\n  \"ManagerStatus\": {\n    \"Leader\": true,\n    \"Reachability\": \"reachable\",\n    \"Addr\": \"172.17.0.2:2377\"\n  }\n}`\n\n\tvar expected swarm.Node\n\terr := json.Unmarshal([]byte(jsonNode), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonNode, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"24ifsmvkjbyhk\"\n\tnode, err := client.InspectNode(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*node, expected) {\n\t\tt.Errorf(\"InspectNode(%q): Expected %#v. Got %#v.\", id, expected, node)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/nodes/24ifsmvkjbyhk\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"InspectNode(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestInspectNodeNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such node\", status: http.StatusNotFound})\n\tnode, err := client.InspectNode(\"notfound\")\n\tif node != nil {\n\t\tt.Errorf(\"InspectNode: Expected <nil> task, got %#v\", node)\n\t}\n\texpectNoSuchNode(t, \"notfound\", err)\n}\n\nfunc TestUpdateNode(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\topts := UpdateNodeOptions{}\n\terr := client.UpdateNode(id, opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"UpdateNode: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/nodes/\" + id + \"/update\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"UpdateNode: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"UpdateNode: Wrong content-type in request. Want %q. Got %q.\", expectedContentType, contentType)\n\t}\n\tvar out UpdateNodeOptions\n\tif err := json.NewDecoder(req.Body).Decode(&out); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(out, opts) {\n\t\tt.Errorf(\"UpdateNode: wrong body, got: %#v, want %#v\", out, opts)\n\t}\n}\n\nfunc TestUpdateNodeNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such node\", status: http.StatusNotFound})\n\terr := client.UpdateNode(\"notfound\", UpdateNodeOptions{})\n\texpectNoSuchNode(t, \"notfound\", err)\n}\n\nfunc TestRemoveNode(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\terr := client.RemoveNode(RemoveNodeOptions{ID: id})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodDelete {\n\t\tt.Errorf(\"RemoveNode(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodDelete, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/nodes/\" + id))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"RemoveNode(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestRemoveNodeNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such node\", status: http.StatusNotFound})\n\terr := client.RemoveNode(RemoveNodeOptions{ID: \"notfound\"})\n\texpectNoSuchNode(t, \"notfound\", err)\n}\n"
        },
        {
          "name": "swarm_secrets.go",
          "type": "blob",
          "size": 4.486328125,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\n// NoSuchSecret is the error returned when a given secret does not exist.\ntype NoSuchSecret struct {\n\tID  string\n\tErr error\n}\n\nfunc (err *NoSuchSecret) Error() string {\n\tif err.Err != nil {\n\t\treturn err.Err.Error()\n\t}\n\treturn \"No such secret: \" + err.ID\n}\n\n// CreateSecretOptions specify parameters to the CreateSecret function.\n//\n// See https://goo.gl/KrVjHz for more details.\ntype CreateSecretOptions struct {\n\tAuth AuthConfiguration `qs:\"-\"`\n\tswarm.SecretSpec\n\tContext context.Context\n}\n\n// CreateSecret creates a new secret, returning the secret instance\n// or an error in case of failure.\n//\n// See https://goo.gl/KrVjHz for more details.\nfunc (c *Client) CreateSecret(opts CreateSecretOptions) (*swarm.Secret, error) {\n\theaders, err := headersWithAuth(opts.Auth)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpath := \"/secrets/create?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\theaders:   headers,\n\t\tdata:      opts.SecretSpec,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar secret swarm.Secret\n\tif err := json.NewDecoder(resp.Body).Decode(&secret); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &secret, nil\n}\n\n// RemoveSecretOptions encapsulates options to remove a secret.\n//\n// See https://goo.gl/Tqrtya for more details.\ntype RemoveSecretOptions struct {\n\tID      string `qs:\"-\"`\n\tContext context.Context\n}\n\n// RemoveSecret removes a secret, returning an error in case of failure.\n//\n// See https://goo.gl/Tqrtya for more details.\nfunc (c *Client) RemoveSecret(opts RemoveSecretOptions) error {\n\tpath := \"/secrets/\" + opts.ID\n\tresp, err := c.do(http.MethodDelete, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchSecret{ID: opts.ID}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// UpdateSecretOptions specify parameters to the UpdateSecret function.\n//\n// Only label can be updated\n// See https://docs.docker.com/engine/api/v1.33/#operation/SecretUpdate\n// See https://goo.gl/wu3MmS for more details.\ntype UpdateSecretOptions struct {\n\tAuth AuthConfiguration `qs:\"-\"`\n\tswarm.SecretSpec\n\tContext context.Context\n\tVersion uint64\n}\n\n// UpdateSecret updates the secret at ID with the options\n//\n// See https://goo.gl/wu3MmS for more details.\nfunc (c *Client) UpdateSecret(id string, opts UpdateSecretOptions) error {\n\theaders, err := headersWithAuth(opts.Auth)\n\tif err != nil {\n\t\treturn err\n\t}\n\tparams := make(url.Values)\n\tparams.Set(\"version\", strconv.FormatUint(opts.Version, 10))\n\tresp, err := c.do(http.MethodPost, \"/secrets/\"+id+\"/update?\"+params.Encode(), doOptions{\n\t\theaders:   headers,\n\t\tdata:      opts.SecretSpec,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchSecret{ID: id}\n\t\t}\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\treturn nil\n}\n\n// InspectSecret returns information about a secret by its ID.\n//\n// See https://goo.gl/dHmr75 for more details.\nfunc (c *Client) InspectSecret(id string) (*swarm.Secret, error) {\n\tpath := \"/secrets/\" + id\n\tresp, err := c.do(http.MethodGet, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchSecret{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar secret swarm.Secret\n\tif err := json.NewDecoder(resp.Body).Decode(&secret); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &secret, nil\n}\n\n// ListSecretsOptions specify parameters to the ListSecrets function.\n//\n// See https://goo.gl/DwvNMd for more details.\ntype ListSecretsOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// ListSecrets returns a slice of secrets matching the given criteria.\n//\n// See https://goo.gl/DwvNMd for more details.\nfunc (c *Client) ListSecrets(opts ListSecretsOptions) ([]swarm.Secret, error) {\n\tpath := \"/secrets?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar secrets []swarm.Secret\n\tif err := json.NewDecoder(resp.Body).Decode(&secrets); err != nil {\n\t\treturn nil, err\n\t}\n\treturn secrets, nil\n}\n"
        },
        {
          "name": "swarm_secrets_test.go",
          "type": "blob",
          "size": 8.2763671875,
          "content": "// Copyright 2017 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\nfunc TestCreateSecret(t *testing.T) {\n\tt.Parallel()\n\tresult := `{\n  \"Id\": \"13417726f7654bc286201f7c9accc98ccbd190efcc4753bf8ecfc0b61ef3dde8\"\n}`\n\tvar expected swarm.Secret\n\terr := json.Unmarshal([]byte(result), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: result, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := CreateSecretOptions{}\n\tsecret, err := client.CreateSecret(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tid := \"13417726f7654bc286201f7c9accc98ccbd190efcc4753bf8ecfc0b61ef3dde8\"\n\tif secret.ID != id {\n\t\tt.Errorf(\"CreateSecret: wrong ID. Want %q. Got %q.\", id, secret.ID)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"CreateSecret: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/secrets/create\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"CreateSecret: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\tvar gotBody Config\n\terr = json.NewDecoder(req.Body).Decode(&gotBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRemoveSecret(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"13417726f7654bc286201f7c9accc98ccbd190efcc4753bf8ecfc0b61ef3dde8\"\n\topts := RemoveSecretOptions{ID: id}\n\terr := client.RemoveSecret(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodDelete {\n\t\tt.Errorf(\"RemoveSecret(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodDelete, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/secrets/\" + id))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"RemoveSecret(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestRemoveSecretNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such secret\", status: http.StatusNotFound})\n\terr := client.RemoveSecret(RemoveSecretOptions{ID: \"a2334\"})\n\texpectNoSuchSecret(t, \"a2334\", err)\n}\n\nfunc TestUpdateSecret(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"13417726f7654bc286201f7c9accc98ccbd190efcc4753bf8ecfc0b61ef3dde8\"\n\tupdate := UpdateSecretOptions{Version: 23}\n\terr := client.UpdateSecret(id, update)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"UpdateSecret: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/secrets/\" + id + \"/update?version=23\"))\n\tif gotURI := req.URL.RequestURI(); gotURI != expectedURL.RequestURI() {\n\t\tt.Errorf(\"UpdateSecret: Wrong path in request. Want %q. Got %q.\", expectedURL.RequestURI(), gotURI)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"UpdateSecret: Wrong content-type in request. Want %q. Got %q.\", expectedContentType, contentType)\n\t}\n\tvar out UpdateSecretOptions\n\tif err := json.NewDecoder(req.Body).Decode(&out); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tupdate.Version = 0\n\tif !reflect.DeepEqual(out, update) {\n\t\tt.Errorf(\"UpdateSecret: wrong body\\ngot  %#v\\nwant %#v\", out, update)\n\t}\n}\n\nfunc TestUpdateSecretWithAuthentication(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"13417726f7654bc286201f7c9accc98ccbd190efcc4753bf8ecfc0b61ef3dde8\"\n\tupdate := UpdateSecretOptions{Version: 23}\n\tupdate.Auth = AuthConfiguration{\n\t\tUsername: \"gopher\",\n\t\tPassword: \"gopher123\",\n\t\tEmail:    \"gopher@tsuru.io\",\n\t}\n\n\terr := client.UpdateSecret(id, update)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"UpdateSecret: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/secrets/\" + id + \"/update?version=23\"))\n\tif gotURI := req.URL.RequestURI(); gotURI != expectedURL.RequestURI() {\n\t\tt.Errorf(\"UpdateSecret: Wrong path in request. Want %q. Got %q.\", expectedURL.RequestURI(), gotURI)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"UpdateSecret: Wrong content-type in request. Want %q. Got %q.\", expectedContentType, contentType)\n\t}\n\tvar out UpdateSecretOptions\n\tif err := json.NewDecoder(req.Body).Decode(&out); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar updateAuth AuthConfiguration\n\n\tauth, err := base64.URLEncoding.DecodeString(req.Header.Get(\"X-Registry-Auth\"))\n\tif err != nil {\n\t\tt.Errorf(\"UpdateSecret: caught error decoding auth. %#v\", err.Error())\n\t}\n\n\terr = json.Unmarshal(auth, &updateAuth)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !reflect.DeepEqual(updateAuth, update.Auth) {\n\t\tt.Errorf(\"UpdateSecret: wrong auth configuration. Want %#v. Got %#v\", update.Auth, updateAuth)\n\t}\n}\n\nfunc TestUpdateSecretNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such Secret\", status: http.StatusNotFound})\n\tupdate := UpdateSecretOptions{}\n\terr := client.UpdateSecret(\"notfound\", update)\n\texpectNoSuchSecret(t, \"notfound\", err)\n}\n\nfunc TestInspectSecretNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such secret\", status: http.StatusNotFound})\n\tsecret, err := client.InspectSecret(\"notfound\")\n\tif secret != nil {\n\t\tt.Errorf(\"InspectSecret: Expected <nil> Secret, got %#v\", secret)\n\t}\n\texpectNoSuchSecret(t, \"notfound\", err)\n}\n\nfunc TestInspectSecret(t *testing.T) {\n\tt.Parallel()\n\tjsonSecret := `{\n\t\t\"ID\": \"ak7w3gjqoa3kuz8xcpnyy0pvl\",\n\t\t\"Version\": {\n\t\t\t\"Index\": 11\n\t\t},\n\t\t\"CreatedAt\": \"2016-11-05T01:20:17.327670065Z\",\n\t\t\"UpdatedAt\": \"2016-11-05T01:20:17.327670065Z\",\n\t\t\"Spec\": {\n\t\t\t\"Name\": \"app-dev.crt\",\n\t\t\t\"Labels\": {\n\t\t\t\t\"foo\": \"bar\"\n\t\t\t},\n\t\t\t\"Driver\": {\n\t\t\t\t\"Name\": \"secret-bucket\",\n\t\t\t\t\"Options\": {\n\t\t\t\t\t\"OptionA\": \"value for driver option A\",\n\t\t\t\t\t\"OptionB\": \"value for driver option B\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}`\n\tvar expected swarm.Secret\n\terr := json.Unmarshal([]byte(jsonSecret), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonSecret, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"ak7w3gjqoa3kuz8xcpnyy0pvl\"\n\tsecret, err := client.InspectSecret(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*secret, expected) {\n\t\tt.Errorf(\"InspectSecret(%q): Expected %#v. Got %#v.\", id, expected, secret)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/secrets/ak7w3gjqoa3kuz8xcpnyy0pvl\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"InspectSecret(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestListSecrets(t *testing.T) {\n\tt.Parallel()\n\tjsonSecrets := `[\n\t\t\t{\n\t\t\t\t\"ID\": \"blt1owaxmitz71s9v5zh81zun\",\n\t\t\t\t\"Version\": {\n\t\t\t\t\t\"Index\": 85\n\t\t\t\t},\n\t\t\t\t\"CreatedAt\": \"2017-07-20T13:55:28.678958722Z\",\n\t\t\t\t\"UpdatedAt\": \"2017-07-20T13:55:28.678958722Z\",\n\t\t\t\t\"Spec\": {\n\t\t\t\t\t\"Name\": \"mysql-passwd\",\n\t\t\t\t\t\"Labels\": {\n\t\t\t\t\t\t\"some.label\": \"some.value\"\n\t\t\t\t\t},\n\t\t\t\t\t\"Driver\": {\n\t\t\t\t\t\t\"Name\": \"secret-bucket\",\n\t\t\t\t\t\t\"Options\": {\n\t\t\t\t\t\t\t\"OptionA\": \"value for driver option A\",\n\t\t\t\t\t\t\t\"OptionB\": \"value for driver option B\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"ID\": \"ktnbjxoalbkvbvedmg1urrz8h\",\n\t\t\t\t\"Version\": {\n\t\t\t\t\t\"Index\": 11\n\t\t\t\t},\n\t\t\t\t\"CreatedAt\": \"2016-11-05T01:20:17.327670065Z\",\n\t\t\t\t\"UpdatedAt\": \"2016-11-05T01:20:17.327670065Z\",\n\t\t\t\t\"Spec\": {\n\t\t\t\t\t\"Name\": \"app-dev.crt\",\n\t\t\t\t\t\"Labels\": {\n\t\t\t\t\t\t\"foo\": \"bar\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n]`\n\tvar expected []swarm.Secret\n\terr := json.Unmarshal([]byte(jsonSecrets), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: jsonSecrets, status: http.StatusOK})\n\tsecrets, err := client.ListSecrets(ListSecretsOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(secrets, expected) {\n\t\tt.Errorf(\"ListSecrets: Expected %#v. Got %#v.\", expected, secrets)\n\t}\n}\n"
        },
        {
          "name": "swarm_service.go",
          "type": "blob",
          "size": 5.8984375,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\n// NoSuchService is the error returned when a given service does not exist.\ntype NoSuchService struct {\n\tID  string\n\tErr error\n}\n\nfunc (err *NoSuchService) Error() string {\n\tif err.Err != nil {\n\t\treturn err.Err.Error()\n\t}\n\treturn \"No such service: \" + err.ID\n}\n\n// CreateServiceOptions specify parameters to the CreateService function.\n//\n// See https://goo.gl/KrVjHz for more details.\ntype CreateServiceOptions struct {\n\tAuth AuthConfiguration `qs:\"-\"`\n\tswarm.ServiceSpec\n\tContext context.Context\n}\n\n// CreateService creates a new service, returning the service instance\n// or an error in case of failure.\n//\n// See https://goo.gl/KrVjHz for more details.\nfunc (c *Client) CreateService(opts CreateServiceOptions) (*swarm.Service, error) {\n\theaders, err := headersWithAuth(opts.Auth)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpath := \"/services/create?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{\n\t\theaders:   headers,\n\t\tdata:      opts.ServiceSpec,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar service swarm.Service\n\tif err := json.NewDecoder(resp.Body).Decode(&service); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &service, nil\n}\n\n// RemoveServiceOptions encapsulates options to remove a service.\n//\n// See https://goo.gl/Tqrtya for more details.\ntype RemoveServiceOptions struct {\n\tID      string `qs:\"-\"`\n\tContext context.Context\n}\n\n// RemoveService removes a service, returning an error in case of failure.\n//\n// See https://goo.gl/Tqrtya for more details.\nfunc (c *Client) RemoveService(opts RemoveServiceOptions) error {\n\tpath := \"/services/\" + opts.ID\n\tresp, err := c.do(http.MethodDelete, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchService{ID: opts.ID}\n\t\t}\n\t\treturn err\n\t}\n\tresp.Body.Close()\n\treturn nil\n}\n\n// UpdateServiceOptions specify parameters to the UpdateService function.\n//\n// See https://goo.gl/wu3MmS for more details.\ntype UpdateServiceOptions struct {\n\tAuth              AuthConfiguration `qs:\"-\"`\n\tswarm.ServiceSpec `qs:\"-\"`\n\tContext           context.Context\n\tVersion           uint64\n\tRollback          string\n}\n\n// UpdateService updates the service at ID with the options\n//\n// See https://goo.gl/wu3MmS for more details.\nfunc (c *Client) UpdateService(id string, opts UpdateServiceOptions) error {\n\theaders, err := headersWithAuth(opts.Auth)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp, err := c.do(http.MethodPost, \"/services/\"+id+\"/update?\"+queryString(opts), doOptions{\n\t\theaders:   headers,\n\t\tdata:      opts.ServiceSpec,\n\t\tforceJSON: true,\n\t\tcontext:   opts.Context,\n\t})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn &NoSuchService{ID: id}\n\t\t}\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\treturn nil\n}\n\n// InspectService returns information about a service by its ID.\n//\n// See https://goo.gl/dHmr75 for more details.\nfunc (c *Client) InspectService(id string) (*swarm.Service, error) {\n\tpath := \"/services/\" + id\n\tresp, err := c.do(http.MethodGet, path, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchService{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar service swarm.Service\n\tif err := json.NewDecoder(resp.Body).Decode(&service); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &service, nil\n}\n\n// ListServicesOptions specify parameters to the ListServices function.\n//\n// See https://goo.gl/DwvNMd for more details.\ntype ListServicesOptions struct {\n\tFilters map[string][]string\n\tStatus  bool\n\tContext context.Context\n}\n\n// ListServices returns a slice of services matching the given criteria.\n//\n// See https://goo.gl/DwvNMd for more details.\nfunc (c *Client) ListServices(opts ListServicesOptions) ([]swarm.Service, error) {\n\tpath := \"/services?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar services []swarm.Service\n\tif err := json.NewDecoder(resp.Body).Decode(&services); err != nil {\n\t\treturn nil, err\n\t}\n\treturn services, nil\n}\n\n// LogsServiceOptions represents the set of options used when getting logs from a\n// service.\ntype LogsServiceOptions struct {\n\tContext           context.Context\n\tService           string        `qs:\"-\"`\n\tOutputStream      io.Writer     `qs:\"-\"`\n\tErrorStream       io.Writer     `qs:\"-\"`\n\tInactivityTimeout time.Duration `qs:\"-\"`\n\tTail              string\n\tSince             int64\n\n\t// Use raw terminal? Usually true when the container contains a TTY.\n\tRawTerminal bool `qs:\"-\"`\n\tFollow      bool\n\tStdout      bool\n\tStderr      bool\n\tTimestamps  bool\n\tDetails     bool\n}\n\n// GetServiceLogs gets stdout and stderr logs from the specified service.\n//\n// When LogsServiceOptions.RawTerminal is set to false, go-dockerclient will multiplex\n// the streams and send the containers stdout to LogsServiceOptions.OutputStream, and\n// stderr to LogsServiceOptions.ErrorStream.\n//\n// When LogsServiceOptions.RawTerminal is true, callers will get the raw stream on\n// LogsServiceOptions.OutputStream.\nfunc (c *Client) GetServiceLogs(opts LogsServiceOptions) error {\n\tif opts.Service == \"\" {\n\t\treturn &NoSuchService{ID: opts.Service}\n\t}\n\tif opts.Tail == \"\" {\n\t\topts.Tail = \"all\"\n\t}\n\tpath := \"/services/\" + opts.Service + \"/logs?\" + queryString(opts)\n\treturn c.stream(http.MethodGet, path, streamOptions{\n\t\tsetRawTerminal:    opts.RawTerminal,\n\t\tstdout:            opts.OutputStream,\n\t\tstderr:            opts.ErrorStream,\n\t\tinactivityTimeout: opts.InactivityTimeout,\n\t\tcontext:           opts.Context,\n\t})\n}\n"
        },
        {
          "name": "swarm_service_test.go",
          "type": "blob",
          "size": 17.6396484375,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\nfunc TestCreateService(t *testing.T) {\n\tt.Parallel()\n\tresult := `{\n  \"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n}`\n\tvar expected swarm.Service\n\terr := json.Unmarshal([]byte(result), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: result, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := CreateServiceOptions{}\n\tservice, err := client.CreateService(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tif service.ID != id {\n\t\tt.Errorf(\"CreateServce: wrong ID. Want %q. Got %q.\", id, service.ID)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"CreateService: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/services/create\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"CreateService: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\tvar gotBody Config\n\terr = json.NewDecoder(req.Body).Decode(&gotBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tauthHeader, ok := req.Header[\"X-Registry-Auth\"]\n\tif ok {\n\t\tt.Errorf(\"CreateService: unexpected non-empty X-Registry-Auth header: %v\", authHeader)\n\t}\n}\n\nfunc TestCreateServiceWithAuthentication(t *testing.T) {\n\tt.Parallel()\n\tresult := `{\n  \"Id\": \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n}`\n\tvar expected swarm.Service\n\terr := json.Unmarshal([]byte(result), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: result, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := CreateServiceOptions{}\n\topts.Auth = AuthConfiguration{\n\t\tUsername: \"gopher\",\n\t\tPassword: \"gopher123\",\n\t\tEmail:    \"gopher@tsuru.io\",\n\t}\n\tservice, err := client.CreateService(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tif service.ID != id {\n\t\tt.Errorf(\"CreateServce: wrong ID. Want %q. Got %q.\", id, service.ID)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"CreateService: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/services/create\"))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"CreateService: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, gotPath)\n\t}\n\tvar gotBody Config\n\terr = json.NewDecoder(req.Body).Decode(&gotBody)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar gotAuth AuthConfiguration\n\n\tauth, err := base64.URLEncoding.DecodeString(req.Header.Get(\"X-Registry-Auth\"))\n\tif err != nil {\n\t\tt.Errorf(\"CreateService: caught error decoding auth. %#v\", err.Error())\n\t}\n\n\terr = json.Unmarshal(auth, &gotAuth)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(gotAuth, opts.Auth) {\n\t\tt.Errorf(\"CreateService: wrong auth configuration. Want %#v. Got %#v.\", opts.Auth, gotAuth)\n\t}\n}\n\nfunc TestRemoveService(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\topts := RemoveServiceOptions{ID: id}\n\terr := client.RemoveService(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodDelete {\n\t\tt.Errorf(\"RemoveService(%q): wrong HTTP method. Want %q. Got %q.\", id, http.MethodDelete, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/services/\" + id))\n\tif gotPath := req.URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"RemoveService(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestRemoveServiceNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such service\", status: http.StatusNotFound})\n\terr := client.RemoveService(RemoveServiceOptions{ID: \"a2334\"})\n\texpected := &NoSuchService{ID: \"a2334\"}\n\tvar e *NoSuchService\n\tif errors.As(err, &e) && e.ID != expected.ID {\n\t\tt.Errorf(\"RemoveService: Wrong error returned. Want %#v. Got %#v.\", expected, err)\n\t}\n}\n\nfunc TestUpdateService(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tupdate := UpdateServiceOptions{Version: 23}\n\terr := client.UpdateService(id, update)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"UpdateService: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/services/\" + id + \"/update?version=23\"))\n\tif gotURI := req.URL.RequestURI(); gotURI != expectedURL.RequestURI() {\n\t\tt.Errorf(\"UpdateService: Wrong path in request. Want %q. Got %q.\", expectedURL.RequestURI(), gotURI)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"UpdateService: Wrong content-type in request. Want %q. Got %q.\", expectedContentType, contentType)\n\t}\n\tvar out UpdateServiceOptions\n\tif err := json.NewDecoder(req.Body).Decode(&out); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tupdate.Version = 0\n\tif !reflect.DeepEqual(out, update) {\n\t\tt.Errorf(\"UpdateService: wrong body\\ngot  %#v\\nwant %#v\", out, update)\n\t}\n}\n\nfunc TestUpdateServiceRollback(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tupdate := UpdateServiceOptions{Version: 23, Rollback: \"previous\"}\n\terr := client.UpdateService(id, update)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"UpdateService: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/services/\" + id + \"/update?version=23&rollback=previous\"))\n\tif req.URL.Path != expectedURL.Path {\n\t\tt.Errorf(\"UpdateService: Wrong path in request. Want %q. Got %q.\", expectedURL.Path, req.URL.Path)\n\t}\n\tif !reflect.DeepEqual(req.URL.Query(), expectedURL.Query()) {\n\t\tt.Errorf(\"UpdateService: Wrong querystring in request. Want %v. Got %v.\", expectedURL.Query(), req.URL.Query())\n\t}\n}\n\nfunc TestUpdateServiceWithAuthentication(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"4fa6e0f0c6786287e131c3852c58a2e01cc697a68231826813597e4994f1d6e2\"\n\tupdate := UpdateServiceOptions{Version: 23}\n\tupdate.Auth = AuthConfiguration{\n\t\tUsername: \"gopher\",\n\t\tPassword: \"gopher123\",\n\t\tEmail:    \"gopher@tsuru.io\",\n\t}\n\n\terr := client.UpdateService(id, update)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\tif req.Method != http.MethodPost {\n\t\tt.Errorf(\"UpdateService: wrong HTTP method. Want %q. Got %q.\", http.MethodPost, req.Method)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/services/\" + id + \"/update?version=23\"))\n\tif gotURI := req.URL.RequestURI(); gotURI != expectedURL.RequestURI() {\n\t\tt.Errorf(\"UpdateService: Wrong path in request. Want %q. Got %q.\", expectedURL.RequestURI(), gotURI)\n\t}\n\texpectedContentType := \"application/json\"\n\tif contentType := req.Header.Get(\"Content-Type\"); contentType != expectedContentType {\n\t\tt.Errorf(\"UpdateService: Wrong content-type in request. Want %q. Got %q.\", expectedContentType, contentType)\n\t}\n\tvar out UpdateServiceOptions\n\tif err := json.NewDecoder(req.Body).Decode(&out); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar updateAuth AuthConfiguration\n\n\tauth, err := base64.URLEncoding.DecodeString(req.Header.Get(\"X-Registry-Auth\"))\n\tif err != nil {\n\t\tt.Errorf(\"UpdateService: caught error decoding auth. %#v\", err.Error())\n\t}\n\n\terr = json.Unmarshal(auth, &updateAuth)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !reflect.DeepEqual(updateAuth, update.Auth) {\n\t\tt.Errorf(\"UpdateService: wrong auth configuration. Want %#v. Got %#v\", update.Auth, updateAuth)\n\t}\n}\n\nfunc TestUpdateServiceNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such service\", status: http.StatusNotFound})\n\tupdate := UpdateServiceOptions{}\n\terr := client.UpdateService(\"notfound\", update)\n\texpected := &NoSuchService{ID: \"notfound\"}\n\tvar e *NoSuchService\n\tif errors.As(err, &e) && e.ID != expected.ID {\n\t\tt.Errorf(\"UpdateService: Wrong error returned. Want %#v. Got %#v.\", expected, err)\n\t}\n}\n\nfunc TestInspectServiceNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such service\", status: http.StatusNotFound})\n\tservice, err := client.InspectService(\"notfound\")\n\tif service != nil {\n\t\tt.Errorf(\"InspectService: Expected <nil> service, got %#v\", service)\n\t}\n\texpected := &NoSuchService{ID: \"notfound\"}\n\tvar e *NoSuchService\n\tif errors.As(err, &e) && e.ID != expected.ID {\n\t\tt.Errorf(\"InspectService: Wrong error returned. Want %#v. Got %#v.\", expected, err)\n\t}\n}\n\nfunc TestInspectService(t *testing.T) {\n\tt.Parallel()\n\tjsonService := `{\n  \"ID\": \"ak7w3gjqoa3kuz8xcpnyy0pvl\",\n  \"Version\": {\n    \"Index\": 95\n  },\n  \"CreatedAt\": \"2016-06-07T21:10:20.269723157Z\",\n  \"UpdatedAt\": \"2016-06-07T21:10:20.276301259Z\",\n  \"Spec\": {\n    \"Name\": \"redis\",\n    \"Task\": {\n      \"ContainerSpec\": {\n        \"Image\": \"redis\"\n      },\n      \"Resources\": {\n        \"Limits\": {},\n        \"Reservations\": {}\n      },\n      \"RestartPolicy\": {\n        \"Condition\": \"ANY\"\n      },\n      \"Placement\": {}\n    },\n    \"Mode\": {\n      \"Replicated\": {\n        \"Replicas\": 1\n      }\n    },\n    \"UpdateConfig\": {\n      \"Parallelism\": 1\n    },\n    \"EndpointSpec\": {\n      \"Mode\": \"VIP\",\n      \"Ingress\": \"PUBLICPORT\",\n      \"ExposedPorts\": [\n        {\n          \"Protocol\": \"tcp\",\n          \"Port\": 6379\n        }\n      ]\n    }\n  },\n  \"Endpoint\": {\n    \"Spec\": {},\n    \"ExposedPorts\": [\n      {\n        \"Protocol\": \"tcp\",\n        \"Port\": 6379,\n        \"PublicPort\": 30001\n      }\n    ],\n    \"VirtualIPs\": [\n      {\n        \"NetworkID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n        \"Addr\": \"10.255.0.4/16\"\n      }\n    ]\n  }\n}`\n\tvar expected swarm.Service\n\terr := json.Unmarshal([]byte(jsonService), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonService, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"ak7w3gjqoa3kuz8xcpnyy0pvl\"\n\tservice, err := client.InspectService(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*service, expected) {\n\t\tt.Errorf(\"InspectService(%q): Expected %#v. Got %#v.\", id, expected, service)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/services/ak7w3gjqoa3kuz8xcpnyy0pvl\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"InspectService(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestListServices(t *testing.T) {\n\tt.Parallel()\n\tjsonServices := `[\n  {\n    \"ID\": \"9mnpnzenvg8p8tdbtq4wvbkcz\",\n    \"Version\": {\n      \"Index\": 19\n    },\n    \"CreatedAt\": \"2016-06-07T21:05:51.880065305Z\",\n    \"UpdatedAt\": \"2016-06-07T21:07:29.962229872Z\",\n    \"Spec\": {\n      \"Name\": \"hopeful_cori\",\n      \"TaskTemplate\": {\n        \"ContainerSpec\": {\n          \"Image\": \"redis\"\n        },\n        \"Resources\": {\n          \"Limits\": {},\n          \"Reservations\": {}\n        },\n        \"RestartPolicy\": {\n          \"Condition\": \"ANY\"\n        },\n        \"Placement\": {}\n      },\n      \"Mode\": {\n        \"Replicated\": {\n          \"Replicas\": 1\n        }\n      },\n      \"UpdateConfig\": {\n        \"Parallelism\": 1\n      },\n      \"EndpointSpec\": {\n        \"Mode\": \"VIP\",\n        \"Ingress\": \"PUBLICPORT\",\n        \"ExposedPorts\": [\n          {\n            \"Protocol\": \"tcp\",\n            \"Port\": 6379\n          }\n        ]\n      }\n    },\n    \"Endpoint\": {\n      \"Spec\": {},\n      \"ExposedPorts\": [\n        {\n          \"Protocol\": \"tcp\",\n          \"Port\": 6379,\n          \"PublicPort\": 30000\n        }\n      ],\n      \"VirtualIPs\": [\n        {\n          \"NetworkID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n          \"Addr\": \"10.255.0.2/16\"\n        },\n        {\n          \"NetworkID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n          \"Addr\": \"10.255.0.3/16\"\n        }\n      ]\n    }\n  }\n]`\n\tvar expected []swarm.Service\n\terr := json.Unmarshal([]byte(jsonServices), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: jsonServices, status: http.StatusOK})\n\tservices, err := client.ListServices(ListServicesOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(services, expected) {\n\t\tt.Errorf(\"ListServices: Expected %#v. Got %#v.\", expected, services)\n\t}\n}\n\nfunc TestGetServiceLogs(t *testing.T) {\n\tvar req http.Request\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tprefix := []byte{1, 0, 0, 0, 0, 0, 0, 19}\n\t\tw.Write(prefix)\n\t\tw.Write([]byte(\"something happened!\"))\n\t\treq = *r\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar buf bytes.Buffer\n\topts := LogsServiceOptions{\n\t\tService:      \"a123456\",\n\t\tOutputStream: &buf,\n\t\tFollow:       true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tTimestamps:   true,\n\t}\n\terr := client.GetServiceLogs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"something happened!\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"Logs: wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"Logs: wrong HTTP method. Want GET. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/services/a123456/logs\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"AttachToContainer for logs: wrong HTTP path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpectedQs := map[string][]string{\n\t\t\"follow\":     {\"1\"},\n\t\t\"stdout\":     {\"1\"},\n\t\t\"stderr\":     {\"1\"},\n\t\t\"timestamps\": {\"1\"},\n\t\t\"tail\":       {\"all\"},\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expectedQs) {\n\t\tt.Errorf(\"Logs: wrong query string. Want %#v. Got %#v.\", expectedQs, got)\n\t}\n}\n\nfunc TestGetServicetLogsNilStdoutDoesntFail(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tprefix := []byte{1, 0, 0, 0, 0, 0, 0, 19}\n\t\tw.Write(prefix)\n\t\tw.Write([]byte(\"something happened!\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\topts := LogsServiceOptions{\n\t\tService:    \"a123456\",\n\t\tFollow:     true,\n\t\tStdout:     true,\n\t\tStderr:     true,\n\t\tTimestamps: true,\n\t}\n\terr := client.GetServiceLogs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGetServiceLogsNilStderrDoesntFail(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tprefix := []byte{2, 0, 0, 0, 0, 0, 0, 19}\n\t\tw.Write(prefix)\n\t\tw.Write([]byte(\"something happened!\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\topts := LogsServiceOptions{\n\t\tService:    \"a123456\",\n\t\tFollow:     true,\n\t\tStdout:     true,\n\t\tStderr:     true,\n\t\tTimestamps: true,\n\t}\n\terr := client.GetServiceLogs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGetServiceLogsSpecifyingTail(t *testing.T) {\n\tvar req http.Request\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tprefix := []byte{1, 0, 0, 0, 0, 0, 0, 19}\n\t\tw.Write(prefix)\n\t\tw.Write([]byte(\"something happened!\"))\n\t\treq = *r\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar buf bytes.Buffer\n\topts := LogsServiceOptions{\n\t\tService:      \"a123456\",\n\t\tOutputStream: &buf,\n\t\tFollow:       true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tTimestamps:   true,\n\t\tTail:         \"100\",\n\t}\n\terr := client.GetServiceLogs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"something happened!\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"Logs: wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n\tif req.Method != http.MethodGet {\n\t\tt.Errorf(\"Logs: wrong HTTP method. Want GET. Got %s.\", req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/services/a123456/logs\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"AttachToContainer for logs: wrong HTTP path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpectedQs := map[string][]string{\n\t\t\"follow\":     {\"1\"},\n\t\t\"stdout\":     {\"1\"},\n\t\t\"stderr\":     {\"1\"},\n\t\t\"timestamps\": {\"1\"},\n\t\t\"tail\":       {\"100\"},\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expectedQs) {\n\t\tt.Errorf(\"Logs: wrong query string. Want %#v. Got %#v.\", expectedQs, got)\n\t}\n}\n\nfunc TestGetServiceLogsRawTerminal(t *testing.T) {\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(\"something happened!\"))\n\t}))\n\tdefer server.Close()\n\tclient, _ := NewClient(server.URL)\n\tclient.SkipServerVersionCheck = true\n\tvar buf bytes.Buffer\n\topts := LogsServiceOptions{\n\t\tService:      \"a123456\",\n\t\tOutputStream: &buf,\n\t\tFollow:       true,\n\t\tRawTerminal:  true,\n\t\tStdout:       true,\n\t\tStderr:       true,\n\t\tTimestamps:   true,\n\t\tTail:         \"100\",\n\t}\n\terr := client.GetServiceLogs(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"something happened!\"\n\tif buf.String() != expected {\n\t\tt.Errorf(\"Logs: wrong output. Want %q. Got %q.\", expected, buf.String())\n\t}\n}\n\nfunc TestGetServiceLogsNoContainer(t *testing.T) {\n\tvar client Client\n\terr := client.GetServiceLogs(LogsServiceOptions{})\n\texpected := &NoSuchService{ID: \"\"}\n\tvar e *NoSuchService\n\tif errors.As(err, &e) && e.ID != expected.ID {\n\t\tt.Errorf(\"AttachToContainer: wrong error. Want %#v. Got %#v.\", expected, err)\n\t}\n}\n"
        },
        {
          "name": "swarm_task.go",
          "type": "blob",
          "size": 1.7412109375,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\n// NoSuchTask is the error returned when a given task does not exist.\ntype NoSuchTask struct {\n\tID  string\n\tErr error\n}\n\nfunc (err *NoSuchTask) Error() string {\n\tif err.Err != nil {\n\t\treturn err.Err.Error()\n\t}\n\treturn \"No such task: \" + err.ID\n}\n\n// ListTasksOptions specify parameters to the ListTasks function.\n//\n// See http://goo.gl/rByLzw for more details.\ntype ListTasksOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// ListTasks returns a slice of tasks matching the given criteria.\n//\n// See http://goo.gl/rByLzw for more details.\nfunc (c *Client) ListTasks(opts ListTasksOptions) ([]swarm.Task, error) {\n\tpath := \"/tasks?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar tasks []swarm.Task\n\tif err := json.NewDecoder(resp.Body).Decode(&tasks); err != nil {\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}\n\n// InspectTask returns information about a task by its ID.\n//\n// See http://goo.gl/kyziuq for more details.\nfunc (c *Client) InspectTask(id string) (*swarm.Task, error) {\n\tresp, err := c.do(http.MethodGet, \"/tasks/\"+id, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchTask{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar task swarm.Task\n\tif err := json.NewDecoder(resp.Body).Decode(&task); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &task, nil\n}\n"
        },
        {
          "name": "swarm_task_test.go",
          "type": "blob",
          "size": 8.9521484375,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\nfunc TestListTasks(t *testing.T) {\n\tt.Parallel()\n\tjsonTasks := `[\n  {\n    \"ID\": \"0kzzo1i0y4jz6027t0k7aezc7\",\n    \"Version\": {\n      \"Index\": 71\n    },\n    \"CreatedAt\": \"2016-06-07T21:07:31.171892745Z\",\n    \"UpdatedAt\": \"2016-06-07T21:07:31.376370513Z\",\n    \"Name\": \"hopeful_cori\",\n    \"Spec\": {\n      \"ContainerSpec\": {\n        \"Image\": \"redis\"\n      },\n      \"Resources\": {\n        \"Limits\": {},\n        \"Reservations\": {}\n      },\n      \"RestartPolicy\": {\n        \"Condition\": \"ANY\"\n      },\n      \"Placement\": {}\n    },\n    \"ServiceID\": \"9mnpnzenvg8p8tdbtq4wvbkcz\",\n    \"Instance\": 1,\n    \"NodeID\": \"24ifsmvkjbyhk\",\n    \"ServiceAnnotations\": {},\n    \"Status\": {\n      \"Timestamp\": \"2016-06-07T21:07:31.290032978Z\",\n      \"State\": \"FAILED\",\n      \"Message\": \"execution failed\",\n      \"ContainerStatus\": {}\n    },\n    \"DesiredState\": \"SHUTDOWN\",\n    \"NetworksAttachments\": [\n      {\n        \"Network\": {\n          \"ID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n          \"Version\": {\n            \"Index\": 18\n          },\n          \"CreatedAt\": \"2016-06-07T20:31:11.912919752Z\",\n          \"UpdatedAt\": \"2016-06-07T21:07:29.955277358Z\",\n          \"Spec\": {\n            \"Name\": \"ingress\",\n            \"Labels\": {\n              \"com.docker.swarm.internal\": \"true\"\n            },\n            \"DriverConfiguration\": {},\n            \"IPAM\": {\n              \"Driver\": {},\n              \"Configs\": [\n                {\n                  \"Family\": \"UNKNOWN\",\n                  \"Subnet\": \"10.255.0.0/16\"\n                }\n              ]\n            }\n          },\n          \"DriverState\": {\n            \"Name\": \"overlay\",\n            \"Options\": {\n              \"com.docker.network.driver.overlay.vxlanid_list\": \"256\"\n            }\n          },\n          \"IPAM\": {\n            \"Driver\": {\n              \"Name\": \"default\"\n            },\n            \"Configs\": [\n              {\n                \"Family\": \"UNKNOWN\",\n                \"Subnet\": \"10.255.0.0/16\"\n              }\n            ]\n          }\n        },\n        \"Addresses\": [\n          \"10.255.0.10/16\"\n        ]\n      }\n    ],\n    \"Endpoint\": {\n      \"Spec\": {},\n      \"ExposedPorts\": [\n        {\n          \"Protocol\": \"tcp\",\n          \"Port\": 6379,\n          \"PublicPort\": 30000\n        }\n      ],\n      \"VirtualIPs\": [\n        {\n          \"NetworkID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n          \"Addr\": \"10.255.0.2/16\"\n        },\n        {\n          \"NetworkID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n          \"Addr\": \"10.255.0.3/16\"\n        }\n      ]\n    }\n  },\n  {\n    \"ID\": \"1yljwbmlr8er2waf8orvqpwms\",\n    \"Version\": {\n      \"Index\": 30\n    },\n    \"CreatedAt\": \"2016-06-07T21:07:30.019104782Z\",\n    \"UpdatedAt\": \"2016-06-07T21:07:30.231958098Z\",\n    \"Name\": \"hopeful_cori\",\n    \"Spec\": {\n      \"ContainerSpec\": {\n        \"Image\": \"redis\"\n      },\n      \"Resources\": {\n        \"Limits\": {},\n        \"Reservations\": {}\n      },\n      \"RestartPolicy\": {\n        \"Condition\": \"ANY\"\n      },\n      \"Placement\": {}\n    },\n    \"ServiceID\": \"9mnpnzenvg8p8tdbtq4wvbkcz\",\n    \"Instance\": 1,\n    \"NodeID\": \"24ifsmvkjbyhk\",\n    \"ServiceAnnotations\": {},\n    \"Status\": {\n      \"Timestamp\": \"2016-06-07T21:07:30.202183143Z\",\n      \"State\": \"FAILED\",\n      \"Message\": \"execution failed\",\n      \"ContainerStatus\": {}\n    },\n    \"DesiredState\": \"SHUTDOWN\",\n    \"NetworksAttachments\": [\n      {\n        \"Network\": {\n          \"ID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n          \"Version\": {\n            \"Index\": 18\n          },\n          \"CreatedAt\": \"2016-06-07T20:31:11.912919752Z\",\n          \"UpdatedAt\": \"2016-06-07T21:07:29.955277358Z\",\n          \"Spec\": {\n            \"Name\": \"ingress\",\n            \"Labels\": {\n              \"com.docker.swarm.internal\": \"true\"\n            },\n            \"DriverConfiguration\": {},\n            \"IPAM\": {\n              \"Driver\": {},\n              \"Configs\": [\n                {\n                  \"Family\": \"UNKNOWN\",\n                  \"Subnet\": \"10.255.0.0/16\"\n                }\n              ]\n            }\n          },\n          \"DriverState\": {\n            \"Name\": \"overlay\",\n            \"Options\": {\n              \"com.docker.network.driver.overlay.vxlanid_list\": \"256\"\n            }\n          },\n          \"IPAM\": {\n            \"Driver\": {\n              \"Name\": \"default\"\n            },\n            \"Configs\": [\n              {\n                \"Family\": \"UNKNOWN\",\n                \"Subnet\": \"10.255.0.0/16\"\n              }\n            ]\n          }\n        },\n        \"Addresses\": [\n          \"10.255.0.5/16\"\n        ]\n      }\n    ],\n    \"Endpoint\": {\n      \"Spec\": {},\n      \"ExposedPorts\": [\n        {\n          \"Protocol\": \"tcp\",\n          \"Port\": 6379,\n          \"PublicPort\": 30000\n        }\n      ],\n      \"VirtualIPs\": [\n        {\n          \"NetworkID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n          \"Addr\": \"10.255.0.2/16\"\n        },\n        {\n          \"NetworkID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n          \"Addr\": \"10.255.0.3/16\"\n        }\n      ]\n    }\n  }\n]`\n\tvar expected []swarm.Task\n\terr := json.Unmarshal([]byte(jsonTasks), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: jsonTasks, status: http.StatusOK})\n\ttasks, err := client.ListTasks(ListTasksOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(tasks, expected) {\n\t\tt.Errorf(\"ListTasks: Expected %#v. Got %#v.\", expected, tasks)\n\t}\n}\n\nfunc TestInspectTask(t *testing.T) {\n\tt.Parallel()\n\tjsonTask := `{\n  \"ID\": \"0kzzo1i0y4jz6027t0k7aezc7\",\n  \"Version\": {\n    \"Index\": 71\n  },\n  \"CreatedAt\": \"2016-06-07T21:07:31.171892745Z\",\n  \"UpdatedAt\": \"2016-06-07T21:07:31.376370513Z\",\n  \"Name\": \"hopeful_cori\",\n  \"Spec\": {\n    \"ContainerSpec\": {\n      \"Image\": \"redis\"\n    },\n    \"Resources\": {\n      \"Limits\": {},\n      \"Reservations\": {}\n    },\n    \"RestartPolicy\": {\n      \"Condition\": \"ANY\"\n    },\n    \"Placement\": {}\n  },\n  \"ServiceID\": \"9mnpnzenvg8p8tdbtq4wvbkcz\",\n  \"Instance\": 1,\n  \"NodeID\": \"24ifsmvkjbyhk\",\n  \"ServiceAnnotations\": {},\n  \"Status\": {\n    \"Timestamp\": \"2016-06-07T21:07:31.290032978Z\",\n    \"State\": \"FAILED\",\n    \"Message\": \"execution failed\",\n    \"ContainerStatus\": {}\n  },\n  \"DesiredState\": \"SHUTDOWN\",\n  \"NetworksAttachments\": [\n    {\n      \"Network\": {\n        \"ID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n        \"Version\": {\n          \"Index\": 18\n        },\n        \"CreatedAt\": \"2016-06-07T20:31:11.912919752Z\",\n        \"UpdatedAt\": \"2016-06-07T21:07:29.955277358Z\",\n        \"Spec\": {\n          \"Name\": \"ingress\",\n          \"Labels\": {\n            \"com.docker.swarm.internal\": \"true\"\n          },\n          \"DriverConfiguration\": {},\n          \"IPAM\": {\n            \"Driver\": {},\n            \"Configs\": [\n              {\n                \"Family\": \"UNKNOWN\",\n                \"Subnet\": \"10.255.0.0/16\"\n              }\n            ]\n          }\n        },\n        \"DriverState\": {\n          \"Name\": \"overlay\",\n          \"Options\": {\n            \"com.docker.network.driver.overlay.vxlanid_list\": \"256\"\n          }\n        },\n        \"IPAM\": {\n          \"Driver\": {\n            \"Name\": \"default\"\n          },\n          \"Configs\": [\n            {\n              \"Family\": \"UNKNOWN\",\n              \"Subnet\": \"10.255.0.0/16\"\n            }\n          ]\n        }\n      },\n      \"Addresses\": [\n        \"10.255.0.10/16\"\n      ]\n    }\n  ],\n  \"Endpoint\": {\n    \"Spec\": {},\n    \"ExposedPorts\": [\n      {\n        \"Protocol\": \"tcp\",\n        \"Port\": 6379,\n        \"PublicPort\": 30000\n      }\n    ],\n    \"VirtualIPs\": [\n      {\n        \"NetworkID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n        \"Addr\": \"10.255.0.2/16\"\n      },\n      {\n        \"NetworkID\": \"4qvuz4ko70xaltuqbt8956gd1\",\n        \"Addr\": \"10.255.0.3/16\"\n      }\n    ]\n  }\n}`\n\n\tvar expected swarm.Task\n\terr := json.Unmarshal([]byte(jsonTask), &expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: jsonTask, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tid := \"0kzzo1i0y4jz6027t0k7aezc7\"\n\ttask, err := client.InspectTask(id)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(*task, expected) {\n\t\tt.Errorf(\"InspectTask(%q): Expected %#v. Got %#v.\", id, expected, task)\n\t}\n\texpectedURL, _ := url.Parse(client.getURL(\"/tasks/0kzzo1i0y4jz6027t0k7aezc7\"))\n\tif gotPath := fakeRT.requests[0].URL.Path; gotPath != expectedURL.Path {\n\t\tt.Errorf(\"InspectTask(%q): Wrong path in request. Want %q. Got %q.\", id, expectedURL.Path, gotPath)\n\t}\n}\n\nfunc TestInspectTaskNotFound(t *testing.T) {\n\tt.Parallel()\n\tconst taskID = \"notfound\"\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such task\", status: http.StatusNotFound})\n\ttask, err := client.InspectTask(taskID)\n\tif task != nil {\n\t\tt.Errorf(\"InspectTask: Expected <nil> task, got %#v\", task)\n\t}\n\tvar taskErr *NoSuchTask\n\tif !errors.As(err, &taskErr) {\n\t\tt.Fatalf(\"InspectTask: wrong error tyope returned. Want %#v. Got %#v.\", taskErr, err)\n\t}\n\tif taskErr.ID != taskID {\n\t\tt.Errorf(\"wrong taskID\\nwant %q\\ngot  %q\", taskID, taskErr.ID)\n\t}\n}\n"
        },
        {
          "name": "swarm_test.go",
          "type": "blob",
          "size": 7.142578125,
          "content": "// Copyright 2016 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\nfunc TestInitSwarm(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: `\"body\"`, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tresponse, err := client.InitSwarm(InitSwarmOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodPost\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"InitSwarm: Wrong HTTP method. Want %s. Got %s.\", expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/swarm/init\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"InitSwarm: Wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpected := \"body\"\n\tif response != expected {\n\t\tt.Errorf(\"InitSwarm: Wrong response. Want %q. Got %q.\", expected, response)\n\t}\n}\n\nfunc TestInitSwarmAlreadyInSwarm(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusNotAcceptable})\n\t_, err := client.InitSwarm(InitSwarmOptions{})\n\tif !errors.Is(err, ErrNodeAlreadyInSwarm) {\n\t\tt.Errorf(\"InitSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeAlreadyInSwarm, err)\n\t}\n\tclient = newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusServiceUnavailable})\n\t_, err = client.InitSwarm(InitSwarmOptions{})\n\tif !errors.Is(err, ErrNodeAlreadyInSwarm) {\n\t\tt.Errorf(\"InitSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeAlreadyInSwarm, err)\n\t}\n}\n\nfunc TestJoinSwarm(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\terr := client.JoinSwarm(JoinSwarmOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodPost\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"JoinSwarm: Wrong HTTP method. Want %s. Got %s.\", expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/swarm/join\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"JoinSwarm: Wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestJoinSwarmAlreadyInSwarm(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusNotAcceptable})\n\terr := client.JoinSwarm(JoinSwarmOptions{})\n\tif !errors.Is(err, ErrNodeAlreadyInSwarm) {\n\t\tt.Errorf(\"JoinSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeAlreadyInSwarm, err)\n\t}\n\tclient = newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusServiceUnavailable})\n\terr = client.JoinSwarm(JoinSwarmOptions{})\n\tif !errors.Is(err, ErrNodeAlreadyInSwarm) {\n\t\tt.Errorf(\"JoinSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeAlreadyInSwarm, err)\n\t}\n}\n\nfunc TestLeaveSwarm(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\ttestData := []struct {\n\t\tforce       bool\n\t\texpectedURI string\n\t}{\n\t\t{false, \"/swarm/leave?force=false\"},\n\t\t{true, \"/swarm/leave?force=true\"},\n\t}\n\tfor i, tt := range testData {\n\t\terr := client.LeaveSwarm(LeaveSwarmOptions{Force: tt.force})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\texpectedMethod := http.MethodPost\n\t\treq := fakeRT.requests[i]\n\t\tif req.Method != expectedMethod {\n\t\t\tt.Errorf(\"LeaveSwarm: Wrong HTTP method. Want %s. Got %s.\", expectedMethod, req.Method)\n\t\t}\n\t\texpected, _ := url.Parse(client.getURL(tt.expectedURI))\n\t\tif req.URL.String() != expected.String() {\n\t\t\tt.Errorf(\"LeaveSwarm: Wrong request string. Want %q. Got %q.\", expected.String(), req.URL.String())\n\t\t}\n\t}\n}\n\nfunc TestLeaveSwarmNotInSwarm(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusNotAcceptable})\n\terr := client.LeaveSwarm(LeaveSwarmOptions{})\n\tif !errors.Is(err, ErrNodeNotInSwarm) {\n\t\tt.Errorf(\"LeaveSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeNotInSwarm, err)\n\t}\n\tclient = newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusServiceUnavailable})\n\terr = client.LeaveSwarm(LeaveSwarmOptions{})\n\tif !errors.Is(err, ErrNodeNotInSwarm) {\n\t\tt.Errorf(\"LeaveSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeNotInSwarm, err)\n\t}\n}\n\nfunc TestUpdateSwarm(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\topts := UpdateSwarmOptions{\n\t\tVersion:            10,\n\t\tRotateManagerToken: true,\n\t\tRotateWorkerToken:  false,\n\t}\n\terr := client.UpdateSwarm(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodPost\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"UpdateSwarm: Wrong HTTP method. Want %s. Got %s.\", expectedMethod, req.Method)\n\t}\n\texpectedPath := \"/swarm/update\"\n\tif req.URL.Path != expectedPath {\n\t\tt.Errorf(\"UpdateSwarm: Wrong request path. Want %q. Got %q.\", expectedPath, req.URL.Path)\n\t}\n\texpected := map[string][]string{\n\t\t\"version\":            {\"10\"},\n\t\t\"rotateManagerToken\": {\"true\"},\n\t\t\"rotateWorkerToken\":  {\"false\"},\n\t}\n\tgot := map[string][]string(req.URL.Query())\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"UpdateSwarm: Wrong request query. Want %v. Got %v\", expected, got)\n\t}\n}\n\nfunc TestUpdateSwarmNotInSwarm(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusNotAcceptable})\n\terr := client.UpdateSwarm(UpdateSwarmOptions{})\n\tif !errors.Is(err, ErrNodeNotInSwarm) {\n\t\tt.Errorf(\"UpdateSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeNotInSwarm, err)\n\t}\n\tclient = newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusServiceUnavailable})\n\terr = client.UpdateSwarm(UpdateSwarmOptions{})\n\tif !errors.Is(err, ErrNodeNotInSwarm) {\n\t\tt.Errorf(\"UpdateSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeNotInSwarm, err)\n\t}\n}\n\nfunc TestInspectSwarm(t *testing.T) {\n\tt.Parallel()\n\tfakeRT := &FakeRoundTripper{message: `{\"ID\": \"123\"}`, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tresponse, err := client.InspectSwarm(context.TODO())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodGet\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"InspectSwarm: Wrong HTTP method. Want %s. Got %s.\", expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/swarm\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"InspectSwarm: Wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n\texpected := swarm.Swarm{ClusterInfo: swarm.ClusterInfo{ID: \"123\"}}\n\tif !reflect.DeepEqual(expected, response) {\n\t\tt.Errorf(\"InspectSwarm: Wrong response. Want %#v. Got %#v.\", expected, response)\n\t}\n}\n\nfunc TestInspectSwarmNotInSwarm(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusNotAcceptable})\n\t_, err := client.InspectSwarm(context.TODO())\n\tif !errors.Is(err, ErrNodeNotInSwarm) {\n\t\tt.Errorf(\"InspectSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeNotInSwarm, err)\n\t}\n\tclient = newTestClient(&FakeRoundTripper{message: \"\", status: http.StatusServiceUnavailable})\n\t_, err = client.InspectSwarm(context.TODO())\n\tif !errors.Is(err, ErrNodeNotInSwarm) {\n\t\tt.Errorf(\"InspectSwarm: Wrong error type. Want %#v. Got %#v\", ErrNodeNotInSwarm, err)\n\t}\n}\n"
        },
        {
          "name": "system.go",
          "type": "blob",
          "size": 2.1171875,
          "content": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\n// VolumeUsageData represents usage data from the docker system api\n// More Info Here https://dockr.ly/2PNzQyO\ntype VolumeUsageData struct {\n\t// The number of containers referencing this volume. This field\n\t// is set to `-1` if the reference-count is not available.\n\t//\n\t// Required: true\n\tRefCount int64 `json:\"RefCount\"`\n\n\t// Amount of disk space used by the volume (in bytes). This information\n\t// is only available for volumes created with the `\"local\"` volume\n\t// driver. For volumes created with other volume drivers, this field\n\t// is set to `-1` (\"not available\")\n\t//\n\t// Required: true\n\tSize int64 `json:\"Size\"`\n}\n\n// ImageSummary represents data about what images are\n// currently known to docker\n// More Info Here https://dockr.ly/2PNzQyO\ntype ImageSummary struct {\n\tContainers  int64             `json:\"Containers\"`\n\tCreated     int64             `json:\"Created\"`\n\tID          string            `json:\"Id\"`\n\tLabels      map[string]string `json:\"Labels\"`\n\tParentID    string            `json:\"ParentId\"`\n\tRepoDigests []string          `json:\"RepoDigests\"`\n\tRepoTags    []string          `json:\"RepoTags\"`\n\tSharedSize  int64             `json:\"SharedSize\"`\n\tSize        int64             `json:\"Size\"`\n\tVirtualSize int64             `json:\"VirtualSize\"`\n}\n\n// DiskUsage holds information about what docker is using disk space on.\n// More Info Here https://dockr.ly/2PNzQyO\ntype DiskUsage struct {\n\tLayersSize int64\n\tImages     []*ImageSummary\n\tContainers []*APIContainers\n\tVolumes    []*Volume\n}\n\n// DiskUsageOptions only contains a context for canceling.\ntype DiskUsageOptions struct {\n\tContext context.Context\n}\n\n// DiskUsage returns a *DiskUsage describing what docker is using disk on.\n//\n// More Info Here https://dockr.ly/2PNzQyO\nfunc (c *Client) DiskUsage(opts DiskUsageOptions) (*DiskUsage, error) {\n\tpath := \"/system/df\"\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar du *DiskUsage\n\tif err := json.NewDecoder(resp.Body).Decode(&du); err != nil {\n\t\treturn nil, err\n\t}\n\treturn du, nil\n}\n"
        },
        {
          "name": "system_test.go",
          "type": "blob",
          "size": 2.7998046875,
          "content": "// Copyright 2015 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDiskUsage(t *testing.T) {\n\tt.Parallel()\n\tduData := `\n{\n  \"LayersSize\": 17667551166,\n  \"Images\": [\n    {\n      \"Containers\": 7,\n      \"Created\": 1536130571,\n      \"Id\": \"sha256:056f6f1952204e38bd67cd2901c0cb2fc4cc8b640d1264814a9916b33eb34794\",\n      \"Labels\": null,\n      \"ParentId\": \"\",\n      \"RepoDigests\": [\n        \"fnproject/fn-test-utils@sha256:2ce83a86519d48b4f0deec062887c8aebf483708f4b87c0756a7cb108ecc98f8\"\n      ],\n      \"RepoTags\": [\n        \"fnproject/fn-test-utils:latest\"\n      ],\n      \"SharedSize\": 4413370,\n      \"Size\": 10861179,\n      \"VirtualSize\": 10861179\n    }\n  ],\n  \"Containers\": [\n    {\n      \"Id\": \"52bd62a82a72d8db8162eeef45a15dbec0a9066903631bff99a02c5e8dafcb3c\",\n      \"Names\": [\n        \"/0_prefork_01CP3AMNDS0000000000000001\"\n      ],\n      \"Image\": \"busybox\",\n      \"ImageID\": \"sha256:e1ddd7948a1c31709a23cc5b7dfe96e55fc364f90e1cebcde0773a1b5a30dcda\",\n      \"Command\": \"tail -f /dev/null\",\n      \"Created\": 1535562634,\n      \"Ports\": [],\n      \"SizeRootFs\": 1162769,\n      \"Labels\": {},\n      \"State\": \"running\",\n      \"Status\": \"Up 2 weeks\",\n      \"HostConfig\": {\n        \"NetworkMode\": \"default\"\n      },\n      \"NetworkSettings\": {\n        \"Networks\": {\n          \"bridge\": {\n            \"IPAMConfig\": null,\n            \"Links\": null,\n            \"Aliases\": null,\n            \"NetworkID\": \"2e879f7f3faba9c4970920e31b1185cadccb8a5c564a8393871c5ae114c49b39\",\n            \"EndpointID\": \"853c2b7bc4e7bd47834a45d0c93465ffaecea09103fcf4caa098c88b974f4124\",\n            \"Gateway\": \"172.17.0.1\",\n            \"IPAddress\": \"172.17.0.5\",\n            \"IPPrefixLen\": 16,\n            \"IPv6Gateway\": \"\",\n            \"GlobalIPv6Address\": \"\",\n            \"GlobalIPv6PrefixLen\": 0,\n            \"MacAddress\": \"02:42:ac:11:00:05\",\n            \"DriverOpts\": null\n          }\n        }\n      },\n      \"Mounts\": []\n    }\n  ],\n  \"Volumes\": [\n    {\n      \"CreatedAt\": \"2018-07-18T11:17:34-07:00\",\n      \"Driver\": \"local\",\n      \"Labels\": null,\n      \"Mountpoint\": \"\",\n      \"Name\": \"1284e17abce1d43818d7136849095c6a449a8dcfbaa859c2ff7c40abc75653eb\",\n      \"Options\": {},\n      \"Scope\": \"local\",\n      \"UsageData\": {\n        \"RefCount\": 0,\n        \"Size\": 0\n      }\n    }\n  ],\n  \"BuilderSize\": 0\n}\n\n`\n\tvar expected *DiskUsage\n\tif err := json.Unmarshal([]byte(duData), &expected); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: duData, status: http.StatusOK})\n\tdu, err := client.DiskUsage(DiskUsageOptions{})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !reflect.DeepEqual(du, expected) {\n\t\tt.Errorf(\"DiskUsage: Wrong return value. Want %#v. Got %#v.\", expected, du)\n\t}\n}\n"
        },
        {
          "name": "tar.go",
          "type": "blob",
          "size": 3.318359375,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/docker/docker/pkg/archive\"\n\t\"github.com/moby/patternmatcher\"\n)\n\nfunc createTarStream(srcPath, dockerfilePath string) (io.ReadCloser, error) {\n\tsrcPath, err := filepath.Abs(srcPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\texcludes, err := parseDockerignore(srcPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tincludes := []string{\".\"}\n\n\t// If .dockerignore mentions .dockerignore or the Dockerfile\n\t// then make sure we send both files over to the daemon\n\t// because Dockerfile is, obviously, needed no matter what, and\n\t// .dockerignore is needed to know if either one needs to be\n\t// removed.  The deamon will remove them for us, if needed, after it\n\t// parses the Dockerfile.\n\t//\n\t// https://github.com/docker/docker/issues/8330\n\t//\n\tforceIncludeFiles := []string{\".dockerignore\", dockerfilePath}\n\n\tfor _, includeFile := range forceIncludeFiles {\n\t\tif includeFile == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tkeepThem, err := patternmatcher.Matches(includeFile, excludes)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot match .dockerfileignore: '%s', error: %w\", includeFile, err)\n\t\t}\n\t\tif keepThem {\n\t\t\tincludes = append(includes, includeFile)\n\t\t}\n\t}\n\n\tif err := validateContextDirectory(srcPath, excludes); err != nil {\n\t\treturn nil, err\n\t}\n\ttarOpts := &archive.TarOptions{\n\t\tExcludePatterns: excludes,\n\t\tIncludeFiles:    includes,\n\t\tCompression:     archive.Uncompressed,\n\t\tNoLchown:        true,\n\t}\n\treturn archive.TarWithOptions(srcPath, tarOpts)\n}\n\n// validateContextDirectory checks if all the contents of the directory\n// can be read and returns an error if some files can't be read.\n// Symlinks which point to non-existing files don't trigger an error\nfunc validateContextDirectory(srcPath string, excludes []string) error {\n\treturn filepath.Walk(filepath.Join(srcPath, \".\"), func(filePath string, f os.FileInfo, err error) error {\n\t\t// skip this directory/file if it's not in the path, it won't get added to the context\n\t\tif relFilePath, relErr := filepath.Rel(srcPath, filePath); relErr != nil {\n\t\t\treturn relErr\n\t\t} else if skip, matchErr := patternmatcher.Matches(relFilePath, excludes); matchErr != nil {\n\t\t\treturn matchErr\n\t\t} else if skip {\n\t\t\tif f.IsDir() {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif err != nil {\n\t\t\tif os.IsPermission(err) {\n\t\t\t\treturn fmt.Errorf(\"cannot stat %q: %w\", filePath, err)\n\t\t\t}\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// skip checking if symlinks point to non-existing files, such symlinks can be useful\n\t\t// also skip named pipes, because they hanging on open\n\t\tif f.Mode()&(os.ModeSymlink|os.ModeNamedPipe) != 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\tif !f.IsDir() {\n\t\t\tcurrentFile, err := os.Open(filePath)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"cannot open %q for reading: %w\", filePath, err)\n\t\t\t}\n\t\t\tcurrentFile.Close()\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc parseDockerignore(root string) ([]string, error) {\n\tvar excludes []string\n\tignore, err := os.ReadFile(path.Join(root, \".dockerignore\"))\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn excludes, fmt.Errorf(\"error reading .dockerignore: %w\", err)\n\t}\n\texcludes = strings.Split(string(ignore), \"\\n\")\n\n\treturn excludes, nil\n}\n"
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "tls.go",
          "type": "blob",
          "size": 2.8505859375,
          "content": "// Copyright 2014 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n//\n// The content is borrowed from Docker's own source code to provide a simple\n// tls based dialer\n\npackage docker\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype tlsClientCon struct {\n\t*tls.Conn\n\trawConn net.Conn\n}\n\nfunc (c *tlsClientCon) CloseWrite() error {\n\t// Go standard tls.Conn doesn't provide the CloseWrite() method so we do it\n\t// on its underlying connection.\n\tif cwc, ok := c.rawConn.(interface {\n\t\tCloseWrite() error\n\t}); ok {\n\t\treturn cwc.CloseWrite()\n\t}\n\treturn nil\n}\n\nfunc tlsDialWithDialer(dialer *net.Dialer, network, addr string, config *tls.Config) (net.Conn, error) {\n\t// We want the Timeout and Deadline values from dialer to cover the\n\t// whole process: TCP connection and TLS handshake. This means that we\n\t// also need to start our own timers now.\n\ttimeout := dialer.Timeout\n\n\tif !dialer.Deadline.IsZero() {\n\t\tdeadlineTimeout := time.Until(dialer.Deadline)\n\t\tif timeout == 0 || deadlineTimeout < timeout {\n\t\t\ttimeout = deadlineTimeout\n\t\t}\n\t}\n\n\tvar errChannel chan error\n\n\tif timeout != 0 {\n\t\terrChannel = make(chan error, 2)\n\t\ttime.AfterFunc(timeout, func() {\n\t\t\terrChannel <- errors.New(\"\")\n\t\t})\n\t}\n\n\trawConn, err := dialer.Dial(network, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcolonPos := strings.LastIndex(addr, \":\")\n\tif colonPos == -1 {\n\t\tcolonPos = len(addr)\n\t}\n\thostname := addr[:colonPos]\n\n\t// If no ServerName is set, infer the ServerName\n\t// from the hostname we're connecting to.\n\tif config.ServerName == \"\" {\n\t\t// Make a copy to avoid polluting argument or default.\n\t\tconfig = copyTLSConfig(config)\n\t\tconfig.ServerName = hostname\n\t}\n\n\tconn := tls.Client(rawConn, config)\n\n\tif timeout == 0 {\n\t\terr = conn.Handshake()\n\t} else {\n\t\tgo func() {\n\t\t\terrChannel <- conn.Handshake()\n\t\t}()\n\n\t\terr = <-errChannel\n\t}\n\n\tif err != nil {\n\t\trawConn.Close()\n\t\treturn nil, err\n\t}\n\n\t// This is Docker difference with standard's crypto/tls package: returned a\n\t// wrapper which holds both the TLS and raw connections.\n\treturn &tlsClientCon{conn, rawConn}, nil\n}\n\n// this exists to silent an error message in go vet\nfunc copyTLSConfig(cfg *tls.Config) *tls.Config {\n\treturn &tls.Config{\n\t\tCertificates:           cfg.Certificates,\n\t\tCipherSuites:           cfg.CipherSuites,\n\t\tClientAuth:             cfg.ClientAuth,\n\t\tClientCAs:              cfg.ClientCAs,\n\t\tClientSessionCache:     cfg.ClientSessionCache,\n\t\tCurvePreferences:       cfg.CurvePreferences,\n\t\tInsecureSkipVerify:     cfg.InsecureSkipVerify,\n\t\tMaxVersion:             cfg.MaxVersion,\n\t\tMinVersion:             cfg.MinVersion,\n\t\tNextProtos:             cfg.NextProtos,\n\t\tRand:                   cfg.Rand,\n\t\tRootCAs:                cfg.RootCAs,\n\t\tServerName:             cfg.ServerName,\n\t\tSessionTicketsDisabled: cfg.SessionTicketsDisabled,\n\t}\n}\n"
        },
        {
          "name": "volume.go",
          "type": "blob",
          "size": 5.400390625,
          "content": "// Copyright 2015 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar (\n\t// ErrNoSuchVolume is the error returned when the volume does not exist.\n\tErrNoSuchVolume = errors.New(\"no such volume\")\n\n\t// ErrVolumeInUse is the error returned when the volume requested to be removed is still in use.\n\tErrVolumeInUse = errors.New(\"volume in use and cannot be removed\")\n)\n\n// Volume represents a volume.\n//\n// See https://goo.gl/3wgTsd for more details.\ntype Volume struct {\n\tName       string            `json:\"Name\" yaml:\"Name\" toml:\"Name\"`\n\tDriver     string            `json:\"Driver,omitempty\" yaml:\"Driver,omitempty\" toml:\"Driver,omitempty\"`\n\tMountpoint string            `json:\"Mountpoint,omitempty\" yaml:\"Mountpoint,omitempty\" toml:\"Mountpoint,omitempty\"`\n\tLabels     map[string]string `json:\"Labels,omitempty\" yaml:\"Labels,omitempty\" toml:\"Labels,omitempty\"`\n\tOptions    map[string]string `json:\"Options,omitempty\" yaml:\"Options,omitempty\" toml:\"Options,omitempty\"`\n\tCreatedAt  time.Time         `json:\"CreatedAt,omitempty\" yaml:\"CreatedAt,omitempty\" toml:\"CreatedAt,omitempty\"`\n}\n\n// ListVolumesOptions specify parameters to the ListVolumes function.\n//\n// See https://goo.gl/3wgTsd for more details.\ntype ListVolumesOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// ListVolumes returns a list of available volumes in the server.\n//\n// See https://goo.gl/3wgTsd for more details.\nfunc (c *Client) ListVolumes(opts ListVolumesOptions) ([]Volume, error) {\n\tresp, err := c.do(http.MethodGet, \"/volumes?\"+queryString(opts), doOptions{\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tm := make(map[string]any)\n\tif err = json.NewDecoder(resp.Body).Decode(&m); err != nil {\n\t\treturn nil, err\n\t}\n\tvar volumes []Volume\n\tvolumesJSON, ok := m[\"Volumes\"]\n\tif !ok {\n\t\treturn volumes, nil\n\t}\n\tdata, err := json.Marshal(volumesJSON)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := json.Unmarshal(data, &volumes); err != nil {\n\t\treturn nil, err\n\t}\n\treturn volumes, nil\n}\n\n// CreateVolumeOptions specify parameters to the CreateVolume function.\n//\n// See https://goo.gl/qEhmEC for more details.\ntype CreateVolumeOptions struct {\n\tName       string\n\tDriver     string\n\tDriverOpts map[string]string\n\tContext    context.Context `json:\"-\"`\n\tLabels     map[string]string\n}\n\n// CreateVolume creates a volume on the server.\n//\n// See https://goo.gl/qEhmEC for more details.\nfunc (c *Client) CreateVolume(opts CreateVolumeOptions) (*Volume, error) {\n\tresp, err := c.do(http.MethodPost, \"/volumes/create\", doOptions{\n\t\tdata:    opts,\n\t\tcontext: opts.Context,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar volume Volume\n\tif err := json.NewDecoder(resp.Body).Decode(&volume); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &volume, nil\n}\n\n// InspectVolume returns a volume by its name.\n//\n// See https://goo.gl/GMjsMc for more details.\nfunc (c *Client) InspectVolume(name string) (*Volume, error) {\n\tresp, err := c.do(http.MethodGet, \"/volumes/\"+name, doOptions{})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) && e.Status == http.StatusNotFound {\n\t\t\treturn nil, ErrNoSuchVolume\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar volume Volume\n\tif err := json.NewDecoder(resp.Body).Decode(&volume); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &volume, nil\n}\n\n// RemoveVolume removes a volume by its name.\n//\n// Deprecated: Use RemoveVolumeWithOptions instead.\nfunc (c *Client) RemoveVolume(name string) error {\n\treturn c.RemoveVolumeWithOptions(RemoveVolumeOptions{Name: name})\n}\n\n// RemoveVolumeOptions specify parameters to the RemoveVolumeWithOptions\n// function.\n//\n// See https://goo.gl/nvd6qj for more details.\ntype RemoveVolumeOptions struct {\n\tContext context.Context\n\tName    string `qs:\"-\"`\n\tForce   bool\n}\n\n// RemoveVolumeWithOptions removes a volume by its name and takes extra\n// parameters.\n//\n// See https://goo.gl/nvd6qj for more details.\nfunc (c *Client) RemoveVolumeWithOptions(opts RemoveVolumeOptions) error {\n\tpath := \"/volumes/\" + opts.Name\n\tresp, err := c.do(http.MethodDelete, path+\"?\"+queryString(opts), doOptions{context: opts.Context})\n\tif err != nil {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) {\n\t\t\tif e.Status == http.StatusNotFound {\n\t\t\t\treturn ErrNoSuchVolume\n\t\t\t}\n\t\t\tif e.Status == http.StatusConflict {\n\t\t\t\treturn ErrVolumeInUse\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\treturn nil\n}\n\n// PruneVolumesOptions specify parameters to the PruneVolumes function.\n//\n// See https://goo.gl/f9XDem for more details.\ntype PruneVolumesOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n// PruneVolumesResults specify results from the PruneVolumes function.\n//\n// See https://goo.gl/f9XDem for more details.\ntype PruneVolumesResults struct {\n\tVolumesDeleted []string\n\tSpaceReclaimed int64\n}\n\n// PruneVolumes deletes volumes which are unused.\n//\n// See https://goo.gl/f9XDem for more details.\nfunc (c *Client) PruneVolumes(opts PruneVolumesOptions) (*PruneVolumesResults, error) {\n\tpath := \"/volumes/prune?\" + queryString(opts)\n\tresp, err := c.do(http.MethodPost, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar results PruneVolumesResults\n\tif err := json.NewDecoder(resp.Body).Decode(&results); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &results, nil\n}\n"
        },
        {
          "name": "volume_test.go",
          "type": "blob",
          "size": 5.90625,
          "content": "// Copyright 2015 go-dockerclient authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage docker\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListVolumes(t *testing.T) {\n\tt.Parallel()\n\tvolumesData := `[\n\t{\n\t\t\"Name\": \"tardis\",\n\t\t\"Driver\": \"local\",\n\t\t\"Mountpoint\": \"/var/lib/docker/volumes/tardis\",\n\t\t\"CreatedAt\": \"2017-07-19T12:00:26Z\"\n\t},\n\t{\n\t\t\"Name\": \"foo\",\n\t\t\"Driver\": \"bar\",\n\t\t\"Mountpoint\": \"/var/lib/docker/volumes/bar\",\n\t\t\"CreatedAt\": \"2017-07-19T12:01:26Z\"\n\t}\n]`\n\tbody := `{ \"Volumes\": ` + volumesData + ` }`\n\tvar expected []Volume\n\tif err := json.Unmarshal([]byte(volumesData), &expected); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: body, status: http.StatusOK})\n\tvolumes, err := client.ListVolumes(ListVolumesOptions{})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !reflect.DeepEqual(volumes, expected) {\n\t\tt.Errorf(\"ListVolumes: Wrong return value. Want %#v. Got %#v.\", expected, volumes)\n\t}\n}\n\nfunc TestCreateVolume(t *testing.T) {\n\tt.Parallel()\n\tbody := `{\n\t\t\"Name\": \"tardis\",\n\t\t\"Driver\": \"local\",\n\t\t\"Mountpoint\": \"/var/lib/docker/volumes/tardis\"\n\t}`\n\tvar expected Volume\n\tif err := json.Unmarshal([]byte(body), &expected); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: body, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tvolume, err := client.CreateVolume(\n\t\tCreateVolumeOptions{\n\t\t\tName:   \"tardis\",\n\t\t\tDriver: \"local\",\n\t\t\tDriverOpts: map[string]string{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(volume, &expected) {\n\t\tt.Errorf(\"CreateVolume: Wrong return value. Want %#v. Got %#v.\", expected, volume)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodPost\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"CreateVolume(): Wrong HTTP method. Want %s. Got %s.\", expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/volumes/create\"))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"CreateVolume(): Wrong request path. Want %q. Got %q.\", u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestInspectVolume(t *testing.T) {\n\tt.Parallel()\n\tbody := `{\n\t\t\"Name\": \"tardis\",\n\t\t\"Driver\": \"local\",\n\t\t\"Mountpoint\": \"/var/lib/docker/volumes/tardis\",\n\t\t\"Options\": {\n\t\t\t\"foo\": \"bar\"\n\t\t}\n\t}`\n\tvar expected Volume\n\tif err := json.Unmarshal([]byte(body), &expected); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfakeRT := &FakeRoundTripper{message: body, status: http.StatusOK}\n\tclient := newTestClient(fakeRT)\n\tname := \"tardis\"\n\tvolume, err := client.InspectVolume(name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(volume, &expected) {\n\t\tt.Errorf(\"InspectVolume: Wrong return value. Want %#v. Got %#v.\", expected, volume)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodGet\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"InspectVolume(%q): Wrong HTTP method. Want %s. Got %s.\", name, expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/volumes/\" + name))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"CreateVolume(%q): Wrong request path. Want %q. Got %q.\", name, u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestRemoveVolume(t *testing.T) {\n\tt.Parallel()\n\tname := \"test\"\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tif err := client.RemoveVolume(name); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodDelete\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"RemoveVolume(%q): Wrong HTTP method. Want %s. Got %s.\", name, expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/volumes/\" + name))\n\tif req.URL.Path != u.Path {\n\t\tt.Errorf(\"RemoveVolume(%q): Wrong request path. Want %q. Got %q.\", name, u.Path, req.URL.Path)\n\t}\n}\n\nfunc TestRemoveVolumeWithOptions(t *testing.T) {\n\tt.Parallel()\n\tname := \"test\"\n\tfakeRT := &FakeRoundTripper{message: \"\", status: http.StatusNoContent}\n\tclient := newTestClient(fakeRT)\n\tif err := client.RemoveVolumeWithOptions(RemoveVolumeOptions{\n\t\tName:  name,\n\t\tForce: true,\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treq := fakeRT.requests[0]\n\texpectedMethod := http.MethodDelete\n\tif req.Method != expectedMethod {\n\t\tt.Errorf(\"RemoveVolume(%q): Wrong HTTP method. Want %s. Got %s.\", name, expectedMethod, req.Method)\n\t}\n\tu, _ := url.Parse(client.getURL(\"/volumes/\" + name + \"?force=1\"))\n\tif req.URL.RequestURI() != u.RequestURI() {\n\t\tt.Errorf(\"RemoveVolume(%q): Wrong request path. Want %q. Got %q.\", name, u.RequestURI(), req.URL.RequestURI())\n\t}\n}\n\nfunc TestRemoveVolumeNotFound(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"no such volume\", status: http.StatusNotFound})\n\tif err := client.RemoveVolume(\"test:\"); !errors.Is(err, ErrNoSuchVolume) {\n\t\tt.Errorf(\"RemoveVolume: wrong error. Want %#v. Got %#v.\", ErrNoSuchVolume, err)\n\t}\n}\n\nfunc TestRemoveVolumeInternalError(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"something went wrong\", status: http.StatusInternalServerError})\n\tif err := client.RemoveVolume(\"test:test\"); err == nil {\n\t\tt.Error(\"RemoveVolume: unexpected <nil> error\")\n\t}\n}\n\nfunc TestRemoveVolumeInUse(t *testing.T) {\n\tt.Parallel()\n\tclient := newTestClient(&FakeRoundTripper{message: \"volume in use and cannot be removed\", status: http.StatusConflict})\n\tif err := client.RemoveVolume(\"test:\"); !errors.Is(err, ErrVolumeInUse) {\n\t\tt.Errorf(\"RemoveVolume: wrong error. Want %#v. Got %#v.\", ErrVolumeInUse, err)\n\t}\n}\n\nfunc TestPruneVolumes(t *testing.T) {\n\tt.Parallel()\n\tresults := `{\n\t\t\"VolumesDeleted\": [\n\t\t\t\"a\", \"b\", \"c\"\n\t\t],\n\t\t\"SpaceReclaimed\": 123\n\t}`\n\n\texpected := &PruneVolumesResults{}\n\terr := json.Unmarshal([]byte(results), expected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient := newTestClient(&FakeRoundTripper{message: results, status: http.StatusOK})\n\tgot, err := client.PruneVolumes(PruneVolumesOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"PruneContainers: Expected %#v. Got %#v.\", expected, got)\n\t}\n}\n"
        }
      ]
    }
  ]
}