{
  "metadata": {
    "timestamp": 1736567032617,
    "page": 613,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hexops/vecty",
      "stars": 2830,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0283203125,
          "content": "testdata/*.got.txt\n.DS_store\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 1.0703125,
          "content": "# This file contains our configuration for golangci-lint; see https://github.com/golangci/golangci-lint\n# for more information.\n\nlinters:\n  enable:\n    - golint\n\nissues:\n  # We do not use golangci-lint's default list of exclusions because some of\n  # them are not good for us (we prefer strictness):\n  #\n  # - Not requiring published functions to have comments.\n  # - Not warning about ineffective break statements.\n  # - And more that don't effect Vecty itself.\n  #\n  exclude-use-default: false\n\n  # List of regexps of issue texts to exclude, empty list by default.\n  exclude:\n    # https://github.com/hexops/vecty/issues/226\n    - \"comment on exported function Timeout should be of the form\"\n\n    # errcheck: Almost all programs ignore errors on these functions and in most cases it's ok\n    - Error return value of .((os\\.)?std(out|err)\\..*|.*Close|.*Flush|os\\.Remove(All)?|.*printf?|os\\.(Un)?Setenv). is not checked\n\n    # golint: False positive when tests are defined in package 'test'\n    - func name will be used as test\\.Test.* by other packages, and that stutters; consider calling this\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.0166015625,
          "content": "sudo: false\ninstall:\n  # Manually download and install Go because the Travis / gimme version has been broken in the past:\n  # https://travis-ci.community/t/goos-js-goarch-wasm-go-run-fails-panic-newosproc-not-implemented/1651/6\n  - wget -O go.tar.gz https://dl.google.com/go/go1.15.linux-amd64.tar.gz\n  - tar -C ~ -xzf go.tar.gz\n  - rm go.tar.gz\n  - export GOROOT=~/go\n  - export PATH=$GOROOT/bin:$PATH\n  - go version\n  - go env\n\n  # Install NodeJS (for testing WebAssembly support)\n  - nvm install 14.7.0\n\n  # Linters, etc.\n  - go get -u github.com/golangci/golangci-lint/cmd/golangci-lint\n  - go get -u github.com/haya14busa/goverage\n  - go get -u mvdan.cc/gofumpt\n  - go get -u mvdan.cc/gofumpt/gofumports\nscript:\n  # Fetch dependencies.\n  - go get -d .\n  - GOOS=js GOARCH=wasm go get -d ./...\n\n  # Ensure consistent code style.\n  - diff -u <(echo -n) <(gofumpt -d -s .)\n  - diff -u <(echo -n) <(gofumports -d .)\n\n  # Consult golangci-lint (multiple Go linting tools).\n  - golangci-lint run . ./elem/... ./event/...\n  - golangci-lint run --exclude 'exported .* should have comment .*or be unexported' ./prop/... ./style/... # https://github.com/hexops/vecty/issues/227\n  - GOOS=js GOARCH=wasm golangci-lint run --build-tags 'js wasm' . ./elem/... ./event/...\n  - GOOS=js GOARCH=wasm golangci-lint run --build-tags 'js wasm' --exclude 'exported .* should have comment .*or be unexported' ./prop/... ./style/... # https://github.com/hexops/vecty/issues/227\n  - bash -c 'cd example && golangci-lint run ./markdown'\n  - bash -c 'cd example && GOOS=js GOARCH=wasm golangci-lint run --build-tags 'js wasm' ./...'\n\n  # Test with Go compiler (under amd64 and wasm architectures.)\n  - go test -race ./...\n  - GOOS=js GOARCH=wasm go test -exec=\"$(go env GOROOT)/misc/wasm/go_js_wasm_exec\" ./...\n\n  # Generate and upload coverage to codecov.io\n  - goverage -covermode=atomic -coverprofile=coverage.out $(go list ./... | grep -v -e vecty/elem -e vecty/event -e vecty/example -e vecty/prop -e vecty/style)\n  - include_cov=coverage.out bash <(curl -s https://codecov.io/bash)\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.66015625,
          "content": "# Names should be added to this file like so:\n#\n#  Jane Doe <jane@gmail.com>\n#  Jane Doe <preferred_link>\n#  Jane Doe <jane@gmail.com> <preferred_link>\n#\n# <preferred_link> may be the person's website, GitHub profile, or GitHub\n# project related to their contribution to Vecty.\n\n# Please keep the list sorted.\n\nAndrea Manzini <ilmanzo@gmail.com> <github.com/ilmanzo>\nIgor Afanasyev <github.com/iafan/vecty-logo>\nPeter Fern <golang+vecty@0xc0dedbad.com> <github.com/pdf>\nStephen Gutekanst <stephen.gutekanst@gmail.com> <github.com/slimsag>\nThomas Bruyelle <thomas.bruyelle@gmail.com> <github.com/tbruyelle>\nMarwan Sulaiman <marwan.sameer@gmail.com> <github.com/marwan-at-work>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.44140625,
          "content": "Copyright (c) 2016 The Vecty Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Vecty nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.5576171875,
          "content": "<p align=\"center\">\n\t<img src=\"https://github.com/vecty/vecty-logo/raw/master/horizontal_color_tagline.png\" />\n</p>\n\nVecty lets you build responsive and dynamic web frontends in Go using WebAssembly, competing with modern web frameworks like React & VueJS.\n\n[![Build Status](https://travis-ci.org/hexops/vecty.svg?branch=master)](https://travis-ci.org/hexops/vecty) [![PkgGoDev](https://pkg.go.dev/badge/github.com/hexops/vecty)](https://pkg.go.dev/github.com/hexops/vecty) [![GoDoc](https://godoc.org/github.com/hexops/vecty?status.svg)](https://godoc.org/github.com/hexops/vecty) [![codecov](https://img.shields.io/codecov/c/github/hexops/vecty/master.svg)](https://codecov.io/gh/hexops/vecty)\n\nBenefits\n========\n\n- Go developers can be competitive frontend developers.\n- Share Go code between your frontend & backend.\n- Reusability by sharing components via Go packages so that others can simply import them.\n\nGoals\n=====\n\n- _Simple_\n\t- Designed from the ground up to be easily mastered _by newcomers_ (like Go).\n- _Performant_\n\t- Efficient & understandable performance, small bundle sizes, same performance as raw JS/HTML/CSS.\n- _Composable_\n\t- Nest components to form your entire user interface, seperating them logically as you would any normal Go package.\n- _Designed for Go (implicit)_\n\t- Written from the ground up asking the question _\"What is the best way to solve this problem in Go?\"_, not simply asking _\"How do we translate $POPULAR_LIBRARY to Go?\"_\n\nFeatures\n========\n\n- Compiles to WebAssembly (via standard Go compiler).\n- Small bundle sizes: 0.5 MB hello world (see section below).\n- Fast expectation-based browser DOM diffing ('virtual DOM', but less resource usage).\n\nVecty vs. Vugu\n==============\n\nIf you're wondering if you should use Vecty or [Vugu](https://www.vugu.org/), consider reading [this Twitter thread](https://twitter.com/JohanBrandhorst/status/1452393594283831297) for advice from both myself and the creator of Vugu.\n\nCurrent Status\n==============\n\n**Vecty is currently considered to be an experimental work-in-progress.** Prior to widespread production use, we must meet our [v1.0.0 milestone](https://github.com/hexops/vecty/issues?q=is%3Aopen+is%3Aissue+milestone%3A1.0.0) goals, which are being completed slowly and steadily as contributors have time (Vecty is over 4 years in the making!).\n\nEarly adopters may make use of it for real applications today as long as they are understanding and accepting of the fact that:\n\n- APIs will change (maybe extensively).\n- A number of important things are not ready:\n\t- Extensive documentation, examples and tutorials\n\t- URL-based component routing\n\t- Ready-to-use component libraries (e.g. material UI)\n\t- Server-side rendering\n\t- And more, see [milestone: v1.0.0 ](https://github.com/hexops/vecty/issues?q=is%3Aopen+is%3Aissue+milestone%3A1.0.0)\n- The scope of Vecty is only ~80% defined currently.\n- There are a number of important [open issues](https://github.com/hexops/vecty/issues).\n\nFor a list of projects currently using Vecty, see the [doc/projects-using-vecty.md](doc/projects-using-vecty.md) file.\n\nNear-zero dependencies\n======================\n\nVecty has nearly zero dependencies, it only relies on `reflect` from the Go stdlib. Through this, it is able to produce the smallest bundle sizes for Go frontend applications out there, limited only by the Go compiler itself:\n\n| Example binary    | Compiler        | uncompressed | `gzip --best` | `brotli` |\n|-------------------|-----------------|--------------|---------------|----------|\n| `hellovecty.wasm` | `tinygo 0.14.0` | 252K         | 97K           | 81K      |\n| `hellovecty.wasm` | `go 1.15`       | 2.1M         | 587K          | 443K     |\n| `markdown.wasm`   | `go 1.19`       | 5.9M         | 1.3M          | 952K     |\n| `todomvc.wasm`    | `go 1.15`       | 2.9M         | 825K          | 617K     |\n\nYou can find these examples under the [example](./example) directory along with a readme on how to go about running a vecty project.\n\nNote: Bundle sizes above do not scale linearly with more code/dependencies in your Vecty project. `hellovecty` is the smallest base-line bundle that the compiler can produce with just Vecty as a dependency, other examples above pull in more of the Go standard library and you would not e.g. have to pay that total cost again.\n\nCommunity\n=========\n\n- Join us in the [#vecty](https://gophers.slack.com/messages/vecty/) channel on the [Gophers Slack](https://gophersinvite.herokuapp.com/)!\n- See what [projects use Vecty in the wild](https://github.com/hexops/vecty/blob/main/doc/projects-using-vecty.md)\n\nChangelog\n=========\n\nSee the [doc/CHANGELOG.md](doc/CHANGELOG.md) file.\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "dom.go",
          "type": "blob",
          "size": 39.111328125,
          "content": "package vecty\n\nimport (\n\t\"reflect\"\n)\n\n// batch renderer singleton\nvar batch = &batchRenderer{idx: make(map[Component]int)}\n\n// Core implements the Context method of the Component interface, and is the\n// core/central struct which all Component implementations should embed.\ntype Core struct {\n\tprevRenderComponent Component\n\tprevRender          ComponentOrHTML\n\tmounted, unmounted  bool\n}\n\n// Context implements the Component interface.\nfunc (c *Core) Context() *Core { return c }\n\n// isMarkupOrChild implements MarkupOrChild\nfunc (c *Core) isMarkupOrChild() {}\n\n// isComponentOrHTML implements ComponentOrHTML\nfunc (c *Core) isComponentOrHTML() {}\n\n// Component represents a single visual component within an application. To\n// define a new component simply implement the Render method and embed the Core\n// struct:\n//\n// \ttype MyComponent struct {\n// \t\tvecty.Core\n// \t\t... additional component fields (state or properties) ...\n// \t}\n//\n// \tfunc (c *MyComponent) Render() vecty.ComponentOrHTML {\n// \t\t... rendering ...\n// \t}\n//\ntype Component interface {\n\t// Render is responsible for building HTML which represents the component.\n\t//\n\t// If Render returns nil, the component will render as nothing (in reality,\n\t// a noscript tag, which has no display or action, and is compatible with\n\t// Vecty's diffing algorithm).\n\tRender() ComponentOrHTML\n\n\t// Context returns the components context, which is used internally by\n\t// Vecty in order to store the previous component render for diffing.\n\tContext() *Core\n\n\tisComponentOrHTML()\n\tisMarkupOrChild()\n}\n\n// Copier is an optional interface that a Component can implement in order to\n// copy itself. Vecty must internally copy components, and it does so by either\n// invoking the Copy method of the Component or, if the component does not\n// implement the Copier interface, a shallow copy is performed.\n//\n// TinyGo: If compiling your Vecty application using the experimental TinyGo\n// support (https://github.com/hexops/vecty/pull/243) then all components must\n// implement at least a shallow-copy Copier interface (this is not required\n// otherwise):\n//\n// \tfunc (c *MyComponent) Copy() vecty.Component {\n// \t\tcpy := *c\n// \t\treturn &cpy\n// \t}\n//\ntype Copier interface {\n\t// Copy returns a copy of the component.\n\tCopy() Component\n}\n\n// Mounter is an optional interface that a Component can implement in order\n// to receive component mount events.\ntype Mounter interface {\n\t// Mount is called after the component has been mounted, after the DOM node\n\t// has been attached.\n\tMount()\n}\n\n// Unmounter is an optional interface that a Component can implement in order\n// to receive component unmount events.\ntype Unmounter interface {\n\t// Unmount is called before the component has been unmounted, before the\n\t// DOM node has been removed.\n\tUnmount()\n}\n\n// Keyer is an optional interface that a Component can implement in order to\n// uniquely identify the component amongst its siblings. If implemented, all\n// siblings, both components and HTML, must also be keyed.\n//\n// Implementing this interface allows siblings to be removed or re-ordered\n// whilst retaining state, and improving render efficiency.\ntype Keyer interface {\n\t// Key returns a value that uniquely identifies the component amongst its\n\t// siblings. The returned type must be a valid map key, or rendering will\n\t// panic.\n\tKey() interface{}\n}\n\n// ComponentOrHTML represents one of:\n//\n//  Component\n//  *HTML\n//  List\n//  KeyedList\n//  nil\n//\n// An unexported method on this interface ensures at compile time that the\n// underlying value must be one of these types.\ntype ComponentOrHTML interface {\n\tisComponentOrHTML()\n\tisMarkupOrChild()\n}\n\n// RenderSkipper is an optional interface that Component's can implement in\n// order to short-circuit the reconciliation of a Component's rendered body.\n//\n// This is purely an optimization, and does not need to be implemented by\n// Components for correctness. Without implementing this interface, only the\n// difference between renders will be applied to the browser DOM. This\n// interface allows components to bypass calculating the difference altogether\n// and quickly state \"nothing has changed, do not re-render\".\ntype RenderSkipper interface {\n\t// SkipRender is called with a copy of the Component made the last time its\n\t// Render method was invoked. If it returns true, rendering of the\n\t// component will be skipped.\n\t//\n\t// The previous component may be of a different type than this\n\t// RenderSkipper itself, thus a type assertion should be used and no action\n\t// taken if the type does not match.\n\tSkipRender(prev Component) bool\n}\n\n// HTML represents some form of HTML: an element with a specific tag, or some\n// literal text (a TextNode).\ntype HTML struct {\n\tnode jsObject\n\n\tnamespace, tag, text, innerHTML string\n\tclasses                         map[string]struct{}\n\tstyles, dataset                 map[string]string\n\tproperties, attributes          map[string]interface{}\n\teventListeners                  []*EventListener\n\tchildren                        []ComponentOrHTML\n\tkey                             interface{}\n\t// keyedChildren stores a map of keys to children, for keyed reconciliation.\n\tkeyedChildren map[interface{}]ComponentOrHTML\n\t// insertBeforeNode tracks the DOM node that elements should be inserted\n\t// before, across List boundaries.\n\tinsertBeforeNode jsObject\n\t// lastRendered child tracks the last child that was rendered, across List\n\t// boundaries.\n\tlastRenderedChild *HTML\n}\n\n// Key implements the Keyer interface.\nfunc (h *HTML) Key() interface{} {\n\treturn h.key\n}\n\n// isMarkupOrChild implements MarkupOrChild\nfunc (h *HTML) isMarkupOrChild() {}\n\n// isComponentOrHTML implements ComponentOrHTML\nfunc (h *HTML) isComponentOrHTML() {}\n\n// createNode creates a HTML node of the appropriate type and namespace.\nfunc (h *HTML) createNode() {\n\tswitch {\n\tcase h.tag != \"\" && h.text != \"\":\n\t\tpanic(\"vecty: internal error (only one of HTML.tag or HTML.text may be set)\")\n\tcase h.tag == \"\" && h.innerHTML != \"\":\n\t\tpanic(\"vecty: only HTML may have UnsafeHTML attribute\")\n\tcase h.tag != \"\" && h.namespace == \"\":\n\t\th.node = global().Get(\"document\").Call(\"createElement\", h.tag)\n\tcase h.tag != \"\" && h.namespace != \"\":\n\t\th.node = global().Get(\"document\").Call(\"createElementNS\", h.namespace, h.tag)\n\tdefault:\n\t\th.node = global().Get(\"document\").Call(\"createTextNode\", h.text)\n\t}\n}\n\n// reconcileText replaces the content of a text node.\nfunc (h *HTML) reconcileText(prev *HTML) {\n\th.node = prev.node\n\n\t// Text modifications.\n\tif h.text != prev.text {\n\t\th.node.Set(\"nodeValue\", h.text)\n\t}\n}\n\nfunc (h *HTML) reconcile(prev *HTML) []Mounter {\n\t// Check for compatible tag and mutate previous instance on match, otherwise start fresh\n\tswitch {\n\tcase prev != nil && h.tag == \"\" && prev.tag == \"\":\n\t\t// Compatible text node\n\t\th.reconcileText(prev)\n\t\treturn nil\n\tcase prev != nil && h.tag != \"\" && prev.tag != \"\" && h.tag == prev.tag && h.namespace == prev.namespace:\n\t\t// Compatible element node\n\t\th.node = prev.node\n\tdefault:\n\t\t// Incompatible node, start fresh\n\t\tif prev == nil {\n\t\t\tprev = &HTML{}\n\t\t}\n\t\th.createNode()\n\t}\n\n\tif !h.node.Equal(prev.node) {\n\t\t// reconcile properties against empty prev for new nodes.\n\t\th.reconcileProperties(&HTML{})\n\t} else {\n\t\th.reconcileProperties(prev)\n\t}\n\n\treturn h.reconcileChildren(prev)\n}\n\n// reconcileProperties updates properties/attributes/etc to match the current\n// element.\nfunc (h *HTML) reconcileProperties(prev *HTML) {\n\t// If nodes match, remove any outdated properties\n\tif h.node.Equal(prev.node) {\n\t\th.removeProperties(prev)\n\t}\n\th.tinyGoCannotIterateNilMaps()\n\n\t// Wrap event listeners\n\tfor _, l := range h.eventListeners {\n\t\tl := l\n\t\tl.wrapper = funcOf(func(this jsObject, args []jsObject) interface{} {\n\t\t\tjsEvent := args[0]\n\t\t\tif l.callPreventDefault {\n\t\t\t\tjsEvent.Call(\"preventDefault\")\n\t\t\t}\n\t\t\tif l.callStopPropagation {\n\t\t\t\tjsEvent.Call(\"stopPropagation\")\n\t\t\t}\n\t\t\tl.Listener(&Event{\n\t\t\t\tValue:  jsEvent.(wrappedObject).j,\n\t\t\t\tTarget: jsEvent.Get(\"target\").(wrappedObject).j,\n\t\t\t})\n\t\t\treturn undefined()\n\t\t})\n\t}\n\n\t// Properties\n\tfor name, value := range h.properties {\n\t\tvar oldValue interface{}\n\t\tswitch name {\n\t\tcase \"value\":\n\t\t\toldValue = h.node.Get(\"value\").String()\n\t\tcase \"checked\":\n\t\t\toldValue = h.node.Get(\"checked\").Bool()\n\t\tdefault:\n\t\t\toldValue = prev.properties[name]\n\t\t}\n\t\tif value != oldValue {\n\t\t\th.node.Set(name, value)\n\t\t}\n\t}\n\n\t// Attributes\n\tfor name, value := range h.attributes {\n\t\tif value != prev.attributes[name] {\n\t\t\th.node.Call(\"setAttribute\", name, value)\n\t\t}\n\t}\n\n\t// Classes\n\tclassList := h.node.Get(\"classList\")\n\tfor name := range h.classes {\n\t\tif _, ok := prev.classes[name]; !ok {\n\t\t\tclassList.Call(\"add\", name)\n\t\t}\n\t}\n\n\t// Dataset\n\tdataset := h.node.Get(\"dataset\")\n\tfor name, value := range h.dataset {\n\t\tif value != prev.dataset[name] {\n\t\t\tdataset.Set(name, value)\n\t\t}\n\t}\n\n\t// Styles\n\tstyle := h.node.Get(\"style\")\n\tfor name, value := range h.styles {\n\t\toldValue := prev.styles[name]\n\t\tif value != oldValue {\n\t\t\tstyle.Call(\"setProperty\", name, value)\n\t\t}\n\t}\n\n\t// Event listeners\n\tfor _, l := range h.eventListeners {\n\t\th.node.Call(\"addEventListener\", l.Name, l.wrapper)\n\t}\n\n\t// InnerHTML\n\tif h.innerHTML != prev.innerHTML {\n\t\th.node.Set(\"innerHTML\", h.innerHTML)\n\t}\n}\n\n// removeProperties removes properties/attributes/etc that are no longer\n// present on the current element.\nfunc (h *HTML) removeProperties(prev *HTML) {\n\t// Properties\n\tfor name := range prev.properties {\n\t\tif _, ok := h.properties[name]; !ok {\n\t\t\th.node.Delete(name)\n\t\t}\n\t}\n\n\t// Attributes\n\tfor name := range prev.attributes {\n\t\tif _, ok := h.attributes[name]; !ok {\n\t\t\th.node.Call(\"removeAttribute\", name)\n\t\t}\n\t}\n\n\t// Classes\n\tclassList := h.node.Get(\"classList\")\n\tfor name := range prev.classes {\n\t\tif _, ok := h.classes[name]; !ok {\n\t\t\tclassList.Call(\"remove\", name)\n\t\t}\n\t}\n\n\t// Dataset\n\tdataset := h.node.Get(\"dataset\")\n\tfor name := range prev.dataset {\n\t\tif _, ok := h.dataset[name]; !ok {\n\t\t\tdataset.Delete(name)\n\t\t}\n\t}\n\n\t// Styles\n\tstyle := h.node.Get(\"style\")\n\tfor name := range prev.styles {\n\t\tif _, ok := h.styles[name]; !ok {\n\t\t\tstyle.Call(\"removeProperty\", name)\n\t\t}\n\t}\n\n\t// Event listeners\n\tfor _, l := range prev.eventListeners {\n\t\th.node.Call(\"removeEventListener\", l.Name, l.wrapper)\n\t\tl.wrapper.Release()\n\t}\n}\n\n// reconcileChildren reconciles children of the current HTML against a previous\n// render's DOM nodes.\nfunc (h *HTML) reconcileChildren(prev *HTML) (pendingMounts []Mounter) {\n\thasKeyedChildren := len(h.keyedChildren) > 0\n\tprevHadKeyedChildren := len(prev.keyedChildren) > 0\n\tfor i, nextChild := range h.children {\n\t\t// Determine concrete type if necessary.\n\t\tswitch v := nextChild.(type) {\n\t\tcase *HTML:\n\t\t\t// If the type of the child is *HTML, but its value is nil, replace\n\t\t\t// the child with a concrete nil, to ensure consistent render\n\t\t\t// handling.\n\t\t\tif v == nil {\n\t\t\t\tnextChild = nil\n\t\t\t\th.children[i] = nextChild\n\t\t\t}\n\t\tcase List:\n\t\t\t// Replace List with keyedList, which can handle nested keys and\n\t\t\t// children.\n\t\t\tnextChild = KeyedList{html: &HTML{children: v}}\n\t\t\th.children[i] = nextChild\n\t\t}\n\n\t\t// Ensure children implement the keyer interface consistently, and\n\t\t// populate the keyedChildren map now.\n\t\t//\n\t\t// TODO(pdf): Add tests for node equality, keyed children\n\t\tvar (\n\t\t\tnew     = !h.node.Equal(prev.node)\n\t\t\tnextKey interface{}\n\t\t)\n\t\tkeyer, isKeyer := nextChild.(Keyer)\n\t\tif hasKeyedChildren && !isKeyer {\n\t\t\tpanic(\"vecty: all siblings must have keys when using keyed elements\")\n\t\t}\n\t\tif isKeyer {\n\t\t\tnextKey = keyer.Key()\n\t\t\tif hasKeyedChildren && nextKey == nil {\n\t\t\t\tpanic(\"vecty: all siblings must have keys when using keyed elements\")\n\t\t\t}\n\t\t\tif nextKey != nil {\n\t\t\t\tif h.keyedChildren == nil {\n\t\t\t\t\th.keyedChildren = make(map[interface{}]ComponentOrHTML)\n\t\t\t\t}\n\t\t\t\tif _, exists := h.keyedChildren[nextKey]; exists {\n\t\t\t\t\tpanic(\"vecty: duplicate sibling key\")\n\t\t\t\t}\n\t\t\t\t// Store the keyed child.\n\t\t\t\th.keyedChildren[nextKey] = nextChild\n\t\t\t\thasKeyedChildren = true\n\t\t\t}\n\t\t}\n\n\t\t// If this is a new element (changed type, or did not exist previously),\n\t\t// simply add the element directly. The existence of keyed children\n\t\t// can not be determined by children index, so skip if keyed.\n\t\tif (i >= len(prev.children) && !hasKeyedChildren) || new {\n\t\t\tif nextChildList, ok := nextChild.(KeyedList); ok {\n\t\t\t\tpendingMounts = append(pendingMounts, nextChildList.reconcile(h, nil)...)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnextChildRender, skip, mounters := render(nextChild, nil)\n\t\t\tif skip || nextChildRender == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpendingMounts = append(pendingMounts, mounters...)\n\t\t\tif m, ok := nextChild.(Mounter); ok {\n\t\t\t\tpendingMounts = append(pendingMounts, m)\n\t\t\t}\n\t\t\th.lastRenderedChild = nextChildRender\n\n\t\t\t// Note: we must insertBefore not appendChild because if we're\n\t\t\t// rendering inside a list with unkeyed children, we will have an\n\t\t\t// insertion node here.\n\t\t\th.insertBefore(h.insertBeforeNode, nextChildRender)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar prevChild ComponentOrHTML\n\t\tif len(prev.children) > i {\n\t\t\tprevChild = prev.children[i]\n\t\t}\n\t\t// Find previous keyed sibling if exists, and mutate from there.\n\t\tif hasKeyedChildren {\n\t\t\tif prevKeyedChild, ok := prev.keyedChildren[nextKey]; ok {\n\t\t\t\tprevChild = prevKeyedChild\n\t\t\t} else {\n\t\t\t\tprevChild = nil\n\t\t\t}\n\t\t}\n\n\t\tvar prevChildRender *HTML\n\t\t// If the previous child was not a list, extract the previous child\n\t\t// render.\n\t\tif _, isList := prevChild.(KeyedList); !isList {\n\t\t\tprevChildRender = extractHTML(prevChild)\n\t\t}\n\n\t\t// If the previous child render was nil try to find the next DOM node\n\t\t// in the previous render so that we can insert this child at the\n\t\t// correct location.\n\t\tif prevChildRender == nil && h.insertBeforeNode == nil {\n\t\t\t// If we have not rendered any children yet, take the insert\n\t\t\t// position from the first child, if any, otherwise use the\n\t\t\t// next sibling from the last rendered child.\n\t\t\tif h.lastRenderedChild == nil {\n\t\t\t\th.insertBeforeNode = h.firstChild()\n\t\t\t} else {\n\t\t\t\th.insertBeforeNode = h.lastRenderedChild.nextSibling()\n\t\t\t}\n\t\t}\n\t\t// If our insertion node is the current previous child, advance to the\n\t\t// next sibling.\n\t\tif prevChildRender != nil && prevChildRender.node.Equal(h.insertBeforeNode) {\n\t\t\th.insertBeforeNode = h.insertBeforeNode.Get(\"nextSibling\")\n\t\t}\n\n\t\t// If the next child is a list, reconcile its elements in-place, and\n\t\t// we're done.\n\t\tif nextChildList, ok := nextChild.(KeyedList); ok {\n\t\t\tpendingMounts = append(pendingMounts, nextChildList.reconcile(h, prevChild)...)\n\t\t\tcontinue\n\t\t}\n\n\t\t// If the previous child was a list, remove the list elements from the\n\t\t// previous render, since we no longer have a list.\n\t\tif prevChildList, ok := prevChild.(KeyedList); ok {\n\t\t\tprevChildList.remove(h)\n\t\t\tprevChild = nil\n\t\t}\n\n\t\t// If we're keyed, find the next DOM node from the previous render to\n\t\t// insert before, for reordering.\n\t\tvar (\n\t\t\tinsertBeforeKeyedNode jsObject\n\t\t\tstableKey             bool\n\t\t)\n\t\tif hasKeyedChildren {\n\t\t\tinsertBeforeKeyedNode = h.lastRenderedChild.nextSibling()\n\t\t\t// If the next node is our old node, mark key as stable, to avoid\n\t\t\t// unnecessary insertion.\n\t\t\tif prevChildRender != nil && prevChildRender.node.Equal(insertBeforeKeyedNode) {\n\t\t\t\tstableKey = true\n\t\t\t\tinsertBeforeKeyedNode = nil\n\t\t\t}\n\t\t}\n\n\t\t// Determine the next child render.\n\t\tnextChildRender, skip, mounters := render(nextChild, prevChild)\n\t\tif nextChildRender != nil && prevChildRender != nil && nextChildRender == prevChildRender {\n\t\t\tpanic(\"vecty: next child render must not equal previous child render (did the child Render illegally return a stored render variable?)\")\n\t\t}\n\n\t\t// Store the last rendered child to determine insertion target for\n\t\t// subsequent children.\n\t\tif nextChildRender != nil {\n\t\t\th.lastRenderedChild = nextChildRender\n\t\t}\n\n\t\t// If the previous and next child are components of the same type, then\n\t\t// keep prevChildComponent as our child so that the next time we are\n\t\t// here prevChild will be the same pointer. We do this because\n\t\t// prevChildComponent is the persistent component instance.\n\t\tif prevChildComponent, ok := prevChild.(Component); ok {\n\t\t\tif nextChildComponent, ok := nextChild.(Component); ok && sameType(prevChildComponent, nextChildComponent) {\n\t\t\t\th.children[i] = prevChild\n\t\t\t\tnextChild = prevChild\n\t\t\t\tif hasKeyedChildren {\n\t\t\t\t\th.keyedChildren[nextKey] = prevChild\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif skip {\n\t\t\tcontinue\n\t\t}\n\t\tpendingMounts = append(pendingMounts, mounters...)\n\n\t\t// Perform the final reconciliation action for nextChildRender and\n\t\t// prevChildRender. Replace, remove, insert or append the DOM nodes.\n\t\tswitch {\n\t\tcase nextChildRender == nil && prevChildRender == nil:\n\t\t\tcontinue // nothing to do.\n\t\tcase nextChildRender != nil && prevChildRender != nil:\n\t\t\tif m := mountUnmount(nextChild, prevChild); m != nil {\n\t\t\t\tpendingMounts = append(pendingMounts, m)\n\t\t\t}\n\n\t\t\tif hasKeyedChildren && (prevChildRender != nil && prevChildRender.node.Equal(nextChildRender.node)) {\n\t\t\t\t// We are re-using the name node. Remove the children from\n\t\t\t\t// keyedChildren so that we don't remove it when we remove dangling\n\t\t\t\t// children below.\n\t\t\t\tdelete(prev.keyedChildren, nextKey)\n\t\t\t}\n\n\t\t\t// If we do not have keyed siblings, or the key is stable, replace\n\t\t\t// the previous node (may be NOOP for equivalent nodes).\n\t\t\tif !hasKeyedChildren || stableKey {\n\t\t\t\treplaceNode(nextChildRender.node, prevChildRender.node)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Moving keyed children need to be inserted (which moves existing\n\t\t\t// nodes), rather than replacing the previous child at this\n\t\t\t// position.\n\t\t\tif insertBeforeKeyedNode != nil {\n\t\t\t\t// Insert before the next sibling, if we have one.\n\t\t\t\th.insertBefore(insertBeforeKeyedNode, nextChildRender)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\th.insertBefore(h.insertBeforeNode, nextChildRender)\n\t\tcase nextChildRender == nil && prevChildRender != nil:\n\t\t\th.removeChild(prevChildRender)\n\t\tcase nextChildRender != nil && prevChildRender == nil:\n\t\t\tif m, ok := nextChild.(Mounter); ok {\n\t\t\t\tpendingMounts = append(pendingMounts, m)\n\t\t\t}\n\t\t\tif insertBeforeKeyedNode != nil {\n\t\t\t\t// Insert before the next keyed sibling, if we have one.\n\t\t\t\th.insertBefore(insertBeforeKeyedNode, nextChildRender)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\th.insertBefore(h.insertBeforeNode, nextChildRender)\n\t\tdefault:\n\t\t\tpanic(\"vecty: internal error (unexpected switch state)\")\n\t\t}\n\t}\n\n\t// If dealing with keyed siblings, remove all prev.keyedChildren which are\n\t// leftovers / ones we did not find a match for above.\n\tif prevHadKeyedChildren && hasKeyedChildren {\n\t\t// Convert prev.keyedChildren map to slice, and invoke removeChildren.\n\t\tprevChildren := make([]ComponentOrHTML, len(prev.keyedChildren))\n\t\ti := 0\n\t\tfor _, c := range prev.keyedChildren {\n\t\t\tprevChildren[i] = c\n\t\t\ti++\n\t\t}\n\t\th.removeChildren(prevChildren)\n\t\treturn pendingMounts\n\t}\n\n\tif len(prev.children) > len(h.children) {\n\t\t// Remove every previous child that h.children does not have in common.\n\t\th.removeChildren(prev.children[len(h.children):])\n\t}\n\treturn pendingMounts\n}\n\n// removeChildren removes child elements from the previous render pass that no\n// longer exist on the current HTML children.\nfunc (h *HTML) removeChildren(prevChildren []ComponentOrHTML) {\n\tfor _, prevChild := range prevChildren {\n\t\tif prevChildList, ok := prevChild.(KeyedList); ok {\n\t\t\t// Previous child was a list, so remove all DOM nodes in it.\n\t\t\tprevChildList.remove(h)\n\t\t\tcontinue\n\t\t}\n\t\tprevChildRender := extractHTML(prevChild)\n\t\tif prevChildRender == nil {\n\t\t\tcontinue\n\t\t}\n\t\th.removeChild(prevChildRender)\n\t}\n}\n\n// firstChild returns the first child DOM node of this element.\nfunc (h *HTML) firstChild() jsObject {\n\tif h == nil || h.node == nil {\n\t\treturn nil\n\t}\n\treturn h.node.Get(\"firstChild\")\n}\n\n// nextSibling returns the next sibling DOM node for this element.\nfunc (h *HTML) nextSibling() jsObject {\n\tif h == nil || h.node == nil {\n\t\treturn nil\n\t}\n\treturn h.node.Get(\"nextSibling\")\n}\n\n// removeChild removes the provided child element from this element, and\n// triggers unmount handlers.\nfunc (h *HTML) removeChild(child *HTML) {\n\t// If we're removing the current insert target, use the next\n\t// sibling, if any.\n\tif h.insertBeforeNode != nil && h.insertBeforeNode.Equal(child.node) {\n\t\th.insertBeforeNode = h.insertBeforeNode.Get(\"nextSibling\")\n\t}\n\tunmount(child)\n\tif child.node == nil {\n\t\treturn\n\t}\n\t// Use the child's parent node here, in case our node is not a valid\n\t// target by the time we're called.\n\tchild.node.Get(\"parentNode\").Call(\"removeChild\", child.node)\n}\n\n// appendChild appends a new child to this element.\nfunc (h *HTML) appendChild(child *HTML) {\n\th.node.Call(\"appendChild\", child.node)\n}\n\n// insertBefore inserts the provided child before the provided DOM node. If the\n// DOM node is nil, the child will be appended instead.\nfunc (h *HTML) insertBefore(node jsObject, child *HTML) {\n\tif node == nil {\n\t\th.appendChild(child)\n\t\treturn\n\t}\n\th.node.Call(\"insertBefore\", child.node, node)\n}\n\n// List represents a list of components or HTML.\ntype List []ComponentOrHTML\n\n// isMarkupOrChild implements MarkupOrChild\nfunc (l List) isMarkupOrChild() {}\n\n// isComponentOrHTML implements ComponentOrHTML\nfunc (l List) isComponentOrHTML() {}\n\n// WithKey wraps the List in a Keyer using the given key. List members are\n// inaccessible within the returned value.\nfunc (l List) WithKey(key interface{}) KeyedList {\n\treturn KeyedList{key: key, html: &HTML{children: l}}\n}\n\n// KeyedList is produced by calling List.WithKey. It has no public behaviour,\n// and List members are no longer accessible once wrapped in this stucture.\ntype KeyedList struct {\n\t// html is used to render a set of children into another element in a\n\t// separate context, without requiring a structural element. Keyed children\n\t// also occupy a separate keyspace to the parent element.\n\thtml *HTML\n\t// key is optional, and only required when the KeyedList has keyed siblings.\n\tkey interface{}\n}\n\n// isMarkupOrChild implements MarkupOrChild\nfunc (l KeyedList) isMarkupOrChild() {}\n\n// isComponentOrHTML implements ComponentOrHTML\nfunc (l KeyedList) isComponentOrHTML() {}\n\n// Key implements the Keyer interface\nfunc (l KeyedList) Key() interface{} {\n\treturn l.key\n}\n\n// reconcile reconciles the keyedList against the DOM node in a separate\n// context, unless keyed. Uses the currently known insertion point from the\n// parent to insert children at the correct position.\nfunc (l KeyedList) reconcile(parent *HTML, prevChild ComponentOrHTML) (pendingMounts []Mounter) {\n\t// Effectively become the parent (copy its scope) so that we can reconcile\n\t// our children against the prev child.\n\tl.html.node = parent.node\n\tl.html.insertBeforeNode = parent.insertBeforeNode\n\tl.html.lastRenderedChild = parent.lastRenderedChild\n\n\tswitch v := prevChild.(type) {\n\tcase KeyedList:\n\t\tpendingMounts = l.html.reconcileChildren(v.html)\n\tcase *HTML, Component, nil:\n\t\tif v == nil {\n\t\t\t// No previous element, so reconcile against a parent with no\n\t\t\t// children so all of our elements are added.\n\t\t\tpendingMounts = l.html.reconcileChildren(&HTML{node: parent.node})\n\t\t} else {\n\t\t\t// Build a previous render containing just the prevChild to be\n\t\t\t// replaced by this list\n\t\t\tprev := &HTML{node: parent.node, children: []ComponentOrHTML{prevChild}}\n\t\t\tif keyer, ok := prevChild.(Keyer); ok && keyer.Key() != nil {\n\t\t\t\tprev.keyedChildren = map[interface{}]ComponentOrHTML{keyer.Key(): prevChild}\n\t\t\t}\n\t\t\tpendingMounts = l.html.reconcileChildren(prev)\n\t\t}\n\tdefault:\n\t\tpanic(\"vecty: internal error (unexpected ComponentOrHTML type \" + reflect.TypeOf(v).String() + \")\")\n\t}\n\n\t// Update the parent insertBeforeNode and lastRenderedChild values to be\n\t// ours, since we acted as the parent and ours is now updated / theirs is\n\t// outdated.\n\tif parent.insertBeforeNode != nil {\n\t\tparent.insertBeforeNode = l.html.insertBeforeNode\n\t}\n\tif l.html.lastRenderedChild != nil {\n\t\tparent.lastRenderedChild = l.html.lastRenderedChild\n\t}\n\treturn pendingMounts\n}\n\n// remove keyedList elements from the parent.\nfunc (l KeyedList) remove(parent *HTML) {\n\t// Become the parent so that we can remove all of our children and get an\n\t// updated insertBeforeNode value.\n\tl.html.node = parent.node\n\tl.html.insertBeforeNode = parent.insertBeforeNode\n\tl.html.removeChildren(l.html.children)\n\n\t// Now that the children are removed, and our insertBeforeNode value has\n\t// been updated, update the parent's insertBeforeNode value since it is now\n\t// invalid and ours is correct.\n\tif parent.insertBeforeNode != nil {\n\t\tparent.insertBeforeNode = l.html.insertBeforeNode\n\t}\n}\n\n// Tag returns an HTML element with the given tag name. Generally, this\n// function is not used directly but rather the elem subpackage (which is type\n// safe) is used instead.\nfunc Tag(tag string, m ...MarkupOrChild) *HTML {\n\th := &HTML{\n\t\ttag: tag,\n\t}\n\tfor _, m := range m {\n\t\tapply(m, h)\n\t}\n\treturn h\n}\n\n// Text returns a TextNode with the given literal text. Because the returned\n// HTML represents a TextNode, the text does not have to be escaped (arbitrary\n// user input fed into this function will always be safely rendered).\nfunc Text(text string, m ...MarkupOrChild) *HTML {\n\th := &HTML{\n\t\ttext: text,\n\t}\n\tfor _, m := range m {\n\t\tapply(m, h)\n\t}\n\treturn h\n}\n\n// Rerender causes the body of the given Component (i.e. the HTML returned by\n// the Component's Render method) to be re-rendered.\n//\n// If the Component has not been rendered before, Rerender panics. If the\n// Component was previously unmounted, Rerender is no-op.\n//\n// Rerender operates efficiently by batching renders together. As a result,\n// there is no guarantee that a calls to Rerender will map 1:1 with calls to\n// the Component's Render method. For example, two calls to Rerender may\n// result in only one call to the Component's Render method.\nfunc Rerender(c Component) {\n\tif c == nil {\n\t\tpanic(\"vecty: Rerender illegally called with a nil Component argument\")\n\t}\n\tif c.Context().prevRender == nil {\n\t\tpanic(\"vecty: Rerender invoked on Component that has never been rendered\")\n\t}\n\tif c.Context().unmounted {\n\t\treturn\n\t}\n\tbatch.add(c)\n}\n\n// batchRenderer handles component re-renders by queueing and deduplicating\n// them, to be rendered on the next animation frame (via requestAnimationFrame).\ntype batchRenderer struct {\n\t// batch contains the list of pending components to render.\n\tbatch []Component\n\t// idx maps components to batch indexes to allow dedup, retaining order.\n\tidx map[Component]int\n\t// scheduled tracks whether a batch has been scheduled for processing.\n\tscheduled bool\n}\n\n// add a Component to the pending batch.\nfunc (b *batchRenderer) add(c Component) {\n\tif i, ok := b.idx[c]; ok {\n\t\t// Shift idx for delete.\n\t\tfor j, c := range b.batch[i+1:] {\n\t\t\tb.idx[c] = i + j\n\t\t}\n\t\t// Delete previously queued render.\n\t\tcopy(b.batch[i:], b.batch[i+1:])\n\t\tb.batch[len(b.batch)-1] = nil\n\t\tb.batch = b.batch[:len(b.batch)-1]\n\t}\n\t// Append and index component.\n\tb.batch = append(b.batch, c)\n\tb.idx[c] = len(b.batch) - 1\n\t// If we're not already scheduled for a render batch, request a render on\n\t// the next frame.\n\tif !b.scheduled {\n\t\tb.scheduled = true\n\t\trequestAnimationFrame(b.render)\n\t}\n}\n\n// render the pending batch.\n// TODO(pdf): Add tests for time budget and multi-pass renders.\nfunc (b *batchRenderer) render(startTime float64) {\n\t// If the batch is empty, mark as unscheduled, and stop render cycle.\n\tif len(b.batch) == 0 {\n\t\tb.scheduled = false\n\t\treturn\n\t}\n\n\t// Drain the current batch.\n\tpending := b.batch\n\tb.batch = nil\n\tb.idx = make(map[Component]int)\n\n\t// Process batch.\n\tfor i, c := range pending {\n\t\t// Skip unmounted components.\n\t\tif c.Context().unmounted {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check for remaining time budget, targeting 60fps (~16ms per frame).\n\t\tif i > 0 {\n\t\t\telapsed := global().Get(\"performance\").Call(\"now\").Float() - startTime\n\t\t\tbudgetRemaining := (1000 / 60) - elapsed\n\t\t\tavgRenderTime := elapsed / float64(i)\n\t\t\t// If the budget remaining is less than 2 times the average\n\t\t\t// Component render time, push the remainder of the batch to the\n\t\t\t// next frame.\n\t\t\tif budgetRemaining < avgRenderTime*2 {\n\t\t\t\tb.batch = pending[i:]\n\t\t\t\tfor i, c := range b.batch {\n\t\t\t\t\tb.idx[c] = i\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Perform render.\n\t\tprevHTML := extractHTML(c.Context().prevRender)\n\t\tnextHTML, skip, pendingMounts := renderComponent(c, c)\n\t\tif skip {\n\t\t\tcontinue\n\t\t}\n\t\treplaceNode(nextHTML.node, prevHTML.node)\n\t\tmount(pendingMounts...)\n\t}\n\n\t// Schedule next frame.\n\trequestAnimationFrame(b.render)\n}\n\n// extractHTML returns the *HTML from a ComponentOrHTML.\nfunc extractHTML(e ComponentOrHTML) *HTML {\n\tswitch v := e.(type) {\n\tcase nil:\n\t\treturn nil\n\tcase *HTML:\n\t\treturn v\n\tcase Component:\n\t\treturn extractHTML(v.Context().prevRender)\n\tdefault:\n\t\tpanic(\"vecty: internal error (unexpected ComponentOrHTML type \" + reflect.TypeOf(e).String() + \")\")\n\t}\n}\n\n// sameType returns whether first and second ComponentOrHTML are of the same\n// underlying type.\nfunc sameType(first, second ComponentOrHTML) bool {\n\treturn reflect.TypeOf(first) == reflect.TypeOf(second)\n}\n\n// copyComponent makes a copy of the given component.\nfunc copyComponent(c Component) Component {\n\tif c == nil {\n\t\tpanic(\"vecty: internal error (cannot copy nil Component)\")\n\t}\n\n\t// If the Component implements the Copier interface, then use that to\n\t// perform the copy.\n\tif copier, ok := c.(Copier); ok {\n\t\tcpy := copier.Copy()\n\t\tif cpy == c {\n\t\t\tpanic(\"vecty: Component.Copy illegally returned an identical *MyComponent pointer\")\n\t\t}\n\t\treturn cpy\n\t}\n\n\ttinyGoAssertCopier(c)\n\n\t// Component does not implement the Copier interface, so perform a shallow\n\t// copy.\n\tv := reflect.ValueOf(c)\n\tif v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct {\n\t\tpanic(\"vecty: Component must be pointer to struct, found \" + reflect.TypeOf(c).String())\n\t}\n\tcpy := reflect.New(v.Elem().Type())\n\tcpy.Elem().Set(v.Elem())\n\treturn cpy.Interface().(Component)\n}\n\n// copyProps copies all struct fields from src to dst that are tagged with\n// `vecty:\"prop\"`.\n//\n// If src and dst are different types or non-pointers, copyProps panics.\nfunc copyProps(src, dst Component) {\n\tif src == dst {\n\t\treturn\n\t}\n\ts := reflect.ValueOf(src)\n\td := reflect.ValueOf(dst)\n\tif s.Type() != d.Type() {\n\t\tpanic(\"vecty: internal error (attempted to copy properties of incompatible structs)\")\n\t}\n\tif s.Kind() != reflect.Ptr || d.Kind() != reflect.Ptr {\n\t\tpanic(\"vecty: internal error (attempted to copy properties of non-pointer)\")\n\t}\n\tfor i := 0; i < s.Elem().NumField(); i++ {\n\t\tsf := s.Elem().Field(i)\n\t\tif s.Elem().Type().Field(i).Tag.Get(\"vecty\") == \"prop\" {\n\t\t\tdf := d.Elem().Field(i)\n\t\t\tif sf.Type() != df.Type() {\n\t\t\t\tpanic(\"vecty: internal error (should never be possible, struct types are identical)\")\n\t\t\t}\n\t\t\tdf.Set(sf)\n\t\t}\n\t}\n}\n\n// render handles rendering the next child into HTML. If skip is returned,\n// the component's SkipRender method has signaled to skip rendering.\n//\n// In specific, render handles six cases:\n//\n// 1. nextChild == *HTML && prevChild == *HTML\n// 2. nextChild == *HTML && prevChild == Component\n// 3. nextChild == *HTML && prevChild == nil\n// 4. nextChild == Component && prevChild == Component\n// 5. nextChild == Component && prevChild == *HTML\n// 6. nextChild == Component && prevChild == nil\n//\nfunc render(next, prev ComponentOrHTML) (nextHTML *HTML, skip bool, pendingMounts []Mounter) {\n\tswitch v := next.(type) {\n\tcase *HTML:\n\t\t// Cases 1, 2 and 3 above. Reconcile against the prevRender.\n\t\tpendingMounts = v.reconcile(extractHTML(prev))\n\t\treturn v, false, pendingMounts\n\tcase Component:\n\t\t// Cases 4, 5, and 6 above.\n\t\treturn renderComponent(v, prev)\n\tcase nil:\n\t\treturn nil, false, nil\n\tdefault:\n\t\tpanic(\"vecty: internal error (unexpected ComponentOrHTML type \" + reflect.TypeOf(next).String() + \")\")\n\t}\n}\n\n// renderComponent handles rendering the given Component into *HTML. If skip ==\n// true is returned, the Component's SkipRender method has signaled the\n// component does not need to be rendered and h == nil is returned.\nfunc renderComponent(next Component, prev ComponentOrHTML) (nextHTML *HTML, skip bool, pendingMounts []Mounter) {\n\t// If we had a component last render, and it's of compatible type, operate\n\t// on the previous instance.\n\tif prevComponent, ok := prev.(Component); ok && sameType(next, prevComponent) {\n\t\t// Copy `vecty:\"prop\"` fields from the newly rendered component (next)\n\t\t// into the persistent component instance (prev) so that it is aware of\n\t\t// what properties the parent has specified during SkipRender/Render\n\t\t// below.\n\t\tcopyProps(next, prevComponent)\n\t\t// Persist the previous component across renders.\n\t\tnext = prevComponent\n\t}\n\n\t// Before rendering, consult the Component's SkipRender method to see if we\n\t// should skip rendering or not.\n\tif rs, ok := next.(RenderSkipper); ok {\n\t\tprevRenderComponent := next.Context().prevRenderComponent\n\t\tif prevRenderComponent != nil {\n\t\t\tif next == prevRenderComponent {\n\t\t\t\tpanic(\"vecty: internal error (SkipRender called with identical prev component)\")\n\t\t\t}\n\t\t\tif rs.SkipRender(prevRenderComponent) {\n\t\t\t\treturn nil, true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// Render the component into HTML, handling nil renders.\n\tnextRender := next.Render()\n\tprevRender := next.Context().prevRender\n\tif nextRender == nil {\n\t\t// nil renders are translated into noscript tags.\n\t\tnextRender = Tag(\"noscript\")\n\t}\n\n\tswitch v := nextRender.(type) {\n\tcase Component:\n\t\tnextHTML, skip, pendingMounts = renderComponent(v, prevRender)\n\t\tif skip {\n\t\t\treturn nextHTML, skip, pendingMounts\n\t\t}\n\t\tif prevComponent, ok := prevRender.(Component); ok && sameType(v, prevComponent) {\n\t\t\tnextRender = prevRender\n\t\t}\n\tcase *HTML:\n\t\tif v == nil {\n\t\t\t// nil renders are translated into noscript tags.\n\t\t\tv = Tag(\"noscript\")\n\t\t}\n\t\tnextHTML = v\n\t\t// Reconcile the actual rendered HTML.\n\t\tpendingMounts = nextHTML.reconcile(extractHTML(prev))\n\tdefault:\n\t\tpanic(\"vecty: internal error (unexpected ComponentOrHTML type \" + reflect.TypeOf(v).String() + \")\")\n\t}\n\n\tm := mountUnmount(nextRender, prevRender)\n\tif m != nil {\n\t\tpendingMounts = append(pendingMounts, m)\n\t}\n\n\t// Update the context to consider this render.\n\tnext.Context().prevRender = nextRender\n\tnext.Context().prevRenderComponent = copyComponent(next)\n\tnext.Context().unmounted = false\n\treturn nextHTML, false, pendingMounts\n}\n\n// mountUnmount determines whether a mount or unmount event should occur,\n// actions unmounts recursively if appropriate, and returns either a Mounter,\n// or nil.\nfunc mountUnmount(next, prev ComponentOrHTML) Mounter {\n\tif next == prev {\n\t\treturn nil\n\t}\n\tif !sameType(next, prev) {\n\t\tif prev != nil {\n\t\t\tunmount(prev)\n\t\t}\n\t\tif m, ok := next.(Mounter); ok {\n\t\t\treturn m\n\t\t}\n\t\treturn nil\n\t}\n\tif prevHTML := extractHTML(prev); prevHTML != nil {\n\t\tif nextHTML := extractHTML(next); nextHTML == nil || !prevHTML.node.Equal(nextHTML.node) {\n\t\t\tfor _, child := range prevHTML.children {\n\t\t\t\tunmount(child)\n\t\t\t}\n\t\t}\n\t}\n\tif u, ok := prev.(Unmounter); ok {\n\t\tu.Unmount()\n\t}\n\tif m, ok := next.(Mounter); ok {\n\t\treturn m\n\t}\n\treturn nil\n}\n\n// mount all pending Mounters\nfunc mount(pendingMounts ...Mounter) {\n\tfor _, mounter := range pendingMounts {\n\t\tif mounter == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif c, ok := mounter.(Component); ok {\n\t\t\tif c.Context().mounted {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.Context().mounted = true\n\t\t\tc.Context().unmounted = false\n\t\t}\n\t\tmounter.Mount()\n\t}\n}\n\n// unmount recursively unmounts the provided ComponentOrHTML, and any children\n// that satisfy the Unmounter interface.\nfunc unmount(e ComponentOrHTML) {\n\tif c, ok := e.(Component); ok {\n\t\tif c.Context().unmounted {\n\t\t\treturn\n\t\t}\n\t\tc.Context().unmounted = true\n\t\tc.Context().mounted = false\n\t\tif prevRenderComponent, ok := c.Context().prevRender.(Component); ok {\n\t\t\tunmount(prevRenderComponent)\n\t\t}\n\t}\n\n\tif l, ok := e.(KeyedList); ok {\n\t\tfor _, child := range l.html.children {\n\t\t\tunmount(child)\n\t\t}\n\t\treturn\n\t}\n\n\tif h := extractHTML(e); h != nil {\n\t\tfor _, child := range h.children {\n\t\t\tunmount(child)\n\t\t}\n\t}\n\n\tif u, ok := e.(Unmounter); ok {\n\t\tu.Unmount()\n\t}\n}\n\n// requestAnimationFrame calls the native JS function of the same name.\nfunc requestAnimationFrame(callback func(float64)) int {\n\tvar cb jsFunc\n\tcb = funcOf(func(this jsObject, args []jsObject) interface{} {\n\t\tcb.Release()\n\n\t\tcallback(args[0].Float())\n\t\treturn undefined()\n\t})\n\treturn global().Call(\"requestAnimationFrame\", cb).Int()\n}\n\n// RenderBody renders the given component as the document body. The given\n// Component's Render method must return a \"body\" element or a panic will\n// occur.\n//\n// This function blocks forever in order to prevent the program from exiting,\n// which would prevent components from rerendering themselves in the future.\n//\n// It is a short-handed form for writing:\n//\n// \terr := vecty.RenderInto(\"body\", body)\n// \tif err !== nil {\n// \t\tpanic(err)\n// \t}\n// \tselect{} // run Go forever\n//\nfunc RenderBody(body Component) {\n\ttarget := global().Get(\"document\").Call(\"querySelector\", \"body\")\n\terr := renderIntoNode(\"RenderBody\", target, body)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif !isTest {\n\t\tselect {} // run Go forever\n\t}\n}\n\n// ElementMismatchError is returned when the element returned by a component\n// does not match what is required for rendering.\ntype ElementMismatchError struct {\n\tmethod, got, want string\n}\n\nfunc (e ElementMismatchError) Error() string {\n\treturn \"vecty: \" + e.method + `: expected Component.Render to return a \"` + e.want + `\", found \"` + e.got + `\"`\n}\n\n// InvalidTargetError is returned when the element targeted by a render is\n// invalid because it is null or undefined.\ntype InvalidTargetError struct {\n\tmethod string\n}\n\nfunc (e InvalidTargetError) Error() string {\n\treturn \"vecty: \" + e.method + `: invalid target element is null or undefined`\n}\n\n// RenderInto renders the given component into the existing HTML element found\n// by the CSS selector (e.g. \"#id\", \".class-name\") by replacing it.\n//\n// If there is more than one element found, the first is used. If no element is\n// found, an error of type InvalidTargetError is returned.\n//\n// If the Component's Render method does not return an element of the same type,\n// an error of type ElementMismatchError is returned.\nfunc RenderInto(selector string, c Component) error {\n\ttarget := global().Get(\"document\").Call(\"querySelector\", selector)\n\treturn renderIntoNode(\"RenderInto\", target, c)\n}\n\nfunc renderIntoNode(methodName string, node jsObject, c Component) error {\n\tif !node.Truthy() {\n\t\treturn InvalidTargetError{method: methodName}\n\t}\n\t// block batch until we're done\n\tbatch.scheduled = true\n\tnextRender, skip, pendingMounts := renderComponent(c, nil)\n\tif skip {\n\t\tpanic(\"vecty: \" + methodName + \": Component.SkipRender illegally returned true\")\n\t}\n\texpectTag := toLower(node.Get(\"nodeName\").String())\n\tif nextRender.tag != expectTag {\n\t\treturn ElementMismatchError{method: methodName, got: nextRender.tag, want: expectTag}\n\t}\n\tdoc := global().Get(\"document\")\n\tif doc.Get(\"readyState\").String() == \"loading\" {\n\t\tvar cb jsFunc\n\t\tcb = funcOf(func(this jsObject, args []jsObject) interface{} {\n\t\t\tcb.Release()\n\n\t\t\treplaceNode(nextRender.node, node)\n\t\t\tmount(pendingMounts...)\n\t\t\tif m, ok := c.(Mounter); ok {\n\t\t\t\tmount(m)\n\t\t\t}\n\t\t\trequestAnimationFrame(batch.render)\n\t\t\treturn undefined()\n\t\t})\n\t\tdoc.Call(\"addEventListener\", \"DOMContentLoaded\", cb)\n\t\treturn nil\n\t}\n\treplaceNode(nextRender.node, node)\n\tmount(pendingMounts...)\n\tif m, ok := c.(Mounter); ok {\n\t\tmount(m)\n\t}\n\trequestAnimationFrame(batch.render)\n\treturn nil\n}\n\n// SetTitle sets the title of the document.\nfunc SetTitle(title string) {\n\tglobal().Get(\"document\").Set(\"title\", title)\n}\n\n// AddStylesheet adds an external stylesheet to the document.\nfunc AddStylesheet(url string) {\n\tlink := global().Get(\"document\").Call(\"createElement\", \"link\")\n\tlink.Set(\"rel\", \"stylesheet\")\n\tlink.Set(\"href\", url)\n\tglobal().Get(\"document\").Get(\"head\").Call(\"appendChild\", link)\n}\n\ntype jsFunc interface {\n\tRelease()\n}\n\ntype jsObject interface {\n\tSet(key string, value interface{})\n\tGet(key string) jsObject\n\tDelete(key string)\n\tCall(name string, args ...interface{}) jsObject\n\tString() string\n\tTruthy() bool\n\tEqual(other jsObject) bool\n\tIsUndefined() bool\n\tBool() bool\n\tInt() int\n\tFloat() float64\n}\n\nvar isTest bool\n"
        },
        {
          "name": "dom_js.go",
          "type": "blob",
          "size": 3.482421875,
          "content": "// +build js\n\npackage vecty\n\nimport \"syscall/js\"\n\n// Event represents a DOM event.\ntype Event struct {\n\tjs.Value\n\tTarget js.Value\n}\n\n// Node returns the underlying JavaScript Element or TextNode.\n//\n// It panics if it is called before the DOM node has been attached, i.e. before\n// the associated component's Mounter interface would be invoked.\nfunc (h *HTML) Node() js.Value {\n\tif h.node == nil {\n\t\tpanic(\"vecty: cannot call (*HTML).Node() before DOM node creation / component mount\")\n\t}\n\treturn h.node.(wrappedObject).j\n}\n\n// RenderIntoNode renders the given component into the existing HTML element by\n// replacing it.\n//\n// If the Component's Render method does not return an element of the same type,\n// an error of type ElementMismatchError is returned.\nfunc RenderIntoNode(node js.Value, c Component) error {\n\treturn renderIntoNode(\"RenderIntoNode\", wrapObject(node), c)\n}\n\nfunc toLower(s string) string {\n\t// We must call the prototype method here to workaround a limitation of\n\t// syscall/js in both Go and GopherJS where we cannot call the\n\t// `toLowerCase` string method. See https://github.com/golang/go/issues/35917\n\treturn js.Global().Get(\"String\").Get(\"prototype\").Get(\"toLowerCase\").Call(\"call\", js.ValueOf(s)).String()\n}\n\nvar globalValue jsObject\n\nfunc global() jsObject {\n\tif globalValue == nil {\n\t\tglobalValue = wrapObject(js.Global())\n\t}\n\treturn globalValue\n}\n\nfunc undefined() wrappedObject {\n\treturn wrappedObject{js.Undefined()}\n}\n\nfunc funcOf(fn func(this jsObject, args []jsObject) interface{}) jsFunc {\n\treturn &jsFuncImpl{\n\t\tf: js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\t\twrappedArgs := make([]jsObject, len(args))\n\t\t\tfor i, arg := range args {\n\t\t\t\twrappedArgs[i] = wrapObject(arg)\n\t\t\t}\n\t\t\treturn unwrap(fn(wrapObject(this), wrappedArgs))\n\t\t}),\n\t\tgoFunc: fn,\n\t}\n}\n\ntype jsFuncImpl struct {\n\tf      js.Func\n\tgoFunc func(this jsObject, args []jsObject) interface{}\n}\n\nfunc (j *jsFuncImpl) String() string {\n\t// fmt.Sprint(j) would produce the actual implementation of the function in\n\t// JS code which differs across WASM/GopherJS/TinyGo so we instead just\n\t// return an opaque string for testing purposes.\n\treturn \"func\"\n}\n\nfunc (j *jsFuncImpl) Release() { j.f.Release() }\n\nfunc valueOf(v interface{}) jsObject {\n\treturn wrapObject(js.ValueOf(v))\n}\n\nfunc wrapObject(j js.Value) jsObject {\n\tif j.IsNull() {\n\t\treturn nil\n\t}\n\treturn wrappedObject{j: j}\n}\n\nfunc unwrap(value interface{}) interface{} {\n\tif v, ok := value.(wrappedObject); ok {\n\t\treturn v.j\n\t}\n\tif v, ok := value.(*jsFuncImpl); ok {\n\t\treturn v.f\n\t}\n\treturn value\n}\n\ntype wrappedObject struct {\n\tj js.Value\n}\n\nfunc (w wrappedObject) Set(key string, value interface{}) {\n\tw.j.Set(key, unwrap(value))\n}\n\nfunc (w wrappedObject) Get(key string) jsObject {\n\treturn wrapObject(w.j.Get(key))\n}\n\nfunc (w wrappedObject) Delete(key string) {\n\tw.j.Delete(key)\n}\n\nfunc (w wrappedObject) Call(name string, args ...interface{}) jsObject {\n\tfor i, arg := range args {\n\t\targs[i] = unwrap(arg)\n\t}\n\treturn wrapObject(w.j.Call(name, args...))\n}\n\nfunc (w wrappedObject) String() string {\n\treturn w.j.String()\n}\n\nfunc (w wrappedObject) Truthy() bool {\n\treturn w.j.Truthy()\n}\n\nfunc (w wrappedObject) IsUndefined() bool {\n\treturn w.j.IsUndefined()\n}\n\nfunc (w wrappedObject) Equal(other jsObject) bool {\n\tif w.j.IsNull() != (other == nil) {\n\t\treturn false\n\t}\n\treturn w.j.Equal(unwrap(other).(js.Value))\n}\n\nfunc (w wrappedObject) Bool() bool {\n\treturn w.j.Bool()\n}\n\nfunc (w wrappedObject) Int() int {\n\treturn w.j.Int()\n}\n\nfunc (w wrappedObject) Float() float64 {\n\treturn w.j.Float()\n}\n"
        },
        {
          "name": "dom_native.go",
          "type": "blob",
          "size": 2.373046875,
          "content": "// +build !js\n\npackage vecty\n\nimport \"strings\"\n\n// Stubs for building Vecty under a native GOOS and GOARCH, so that Vecty\n// type-checks, lints, auto-completes, and serves documentation under godoc.org\n// as with any other normal Go package that is not under GOOS=js and\n// GOARCH=wasm.\n\n// SyscallJSValue is an actual syscall/js.Value type under WebAssembly compilation.\n//\n// It is declared here just for purposes of testing Vecty under native\n// 'go test', linting, and serving documentation under godoc.org.\ntype SyscallJSValue jsObject\n\n// Event represents a DOM event.\ntype Event struct {\n\tValue  SyscallJSValue\n\tTarget SyscallJSValue\n}\n\n// Node returns the underlying JavaScript Element or TextNode.\n//\n// It panics if it is called before the DOM node has been attached, i.e. before\n// the associated component's Mounter interface would be invoked.\nfunc (h *HTML) Node() SyscallJSValue {\n\treturn htmlNodeImpl(h)\n}\n\n// RenderIntoNode renders the given component into the existing HTML element by\n// replacing it.\n//\n// If the Component's Render method does not return an element of the same type,\n// an error of type ElementMismatchError is returned.\nfunc RenderIntoNode(node SyscallJSValue, c Component) error {\n\treturn renderIntoNode(\"RenderIntoNode\", node, c)\n}\n\nfunc toLower(s string) string {\n\treturn strings.ToLower(s)\n}\n\nvar globalValue jsObject\n\nfunc global() jsObject {\n\treturn globalValue\n}\n\nfunc undefined() wrappedObject {\n\treturn wrappedObject{j: &jsObjectImpl{}}\n}\n\nfunc funcOf(fn func(this jsObject, args []jsObject) interface{}) jsFunc {\n\treturn funcOfImpl(fn)\n}\n\ntype jsFuncImpl struct {\n\tgoFunc func(this jsObject, args []jsObject) interface{}\n}\n\nfunc (j *jsFuncImpl) String() string { return \"func\" }\nfunc (j *jsFuncImpl) Release()       {}\n\nfunc valueOf(v interface{}) jsObject { return valueOfImpl(v) }\n\ntype wrappedObject struct {\n\tjsObject\n\tj jsObject\n}\n\ntype jsObjectImpl struct {\n\tjsObject\n}\n\nfunc (e *jsObjectImpl) Equal(other jsObject) bool {\n\treturn e == other.(*jsObjectImpl)\n}\n\nvar (\n\thtmlNodeImpl = func(h *HTML) SyscallJSValue {\n\t\tpanic(\"not implemented on this architecture in non-testing environment\")\n\t}\n\tfuncOfImpl = func(fn func(this jsObject, args []jsObject) interface{}) jsFunc {\n\t\tpanic(\"not implemented on this architecture in non-testing environment\")\n\t}\n\tvalueOfImpl = func(v interface{}) jsObject {\n\t\tpanic(\"not implemented on this architecture in non-testing environment\")\n\t}\n)\n"
        },
        {
          "name": "dom_no_tinygo.go",
          "type": "blob",
          "size": 0.3701171875,
          "content": "// +build !tinygo\n\npackage vecty\n\nfunc init() {\n\tif isTest {\n\t\treturn\n\t}\n\tif global() == nil {\n\t\tpanic(\"vecty: only WebAssembly, TinyGo, and testing compilation is supported\")\n\t}\n\tif global().Get(\"document\").IsUndefined() {\n\t\tpanic(\"vecty: only running inside a browser is supported\")\n\t}\n}\n\nfunc (h *HTML) tinyGoCannotIterateNilMaps() {}\n\nfunc tinyGoAssertCopier(c Component) {}\n"
        },
        {
          "name": "dom_test.go",
          "type": "blob",
          "size": 31.263671875,
          "content": "package vecty\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\ntype testCore struct{ Core }\n\nfunc (testCore) Render() ComponentOrHTML { return Tag(\"p\") }\n\ntype testCorePtr struct{ *Core }\n\nfunc (testCorePtr) Render() ComponentOrHTML { return Tag(\"p\") }\n\nfunc TestCore(t *testing.T) {\n\t// Test that a standard *MyComponent with embedded Core works as we expect.\n\tt.Run(\"comp_ptr_and_core\", func(t *testing.T) {\n\t\tv1 := Tag(\"v1\")\n\t\tvalid := Component(&testCore{})\n\t\tvalid.Context().prevRender = v1\n\t\tif valid.Context().prevRender != v1 {\n\t\t\tt.Fatal(\"valid.Context().prevRender != v1\")\n\t\t}\n\t})\n\n\t// Test that a non-pointer MyComponent with embedded Core does not satisfy\n\t// the Component interface:\n\t//\n\t//  testCore does not implement Component (Context method has pointer receiver)\n\t//\n\tt.Run(\"comp_and_core\", func(t *testing.T) {\n\t\tisComponent := func(x interface{}) bool {\n\t\t\t_, ok := x.(Component)\n\t\t\treturn ok\n\t\t}\n\t\tif isComponent(testCore{}) {\n\t\t\tt.Fatal(\"expected !isComponent(testCompCore{})\")\n\t\t}\n\t})\n\n\t// Test what happens when a user accidentally embeds *Core instead of Core in\n\t// their component.\n\tt.Run(\"comp_ptr_and_core_ptr\", func(t *testing.T) {\n\t\tv1 := Tag(\"v1\")\n\t\tinvalid := Component(&testCorePtr{})\n\t\tgot := recoverStr(func() {\n\t\t\tinvalid.Context().prevRender = v1\n\t\t})\n\t\t// TODO(slimsag): This would happen in user-facing code too. We should\n\t\t// create a helper for when we access a component's context, which\n\t\t// would panic with a more helpful message.\n\t\twant := \"runtime error: invalid memory address or nil pointer dereference\"\n\t\tif got != want {\n\t\t\tt.Fatalf(\"got panic %q want %q\", got, want)\n\t\t}\n\t})\n\tt.Run(\"comp_and_core_ptr\", func(t *testing.T) {\n\t\tv1 := Tag(\"v1\")\n\t\tinvalid := Component(testCorePtr{})\n\t\tgot := recoverStr(func() {\n\t\t\tinvalid.Context().prevRender = v1\n\t\t})\n\t\t// TODO(slimsag): This would happen in user-facing code too. We should\n\t\t// create a helper for when we access a component's context, which\n\t\t// would panic with a more helpful message.\n\t\twant := \"runtime error: invalid memory address or nil pointer dereference\"\n\t\tif got != want {\n\t\t\tt.Fatalf(\"got panic %q want %q\", got, want)\n\t\t}\n\t})\n}\n\n// TODO(slimsag): TestUnmounter; Unmounter.Unmount\n\nfunc TestHTML_Node(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tx := undefined()\n\th := &HTML{node: x}\n\tif !h.Node().Equal(x.j) {\n\t\tt.Fatal(\"h.Node() != x\")\n\t}\n}\n\n// TestHTML_reconcile_std tests that (*HTML).reconcile against an old HTML instance\n// works as expected (i.e. that it updates nodes correctly).\nfunc TestHTML_reconcile_std(t *testing.T) {\n\tt.Run(\"text_identical\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\tinit := Text(\"foobar\")\n\t\tinit.reconcile(nil)\n\n\t\ttarget := Text(\"foobar\")\n\t\ttarget.reconcile(init)\n\t})\n\tt.Run(\"text_diff\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\tinit := Text(\"bar\")\n\t\tinit.reconcile(nil)\n\n\t\ttarget := Text(\"foo\")\n\t\ttarget.reconcile(init)\n\t})\n\tt.Run(\"properties\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\tinitHTML    *HTML\n\t\t\ttargetHTML  *HTML\n\t\t\tsortedLines [][2]int\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"diff\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Property(\"a\", 1), Property(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Property(\"a\", 3), Property(\"b\", \"4foobar\"))),\n\t\t\t\tsortedLines: [][2]int{{3, 4}, {12, 13}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"remove\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Property(\"a\", 1), Property(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Property(\"a\", 3))),\n\t\t\t\tsortedLines: [][2]int{{3, 4}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"replaced_elem_diff\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Property(\"a\", 1), Property(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"span\", Markup(Property(\"a\", 3), Property(\"b\", \"4foobar\"))),\n\t\t\t\tsortedLines: [][2]int{{3, 4}, {11, 12}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"replaced_elem_shared\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Property(\"a\", 1), Property(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"span\", Markup(Property(\"a\", 1), Property(\"b\", \"4foobar\"))),\n\t\t\t\tsortedLines: [][2]int{{3, 4}, {11, 12}},\n\t\t\t},\n\t\t}\n\t\tfor _, tst := range cases {\n\t\t\tt.Run(tst.name, func(t *testing.T) {\n\t\t\t\tts := testSuite(t)\n\t\t\t\tdefer ts.multiSortedDone(tst.sortedLines...)\n\n\t\t\t\ttst.initHTML.reconcile(nil)\n\t\t\t\tts.record(\"(first reconcile done)\")\n\t\t\t\ttst.targetHTML.reconcile(tst.initHTML)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"attributes\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\tinitHTML    *HTML\n\t\t\ttargetHTML  *HTML\n\t\t\tsortedLines [][2]int\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"diff\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Attribute(\"a\", 1), Attribute(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Attribute(\"a\", 3), Attribute(\"b\", \"4foobar\"))),\n\t\t\t\tsortedLines: [][2]int{{3, 4}, {12, 13}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"remove\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Attribute(\"a\", 1), Attribute(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Attribute(\"a\", 3))),\n\t\t\t\tsortedLines: [][2]int{{3, 4}},\n\t\t\t},\n\t\t}\n\t\tfor _, tst := range cases {\n\t\t\tt.Run(tst.name, func(t *testing.T) {\n\t\t\t\tts := testSuite(t)\n\t\t\t\tdefer ts.multiSortedDone(tst.sortedLines...)\n\n\t\t\t\ttst.initHTML.reconcile(nil)\n\t\t\t\tts.record(\"(first reconcile done)\")\n\t\t\t\ttst.targetHTML.reconcile(tst.initHTML)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"class\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\tinitHTML    *HTML\n\t\t\ttargetHTML  *HTML\n\t\t\tsortedLines [][2]int\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"multi\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Class(\"a\"), Class(\"b\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Class(\"a\"), Class(\"c\"))),\n\t\t\t\tsortedLines: [][2]int{{4, 5}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"diff\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Class(\"a\", \"b\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Class(\"a\", \"c\"))),\n\t\t\t\tsortedLines: [][2]int{{4, 5}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"remove\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Class(\"a\", \"b\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Class(\"a\"))),\n\t\t\t\tsortedLines: [][2]int{{4, 5}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"map\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(ClassMap{\"a\": true, \"b\": true})),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(ClassMap{\"a\": true})),\n\t\t\t\tsortedLines: [][2]int{{4, 5}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"map_toggle\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(ClassMap{\"a\": true, \"b\": true})),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(ClassMap{\"a\": true, \"b\": false})),\n\t\t\t\tsortedLines: [][2]int{{4, 5}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"combo\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(ClassMap{\"a\": true, \"b\": true}, Class(\"c\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(ClassMap{\"a\": true, \"b\": false}, Class(\"d\"))),\n\t\t\t\tsortedLines: [][2]int{{4, 6}, {11, 12}},\n\t\t\t},\n\t\t}\n\t\tfor _, tst := range cases {\n\t\t\tt.Run(tst.name, func(t *testing.T) {\n\t\t\t\tts := testSuite(t)\n\t\t\t\tdefer ts.multiSortedDone(tst.sortedLines...)\n\n\t\t\t\ttst.initHTML.reconcile(nil)\n\t\t\t\tts.record(\"(first reconcile done)\")\n\t\t\t\ttst.targetHTML.reconcile(tst.initHTML)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"dataset\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\tinitHTML    *HTML\n\t\t\ttargetHTML  *HTML\n\t\t\tsortedLines [][2]int\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"diff\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Data(\"a\", \"1\"), Data(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Data(\"a\", \"3\"), Data(\"b\", \"4foobar\"))),\n\t\t\t\tsortedLines: [][2]int{{5, 6}, {14, 15}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"remove\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Data(\"a\", \"1\"), Data(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Data(\"a\", \"3\"))),\n\t\t\t\tsortedLines: [][2]int{{5, 6}},\n\t\t\t},\n\t\t}\n\t\tfor _, tst := range cases {\n\t\t\tt.Run(tst.name, func(t *testing.T) {\n\t\t\t\tts := testSuite(t)\n\t\t\t\tdefer ts.multiSortedDone(tst.sortedLines...)\n\n\t\t\t\ttst.initHTML.reconcile(nil)\n\t\t\t\tts.record(\"(first reconcile done)\")\n\t\t\t\ttst.targetHTML.reconcile(tst.initHTML)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"style\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\tinitHTML    *HTML\n\t\t\ttargetHTML  *HTML\n\t\t\tsortedLines [][2]int\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"diff\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Style(\"a\", \"1\"), Style(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Style(\"a\", \"3\"), Style(\"b\", \"4foobar\"))),\n\t\t\t\tsortedLines: [][2]int{{6, 7}, {15, 16}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"remove\",\n\t\t\t\tinitHTML:    Tag(\"div\", Markup(Style(\"a\", \"1\"), Style(\"b\", \"2foobar\"))),\n\t\t\t\ttargetHTML:  Tag(\"div\", Markup(Style(\"a\", \"3\"))),\n\t\t\t\tsortedLines: [][2]int{{6, 7}},\n\t\t\t},\n\t\t}\n\t\tfor _, tst := range cases {\n\t\t\tt.Run(tst.name, func(t *testing.T) {\n\t\t\t\tts := testSuite(t)\n\t\t\t\tdefer ts.multiSortedDone(tst.sortedLines...)\n\n\t\t\t\ttst.initHTML.reconcile(nil)\n\t\t\t\tts.record(\"(first reconcile done)\")\n\t\t\t\ttst.targetHTML.reconcile(tst.initHTML)\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"event_listener\", func(t *testing.T) {\n\t\t// TODO(pdf): Mock listener functions for equality testing\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\tinitEventListeners := []Applyer{\n\t\t\t&EventListener{Name: \"click\"},\n\t\t\t&EventListener{Name: \"keydown\"},\n\t\t}\n\t\tprev := Tag(\"div\", Markup(initEventListeners...))\n\t\tprev.reconcile(nil)\n\t\tts.record(\"(expected two added event listeners above)\")\n\t\tfor i, m := range initEventListeners {\n\t\t\tlistener := m.(*EventListener)\n\t\t\tif listener.wrapper == nil {\n\t\t\t\tt.Fatalf(\"listener %d wrapper == nil: %+v\", i, listener)\n\t\t\t}\n\t\t}\n\n\t\ttargetEventListeners := []Applyer{\n\t\t\t&EventListener{Name: \"click\"},\n\t\t}\n\t\th := Tag(\"div\", Markup(targetEventListeners...))\n\t\th.reconcile(prev)\n\t\tts.record(\"(expected two removed, one added event listeners above)\")\n\t\tfor i, m := range targetEventListeners {\n\t\t\tlistener := m.(*EventListener)\n\t\t\tif listener.wrapper == nil {\n\t\t\t\tt.Fatalf(\"listener %d wrapper == nil: %+v\", i, listener)\n\t\t\t}\n\t\t}\n\t})\n\n\t// TODO(pdf): test (*HTML).reconcile child mutations, and value/checked properties\n\t// TODO(pdf): test multi-pass reconcile of persistent component pointer children, ref: https://github.com/hexops/vecty/pull/124\n}\n\n// TestHTML_reconcile_nil tests that (*HTML).reconcile(nil) works as expected (i.e.\n// that it creates nodes correctly).\nfunc TestHTML_reconcile_nil(t *testing.T) {\n\tt.Run(\"one_of_tag_or_text\", func(t *testing.T) {\n\t\tgot := recoverStr(func() {\n\t\t\th := &HTML{text: \"hello\", tag: \"div\"}\n\t\t\th.reconcile(nil)\n\t\t})\n\t\twant := \"vecty: internal error (only one of HTML.tag or HTML.text may be set)\"\n\t\tif got != want {\n\t\t\tt.Fatalf(\"got panic %q want %q\", got, want)\n\t\t}\n\t})\n\tt.Run(\"unsafe_text\", func(t *testing.T) {\n\t\tgot := recoverStr(func() {\n\t\t\th := &HTML{text: \"hello\", innerHTML: \"foobar\"}\n\t\t\th.reconcile(nil)\n\t\t})\n\t\twant := \"vecty: only HTML may have UnsafeHTML attribute\"\n\t\tif got != want {\n\t\t\tt.Fatalf(\"got panic %q want %q\", got, want)\n\t\t}\n\t})\n\tt.Run(\"create_element\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\th := Tag(\"strong\")\n\t\th.reconcile(nil)\n\t})\n\tt.Run(\"create_element_ns\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\th := Tag(\"strong\", Markup(Namespace(\"foobar\")))\n\t\th.reconcile(nil)\n\t})\n\tt.Run(\"create_text_node\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\th := Text(\"hello\")\n\t\th.reconcile(nil)\n\t})\n\tt.Run(\"inner_html\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\th := Tag(\"div\", Markup(UnsafeHTML(\"<p>hello</p>\")))\n\t\th.reconcile(nil)\n\t})\n\tt.Run(\"properties\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.sortedDone(3, 4)\n\n\t\th := Tag(\"div\", Markup(Property(\"a\", 1), Property(\"b\", \"2foobar\")))\n\t\th.reconcile(nil)\n\t})\n\tt.Run(\"attributes\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.sortedDone(3, 4)\n\n\t\th := Tag(\"div\", Markup(Attribute(\"a\", 1), Attribute(\"b\", \"2foobar\")))\n\t\th.reconcile(nil)\n\t})\n\tt.Run(\"dataset\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.sortedDone(5, 6)\n\n\t\th := Tag(\"div\", Markup(Data(\"a\", \"1\"), Data(\"b\", \"2foobar\")))\n\t\th.reconcile(nil)\n\t})\n\tt.Run(\"style\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.sortedDone(6, 7)\n\n\t\th := Tag(\"div\", Markup(Style(\"a\", \"1\"), Style(\"b\", \"2foobar\")))\n\t\th.reconcile(nil)\n\t})\n\tt.Run(\"add_event_listener\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\te0 := &EventListener{Name: \"click\"}\n\t\te1 := &EventListener{Name: \"keydown\"}\n\t\th := Tag(\"div\", Markup(e0, e1))\n\t\th.reconcile(nil)\n\t\tif e0.wrapper == nil {\n\t\t\tt.Fatal(\"e0.wrapper == nil\")\n\t\t}\n\t\tif e1.wrapper == nil {\n\t\t\tt.Fatal(\"e1.wrapper == nil\")\n\t\t}\n\t})\n\tt.Run(\"children\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\tvar compRenderCalls int\n\t\tcompRender := Tag(\"div\")\n\t\tcomp := &componentFunc{\n\t\t\tid: \"foobar\",\n\t\t\trender: func() ComponentOrHTML {\n\t\t\t\tcompRenderCalls++\n\t\t\t\treturn compRender\n\t\t\t},\n\t\t}\n\t\th := Tag(\"div\", Tag(\"div\", comp))\n\t\th.reconcile(nil)\n\t\tif compRenderCalls != 1 {\n\t\t\tt.Fatal(\"compRenderCalls != 1\")\n\t\t}\n\t\tif comp.Context().prevRenderComponent.(*componentFunc).id != comp.id {\n\t\t\tt.Fatal(\"comp.Context().prevRenderComponent.(*componentFunc).id != comp.id\")\n\t\t}\n\t\tif comp.Context().prevRender != compRender {\n\t\t\tt.Fatal(\"comp.Context().prevRender != compRender\")\n\t\t}\n\t})\n\tt.Run(\"children_render_nil\", func(t *testing.T) {\n\t\tts := testSuite(t)\n\t\tdefer ts.done()\n\n\t\tvar compRenderCalls int\n\t\tcomp := &componentFunc{\n\t\t\tid: \"foobar\",\n\t\t\trender: func() ComponentOrHTML {\n\t\t\t\tcompRenderCalls++\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\t\th := Tag(\"div\", Tag(\"div\", comp))\n\t\th.reconcile(nil)\n\t\tif compRenderCalls != 1 {\n\t\t\tt.Fatal(\"compRenderCalls != 1\")\n\t\t}\n\t\tif comp.Context().prevRenderComponent.(*componentFunc).id != comp.id {\n\t\t\tt.Fatal(\"comp.Context().prevRenderComponent.(*componentFunc).id != comp.id\")\n\t\t}\n\t\tif comp.Context().prevRender == nil {\n\t\t\tt.Fatal(\"comp.Context().prevRender == nil\")\n\t\t}\n\t})\n}\n\nfunc TestTag(t *testing.T) {\n\tmarkupCalled := false\n\twant := \"foobar\"\n\th := Tag(want, Markup(markupFunc(func(h *HTML) {\n\t\tmarkupCalled = true\n\t})))\n\tif !markupCalled {\n\t\tt.Fatal(\"expected markup to be applied\")\n\t}\n\tif h.tag != want {\n\t\tt.Fatalf(\"got tag %q want tag %q\", h.text, want)\n\t}\n\tif h.text != \"\" {\n\t\tt.Fatal(\"expected no text\")\n\t}\n}\n\nfunc TestText(t *testing.T) {\n\tmarkupCalled := false\n\twant := \"Hello world!\"\n\th := Text(want, Markup(markupFunc(func(h *HTML) {\n\t\tmarkupCalled = true\n\t})))\n\tif !markupCalled {\n\t\tt.Fatal(\"expected markup to be applied\")\n\t}\n\tif h.text != want {\n\t\tt.Fatalf(\"got text %q want text %q\", h.text, want)\n\t}\n\tif h.tag != \"\" {\n\t\tt.Fatal(\"expected no tag\")\n\t}\n}\n\n// TestRerender_nil tests that Rerender panics when the component argument is\n// nil.\nfunc TestRerender_nil(t *testing.T) {\n\tgotPanic := \"\"\n\tfunc() {\n\t\tdefer func() {\n\t\t\tr := recover()\n\t\t\tif r != nil {\n\t\t\t\tgotPanic = fmt.Sprint(r)\n\t\t\t}\n\t\t}()\n\t\tRerender(nil)\n\t}()\n\texpected := \"vecty: Rerender illegally called with a nil Component argument\"\n\tif gotPanic != expected {\n\t\tt.Fatalf(\"got panic %q expected %q\", gotPanic, expected)\n\t}\n}\n\n// TestRerender_no_prevRender tests the behavior of Rerender when there is no\n// previous render.\nfunc TestRerender_no_prevRender(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tgot := recoverStr(func() {\n\t\tRerender(&componentFunc{\n\t\t\trender: func() ComponentOrHTML {\n\t\t\t\tpanic(\"expected no Render call\")\n\t\t\t},\n\t\t\tskipRender: func(prev Component) bool {\n\t\t\t\tpanic(\"expected no SkipRender call\")\n\t\t\t},\n\t\t})\n\t})\n\twant := \"vecty: Rerender invoked on Component that has never been rendered\"\n\tif got != want {\n\t\tt.Fatalf(\"got panic %q expected %q\", got, want)\n\t}\n}\n\n// TestRerender_identical tests the behavior of Rerender when there is a\n// previous render which is identical to the new render.\nfunc TestRerender_identical(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.strings.mock(`global.Get(\"document\").Get(\"readyState\")`, \"complete\")\n\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\t// Perform the initial render of the component.\n\trender := Tag(\"body\")\n\tvar renderCalled, skipRenderCalled int\n\tcomp := &componentFunc{\n\t\tid: \"original\",\n\t\trender: func() ComponentOrHTML {\n\t\t\trenderCalled++\n\t\t\treturn render\n\t\t},\n\t}\n\tRenderBody(comp)\n\tif renderCalled != 1 {\n\t\tt.Fatal(\"renderCalled != 1\")\n\t}\n\tif comp.Context().prevRender != render {\n\t\tt.Fatal(\"comp.Context().prevRender != render\")\n\t}\n\tif comp.Context().prevRenderComponent.(*componentFunc).id != \"original\" {\n\t\tt.Fatal(`comp.Context().prevRenderComponent.(*componentFunc).id != \"original\"`)\n\t}\n\n\t// Perform a re-render.\n\tnewRender := Tag(\"body\")\n\tcomp.id = \"modified\"\n\tcomp.render = func() ComponentOrHTML {\n\t\trenderCalled++\n\t\treturn newRender\n\t}\n\tcomp.skipRender = func(prev Component) bool {\n\t\tif comp.id != \"modified\" {\n\t\t\tpanic(`comp.id != \"modified\"`)\n\t\t}\n\t\tif comp.Context().prevRenderComponent.(*componentFunc).id != \"original\" {\n\t\t\tpanic(`comp.Context().prevRenderComponent.(*componentFunc).id != \"original\"`)\n\t\t}\n\t\tif prev.(*componentFunc).id != \"original\" {\n\t\t\tpanic(`prev.(*componentFunc).id != \"original\"`)\n\t\t}\n\t\tskipRenderCalled++\n\t\treturn false\n\t}\n\tRerender(comp)\n\n\t// Invoke the render callback.\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.invokeCallbackRequestAnimationFrame(0)\n\n\tif renderCalled != 2 {\n\t\tt.Fatal(\"renderCalled != 2\")\n\t}\n\tif skipRenderCalled != 1 {\n\t\tt.Fatal(\"skipRenderCalled != 1\")\n\t}\n\tif comp.Context().prevRender != newRender {\n\t\tt.Fatal(\"comp.Context().prevRender != newRender\")\n\t}\n\tif comp.Context().prevRenderComponent.(*componentFunc).id != \"modified\" {\n\t\tt.Fatal(`comp.Context().prevRenderComponent.(*componentFunc).id != \"modified\"`)\n\t}\n}\n\n// TestRerender_change tests the behavior of Rerender when there is a\n// previous render which is different from the new render.\nfunc TestRerender_change(t *testing.T) {\n\tcases := []struct {\n\t\tname      string\n\t\tnewRender *HTML\n\t}{\n\t\t{\n\t\t\tname:      \"new_child\",\n\t\t\tnewRender: Tag(\"body\", Tag(\"div\")),\n\t\t},\n\t\t// TODO(slimsag): bug! nil produces <noscript> and we incorrectly try\n\t\t// to replace <body> with it! We should panic & warn the user.\n\t\t//{\n\t\t//\tname:      \"nil\",\n\t\t//\tnewRender: nil,\n\t\t//},\n\t}\n\tfor _, tst := range cases {\n\t\tt.Run(tst.name, func(t *testing.T) {\n\t\t\tts := testSuite(t)\n\t\t\tdefer ts.done()\n\n\t\t\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\t\t\tts.strings.mock(`global.Get(\"document\").Get(\"readyState\")`, \"complete\")\n\t\t\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\t\t\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\t\t\t// Perform the initial render of the component.\n\t\t\trender := Tag(\"body\")\n\t\t\tvar renderCalled, skipRenderCalled int\n\t\t\tcomp := &componentFunc{\n\t\t\t\tid: \"original\",\n\t\t\t\trender: func() ComponentOrHTML {\n\t\t\t\t\trenderCalled++\n\t\t\t\t\treturn render\n\t\t\t\t},\n\t\t\t}\n\t\t\tRenderBody(comp)\n\t\t\tts.record(\"(expect body to be set now)\")\n\t\t\tif renderCalled != 1 {\n\t\t\t\tt.Fatal(\"renderCalled != 1\")\n\t\t\t}\n\t\t\tif comp.Context().prevRender != render {\n\t\t\t\tt.Fatal(\"comp.Context().prevRender != render\")\n\t\t\t}\n\t\t\tif comp.Context().prevRenderComponent.(*componentFunc).id != \"original\" {\n\t\t\t\tt.Fatal(`comp.Context().prevRenderComponent.(*componentFunc).id != \"original\"`)\n\t\t\t}\n\n\t\t\t// Perform a re-render.\n\t\t\tcomp.id = \"modified\"\n\t\t\tcomp.render = func() ComponentOrHTML {\n\t\t\t\trenderCalled++\n\t\t\t\treturn tst.newRender\n\t\t\t}\n\t\t\tcomp.skipRender = func(prev Component) bool {\n\t\t\t\tif comp.id != \"modified\" {\n\t\t\t\t\tpanic(`comp.id != \"modified\"`)\n\t\t\t\t}\n\t\t\t\tif comp.Context().prevRenderComponent.(*componentFunc).id != \"original\" {\n\t\t\t\t\tpanic(`comp.Context().prevRenderComponent.(*componentFunc).id != \"original\"`)\n\t\t\t\t}\n\t\t\t\tif prev.(*componentFunc).id != \"original\" {\n\t\t\t\t\tpanic(`prev.(*componentFunc).id != \"original\"`)\n\t\t\t\t}\n\t\t\t\tskipRenderCalled++\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tRerender(comp)\n\n\t\t\t// Invoke the render callback.\n\t\t\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\t\t\tts.invokeCallbackRequestAnimationFrame(0)\n\n\t\t\tif renderCalled != 2 {\n\t\t\t\tt.Fatal(\"renderCalled != 2\")\n\t\t\t}\n\t\t\tif skipRenderCalled != 1 {\n\t\t\t\tt.Fatal(\"skipRenderCalled != 1\")\n\t\t\t}\n\t\t\tif comp.Context().prevRender != tst.newRender {\n\t\t\t\tt.Fatal(\"comp.Context().prevRender != tst.newRender\")\n\t\t\t}\n\t\t\tif comp.Context().prevRenderComponent.(*componentFunc).id != \"modified\" {\n\t\t\t\tt.Fatal(`comp.Context().prevRenderComponent.(*componentFunc).id != \"modified\"`)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestRerender_Nested tests the behavior of Rerender when there is a\n// nested Component that is exchanged for *HTML.\nfunc TestRerender_Nested(t *testing.T) {\n\tcases := []struct {\n\t\tname                     string\n\t\tinitialRender, newRender ComponentOrHTML\n\t}{\n\t\t{\n\t\t\tname:          \"html_to_component\",\n\t\t\tinitialRender: Tag(\"body\"),\n\t\t\tnewRender: &componentFunc{\n\t\t\t\trender: func() ComponentOrHTML {\n\t\t\t\t\treturn Tag(\"body\", Tag(\"div\"))\n\t\t\t\t},\n\t\t\t\tskipRender: func(Component) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"component_to_html\",\n\t\t\tinitialRender: &componentFunc{\n\t\t\t\trender: func() ComponentOrHTML {\n\t\t\t\t\treturn Tag(\"body\")\n\t\t\t\t},\n\t\t\t\tskipRender: func(Component) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t},\n\t\t\tnewRender: Tag(\"body\", Tag(\"div\")),\n\t\t},\n\t}\n\tfor _, tst := range cases {\n\t\tt.Run(tst.name, func(t *testing.T) {\n\t\t\tts := testSuite(t)\n\t\t\tdefer ts.done()\n\n\t\t\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\t\t\tts.strings.mock(`global.Get(\"document\").Get(\"readyState\")`, \"complete\")\n\t\t\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\t\t\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\t\t\t// Perform the initial render of the component.\n\t\t\tvar renderCalled, skipRenderCalled int\n\t\t\tcomp := &componentFunc{\n\t\t\t\tid: \"original\",\n\t\t\t\trender: func() ComponentOrHTML {\n\t\t\t\t\trenderCalled++\n\t\t\t\t\treturn tst.initialRender\n\t\t\t\t},\n\t\t\t}\n\t\t\tRenderBody(comp)\n\t\t\tts.record(\"(expect body to be set now)\")\n\t\t\tif renderCalled != 1 {\n\t\t\t\tt.Fatal(\"renderCalled != 1\")\n\t\t\t}\n\t\t\tif comp.Context().prevRender != tst.initialRender {\n\t\t\t\tt.Fatal(\"comp.Context().prevRender != render\")\n\t\t\t}\n\t\t\tif comp.Context().prevRenderComponent.(*componentFunc).id != \"original\" {\n\t\t\t\tt.Fatal(`comp.Context().prevRenderComponent.(*componentFunc).id != \"original\"`)\n\t\t\t}\n\n\t\t\t// Perform a re-render.\n\t\t\tcomp.id = \"modified\"\n\t\t\tcomp.render = func() ComponentOrHTML {\n\t\t\t\trenderCalled++\n\t\t\t\treturn tst.newRender\n\t\t\t}\n\t\t\tcomp.skipRender = func(prev Component) bool {\n\t\t\t\tif comp.id != \"modified\" {\n\t\t\t\t\tpanic(`comp.id != \"modified\"`)\n\t\t\t\t}\n\t\t\t\tif comp.Context().prevRenderComponent.(*componentFunc).id != \"original\" {\n\t\t\t\t\tpanic(`comp.Context().prevRenderComponent.(*componentFunc).id != \"original\"`)\n\t\t\t\t}\n\t\t\t\tif prev.(*componentFunc).id != \"original\" {\n\t\t\t\t\tpanic(`prev.(*componentFunc).id != \"original\"`)\n\t\t\t\t}\n\t\t\t\tskipRenderCalled++\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tRerender(comp)\n\n\t\t\t// Invoke the render callback.\n\t\t\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\t\t\tts.invokeCallbackRequestAnimationFrame(0)\n\n\t\t\tif skipRenderCalled != 1 {\n\t\t\t\tt.Fatal(\"skipRenderCalled != 1\")\n\t\t\t}\n\t\t\tif comp.Context().prevRender != tst.newRender {\n\t\t\t\tt.Fatal(\"comp.Context().prevRender != tst.newRender\")\n\t\t\t}\n\t\t\tif comp.Context().prevRenderComponent.(*componentFunc).id != \"modified\" {\n\t\t\t\tt.Fatal(`comp.Context().prevRenderComponent.(*componentFunc).id != \"modified\"`)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype persistentComponentBody struct {\n\tCore\n}\n\nfunc (c *persistentComponentBody) Render() ComponentOrHTML {\n\treturn Tag(\n\t\t\"body\",\n\t\t&persistentComponent{},\n\t)\n}\n\nvar (\n\tlastRenderedComponent Component\n\trenderCount           int\n)\n\ntype persistentComponent struct {\n\tCore\n}\n\nfunc (c *persistentComponent) Render() ComponentOrHTML {\n\tif lastRenderedComponent == nil {\n\t\tlastRenderedComponent = c\n\t} else if lastRenderedComponent != c {\n\t\tpanic(\"unexpected last rendered component\")\n\t}\n\trenderCount++\n\treturn Tag(\"div\")\n}\n\n// TestRerender_persistent tests the behavior of rendering persistent\n// components.\nfunc TestRerender_persistent(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.strings.mock(`global.Get(\"document\").Get(\"readyState\")`, \"complete\")\n\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\tlastRenderedComponent = nil\n\trenderCount = 0\n\n\tcomp := &persistentComponentBody{}\n\t// Perform the initial render of the component.\n\tRenderBody(comp)\n\n\tif renderCount != 1 {\n\t\tt.Fatal(\"renderCount != 1\")\n\t}\n\n\t// Perform a re-render.\n\tRerender(comp)\n\n\t// Invoke the render callback.\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.invokeCallbackRequestAnimationFrame(0)\n\n\tif renderCount != 2 {\n\t\tt.Fatal(\"renderCount != 2\")\n\t}\n\n\t// Perform a re-render.\n\tRerender(comp)\n\n\t// Invoke the render callback.\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.invokeCallbackRequestAnimationFrame(0)\n\n\tif renderCount != 3 {\n\t\tt.Fatal(\"renderCount != 3\")\n\t}\n}\n\ntype persistentComponentBody2 struct {\n\tCore\n}\n\nfunc (c *persistentComponentBody2) Render() ComponentOrHTML {\n\treturn Tag(\n\t\t\"body\",\n\t\t&persistentWrapperComponent{},\n\t)\n}\n\ntype persistentWrapperComponent struct {\n\tCore\n}\n\nfunc (c *persistentWrapperComponent) Render() ComponentOrHTML {\n\treturn &persistentComponent{}\n}\n\n// TestRerender_persistent_direct tests the behavior of rendering persistent\n// components that are directly returned by Render().\nfunc TestRerender_persistent_direct(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.strings.mock(`global.Get(\"document\").Get(\"readyState\")`, \"complete\")\n\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\tlastRenderedComponent = nil\n\trenderCount = 0\n\n\tcomp := &persistentComponentBody2{}\n\t// Perform the initial render of the component.\n\tRenderBody(comp)\n\n\tif renderCount != 1 {\n\t\tt.Fatal(\"renderCount != 1\")\n\t}\n\n\t// Perform a re-render.\n\tRerender(comp)\n\n\t// Invoke the render callback.\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.invokeCallbackRequestAnimationFrame(0)\n\n\tif renderCount != 2 {\n\t\tt.Fatal(\"renderCount != 2\")\n\t}\n\n\t// Perform a re-render.\n\tRerender(comp)\n\n\t// Invoke the render callback.\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.invokeCallbackRequestAnimationFrame(0)\n\n\tif renderCount != 3 {\n\t\tt.Fatal(\"renderCount != 3\")\n\t}\n}\n\n// TestRenderBody_ExpectsBody tests that RenderBody panics when something other\n// than a \"body\" tag is rendered by the component.\nfunc TestRenderBody_ExpectsBody(t *testing.T) {\n\tcases := []struct {\n\t\tname      string\n\t\trender    *HTML\n\t\twantPanic string\n\t}{\n\t\t{\n\t\t\tname:      \"text\",\n\t\t\trender:    Text(\"Hello world!\"),\n\t\t\twantPanic: \"vecty: RenderBody: expected Component.Render to return a \\\"body\\\", found \\\"\\\"\", // TODO(slimsag): error message bug\n\t\t},\n\t\t{\n\t\t\tname:      \"div\",\n\t\t\trender:    Tag(\"div\"),\n\t\t\twantPanic: \"vecty: RenderBody: expected Component.Render to return a \\\"body\\\", found \\\"div\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:      \"nil\",\n\t\t\trender:    nil,\n\t\t\twantPanic: \"vecty: RenderBody: expected Component.Render to return a \\\"body\\\", found \\\"noscript\\\"\",\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tts := testSuite(t)\n\t\t\tdefer ts.done()\n\n\t\t\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\t\t\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\t\t\tvar gotPanic string\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tr := recover()\n\t\t\t\t\tif r != nil {\n\t\t\t\t\t\tgotPanic = fmt.Sprint(r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tRenderBody(&componentFunc{\n\t\t\t\t\trender: func() ComponentOrHTML {\n\t\t\t\t\t\treturn c.render\n\t\t\t\t\t},\n\t\t\t\t\tskipRender: func(prev Component) bool { return false },\n\t\t\t\t})\n\t\t\t}()\n\t\t\tif c.wantPanic != gotPanic {\n\t\t\t\tt.Fatalf(\"want panic:\\n%q\\ngot panic:\\n%q\", c.wantPanic, gotPanic)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestRenderBody_RenderSkipper_Skip tests that RenderBody panics when the\n// component's SkipRender method returns skip == true.\nfunc TestRenderBody_RenderSkipper_Skip(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\tcomp := &componentFunc{\n\t\trender: func() ComponentOrHTML {\n\t\t\treturn Tag(\"body\")\n\t\t},\n\t\tskipRender: func(prev Component) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tfakePrevRender := *comp\n\tcomp.Context().prevRenderComponent = &fakePrevRender\n\tgot := recoverStr(func() {\n\t\tRenderBody(comp)\n\t})\n\twant := \"vecty: RenderBody: Component.SkipRender illegally returned true\"\n\tif got != want {\n\t\tt.Fatalf(\"got panic %q want %q\", got, want)\n\t}\n}\n\n// TestRenderBody_Standard_loaded tests that RenderBody properly handles the\n// standard case of rendering into the \"body\" tag when the DOM is in a loaded\n// state.\nfunc TestRenderBody_Standard_loaded(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tts.strings.mock(`global.Get(\"document\").Get(\"readyState\")`, \"loaded\")\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\tRenderBody(&componentFunc{\n\t\trender: func() ComponentOrHTML {\n\t\t\treturn Tag(\"body\")\n\t\t},\n\t})\n}\n\n// TestRenderBody_Standard_loading tests that RenderBody properly handles the\n// standard case of rendering into the \"body\" tag when the DOM is in a loading\n// state.\nfunc TestRenderBody_Standard_loading(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tts.strings.mock(`global.Get(\"document\").Get(\"readyState\")`, \"loading\")\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\tRenderBody(&componentFunc{\n\t\trender: func() ComponentOrHTML {\n\t\t\treturn Tag(\"body\")\n\t\t},\n\t})\n\n\tts.record(\"(invoking DOMContentLoaded event listener)\")\n\tts.invokeCallbackDOMContentLoaded()\n}\n\n// TestRenderBody_Nested tests that RenderBody properly handles nested\n// Components.\nfunc TestRenderBody_Nested(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tts.strings.mock(`global.Get(\"document\").Get(\"readyState\")`, \"complete\")\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\tRenderBody(&componentFunc{\n\t\trender: func() ComponentOrHTML {\n\t\t\treturn &componentFunc{\n\t\t\t\trender: func() ComponentOrHTML {\n\t\t\t\t\treturn &componentFunc{\n\t\t\t\t\t\trender: func() ComponentOrHTML {\n\t\t\t\t\t\t\treturn Tag(\"body\")\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t})\n}\n\n// TestSetTitle tests that the SetTitle function performs the correct DOM\n// operations.\nfunc TestSetTitle(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tSetTitle(\"foobartitle\")\n}\n\n// TestAddStylesheet tests that the AddStylesheet performs the correct DOM\n// operations.\nfunc TestAddStylesheet(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tAddStylesheet(\"https://google.com/foobar.css\")\n}\n\nfunc TestKeyedChild_DifferentType(t *testing.T) {\n\tts := testSuite(t)\n\tdefer ts.done()\n\n\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\tts.strings.mock(`global.Get(\"document\").Get(\"readyState\")`, \"complete\")\n\tts.strings.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\").Get(\"nodeName\")`, \"BODY\")\n\tts.truthies.mock(`global.Get(\"document\").Call(\"querySelector\", \"body\")`, true)\n\n\tcomp := &componentFunc{\n\t\trender: func() ComponentOrHTML {\n\t\t\treturn Tag(\n\t\t\t\t\"body\",\n\t\t\t\tTag(\n\t\t\t\t\t\"tag1\",\n\t\t\t\t\tMarkup(Key(\"key\")),\n\t\t\t\t),\n\t\t\t)\n\t\t},\n\t\tskipRender: func(prev Component) bool { return false },\n\t}\n\n\tRenderBody(comp)\n\n\trerender := func() {\n\t\tRerender(comp)\n\t\tts.ints.mock(`global.Call(\"requestAnimationFrame\", func)`, 0)\n\t\tts.invokeCallbackRequestAnimationFrame(0)\n\t}\n\n\t// Re-render\n\trerender()\n\n\tcomp.render = func() ComponentOrHTML {\n\t\treturn Tag(\n\t\t\t\"body\",\n\t\t\tTag(\n\t\t\t\t\"tag2\",\n\t\t\t\tMarkup(Key(\"key\")),\n\t\t\t),\n\t\t)\n\t}\n\n\trerender()\n}\n"
        },
        {
          "name": "dom_tinygo.go",
          "type": "blob",
          "size": 2.7255859375,
          "content": "// +build tinygo\n\npackage vecty\n\nimport \"fmt\"\n\nfunc init() {\n\tif isTest {\n\t\treturn\n\t}\n\t// BUG: TinyGo does not allow calling global() inside of init like this.\n\t//\n\t//if global() == nil {\n\t//\tpanic(\"vecty: only WebAssembly, TinyGo, and testing compilation is supported\")\n\t//}\n\t//if global().Get(\"document\").IsUndefined() {\n\t//\tpanic(\"vecty: only running inside a browser is supported\")\n\t//}\n}\n\n// BUG: TinyGo does not allow iterating over null maps like these:\n//\n// \tpanic: runtime error: nil pointer dereference\n//\n// \tmain.wasm:1 Uncaught (in promise) RuntimeError: unreachable\n// \t\tat runtime.runtimePanic (http://localhost:8081/main.wasm:wasm-function[61]:0x4472)\n// \t\tat runtime.nilPanic (http://localhost:8081/main.wasm:wasm-function[46]:0x3277)\n// \t\tat runtime.hashmapNext (http://localhost:8081/main.wasm:wasm-function[83]:0x5881)\n// \t\tat (*github.com/hexops/vecty.HTML).reconcileProperties (http://localhost:8081/main.wasm:wasm-function[198]:0x117f4)\n// \t\tat (*github.com/hexops/vecty.HTML).reconcile (http://localhost:8081/main.wasm:wasm-function[175]:0xda6c)\n// \t\tat github.com/hexops/vecty.renderComponent (http://localhost:8081/main.wasm:wasm-function[176]:0xf00d)\n// \t\tat github.com/hexops/vecty.renderIntoNode (http://localhost:8081/main.wasm:wasm-function[153]:0xbbe3)\n// \t\tat github.com/hexops/vecty.RenderBody (http://localhost:8081/main.wasm:wasm-function[147]:0xb4a8)\n// \t\tat github.com/hexops/vecty/example/hellovecty.main (http://localhost:8081/main.wasm:wasm-function[107]:0x6e36)\n// \t\tat runtime.run$1 (http://localhost:8081/main.wasm:wasm-function[55]:0x40c6)\n//\nfunc (h *HTML) tinyGoCannotIterateNilMaps() {\n\tif h.properties == nil {\n\t\th.properties = map[string]interface{}{}\n\t}\n\tif h.attributes == nil {\n\t\th.attributes = map[string]interface{}{}\n\t}\n\tif h.classes == nil {\n\t\th.classes = map[string]struct{}{}\n\t}\n\tif h.dataset == nil {\n\t\th.dataset = map[string]string{}\n\t}\n\tif h.styles == nil {\n\t\th.styles = map[string]string{}\n\t}\n}\n\nfunc tinyGoAssertCopier(c Component) {\n\t_, ok := c.(Copier)\n\tif ok {\n\t\treturn\n\t}\n\tprintln(c)\n\tpanic(fmt.Sprintf(`vecty: Component %T does not implement vecty.Copier interface\n\nTinyGo does not support Vecty components that do not implement the vecty.Copier interface.\n\n## What does this mean?\n\nTinyGo currently does not have support for reflect.New: https://github.com/tinygo-org/tinygo/issues/1087\nThis prevents Vecty from automatically copying your component for you using reflection.\n\n## How do I fix this?\n\nYou will need to implement the 'vecty.Copier' interface on your component, e.g.:\n\n\tfunc (c *MyComponent) Copy() vecty.Component {\n\t\tcpy := *c\n\t\treturn &cpy\n\t}\n\n## Which component?\n\nVecty has printed as much information as it can about the component above. Unfortunately, you will need to hunt it down yourself.\n\n`, c))\n}\n"
        },
        {
          "name": "domutil.go",
          "type": "blob",
          "size": 0.166015625,
          "content": "package vecty\n\nfunc replaceNode(newNode, oldNode jsObject) {\n\tif newNode.Equal(oldNode) {\n\t\treturn\n\t}\n\toldNode.Get(\"parentNode\").Call(\"replaceChild\", newNode, oldNode)\n}\n"
        },
        {
          "name": "elem",
          "type": "tree",
          "content": null
        },
        {
          "name": "event",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0390625,
          "content": "module github.com/hexops/vecty\n\ngo 1.14\n"
        },
        {
          "name": "markup.go",
          "type": "blob",
          "size": 7.6142578125,
          "content": "package vecty\n\nimport \"reflect\"\n\n// EventListener is markup that specifies a callback function to be invoked when\n// the named DOM event is fired.\ntype EventListener struct {\n\tName                string\n\tListener            func(*Event)\n\tcallPreventDefault  bool\n\tcallStopPropagation bool\n\twrapper             jsFunc\n}\n\n// PreventDefault prevents the default behavior of the event from occurring.\n//\n// See https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault.\nfunc (l *EventListener) PreventDefault() *EventListener {\n\tl.callPreventDefault = true\n\treturn l\n}\n\n// StopPropagation prevents further propagation of the current event in the\n// capturing and bubbling phases.\n//\n// See https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation.\nfunc (l *EventListener) StopPropagation() *EventListener {\n\tl.callStopPropagation = true\n\treturn l\n}\n\n// Apply implements the Applyer interface.\nfunc (l *EventListener) Apply(h *HTML) {\n\th.eventListeners = append(h.eventListeners, l)\n}\n\n// MarkupOrChild represents one of:\n//\n//  Component\n//  *HTML\n//  List\n//  KeyedList\n//  nil\n//  MarkupList\n//\n// An unexported method on this interface ensures at compile time that the\n// underlying value must be one of these types.\ntype MarkupOrChild interface {\n\tisMarkupOrChild()\n}\n\nfunc apply(m MarkupOrChild, h *HTML) {\n\tswitch m := m.(type) {\n\tcase MarkupList:\n\t\tm.Apply(h)\n\tcase nil:\n\t\th.children = append(h.children, nil)\n\tcase Component, *HTML, List, KeyedList:\n\t\th.children = append(h.children, m.(ComponentOrHTML))\n\tdefault:\n\t\tpanic(\"vecty: internal error (unexpected MarkupOrChild type \" + reflect.TypeOf(m).String() + \")\")\n\t}\n}\n\n// Applyer represents some type of markup (a style, property, data, etc) which\n// can be applied to a given HTML element or text node.\ntype Applyer interface {\n\t// Apply applies the markup to the given HTML element or text node.\n\tApply(h *HTML)\n}\n\ntype markupFunc func(h *HTML)\n\nfunc (m markupFunc) Apply(h *HTML) { m(h) }\n\n// Style returns an Applyer which applies the given CSS style. Generally, this\n// function is not used directly but rather the style subpackage (which is type\n// safe) should be used instead.\nfunc Style(key, value string) Applyer {\n\treturn markupFunc(func(h *HTML) {\n\t\tif h.styles == nil {\n\t\t\th.styles = make(map[string]string)\n\t\t}\n\t\th.styles[key] = value\n\t})\n}\n\n// Key returns an Applyer that uniquely identifies the HTML element amongst its\n// siblings. When used, all other sibling elements and components must also be\n// keyed.\nfunc Key(key interface{}) Applyer {\n\treturn markupFunc(func(h *HTML) {\n\t\th.key = key\n\t})\n}\n\n// Property returns an Applyer which applies the given JavaScript property to an\n// HTML element or text node. Generally, this function is not used directly but\n// rather the prop and style subpackages (which are type safe) should be used instead.\n//\n// To set style, use style package or Style. Property panics if key is \"style\".\nfunc Property(key string, value interface{}) Applyer {\n\tif key == \"style\" {\n\t\tpanic(`vecty: Property called with key \"style\"; style package or Style should be used instead`)\n\t}\n\treturn markupFunc(func(h *HTML) {\n\t\tif h.properties == nil {\n\t\t\th.properties = make(map[string]interface{})\n\t\t}\n\t\th.properties[key] = value\n\t})\n}\n\n// Attribute returns an Applyer which applies the given attribute to an element.\n//\n// In most situations, you should use Property function, or the prop subpackage\n// (which is type-safe) instead. There are only a few attributes (aria-*, role,\n// etc) which do not have equivalent properties. Always opt for the property\n// first, before relying on an attribute.\nfunc Attribute(key string, value interface{}) Applyer {\n\treturn markupFunc(func(h *HTML) {\n\t\tif h.attributes == nil {\n\t\t\th.attributes = make(map[string]interface{})\n\t\t}\n\t\th.attributes[key] = value\n\t})\n}\n\n// Data returns an Applyer which applies the given data attribute.\nfunc Data(key, value string) Applyer {\n\treturn markupFunc(func(h *HTML) {\n\t\tif h.dataset == nil {\n\t\t\th.dataset = make(map[string]string)\n\t\t}\n\t\th.dataset[key] = value\n\t})\n}\n\n// Class returns an Applyer which applies the provided classes. Subsequent\n// calls to this function will append additional classes. To toggle classes,\n// use ClassMap instead. Each class name must be passed as a separate argument.\nfunc Class(class ...string) Applyer {\n\tmustValidateClassNames(class)\n\treturn markupFunc(func(h *HTML) {\n\t\tif h.classes == nil {\n\t\t\th.classes = make(map[string]struct{})\n\t\t}\n\t\tfor _, name := range class {\n\t\t\th.classes[name] = struct{}{}\n\t\t}\n\t})\n}\n\n// mustValidateClassNames ensures no class names have spaces\n// and panics with clear instructions on how to fix this user error.\nfunc mustValidateClassNames(class []string) {\n\tfor _, name := range class {\n\t\tif containsSpace(name) {\n\t\t\tpanic(`vecty: invalid argument to vecty.Class \"` + name + `\" (string may not contain spaces)`)\n\t\t}\n\t}\n}\n\n// containsSpace reports whether s contains a space character.\nfunc containsSpace(s string) bool {\n\tfor _, c := range s {\n\t\tif c == ' ' {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ClassMap is markup that specifies classes to be applied to an element if\n// their boolean value are true.\ntype ClassMap map[string]bool\n\n// Apply implements the Applyer interface.\nfunc (m ClassMap) Apply(h *HTML) {\n\tif h.classes == nil {\n\t\th.classes = make(map[string]struct{})\n\t}\n\tfor name, active := range m {\n\t\tif !active {\n\t\t\tdelete(h.classes, name)\n\t\t\tcontinue\n\t\t}\n\t\th.classes[name] = struct{}{}\n\t}\n}\n\n// MarkupList represents a list of Applyer which is individually\n// applied to an HTML element or text node.\n//\n// It may only be created through the Markup function.\ntype MarkupList struct {\n\tlist []Applyer\n}\n\n// Apply implements the Applyer interface.\nfunc (m MarkupList) Apply(h *HTML) {\n\tfor _, a := range m.list {\n\t\tif a == nil {\n\t\t\tcontinue\n\t\t}\n\t\ta.Apply(h)\n\t}\n}\n\n// isMarkupOrChild implements MarkupOrChild\nfunc (m MarkupList) isMarkupOrChild() {}\n\n// Markup wraps a list of Applyer which is individually\n// applied to an HTML element or text node.\nfunc Markup(m ...Applyer) MarkupList {\n\t// returns public non-pointer struct value with private field so that users\n\t// must acquire a MarkupList only from this function, and so that it can\n\t// never be nil (which would make it indistinguishable from (*HTML)(nil) in\n\t// a call to e.g. Tag).\n\treturn MarkupList{list: m}\n}\n\n// If returns nil if cond is false, otherwise it returns the given children.\nfunc If(cond bool, children ...ComponentOrHTML) MarkupOrChild {\n\tif cond {\n\t\treturn List(children)\n\t}\n\treturn nil\n}\n\n// MarkupIf returns nil if cond is false, otherwise it returns the given markup.\nfunc MarkupIf(cond bool, markup ...Applyer) Applyer {\n\tif cond {\n\t\treturn Markup(markup...)\n\t}\n\treturn nil\n}\n\n// UnsafeHTML is Applyer which unsafely sets the inner HTML of an HTML element.\n//\n// It is entirely up to the caller to ensure the input HTML is properly\n// sanitized.\n//\n// It is akin to innerHTML in standard JavaScript and dangerouslySetInnerHTML\n// in React, and is said to be unsafe because Vecty makes no effort to validate\n// or ensure the HTML is safe for insertion in the DOM. If the HTML came from a\n// user, for example, it would create a cross-site-scripting (XSS) exploit in\n// the application.\n//\n// The returned Applyer can only be applied to HTML, not vecty.Text, or else a\n// panic will occur.\nfunc UnsafeHTML(html string) Applyer {\n\treturn markupFunc(func(h *HTML) {\n\t\th.innerHTML = html\n\t})\n}\n\n// Namespace is Applyer which sets the namespace URI to associate with the\n// created element. This is primarily used when working with, e.g., SVG.\n//\n// See https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS#Valid Namespace URIs\nfunc Namespace(uri string) Applyer {\n\treturn markupFunc(func(h *HTML) {\n\t\th.namespace = uri\n\t})\n}\n"
        },
        {
          "name": "markup_test.go",
          "type": "blob",
          "size": 0.24609375,
          "content": "package vecty\n\nimport \"testing\"\n\n// TODO(slimsag): tests for other Markup\n\nfunc TestNamespace(t *testing.T) {\n\twant := \"b\"\n\th := Tag(\"a\", Markup(Namespace(want)))\n\tif h.namespace != want {\n\t\tt.Fatalf(\"got namespace %q want %q\", h.namespace, want)\n\t}\n}\n"
        },
        {
          "name": "prop",
          "type": "tree",
          "content": null
        },
        {
          "name": "require_go_1_14.go",
          "type": "blob",
          "size": 0.2548828125,
          "content": "// +build !go1.14\n\npackage vecty\n\n// Typechecking will pass except one error:\n//\n// \t# github.com/hexops/vecty\n// \t../../require_go_1_14.go:7:2: undefined: VECTY_REQUIRES_GO_1_14_PLUS\n//\n\nfunc init() {\n\tVECTY_REQUIRES_GO_1_14_PLUS = \"Vecty requires Go 1.14+\"\n}\n"
        },
        {
          "name": "style",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "testsuite_js_test.go",
          "type": "blob",
          "size": 0.517578125,
          "content": "// +build js\n\npackage vecty\n\nimport \"syscall/js\"\n\n// os/exec does not work in GOOS=js GOARCH=wasm, so we implement the minor functionality that we\n// need for the test suite using the NodeJS API on our own.\n\nfunc commandOutput(command string, args ...string) (string, error) {\n\targsi := make([]interface{}, len(args))\n\tfor i, arg := range args {\n\t\targsi[i] = arg\n\t}\n\tproc := childProcess.Call(\"spawnSync\", command, argsi)\n\treturn proc.Get(\"stdout\").String(), nil\n}\n\nvar childProcess = js.Global().Call(\"require\", \"child_process\")\n"
        },
        {
          "name": "testsuite_native_test.go",
          "type": "blob",
          "size": 0.998046875,
          "content": "// +build !js\n\npackage vecty\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\t\"reflect\"\n)\n\nfunc commandOutput(command string, args ...string) (string, error) {\n\tcmd := exec.Command(command, args...)\n\tout, _ := cmd.CombinedOutput()\n\treturn string(out), nil\n}\n\nfunc init() {\n\thtmlNodeImpl = func(h *HTML) SyscallJSValue {\n\t\tif h.node == nil {\n\t\t\tpanic(\"vecty: cannot call (*HTML).Node() before DOM node creation / component mount\")\n\t\t}\n\t\treturn h.node.(wrappedObject).j\n\t}\n\tfuncOfImpl = func(fn func(this jsObject, args []jsObject) interface{}) jsFunc {\n\t\treturn &jsFuncImpl{\n\t\t\tgoFunc: fn,\n\t\t}\n\t}\n\tvalueOfImpl = func(v interface{}) jsObject {\n\t\tts := global().(*objectRecorder).ts\n\t\tname := fmt.Sprintf(\"valueOf(%v)\", v)\n\t\tr := &objectRecorder{ts: ts, name: name}\n\t\tswitch reflect.ValueOf(v).Kind() {\n\t\tcase reflect.String:\n\t\t\tts.strings.mock(name, v)\n\t\tcase reflect.Bool:\n\t\t\tts.bools.mock(name, v)\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\tts.floats.mock(name, v)\n\t\tcase reflect.Int:\n\t\t\tts.ints.mock(name, v)\n\t\tdefault:\n\t\t}\n\t\treturn r\n\t}\n}\n"
        },
        {
          "name": "testsuite_test.go",
          "type": "blob",
          "size": 8.2998046875,
          "content": "package vecty\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar _ = func() bool {\n\tisTest = true\n\treturn true\n}()\n\n// recoverStr runs f and returns the recovered panic as a string.\nfunc recoverStr(f func()) (s string) {\n\tdefer func() {\n\t\ts = fmt.Sprint(recover())\n\t}()\n\tf()\n\treturn\n}\n\ntype componentFunc struct {\n\tCore\n\tid         string\n\trender     func() ComponentOrHTML\n\tskipRender func(prev Component) bool\n}\n\nfunc (c *componentFunc) Render() ComponentOrHTML        { return c.render() }\nfunc (c *componentFunc) SkipRender(prev Component) bool { return c.skipRender(prev) }\n\nfunc TestMain(m *testing.M) {\n\t// Try to remove all testdata/*.got.txt files now.\n\tmatches, _ := filepath.Glob(\"testdata/*.got.txt\")\n\tfor _, match := range matches {\n\t\tos.Remove(match)\n\t}\n\n\tos.Exit(m.Run())\n}\n\nfunc testSuite(t *testing.T) *testSuiteT {\n\tts := &testSuiteT{\n\t\tt:           t,\n\t\tcallbacks:   make(map[string]interface{}),\n\t\tstrings:     &valueMocker{},\n\t\tbools:       &valueMocker{},\n\t\tfloats:      &valueMocker{},\n\t\tints:        &valueMocker{},\n\t\ttruthies:    &valueMocker{},\n\t\tisUndefined: &valueMocker{},\n\t}\n\tglobalValue = &objectRecorder{\n\t\tts:   ts,\n\t\tname: \"global\",\n\t}\n\treturn ts\n}\n\n// mockedValue represents a mocked value.\ntype mockedValue struct {\n\tinvocation string\n\tvalue      interface{}\n}\n\n// valueMocker keeps tracked of mocked values for method invocations on\n// jsObject's.\ntype valueMocker struct {\n\tvalues []mockedValue\n}\n\n// mock adds an entry to mock the specified invocation to return the given\n// value.\nfunc (v *valueMocker) mock(invocation string, value interface{}) {\n\tv.values = append(v.values, mockedValue{invocation, value})\n}\n\n// get gets the mocked value for the specified invocation.\nfunc (v *valueMocker) get(invocation string) interface{} {\n\tfor i, value := range v.values {\n\t\tif value.invocation == invocation {\n\t\t\t// Found the right invocation.\n\t\t\tv.values = append(v.values[:i], v.values[i+1:]...)\n\t\t\treturn value.value\n\t\t}\n\t}\n\tpanic(fmt.Sprintf(\"expected mocked value for invocation: %s\", invocation))\n}\n\ntype testSuiteT struct {\n\tt                                                   *testing.T\n\tcallbacks                                           map[string]interface{}\n\tstrings, bools, floats, ints, truthies, isUndefined *valueMocker\n\n\tgot    string\n\tisDone bool\n}\n\nfunc (ts *testSuiteT) done() {\n\tts.t.Helper()\n\tts.multiSortedDone()\n}\n\n// sortedDone is just like done(), except it sorts the specified line range first.\nfunc (ts *testSuiteT) sortedDone(sortStartLine, sortEndLine int) {\n\tts.t.Helper()\n\tts.multiSortedDone([2]int{sortStartLine, sortEndLine})\n}\n\n// multiSortedDone is just like done(), except it sorts the specified line range first.\nfunc (ts *testSuiteT) multiSortedDone(linesToSort ...[2]int) {\n\tts.t.Helper()\n\tif ts.isDone {\n\t\tpanic(\"testSuite done methods called multiple times\")\n\t}\n\tts.isDone = true\n\t// Read the want file or create it if it does not exist.\n\ttestName := strings.Replace(ts.t.Name(), \"/\", \"__\", -1)\n\twantFileName := path.Join(\"testdata\", testName+\".want.txt\")\n\twantBytes, err := ioutil.ReadFile(wantFileName)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\t// Touch the file\n\t\t\tf, err := os.Create(wantFileName)\n\t\t\tf.Close()\n\t\t\tif err != nil {\n\t\t\t\tts.t.Error(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tts.t.Error(err)\n\t\t\treturn\n\t\t}\n\t}\n\twant := strings.TrimSpace(string(wantBytes))\n\n\t// Ensure output is properly sorted.\n\tsplit := strings.Split(strings.TrimSpace(ts.got), \"\\n\")\n\tfor _, pair := range linesToSort {\n\t\tsortStartLine := pair[0] - 1 // to match editor line numbers\n\t\tif sortStartLine < 0 {\n\t\t\tsortStartLine = 0\n\t\t}\n\t\tsortEndLine := pair[1]\n\t\tif sortEndLine > len(split) {\n\t\t\tsortEndLine = len(split)\n\t\t}\n\t\tsorted := split[sortStartLine:sortEndLine]\n\t\tts.t.Logf(\"lines selected for sorting (%d-%d):\\n%s\\n\\n\", sortStartLine, sortEndLine, strings.Join(sorted, \"\\n\"))\n\t\tsort.Strings(sorted)\n\t\tfor i := sortStartLine; i < sortEndLine; i++ {\n\t\t\tsplit[i] = sorted[i-sortStartLine]\n\t\t}\n\t}\n\tgot := strings.Join(split, \"\\n\")\n\n\t// Check if we got what we wanted.\n\tif got == want {\n\t\t// Successful test.\n\n\t\t// Ensure there are no unused mocked values.\n\t\tfor _, v := range ts.strings.values {\n\t\t\tts.t.Errorf(\"unused mocked string value %q %v\", v.invocation, v.value)\n\t\t}\n\t\tfor _, v := range ts.bools.values {\n\t\t\tts.t.Errorf(\"unused mocked bool value %q %v\", v.invocation, v.value)\n\t\t}\n\t\tfor _, v := range ts.floats.values {\n\t\t\tts.t.Errorf(\"unused mocked float value %q %v\", v.invocation, v.value)\n\t\t}\n\t\tfor _, v := range ts.ints.values {\n\t\t\tts.t.Errorf(\"unused mocked int value %q %v\", v.invocation, v.value)\n\t\t}\n\t\treturn\n\t}\n\n\t// Write what we got to disk.\n\tgotFileName := path.Join(\"testdata\", testName+\".got.txt\")\n\terr = ioutil.WriteFile(gotFileName, []byte(got), 0o777)\n\tif err != nil {\n\t\tts.t.Error(err)\n\t\treturn\n\t}\n\n\t// Print a nice diff for easy comparison.\n\tout, err := commandOutput(\"git\", \"-c\", \"color.ui=always\", \"diff\", \"--no-index\", wantFileName, gotFileName)\n\tif err != nil {\n\t\tts.t.Log(\"running git diff\", err)\n\t} else {\n\t\tts.t.Log(\"\\n\" + out)\n\t}\n\n\tts.t.Errorf(\"to accept these changes:\\n\\n$ mv %s %s\", gotFileName, wantFileName)\n}\n\n// record records the invocation to the test suite and returns the string\n// unmodified.\nfunc (ts *testSuiteT) record(invocation string) string {\n\tts.got += \"\\n\" + invocation\n\treturn invocation\n}\n\n// addCallbacks adds the first function in args to ts.callbacks[invocation], if there is one.\nfunc (ts *testSuiteT) addCallbacks(invocation string, args ...interface{}) {\n\tfor _, a := range args {\n\t\tif fi, ok := a.(*jsFuncImpl); ok {\n\t\t\tts.callbacks[invocation] = fi.goFunc\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (ts *testSuiteT) invokeCallbackRequestAnimationFrame(v float64) {\n\tcb := ts.callbacks[`global.Call(\"requestAnimationFrame\", func)`].(func(this jsObject, args []jsObject) interface{})\n\tcb(undefined(), []jsObject{valueOf(v)})\n}\n\nfunc (ts *testSuiteT) invokeCallbackDOMContentLoaded() {\n\tcb := ts.callbacks[`global.Get(\"document\").Call(\"addEventListener\", \"DOMContentLoaded\", func)`].(func(this jsObject, args []jsObject) interface{})\n\tcb(undefined(), nil)\n}\n\n// objectRecorder implements the jsObject interface by recording method\n// invocations to the test suite.\ntype objectRecorder struct {\n\tts   *testSuiteT\n\tname string\n}\n\n// Set implements the jsObject interface.\nfunc (r *objectRecorder) Set(key string, value interface{}) {\n\tinvocation := r.ts.record(fmt.Sprintf(\"%s.Set(%q, %+v)\", r.name, key, stringify(value)))\n\tr.ts.addCallbacks(invocation, value)\n}\n\n// Get implements the jsObject interface.\nfunc (r *objectRecorder) Get(key string) jsObject {\n\tinvocation := r.ts.record(fmt.Sprintf(\"%s.Get(%q)\", r.name, key))\n\treturn &objectRecorder{\n\t\tts:   r.ts,\n\t\tname: invocation,\n\t}\n}\n\n// Delete implements the jsObject interface.\nfunc (r *objectRecorder) Delete(key string) {\n\tr.ts.record(fmt.Sprintf(\"%s.Delete(%q)\", r.name, key))\n}\n\n// Call implements the jsObject interface.\nfunc (r *objectRecorder) Call(name string, args ...interface{}) jsObject {\n\tinvocation := r.ts.record(fmt.Sprintf(\"%s.Call(%q, %s)\", r.name, name, stringify(args...)))\n\tr.ts.addCallbacks(invocation, args...)\n\treturn &objectRecorder{\n\t\tts:   r.ts,\n\t\tname: invocation,\n\t}\n}\n\n// String implements the jsObject interface.\nfunc (r *objectRecorder) String() string { return r.ts.strings.get(r.name).(string) }\n\n// Truthy implements the jsObject interface.\nfunc (r *objectRecorder) Truthy() bool { return r.ts.truthies.get(r.name).(bool) }\n\n// IsUndefined implements the jsObject interface.\nfunc (r *objectRecorder) IsUndefined() bool { return r.ts.isUndefined.get(r.name).(bool) }\n\n// Equal implements the jsObject interface.\nfunc (r *objectRecorder) Equal(other jsObject) bool {\n\tif (r == nil) != (other == nil) {\n\t\treturn false\n\t}\n\treturn r == other.(*objectRecorder)\n}\n\n// Bool implements the jsObject interface.\nfunc (r *objectRecorder) Bool() bool { return r.ts.bools.get(r.name).(bool) }\n\n// Int implements the jsObject interface.\nfunc (r *objectRecorder) Int() int { return r.ts.ints.get(r.name).(int) }\n\n// Float implements the jsObject interface.\nfunc (r *objectRecorder) Float() float64 { return r.ts.floats.get(r.name).(float64) }\n\nfunc stringify(args ...interface{}) string {\n\tvar s []string\n\tfor _, a := range args {\n\t\tswitch v := a.(type) {\n\t\tcase string:\n\t\t\ts = append(s, fmt.Sprintf(\"%q\", v))\n\t\tcase *objectRecorder:\n\t\t\ts = append(s, fmt.Sprintf(\"jsObject(%s)\", v.name))\n\t\tdefault:\n\t\t\ts = append(s, fmt.Sprintf(\"%v\", v))\n\t\t}\n\t}\n\treturn strings.Join(s, \", \")\n}\n"
        }
      ]
    }
  ]
}