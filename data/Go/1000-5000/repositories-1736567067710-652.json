{
  "metadata": {
    "timestamp": 1736567067710,
    "page": 652,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "shiyanhui/dht",
      "stars": 2743,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.009765625,
          "content": ".DS_Store\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Dean Karn\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.4775390625,
          "content": "![](https://raw.githubusercontent.com/shiyanhui/dht/master/doc/screen-shot.png)\n\nSee the video on the [Youtube](https://www.youtube.com/watch?v=AIpeQtw22kc).\n\n[中文版README](https://github.com/shiyanhui/dht/blob/master/README_CN.md)\n\n## Introduction\n\nDHT implements the bittorrent DHT protocol in Go. Now it includes:\n\n- [BEP-3 (part)](http://www.bittorrent.org/beps/bep_0003.html)\n- [BEP-5](http://www.bittorrent.org/beps/bep_0005.html)\n- [BEP-9](http://www.bittorrent.org/beps/bep_0009.html)\n- [BEP-10](http://www.bittorrent.org/beps/bep_0010.html)\n\nIt contains two modes, the standard mode and the crawling mode. The standard\nmode follows the BEPs, and you can use it as a standard dht server. The crawling\nmode aims to crawl as more metadata info as possiple. It doesn't follow the\nstandard BEPs protocol. With the crawling mode, you can build another [BTDigg](http://btdigg.org/).\n\n[bthub.io](http://bthub.io) is a BT search engine based on the crawling mode.\n\n## Installation\n\n    go get github.com/shiyanhui/dht\n\n## Example\n\nBelow is a simple spider. You can move [here](https://github.com/shiyanhui/dht/blob/master/sample)\nto see more samples.\n\n```go\nimport (\n    \"fmt\"\n    \"github.com/shiyanhui/dht\"\n)\n\nfunc main() {\n    downloader := dht.NewWire(65535)\n    go func() {\n        // once we got the request result\n        for resp := range downloader.Response() {\n            fmt.Println(resp.InfoHash, resp.MetadataInfo)\n        }\n    }()\n    go downloader.Run()\n\n    config := dht.NewCrawlConfig()\n    config.OnAnnouncePeer = func(infoHash, ip string, port int) {\n        // request to download the metadata info\n        downloader.Request([]byte(infoHash), ip, port)\n    }\n    d := dht.New(config)\n\n    d.Run()\n}\n```\n\n## Download\n\nYou can download the demo compiled binary file [here](https://github.com/shiyanhui/dht/files/407021/spider.zip).\n\n## Note\n\n- The default crawl mode configure costs about 300M RAM. Set **MaxNodes**\n  and **BlackListMaxSize** to fit yourself.\n- Now it cant't run in LAN because of NAT.\n\n## TODO\n\n- [ ] NAT Traversal.\n- [ ] Implements the full BEP-3.\n- [ ] Optimization.\n\n## FAQ\n\n#### Why it is slow compared to other spiders ?\n\nWell, maybe there are several reasons.\n\n- DHT aims to implements the standard BitTorrent DHT protocol, not born for crawling the DHT network.\n- NAT Traversal issue. You run the crawler in a local network.\n- It will block ip which looks like bad and a good ip may be mis-judged.\n\n## License\n\nMIT, read more [here](https://github.com/shiyanhui/dht/blob/master/LICENSE)\n"
        },
        {
          "name": "README_CN.md",
          "type": "blob",
          "size": 2.318359375,
          "content": "![](https://raw.githubusercontent.com/shiyanhui/dht/master/doc/screen-shot.png)\n\n在这个视频上你可以看到爬取效果[Youtube](https://www.youtube.com/watch?v=AIpeQtw22kc).\n\n## Introduction\n\nDHT实现了BitTorrent DHT协议，主要包括：\n\n- [BEP-3 (部分)](http://www.bittorrent.org/beps/bep_0003.html)\n- [BEP-5](http://www.bittorrent.org/beps/bep_0005.html)\n- [BEP-9](http://www.bittorrent.org/beps/bep_0009.html)\n- [BEP-10](http://www.bittorrent.org/beps/bep_0010.html)\n\n它包含两种模式，标准模式和爬虫模式。标准模式遵循DHT协议，你可以把它当做一个标准\n的DHT组件。爬虫模式是为了嗅探到更多torrent文件信息，它在某些方面不遵循DHT协议。\n基于爬虫模式，你可以打造你自己的[BTDigg](http://btdigg.org/)。\n\n[bthub.io](http://bthub.io)是一个基于这个爬虫而建的BT搜索引擎，你可以把他当做\nBTDigg的替代品。\n\n## Installation\n\n    go get github.com/shiyanhui/dht\n\n## Example\n\n下面是一个简单的爬虫例子，你可以到[这里](https://github.com/shiyanhui/dht/blob/master/sample)看完整的Demo。\n\n```go\nimport (\n    \"fmt\"\n    \"github.com/shiyanhui/dht\"\n)\n\nfunc main() {\n    downloader := dht.NewWire(65536)\n    go func() {\n        // once we got the request result\n        for resp := range downloader.Response() {\n            fmt.Println(resp.InfoHash, resp.MetadataInfo)\n        }\n    }()\n    go downloader.Run()\n\n    config := dht.NewCrawlConfig()\n    config.OnAnnouncePeer = func(infoHash, ip string, port int) {\n        // request to download the metadata info\n        downloader.Request([]byte(infoHash), ip, port)\n    }\n    d := dht.New(config)\n\n    d.Run()\n}\n```\n\n## Download\n\n这个是已经编译好的Demo二进制文件，你可以到这里[下载](https://github.com/shiyanhui/dht/files/407021/spider.zip)。\n\n## 注意\n\n- 默认的爬虫配置需要300M左右内存，你可以根据你的服务器内存大小调整MaxNodes和\n  BlackListMaxSize\n- 目前还不能穿透NAT，因此还不能在局域网运行\n\n## TODO\n\n- [ ] NAT穿透，在局域网内也能够运行\n- [ ] 完整地实现BEP-3，这样不但能够下载种子，也能够下载资源\n- [ ] 优化\n\n## Blog\n\n你可以在[这里](https://github.com/shiyanhui/dht/wiki)看到DHT Spider教程。\n\n## License\n\n[MIT](https://github.com/shiyanhui/dht/blob/master/LICENSE)\n"
        },
        {
          "name": "bencode.go",
          "type": "blob",
          "size": 5.16015625,
          "content": "package dht\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\n// find returns the index of first target in data starting from `start`.\n// It returns -1 if target not found.\nfunc find(data []byte, start int, target rune) (index int) {\n\tindex = bytes.IndexRune(data[start:], target)\n\tif index != -1 {\n\t\treturn index + start\n\t}\n\treturn index\n}\n\n// DecodeString decodes a string in the data. It returns a tuple\n// (decoded result, the end position, error).\nfunc DecodeString(data []byte, start int) (\n\tresult interface{}, index int, err error) {\n\n\tif start >= len(data) || data[start] < '0' || data[start] > '9' {\n\t\terr = errors.New(\"invalid string bencode\")\n\t\treturn\n\t}\n\n\ti := find(data, start, ':')\n\tif i == -1 {\n\t\terr = errors.New(\"':' not found when decode string\")\n\t\treturn\n\t}\n\n\tlength, err := strconv.Atoi(string(data[start:i]))\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif length < 0 {\n\t\terr = errors.New(\"invalid length of string\")\n\t\treturn\n\t}\n\n\tindex = i + 1 + length\n\n\tif index > len(data) || index < i+1 {\n\t\terr = errors.New(\"out of range\")\n\t\treturn\n\t}\n\n\tresult = string(data[i+1 : index])\n\treturn\n}\n\n// DecodeInt decodes int value in the data.\nfunc DecodeInt(data []byte, start int) (\n\tresult interface{}, index int, err error) {\n\n\tif start >= len(data) || data[start] != 'i' {\n\t\terr = errors.New(\"invalid int bencode\")\n\t\treturn\n\t}\n\n\tindex = find(data, start+1, 'e')\n\n\tif index == -1 {\n\t\terr = errors.New(\"':' not found when decode int\")\n\t\treturn\n\t}\n\n\tresult, err = strconv.Atoi(string(data[start+1 : index]))\n\tif err != nil {\n\t\treturn\n\t}\n\tindex++\n\n\treturn\n}\n\n// decodeItem decodes an item of dict or list.\nfunc decodeItem(data []byte, i int) (\n\tresult interface{}, index int, err error) {\n\n\tvar decodeFunc = []func([]byte, int) (interface{}, int, error){\n\t\tDecodeString, DecodeInt, DecodeList, DecodeDict,\n\t}\n\n\tfor _, f := range decodeFunc {\n\t\tresult, index, err = f(data, i)\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\terr = errors.New(\"invalid bencode when decode item\")\n\treturn\n}\n\n// DecodeList decodes a list value.\nfunc DecodeList(data []byte, start int) (\n\tresult interface{}, index int, err error) {\n\n\tif start >= len(data) || data[start] != 'l' {\n\t\terr = errors.New(\"invalid list bencode\")\n\t\treturn\n\t}\n\n\tvar item interface{}\n\tr := make([]interface{}, 0, 8)\n\n\tindex = start + 1\n\tfor index < len(data) {\n\t\tchar, _ := utf8.DecodeRune(data[index:])\n\t\tif char == 'e' {\n\t\t\tbreak\n\t\t}\n\n\t\titem, index, err = decodeItem(data, index)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tr = append(r, item)\n\t}\n\n\tif index == len(data) {\n\t\terr = errors.New(\"'e' not found when decode list\")\n\t\treturn\n\t}\n\tindex++\n\n\tresult = r\n\treturn\n}\n\n// DecodeDict decodes a map value.\nfunc DecodeDict(data []byte, start int) (\n\tresult interface{}, index int, err error) {\n\n\tif start >= len(data) || data[start] != 'd' {\n\t\terr = errors.New(\"invalid dict bencode\")\n\t\treturn\n\t}\n\n\tvar item, key interface{}\n\tr := make(map[string]interface{})\n\n\tindex = start + 1\n\tfor index < len(data) {\n\t\tchar, _ := utf8.DecodeRune(data[index:])\n\t\tif char == 'e' {\n\t\t\tbreak\n\t\t}\n\n\t\tif !unicode.IsDigit(char) {\n\t\t\terr = errors.New(\"invalid dict bencode\")\n\t\t\treturn\n\t\t}\n\n\t\tkey, index, err = DecodeString(data, index)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif index >= len(data) {\n\t\t\terr = errors.New(\"out of range\")\n\t\t\treturn\n\t\t}\n\n\t\titem, index, err = decodeItem(data, index)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tr[key.(string)] = item\n\t}\n\n\tif index == len(data) {\n\t\terr = errors.New(\"'e' not found when decode dict\")\n\t\treturn\n\t}\n\tindex++\n\n\tresult = r\n\treturn\n}\n\n// Decode decodes a bencoded string to string, int, list or map.\nfunc Decode(data []byte) (result interface{}, err error) {\n\tresult, _, err = decodeItem(data, 0)\n\treturn\n}\n\n// EncodeString encodes a string value.\nfunc EncodeString(data string) string {\n\treturn strings.Join([]string{strconv.Itoa(len(data)), data}, \":\")\n}\n\n// EncodeInt encodes a int value.\nfunc EncodeInt(data int) string {\n\treturn strings.Join([]string{\"i\", strconv.Itoa(data), \"e\"}, \"\")\n}\n\n// EncodeItem encodes an item of dict or list.\nfunc encodeItem(data interface{}) (item string) {\n\tswitch v := data.(type) {\n\tcase string:\n\t\titem = EncodeString(v)\n\tcase int:\n\t\titem = EncodeInt(v)\n\tcase []interface{}:\n\t\titem = EncodeList(v)\n\tcase map[string]interface{}:\n\t\titem = EncodeDict(v)\n\tdefault:\n\t\tpanic(\"invalid type when encode item\")\n\t}\n\treturn\n}\n\n// EncodeList encodes a list value.\nfunc EncodeList(data []interface{}) string {\n\tresult := make([]string, len(data))\n\n\tfor i, item := range data {\n\t\tresult[i] = encodeItem(item)\n\t}\n\n\treturn strings.Join([]string{\"l\", strings.Join(result, \"\"), \"e\"}, \"\")\n}\n\n// EncodeDict encodes a dict value.\nfunc EncodeDict(data map[string]interface{}) string {\n\tresult, i := make([]string, len(data)), 0\n\n\tfor key, val := range data {\n\t\tresult[i] = strings.Join(\n\t\t\t[]string{EncodeString(key), encodeItem(val)},\n\t\t\t\"\")\n\t\ti++\n\t}\n\n\treturn strings.Join([]string{\"d\", strings.Join(result, \"\"), \"e\"}, \"\")\n}\n\n// Encode encodes a string, int, dict or list value to a bencoded string.\nfunc Encode(data interface{}) string {\n\tswitch v := data.(type) {\n\tcase string:\n\t\treturn EncodeString(v)\n\tcase int:\n\t\treturn EncodeInt(v)\n\tcase []interface{}:\n\t\treturn EncodeList(v)\n\tcase map[string]interface{}:\n\t\treturn EncodeDict(v)\n\tdefault:\n\t\tpanic(\"invalid type when encode\")\n\t}\n}\n"
        },
        {
          "name": "bencode_test.go",
          "type": "blob",
          "size": 2.6396484375,
          "content": "package dht\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDecodeString(t *testing.T) {\n\tcases := []struct {\n\t\tin  string\n\t\tout string\n\t}{\n\t\t{\"0:\", \"\"},\n\t\t{\"1:a\", \"a\"},\n\t\t{\"5:hello\", \"hello\"},\n\t}\n\n\tfor _, c := range cases {\n\t\tif out, err := Decode([]byte(c.in)); err != nil || out != c.out {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestDecodeInt(t *testing.T) {\n\tcases := []struct {\n\t\tin  string\n\t\tout int\n\t}{\n\t\t{\"i123e:\", 123},\n\t\t{\"i0e\", 0},\n\t\t{\"i-1e\", -1},\n\t}\n\n\tfor _, c := range cases {\n\t\tif out, err := Decode([]byte(c.in)); err != nil || out != c.out {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestDecodeList(t *testing.T) {\n\tcases := []struct {\n\t\tin  string\n\t\tout []interface{}\n\t}{\n\t\t{\"li123ei-1ee\", []interface{}{123, -1}},\n\t\t{\"l5:helloe\", []interface{}{\"hello\"}},\n\t\t{\"ld5:hello5:worldee\", []interface{}{map[string]interface{}{\"hello\": \"world\"}}},\n\t\t{\"lli1ei2eee\", []interface{}{[]interface{}{1, 2}}},\n\t}\n\n\tfor i, c := range cases {\n\t\tv, err := Decode([]byte(c.in))\n\t\tif err != nil {\n\t\t\tt.Fail()\n\t\t}\n\n\t\tout := v.([]interface{})\n\n\t\tswitch i {\n\t\tcase 0, 1:\n\t\t\tfor j, item := range out {\n\t\t\t\tif item != c.out[j] {\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}\n\t\tcase 2:\n\t\t\tif len(out) != 1 {\n\t\t\t\tt.Fail()\n\t\t\t}\n\n\t\t\to := out[0].(map[string]interface{})\n\t\t\tcout := c.out[0].(map[string]interface{})\n\n\t\t\tfor k, v := range o {\n\t\t\t\tif cv, ok := cout[k]; !ok || v != cv {\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}\n\t\tcase 3:\n\t\t\tif len(out) != 1 {\n\t\t\t\tt.Fail()\n\t\t\t}\n\n\t\t\to := out[0].([]interface{})\n\t\t\tcout := c.out[0].([]interface{})\n\n\t\t\tfor j, item := range o {\n\t\t\t\tif item != cout[j] {\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDecodeDict(t *testing.T) {\n\tcases := []struct {\n\t\tin  string\n\t\tout map[string]interface{}\n\t}{\n\t\t{\"d5:helloi100ee\", map[string]interface{}{\"hello\": 100}},\n\t\t{\"d3:foo3:bare\", map[string]interface{}{\"foo\": \"bar\"}},\n\t\t{\"d1:ad3:foo3:baree\", map[string]interface{}{\"a\": map[string]interface{}{\"foo\": \"bar\"}}},\n\t\t{\"d4:listli1eee\", map[string]interface{}{\"list\": []interface{}{1}}},\n\t}\n\n\tfor i, c := range cases {\n\t\tv, err := Decode([]byte(c.in))\n\t\tif err != nil {\n\t\t\tt.Fail()\n\t\t}\n\n\t\tout := v.(map[string]interface{})\n\n\t\tswitch i {\n\t\tcase 0, 1:\n\t\t\tfor k, v := range out {\n\t\t\t\tif cv, ok := c.out[k]; !ok || v != cv {\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}\n\t\tcase 2:\n\t\t\tif len(out) != 1 {\n\t\t\t\tt.Fail()\n\t\t\t}\n\n\t\t\tv, ok := out[\"a\"]\n\t\t\tif !ok {\n\t\t\t\tt.Fail()\n\t\t\t}\n\n\t\t\tcout := c.out[\"a\"].(map[string]interface{})\n\n\t\t\tfor k, v := range v.(map[string]interface{}) {\n\t\t\t\tif cv, ok := cout[k]; !ok || v != cv {\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}\n\t\tcase 3:\n\t\t\tif len(out) != 1 {\n\t\t\t\tt.Fail()\n\t\t\t}\n\n\t\t\tv, ok := out[\"list\"]\n\t\t\tif !ok {\n\t\t\t\tt.Fail()\n\t\t\t}\n\n\t\t\tcout := c.out[\"list\"].([]interface{})\n\n\t\t\tfor j, v := range v.([]interface{}) {\n\t\t\t\tif v != cout[j] {\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "bitmap.go",
          "type": "blob",
          "size": 3.2705078125,
          "content": "package dht\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// bitmap represents a bit array.\ntype bitmap struct {\n\tSize int\n\tdata []byte\n}\n\n// newBitmap returns a size-length bitmap pointer.\nfunc newBitmap(size int) *bitmap {\n\tdiv, mod := size>>3, size&0x07\n\tif mod > 0 {\n\t\tdiv++\n\t}\n\treturn &bitmap{size, make([]byte, div)}\n}\n\n// newBitmapFrom returns a new copyed bitmap pointer which\n// newBitmap.data = other.data[:size].\nfunc newBitmapFrom(other *bitmap, size int) *bitmap {\n\tbitmap := newBitmap(size)\n\n\tif size > other.Size {\n\t\tsize = other.Size\n\t}\n\n\tdiv := size >> 3\n\n\tfor i := 0; i < div; i++ {\n\t\tbitmap.data[i] = other.data[i]\n\t}\n\n\tfor i := div << 3; i < size; i++ {\n\t\tif other.Bit(i) == 1 {\n\t\t\tbitmap.Set(i)\n\t\t}\n\t}\n\n\treturn bitmap\n}\n\n// newBitmapFromBytes returns a bitmap pointer created from a byte array.\nfunc newBitmapFromBytes(data []byte) *bitmap {\n\tbitmap := newBitmap(len(data) << 3)\n\tcopy(bitmap.data, data)\n\treturn bitmap\n}\n\n// newBitmapFromString returns a bitmap pointer created from a string.\nfunc newBitmapFromString(data string) *bitmap {\n\treturn newBitmapFromBytes([]byte(data))\n}\n\n// Bit returns the bit at index.\nfunc (bitmap *bitmap) Bit(index int) int {\n\tif index >= bitmap.Size {\n\t\tpanic(\"index out of range\")\n\t}\n\n\tdiv, mod := index>>3, index&0x07\n\treturn int((uint(bitmap.data[div]) & (1 << uint(7-mod))) >> uint(7-mod))\n}\n\n// set sets the bit at index `index`. If bit is true, set 1, otherwise set 0.\nfunc (bitmap *bitmap) set(index int, bit int) {\n\tif index >= bitmap.Size {\n\t\tpanic(\"index out of range\")\n\t}\n\n\tdiv, mod := index>>3, index&0x07\n\tshift := byte(1 << uint(7-mod))\n\n\tbitmap.data[div] &= ^shift\n\tif bit > 0 {\n\t\tbitmap.data[div] |= shift\n\t}\n}\n\n// Set sets the bit at idnex to 1.\nfunc (bitmap *bitmap) Set(index int) {\n\tbitmap.set(index, 1)\n}\n\n// Unset sets the bit at idnex to 0.\nfunc (bitmap *bitmap) Unset(index int) {\n\tbitmap.set(index, 0)\n}\n\n// Compare compares the prefixLen-prefix of two bitmap.\n//   - If bitmap.data[:prefixLen] < other.data[:prefixLen], return -1.\n//   - If bitmap.data[:prefixLen] > other.data[:prefixLen], return 1.\n//   - Otherwise return 0.\nfunc (bitmap *bitmap) Compare(other *bitmap, prefixLen int) int {\n\tif prefixLen > bitmap.Size || prefixLen > other.Size {\n\t\tpanic(\"index out of range\")\n\t}\n\n\tdiv, mod := prefixLen>>3, prefixLen&0x07\n\tres := bytes.Compare(bitmap.data[:div], other.data[:div])\n\tif res != 0 {\n\t\treturn res\n\t}\n\n\tfor i := div << 3; i < (div<<3)+mod; i++ {\n\t\tbit1, bit2 := bitmap.Bit(i), other.Bit(i)\n\t\tif bit1 > bit2 {\n\t\t\treturn 1\n\t\t} else if bit1 < bit2 {\n\t\t\treturn -1\n\t\t}\n\t}\n\n\treturn 0\n}\n\n// Xor returns the xor value of two bitmap.\nfunc (bitmap *bitmap) Xor(other *bitmap) *bitmap {\n\tif bitmap.Size != other.Size {\n\t\tpanic(\"size not the same\")\n\t}\n\n\tdistance := newBitmap(bitmap.Size)\n\txor(distance.data, bitmap.data, other.data)\n\n\treturn distance\n}\n\n// String returns the bit sequence string of the bitmap.\nfunc (bitmap *bitmap) String() string {\n\tdiv, mod := bitmap.Size>>3, bitmap.Size&0x07\n\tbuff := make([]string, div+mod)\n\n\tfor i := 0; i < div; i++ {\n\t\tbuff[i] = fmt.Sprintf(\"%08b\", bitmap.data[i])\n\t}\n\n\tfor i := div; i < div+mod; i++ {\n\t\tbuff[i] = fmt.Sprintf(\"%1b\", bitmap.Bit(div*8+(i-div)))\n\t}\n\n\treturn strings.Join(buff, \"\")\n}\n\n// RawString returns the string value of bitmap.data.\nfunc (bitmap *bitmap) RawString() string {\n\treturn string(bitmap.data)\n}\n"
        },
        {
          "name": "bitmap_test.go",
          "type": "blob",
          "size": 0.91015625,
          "content": "package dht\n\nimport (\n\t\"testing\"\n)\n\nfunc TestBitmap(t *testing.T) {\n\ta := newBitmap(10)\n\tb := newBitmapFrom(a, 10)\n\tc := newBitmapFromBytes([]byte{48, 49, 50, 51, 52, 53, 54, 55, 56, 57})\n\td := newBitmapFromString(\"0123456789\")\n\te := newBitmap(10)\n\n\t// Bit\n\tfor i := 0; i < a.Size; i++ {\n\t\tif a.Bit(i) != 0 {\n\t\t\tt.Fail()\n\t\t}\n\t}\n\n\t// Compare\n\tif c.Compare(d, d.Size) != 0 {\n\t\tt.Fail()\n\t}\n\n\t// RawString\n\tif c.RawString() != d.RawString() || c.RawString() != \"0123456789\" {\n\t\tt.Fail()\n\t}\n\n\t// Set\n\tb.Set(5)\n\tif b.Bit(5) != 1 {\n\t\tt.Fail()\n\t}\n\n\t// Unset\n\tb.Unset(5)\n\tif b.Bit(5) == 1 {\n\t\tt.Fail()\n\t}\n\n\t// String\n\tif e.String() != \"0000000000\" {\n\t\tt.Fail()\n\t}\n\te.Set(9)\n\tif e.String() != \"0000000001\" {\n\t\tt.Fail()\n\t}\n\te.Set(2)\n\tif e.String() != \"0010000001\" {\n\t\tt.Fail()\n\t}\n\n\ta.Set(0)\n\ta.Set(5)\n\ta.Set(8)\n\tif a.String() != \"1000010010\" {\n\t\tt.Fail()\n\t}\n\n\t// Xor\n\tb.Set(5)\n\tb.Set(9)\n\tif a.Xor(b).String() != \"1000000011\" {\n\t\tt.Fail()\n\t}\n}\n"
        },
        {
          "name": "bitmap_xor.go",
          "type": "blob",
          "size": 0.12890625,
          "content": "// +build !amd64,!386\n\npackage dht\n\nfunc xor(dst, a, b []byte) {\n\tn := len(a)\n\tfor i := 0; i < n; i++ {\n\t\tdst[i] = a[i] ^ b[i]\n\t}\n}\n"
        },
        {
          "name": "bitmap_xorfast.go",
          "type": "blob",
          "size": 0.4189453125,
          "content": "// +build amd64 386\n\npackage dht\n\nimport \"unsafe\"\n\nconst wordSize = int(unsafe.Sizeof(uintptr(0)))\n\nfunc xor(dst, a, b []byte) {\n\tn := len(a)\n\n\tw := n / wordSize\n\tif w > 0 {\n\t\tdw := *(*[]uintptr)(unsafe.Pointer(&dst))\n\t\taw := *(*[]uintptr)(unsafe.Pointer(&a))\n\t\tbw := *(*[]uintptr)(unsafe.Pointer(&b))\n\t\tfor i := 0; i < w; i++ {\n\t\t\tdw[i] = aw[i] ^ bw[i]\n\t\t}\n\t}\n\n\tfor i := n - n%wordSize; i < n; i++ {\n\t\tdst[i] = a[i] ^ b[i]\n\t}\n}\n"
        },
        {
          "name": "blacklist.go",
          "type": "blob",
          "size": 1.8916015625,
          "content": "package dht\n\nimport (\n\t\"time\"\n)\n\n// blockedItem represents a blocked node.\ntype blockedItem struct {\n\tip         string\n\tport       int\n\tcreateTime time.Time\n}\n\n// blackList manages the blocked nodes including which sends bad information\n// and can't ping out.\ntype blackList struct {\n\tlist         *syncedMap\n\tmaxSize      int\n\texpiredAfter time.Duration\n}\n\n// newBlackList returns a blackList pointer.\nfunc newBlackList(size int) *blackList {\n\treturn &blackList{\n\t\tlist:         newSyncedMap(),\n\t\tmaxSize:      size,\n\t\texpiredAfter: time.Hour * 1,\n\t}\n}\n\n// genKey returns a key. If port is less than 0, the key wil be ip. Ohterwise\n// it will be `ip:port` format.\nfunc (bl *blackList) genKey(ip string, port int) string {\n\tkey := ip\n\tif port >= 0 {\n\t\tkey = genAddress(ip, port)\n\t}\n\treturn key\n}\n\n// insert adds a blocked item to the blacklist.\nfunc (bl *blackList) insert(ip string, port int) {\n\tif bl.list.Len() >= bl.maxSize {\n\t\treturn\n\t}\n\n\tbl.list.Set(bl.genKey(ip, port), &blockedItem{\n\t\tip:         ip,\n\t\tport:       port,\n\t\tcreateTime: time.Now(),\n\t})\n}\n\n// delete removes blocked item form the blackList.\nfunc (bl *blackList) delete(ip string, port int) {\n\tbl.list.Delete(bl.genKey(ip, port))\n}\n\n// validate checks whether ip-port pair is in the block nodes list.\nfunc (bl *blackList) in(ip string, port int) bool {\n\tif _, ok := bl.list.Get(ip); ok {\n\t\treturn true\n\t}\n\n\tkey := bl.genKey(ip, port)\n\n\tv, ok := bl.list.Get(key)\n\tif ok {\n\t\tif time.Now().Sub(v.(*blockedItem).createTime) < bl.expiredAfter {\n\t\t\treturn true\n\t\t}\n\t\tbl.list.Delete(key)\n\t}\n\treturn false\n}\n\n// clear cleans the expired items every 10 minutes.\nfunc (bl *blackList) clear() {\n\tfor _ = range time.Tick(time.Minute * 10) {\n\t\tkeys := make([]interface{}, 0, 100)\n\n\t\tfor item := range bl.list.Iter() {\n\t\t\tif time.Now().Sub(\n\t\t\t\titem.val.(*blockedItem).createTime) > bl.expiredAfter {\n\n\t\t\t\tkeys = append(keys, item.key)\n\t\t\t}\n\t\t}\n\n\t\tbl.list.DeleteMulti(keys)\n\t}\n}\n"
        },
        {
          "name": "blacklist_test.go",
          "type": "blob",
          "size": 0.8330078125,
          "content": "package dht\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nvar blacklist = newBlackList(256)\n\nfunc TestGenKey(t *testing.T) {\n\tcases := []struct {\n\t\tin struct {\n\t\t\tip   string\n\t\t\tport int\n\t\t}\n\t\tout string\n\t}{\n\t\t{struct {\n\t\t\tip   string\n\t\t\tport int\n\t\t}{\"0.0.0.0\", -1}, \"0.0.0.0\"},\n\t\t{struct {\n\t\t\tip   string\n\t\t\tport int\n\t\t}{\"1.1.1.1\", 8080}, \"1.1.1.1:8080\"},\n\t}\n\n\tfor _, c := range cases {\n\t\tif blacklist.genKey(c.in.ip, c.in.port) != c.out {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n\nfunc TestBlackList(t *testing.T) {\n\taddress := []struct {\n\t\tip   string\n\t\tport int\n\t}{\n\t\t{\"0.0.0.0\", -1},\n\t\t{\"1.1.1.1\", 8080},\n\t\t{\"2.2.2.2\", 8081},\n\t}\n\n\tfor _, addr := range address {\n\t\tblacklist.insert(addr.ip, addr.port)\n\t\tif !blacklist.in(addr.ip, addr.port) {\n\t\t\tt.Fail()\n\t\t}\n\n\t\tblacklist.delete(addr.ip, addr.port)\n\t\tif blacklist.in(addr.ip, addr.port) {\n\t\t\tfmt.Println(addr.ip)\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "container.go",
          "type": "blob",
          "size": 5.67578125,
          "content": "package dht\n\nimport (\n\t\"container/list\"\n\t\"sync\"\n)\n\ntype mapItem struct {\n\tkey interface{}\n\tval interface{}\n}\n\n// syncedMap represents a goroutine-safe map.\ntype syncedMap struct {\n\t*sync.RWMutex\n\tdata map[interface{}]interface{}\n}\n\n// newSyncedMap returns a syncedMap pointer.\nfunc newSyncedMap() *syncedMap {\n\treturn &syncedMap{\n\t\tRWMutex: &sync.RWMutex{},\n\t\tdata:    make(map[interface{}]interface{}),\n\t}\n}\n\n// Get returns the value mapped to key.\nfunc (smap *syncedMap) Get(key interface{}) (val interface{}, ok bool) {\n\tsmap.RLock()\n\tdefer smap.RUnlock()\n\n\tval, ok = smap.data[key]\n\treturn\n}\n\n// Has returns whether the syncedMap contains the key.\nfunc (smap *syncedMap) Has(key interface{}) bool {\n\t_, ok := smap.Get(key)\n\treturn ok\n}\n\n// Set sets pair {key: val}.\nfunc (smap *syncedMap) Set(key interface{}, val interface{}) {\n\tsmap.Lock()\n\tdefer smap.Unlock()\n\n\tsmap.data[key] = val\n}\n\n// Delete deletes the key in the map.\nfunc (smap *syncedMap) Delete(key interface{}) {\n\tsmap.Lock()\n\tdefer smap.Unlock()\n\n\tdelete(smap.data, key)\n}\n\n// DeleteMulti deletes keys in batch.\nfunc (smap *syncedMap) DeleteMulti(keys []interface{}) {\n\tsmap.Lock()\n\tdefer smap.Unlock()\n\n\tfor _, key := range keys {\n\t\tdelete(smap.data, key)\n\t}\n}\n\n// Clear resets the data.\nfunc (smap *syncedMap) Clear() {\n\tsmap.Lock()\n\tdefer smap.Unlock()\n\n\tsmap.data = make(map[interface{}]interface{})\n}\n\n// Iter returns a chan which output all items.\nfunc (smap *syncedMap) Iter() <-chan mapItem {\n\tch := make(chan mapItem)\n\tgo func() {\n\t\tsmap.RLock()\n\t\tfor key, val := range smap.data {\n\t\t\tch <- mapItem{\n\t\t\t\tkey: key,\n\t\t\t\tval: val,\n\t\t\t}\n\t\t}\n\t\tsmap.RUnlock()\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\n\n// Len returns the length of syncedMap.\nfunc (smap *syncedMap) Len() int {\n\tsmap.RLock()\n\tdefer smap.RUnlock()\n\n\treturn len(smap.data)\n}\n\n// syncedList represents a goroutine-safe list.\ntype syncedList struct {\n\t*sync.RWMutex\n\tqueue *list.List\n}\n\n// newSyncedList returns a syncedList pointer.\nfunc newSyncedList() *syncedList {\n\treturn &syncedList{\n\t\tRWMutex: &sync.RWMutex{},\n\t\tqueue:   list.New(),\n\t}\n}\n\n// Front returns the first element of slist.\nfunc (slist *syncedList) Front() *list.Element {\n\tslist.RLock()\n\tdefer slist.RUnlock()\n\n\treturn slist.queue.Front()\n}\n\n// Back returns the last element of slist.\nfunc (slist *syncedList) Back() *list.Element {\n\tslist.RLock()\n\tdefer slist.RUnlock()\n\n\treturn slist.queue.Back()\n}\n\n// PushFront pushs an element to the head of slist.\nfunc (slist *syncedList) PushFront(v interface{}) *list.Element {\n\tslist.Lock()\n\tdefer slist.Unlock()\n\n\treturn slist.queue.PushFront(v)\n}\n\n// PushBack pushs an element to the tail of slist.\nfunc (slist *syncedList) PushBack(v interface{}) *list.Element {\n\tslist.Lock()\n\tdefer slist.Unlock()\n\n\treturn slist.queue.PushBack(v)\n}\n\n// InsertBefore inserts v before mark.\nfunc (slist *syncedList) InsertBefore(\n\tv interface{}, mark *list.Element) *list.Element {\n\n\tslist.Lock()\n\tdefer slist.Unlock()\n\n\treturn slist.queue.InsertBefore(v, mark)\n}\n\n// InsertAfter inserts v after mark.\nfunc (slist *syncedList) InsertAfter(\n\tv interface{}, mark *list.Element) *list.Element {\n\n\tslist.Lock()\n\tdefer slist.Unlock()\n\n\treturn slist.queue.InsertAfter(v, mark)\n}\n\n// Remove removes e from the slist.\nfunc (slist *syncedList) Remove(e *list.Element) interface{} {\n\tslist.Lock()\n\tdefer slist.Unlock()\n\n\treturn slist.queue.Remove(e)\n}\n\n// Clear resets the list queue.\nfunc (slist *syncedList) Clear() {\n\tslist.Lock()\n\tdefer slist.Unlock()\n\n\tslist.queue.Init()\n}\n\n// Len returns length of the slist.\nfunc (slist *syncedList) Len() int {\n\tslist.RLock()\n\tdefer slist.RUnlock()\n\n\treturn slist.queue.Len()\n}\n\n// Iter returns a chan which output all elements.\nfunc (slist *syncedList) Iter() <-chan *list.Element {\n\tch := make(chan *list.Element)\n\tgo func() {\n\t\tslist.RLock()\n\t\tfor e := slist.queue.Front(); e != nil; e = e.Next() {\n\t\t\tch <- e\n\t\t}\n\t\tslist.RUnlock()\n\t\tclose(ch)\n\t}()\n\treturn ch\n}\n\n// KeyedDeque represents a keyed deque.\ntype keyedDeque struct {\n\t*sync.RWMutex\n\t*syncedList\n\tindex         map[interface{}]*list.Element\n\tinvertedIndex map[*list.Element]interface{}\n}\n\n// newKeyedDeque returns a newKeyedDeque pointer.\nfunc newKeyedDeque() *keyedDeque {\n\treturn &keyedDeque{\n\t\tRWMutex:       &sync.RWMutex{},\n\t\tsyncedList:    newSyncedList(),\n\t\tindex:         make(map[interface{}]*list.Element),\n\t\tinvertedIndex: make(map[*list.Element]interface{}),\n\t}\n}\n\n// Push pushs a keyed-value to the end of deque.\nfunc (deque *keyedDeque) Push(key interface{}, val interface{}) {\n\tdeque.Lock()\n\tdefer deque.Unlock()\n\n\tif e, ok := deque.index[key]; ok {\n\t\tdeque.syncedList.Remove(e)\n\t}\n\tdeque.index[key] = deque.syncedList.PushBack(val)\n\tdeque.invertedIndex[deque.index[key]] = key\n}\n\n// Get returns the keyed value.\nfunc (deque *keyedDeque) Get(key interface{}) (*list.Element, bool) {\n\tdeque.RLock()\n\tdefer deque.RUnlock()\n\n\tv, ok := deque.index[key]\n\treturn v, ok\n}\n\n// Has returns whether key already exists.\nfunc (deque *keyedDeque) HasKey(key interface{}) bool {\n\t_, ok := deque.Get(key)\n\treturn ok\n}\n\n// Delete deletes a value named key.\nfunc (deque *keyedDeque) Delete(key interface{}) (v interface{}) {\n\tdeque.RLock()\n\te, ok := deque.index[key]\n\tdeque.RUnlock()\n\n\tdeque.Lock()\n\tdefer deque.Unlock()\n\n\tif ok {\n\t\tv = deque.syncedList.Remove(e)\n\t\tdelete(deque.index, key)\n\t\tdelete(deque.invertedIndex, e)\n\t}\n\n\treturn\n}\n\n// Removes overwrites list.List.Remove.\nfunc (deque *keyedDeque) Remove(e *list.Element) (v interface{}) {\n\tdeque.RLock()\n\tkey, ok := deque.invertedIndex[e]\n\tdeque.RUnlock()\n\n\tif ok {\n\t\tv = deque.Delete(key)\n\t}\n\n\treturn\n}\n\n// Clear resets the deque.\nfunc (deque *keyedDeque) Clear() {\n\tdeque.Lock()\n\tdefer deque.Unlock()\n\n\tdeque.syncedList.Clear()\n\tdeque.index = make(map[interface{}]*list.Element)\n\tdeque.invertedIndex = make(map[*list.Element]interface{})\n}\n"
        },
        {
          "name": "container_test.go",
          "type": "blob",
          "size": 2.3642578125,
          "content": "package dht\n\nimport (\n\t\"sync\"\n\t\"testing\"\n)\n\nfunc TestSyncedMap(t *testing.T) {\n\tcases := []mapItem{\n\t\t{\"a\", 0},\n\t\t{\"b\", 1},\n\t\t{\"c\", 2},\n\t}\n\n\tsm := newSyncedMap()\n\n\tset := func() {\n\t\tgroup := sync.WaitGroup{}\n\t\tfor _, item := range cases {\n\t\t\tgroup.Add(1)\n\t\t\tgo func(item mapItem) {\n\t\t\t\tsm.Set(item.key, item.val)\n\t\t\t\tgroup.Done()\n\t\t\t}(item)\n\t\t}\n\t\tgroup.Wait()\n\t}\n\n\tisEmpty := func() {\n\t\tif sm.Len() != 0 {\n\t\t\tt.Fail()\n\t\t}\n\t}\n\n\t// Set\n\tset()\n\tif sm.Len() != len(cases) {\n\t\tt.Fail()\n\t}\n\nLoop:\n\t// Iter\n\tfor item := range sm.Iter() {\n\t\tfor _, c := range cases {\n\t\t\tif item.key == c.key && item.val == c.val {\n\t\t\t\tcontinue Loop\n\t\t\t}\n\t\t}\n\t\tt.Fail()\n\t}\n\n\t// Get, Delete, Has\n\tfor _, item := range cases {\n\t\tval, ok := sm.Get(item.key)\n\t\tif !ok || val != item.val {\n\t\t\tt.Fail()\n\t\t}\n\n\t\tsm.Delete(item.key)\n\t\tif sm.Has(item.key) {\n\t\t\tt.Fail()\n\t\t}\n\t}\n\tisEmpty()\n\n\t// DeleteMulti\n\tset()\n\tsm.DeleteMulti([]interface{}{\"a\", \"b\", \"c\"})\n\tisEmpty()\n\n\t// Clear\n\tset()\n\tsm.Clear()\n\tisEmpty()\n}\n\nfunc TestSyncedList(t *testing.T) {\n\tsl := newSyncedList()\n\n\tinsert := func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tsl.PushBack(i)\n\t\t}\n\t}\n\n\tisEmpty := func() {\n\t\tif sl.Len() != 0 {\n\t\t\tt.Fail()\n\t\t}\n\t}\n\n\t// PushBack\n\tinsert()\n\n\t// Len\n\tif sl.Len() != 10 {\n\t\tt.Fail()\n\t}\n\n\t// Iter\n\ti := 0\n\tfor item := range sl.Iter() {\n\t\tif item.Value.(int) != i {\n\t\t\tt.Fail()\n\t\t}\n\t\ti++\n\t}\n\n\t// Front\n\tif sl.Front().Value.(int) != 0 {\n\t\tt.Fail()\n\t}\n\n\t// Back\n\tif sl.Back().Value.(int) != 9 {\n\t\tt.Fail()\n\t}\n\n\t// Remove\n\tfor i := 0; i < 10; i++ {\n\t\tif sl.Remove(sl.Front()).(int) != i {\n\t\t\tt.Fail()\n\t\t}\n\t}\n\tisEmpty()\n\n\t// Clear\n\tinsert()\n\tsl.Clear()\n\tisEmpty()\n}\n\nfunc TestKeyedDeque(t *testing.T) {\n\tcases := []mapItem{\n\t\t{\"a\", 0},\n\t\t{\"b\", 1},\n\t\t{\"c\", 2},\n\t}\n\n\tdeque := newKeyedDeque()\n\n\tinsert := func() {\n\t\tfor _, item := range cases {\n\t\t\tdeque.Push(item.key, item.val)\n\t\t}\n\t}\n\n\tisEmpty := func() {\n\t\tif deque.Len() != 0 {\n\t\t\tt.Fail()\n\t\t}\n\t}\n\n\t// Push\n\tinsert()\n\n\t// Len\n\tif deque.Len() != 3 {\n\t\tt.Fail()\n\t}\n\n\t// Iter\n\ti := 0\n\tfor e := range deque.Iter() {\n\t\tif e.Value.(int) != i {\n\t\t\tt.Fail()\n\t\t}\n\t\ti++\n\t}\n\n\t// HasKey, Get, Delete\n\tfor _, item := range cases {\n\t\tif !deque.HasKey(item.key) {\n\t\t\tt.Fail()\n\t\t}\n\n\t\te, ok := deque.Get(item.key)\n\t\tif !ok || e.Value.(int) != item.val {\n\t\t\tt.Fail()\n\t\t}\n\n\t\tif deque.Delete(item.key) != item.val {\n\t\t\tt.Fail()\n\t\t}\n\n\t\tif deque.HasKey(item.key) {\n\t\t\tt.Fail()\n\t\t}\n\t}\n\tisEmpty()\n\n\t// Clear\n\tinsert()\n\tdeque.Clear()\n\tisEmpty()\n}\n"
        },
        {
          "name": "dht.go",
          "type": "blob",
          "size": 6.8193359375,
          "content": "// Package dht implements the bittorrent dht protocol. For more information\n// see http://www.bittorrent.org/beps/bep_0005.html.\npackage dht\n\nimport (\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"math\"\n\t\"net\"\n\t\"time\"\n)\n\nconst (\n\t// StandardMode follows the standard protocol\n\tStandardMode = iota\n\t// CrawlMode for crawling the dht network.\n\tCrawlMode\n)\n\nvar (\n\t// ErrNotReady is the error when DHT is not initialized.\n\tErrNotReady = errors.New(\"dht is not ready\")\n\t// ErrOnGetPeersResponseNotSet is the error that config\n\t// OnGetPeersResponseNotSet is not set when call dht.GetPeers.\n\tErrOnGetPeersResponseNotSet = errors.New(\"OnGetPeersResponse is not set\")\n)\n\n// Config represents the configure of dht.\ntype Config struct {\n\t// in mainline dht, k = 8\n\tK int\n\t// for crawling mode, we put all nodes in one bucket, so KBucketSize may\n\t// not be K\n\tKBucketSize int\n\t// candidates are udp, udp4, udp6\n\tNetwork string\n\t// format is `ip:port`\n\tAddress string\n\t// the prime nodes through which we can join in dht network\n\tPrimeNodes []string\n\t// the kbucket expired duration\n\tKBucketExpiredAfter time.Duration\n\t// the node expired duration\n\tNodeExpriedAfter time.Duration\n\t// how long it checks whether the bucket is expired\n\tCheckKBucketPeriod time.Duration\n\t// peer token expired duration\n\tTokenExpiredAfter time.Duration\n\t// the max transaction id\n\tMaxTransactionCursor uint64\n\t// how many nodes routing table can hold\n\tMaxNodes int\n\t// callback when got get_peers request\n\tOnGetPeers func(string, string, int)\n\t// callback when receive get_peers response\n\tOnGetPeersResponse func(string, *Peer)\n\t// callback when got announce_peer request\n\tOnAnnouncePeer func(string, string, int)\n\t// blcoked ips\n\tBlockedIPs []string\n\t// blacklist size\n\tBlackListMaxSize int\n\t// StandardMode or CrawlMode\n\tMode int\n\t// the times it tries when send fails\n\tTry int\n\t// the size of packet need to be dealt with\n\tPacketJobLimit int\n\t// the size of packet handler\n\tPacketWorkerLimit int\n\t// the nodes num to be fresh in a kbucket\n\tRefreshNodeNum int\n}\n\n// NewStandardConfig returns a Config pointer with default values.\nfunc NewStandardConfig() *Config {\n\treturn &Config{\n\t\tK:           8,\n\t\tKBucketSize: 8,\n\t\tNetwork:     \"udp4\",\n\t\tAddress:     \":6881\",\n\t\tPrimeNodes: []string{\n\t\t\t\"router.bittorrent.com:6881\",\n\t\t\t\"router.utorrent.com:6881\",\n\t\t\t\"dht.transmissionbt.com:6881\",\n\t\t},\n\t\tNodeExpriedAfter:     time.Duration(time.Minute * 15),\n\t\tKBucketExpiredAfter:  time.Duration(time.Minute * 15),\n\t\tCheckKBucketPeriod:   time.Duration(time.Second * 30),\n\t\tTokenExpiredAfter:    time.Duration(time.Minute * 10),\n\t\tMaxTransactionCursor: math.MaxUint32,\n\t\tMaxNodes:             5000,\n\t\tBlockedIPs:           make([]string, 0),\n\t\tBlackListMaxSize:     65536,\n\t\tTry:                  2,\n\t\tMode:                 StandardMode,\n\t\tPacketJobLimit:       1024,\n\t\tPacketWorkerLimit:    256,\n\t\tRefreshNodeNum:       8,\n\t}\n}\n\n// NewCrawlConfig returns a config in crawling mode.\nfunc NewCrawlConfig() *Config {\n\tconfig := NewStandardConfig()\n\tconfig.NodeExpriedAfter = 0\n\tconfig.KBucketExpiredAfter = 0\n\tconfig.CheckKBucketPeriod = time.Second * 5\n\tconfig.KBucketSize = math.MaxInt32\n\tconfig.Mode = CrawlMode\n\tconfig.RefreshNodeNum = 256\n\n\treturn config\n}\n\n// DHT represents a DHT node.\ntype DHT struct {\n\t*Config\n\tnode               *node\n\tconn               *net.UDPConn\n\troutingTable       *routingTable\n\ttransactionManager *transactionManager\n\tpeersManager       *peersManager\n\ttokenManager       *tokenManager\n\tblackList          *blackList\n\tReady              bool\n\tpackets            chan packet\n\tworkerTokens       chan struct{}\n}\n\n// New returns a DHT pointer. If config is nil, then config will be set to\n// the default config.\nfunc New(config *Config) *DHT {\n\tif config == nil {\n\t\tconfig = NewStandardConfig()\n\t}\n\n\tnode, err := newNode(randomString(20), config.Network, config.Address)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\td := &DHT{\n\t\tConfig:       config,\n\t\tnode:         node,\n\t\tblackList:    newBlackList(config.BlackListMaxSize),\n\t\tpackets:      make(chan packet, config.PacketJobLimit),\n\t\tworkerTokens: make(chan struct{}, config.PacketWorkerLimit),\n\t}\n\n\tfor _, ip := range config.BlockedIPs {\n\t\td.blackList.insert(ip, -1)\n\t}\n\n\tgo func() {\n\t\tfor _, ip := range getLocalIPs() {\n\t\t\td.blackList.insert(ip, -1)\n\t\t}\n\n\t\tip, err := getRemoteIP()\n\t\tif err != nil {\n\t\t\td.blackList.insert(ip, -1)\n\t\t}\n\t}()\n\n\treturn d\n}\n\n// IsStandardMode returns whether mode is StandardMode.\nfunc (dht *DHT) IsStandardMode() bool {\n\treturn dht.Mode == StandardMode\n}\n\n// IsCrawlMode returns whether mode is CrawlMode.\nfunc (dht *DHT) IsCrawlMode() bool {\n\treturn dht.Mode == CrawlMode\n}\n\n// init initializes global varables.\nfunc (dht *DHT) init() {\n\tlistener, err := net.ListenPacket(dht.Network, dht.Address)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdht.conn = listener.(*net.UDPConn)\n\tdht.routingTable = newRoutingTable(dht.KBucketSize, dht)\n\tdht.peersManager = newPeersManager(dht)\n\tdht.tokenManager = newTokenManager(dht.TokenExpiredAfter, dht)\n\tdht.transactionManager = newTransactionManager(\n\t\tdht.MaxTransactionCursor, dht)\n\n\tgo dht.transactionManager.run()\n\tgo dht.tokenManager.clear()\n\tgo dht.blackList.clear()\n}\n\n// join makes current node join the dht network.\nfunc (dht *DHT) join() {\n\tfor _, addr := range dht.PrimeNodes {\n\t\traddr, err := net.ResolveUDPAddr(dht.Network, addr)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// NOTE: Temporary node has NOT node id.\n\t\tdht.transactionManager.findNode(\n\t\t\t&node{addr: raddr},\n\t\t\tdht.node.id.RawString(),\n\t\t)\n\t}\n}\n\n// listen receives message from udp.\nfunc (dht *DHT) listen() {\n\tgo func() {\n\t\tbuff := make([]byte, 8192)\n\t\tfor {\n\t\t\tn, raddr, err := dht.conn.ReadFromUDP(buff)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdht.packets <- packet{buff[:n], raddr}\n\t\t}\n\t}()\n}\n\n// id returns a id near to target if target is not null, otherwise it returns\n// the dht's node id.\nfunc (dht *DHT) id(target string) string {\n\tif dht.IsStandardMode() || target == \"\" {\n\t\treturn dht.node.id.RawString()\n\t}\n\treturn target[:15] + dht.node.id.RawString()[15:]\n}\n\n// GetPeers returns peers who have announced having infoHash.\nfunc (dht *DHT) GetPeers(infoHash string) error {\n\tif !dht.Ready {\n\t\treturn ErrNotReady\n\t}\n\n\tif dht.OnGetPeersResponse == nil {\n\t\treturn ErrOnGetPeersResponseNotSet\n\t}\n\n\tif len(infoHash) == 40 {\n\t\tdata, err := hex.DecodeString(infoHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinfoHash = string(data)\n\t}\n\n\tneighbors := dht.routingTable.GetNeighbors(\n\t\tnewBitmapFromString(infoHash), dht.routingTable.Len())\n\n\tfor _, no := range neighbors {\n\t\tdht.transactionManager.getPeers(no, infoHash)\n\t}\n\n\treturn nil\n}\n\n// Run starts the dht.\nfunc (dht *DHT) Run() {\n\tdht.init()\n\tdht.listen()\n\tdht.join()\n\n\tdht.Ready = true\n\n\tvar pkt packet\n\ttick := time.Tick(dht.CheckKBucketPeriod)\n\n\tfor {\n\t\tselect {\n\t\tcase pkt = <-dht.packets:\n\t\t\thandle(dht, pkt)\n\t\tcase <-tick:\n\t\t\tif dht.routingTable.Len() == 0 {\n\t\t\t\tdht.join()\n\t\t\t} else if dht.transactionManager.len() == 0 {\n\t\t\t\tgo dht.routingTable.Fresh()\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0400390625,
          "content": "module github.com/shiyanhui/dht\n\ngo 1.15\n"
        },
        {
          "name": "krpc.go",
          "type": "blob",
          "size": 17.921875,
          "content": "package dht\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nconst (\n\tpingType         = \"ping\"\n\tfindNodeType     = \"find_node\"\n\tgetPeersType     = \"get_peers\"\n\tannouncePeerType = \"announce_peer\"\n)\n\nconst (\n\tgeneralError = 201 + iota\n\tserverError\n\tprotocolError\n\tunknownError\n)\n\n// packet represents the information receive from udp.\ntype packet struct {\n\tdata  []byte\n\traddr *net.UDPAddr\n}\n\n// token represents the token when response getPeers request.\ntype token struct {\n\tdata       string\n\tcreateTime time.Time\n}\n\n// tokenManager managers the tokens.\ntype tokenManager struct {\n\t*syncedMap\n\texpiredAfter time.Duration\n\tdht          *DHT\n}\n\n// newTokenManager returns a new tokenManager.\nfunc newTokenManager(expiredAfter time.Duration, dht *DHT) *tokenManager {\n\treturn &tokenManager{\n\t\tsyncedMap:    newSyncedMap(),\n\t\texpiredAfter: expiredAfter,\n\t\tdht:          dht,\n\t}\n}\n\n// token returns a token. If it doesn't exist or is expired, it will add a\n// new token.\nfunc (tm *tokenManager) token(addr *net.UDPAddr) string {\n\tv, ok := tm.Get(addr.IP.String())\n\ttk, _ := v.(token)\n\n\tif !ok || time.Now().Sub(tk.createTime) > tm.expiredAfter {\n\t\ttk = token{\n\t\t\tdata:       randomString(5),\n\t\t\tcreateTime: time.Now(),\n\t\t}\n\n\t\ttm.Set(addr.IP.String(), tk)\n\t}\n\n\treturn tk.data\n}\n\n// clear removes expired tokens.\nfunc (tm *tokenManager) clear() {\n\tfor _ = range time.Tick(time.Minute * 3) {\n\t\tkeys := make([]interface{}, 0, 100)\n\n\t\tfor item := range tm.Iter() {\n\t\t\tif time.Now().Sub(item.val.(token).createTime) > tm.expiredAfter {\n\t\t\t\tkeys = append(keys, item.key)\n\t\t\t}\n\t\t}\n\n\t\ttm.DeleteMulti(keys)\n\t}\n}\n\n// check returns whether the token is valid.\nfunc (tm *tokenManager) check(addr *net.UDPAddr, tokenString string) bool {\n\tkey := addr.IP.String()\n\tv, ok := tm.Get(key)\n\ttk, _ := v.(token)\n\n\tif ok {\n\t\ttm.Delete(key)\n\t}\n\n\treturn ok && tokenString == tk.data\n}\n\n// makeQuery returns a query-formed data.\nfunc makeQuery(t, q string, a map[string]interface{}) map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"t\": t,\n\t\t\"y\": \"q\",\n\t\t\"q\": q,\n\t\t\"a\": a,\n\t}\n}\n\n// makeResponse returns a response-formed data.\nfunc makeResponse(t string, r map[string]interface{}) map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"t\": t,\n\t\t\"y\": \"r\",\n\t\t\"r\": r,\n\t}\n}\n\n// makeError returns a err-formed data.\nfunc makeError(t string, errCode int, errMsg string) map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"t\": t,\n\t\t\"y\": \"e\",\n\t\t\"e\": []interface{}{errCode, errMsg},\n\t}\n}\n\n// send sends data to the udp.\nfunc send(dht *DHT, addr *net.UDPAddr, data map[string]interface{}) error {\n\tdht.conn.SetWriteDeadline(time.Now().Add(time.Second * 15))\n\n\t_, err := dht.conn.WriteToUDP([]byte(Encode(data)), addr)\n\tif err != nil {\n\t\tdht.blackList.insert(addr.IP.String(), -1)\n\t}\n\treturn err\n}\n\n// query represents the query data included queried node and query-formed data.\ntype query struct {\n\tnode *node\n\tdata map[string]interface{}\n}\n\n// transaction implements transaction.\ntype transaction struct {\n\t*query\n\tid       string\n\tresponse chan struct{}\n}\n\n// transactionManager represents the manager of transactions.\ntype transactionManager struct {\n\t*sync.RWMutex\n\ttransactions *syncedMap\n\tindex        *syncedMap\n\tcursor       uint64\n\tmaxCursor    uint64\n\tqueryChan    chan *query\n\tdht          *DHT\n}\n\n// newTransactionManager returns new transactionManager pointer.\nfunc newTransactionManager(maxCursor uint64, dht *DHT) *transactionManager {\n\treturn &transactionManager{\n\t\tRWMutex:      &sync.RWMutex{},\n\t\ttransactions: newSyncedMap(),\n\t\tindex:        newSyncedMap(),\n\t\tmaxCursor:    maxCursor,\n\t\tqueryChan:    make(chan *query, 1024),\n\t\tdht:          dht,\n\t}\n}\n\n// genTransID generates a transaction id and returns it.\nfunc (tm *transactionManager) genTransID() string {\n\ttm.Lock()\n\tdefer tm.Unlock()\n\n\ttm.cursor = (tm.cursor + 1) % tm.maxCursor\n\treturn string(int2bytes(tm.cursor))\n}\n\n// newTransaction creates a new transaction.\nfunc (tm *transactionManager) newTransaction(id string, q *query) *transaction {\n\treturn &transaction{\n\t\tid:       id,\n\t\tquery:    q,\n\t\tresponse: make(chan struct{}, tm.dht.Try+1),\n\t}\n}\n\n// genIndexKey generates an indexed key which consists of queryType and\n// address.\nfunc (tm *transactionManager) genIndexKey(queryType, address string) string {\n\treturn strings.Join([]string{queryType, address}, \":\")\n}\n\n// genIndexKeyByTrans generates an indexed key by a transaction.\nfunc (tm *transactionManager) genIndexKeyByTrans(trans *transaction) string {\n\treturn tm.genIndexKey(trans.data[\"q\"].(string), trans.node.addr.String())\n}\n\n// insert adds a transaction to transactionManager.\nfunc (tm *transactionManager) insert(trans *transaction) {\n\ttm.Lock()\n\tdefer tm.Unlock()\n\n\ttm.transactions.Set(trans.id, trans)\n\ttm.index.Set(tm.genIndexKeyByTrans(trans), trans)\n}\n\n// delete removes a transaction from transactionManager.\nfunc (tm *transactionManager) delete(transID string) {\n\tv, ok := tm.transactions.Get(transID)\n\tif !ok {\n\t\treturn\n\t}\n\n\ttm.Lock()\n\tdefer tm.Unlock()\n\n\ttrans := v.(*transaction)\n\ttm.transactions.Delete(trans.id)\n\ttm.index.Delete(tm.genIndexKeyByTrans(trans))\n}\n\n// len returns how many transactions are requesting now.\nfunc (tm *transactionManager) len() int {\n\treturn tm.transactions.Len()\n}\n\n// transaction returns a transaction. keyType should be one of 0, 1 which\n// represents transId and index each.\nfunc (tm *transactionManager) transaction(\n\tkey string, keyType int) *transaction {\n\n\tsm := tm.transactions\n\tif keyType == 1 {\n\t\tsm = tm.index\n\t}\n\n\tv, ok := sm.Get(key)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\treturn v.(*transaction)\n}\n\n// getByTransID returns a transaction by transID.\nfunc (tm *transactionManager) getByTransID(transID string) *transaction {\n\treturn tm.transaction(transID, 0)\n}\n\n// getByIndex returns a transaction by indexed key.\nfunc (tm *transactionManager) getByIndex(index string) *transaction {\n\treturn tm.transaction(index, 1)\n}\n\n// transaction gets the proper transaction with whose id is transId and\n// address is addr.\nfunc (tm *transactionManager) filterOne(\n\ttransID string, addr *net.UDPAddr) *transaction {\n\n\ttrans := tm.getByTransID(transID)\n\tif trans == nil || trans.node.addr.String() != addr.String() {\n\t\treturn nil\n\t}\n\n\treturn trans\n}\n\n// query sends the query-formed data to udp and wait for the response.\n// When timeout, it will retry `try - 1` times, which means it will query\n// `try` times totally.\nfunc (tm *transactionManager) query(q *query, try int) {\n\ttransID := q.data[\"t\"].(string)\n\ttrans := tm.newTransaction(transID, q)\n\n\ttm.insert(trans)\n\tdefer tm.delete(trans.id)\n\n\tsuccess := false\n\tfor i := 0; i < try; i++ {\n\t\tif err := send(tm.dht, q.node.addr, q.data); err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tselect {\n\t\tcase <-trans.response:\n\t\t\tsuccess = true\n\t\t\tbreak\n\t\tcase <-time.After(time.Second * 15):\n\t\t}\n\t}\n\n\tif !success && q.node.id != nil {\n\t\ttm.dht.blackList.insert(q.node.addr.IP.String(), q.node.addr.Port)\n\t\ttm.dht.routingTable.RemoveByAddr(q.node.addr.String())\n\t}\n}\n\n// run starts to listen and consume the query chan.\nfunc (tm *transactionManager) run() {\n\tvar q *query\n\n\tfor {\n\t\tselect {\n\t\tcase q = <-tm.queryChan:\n\t\t\tgo tm.query(q, tm.dht.Try)\n\t\t}\n\t}\n}\n\n// sendQuery send query-formed data to the chan.\nfunc (tm *transactionManager) sendQuery(\n\tno *node, queryType string, a map[string]interface{}) {\n\n\t// If the target is self, then stop.\n\tif no.id != nil && no.id.RawString() == tm.dht.node.id.RawString() ||\n\t\ttm.getByIndex(tm.genIndexKey(queryType, no.addr.String())) != nil ||\n\t\ttm.dht.blackList.in(no.addr.IP.String(), no.addr.Port) {\n\t\treturn\n\t}\n\n\tdata := makeQuery(tm.genTransID(), queryType, a)\n\ttm.queryChan <- &query{\n\t\tnode: no,\n\t\tdata: data,\n\t}\n}\n\n// ping sends ping query to the chan.\nfunc (tm *transactionManager) ping(no *node) {\n\ttm.sendQuery(no, pingType, map[string]interface{}{\n\t\t\"id\": tm.dht.id(no.id.RawString()),\n\t})\n}\n\n// findNode sends find_node query to the chan.\nfunc (tm *transactionManager) findNode(no *node, target string) {\n\ttm.sendQuery(no, findNodeType, map[string]interface{}{\n\t\t\"id\":     tm.dht.id(target),\n\t\t\"target\": target,\n\t})\n}\n\n// getPeers sends get_peers query to the chan.\nfunc (tm *transactionManager) getPeers(no *node, infoHash string) {\n\ttm.sendQuery(no, getPeersType, map[string]interface{}{\n\t\t\"id\":        tm.dht.id(infoHash),\n\t\t\"info_hash\": infoHash,\n\t})\n}\n\n// announcePeer sends announce_peer query to the chan.\nfunc (tm *transactionManager) announcePeer(\n\tno *node, infoHash string, impliedPort, port int, token string) {\n\n\ttm.sendQuery(no, announcePeerType, map[string]interface{}{\n\t\t\"id\":           tm.dht.id(no.id.RawString()),\n\t\t\"info_hash\":    infoHash,\n\t\t\"implied_port\": impliedPort,\n\t\t\"port\":         port,\n\t\t\"token\":        token,\n\t})\n}\n\n// ParseKey parses the key in dict data. `t` is type of the keyed value.\n// It's one of \"int\", \"string\", \"map\", \"list\".\nfunc ParseKey(data map[string]interface{}, key string, t string) error {\n\tval, ok := data[key]\n\tif !ok {\n\t\treturn errors.New(\"lack of key\")\n\t}\n\n\tswitch t {\n\tcase \"string\":\n\t\t_, ok = val.(string)\n\tcase \"int\":\n\t\t_, ok = val.(int)\n\tcase \"map\":\n\t\t_, ok = val.(map[string]interface{})\n\tcase \"list\":\n\t\t_, ok = val.([]interface{})\n\tdefault:\n\t\tpanic(\"invalid type\")\n\t}\n\n\tif !ok {\n\t\treturn errors.New(\"invalid key type\")\n\t}\n\n\treturn nil\n}\n\n// ParseKeys parses keys. It just wraps ParseKey.\nfunc ParseKeys(data map[string]interface{}, pairs [][]string) error {\n\tfor _, args := range pairs {\n\t\tkey, t := args[0], args[1]\n\t\tif err := ParseKey(data, key, t); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// parseMessage parses the basic data received from udp.\n// It returns a map value.\nfunc parseMessage(data interface{}) (map[string]interface{}, error) {\n\tresponse, ok := data.(map[string]interface{})\n\tif !ok {\n\t\treturn nil, errors.New(\"response is not dict\")\n\t}\n\n\tif err := ParseKeys(\n\t\tresponse, [][]string{{\"t\", \"string\"}, {\"y\", \"string\"}}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n\n// handleRequest handles the requests received from udp.\nfunc handleRequest(dht *DHT, addr *net.UDPAddr,\n\tresponse map[string]interface{}) (success bool) {\n\n\tt := response[\"t\"].(string)\n\n\tif err := ParseKeys(\n\t\tresponse, [][]string{{\"q\", \"string\"}, {\"a\", \"map\"}}); err != nil {\n\n\t\tsend(dht, addr, makeError(t, protocolError, err.Error()))\n\t\treturn\n\t}\n\n\tq := response[\"q\"].(string)\n\ta := response[\"a\"].(map[string]interface{})\n\n\tif err := ParseKey(a, \"id\", \"string\"); err != nil {\n\t\tsend(dht, addr, makeError(t, protocolError, err.Error()))\n\t\treturn\n\t}\n\n\tid := a[\"id\"].(string)\n\n\tif id == dht.node.id.RawString() {\n\t\treturn\n\t}\n\n\tif len(id) != 20 {\n\t\tsend(dht, addr, makeError(t, protocolError, \"invalid id\"))\n\t\treturn\n\t}\n\n\tif no, ok := dht.routingTable.GetNodeByAddress(addr.String()); ok &&\n\t\tno.id.RawString() != id {\n\n\t\tdht.blackList.insert(addr.IP.String(), addr.Port)\n\t\tdht.routingTable.RemoveByAddr(addr.String())\n\n\t\tsend(dht, addr, makeError(t, protocolError, \"invalid id\"))\n\t\treturn\n\t}\n\n\tswitch q {\n\tcase pingType:\n\t\tsend(dht, addr, makeResponse(t, map[string]interface{}{\n\t\t\t\"id\": dht.id(id),\n\t\t}))\n\tcase findNodeType:\n\t\tif dht.IsStandardMode() {\n\t\t\tif err := ParseKey(a, \"target\", \"string\"); err != nil {\n\t\t\t\tsend(dht, addr, makeError(t, protocolError, err.Error()))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttarget := a[\"target\"].(string)\n\t\t\tif len(target) != 20 {\n\t\t\t\tsend(dht, addr, makeError(t, protocolError, \"invalid target\"))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar nodes string\n\t\t\ttargetID := newBitmapFromString(target)\n\n\t\t\tno, _ := dht.routingTable.GetNodeKBucktByID(targetID)\n\t\t\tif no != nil {\n\t\t\t\tnodes = no.CompactNodeInfo()\n\t\t\t} else {\n\t\t\t\tnodes = strings.Join(\n\t\t\t\t\tdht.routingTable.GetNeighborCompactInfos(targetID, dht.K),\n\t\t\t\t\t\"\",\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tsend(dht, addr, makeResponse(t, map[string]interface{}{\n\t\t\t\t\"id\":    dht.id(target),\n\t\t\t\t\"nodes\": nodes,\n\t\t\t}))\n\t\t}\n\tcase getPeersType:\n\t\tif err := ParseKey(a, \"info_hash\", \"string\"); err != nil {\n\t\t\tsend(dht, addr, makeError(t, protocolError, err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tinfoHash := a[\"info_hash\"].(string)\n\n\t\tif len(infoHash) != 20 {\n\t\t\tsend(dht, addr, makeError(t, protocolError, \"invalid info_hash\"))\n\t\t\treturn\n\t\t}\n\n\t\tif dht.IsCrawlMode() {\n\t\t\tsend(dht, addr, makeResponse(t, map[string]interface{}{\n\t\t\t\t\"id\":    dht.id(infoHash),\n\t\t\t\t\"token\": dht.tokenManager.token(addr),\n\t\t\t\t\"nodes\": \"\",\n\t\t\t}))\n\t\t} else if peers := dht.peersManager.GetPeers(\n\t\t\tinfoHash, dht.K); len(peers) > 0 {\n\n\t\t\tvalues := make([]interface{}, len(peers))\n\t\t\tfor i, p := range peers {\n\t\t\t\tvalues[i] = p.CompactIPPortInfo()\n\t\t\t}\n\n\t\t\tsend(dht, addr, makeResponse(t, map[string]interface{}{\n\t\t\t\t\"id\":     dht.id(infoHash),\n\t\t\t\t\"values\": values,\n\t\t\t\t\"token\":  dht.tokenManager.token(addr),\n\t\t\t}))\n\t\t} else {\n\t\t\tsend(dht, addr, makeResponse(t, map[string]interface{}{\n\t\t\t\t\"id\":    dht.id(infoHash),\n\t\t\t\t\"token\": dht.tokenManager.token(addr),\n\t\t\t\t\"nodes\": strings.Join(dht.routingTable.GetNeighborCompactInfos(\n\t\t\t\t\tnewBitmapFromString(infoHash), dht.K), \"\"),\n\t\t\t}))\n\t\t}\n\n\t\tif dht.OnGetPeers != nil {\n\t\t\tdht.OnGetPeers(infoHash, addr.IP.String(), addr.Port)\n\t\t}\n\tcase announcePeerType:\n\t\tif err := ParseKeys(a, [][]string{\n\t\t\t{\"info_hash\", \"string\"},\n\t\t\t{\"port\", \"int\"},\n\t\t\t{\"token\", \"string\"}}); err != nil {\n\n\t\t\tsend(dht, addr, makeError(t, protocolError, err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tinfoHash := a[\"info_hash\"].(string)\n\t\tport := a[\"port\"].(int)\n\t\ttoken := a[\"token\"].(string)\n\n\t\tif !dht.tokenManager.check(addr, token) {\n\t\t\t//\t\t\tsend(dht, addr, makeError(t, protocolError, \"invalid token\"))\n\t\t\treturn\n\t\t}\n\n\t\tif impliedPort, ok := a[\"implied_port\"]; ok &&\n\t\t\timpliedPort.(int) != 0 {\n\n\t\t\tport = addr.Port\n\t\t}\n\n\t\tif dht.IsStandardMode() {\n\t\t\tdht.peersManager.Insert(infoHash, newPeer(addr.IP, port, token))\n\n\t\t\tsend(dht, addr, makeResponse(t, map[string]interface{}{\n\t\t\t\t\"id\": dht.id(id),\n\t\t\t}))\n\t\t}\n\n\t\tif dht.OnAnnouncePeer != nil {\n\t\t\tdht.OnAnnouncePeer(infoHash, addr.IP.String(), port)\n\t\t}\n\tdefault:\n\t\t//\t\tsend(dht, addr, makeError(t, protocolError, \"invalid q\"))\n\t\treturn\n\t}\n\n\tno, _ := newNode(id, addr.Network(), addr.String())\n\tdht.routingTable.Insert(no)\n\treturn true\n}\n\n// findOn puts nodes in the response to the routingTable, then if target is in\n// the nodes or all nodes are in the routingTable, it stops. Otherwise it\n// continues to findNode or getPeers.\nfunc findOn(dht *DHT, r map[string]interface{}, target *bitmap,\n\tqueryType string) error {\n\n\tif err := ParseKey(r, \"nodes\", \"string\"); err != nil {\n\t\treturn err\n\t}\n\n\tnodes := r[\"nodes\"].(string)\n\tif len(nodes)%26 != 0 {\n\t\treturn errors.New(\"the length of nodes should can be divided by 26\")\n\t}\n\n\thasNew, found := false, false\n\tfor i := 0; i < len(nodes)/26; i++ {\n\t\tno, _ := newNodeFromCompactInfo(\n\t\t\tstring(nodes[i*26:(i+1)*26]), dht.Network)\n\n\t\tif no.id.RawString() == target.RawString() {\n\t\t\tfound = true\n\t\t}\n\n\t\tif dht.routingTable.Insert(no) {\n\t\t\thasNew = true\n\t\t}\n\t}\n\n\tif found || !hasNew {\n\t\treturn nil\n\t}\n\n\ttargetID := target.RawString()\n\tfor _, no := range dht.routingTable.GetNeighbors(target, dht.K) {\n\t\tswitch queryType {\n\t\tcase findNodeType:\n\t\t\tdht.transactionManager.findNode(no, targetID)\n\t\tcase getPeersType:\n\t\t\tdht.transactionManager.getPeers(no, targetID)\n\t\tdefault:\n\t\t\tpanic(\"invalid find type\")\n\t\t}\n\t}\n\treturn nil\n}\n\n// handleResponse handles responses received from udp.\nfunc handleResponse(dht *DHT, addr *net.UDPAddr,\n\tresponse map[string]interface{}) (success bool) {\n\n\tt := response[\"t\"].(string)\n\n\ttrans := dht.transactionManager.filterOne(t, addr)\n\tif trans == nil {\n\t\treturn\n\t}\n\n\t// inform transManager to delete the transaction.\n\tif err := ParseKey(response, \"r\", \"map\"); err != nil {\n\t\treturn\n\t}\n\n\tq := trans.data[\"q\"].(string)\n\ta := trans.data[\"a\"].(map[string]interface{})\n\tr := response[\"r\"].(map[string]interface{})\n\n\tif err := ParseKey(r, \"id\", \"string\"); err != nil {\n\t\treturn\n\t}\n\n\tid := r[\"id\"].(string)\n\n\t// If response's node id is not the same with the node id in the\n\t// transaction, raise error.\n\tif trans.node.id != nil && trans.node.id.RawString() != r[\"id\"].(string) {\n\t\tdht.blackList.insert(addr.IP.String(), addr.Port)\n\t\tdht.routingTable.RemoveByAddr(addr.String())\n\t\treturn\n\t}\n\n\tnode, err := newNode(id, addr.Network(), addr.String())\n\tif err != nil {\n\t\treturn\n\t}\n\n\tswitch q {\n\tcase pingType:\n\tcase findNodeType:\n\t\tif trans.data[\"q\"].(string) != findNodeType {\n\t\t\treturn\n\t\t}\n\n\t\ttarget := trans.data[\"a\"].(map[string]interface{})[\"target\"].(string)\n\t\tif findOn(dht, r, newBitmapFromString(target), findNodeType) != nil {\n\t\t\treturn\n\t\t}\n\tcase getPeersType:\n\t\tif err := ParseKey(r, \"token\", \"string\"); err != nil {\n\t\t\treturn\n\t\t}\n\n\t\ttoken := r[\"token\"].(string)\n\t\tinfoHash := a[\"info_hash\"].(string)\n\n\t\tif err := ParseKey(r, \"values\", \"list\"); err == nil {\n\t\t\tvalues := r[\"values\"].([]interface{})\n\t\t\tfor _, v := range values {\n\t\t\t\tp, err := newPeerFromCompactIPPortInfo(v.(string), token)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdht.peersManager.Insert(infoHash, p)\n\t\t\t\tif dht.OnGetPeersResponse != nil {\n\t\t\t\t\tdht.OnGetPeersResponse(infoHash, p)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if findOn(\n\t\t\tdht, r, newBitmapFromString(infoHash), getPeersType) != nil {\n\t\t\treturn\n\t\t}\n\tcase announcePeerType:\n\tdefault:\n\t\treturn\n\t}\n\n\t// inform transManager to delete transaction.\n\ttrans.response <- struct{}{}\n\n\tdht.blackList.delete(addr.IP.String(), addr.Port)\n\tdht.routingTable.Insert(node)\n\n\treturn true\n}\n\n// handleError handles errors received from udp.\nfunc handleError(dht *DHT, addr *net.UDPAddr,\n\tresponse map[string]interface{}) (success bool) {\n\n\tif err := ParseKey(response, \"e\", \"list\"); err != nil {\n\t\treturn\n\t}\n\n\tif e := response[\"e\"].([]interface{}); len(e) != 2 {\n\t\treturn\n\t}\n\n\tif trans := dht.transactionManager.filterOne(\n\t\tresponse[\"t\"].(string), addr); trans != nil {\n\n\t\ttrans.response <- struct{}{}\n\t}\n\n\treturn true\n}\n\nvar handlers = map[string]func(*DHT, *net.UDPAddr, map[string]interface{}) bool{\n\t\"q\": handleRequest,\n\t\"r\": handleResponse,\n\t\"e\": handleError,\n}\n\n// handle handles packets received from udp.\nfunc handle(dht *DHT, pkt packet) {\n\tif len(dht.workerTokens) == dht.PacketWorkerLimit {\n\t\treturn\n\t}\n\n\tdht.workerTokens <- struct{}{}\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\t<-dht.workerTokens\n\t\t}()\n\n\t\tif dht.blackList.in(pkt.raddr.IP.String(), pkt.raddr.Port) {\n\t\t\treturn\n\t\t}\n\n\t\tdata, err := Decode(pkt.data)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tresponse, err := parseMessage(data)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif f, ok := handlers[response[\"y\"].(string)]; ok {\n\t\t\tf(dht, pkt.raddr, response)\n\t\t}\n\t}()\n}\n"
        },
        {
          "name": "peerwire.go",
          "type": "blob",
          "size": 7.833984375,
          "content": "package dht\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha1\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst (\n\t// REQUEST represents request message type\n\tREQUEST = iota\n\t// DATA represents data message type\n\tDATA\n\t// REJECT represents reject message type\n\tREJECT\n)\n\nconst (\n\t// BLOCK is 2 ^ 14\n\tBLOCK = 16384\n\t// MaxMetadataSize represents the max medata it can accept\n\tMaxMetadataSize = BLOCK * 1000\n\t// EXTENDED represents it is a extended message\n\tEXTENDED = 20\n\t// HANDSHAKE represents handshake bit\n\tHANDSHAKE = 0\n)\n\nvar handshakePrefix = []byte{\n\t19, 66, 105, 116, 84, 111, 114, 114, 101, 110, 116, 32, 112, 114,\n\t111, 116, 111, 99, 111, 108, 0, 0, 0, 0, 0, 16, 0, 1,\n}\n\n// read reads size-length bytes from conn to data.\nfunc read(conn *net.TCPConn, size int, data *bytes.Buffer) error {\n\tconn.SetReadDeadline(time.Now().Add(time.Second * 15))\n\n\tn, err := io.CopyN(data, conn, int64(size))\n\tif err != nil || n != int64(size) {\n\t\treturn errors.New(\"read error\")\n\t}\n\treturn nil\n}\n\n// readMessage gets a message from the tcp connection.\nfunc readMessage(conn *net.TCPConn, data *bytes.Buffer) (\n\tlength int, err error) {\n\n\tif err = read(conn, 4, data); err != nil {\n\t\treturn\n\t}\n\n\tlength = int(bytes2int(data.Next(4)))\n\tif length == 0 {\n\t\treturn\n\t}\n\n\tif err = read(conn, length, data); err != nil {\n\t\treturn\n\t}\n\treturn\n}\n\n// sendMessage sends data to the connection.\nfunc sendMessage(conn *net.TCPConn, data []byte) error {\n\tlength := int32(len(data))\n\n\tbuffer := bytes.NewBuffer(nil)\n\tbinary.Write(buffer, binary.BigEndian, length)\n\n\tconn.SetWriteDeadline(time.Now().Add(time.Second * 10))\n\t_, err := conn.Write(append(buffer.Bytes(), data...))\n\treturn err\n}\n\n// sendHandshake sends handshake message to conn.\nfunc sendHandshake(conn *net.TCPConn, infoHash, peerID []byte) error {\n\tdata := make([]byte, 68)\n\tcopy(data[:28], handshakePrefix)\n\tcopy(data[28:48], infoHash)\n\tcopy(data[48:], peerID)\n\n\tconn.SetWriteDeadline(time.Now().Add(time.Second * 10))\n\t_, err := conn.Write(data)\n\treturn err\n}\n\n// onHandshake handles the handshake response.\nfunc onHandshake(data []byte) (err error) {\n\tif !(bytes.Equal(handshakePrefix[:20], data[:20]) && data[25]&0x10 != 0) {\n\t\terr = errors.New(\"invalid handshake response\")\n\t}\n\treturn\n}\n\n// sendExtHandshake requests for the ut_metadata and metadata_size.\nfunc sendExtHandshake(conn *net.TCPConn) error {\n\tdata := append(\n\t\t[]byte{EXTENDED, HANDSHAKE},\n\t\tEncode(map[string]interface{}{\n\t\t\t\"m\": map[string]interface{}{\"ut_metadata\": 1},\n\t\t})...,\n\t)\n\n\treturn sendMessage(conn, data)\n}\n\n// getUTMetaSize returns the ut_metadata and metadata_size.\nfunc getUTMetaSize(data []byte) (\n\tutMetadata int, metadataSize int, err error) {\n\n\tv, err := Decode(data)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdict, ok := v.(map[string]interface{})\n\tif !ok {\n\t\terr = errors.New(\"invalid dict\")\n\t\treturn\n\t}\n\n\tif err = ParseKeys(\n\t\tdict, [][]string{{\"metadata_size\", \"int\"}, {\"m\", \"map\"}}); err != nil {\n\t\treturn\n\t}\n\n\tm := dict[\"m\"].(map[string]interface{})\n\tif err = ParseKey(m, \"ut_metadata\", \"int\"); err != nil {\n\t\treturn\n\t}\n\n\tutMetadata = m[\"ut_metadata\"].(int)\n\tmetadataSize = dict[\"metadata_size\"].(int)\n\n\tif metadataSize > MaxMetadataSize {\n\t\terr = errors.New(\"metadata_size too long\")\n\t}\n\treturn\n}\n\n// Request represents the request context.\ntype Request struct {\n\tInfoHash []byte\n\tIP       string\n\tPort     int\n}\n\n// Response contains the request context and the metadata info.\ntype Response struct {\n\tRequest\n\tMetadataInfo []byte\n}\n\n// Wire represents the wire protocol.\ntype Wire struct {\n\tblackList    *blackList\n\tqueue        *syncedMap\n\trequests     chan Request\n\tresponses    chan Response\n\tworkerTokens chan struct{}\n}\n\n// NewWire returns a Wire pointer.\n//   - blackListSize: the blacklist size\n//   - requestQueueSize: the max requests it can buffers\n//   - workerQueueSize: the max goroutine downloading workers\nfunc NewWire(blackListSize, requestQueueSize, workerQueueSize int) *Wire {\n\treturn &Wire{\n\t\tblackList:    newBlackList(blackListSize),\n\t\tqueue:        newSyncedMap(),\n\t\trequests:     make(chan Request, requestQueueSize),\n\t\tresponses:    make(chan Response, 1024),\n\t\tworkerTokens: make(chan struct{}, workerQueueSize),\n\t}\n}\n\n// Request pushes the request to the queue.\nfunc (wire *Wire) Request(infoHash []byte, ip string, port int) {\n\twire.requests <- Request{InfoHash: infoHash, IP: ip, Port: port}\n}\n\n// Response returns a chan of Response.\nfunc (wire *Wire) Response() <-chan Response {\n\treturn wire.responses\n}\n\n// isDone returns whether the wire get all pieces of the metadata info.\nfunc (wire *Wire) isDone(pieces [][]byte) bool {\n\tfor _, piece := range pieces {\n\t\tif len(piece) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (wire *Wire) requestPieces(\n\tconn *net.TCPConn, utMetadata int, metadataSize int, piecesNum int) {\n\n\tbuffer := make([]byte, 1024)\n\tfor i := 0; i < piecesNum; i++ {\n\t\tbuffer[0] = EXTENDED\n\t\tbuffer[1] = byte(utMetadata)\n\n\t\tmsg := Encode(map[string]interface{}{\n\t\t\t\"msg_type\": REQUEST,\n\t\t\t\"piece\":    i,\n\t\t})\n\n\t\tlength := len(msg) + 2\n\t\tcopy(buffer[2:length], msg)\n\n\t\tsendMessage(conn, buffer[:length])\n\t}\n\tbuffer = nil\n}\n\n// fetchMetadata fetchs medata info accroding to infohash from dht.\nfunc (wire *Wire) fetchMetadata(r Request) {\n\tvar (\n\t\tlength       int\n\t\tmsgType      byte\n\t\tpiecesNum    int\n\t\tpieces       [][]byte\n\t\tutMetadata   int\n\t\tmetadataSize int\n\t)\n\n\tdefer func() {\n\t\tpieces = nil\n\t\trecover()\n\t}()\n\n\tinfoHash := r.InfoHash\n\taddress := genAddress(r.IP, r.Port)\n\n\tdial, err := net.DialTimeout(\"tcp\", address, time.Second*15)\n\tif err != nil {\n\t\twire.blackList.insert(r.IP, r.Port)\n\t\treturn\n\t}\n\tconn := dial.(*net.TCPConn)\n\tconn.SetLinger(0)\n\tdefer conn.Close()\n\n\tdata := bytes.NewBuffer(nil)\n\tdata.Grow(BLOCK)\n\n\tif sendHandshake(conn, infoHash, []byte(randomString(20))) != nil ||\n\t\tread(conn, 68, data) != nil ||\n\t\tonHandshake(data.Next(68)) != nil ||\n\t\tsendExtHandshake(conn) != nil {\n\t\treturn\n\t}\n\n\tfor {\n\t\tlength, err = readMessage(conn, data)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif length == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tmsgType, err = data.ReadByte()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tswitch msgType {\n\t\tcase EXTENDED:\n\t\t\textendedID, err := data.ReadByte()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpayload, err := ioutil.ReadAll(data)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif extendedID == 0 {\n\t\t\t\tif pieces != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tutMetadata, metadataSize, err = getUTMetaSize(payload)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tpiecesNum = metadataSize / BLOCK\n\t\t\t\tif metadataSize%BLOCK != 0 {\n\t\t\t\t\tpiecesNum++\n\t\t\t\t}\n\n\t\t\t\tpieces = make([][]byte, piecesNum)\n\t\t\t\tgo wire.requestPieces(conn, utMetadata, metadataSize, piecesNum)\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif pieces == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\td, index, err := DecodeDict(payload, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdict := d.(map[string]interface{})\n\n\t\t\tif err = ParseKeys(dict, [][]string{\n\t\t\t\t{\"msg_type\", \"int\"},\n\t\t\t\t{\"piece\", \"int\"}}); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif dict[\"msg_type\"].(int) != DATA {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpiece := dict[\"piece\"].(int)\n\t\t\tpieceLen := length - 2 - index\n\n\t\t\tif (piece != piecesNum-1 && pieceLen != BLOCK) ||\n\t\t\t\t(piece == piecesNum-1 && pieceLen != metadataSize%BLOCK) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpieces[piece] = payload[index:]\n\n\t\t\tif wire.isDone(pieces) {\n\t\t\t\tmetadataInfo := bytes.Join(pieces, nil)\n\n\t\t\t\tinfo := sha1.Sum(metadataInfo)\n\t\t\t\tif !bytes.Equal(infoHash, info[:]) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\twire.responses <- Response{\n\t\t\t\t\tRequest:      r,\n\t\t\t\t\tMetadataInfo: metadataInfo,\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\tdefault:\n\t\t\tdata.Reset()\n\t\t}\n\t}\n}\n\n// Run starts the peer wire protocol.\nfunc (wire *Wire) Run() {\n\tgo wire.blackList.clear()\n\n\tfor r := range wire.requests {\n\t\twire.workerTokens <- struct{}{}\n\n\t\tgo func(r Request) {\n\t\t\tdefer func() {\n\t\t\t\t<-wire.workerTokens\n\t\t\t}()\n\n\t\t\tkey := strings.Join([]string{\n\t\t\t\tstring(r.InfoHash), genAddress(r.IP, r.Port),\n\t\t\t}, \":\")\n\n\t\t\tif len(r.InfoHash) != 20 || wire.blackList.in(r.IP, r.Port) ||\n\t\t\t\twire.queue.Has(key) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twire.fetchMetadata(r)\n\t\t}(r)\n\t}\n}\n"
        },
        {
          "name": "routingtable.go",
          "type": "blob",
          "size": 13.8603515625,
          "content": "package dht\n\nimport (\n\t\"container/heap\"\n\t\"errors\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\n// maxPrefixLength is the length of DHT node.\nconst maxPrefixLength = 160\n\n// node represents a DHT node.\ntype node struct {\n\tid             *bitmap\n\taddr           *net.UDPAddr\n\tlastActiveTime time.Time\n}\n\n// newNode returns a node pointer.\nfunc newNode(id, network, address string) (*node, error) {\n\tif len(id) != 20 {\n\t\treturn nil, errors.New(\"node id should be a 20-length string\")\n\t}\n\n\taddr, err := net.ResolveUDPAddr(network, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &node{newBitmapFromString(id), addr, time.Now()}, nil\n}\n\n// newNodeFromCompactInfo parses compactNodeInfo and returns a node pointer.\nfunc newNodeFromCompactInfo(\n\tcompactNodeInfo string, network string) (*node, error) {\n\n\tif len(compactNodeInfo) != 26 {\n\t\treturn nil, errors.New(\"compactNodeInfo should be a 26-length string\")\n\t}\n\n\tid := compactNodeInfo[:20]\n\tip, port, _ := decodeCompactIPPortInfo(compactNodeInfo[20:])\n\n\treturn newNode(id, network, genAddress(ip.String(), port))\n}\n\n// CompactIPPortInfo returns \"Compact IP-address/port info\".\n// See http://www.bittorrent.org/beps/bep_0005.html.\nfunc (node *node) CompactIPPortInfo() string {\n\tinfo, _ := encodeCompactIPPortInfo(node.addr.IP, node.addr.Port)\n\treturn info\n}\n\n// CompactNodeInfo returns \"Compact node info\".\n// See http://www.bittorrent.org/beps/bep_0005.html.\nfunc (node *node) CompactNodeInfo() string {\n\treturn strings.Join([]string{\n\t\tnode.id.RawString(), node.CompactIPPortInfo(),\n\t}, \"\")\n}\n\n// Peer represents a peer contact.\ntype Peer struct {\n\tIP    net.IP\n\tPort  int\n\ttoken string\n}\n\n// newPeer returns a new peer pointer.\nfunc newPeer(ip net.IP, port int, token string) *Peer {\n\treturn &Peer{\n\t\tIP:    ip,\n\t\tPort:  port,\n\t\ttoken: token,\n\t}\n}\n\n// newPeerFromCompactIPPortInfo create a peer pointer by compact ip/port info.\nfunc newPeerFromCompactIPPortInfo(compactInfo, token string) (*Peer, error) {\n\tip, port, err := decodeCompactIPPortInfo(compactInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newPeer(ip, port, token), nil\n}\n\n// CompactIPPortInfo returns \"Compact node info\".\n// See http://www.bittorrent.org/beps/bep_0005.html.\nfunc (p *Peer) CompactIPPortInfo() string {\n\tinfo, _ := encodeCompactIPPortInfo(p.IP, p.Port)\n\treturn info\n}\n\n// peersManager represents a proxy that manipulates peers.\ntype peersManager struct {\n\tsync.RWMutex\n\ttable *syncedMap\n\tdht   *DHT\n}\n\n// newPeersManager returns a new peersManager.\nfunc newPeersManager(dht *DHT) *peersManager {\n\treturn &peersManager{\n\t\ttable: newSyncedMap(),\n\t\tdht:   dht,\n\t}\n}\n\n// Insert adds a peer into peersManager.\nfunc (pm *peersManager) Insert(infoHash string, peer *Peer) {\n\tpm.Lock()\n\tif _, ok := pm.table.Get(infoHash); !ok {\n\t\tpm.table.Set(infoHash, newKeyedDeque())\n\t}\n\tpm.Unlock()\n\n\tv, _ := pm.table.Get(infoHash)\n\tqueue := v.(*keyedDeque)\n\n\tqueue.Push(peer.CompactIPPortInfo(), peer)\n\tif queue.Len() > pm.dht.K {\n\t\tqueue.Remove(queue.Front())\n\t}\n}\n\n// GetPeers returns size-length peers who announces having infoHash.\nfunc (pm *peersManager) GetPeers(infoHash string, size int) []*Peer {\n\tpeers := make([]*Peer, 0, size)\n\n\tv, ok := pm.table.Get(infoHash)\n\tif !ok {\n\t\treturn peers\n\t}\n\n\tfor e := range v.(*keyedDeque).Iter() {\n\t\tpeers = append(peers, e.Value.(*Peer))\n\t}\n\n\tif len(peers) > size {\n\t\tpeers = peers[len(peers)-size:]\n\t}\n\treturn peers\n}\n\n// kbucket represents a k-size bucket.\ntype kbucket struct {\n\tsync.RWMutex\n\tnodes, candidates *keyedDeque\n\tlastChanged       time.Time\n\tprefix            *bitmap\n}\n\n// newKBucket returns a new kbucket pointer.\nfunc newKBucket(prefix *bitmap) *kbucket {\n\tbucket := &kbucket{\n\t\tnodes:       newKeyedDeque(),\n\t\tcandidates:  newKeyedDeque(),\n\t\tlastChanged: time.Now(),\n\t\tprefix:      prefix,\n\t}\n\treturn bucket\n}\n\n// LastChanged return the last time when it changes.\nfunc (bucket *kbucket) LastChanged() time.Time {\n\tbucket.RLock()\n\tdefer bucket.RUnlock()\n\n\treturn bucket.lastChanged\n}\n\n// RandomChildID returns a random id that has the same prefix with bucket.\nfunc (bucket *kbucket) RandomChildID() string {\n\tprefixLen := bucket.prefix.Size / 8\n\n\treturn strings.Join([]string{\n\t\tbucket.prefix.RawString()[:prefixLen],\n\t\trandomString(20 - prefixLen),\n\t}, \"\")\n}\n\n// UpdateTimestamp update bucket's last changed time..\nfunc (bucket *kbucket) UpdateTimestamp() {\n\tbucket.Lock()\n\tdefer bucket.Unlock()\n\n\tbucket.lastChanged = time.Now()\n}\n\n// Insert inserts node to the bucket. It returns whether the node is new in\n// the bucket.\nfunc (bucket *kbucket) Insert(no *node) bool {\n\tisNew := !bucket.nodes.HasKey(no.id.RawString())\n\n\tbucket.nodes.Push(no.id.RawString(), no)\n\tbucket.UpdateTimestamp()\n\n\treturn isNew\n}\n\n// Replace removes node, then put bucket.candidates.Back() to the right\n// place of bucket.nodes.\nfunc (bucket *kbucket) Replace(no *node) {\n\tbucket.nodes.Delete(no.id.RawString())\n\tbucket.UpdateTimestamp()\n\n\tif bucket.candidates.Len() == 0 {\n\t\treturn\n\t}\n\n\tno = bucket.candidates.Remove(bucket.candidates.Back()).(*node)\n\n\tinserted := false\n\tfor e := range bucket.nodes.Iter() {\n\t\tif e.Value.(*node).lastActiveTime.After(\n\t\t\tno.lastActiveTime) && !inserted {\n\n\t\t\tbucket.nodes.InsertBefore(no, e)\n\t\t\tinserted = true\n\t\t}\n\t}\n\n\tif !inserted {\n\t\tbucket.nodes.PushBack(no)\n\t}\n}\n\n// Fresh pings the expired nodes in the bucket.\nfunc (bucket *kbucket) Fresh(dht *DHT) {\n\tfor e := range bucket.nodes.Iter() {\n\t\tno := e.Value.(*node)\n\t\tif time.Since(no.lastActiveTime) > dht.NodeExpriedAfter {\n\t\t\tdht.transactionManager.ping(no)\n\t\t}\n\t}\n}\n\n// routingTableNode represents routing table tree node.\ntype routingTableNode struct {\n\tsync.RWMutex\n\tchildren []*routingTableNode\n\tbucket   *kbucket\n}\n\n// newRoutingTableNode returns a new routingTableNode pointer.\nfunc newRoutingTableNode(prefix *bitmap) *routingTableNode {\n\treturn &routingTableNode{\n\t\tchildren: make([]*routingTableNode, 2),\n\t\tbucket:   newKBucket(prefix),\n\t}\n}\n\n// Child returns routingTableNode's left or right child.\nfunc (tableNode *routingTableNode) Child(index int) *routingTableNode {\n\tif index >= 2 {\n\t\treturn nil\n\t}\n\n\ttableNode.RLock()\n\tdefer tableNode.RUnlock()\n\n\treturn tableNode.children[index]\n}\n\n// SetChild sets routingTableNode's left or right child. When index is 0, it's\n// the left child, if 1, it's the right child.\nfunc (tableNode *routingTableNode) SetChild(index int, c *routingTableNode) {\n\ttableNode.Lock()\n\tdefer tableNode.Unlock()\n\n\ttableNode.children[index] = c\n}\n\n// KBucket returns the bucket routingTableNode holds.\nfunc (tableNode *routingTableNode) KBucket() *kbucket {\n\ttableNode.RLock()\n\tdefer tableNode.RUnlock()\n\n\treturn tableNode.bucket\n}\n\n// SetKBucket sets the bucket.\nfunc (tableNode *routingTableNode) SetKBucket(bucket *kbucket) {\n\ttableNode.Lock()\n\tdefer tableNode.Unlock()\n\n\ttableNode.bucket = bucket\n}\n\n// Split splits current routingTableNode and sets it's two children.\nfunc (tableNode *routingTableNode) Split() {\n\tprefixLen := tableNode.KBucket().prefix.Size\n\n\tif prefixLen == maxPrefixLength {\n\t\treturn\n\t}\n\n\tfor i := 0; i < 2; i++ {\n\t\ttableNode.SetChild(i, newRoutingTableNode(newBitmapFrom(\n\t\t\ttableNode.KBucket().prefix, prefixLen+1)))\n\t}\n\n\ttableNode.Lock()\n\ttableNode.children[1].bucket.prefix.Set(prefixLen)\n\ttableNode.Unlock()\n\n\tfor e := range tableNode.KBucket().nodes.Iter() {\n\t\tnd := e.Value.(*node)\n\t\ttableNode.Child(nd.id.Bit(prefixLen)).KBucket().nodes.PushBack(nd)\n\t}\n\n\tfor e := range tableNode.KBucket().candidates.Iter() {\n\t\tnd := e.Value.(*node)\n\t\ttableNode.Child(nd.id.Bit(prefixLen)).KBucket().candidates.PushBack(nd)\n\t}\n\n\tfor i := 0; i < 2; i++ {\n\t\ttableNode.Child(i).KBucket().UpdateTimestamp()\n\t}\n}\n\n// routingTable implements the routing table in DHT protocol.\ntype routingTable struct {\n\t*sync.RWMutex\n\tk              int\n\troot           *routingTableNode\n\tcachedNodes    *syncedMap\n\tcachedKBuckets *keyedDeque\n\tdht            *DHT\n\tclearQueue     *syncedList\n}\n\n// newRoutingTable returns a new routingTable pointer.\nfunc newRoutingTable(k int, dht *DHT) *routingTable {\n\troot := newRoutingTableNode(newBitmap(0))\n\n\trt := &routingTable{\n\t\tRWMutex:        &sync.RWMutex{},\n\t\tk:              k,\n\t\troot:           root,\n\t\tcachedNodes:    newSyncedMap(),\n\t\tcachedKBuckets: newKeyedDeque(),\n\t\tdht:            dht,\n\t\tclearQueue:     newSyncedList(),\n\t}\n\n\trt.cachedKBuckets.Push(root.bucket.prefix.String(), root.bucket)\n\treturn rt\n}\n\n// Insert adds a node to routing table. It returns whether the node is new\n// in the routingtable.\nfunc (rt *routingTable) Insert(nd *node) bool {\n\trt.Lock()\n\tdefer rt.Unlock()\n\n\tif rt.dht.blackList.in(nd.addr.IP.String(), nd.addr.Port) ||\n\t\trt.cachedNodes.Len() >= rt.dht.MaxNodes {\n\t\treturn false\n\t}\n\n\tvar (\n\t\tnext   *routingTableNode\n\t\tbucket *kbucket\n\t)\n\troot := rt.root\n\n\tfor prefixLen := 1; prefixLen <= maxPrefixLength; prefixLen++ {\n\t\tnext = root.Child(nd.id.Bit(prefixLen - 1))\n\n\t\tif next != nil {\n\t\t\t// If next is not the leaf.\n\t\t\troot = next\n\t\t} else if root.KBucket().nodes.Len() < rt.k ||\n\t\t\troot.KBucket().nodes.HasKey(nd.id.RawString()) {\n\n\t\t\tbucket = root.KBucket()\n\t\t\tisNew := bucket.Insert(nd)\n\n\t\t\trt.cachedNodes.Set(nd.addr.String(), nd)\n\t\t\trt.cachedKBuckets.Push(bucket.prefix.String(), bucket)\n\n\t\t\treturn isNew\n\t\t} else if root.KBucket().prefix.Compare(nd.id, prefixLen-1) == 0 {\n\t\t\t// If node has the same prefix with bucket, split it.\n\n\t\t\troot.Split()\n\n\t\t\trt.cachedKBuckets.Delete(root.KBucket().prefix.String())\n\t\t\troot.SetKBucket(nil)\n\n\t\t\tfor i := 0; i < 2; i++ {\n\t\t\t\tbucket = root.Child(i).KBucket()\n\t\t\t\trt.cachedKBuckets.Push(bucket.prefix.String(), bucket)\n\t\t\t}\n\n\t\t\troot = root.Child(nd.id.Bit(prefixLen - 1))\n\t\t} else {\n\t\t\t// Finally, store node as a candidate and fresh the bucket.\n\t\t\troot.KBucket().candidates.PushBack(nd)\n\t\t\tif root.KBucket().candidates.Len() > rt.k {\n\t\t\t\troot.KBucket().candidates.Remove(\n\t\t\t\t\troot.KBucket().candidates.Front())\n\t\t\t}\n\n\t\t\tgo root.KBucket().Fresh(rt.dht)\n\t\t\treturn false\n\t\t}\n\t}\n\treturn false\n}\n\n// GetNeighbors returns the size-length nodes closest to id.\nfunc (rt *routingTable) GetNeighbors(id *bitmap, size int) []*node {\n\trt.RLock()\n\tnodes := make([]interface{}, 0, rt.cachedNodes.Len())\n\tfor item := range rt.cachedNodes.Iter() {\n\t\tnodes = append(nodes, item.val.(*node))\n\t}\n\trt.RUnlock()\n\n\tneighbors := getTopK(nodes, id, size)\n\tresult := make([]*node, len(neighbors))\n\n\tfor i, nd := range neighbors {\n\t\tresult[i] = nd.(*node)\n\t}\n\treturn result\n}\n\n// GetNeighborIds return the size-length compact node info closest to id.\nfunc (rt *routingTable) GetNeighborCompactInfos(id *bitmap, size int) []string {\n\tneighbors := rt.GetNeighbors(id, size)\n\tinfos := make([]string, len(neighbors))\n\n\tfor i, no := range neighbors {\n\t\tinfos[i] = no.CompactNodeInfo()\n\t}\n\n\treturn infos\n}\n\n// GetNodeKBucktById returns node whose id is `id` and the bucket it\n// belongs to.\nfunc (rt *routingTable) GetNodeKBucktByID(id *bitmap) (\n\tnd *node, bucket *kbucket) {\n\n\trt.RLock()\n\tdefer rt.RUnlock()\n\n\tvar next *routingTableNode\n\troot := rt.root\n\n\tfor prefixLen := 1; prefixLen <= maxPrefixLength; prefixLen++ {\n\t\tnext = root.Child(id.Bit(prefixLen - 1))\n\t\tif next == nil {\n\t\t\tv, ok := root.KBucket().nodes.Get(id.RawString())\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnd, bucket = v.Value.(*node), root.KBucket()\n\t\t\treturn\n\t\t}\n\t\troot = next\n\t}\n\treturn\n}\n\n// GetNodeByAddress finds node by address.\nfunc (rt *routingTable) GetNodeByAddress(address string) (no *node, ok bool) {\n\trt.RLock()\n\tdefer rt.RUnlock()\n\n\tv, ok := rt.cachedNodes.Get(address)\n\tif ok {\n\t\tno = v.(*node)\n\t}\n\treturn\n}\n\n// Remove deletes the node whose id is `id`.\nfunc (rt *routingTable) Remove(id *bitmap) {\n\tif nd, bucket := rt.GetNodeKBucktByID(id); nd != nil {\n\t\tbucket.Replace(nd)\n\t\trt.cachedNodes.Delete(nd.addr.String())\n\t\trt.cachedKBuckets.Push(bucket.prefix.String(), bucket)\n\t}\n}\n\n// Remove deletes the node whose address is `ip:port`.\nfunc (rt *routingTable) RemoveByAddr(address string) {\n\tv, ok := rt.cachedNodes.Get(address)\n\tif ok {\n\t\trt.Remove(v.(*node).id)\n\t}\n}\n\n// Fresh sends findNode to all nodes in the expired nodes.\nfunc (rt *routingTable) Fresh() {\n\tnow := time.Now()\n\n\tfor e := range rt.cachedKBuckets.Iter() {\n\t\tbucket := e.Value.(*kbucket)\n\t\tif now.Sub(bucket.LastChanged()) < rt.dht.KBucketExpiredAfter ||\n\t\t\tbucket.nodes.Len() == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\ti := 0\n\t\tfor e := range bucket.nodes.Iter() {\n\t\t\tif i < rt.dht.RefreshNodeNum {\n\t\t\t\tno := e.Value.(*node)\n\t\t\t\trt.dht.transactionManager.findNode(no, bucket.RandomChildID())\n\t\t\t\trt.clearQueue.PushBack(no)\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\n\tif rt.dht.IsCrawlMode() {\n\t\tfor e := range rt.clearQueue.Iter() {\n\t\t\trt.Remove(e.Value.(*node).id)\n\t\t}\n\t}\n\n\trt.clearQueue.Clear()\n}\n\n// Len returns the number of nodes in table.\nfunc (rt *routingTable) Len() int {\n\trt.RLock()\n\tdefer rt.RUnlock()\n\n\treturn rt.cachedNodes.Len()\n}\n\n// Implementation of heap with heap.Interface.\ntype heapItem struct {\n\tdistance *bitmap\n\tvalue    interface{}\n}\n\ntype topKHeap []*heapItem\n\nfunc (kHeap topKHeap) Len() int {\n\treturn len(kHeap)\n}\n\nfunc (kHeap topKHeap) Less(i, j int) bool {\n\treturn kHeap[i].distance.Compare(kHeap[j].distance, maxPrefixLength) == 1\n}\n\nfunc (kHeap topKHeap) Swap(i, j int) {\n\tkHeap[i], kHeap[j] = kHeap[j], kHeap[i]\n}\n\nfunc (kHeap *topKHeap) Push(x interface{}) {\n\t*kHeap = append(*kHeap, x.(*heapItem))\n}\n\nfunc (kHeap *topKHeap) Pop() interface{} {\n\tn := len(*kHeap)\n\tx := (*kHeap)[n-1]\n\t*kHeap = (*kHeap)[:n-1]\n\treturn x\n}\n\n// getTopK solves the top-k problem with heap. It's time complexity is\n// O(n*log(k)). When n is large, time complexity will be too high, need to be\n// optimized.\nfunc getTopK(queue []interface{}, id *bitmap, k int) []interface{} {\n\ttopkHeap := make(topKHeap, 0, k+1)\n\n\tfor _, value := range queue {\n\t\tnode := value.(*node)\n\t\tdistance := id.Xor(node.id)\n\t\tif topkHeap.Len() == k {\n\t\t\tvar last = topkHeap[topkHeap.Len() - 1]\n\t\t\tif last.distance.Compare(distance, maxPrefixLength) == 1 {\n\t\t\t\titem := &heapItem{\n\t\t\t\t\tdistance,\n\t\t\t\t\tvalue,\n\t\t\t\t}\n\t\t\t\theap.Push(&topkHeap, item)\n\t\t\t\theap.Pop(&topkHeap)\n\t\t\t}\n\t\t} else {\n\t\t\titem := &heapItem{\n\t\t\t\tdistance,\n\t\t\t\tvalue,\n\t\t\t}\n\t\t\theap.Push(&topkHeap, item)\n\t\t}\n\t}\n\n\ttops := make([]interface{}, topkHeap.Len())\n\tfor i := len(tops) - 1; i >= 0; i-- {\n\t\ttops[i] = heap.Pop(&topkHeap).(*heapItem).value\n\t}\n\n\treturn tops\n}\n"
        },
        {
          "name": "sample",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 2.5498046875,
          "content": "package dht\n\nimport (\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// randomString generates a size-length string randomly.\nfunc randomString(size int) string {\n\tbuff := make([]byte, size)\n\trand.Read(buff)\n\treturn string(buff)\n}\n\n// bytes2int returns the int value it represents.\nfunc bytes2int(data []byte) uint64 {\n\tn, val := len(data), uint64(0)\n\tif n > 8 {\n\t\tpanic(\"data too long\")\n\t}\n\n\tfor i, b := range data {\n\t\tval += uint64(b) << uint64((n-i-1)*8)\n\t}\n\treturn val\n}\n\n// int2bytes returns the byte array it represents.\nfunc int2bytes(val uint64) []byte {\n\tdata, j := make([]byte, 8), -1\n\tfor i := 0; i < 8; i++ {\n\t\tshift := uint64((7 - i) * 8)\n\t\tdata[i] = byte((val & (0xff << shift)) >> shift)\n\n\t\tif j == -1 && data[i] != 0 {\n\t\t\tj = i\n\t\t}\n\t}\n\n\tif j != -1 {\n\t\treturn data[j:]\n\t}\n\treturn data[:1]\n}\n\n// decodeCompactIPPortInfo decodes compactIP-address/port info in BitTorrent\n// DHT Protocol. It returns the ip and port number.\nfunc decodeCompactIPPortInfo(info string) (ip net.IP, port int, err error) {\n\tif len(info) != 6 {\n\t\terr = errors.New(\"compact info should be 6-length long\")\n\t\treturn\n\t}\n\n\tip = net.IPv4(info[0], info[1], info[2], info[3])\n\tport = int((uint16(info[4]) << 8) | uint16(info[5]))\n\treturn\n}\n\n// encodeCompactIPPortInfo encodes an ip and a port number to\n// compactIP-address/port info.\nfunc encodeCompactIPPortInfo(ip net.IP, port int) (info string, err error) {\n\tif port > 65535 || port < 0 {\n\t\terr = errors.New(\n\t\t\t\"port should be no greater than 65535 and no less than 0\")\n\t\treturn\n\t}\n\n\tp := int2bytes(uint64(port))\n\tif len(p) < 2 {\n\t\tp = append(p, p[0])\n\t\tp[0] = 0\n\t}\n\n\tinfo = string(append(ip, p...))\n\treturn\n}\n\n// getLocalIPs returns local ips.\nfunc getLocalIPs() (ips []string) {\n\tips = make([]string, 0, 6)\n\n\taddrs, err := net.InterfaceAddrs()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfor _, addr := range addrs {\n\t\tip, _, err := net.ParseCIDR(addr.String())\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tips = append(ips, ip.String())\n\t}\n\treturn\n}\n\n// getRemoteIP returns the wlan ip.\nfunc getRemoteIP() (ip string, err error) {\n\tclient := &http.Client{\n\t\tTimeout: time.Second * 30,\n\t}\n\n\treq, err := http.NewRequest(\"GET\", \"http://ifconfig.me\", nil)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treq.Header.Set(\"User-Agent\", \"curl\")\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer res.Body.Close()\n\n\tdata, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn\n\t}\n\tip = string(data)\n\n\treturn\n}\n\n// genAddress returns a ip:port address.\nfunc genAddress(ip string, port int) string {\n\treturn strings.Join([]string{ip, strconv.Itoa(port)}, \":\")\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 1.53515625,
          "content": "package dht\n\nimport (\n\t\"testing\"\n)\n\nfunc TestInt2Bytes(t *testing.T) {\n\tcases := []struct {\n\t\tin  uint64\n\t\tout []byte\n\t}{\n\t\t{0, []byte{0}},\n\t\t{1, []byte{1}},\n\t\t{256, []byte{1, 0}},\n\t\t{22129, []byte{86, 113}},\n\t}\n\n\tfor _, c := range cases {\n\t\tr := int2bytes(c.in)\n\t\tif len(r) != len(c.out) {\n\t\t\tt.Fail()\n\t\t}\n\n\t\tfor i, v := range r {\n\t\t\tif v != c.out[i] {\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBytes2Int(t *testing.T) {\n\tcases := []struct {\n\t\tin  []byte\n\t\tout uint64\n\t}{\n\t\t{[]byte{0}, 0},\n\t\t{[]byte{1}, 1},\n\t\t{[]byte{1, 0}, 256},\n\t\t{[]byte{86, 113}, 22129},\n\t}\n\n\tfor _, c := range cases {\n\t\tif bytes2int(c.in) != c.out {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n\nfunc TestDecodeCompactIPPortInfo(t *testing.T) {\n\tcases := []struct {\n\t\tin  string\n\t\tout struct {\n\t\t\tip   string\n\t\t\tport int\n\t\t}\n\t}{\n\t\t{\"123456\", struct {\n\t\t\tip   string\n\t\t\tport int\n\t\t}{\"49.50.51.52\", 13622}},\n\t\t{\"abcdef\", struct {\n\t\t\tip   string\n\t\t\tport int\n\t\t}{\"97.98.99.100\", 25958}},\n\t}\n\n\tfor _, item := range cases {\n\t\tip, port, err := decodeCompactIPPortInfo(item.in)\n\t\tif err != nil || ip.String() != item.out.ip || port != item.out.port {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n\nfunc TestEncodeCompactIPPortInfo(t *testing.T) {\n\tcases := []struct {\n\t\tin struct {\n\t\t\tip   []byte\n\t\t\tport int\n\t\t}\n\t\tout string\n\t}{\n\t\t{struct {\n\t\t\tip   []byte\n\t\t\tport int\n\t\t}{[]byte{49, 50, 51, 52}, 13622}, \"123456\"},\n\t\t{struct {\n\t\t\tip   []byte\n\t\t\tport int\n\t\t}{[]byte{97, 98, 99, 100}, 25958}, \"abcdef\"},\n\t}\n\n\tfor _, item := range cases {\n\t\tinfo, err := encodeCompactIPPortInfo(item.in.ip, item.in.port)\n\t\tif err != nil || info != item.out {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}