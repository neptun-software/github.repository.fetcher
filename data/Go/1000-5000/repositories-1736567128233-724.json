{
  "metadata": {
    "timestamp": 1736567128233,
    "page": 724,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjczMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jessevdk/go-flags",
      "stars": 2610,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4794921875,
          "content": "Copyright (c) 2012 Jesse van den Kieboom. All rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\n     copyright notice, this list of conditions and the following disclaimer\n     in the documentation and/or other materials provided with the\n     distribution.\n   * Neither the name of Google Inc. nor the names of its\n     contributors may be used to endorse or promote products derived from\n     this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.912109375,
          "content": "go-flags: a go library for parsing command line arguments\n=========================================================\n\n[![GoDoc](https://godoc.org/github.com/jessevdk/go-flags?status.png)](https://godoc.org/github.com/jessevdk/go-flags)\n\nThis library provides similar functionality to the builtin flag library of\ngo, but provides much more functionality and nicer formatting. From the\ndocumentation:\n\nPackage flags provides an extensive command line option parser.\nThe flags package is similar in functionality to the go builtin flag package\nbut provides more options and uses reflection to provide a convenient and\nsuccinct way of specifying command line options.\n\nSupported features:\n* Options with short names (-v)\n* Options with long names (--verbose)\n* Options with and without arguments (bool v.s. other type)\n* Options with optional arguments and default values\n* Multiple option groups each containing a set of options\n* Generate and print well-formatted help message\n* Passing remaining command line arguments after -- (optional)\n* Ignoring unknown command line options (optional)\n* Supports -I/usr/include -I=/usr/include -I /usr/include option argument specification\n* Supports multiple short options -aux\n* Supports all primitive go types (string, int{8..64}, uint{8..64}, float)\n* Supports same option multiple times (can store in slice or last option counts)\n* Supports maps\n* Supports function callbacks\n* Supports namespaces for (nested) option groups\n\nThe flags package uses structs, reflection and struct field tags\nto allow users to specify command line options. This results in very simple\nand concise specification of your application options. For example:\n\n```go\ntype Options struct {\n\tVerbose []bool `short:\"v\" long:\"verbose\" description:\"Show verbose debug information\"`\n}\n```\n\nThis specifies one option with a short name -v and a long name --verbose.\nWhen either -v or --verbose is found on the command line, a 'true' value\nwill be appended to the Verbose field. e.g. when specifying -vvv, the\nresulting value of Verbose will be {[true, true, true]}.\n\nExample:\n--------\n```go\nvar opts struct {\n\t// Slice of bool will append 'true' each time the option\n\t// is encountered (can be set multiple times, like -vvv)\n\tVerbose []bool `short:\"v\" long:\"verbose\" description:\"Show verbose debug information\"`\n\n\t// Example of automatic marshalling to desired type (uint)\n\tOffset uint `long:\"offset\" description:\"Offset\"`\n\n\t// Example of a callback, called each time the option is found.\n\tCall func(string) `short:\"c\" description:\"Call phone number\"`\n\n\t// Example of a required flag\n\tName string `short:\"n\" long:\"name\" description:\"A name\" required:\"true\"`\n\n\t// Example of a flag restricted to a pre-defined set of strings\n\tAnimal string `long:\"animal\" choice:\"cat\" choice:\"dog\"`\n\n\t// Example of a value name\n\tFile string `short:\"f\" long:\"file\" description:\"A file\" value-name:\"FILE\"`\n\n\t// Example of a pointer\n\tPtr *int `short:\"p\" description:\"A pointer to an integer\"`\n\n\t// Example of a slice of strings\n\tStringSlice []string `short:\"s\" description:\"A slice of strings\"`\n\n\t// Example of a slice of pointers\n\tPtrSlice []*string `long:\"ptrslice\" description:\"A slice of pointers to string\"`\n\n\t// Example of a map\n\tIntMap map[string]int `long:\"intmap\" description:\"A map from string to int\"`\n\n\t// Example of env variable\n\tThresholds  []int     `long:\"thresholds\" default:\"1\" default:\"2\" env:\"THRESHOLD_VALUES\"  env-delim:\",\"`\n}\n\n// Callback which will invoke callto:<argument> to call a number.\n// Note that this works just on OS X (and probably only with\n// Skype) but it shows the idea.\nopts.Call = func(num string) {\n\tcmd := exec.Command(\"open\", \"callto:\"+num)\n\tcmd.Start()\n\tcmd.Process.Release()\n}\n\n// Make some fake arguments to parse.\nargs := []string{\n\t\"-vv\",\n\t\"--offset=5\",\n\t\"-n\", \"Me\",\n\t\"--animal\", \"dog\", // anything other than \"cat\" or \"dog\" will raise an error\n\t\"-p\", \"3\",\n\t\"-s\", \"hello\",\n\t\"-s\", \"world\",\n\t\"--ptrslice\", \"hello\",\n\t\"--ptrslice\", \"world\",\n\t\"--intmap\", \"a:1\",\n\t\"--intmap\", \"b:5\",\n\t\"arg1\",\n\t\"arg2\",\n\t\"arg3\",\n}\n\n// Parse flags from `args'. Note that here we use flags.ParseArgs for\n// the sake of making a working example. Normally, you would simply use\n// flags.Parse(&opts) which uses os.Args\nargs, err := flags.ParseArgs(&opts, args)\n\nif err != nil {\n\tpanic(err)\n}\n\nfmt.Printf(\"Verbosity: %v\\n\", opts.Verbose)\nfmt.Printf(\"Offset: %d\\n\", opts.Offset)\nfmt.Printf(\"Name: %s\\n\", opts.Name)\nfmt.Printf(\"Animal: %s\\n\", opts.Animal)\nfmt.Printf(\"Ptr: %d\\n\", *opts.Ptr)\nfmt.Printf(\"StringSlice: %v\\n\", opts.StringSlice)\nfmt.Printf(\"PtrSlice: [%v %v]\\n\", *opts.PtrSlice[0], *opts.PtrSlice[1])\nfmt.Printf(\"IntMap: [a:%v b:%v]\\n\", opts.IntMap[\"a\"], opts.IntMap[\"b\"])\nfmt.Printf(\"Remaining args: %s\\n\", strings.Join(args, \" \"))\n\n// Output: Verbosity: [true true]\n// Offset: 5\n// Name: Me\n// Ptr: 3\n// StringSlice: [hello world]\n// PtrSlice: [hello world]\n// IntMap: [a:1 b:5]\n// Remaining args: arg1 arg2 arg3\n```\n\nMore information can be found in the godocs: <http://godoc.org/github.com/jessevdk/go-flags>\n"
        },
        {
          "name": "arg.go",
          "type": "blob",
          "size": 0.53515625,
          "content": "package flags\n\nimport (\n\t\"reflect\"\n)\n\n// Arg represents a positional argument on the command line.\ntype Arg struct {\n\t// The name of the positional argument (used in the help)\n\tName string\n\n\t// A description of the positional argument (used in the help)\n\tDescription string\n\n\t// The minimal number of required positional arguments\n\tRequired int\n\n\t// The maximum number of required positional arguments\n\tRequiredMaximum int\n\n\tvalue reflect.Value\n\ttag   multiTag\n}\n\nfunc (a *Arg) isRemaining() bool {\n\treturn a.value.Type().Kind() == reflect.Slice\n}\n"
        },
        {
          "name": "arg_test.go",
          "type": "blob",
          "size": 3.7080078125,
          "content": "package flags\n\nimport (\n\t\"testing\"\n)\n\nfunc TestPositional(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tCommand  int\n\t\t\tFilename string\n\t\t\tRest     []string\n\t\t} `positional-args:\"yes\" required:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, Default)\n\tret, err := p.ParseArgs([]string{\"10\", \"arg_test.go\", \"a\", \"b\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif opts.Positional.Command != 10 {\n\t\tt.Fatalf(\"Expected opts.Positional.Command to be 10, but got %v\", opts.Positional.Command)\n\t}\n\n\tif opts.Positional.Filename != \"arg_test.go\" {\n\t\tt.Fatalf(\"Expected opts.Positional.Filename to be \\\"arg_test.go\\\", but got %v\", opts.Positional.Filename)\n\t}\n\n\tassertStringArray(t, opts.Positional.Rest, []string{\"a\", \"b\"})\n\tassertStringArray(t, ret, []string{})\n}\n\nfunc TestPositionalRequired(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tCommand  int\n\t\t\tFilename string\n\t\t\tRest     []string\n\t\t} `positional-args:\"yes\" required:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\t_, err := p.ParseArgs([]string{\"10\"})\n\n\tassertError(t, err, ErrRequired, \"the required argument `Filename` was not provided\")\n}\n\nfunc TestPositionalRequiredRest1Fail(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tRest []string `required:\"yes\"`\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\t_, err := p.ParseArgs([]string{})\n\n\tassertError(t, err, ErrRequired, \"the required argument `Rest (at least 1 argument)` was not provided\")\n}\n\nfunc TestPositionalRequiredRest1Pass(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tRest []string `required:\"yes\"`\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\t_, err := p.ParseArgs([]string{\"rest1\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif len(opts.Positional.Rest) != 1 {\n\t\tt.Fatalf(\"Expected 1 positional rest argument\")\n\t}\n\n\tassertString(t, opts.Positional.Rest[0], \"rest1\")\n}\n\nfunc TestPositionalRequiredRest2Fail(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tRest []string `required:\"2\"`\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\t_, err := p.ParseArgs([]string{\"rest1\"})\n\n\tassertError(t, err, ErrRequired, \"the required argument `Rest (at least 2 arguments, but got only 1)` was not provided\")\n}\n\nfunc TestPositionalRequiredRest2Pass(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tRest []string `required:\"2\"`\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\t_, err := p.ParseArgs([]string{\"rest1\", \"rest2\", \"rest3\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif len(opts.Positional.Rest) != 3 {\n\t\tt.Fatalf(\"Expected 3 positional rest argument\")\n\t}\n\n\tassertString(t, opts.Positional.Rest[0], \"rest1\")\n\tassertString(t, opts.Positional.Rest[1], \"rest2\")\n\tassertString(t, opts.Positional.Rest[2], \"rest3\")\n}\n\nfunc TestPositionalRequiredRestRangeFail(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tRest []string `required:\"1-2\"`\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\t_, err := p.ParseArgs([]string{\"rest1\", \"rest2\", \"rest3\"})\n\n\tassertError(t, err, ErrRequired, \"the required argument `Rest (at most 2 arguments, but got 3)` was not provided\")\n}\n\nfunc TestPositionalRequiredRestRangeEmptyFail(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tRest []string `required:\"0-0\"`\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\t_, err := p.ParseArgs([]string{\"some\", \"thing\"})\n\n\tassertError(t, err, ErrRequired, \"the required argument `Rest (zero arguments)` was not provided\")\n}\n"
        },
        {
          "name": "assert_test.go",
          "type": "blob",
          "size": 2.9296875,
          "content": "package flags\n\nimport (\n\t\"fmt\"\n\t\"path\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/sergi/go-diff/diffmatchpatch\"\n)\n\nfunc assertCallerInfo() (string, int) {\n\tptr := make([]uintptr, 15)\n\tn := runtime.Callers(1, ptr)\n\n\tif n == 0 {\n\t\treturn \"\", 0\n\t}\n\n\tmef := runtime.FuncForPC(ptr[0])\n\tmefile, meline := mef.FileLine(ptr[0])\n\n\tfor i := 2; i < n; i++ {\n\t\tf := runtime.FuncForPC(ptr[i])\n\t\tfile, line := f.FileLine(ptr[i])\n\n\t\tif file != mefile {\n\t\t\treturn file, line\n\t\t}\n\t}\n\n\treturn mefile, meline\n}\n\nfunc assertErrorf(t *testing.T, format string, args ...interface{}) {\n\tmsg := fmt.Sprintf(format, args...)\n\n\tfile, line := assertCallerInfo()\n\n\tt.Errorf(\"%s:%d: %s\", path.Base(file), line, msg)\n}\n\nfunc assertFatalf(t *testing.T, format string, args ...interface{}) {\n\tmsg := fmt.Sprintf(format, args...)\n\n\tfile, line := assertCallerInfo()\n\n\tt.Fatalf(\"%s:%d: %s\", path.Base(file), line, msg)\n}\n\nfunc assertString(t *testing.T, a string, b string) {\n\tif a != b {\n\t\tassertErrorf(t, \"Expected %#v, but got %#v\", b, a)\n\t}\n}\n\nfunc assertStringArray(t *testing.T, a []string, b []string) {\n\tif len(a) != len(b) {\n\t\tassertErrorf(t, \"Expected %#v, but got %#v\", b, a)\n\t\treturn\n\t}\n\n\tfor i, v := range a {\n\t\tif b[i] != v {\n\t\t\tassertErrorf(t, \"Expected %#v, but got %#v\", b, a)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc assertBoolArray(t *testing.T, a []bool, b []bool) {\n\tif len(a) != len(b) {\n\t\tassertErrorf(t, \"Expected %#v, but got %#v\", b, a)\n\t\treturn\n\t}\n\n\tfor i, v := range a {\n\t\tif b[i] != v {\n\t\t\tassertErrorf(t, \"Expected %#v, but got %#v\", b, a)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc assertParserSuccess(t *testing.T, data interface{}, args ...string) (*Parser, []string) {\n\tparser := NewParser(data, Default&^PrintErrors)\n\tret, err := parser.ParseArgs(args)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error: %s\", err)\n\t\treturn nil, nil\n\t}\n\n\treturn parser, ret\n}\n\nfunc assertParseSuccess(t *testing.T, data interface{}, args ...string) []string {\n\t_, ret := assertParserSuccess(t, data, args...)\n\treturn ret\n}\n\nfunc assertError(t *testing.T, err error, typ ErrorType, msg string) {\n\tif err == nil {\n\t\tassertFatalf(t, \"Expected error: \\\"%s\\\", but no error occurred\", msg)\n\t\treturn\n\t}\n\n\tif e, ok := err.(*Error); !ok {\n\t\tassertFatalf(t, \"Expected Error type, but got %#v\", err)\n\t} else {\n\t\tif e.Type != typ {\n\t\t\tassertErrorf(t, \"Expected error type {%s}, but got {%s}\", typ, e.Type)\n\t\t}\n\n\t\tif e.Message != msg {\n\t\t\tassertErrorf(t, \"Expected error message %#v, but got %#v\", msg, e.Message)\n\t\t}\n\t}\n}\n\nfunc assertParseFail(t *testing.T, typ ErrorType, msg string, data interface{}, args ...string) []string {\n\tparser := NewParser(data, Default&^PrintErrors)\n\tret, err := parser.ParseArgs(args)\n\n\tassertError(t, err, typ, msg)\n\treturn ret\n}\n\nfunc assertDiff(t *testing.T, actual, expected, msg string) {\n\tif actual == expected {\n\t\treturn\n\t}\n\n\tdmp := diffmatchpatch.New()\n\tdiffs := dmp.DiffMain(actual, expected, false)\n\n\tif len(diffs) == 0 {\n\t\treturn\n\t}\n\n\tpretty := dmp.DiffPrettyText(diffs)\n\tassertErrorf(t, \"Unexpected %s:\\n\\n%s\", msg, pretty)\n}\n"
        },
        {
          "name": "check_crosscompile.sh",
          "type": "blob",
          "size": 0.4501953125,
          "content": "#!/bin/bash\n\nset -e\n\necho '# linux arm7'\nGOARM=7 GOARCH=arm GOOS=linux go build\necho '# linux arm5'\nGOARM=5 GOARCH=arm GOOS=linux go build\necho '# windows 386'\nGOARCH=386 GOOS=windows go build\necho '# windows amd64'\nGOARCH=amd64 GOOS=windows go build\necho '# darwin'\nGOARCH=amd64 GOOS=darwin go build\necho '# freebsd'\nGOARCH=amd64 GOOS=freebsd go build\necho '# aix ppc64'\nGOARCH=ppc64 GOOS=aix go build\necho '# solaris amd64'\nGOARCH=amd64 GOOS=solaris go build\n"
        },
        {
          "name": "closest.go",
          "type": "blob",
          "size": 0.9404296875,
          "content": "package flags\n\nfunc levenshtein(s string, t string) int {\n\tif len(s) == 0 {\n\t\treturn len(t)\n\t}\n\n\tif len(t) == 0 {\n\t\treturn len(s)\n\t}\n\n\tdists := make([][]int, len(s)+1)\n\tfor i := range dists {\n\t\tdists[i] = make([]int, len(t)+1)\n\t\tdists[i][0] = i\n\t}\n\n\tfor j := range t {\n\t\tdists[0][j] = j\n\t}\n\n\tfor i, sc := range s {\n\t\tfor j, tc := range t {\n\t\t\tif sc == tc {\n\t\t\t\tdists[i+1][j+1] = dists[i][j]\n\t\t\t} else {\n\t\t\t\tdists[i+1][j+1] = dists[i][j] + 1\n\t\t\t\tif dists[i+1][j] < dists[i+1][j+1] {\n\t\t\t\t\tdists[i+1][j+1] = dists[i+1][j] + 1\n\t\t\t\t}\n\t\t\t\tif dists[i][j+1] < dists[i+1][j+1] {\n\t\t\t\t\tdists[i+1][j+1] = dists[i][j+1] + 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dists[len(s)][len(t)]\n}\n\nfunc closestChoice(cmd string, choices []string) (string, int) {\n\tif len(choices) == 0 {\n\t\treturn \"\", 0\n\t}\n\n\tmincmd := -1\n\tmindist := -1\n\n\tfor i, c := range choices {\n\t\tl := levenshtein(cmd, c)\n\n\t\tif mincmd < 0 || l < mindist {\n\t\t\tmindist = l\n\t\t\tmincmd = i\n\t\t}\n\t}\n\n\treturn choices[mincmd], mindist\n}\n"
        },
        {
          "name": "command.go",
          "type": "blob",
          "size": 10.4150390625,
          "content": "package flags\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Command represents an application command. Commands can be added to the\n// parser (which itself is a command) and are selected/executed when its name\n// is specified on the command line. The Command type embeds a Group and\n// therefore also carries a set of command specific options.\ntype Command struct {\n\t// Embedded, see Group for more information\n\t*Group\n\n\t// The name by which the command can be invoked\n\tName string\n\n\t// The active sub command (set by parsing) or nil\n\tActive *Command\n\n\t// Whether subcommands are optional\n\tSubcommandsOptional bool\n\n\t// Aliases for the command\n\tAliases []string\n\n\t// Whether positional arguments are required\n\tArgsRequired bool\n\n\t// Whether to pass all arguments after the first non option as remaining\n\t// command line arguments. This is equivalent to strict POSIX processing.\n\t// This is command-local version of PassAfterNonOption Parser flag. It\n\t// cannot be turned off when PassAfterNonOption Parser flag is set.\n\tPassAfterNonOption bool\n\n\tcommands            []*Command\n\thasBuiltinHelpGroup bool\n\targs                []*Arg\n}\n\n// Commander is an interface which can be implemented by any command added in\n// the options. When implemented, the Execute method will be called for the last\n// specified (sub)command providing the remaining command line arguments.\ntype Commander interface {\n\t// Execute will be called for the last active (sub)command. The\n\t// args argument contains the remaining command line arguments. The\n\t// error that Execute returns will be eventually passed out of the\n\t// Parse method of the Parser.\n\tExecute(args []string) error\n}\n\n// Usage is an interface which can be implemented to show a custom usage string\n// in the help message shown for a command.\ntype Usage interface {\n\t// Usage is called for commands to allow customized printing of command\n\t// usage in the generated help message.\n\tUsage() string\n}\n\ntype lookup struct {\n\tshortNames map[string]*Option\n\tlongNames  map[string]*Option\n\n\tcommands map[string]*Command\n}\n\n// AddCommand adds a new command to the parser with the given name and data. The\n// data needs to be a pointer to a struct from which the fields indicate which\n// options are in the command. The provided data can implement the Command and\n// Usage interfaces.\nfunc (c *Command) AddCommand(command string, shortDescription string, longDescription string, data interface{}) (*Command, error) {\n\tcmd := newCommand(command, shortDescription, longDescription, data)\n\n\tcmd.parent = c\n\n\tif err := cmd.scan(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.commands = append(c.commands, cmd)\n\treturn cmd, nil\n}\n\n// AddGroup adds a new group to the command with the given name and data. The\n// data needs to be a pointer to a struct from which the fields indicate which\n// options are in the group.\nfunc (c *Command) AddGroup(shortDescription string, longDescription string, data interface{}) (*Group, error) {\n\tgroup := newGroup(shortDescription, longDescription, data)\n\n\tgroup.parent = c\n\n\tif err := group.scanType(c.scanSubcommandHandler(group)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.groups = append(c.groups, group)\n\treturn group, nil\n}\n\n// Commands returns a list of subcommands of this command.\nfunc (c *Command) Commands() []*Command {\n\treturn c.commands\n}\n\n// Find locates the subcommand with the given name and returns it. If no such\n// command can be found Find will return nil.\nfunc (c *Command) Find(name string) *Command {\n\tfor _, cc := range c.commands {\n\t\tif cc.match(name) {\n\t\t\treturn cc\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// FindOptionByLongName finds an option that is part of the command, or any of\n// its parent commands, by matching its long name (including the option\n// namespace).\nfunc (c *Command) FindOptionByLongName(longName string) (option *Option) {\n\tfor option == nil && c != nil {\n\t\toption = c.Group.FindOptionByLongName(longName)\n\n\t\tc, _ = c.parent.(*Command)\n\t}\n\n\treturn option\n}\n\n// FindOptionByShortName finds an option that is part of the command, or any of\n// its parent commands, by matching its long name (including the option\n// namespace).\nfunc (c *Command) FindOptionByShortName(shortName rune) (option *Option) {\n\tfor option == nil && c != nil {\n\t\toption = c.Group.FindOptionByShortName(shortName)\n\n\t\tc, _ = c.parent.(*Command)\n\t}\n\n\treturn option\n}\n\n// Args returns a list of positional arguments associated with this command.\nfunc (c *Command) Args() []*Arg {\n\tret := make([]*Arg, len(c.args))\n\tcopy(ret, c.args)\n\n\treturn ret\n}\n\nfunc newCommand(name string, shortDescription string, longDescription string, data interface{}) *Command {\n\treturn &Command{\n\t\tGroup: newGroup(shortDescription, longDescription, data),\n\t\tName:  name,\n\t}\n}\n\nfunc (c *Command) scanSubcommandHandler(parentg *Group) scanHandler {\n\tf := func(realval reflect.Value, sfield *reflect.StructField) (bool, error) {\n\t\tmtag := newMultiTag(string(sfield.Tag))\n\n\t\tif err := mtag.Parse(); err != nil {\n\t\t\treturn true, err\n\t\t}\n\n\t\tpositional := mtag.Get(\"positional-args\")\n\n\t\tif len(positional) != 0 {\n\t\t\tstype := realval.Type()\n\n\t\t\tfor i := 0; i < stype.NumField(); i++ {\n\t\t\t\tfield := stype.Field(i)\n\n\t\t\t\tm := newMultiTag((string(field.Tag)))\n\n\t\t\t\tif err := m.Parse(); err != nil {\n\t\t\t\t\treturn true, err\n\t\t\t\t}\n\n\t\t\t\tname := m.Get(\"positional-arg-name\")\n\n\t\t\t\tif len(name) == 0 {\n\t\t\t\t\tname = field.Name\n\t\t\t\t}\n\n\t\t\t\trequired := -1\n\t\t\t\trequiredMaximum := -1\n\n\t\t\t\tsreq := m.Get(\"required\")\n\n\t\t\t\tif sreq != \"\" {\n\t\t\t\t\trequired = 1\n\n\t\t\t\t\trng := strings.SplitN(sreq, \"-\", 2)\n\n\t\t\t\t\tif len(rng) > 1 {\n\t\t\t\t\t\tif preq, err := strconv.ParseInt(rng[0], 10, 32); err == nil {\n\t\t\t\t\t\t\trequired = int(preq)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif preq, err := strconv.ParseInt(rng[1], 10, 32); err == nil {\n\t\t\t\t\t\t\trequiredMaximum = int(preq)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif preq, err := strconv.ParseInt(sreq, 10, 32); err == nil {\n\t\t\t\t\t\t\trequired = int(preq)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\targ := &Arg{\n\t\t\t\t\tName:            name,\n\t\t\t\t\tDescription:     m.Get(\"description\"),\n\t\t\t\t\tRequired:        required,\n\t\t\t\t\tRequiredMaximum: requiredMaximum,\n\n\t\t\t\t\tvalue: realval.Field(i),\n\t\t\t\t\ttag:   m,\n\t\t\t\t}\n\n\t\t\t\tc.args = append(c.args, arg)\n\n\t\t\t\tif len(mtag.Get(\"required\")) != 0 {\n\t\t\t\t\tc.ArgsRequired = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true, nil\n\t\t}\n\n\t\tsubcommand := mtag.Get(\"command\")\n\n\t\tif len(subcommand) != 0 {\n\t\t\tvar ptrval reflect.Value\n\n\t\t\tif realval.Kind() == reflect.Ptr {\n\t\t\t\tptrval = realval\n\n\t\t\t\tif ptrval.IsNil() {\n\t\t\t\t\tptrval.Set(reflect.New(ptrval.Type().Elem()))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tptrval = realval.Addr()\n\t\t\t}\n\n\t\t\tshortDescription := mtag.Get(\"description\")\n\t\t\tlongDescription := mtag.Get(\"long-description\")\n\t\t\tsubcommandsOptional := mtag.Get(\"subcommands-optional\")\n\t\t\taliases := mtag.GetMany(\"alias\")\n\t\t\tpassAfterNonOption := mtag.Get(\"pass-after-non-option\")\n\n\t\t\tsubc, err := c.AddCommand(subcommand, shortDescription, longDescription, ptrval.Interface())\n\n\t\t\tif err != nil {\n\t\t\t\treturn true, err\n\t\t\t}\n\n\t\t\tsubc.Hidden = mtag.Get(\"hidden\") != \"\"\n\n\t\t\tif len(subcommandsOptional) > 0 {\n\t\t\t\tsubc.SubcommandsOptional = true\n\t\t\t}\n\n\t\t\tif len(aliases) > 0 {\n\t\t\t\tsubc.Aliases = aliases\n\t\t\t}\n\n\t\t\tif len(passAfterNonOption) > 0 {\n\t\t\t\tsubc.PassAfterNonOption = true\n\t\t\t}\n\n\t\t\treturn true, nil\n\t\t}\n\n\t\treturn parentg.scanSubGroupHandler(realval, sfield)\n\t}\n\n\treturn f\n}\n\nfunc (c *Command) scan() error {\n\treturn c.scanType(c.scanSubcommandHandler(c.Group))\n}\n\nfunc (c *Command) eachOption(f func(*Command, *Group, *Option)) {\n\tc.eachCommand(func(c *Command) {\n\t\tc.eachGroup(func(g *Group) {\n\t\t\tfor _, option := range g.options {\n\t\t\t\tf(c, g, option)\n\t\t\t}\n\t\t})\n\t}, true)\n}\n\nfunc (c *Command) eachCommand(f func(*Command), recurse bool) {\n\tf(c)\n\n\tfor _, cc := range c.commands {\n\t\tif recurse {\n\t\t\tcc.eachCommand(f, true)\n\t\t} else {\n\t\t\tf(cc)\n\t\t}\n\t}\n}\n\nfunc (c *Command) eachActiveGroup(f func(cc *Command, g *Group)) {\n\tc.eachGroup(func(g *Group) {\n\t\tf(c, g)\n\t})\n\n\tif c.Active != nil {\n\t\tc.Active.eachActiveGroup(f)\n\t}\n}\n\nfunc (c *Command) addHelpGroups(showHelp func() error) {\n\tif !c.hasBuiltinHelpGroup {\n\t\tc.addHelpGroup(showHelp)\n\t\tc.hasBuiltinHelpGroup = true\n\t}\n\n\tfor _, cc := range c.commands {\n\t\tcc.addHelpGroups(showHelp)\n\t}\n}\n\nfunc (c *Command) makeLookup() lookup {\n\tret := lookup{\n\t\tshortNames: make(map[string]*Option),\n\t\tlongNames:  make(map[string]*Option),\n\t\tcommands:   make(map[string]*Command),\n\t}\n\n\tparent := c.parent\n\n\tvar parents []*Command\n\n\tfor parent != nil {\n\t\tif cmd, ok := parent.(*Command); ok {\n\t\t\tparents = append(parents, cmd)\n\t\t\tparent = cmd.parent\n\t\t} else {\n\t\t\tparent = nil\n\t\t}\n\t}\n\n\tfor i := len(parents) - 1; i >= 0; i-- {\n\t\tparents[i].fillLookup(&ret, true)\n\t}\n\n\tc.fillLookup(&ret, false)\n\treturn ret\n}\n\nfunc (c *Command) fillLookup(ret *lookup, onlyOptions bool) {\n\tc.eachGroup(func(g *Group) {\n\t\tfor _, option := range g.options {\n\t\t\tif option.ShortName != 0 {\n\t\t\t\tret.shortNames[string(option.ShortName)] = option\n\t\t\t}\n\n\t\t\tif len(option.LongName) > 0 {\n\t\t\t\tret.longNames[option.LongNameWithNamespace()] = option\n\t\t\t}\n\t\t}\n\t})\n\n\tif onlyOptions {\n\t\treturn\n\t}\n\n\tfor _, subcommand := range c.commands {\n\t\tret.commands[subcommand.Name] = subcommand\n\n\t\tfor _, a := range subcommand.Aliases {\n\t\t\tret.commands[a] = subcommand\n\t\t}\n\t}\n}\n\nfunc (c *Command) groupByName(name string) *Group {\n\tif grp := c.Group.groupByName(name); grp != nil {\n\t\treturn grp\n\t}\n\n\tfor _, subc := range c.commands {\n\t\tprefix := subc.Name + \".\"\n\n\t\tif strings.HasPrefix(name, prefix) {\n\t\t\tif grp := subc.groupByName(name[len(prefix):]); grp != nil {\n\t\t\t\treturn grp\n\t\t\t}\n\t\t} else if name == subc.Name {\n\t\t\treturn subc.Group\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype commandList []*Command\n\nfunc (c commandList) Less(i, j int) bool {\n\treturn c[i].Name < c[j].Name\n}\n\nfunc (c commandList) Len() int {\n\treturn len(c)\n}\n\nfunc (c commandList) Swap(i, j int) {\n\tc[i], c[j] = c[j], c[i]\n}\n\nfunc (c *Command) sortedVisibleCommands() []*Command {\n\tret := commandList(c.visibleCommands())\n\tsort.Sort(ret)\n\n\treturn []*Command(ret)\n}\n\nfunc (c *Command) visibleCommands() []*Command {\n\tret := make([]*Command, 0, len(c.commands))\n\n\tfor _, cmd := range c.commands {\n\t\tif !cmd.Hidden {\n\t\t\tret = append(ret, cmd)\n\t\t}\n\t}\n\n\treturn ret\n}\n\nfunc (c *Command) match(name string) bool {\n\tif c.Name == name {\n\t\treturn true\n\t}\n\n\tfor _, v := range c.Aliases {\n\t\tif v == name {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (c *Command) hasHelpOptions() bool {\n\tret := false\n\n\tc.eachGroup(func(g *Group) {\n\t\tif g.isBuiltinHelp {\n\t\t\treturn\n\t\t}\n\n\t\tfor _, opt := range g.options {\n\t\t\tif opt.showInHelp() {\n\t\t\t\tret = true\n\t\t\t}\n\t\t}\n\t})\n\n\treturn ret\n}\n\nfunc (c *Command) fillParseState(s *parseState) {\n\ts.positional = make([]*Arg, len(c.args))\n\tcopy(s.positional, c.args)\n\n\ts.lookup = c.makeLookup()\n\ts.command = c\n}\n"
        },
        {
          "name": "command_test.go",
          "type": "blob",
          "size": 15.12109375,
          "content": "package flags\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestCommandInline(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand struct {\n\t\t\tG bool `short:\"g\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tp, ret := assertParserSuccess(t, &opts, \"-v\", \"cmd\", \"-g\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif p.Active == nil {\n\t\tt.Errorf(\"Expected active command\")\n\t}\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.Command.G {\n\t\tt.Errorf(\"Expected Command.G to be true\")\n\t}\n\n\tif p.Command.Find(\"cmd\") != p.Active {\n\t\tt.Errorf(\"Expected to find command `cmd' to be active\")\n\t}\n}\n\nfunc TestCommandInlineMulti(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tC1 struct {\n\t\t} `command:\"c1\"`\n\n\t\tC2 struct {\n\t\t\tG bool `short:\"g\"`\n\t\t} `command:\"c2\"`\n\t}{}\n\n\tp, ret := assertParserSuccess(t, &opts, \"-v\", \"c2\", \"-g\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif p.Active == nil {\n\t\tt.Errorf(\"Expected active command\")\n\t}\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.C2.G {\n\t\tt.Errorf(\"Expected C2.G to be true\")\n\t}\n\n\tif p.Command.Find(\"c1\") == nil {\n\t\tt.Errorf(\"Expected to find command `c1'\")\n\t}\n\n\tif c2 := p.Command.Find(\"c2\"); c2 == nil {\n\t\tt.Errorf(\"Expected to find command `c2'\")\n\t} else if c2 != p.Active {\n\t\tt.Errorf(\"Expected to find command `c2' to be active\")\n\t}\n}\n\nfunc TestCommandFlagOrder1(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand struct {\n\t\t\tG bool `short:\"g\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseFail(t, ErrUnknownFlag, \"unknown flag `g'\", &opts, \"-v\", \"-g\", \"cmd\")\n}\n\nfunc TestCommandFlagOrder2(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand struct {\n\t\t\tG bool `short:\"g\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts, \"cmd\", \"-v\", \"-g\")\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.Command.G {\n\t\tt.Errorf(\"Expected Command.G to be true\")\n\t}\n}\n\nfunc TestCommandFlagOrderSub(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand struct {\n\t\t\tG bool `short:\"g\"`\n\n\t\t\tSubCommand struct {\n\t\t\t\tB bool `short:\"b\"`\n\t\t\t} `command:\"sub\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts, \"cmd\", \"sub\", \"-v\", \"-g\", \"-b\")\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.Command.G {\n\t\tt.Errorf(\"Expected Command.G to be true\")\n\t}\n\n\tif !opts.Command.SubCommand.B {\n\t\tt.Errorf(\"Expected Command.SubCommand.B to be true\")\n\t}\n}\n\nfunc TestCommandFlagOverride1(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand struct {\n\t\t\tValue bool `short:\"v\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts, \"-v\", \"cmd\")\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif opts.Command.Value {\n\t\tt.Errorf(\"Expected Command.Value to be false\")\n\t}\n}\n\nfunc TestCommandFlagOverride2(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand struct {\n\t\t\tValue bool `short:\"v\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts, \"cmd\", \"-v\")\n\n\tif opts.Value {\n\t\tt.Errorf(\"Expected Value to be false\")\n\t}\n\n\tif !opts.Command.Value {\n\t\tt.Errorf(\"Expected Command.Value to be true\")\n\t}\n}\n\nfunc TestCommandFlagOverrideSub(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand struct {\n\t\t\tValue bool `short:\"v\"`\n\n\t\t\tSubCommand struct {\n\t\t\t\tValue bool `short:\"v\"`\n\t\t\t} `command:\"sub\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts, \"cmd\", \"sub\", \"-v\")\n\n\tif opts.Value {\n\t\tt.Errorf(\"Expected Value to be false\")\n\t}\n\n\tif opts.Command.Value {\n\t\tt.Errorf(\"Expected Command.Value to be false\")\n\t}\n\n\tif !opts.Command.SubCommand.Value {\n\t\tt.Errorf(\"Expected Command.Value to be true\")\n\t}\n}\n\nfunc TestCommandFlagOverrideSub2(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand struct {\n\t\t\tValue bool `short:\"v\"`\n\n\t\t\tSubCommand struct {\n\t\t\t\tG bool `short:\"g\"`\n\t\t\t} `command:\"sub\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts, \"cmd\", \"sub\", \"-v\")\n\n\tif opts.Value {\n\t\tt.Errorf(\"Expected Value to be false\")\n\t}\n\n\tif !opts.Command.Value {\n\t\tt.Errorf(\"Expected Command.Value to be true\")\n\t}\n}\n\nfunc TestCommandEstimate(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCmd1 struct {\n\t\t} `command:\"remove\"`\n\n\t\tCmd2 struct {\n\t\t} `command:\"add\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\t_, err := p.ParseArgs([]string{})\n\n\tassertError(t, err, ErrCommandRequired, \"Please specify one command of: add or remove\")\n}\n\nfunc TestCommandEstimate2(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCmd1 struct {\n\t\t} `command:\"remove\"`\n\n\t\tCmd2 struct {\n\t\t} `command:\"add\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\t_, err := p.ParseArgs([]string{\"rmive\"})\n\n\tassertError(t, err, ErrUnknownCommand, \"Unknown command `rmive', did you mean `remove'?\")\n}\n\ntype testCommand struct {\n\tG        bool `short:\"g\"`\n\tExecuted bool\n\tEArgs    []string\n}\n\nfunc (c *testCommand) Execute(args []string) error {\n\tc.Executed = true\n\tc.EArgs = args\n\n\treturn nil\n}\n\nfunc TestCommandExecute(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand testCommand `command:\"cmd\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts, \"-v\", \"cmd\", \"-g\", \"a\", \"b\")\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.Command.Executed {\n\t\tt.Errorf(\"Did not execute command\")\n\t}\n\n\tif !opts.Command.G {\n\t\tt.Errorf(\"Expected Command.C to be true\")\n\t}\n\n\tassertStringArray(t, opts.Command.EArgs, []string{\"a\", \"b\"})\n}\n\nfunc TestCommandClosest(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCmd1 struct {\n\t\t} `command:\"remove\"`\n\n\t\tCmd2 struct {\n\t\t} `command:\"add\"`\n\t}{}\n\n\targs := assertParseFail(t, ErrUnknownCommand, \"Unknown command `addd', did you mean `add'?\", &opts, \"-v\", \"addd\")\n\n\tassertStringArray(t, args, []string{\"addd\"})\n}\n\nfunc TestCommandAdd(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\t}{}\n\n\tvar cmd = struct {\n\t\tG bool `short:\"g\"`\n\t}{}\n\n\tp := NewParser(&opts, Default)\n\tc, err := p.AddCommand(\"cmd\", \"\", \"\", &cmd)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tret, err := p.ParseArgs([]string{\"-v\", \"cmd\", \"-g\", \"rest\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tassertStringArray(t, ret, []string{\"rest\"})\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !cmd.G {\n\t\tt.Errorf(\"Expected Command.G to be true\")\n\t}\n\n\tif p.Command.Find(\"cmd\") != c {\n\t\tt.Errorf(\"Expected to find command `cmd'\")\n\t}\n\n\tif p.Commands()[0] != c {\n\t\tt.Errorf(\"Expected command %#v, but got %#v\", c, p.Commands()[0])\n\t}\n\n\tif c.Options()[0].ShortName != 'g' {\n\t\tt.Errorf(\"Expected short name `g' but got %v\", c.Options()[0].ShortName)\n\t}\n}\n\nfunc TestCommandNestedInline(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand struct {\n\t\t\tG bool `short:\"g\"`\n\n\t\t\tNested struct {\n\t\t\t\tN string `long:\"n\"`\n\t\t\t} `command:\"nested\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tp, ret := assertParserSuccess(t, &opts, \"-v\", \"cmd\", \"-g\", \"nested\", \"--n\", \"n\", \"rest\")\n\n\tassertStringArray(t, ret, []string{\"rest\"})\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.Command.G {\n\t\tt.Errorf(\"Expected Command.G to be true\")\n\t}\n\n\tassertString(t, opts.Command.Nested.N, \"n\")\n\n\tif c := p.Command.Find(\"cmd\"); c == nil {\n\t\tt.Errorf(\"Expected to find command `cmd'\")\n\t} else {\n\t\tif c != p.Active {\n\t\t\tt.Errorf(\"Expected `cmd' to be the active parser command\")\n\t\t}\n\n\t\tif nested := c.Find(\"nested\"); nested == nil {\n\t\t\tt.Errorf(\"Expected to find command `nested'\")\n\t\t} else if nested != c.Active {\n\t\t\tt.Errorf(\"Expected to find command `nested' to be the active `cmd' command\")\n\t\t}\n\t}\n}\n\nfunc TestRequiredOnCommand(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\" required:\"true\"`\n\n\t\tCommand struct {\n\t\t\tG bool `short:\"g\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseFail(t, ErrRequired, fmt.Sprintf(\"the required flag `%cv' was not specified\", defaultShortOptDelimiter), &opts, \"cmd\")\n}\n\nfunc TestRequiredAllOnCommand(t *testing.T) {\n\tvar opts = struct {\n\t\tValue   bool `short:\"v\" required:\"true\"`\n\t\tMissing bool `long:\"missing\" required:\"true\"`\n\n\t\tCommand struct {\n\t\t\tG bool `short:\"g\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseFail(t, ErrRequired, fmt.Sprintf(\"the required flags `%smissing' and `%cv' were not specified\", defaultLongOptDelimiter, defaultShortOptDelimiter), &opts, \"cmd\")\n}\n\nfunc TestDefaultOnCommand(t *testing.T) {\n\tvar opts = struct {\n\t\tCommand struct {\n\t\t\tG string `short:\"g\" default:\"value\"`\n\t\t} `command:\"cmd\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts, \"cmd\")\n\n\tif opts.Command.G != \"value\" {\n\t\tt.Errorf(\"Expected G to be \\\"value\\\"\")\n\t}\n}\n\nfunc TestAfterNonCommand(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCmd1 struct {\n\t\t} `command:\"remove\"`\n\n\t\tCmd2 struct {\n\t\t} `command:\"add\"`\n\t}{}\n\n\tassertParseFail(t, ErrUnknownCommand, \"Unknown command `nocmd'. Please specify one command of: add or remove\", &opts, \"nocmd\", \"remove\")\n}\n\nfunc TestSubcommandsOptional(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCmd1 struct {\n\t\t} `command:\"remove\"`\n\n\t\tCmd2 struct {\n\t\t} `command:\"add\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\tp.SubcommandsOptional = true\n\n\t_, err := p.ParseArgs([]string{\"-v\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n}\n\nfunc TestSubcommandsOptionalAfterNonCommand(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCmd1 struct {\n\t\t} `command:\"remove\"`\n\n\t\tCmd2 struct {\n\t\t} `command:\"add\"`\n\t}{}\n\n\tp := NewParser(&opts, None)\n\tp.SubcommandsOptional = true\n\n\tretargs, err := p.ParseArgs([]string{\"nocmd\", \"remove\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tassertStringArray(t, retargs, []string{\"nocmd\", \"remove\"})\n}\n\nfunc TestCommandAlias(t *testing.T) {\n\tvar opts = struct {\n\t\tCommand struct {\n\t\t\tG string `short:\"g\" default:\"value\"`\n\t\t} `command:\"cmd\" alias:\"cm\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts, \"cm\")\n\n\tif opts.Command.G != \"value\" {\n\t\tt.Errorf(\"Expected G to be \\\"value\\\"\")\n\t}\n}\n\nfunc TestSubCommandFindOptionByLongFlag(t *testing.T) {\n\tvar opts struct {\n\t\tTesting bool `long:\"testing\" description:\"Testing\"`\n\t}\n\n\tvar cmd struct {\n\t\tOther bool `long:\"other\" description:\"Other\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\tc, _ := p.AddCommand(\"command\", \"Short\", \"Long\", &cmd)\n\n\topt := c.FindOptionByLongName(\"other\")\n\n\tif opt == nil {\n\t\tt.Errorf(\"Expected option, but found none\")\n\t}\n\n\tassertString(t, opt.LongName, \"other\")\n\n\topt = c.FindOptionByLongName(\"testing\")\n\n\tif opt == nil {\n\t\tt.Errorf(\"Expected option, but found none\")\n\t}\n\n\tassertString(t, opt.LongName, \"testing\")\n}\n\nfunc TestSubCommandFindOptionByShortFlag(t *testing.T) {\n\tvar opts struct {\n\t\tTesting bool `short:\"t\" description:\"Testing\"`\n\t}\n\n\tvar cmd struct {\n\t\tOther bool `short:\"o\" description:\"Other\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\tc, _ := p.AddCommand(\"command\", \"Short\", \"Long\", &cmd)\n\n\topt := c.FindOptionByShortName('o')\n\n\tif opt == nil {\n\t\tt.Errorf(\"Expected option, but found none\")\n\t}\n\n\tif opt.ShortName != 'o' {\n\t\tt.Errorf(\"Expected 'o', but got %v\", opt.ShortName)\n\t}\n\n\topt = c.FindOptionByShortName('t')\n\n\tif opt == nil {\n\t\tt.Errorf(\"Expected option, but found none\")\n\t}\n\n\tif opt.ShortName != 't' {\n\t\tt.Errorf(\"Expected 'o', but got %v\", opt.ShortName)\n\t}\n}\n\ntype fooCmd struct {\n\tFlag bool `short:\"f\"`\n\targs []string\n}\n\nfunc (foo *fooCmd) Execute(s []string) error {\n\tfoo.args = s\n\treturn nil\n}\n\nfunc TestCommandPassAfterNonOption(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool   `short:\"v\"`\n\t\tFoo   fooCmd `command:\"foo\"`\n\t}{}\n\tp := NewParser(&opts, PassAfterNonOption)\n\tret, err := p.ParseArgs([]string{\"-v\", \"foo\", \"-f\", \"bar\", \"-v\", \"-g\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.Foo.Flag {\n\t\tt.Errorf(\"Expected Foo.Flag to be true\")\n\t}\n\n\tassertStringArray(t, ret, []string{\"bar\", \"-v\", \"-g\"})\n\tassertStringArray(t, opts.Foo.args, []string{\"bar\", \"-v\", \"-g\"})\n}\n\ntype barCmd struct {\n\tfooCmd\n\tPositional struct {\n\t\tArgs []string\n\t} `positional-args:\"yes\"`\n}\n\nfunc TestCommandPassAfterNonOptionWithPositional(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool   `short:\"v\"`\n\t\tBar   barCmd `command:\"bar\"`\n\t}{}\n\tp := NewParser(&opts, PassAfterNonOption)\n\tret, err := p.ParseArgs([]string{\"-v\", \"bar\", \"-f\", \"baz\", \"-v\", \"-g\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.Bar.Flag {\n\t\tt.Errorf(\"Expected Bar.Flag to be true\")\n\t}\n\n\tassertStringArray(t, ret, []string{})\n\tassertStringArray(t, opts.Bar.args, []string{})\n\tassertStringArray(t, opts.Bar.Positional.Args, []string{\"baz\", \"-v\", \"-g\"})\n}\n\ntype cmdLocalPassAfterNonOptionMix struct {\n\tFlagA bool `short:\"a\"`\n\tCmd1  struct {\n\t\tFlagB      bool `short:\"b\"`\n\t\tPositional struct {\n\t\t\tArgs []string\n\t\t} `positional-args:\"yes\"`\n\t} `command:\"cmd1\" pass-after-non-option:\"yes\"`\n\tCmd2 struct {\n\t\tFlagB      bool `short:\"b\"`\n\t\tPositional struct {\n\t\t\tArgs []string\n\t\t} `positional-args:\"yes\"`\n\t} `command:\"cmd2\"`\n}\n\nfunc TestCommandLocalPassAfterNonOptionMixCmd1(t *testing.T) {\n\tvar opts cmdLocalPassAfterNonOptionMix\n\n\tassertParseSuccess(t, &opts, \"cmd1\", \"-b\", \"arg1\", \"-a\", \"arg2\", \"-x\")\n\n\tif opts.FlagA {\n\t\tt.Errorf(\"Expected FlagA to be false\")\n\t}\n\n\tif !opts.Cmd1.FlagB {\n\t\tt.Errorf(\"Expected Cmd1.FlagB to be true\")\n\t}\n\n\tassertStringArray(t, opts.Cmd1.Positional.Args, []string{\"arg1\", \"-a\", \"arg2\", \"-x\"})\n}\n\nfunc TestCommandLocalPassAfterNonOptionMixCmd2(t *testing.T) {\n\tvar opts cmdLocalPassAfterNonOptionMix\n\n\tassertParseSuccess(t, &opts, \"cmd2\", \"-b\", \"arg1\", \"-a\", \"arg2\")\n\n\tif !opts.FlagA {\n\t\tt.Errorf(\"Expected FlagA to be true\")\n\t}\n\n\tif !opts.Cmd2.FlagB {\n\t\tt.Errorf(\"Expected Cmd2.FlagB to be true\")\n\t}\n\n\tassertStringArray(t, opts.Cmd2.Positional.Args, []string{\"arg1\", \"arg2\"})\n}\n\nfunc TestCommandLocalPassAfterNonOptionMixCmd2UnkownFlag(t *testing.T) {\n\tvar opts cmdLocalPassAfterNonOptionMix\n\n\tassertParseFail(t, ErrUnknownFlag, \"unknown flag `x'\", &opts, \"cmd2\", \"-b\", \"arg1\", \"-a\", \"arg2\", \"-x\")\n}\n\ntype cmdLocalPassAfterNonOptionNest struct {\n\tFlagA bool `short:\"a\"`\n\tCmd1  struct {\n\t\tFlagB bool `short:\"b\"`\n\t\tCmd2  struct {\n\t\t\tFlagC bool `short:\"c\"`\n\t\t\tCmd3  struct {\n\t\t\t\tFlagD bool `short:\"d\"`\n\t\t\t} `command:\"cmd3\"`\n\t\t} `command:\"cmd2\" subcommands-optional:\"yes\" pass-after-non-option:\"yes\"`\n\t} `command:\"cmd1\"`\n}\n\nfunc TestCommandLocalPassAfterNonOptionNest1(t *testing.T) {\n\tvar opts cmdLocalPassAfterNonOptionNest\n\n\tret := assertParseSuccess(t, &opts, \"cmd1\", \"cmd2\", \"-a\", \"x\", \"-b\", \"cmd3\", \"-c\", \"-d\")\n\n\tif !opts.FlagA {\n\t\tt.Errorf(\"Expected FlagA to be true\")\n\t}\n\n\tif opts.Cmd1.FlagB {\n\t\tt.Errorf(\"Expected Cmd1.FlagB to be false\")\n\t}\n\n\tif opts.Cmd1.Cmd2.FlagC {\n\t\tt.Errorf(\"Expected Cmd1.Cmd2.FlagC to be false\")\n\t}\n\n\tif opts.Cmd1.Cmd2.Cmd3.FlagD {\n\t\tt.Errorf(\"Expected Cmd1.Cmd2.Cmd3.FlagD to be false\")\n\t}\n\n\tassertStringArray(t, ret, []string{\"x\", \"-b\", \"cmd3\", \"-c\", \"-d\"})\n}\n\nfunc TestCommandLocalPassAfterNonOptionNest2(t *testing.T) {\n\tvar opts cmdLocalPassAfterNonOptionNest\n\n\tret := assertParseSuccess(t, &opts, \"cmd1\", \"cmd2\", \"cmd3\", \"-a\", \"x\", \"-b\", \"-c\", \"-d\")\n\n\tif !opts.FlagA {\n\t\tt.Errorf(\"Expected FlagA to be true\")\n\t}\n\n\tif !opts.Cmd1.FlagB {\n\t\tt.Errorf(\"Expected Cmd1.FlagB to be true\")\n\t}\n\n\tif !opts.Cmd1.Cmd2.FlagC {\n\t\tt.Errorf(\"Expected Cmd1.Cmd2.FlagC to be true\")\n\t}\n\n\tif !opts.Cmd1.Cmd2.Cmd3.FlagD {\n\t\tt.Errorf(\"Expected Cmd1.Cmd2.Cmd3.FlagD to be true\")\n\t}\n\n\tassertStringArray(t, ret, []string{\"x\"})\n}\n"
        },
        {
          "name": "completion.go",
          "type": "blob",
          "size": 7.060546875,
          "content": "package flags\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// Completion is a type containing information of a completion.\ntype Completion struct {\n\t// The completed item\n\tItem string\n\n\t// A description of the completed item (optional)\n\tDescription string\n}\n\ntype completions []Completion\n\nfunc (c completions) Len() int {\n\treturn len(c)\n}\n\nfunc (c completions) Less(i, j int) bool {\n\treturn c[i].Item < c[j].Item\n}\n\nfunc (c completions) Swap(i, j int) {\n\tc[i], c[j] = c[j], c[i]\n}\n\n// Completer is an interface which can be implemented by types\n// to provide custom command line argument completion.\ntype Completer interface {\n\t// Complete receives a prefix representing a (partial) value\n\t// for its type and should provide a list of possible valid\n\t// completions.\n\tComplete(match string) []Completion\n}\n\ntype completion struct {\n\tparser *Parser\n}\n\n// Filename is a string alias which provides filename completion.\ntype Filename string\n\nfunc completionsWithoutDescriptions(items []string) []Completion {\n\tret := make([]Completion, len(items))\n\n\tfor i, v := range items {\n\t\tret[i].Item = v\n\t}\n\n\treturn ret\n}\n\n// Complete returns a list of existing files with the given\n// prefix.\nfunc (f *Filename) Complete(match string) []Completion {\n\tret, _ := filepath.Glob(match + \"*\")\n\tif len(ret) == 1 {\n\t\tif info, err := os.Stat(ret[0]); err == nil && info.IsDir() {\n\t\t\tret[0] = ret[0] + \"/\"\n\t\t}\n\t}\n\treturn completionsWithoutDescriptions(ret)\n}\n\nfunc (c *completion) skipPositional(s *parseState, n int) {\n\tif n >= len(s.positional) {\n\t\ts.positional = nil\n\t} else {\n\t\ts.positional = s.positional[n:]\n\t}\n}\n\nfunc (c *completion) completeOptionNames(s *parseState, prefix string, match string, short bool) []Completion {\n\tif short && len(match) != 0 {\n\t\treturn []Completion{\n\t\t\t{\n\t\t\t\tItem: prefix + match,\n\t\t\t},\n\t\t}\n\t}\n\n\tvar results []Completion\n\trepeats := map[string]bool{}\n\n\tvar longprefix string\n\tvar shortprefix string\n\n\tif prefix == \"/\" {\n\t\tlongprefix = \"/\"\n\t\tshortprefix = \"/\"\n\t} else {\n\t\tlongprefix = \"--\"\n\t\tshortprefix = \"-\"\n\t}\n\n\tfor name, opt := range s.lookup.longNames {\n\t\tif strings.HasPrefix(name, match) && !opt.Hidden {\n\t\t\tresults = append(results, Completion{\n\t\t\t\tItem:        longprefix + name,\n\t\t\t\tDescription: opt.Description,\n\t\t\t})\n\n\t\t\tif short {\n\t\t\t\trepeats[string(opt.ShortName)] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tif short {\n\t\tfor name, opt := range s.lookup.shortNames {\n\t\t\tif _, exist := repeats[name]; !exist && strings.HasPrefix(name, match) && !opt.Hidden {\n\t\t\t\tresults = append(results, Completion{\n\t\t\t\t\tItem:        shortprefix + name,\n\t\t\t\t\tDescription: opt.Description,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results\n}\n\nfunc (c *completion) completeNamesForLongPrefix(s *parseState, prefix string, match string) []Completion {\n\treturn c.completeOptionNames(s, prefix, match, false)\n}\n\nfunc (c *completion) completeNamesForShortPrefix(s *parseState, prefix string, match string) []Completion {\n\treturn c.completeOptionNames(s, prefix, match, true)\n}\n\nfunc (c *completion) completeCommands(s *parseState, match string) []Completion {\n\tn := make([]Completion, 0, len(s.command.commands))\n\n\tfor _, cmd := range s.command.commands {\n\t\tif cmd.data != c && !cmd.Hidden && strings.HasPrefix(cmd.Name, match) {\n\t\t\tn = append(n, Completion{\n\t\t\t\tItem:        cmd.Name,\n\t\t\t\tDescription: cmd.ShortDescription,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn n\n}\n\nfunc (c *completion) completeValue(value reflect.Value, prefix string, match string) []Completion {\n\tif value.Kind() == reflect.Slice {\n\t\tvalue = reflect.New(value.Type().Elem())\n\t}\n\ti := value.Interface()\n\n\tvar ret []Completion\n\n\tif cmp, ok := i.(Completer); ok {\n\t\tret = cmp.Complete(match)\n\t} else if value.CanAddr() {\n\t\tif cmp, ok = value.Addr().Interface().(Completer); ok {\n\t\t\tret = cmp.Complete(match)\n\t\t}\n\t}\n\n\tfor i, v := range ret {\n\t\tret[i].Item = prefix + v.Item\n\t}\n\n\treturn ret\n}\n\nfunc (c *completion) complete(args []string) []Completion {\n\tif len(args) == 0 {\n\t\targs = []string{\"\"}\n\t}\n\n\ts := &parseState{\n\t\targs: args,\n\t}\n\n\tc.parser.fillParseState(s)\n\n\tvar opt *Option\n\n\tfor len(s.args) > 1 {\n\t\targ := s.pop()\n\n\t\tif (c.parser.Options&PassDoubleDash) != None && arg == \"--\" {\n\t\t\topt = nil\n\t\t\tc.skipPositional(s, len(s.args)-1)\n\n\t\t\tbreak\n\t\t}\n\n\t\tif argumentIsOption(arg) {\n\t\t\tprefix, optname, islong := stripOptionPrefix(arg)\n\t\t\toptname, _, argument := splitOption(prefix, optname, islong)\n\n\t\t\tif argument == nil {\n\t\t\t\tvar o *Option\n\t\t\t\tcanarg := true\n\n\t\t\t\tif islong {\n\t\t\t\t\to = s.lookup.longNames[optname]\n\t\t\t\t} else {\n\t\t\t\t\tfor i, r := range optname {\n\t\t\t\t\t\tsname := string(r)\n\t\t\t\t\t\to = s.lookup.shortNames[sname]\n\n\t\t\t\t\t\tif o == nil {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif i == 0 && o.canArgument() && len(optname) != len(sname) {\n\t\t\t\t\t\t\tcanarg = false\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif o == nil && (c.parser.Options&PassAfterNonOption) != None {\n\t\t\t\t\topt = nil\n\t\t\t\t\tc.skipPositional(s, len(s.args)-1)\n\n\t\t\t\t\tbreak\n\t\t\t\t} else if o != nil && o.canArgument() && !o.OptionalArgument && canarg {\n\t\t\t\t\tif len(s.args) > 1 {\n\t\t\t\t\t\ts.pop()\n\t\t\t\t\t} else {\n\t\t\t\t\t\topt = o\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif len(s.positional) > 0 {\n\t\t\t\tif !s.positional[0].isRemaining() {\n\t\t\t\t\t// Don't advance beyond a remaining positional arg (because\n\t\t\t\t\t// it consumes all subsequent args).\n\t\t\t\t\ts.positional = s.positional[1:]\n\t\t\t\t}\n\t\t\t} else if cmd, ok := s.lookup.commands[arg]; ok {\n\t\t\t\tcmd.fillParseState(s)\n\t\t\t}\n\n\t\t\topt = nil\n\t\t}\n\t}\n\n\tlastarg := s.args[len(s.args)-1]\n\tvar ret []Completion\n\n\tif opt != nil {\n\t\t// Completion for the argument of 'opt'\n\t\tret = c.completeValue(opt.value, \"\", lastarg)\n\t} else if argumentStartsOption(lastarg) {\n\t\t// Complete the option\n\t\tprefix, optname, islong := stripOptionPrefix(lastarg)\n\t\toptname, split, argument := splitOption(prefix, optname, islong)\n\n\t\tif argument == nil && !islong {\n\t\t\trname, n := utf8.DecodeRuneInString(optname)\n\t\t\tsname := string(rname)\n\n\t\t\tif opt := s.lookup.shortNames[sname]; opt != nil && opt.canArgument() {\n\t\t\t\tret = c.completeValue(opt.value, prefix+sname, optname[n:])\n\t\t\t} else {\n\t\t\t\tret = c.completeNamesForShortPrefix(s, prefix, optname)\n\t\t\t}\n\t\t} else if argument != nil {\n\t\t\tif islong {\n\t\t\t\topt = s.lookup.longNames[optname]\n\t\t\t} else {\n\t\t\t\topt = s.lookup.shortNames[optname]\n\t\t\t}\n\n\t\t\tif opt != nil {\n\t\t\t\tret = c.completeValue(opt.value, prefix+optname+split, *argument)\n\t\t\t}\n\t\t} else if islong {\n\t\t\tret = c.completeNamesForLongPrefix(s, prefix, optname)\n\t\t} else {\n\t\t\tret = c.completeNamesForShortPrefix(s, prefix, optname)\n\t\t}\n\t} else if len(s.positional) > 0 {\n\t\t// Complete for positional argument\n\t\tret = c.completeValue(s.positional[0].value, \"\", lastarg)\n\t} else if len(s.command.commands) > 0 {\n\t\t// Complete for command\n\t\tret = c.completeCommands(s, lastarg)\n\t}\n\n\tsort.Sort(completions(ret))\n\treturn ret\n}\n\nfunc (c *completion) print(items []Completion, showDescriptions bool) {\n\tif showDescriptions && len(items) > 1 {\n\t\tmaxl := 0\n\n\t\tfor _, v := range items {\n\t\t\tif len(v.Item) > maxl {\n\t\t\t\tmaxl = len(v.Item)\n\t\t\t}\n\t\t}\n\n\t\tfor _, v := range items {\n\t\t\tfmt.Printf(\"%s\", v.Item)\n\n\t\t\tif len(v.Description) > 0 {\n\t\t\t\tfmt.Printf(\"%s  # %s\", strings.Repeat(\" \", maxl-len(v.Item)), v.Description)\n\t\t\t}\n\n\t\t\tfmt.Printf(\"\\n\")\n\t\t}\n\t} else {\n\t\tfor _, v := range items {\n\t\t\tfmt.Println(v.Item)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "completion_test.go",
          "type": "blob",
          "size": 8.0625,
          "content": "package flags\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype TestComplete struct {\n}\n\nfunc (t *TestComplete) Complete(match string) []Completion {\n\toptions := []string{\n\t\t\"hello world\",\n\t\t\"hello universe\",\n\t\t\"hello multiverse\",\n\t}\n\n\tret := make([]Completion, 0, len(options))\n\n\tfor _, o := range options {\n\t\tif strings.HasPrefix(o, match) {\n\t\t\tret = append(ret, Completion{\n\t\t\t\tItem: o,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn ret\n}\n\nvar completionTestOptions struct {\n\tVerbose  bool `short:\"v\" long:\"verbose\" description:\"Verbose messages\"`\n\tDebug    bool `short:\"d\" long:\"debug\" description:\"Enable debug\"`\n\tInfo     bool `short:\"i\" description:\"Display info\"`\n\tVersion  bool `long:\"version\" description:\"Show version\"`\n\tRequired bool `long:\"required\" required:\"true\" description:\"This is required\"`\n\tHidden   bool `long:\"hidden\" hidden:\"true\" description:\"This is hidden\"`\n\n\tAddCommand struct {\n\t\tPositional struct {\n\t\t\tFilename Filename\n\t\t} `positional-args:\"yes\"`\n\t} `command:\"add\" description:\"add an item\"`\n\n\tAddMultiCommand struct {\n\t\tPositional struct {\n\t\t\tFilename []Filename\n\t\t} `positional-args:\"yes\"`\n\t\tExtra []Filename `short:\"f\"`\n\t} `command:\"add-multi\" description:\"add multiple items\"`\n\n\tAddMultiCommandFlag struct {\n\t\tFiles []Filename `short:\"f\"`\n\t} `command:\"add-multi-flag\" description:\"add multiple items via flags\"`\n\n\tRemoveCommand struct {\n\t\tOther bool     `short:\"o\"`\n\t\tFile  Filename `short:\"f\" long:\"filename\"`\n\t} `command:\"rm\" description:\"remove an item\"`\n\n\tRenameCommand struct {\n\t\tCompleted TestComplete `short:\"c\" long:\"completed\"`\n\t} `command:\"rename\" description:\"rename an item\"`\n\n\tHiddenCommand struct {\n\t} `command:\"hidden\" description:\"hidden command\" hidden:\"true\"`\n}\n\ntype completionTest struct {\n\tArgs             []string\n\tCompleted        []string\n\tShowDescriptions bool\n}\n\nvar completionTests []completionTest\n\nfunc makeLongName(option string) string {\n\treturn defaultLongOptDelimiter + option\n}\n\nfunc makeShortName(option string) string {\n\treturn string(defaultShortOptDelimiter) + option\n}\n\nfunc init() {\n\t_, sourcefile, _, _ := runtime.Caller(0)\n\tcompletionTestSourcedir := filepath.Join(filepath.SplitList(path.Dir(sourcefile))...)\n\n\tcompletionTestFilename := []string{filepath.Join(completionTestSourcedir, \"completion.go\"), filepath.Join(completionTestSourcedir, \"completion_test.go\")}\n\n\tcompletionTestSubdir := []string{\n\t\tfilepath.Join(completionTestSourcedir, \"examples/add.go\"),\n\t\tfilepath.Join(completionTestSourcedir, \"examples/bash-completion\"),\n\t\tfilepath.Join(completionTestSourcedir, \"examples/main.go\"),\n\t\tfilepath.Join(completionTestSourcedir, \"examples/rm.go\"),\n\t}\n\n\tcompletionTests = []completionTest{\n\t\t{\n\t\t\t// Short names\n\t\t\t[]string{makeShortName(\"\")},\n\t\t\t[]string{makeLongName(\"debug\"), makeLongName(\"required\"), makeLongName(\"verbose\"), makeLongName(\"version\"), makeShortName(\"i\")},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Short names full\n\t\t\t[]string{makeShortName(\"i\")},\n\t\t\t[]string{makeShortName(\"i\")},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Short names concatenated\n\t\t\t[]string{\"-dv\"},\n\t\t\t[]string{\"-dv\"},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Long names\n\t\t\t[]string{\"--\"},\n\t\t\t[]string{\"--debug\", \"--required\", \"--verbose\", \"--version\"},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Long names with descriptions\n\t\t\t[]string{\"--\"},\n\t\t\t[]string{\n\t\t\t\t\"--debug     # Enable debug\",\n\t\t\t\t\"--required  # This is required\",\n\t\t\t\t\"--verbose   # Verbose messages\",\n\t\t\t\t\"--version   # Show version\",\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\n\t\t{\n\t\t\t// Long names partial\n\t\t\t[]string{makeLongName(\"ver\")},\n\t\t\t[]string{makeLongName(\"verbose\"), makeLongName(\"version\")},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Commands\n\t\t\t[]string{\"\"},\n\t\t\t[]string{\"add\", \"add-multi\", \"add-multi-flag\", \"rename\", \"rm\"},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Commands with descriptions\n\t\t\t[]string{\"\"},\n\t\t\t[]string{\n\t\t\t\t\"add             # add an item\",\n\t\t\t\t\"add-multi       # add multiple items\",\n\t\t\t\t\"add-multi-flag  # add multiple items via flags\",\n\t\t\t\t\"rename          # rename an item\",\n\t\t\t\t\"rm              # remove an item\",\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\n\t\t{\n\t\t\t// Commands partial\n\t\t\t[]string{\"r\"},\n\t\t\t[]string{\"rename\", \"rm\"},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Positional filename\n\t\t\t[]string{\"add\", filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\tcompletionTestFilename,\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Multiple positional filename (1 arg)\n\t\t\t[]string{\"add-multi\", filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\tcompletionTestFilename,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Multiple positional filename (2 args)\n\t\t\t[]string{\"add-multi\", filepath.Join(completionTestSourcedir, \"completion.go\"), filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\tcompletionTestFilename,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Multiple positional filename (3 args)\n\t\t\t[]string{\"add-multi\", filepath.Join(completionTestSourcedir, \"completion.go\"), filepath.Join(completionTestSourcedir, \"completion.go\"), filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\tcompletionTestFilename,\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Flag filename\n\t\t\t[]string{\"rm\", makeShortName(\"f\"), filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\tcompletionTestFilename,\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Flag short concat last filename\n\t\t\t[]string{\"rm\", \"-of\", filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\tcompletionTestFilename,\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Flag concat filename\n\t\t\t[]string{\"rm\", \"-f\" + filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\t[]string{\"-f\" + completionTestFilename[0], \"-f\" + completionTestFilename[1]},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Flag equal concat filename\n\t\t\t[]string{\"rm\", \"-f=\" + filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\t[]string{\"-f=\" + completionTestFilename[0], \"-f=\" + completionTestFilename[1]},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Flag concat long filename\n\t\t\t[]string{\"rm\", \"--filename=\" + filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\t[]string{\"--filename=\" + completionTestFilename[0], \"--filename=\" + completionTestFilename[1]},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Flag long filename\n\t\t\t[]string{\"rm\", \"--filename\", filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\tcompletionTestFilename,\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// To subdir\n\t\t\t[]string{\"rm\", \"--filename\", filepath.Join(completionTestSourcedir, \"examples/bash-\")},\n\t\t\t[]string{filepath.Join(completionTestSourcedir, \"examples/bash-completion/\")},\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Subdirectory\n\t\t\t[]string{\"rm\", \"--filename\", filepath.Join(completionTestSourcedir, \"examples\") + \"/\"},\n\t\t\tcompletionTestSubdir,\n\t\t\tfalse,\n\t\t},\n\n\t\t{\n\t\t\t// Custom completed\n\t\t\t[]string{\"rename\", makeShortName(\"c\"), \"hello un\"},\n\t\t\t[]string{\"hello universe\"},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t// Multiple flag filename\n\t\t\t[]string{\"add-multi-flag\", makeShortName(\"f\"), filepath.Join(completionTestSourcedir, \"completion\")},\n\t\t\tcompletionTestFilename,\n\t\t\tfalse,\n\t\t},\n\t}\n}\n\nfunc TestCompletion(t *testing.T) {\n\tp := NewParser(&completionTestOptions, Default)\n\tc := &completion{parser: p}\n\n\tfor _, test := range completionTests {\n\t\tif test.ShowDescriptions {\n\t\t\tcontinue\n\t\t}\n\n\t\tret := c.complete(test.Args)\n\t\titems := make([]string, len(ret))\n\n\t\tfor i, v := range ret {\n\t\t\titems[i] = v.Item\n\t\t}\n\n\t\tsort.Strings(items)\n\t\tsort.Strings(test.Completed)\n\n\t\tif !reflect.DeepEqual(items, test.Completed) {\n\t\t\tt.Errorf(\"Args: %#v, %#v\\n  Expected: %#v\\n  Got:     %#v\", test.Args, test.ShowDescriptions, test.Completed, items)\n\t\t}\n\t}\n}\n\nfunc TestParserCompletion(t *testing.T) {\n\tfor _, test := range completionTests {\n\t\tif test.ShowDescriptions {\n\t\t\tos.Setenv(\"GO_FLAGS_COMPLETION\", \"verbose\")\n\t\t} else {\n\t\t\tos.Setenv(\"GO_FLAGS_COMPLETION\", \"1\")\n\t\t}\n\n\t\ttmp := os.Stdout\n\n\t\tr, w, _ := os.Pipe()\n\t\tos.Stdout = w\n\n\t\tout := make(chan string)\n\n\t\tgo func() {\n\t\t\tvar buf bytes.Buffer\n\n\t\t\tio.Copy(&buf, r)\n\n\t\t\tout <- buf.String()\n\t\t}()\n\n\t\tp := NewParser(&completionTestOptions, None)\n\n\t\tp.CompletionHandler = func(items []Completion) {\n\t\t\tcomp := &completion{parser: p}\n\t\t\tcomp.print(items, test.ShowDescriptions)\n\t\t}\n\n\t\t_, err := p.ParseArgs(test.Args)\n\n\t\tw.Close()\n\n\t\tos.Stdout = tmp\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t\t}\n\n\t\tgot := strings.Split(strings.Trim(<-out, \"\\n\"), \"\\n\")\n\n\t\tif !reflect.DeepEqual(got, test.Completed) {\n\t\t\tt.Errorf(\"Expected: %#v\\nGot: %#v\", test.Completed, got)\n\t\t}\n\t}\n\n\tos.Setenv(\"GO_FLAGS_COMPLETION\", \"\")\n}\n"
        },
        {
          "name": "convert.go",
          "type": "blob",
          "size": 7.30859375,
          "content": "// Copyright 2012 Jesse van den Kieboom. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage flags\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Marshaler is the interface implemented by types that can marshal themselves\n// to a string representation of the flag.\ntype Marshaler interface {\n\t// MarshalFlag marshals a flag value to its string representation.\n\tMarshalFlag() (string, error)\n}\n\n// Unmarshaler is the interface implemented by types that can unmarshal a flag\n// argument to themselves. The provided value is directly passed from the\n// command line.\ntype Unmarshaler interface {\n\t// UnmarshalFlag unmarshals a string value representation to the flag\n\t// value (which therefore needs to be a pointer receiver).\n\tUnmarshalFlag(value string) error\n}\n\n// ValueValidator is the interface implemented by types that can validate a\n// flag argument themselves. The provided value is directly passed from the\n// command line.\ntype ValueValidator interface {\n\t// IsValidValue returns an error if the provided string value is valid for\n\t// the flag.\n\tIsValidValue(value string) error\n}\n\nfunc getBase(options multiTag, base int) (int, error) {\n\tsbase := options.Get(\"base\")\n\n\tvar err error\n\tvar ivbase int64\n\n\tif sbase != \"\" {\n\t\tivbase, err = strconv.ParseInt(sbase, 10, 32)\n\t\tbase = int(ivbase)\n\t}\n\n\treturn base, err\n}\n\nfunc convertMarshal(val reflect.Value) (bool, string, error) {\n\t// Check first for the Marshaler interface\n\tif val.IsValid() && val.Type().NumMethod() > 0 && val.CanInterface() {\n\t\tif marshaler, ok := val.Interface().(Marshaler); ok {\n\t\t\tret, err := marshaler.MarshalFlag()\n\t\t\treturn true, ret, err\n\t\t}\n\t}\n\n\treturn false, \"\", nil\n}\n\nfunc convertToString(val reflect.Value, options multiTag) (string, error) {\n\tif ok, ret, err := convertMarshal(val); ok {\n\t\treturn ret, err\n\t}\n\n\tif !val.IsValid() {\n\t\treturn \"\", nil\n\t}\n\n\ttp := val.Type()\n\n\t// Support for time.Duration\n\tif tp == reflect.TypeOf((*time.Duration)(nil)).Elem() {\n\t\tstringer := val.Interface().(fmt.Stringer)\n\t\treturn stringer.String(), nil\n\t}\n\n\tswitch tp.Kind() {\n\tcase reflect.String:\n\t\treturn val.String(), nil\n\tcase reflect.Bool:\n\t\tif val.Bool() {\n\t\t\treturn \"true\", nil\n\t\t}\n\n\t\treturn \"false\", nil\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tbase, err := getBase(options, 10)\n\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn strconv.FormatInt(val.Int(), base), nil\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tbase, err := getBase(options, 10)\n\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn strconv.FormatUint(val.Uint(), base), nil\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn strconv.FormatFloat(val.Float(), 'g', -1, tp.Bits()), nil\n\tcase reflect.Slice:\n\t\tif val.Len() == 0 {\n\t\t\treturn \"\", nil\n\t\t}\n\n\t\tret := \"[\"\n\n\t\tfor i := 0; i < val.Len(); i++ {\n\t\t\tif i != 0 {\n\t\t\t\tret += \", \"\n\t\t\t}\n\n\t\t\titem, err := convertToString(val.Index(i), options)\n\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tret += item\n\t\t}\n\n\t\treturn ret + \"]\", nil\n\tcase reflect.Map:\n\t\tret := \"{\"\n\n\t\tfor i, key := range val.MapKeys() {\n\t\t\tif i != 0 {\n\t\t\t\tret += \", \"\n\t\t\t}\n\n\t\t\tkeyitem, err := convertToString(key, options)\n\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\titem, err := convertToString(val.MapIndex(key), options)\n\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tret += keyitem + \":\" + item\n\t\t}\n\n\t\treturn ret + \"}\", nil\n\tcase reflect.Ptr:\n\t\treturn convertToString(reflect.Indirect(val), options)\n\tcase reflect.Interface:\n\t\tif !val.IsNil() {\n\t\t\treturn convertToString(val.Elem(), options)\n\t\t}\n\t}\n\n\treturn \"\", nil\n}\n\nfunc convertUnmarshal(val string, retval reflect.Value) (bool, error) {\n\tif retval.Type().NumMethod() > 0 && retval.CanInterface() {\n\t\tif unmarshaler, ok := retval.Interface().(Unmarshaler); ok {\n\t\t\tif retval.IsNil() {\n\t\t\t\tretval.Set(reflect.New(retval.Type().Elem()))\n\n\t\t\t\t// Re-assign from the new value\n\t\t\t\tunmarshaler = retval.Interface().(Unmarshaler)\n\t\t\t}\n\n\t\t\treturn true, unmarshaler.UnmarshalFlag(val)\n\t\t}\n\t}\n\n\tif retval.Type().Kind() != reflect.Ptr && retval.CanAddr() {\n\t\treturn convertUnmarshal(val, retval.Addr())\n\t}\n\n\tif retval.Type().Kind() == reflect.Interface && !retval.IsNil() {\n\t\treturn convertUnmarshal(val, retval.Elem())\n\t}\n\n\treturn false, nil\n}\n\nfunc convert(val string, retval reflect.Value, options multiTag) error {\n\tif ok, err := convertUnmarshal(val, retval); ok {\n\t\treturn err\n\t}\n\n\ttp := retval.Type()\n\n\t// Support for time.Duration\n\tif tp == reflect.TypeOf((*time.Duration)(nil)).Elem() {\n\t\tparsed, err := time.ParseDuration(val)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tretval.SetInt(int64(parsed))\n\t\treturn nil\n\t}\n\n\tswitch tp.Kind() {\n\tcase reflect.String:\n\t\tretval.SetString(val)\n\tcase reflect.Bool:\n\t\tif val == \"\" {\n\t\t\tretval.SetBool(true)\n\t\t} else {\n\t\t\tb, err := strconv.ParseBool(val)\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tretval.SetBool(b)\n\t\t}\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tbase, err := getBase(options, 0)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tparsed, err := strconv.ParseInt(val, base, tp.Bits())\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tretval.SetInt(parsed)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tbase, err := getBase(options, 0)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tparsed, err := strconv.ParseUint(val, base, tp.Bits())\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tretval.SetUint(parsed)\n\tcase reflect.Float32, reflect.Float64:\n\t\tparsed, err := strconv.ParseFloat(val, tp.Bits())\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tretval.SetFloat(parsed)\n\tcase reflect.Slice:\n\t\telemtp := tp.Elem()\n\n\t\telemvalptr := reflect.New(elemtp)\n\t\telemval := reflect.Indirect(elemvalptr)\n\n\t\tif err := convert(val, elemval, options); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tretval.Set(reflect.Append(retval, elemval))\n\tcase reflect.Map:\n\t\tkeyValueDelimiter := options.Get(\"key-value-delimiter\")\n\t\tif keyValueDelimiter == \"\" {\n\t\t\tkeyValueDelimiter = \":\"\n\t\t}\n\n\t\tparts := strings.SplitN(val, keyValueDelimiter, 2)\n\n\t\tkey := parts[0]\n\t\tvar value string\n\n\t\tif len(parts) == 2 {\n\t\t\tvalue = parts[1]\n\t\t}\n\n\t\tkeytp := tp.Key()\n\t\tkeyval := reflect.New(keytp)\n\n\t\tif err := convert(key, keyval, options); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvaluetp := tp.Elem()\n\t\tvalueval := reflect.New(valuetp)\n\n\t\tif err := convert(value, valueval, options); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif retval.IsNil() {\n\t\t\tretval.Set(reflect.MakeMap(tp))\n\t\t}\n\n\t\tretval.SetMapIndex(reflect.Indirect(keyval), reflect.Indirect(valueval))\n\tcase reflect.Ptr:\n\t\tif retval.IsNil() {\n\t\t\tretval.Set(reflect.New(retval.Type().Elem()))\n\t\t}\n\n\t\treturn convert(val, reflect.Indirect(retval), options)\n\tcase reflect.Interface:\n\t\tif !retval.IsNil() {\n\t\t\treturn convert(val, retval.Elem(), options)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc isPrint(s string) bool {\n\tfor _, c := range s {\n\t\tif !strconv.IsPrint(c) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc quoteIfNeeded(s string) string {\n\tif !isPrint(s) {\n\t\treturn strconv.Quote(s)\n\t}\n\n\treturn s\n}\n\nfunc quoteIfNeededV(s []string) []string {\n\tret := make([]string, len(s))\n\n\tfor i, v := range s {\n\t\tret[i] = quoteIfNeeded(v)\n\t}\n\n\treturn ret\n}\n\nfunc quoteV(s []string) []string {\n\tret := make([]string, len(s))\n\n\tfor i, v := range s {\n\t\tret[i] = strconv.Quote(v)\n\t}\n\n\treturn ret\n}\n\nfunc unquoteIfPossible(s string) (string, error) {\n\tif len(s) == 0 || s[0] != '\"' {\n\t\treturn s, nil\n\t}\n\n\treturn strconv.Unquote(s)\n}\n"
        },
        {
          "name": "convert_test.go",
          "type": "blob",
          "size": 2.9443359375,
          "content": "package flags\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc expectConvert(t *testing.T, o *Option, expected string) {\n\ts, err := convertToString(o.value, o.tag)\n\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tassertString(t, s, expected)\n}\n\nfunc TestConvertToString(t *testing.T) {\n\td, _ := time.ParseDuration(\"1h2m4s\")\n\n\tvar opts = struct {\n\t\tString string `long:\"string\"`\n\n\t\tInt   int   `long:\"int\"`\n\t\tInt8  int8  `long:\"int8\"`\n\t\tInt16 int16 `long:\"int16\"`\n\t\tInt32 int32 `long:\"int32\"`\n\t\tInt64 int64 `long:\"int64\"`\n\n\t\tUint   uint   `long:\"uint\"`\n\t\tUint8  uint8  `long:\"uint8\"`\n\t\tUint16 uint16 `long:\"uint16\"`\n\t\tUint32 uint32 `long:\"uint32\"`\n\t\tUint64 uint64 `long:\"uint64\"`\n\n\t\tFloat32 float32 `long:\"float32\"`\n\t\tFloat64 float64 `long:\"float64\"`\n\n\t\tDuration time.Duration `long:\"duration\"`\n\n\t\tBool bool `long:\"bool\"`\n\n\t\tIntSlice    []int           `long:\"int-slice\"`\n\t\tIntFloatMap map[int]float64 `long:\"int-float-map\"`\n\n\t\tPtrBool   *bool       `long:\"ptr-bool\"`\n\t\tInterface interface{} `long:\"interface\"`\n\n\t\tInt32Base  int32  `long:\"int32-base\" base:\"16\"`\n\t\tUint32Base uint32 `long:\"uint32-base\" base:\"16\"`\n\t}{\n\t\t\"string\",\n\n\t\t-2,\n\t\t-1,\n\t\t0,\n\t\t1,\n\t\t2,\n\n\t\t1,\n\t\t2,\n\t\t3,\n\t\t4,\n\t\t5,\n\n\t\t1.2,\n\t\t-3.4,\n\n\t\td,\n\t\ttrue,\n\n\t\t[]int{-3, 4, -2},\n\t\tmap[int]float64{-2: 4.5},\n\n\t\tnew(bool),\n\t\tfloat32(5.2),\n\n\t\t-5823,\n\t\t4232,\n\t}\n\n\tp := NewNamedParser(\"test\", Default)\n\tgrp, _ := p.AddGroup(\"test group\", \"\", &opts)\n\n\texpects := []string{\n\t\t\"string\",\n\t\t\"-2\",\n\t\t\"-1\",\n\t\t\"0\",\n\t\t\"1\",\n\t\t\"2\",\n\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"4\",\n\t\t\"5\",\n\n\t\t\"1.2\",\n\t\t\"-3.4\",\n\n\t\t\"1h2m4s\",\n\t\t\"true\",\n\n\t\t\"[-3, 4, -2]\",\n\t\t\"{-2:4.5}\",\n\n\t\t\"false\",\n\t\t\"5.2\",\n\n\t\t\"-16bf\",\n\t\t\"1088\",\n\t}\n\n\tfor i, v := range grp.Options() {\n\t\texpectConvert(t, v, expects[i])\n\t}\n}\n\nfunc TestConvertToStringInvalidIntBase(t *testing.T) {\n\tvar opts = struct {\n\t\tInt int `long:\"int\" base:\"no\"`\n\t}{\n\t\t2,\n\t}\n\n\tp := NewNamedParser(\"test\", Default)\n\tgrp, _ := p.AddGroup(\"test group\", \"\", &opts)\n\to := grp.Options()[0]\n\n\t_, err := convertToString(o.value, o.tag)\n\n\tif err != nil {\n\t\terr = newErrorf(ErrMarshal, \"%v\", err)\n\t}\n\n\tassertError(t, err, ErrMarshal, \"strconv.ParseInt: parsing \\\"no\\\": invalid syntax\")\n}\n\nfunc TestConvertToStringInvalidUintBase(t *testing.T) {\n\tvar opts = struct {\n\t\tUint uint `long:\"uint\" base:\"no\"`\n\t}{\n\t\t2,\n\t}\n\n\tp := NewNamedParser(\"test\", Default)\n\tgrp, _ := p.AddGroup(\"test group\", \"\", &opts)\n\to := grp.Options()[0]\n\n\t_, err := convertToString(o.value, o.tag)\n\n\tif err != nil {\n\t\terr = newErrorf(ErrMarshal, \"%v\", err)\n\t}\n\n\tassertError(t, err, ErrMarshal, \"strconv.ParseInt: parsing \\\"no\\\": invalid syntax\")\n}\n\nfunc TestConvertToMapWithDelimiter(t *testing.T) {\n\tvar opts = struct {\n\t\tStringStringMap map[string]string `long:\"string-string-map\" key-value-delimiter:\"=\"`\n\t}{}\n\n\tp := NewNamedParser(\"test\", Default)\n\tgrp, _ := p.AddGroup(\"test group\", \"\", &opts)\n\to := grp.Options()[0]\n\n\terr := convert(\"key=value\", o.value, o.tag)\n\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tassertString(t, opts.StringStringMap[\"key\"], \"value\")\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 2.98828125,
          "content": "package flags\n\nimport (\n\t\"fmt\"\n)\n\n// ErrorType represents the type of error.\ntype ErrorType uint\n\nconst (\n\t// ErrUnknown indicates a generic error.\n\tErrUnknown ErrorType = iota\n\n\t// ErrExpectedArgument indicates that an argument was expected.\n\tErrExpectedArgument\n\n\t// ErrUnknownFlag indicates an unknown flag.\n\tErrUnknownFlag\n\n\t// ErrUnknownGroup indicates an unknown group.\n\tErrUnknownGroup\n\n\t// ErrMarshal indicates a marshalling error while converting values.\n\tErrMarshal\n\n\t// ErrHelp indicates that the built-in help was shown (the error\n\t// contains the help message).\n\tErrHelp\n\n\t// ErrNoArgumentForBool indicates that an argument was given for a\n\t// boolean flag (which don't not take any arguments).\n\tErrNoArgumentForBool\n\n\t// ErrRequired indicates that a required flag was not provided.\n\tErrRequired\n\n\t// ErrShortNameTooLong indicates that a short flag name was specified,\n\t// longer than one character.\n\tErrShortNameTooLong\n\n\t// ErrDuplicatedFlag indicates that a short or long flag has been\n\t// defined more than once\n\tErrDuplicatedFlag\n\n\t// ErrTag indicates an error while parsing flag tags.\n\tErrTag\n\n\t// ErrCommandRequired indicates that a command was required but not\n\t// specified\n\tErrCommandRequired\n\n\t// ErrUnknownCommand indicates that an unknown command was specified.\n\tErrUnknownCommand\n\n\t// ErrInvalidChoice indicates an invalid option value which only allows\n\t// a certain number of choices.\n\tErrInvalidChoice\n\n\t// ErrInvalidTag indicates an invalid tag or invalid use of an existing tag\n\tErrInvalidTag\n)\n\nfunc (e ErrorType) String() string {\n\tswitch e {\n\tcase ErrUnknown:\n\t\treturn \"unknown\"\n\tcase ErrExpectedArgument:\n\t\treturn \"expected argument\"\n\tcase ErrUnknownFlag:\n\t\treturn \"unknown flag\"\n\tcase ErrUnknownGroup:\n\t\treturn \"unknown group\"\n\tcase ErrMarshal:\n\t\treturn \"marshal\"\n\tcase ErrHelp:\n\t\treturn \"help\"\n\tcase ErrNoArgumentForBool:\n\t\treturn \"no argument for bool\"\n\tcase ErrRequired:\n\t\treturn \"required\"\n\tcase ErrShortNameTooLong:\n\t\treturn \"short name too long\"\n\tcase ErrDuplicatedFlag:\n\t\treturn \"duplicated flag\"\n\tcase ErrTag:\n\t\treturn \"tag\"\n\tcase ErrCommandRequired:\n\t\treturn \"command required\"\n\tcase ErrUnknownCommand:\n\t\treturn \"unknown command\"\n\tcase ErrInvalidChoice:\n\t\treturn \"invalid choice\"\n\tcase ErrInvalidTag:\n\t\treturn \"invalid tag\"\n\t}\n\n\treturn \"unrecognized error type\"\n}\n\nfunc (e ErrorType) Error() string {\n\treturn e.String()\n}\n\n// Error represents a parser error. The error returned from Parse is of this\n// type. The error contains both a Type and Message.\ntype Error struct {\n\t// The type of error\n\tType ErrorType\n\n\t// The error message\n\tMessage string\n}\n\n// Error returns the error's message\nfunc (e *Error) Error() string {\n\treturn e.Message\n}\n\nfunc newError(tp ErrorType, message string) *Error {\n\treturn &Error{\n\t\tType:    tp,\n\t\tMessage: message,\n\t}\n}\n\nfunc newErrorf(tp ErrorType, format string, args ...interface{}) *Error {\n\treturn newError(tp, fmt.Sprintf(format, args...))\n}\n\nfunc wrapError(err error) *Error {\n\tret, ok := err.(*Error)\n\n\tif !ok {\n\t\treturn newError(ErrUnknown, err.Error())\n\t}\n\n\treturn ret\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 3.029296875,
          "content": "// Example of use of the flags package.\npackage flags\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc Example() {\n\tvar opts struct {\n\t\t// Slice of bool will append 'true' each time the option\n\t\t// is encountered (can be set multiple times, like -vvv)\n\t\tVerbose []bool `short:\"v\" long:\"verbose\" description:\"Show verbose debug information\"`\n\n\t\t// Example of automatic marshalling to desired type (uint)\n\t\tOffset uint `long:\"offset\" description:\"Offset\"`\n\n\t\t// Example of a callback, called each time the option is found.\n\t\tCall func(string) `short:\"c\" description:\"Call phone number\"`\n\n\t\t// Example of a required flag\n\t\tName string `short:\"n\" long:\"name\" description:\"A name\" required:\"true\"`\n\n\t\t// Example of a value name\n\t\tFile string `short:\"f\" long:\"file\" description:\"A file\" value-name:\"FILE\"`\n\n\t\t// Example of a pointer\n\t\tPtr *int `short:\"p\" description:\"A pointer to an integer\"`\n\n\t\t// Example of a slice of strings\n\t\tStringSlice []string `short:\"s\" description:\"A slice of strings\"`\n\n\t\t// Example of a slice of pointers\n\t\tPtrSlice []*string `long:\"ptrslice\" description:\"A slice of pointers to string\"`\n\n\t\t// Example of a map\n\t\tIntMap map[string]int `long:\"intmap\" description:\"A map from string to int\"`\n\n\t\t// Example of a filename (useful for completion)\n\t\tFilename Filename `long:\"filename\" description:\"A filename\"`\n\n\t\t// Example of positional arguments\n\t\tArgs struct {\n\t\t\tID   string\n\t\t\tNum  int\n\t\t\tRest []string\n\t\t} `positional-args:\"yes\" required:\"yes\"`\n\t}\n\n\t// Callback which will invoke callto:<argument> to call a number.\n\t// Note that this works just on OS X (and probably only with\n\t// Skype) but it shows the idea.\n\topts.Call = func(num string) {\n\t\tcmd := exec.Command(\"open\", \"callto:\"+num)\n\t\tcmd.Start()\n\t\tcmd.Process.Release()\n\t}\n\n\t// Make some fake arguments to parse.\n\targs := []string{\n\t\t\"-vv\",\n\t\t\"--offset=5\",\n\t\t\"-n\", \"Me\",\n\t\t\"-p\", \"3\",\n\t\t\"-s\", \"hello\",\n\t\t\"-s\", \"world\",\n\t\t\"--ptrslice\", \"hello\",\n\t\t\"--ptrslice\", \"world\",\n\t\t\"--intmap\", \"a:1\",\n\t\t\"--intmap\", \"b:5\",\n\t\t\"--filename\", \"hello.go\",\n\t\t\"id\",\n\t\t\"10\",\n\t\t\"remaining1\",\n\t\t\"remaining2\",\n\t}\n\n\t// Parse flags from `args'. Note that here we use flags.ParseArgs for\n\t// the sake of making a working example. Normally, you would simply use\n\t// flags.Parse(&opts) which uses os.Args\n\t_, err := ParseArgs(&opts, args)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Verbosity: %v\\n\", opts.Verbose)\n\tfmt.Printf(\"Offset: %d\\n\", opts.Offset)\n\tfmt.Printf(\"Name: %s\\n\", opts.Name)\n\tfmt.Printf(\"Ptr: %d\\n\", *opts.Ptr)\n\tfmt.Printf(\"StringSlice: %v\\n\", opts.StringSlice)\n\tfmt.Printf(\"PtrSlice: [%v %v]\\n\", *opts.PtrSlice[0], *opts.PtrSlice[1])\n\tfmt.Printf(\"IntMap: [a:%v b:%v]\\n\", opts.IntMap[\"a\"], opts.IntMap[\"b\"])\n\tfmt.Printf(\"Filename: %v\\n\", opts.Filename)\n\tfmt.Printf(\"Args.ID: %s\\n\", opts.Args.ID)\n\tfmt.Printf(\"Args.Num: %d\\n\", opts.Args.Num)\n\tfmt.Printf(\"Args.Rest: %v\\n\", opts.Args.Rest)\n\n\t// Output: Verbosity: [true true]\n\t// Offset: 5\n\t// Name: Me\n\t// Ptr: 3\n\t// StringSlice: [hello world]\n\t// PtrSlice: [hello world]\n\t// IntMap: [a:1 b:5]\n\t// Filename: hello.go\n\t// Args.ID: id\n\t// Args.Num: 10\n\t// Args.Rest: [remaining1 remaining2]\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "flags.go",
          "type": "blob",
          "size": 11.9677734375,
          "content": "// Copyright 2012 Jesse van den Kieboom. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n/*\nPackage flags provides an extensive command line option parser.\nThe flags package is similar in functionality to the go built-in flag package\nbut provides more options and uses reflection to provide a convenient and\nsuccinct way of specifying command line options.\n\n# Supported features\n\nThe following features are supported in go-flags:\n\n\tOptions with short names (-v)\n\tOptions with long names (--verbose)\n\tOptions with and without arguments (bool v.s. other type)\n\tOptions with optional arguments and default values\n\tOption default values from ENVIRONMENT_VARIABLES, including slice and map values\n\tMultiple option groups each containing a set of options\n\tGenerate and print well-formatted help message\n\tPassing remaining command line arguments after -- (optional)\n\tIgnoring unknown command line options (optional)\n\tSupports -I/usr/include -I=/usr/include -I /usr/include option argument specification\n\tSupports multiple short options -aux\n\tSupports all primitive go types (string, int{8..64}, uint{8..64}, float)\n\tSupports same option multiple times (can store in slice or last option counts)\n\tSupports maps\n\tSupports function callbacks\n\tSupports namespaces for (nested) option groups\n\nAdditional features specific to Windows:\n\n\tOptions with short names (/v)\n\tOptions with long names (/verbose)\n\tWindows-style options with arguments use a colon as the delimiter\n\tModify generated help message with Windows-style / options\n\tWindows style options can be disabled at build time using the \"forceposix\"\n\tbuild tag\n\n# Basic usage\n\nThe flags package uses structs, reflection and struct field tags\nto allow users to specify command line options. This results in very simple\nand concise specification of your application options. For example:\n\n\ttype Options struct {\n\t    Verbose []bool `short:\"v\" long:\"verbose\" description:\"Show verbose debug information\"`\n\t}\n\nThis specifies one option with a short name -v and a long name --verbose.\nWhen either -v or --verbose is found on the command line, a 'true' value\nwill be appended to the Verbose field. e.g. when specifying -vvv, the\nresulting value of Verbose will be {[true, true, true]}.\n\nSlice options work exactly the same as primitive type options, except that\nwhenever the option is encountered, a value is appended to the slice.\n\nMap options from string to primitive type are also supported. On the command\nline, you specify the value for such an option as key:value. For example\n\n\ttype Options struct {\n\t    AuthorInfo string[string] `short:\"a\"`\n\t}\n\nThen, the AuthorInfo map can be filled with something like\n-a name:Jesse -a \"surname:van den Kieboom\".\n\nFinally, for full control over the conversion between command line argument\nvalues and options, user defined types can choose to implement the Marshaler\nand Unmarshaler interfaces.\n\n# Available field tags\n\nThe following is a list of tags for struct fields supported by go-flags:\n\n\tshort:            the short name of the option (single character)\n\tlong:             the long name of the option\n\trequired:         if non empty, makes the option required to appear on the command\n\t                  line. If a required option is not present, the parser will\n\t                  return ErrRequired (optional)\n\tdescription:      the description of the option (optional)\n\tlong-description: the long description of the option. Currently only\n\t                  displayed in generated man pages (optional)\n\tno-flag:          if non-empty, this field is ignored as an option (optional)\n\n\toptional:       if non-empty, makes the argument of the option optional. When an\n\t                argument is optional it can only be specified using\n\t                --option=argument (optional)\n\toptional-value: the value of an optional option when the option occurs\n\t                without an argument. This tag can be specified multiple\n\t                times in the case of maps or slices (optional)\n\tdefault:        the default value of an option. This tag can be specified\n\t                multiple times in the case of slices or maps (optional)\n\tdefault-mask:   when specified, this value will be displayed in the help\n\t                instead of the actual default value. This is useful\n\t                mostly for hiding otherwise sensitive information from\n\t                showing up in the help. If default-mask takes the special\n\t                value \"-\", then no default value will be shown at all\n\t                (optional)\n\tenv:            the default value of the option is overridden from the\n\t                specified environment variable, if one has been defined.\n\t                (optional)\n\tenv-delim:      the 'env' default value from environment is split into\n\t                multiple values with the given delimiter string, use with\n\t                slices and maps (optional)\n\tvalue-name:     the name of the argument value (to be shown in the help)\n\t                (optional)\n\tchoice:         limits the values for an option to a set of values.\n\t                Repeat this tag once for each allowable value.\n\t                e.g. `long:\"animal\" choice:\"cat\" choice:\"dog\"`\n\thidden:         if non-empty, the option is not visible in the help or man page.\n\n\tbase: a base (radix) used to convert strings to integer values, the\n\t      default base is 10 (i.e. decimal) (optional)\n\n\tini-name:       the explicit ini option name (optional)\n\tno-ini:         if non-empty this field is ignored as an ini option\n\t                (optional)\n\n\tgroup:                when specified on a struct field, makes the struct\n\t                      field a separate group with the given name (optional)\n\tnamespace:            when specified on a group struct field, the namespace\n\t                      gets prepended to every option's long name and\n\t                      subgroup's namespace of this group, separated by\n\t                      the parser's namespace delimiter (optional)\n\tenv-namespace:        when specified on a group struct field, the env-namespace\n\t                      gets prepended to every option's env key and\n\t                      subgroup's env-namespace of this group, separated by\n\t                      the parser's env-namespace delimiter (optional)\n\tcommand:              when specified on a struct field, makes the struct\n\t                      field a (sub)command with the given name (optional)\n\tsubcommands-optional: when specified on a command struct field, makes\n\t                      any subcommands of that command optional (optional)\n\talias:                when specified on a command struct field, adds the\n\t                      specified name as an alias for the command. Can be\n\t                      be specified multiple times to add more than one\n\t                      alias (optional)\n\tpositional-args:      when specified on a field with a struct type,\n\t                      uses the fields of that struct to parse remaining\n\t                      positional command line arguments into (in order\n\t                      of the fields). If a field has a slice type,\n\t                      then all remaining arguments will be added to it.\n\t                      Positional arguments are optional by default,\n\t                      unless the \"required\" tag is specified together\n\t                      with the \"positional-args\" tag. The \"required\" tag\n\t                      can also be set on the individual rest argument\n\t                      fields, to require only the first N positional\n\t                      arguments. If the \"required\" tag is set on the\n\t                      rest arguments slice, then its value determines\n\t                      the minimum amount of rest arguments that needs to\n\t                      be provided (e.g. `required:\"2\"`) (optional)\n\tpositional-arg-name:  used on a field in a positional argument struct; name\n\t                      of the positional argument placeholder to be shown in\n\t                      the help (optional)\n\nEither the `short:` tag or the `long:` must be specified to make the field eligible as an\noption.\n\n# Option groups\n\nOption groups are a simple way to semantically separate your options. All\noptions in a particular group are shown together in the help under the name\nof the group. Namespaces can be used to specify option long names more\nprecisely and emphasize the options affiliation to their group.\n\nThere are currently three ways to specify option groups.\n\n 1. Use NewNamedParser specifying the various option groups.\n 2. Use AddGroup to add a group to an existing parser.\n 3. Add a struct field to the top-level options annotated with the\n    group:\"group-name\" tag.\n\n# Commands\n\nThe flags package also has basic support for commands. Commands are often\nused in monolithic applications that support various commands or actions.\nTake git for example, all of the add, commit, checkout, etc. are called\ncommands. Using commands you can easily separate multiple functions of your\napplication.\n\nThere are currently two ways to specify a command.\n\n 1. Use AddCommand on an existing parser.\n 2. Add a struct field to your options struct annotated with the\n    command:\"command-name\" tag.\n\nThe most common, idiomatic way to implement commands is to define a global\nparser instance and implement each command in a separate file. These\ncommand files should define a go init function which calls AddCommand on\nthe global parser.\n\nWhen parsing ends and there is an active command and that command implements\nthe Commander interface, then its Execute method will be run with the\nremaining command line arguments.\n\nCommand structs can have options which become valid to parse after the\ncommand has been specified on the command line, in addition to the options\nof all the parent commands. I.e. considering a -v flag on the parser and an\nadd command, the following are equivalent:\n\n\t./app -v add\n\t./app add -v\n\nHowever, if the -v flag is defined on the add command, then the first of\nthe two examples above would fail since the -v flag is not defined before\nthe add command.\n\n# Completion\n\ngo-flags has builtin support to provide bash completion of flags, commands\nand argument values. To use completion, the binary which uses go-flags\ncan be invoked in a special environment to list completion of the current\ncommand line argument. It should be noted that this `executes` your application,\nand it is up to the user to make sure there are no negative side effects (for\nexample from init functions).\n\nSetting the environment variable `GO_FLAGS_COMPLETION=1` enables completion\nby replacing the argument parsing routine with the completion routine which\noutputs completions for the passed arguments. The basic invocation to\ncomplete a set of arguments is therefore:\n\n\tGO_FLAGS_COMPLETION=1 ./completion-example arg1 arg2 arg3\n\nwhere `completion-example` is the binary, `arg1` and `arg2` are\nthe current arguments, and `arg3` (the last argument) is the argument\nto be completed. If the GO_FLAGS_COMPLETION is set to \"verbose\", then\ndescriptions of possible completion items will also be shown, if there\nare more than 1 completion items.\n\nTo use this with bash completion, a simple file can be written which\ncalls the binary which supports go-flags completion:\n\n\t_completion_example() {\n\t    # All arguments except the first one\n\t    args=(\"${COMP_WORDS[@]:1:$COMP_CWORD}\")\n\n\t    # Only split on newlines\n\t    local IFS=$'\\n'\n\n\t    # Call completion (note that the first element of COMP_WORDS is\n\t    # the executable itself)\n\t    COMPREPLY=($(GO_FLAGS_COMPLETION=1 ${COMP_WORDS[0]} \"${args[@]}\"))\n\t    return 0\n\t}\n\n\tcomplete -F _completion_example completion-example\n\nCompletion requires the parser option PassDoubleDash and is therefore enforced if the environment variable GO_FLAGS_COMPLETION is set.\n\nCustomized completion for argument values is supported by implementing\nthe flags.Completer interface for the argument value type. An example\nof a type which does so is the flags.Filename type, an alias of string\nallowing simple filename completion. A slice or array argument value\nwhose element type implements flags.Completer will also be completed.\n*/\npackage flags\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1142578125,
          "content": "module github.com/jessevdk/go-flags\n\ngo 1.20\n\nrequire (\n\tgithub.com/sergi/go-diff v1.3.1\n\tgolang.org/x/sys v0.21.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.6669921875,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/sergi/go-diff v1.3.1 h1:xkr+Oxo4BOQKmkn/B9eMK0g5Kg/983T9DqqPHwYqD+8=\ngithub.com/sergi/go-diff v1.3.1/go.mod h1:aMJSSKb2lpPvRNec0+w3fl7LP9IOFzdc9Pa4NFbPK1I=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngolang.org/x/sys v0.21.0 h1:rF+pYz3DAGSQAxAu1CbC7catZg4ebC4UIeIhKxBZvws=\ngolang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\n"
        },
        {
          "name": "group.go",
          "type": "blob",
          "size": 10.130859375,
          "content": "// Copyright 2012 Jesse van den Kieboom. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage flags\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// ErrNotPointerToStruct indicates that a provided data container is not\n// a pointer to a struct. Only pointers to structs are valid data containers\n// for options.\nvar ErrNotPointerToStruct = errors.New(\"provided data is not a pointer to struct\")\n\n// Group represents an option group. Option groups can be used to logically\n// group options together under a description. Groups are only used to provide\n// more structure to options both for the user (as displayed in the help message)\n// and for you, since groups can be nested.\ntype Group struct {\n\t// A short description of the group. The\n\t// short description is primarily used in the built-in generated help\n\t// message\n\tShortDescription string\n\n\t// A long description of the group. The long\n\t// description is primarily used to present information on commands\n\t// (Command embeds Group) in the built-in generated help and man pages.\n\tLongDescription string\n\n\t// The namespace of the group\n\tNamespace string\n\n\t// The environment namespace of the group\n\tEnvNamespace string\n\n\t// If true, the group is not displayed in the help or man page\n\tHidden bool\n\n\t// The parent of the group or nil if it has no parent\n\tparent interface{}\n\n\t// All the options in the group\n\toptions []*Option\n\n\t// All the subgroups\n\tgroups []*Group\n\n\t// Whether the group represents the built-in help group\n\tisBuiltinHelp bool\n\n\tdata interface{}\n}\n\ntype scanHandler func(reflect.Value, *reflect.StructField) (bool, error)\n\n// AddGroup adds a new group to the command with the given name and data. The\n// data needs to be a pointer to a struct from which the fields indicate which\n// options are in the group.\nfunc (g *Group) AddGroup(shortDescription string, longDescription string, data interface{}) (*Group, error) {\n\tgroup := newGroup(shortDescription, longDescription, data)\n\n\tgroup.parent = g\n\n\tif err := group.scan(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tg.groups = append(g.groups, group)\n\treturn group, nil\n}\n\n// AddOption adds a new option to this group.\nfunc (g *Group) AddOption(option *Option, data interface{}) {\n\toption.value = reflect.ValueOf(data)\n\toption.group = g\n\tg.options = append(g.options, option)\n}\n\n// Groups returns the list of groups embedded in this group.\nfunc (g *Group) Groups() []*Group {\n\treturn g.groups\n}\n\n// Options returns the list of options in this group.\nfunc (g *Group) Options() []*Option {\n\treturn g.options\n}\n\n// Find locates the subgroup with the given short description and returns it.\n// If no such group can be found Find will return nil. Note that the description\n// is matched case insensitively.\nfunc (g *Group) Find(shortDescription string) *Group {\n\tlshortDescription := strings.ToLower(shortDescription)\n\n\tvar ret *Group\n\n\tg.eachGroup(func(gg *Group) {\n\t\tif gg != g && strings.ToLower(gg.ShortDescription) == lshortDescription {\n\t\t\tret = gg\n\t\t}\n\t})\n\n\treturn ret\n}\n\nfunc (g *Group) findOption(matcher func(*Option) bool) (option *Option) {\n\tg.eachGroup(func(g *Group) {\n\t\tfor _, opt := range g.options {\n\t\t\tif option == nil && matcher(opt) {\n\t\t\t\toption = opt\n\t\t\t}\n\t\t}\n\t})\n\n\treturn option\n}\n\n// FindOptionByLongName finds an option that is part of the group, or any of its\n// subgroups, by matching its long name (including the option namespace).\nfunc (g *Group) FindOptionByLongName(longName string) *Option {\n\treturn g.findOption(func(option *Option) bool {\n\t\treturn option.LongNameWithNamespace() == longName\n\t})\n}\n\n// FindOptionByShortName finds an option that is part of the group, or any of\n// its subgroups, by matching its short name.\nfunc (g *Group) FindOptionByShortName(shortName rune) *Option {\n\treturn g.findOption(func(option *Option) bool {\n\t\treturn option.ShortName == shortName\n\t})\n}\n\nfunc newGroup(shortDescription string, longDescription string, data interface{}) *Group {\n\treturn &Group{\n\t\tShortDescription: shortDescription,\n\t\tLongDescription:  longDescription,\n\n\t\tdata: data,\n\t}\n}\n\nfunc (g *Group) optionByName(name string, namematch func(*Option, string) bool) *Option {\n\tprio := 0\n\tvar retopt *Option\n\n\tg.eachGroup(func(g *Group) {\n\t\tfor _, opt := range g.options {\n\t\t\tif namematch != nil && namematch(opt, name) && prio < 4 {\n\t\t\t\tretopt = opt\n\t\t\t\tprio = 4\n\t\t\t}\n\n\t\t\tif name == opt.field.Name && prio < 3 {\n\t\t\t\tretopt = opt\n\t\t\t\tprio = 3\n\t\t\t}\n\n\t\t\tif name == opt.LongNameWithNamespace() && prio < 2 {\n\t\t\t\tretopt = opt\n\t\t\t\tprio = 2\n\t\t\t}\n\n\t\t\tif opt.ShortName != 0 && name == string(opt.ShortName) && prio < 1 {\n\t\t\t\tretopt = opt\n\t\t\t\tprio = 1\n\t\t\t}\n\t\t}\n\t})\n\n\treturn retopt\n}\n\nfunc (g *Group) showInHelp() bool {\n\tif g.Hidden {\n\t\treturn false\n\t}\n\tfor _, opt := range g.options {\n\t\tif opt.showInHelp() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (g *Group) eachGroup(f func(*Group)) {\n\tf(g)\n\n\tfor _, gg := range g.groups {\n\t\tgg.eachGroup(f)\n\t}\n}\n\nfunc isStringFalsy(s string) bool {\n\treturn s == \"\" || s == \"false\" || s == \"no\" || s == \"0\"\n}\n\nfunc (g *Group) scanStruct(realval reflect.Value, sfield *reflect.StructField, handler scanHandler) error {\n\tstype := realval.Type()\n\n\tif sfield != nil {\n\t\tif ok, err := handler(realval, sfield); err != nil {\n\t\t\treturn err\n\t\t} else if ok {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfor i := 0; i < stype.NumField(); i++ {\n\t\tfield := stype.Field(i)\n\n\t\t// PkgName is set only for non-exported fields, which we ignore\n\t\tif field.PkgPath != \"\" && !field.Anonymous {\n\t\t\tcontinue\n\t\t}\n\n\t\tmtag := newMultiTag(string(field.Tag))\n\n\t\tif err := mtag.Parse(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Skip fields with the no-flag tag\n\t\tif mtag.Get(\"no-flag\") != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Dive deep into structs or pointers to structs\n\t\tkind := field.Type.Kind()\n\t\tfld := realval.Field(i)\n\n\t\tif kind == reflect.Struct {\n\t\t\tif err := g.scanStruct(fld, &field, handler); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if kind == reflect.Ptr && field.Type.Elem().Kind() == reflect.Struct {\n\t\t\tflagCountBefore := len(g.options) + len(g.groups)\n\n\t\t\tif fld.IsNil() {\n\t\t\t\tfld = reflect.New(fld.Type().Elem())\n\t\t\t}\n\n\t\t\tif err := g.scanStruct(reflect.Indirect(fld), &field, handler); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif len(g.options)+len(g.groups) != flagCountBefore {\n\t\t\t\trealval.Field(i).Set(fld)\n\t\t\t}\n\t\t}\n\n\t\tlongname := mtag.Get(\"long\")\n\t\tshortname := mtag.Get(\"short\")\n\n\t\t// Need at least either a short or long name\n\t\tif longname == \"\" && shortname == \"\" && mtag.Get(\"ini-name\") == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tshort := rune(0)\n\t\trc := utf8.RuneCountInString(shortname)\n\n\t\tif rc > 1 {\n\t\t\treturn newErrorf(ErrShortNameTooLong,\n\t\t\t\t\"short names can only be 1 character long, not `%s'\",\n\t\t\t\tshortname)\n\n\t\t} else if rc == 1 {\n\t\t\tshort, _ = utf8.DecodeRuneInString(shortname)\n\t\t}\n\n\t\tdescription := mtag.Get(\"description\")\n\t\tdef := mtag.GetMany(\"default\")\n\n\t\toptionalValue := mtag.GetMany(\"optional-value\")\n\t\tvalueName := mtag.Get(\"value-name\")\n\t\tdefaultMask := mtag.Get(\"default-mask\")\n\n\t\toptional := !isStringFalsy(mtag.Get(\"optional\"))\n\t\trequired := !isStringFalsy(mtag.Get(\"required\"))\n\t\tchoices := mtag.GetMany(\"choice\")\n\t\thidden := !isStringFalsy(mtag.Get(\"hidden\"))\n\n\t\toption := &Option{\n\t\t\tDescription:      description,\n\t\t\tShortName:        short,\n\t\t\tLongName:         longname,\n\t\t\tDefault:          def,\n\t\t\tEnvDefaultKey:    mtag.Get(\"env\"),\n\t\t\tEnvDefaultDelim:  mtag.Get(\"env-delim\"),\n\t\t\tOptionalArgument: optional,\n\t\t\tOptionalValue:    optionalValue,\n\t\t\tRequired:         required,\n\t\t\tValueName:        valueName,\n\t\t\tDefaultMask:      defaultMask,\n\t\t\tChoices:          choices,\n\t\t\tHidden:           hidden,\n\n\t\t\tgroup: g,\n\n\t\t\tfield: field,\n\t\t\tvalue: realval.Field(i),\n\t\t\ttag:   mtag,\n\t\t}\n\n\t\tif option.isBool() && option.Default != nil {\n\t\t\treturn newErrorf(ErrInvalidTag,\n\t\t\t\t\"boolean flag `%s' may not have default values, they always default to `false' and can only be turned on\",\n\t\t\t\toption.shortAndLongName())\n\t\t}\n\n\t\tg.options = append(g.options, option)\n\t}\n\n\treturn nil\n}\n\nfunc (g *Group) checkForDuplicateFlags() *Error {\n\tshortNames := make(map[rune]*Option)\n\tlongNames := make(map[string]*Option)\n\n\tvar duplicateError *Error\n\n\tg.eachGroup(func(g *Group) {\n\t\tfor _, option := range g.options {\n\t\t\tif option.LongName != \"\" {\n\t\t\t\tlongName := option.LongNameWithNamespace()\n\n\t\t\t\tif otherOption, ok := longNames[longName]; ok {\n\t\t\t\t\tduplicateError = newErrorf(ErrDuplicatedFlag, \"option `%s' uses the same long name as option `%s'\", option, otherOption)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlongNames[longName] = option\n\t\t\t}\n\t\t\tif option.ShortName != 0 {\n\t\t\t\tif otherOption, ok := shortNames[option.ShortName]; ok {\n\t\t\t\t\tduplicateError = newErrorf(ErrDuplicatedFlag, \"option `%s' uses the same short name as option `%s'\", option, otherOption)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tshortNames[option.ShortName] = option\n\t\t\t}\n\t\t}\n\t})\n\n\treturn duplicateError\n}\n\nfunc (g *Group) scanSubGroupHandler(realval reflect.Value, sfield *reflect.StructField) (bool, error) {\n\tmtag := newMultiTag(string(sfield.Tag))\n\n\tif err := mtag.Parse(); err != nil {\n\t\treturn true, err\n\t}\n\n\tsubgroup := mtag.Get(\"group\")\n\n\tif len(subgroup) != 0 {\n\t\tvar ptrval reflect.Value\n\n\t\tif realval.Kind() == reflect.Ptr {\n\t\t\tptrval = realval\n\n\t\t\tif ptrval.IsNil() {\n\t\t\t\tptrval.Set(reflect.New(ptrval.Type()))\n\t\t\t}\n\t\t} else {\n\t\t\tptrval = realval.Addr()\n\t\t}\n\n\t\tdescription := mtag.Get(\"description\")\n\n\t\tgroup, err := g.AddGroup(subgroup, description, ptrval.Interface())\n\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\n\t\tgroup.Namespace = mtag.Get(\"namespace\")\n\t\tgroup.EnvNamespace = mtag.Get(\"env-namespace\")\n\t\tgroup.Hidden = mtag.Get(\"hidden\") != \"\"\n\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\nfunc (g *Group) scanType(handler scanHandler) error {\n\t// Get all the public fields in the data struct\n\tptrval := reflect.ValueOf(g.data)\n\n\tif ptrval.Type().Kind() != reflect.Ptr {\n\t\tpanic(ErrNotPointerToStruct)\n\t}\n\n\tstype := ptrval.Type().Elem()\n\n\tif stype.Kind() != reflect.Struct {\n\t\tpanic(ErrNotPointerToStruct)\n\t}\n\n\trealval := reflect.Indirect(ptrval)\n\n\tif err := g.scanStruct(realval, nil, handler); err != nil {\n\t\treturn err\n\t}\n\n\tif err := g.checkForDuplicateFlags(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (g *Group) scan() error {\n\treturn g.scanType(g.scanSubGroupHandler)\n}\n\nfunc (g *Group) groupByName(name string) *Group {\n\tif len(name) == 0 {\n\t\treturn g\n\t}\n\n\treturn g.Find(name)\n}\n"
        },
        {
          "name": "group_test.go",
          "type": "blob",
          "size": 5.5576171875,
          "content": "package flags\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGroupInline(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tGroup struct {\n\t\t\tG bool `short:\"g\"`\n\t\t} `group:\"Grouped Options\"`\n\t}{}\n\n\tp, ret := assertParserSuccess(t, &opts, \"-v\", \"-g\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.Group.G {\n\t\tt.Errorf(\"Expected Group.G to be true\")\n\t}\n\n\tif p.Command.Group.Find(\"Grouped Options\") == nil {\n\t\tt.Errorf(\"Expected to find group `Grouped Options'\")\n\t}\n}\n\nfunc TestGroupAdd(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\t}{}\n\n\tvar grp = struct {\n\t\tG bool `short:\"g\"`\n\t}{}\n\n\tp := NewParser(&opts, Default)\n\tg, err := p.AddGroup(\"Grouped Options\", \"\", &grp)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tret, err := p.ParseArgs([]string{\"-v\", \"-g\", \"rest\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tassertStringArray(t, ret, []string{\"rest\"})\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !grp.G {\n\t\tt.Errorf(\"Expected Group.G to be true\")\n\t}\n\n\tif p.Command.Group.Find(\"Grouped Options\") != g {\n\t\tt.Errorf(\"Expected to find group `Grouped Options'\")\n\t}\n\n\tif p.Groups()[1] != g {\n\t\tt.Errorf(\"Expected group %#v, but got %#v\", g, p.Groups()[0])\n\t}\n\n\tif g.Options()[0].ShortName != 'g' {\n\t\tt.Errorf(\"Expected short name `g' but got %v\", g.Options()[0].ShortName)\n\t}\n}\n\nfunc TestGroupNestedInline(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tGroup struct {\n\t\t\tG bool `short:\"g\"`\n\n\t\t\tNested struct {\n\t\t\t\tN string `long:\"n\"`\n\t\t\t} `group:\"Nested Options\"`\n\t\t} `group:\"Grouped Options\"`\n\t}{}\n\n\tp, ret := assertParserSuccess(t, &opts, \"-v\", \"-g\", \"--n\", \"n\", \"rest\")\n\n\tassertStringArray(t, ret, []string{\"rest\"})\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tif !opts.Group.G {\n\t\tt.Errorf(\"Expected Group.G to be true\")\n\t}\n\n\tassertString(t, opts.Group.Nested.N, \"n\")\n\n\tif p.Command.Group.Find(\"Grouped Options\") == nil {\n\t\tt.Errorf(\"Expected to find group `Grouped Options'\")\n\t}\n\n\tif p.Command.Group.Find(\"Nested Options\") == nil {\n\t\tt.Errorf(\"Expected to find group `Nested Options'\")\n\t}\n}\n\nfunc TestGroupNestedInlineNamespace(t *testing.T) {\n\tvar opts = struct {\n\t\tOpt string `long:\"opt\"`\n\n\t\tGroup struct {\n\t\t\tOpt   string `long:\"opt\"`\n\t\t\tGroup struct {\n\t\t\t\tOpt string `long:\"opt\"`\n\t\t\t} `group:\"Subsubgroup\" namespace:\"sap\"`\n\t\t} `group:\"Subgroup\" namespace:\"sip\"`\n\t}{}\n\n\tp, ret := assertParserSuccess(t, &opts, \"--opt\", \"a\", \"--sip.opt\", \"b\", \"--sip.sap.opt\", \"c\", \"rest\")\n\n\tassertStringArray(t, ret, []string{\"rest\"})\n\n\tassertString(t, opts.Opt, \"a\")\n\tassertString(t, opts.Group.Opt, \"b\")\n\tassertString(t, opts.Group.Group.Opt, \"c\")\n\n\tfor _, name := range []string{\"Subgroup\", \"Subsubgroup\"} {\n\t\tif p.Command.Group.Find(name) == nil {\n\t\t\tt.Errorf(\"Expected to find group '%s'\", name)\n\t\t}\n\t}\n}\n\nfunc TestDuplicateShortFlags(t *testing.T) {\n\tvar opts struct {\n\t\tVerbose   []bool   `short:\"v\" long:\"verbose\" description:\"Show verbose debug information\"`\n\t\tVariables []string `short:\"v\" long:\"variable\" description:\"Set a variable value.\"`\n\t}\n\n\targs := []string{\n\t\t\"--verbose\",\n\t\t\"-v\", \"123\",\n\t\t\"-v\", \"456\",\n\t}\n\n\t_, err := ParseArgs(&opts, args)\n\n\tif err == nil {\n\t\tt.Errorf(\"Expected an error with type ErrDuplicatedFlag\")\n\t} else {\n\t\terr2 := err.(*Error)\n\t\tif err2.Type != ErrDuplicatedFlag {\n\t\t\tt.Errorf(\"Expected an error with type ErrDuplicatedFlag\")\n\t\t}\n\t}\n}\n\nfunc TestDuplicateLongFlags(t *testing.T) {\n\tvar opts struct {\n\t\tTest1 []bool   `short:\"a\" long:\"testing\" description:\"Test 1\"`\n\t\tTest2 []string `short:\"b\" long:\"testing\" description:\"Test 2.\"`\n\t}\n\n\targs := []string{\n\t\t\"--testing\",\n\t}\n\n\t_, err := ParseArgs(&opts, args)\n\n\tif err == nil {\n\t\tt.Errorf(\"Expected an error with type ErrDuplicatedFlag\")\n\t} else {\n\t\terr2 := err.(*Error)\n\t\tif err2.Type != ErrDuplicatedFlag {\n\t\t\tt.Errorf(\"Expected an error with type ErrDuplicatedFlag\")\n\t\t}\n\t}\n}\n\nfunc TestFindOptionByLongFlag(t *testing.T) {\n\tvar opts struct {\n\t\tTesting bool `long:\"testing\" description:\"Testing\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\topt := p.FindOptionByLongName(\"testing\")\n\n\tif opt == nil {\n\t\tt.Errorf(\"Expected option, but found none\")\n\t}\n\n\tassertString(t, opt.LongName, \"testing\")\n}\n\nfunc TestFindOptionByShortFlag(t *testing.T) {\n\tvar opts struct {\n\t\tTesting bool `short:\"t\" description:\"Testing\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\topt := p.FindOptionByShortName('t')\n\n\tif opt == nil {\n\t\tt.Errorf(\"Expected option, but found none\")\n\t}\n\n\tif opt.ShortName != 't' {\n\t\tt.Errorf(\"Expected 't', but got %v\", opt.ShortName)\n\t}\n}\n\nfunc TestFindOptionByLongFlagInSubGroup(t *testing.T) {\n\tvar opts struct {\n\t\tGroup struct {\n\t\t\tTesting bool `long:\"testing\" description:\"Testing\"`\n\t\t} `group:\"sub-group\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\topt := p.FindOptionByLongName(\"testing\")\n\n\tif opt == nil {\n\t\tt.Errorf(\"Expected option, but found none\")\n\t}\n\n\tassertString(t, opt.LongName, \"testing\")\n}\n\nfunc TestFindOptionByShortFlagInSubGroup(t *testing.T) {\n\tvar opts struct {\n\t\tGroup struct {\n\t\t\tTesting bool `short:\"t\" description:\"Testing\"`\n\t\t} `group:\"sub-group\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\topt := p.FindOptionByShortName('t')\n\n\tif opt == nil {\n\t\tt.Errorf(\"Expected option, but found none\")\n\t}\n\n\tif opt.ShortName != 't' {\n\t\tt.Errorf(\"Expected 't', but got %v\", opt.ShortName)\n\t}\n}\n\nfunc TestAddOptionNonOptional(t *testing.T) {\n\tvar opts struct {\n\t\tTest bool\n\t}\n\tp := NewParser(&opts, Default)\n\tp.AddOption(&Option{\n\t\tLongName: \"test\",\n\t}, &opts.Test)\n\t_, err := p.ParseArgs([]string{\"--test\"})\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err)\n\t} else if !opts.Test {\n\t\tt.Errorf(\"option not set\")\n\t}\n}\n"
        },
        {
          "name": "help.go",
          "type": "blob",
          "size": 9.6923828125,
          "content": "// Copyright 2012 Jesse van den Kieboom. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage flags\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"runtime\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\ntype alignmentInfo struct {\n\tmaxLongLen      int\n\thasShort        bool\n\thasValueName    bool\n\tterminalColumns int\n\tindent          bool\n}\n\nconst (\n\tpaddingBeforeOption                 = 2\n\tdistanceBetweenOptionAndDescription = 2\n)\n\nfunc (a *alignmentInfo) descriptionStart() int {\n\tret := a.maxLongLen + distanceBetweenOptionAndDescription\n\n\tif a.hasShort {\n\t\tret += 2\n\t}\n\n\tif a.maxLongLen > 0 {\n\t\tret += 4\n\t}\n\n\tif a.hasValueName {\n\t\tret += 3\n\t}\n\n\treturn ret\n}\n\nfunc (a *alignmentInfo) updateLen(name string, indent bool) {\n\tl := utf8.RuneCountInString(name)\n\n\tif indent {\n\t\tl = l + 4\n\t}\n\n\tif l > a.maxLongLen {\n\t\ta.maxLongLen = l\n\t}\n}\n\nfunc (p *Parser) getAlignmentInfo() alignmentInfo {\n\tret := alignmentInfo{\n\t\tmaxLongLen:      0,\n\t\thasShort:        false,\n\t\thasValueName:    false,\n\t\tterminalColumns: getTerminalColumns(),\n\t}\n\n\tif ret.terminalColumns <= 0 {\n\t\tret.terminalColumns = 80\n\t}\n\n\tvar prevcmd *Command\n\n\tp.eachActiveGroup(func(c *Command, grp *Group) {\n\t\tif c != prevcmd {\n\t\t\tfor _, arg := range c.args {\n\t\t\t\tret.updateLen(arg.Name, c != p.Command)\n\t\t\t}\n\t\t\tprevcmd = c\n\t\t}\n\t\tif !grp.showInHelp() {\n\t\t\treturn\n\t\t}\n\t\tfor _, info := range grp.options {\n\t\t\tif !info.showInHelp() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif info.ShortName != 0 {\n\t\t\t\tret.hasShort = true\n\t\t\t}\n\n\t\t\tif len(info.ValueName) > 0 {\n\t\t\t\tret.hasValueName = true\n\t\t\t}\n\n\t\t\tl := info.LongNameWithNamespace() + info.ValueName\n\n\t\t\tif len(info.Choices) != 0 {\n\t\t\t\tl += \"[\" + strings.Join(info.Choices, \"|\") + \"]\"\n\t\t\t}\n\n\t\t\tret.updateLen(l, c != p.Command)\n\t\t}\n\t})\n\n\treturn ret\n}\n\nfunc wrapText(s string, l int, prefix string) string {\n\tvar ret string\n\n\tif l < 10 {\n\t\tl = 10\n\t}\n\n\t// Basic text wrapping of s at spaces to fit in l\n\tlines := strings.Split(s, \"\\n\")\n\n\tfor _, line := range lines {\n\t\tvar retline string\n\n\t\tline = strings.TrimSpace(line)\n\n\t\tfor len(line) > l {\n\t\t\t// Try to split on space\n\t\t\tsuffix := \"\"\n\n\t\t\tpos := strings.LastIndex(line[:l], \" \")\n\n\t\t\tif pos < 0 {\n\t\t\t\tpos = l - 1\n\t\t\t\tsuffix = \"-\\n\"\n\t\t\t}\n\n\t\t\tif len(retline) != 0 {\n\t\t\t\tretline += \"\\n\" + prefix\n\t\t\t}\n\n\t\t\tretline += strings.TrimSpace(line[:pos]) + suffix\n\t\t\tline = strings.TrimSpace(line[pos:])\n\t\t}\n\n\t\tif len(line) > 0 {\n\t\t\tif len(retline) != 0 {\n\t\t\t\tretline += \"\\n\" + prefix\n\t\t\t}\n\n\t\t\tretline += line\n\t\t}\n\n\t\tif len(ret) > 0 {\n\t\t\tret += \"\\n\"\n\n\t\t\tif len(retline) > 0 {\n\t\t\t\tret += prefix\n\t\t\t}\n\t\t}\n\n\t\tret += retline\n\t}\n\n\treturn ret\n}\n\nfunc (p *Parser) writeHelpOption(writer *bufio.Writer, option *Option, info alignmentInfo) {\n\tline := &bytes.Buffer{}\n\n\tprefix := paddingBeforeOption\n\n\tif info.indent {\n\t\tprefix += 4\n\t}\n\n\tif option.Hidden {\n\t\treturn\n\t}\n\n\tline.WriteString(strings.Repeat(\" \", prefix))\n\n\tif option.ShortName != 0 {\n\t\tline.WriteRune(defaultShortOptDelimiter)\n\t\tline.WriteRune(option.ShortName)\n\t} else if info.hasShort {\n\t\tline.WriteString(\"  \")\n\t}\n\n\tdescstart := info.descriptionStart() + paddingBeforeOption\n\n\tif len(option.LongName) > 0 {\n\t\tif option.ShortName != 0 {\n\t\t\tline.WriteString(\", \")\n\t\t} else if info.hasShort {\n\t\t\tline.WriteString(\"  \")\n\t\t}\n\n\t\tline.WriteString(defaultLongOptDelimiter)\n\t\tline.WriteString(option.LongNameWithNamespace())\n\t}\n\n\tif option.canArgument() {\n\t\tline.WriteRune(defaultNameArgDelimiter)\n\n\t\tif len(option.ValueName) > 0 {\n\t\t\tline.WriteString(option.ValueName)\n\t\t}\n\n\t\tif len(option.Choices) > 0 {\n\t\t\tline.WriteString(\"[\" + strings.Join(option.Choices, \"|\") + \"]\")\n\t\t}\n\t}\n\n\twritten := line.Len()\n\tline.WriteTo(writer)\n\n\tif option.Description != \"\" {\n\t\tdw := descstart - written\n\t\twriter.WriteString(strings.Repeat(\" \", dw))\n\n\t\tvar def string\n\n\t\tif len(option.DefaultMask) != 0 {\n\t\t\tif option.DefaultMask != \"-\" {\n\t\t\t\tdef = option.DefaultMask\n\t\t\t}\n\t\t} else {\n\t\t\tdef = option.defaultLiteral\n\t\t}\n\n\t\tvar envDef string\n\t\tif option.EnvKeyWithNamespace() != \"\" {\n\t\t\tvar envPrintable string\n\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\tenvPrintable = \"%\" + option.EnvKeyWithNamespace() + \"%\"\n\t\t\t} else {\n\t\t\t\tenvPrintable = \"$\" + option.EnvKeyWithNamespace()\n\t\t\t}\n\t\t\tenvDef = fmt.Sprintf(\" [%s]\", envPrintable)\n\t\t}\n\n\t\tvar desc string\n\n\t\tif def != \"\" {\n\t\t\tdesc = fmt.Sprintf(\"%s (default: %v)%s\", option.Description, def, envDef)\n\t\t} else {\n\t\t\tdesc = option.Description + envDef\n\t\t}\n\n\t\twriter.WriteString(wrapText(desc,\n\t\t\tinfo.terminalColumns-descstart,\n\t\t\tstrings.Repeat(\" \", descstart)))\n\t}\n\n\twriter.WriteString(\"\\n\")\n}\n\nfunc maxCommandLength(s []*Command) int {\n\tif len(s) == 0 {\n\t\treturn 0\n\t}\n\n\tret := len(s[0].Name)\n\n\tfor _, v := range s[1:] {\n\t\tl := len(v.Name)\n\n\t\tif l > ret {\n\t\t\tret = l\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// WriteHelp writes a help message containing all the possible options and\n// their descriptions to the provided writer. Note that the HelpFlag parser\n// option provides a convenient way to add a -h/--help option group to the\n// command line parser which will automatically show the help messages using\n// this method.\nfunc (p *Parser) WriteHelp(writer io.Writer) {\n\tif writer == nil {\n\t\treturn\n\t}\n\n\twr := bufio.NewWriter(writer)\n\taligninfo := p.getAlignmentInfo()\n\n\tcmd := p.Command\n\n\tfor cmd.Active != nil {\n\t\tcmd = cmd.Active\n\t}\n\n\tif p.Name != \"\" {\n\t\twr.WriteString(\"Usage:\\n\")\n\t\twr.WriteString(\" \")\n\n\t\tallcmd := p.Command\n\n\t\tfor allcmd != nil {\n\t\t\tvar usage string\n\n\t\t\tif allcmd == p.Command {\n\t\t\t\tif len(p.Usage) != 0 {\n\t\t\t\t\tusage = p.Usage\n\t\t\t\t} else if p.Options&HelpFlag != 0 {\n\t\t\t\t\tusage = \"[OPTIONS]\"\n\t\t\t\t}\n\t\t\t} else if us, ok := allcmd.data.(Usage); ok {\n\t\t\t\tusage = us.Usage()\n\t\t\t} else if allcmd.hasHelpOptions() {\n\t\t\t\tusage = fmt.Sprintf(\"[%s-OPTIONS]\", allcmd.Name)\n\t\t\t}\n\n\t\t\tif len(usage) != 0 {\n\t\t\t\tfmt.Fprintf(wr, \" %s %s\", allcmd.Name, usage)\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(wr, \" %s\", allcmd.Name)\n\t\t\t}\n\n\t\t\tif len(allcmd.args) > 0 {\n\t\t\t\tfmt.Fprintf(wr, \" \")\n\t\t\t}\n\n\t\t\tfor i, arg := range allcmd.args {\n\t\t\t\tif i != 0 {\n\t\t\t\t\tfmt.Fprintf(wr, \" \")\n\t\t\t\t}\n\n\t\t\t\tname := arg.Name\n\n\t\t\t\tif arg.isRemaining() {\n\t\t\t\t\tname = name + \"...\"\n\t\t\t\t}\n\n\t\t\t\tif !allcmd.ArgsRequired {\n\t\t\t\t\tif arg.Required > 0 {\n\t\t\t\t\t\tfmt.Fprintf(wr, \"%s\", name)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfmt.Fprintf(wr, \"[%s]\", name)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintf(wr, \"%s\", name)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif allcmd.Active == nil && len(allcmd.commands) > 0 {\n\t\t\t\tvar co, cc string\n\n\t\t\t\tif allcmd.SubcommandsOptional {\n\t\t\t\t\tco, cc = \"[\", \"]\"\n\t\t\t\t} else {\n\t\t\t\t\tco, cc = \"<\", \">\"\n\t\t\t\t}\n\n\t\t\t\tvisibleCommands := allcmd.visibleCommands()\n\n\t\t\t\tif len(visibleCommands) > 3 {\n\t\t\t\t\tfmt.Fprintf(wr, \" %scommand%s\", co, cc)\n\t\t\t\t} else {\n\t\t\t\t\tsubcommands := allcmd.sortedVisibleCommands()\n\t\t\t\t\tnames := make([]string, len(subcommands))\n\n\t\t\t\t\tfor i, subc := range subcommands {\n\t\t\t\t\t\tnames[i] = subc.Name\n\t\t\t\t\t}\n\n\t\t\t\t\tfmt.Fprintf(wr, \" %s%s%s\", co, strings.Join(names, \" | \"), cc)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tallcmd = allcmd.Active\n\t\t}\n\n\t\tfmt.Fprintln(wr)\n\n\t\tif len(cmd.LongDescription) != 0 {\n\t\t\tfmt.Fprintln(wr)\n\n\t\t\tt := wrapText(cmd.LongDescription,\n\t\t\t\taligninfo.terminalColumns,\n\t\t\t\t\"\")\n\n\t\t\tfmt.Fprintln(wr, t)\n\t\t}\n\t}\n\n\tc := p.Command\n\n\tfor c != nil {\n\t\tprintcmd := c != p.Command\n\n\t\tc.eachGroup(func(grp *Group) {\n\t\t\tfirst := true\n\n\t\t\t// Skip built-in help group for all commands except the top-level\n\t\t\t// parser\n\t\t\tif grp.Hidden || (grp.isBuiltinHelp && c != p.Command) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor _, info := range grp.options {\n\t\t\t\tif !info.showInHelp() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif printcmd {\n\t\t\t\t\tfmt.Fprintf(wr, \"\\n[%s command options]\\n\", c.Name)\n\t\t\t\t\taligninfo.indent = true\n\t\t\t\t\tprintcmd = false\n\t\t\t\t}\n\n\t\t\t\tif first && cmd.Group != grp {\n\t\t\t\t\tfmt.Fprintln(wr)\n\n\t\t\t\t\tif aligninfo.indent {\n\t\t\t\t\t\twr.WriteString(\"    \")\n\t\t\t\t\t}\n\n\t\t\t\t\tfmt.Fprintf(wr, \"%s:\\n\", grp.ShortDescription)\n\t\t\t\t\tfirst = false\n\t\t\t\t}\n\n\t\t\t\tp.writeHelpOption(wr, info, aligninfo)\n\t\t\t}\n\t\t})\n\n\t\tvar args []*Arg\n\t\tfor _, arg := range c.args {\n\t\t\tif arg.Description != \"\" {\n\t\t\t\targs = append(args, arg)\n\t\t\t}\n\t\t}\n\n\t\tif len(args) > 0 {\n\t\t\tif c == p.Command {\n\t\t\t\tfmt.Fprintf(wr, \"\\nArguments:\\n\")\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(wr, \"\\n[%s command arguments]\\n\", c.Name)\n\t\t\t}\n\n\t\t\tdescStart := aligninfo.descriptionStart() + paddingBeforeOption\n\n\t\t\tfor _, arg := range args {\n\t\t\t\targPrefix := strings.Repeat(\" \", paddingBeforeOption)\n\t\t\t\targPrefix += arg.Name\n\n\t\t\t\tif len(arg.Description) > 0 {\n\t\t\t\t\targPrefix += \":\"\n\t\t\t\t\twr.WriteString(argPrefix)\n\n\t\t\t\t\t// Space between \"arg:\" and the description start\n\t\t\t\t\tdescPadding := strings.Repeat(\" \", descStart-len(argPrefix))\n\t\t\t\t\t// How much space the description gets before wrapping\n\t\t\t\t\tdescWidth := aligninfo.terminalColumns - 1 - descStart\n\t\t\t\t\t// Whitespace to which we can indent new description lines\n\t\t\t\t\tdescPrefix := strings.Repeat(\" \", descStart)\n\n\t\t\t\t\twr.WriteString(descPadding)\n\t\t\t\t\twr.WriteString(wrapText(arg.Description, descWidth, descPrefix))\n\t\t\t\t} else {\n\t\t\t\t\twr.WriteString(argPrefix)\n\t\t\t\t}\n\n\t\t\t\tfmt.Fprintln(wr)\n\t\t\t}\n\t\t}\n\n\t\tc = c.Active\n\t}\n\n\tscommands := cmd.sortedVisibleCommands()\n\n\tif len(scommands) > 0 {\n\t\tmaxnamelen := maxCommandLength(scommands)\n\n\t\tfmt.Fprintln(wr)\n\t\tfmt.Fprintln(wr, \"Available commands:\")\n\n\t\tfor _, c := range scommands {\n\t\t\tfmt.Fprintf(wr, \"  %s\", c.Name)\n\n\t\t\tif len(c.ShortDescription) > 0 {\n\t\t\t\tpad := strings.Repeat(\" \", maxnamelen-len(c.Name))\n\t\t\t\tfmt.Fprintf(wr, \"%s  %s\", pad, c.ShortDescription)\n\n\t\t\t\tif len(c.Aliases) > 0 {\n\t\t\t\t\tfmt.Fprintf(wr, \" (aliases: %s)\", strings.Join(c.Aliases, \", \"))\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfmt.Fprintln(wr)\n\t\t}\n\t}\n\n\twr.Flush()\n}\n\n// WroteHelp is a helper to test the error from ParseArgs() to\n// determine if the help message was written. It is safe to\n// call without first checking that error is nil.\nfunc WroteHelp(err error) bool {\n\tif err == nil { // No error\n\t\treturn false\n\t}\n\n\tflagError, ok := err.(*Error)\n\tif !ok { // Not a go-flag error\n\t\treturn false\n\t}\n\n\tif flagError.Type != ErrHelp { // Did not print the help message\n\t\treturn false\n\t}\n\n\treturn true\n}\n"
        },
        {
          "name": "help_test.go",
          "type": "blob",
          "size": 21.8125,
          "content": "package flags\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype helpOptions struct {\n\tVerbose          []bool       `short:\"v\" long:\"verbose\" description:\"Show verbose debug information\" ini-name:\"verbose\"`\n\tCall             func(string) `short:\"c\" description:\"Call phone number\" ini-name:\"call\"`\n\tPtrSlice         []*string    `long:\"ptrslice\" description:\"A slice of pointers to string\"`\n\tEmptyDescription bool         `long:\"empty-description\"`\n\n\tDefault           string            `long:\"default\" default:\"Some\\nvalue\" description:\"Test default value\"`\n\tDefaultArray      []string          `long:\"default-array\" default:\"Some value\" default:\"Other\\tvalue\" description:\"Test default array value\"`\n\tDefaultMap        map[string]string `long:\"default-map\" default:\"some:value\" default:\"another:value\" description:\"Testdefault map value\"`\n\tEnvDefault1       string            `long:\"env-default1\" default:\"Some value\" env:\"ENV_DEFAULT\" description:\"Test env-default1 value\"`\n\tEnvDefault2       string            `long:\"env-default2\" env:\"ENV_DEFAULT\" description:\"Test env-default2 value\"`\n\tOptionWithArgName string            `long:\"opt-with-arg-name\" value-name:\"something\" description:\"Option with named argument\"`\n\tOptionWithChoices string            `long:\"opt-with-choices\" value-name:\"choice\" choice:\"dog\" choice:\"cat\" description:\"Option with choices\"`\n\tHidden            string            `long:\"hidden\" description:\"Hidden option\" hidden:\"yes\"`\n\n\tHiddenOptionWithVeryLongName bool `long:\"this-hidden-option-has-a-ridiculously-long-name\" hidden:\"yes\"`\n\n\tOnlyIni string `ini-name:\"only-ini\" description:\"Option only available in ini\"`\n\n\tOther struct {\n\t\tStringSlice []string       `short:\"s\" default:\"some\" default:\"value\" description:\"A slice of strings\"`\n\t\tIntMap      map[string]int `long:\"intmap\" default:\"a:1\" description:\"A map from string to int\" ini-name:\"int-map\"`\n\t} `group:\"Other Options\"`\n\n\tHiddenGroup struct {\n\t\tInsideHiddenGroup string `long:\"inside-hidden-group\" description:\"Inside hidden group\"`\n\t\tPadder            bool   `long:\"this-option-in-a-hidden-group-has-a-ridiculously-long-name\"`\n\t} `group:\"Hidden group\" hidden:\"yes\"`\n\n\tGroupWithOnlyHiddenOptions struct {\n\t\tSecretFlag bool `long:\"secret\" description:\"Hidden flag in a non-hidden group\" hidden:\"yes\"`\n\t} `group:\"Non-hidden group with only hidden options\"`\n\n\tGroup struct {\n\t\tOpt                  string `long:\"opt\" description:\"This is a subgroup option\"`\n\t\tHiddenInsideGroup    string `long:\"hidden-inside-group\" description:\"Hidden inside group\" hidden:\"yes\"`\n\t\tNotHiddenInsideGroup string `long:\"not-hidden-inside-group\" description:\"Not hidden inside group\" hidden:\"false\"`\n\n\t\tGroup struct {\n\t\t\tOpt string `long:\"opt\" description:\"This is a subsubgroup option\"`\n\t\t} `group:\"Subsubgroup\" namespace:\"sap\"`\n\t} `group:\"Subgroup\" namespace:\"sip\"`\n\n\tBommand struct {\n\t\tHidden bool `long:\"hidden\" description:\"A hidden option\" hidden:\"yes\"`\n\t} `command:\"bommand\" description:\"A command with only hidden options\"`\n\n\tCommand struct {\n\t\tExtraVerbose []bool `long:\"extra-verbose\" description:\"Use for extra verbosity\"`\n\t} `command:\"command\" alias:\"cm\" alias:\"cmd\" description:\"A command\"`\n\n\tHiddenCommand struct {\n\t\tExtraVerbose []bool `long:\"extra-verbose\" description:\"Use for extra verbosity\"`\n\t} `command:\"hidden-command\" description:\"A hidden command\" hidden:\"yes\"`\n\n\tParentCommand struct {\n\t\tOpt        string `long:\"opt\" description:\"This is a parent command option\"`\n\t\tSubCommand struct {\n\t\t\tOpt string `long:\"opt\" description:\"This is a sub command option\"`\n\t\t} `command:\"sub\" description:\"A sub command\"`\n\t} `command:\"parent\" description:\"A parent command\"`\n\n\tArgs struct {\n\t\tFilename     string  `positional-arg-name:\"filename\" description:\"A filename with a long description to trigger line wrapping\"`\n\t\tNumber       int     `positional-arg-name:\"num\" description:\"A number\"`\n\t\tHiddenInHelp float32 `positional-arg-name:\"hidden-in-help\" required:\"yes\"`\n\t} `positional-args:\"yes\"`\n}\n\nfunc TestHelp(t *testing.T) {\n\toldEnv := EnvSnapshot()\n\tdefer oldEnv.Restore()\n\tos.Setenv(\"ENV_DEFAULT\", \"env-def\")\n\n\tvar opts helpOptions\n\tp := NewNamedParser(\"TestHelp\", HelpFlag)\n\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\t_, err := p.ParseArgs([]string{\"--help\"})\n\n\tif err == nil {\n\t\tt.Fatalf(\"Expected help error\")\n\t}\n\n\tif e, ok := err.(*Error); !ok {\n\t\tt.Fatalf(\"Expected flags.Error, but got %T\", err)\n\t} else {\n\t\tif e.Type != ErrHelp {\n\t\t\tt.Errorf(\"Expected flags.ErrHelp type, but got %s\", e.Type)\n\t\t}\n\n\t\tvar expected string\n\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\texpected = `Usage:\n  TestHelp [OPTIONS] [filename] [num] hidden-in-help <bommand | command | parent>\n\nApplication Options:\n  /v, /verbose                              Show verbose debug information\n  /c:                                       Call phone number\n      /ptrslice:                            A slice of pointers to string\n      /empty-description\n      /default:                             Test default value (default:\n                                            \"Some\\nvalue\")\n      /default-array:                       Test default array value (default:\n                                            Some value, \"Other\\tvalue\")\n      /default-map:                         Testdefault map value (default:\n                                            some:value, another:value)\n      /env-default1:                        Test env-default1 value (default:\n                                            Some value) [%ENV_DEFAULT%]\n      /env-default2:                        Test env-default2 value\n                                            [%ENV_DEFAULT%]\n      /opt-with-arg-name:something          Option with named argument\n      /opt-with-choices:choice[dog|cat]     Option with choices\n\nOther Options:\n  /s:                                       A slice of strings (default: some,\n                                            value)\n      /intmap:                              A map from string to int (default:\n                                            a:1)\n\nSubgroup:\n      /sip.opt:                             This is a subgroup option\n      /sip.not-hidden-inside-group:         Not hidden inside group\n\nSubsubgroup:\n      /sip.sap.opt:                         This is a subsubgroup option\n\nHelp Options:\n  /?                                        Show this help message\n  /h, /help                                 Show this help message\n\nArguments:\n  filename:                                 A filename with a long description\n                                            to trigger line wrapping\n  num:                                      A number\n\nAvailable commands:\n  bommand  A command with only hidden options\n  command  A command (aliases: cm, cmd)\n  parent   A parent command\n`\n\t\t} else {\n\t\t\texpected = `Usage:\n  TestHelp [OPTIONS] [filename] [num] hidden-in-help <bommand | command | parent>\n\nApplication Options:\n  -v, --verbose                             Show verbose debug information\n  -c=                                       Call phone number\n      --ptrslice=                           A slice of pointers to string\n      --empty-description\n      --default=                            Test default value (default:\n                                            \"Some\\nvalue\")\n      --default-array=                      Test default array value (default:\n                                            Some value, \"Other\\tvalue\")\n      --default-map=                        Testdefault map value (default:\n                                            some:value, another:value)\n      --env-default1=                       Test env-default1 value (default:\n                                            Some value) [$ENV_DEFAULT]\n      --env-default2=                       Test env-default2 value\n                                            [$ENV_DEFAULT]\n      --opt-with-arg-name=something         Option with named argument\n      --opt-with-choices=choice[dog|cat]    Option with choices\n\nOther Options:\n  -s=                                       A slice of strings (default: some,\n                                            value)\n      --intmap=                             A map from string to int (default:\n                                            a:1)\n\nSubgroup:\n      --sip.opt=                            This is a subgroup option\n      --sip.not-hidden-inside-group=        Not hidden inside group\n\nSubsubgroup:\n      --sip.sap.opt=                        This is a subsubgroup option\n\nHelp Options:\n  -h, --help                                Show this help message\n\nArguments:\n  filename:                                 A filename with a long description\n                                            to trigger line wrapping\n  num:                                      A number\n\nAvailable commands:\n  bommand  A command with only hidden options\n  command  A command (aliases: cm, cmd)\n  parent   A parent command\n`\n\t\t}\n\n\t\tassertDiff(t, e.Message, expected, \"help message\")\n\t}\n}\n\nfunc TestMan(t *testing.T) {\n\toldEnv := EnvSnapshot()\n\tdefer oldEnv.Restore()\n\tos.Setenv(\"ENV_DEFAULT\", \"env-def\")\n\n\tvar opts helpOptions\n\tp := NewNamedParser(\"TestMan\", HelpFlag)\n\tp.ShortDescription = \"Test manpage generation\"\n\tp.LongDescription = \"This is a somewhat `longer' description of what this does.\\nWith multiple lines.\"\n\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\tfor _, cmd := range p.Commands() {\n\t\tcmd.LongDescription = fmt.Sprintf(\"Longer `%s' description\", cmd.Name)\n\t}\n\n\tvar buf bytes.Buffer\n\tp.WriteManPage(&buf)\n\n\tgot := buf.String()\n\n\ttt := time.Now()\n\tsource_date_epoch := os.Getenv(\"SOURCE_DATE_EPOCH\")\n\tif source_date_epoch != \"\" {\n\t\tsde, err := strconv.ParseInt(source_date_epoch, 10, 64)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"Invalid SOURCE_DATE_EPOCH: %s\", err))\n\t\t}\n\t\ttt = time.Unix(sde, 0)\n\t}\n\n\tvar envDefaultName string\n\n\tif runtime.GOOS == \"windows\" {\n\t\tenvDefaultName = \"%ENV_DEFAULT%\"\n\t} else {\n\t\tenvDefaultName = \"$ENV_DEFAULT\"\n\t}\n\n\texpected := fmt.Sprintf(`.TH TestMan 1 \"%s\"\n.SH NAME\nTestMan \\- Test manpage generation\n.SH SYNOPSIS\n\\fBTestMan\\fP [OPTIONS]\n.SH DESCRIPTION\nThis is a somewhat \\fBlonger\\fP description of what this does.\nWith multiple lines.\n.SH OPTIONS\n.SS Application Options\nThe application options\n.TP\n\\fB\\fB\\-v\\fR, \\fB\\-\\-verbose\\fR\\fP\nShow verbose debug information\n.TP\n\\fB\\fB\\-c\\fR\\fP\nCall phone number\n.TP\n\\fB\\fB\\-\\-ptrslice\\fR\\fP\nA slice of pointers to string\n.TP\n\\fB\\fB\\-\\-empty-description\\fR\\fP\n.TP\n\\fB\\fB\\-\\-default\\fR <default: \\fI\"Some\\\\nvalue\"\\fR>\\fP\nTest default value\n.TP\n\\fB\\fB\\-\\-default-array\\fR <default: \\fI\"Some value\", \"Other\\\\tvalue\"\\fR>\\fP\nTest default array value\n.TP\n\\fB\\fB\\-\\-default-map\\fR <default: \\fI\"some:value\", \"another:value\"\\fR>\\fP\nTestdefault map value\n.TP\n\\fB\\fB\\-\\-env-default1\\fR <default: \\fI\"Some value\"\\fR>\\fP\nTest env-default1 value\n.TP\n\\fB\\fB\\-\\-env-default2\\fR <default: \\fI%s\\fR>\\fP\nTest env-default2 value\n.TP\n\\fB\\fB\\-\\-opt-with-arg-name\\fR \\fIsomething\\fR\\fP\nOption with named argument\n.TP\n\\fB\\fB\\-\\-opt-with-choices\\fR \\fIchoice\\fR\\fP\nOption with choices\n.SS Other Options\n.TP\n\\fB\\fB\\-s\\fR <default: \\fI\"some\", \"value\"\\fR>\\fP\nA slice of strings\n.TP\n\\fB\\fB\\-\\-intmap\\fR <default: \\fI\"a:1\"\\fR>\\fP\nA map from string to int\n.SS Subgroup\n.TP\n\\fB\\fB\\-\\-sip.opt\\fR\\fP\nThis is a subgroup option\n.TP\n\\fB\\fB\\-\\-sip.not-hidden-inside-group\\fR\\fP\nNot hidden inside group\n.SS Subsubgroup\n.TP\n\\fB\\fB\\-\\-sip.sap.opt\\fR\\fP\nThis is a subsubgroup option\n.SH COMMANDS\n.SS bommand\nA command with only hidden options\n\nLonger \\fBbommand\\fP description\n.SS command\nA command\n\nLonger \\fBcommand\\fP description\n\n\\fBUsage\\fP: TestMan [OPTIONS] command [command-OPTIONS]\n.TP\n\n\\fBAliases\\fP: cm, cmd\n\n.TP\n\\fB\\fB\\-\\-extra-verbose\\fR\\fP\nUse for extra verbosity\n.SS parent\nA parent command\n\nLonger \\fBparent\\fP description\n\n\\fBUsage\\fP: TestMan [OPTIONS] parent [parent-OPTIONS]\n.TP\n.TP\n\\fB\\fB\\-\\-opt\\fR\\fP\nThis is a parent command option\n.SS parent sub\nA sub command\n\n\\fBUsage\\fP: TestMan [OPTIONS] parent [parent-OPTIONS] sub [sub-OPTIONS]\n.TP\n.TP\n\\fB\\fB\\-\\-opt\\fR\\fP\nThis is a sub command option\n`, tt.Format(\"2 January 2006\"), envDefaultName)\n\n\tassertDiff(t, got, expected, \"man page\")\n}\n\ntype helpCommandNoOptions struct {\n\tCommand struct {\n\t} `command:\"command\" description:\"A command\"`\n}\n\nfunc TestHelpCommand(t *testing.T) {\n\toldEnv := EnvSnapshot()\n\tdefer oldEnv.Restore()\n\tos.Setenv(\"ENV_DEFAULT\", \"env-def\")\n\n\tvar opts helpCommandNoOptions\n\tp := NewNamedParser(\"TestHelpCommand\", HelpFlag)\n\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\t_, err := p.ParseArgs([]string{\"command\", \"--help\"})\n\n\tif err == nil {\n\t\tt.Fatalf(\"Expected help error\")\n\t}\n\n\tif e, ok := err.(*Error); !ok {\n\t\tt.Fatalf(\"Expected flags.Error, but got %T\", err)\n\t} else {\n\t\tif e.Type != ErrHelp {\n\t\t\tt.Errorf(\"Expected flags.ErrHelp type, but got %s\", e.Type)\n\t\t}\n\n\t\tvar expected string\n\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\texpected = `Usage:\n  TestHelpCommand [OPTIONS] command\n\nHelp Options:\n  /?              Show this help message\n  /h, /help       Show this help message\n`\n\t\t} else {\n\t\t\texpected = `Usage:\n  TestHelpCommand [OPTIONS] command\n\nHelp Options:\n  -h, --help      Show this help message\n`\n\t\t}\n\n\t\tassertDiff(t, e.Message, expected, \"help message\")\n\t}\n}\n\nfunc TestHiddenCommandNoBuiltinHelp(t *testing.T) {\n\toldEnv := EnvSnapshot()\n\tdefer oldEnv.Restore()\n\tos.Setenv(\"ENV_DEFAULT\", \"env-def\")\n\n\t// no auto added help group\n\tp := NewNamedParser(\"TestHelpCommand\", 0)\n\t// and no usage information either\n\tp.Usage = \"\"\n\n\t// add custom help group which is not listed in --help output\n\tvar help struct {\n\t\tShowHelp func() error `short:\"h\" long:\"help\"`\n\t}\n\thelp.ShowHelp = func() error {\n\t\treturn &Error{Type: ErrHelp}\n\t}\n\thlpgrp, err := p.AddGroup(\"Help Options\", \"\", &help)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\thlpgrp.Hidden = true\n\thlp := p.FindOptionByLongName(\"help\")\n\thlp.Description = \"Show this help message\"\n\t// make sure the --help option is hidden\n\thlp.Hidden = true\n\n\t// add a hidden command\n\tvar hiddenCmdOpts struct {\n\t\tFoo        bool `short:\"f\" long:\"very-long-foo-option\" description:\"Very long foo description\"`\n\t\tBar        bool `short:\"b\" description:\"Option bar\"`\n\t\tPositional struct {\n\t\t\tPositionalFoo string `positional-arg-name:\"<positional-foo>\" description:\"positional foo\"`\n\t\t} `positional-args:\"yes\"`\n\t}\n\tcmdHidden, err := p.Command.AddCommand(\"hidden\", \"Hidden command description\", \"Long hidden command description\", &hiddenCmdOpts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\t// make it hidden\n\tcmdHidden.Hidden = true\n\tif len(cmdHidden.Options()) != 2 {\n\t\tt.Fatalf(\"unexpected options count\")\n\t}\n\t// which help we ask for explicitly\n\t_, err = p.ParseArgs([]string{\"hidden\", \"--help\"})\n\n\tif err == nil {\n\t\tt.Fatalf(\"Expected help error\")\n\t}\n\tif e, ok := err.(*Error); !ok {\n\t\tt.Fatalf(\"Expected flags.Error, but got %T\", err)\n\t} else {\n\t\tif e.Type != ErrHelp {\n\t\t\tt.Errorf(\"Expected flags.ErrHelp type, but got %s\", e.Type)\n\t\t}\n\n\t\tvar expected string\n\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\texpected = `Usage:\n  TestHelpCommand hidden [hidden-OPTIONS] [<positional-foo>]\n\nLong hidden command description\n\n[hidden command arguments]\n  <positional-foo>:         positional foo\n`\n\t\t} else {\n\t\t\texpected = `Usage:\n  TestHelpCommand hidden [hidden-OPTIONS] [<positional-foo>]\n\nLong hidden command description\n\n[hidden command arguments]\n  <positional-foo>:         positional foo\n`\n\t\t}\n\t\th := &bytes.Buffer{}\n\t\tp.WriteHelp(h)\n\n\t\tassertDiff(t, h.String(), expected, \"help message\")\n\t}\n}\n\nfunc TestHelpDefaults(t *testing.T) {\n\tvar expected string\n\n\tif runtime.GOOS == \"windows\" {\n\t\texpected = `Usage:\n  TestHelpDefaults [OPTIONS]\n\nApplication Options:\n      /with-default:               With default (default: default-value)\n      /without-default:            Without default\n      /with-programmatic-default:  With programmatic default (default:\n                                   default-value)\n\nHelp Options:\n  /?                               Show this help message\n  /h, /help                        Show this help message\n`\n\t} else {\n\t\texpected = `Usage:\n  TestHelpDefaults [OPTIONS]\n\nApplication Options:\n      --with-default=              With default (default: default-value)\n      --without-default=           Without default\n      --with-programmatic-default= With programmatic default (default:\n                                   default-value)\n\nHelp Options:\n  -h, --help                       Show this help message\n`\n\t}\n\n\ttests := []struct {\n\t\tArgs   []string\n\t\tOutput string\n\t}{\n\t\t{\n\t\t\tArgs:   []string{\"-h\"},\n\t\t\tOutput: expected,\n\t\t},\n\t\t{\n\t\t\tArgs:   []string{\"--with-default\", \"other-value\", \"--with-programmatic-default\", \"other-value\", \"-h\"},\n\t\t\tOutput: expected,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar opts struct {\n\t\t\tWithDefault             string `long:\"with-default\" default:\"default-value\" description:\"With default\"`\n\t\t\tWithoutDefault          string `long:\"without-default\" description:\"Without default\"`\n\t\t\tWithProgrammaticDefault string `long:\"with-programmatic-default\" description:\"With programmatic default\"`\n\t\t}\n\n\t\topts.WithProgrammaticDefault = \"default-value\"\n\n\t\tp := NewNamedParser(\"TestHelpDefaults\", HelpFlag)\n\t\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\t\t_, err := p.ParseArgs(test.Args)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected help error\")\n\t\t}\n\n\t\tif e, ok := err.(*Error); !ok {\n\t\t\tt.Fatalf(\"Expected flags.Error, but got %T\", err)\n\t\t} else {\n\t\t\tif e.Type != ErrHelp {\n\t\t\t\tt.Errorf(\"Expected flags.ErrHelp type, but got %s\", e.Type)\n\t\t\t}\n\n\t\t\tassertDiff(t, e.Message, test.Output, \"help message\")\n\t\t}\n\t}\n}\n\nfunc TestHelpRestArgs(t *testing.T) {\n\topts := struct {\n\t\tVerbose bool `short:\"v\"`\n\t}{}\n\n\tp := NewNamedParser(\"TestHelpDefaults\", HelpFlag)\n\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\tretargs, err := p.ParseArgs([]string{\"-h\", \"-v\", \"rest\"})\n\n\tif err == nil {\n\t\tt.Fatalf(\"Expected help error\")\n\t}\n\n\tassertStringArray(t, retargs, []string{\"-v\", \"rest\"})\n}\n\nfunc TestWrapText(t *testing.T) {\n\ts := \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n\n\tgot := wrapText(s, 60, \"      \")\n\texpected := `Lorem ipsum dolor sit amet, consectetur adipisicing elit,\n      sed do eiusmod tempor incididunt ut labore et dolore magna\n      aliqua. Ut enim ad minim veniam, quis nostrud exercitation\n      ullamco laboris nisi ut aliquip ex ea commodo consequat.\n      Duis aute irure dolor in reprehenderit in voluptate velit\n      esse cillum dolore eu fugiat nulla pariatur. Excepteur sint\n      occaecat cupidatat non proident, sunt in culpa qui officia\n      deserunt mollit anim id est laborum.`\n\n\tassertDiff(t, got, expected, \"wrapped text\")\n}\n\nfunc TestWrapParagraph(t *testing.T) {\n\ts := \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\\n\\n\"\n\ts += \"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\\n\\n\"\n\ts += \"Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\\n\\n\"\n\ts += \"Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\n\"\n\n\tgot := wrapText(s, 60, \"      \")\n\texpected := `Lorem ipsum dolor sit amet, consectetur adipisicing elit,\n      sed do eiusmod tempor incididunt ut labore et dolore magna\n      aliqua.\n\n      Ut enim ad minim veniam, quis nostrud exercitation ullamco\n      laboris nisi ut aliquip ex ea commodo consequat.\n\n      Duis aute irure dolor in reprehenderit in voluptate velit\n      esse cillum dolore eu fugiat nulla pariatur.\n\n      Excepteur sint occaecat cupidatat non proident, sunt in\n      culpa qui officia deserunt mollit anim id est laborum.\n`\n\n\tassertDiff(t, got, expected, \"wrapped paragraph\")\n}\n\nfunc TestHelpDefaultMask(t *testing.T) {\n\tvar tests = []struct {\n\t\topts    interface{}\n\t\tpresent string\n\t}{\n\t\t{\n\t\t\topts: &struct {\n\t\t\t\tValue string `short:\"v\" default:\"123\" description:\"V\"`\n\t\t\t}{},\n\t\t\tpresent: \"V (default: 123)\\n\",\n\t\t},\n\t\t{\n\t\t\topts: &struct {\n\t\t\t\tValue string `short:\"v\" default:\"123\" default-mask:\"abc\" description:\"V\"`\n\t\t\t}{},\n\t\t\tpresent: \"V (default: abc)\\n\",\n\t\t},\n\t\t{\n\t\t\topts: &struct {\n\t\t\t\tValue string `short:\"v\" default:\"123\" default-mask:\"-\" description:\"V\"`\n\t\t\t}{},\n\t\t\tpresent: \"V\\n\",\n\t\t},\n\t\t{\n\t\t\topts: &struct {\n\t\t\t\tValue string `short:\"v\" description:\"V\"`\n\t\t\t}{Value: \"123\"},\n\t\t\tpresent: \"V (default: 123)\\n\",\n\t\t},\n\t\t{\n\t\t\topts: &struct {\n\t\t\t\tValue string `short:\"v\" default-mask:\"abc\" description:\"V\"`\n\t\t\t}{Value: \"123\"},\n\t\t\tpresent: \"V (default: abc)\\n\",\n\t\t},\n\t\t{\n\t\t\topts: &struct {\n\t\t\t\tValue string `short:\"v\" default-mask:\"-\" description:\"V\"`\n\t\t\t}{Value: \"123\"},\n\t\t\tpresent: \"V\\n\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tp := NewParser(test.opts, HelpFlag)\n\t\t_, err := p.ParseArgs([]string{\"-h\"})\n\t\tif flagsErr, ok := err.(*Error); ok && flagsErr.Type == ErrHelp {\n\t\t\terr = nil\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\t}\n\t\th := &bytes.Buffer{}\n\t\tw := bufio.NewWriter(h)\n\t\tp.writeHelpOption(w, p.FindOptionByShortName('v'), p.getAlignmentInfo())\n\t\tw.Flush()\n\t\tif strings.Index(h.String(), test.present) < 0 {\n\t\t\tt.Errorf(\"Not present %q\\n%s\", test.present, h.String())\n\t\t}\n\t}\n}\n\nfunc TestWroteHelp(t *testing.T) {\n\ttype testInfo struct {\n\t\tvalue  error\n\t\tisHelp bool\n\t}\n\ttests := map[string]testInfo{\n\t\t\"No error\":    {value: nil, isHelp: false},\n\t\t\"Plain error\": {value: errors.New(\"an error\"), isHelp: false},\n\t\t\"ErrUnknown\":  {value: newError(ErrUnknown, \"an error\"), isHelp: false},\n\t\t\"ErrHelp\":     {value: newError(ErrHelp, \"an error\"), isHelp: true},\n\t}\n\n\tfor name, test := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tres := WroteHelp(test.value)\n\t\t\tif test.isHelp != res {\n\t\t\t\tt.Errorf(\"Expected %t, got %t\", test.isHelp, res)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "ini.go",
          "type": "blob",
          "size": 13.1845703125,
          "content": "package flags\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// IniError contains location information on where an error occurred.\ntype IniError struct {\n\t// The error message.\n\tMessage string\n\n\t// The filename of the file in which the error occurred.\n\tFile string\n\n\t// The line number at which the error occurred.\n\tLineNumber uint\n}\n\n// Error provides a \"file:line: message\" formatted message of the ini error.\nfunc (x *IniError) Error() string {\n\treturn fmt.Sprintf(\n\t\t\"%s:%d: %s\",\n\t\tx.File,\n\t\tx.LineNumber,\n\t\tx.Message,\n\t)\n}\n\n// IniOptions for writing\ntype IniOptions uint\n\nconst (\n\t// IniNone indicates no options.\n\tIniNone IniOptions = 0\n\n\t// IniIncludeDefaults indicates that default values should be written.\n\tIniIncludeDefaults = 1 << iota\n\n\t// IniCommentDefaults indicates that if IniIncludeDefaults is used\n\t// options with default values are written but commented out.\n\tIniCommentDefaults\n\n\t// IniIncludeComments indicates that comments containing the description\n\t// of an option should be written.\n\tIniIncludeComments\n\n\t// IniDefault provides a default set of options.\n\tIniDefault = IniIncludeComments\n)\n\n// IniParser is a utility to read and write flags options from and to ini\n// formatted strings.\ntype IniParser struct {\n\tParseAsDefaults bool // override default flags\n\n\tparser *Parser\n}\n\ntype iniValue struct {\n\tName       string\n\tValue      string\n\tQuoted     bool\n\tLineNumber uint\n}\n\ntype iniSection []iniValue\n\ntype ini struct {\n\tFile     string\n\tSections map[string]iniSection\n}\n\n// NewIniParser creates a new ini parser for a given Parser.\nfunc NewIniParser(p *Parser) *IniParser {\n\treturn &IniParser{\n\t\tparser: p,\n\t}\n}\n\n// IniParse is a convenience function to parse command line options with default\n// settings from an ini formatted file. The provided data is a pointer to a struct\n// representing the default option group (named \"Application Options\"). For\n// more control, use flags.NewParser.\nfunc IniParse(filename string, data interface{}) error {\n\tp := NewParser(data, Default)\n\n\treturn NewIniParser(p).ParseFile(filename)\n}\n\n// ParseFile parses flags from an ini formatted file. See Parse for more\n// information on the ini file format. The returned errors can be of the type\n// flags.Error or flags.IniError.\nfunc (i *IniParser) ParseFile(filename string) error {\n\tini, err := readIniFromFile(filename)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn i.parse(ini)\n}\n\n// Parse parses flags from an ini format. You can use ParseFile as a\n// convenience function to parse from a filename instead of a general\n// io.Reader.\n//\n// The format of the ini file is as follows:\n//\n//\t[Option group name]\n//\toption = value\n//\n// Each section in the ini file represents an option group or command in the\n// flags parser. The default flags parser option group (i.e. when using\n// flags.Parse) is named 'Application Options'. The ini option name is matched\n// in the following order:\n//\n//  1. Compared to the ini-name tag on the option struct field (if present)\n//  2. Compared to the struct field name\n//  3. Compared to the option long name (if present)\n//  4. Compared to the option short name (if present)\n//\n// Sections for nested groups and commands can be addressed using a dot `.'\n// namespacing notation (i.e [subcommand.Options]). Group section names are\n// matched case insensitive.\n//\n// The returned errors can be of the type flags.Error or flags.IniError.\nfunc (i *IniParser) Parse(reader io.Reader) error {\n\tini, err := readIni(reader, \"\")\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn i.parse(ini)\n}\n\n// WriteFile writes the flags as ini format into a file. See Write\n// for more information. The returned error occurs when the specified file\n// could not be opened for writing.\nfunc (i *IniParser) WriteFile(filename string, options IniOptions) error {\n\treturn writeIniToFile(i, filename, options)\n}\n\n// Write writes the current values of all the flags to an ini format.\n// See Parse for more information on the ini file format. You typically\n// call this only after settings have been parsed since the default values of each\n// option are stored just before parsing the flags (this is only relevant when\n// IniIncludeDefaults is _not_ set in options).\nfunc (i *IniParser) Write(writer io.Writer, options IniOptions) {\n\twriteIni(i, writer, options)\n}\n\nfunc readFullLine(reader *bufio.Reader) (string, error) {\n\tvar line []byte\n\n\tfor {\n\t\tl, more, err := reader.ReadLine()\n\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif line == nil && !more {\n\t\t\treturn string(l), nil\n\t\t}\n\n\t\tline = append(line, l...)\n\n\t\tif !more {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn string(line), nil\n}\n\nfunc optionIniName(option *Option) string {\n\tname := option.tag.Get(\"_read-ini-name\")\n\n\tif len(name) != 0 {\n\t\treturn name\n\t}\n\n\tname = option.tag.Get(\"ini-name\")\n\n\tif len(name) != 0 {\n\t\treturn name\n\t}\n\n\treturn option.field.Name\n}\n\nfunc writeGroupIni(cmd *Command, group *Group, namespace string, writer io.Writer, options IniOptions) {\n\tvar sname string\n\n\tif len(namespace) != 0 {\n\t\tsname = namespace\n\t}\n\n\tif cmd.Group != group && len(group.ShortDescription) != 0 {\n\t\tif len(sname) != 0 {\n\t\t\tsname += \".\"\n\t\t}\n\n\t\tsname += group.ShortDescription\n\t}\n\n\tsectionwritten := false\n\tcomments := (options & IniIncludeComments) != IniNone\n\n\tfor _, option := range group.options {\n\t\tif option.isFunc() || option.Hidden {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(option.tag.Get(\"no-ini\")) != 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tval := option.value\n\n\t\tif (options&IniIncludeDefaults) == IniNone && option.valueIsDefault() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif !sectionwritten {\n\t\t\tfmt.Fprintf(writer, \"[%s]\\n\", sname)\n\t\t\tsectionwritten = true\n\t\t}\n\n\t\tif comments && len(option.Description) != 0 {\n\t\t\tfmt.Fprintf(writer, \"; %s\\n\", option.Description)\n\t\t}\n\n\t\toname := optionIniName(option)\n\n\t\tcommentOption := (options&(IniIncludeDefaults|IniCommentDefaults)) == IniIncludeDefaults|IniCommentDefaults && option.valueIsDefault()\n\n\t\tkind := val.Type().Kind()\n\t\tswitch kind {\n\t\tcase reflect.Slice:\n\t\t\tkind = val.Type().Elem().Kind()\n\n\t\t\tif val.Len() == 0 {\n\t\t\t\twriteOption(writer, oname, kind, \"\", \"\", true, option.iniQuote)\n\t\t\t} else {\n\t\t\t\tfor idx := 0; idx < val.Len(); idx++ {\n\t\t\t\t\tv, _ := convertToString(val.Index(idx), option.tag)\n\n\t\t\t\t\twriteOption(writer, oname, kind, \"\", v, commentOption, option.iniQuote)\n\t\t\t\t}\n\t\t\t}\n\t\tcase reflect.Map:\n\t\t\tkind = val.Type().Elem().Kind()\n\n\t\t\tif val.Len() == 0 {\n\t\t\t\twriteOption(writer, oname, kind, \"\", \"\", true, option.iniQuote)\n\t\t\t} else {\n\t\t\t\tmkeys := val.MapKeys()\n\t\t\t\tkeys := make([]string, len(val.MapKeys()))\n\t\t\t\tkkmap := make(map[string]reflect.Value)\n\n\t\t\t\tfor i, k := range mkeys {\n\t\t\t\t\tkeys[i], _ = convertToString(k, option.tag)\n\t\t\t\t\tkkmap[keys[i]] = k\n\t\t\t\t}\n\n\t\t\t\tsort.Strings(keys)\n\n\t\t\t\tfor _, k := range keys {\n\t\t\t\t\tv, _ := convertToString(val.MapIndex(kkmap[k]), option.tag)\n\n\t\t\t\t\twriteOption(writer, oname, kind, k, v, commentOption, option.iniQuote)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tv, _ := convertToString(val, option.tag)\n\n\t\t\twriteOption(writer, oname, kind, \"\", v, commentOption, option.iniQuote)\n\t\t}\n\n\t\tif comments {\n\t\t\tfmt.Fprintln(writer)\n\t\t}\n\t}\n\n\tif sectionwritten && !comments {\n\t\tfmt.Fprintln(writer)\n\t}\n}\n\nfunc writeOption(writer io.Writer, optionName string, optionType reflect.Kind, optionKey string, optionValue string, commentOption bool, forceQuote bool) {\n\tif forceQuote || (optionType == reflect.String && !isPrint(optionValue)) {\n\t\toptionValue = strconv.Quote(optionValue)\n\t}\n\n\tcomment := \"\"\n\tif commentOption {\n\t\tcomment = \"; \"\n\t}\n\n\tfmt.Fprintf(writer, \"%s%s =\", comment, optionName)\n\n\tif optionKey != \"\" {\n\t\tfmt.Fprintf(writer, \" %s:%s\", optionKey, optionValue)\n\t} else if optionValue != \"\" {\n\t\tfmt.Fprintf(writer, \" %s\", optionValue)\n\t}\n\n\tfmt.Fprintln(writer)\n}\n\nfunc writeCommandIni(command *Command, namespace string, writer io.Writer, options IniOptions) {\n\tcommand.eachGroup(func(group *Group) {\n\t\tif !group.Hidden {\n\t\t\twriteGroupIni(command, group, namespace, writer, options)\n\t\t}\n\t})\n\n\tfor _, c := range command.commands {\n\t\tvar fqn string\n\n\t\tif c.Hidden {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(namespace) != 0 {\n\t\t\tfqn = namespace + \".\" + c.Name\n\t\t} else {\n\t\t\tfqn = c.Name\n\t\t}\n\n\t\twriteCommandIni(c, fqn, writer, options)\n\t}\n}\n\nfunc writeIni(parser *IniParser, writer io.Writer, options IniOptions) {\n\twriteCommandIni(parser.parser.Command, \"\", writer, options)\n}\n\nfunc writeIniToFile(parser *IniParser, filename string, options IniOptions) error {\n\tfile, err := os.Create(filename)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer file.Close()\n\n\twriteIni(parser, file, options)\n\n\treturn nil\n}\n\nfunc readIniFromFile(filename string) (*ini, error) {\n\tfile, err := os.Open(filename)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer file.Close()\n\n\treturn readIni(file, filename)\n}\n\nfunc readIni(contents io.Reader, filename string) (*ini, error) {\n\tret := &ini{\n\t\tFile:     filename,\n\t\tSections: make(map[string]iniSection),\n\t}\n\n\treader := bufio.NewReader(contents)\n\n\t// Empty global section\n\tsection := make(iniSection, 0, 10)\n\tsectionname := \"\"\n\n\tret.Sections[sectionname] = section\n\n\tvar lineno uint\n\n\tfor {\n\t\tline, err := readFullLine(reader)\n\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tlineno++\n\t\tline = strings.TrimSpace(line)\n\n\t\t// Skip empty lines and lines starting with ; (comments)\n\t\tif len(line) == 0 || line[0] == ';' || line[0] == '#' {\n\t\t\tcontinue\n\t\t}\n\n\t\tif line[0] == '[' {\n\t\t\tif line[0] != '[' || line[len(line)-1] != ']' {\n\t\t\t\treturn nil, &IniError{\n\t\t\t\t\tMessage:    \"malformed section header\",\n\t\t\t\t\tFile:       filename,\n\t\t\t\t\tLineNumber: lineno,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tname := strings.TrimSpace(line[1 : len(line)-1])\n\n\t\t\tif len(name) == 0 {\n\t\t\t\treturn nil, &IniError{\n\t\t\t\t\tMessage:    \"empty section name\",\n\t\t\t\t\tFile:       filename,\n\t\t\t\t\tLineNumber: lineno,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsectionname = name\n\t\t\tsection = ret.Sections[name]\n\n\t\t\tif section == nil {\n\t\t\t\tsection = make(iniSection, 0, 10)\n\t\t\t\tret.Sections[name] = section\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Parse option here\n\t\tkeyval := strings.SplitN(line, \"=\", 2)\n\n\t\tif len(keyval) != 2 {\n\t\t\treturn nil, &IniError{\n\t\t\t\tMessage:    fmt.Sprintf(\"malformed key=value (%s)\", line),\n\t\t\t\tFile:       filename,\n\t\t\t\tLineNumber: lineno,\n\t\t\t}\n\t\t}\n\n\t\tname := strings.TrimSpace(keyval[0])\n\t\tvalue := strings.TrimSpace(keyval[1])\n\t\tquoted := false\n\n\t\tif len(value) != 0 && value[0] == '\"' {\n\t\t\tif v, err := strconv.Unquote(value); err == nil {\n\t\t\t\tvalue = v\n\n\t\t\t\tquoted = true\n\t\t\t} else {\n\t\t\t\treturn nil, &IniError{\n\t\t\t\t\tMessage:    err.Error(),\n\t\t\t\t\tFile:       filename,\n\t\t\t\t\tLineNumber: lineno,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsection = append(section, iniValue{\n\t\t\tName:       name,\n\t\t\tValue:      value,\n\t\t\tQuoted:     quoted,\n\t\t\tLineNumber: lineno,\n\t\t})\n\n\t\tret.Sections[sectionname] = section\n\t}\n\n\treturn ret, nil\n}\n\nfunc (i *IniParser) matchingGroups(name string) []*Group {\n\tif len(name) == 0 {\n\t\tvar ret []*Group\n\n\t\ti.parser.eachGroup(func(g *Group) {\n\t\t\tret = append(ret, g)\n\t\t})\n\n\t\treturn ret\n\t}\n\n\tg := i.parser.groupByName(name)\n\n\tif g != nil {\n\t\treturn []*Group{g}\n\t}\n\n\treturn nil\n}\n\nfunc (i *IniParser) parse(ini *ini) error {\n\tp := i.parser\n\n\tp.eachOption(func(cmd *Command, group *Group, option *Option) {\n\t\toption.clearReferenceBeforeSet = true\n\t})\n\n\tvar quotesLookup = make(map[*Option]bool)\n\n\tfor name, section := range ini.Sections {\n\t\tgroups := i.matchingGroups(name)\n\n\t\tif len(groups) == 0 {\n\t\t\tif (p.Options & IgnoreUnknown) == None {\n\t\t\t\treturn newErrorf(ErrUnknownGroup, \"could not find option group `%s'\", name)\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, inival := range section {\n\t\t\tvar opt *Option\n\n\t\t\tfor _, group := range groups {\n\t\t\t\topt = group.optionByName(inival.Name, func(o *Option, n string) bool {\n\t\t\t\t\treturn strings.ToLower(o.tag.Get(\"ini-name\")) == strings.ToLower(n)\n\t\t\t\t})\n\n\t\t\t\tif opt != nil && len(opt.tag.Get(\"no-ini\")) != 0 {\n\t\t\t\t\topt = nil\n\t\t\t\t}\n\n\t\t\t\tif opt != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif opt == nil {\n\t\t\t\tif (p.Options & IgnoreUnknown) == None {\n\t\t\t\t\treturn &IniError{\n\t\t\t\t\t\tMessage:    fmt.Sprintf(\"unknown option: %s\", inival.Name),\n\t\t\t\t\t\tFile:       ini.File,\n\t\t\t\t\t\tLineNumber: inival.LineNumber,\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// ini value is ignored if parsed as default but defaults are prevented\n\t\t\tif i.ParseAsDefaults && opt.preventDefault {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpval := &inival.Value\n\n\t\t\tif !opt.canArgument() && len(inival.Value) == 0 {\n\t\t\t\tpval = nil\n\t\t\t} else {\n\t\t\t\tif opt.value.Type().Kind() == reflect.Map {\n\t\t\t\t\tparts := strings.SplitN(inival.Value, \":\", 2)\n\n\t\t\t\t\t// only handle unquoting\n\t\t\t\t\tif len(parts) == 2 && parts[1][0] == '\"' {\n\t\t\t\t\t\tif v, err := strconv.Unquote(parts[1]); err == nil {\n\t\t\t\t\t\t\tparts[1] = v\n\n\t\t\t\t\t\t\tinival.Quoted = true\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn &IniError{\n\t\t\t\t\t\t\t\tMessage:    err.Error(),\n\t\t\t\t\t\t\t\tFile:       ini.File,\n\t\t\t\t\t\t\t\tLineNumber: inival.LineNumber,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts := parts[0] + \":\" + parts[1]\n\n\t\t\t\t\t\tpval = &s\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar err error\n\n\t\t\tif i.ParseAsDefaults {\n\t\t\t\terr = opt.setDefault(pval)\n\t\t\t} else {\n\t\t\t\terr = opt.Set(pval)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\treturn &IniError{\n\t\t\t\t\tMessage:    err.Error(),\n\t\t\t\t\tFile:       ini.File,\n\t\t\t\t\tLineNumber: inival.LineNumber,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Defaults from ini files take precendence over defaults from parser\n\t\t\topt.preventDefault = true\n\n\t\t\t// either all INI values are quoted or only values who need quoting\n\t\t\tif _, ok := quotesLookup[opt]; !inival.Quoted || !ok {\n\t\t\t\tquotesLookup[opt] = inival.Quoted\n\t\t\t}\n\n\t\t\topt.tag.Set(\"_read-ini-name\", inival.Name)\n\t\t}\n\t}\n\n\tfor opt, quoted := range quotesLookup {\n\t\topt.iniQuote = quoted\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "ini_test.go",
          "type": "blob",
          "size": 22.4833984375,
          "content": "package flags\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestWriteIni(t *testing.T) {\n\toldEnv := EnvSnapshot()\n\tdefer oldEnv.Restore()\n\tos.Setenv(\"ENV_DEFAULT\", \"env-def\")\n\n\tvar tests = []struct {\n\t\targs     []string\n\t\toptions  IniOptions\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t[]string{\"-vv\", \"--intmap=a:2\", \"--intmap\", \"b:3\", \"filename\", \"0\", \"3.14\", \"command\"},\n\t\t\tIniDefault,\n\t\t\t`[Application Options]\n; Show verbose debug information\nverbose = true\nverbose = true\n\n; Test env-default1 value\nEnvDefault1 = env-def\n\n; Test env-default2 value\nEnvDefault2 = env-def\n\n[Other Options]\n; A map from string to int\nint-map = a:2\nint-map = b:3\n\n`,\n\t\t},\n\t\t{\n\t\t\t[]string{\"-vv\", \"--intmap=a:2\", \"--intmap\", \"b:3\", \"filename\", \"0\", \"3.14\", \"command\"},\n\t\t\tIniDefault | IniIncludeDefaults,\n\t\t\t`[Application Options]\n; Show verbose debug information\nverbose = true\nverbose = true\n\n; A slice of pointers to string\n; PtrSlice =\n\nEmptyDescription = false\n\n; Test default value\nDefault = \"Some\\nvalue\"\n\n; Test default array value\nDefaultArray = Some value\nDefaultArray = \"Other\\tvalue\"\n\n; Testdefault map value\nDefaultMap = another:value\nDefaultMap = some:value\n\n; Test env-default1 value\nEnvDefault1 = env-def\n\n; Test env-default2 value\nEnvDefault2 = env-def\n\n; Option with named argument\nOptionWithArgName =\n\n; Option with choices\nOptionWithChoices =\n\n; Option only available in ini\nonly-ini =\n\n[Other Options]\n; A slice of strings\nStringSlice = some\nStringSlice = value\n\n; A map from string to int\nint-map = a:2\nint-map = b:3\n\n[Subgroup]\n; This is a subgroup option\nOpt =\n\n; Not hidden inside group\nNotHiddenInsideGroup =\n\n[Subsubgroup]\n; This is a subsubgroup option\nOpt =\n\n[command]\n; Use for extra verbosity\n; ExtraVerbose =\n\n[parent]\n; This is a parent command option\nOpt =\n\n[parent.sub]\n; This is a sub command option\nOpt =\n\n`,\n\t\t},\n\t\t{\n\t\t\t[]string{\"filename\", \"0\", \"3.14\", \"command\"},\n\t\t\tIniDefault | IniIncludeDefaults | IniCommentDefaults,\n\t\t\t`[Application Options]\n; Show verbose debug information\n; verbose =\n\n; A slice of pointers to string\n; PtrSlice =\n\n; EmptyDescription = false\n\n; Test default value\n; Default = \"Some\\nvalue\"\n\n; Test default array value\n; DefaultArray = Some value\n; DefaultArray = \"Other\\tvalue\"\n\n; Testdefault map value\n; DefaultMap = another:value\n; DefaultMap = some:value\n\n; Test env-default1 value\nEnvDefault1 = env-def\n\n; Test env-default2 value\nEnvDefault2 = env-def\n\n; Option with named argument\n; OptionWithArgName =\n\n; Option with choices\n; OptionWithChoices =\n\n; Option only available in ini\n; only-ini =\n\n[Other Options]\n; A slice of strings\n; StringSlice = some\n; StringSlice = value\n\n; A map from string to int\n; int-map = a:1\n\n[Subgroup]\n; This is a subgroup option\n; Opt =\n\n; Not hidden inside group\n; NotHiddenInsideGroup =\n\n[Subsubgroup]\n; This is a subsubgroup option\n; Opt =\n\n[command]\n; Use for extra verbosity\n; ExtraVerbose =\n\n[parent]\n; This is a parent command option\n; Opt =\n\n[parent.sub]\n; This is a sub command option\n; Opt =\n\n`,\n\t\t},\n\t\t{\n\t\t\t[]string{\"--default=New value\", \"--default-array=New value\", \"--default-map=new:value\", \"filename\", \"0\", \"3.14\", \"command\"},\n\t\t\tIniDefault | IniIncludeDefaults | IniCommentDefaults,\n\t\t\t`[Application Options]\n; Show verbose debug information\n; verbose =\n\n; A slice of pointers to string\n; PtrSlice =\n\n; EmptyDescription = false\n\n; Test default value\nDefault = New value\n\n; Test default array value\nDefaultArray = New value\n\n; Testdefault map value\nDefaultMap = new:value\n\n; Test env-default1 value\nEnvDefault1 = env-def\n\n; Test env-default2 value\nEnvDefault2 = env-def\n\n; Option with named argument\n; OptionWithArgName =\n\n; Option with choices\n; OptionWithChoices =\n\n; Option only available in ini\n; only-ini =\n\n[Other Options]\n; A slice of strings\n; StringSlice = some\n; StringSlice = value\n\n; A map from string to int\n; int-map = a:1\n\n[Subgroup]\n; This is a subgroup option\n; Opt =\n\n; Not hidden inside group\n; NotHiddenInsideGroup =\n\n[Subsubgroup]\n; This is a subsubgroup option\n; Opt =\n\n[command]\n; Use for extra verbosity\n; ExtraVerbose =\n\n[parent]\n; This is a parent command option\n; Opt =\n\n[parent.sub]\n; This is a sub command option\n; Opt =\n\n`,\n\t\t},\n\t\t{\n\t\t\t[]string{\"-vv\", \"filename\", \"0\", \"3.14\", \"parent\", \"--opt=p\", \"sub\", \"--opt=s\"},\n\t\t\tIniDefault,\n\t\t\t`[Application Options]\n; Show verbose debug information\nverbose = true\nverbose = true\n\n; Test env-default1 value\nEnvDefault1 = env-def\n\n; Test env-default2 value\nEnvDefault2 = env-def\n\n[parent]\n; This is a parent command option\nOpt = p\n\n[parent.sub]\n; This is a sub command option\nOpt = s\n\n`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar opts helpOptions\n\n\t\tp := NewNamedParser(\"TestIni\", Default)\n\t\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\t\t_, err := p.ParseArgs(test.args)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\t}\n\n\t\tinip := NewIniParser(p)\n\n\t\tvar b bytes.Buffer\n\t\tinip.Write(&b, test.options)\n\n\t\tgot := b.String()\n\t\texpected := test.expected\n\n\t\tmsg := fmt.Sprintf(\"with arguments %+v and ini options %b\", test.args, test.options)\n\t\tassertDiff(t, got, expected, msg)\n\t}\n}\n\nfunc TestReadIni_flagEquivalent(t *testing.T) {\n\ttype options struct {\n\t\tOpt1 bool `long:\"opt1\"`\n\n\t\tGroup1 struct {\n\t\t\tOpt2 bool `long:\"opt2\"`\n\t\t} `group:\"group1\"`\n\n\t\tGroup2 struct {\n\t\t\tOpt3 bool `long:\"opt3\"`\n\t\t} `group:\"group2\" namespace:\"ns1\"`\n\n\t\tCmd1 struct {\n\t\t\tOpt4 bool `long:\"opt4\"`\n\t\t\tOpt5 bool `long:\"foo.opt5\"`\n\n\t\t\tGroup1 struct {\n\t\t\t\tOpt6 bool `long:\"opt6\"`\n\t\t\t\tOpt7 bool `long:\"foo.opt7\"`\n\t\t\t} `group:\"group1\"`\n\n\t\t\tGroup2 struct {\n\t\t\t\tOpt8 bool `long:\"opt8\"`\n\t\t\t} `group:\"group2\" namespace:\"ns1\"`\n\t\t} `command:\"cmd1\"`\n\t}\n\n\ta := `\nopt1=true\n\n[group1]\nopt2=true\n\n[group2]\nns1.opt3=true\n\n[cmd1]\nopt4=true\nfoo.opt5=true\n\n[cmd1.group1]\nopt6=true\nfoo.opt7=true\n\n[cmd1.group2]\nns1.opt8=true\n`\n\tb := `\nopt1=true\nopt2=true\nns1.opt3=true\n\n[cmd1]\nopt4=true\nfoo.opt5=true\nopt6=true\nfoo.opt7=true\nns1.opt8=true\n`\n\n\tparse := func(readIni string) (opts options, writeIni string) {\n\t\tp := NewNamedParser(\"TestIni\", Default)\n\t\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\t\tinip := NewIniParser(p)\n\t\terr := inip.Parse(strings.NewReader(readIni))\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %s\\n\\nFile:\\n%s\", err, readIni)\n\t\t}\n\n\t\tvar b bytes.Buffer\n\t\tinip.Write(&b, Default)\n\n\t\treturn opts, b.String()\n\t}\n\n\taOpt, aIni := parse(a)\n\tbOpt, bIni := parse(b)\n\n\tassertDiff(t, aIni, bIni, \"\")\n\tif !reflect.DeepEqual(aOpt, bOpt) {\n\t\tt.Errorf(\"not equal\")\n\t}\n}\n\nfunc TestReadIni(t *testing.T) {\n\tvar opts helpOptions\n\n\tp := NewNamedParser(\"TestIni\", Default)\n\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\tinip := NewIniParser(p)\n\n\tinic := `\n; Show verbose debug information\nverbose = true\nverbose = true\n\nDefaultMap = another:\"value\\n1\"\nDefaultMap = some:value 2\n\n[Application Options]\n; A slice of pointers to string\n; PtrSlice =\n\n; Test default value\nDefault = \"New\\nvalue\"\n\n; Test env-default1 value\nEnvDefault1 = New value\n\n[Other Options]\n# A slice of strings\nStringSlice = \"some\\nvalue\"\nStringSlice = another value\n\n; A map from string to int\nint-map = a:2\nint-map = b:3\n\n`\n\n\tb := strings.NewReader(inic)\n\terr := inip.Parse(b)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\n\tassertBoolArray(t, opts.Verbose, []bool{true, true})\n\n\tif v := map[string]string{\"another\": \"value\\n1\", \"some\": \"value 2\"}; !reflect.DeepEqual(opts.DefaultMap, v) {\n\t\tt.Fatalf(\"Expected %#v for DefaultMap but got %#v\", v, opts.DefaultMap)\n\t}\n\n\tassertString(t, opts.Default, \"New\\nvalue\")\n\n\tassertString(t, opts.EnvDefault1, \"New value\")\n\n\tassertStringArray(t, opts.Other.StringSlice, []string{\"some\\nvalue\", \"another value\"})\n\n\tif v, ok := opts.Other.IntMap[\"a\"]; !ok {\n\t\tt.Errorf(\"Expected \\\"a\\\" in Other.IntMap\")\n\t} else if v != 2 {\n\t\tt.Errorf(\"Expected Other.IntMap[\\\"a\\\"] = 2, but got %v\", v)\n\t}\n\n\tif v, ok := opts.Other.IntMap[\"b\"]; !ok {\n\t\tt.Errorf(\"Expected \\\"b\\\" in Other.IntMap\")\n\t} else if v != 3 {\n\t\tt.Errorf(\"Expected Other.IntMap[\\\"b\\\"] = 3, but got %v\", v)\n\t}\n}\n\nfunc TestReadAndWriteIni(t *testing.T) {\n\tvar tests = []struct {\n\t\toptions IniOptions\n\t\tread    string\n\t\twrite   string\n\t}{\n\t\t{\n\t\t\tIniIncludeComments,\n\t\t\t`[Application Options]\n; Show verbose debug information\nverbose = true\nverbose = true\n\n; Test default value\nDefault = \"quote me\"\n\n; Test default array value\nDefaultArray = 1\nDefaultArray = \"2\"\nDefaultArray = 3\n\n; Testdefault map value\n; DefaultMap =\n\n; Test env-default1 value\nEnvDefault1 = env-def\n\n; Test env-default2 value\nEnvDefault2 = env-def\n\n[Other Options]\n; A slice of strings\n; StringSlice =\n\n; A map from string to int\nint-map = a:2\nint-map = b:\"3\"\n\n`,\n\t\t\t`[Application Options]\n; Show verbose debug information\nverbose = true\nverbose = true\n\n; Test default value\nDefault = \"quote me\"\n\n; Test default array value\nDefaultArray = 1\nDefaultArray = 2\nDefaultArray = 3\n\n; Testdefault map value\n; DefaultMap =\n\n; Test env-default1 value\nEnvDefault1 = env-def\n\n; Test env-default2 value\nEnvDefault2 = env-def\n\n[Other Options]\n; A slice of strings\n; StringSlice =\n\n; A map from string to int\nint-map = a:2\nint-map = b:3\n\n`,\n\t\t},\n\t\t{\n\t\t\tIniIncludeComments,\n\t\t\t`[Application Options]\n; Show verbose debug information\nverbose = true\nverbose = true\n\n; Test default value\nDefault = \"quote me\"\n\n; Test default array value\nDefaultArray = \"1\"\nDefaultArray = \"2\"\nDefaultArray = \"3\"\n\n; Testdefault map value\n; DefaultMap =\n\n; Test env-default1 value\nEnvDefault1 = env-def\n\n; Test env-default2 value\nEnvDefault2 = env-def\n\n[Other Options]\n; A slice of strings\n; StringSlice =\n\n; A map from string to int\nint-map = a:\"2\"\nint-map = b:\"3\"\n\n`,\n\t\t\t`[Application Options]\n; Show verbose debug information\nverbose = true\nverbose = true\n\n; Test default value\nDefault = \"quote me\"\n\n; Test default array value\nDefaultArray = \"1\"\nDefaultArray = \"2\"\nDefaultArray = \"3\"\n\n; Testdefault map value\n; DefaultMap =\n\n; Test env-default1 value\nEnvDefault1 = env-def\n\n; Test env-default2 value\nEnvDefault2 = env-def\n\n[Other Options]\n; A slice of strings\n; StringSlice =\n\n; A map from string to int\nint-map = a:\"2\"\nint-map = b:\"3\"\n\n`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar opts helpOptions\n\n\t\tp := NewNamedParser(\"TestIni\", Default)\n\t\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\t\tinip := NewIniParser(p)\n\n\t\tread := strings.NewReader(test.read)\n\t\terr := inip.Parse(read)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t\t}\n\n\t\tvar write bytes.Buffer\n\t\tinip.Write(&write, test.options)\n\n\t\tgot := write.String()\n\n\t\tmsg := fmt.Sprintf(\"with ini options %b\", test.options)\n\t\tassertDiff(t, got, test.write, msg)\n\t}\n}\n\nfunc TestReadIniWrongQuoting(t *testing.T) {\n\tvar tests = []struct {\n\t\tiniFile    string\n\t\tlineNumber uint\n\t}{\n\t\t{\n\t\t\tiniFile:    `Default = \"New\\nvalue`,\n\t\t\tlineNumber: 1,\n\t\t},\n\t\t{\n\t\t\tiniFile:    `StringSlice = \"New\\nvalue`,\n\t\t\tlineNumber: 1,\n\t\t},\n\t\t{\n\t\t\tiniFile: `StringSlice = \"New\\nvalue\"\n\t\t\tStringSlice = \"Second\\nvalue`,\n\t\t\tlineNumber: 2,\n\t\t},\n\t\t{\n\t\t\tiniFile:    `DefaultMap = some:\"value`,\n\t\t\tlineNumber: 1,\n\t\t},\n\t\t{\n\t\t\tiniFile: `DefaultMap = some:value\n\t\t\tDefaultMap = another:\"value`,\n\t\t\tlineNumber: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar opts helpOptions\n\n\t\tp := NewNamedParser(\"TestIni\", Default)\n\t\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\t\tinip := NewIniParser(p)\n\n\t\tinic := test.iniFile\n\n\t\tb := strings.NewReader(inic)\n\t\terr := inip.Parse(b)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expect error\")\n\t\t}\n\n\t\tiniError := err.(*IniError)\n\n\t\tif iniError.LineNumber != test.lineNumber {\n\t\t\tt.Fatalf(\"Expect error on line %d\", test.lineNumber)\n\t\t}\n\t}\n}\n\nfunc TestIniCommands(t *testing.T) {\n\tvar opts struct {\n\t\tValue string `short:\"v\" long:\"value\"`\n\n\t\tAdd struct {\n\t\t\tName int `short:\"n\" long:\"name\" ini-name:\"AliasName\"`\n\n\t\t\tOther struct {\n\t\t\t\tO string `short:\"o\" long:\"other\"`\n\t\t\t} `group:\"Other Options\"`\n\t\t} `command:\"add\"`\n\t}\n\n\tp := NewNamedParser(\"TestIni\", Default)\n\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\tinip := NewIniParser(p)\n\n\tinic := `[Application Options]\nvalue = some value\n\n[add]\nAliasName = 5\n\n[add.Other Options]\nother = subgroup\n\n`\n\n\tb := strings.NewReader(inic)\n\terr := inip.Parse(b)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\n\tassertString(t, opts.Value, \"some value\")\n\n\tif opts.Add.Name != 5 {\n\t\tt.Errorf(\"Expected opts.Add.Name to be 5, but got %v\", opts.Add.Name)\n\t}\n\n\tassertString(t, opts.Add.Other.O, \"subgroup\")\n\n\t// Test writing it back\n\tbuf := &bytes.Buffer{}\n\n\tinip.Write(buf, IniDefault)\n\n\tassertDiff(t, buf.String(), inic, \"ini contents\")\n}\n\nfunc TestIniNoIni(t *testing.T) {\n\tvar opts struct {\n\t\tNoValue string `short:\"n\" long:\"novalue\" no-ini:\"yes\"`\n\t\tValue   string `short:\"v\" long:\"value\"`\n\t}\n\n\tp := NewNamedParser(\"TestIni\", Default)\n\tp.AddGroup(\"Application Options\", \"The application options\", &opts)\n\n\tinip := NewIniParser(p)\n\n\t// read INI\n\tinic := `[Application Options]\nnovalue = some value\nvalue = some other value\n`\n\n\tb := strings.NewReader(inic)\n\terr := inip.Parse(b)\n\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error\")\n\t}\n\n\tiniError := err.(*IniError)\n\n\tif v := uint(2); iniError.LineNumber != v {\n\t\tt.Errorf(\"Expected opts.Add.Name to be %d, but got %d\", v, iniError.LineNumber)\n\t}\n\n\tif v := \"unknown option: novalue\"; iniError.Message != v {\n\t\tt.Errorf(\"Expected opts.Add.Name to be %s, but got %s\", v, iniError.Message)\n\t}\n\n\t// write INI\n\topts.NoValue = \"some value\"\n\topts.Value = \"some other value\"\n\n\tfile, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot create temporary file: %s\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\terr = inip.WriteFile(file.Name(), IniIncludeDefaults)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not write ini file: %s\", err)\n\t}\n\n\tfound, err := ioutil.ReadFile(file.Name())\n\tif err != nil {\n\t\tt.Fatalf(\"Could not read written ini file: %s\", err)\n\t}\n\n\texpected := \"[Application Options]\\nValue = some other value\\n\\n\"\n\n\tassertDiff(t, string(found), expected, \"ini content\")\n}\n\nfunc TestIniParse(t *testing.T) {\n\tfile, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot create temporary file: %s\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\t_, err = file.WriteString(\"value = 123\")\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot write to temporary file: %s\", err)\n\t}\n\n\tfile.Close()\n\n\tvar opts struct {\n\t\tValue int `long:\"value\"`\n\t}\n\n\terr = IniParse(file.Name(), &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not parse ini: %s\", err)\n\t}\n\n\tif opts.Value != 123 {\n\t\tt.Fatalf(\"Expected Value to be \\\"123\\\" but was \\\"%d\\\"\", opts.Value)\n\t}\n}\n\nfunc TestIniCliOverrides(t *testing.T) {\n\tfile, err := ioutil.TempFile(\"\", \"\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot create temporary file: %s\", err)\n\t}\n\n\tdefer os.Remove(file.Name())\n\n\t_, err = file.WriteString(\"values = 123\\n\")\n\t_, err = file.WriteString(\"values = 456\\n\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot write to temporary file: %s\", err)\n\t}\n\n\tfile.Close()\n\n\tvar opts struct {\n\t\tValues []int `long:\"values\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\terr = NewIniParser(p).ParseFile(file.Name())\n\n\tif err != nil {\n\t\tt.Fatalf(\"Could not parse ini: %s\", err)\n\t}\n\n\t_, err = p.ParseArgs([]string{\"--values\", \"111\", \"--values\", \"222\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse arguments: %s\", err)\n\t}\n\n\tif len(opts.Values) != 2 {\n\t\tt.Fatalf(\"Expected Values to contain two elements, but got %d\", len(opts.Values))\n\t}\n\n\tif opts.Values[0] != 111 {\n\t\tt.Fatalf(\"Expected Values[0] to be 111, but got '%d'\", opts.Values[0])\n\t}\n\n\tif opts.Values[1] != 222 {\n\t\tt.Fatalf(\"Expected Values[1] to be 222, but got '%d'\", opts.Values[1])\n\t}\n}\n\nfunc TestIniOverrides(t *testing.T) {\n\tfile, err := ioutil.TempFile(\"\", \"\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot create temporary file: %s\", err)\n\t}\n\n\tdefer os.Remove(file.Name())\n\n\t_, err = file.WriteString(\"value-with-default = \\\"ini-value\\\"\\n\")\n\t_, err = file.WriteString(\"value-with-default-override-cli = \\\"ini-value\\\"\\n\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot write to temporary file: %s\", err)\n\t}\n\n\tfile.Close()\n\n\tvar opts struct {\n\t\tValueWithDefault            string `long:\"value-with-default\" default:\"value\"`\n\t\tValueWithDefaultOverrideCli string `long:\"value-with-default-override-cli\" default:\"value\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\terr = NewIniParser(p).ParseFile(file.Name())\n\n\tif err != nil {\n\t\tt.Fatalf(\"Could not parse ini: %s\", err)\n\t}\n\n\t_, err = p.ParseArgs([]string{\"--value-with-default-override-cli\", \"cli-value\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse arguments: %s\", err)\n\t}\n\n\tassertString(t, opts.ValueWithDefault, \"ini-value\")\n\tassertString(t, opts.ValueWithDefaultOverrideCli, \"cli-value\")\n}\n\nfunc TestIniOverridesFromConfigFlag(t *testing.T) {\n\tfile, err := ioutil.TempFile(\"\", \"\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot create temporary file: %s\", err)\n\t}\n\n\tdefer os.Remove(file.Name())\n\n\t_, err = file.WriteString(\"value-with-default = \\\"ini-value\\\"\\n\")\n\t_, err = file.WriteString(\"value-with-default-override-cli = \\\"ini-value\\\"\\n\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot write to temporary file: %s\", err)\n\t}\n\n\tfile.Close()\n\n\tvar opts struct {\n\t\tConfig                      func(filename string) `long:\"config\"`\n\t\tValueWithDefault            string                `long:\"value-with-default\" default:\"value\"`\n\t\tValueWithDefaultOverrideCli string                `long:\"value-with-default-override-cli\" default:\"value\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\n\topt := p.FindOptionByLongName(\"config\")\n\topt.Default = []string{file.Name()}\n\n\topts.Config = func(filename string) {\n\t\tparser := NewIniParser(p)\n\t\tparser.ParseAsDefaults = true\n\t\tparser.ParseFile(filename)\n\t}\n\n\t_, err = p.ParseArgs([]string{\"--value-with-default-override-cli\", \"cli-value\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse arguments: %s\", err)\n\t}\n\n\tassertString(t, opts.ValueWithDefault, \"ini-value\")\n\tassertString(t, opts.ValueWithDefaultOverrideCli, \"cli-value\")\n}\n\nfunc TestIniRequired(t *testing.T) {\n\tvar opts struct {\n\t\tRequired string               `short:\"r\" required:\"yes\" description:\"required\"`\n\t\tConfig   func(s string) error `long:\"config\" default:\"no-ini-file\" no-ini:\"true\"`\n\t}\n\n\tp := NewParser(&opts, Default)\n\n\topts.Config = func(s string) error {\n\t\tinip := NewIniParser(p)\n\t\tinip.ParseAsDefaults = true\n\t\treturn inip.Parse(strings.NewReader(\"Required = ini-value\\n\"))\n\t}\n\n\t_, err := p.ParseArgs([]string{\"-r\", \"cli-value\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse arguments: %s\", err)\n\t}\n\n\tassertString(t, opts.Required, \"cli-value\")\n}\n\nfunc TestIniRequiredSlice_ShouldNotNeedToBeSpecifiedOnCli(t *testing.T) {\n\ttype options struct {\n\t\tItems []string `long:\"item\" required:\"true\"`\n\t}\n\tvar opts options\n\tini := `\n[Application Options]\nitem=abc`\n\targs := []string{}\n\n\tparser := NewParser(&opts, Default)\n\tinip := NewIniParser(parser)\n\n\tinip.Parse(strings.NewReader(ini))\n\n\t_, err := parser.ParseArgs(args)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected failure: %v\", err)\n\t}\n\n\tassertString(t, opts.Items[0], \"abc\")\n}\n\nfunc TestWriteFile(t *testing.T) {\n\tfile, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot create temporary file: %s\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\tvar opts struct {\n\t\tValue int `long:\"value\"`\n\t}\n\n\topts.Value = 123\n\n\tp := NewParser(&opts, Default)\n\tini := NewIniParser(p)\n\n\terr = ini.WriteFile(file.Name(), IniIncludeDefaults)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not write ini file: %s\", err)\n\t}\n\n\tfound, err := ioutil.ReadFile(file.Name())\n\tif err != nil {\n\t\tt.Fatalf(\"Could not read written ini file: %s\", err)\n\t}\n\n\texpected := \"[Application Options]\\nValue = 123\\n\\n\"\n\n\tassertDiff(t, string(found), expected, \"ini content\")\n}\n\nfunc TestOverwriteRequiredOptions(t *testing.T) {\n\tvar tests = []struct {\n\t\targs     []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\targs: []string{\"--value\", \"from CLI\"},\n\t\t\texpected: []string{\n\t\t\t\t\"from CLI\",\n\t\t\t\t\"from default\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\targs: []string{\"--value\", \"from CLI\", \"--default\", \"from CLI\"},\n\t\t\texpected: []string{\n\t\t\t\t\"from CLI\",\n\t\t\t\t\"from CLI\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\targs: []string{\"--config\", \"no file name\"},\n\t\t\texpected: []string{\n\t\t\t\t\"from INI\",\n\t\t\t\t\"from INI\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\targs: []string{\"--value\", \"from CLI before\", \"--default\", \"from CLI before\", \"--config\", \"no file name\"},\n\t\t\texpected: []string{\n\t\t\t\t\"from INI\",\n\t\t\t\t\"from INI\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\targs: []string{\"--value\", \"from CLI before\", \"--default\", \"from CLI before\", \"--config\", \"no file name\", \"--value\", \"from CLI after\", \"--default\", \"from CLI after\"},\n\t\t\texpected: []string{\n\t\t\t\t\"from CLI after\",\n\t\t\t\t\"from CLI after\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar opts struct {\n\t\t\tConfig  func(s string) error `long:\"config\" no-ini:\"true\"`\n\t\t\tValue   string               `long:\"value\" required:\"true\"`\n\t\t\tDefault string               `long:\"default\" required:\"true\" default:\"from default\"`\n\t\t}\n\n\t\tp := NewParser(&opts, Default)\n\n\t\topts.Config = func(s string) error {\n\t\t\tini := NewIniParser(p)\n\n\t\t\treturn ini.Parse(bytes.NewBufferString(\"value = from INI\\ndefault = from INI\"))\n\t\t}\n\n\t\t_, err := p.ParseArgs(test.args)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error %s with args %+v\", err, test.args)\n\t\t}\n\n\t\tif opts.Value != test.expected[0] {\n\t\t\tt.Fatalf(\"Expected Value to be \\\"%s\\\" but was \\\"%s\\\" with args %+v\", test.expected[0], opts.Value, test.args)\n\t\t}\n\n\t\tif opts.Default != test.expected[1] {\n\t\t\tt.Fatalf(\"Expected Default to be \\\"%s\\\" but was \\\"%s\\\" with args %+v\", test.expected[1], opts.Default, test.args)\n\t\t}\n\t}\n}\n\nfunc TestIniOverwriteOptions(t *testing.T) {\n\tvar tests = []struct {\n\t\targs     []string\n\t\texpected string\n\t\ttoggled  bool\n\t}{\n\t\t{\n\t\t\targs:     []string{},\n\t\t\texpected: \"from default\",\n\t\t},\n\t\t{\n\t\t\targs:     []string{\"--value\", \"from CLI\"},\n\t\t\texpected: \"from CLI\",\n\t\t},\n\t\t{\n\t\t\targs:     []string{\"--config\", \"no file name\"},\n\t\t\texpected: \"from INI\",\n\t\t\ttoggled:  true,\n\t\t},\n\t\t{\n\t\t\targs:     []string{\"--value\", \"from CLI before\", \"--config\", \"no file name\"},\n\t\t\texpected: \"from CLI before\",\n\t\t\ttoggled:  true,\n\t\t},\n\t\t{\n\t\t\targs:     []string{\"--config\", \"no file name\", \"--value\", \"from CLI after\"},\n\t\t\texpected: \"from CLI after\",\n\t\t\ttoggled:  true,\n\t\t},\n\t\t{\n\t\t\targs:     []string{\"--toggle\"},\n\t\t\ttoggled:  true,\n\t\t\texpected: \"from default\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar opts struct {\n\t\t\tConfig string `long:\"config\" no-ini:\"true\"`\n\t\t\tValue  string `long:\"value\" default:\"from default\"`\n\t\t\tToggle bool   `long:\"toggle\"`\n\t\t}\n\n\t\tp := NewParser(&opts, Default)\n\n\t\t_, err := p.ParseArgs(test.args)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error %s with args %+v\", err, test.args)\n\t\t}\n\n\t\tif opts.Config != \"\" {\n\t\t\tinip := NewIniParser(p)\n\t\t\tinip.ParseAsDefaults = true\n\n\t\t\terr = inip.Parse(bytes.NewBufferString(\"value = from INI\\ntoggle = true\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unexpected error %s with args %+v\", err, test.args)\n\t\t\t}\n\t\t}\n\n\t\tif opts.Value != test.expected {\n\t\t\tt.Fatalf(\"Expected Value to be \\\"%s\\\" but was \\\"%s\\\" with args %+v\", test.expected, opts.Value, test.args)\n\t\t}\n\n\t\tif opts.Toggle != test.toggled {\n\t\t\tt.Fatalf(\"Expected Toggle to be \\\"%v\\\" but was \\\"%v\\\" with args %+v\", test.toggled, opts.Toggle, test.args)\n\t\t}\n\n\t}\n}\n"
        },
        {
          "name": "long_test.go",
          "type": "blob",
          "size": 1.7421875,
          "content": "package flags\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLong(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `long:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"--value\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n}\n\nfunc TestLongArg(t *testing.T) {\n\tvar opts = struct {\n\t\tValue string `long:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"--value\", \"value\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestLongArgEqual(t *testing.T) {\n\tvar opts = struct {\n\t\tValue string `long:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"--value=value\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestLongDefault(t *testing.T) {\n\tvar opts = struct {\n\t\tValue string `long:\"value\" default:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts)\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestLongOptional(t *testing.T) {\n\tvar opts = struct {\n\t\tValue string `long:\"value\" optional:\"yes\" optional-value:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"--value\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestLongOptionalArg(t *testing.T) {\n\tvar opts = struct {\n\t\tValue string `long:\"value\" optional:\"yes\" optional-value:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"--value\", \"no\")\n\n\tassertStringArray(t, ret, []string{\"no\"})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestLongOptionalArgEqual(t *testing.T) {\n\tvar opts = struct {\n\t\tValue string `long:\"value\" optional:\"yes\" optional-value:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"--value=value\", \"no\")\n\n\tassertStringArray(t, ret, []string{\"no\"})\n\tassertString(t, opts.Value, \"value\")\n}\n"
        },
        {
          "name": "man.go",
          "type": "blob",
          "size": 5.1953125,
          "content": "package flags\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc manQuoteLines(s string) string {\n\tlines := strings.Split(s, \"\\n\")\n\tparts := []string{}\n\n\tfor _, line := range lines {\n\t\tparts = append(parts, manQuote(line))\n\t}\n\n\treturn strings.Join(parts, \"\\n\")\n}\n\nfunc manQuote(s string) string {\n\treturn strings.Replace(s, \"\\\\\", \"\\\\\\\\\", -1)\n}\n\nfunc formatForMan(wr io.Writer, s string, quoter func(s string) string) {\n\tfor {\n\t\tidx := strings.IndexRune(s, '`')\n\n\t\tif idx < 0 {\n\t\t\tfmt.Fprintf(wr, \"%s\", quoter(s))\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Fprintf(wr, \"%s\", quoter(s[:idx]))\n\n\t\ts = s[idx+1:]\n\t\tidx = strings.IndexRune(s, '\\'')\n\n\t\tif idx < 0 {\n\t\t\tfmt.Fprintf(wr, \"%s\", quoter(s))\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Fprintf(wr, \"\\\\fB%s\\\\fP\", quoter(s[:idx]))\n\t\ts = s[idx+1:]\n\t}\n}\n\nfunc writeManPageOptions(wr io.Writer, grp *Group) {\n\tgrp.eachGroup(func(group *Group) {\n\t\tif !group.showInHelp() {\n\t\t\treturn\n\t\t}\n\n\t\t// If the parent (grp) has any subgroups, display their descriptions as\n\t\t// subsection headers similar to the output of --help.\n\t\tif group.ShortDescription != \"\" && len(grp.groups) > 0 {\n\t\t\tfmt.Fprintf(wr, \".SS %s\\n\", group.ShortDescription)\n\n\t\t\tif group.LongDescription != \"\" {\n\t\t\t\tformatForMan(wr, group.LongDescription, manQuoteLines)\n\t\t\t\tfmt.Fprintln(wr, \"\")\n\t\t\t}\n\t\t}\n\n\t\tfor _, opt := range group.options {\n\t\t\tif !opt.showInHelp() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Fprintln(wr, \".TP\")\n\t\t\tfmt.Fprintf(wr, \"\\\\fB\")\n\n\t\t\tif opt.ShortName != 0 {\n\t\t\t\tfmt.Fprintf(wr, \"\\\\fB\\\\-%c\\\\fR\", opt.ShortName)\n\t\t\t}\n\n\t\t\tif len(opt.LongName) != 0 {\n\t\t\t\tif opt.ShortName != 0 {\n\t\t\t\t\tfmt.Fprintf(wr, \", \")\n\t\t\t\t}\n\n\t\t\t\tfmt.Fprintf(wr, \"\\\\fB\\\\-\\\\-%s\\\\fR\", manQuote(opt.LongNameWithNamespace()))\n\t\t\t}\n\n\t\t\tif len(opt.ValueName) != 0 || opt.OptionalArgument {\n\t\t\t\tif opt.OptionalArgument {\n\t\t\t\t\tfmt.Fprintf(wr, \" [\\\\fI%s=%s\\\\fR]\", manQuote(opt.ValueName), manQuote(strings.Join(quoteV(opt.OptionalValue), \", \")))\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintf(wr, \" \\\\fI%s\\\\fR\", manQuote(opt.ValueName))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(opt.Default) != 0 {\n\t\t\t\tfmt.Fprintf(wr, \" <default: \\\\fI%s\\\\fR>\", manQuote(strings.Join(quoteV(opt.Default), \", \")))\n\t\t\t} else if len(opt.EnvKeyWithNamespace()) != 0 {\n\t\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\t\tfmt.Fprintf(wr, \" <default: \\\\fI%%%s%%\\\\fR>\", manQuote(opt.EnvKeyWithNamespace()))\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintf(wr, \" <default: \\\\fI$%s\\\\fR>\", manQuote(opt.EnvKeyWithNamespace()))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif opt.Required {\n\t\t\t\tfmt.Fprintf(wr, \" (\\\\fIrequired\\\\fR)\")\n\t\t\t}\n\n\t\t\tfmt.Fprintln(wr, \"\\\\fP\")\n\n\t\t\tif len(opt.Description) != 0 {\n\t\t\t\tformatForMan(wr, opt.Description, manQuoteLines)\n\t\t\t\tfmt.Fprintln(wr, \"\")\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc writeManPageSubcommands(wr io.Writer, name string, usagePrefix string, root *Command) {\n\tcommands := root.sortedVisibleCommands()\n\n\tfor _, c := range commands {\n\t\tvar nn string\n\n\t\tif c.Hidden {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(name) != 0 {\n\t\t\tnn = name + \" \" + c.Name\n\t\t} else {\n\t\t\tnn = c.Name\n\t\t}\n\n\t\twriteManPageCommand(wr, nn, usagePrefix, c)\n\t}\n}\n\nfunc writeManPageCommand(wr io.Writer, name string, usagePrefix string, command *Command) {\n\tfmt.Fprintf(wr, \".SS %s\\n\", name)\n\tfmt.Fprintln(wr, command.ShortDescription)\n\n\tif len(command.LongDescription) > 0 {\n\t\tfmt.Fprintln(wr, \"\")\n\n\t\tcmdstart := fmt.Sprintf(\"The %s command\", manQuote(command.Name))\n\n\t\tif strings.HasPrefix(command.LongDescription, cmdstart) {\n\t\t\tfmt.Fprintf(wr, \"The \\\\fI%s\\\\fP command\", manQuote(command.Name))\n\n\t\t\tformatForMan(wr, command.LongDescription[len(cmdstart):], manQuoteLines)\n\t\t\tfmt.Fprintln(wr, \"\")\n\t\t} else {\n\t\t\tformatForMan(wr, command.LongDescription, manQuoteLines)\n\t\t\tfmt.Fprintln(wr, \"\")\n\t\t}\n\t}\n\n\tvar pre = usagePrefix + \" \" + command.Name\n\n\tvar usage string\n\tif us, ok := command.data.(Usage); ok {\n\t\tusage = us.Usage()\n\t} else if command.hasHelpOptions() {\n\t\tusage = fmt.Sprintf(\"[%s-OPTIONS]\", command.Name)\n\t}\n\n\tvar nextPrefix = pre\n\tif len(usage) > 0 {\n\t\tfmt.Fprintf(wr, \"\\n\\\\fBUsage\\\\fP: %s %s\\n.TP\\n\", manQuote(pre), manQuote(usage))\n\t\tnextPrefix = pre + \" \" + usage\n\t}\n\n\tif len(command.Aliases) > 0 {\n\t\tfmt.Fprintf(wr, \"\\n\\\\fBAliases\\\\fP: %s\\n\\n\", manQuote(strings.Join(command.Aliases, \", \")))\n\t}\n\n\twriteManPageOptions(wr, command.Group)\n\twriteManPageSubcommands(wr, name, nextPrefix, command)\n}\n\n// WriteManPage writes a basic man page in groff format to the specified\n// writer.\nfunc (p *Parser) WriteManPage(wr io.Writer) {\n\tt := time.Now()\n\tsource_date_epoch := os.Getenv(\"SOURCE_DATE_EPOCH\")\n\tif source_date_epoch != \"\" {\n\t\tsde, err := strconv.ParseInt(source_date_epoch, 10, 64)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"Invalid SOURCE_DATE_EPOCH: %s\", err))\n\t\t}\n\t\tt = time.Unix(sde, 0)\n\t}\n\n\tfmt.Fprintf(wr, \".TH %s 1 \\\"%s\\\"\\n\", manQuote(p.Name), t.Format(\"2 January 2006\"))\n\tfmt.Fprintln(wr, \".SH NAME\")\n\tfmt.Fprintf(wr, \"%s \\\\- %s\\n\", manQuote(p.Name), manQuoteLines(p.ShortDescription))\n\tfmt.Fprintln(wr, \".SH SYNOPSIS\")\n\n\tusage := p.Usage\n\n\tif len(usage) == 0 {\n\t\tusage = \"[OPTIONS]\"\n\t}\n\n\tfmt.Fprintf(wr, \"\\\\fB%s\\\\fP %s\\n\", manQuote(p.Name), manQuote(usage))\n\tfmt.Fprintln(wr, \".SH DESCRIPTION\")\n\n\tformatForMan(wr, p.LongDescription, manQuoteLines)\n\tfmt.Fprintln(wr, \"\")\n\n\tfmt.Fprintln(wr, \".SH OPTIONS\")\n\n\twriteManPageOptions(wr, p.Command.Group)\n\n\tif len(p.visibleCommands()) > 0 {\n\t\tfmt.Fprintln(wr, \".SH COMMANDS\")\n\n\t\twriteManPageSubcommands(wr, \"\", p.Name+\" \"+usage, p.Command)\n\t}\n}\n"
        },
        {
          "name": "marshal_test.go",
          "type": "blob",
          "size": 2.431640625,
          "content": "package flags\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\ntype marshalled string\n\nfunc (m *marshalled) UnmarshalFlag(value string) error {\n\tif value == \"yes\" {\n\t\t*m = \"true\"\n\t} else if value == \"no\" {\n\t\t*m = \"false\"\n\t} else {\n\t\treturn fmt.Errorf(\"`%s' is not a valid value, please specify `yes' or `no'\", value)\n\t}\n\n\treturn nil\n}\n\nfunc (m marshalled) MarshalFlag() (string, error) {\n\tif m == \"true\" {\n\t\treturn \"yes\", nil\n\t}\n\n\treturn \"no\", nil\n}\n\ntype marshalledError bool\n\nfunc (m marshalledError) MarshalFlag() (string, error) {\n\treturn \"\", newErrorf(ErrMarshal, \"Failed to marshal\")\n}\n\nfunc TestUnmarshal(t *testing.T) {\n\tvar opts = struct {\n\t\tValue marshalled `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v=yes\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif opts.Value != \"true\" {\n\t\tt.Errorf(\"Expected Value to be \\\"true\\\"\")\n\t}\n}\n\nfunc TestUnmarshalDefault(t *testing.T) {\n\tvar opts = struct {\n\t\tValue marshalled `short:\"v\" default:\"yes\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts)\n\n\tassertStringArray(t, ret, []string{})\n\n\tif opts.Value != \"true\" {\n\t\tt.Errorf(\"Expected Value to be \\\"true\\\"\")\n\t}\n}\n\nfunc TestUnmarshalOptional(t *testing.T) {\n\tvar opts = struct {\n\t\tValue marshalled `short:\"v\" optional:\"yes\" optional-value:\"yes\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif opts.Value != \"true\" {\n\t\tt.Errorf(\"Expected Value to be \\\"true\\\"\")\n\t}\n}\n\nfunc TestUnmarshalError(t *testing.T) {\n\tvar opts = struct {\n\t\tValue marshalled `short:\"v\"`\n\t}{}\n\n\tassertParseFail(t, ErrMarshal, fmt.Sprintf(\"invalid argument for flag `%cv' (expected flags.marshalled): `invalid' is not a valid value, please specify `yes' or `no'\", defaultShortOptDelimiter), &opts, \"-vinvalid\")\n}\n\nfunc TestUnmarshalPositionalError(t *testing.T) {\n\tvar opts = struct {\n\t\tArgs struct {\n\t\t\tValue marshalled\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\tparser := NewParser(&opts, Default&^PrintErrors)\n\t_, err := parser.ParseArgs([]string{\"invalid\"})\n\n\tmsg := \"`invalid' is not a valid value, please specify `yes' or `no'\"\n\n\tif err == nil {\n\t\tassertFatalf(t, \"Expected error: %s\", msg)\n\t\treturn\n\t}\n\n\tif err.Error() != msg {\n\t\tassertErrorf(t, \"Expected error message %#v, but got %#v\", msg, err.Error())\n\t}\n}\n\nfunc TestMarshalError(t *testing.T) {\n\tvar opts = struct {\n\t\tValue marshalledError `short:\"v\"`\n\t}{}\n\n\tp := NewParser(&opts, Default)\n\to := p.Command.Groups()[0].Options()[0]\n\n\t_, err := convertToString(o.value, o.tag)\n\n\tassertError(t, err, ErrMarshal, \"Failed to marshal\")\n}\n"
        },
        {
          "name": "multitag.go",
          "type": "blob",
          "size": 2.3974609375,
          "content": "package flags\n\nimport (\n\t\"strconv\"\n)\n\ntype multiTag struct {\n\tvalue string\n\tcache map[string][]string\n}\n\nfunc newMultiTag(v string) multiTag {\n\treturn multiTag{\n\t\tvalue: v,\n\t}\n}\n\nfunc (x *multiTag) scan() (map[string][]string, error) {\n\tv := x.value\n\n\tret := make(map[string][]string)\n\n\t// This is mostly copied from reflect.StructTag.Get\n\tfor v != \"\" {\n\t\ti := 0\n\n\t\t// Skip whitespace\n\t\tfor i < len(v) && v[i] == ' ' {\n\t\t\ti++\n\t\t}\n\n\t\tv = v[i:]\n\n\t\tif v == \"\" {\n\t\t\tbreak\n\t\t}\n\n\t\t// Scan to colon to find key\n\t\ti = 0\n\n\t\tfor i < len(v) && v[i] != ' ' && v[i] != ':' && v[i] != '\"' {\n\t\t\ti++\n\t\t}\n\n\t\tif i >= len(v) {\n\t\t\treturn nil, newErrorf(ErrTag, \"expected `:' after key name, but got end of tag (in `%v`)\", x.value)\n\t\t}\n\n\t\tif v[i] != ':' {\n\t\t\treturn nil, newErrorf(ErrTag, \"expected `:' after key name, but got `%v' (in `%v`)\", v[i], x.value)\n\t\t}\n\n\t\tif i+1 >= len(v) {\n\t\t\treturn nil, newErrorf(ErrTag, \"expected `\\\"' to start tag value at end of tag (in `%v`)\", x.value)\n\t\t}\n\n\t\tif v[i+1] != '\"' {\n\t\t\treturn nil, newErrorf(ErrTag, \"expected `\\\"' to start tag value, but got `%v' (in `%v`)\", v[i+1], x.value)\n\t\t}\n\n\t\tname := v[:i]\n\t\tv = v[i+1:]\n\n\t\t// Scan quoted string to find value\n\t\ti = 1\n\n\t\tfor i < len(v) && v[i] != '\"' {\n\t\t\tif v[i] == '\\n' {\n\t\t\t\treturn nil, newErrorf(ErrTag, \"unexpected newline in tag value `%v' (in `%v`)\", name, x.value)\n\t\t\t}\n\n\t\t\tif v[i] == '\\\\' {\n\t\t\t\ti++\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\tif i >= len(v) {\n\t\t\treturn nil, newErrorf(ErrTag, \"expected end of tag value `\\\"' at end of tag (in `%v`)\", x.value)\n\t\t}\n\n\t\tval, err := strconv.Unquote(v[:i+1])\n\n\t\tif err != nil {\n\t\t\treturn nil, newErrorf(ErrTag, \"Malformed value of tag `%v:%v` => %v (in `%v`)\", name, v[:i+1], err, x.value)\n\t\t}\n\n\t\tv = v[i+1:]\n\n\t\tret[name] = append(ret[name], val)\n\t}\n\n\treturn ret, nil\n}\n\nfunc (x *multiTag) Parse() error {\n\tvals, err := x.scan()\n\tx.cache = vals\n\n\treturn err\n}\n\nfunc (x *multiTag) cached() map[string][]string {\n\tif x.cache == nil {\n\t\tcache, _ := x.scan()\n\n\t\tif cache == nil {\n\t\t\tcache = make(map[string][]string)\n\t\t}\n\n\t\tx.cache = cache\n\t}\n\n\treturn x.cache\n}\n\nfunc (x *multiTag) Get(key string) string {\n\tc := x.cached()\n\n\tif v, ok := c[key]; ok {\n\t\treturn v[len(v)-1]\n\t}\n\n\treturn \"\"\n}\n\nfunc (x *multiTag) GetMany(key string) []string {\n\tc := x.cached()\n\treturn c[key]\n}\n\nfunc (x *multiTag) Set(key string, value string) {\n\tc := x.cached()\n\tc[key] = []string{value}\n}\n\nfunc (x *multiTag) SetMany(key string, value []string) {\n\tc := x.cached()\n\tc[key] = value\n}\n"
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 12.2841796875,
          "content": "package flags\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// Option flag information. Contains a description of the option, short and\n// long name as well as a default value and whether an argument for this\n// flag is optional.\ntype Option struct {\n\t// The description of the option flag. This description is shown\n\t// automatically in the built-in help.\n\tDescription string\n\n\t// The short name of the option (a single character). If not 0, the\n\t// option flag can be 'activated' using -<ShortName>. Either ShortName\n\t// or LongName needs to be non-empty.\n\tShortName rune\n\n\t// The long name of the option. If not \"\", the option flag can be\n\t// activated using --<LongName>. Either ShortName or LongName needs\n\t// to be non-empty.\n\tLongName string\n\n\t// The default value of the option.\n\tDefault []string\n\n\t// The optional environment default value key name.\n\tEnvDefaultKey string\n\n\t// The optional delimiter string for EnvDefaultKey values.\n\tEnvDefaultDelim string\n\n\t// If true, specifies that the argument to an option flag is optional.\n\t// When no argument to the flag is specified on the command line, the\n\t// value of OptionalValue will be set in the field this option represents.\n\t// This is only valid for non-boolean options.\n\tOptionalArgument bool\n\n\t// The optional value of the option. The optional value is used when\n\t// the option flag is marked as having an OptionalArgument. This means\n\t// that when the flag is specified, but no option argument is given,\n\t// the value of the field this option represents will be set to\n\t// OptionalValue. This is only valid for non-boolean options.\n\tOptionalValue []string\n\n\t// If true, the option _must_ be specified on the command line. If the\n\t// option is not specified, the parser will generate an ErrRequired type\n\t// error.\n\tRequired bool\n\n\t// A name for the value of an option shown in the Help as --flag [ValueName]\n\tValueName string\n\n\t// A mask value to show in the help instead of the default value. This\n\t// is useful for hiding sensitive information in the help, such as\n\t// passwords.\n\tDefaultMask string\n\n\t// If non empty, only a certain set of values is allowed for an option.\n\tChoices []string\n\n\t// If true, the option is not displayed in the help or man page\n\tHidden bool\n\n\t// The group which the option belongs to\n\tgroup *Group\n\n\t// The struct field which the option represents.\n\tfield reflect.StructField\n\n\t// The struct field value which the option represents.\n\tvalue reflect.Value\n\n\t// Determines if the option will be always quoted in the INI output\n\tiniQuote bool\n\n\ttag                     multiTag\n\tisSet                   bool\n\tisSetDefault            bool\n\tpreventDefault          bool\n\tclearReferenceBeforeSet bool\n\n\tdefaultLiteral string\n}\n\n// LongNameWithNamespace returns the option's long name with the group namespaces\n// prepended by walking up the option's group tree. Namespaces and the long name\n// itself are separated by the parser's namespace delimiter. If the long name is\n// empty an empty string is returned.\nfunc (option *Option) LongNameWithNamespace() string {\n\tif len(option.LongName) == 0 {\n\t\treturn \"\"\n\t}\n\n\t// fetch the namespace delimiter from the parser which is always at the\n\t// end of the group hierarchy\n\tnamespaceDelimiter := \"\"\n\tg := option.group\n\n\tfor {\n\t\tif p, ok := g.parent.(*Parser); ok {\n\t\t\tnamespaceDelimiter = p.NamespaceDelimiter\n\n\t\t\tbreak\n\t\t}\n\n\t\tswitch i := g.parent.(type) {\n\t\tcase *Command:\n\t\t\tg = i.Group\n\t\tcase *Group:\n\t\t\tg = i\n\t\t}\n\t}\n\n\t// concatenate long name with namespace\n\tlongName := option.LongName\n\tg = option.group\n\n\tfor g != nil {\n\t\tif g.Namespace != \"\" {\n\t\t\tlongName = g.Namespace + namespaceDelimiter + longName\n\t\t}\n\n\t\tswitch i := g.parent.(type) {\n\t\tcase *Command:\n\t\t\tg = i.Group\n\t\tcase *Group:\n\t\t\tg = i\n\t\tcase *Parser:\n\t\t\tg = nil\n\t\t}\n\t}\n\n\treturn longName\n}\n\n// EnvKeyWithNamespace returns the option's env key with the group namespaces\n// prepended by walking up the option's group tree. Namespaces and the env key\n// itself are separated by the parser's namespace delimiter. If the env key is\n// empty an empty string is returned.\nfunc (option *Option) EnvKeyWithNamespace() string {\n\tif len(option.EnvDefaultKey) == 0 {\n\t\treturn \"\"\n\t}\n\n\t// fetch the namespace delimiter from the parser which is always at the\n\t// end of the group hierarchy\n\tnamespaceDelimiter := \"\"\n\tg := option.group\n\n\tfor {\n\t\tif p, ok := g.parent.(*Parser); ok {\n\t\t\tnamespaceDelimiter = p.EnvNamespaceDelimiter\n\n\t\t\tbreak\n\t\t}\n\n\t\tswitch i := g.parent.(type) {\n\t\tcase *Command:\n\t\t\tg = i.Group\n\t\tcase *Group:\n\t\t\tg = i\n\t\t}\n\t}\n\n\t// concatenate long name with namespace\n\tkey := option.EnvDefaultKey\n\tg = option.group\n\n\tfor g != nil {\n\t\tif g.EnvNamespace != \"\" {\n\t\t\tkey = g.EnvNamespace + namespaceDelimiter + key\n\t\t}\n\n\t\tswitch i := g.parent.(type) {\n\t\tcase *Command:\n\t\t\tg = i.Group\n\t\tcase *Group:\n\t\t\tg = i\n\t\tcase *Parser:\n\t\t\tg = nil\n\t\t}\n\t}\n\n\treturn key\n}\n\n// String converts an option to a human friendly readable string describing the\n// option.\nfunc (option *Option) String() string {\n\tvar s string\n\tvar short string\n\n\tif option.ShortName != 0 {\n\t\tdata := make([]byte, utf8.RuneLen(option.ShortName))\n\t\tutf8.EncodeRune(data, option.ShortName)\n\t\tshort = string(data)\n\n\t\tif len(option.LongName) != 0 {\n\t\t\ts = fmt.Sprintf(\"%s%s, %s%s\",\n\t\t\t\tstring(defaultShortOptDelimiter), short,\n\t\t\t\tdefaultLongOptDelimiter, option.LongNameWithNamespace())\n\t\t} else {\n\t\t\ts = fmt.Sprintf(\"%s%s\", string(defaultShortOptDelimiter), short)\n\t\t}\n\t} else if len(option.LongName) != 0 {\n\t\ts = fmt.Sprintf(\"%s%s\", defaultLongOptDelimiter, option.LongNameWithNamespace())\n\t}\n\n\treturn s\n}\n\n// Value returns the option value as an interface{}.\nfunc (option *Option) Value() interface{} {\n\treturn option.value.Interface()\n}\n\n// Field returns the reflect struct field of the option.\nfunc (option *Option) Field() reflect.StructField {\n\treturn option.field\n}\n\n// IsSet returns true if option has been set\nfunc (option *Option) IsSet() bool {\n\treturn option.isSet\n}\n\n// IsSetDefault returns true if option has been set via the default option tag\nfunc (option *Option) IsSetDefault() bool {\n\treturn option.isSetDefault\n}\n\n// Set the value of an option to the specified value. An error will be returned\n// if the specified value could not be converted to the corresponding option\n// value type.\nfunc (option *Option) Set(value *string) error {\n\tkind := option.value.Type().Kind()\n\n\tif (kind == reflect.Map || kind == reflect.Slice) && option.clearReferenceBeforeSet {\n\t\toption.empty()\n\t}\n\n\toption.isSet = true\n\toption.preventDefault = true\n\toption.clearReferenceBeforeSet = false\n\n\tif len(option.Choices) != 0 {\n\t\tfound := false\n\n\t\tfor _, choice := range option.Choices {\n\t\t\tif choice == *value {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !found {\n\t\t\tallowed := strings.Join(option.Choices[0:len(option.Choices)-1], \", \")\n\n\t\t\tif len(option.Choices) > 1 {\n\t\t\t\tallowed += \" or \" + option.Choices[len(option.Choices)-1]\n\t\t\t}\n\n\t\t\treturn newErrorf(ErrInvalidChoice,\n\t\t\t\t\"Invalid value `%s' for option `%s'. Allowed values are: %s\",\n\t\t\t\t*value, option, allowed)\n\t\t}\n\t}\n\n\tif option.isFunc() {\n\t\treturn option.call(value)\n\t} else if value != nil {\n\t\treturn convert(*value, option.value, option.tag)\n\t}\n\n\treturn convert(\"\", option.value, option.tag)\n}\n\nfunc (option *Option) setDefault(value *string) error {\n\tif option.preventDefault {\n\t\treturn nil\n\t}\n\n\tif err := option.Set(value); err != nil {\n\t\treturn err\n\t}\n\n\toption.isSetDefault = true\n\toption.preventDefault = false\n\n\treturn nil\n}\n\nfunc (option *Option) showInHelp() bool {\n\treturn !option.Hidden && (option.ShortName != 0 || len(option.LongName) != 0)\n}\n\nfunc (option *Option) canArgument() bool {\n\tif u := option.isUnmarshaler(); u != nil {\n\t\treturn true\n\t}\n\n\treturn !option.isBool()\n}\n\nfunc (option *Option) emptyValue() reflect.Value {\n\ttp := option.value.Type()\n\n\tif tp.Kind() == reflect.Map {\n\t\treturn reflect.MakeMap(tp)\n\t}\n\n\treturn reflect.Zero(tp)\n}\n\nfunc (option *Option) empty() {\n\tif !option.isFunc() {\n\t\toption.value.Set(option.emptyValue())\n\t}\n}\n\nfunc (option *Option) clearDefault() error {\n\tif option.preventDefault {\n\t\treturn nil\n\t}\n\n\tusedDefault := option.Default\n\n\tif envKey := option.EnvKeyWithNamespace(); envKey != \"\" {\n\t\tif value, ok := os.LookupEnv(envKey); ok {\n\t\t\tif option.EnvDefaultDelim != \"\" {\n\t\t\t\tusedDefault = strings.Split(value, option.EnvDefaultDelim)\n\t\t\t} else {\n\t\t\t\tusedDefault = []string{value}\n\t\t\t}\n\t\t}\n\t}\n\n\toption.isSetDefault = true\n\n\tif len(usedDefault) > 0 {\n\t\toption.empty()\n\n\t\tfor _, d := range usedDefault {\n\t\t\terr := option.setDefault(&d)\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttp := option.value.Type()\n\n\t\tswitch tp.Kind() {\n\t\tcase reflect.Map:\n\t\t\tif option.value.IsNil() {\n\t\t\t\toption.empty()\n\t\t\t}\n\t\tcase reflect.Slice:\n\t\t\tif option.value.IsNil() {\n\t\t\t\toption.empty()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (option *Option) valueIsDefault() bool {\n\t// Check if the value of the option corresponds to its\n\t// default value\n\temptyval := option.emptyValue()\n\n\tcheckvalptr := reflect.New(emptyval.Type())\n\tcheckval := reflect.Indirect(checkvalptr)\n\n\tcheckval.Set(emptyval)\n\n\tif len(option.Default) != 0 {\n\t\tfor _, v := range option.Default {\n\t\t\tconvert(v, checkval, option.tag)\n\t\t}\n\t}\n\n\treturn reflect.DeepEqual(option.value.Interface(), checkval.Interface())\n}\n\nfunc (option *Option) isUnmarshaler() Unmarshaler {\n\tv := option.value\n\n\tfor {\n\t\tif !v.CanInterface() {\n\t\t\tbreak\n\t\t}\n\n\t\ti := v.Interface()\n\n\t\tif u, ok := i.(Unmarshaler); ok {\n\t\t\treturn u\n\t\t}\n\n\t\tif !v.CanAddr() {\n\t\t\tbreak\n\t\t}\n\n\t\tv = v.Addr()\n\t}\n\n\treturn nil\n}\n\nfunc (option *Option) isValueValidator() ValueValidator {\n\tv := option.value\n\n\tfor {\n\t\tif !v.CanInterface() {\n\t\t\tbreak\n\t\t}\n\n\t\ti := v.Interface()\n\n\t\tif u, ok := i.(ValueValidator); ok {\n\t\t\treturn u\n\t\t}\n\n\t\tif !v.CanAddr() {\n\t\t\tbreak\n\t\t}\n\n\t\tv = v.Addr()\n\t}\n\n\treturn nil\n}\n\nfunc (option *Option) isBool() bool {\n\ttp := option.value.Type()\n\n\tfor {\n\t\tswitch tp.Kind() {\n\t\tcase reflect.Slice, reflect.Ptr:\n\t\t\ttp = tp.Elem()\n\t\tcase reflect.Bool:\n\t\t\treturn true\n\t\tcase reflect.Func:\n\t\t\treturn tp.NumIn() == 0\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunc (option *Option) isSignedNumber() bool {\n\ttp := option.value.Type()\n\n\tfor {\n\t\tswitch tp.Kind() {\n\t\tcase reflect.Slice, reflect.Ptr:\n\t\t\ttp = tp.Elem()\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Float32, reflect.Float64:\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunc (option *Option) isFunc() bool {\n\treturn option.value.Type().Kind() == reflect.Func\n}\n\nfunc (option *Option) call(value *string) error {\n\tvar retval []reflect.Value\n\n\tif value == nil {\n\t\tretval = option.value.Call(nil)\n\t} else {\n\t\ttp := option.value.Type().In(0)\n\n\t\tval := reflect.New(tp)\n\t\tval = reflect.Indirect(val)\n\n\t\tif err := convert(*value, val, option.tag); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tretval = option.value.Call([]reflect.Value{val})\n\t}\n\n\tif len(retval) == 1 && retval[0].Type() == reflect.TypeOf((*error)(nil)).Elem() {\n\t\tif retval[0].Interface() == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn retval[0].Interface().(error)\n\t}\n\n\treturn nil\n}\n\nfunc (option *Option) updateDefaultLiteral() {\n\tdefs := option.Default\n\tdef := \"\"\n\n\tif len(defs) == 0 && option.canArgument() {\n\t\tvar showdef bool\n\n\t\tswitch option.field.Type.Kind() {\n\t\tcase reflect.Func, reflect.Ptr:\n\t\t\tshowdef = !option.value.IsNil()\n\t\tcase reflect.Slice, reflect.String, reflect.Array:\n\t\t\tshowdef = option.value.Len() > 0\n\t\tcase reflect.Map:\n\t\t\tshowdef = !option.value.IsNil() && option.value.Len() > 0\n\t\tdefault:\n\t\t\tzeroval := reflect.Zero(option.field.Type)\n\t\t\tshowdef = !reflect.DeepEqual(zeroval.Interface(), option.value.Interface())\n\t\t}\n\n\t\tif showdef {\n\t\t\tdef, _ = convertToString(option.value, option.tag)\n\t\t}\n\t} else if len(defs) != 0 {\n\t\tl := len(defs) - 1\n\n\t\tfor i := 0; i < l; i++ {\n\t\t\tdef += quoteIfNeeded(defs[i]) + \", \"\n\t\t}\n\n\t\tdef += quoteIfNeeded(defs[l])\n\t}\n\n\toption.defaultLiteral = def\n}\n\nfunc (option *Option) shortAndLongName() string {\n\tret := &bytes.Buffer{}\n\n\tif option.ShortName != 0 {\n\t\tret.WriteRune(defaultShortOptDelimiter)\n\t\tret.WriteRune(option.ShortName)\n\t}\n\n\tif len(option.LongName) != 0 {\n\t\tif option.ShortName != 0 {\n\t\t\tret.WriteRune('/')\n\t\t}\n\n\t\tret.WriteString(option.LongName)\n\t}\n\n\treturn ret.String()\n}\n\nfunc (option *Option) isValidValue(arg string) error {\n\tif validator := option.isValueValidator(); validator != nil {\n\t\treturn validator.IsValidValue(arg)\n\t}\n\tif argumentIsOption(arg) && !(option.isSignedNumber() && len(arg) > 1 && arg[0] == '-' && arg[1] >= '0' && arg[1] <= '9') {\n\t\treturn fmt.Errorf(\"expected argument for flag `%s', but got option `%s'\", option, arg)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 2.7724609375,
          "content": "package flags\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestPassDoubleDash(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\t}{}\n\n\tp := NewParser(&opts, PassDoubleDash)\n\tret, err := p.ParseArgs([]string{\"-v\", \"--\", \"-v\", \"-g\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tassertStringArray(t, ret, []string{\"-v\", \"-g\"})\n}\n\nfunc TestPassAfterNonOption(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\t}{}\n\n\tp := NewParser(&opts, PassAfterNonOption)\n\tret, err := p.ParseArgs([]string{\"-v\", \"arg\", \"-v\", \"-g\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tassertStringArray(t, ret, []string{\"arg\", \"-v\", \"-g\"})\n}\n\nfunc TestPassAfterNonOptionWithPositional(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tRest []string `required:\"yes\"`\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, PassAfterNonOption)\n\tret, err := p.ParseArgs([]string{\"-v\", \"arg\", \"-v\", \"-g\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tassertStringArray(t, ret, []string{})\n\tassertStringArray(t, opts.Positional.Rest, []string{\"arg\", \"-v\", \"-g\"})\n}\n\nfunc TestPassAfterNonOptionWithPositionalIntPass(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tRest []int `required:\"yes\"`\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\tp := NewParser(&opts, PassAfterNonOption)\n\tret, err := p.ParseArgs([]string{\"-v\", \"1\", \"2\", \"3\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n\n\tassertStringArray(t, ret, []string{})\n\tfor i, rest := range opts.Positional.Rest {\n\t\tif rest != i+1 {\n\t\t\tassertErrorf(t, \"Expected %v got %v\", i+1, rest)\n\t\t}\n\t}\n}\n\nfunc TestPassAfterNonOptionWithPositionalIntFail(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tPositional struct {\n\t\t\tRest []int `required:\"yes\"`\n\t\t} `positional-args:\"yes\"`\n\t}{}\n\n\ttests := []struct {\n\t\topts        []string\n\t\terrContains string\n\t\tret         []string\n\t}{\n\t\t{\n\t\t\t[]string{\"-v\", \"notint1\", \"notint2\", \"notint3\"},\n\t\t\t\"notint1\",\n\t\t\t[]string{\"notint1\", \"notint2\", \"notint3\"},\n\t\t},\n\t\t{\n\t\t\t[]string{\"-v\", \"1\", \"notint2\", \"notint3\"},\n\t\t\t\"notint2\",\n\t\t\t[]string{\"1\", \"notint2\", \"notint3\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tp := NewParser(&opts, PassAfterNonOption)\n\t\tret, err := p.ParseArgs(test.opts)\n\n\t\tif err == nil {\n\t\t\tassertErrorf(t, \"Expected error\")\n\t\t\treturn\n\t\t}\n\n\t\tif !strings.Contains(err.Error(), test.errContains) {\n\t\t\tassertErrorf(t, \"Expected the first illegal argument in the error\")\n\t\t}\n\n\t\tassertStringArray(t, ret, test.ret)\n\t}\n}\n"
        },
        {
          "name": "optstyle_other.go",
          "type": "blob",
          "size": 1.6328125,
          "content": "//go:build !windows || forceposix\n// +build !windows forceposix\n\npackage flags\n\nimport (\n\t\"strings\"\n)\n\nconst (\n\tdefaultShortOptDelimiter = '-'\n\tdefaultLongOptDelimiter  = \"--\"\n\tdefaultNameArgDelimiter  = '='\n)\n\nfunc argumentStartsOption(arg string) bool {\n\treturn len(arg) > 0 && arg[0] == '-'\n}\n\nfunc argumentIsOption(arg string) bool {\n\tif len(arg) > 1 && arg[0] == '-' && arg[1] != '-' {\n\t\treturn true\n\t}\n\n\tif len(arg) > 2 && arg[0] == '-' && arg[1] == '-' && arg[2] != '-' {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// stripOptionPrefix returns the option without the prefix and whether or\n// not the option is a long option or not.\nfunc stripOptionPrefix(optname string) (prefix string, name string, islong bool) {\n\tif strings.HasPrefix(optname, \"--\") {\n\t\treturn \"--\", optname[2:], true\n\t} else if strings.HasPrefix(optname, \"-\") {\n\t\treturn \"-\", optname[1:], false\n\t}\n\n\treturn \"\", optname, false\n}\n\n// splitOption attempts to split the passed option into a name and an argument.\n// When there is no argument specified, nil will be returned for it.\nfunc splitOption(prefix string, option string, islong bool) (string, string, *string) {\n\tpos := strings.Index(option, \"=\")\n\n\tif (islong && pos >= 0) || (!islong && pos == 1) {\n\t\trest := option[pos+1:]\n\t\treturn option[:pos], \"=\", &rest\n\t}\n\n\treturn option, \"\", nil\n}\n\n// addHelpGroup adds a new group that contains default help parameters.\nfunc (c *Command) addHelpGroup(showHelp func() error) *Group {\n\tvar help struct {\n\t\tShowHelp func() error `short:\"h\" long:\"help\" description:\"Show this help message\"`\n\t}\n\n\thelp.ShowHelp = showHelp\n\tret, _ := c.AddGroup(\"Help Options\", \"\", &help)\n\tret.isBuiltinHelp = true\n\n\treturn ret\n}\n"
        },
        {
          "name": "optstyle_windows.go",
          "type": "blob",
          "size": 2.8994140625,
          "content": "//go:build !forceposix\n// +build !forceposix\n\npackage flags\n\nimport (\n\t\"strings\"\n)\n\n// Windows uses a front slash for both short and long options.  Also it uses\n// a colon for name/argument delimter.\nconst (\n\tdefaultShortOptDelimiter = '/'\n\tdefaultLongOptDelimiter  = \"/\"\n\tdefaultNameArgDelimiter  = ':'\n)\n\nfunc argumentStartsOption(arg string) bool {\n\treturn len(arg) > 0 && (arg[0] == '-' || arg[0] == '/')\n}\n\nfunc argumentIsOption(arg string) bool {\n\t// Windows-style options allow front slash for the option\n\t// delimiter.\n\tif len(arg) > 1 && arg[0] == '/' {\n\t\treturn true\n\t}\n\n\tif len(arg) > 1 && arg[0] == '-' && arg[1] != '-' {\n\t\treturn true\n\t}\n\n\tif len(arg) > 2 && arg[0] == '-' && arg[1] == '-' && arg[2] != '-' {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// stripOptionPrefix returns the option without the prefix and whether or\n// not the option is a long option or not.\nfunc stripOptionPrefix(optname string) (prefix string, name string, islong bool) {\n\t// Determine if the argument is a long option or not.  Windows\n\t// typically supports both long and short options with a single\n\t// front slash as the option delimiter, so handle this situation\n\t// nicely.\n\tpossplit := 0\n\n\tif strings.HasPrefix(optname, \"--\") {\n\t\tpossplit = 2\n\t\tislong = true\n\t} else if strings.HasPrefix(optname, \"-\") {\n\t\tpossplit = 1\n\t\tislong = false\n\t} else if strings.HasPrefix(optname, \"/\") {\n\t\tpossplit = 1\n\t\tislong = len(optname) > 2\n\t}\n\n\treturn optname[:possplit], optname[possplit:], islong\n}\n\n// splitOption attempts to split the passed option into a name and an argument.\n// When there is no argument specified, nil will be returned for it.\nfunc splitOption(prefix string, option string, islong bool) (string, string, *string) {\n\tif len(option) == 0 {\n\t\treturn option, \"\", nil\n\t}\n\n\t// Windows typically uses a colon for the option name and argument\n\t// delimiter while POSIX typically uses an equals.  Support both styles,\n\t// but don't allow the two to be mixed.  That is to say /foo:bar and\n\t// --foo=bar are acceptable, but /foo=bar and --foo:bar are not.\n\tvar pos int\n\tvar sp string\n\n\tif prefix == \"/\" {\n\t\tsp = \":\"\n\t\tpos = strings.Index(option, sp)\n\t} else if len(prefix) > 0 {\n\t\tsp = \"=\"\n\t\tpos = strings.Index(option, sp)\n\t}\n\n\tif (islong && pos >= 0) || (!islong && pos == 1) {\n\t\trest := option[pos+1:]\n\t\treturn option[:pos], sp, &rest\n\t}\n\n\treturn option, \"\", nil\n}\n\n// addHelpGroup adds a new group that contains default help parameters.\nfunc (c *Command) addHelpGroup(showHelp func() error) *Group {\n\t// Windows CLI applications typically use /? for help, so make both\n\t// that available as well as the POSIX style h and help.\n\tvar help struct {\n\t\tShowHelpWindows func() error `short:\"?\" description:\"Show this help message\"`\n\t\tShowHelpPosix   func() error `short:\"h\" long:\"help\" description:\"Show this help message\"`\n\t}\n\n\thelp.ShowHelpWindows = showHelp\n\thelp.ShowHelpPosix = showHelp\n\n\tret, _ := c.AddGroup(\"Help Options\", \"\", &help)\n\tret.isBuiltinHelp = true\n\n\treturn ret\n}\n"
        },
        {
          "name": "parser.go",
          "type": "blob",
          "size": 18.53125,
          "content": "// Copyright 2012 Jesse van den Kieboom. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage flags\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// A Parser provides command line option parsing. It can contain several\n// option groups each with their own set of options.\ntype Parser struct {\n\t// Embedded, see Command for more information\n\t*Command\n\n\t// A usage string to be displayed in the help message.\n\tUsage string\n\n\t// Option flags changing the behavior of the parser.\n\tOptions Options\n\n\t// NamespaceDelimiter separates group namespaces and option long names\n\tNamespaceDelimiter string\n\n\t// EnvNamespaceDelimiter separates group env namespaces and env keys\n\tEnvNamespaceDelimiter string\n\n\t// UnknownOptionsHandler is a function which gets called when the parser\n\t// encounters an unknown option. The function receives the unknown option\n\t// name, a SplitArgument which specifies its value if set with an argument\n\t// separator, and the remaining command line arguments.\n\t// It should return a new list of remaining arguments to continue parsing,\n\t// or an error to indicate a parse failure.\n\tUnknownOptionHandler func(option string, arg SplitArgument, args []string) ([]string, error)\n\n\t// CompletionHandler is a function gets called to handle the completion of\n\t// items. By default, the items are printed and the application is exited.\n\t// You can override this default behavior by specifying a custom CompletionHandler.\n\tCompletionHandler func(items []Completion)\n\n\t// CommandHandler is a function that gets called to handle execution of a\n\t// command. By default, the command will simply be executed. This can be\n\t// overridden to perform certain actions (such as applying global flags)\n\t// just before the command is executed. Note that if you override the\n\t// handler it is your responsibility to call the command.Execute function.\n\t//\n\t// The command passed into CommandHandler may be nil in case there is no\n\t// command to be executed when parsing has finished.\n\tCommandHandler func(command Commander, args []string) error\n\n\tinternalError error\n}\n\n// SplitArgument represents the argument value of an option that was passed using\n// an argument separator.\ntype SplitArgument interface {\n\t// String returns the option's value as a string, and a boolean indicating\n\t// if the option was present.\n\tValue() (string, bool)\n}\n\ntype strArgument struct {\n\tvalue *string\n}\n\nfunc (s strArgument) Value() (string, bool) {\n\tif s.value == nil {\n\t\treturn \"\", false\n\t}\n\n\treturn *s.value, true\n}\n\n// Options provides parser options that change the behavior of the option\n// parser.\ntype Options uint\n\nconst (\n\t// None indicates no options.\n\tNone Options = 0\n\n\t// HelpFlag adds a default Help Options group to the parser containing\n\t// -h and --help options. When either -h or --help is specified on the\n\t// command line, the parser will return the special error of type\n\t// ErrHelp. When PrintErrors is also specified, then the help message\n\t// will also be automatically printed to os.Stdout.\n\tHelpFlag = 1 << iota\n\n\t// PassDoubleDash passes all arguments after a double dash, --, as\n\t// remaining command line arguments (i.e. they will not be parsed for\n\t// flags).\n\tPassDoubleDash\n\n\t// IgnoreUnknown ignores any unknown options and passes them as\n\t// remaining command line arguments instead of generating an error.\n\tIgnoreUnknown\n\n\t// PrintErrors prints any errors which occurred during parsing to\n\t// os.Stderr. In the special case of ErrHelp, the message will be printed\n\t// to os.Stdout.\n\tPrintErrors\n\n\t// PassAfterNonOption passes all arguments after the first non option\n\t// as remaining command line arguments. This is equivalent to strict\n\t// POSIX processing.\n\tPassAfterNonOption\n\n\t// AllowBoolValues allows a user to assign true/false to a boolean value\n\t// rather than raising an error stating it cannot have an argument.\n\tAllowBoolValues\n\n\t// Default is a convenient default set of options which should cover\n\t// most of the uses of the flags package.\n\tDefault = HelpFlag | PrintErrors | PassDoubleDash\n)\n\ntype parseState struct {\n\targ        string\n\targs       []string\n\tretargs    []string\n\tpositional []*Arg\n\terr        error\n\n\tcommand *Command\n\tlookup  lookup\n}\n\n// Parse is a convenience function to parse command line options with default\n// settings. The provided data is a pointer to a struct representing the\n// default option group (named \"Application Options\"). For more control, use\n// flags.NewParser.\nfunc Parse(data interface{}) ([]string, error) {\n\treturn NewParser(data, Default).Parse()\n}\n\n// ParseArgs is a convenience function to parse command line options with default\n// settings. The provided data is a pointer to a struct representing the\n// default option group (named \"Application Options\"). The args argument is\n// the list of command line arguments to parse. If you just want to parse the\n// default program command line arguments (i.e. os.Args), then use flags.Parse\n// instead. For more control, use flags.NewParser.\nfunc ParseArgs(data interface{}, args []string) ([]string, error) {\n\treturn NewParser(data, Default).ParseArgs(args)\n}\n\n// NewParser creates a new parser. It uses os.Args[0] as the application\n// name and then calls Parser.NewNamedParser (see Parser.NewNamedParser for\n// more details). The provided data is a pointer to a struct representing the\n// default option group (named \"Application Options\"), or nil if the default\n// group should not be added. The options parameter specifies a set of options\n// for the parser.\nfunc NewParser(data interface{}, options Options) *Parser {\n\tp := NewNamedParser(path.Base(os.Args[0]), options)\n\n\tif data != nil {\n\t\tg, err := p.AddGroup(\"Application Options\", \"\", data)\n\n\t\tif err == nil {\n\t\t\tg.parent = p\n\t\t}\n\n\t\tp.internalError = err\n\t}\n\n\treturn p\n}\n\n// NewNamedParser creates a new parser. The appname is used to display the\n// executable name in the built-in help message. Option groups and commands can\n// be added to this parser by using AddGroup and AddCommand.\nfunc NewNamedParser(appname string, options Options) *Parser {\n\tp := &Parser{\n\t\tCommand:               newCommand(appname, \"\", \"\", nil),\n\t\tOptions:               options,\n\t\tNamespaceDelimiter:    \".\",\n\t\tEnvNamespaceDelimiter: \"_\",\n\t}\n\n\tp.Command.parent = p\n\n\treturn p\n}\n\n// Parse parses the command line arguments from os.Args using Parser.ParseArgs.\n// For more detailed information see ParseArgs.\nfunc (p *Parser) Parse() ([]string, error) {\n\treturn p.ParseArgs(os.Args[1:])\n}\n\n// ParseArgs parses the command line arguments according to the option groups that\n// were added to the parser. On successful parsing of the arguments, the\n// remaining, non-option, arguments (if any) are returned. The returned error\n// indicates a parsing error and can be used with PrintError to display\n// contextual information on where the error occurred exactly.\n//\n// When the common help group has been added (AddHelp) and either -h or --help\n// was specified in the command line arguments, a help message will be\n// automatically printed if the PrintErrors option is enabled.\n// Furthermore, the special error type ErrHelp is returned.\n// It is up to the caller to exit the program if so desired.\nfunc (p *Parser) ParseArgs(args []string) ([]string, error) {\n\tif p.internalError != nil {\n\t\treturn nil, p.internalError\n\t}\n\n\tp.eachOption(func(c *Command, g *Group, option *Option) {\n\t\toption.clearReferenceBeforeSet = true\n\t\toption.updateDefaultLiteral()\n\t})\n\n\t// Add built-in help group to all commands if necessary\n\tif (p.Options & HelpFlag) != None {\n\t\tp.addHelpGroups(p.showBuiltinHelp)\n\t}\n\n\tcompval := os.Getenv(\"GO_FLAGS_COMPLETION\")\n\n\tif len(compval) != 0 {\n\t\tcomp := &completion{parser: p}\n\t\titems := comp.complete(args)\n\n\t\tif p.CompletionHandler != nil {\n\t\t\tp.CompletionHandler(items)\n\t\t} else {\n\t\t\tcomp.print(items, compval == \"verbose\")\n\t\t\tos.Exit(0)\n\t\t}\n\n\t\treturn nil, nil\n\t}\n\n\ts := &parseState{\n\t\targs:    args,\n\t\tretargs: make([]string, 0, len(args)),\n\t}\n\n\tp.fillParseState(s)\n\n\tfor !s.eof() {\n\t\tvar err error\n\t\targ := s.pop()\n\n\t\t// When PassDoubleDash is set and we encounter a --, then\n\t\t// simply append all the rest as arguments and break out\n\t\tif (p.Options&PassDoubleDash) != None && arg == \"--\" {\n\t\t\ts.addArgs(s.args...)\n\t\t\tbreak\n\t\t}\n\n\t\tif !argumentIsOption(arg) {\n\t\t\tif ((p.Options&PassAfterNonOption) != None || s.command.PassAfterNonOption) && s.lookup.commands[arg] == nil {\n\t\t\t\t// If PassAfterNonOption is set then all remaining arguments\n\t\t\t\t// are considered positional\n\t\t\t\tif err = s.addArgs(s.arg); err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif err = s.addArgs(s.args...); err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Note: this also sets s.err, so we can just check for\n\t\t\t// nil here and use s.err later\n\t\t\tif p.parseNonOption(s) != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tprefix, optname, islong := stripOptionPrefix(arg)\n\t\toptname, _, argument := splitOption(prefix, optname, islong)\n\n\t\tif islong {\n\t\t\terr = p.parseLong(s, optname, argument)\n\t\t} else {\n\t\t\terr = p.parseShort(s, optname, argument)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tignoreUnknown := (p.Options & IgnoreUnknown) != None\n\t\t\tparseErr := wrapError(err)\n\n\t\t\tif parseErr.Type != ErrUnknownFlag || (!ignoreUnknown && p.UnknownOptionHandler == nil) {\n\t\t\t\ts.err = parseErr\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif ignoreUnknown {\n\t\t\t\ts.addArgs(arg)\n\t\t\t} else if p.UnknownOptionHandler != nil {\n\t\t\t\tmodifiedArgs, err := p.UnknownOptionHandler(optname, strArgument{argument}, s.args)\n\n\t\t\t\tif err != nil {\n\t\t\t\t\ts.err = err\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\ts.args = modifiedArgs\n\t\t\t}\n\t\t}\n\t}\n\n\tif s.err == nil {\n\t\tp.eachOption(func(c *Command, g *Group, option *Option) {\n\t\t\terr := option.clearDefault()\n\t\t\tif err != nil {\n\t\t\t\tif _, ok := err.(*Error); !ok {\n\t\t\t\t\terr = p.marshalError(option, err)\n\t\t\t\t}\n\t\t\t\ts.err = err\n\t\t\t}\n\t\t})\n\n\t\ts.checkRequired(p)\n\t}\n\n\tvar reterr error\n\n\tif s.err != nil {\n\t\treterr = s.err\n\t} else if len(s.command.commands) != 0 && !s.command.SubcommandsOptional {\n\t\treterr = s.estimateCommand()\n\t} else if cmd, ok := s.command.data.(Commander); ok {\n\t\tif p.CommandHandler != nil {\n\t\t\treterr = p.CommandHandler(cmd, s.retargs)\n\t\t} else {\n\t\t\treterr = cmd.Execute(s.retargs)\n\t\t}\n\t} else if p.CommandHandler != nil {\n\t\treterr = p.CommandHandler(nil, s.retargs)\n\t}\n\n\tif reterr != nil {\n\t\tvar retargs []string\n\n\t\tif ourErr, ok := reterr.(*Error); !ok || ourErr.Type != ErrHelp {\n\t\t\tretargs = append([]string{s.arg}, s.args...)\n\t\t} else {\n\t\t\tretargs = s.args\n\t\t}\n\n\t\treturn retargs, p.printError(reterr)\n\t}\n\n\treturn s.retargs, nil\n}\n\nfunc (p *parseState) eof() bool {\n\treturn len(p.args) == 0\n}\n\nfunc (p *parseState) pop() string {\n\tif p.eof() {\n\t\treturn \"\"\n\t}\n\n\tp.arg = p.args[0]\n\tp.args = p.args[1:]\n\n\treturn p.arg\n}\n\nfunc (p *parseState) peek() string {\n\tif p.eof() {\n\t\treturn \"\"\n\t}\n\n\treturn p.args[0]\n}\n\nfunc (p *parseState) checkRequired(parser *Parser) error {\n\tc := parser.Command\n\n\tvar required []*Option\n\n\tfor c != nil {\n\t\tc.eachGroup(func(g *Group) {\n\t\t\tfor _, option := range g.options {\n\t\t\t\tif !option.isSet && option.Required {\n\t\t\t\t\trequired = append(required, option)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tc = c.Active\n\t}\n\n\tif len(required) == 0 {\n\t\tif len(p.positional) > 0 {\n\t\t\tvar reqnames []string\n\n\t\t\tfor _, arg := range p.positional {\n\t\t\t\targRequired := (!arg.isRemaining() && p.command.ArgsRequired) || arg.Required != -1 || arg.RequiredMaximum != -1\n\n\t\t\t\tif !argRequired {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif arg.isRemaining() {\n\t\t\t\t\tif arg.value.Len() < arg.Required {\n\t\t\t\t\t\tvar arguments string\n\n\t\t\t\t\t\tif arg.Required > 1 {\n\t\t\t\t\t\t\targuments = \"arguments, but got only \" + fmt.Sprintf(\"%d\", arg.value.Len())\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targuments = \"argument\"\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treqnames = append(reqnames, \"`\"+arg.Name+\" (at least \"+fmt.Sprintf(\"%d\", arg.Required)+\" \"+arguments+\")`\")\n\t\t\t\t\t} else if arg.RequiredMaximum != -1 && arg.value.Len() > arg.RequiredMaximum {\n\t\t\t\t\t\tif arg.RequiredMaximum == 0 {\n\t\t\t\t\t\t\treqnames = append(reqnames, \"`\"+arg.Name+\" (zero arguments)`\")\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar arguments string\n\n\t\t\t\t\t\t\tif arg.RequiredMaximum > 1 {\n\t\t\t\t\t\t\t\targuments = \"arguments, but got \" + fmt.Sprintf(\"%d\", arg.value.Len())\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\targuments = \"argument\"\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treqnames = append(reqnames, \"`\"+arg.Name+\" (at most \"+fmt.Sprintf(\"%d\", arg.RequiredMaximum)+\" \"+arguments+\")`\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treqnames = append(reqnames, \"`\"+arg.Name+\"`\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(reqnames) == 0 {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tvar msg string\n\n\t\t\tif len(reqnames) == 1 {\n\t\t\t\tmsg = fmt.Sprintf(\"the required argument %s was not provided\", reqnames[0])\n\t\t\t} else {\n\t\t\t\tmsg = fmt.Sprintf(\"the required arguments %s and %s were not provided\",\n\t\t\t\t\tstrings.Join(reqnames[:len(reqnames)-1], \", \"), reqnames[len(reqnames)-1])\n\t\t\t}\n\n\t\t\tp.err = newError(ErrRequired, msg)\n\t\t\treturn p.err\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tnames := make([]string, 0, len(required))\n\n\tfor _, k := range required {\n\t\tnames = append(names, \"`\"+k.String()+\"'\")\n\t}\n\n\tsort.Strings(names)\n\n\tvar msg string\n\n\tif len(names) == 1 {\n\t\tmsg = fmt.Sprintf(\"the required flag %s was not specified\", names[0])\n\t} else {\n\t\tmsg = fmt.Sprintf(\"the required flags %s and %s were not specified\",\n\t\t\tstrings.Join(names[:len(names)-1], \", \"), names[len(names)-1])\n\t}\n\n\tp.err = newError(ErrRequired, msg)\n\treturn p.err\n}\n\nfunc (p *parseState) estimateCommand() error {\n\tcommands := p.command.sortedVisibleCommands()\n\tcmdnames := make([]string, len(commands))\n\n\tfor i, v := range commands {\n\t\tcmdnames[i] = v.Name\n\t}\n\n\tvar msg string\n\tvar errtype ErrorType\n\n\tif len(p.retargs) != 0 {\n\t\tc, l := closestChoice(p.retargs[0], cmdnames)\n\t\tmsg = fmt.Sprintf(\"Unknown command `%s'\", p.retargs[0])\n\t\terrtype = ErrUnknownCommand\n\n\t\tif float32(l)/float32(len(c)) < 0.5 {\n\t\t\tmsg = fmt.Sprintf(\"%s, did you mean `%s'?\", msg, c)\n\t\t} else if len(cmdnames) == 1 {\n\t\t\tmsg = fmt.Sprintf(\"%s. You should use the %s command\",\n\t\t\t\tmsg,\n\t\t\t\tcmdnames[0])\n\t\t} else if len(cmdnames) > 1 {\n\t\t\tmsg = fmt.Sprintf(\"%s. Please specify one command of: %s or %s\",\n\t\t\t\tmsg,\n\t\t\t\tstrings.Join(cmdnames[:len(cmdnames)-1], \", \"),\n\t\t\t\tcmdnames[len(cmdnames)-1])\n\t\t}\n\t} else {\n\t\terrtype = ErrCommandRequired\n\n\t\tif len(cmdnames) == 1 {\n\t\t\tmsg = fmt.Sprintf(\"Please specify the %s command\", cmdnames[0])\n\t\t} else if len(cmdnames) > 1 {\n\t\t\tmsg = fmt.Sprintf(\"Please specify one command of: %s or %s\",\n\t\t\t\tstrings.Join(cmdnames[:len(cmdnames)-1], \", \"),\n\t\t\t\tcmdnames[len(cmdnames)-1])\n\t\t}\n\t}\n\n\treturn newError(errtype, msg)\n}\n\nfunc (p *Parser) parseOption(s *parseState, name string, option *Option, canarg bool, argument *string) (err error) {\n\tif !option.canArgument() {\n\t\tif argument != nil && (p.Options&AllowBoolValues) == None {\n\t\t\treturn newErrorf(ErrNoArgumentForBool, \"bool flag `%s' cannot have an argument\", option)\n\t\t}\n\t\terr = option.Set(argument)\n\t} else if argument != nil || (canarg && !s.eof()) {\n\t\tvar arg string\n\n\t\tif argument != nil {\n\t\t\targ = *argument\n\t\t} else {\n\t\t\targ = s.pop()\n\n\t\t\tif validationErr := option.isValidValue(arg); validationErr != nil {\n\t\t\t\treturn newErrorf(ErrExpectedArgument, validationErr.Error())\n\t\t\t} else if p.Options&PassDoubleDash != 0 && arg == \"--\" {\n\t\t\t\treturn newErrorf(ErrExpectedArgument, \"expected argument for flag `%s', but got double dash `--'\", option)\n\t\t\t}\n\t\t}\n\n\t\tif option.tag.Get(\"unquote\") != \"false\" {\n\t\t\targ, err = unquoteIfPossible(arg)\n\t\t}\n\n\t\tif err == nil {\n\t\t\terr = option.Set(&arg)\n\t\t}\n\t} else if option.OptionalArgument {\n\t\toption.empty()\n\n\t\tfor _, v := range option.OptionalValue {\n\t\t\terr = option.Set(&v)\n\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\terr = newErrorf(ErrExpectedArgument, \"expected argument for flag `%s'\", option)\n\t}\n\n\tif err != nil {\n\t\tif _, ok := err.(*Error); !ok {\n\t\t\terr = p.marshalError(option, err)\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (p *Parser) marshalError(option *Option, err error) *Error {\n\ts := \"invalid argument for flag `%s'\"\n\n\texpected := p.expectedType(option)\n\n\tif expected != \"\" {\n\t\ts = s + \" (expected \" + expected + \")\"\n\t}\n\n\treturn newErrorf(ErrMarshal, s+\": %s\",\n\t\toption,\n\t\terr.Error())\n}\n\nfunc (p *Parser) expectedType(option *Option) string {\n\tvalueType := option.value.Type()\n\n\tif valueType.Kind() == reflect.Func {\n\t\treturn \"\"\n\t}\n\n\treturn valueType.String()\n}\n\nfunc (p *Parser) parseLong(s *parseState, name string, argument *string) error {\n\tif option := s.lookup.longNames[name]; option != nil {\n\t\t// Only long options that are required can consume an argument\n\t\t// from the argument list\n\t\tcanarg := !option.OptionalArgument\n\n\t\treturn p.parseOption(s, name, option, canarg, argument)\n\t}\n\n\treturn newErrorf(ErrUnknownFlag, \"unknown flag `%s'\", name)\n}\n\nfunc (p *Parser) splitShortConcatArg(s *parseState, optname string) (string, *string) {\n\tc, n := utf8.DecodeRuneInString(optname)\n\n\tif n == len(optname) {\n\t\treturn optname, nil\n\t}\n\n\tfirst := string(c)\n\n\tif option := s.lookup.shortNames[first]; option != nil && option.canArgument() {\n\t\targ := optname[n:]\n\t\treturn first, &arg\n\t}\n\n\treturn optname, nil\n}\n\nfunc (p *Parser) parseShort(s *parseState, optname string, argument *string) error {\n\tif argument == nil {\n\t\toptname, argument = p.splitShortConcatArg(s, optname)\n\t}\n\n\tfor i, c := range optname {\n\t\tshortname := string(c)\n\n\t\tif option := s.lookup.shortNames[shortname]; option != nil {\n\t\t\t// Only the last short argument can consume an argument from\n\t\t\t// the arguments list, and only if it's non optional\n\t\t\tcanarg := (i+utf8.RuneLen(c) == len(optname)) && !option.OptionalArgument\n\n\t\t\tif err := p.parseOption(s, shortname, option, canarg, argument); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn newErrorf(ErrUnknownFlag, \"unknown flag `%s'\", shortname)\n\t\t}\n\n\t\t// Only the first option can have a concatted argument, so just\n\t\t// clear argument here\n\t\targument = nil\n\t}\n\n\treturn nil\n}\n\nfunc (p *parseState) addArgs(args ...string) error {\n\tfor len(p.positional) > 0 && len(args) > 0 {\n\t\targ := p.positional[0]\n\n\t\tif err := convert(args[0], arg.value, arg.tag); err != nil {\n\t\t\tp.err = err\n\t\t\treturn err\n\t\t}\n\n\t\tif !arg.isRemaining() {\n\t\t\tp.positional = p.positional[1:]\n\t\t}\n\n\t\targs = args[1:]\n\t}\n\n\tp.retargs = append(p.retargs, args...)\n\treturn nil\n}\n\nfunc (p *Parser) parseNonOption(s *parseState) error {\n\tif len(s.positional) > 0 {\n\t\treturn s.addArgs(s.arg)\n\t}\n\n\tif len(s.command.commands) > 0 && len(s.retargs) == 0 {\n\t\tif cmd := s.lookup.commands[s.arg]; cmd != nil {\n\t\t\ts.command.Active = cmd\n\t\t\tcmd.fillParseState(s)\n\n\t\t\treturn nil\n\t\t} else if !s.command.SubcommandsOptional {\n\t\t\ts.addArgs(s.arg)\n\t\t\treturn newErrorf(ErrUnknownCommand, \"Unknown command `%s'\", s.arg)\n\t\t}\n\t}\n\n\treturn s.addArgs(s.arg)\n}\n\nfunc (p *Parser) showBuiltinHelp() error {\n\tvar b bytes.Buffer\n\n\tp.WriteHelp(&b)\n\treturn newError(ErrHelp, b.String())\n}\n\nfunc (p *Parser) printError(err error) error {\n\tif err != nil && (p.Options&PrintErrors) != None {\n\t\tflagsErr, ok := err.(*Error)\n\n\t\tif ok && flagsErr.Type == ErrHelp {\n\t\t\tfmt.Fprintln(os.Stdout, err)\n\t\t} else {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t}\n\t}\n\n\treturn err\n}\n"
        },
        {
          "name": "parser_test.go",
          "type": "blob",
          "size": 19.701171875,
          "content": "package flags\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype defaultOptions struct {\n\tInt           int `long:\"i\"`\n\tIntDefault    int `long:\"id\" default:\"1\"`\n\tIntUnderscore int `long:\"idu\" default:\"1_0\"`\n\n\tFloat64           float64 `long:\"f\"`\n\tFloat64Default    float64 `long:\"fd\" default:\"-3.14\"`\n\tFloat64Underscore float64 `long:\"fdu\" default:\"-3_3.14\"`\n\n\tNumericFlag bool `short:\"3\"`\n\n\tString            string `long:\"str\"`\n\tStringDefault     string `long:\"strd\" default:\"abc\"`\n\tStringNotUnquoted string `long:\"strnot\" unquote:\"false\"`\n\n\tTime        time.Duration `long:\"t\"`\n\tTimeDefault time.Duration `long:\"td\" default:\"1m\"`\n\n\tMap        map[string]int `long:\"m\"`\n\tMapDefault map[string]int `long:\"md\" default:\"a:1\"`\n\n\tSlice        []int `long:\"s\"`\n\tSliceDefault []int `long:\"sd\" default:\"1\" default:\"2\"`\n}\n\nfunc TestDefaults(t *testing.T) {\n\tvar tests = []struct {\n\t\tmsg         string\n\t\targs        []string\n\t\texpected    defaultOptions\n\t\texpectedErr string\n\t}{\n\t\t{\n\t\t\tmsg:  \"no arguments, expecting default values\",\n\t\t\targs: []string{},\n\t\t\texpected: defaultOptions{\n\t\t\t\tInt:           0,\n\t\t\t\tIntDefault:    1,\n\t\t\t\tIntUnderscore: 10,\n\n\t\t\t\tFloat64:           0.0,\n\t\t\t\tFloat64Default:    -3.14,\n\t\t\t\tFloat64Underscore: -33.14,\n\n\t\t\t\tNumericFlag: false,\n\n\t\t\t\tString:        \"\",\n\t\t\t\tStringDefault: \"abc\",\n\n\t\t\t\tTime:        0,\n\t\t\t\tTimeDefault: time.Minute,\n\n\t\t\t\tMap:        map[string]int{},\n\t\t\t\tMapDefault: map[string]int{\"a\": 1},\n\n\t\t\t\tSlice:        []int{},\n\t\t\t\tSliceDefault: []int{1, 2},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsg:  \"non-zero value arguments, expecting overwritten arguments\",\n\t\t\targs: []string{\"--i=3\", \"--id=3\", \"--idu=3_3\", \"--f=-2.71\", \"--fd=2.71\", \"--fdu=2_2.71\", \"-3\", \"--str=def\", \"--strd=def\", \"--t=3ms\", \"--td=3ms\", \"--m=c:3\", \"--md=c:3\", \"--s=3\", \"--sd=3\"},\n\t\t\texpected: defaultOptions{\n\t\t\t\tInt:           3,\n\t\t\t\tIntDefault:    3,\n\t\t\t\tIntUnderscore: 33,\n\n\t\t\t\tFloat64:           -2.71,\n\t\t\t\tFloat64Default:    2.71,\n\t\t\t\tFloat64Underscore: 22.71,\n\n\t\t\t\tNumericFlag: true,\n\n\t\t\t\tString:        \"def\",\n\t\t\t\tStringDefault: \"def\",\n\n\t\t\t\tTime:        3 * time.Millisecond,\n\t\t\t\tTimeDefault: 3 * time.Millisecond,\n\n\t\t\t\tMap:        map[string]int{\"c\": 3},\n\t\t\t\tMapDefault: map[string]int{\"c\": 3},\n\n\t\t\t\tSlice:        []int{3},\n\t\t\t\tSliceDefault: []int{3},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsg:         \"non-zero value arguments, expecting overwritten arguments\",\n\t\t\targs:        []string{\"-3=true\"},\n\t\t\texpectedErr: \"bool flag `\" + makeShortName(\"3\") + \"' cannot have an argument\",\n\t\t},\n\t\t{\n\t\t\tmsg:  \"zero value arguments, expecting overwritten arguments\",\n\t\t\targs: []string{\"--i=0\", \"--id=0\", \"--idu=0\", \"--f=0\", \"--fd=0\", \"--fdu=0\", \"--str\", \"\", \"--strd=\\\"\\\"\", \"--t=0ms\", \"--td=0s\", \"--m=:0\", \"--md=:0\", \"--s=0\", \"--sd=0\"},\n\t\t\texpected: defaultOptions{\n\t\t\t\tInt:           0,\n\t\t\t\tIntDefault:    0,\n\t\t\t\tIntUnderscore: 0,\n\n\t\t\t\tFloat64:           0,\n\t\t\t\tFloat64Default:    0,\n\t\t\t\tFloat64Underscore: 0,\n\n\t\t\t\tString:        \"\",\n\t\t\t\tStringDefault: \"\",\n\n\t\t\t\tTime:        0,\n\t\t\t\tTimeDefault: 0,\n\n\t\t\t\tMap:        map[string]int{\"\": 0},\n\t\t\t\tMapDefault: map[string]int{\"\": 0},\n\n\t\t\t\tSlice:        []int{0},\n\t\t\t\tSliceDefault: []int{0},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar opts defaultOptions\n\n\t\t_, err := ParseArgs(&opts, test.args)\n\t\tif test.expectedErr != \"\" {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"%s:\\nExpected error containing substring %q\", test.msg, test.expectedErr)\n\t\t\t} else if !strings.Contains(err.Error(), test.expectedErr) {\n\t\t\t\tt.Errorf(\"%s:\\nExpected error %q to contain substring %q\", test.msg, err, test.expectedErr)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s:\\nUnexpected error: %v\", test.msg, err)\n\t\t\t}\n\n\t\t\tif opts.Slice == nil {\n\t\t\t\topts.Slice = []int{}\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(opts, test.expected) {\n\t\t\t\tt.Errorf(\"%s:\\nUnexpected options with arguments %+v\\nexpected\\n%+v\\nbut got\\n%+v\\n\", test.msg, test.args, test.expected, opts)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNoDefaultsForBools(t *testing.T) {\n\tvar opts struct {\n\t\tDefaultBool bool `short:\"d\" default:\"true\"`\n\t}\n\n\tif runtime.GOOS == \"windows\" {\n\t\tassertParseFail(t, ErrInvalidTag, \"boolean flag `/d' may not have default values, they always default to `false' and can only be turned on\", &opts)\n\t} else {\n\t\tassertParseFail(t, ErrInvalidTag, \"boolean flag `-d' may not have default values, they always default to `false' and can only be turned on\", &opts)\n\t}\n}\n\nfunc TestUnquoting(t *testing.T) {\n\tvar tests = []struct {\n\t\targ   string\n\t\terr   error\n\t\tvalue string\n\t}{\n\t\t{\n\t\t\targ:   \"\\\"abc\",\n\t\t\terr:   strconv.ErrSyntax,\n\t\t\tvalue: \"\",\n\t\t},\n\t\t{\n\t\t\targ:   \"\\\"\\\"abc\\\"\",\n\t\t\terr:   strconv.ErrSyntax,\n\t\t\tvalue: \"\",\n\t\t},\n\t\t{\n\t\t\targ:   \"\\\"abc\\\"\",\n\t\t\terr:   nil,\n\t\t\tvalue: \"abc\",\n\t\t},\n\t\t{\n\t\t\targ:   \"\\\"\\\\\\\"abc\\\\\\\"\\\"\",\n\t\t\terr:   nil,\n\t\t\tvalue: \"\\\"abc\\\"\",\n\t\t},\n\t\t{\n\t\t\targ:   \"\\\"\\\\\\\"abc\\\"\",\n\t\t\terr:   nil,\n\t\t\tvalue: \"\\\"abc\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar opts defaultOptions\n\n\t\tfor _, delimiter := range []bool{false, true} {\n\t\t\tp := NewParser(&opts, None)\n\n\t\t\tvar err error\n\t\t\tif delimiter {\n\t\t\t\t_, err = p.ParseArgs([]string{\"--str=\" + test.arg, \"--strnot=\" + test.arg})\n\t\t\t} else {\n\t\t\t\t_, err = p.ParseArgs([]string{\"--str\", test.arg, \"--strnot\", test.arg})\n\t\t\t}\n\n\t\t\tif test.err == nil {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"Expected no error but got: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tif test.value != opts.String {\n\t\t\t\t\tt.Fatalf(\"Expected String to be %q but got %q\", test.value, opts.String)\n\t\t\t\t}\n\t\t\t\tif q := strconv.Quote(test.value); q != opts.StringNotUnquoted {\n\t\t\t\t\tt.Fatalf(\"Expected StringDefault to be %q but got %q\", q, opts.StringNotUnquoted)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"Expected error\")\n\t\t\t\t} else if e, ok := err.(*Error); ok {\n\t\t\t\t\tif strings.HasPrefix(e.Message, test.err.Error()) {\n\t\t\t\t\t\tt.Fatalf(\"Expected error message to end with %q but got %v\", test.err.Error(), e.Message)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// EnvRestorer keeps a copy of a set of env variables and can restore the env from them\ntype EnvRestorer struct {\n\tenv map[string]string\n}\n\nfunc (r *EnvRestorer) Restore() {\n\tos.Clearenv()\n\n\tfor k, v := range r.env {\n\t\tos.Setenv(k, v)\n\t}\n}\n\n// EnvSnapshot returns a snapshot of the currently set env variables\nfunc EnvSnapshot() *EnvRestorer {\n\tr := EnvRestorer{make(map[string]string)}\n\n\tfor _, kv := range os.Environ() {\n\t\tparts := strings.SplitN(kv, \"=\", 2)\n\n\t\tif len(parts) != 2 {\n\t\t\tpanic(\"got a weird env variable: \" + kv)\n\t\t}\n\n\t\tr.env[parts[0]] = parts[1]\n\t}\n\n\treturn &r\n}\n\ntype envNestedOptions struct {\n\tFoo string `long:\"foo\" default:\"z\" env:\"FOO\"`\n}\n\ntype envDefaultOptions struct {\n\tInt    int              `long:\"i\" default:\"1\" env:\"TEST_I\"`\n\tTime   time.Duration    `long:\"t\" default:\"1m\" env:\"TEST_T\"`\n\tMap    map[string]int   `long:\"m\" default:\"a:1\" env:\"TEST_M\" env-delim:\";\"`\n\tSlice  []int            `long:\"s\" default:\"1\" default:\"2\" env:\"TEST_S\"  env-delim:\",\"`\n\tNested envNestedOptions `group:\"nested\" namespace:\"nested\" env-namespace:\"NESTED\"`\n}\n\nfunc TestEnvDefaults(t *testing.T) {\n\tvar tests = []struct {\n\t\tmsg         string\n\t\targs        []string\n\t\texpected    envDefaultOptions\n\t\texpectedErr string\n\t\tenv         map[string]string\n\t}{\n\t\t{\n\t\t\tmsg:  \"no arguments, no env, expecting default values\",\n\t\t\targs: []string{},\n\t\t\texpected: envDefaultOptions{\n\t\t\t\tInt:   1,\n\t\t\t\tTime:  time.Minute,\n\t\t\t\tMap:   map[string]int{\"a\": 1},\n\t\t\t\tSlice: []int{1, 2},\n\t\t\t\tNested: envNestedOptions{\n\t\t\t\t\tFoo: \"z\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsg:  \"no arguments, env defaults, expecting env default values\",\n\t\t\targs: []string{},\n\t\t\texpected: envDefaultOptions{\n\t\t\t\tInt:   2,\n\t\t\t\tTime:  2 * time.Minute,\n\t\t\t\tMap:   map[string]int{\"a\": 2, \"b\": 3},\n\t\t\t\tSlice: []int{4, 5, 6},\n\t\t\t\tNested: envNestedOptions{\n\t\t\t\t\tFoo: \"a\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"TEST_I\":     \"2\",\n\t\t\t\t\"TEST_T\":     \"2m\",\n\t\t\t\t\"TEST_M\":     \"a:2;b:3\",\n\t\t\t\t\"TEST_S\":     \"4,5,6\",\n\t\t\t\t\"NESTED_FOO\": \"a\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsg:         \"no arguments, malformed env defaults, expecting parse error\",\n\t\t\targs:        []string{},\n\t\t\texpectedErr: `parsing \"two\": invalid syntax`,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"TEST_I\": \"two\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsg:  \"non-zero value arguments, expecting overwritten arguments\",\n\t\t\targs: []string{\"--i=3\", \"--t=3ms\", \"--m=c:3\", \"--s=3\", \"--nested.foo=\\\"p\\\"\"},\n\t\t\texpected: envDefaultOptions{\n\t\t\t\tInt:   3,\n\t\t\t\tTime:  3 * time.Millisecond,\n\t\t\t\tMap:   map[string]int{\"c\": 3},\n\t\t\t\tSlice: []int{3},\n\t\t\t\tNested: envNestedOptions{\n\t\t\t\t\tFoo: \"p\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"TEST_I\":     \"2\",\n\t\t\t\t\"TEST_T\":     \"2m\",\n\t\t\t\t\"TEST_M\":     \"a:2;b:3\",\n\t\t\t\t\"TEST_S\":     \"4,5,6\",\n\t\t\t\t\"NESTED_FOO\": \"a\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tmsg:  \"zero value arguments, expecting overwritten arguments\",\n\t\t\targs: []string{\"--i=0\", \"--t=0ms\", \"--m=:0\", \"--s=0\", \"--nested.foo=\\\"\\\"\"},\n\t\t\texpected: envDefaultOptions{\n\t\t\t\tInt:   0,\n\t\t\t\tTime:  0,\n\t\t\t\tMap:   map[string]int{\"\": 0},\n\t\t\t\tSlice: []int{0},\n\t\t\t\tNested: envNestedOptions{\n\t\t\t\t\tFoo: \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tenv: map[string]string{\n\t\t\t\t\"TEST_I\":     \"2\",\n\t\t\t\t\"TEST_T\":     \"2m\",\n\t\t\t\t\"TEST_M\":     \"a:2;b:3\",\n\t\t\t\t\"TEST_S\":     \"4,5,6\",\n\t\t\t\t\"NESTED_FOO\": \"a\",\n\t\t\t},\n\t\t},\n\t}\n\n\toldEnv := EnvSnapshot()\n\tdefer oldEnv.Restore()\n\n\tfor _, test := range tests {\n\t\tvar opts envDefaultOptions\n\t\toldEnv.Restore()\n\t\tfor envKey, envValue := range test.env {\n\t\t\tos.Setenv(envKey, envValue)\n\t\t}\n\t\t_, err := NewParser(&opts, None).ParseArgs(test.args)\n\t\tif test.expectedErr != \"\" {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"%s:\\nExpected error containing substring %q\", test.msg, test.expectedErr)\n\t\t\t} else if !strings.Contains(err.Error(), test.expectedErr) {\n\t\t\t\tt.Errorf(\"%s:\\nExpected error %q to contain substring %q\", test.msg, err, test.expectedErr)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s:\\nUnexpected error: %v\", test.msg, err)\n\t\t\t}\n\n\t\t\tif opts.Slice == nil {\n\t\t\t\topts.Slice = []int{}\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(opts, test.expected) {\n\t\t\t\tt.Errorf(\"%s:\\nUnexpected options with arguments %+v\\nexpected\\n%+v\\nbut got\\n%+v\\n\", test.msg, test.args, test.expected, opts)\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype CustomFlag struct {\n\tValue string\n}\n\nfunc (c *CustomFlag) UnmarshalFlag(s string) error {\n\tc.Value = s\n\treturn nil\n}\n\nfunc (c *CustomFlag) IsValidValue(s string) error {\n\tif !(s == \"-1\" || s == \"-foo\") {\n\t\treturn errors.New(\"invalid flag value\")\n\t}\n\treturn nil\n}\n\nfunc TestOptionAsArgument(t *testing.T) {\n\tvar tests = []struct {\n\t\targs        []string\n\t\texpectError bool\n\t\terrType     ErrorType\n\t\terrMsg      string\n\t\trest        []string\n\t}{\n\t\t{\n\t\t\t// short option must not be accepted as argument\n\t\t\targs:        []string{\"--string-slice\", \"foobar\", \"--string-slice\", \"-o\"},\n\t\t\texpectError: true,\n\t\t\terrType:     ErrExpectedArgument,\n\t\t\terrMsg:      \"expected argument for flag `\" + defaultLongOptDelimiter + \"string-slice', but got option `-o'\",\n\t\t},\n\t\t{\n\t\t\t// long option must not be accepted as argument\n\t\t\targs:        []string{\"--string-slice\", \"foobar\", \"--string-slice\", \"--other-option\"},\n\t\t\texpectError: true,\n\t\t\terrType:     ErrExpectedArgument,\n\t\t\terrMsg:      \"expected argument for flag `\" + defaultLongOptDelimiter + \"string-slice', but got option `--other-option'\",\n\t\t},\n\t\t{\n\t\t\t// long option must not be accepted as argument\n\t\t\targs:        []string{\"--string-slice\", \"--\"},\n\t\t\texpectError: true,\n\t\t\terrType:     ErrExpectedArgument,\n\t\t\terrMsg:      \"expected argument for flag `\" + defaultLongOptDelimiter + \"string-slice', but got double dash `--'\",\n\t\t},\n\t\t{\n\t\t\t// quoted and appended option should be accepted as argument (even if it looks like an option)\n\t\t\targs: []string{\"--string-slice\", \"foobar\", \"--string-slice=\\\"--other-option\\\"\"},\n\t\t},\n\t\t{\n\t\t\t// Accept any single character arguments including '-'\n\t\t\targs: []string{\"--string-slice\", \"-\"},\n\t\t},\n\t\t{\n\t\t\t// Do not accept arguments which start with '-' even if the next character is a digit\n\t\t\targs:        []string{\"--string-slice\", \"-3.14\"},\n\t\t\texpectError: true,\n\t\t\terrType:     ErrExpectedArgument,\n\t\t\terrMsg:      \"expected argument for flag `\" + defaultLongOptDelimiter + \"string-slice', but got option `-3.14'\",\n\t\t},\n\t\t{\n\t\t\t// Do not accept arguments which start with '-' if the next character is not a digit\n\t\t\targs:        []string{\"--string-slice\", \"-character\"},\n\t\t\texpectError: true,\n\t\t\terrType:     ErrExpectedArgument,\n\t\t\terrMsg:      \"expected argument for flag `\" + defaultLongOptDelimiter + \"string-slice', but got option `-character'\",\n\t\t},\n\t\t{\n\t\t\targs: []string{\"-o\", \"-\", \"-\"},\n\t\t\trest: []string{\"-\", \"-\"},\n\t\t},\n\t\t{\n\t\t\t// Accept arguments which start with '-' if the next character is a digit\n\t\t\targs: []string{\"--int-slice\", \"-3\"},\n\t\t},\n\t\t{\n\t\t\t// Accept arguments which start with '-' if the next character is a digit\n\t\t\targs: []string{\"--int16\", \"-3\"},\n\t\t},\n\t\t{\n\t\t\t// Accept arguments which start with '-' if the next character is a digit\n\t\t\targs: []string{\"--float32\", \"-3.2\"},\n\t\t},\n\t\t{\n\t\t\t// Accept arguments which start with '-' if the next character is a digit\n\t\t\targs: []string{\"--float32ptr\", \"-3.2\"},\n\t\t},\n\t\t{\n\t\t\t// Accept arguments for values that pass the IsValidValue fuction for value validators\n\t\t\targs: []string{\"--custom-flag\", \"-foo\"},\n\t\t},\n\t\t{\n\t\t\t// Accept arguments for values that pass the IsValidValue fuction for value validators\n\t\t\targs: []string{\"--custom-flag\", \"-1\"},\n\t\t},\n\t\t{\n\t\t\t// Rejects arguments for values that fail the IsValidValue fuction for value validators\n\t\t\targs:        []string{\"--custom-flag\", \"-2\"},\n\t\t\texpectError: true,\n\t\t\terrType:     ErrExpectedArgument,\n\t\t\terrMsg:      \"invalid flag value\",\n\t\t},\n\t}\n\n\tvar opts struct {\n\t\tStringSlice []string   `long:\"string-slice\"`\n\t\tIntSlice    []int      `long:\"int-slice\"`\n\t\tInt16       int16      `long:\"int16\"`\n\t\tFloat32     float32    `long:\"float32\"`\n\t\tFloat32Ptr  *float32   `long:\"float32ptr\"`\n\t\tOtherOption bool       `long:\"other-option\" short:\"o\"`\n\t\tCustom      CustomFlag `long:\"custom-flag\" short:\"c\"`\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectError {\n\t\t\tassertParseFail(t, test.errType, test.errMsg, &opts, test.args...)\n\t\t} else {\n\t\t\targs := assertParseSuccess(t, &opts, test.args...)\n\n\t\t\tassertStringArray(t, args, test.rest)\n\t\t}\n\t}\n}\n\nfunc TestUnknownFlagHandler(t *testing.T) {\n\n\tvar opts struct {\n\t\tFlag1 string `long:\"flag1\"`\n\t\tFlag2 string `long:\"flag2\"`\n\t}\n\n\tp := NewParser(&opts, None)\n\n\tvar unknownFlag1 string\n\tvar unknownFlag2 bool\n\tvar unknownFlag3 string\n\n\t// Set up a callback to intercept unknown options during parsing\n\tp.UnknownOptionHandler = func(option string, arg SplitArgument, args []string) ([]string, error) {\n\t\tif option == \"unknownFlag1\" {\n\t\t\tif argValue, ok := arg.Value(); ok {\n\t\t\t\tunknownFlag1 = argValue\n\t\t\t\treturn args, nil\n\t\t\t}\n\t\t\t// consume a value from remaining args list\n\t\t\tunknownFlag1 = args[0]\n\t\t\treturn args[1:], nil\n\t\t} else if option == \"unknownFlag2\" {\n\t\t\t// treat this one as a bool switch, don't consume any args\n\t\t\tunknownFlag2 = true\n\t\t\treturn args, nil\n\t\t} else if option == \"unknownFlag3\" {\n\t\t\tif argValue, ok := arg.Value(); ok {\n\t\t\t\tunknownFlag3 = argValue\n\t\t\t\treturn args, nil\n\t\t\t}\n\t\t\t// consume a value from remaining args list\n\t\t\tunknownFlag3 = args[0]\n\t\t\treturn args[1:], nil\n\t\t}\n\n\t\treturn args, fmt.Errorf(\"Unknown flag: %v\", option)\n\t}\n\n\t// Parse args containing some unknown flags, verify that\n\t// our callback can handle all of them\n\t_, err := p.ParseArgs([]string{\"--flag1=stuff\", \"--unknownFlag1\", \"blah\", \"--unknownFlag2\", \"--unknownFlag3=baz\", \"--flag2=foo\"})\n\n\tif err != nil {\n\t\tassertErrorf(t, \"Parser returned unexpected error %v\", err)\n\t}\n\n\tassertString(t, opts.Flag1, \"stuff\")\n\tassertString(t, opts.Flag2, \"foo\")\n\tassertString(t, unknownFlag1, \"blah\")\n\tassertString(t, unknownFlag3, \"baz\")\n\n\tif !unknownFlag2 {\n\t\tassertErrorf(t, \"Flag should have been set by unknown handler, but had value: %v\", unknownFlag2)\n\t}\n\n\t// Parse args with unknown flags that callback doesn't handle, verify it returns error\n\t_, err = p.ParseArgs([]string{\"--flag1=stuff\", \"--unknownFlagX\", \"blah\", \"--flag2=foo\"})\n\n\tif err == nil {\n\t\tassertErrorf(t, \"Parser should have returned error, but returned nil\")\n\t}\n}\n\nfunc TestChoices(t *testing.T) {\n\tvar opts struct {\n\t\tChoice string `long:\"choose\" choice:\"v1\" choice:\"v2\"`\n\t}\n\n\tassertParseFail(t, ErrInvalidChoice, \"Invalid value `invalid' for option `\"+defaultLongOptDelimiter+\"choose'. Allowed values are: v1 or v2\", &opts, \"--choose\", \"invalid\")\n\tassertParseSuccess(t, &opts, \"--choose\", \"v2\")\n\tassertString(t, opts.Choice, \"v2\")\n}\n\nfunc TestEmbedded(t *testing.T) {\n\ttype embedded struct {\n\t\tV bool `short:\"v\"`\n\t}\n\tvar opts struct {\n\t\tembedded\n\t}\n\n\tassertParseSuccess(t, &opts, \"-v\")\n\n\tif !opts.V {\n\t\tt.Errorf(\"Expected V to be true\")\n\t}\n}\n\ntype command struct {\n}\n\nfunc (c *command) Execute(args []string) error {\n\treturn nil\n}\n\nfunc TestCommandHandlerNoCommand(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\t}{}\n\n\tparser := NewParser(&opts, Default&^PrintErrors)\n\n\tvar executedCommand Commander\n\tvar executedArgs []string\n\n\texecuted := false\n\n\tparser.CommandHandler = func(command Commander, args []string) error {\n\t\texecuted = true\n\n\t\texecutedCommand = command\n\t\texecutedArgs = args\n\n\t\treturn nil\n\t}\n\n\t_, err := parser.ParseArgs([]string{\"arg1\", \"arg2\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error: %s\", err)\n\t}\n\n\tif !executed {\n\t\tt.Errorf(\"Expected command handler to be executed\")\n\t}\n\n\tif executedCommand != nil {\n\t\tt.Errorf(\"Did not exect an executed command\")\n\t}\n\n\tassertStringArray(t, executedArgs, []string{\"arg1\", \"arg2\"})\n}\n\nfunc TestCommandHandler(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\n\t\tCommand command `command:\"cmd\"`\n\t}{}\n\n\tparser := NewParser(&opts, Default&^PrintErrors)\n\n\tvar executedCommand Commander\n\tvar executedArgs []string\n\n\texecuted := false\n\n\tparser.CommandHandler = func(command Commander, args []string) error {\n\t\texecuted = true\n\n\t\texecutedCommand = command\n\t\texecutedArgs = args\n\n\t\treturn nil\n\t}\n\n\t_, err := parser.ParseArgs([]string{\"cmd\", \"arg1\", \"arg2\"})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected parse error: %s\", err)\n\t}\n\n\tif !executed {\n\t\tt.Errorf(\"Expected command handler to be executed\")\n\t}\n\n\tif executedCommand == nil {\n\t\tt.Errorf(\"Expected command handler to be executed\")\n\t}\n\n\tassertStringArray(t, executedArgs, []string{\"arg1\", \"arg2\"})\n}\n\nfunc TestAllowBoolValues(t *testing.T) {\n\tvar tests = []struct {\n\t\tmsg                string\n\t\targs               []string\n\t\texpectedErr        string\n\t\texpected           bool\n\t\texpectedNonOptArgs []string\n\t}{\n\t\t{\n\t\t\tmsg:      \"no value\",\n\t\t\targs:     []string{\"-v\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tmsg:      \"true value\",\n\t\t\targs:     []string{\"-v=true\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tmsg:      \"false value\",\n\t\t\targs:     []string{\"-v=false\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tmsg:         \"bad value\",\n\t\t\targs:        []string{\"-v=badvalue\"},\n\t\t\texpectedErr: `parsing \"badvalue\": invalid syntax`,\n\t\t},\n\t\t{\n\t\t\t// this test is to ensure flag values can only be specified as --flag=value and not \"--flag value\".\n\t\t\t// if \"--flag value\" was supported it's not clear if value should be a non-optional argument\n\t\t\t// or the value for the flag.\n\t\t\tmsg:                \"validate flags can only be set with a value immediately following an assignment operator (=)\",\n\t\t\targs:               []string{\"-v\", \"false\"},\n\t\t\texpected:           true,\n\t\t\texpectedNonOptArgs: []string{\"false\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar opts = struct {\n\t\t\tValue bool `short:\"v\"`\n\t\t}{}\n\t\tparser := NewParser(&opts, AllowBoolValues)\n\t\tnonOptArgs, err := parser.ParseArgs(test.args)\n\n\t\tif test.expectedErr == \"\" {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%s:\\nUnexpected parse error: %s\", test.msg, err)\n\t\t\t}\n\t\t\tif opts.Value != test.expected {\n\t\t\t\tt.Errorf(\"%s:\\nExpected %v; got %v\", test.msg, test.expected, opts.Value)\n\t\t\t}\n\t\t\tif len(test.expectedNonOptArgs) != len(nonOptArgs) && !reflect.DeepEqual(test.expectedNonOptArgs, nonOptArgs) {\n\t\t\t\tt.Errorf(\"%s:\\nUnexpected non-argument options\\nexpected\\n%+v\\nbut got\\n%+v\\n\", test.msg, test.expectedNonOptArgs, nonOptArgs)\n\t\t\t}\n\t\t} else {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"%s:\\nExpected error containing substring %q\", test.msg, test.expectedErr)\n\t\t\t} else if !strings.Contains(err.Error(), test.expectedErr) {\n\t\t\t\tt.Errorf(\"%s:\\nExpected error %q to contain substring %q\", test.msg, err, test.expectedErr)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "pointer_test.go",
          "type": "blob",
          "size": 3.1171875,
          "content": "package flags\n\nimport (\n\t\"testing\"\n)\n\nfunc TestPointerBool(t *testing.T) {\n\tvar opts = struct {\n\t\tValue *bool `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif !*opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n}\n\nfunc TestPointerString(t *testing.T) {\n\tvar opts = struct {\n\t\tValue *string `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\", \"value\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, *opts.Value, \"value\")\n}\n\nfunc TestPointerSlice(t *testing.T) {\n\tvar opts = struct {\n\t\tValue *[]string `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\", \"value1\", \"-v\", \"value2\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertStringArray(t, *opts.Value, []string{\"value1\", \"value2\"})\n}\n\nfunc TestPointerMap(t *testing.T) {\n\tvar opts = struct {\n\t\tValue *map[string]int `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\", \"k1:2\", \"-v\", \"k2:-5\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif v, ok := (*opts.Value)[\"k1\"]; !ok {\n\t\tt.Errorf(\"Expected key \\\"k1\\\" to exist\")\n\t} else if v != 2 {\n\t\tt.Errorf(\"Expected \\\"k1\\\" to be 2, but got %#v\", v)\n\t}\n\n\tif v, ok := (*opts.Value)[\"k2\"]; !ok {\n\t\tt.Errorf(\"Expected key \\\"k2\\\" to exist\")\n\t} else if v != -5 {\n\t\tt.Errorf(\"Expected \\\"k2\\\" to be -5, but got %#v\", v)\n\t}\n}\n\ntype marshalledString string\n\nfunc (m *marshalledString) UnmarshalFlag(value string) error {\n\t*m = marshalledString(value)\n\treturn nil\n}\n\nfunc (m marshalledString) MarshalFlag() (string, error) {\n\treturn string(m), nil\n}\n\nfunc TestPointerStringMarshalled(t *testing.T) {\n\tvar opts = struct {\n\t\tValue *marshalledString `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\", \"value\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif opts.Value == nil {\n\t\tt.Error(\"Expected value not to be nil\")\n\t\treturn\n\t}\n\n\tassertString(t, string(*opts.Value), \"value\")\n}\n\ntype marshalledStruct struct {\n\tValue string\n}\n\nfunc (m *marshalledStruct) UnmarshalFlag(value string) error {\n\tm.Value = value\n\treturn nil\n}\n\nfunc (m marshalledStruct) MarshalFlag() (string, error) {\n\treturn m.Value, nil\n}\n\nfunc TestPointerStructMarshalled(t *testing.T) {\n\tvar opts = struct {\n\t\tValue *marshalledStruct `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\", \"value\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif opts.Value == nil {\n\t\tt.Error(\"Expected value not to be nil\")\n\t\treturn\n\t}\n\n\tassertString(t, opts.Value.Value, \"value\")\n}\n\ntype PointerGroup struct {\n\tValue bool `short:\"v\"`\n}\n\nfunc TestPointerGroup(t *testing.T) {\n\tvar opts = struct {\n\t\tGroup *PointerGroup `group:\"Group Options\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif !opts.Group.Value {\n\t\tt.Errorf(\"Expected Group.Value to be true\")\n\t}\n}\n\nfunc TestDoNotChangeNonTaggedFields(t *testing.T) {\n\tvar opts struct {\n\t\tA struct {\n\t\t\tPointer *int\n\t\t}\n\t\tB *struct {\n\t\t\tPointer *int\n\t\t}\n\t}\n\n\tret := assertParseSuccess(t, &opts)\n\n\tassertStringArray(t, ret, []string{})\n\n\tif opts.A.Pointer != nil {\n\t\tt.Error(\"Expected A.Pointer to be nil\")\n\t}\n\tif opts.B != nil {\n\t\tt.Error(\"Expected B to be nil\")\n\t}\n\tif opts.B != nil && opts.B.Pointer != nil {\n\t\tt.Error(\"Expected B.Pointer to be nil\")\n\t}\n}\n"
        },
        {
          "name": "short_test.go",
          "type": "blob",
          "size": 4.8310546875,
          "content": "package flags\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestShort(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif !opts.Value {\n\t\tt.Errorf(\"Expected Value to be true\")\n\t}\n}\n\nfunc TestShortTooLong(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"vv\"`\n\t}{}\n\n\tassertParseFail(t, ErrShortNameTooLong, \"short names can only be 1 character long, not `vv'\", &opts)\n}\n\nfunc TestShortRequired(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\" required:\"true\"`\n\t}{}\n\n\tassertParseFail(t, ErrRequired, fmt.Sprintf(\"the required flag `%cv' was not specified\", defaultShortOptDelimiter), &opts)\n}\n\nfunc TestShortRequiredFalsy1(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\" required:\"false\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts)\n}\n\nfunc TestShortRequiredFalsy2(t *testing.T) {\n\tvar opts = struct {\n\t\tValue bool `short:\"v\" required:\"no\"`\n\t}{}\n\n\tassertParseSuccess(t, &opts)\n}\n\nfunc TestShortMultiConcat(t *testing.T) {\n\tvar opts = struct {\n\t\tV bool `short:\"v\"`\n\t\tO bool `short:\"o\"`\n\t\tF bool `short:\"f\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-vo\", \"-f\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif !opts.V {\n\t\tt.Errorf(\"Expected V to be true\")\n\t}\n\n\tif !opts.O {\n\t\tt.Errorf(\"Expected O to be true\")\n\t}\n\n\tif !opts.F {\n\t\tt.Errorf(\"Expected F to be true\")\n\t}\n}\n\nfunc TestShortMultiRequiredConcat(t *testing.T) {\n\tvar opts = struct {\n\t\tV bool `short:\"v\" required:\"true\"`\n\t\tO bool `short:\"o\" required:\"true\"`\n\t\tF bool `short:\"f\" required:\"true\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-vo\", \"-f\")\n\n\tassertStringArray(t, ret, []string{})\n\n\tif !opts.V {\n\t\tt.Errorf(\"Expected V to be true\")\n\t}\n\n\tif !opts.O {\n\t\tt.Errorf(\"Expected O to be true\")\n\t}\n\n\tif !opts.F {\n\t\tt.Errorf(\"Expected F to be true\")\n\t}\n}\n\nfunc TestShortMultiSlice(t *testing.T) {\n\tvar opts = struct {\n\t\tValues []bool `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\", \"-v\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertBoolArray(t, opts.Values, []bool{true, true})\n}\n\nfunc TestShortMultiSliceConcat(t *testing.T) {\n\tvar opts = struct {\n\t\tValues []bool `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-vvv\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertBoolArray(t, opts.Values, []bool{true, true, true})\n}\n\nfunc TestShortWithEqualArg(t *testing.T) {\n\tvar opts = struct {\n\t\tValue string `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v=value\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestShortWithArg(t *testing.T) {\n\tvar opts = struct {\n\t\tValue string `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-vvalue\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestShortArg(t *testing.T) {\n\tvar opts = struct {\n\t\tValue string `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-v\", \"value\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestShortMultiWithEqualArg(t *testing.T) {\n\tvar opts = struct {\n\t\tF     []bool `short:\"f\"`\n\t\tValue string `short:\"v\"`\n\t}{}\n\n\tassertParseFail(t, ErrExpectedArgument, fmt.Sprintf(\"expected argument for flag `%cv'\", defaultShortOptDelimiter), &opts, \"-ffv=value\")\n}\n\nfunc TestShortMultiArg(t *testing.T) {\n\tvar opts = struct {\n\t\tF     []bool `short:\"f\"`\n\t\tValue string `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-ffv\", \"value\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertBoolArray(t, opts.F, []bool{true, true})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestShortMultiArgConcatFail(t *testing.T) {\n\tvar opts = struct {\n\t\tF     []bool `short:\"f\"`\n\t\tValue string `short:\"v\"`\n\t}{}\n\n\tassertParseFail(t, ErrExpectedArgument, fmt.Sprintf(\"expected argument for flag `%cv'\", defaultShortOptDelimiter), &opts, \"-ffvvalue\")\n}\n\nfunc TestShortMultiArgConcat(t *testing.T) {\n\tvar opts = struct {\n\t\tF     []bool `short:\"f\"`\n\t\tValue string `short:\"v\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-vff\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"ff\")\n}\n\nfunc TestShortOptional(t *testing.T) {\n\tvar opts = struct {\n\t\tF     []bool `short:\"f\"`\n\t\tValue string `short:\"v\" optional:\"yes\" optional-value:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-fv\", \"f\")\n\n\tassertStringArray(t, ret, []string{\"f\"})\n\tassertString(t, opts.Value, \"value\")\n}\n\nfunc TestShortOptionalFalsy1(t *testing.T) {\n\tvar opts = struct {\n\t\tF     []bool `short:\"f\"`\n\t\tValue string `short:\"v\" optional:\"false\" optional-value:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-fv\", \"f\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"f\")\n}\n\nfunc TestShortOptionalFalsy2(t *testing.T) {\n\tvar opts = struct {\n\t\tF     []bool `short:\"f\"`\n\t\tValue string `short:\"v\" optional:\"no\" optional-value:\"value\"`\n\t}{}\n\n\tret := assertParseSuccess(t, &opts, \"-fv\", \"f\")\n\n\tassertStringArray(t, ret, []string{})\n\tassertString(t, opts.Value, \"f\")\n}\n"
        },
        {
          "name": "termsize.go",
          "type": "blob",
          "size": 0.3779296875,
          "content": "//go:build !windows && !plan9 && !appengine && !wasm && !aix\n// +build !windows,!plan9,!appengine,!wasm,!aix\n\npackage flags\n\nimport (\n\t\"flag\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc getTerminalColumns() int {\n\tif flag.Lookup(\"test.v\") != nil {\n\t\treturn defaultTermSize\n\t}\n\n\tws, err := unix.IoctlGetWinsize(0, unix.TIOCGWINSZ)\n\tif err != nil {\n\t\treturn defaultTermSize\n\t}\n\treturn int(ws.Col)\n}\n"
        },
        {
          "name": "termsize_defaults.go",
          "type": "blob",
          "size": 0.041015625,
          "content": "package flags\n\nconst defaultTermSize = 80\n"
        },
        {
          "name": "termsize_nosysioctl.go",
          "type": "blob",
          "size": 0.150390625,
          "content": "//go:build plan9 || appengine || wasm || aix\n// +build plan9 appengine wasm aix\n\npackage flags\n\nfunc getTerminalColumns() int {\n\treturn defaultTermSize\n}\n"
        },
        {
          "name": "termsize_windows.go",
          "type": "blob",
          "size": 1.7705078125,
          "content": "//go:build windows\n// +build windows\n\npackage flags\n\nimport (\n\t\"flag\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\ntype (\n\tSHORT int16\n\tWORD  uint16\n\n\tSMALL_RECT struct {\n\t\tLeft   SHORT\n\t\tTop    SHORT\n\t\tRight  SHORT\n\t\tBottom SHORT\n\t}\n\n\tCOORD struct {\n\t\tX SHORT\n\t\tY SHORT\n\t}\n\n\tCONSOLE_SCREEN_BUFFER_INFO struct {\n\t\tSize              COORD\n\t\tCursorPosition    COORD\n\t\tAttributes        WORD\n\t\tWindow            SMALL_RECT\n\t\tMaximumWindowSize COORD\n\t}\n)\n\nvar kernel32DLL = syscall.NewLazyDLL(\"kernel32.dll\")\nvar getConsoleScreenBufferInfoProc = kernel32DLL.NewProc(\"GetConsoleScreenBufferInfo\")\n\nfunc getError(r1, r2 uintptr, lastErr error) error {\n\t// If the function fails, the return value is zero.\n\tif r1 == 0 {\n\t\tif lastErr != nil {\n\t\t\treturn lastErr\n\t\t}\n\t\treturn syscall.EINVAL\n\t}\n\treturn nil\n}\n\nfunc getStdHandle(stdhandle int) (uintptr, error) {\n\thandle, err := syscall.GetStdHandle(stdhandle)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn uintptr(handle), nil\n}\n\n// GetConsoleScreenBufferInfo retrieves information about the specified console screen buffer.\n// http://msdn.microsoft.com/en-us/library/windows/desktop/ms683171(v=vs.85).aspx\nfunc GetConsoleScreenBufferInfo(handle uintptr) (*CONSOLE_SCREEN_BUFFER_INFO, error) {\n\tvar info CONSOLE_SCREEN_BUFFER_INFO\n\tif err := getError(getConsoleScreenBufferInfoProc.Call(handle, uintptr(unsafe.Pointer(&info)), 0)); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &info, nil\n}\n\nfunc getTerminalColumns() int {\n\tif flag.Lookup(\"test.v\") != nil {\n\t\treturn defaultTermSize\n\t}\n\n\tstdoutHandle, err := getStdHandle(syscall.STD_OUTPUT_HANDLE)\n\tif err != nil {\n\t\treturn defaultTermSize\n\t}\n\n\tinfo, err := GetConsoleScreenBufferInfo(stdoutHandle)\n\tif err != nil {\n\t\treturn defaultTermSize\n\t}\n\n\tif info.MaximumWindowSize.X > 0 {\n\t\treturn int(info.MaximumWindowSize.X)\n\t}\n\n\treturn defaultTermSize\n}\n"
        },
        {
          "name": "unknown_test.go",
          "type": "blob",
          "size": 0.955078125,
          "content": "package flags\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnknownFlags(t *testing.T) {\n\tvar opts = struct {\n\t\tVerbose []bool `short:\"v\" long:\"verbose\" description:\"Verbose output\"`\n\t}{}\n\n\targs := []string{\n\t\t\"-f\",\n\t}\n\n\tp := NewParser(&opts, 0)\n\targs, err := p.ParseArgs(args)\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error for unknown argument\")\n\t}\n}\n\nfunc TestIgnoreUnknownFlags(t *testing.T) {\n\tvar opts = struct {\n\t\tVerbose []bool `short:\"v\" long:\"verbose\" description:\"Verbose output\"`\n\t}{}\n\n\targs := []string{\n\t\t\"hello\",\n\t\t\"world\",\n\t\t\"-v\",\n\t\t\"--foo=bar\",\n\t\t\"--verbose\",\n\t\t\"-f\",\n\t}\n\n\tp := NewParser(&opts, IgnoreUnknown)\n\targs, err := p.ParseArgs(args)\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texargs := []string{\n\t\t\"hello\",\n\t\t\"world\",\n\t\t\"--foo=bar\",\n\t\t\"-f\",\n\t}\n\n\tissame := (len(args) == len(exargs))\n\n\tif issame {\n\t\tfor i := 0; i < len(args); i++ {\n\t\t\tif args[i] != exargs[i] {\n\t\t\t\tissame = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !issame {\n\t\tt.Fatalf(\"Expected %v but got %v\", exargs, args)\n\t}\n}\n"
        }
      ]
    }
  ]
}