{
  "metadata": {
    "timestamp": 1736566675127,
    "page": 229,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "golang/lint",
      "stars": 3977,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.224609375,
          "content": "sudo: false\nlanguage: go\ngo:\n  - 1.10.x\n  - 1.11.x\n  - master\n\ngo_import_path: golang.org/x/lint\n\ninstall:\n  - go get -t -v ./...\n\nscript:\n  - go test -v -race ./...\n\nmatrix:\n  allow_failures:\n    - go: master\n  fast_finish: true\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.40234375,
          "content": "# Contributing to Golint\n\n## Before filing an issue:\n\n### Are you having trouble building golint?\n\nCheck you have the latest version of its dependencies. Run\n```\ngo get -u golang.org/x/lint/golint\n```\nIf you still have problems, consider searching for existing issues before filing a new issue.\n\n## Before sending a pull request:\n\nHave you understood the purpose of golint? Make sure to carefully read `README`.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4443359375,
          "content": "Copyright (c) 2013 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.7216796875,
          "content": "**NOTE:** Golint is [deprecated and frozen](https://github.com/golang/go/issues/38968).\nThere's no drop-in replacement for it, but tools such as [Staticcheck](https://staticcheck.io/)\nand `go vet` should be used instead.\n\nGolint is a linter for Go source code.\n\n[![Go Reference](https://pkg.go.dev/badge/golang.org/x/lint.svg)](https://pkg.go.dev/golang.org/x/lint)\n[![Build Status](https://travis-ci.org/golang/lint.svg?branch=master)](https://travis-ci.org/golang/lint)\n\n## Installation\n\nGolint requires a\n[supported release of Go](https://golang.org/doc/devel/release.html#policy).\n\n    go get -u golang.org/x/lint/golint\n\nTo find out where `golint` was installed you can run `go list -f {{.Target}} golang.org/x/lint/golint`. For `golint` to be used globally add that directory to the `$PATH` environment setting.\n\n## Usage\n\nInvoke `golint` with one or more filenames, directories, or packages named\nby its import path. Golint uses the same\n[import path syntax](https://golang.org/cmd/go/#hdr-Import_path_syntax) as\nthe `go` command and therefore\nalso supports relative import paths like `./...`. Additionally the `...`\nwildcard can be used as suffix on relative and absolute file paths to recurse\ninto them.\n\nThe output of this tool is a list of suggestions in Vim quickfix format,\nwhich is accepted by lots of different editors.\n\n## Purpose\n\nGolint differs from gofmt. Gofmt reformats Go source code, whereas\ngolint prints out style mistakes.\n\nGolint differs from govet. Govet is concerned with correctness, whereas\ngolint is concerned with coding style. Golint is in use at Google, and it\nseeks to match the accepted style of the open source Go project.\n\nThe suggestions made by golint are exactly that: suggestions.\nGolint is not perfect, and has both false positives and false negatives.\nDo not treat its output as a gold standard. We will not be adding pragmas\nor other knobs to suppress specific warnings, so do not expect or require\ncode to be completely \"lint-free\".\nIn short, this tool is not, and will never be, trustworthy enough for its\nsuggestions to be enforced automatically, for example as part of a build process.\nGolint makes suggestions for many of the mechanically checkable items listed in\n[Effective Go](https://golang.org/doc/effective_go.html) and the\n[CodeReviewComments wiki page](https://golang.org/wiki/CodeReviewComments).\n\n## Scope\n\nGolint is meant to carry out the stylistic conventions put forth in\n[Effective Go](https://golang.org/doc/effective_go.html) and\n[CodeReviewComments](https://golang.org/wiki/CodeReviewComments).\nChanges that are not aligned with those documents will not be considered.\n\n## Contributions\n\nContributions to this project are welcome provided they are [in scope](#scope),\nthough please send mail before starting work on anything major.\nContributors retain their copyright, so we need you to fill out\n[a short form](https://developers.google.com/open-source/cla/individual)\nbefore we can accept your contribution.\n\n## Vim\n\nAdd this to your ~/.vimrc:\n\n    set rtp+=$GOPATH/src/golang.org/x/lint/misc/vim\n\nIf you have multiple entries in your GOPATH, replace `$GOPATH` with the right value.\n\nRunning `:Lint` will run golint on the current file and populate the quickfix list.\n\nOptionally, add this to your `~/.vimrc` to automatically run `golint` on `:w`\n\n    autocmd BufWritePost,FileWritePost *.go execute 'Lint' | cwindow\n\n\n## Emacs\n\nAdd this to your `.emacs` file:\n\n    (add-to-list 'load-path (concat (getenv \"GOPATH\")  \"/src/golang.org/x/lint/misc/emacs/\"))\n    (require 'golint)\n\nIf you have multiple entries in your GOPATH, replace `$GOPATH` with the right value.\n\nRunning M-x golint will run golint on the current file.\n\nFor more usage, see [Compilation-Mode](http://www.gnu.org/software/emacs/manual/html_node/emacs/Compilation-Mode.html).\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0947265625,
          "content": "module golang.org/x/lint\n\ngo 1.11\n\nrequire golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.2373046875,
          "content": "golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7 h1:EBZoQjiKKPaLbPrbpssUfuHtwM6KV/vb4U85g/cigFY=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "golint",
          "type": "tree",
          "content": null
        },
        {
          "name": "lint.go",
          "type": "blob",
          "size": 43.439453125,
          "content": "// Copyright (c) 2013 The Go Authors. All rights reserved.\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd.\n\n// Package lint contains a linter for Go source code.\npackage lint // import \"golang.org/x/lint\"\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/printer\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"golang.org/x/tools/go/ast/astutil\"\n\t\"golang.org/x/tools/go/gcexportdata\"\n)\n\nconst styleGuideBase = \"https://golang.org/wiki/CodeReviewComments\"\n\n// A Linter lints Go source code.\ntype Linter struct {\n}\n\n// Problem represents a problem in some source code.\ntype Problem struct {\n\tPosition   token.Position // position in source file\n\tText       string         // the prose that describes the problem\n\tLink       string         // (optional) the link to the style guide for the problem\n\tConfidence float64        // a value in (0,1] estimating the confidence in this problem's correctness\n\tLineText   string         // the source line\n\tCategory   string         // a short name for the general category of the problem\n\n\t// If the problem has a suggested fix (the minority case),\n\t// ReplacementLine is a full replacement for the relevant line of the source file.\n\tReplacementLine string\n}\n\nfunc (p *Problem) String() string {\n\tif p.Link != \"\" {\n\t\treturn p.Text + \"\\n\\n\" + p.Link\n\t}\n\treturn p.Text\n}\n\ntype byPosition []Problem\n\nfunc (p byPosition) Len() int      { return len(p) }\nfunc (p byPosition) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\n\nfunc (p byPosition) Less(i, j int) bool {\n\tpi, pj := p[i].Position, p[j].Position\n\n\tif pi.Filename != pj.Filename {\n\t\treturn pi.Filename < pj.Filename\n\t}\n\tif pi.Line != pj.Line {\n\t\treturn pi.Line < pj.Line\n\t}\n\tif pi.Column != pj.Column {\n\t\treturn pi.Column < pj.Column\n\t}\n\n\treturn p[i].Text < p[j].Text\n}\n\n// Lint lints src.\nfunc (l *Linter) Lint(filename string, src []byte) ([]Problem, error) {\n\treturn l.LintFiles(map[string][]byte{filename: src})\n}\n\n// LintFiles lints a set of files of a single package.\n// The argument is a map of filename to source.\nfunc (l *Linter) LintFiles(files map[string][]byte) ([]Problem, error) {\n\tpkg := &pkg{\n\t\tfset:  token.NewFileSet(),\n\t\tfiles: make(map[string]*file),\n\t}\n\tvar pkgName string\n\tfor filename, src := range files {\n\t\tif isGenerated(src) {\n\t\t\tcontinue // See issue #239\n\t\t}\n\t\tf, err := parser.ParseFile(pkg.fset, filename, src, parser.ParseComments)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif pkgName == \"\" {\n\t\t\tpkgName = f.Name.Name\n\t\t} else if f.Name.Name != pkgName {\n\t\t\treturn nil, fmt.Errorf(\"%s is in package %s, not %s\", filename, f.Name.Name, pkgName)\n\t\t}\n\t\tpkg.files[filename] = &file{\n\t\t\tpkg:      pkg,\n\t\t\tf:        f,\n\t\t\tfset:     pkg.fset,\n\t\t\tsrc:      src,\n\t\t\tfilename: filename,\n\t\t}\n\t}\n\tif len(pkg.files) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn pkg.lint(), nil\n}\n\nvar (\n\tgenHdr = []byte(\"// Code generated \")\n\tgenFtr = []byte(\" DO NOT EDIT.\")\n)\n\n// isGenerated reports whether the source file is generated code\n// according the rules from https://golang.org/s/generatedcode.\nfunc isGenerated(src []byte) bool {\n\tsc := bufio.NewScanner(bytes.NewReader(src))\n\tfor sc.Scan() {\n\t\tb := sc.Bytes()\n\t\tif bytes.HasPrefix(b, genHdr) && bytes.HasSuffix(b, genFtr) && len(b) >= len(genHdr)+len(genFtr) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// pkg represents a package being linted.\ntype pkg struct {\n\tfset  *token.FileSet\n\tfiles map[string]*file\n\n\ttypesPkg  *types.Package\n\ttypesInfo *types.Info\n\n\t// sortable is the set of types in the package that implement sort.Interface.\n\tsortable map[string]bool\n\t// main is whether this is a \"main\" package.\n\tmain bool\n\n\tproblems []Problem\n}\n\nfunc (p *pkg) lint() []Problem {\n\tif err := p.typeCheck(); err != nil {\n\t\t/* TODO(dsymonds): Consider reporting these errors when golint operates on entire packages.\n\t\tif e, ok := err.(types.Error); ok {\n\t\t\tpos := p.fset.Position(e.Pos)\n\t\t\tconf := 1.0\n\t\t\tif strings.Contains(e.Msg, \"can't find import: \") {\n\t\t\t\t// Golint is probably being run in a context that doesn't support\n\t\t\t\t// typechecking (e.g. package files aren't found), so don't warn about it.\n\t\t\t\tconf = 0\n\t\t\t}\n\t\t\tif conf > 0 {\n\t\t\t\tp.errorfAt(pos, conf, category(\"typechecking\"), e.Msg)\n\t\t\t}\n\n\t\t\t// TODO(dsymonds): Abort if !e.Soft?\n\t\t}\n\t\t*/\n\t}\n\n\tp.scanSortable()\n\tp.main = p.isMain()\n\n\tfor _, f := range p.files {\n\t\tf.lint()\n\t}\n\n\tsort.Sort(byPosition(p.problems))\n\n\treturn p.problems\n}\n\n// file represents a file being linted.\ntype file struct {\n\tpkg      *pkg\n\tf        *ast.File\n\tfset     *token.FileSet\n\tsrc      []byte\n\tfilename string\n}\n\nfunc (f *file) isTest() bool { return strings.HasSuffix(f.filename, \"_test.go\") }\n\nfunc (f *file) lint() {\n\tf.lintPackageComment()\n\tf.lintImports()\n\tf.lintBlankImports()\n\tf.lintExported()\n\tf.lintNames()\n\tf.lintElses()\n\tf.lintRanges()\n\tf.lintErrorf()\n\tf.lintErrors()\n\tf.lintErrorStrings()\n\tf.lintReceiverNames()\n\tf.lintIncDec()\n\tf.lintErrorReturn()\n\tf.lintUnexportedReturn()\n\tf.lintTimeNames()\n\tf.lintContextKeyTypes()\n\tf.lintContextArgs()\n}\n\ntype link string\ntype category string\n\n// The variadic arguments may start with link and category types,\n// and must end with a format string and any arguments.\n// It returns the new Problem.\nfunc (f *file) errorf(n ast.Node, confidence float64, args ...interface{}) *Problem {\n\tpos := f.fset.Position(n.Pos())\n\tif pos.Filename == \"\" {\n\t\tpos.Filename = f.filename\n\t}\n\treturn f.pkg.errorfAt(pos, confidence, args...)\n}\n\nfunc (p *pkg) errorfAt(pos token.Position, confidence float64, args ...interface{}) *Problem {\n\tproblem := Problem{\n\t\tPosition:   pos,\n\t\tConfidence: confidence,\n\t}\n\tif pos.Filename != \"\" {\n\t\t// The file might not exist in our mapping if a //line directive was encountered.\n\t\tif f, ok := p.files[pos.Filename]; ok {\n\t\t\tproblem.LineText = srcLine(f.src, pos)\n\t\t}\n\t}\n\nargLoop:\n\tfor len(args) > 1 { // always leave at least the format string in args\n\t\tswitch v := args[0].(type) {\n\t\tcase link:\n\t\t\tproblem.Link = string(v)\n\t\tcase category:\n\t\t\tproblem.Category = string(v)\n\t\tdefault:\n\t\t\tbreak argLoop\n\t\t}\n\t\targs = args[1:]\n\t}\n\n\tproblem.Text = fmt.Sprintf(args[0].(string), args[1:]...)\n\n\tp.problems = append(p.problems, problem)\n\treturn &p.problems[len(p.problems)-1]\n}\n\nvar newImporter = func(fset *token.FileSet) types.ImporterFrom {\n\treturn gcexportdata.NewImporter(fset, make(map[string]*types.Package))\n}\n\nfunc (p *pkg) typeCheck() error {\n\tconfig := &types.Config{\n\t\t// By setting a no-op error reporter, the type checker does as much work as possible.\n\t\tError:    func(error) {},\n\t\tImporter: newImporter(p.fset),\n\t}\n\tinfo := &types.Info{\n\t\tTypes:  make(map[ast.Expr]types.TypeAndValue),\n\t\tDefs:   make(map[*ast.Ident]types.Object),\n\t\tUses:   make(map[*ast.Ident]types.Object),\n\t\tScopes: make(map[ast.Node]*types.Scope),\n\t}\n\tvar anyFile *file\n\tvar astFiles []*ast.File\n\tfor _, f := range p.files {\n\t\tanyFile = f\n\t\tastFiles = append(astFiles, f.f)\n\t}\n\tpkg, err := config.Check(anyFile.f.Name.Name, p.fset, astFiles, info)\n\t// Remember the typechecking info, even if config.Check failed,\n\t// since we will get partial information.\n\tp.typesPkg = pkg\n\tp.typesInfo = info\n\treturn err\n}\n\nfunc (p *pkg) typeOf(expr ast.Expr) types.Type {\n\tif p.typesInfo == nil {\n\t\treturn nil\n\t}\n\treturn p.typesInfo.TypeOf(expr)\n}\n\nfunc (p *pkg) isNamedType(typ types.Type, importPath, name string) bool {\n\tn, ok := typ.(*types.Named)\n\tif !ok {\n\t\treturn false\n\t}\n\ttn := n.Obj()\n\treturn tn != nil && tn.Pkg() != nil && tn.Pkg().Path() == importPath && tn.Name() == name\n}\n\n// scopeOf returns the tightest scope encompassing id.\nfunc (p *pkg) scopeOf(id *ast.Ident) *types.Scope {\n\tvar scope *types.Scope\n\tif obj := p.typesInfo.ObjectOf(id); obj != nil {\n\t\tscope = obj.Parent()\n\t}\n\tif scope == p.typesPkg.Scope() {\n\t\t// We were given a top-level identifier.\n\t\t// Use the file-level scope instead of the package-level scope.\n\t\tpos := id.Pos()\n\t\tfor _, f := range p.files {\n\t\t\tif f.f.Pos() <= pos && pos < f.f.End() {\n\t\t\t\tscope = p.typesInfo.Scopes[f.f]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn scope\n}\n\nfunc (p *pkg) scanSortable() {\n\tp.sortable = make(map[string]bool)\n\n\t// bitfield for which methods exist on each type.\n\tconst (\n\t\tLen = 1 << iota\n\t\tLess\n\t\tSwap\n\t)\n\tnmap := map[string]int{\"Len\": Len, \"Less\": Less, \"Swap\": Swap}\n\thas := make(map[string]int)\n\tfor _, f := range p.files {\n\t\tf.walk(func(n ast.Node) bool {\n\t\t\tfn, ok := n.(*ast.FuncDecl)\n\t\t\tif !ok || fn.Recv == nil || len(fn.Recv.List) == 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// TODO(dsymonds): We could check the signature to be more precise.\n\t\t\trecv := receiverType(fn)\n\t\t\tif i, ok := nmap[fn.Name.Name]; ok {\n\t\t\t\thas[recv] |= i\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t}\n\tfor typ, ms := range has {\n\t\tif ms == Len|Less|Swap {\n\t\t\tp.sortable[typ] = true\n\t\t}\n\t}\n}\n\nfunc (p *pkg) isMain() bool {\n\tfor _, f := range p.files {\n\t\tif f.isMain() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (f *file) isMain() bool {\n\tif f.f.Name.Name == \"main\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// lintPackageComment checks package comments. It complains if\n// there is no package comment, or if it is not of the right form.\n// This has a notable false positive in that a package comment\n// could rightfully appear in a different file of the same package,\n// but that's not easy to fix since this linter is file-oriented.\nfunc (f *file) lintPackageComment() {\n\tif f.isTest() {\n\t\treturn\n\t}\n\n\tconst ref = styleGuideBase + \"#package-comments\"\n\tprefix := \"Package \" + f.f.Name.Name + \" \"\n\n\t// Look for a detached package comment.\n\t// First, scan for the last comment that occurs before the \"package\" keyword.\n\tvar lastCG *ast.CommentGroup\n\tfor _, cg := range f.f.Comments {\n\t\tif cg.Pos() > f.f.Package {\n\t\t\t// Gone past \"package\" keyword.\n\t\t\tbreak\n\t\t}\n\t\tlastCG = cg\n\t}\n\tif lastCG != nil && strings.HasPrefix(lastCG.Text(), prefix) {\n\t\tendPos := f.fset.Position(lastCG.End())\n\t\tpkgPos := f.fset.Position(f.f.Package)\n\t\tif endPos.Line+1 < pkgPos.Line {\n\t\t\t// There isn't a great place to anchor this error;\n\t\t\t// the start of the blank lines between the doc and the package statement\n\t\t\t// is at least pointing at the location of the problem.\n\t\t\tpos := token.Position{\n\t\t\t\tFilename: endPos.Filename,\n\t\t\t\t// Offset not set; it is non-trivial, and doesn't appear to be needed.\n\t\t\t\tLine:   endPos.Line + 1,\n\t\t\t\tColumn: 1,\n\t\t\t}\n\t\t\tf.pkg.errorfAt(pos, 0.9, link(ref), category(\"comments\"), \"package comment is detached; there should be no blank lines between it and the package statement\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tif f.f.Doc == nil {\n\t\tf.errorf(f.f, 0.2, link(ref), category(\"comments\"), \"should have a package comment, unless it's in another file for this package\")\n\t\treturn\n\t}\n\ts := f.f.Doc.Text()\n\tif ts := strings.TrimLeft(s, \" \\t\"); ts != s {\n\t\tf.errorf(f.f.Doc, 1, link(ref), category(\"comments\"), \"package comment should not have leading space\")\n\t\ts = ts\n\t}\n\t// Only non-main packages need to keep to this form.\n\tif !f.pkg.main && !strings.HasPrefix(s, prefix) {\n\t\tf.errorf(f.f.Doc, 1, link(ref), category(\"comments\"), `package comment should be of the form \"%s...\"`, prefix)\n\t}\n}\n\n// lintBlankImports complains if a non-main package has blank imports that are\n// not documented.\nfunc (f *file) lintBlankImports() {\n\t// In package main and in tests, we don't complain about blank imports.\n\tif f.pkg.main || f.isTest() {\n\t\treturn\n\t}\n\n\t// The first element of each contiguous group of blank imports should have\n\t// an explanatory comment of some kind.\n\tfor i, imp := range f.f.Imports {\n\t\tpos := f.fset.Position(imp.Pos())\n\n\t\tif !isBlank(imp.Name) {\n\t\t\tcontinue // Ignore non-blank imports.\n\t\t}\n\t\tif i > 0 {\n\t\t\tprev := f.f.Imports[i-1]\n\t\t\tprevPos := f.fset.Position(prev.Pos())\n\t\t\tif isBlank(prev.Name) && prevPos.Line+1 == pos.Line {\n\t\t\t\tcontinue // A subsequent blank in a group.\n\t\t\t}\n\t\t}\n\n\t\t// This is the first blank import of a group.\n\t\tif imp.Doc == nil && imp.Comment == nil {\n\t\t\tref := \"\"\n\t\t\tf.errorf(imp, 1, link(ref), category(\"imports\"), \"a blank import should be only in a main or test package, or have a comment justifying it\")\n\t\t}\n\t}\n}\n\n// lintImports examines import blocks.\nfunc (f *file) lintImports() {\n\tfor i, is := range f.f.Imports {\n\t\t_ = i\n\t\tif is.Name != nil && is.Name.Name == \".\" && !f.isTest() {\n\t\t\tf.errorf(is, 1, link(styleGuideBase+\"#import-dot\"), category(\"imports\"), \"should not use dot imports\")\n\t\t}\n\n\t}\n}\n\nconst docCommentsLink = styleGuideBase + \"#doc-comments\"\n\n// lintExported examines the exported names.\n// It complains if any required doc comments are missing,\n// or if they are not of the right form. The exact rules are in\n// lintFuncDoc, lintTypeDoc and lintValueSpecDoc; this function\n// also tracks the GenDecl structure being traversed to permit\n// doc comments for constants to be on top of the const block.\n// It also complains if the names stutter when combined with\n// the package name.\nfunc (f *file) lintExported() {\n\tif f.isTest() {\n\t\treturn\n\t}\n\n\tvar lastGen *ast.GenDecl // last GenDecl entered.\n\n\t// Set of GenDecls that have already had missing comments flagged.\n\tgenDeclMissingComments := make(map[*ast.GenDecl]bool)\n\n\tf.walk(func(node ast.Node) bool {\n\t\tswitch v := node.(type) {\n\t\tcase *ast.GenDecl:\n\t\t\tif v.Tok == token.IMPORT {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// token.CONST, token.TYPE or token.VAR\n\t\t\tlastGen = v\n\t\t\treturn true\n\t\tcase *ast.FuncDecl:\n\t\t\tf.lintFuncDoc(v)\n\t\t\tif v.Recv == nil {\n\t\t\t\t// Only check for stutter on functions, not methods.\n\t\t\t\t// Method names are not used package-qualified.\n\t\t\t\tf.checkStutter(v.Name, \"func\")\n\t\t\t}\n\t\t\t// Don't proceed inside funcs.\n\t\t\treturn false\n\t\tcase *ast.TypeSpec:\n\t\t\t// inside a GenDecl, which usually has the doc\n\t\t\tdoc := v.Doc\n\t\t\tif doc == nil {\n\t\t\t\tdoc = lastGen.Doc\n\t\t\t}\n\t\t\tf.lintTypeDoc(v, doc)\n\t\t\tf.checkStutter(v.Name, \"type\")\n\t\t\t// Don't proceed inside types.\n\t\t\treturn false\n\t\tcase *ast.ValueSpec:\n\t\t\tf.lintValueSpecDoc(v, lastGen, genDeclMissingComments)\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t})\n}\n\nvar (\n\tallCapsRE = regexp.MustCompile(`^[A-Z0-9_]+$`)\n\tanyCapsRE = regexp.MustCompile(`[A-Z]`)\n)\n\n// knownNameExceptions is a set of names that are known to be exempt from naming checks.\n// This is usually because they are constrained by having to match names in the\n// standard library.\nvar knownNameExceptions = map[string]bool{\n\t\"LastInsertId\": true, // must match database/sql\n\t\"kWh\":          true,\n}\n\nfunc isInTopLevel(f *ast.File, ident *ast.Ident) bool {\n\tpath, _ := astutil.PathEnclosingInterval(f, ident.Pos(), ident.End())\n\tfor _, f := range path {\n\t\tswitch f.(type) {\n\t\tcase *ast.File, *ast.GenDecl, *ast.ValueSpec, *ast.Ident:\n\t\t\tcontinue\n\t\t}\n\t\treturn false\n\t}\n\treturn true\n}\n\n// lintNames examines all names in the file.\n// It complains if any use underscores or incorrect known initialisms.\nfunc (f *file) lintNames() {\n\t// Package names need slightly different handling than other names.\n\tif strings.Contains(f.f.Name.Name, \"_\") && !strings.HasSuffix(f.f.Name.Name, \"_test\") {\n\t\tf.errorf(f.f, 1, link(\"http://golang.org/doc/effective_go.html#package-names\"), category(\"naming\"), \"don't use an underscore in package name\")\n\t}\n\tif anyCapsRE.MatchString(f.f.Name.Name) {\n\t\tf.errorf(f.f, 1, link(\"http://golang.org/doc/effective_go.html#package-names\"), category(\"mixed-caps\"), \"don't use MixedCaps in package name; %s should be %s\", f.f.Name.Name, strings.ToLower(f.f.Name.Name))\n\t}\n\n\tcheck := func(id *ast.Ident, thing string) {\n\t\tif id.Name == \"_\" {\n\t\t\treturn\n\t\t}\n\t\tif knownNameExceptions[id.Name] {\n\t\t\treturn\n\t\t}\n\n\t\t// Handle two common styles from other languages that don't belong in Go.\n\t\tif len(id.Name) >= 5 && allCapsRE.MatchString(id.Name) && strings.Contains(id.Name, \"_\") {\n\t\t\tcapCount := 0\n\t\t\tfor _, c := range id.Name {\n\t\t\t\tif 'A' <= c && c <= 'Z' {\n\t\t\t\t\tcapCount++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif capCount >= 2 {\n\t\t\t\tf.errorf(id, 0.8, link(styleGuideBase+\"#mixed-caps\"), category(\"naming\"), \"don't use ALL_CAPS in Go names; use CamelCase\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif thing == \"const\" || (thing == \"var\" && isInTopLevel(f.f, id)) {\n\t\t\tif len(id.Name) > 2 && id.Name[0] == 'k' && id.Name[1] >= 'A' && id.Name[1] <= 'Z' {\n\t\t\t\tshould := string(id.Name[1]+'a'-'A') + id.Name[2:]\n\t\t\t\tf.errorf(id, 0.8, link(styleGuideBase+\"#mixed-caps\"), category(\"naming\"), \"don't use leading k in Go names; %s %s should be %s\", thing, id.Name, should)\n\t\t\t}\n\t\t}\n\n\t\tshould := lintName(id.Name)\n\t\tif id.Name == should {\n\t\t\treturn\n\t\t}\n\n\t\tif len(id.Name) > 2 && strings.Contains(id.Name[1:], \"_\") {\n\t\t\tf.errorf(id, 0.9, link(\"http://golang.org/doc/effective_go.html#mixed-caps\"), category(\"naming\"), \"don't use underscores in Go names; %s %s should be %s\", thing, id.Name, should)\n\t\t\treturn\n\t\t}\n\t\tf.errorf(id, 0.8, link(styleGuideBase+\"#initialisms\"), category(\"naming\"), \"%s %s should be %s\", thing, id.Name, should)\n\t}\n\tcheckList := func(fl *ast.FieldList, thing string) {\n\t\tif fl == nil {\n\t\t\treturn\n\t\t}\n\t\tfor _, f := range fl.List {\n\t\t\tfor _, id := range f.Names {\n\t\t\t\tcheck(id, thing)\n\t\t\t}\n\t\t}\n\t}\n\tf.walk(func(node ast.Node) bool {\n\t\tswitch v := node.(type) {\n\t\tcase *ast.AssignStmt:\n\t\t\tif v.Tok == token.ASSIGN {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tfor _, exp := range v.Lhs {\n\t\t\t\tif id, ok := exp.(*ast.Ident); ok {\n\t\t\t\t\tcheck(id, \"var\")\n\t\t\t\t}\n\t\t\t}\n\t\tcase *ast.FuncDecl:\n\t\t\tif f.isTest() && (strings.HasPrefix(v.Name.Name, \"Example\") || strings.HasPrefix(v.Name.Name, \"Test\") || strings.HasPrefix(v.Name.Name, \"Benchmark\")) {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tthing := \"func\"\n\t\t\tif v.Recv != nil {\n\t\t\t\tthing = \"method\"\n\t\t\t}\n\n\t\t\t// Exclude naming warnings for functions that are exported to C but\n\t\t\t// not exported in the Go API.\n\t\t\t// See https://github.com/golang/lint/issues/144.\n\t\t\tif ast.IsExported(v.Name.Name) || !isCgoExported(v) {\n\t\t\t\tcheck(v.Name, thing)\n\t\t\t}\n\n\t\t\tcheckList(v.Type.Params, thing+\" parameter\")\n\t\t\tcheckList(v.Type.Results, thing+\" result\")\n\t\tcase *ast.GenDecl:\n\t\t\tif v.Tok == token.IMPORT {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tvar thing string\n\t\t\tswitch v.Tok {\n\t\t\tcase token.CONST:\n\t\t\t\tthing = \"const\"\n\t\t\tcase token.TYPE:\n\t\t\t\tthing = \"type\"\n\t\t\tcase token.VAR:\n\t\t\t\tthing = \"var\"\n\t\t\t}\n\t\t\tfor _, spec := range v.Specs {\n\t\t\t\tswitch s := spec.(type) {\n\t\t\t\tcase *ast.TypeSpec:\n\t\t\t\t\tcheck(s.Name, thing)\n\t\t\t\tcase *ast.ValueSpec:\n\t\t\t\t\tfor _, id := range s.Names {\n\t\t\t\t\t\tcheck(id, thing)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase *ast.InterfaceType:\n\t\t\t// Do not check interface method names.\n\t\t\t// They are often constrainted by the method names of concrete types.\n\t\t\tfor _, x := range v.Methods.List {\n\t\t\t\tft, ok := x.Type.(*ast.FuncType)\n\t\t\t\tif !ok { // might be an embedded interface name\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcheckList(ft.Params, \"interface method parameter\")\n\t\t\t\tcheckList(ft.Results, \"interface method result\")\n\t\t\t}\n\t\tcase *ast.RangeStmt:\n\t\t\tif v.Tok == token.ASSIGN {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif id, ok := v.Key.(*ast.Ident); ok {\n\t\t\t\tcheck(id, \"range var\")\n\t\t\t}\n\t\t\tif id, ok := v.Value.(*ast.Ident); ok {\n\t\t\t\tcheck(id, \"range var\")\n\t\t\t}\n\t\tcase *ast.StructType:\n\t\t\tfor _, f := range v.Fields.List {\n\t\t\t\tfor _, id := range f.Names {\n\t\t\t\t\tcheck(id, \"struct field\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n}\n\n// lintName returns a different name if it should be different.\nfunc lintName(name string) (should string) {\n\t// Fast path for simple cases: \"_\" and all lowercase.\n\tif name == \"_\" {\n\t\treturn name\n\t}\n\tallLower := true\n\tfor _, r := range name {\n\t\tif !unicode.IsLower(r) {\n\t\t\tallLower = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif allLower {\n\t\treturn name\n\t}\n\n\t// Split camelCase at any lower->upper transition, and split on underscores.\n\t// Check each word for common initialisms.\n\trunes := []rune(name)\n\tw, i := 0, 0 // index of start of word, scan\n\tfor i+1 <= len(runes) {\n\t\teow := false // whether we hit the end of a word\n\t\tif i+1 == len(runes) {\n\t\t\teow = true\n\t\t} else if runes[i+1] == '_' {\n\t\t\t// underscore; shift the remainder forward over any run of underscores\n\t\t\teow = true\n\t\t\tn := 1\n\t\t\tfor i+n+1 < len(runes) && runes[i+n+1] == '_' {\n\t\t\t\tn++\n\t\t\t}\n\n\t\t\t// Leave at most one underscore if the underscore is between two digits\n\t\t\tif i+n+1 < len(runes) && unicode.IsDigit(runes[i]) && unicode.IsDigit(runes[i+n+1]) {\n\t\t\t\tn--\n\t\t\t}\n\n\t\t\tcopy(runes[i+1:], runes[i+n+1:])\n\t\t\trunes = runes[:len(runes)-n]\n\t\t} else if unicode.IsLower(runes[i]) && !unicode.IsLower(runes[i+1]) {\n\t\t\t// lower->non-lower\n\t\t\teow = true\n\t\t}\n\t\ti++\n\t\tif !eow {\n\t\t\tcontinue\n\t\t}\n\n\t\t// [w,i) is a word.\n\t\tword := string(runes[w:i])\n\t\tif u := strings.ToUpper(word); commonInitialisms[u] {\n\t\t\t// Keep consistent case, which is lowercase only at the start.\n\t\t\tif w == 0 && unicode.IsLower(runes[w]) {\n\t\t\t\tu = strings.ToLower(u)\n\t\t\t}\n\t\t\t// All the common initialisms are ASCII,\n\t\t\t// so we can replace the bytes exactly.\n\t\t\tcopy(runes[w:], []rune(u))\n\t\t} else if w > 0 && strings.ToLower(word) == word {\n\t\t\t// already all lowercase, and not the first word, so uppercase the first character.\n\t\t\trunes[w] = unicode.ToUpper(runes[w])\n\t\t}\n\t\tw = i\n\t}\n\treturn string(runes)\n}\n\n// commonInitialisms is a set of common initialisms.\n// Only add entries that are highly unlikely to be non-initialisms.\n// For instance, \"ID\" is fine (Freudian code is rare), but \"AND\" is not.\nvar commonInitialisms = map[string]bool{\n\t\"ACL\":   true,\n\t\"API\":   true,\n\t\"ASCII\": true,\n\t\"CPU\":   true,\n\t\"CSS\":   true,\n\t\"DNS\":   true,\n\t\"EOF\":   true,\n\t\"GUID\":  true,\n\t\"HTML\":  true,\n\t\"HTTP\":  true,\n\t\"HTTPS\": true,\n\t\"ID\":    true,\n\t\"IP\":    true,\n\t\"JSON\":  true,\n\t\"LHS\":   true,\n\t\"QPS\":   true,\n\t\"RAM\":   true,\n\t\"RHS\":   true,\n\t\"RPC\":   true,\n\t\"SLA\":   true,\n\t\"SMTP\":  true,\n\t\"SQL\":   true,\n\t\"SSH\":   true,\n\t\"TCP\":   true,\n\t\"TLS\":   true,\n\t\"TTL\":   true,\n\t\"UDP\":   true,\n\t\"UI\":    true,\n\t\"UID\":   true,\n\t\"UUID\":  true,\n\t\"URI\":   true,\n\t\"URL\":   true,\n\t\"UTF8\":  true,\n\t\"VM\":    true,\n\t\"XML\":   true,\n\t\"XMPP\":  true,\n\t\"XSRF\":  true,\n\t\"XSS\":   true,\n}\n\n// lintTypeDoc examines the doc comment on a type.\n// It complains if they are missing from an exported type,\n// or if they are not of the standard form.\nfunc (f *file) lintTypeDoc(t *ast.TypeSpec, doc *ast.CommentGroup) {\n\tif !ast.IsExported(t.Name.Name) {\n\t\treturn\n\t}\n\tif doc == nil {\n\t\tf.errorf(t, 1, link(docCommentsLink), category(\"comments\"), \"exported type %v should have comment or be unexported\", t.Name)\n\t\treturn\n\t}\n\n\ts := doc.Text()\n\tarticles := [...]string{\"A\", \"An\", \"The\"}\n\tfor _, a := range articles {\n\t\tif strings.HasPrefix(s, a+\" \") {\n\t\t\ts = s[len(a)+1:]\n\t\t\tbreak\n\t\t}\n\t}\n\tif !strings.HasPrefix(s, t.Name.Name+\" \") {\n\t\tf.errorf(doc, 1, link(docCommentsLink), category(\"comments\"), `comment on exported type %v should be of the form \"%v ...\" (with optional leading article)`, t.Name, t.Name)\n\t}\n}\n\nvar commonMethods = map[string]bool{\n\t\"Error\":     true,\n\t\"Read\":      true,\n\t\"ServeHTTP\": true,\n\t\"String\":    true,\n\t\"Write\":     true,\n\t\"Unwrap\":    true,\n}\n\n// lintFuncDoc examines doc comments on functions and methods.\n// It complains if they are missing, or not of the right form.\n// It has specific exclusions for well-known methods (see commonMethods above).\nfunc (f *file) lintFuncDoc(fn *ast.FuncDecl) {\n\tif !ast.IsExported(fn.Name.Name) {\n\t\t// func is unexported\n\t\treturn\n\t}\n\tkind := \"function\"\n\tname := fn.Name.Name\n\tif fn.Recv != nil && len(fn.Recv.List) > 0 {\n\t\t// method\n\t\tkind = \"method\"\n\t\trecv := receiverType(fn)\n\t\tif !ast.IsExported(recv) {\n\t\t\t// receiver is unexported\n\t\t\treturn\n\t\t}\n\t\tif commonMethods[name] {\n\t\t\treturn\n\t\t}\n\t\tswitch name {\n\t\tcase \"Len\", \"Less\", \"Swap\":\n\t\t\tif f.pkg.sortable[recv] {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tname = recv + \".\" + name\n\t}\n\tif fn.Doc == nil {\n\t\tf.errorf(fn, 1, link(docCommentsLink), category(\"comments\"), \"exported %s %s should have comment or be unexported\", kind, name)\n\t\treturn\n\t}\n\ts := fn.Doc.Text()\n\tprefix := fn.Name.Name + \" \"\n\tif !strings.HasPrefix(s, prefix) {\n\t\tf.errorf(fn.Doc, 1, link(docCommentsLink), category(\"comments\"), `comment on exported %s %s should be of the form \"%s...\"`, kind, name, prefix)\n\t}\n}\n\n// lintValueSpecDoc examines package-global variables and constants.\n// It complains if they are not individually declared,\n// or if they are not suitably documented in the right form (unless they are in a block that is commented).\nfunc (f *file) lintValueSpecDoc(vs *ast.ValueSpec, gd *ast.GenDecl, genDeclMissingComments map[*ast.GenDecl]bool) {\n\tkind := \"var\"\n\tif gd.Tok == token.CONST {\n\t\tkind = \"const\"\n\t}\n\n\tif len(vs.Names) > 1 {\n\t\t// Check that none are exported except for the first.\n\t\tfor _, n := range vs.Names[1:] {\n\t\t\tif ast.IsExported(n.Name) {\n\t\t\t\tf.errorf(vs, 1, category(\"comments\"), \"exported %s %s should have its own declaration\", kind, n.Name)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\t// Only one name.\n\tname := vs.Names[0].Name\n\tif !ast.IsExported(name) {\n\t\treturn\n\t}\n\n\tif vs.Doc == nil && gd.Doc == nil {\n\t\tif genDeclMissingComments[gd] {\n\t\t\treturn\n\t\t}\n\t\tblock := \"\"\n\t\tif kind == \"const\" && gd.Lparen.IsValid() {\n\t\t\tblock = \" (or a comment on this block)\"\n\t\t}\n\t\tf.errorf(vs, 1, link(docCommentsLink), category(\"comments\"), \"exported %s %s should have comment%s or be unexported\", kind, name, block)\n\t\tgenDeclMissingComments[gd] = true\n\t\treturn\n\t}\n\t// If this GenDecl has parens and a comment, we don't check its comment form.\n\tif gd.Lparen.IsValid() && gd.Doc != nil {\n\t\treturn\n\t}\n\t// The relevant text to check will be on either vs.Doc or gd.Doc.\n\t// Use vs.Doc preferentially.\n\tdoc := vs.Doc\n\tif doc == nil {\n\t\tdoc = gd.Doc\n\t}\n\tprefix := name + \" \"\n\tif !strings.HasPrefix(doc.Text(), prefix) {\n\t\tf.errorf(doc, 1, link(docCommentsLink), category(\"comments\"), `comment on exported %s %s should be of the form \"%s...\"`, kind, name, prefix)\n\t}\n}\n\nfunc (f *file) checkStutter(id *ast.Ident, thing string) {\n\tpkg, name := f.f.Name.Name, id.Name\n\tif !ast.IsExported(name) {\n\t\t// unexported name\n\t\treturn\n\t}\n\t// A name stutters if the package name is a strict prefix\n\t// and the next character of the name starts a new word.\n\tif len(name) <= len(pkg) {\n\t\t// name is too short to stutter.\n\t\t// This permits the name to be the same as the package name.\n\t\treturn\n\t}\n\tif !strings.EqualFold(pkg, name[:len(pkg)]) {\n\t\treturn\n\t}\n\t// We can assume the name is well-formed UTF-8.\n\t// If the next rune after the package name is uppercase or an underscore\n\t// the it's starting a new word and thus this name stutters.\n\trem := name[len(pkg):]\n\tif next, _ := utf8.DecodeRuneInString(rem); next == '_' || unicode.IsUpper(next) {\n\t\tf.errorf(id, 0.8, link(styleGuideBase+\"#package-names\"), category(\"naming\"), \"%s name will be used as %s.%s by other packages, and that stutters; consider calling this %s\", thing, pkg, name, rem)\n\t}\n}\n\n// zeroLiteral is a set of ast.BasicLit values that are zero values.\n// It is not exhaustive.\nvar zeroLiteral = map[string]bool{\n\t\"false\": true, // bool\n\t// runes\n\t`'\\x00'`: true,\n\t`'\\000'`: true,\n\t// strings\n\t`\"\"`: true,\n\t\"``\": true,\n\t// numerics\n\t\"0\":   true,\n\t\"0.\":  true,\n\t\"0.0\": true,\n\t\"0i\":  true,\n}\n\n// lintElses examines else blocks. It complains about any else block whose if block ends in a return.\nfunc (f *file) lintElses() {\n\t// We don't want to flag if { } else if { } else { } constructions.\n\t// They will appear as an IfStmt whose Else field is also an IfStmt.\n\t// Record such a node so we ignore it when we visit it.\n\tignore := make(map[*ast.IfStmt]bool)\n\n\tf.walk(func(node ast.Node) bool {\n\t\tifStmt, ok := node.(*ast.IfStmt)\n\t\tif !ok || ifStmt.Else == nil {\n\t\t\treturn true\n\t\t}\n\t\tif elseif, ok := ifStmt.Else.(*ast.IfStmt); ok {\n\t\t\tignore[elseif] = true\n\t\t\treturn true\n\t\t}\n\t\tif ignore[ifStmt] {\n\t\t\treturn true\n\t\t}\n\t\tif _, ok := ifStmt.Else.(*ast.BlockStmt); !ok {\n\t\t\t// only care about elses without conditions\n\t\t\treturn true\n\t\t}\n\t\tif len(ifStmt.Body.List) == 0 {\n\t\t\treturn true\n\t\t}\n\t\tshortDecl := false // does the if statement have a \":=\" initialization statement?\n\t\tif ifStmt.Init != nil {\n\t\t\tif as, ok := ifStmt.Init.(*ast.AssignStmt); ok && as.Tok == token.DEFINE {\n\t\t\t\tshortDecl = true\n\t\t\t}\n\t\t}\n\t\tlastStmt := ifStmt.Body.List[len(ifStmt.Body.List)-1]\n\t\tif _, ok := lastStmt.(*ast.ReturnStmt); ok {\n\t\t\textra := \"\"\n\t\t\tif shortDecl {\n\t\t\t\textra = \" (move short variable declaration to its own line if necessary)\"\n\t\t\t}\n\t\t\tf.errorf(ifStmt.Else, 1, link(styleGuideBase+\"#indent-error-flow\"), category(\"indent\"), \"if block ends with a return statement, so drop this else and outdent its block\"+extra)\n\t\t}\n\t\treturn true\n\t})\n}\n\n// lintRanges examines range clauses. It complains about redundant constructions.\nfunc (f *file) lintRanges() {\n\tf.walk(func(node ast.Node) bool {\n\t\trs, ok := node.(*ast.RangeStmt)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\n\t\tif isIdent(rs.Key, \"_\") && (rs.Value == nil || isIdent(rs.Value, \"_\")) {\n\t\t\tp := f.errorf(rs.Key, 1, category(\"range-loop\"), \"should omit values from range; this loop is equivalent to `for range ...`\")\n\n\t\t\tnewRS := *rs // shallow copy\n\t\t\tnewRS.Value = nil\n\t\t\tnewRS.Key = nil\n\t\t\tp.ReplacementLine = f.firstLineOf(&newRS, rs)\n\n\t\t\treturn true\n\t\t}\n\n\t\tif isIdent(rs.Value, \"_\") {\n\t\t\tp := f.errorf(rs.Value, 1, category(\"range-loop\"), \"should omit 2nd value from range; this loop is equivalent to `for %s %s range ...`\", f.render(rs.Key), rs.Tok)\n\n\t\t\tnewRS := *rs // shallow copy\n\t\t\tnewRS.Value = nil\n\t\t\tp.ReplacementLine = f.firstLineOf(&newRS, rs)\n\t\t}\n\n\t\treturn true\n\t})\n}\n\n// lintErrorf examines errors.New and testing.Error calls. It complains if its only argument is an fmt.Sprintf invocation.\nfunc (f *file) lintErrorf() {\n\tf.walk(func(node ast.Node) bool {\n\t\tce, ok := node.(*ast.CallExpr)\n\t\tif !ok || len(ce.Args) != 1 {\n\t\t\treturn true\n\t\t}\n\t\tisErrorsNew := isPkgDot(ce.Fun, \"errors\", \"New\")\n\t\tvar isTestingError bool\n\t\tse, ok := ce.Fun.(*ast.SelectorExpr)\n\t\tif ok && se.Sel.Name == \"Error\" {\n\t\t\tif typ := f.pkg.typeOf(se.X); typ != nil {\n\t\t\t\tisTestingError = typ.String() == \"*testing.T\"\n\t\t\t}\n\t\t}\n\t\tif !isErrorsNew && !isTestingError {\n\t\t\treturn true\n\t\t}\n\t\tif !f.imports(\"errors\") {\n\t\t\treturn true\n\t\t}\n\t\targ := ce.Args[0]\n\t\tce, ok = arg.(*ast.CallExpr)\n\t\tif !ok || !isPkgDot(ce.Fun, \"fmt\", \"Sprintf\") {\n\t\t\treturn true\n\t\t}\n\t\terrorfPrefix := \"fmt\"\n\t\tif isTestingError {\n\t\t\terrorfPrefix = f.render(se.X)\n\t\t}\n\t\tp := f.errorf(node, 1, category(\"errors\"), \"should replace %s(fmt.Sprintf(...)) with %s.Errorf(...)\", f.render(se), errorfPrefix)\n\n\t\tm := f.srcLineWithMatch(ce, `^(.*)`+f.render(se)+`\\(fmt\\.Sprintf\\((.*)\\)\\)(.*)$`)\n\t\tif m != nil {\n\t\t\tp.ReplacementLine = m[1] + errorfPrefix + \".Errorf(\" + m[2] + \")\" + m[3]\n\t\t}\n\n\t\treturn true\n\t})\n}\n\n// lintErrors examines global error vars. It complains if they aren't named in the standard way.\nfunc (f *file) lintErrors() {\n\tfor _, decl := range f.f.Decls {\n\t\tgd, ok := decl.(*ast.GenDecl)\n\t\tif !ok || gd.Tok != token.VAR {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, spec := range gd.Specs {\n\t\t\tspec := spec.(*ast.ValueSpec)\n\t\t\tif len(spec.Names) != 1 || len(spec.Values) != 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tce, ok := spec.Values[0].(*ast.CallExpr)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !isPkgDot(ce.Fun, \"errors\", \"New\") && !isPkgDot(ce.Fun, \"fmt\", \"Errorf\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tid := spec.Names[0]\n\t\t\tprefix := \"err\"\n\t\t\tif id.IsExported() {\n\t\t\t\tprefix = \"Err\"\n\t\t\t}\n\t\t\tif !strings.HasPrefix(id.Name, prefix) {\n\t\t\t\tf.errorf(id, 0.9, category(\"naming\"), \"error var %s should have name of the form %sFoo\", id.Name, prefix)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc lintErrorString(s string) (isClean bool, conf float64) {\n\tconst basicConfidence = 0.8\n\tconst capConfidence = basicConfidence - 0.2\n\tfirst, firstN := utf8.DecodeRuneInString(s)\n\tlast, _ := utf8.DecodeLastRuneInString(s)\n\tif last == '.' || last == ':' || last == '!' || last == '\\n' {\n\t\treturn false, basicConfidence\n\t}\n\tif unicode.IsUpper(first) {\n\t\t// People use proper nouns and exported Go identifiers in error strings,\n\t\t// so decrease the confidence of warnings for capitalization.\n\t\tif len(s) <= firstN {\n\t\t\treturn false, capConfidence\n\t\t}\n\t\t// Flag strings starting with something that doesn't look like an initialism.\n\t\tif second, _ := utf8.DecodeRuneInString(s[firstN:]); !unicode.IsUpper(second) {\n\t\t\treturn false, capConfidence\n\t\t}\n\t}\n\treturn true, 0\n}\n\n// lintErrorStrings examines error strings.\n// It complains if they are capitalized or end in punctuation or a newline.\nfunc (f *file) lintErrorStrings() {\n\tf.walk(func(node ast.Node) bool {\n\t\tce, ok := node.(*ast.CallExpr)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\t\tif !isPkgDot(ce.Fun, \"errors\", \"New\") && !isPkgDot(ce.Fun, \"fmt\", \"Errorf\") {\n\t\t\treturn true\n\t\t}\n\t\tif len(ce.Args) < 1 {\n\t\t\treturn true\n\t\t}\n\t\tstr, ok := ce.Args[0].(*ast.BasicLit)\n\t\tif !ok || str.Kind != token.STRING {\n\t\t\treturn true\n\t\t}\n\t\ts, _ := strconv.Unquote(str.Value) // can assume well-formed Go\n\t\tif s == \"\" {\n\t\t\treturn true\n\t\t}\n\t\tclean, conf := lintErrorString(s)\n\t\tif clean {\n\t\t\treturn true\n\t\t}\n\n\t\tf.errorf(str, conf, link(styleGuideBase+\"#error-strings\"), category(\"errors\"),\n\t\t\t\"error strings should not be capitalized or end with punctuation or a newline\")\n\t\treturn true\n\t})\n}\n\n// lintReceiverNames examines receiver names. It complains about inconsistent\n// names used for the same type and names such as \"this\".\nfunc (f *file) lintReceiverNames() {\n\ttypeReceiver := map[string]string{}\n\tf.walk(func(n ast.Node) bool {\n\t\tfn, ok := n.(*ast.FuncDecl)\n\t\tif !ok || fn.Recv == nil || len(fn.Recv.List) == 0 {\n\t\t\treturn true\n\t\t}\n\t\tnames := fn.Recv.List[0].Names\n\t\tif len(names) < 1 {\n\t\t\treturn true\n\t\t}\n\t\tname := names[0].Name\n\t\tconst ref = styleGuideBase + \"#receiver-names\"\n\t\tif name == \"_\" {\n\t\t\tf.errorf(n, 1, link(ref), category(\"naming\"), `receiver name should not be an underscore, omit the name if it is unused`)\n\t\t\treturn true\n\t\t}\n\t\tif name == \"this\" || name == \"self\" {\n\t\t\tf.errorf(n, 1, link(ref), category(\"naming\"), `receiver name should be a reflection of its identity; don't use generic names such as \"this\" or \"self\"`)\n\t\t\treturn true\n\t\t}\n\t\trecv := receiverType(fn)\n\t\tif prev, ok := typeReceiver[recv]; ok && prev != name {\n\t\t\tf.errorf(n, 1, link(ref), category(\"naming\"), \"receiver name %s should be consistent with previous receiver name %s for %s\", name, prev, recv)\n\t\t\treturn true\n\t\t}\n\t\ttypeReceiver[recv] = name\n\t\treturn true\n\t})\n}\n\n// lintIncDec examines statements that increment or decrement a variable.\n// It complains if they don't use x++ or x--.\nfunc (f *file) lintIncDec() {\n\tf.walk(func(n ast.Node) bool {\n\t\tas, ok := n.(*ast.AssignStmt)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\t\tif len(as.Lhs) != 1 {\n\t\t\treturn true\n\t\t}\n\t\tif !isOne(as.Rhs[0]) {\n\t\t\treturn true\n\t\t}\n\t\tvar suffix string\n\t\tswitch as.Tok {\n\t\tcase token.ADD_ASSIGN:\n\t\t\tsuffix = \"++\"\n\t\tcase token.SUB_ASSIGN:\n\t\t\tsuffix = \"--\"\n\t\tdefault:\n\t\t\treturn true\n\t\t}\n\t\tf.errorf(as, 0.8, category(\"unary-op\"), \"should replace %s with %s%s\", f.render(as), f.render(as.Lhs[0]), suffix)\n\t\treturn true\n\t})\n}\n\n// lintErrorReturn examines function declarations that return an error.\n// It complains if the error isn't the last parameter.\nfunc (f *file) lintErrorReturn() {\n\tf.walk(func(n ast.Node) bool {\n\t\tfn, ok := n.(*ast.FuncDecl)\n\t\tif !ok || fn.Type.Results == nil {\n\t\t\treturn true\n\t\t}\n\t\tret := fn.Type.Results.List\n\t\tif len(ret) <= 1 {\n\t\t\treturn true\n\t\t}\n\t\tif isIdent(ret[len(ret)-1].Type, \"error\") {\n\t\t\treturn true\n\t\t}\n\t\t// An error return parameter should be the last parameter.\n\t\t// Flag any error parameters found before the last.\n\t\tfor _, r := range ret[:len(ret)-1] {\n\t\t\tif isIdent(r.Type, \"error\") {\n\t\t\t\tf.errorf(fn, 0.9, category(\"arg-order\"), \"error should be the last type when returning multiple items\")\n\t\t\t\tbreak // only flag one\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n}\n\n// lintUnexportedReturn examines exported function declarations.\n// It complains if any return an unexported type.\nfunc (f *file) lintUnexportedReturn() {\n\tf.walk(func(n ast.Node) bool {\n\t\tfn, ok := n.(*ast.FuncDecl)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\t\tif fn.Type.Results == nil {\n\t\t\treturn false\n\t\t}\n\t\tif !fn.Name.IsExported() {\n\t\t\treturn false\n\t\t}\n\t\tthing := \"func\"\n\t\tif fn.Recv != nil && len(fn.Recv.List) > 0 {\n\t\t\tthing = \"method\"\n\t\t\tif !ast.IsExported(receiverType(fn)) {\n\t\t\t\t// Don't report exported methods of unexported types,\n\t\t\t\t// such as private implementations of sort.Interface.\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tfor _, ret := range fn.Type.Results.List {\n\t\t\ttyp := f.pkg.typeOf(ret.Type)\n\t\t\tif exportedType(typ) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tf.errorf(ret.Type, 0.8, category(\"unexported-type-in-api\"),\n\t\t\t\t\"exported %s %s returns unexported type %s, which can be annoying to use\",\n\t\t\t\tthing, fn.Name.Name, typ)\n\t\t\tbreak // only flag one\n\t\t}\n\t\treturn false\n\t})\n}\n\n// exportedType reports whether typ is an exported type.\n// It is imprecise, and will err on the side of returning true,\n// such as for composite types.\nfunc exportedType(typ types.Type) bool {\n\tswitch T := typ.(type) {\n\tcase *types.Named:\n\t\t// Builtin types have no package.\n\t\treturn T.Obj().Pkg() == nil || T.Obj().Exported()\n\tcase *types.Map:\n\t\treturn exportedType(T.Key()) && exportedType(T.Elem())\n\tcase interface {\n\t\tElem() types.Type\n\t}: // array, slice, pointer, chan\n\t\treturn exportedType(T.Elem())\n\t}\n\t// Be conservative about other types, such as struct, interface, etc.\n\treturn true\n}\n\n// timeSuffixes is a list of name suffixes that imply a time unit.\n// This is not an exhaustive list.\nvar timeSuffixes = []string{\n\t\"Sec\", \"Secs\", \"Seconds\",\n\t\"Msec\", \"Msecs\",\n\t\"Milli\", \"Millis\", \"Milliseconds\",\n\t\"Usec\", \"Usecs\", \"Microseconds\",\n\t\"MS\", \"Ms\",\n}\n\nfunc (f *file) lintTimeNames() {\n\tf.walk(func(node ast.Node) bool {\n\t\tv, ok := node.(*ast.ValueSpec)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\t\tfor _, name := range v.Names {\n\t\t\torigTyp := f.pkg.typeOf(name)\n\t\t\t// Look for time.Duration or *time.Duration;\n\t\t\t// the latter is common when using flag.Duration.\n\t\t\ttyp := origTyp\n\t\t\tif pt, ok := typ.(*types.Pointer); ok {\n\t\t\t\ttyp = pt.Elem()\n\t\t\t}\n\t\t\tif !f.pkg.isNamedType(typ, \"time\", \"Duration\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsuffix := \"\"\n\t\t\tfor _, suf := range timeSuffixes {\n\t\t\t\tif strings.HasSuffix(name.Name, suf) {\n\t\t\t\t\tsuffix = suf\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif suffix == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tf.errorf(v, 0.9, category(\"time\"), \"var %s is of type %v; don't use unit-specific suffix %q\", name.Name, origTyp, suffix)\n\t\t}\n\t\treturn true\n\t})\n}\n\n// lintContextKeyTypes checks for call expressions to context.WithValue with\n// basic types used for the key argument.\n// See: https://golang.org/issue/17293\nfunc (f *file) lintContextKeyTypes() {\n\tf.walk(func(node ast.Node) bool {\n\t\tswitch node := node.(type) {\n\t\tcase *ast.CallExpr:\n\t\t\tf.checkContextKeyType(node)\n\t\t}\n\n\t\treturn true\n\t})\n}\n\n// checkContextKeyType reports an error if the call expression calls\n// context.WithValue with a key argument of basic type.\nfunc (f *file) checkContextKeyType(x *ast.CallExpr) {\n\tsel, ok := x.Fun.(*ast.SelectorExpr)\n\tif !ok {\n\t\treturn\n\t}\n\tpkg, ok := sel.X.(*ast.Ident)\n\tif !ok || pkg.Name != \"context\" {\n\t\treturn\n\t}\n\tif sel.Sel.Name != \"WithValue\" {\n\t\treturn\n\t}\n\n\t// key is second argument to context.WithValue\n\tif len(x.Args) != 3 {\n\t\treturn\n\t}\n\tkey := f.pkg.typesInfo.Types[x.Args[1]]\n\n\tif ktyp, ok := key.Type.(*types.Basic); ok && ktyp.Kind() != types.Invalid {\n\t\tf.errorf(x, 1.0, category(\"context\"), fmt.Sprintf(\"should not use basic type %s as key in context.WithValue\", key.Type))\n\t}\n}\n\n// lintContextArgs examines function declarations that contain an\n// argument with a type of context.Context\n// It complains if that argument isn't the first parameter.\nfunc (f *file) lintContextArgs() {\n\tf.walk(func(n ast.Node) bool {\n\t\tfn, ok := n.(*ast.FuncDecl)\n\t\tif !ok || len(fn.Type.Params.List) <= 1 {\n\t\t\treturn true\n\t\t}\n\t\t// A context.Context should be the first parameter of a function.\n\t\t// Flag any that show up after the first.\n\t\tfor _, arg := range fn.Type.Params.List[1:] {\n\t\t\tif isPkgDot(arg.Type, \"context\", \"Context\") {\n\t\t\t\tf.errorf(fn, 0.9, link(\"https://golang.org/pkg/context/\"), category(\"arg-order\"), \"context.Context should be the first parameter of a function\")\n\t\t\t\tbreak // only flag one\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n}\n\n// containsComments returns whether the interval [start, end) contains any\n// comments without \"// MATCH \" prefix.\nfunc (f *file) containsComments(start, end token.Pos) bool {\n\tfor _, cgroup := range f.f.Comments {\n\t\tcomments := cgroup.List\n\t\tif comments[0].Slash >= end {\n\t\t\t// All comments starting with this group are after end pos.\n\t\t\treturn false\n\t\t}\n\t\tif comments[len(comments)-1].Slash < start {\n\t\t\t// Comments group ends before start pos.\n\t\t\tcontinue\n\t\t}\n\t\tfor _, c := range comments {\n\t\t\tif start <= c.Slash && c.Slash < end && !strings.HasPrefix(c.Text, \"// MATCH \") {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// receiverType returns the named type of the method receiver, sans \"*\",\n// or \"invalid-type\" if fn.Recv is ill formed.\nfunc receiverType(fn *ast.FuncDecl) string {\n\tswitch e := fn.Recv.List[0].Type.(type) {\n\tcase *ast.Ident:\n\t\treturn e.Name\n\tcase *ast.StarExpr:\n\t\tif id, ok := e.X.(*ast.Ident); ok {\n\t\t\treturn id.Name\n\t\t}\n\t}\n\t// The parser accepts much more than just the legal forms.\n\treturn \"invalid-type\"\n}\n\nfunc (f *file) walk(fn func(ast.Node) bool) {\n\tast.Walk(walker(fn), f.f)\n}\n\nfunc (f *file) render(x interface{}) string {\n\tvar buf bytes.Buffer\n\tif err := printer.Fprint(&buf, f.fset, x); err != nil {\n\t\tpanic(err)\n\t}\n\treturn buf.String()\n}\n\nfunc (f *file) debugRender(x interface{}) string {\n\tvar buf bytes.Buffer\n\tif err := ast.Fprint(&buf, f.fset, x, nil); err != nil {\n\t\tpanic(err)\n\t}\n\treturn buf.String()\n}\n\n// walker adapts a function to satisfy the ast.Visitor interface.\n// The function return whether the walk should proceed into the node's children.\ntype walker func(ast.Node) bool\n\nfunc (w walker) Visit(node ast.Node) ast.Visitor {\n\tif w(node) {\n\t\treturn w\n\t}\n\treturn nil\n}\n\nfunc isIdent(expr ast.Expr, ident string) bool {\n\tid, ok := expr.(*ast.Ident)\n\treturn ok && id.Name == ident\n}\n\n// isBlank returns whether id is the blank identifier \"_\".\n// If id == nil, the answer is false.\nfunc isBlank(id *ast.Ident) bool { return id != nil && id.Name == \"_\" }\n\nfunc isPkgDot(expr ast.Expr, pkg, name string) bool {\n\tsel, ok := expr.(*ast.SelectorExpr)\n\treturn ok && isIdent(sel.X, pkg) && isIdent(sel.Sel, name)\n}\n\nfunc isOne(expr ast.Expr) bool {\n\tlit, ok := expr.(*ast.BasicLit)\n\treturn ok && lit.Kind == token.INT && lit.Value == \"1\"\n}\n\nfunc isCgoExported(f *ast.FuncDecl) bool {\n\tif f.Recv != nil || f.Doc == nil {\n\t\treturn false\n\t}\n\n\tcgoExport := regexp.MustCompile(fmt.Sprintf(\"(?m)^//export %s$\", regexp.QuoteMeta(f.Name.Name)))\n\tfor _, c := range f.Doc.List {\n\t\tif cgoExport.MatchString(c.Text) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nvar basicTypeKinds = map[types.BasicKind]string{\n\ttypes.UntypedBool:    \"bool\",\n\ttypes.UntypedInt:     \"int\",\n\ttypes.UntypedRune:    \"rune\",\n\ttypes.UntypedFloat:   \"float64\",\n\ttypes.UntypedComplex: \"complex128\",\n\ttypes.UntypedString:  \"string\",\n}\n\n// isUntypedConst reports whether expr is an untyped constant,\n// and indicates what its default type is.\n// scope may be nil.\nfunc (f *file) isUntypedConst(expr ast.Expr) (defType string, ok bool) {\n\t// Re-evaluate expr outside of its context to see if it's untyped.\n\t// (An expr evaluated within, for example, an assignment context will get the type of the LHS.)\n\texprStr := f.render(expr)\n\ttv, err := types.Eval(f.fset, f.pkg.typesPkg, expr.Pos(), exprStr)\n\tif err != nil {\n\t\treturn \"\", false\n\t}\n\tif b, ok := tv.Type.(*types.Basic); ok {\n\t\tif dt, ok := basicTypeKinds[b.Kind()]; ok {\n\t\t\treturn dt, true\n\t\t}\n\t}\n\n\treturn \"\", false\n}\n\n// firstLineOf renders the given node and returns its first line.\n// It will also match the indentation of another node.\nfunc (f *file) firstLineOf(node, match ast.Node) string {\n\tline := f.render(node)\n\tif i := strings.Index(line, \"\\n\"); i >= 0 {\n\t\tline = line[:i]\n\t}\n\treturn f.indentOf(match) + line\n}\n\nfunc (f *file) indentOf(node ast.Node) string {\n\tline := srcLine(f.src, f.fset.Position(node.Pos()))\n\tfor i, r := range line {\n\t\tswitch r {\n\t\tcase ' ', '\\t':\n\t\tdefault:\n\t\t\treturn line[:i]\n\t\t}\n\t}\n\treturn line // unusual or empty line\n}\n\nfunc (f *file) srcLineWithMatch(node ast.Node, pattern string) (m []string) {\n\tline := srcLine(f.src, f.fset.Position(node.Pos()))\n\tline = strings.TrimSuffix(line, \"\\n\")\n\trx := regexp.MustCompile(pattern)\n\treturn rx.FindStringSubmatch(line)\n}\n\n// imports returns true if the current file imports the specified package path.\nfunc (f *file) imports(importPath string) bool {\n\tall := astutil.Imports(f.fset, f.f)\n\tfor _, p := range all {\n\t\tfor _, i := range p {\n\t\t\tuq, err := strconv.Unquote(i.Path.Value)\n\t\t\tif err == nil && importPath == uq {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// srcLine returns the complete line at p, including the terminating newline.\nfunc srcLine(src []byte, p token.Position) string {\n\t// Run to end of line in both directions if not at line start/end.\n\tlo, hi := p.Offset, p.Offset+1\n\tfor lo > 0 && src[lo-1] != '\\n' {\n\t\tlo--\n\t}\n\tfor hi < len(src) && src[hi-1] != '\\n' {\n\t\thi++\n\t}\n\treturn string(src[lo:hi])\n}\n"
        },
        {
          "name": "lint_test.go",
          "type": "blob",
          "size": 8.5439453125,
          "content": "// Copyright (c) 2013 The Go Authors. All rights reserved.\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd.\n\npackage lint\n\nimport (\n\t\"bytes\"\n\t\"flag\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/printer\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"io/ioutil\"\n\t\"path\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar lintMatch = flag.String(\"lint.match\", \"\", \"restrict testdata matches to this pattern\")\n\nfunc TestAll(t *testing.T) {\n\tl := new(Linter)\n\trx, err := regexp.Compile(*lintMatch)\n\tif err != nil {\n\t\tt.Fatalf(\"Bad -lint.match value %q: %v\", *lintMatch, err)\n\t}\n\n\tbaseDir := \"testdata\"\n\tfis, err := ioutil.ReadDir(baseDir)\n\tif err != nil {\n\t\tt.Fatalf(\"ioutil.ReadDir: %v\", err)\n\t}\n\tif len(fis) == 0 {\n\t\tt.Fatalf(\"no files in %v\", baseDir)\n\t}\n\tfor _, fi := range fis {\n\t\tif !rx.MatchString(fi.Name()) {\n\t\t\tcontinue\n\t\t}\n\t\t//t.Logf(\"Testing %s\", fi.Name())\n\t\tsrc, err := ioutil.ReadFile(path.Join(baseDir, fi.Name()))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed reading %s: %v\", fi.Name(), err)\n\t\t}\n\n\t\tins := parseInstructions(t, fi.Name(), src)\n\t\tif ins == nil {\n\t\t\tt.Errorf(\"Test file %v does not have instructions\", fi.Name())\n\t\t\tcontinue\n\t\t}\n\n\t\tps, err := l.Lint(fi.Name(), src)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Linting %s: %v\", fi.Name(), err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, in := range ins {\n\t\t\tok := false\n\t\t\tfor i, p := range ps {\n\t\t\t\tif p.Position.Line != in.Line {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif in.Match.MatchString(p.Text) {\n\t\t\t\t\t// check replacement if we are expecting one\n\t\t\t\t\tif in.Replacement != \"\" {\n\t\t\t\t\t\t// ignore any inline comments, since that would be recursive\n\t\t\t\t\t\tr := p.ReplacementLine\n\t\t\t\t\t\tif i := strings.Index(r, \" //\"); i >= 0 {\n\t\t\t\t\t\t\tr = r[:i]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif r != in.Replacement {\n\t\t\t\t\t\t\tt.Errorf(\"Lint failed at %s:%d; got replacement %q, want %q\", fi.Name(), in.Line, r, in.Replacement)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// remove this problem from ps\n\t\t\t\t\tcopy(ps[i:], ps[i+1:])\n\t\t\t\t\tps = ps[:len(ps)-1]\n\n\t\t\t\t\t//t.Logf(\"/%v/ matched at %s:%d\", in.Match, fi.Name(), in.Line)\n\t\t\t\t\tok = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"Lint failed at %s:%d; /%v/ did not match\", fi.Name(), in.Line, in.Match)\n\t\t\t}\n\t\t}\n\t\tfor _, p := range ps {\n\t\t\tt.Errorf(\"Unexpected problem at %s:%d: %v\", fi.Name(), p.Position.Line, p.Text)\n\t\t}\n\t}\n}\n\ntype instruction struct {\n\tLine        int            // the line number this applies to\n\tMatch       *regexp.Regexp // what pattern to match\n\tReplacement string         // what the suggested replacement line should be\n}\n\n// parseInstructions parses instructions from the comments in a Go source file.\n// It returns nil if none were parsed.\nfunc parseInstructions(t *testing.T, filename string, src []byte) []instruction {\n\tfset := token.NewFileSet()\n\tf, err := parser.ParseFile(fset, filename, src, parser.ParseComments)\n\tif err != nil {\n\t\tt.Fatalf(\"Test file %v does not parse: %v\", filename, err)\n\t}\n\tvar ins []instruction\n\tfor _, cg := range f.Comments {\n\t\tln := fset.Position(cg.Pos()).Line\n\t\traw := cg.Text()\n\t\tfor _, line := range strings.Split(raw, \"\\n\") {\n\t\t\tif line == \"\" || strings.HasPrefix(line, \"#\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif line == \"OK\" && ins == nil {\n\t\t\t\t// so our return value will be non-nil\n\t\t\t\tins = make([]instruction, 0)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strings.Contains(line, \"MATCH\") {\n\t\t\t\trx, err := extractPattern(line)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"At %v:%d: %v\", filename, ln, err)\n\t\t\t\t}\n\t\t\t\tmatchLine := ln\n\t\t\t\tif i := strings.Index(line, \"MATCH:\"); i >= 0 {\n\t\t\t\t\t// This is a match for a different line.\n\t\t\t\t\tlns := strings.TrimPrefix(line[i:], \"MATCH:\")\n\t\t\t\t\tlns = lns[:strings.Index(lns, \" \")]\n\t\t\t\t\tmatchLine, err = strconv.Atoi(lns)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatalf(\"Bad match line number %q at %v:%d: %v\", lns, filename, ln, err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar repl string\n\t\t\t\tif r, ok := extractReplacement(line); ok {\n\t\t\t\t\trepl = r\n\t\t\t\t}\n\t\t\t\tins = append(ins, instruction{\n\t\t\t\t\tLine:        matchLine,\n\t\t\t\t\tMatch:       rx,\n\t\t\t\t\tReplacement: repl,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\treturn ins\n}\n\nfunc extractPattern(line string) (*regexp.Regexp, error) {\n\ta, b := strings.Index(line, \"/\"), strings.LastIndex(line, \"/\")\n\tif a == -1 || a == b {\n\t\treturn nil, fmt.Errorf(\"malformed match instruction %q\", line)\n\t}\n\tpat := line[a+1 : b]\n\trx, err := regexp.Compile(pat)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"bad match pattern %q: %v\", pat, err)\n\t}\n\treturn rx, nil\n}\n\nfunc extractReplacement(line string) (string, bool) {\n\t// Look for this:  / -> `\n\t// (the end of a match and start of a backtick string),\n\t// and then the closing backtick.\n\tconst start = \"/ -> `\"\n\ta, b := strings.Index(line, start), strings.LastIndex(line, \"`\")\n\tif a < 0 || a > b {\n\t\treturn \"\", false\n\t}\n\treturn line[a+len(start) : b], true\n}\n\nfunc render(fset *token.FileSet, x interface{}) string {\n\tvar buf bytes.Buffer\n\tif err := printer.Fprint(&buf, fset, x); err != nil {\n\t\tpanic(err)\n\t}\n\treturn buf.String()\n}\n\nfunc TestLine(t *testing.T) {\n\ttests := []struct {\n\t\tsrc    string\n\t\toffset int\n\t\twant   string\n\t}{\n\t\t{\"single line file\", 5, \"single line file\"},\n\t\t{\"single line file with newline\\n\", 5, \"single line file with newline\\n\"},\n\t\t{\"first\\nsecond\\nthird\\n\", 2, \"first\\n\"},\n\t\t{\"first\\nsecond\\nthird\\n\", 9, \"second\\n\"},\n\t\t{\"first\\nsecond\\nthird\\n\", 14, \"third\\n\"},\n\t\t{\"first\\nsecond\\nthird with no newline\", 16, \"third with no newline\"},\n\t\t{\"first byte\\n\", 0, \"first byte\\n\"},\n\t}\n\tfor _, test := range tests {\n\t\tgot := srcLine([]byte(test.src), token.Position{Offset: test.offset})\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"srcLine(%q, offset=%d) = %q, want %q\", test.src, test.offset, got, test.want)\n\t\t}\n\t}\n}\n\nfunc TestLintName(t *testing.T) {\n\ttests := []struct {\n\t\tname, want string\n\t}{\n\t\t{\"foo_bar\", \"fooBar\"},\n\t\t{\"foo_bar_baz\", \"fooBarBaz\"},\n\t\t{\"Foo_bar\", \"FooBar\"},\n\t\t{\"foo_WiFi\", \"fooWiFi\"},\n\t\t{\"id\", \"id\"},\n\t\t{\"Id\", \"ID\"},\n\t\t{\"foo_id\", \"fooID\"},\n\t\t{\"fooId\", \"fooID\"},\n\t\t{\"fooUid\", \"fooUID\"},\n\t\t{\"idFoo\", \"idFoo\"},\n\t\t{\"uidFoo\", \"uidFoo\"},\n\t\t{\"midIdDle\", \"midIDDle\"},\n\t\t{\"APIProxy\", \"APIProxy\"},\n\t\t{\"ApiProxy\", \"APIProxy\"},\n\t\t{\"apiProxy\", \"apiProxy\"},\n\t\t{\"_Leading\", \"_Leading\"},\n\t\t{\"___Leading\", \"_Leading\"},\n\t\t{\"trailing_\", \"trailing\"},\n\t\t{\"trailing___\", \"trailing\"},\n\t\t{\"a_b\", \"aB\"},\n\t\t{\"a__b\", \"aB\"},\n\t\t{\"a___b\", \"aB\"},\n\t\t{\"Rpc1150\", \"RPC1150\"},\n\t\t{\"case3_1\", \"case3_1\"},\n\t\t{\"case3__1\", \"case3_1\"},\n\t\t{\"IEEE802_16bit\", \"IEEE802_16bit\"},\n\t\t{\"IEEE802_16Bit\", \"IEEE802_16Bit\"},\n\t}\n\tfor _, test := range tests {\n\t\tgot := lintName(test.name)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"lintName(%q) = %q, want %q\", test.name, got, test.want)\n\t\t}\n\t}\n}\n\nfunc TestExportedType(t *testing.T) {\n\ttests := []struct {\n\t\ttypString string\n\t\texp       bool\n\t}{\n\t\t{\"int\", true},\n\t\t{\"string\", false}, // references the shadowed builtin \"string\"\n\t\t{\"T\", true},\n\t\t{\"t\", false},\n\t\t{\"*T\", true},\n\t\t{\"*t\", false},\n\t\t{\"map[int]complex128\", true},\n\t}\n\tfor _, test := range tests {\n\t\tsrc := `package foo; type T int; type t int; type string struct{}`\n\t\tfset := token.NewFileSet()\n\t\tfile, err := parser.ParseFile(fset, \"foo.go\", src, 0)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Parsing %q: %v\", src, err)\n\t\t}\n\t\t// use the package name as package path\n\t\tconfig := &types.Config{}\n\t\tpkg, err := config.Check(file.Name.Name, fset, []*ast.File{file}, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Type checking %q: %v\", src, err)\n\t\t}\n\t\ttv, err := types.Eval(fset, pkg, token.NoPos, test.typString)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"types.Eval(%q): %v\", test.typString, err)\n\t\t\tcontinue\n\t\t}\n\t\tif got := exportedType(tv.Type); got != test.exp {\n\t\t\tt.Errorf(\"exportedType(%v) = %t, want %t\", tv.Type, got, test.exp)\n\t\t}\n\t}\n}\n\nfunc TestIsGenerated(t *testing.T) {\n\ttests := []struct {\n\t\tsource    string\n\t\tgenerated bool\n\t}{\n\t\t{\"// Code Generated by some tool. DO NOT EDIT.\", false},\n\t\t{\"// Code generated by some tool. DO NOT EDIT.\", true},\n\t\t{\"// Code generated by some tool. DO NOT EDIT\", false},\n\t\t{\"// Code generated  DO NOT EDIT.\", true},\n\t\t{\"// Code generated DO NOT EDIT.\", false},\n\t\t{\"\\t\\t// Code generated by some tool. DO NOT EDIT.\\npackage foo\\n\", false},\n\t\t{\"// Code generated by some tool. DO NOT EDIT.\\npackage foo\\n\", true},\n\t\t{\"package foo\\n// Code generated by some tool. DO NOT EDIT.\\ntype foo int\\n\", true},\n\t\t{\"package foo\\n // Code generated by some tool. DO NOT EDIT.\\ntype foo int\\n\", false},\n\t\t{\"package foo\\n// Code generated by some tool. DO NOT EDIT. \\ntype foo int\\n\", false},\n\t\t{\"package foo\\ntype foo int\\n// Code generated by some tool. DO NOT EDIT.\\n\", true},\n\t\t{\"package foo\\ntype foo int\\n// Code generated by some tool. DO NOT EDIT.\", true},\n\t}\n\n\tfor i, test := range tests {\n\t\tgot := isGenerated([]byte(test.source))\n\t\tif got != test.generated {\n\t\t\tt.Errorf(\"test %d, isGenerated() = %v, want %v\", i, got, test.generated)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}