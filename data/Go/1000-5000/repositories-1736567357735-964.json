{
  "metadata": {
    "timestamp": 1736567357735,
    "page": 964,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "anaskhan96/soup",
      "stars": 2188,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0068359375,
          "content": ".idea/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.05078125,
          "content": "language: go\n\ngo:\n  - 1.15.x\n  \nscript:\n  - go test\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.884765625,
          "content": "## v1.2.0\n\n### Added\n\n- Error enums which can be accessed using `Root.Error.(soup.Error).Type`. Refer to `examples/errors`.\n\n## v1.1.0\n\n### Added\n\n- Cookies can be added to the HTTP request, either via the `Cookies` map or the `Cookie()` function\n- Function `GetWithClient()` provides the ability to send the request with a custom HTTP client\n- Function `FindStrict()` finds the first instance of the mentioned tag with the exact matching values of the provided attribute (previously `Find()`)\n- Function `FindAllStrict()` finds all the instances of the mentioned tag with the exact matching values of the attributes (previously `FindAll()`)\n\n## Changed\n\n- Function `Find()` now finds the first instance of the mentioned tag with any matching values of the provided attribute.\n- Function `FindAll()` now finds all the instances of the mentioned tag with any matching values of the provided attribute.\n\n---\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.6953125,
          "content": "# soup\n[![Build Status](https://travis-ci.org/anaskhan96/soup.svg?branch=master)](https://travis-ci.org/anaskhan96/soup)\n[![GoDoc](https://godoc.org/github.com/anaskhan96/soup?status.svg)](https://pkg.go.dev/github.com/anaskhan96/soup)\n[![Go Report Card](https://goreportcard.com/badge/github.com/anaskhan96/soup)](https://goreportcard.com/report/github.com/anaskhan96/soup)\n\n**Web Scraper in Go, similar to BeautifulSoup**\n\n*soup* is a small web scraper package for Go, with its interface highly similar to that of BeautifulSoup.\n\nExported variables and functions implemented till now :\n```go\nvar Headers map[string]string // Set headers as a map of key-value pairs, an alternative to calling Header() individually\nvar Cookies map[string]string // Set cookies as a map of key-value  pairs, an alternative to calling Cookie() individually\nfunc Get(string) (string,error) {} // Takes the url as an argument, returns HTML string\nfunc GetWithClient(string, *http.Client) {} // Takes the url and a custom HTTP client as arguments, returns HTML string\nfunc Post(string, string, interface{}) (string, error) {} // Takes the url, bodyType, and payload as an argument, returns HTML string\nfunc PostForm(string, url.Values) {} // Takes the url and body. bodyType is set to \"application/x-www-form-urlencoded\"\nfunc Header(string, string) {} // Takes key,value pair to set as headers for the HTTP request made in Get()\nfunc Cookie(string, string) {} // Takes key, value pair to set as cookies to be sent with the HTTP request in Get()\nfunc HTMLParse(string) Root {} // Takes the HTML string as an argument, returns a pointer to the DOM constructed\nfunc Find([]string) Root {} // Element tag,(attribute key-value pair) as argument, pointer to first occurence returned\nfunc FindAll([]string) []Root {} // Same as Find(), but pointers to all occurrences returned\nfunc FindStrict([]string) Root {} //  Element tag,(attribute key-value pair) as argument, pointer to first occurence returned with exact matching values\nfunc FindAllStrict([]string) []Root {} // Same as FindStrict(), but pointers to all occurrences returned\nfunc FindNextSibling() Root {} // Pointer to the next sibling of the Element in the DOM returned\nfunc FindNextElementSibling() Root {} // Pointer to the next element sibling of the Element in the DOM returned\nfunc FindPrevSibling() Root {} // Pointer to the previous sibling of the Element in the DOM returned\nfunc FindPrevElementSibling() Root {} // Pointer to the previous element sibling of the Element in the DOM returned\nfunc Children() []Root {} // Find all direct children of this DOM element\nfunc Attrs() map[string]string {} // Map returned with all the attributes of the Element as lookup to their respective values\nfunc Text() string {} // Full text inside a non-nested tag returned, first half returned in a nested one\nfunc FullText() string {} // Full text inside a nested/non-nested tag returned\nfunc SetDebug(bool) {} // Sets the debug mode to true or false; false by default\nfunc HTML() {} // HTML returns the HTML code for the specific element\n```\n\n`Root` is a struct, containing three fields :\n* `Pointer` containing the pointer to the current html node\n* `NodeValue` containing the current html node's value, i.e. the tag name for an ElementNode, or the text in case of a TextNode\n* `Error` containing an error in a struct if one occurrs, else `nil` is returned. \nA detailed text explaination of the error can be accessed using the `Error()` function. A field `Type` in this struct of type `ErrorType` will denote the kind of error that took place, which will consist of either of the following\n\t* `ErrUnableToParse`\n\t* `ErrElementNotFound`\n\t* `ErrNoNextSibling`\n\t* `ErrNoPreviousSibling`\n\t* `ErrNoNextElementSibling`\n\t* `ErrNoPreviousElementSibling`\n\t* `ErrCreatingGetRequest`\n\t* `ErrInGetRequest`\n\t* `ErrReadingResponse`\n\n## Installation\nInstall the package using the command\n```bash\ngo get github.com/anaskhan96/soup\n```\n\n## Example\nAn example code is given below to scrape the \"Comics I Enjoy\" part (text and its links) from [xkcd](https://xkcd.com).\n\n[More Examples](https://github.com/anaskhan96/soup/tree/master/examples)\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/anaskhan96/soup\"\n\t\"os\"\n)\n\nfunc main() {\n\tresp, err := soup.Get(\"https://xkcd.com\")\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n\tdoc := soup.HTMLParse(resp)\n\tlinks := doc.Find(\"div\", \"id\", \"comicLinks\").FindAll(\"a\")\n\tfor _, link := range links {\n\t\tfmt.Println(link.Text(), \"| Link :\", link.Attrs()[\"href\"])\n\t}\n}\n```\n\n## Contributions\nThis package was developed in my free time. However, contributions from everybody in the community are welcome, to make it a better web scraper. If you think there should be a particular feature or function included in the package, feel free to open up a new issue or pull request.\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1416015625,
          "content": "module github.com/anaskhan96/soup\n\ngo 1.13\n\nrequire (\n\tgithub.com/stretchr/testify v1.6.1\n\tgolang.org/x/net v0.0.0-20200114155413-6afb5195e5aa\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.54296875,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0 h1:4G4v2dO3VZwixGIRoQ5Lfboy6nUhCyYzaqnIAPPhYs4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.6.1 h1:hDPOHmpOpP40lSULcqw7IrRb/u7w6RpDC9399XyoNd0=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/net v0.0.0-20200114155413-6afb5195e5aa h1:F+8P+gmewFQYRk6JoLQLwjBCTu3mcIURZfNkVweuRKA=\ngolang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "license",
          "type": "blob",
          "size": 1.041015625,
          "content": "MIT License\n\nCopyright (c) 2017 Anas Khan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "soup.go",
          "type": "blob",
          "size": 16.28515625,
          "content": "/* soup package implements a simple web scraper for Go,\nkeeping it as similar as possible to BeautifulSoup\n*/\n\npackage soup\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\tnetURL \"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"golang.org/x/net/html\"\n\t\"golang.org/x/net/html/charset\"\n)\n\n// ErrorType defines types of errors that are possible from soup\ntype ErrorType int\n\nconst (\n\t// ErrUnableToParse will be returned when the HTML could not be parsed\n\tErrUnableToParse ErrorType = iota\n\t// ErrElementNotFound will be returned when element was not found\n\tErrElementNotFound\n\t// ErrNoNextSibling will be returned when no next sibling can be found\n\tErrNoNextSibling\n\t// ErrNoPreviousSibling will be returned when no previous sibling can be found\n\tErrNoPreviousSibling\n\t// ErrNoNextElementSibling will be returned when no next element sibling can be found\n\tErrNoNextElementSibling\n\t// ErrNoPreviousElementSibling will be returned when no previous element sibling can be found\n\tErrNoPreviousElementSibling\n\t// ErrCreatingGetRequest will be returned when the get request couldn't be created\n\tErrCreatingGetRequest\n\t// ErrInGetRequest will be returned when there was an error during the get request\n\tErrInGetRequest\n\t// ErrCreatingPostRequest will be returned when the post request couldn't be created\n\tErrCreatingPostRequest\n\t// ErrMarshallingPostRequest will be returned when the body of a post request couldn't be serialized\n\tErrMarshallingPostRequest\n\t// ErrReadingResponse will be returned if there was an error reading the response to our get request\n\tErrReadingResponse\n)\n\n// Error allows easier introspection on the type of error returned.\n// If you know you have a Error, you can compare the Type to one of the exported types\n// from this package to see what kind of error it is, then further inspect the Error() method\n// to see if it has more specific details for you, like in the case of a ErrElementNotFound\n// type of error.\ntype Error struct {\n\tType ErrorType\n\tmsg  string\n}\n\nfunc (se Error) Error() string {\n\treturn se.msg\n}\n\nfunc newError(t ErrorType, msg string) Error {\n\treturn Error{Type: t, msg: msg}\n}\n\n// Root is a structure containing a pointer to an html node, the node value, and an error variable to return an error if one occurred\ntype Root struct {\n\tPointer   *html.Node\n\tNodeValue string\n\tError     error\n}\n\n// Init a new HTTP client for use when the client doesn't want to use their own.\nvar (\n\tdefaultClient = &http.Client{}\n\n\tdebug = false\n\n\t// Headers contains all HTTP headers to send\n\tHeaders = make(map[string]string)\n\n\t// Cookies contains all HTTP cookies to send\n\tCookies = make(map[string]string)\n)\n\n// SetDebug sets the debug status\n// Setting this to true causes the panics to be thrown and logged onto the console.\n// Setting this to false causes the errors to be saved in the Error field in the returned struct.\nfunc SetDebug(d bool) {\n\tdebug = d\n}\n\n// Header sets a new HTTP header\nfunc Header(n string, v string) {\n\tHeaders[n] = v\n}\n\n// Cookie sets a cookie for http requests\nfunc Cookie(n string, v string) {\n\tCookies[n] = v\n}\n\n// GetWithClient returns the HTML returned by the url using a provided HTTP client\nfunc GetWithClient(url string, client *http.Client) (string, error) {\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tif debug {\n\t\t\tpanic(\"Couldn't create GET request to \" + url)\n\t\t}\n\t\treturn \"\", newError(ErrCreatingGetRequest, \"error creating get request to \"+url)\n\t}\n\n\tsetHeadersAndCookies(req)\n\n\t// Perform request\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tif debug {\n\t\t\tpanic(\"Couldn't perform GET request to \" + url)\n\t\t}\n\t\treturn \"\", newError(ErrInGetRequest, \"couldn't perform GET request to \"+url)\n\t}\n\tdefer resp.Body.Close()\n\tutf8Body, err := charset.NewReader(resp.Body, resp.Header.Get(\"Content-Type\"))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tbytes, err := ioutil.ReadAll(utf8Body)\n\tif err != nil {\n\t\tif debug {\n\t\t\tpanic(\"Unable to read the response body\")\n\t\t}\n\t\treturn \"\", newError(ErrReadingResponse, \"unable to read the response body\")\n\t}\n\treturn string(bytes), nil\n}\n\n// setHeadersAndCookies helps build a request\nfunc setHeadersAndCookies(req *http.Request) {\n\t// Set headers\n\tfor hName, hValue := range Headers {\n\t\treq.Header.Set(hName, hValue)\n\t}\n\t// Set cookies\n\tfor cName, cValue := range Cookies {\n\t\treq.AddCookie(&http.Cookie{\n\t\t\tName:  cName,\n\t\t\tValue: cValue,\n\t\t})\n\t}\n}\n\n// getBodyReader serializes the body for a network request. See the test file for examples\nfunc getBodyReader(rawBody interface{}) (io.Reader, error) {\n\tvar bodyReader io.Reader\n\n\tif rawBody != nil {\n\t\tswitch body := rawBody.(type) {\n\t\tcase map[string]string:\n\t\t\tjsonBody, err := json.Marshal(body)\n\t\t\tif err != nil {\n\t\t\t\tif debug {\n\t\t\t\t\tpanic(\"Unable to read the response body\")\n\t\t\t\t}\n\t\t\t\treturn nil, newError(ErrMarshallingPostRequest, \"couldn't serialize map of strings to JSON.\")\n\t\t\t}\n\t\t\tbodyReader = bytes.NewBuffer(jsonBody)\n\t\tcase netURL.Values:\n\t\t\tbodyReader = strings.NewReader(body.Encode())\n\t\tcase []byte: //expects JSON format\n\t\t\tbodyReader = bytes.NewBuffer(body)\n\t\tcase string: //expects JSON format\n\t\t\tbodyReader = strings.NewReader(body)\n\t\tdefault:\n\t\t\treturn nil, newError(ErrMarshallingPostRequest, fmt.Sprintf(\"Cannot handle body type %T\", rawBody))\n\t\t}\n\t}\n\n\treturn bodyReader, nil\n}\n\n// PostWithClient returns the HTML returned by the url using a provided HTTP client\n// The type of the body must conform to one of the types listed in func getBodyReader()\nfunc PostWithClient(url string, bodyType string, body interface{}, client *http.Client) (string, error) {\n\tbodyReader, err := getBodyReader(body)\n\tif err != nil {\n\t\treturn \"todo:\", err\n\t}\n\n\treq, _ := http.NewRequest(\"POST\", url, bodyReader)\n\tHeader(\"Content-Type\", bodyType)\n\tsetHeadersAndCookies(req)\n\n\tif debug {\n\t\t// Save a copy of this request for debugging.\n\t\trequestDump, err := httputil.DumpRequest(req, true)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t}\n\t\tfmt.Println(string(requestDump))\n\t}\n\n\t// Perform request\n\tresp, err := client.Do(req)\n\n\tif err != nil {\n\t\tif debug {\n\t\t\tpanic(\"Couldn't perform POST request to \" + url)\n\t\t}\n\t\treturn \"\", newError(ErrCreatingPostRequest, \"couldn't perform POST request to \"+url)\n\t}\n\tdefer resp.Body.Close()\n\tbytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tif debug {\n\t\t\tpanic(\"Unable to read the response body\")\n\t\t}\n\t\treturn \"\", newError(ErrReadingResponse, \"unable to read the response body\")\n\t}\n\treturn string(bytes), nil\n}\n\n// Post returns the HTML returned by the url as a string using the default HTTP client\nfunc Post(url string, bodyType string, body interface{}) (string, error) {\n\treturn PostWithClient(url, bodyType, body, defaultClient)\n}\n\n// PostForm is a convenience method for POST requests that\nfunc PostForm(url string, data url.Values) (string, error) {\n\treturn PostWithClient(url, \"application/x-www-form-urlencoded\", data, defaultClient)\n}\n\n// Get returns the HTML returned by the url as a string using the default HTTP client\nfunc Get(url string) (string, error) {\n\treturn GetWithClient(url, defaultClient)\n}\n\n// HTMLParse parses the HTML returning a start pointer to the DOM\nfunc HTMLParse(s string) Root {\n\tr, err := html.Parse(strings.NewReader(s))\n\tif err != nil {\n\t\tif debug {\n\t\t\tpanic(\"Unable to parse the HTML\")\n\t\t}\n\t\treturn Root{Error: newError(ErrUnableToParse, \"unable to parse the HTML\")}\n\t}\n\tfor r.Type != html.ElementNode {\n\t\tswitch r.Type {\n\t\tcase html.DocumentNode:\n\t\t\tr = r.FirstChild\n\t\tcase html.DoctypeNode:\n\t\t\tr = r.NextSibling\n\t\tcase html.CommentNode:\n\t\t\tr = r.NextSibling\n\t\t}\n\t}\n\treturn Root{Pointer: r, NodeValue: r.Data}\n}\n\n// Find finds the first occurrence of the given tag name,\n// with or without attribute key and value specified,\n// and returns a struct with a pointer to it\nfunc (r Root) Find(args ...string) Root {\n\ttemp, ok := findOnce(r.Pointer, args, false, false)\n\tif ok == false {\n\t\tif debug {\n\t\t\tpanic(\"Element `\" + args[0] + \"` with attributes `\" + strings.Join(args[1:], \" \") + \"` not found\")\n\t\t}\n\t\treturn Root{Error: newError(ErrElementNotFound, fmt.Sprintf(\"element `%s` with attributes `%s` not found\", args[0], strings.Join(args[1:], \" \")))}\n\t}\n\treturn Root{Pointer: temp, NodeValue: temp.Data}\n}\n\n// FindAll finds all occurrences of the given tag name,\n// with or without key and value specified,\n// and returns an array of structs, each having\n// the respective pointers\nfunc (r Root) FindAll(args ...string) []Root {\n\ttemp := findAllofem(r.Pointer, args, false)\n\tif len(temp) == 0 {\n\t\tif debug {\n\t\t\tpanic(\"Element `\" + args[0] + \"` with attributes `\" + strings.Join(args[1:], \" \") + \"` not found\")\n\t\t}\n\t\treturn []Root{}\n\t}\n\tpointers := make([]Root, 0, len(temp))\n\tfor i := 0; i < len(temp); i++ {\n\t\tpointers = append(pointers, Root{Pointer: temp[i], NodeValue: temp[i].Data})\n\t}\n\treturn pointers\n}\n\n// FindStrict finds the first occurrence of the given tag name\n// only if all the values of the provided attribute are an exact match\nfunc (r Root) FindStrict(args ...string) Root {\n\ttemp, ok := findOnce(r.Pointer, args, false, true)\n\tif ok == false {\n\t\tif debug {\n\t\t\tpanic(\"Element `\" + args[0] + \"` with attributes `\" + strings.Join(args[1:], \" \") + \"` not found\")\n\t\t}\n\t\treturn Root{nil, \"\", newError(ErrElementNotFound, fmt.Sprintf(\"element `%s` with attributes `%s` not found\", args[0], strings.Join(args[1:], \" \")))}\n\t}\n\treturn Root{Pointer: temp, NodeValue: temp.Data}\n}\n\n// FindAllStrict finds all occurrences of the given tag name\n// only if all the values of the provided attribute are an exact match\nfunc (r Root) FindAllStrict(args ...string) []Root {\n\ttemp := findAllofem(r.Pointer, args, true)\n\tif len(temp) == 0 {\n\t\tif debug {\n\t\t\tpanic(\"Element `\" + args[0] + \"` with attributes `\" + strings.Join(args[1:], \" \") + \"` not found\")\n\t\t}\n\t\treturn []Root{}\n\t}\n\tpointers := make([]Root, 0, len(temp))\n\tfor i := 0; i < len(temp); i++ {\n\t\tpointers = append(pointers, Root{Pointer: temp[i], NodeValue: temp[i].Data})\n\t}\n\treturn pointers\n}\n\n// FindNextSibling finds the next sibling of the pointer in the DOM\n// returning a struct with a pointer to it\nfunc (r Root) FindNextSibling() Root {\n\tnextSibling := r.Pointer.NextSibling\n\tif nextSibling == nil {\n\t\tif debug {\n\t\t\tpanic(\"No next sibling found\")\n\t\t}\n\t\treturn Root{Error: newError(ErrNoNextSibling, \"no next sibling found\")}\n\t}\n\treturn Root{Pointer: nextSibling, NodeValue: nextSibling.Data}\n}\n\n// FindPrevSibling finds the previous sibling of the pointer in the DOM\n// returning a struct with a pointer to it\nfunc (r Root) FindPrevSibling() Root {\n\tprevSibling := r.Pointer.PrevSibling\n\tif prevSibling == nil {\n\t\tif debug {\n\t\t\tpanic(\"No previous sibling found\")\n\t\t}\n\n\t\treturn Root{Error: newError(ErrNoPreviousSibling, \"no previous sibling found\")}\n\t}\n\treturn Root{Pointer: prevSibling, NodeValue: prevSibling.Data}\n}\n\n// FindNextElementSibling finds the next element sibling of the pointer in the DOM\n// returning a struct with a pointer to it\nfunc (r Root) FindNextElementSibling() Root {\n\tnextSibling := r.Pointer.NextSibling\n\tif nextSibling == nil {\n\t\tif debug {\n\t\t\tpanic(\"No next element sibling found\")\n\t\t}\n\t\treturn Root{Error: newError(ErrNoNextElementSibling, \"no next element sibling found\")}\n\t}\n\tif nextSibling.Type == html.ElementNode {\n\t\treturn Root{Pointer: nextSibling, NodeValue: nextSibling.Data}\n\t}\n\tp := Root{Pointer: nextSibling, NodeValue: nextSibling.Data}\n\treturn p.FindNextElementSibling()\n}\n\n// FindPrevElementSibling finds the previous element sibling of the pointer in the DOM\n// returning a struct with a pointer to it\nfunc (r Root) FindPrevElementSibling() Root {\n\tprevSibling := r.Pointer.PrevSibling\n\tif prevSibling == nil {\n\t\tif debug {\n\t\t\tpanic(\"No previous element sibling found\")\n\t\t}\n\t\treturn Root{Error: newError(ErrNoPreviousElementSibling, \"no previous element sibling found\")}\n\t}\n\tif prevSibling.Type == html.ElementNode {\n\t\treturn Root{Pointer: prevSibling, NodeValue: prevSibling.Data}\n\t}\n\tp := Root{Pointer: prevSibling, NodeValue: prevSibling.Data}\n\treturn p.FindPrevElementSibling()\n}\n\n// Children returns all direct children of this DOME element.\nfunc (r Root) Children() []Root {\n\tchild := r.Pointer.FirstChild\n\tvar children []Root\n\tfor child != nil {\n\t\tchildren = append(children, Root{Pointer: child, NodeValue: child.Data})\n\t\tchild = child.NextSibling\n\t}\n\treturn children\n}\n\n// Attrs returns a map containing all attributes\nfunc (r Root) Attrs() map[string]string {\n\tif r.Pointer.Type != html.ElementNode {\n\t\tif debug {\n\t\t\tpanic(\"Not an ElementNode\")\n\t\t}\n\t\treturn nil\n\t}\n\tif len(r.Pointer.Attr) == 0 {\n\t\treturn nil\n\t}\n\treturn getKeyValue(r.Pointer.Attr)\n}\n\n// Text returns the string inside a non-nested element\nfunc (r Root) Text() string {\n\tk := r.Pointer.FirstChild\ncheckNode:\n\tif k != nil && k.Type != html.TextNode {\n\t\tk = k.NextSibling\n\t\tif k == nil {\n\t\t\tif debug {\n\t\t\t\tpanic(\"No text node found\")\n\t\t\t}\n\t\t\treturn \"\"\n\t\t}\n\t\tgoto checkNode\n\t}\n\tif k != nil {\n\t\tr, _ := regexp.Compile(`^\\s+$`)\n\t\tif ok := r.MatchString(k.Data); ok {\n\t\t\tk = k.NextSibling\n\t\t\tif k == nil {\n\t\t\t\tif debug {\n\t\t\t\t\tpanic(\"No text node found\")\n\t\t\t\t}\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\tgoto checkNode\n\t\t}\n\t\treturn k.Data\n\t}\n\treturn \"\"\n}\n\n// HTML returns the HTML code for the specific element\nfunc (r Root) HTML() string {\n\tvar buf bytes.Buffer\n\tif err := html.Render(&buf, r.Pointer); err != nil {\n\t\treturn \"\"\n\t}\n\treturn buf.String()\n}\n\n// FullText returns the string inside even a nested element\nfunc (r Root) FullText() string {\n\tvar buf bytes.Buffer\n\n\tvar f func(*html.Node)\n\tf = func(n *html.Node) {\n\t\tif n == nil {\n\t\t\treturn\n\t\t}\n\t\tif n.Type == html.TextNode {\n\t\t\tbuf.WriteString(n.Data)\n\t\t}\n\t\tif n.Type == html.ElementNode {\n\t\t\tf(n.FirstChild)\n\t\t}\n\t\tif n.NextSibling != nil {\n\t\t\tf(n.NextSibling)\n\t\t}\n\t}\n\n\tf(r.Pointer.FirstChild)\n\n\treturn buf.String()\n}\n\nfunc matchElementName(n *html.Node, name string) bool {\n\treturn name == \"\" || name == n.Data\n}\n\n// Using depth first search to find the first occurrence and return\nfunc findOnce(n *html.Node, args []string, uni bool, strict bool) (*html.Node, bool) {\n\tif uni == true {\n\t\tif n.Type == html.ElementNode && matchElementName(n, args[0]) {\n\t\t\tif len(args) > 1 && len(args) < 4 {\n\t\t\t\tfor i := 0; i < len(n.Attr); i++ {\n\t\t\t\t\tattr := n.Attr[i]\n\t\t\t\t\tsearchAttrName := args[1]\n\t\t\t\t\tsearchAttrVal := args[2]\n\t\t\t\t\tif (strict && attributeAndValueEquals(attr, searchAttrName, searchAttrVal)) ||\n\t\t\t\t\t\t(!strict && attributeContainsValue(attr, searchAttrName, searchAttrVal)) {\n\t\t\t\t\t\treturn n, true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if len(args) == 1 {\n\t\t\t\treturn n, true\n\t\t\t}\n\t\t}\n\t}\n\tuni = true\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\tp, q := findOnce(c, args, true, strict)\n\t\tif q != false {\n\t\t\treturn p, q\n\t\t}\n\t}\n\treturn nil, false\n}\n\n// Using depth first search to find all occurrences and return\nfunc findAllofem(n *html.Node, args []string, strict bool) []*html.Node {\n\tvar nodeLinks = make([]*html.Node, 0, 10)\n\tvar f func(*html.Node, []string, bool)\n\tf = func(n *html.Node, args []string, uni bool) {\n\t\tif uni == true {\n\t\t\tif n.Type == html.ElementNode && matchElementName(n, args[0]) {\n\t\t\t\tif len(args) > 1 && len(args) < 4 {\n\t\t\t\t\tfor i := 0; i < len(n.Attr); i++ {\n\t\t\t\t\t\tattr := n.Attr[i]\n\t\t\t\t\t\tsearchAttrName := args[1]\n\t\t\t\t\t\tsearchAttrVal := args[2]\n\t\t\t\t\t\tif (strict && attributeAndValueEquals(attr, searchAttrName, searchAttrVal)) ||\n\t\t\t\t\t\t\t(!strict && attributeContainsValue(attr, searchAttrName, searchAttrVal)) {\n\t\t\t\t\t\t\tnodeLinks = append(nodeLinks, n)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if len(args) == 1 {\n\t\t\t\t\tnodeLinks = append(nodeLinks, n)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tuni = true\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\tf(c, args, true)\n\t\t}\n\t}\n\tf(n, args, false)\n\treturn nodeLinks\n}\n\n// attributeAndValueEquals reports when the html.Attribute attr has the same attribute name and value as from\n// provided arguments\nfunc attributeAndValueEquals(attr html.Attribute, attribute, value string) bool {\n\treturn attr.Key == attribute && attr.Val == value\n}\n\n// attributeContainsValue reports when the html.Attribute attr has the same attribute name as from provided\n// attribute argument and compares if it has the same value in its values parameter\nfunc attributeContainsValue(attr html.Attribute, attribute, value string) bool {\n\tif attr.Key == attribute {\n\t\tfor _, attrVal := range strings.Fields(attr.Val) {\n\t\t\tif attrVal == value {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// Returns a key pair value (like a dictionary) for each attribute\nfunc getKeyValue(attributes []html.Attribute) map[string]string {\n\tvar keyvalues = make(map[string]string)\n\tfor i := 0; i < len(attributes); i++ {\n\t\t_, exists := keyvalues[attributes[i].Key]\n\t\tif exists == false {\n\t\t\tkeyvalues[attributes[i].Key] = attributes[i].Val\n\t\t}\n\t}\n\treturn keyvalues\n}\n"
        },
        {
          "name": "soup_test.go",
          "type": "blob",
          "size": 7.919921875,
          "content": "package soup\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst testHTML = `\n<html>\n  <head>\n    <title>Sample \"Hello, World\" Application</title>\n  </head>\n  <body bgcolor=white>\n\n    <table border=\"0\" cellpadding=\"10\">\n      <tr>\n        <td>\n          <img src=\"images/springsource.png\">\n        </td>\n        <td>\n          <h1>Sample \"Hello, World\" Application</h1>\n        </td>\n      </tr>\n    </table>\n    <div id=\"0\">\n      <div id=\"1\">Just two divs peacing out</div>\n    </div>\n    check\n    <div id=\"2\">One more</div>\n    <p>This is the home page for the HelloWorld Web application. </p>\n    <p>To prove that they work, you can execute either of the following links:\n    <ul>\n      <li>To a <a href=\"hello.jsp\">JSP page</a> right?</li>\n      <li>To a <a href=\"hello\">servlet</a></li>\n    </ul>\n    </p>\n    <div id=\"3\">\n      <div id=\"4\">Last one</div>\n    </div>\n    <div id=\"5\">\n        <h1><span></span></h1>\n    </div>\n  </body>\n</html>\n`\n\nconst multipleClassesHTML = `\n<html>\n\t<head>\n\t\t<title>Sample Application</title>\n\t</head>\n\t<body>\n\t\t<div class=\"first second\">Multiple classes</div>\n\t\t<div class=\"first\">Single class</div>\n\t\t<div class=\"second first third\">Multiple classes inorder</div>\n\t\t<div>\n\t\t\t<div class=\"first\">Inner single class</div>\n\t\t\t<div class=\"first second\">Inner multiple classes</div>\n\t\t\t<div class=\"second first\">Inner multiple classes inorder</div>\n\t\t</div>\n\t</body>\n</html>\n`\n\nvar doc = HTMLParse(testHTML)\nvar multipleClasses = HTMLParse(multipleClassesHTML)\n\nfunc TestFind(t *testing.T) {\n\t// Find() and Attrs()\n\tactual := doc.Find(\"img\").Attrs()[\"src\"]\n\tassert.Equal(t, \"images/springsource.png\", actual)\n\t// Find(...) and Text()\n\tactual = doc.Find(\"a\", \"href\", \"hello\").Text()\n\tassert.Equal(t, \"servlet\", actual)\n\t// Nested Find()\n\tactual = doc.Find(\"div\").Find(\"div\").Text()\n\tassert.Equal(t, \"Just two divs peacing out\", actual)\n\t// Find(\"\") for any\n\tactual = multipleClasses.Find(\"body\").Find(\"\").Text()\n\tassert.Equal(t, \"Multiple classes\", actual)\n\t// Find(\"\") with attributes\n\tactual = doc.Find(\"\", \"id\", \"4\").Text()\n\tassert.Equal(t, \"Last one\", actual)\n}\n\nfunc TestFindNextPrevElement(t *testing.T) {\n\t// FindNextSibling() and NodeValue field\n\tactual := doc.Find(\"div\", \"id\", \"0\").FindNextSibling().NodeValue\n\tassert.Equal(t, \"check\", strings.TrimSpace(actual))\n\t// FindPrevSibling() and NodeValue field\n\tactual = doc.Find(\"div\", \"id\", \"2\").FindPrevSibling().NodeValue\n\tassert.Equal(t, \"check\", strings.TrimSpace(actual))\n\t// FindNextElementSibling() and NodeValue field\n\tactual = doc.Find(\"table\").FindNextElementSibling().NodeValue\n\tassert.Equal(t, \"div\", strings.TrimSpace(actual))\n\t// FindPrevElementSibling() and NodeValue field\n\tactual = doc.Find(\"p\").FindPrevElementSibling().NodeValue\n\tassert.Equal(t, \"div\", strings.TrimSpace(actual))\n}\n\nfunc TestFindAll(t *testing.T) {\n\t// FindAll() and Attrs()\n\tallDivs := doc.FindAll(\"div\")\n\tfor i := 0; i < len(allDivs); i++ {\n\t\tid := allDivs[i].Attrs()[\"id\"]\n\t\tactual, _ := strconv.Atoi(id)\n\t\tassert.Equal(t, i, actual)\n\t}\n}\n\nfunc TestFindAllBySingleClass(t *testing.T) {\n\tactual := multipleClasses.FindAll(\"div\", \"class\", \"first\")\n\tassert.Equal(t, 6, len(actual))\n\tactual = multipleClasses.FindAll(\"div\", \"class\", \"third\")\n\tassert.Equal(t, 1, len(actual))\n}\n\nfunc TestFindAllByAttribute(t *testing.T) {\n\tactual := doc.FindAll(\"\", \"id\", \"2\")\n\tassert.Equal(t, 1, len(actual))\n}\n\nfunc TestFindBySingleClass(t *testing.T) {\n\tactual := multipleClasses.Find(\"div\", \"class\", \"first\")\n\tassert.Equal(t, \"Multiple classes\", actual.Text())\n\tactual = multipleClasses.Find(\"div\", \"class\", \"third\")\n\tassert.Equal(t, \"Multiple classes inorder\", actual.Text())\n}\n\nfunc TestFindAllStrict(t *testing.T) {\n\tactual := multipleClasses.FindAllStrict(\"div\", \"class\", \"first second\")\n\tassert.Equal(t, 2, len(actual))\n\tactual = multipleClasses.FindAllStrict(\"div\", \"class\", \"first third second\")\n\tassert.Equal(t, 0, len(actual))\n\tactual = multipleClasses.FindAllStrict(\"div\", \"class\", \"second first third\")\n\tassert.Equal(t, 1, len(actual))\n}\n\nfunc TestFindStrict(t *testing.T) {\n\tactual := multipleClasses.FindStrict(\"div\", \"class\", \"first\")\n\tassert.Equal(t, \"Single class\", actual.Text())\n\tactual = multipleClasses.FindStrict(\"div\", \"class\", \"third\")\n\tassert.NotNil(t, actual.Error)\n}\n\nfunc TestText(t *testing.T) {\n\t// <li>To a <a href=\"hello.jsp\">JSP page</a> right?</li>\n\tli := doc.Find(\"ul\").Find(\"li\")\n\tassert.Equal(t, \"To a \", li.Text())\n}\nfunc TestFullText(t *testing.T) {\n\t// <li>To a <a href=\"hello.jsp\">JSP page</a> right?</li>\n\tli := doc.Find(\"ul\").Find(\"li\")\n\tassert.Equal(t, \"To a JSP page right?\", li.FullText())\n}\n\nfunc TestFullTextEmpty(t *testing.T) {\n\t// <div id=\"5\"><h1><span></span></h1></div>\n\th1 := doc.Find(\"div\", \"id\", \"5\").Find(\"h1\")\n\tassert.Empty(t, h1.FullText())\n}\n\nfunc TestNewErrorReturnsInspectableError(t *testing.T) {\n\terr := newError(ErrElementNotFound, \"element not found\")\n\tassert.NotNil(t, err)\n\tassert.Equal(t, ErrElementNotFound, err.Type)\n\tassert.Equal(t, \"element not found\", err.Error())\n}\n\nfunc TestFindReturnsInspectableError(t *testing.T) {\n\tr := doc.Find(\"bogus\", \"thing\")\n\tassert.IsType(t, Error{}, r.Error)\n\tassert.Equal(t, \"element `bogus` with attributes `thing` not found\", r.Error.Error())\n\tassert.Equal(t, ErrElementNotFound, r.Error.(Error).Type)\n}\n\n// Similar test: https://github.com/hashicorp/go-retryablehttp/blob/master/client_test.go#L616\nfunc TestClient_Post(t *testing.T) {\n\t// Mock server which always responds 200.\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != \"POST\" {\n\t\t\tt.Fatalf(\"bad method: %s\", r.Method)\n\t\t}\n\t\tif r.RequestURI != \"/foo/bar\" {\n\t\t\tt.Fatalf(\"bad uri: %s\", r.RequestURI)\n\t\t}\n\t\tif ct := r.Header.Get(\"Content-Type\"); ct != \"application/json\" {\n\t\t\tt.Fatalf(\"bad content-type: %s\", ct)\n\t\t}\n\n\t\t// Check the payload\n\t\tbody, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %s\", err)\n\t\t}\n\t\texpected := []byte(`{\"hello\":\"world\"}`)\n\t\tif !bytes.Equal(body, expected) {\n\t\t\tt.Fatalf(\"bad: %v\", string(body))\n\t\t}\n\n\t\tw.WriteHeader(200)\n\t}))\n\tdefer ts.Close()\n\n\t// Make the request with JSON payload\n\t_, err := Post(\n\t\tts.URL+\"/foo/bar\", \"application/json\", `{\"hello\":\"world\"}`)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\t// Make the request with byte payload\n\t_, err = Post(\n\t\tts.URL+\"/foo/bar\", \"application/json\", []byte(`{\"hello\":\"world\"}`))\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\t// Make the request with string map payload\n\t_, err = Post(\n\t\tts.URL+\"/foo/bar\",\n\t\t\"application/json\",\n\t\tmap[string]string{\n\t\t\t\"hello\": \"world\",\n\t\t})\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n}\n\n// Similar test: https://github.com/hashicorp/go-retryablehttp/blob/add-circleci/client_test.go#L631\nfunc TestClient_PostForm(t *testing.T) {\n\t// Mock server which always responds 200.\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != \"POST\" {\n\t\t\tt.Fatalf(\"bad method: %s\", r.Method)\n\t\t}\n\t\tif r.RequestURI != \"/foo/bar\" {\n\t\t\tt.Fatalf(\"bad uri: %s\", r.RequestURI)\n\t\t}\n\t\tif ct := r.Header.Get(\"Content-Type\"); ct != \"application/x-www-form-urlencoded\" {\n\t\t\tt.Fatalf(\"bad content-type: %s\", ct)\n\t\t}\n\n\t\t// Check the payload\n\t\tbody, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %s\", err)\n\t\t}\n\t\texpected := []byte(`hello=world`)\n\t\tif !bytes.Equal(body, expected) {\n\t\t\tt.Fatalf(\"bad: %v\", string(body))\n\t\t}\n\n\t\tw.WriteHeader(200)\n\t}))\n\tdefer ts.Close()\n\n\t// Create the form data.\n\tform1, err := url.ParseQuery(\"hello=world\")\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tform2 := url.Values{\n\t\t\"hello\": []string{\"world\"},\n\t}\n\n\t// Make the request.\n\t_, err = PostForm(ts.URL+\"/foo/bar\", form1)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\t// Make the request.\n\t_, err = PostForm(ts.URL+\"/foo/bar\", form2)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n}\n\nfunc TestHTML(t *testing.T) {\n\tli := doc.Find(\"ul\").Find(\"li\")\n\tassert.Equal(t, \"<li>To a <a href=\\\"hello.jsp\\\">JSP page</a> right?</li>\", li.HTML())\n\n}\n"
        }
      ]
    }
  ]
}