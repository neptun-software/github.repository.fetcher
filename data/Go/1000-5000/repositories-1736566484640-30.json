{
  "metadata": {
    "timestamp": 1736566484640,
    "page": 30,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vugu/vugu",
      "stars": 4874,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.037109375,
          "content": "domrender/renderer-js-script.go -diff\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.26171875,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\ntodo-notes.txt\n.vscode\n*.code-workspace\n\n#examples/wip\nexamples/wip2\n\ntmp\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.662109375,
          "content": "language: go\ngo:\n  - 1.21.x\n\nos:\n  - linux\n\ndist: trusty\nsudo: false\n\ninstall: true\n\nenv:\n  - GO111MODULE=on\n\nscript:\n  - go install ./cmd/vugugen\n  - go test .\n  - go test ./devutil\n  - go test ./distutil\n  - go test ./domrender\n  - go test ./gen\n  - go test ./js\n  - go test ./staticrender\n  - go test ./simplehttp\n  - go test ./vgform\n  - go test ./wasm-test-suite\n\nnotifications:\n  email: true\n\nbefore_install:\n  - go get golang.org/x/tools/cmd/goimports && go install golang.org/x/tools/cmd/goimports\n  - cd wasm-test-suite/docker && ./make-docker.sh\n  - docker run -d -t -p 9222:9222 -p 8846:8846 --name wasm-test-suite vugu/wasm-test-suite:latest\n\nservices:\n  - docker\n\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 17.6044921875,
          "content": "# Contributing\n\nPlease first discuss via GitHub issue the change you wish to make.\nAnd please follow the code of conduct outlined below during all interactions.\n\n## Developing on a Fork\n\nTo work on a copy of Vugu, the easiest way is to use the `replace` module directive as described in https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive\n\nThis way your forked or local copy of Vugu can correspond to the import path `github.com/vugu/vugu`.  Example:\n\n```bash\ngit checkout https://github.com/vugu/vugu # or, your forked copy\n```\n\nAnd now you can reference it from another project:\n\nsome-other-project/go.mod:\n```\nmodule some-other-project\n\n// point vugu imports at your local copy instead of public download\nreplace github.com/vugu/vugu => ../vugu\n```\n\n## Vugu Project Layout\n\nSome important subdirectories in the Vugu project are:\n* The top level (corresponding to `github.com/vugu/vugu` import path) has common things shared across the other packages.\n* `cmd` contains command-line executables, `vugugen` being the most commonly used.  Note that these command-line tools are generally small and just a thin wrapper around functionality from another package.\n* `devutil` has utilities specifically created to facility rapid development such as wrappers for each Go+Wasm compilation and an HTTP muxer more suitable for Vugu development than the default one from net/http.\n* `domrender` has the client-side code which synchronizes Vugu's virtual DOM tree with the browser's DOM.\n* `gen` has code generaiton logic used to convert .vugu files into .go source code.  Most of the implementation of `vugugen` is available here.\n* `js` has a wrapper around `syscall/js` which delegates to the default implementation in WebAssembly but in other environments allows compilation and functionality gracefully degrades.  Useful for writing code that needs to compile both in and outside Wasm environments without having to maintain two separate implementations via build tags just to include one reference to e.g. js.Value.\n* `wasm-test-suite` contains the wasm tests. These require the use of a dockerized nginx and dockerised headless chrome run. See Legacy Running Tests below\n* `legacy-wasm-test-suite` contains a test suite using Headless Chrome, see Legacy Running Tests below. \n* `magefiles` contains the Mage build script called `magefile.go`. This defines the top level targets. The other Go files contain the lower level functionality that the Magefile depend on. The `go.mod` and `go.sum` in this directory are related to `mage` and NOT to `vugu`.\n* `testing` contains a collection of packages used by the `wasm-test-suite` that simply the test cases.\n* The following folders are being deprecated and should be used with caution: \n  * `simplehttp` is an earlier attempt at development tooling use `devutil` instead.  `tinygo-dev` will be removed, the working parts have moved into `devutil`.\n\n\n## Building\n\n`vugu` now uses [mage](https://magefile.org/) to manage the build of the `vugu` tools - `vugugen`, `vugufmt` and `vgfrom`.\n[Mage](https://magefile.org/) is also used to manage the testing process.\n\n\n`vugugen` is the tool that combines your `*.vugu` files with your component `*.go` files before generating the final Go source files that\ncan then be compiled into a `wasm` binary by the Go Compiler.\n\nIf you don't have the `mage` tool installed the simplest way to install it is:\n\n```\ngit clone https://github.com/magefile/mage\ncd mage\ngo run bootstrap.go\n```\n\nYou must run `mage` from the module root of `vugu`, this is the directory where the top level `go.mod` exists.\n\nYou will also need the [`goimports`](https://pkg.go.dev/golang.org/x/tools/cmd/goimports) tool installed. It is very likely that you have this installed already, normally as part of an editor plugin. If not then the it can be installed with:\n\n```\ngo install golang.org/x/tools/cmd/goimports@latest\n```\n\nIn order to run the tests you will also need `docker` installed. If you don't have `docker` installed then follow the [docker install instructions](https://docs.docker.com/engine/install/#licensing).\n\n\n**You must have Go v1.22.3 as a minimum to build `vugu`. We require the for loop changes that were introduced in Go v1.22, and v1.22.3 was the lastest at the time writing.**\n\nThe `Magefile` is self documenting. To see all of the targets, execute:\n\n```\ncd /path/to/vugu\nmage -l\n```\n\nIn general you want to use the `all` target to build, lint and test everything. Its used like so:\n\n```\ncd /path/to/vugu\nmage all\n```\n\nor\n\n```\ncd /path/to/vugu\nmage -v all\n```\n\nAt the moment the `mage` build is still quite noisy, it will generate a significant amount output to the console even without the verbose `-v` option. This will be gradually reduce in future releases.\n\n### Building using Mage\n\nIf you only need to build the `vugugen` and `vugufmt` tools then building these is as simple as:\n\n```\ncd /path/to/vugu\nmage build\n```\n\nThis will build the `vugu` root module, and build and install the `vugugen` and `vugufmt` tools.\n\nIt won't run any of the test suites.\n\n## Running Unit Tests\n\nIf you just want to run the unit tests for `vugu` itself then that is simply:\n\n```\ncd /path/to/vugu\nmage test\n```\n\nThis won't however run amy of of the `wasm` tests.\n\n## Cleaning the autogenerated files\n\nRunning any of the `all`, `build`, `test`, `testWasm` or `testlegacyWasm` targets will generate a significant number of autogenerated files.\n\nThis should be cleaned before committing to the repository. This can be achieved with:\n\n```\ncd /path/to/vugu\nmage cleanAutoGeneratedFiles\n```\n\nThese files are only cleaned when a new build is started. They are left after building in case the build failed and the files need to be examined to determine the reason for the failure.\n\n## Running `wasm` tests\n\nThe `wasm` tests are more complex to execute. A simple `go test` won't work.\n\nThe `wasm` tests work like this. `vugu` will generate via the `vugugen` tool, that should be called via the `go generate` tooling a series of `*.go` files for each of the `*.vugu` files in the test. However the only way to validate that compiling the resulting Go files to `wasm` does what we expect is to serve the resulting `wasm` file via a web browser.\n\nThis however isn't enough, we also need to execute the `wasm` that is being served. For this we need a headless browser.\n\nTo validate the result of the execution of the `wasm` in a headless browser we need a standard Go test. This Go test uses the [`chronedp`](https://github.com/chromedp/chromedp) package to connect to the headless browser and examine the resulting HTML after the `wasm` file has executed in the headless browser.\n\nTo achieve this requires using `docker` and specifically it relies on `docker`'s networking capabilities.\n\nThe approach works like this:\n\nThere are two docker containers. One container runs `nginx` and serves the files in the `/wasm-test-suite` directory. The second container contains a headless chrome image, via `chromedp`.\n\nBoth of these containers are connected to a private `docker` network called `vugu-net`. The network provices communication as well as service loopkup/DNS resolution.\n\nThe test itself is a standard Go test. It first connects to the headless chrome instance running on `localhost:9222`, and then asks the headless chrome instance to connect to the `nginx` container.\n\nOnce the `nginx` instance (in the first docker container) has servered the `wasm` to the headless chrome browser (in the second docker container) the Go test can query the resulting state of the DOM via `chromedp` in the headless chrome (in the second container). It is this DOM querying that determines if the test passes of fails.\n\nThe good news is that `mage` hides all of this complexity.\n\nRunning the whole of the `wasm-test-suite` is as simple as:\n\n```\ncd /path/to/vugu\nmage testWasm\n```\n\nif you only want to run a single wasm test, useful if only one test is failing or you are developing a new test, that can be achieved with:\n\n```\ncd /path/to/vugu\nmage testSingleWasmTest <test-module-name>\n```\n\nFor example to run the test `test-002-click` which is located in the `wasm-test-suite/test-002-click` directory its as simple as:\n\n```\ncd /path/to/vugu\nmage testSingleWasmTest github.com/vugu/vugu/wasm-test-suite/test-002-click\n```\n\n*Note: At present all of the `wasm` tests are built with the standard Go compiler. The `mage` based build does not yet support building the test cases with the `tinygo` compiler suite. Using the `tinygo` compiler suite to built these tests will be added again at a future date.* \n\n## Running a `wasm` test manually\n\nIn order to debug a failing test it can often be helpful to see what is happening in a browser. The `mage` based build supports this quite naturally. Just execute:\n\n```\ncd /path/to/vugu\nmage startLocalNginx\n```\n\nand browse to a URL of the following format:\n\n```\nhttp://localhost:8888/<test-directory-name>\n```\n\nFor example to examine the test `test-001-simple` the URL would be:\n\n```\nhttp://localhost:8888/test-001-simple\n```\n\nUsing the `testSingleWasmTest` will rebuild the `wasm` for you, although it will also execute the presumably failing test.\n\n*We may add the ability to build, but not execute a single `wasm` test at a future date.*\n\nThe `startLocalNginx` target is safe, in that it can be called multiple times without calling the corresponding `stopLocalNginx` target. Any running `nginx` container will always be stopped before any new one is started.\n\n\n## Creating a new `wasm` test\n\nIf you need to create a new `wasm` test in the `wasm-test-suite` the process is fairly straight forward. The critical point is to base it on a working test case and to ideally follow the directory naming convention.\n\nFor example\n\n```\ncd /path/to/vugu\ncp -r ./wasm-test-suite/test-001-simple/ ./wasm-test-suite/test-NNN-objective\n\n```\n\nWhere `NNN` is a 3 digit number\n\nThe `cp` will copy everything in the directory including the critical local `.gitignore` file to the new tests directory. Please make sire the `.gitignore` is present to ensure that vugu generated files are not submitted to the repository.\n\nYou then need to edit the `./wasm-test-suite/test-NNN-objective/go.mod` to change the module name. ***This step is critical.***\n\nThe module name must be changed to match the test, so in this case the module name would be changed to `github.com/vugu/vugu/wasm-test-suite/test-NNN-objective`\n\nYou can then edit the `root.vugu`, `root.go` as needed to support the test case.\n\nThe Go test function itself should also be renamed to reflect the test, so in this case the test function in `main_test.go` should be renamed to `TestNNNObjective`\n\nThe test file `main_test.go` can then be edited as required to reflect the test new case. However the hostname used to connect to the `nginx` container ***must not*** be changed from `vugu-nginx`. The `nginx` container will already have been started with this hostname name by `mage` before this test is compiled.\n\nThe files `main_wasm.go` and `wasm_exec.js` should not be edited. Likewise the file `index.html.tmpl` should **not** be edited or renamed - the build process depends on the name remaining `index.html.tmpl`.\n\nAny local `index.html` file will be overwritten by the build process, so it can be removed as you wish. The local `.gitignore` file also ensures it is never committed to the repository.\n\nThe new test can then be run with the rest of the wasm test suite like this:\n\n```\ncd /path/to/vugu\nmage testWasm\n```\n\nOr individually like this:\n\n```\ncd /path/to/vugu\nmage testSingleWasmTest github.com/vugu/vugu/wasm-test-suite/test-xxx-objective\n```\n\n## Running the `legacy-wasm-test-suite`\n\nThe `legacy-wasm-test-suite` uses an entirely different approach to building and testing.\n\nFirst an external script `run-wasm-test-suite-docker.sh` launches a docker container with headless chrome and a small server\n\nSecondly a standard Go test function i.e. a function named `TestXxx`, runs `vugugen`, builds the `wasm` binary, builds the test, copys the resulting `wasm` binary into the directory that is being served by the web server. \n\nThe standard Go test then queries the DOM to determine of the actions taken by the `wasm` binary are correct.\n\nThese tests are built twice. Once using the standard Go compiler and once with the `tinygo` compiler suite, The later is considerably slower. The legacy test suite can therefor take as much as 35 minutes to execute. There is no way to only build for one compiler or the other.\n\n*These tests have been compaltely replaced by teh more flexible approach outlined above. We expect these tests to be removed entirely at some point.*\n\nIf you have to run these tests then that can be achieved using `mage` with:\n\n```\ncd /path/to/vugu\nmage testlegacyWasm\n```\n\nThis target is **not** run by default. It must be run explicitly or via the `allWithlegacyWasm` target.\n\nThe legacy test suite still supports running an individual test, however this does not use `mage`, rather it uses a shell script (not portable to Windows) and the `go test` command. \n\nTo execute a individual legacy wasm test in `legacy-wasm-test-suite`, `run-wasm-test-suite-docker.sh` can be used to launch a docker container with Headless Chrome and a small server.  You can then use `go test` in `wasm-test-suite` to execute the various end-to-end tests available.\n\nThis requires Docker to be installed properly and the test suite expects to be able to connect the running docker instance on ports 8846 for web serving/upload and port 9222 to control headless chrome.\n\n## Vugu Documentation\n\nDocumention for Vugu, other than GoDoc (https://pkg.go.dev/github.com/vugu/vugu), lives on https://vugu.org.  The source for it is at https://github.com/vugu/vugu-site and you can submit PRs to that repository to propose changes.  For small improvements and errata it is fine to just submit a PR.  For more significant changes or if a discussion is required, please create a GitHub issue first\n\n## Submitting Pull Requests\n\nPlease make sure that any PRs:\n* Only include necessary modifications.  Avoid unnecessary changes such as reformatting code, renaming existing variables and the like unless previously discussed via issue.\n* Do not include files not intended for version control - .DS_Store, compiled binaries, debug output, etc.\n* Try hard to not break publicly exposed APIs.  The more likely a change is to cause breakage for other issues, the more vital prior discussion is.  Vugu is not yet 1.0 but compatibility is taken seriously nonetheless.\n* Introducing new publicly exposed APIs, as mentioned above, require discussion first.  Depending on the feature, it may be okay to introduce some things as a prototype, but in general before something gets merged into master, both you and the Vugu maintainers should be happy with the design.\n\n## Code of Conduct\n\n### Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, gender identity and expression, level of experience,\nnationality, personal appearance, race, religion, or sexual identity and\norientation.\n\n### Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\nadvances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n### Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n### Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n### Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at admin at vugu dot org. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n### Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0361328125,
          "content": "MIT License\n\nCopyright (c) 2019 vugu\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.5888671875,
          "content": "# Vugu\n\n[![Travis CI](https://travis-ci.org/vugu/vugu.svg?branch=master)](https://travis-ci.org/vugu/vugu)\n[![GoDoc](https://godoc.org/github.com/vugu/vugu?status.svg)](https://godoc.org/github.com/vugu/vugu)\n[![stability-experimental](https://img.shields.io/badge/stability-experimental-orange.svg)](https://github.com/emersion/stability-badges#experimental)\n<!-- [![Go Report Card](https://goreportcard.com/badge/github.com/vugu/vugu)](https://goreportcard.com/report/github.com/vugu/vugu) -->\n\nVugu is an experimental library for web UIs written in Go and targeting webassembly.  Guide and docs at https://www.vugu.org.\nGodoc at https://godoc.org/github.com/vugu/vugu.\n\nIf you've ever wanted to write a UI not in JS but pure Go... and run it in your browser, right now... That (experimental;) future is here!\n\nIntroducing Vugu (pronounced /ˈvuː.ɡuː/), a VueJS-inspired library in Go targeting wasm.\n\nNo node. No JS. No npm. No node_modules folder competing with your music library for disk space.\n\n## Updates ♨\n\n* 2024-05-25 Move to a [mage](https://magefile.org/) based build process\n<img src=\"https://cdnjs.cloudflare.com/ajax/libs/ionicons/4.5.6/collection/build/ionicons/svg/logo-slack.svg\" width=\"17\" height=\"17\"> Join the conversation: [Gophers on Slack](https://invite.slack.golangbridge.org/), channel #vugu\n\n## Highlights\n\n* Runs in-browser using WebAssembly\n* Single-file components\n* Vue-like markup syntax\n* Write idiomatic Go code\n* Rapid prototyping\n* ~3 minute setup\n* Standard Go build tools\n\n\n## Start\n\nGet started: http://www.vugu.org/doc/start\n\nStill a work in progress, but a lot of things are already functional. Some work really well.\n\n**You must have Go v1.22.3 as a minimum to use `vugu`. We require the for loop changes that were introduced in Go v1.22, and v1.22.3 was the lastest at the time writing.**\n\n\n## Building `vugu` for Contributors\n\n`vugu` now uses [mage](https://magefile.org/) to manage the build of the `vugu` tools - `vugugen`, `vugufmt` and `vgfrom`.\n[Mage](https://magefile.org/) is also used to manage the testing process.\n\nPlease see the updated build instruction in the [Contributors Guide](https://github.com/vugu/vugu/blob/master/CONTRIBUTING.md)\n\n\n## Running the examples\n\nTo run the examples you must have the [`mage`](https://magefile.org/) tool, `docker` and `goimports` installed. `vugu` uses `mage` to manage the build process.\n\nThe simplest way to install `mage` is:\n\n```\ngit clone https://github.com/magefile/mage\ncd mage\ngo run bootstrap.go\n```\n\nYou must run `mage` from the module root of `vugu`, this is the directory where the top level `go.mod` exists.\n\nYou will also need the [`goimports`](https://pkg.go.dev/golang.org/x/tools/cmd/goimports) tool installed. It is very likely that you have this installed already, normally as part of an editor plugin. If not then the it can be installed with:\n\n```\ngo install golang.org/x/tools/cmd/goimports@latest\n```\n\nIn order to run the examples you will also need `docker` installed. If you don't have `docker` installed then follow the [docker install instructions](https://docs.docker.com/engine/install/#licensing). Each example will be served by a local `nginx` container.\n\nAll of the examples are in the `examples` directory. Each sub-directory of `examples` contains a single example. Each example is it own Go module.\n\nBuilding and serving all of the examples is a simple as:\n\n```\ncd path/to/vugu\nmage examples\n```\n\nor\n\n```\ncd path/to/vugu\nmage -v examples\n```\n\nEach example will be served at a URL of the form\n\n```\nhttp://localhost:8888/<name-of-example-directory>\n```\n\nFor example to see the `fetch-and-display` example the URL would be:\n\n```\nhttp://localhost:8888/fetch-and-display\n```\n\nOr if you only want to run a single example use:\n\n```\ncd path/to/vugu\nmage singleExample <name-of-example-module>\n```\n\nFor example to serve just the `fetch-and-display` example the command would be:\n\n```\ncd path/to/vugu\nmage singleExample github.com/vugu/vugu/example/fetch-and-display\n```\n\n### Creating a new example\n\nIf you need to create a new example the process is fairly straight forward. The critical point is to base it on a working example.\n\nFor example\n\n```\ncd /path/to/vugu\ncp -r ./examples/fetch-and-display/ ./examples/my-new-example\n\n```\n\nThe `cp` will copy everything in the directory including the critical local `.gitignore` file to the new example directory. Please make sire the `.gitignore` is present to ensure that vugu generated files are not submitted to the repository.\n\nYou then need to edit the `./examples/my-new-example/go.mod` to change the module name. ***This step is critical.***\n\nThe module name must be changed to match the example, so in this case the module name would be changed to `github.com/vugu/vugu/examples/my-new-example`\n\nYou can then edit the `root.vugu`, `root.go` as needed to support the example, or add more `*.vugu` and `*.go` files as necessary.\n\nThe files `main_wasm.go` and `wasm_exec.js` should not be edited.\n\nThe examples `index.html` file will need to edited in two distinct places. The first is circa line 11\n\n```\n<script src=\"/fetch-and-display/wasm_exec.js\"></script>\n```\n\nTo change the path to reflect the name of the example. In this case:\n\n```\n<script src=\"/my-new-example/wasm_exec.js\"></script>\n```\n\n\nThe second change is similar but reflects the path of the `main.wasm` binary. This is circa line 29\n\n```\nWebAssembly.instantiateStreaming(fetch(\"/fetch-and-display/main.wasm\"), go.importObject).then((result) => {\n```\n\nwhich in this case would be changed to:\n\n```\nWebAssembly.instantiateStreaming(fetch(\"/my-new-example/main.wasm\"), go.importObject).then((result) => {\n```\n\nThe new example can then be built and served with:\n\n```\ncd /path/to/vugu\nmage examples\n```\n\nOr individually like this:\n\n```\ncd /path/to/vugu\nmage singleExample github.com/vugu/vugu/example/my-new-example\n```\n\n\n## Abbreviated Roadmap\n\n- [x] Move to a Mage based build\n- [x] Single-file components (looks similar to .vue); .vugu -> .go code generation.\n- [x] Includes CSS in components.\n- [x] Basic flow control with vg-if, vg-for and output with vg-content.\n- [x] Dynamic attributes with `<tag :prop='expr'>`.\n- [x] Nested components with dynamic properties\n- [x] Efficiently syncs to browser DOM.\n- [x] Static HTML output (great for tests).\n- [x] DOM Events, click, etc.\n- [x] Modification tracking to avoid unnecessary computation where possible.\n- [x] Basic dev and prod server tooling, easy to get started\n- [x] Rewrite everything so it is not so terrible internally\n- [x] URL Router (in-progress)\n- [x] Tinygo compilation support\n- [x] Server-side rendering (works, needs more documentation and examples)\n- [x] Go-only component events\n- [x] Slots\n- [ ] Component library(s) (wip!)\n- [ ] Performance optimizations\n- And much more...\n\n## Notes\n\nIt's built **more like a library than a framework**.  While Vugu does do code generation for your .vugu component\nfiles, (and will even output a default main_wasm.go for a new project and build your program automatically upon page refresh), \nfundamentally you are still in control.  Overall program flow, application wiring and initialization, the render loop\nthat keeps the page in sync with your components - you have control over all of that.\nFrameworks call your code.  Vugu is a library, your code calls it (even if Vugu generates a bit of that for you in\nthe beginning to make things easier). One of the primary goals for Vugu, when it comes to developers first encountering it, \nwas to make it very fast and easy to get started, but without imposing unnecessary limitations on how a project is structured.\nGo build tooling (and now the module system) is awesome.  The idea is to leverage that to the furthest extent possible,\nrather than reprogramming the wheel.\n\nSo you won't find a vugu command line tool that runs a development server, instead\nyou'll find in the docs an appropriate snippet of code you can paste in a file and `go run` yourself.  For the code\ngeneration while there is an http.Handler that can do this upon page refresh, you also can (and should!) run `vugugen`\nvia `go generate`. There are many small decisions in Vugu which follow this philosophy: wherever reasonably possible,\njust use the existing mechanism instead of inventing anew.  And keep doing that until there's proof that something\nelse is really needed.  So far it's been working well.  And it allows Vugu to focus on the specific things it \nbrings to the table.\n\n## Examples\n\nExamples of implementations can be found into [examples repositories](https://github.com/orgs/vugu-examples/repositories)\n\n## VSCode plugin\n\nAs most of your code will be in `.vugu` files, you will need to install [vscode-vugu](https://marketplace.visualstudio.com/items?itemName=binhonglee.vscode-vugu)\nCredits goes to @binhonglee."
        },
        {
          "name": "attribute-lister.go",
          "type": "blob",
          "size": 0.8359375,
          "content": "package vugu\n\n// VGAttributeLister implements the required functionality, required by the `:=` attribute setter.\n// Types may implement this interface, to\ntype VGAttributeLister interface {\n\tAttributeList() []VGAttribute\n}\n\n// The VGAttributeListerFunc type is an adapter to allow the use of functions as VGAttributeLister\ntype VGAttributeListerFunc func() []VGAttribute\n\n// AttributeList calls the underlying function\nfunc (f VGAttributeListerFunc) AttributeList() []VGAttribute {\n\treturn f()\n}\n\n// AttrMap implements VGAttributeLister as a map[string]interface{}\ntype AttrMap map[string]interface{}\n\n// AttributeList returns an attribute list corresponding to this map using the rules from VGNode.AddAttrInterface.\nfunc (m AttrMap) AttributeList() (ret []VGAttribute) {\n\tvar n VGNode\n\tfor k := range m {\n\t\tn.AddAttrInterface(k, m[k])\n\t}\n\treturn n.Attr\n}\n"
        },
        {
          "name": "build-env-default.go",
          "type": "blob",
          "size": 0.109375,
          "content": "package vugu\n\ntype buildCacheKey interface{}\n\nfunc makeBuildCacheKey(v interface{}) buildCacheKey {\n\treturn v\n}\n"
        },
        {
          "name": "build-env.go",
          "type": "blob",
          "size": 13.517578125,
          "content": "package vugu\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\n\t\"github.com/vugu/xxhash\"\n)\n\n// NewBuildEnv returns a newly initialized BuildEnv.\n// The eventEnv is used to implement lifecycle callbacks on components,\n// it's a vararg for now in order to avoid breaking earlier code but\n// it should be provided in all new code written.\nfunc NewBuildEnv(eventEnv ...EventEnv) (*BuildEnv, error) {\n\t// TODO: remove the ... and make it required and check for nil\n\tret := &BuildEnv{}\n\tfor _, ee := range eventEnv {\n\t\tret.eventEnv = ee\n\t}\n\treturn ret, nil\n}\n\n// BuildEnv is the environment used when building virtual DOM.\ntype BuildEnv struct {\n\n\t// wireFunc is called on each componen to inject stuff\n\twireFunc func(c Builder)\n\n\t// components in cache pool from prior build\n\tcompCache map[CompKey]Builder\n\n\t// components used so far in this build\n\tcompUsed map[CompKey]Builder\n\n\t// cache of build output by component from prior build pass\n\tbuildCache map[buildCacheKey]*BuildOut\n\n\t// new build output from this build pass (becomes buildCache next build pass)\n\tbuildResults map[buildCacheKey]*BuildOut\n\n\t// lifecycle callbacks need this and it needs to match what the renderer has\n\teventEnv EventEnv\n\n\t// track lifecycle callbacks\n\tcompStateMap map[Builder]compState\n\n\t// used to determine \"seen in this pass\"\n\tpassNum uint8\n}\n\n// BuildResults contains the BuildOut values for full tree of components built.\ntype BuildResults struct {\n\tOut *BuildOut\n\n\tallOut map[buildCacheKey]*BuildOut\n}\n\n// ResultFor is alias for indexing into AllOut.\nfunc (r *BuildResults) ResultFor(component interface{}) *BuildOut {\n\treturn r.allOut[makeBuildCacheKey(component)]\n}\n\n// RunBuild performs a bulid on a component, managing the lifecycles of nested components and related concerned.\n// In the map that is output, m[builder] will give the BuildOut for the component in question.  Child components\n// can likewise be indexed using the component (which should be a struct pointer) as the key.\n// Callers should not modify the return value as it is reused by subsequent calls.\nfunc (e *BuildEnv) RunBuild(builder Builder) *BuildResults {\n\n\tif e.compCache == nil {\n\t\te.compCache = make(map[CompKey]Builder)\n\t}\n\tif e.compUsed == nil {\n\t\te.compUsed = make(map[CompKey]Builder)\n\t}\n\n\t// clear old prior build pass's cache\n\tfor k := range e.compCache {\n\t\tdelete(e.compCache, k)\n\t}\n\n\t// swap cache and used, so the prior used is the new cache\n\te.compCache, e.compUsed = e.compUsed, e.compCache\n\n\tif e.buildCache == nil {\n\t\te.buildCache = make(map[buildCacheKey]*BuildOut)\n\t}\n\tif e.buildResults == nil {\n\t\te.buildResults = make(map[buildCacheKey]*BuildOut)\n\t}\n\n\t// clear old prior build pass's cache\n\tfor k := range e.buildCache {\n\t\tdelete(e.buildCache, k)\n\t}\n\n\t// swap cache and results, so the prior results is the new cache\n\te.buildCache, e.buildResults = e.buildResults, e.buildCache\n\n\te.passNum++\n\n\tif e.compStateMap == nil {\n\t\te.compStateMap = make(map[Builder]compState)\n\t}\n\n\tvar buildIn BuildIn\n\tbuildIn.BuildEnv = e\n\t// buildIn.PositionHashList starts empty\n\n\t// recursively build everything\n\te.buildOne(&buildIn, builder)\n\n\t// sanity check\n\tif len(buildIn.PositionHashList) != 0 {\n\t\tpanic(fmt.Errorf(\"unexpected PositionHashList len = %d\", len(buildIn.PositionHashList)))\n\t}\n\n\t// remove and invoke destroy on anything where passNum doesn't match\n\tfor k, st := range e.compStateMap {\n\t\tif st.passNum != e.passNum {\n\t\t\tinvokeDestroy(k, e.eventEnv)\n\t\t\tdelete(e.compStateMap, k)\n\t\t}\n\t}\n\n\treturn &BuildResults{allOut: e.buildResults, Out: e.buildResults[makeBuildCacheKey(builder)]}\n}\n\nfunc (e *BuildEnv) buildOne(buildIn *BuildIn, thisb Builder) {\n\n\tst, ok := e.compStateMap[thisb]\n\tif !ok {\n\t\tinvokeInit(thisb, e.eventEnv)\n\t}\n\tst.passNum = e.passNum\n\te.compStateMap[thisb] = st\n\n\tbeforeBuilder, ok := thisb.(BeforeBuilder)\n\tif ok {\n\t\tbeforeBuilder.BeforeBuild()\n\t} else {\n\t\tinvokeCompute(thisb, e.eventEnv)\n\t}\n\n\tbuildOut := thisb.Build(buildIn)\n\n\t// store in buildResults\n\te.buildResults[makeBuildCacheKey(thisb)] = buildOut\n\n\tif len(buildOut.Components) == 0 {\n\t\treturn\n\t}\n\n\t// push next position hash to the stack, remove it upon exit\n\tnextPositionHash := hashVals(buildIn.CurrentPositionHash())\n\tbuildIn.PositionHashList = append(buildIn.PositionHashList, nextPositionHash)\n\tdefer func() {\n\t\tbuildIn.PositionHashList = buildIn.PositionHashList[:len(buildIn.PositionHashList)-1]\n\t}()\n\n\tfor _, c := range buildOut.Components {\n\n\t\te.buildOne(buildIn, c)\n\n\t\t// each iteration we increment the last position hash (the one we added above) by one\n\t\tbuildIn.PositionHashList[len(buildIn.PositionHashList)-1]++\n\t}\n}\n\n// CachedComponent will return the component that corresponds to a given CompKey.\n// The CompKey must contain a unique ID for the instance in question, and an optional\n// IterKey if applicable in the caller.\n// A nil value will be returned if nothing is found.  During a single build pass\n// only one component will be returned for a specified key (it is removed from the pool),\n// in order to protect against\n// broken callers that accidentally forget to set IterKey properly and ask for the same\n// component over and over, in whiich case the first call will return a value and\n// subsequent calls will return nil.\nfunc (e *BuildEnv) CachedComponent(compKey CompKey) Builder {\n\tret, ok := e.compCache[compKey]\n\tif ok {\n\t\tdelete(e.compCache, compKey)\n\t\treturn ret\n\t}\n\treturn nil\n}\n\n// UseComponent indicates the component which was actually used for a specified CompKey\n// during this build pass and stores it for later use.  In the next build pass, components\n// which have be provided UseComponent() will be available via CachedComponent().\nfunc (e *BuildEnv) UseComponent(compKey CompKey, component Builder) {\n\tdelete(e.compCache, compKey)    // make sure it's not in the cache\n\te.compUsed[compKey] = component // make sure it is in the used\n}\n\n// SetWireFunc assigns the function to be called by WireComponent.\n// If not set then WireComponent will have no effect.\nfunc (e *BuildEnv) SetWireFunc(f func(component Builder)) {\n\te.wireFunc = f\n}\n\n// WireComponent calls the wire function on this component.\n// This is called during component creation and use and provides an\n// opportunity to inject things into this component.\nfunc (e *BuildEnv) WireComponent(component Builder) {\n\tif e.wireFunc != nil {\n\t\te.wireFunc(component)\n\t}\n}\n\n// hashVals performs a hash of the given values together\nfunc hashVals(vs ...uint64) uint64 {\n\th := xxhash.New()\n\tvar b [8]byte\n\tfor _, v := range vs {\n\t\tbinary.BigEndian.PutUint64(b[:], v)\n\t\t_, err := h.Write(b[:])\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn h.Sum64()\n\n}\n\ntype compState struct {\n\tpassNum uint8\n\t// TODO: flags?\n}\n\n// FIXME: IMPORTANT: If we can separate the hash computation from the equal comparision, then we can use\n// the hash do map lookups but then have a stable equal comparision, this way components will never\n// be incorrectly reused, but still get virtually all of the benefits of using the hash approach for\n// rapid comparision (i.e. \"is this probably the same\"/\"find me one that is probably the same\" is fast\n// to answer).\n\n// NOTE: seems like we have two very distinct types of component comparisions:\n// 1. Should we re-use this instance?  (Basically, is the input the same - should ignore things like computed properties and other internal state)\n//    ^ This seems like a \"shallow\" comparision - pointer struct fields should be compared on the basis of do they point to the same thing.\n// 2. Is this component changed since last render?  (This should examine whatever it needs to in order to determine if a re-render is needed)\n//    ^ This seems like a \"deep\" comparision against a last known rendered state - you don't care about what the pointers are, you\n//      follow it until you get a value, and you check if it's \"changed\".\n\n// NOTE: This whole thing seems to be a question of optimization. We could just create\n// a new component for each pass, but we want to reuse, so it's worth thinking the entire thought through,\n// and ask what happens if we optmize each step.\n\n//----\n\n/*\n\tPoints to optimize\n\n\t- Don't recreate components that have the same input, reuse them (actually, why?? - because if they\n\t  compute internal state we sholud preserve that where possible). If we don't do this properly, then the\n\t  other two optimizations likely won't work either. (THIS IS BASICALLY THE \"SHALLOW COMPARE\" APPAROACH - BOTH FOR HASHING\n\t  AND EQUAL COMPARISION - COMPARE THE POINTERS NOT FOLLOWING THEM ETC)\n\n\t- Don't re-create VGNode tree for component if output will be the same (algo for how to determine this tbd)\n\t  - Breaks into \"our VGNode stuff is the same\" and \"ours plus children is the same\".\n\n\t- Don't re-sync VGNodes to render pipeline if they are the same.\n\t  - two cases here: 1. Same exact DOM for a component returned , 2. newly generated the same DOM\n*/\n\n// NOTE: Should we be using a pool for VGNode and VGAttribute allocation?  We are going to be creating and\n// destroying a whole lot of these. MAYBE, BUT BENCHMARK SHOWS ONLY ABOUT 15% IMPROVEMENT USING THE POOL, MIGHT\n// BE DIFFERENT IN REAL LIFE BUT PROBABLY NOT WORTH DOING RIGHT OUT THE GATE.\n\n/*\n\n\tBasic sequence:\n\n\t- Build is called on root component\n\t- Component checks self to see if DOM output will be same as last time and if we have cached BuildOut, return it if so.\n\t- No BuildOut cached, run through rest of Build.\n\t- For each component encountered, give BuildEnv the populated struct and ask it for the instance to use\n\t  (it will pull from cache or use the object it was sent).\n\t- Component is stored on VGNode.Component field.  BuildOut also should keep a slice of these for quick traversal.\n\t- BuildOut is returned from root component's Build.\n\t- The list of components in the BuildOut is traversed, Build called for each one,\n\t  and the result set on VGNode.ComponentOut.\n\t- This causes the above cycle to run again for each of these child components.  Runs until no more are left.\n\t- FIXME: need to see how we combine the CSS and JS and make this accessible to the renderer (although maybe\n\t  the renderer can follow the component trail in BuildOut, or something)\n\n\t- At this point we have a BuildOut with a tree of VGNodes, and each one either has content itself or\n\t  has another BuildOut in the VGNode.ComponentOut field.  Between the two caching mechanisms (component\n\t  checking itself to see if same output, and each component creation checked with BuildEnv for re-use),\n\t  the cached case for traversing even a large case should be fast.\n\n\t- During render: The BuildOut pointer (or maybe its Out field) is used as a cache key - same BuildOut ptr, we assume same\n\t  VGNodes, and renderer can safely skip to each child component and continue from there.\n\t- For each VGNode, we call String() and have a map of the prior output for this position, if it's the same,\n\t  we can skip all the sync stuff and just move to the next.  String() needs to be very carefully implemented\n\t  so it can be used for equality tests like this safely.  The idea is that if we get a different VGNode\n\t  but with the exact same content, we avoid the extra render instructions.\n\n\t------------------\n\tTODO: We need to verify that component events and slots as planned\n\thttps://github.com/vugu/vugu/wiki/Component-Related-Features-Design\n\tstill work with this idea above.  I THINK WE CAN JUST ASSIGN THE\n\tSLOT AND EVENT CALLBACKS EACH TIME, THAT SHOULD WORK JUST FINE, WE\n\tDON'T NEED TO COMPARE AND KEEP THE OLD SLOT FUNCS ETC, JUST OVERWRITE.\n*/\n\n/*\nMORE NOTES:\n\nOn 9/6/19 6:23 PM, Brad Peabody wrote:\n> each unique position where a component is used could get a unique ID - generated, maybe with type name, doesn't matter really,\n  but then for cases where there is no loop it's just a straight up lookup; in loop cases it's that ID plus a key of some sort\n  (maybe vg-key specifies, with default of index number). could be a struct that has this ID string and key value and that's used\n  to cache which component was used for this last render cycle.\n>\n> interesting - then if we know which exact component was in this slot last time, we can just re-assign all of the fields each pass -\n  if they are the same, fine, if not, fine, either way we just assign the fields and tell the component to Build, etc.\n\nkeys can be uint64: uint32 unix timestamp (goes up to 2106-02-07 06:28:15) plus 32 bits of crytographically random data -\nreally should be random enough for all practical purposes (NOW IMPLEMENTED AS CompKey)\n\n*/\n\n/*\n\nSTRUCT TAGS:\n\ntype Widget struct {\n\n\t// component param\n\tSize int `vugu:\"cparam\"`\n\tFirstName *string `vugu:\"cparam\"`\n\n\t// computed property, used for display, but entirely dependent upon Size\n\tDisplaySize string\n}\n\n*/\n\n/*\n\nDIRTY CHECKING:\n\nBasic idea:\n\ntype DirtyChecker interface{\n\tDirtyCheck(oldData []byte) (isDirty bool, newData []byte)\n\t// or maybe just interface{}\n\tDirtyCheck(oldData interface{}) (isDirty bool, newData interface{})\n}\n\n// \"mod\" is good!  doesn't sound weird, \"modify\" is pretty clearly on point, and \"mod\" is short.\n\ntype ModChecker interface{\n\tModCheck(oldData interface{}) (isDirty bool, newData interface{})\n}\n\ntype SomeComponent struct {\n\tFirstName string `vugu:\"modcheck\"`\n\n\tFirstNameFormatted string // computed field, not \"modcheck\"'ed\n}\n\n*/\n\n// func (e *BuildEnv) Component(vgparent *VGNode, comp Builder) Builder {\n\n// \treturn comp\n// }\n\n// // BuildRoot creates a BuildIn struct and calls Build on the root component (Builder), returning it's output.\n// func (e *BuildEnv) BuildRoot() (*BuildOut, error) {\n\n// \tvar buildIn BuildIn\n// \tbuildIn.BuildEnv = e\n\n// \t// TODO: SlotMap?\n\n// \treturn e.root.Build(&buildIn)\n// }\n\n// func (e *BuildEnv) ComponentFor(n *VGNode) (Builder, error) {\n// \tpanic(fmt.Errorf(\"not yet implemented\"))\n// }\n\n// func (e *BuildEnv) SetComponentFor(n *VGNode, c Builder) error {\n// \tpanic(fmt.Errorf(\"not yet implemented\"))\n// }\n"
        },
        {
          "name": "build-env_test.go",
          "type": "blob",
          "size": 1.2890625,
          "content": "package vugu\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBuildEnvCachedComponent(t *testing.T) {\n\n\tassert := assert.New(t)\n\n\tbe, err := NewBuildEnv()\n\tassert.NoError(err)\n\tassert.NotNil(be)\n\n\t{ // just double check sane behavior for these keys\n\t\tk1 := MakeCompKey(1, 1)\n\t\tk2 := MakeCompKey(1, 1)\n\t\tassert.Equal(k1, k2)\n\t\tk3 := MakeCompKey(1, 2)\n\t\tassert.NotEqual(k1, k3)\n\t\tk4 := MakeCompKey(1, 1)\n\t\tassert.Equal(k1, k4)\n\t}\n\n\trb1 := &rootb1{}\n\n\t// first run to intialize\n\tres := be.RunBuild(rb1)\n\tassert.NotNil(res)\n\n\tc := be.CachedComponent(MakeCompKey(1, 1))\n\tassert.Nil(c)\n\tassert.Nil(be.compCache[MakeCompKey(1, 1)])\n\n\tb1 := &testb1{}\n\tbe.UseComponent(MakeCompKey(1, 1), b1)\n\tassert.NotNil(be.compUsed[MakeCompKey(1, 1)])\n\n\t// run another one\n\tres = be.RunBuild(rb1)\n\tassert.NotNil(res)\n\n\t// we should see b1 in the cache\n\tassert.NotNil(be.compCache[MakeCompKey(1, 1)])\n\tassert.Equal(b1, be.compCache[MakeCompKey(1, 1)])\n\n\t// TODO: but not in the used (not used for this pass)\n\n\t// TODO: now try to use it and make sure we can only get it once\n\n}\n\ntype rootb1 struct{}\n\nfunc (b *rootb1) Build(in *BuildIn) (out *BuildOut) {\n\treturn &BuildOut{\n\t\tOut: []*VGNode{},\n\t}\n}\n\ntype testb1 struct{}\n\nfunc (b *testb1) Build(in *BuildIn) (out *BuildOut) {\n\treturn &BuildOut{\n\t\tOut: []*VGNode{},\n\t}\n}\n"
        },
        {
          "name": "change-counter.go",
          "type": "blob",
          "size": 0.6845703125,
          "content": "package vugu\r\n\r\n// ChangeCounter is a number that can be incremented to indicate modification.\r\n// The ModCheck method is implemented using this number.\r\n// A ChangeCounter can be used directly or embedded in a struct, with its\r\n// methods calling Changed on each mutating operation, in order to\r\n// track its modification.\r\ntype ChangeCounter int\r\n\r\n// Changed increments the counter to indicate a modification.\r\nfunc (c *ChangeCounter) Changed() {\r\n\t*c++\r\n}\r\n\r\n// ModCheck implements the ModChecker interface.\r\nfunc (c *ChangeCounter) ModCheck(mt *ModTracker, oldData interface{}) (isModified bool, newData interface{}) {\r\n\toldn, ok := oldData.(ChangeCounter)\r\n\treturn (!ok) || (oldn != *c), *c\r\n}\r\n"
        },
        {
          "name": "change-counter_test.go",
          "type": "blob",
          "size": 1.375,
          "content": "package vugu\n\nimport (\n\t\"log\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestModCheckerChangeCounter(t *testing.T) {\n\n\tassert := assert.New(t)\n\n\tvar wl WidgetList\n\twl.SetList([]Widget{\n\t\t{ID: 1, Name: \"Willy\"},\n\t\t{ID: 2, Name: \"Nilly\"},\n\t\t{ID: 3, Name: \"Silly\"},\n\t})\n\n\tvar mc ModTracker\n\tmc.TrackNext()\n\n\tchanged := mc.ModCheckAll(&wl)\n\tassert.True(changed)\n\tlog.Printf(\"changed(1) = %v\", changed)\n\n\tmc.TrackNext()\n\n\twl.Changed()\n\tchanged = mc.ModCheckAll(&wl)\n\tassert.True(changed)\n\tlog.Printf(\"changed(2) = %v\", changed)\n\n\tmc.TrackNext()\n\n\tchanged = mc.ModCheckAll(&wl)\n\tassert.False(changed)\n\tlog.Printf(\"changed(3) = %v\", changed)\n\n\tmc.TrackNext()\n\n\tchanged = mc.ModCheckAll(&wl)\n\tassert.False(changed)\n\tlog.Printf(\"changed(4) = %v\", changed)\n\n\tmc.TrackNext()\n\n\twl.SetList([]Widget{\n\t\t{ID: 4, Name: \"Billy\"},\n\t\t{ID: 5, Name: \"Lilly\"},\n\t\t{ID: 6, Name: \"Milly\"},\n\t})\n\n\tchanged = mc.ModCheckAll(&wl)\n\tassert.True(changed)\n\tlog.Printf(\"changed(5) = %v\", changed)\n\n\tmc.TrackNext()\n\n\tchanged = mc.ModCheckAll(&wl)\n\tassert.False(changed)\n\tlog.Printf(\"changed(6) = %v\", changed)\n\n}\n\ntype Widget struct {\n\tID   uint64\n\tName string\n}\n\ntype WidgetList struct {\n\titems []Widget\n\tChangeCounter\n}\n\nfunc (l *WidgetList) SetList(items []Widget) {\n\tl.items = items\n\tl.Changed()\n}\n\nfunc (l *WidgetList) Len() int {\n\treturn len(l.items)\n}\n\nfunc (l *WidgetList) Index(idx int) Widget {\n\treturn l.items[idx]\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "comp-key-default.go",
          "type": "blob",
          "size": 0.619140625,
          "content": "// +build !tinygo\n\npackage vugu\n\n// CompKey is the key used to identify and look up a component instance.\ntype CompKey struct {\n\tID      uint64      // unique ID for this instance of a component, randomly generated and embeded into source code\n\tIterKey interface{} // optional iteration key to distinguish the same component reference in source code but different loop iterations\n}\n\n// MakeCompKey creates a CompKey from the id and iteration key you provide.\n// The purpose is to hide the implementation of CompKey as it can vary.\nfunc MakeCompKey(id uint64, iterKey interface{}) CompKey {\n\treturn CompKey{ID: id, IterKey: iterKey}\n}\n"
        },
        {
          "name": "comp-key-tinygo.go",
          "type": "blob",
          "size": 0.3701171875,
          "content": "// +build tinygo\n\npackage vugu\n\nimport \"fmt\"\n\n// CompKey is a string in TinyGo for the time being\ntype CompKey string\n\n// MakeCompKey creates a CompKey from the id and iteration key you provide.\n// The purpose is to hide the implementation of CompKey as it can vary.\nfunc MakeCompKey(id uint64, iterKey interface{}) CompKey {\n\treturn CompKey(fmt.Sprintf(\"%x:%v\", id, iterKey))\n}\n"
        },
        {
          "name": "comp-key.go",
          "type": "blob",
          "size": 1.0205078125,
          "content": "package vugu\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/vugu/xxhash\"\n)\n\n// MakeCompKeyID forms a value for CompKey.ID from the given time the uint32 you provide for the lower 32 bits.\nfunc MakeCompKeyID(t time.Time, data uint32) uint64 {\n\tvar ret = uint64(t.Unix()) << 32\n\tret |= uint64(data)\n\treturn ret\n}\n\n// MakeCompKeyIDTimeHash forms a value for CompKey.ID from the given time and a hash of the bytes you provide.\nfunc MakeCompKeyIDTimeHash(t time.Time, b []byte) uint64 {\n\th := xxhash.New()\n\t_, err := h.Write(b)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn MakeCompKeyID(t, uint32(h.Sum64()))\n}\n\nvar compKeyRand *rand.Rand\n\n// MakeCompKeyIDNowRand generates a value for CompKey.ID based on the current unix timestamp in seconds for the top 32 bits and\n// the bottom 32 bits populated from a random source\nfunc MakeCompKeyIDNowRand() uint64 {\n\tif compKeyRand == nil {\n\t\tcompKeyRand = rand.New(rand.NewSource(time.Now().UnixNano()))\n\t}\n\tvar ret = uint64(time.Now().Unix()) << 32\n\tret |= uint64(compKeyRand.Int63() & 0xFFFFFFFF)\n\treturn ret\n}\n"
        },
        {
          "name": "comp-key_test.go",
          "type": "blob",
          "size": 0.7685546875,
          "content": "package vugu\n\nimport (\n\t\"log\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCompKey(t *testing.T) {\n\n\tassert := assert.New(t)\n\n\tid := MakeCompKeyIDNowRand()\n\tlog.Printf(\"id=%#v\", id)\n\n\tm := make(map[CompKey]bool, 5000)\n\tfor i := 0; i < 5000; i++ {\n\t\tck := CompKey{ID: MakeCompKeyIDNowRand()}\n\t\tif m[ck] {\n\t\t\tt.Logf(\"CompKey %#v found duplicate\", ck)\n\t\t\tt.Fail()\n\t\t}\n\t\tm[ck] = true\n\t}\n\n\t// verify that different IterKey values are distinct\n\tm = make(map[CompKey]bool)\n\tck1 := CompKey{ID: MakeCompKeyIDNowRand(), IterKey: int(123)}\n\tm[ck1] = true\n\tassert.False(m[CompKey{ID: ck1.ID, IterKey: nil}])\n\tassert.False(m[CompKey{ID: ck1.ID, IterKey: int(122)}])\n\tassert.False(m[CompKey{ID: ck1.ID, IterKey: uint(123)}])\n\tassert.True(m[CompKey{ID: ck1.ID, IterKey: int(123)}])\n\n}\n"
        },
        {
          "name": "component.go",
          "type": "blob",
          "size": 5.41796875,
          "content": "package vugu\n\nimport (\n\t\"bytes\"\n)\n\n// BuildIn is the input to a Build call.\ntype BuildIn struct {\n\n\t// the overall build environment\n\tBuildEnv *BuildEnv\n\n\t// a stack of position hashes, the last one can be used by a component to get a unique hash for overall position\n\tPositionHashList []uint64\n}\n\n// CurrentPositionHash returns the hash value that can be used by a component to\n// mix into it's own hash values to achieve uniqueness based on overall position\n// in the output tree.  Basically you should XOR this with whatever unique reference\n// ID within the component itself used during Build.  The purpose is to ensure\n// that we use the same ID for the same component in the same position within\n// the overall tree but a different one for the same component in a different position.\nfunc (bi *BuildIn) CurrentPositionHash() uint64 {\n\tif len(bi.PositionHashList) == 0 {\n\t\treturn 0\n\t}\n\treturn bi.PositionHashList[len(bi.PositionHashList)-1]\n}\n\n// BuildOut is the output from a Build call.  It includes Out as the DOM elements\n// produced, plus slices for CSS and JS elements.\ntype BuildOut struct {\n\n\t// output element(s) - usually just one that is parent to the rest but slots can have multiple\n\tOut []*VGNode\n\n\t// components that need to be built next - corresponding to each VGNode in Out with a Component value set,\n\t// we make the Builder populate this so BuildEnv doesn't have to traverse Out to gather up each node with a component\n\t// FIXME: should this be called ChildComponents, NextComponents? something to make it clear that these are pointers to more work to\n\t// do rather than something already done\n\tComponents []Builder\n\n\t// optional CSS style or link tag(s)\n\tCSS []*VGNode\n\n\t// optional JS script tag(s)\n\tJS []*VGNode\n}\n\n// AppendCSS will append a unique node to CSS (nodes match exactly will not be added again).\nfunc (b *BuildOut) AppendCSS(nlist ...*VGNode) {\n\t// FIXME: we really should consider doing this dedeplication with a map or something, but for now this works\nnlistloop:\n\tfor _, n := range nlist {\n\t\tfor _, css := range b.CSS {\n\t\t\tif !ssNodeEq(n, css) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ssText(n) != ssText(css) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// these are the same, skip duplicate add\n\t\t\tcontinue nlistloop\n\t\t}\n\t\t// not a duplicate, add it\n\t\tb.CSS = append(b.CSS, n)\n\t}\n}\n\n// AppendJS will append a unique node to JS (nodes match exactly will not be added again).\nfunc (b *BuildOut) AppendJS(nlist ...*VGNode) {\nnlistloop:\n\tfor _, n := range nlist {\n\t\tfor _, js := range b.JS {\n\t\t\tif !ssNodeEq(n, js) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ssText(n) != ssText(js) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// these are the same, skip duplicate add\n\t\t\tcontinue nlistloop\n\t\t}\n\t\t// not a duplicate, add it\n\t\tb.JS = append(b.JS, n)\n\t}\n}\n\n// returns text content of child of script/style tag (assumes only one level of children and all text)\nfunc ssText(n *VGNode) string {\n\t// special case 0 children\n\tif n.FirstChild == nil {\n\t\treturn \"\"\n\t}\n\t// special case 1 child\n\tif n.FirstChild.NextSibling == nil {\n\t\treturn n.FirstChild.Data\n\t}\n\t// more than one child\n\tvar buf bytes.Buffer\n\tfor childN := n.FirstChild; childN != nil; childN = childN.NextSibling {\n\t\tbuf.WriteString(childN.Data)\n\t}\n\treturn buf.String()\n}\n\n// script/style node compare - only care about Type, Data and Attributes, does not examine children\nfunc ssNodeEq(n1, n2 *VGNode) bool {\n\tif n1.Type != n2.Type {\n\t\treturn false\n\t}\n\tif n1.Data != n2.Data {\n\t\treturn false\n\t}\n\tif len(n1.Attr) != len(n2.Attr) {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(n1.Attr); i++ {\n\t\tif n1.Attr[i] != n2.Attr[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// FIXME: CSS and JS are now full element nodes not just blocks of text (style, link, or script tags),\n// and we should have some sort of AppendCSS and AppendJS methods that understand that and also perform\n// deduplication.  There is no reason to wait and deduplicate later, we should be doing it here during\n// the Build.\n\n// func (b *BuildOut) AppendCSS(css string) {\n// \t// FIXME: should we be deduplicating here??\n// \tvgn := &VGNode{Type: ElementNode, Data: \"style\"}\n// \tvgn.AppendChild(&VGNode{Type: TextNode, Data: css})\n// \tb.CSS = append(b.CSS, vgn)\n// }\n\n// func (b *BuildOut) AppendJS(js string) {\n// \t// FIXME: should we be deduplicating here??\n// \tvgn := &VGNode{Type: ElementNode, Data: \"script\"}\n// \tvgn.AppendChild(&VGNode{Type: TextNode, Data: js})\n// \tb.JS = append(b.JS, vgn)\n// }\n\n// Builder is the interface that components implement.\ntype Builder interface {\n\t// Build is called to construct a tree of VGNodes corresponding to the DOM of this component.\n\t// Note that Build does not return an error because there is nothing the caller can do about\n\t// it except for stop rendering.  This way we force errors during Build to either be handled\n\t// internally or to explicitly result in a panic.\n\tBuild(in *BuildIn) (out *BuildOut)\n}\n\n// builderFunc is a Build-like function that implements Builder.\ntype builderFunc func(in *BuildIn) (out *BuildOut)\n\n// Build implements Builder.\nfunc (f builderFunc) Build(in *BuildIn) (out *BuildOut) { return f(in) }\n\n// NewBuilderFunc returns a Builder from a function that is called for Build.\nfunc NewBuilderFunc(f func(in *BuildIn) (out *BuildOut)) Builder {\n\t// NOTE: for now, all components have to be struct pointers, so we wrap\n\t// this function in a struct pointer.  Would be nice to fix this at some point.\n\treturn &struct {\n\t\tBuilder\n\t}{\n\t\tBuilder: builderFunc(f),\n\t}\n}\n\n// BeforeBuilder is deprecated.  It is replaced by the Compute lifecycle callback.\ntype BeforeBuilder interface {\n\tBeforeBuild()\n}\n"
        },
        {
          "name": "devutil",
          "type": "tree",
          "content": null
        },
        {
          "name": "distutil",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 2.6328125,
          "content": "/*\n\tPackage vugu provides core functionality including vugu->go codegen and in-browser DOM syncing running in WebAssembly.  See http://www.vugu.org/\n\n\tSince Vugu projects can have both client-side (running in WebAssembly) as well as server-side functionality many of the\n\titems in this package are available in both environments.  Some however are either only available or only generally useful\n\tin one environment.\n\n\tCommon functionality includes the ComponentType interface, and ComponentInst struct corresponding to an instantiated componnet.\n\tVGNode and related structs are used to represent a virtual Document Object Model.  It is based on golang.org/x/net/html but\n\twith additional fields needed for Vugu.  Data hashing is performed by ComputeHash() and can be customized by implementing\n\tthe DataHasher interface.\n\n\tClient-side code uses JSEnv to maintain a render loop and regenerate virtual DOM and efficiently synchronize it with\n\tthe browser as needed.  DOMEvent is a wrapper around events from the browser and EventEnv is used to synchronize data\n\taccess when writing event handler code that spawns goroutines.  Where appropriate, server-side stubs are available\n\tso components can be compiled for both client (WebAssembly) and server (server-side rendering and testing).\n\n\tServer-side code can use ParserGo and ParserGoPkg to parse .vugu files and code generate a corresponding .go file.\n\tStaticHTMLEnv can be used to generate static HTML, similar to the output of JSEnv but can be run on the server.\n\tSupported features are approximately the same minus event handling, unapplicable to static output.\n\n*/\npackage vugu\n\n/*\n\nold notes:\n\n\tCommon\n\n\tComponents and Registration...\n\n\tVGNode and friends for virtual DOM:\n\n\t<b>Data hashing is perfomed with the ComputeHash() function.<b>  <em>It walks your data structure</en> and hashes the information as it goes.\n\tIt uses xxhash internally and returns a uint64.  It is intended to be both fast and have good hash distribution to avoid\n\tcollision-related bugs.\n\n\t\tsomeData := &struct{A string}{A:\"test\"}\n\t\thv := ComputeHash(someData)\n\n\tIf the DataHasher interface is implemented by a particular type then ComputeHash will just called it and hash it's return\n\tinto the calculation.  Otherwise ComputeHash walks the data and finds primitive values and hashes them byte by bytes.\n\tNil interfaces and nil pointers are skipped.\n\n\tEffective hashing is an important part of achieving good performance in Vugu applications, since the question \"is this different\n\tthan it was before\" needs to be asked frequently.  The current experiment is to rely entirely on data hashing for change detection\n\trather than implementing a data-binding system.\n\n*/\n"
        },
        {
          "name": "domrender",
          "type": "tree",
          "content": null
        },
        {
          "name": "events-dom.go",
          "type": "blob",
          "size": 10.1689453125,
          "content": "package vugu\n\nimport (\n\t\"sync\"\n\n\t\"github.com/vugu/vugu/js\"\n)\n\n// NewDOMEvent returns a new initialized DOMEvent.\nfunc NewDOMEvent(eventEnv EventEnv, eventSummary map[string]interface{}) DOMEvent {\n\treturn &domEvent{\n\t\teventSummary: eventSummary,\n\t\teventEnv:     eventEnv,\n\t\twindow:       js.Global().Get(\"window\"),\n\t}\n}\n\n// DOMEvent is an event originated in the browser.  It wraps the JS event that comes in.\n// It is meant to be used in WebAssembly but some methods exist here so code can compile\n// server-side as well (although DOMEvents should not ever be generated server-side).\ntype DOMEvent interface {\n\n\t// Prop returns a value from the EventSummary using the keys you specify.\n\t// The keys is a list of map keys to be looked up. For example:\n\t// e.Prop(\"target\", \"name\") will return the same value as e.EventSummary()[\"target\"][\"name\"],\n\t// except that Prop helps with some edge cases and if a value is missing\n\t// of the wrong type, nil will be returned, instead of panicing.\n\tProp(keys ...string) interface{}\n\n\t// PropString is like Prop but returns it's value as a string.\n\t// No type conversion is done, if the requested value is not\n\t// already a string then an empty string will be returned.\n\tPropString(keys ...string) string\n\n\t// PropFloat64 is like Prop but returns it's value as a float64.\n\t// No type conversion is done, if the requested value is not\n\t// already a float64 then float64(0) will be returned.\n\tPropFloat64(keys ...string) float64\n\n\t// PropBool is like Prop but returns it's value as a bool.\n\t// No type conversion is done, if the requested value is not\n\t// already a bool then false will be returned.\n\tPropBool(keys ...string) bool\n\n\t// EventSummary returns a map with simple properties (primitive types) from the event.\n\t// Accessing values returns by EventSummary incurs no additional performance or memory\n\t// penalty, whereas calls to JSEvent, JSEventTarget, etc. require a call into the browser\n\t// JS engine and the attendant resource usage.  So if you can get the information you\n\t// need from the EventSummary, that's better.\n\tEventSummary() map[string]interface{}\n\n\t// JSEvent returns a js.Value in wasm that corresponds to the event object.\n\t// Non-wasm implementation returns nil.\n\tJSEvent() js.Value\n\n\t// JSEventTarget returns the value of the \"target\" property of the event, the element\n\t// that the event was originally fired/registered on.\n\tJSEventTarget() js.Value\n\n\t// JSEventCurrentTarget returns the value of the \"currentTarget\" property of the event, the element\n\t// that is currently processing the event.\n\tJSEventCurrentTarget() js.Value\n\n\t// EventEnv returns the EventEnv for the current environment and allows locking and unlocking around modifications.\n\t// See EventEnv struct.\n\tEventEnv() EventEnv\n\n\t// PreventDefault calls preventDefault() on the underlying DOM event.\n\t// May only be used within event handler in same goroutine.\n\tPreventDefault()\n\n\t// StopPropagation calls stopPropagation() on the underlying DOM event.\n\t// May only be used within event handler in same goroutine.\n\tStopPropagation()\n}\n\n// domEvent implements the DOMEvent interface.\n// This way DOMEvent can be passed around without a pointer this helps make\n// DOM events and component events similar and consistent.\n// It might actually makes sense to move this into the domrender package at some point.\ntype domEvent struct {\n\teventSummary map[string]interface{}\n\n\teventEnv EventEnv // from the renderer\n\n\t// TODO: yeah but why? this does not need to be here\n\twindow js.Value // sure, why not\n}\n\nvar _ DOMEvent = &domEvent{} // assert domEvent implements DOMEvent\n\n// Prop returns a value from the EventSummary using the keys you specify.\n// The keys is a list of map keys to be looked up. For example:\n// e.Prop(\"target\", \"name\") will return the same value as e.EventSummary()[\"target\"][\"name\"],\n// except that Prop helps with some edge cases and if a value is missing\n// of the wrong type, nil will be returned, instead of panicing.\nfunc (e *domEvent) Prop(keys ...string) interface{} {\n\n\tvar ret interface{}\n\tret = e.eventSummary\n\n\tfor _, key := range keys {\n\n\t\t// see if ret is a map\n\t\tm, _ := ret.(map[string]interface{})\n\t\tif m == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// and index into the map if so, replacing ret\n\t\tret = m[key]\n\n\t}\n\n\treturn ret\n}\n\n// PropString is like Prop but returns it's value as a string.\n// No type conversion is done, if the requested value is not\n// already a string then an empty string will be returned.\nfunc (e *domEvent) PropString(keys ...string) string {\n\tret, _ := e.Prop(keys...).(string)\n\treturn ret\n}\n\n// PropFloat64 is like Prop but returns it's value as a float64.\n// No type conversion is done, if the requested value is not\n// already a float64 then float64(0) will be returned.\nfunc (e *domEvent) PropFloat64(keys ...string) float64 {\n\tret, _ := e.Prop(keys...).(float64)\n\treturn ret\n}\n\n// PropBool is like Prop but returns it's value as a bool.\n// No type conversion is done, if the requested value is not\n// already a bool then false will be returned.\nfunc (e *domEvent) PropBool(keys ...string) bool {\n\tret, _ := e.Prop(keys...).(bool)\n\treturn ret\n}\n\n// EventSummary returns a map with simple properties (primitive types) from the event.\n// Accessing values returns by EventSummary incurs no additional performance or memory\n// penalty, whereas calls to JSEvent, JSEventTarget, etc. require a call into the browser\n// JS engine and the attendant resource usage.  So if you can get the information you\n// need from the EventSummary, that's better.\nfunc (e *domEvent) EventSummary() map[string]interface{} {\n\treturn e.eventSummary\n}\n\n// JSEvent this returns a js.Value in wasm that corresponds to the event object.\n// Non-wasm implementation returns nil.\nfunc (e *domEvent) JSEvent() js.Value {\n\treturn e.window.Call(\"vuguGetActiveEvent\")\n}\n\n// JSEventTarget returns the value of the \"target\" property of the event, the element\n// that the event was originally fired/registered on.\nfunc (e *domEvent) JSEventTarget() js.Value {\n\treturn e.window.Call(\"vuguGetActiveEventTarget\")\n}\n\n// JSEventCurrentTarget returns the value of the \"currentTarget\" property of the event, the element\n// that is currently processing the event.\nfunc (e *domEvent) JSEventCurrentTarget() js.Value {\n\treturn e.window.Call(\"vuguGetActiveEventCurrentTarget\")\n}\n\n// EventEnv returns the EventEnv for the current environment and allows locking and unlocking around modifications.\n// See EventEnv struct.\nfunc (e *domEvent) EventEnv() EventEnv {\n\treturn e.eventEnv\n}\n\n// PreventDefault calls preventDefault() on the underlying DOM event.\n// May only be used within event handler in same goroutine.\nfunc (e *domEvent) PreventDefault() {\n\te.window.Call(\"vuguActiveEventPreventDefault\")\n}\n\n// StopPropagation calls stopPropagation() on the underlying DOM event.\n// May only be used within event handler in same goroutine.\nfunc (e *domEvent) StopPropagation() {\n\te.window.Call(\"vuguActiveEventStopPropagation\")\n}\n\n// DOMEventHandlerSpec describes an event that gets registered with addEventListener.\ntype DOMEventHandlerSpec struct {\n\tEventType string // \"click\", \"mouseover\", etc.\n\tFunc      func(DOMEvent)\n\tCapture   bool\n\tPassive   bool\n}\n\n// // DOMEventHandler is created in BuildVDOM to represent a method call that is performed to handle an event.\n// type DOMEventHandler struct {\n// \tReceiverAndMethodHash uint64        // hash value corresponding to the method and receiver, so we get a unique value for each combination of method and receiver\n// \tMethod                reflect.Value // method to be called, with receiver baked into it if needed (see reflect/Value.MethodByName)\n// \tArgs                  []interface{} // arguments to be passed in when calling (special case for eventStub)\n// }\n\n// func (d DOMEventHandler) hashString() string {\n// \treturn fmt.Sprintf(\"%x\", d.hash())\n// }\n\n// func (d DOMEventHandler) hash() (ret uint64) {\n\n// \t// defer func() {\n// \t// \tlog.Printf(\"DOMEventHandler.hash for (receiver_and_method_hash=%v, method=%#v, args=%#v) is returning %v\", d.ReceiverAndMethodHash, d.Method, d.Args, ret)\n// \t// }()\n\n// \tif !d.Method.IsValid() && len(d.Args) == 0 {\n// \t\treturn 0\n// \t}\n\n// \tb8 := make([]byte, 8)\n// \th := xxhash.New()\n\n// \t// this may end up being an issue but I need to move through this for now -\n// \t// this is only unique for the method itself, not the instance it's tied to, although\n// \t// it's probably rare to have to distinguish between multiple component types in use in an application\n// \t// fmt.Fprintf(h, \"%#v\", d.Method)\n\n// \t// NOTE: added ReceiverAndMethodHash to deal with the note above, let's see if it solves the problem\n// \tbinary.BigEndian.PutUint64(b8, d.ReceiverAndMethodHash)\n// \th.Write(b8)\n\n// \t// add the args\n// \tfor _, a := range d.Args {\n// \t\tbinary.BigEndian.PutUint64(b8, ComputeHash(a))\n// \t\th.Write(b8)\n// \t}\n// \treturn h.Sum64()\n// }\n\n// EventEnv provides locking mechanism to for rendering environment to events so\n// data access and rendering can be synchronized and avoid race conditions.\ntype EventEnv interface {\n\tLock()         // acquire write lock\n\tUnlockOnly()   // release write lock\n\tUnlockRender() // release write lock and request re-render\n\n\tRLock()   // acquire read lock\n\tRUnlock() // release read lock\n}\n\n// NewEventEnvImpl creates and returns a new EventEnvImpl.\nfunc NewEventEnvImpl(rwmu *sync.RWMutex, requestRenderCH chan bool) *EventEnvImpl {\n\treturn &EventEnvImpl{\n\t\trwmu:            rwmu,\n\t\trequestRenderCH: requestRenderCH,\n\t}\n}\n\n// EventEnvImpl implements EventEnv\ntype EventEnvImpl struct {\n\trwmu            *sync.RWMutex\n\trequestRenderCH chan bool\n}\n\n// Lock will acquire write lock\nfunc (ee *EventEnvImpl) Lock() {\n\t// if ee.rwmu == nil {\n\t// \treturn\n\t// }\n\tee.rwmu.Lock()\n}\n\n// UnlockOnly will release the write lock\nfunc (ee *EventEnvImpl) UnlockOnly() {\n\t// if ee.rwmu == nil {\n\t// \treturn\n\t// }\n\tee.rwmu.Unlock()\n}\n\n// UnlockRender will release write lock and request re-render\nfunc (ee *EventEnvImpl) UnlockRender() {\n\t// if ee.rwmu != nil {\n\tee.rwmu.Unlock()\n\t// }\n\tif ee.requestRenderCH != nil {\n\t\t// send non-blocking\n\t\tselect {\n\t\tcase ee.requestRenderCH <- true:\n\t\tdefault:\n\t\t}\n\t}\n}\n\n// RLock will acquire a read lock\nfunc (ee *EventEnvImpl) RLock() {\n\t// if ee.rwmu == nil {\n\t// \treturn\n\t// }\n\tee.rwmu.RLock()\n}\n\n// RUnlock will release the read lock\nfunc (ee *EventEnvImpl) RUnlock() {\n\t// if ee.rwmu == nil {\n\t// \treturn\n\t// }\n\tee.rwmu.RUnlock()\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "gen",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.978515625,
          "content": "module github.com/vugu/vugu\n\nrequire (\n\tgithub.com/chromedp/cdproto v0.0.0-20240810084448-b931b754e476\n\tgithub.com/chromedp/chromedp v0.10.0\n\tgithub.com/stretchr/testify v1.9.0\n\tgithub.com/vugu/html v0.0.0-20190914200101-c62dc20b8289\n\tgithub.com/vugu/vjson v0.0.0-20200505061711-f9cbed27d3d9\n\tgithub.com/vugu/xxhash v0.0.0-20191111030615-ed24d0179019\n\tgolang.org/x/text v0.17.0\n)\n\nrequire (\n\tgithub.com/chromedp/sysutil v1.0.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/gobwas/httphead v0.1.0 // indirect\n\tgithub.com/gobwas/pool v0.2.1 // indirect\n\tgithub.com/gobwas/ws v1.4.0 // indirect\n\tgithub.com/josharian/intern v1.0.0 // indirect\n\tgithub.com/ledongthuc/pdf v0.0.0-20240201131950-da5b75280b06 // indirect\n\tgithub.com/mailru/easyjson v0.7.7 // indirect\n\tgithub.com/orisano/pixelmatch v0.0.0-20230914042517-fa304d1dc785 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgolang.org/x/sys v0.24.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n\ngo 1.22.3\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.5224609375,
          "content": "github.com/chromedp/cdproto v0.0.0-20240801214329-3f85d328b335/go.mod h1:GKljq0VrfU4D5yc+2qA6OVr8pmO/MBbPEWqWQ/oqGEs=\ngithub.com/chromedp/cdproto v0.0.0-20240810084448-b931b754e476 h1:VnjHsRXCRti7Av7E+j4DCha3kf68echfDzQ+wD11SBU=\ngithub.com/chromedp/cdproto v0.0.0-20240810084448-b931b754e476/go.mod h1:GKljq0VrfU4D5yc+2qA6OVr8pmO/MBbPEWqWQ/oqGEs=\ngithub.com/chromedp/chromedp v0.10.0 h1:bRclRYVpMm/UVD76+1HcRW9eV3l58rFfy7AdBvKab1E=\ngithub.com/chromedp/chromedp v0.10.0/go.mod h1:ei/1ncZIqXX1YnAYDkxhD4gzBgavMEUu7JCKvztdomE=\ngithub.com/chromedp/sysutil v1.0.0 h1:+ZxhTpfpZlmchB58ih/LBHX52ky7w2VhQVKQMucy3Ic=\ngithub.com/chromedp/sysutil v1.0.0/go.mod h1:kgWmDdq8fTzXYcKIBqIYvRRTnYb9aNS9moAV0xufSww=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/gobwas/httphead v0.1.0 h1:exrUm0f4YX0L7EBwZHuCF4GDp8aJfVeBrlLQrs6NqWU=\ngithub.com/gobwas/httphead v0.1.0/go.mod h1:O/RXo79gxV8G+RqlR/otEwx4Q36zl9rqC5u12GKvMCM=\ngithub.com/gobwas/pool v0.2.1 h1:xfeeEhW7pwmX8nuLVlqbzVc7udMDrwetjEv+TZIz1og=\ngithub.com/gobwas/pool v0.2.1/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=\ngithub.com/gobwas/ws v1.4.0 h1:CTaoG1tojrh4ucGPcoJFiAQUAsEWekEWvLy7GsVNqGs=\ngithub.com/gobwas/ws v1.4.0/go.mod h1:G3gNqMNtPppf5XUz7O4shetPpcZ1VJ7zt18dlUeakrc=\ngithub.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\ngithub.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80/go.mod h1:imJHygn/1yfhB7XSJJKlFZKl/J+dCPAknuiaGOshXAs=\ngithub.com/ledongthuc/pdf v0.0.0-20240201131950-da5b75280b06 h1:kacRlPN7EN++tVpGUorNGPn/4DnB7/DfTY82AOn6ccU=\ngithub.com/ledongthuc/pdf v0.0.0-20240201131950-da5b75280b06/go.mod h1:imJHygn/1yfhB7XSJJKlFZKl/J+dCPAknuiaGOshXAs=\ngithub.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=\ngithub.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=\ngithub.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde/go.mod h1:nZgzbfBr3hhjoZnS66nKrHmduYNpc34ny7RK4z5/HM0=\ngithub.com/orisano/pixelmatch v0.0.0-20230914042517-fa304d1dc785 h1:J1//5K/6QF10cZ59zLcVNFGmBfiSrH8Cho/lNrViK9s=\ngithub.com/orisano/pixelmatch v0.0.0-20230914042517-fa304d1dc785/go.mod h1:nZgzbfBr3hhjoZnS66nKrHmduYNpc34ny7RK4z5/HM0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/vugu/html v0.0.0-20190914200101-c62dc20b8289 h1:w3hfLuU5tKlcf+hhfmx6UZ5IC1h5M69dL9/6uugfLj8=\ngithub.com/vugu/html v0.0.0-20190914200101-c62dc20b8289/go.mod h1:Y3pLGz8dZUSrB9SARXqFmtW8RNs4HIGAr0+JaWL31Vg=\ngithub.com/vugu/vjson v0.0.0-20200505061711-f9cbed27d3d9 h1:0cwYt2uGUAwxOYF6zAkVvCKWt8zOV3JhQqjvwKb6jf0=\ngithub.com/vugu/vjson v0.0.0-20200505061711-f9cbed27d3d9/go.mod h1:z7mAqSUjRDMQ09NIO18jG2llXMHLnUHlZ3/8MEMyBPA=\ngithub.com/vugu/xxhash v0.0.0-20191111030615-ed24d0179019 h1:8NGiD5gWbVGObr+lnqcbM2rcOQBO6mr+m19BIblCdho=\ngithub.com/vugu/xxhash v0.0.0-20191111030615-ed24d0179019/go.mod h1:PrBK6+LJXwb+3EnJTHo43Uh4FhjFFwvN4jKk4Zc5zZ8=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/net v0.0.0-20190912160710-24e19bdeb0f2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.22.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.24.0 h1:Twjiwq9dn6R1fQcyiK+wQyHWfaz/BJB+YIpzU/Cv3Xg=\ngolang.org/x/sys v0.24.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.17.0 h1:XtiM5bkSOt+ewxlOE/aE/AKEHibwj/6gvWMl9Rsh0Qc=\ngolang.org/x/text v0.17.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "html.go",
          "type": "blob",
          "size": 1.501953125,
          "content": "package vugu\n\n// HTMLer describes something that can return HTML.\ntype HTMLer interface {\n\tHTML() string // return raw html (with any needed escaping already done)\n}\n\n// HTML implements the HTMLer interface on a string with no transform, just returns\n// the string as-is for raw HTML.\ntype HTML string\n\n// HTML implements the HTMLer interface.\nfunc (h HTML) HTML() string {\n\treturn string(h)\n}\n\n// NOTE: I'm bailing on this OptionalHTMLer thing because you can get the same\n// functionality with an explicit vg-if.  It's unclear how much benefit\n// it is to hide an element when you pass it a nil and if it's worth the effort\n// and additional complexity. It is much more important that we handle escaping\n// properly to prevent XSS, so we're going to simplify and focus on that.\n\n// // OptionalHTMLer is like HTMLer but can also explicitly express \"nothing here\"\n// // as distinct from an empty string.  This is used, for example, to express\n// // the difference between `<div></div>` and no tag at all.\n// type OptionalHTMLer interface {\n// \t// return html value and true for HTML content, or false to indicate no content.\n// \tOptionalHTML() (string, bool)\n// }\n\n// // OptionalHTML implements OptionalHTMLer using a string pointer.\n// type OptionalHTML struct {\n// \tValue *string // nil means return (\"\", false) from OptionalHTML\n// }\n\n// // OptionalHTML implements the OptionalHTMLer interface.\n// func (h OptionalHTML) OptionalHTML() (string, bool) {\n// \tif h.Value == nil {\n// \t\treturn \"\", false\n// \t}\n// \treturn *h.Value, true\n// }\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "js",
          "type": "tree",
          "content": null
        },
        {
          "name": "legacy-wasm-test-suite",
          "type": "tree",
          "content": null
        },
        {
          "name": "lifecycle.go",
          "type": "blob",
          "size": 2.0234375,
          "content": "package vugu\n\n// // UnlockRenderer is something that releases a lock and requests a re-render.\n// type UnlockRenderer interface {\n// \tUnlockRender()\n// }\n\n// InitCtx is the context passed to an Init callback.\ntype InitCtx interface {\n\tEventEnv() EventEnv\n\n\t// TODO: decide if we want to do something like this for convenience\n\t// Lock() UnlockRenderer\n}\n\ntype initCtx struct {\n\teventEnv EventEnv\n}\n\n// EventEnv implements InitCtx\nfunc (c *initCtx) EventEnv() EventEnv {\n\treturn c.eventEnv\n}\n\ntype initer0 interface {\n\tInit()\n}\ntype initer1 interface {\n\tInit(ctx InitCtx)\n}\n\nfunc invokeInit(c interface{}, eventEnv EventEnv) {\n\tif i, ok := c.(initer0); ok {\n\t\ti.Init()\n\t} else if i, ok := c.(initer1); ok {\n\t\ti.Init(&initCtx{eventEnv: eventEnv})\n\t}\n}\n\n// ComputeCtx is the context passed to a Compute callback.\ntype ComputeCtx interface {\n\tEventEnv() EventEnv\n}\n\ntype computeCtx struct {\n\teventEnv EventEnv\n}\n\n// EventEnv implements ComputeCtx\nfunc (c *computeCtx) EventEnv() EventEnv {\n\treturn c.eventEnv\n}\n\ntype computer0 interface {\n\tCompute()\n}\ntype computer1 interface {\n\tCompute(ctx ComputeCtx)\n}\n\nfunc invokeCompute(c interface{}, eventEnv EventEnv) {\n\tif i, ok := c.(computer0); ok {\n\t\ti.Compute()\n\t} else if i, ok := c.(computer1); ok {\n\t\ti.Compute(&computeCtx{eventEnv: eventEnv})\n\t}\n}\n\n// DestroyCtx is the context passed to a Destroy callback.\ntype DestroyCtx interface {\n\tEventEnv() EventEnv\n}\n\ntype destroyCtx struct {\n\teventEnv EventEnv\n}\n\n// EventEnv implements DestroyCtx\nfunc (c *destroyCtx) EventEnv() EventEnv {\n\treturn c.eventEnv\n}\n\ntype destroyer0 interface {\n\tDestroy()\n}\ntype destroyer1 interface {\n\tDestroy(ctx DestroyCtx)\n}\n\nfunc invokeDestroy(c interface{}, eventEnv EventEnv) {\n\tif i, ok := c.(destroyer0); ok {\n\t\ti.Destroy()\n\t} else if i, ok := c.(destroyer1); ok {\n\t\ti.Destroy(&destroyCtx{eventEnv: eventEnv})\n\t}\n}\n\n// RenderedCtx is the context passed to the Rendered callback.\ntype RenderedCtx interface {\n\tEventEnv() EventEnv // in case you need to request re-render\n\tFirst() bool        // true the first time this component is rendered\n}\n"
        },
        {
          "name": "magefiles",
          "type": "tree",
          "content": null
        },
        {
          "name": "misc-default.go",
          "type": "blob",
          "size": 0.1279296875,
          "content": "//go:build !tinygo\n// +build !tinygo\n\npackage vugu\n\nimport \"reflect\"\n\nfunc rvIsZero(rv reflect.Value) bool {\n\treturn rv.IsZero()\n}\n"
        },
        {
          "name": "misc-tinygo.go",
          "type": "blob",
          "size": 0.1201171875,
          "content": "//go:build tinygo\n// +build tinygo\n\npackage vugu\n\nimport \"reflect\"\n\nfunc rvIsZero(rv reflect.Value) bool {\n\treturn false\n}\n"
        },
        {
          "name": "mod-check-common.go",
          "type": "blob",
          "size": 1.236328125,
          "content": "package vugu\n\n// ModChecker interface is implemented by types that want to implement their own modification tracking.\n// The ModCheck method is passed a ModTracker (for use in checking child values for modification if needed),\n// and the prior data value stored corresponding to this value (will be nil on the first call).\n// ModCheck should return true if this instance is modified, as well as a new data value to be stored.\n// It is up to the specific implementation to decide what type to use for oldData and newData and how to\n// compare them.  In some cases it may be appropriate to return the value itself or a summarized version\n// of it.  But for types that use lots of memory and would otherwise take too much time to traverse, a\n// counter or other value can be used to indicate that some changed is occured, with the rest of the\n// application using mutator methods to increment this value upon change.\ntype ModChecker interface {\n\tModCheck(mt *ModTracker, oldData interface{}) (isModified bool, newData interface{})\n}\n\n// NewModTracker creates an empty ModTracker, calls TrackNext on it, and returns it.\nfunc NewModTracker() *ModTracker {\n\tvar ret ModTracker\n\tret.TrackNext()\n\treturn &ret\n}\n\ntype mtResult struct {\n\tmodified bool\n\tdata     interface{}\n}\n"
        },
        {
          "name": "mod-check-default.go",
          "type": "blob",
          "size": 10.84765625,
          "content": "//go:build !tinygo\n// +build !tinygo\n\npackage vugu\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"unsafe\"\n\n\t\"github.com/vugu/xxhash\"\n)\n\n// type ModCheckedString string\n// func (s ModCheckedString) ModCheck(mt *ModTracker, oldData interface{}) (isModified bool, newData interface{}) {\n// }\n\n// ModTracker tracks modifications and maintains the appropriate state for this.\ntype ModTracker struct {\n\told map[interface{}]mtResult\n\tcur map[interface{}]mtResult\n}\n\n// TrackNext moves the \"current\" information to the \"old\" position - starting a new round of change tracking.\n// Calls to ModCheckAll after calling TrackNext will compare current values to the values from before the call to TrackNext.\n// It is generally called once at the start of each build and render cycle.  This method must be called at least\n// once before doing modification checks.\nfunc (mt *ModTracker) TrackNext() {\n\n\t// lazy initialize\n\tif mt.old == nil {\n\t\tmt.old = make(map[interface{}]mtResult)\n\t}\n\tif mt.cur == nil {\n\t\tmt.cur = make(map[interface{}]mtResult)\n\t}\n\n\t// remove all elements from old map\n\tfor k := range mt.old {\n\t\tdelete(mt.old, k)\n\t}\n\n\t// and swap them\n\tmt.old, mt.cur = mt.cur, mt.old\n\n}\n\n//nolint:golint,unused\nfunc (mt *ModTracker) dump() []byte {\n\tvar buf bytes.Buffer\n\tfmt.Fprintf(&buf, \"-- cur (len=%d): --\\n\", len(mt.cur))\n\tfor k, v := range mt.cur {\n\t\tfmt.Fprintf(&buf, \" %#v = %#v\\n\", k, v)\n\t}\n\tfmt.Fprintf(&buf, \"-- old (len=%d): --\\n\", len(mt.old))\n\tfor k, v := range mt.old {\n\t\tfmt.Fprintf(&buf, \" %#v = %#v\\n\", k, v)\n\t}\n\treturn buf.Bytes()\n}\n\n// Otherwise pointers to some built-in types are supported including all primitive single-value types -\n// bool, int/uint and all variations, both float types, both complex types, string.\n// Pointers to supported types are supported.\n// Arrays, slices and maps(nope!) using supported types are supported.\n// Pointers to structs will be checked by\n// checking each field with a struct tag like `vugu:\"modcheck\"`.  Slices and arrays of\n// structs are okay, since their members have a stable position in memory and a pointer\n// can be taken.  Maps using structs however must use pointers to them\n// (restriction applies to both keys and values) to be supported.\n\n// ModCheckAll performs a modification check on the values provided.\n// For values implementing the ModChecker interface, the ModCheck method will be called.\n// All values passed should be pointers to the types described below.\n// Single-value primitive types are supported.  Structs are supported and\n// and are traversed by calling ModCheckAll on each with the tag `vugu:\"modcheck\"`.\n// Arrays and slices of supported types are supported, their length is compared as well\n// as a pointer to each member.\n// As a special case []byte is treated like a string.\n// Maps are not supported at this time.\n// Other weird and wonderful things like channels and funcs are not supported.\n// Passing an unsupported type will result in a panic.\nfunc (mt *ModTracker) ModCheckAll(values ...interface{}) (ret bool) {\n\n\tfor _, v := range values {\n\n\t\t// check if we've already done a mod check on v\n\t\tcurres, ok := mt.cur[v]\n\t\tif ok {\n\t\t\tret = ret || curres.modified\n\t\t\tcontinue\n\t\t}\n\n\t\t// look up the old data\n\t\toldres := mt.old[v]\n\n\t\t// the result of the mod check on v goes here\n\t\tvar mod bool\n\t\tvar newdata interface{}\n\n\t\t{\n\t\t\t// see if it implements the ModChecker interface\n\t\t\tmc, ok := v.(ModChecker)\n\t\t\tif ok {\n\t\t\t\tmod, newdata = mc.ModCheck(mt, oldres.data)\n\t\t\t\tgoto handleData\n\t\t\t}\n\n\t\t\t// support for certain built-in types\n\t\t\tswitch vt := v.(type) {\n\n\t\t\tcase *string:\n\t\t\t\toldval, ok := oldres.data.(string)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *[]byte: // special case of []byte, handled like string not slice\n\t\t\t\toldval, ok := oldres.data.(string)\n\t\t\t\tvts := string(*vt)\n\t\t\t\tmod = !ok || oldval != vts\n\t\t\t\tnewdata = vts\n\t\t\t\tgoto handleData\n\n\t\t\tcase *bool:\n\t\t\t\toldval, ok := oldres.data.(bool)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *int:\n\t\t\t\toldval, ok := oldres.data.(int)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *int8:\n\t\t\t\toldval, ok := oldres.data.(int8)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *int16:\n\t\t\t\toldval, ok := oldres.data.(int16)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *int32:\n\t\t\t\toldval, ok := oldres.data.(int32)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *int64:\n\t\t\t\toldval, ok := oldres.data.(int64)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *uint:\n\t\t\t\toldval, ok := oldres.data.(uint)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *uint8:\n\t\t\t\toldval, ok := oldres.data.(uint8)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *uint16:\n\t\t\t\toldval, ok := oldres.data.(uint16)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *uint32:\n\t\t\t\toldval, ok := oldres.data.(uint32)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *uint64:\n\t\t\t\toldval, ok := oldres.data.(uint64)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *float32:\n\t\t\t\toldval, ok := oldres.data.(float32)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *float64:\n\t\t\t\toldval, ok := oldres.data.(float64)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *complex64:\n\t\t\t\toldval, ok := oldres.data.(complex64)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\tcase *complex128:\n\t\t\t\toldval, ok := oldres.data.(complex128)\n\t\t\t\tmod = !ok || oldval != *vt\n\t\t\t\tnewdata = *vt\n\t\t\t\tgoto handleData\n\n\t\t\t}\n\n\t\t\t// when the scalpel (type switch) doesn't do it,\n\t\t\t// gotta use the bonesaw (reflection)\n\n\t\t\trv := reflect.ValueOf(v)\n\n\t\t\t// check pointer and deref\n\t\t\tif rv.Kind() != reflect.Ptr {\n\t\t\t\tpanic(errors.New(\"type not implemented (pointer required): \" + rv.String()))\n\t\t\t}\n\t\t\trvv := rv.Elem()\n\n\t\t\t// slice and array are treated the same\n\t\t\tif rvv.Kind() == reflect.Slice || rvv.Kind() == reflect.Array {\n\n\t\t\t\tl := rvv.Len()\n\n\t\t\t\t// for slices and arrays we compute the hash of the raw contents,\n\t\t\t\t// takes care of length and sequence changes\n\t\t\t\tha := xxhash.New()\n\n\t\t\t\tvar el0t reflect.Type\n\n\t\t\t\tif l > 0 {\n\t\t\t\t\t// use the unsafe package to make a byte slice corresponding to the raw slice contents\n\t\t\t\t\tvar bs []byte\n\t\t\t\t\t// TODO: need to be fix later\n\t\t\t\t\tbsh := (*reflect.SliceHeader)(unsafe.Pointer(&bs)) //nolint:staticcheck\n\n\t\t\t\t\tel0 := rvv.Index(0)\n\t\t\t\t\tel0t = el0.Type()\n\n\t\t\t\t\tbsh.Data = el0.Addr().Pointer() // point to first element of slice\n\t\t\t\t\tbsh.Len = l * int(el0t.Size())\n\t\t\t\t\tbsh.Cap = bsh.Len\n\n\t\t\t\t\t// hash it\n\t\t\t\t\t_, err := ha.Write(bs)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thashval := ha.Sum64()\n\n\t\t\t\t// use hashval as our data, and mark as modified if different\n\t\t\t\toldval, ok := oldres.data.(uint64)\n\t\t\t\tmod = !ok || oldval != hashval\n\t\t\t\tnewdata = hashval\n\n\t\t\t\t// for types that by definition have already been checked with the hash above, we're done\n\t\t\t\tif el0t != nil {\n\t\t\t\t\tswitch el0t.Kind() {\n\t\t\t\t\tcase reflect.Bool,\n\t\t\t\t\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\t\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\t\t\t\treflect.Uintptr,\n\t\t\t\t\t\treflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128,\n\t\t\t\t\t\treflect.String:\n\t\t\t\t\t\tgoto handleData\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// recurse into each element and check, update mod as we go\n\t\t\t\t// NOTE: for \"deep\" element types that can have changes within them,\n\t\t\t\t// it's important to recurse into children even if mod is already\n\t\t\t\t// true, otherwise we'll never call ModCheckAll on these children and\n\t\t\t\t// never get an unmodified response\n\n\t\t\t\tfor i := 0; i < l; i++ {\n\n\t\t\t\t\t// get pointer to the individual element and recurse into it\n\t\t\t\t\telv := rvv.Index(i).Addr().Interface()\n\t\t\t\t\tmod = mt.ModCheckAll(elv) || mod\n\t\t\t\t}\n\n\t\t\t\tgoto handleData\n\n\t\t\t}\n\n\t\t\t// for structs we iterate over the fields looked for tagged ones\n\t\t\tif rvv.Kind() == reflect.Struct {\n\n\t\t\t\t// just use bool(true) as the data value for a struct - this way it will always be modified the first time,\n\t\t\t\t// but every subsequent check will solely depend on the checks on it's fields\n\t\t\t\toldval, ok := oldres.data.(bool)\n\t\t\t\tmod = !ok || !oldval\n\t\t\t\tnewdata = true\n\n\t\t\t\trvvt := rvv.Type()\n\t\t\t\tfor i := 0; i < rvvt.NumField(); i++ {\n\t\t\t\t\t// skip untagged fields\n\t\t\t\t\tif !hasTagPart(rvvt.Field(i).Tag.Get(\"vugu\"), \"data\") {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// call ModCheckAll on pointer to field\n\t\t\t\t\tmod = mt.ModCheckAll(\n\t\t\t\t\t\trvv.Field(i).Addr().Interface(),\n\t\t\t\t\t) || mod\n\n\t\t\t\t}\n\n\t\t\t\tgoto handleData\n\t\t\t}\n\n\t\t\t// random stream of conciousness: should we check for a ModCheck implementation here and call it?\n\t\t\t// We might want to follow these pointers or rather recurse into them (if not nil?)\n\t\t\t// with a ModCheckAll.  Also look at how this ties into maps (if at all), since theoretically\n\t\t\t// we could compare a map by storing its length and basically doing for k, v := range m { ...ModCheckAll(&k,&v)... }\n\t\t\t// actually no that won't work because k and v will have different locations each time - but still could\n\t\t\t// potentially make some mapKeyValue struct that does what we need - but not vital to solve right now.\n\t\t\t// Pointers to pointers will probably come up first, and is likely why you are reading this comment.\n\n\t\t\t// pointer (meaning we were originally passed a pointer to a pointer)\n\t\t\tif rvv.Kind() == reflect.Ptr {\n\n\t\t\t\t// use pointer value as data...\n\t\t\t\tvv := rvv.Pointer()\n\t\t\t\toldval, ok := oldres.data.(uintptr)\n\t\t\t\tmod = !ok || oldval != vv\n\t\t\t\tnewdata = vv\n\n\t\t\t\t// ...but also recurse and call ModChecker with one level of pointer dereferencing, if not nil\n\t\t\t\tif !rvv.IsNil() {\n\t\t\t\t\tmod = mt.ModCheckAll(\n\t\t\t\t\t\trvv.Interface(),\n\t\t\t\t\t) || mod\n\t\t\t\t}\n\n\t\t\t\tgoto handleData\n\t\t\t}\n\n\t\t\tpanic(errors.New(\"type not implemented: \" + reflect.TypeOf(v).String()))\n\n\t\t}\n\thandleData:\n\t\tmt.cur[v] = mtResult{modified: mod, data: newdata}\n\t\tret = ret || mod\n\n\t}\n\n\treturn ret\n}\n\n// ModCheck(oldData interface{}) (isModified bool, newData interface{})\n\n// hm, this may not work - what happens if we call ModCheck twice in a row?? we need a clear\n// way to demark the \"old\" and \"new\" versions of data - it might be that the comparison and\n// the gather of the new value need to be separate methods?  Or can ModTracker somehow\n// prevent ModCheck from being call twice in the same pass (or prevent that from being an issue)\n\n// actually that might work - if there is a call on ModTracker that moves \"new\" to \"old\", it\n// woudl be pretty clear - and then calling this would only update the \"new\" value.  Also the\n// presence of something in the \"new\" data would mean it's already been called in this pass\n// and so can be deduplicated.\n\nfunc hasTagPart(tagstr, part string) bool {\n\tfor _, p := range strings.Split(tagstr, \",\") {\n\t\tif p == part {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "mod-check-tinygo.go",
          "type": "blob",
          "size": 0.2724609375,
          "content": "// +build tinygo\n\npackage vugu\n\ntype ModTracker struct {\n\t// old map[interface{}]mtResult\n\t// cur map[interface{}]mtResult\n}\n\nfunc (mt *ModTracker) TrackNext() {\n\tpanic(\"TBD tinygo\")\n}\n\nfunc (mt *ModTracker) ModCheckAll(values ...interface{}) (ret bool) {\n\tpanic(\"TBD tinygo\")\n}\n"
        },
        {
          "name": "mod-check_test.go",
          "type": "blob",
          "size": 12.5,
          "content": "package vugu\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestModCheckerWidget(t *testing.T) {\n\n\t// try a more complex but realistic example\n\n\tassert := assert.New(t)\n\tmt := NewModTracker()\n\n\ttype Tag struct {\n\t\tName  string `vugu:\"data\" json:\"name\"`\n\t\tStyle int    `vugu:\"data\" json:\"style\"`\n\t}\n\n\ttype Widget struct {\n\t\tID           int64   `vugu:\"data\" json:\"id\"`\n\t\tName         string  `vugu:\"data\" json:\"name\"`\n\t\tDescription  *string `vugu:\"data\" json:\"description\"`\n\t\tActive       bool    `vugu:\"data\" json:\"active\"`\n\t\tStockCount   *int32  `vugu:\"data\" json:\"stock_count\"`\n\t\tTags         []Tag   `vugu:\"data\" json:\"tags\"`\n\t\tFeaturedTags []*Tag  `vugu:\"data\" json:\"-\"` // calculated separately after loading\n\t}\n\n\twjson := `\n\t[\n\t\t{\n\t\t\t\"id\": 100,\n\t\t\t\"name\": \"Widgetron\",\n\t\t\t\"description\": \"This one is electronical\",\n\t\t\t\"active\": true,\n\t\t\t\"stock_count\": 42,\n\t\t\t\"tags\": [{\"name\":\"Electronical\",\"style\":314159},{\"name\":\"Whatever\",\"style\":1}]\n\t\t},\n\t\t{\n\t\t\t\"id\": 101,\n\t\t\t\"name\": \"Widgetcron\",\n\t\t\t\"description\": \"This one is chronical\",\n\t\t\t\"active\": true,\n\t\t\t\"stock_count\": 2400,\n\t\t\t\"tags\": [{\"name\":\"Something\",\"style\":2400},{\"name\":\"Whatever\",\"style\":1}]\n\t\t},\n\t\t{\n\t\t\t\"id\": 102,\n\t\t\t\"name\": \"Widgetevil\",\n\t\t\t\"description\": \"This one is diabolical\",\n\t\t\t\"active\": false,\n\t\t\t\"stock_count\": 13,\n\t\t\t\"tags\": [{\"name\":\"Something\",\"style\":666}]\n\t\t}\n\t]\n\t`\n\n\tvar wlist []Widget\n\tassert.NoError(json.Unmarshal([]byte(wjson), &wlist))\n\n\t// log.Printf(\"wlist: %#v\", wlist)\n\n\tmt.TrackNext()\n\tassert.True(mt.ModCheckAll(&wlist))\n\tassert.True(mt.ModCheckAll(&wlist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wlist))\n\n\t// change the sequence\n\tmt.TrackNext()\n\twlist[0], wlist[1] = wlist[1], wlist[0]\n\tassert.True(mt.ModCheckAll(&wlist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wlist))\n\n\t// change a field value\n\tmt.TrackNext()\n\twlist[0].Name = \"Widgetcroninator\"\n\tassert.True(mt.ModCheckAll(&wlist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wlist))\n\n\t// change a pointer field\n\tmt.TrackNext()\n\tnewStockCount := int32(2401)\n\twlist[0].StockCount = &newStockCount\n\tassert.True(mt.ModCheckAll(&wlist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wlist))\n\n\t// log.Printf(\"dumpA: %s\", mt.dump())\n\n\t// change the value pointed to by a field\n\tmt.TrackNext()\n\t*wlist[0].StockCount = 2402\n\tassert.True(mt.ModCheckAll(&wlist))\n\n\t// log.Printf(\"dumpB: %s\", mt.dump())\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wlist))\n\n\t// set pointer field to nil\n\tmt.TrackNext()\n\twlist[0].StockCount = nil\n\tassert.True(mt.ModCheckAll(&wlist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wlist))\n\n\t// log.Printf(\"dump: %s\", mt.dump())\n\n\t// now try it with a slice of struct pointers\n\tvar wplist []*Widget\n\tassert.NoError(json.Unmarshal([]byte(wjson), &wplist))\n\n\tmt.TrackNext()\n\tassert.True(mt.ModCheckAll(&wplist))\n\tassert.True(mt.ModCheckAll(&wplist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wplist))\n\n\t// change the sequence\n\tmt.TrackNext()\n\twplist[0], wplist[1] = wplist[1], wplist[0]\n\tassert.True(mt.ModCheckAll(&wplist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wplist))\n\n\t// change a field value\n\tmt.TrackNext()\n\twplist[0].Name = \"Widgetcroninator\"\n\tassert.True(mt.ModCheckAll(&wplist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wplist))\n\n\t// change a pointer field\n\tmt.TrackNext()\n\tnewStockCount = int32(2401)\n\twplist[0].StockCount = &newStockCount\n\tassert.True(mt.ModCheckAll(&wplist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wplist))\n\n\t// log.Printf(\"dumpA: %s\", mt.dump())\n\n\t// change the value pointed to by a field\n\tmt.TrackNext()\n\t*wplist[0].StockCount = 2402\n\tassert.True(mt.ModCheckAll(&wplist))\n\n\t// log.Printf(\"dumpB: %s\", mt.dump())\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wplist))\n\n\t// set pointer field to nil\n\tmt.TrackNext()\n\twplist[0].StockCount = nil\n\tassert.True(mt.ModCheckAll(&wplist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wplist))\n\n\t// set one of the struct elements to nil\n\tmt.TrackNext()\n\twplist[0] = nil\n\tassert.True(mt.ModCheckAll(&wplist))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&wplist))\n\n}\n\nfunc TestModCheckerStruct(t *testing.T) {\n\tassert := assert.New(t)\n\tmt := NewModTracker()\n\n\tvar s1 struct {\n\t\tF1 string  `vugu:\"data\"`\n\t\tF2 int     `vugu:\"data\"`\n\t\tF3 float64 // not tagged\n\t}\n\n\tmt.TrackNext()\n\tassert.True(mt.ModCheckAll(&s1))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&s1))\n\n\tmt.TrackNext()\n\ts1.F1 = \"test1\"\n\tassert.True(mt.ModCheckAll(&s1))\n\n\tmt.TrackNext()\n\ts1.F2 = 1\n\tassert.True(mt.ModCheckAll(&s1))\n\n\tmt.TrackNext()\n\ts1.F3 = 1.0 // field not tagged, should not cause modification\n\tassert.False(mt.ModCheckAll(&s1))\n\n}\n\nfunc TestModCheckerSliceArray(t *testing.T) {\n\n\tassert := assert.New(t)\n\tmt := NewModTracker()\n\n\tvar a1 [3]string\n\ta1[0] = \"s1\"\n\ta1[1] = \"s2\"\n\ta1[2] = \"s3\"\n\n\tassert.True(mt.ModCheckAll(&a1))\n\n\t// log.Printf(\"state1: \\n%s\", mt.dump())\n\n\tmt.TrackNext()\n\n\t// log.Printf(\"state2: \\n%s\", mt.dump())\n\n\tassert.False(mt.ModCheckAll(&a1))\n\n\t// log.Printf(\"state3: \\n%s\", mt.dump())\n\n\tvar s1 []string\n\ts1 = a1[:]\n\n\tmt.TrackNext()\n\tassert.True(mt.ModCheckAll(&s1))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&s1))\n\n\tmt.TrackNext()\n\ts1 = a1[:2]\n\tassert.True(mt.ModCheckAll(&s1))\n\n\t// swap two elements\n\tmt.TrackNext()\n\ts1[0], s1[1] = s1[1], s1[0]\n\tassert.True(mt.ModCheckAll(&s1))\n\n\tmt.TrackNext()\n\tassert.False(mt.ModCheckAll(&s1))\n\n}\n\nfunc TestModCheckerStrings(t *testing.T) {\n\n\tassert := assert.New(t)\n\n\tvar mt ModTracker\n\n\tmt.TrackNext()\n\ts := \"testing\" // initial value\n\tassert.True(mt.ModCheckAll(&s))\n\n\tmt.TrackNext()\n\t// no change\n\tassert.False(mt.ModCheckAll(&s))\n\n\tmt.TrackNext()\n\ts = \"testing2\" // different value\n\tassert.True(mt.ModCheckAll(&s))\n\n\tmt.TrackNext()\n\ts = \"testing\" // back to earlier value\n\tassert.True(mt.ModCheckAll(&s))\n\n\tmt.TrackNext()\n\ts = \"testing\" // same value\n\tassert.False(mt.ModCheckAll(&s))\n\n\t// run through it again with a byte slice\n\n\tmt.TrackNext()\n\tb := []byte(\"testing\") // initial value\n\tassert.True(mt.ModCheckAll(&b))\n\n\tmt.TrackNext()\n\t// no change\n\tassert.False(mt.ModCheckAll(&b))\n\n\tmt.TrackNext()\n\tb = []byte(\"testing2\") // different value\n\tassert.True(mt.ModCheckAll(&b))\n\n\tmt.TrackNext()\n\tb = []byte(\"testing\") // back to earlier value\n\tassert.True(mt.ModCheckAll(&b))\n\n\tmt.TrackNext()\n\tb = []byte(\"testing\") // same value\n\tassert.False(mt.ModCheckAll(&b))\n\n\t// check both\n\tmt.TrackNext()\n\n\tmt.TrackNext()\n\tb = []byte(\"testing\")\n\tassert.True(mt.ModCheckAll(&b))\n\ts = \"testing\"\n\tassert.True(mt.ModCheckAll(&s))\n\n\tmt.TrackNext()\n\tb = []byte(\"testing\")\n\tassert.False(mt.ModCheckAll(&b))\n\ts = \"testing\"\n\tassert.False(mt.ModCheckAll(&s))\n\n}\n\nfunc TestModCheckerBool(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 bool\n\tcheck := func(vp *bool, newv bool, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, false, true)\n\tcheck(&v1, false, false)\n\tcheck(&v1, true, true)\n\tcheck(&v1, true, false)\n\tcheck(&v1, false, true)\n\tcheck(&v1, false, false)\n\tcheck(&v1, false, false)\n\tcheck(&v2, false, true)\n\tcheck(&v2, true, true)\n\tcheck(&v2, false, true)\n\tcheck(&v2, false, false)\n\n}\n\nfunc TestModCheckerInt(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 int\n\tcheck := func(vp *int, newv int, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n\nfunc TestModCheckerInt8(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 int8\n\tcheck := func(vp *int8, newv int8, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n\nfunc TestModCheckerInt16(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 int16\n\tcheck := func(vp *int16, newv int16, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n\nfunc TestModCheckerInt32(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 int32\n\tcheck := func(vp *int32, newv int32, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n\nfunc TestModCheckerInt64(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 int64\n\tcheck := func(vp *int64, newv int64, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n\nfunc TestModCheckerUint(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 uint\n\tcheck := func(vp *uint, newv uint, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n\nfunc TestModCheckerUint8(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 uint8\n\tcheck := func(vp *uint8, newv uint8, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n\nfunc TestModCheckerUint16(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 uint16\n\tcheck := func(vp *uint16, newv uint16, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n\nfunc TestModCheckerUint32(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 uint32\n\tcheck := func(vp *uint32, newv uint32, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n\nfunc TestModCheckerUint64(t *testing.T) {\n\n\tmt := NewModTracker()\n\n\tvar v1, v2 uint64\n\tcheck := func(vp *uint64, newv uint64, expectedMod bool) {\n\t\tmt.TrackNext()\n\t\t*vp = newv\n\t\tmod := mt.ModCheckAll(vp)\n\t\tif mod != expectedMod {\n\t\t\tt.Errorf(\"check(%#v, %#v, %#v) wrong mod result: %v\", vp, newv, expectedMod, mod)\n\t\t}\n\t}\n\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 2, true)\n\tcheck(&v1, 2, false)\n\tcheck(&v1, 1, true)\n\tcheck(&v1, 1, false)\n\tcheck(&v1, 1, false)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 2, true)\n\tcheck(&v2, 1, true)\n\tcheck(&v2, 1, false)\n\n}\n"
        },
        {
          "name": "simplehttp",
          "type": "tree",
          "content": null
        },
        {
          "name": "staticrender",
          "type": "tree",
          "content": null
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "tinygo-dev",
          "type": "tree",
          "content": null
        },
        {
          "name": "vgform",
          "type": "tree",
          "content": null
        },
        {
          "name": "vgnode.go",
          "type": "blob",
          "size": 11.8798828125,
          "content": "package vugu\n\nimport (\n\t\"fmt\"\n\t\"html\"\n\t\"reflect\"\n\t\"strconv\"\n\n\t\"github.com/vugu/vugu/js\"\n)\n\n// VGNodeType is one of the valid node types (error, text, document, element, comment, doctype).\n// Note that only text, element and comment are currently used.\ntype VGNodeType uint32\n\n// Available VGNodeTypes.\nconst (\n\tErrorNode    = VGNodeType(0 /*html.ErrorNode*/)\n\tTextNode     = VGNodeType(1 /*html.TextNode*/)\n\tDocumentNode = VGNodeType(2 /*html.DocumentNode*/)\n\tElementNode  = VGNodeType(3 /*html.ElementNode*/)\n\tCommentNode  = VGNodeType(4 /*html.CommentNode*/)\n\tDoctypeNode  = VGNodeType(5 /*html.DoctypeNode*/)\n)\n\n// VGAtom is an integer corresponding to golang.org/x/net/html/atom.Atom.\n// Note that this may be removed for simplicity and to remove the dependency\n// on the package above.  Suggest you don't use it.\n// type VGAtom uint32\n\n// VGAttribute is the attribute on an HTML tag.\ntype VGAttribute struct {\n\tNamespace, Key, Val string\n}\n\n// VGProperty is a JS property to be set on a DOM element.\ntype VGProperty struct {\n\tKey     string\n\tJSONVal []byte // value as JSON expression\n}\n\n// VGNode represents a node from our virtual DOM with the dynamic parts wired up into functions.\n//\n// For the static parts, an instance of VGNode corresponds directly to the DOM representation of\n// an HTML node.  The pointers to other VGNode instances (Parent, FirstChild, etc.) are used to manage the tree.\n// Type, Data, Namespace and Attr have the usual meanings for nodes.\n//\n// The Component field, if not-nil indicates that rendering should be delegated to the specified component,\n// all other fields are ignored.\n//\n// Another special case is when Type is ElementNode and Data is an empty string (and Component is nil) then this node is a \"template\"\n// (i.e. <vg-template>) and its children will be \"flattened\" into the DOM in position of this element\n// and attributes, events, etc. ignored.\n//\n// Prop contains JavaScript property values to be assigned during render. InnerHTML provides alternate\n// HTML content instead of children.  DOMEventHandlerSpecList specifies DOM handlers to register.\n// And the JS...Handler fields are used to register callbacks to obtain information at JS render-time.\n//\n// TODO: This and its related parts should probably move into a sub-package (vgnode?) and\n// the \"VG\" prefixes removed.\ntype VGNode struct {\n\tParent, FirstChild, LastChild, PrevSibling, NextSibling *VGNode\n\n\tType VGNodeType\n\t// DataAtom  VGAtom // this needed to come out, we're not using it and without well-defined behavior it just becomes confusing and problematic\n\tData      string\n\tNamespace string\n\tAttr      []VGAttribute\n\n\t// JS properties to e set during render\n\tProp []VGProperty\n\n\t// Props Props // dynamic attributes, used as input for components or converted to attributes for regular HTML elements\n\n\tInnerHTML *string // indicates that children should be ignored and this raw HTML is the children of this tag; nil means not set, empty string means explicitly set to empty string\n\n\tDOMEventHandlerSpecList []DOMEventHandlerSpec // describes invocations when DOM events happen\n\n\t// indicates this node's output should be delegated to the specified component\n\tComponent interface{}\n\n\t// if not-nil, called when element is created (but before examining child nodes)\n\tJSCreateHandler JSValueHandler\n\t// if not-nil, called after children have been visited\n\tJSPopulateHandler JSValueHandler\n}\n\n// IsComponent returns true if this is a component (Component != nil).\n// Components have rendering delegated to them instead of processing this node.\nfunc (n *VGNode) IsComponent() bool {\n\treturn n.Component != nil\n}\n\n// IsTemplate returns true if this is a template (Type is ElementNode and Data is an empty string and not a Component).\n// Templates have their children flattened into the output DOM instead of being processed directly.\nfunc (n *VGNode) IsTemplate() bool {\n\tif n.Type == ElementNode && n.Data == \"\" && n.Component == nil {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// InsertBefore inserts newChild as a child of n, immediately before oldChild\n// in the sequence of n's children. oldChild may be nil, in which case newChild\n// is appended to the end of n's children.\n//\n// It will panic if newChild already has a parent or siblings.\nfunc (n *VGNode) InsertBefore(newChild, oldChild *VGNode) {\n\tif newChild.Parent != nil || newChild.PrevSibling != nil || newChild.NextSibling != nil {\n\t\tpanic(\"html: InsertBefore called for an attached child Node\")\n\t}\n\tvar prev, next *VGNode\n\tif oldChild != nil {\n\t\tprev, next = oldChild.PrevSibling, oldChild\n\t} else {\n\t\tprev = n.LastChild\n\t}\n\tif prev != nil {\n\t\tprev.NextSibling = newChild\n\t} else {\n\t\tn.FirstChild = newChild\n\t}\n\tif next != nil {\n\t\tnext.PrevSibling = newChild\n\t} else {\n\t\tn.LastChild = newChild\n\t}\n\tnewChild.Parent = n\n\tnewChild.PrevSibling = prev\n\tnewChild.NextSibling = next\n}\n\n// AppendChild adds a node c as a child of n.\n//\n// It will panic if c already has a parent or siblings.\nfunc (n *VGNode) AppendChild(c *VGNode) {\n\tif c.Parent != nil || c.PrevSibling != nil || c.NextSibling != nil {\n\t\tpanic(\"html: AppendChild called for an attached child Node\")\n\t}\n\tlast := n.LastChild\n\tif last != nil {\n\t\tlast.NextSibling = c\n\t} else {\n\t\tn.FirstChild = c\n\t}\n\tn.LastChild = c\n\tc.Parent = n\n\tc.PrevSibling = last\n}\n\n// RemoveChild removes a node c that is a child of n. Afterwards, c will have\n// no parent and no siblings.\n//\n// It will panic if c's parent is not n.\nfunc (n *VGNode) RemoveChild(c *VGNode) {\n\tif c.Parent != n {\n\t\tpanic(\"html: RemoveChild called for a non-child Node\")\n\t}\n\tif n.FirstChild == c {\n\t\tn.FirstChild = c.NextSibling\n\t}\n\tif c.NextSibling != nil {\n\t\tc.NextSibling.PrevSibling = c.PrevSibling\n\t}\n\tif n.LastChild == c {\n\t\tn.LastChild = c.PrevSibling\n\t}\n\tif c.PrevSibling != nil {\n\t\tc.PrevSibling.NextSibling = c.NextSibling\n\t}\n\tc.Parent = nil\n\tc.PrevSibling = nil\n\tc.NextSibling = nil\n}\n\n// type IfFunc func(data interface{}) (bool, error)\n\n// Walk will walk the tree under a VGNode using the specified callback function.\n// If the function provided returns a non-nil error then walking will be stopped\n// and this error will be returned.  Only FirstChild and NextSibling are used\n// while walking and so with well-formed documents should not loop. (But loops\n// created manually by modifying FirstChild or NextSibling pointers could cause\n// this function to recurse indefinitely.)  Note that f may modify nodes as it\n// visits them with predictable results as long as it does not modify elements\n// higher on the tree (up, toward the parent); it is safe to modify self and children.\nfunc (n *VGNode) Walk(f func(*VGNode) error) error {\n\tif n == nil {\n\t\treturn nil\n\t}\n\terr := f(n)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = n.FirstChild.Walk(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = n.NextSibling.Walk(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AddAttrInterface sets an attribute based on the given interface. The followings types are supported\n// - string - value is used as attr value as it is\n// - int,float,... - the value is converted to string with strconv and used as attr value\n// - bool - treat the attribute as a flag. If false, the attribute will be ignored, if true outputs the attribute without a value\n// - fmt.Stringer - if the value implements fmt.Stringer, the returned string of StringVar() is used\n// - ptr - If the ptr is nil, the attribute will be ignored. Else, the rules above apply\n// any other type is handled via fmt.Sprintf()\nfunc (n *VGNode) AddAttrInterface(key string, val interface{}) {\n\t// ignore nil attributes\n\tif val == nil {\n\t\treturn\n\t}\n\n\tnattr := VGAttribute{\n\t\tKey: key,\n\t}\n\n\tswitch v := val.(type) {\n\tcase string:\n\t\tnattr.Val = v\n\tcase int:\n\t\tnattr.Val = strconv.Itoa(v)\n\tcase int8:\n\t\tnattr.Val = strconv.Itoa(int(v))\n\tcase int16:\n\t\tnattr.Val = strconv.Itoa(int(v))\n\tcase int32:\n\t\tnattr.Val = strconv.Itoa(int(v))\n\tcase int64:\n\t\tnattr.Val = strconv.FormatInt(v, 10)\n\tcase uint:\n\t\tnattr.Val = strconv.FormatUint(uint64(v), 10)\n\tcase uint8:\n\t\tnattr.Val = strconv.FormatUint(uint64(v), 10)\n\tcase uint16:\n\t\tnattr.Val = strconv.FormatUint(uint64(v), 10)\n\tcase uint32:\n\t\tnattr.Val = strconv.FormatUint(uint64(v), 10)\n\tcase uint64:\n\t\tnattr.Val = strconv.FormatUint(v, 10)\n\tcase float32:\n\t\tnattr.Val = strconv.FormatFloat(float64(v), 'f', 6, 32)\n\tcase float64:\n\t\tnattr.Val = strconv.FormatFloat(v, 'f', 6, 64)\n\tcase bool:\n\t\tif !v {\n\t\t\treturn\n\t\t}\n\t\t// FIXME: according to the HTML spec this is valid for flags, but not pretty\n\t\t// To change this, we have to adopt the changes inside the domrender and staticrender too.\n\t\tnattr.Val = key\n\tcase fmt.Stringer:\n\t\t// we have to check that the given interface does not hide a nil ptr\n\t\tif p := reflect.ValueOf(val); p.Kind() == reflect.Ptr && p.IsNil() {\n\t\t\treturn\n\t\t}\n\t\tnattr.Val = v.String()\n\tdefault:\n\t\t// check if this is a ptr\n\t\trv := reflect.ValueOf(val)\n\t\tif rv.Kind() == reflect.Ptr {\n\t\t\tif rv.IsNil() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// indirect the ptr and recurse\n\t\t\tif !rvIsZero(rv) {\n\t\t\t\tn.AddAttrInterface(key, reflect.Indirect(rv).Interface())\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\t// fall back to fmt\n\t\tnattr.Val = fmt.Sprintf(\"%v\", val)\n\t}\n\n\tn.Attr = append(n.Attr, nattr)\n}\n\n// AddAttrList takes a VGAttributeLister and sets the returned attributes to the node\nfunc (n *VGNode) AddAttrList(lister VGAttributeLister) {\n\tn.Attr = append(n.Attr, lister.AttributeList()...)\n}\n\n// SetInnerHTML assigns the InnerHTML field with useful logic based on the type of input.\n// Values of string type are escaped using html.EscapeString().  Values in the\n// int or float type families or bool are converted to a string using the strconv package\n// (no escaping is required).  Nil values set InnerHTML to nil.  Non-nil pointers\n// are followed and the same rules applied.  Values implementing HTMLer will have their\n// HTML() method called and the result put into InnerHTML without escaping.\n// Values implementing fmt.Stringer have thier String() method called and the escaped result\n// used as in string above.\n//\n// All other values have undefined behavior but are currently handled by setting InnerHTML\n// to the result of: `html.EscapeString(fmt.Sprintf(\"%v\", val))`\nfunc (n *VGNode) SetInnerHTML(val interface{}) {\n\n\tvar s string\n\n\tif val == nil {\n\t\tn.InnerHTML = nil\n\t\treturn\n\t}\n\n\tswitch v := val.(type) {\n\tcase string:\n\t\ts = html.EscapeString(v)\n\tcase int:\n\t\ts = strconv.Itoa(v)\n\tcase int8:\n\t\ts = strconv.Itoa(int(v))\n\tcase int16:\n\t\ts = strconv.Itoa(int(v))\n\tcase int32:\n\t\ts = strconv.Itoa(int(v))\n\tcase int64:\n\t\ts = strconv.FormatInt(v, 10)\n\tcase uint:\n\t\ts = strconv.FormatUint(uint64(v), 10)\n\tcase uint8:\n\t\ts = strconv.FormatUint(uint64(v), 10)\n\tcase uint16:\n\t\ts = strconv.FormatUint(uint64(v), 10)\n\tcase uint32:\n\t\ts = strconv.FormatUint(uint64(v), 10)\n\tcase uint64:\n\t\ts = strconv.FormatUint(v, 10)\n\tcase float32:\n\t\ts = strconv.FormatFloat(float64(v), 'f', 6, 32)\n\tcase float64:\n\t\ts = strconv.FormatFloat(v, 'f', 6, 64)\n\tcase bool:\n\t\t// I don't see any use in making false result in no output in this case.\n\t\t// I'm guessing if someone puts a bool in vg-content/vg-html\n\t\t// they are expecting it to print out the text \"true\" or \"false\".\n\t\t// It's different from AddAttrInterface but I think appropriate here.\n\t\ts = strconv.FormatBool(v)\n\n\tcase HTMLer:\n\t\ts = v.HTML()\n\n\tcase fmt.Stringer:\n\t\t// we have to check that the given interface does not hide a nil ptr\n\t\tif p := reflect.ValueOf(val); p.Kind() == reflect.Ptr && p.IsNil() {\n\t\t\tn.InnerHTML = nil\n\t\t\treturn\n\t\t}\n\t\ts = html.EscapeString(v.String())\n\tdefault:\n\t\t// check if this is a ptr\n\t\trv := reflect.ValueOf(val)\n\n\t\tif rv.Kind() == reflect.Ptr {\n\t\t\tif rv.IsNil() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !rvIsZero(rv) {\n\t\t\t\tindirected := reflect.Indirect(rv)\n\t\t\t\tif !indirected.IsNil() {\n\t\t\t\t\tn.SetInnerHTML(indirected.Interface())\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// fall back to fmt\n\t\ts = html.EscapeString(fmt.Sprintf(\"%v\", val))\n\t}\n\n\tn.InnerHTML = &s\n}\n\n// JSValueHandler does something with a js.Value\ntype JSValueHandler interface {\n\tJSValueHandle(js.Value)\n}\n\n// JSValueFunc implements JSValueHandler as a function.\ntype JSValueFunc func(js.Value)\n\n// JSValueHandle implements the JSValueHandler interface.\nfunc (f JSValueFunc) JSValueHandle(v js.Value) { f(v) }\n"
        },
        {
          "name": "vgnode_test.go",
          "type": "blob",
          "size": 2.7998046875,
          "content": "package vugu\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\t// \"github.com/vugu/html\"\n\t// \"github.com/vugu/html/atom\"\n\t// html \"golang.org/x/net/html\"\n\t// atom \"golang.org/x/net/html/atom\"\n)\n\n//go:noinline\nfunc allocVGNode() *VGNode {\n\tvar ret VGNode\n\treturn &ret\n}\n\nfunc BenchmarkAlloc(b *testing.B) {\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tv := allocVGNode()\n\t\t_ = v\n\t}\n\n}\n\nvar vgnodePool = sync.Pool{New: func() interface{} { return &VGNode{} }}\n\nfunc BenchmarkPool(b *testing.B) {\n\n\tobjlist := make([]*VGNode, 0, 10)\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tv := vgnodePool.Get().(*VGNode)\n\t\t*v = VGNode{} // zero it out\n\n\t\t// stack up 10 at a time and then release them to the pool\n\t\tobjlist = append(objlist, v)\n\t\tif len(objlist) >= 10 {\n\t\t\tfor _, o := range objlist {\n\t\t\t\tvgnodePool.Put(o)\n\t\t\t}\n\t\t\tobjlist = objlist[:0]\n\t\t}\n\t}\n\n}\n\n// func TestFuncPtr(t *testing.T) {\n\n// \ts1 := \"s1\"\n// \ts2 := \"s2\"\n\n// \tfA := fp(&s1)\n// \tfB := fp(&s1)\n// \tfC := fp(&s2)\n\n// \tlog.Printf(\"fA()=%v, fB()=%v, fC()=%v\", fA(), fB(), fC())\n\n// \t// log.Printf(\"fA=%v, fB=%v, fC=%v\", unsafe.Pointer(fA), unsafe.Pointer(fB), unsafe.Pointer(fC))\n// \t// log.Printf(\"fA=%v, fB=%v, fC=%v\", fA, fB, fC)\n// \tlog.Printf(\"fA=%v, fB=%v, fC=%v\", reflect.ValueOf(fA).Pointer(), reflect.ValueOf(fB).Pointer(), reflect.ValueOf(fC).Pointer())\n\n// \tlog.Printf(\"fA==fB=%v, fA==fC=%v\", fA == fB, fA == fC)\n\n// }\n\n// func fp(strp *string) func() string {\n// \t// capture one variable\n// \treturn func() string {\n// \t\treturn *strp\n// \t}\n// }\n\n// func TestParseTemplate(t *testing.T) {\n\n// \tassert := assert.New(t)\n\n// \tin := `\n// <div id=\"whatever\">\n// \t<ul>\n// \t\t<li vg-if=\".Test1\" vg-range=\".Test2\" @click=\"something\" :testbind=\"bound\">Blah!</li>\n// \t</ul>\n// </div>\n// `\n\n// \tn, err := ParseTemplate(bytes.NewReader([]byte(in)))\n// \tassert.NoError(err)\n// \tassert.NotNil(n)\n\n// \tfound := false\n// \tassert.NoError(n.Walk(func(v *VGNode) error {\n// \t\tif v.Type == ElementNode && v.Data == \"li\" {\n// \t\t\tfound = true\n// \t\t\tassert.Equal(\".Test1\", v.VGIf.Val)\n// \t\t\tassert.Equal(\".Test2\", v.VGRange.Val)\n// \t\t\tassert.Equal(\"@click\", v.EventAttr[0].Key)\n// \t\t\tassert.Equal(\":testbind\", v.BindAttr[0].Key)\n// \t\t\tassert.Equal(\"bound\", v.BindAttr[0].Val)\n// \t\t}\n// \t\treturn nil\n// \t}))\n// \tassert.True(found)\n\n// }\n\n// func TestTmp(t *testing.T) {\n\n// \tinRaw := []byte(`<li>hello</li>\n\n// <script type=\"application/x-go\">\n\n// type DemoLine struct {\n// \tNum int\n// }\n\n// </script>\n// `)\n\n// \tnlist, err := html.ParseFragment(bytes.NewReader(inRaw), &html.Node{\n// \t\tType:     html.ElementNode,\n// \t\tDataAtom: atom.Body,\n// \t\tData:     \"body\",\n// \t})\n// \tif err != nil {\n// \t\tpanic(err)\n// \t}\n\n// \tvar buf bytes.Buffer\n// \tfor i := range nlist {\n// \t\tlog.Printf(\"%#v\\n\", nlist[i])\n// \t\terr = html.Render(&buf, nlist[i])\n// \t\tif err != nil {\n// \t\t\tpanic(err)\n// \t\t}\n// \t}\n\n// \tlog.Printf(\"OUT: %s\", buf.String())\n\n// }\n"
        },
        {
          "name": "vugufmt",
          "type": "tree",
          "content": null
        },
        {
          "name": "wasm-test-suite",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}