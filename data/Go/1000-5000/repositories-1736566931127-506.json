{
  "metadata": {
    "timestamp": 1736566931127,
    "page": 506,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "connectrpc/connect-go",
      "stars": 3096,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.04296875,
          "content": "/.tmp/\n*.pprof\n*.svg\ncover.out\nconnect.test\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 4.833984375,
          "content": "linters-settings:\n  errcheck:\n    check-type-assertions: true\n  exhaustruct:\n    include:\n      # No zero values for param structs.\n      - 'connectrpc\\.com/connect\\..*[pP]arams'\n  forbidigo:\n    forbid:\n      - '^fmt\\.Print'\n      - '^log\\.'\n      - '^print$'\n      - '^println$'\n      - '^panic$'\n  godox:\n    # TODO, OPT, etc. comments are fine to commit. Use FIXME comments for\n    # temporary hacks, and use godox to prevent committing them.\n    keywords: [FIXME]\n  importas:\n    no-unaliased: true\n    alias:\n      - pkg: connectrpc.com/connect/internal/gen/connect/ping/v1\n        alias: pingv1\n  varnamelen:\n    ignore-decls:\n      - T any\n      - i int\n      - wg sync.WaitGroup\nlinters:\n  enable-all: true\n  disable:\n    - cyclop            # covered by gocyclo\n    - depguard          # unnecessary for small libraries\n    - execinquery       # deprecated since golangci v1.58\n    - funlen            # rely on code review to limit function length\n    - gocognit          # dubious \"cognitive overhead\" quantification\n    - gofumpt           # prefer standard gofmt\n    - goimports         # rely on gci instead\n    - gomnd             # some unnamed constants are okay\n    - inamedparam       # convention is not followed\n    - ireturn           # \"accept interfaces, return structs\" isn't ironclad\n    - lll               # don't want hard limits for line length\n    - maintidx          # covered by gocyclo\n    - mnd               # status codes are clearer than constants\n    - nlreturn          # generous whitespace violates house style\n    - nonamedreturns    # named returns are fine; it's *bare* returns that are bad\n    - protogetter       # too many false positives\n    - testpackage       # internal tests are fine\n    - wrapcheck         # don't _always_ need to wrap errors\n    - wsl               # generous whitespace violates house style\nissues:\n  exclude-dirs-use-default: false\n\n  exclude:\n    # Don't ban use of fmt.Errorf to create new errors, but the remaining\n    # checks from err113 are useful.\n    - \"do not define dynamic errors, use wrapped static errors instead: .*\"\n\n  exclude-rules:\n    # If future reflect.Kinds are nil-able, we'll find out when a test fails.\n    - linters: [exhaustive]\n      path: internal/assert/assert.go\n    # We need our duplex HTTP call to have access to the context.\n    - linters: [containedctx]\n      path: duplex_http_call.go\n    # We need to init a global in-mem HTTP server for testable examples.\n    - linters: [gochecknoinits, gochecknoglobals]\n      path: example_init_test.go\n    # We purposefully do an ineffectual assignment for an example.\n    - linters: [ineffassign]\n      path: client_example_test.go\n    # The generated file is effectively a global receiver.\n    - linters: [varnamelen]\n      path: cmd/protoc-gen-connect-go\n      text: \"parameter name 'g' is too short\"\n    # Thorough error logging and timeout config make this example unreadably long.\n    - linters: [errcheck, gosec]\n      path: error_writer_example_test.go\n    # It should be crystal clear that Connect uses plain *http.Clients.\n    - linters: [revive, stylecheck]\n      path: client_example_test.go\n    # Don't complain about timeout management or lack of output assertions in examples.\n    - linters: [gosec, testableexamples]\n      path: handler_example_test.go\n    # No output assertions needed for these examples.\n    - linters: [testableexamples]\n      path: error_writer_example_test.go\n    - linters: [testableexamples]\n      path: error_not_modified_example_test.go\n    - linters: [testableexamples]\n      path: error_example_test.go\n    # In examples, it's okay to use http.ListenAndServe.\n    - linters: [gosec]\n      path: error_not_modified_example_test.go\n    # There are many instances where we want to keep unused parameters\n    # as a matter of style or convention, for example when a context.Context\n    # is the first parameter, we choose to just globally ignore this.\n    - linters: [revive]\n      text: \"^unused-parameter: \"\n    # We want to return explicit nils in protocol_grpc.go\n    - linters: [revive]\n      text: \"^if-return: \"\n      path: protocol_grpc.go\n    # We want to return explicit nils in protocol_connect.go\n    - linters: [revive]\n      text: \"^if-return: \"\n      path: protocol_connect.go\n    # We want to return explicit nils in error_writer.go\n    - linters: [revive]\n      text: \"^if-return: \"\n      path: error_writer.go\n    # We want to set http.Server's logger\n    - linters: [forbidigo]\n      path: internal/memhttp\n      text: \"use of `log.(New|Logger|Lshortfile)` forbidden by pattern .*\"\n    # We want to show examples with http.Get\n    - linters: [noctx]\n      path: internal/memhttp/memhttp_test.go\n    # Allow fmt.Sprintf for cmd/protoc-gen-connect-go for consistency\n    - linters: [perfsprint]\n      path: cmd/protoc-gen-connect-go/main.go\n    # Allow non-canonical headers in tests\n    - linters: [canonicalheader]\n      path: '.*_test.go'\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.087890625,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2021-2024 The Connect Authors\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MAINTAINERS.md",
          "type": "blob",
          "size": 0.4658203125,
          "content": "Maintainers\n===========\n\n## Current\n* [Peter Edge](https://github.com/bufdev), [Buf](https://buf.build)\n* [Akshay Shah](https://github.com/akshayjshah), [Buf](https://buf.build)\n* [Josh Humphries](https://github.com/jhump), [Buf](https://buf.build)\n* [Matt Robenolt](https://github.com/mattrobenolt), [PlanetScale](https://planetscale.com)\n* [Edward McFarlane](https://github.com/emcfarlane), [Buf](https://buf.build)\n\n## Former\n* [Alex McKinney](https://github.com/amckinney)\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.5166015625,
          "content": "# See https://tech.davis-hansson.com/p/make/\nSHELL := bash\n.DELETE_ON_ERROR:\n.SHELLFLAGS := -eu -o pipefail -c\n.DEFAULT_GOAL := all\nMAKEFLAGS += --warn-undefined-variables\nMAKEFLAGS += --no-builtin-rules\nMAKEFLAGS += --no-print-directory\nBIN := .tmp/bin\nexport PATH := $(BIN):$(PATH)\nexport GOBIN := $(abspath $(BIN))\nCOPYRIGHT_YEARS := 2021-2024\nLICENSE_IGNORE := --ignore /testdata/\nBUF_VERSION := 1.47.2\n\n.PHONY: help\nhelp: ## Describe useful make targets\n\t@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = \":.*?## \"}; {printf \"%-30s %s\\n\", $$1, $$2}'\n\n.PHONY: all\nall: ## Build, test, and lint (default)\n\t$(MAKE) test\n\t$(MAKE) lint\n\n.PHONY: clean\nclean: ## Delete intermediate build artifacts\n\t@# -X only removes untracked files, -d recurses into directories, -f actually removes files/dirs\n\tgit clean -Xdf\n\n.PHONY: test\ntest: shorttest slowtest\n\n.PHONY: shorttest\nshorttest: build ## Run unit tests\n\tgo test -vet=off -race -cover -short ./...\n\n.PHONY: slowtest\n# Runs all tests, including known long/slow ones. The\n# race detector is not used for a few reasons:\n#  1. Race coverage of the short tests should be\n#     adequate to catch race conditions.\n#  2. It slows tests down, which is not good if we\n#     know these are already slow tests.\n#  3. Some of the slow tests can't repro issues and\n#     find regressions as reliably with the race\n#     detector enabled.\nslowtest: build\n\tgo test ./...\n\n.PHONY: runconformance\nrunconformance: build ## Run conformance test suite\n\tcd internal/conformance && ./runconformance.sh\n\n.PHONY: bench\nbench: BENCH ?= .*\nbench: build ## Run benchmarks for root package\n\tgo test -vet=off -run '^$$' -bench '$(BENCH)' -benchmem -cpuprofile cpu.pprof -memprofile mem.pprof .\n\n.PHONY: build\nbuild: generate ## Build all packages\n\tgo build ./...\n\n.PHONY: install\ninstall: ## Install all binaries\n\tgo install ./...\n\n.PHONY: lint\nlint: $(BIN)/golangci-lint $(BIN)/buf ## Lint Go and protobuf\n\tgo vet ./...\n\tgolangci-lint run --modules-download-mode=readonly --timeout=3m0s\n\tbuf lint\n\tbuf format -d --exit-code\n\n.PHONY: lintfix\nlintfix: $(BIN)/golangci-lint $(BIN)/buf ## Automatically fix some lint errors\n\tgolangci-lint run --fix --modules-download-mode=readonly --timeout=3m0s\n\tbuf format -w\n\n.PHONY: generate\ngenerate: $(BIN)/buf $(BIN)/protoc-gen-go $(BIN)/protoc-gen-connect-go $(BIN)/license-header ## Regenerate code and licenses\n\tgo mod tidy\n\trm -rf internal/gen\n\tPATH=\"$(abspath $(BIN))\" buf generate\n\t( cd cmd/protoc-gen-connect-go; ./generate.sh )\n\tlicense-header \\\n\t\t--license-type apache \\\n\t\t--copyright-holder \"The Connect Authors\" \\\n\t\t--year-range \"$(COPYRIGHT_YEARS)\" $(LICENSE_IGNORE)\n\n.PHONY: upgrade\nupgrade: ## Upgrade dependencies\n\tgo get -u -t ./... && go mod tidy -v\n\n.PHONY: checkgenerate\ncheckgenerate:\n\t@# Used in CI to verify that `make generate` doesn't produce a diff.\n\ttest -z \"$$(git status --porcelain | tee /dev/stderr)\"\n\n.PHONY: $(BIN)/protoc-gen-connect-go\n$(BIN)/protoc-gen-connect-go:\n\t@mkdir -p $(@D)\n\tgo build -o $(@) ./cmd/protoc-gen-connect-go\n\n$(BIN)/buf: Makefile\n\t@mkdir -p $(@D)\n\tgo install github.com/bufbuild/buf/cmd/buf@v${BUF_VERSION}\n\n$(BIN)/license-header: Makefile\n\t@mkdir -p $(@D)\n\tgo install github.com/bufbuild/buf/private/pkg/licenseheader/cmd/license-header@v${BUF_VERSION}\n\n$(BIN)/golangci-lint: Makefile\n\t@mkdir -p $(@D)\n\tgo install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.60.0\n\n$(BIN)/protoc-gen-go: Makefile go.mod\n\t@mkdir -p $(@D)\n\t@# The version of protoc-gen-go is determined by the version in go.mod\n\tgo install google.golang.org/protobuf/cmd/protoc-gen-go\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.8564453125,
          "content": "Connect\n=======\n\n[![Build](https://github.com/connectrpc/connect-go/actions/workflows/ci.yaml/badge.svg?branch=main)](https://github.com/connectrpc/connect-go/actions/workflows/ci.yaml)\n[![Report Card](https://goreportcard.com/badge/connectrpc.com/connect)](https://goreportcard.com/report/connectrpc.com/connect)\n[![GoDoc](https://pkg.go.dev/badge/connectrpc.com/connect.svg)](https://pkg.go.dev/connectrpc.com/connect)\n[![Slack](https://img.shields.io/badge/slack-buf-%23e01563)][slack]\n[![OpenSSF Best Practices](https://www.bestpractices.dev/projects/8972/badge)](https://www.bestpractices.dev/projects/8972)\n\nConnect is a slim library for building browser and gRPC-compatible HTTP APIs.\nYou write a short [Protocol Buffer][protobuf] schema and implement your\napplication logic, and Connect generates code to handle marshaling, routing,\ncompression, and content type negotiation. It also generates an idiomatic,\ntype-safe client. Handlers and clients support three protocols: gRPC, gRPC-Web,\nand Connect's own protocol.\n\nThe [Connect protocol][protocol] is a simple protocol that works over HTTP/1.1\nor HTTP/2. It takes the best portions of gRPC and gRPC-Web, including\nstreaming, and packages them into a protocol that works equally well in\nbrowsers, monoliths, and microservices. Calling a Connect API is as easy as\nusing `curl`. Try it with our live demo:\n\n```\ncurl \\\n    --header \"Content-Type: application/json\" \\\n    --data '{\"sentence\": \"I feel happy.\"}' \\\n    https://demo.connectrpc.com/connectrpc.eliza.v1.ElizaService/Say\n```\n\nHandlers and clients also support the gRPC and gRPC-Web protocols, including\nstreaming, headers, trailers, and error details. gRPC-compatible [server\nreflection][grpcreflect] and [health checks][grpchealth] are available as\nstandalone packages. Instead of cURL, we could call our API with a gRPC client:\n\n```\ngo install github.com/bufbuild/buf/cmd/buf@latest\nbuf curl --protocol grpc \\\n    --data '{\"sentence\": \"I feel happy.\"}' \\\n    https://demo.connectrpc.com/connectrpc.eliza.v1.ElizaService/Say\n```\n\nUnder the hood, Connect is just [Protocol Buffers][protobuf] and the standard\nlibrary: no custom HTTP implementation, no new name resolution or load\nbalancing APIs, and no surprises. Everything you already know about `net/http`\nstill applies, and any package that works with an `http.Server`, `http.Client`,\nor `http.Handler` also works with Connect.\n\nFor more on Connect, see the [announcement blog post][blog], the documentation\non [connectrpc.com][docs] (especially the [Getting Started] guide for Go), the\n[demo service][examples-go], or the [protocol specification][protocol].\n\n## A small example\n\nCurious what all this looks like in practice? From a [Protobuf\nschema](internal/proto/connect/ping/v1/ping.proto), we generate [a small RPC\npackage](internal/gen/connect/ping/v1/pingv1connect/ping.connect.go). Using that\npackage, we can build a server:\n\n```go\npackage main\n\nimport (\n  \"context\"\n  \"log\"\n  \"net/http\"\n\n  \"connectrpc.com/connect\"\n  pingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n  \"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n  \"golang.org/x/net/http2\"\n  \"golang.org/x/net/http2/h2c\"\n)\n\ntype PingServer struct {\n  pingv1connect.UnimplementedPingServiceHandler // returns errors from all methods\n}\n\nfunc (ps *PingServer) Ping(\n  ctx context.Context,\n  req *connect.Request[pingv1.PingRequest],\n) (*connect.Response[pingv1.PingResponse], error) {\n  // connect.Request and connect.Response give you direct access to headers and\n  // trailers. No context-based nonsense!\n  log.Println(req.Header().Get(\"Some-Header\"))\n  res := connect.NewResponse(&pingv1.PingResponse{\n    // req.Msg is a strongly-typed *pingv1.PingRequest, so we can access its\n    // fields without type assertions.\n    Number: req.Msg.Number,\n  })\n  res.Header().Set(\"Some-Other-Header\", \"hello!\")\n  return res, nil\n}\n\nfunc main() {\n  mux := http.NewServeMux()\n  // The generated constructors return a path and a plain net/http\n  // handler.\n  mux.Handle(pingv1connect.NewPingServiceHandler(&PingServer{}))\n  err := http.ListenAndServe(\n    \"localhost:8080\",\n    // For gRPC clients, it's convenient to support HTTP/2 without TLS. You can\n    // avoid x/net/http2 by using http.ListenAndServeTLS.\n    h2c.NewHandler(mux, &http2.Server{}),\n  )\n  log.Fatalf(\"listen failed: %v\", err)\n}\n```\n\nWith that server running, you can make requests with any gRPC or Connect\nclient. To write a client using Connect,\n\n```go\npackage main\n\nimport (\n  \"context\"\n  \"log\"\n  \"net/http\"\n\n  \"connectrpc.com/connect\"\n  pingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n  \"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n)\n\nfunc main() {\n  client := pingv1connect.NewPingServiceClient(\n    http.DefaultClient,\n    \"http://localhost:8080/\",\n  )\n  req := connect.NewRequest(&pingv1.PingRequest{\n    Number: 42,\n  })\n  req.Header().Set(\"Some-Header\", \"hello from connect\")\n  res, err := client.Ping(context.Background(), req)\n  if err != nil {\n    log.Fatalln(err)\n  }\n  log.Println(res.Msg)\n  log.Println(res.Header().Get(\"Some-Other-Header\"))\n}\n```\n\nOf course, `http.ListenAndServe` and `http.DefaultClient` aren't fit for\nproduction use! See Connect's [deployment docs][docs-deployment] for a guide to\nconfiguring timeouts, connection pools, observability, and h2c.\n\n## Ecosystem\n\n* [grpchealth]: gRPC-compatible health checks\n* [grpcreflect]: gRPC-compatible server reflection\n* [examples-go]: service powering demo.connectrpc.com, including bidi streaming\n* [connect-es]: Type-safe APIs with Protobuf and TypeScript\n* [Buf Studio]: web UI for ad-hoc RPCs\n* [conformance]: Connect, gRPC, and gRPC-Web interoperability tests\n\n## Status: Stable\n\nThis module is stable. It supports:\n\n* The three most recent major releases of Go. Keep in mind that [only the last\n  two releases receive security patches][go-support-policy].\n* [APIv2] of Protocol Buffers in Go (`google.golang.org/protobuf`).\n\nWithin those parameters, `connect` follows semantic versioning. We will\n_not_ make breaking changes in the 1.x series of releases.\n\n## Legal\n\nOffered under the [Apache 2 license][license].\n\n[APIv2]: https://blog.golang.org/protobuf-apiv2\n[Buf Studio]: https://buf.build/studio\n[Getting Started]: https://connectrpc.com/docs/go/getting-started\n[blog]: https://buf.build/blog/connect-a-better-grpc\n[conformance]: https://github.com/connectrpc/conformance\n[grpchealth]: https://github.com/connectrpc/grpchealth-go\n[grpcreflect]: https://github.com/connectrpc/grpcreflect-go\n[connect-es]: https://github.com/connectrpc/connect-es\n[examples-go]: https://github.com/connectrpc/examples-go\n[docs-deployment]: https://connectrpc.com/docs/go/deployment\n[docs]: https://connectrpc.com\n[go-support-policy]: https://golang.org/doc/devel/release#policy\n[license]: https://github.com/connectrpc/connect-go/blob/main/LICENSE\n[protobuf]: https://developers.google.com/protocol-buffers\n[protocol]: https://connectrpc.com/docs/protocol\n[slack]: https://buf.build/links/slack\n"
        },
        {
          "name": "RELEASE.md",
          "type": "blob",
          "size": 3.208984375,
          "content": "# Releasing connect-go\n\nThis document outlines how to create a release of connect-go.\n\n1. Clone the repo, ensuring you have the latest main.\n\n2. On a new branch, open [connect.go](connect.go) and change the `Version` constant to an appropriate [semantic version](https://semver.org/). To select the correct version, look at the version number of the [latest release] and the changes that are included in this new release.\n  * If there are only bug fixes and no new features, remove the `-dev` suffix, set MINOR number to be equal to the [latest release], and set the PATCH number to be 1 more than the PATCH number of the [latest release].\n  * If there are features being released, remove the `-dev` suffix, set the MINOR number to be 1 more than the MINOR number of the [latest release], and set the PATCH number to `0`. In the common case, the diff here will just be to remove the `-dev` suffix.\n\n   ```patch\n   -const Version = \"1.14.0-dev\"\n   +const Version = \"1.14.0\"\n   ```\n\n3. Check for any changes in [cmd/protoc-gen-connect-go/main.go](cmd/protoc-gen-connect-go/main.go) that require a version restriction. A constant `IsAtLeastVersionX_Y_Z` should be defined in [connect.go](connect.go) if generated code has begun to use a new API. Make sure the generated code references this constant. If a new constant has been added since the last release, ensure that the name of the constant matches the version being released ([Example PR #496](https://github.com/connectrpc/connect-go/pull/496)).\n\n4. Open a PR titled \"Prepare for vX.Y.Z\" ([Example PR #661](https://github.com/connectrpc/connect-go/pull/661)) and a description tagging all current maintainers. Once it's reviewed and CI passes, merge it.\n\n    *Make sure no new commits are merged until the release is complete.*\n\n5. Review all commits in the new release and for each PR check an appropriate label is used and edit the title to be meaninful to end users. This will help auto-generated release notes match the final notes as closely as possible.\n\n6. Using the Github UI, create a new release.\n    - Under “Choose a tag”, type in “vX.Y.Z” to create a new tag for the release upon publish.\n    - Target the main branch.\n    - Title the Release “vX.Y.Z”.\n    - Click “set as latest release”.\n    - Set the last version as the “Previous tag”.\n    - Click “Generate release notes” to autogenerate release notes.\n    - Edit the release notes. A summary and other sub categories may be added if required but should, in most cases, be left as ### Enhancements and ### Bugfixes. Feel free to collect multiple small changes to docs or Github config into one line, but try to tag every contributor. Make especially sure to credit new external contributors!\n\n7. Publish the release.\n\n8. On a new branch, open [connect.go](connect.go) and change the `Version` to increment the minor tag and append the `-dev` suffix. Use the next minor release - we never anticipate bugs and patch releases.\n\n   ```patch\n   -const Version = \"1.14.0\"\n   +const Version = \"1.15.0-dev\"\n   ```\n\n9. Open a PR titled \"Back to development\" ([Example PR #662](https://github.com/connectrpc/connect-go/pull/662)). Once it's reviewed and CI passes, merge it.\n\n[latest release]: https://github.com/connectrpc/connect-go/releases/latest\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.15234375,
          "content": "Security Policy\n===============\n\nThis project follows the [Connect security policy and reporting\nprocess](https://connectrpc.com/docs/governance/security).\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 7.4736328125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\n\tconnect \"connectrpc.com/connect\"\n\t\"connectrpc.com/connect/internal/assert\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n)\n\nfunc BenchmarkConnect(b *testing.B) {\n\tmux := http.NewServeMux()\n\tmux.Handle(\n\t\tpingv1connect.NewPingServiceHandler(\n\t\t\t&ExamplePingServer{},\n\t\t),\n\t)\n\tserver := httptest.NewUnstartedServer(mux)\n\tserver.EnableHTTP2 = true\n\tserver.StartTLS()\n\tb.Cleanup(server.Close)\n\n\thttpClient := server.Client()\n\thttpTransport, ok := httpClient.Transport.(*http.Transport)\n\tassert.True(b, ok)\n\thttpTransport.DisableCompression = true\n\n\tclients := []struct {\n\t\tname string\n\t\topts []connect.ClientOption\n\t}{{\n\t\tname: \"connect\",\n\t\topts: []connect.ClientOption{},\n\t}, {\n\t\tname: \"grpc\",\n\t\topts: []connect.ClientOption{\n\t\t\tconnect.WithGRPC(),\n\t\t},\n\t}, {\n\t\tname: \"grpcweb\",\n\t\topts: []connect.ClientOption{\n\t\t\tconnect.WithGRPCWeb(),\n\t\t},\n\t}}\n\n\ttwoMiB := strings.Repeat(\"a\", 2*1024*1024)\n\tfor _, client := range clients {\n\t\tb.Run(client.name, func(b *testing.B) {\n\t\t\tclient := pingv1connect.NewPingServiceClient(\n\t\t\t\thttpClient,\n\t\t\t\tserver.URL,\n\t\t\t\tconnect.WithSendGzip(),\n\t\t\t\tconnect.WithClientOptions(client.opts...),\n\t\t\t)\n\n\t\t\tctx := context.Background()\n\t\t\tb.Run(\"unary_big\", func(b *testing.B) {\n\t\t\t\tb.ReportAllocs()\n\t\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\t\tfor pb.Next() {\n\t\t\t\t\t\tif _, err := client.Ping(\n\t\t\t\t\t\t\tctx, connect.NewRequest(&pingv1.PingRequest{Text: twoMiB}),\n\t\t\t\t\t\t); err != nil {\n\t\t\t\t\t\t\tb.Error(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t\tb.Run(\"unary_small\", func(b *testing.B) {\n\t\t\t\tb.ReportAllocs()\n\t\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\t\tfor pb.Next() {\n\t\t\t\t\t\tresponse, err := client.Ping(\n\t\t\t\t\t\t\tctx, connect.NewRequest(&pingv1.PingRequest{Number: 42}),\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tb.Error(err)\n\t\t\t\t\t\t} else if num := response.Msg.GetNumber(); num != 42 {\n\t\t\t\t\t\t\tb.Errorf(\"expected 42, got %d\", num)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t\tb.Run(\"client_stream\", func(b *testing.B) {\n\t\t\t\tb.ReportAllocs()\n\t\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\t\tfor pb.Next() {\n\t\t\t\t\t\tconst (\n\t\t\t\t\t\t\tupTo   = 1\n\t\t\t\t\t\t\texpect = 1\n\t\t\t\t\t\t)\n\t\t\t\t\t\tstream := client.Sum(ctx)\n\t\t\t\t\t\tfor number := int64(1); number <= upTo; number++ {\n\t\t\t\t\t\t\tif err := stream.Send(&pingv1.SumRequest{Number: number}); err != nil {\n\t\t\t\t\t\t\t\tb.Error(err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresponse, err := stream.CloseAndReceive()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tb.Error(err)\n\t\t\t\t\t\t} else if got := response.Msg.GetSum(); got != expect {\n\t\t\t\t\t\t\tb.Errorf(\"expected %d, got %d\", expect, got)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t\tb.Run(\"server_stream\", func(b *testing.B) {\n\t\t\t\tb.ReportAllocs()\n\t\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\t\tfor pb.Next() {\n\t\t\t\t\t\tconst (\n\t\t\t\t\t\t\tupTo = 1\n\t\t\t\t\t\t)\n\t\t\t\t\t\trequest := connect.NewRequest(&pingv1.CountUpRequest{Number: upTo})\n\t\t\t\t\t\tstream, err := client.CountUp(ctx, request)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tb.Error(err)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumber := int64(1)\n\t\t\t\t\t\tfor ; stream.Receive(); number++ {\n\t\t\t\t\t\t\tif got := stream.Msg().GetNumber(); got != number {\n\t\t\t\t\t\t\t\tb.Errorf(\"expected %d, got %d\", number, got)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif number != upTo+1 {\n\t\t\t\t\t\t\tb.Errorf(\"expected %d, got %d\", upTo+1, number)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t\tb.Run(\"bidi_stream\", func(b *testing.B) {\n\t\t\t\tb.ReportAllocs()\n\t\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\t\tfor pb.Next() {\n\t\t\t\t\t\tconst (\n\t\t\t\t\t\t\tupTo = 1\n\t\t\t\t\t\t)\n\t\t\t\t\t\tstream := client.CumSum(ctx)\n\t\t\t\t\t\tnumber := int64(1)\n\t\t\t\t\t\tfor ; number <= upTo; number++ {\n\t\t\t\t\t\t\tif err := stream.Send(&pingv1.CumSumRequest{Number: number}); err != nil {\n\t\t\t\t\t\t\t\tb.Error(err)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmsg, err := stream.Receive()\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tb.Error(err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif got, expected := msg.GetSum(), number*(number+1)/2; got != expected {\n\t\t\t\t\t\t\t\tb.Errorf(\"expected %d, got %d\", expected, got)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif err := stream.CloseRequest(); err != nil {\n\t\t\t\t\t\t\tb.Error(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif err := stream.CloseResponse(); err != nil {\n\t\t\t\t\t\t\tb.Error(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n}\n\ntype ping struct {\n\tText string `json:\"text\"`\n}\n\nfunc BenchmarkREST(b *testing.B) {\n\thandler := func(writer http.ResponseWriter, request *http.Request) {\n\t\tdefer request.Body.Close()\n\t\tdefer func() {\n\t\t\t_, err := io.Copy(io.Discard, request.Body)\n\t\t\tassert.Nil(b, err)\n\t\t}()\n\t\twriter.Header().Set(\"Content-Type\", \"application/json\")\n\t\tvar body io.Reader = request.Body\n\t\tif request.Header.Get(\"Content-Encoding\") == \"gzip\" {\n\t\t\tgzipReader, err := gzip.NewReader(body)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatalf(\"get gzip reader: %v\", err)\n\t\t\t}\n\t\t\tdefer gzipReader.Close()\n\t\t\tbody = gzipReader\n\t\t}\n\t\tvar out io.Writer = writer\n\t\tif strings.Contains(request.Header.Get(\"Accept-Encoding\"), \"gzip\") {\n\t\t\twriter.Header().Set(\"Content-Encoding\", \"gzip\")\n\t\t\tgzipWriter := gzip.NewWriter(writer)\n\t\t\tdefer gzipWriter.Close()\n\t\t\tout = gzipWriter\n\t\t}\n\t\traw, err := io.ReadAll(body)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"read body: %v\", err)\n\t\t}\n\t\tvar pingRequest ping\n\t\tif err := json.Unmarshal(raw, &pingRequest); err != nil {\n\t\t\tb.Fatalf(\"json unmarshal: %v\", err)\n\t\t}\n\t\tbs, err := json.Marshal(&pingRequest)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"json marshal: %v\", err)\n\t\t}\n\t\t_, err = out.Write(bs)\n\t\tassert.Nil(b, err)\n\t}\n\n\tserver := httptest.NewUnstartedServer(http.HandlerFunc(handler))\n\tserver.EnableHTTP2 = true\n\tserver.StartTLS()\n\tb.Cleanup(server.Close)\n\ttwoMiB := strings.Repeat(\"a\", 2*1024*1024)\n\tb.ResetTimer()\n\n\tb.Run(\"unary\", func(b *testing.B) {\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tfor pb.Next() {\n\t\t\t\tunaryRESTIteration(b, server.Client(), server.URL, twoMiB)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc unaryRESTIteration(b *testing.B, client *http.Client, url string, text string) {\n\tb.Helper()\n\trawRequestBody := bytes.NewBuffer(nil)\n\tcompressedRequestBody := gzip.NewWriter(rawRequestBody)\n\tencoder := json.NewEncoder(compressedRequestBody)\n\tif err := encoder.Encode(&ping{text}); err != nil {\n\t\tb.Fatalf(\"marshal request: %v\", err)\n\t}\n\tcompressedRequestBody.Close()\n\trequest, err := http.NewRequestWithContext(\n\t\tcontext.Background(),\n\t\thttp.MethodPost,\n\t\turl,\n\t\trawRequestBody,\n\t)\n\tif err != nil {\n\t\tb.Fatalf(\"construct request: %v\", err)\n\t}\n\trequest.Header.Set(\"Content-Encoding\", \"gzip\")\n\trequest.Header.Set(\"Accept-Encoding\", \"gzip\")\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\tb.Fatalf(\"do request: %v\", err)\n\t}\n\tdefer func() {\n\t\t_, err := io.Copy(io.Discard, response.Body)\n\t\tassert.Nil(b, err)\n\t}()\n\tif response.StatusCode != http.StatusOK {\n\t\tb.Fatalf(\"response status: %v\", response.Status)\n\t}\n\tuncompressed, err := gzip.NewReader(response.Body)\n\tif err != nil {\n\t\tb.Fatalf(\"uncompress response: %v\", err)\n\t}\n\traw, err := io.ReadAll(uncompressed)\n\tif err != nil {\n\t\tb.Fatalf(\"read response: %v\", err)\n\t}\n\tvar got ping\n\tif err := json.Unmarshal(raw, &got); err != nil {\n\t\tb.Fatalf(\"unmarshal: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "buf.gen.yaml",
          "type": "blob",
          "size": 0.3125,
          "content": "version: v2\nmanaged:\n  enabled: true\n  override:\n    - file_option: go_package_prefix\n      value: connectrpc.com/connect/internal/gen\nplugins:\n  - local: protoc-gen-go\n    out: internal/gen\n    opt: paths=source_relative\n  - local: protoc-gen-connect-go\n    out: internal/gen\n    opt: paths=source_relative\nclean: true\n"
        },
        {
          "name": "buf.yaml",
          "type": "blob",
          "size": 0.333984375,
          "content": "version: v2\nmodules:\n  - path: internal/proto\nlint:\n  use:\n    - DEFAULT\n  ignore:\n    - internal/proto/connectext/grpc/health/v1/health.proto\n    - internal/proto/connectext/grpc/reflection/v1alpha/reflection.proto\n    - internal/proto/connectext/grpc/status/v1/status.proto\n  disallow_comment_ignores: true\nbreaking:\n  use:\n    - WIRE_JSON\n"
        },
        {
          "name": "buffer_pool.go",
          "type": "blob",
          "size": 1.263671875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"sync\"\n)\n\nconst (\n\tinitialBufferSize    = 512\n\tmaxRecycleBufferSize = 8 * 1024 * 1024 // if >8MiB, don't hold onto a buffer\n)\n\ntype bufferPool struct {\n\tsync.Pool\n}\n\nfunc newBufferPool() *bufferPool {\n\treturn &bufferPool{\n\t\tPool: sync.Pool{\n\t\t\tNew: func() any {\n\t\t\t\treturn bytes.NewBuffer(make([]byte, 0, initialBufferSize))\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc (b *bufferPool) Get() *bytes.Buffer {\n\tif buf, ok := b.Pool.Get().(*bytes.Buffer); ok {\n\t\treturn buf\n\t}\n\treturn bytes.NewBuffer(make([]byte, 0, initialBufferSize))\n}\n\nfunc (b *bufferPool) Put(buffer *bytes.Buffer) {\n\tif buffer.Cap() > maxRecycleBufferSize {\n\t\treturn\n\t}\n\tbuffer.Reset()\n\tb.Pool.Put(buffer)\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 9.0380859375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\n// Client is a reusable, concurrency-safe client for a single procedure.\n// Depending on the procedure's type, use the CallUnary, CallClientStream,\n// CallServerStream, or CallBidiStream method.\n//\n// By default, clients use the Connect protocol with the binary Protobuf Codec,\n// ask for gzipped responses, and send uncompressed requests. To use the gRPC\n// or gRPC-Web protocols, use the [WithGRPC] or [WithGRPCWeb] options.\ntype Client[Req, Res any] struct {\n\tconfig         *clientConfig\n\tcallUnary      func(context.Context, *Request[Req]) (*Response[Res], error)\n\tprotocolClient protocolClient\n\terr            error\n}\n\n// NewClient constructs a new Client.\nfunc NewClient[Req, Res any](httpClient HTTPClient, url string, options ...ClientOption) *Client[Req, Res] {\n\tclient := &Client[Req, Res]{}\n\tconfig, err := newClientConfig(url, options)\n\tif err != nil {\n\t\tclient.err = err\n\t\treturn client\n\t}\n\tclient.config = config\n\tprotocolClient, protocolErr := client.config.Protocol.NewClient(\n\t\t&protocolClientParams{\n\t\t\tCompressionName: config.RequestCompressionName,\n\t\t\tCompressionPools: newReadOnlyCompressionPools(\n\t\t\t\tconfig.CompressionPools,\n\t\t\t\tconfig.CompressionNames,\n\t\t\t),\n\t\t\tCodec:            config.Codec,\n\t\t\tProtobuf:         config.protobuf(),\n\t\t\tCompressMinBytes: config.CompressMinBytes,\n\t\t\tHTTPClient:       httpClient,\n\t\t\tURL:              config.URL,\n\t\t\tBufferPool:       config.BufferPool,\n\t\t\tReadMaxBytes:     config.ReadMaxBytes,\n\t\t\tSendMaxBytes:     config.SendMaxBytes,\n\t\t\tEnableGet:        config.EnableGet,\n\t\t\tGetURLMaxBytes:   config.GetURLMaxBytes,\n\t\t\tGetUseFallback:   config.GetUseFallback,\n\t\t},\n\t)\n\tif protocolErr != nil {\n\t\tclient.err = protocolErr\n\t\treturn client\n\t}\n\tclient.protocolClient = protocolClient\n\t// Rather than applying unary interceptors along the hot path, we can do it\n\t// once at client creation.\n\tunarySpec := config.newSpec(StreamTypeUnary)\n\tunaryFunc := UnaryFunc(func(ctx context.Context, request AnyRequest) (AnyResponse, error) {\n\t\tconn := client.protocolClient.NewConn(ctx, unarySpec, request.Header())\n\t\tconn.onRequestSend(func(r *http.Request) {\n\t\t\trequest.setRequestMethod(r.Method)\n\t\t})\n\t\t// Send always returns an io.EOF unless the error is from the client-side.\n\t\t// We want the user to continue to call Receive in those cases to get the\n\t\t// full error from the server-side.\n\t\tif err := conn.Send(request.Any()); err != nil && !errors.Is(err, io.EOF) {\n\t\t\t_ = conn.CloseRequest()\n\t\t\t_ = conn.CloseResponse()\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := conn.CloseRequest(); err != nil {\n\t\t\t_ = conn.CloseResponse()\n\t\t\treturn nil, err\n\t\t}\n\t\tresponse, err := receiveUnaryResponse[Res](conn, config.Initializer)\n\t\tif err != nil {\n\t\t\t_ = conn.CloseResponse()\n\t\t\treturn nil, err\n\t\t}\n\t\treturn response, conn.CloseResponse()\n\t})\n\tif interceptor := config.Interceptor; interceptor != nil {\n\t\tunaryFunc = interceptor.WrapUnary(unaryFunc)\n\t}\n\tclient.callUnary = func(ctx context.Context, request *Request[Req]) (*Response[Res], error) {\n\t\t// To make the specification, peer, and RPC headers visible to the full\n\t\t// interceptor chain (as though they were supplied by the caller), we'll\n\t\t// add them here.\n\t\trequest.spec = unarySpec\n\t\trequest.peer = client.protocolClient.Peer()\n\t\tprotocolClient.WriteRequestHeader(StreamTypeUnary, request.Header())\n\t\tresponse, err := unaryFunc(ctx, request)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttyped, ok := response.(*Response[Res])\n\t\tif !ok {\n\t\t\treturn nil, errorf(CodeInternal, \"unexpected client response type %T\", response)\n\t\t}\n\t\treturn typed, nil\n\t}\n\treturn client\n}\n\n// CallUnary calls a request-response procedure.\nfunc (c *Client[Req, Res]) CallUnary(ctx context.Context, request *Request[Req]) (*Response[Res], error) {\n\tif c.err != nil {\n\t\treturn nil, c.err\n\t}\n\treturn c.callUnary(ctx, request)\n}\n\n// CallClientStream calls a client streaming procedure.\nfunc (c *Client[Req, Res]) CallClientStream(ctx context.Context) *ClientStreamForClient[Req, Res] {\n\tif c.err != nil {\n\t\treturn &ClientStreamForClient[Req, Res]{err: c.err}\n\t}\n\treturn &ClientStreamForClient[Req, Res]{\n\t\tconn:        c.newConn(ctx, StreamTypeClient, nil),\n\t\tinitializer: c.config.Initializer,\n\t}\n}\n\n// CallServerStream calls a server streaming procedure.\nfunc (c *Client[Req, Res]) CallServerStream(ctx context.Context, request *Request[Req]) (*ServerStreamForClient[Res], error) {\n\tif c.err != nil {\n\t\treturn nil, c.err\n\t}\n\tconn := c.newConn(ctx, StreamTypeServer, func(r *http.Request) {\n\t\trequest.method = r.Method\n\t})\n\trequest.spec = conn.Spec()\n\trequest.peer = conn.Peer()\n\tmergeHeaders(conn.RequestHeader(), request.header)\n\t// Send always returns an io.EOF unless the error is from the client-side.\n\t// We want the user to continue to call Receive in those cases to get the\n\t// full error from the server-side.\n\tif err := conn.Send(request.Msg); err != nil && !errors.Is(err, io.EOF) {\n\t\t_ = conn.CloseRequest()\n\t\t_ = conn.CloseResponse()\n\t\treturn nil, err\n\t}\n\tif err := conn.CloseRequest(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ServerStreamForClient[Res]{\n\t\tconn:        conn,\n\t\tinitializer: c.config.Initializer,\n\t}, nil\n}\n\n// CallBidiStream calls a bidirectional streaming procedure.\nfunc (c *Client[Req, Res]) CallBidiStream(ctx context.Context) *BidiStreamForClient[Req, Res] {\n\tif c.err != nil {\n\t\treturn &BidiStreamForClient[Req, Res]{err: c.err}\n\t}\n\treturn &BidiStreamForClient[Req, Res]{\n\t\tconn:        c.newConn(ctx, StreamTypeBidi, nil),\n\t\tinitializer: c.config.Initializer,\n\t}\n}\n\nfunc (c *Client[Req, Res]) newConn(ctx context.Context, streamType StreamType, onRequestSend func(r *http.Request)) StreamingClientConn {\n\tnewConn := func(ctx context.Context, spec Spec) StreamingClientConn {\n\t\theader := make(http.Header, 8) // arbitrary power of two, prevent immediate resizing\n\t\tc.protocolClient.WriteRequestHeader(streamType, header)\n\t\tconn := c.protocolClient.NewConn(ctx, spec, header)\n\t\tconn.onRequestSend(onRequestSend)\n\t\treturn conn\n\t}\n\tif interceptor := c.config.Interceptor; interceptor != nil {\n\t\tnewConn = interceptor.WrapStreamingClient(newConn)\n\t}\n\treturn newConn(ctx, c.config.newSpec(streamType))\n}\n\ntype clientConfig struct {\n\tURL                    *url.URL\n\tProtocol               protocol\n\tProcedure              string\n\tSchema                 any\n\tInitializer            maybeInitializer\n\tCompressMinBytes       int\n\tInterceptor            Interceptor\n\tCompressionPools       map[string]*compressionPool\n\tCompressionNames       []string\n\tCodec                  Codec\n\tRequestCompressionName string\n\tBufferPool             *bufferPool\n\tReadMaxBytes           int\n\tSendMaxBytes           int\n\tEnableGet              bool\n\tGetURLMaxBytes         int\n\tGetUseFallback         bool\n\tIdempotencyLevel       IdempotencyLevel\n}\n\nfunc newClientConfig(rawURL string, options []ClientOption) (*clientConfig, *Error) {\n\turl, err := parseRequestURL(rawURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprotoPath := extractProtoPath(url.Path)\n\tconfig := clientConfig{\n\t\tURL:              url,\n\t\tProtocol:         &protocolConnect{},\n\t\tProcedure:        protoPath,\n\t\tCompressionPools: make(map[string]*compressionPool),\n\t\tBufferPool:       newBufferPool(),\n\t}\n\twithProtoBinaryCodec().applyToClient(&config)\n\twithGzip().applyToClient(&config)\n\tfor _, opt := range options {\n\t\topt.applyToClient(&config)\n\t}\n\tif err := config.validate(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &config, nil\n}\n\nfunc (c *clientConfig) validate() *Error {\n\tif c.Codec == nil || c.Codec.Name() == \"\" {\n\t\treturn errorf(CodeUnknown, \"no codec configured\")\n\t}\n\tif c.RequestCompressionName != \"\" && c.RequestCompressionName != compressionIdentity {\n\t\tif _, ok := c.CompressionPools[c.RequestCompressionName]; !ok {\n\t\t\treturn errorf(CodeUnknown, \"unknown compression %q\", c.RequestCompressionName)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *clientConfig) protobuf() Codec {\n\tif c.Codec.Name() == codecNameProto {\n\t\treturn c.Codec\n\t}\n\treturn &protoBinaryCodec{}\n}\n\nfunc (c *clientConfig) newSpec(t StreamType) Spec {\n\treturn Spec{\n\t\tStreamType:       t,\n\t\tProcedure:        c.Procedure,\n\t\tSchema:           c.Schema,\n\t\tIsClient:         true,\n\t\tIdempotencyLevel: c.IdempotencyLevel,\n\t}\n}\n\nfunc parseRequestURL(rawURL string) (*url.URL, *Error) {\n\turl, err := url.ParseRequestURI(rawURL)\n\tif err == nil {\n\t\treturn url, nil\n\t}\n\tif !strings.Contains(rawURL, \"://\") {\n\t\t// URL doesn't have a scheme, so the user is likely accustomed to\n\t\t// grpc-go's APIs.\n\t\terr = fmt.Errorf(\n\t\t\t\"URL %q missing scheme: use http:// or https:// (unlike grpc-go)\",\n\t\t\trawURL,\n\t\t)\n\t}\n\treturn nil, NewError(CodeUnavailable, err)\n}\n"
        },
        {
          "name": "client_example_test.go",
          "type": "blob",
          "size": 1.71484375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\tconnect \"connectrpc.com/connect\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n)\n\nfunc Example_client() {\n\tlogger := log.New(os.Stdout, \"\" /* prefix */, 0 /* flags */)\n\t// To keep this example runnable, we'll use an HTTP server and client\n\t// that communicate over in-memory pipes. The client is still a plain\n\t// *http.Client!\n\tvar httpClient *http.Client = examplePingServer.Client()\n\n\t// By default, clients use the Connect protocol. Add connect.WithGRPC() or\n\t// connect.WithGRPCWeb() to switch protocols.\n\tclient := pingv1connect.NewPingServiceClient(\n\t\thttpClient,\n\t\texamplePingServer.URL(),\n\t)\n\tresponse, err := client.Ping(\n\t\tcontext.Background(),\n\t\tconnect.NewRequest(&pingv1.PingRequest{Number: 42}),\n\t)\n\tif err != nil {\n\t\tlogger.Println(\"error:\", err)\n\t\treturn\n\t}\n\tlogger.Println(\"response content-type:\", response.Header().Get(\"Content-Type\"))\n\tlogger.Println(\"response message:\", response.Msg)\n\n\t// Output:\n\t// response content-type: application/proto\n\t// response message: number:42\n}\n"
        },
        {
          "name": "client_ext_test.go",
          "type": "blob",
          "size": 26.3017578125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"connectrpc.com/connect\"\n\t\"connectrpc.com/connect/internal/assert\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n\t\"connectrpc.com/connect/internal/memhttp/memhttptest\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/reflect/protoreflect\"\n\t\"google.golang.org/protobuf/reflect/protoregistry\"\n\t\"google.golang.org/protobuf/types/dynamicpb\"\n)\n\nfunc TestNewClient_InitFailure(t *testing.T) {\n\tt.Parallel()\n\tclient := pingv1connect.NewPingServiceClient(\n\t\thttp.DefaultClient,\n\t\t\"http://127.0.0.1:8080\",\n\t\t// This triggers an error during initialization, so each call will short circuit returning an error.\n\t\tconnect.WithSendCompression(\"invalid\"),\n\t)\n\tvalidateExpectedError := func(t *testing.T, err error) {\n\t\tt.Helper()\n\t\tassert.NotNil(t, err)\n\t\tvar connectErr *connect.Error\n\t\tassert.True(t, errors.As(err, &connectErr))\n\t\tassert.Equal(t, connectErr.Message(), `unknown compression \"invalid\"`)\n\t}\n\n\tt.Run(\"unary\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t_, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{}))\n\t\tvalidateExpectedError(t, err)\n\t})\n\n\tt.Run(\"bidi\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tbidiStream := client.CumSum(context.Background())\n\t\terr := bidiStream.Send(&pingv1.CumSumRequest{})\n\t\tvalidateExpectedError(t, err)\n\t})\n\n\tt.Run(\"client_stream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclientStream := client.Sum(context.Background())\n\t\terr := clientStream.Send(&pingv1.SumRequest{})\n\t\tvalidateExpectedError(t, err)\n\t})\n\n\tt.Run(\"server_stream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\t_, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{Number: 3}))\n\t\tvalidateExpectedError(t, err)\n\t})\n}\n\nfunc TestClientPeer(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\n\trun := func(t *testing.T, unaryHTTPMethod string, opts ...connect.ClientOption) {\n\t\tt.Helper()\n\t\tclient := pingv1connect.NewPingServiceClient(\n\t\t\tserver.Client(),\n\t\t\tserver.URL(),\n\t\t\tconnect.WithClientOptions(opts...),\n\t\t\tconnect.WithInterceptors(&assertPeerInterceptor{t}),\n\t\t)\n\t\tctx := context.Background()\n\t\tt.Run(\"unary\", func(t *testing.T) {\n\t\t\tunaryReq := connect.NewRequest[pingv1.PingRequest](nil)\n\t\t\t_, err := client.Ping(ctx, unaryReq)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, unaryHTTPMethod, unaryReq.HTTPMethod())\n\t\t\ttext := strings.Repeat(\".\", 256)\n\t\t\tr, err := client.Ping(ctx, connect.NewRequest(&pingv1.PingRequest{Text: text}))\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, r.Msg.GetText(), text)\n\t\t})\n\t\tt.Run(\"client_stream\", func(t *testing.T) {\n\t\t\tclientStream := client.Sum(ctx)\n\t\t\tt.Cleanup(func() {\n\t\t\t\t_, closeErr := clientStream.CloseAndReceive()\n\t\t\t\tassert.Nil(t, closeErr)\n\t\t\t})\n\t\t\tassert.NotZero(t, clientStream.Peer().Addr)\n\t\t\tassert.NotZero(t, clientStream.Peer().Protocol)\n\t\t\terr := clientStream.Send(&pingv1.SumRequest{})\n\t\t\tassert.Nil(t, err)\n\t\t})\n\t\tt.Run(\"server_stream\", func(t *testing.T) {\n\t\t\tserverStream, err := client.CountUp(ctx, connect.NewRequest(&pingv1.CountUpRequest{}))\n\t\t\tt.Cleanup(func() {\n\t\t\t\tassert.Nil(t, serverStream.Close())\n\t\t\t})\n\t\t\tassert.Nil(t, err)\n\t\t})\n\t\tt.Run(\"bidi_stream\", func(t *testing.T) {\n\t\t\tbidiStream := client.CumSum(ctx)\n\t\t\tt.Cleanup(func() {\n\t\t\t\tassert.Nil(t, bidiStream.CloseRequest())\n\t\t\t\tassert.Nil(t, bidiStream.CloseResponse())\n\t\t\t})\n\t\t\tassert.NotZero(t, bidiStream.Peer().Addr)\n\t\t\tassert.NotZero(t, bidiStream.Peer().Protocol)\n\t\t\terr := bidiStream.Send(&pingv1.CumSumRequest{})\n\t\t\tassert.Nil(t, err)\n\t\t})\n\t}\n\n\tt.Run(\"connect\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trun(t, http.MethodPost)\n\t})\n\tt.Run(\"connect+get\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trun(t, http.MethodGet,\n\t\t\tconnect.WithHTTPGet(),\n\t\t\tconnect.WithSendGzip(),\n\t\t)\n\t})\n\tt.Run(\"grpc\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trun(t, http.MethodPost, connect.WithGRPC())\n\t})\n\tt.Run(\"grpcweb\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trun(t, http.MethodPost, connect.WithGRPCWeb())\n\t})\n}\n\nfunc TestGetNotModified(t *testing.T) {\n\tt.Parallel()\n\n\tconst etag = \"some-etag\"\n\t// Handlers should automatically set Vary to include request headers that are\n\t// part of the RPC protocol.\n\texpectVary := []string{\"Accept-Encoding\"}\n\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(&notModifiedPingServer{etag: etag}))\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := pingv1connect.NewPingServiceClient(\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t\tconnect.WithHTTPGet(),\n\t)\n\tctx := context.Background()\n\t// unconditional request\n\tunaryReq := connect.NewRequest(&pingv1.PingRequest{})\n\tres, err := client.Ping(ctx, unaryReq)\n\tassert.Nil(t, err)\n\tassert.Equal(t, res.Header().Get(\"Etag\"), etag)\n\tassert.Equal(t, res.Header().Values(\"Vary\"), expectVary)\n\tassert.Equal(t, http.MethodGet, unaryReq.HTTPMethod())\n\n\tunaryReq = connect.NewRequest(&pingv1.PingRequest{})\n\tunaryReq.Header().Set(\"If-None-Match\", etag)\n\t_, err = client.Ping(ctx, unaryReq)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, connect.CodeOf(err), connect.CodeUnknown)\n\tassert.True(t, connect.IsNotModifiedError(err))\n\tvar connectErr *connect.Error\n\tassert.True(t, errors.As(err, &connectErr))\n\tassert.Equal(t, connectErr.Meta().Get(\"Etag\"), etag)\n\tassert.Equal(t, connectErr.Meta().Values(\"Vary\"), expectVary)\n\tassert.Equal(t, http.MethodGet, unaryReq.HTTPMethod())\n}\n\nfunc TestGetNoContentHeaders(t *testing.T) {\n\tt.Parallel()\n\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(&pingServer{}))\n\tserver := memhttptest.NewServer(t, http.HandlerFunc(func(respWriter http.ResponseWriter, req *http.Request) {\n\t\tif len(req.Header.Values(\"content-type\")) > 0 ||\n\t\t\tlen(req.Header.Values(\"content-encoding\")) > 0 ||\n\t\t\tlen(req.Header.Values(\"content-length\")) > 0 {\n\t\t\thttp.Error(respWriter, \"GET request should not include content headers\", http.StatusBadRequest)\n\t\t}\n\t\tmux.ServeHTTP(respWriter, req)\n\t}))\n\tclient := pingv1connect.NewPingServiceClient(\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t\tconnect.WithHTTPGet(),\n\t)\n\tctx := context.Background()\n\n\tunaryReq := connect.NewRequest(&pingv1.PingRequest{})\n\t_, err := client.Ping(ctx, unaryReq)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.MethodGet, unaryReq.HTTPMethod())\n}\n\nfunc TestConnectionDropped(t *testing.T) {\n\tt.Parallel()\n\tctx := context.Background()\n\tfor _, protocol := range []string{connect.ProtocolConnect, connect.ProtocolGRPC, connect.ProtocolGRPCWeb} {\n\t\tvar opts []connect.ClientOption\n\t\tswitch protocol {\n\t\tcase connect.ProtocolGRPC:\n\t\t\topts = []connect.ClientOption{connect.WithGRPC()}\n\t\tcase connect.ProtocolGRPCWeb:\n\t\t\topts = []connect.ClientOption{connect.WithGRPCWeb()}\n\t\t}\n\t\tt.Run(protocol, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\thttpClient := httpClientFunc(func(_ *http.Request) (*http.Response, error) {\n\t\t\t\treturn nil, io.EOF\n\t\t\t})\n\t\t\tclient := pingv1connect.NewPingServiceClient(\n\t\t\t\thttpClient,\n\t\t\t\t\"http://1.2.3.4\",\n\t\t\t\topts...,\n\t\t\t)\n\t\t\tt.Run(\"unary\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\treq := connect.NewRequest[pingv1.PingRequest](nil)\n\t\t\t\t_, err := client.Ping(ctx, req)\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t\tif !assert.Equal(t, connect.CodeOf(err), connect.CodeUnavailable) {\n\t\t\t\t\tt.Logf(\"err = %v\\n%#v\", err, err)\n\t\t\t\t}\n\t\t\t})\n\t\t\tt.Run(\"stream\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\treq := connect.NewRequest[pingv1.CountUpRequest](nil)\n\t\t\t\tsvrStream, err := client.CountUp(ctx, req)\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Cleanup(func() {\n\t\t\t\t\t\tassert.Nil(t, svrStream.Close())\n\t\t\t\t\t})\n\t\t\t\t\tif !assert.False(t, svrStream.Receive()) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\terr = svrStream.Err()\n\t\t\t\t}\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t\tif !assert.Equal(t, connect.CodeOf(err), connect.CodeUnavailable) {\n\t\t\t\t\tt.Logf(\"err = %v\\n%#v\", err, err)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestSpecSchema(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(\n\t\tpingServer{},\n\t\tconnect.WithInterceptors(&assertSchemaInterceptor{t}),\n\t))\n\tserver := memhttptest.NewServer(t, mux)\n\tctx := context.Background()\n\tclient := pingv1connect.NewPingServiceClient(\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t\tconnect.WithInterceptors(&assertSchemaInterceptor{t}),\n\t)\n\tt.Run(\"unary\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tunaryReq := connect.NewRequest[pingv1.PingRequest](nil)\n\t\t_, err := client.Ping(ctx, unaryReq)\n\t\tassert.NotNil(t, unaryReq.Spec().Schema)\n\t\tassert.Nil(t, err)\n\t\ttext := strings.Repeat(\".\", 256)\n\t\tr, err := client.Ping(ctx, connect.NewRequest(&pingv1.PingRequest{Text: text}))\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, r.Msg.GetText(), text)\n\t})\n\tt.Run(\"bidi_stream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tbidiStream := client.CumSum(ctx)\n\t\tt.Cleanup(func() {\n\t\t\tassert.Nil(t, bidiStream.CloseRequest())\n\t\t\tassert.Nil(t, bidiStream.CloseResponse())\n\t\t})\n\t\tassert.NotZero(t, bidiStream.Spec().Schema)\n\t\terr := bidiStream.Send(&pingv1.CumSumRequest{})\n\t\tassert.Nil(t, err)\n\t})\n}\n\nfunc TestDynamicClient(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\tctx := context.Background()\n\tinitializer := func(spec connect.Spec, msg any) error {\n\t\tdynamic, ok := msg.(*dynamicpb.Message)\n\t\tif !ok {\n\t\t\treturn nil\n\t\t}\n\t\tdesc, ok := spec.Schema.(protoreflect.MethodDescriptor)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"invalid schema type %T for %T message\", spec.Schema, dynamic)\n\t\t}\n\t\tif spec.IsClient {\n\t\t\t*dynamic = *dynamicpb.NewMessage(desc.Output())\n\t\t} else {\n\t\t\t*dynamic = *dynamicpb.NewMessage(desc.Input())\n\t\t}\n\t\treturn nil\n\t}\n\tt.Run(\"unary\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.Ping\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\tclient := connect.NewClient[dynamicpb.Message, dynamicpb.Message](\n\t\t\tserver.Client(),\n\t\t\tserver.URL()+\"/connect.ping.v1.PingService/Ping\",\n\t\t\tconnect.WithSchema(methodDesc),\n\t\t\tconnect.WithIdempotency(connect.IdempotencyNoSideEffects),\n\t\t\tconnect.WithResponseInitializer(initializer),\n\t\t)\n\t\tmsg := dynamicpb.NewMessage(methodDesc.Input())\n\t\tmsg.Set(\n\t\t\tmethodDesc.Input().Fields().ByName(\"number\"),\n\t\t\tprotoreflect.ValueOfInt64(42),\n\t\t)\n\t\tres, err := client.CallUnary(ctx, connect.NewRequest(msg))\n\t\tassert.Nil(t, err)\n\t\tgot := res.Msg.Get(methodDesc.Output().Fields().ByName(\"number\")).Int()\n\t\tassert.Equal(t, got, 42)\n\t})\n\tt.Run(\"clientStream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.Sum\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\tclient := connect.NewClient[dynamicpb.Message, dynamicpb.Message](\n\t\t\tserver.Client(),\n\t\t\tserver.URL()+\"/connect.ping.v1.PingService/Sum\",\n\t\t\tconnect.WithSchema(methodDesc),\n\t\t\tconnect.WithResponseInitializer(initializer),\n\t\t)\n\t\tstream := client.CallClientStream(ctx)\n\t\tmsg := dynamicpb.NewMessage(methodDesc.Input())\n\t\tmsg.Set(\n\t\t\tmethodDesc.Input().Fields().ByName(\"number\"),\n\t\t\tprotoreflect.ValueOfInt64(42),\n\t\t)\n\t\tassert.Nil(t, stream.Send(msg))\n\t\tassert.Nil(t, stream.Send(msg))\n\t\trsp, err := stream.CloseAndReceive()\n\t\tif !assert.Nil(t, err) {\n\t\t\treturn\n\t\t}\n\t\tgot := rsp.Msg.Get(methodDesc.Output().Fields().ByName(\"sum\")).Int()\n\t\tassert.Equal(t, got, 42*2)\n\t})\n\tt.Run(\"serverStream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.CountUp\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\tclient := connect.NewClient[dynamicpb.Message, dynamicpb.Message](\n\t\t\tserver.Client(),\n\t\t\tserver.URL()+\"/connect.ping.v1.PingService/CountUp\",\n\t\t\tconnect.WithSchema(methodDesc),\n\t\t\tconnect.WithResponseInitializer(initializer),\n\t\t)\n\t\tmsg := dynamicpb.NewMessage(methodDesc.Input())\n\t\tmsg.Set(\n\t\t\tmethodDesc.Input().Fields().ByName(\"number\"),\n\t\t\tprotoreflect.ValueOfInt64(2),\n\t\t)\n\t\treq := connect.NewRequest(msg)\n\t\tstream, err := client.CallServerStream(ctx, req)\n\t\tif !assert.Nil(t, err) {\n\t\t\treturn\n\t\t}\n\t\tfor i := 1; stream.Receive(); i++ {\n\t\t\tout := stream.Msg()\n\t\t\tgot := out.Get(methodDesc.Output().Fields().ByName(\"number\")).Int()\n\t\t\tassert.Equal(t, got, int64(i))\n\t\t}\n\t\tassert.Nil(t, stream.Close())\n\t})\n\tt.Run(\"bidi\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.CumSum\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\tclient := connect.NewClient[dynamicpb.Message, dynamicpb.Message](\n\t\t\tserver.Client(),\n\t\t\tserver.URL()+\"/connect.ping.v1.PingService/CumSum\",\n\t\t\tconnect.WithSchema(methodDesc),\n\t\t\tconnect.WithResponseInitializer(initializer),\n\t\t)\n\t\tstream := client.CallBidiStream(ctx)\n\t\tmsg := dynamicpb.NewMessage(methodDesc.Input())\n\t\tmsg.Set(\n\t\t\tmethodDesc.Input().Fields().ByName(\"number\"),\n\t\t\tprotoreflect.ValueOfInt64(42),\n\t\t)\n\t\tassert.Nil(t, stream.Send(msg))\n\t\tassert.Nil(t, stream.CloseRequest())\n\t\tout, err := stream.Receive()\n\t\tif assert.Nil(t, err) {\n\t\t\treturn\n\t\t}\n\t\tgot := out.Get(methodDesc.Output().Fields().ByName(\"number\")).Int()\n\t\tassert.Equal(t, got, 42)\n\t})\n\tt.Run(\"option\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.Ping\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\toptionCalled := false\n\t\tclient := connect.NewClient[dynamicpb.Message, dynamicpb.Message](\n\t\t\tserver.Client(),\n\t\t\tserver.URL()+\"/connect.ping.v1.PingService/Ping\",\n\t\t\tconnect.WithSchema(methodDesc),\n\t\t\tconnect.WithIdempotency(connect.IdempotencyNoSideEffects),\n\t\t\tconnect.WithResponseInitializer(\n\t\t\t\tfunc(spec connect.Spec, msg any) error {\n\t\t\t\t\tassert.NotNil(t, spec)\n\t\t\t\t\tassert.NotNil(t, msg)\n\t\t\t\t\tdynamic, ok := msg.(*dynamicpb.Message)\n\t\t\t\t\tif !assert.True(t, ok) {\n\t\t\t\t\t\treturn fmt.Errorf(\"unexpected message type: %T\", msg)\n\t\t\t\t\t}\n\t\t\t\t\t*dynamic = *dynamicpb.NewMessage(methodDesc.Output())\n\t\t\t\t\toptionCalled = true\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t),\n\t\t)\n\t\tmsg := dynamicpb.NewMessage(methodDesc.Input())\n\t\tmsg.Set(\n\t\t\tmethodDesc.Input().Fields().ByName(\"number\"),\n\t\t\tprotoreflect.ValueOfInt64(42),\n\t\t)\n\t\tres, err := client.CallUnary(ctx, connect.NewRequest(msg))\n\t\tassert.Nil(t, err)\n\t\tgot := res.Msg.Get(methodDesc.Output().Fields().ByName(\"number\")).Int()\n\t\tassert.Equal(t, got, 42)\n\t\tassert.True(t, optionCalled)\n\t})\n}\n\nfunc TestClientDeadlineHandling(t *testing.T) {\n\tt.Parallel()\n\tif testing.Short() {\n\t\tt.Skip(\"skipping slow test\")\n\t}\n\n\t// Note that these tests are not able to reproduce issues with the race\n\t// detector enabled. That's partly why the makefile only runs \"slow\"\n\t// tests with the race detector disabled.\n\n\t_, handler := pingv1connect.NewPingServiceHandler(pingServer{})\n\tsvr := httptest.NewUnstartedServer(http.HandlerFunc(func(respWriter http.ResponseWriter, req *http.Request) {\n\t\tif req.Context().Err() != nil {\n\t\t\treturn\n\t\t}\n\t\thandler.ServeHTTP(respWriter, req)\n\t}))\n\tsvr.Config.ErrorLog = log.New(io.Discard, \"\", 0) //nolint:forbidigo\n\tsvr.EnableHTTP2 = true\n\tsvr.StartTLS()\n\tt.Cleanup(svr.Close)\n\n\t// This case creates a new connection for each RPC to verify that timeouts during dialing\n\t// won't cause issues. This is historically easier to reproduce, so it uses a smaller\n\t// duration, no concurrency, and fewer iterations. This is important because if we used\n\t// a new connection for each RPC in the bigger test scenario below, we'd encounter other\n\t// issues related to overwhelming the loopback interface and exhausting ephemeral ports.\n\tt.Run(\"dial\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttransport, ok := svr.Client().Transport.(*http.Transport)\n\t\tif !assert.True(t, ok) {\n\t\t\tt.FailNow()\n\t\t}\n\t\ttestClientDeadlineBruteForceLoop(t,\n\t\t\t5*time.Second, 5, 1,\n\t\t\tfunc(ctx context.Context) (string, rpcErrors) {\n\t\t\t\thttpClient := &http.Client{\n\t\t\t\t\tTransport: transport.Clone(),\n\t\t\t\t}\n\t\t\t\tclient := pingv1connect.NewPingServiceClient(httpClient, svr.URL)\n\t\t\t\t_, err := client.Ping(ctx, connect.NewRequest(&pingv1.PingRequest{Text: \"foo\"}))\n\t\t\t\t// Close all connections and make sure to give a little time for the OS to\n\t\t\t\t// release socket resources to prevent resource exhaustion (such as running\n\t\t\t\t// out of ephemeral ports).\n\t\t\t\thttpClient.CloseIdleConnections()\n\t\t\t\ttime.Sleep(time.Millisecond / 2)\n\t\t\t\treturn pingv1connect.PingServicePingProcedure, rpcErrors{recvErr: err}\n\t\t\t},\n\t\t)\n\t})\n\n\t// This case creates significantly more load than the above one, but uses a normal\n\t// client so pools and re-uses connections. It also uses all stream types to send\n\t// messages, to make sure that all stream implementations handle deadlines correctly.\n\t// The I/O errors related to deadlines are historically harder to reproduce, so it\n\t// throws a lot more effort into reproducing, particularly a longer duration for\n\t// which it will run. It also uses larger messages (by packing requests with\n\t// unrecognized fields) and compression, to make it more likely to encounter the\n\t// deadline in the middle of read and write operations.\n\tt.Run(\"read-write\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tvar extraField []byte\n\t\textraField = protowire.AppendTag(extraField, 999, protowire.BytesType)\n\t\textraData := make([]byte, 16*1024)\n\t\t// use good random data so it's not very compressible\n\t\tif _, err := rand.Read(extraData); err != nil {\n\t\t\tt.Fatalf(\"failed to generate extra payload: %v\", err)\n\t\t\treturn\n\t\t}\n\t\textraField = protowire.AppendBytes(extraField, extraData)\n\n\t\tclientConnect := pingv1connect.NewPingServiceClient(svr.Client(), svr.URL, connect.WithSendGzip())\n\t\tclientGRPC := pingv1connect.NewPingServiceClient(svr.Client(), svr.URL, connect.WithSendGzip(), connect.WithGRPCWeb())\n\t\tvar count atomic.Int32\n\t\ttestClientDeadlineBruteForceLoop(t,\n\t\t\t20*time.Second, 200, runtime.GOMAXPROCS(0),\n\t\t\tfunc(ctx context.Context) (string, rpcErrors) {\n\t\t\t\tvar procedure string\n\t\t\t\tvar errs rpcErrors\n\t\t\t\trpcNum := count.Add(1)\n\t\t\t\tvar client pingv1connect.PingServiceClient\n\t\t\t\tif rpcNum&4 == 0 {\n\t\t\t\t\tclient = clientConnect\n\t\t\t\t} else {\n\t\t\t\t\tclient = clientGRPC\n\t\t\t\t}\n\t\t\t\tswitch rpcNum & 3 {\n\t\t\t\tcase 0:\n\t\t\t\t\tprocedure = pingv1connect.PingServicePingProcedure\n\t\t\t\t\t_, errs.recvErr = client.Ping(ctx, connect.NewRequest(addUnrecognizedBytes(&pingv1.PingRequest{Text: \"foo\"}, extraField)))\n\t\t\t\tcase 1:\n\t\t\t\t\tprocedure = pingv1connect.PingServiceSumProcedure\n\t\t\t\t\tstream := client.Sum(ctx)\n\t\t\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\t\t\terrs.sendErr = stream.Send(addUnrecognizedBytes(&pingv1.SumRequest{Number: 1}, extraField))\n\t\t\t\t\t\tif errs.sendErr != nil {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_, errs.recvErr = stream.CloseAndReceive()\n\t\t\t\tcase 2:\n\t\t\t\t\tprocedure = pingv1connect.PingServiceCountUpProcedure\n\t\t\t\t\tvar stream *connect.ServerStreamForClient[pingv1.CountUpResponse]\n\t\t\t\t\tstream, errs.recvErr = client.CountUp(ctx, connect.NewRequest(addUnrecognizedBytes(&pingv1.CountUpRequest{Number: 3}, extraField)))\n\t\t\t\t\tif errs.recvErr == nil {\n\t\t\t\t\t\tfor stream.Receive() {\n\t\t\t\t\t\t}\n\t\t\t\t\t\terrs.recvErr = stream.Err()\n\t\t\t\t\t\terrs.closeRecvErr = stream.Close()\n\t\t\t\t\t}\n\t\t\t\tcase 3:\n\t\t\t\t\tprocedure = pingv1connect.PingServiceCumSumProcedure\n\t\t\t\t\tstream := client.CumSum(ctx)\n\t\t\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\t\t\terrs.sendErr = stream.Send(addUnrecognizedBytes(&pingv1.CumSumRequest{Number: 1}, extraField))\n\t\t\t\t\t\t_, errs.recvErr = stream.Receive()\n\t\t\t\t\t\tif errs.recvErr != nil {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\terrs.closeSendErr = stream.CloseRequest()\n\t\t\t\t\terrs.closeRecvErr = stream.CloseResponse()\n\t\t\t\t}\n\t\t\t\treturn procedure, errs\n\t\t\t},\n\t\t)\n\t})\n}\n\nfunc testClientDeadlineBruteForceLoop(\n\tt *testing.T,\n\tduration time.Duration,\n\titerationsPerDeadline int,\n\tparallelism int,\n\tloopBody func(ctx context.Context) (string, rpcErrors),\n) {\n\tt.Helper()\n\ttestContext, testCancel := context.WithTimeout(context.Background(), duration)\n\tdefer testCancel()\n\tvar rpcCount atomic.Int64\n\n\tvar wg sync.WaitGroup\n\tfor goroutine := 0; goroutine < parallelism; goroutine++ {\n\t\tgoroutine := goroutine\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t// We try a range of timeouts since the timing issue is sensitive\n\t\t\t// to execution environment (e.g. CPU, memory, and network speeds).\n\t\t\t// So the lower timeout values may be more likely to trigger an issue\n\t\t\t// in faster environments; higher timeouts for slower environments.\n\t\t\tconst minTimeout = 10 * time.Microsecond\n\t\t\tconst maxTimeout = 2 * time.Millisecond\n\t\t\tfor {\n\t\t\t\tfor timeout := minTimeout; timeout <= maxTimeout; timeout += 10 * time.Microsecond {\n\t\t\t\t\tfor i := 0; i < iterationsPerDeadline; i++ {\n\t\t\t\t\t\tif testContext.Err() != nil {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\t\t\t\t\t// We are intentionally not inheriting from testContext, which signals when the\n\t\t\t\t\t\t// test loop should stop and return but need not influence the RPC deadline.\n\t\t\t\t\t\tproc, errs := loopBody(ctx) //nolint:contextcheck\n\t\t\t\t\t\trpcCount.Add(1)\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t\ttype errCase struct {\n\t\t\t\t\t\t\terr      error\n\t\t\t\t\t\t\tname     string\n\t\t\t\t\t\t\tallowEOF bool\n\t\t\t\t\t\t}\n\t\t\t\t\t\terrCases := []errCase{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terr:      errs.sendErr,\n\t\t\t\t\t\t\t\tname:     \"send error\",\n\t\t\t\t\t\t\t\tallowEOF: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terr:  errs.recvErr,\n\t\t\t\t\t\t\t\tname: \"receive error\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terr:  errs.closeSendErr,\n\t\t\t\t\t\t\t\tname: \"close-send error\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terr:  errs.closeRecvErr,\n\t\t\t\t\t\t\t\tname: \"close-receive error\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor _, errCase := range errCases {\n\t\t\t\t\t\t\terr := errCase.err\n\t\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\t\t// operation completed before timeout, try again\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif errCase.allowEOF && errors.Is(err, io.EOF) {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif !assert.Equal(t, connect.CodeOf(err), connect.CodeDeadlineExceeded) {\n\t\t\t\t\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t\t\t\t\t_, _ = fmt.Fprintf(&buf, \"actual %v from %s: %v\\n%#v\", errCase.name, proc, err, err)\n\t\t\t\t\t\t\t\tfor {\n\t\t\t\t\t\t\t\t\terr = errors.Unwrap(err)\n\t\t\t\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t_, _ = fmt.Fprintf(&buf, \"\\n  caused by: %#v\", err)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tt.Log(buf.String())\n\t\t\t\t\t\t\t\ttestCancel()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.Logf(\"goroutine %d: repeating duration loop\", goroutine)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\tt.Logf(\"Issued %d RPCs.\", rpcCount.Load())\n}\n\ntype notModifiedPingServer struct {\n\tpingv1connect.UnimplementedPingServiceHandler\n\n\tetag string\n}\n\nfunc (s *notModifiedPingServer) Ping(\n\t_ context.Context,\n\treq *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\tif req.HTTPMethod() == http.MethodGet && req.Header().Get(\"If-None-Match\") == s.etag {\n\t\treturn nil, connect.NewNotModifiedError(http.Header{\"Etag\": []string{s.etag}})\n\t}\n\tresp := connect.NewResponse(&pingv1.PingResponse{})\n\tresp.Header().Set(\"Etag\", s.etag)\n\treturn resp, nil\n}\n\ntype assertPeerInterceptor struct {\n\ttb testing.TB\n}\n\nfunc (a *assertPeerInterceptor) WrapUnary(next connect.UnaryFunc) connect.UnaryFunc {\n\treturn func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {\n\t\tassert.NotZero(a.tb, req.Peer().Addr)\n\t\tassert.NotZero(a.tb, req.Peer().Protocol)\n\t\treturn next(ctx, req)\n\t}\n}\n\nfunc (a *assertPeerInterceptor) WrapStreamingClient(next connect.StreamingClientFunc) connect.StreamingClientFunc {\n\treturn func(ctx context.Context, spec connect.Spec) connect.StreamingClientConn {\n\t\tconn := next(ctx, spec)\n\t\tassert.NotZero(a.tb, conn.Peer().Addr)\n\t\tassert.NotZero(a.tb, conn.Peer().Protocol)\n\t\tassert.NotZero(a.tb, conn.Spec())\n\t\treturn conn\n\t}\n}\n\nfunc (a *assertPeerInterceptor) WrapStreamingHandler(next connect.StreamingHandlerFunc) connect.StreamingHandlerFunc {\n\treturn func(ctx context.Context, conn connect.StreamingHandlerConn) error {\n\t\tassert.NotZero(a.tb, conn.Peer().Addr)\n\t\tassert.NotZero(a.tb, conn.Peer().Protocol)\n\t\tassert.NotZero(a.tb, conn.Spec())\n\t\treturn next(ctx, conn)\n\t}\n}\n\ntype assertSchemaInterceptor struct {\n\ttb testing.TB\n}\n\nfunc (a *assertSchemaInterceptor) WrapUnary(next connect.UnaryFunc) connect.UnaryFunc {\n\treturn func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {\n\t\tif !assert.NotNil(a.tb, req.Spec().Schema) {\n\t\t\treturn next(ctx, req)\n\t\t}\n\t\tmethodDesc, ok := req.Spec().Schema.(protoreflect.MethodDescriptor)\n\t\tif assert.True(a.tb, ok) {\n\t\t\tprocedure := fmt.Sprintf(\"/%s/%s\", methodDesc.Parent().FullName(), methodDesc.Name())\n\t\t\tassert.Equal(a.tb, procedure, req.Spec().Procedure)\n\t\t}\n\t\treturn next(ctx, req)\n\t}\n}\n\nfunc (a *assertSchemaInterceptor) WrapStreamingClient(next connect.StreamingClientFunc) connect.StreamingClientFunc {\n\treturn func(ctx context.Context, spec connect.Spec) connect.StreamingClientConn {\n\t\tconn := next(ctx, spec)\n\t\tif !assert.NotNil(a.tb, spec.Schema) {\n\t\t\treturn conn\n\t\t}\n\t\tmethodDescriptor, ok := spec.Schema.(protoreflect.MethodDescriptor)\n\t\tif assert.True(a.tb, ok) {\n\t\t\tprocedure := fmt.Sprintf(\"/%s/%s\", methodDescriptor.Parent().FullName(), methodDescriptor.Name())\n\t\t\tassert.Equal(a.tb, procedure, spec.Procedure)\n\t\t}\n\t\treturn conn\n\t}\n}\n\nfunc (a *assertSchemaInterceptor) WrapStreamingHandler(next connect.StreamingHandlerFunc) connect.StreamingHandlerFunc {\n\treturn func(ctx context.Context, conn connect.StreamingHandlerConn) error {\n\t\tif !assert.NotNil(a.tb, conn.Spec().Schema) {\n\t\t\treturn next(ctx, conn)\n\t\t}\n\t\tmethodDesc, ok := conn.Spec().Schema.(protoreflect.MethodDescriptor)\n\t\tif assert.True(a.tb, ok) {\n\t\t\tprocedure := fmt.Sprintf(\"/%s/%s\", methodDesc.Parent().FullName(), methodDesc.Name())\n\t\t\tassert.Equal(a.tb, procedure, conn.Spec().Procedure)\n\t\t}\n\t\treturn next(ctx, conn)\n\t}\n}\n\ntype rpcErrors struct {\n\tsendErr      error\n\trecvErr      error\n\tcloseSendErr error\n\tcloseRecvErr error\n}\n\nfunc addUnrecognizedBytes[M proto.Message](msg M, data []byte) M {\n\tmsg.ProtoReflect().SetUnknown(data)\n\treturn msg\n}\n\ntype httpClientFunc func(*http.Request) (*http.Response, error)\n\nfunc (fn httpClientFunc) Do(req *http.Request) (*http.Response, error) {\n\treturn fn(req)\n}\n"
        },
        {
          "name": "client_get_fallback_test.go",
          "type": "blob",
          "size": 1.8017578125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/memhttp/memhttptest\"\n)\n\nfunc TestClientUnaryGetFallback(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/connect.ping.v1.PingService/Ping\", NewUnaryHandler(\n\t\t\"/connect.ping.v1.PingService/Ping\",\n\t\tfunc(ctx context.Context, r *Request[pingv1.PingRequest]) (*Response[pingv1.PingResponse], error) {\n\t\t\treturn NewResponse(&pingv1.PingResponse{\n\t\t\t\tNumber: r.Msg.GetNumber(),\n\t\t\t\tText:   r.Msg.GetText(),\n\t\t\t}), nil\n\t\t},\n\t\tWithIdempotency(IdempotencyNoSideEffects),\n\t))\n\tserver := memhttptest.NewServer(t, mux)\n\n\tclient := NewClient[pingv1.PingRequest, pingv1.PingResponse](\n\t\tserver.Client(),\n\t\tserver.URL()+\"/connect.ping.v1.PingService/Ping\",\n\t\tWithHTTPGet(),\n\t\tWithHTTPGetMaxURLSize(1, true),\n\t\tWithSendGzip(),\n\t)\n\tctx := context.Background()\n\n\t_, err := client.CallUnary(ctx, NewRequest[pingv1.PingRequest](nil))\n\tassert.Nil(t, err)\n\n\ttext := strings.Repeat(\".\", 256)\n\tr, err := client.CallUnary(ctx, NewRequest(&pingv1.PingRequest{Text: text}))\n\tassert.Nil(t, err)\n\tassert.Equal(t, r.Msg.GetText(), text)\n}\n"
        },
        {
          "name": "client_stream.go",
          "type": "blob",
          "size": 8.94140625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// ClientStreamForClient is the client's view of a client streaming RPC.\n//\n// It's returned from [Client].CallClientStream, but doesn't currently have an\n// exported constructor function.\ntype ClientStreamForClient[Req, Res any] struct {\n\tconn        StreamingClientConn\n\tinitializer maybeInitializer\n\t// Error from client construction. If non-nil, return for all calls.\n\terr error\n}\n\n// Spec returns the specification for the RPC.\nfunc (c *ClientStreamForClient[_, _]) Spec() Spec {\n\treturn c.conn.Spec()\n}\n\n// Peer describes the server for the RPC.\nfunc (c *ClientStreamForClient[_, _]) Peer() Peer {\n\treturn c.conn.Peer()\n}\n\n// RequestHeader returns the request headers. Headers are sent to the server with the\n// first call to Send.\n//\n// Headers beginning with \"Connect-\" and \"Grpc-\" are reserved for use by the\n// Connect and gRPC protocols. Applications shouldn't write them.\nfunc (c *ClientStreamForClient[Req, Res]) RequestHeader() http.Header {\n\tif c.err != nil {\n\t\treturn http.Header{}\n\t}\n\treturn c.conn.RequestHeader()\n}\n\n// Send a message to the server. The first call to Send also sends the request\n// headers.\n//\n// If the server returns an error, Send returns an error that wraps [io.EOF].\n// Clients should check for case using the standard library's [errors.Is] and\n// unmarshal the error using CloseAndReceive.\nfunc (c *ClientStreamForClient[Req, Res]) Send(request *Req) error {\n\tif c.err != nil {\n\t\treturn c.err\n\t}\n\tif request == nil {\n\t\treturn c.conn.Send(nil)\n\t}\n\treturn c.conn.Send(request)\n}\n\n// CloseAndReceive closes the send side of the stream and waits for the\n// response.\nfunc (c *ClientStreamForClient[Req, Res]) CloseAndReceive() (*Response[Res], error) {\n\tif c.err != nil {\n\t\treturn nil, c.err\n\t}\n\tif err := c.conn.CloseRequest(); err != nil {\n\t\t_ = c.conn.CloseResponse()\n\t\treturn nil, err\n\t}\n\tresponse, err := receiveUnaryResponse[Res](c.conn, c.initializer)\n\tif err != nil {\n\t\t_ = c.conn.CloseResponse()\n\t\treturn nil, err\n\t}\n\treturn response, c.conn.CloseResponse()\n}\n\n// Conn exposes the underlying StreamingClientConn. This may be useful if\n// you'd prefer to wrap the connection in a different high-level API.\nfunc (c *ClientStreamForClient[Req, Res]) Conn() (StreamingClientConn, error) {\n\treturn c.conn, c.err\n}\n\n// ServerStreamForClient is the client's view of a server streaming RPC.\n//\n// It's returned from [Client].CallServerStream, but doesn't currently have an\n// exported constructor function.\ntype ServerStreamForClient[Res any] struct {\n\tconn        StreamingClientConn\n\tinitializer maybeInitializer\n\tmsg         *Res\n\t// Error from client construction. If non-nil, return for all calls.\n\tconstructErr error\n\t// Error from conn.Receive().\n\treceiveErr error\n}\n\n// Receive advances the stream to the next message, which will then be\n// available through the Msg method. It returns false when the stream stops,\n// either by reaching the end or by encountering an unexpected error. After\n// Receive returns false, the Err method will return any unexpected error\n// encountered.\nfunc (s *ServerStreamForClient[Res]) Receive() bool {\n\tif s.constructErr != nil || s.receiveErr != nil {\n\t\treturn false\n\t}\n\ts.msg = new(Res)\n\tif err := s.initializer.maybe(s.conn.Spec(), s.msg); err != nil {\n\t\ts.receiveErr = err\n\t\treturn false\n\t}\n\ts.receiveErr = s.conn.Receive(s.msg)\n\treturn s.receiveErr == nil\n}\n\n// Msg returns the most recent message unmarshaled by a call to Receive.\nfunc (s *ServerStreamForClient[Res]) Msg() *Res {\n\tif s.msg == nil {\n\t\ts.msg = new(Res)\n\t}\n\treturn s.msg\n}\n\n// Err returns the first non-EOF error that was encountered by Receive.\nfunc (s *ServerStreamForClient[Res]) Err() error {\n\tif s.constructErr != nil {\n\t\treturn s.constructErr\n\t}\n\tif s.receiveErr != nil && !errors.Is(s.receiveErr, io.EOF) {\n\t\treturn s.receiveErr\n\t}\n\treturn nil\n}\n\n// ResponseHeader returns the headers received from the server. It blocks until\n// the first call to Receive returns.\nfunc (s *ServerStreamForClient[Res]) ResponseHeader() http.Header {\n\tif s.constructErr != nil {\n\t\treturn http.Header{}\n\t}\n\treturn s.conn.ResponseHeader()\n}\n\n// ResponseTrailer returns the trailers received from the server. Trailers\n// aren't fully populated until Receive() returns an error wrapping io.EOF.\nfunc (s *ServerStreamForClient[Res]) ResponseTrailer() http.Header {\n\tif s.constructErr != nil {\n\t\treturn http.Header{}\n\t}\n\treturn s.conn.ResponseTrailer()\n}\n\n// Close the receive side of the stream.\n//\n// Close is non-blocking. To gracefully close the stream and allow for\n// connection resuse ensure all messages have been received before calling\n// Close. All messages are received when Receive returns false.\nfunc (s *ServerStreamForClient[Res]) Close() error {\n\tif s.constructErr != nil {\n\t\treturn s.constructErr\n\t}\n\treturn s.conn.CloseResponse()\n}\n\n// Conn exposes the underlying StreamingClientConn. This may be useful if\n// you'd prefer to wrap the connection in a different high-level API.\nfunc (s *ServerStreamForClient[Res]) Conn() (StreamingClientConn, error) {\n\treturn s.conn, s.constructErr\n}\n\n// BidiStreamForClient is the client's view of a bidirectional streaming RPC.\n//\n// It's returned from [Client].CallBidiStream, but doesn't currently have an\n// exported constructor function.\ntype BidiStreamForClient[Req, Res any] struct {\n\tconn        StreamingClientConn\n\tinitializer maybeInitializer\n\t// Error from client construction. If non-nil, return for all calls.\n\terr error\n}\n\n// Spec returns the specification for the RPC.\nfunc (b *BidiStreamForClient[_, _]) Spec() Spec {\n\treturn b.conn.Spec()\n}\n\n// Peer describes the server for the RPC.\nfunc (b *BidiStreamForClient[_, _]) Peer() Peer {\n\treturn b.conn.Peer()\n}\n\n// RequestHeader returns the request headers. Headers are sent with the first\n// call to Send.\n//\n// Headers beginning with \"Connect-\" and \"Grpc-\" are reserved for use by the\n// Connect and gRPC protocols. Applications shouldn't write them.\nfunc (b *BidiStreamForClient[Req, Res]) RequestHeader() http.Header {\n\tif b.err != nil {\n\t\treturn http.Header{}\n\t}\n\treturn b.conn.RequestHeader()\n}\n\n// Send a message to the server. The first call to Send also sends the request\n// headers. To send just the request headers, without a body, call Send with a\n// nil pointer.\n//\n// If the server returns an error, Send returns an error that wraps [io.EOF].\n// Clients should check for EOF using the standard library's [errors.Is] and\n// call Receive to retrieve the error.\nfunc (b *BidiStreamForClient[Req, Res]) Send(msg *Req) error {\n\tif b.err != nil {\n\t\treturn b.err\n\t}\n\tif msg == nil {\n\t\treturn b.conn.Send(nil)\n\t}\n\treturn b.conn.Send(msg)\n}\n\n// CloseRequest closes the send side of the stream.\nfunc (b *BidiStreamForClient[Req, Res]) CloseRequest() error {\n\tif b.err != nil {\n\t\treturn b.err\n\t}\n\treturn b.conn.CloseRequest()\n}\n\n// Receive a message. When the server is done sending messages and no other\n// errors have occurred, Receive will return an error that wraps [io.EOF].\nfunc (b *BidiStreamForClient[Req, Res]) Receive() (*Res, error) {\n\tif b.err != nil {\n\t\treturn nil, b.err\n\t}\n\tvar msg Res\n\tif err := b.initializer.maybe(b.conn.Spec(), &msg); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := b.conn.Receive(&msg); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &msg, nil\n}\n\n// CloseResponse closes the receive side of the stream.\n//\n// CloseResponse is non-blocking. To gracefully close the stream and allow for\n// connection resuse ensure all messages have been received before calling\n// CloseResponse. All messages are received when Receive returns an error\n// wrapping [io.EOF].\nfunc (b *BidiStreamForClient[Req, Res]) CloseResponse() error {\n\tif b.err != nil {\n\t\treturn b.err\n\t}\n\treturn b.conn.CloseResponse()\n}\n\n// ResponseHeader returns the headers received from the server. It blocks until\n// the first call to Receive returns.\nfunc (b *BidiStreamForClient[Req, Res]) ResponseHeader() http.Header {\n\tif b.err != nil {\n\t\treturn http.Header{}\n\t}\n\treturn b.conn.ResponseHeader()\n}\n\n// ResponseTrailer returns the trailers received from the server. Trailers\n// aren't fully populated until Receive() returns an error wrapping [io.EOF].\nfunc (b *BidiStreamForClient[Req, Res]) ResponseTrailer() http.Header {\n\tif b.err != nil {\n\t\treturn http.Header{}\n\t}\n\treturn b.conn.ResponseTrailer()\n}\n\n// Conn exposes the underlying StreamingClientConn. This may be useful if\n// you'd prefer to wrap the connection in a different high-level API.\nfunc (b *BidiStreamForClient[Req, Res]) Conn() (StreamingClientConn, error) {\n\treturn b.conn, b.err\n}\n"
        },
        {
          "name": "client_stream_test.go",
          "type": "blob",
          "size": 3.5048828125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n)\n\nfunc TestClientStreamForClient_NoPanics(t *testing.T) {\n\tt.Parallel()\n\tinitErr := errors.New(\"client init failure\")\n\tclientStream := &ClientStreamForClient[pingv1.PingRequest, pingv1.PingResponse]{err: initErr}\n\tassert.ErrorIs(t, clientStream.Send(&pingv1.PingRequest{}), initErr)\n\tverifyHeaders(t, clientStream.RequestHeader())\n\tres, err := clientStream.CloseAndReceive()\n\tassert.Nil(t, res)\n\tassert.ErrorIs(t, err, initErr)\n\tconn, err := clientStream.Conn()\n\tassert.NotNil(t, err)\n\tassert.Nil(t, conn)\n}\n\nfunc TestServerStreamForClient_NoPanics(t *testing.T) {\n\tt.Parallel()\n\tinitErr := errors.New(\"client init failure\")\n\tserverStream := &ServerStreamForClient[pingv1.PingResponse]{constructErr: initErr}\n\tassert.ErrorIs(t, serverStream.Err(), initErr)\n\tassert.ErrorIs(t, serverStream.Close(), initErr)\n\tassert.NotNil(t, serverStream.Msg())\n\tassert.False(t, serverStream.Receive())\n\tverifyHeaders(t, serverStream.ResponseHeader())\n\tverifyHeaders(t, serverStream.ResponseTrailer())\n\tconn, err := serverStream.Conn()\n\tassert.NotNil(t, err)\n\tassert.Nil(t, conn)\n}\n\nfunc TestServerStreamForClient(t *testing.T) {\n\tt.Parallel()\n\tstream := &ServerStreamForClient[pingv1.PingResponse]{\n\t\tconn: &nopStreamingClientConn{},\n\t}\n\t// Ensure that each call to Receive allocates a new message. This helps\n\t// vtprotobuf, which doesn't automatically zero messages before unmarshaling\n\t// (see https://connectrpc.com/connect/issues/345), and it's also\n\t// less error-prone for users.\n\tassert.True(t, stream.Receive())\n\tfirst := fmt.Sprintf(\"%p\", stream.Msg())\n\tassert.True(t, stream.Receive())\n\tsecond := fmt.Sprintf(\"%p\", stream.Msg())\n\tassert.NotEqual(t, first, second)\n\tconn, err := stream.Conn()\n\tassert.Nil(t, err)\n\tassert.NotNil(t, conn)\n}\n\nfunc TestBidiStreamForClient_NoPanics(t *testing.T) {\n\tt.Parallel()\n\tinitErr := errors.New(\"client init failure\")\n\tbidiStream := &BidiStreamForClient[pingv1.CumSumRequest, pingv1.CumSumResponse]{err: initErr}\n\tres, err := bidiStream.Receive()\n\tassert.Nil(t, res)\n\tassert.ErrorIs(t, err, initErr)\n\tverifyHeaders(t, bidiStream.RequestHeader())\n\tverifyHeaders(t, bidiStream.ResponseHeader())\n\tverifyHeaders(t, bidiStream.ResponseTrailer())\n\tassert.ErrorIs(t, bidiStream.Send(&pingv1.CumSumRequest{}), initErr)\n\tassert.ErrorIs(t, bidiStream.CloseRequest(), initErr)\n\tassert.ErrorIs(t, bidiStream.CloseResponse(), initErr)\n\tconn, err := bidiStream.Conn()\n\tassert.NotNil(t, err)\n\tassert.Nil(t, conn)\n}\n\nfunc verifyHeaders(t *testing.T, headers http.Header) {\n\tt.Helper()\n\tassert.Equal(t, headers, http.Header{})\n\n\t// Verify set/del don't panic\n\theaders.Set(\"A\", \"b\")\n\theaders.Del(\"A\")\n}\n\ntype nopStreamingClientConn struct {\n\tStreamingClientConn\n}\n\nfunc (c *nopStreamingClientConn) Receive(msg any) error {\n\treturn nil\n}\n\nfunc (c *nopStreamingClientConn) Spec() Spec {\n\treturn Spec{}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "code.go",
          "type": "blob",
          "size": 6.4931640625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// A Code is one of the Connect protocol's error codes. There are no user-defined\n// codes, so only the codes enumerated below are valid. In both name and\n// semantics, these codes match the gRPC status codes.\n//\n// The descriptions below are optimized for brevity rather than completeness.\n// See the [Connect protocol specification] for detailed descriptions of each\n// code and example usage.\n//\n// [Connect protocol specification]: https://connectrpc.com/docs/protocol\ntype Code uint32\n\nconst (\n\t// The zero code in gRPC is OK, which indicates that the operation was a\n\t// success. We don't define a constant for it because it overlaps awkwardly\n\t// with Go's error semantics: what does it mean to have a non-nil error with\n\t// an OK status? (Also, the Connect protocol doesn't use a code for\n\t// successes.)\n\n\t// CodeCanceled indicates that the operation was canceled, typically by the\n\t// caller.\n\tCodeCanceled Code = 1\n\n\t// CodeUnknown indicates that the operation failed for an unknown reason.\n\tCodeUnknown Code = 2\n\n\t// CodeInvalidArgument indicates that client supplied an invalid argument.\n\tCodeInvalidArgument Code = 3\n\n\t// CodeDeadlineExceeded indicates that deadline expired before the operation\n\t// could complete.\n\tCodeDeadlineExceeded Code = 4\n\n\t// CodeNotFound indicates that some requested entity (for example, a file or\n\t// directory) was not found.\n\tCodeNotFound Code = 5\n\n\t// CodeAlreadyExists indicates that client attempted to create an entity (for\n\t// example, a file or directory) that already exists.\n\tCodeAlreadyExists Code = 6\n\n\t// CodePermissionDenied indicates that the caller doesn't have permission to\n\t// execute the specified operation.\n\tCodePermissionDenied Code = 7\n\n\t// CodeResourceExhausted indicates that some resource has been exhausted. For\n\t// example, a per-user quota may be exhausted or the entire file system may\n\t// be full.\n\tCodeResourceExhausted Code = 8\n\n\t// CodeFailedPrecondition indicates that the system is not in a state\n\t// required for the operation's execution.\n\tCodeFailedPrecondition Code = 9\n\n\t// CodeAborted indicates that operation was aborted by the system, usually\n\t// because of a concurrency issue such as a sequencer check failure or\n\t// transaction abort.\n\tCodeAborted Code = 10\n\n\t// CodeOutOfRange indicates that the operation was attempted past the valid\n\t// range (for example, seeking past end-of-file).\n\tCodeOutOfRange Code = 11\n\n\t// CodeUnimplemented indicates that the operation isn't implemented,\n\t// supported, or enabled in this service.\n\tCodeUnimplemented Code = 12\n\n\t// CodeInternal indicates that some invariants expected by the underlying\n\t// system have been broken. This code is reserved for serious errors.\n\tCodeInternal Code = 13\n\n\t// CodeUnavailable indicates that the service is currently unavailable. This\n\t// is usually temporary, so clients can back off and retry idempotent\n\t// operations.\n\tCodeUnavailable Code = 14\n\n\t// CodeDataLoss indicates that the operation has resulted in unrecoverable\n\t// data loss or corruption.\n\tCodeDataLoss Code = 15\n\n\t// CodeUnauthenticated indicates that the request does not have valid\n\t// authentication credentials for the operation.\n\tCodeUnauthenticated Code = 16\n\n\tminCode = CodeCanceled\n\tmaxCode = CodeUnauthenticated\n)\n\nfunc (c Code) String() string {\n\tswitch c {\n\tcase CodeCanceled:\n\t\treturn \"canceled\"\n\tcase CodeUnknown:\n\t\treturn \"unknown\"\n\tcase CodeInvalidArgument:\n\t\treturn \"invalid_argument\"\n\tcase CodeDeadlineExceeded:\n\t\treturn \"deadline_exceeded\"\n\tcase CodeNotFound:\n\t\treturn \"not_found\"\n\tcase CodeAlreadyExists:\n\t\treturn \"already_exists\"\n\tcase CodePermissionDenied:\n\t\treturn \"permission_denied\"\n\tcase CodeResourceExhausted:\n\t\treturn \"resource_exhausted\"\n\tcase CodeFailedPrecondition:\n\t\treturn \"failed_precondition\"\n\tcase CodeAborted:\n\t\treturn \"aborted\"\n\tcase CodeOutOfRange:\n\t\treturn \"out_of_range\"\n\tcase CodeUnimplemented:\n\t\treturn \"unimplemented\"\n\tcase CodeInternal:\n\t\treturn \"internal\"\n\tcase CodeUnavailable:\n\t\treturn \"unavailable\"\n\tcase CodeDataLoss:\n\t\treturn \"data_loss\"\n\tcase CodeUnauthenticated:\n\t\treturn \"unauthenticated\"\n\t}\n\treturn fmt.Sprintf(\"code_%d\", c)\n}\n\n// MarshalText implements [encoding.TextMarshaler].\nfunc (c Code) MarshalText() ([]byte, error) {\n\treturn []byte(c.String()), nil\n}\n\n// UnmarshalText implements [encoding.TextUnmarshaler].\nfunc (c *Code) UnmarshalText(data []byte) error {\n\tdataStr := string(data)\n\tswitch dataStr {\n\tcase \"canceled\":\n\t\t*c = CodeCanceled\n\t\treturn nil\n\tcase \"unknown\":\n\t\t*c = CodeUnknown\n\t\treturn nil\n\tcase \"invalid_argument\":\n\t\t*c = CodeInvalidArgument\n\t\treturn nil\n\tcase \"deadline_exceeded\":\n\t\t*c = CodeDeadlineExceeded\n\t\treturn nil\n\tcase \"not_found\":\n\t\t*c = CodeNotFound\n\t\treturn nil\n\tcase \"already_exists\":\n\t\t*c = CodeAlreadyExists\n\t\treturn nil\n\tcase \"permission_denied\":\n\t\t*c = CodePermissionDenied\n\t\treturn nil\n\tcase \"resource_exhausted\":\n\t\t*c = CodeResourceExhausted\n\t\treturn nil\n\tcase \"failed_precondition\":\n\t\t*c = CodeFailedPrecondition\n\t\treturn nil\n\tcase \"aborted\":\n\t\t*c = CodeAborted\n\t\treturn nil\n\tcase \"out_of_range\":\n\t\t*c = CodeOutOfRange\n\t\treturn nil\n\tcase \"unimplemented\":\n\t\t*c = CodeUnimplemented\n\t\treturn nil\n\tcase \"internal\":\n\t\t*c = CodeInternal\n\t\treturn nil\n\tcase \"unavailable\":\n\t\t*c = CodeUnavailable\n\t\treturn nil\n\tcase \"data_loss\":\n\t\t*c = CodeDataLoss\n\t\treturn nil\n\tcase \"unauthenticated\":\n\t\t*c = CodeUnauthenticated\n\t\treturn nil\n\t}\n\t// Ensure that non-canonical codes round-trip through MarshalText and\n\t// UnmarshalText.\n\tif strings.HasPrefix(dataStr, \"code_\") {\n\t\tdataStr = strings.TrimPrefix(dataStr, \"code_\")\n\t\tcode, err := strconv.ParseInt(dataStr, 10 /* base */, 64 /* bitsize */)\n\t\tif err == nil && (code < int64(minCode) || code > int64(maxCode)) {\n\t\t\t*c = Code(code)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"invalid code %q\", dataStr)\n}\n\n// CodeOf returns the error's status code if it is or wraps an [*Error] and\n// [CodeUnknown] otherwise.\nfunc CodeOf(err error) Code {\n\tif connectErr, ok := asError(err); ok {\n\t\treturn connectErr.Code()\n\t}\n\treturn CodeUnknown\n}\n"
        },
        {
          "name": "code_test.go",
          "type": "blob",
          "size": 1.626953125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n)\n\nfunc TestCode(t *testing.T) {\n\tt.Parallel()\n\tvar valid []Code\n\tfor code := minCode; code <= maxCode; code++ {\n\t\tvalid = append(valid, code)\n\t}\n\t// Ensures that we don't forget to update the mapping in the Stringer\n\t// implementation.\n\tfor _, code := range valid {\n\t\tassert.False(\n\t\t\tt,\n\t\t\tstrings.HasPrefix(code.String(), \"code_\"),\n\t\t\tassert.Sprintf(\"update Code.String() method for new code %v\", code),\n\t\t)\n\t\tassertCodeRoundTrips(t, code)\n\t}\n\tassertCodeRoundTrips(t, Code(999))\n}\n\nfunc assertCodeRoundTrips(tb testing.TB, code Code) {\n\ttb.Helper()\n\tencoded, err := code.MarshalText()\n\tassert.Nil(tb, err)\n\tvar decoded Code\n\tassert.Nil(tb, decoded.UnmarshalText(encoded))\n\tassert.Equal(tb, decoded, code)\n\tif code >= minCode && code <= maxCode {\n\t\tvar invalid Code\n\t\t// For the known codes, we only accept the canonical string representation: \"canceled\", not \"code_1\".\n\t\tassert.NotNil(tb, invalid.UnmarshalText([]byte(\"code_\"+strconv.Itoa(int(code)))))\n\t}\n}\n"
        },
        {
          "name": "codec.go",
          "type": "blob",
          "size": 7.8232421875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"google.golang.org/protobuf/encoding/protojson\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/runtime/protoiface\"\n)\n\nconst (\n\tcodecNameProto           = \"proto\"\n\tcodecNameJSON            = \"json\"\n\tcodecNameJSONCharsetUTF8 = codecNameJSON + \"; charset=utf-8\"\n)\n\n// Codec marshals structs (typically generated from a schema) to and from bytes.\ntype Codec interface {\n\t// Name returns the name of the Codec.\n\t//\n\t// This may be used as part of the Content-Type within HTTP. For example,\n\t// with gRPC this is the content subtype, so \"application/grpc+proto\" will\n\t// map to the Codec with name \"proto\".\n\t//\n\t// Names must not be empty.\n\tName() string\n\t// Marshal marshals the given message.\n\t//\n\t// Marshal may expect a specific type of message, and will error if this type\n\t// is not given.\n\tMarshal(any) ([]byte, error)\n\t// Unmarshal unmarshals the given message.\n\t//\n\t// Unmarshal may expect a specific type of message, and will error if this\n\t// type is not given.\n\tUnmarshal([]byte, any) error\n}\n\n// marshalAppender is an extension to Codec for appending to a byte slice.\ntype marshalAppender interface {\n\tCodec\n\n\t// MarshalAppend marshals the given message and appends it to the given\n\t// byte slice.\n\t//\n\t// MarshalAppend may expect a specific type of message, and will error if\n\t// this type is not given.\n\tMarshalAppend([]byte, any) ([]byte, error)\n}\n\n// stableCodec is an extension to Codec for serializing with stable output.\ntype stableCodec interface {\n\tCodec\n\n\t// MarshalStable marshals the given message with stable field ordering.\n\t//\n\t// MarshalStable should return the same output for a given input. Although\n\t// it is not guaranteed to be canonicalized, the marshalling routine for\n\t// MarshalStable will opt for the most normalized output available for a\n\t// given serialization.\n\t//\n\t// For practical reasons, it is possible for MarshalStable to return two\n\t// different results for two inputs considered to be \"equal\" in their own\n\t// domain, and it may change in the future with codec updates, but for\n\t// any given concrete value and any given version, it should return the\n\t// same output.\n\tMarshalStable(any) ([]byte, error)\n\n\t// IsBinary returns true if the marshalled data is binary for this codec.\n\t//\n\t// If this function returns false, the data returned from Marshal and\n\t// MarshalStable are considered valid text and may be used in contexts\n\t// where text is expected.\n\tIsBinary() bool\n}\n\ntype protoBinaryCodec struct{}\n\nvar _ Codec = (*protoBinaryCodec)(nil)\n\nfunc (c *protoBinaryCodec) Name() string { return codecNameProto }\n\nfunc (c *protoBinaryCodec) Marshal(message any) ([]byte, error) {\n\tprotoMessage, ok := message.(proto.Message)\n\tif !ok {\n\t\treturn nil, errNotProto(message)\n\t}\n\treturn proto.Marshal(protoMessage)\n}\n\nfunc (c *protoBinaryCodec) MarshalAppend(dst []byte, message any) ([]byte, error) {\n\tprotoMessage, ok := message.(proto.Message)\n\tif !ok {\n\t\treturn nil, errNotProto(message)\n\t}\n\treturn proto.MarshalOptions{}.MarshalAppend(dst, protoMessage)\n}\n\nfunc (c *protoBinaryCodec) Unmarshal(data []byte, message any) error {\n\tprotoMessage, ok := message.(proto.Message)\n\tif !ok {\n\t\treturn errNotProto(message)\n\t}\n\terr := proto.Unmarshal(data, protoMessage)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unmarshal into %T: %w\", message, err)\n\t}\n\treturn nil\n}\n\nfunc (c *protoBinaryCodec) MarshalStable(message any) ([]byte, error) {\n\tprotoMessage, ok := message.(proto.Message)\n\tif !ok {\n\t\treturn nil, errNotProto(message)\n\t}\n\t// protobuf does not offer a canonical output today, so this format is not\n\t// guaranteed to match deterministic output from other protobuf libraries.\n\t// In addition, unknown fields may cause inconsistent output for otherwise\n\t// equal messages.\n\t// https://github.com/golang/protobuf/issues/1121\n\toptions := proto.MarshalOptions{Deterministic: true}\n\treturn options.Marshal(protoMessage)\n}\n\nfunc (c *protoBinaryCodec) IsBinary() bool {\n\treturn true\n}\n\ntype protoJSONCodec struct {\n\tname string\n}\n\nvar _ Codec = (*protoJSONCodec)(nil)\n\nfunc (c *protoJSONCodec) Name() string { return c.name }\n\nfunc (c *protoJSONCodec) Marshal(message any) ([]byte, error) {\n\tprotoMessage, ok := message.(proto.Message)\n\tif !ok {\n\t\treturn nil, errNotProto(message)\n\t}\n\treturn protojson.MarshalOptions{}.Marshal(protoMessage)\n}\n\nfunc (c *protoJSONCodec) MarshalAppend(dst []byte, message any) ([]byte, error) {\n\tprotoMessage, ok := message.(proto.Message)\n\tif !ok {\n\t\treturn nil, errNotProto(message)\n\t}\n\treturn protojson.MarshalOptions{}.MarshalAppend(dst, protoMessage)\n}\n\nfunc (c *protoJSONCodec) Unmarshal(binary []byte, message any) error {\n\tprotoMessage, ok := message.(proto.Message)\n\tif !ok {\n\t\treturn errNotProto(message)\n\t}\n\tif len(binary) == 0 {\n\t\treturn errors.New(\"zero-length payload is not a valid JSON object\")\n\t}\n\t// Discard unknown fields so clients and servers aren't forced to always use\n\t// exactly the same version of the schema.\n\toptions := protojson.UnmarshalOptions{DiscardUnknown: true}\n\terr := options.Unmarshal(binary, protoMessage)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unmarshal into %T: %w\", message, err)\n\t}\n\treturn nil\n}\n\nfunc (c *protoJSONCodec) MarshalStable(message any) ([]byte, error) {\n\t// protojson does not offer a \"deterministic\" field ordering, but fields\n\t// are still ordered consistently by their index. However, protojson can\n\t// output inconsistent whitespace for some reason, therefore it is\n\t// suggested to use a formatter to ensure consistent formatting.\n\t// https://github.com/golang/protobuf/issues/1373\n\tmessageJSON, err := c.Marshal(message)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcompactedJSON := bytes.NewBuffer(messageJSON[:0])\n\tif err = json.Compact(compactedJSON, messageJSON); err != nil {\n\t\treturn nil, err\n\t}\n\treturn compactedJSON.Bytes(), nil\n}\n\nfunc (c *protoJSONCodec) IsBinary() bool {\n\treturn false\n}\n\n// readOnlyCodecs is a read-only interface to a map of named codecs.\ntype readOnlyCodecs interface {\n\t// Get gets the Codec with the given name.\n\tGet(string) Codec\n\t// Protobuf gets the user-supplied protobuf codec, falling back to the default\n\t// implementation if necessary.\n\t//\n\t// This is helpful in the gRPC protocol, where the wire protocol requires\n\t// marshaling protobuf structs to binary even if the RPC procedures were\n\t// generated from a different IDL.\n\tProtobuf() Codec\n\t// Names returns a copy of the registered codec names. The returned slice is\n\t// safe for the caller to mutate.\n\tNames() []string\n}\n\nfunc newReadOnlyCodecs(nameToCodec map[string]Codec) readOnlyCodecs {\n\treturn &codecMap{\n\t\tnameToCodec: nameToCodec,\n\t}\n}\n\ntype codecMap struct {\n\tnameToCodec map[string]Codec\n}\n\nfunc (m *codecMap) Get(name string) Codec {\n\treturn m.nameToCodec[name]\n}\n\nfunc (m *codecMap) Protobuf() Codec {\n\tif pb, ok := m.nameToCodec[codecNameProto]; ok {\n\t\treturn pb\n\t}\n\treturn &protoBinaryCodec{}\n}\n\nfunc (m *codecMap) Names() []string {\n\tnames := make([]string, 0, len(m.nameToCodec))\n\tfor name := range m.nameToCodec {\n\t\tnames = append(names, name)\n\t}\n\treturn names\n}\n\nfunc errNotProto(message any) error {\n\tif _, ok := message.(protoiface.MessageV1); ok {\n\t\treturn fmt.Errorf(\"%T uses github.com/golang/protobuf, but connect-go only supports google.golang.org/protobuf: see https://go.dev/blog/protobuf-apiv2\", message)\n\t}\n\treturn fmt.Errorf(\"%T doesn't implement proto.Message\", message)\n}\n"
        },
        {
          "name": "codec_test.go",
          "type": "blob",
          "size": 4.0859375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n\t\"testing\"\n\t\"testing/quick\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n)\n\nfunc convertMapToInterface(stringMap map[string]string) map[string]interface{} {\n\tinterfaceMap := make(map[string]interface{})\n\tfor key, value := range stringMap {\n\t\tinterfaceMap[key] = value\n\t}\n\treturn interfaceMap\n}\n\nfunc TestCodecRoundTrips(t *testing.T) {\n\tt.Parallel()\n\tmakeRoundtrip := func(codec Codec) func(string, int64) bool {\n\t\treturn func(text string, number int64) bool {\n\t\t\tgot := pingv1.PingRequest{}\n\t\t\twant := pingv1.PingRequest{Text: text, Number: number}\n\t\t\tdata, err := codec.Marshal(&want)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\terr = codec.Unmarshal(data, &got)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn proto.Equal(&got, &want)\n\t\t}\n\t}\n\tif err := quick.Check(makeRoundtrip(&protoBinaryCodec{}), nil /* config */); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := quick.Check(makeRoundtrip(&protoJSONCodec{}), nil /* config */); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestAppendCodec(t *testing.T) {\n\tt.Parallel()\n\tmakeRoundtrip := func(codec marshalAppender) func(string, int64) bool {\n\t\tvar data []byte\n\t\treturn func(text string, number int64) bool {\n\t\t\tgot := pingv1.PingRequest{}\n\t\t\twant := pingv1.PingRequest{Text: text, Number: number}\n\t\t\tdata = data[:0]\n\t\t\tvar err error\n\t\t\tdata, err = codec.MarshalAppend(data, &want)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\terr = codec.Unmarshal(data, &got)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\treturn proto.Equal(&got, &want)\n\t\t}\n\t}\n\tif err := quick.Check(makeRoundtrip(&protoBinaryCodec{}), nil /* config */); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := quick.Check(makeRoundtrip(&protoJSONCodec{}), nil /* config */); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestStableCodec(t *testing.T) {\n\tt.Parallel()\n\tmakeRoundtrip := func(codec stableCodec) func(map[string]string) bool {\n\t\treturn func(input map[string]string) bool {\n\t\t\tinitialProto, err := structpb.NewStruct(convertMapToInterface(input))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\twant, err := codec.MarshalStable(initialProto)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\troundtripProto := &structpb.Struct{}\n\t\t\t\terr = codec.Unmarshal(want, roundtripProto)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tgot, err := codec.MarshalStable(roundtripProto)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif !bytes.Equal(got, want) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t}\n\tif err := quick.Check(makeRoundtrip(&protoBinaryCodec{}), nil /* config */); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := quick.Check(makeRoundtrip(&protoJSONCodec{}), nil /* config */); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestJSONCodec(t *testing.T) {\n\tt.Parallel()\n\n\tcodec := &protoJSONCodec{name: codecNameJSON}\n\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\terr := codec.Unmarshal([]byte(\"{}\"), &emptypb.Empty{})\n\t\tassert.Nil(t, err)\n\t})\n\n\tt.Run(\"unknown fields\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\terr := codec.Unmarshal([]byte(`{\"foo\": \"bar\"}`), &emptypb.Empty{})\n\t\tassert.Nil(t, err)\n\t})\n\n\tt.Run(\"empty string\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\terr := codec.Unmarshal([]byte{}, &emptypb.Empty{})\n\t\tassert.NotNil(t, err)\n\t\tassert.True(\n\t\t\tt,\n\t\t\tstrings.Contains(err.Error(), \"valid JSON\"),\n\t\t\tassert.Sprintf(`error message should explain that \"\" is not a valid JSON object`),\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "compression.go",
          "type": "blob",
          "size": 6.7177734375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n)\n\nconst (\n\tcompressionGzip     = \"gzip\"\n\tcompressionIdentity = \"identity\"\n)\n\n// A Decompressor is a reusable wrapper that decompresses an underlying data\n// source. The standard library's [*gzip.Reader] implements Decompressor.\ntype Decompressor interface {\n\tio.Reader\n\n\t// Close closes the Decompressor, but not the underlying data source. It may\n\t// return an error if the Decompressor wasn't read to EOF.\n\tClose() error\n\n\t// Reset discards the Decompressor's internal state, if any, and prepares it\n\t// to read from a new source of compressed data.\n\tReset(io.Reader) error\n}\n\n// A Compressor is a reusable wrapper that compresses data written to an\n// underlying sink. The standard library's [*gzip.Writer] implements Compressor.\ntype Compressor interface {\n\tio.Writer\n\n\t// Close flushes any buffered data to the underlying sink, then closes the\n\t// Compressor. It must not close the underlying sink.\n\tClose() error\n\n\t// Reset discards the Compressor's internal state, if any, and prepares it to\n\t// write compressed data to a new sink.\n\tReset(io.Writer)\n}\n\ntype compressionPool struct {\n\tdecompressors sync.Pool\n\tcompressors   sync.Pool\n}\n\nfunc newCompressionPool(\n\tnewDecompressor func() Decompressor,\n\tnewCompressor func() Compressor,\n) *compressionPool {\n\tif newDecompressor == nil && newCompressor == nil {\n\t\treturn nil\n\t}\n\treturn &compressionPool{\n\t\tdecompressors: sync.Pool{\n\t\t\tNew: func() any { return newDecompressor() },\n\t\t},\n\t\tcompressors: sync.Pool{\n\t\t\tNew: func() any { return newCompressor() },\n\t\t},\n\t}\n}\n\nfunc (c *compressionPool) Decompress(dst *bytes.Buffer, src *bytes.Buffer, readMaxBytes int64) *Error {\n\tdecompressor, err := c.getDecompressor(src)\n\tif err != nil {\n\t\treturn errorf(CodeInvalidArgument, \"get decompressor: %w\", err)\n\t}\n\treader := io.Reader(decompressor)\n\tif readMaxBytes > 0 && readMaxBytes < math.MaxInt64 {\n\t\treader = io.LimitReader(decompressor, readMaxBytes+1)\n\t}\n\tbytesRead, err := dst.ReadFrom(reader)\n\tif err != nil {\n\t\t_ = c.putDecompressor(decompressor)\n\t\terr = wrapIfContextError(err)\n\t\tif connectErr, ok := asError(err); ok {\n\t\t\treturn connectErr\n\t\t}\n\t\treturn errorf(CodeInvalidArgument, \"decompress: %w\", err)\n\t}\n\tif readMaxBytes > 0 && bytesRead > readMaxBytes {\n\t\tdiscardedBytes, err := io.Copy(io.Discard, decompressor)\n\t\t_ = c.putDecompressor(decompressor)\n\t\tif err != nil {\n\t\t\treturn errorf(CodeResourceExhausted, \"message is larger than configured max %d - unable to determine message size: %w\", readMaxBytes, err)\n\t\t}\n\t\treturn errorf(CodeResourceExhausted, \"message size %d is larger than configured max %d\", bytesRead+discardedBytes, readMaxBytes)\n\t}\n\tif err := c.putDecompressor(decompressor); err != nil {\n\t\treturn errorf(CodeUnknown, \"recycle decompressor: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *compressionPool) Compress(dst *bytes.Buffer, src *bytes.Buffer) *Error {\n\tcompressor, err := c.getCompressor(dst)\n\tif err != nil {\n\t\treturn errorf(CodeUnknown, \"get compressor: %w\", err)\n\t}\n\tif _, err := src.WriteTo(compressor); err != nil {\n\t\t_ = c.putCompressor(compressor)\n\t\terr = wrapIfContextError(err)\n\t\tif connectErr, ok := asError(err); ok {\n\t\t\treturn connectErr\n\t\t}\n\t\treturn errorf(CodeInternal, \"compress: %w\", err)\n\t}\n\tif err := c.putCompressor(compressor); err != nil {\n\t\treturn errorf(CodeInternal, \"recycle compressor: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (c *compressionPool) getDecompressor(reader io.Reader) (Decompressor, error) {\n\tdecompressor, ok := c.decompressors.Get().(Decompressor)\n\tif !ok {\n\t\treturn nil, errors.New(\"expected Decompressor, got incorrect type from pool\")\n\t}\n\treturn decompressor, decompressor.Reset(reader)\n}\n\nfunc (c *compressionPool) putDecompressor(decompressor Decompressor) error {\n\tif err := decompressor.Close(); err != nil {\n\t\treturn err\n\t}\n\t// While it's in the pool, we don't want the decompressor to retain a\n\t// reference to the underlying reader. However, most decompressors attempt to\n\t// read some header data from the new data source when Reset; since we don't\n\t// know the compression format, we can't provide a valid header. Since we\n\t// also reset the decompressor when it's pulled out of the pool, we can\n\t// ignore errors here.\n\t_ = decompressor.Reset(http.NoBody)\n\tc.decompressors.Put(decompressor)\n\treturn nil\n}\n\nfunc (c *compressionPool) getCompressor(writer io.Writer) (Compressor, error) {\n\tcompressor, ok := c.compressors.Get().(Compressor)\n\tif !ok {\n\t\treturn nil, errors.New(\"expected Compressor, got incorrect type from pool\")\n\t}\n\tcompressor.Reset(writer)\n\treturn compressor, nil\n}\n\nfunc (c *compressionPool) putCompressor(compressor Compressor) error {\n\tif err := compressor.Close(); err != nil {\n\t\treturn err\n\t}\n\tcompressor.Reset(io.Discard) // don't keep references\n\tc.compressors.Put(compressor)\n\treturn nil\n}\n\n// readOnlyCompressionPools is a read-only interface to a map of named\n// compressionPools.\ntype readOnlyCompressionPools interface {\n\tGet(string) *compressionPool\n\tContains(string) bool\n\t// Wordy, but clarifies how this is different from readOnlyCodecs.Names().\n\tCommaSeparatedNames() string\n}\n\nfunc newReadOnlyCompressionPools(\n\tnameToPool map[string]*compressionPool,\n\treversedNames []string,\n) readOnlyCompressionPools {\n\t// Client and handler configs keep compression names in registration order,\n\t// but we want the last registered to be the most preferred.\n\tnames := make([]string, 0, len(reversedNames))\n\tseen := make(map[string]struct{}, len(reversedNames))\n\tfor i := len(reversedNames) - 1; i >= 0; i-- {\n\t\tname := reversedNames[i]\n\t\tif _, ok := seen[name]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tseen[name] = struct{}{}\n\t\tnames = append(names, name)\n\t}\n\treturn &namedCompressionPools{\n\t\tnameToPool:          nameToPool,\n\t\tcommaSeparatedNames: strings.Join(names, \",\"),\n\t}\n}\n\ntype namedCompressionPools struct {\n\tnameToPool          map[string]*compressionPool\n\tcommaSeparatedNames string\n}\n\nfunc (m *namedCompressionPools) Get(name string) *compressionPool {\n\tif name == \"\" || name == compressionIdentity {\n\t\treturn nil\n\t}\n\treturn m.nameToPool[name]\n}\n\nfunc (m *namedCompressionPools) Contains(name string) bool {\n\t_, ok := m.nameToPool[name]\n\treturn ok\n}\n\nfunc (m *namedCompressionPools) CommaSeparatedNames() string {\n\treturn m.commaSeparatedNames\n}\n"
        },
        {
          "name": "compression_test.go",
          "type": "blob",
          "size": 5.4306640625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n\t\"connectrpc.com/connect/internal/memhttp/memhttptest\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n)\n\nfunc TestAcceptEncodingOrdering(t *testing.T) {\n\tt.Parallel()\n\tconst (\n\t\tcompressionBrotli = \"br\"\n\t\texpect            = compressionGzip + \",\" + compressionBrotli\n\t)\n\n\twithFakeBrotli, ok := withGzip().(*compressionOption)\n\tassert.True(t, ok)\n\twithFakeBrotli.Name = compressionBrotli\n\n\tvar called bool\n\tverify := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tgot := r.Header.Get(connectUnaryHeaderAcceptCompression)\n\t\tassert.Equal(t, got, expect)\n\t\tw.WriteHeader(http.StatusOK)\n\t\tcalled = true\n\t})\n\tserver := memhttptest.NewServer(t, verify)\n\tclient := NewClient[emptypb.Empty, emptypb.Empty](\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t\twithFakeBrotli,\n\t\twithGzip(),\n\t)\n\t_, _ = client.CallUnary(context.Background(), NewRequest(&emptypb.Empty{}))\n\tassert.True(t, called)\n}\n\nfunc TestClientCompressionOptionTest(t *testing.T) {\n\tt.Parallel()\n\tconst testURL = \"http://foo.bar.com/service/method\"\n\n\tcheckPools := func(t *testing.T, config *clientConfig) {\n\t\tt.Helper()\n\t\tassert.Equal(t, len(config.CompressionNames), len(config.CompressionPools))\n\t\tfor _, name := range config.CompressionNames {\n\t\t\tpool := config.CompressionPools[name]\n\t\t\tassert.NotNil(t, pool)\n\t\t}\n\t}\n\tdummyDecompressCtor := func() Decompressor { return nil }\n\tdummyCompressCtor := func() Compressor { return nil }\n\n\tt.Run(\"defaults\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tconfig, err := newClientConfig(testURL, nil)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, config.CompressionNames, []string{compressionGzip})\n\t\tcheckPools(t, config)\n\t})\n\tt.Run(\"WithAcceptCompression\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\topts := []ClientOption{WithAcceptCompression(\"foo\", dummyDecompressCtor, dummyCompressCtor)}\n\t\tconfig, err := newClientConfig(testURL, opts)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, config.CompressionNames, []string{compressionGzip, \"foo\"})\n\t\tcheckPools(t, config)\n\t})\n\tt.Run(\"WithAcceptCompression-empty-name-noop\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\topts := []ClientOption{WithAcceptCompression(\"\", dummyDecompressCtor, dummyCompressCtor)}\n\t\tconfig, err := newClientConfig(testURL, opts)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, config.CompressionNames, []string{compressionGzip})\n\t\tcheckPools(t, config)\n\t})\n\tt.Run(\"WithAcceptCompression-nil-ctors-noop\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\topts := []ClientOption{WithAcceptCompression(\"foo\", nil, nil)}\n\t\tconfig, err := newClientConfig(testURL, opts)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, config.CompressionNames, []string{compressionGzip})\n\t\tcheckPools(t, config)\n\t})\n\tt.Run(\"WithAcceptCompression-nil-ctors-unregisters\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\topts := []ClientOption{WithAcceptCompression(\"gzip\", nil, nil)}\n\t\tconfig, err := newClientConfig(testURL, opts)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, config.CompressionNames, nil)\n\t\tcheckPools(t, config)\n\t})\n}\n\nfunc TestHandlerCompressionOptionTest(t *testing.T) {\n\tt.Parallel()\n\tconst testProc = \"/service/method\"\n\n\tcheckPools := func(t *testing.T, config *handlerConfig) {\n\t\tt.Helper()\n\t\tassert.Equal(t, len(config.CompressionNames), len(config.CompressionPools))\n\t\tfor _, name := range config.CompressionNames {\n\t\t\tpool := config.CompressionPools[name]\n\t\t\tassert.NotNil(t, pool)\n\t\t}\n\t}\n\tdummyDecompressCtor := func() Decompressor { return nil }\n\tdummyCompressCtor := func() Compressor { return nil }\n\n\tt.Run(\"defaults\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tconfig := newHandlerConfig(testProc, StreamTypeUnary, nil)\n\t\tassert.Equal(t, config.CompressionNames, []string{compressionGzip})\n\t\tcheckPools(t, config)\n\t})\n\tt.Run(\"WithCompression\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\topts := []HandlerOption{WithCompression(\"foo\", dummyDecompressCtor, dummyCompressCtor)}\n\t\tconfig := newHandlerConfig(testProc, StreamTypeUnary, opts)\n\t\tassert.Equal(t, config.CompressionNames, []string{compressionGzip, \"foo\"})\n\t\tcheckPools(t, config)\n\t})\n\tt.Run(\"WithCompression-empty-name-noop\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\topts := []HandlerOption{WithCompression(\"\", dummyDecompressCtor, dummyCompressCtor)}\n\t\tconfig := newHandlerConfig(testProc, StreamTypeUnary, opts)\n\t\tassert.Equal(t, config.CompressionNames, []string{compressionGzip})\n\t\tcheckPools(t, config)\n\t})\n\tt.Run(\"WithCompression-nil-ctors-noop\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\topts := []HandlerOption{WithCompression(\"foo\", nil, nil)}\n\t\tconfig := newHandlerConfig(testProc, StreamTypeUnary, opts)\n\t\tassert.Equal(t, config.CompressionNames, []string{compressionGzip})\n\t\tcheckPools(t, config)\n\t})\n\tt.Run(\"WithCompression-nil-ctors-unregisters\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\topts := []HandlerOption{WithCompression(\"gzip\", nil, nil)}\n\t\tconfig := newHandlerConfig(testProc, StreamTypeUnary, opts)\n\t\tassert.Equal(t, config.CompressionNames, nil)\n\t\tcheckPools(t, config)\n\t})\n}\n"
        },
        {
          "name": "connect.go",
          "type": "blob",
          "size": 14.8125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package connect is a slim RPC framework built on Protocol Buffers and\n// [net/http]. In addition to supporting its own protocol, Connect handlers and\n// clients are wire-compatible with gRPC and gRPC-Web, including streaming.\n//\n// This documentation is intended to explain each type and function in\n// isolation. Walkthroughs, FAQs, and other narrative docs are available on the\n// [Connect website], and there's a working [demonstration service] on Github.\n//\n// [Connect website]: https://connectrpc.com\n// [demonstration service]: https://github.com/connectrpc/examples-go\npackage connect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// Version is the semantic version of the connect module.\nconst Version = \"1.19.0-dev\"\n\n// These constants are used in compile-time handshakes with connect's generated\n// code.\nconst (\n\tIsAtLeastVersion0_0_1  = true\n\tIsAtLeastVersion0_1_0  = true\n\tIsAtLeastVersion1_7_0  = true\n\tIsAtLeastVersion1_13_0 = true\n)\n\n// StreamType describes whether the client, server, neither, or both is\n// streaming.\ntype StreamType uint8\n\nconst (\n\tStreamTypeUnary  StreamType = 0b00\n\tStreamTypeClient StreamType = 0b01\n\tStreamTypeServer StreamType = 0b10\n\tStreamTypeBidi              = StreamTypeClient | StreamTypeServer\n)\n\nfunc (s StreamType) String() string {\n\tswitch s {\n\tcase StreamTypeUnary:\n\t\treturn \"unary\"\n\tcase StreamTypeClient:\n\t\treturn \"client\"\n\tcase StreamTypeServer:\n\t\treturn \"server\"\n\tcase StreamTypeBidi:\n\t\treturn \"bidi\"\n\t}\n\treturn fmt.Sprintf(\"stream_%d\", s)\n}\n\n// StreamingHandlerConn is the server's view of a bidirectional message\n// exchange. Interceptors for streaming RPCs may wrap StreamingHandlerConns.\n//\n// Like the standard library's [http.ResponseWriter], StreamingHandlerConns write\n// response headers to the network with the first call to Send. Any subsequent\n// mutations are effectively no-ops. Handlers may mutate response trailers at\n// any time before returning. When the client has finished sending data,\n// Receive returns an error wrapping [io.EOF]. Handlers should check for this\n// using the standard library's [errors.Is].\n//\n// Headers and trailers beginning with \"Connect-\" and \"Grpc-\" are reserved for\n// use by the gRPC and Connect protocols: applications may read them but\n// shouldn't write them.\n//\n// StreamingHandlerConn implementations provided by this module guarantee that\n// all returned errors can be cast to [*Error] using the standard library's\n// [errors.As].\n//\n// StreamingHandlerConn implementations do not need to be safe for concurrent use.\ntype StreamingHandlerConn interface {\n\tSpec() Spec\n\tPeer() Peer\n\n\tReceive(any) error\n\tRequestHeader() http.Header\n\n\tSend(any) error\n\tResponseHeader() http.Header\n\tResponseTrailer() http.Header\n}\n\n// StreamingClientConn is the client's view of a bidirectional message exchange.\n// Interceptors for streaming RPCs may wrap StreamingClientConns.\n//\n// StreamingClientConns write request headers to the network with the first\n// call to Send. Any subsequent mutations are effectively no-ops. When the\n// server is done sending data, the StreamingClientConn's Receive method\n// returns an error wrapping [io.EOF]. Clients should check for this using the\n// standard library's [errors.Is]. If the server encounters an error during\n// processing, subsequent calls to the StreamingClientConn's Send method will\n// return an error wrapping [io.EOF]; clients may then call Receive to unmarshal\n// the error.\n//\n// Headers and trailers beginning with \"Connect-\" and \"Grpc-\" are reserved for\n// use by the gRPC and Connect protocols: applications may read them but\n// shouldn't write them.\n//\n// StreamingClientConn implementations provided by this module guarantee that\n// all returned errors can be cast to [*Error] using the standard library's\n// [errors.As].\n//\n// In order to support bidirectional streaming RPCs, all StreamingClientConn\n// implementations must support limited concurrent use. See the comments on\n// each group of methods for details.\ntype StreamingClientConn interface {\n\t// Spec and Peer must be safe to call concurrently with all other methods.\n\tSpec() Spec\n\tPeer() Peer\n\n\t// Send, RequestHeader, and CloseRequest may race with each other, but must\n\t// be safe to call concurrently with all other methods.\n\tSend(any) error\n\tRequestHeader() http.Header\n\tCloseRequest() error\n\n\t// Receive, ResponseHeader, ResponseTrailer, and CloseResponse may race with\n\t// each other, but must be safe to call concurrently with all other methods.\n\tReceive(any) error\n\tResponseHeader() http.Header\n\tResponseTrailer() http.Header\n\tCloseResponse() error\n}\n\n// Request is a wrapper around a generated request message. It provides\n// access to metadata like headers and the RPC specification, as well as\n// strongly-typed access to the message itself.\ntype Request[T any] struct {\n\tMsg *T\n\n\tspec   Spec\n\tpeer   Peer\n\theader http.Header\n\tmethod string\n}\n\n// NewRequest wraps a generated request message.\nfunc NewRequest[T any](message *T) *Request[T] {\n\treturn &Request[T]{\n\t\tMsg: message,\n\t\t// Initialized lazily so we don't allocate unnecessarily.\n\t\theader: nil,\n\t}\n}\n\n// Any returns the concrete request message as an empty interface, so that\n// *Request implements the [AnyRequest] interface.\nfunc (r *Request[_]) Any() any {\n\treturn r.Msg\n}\n\n// Spec returns a description of this RPC.\nfunc (r *Request[_]) Spec() Spec {\n\treturn r.spec\n}\n\n// Peer describes the other party for this RPC.\nfunc (r *Request[_]) Peer() Peer {\n\treturn r.peer\n}\n\n// Header returns the HTTP headers for this request. Headers beginning with\n// \"Connect-\" and \"Grpc-\" are reserved for use by the Connect and gRPC\n// protocols: applications may read them but shouldn't write them.\nfunc (r *Request[_]) Header() http.Header {\n\tif r.header == nil {\n\t\tr.header = make(http.Header)\n\t}\n\treturn r.header\n}\n\n// HTTPMethod returns the HTTP method for this request. This is nearly always\n// POST, but side-effect-free unary RPCs could be made via a GET.\n//\n// On a newly created request, via NewRequest, this will return the empty\n// string until the actual request is actually sent and the HTTP method\n// determined. This means that client interceptor functions will see the\n// empty string until *after* they delegate to the handler they wrapped. It\n// is even possible for this to return the empty string after such delegation,\n// if the request was never actually sent to the server (and thus no\n// determination ever made about the HTTP method).\nfunc (r *Request[_]) HTTPMethod() string {\n\treturn r.method\n}\n\n// internalOnly implements AnyRequest.\nfunc (r *Request[_]) internalOnly() {}\n\n// setRequestMethod sets the request method to the given value.\nfunc (r *Request[_]) setRequestMethod(method string) {\n\tr.method = method\n}\n\n// AnyRequest is the common method set of every [Request], regardless of type\n// parameter. It's used in unary interceptors.\n//\n// Headers and trailers beginning with \"Connect-\" and \"Grpc-\" are reserved for\n// use by the gRPC and Connect protocols: applications may read them but\n// shouldn't write them.\n//\n// To preserve our ability to add methods to this interface without breaking\n// backward compatibility, only types defined in this package can implement\n// AnyRequest.\ntype AnyRequest interface {\n\tAny() any\n\tSpec() Spec\n\tPeer() Peer\n\tHeader() http.Header\n\tHTTPMethod() string\n\n\tinternalOnly()\n\tsetRequestMethod(string)\n}\n\n// Response is a wrapper around a generated response message. It provides\n// access to metadata like headers and trailers, as well as strongly-typed\n// access to the message itself.\ntype Response[T any] struct {\n\tMsg *T\n\n\theader  http.Header\n\ttrailer http.Header\n}\n\n// NewResponse wraps a generated response message.\nfunc NewResponse[T any](message *T) *Response[T] {\n\treturn &Response[T]{\n\t\tMsg: message,\n\t\t// Initialized lazily so we don't allocate unnecessarily.\n\t\theader:  nil,\n\t\ttrailer: nil,\n\t}\n}\n\n// Any returns the concrete response message as an empty interface, so that\n// *Response implements the [AnyResponse] interface.\nfunc (r *Response[_]) Any() any {\n\treturn r.Msg\n}\n\n// Header returns the HTTP headers for this response. Headers beginning with\n// \"Connect-\" and \"Grpc-\" are reserved for use by the Connect and gRPC\n// protocols: applications may read them but shouldn't write them.\nfunc (r *Response[_]) Header() http.Header {\n\tif r.header == nil {\n\t\tr.header = make(http.Header)\n\t}\n\treturn r.header\n}\n\n// Trailer returns the trailers for this response. Depending on the underlying\n// RPC protocol, trailers may be sent as HTTP trailers or a protocol-specific\n// block of in-body metadata.\n//\n// Trailers beginning with \"Connect-\" and \"Grpc-\" are reserved for use by the\n// Connect and gRPC protocols: applications may read them but shouldn't write\n// them.\nfunc (r *Response[_]) Trailer() http.Header {\n\tif r.trailer == nil {\n\t\tr.trailer = make(http.Header)\n\t}\n\treturn r.trailer\n}\n\n// internalOnly implements AnyResponse.\nfunc (r *Response[_]) internalOnly() {}\n\n// AnyResponse is the common method set of every [Response], regardless of type\n// parameter. It's used in unary interceptors.\n//\n// Headers and trailers beginning with \"Connect-\" and \"Grpc-\" are reserved for\n// use by the gRPC and Connect protocols: applications may read them but\n// shouldn't write them.\n//\n// To preserve our ability to add methods to this interface without breaking\n// backward compatibility, only types defined in this package can implement\n// AnyResponse.\ntype AnyResponse interface {\n\tAny() any\n\tHeader() http.Header\n\tTrailer() http.Header\n\n\tinternalOnly()\n}\n\n// HTTPClient is the interface connect expects HTTP clients to implement. The\n// standard library's *http.Client implements HTTPClient.\ntype HTTPClient interface {\n\tDo(*http.Request) (*http.Response, error)\n}\n\n// Spec is a description of a client call or a handler invocation.\n//\n// If you're using Protobuf, protoc-gen-connect-go generates a constant for the\n// fully-qualified Procedure corresponding to each RPC in your schema.\ntype Spec struct {\n\tStreamType       StreamType\n\tSchema           any    // for protobuf RPCs, a protoreflect.MethodDescriptor\n\tProcedure        string // for example, \"/acme.foo.v1.FooService/Bar\"\n\tIsClient         bool   // otherwise we're in a handler\n\tIdempotencyLevel IdempotencyLevel\n}\n\n// Peer describes the other party to an RPC.\n//\n// When accessed client-side, Addr contains the host or host:port from the\n// server's URL. When accessed server-side, Addr contains the client's address\n// in IP:port format.\n//\n// On both the client and the server, Protocol is the RPC protocol in use.\n// Currently, it's either [ProtocolConnect], [ProtocolGRPC], or\n// [ProtocolGRPCWeb], but additional protocols may be added in the future.\n//\n// Query contains the query parameters for the request. For the server, this\n// will reflect the actual query parameters sent. For the client, it is unset.\ntype Peer struct {\n\tAddr     string\n\tProtocol string\n\tQuery    url.Values // server-only\n}\n\nfunc newPeerFromURL(url *url.URL, protocol string) Peer {\n\treturn Peer{\n\t\tAddr:     url.Host,\n\t\tProtocol: protocol,\n\t}\n}\n\n// handlerConnCloser extends StreamingHandlerConn with a method for handlers to\n// terminate the message exchange (and optionally send an error to the client).\ntype handlerConnCloser interface {\n\tStreamingHandlerConn\n\n\tClose(error) error\n}\n\n// receiveConn represents the shared methods of both StreamingClientConn and StreamingHandlerConn\n// that the below helper functions use for implementing the rules around a \"unary\" stream, that\n// is expected to have exactly one message (or zero messages followed by a non-EOF error).\ntype receiveConn interface {\n\tSpec() Spec\n\tReceive(any) error\n}\n\n// hasHTTPMethod is implemented by streaming connections that support HTTP methods other than\n// POST.\ntype hasHTTPMethod interface {\n\tgetHTTPMethod() string\n}\n\n// receiveUnaryResponse unmarshals a message from a StreamingClientConn, then\n// envelopes the message and attaches headers and trailers. It attempts to\n// consume the response stream and isn't appropriate when receiving multiple\n// messages.\nfunc receiveUnaryResponse[T any](conn StreamingClientConn, initializer maybeInitializer) (*Response[T], error) {\n\tmsg, err := receiveUnaryMessage[T](conn, initializer, \"response\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Response[T]{\n\t\tMsg:     msg,\n\t\theader:  conn.ResponseHeader(),\n\t\ttrailer: conn.ResponseTrailer(),\n\t}, nil\n}\n\n// receiveUnaryRequest unmarshals a message from a StreamingClientConn, then\n// envelopes the message and attaches headers and other request properties. It\n// attempts to consume the request stream and isn't appropriate when receiving\n// multiple messages.\nfunc receiveUnaryRequest[T any](conn StreamingHandlerConn, initializer maybeInitializer) (*Request[T], error) {\n\tmsg, err := receiveUnaryMessage[T](conn, initializer, \"request\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmethod := http.MethodPost\n\tif hasRequestMethod, ok := conn.(hasHTTPMethod); ok {\n\t\tmethod = hasRequestMethod.getHTTPMethod()\n\t}\n\treturn &Request[T]{\n\t\tMsg:    msg,\n\t\tspec:   conn.Spec(),\n\t\tpeer:   conn.Peer(),\n\t\theader: conn.RequestHeader(),\n\t\tmethod: method,\n\t}, nil\n}\n\nfunc receiveUnaryMessage[T any](conn receiveConn, initializer maybeInitializer, what string) (*T, error) {\n\tvar msg T\n\tif err := initializer.maybe(conn.Spec(), &msg); err != nil {\n\t\treturn nil, err\n\t}\n\t// Possibly counter-intuitive, but the gRPC specs about error codes state that both clients\n\t// and servers should return \"unimplemented\" when they encounter a cardinality violation: where\n\t// the number of messages in the stream is wrong. Search for \"cardinality violation\" in the\n\t// following docs:\n\t//    https://grpc.github.io/grpc/core/md_doc_statuscodes.html\n\tif err := conn.Receive(&msg); err != nil {\n\t\tif errors.Is(err, io.EOF) {\n\t\t\terr = NewError(CodeUnimplemented, fmt.Errorf(\"unary %s has zero messages\", what))\n\t\t}\n\t\treturn nil, err\n\t}\n\t// In a well-formed stream, the one message must be the only content in the body.\n\t// To verify that it is well-formed, try to read another message from the stream.\n\t// TODO: optimize this second receive: ideally do it w/out allocation, w/out\n\t//       fully reading next message (if one is present), and w/out trying to\n\t//       actually unmarshal the bytes)\n\tvar msg2 T\n\tif err := initializer.maybe(conn.Spec(), &msg2); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := conn.Receive(&msg2); !errors.Is(err, io.EOF) {\n\t\tif err == nil {\n\t\t\terr = NewError(CodeUnimplemented, fmt.Errorf(\"unary %s has multiple messages\", what))\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &msg, nil\n}\n"
        },
        {
          "name": "connect_ext_test.go",
          "type": "blob",
          "size": 107.0029296875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"bytes\"\n\t\"compress/flate\"\n\t\"compress/gzip\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\tconnect \"connectrpc.com/connect\"\n\t\"connectrpc.com/connect/internal/assert\"\n\t\"connectrpc.com/connect/internal/gen/connect/import/v1/importv1connect\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n\t\"connectrpc.com/connect/internal/memhttp\"\n\t\"connectrpc.com/connect/internal/memhttp/memhttptest\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/reflect/protoregistry\"\n\t\"google.golang.org/protobuf/types/known/wrapperspb\"\n)\n\nconst errorMessage = \"oh no\"\n\n// The ping server implementation used in the tests returns errors if the\n// client doesn't set a header, and the server sets headers and trailers on the\n// response.\nconst (\n\theaderValue                 = \"some header value\"\n\ttrailerValue                = \"some trailer value\"\n\tclientHeader                = \"Connect-Client-Header\"\n\thandlerHeader               = \"Connect-Handler-Header\"\n\thandlerTrailer              = \"Connect-Handler-Trailer\"\n\tclientMiddlewareErrorHeader = \"Connect-Trigger-HTTP-Error\"\n)\n\nfunc TestServer(t *testing.T) {\n\tt.Parallel()\n\ttestPing := func(t *testing.T, client pingv1connect.PingServiceClient) { //nolint:thelper\n\t\tt.Run(\"ping\", func(t *testing.T) {\n\t\t\tnum := int64(42)\n\t\t\trequest := connect.NewRequest(&pingv1.PingRequest{Number: num})\n\t\t\trequest.Header().Set(clientHeader, headerValue)\n\t\t\texpect := &pingv1.PingResponse{Number: num}\n\t\t\tresponse, err := client.Ping(context.Background(), request)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, response.Msg, expect)\n\t\t\tassert.Equal(t, response.Header().Values(handlerHeader), []string{headerValue})\n\t\t\tassert.Equal(t, response.Trailer().Values(handlerTrailer), []string{trailerValue})\n\t\t})\n\t\tt.Run(\"zero_ping\", func(t *testing.T) {\n\t\t\trequest := connect.NewRequest(&pingv1.PingRequest{})\n\t\t\trequest.Header().Set(clientHeader, headerValue)\n\t\t\tresponse, err := client.Ping(context.Background(), request)\n\t\t\tassert.Nil(t, err)\n\t\t\tvar expect pingv1.PingResponse\n\t\t\tassert.Equal(t, response.Msg, &expect)\n\t\t\tassert.Equal(t, response.Header().Values(handlerHeader), []string{headerValue})\n\t\t\tassert.Equal(t, response.Trailer().Values(handlerTrailer), []string{trailerValue})\n\t\t})\n\t\tt.Run(\"large_ping\", func(t *testing.T) {\n\t\t\t// Using a large payload splits the request and response over multiple\n\t\t\t// packets, ensuring that we're managing HTTP readers and writers\n\t\t\t// correctly.\n\t\t\tif testing.Short() {\n\t\t\t\tt.Skipf(\"skipping %s test in short mode\", t.Name())\n\t\t\t}\n\t\t\thellos := strings.Repeat(\"hello\", 1024*1024) // ~5mb\n\t\t\trequest := connect.NewRequest(&pingv1.PingRequest{Text: hellos})\n\t\t\trequest.Header().Set(clientHeader, headerValue)\n\t\t\tresponse, err := client.Ping(context.Background(), request)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, response.Msg.GetText(), hellos)\n\t\t\tassert.Equal(t, response.Header().Values(handlerHeader), []string{headerValue})\n\t\t\tassert.Equal(t, response.Trailer().Values(handlerTrailer), []string{trailerValue})\n\t\t})\n\t\tt.Run(\"ping_error\", func(t *testing.T) {\n\t\t\t_, err := client.Ping(\n\t\t\t\tcontext.Background(),\n\t\t\t\tconnect.NewRequest(&pingv1.PingRequest{}),\n\t\t\t)\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeInvalidArgument)\n\t\t})\n\t\tt.Run(\"ping_timeout\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(-time.Second))\n\t\t\tdefer cancel()\n\t\t\trequest := connect.NewRequest(&pingv1.PingRequest{})\n\t\t\trequest.Header().Set(clientHeader, headerValue)\n\t\t\t_, err := client.Ping(ctx, request)\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeDeadlineExceeded)\n\t\t})\n\t}\n\ttestSum := func(t *testing.T, client pingv1connect.PingServiceClient) { //nolint:thelper\n\t\tt.Run(\"sum\", func(t *testing.T) {\n\t\t\tconst (\n\t\t\t\tupTo   = 10\n\t\t\t\texpect = 55 // 1+10 + 2+9 + ... + 5+6 = 55\n\t\t\t)\n\t\t\tstream := client.Sum(context.Background())\n\t\t\tstream.RequestHeader().Set(clientHeader, headerValue)\n\t\t\tfor i := int64(1); i <= upTo; i++ {\n\t\t\t\terr := stream.Send(&pingv1.SumRequest{Number: i})\n\t\t\t\tassert.Nil(t, err, assert.Sprintf(\"send %d\", i))\n\t\t\t}\n\t\t\tresponse, err := stream.CloseAndReceive()\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, response.Msg.GetSum(), expect)\n\t\t\tassert.Equal(t, response.Header().Values(handlerHeader), []string{headerValue})\n\t\t\tassert.Equal(t, response.Trailer().Values(handlerTrailer), []string{trailerValue})\n\t\t})\n\t\tt.Run(\"sum_error\", func(t *testing.T) {\n\t\t\tstream := client.Sum(context.Background())\n\t\t\tif err := stream.Send(&pingv1.SumRequest{Number: 1}); err != nil {\n\t\t\t\tassert.ErrorIs(t, err, io.EOF)\n\t\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeUnknown)\n\t\t\t}\n\t\t\t_, err := stream.CloseAndReceive()\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeInvalidArgument)\n\t\t})\n\t\tt.Run(\"sum_close_and_receive_without_send\", func(t *testing.T) {\n\t\t\tstream := client.Sum(context.Background())\n\t\t\tstream.RequestHeader().Set(clientHeader, headerValue)\n\t\t\tgot, err := stream.CloseAndReceive()\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, got.Msg, &pingv1.SumResponse{}) // receive header only stream\n\t\t\tassert.Equal(t, got.Header().Values(handlerHeader), []string{headerValue})\n\t\t})\n\t}\n\ttestCountUp := func(t *testing.T, client pingv1connect.PingServiceClient) { //nolint:thelper\n\t\tt.Run(\"count_up\", func(t *testing.T) {\n\t\t\tconst upTo = 5\n\t\t\tgot := make([]int64, 0, upTo)\n\t\t\texpect := make([]int64, 0, upTo)\n\t\t\tfor i := 1; i <= upTo; i++ {\n\t\t\t\texpect = append(expect, int64(i))\n\t\t\t}\n\t\t\trequest := connect.NewRequest(&pingv1.CountUpRequest{Number: upTo})\n\t\t\trequest.Header().Set(clientHeader, headerValue)\n\t\t\tstream, err := client.CountUp(context.Background(), request)\n\t\t\tassert.Nil(t, err)\n\t\t\tfor stream.Receive() {\n\t\t\t\tgot = append(got, stream.Msg().GetNumber())\n\t\t\t}\n\t\t\tassert.Nil(t, stream.Err())\n\t\t\tassert.Nil(t, stream.Close())\n\t\t\tassert.Equal(t, got, expect)\n\t\t})\n\t\tt.Run(\"count_up_error\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tt.Cleanup(cancel)\n\t\t\tstream, err := client.CountUp(\n\t\t\t\tctx,\n\t\t\t\tconnect.NewRequest(&pingv1.CountUpRequest{Number: 1}),\n\t\t\t)\n\t\t\tassert.Nil(t, err)\n\t\t\tfor stream.Receive() {\n\t\t\t\tt.Fatalf(\"expected error, shouldn't receive any messages\")\n\t\t\t}\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\tconnect.CodeOf(stream.Err()),\n\t\t\t\tconnect.CodeInvalidArgument,\n\t\t\t)\n\t\t\tassert.Nil(t, stream.Close())\n\t\t})\n\t\tt.Run(\"count_up_timeout\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(-time.Second))\n\t\t\tt.Cleanup(cancel)\n\t\t\t_, err := client.CountUp(ctx, connect.NewRequest(&pingv1.CountUpRequest{Number: 1}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeDeadlineExceeded)\n\t\t})\n\t\tt.Run(\"count_up_cancel_after_first_response\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\trequest := connect.NewRequest(&pingv1.CountUpRequest{Number: 5})\n\t\t\trequest.Header().Set(clientHeader, headerValue)\n\t\t\tstream, err := client.CountUp(ctx, request)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.True(t, stream.Receive())\n\t\t\tcancel()\n\t\t\tassert.False(t, stream.Receive())\n\t\t\tassert.NotNil(t, stream.Err())\n\t\t\tassert.Equal(t, connect.CodeOf(stream.Err()), connect.CodeCanceled)\n\t\t\tassert.Nil(t, stream.Close())\n\t\t})\n\t}\n\ttestCumSum := func(t *testing.T, client pingv1connect.PingServiceClient, expectSuccess bool) { //nolint:thelper\n\t\tt.Run(\"cumsum\", func(t *testing.T) {\n\t\t\tsend := []int64{3, 5, 1}\n\t\t\texpect := []int64{3, 8, 9}\n\t\t\tvar got []int64\n\t\t\tstream := client.CumSum(context.Background())\n\t\t\tstream.RequestHeader().Set(clientHeader, headerValue)\n\t\t\tif !expectSuccess { // server doesn't support HTTP/2\n\t\t\t\tfailNoHTTP2(t, stream)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(2)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tfor i, n := range send {\n\t\t\t\t\terr := stream.Send(&pingv1.CumSumRequest{Number: n})\n\t\t\t\t\tassert.Nil(t, err, assert.Sprintf(\"send error #%d\", i))\n\t\t\t\t}\n\t\t\t\tassert.Nil(t, stream.CloseRequest())\n\t\t\t}()\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tfor {\n\t\t\t\t\tmsg, err := stream.Receive()\n\t\t\t\t\tif errors.Is(err, io.EOF) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tassert.Nil(t, err)\n\t\t\t\t\tgot = append(got, msg.GetSum())\n\t\t\t\t}\n\t\t\t\tassert.Nil(t, stream.CloseResponse())\n\t\t\t}()\n\t\t\twg.Wait()\n\t\t\tassert.Equal(t, got, expect)\n\t\t\tassert.Equal(t, stream.ResponseHeader().Values(handlerHeader), []string{headerValue})\n\t\t\tassert.Equal(t, stream.ResponseTrailer().Values(handlerTrailer), []string{trailerValue})\n\t\t})\n\t\tt.Run(\"cumsum_error\", func(t *testing.T) {\n\t\t\tstream := client.CumSum(context.Background())\n\t\t\tif !expectSuccess { // server doesn't support HTTP/2\n\t\t\t\tfailNoHTTP2(t, stream)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := stream.Send(&pingv1.CumSumRequest{Number: 42}); err != nil {\n\t\t\t\tassert.ErrorIs(t, err, io.EOF)\n\t\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeUnknown)\n\t\t\t}\n\t\t\t// We didn't send the headers the server expects, so we should now get an\n\t\t\t// error.\n\t\t\t_, err := stream.Receive()\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeInvalidArgument)\n\t\t\tassert.True(t, connect.IsWireError(err))\n\t\t})\n\t\tt.Run(\"cumsum_empty_stream\", func(t *testing.T) {\n\t\t\tstream := client.CumSum(context.Background())\n\t\t\tstream.RequestHeader().Set(clientHeader, headerValue)\n\t\t\tif !expectSuccess { // server doesn't support HTTP/2\n\t\t\t\tfailNoHTTP2(t, stream)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Deliberately closing with calling Send to test the behavior of Receive.\n\t\t\t// This test case is based on the grpc interop tests.\n\t\t\tassert.Nil(t, stream.CloseRequest())\n\t\t\tresponse, err := stream.Receive()\n\t\t\tassert.Nil(t, response)\n\t\t\tassert.True(t, errors.Is(err, io.EOF))\n\t\t\tassert.False(t, connect.IsWireError(err))\n\t\t\tassert.Nil(t, stream.CloseResponse()) // clean-up the stream\n\t\t})\n\t\tt.Run(\"cumsum_cancel_after_first_response\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tstream := client.CumSum(ctx)\n\t\t\tstream.RequestHeader().Set(clientHeader, headerValue)\n\t\t\tif !expectSuccess { // server doesn't support HTTP/2\n\t\t\t\tfailNoHTTP2(t, stream)\n\t\t\t\tcancel()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar got []int64\n\t\t\texpect := []int64{42}\n\t\t\tif err := stream.Send(&pingv1.CumSumRequest{Number: 42}); err != nil {\n\t\t\t\tassert.ErrorIs(t, err, io.EOF)\n\t\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeUnknown)\n\t\t\t}\n\t\t\tmsg, err := stream.Receive()\n\t\t\tassert.Nil(t, err)\n\t\t\tgot = append(got, msg.GetSum())\n\t\t\tcancel()\n\t\t\t_, err = stream.Receive()\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeCanceled)\n\t\t\tassert.Equal(t, got, expect)\n\t\t\tassert.False(t, connect.IsWireError(err))\n\t\t\tassert.Nil(t, stream.CloseResponse())\n\t\t})\n\t\tt.Run(\"cumsum_cancel_before_send\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tstream := client.CumSum(ctx)\n\t\t\tif !expectSuccess { // server doesn't support HTTP/2\n\t\t\t\tfailNoHTTP2(t, stream)\n\t\t\t\tcancel()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tstream.RequestHeader().Set(clientHeader, headerValue)\n\t\t\tassert.Nil(t, stream.Send(&pingv1.CumSumRequest{Number: 8}))\n\t\t\tcancel()\n\t\t\t// On a subsequent send, ensure that we are still catching context\n\t\t\t// cancellations.\n\t\t\terr := stream.Send(&pingv1.CumSumRequest{Number: 19})\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeCanceled, assert.Sprintf(\"%v\", err))\n\t\t\tassert.False(t, connect.IsWireError(err))\n\t\t\tassert.Nil(t, stream.CloseRequest())\n\t\t\tassert.Nil(t, stream.CloseResponse())\n\t\t})\n\t}\n\ttestErrors := func(t *testing.T, client pingv1connect.PingServiceClient) { //nolint:thelper\n\t\tassertIsHTTPMiddlewareError := func(tb testing.TB, err error) {\n\t\t\ttb.Helper()\n\t\t\tassert.NotNil(tb, err)\n\t\t\tvar connectErr *connect.Error\n\t\t\tassert.True(tb, errors.As(err, &connectErr))\n\t\t\texpect := newHTTPMiddlewareError()\n\t\t\tassert.Equal(tb, connectErr.Code(), expect.Code())\n\t\t\tassert.Equal(tb, connectErr.Message(), expect.Message())\n\t\t\tfor k, v := range expect.Meta() {\n\t\t\t\tassert.Equal(tb, connectErr.Meta().Values(k), v)\n\t\t\t}\n\t\t\tassert.Equal(tb, len(connectErr.Details()), len(expect.Details()))\n\t\t}\n\t\tt.Run(\"errors\", func(t *testing.T) {\n\t\t\trequest := connect.NewRequest(&pingv1.FailRequest{\n\t\t\t\tCode: int32(connect.CodeResourceExhausted),\n\t\t\t})\n\t\t\trequest.Header().Set(clientHeader, headerValue)\n\n\t\t\tresponse, err := client.Fail(context.Background(), request)\n\t\t\tassert.Nil(t, response)\n\t\t\tassert.NotNil(t, err)\n\t\t\tvar connectErr *connect.Error\n\t\t\tok := errors.As(err, &connectErr)\n\t\t\tassert.True(t, ok, assert.Sprintf(\"conversion to *connect.Error\"))\n\t\t\tassert.True(t, connect.IsWireError(err))\n\t\t\tassert.Equal(t, connectErr.Code(), connect.CodeResourceExhausted)\n\t\t\tassert.Equal(t, connectErr.Error(), \"resource_exhausted: \"+errorMessage)\n\t\t\tassert.Zero(t, connectErr.Details())\n\t\t\tassert.Equal(t, connectErr.Meta().Values(handlerHeader), []string{headerValue})\n\t\t\tassert.Equal(t, connectErr.Meta().Values(handlerTrailer), []string{trailerValue})\n\t\t})\n\t\tt.Run(\"middleware_errors_unary\", func(t *testing.T) {\n\t\t\trequest := connect.NewRequest(&pingv1.PingRequest{})\n\t\t\trequest.Header().Set(clientMiddlewareErrorHeader, headerValue)\n\t\t\t_, err := client.Ping(context.Background(), request)\n\t\t\tassertIsHTTPMiddlewareError(t, err)\n\t\t})\n\t\tt.Run(\"middleware_errors_streaming\", func(t *testing.T) {\n\t\t\trequest := connect.NewRequest(&pingv1.CountUpRequest{Number: 10})\n\t\t\trequest.Header().Set(clientMiddlewareErrorHeader, headerValue)\n\t\t\tstream, err := client.CountUp(context.Background(), request)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.False(t, stream.Receive())\n\t\t\tassertIsHTTPMiddlewareError(t, stream.Err())\n\t\t})\n\t}\n\ttestMatrix := func(t *testing.T, client *http.Client, url string, bidi bool) { //nolint:thelper\n\t\trun := func(t *testing.T, opts ...connect.ClientOption) {\n\t\t\tt.Helper()\n\t\t\tclient := pingv1connect.NewPingServiceClient(client, url, opts...)\n\t\t\ttestPing(t, client)\n\t\t\ttestSum(t, client)\n\t\t\ttestCountUp(t, client)\n\t\t\ttestCumSum(t, client, bidi)\n\t\t\ttestErrors(t, client)\n\t\t}\n\t\tt.Run(\"connect\", func(t *testing.T) {\n\t\t\tt.Run(\"proto\", func(t *testing.T) {\n\t\t\t\trun(t)\n\t\t\t})\n\t\t\tt.Run(\"proto_gzip\", func(t *testing.T) {\n\t\t\t\trun(t, connect.WithSendGzip())\n\t\t\t})\n\t\t\tt.Run(\"json_gzip\", func(t *testing.T) {\n\t\t\t\trun(\n\t\t\t\t\tt,\n\t\t\t\t\tconnect.WithProtoJSON(),\n\t\t\t\t\tconnect.WithSendGzip(),\n\t\t\t\t)\n\t\t\t})\n\t\t\tt.Run(\"json_get\", func(t *testing.T) {\n\t\t\t\trun(\n\t\t\t\t\tt,\n\t\t\t\t\tconnect.WithProtoJSON(),\n\t\t\t\t\tconnect.WithHTTPGet(),\n\t\t\t\t\tconnect.WithHTTPGetMaxURLSize(1024, true),\n\t\t\t\t)\n\t\t\t})\n\t\t})\n\t\tt.Run(\"grpc\", func(t *testing.T) {\n\t\t\tt.Run(\"proto\", func(t *testing.T) {\n\t\t\t\trun(t, connect.WithGRPC())\n\t\t\t})\n\t\t\tt.Run(\"proto_gzip\", func(t *testing.T) {\n\t\t\t\trun(t, connect.WithGRPC(), connect.WithSendGzip())\n\t\t\t})\n\t\t\tt.Run(\"json_gzip\", func(t *testing.T) {\n\t\t\t\trun(\n\t\t\t\t\tt,\n\t\t\t\t\tconnect.WithGRPC(),\n\t\t\t\t\tconnect.WithProtoJSON(),\n\t\t\t\t\tconnect.WithSendGzip(),\n\t\t\t\t)\n\t\t\t})\n\t\t})\n\t\tt.Run(\"grpcweb\", func(t *testing.T) {\n\t\t\tt.Run(\"proto\", func(t *testing.T) {\n\t\t\t\trun(t, connect.WithGRPCWeb())\n\t\t\t})\n\t\t\tt.Run(\"proto_gzip\", func(t *testing.T) {\n\t\t\t\trun(t, connect.WithGRPCWeb(), connect.WithSendGzip())\n\t\t\t})\n\t\t\tt.Run(\"json_gzip\", func(t *testing.T) {\n\t\t\t\trun(\n\t\t\t\t\tt,\n\t\t\t\t\tconnect.WithGRPCWeb(),\n\t\t\t\t\tconnect.WithProtoJSON(),\n\t\t\t\t\tconnect.WithSendGzip(),\n\t\t\t\t)\n\t\t\t})\n\t\t})\n\t}\n\n\tmux := http.NewServeMux()\n\tpingRoute, pingHandler := pingv1connect.NewPingServiceHandler(\n\t\tpingServer{checkMetadata: true},\n\t)\n\terrorWriter := connect.NewErrorWriter()\n\t// Add net/http middleware to the ping service to evaluate HTTP state.\n\tmux.Handle(pingRoute, http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {\n\t\t// Exercise ErrorWriter for HTTP middleware errors.\n\t\tif request.Header.Get(clientMiddlewareErrorHeader) != \"\" {\n\t\t\tdefer request.Body.Close()\n\t\t\tif _, err := io.Copy(io.Discard, request.Body); err != nil {\n\t\t\t\tt.Errorf(\"drain request body: %v\", err)\n\t\t\t}\n\t\t\tif !errorWriter.IsSupported(request) {\n\t\t\t\tt.Errorf(\"ErrorWriter doesn't support Content-Type %q\", request.Header.Get(\"Content-Type\"))\n\t\t\t}\n\t\t\tif err := errorWriter.Write(response, request, newHTTPMiddlewareError()); err != nil {\n\t\t\t\tt.Errorf(\"send RPC error from HTTP middleware: %v\", err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\t// Check Content-Length is set correctly.\n\t\tswitch request.URL.Path {\n\t\tcase pingv1connect.PingServicePingProcedure,\n\t\t\tpingv1connect.PingServiceFailProcedure,\n\t\t\tpingv1connect.PingServiceCountUpProcedure:\n\t\t\t// Unary requests set Content-Length to the length of the request body.\n\t\t\tif request.ContentLength < 0 {\n\t\t\t\tt.Errorf(\"%s: expected Content-Length >= 0, got %d\", request.URL.Path, request.ContentLength)\n\t\t\t}\n\t\tcase pingv1connect.PingServiceSumProcedure,\n\t\t\tpingv1connect.PingServiceCumSumProcedure:\n\t\t\t// Streaming requests set Content-Length to -1 or 0 on empty requests.\n\t\t\tif request.ContentLength > 0 {\n\t\t\t\tt.Errorf(\"%s: expected Content-Length -1 or 0, got %d\", request.URL.Path, request.ContentLength)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Errorf(\"unexpected path %q\", request.URL.Path)\n\t\t}\n\t\tpingHandler.ServeHTTP(response, request)\n\t}))\n\n\tt.Run(\"http1\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := &http.Client{Transport: server.TransportHTTP1()}\n\t\ttestMatrix(t, client, server.URL(), false /* bidi */)\n\t})\n\tt.Run(\"http2\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := server.Client()\n\t\ttestMatrix(t, client, server.URL(), true /* bidi */)\n\t})\n}\n\nfunc TestConcurrentStreams(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skipf(\"skipping %s test in short mode\", t.Name())\n\t}\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\tvar done, start sync.WaitGroup\n\tstart.Add(1)\n\tfor i := 0; i < runtime.GOMAXPROCS(0)*8; i++ {\n\t\tdone.Add(1)\n\t\tgo func() {\n\t\t\tdefer done.Done()\n\t\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\t\tvar total int64\n\t\t\tsum := client.CumSum(context.Background())\n\t\t\tstart.Wait()\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tnum := rand.Int63n(1000) //nolint: gosec\n\t\t\t\ttotal += num\n\t\t\t\tif err := sum.Send(&pingv1.CumSumRequest{Number: num}); err != nil {\n\t\t\t\t\tt.Errorf(\"failed to send request: %v\", err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tresp, err := sum.Receive()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"failed to receive from stream: %v\", err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif got := resp.GetSum(); total != got {\n\t\t\t\t\tt.Errorf(\"expected %d == %d\", total, got)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := sum.CloseRequest(); err != nil {\n\t\t\t\tt.Errorf(\"failed to close request: %v\", err)\n\t\t\t}\n\t\t\tif err := sum.CloseResponse(); err != nil {\n\t\t\t\tt.Errorf(\"failed to close response: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\tstart.Done()\n\tdone.Wait()\n}\n\nfunc TestErrorHeaderPropagation(t *testing.T) {\n\tt.Parallel()\n\tnewError := func(testname string, isWire bool) *connect.Error {\n\t\terr := connect.NewError(connect.CodeInvalidArgument, errors.New(testname))\n\t\tif isWire {\n\t\t\terr = connect.NewWireError(connect.CodeInvalidArgument, errors.New(testname))\n\t\t}\n\t\tmsgDetail := &wrapperspb.StringValue{Value: \"server details\"}\n\t\terrDetail, derr := connect.NewErrorDetail(msgDetail)\n\t\tif assert.Nil(t, derr) {\n\t\t\terr.AddDetail(errDetail)\n\t\t}\n\t\terr.Meta().Set(\"Content-Length\", \"1337\")\n\t\terr.Meta().Set(\"Content-Type\", \"application/xml\")\n\t\terr.Meta().Set(\"Accept-Encoding\", \"bogus\")\n\t\terr.Meta().Set(\"Date\", \"Thu, 01 Jan 1970 00:00:00 GMT\")\n\t\terr.Meta().Set(\"Grpc-Status\", \"0\")\n\t\t// Set custom headers.\n\t\terr.Meta().Set(\"X-Test\", testname)\n\t\terr.Meta()[\"x-test-case\"] = []string{testname}\n\t\treturn err\n\t}\n\tpingServer := &pluggablePingServer{\n\t\tping: func(ctx context.Context, request *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\t\t\treturn nil, newError(request.Header().Get(\"X-Test\"), request.Header().Get(\"X-Test-Is-Wire\") == \"true\")\n\t\t},\n\t\tcumSum: func(ctx context.Context, stream *connect.BidiStream[pingv1.CumSumRequest, pingv1.CumSumResponse]) error {\n\t\t\treturn newError(stream.RequestHeader().Get(\"X-Test\"), stream.RequestHeader().Get(\"X-Test-Is-Wire\") == \"true\")\n\t\t},\n\t}\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer))\n\tserver := memhttptest.NewServer(t, mux)\n\n\tassertError := func(t *testing.T, err error, allowCustomHeaders bool) {\n\t\tt.Helper()\n\t\tvar connectErr *connect.Error\n\t\tif !assert.True(t, errors.As(err, &connectErr)) {\n\t\t\treturn\n\t\t}\n\t\tassert.Equal(t, connectErr.Code(), connect.CodeInvalidArgument)\n\t\tassert.Equal(t, connectErr.Message(), t.Name())\n\t\tdetails := connectErr.Details()\n\t\tif assert.Equal(t, len(details), 1) {\n\t\t\tdetailMsg, err := details[0].Value()\n\t\t\tif !assert.Nil(t, err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tserverDetails, ok := detailMsg.(*wrapperspb.StringValue)\n\t\t\tif !assert.True(t, ok) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Equal(t, serverDetails.Value, \"server details\")\n\t\t}\n\t\tmeta := connectErr.Meta()\n\t\tassert.NotEqual(t, meta.Values(\"Content-Length\"), []string{\"1337\"})\n\t\tassert.NotEqual(t, meta.Values(\"Accept-Encoding\"), []string{\"bogus\"})\n\t\tassert.NotEqual(t, meta.Values(\"Content-Type\"), []string{\"application/xml\"})\n\t\tassert.NotEqual(t, meta.Values(\"Content-Length\"), []string{\"1337\"})\n\t\tassert.NotEqual(t, meta.Values(\"Date\"), []string{\"Thu, 01 Jan 1970 00:00:00 GMT\"})\n\t\tif allowCustomHeaders {\n\t\t\tassert.Equal(t, meta.Values(\"x-test-case\"), []string{t.Name()})\n\t\t\tassert.Equal(t, meta.Values(\"X-Test\"), []string{t.Name()})\n\t\t} else {\n\t\t\tassert.Equal(t, meta.Values(\"x-test-case\"), []string(nil))\n\t\t\tassert.Equal(t, meta.Values(\"X-Test\"), []string(nil))\n\t\t}\n\t}\n\ttestServices := func(t *testing.T, client pingv1connect.PingServiceClient) {\n\t\tt.Helper()\n\t\tt.Run(\"unary\", func(t *testing.T) {\n\t\t\trequest := connect.NewRequest(&pingv1.PingRequest{})\n\t\t\trequest.Header().Set(\"X-Test\", t.Name())\n\t\t\t_, err := client.Ping(context.Background(), request)\n\t\t\tif !assert.NotNil(t, err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassertError(t, err, true /* allowCustomHeaders */)\n\t\t\tt.Run(\"wire\", func(t *testing.T) {\n\t\t\t\trequest := connect.NewRequest(&pingv1.PingRequest{})\n\t\t\t\trequest.Header().Set(\"X-Test\", t.Name())\n\t\t\t\trequest.Header().Set(\"X-Test-Is-Wire\", \"true\")\n\t\t\t\t_, err := client.Ping(context.Background(), request)\n\t\t\t\tif !assert.NotNil(t, err) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tassertError(t, err, false /* allowCustomHeaders */)\n\t\t\t})\n\t\t})\n\t\tt.Run(\"bidi\", func(t *testing.T) {\n\t\t\tstream := client.CumSum(context.Background())\n\t\t\tstream.RequestHeader().Set(\"X-Test\", t.Name())\n\t\t\tif err := stream.Send(nil); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\t_, err := stream.Receive()\n\t\t\tif !assert.NotNil(t, err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassertError(t, err, true /* allowCustomHeaders */)\n\t\t\tt.Run(\"wire\", func(t *testing.T) {\n\t\t\t\tstream := client.CumSum(context.Background())\n\t\t\t\tstream.RequestHeader().Set(\"X-Test\", t.Name())\n\t\t\t\tstream.RequestHeader().Set(\"X-Test-Is-Wire\", \"true\")\n\t\t\t\tif err := stream.Send(nil); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\t_, err := stream.Receive()\n\t\t\t\tif !assert.NotNil(t, err) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\tt.Run(\"connect\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\ttestServices(t, client)\n\t})\n\tt.Run(\"grpc\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPC())\n\t\ttestServices(t, client)\n\t})\n\tt.Run(\"grpc-web\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPCWeb())\n\t\ttestServices(t, client)\n\t})\n}\n\nfunc TestHeaderBasic(t *testing.T) {\n\tt.Parallel()\n\tconst (\n\t\tkey  = \"Test-Key\"\n\t\tcval = \"client value\"\n\t\thval = \"client value\"\n\t)\n\n\tpingServer := &pluggablePingServer{\n\t\tping: func(ctx context.Context, request *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\t\t\tassert.Equal(t, request.Header().Get(key), cval)\n\t\t\tresponse := connect.NewResponse(&pingv1.PingResponse{})\n\t\t\tresponse.Header().Set(key, hval)\n\t\t\treturn response, nil\n\t\t},\n\t}\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer))\n\tserver := memhttptest.NewServer(t, mux)\n\n\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\trequest := connect.NewRequest(&pingv1.PingRequest{})\n\trequest.Header().Set(key, cval)\n\tresponse, err := client.Ping(context.Background(), request)\n\tassert.Nil(t, err)\n\tassert.Equal(t, response.Header().Get(key), hval)\n}\n\nfunc TestHeaderHost(t *testing.T) {\n\tt.Parallel()\n\tconst (\n\t\tkey  = \"Host\"\n\t\tcval = \"buf.build\"\n\t)\n\n\tpingServer := &pluggablePingServer{\n\t\tping: func(_ context.Context, request *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\t\t\tassert.Equal(t, request.Header().Get(key), cval)\n\t\t\tresponse := connect.NewResponse(&pingv1.PingResponse{})\n\t\t\treturn response, nil\n\t\t},\n\t}\n\n\tnewHTTP2Server := func(t *testing.T) *memhttp.Server {\n\t\tt.Helper()\n\t\tmux := http.NewServeMux()\n\t\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer))\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\treturn server\n\t}\n\n\tcallWithHost := func(t *testing.T, client pingv1connect.PingServiceClient) {\n\t\tt.Helper()\n\n\t\trequest := connect.NewRequest(&pingv1.PingRequest{})\n\t\trequest.Header().Set(key, cval)\n\t\tresponse, err := client.Ping(context.Background(), request)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, response.Header().Get(key), \"\")\n\t}\n\n\tt.Run(\"connect\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\tcallWithHost(t, client)\n\t})\n\n\tt.Run(\"grpc\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPC())\n\t\tcallWithHost(t, client)\n\t})\n\n\tt.Run(\"grpc-web\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPCWeb())\n\t\tcallWithHost(t, client)\n\t})\n}\n\nfunc TestTimeoutParsing(t *testing.T) {\n\tt.Parallel()\n\tconst timeout = 10 * time.Minute\n\tpingServer := &pluggablePingServer{\n\t\tping: func(ctx context.Context, request *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\t\t\tdeadline, ok := ctx.Deadline()\n\t\t\tassert.True(t, ok)\n\t\t\tremaining := time.Until(deadline)\n\t\t\tassert.True(t, remaining > 0)\n\t\t\tassert.True(t, remaining <= timeout)\n\t\t\treturn connect.NewResponse(&pingv1.PingResponse{}), nil\n\t\t},\n\t}\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer))\n\tserver := memhttptest.NewServer(t, mux)\n\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t_, err := client.Ping(ctx, connect.NewRequest(&pingv1.PingRequest{}))\n\tassert.Nil(t, err)\n}\n\nfunc TestFailCodec(t *testing.T) {\n\tt.Parallel()\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\tserver := memhttptest.NewServer(t, handler)\n\tclient := pingv1connect.NewPingServiceClient(\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t\tconnect.WithCodec(failCodec{}),\n\t)\n\tstream := client.CumSum(context.Background())\n\terr := stream.Send(&pingv1.CumSumRequest{})\n\tvar connectErr *connect.Error\n\tassert.NotNil(t, err)\n\tassert.True(t, errors.As(err, &connectErr))\n\tassert.Equal(t, connectErr.Code(), connect.CodeInternal)\n}\n\nfunc TestContextError(t *testing.T) {\n\tt.Parallel()\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\tserver := memhttptest.NewServer(t, handler)\n\tclient := pingv1connect.NewPingServiceClient(\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\tstream := client.CumSum(ctx)\n\terr := stream.Send(nil)\n\tvar connectErr *connect.Error\n\tassert.NotNil(t, err)\n\tassert.True(t, errors.As(err, &connectErr))\n\tassert.Equal(t, connectErr.Code(), connect.CodeCanceled)\n\tassert.False(t, connect.IsWireError(err))\n}\n\nfunc TestGRPCMarshalStatusError(t *testing.T) {\n\tt.Parallel()\n\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(\n\t\tpingServer{\n\t\t\t// Include error details in the response, so that the Status protobuf will be marshaled.\n\t\t\tincludeErrorDetails: true,\n\t\t},\n\t\t// We're using a codec that will fail to marshal the Status protobuf, which means the returned error will be ignored\n\t\tconnect.WithCodec(failCodec{}),\n\t))\n\tserver := memhttptest.NewServer(t, mux)\n\n\tassertInternalError := func(tb testing.TB, opts ...connect.ClientOption) {\n\t\ttb.Helper()\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), opts...)\n\t\trequest := connect.NewRequest(&pingv1.FailRequest{Code: int32(connect.CodeResourceExhausted)})\n\t\t_, err := client.Fail(context.Background(), request)\n\t\ttb.Log(err)\n\t\tassert.NotNil(t, err, assert.Sprintf(\"expected an error\"))\n\t\tvar connectErr *connect.Error\n\t\tok := errors.As(err, &connectErr)\n\t\tassert.True(t, ok, assert.Sprintf(\"expected the error to be a connect.Error\"))\n\t\t// This should be Internal, not ResourceExhausted, because we're testing when the Status object itself fails to marshal\n\t\tassert.Equal(t, connectErr.Code(), connect.CodeInternal, assert.Sprintf(\"expected the error code to be Internal, was %s\", connectErr.Code()))\n\t\tassert.True(\n\t\t\tt,\n\t\t\tstrings.HasSuffix(connectErr.Message(), \": boom\"),\n\t\t)\n\t}\n\n\t// Only applies to gRPC protocols, where we're marshaling the Status protobuf\n\t// message to binary.\n\tassertInternalError(t, connect.WithGRPC())\n\tassertInternalError(t, connect.WithGRPCWeb())\n}\n\nfunc TestGRPCMissingTrailersError(t *testing.T) {\n\tt.Parallel()\n\n\ttrimTrailers := func(handler http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tr.Header.Del(\"Te\")\n\t\t\thandler.ServeHTTP(&trimTrailerWriter{w: w}, r)\n\t\t})\n\t}\n\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(\n\t\tpingServer{checkMetadata: true},\n\t))\n\tserver := memhttptest.NewServer(t, trimTrailers(mux))\n\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPC())\n\n\tassertErrorNoTrailers := func(t *testing.T, err error) {\n\t\tt.Helper()\n\t\tassert.NotNil(t, err)\n\t\tvar connectErr *connect.Error\n\t\tok := errors.As(err, &connectErr)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, connectErr.Code(), connect.CodeUnknown)\n\t\tassert.True(\n\t\t\tt,\n\t\t\tstrings.HasSuffix(connectErr.Message(), \"protocol error: no Grpc-Status trailer: unexpected EOF\"),\n\t\t)\n\t}\n\n\tassertNilOrEOF := func(t *testing.T, err error) {\n\t\tt.Helper()\n\t\tif err != nil {\n\t\t\tassert.ErrorIs(t, err, io.EOF)\n\t\t}\n\t}\n\n\tt.Run(\"ping\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trequest := connect.NewRequest(&pingv1.PingRequest{Number: 1, Text: \"foobar\"})\n\t\t_, err := client.Ping(context.Background(), request)\n\t\tassertErrorNoTrailers(t, err)\n\t})\n\tt.Run(\"sum\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tstream := client.Sum(context.Background())\n\t\terr := stream.Send(&pingv1.SumRequest{Number: 1})\n\t\tassertNilOrEOF(t, err)\n\t\t_, err = stream.CloseAndReceive()\n\t\tassertErrorNoTrailers(t, err)\n\t})\n\tt.Run(\"count_up\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tstream, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{Number: 10}))\n\t\tassert.Nil(t, err)\n\t\tassert.False(t, stream.Receive())\n\t\tassertErrorNoTrailers(t, stream.Err())\n\t})\n\tt.Run(\"cumsum\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tstream := client.CumSum(context.Background())\n\t\tassertNilOrEOF(t, stream.Send(&pingv1.CumSumRequest{Number: 10}))\n\t\t_, err := stream.Receive()\n\t\tassertErrorNoTrailers(t, err)\n\t\tassert.Nil(t, stream.CloseResponse())\n\t})\n\tt.Run(\"cumsum_empty_stream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tstream := client.CumSum(context.Background())\n\t\tassert.Nil(t, stream.CloseRequest())\n\t\tresponse, err := stream.Receive()\n\t\tassert.Nil(t, response)\n\t\tassertErrorNoTrailers(t, err)\n\t\tassert.Nil(t, stream.CloseResponse())\n\t})\n}\n\nfunc TestUnavailableIfHostInvalid(t *testing.T) {\n\tt.Parallel()\n\tclient := pingv1connect.NewPingServiceClient(\n\t\thttp.DefaultClient,\n\t\t\"https://api.invalid/\",\n\t)\n\t_, err := client.Ping(\n\t\tcontext.Background(),\n\t\tconnect.NewRequest(&pingv1.PingRequest{}),\n\t)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, connect.CodeOf(err), connect.CodeUnavailable)\n}\n\nfunc TestBidiRequiresHTTP2(t *testing.T) {\n\tt.Parallel()\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/connect+proto\")\n\t\t_, err := io.WriteString(w, \"hello world\")\n\t\tassert.Nil(t, err)\n\t})\n\tserver := memhttptest.NewServer(t, handler)\n\tclient := pingv1connect.NewPingServiceClient(\n\t\t&http.Client{Transport: server.TransportHTTP1()},\n\t\tserver.URL(),\n\t)\n\tstream := client.CumSum(context.Background())\n\t// Stream creates an async request, can error on Send or Receive.\n\tif err := stream.Send(&pingv1.CumSumRequest{}); err != nil {\n\t\tassert.ErrorIs(t, err, io.EOF)\n\t}\n\tassert.Nil(t, stream.CloseRequest())\n\t_, err := stream.Receive()\n\tassert.NotNil(t, err)\n\tvar connectErr *connect.Error\n\tassert.True(t, errors.As(err, &connectErr))\n\tassert.Equal(t, connectErr.Code(), connect.CodeUnimplemented)\n\tassert.True(\n\t\tt,\n\t\tstrings.HasSuffix(connectErr.Message(), \": bidi streams require at least HTTP/2\"),\n\t)\n}\n\nfunc TestCompressMinBytesClient(t *testing.T) {\n\tt.Parallel()\n\tassertContentType := func(tb testing.TB, text, expect string) {\n\t\ttb.Helper()\n\t\tmux := http.NewServeMux()\n\t\tmux.Handle(\"/\", http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {\n\t\t\twriter.Header().Set(\"Content-Type\", \"application/proto\")\n\t\t\tassert.Equal(tb, request.Header.Get(\"Content-Encoding\"), expect)\n\t\t}))\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\t_, err := pingv1connect.NewPingServiceClient(\n\t\t\tserver.Client(),\n\t\t\tserver.URL(),\n\t\t\tconnect.WithSendGzip(),\n\t\t\tconnect.WithCompressMinBytes(8),\n\t\t).Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{Text: text}))\n\t\tassert.Nil(tb, err)\n\t}\n\tt.Run(\"request_uncompressed\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tassertContentType(t, \"ping\", \"\")\n\t})\n\tt.Run(\"request_compressed\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tassertContentType(t, \"pingping\", \"gzip\")\n\t})\n\n\tt.Run(\"request_uncompressed\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tassertContentType(t, \"ping\", \"\")\n\t})\n\tt.Run(\"request_compressed\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tassertContentType(t, strings.Repeat(\"ping\", 2), \"gzip\")\n\t})\n}\n\nfunc TestCompressMinBytes(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(\n\t\tpingServer{},\n\t\tconnect.WithCompressMinBytes(8),\n\t))\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := server.Client()\n\n\tgetPingResponse := func(t *testing.T, pingText string) *http.Response {\n\t\tt.Helper()\n\t\trequest := &pingv1.PingRequest{Text: pingText}\n\t\trequestBytes, err := proto.Marshal(request)\n\t\tassert.Nil(t, err)\n\t\treq, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodPost,\n\t\t\tserver.URL()+pingv1connect.PingServicePingProcedure,\n\t\t\tbytes.NewReader(requestBytes),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\treq.Header.Set(\"Content-Type\", \"application/proto\")\n\t\tresponse, err := client.Do(req)\n\t\tassert.Nil(t, err)\n\t\tt.Cleanup(func() {\n\t\t\tassert.Nil(t, response.Body.Close())\n\t\t})\n\t\treturn response\n\t}\n\n\tt.Run(\"response_uncompressed\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tassert.False(t, getPingResponse(t, \"ping\").Uncompressed) //nolint:bodyclose\n\t})\n\n\tt.Run(\"response_compressed\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tassert.True(t, getPingResponse(t, strings.Repeat(\"ping\", 2)).Uncompressed) //nolint:bodyclose\n\t})\n}\n\nfunc TestCustomCompression(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tcompressionName := \"deflate\"\n\tdecompressor := func() connect.Decompressor {\n\t\t// Need to instantiate with a reader - before decompressing Reset(io.Reader) is called\n\t\treturn newDeflateReader(strings.NewReader(\"\"))\n\t}\n\tcompressor := func() connect.Compressor {\n\t\tw, err := flate.NewWriter(&strings.Builder{}, flate.DefaultCompression)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create flate writer: %v\", err)\n\t\t}\n\t\treturn w\n\t}\n\tmux.Handle(pingv1connect.NewPingServiceHandler(\n\t\tpingServer{},\n\t\tconnect.WithCompression(compressionName, decompressor, compressor),\n\t))\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := pingv1connect.NewPingServiceClient(server.Client(),\n\t\tserver.URL(),\n\t\tconnect.WithAcceptCompression(compressionName, decompressor, compressor),\n\t\tconnect.WithSendCompression(compressionName),\n\t)\n\trequest := &pingv1.PingRequest{Text: \"testing 1..2..3..\"}\n\tresponse, err := client.Ping(context.Background(), connect.NewRequest(request))\n\tassert.Nil(t, err)\n\tassert.Equal(t, response.Msg, &pingv1.PingResponse{Text: request.GetText()})\n}\n\nfunc TestClientWithoutGzipSupport(t *testing.T) {\n\t// See https://connectrpc.com/connect/pull/349 for why we want to\n\t// support this. TL;DR is that Microsoft's dapr sidecar can't handle\n\t// asymmetric compression.\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := pingv1connect.NewPingServiceClient(server.Client(),\n\t\tserver.URL(),\n\t\tconnect.WithAcceptCompression(\"gzip\", nil, nil),\n\t\tconnect.WithSendGzip(),\n\t)\n\trequest := &pingv1.PingRequest{Text: \"gzip me!\"}\n\t_, err := client.Ping(context.Background(), connect.NewRequest(request))\n\tassert.NotNil(t, err)\n\tassert.Equal(t, connect.CodeOf(err), connect.CodeUnknown)\n\tassert.True(t, strings.Contains(err.Error(), \"unknown compression\"))\n}\n\nfunc TestInvalidHeaderTimeout(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\tgetPingResponseWithTimeout := func(t *testing.T, timeout string) *http.Response {\n\t\tt.Helper()\n\t\trequest, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodPost,\n\t\t\tserver.URL()+pingv1connect.PingServicePingProcedure,\n\t\t\tstrings.NewReader(\"{}\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\t\trequest.Header.Set(\"Connect-Timeout-Ms\", timeout)\n\t\tresponse, err := server.Client().Do(request)\n\t\tassert.Nil(t, err)\n\t\tt.Cleanup(func() {\n\t\t\tassert.Nil(t, response.Body.Close())\n\t\t})\n\t\treturn response\n\t}\n\tt.Run(\"timeout_non_numeric\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tassert.Equal(t, getPingResponseWithTimeout(t, \"10s\").StatusCode, http.StatusBadRequest) //nolint:bodyclose\n\t})\n\tt.Run(\"timeout_out_of_range\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tassert.Equal(t, getPingResponseWithTimeout(t, \"12345678901\").StatusCode, http.StatusBadRequest) //nolint:bodyclose\n\t})\n}\n\nfunc TestInterceptorReturnsWrongType(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithInterceptors(connect.UnaryInterceptorFunc(func(next connect.UnaryFunc) connect.UnaryFunc {\n\t\treturn func(ctx context.Context, request connect.AnyRequest) (connect.AnyResponse, error) {\n\t\t\tif _, err := next(ctx, request); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn connect.NewResponse(&pingv1.CumSumResponse{\n\t\t\t\tSum: 1,\n\t\t\t}), nil\n\t\t}\n\t})))\n\t_, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{Text: \"hello!\"}))\n\tassert.NotNil(t, err)\n\tvar connectErr *connect.Error\n\tassert.True(t, errors.As(err, &connectErr))\n\tassert.Equal(t, connectErr.Code(), connect.CodeInternal)\n\tassert.True(t, strings.Contains(connectErr.Message(), \"unexpected client response type\"))\n}\n\nfunc TestHandlerWithReadMaxBytes(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\treadMaxBytes := 1024\n\tmux.Handle(pingv1connect.NewPingServiceHandler(\n\t\tpingServer{},\n\t\tconnect.WithConditionalHandlerOptions(func(spec connect.Spec) []connect.HandlerOption {\n\t\t\tvar options []connect.HandlerOption\n\t\t\tif spec.Procedure == pingv1connect.PingServicePingProcedure {\n\t\t\t\toptions = append(options, connect.WithReadMaxBytes(readMaxBytes))\n\t\t\t}\n\t\t\treturn options\n\t\t}),\n\t))\n\treadMaxBytesMatrix := func(t *testing.T, client pingv1connect.PingServiceClient, compressed bool) {\n\t\tt.Helper()\n\t\tt.Run(\"equal_read_max\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// Serializes to exactly readMaxBytes (1024) - no errors expected\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"a\", 1021)}\n\t\t\tassert.Equal(t, proto.Size(pingRequest), readMaxBytes)\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.Nil(t, err)\n\t\t})\n\t\tt.Run(\"read_max_plus_one\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// Serializes to readMaxBytes+1 (1025) - expect invalid argument.\n\t\t\t// This will be over the limit after decompression but under with compression.\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"a\", 1022)}\n\t\t\tif compressed {\n\t\t\t\tcompressedSize := gzipCompressedSize(t, pingRequest)\n\t\t\t\tassert.True(t, compressedSize < readMaxBytes, assert.Sprintf(\"expected compressed size %d < %d\", compressedSize, readMaxBytes))\n\t\t\t}\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t\tassert.True(t, strings.HasSuffix(err.Error(), fmt.Sprintf(\"message size %d is larger than configured max %d\", proto.Size(pingRequest), readMaxBytes)))\n\t\t})\n\t\tt.Run(\"read_max_large\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif testing.Short() {\n\t\t\t\tt.Skipf(\"skipping %s test in short mode\", t.Name())\n\t\t\t}\n\t\t\t// Serializes to much larger than readMaxBytes (5 MiB)\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"abcde\", 1024*1024)}\n\t\t\texpectedSize := proto.Size(pingRequest)\n\t\t\t// With gzip request compression, the error should indicate the envelope size (before decompression) is too large.\n\t\t\tif compressed {\n\t\t\t\texpectedSize = gzipCompressedSize(t, pingRequest)\n\t\t\t\tassert.True(t, expectedSize > readMaxBytes, assert.Sprintf(\"expected compressed size %d > %d\", expectedSize, readMaxBytes))\n\t\t\t}\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t\tassert.Equal(t, err.Error(), fmt.Sprintf(\"resource_exhausted: message size %d is larger than configured max %d\", expectedSize, readMaxBytes))\n\t\t})\n\t}\n\tnewHTTP2Server := func(t *testing.T) *memhttp.Server {\n\t\tt.Helper()\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\treturn server\n\t}\n\tt.Run(\"connect\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\treadMaxBytesMatrix(t, client, false)\n\t})\n\tt.Run(\"connect_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithSendGzip())\n\t\treadMaxBytesMatrix(t, client, true)\n\t})\n\tt.Run(\"grpc\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPC())\n\t\treadMaxBytesMatrix(t, client, false)\n\t})\n\tt.Run(\"grpc_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPC(), connect.WithSendGzip())\n\t\treadMaxBytesMatrix(t, client, true)\n\t})\n\tt.Run(\"grpcweb\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPCWeb())\n\t\treadMaxBytesMatrix(t, client, false)\n\t})\n\tt.Run(\"grpcweb_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPCWeb(), connect.WithSendGzip())\n\t\treadMaxBytesMatrix(t, client, true)\n\t})\n}\n\nfunc TestHandlerWithHTTPMaxBytes(t *testing.T) {\n\t// This is similar to Connect's own ReadMaxBytes option, but applied to the\n\t// whole stream using the stdlib's http.MaxBytesHandler.\n\tt.Parallel()\n\tconst readMaxBytes = 128\n\tmux := http.NewServeMux()\n\tpingRoute, pingHandler := pingv1connect.NewPingServiceHandler(pingServer{})\n\tmux.Handle(pingRoute, http.MaxBytesHandler(pingHandler, readMaxBytes))\n\trun := func(t *testing.T, client pingv1connect.PingServiceClient, compressed bool) {\n\t\tt.Helper()\n\t\tt.Run(\"below_read_max\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{}))\n\t\t\tassert.Nil(t, err)\n\t\t})\n\t\tt.Run(\"just_above_max\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"a\", readMaxBytes*10)}\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tif compressed {\n\t\t\t\tcompressedSize := gzipCompressedSize(t, pingRequest)\n\t\t\t\tassert.True(t, compressedSize < readMaxBytes, assert.Sprintf(\"expected compressed size %d < %d\", compressedSize, readMaxBytes))\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t})\n\t\tt.Run(\"read_max_large\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif testing.Short() {\n\t\t\t\tt.Skipf(\"skipping %s test in short mode\", t.Name())\n\t\t\t}\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"abcde\", 1024*1024)}\n\t\t\tif compressed {\n\t\t\t\texpectedSize := gzipCompressedSize(t, pingRequest)\n\t\t\t\tassert.True(t, expectedSize > readMaxBytes, assert.Sprintf(\"expected compressed size %d > %d\", expectedSize, readMaxBytes))\n\t\t\t}\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t})\n\t}\n\tt.Run(\"connect\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\trun(t, client, false)\n\t})\n\tt.Run(\"connect_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithSendGzip())\n\t\trun(t, client, true)\n\t})\n\tt.Run(\"grpc\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPC())\n\t\trun(t, client, false)\n\t})\n\tt.Run(\"grpc_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPC(), connect.WithSendGzip())\n\t\trun(t, client, true)\n\t})\n\tt.Run(\"grpcweb\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPCWeb())\n\t\trun(t, client, false)\n\t})\n\tt.Run(\"grpcweb_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPCWeb(), connect.WithSendGzip())\n\t\trun(t, client, true)\n\t})\n}\n\nfunc TestClientWithReadMaxBytes(t *testing.T) {\n\tt.Parallel()\n\tcreateServer := func(tb testing.TB, enableCompression bool) *memhttp.Server {\n\t\ttb.Helper()\n\t\tmux := http.NewServeMux()\n\t\tvar compressionOption connect.HandlerOption\n\t\tif enableCompression {\n\t\t\tcompressionOption = connect.WithCompressMinBytes(1)\n\t\t} else {\n\t\t\tcompressionOption = connect.WithCompressMinBytes(math.MaxInt)\n\t\t}\n\t\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}, compressionOption))\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\treturn server\n\t}\n\tserverUncompressed := createServer(t, false)\n\tserverCompressed := createServer(t, true)\n\treadMaxBytes := 1024\n\treadMaxBytesMatrix := func(t *testing.T, client pingv1connect.PingServiceClient, compressed bool) {\n\t\tt.Helper()\n\t\tt.Run(\"equal_read_max\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// Serializes to exactly readMaxBytes (1024) - no errors expected\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"a\", 1021)}\n\t\t\tassert.Equal(t, proto.Size(pingRequest), readMaxBytes)\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.Nil(t, err)\n\t\t})\n\t\tt.Run(\"read_max_plus_one\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// Serializes to readMaxBytes+1 (1025) - expect resource exhausted.\n\t\t\t// This will be over the limit after decompression but under with compression.\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"a\", 1022)}\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t\tassert.True(t, strings.HasSuffix(err.Error(), fmt.Sprintf(\"message size %d is larger than configured max %d\", proto.Size(pingRequest), readMaxBytes)))\n\t\t})\n\t\tt.Run(\"read_max_large\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif testing.Short() {\n\t\t\t\tt.Skipf(\"skipping %s test in short mode\", t.Name())\n\t\t\t}\n\t\t\t// Serializes to much larger than readMaxBytes (5 MiB)\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"abcde\", 1024*1024)}\n\t\t\texpectedSize := proto.Size(pingRequest)\n\t\t\t// With gzip response compression, the error should indicate the envelope size (before decompression) is too large.\n\t\t\tif compressed {\n\t\t\t\texpectedSize = gzipCompressedSize(t, pingRequest)\n\t\t\t\tassert.True(t, expectedSize > readMaxBytes, assert.Sprintf(\"expected compressed size %d > %d\", expectedSize, readMaxBytes))\n\t\t\t}\n\t\t\tassert.True(t, expectedSize > readMaxBytes, assert.Sprintf(\"expected compressed size %d > %d\", expectedSize, readMaxBytes))\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t\tassert.Equal(t, err.Error(), fmt.Sprintf(\"resource_exhausted: message size %d is larger than configured max %d\", expectedSize, readMaxBytes))\n\t\t})\n\t}\n\tt.Run(\"connect\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := pingv1connect.NewPingServiceClient(serverUncompressed.Client(), serverUncompressed.URL(), connect.WithReadMaxBytes(readMaxBytes))\n\t\treadMaxBytesMatrix(t, client, false)\n\t})\n\tt.Run(\"connect_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := pingv1connect.NewPingServiceClient(serverCompressed.Client(), serverCompressed.URL(), connect.WithReadMaxBytes(readMaxBytes))\n\t\treadMaxBytesMatrix(t, client, true)\n\t})\n\tt.Run(\"grpc\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := pingv1connect.NewPingServiceClient(serverUncompressed.Client(), serverUncompressed.URL(), connect.WithReadMaxBytes(readMaxBytes), connect.WithGRPC())\n\t\treadMaxBytesMatrix(t, client, false)\n\t})\n\tt.Run(\"grpc_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := pingv1connect.NewPingServiceClient(serverCompressed.Client(), serverCompressed.URL(), connect.WithReadMaxBytes(readMaxBytes), connect.WithGRPC())\n\t\treadMaxBytesMatrix(t, client, true)\n\t})\n\tt.Run(\"grpcweb\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := pingv1connect.NewPingServiceClient(serverUncompressed.Client(), serverUncompressed.URL(), connect.WithReadMaxBytes(readMaxBytes), connect.WithGRPCWeb())\n\t\treadMaxBytesMatrix(t, client, false)\n\t})\n\tt.Run(\"grpcweb_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := pingv1connect.NewPingServiceClient(serverCompressed.Client(), serverCompressed.URL(), connect.WithReadMaxBytes(readMaxBytes), connect.WithGRPCWeb())\n\t\treadMaxBytesMatrix(t, client, true)\n\t})\n}\n\nfunc TestHandlerWithSendMaxBytes(t *testing.T) {\n\tt.Parallel()\n\tsendMaxBytes := 1024\n\tsendMaxBytesMatrix := func(t *testing.T, client pingv1connect.PingServiceClient, compressed bool) {\n\t\tt.Helper()\n\t\tt.Run(\"equal_send_max\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// Serializes to exactly sendMaxBytes (1024) - no errors expected\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"a\", 1021)}\n\t\t\tassert.Equal(t, proto.Size(pingRequest), sendMaxBytes)\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.Nil(t, err)\n\t\t})\n\t\tt.Run(\"send_max_plus_one\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// Serializes to sendMaxBytes+1 (1025) - expect invalid argument.\n\t\t\t// This will be over the limit after decompression but under with compression.\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"a\", 1022)}\n\t\t\tif compressed {\n\t\t\t\tcompressedSize := gzipCompressedSize(t, pingRequest)\n\t\t\t\tassert.True(t, compressedSize < sendMaxBytes, assert.Sprintf(\"expected compressed size %d < %d\", compressedSize, sendMaxBytes))\n\t\t\t}\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tif compressed {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t\t\tassert.True(t, strings.HasSuffix(err.Error(), fmt.Sprintf(\"message size %d exceeds sendMaxBytes %d\", proto.Size(pingRequest), sendMaxBytes)))\n\t\t\t}\n\t\t})\n\t\tt.Run(\"send_max_large\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif testing.Short() {\n\t\t\t\tt.Skipf(\"skipping %s test in short mode\", t.Name())\n\t\t\t}\n\t\t\t// Serializes to much larger than sendMaxBytes (5 MiB)\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"abcde\", 1024*1024)}\n\t\t\texpectedSize := proto.Size(pingRequest)\n\t\t\t// With gzip request compression, the error should indicate the envelope size (before decompression) is too large.\n\t\t\tif compressed {\n\t\t\t\texpectedSize = gzipCompressedSize(t, pingRequest)\n\t\t\t\tassert.True(t, expectedSize > sendMaxBytes, assert.Sprintf(\"expected compressed size %d > %d\", expectedSize, sendMaxBytes))\n\t\t\t}\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t\tif compressed {\n\t\t\t\tassert.Equal(t, err.Error(), fmt.Sprintf(\"resource_exhausted: compressed message size %d exceeds sendMaxBytes %d\", expectedSize, sendMaxBytes))\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, err.Error(), fmt.Sprintf(\"resource_exhausted: message size %d exceeds sendMaxBytes %d\", expectedSize, sendMaxBytes))\n\t\t\t}\n\t\t})\n\t}\n\tnewHTTP2Server := func(t *testing.T, compressed bool, sendMaxBytes int) *memhttp.Server {\n\t\tt.Helper()\n\t\tmux := http.NewServeMux()\n\t\toptions := []connect.HandlerOption{connect.WithSendMaxBytes(sendMaxBytes)}\n\t\tif compressed {\n\t\t\toptions = append(options, connect.WithCompressMinBytes(1))\n\t\t} else {\n\t\t\toptions = append(options, connect.WithCompressMinBytes(math.MaxInt))\n\t\t}\n\t\tmux.Handle(pingv1connect.NewPingServiceHandler(\n\t\t\tpingServer{},\n\t\t\toptions...,\n\t\t))\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\treturn server\n\t}\n\tt.Run(\"connect\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t, false, sendMaxBytes)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\tsendMaxBytesMatrix(t, client, false)\n\t})\n\tt.Run(\"connect_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t, true, sendMaxBytes)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\tsendMaxBytesMatrix(t, client, true)\n\t})\n\tt.Run(\"grpc\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t, false, sendMaxBytes)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPC())\n\t\tsendMaxBytesMatrix(t, client, false)\n\t})\n\tt.Run(\"grpc_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t, true, sendMaxBytes)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPC())\n\t\tsendMaxBytesMatrix(t, client, true)\n\t})\n\tt.Run(\"grpcweb\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t, false, sendMaxBytes)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPCWeb())\n\t\tsendMaxBytesMatrix(t, client, false)\n\t})\n\tt.Run(\"grpcweb_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tserver := newHTTP2Server(t, true, sendMaxBytes)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPCWeb())\n\t\tsendMaxBytesMatrix(t, client, true)\n\t})\n}\n\nfunc TestClientWithSendMaxBytes(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\tsendMaxBytesMatrix := func(t *testing.T, client pingv1connect.PingServiceClient, sendMaxBytes int, compressed bool) {\n\t\tt.Helper()\n\t\tt.Run(\"equal_send_max\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// Serializes to exactly sendMaxBytes (1024) - no errors expected\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"a\", 1021)}\n\t\t\tassert.Equal(t, proto.Size(pingRequest), sendMaxBytes)\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.Nil(t, err)\n\t\t})\n\t\tt.Run(\"send_max_plus_one\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// Serializes to sendMaxBytes+1 (1025) - expect resource exhausted.\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"a\", 1022)}\n\t\t\tassert.Equal(t, proto.Size(pingRequest), sendMaxBytes+1)\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tif compressed {\n\t\t\t\tassert.True(t, gzipCompressedSize(t, pingRequest) < sendMaxBytes)\n\t\t\t\tassert.Nil(t, err, assert.Sprintf(\"expected nil error for compressed message < sendMaxBytes\"))\n\t\t\t} else {\n\t\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t\t\tassert.True(t, strings.HasSuffix(err.Error(), fmt.Sprintf(\"message size %d exceeds sendMaxBytes %d\", proto.Size(pingRequest), sendMaxBytes)))\n\t\t\t}\n\t\t})\n\t\tt.Run(\"send_max_large\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif testing.Short() {\n\t\t\t\tt.Skipf(\"skipping %s test in short mode\", t.Name())\n\t\t\t}\n\t\t\t// Serializes to much larger than sendMaxBytes (5 MiB)\n\t\t\tpingRequest := &pingv1.PingRequest{Text: strings.Repeat(\"abcde\", 1024*1024)}\n\t\t\texpectedSize := proto.Size(pingRequest)\n\t\t\t// With gzip response compression, the error should indicate the envelope size (before decompression) is too large.\n\t\t\tif compressed {\n\t\t\t\texpectedSize = gzipCompressedSize(t, pingRequest)\n\t\t\t}\n\t\t\tassert.True(t, expectedSize > sendMaxBytes)\n\t\t\t_, err := client.Ping(context.Background(), connect.NewRequest(pingRequest))\n\t\t\tassert.NotNil(t, err, assert.Sprintf(\"expected non-nil error for large message\"))\n\t\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeResourceExhausted)\n\t\t\tif compressed {\n\t\t\t\tassert.Equal(t, err.Error(), fmt.Sprintf(\"resource_exhausted: compressed message size %d exceeds sendMaxBytes %d\", expectedSize, sendMaxBytes))\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, err.Error(), fmt.Sprintf(\"resource_exhausted: message size %d exceeds sendMaxBytes %d\", expectedSize, sendMaxBytes))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"connect\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsendMaxBytes := 1024\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithSendMaxBytes(sendMaxBytes))\n\t\tsendMaxBytesMatrix(t, client, sendMaxBytes, false)\n\t})\n\tt.Run(\"connect_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsendMaxBytes := 1024\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithSendMaxBytes(sendMaxBytes), connect.WithSendGzip())\n\t\tsendMaxBytesMatrix(t, client, sendMaxBytes, true)\n\t})\n\tt.Run(\"grpc\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsendMaxBytes := 1024\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithSendMaxBytes(sendMaxBytes), connect.WithGRPC())\n\t\tsendMaxBytesMatrix(t, client, sendMaxBytes, false)\n\t})\n\tt.Run(\"grpc_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsendMaxBytes := 1024\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithSendMaxBytes(sendMaxBytes), connect.WithGRPC(), connect.WithSendGzip())\n\t\tsendMaxBytesMatrix(t, client, sendMaxBytes, true)\n\t})\n\tt.Run(\"grpcweb\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsendMaxBytes := 1024\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithSendMaxBytes(sendMaxBytes), connect.WithGRPCWeb())\n\t\tsendMaxBytesMatrix(t, client, sendMaxBytes, false)\n\t})\n\tt.Run(\"grpcweb_gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tsendMaxBytes := 1024\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithSendMaxBytes(sendMaxBytes), connect.WithGRPCWeb(), connect.WithSendGzip())\n\t\tsendMaxBytesMatrix(t, client, sendMaxBytes, true)\n\t})\n}\n\nfunc TestBidiStreamServerSendsFirstMessage(t *testing.T) {\n\tt.Parallel()\n\trun := func(t *testing.T, opts ...connect.ClientOption) {\n\t\tt.Helper()\n\t\theadersSent := make(chan struct{})\n\t\tpingServer := &pluggablePingServer{\n\t\t\tcumSum: func(ctx context.Context, stream *connect.BidiStream[pingv1.CumSumRequest, pingv1.CumSumResponse]) error {\n\t\t\t\tclose(headersSent)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\t\tmux := http.NewServeMux()\n\t\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer))\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(\n\t\t\tserver.Client(),\n\t\t\tserver.URL(),\n\t\t\tconnect.WithClientOptions(opts...),\n\t\t\tconnect.WithInterceptors(&assertPeerInterceptor{t}),\n\t\t)\n\t\tstream := client.CumSum(context.Background())\n\t\tt.Cleanup(func() {\n\t\t\tassert.Nil(t, stream.CloseRequest())\n\t\t\tassert.Nil(t, stream.CloseResponse())\n\t\t})\n\t\tassert.Nil(t, stream.Send(nil))\n\t\tselect {\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Error(\"timed out to get request headers\")\n\t\tcase <-headersSent:\n\t\t}\n\t}\n\tt.Run(\"connect\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trun(t)\n\t})\n\tt.Run(\"grpc\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trun(t, connect.WithGRPC())\n\t})\n\tt.Run(\"grpcweb\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trun(t, connect.WithGRPCWeb())\n\t})\n}\n\nfunc TestStreamForServer(t *testing.T) {\n\tt.Parallel()\n\tnewPingClient := func(t *testing.T, pingServer pingv1connect.PingServiceHandler) pingv1connect.PingServiceClient {\n\t\tt.Helper()\n\t\tmux := http.NewServeMux()\n\t\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer))\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(\n\t\t\tserver.Client(),\n\t\t\tserver.URL(),\n\t\t)\n\t\treturn client\n\t}\n\tt.Run(\"not-proto-message\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := newPingClient(t, &pluggablePingServer{\n\t\t\tcumSum: func(ctx context.Context, stream *connect.BidiStream[pingv1.CumSumRequest, pingv1.CumSumResponse]) error {\n\t\t\t\treturn stream.Conn().Send(\"foobar\")\n\t\t\t},\n\t\t})\n\t\tstream := client.CumSum(context.Background())\n\t\tassert.Nil(t, stream.Send(nil))\n\t\t_, err := stream.Receive()\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeInternal)\n\t\tassert.Nil(t, stream.CloseRequest())\n\t})\n\tt.Run(\"nil-message\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := newPingClient(t, &pluggablePingServer{\n\t\t\tcumSum: func(ctx context.Context, stream *connect.BidiStream[pingv1.CumSumRequest, pingv1.CumSumResponse]) error {\n\t\t\t\treturn stream.Send(nil)\n\t\t\t},\n\t\t})\n\t\tstream := client.CumSum(context.Background())\n\t\tassert.Nil(t, stream.Send(nil))\n\t\t_, err := stream.Receive()\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeUnknown)\n\t\tassert.Nil(t, stream.CloseRequest())\n\t})\n\tt.Run(\"get-spec\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := newPingClient(t, &pluggablePingServer{\n\t\t\tcumSum: func(ctx context.Context, stream *connect.BidiStream[pingv1.CumSumRequest, pingv1.CumSumResponse]) error {\n\t\t\t\tassert.Equal(t, stream.Spec().StreamType, connect.StreamTypeBidi)\n\t\t\t\tassert.Equal(t, stream.Spec().Procedure, pingv1connect.PingServiceCumSumProcedure)\n\t\t\t\tassert.False(t, stream.Spec().IsClient)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\t\tstream := client.CumSum(context.Background())\n\t\tassert.Nil(t, stream.Send(nil))\n\t\tassert.Nil(t, stream.CloseRequest())\n\t})\n\tt.Run(\"server-stream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := newPingClient(t, &pluggablePingServer{\n\t\t\tcountUp: func(ctx context.Context, req *connect.Request[pingv1.CountUpRequest], stream *connect.ServerStream[pingv1.CountUpResponse]) error {\n\t\t\t\tassert.Equal(t, stream.Conn().Spec().StreamType, connect.StreamTypeServer)\n\t\t\t\tassert.Equal(t, stream.Conn().Spec().Procedure, pingv1connect.PingServiceCountUpProcedure)\n\t\t\t\tassert.False(t, stream.Conn().Spec().IsClient)\n\t\t\t\tassert.Nil(t, stream.Send(&pingv1.CountUpResponse{Number: 1}))\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\t\tstream, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{}))\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, stream)\n\t\tassert.Nil(t, stream.Close())\n\t})\n\tt.Run(\"server-stream-send\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := newPingClient(t, &pluggablePingServer{\n\t\t\tcountUp: func(ctx context.Context, req *connect.Request[pingv1.CountUpRequest], stream *connect.ServerStream[pingv1.CountUpResponse]) error {\n\t\t\t\tassert.Nil(t, stream.Send(&pingv1.CountUpResponse{Number: 1}))\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\t\tstream, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{}))\n\t\tassert.Nil(t, err)\n\t\tassert.True(t, stream.Receive())\n\t\tmsg := stream.Msg()\n\t\tassert.NotNil(t, msg)\n\t\tassert.Equal(t, msg.GetNumber(), 1)\n\t\tassert.Nil(t, stream.Close())\n\t})\n\tt.Run(\"server-stream-send-nil\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := newPingClient(t, &pluggablePingServer{\n\t\t\tcountUp: func(ctx context.Context, req *connect.Request[pingv1.CountUpRequest], stream *connect.ServerStream[pingv1.CountUpResponse]) error {\n\t\t\t\tstream.ResponseHeader().Set(\"foo\", \"bar\")\n\t\t\t\tstream.ResponseTrailer().Set(\"bas\", \"blah\")\n\t\t\t\tassert.Nil(t, stream.Send(nil))\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\t\tstream, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{}))\n\t\tassert.Nil(t, err)\n\t\tassert.False(t, stream.Receive())\n\t\theaders := stream.ResponseHeader()\n\t\tassert.NotNil(t, headers)\n\t\tassert.Equal(t, headers.Get(\"foo\"), \"bar\")\n\t\ttrailers := stream.ResponseTrailer()\n\t\tassert.NotNil(t, trailers)\n\t\tassert.Equal(t, trailers.Get(\"bas\"), \"blah\")\n\t\tassert.Nil(t, stream.Close())\n\t})\n\tt.Run(\"client-stream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := newPingClient(t, &pluggablePingServer{\n\t\t\tsum: func(ctx context.Context, stream *connect.ClientStream[pingv1.SumRequest]) (*connect.Response[pingv1.SumResponse], error) {\n\t\t\t\tassert.Equal(t, stream.Spec().StreamType, connect.StreamTypeClient)\n\t\t\t\tassert.Equal(t, stream.Spec().Procedure, pingv1connect.PingServiceSumProcedure)\n\t\t\t\tassert.False(t, stream.Spec().IsClient)\n\t\t\t\tassert.True(t, stream.Receive())\n\t\t\t\tmsg := stream.Msg()\n\t\t\t\tassert.NotNil(t, msg)\n\t\t\t\tassert.Equal(t, msg.GetNumber(), 1)\n\t\t\t\treturn connect.NewResponse(&pingv1.SumResponse{Sum: 1}), nil\n\t\t\t},\n\t\t})\n\t\tstream := client.Sum(context.Background())\n\t\tassert.Nil(t, stream.Send(&pingv1.SumRequest{Number: 1}))\n\t\tres, err := stream.CloseAndReceive()\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, res)\n\t\tassert.Equal(t, res.Msg.GetSum(), 1)\n\t})\n\tt.Run(\"client-stream-conn\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := newPingClient(t, &pluggablePingServer{\n\t\t\tsum: func(ctx context.Context, stream *connect.ClientStream[pingv1.SumRequest]) (*connect.Response[pingv1.SumResponse], error) {\n\t\t\t\tassert.True(t, stream.Receive())\n\t\t\t\tassert.NotNil(t, stream.Conn().Send(\"not-proto\"))\n\t\t\t\treturn connect.NewResponse(&pingv1.SumResponse{}), nil\n\t\t\t},\n\t\t})\n\t\tstream := client.Sum(context.Background())\n\t\tassert.Nil(t, stream.Send(&pingv1.SumRequest{Number: 1}))\n\t\tres, err := stream.CloseAndReceive()\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, res)\n\t})\n\tt.Run(\"client-stream-send-msg\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tclient := newPingClient(t, &pluggablePingServer{\n\t\t\tsum: func(ctx context.Context, stream *connect.ClientStream[pingv1.SumRequest]) (*connect.Response[pingv1.SumResponse], error) {\n\t\t\t\tassert.True(t, stream.Receive())\n\t\t\t\t// We end up sending two response messages, but only one is expected.\n\t\t\t\tassert.Nil(t, stream.Conn().Send(&pingv1.SumResponse{Sum: 2}))\n\t\t\t\treturn connect.NewResponse(&pingv1.SumResponse{}), nil\n\t\t\t},\n\t\t})\n\t\tstream := client.Sum(context.Background())\n\t\tassert.Nil(t, stream.Send(&pingv1.SumRequest{Number: 1}))\n\t\tres, err := stream.CloseAndReceive()\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeUnimplemented)\n\t\tassert.Nil(t, res)\n\t})\n}\n\nfunc TestConnectHTTPErrorCodes(t *testing.T) {\n\tt.Parallel()\n\tcheckHTTPStatus := func(t *testing.T, connectCode connect.Code, wantHttpStatus int) {\n\t\tt.Helper()\n\t\tmux := http.NewServeMux()\n\t\tpluggableServer := &pluggablePingServer{\n\t\t\tping: func(_ context.Context, _ *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\t\t\t\treturn nil, connect.NewError(connectCode, errors.New(\"error\"))\n\t\t\t},\n\t\t}\n\t\tmux.Handle(pingv1connect.NewPingServiceHandler(pluggableServer))\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\treq, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodPost,\n\t\t\tserver.URL()+pingv1connect.PingServicePingProcedure,\n\t\t\tstrings.NewReader(\"{}\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\tresp, err := server.Client().Do(req)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, wantHttpStatus, resp.StatusCode)\n\t\tconnectClient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\tconnectResp, err := connectClient.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{}))\n\t\tassert.NotNil(t, err)\n\t\tassert.Nil(t, connectResp)\n\t}\n\tt.Run(\"CodeCanceled-499\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeCanceled, 499)\n\t})\n\tt.Run(\"CodeUnknown-500\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeUnknown, 500)\n\t})\n\tt.Run(\"CodeInvalidArgument-400\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeInvalidArgument, 400)\n\t})\n\tt.Run(\"CodeDeadlineExceeded-504\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeDeadlineExceeded, 504)\n\t})\n\tt.Run(\"CodeNotFound-404\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeNotFound, 404)\n\t})\n\tt.Run(\"CodeAlreadyExists-409\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeAlreadyExists, 409)\n\t})\n\tt.Run(\"CodePermissionDenied-403\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodePermissionDenied, 403)\n\t})\n\tt.Run(\"CodeResourceExhausted-429\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeResourceExhausted, 429)\n\t})\n\tt.Run(\"CodeFailedPrecondition-400\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeFailedPrecondition, 400)\n\t})\n\tt.Run(\"CodeAborted-409\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeAborted, 409)\n\t})\n\tt.Run(\"CodeOutOfRange-400\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeOutOfRange, 400)\n\t})\n\tt.Run(\"CodeUnimplemented-501\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeUnimplemented, 501)\n\t})\n\tt.Run(\"CodeInternal-500\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeInternal, 500)\n\t})\n\tt.Run(\"CodeUnavailable-503\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeUnavailable, 503)\n\t})\n\tt.Run(\"CodeDataLoss-500\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeDataLoss, 500)\n\t})\n\tt.Run(\"CodeUnauthenticated-401\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, connect.CodeUnauthenticated, 401)\n\t})\n\tt.Run(\"100-500\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, 100, 500)\n\t})\n\tt.Run(\"0-500\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcheckHTTPStatus(t, 0, 500)\n\t})\n}\n\nfunc TestFailCompression(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tcompressorName := \"fail\"\n\tcompressor := func() connect.Compressor { return failCompressor{} }\n\tdecompressor := func() connect.Decompressor { return failDecompressor{} }\n\tmux.Handle(\n\t\tpingv1connect.NewPingServiceHandler(\n\t\t\tpingServer{},\n\t\t\tconnect.WithCompression(compressorName, decompressor, compressor),\n\t\t),\n\t)\n\tserver := memhttptest.NewServer(t, mux)\n\tpingclient := pingv1connect.NewPingServiceClient(\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t\tconnect.WithAcceptCompression(compressorName, decompressor, compressor),\n\t\tconnect.WithSendCompression(compressorName),\n\t)\n\t_, err := pingclient.Ping(\n\t\tcontext.Background(),\n\t\tconnect.NewRequest(&pingv1.PingRequest{\n\t\t\tText: \"ping\",\n\t\t}),\n\t)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, connect.CodeOf(err), connect.CodeInternal)\n}\n\nfunc TestUnflushableResponseWriter(t *testing.T) {\n\tt.Parallel()\n\tassertIsFlusherErr := func(t *testing.T, err error) {\n\t\tt.Helper()\n\t\tif !assert.NotNil(t, err) {\n\t\t\treturn\n\t\t}\n\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeInternal, assert.Sprintf(\"got %v\", err))\n\t\tassert.True(\n\t\t\tt,\n\t\t\tstrings.HasSuffix(err.Error(), \"unflushableWriter does not implement http.Flusher\"),\n\t\t\tassert.Sprintf(\"error doesn't reference http.Flusher: %s\", err.Error()),\n\t\t)\n\t}\n\tmux := http.NewServeMux()\n\tpath, handler := pingv1connect.NewPingServiceHandler(pingServer{})\n\twrapped := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thandler.ServeHTTP(&unflushableWriter{w}, r)\n\t})\n\tmux.Handle(path, wrapped)\n\tserver := memhttptest.NewServer(t, mux)\n\n\ttests := []struct {\n\t\tname    string\n\t\toptions []connect.ClientOption\n\t}{\n\t\t{\"connect\", nil},\n\t\t{\"grpc\", []connect.ClientOption{connect.WithGRPC()}},\n\t\t{\"grpcweb\", []connect.ClientOption{connect.WithGRPCWeb()}},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tpingclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), tt.options...)\n\t\t\tstream, err := pingclient.CountUp(\n\t\t\t\tcontext.Background(),\n\t\t\t\tconnect.NewRequest(&pingv1.CountUpRequest{Number: 5}),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tassertIsFlusherErr(t, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif assert.False(t, stream.Receive()) {\n\t\t\t\tassertIsFlusherErr(t, stream.Err())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGRPCErrorMetadataIsTrailersOnly(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\n\tprotoBytes, err := proto.Marshal(&pingv1.FailRequest{Code: int32(connect.CodeInternal)})\n\tassert.Nil(t, err)\n\t// Manually construct a gRPC prefix. Data is uncompressed, so the first byte\n\t// is 0. Set the last 4 bytes to the message length.\n\tvar prefix [5]byte\n\tbinary.BigEndian.PutUint32(prefix[1:5], uint32(len(protoBytes)))\n\tbody := append(prefix[:], protoBytes...)\n\t// Manually send off a gRPC request.\n\treq, err := http.NewRequestWithContext(\n\t\tcontext.Background(),\n\t\thttp.MethodPost,\n\t\tserver.URL()+pingv1connect.PingServiceFailProcedure,\n\t\tbytes.NewReader(body),\n\t)\n\tassert.Nil(t, err)\n\treq.Header.Set(\"Content-Type\", \"application/grpc\")\n\tres, err := server.Client().Do(req)\n\tassert.Nil(t, err)\n\tassert.Equal(t, res.StatusCode, http.StatusOK)\n\tassert.Equal(t, res.Header.Get(\"Content-Type\"), \"application/grpc\")\n\t// pingServer.Fail adds handlerHeader and handlerTrailer to the error\n\t// metadata. The gRPC protocol should send all error metadata as trailers.\n\tassert.Zero(t, res.Header.Get(handlerHeader))\n\tassert.Zero(t, res.Header.Get(handlerTrailer))\n\t_, err = io.Copy(io.Discard, res.Body)\n\tassert.Nil(t, err)\n\tassert.Nil(t, res.Body.Close())\n\tassert.NotZero(t, res.Trailer.Get(handlerHeader))\n\tassert.NotZero(t, res.Trailer.Get(handlerTrailer))\n}\n\nfunc TestConnectProtocolHeaderSentByDefault(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}, connect.WithRequireConnectProtocolHeader()))\n\tserver := memhttptest.NewServer(t, mux)\n\n\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t_, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{}))\n\tassert.Nil(t, err)\n\n\tstream := client.CumSum(context.Background())\n\tassert.Nil(t, stream.Send(&pingv1.CumSumRequest{}))\n\t_, err = stream.Receive()\n\tassert.Nil(t, err)\n\tassert.Nil(t, stream.CloseRequest())\n\tassert.Nil(t, stream.CloseResponse())\n}\n\nfunc TestConnectProtocolHeaderRequired(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(\n\t\tpingServer{},\n\t\tconnect.WithRequireConnectProtocolHeader(),\n\t))\n\tserver := memhttptest.NewServer(t, mux)\n\n\ttests := []struct {\n\t\theaders http.Header\n\t}{\n\t\t{http.Header{}},\n\t\t{http.Header{\"Connect-Protocol-Version\": []string{\"0\"}}},\n\t}\n\tfor _, tcase := range tests {\n\t\treq, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodPost,\n\t\t\tserver.URL()+pingv1connect.PingServicePingProcedure,\n\t\t\tstrings.NewReader(\"{}\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\tfor k, v := range tcase.headers {\n\t\t\treq.Header[k] = v\n\t\t}\n\t\tresponse, err := server.Client().Do(req)\n\t\tassert.Nil(t, err)\n\t\tassert.Nil(t, response.Body.Close())\n\t\tassert.Equal(t, response.StatusCode, http.StatusBadRequest)\n\t}\n}\n\nfunc TestAllowCustomUserAgent(t *testing.T) {\n\tt.Parallel()\n\n\tconst customAgent = \"custom\"\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(&pluggablePingServer{\n\t\tping: func(_ context.Context, req *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\t\t\tagent := req.Header().Get(\"User-Agent\")\n\t\t\tassert.Equal(t, agent, customAgent)\n\t\t\treturn connect.NewResponse(&pingv1.PingResponse{Number: req.Msg.GetNumber()}), nil\n\t\t},\n\t}))\n\tserver := memhttptest.NewServer(t, mux)\n\n\t// If the user has set a User-Agent, we shouldn't clobber it.\n\ttests := []struct {\n\t\tprotocol string\n\t\topts     []connect.ClientOption\n\t}{\n\t\t{\"connect\", nil},\n\t\t{\"grpc\", []connect.ClientOption{connect.WithGRPC()}},\n\t\t{\"grpcweb\", []connect.ClientOption{connect.WithGRPCWeb()}},\n\t}\n\tfor _, testCase := range tests {\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), testCase.opts...)\n\t\treq := connect.NewRequest(&pingv1.PingRequest{Number: 42})\n\t\treq.Header().Set(\"User-Agent\", customAgent)\n\t\t_, err := client.Ping(context.Background(), req)\n\t\tassert.Nil(t, err)\n\t}\n}\n\nfunc TestWebXUserAgent(t *testing.T) {\n\tt.Parallel()\n\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(&pluggablePingServer{\n\t\tping: func(_ context.Context, req *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\t\t\tagent := req.Header().Get(\"User-Agent\")\n\t\t\tassert.NotZero(t, agent)\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\treq.Header().Get(\"X-User-Agent\"),\n\t\t\t\tagent,\n\t\t\t)\n\t\t\treturn connect.NewResponse(&pingv1.PingResponse{Number: req.Msg.GetNumber()}), nil\n\t\t},\n\t}))\n\tserver := memhttptest.NewServer(t, mux)\n\n\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithGRPCWeb())\n\treq := connect.NewRequest(&pingv1.PingRequest{Number: 42})\n\t_, err := client.Ping(context.Background(), req)\n\tassert.Nil(t, err)\n}\n\nfunc TestBidiOverHTTP1(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\n\t// Clients expecting a full-duplex connection that end up with a simplex\n\t// HTTP/1.1 connection shouldn't hang. Instead, the server should close the\n\t// TCP connection.\n\tclient := pingv1connect.NewPingServiceClient(\n\t\t&http.Client{Transport: server.TransportHTTP1()},\n\t\tserver.URL(),\n\t)\n\tstream := client.CumSum(context.Background())\n\t// Stream creates an async request, can error on Send or Receive.\n\tif err := stream.Send(&pingv1.CumSumRequest{Number: 2}); err != nil {\n\t\tassert.ErrorIs(t, err, io.EOF)\n\t}\n\t_, err := stream.Receive()\n\tassert.NotNil(t, err)\n\tassert.Equal(t, connect.CodeOf(err), connect.CodeUnknown)\n\tassert.Equal(t, err.Error(), \"unknown: HTTP status 505 HTTP Version Not Supported\")\n\tassert.Nil(t, stream.CloseRequest())\n\tassert.Nil(t, stream.CloseResponse())\n}\n\nfunc TestHandlerReturnsNilResponse(t *testing.T) {\n\t// When user-written handlers return nil responses _and_ nil errors, ensure\n\t// that the resulting panic includes at least the name of the procedure.\n\tt.Parallel()\n\n\tvar panics int\n\trecoverPanic := func(_ context.Context, spec connect.Spec, _ http.Header, p any) error {\n\t\tpanics++\n\t\tassert.NotNil(t, p)\n\t\tstr := fmt.Sprint(p)\n\t\tassert.True(\n\t\t\tt,\n\t\t\tstrings.Contains(str, spec.Procedure),\n\t\t\tassert.Sprintf(\"%q does not contain procedure %q\", str, spec.Procedure),\n\t\t)\n\t\treturn connect.NewError(connect.CodeInternal, errors.New(str))\n\t}\n\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(&pluggablePingServer{\n\t\tping: func(ctx context.Context, req *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\t\t\treturn nil, nil //nolint: nilnil\n\t\t},\n\t\tsum: func(ctx context.Context, req *connect.ClientStream[pingv1.SumRequest]) (*connect.Response[pingv1.SumResponse], error) {\n\t\t\treturn nil, nil //nolint: nilnil\n\t\t},\n\t}, connect.WithRecover(recoverPanic)))\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\n\t_, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{}))\n\tassert.NotNil(t, err)\n\tassert.Equal(t, connect.CodeOf(err), connect.CodeInternal)\n\n\t_, err = client.Sum(context.Background()).CloseAndReceive()\n\tassert.NotNil(t, err)\n\tassert.Equal(t, connect.CodeOf(err), connect.CodeInternal)\n\n\tassert.Equal(t, panics, 2)\n}\n\nfunc TestStreamUnexpectedEOF(t *testing.T) {\n\tt.Parallel()\n\n\t// Initialized by the test case.\n\ttestcaseMux := make(map[string]http.HandlerFunc)\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(responseWriter http.ResponseWriter, request *http.Request) {\n\t\ttestcase, ok := testcaseMux[request.Header.Get(\"Test-Case\")]\n\t\tif !ok {\n\t\t\tresponseWriter.WriteHeader(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\t_, _ = io.Copy(io.Discard, request.Body)\n\t\ttestcase(responseWriter, request)\n\t})\n\tserver := memhttptest.NewServer(t, mux)\n\n\thead := [5]byte{}\n\tpayload := []byte(`{\"number\": 42}`)\n\tbinary.BigEndian.PutUint32(head[1:], uint32(len(payload)))\n\ttestcases := []struct {\n\t\tname       string\n\t\thandler    http.HandlerFunc\n\t\toptions    []connect.ClientOption\n\t\texpectCode connect.Code\n\t\texpectMsg  string\n\t}{{\n\t\tname:    \"connect_missing_end\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/connect+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload)\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInternal,\n\t\texpectMsg:  \"internal: protocol error: unexpected EOF\",\n\t}, {\n\t\tname:    \"grpc_missing_end\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON(), connect.WithGRPC()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/grpc+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload)\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInternal,\n\t\texpectMsg:  \"internal: protocol error: no Grpc-Status trailer: unexpected EOF\",\n\t}, {\n\t\tname:    \"grpc_missing_status\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON(), connect.WithGRPC()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/grpc+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload)\n\t\t\tassert.Nil(t, err)\n\t\t\t// Trailers exist, just no status. So error will be unknown instead of internal.\n\t\t\tresponseWriter.Header().Set(http.TrailerPrefix+\"grpc-message\", \"foo\")\n\t\t},\n\t\texpectCode: connect.CodeUnknown,\n\t\texpectMsg:  \"unknown: protocol error: no Grpc-Status trailer: unexpected EOF\",\n\t}, {\n\t\tname:    \"grpc-web_missing_end\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON(), connect.WithGRPCWeb()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/grpc-web+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, _ = responseWriter.Write(payload)\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInternal,\n\t\texpectMsg:  \"internal: protocol error: no Grpc-Status trailer: unexpected EOF\",\n\t}, {\n\t\tname:    \"grpc-web_missing_status\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON(), connect.WithGRPCWeb()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/grpc-web+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload)\n\t\t\tassert.Nil(t, err)\n\t\t\t// Trailers exist, just no status. So error will be unknown instead of internal.\n\t\t\t_, err = responseWriter.Write([]byte{128}) // end-stream flag\n\t\t\tassert.Nil(t, err)\n\t\t\tendStream := \"grpc-message: foo\\r\\n\"\n\t\t\tvar length [4]byte\n\t\t\tbinary.BigEndian.PutUint32(length[:], uint32(len(endStream)))\n\t\t\t_, err = responseWriter.Write(length[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write([]byte(endStream))\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeUnknown,\n\t\texpectMsg:  \"unknown: protocol error: no Grpc-Status trailer: unexpected EOF\",\n\t}, {\n\t\tname:    \"connect_partial_payload\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/connect+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload[:len(payload)-1])\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInvalidArgument,\n\t\texpectMsg:  fmt.Sprintf(\"invalid_argument: protocol error: promised %d bytes in enveloped message, got %d bytes\", len(payload), len(payload)-1),\n\t}, {\n\t\tname:    \"grpc_partial_payload\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON(), connect.WithGRPC()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/grpc+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload[:len(payload)-1])\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInvalidArgument,\n\t\texpectMsg:  fmt.Sprintf(\"invalid_argument: protocol error: promised %d bytes in enveloped message, got %d bytes\", len(payload), len(payload)-1),\n\t}, {\n\t\tname:    \"grpc-web_partial_payload\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON(), connect.WithGRPCWeb()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/grpc-web+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload[:len(payload)-1])\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInvalidArgument,\n\t\texpectMsg:  fmt.Sprintf(\"invalid_argument: protocol error: promised %d bytes in enveloped message, got %d bytes\", len(payload), len(payload)-1),\n\t}, {\n\t\tname:    \"connect_partial_frame\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/connect+json\")\n\t\t\t_, err := responseWriter.Write(head[:4])\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInvalidArgument,\n\t\texpectMsg:  \"invalid_argument: protocol error: incomplete envelope: unexpected EOF\",\n\t}, {\n\t\tname:    \"grpc_partial_frame\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON(), connect.WithGRPC()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/grpc+json\")\n\t\t\t_, err := responseWriter.Write(head[:4])\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInvalidArgument,\n\t\texpectMsg:  \"invalid_argument: protocol error: incomplete envelope: unexpected EOF\",\n\t}, {\n\t\tname:    \"grpc-web_partial_frame\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON(), connect.WithGRPCWeb()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\theader := responseWriter.Header()\n\t\t\theader.Set(\"Content-Type\", \"application/grpc-web+json\")\n\t\t\t_, err := responseWriter.Write(head[:4])\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInvalidArgument,\n\t\texpectMsg:  \"invalid_argument: protocol error: incomplete envelope: unexpected EOF\",\n\t}, {\n\t\tname:    \"connect_excess_eof\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\tresponseWriter.Header().Set(\"Content-Type\", \"application/connect+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload)\n\t\t\tassert.Nil(t, err)\n\t\t\t// Write EOF\n\t\t\t_, err = responseWriter.Write([]byte{1 << 1, 0, 0, 0, 2})\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write([]byte(\"{}\"))\n\t\t\tassert.Nil(t, err)\n\t\t\t// Excess payload\n\t\t\t_, err = responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload)\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInternal,\n\t\texpectMsg:  fmt.Sprintf(\"internal: corrupt response: %d extra bytes after end of stream\", len(payload)+len(head)),\n\t}, {\n\t\tname:    \"grpc-web_excess_eof\",\n\t\toptions: []connect.ClientOption{connect.WithProtoJSON(), connect.WithGRPCWeb()},\n\t\thandler: func(responseWriter http.ResponseWriter, _ *http.Request) {\n\t\t\tresponseWriter.Header().Set(\"Content-Type\", \"application/grpc-web+json\")\n\t\t\t_, err := responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload)\n\t\t\tassert.Nil(t, err)\n\t\t\t// Write EOF\n\t\t\tvar buf bytes.Buffer\n\t\t\ttrailer := http.Header{\"grpc-status\": []string{\"0\"}}\n\t\t\tassert.Nil(t, trailer.Write(&buf))\n\t\t\tvar head [5]byte\n\t\t\thead[0] = 1 << 7\n\t\t\tbinary.BigEndian.PutUint32(head[1:], uint32(buf.Len()))\n\t\t\t_, err = responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(buf.Bytes())\n\t\t\tassert.Nil(t, err)\n\t\t\t// Excess payload\n\t\t\t_, err = responseWriter.Write(head[:])\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = responseWriter.Write(payload)\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t\texpectCode: connect.CodeInternal,\n\t\texpectMsg:  fmt.Sprintf(\"internal: corrupt response: %d extra bytes after end of stream\", len(payload)+len(head)),\n\t}}\n\tfor _, testcase := range testcases {\n\t\ttestcaseMux[t.Name()+\"/\"+testcase.name] = testcase.handler\n\t}\n\tfor _, testcase := range testcases {\n\t\ttestcase := testcase\n\t\tt.Run(testcase.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tclient := pingv1connect.NewPingServiceClient(\n\t\t\t\tserver.Client(),\n\t\t\t\tserver.URL(),\n\t\t\t\ttestcase.options...,\n\t\t\t)\n\t\t\tconst upTo = 2\n\t\t\trequest := connect.NewRequest(&pingv1.CountUpRequest{Number: upTo})\n\t\t\trequest.Header().Set(\"Test-Case\", t.Name())\n\t\t\tstream, err := client.CountUp(context.Background(), request)\n\t\t\tassert.Nil(t, err)\n\t\t\tfor i := 0; stream.Receive() && i < upTo; i++ {\n\t\t\t\tassert.Equal(t, stream.Msg().GetNumber(), 42)\n\t\t\t}\n\t\t\tassert.NotNil(t, stream.Err())\n\t\t\tassert.Equal(t, connect.CodeOf(stream.Err()), testcase.expectCode)\n\t\t\tassert.Equal(t, stream.Err().Error(), testcase.expectMsg)\n\t\t})\n\t}\n}\n\n// TestClientDisconnect tests that the handler receives a CodeCanceled error when\n// the client abruptly disconnects.\nfunc TestClientDisconnect(t *testing.T) {\n\tt.Parallel()\n\ttype httpRoundTripFunc func(server *memhttp.Server, clientConn *net.Conn, onError chan struct{}) http.RoundTripper\n\thttp1RoundTripper := func(server *memhttp.Server, clientConn *net.Conn, onError chan struct{}) http.RoundTripper {\n\t\ttransport := server.TransportHTTP1()\n\t\tdialContext := transport.DialContext\n\t\ttransport.DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\tconn, err := dialContext(ctx, network, addr)\n\t\t\tif err != nil {\n\t\t\t\tclose(onError)\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t*clientConn = conn // Capture the client connection.\n\t\t\treturn conn, nil\n\t\t}\n\t\treturn transport\n\t}\n\thttp2RoundTripper := func(server *memhttp.Server, clientConn *net.Conn, onError chan struct{}) http.RoundTripper {\n\t\ttransport := server.Transport()\n\t\tdialContext := transport.DialTLSContext\n\t\ttransport.DialTLSContext = func(ctx context.Context, network, addr string, cfg *tls.Config) (net.Conn, error) {\n\t\t\tconn, err := dialContext(ctx, network, addr, cfg)\n\t\t\tif err != nil {\n\t\t\t\tclose(onError)\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t*clientConn = conn // Capture the client connection.\n\t\t\treturn conn, nil\n\t\t}\n\t\treturn transport\n\t}\n\ttestTransportClosure := func(t *testing.T, captureTransport httpRoundTripFunc) { //nolint:thelper\n\t\tt.Run(\"handler_reads\", func(t *testing.T) {\n\t\t\tvar (\n\t\t\t\thandlerReceiveErr error\n\t\t\t\thandlerContextErr error\n\t\t\t\tgotRequest        = make(chan struct{})\n\t\t\t\tgotResponse       = make(chan struct{})\n\t\t\t)\n\t\t\tpingServer := &pluggablePingServer{\n\t\t\t\tsum: func(ctx context.Context, stream *connect.ClientStream[pingv1.SumRequest]) (*connect.Response[pingv1.SumResponse], error) {\n\t\t\t\t\tclose(gotRequest)\n\t\t\t\t\tfor stream.Receive() {\n\t\t\t\t\t\t// Do nothing\n\t\t\t\t\t}\n\t\t\t\t\thandlerReceiveErr = stream.Err()\n\t\t\t\t\thandlerContextErr = ctx.Err()\n\t\t\t\t\tclose(gotResponse)\n\t\t\t\t\treturn connect.NewResponse(&pingv1.SumResponse{}), nil\n\t\t\t\t},\n\t\t\t}\n\t\t\tmux := http.NewServeMux()\n\t\t\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer))\n\t\t\tserver := memhttptest.NewServer(t, mux)\n\t\t\tvar clientConn net.Conn\n\t\t\ttransport := captureTransport(server, &clientConn, gotRequest)\n\t\t\tserverClient := &http.Client{Transport: transport}\n\t\t\tclient := pingv1connect.NewPingServiceClient(serverClient, server.URL())\n\t\t\tstream := client.Sum(context.Background())\n\t\t\t// Send header.\n\t\t\tassert.Nil(t, stream.Send(nil))\n\t\t\t<-gotRequest\n\t\t\t// Client abruptly disconnects.\n\t\t\tif !assert.NotNil(t, clientConn) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, clientConn.Close())\n\t\t\t_, err := stream.CloseAndReceive()\n\t\t\tassert.NotNil(t, err)\n\t\t\t<-gotResponse\n\t\t\tassert.NotNil(t, handlerReceiveErr)\n\t\t\tassert.Equal(t, connect.CodeOf(handlerReceiveErr), connect.CodeCanceled, assert.Sprintf(\"got %v\", handlerReceiveErr))\n\t\t\tassert.ErrorIs(t, handlerContextErr, context.Canceled)\n\t\t})\n\t\tt.Run(\"handler_writes\", func(t *testing.T) {\n\t\t\tvar (\n\t\t\t\thandlerReceiveErr error\n\t\t\t\thandlerContextErr error\n\t\t\t\tgotRequest        = make(chan struct{})\n\t\t\t\tgotResponse       = make(chan struct{})\n\t\t\t)\n\t\t\tpingServer := &pluggablePingServer{\n\t\t\t\tcountUp: func(ctx context.Context, _ *connect.Request[pingv1.CountUpRequest], stream *connect.ServerStream[pingv1.CountUpResponse]) error {\n\t\t\t\t\tclose(gotRequest)\n\t\t\t\t\tvar err error\n\t\t\t\t\tfor err == nil {\n\t\t\t\t\t\terr = stream.Send(&pingv1.CountUpResponse{})\n\t\t\t\t\t}\n\t\t\t\t\thandlerReceiveErr = err\n\t\t\t\t\thandlerContextErr = ctx.Err()\n\t\t\t\t\tclose(gotResponse)\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}\n\t\t\tmux := http.NewServeMux()\n\t\t\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer))\n\t\t\tserver := memhttptest.NewServer(t, mux)\n\t\t\tvar clientConn net.Conn\n\t\t\ttransport := captureTransport(server, &clientConn, gotRequest)\n\t\t\tserverClient := &http.Client{Transport: transport}\n\t\t\tclient := pingv1connect.NewPingServiceClient(serverClient, server.URL())\n\t\t\tstream, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{}))\n\t\t\tif !assert.Nil(t, err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t<-gotRequest\n\t\t\t// Client abruptly disconnects.\n\t\t\tif !assert.NotNil(t, clientConn) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, clientConn.Close())\n\t\t\tfor stream.Receive() {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\tassert.NotNil(t, stream.Err())\n\t\t\t<-gotResponse\n\t\t\tassert.NotNil(t, handlerReceiveErr)\n\t\t\tassert.Equal(t, connect.CodeOf(handlerReceiveErr), connect.CodeCanceled)\n\t\t\tassert.ErrorIs(t, handlerContextErr, context.Canceled)\n\t\t})\n\t}\n\tt.Run(\"http1\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttestTransportClosure(t, http1RoundTripper)\n\t})\n\tt.Run(\"http2\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttestTransportClosure(t, http2RoundTripper)\n\t})\n}\n\n// TestBlankImportCodeGeneration tests that services.connect.go is generated with\n// blank import statements to services.pb.go so that the service's Descriptor is\n// available in the global proto registry.\nfunc TestBlankImportCodeGeneration(t *testing.T) {\n\tt.Parallel()\n\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(importv1connect.ImportServiceName)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, desc)\n}\n\n// TestSetProtocolHeaders tests that headers required by the protocols are set\n// overriding user provided headers.\nfunc TestSetProtocolHeaders(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname              string\n\t\tclientOption      connect.ClientOption\n\t\texpectContentType string\n\t}{{\n\t\tname:              \"connect\",\n\t\texpectContentType: \"application/proto\",\n\t}, {\n\t\tname:              \"grpc\",\n\t\tclientOption:      connect.WithGRPC(),\n\t\texpectContentType: \"application/grpc\",\n\t}, {\n\t\tname:              \"grpcweb\",\n\t\tclientOption:      connect.WithGRPCWeb(),\n\t\texpectContentType: \"application/grpc-web+proto\",\n\t}}\n\tfor _, tt := range tests {\n\t\ttestcase := tt\n\t\tt.Run(testcase.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tpingServer := &pingServer{}\n\t\t\tmux := http.NewServeMux()\n\t\t\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer))\n\t\t\tserver := memhttptest.NewServer(t, mux)\n\n\t\t\tclientOpts := []connect.ClientOption{}\n\t\t\tif testcase.clientOption == nil {\n\t\t\t\t// Use a different protocol to test the override.\n\t\t\t\tclientOpts = append(clientOpts, connect.WithGRPC())\n\t\t\t}\n\t\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), clientOpts...)\n\n\t\t\tpingProxyServer := &pluggablePingServer{\n\t\t\t\tping: func(ctx context.Context, request *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\t\t\t\t\treturn client.Ping(ctx, request)\n\t\t\t\t},\n\t\t\t}\n\t\t\tproxyMux := http.NewServeMux()\n\t\t\tproxyMux.Handle(pingv1connect.NewPingServiceHandler(pingProxyServer))\n\t\t\tproxyServer := memhttptest.NewServer(t, proxyMux)\n\n\t\t\tproxyClientOpts := []connect.ClientOption{}\n\t\t\tif testcase.clientOption != nil {\n\t\t\t\tproxyClientOpts = append(proxyClientOpts, testcase.clientOption)\n\t\t\t}\n\t\t\tproxyClient := pingv1connect.NewPingServiceClient(proxyServer.Client(), proxyServer.URL(), proxyClientOpts...)\n\n\t\t\trequest := connect.NewRequest(&pingv1.PingRequest{Number: 42})\n\t\t\trequest.Header().Set(\"X-Test\", t.Name())\n\t\t\tresponse, err := proxyClient.Ping(context.Background(), request)\n\t\t\tif !assert.Nil(t, err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Assert the Content-Type is set for the proxy clients protocol and not the client's.\n\t\t\tassert.Equal(t, response.Header().Get(\"Content-Type\"), testcase.expectContentType)\n\t\t\tassert.Equal(t, len(response.Header().Values(\"Content-Type\")), 1)\n\t\t})\n\t}\n}\n\ntype unflushableWriter struct {\n\tw http.ResponseWriter\n}\n\nfunc (w *unflushableWriter) Header() http.Header         { return w.w.Header() }\nfunc (w *unflushableWriter) Write(b []byte) (int, error) { return w.w.Write(b) }\nfunc (w *unflushableWriter) WriteHeader(code int)        { w.w.WriteHeader(code) }\n\nfunc gzipCompressedSize(tb testing.TB, message proto.Message) int {\n\ttb.Helper()\n\tuncompressed, err := proto.Marshal(message)\n\tassert.Nil(tb, err)\n\tvar buf bytes.Buffer\n\tgzipWriter := gzip.NewWriter(&buf)\n\t_, err = gzipWriter.Write(uncompressed)\n\tassert.Nil(tb, err)\n\tassert.Nil(tb, gzipWriter.Close())\n\treturn buf.Len()\n}\n\ntype failCodec struct{}\n\nfunc (c failCodec) Name() string {\n\treturn \"proto\"\n}\n\nfunc (c failCodec) Marshal(message any) ([]byte, error) {\n\treturn nil, errors.New(\"boom\")\n}\n\nfunc (c failCodec) Unmarshal(data []byte, message any) error {\n\tprotoMessage, ok := message.(proto.Message)\n\tif !ok {\n\t\treturn fmt.Errorf(\"not protobuf: %T\", message)\n\t}\n\treturn proto.Unmarshal(data, protoMessage)\n}\n\ntype pluggablePingServer struct {\n\tpingv1connect.UnimplementedPingServiceHandler\n\n\tping    func(context.Context, *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error)\n\tsum     func(context.Context, *connect.ClientStream[pingv1.SumRequest]) (*connect.Response[pingv1.SumResponse], error)\n\tcountUp func(context.Context, *connect.Request[pingv1.CountUpRequest], *connect.ServerStream[pingv1.CountUpResponse]) error\n\tcumSum  func(context.Context, *connect.BidiStream[pingv1.CumSumRequest, pingv1.CumSumResponse]) error\n}\n\nfunc (p *pluggablePingServer) Ping(\n\tctx context.Context,\n\trequest *connect.Request[pingv1.PingRequest],\n) (*connect.Response[pingv1.PingResponse], error) {\n\treturn p.ping(ctx, request)\n}\n\nfunc (p *pluggablePingServer) Sum(\n\tctx context.Context,\n\tstream *connect.ClientStream[pingv1.SumRequest],\n) (*connect.Response[pingv1.SumResponse], error) {\n\treturn p.sum(ctx, stream)\n}\n\nfunc (p *pluggablePingServer) CountUp(\n\tctx context.Context,\n\treq *connect.Request[pingv1.CountUpRequest],\n\tstream *connect.ServerStream[pingv1.CountUpResponse],\n) error {\n\treturn p.countUp(ctx, req, stream)\n}\n\nfunc (p *pluggablePingServer) CumSum(\n\tctx context.Context,\n\tstream *connect.BidiStream[pingv1.CumSumRequest, pingv1.CumSumResponse],\n) error {\n\treturn p.cumSum(ctx, stream)\n}\n\nfunc failNoHTTP2(tb testing.TB, stream *connect.BidiStreamForClient[pingv1.CumSumRequest, pingv1.CumSumResponse]) {\n\ttb.Helper()\n\tif err := stream.Send(&pingv1.CumSumRequest{}); err != nil {\n\t\tassert.ErrorIs(tb, err, io.EOF)\n\t\tassert.Equal(tb, connect.CodeOf(err), connect.CodeUnknown)\n\t}\n\tassert.Nil(tb, stream.CloseRequest())\n\t_, err := stream.Receive()\n\tassert.NotNil(tb, err) // should be 505\n\tassert.True(\n\t\ttb,\n\t\tstrings.Contains(err.Error(), \"HTTP status 505\"),\n\t\tassert.Sprintf(\"expected 505, got %v\", err),\n\t)\n\tassert.Nil(tb, stream.CloseResponse())\n}\n\nfunc expectClientHeader(check bool, req connect.AnyRequest) error {\n\tif !check {\n\t\treturn nil\n\t}\n\treturn expectMetadata(req.Header(), \"header\", clientHeader, headerValue)\n}\n\nfunc expectMetadata(meta http.Header, metaType, key, value string) error {\n\tif got := meta.Get(key); got != value {\n\t\treturn connect.NewError(connect.CodeInvalidArgument, fmt.Errorf(\n\t\t\t\"%s %q: got %q, expected %q\",\n\t\t\tmetaType,\n\t\t\tkey,\n\t\t\tgot,\n\t\t\tvalue,\n\t\t))\n\t}\n\treturn nil\n}\n\ntype pingServer struct {\n\tpingv1connect.UnimplementedPingServiceHandler\n\n\tcheckMetadata       bool\n\tincludeErrorDetails bool\n}\n\nfunc (p pingServer) Ping(ctx context.Context, request *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\tif err := expectClientHeader(p.checkMetadata, request); err != nil {\n\t\treturn nil, err\n\t}\n\tif request.Peer().Addr == \"\" {\n\t\treturn nil, connect.NewError(connect.CodeInternal, errors.New(\"no peer address\"))\n\t}\n\tif request.Peer().Protocol == \"\" {\n\t\treturn nil, connect.NewError(connect.CodeInternal, errors.New(\"no peer protocol\"))\n\t}\n\tresponse := connect.NewResponse(\n\t\t&pingv1.PingResponse{\n\t\t\tNumber: request.Msg.GetNumber(),\n\t\t\tText:   request.Msg.GetText(),\n\t\t},\n\t)\n\tresponse.Header().Set(handlerHeader, headerValue)\n\tresponse.Trailer().Set(handlerTrailer, trailerValue)\n\treturn response, nil\n}\n\nfunc (p pingServer) Fail(ctx context.Context, request *connect.Request[pingv1.FailRequest]) (*connect.Response[pingv1.FailResponse], error) {\n\tif err := expectClientHeader(p.checkMetadata, request); err != nil {\n\t\treturn nil, err\n\t}\n\tif request.Peer().Addr == \"\" {\n\t\treturn nil, connect.NewError(connect.CodeInternal, errors.New(\"no peer address\"))\n\t}\n\tif request.Peer().Protocol == \"\" {\n\t\treturn nil, connect.NewError(connect.CodeInternal, errors.New(\"no peer protocol\"))\n\t}\n\terr := connect.NewError(connect.Code(request.Msg.GetCode()), errors.New(errorMessage))\n\terr.Meta().Set(handlerHeader, headerValue)\n\terr.Meta().Set(handlerTrailer, trailerValue)\n\tif p.includeErrorDetails {\n\t\tdetail, derr := connect.NewErrorDetail(&pingv1.FailRequest{Code: request.Msg.GetCode()})\n\t\tif derr != nil {\n\t\t\treturn nil, derr\n\t\t}\n\t\terr.AddDetail(detail)\n\t}\n\treturn nil, err\n}\n\nfunc (p pingServer) Sum(\n\tctx context.Context,\n\tstream *connect.ClientStream[pingv1.SumRequest],\n) (*connect.Response[pingv1.SumResponse], error) {\n\tif p.checkMetadata {\n\t\tif err := expectMetadata(stream.RequestHeader(), \"header\", clientHeader, headerValue); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif stream.Peer().Addr == \"\" {\n\t\treturn nil, connect.NewError(connect.CodeInternal, errors.New(\"no peer address\"))\n\t}\n\tif stream.Peer().Protocol == \"\" {\n\t\treturn nil, connect.NewError(connect.CodeInternal, errors.New(\"no peer protocol\"))\n\t}\n\tvar sum int64\n\tfor stream.Receive() {\n\t\tsum += stream.Msg().GetNumber()\n\t}\n\tif stream.Err() != nil {\n\t\treturn nil, stream.Err()\n\t}\n\tresponse := connect.NewResponse(&pingv1.SumResponse{Sum: sum})\n\tresponse.Header().Set(handlerHeader, headerValue)\n\tresponse.Trailer().Set(handlerTrailer, trailerValue)\n\treturn response, nil\n}\n\nfunc (p pingServer) CountUp(\n\tctx context.Context,\n\trequest *connect.Request[pingv1.CountUpRequest],\n\tstream *connect.ServerStream[pingv1.CountUpResponse],\n) error {\n\tif err := expectClientHeader(p.checkMetadata, request); err != nil {\n\t\treturn err\n\t}\n\tif request.Peer().Addr == \"\" {\n\t\treturn connect.NewError(connect.CodeInternal, errors.New(\"no peer address\"))\n\t}\n\tif request.Peer().Protocol == \"\" {\n\t\treturn connect.NewError(connect.CodeInternal, errors.New(\"no peer protocol\"))\n\t}\n\tif request.Msg.GetNumber() <= 0 {\n\t\treturn connect.NewError(connect.CodeInvalidArgument, fmt.Errorf(\n\t\t\t\"number must be positive: got %v\",\n\t\t\trequest.Msg.GetNumber(),\n\t\t))\n\t}\n\tstream.ResponseHeader().Set(handlerHeader, headerValue)\n\tstream.ResponseTrailer().Set(handlerTrailer, trailerValue)\n\tfor i := int64(1); i <= request.Msg.GetNumber(); i++ {\n\t\tif err := stream.Send(&pingv1.CountUpResponse{Number: i}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p pingServer) CumSum(\n\tctx context.Context,\n\tstream *connect.BidiStream[pingv1.CumSumRequest, pingv1.CumSumResponse],\n) error {\n\tvar sum int64\n\tif p.checkMetadata {\n\t\tif err := expectMetadata(stream.RequestHeader(), \"header\", clientHeader, headerValue); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif stream.Peer().Addr == \"\" {\n\t\treturn connect.NewError(connect.CodeInternal, errors.New(\"no peer address\"))\n\t}\n\tif stream.Peer().Protocol == \"\" {\n\t\treturn connect.NewError(connect.CodeInternal, errors.New(\"no peer address\"))\n\t}\n\tstream.ResponseHeader().Set(handlerHeader, headerValue)\n\tstream.ResponseTrailer().Set(handlerTrailer, trailerValue)\n\tfor {\n\t\tmsg, err := stream.Receive()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\treturn nil\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsum += msg.GetNumber()\n\t\tif err := stream.Send(&pingv1.CumSumResponse{Sum: sum}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\ntype deflateReader struct {\n\tr io.ReadCloser\n}\n\nfunc newDeflateReader(r io.Reader) *deflateReader {\n\treturn &deflateReader{r: flate.NewReader(r)}\n}\n\nfunc (d *deflateReader) Read(p []byte) (int, error) {\n\treturn d.r.Read(p)\n}\n\nfunc (d *deflateReader) Close() error {\n\treturn d.r.Close()\n}\n\nfunc (d *deflateReader) Reset(reader io.Reader) error {\n\tif resetter, ok := d.r.(flate.Resetter); ok {\n\t\treturn resetter.Reset(reader, nil)\n\t}\n\treturn errors.New(\"flate reader should implement flate.Resetter\")\n}\n\nvar _ connect.Decompressor = (*deflateReader)(nil)\n\ntype trimTrailerWriter struct {\n\tw http.ResponseWriter\n}\n\nfunc (l *trimTrailerWriter) Header() http.Header {\n\treturn l.w.Header()\n}\n\n// Write writes b to underlying writer and counts written size.\nfunc (l *trimTrailerWriter) Write(b []byte) (int, error) {\n\tl.removeTrailers()\n\treturn l.w.Write(b)\n}\n\n// WriteHeader writes s to underlying writer and retains the status.\nfunc (l *trimTrailerWriter) WriteHeader(s int) {\n\tl.removeTrailers()\n\tl.w.WriteHeader(s)\n}\n\n// Flush implements http.Flusher.\nfunc (l *trimTrailerWriter) Flush() {\n\tl.removeTrailers()\n\tif f, ok := l.w.(http.Flusher); ok {\n\t\tf.Flush()\n\t}\n}\n\nfunc (l *trimTrailerWriter) removeTrailers() {\n\tfor _, v := range l.w.Header().Values(\"Trailer\") {\n\t\tl.w.Header().Del(v)\n\t}\n\tl.w.Header().Del(\"Trailer\")\n\tfor k := range l.w.Header() {\n\t\tif strings.HasPrefix(k, http.TrailerPrefix) {\n\t\t\tl.w.Header().Del(k)\n\t\t}\n\t}\n}\n\nfunc newHTTPMiddlewareError() *connect.Error {\n\terr := connect.NewError(connect.CodeResourceExhausted, errors.New(\"error from HTTP middleware\"))\n\terr.Meta().Set(\"Middleware-Foo\", \"bar\")\n\treturn err\n}\n\ntype failDecompressor struct {\n\tconnect.Decompressor\n}\n\ntype failCompressor struct{}\n\nfunc (failCompressor) Write([]byte) (int, error) {\n\treturn 0, errors.New(\"failCompressor\")\n}\n\nfunc (failCompressor) Close() error {\n\treturn errors.New(\"failCompressor\")\n}\n\nfunc (failCompressor) Reset(io.Writer) {}\n"
        },
        {
          "name": "duplex_http_call.go",
          "type": "blob",
          "size": 14.1376953125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\n// duplexHTTPCall is a full-duplex stream between the client and server. The\n// request body is the stream from client to server, and the response body is\n// the reverse.\n//\n// Be warned: we need to use some lesser-known APIs to do this with net/http.\ntype duplexHTTPCall struct {\n\tctx              context.Context\n\thttpClient       HTTPClient\n\tstreamType       StreamType\n\tonRequestSend    func(*http.Request)\n\tvalidateResponse func(*http.Response) *Error\n\n\t// io.Pipe is used to implement the request body for client streaming calls.\n\t// If the request is unary, requestBodyWriter is nil.\n\trequestBodyWriter *io.PipeWriter\n\n\t// requestSent ensures we only send the request once.\n\trequestSent atomic.Bool\n\trequest     *http.Request\n\n\t// responseReady is closed when the response is ready or when the request\n\t// fails. Any error on request initialisation will be set on the\n\t// responseErr. There's always a response if responseErr is nil.\n\tresponseReady chan struct{}\n\tresponse      *http.Response\n\tresponseErr   error\n}\n\nfunc newDuplexHTTPCall(\n\tctx context.Context,\n\thttpClient HTTPClient,\n\turl *url.URL,\n\tspec Spec,\n\theader http.Header,\n) *duplexHTTPCall {\n\t// ensure we make a copy of the url before we pass along to the\n\t// Request. This ensures if a transport out of our control wants\n\t// to mutate the req.URL, we don't feel the effects of it.\n\turl = cloneURL(url)\n\n\t// This is mirroring what http.NewRequestContext did, but\n\t// using an already parsed url.URL object, rather than a string\n\t// and parsing it again. This is a bit funny with HTTP/1.1\n\t// explicitly, but this is logic copied over from\n\t// NewRequestContext and doesn't effect the actual version\n\t// being transmitted.\n\trequest := (&http.Request{\n\t\tMethod:     http.MethodPost,\n\t\tURL:        url,\n\t\tHeader:     header,\n\t\tProto:      \"HTTP/1.1\",\n\t\tProtoMajor: 1,\n\t\tProtoMinor: 1,\n\t\tBody:       http.NoBody,\n\t\tGetBody:    getNoBody,\n\t\tHost:       url.Host,\n\t}).WithContext(ctx)\n\treturn &duplexHTTPCall{\n\t\tctx:           ctx,\n\t\thttpClient:    httpClient,\n\t\tstreamType:    spec.StreamType,\n\t\trequest:       request,\n\t\tresponseReady: make(chan struct{}),\n\t}\n}\n\n// Send sends a message to the server.\nfunc (d *duplexHTTPCall) Send(payload messagePayload) (int64, error) {\n\tif d.streamType&StreamTypeClient == 0 {\n\t\treturn d.sendUnary(payload)\n\t}\n\tisFirst := d.requestSent.CompareAndSwap(false, true)\n\tif isFirst {\n\t\t// This is the first time we're sending a message to the server.\n\t\t// We need to send the request headers and start the request.\n\t\tpipeReader, pipeWriter := io.Pipe()\n\t\td.requestBodyWriter = pipeWriter\n\t\td.request.Body = pipeReader\n\t\td.request.GetBody = nil // GetBody not supported for client streaming\n\t\td.request.ContentLength = -1\n\t\tgo d.makeRequest() // concurrent request\n\t}\n\tif err := d.ctx.Err(); err != nil {\n\t\treturn 0, wrapIfContextError(err)\n\t}\n\tif isFirst && payload.Len() == 0 {\n\t\t// On first write a nil Send is used to send request headers. Avoid\n\t\t// writing a zero-length payload to avoid superfluous errors with close.\n\t\treturn 0, nil\n\t}\n\t// It's safe to write to this side of the pipe while net/http concurrently\n\t// reads from the other side.\n\tbytesWritten, err := payload.WriteTo(d.requestBodyWriter)\n\tif err != nil && errors.Is(err, io.ErrClosedPipe) {\n\t\t// Signal that the stream is closed with the more-typical io.EOF instead of\n\t\t// io.ErrClosedPipe. This makes it easier for protocol-specific wrappers to\n\t\t// match grpc-go's behavior.\n\t\terr = io.EOF\n\t}\n\treturn bytesWritten, err\n}\n\nfunc (d *duplexHTTPCall) sendUnary(payload messagePayload) (int64, error) {\n\t// Unary messages are sent as a single HTTP request. We don't need to use a\n\t// pipe for the request body and we don't need to send headers separately.\n\tif !d.requestSent.CompareAndSwap(false, true) {\n\t\treturn 0, errors.New(\"request already sent\")\n\t}\n\tpayloadLength := int64(payload.Len())\n\tif payloadLength > 0 {\n\t\t// Build the request body from the payload.\n\t\tpayloadBody := newPayloadCloser(payload)\n\t\td.request.Body = payloadBody\n\t\td.request.ContentLength = payloadLength\n\t\td.request.GetBody = func() (io.ReadCloser, error) {\n\t\t\tif !payloadBody.Rewind() {\n\t\t\t\treturn nil, errors.New(\"payload cannot be retried\")\n\t\t\t}\n\t\t\treturn payloadBody, nil\n\t\t}\n\t\t// Release the payload ensuring that after Send returns the\n\t\t// payload is safe to be reused. See [http.RoundTripper] for\n\t\t// more details.\n\t\tdefer payloadBody.Release()\n\t}\n\td.makeRequest() // synchronous request\n\tif d.responseErr != nil {\n\t\t// Check on response errors for context errors. Other errors are\n\t\t// handled on read.\n\t\tif err := d.ctx.Err(); err != nil {\n\t\t\treturn 0, wrapIfContextError(err)\n\t\t}\n\t}\n\treturn payloadLength, nil\n}\n\n// CloseWrite closes the request body. Callers *must* call CloseWrite before Read when\n// using HTTP/1.x.\nfunc (d *duplexHTTPCall) CloseWrite() error {\n\t// Even if Write was never called, we need to make an HTTP request. This\n\t// ensures that we've sent any headers to the server and that we have an HTTP\n\t// response to read from.\n\tif d.requestSent.CompareAndSwap(false, true) {\n\t\tgo d.makeRequest()\n\t\t// We never setup a request body, so it's effectively already closed.\n\t\t// So nothing else to do.\n\t\treturn nil\n\t}\n\t// The user calls CloseWrite to indicate that they're done sending data. It's\n\t// safe to close the write side of the pipe while net/http is reading from\n\t// it.\n\t//\n\t// Because connect also supports some RPC types over HTTP/1.1, we need to be\n\t// careful how we expose this method to users. HTTP/1.1 doesn't support\n\t// bidirectional streaming - the write side of the stream (aka request body)\n\t// must be closed before we start reading the response or we'll just block\n\t// forever. To make sure users don't have to worry about this, the generated\n\t// code for unary, client streaming, and server streaming RPCs must call\n\t// CloseWrite automatically rather than requiring the user to do it.\n\tif d.requestBodyWriter != nil {\n\t\treturn d.requestBodyWriter.Close()\n\t}\n\treturn d.request.Body.Close()\n}\n\n// Header returns the HTTP request headers.\nfunc (d *duplexHTTPCall) Header() http.Header {\n\treturn d.request.Header\n}\n\n// Trailer returns the HTTP request trailers.\nfunc (d *duplexHTTPCall) Trailer() http.Header {\n\treturn d.request.Trailer\n}\n\n// URL returns the URL for the request.\nfunc (d *duplexHTTPCall) URL() *url.URL {\n\treturn d.request.URL\n}\n\n// Method returns the HTTP method for the request (GET or POST).\nfunc (d *duplexHTTPCall) Method() string {\n\treturn d.request.Method\n}\n\n// SetMethod changes the method of the request before it is sent.\nfunc (d *duplexHTTPCall) SetMethod(method string) {\n\td.request.Method = method\n}\n\n// Read from the response body. Returns the first error passed to SetError.\nfunc (d *duplexHTTPCall) Read(data []byte) (int, error) {\n\t// First, we wait until we've gotten the response headers and established the\n\t// server-to-client side of the stream.\n\tif err := d.BlockUntilResponseReady(); err != nil {\n\t\t// The stream is already closed or corrupted.\n\t\treturn 0, err\n\t}\n\t// Before we read, check if the context has been canceled.\n\tif err := d.ctx.Err(); err != nil {\n\t\treturn 0, wrapIfContextError(err)\n\t}\n\tn, err := d.response.Body.Read(data)\n\tif err != nil && !errors.Is(err, io.EOF) {\n\t\terr = wrapIfContextDone(d.ctx, err)\n\t\terr = wrapIfRSTError(err)\n\t}\n\treturn n, err\n}\n\nfunc (d *duplexHTTPCall) CloseRead() error {\n\t_ = d.BlockUntilResponseReady()\n\tif d.response == nil {\n\t\treturn nil\n\t}\n\terr := d.response.Body.Close()\n\terr = wrapIfContextDone(d.ctx, err)\n\treturn wrapIfRSTError(err)\n}\n\n// ResponseStatusCode is the response's HTTP status code.\nfunc (d *duplexHTTPCall) ResponseStatusCode() (int, error) {\n\tif err := d.BlockUntilResponseReady(); err != nil {\n\t\treturn 0, err\n\t}\n\treturn d.response.StatusCode, nil\n}\n\n// ResponseHeader returns the response HTTP headers.\nfunc (d *duplexHTTPCall) ResponseHeader() http.Header {\n\t_ = d.BlockUntilResponseReady()\n\tif d.response != nil {\n\t\treturn d.response.Header\n\t}\n\treturn make(http.Header)\n}\n\n// ResponseTrailer returns the response HTTP trailers.\nfunc (d *duplexHTTPCall) ResponseTrailer() http.Header {\n\t_ = d.BlockUntilResponseReady()\n\tif d.response != nil {\n\t\treturn d.response.Trailer\n\t}\n\treturn make(http.Header)\n}\n\n// SetValidateResponse sets the response validation function. The function runs\n// in a background goroutine.\nfunc (d *duplexHTTPCall) SetValidateResponse(validate func(*http.Response) *Error) {\n\td.validateResponse = validate\n}\n\n// BlockUntilResponseReady returns when the response is ready or reports an\n// error from initializing the request.\nfunc (d *duplexHTTPCall) BlockUntilResponseReady() error {\n\t<-d.responseReady\n\treturn d.responseErr\n}\n\nfunc (d *duplexHTTPCall) makeRequest() {\n\t// This runs concurrently with Write and CloseWrite. Read and CloseRead wait\n\t// on d.responseReady, so we can't race with them.\n\tdefer close(d.responseReady)\n\n\t// Promote the header Host to the request object.\n\tif host := getHeaderCanonical(d.request.Header, headerHost); len(host) > 0 {\n\t\td.request.Host = host\n\t}\n\tif d.onRequestSend != nil {\n\t\td.onRequestSend(d.request)\n\t}\n\t// Once we send a message to the server, they send a message back and\n\t// establish the receive side of the stream.\n\t// On error, we close the request body using the Write side of the pipe.\n\t// This ensures HTTP2 streams receive an io.EOF from the Read side of the\n\t// pipe. Write's check for io.ErrClosedPipe and will convert this to io.EOF.\n\tresponse, err := d.httpClient.Do(d.request) //nolint:bodyclose\n\tif err != nil {\n\t\tif errors.Is(err, io.EOF) {\n\t\t\t// We use io.EOF as a sentinel in many places and don't want this\n\t\t\t// transport error to be confused for those other situations.\n\t\t\terr = io.ErrUnexpectedEOF\n\t\t}\n\t\terr = wrapIfContextError(err)\n\t\terr = wrapIfLikelyH2CNotConfiguredError(d.request, err)\n\t\terr = wrapIfLikelyWithGRPCNotUsedError(err)\n\t\terr = wrapIfRSTError(err)\n\t\tif _, ok := asError(err); !ok {\n\t\t\terr = NewError(CodeUnavailable, err)\n\t\t}\n\t\td.responseErr = err\n\t\t_ = d.CloseWrite()\n\t\treturn\n\t}\n\t// We've got a response. We can now read from the response body.\n\t// Closing the response body is delegated to the caller even on error.\n\td.response = response\n\tif err := d.validateResponse(response); err != nil {\n\t\td.responseErr = err\n\t\t_ = d.CloseWrite()\n\t\treturn\n\t}\n\tif (d.streamType&StreamTypeBidi) == StreamTypeBidi && response.ProtoMajor < 2 {\n\t\t// If we somehow dialed an HTTP/1.x server, fail with an explicit message\n\t\t// rather than returning a more cryptic error later on.\n\t\td.responseErr = errorf(\n\t\t\tCodeUnimplemented,\n\t\t\t\"response from %v is HTTP/%d.%d: bidi streams require at least HTTP/2\",\n\t\t\td.request.URL,\n\t\t\tresponse.ProtoMajor,\n\t\t\tresponse.ProtoMinor,\n\t\t)\n\t\t_ = d.CloseWrite()\n\t}\n}\n\n// getNoBody is a GetBody function for http.NoBody.\nfunc getNoBody() (io.ReadCloser, error) {\n\treturn http.NoBody, nil\n}\n\n// messagePayload is a sized and seekable message payload. The interface is\n// implemented by [*bytes.Reader] and *envelope. Reads must be non-blocking.\ntype messagePayload interface {\n\tio.Reader\n\tio.WriterTo\n\tio.Seeker\n\tLen() int\n}\n\n// nopPayload is a message payload that does nothing. It's used to send headers\n// to the server.\ntype nopPayload struct{}\n\nvar _ messagePayload = nopPayload{}\n\nfunc (nopPayload) Read([]byte) (int, error) {\n\treturn 0, io.EOF\n}\nfunc (nopPayload) WriteTo(io.Writer) (int64, error) {\n\treturn 0, nil\n}\nfunc (nopPayload) Seek(int64, int) (int64, error) {\n\treturn 0, nil\n}\nfunc (nopPayload) Len() int {\n\treturn 0\n}\n\n// messageSender sends a message payload. The interface is implemented by\n// [*duplexHTTPCall] and writeSender.\ntype messageSender interface {\n\tSend(messagePayload) (int64, error)\n}\n\n// writeSender is a sender that writes to an [io.Writer]. Useful for wrapping\n// [http.ResponseWriter].\ntype writeSender struct {\n\twriter io.Writer\n}\n\nvar _ messageSender = writeSender{}\n\nfunc (w writeSender) Send(payload messagePayload) (int64, error) {\n\treturn payload.WriteTo(w.writer)\n}\n\n// See: https://cs.opensource.google/go/go/+/refs/tags/go1.20.1:src/net/http/clone.go;l=22-33\nfunc cloneURL(oldURL *url.URL) *url.URL {\n\tif oldURL == nil {\n\t\treturn nil\n\t}\n\tnewURL := new(url.URL)\n\t*newURL = *oldURL\n\tif oldURL.User != nil {\n\t\tnewURL.User = new(url.Userinfo)\n\t\t*newURL.User = *oldURL.User\n\t}\n\treturn newURL\n}\n\n// payloadCloser is an [io.ReadCloser] that wraps a messagePayload. It's used to\n// implement the request body for unary calls. To safely reuse the buffer\n// call Release after the response is received to ensure the payload is safe for\n// reuse.\ntype payloadCloser struct {\n\tmu      sync.Mutex\n\tpayload messagePayload // nil after Release\n}\n\nfunc newPayloadCloser(payload messagePayload) *payloadCloser {\n\treturn &payloadCloser{\n\t\tpayload: payload,\n\t}\n}\n\n// Read implements [io.Reader].\nfunc (p *payloadCloser) Read(dst []byte) (readN int, err error) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.payload == nil {\n\t\treturn 0, io.EOF\n\t}\n\treturn p.payload.Read(dst)\n}\n\n// WriteTo implements [io.WriterTo].\nfunc (p *payloadCloser) WriteTo(dst io.Writer) (int64, error) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.payload == nil {\n\t\treturn 0, nil\n\t}\n\treturn p.payload.WriteTo(dst)\n}\n\n// Close implements [io.Closer].\nfunc (p *payloadCloser) Close() error {\n\treturn nil\n}\n\n// Rewind rewinds the payload to the beginning. It returns false if the\n// payload has been discarded from a previous call to Release.\nfunc (p *payloadCloser) Rewind() bool {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.payload == nil {\n\t\treturn false\n\t}\n\tif _, err := p.payload.Seek(0, io.SeekStart); err != nil {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Release discards the payload. After Release is called, the payload cannot be\n// rewound and the payload is safe to reuse.\nfunc (p *payloadCloser) Release() {\n\tp.mu.Lock()\n\tp.payload = nil\n\tp.mu.Unlock()\n}\n"
        },
        {
          "name": "duplex_http_call_test.go",
          "type": "blob",
          "size": 3.2431640625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n)\n\n// TestHTTPCallGetBody tests that the client is able to retry requests on\n// connection close errors. It will initialize a closing handler and ensure\n// http.Request.GetBody is successfully called to replay the request.\nfunc TestHTTPCallGetBody(t *testing.T) {\n\tt.Parallel()\n\thandler := http.HandlerFunc(func(responseWriter http.ResponseWriter, request *http.Request) {\n\t\t// The \"Connection: close\" header is turned into a GOAWAY frame by the http2 server.\n\t\tresponseWriter.Header().Add(\"Connection\", \"close\")\n\t\t_, _ = io.Copy(responseWriter, request.Body)\n\t\t_ = request.Body.Close()\n\t})\n\t// Must use httptest for this test.\n\tserver := httptest.NewUnstartedServer(handler)\n\tserver.EnableHTTP2 = true\n\tserver.StartTLS()\n\tt.Cleanup(server.Close)\n\tbufferPool := newBufferPool()\n\tserverURL, _ := url.Parse(server.URL)\n\terrGetBodyCalled := errors.New(\"getBodyCalled\") // sentinel error\n\tcaller := func(size int) error {\n\t\tcall := newDuplexHTTPCall(\n\t\t\tcontext.Background(),\n\t\t\tserver.Client(),\n\t\t\tserverURL,\n\t\t\tSpec{StreamType: StreamTypeUnary},\n\t\t\thttp.Header{},\n\t\t)\n\t\tgetBodyCalled := false\n\t\tcall.onRequestSend = func(*http.Request) {\n\t\t\tgetBody := call.request.GetBody\n\t\t\tcall.request.GetBody = func() (io.ReadCloser, error) {\n\t\t\t\tgetBodyCalled = true\n\t\t\t\trdcloser, err := getBody()\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\treturn rdcloser, err\n\t\t\t}\n\t\t}\n\t\t// SetValidateResponse must be set.\n\t\tcall.SetValidateResponse(func(*http.Response) *Error {\n\t\t\treturn nil\n\t\t})\n\t\tbuf := bufferPool.Get()\n\t\tdefer bufferPool.Put(buf)\n\t\tbuf.Write(make([]byte, size))\n\t\t_, err := call.Send(bytes.NewReader(buf.Bytes()))\n\t\tassert.Nil(t, err)\n\t\tassert.Nil(t, call.CloseWrite())\n\t\tbuf.Reset()\n\t\t_, err = io.Copy(buf, call)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, buf.Len(), size)\n\t\tif getBodyCalled {\n\t\t\treturn errGetBodyCalled\n\t\t}\n\t\treturn nil\n\t}\n\ttype work struct {\n\t\tsize int\n\t\terrs chan error\n\t}\n\tnumWorkers := 2\n\tworkChan := make(chan work)\n\twg := sync.WaitGroup{}\n\twg.Add(numWorkers)\n\tfor i := 0; i < numWorkers; i++ {\n\t\tgo func() {\n\t\t\tfor work := range workChan {\n\t\t\t\twork.errs <- caller(work.size)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\tfor i, gotGetBody := 0, false; !gotGetBody; i++ {\n\t\terrs := make([]chan error, numWorkers)\n\t\tfor i := 0; i < numWorkers; i++ {\n\t\t\terrs[i] = make(chan error, 1)\n\t\t\tworkChan <- work{size: 512, errs: errs[i]}\n\t\t}\n\t\tt.Log(\"waiting\", i)\n\t\tfor _, errChan := range errs {\n\t\t\tif err := <-errChan; err != nil {\n\t\t\t\tif errors.Is(err, errGetBodyCalled) {\n\t\t\t\t\tgotGetBody = true\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tclose(workChan)\n\twg.Wait()\n}\n"
        },
        {
          "name": "envelope.go",
          "type": "blob",
          "size": 11.4384765625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n)\n\n// flagEnvelopeCompressed indicates that the data is compressed. It has the\n// same meaning in the gRPC-Web, gRPC-HTTP2, and Connect protocols.\nconst flagEnvelopeCompressed = 0b00000001\n\nvar errSpecialEnvelope = errorf(\n\tCodeUnknown,\n\t\"final message has protocol-specific flags: %w\",\n\t// User code checks for end of stream with errors.Is(err, io.EOF).\n\tio.EOF,\n)\n\n// envelope is a block of arbitrary bytes wrapped in gRPC and Connect's framing\n// protocol.\n//\n// Each message is preceded by a 5-byte prefix. The first byte is a uint8 used\n// as a set of bitwise flags, and the remainder is a uint32 indicating the\n// message length. gRPC and Connect interpret the bitwise flags differently, so\n// envelope leaves their interpretation up to the caller.\ntype envelope struct {\n\tData   *bytes.Buffer\n\tFlags  uint8\n\toffset int64\n}\n\nvar _ messagePayload = (*envelope)(nil)\n\nfunc (e *envelope) IsSet(flag uint8) bool {\n\treturn e.Flags&flag == flag\n}\n\n// Read implements [io.Reader].\nfunc (e *envelope) Read(data []byte) (readN int, err error) {\n\tif e.offset < 5 {\n\t\tprefix := makeEnvelopePrefix(e.Flags, e.Data.Len())\n\t\treadN = copy(data, prefix[e.offset:])\n\t\te.offset += int64(readN)\n\t\tif e.offset < 5 {\n\t\t\treturn readN, nil\n\t\t}\n\t\tdata = data[readN:]\n\t}\n\tn := copy(data, e.Data.Bytes()[e.offset-5:])\n\te.offset += int64(n)\n\treadN += n\n\tif readN == 0 && e.offset == int64(e.Data.Len()+5) {\n\t\terr = io.EOF\n\t}\n\treturn readN, err\n}\n\n// WriteTo implements [io.WriterTo].\nfunc (e *envelope) WriteTo(dst io.Writer) (wroteN int64, err error) {\n\tif e.offset < 5 {\n\t\tprefix := makeEnvelopePrefix(e.Flags, e.Data.Len())\n\t\tprefixN, err := dst.Write(prefix[e.offset:])\n\t\te.offset += int64(prefixN)\n\t\twroteN += int64(prefixN)\n\t\tif e.offset < 5 {\n\t\t\treturn wroteN, err\n\t\t}\n\t}\n\tn, err := dst.Write(e.Data.Bytes()[e.offset-5:])\n\te.offset += int64(n)\n\twroteN += int64(n)\n\treturn wroteN, err\n}\n\n// Seek implements [io.Seeker]. Based on the implementation of [bytes.Reader].\nfunc (e *envelope) Seek(offset int64, whence int) (int64, error) {\n\tvar abs int64\n\tswitch whence {\n\tcase io.SeekStart:\n\t\tabs = offset\n\tcase io.SeekCurrent:\n\t\tabs = e.offset + offset\n\tcase io.SeekEnd:\n\t\tabs = int64(e.Data.Len()) + offset\n\tdefault:\n\t\treturn 0, errors.New(\"connect.envelope.Seek: invalid whence\")\n\t}\n\tif abs < 0 {\n\t\treturn 0, errors.New(\"connect.envelope.Seek: negative position\")\n\t}\n\te.offset = abs\n\treturn abs, nil\n}\n\n// Len returns the number of bytes of the unread portion of the envelope.\nfunc (e *envelope) Len() int {\n\tif length := int(int64(e.Data.Len()) + 5 - e.offset); length > 0 {\n\t\treturn length\n\t}\n\treturn 0\n}\n\ntype envelopeWriter struct {\n\tctx              context.Context //nolint:containedctx\n\tsender           messageSender\n\tcodec            Codec\n\tcompressMinBytes int\n\tcompressionPool  *compressionPool\n\tbufferPool       *bufferPool\n\tsendMaxBytes     int\n}\n\nfunc (w *envelopeWriter) Marshal(message any) *Error {\n\tif message == nil {\n\t\t// Send no-op message to create the request and send headers.\n\t\tpayload := nopPayload{}\n\t\tif _, err := w.sender.Send(payload); err != nil {\n\t\t\tif connectErr, ok := asError(err); ok {\n\t\t\t\treturn connectErr\n\t\t\t}\n\t\t\treturn NewError(CodeUnknown, err)\n\t\t}\n\t\treturn nil\n\t}\n\tif appender, ok := w.codec.(marshalAppender); ok {\n\t\treturn w.marshalAppend(message, appender)\n\t}\n\treturn w.marshal(message)\n}\n\n// Write writes the enveloped message, compressing as necessary. It doesn't\n// retain any references to the supplied envelope or its underlying data.\nfunc (w *envelopeWriter) Write(env *envelope) *Error {\n\tif env.IsSet(flagEnvelopeCompressed) ||\n\t\tw.compressionPool == nil ||\n\t\tenv.Data.Len() < w.compressMinBytes {\n\t\tif w.sendMaxBytes > 0 && env.Data.Len() > w.sendMaxBytes {\n\t\t\treturn errorf(CodeResourceExhausted, \"message size %d exceeds sendMaxBytes %d\", env.Data.Len(), w.sendMaxBytes)\n\t\t}\n\t\treturn w.write(env)\n\t}\n\tdata := w.bufferPool.Get()\n\tdefer w.bufferPool.Put(data)\n\tif err := w.compressionPool.Compress(data, env.Data); err != nil {\n\t\treturn err\n\t}\n\tif w.sendMaxBytes > 0 && data.Len() > w.sendMaxBytes {\n\t\treturn errorf(CodeResourceExhausted, \"compressed message size %d exceeds sendMaxBytes %d\", data.Len(), w.sendMaxBytes)\n\t}\n\treturn w.write(&envelope{\n\t\tData:  data,\n\t\tFlags: env.Flags | flagEnvelopeCompressed,\n\t})\n}\n\nfunc (w *envelopeWriter) marshalAppend(message any, codec marshalAppender) *Error {\n\t// Codec supports MarshalAppend; try to re-use a []byte from the pool.\n\tbuffer := w.bufferPool.Get()\n\tdefer w.bufferPool.Put(buffer)\n\traw, err := codec.MarshalAppend(buffer.Bytes(), message)\n\tif err != nil {\n\t\treturn errorf(CodeInternal, \"marshal message: %w\", err)\n\t}\n\tif cap(raw) > buffer.Cap() {\n\t\t// The buffer from the pool was too small, so MarshalAppend grew the slice.\n\t\t// Pessimistically assume that the too-small buffer is insufficient for the\n\t\t// application workload, so there's no point in keeping it in the pool.\n\t\t// Instead, replace it with the larger, newly-allocated slice. This\n\t\t// allocates, but it's a small, constant-size allocation.\n\t\t*buffer = *bytes.NewBuffer(raw)\n\t} else {\n\t\t// MarshalAppend didn't allocate, but we need to fix the internal state of\n\t\t// the buffer. Compared to replacing the buffer (as above), buffer.Write\n\t\t// copies but avoids allocating.\n\t\tbuffer.Write(raw)\n\t}\n\tenvelope := &envelope{Data: buffer}\n\treturn w.Write(envelope)\n}\n\nfunc (w *envelopeWriter) marshal(message any) *Error {\n\t// Codec doesn't support MarshalAppend; let Marshal allocate a []byte.\n\traw, err := w.codec.Marshal(message)\n\tif err != nil {\n\t\treturn errorf(CodeInternal, \"marshal message: %w\", err)\n\t}\n\tbuffer := bytes.NewBuffer(raw)\n\t// Put our new []byte into the pool for later reuse.\n\tdefer w.bufferPool.Put(buffer)\n\tenvelope := &envelope{Data: buffer}\n\treturn w.Write(envelope)\n}\n\nfunc (w *envelopeWriter) write(env *envelope) *Error {\n\tif _, err := w.sender.Send(env); err != nil {\n\t\terr = wrapIfContextDone(w.ctx, err)\n\t\tif connectErr, ok := asError(err); ok {\n\t\t\treturn connectErr\n\t\t}\n\t\treturn errorf(CodeUnknown, \"write envelope: %w\", err)\n\t}\n\treturn nil\n}\n\ntype envelopeReader struct {\n\tctx             context.Context //nolint:containedctx\n\treader          io.Reader\n\tbytesRead       int64 // detect trailers-only gRPC responses\n\tcodec           Codec\n\tlast            envelope\n\tcompressionPool *compressionPool\n\tbufferPool      *bufferPool\n\treadMaxBytes    int\n}\n\nfunc (r *envelopeReader) Unmarshal(message any) *Error {\n\tbuffer := r.bufferPool.Get()\n\tvar dontRelease *bytes.Buffer\n\tdefer func() {\n\t\tif buffer != dontRelease {\n\t\t\tr.bufferPool.Put(buffer)\n\t\t}\n\t}()\n\n\tenv := &envelope{Data: buffer}\n\terr := r.Read(env)\n\tswitch {\n\tcase err == nil && env.IsSet(flagEnvelopeCompressed) && r.compressionPool == nil:\n\t\treturn errorf(\n\t\t\tCodeInternal,\n\t\t\t\"protocol error: sent compressed message without compression support\",\n\t\t)\n\tcase err == nil &&\n\t\t(env.Flags == 0 || env.Flags == flagEnvelopeCompressed) &&\n\t\tenv.Data.Len() == 0:\n\t\t// This is a standard message (because none of the top 7 bits are set) and\n\t\t// there's no data, so the zero value of the message is correct.\n\t\treturn nil\n\tcase err != nil && errors.Is(err, io.EOF):\n\t\t// The stream has ended. Propagate the EOF to the caller.\n\t\treturn err\n\tcase err != nil:\n\t\t// Something's wrong.\n\t\treturn err\n\t}\n\n\tdata := env.Data\n\tif data.Len() > 0 && env.IsSet(flagEnvelopeCompressed) {\n\t\tdecompressed := r.bufferPool.Get()\n\t\tdefer func() {\n\t\t\tif decompressed != dontRelease {\n\t\t\t\tr.bufferPool.Put(decompressed)\n\t\t\t}\n\t\t}()\n\t\tif err := r.compressionPool.Decompress(decompressed, data, int64(r.readMaxBytes)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdata = decompressed\n\t}\n\n\tif env.Flags != 0 && env.Flags != flagEnvelopeCompressed {\n\t\t// Drain the rest of the stream to ensure there is no extra data.\n\t\tnumBytes, err := discard(r.reader)\n\t\tr.bytesRead += numBytes\n\t\tif err != nil {\n\t\t\terr = wrapIfContextError(err)\n\t\t\tif connErr, ok := asError(err); ok {\n\t\t\t\treturn connErr\n\t\t\t}\n\t\t\treturn errorf(CodeInternal, \"corrupt response: I/O error after end-stream message: %w\", err)\n\t\t} else if numBytes > 0 {\n\t\t\treturn errorf(CodeInternal, \"corrupt response: %d extra bytes after end of stream\", numBytes)\n\t\t}\n\t\t// One of the protocol-specific flags are set, so this is the end of the\n\t\t// stream. Save the message for protocol-specific code to process and\n\t\t// return a sentinel error. We alias the buffer with dontRelease as a\n\t\t// way of marking it so above defers don't release it to the pool.\n\t\tr.last = envelope{\n\t\t\tData:  data,\n\t\t\tFlags: env.Flags,\n\t\t}\n\t\tdontRelease = data\n\t\treturn errSpecialEnvelope\n\t}\n\n\tif err := r.codec.Unmarshal(data.Bytes(), message); err != nil {\n\t\treturn errorf(CodeInvalidArgument, \"unmarshal message: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *envelopeReader) Read(env *envelope) *Error {\n\tprefixes := [5]byte{}\n\t// io.ReadFull reads the number of bytes requested, or returns an error.\n\t// io.EOF will only be returned if no bytes were read.\n\tn, err := io.ReadFull(r.reader, prefixes[:])\n\tr.bytesRead += int64(n)\n\tif err != nil {\n\t\tif errors.Is(err, io.EOF) {\n\t\t\t// The stream ended cleanly. That's expected, but we need to propagate an EOF\n\t\t\t// to the user so that they know that the stream has ended. We shouldn't\n\t\t\t// add any alarming text about protocol errors, though.\n\t\t\treturn NewError(CodeUnknown, err)\n\t\t}\n\t\terr = wrapIfMaxBytesError(err, \"read 5 byte message prefix\")\n\t\terr = wrapIfContextDone(r.ctx, err)\n\t\tif connectErr, ok := asError(err); ok {\n\t\t\treturn connectErr\n\t\t}\n\t\t// Something else has gone wrong - the stream didn't end cleanly.\n\t\treturn errorf(\n\t\t\tCodeInvalidArgument,\n\t\t\t\"protocol error: incomplete envelope: %w\", err,\n\t\t)\n\t}\n\tsize := int64(binary.BigEndian.Uint32(prefixes[1:5]))\n\tif r.readMaxBytes > 0 && size > int64(r.readMaxBytes) {\n\t\tn, err := io.CopyN(io.Discard, r.reader, size)\n\t\tr.bytesRead += n\n\t\tif err != nil && !errors.Is(err, io.EOF) {\n\t\t\treturn errorf(CodeResourceExhausted, \"message is larger than configured max %d - unable to determine message size: %w\", r.readMaxBytes, err)\n\t\t}\n\t\treturn errorf(CodeResourceExhausted, \"message size %d is larger than configured max %d\", size, r.readMaxBytes)\n\t}\n\t// We've read the prefix, so we know how many bytes to expect.\n\t// CopyN will return an error if it doesn't read the requested\n\t// number of bytes.\n\treadN, err := io.CopyN(env.Data, r.reader, size)\n\tr.bytesRead += readN\n\tif err != nil {\n\t\tif errors.Is(err, io.EOF) {\n\t\t\t// We've gotten fewer bytes than we expected, so the stream has ended\n\t\t\t// unexpectedly.\n\t\t\treturn errorf(\n\t\t\t\tCodeInvalidArgument,\n\t\t\t\t\"protocol error: promised %d bytes in enveloped message, got %d bytes\",\n\t\t\t\tsize,\n\t\t\t\treadN,\n\t\t\t)\n\t\t}\n\t\terr = wrapIfMaxBytesError(err, \"read %d byte message\", size)\n\t\terr = wrapIfContextDone(r.ctx, err)\n\t\tif connectErr, ok := asError(err); ok {\n\t\t\treturn connectErr\n\t\t}\n\t\treturn errorf(CodeUnknown, \"read enveloped message: %w\", err)\n\t}\n\tenv.Flags = prefixes[0]\n\treturn nil\n}\n\nfunc makeEnvelopePrefix(flags uint8, size int) [5]byte {\n\tprefix := [5]byte{}\n\tprefix[0] = flags\n\tbinary.BigEndian.PutUint32(prefix[1:5], uint32(size))\n\treturn prefix\n}\n"
        },
        {
          "name": "envelope_test.go",
          "type": "blob",
          "size": 3.107421875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n)\n\nfunc TestEnvelope(t *testing.T) {\n\tt.Parallel()\n\tpayload := []byte(`{\"number\": 42}`)\n\thead := makeEnvelopePrefix(0, len(payload))\n\tbuf := &bytes.Buffer{}\n\tbuf.Write(head[:])\n\tbuf.Write(payload)\n\tt.Run(\"read\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tt.Run(\"full\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tenv := &envelope{Data: &bytes.Buffer{}}\n\t\t\trdr := envelopeReader{\n\t\t\t\treader: bytes.NewReader(buf.Bytes()),\n\t\t\t}\n\t\t\tassert.Nil(t, rdr.Read(env))\n\t\t\tassert.Equal(t, payload, env.Data.Bytes())\n\t\t})\n\t\tt.Run(\"byteByByte\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tenv := &envelope{Data: &bytes.Buffer{}}\n\t\t\trdr := envelopeReader{\n\t\t\t\tctx: context.Background(),\n\t\t\t\treader: byteByByteReader{\n\t\t\t\t\treader: bytes.NewReader(buf.Bytes()),\n\t\t\t\t},\n\t\t\t}\n\t\t\tassert.Nil(t, rdr.Read(env))\n\t\t\tassert.Equal(t, payload, env.Data.Bytes())\n\t\t})\n\t})\n\tt.Run(\"write\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tt.Run(\"full\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tdst := &bytes.Buffer{}\n\t\t\twtr := envelopeWriter{\n\t\t\t\tsender: writeSender{writer: dst},\n\t\t\t}\n\t\t\tenv := &envelope{Data: bytes.NewBuffer(payload)}\n\t\t\terr := wtr.Write(env)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, buf.Bytes(), dst.Bytes())\n\t\t})\n\t\tt.Run(\"partial\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tdst := &bytes.Buffer{}\n\t\t\tenv := &envelope{Data: bytes.NewBuffer(payload)}\n\t\t\t_, err := io.CopyN(dst, env, 2)\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = env.WriteTo(dst)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, buf.Bytes(), dst.Bytes())\n\t\t})\n\t})\n\tt.Run(\"seek\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tt.Run(\"start\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tdst1 := &bytes.Buffer{}\n\t\t\tdst2 := &bytes.Buffer{}\n\t\t\tenv := &envelope{Data: bytes.NewBuffer(payload)}\n\t\t\t_, err := io.CopyN(dst1, env, 2)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, env.Len(), len(payload)+3)\n\t\t\t_, err = env.Seek(0, io.SeekStart)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, env.Len(), len(payload)+5)\n\t\t\t_, err = io.CopyN(dst2, env, 2)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, dst1.Bytes(), dst2.Bytes())\n\t\t\t_, err = env.WriteTo(dst2)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, dst2.Bytes(), buf.Bytes())\n\t\t\tassert.Equal(t, env.Len(), 0)\n\t\t})\n\t})\n}\n\n// byteByByteReader is test reader that reads a single byte at a time.\ntype byteByByteReader struct {\n\treader io.ByteReader\n}\n\nfunc (b byteByByteReader) Read(data []byte) (int, error) {\n\tif len(data) == 0 {\n\t\treturn 0, nil\n\t}\n\tnext, err := b.reader.ReadByte()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdata[0] = next\n\treturn 1, nil\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 16.412109375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/anypb\"\n)\n\nconst (\n\tcommonErrorsURL          = \"https://connectrpc.com/docs/go/common-errors\"\n\tdefaultAnyResolverPrefix = \"type.googleapis.com/\"\n)\n\nvar (\n\t// errNotModified signals Connect-protocol responses to GET requests to use the\n\t// 304 Not Modified HTTP error code.\n\terrNotModified = errors.New(\"not modified\")\n\t// errNotModifiedClient wraps ErrNotModified for use client-side.\n\terrNotModifiedClient = fmt.Errorf(\"HTTP 304: %w\", errNotModified)\n)\n\n// An ErrorDetail is a self-describing Protobuf message attached to an [*Error].\n// Error details are sent over the network to clients, which can then work with\n// strongly-typed data rather than trying to parse a complex error message. For\n// example, you might use details to send a localized error message or retry\n// parameters to the client.\n//\n// The [google.golang.org/genproto/googleapis/rpc/errdetails] package contains a\n// variety of Protobuf messages commonly used as error details.\ntype ErrorDetail struct {\n\tpbAny    *anypb.Any\n\tpbInner  proto.Message // if nil, must be extracted from pbAny\n\twireJSON string        // preserve human-readable JSON\n}\n\n// NewErrorDetail constructs a new error detail. If msg is an *[anypb.Any] then\n// it is used as is. Otherwise, it is first marshalled into an *[anypb.Any]\n// value. This returns an error if msg cannot be marshalled.\nfunc NewErrorDetail(msg proto.Message) (*ErrorDetail, error) {\n\t// If it's already an Any, don't wrap it inside another.\n\tif pb, ok := msg.(*anypb.Any); ok {\n\t\treturn &ErrorDetail{pbAny: pb}, nil\n\t}\n\tpb, err := anypb.New(msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ErrorDetail{pbAny: pb, pbInner: msg}, nil\n}\n\n// Type is the fully-qualified name of the detail's Protobuf message (for\n// example, acme.foo.v1.FooDetail).\nfunc (d *ErrorDetail) Type() string {\n\t// proto.Any tries to make messages self-describing by using type URLs rather\n\t// than plain type names, but there aren't any descriptor registries\n\t// deployed. With the current state of the `Any` code, it's not possible to\n\t// build a useful type registry either. To hide this from users, we should\n\t// trim the URL prefix is added to the type name.\n\t//\n\t// If we ever want to support remote registries, we can add an explicit\n\t// `TypeURL` method.\n\treturn typeNameFromURL(d.pbAny.GetTypeUrl())\n}\n\n// Bytes returns a copy of the Protobuf-serialized detail.\nfunc (d *ErrorDetail) Bytes() []byte {\n\tout := make([]byte, len(d.pbAny.GetValue()))\n\tcopy(out, d.pbAny.GetValue())\n\treturn out\n}\n\n// Value uses the Protobuf runtime's package-global registry to unmarshal the\n// Detail into a strongly-typed message. Typically, clients use Go type\n// assertions to cast from the proto.Message interface to concrete types.\nfunc (d *ErrorDetail) Value() (proto.Message, error) {\n\tif d.pbInner != nil {\n\t\t// We clone it so that if the caller mutates the returned value,\n\t\t// they don't inadvertently corrupt this error detail value.\n\t\treturn proto.Clone(d.pbInner), nil\n\t}\n\treturn d.pbAny.UnmarshalNew()\n}\n\n// An Error captures four key pieces of information: a [Code], an underlying Go\n// error, a map of metadata, and an optional collection of arbitrary Protobuf\n// messages called \"details\" (more on those below). Servers send the code, the\n// underlying error's Error() output, the metadata, and details over the wire\n// to clients. Remember that the underlying error's message will be sent to\n// clients - take care not to leak sensitive information from public APIs!\n//\n// Service implementations and interceptors should return errors that can be\n// cast to an [*Error] (using the standard library's [errors.As]). If the returned\n// error can't be cast to an [*Error], connect will use [CodeUnknown] and the\n// returned error's message.\n//\n// Error details are an optional mechanism for servers, interceptors, and\n// proxies to attach arbitrary Protobuf messages to the error code and message.\n// They're a clearer and more performant alternative to HTTP header\n// microformats. See [the documentation on errors] for more details.\n//\n// [the documentation on errors]: https://connectrpc.com/docs/go/errors\ntype Error struct {\n\tcode    Code\n\terr     error\n\tdetails []*ErrorDetail\n\tmeta    http.Header\n\twireErr bool\n}\n\n// NewError annotates any Go error with a status code.\nfunc NewError(c Code, underlying error) *Error {\n\treturn &Error{code: c, err: underlying}\n}\n\n// NewWireError is similar to [NewError], but the resulting *Error returns true\n// when tested with [IsWireError].\n//\n// This is useful for clients trying to propagate partial failures from\n// streaming RPCs. Often, these RPCs include error information in their\n// response messages (for example, [gRPC server reflection] and\n// OpenTelemetry's [OTLP]). Clients propagating these errors up the stack\n// should use NewWireError to clarify that the error code, message, and details\n// (if any) were explicitly sent by the server rather than inferred from a\n// lower-level networking error or timeout.\n//\n// [gRPC server reflection]: https://github.com/grpc/grpc/blob/v1.49.2/src/proto/grpc/reflection/v1alpha/reflection.proto#L132-L136\n// [OTLP]: https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md#partial-success\nfunc NewWireError(c Code, underlying error) *Error {\n\terr := NewError(c, underlying)\n\terr.wireErr = true\n\treturn err\n}\n\n// IsWireError checks whether the error was returned by the server, as opposed\n// to being synthesized by the client.\n//\n// Clients may find this useful when deciding how to propagate errors. For\n// example, an RPC-to-HTTP proxy might expose a server-sent CodeUnknown as an\n// HTTP 500 but a client-synthesized CodeUnknown as a 503.\n//\n// Handlers will strip [Error.Meta] headers propagated from wire errors to avoid\n// leaking response headers. To propagate headers recreate the error as a\n// non-wire error.\nfunc IsWireError(err error) bool {\n\tse := new(Error)\n\tif !errors.As(err, &se) {\n\t\treturn false\n\t}\n\treturn se.wireErr\n}\n\n// NewNotModifiedError indicates that the requested resource hasn't changed. It\n// should be used only when handlers wish to respond to conditional HTTP GET\n// requests with a 304 Not Modified. In all other circumstances, including all\n// RPCs using the gRPC or gRPC-Web protocols, it's equivalent to sending an\n// error with [CodeUnknown]. The supplied headers should include Etag,\n// Cache-Control, or any other headers required by [RFC 9110 § 15.4.5].\n//\n// Clients should check for this error using [IsNotModifiedError].\n//\n// [RFC 9110 § 15.4.5]: https://httpwg.org/specs/rfc9110.html#status.304\nfunc NewNotModifiedError(headers http.Header) *Error {\n\terr := NewError(CodeUnknown, errNotModified)\n\tif headers != nil {\n\t\terr.meta = headers\n\t}\n\treturn err\n}\n\nfunc (e *Error) Error() string {\n\tmessage := e.Message()\n\tif message == \"\" {\n\t\treturn e.code.String()\n\t}\n\treturn e.code.String() + \": \" + message\n}\n\n// Message returns the underlying error message. It may be empty if the\n// original error was created with a status code and a nil error.\nfunc (e *Error) Message() string {\n\tif e.err != nil {\n\t\treturn e.err.Error()\n\t}\n\treturn \"\"\n}\n\n// Unwrap allows [errors.Is] and [errors.As] access to the underlying error.\nfunc (e *Error) Unwrap() error {\n\treturn e.err\n}\n\n// Code returns the error's status code.\nfunc (e *Error) Code() Code {\n\treturn e.code\n}\n\n// Details returns the error's details.\nfunc (e *Error) Details() []*ErrorDetail {\n\treturn e.details\n}\n\n// AddDetail appends to the error's details.\nfunc (e *Error) AddDetail(d *ErrorDetail) {\n\te.details = append(e.details, d)\n}\n\n// Meta allows the error to carry additional information as key-value pairs.\n//\n// Metadata attached to errors returned by unary handlers is always sent as\n// HTTP headers, regardless of the protocol. Metadata attached to errors\n// returned by streaming handlers may be sent as HTTP headers, HTTP trailers,\n// or a block of in-body metadata, depending on the protocol in use and whether\n// or not the handler has already written messages to the stream.\n//\n// Protocol-specific headers and trailers may be removed to avoid breaking\n// protocol semantics. For example, Content-Length and Content-Type headers\n// won't be propagated. See the documentation for each protocol for more\n// datails.\n//\n// When clients receive errors, the metadata contains the union of the HTTP\n// headers and the protocol-specific trailers (either HTTP trailers or in-body\n// metadata).\nfunc (e *Error) Meta() http.Header {\n\tif e.meta == nil {\n\t\te.meta = make(http.Header)\n\t}\n\treturn e.meta\n}\n\nfunc (e *Error) detailsAsAny() []*anypb.Any {\n\tanys := make([]*anypb.Any, 0, len(e.details))\n\tfor _, detail := range e.details {\n\t\tanys = append(anys, detail.pbAny)\n\t}\n\treturn anys\n}\n\n// IsNotModifiedError checks whether the supplied error indicates that the\n// requested resource hasn't changed. It only returns true if the server used\n// [NewNotModifiedError] in response to a Connect-protocol RPC made with an\n// HTTP GET.\nfunc IsNotModifiedError(err error) bool {\n\treturn errors.Is(err, errNotModified)\n}\n\n// errorf calls fmt.Errorf with the supplied template and arguments, then wraps\n// the resulting error.\nfunc errorf(c Code, template string, args ...any) *Error {\n\treturn NewError(c, fmt.Errorf(template, args...))\n}\n\n// asError uses errors.As to unwrap any error and look for a connect *Error.\nfunc asError(err error) (*Error, bool) {\n\tvar connectErr *Error\n\tok := errors.As(err, &connectErr)\n\treturn connectErr, ok\n}\n\n// wrapIfUncoded ensures that all errors are wrapped. It leaves already-wrapped\n// errors unchanged, uses wrapIfContextError to apply codes to context.Canceled\n// and context.DeadlineExceeded, and falls back to wrapping other errors with\n// CodeUnknown.\nfunc wrapIfUncoded(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tmaybeCodedErr := wrapIfContextError(err)\n\tif _, ok := asError(maybeCodedErr); ok {\n\t\treturn maybeCodedErr\n\t}\n\treturn NewError(CodeUnknown, maybeCodedErr)\n}\n\n// wrapIfContextError applies CodeCanceled or CodeDeadlineExceeded to Go's\n// context.Canceled and context.DeadlineExceeded errors, but only if they\n// haven't already been wrapped.\nfunc wrapIfContextError(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif _, ok := asError(err); ok {\n\t\treturn err\n\t}\n\tif errors.Is(err, context.Canceled) {\n\t\treturn NewError(CodeCanceled, err)\n\t}\n\tif errors.Is(err, context.DeadlineExceeded) {\n\t\treturn NewError(CodeDeadlineExceeded, err)\n\t}\n\t// Ick, some dial errors can be returned as os.ErrDeadlineExceeded\n\t// instead of context.DeadlineExceeded :(\n\t// https://github.com/golang/go/issues/64449\n\tif errors.Is(err, os.ErrDeadlineExceeded) {\n\t\treturn NewError(CodeDeadlineExceeded, err)\n\t}\n\treturn err\n}\n\n// wrapIfContextDone wraps errors with CodeCanceled or CodeDeadlineExceeded\n// if the context is done. It leaves already-wrapped errors unchanged.\nfunc wrapIfContextDone(ctx context.Context, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\terr = wrapIfContextError(err)\n\tif _, ok := asError(err); ok {\n\t\treturn err\n\t}\n\tctxErr := ctx.Err()\n\tif errors.Is(ctxErr, context.Canceled) {\n\t\treturn NewError(CodeCanceled, err)\n\t} else if errors.Is(ctxErr, context.DeadlineExceeded) {\n\t\treturn NewError(CodeDeadlineExceeded, err)\n\t}\n\treturn err\n}\n\n// wrapIfLikelyH2CNotConfiguredError adds a wrapping error that has a message\n// telling the caller that they likely need to use h2c but are using a raw http.Client{}.\n//\n// This happens when running a gRPC-only server.\n// This is fragile and may break over time, and this should be considered a best-effort.\nfunc wrapIfLikelyH2CNotConfiguredError(request *http.Request, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif _, ok := asError(err); ok {\n\t\treturn err\n\t}\n\tif url := request.URL; url != nil && url.Scheme != \"http\" {\n\t\t// If the scheme is not http, we definitely do not have an h2c error, so just return.\n\t\treturn err\n\t}\n\t// net/http code has been investigated and there is no typing of any of these errors\n\t// they are all created with fmt.Errorf\n\t// grpc-go returns the first error 2/3-3/4 of the time, and the second error 1/4-1/3 of the time\n\tif errString := err.Error(); strings.HasPrefix(errString, `Post \"`) &&\n\t\t(strings.Contains(errString, `net/http: HTTP/1.x transport connection broken: malformed HTTP response`) ||\n\t\t\tstrings.HasSuffix(errString, `write: broken pipe`)) {\n\t\treturn fmt.Errorf(\"possible h2c configuration issue when talking to gRPC server, see %s: %w\", commonErrorsURL, err)\n\t}\n\treturn err\n}\n\n// wrapIfLikelyWithGRPCNotUsedError adds a wrapping error that has a message\n// telling the caller that they likely forgot to use connect.WithGRPC().\n//\n// This happens when running a gRPC-only server.\n// This is fragile and may break over time, and this should be considered a best-effort.\nfunc wrapIfLikelyWithGRPCNotUsedError(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif _, ok := asError(err); ok {\n\t\treturn err\n\t}\n\t// golang.org/x/net code has been investigated and there is no typing of this error\n\t// it is created with fmt.Errorf\n\t// http2/transport.go:573:\treturn nil, fmt.Errorf(\"http2: Transport: cannot retry err [%v] after Request.Body was written; define Request.GetBody to avoid this error\", err)\n\tif errString := err.Error(); strings.HasPrefix(errString, `Post \"`) &&\n\t\tstrings.Contains(errString, `http2: Transport: cannot retry err`) &&\n\t\tstrings.HasSuffix(errString, `after Request.Body was written; define Request.GetBody to avoid this error`) {\n\t\treturn fmt.Errorf(\"possible missing connect.WithGPRC() client option when talking to gRPC server, see %s: %w\", commonErrorsURL, err)\n\t}\n\treturn err\n}\n\n// HTTP/2 has its own set of error codes, which it sends in RST_STREAM frames.\n// When the server sends one of these errors, we should map it back into our\n// RPC error codes following\n// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#http2-transport-mapping.\n//\n// This would be vastly simpler if we were using x/net/http2 directly, since\n// the StreamError type is exported. When x/net/http2 gets vendored into\n// net/http, though, all these types become unexported...so we're left with\n// string munging.\nfunc wrapIfRSTError(err error) error {\n\tconst (\n\t\tstreamErrPrefix = \"stream error: \"\n\t\tfromPeerSuffix  = \"; received from peer\"\n\t)\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif _, ok := asError(err); ok {\n\t\treturn err\n\t}\n\tif urlErr := new(url.Error); errors.As(err, &urlErr) {\n\t\t// If we get an RST_STREAM error from http.Client.Do, it's wrapped in a\n\t\t// *url.Error.\n\t\terr = urlErr.Unwrap()\n\t}\n\tmsg := err.Error()\n\tif !strings.HasPrefix(msg, streamErrPrefix) {\n\t\treturn err\n\t}\n\tif !strings.HasSuffix(msg, fromPeerSuffix) {\n\t\treturn err\n\t}\n\tmsg = strings.TrimSuffix(msg, fromPeerSuffix)\n\ti := strings.LastIndex(msg, \";\")\n\tif i < 0 || i >= len(msg)-1 {\n\t\treturn err\n\t}\n\tmsg = msg[i+1:]\n\tmsg = strings.TrimSpace(msg)\n\tswitch msg {\n\tcase \"NO_ERROR\", \"PROTOCOL_ERROR\", \"INTERNAL_ERROR\", \"FLOW_CONTROL_ERROR\",\n\t\t\"SETTINGS_TIMEOUT\", \"FRAME_SIZE_ERROR\", \"COMPRESSION_ERROR\", \"CONNECT_ERROR\":\n\t\treturn NewError(CodeInternal, err)\n\tcase \"REFUSED_STREAM\":\n\t\treturn NewError(CodeUnavailable, err)\n\tcase \"CANCEL\":\n\t\treturn NewError(CodeCanceled, err)\n\tcase \"ENHANCE_YOUR_CALM\":\n\t\treturn NewError(CodeResourceExhausted, fmt.Errorf(\"bandwidth exhausted: %w\", err))\n\tcase \"INADEQUATE_SECURITY\":\n\t\treturn NewError(CodePermissionDenied, fmt.Errorf(\"transport protocol insecure: %w\", err))\n\tdefault:\n\t\treturn err\n\t}\n}\n\n// wrapIfMaxBytesError wraps errors returned reading from a http.MaxBytesHandler\n// whose limit has been exceeded.\nfunc wrapIfMaxBytesError(err error, tmpl string, args ...any) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif _, ok := asError(err); ok {\n\t\treturn err\n\t}\n\tvar maxBytesErr *http.MaxBytesError\n\tif ok := errors.As(err, &maxBytesErr); !ok {\n\t\treturn err\n\t}\n\tprefix := fmt.Sprintf(tmpl, args...)\n\treturn errorf(CodeResourceExhausted, \"%s: exceeded %d byte http.MaxBytesReader limit\", prefix, maxBytesErr.Limit)\n}\n\nfunc typeNameFromURL(url string) string {\n\treturn url[strings.LastIndexByte(url, '/')+1:]\n}\n"
        },
        {
          "name": "error_example_test.go",
          "type": "blob",
          "size": 2.1005859375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\n\tconnect \"connectrpc.com/connect\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n)\n\nfunc ExampleError_Message() {\n\terr := fmt.Errorf(\n\t\t\"another: %w\",\n\t\tconnect.NewError(connect.CodeUnavailable, errors.New(\"failed to foo\")),\n\t)\n\tif connectErr := (&connect.Error{}); errors.As(err, &connectErr) {\n\t\tfmt.Println(\"underlying error message:\", connectErr.Message())\n\t}\n\n\t// Output:\n\t// underlying error message: failed to foo\n}\n\nfunc ExampleIsNotModifiedError() {\n\t// Assume that the server from NewNotModifiedError's example is running on\n\t// localhost:8080.\n\tclient := pingv1connect.NewPingServiceClient(\n\t\thttp.DefaultClient,\n\t\t\"http://localhost:8080\",\n\t\t// Enable client-side support for HTTP GETs.\n\t\tconnect.WithHTTPGet(),\n\t)\n\treq := connect.NewRequest(&pingv1.PingRequest{Number: 42})\n\tfirst, err := client.Ping(context.Background(), req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\t// If the server set an Etag, we can use it to cache the response.\n\tetag := first.Header().Get(\"Etag\")\n\tif etag == \"\" {\n\t\tfmt.Println(\"no Etag in response headers\")\n\t\treturn\n\t}\n\tfmt.Println(\"cached response with Etag\", etag)\n\t// Now we'd like to make the same request again, but avoid re-fetching the\n\t// response if possible.\n\treq.Header().Set(\"If-None-Match\", etag)\n\t_, err = client.Ping(context.Background(), req)\n\tif connect.IsNotModifiedError(err) {\n\t\tfmt.Println(\"can reuse cached response\")\n\t}\n}\n"
        },
        {
          "name": "error_not_modified_example_test.go",
          "type": "blob",
          "size": 2.20703125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strconv\"\n\n\tconnect \"connectrpc.com/connect\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n)\n\n// ExampleCachingServer is an example of how servers can take advantage the\n// Connect protocol's support for HTTP-level caching. The Protobuf\n// definition for this API is in proto/connect/ping/v1/ping.proto.\ntype ExampleCachingPingServer struct {\n\tpingv1connect.UnimplementedPingServiceHandler\n}\n\n// Ping is idempotent and free of side effects (and the Protobuf schema\n// indicates this), so clients using the Connect protocol may call it with HTTP\n// GET requests. This implementation uses Etags to manage client-side caching.\nfunc (*ExampleCachingPingServer) Ping(\n\t_ context.Context,\n\treq *connect.Request[pingv1.PingRequest],\n) (*connect.Response[pingv1.PingResponse], error) {\n\tresp := connect.NewResponse(&pingv1.PingResponse{\n\t\tNumber: req.Msg.GetNumber(),\n\t})\n\t// Our hashing logic is simple: we use the number in the PingResponse.\n\thash := strconv.FormatInt(resp.Msg.GetNumber(), 10)\n\t// If the request was an HTTP GET, we'll need to check if the client already\n\t// has the response cached.\n\tif req.HTTPMethod() == http.MethodGet && req.Header().Get(\"If-None-Match\") == hash {\n\t\treturn nil, connect.NewNotModifiedError(http.Header{\n\t\t\t\"Etag\": []string{hash},\n\t\t})\n\t}\n\tresp.Header().Set(\"Etag\", hash)\n\treturn resp, nil\n}\n\nfunc ExampleNewNotModifiedError() {\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(&ExampleCachingPingServer{}))\n\t_ = http.ListenAndServe(\"localhost:8080\", mux)\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 4.2236328125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/durationpb\"\n\t\"google.golang.org/protobuf/types/known/emptypb\"\n)\n\nfunc TestErrorNilUnderlying(t *testing.T) {\n\tt.Parallel()\n\terr := NewError(CodeUnknown, nil)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, err.Error(), CodeUnknown.String())\n\tassert.Equal(t, err.Code(), CodeUnknown)\n\tassert.Zero(t, err.Details())\n\tdetail, detailErr := NewErrorDetail(&emptypb.Empty{})\n\tassert.Nil(t, detailErr)\n\terr.AddDetail(detail)\n\tassert.Equal(t, len(err.Details()), 1)\n\tassert.Equal(t, err.Details()[0].Type(), \"google.protobuf.Empty\")\n\terr.Meta().Set(\"Foo\", \"bar\")\n\tassert.Equal(t, err.Meta().Get(\"Foo\"), \"bar\")\n\tassert.Equal(t, CodeOf(err), CodeUnknown)\n}\n\nfunc TestErrorFormatting(t *testing.T) {\n\tt.Parallel()\n\tassert.Equal(\n\t\tt,\n\t\tNewError(CodeUnavailable, errors.New(\"\")).Error(),\n\t\tCodeUnavailable.String(),\n\t)\n\tgot := NewError(CodeUnavailable, errors.New(\"Foo\")).Error()\n\tassert.True(t, strings.Contains(got, CodeUnavailable.String()))\n\tassert.True(t, strings.Contains(got, \"Foo\"))\n}\n\nfunc TestErrorCode(t *testing.T) {\n\tt.Parallel()\n\terr := fmt.Errorf(\n\t\t\"another: %w\",\n\t\tNewError(CodeUnavailable, errors.New(\"foo\")),\n\t)\n\tconnectErr, ok := asError(err)\n\tassert.True(t, ok)\n\tassert.Equal(t, connectErr.Code(), CodeUnavailable)\n}\n\nfunc TestCodeOf(t *testing.T) {\n\tt.Parallel()\n\tassert.Equal(\n\t\tt,\n\t\tCodeOf(NewError(CodeUnavailable, errors.New(\"foo\"))),\n\t\tCodeUnavailable,\n\t)\n\tassert.Equal(t, CodeOf(errors.New(\"foo\")), CodeUnknown)\n}\n\nfunc TestErrorDetails(t *testing.T) {\n\tt.Parallel()\n\tsecond := durationpb.New(time.Second)\n\tdetail, err := NewErrorDetail(second)\n\tassert.Nil(t, err)\n\tconnectErr := NewError(CodeUnknown, errors.New(\"error with details\"))\n\tassert.Zero(t, connectErr.Details())\n\tconnectErr.AddDetail(detail)\n\tassert.Equal(t, len(connectErr.Details()), 1)\n\tunmarshaled, err := connectErr.Details()[0].Value()\n\tassert.Nil(t, err)\n\tassert.Equal(t, unmarshaled, proto.Message(second))\n\tsecondBin, err := proto.Marshal(second)\n\tassert.Nil(t, err)\n\tassert.Equal(t, detail.Bytes(), secondBin)\n}\n\nfunc TestErrorIs(t *testing.T) {\n\tt.Parallel()\n\t// errors.New and fmt.Errorf return *errors.errorString. errors.Is\n\t// considers two *errors.errorStrings equal iff they have the same address.\n\terr := errors.New(\"oh no\")\n\tassert.False(t, errors.Is(err, errors.New(\"oh no\")))\n\tassert.True(t, errors.Is(err, err))\n\t// Our errors should have the same semantics. Note that we'd need to extend\n\t// the ErrorDetail interface to support value equality.\n\tconnectErr := NewError(CodeUnavailable, err)\n\tassert.False(t, errors.Is(connectErr, NewError(CodeUnavailable, err)))\n\tassert.True(t, errors.Is(connectErr, connectErr))\n}\n\nfunc TestTypeNameFromURL(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tname     string\n\t\turl      string\n\t\ttypeName string\n\t}{\n\t\t{\n\t\t\tname:     \"no-prefix\",\n\t\t\turl:      \"foo.bar.Baz\",\n\t\t\ttypeName: \"foo.bar.Baz\",\n\t\t},\n\t\t{\n\t\t\tname:     \"standard-prefix\",\n\t\t\turl:      defaultAnyResolverPrefix + \"foo.bar.Baz\",\n\t\t\ttypeName: \"foo.bar.Baz\",\n\t\t},\n\t\t{\n\t\t\tname:     \"different-hostname\",\n\t\t\turl:      \"abc.com/foo.bar.Baz\",\n\t\t\ttypeName: \"foo.bar.Baz\",\n\t\t},\n\t\t{\n\t\t\tname:     \"additional-path-elements\",\n\t\t\turl:      defaultAnyResolverPrefix + \"abc/def/foo.bar.Baz\",\n\t\t\ttypeName: \"foo.bar.Baz\",\n\t\t},\n\t\t{\n\t\t\tname:     \"full-url\",\n\t\t\turl:      \"https://abc.com/abc/def/foo.bar.Baz\",\n\t\t\ttypeName: \"foo.bar.Baz\",\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tassert.Equal(t, typeNameFromURL(testCase.url), testCase.typeName)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "error_writer.go",
          "type": "blob",
          "size": 6.8056640625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// protocolType is one of the supported RPC protocols.\ntype protocolType uint8\n\nconst (\n\tunknownProtocol protocolType = iota\n\tconnectUnaryProtocol\n\tconnectStreamProtocol\n\tgrpcProtocol\n\tgrpcWebProtocol\n)\n\n// An ErrorWriter writes errors to an [http.ResponseWriter] in the format\n// expected by an RPC client. This is especially useful in server-side net/http\n// middleware, where you may wish to handle requests from RPC and non-RPC\n// clients with the same code.\n//\n// ErrorWriters are safe to use concurrently.\ntype ErrorWriter struct {\n\tbufferPool                   *bufferPool\n\tprotobuf                     Codec\n\trequireConnectProtocolHeader bool\n}\n\n// NewErrorWriter constructs an ErrorWriter. Handler options may be passed to\n// configure the error writer behaviour to match the handlers.\n// [WithRequiredConnectProtocolHeader] will assert that Connect protocol\n// requests include the version header allowing the error writer to correctly\n// classify the request.\n// Options supplied via [WithConditionalHandlerOptions] are ignored.\nfunc NewErrorWriter(opts ...HandlerOption) *ErrorWriter {\n\tconfig := newHandlerConfig(\"\", StreamTypeUnary, opts)\n\tcodecs := newReadOnlyCodecs(config.Codecs)\n\treturn &ErrorWriter{\n\t\tbufferPool:                   config.BufferPool,\n\t\tprotobuf:                     codecs.Protobuf(),\n\t\trequireConnectProtocolHeader: config.RequireConnectProtocolHeader,\n\t}\n}\n\nfunc (w *ErrorWriter) classifyRequest(request *http.Request) protocolType {\n\tctype := canonicalizeContentType(getHeaderCanonical(request.Header, headerContentType))\n\tisPost := request.Method == http.MethodPost\n\tisGet := request.Method == http.MethodGet\n\tswitch {\n\tcase isPost && (ctype == grpcContentTypeDefault || strings.HasPrefix(ctype, grpcContentTypePrefix)):\n\t\treturn grpcProtocol\n\tcase isPost && (ctype == grpcWebContentTypeDefault || strings.HasPrefix(ctype, grpcWebContentTypePrefix)):\n\t\treturn grpcWebProtocol\n\tcase isPost && strings.HasPrefix(ctype, connectStreamingContentTypePrefix):\n\t\t// Streaming ignores the requireConnectProtocolHeader option as the\n\t\t// Content-Type is enough to determine the protocol.\n\t\tif err := connectCheckProtocolVersion(request, false /* required */); err != nil {\n\t\t\treturn unknownProtocol\n\t\t}\n\t\treturn connectStreamProtocol\n\tcase isPost && strings.HasPrefix(ctype, connectUnaryContentTypePrefix):\n\t\tif err := connectCheckProtocolVersion(request, w.requireConnectProtocolHeader); err != nil {\n\t\t\treturn unknownProtocol\n\t\t}\n\t\treturn connectUnaryProtocol\n\tcase isGet:\n\t\tif err := connectCheckProtocolVersion(request, w.requireConnectProtocolHeader); err != nil {\n\t\t\treturn unknownProtocol\n\t\t}\n\t\treturn connectUnaryProtocol\n\tdefault:\n\t\treturn unknownProtocol\n\t}\n}\n\n// IsSupported checks whether a request is using one of the ErrorWriter's\n// supported RPC protocols.\nfunc (w *ErrorWriter) IsSupported(request *http.Request) bool {\n\treturn w.classifyRequest(request) != unknownProtocol\n}\n\n// Write an error, using the format appropriate for the RPC protocol in use.\n// Callers should first use IsSupported to verify that the request is using one\n// of the ErrorWriter's supported RPC protocols. If the protocol is unknown,\n// Write will send the error as unprefixed, Connect-formatted JSON.\n//\n// Write does not read or close the request body.\nfunc (w *ErrorWriter) Write(response http.ResponseWriter, request *http.Request, err error) error {\n\tctype := canonicalizeContentType(getHeaderCanonical(request.Header, headerContentType))\n\tswitch protocolType := w.classifyRequest(request); protocolType {\n\tcase connectStreamProtocol:\n\t\tsetHeaderCanonical(response.Header(), headerContentType, ctype)\n\t\treturn w.writeConnectStreaming(response, err)\n\tcase grpcProtocol:\n\t\tsetHeaderCanonical(response.Header(), headerContentType, ctype)\n\t\treturn w.writeGRPC(response, err)\n\tcase grpcWebProtocol:\n\t\tsetHeaderCanonical(response.Header(), headerContentType, ctype)\n\t\treturn w.writeGRPCWeb(response, err)\n\tcase unknownProtocol, connectUnaryProtocol:\n\t\tfallthrough\n\tdefault:\n\t\t// Unary errors are always JSON. Unknown protocols are treated as unary\n\t\t// because they are likely to be Connect clients and will still be able to\n\t\t// parse the error as it's in a human-readable format.\n\t\tsetHeaderCanonical(response.Header(), headerContentType, connectUnaryContentTypeJSON)\n\t\treturn w.writeConnectUnary(response, err)\n\t}\n}\n\nfunc (w *ErrorWriter) writeConnectUnary(response http.ResponseWriter, err error) error {\n\tif connectErr, ok := asError(err); ok && !connectErr.wireErr {\n\t\tmergeNonProtocolHeaders(response.Header(), connectErr.meta)\n\t}\n\tresponse.WriteHeader(connectCodeToHTTP(CodeOf(err)))\n\tdata, marshalErr := json.Marshal(newConnectWireError(err))\n\tif marshalErr != nil {\n\t\treturn fmt.Errorf(\"marshal error: %w\", marshalErr)\n\t}\n\t_, writeErr := response.Write(data)\n\treturn writeErr\n}\n\nfunc (w *ErrorWriter) writeConnectStreaming(response http.ResponseWriter, err error) error {\n\tresponse.WriteHeader(http.StatusOK)\n\tmarshaler := &connectStreamingMarshaler{\n\t\tenvelopeWriter: envelopeWriter{\n\t\t\tsender:     writeSender{writer: response},\n\t\t\tbufferPool: w.bufferPool,\n\t\t},\n\t}\n\t// MarshalEndStream returns *Error: check return value to avoid typed nils.\n\tif marshalErr := marshaler.MarshalEndStream(err, make(http.Header)); marshalErr != nil {\n\t\treturn marshalErr\n\t}\n\treturn nil\n}\n\nfunc (w *ErrorWriter) writeGRPC(response http.ResponseWriter, err error) error {\n\ttrailers := make(http.Header, 2) // need space for at least code & message\n\tgrpcErrorToTrailer(trailers, w.protobuf, err)\n\t// To make net/http reliably send trailers without a body, we must set the\n\t// Trailers header rather than using http.TrailerPrefix. See\n\t// https://github.com/golang/go/issues/54723.\n\tkeys := make([]string, 0, len(trailers))\n\tfor k := range trailers {\n\t\tkeys = append(keys, k)\n\t}\n\tsetHeaderCanonical(response.Header(), headerTrailer, strings.Join(keys, \",\"))\n\tresponse.WriteHeader(http.StatusOK)\n\tmergeHeaders(response.Header(), trailers)\n\treturn nil\n}\n\nfunc (w *ErrorWriter) writeGRPCWeb(response http.ResponseWriter, err error) error {\n\t// This is a trailers-only response. To match the behavior of Envoy and\n\t// protocol_grpc.go, put the trailers in the HTTP headers.\n\tgrpcErrorToTrailer(response.Header(), w.protobuf, err)\n\tresponse.WriteHeader(http.StatusOK)\n\treturn nil\n}\n"
        },
        {
          "name": "error_writer_example_test.go",
          "type": "blob",
          "size": 2.2470703125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\n\tconnect \"connectrpc.com/connect\"\n)\n\n// NewHelloHandler is an example HTTP handler. In a real application, it might\n// handle RPCs, requests for HTML, or anything else.\nfunc NewHelloHandler() http.Handler {\n\treturn http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {\n\t\tio.WriteString(response, \"Hello, world!\")\n\t})\n}\n\n// NewAuthenticatedHandler is an example of middleware that works with both RPC\n// and non-RPC clients.\nfunc NewAuthenticatedHandler(handler http.Handler) http.Handler {\n\terrorWriter := connect.NewErrorWriter()\n\treturn http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {\n\t\t// Dummy authentication logic.\n\t\tif request.Header.Get(\"Token\") == \"super-secret\" {\n\t\t\thandler.ServeHTTP(response, request)\n\t\t\treturn\n\t\t}\n\t\tdefer request.Body.Close()\n\t\tdefer io.Copy(io.Discard, request.Body)\n\t\tif errorWriter.IsSupported(request) {\n\t\t\t// Send a protocol-appropriate error to RPC clients, so that they receive\n\t\t\t// the right code, message, and any metadata or error details.\n\t\t\tunauthenticated := connect.NewError(connect.CodeUnauthenticated, errors.New(\"invalid token\"))\n\t\t\terrorWriter.Write(response, request, unauthenticated)\n\t\t} else {\n\t\t\t// Send an error to non-RPC clients.\n\t\t\tresponse.WriteHeader(http.StatusUnauthorized)\n\t\t\tio.WriteString(response, \"invalid token\")\n\t\t}\n\t})\n}\n\nfunc ExampleErrorWriter() {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", NewHelloHandler())\n\tsrv := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: NewAuthenticatedHandler(mux),\n\t}\n\tif err := srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {\n\t\tlog.Fatalln(err)\n\t}\n}\n"
        },
        {
          "name": "error_writer_test.go",
          "type": "blob",
          "size": 4.6064453125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n)\n\nfunc TestErrorWriter(t *testing.T) {\n\tt.Parallel()\n\tt.Run(\"RequireConnectProtocolHeader\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twriter := NewErrorWriter(WithRequireConnectProtocolHeader())\n\t\tt.Run(\"Unary\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", connectUnaryContentTypePrefix+codecNameJSON)\n\t\t\tassert.False(t, writer.IsSupported(req))\n\t\t\treq.Header.Set(connectHeaderProtocolVersion, connectProtocolVersion)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t\tt.Run(\"UnaryGET\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"http://localhost\", nil)\n\t\t\tassert.False(t, writer.IsSupported(req))\n\t\t\tquery := req.URL.Query()\n\t\t\tquery.Set(connectUnaryConnectQueryParameter, connectUnaryConnectQueryValue)\n\t\t\treq.URL.RawQuery = query.Encode()\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t\tt.Run(\"Stream\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", connectStreamingContentTypePrefix+codecNameJSON)\n\t\t\tassert.True(t, writer.IsSupported(req)) // ignores WithRequireConnectProtocolHeader\n\t\t\treq.Header.Set(connectHeaderProtocolVersion, connectProtocolVersion)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t})\n\tt.Run(\"Protocols\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twriter := NewErrorWriter() // All supported by default\n\t\tt.Run(\"ConnectUnary\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", connectUnaryContentTypePrefix+codecNameJSON)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t\tt.Run(\"ConnectUnaryGET\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"http://localhost\", nil)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t\tt.Run(\"ConnectStream\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", connectStreamingContentTypePrefix+codecNameJSON)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t\tt.Run(\"GRPC\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", grpcContentTypeDefault)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t\treq.Header.Set(\"Content-Type\", grpcContentTypePrefix+\"json\")\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t\tt.Run(\"GRPCWeb\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", grpcWebContentTypeDefault)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t\treq.Header.Set(\"Content-Type\", grpcWebContentTypePrefix+\"json\")\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t})\n\tt.Run(\"UnknownCodec\", func(t *testing.T) {\n\t\t// An Unknown codec should return supported as the protocol is known and\n\t\t// the error codec is agnostic to the codec used. The server can respond\n\t\t// with a protocol error for the unknown codec.\n\t\tt.Parallel()\n\t\twriter := NewErrorWriter()\n\t\tunknownCodec := \"invalid\"\n\t\tt.Run(\"ConnectUnary\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", connectUnaryContentTypePrefix+unknownCodec)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t\tt.Run(\"ConnectStream\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", connectStreamingContentTypePrefix+unknownCodec)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t\tt.Run(\"GRPC\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", grpcContentTypePrefix+unknownCodec)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t\tt.Run(\"GRPCWeb\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodPost, \"http://localhost\", nil)\n\t\t\treq.Header.Set(\"Content-Type\", grpcWebContentTypePrefix+unknownCodec)\n\t\t\tassert.True(t, writer.IsSupported(req))\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "example_init_test.go",
          "type": "blob",
          "size": 1.2470703125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"net/http\"\n\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n\t\"connectrpc.com/connect/internal/memhttp\"\n)\n\nvar examplePingServer *memhttp.Server\n\nfunc init() {\n\t// Generally, init functions are bad. However, we need to set up the server\n\t// before the examples run.\n\t//\n\t// To write testable examples that users can grok *and* can execute in the\n\t// playground we use an in memory pipe as network based playgrounds can\n\t// deadlock, see:\n\t// (https://github.com/golang/go/issues/48394)\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}))\n\texamplePingServer = memhttp.NewServer(mux)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2919921875,
          "content": "module connectrpc.com/connect\n\ngo 1.21\n\nretract (\n\tv1.10.0 // module cache poisoned, use v1.10.1\n\tv1.9.0 // module cache poisoned, use v1.9.1\n)\n\nrequire (\n\tgithub.com/google/go-cmp v0.5.9\n\tgolang.org/x/net v0.23.0\n\tgoogle.golang.org/protobuf v1.34.2\n)\n\nrequire golang.org/x/text v0.14.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.6328125,
          "content": "github.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngolang.org/x/net v0.23.0 h1:7EYJ93RZ9vYSZAIb2x3lnuvqO5zneoD6IvWjuhfxjTs=\ngolang.org/x/net v0.23.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=\ngolang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngoogle.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=\ngoogle.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=\n"
        },
        {
          "name": "handler.go",
          "type": "blob",
          "size": 10.6611328125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"context\"\n\t\"net/http\"\n)\n\n// A Handler is the server-side implementation of a single RPC defined by a\n// service schema.\n//\n// By default, Handlers support the Connect, gRPC, and gRPC-Web protocols with\n// the binary Protobuf and JSON codecs. They support gzip compression using the\n// standard library's [compress/gzip].\ntype Handler struct {\n\tspec             Spec\n\timplementation   StreamingHandlerFunc\n\tprotocolHandlers map[string][]protocolHandler // Method to protocol handlers\n\tallowMethod      string                       // Allow header\n\tacceptPost       string                       // Accept-Post header\n}\n\n// NewUnaryHandler constructs a [Handler] for a request-response procedure.\nfunc NewUnaryHandler[Req, Res any](\n\tprocedure string,\n\tunary func(context.Context, *Request[Req]) (*Response[Res], error),\n\toptions ...HandlerOption,\n) *Handler {\n\t// Wrap the strongly-typed implementation so we can apply interceptors.\n\tuntyped := UnaryFunc(func(ctx context.Context, request AnyRequest) (AnyResponse, error) {\n\t\tif err := ctx.Err(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttyped, ok := request.(*Request[Req])\n\t\tif !ok {\n\t\t\treturn nil, errorf(CodeInternal, \"unexpected handler request type %T\", request)\n\t\t}\n\t\tres, err := unary(ctx, typed)\n\t\tif res == nil && err == nil {\n\t\t\t// This is going to panic during serialization. Debugging is much easier\n\t\t\t// if we panic here instead, so we can include the procedure name.\n\t\t\tpanic(procedure + \" returned nil *connect.Response and nil error\") //nolint: forbidigo\n\t\t}\n\t\treturn res, err\n\t})\n\tconfig := newHandlerConfig(procedure, StreamTypeUnary, options)\n\tif interceptor := config.Interceptor; interceptor != nil {\n\t\tuntyped = interceptor.WrapUnary(untyped)\n\t}\n\t// Given a stream, how should we call the unary function?\n\timplementation := func(ctx context.Context, conn StreamingHandlerConn) error {\n\t\trequest, err := receiveUnaryRequest[Req](conn, config.Initializer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresponse, err := untyped(ctx, request)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmergeNonProtocolHeaders(conn.ResponseHeader(), response.Header())\n\t\tmergeNonProtocolHeaders(conn.ResponseTrailer(), response.Trailer())\n\t\treturn conn.Send(response.Any())\n\t}\n\n\tprotocolHandlers := config.newProtocolHandlers()\n\treturn &Handler{\n\t\tspec:             config.newSpec(),\n\t\timplementation:   implementation,\n\t\tprotocolHandlers: mappedMethodHandlers(protocolHandlers),\n\t\tallowMethod:      sortedAllowMethodValue(protocolHandlers),\n\t\tacceptPost:       sortedAcceptPostValue(protocolHandlers),\n\t}\n}\n\n// NewClientStreamHandler constructs a [Handler] for a client streaming procedure.\nfunc NewClientStreamHandler[Req, Res any](\n\tprocedure string,\n\timplementation func(context.Context, *ClientStream[Req]) (*Response[Res], error),\n\toptions ...HandlerOption,\n) *Handler {\n\tconfig := newHandlerConfig(procedure, StreamTypeClient, options)\n\treturn newStreamHandler(\n\t\tconfig,\n\t\tfunc(ctx context.Context, conn StreamingHandlerConn) error {\n\t\t\tstream := &ClientStream[Req]{\n\t\t\t\tconn:        conn,\n\t\t\t\tinitializer: config.Initializer,\n\t\t\t}\n\t\t\tres, err := implementation(ctx, stream)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif res == nil {\n\t\t\t\t// This is going to panic during serialization. Debugging is much easier\n\t\t\t\t// if we panic here instead, so we can include the procedure name.\n\t\t\t\tpanic(procedure + \" returned nil *connect.Response and nil error\") //nolint: forbidigo\n\t\t\t}\n\t\t\tmergeHeaders(conn.ResponseHeader(), res.header)\n\t\t\tmergeHeaders(conn.ResponseTrailer(), res.trailer)\n\t\t\treturn conn.Send(res.Msg)\n\t\t},\n\t)\n}\n\n// NewServerStreamHandler constructs a [Handler] for a server streaming procedure.\nfunc NewServerStreamHandler[Req, Res any](\n\tprocedure string,\n\timplementation func(context.Context, *Request[Req], *ServerStream[Res]) error,\n\toptions ...HandlerOption,\n) *Handler {\n\tconfig := newHandlerConfig(procedure, StreamTypeServer, options)\n\treturn newStreamHandler(\n\t\tconfig,\n\t\tfunc(ctx context.Context, conn StreamingHandlerConn) error {\n\t\t\treq, err := receiveUnaryRequest[Req](conn, config.Initializer)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn implementation(ctx, req, &ServerStream[Res]{conn: conn})\n\t\t},\n\t)\n}\n\n// NewBidiStreamHandler constructs a [Handler] for a bidirectional streaming procedure.\nfunc NewBidiStreamHandler[Req, Res any](\n\tprocedure string,\n\timplementation func(context.Context, *BidiStream[Req, Res]) error,\n\toptions ...HandlerOption,\n) *Handler {\n\tconfig := newHandlerConfig(procedure, StreamTypeBidi, options)\n\treturn newStreamHandler(\n\t\tconfig,\n\t\tfunc(ctx context.Context, conn StreamingHandlerConn) error {\n\t\t\treturn implementation(\n\t\t\t\tctx,\n\t\t\t\t&BidiStream[Req, Res]{\n\t\t\t\t\tconn:        conn,\n\t\t\t\t\tinitializer: config.Initializer,\n\t\t\t\t},\n\t\t\t)\n\t\t},\n\t)\n}\n\n// ServeHTTP implements [http.Handler].\nfunc (h *Handler) ServeHTTP(responseWriter http.ResponseWriter, request *http.Request) {\n\t// We don't need to defer functions to close the request body or read to\n\t// EOF: the stream we construct later on already does that, and we only\n\t// return early when dealing with misbehaving clients. In those cases, it's\n\t// okay if we can't re-use the connection.\n\tisBidi := (h.spec.StreamType & StreamTypeBidi) == StreamTypeBidi\n\tif isBidi && request.ProtoMajor < 2 {\n\t\t// Clients coded to expect full-duplex connections may hang if they've\n\t\t// mistakenly negotiated HTTP/1.1. To unblock them, we must close the\n\t\t// underlying TCP connection.\n\t\tresponseWriter.Header().Set(\"Connection\", \"close\")\n\t\tresponseWriter.WriteHeader(http.StatusHTTPVersionNotSupported)\n\t\treturn\n\t}\n\n\tprotocolHandlers := h.protocolHandlers[request.Method]\n\tif len(protocolHandlers) == 0 {\n\t\tresponseWriter.Header().Set(\"Allow\", h.allowMethod)\n\t\tresponseWriter.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tcontentType := canonicalizeContentType(getHeaderCanonical(request.Header, headerContentType))\n\n\t// Find our implementation of the RPC protocol in use.\n\tvar protocolHandler protocolHandler\n\tfor _, handler := range protocolHandlers {\n\t\tif handler.CanHandlePayload(request, contentType) {\n\t\t\tprotocolHandler = handler\n\t\t\tbreak\n\t\t}\n\t}\n\tif protocolHandler == nil {\n\t\tresponseWriter.Header().Set(\"Accept-Post\", h.acceptPost)\n\t\tresponseWriter.WriteHeader(http.StatusUnsupportedMediaType)\n\t\treturn\n\t}\n\n\tif request.Method == http.MethodGet {\n\t\t// A body must not be present.\n\t\thasBody := request.ContentLength > 0\n\t\tif request.ContentLength < 0 {\n\t\t\t// No content-length header.\n\t\t\t// Test if body is empty by trying to read a single byte.\n\t\t\tvar b [1]byte\n\t\t\tn, _ := request.Body.Read(b[:])\n\t\t\thasBody = n > 0\n\t\t}\n\t\tif hasBody {\n\t\t\tresponseWriter.WriteHeader(http.StatusUnsupportedMediaType)\n\t\t\treturn\n\t\t}\n\t\t_ = request.Body.Close()\n\t}\n\n\t// Establish a stream and serve the RPC.\n\tsetHeaderCanonical(request.Header, headerContentType, contentType)\n\tsetHeaderCanonical(request.Header, headerHost, request.Host)\n\tctx, cancel, timeoutErr := protocolHandler.SetTimeout(request) //nolint: contextcheck\n\tif timeoutErr != nil {\n\t\tctx = request.Context()\n\t}\n\tif cancel != nil {\n\t\tdefer cancel()\n\t}\n\tconnCloser, ok := protocolHandler.NewConn(\n\t\tresponseWriter,\n\t\trequest.WithContext(ctx),\n\t)\n\tif !ok {\n\t\t// Failed to create stream, usually because client used an unknown\n\t\t// compression algorithm. Nothing further to do.\n\t\treturn\n\t}\n\tif timeoutErr != nil {\n\t\t_ = connCloser.Close(timeoutErr)\n\t\treturn\n\t}\n\t_ = connCloser.Close(h.implementation(ctx, connCloser))\n}\n\ntype handlerConfig struct {\n\tCompressionPools             map[string]*compressionPool\n\tCompressionNames             []string\n\tCodecs                       map[string]Codec\n\tCompressMinBytes             int\n\tInterceptor                  Interceptor\n\tProcedure                    string\n\tSchema                       any\n\tInitializer                  maybeInitializer\n\tRequireConnectProtocolHeader bool\n\tIdempotencyLevel             IdempotencyLevel\n\tBufferPool                   *bufferPool\n\tReadMaxBytes                 int\n\tSendMaxBytes                 int\n\tStreamType                   StreamType\n}\n\nfunc newHandlerConfig(procedure string, streamType StreamType, options []HandlerOption) *handlerConfig {\n\tprotoPath := extractProtoPath(procedure)\n\tconfig := handlerConfig{\n\t\tProcedure:        protoPath,\n\t\tCompressionPools: make(map[string]*compressionPool),\n\t\tCodecs:           make(map[string]Codec),\n\t\tBufferPool:       newBufferPool(),\n\t\tStreamType:       streamType,\n\t}\n\twithProtoBinaryCodec().applyToHandler(&config)\n\twithProtoJSONCodecs().applyToHandler(&config)\n\twithGzip().applyToHandler(&config)\n\tfor _, opt := range options {\n\t\topt.applyToHandler(&config)\n\t}\n\treturn &config\n}\n\nfunc (c *handlerConfig) newSpec() Spec {\n\treturn Spec{\n\t\tProcedure:        c.Procedure,\n\t\tSchema:           c.Schema,\n\t\tStreamType:       c.StreamType,\n\t\tIdempotencyLevel: c.IdempotencyLevel,\n\t}\n}\n\nfunc (c *handlerConfig) newProtocolHandlers() []protocolHandler {\n\tprotocols := []protocol{\n\t\t&protocolConnect{},\n\t\t&protocolGRPC{web: false},\n\t\t&protocolGRPC{web: true},\n\t}\n\thandlers := make([]protocolHandler, 0, len(protocols))\n\tcodecs := newReadOnlyCodecs(c.Codecs)\n\tcompressors := newReadOnlyCompressionPools(\n\t\tc.CompressionPools,\n\t\tc.CompressionNames,\n\t)\n\tfor _, protocol := range protocols {\n\t\thandlers = append(handlers, protocol.NewHandler(&protocolHandlerParams{\n\t\t\tSpec:                         c.newSpec(),\n\t\t\tCodecs:                       codecs,\n\t\t\tCompressionPools:             compressors,\n\t\t\tCompressMinBytes:             c.CompressMinBytes,\n\t\t\tBufferPool:                   c.BufferPool,\n\t\t\tReadMaxBytes:                 c.ReadMaxBytes,\n\t\t\tSendMaxBytes:                 c.SendMaxBytes,\n\t\t\tRequireConnectProtocolHeader: c.RequireConnectProtocolHeader,\n\t\t\tIdempotencyLevel:             c.IdempotencyLevel,\n\t\t}))\n\t}\n\treturn handlers\n}\n\nfunc newStreamHandler(\n\tconfig *handlerConfig,\n\timplementation StreamingHandlerFunc,\n) *Handler {\n\tif ic := config.Interceptor; ic != nil {\n\t\timplementation = ic.WrapStreamingHandler(implementation)\n\t}\n\tprotocolHandlers := config.newProtocolHandlers()\n\treturn &Handler{\n\t\tspec:             config.newSpec(),\n\t\timplementation:   implementation,\n\t\tprotocolHandlers: mappedMethodHandlers(protocolHandlers),\n\t\tallowMethod:      sortedAllowMethodValue(protocolHandlers),\n\t\tacceptPost:       sortedAcceptPostValue(protocolHandlers),\n\t}\n}\n"
        },
        {
          "name": "handler_example_test.go",
          "type": "blob",
          "size": 3.53515625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\n\tconnect \"connectrpc.com/connect\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n)\n\n// ExamplePingServer implements some trivial business logic. The Protobuf\n// definition for this API is in proto/connect/ping/v1/ping.proto.\ntype ExamplePingServer struct {\n\tpingv1connect.UnimplementedPingServiceHandler\n}\n\n// Ping implements pingv1connect.PingServiceHandler.\nfunc (*ExamplePingServer) Ping(\n\t_ context.Context,\n\trequest *connect.Request[pingv1.PingRequest],\n) (*connect.Response[pingv1.PingResponse], error) {\n\treturn connect.NewResponse(\n\t\t&pingv1.PingResponse{\n\t\t\tNumber: request.Msg.GetNumber(),\n\t\t\tText:   request.Msg.GetText(),\n\t\t},\n\t), nil\n}\n\n// Sum implements pingv1connect.PingServiceHandler.\nfunc (p *ExamplePingServer) Sum(ctx context.Context, stream *connect.ClientStream[pingv1.SumRequest]) (*connect.Response[pingv1.SumResponse], error) {\n\tvar sum int64\n\tfor stream.Receive() {\n\t\tsum += stream.Msg().GetNumber()\n\t}\n\tif stream.Err() != nil {\n\t\treturn nil, stream.Err()\n\t}\n\treturn connect.NewResponse(&pingv1.SumResponse{Sum: sum}), nil\n}\n\n// CountUp implements pingv1connect.PingServiceHandler.\nfunc (p *ExamplePingServer) CountUp(ctx context.Context, request *connect.Request[pingv1.CountUpRequest], stream *connect.ServerStream[pingv1.CountUpResponse]) error {\n\tfor number := int64(1); number <= request.Msg.GetNumber(); number++ {\n\t\tif err := stream.Send(&pingv1.CountUpResponse{Number: number}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// CumSum implements pingv1connect.PingServiceHandler.\nfunc (p *ExamplePingServer) CumSum(ctx context.Context, stream *connect.BidiStream[pingv1.CumSumRequest, pingv1.CumSumResponse]) error {\n\tvar sum int64\n\tfor {\n\t\tmsg, err := stream.Receive()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\treturn nil\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsum += msg.GetNumber()\n\t\tif err := stream.Send(&pingv1.CumSumResponse{Sum: sum}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc Example_handler() {\n\t// protoc-gen-connect-go generates constructors that return plain net/http\n\t// Handlers, so they're compatible with most Go HTTP routers and middleware\n\t// (for example, net/http's StripPrefix). Each handler automatically supports\n\t// the Connect, gRPC, and gRPC-Web protocols.\n\tmux := http.NewServeMux()\n\tmux.Handle(\n\t\tpingv1connect.NewPingServiceHandler(\n\t\t\t&ExamplePingServer{}, // our business logic\n\t\t),\n\t)\n\t// You can serve gRPC's health and server reflection APIs using\n\t// connectrpc.com/grpchealth and connectrpc.com/grpcreflect.\n\t_ = http.ListenAndServeTLS(\n\t\t\"localhost:8080\",\n\t\t\"internal/testdata/server.crt\",\n\t\t\"internal/testdata/server.key\",\n\t\tmux,\n\t)\n\t// To serve HTTP/2 requests without TLS (as many gRPC clients expect), import\n\t// golang.org/x/net/http2/h2c and golang.org/x/net/http2 and change to:\n\t// _ = http.ListenAndServe(\n\t// \t\"localhost:8080\",\n\t// \th2c.NewHandler(mux, &http2.Server{}),\n\t// )\n}\n"
        },
        {
          "name": "handler_ext_test.go",
          "type": "blob",
          "size": 16.24609375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\tconnect \"connectrpc.com/connect\"\n\t\"connectrpc.com/connect/internal/assert\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n\t\"connectrpc.com/connect/internal/memhttp/memhttptest\"\n\t\"google.golang.org/protobuf/reflect/protoreflect\"\n\t\"google.golang.org/protobuf/reflect/protoregistry\"\n\t\"google.golang.org/protobuf/types/dynamicpb\"\n)\n\nfunc TestHandler_ServeHTTP(t *testing.T) {\n\tt.Parallel()\n\tpath, handler := pingv1connect.NewPingServiceHandler(successPingServer{})\n\tprefixed := http.NewServeMux()\n\tprefixed.Handle(path, handler)\n\tmux := http.NewServeMux()\n\tmux.Handle(path, handler)\n\tmux.Handle(\"/prefixed/\", http.StripPrefix(\"/prefixed\", prefixed))\n\tconst pingProcedure = pingv1connect.PingServicePingProcedure\n\tconst sumProcedure = pingv1connect.PingServiceSumProcedure\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := server.Client()\n\n\tt.Run(\"get_method_no_encoding\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trequest, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodGet,\n\t\t\tserver.URL()+pingProcedure,\n\t\t\tstrings.NewReader(\"\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\tresp, err := client.Do(request)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusUnsupportedMediaType)\n\t})\n\n\tt.Run(\"get_method_bad_encoding\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trequest, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodGet,\n\t\t\tserver.URL()+pingProcedure+`?encoding=unk&message={}`,\n\t\t\tstrings.NewReader(\"\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\tresp, err := client.Do(request)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusUnsupportedMediaType)\n\t})\n\n\tt.Run(\"get_method_body_not_allowed\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tconst queryStringSuffix = `?encoding=json&message={}`\n\t\trequest, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodGet,\n\t\t\tserver.URL()+pingProcedure+queryStringSuffix,\n\t\t\tstrings.NewReader(\"!\"), // non-empty body\n\t\t)\n\t\tassert.Nil(t, err)\n\t\tresp, err := client.Do(request)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusUnsupportedMediaType)\n\n\t\t// Same thing, but this time w/ a content-length header\n\t\trequest, err = http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodGet,\n\t\t\tserver.URL()+pingProcedure+queryStringSuffix,\n\t\t\tstrings.NewReader(\"!\"), // non-empty body\n\t\t)\n\t\tassert.Nil(t, err)\n\t\trequest.Header.Set(\"content-length\", \"1\")\n\t\tresp, err = client.Do(request)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusUnsupportedMediaType)\n\t})\n\n\tt.Run(\"idempotent_get_method\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trequest, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodGet,\n\t\t\tserver.URL()+pingProcedure+`?encoding=json&message={}`,\n\t\t\tstrings.NewReader(\"\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\tresp, err := client.Do(request)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\t})\n\n\tt.Run(\"prefixed_get_method\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trequest, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodGet,\n\t\t\tserver.URL()+\"/prefixed\"+pingProcedure+`?encoding=json&message={}`,\n\t\t\tstrings.NewReader(\"\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\tresp, err := client.Do(request)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\t})\n\n\tt.Run(\"method_not_allowed\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trequest, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodGet,\n\t\t\tserver.URL()+sumProcedure,\n\t\t\tstrings.NewReader(\"\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\tresp, err := client.Do(request)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusMethodNotAllowed)\n\t\tassert.Equal(t, resp.Header.Get(\"Allow\"), http.MethodPost)\n\t})\n\n\tt.Run(\"unsupported_content_type\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trequest, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodPost,\n\t\t\tserver.URL()+pingProcedure,\n\t\t\tstrings.NewReader(\"{}\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\trequest.Header.Set(\"Content-Type\", \"application/x-custom-json\")\n\t\tresp, err := client.Do(request)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusUnsupportedMediaType)\n\t\tassert.Equal(t, resp.Header.Get(\"Accept-Post\"), strings.Join([]string{\n\t\t\t\"application/grpc\",\n\t\t\t\"application/grpc+json\",\n\t\t\t\"application/grpc+json; charset=utf-8\",\n\t\t\t\"application/grpc+proto\",\n\t\t\t\"application/grpc-web\",\n\t\t\t\"application/grpc-web+json\",\n\t\t\t\"application/grpc-web+json; charset=utf-8\",\n\t\t\t\"application/grpc-web+proto\",\n\t\t\t\"application/json\",\n\t\t\t\"application/json; charset=utf-8\",\n\t\t\t\"application/proto\",\n\t\t}, \", \"))\n\t})\n\n\tt.Run(\"charset_in_content_type_header\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\treq, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodPost,\n\t\t\tserver.URL()+pingProcedure,\n\t\t\tstrings.NewReader(\"{}\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\treq.Header.Set(\"Content-Type\", \"application/json;Charset=Utf-8\")\n\t\tresp, err := client.Do(req)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\t})\n\n\tt.Run(\"unsupported_charset\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\treq, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodPost,\n\t\t\tserver.URL()+pingProcedure,\n\t\t\tstrings.NewReader(\"{}\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\treq.Header.Set(\"Content-Type\", \"application/json; charset=shift-jis\")\n\t\tresp, err := client.Do(req)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusUnsupportedMediaType)\n\t})\n\n\tt.Run(\"unsupported_content_encoding\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\treq, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodPost,\n\t\t\tserver.URL()+pingProcedure,\n\t\t\tstrings.NewReader(\"{}\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\treq.Header.Set(\"Content-Encoding\", \"invalid\")\n\t\tresp, err := client.Do(req)\n\t\tassert.Nil(t, err)\n\t\tdefer resp.Body.Close()\n\t\tassert.Equal(t, resp.StatusCode, http.StatusNotImplemented)\n\n\t\ttype errorMessage struct {\n\t\t\tCode    string `json:\"code,omitempty\"`\n\t\t\tMessage string `json:\"message,omitempty\"`\n\t\t}\n\t\tvar message errorMessage\n\t\terr = json.NewDecoder(resp.Body).Decode(&message)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, message.Message, `unknown compression \"invalid\": supported encodings are gzip`)\n\t\tassert.Equal(t, message.Code, connect.CodeUnimplemented.String())\n\t})\n}\n\nfunc TestHandlerMaliciousPrefix(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(successPingServer{}))\n\tserver := memhttptest.NewServer(t, mux)\n\n\tconst (\n\t\tconcurrency  = 256\n\t\tspuriousSize = 1024 * 1024 * 512 // 512 MB\n\t)\n\tvar wg sync.WaitGroup\n\tstart := make(chan struct{})\n\tfor i := 0; i < concurrency; i++ {\n\t\tbody := make([]byte, 16)\n\t\t// Envelope prefix indicates a large payload which we're not actually\n\t\t// sending.\n\t\tbinary.BigEndian.PutUint32(body[1:5], spuriousSize)\n\t\treq, err := http.NewRequestWithContext(\n\t\t\tcontext.Background(),\n\t\t\thttp.MethodPost,\n\t\t\tserver.URL()+pingv1connect.PingServicePingProcedure,\n\t\t\tbytes.NewReader(body),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\treq.Header.Set(\"Content-Type\", \"application/grpc\")\n\t\twg.Add(1)\n\t\tgo func(req *http.Request) {\n\t\t\tdefer wg.Done()\n\t\t\t<-start\n\t\t\tresponse, err := server.Client().Do(req)\n\t\t\tif err == nil {\n\t\t\t\t_, _ = io.Copy(io.Discard, response.Body)\n\t\t\t\tresponse.Body.Close()\n\t\t\t}\n\t\t}(req)\n\t}\n\tclose(start)\n\twg.Wait()\n}\n\nfunc TestDynamicHandler(t *testing.T) {\n\tt.Parallel()\n\tinitializer := func(spec connect.Spec, msg any) error {\n\t\tdynamic, ok := msg.(*dynamicpb.Message)\n\t\tif !ok {\n\t\t\treturn nil\n\t\t}\n\t\tdesc, ok := spec.Schema.(protoreflect.MethodDescriptor)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"invalid schema type %T for %T message\", spec.Schema, dynamic)\n\t\t}\n\t\tif spec.IsClient {\n\t\t\t*dynamic = *dynamicpb.NewMessage(desc.Output())\n\t\t} else {\n\t\t\t*dynamic = *dynamicpb.NewMessage(desc.Input())\n\t\t}\n\t\treturn nil\n\t}\n\tt.Run(\"unary\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.Ping\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\tdynamicPing := func(_ context.Context, req *connect.Request[dynamicpb.Message]) (*connect.Response[dynamicpb.Message], error) {\n\t\t\tgot := req.Msg.Get(methodDesc.Input().Fields().ByName(\"number\")).Int()\n\t\t\tmsg := dynamicpb.NewMessage(methodDesc.Output())\n\t\t\tmsg.Set(\n\t\t\t\tmethodDesc.Output().Fields().ByName(\"number\"),\n\t\t\t\tprotoreflect.ValueOfInt64(got),\n\t\t\t)\n\t\t\treturn connect.NewResponse(msg), nil\n\t\t}\n\t\tmux := http.NewServeMux()\n\t\tmux.Handle(\"/connect.ping.v1.PingService/Ping\",\n\t\t\tconnect.NewUnaryHandler(\n\t\t\t\t\"/connect.ping.v1.PingService/Ping\",\n\t\t\t\tdynamicPing,\n\t\t\t\tconnect.WithSchema(methodDesc),\n\t\t\t\tconnect.WithIdempotency(connect.IdempotencyNoSideEffects),\n\t\t\t\tconnect.WithRequestInitializer(initializer),\n\t\t\t),\n\t\t)\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\trsp, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{\n\t\t\tNumber: 42,\n\t\t}))\n\t\tif !assert.Nil(t, err) {\n\t\t\treturn\n\t\t}\n\t\tgot := rsp.Msg.Number\n\t\tassert.Equal(t, got, 42)\n\t})\n\tt.Run(\"clientStream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.Sum\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\tdynamicSum := func(_ context.Context, stream *connect.ClientStream[dynamicpb.Message]) (*connect.Response[dynamicpb.Message], error) {\n\t\t\tvar sum int64\n\t\t\tfor stream.Receive() {\n\t\t\t\tgot := stream.Msg().Get(\n\t\t\t\t\tmethodDesc.Input().Fields().ByName(\"number\"),\n\t\t\t\t).Int()\n\t\t\t\tsum += got\n\t\t\t}\n\t\t\tmsg := dynamicpb.NewMessage(methodDesc.Output())\n\t\t\tmsg.Set(\n\t\t\t\tmethodDesc.Output().Fields().ByName(\"sum\"),\n\t\t\t\tprotoreflect.ValueOfInt64(sum),\n\t\t\t)\n\t\t\treturn connect.NewResponse(msg), nil\n\t\t}\n\t\tmux := http.NewServeMux()\n\t\tmux.Handle(\"/connect.ping.v1.PingService/Sum\",\n\t\t\tconnect.NewClientStreamHandler(\n\t\t\t\t\"/connect.ping.v1.PingService/Sum\",\n\t\t\t\tdynamicSum,\n\t\t\t\tconnect.WithSchema(methodDesc),\n\t\t\t\tconnect.WithRequestInitializer(initializer),\n\t\t\t),\n\t\t)\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\tstream := client.Sum(context.Background())\n\t\tassert.Nil(t, stream.Send(&pingv1.SumRequest{Number: 42}))\n\t\tassert.Nil(t, stream.Send(&pingv1.SumRequest{Number: 42}))\n\t\trsp, err := stream.CloseAndReceive()\n\t\tif !assert.Nil(t, err) {\n\t\t\treturn\n\t\t}\n\t\tassert.Equal(t, rsp.Msg.Sum, 42*2)\n\t})\n\tt.Run(\"serverStream\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.CountUp\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\tdynamicCountUp := func(_ context.Context, req *connect.Request[dynamicpb.Message], stream *connect.ServerStream[dynamicpb.Message]) error {\n\t\t\tnumber := req.Msg.Get(methodDesc.Input().Fields().ByName(\"number\")).Int()\n\t\t\tfor i := int64(1); i <= number; i++ {\n\t\t\t\tmsg := dynamicpb.NewMessage(methodDesc.Output())\n\t\t\t\tmsg.Set(\n\t\t\t\t\tmethodDesc.Output().Fields().ByName(\"number\"),\n\t\t\t\t\tprotoreflect.ValueOfInt64(i),\n\t\t\t\t)\n\t\t\t\tif err := stream.Send(msg); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tmux := http.NewServeMux()\n\t\tmux.Handle(\"/connect.ping.v1.PingService/CountUp\",\n\t\t\tconnect.NewServerStreamHandler(\n\t\t\t\t\"/connect.ping.v1.PingService/CountUp\",\n\t\t\t\tdynamicCountUp,\n\t\t\t\tconnect.WithSchema(methodDesc),\n\t\t\t\tconnect.WithRequestInitializer(initializer),\n\t\t\t),\n\t\t)\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\tstream, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{\n\t\t\tNumber: 2,\n\t\t}))\n\t\tif !assert.Nil(t, err) {\n\t\t\treturn\n\t\t}\n\t\tvar sum int64\n\t\tfor stream.Receive() {\n\t\t\tsum += stream.Msg().Number\n\t\t}\n\t\tassert.Nil(t, stream.Err())\n\t\tassert.Equal(t, sum, 3) // 1 + 2\n\t})\n\tt.Run(\"bidi\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.CumSum\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\tdynamicCumSum := func(\n\t\t\t_ context.Context,\n\t\t\tstream *connect.BidiStream[dynamicpb.Message, dynamicpb.Message],\n\t\t) error {\n\t\t\tvar sum int64\n\t\t\tfor {\n\t\t\t\tmsg, err := stream.Receive()\n\t\t\t\tif errors.Is(err, io.EOF) {\n\t\t\t\t\treturn nil\n\t\t\t\t} else if err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tgot := msg.Get(methodDesc.Input().Fields().ByName(\"number\")).Int()\n\t\t\t\tsum += got\n\t\t\t\tout := dynamicpb.NewMessage(methodDesc.Output())\n\t\t\t\tout.Set(\n\t\t\t\t\tmethodDesc.Output().Fields().ByName(\"sum\"),\n\t\t\t\t\tprotoreflect.ValueOfInt64(sum),\n\t\t\t\t)\n\t\t\t\tif err := stream.Send(out); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmux := http.NewServeMux()\n\t\tmux.Handle(\"/connect.ping.v1.PingService/CumSum\",\n\t\t\tconnect.NewBidiStreamHandler(\n\t\t\t\t\"/connect.ping.v1.PingService/CumSum\",\n\t\t\t\tdynamicCumSum,\n\t\t\t\tconnect.WithSchema(methodDesc),\n\t\t\t\tconnect.WithRequestInitializer(initializer),\n\t\t\t),\n\t\t)\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\tstream := client.CumSum(context.Background())\n\t\tassert.Nil(t, stream.Send(&pingv1.CumSumRequest{Number: 1}))\n\t\tmsg, err := stream.Receive()\n\t\tif !assert.Nil(t, err) {\n\t\t\treturn\n\t\t}\n\t\tassert.Equal(t, msg.Sum, int64(1))\n\t\tassert.Nil(t, stream.CloseRequest())\n\t\tassert.Nil(t, stream.CloseResponse())\n\t})\n\tt.Run(\"option\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tdesc, err := protoregistry.GlobalFiles.FindDescriptorByName(\"connect.ping.v1.PingService.Ping\")\n\t\tassert.Nil(t, err)\n\t\tmethodDesc, ok := desc.(protoreflect.MethodDescriptor)\n\t\tassert.True(t, ok)\n\t\tdynamicPing := func(_ context.Context, req *connect.Request[dynamicpb.Message]) (*connect.Response[dynamicpb.Message], error) {\n\t\t\tgot := req.Msg.Get(methodDesc.Input().Fields().ByName(\"number\")).Int()\n\t\t\tmsg := dynamicpb.NewMessage(methodDesc.Output())\n\t\t\tmsg.Set(\n\t\t\t\tmethodDesc.Output().Fields().ByName(\"number\"),\n\t\t\t\tprotoreflect.ValueOfInt64(got),\n\t\t\t)\n\t\t\treturn connect.NewResponse(msg), nil\n\t\t}\n\t\toptionCalled := false\n\t\tmux := http.NewServeMux()\n\t\tmux.Handle(\"/connect.ping.v1.PingService/Ping\",\n\t\t\tconnect.NewUnaryHandler(\n\t\t\t\t\"/connect.ping.v1.PingService/Ping\",\n\t\t\t\tdynamicPing,\n\t\t\t\tconnect.WithSchema(methodDesc),\n\t\t\t\tconnect.WithIdempotency(connect.IdempotencyNoSideEffects),\n\t\t\t\tconnect.WithRequestInitializer(\n\t\t\t\t\tfunc(spec connect.Spec, msg any) error {\n\t\t\t\t\t\tassert.NotNil(t, spec)\n\t\t\t\t\t\tassert.NotNil(t, msg)\n\t\t\t\t\t\tdynamic, ok := msg.(*dynamicpb.Message)\n\t\t\t\t\t\tif !assert.True(t, ok) {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"unexpected message type: %T\", msg)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*dynamic = *dynamicpb.NewMessage(methodDesc.Input())\n\t\t\t\t\t\toptionCalled = true\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\tserver := memhttptest.NewServer(t, mux)\n\t\tclient := pingv1connect.NewPingServiceClient(server.Client(), server.URL())\n\t\trsp, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{\n\t\t\tNumber: 42,\n\t\t}))\n\t\tif !assert.Nil(t, err) {\n\t\t\treturn\n\t\t}\n\t\tgot := rsp.Msg.Number\n\t\tassert.Equal(t, got, 42)\n\t\tassert.True(t, optionCalled)\n\t})\n}\n\ntype successPingServer struct {\n\tpingv1connect.UnimplementedPingServiceHandler\n}\n\nfunc (successPingServer) Ping(context.Context, *connect.Request[pingv1.PingRequest]) (*connect.Response[pingv1.PingResponse], error) {\n\treturn &connect.Response[pingv1.PingResponse]{}, nil\n}\n"
        },
        {
          "name": "handler_stream.go",
          "type": "blob",
          "size": 5.92578125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// ClientStream is the handler's view of a client streaming RPC.\n//\n// It's constructed as part of [Handler] invocation, but doesn't currently have\n// an exported constructor.\ntype ClientStream[Req any] struct {\n\tconn        StreamingHandlerConn\n\tinitializer maybeInitializer\n\tmsg         *Req\n\terr         error\n}\n\n// Spec returns the specification for the RPC.\nfunc (c *ClientStream[_]) Spec() Spec {\n\treturn c.conn.Spec()\n}\n\n// Peer describes the client for this RPC.\nfunc (c *ClientStream[_]) Peer() Peer {\n\treturn c.conn.Peer()\n}\n\n// RequestHeader returns the headers received from the client.\nfunc (c *ClientStream[Req]) RequestHeader() http.Header {\n\treturn c.conn.RequestHeader()\n}\n\n// Receive advances the stream to the next message, which will then be\n// available through the Msg method. It returns false when the stream stops,\n// either by reaching the end or by encountering an unexpected error. After\n// Receive returns false, the Err method will return any unexpected error\n// encountered.\nfunc (c *ClientStream[Req]) Receive() bool {\n\tif c.err != nil {\n\t\treturn false\n\t}\n\tc.msg = new(Req)\n\tif err := c.initializer.maybe(c.Spec(), c.msg); err != nil {\n\t\tc.err = err\n\t\treturn false\n\t}\n\tc.err = c.conn.Receive(c.msg)\n\treturn c.err == nil\n}\n\n// Msg returns the most recent message unmarshaled by a call to Receive.\nfunc (c *ClientStream[Req]) Msg() *Req {\n\tif c.msg == nil {\n\t\tc.msg = new(Req)\n\t}\n\treturn c.msg\n}\n\n// Err returns the first non-EOF error that was encountered by Receive.\nfunc (c *ClientStream[Req]) Err() error {\n\tif c.err == nil || errors.Is(c.err, io.EOF) {\n\t\treturn nil\n\t}\n\treturn c.err\n}\n\n// Conn exposes the underlying StreamingHandlerConn. This may be useful if\n// you'd prefer to wrap the connection in a different high-level API.\nfunc (c *ClientStream[Req]) Conn() StreamingHandlerConn {\n\treturn c.conn\n}\n\n// ServerStream is the handler's view of a server streaming RPC.\n//\n// It's constructed as part of [Handler] invocation, but doesn't currently have\n// an exported constructor.\ntype ServerStream[Res any] struct {\n\tconn StreamingHandlerConn\n}\n\n// ResponseHeader returns the response headers. Headers are sent with the first\n// call to Send.\n//\n// Headers beginning with \"Connect-\" and \"Grpc-\" are reserved for use by the\n// Connect and gRPC protocols. Applications shouldn't write them.\nfunc (s *ServerStream[Res]) ResponseHeader() http.Header {\n\treturn s.conn.ResponseHeader()\n}\n\n// ResponseTrailer returns the response trailers. Handlers may write to the\n// response trailers at any time before returning.\n//\n// Trailers beginning with \"Connect-\" and \"Grpc-\" are reserved for use by the\n// Connect and gRPC protocols. Applications shouldn't write them.\nfunc (s *ServerStream[Res]) ResponseTrailer() http.Header {\n\treturn s.conn.ResponseTrailer()\n}\n\n// Send a message to the client. The first call to Send also sends the response\n// headers.\nfunc (s *ServerStream[Res]) Send(msg *Res) error {\n\tif msg == nil {\n\t\treturn s.conn.Send(nil)\n\t}\n\treturn s.conn.Send(msg)\n}\n\n// Conn exposes the underlying StreamingHandlerConn. This may be useful if\n// you'd prefer to wrap the connection in a different high-level API.\nfunc (s *ServerStream[Res]) Conn() StreamingHandlerConn {\n\treturn s.conn\n}\n\n// BidiStream is the handler's view of a bidirectional streaming RPC.\n//\n// It's constructed as part of [Handler] invocation, but doesn't currently have\n// an exported constructor.\ntype BidiStream[Req, Res any] struct {\n\tconn        StreamingHandlerConn\n\tinitializer maybeInitializer\n}\n\n// Spec returns the specification for the RPC.\nfunc (b *BidiStream[_, _]) Spec() Spec {\n\treturn b.conn.Spec()\n}\n\n// Peer describes the client for this RPC.\nfunc (b *BidiStream[_, _]) Peer() Peer {\n\treturn b.conn.Peer()\n}\n\n// RequestHeader returns the headers received from the client.\nfunc (b *BidiStream[Req, Res]) RequestHeader() http.Header {\n\treturn b.conn.RequestHeader()\n}\n\n// Receive a message. When the client is done sending messages, Receive will\n// return an error that wraps [io.EOF].\nfunc (b *BidiStream[Req, Res]) Receive() (*Req, error) {\n\tvar req Req\n\tif err := b.initializer.maybe(b.Spec(), &req); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := b.conn.Receive(&req); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &req, nil\n}\n\n// ResponseHeader returns the response headers. Headers are sent with the first\n// call to Send.\n//\n// Headers beginning with \"Connect-\" and \"Grpc-\" are reserved for use by the\n// Connect and gRPC protocols. Applications shouldn't write them.\nfunc (b *BidiStream[Req, Res]) ResponseHeader() http.Header {\n\treturn b.conn.ResponseHeader()\n}\n\n// ResponseTrailer returns the response trailers. Handlers may write to the\n// response trailers at any time before returning.\n//\n// Trailers beginning with \"Connect-\" and \"Grpc-\" are reserved for use by the\n// Connect and gRPC protocols. Applications shouldn't write them.\nfunc (b *BidiStream[Req, Res]) ResponseTrailer() http.Header {\n\treturn b.conn.ResponseTrailer()\n}\n\n// Send a message to the client. The first call to Send also sends the response\n// headers.\nfunc (b *BidiStream[Req, Res]) Send(msg *Res) error {\n\tif msg == nil {\n\t\treturn b.conn.Send(nil)\n\t}\n\treturn b.conn.Send(msg)\n}\n\n// Conn exposes the underlying StreamingHandlerConn. This may be useful if\n// you'd prefer to wrap the connection in a different high-level API.\nfunc (b *BidiStream[Req, Res]) Conn() StreamingHandlerConn {\n\treturn b.conn\n}\n"
        },
        {
          "name": "handler_stream_test.go",
          "type": "blob",
          "size": 1.4892578125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n)\n\nfunc TestClientStreamIterator(t *testing.T) {\n\tt.Parallel()\n\t// The server's view of a client streaming RPC is an iterator. For safety,\n\t// and to match grpc-go's behavior, we should allocate a new message for each\n\t// iteration.\n\tstream := &ClientStream[pingv1.PingRequest]{\n\t\tconn: &nopStreamingHandlerConn{},\n\t}\n\tassert.True(t, stream.Receive())\n\tfirst := fmt.Sprintf(\"%p\", stream.Msg())\n\tassert.True(t, stream.Receive())\n\tsecond := fmt.Sprintf(\"%p\", stream.Msg())\n\tassert.NotEqual(t, first, second, assert.Sprintf(\"should allocate a new message for each iteration\"))\n}\n\ntype nopStreamingHandlerConn struct {\n\tStreamingHandlerConn\n}\n\nfunc (nopStreamingHandlerConn) Receive(msg any) error {\n\treturn nil\n}\n\nfunc (nopStreamingHandlerConn) Spec() Spec {\n\treturn Spec{}\n}\n"
        },
        {
          "name": "header.go",
          "type": "blob",
          "size": 4.16796875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"encoding/base64\"\n\t\"net/http\"\n)\n\nvar (\n\t//nolint:gochecknoglobals\n\tprotocolHeaders = map[string]struct{}{\n\t\t// HTTP headers.\n\t\theaderContentType:     {},\n\t\theaderContentLength:   {},\n\t\theaderContentEncoding: {},\n\t\theaderHost:            {},\n\t\theaderUserAgent:       {},\n\t\theaderTrailer:         {},\n\t\theaderDate:            {},\n\t\t// Connect headers.\n\t\tconnectUnaryHeaderAcceptCompression:     {},\n\t\tconnectUnaryTrailerPrefix:               {},\n\t\tconnectStreamingHeaderCompression:       {},\n\t\tconnectStreamingHeaderAcceptCompression: {},\n\t\tconnectHeaderTimeout:                    {},\n\t\tconnectHeaderProtocolVersion:            {},\n\t\t// gRPC headers.\n\t\tgrpcHeaderCompression:       {},\n\t\tgrpcHeaderAcceptCompression: {},\n\t\tgrpcHeaderTimeout:           {},\n\t\tgrpcHeaderStatus:            {},\n\t\tgrpcHeaderMessage:           {},\n\t\tgrpcHeaderDetails:           {},\n\t}\n)\n\n// EncodeBinaryHeader base64-encodes the data. It always emits unpadded values.\n//\n// In the Connect, gRPC, and gRPC-Web protocols, binary headers must have keys\n// ending in \"-Bin\".\nfunc EncodeBinaryHeader(data []byte) string {\n\t// gRPC specification says that implementations should emit unpadded values.\n\treturn base64.RawStdEncoding.EncodeToString(data)\n}\n\n// DecodeBinaryHeader base64-decodes the data. It can decode padded or unpadded\n// values. Following usual HTTP semantics, multiple base64-encoded values may\n// be joined with a comma. When receiving such comma-separated values, split\n// them with [strings.Split] before calling DecodeBinaryHeader.\n//\n// Binary headers sent using the Connect, gRPC, and gRPC-Web protocols have\n// keys ending in \"-Bin\".\nfunc DecodeBinaryHeader(data string) ([]byte, error) {\n\tif len(data)%4 != 0 {\n\t\t// Data definitely isn't padded.\n\t\treturn base64.RawStdEncoding.DecodeString(data)\n\t}\n\t// Either the data was padded, or padding wasn't necessary. In both cases,\n\t// the padding-aware decoder works.\n\treturn base64.StdEncoding.DecodeString(data)\n}\n\nfunc mergeHeaders(into, from http.Header) {\n\tfor key, vals := range from {\n\t\tif len(vals) == 0 {\n\t\t\t// For response trailers, net/http will pre-populate entries\n\t\t\t// with nil values based on the \"Trailer\" header. But if there\n\t\t\t// are no actual values for those keys, we skip them.\n\t\t\tcontinue\n\t\t}\n\t\tinto[key] = append(into[key], vals...)\n\t}\n}\n\n// mergeNonProtocolHeaders merges headers excluding protocol headers defined in\n// protocolHeaders.\nfunc mergeNonProtocolHeaders(into, from http.Header) {\n\tfor key, vals := range from {\n\t\tif len(vals) == 0 {\n\t\t\t// For response trailers, net/http will pre-populate entries\n\t\t\t// with nil values based on the \"Trailer\" header. But if there\n\t\t\t// are no actual values for those keys, we skip them.\n\t\t\tcontinue\n\t\t}\n\t\tif _, isProtocolHeader := protocolHeaders[key]; !isProtocolHeader {\n\t\t\tinto[key] = append(into[key], vals...)\n\t\t}\n\t}\n}\n\n// getHeaderCanonical is a shortcut for Header.Get() which\n// bypasses the CanonicalMIMEHeaderKey operation when we\n// know the key is already in canonical form.\nfunc getHeaderCanonical(h http.Header, key string) string {\n\tif h == nil {\n\t\treturn \"\"\n\t}\n\tv := h[key]\n\tif len(v) == 0 {\n\t\treturn \"\"\n\t}\n\treturn v[0]\n}\n\n// setHeaderCanonical is a shortcut for Header.Set() which\n// bypasses the CanonicalMIMEHeaderKey operation when we\n// know the key is already in canonical form.\nfunc setHeaderCanonical(h http.Header, key, value string) {\n\th[key] = []string{value}\n}\n\n// delHeaderCanonical is a shortcut for Header.Del() which\n// bypasses the CanonicalMIMEHeaderKey operation when we\n// know the key is already in canonical form.\nfunc delHeaderCanonical(h http.Header, key string) {\n\tdelete(h, key)\n}\n"
        },
        {
          "name": "header_test.go",
          "type": "blob",
          "size": 1.4580078125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"testing\"\n\t\"testing/quick\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n)\n\nfunc TestBinaryEncodingQuick(t *testing.T) {\n\tt.Parallel()\n\troundtrip := func(binary []byte) bool {\n\t\tencoded := EncodeBinaryHeader(binary)\n\t\tdecoded, err := DecodeBinaryHeader(encoded)\n\t\tif err != nil {\n\t\t\t// We want to abort immediately. Don't use our assert package.\n\t\t\tt.Fatalf(\"decode error: %v\", err)\n\t\t}\n\t\treturn bytes.Equal(decoded, binary)\n\t}\n\tif err := quick.Check(roundtrip, nil /* config */); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestHeaderMerge(t *testing.T) {\n\tt.Parallel()\n\theader := http.Header{\n\t\t\"Foo\": []string{\"one\"},\n\t}\n\tmergeHeaders(header, http.Header{\n\t\t\"Foo\": []string{\"two\"},\n\t\t\"Bar\": []string{\"one\"},\n\t\t\"Baz\": nil,\n\t})\n\texpect := http.Header{\n\t\t\"Foo\": []string{\"one\", \"two\"},\n\t\t\"Bar\": []string{\"one\"},\n\t}\n\tassert.Equal(t, header, expect)\n}\n"
        },
        {
          "name": "idempotency_level.go",
          "type": "blob",
          "size": 2.875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport \"fmt\"\n\n// An IdempotencyLevel is a value that declares how \"idempotent\" an RPC is. This\n// value can affect RPC behaviors, such as determining whether it is safe to\n// retry a request, or what kinds of request modalities are allowed for a given\n// procedure.\ntype IdempotencyLevel int\n\n// NOTE: For simplicity, these should be kept in sync with the values of the\n// google.protobuf.MethodOptions.IdempotencyLevel enumeration.\n\nconst (\n\t// IdempotencyUnknown is the default idempotency level. A procedure with\n\t// this idempotency level may not be idempotent. This is appropriate for\n\t// any kind of procedure.\n\tIdempotencyUnknown IdempotencyLevel = 0\n\n\t// IdempotencyNoSideEffects is the idempotency level that specifies that a\n\t// given call has no side-effects. This is equivalent to [RFC 9110 § 9.2.1]\n\t// \"safe\" methods in terms of semantics. This procedure should not mutate\n\t// any state. This idempotency level is appropriate for queries, or anything\n\t// that would be suitable for an HTTP GET request. In addition, due to the\n\t// lack of side-effects, such a procedure would be suitable to retry and\n\t// expect that the results will not be altered by preceding attempts.\n\t//\n\t// [RFC 9110 § 9.2.1]: https://www.rfc-editor.org/rfc/rfc9110.html#section-9.2.1\n\tIdempotencyNoSideEffects IdempotencyLevel = 1\n\n\t// IdempotencyIdempotent is the idempotency level that specifies that a\n\t// given call is \"idempotent\", such that multiple instances of the same\n\t// request to this procedure would have the same side-effects as a single\n\t// request. This is equivalent to [RFC 9110 § 9.2.2] \"idempotent\" methods.\n\t// This level is a subset of the previous level. This idempotency level is\n\t// appropriate for any procedure that is safe to retry multiple times\n\t// and be guaranteed that the response and side-effects will not be altered\n\t// as a result of multiple attempts, for example, entity deletion requests.\n\t//\n\t// [RFC 9110 § 9.2.2]: https://www.rfc-editor.org/rfc/rfc9110.html#section-9.2.2\n\tIdempotencyIdempotent IdempotencyLevel = 2\n)\n\nfunc (i IdempotencyLevel) String() string {\n\tswitch i {\n\tcase IdempotencyUnknown:\n\t\treturn \"idempotency_unknown\"\n\tcase IdempotencyNoSideEffects:\n\t\treturn \"no_side_effects\"\n\tcase IdempotencyIdempotent:\n\t\treturn \"idempotent\"\n\t}\n\treturn fmt.Sprintf(\"idempotency_%d\", i)\n}\n"
        },
        {
          "name": "interceptor.go",
          "type": "blob",
          "size": 3.7568359375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"context\"\n)\n\n// UnaryFunc is the generic signature of a unary RPC. Interceptors may wrap\n// Funcs.\n//\n// The type of the request and response structs depend on the codec being used.\n// When using Protobuf, request.Any() and response.Any() will always be\n// [proto.Message] implementations.\ntype UnaryFunc func(context.Context, AnyRequest) (AnyResponse, error)\n\n// StreamingClientFunc is the generic signature of a streaming RPC from the client's\n// perspective. Interceptors may wrap StreamingClientFuncs.\ntype StreamingClientFunc func(context.Context, Spec) StreamingClientConn\n\n// StreamingHandlerFunc is the generic signature of a streaming RPC from the\n// handler's perspective. Interceptors may wrap StreamingHandlerFuncs.\ntype StreamingHandlerFunc func(context.Context, StreamingHandlerConn) error\n\n// An Interceptor adds logic to a generated handler or client, like the\n// decorators or middleware you may have seen in other libraries. Interceptors\n// may replace the context, mutate requests and responses, handle errors,\n// retry, recover from panics, emit logs and metrics, or do nearly anything\n// else.\n//\n// The returned functions must be safe to call concurrently.\ntype Interceptor interface {\n\tWrapUnary(UnaryFunc) UnaryFunc\n\tWrapStreamingClient(StreamingClientFunc) StreamingClientFunc\n\tWrapStreamingHandler(StreamingHandlerFunc) StreamingHandlerFunc\n}\n\n// UnaryInterceptorFunc is a simple Interceptor implementation that only\n// wraps unary RPCs. It has no effect on streaming RPCs.\ntype UnaryInterceptorFunc func(UnaryFunc) UnaryFunc\n\n// WrapUnary implements [Interceptor] by applying the interceptor function.\nfunc (f UnaryInterceptorFunc) WrapUnary(next UnaryFunc) UnaryFunc { return f(next) }\n\n// WrapStreamingClient implements [Interceptor] with a no-op.\nfunc (f UnaryInterceptorFunc) WrapStreamingClient(next StreamingClientFunc) StreamingClientFunc {\n\treturn next\n}\n\n// WrapStreamingHandler implements [Interceptor] with a no-op.\nfunc (f UnaryInterceptorFunc) WrapStreamingHandler(next StreamingHandlerFunc) StreamingHandlerFunc {\n\treturn next\n}\n\n// A chain composes multiple interceptors into one.\ntype chain struct {\n\tinterceptors []Interceptor\n}\n\n// newChain composes multiple interceptors into one.\nfunc newChain(interceptors []Interceptor) *chain {\n\t// We usually wrap in reverse order to have the first interceptor from\n\t// the slice act first. Rather than doing this dance repeatedly, reverse the\n\t// interceptor order now.\n\tvar chain chain\n\tfor i := len(interceptors) - 1; i >= 0; i-- {\n\t\tif interceptor := interceptors[i]; interceptor != nil {\n\t\t\tchain.interceptors = append(chain.interceptors, interceptor)\n\t\t}\n\t}\n\treturn &chain\n}\n\nfunc (c *chain) WrapUnary(next UnaryFunc) UnaryFunc {\n\tfor _, interceptor := range c.interceptors {\n\t\tnext = interceptor.WrapUnary(next)\n\t}\n\treturn next\n}\n\nfunc (c *chain) WrapStreamingClient(next StreamingClientFunc) StreamingClientFunc {\n\tfor _, interceptor := range c.interceptors {\n\t\tnext = interceptor.WrapStreamingClient(next)\n\t}\n\treturn next\n}\n\nfunc (c *chain) WrapStreamingHandler(next StreamingHandlerFunc) StreamingHandlerFunc {\n\tfor _, interceptor := range c.interceptors {\n\t\tnext = interceptor.WrapStreamingHandler(next)\n\t}\n\treturn next\n}\n"
        },
        {
          "name": "interceptor_example_test.go",
          "type": "blob",
          "size": 3.4140625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"os\"\n\n\tconnect \"connectrpc.com/connect\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n)\n\nfunc ExampleUnaryInterceptorFunc() {\n\tlogger := log.New(os.Stdout, \"\" /* prefix */, 0 /* flags */)\n\tloggingInterceptor := connect.UnaryInterceptorFunc(\n\t\tfunc(next connect.UnaryFunc) connect.UnaryFunc {\n\t\t\treturn connect.UnaryFunc(func(ctx context.Context, request connect.AnyRequest) (connect.AnyResponse, error) {\n\t\t\t\tlogger.Println(\"calling:\", request.Spec().Procedure)\n\t\t\t\tlogger.Println(\"request:\", request.Any())\n\t\t\t\tresponse, err := next(ctx, request)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Println(\"error:\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlogger.Println(\"response:\", response.Any())\n\t\t\t\t}\n\t\t\t\treturn response, err\n\t\t\t})\n\t\t},\n\t)\n\tclient := pingv1connect.NewPingServiceClient(\n\t\texamplePingServer.Client(),\n\t\texamplePingServer.URL(),\n\t\tconnect.WithInterceptors(loggingInterceptor),\n\t)\n\tif _, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{Number: 42})); err != nil {\n\t\tlogger.Println(\"error:\", err)\n\t\treturn\n\t}\n\n\t// Output:\n\t// calling: /connect.ping.v1.PingService/Ping\n\t// request: number:42\n\t// response: number:42\n}\n\nfunc ExampleWithInterceptors() {\n\tlogger := log.New(os.Stdout, \"\" /* prefix */, 0 /* flags */)\n\touter := connect.UnaryInterceptorFunc(\n\t\tfunc(next connect.UnaryFunc) connect.UnaryFunc {\n\t\t\treturn connect.UnaryFunc(func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {\n\t\t\t\tlogger.Println(\"outer interceptor: before call\")\n\t\t\t\tres, err := next(ctx, req)\n\t\t\t\tlogger.Println(\"outer interceptor: after call\")\n\t\t\t\treturn res, err\n\t\t\t})\n\t\t},\n\t)\n\tinner := connect.UnaryInterceptorFunc(\n\t\tfunc(next connect.UnaryFunc) connect.UnaryFunc {\n\t\t\treturn connect.UnaryFunc(func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {\n\t\t\t\tlogger.Println(\"inner interceptor: before call\")\n\t\t\t\tres, err := next(ctx, req)\n\t\t\t\tlogger.Println(\"inner interceptor: after call\")\n\t\t\t\treturn res, err\n\t\t\t})\n\t\t},\n\t)\n\tclient := pingv1connect.NewPingServiceClient(\n\t\texamplePingServer.Client(),\n\t\texamplePingServer.URL(),\n\t\tconnect.WithInterceptors(outer, inner),\n\t)\n\tif _, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{})); err != nil {\n\t\tlogger.Println(\"error:\", err)\n\t\treturn\n\t}\n\n\t// Output:\n\t// outer interceptor: before call\n\t// inner interceptor: before call\n\t// inner interceptor: after call\n\t// outer interceptor: after call\n}\n\nfunc ExampleWithConditionalHandlerOptions() {\n\tconnect.WithConditionalHandlerOptions(func(spec connect.Spec) []connect.HandlerOption {\n\t\tvar options []connect.HandlerOption\n\t\tif spec.Procedure == pingv1connect.PingServicePingProcedure {\n\t\t\toptions = append(options, connect.WithReadMaxBytes(1024))\n\t\t}\n\t\treturn options\n\t})\n\t// Output:\n}\n"
        },
        {
          "name": "interceptor_ext_test.go",
          "type": "blob",
          "size": 12.84765625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\tconnect \"connectrpc.com/connect\"\n\t\"connectrpc.com/connect/internal/assert\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n\t\"connectrpc.com/connect/internal/memhttp/memhttptest\"\n)\n\nfunc TestOnionOrderingEndToEnd(t *testing.T) {\n\tt.Parallel()\n\t// Helper function: returns a function that asserts that there's some value\n\t// set for header \"expect\", and adds a value for header \"add\".\n\tnewInspector := func(expect, add string) func(connect.Spec, http.Header) {\n\t\treturn func(spec connect.Spec, header http.Header) {\n\t\t\tif expect != \"\" {\n\t\t\t\tassert.NotZero(\n\t\t\t\t\tt,\n\t\t\t\t\theader.Get(expect),\n\t\t\t\t\tassert.Sprintf(\n\t\t\t\t\t\t\"%s (IsClient %v): header %q missing: %v\",\n\t\t\t\t\t\tspec.Procedure,\n\t\t\t\t\t\tspec.IsClient,\n\t\t\t\t\t\texpect,\n\t\t\t\t\t\theader,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t}\n\t\t\theader.Set(add, \"v\")\n\t\t}\n\t}\n\t// Helper function: asserts that there's a value present for header keys\n\t// \"one\", \"two\", \"three\", and \"four\".\n\tassertAllPresent := func(spec connect.Spec, header http.Header) {\n\t\tfor _, key := range []string{\"one\", \"two\", \"three\", \"four\"} {\n\t\t\tassert.NotZero(\n\t\t\t\tt,\n\t\t\t\theader.Get(key),\n\t\t\t\tassert.Sprintf(\n\t\t\t\t\t\"%s (IsClient %v): checking all headers, %q missing: %v\",\n\t\t\t\t\tspec.Procedure,\n\t\t\t\t\tspec.IsClient,\n\t\t\t\t\tkey,\n\t\t\t\t\theader,\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t}\n\n\tvar client1, client2, client3, handler1, handler2, handler3 atomic.Int32\n\n\t// The client and handler interceptor onions are the meat of the test. The\n\t// order of interceptor execution must be the same for unary and streaming\n\t// procedures.\n\t//\n\t// Requests should fall through the client onion from top to bottom, traverse\n\t// the network, and then fall through the handler onion from top to bottom.\n\t// Responses should climb up the handler onion, traverse the network, and\n\t// then climb up the client onion.\n\t//\n\t// The request and response sides of this onion are numbered to make the\n\t// intended order clear.\n\tclientOnion := connect.WithInterceptors(\n\t\tnewHeaderInterceptor(\n\t\t\t&client1,\n\t\t\t// 1 (start). request: should see protocol-related headers\n\t\t\tfunc(_ connect.Spec, h http.Header) {\n\t\t\t\tassert.NotZero(t, h.Get(\"Content-Type\"))\n\t\t\t},\n\t\t\t// 12 (end). response: check \"one\"-\"four\"\n\t\t\tassertAllPresent,\n\t\t),\n\t\tnewHeaderInterceptor(\n\t\t\t&client2,\n\t\t\tnewInspector(\"\", \"one\"),       // 2. request: add header \"one\"\n\t\t\tnewInspector(\"three\", \"four\"), // 11. response: check \"three\", add \"four\"\n\t\t),\n\t\tnewHeaderInterceptor(\n\t\t\t&client3,\n\t\t\tnewInspector(\"one\", \"two\"),   // 3. request: check \"one\", add \"two\"\n\t\t\tnewInspector(\"two\", \"three\"), // 10. response: check \"two\", add \"three\"\n\t\t),\n\t)\n\thandlerOnion := connect.WithInterceptors(\n\t\tnewHeaderInterceptor(\n\t\t\t&handler1,\n\t\t\tnewInspector(\"two\", \"three\"), // 4. request: check \"two\", add \"three\"\n\t\t\tnewInspector(\"one\", \"two\"),   // 9. response: check \"one\", add \"two\"\n\t\t),\n\t\tnewHeaderInterceptor(\n\t\t\t&handler2,\n\t\t\tnewInspector(\"three\", \"four\"), // 5. request: check \"three\", add \"four\"\n\t\t\tnewInspector(\"\", \"one\"),       // 8. response: add \"one\"\n\t\t),\n\t\tnewHeaderInterceptor(\n\t\t\t&handler3,\n\t\t\tassertAllPresent, // 6. request: check \"one\"-\"four\"\n\t\t\tnil,              // 7. response: no-op\n\t\t),\n\t)\n\n\tmux := http.NewServeMux()\n\tmux.Handle(\n\t\tpingv1connect.NewPingServiceHandler(\n\t\t\tpingServer{},\n\t\t\thandlerOnion,\n\t\t),\n\t)\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := pingv1connect.NewPingServiceClient(\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t\tclientOnion,\n\t)\n\n\t_, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{Number: 10}))\n\tassert.Nil(t, err)\n\n\t// make sure the interceptors were actually invoked\n\tassert.Equal(t, int32(1), client1.Load())\n\tassert.Equal(t, int32(1), client2.Load())\n\tassert.Equal(t, int32(1), client3.Load())\n\tassert.Equal(t, int32(1), handler1.Load())\n\tassert.Equal(t, int32(1), handler2.Load())\n\tassert.Equal(t, int32(1), handler3.Load())\n\n\tresponses, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{Number: 10}))\n\tassert.Nil(t, err)\n\tvar sum int64\n\tfor responses.Receive() {\n\t\tsum += responses.Msg().GetNumber()\n\t}\n\tassert.Equal(t, sum, 55)\n\tassert.Nil(t, responses.Close())\n\n\t// make sure the interceptors were invoked again\n\tassert.Equal(t, int32(2), client1.Load())\n\tassert.Equal(t, int32(2), client2.Load())\n\tassert.Equal(t, int32(2), client3.Load())\n\tassert.Equal(t, int32(2), handler1.Load())\n\tassert.Equal(t, int32(2), handler2.Load())\n\tassert.Equal(t, int32(2), handler3.Load())\n}\n\nfunc TestEmptyUnaryInterceptorFunc(t *testing.T) {\n\tt.Parallel()\n\tmux := http.NewServeMux()\n\tinterceptor := connect.UnaryInterceptorFunc(func(next connect.UnaryFunc) connect.UnaryFunc {\n\t\treturn func(ctx context.Context, request connect.AnyRequest) (connect.AnyResponse, error) {\n\t\t\treturn next(ctx, request)\n\t\t}\n\t})\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pingServer{}, connect.WithInterceptors(interceptor)))\n\tserver := memhttptest.NewServer(t, mux)\n\tconnectClient := pingv1connect.NewPingServiceClient(server.Client(), server.URL(), connect.WithInterceptors(interceptor))\n\t_, err := connectClient.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{}))\n\tassert.Nil(t, err)\n\tsumStream := connectClient.Sum(context.Background())\n\tassert.Nil(t, sumStream.Send(&pingv1.SumRequest{Number: 1}))\n\tresp, err := sumStream.CloseAndReceive()\n\tassert.Nil(t, err)\n\tassert.NotNil(t, resp)\n\tcountUpStream, err := connectClient.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{}))\n\tassert.Nil(t, err)\n\tfor countUpStream.Receive() {\n\t\tassert.NotNil(t, countUpStream.Msg())\n\t}\n\tassert.Nil(t, countUpStream.Close())\n}\n\nfunc TestInterceptorFuncAccessingHTTPMethod(t *testing.T) {\n\tt.Parallel()\n\tclientChecker := &httpMethodChecker{client: true}\n\thandlerChecker := &httpMethodChecker{}\n\n\tmux := http.NewServeMux()\n\tmux.Handle(\n\t\tpingv1connect.NewPingServiceHandler(\n\t\t\tpingServer{},\n\t\t\tconnect.WithInterceptors(handlerChecker),\n\t\t),\n\t)\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := pingv1connect.NewPingServiceClient(\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t\tconnect.WithInterceptors(clientChecker),\n\t)\n\n\tpingReq := connect.NewRequest(&pingv1.PingRequest{Number: 10})\n\tassert.Equal(t, \"\", pingReq.HTTPMethod())\n\t_, err := client.Ping(context.Background(), pingReq)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.MethodPost, pingReq.HTTPMethod())\n\n\t// make sure interceptor was invoked\n\tassert.Equal(t, int32(1), clientChecker.count.Load())\n\tassert.Equal(t, int32(1), handlerChecker.count.Load())\n\n\tcountUpReq := connect.NewRequest(&pingv1.CountUpRequest{Number: 10})\n\tassert.Equal(t, \"\", countUpReq.HTTPMethod())\n\tresponses, err := client.CountUp(context.Background(), countUpReq)\n\tassert.Nil(t, err)\n\tvar sum int64\n\tfor responses.Receive() {\n\t\tsum += responses.Msg().GetNumber()\n\t}\n\tassert.Equal(t, sum, 55)\n\tassert.Nil(t, responses.Close())\n\tassert.Equal(t, http.MethodPost, countUpReq.HTTPMethod())\n\n\t// make sure interceptor was invoked again\n\tassert.Equal(t, int32(2), clientChecker.count.Load())\n\tassert.Equal(t, int32(2), handlerChecker.count.Load())\n}\n\n// headerInterceptor makes it easier to write interceptors that inspect or\n// mutate HTTP headers. It applies the same logic to unary and streaming\n// procedures, wrapping the send or receive side of the stream as appropriate.\n//\n// It's useful as a testing harness to make sure that we're chaining\n// interceptors in the correct order.\ntype headerInterceptor struct {\n\tcounter               *atomic.Int32\n\tinspectRequestHeader  func(connect.Spec, http.Header)\n\tinspectResponseHeader func(connect.Spec, http.Header)\n}\n\n// newHeaderInterceptor constructs a headerInterceptor. Nil function pointers\n// are treated as no-ops.\nfunc newHeaderInterceptor(\n\tcounter *atomic.Int32,\n\tinspectRequestHeader func(connect.Spec, http.Header),\n\tinspectResponseHeader func(connect.Spec, http.Header),\n) *headerInterceptor {\n\tinterceptor := headerInterceptor{\n\t\tcounter:               counter,\n\t\tinspectRequestHeader:  inspectRequestHeader,\n\t\tinspectResponseHeader: inspectResponseHeader,\n\t}\n\tif interceptor.inspectRequestHeader == nil {\n\t\tinterceptor.inspectRequestHeader = func(_ connect.Spec, _ http.Header) {}\n\t}\n\tif interceptor.inspectResponseHeader == nil {\n\t\tinterceptor.inspectResponseHeader = func(_ connect.Spec, _ http.Header) {}\n\t}\n\treturn &interceptor\n}\n\nfunc (h *headerInterceptor) WrapUnary(next connect.UnaryFunc) connect.UnaryFunc {\n\treturn func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {\n\t\th.counter.Add(1)\n\t\th.inspectRequestHeader(req.Spec(), req.Header())\n\t\tres, err := next(ctx, req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\th.inspectResponseHeader(req.Spec(), res.Header())\n\t\treturn res, nil\n\t}\n}\n\nfunc (h *headerInterceptor) WrapStreamingClient(next connect.StreamingClientFunc) connect.StreamingClientFunc {\n\treturn func(ctx context.Context, spec connect.Spec) connect.StreamingClientConn {\n\t\th.counter.Add(1)\n\t\treturn &headerInspectingClientConn{\n\t\t\tStreamingClientConn:   next(ctx, spec),\n\t\t\tinspectRequestHeader:  h.inspectRequestHeader,\n\t\t\tinspectResponseHeader: h.inspectResponseHeader,\n\t\t}\n\t}\n}\n\nfunc (h *headerInterceptor) WrapStreamingHandler(next connect.StreamingHandlerFunc) connect.StreamingHandlerFunc {\n\treturn func(ctx context.Context, conn connect.StreamingHandlerConn) error {\n\t\th.counter.Add(1)\n\t\th.inspectRequestHeader(conn.Spec(), conn.RequestHeader())\n\t\treturn next(ctx, &headerInspectingHandlerConn{\n\t\t\tStreamingHandlerConn:  conn,\n\t\t\tinspectResponseHeader: h.inspectResponseHeader,\n\t\t})\n\t}\n}\n\ntype headerInspectingHandlerConn struct {\n\tconnect.StreamingHandlerConn\n\n\tinspectedResponse     bool\n\tinspectResponseHeader func(connect.Spec, http.Header)\n}\n\nfunc (hc *headerInspectingHandlerConn) Send(msg any) error {\n\tif !hc.inspectedResponse {\n\t\thc.inspectResponseHeader(hc.Spec(), hc.ResponseHeader())\n\t\thc.inspectedResponse = true\n\t}\n\treturn hc.StreamingHandlerConn.Send(msg)\n}\n\ntype headerInspectingClientConn struct {\n\tconnect.StreamingClientConn\n\n\tinspectedRequest      bool\n\tinspectRequestHeader  func(connect.Spec, http.Header)\n\tinspectedResponse     bool\n\tinspectResponseHeader func(connect.Spec, http.Header)\n}\n\nfunc (cc *headerInspectingClientConn) Send(msg any) error {\n\tif !cc.inspectedRequest {\n\t\tcc.inspectRequestHeader(cc.Spec(), cc.RequestHeader())\n\t\tcc.inspectedRequest = true\n\t}\n\treturn cc.StreamingClientConn.Send(msg)\n}\n\nfunc (cc *headerInspectingClientConn) Receive(msg any) error {\n\terr := cc.StreamingClientConn.Receive(msg)\n\tif !cc.inspectedResponse {\n\t\tcc.inspectResponseHeader(cc.Spec(), cc.ResponseHeader())\n\t\tcc.inspectedResponse = true\n\t}\n\treturn err\n}\n\ntype httpMethodChecker struct {\n\tclient bool\n\tcount  atomic.Int32\n}\n\nfunc (h *httpMethodChecker) WrapUnary(unaryFunc connect.UnaryFunc) connect.UnaryFunc {\n\treturn func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {\n\t\th.count.Add(1)\n\t\tif h.client {\n\t\t\t// should be blank until after we make request\n\t\t\tif req.HTTPMethod() != \"\" {\n\t\t\t\treturn nil, fmt.Errorf(\"expected blank HTTP method but instead got %q\", req.HTTPMethod())\n\t\t\t}\n\t\t} else {\n\t\t\t// server interceptors see method from the start\n\t\t\t// NB: In theory, the method could also be GET, not just POST. But for the\n\t\t\t// configuration under test, it will always be POST.\n\t\t\tif req.HTTPMethod() != http.MethodPost {\n\t\t\t\treturn nil, fmt.Errorf(\"expected HTTP method %s but instead got %q\", http.MethodPost, req.HTTPMethod())\n\t\t\t}\n\t\t}\n\t\tresp, err := unaryFunc(ctx, req)\n\t\t// NB: In theory, the method could also be GET, not just POST. But for the\n\t\t// configuration under test, it will always be POST.\n\t\tif req.HTTPMethod() != http.MethodPost {\n\t\t\treturn nil, fmt.Errorf(\"expected HTTP method %s but instead got %q\", http.MethodPost, req.HTTPMethod())\n\t\t}\n\t\treturn resp, err\n\t}\n}\n\nfunc (h *httpMethodChecker) WrapStreamingClient(clientFunc connect.StreamingClientFunc) connect.StreamingClientFunc {\n\treturn func(ctx context.Context, spec connect.Spec) connect.StreamingClientConn {\n\t\t// method not exposed to streaming interceptor, but that's okay because it's always POST for streams\n\t\th.count.Add(1)\n\t\treturn clientFunc(ctx, spec)\n\t}\n}\n\nfunc (h *httpMethodChecker) WrapStreamingHandler(handlerFunc connect.StreamingHandlerFunc) connect.StreamingHandlerFunc {\n\treturn func(ctx context.Context, conn connect.StreamingHandlerConn) error {\n\t\t// method not exposed to streaming interceptor, but that's okay because it's always POST for streams\n\t\th.count.Add(1)\n\t\treturn handlerFunc(ctx, conn)\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 22.013671875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"compress/gzip\"\n\t\"context\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// A ClientOption configures a [Client].\n//\n// In addition to any options grouped in the documentation below, remember that\n// any [Option] is also a valid ClientOption.\ntype ClientOption interface {\n\tapplyToClient(*clientConfig)\n}\n\n// WithAcceptCompression makes a compression algorithm available to a client.\n// Clients ask servers to compress responses using any of the registered\n// algorithms. The first registered algorithm is treated as the least\n// preferred, and the last registered algorithm is the most preferred.\n//\n// It's safe to use this option liberally: servers will ignore any\n// compression algorithms they don't support. To compress requests, pair this\n// option with [WithSendCompression]. To remove support for a\n// previously-registered compression algorithm, use WithAcceptCompression with\n// nil decompressor and compressor constructors.\n//\n// Clients accept gzipped responses by default, using a compressor backed by the\n// standard library's [gzip] package with the default compression level. Use\n// [WithSendGzip] to compress requests with gzip.\n//\n// Calling WithAcceptCompression with an empty name is a no-op.\nfunc WithAcceptCompression(\n\tname string,\n\tnewDecompressor func() Decompressor,\n\tnewCompressor func() Compressor,\n) ClientOption {\n\treturn &compressionOption{\n\t\tName:            name,\n\t\tCompressionPool: newCompressionPool(newDecompressor, newCompressor),\n\t}\n}\n\n// WithClientOptions composes multiple ClientOptions into one.\nfunc WithClientOptions(options ...ClientOption) ClientOption {\n\treturn &clientOptionsOption{options}\n}\n\n// WithGRPC configures clients to use the HTTP/2 gRPC protocol.\nfunc WithGRPC() ClientOption {\n\treturn &grpcOption{web: false}\n}\n\n// WithGRPCWeb configures clients to use the gRPC-Web protocol.\nfunc WithGRPCWeb() ClientOption {\n\treturn &grpcOption{web: true}\n}\n\n// WithProtoJSON configures a client to send JSON-encoded data instead of\n// binary Protobuf. It uses the standard Protobuf JSON mapping as implemented\n// by [google.golang.org/protobuf/encoding/protojson]: fields are named using\n// lowerCamelCase, zero values are omitted, missing required fields are errors,\n// enums are emitted as strings, etc.\nfunc WithProtoJSON() ClientOption {\n\treturn WithCodec(&protoJSONCodec{codecNameJSON})\n}\n\n// WithSendCompression configures the client to use the specified algorithm to\n// compress request messages. If the algorithm has not been registered using\n// [WithAcceptCompression], the client will return errors at runtime.\n//\n// Because some servers don't support compression, clients default to sending\n// uncompressed requests.\nfunc WithSendCompression(name string) ClientOption {\n\treturn &sendCompressionOption{Name: name}\n}\n\n// WithSendGzip configures the client to gzip requests. Since clients have\n// access to a gzip compressor by default, WithSendGzip doesn't require\n// [WithSendCompression].\n//\n// Some servers don't support gzip, so clients default to sending uncompressed\n// requests.\nfunc WithSendGzip() ClientOption {\n\treturn WithSendCompression(compressionGzip)\n}\n\n// A HandlerOption configures a [Handler].\n//\n// In addition to any options grouped in the documentation below, remember that\n// any [Option] is also a HandlerOption.\ntype HandlerOption interface {\n\tapplyToHandler(*handlerConfig)\n}\n\n// WithCompression configures handlers to support a compression algorithm.\n// Clients may send messages compressed with that algorithm and/or request\n// compressed responses. The [Compressor] and [Decompressor] produced by the\n// supplied constructors must use the same algorithm. Internally, Connect pools\n// compressors and decompressors.\n//\n// By default, handlers support gzip using the standard library's\n// [compress/gzip] package at the default compression level. To remove support for\n// a previously-registered compression algorithm, use WithCompression with nil\n// decompressor and compressor constructors.\n//\n// Calling WithCompression with an empty name is a no-op.\nfunc WithCompression(\n\tname string,\n\tnewDecompressor func() Decompressor,\n\tnewCompressor func() Compressor,\n) HandlerOption {\n\treturn &compressionOption{\n\t\tName:            name,\n\t\tCompressionPool: newCompressionPool(newDecompressor, newCompressor),\n\t}\n}\n\n// WithHandlerOptions composes multiple HandlerOptions into one.\nfunc WithHandlerOptions(options ...HandlerOption) HandlerOption {\n\treturn &handlerOptionsOption{options}\n}\n\n// WithRecover adds an interceptor that recovers from panics. The supplied\n// function receives the context, [Spec], request headers, and the recovered\n// value (which may be nil). It must return an error to send back to the\n// client. It may also log the panic, emit metrics, or execute other\n// error-handling logic. Handler functions must be safe to call concurrently.\n//\n// To preserve compatibility with [net/http]'s semantics, this interceptor\n// doesn't handle panics with [http.ErrAbortHandler].\n//\n// By default, handlers don't recover from panics. Because the standard\n// library's [http.Server] recovers from panics by default, this option isn't\n// usually necessary to prevent crashes. Instead, it helps servers collect\n// RPC-specific data during panics and send a more detailed error to\n// clients.\nfunc WithRecover(handle func(context.Context, Spec, http.Header, any) error) HandlerOption {\n\treturn WithInterceptors(&recoverHandlerInterceptor{handle: handle})\n}\n\n// WithRequireConnectProtocolHeader configures the Handler to require requests\n// using the Connect RPC protocol to include the Connect-Protocol-Version\n// header. This ensures that HTTP proxies and net/http middleware can easily\n// identify valid Connect requests, even if they use a common Content-Type like\n// application/json. However, it makes ad-hoc requests with tools like cURL\n// more laborious. Streaming requests are not affected by this option.\n//\n// This option has no effect if the client uses the gRPC or gRPC-Web protocols.\nfunc WithRequireConnectProtocolHeader() HandlerOption {\n\treturn &requireConnectProtocolHeaderOption{}\n}\n\n// WithConditionalHandlerOptions allows procedures in the same service to have\n// different configurations: for example, one procedure may need a much larger\n// WithReadMaxBytes setting than the others.\n//\n// WithConditionalHandlerOptions takes a function which may inspect each\n// procedure's Spec before deciding which options to apply. Returning a nil\n// slice is safe.\nfunc WithConditionalHandlerOptions(conditional func(spec Spec) []HandlerOption) HandlerOption {\n\treturn &conditionalHandlerOptions{conditional: conditional}\n}\n\n// Option implements both [ClientOption] and [HandlerOption], so it can be\n// applied both client-side and server-side.\ntype Option interface {\n\tClientOption\n\tHandlerOption\n}\n\n// WithSchema provides a parsed representation of the schema for an RPC to a\n// client or handler. The supplied schema is exposed as [Spec.Schema]. This\n// option is typically added by generated code.\n//\n// For services using protobuf schemas, the supplied schema should be a\n// [protoreflect.MethodDescriptor].\nfunc WithSchema(schema any) Option {\n\treturn &schemaOption{Schema: schema}\n}\n\n// WithRequestInitializer provides a function that initializes a new message.\n// It may be used to dynamically construct request messages. It is called on\n// server receives to construct the message to be unmarshaled into. The message\n// will be a non nil pointer to the type created by the handler. Use the Schema\n// field of the [Spec] to determine the type of the message.\nfunc WithRequestInitializer(initializer func(spec Spec, message any) error) HandlerOption {\n\treturn &initializerOption{Initializer: initializer}\n}\n\n// WithResponseInitializer provides a function that initializes a new message.\n// It may be used to dynamically construct response messages. It is called on\n// client receives to construct the message to be unmarshaled into. The message\n// will be a non nil pointer to the type created by the client. Use the Schema\n// field of the [Spec] to determine the type of the message.\nfunc WithResponseInitializer(initializer func(spec Spec, message any) error) ClientOption {\n\treturn &initializerOption{Initializer: initializer}\n}\n\n// WithCodec registers a serialization method with a client or handler.\n// Handlers may have multiple codecs registered, and use whichever the client\n// chooses. Clients may only have a single codec.\n//\n// By default, handlers and clients support binary Protocol Buffer data using\n// [google.golang.org/protobuf/proto]. Handlers also support JSON by default,\n// using the standard Protobuf JSON mapping. Users with more specialized needs\n// may override the default codecs by registering a new codec under the \"proto\"\n// or \"json\" names. When supplying a custom \"proto\" codec, keep in mind that\n// some unexported, protocol-specific messages are serialized using Protobuf -\n// take care to fall back to the standard Protobuf implementation if\n// necessary.\n//\n// Registering a codec with an empty name is a no-op.\nfunc WithCodec(codec Codec) Option {\n\treturn &codecOption{Codec: codec}\n}\n\n// WithCompressMinBytes sets a minimum size threshold for compression:\n// regardless of compressor configuration, messages smaller than the configured\n// minimum are sent uncompressed.\n//\n// The default minimum is zero. Setting a minimum compression threshold may\n// improve overall performance, because the CPU cost of compressing very small\n// messages usually isn't worth the small reduction in network I/O.\nfunc WithCompressMinBytes(minBytes int) Option {\n\treturn &compressMinBytesOption{Min: minBytes}\n}\n\n// WithReadMaxBytes limits the performance impact of pathologically large\n// messages sent by the other party. For handlers, WithReadMaxBytes limits the size\n// of a message that the client can send. For clients, WithReadMaxBytes limits the\n// size of a message that the server can respond with. Limits apply to each Protobuf\n// message, not to the stream as a whole.\n//\n// Setting WithReadMaxBytes to zero allows any message size. Both clients and\n// handlers default to allowing any request size.\n//\n// Handlers may also use [http.MaxBytesHandler] to limit the total size of the\n// HTTP request stream (rather than the per-message size). Connect handles\n// [http.MaxBytesError] specially, so clients still receive errors with the\n// appropriate error code and informative messages.\nfunc WithReadMaxBytes(maxBytes int) Option {\n\treturn &readMaxBytesOption{Max: maxBytes}\n}\n\n// WithSendMaxBytes prevents sending messages too large for the client/handler\n// to handle without significant performance overhead. For handlers, WithSendMaxBytes\n// limits the size of a message that the handler can respond with. For clients,\n// WithSendMaxBytes limits the size of a message that the client can send. Limits\n// apply to each message, not to the stream as a whole.\n//\n// Setting WithSendMaxBytes to zero allows any message size. Both clients and\n// handlers default to allowing any message size.\nfunc WithSendMaxBytes(maxBytes int) Option {\n\treturn &sendMaxBytesOption{Max: maxBytes}\n}\n\n// WithIdempotency declares the idempotency of the procedure. This can determine\n// whether a procedure call can safely be retried, and may affect which request\n// modalities are allowed for a given procedure call.\n//\n// In most cases, you should not need to manually set this. It is normally set\n// by the code generator for your schema. For protobuf schemas, it can be set like this:\n//\n//\trpc Ping(PingRequest) returns (PingResponse) {\n//\t  option idempotency_level = NO_SIDE_EFFECTS;\n//\t}\nfunc WithIdempotency(idempotencyLevel IdempotencyLevel) Option {\n\treturn &idempotencyOption{idempotencyLevel: idempotencyLevel}\n}\n\n// WithHTTPGet allows Connect-protocol clients to use HTTP GET requests for\n// side-effect free unary RPC calls. Typically, the service schema indicates\n// which procedures are idempotent (see [WithIdempotency] for an example\n// protobuf schema). The gRPC and gRPC-Web protocols are POST-only, so this\n// option has no effect when combined with [WithGRPC] or [WithGRPCWeb].\n//\n// Using HTTP GET requests makes it easier to take advantage of CDNs, caching\n// reverse proxies, and browsers' built-in caching. Note, however, that servers\n// don't automatically set any cache headers; you can set cache headers using\n// interceptors or by adding headers in individual procedure implementations.\n//\n// By default, all requests are made as HTTP POSTs.\nfunc WithHTTPGet() ClientOption {\n\treturn &enableGet{}\n}\n\n// WithInterceptors configures a client or handler's interceptor stack. Repeated\n// WithInterceptors options are applied in order, so\n//\n//\tWithInterceptors(A) + WithInterceptors(B, C) == WithInterceptors(A, B, C)\n//\n// Unary interceptors compose like an onion. The first interceptor provided is\n// the outermost layer of the onion: it acts first on the context and request,\n// and last on the response and error.\n//\n// Stream interceptors also behave like an onion: the first interceptor\n// provided is the outermost wrapper for the [StreamingClientConn] or\n// [StreamingHandlerConn]. It's the first to see sent messages and the last to\n// see received messages.\n//\n// Applied to client and handler, WithInterceptors(A, B, ..., Y, Z) produces:\n//\n//\t client.Send()       client.Receive()\n//\t       |                   ^\n//\t       v                   |\n//\t    A ---                 --- A\n//\t    B ---                 --- B\n//\t    : ...                 ... :\n//\t    Y ---                 --- Y\n//\t    Z ---                 --- Z\n//\t       |                   ^\n//\t       v                   |\n//\t  = = = = = = = = = = = = = = = =\n//\t               network\n//\t  = = = = = = = = = = = = = = = =\n//\t       |                   ^\n//\t       v                   |\n//\t    A ---                 --- A\n//\t    B ---                 --- B\n//\t    : ...                 ... :\n//\t    Y ---                 --- Y\n//\t    Z ---                 --- Z\n//\t       |                   ^\n//\t       v                   |\n//\thandler.Receive()   handler.Send()\n//\t       |                   ^\n//\t       |                   |\n//\t       '-> handler logic >-'\n//\n// Note that in clients, Send handles the request message(s) and Receive\n// handles the response message(s). For handlers, it's the reverse. Depending\n// on your interceptor's logic, you may need to wrap one method in clients and\n// the other in handlers.\nfunc WithInterceptors(interceptors ...Interceptor) Option {\n\treturn &interceptorsOption{interceptors}\n}\n\n// WithOptions composes multiple Options into one.\nfunc WithOptions(options ...Option) Option {\n\treturn &optionsOption{options}\n}\n\ntype schemaOption struct {\n\tSchema any\n}\n\nfunc (o *schemaOption) applyToClient(config *clientConfig) {\n\tconfig.Schema = o.Schema\n}\n\nfunc (o *schemaOption) applyToHandler(config *handlerConfig) {\n\tconfig.Schema = o.Schema\n}\n\ntype initializerOption struct {\n\tInitializer func(spec Spec, message any) error\n}\n\nfunc (o *initializerOption) applyToHandler(config *handlerConfig) {\n\tconfig.Initializer = maybeInitializer{initializer: o.Initializer}\n}\n\nfunc (o *initializerOption) applyToClient(config *clientConfig) {\n\tconfig.Initializer = maybeInitializer{initializer: o.Initializer}\n}\n\ntype maybeInitializer struct {\n\tinitializer func(spec Spec, message any) error\n}\n\nfunc (o maybeInitializer) maybe(spec Spec, message any) error {\n\tif o.initializer != nil {\n\t\treturn o.initializer(spec, message)\n\t}\n\treturn nil\n}\n\ntype clientOptionsOption struct {\n\toptions []ClientOption\n}\n\nfunc (o *clientOptionsOption) applyToClient(config *clientConfig) {\n\tfor _, option := range o.options {\n\t\toption.applyToClient(config)\n\t}\n}\n\ntype codecOption struct {\n\tCodec Codec\n}\n\nfunc (o *codecOption) applyToClient(config *clientConfig) {\n\tif o.Codec == nil || o.Codec.Name() == \"\" {\n\t\treturn\n\t}\n\tconfig.Codec = o.Codec\n}\n\nfunc (o *codecOption) applyToHandler(config *handlerConfig) {\n\tif o.Codec == nil || o.Codec.Name() == \"\" {\n\t\treturn\n\t}\n\tconfig.Codecs[o.Codec.Name()] = o.Codec\n}\n\ntype compressionOption struct {\n\tName            string\n\tCompressionPool *compressionPool\n}\n\nfunc (o *compressionOption) applyToClient(config *clientConfig) {\n\to.apply(&config.CompressionNames, config.CompressionPools)\n}\n\nfunc (o *compressionOption) applyToHandler(config *handlerConfig) {\n\to.apply(&config.CompressionNames, config.CompressionPools)\n}\n\nfunc (o *compressionOption) apply(configuredNames *[]string, configuredPools map[string]*compressionPool) {\n\tif o.Name == \"\" {\n\t\treturn\n\t}\n\tif o.CompressionPool == nil {\n\t\tdelete(configuredPools, o.Name)\n\t\tvar names []string\n\t\tfor _, name := range *configuredNames {\n\t\t\tif name == o.Name {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnames = append(names, name)\n\t\t}\n\t\t*configuredNames = names\n\t\treturn\n\t}\n\tconfiguredPools[o.Name] = o.CompressionPool\n\t*configuredNames = append(*configuredNames, o.Name)\n}\n\ntype compressMinBytesOption struct {\n\tMin int\n}\n\nfunc (o *compressMinBytesOption) applyToClient(config *clientConfig) {\n\tconfig.CompressMinBytes = o.Min\n}\n\nfunc (o *compressMinBytesOption) applyToHandler(config *handlerConfig) {\n\tconfig.CompressMinBytes = o.Min\n}\n\ntype readMaxBytesOption struct {\n\tMax int\n}\n\nfunc (o *readMaxBytesOption) applyToClient(config *clientConfig) {\n\tconfig.ReadMaxBytes = o.Max\n}\n\nfunc (o *readMaxBytesOption) applyToHandler(config *handlerConfig) {\n\tconfig.ReadMaxBytes = o.Max\n}\n\ntype sendMaxBytesOption struct {\n\tMax int\n}\n\nfunc (o *sendMaxBytesOption) applyToClient(config *clientConfig) {\n\tconfig.SendMaxBytes = o.Max\n}\n\nfunc (o *sendMaxBytesOption) applyToHandler(config *handlerConfig) {\n\tconfig.SendMaxBytes = o.Max\n}\n\ntype handlerOptionsOption struct {\n\toptions []HandlerOption\n}\n\nfunc (o *handlerOptionsOption) applyToHandler(config *handlerConfig) {\n\tfor _, option := range o.options {\n\t\toption.applyToHandler(config)\n\t}\n}\n\ntype requireConnectProtocolHeaderOption struct{}\n\nfunc (o *requireConnectProtocolHeaderOption) applyToHandler(config *handlerConfig) {\n\tconfig.RequireConnectProtocolHeader = true\n}\n\ntype idempotencyOption struct {\n\tidempotencyLevel IdempotencyLevel\n}\n\nfunc (o *idempotencyOption) applyToClient(config *clientConfig) {\n\tconfig.IdempotencyLevel = o.idempotencyLevel\n}\n\nfunc (o *idempotencyOption) applyToHandler(config *handlerConfig) {\n\tconfig.IdempotencyLevel = o.idempotencyLevel\n}\n\ntype grpcOption struct {\n\tweb bool\n}\n\nfunc (o *grpcOption) applyToClient(config *clientConfig) {\n\tconfig.Protocol = &protocolGRPC{web: o.web}\n}\n\ntype enableGet struct{}\n\nfunc (o *enableGet) applyToClient(config *clientConfig) {\n\tconfig.EnableGet = true\n}\n\n// WithHTTPGetMaxURLSize sets the maximum allowable URL length for GET requests\n// made using the Connect protocol. It has no effect on gRPC or gRPC-Web\n// clients, since those protocols are POST-only.\n//\n// Limiting the URL size is useful as most user agents, proxies, and servers\n// have limits on the allowable length of a URL. For example, Apache and Nginx\n// limit the size of a request line to around 8 KiB, meaning that maximum\n// length of a URL is a bit smaller than this. If you run into URL size\n// limitations imposed by your network infrastructure and don't know the\n// maximum allowable size, or if you'd prefer to be cautious from the start, a\n// 4096 byte (4 KiB) limit works with most common proxies and CDNs.\n//\n// If fallback is set to true and the URL would be longer than the configured\n// maximum value, the request will be sent as an HTTP POST instead. If fallback\n// is set to false, the request will fail with [CodeResourceExhausted].\n//\n// By default, Connect-protocol clients with GET requests enabled may send a\n// URL of any size.\nfunc WithHTTPGetMaxURLSize(bytes int, fallback bool) ClientOption {\n\treturn &getURLMaxBytes{Max: bytes, Fallback: fallback}\n}\n\ntype getURLMaxBytes struct {\n\tMax      int\n\tFallback bool\n}\n\nfunc (o *getURLMaxBytes) applyToClient(config *clientConfig) {\n\tconfig.GetURLMaxBytes = o.Max\n\tconfig.GetUseFallback = o.Fallback\n}\n\ntype interceptorsOption struct {\n\tInterceptors []Interceptor\n}\n\nfunc (o *interceptorsOption) applyToClient(config *clientConfig) {\n\tconfig.Interceptor = o.chainWith(config.Interceptor)\n}\n\nfunc (o *interceptorsOption) applyToHandler(config *handlerConfig) {\n\tconfig.Interceptor = o.chainWith(config.Interceptor)\n}\n\nfunc (o *interceptorsOption) chainWith(current Interceptor) Interceptor {\n\tif len(o.Interceptors) == 0 {\n\t\treturn current\n\t}\n\tif current == nil && len(o.Interceptors) == 1 {\n\t\treturn o.Interceptors[0]\n\t}\n\tif current == nil && len(o.Interceptors) > 1 {\n\t\treturn newChain(o.Interceptors)\n\t}\n\treturn newChain(append([]Interceptor{current}, o.Interceptors...))\n}\n\ntype optionsOption struct {\n\toptions []Option\n}\n\nfunc (o *optionsOption) applyToClient(config *clientConfig) {\n\tfor _, option := range o.options {\n\t\toption.applyToClient(config)\n\t}\n}\n\nfunc (o *optionsOption) applyToHandler(config *handlerConfig) {\n\tfor _, option := range o.options {\n\t\toption.applyToHandler(config)\n\t}\n}\n\ntype sendCompressionOption struct {\n\tName string\n}\n\nfunc (o *sendCompressionOption) applyToClient(config *clientConfig) {\n\tconfig.RequestCompressionName = o.Name\n}\n\nfunc withGzip() Option {\n\treturn &compressionOption{\n\t\tName: compressionGzip,\n\t\tCompressionPool: newCompressionPool(\n\t\t\tfunc() Decompressor { return &gzip.Reader{} },\n\t\t\tfunc() Compressor { return gzip.NewWriter(io.Discard) },\n\t\t),\n\t}\n}\n\nfunc withProtoBinaryCodec() Option {\n\treturn WithCodec(&protoBinaryCodec{})\n}\n\nfunc withProtoJSONCodecs() HandlerOption {\n\treturn WithHandlerOptions(\n\t\tWithCodec(&protoJSONCodec{codecNameJSON}),\n\t\tWithCodec(&protoJSONCodec{codecNameJSONCharsetUTF8}),\n\t)\n}\n\ntype conditionalHandlerOptions struct {\n\tconditional func(spec Spec) []HandlerOption\n}\n\nfunc (o *conditionalHandlerOptions) applyToHandler(config *handlerConfig) {\n\tspec := config.newSpec()\n\tif spec.Procedure == \"\" {\n\t\treturn // ignore empty specs\n\t}\n\tfor _, option := range o.conditional(spec) {\n\t\toption.applyToHandler(config)\n\t}\n}\n"
        },
        {
          "name": "protobuf_util.go",
          "type": "blob",
          "size": 1.240234375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"strings\"\n)\n\n// extractProtoPath returns the trailing portion of the URL's path,\n// corresponding to the Protobuf package, service, and method. It always starts\n// with a slash. Within connect, we use this as (1) Spec.Procedure and (2) the\n// path when mounting handlers on muxes.\nfunc extractProtoPath(path string) string {\n\tsegments := strings.Split(path, \"/\")\n\tvar pkg, method string\n\tif len(segments) > 0 {\n\t\tpkg = segments[0]\n\t}\n\tif len(segments) > 1 {\n\t\tpkg = segments[len(segments)-2]\n\t\tmethod = segments[len(segments)-1]\n\t}\n\tif pkg == \"\" {\n\t\treturn \"/\"\n\t}\n\tif method == \"\" {\n\t\treturn \"/\" + pkg\n\t}\n\treturn \"/\" + pkg + \"/\" + method\n}\n"
        },
        {
          "name": "protobuf_util_test.go",
          "type": "blob",
          "size": 1.53515625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n)\n\nfunc TestParseProtobufURL(t *testing.T) {\n\tt.Parallel()\n\tassertExtractedProtoPath(\n\t\tt,\n\t\t// full URL\n\t\t\"https://api.foo.com/grpc/foo.user.v1.UserService/GetUser\",\n\t\t\"/foo.user.v1.UserService/GetUser\",\n\t)\n\tassertExtractedProtoPath(\n\t\tt,\n\t\t// rooted path\n\t\t\"/foo.user.v1.UserService/GetUser\",\n\t\t\"/foo.user.v1.UserService/GetUser\",\n\t)\n\tassertExtractedProtoPath(\n\t\tt,\n\t\t// path without leading or trailing slashes\n\t\t\"foo.user.v1.UserService/GetUser\",\n\t\t\"/foo.user.v1.UserService/GetUser\",\n\t)\n\tassertExtractedProtoPath(\n\t\tt,\n\t\t// path with trailing slash\n\t\t\"/foo.user.v1.UserService.GetUser/\",\n\t\t\"/foo.user.v1.UserService.GetUser\",\n\t)\n\t// edge cases\n\tassertExtractedProtoPath(t, \"\", \"/\")\n\tassertExtractedProtoPath(t, \"//\", \"/\")\n}\n\nfunc assertExtractedProtoPath(tb testing.TB, inputURL, expectPath string) {\n\ttb.Helper()\n\tassert.Equal(\n\t\ttb,\n\t\textractProtoPath(inputURL),\n\t\texpectPath,\n\t)\n}\n"
        },
        {
          "name": "protocol.go",
          "type": "blob",
          "size": 14.1953125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// The names of the Connect, gRPC, and gRPC-Web protocols (as exposed by\n// [Peer.Protocol]). Additional protocols may be added in the future.\nconst (\n\tProtocolConnect = \"connect\"\n\tProtocolGRPC    = \"grpc\"\n\tProtocolGRPCWeb = \"grpcweb\"\n)\n\nconst (\n\theaderContentType     = \"Content-Type\"\n\theaderContentEncoding = \"Content-Encoding\"\n\theaderContentLength   = \"Content-Length\"\n\theaderHost            = \"Host\"\n\theaderUserAgent       = \"User-Agent\"\n\theaderTrailer         = \"Trailer\"\n\theaderDate            = \"Date\"\n\n\tdiscardLimit = 1024 * 1024 * 4 // 4MiB\n)\n\nvar errNoTimeout = errors.New(\"no timeout\")\n\n// A Protocol defines the HTTP semantics to use when sending and receiving\n// messages. It ties together codecs, compressors, and net/http to produce\n// Senders and Receivers.\n//\n// For example, connect supports the gRPC protocol using this abstraction. Among\n// many other things, the protocol implementation is responsible for\n// translating timeouts from Go contexts to HTTP and vice versa. For gRPC, it\n// converts timeouts to and from strings (for example, 10*time.Second <->\n// \"10S\"), and puts those strings into the \"Grpc-Timeout\" HTTP header. Other\n// protocols might encode durations differently, put them into a different HTTP\n// header, or ignore them entirely.\n//\n// We don't have any short-term plans to export this interface; it's just here\n// to separate the protocol-specific portions of connect from the\n// protocol-agnostic plumbing.\ntype protocol interface {\n\tNewHandler(*protocolHandlerParams) protocolHandler\n\tNewClient(*protocolClientParams) (protocolClient, error)\n}\n\n// HandlerParams are the arguments provided to a Protocol's NewHandler\n// method, bundled into a struct to allow backward-compatible argument\n// additions. Protocol implementations should take care to use the supplied\n// Spec rather than constructing their own, since new fields may have been\n// added.\ntype protocolHandlerParams struct {\n\tSpec                         Spec\n\tCodecs                       readOnlyCodecs\n\tCompressionPools             readOnlyCompressionPools\n\tCompressMinBytes             int\n\tBufferPool                   *bufferPool\n\tReadMaxBytes                 int\n\tSendMaxBytes                 int\n\tRequireConnectProtocolHeader bool\n\tIdempotencyLevel             IdempotencyLevel\n}\n\n// Handler is the server side of a protocol. HTTP handlers typically support\n// multiple protocols, codecs, and compressors.\ntype protocolHandler interface {\n\t// Methods is the set of HTTP methods the protocol can handle.\n\tMethods() map[string]struct{}\n\n\t// ContentTypes is the set of HTTP Content-Types that the protocol can\n\t// handle.\n\tContentTypes() map[string]struct{}\n\n\t// SetTimeout runs before NewStream. Implementations may inspect the HTTP\n\t// request, parse any timeout set by the client, and return a modified\n\t// context and cancellation function.\n\t//\n\t// If the client didn't send a timeout, SetTimeout should return the\n\t// request's context, a nil cancellation function, and a nil error.\n\tSetTimeout(*http.Request) (context.Context, context.CancelFunc, error)\n\n\t// CanHandlePayload returns true if the protocol can handle an HTTP request.\n\t// This is called after the request method is validated, so we only need to\n\t// be concerned with the content type/payload specifically.\n\tCanHandlePayload(*http.Request, string) bool\n\n\t// NewConn constructs a HandlerConn for the message exchange.\n\tNewConn(http.ResponseWriter, *http.Request) (handlerConnCloser, bool)\n}\n\n// ClientParams are the arguments provided to a Protocol's NewClient method,\n// bundled into a struct to allow backward-compatible argument additions.\n// Protocol implementations should take care to use the supplied Spec rather\n// than constructing their own, since new fields may have been added.\ntype protocolClientParams struct {\n\tCompressionName  string\n\tCompressionPools readOnlyCompressionPools\n\tCodec            Codec\n\tCompressMinBytes int\n\tHTTPClient       HTTPClient\n\tURL              *url.URL\n\tBufferPool       *bufferPool\n\tReadMaxBytes     int\n\tSendMaxBytes     int\n\tEnableGet        bool\n\tGetURLMaxBytes   int\n\tGetUseFallback   bool\n\t// The gRPC family of protocols always needs access to a Protobuf codec to\n\t// marshal and unmarshal errors.\n\tProtobuf Codec\n}\n\n// Client is the client side of a protocol. HTTP clients typically use a single\n// protocol, codec, and compressor to send requests.\ntype protocolClient interface {\n\t// Peer describes the server for the RPC.\n\tPeer() Peer\n\n\t// WriteRequestHeader writes any protocol-specific request headers.\n\tWriteRequestHeader(StreamType, http.Header)\n\n\t// NewConn constructs a StreamingClientConn for the message exchange.\n\t//\n\t// Implementations should assume that the supplied HTTP headers have already\n\t// been populated by WriteRequestHeader. When constructing a stream for a\n\t// unary call, implementations may assume that the Sender's Send and Close\n\t// methods return before the Receiver's Receive or Close methods are called.\n\tNewConn(context.Context, Spec, http.Header) streamingClientConn\n}\n\n// streamingClientConn extends StreamingClientConn with a method for registering\n// a hook when the HTTP request is actually sent.\ntype streamingClientConn interface {\n\tStreamingClientConn\n\n\tonRequestSend(fn func(*http.Request))\n}\n\n// errorTranslatingHandlerConnCloser wraps a handlerConnCloser to ensure that\n// we always return coded errors to users and write coded errors to the\n// network.\n//\n// It's used in protocol implementations.\ntype errorTranslatingHandlerConnCloser struct {\n\thandlerConnCloser\n\n\ttoWire   func(error) error\n\tfromWire func(error) error\n}\n\nfunc (hc *errorTranslatingHandlerConnCloser) Send(msg any) error {\n\treturn hc.fromWire(hc.handlerConnCloser.Send(msg))\n}\n\nfunc (hc *errorTranslatingHandlerConnCloser) Receive(msg any) error {\n\treturn hc.fromWire(hc.handlerConnCloser.Receive(msg))\n}\n\nfunc (hc *errorTranslatingHandlerConnCloser) Close(err error) error {\n\tcloseErr := hc.handlerConnCloser.Close(hc.toWire(err))\n\treturn hc.fromWire(closeErr)\n}\n\nfunc (hc *errorTranslatingHandlerConnCloser) getHTTPMethod() string {\n\tif methoder, ok := hc.handlerConnCloser.(interface{ getHTTPMethod() string }); ok {\n\t\treturn methoder.getHTTPMethod()\n\t}\n\treturn http.MethodPost\n}\n\n// errorTranslatingClientConn wraps a StreamingClientConn to make sure that we always\n// return coded errors from clients.\n//\n// It's used in protocol implementations.\ntype errorTranslatingClientConn struct {\n\tstreamingClientConn\n\n\tfromWire func(error) error\n}\n\nfunc (cc *errorTranslatingClientConn) Send(msg any) error {\n\treturn cc.fromWire(cc.streamingClientConn.Send(msg))\n}\n\nfunc (cc *errorTranslatingClientConn) Receive(msg any) error {\n\treturn cc.fromWire(cc.streamingClientConn.Receive(msg))\n}\n\nfunc (cc *errorTranslatingClientConn) CloseRequest() error {\n\treturn cc.fromWire(cc.streamingClientConn.CloseRequest())\n}\n\nfunc (cc *errorTranslatingClientConn) CloseResponse() error {\n\treturn cc.fromWire(cc.streamingClientConn.CloseResponse())\n}\n\nfunc (cc *errorTranslatingClientConn) onRequestSend(fn func(*http.Request)) {\n\tcc.streamingClientConn.onRequestSend(fn)\n}\n\n// wrapHandlerConnWithCodedErrors ensures that we (1) automatically code\n// context-related errors correctly when writing them to the network, and (2)\n// return *Errors from all exported APIs.\nfunc wrapHandlerConnWithCodedErrors(conn handlerConnCloser) handlerConnCloser {\n\treturn &errorTranslatingHandlerConnCloser{\n\t\thandlerConnCloser: conn,\n\t\ttoWire:            wrapIfContextError,\n\t\tfromWire:          wrapIfUncoded,\n\t}\n}\n\n// wrapClientConnWithCodedErrors ensures that we always return *Errors from\n// public APIs.\nfunc wrapClientConnWithCodedErrors(conn streamingClientConn) streamingClientConn {\n\treturn &errorTranslatingClientConn{\n\t\tstreamingClientConn: conn,\n\t\tfromWire:            wrapIfUncoded,\n\t}\n}\n\nfunc mappedMethodHandlers(handlers []protocolHandler) map[string][]protocolHandler {\n\tmethodHandlers := make(map[string][]protocolHandler)\n\tfor _, handler := range handlers {\n\t\tfor method := range handler.Methods() {\n\t\t\tmethodHandlers[method] = append(methodHandlers[method], handler)\n\t\t}\n\t}\n\treturn methodHandlers\n}\n\nfunc sortedAcceptPostValue(handlers []protocolHandler) string {\n\tcontentTypes := make(map[string]struct{})\n\tfor _, handler := range handlers {\n\t\tfor contentType := range handler.ContentTypes() {\n\t\t\tcontentTypes[contentType] = struct{}{}\n\t\t}\n\t}\n\taccept := make([]string, 0, len(contentTypes))\n\tfor ct := range contentTypes {\n\t\taccept = append(accept, ct)\n\t}\n\tsort.Strings(accept)\n\treturn strings.Join(accept, \", \")\n}\n\nfunc sortedAllowMethodValue(handlers []protocolHandler) string {\n\tmethods := make(map[string]struct{})\n\tfor _, handler := range handlers {\n\t\tfor method := range handler.Methods() {\n\t\t\tmethods[method] = struct{}{}\n\t\t}\n\t}\n\tallow := make([]string, 0, len(methods))\n\tfor ct := range methods {\n\t\tallow = append(allow, ct)\n\t}\n\tsort.Strings(allow)\n\treturn strings.Join(allow, \", \")\n}\n\nfunc isCommaOrSpace(c rune) bool {\n\treturn c == ',' || c == ' '\n}\n\nfunc discard(reader io.Reader) (int64, error) {\n\tif lr, ok := reader.(*io.LimitedReader); ok {\n\t\treturn io.Copy(io.Discard, lr)\n\t}\n\t// We don't want to get stuck throwing data away forever, so limit how much\n\t// we're willing to do here.\n\tlr := &io.LimitedReader{R: reader, N: discardLimit}\n\treturn io.Copy(io.Discard, lr)\n}\n\n// negotiateCompression determines and validates the request compression and\n// response compression using the available compressors and protocol-specific\n// Content-Encoding and Accept-Encoding headers.\nfunc negotiateCompression( //nolint:nonamedreturns\n\tavailableCompressors readOnlyCompressionPools,\n\tsent, accept string,\n) (requestCompression, responseCompression string, clientVisibleErr *Error) {\n\trequestCompression = compressionIdentity\n\tif sent != \"\" && sent != compressionIdentity {\n\t\t// We default to identity, so we only care if the client sends something\n\t\t// other than the empty string or compressIdentity.\n\t\tif availableCompressors.Contains(sent) {\n\t\t\trequestCompression = sent\n\t\t} else {\n\t\t\t// To comply with\n\t\t\t// https://github.com/grpc/grpc/blob/master/doc/compression.md and the\n\t\t\t// Connect protocol, we should return CodeUnimplemented and specify\n\t\t\t// acceptable compression(s) (in addition to setting the a\n\t\t\t// protocol-specific accept-encoding header).\n\t\t\treturn \"\", \"\", errorf(\n\t\t\t\tCodeUnimplemented,\n\t\t\t\t\"unknown compression %q: supported encodings are %v\",\n\t\t\t\tsent, availableCompressors.CommaSeparatedNames(),\n\t\t\t)\n\t\t}\n\t}\n\t// Support asymmetric compression. This logic follows\n\t// https://github.com/grpc/grpc/blob/master/doc/compression.md and common\n\t// sense.\n\tresponseCompression = requestCompression\n\t// If we're not already planning to compress the response, check whether the\n\t// client requested a compression algorithm we support.\n\tif responseCompression == compressionIdentity && accept != \"\" {\n\t\tfor _, name := range strings.FieldsFunc(accept, isCommaOrSpace) {\n\t\t\tif availableCompressors.Contains(name) {\n\t\t\t\t// We found a mutually supported compression algorithm. Unlike standard\n\t\t\t\t// HTTP, there's no preference weighting, so can bail out immediately.\n\t\t\t\tresponseCompression = name\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn requestCompression, responseCompression, nil\n}\n\n// checkServerStreamsCanFlush ensures that bidi and server streaming handlers\n// have received an http.ResponseWriter that implements http.Flusher, since\n// they must flush data after sending each message.\nfunc checkServerStreamsCanFlush(spec Spec, responseWriter http.ResponseWriter) *Error {\n\trequiresFlusher := (spec.StreamType & StreamTypeServer) == StreamTypeServer\n\tif _, flushable := responseWriter.(http.Flusher); requiresFlusher && !flushable {\n\t\treturn NewError(CodeInternal, fmt.Errorf(\"%T does not implement http.Flusher\", responseWriter))\n\t}\n\treturn nil\n}\n\nfunc flushResponseWriter(w http.ResponseWriter) {\n\tif f, ok := w.(http.Flusher); ok {\n\t\tf.Flush()\n\t}\n}\n\nfunc canonicalizeContentType(contentType string) string {\n\t// Typically, clients send Content-Type in canonical form, without\n\t// parameters. In those cases, we'd like to avoid parsing and\n\t// canonicalization overhead.\n\t//\n\t// See https://www.rfc-editor.org/rfc/rfc2045.html#section-5.1 for a full\n\t// grammar.\n\tvar slashes int\n\tfor _, r := range contentType {\n\t\tswitch {\n\t\tcase r >= 'a' && r <= 'z':\n\t\tcase r == '.' || r == '+' || r == '-':\n\t\tcase r == '/':\n\t\t\tslashes++\n\t\tdefault:\n\t\t\treturn canonicalizeContentTypeSlow(contentType)\n\t\t}\n\t}\n\tif slashes == 1 {\n\t\treturn contentType\n\t}\n\treturn canonicalizeContentTypeSlow(contentType)\n}\n\nfunc canonicalizeContentTypeSlow(contentType string) string {\n\tbase, params, err := mime.ParseMediaType(contentType)\n\tif err != nil {\n\t\treturn contentType\n\t}\n\t// According to RFC 9110 Section 8.3.2, the charset parameter value should be treated as case-insensitive.\n\t// mime.FormatMediaType canonicalizes parameter names, but not parameter values,\n\t// because the case sensitivity of a parameter value depends on its semantics.\n\t// Therefore, the charset parameter value should be canonicalized here.\n\t// ref.) https://httpwg.org/specs/rfc9110.html#rfc.section.8.3.2\n\tif charset, ok := params[\"charset\"]; ok {\n\t\tparams[\"charset\"] = strings.ToLower(charset)\n\t}\n\treturn mime.FormatMediaType(base, params)\n}\n\nfunc httpToCode(httpCode int) Code {\n\t// https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md\n\t// Note that this is NOT the inverse of the gRPC-to-HTTP or Connect-to-HTTP\n\t// mappings.\n\n\t// Literals are easier to compare to the specification (vs named\n\t// constants).\n\tswitch httpCode {\n\tcase 400:\n\t\treturn CodeInternal\n\tcase 401:\n\t\treturn CodeUnauthenticated\n\tcase 403:\n\t\treturn CodePermissionDenied\n\tcase 404:\n\t\treturn CodeUnimplemented\n\tcase 429:\n\t\treturn CodeUnavailable\n\tcase 502, 503, 504:\n\t\treturn CodeUnavailable\n\tdefault:\n\t\treturn CodeUnknown\n\t}\n}\n"
        },
        {
          "name": "protocol_connect.go",
          "type": "blob",
          "size": 45.4482421875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/anypb\"\n)\n\nconst (\n\tconnectUnaryHeaderCompression           = \"Content-Encoding\"\n\tconnectUnaryHeaderAcceptCompression     = \"Accept-Encoding\"\n\tconnectUnaryTrailerPrefix               = \"Trailer-\"\n\tconnectStreamingHeaderCompression       = \"Connect-Content-Encoding\"\n\tconnectStreamingHeaderAcceptCompression = \"Connect-Accept-Encoding\"\n\tconnectHeaderTimeout                    = \"Connect-Timeout-Ms\"\n\tconnectHeaderProtocolVersion            = \"Connect-Protocol-Version\"\n\tconnectProtocolVersion                  = \"1\"\n\theaderVary                              = \"Vary\"\n\n\tconnectFlagEnvelopeEndStream = 0b00000010\n\n\tconnectUnaryContentTypePrefix     = \"application/\"\n\tconnectUnaryContentTypeJSON       = connectUnaryContentTypePrefix + codecNameJSON\n\tconnectStreamingContentTypePrefix = \"application/connect+\"\n\n\tconnectUnaryEncodingQueryParameter    = \"encoding\"\n\tconnectUnaryMessageQueryParameter     = \"message\"\n\tconnectUnaryBase64QueryParameter      = \"base64\"\n\tconnectUnaryCompressionQueryParameter = \"compression\"\n\tconnectUnaryConnectQueryParameter     = \"connect\"\n\tconnectUnaryConnectQueryValue         = \"v\" + connectProtocolVersion\n)\n\n// defaultConnectUserAgent returns a User-Agent string similar to those used in gRPC.\n//\n//nolint:gochecknoglobals\nvar defaultConnectUserAgent = fmt.Sprintf(\"connect-go/%s (%s)\", Version, runtime.Version())\n\ntype protocolConnect struct{}\n\n// NewHandler implements protocol, so it must return an interface.\nfunc (*protocolConnect) NewHandler(params *protocolHandlerParams) protocolHandler {\n\tmethods := make(map[string]struct{})\n\tmethods[http.MethodPost] = struct{}{}\n\n\tif params.Spec.StreamType == StreamTypeUnary && params.IdempotencyLevel == IdempotencyNoSideEffects {\n\t\tmethods[http.MethodGet] = struct{}{}\n\t}\n\n\tcontentTypes := make(map[string]struct{})\n\tfor _, name := range params.Codecs.Names() {\n\t\tif params.Spec.StreamType == StreamTypeUnary {\n\t\t\tcontentTypes[canonicalizeContentType(connectUnaryContentTypePrefix+name)] = struct{}{}\n\t\t\tcontinue\n\t\t}\n\t\tcontentTypes[canonicalizeContentType(connectStreamingContentTypePrefix+name)] = struct{}{}\n\t}\n\n\treturn &connectHandler{\n\t\tprotocolHandlerParams: *params,\n\t\tmethods:               methods,\n\t\taccept:                contentTypes,\n\t}\n}\n\n// NewClient implements protocol, so it must return an interface.\nfunc (*protocolConnect) NewClient(params *protocolClientParams) (protocolClient, error) {\n\treturn &connectClient{\n\t\tprotocolClientParams: *params,\n\t\tpeer:                 newPeerFromURL(params.URL, ProtocolConnect),\n\t}, nil\n}\n\ntype connectHandler struct {\n\tprotocolHandlerParams\n\n\tmethods map[string]struct{}\n\taccept  map[string]struct{}\n}\n\nfunc (h *connectHandler) Methods() map[string]struct{} {\n\treturn h.methods\n}\n\nfunc (h *connectHandler) ContentTypes() map[string]struct{} {\n\treturn h.accept\n}\n\nfunc (*connectHandler) SetTimeout(request *http.Request) (context.Context, context.CancelFunc, error) {\n\ttimeout := getHeaderCanonical(request.Header, connectHeaderTimeout)\n\tif timeout == \"\" {\n\t\treturn request.Context(), nil, nil\n\t}\n\tif len(timeout) > 10 {\n\t\treturn nil, nil, errorf(CodeInvalidArgument, \"parse timeout: %q has >10 digits\", timeout)\n\t}\n\tmillis, err := strconv.ParseInt(timeout, 10 /* base */, 64 /* bitsize */)\n\tif err != nil {\n\t\treturn nil, nil, errorf(CodeInvalidArgument, \"parse timeout: %w\", err)\n\t}\n\tctx, cancel := context.WithTimeout(\n\t\trequest.Context(),\n\t\ttime.Duration(millis)*time.Millisecond,\n\t)\n\treturn ctx, cancel, nil\n}\n\nfunc (h *connectHandler) CanHandlePayload(request *http.Request, contentType string) bool {\n\tif request.Method == http.MethodGet {\n\t\tquery := request.URL.Query()\n\t\tcodecName := query.Get(connectUnaryEncodingQueryParameter)\n\t\tcontentType = connectContentTypeFromCodecName(\n\t\t\th.Spec.StreamType,\n\t\t\tcodecName,\n\t\t)\n\t}\n\t_, ok := h.accept[contentType]\n\treturn ok\n}\n\nfunc (h *connectHandler) NewConn(\n\tresponseWriter http.ResponseWriter,\n\trequest *http.Request,\n) (handlerConnCloser, bool) {\n\tctx := request.Context()\n\tquery := request.URL.Query()\n\t// We need to parse metadata before entering the interceptor stack; we'll\n\t// send the error to the client later on.\n\tvar contentEncoding, acceptEncoding string\n\tif h.Spec.StreamType == StreamTypeUnary {\n\t\tif request.Method == http.MethodGet {\n\t\t\tcontentEncoding = query.Get(connectUnaryCompressionQueryParameter)\n\t\t} else {\n\t\t\tcontentEncoding = getHeaderCanonical(request.Header, connectUnaryHeaderCompression)\n\t\t}\n\t\tacceptEncoding = getHeaderCanonical(request.Header, connectUnaryHeaderAcceptCompression)\n\t} else {\n\t\tcontentEncoding = getHeaderCanonical(request.Header, connectStreamingHeaderCompression)\n\t\tacceptEncoding = getHeaderCanonical(request.Header, connectStreamingHeaderAcceptCompression)\n\t}\n\trequestCompression, responseCompression, failed := negotiateCompression(\n\t\th.CompressionPools,\n\t\tcontentEncoding,\n\t\tacceptEncoding,\n\t)\n\tif failed == nil {\n\t\tfailed = checkServerStreamsCanFlush(h.Spec, responseWriter)\n\t}\n\tif failed == nil {\n\t\trequired := h.RequireConnectProtocolHeader && (h.Spec.StreamType == StreamTypeUnary)\n\t\tfailed = connectCheckProtocolVersion(request, required)\n\t}\n\n\tvar requestBody io.ReadCloser\n\tvar contentType, codecName string\n\tif request.Method == http.MethodGet {\n\t\tif failed == nil && !query.Has(connectUnaryEncodingQueryParameter) {\n\t\t\tfailed = errorf(CodeInvalidArgument, \"missing %s parameter\", connectUnaryEncodingQueryParameter)\n\t\t} else if failed == nil && !query.Has(connectUnaryMessageQueryParameter) {\n\t\t\tfailed = errorf(CodeInvalidArgument, \"missing %s parameter\", connectUnaryMessageQueryParameter)\n\t\t}\n\t\tmsg := query.Get(connectUnaryMessageQueryParameter)\n\t\tmsgReader := queryValueReader(msg, query.Get(connectUnaryBase64QueryParameter) == \"1\")\n\t\trequestBody = io.NopCloser(msgReader)\n\t\tcodecName = query.Get(connectUnaryEncodingQueryParameter)\n\t\tcontentType = connectContentTypeFromCodecName(\n\t\t\th.Spec.StreamType,\n\t\t\tcodecName,\n\t\t)\n\t} else {\n\t\trequestBody = request.Body\n\t\tcontentType = getHeaderCanonical(request.Header, headerContentType)\n\t\tcodecName = connectCodecFromContentType(\n\t\t\th.Spec.StreamType,\n\t\t\tcontentType,\n\t\t)\n\t}\n\n\tcodec := h.Codecs.Get(codecName)\n\t// The codec can be nil in the GET request case; that's okay: when failed\n\t// is non-nil, codec is never used.\n\tif failed == nil && codec == nil {\n\t\tfailed = errorf(CodeInvalidArgument, \"invalid message encoding: %q\", codecName)\n\t}\n\n\t// Write any remaining headers here:\n\t// (1) any writes to the stream will implicitly send the headers, so we\n\t// should get all of gRPC's required response headers ready.\n\t// (2) interceptors should be able to see these headers.\n\t//\n\t// Since we know that these header keys are already in canonical form, we can\n\t// skip the normalization in Header.Set.\n\theader := responseWriter.Header()\n\theader[headerContentType] = []string{contentType}\n\tacceptCompressionHeader := connectUnaryHeaderAcceptCompression\n\tif h.Spec.StreamType != StreamTypeUnary {\n\t\tacceptCompressionHeader = connectStreamingHeaderAcceptCompression\n\t\t// We only write the request encoding header here for streaming calls,\n\t\t// since the streaming envelope lets us choose whether to compress each\n\t\t// message individually. For unary, we won't know whether we're compressing\n\t\t// the request until we see how large the payload is.\n\t\tif responseCompression != compressionIdentity {\n\t\t\theader[connectStreamingHeaderCompression] = []string{responseCompression}\n\t\t}\n\t}\n\theader[acceptCompressionHeader] = []string{h.CompressionPools.CommaSeparatedNames()}\n\n\tvar conn handlerConnCloser\n\tpeer := Peer{\n\t\tAddr:     request.RemoteAddr,\n\t\tProtocol: ProtocolConnect,\n\t\tQuery:    query,\n\t}\n\tif h.Spec.StreamType == StreamTypeUnary {\n\t\tconn = &connectUnaryHandlerConn{\n\t\t\tspec:           h.Spec,\n\t\t\tpeer:           peer,\n\t\t\trequest:        request,\n\t\t\tresponseWriter: responseWriter,\n\t\t\tmarshaler: connectUnaryMarshaler{\n\t\t\t\tctx:              ctx,\n\t\t\t\tsender:           writeSender{writer: responseWriter},\n\t\t\t\tcodec:            codec,\n\t\t\t\tcompressMinBytes: h.CompressMinBytes,\n\t\t\t\tcompressionName:  responseCompression,\n\t\t\t\tcompressionPool:  h.CompressionPools.Get(responseCompression),\n\t\t\t\tbufferPool:       h.BufferPool,\n\t\t\t\theader:           responseWriter.Header(),\n\t\t\t\tsendMaxBytes:     h.SendMaxBytes,\n\t\t\t},\n\t\t\tunmarshaler: connectUnaryUnmarshaler{\n\t\t\t\tctx:             ctx,\n\t\t\t\treader:          requestBody,\n\t\t\t\tcodec:           codec,\n\t\t\t\tcompressionPool: h.CompressionPools.Get(requestCompression),\n\t\t\t\tbufferPool:      h.BufferPool,\n\t\t\t\treadMaxBytes:    h.ReadMaxBytes,\n\t\t\t},\n\t\t\tresponseTrailer: make(http.Header),\n\t\t}\n\t} else {\n\t\tconn = &connectStreamingHandlerConn{\n\t\t\tspec:           h.Spec,\n\t\t\tpeer:           peer,\n\t\t\trequest:        request,\n\t\t\tresponseWriter: responseWriter,\n\t\t\tmarshaler: connectStreamingMarshaler{\n\t\t\t\tenvelopeWriter: envelopeWriter{\n\t\t\t\t\tctx:              ctx,\n\t\t\t\t\tsender:           writeSender{responseWriter},\n\t\t\t\t\tcodec:            codec,\n\t\t\t\t\tcompressMinBytes: h.CompressMinBytes,\n\t\t\t\t\tcompressionPool:  h.CompressionPools.Get(responseCompression),\n\t\t\t\t\tbufferPool:       h.BufferPool,\n\t\t\t\t\tsendMaxBytes:     h.SendMaxBytes,\n\t\t\t\t},\n\t\t\t},\n\t\t\tunmarshaler: connectStreamingUnmarshaler{\n\t\t\t\tenvelopeReader: envelopeReader{\n\t\t\t\t\tctx:             ctx,\n\t\t\t\t\treader:          requestBody,\n\t\t\t\t\tcodec:           codec,\n\t\t\t\t\tcompressionPool: h.CompressionPools.Get(requestCompression),\n\t\t\t\t\tbufferPool:      h.BufferPool,\n\t\t\t\t\treadMaxBytes:    h.ReadMaxBytes,\n\t\t\t\t},\n\t\t\t},\n\t\t\tresponseTrailer: make(http.Header),\n\t\t}\n\t}\n\tconn = wrapHandlerConnWithCodedErrors(conn)\n\n\tif failed != nil {\n\t\t// Negotiation failed, so we can't establish a stream.\n\t\t_ = conn.Close(failed)\n\t\treturn nil, false\n\t}\n\treturn conn, true\n}\n\ntype connectClient struct {\n\tprotocolClientParams\n\n\tpeer Peer\n}\n\nfunc (c *connectClient) Peer() Peer {\n\treturn c.peer\n}\n\nfunc (c *connectClient) WriteRequestHeader(streamType StreamType, header http.Header) {\n\t// We know these header keys are in canonical form, so we can bypass all the\n\t// checks in Header.Set.\n\tif getHeaderCanonical(header, headerUserAgent) == \"\" {\n\t\theader[headerUserAgent] = []string{defaultConnectUserAgent}\n\t}\n\theader[connectHeaderProtocolVersion] = []string{connectProtocolVersion}\n\theader[headerContentType] = []string{\n\t\tconnectContentTypeFromCodecName(streamType, c.Codec.Name()),\n\t}\n\tacceptCompressionHeader := connectUnaryHeaderAcceptCompression\n\tif streamType != StreamTypeUnary {\n\t\t// If we don't set Accept-Encoding, by default http.Client will ask the\n\t\t// server to compress the whole stream. Since we're already compressing\n\t\t// each message, this is a waste.\n\t\theader[connectUnaryHeaderAcceptCompression] = []string{compressionIdentity}\n\t\tacceptCompressionHeader = connectStreamingHeaderAcceptCompression\n\t\t// We only write the request encoding header here for streaming calls,\n\t\t// since the streaming envelope lets us choose whether to compress each\n\t\t// message individually. For unary, we won't know whether we're compressing\n\t\t// the request until we see how large the payload is.\n\t\tif c.CompressionName != \"\" && c.CompressionName != compressionIdentity {\n\t\t\theader[connectStreamingHeaderCompression] = []string{c.CompressionName}\n\t\t}\n\t}\n\tif acceptCompression := c.CompressionPools.CommaSeparatedNames(); acceptCompression != \"\" {\n\t\theader[acceptCompressionHeader] = []string{acceptCompression}\n\t}\n}\n\nfunc (c *connectClient) NewConn(\n\tctx context.Context,\n\tspec Spec,\n\theader http.Header,\n) streamingClientConn {\n\tif deadline, ok := ctx.Deadline(); ok {\n\t\tmillis := int64(time.Until(deadline) / time.Millisecond)\n\t\tif millis > 0 {\n\t\t\tencoded := strconv.FormatInt(millis, 10 /* base */)\n\t\t\tif len(encoded) <= 10 {\n\t\t\t\theader[connectHeaderTimeout] = []string{encoded}\n\t\t\t} // else effectively unbounded\n\t\t}\n\t}\n\tduplexCall := newDuplexHTTPCall(ctx, c.HTTPClient, c.URL, spec, header)\n\tvar conn streamingClientConn\n\tif spec.StreamType == StreamTypeUnary {\n\t\tunaryConn := &connectUnaryClientConn{\n\t\t\tspec:             spec,\n\t\t\tpeer:             c.Peer(),\n\t\t\tduplexCall:       duplexCall,\n\t\t\tcompressionPools: c.CompressionPools,\n\t\t\tbufferPool:       c.BufferPool,\n\t\t\tmarshaler: connectUnaryRequestMarshaler{\n\t\t\t\tconnectUnaryMarshaler: connectUnaryMarshaler{\n\t\t\t\t\tctx:              ctx,\n\t\t\t\t\tsender:           duplexCall,\n\t\t\t\t\tcodec:            c.Codec,\n\t\t\t\t\tcompressMinBytes: c.CompressMinBytes,\n\t\t\t\t\tcompressionName:  c.CompressionName,\n\t\t\t\t\tcompressionPool:  c.CompressionPools.Get(c.CompressionName),\n\t\t\t\t\tbufferPool:       c.BufferPool,\n\t\t\t\t\theader:           duplexCall.Header(),\n\t\t\t\t\tsendMaxBytes:     c.SendMaxBytes,\n\t\t\t\t},\n\t\t\t},\n\t\t\tunmarshaler: connectUnaryUnmarshaler{\n\t\t\t\tctx:          ctx,\n\t\t\t\treader:       duplexCall,\n\t\t\t\tcodec:        c.Codec,\n\t\t\t\tbufferPool:   c.BufferPool,\n\t\t\t\treadMaxBytes: c.ReadMaxBytes,\n\t\t\t},\n\t\t\tresponseHeader:  make(http.Header),\n\t\t\tresponseTrailer: make(http.Header),\n\t\t}\n\t\tif spec.IdempotencyLevel == IdempotencyNoSideEffects {\n\t\t\tunaryConn.marshaler.enableGet = c.EnableGet\n\t\t\tunaryConn.marshaler.getURLMaxBytes = c.GetURLMaxBytes\n\t\t\tunaryConn.marshaler.getUseFallback = c.GetUseFallback\n\t\t\tunaryConn.marshaler.duplexCall = duplexCall\n\t\t\tif stableCodec, ok := c.Codec.(stableCodec); ok {\n\t\t\t\tunaryConn.marshaler.stableCodec = stableCodec\n\t\t\t}\n\t\t}\n\t\tconn = unaryConn\n\t\tduplexCall.SetValidateResponse(unaryConn.validateResponse)\n\t} else {\n\t\tstreamingConn := &connectStreamingClientConn{\n\t\t\tspec:             spec,\n\t\t\tpeer:             c.Peer(),\n\t\t\tduplexCall:       duplexCall,\n\t\t\tcompressionPools: c.CompressionPools,\n\t\t\tbufferPool:       c.BufferPool,\n\t\t\tcodec:            c.Codec,\n\t\t\tmarshaler: connectStreamingMarshaler{\n\t\t\t\tenvelopeWriter: envelopeWriter{\n\t\t\t\t\tctx:              ctx,\n\t\t\t\t\tsender:           duplexCall,\n\t\t\t\t\tcodec:            c.Codec,\n\t\t\t\t\tcompressMinBytes: c.CompressMinBytes,\n\t\t\t\t\tcompressionPool:  c.CompressionPools.Get(c.CompressionName),\n\t\t\t\t\tbufferPool:       c.BufferPool,\n\t\t\t\t\tsendMaxBytes:     c.SendMaxBytes,\n\t\t\t\t},\n\t\t\t},\n\t\t\tunmarshaler: connectStreamingUnmarshaler{\n\t\t\t\tenvelopeReader: envelopeReader{\n\t\t\t\t\tctx:          ctx,\n\t\t\t\t\treader:       duplexCall,\n\t\t\t\t\tcodec:        c.Codec,\n\t\t\t\t\tbufferPool:   c.BufferPool,\n\t\t\t\t\treadMaxBytes: c.ReadMaxBytes,\n\t\t\t\t},\n\t\t\t},\n\t\t\tresponseHeader:  make(http.Header),\n\t\t\tresponseTrailer: make(http.Header),\n\t\t}\n\t\tconn = streamingConn\n\t\tduplexCall.SetValidateResponse(streamingConn.validateResponse)\n\t}\n\treturn wrapClientConnWithCodedErrors(conn)\n}\n\ntype connectUnaryClientConn struct {\n\tspec             Spec\n\tpeer             Peer\n\tduplexCall       *duplexHTTPCall\n\tcompressionPools readOnlyCompressionPools\n\tbufferPool       *bufferPool\n\tmarshaler        connectUnaryRequestMarshaler\n\tunmarshaler      connectUnaryUnmarshaler\n\tresponseHeader   http.Header\n\tresponseTrailer  http.Header\n}\n\nfunc (cc *connectUnaryClientConn) Spec() Spec {\n\treturn cc.spec\n}\n\nfunc (cc *connectUnaryClientConn) Peer() Peer {\n\treturn cc.peer\n}\n\nfunc (cc *connectUnaryClientConn) Send(msg any) error {\n\tif err := cc.marshaler.Marshal(msg); err != nil {\n\t\treturn err\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (cc *connectUnaryClientConn) RequestHeader() http.Header {\n\treturn cc.duplexCall.Header()\n}\n\nfunc (cc *connectUnaryClientConn) CloseRequest() error {\n\treturn cc.duplexCall.CloseWrite()\n}\n\nfunc (cc *connectUnaryClientConn) Receive(msg any) error {\n\tif err := cc.duplexCall.BlockUntilResponseReady(); err != nil {\n\t\treturn err\n\t}\n\tif err := cc.unmarshaler.Unmarshal(msg); err != nil {\n\t\treturn err\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (cc *connectUnaryClientConn) ResponseHeader() http.Header {\n\t_ = cc.duplexCall.BlockUntilResponseReady()\n\treturn cc.responseHeader\n}\n\nfunc (cc *connectUnaryClientConn) ResponseTrailer() http.Header {\n\t_ = cc.duplexCall.BlockUntilResponseReady()\n\treturn cc.responseTrailer\n}\n\nfunc (cc *connectUnaryClientConn) CloseResponse() error {\n\treturn cc.duplexCall.CloseRead()\n}\n\nfunc (cc *connectUnaryClientConn) onRequestSend(fn func(*http.Request)) {\n\tcc.duplexCall.onRequestSend = fn\n}\n\nfunc (cc *connectUnaryClientConn) validateResponse(response *http.Response) *Error {\n\tfor k, v := range response.Header {\n\t\tif !strings.HasPrefix(k, connectUnaryTrailerPrefix) {\n\t\t\tcc.responseHeader[k] = v\n\t\t\tcontinue\n\t\t}\n\t\tcc.responseTrailer[k[len(connectUnaryTrailerPrefix):]] = v\n\t}\n\tif err := connectValidateUnaryResponseContentType(\n\t\tcc.marshaler.codec.Name(),\n\t\tcc.duplexCall.Method(),\n\t\tresponse.StatusCode,\n\t\tresponse.Status,\n\t\tgetHeaderCanonical(response.Header, headerContentType),\n\t); err != nil {\n\t\tif IsNotModifiedError(err) {\n\t\t\t// Allow access to response headers for this kind of error.\n\t\t\t// RFC 9110 doesn't allow trailers on 304s, so we only need to include headers.\n\t\t\terr.meta = cc.responseHeader.Clone()\n\t\t}\n\t\treturn err\n\t}\n\tcompression := getHeaderCanonical(response.Header, connectUnaryHeaderCompression)\n\tif compression != \"\" &&\n\t\tcompression != compressionIdentity &&\n\t\t!cc.compressionPools.Contains(compression) {\n\t\treturn errorf(\n\t\t\tCodeInternal,\n\t\t\t\"unknown encoding %q: accepted encodings are %v\",\n\t\t\tcompression,\n\t\t\tcc.compressionPools.CommaSeparatedNames(),\n\t\t)\n\t}\n\tcc.unmarshaler.compressionPool = cc.compressionPools.Get(compression)\n\tif response.StatusCode != http.StatusOK {\n\t\tunmarshaler := connectUnaryUnmarshaler{\n\t\t\tctx:             cc.unmarshaler.ctx,\n\t\t\treader:          response.Body,\n\t\t\tcompressionPool: cc.unmarshaler.compressionPool,\n\t\t\tbufferPool:      cc.bufferPool,\n\t\t}\n\t\tvar wireErr connectWireError\n\t\tif err := unmarshaler.UnmarshalFunc(&wireErr, json.Unmarshal); err != nil {\n\t\t\treturn NewError(\n\t\t\t\thttpToCode(response.StatusCode),\n\t\t\t\terrors.New(response.Status),\n\t\t\t)\n\t\t}\n\t\tif wireErr.Code == 0 {\n\t\t\t// code not set? default to one implied by HTTP status\n\t\t\twireErr.Code = httpToCode(response.StatusCode)\n\t\t}\n\t\tserverErr := wireErr.asError()\n\t\tif serverErr == nil {\n\t\t\treturn nil\n\t\t}\n\t\tserverErr.meta = cc.responseHeader.Clone()\n\t\tmergeHeaders(serverErr.meta, cc.responseTrailer)\n\t\treturn serverErr\n\t}\n\treturn nil\n}\n\ntype connectStreamingClientConn struct {\n\tspec             Spec\n\tpeer             Peer\n\tduplexCall       *duplexHTTPCall\n\tcompressionPools readOnlyCompressionPools\n\tbufferPool       *bufferPool\n\tcodec            Codec\n\tmarshaler        connectStreamingMarshaler\n\tunmarshaler      connectStreamingUnmarshaler\n\tresponseHeader   http.Header\n\tresponseTrailer  http.Header\n}\n\nfunc (cc *connectStreamingClientConn) Spec() Spec {\n\treturn cc.spec\n}\n\nfunc (cc *connectStreamingClientConn) Peer() Peer {\n\treturn cc.peer\n}\n\nfunc (cc *connectStreamingClientConn) Send(msg any) error {\n\tif err := cc.marshaler.Marshal(msg); err != nil {\n\t\treturn err\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (cc *connectStreamingClientConn) RequestHeader() http.Header {\n\treturn cc.duplexCall.Header()\n}\n\nfunc (cc *connectStreamingClientConn) CloseRequest() error {\n\treturn cc.duplexCall.CloseWrite()\n}\n\nfunc (cc *connectStreamingClientConn) Receive(msg any) error {\n\tif err := cc.duplexCall.BlockUntilResponseReady(); err != nil {\n\t\treturn err\n\t}\n\terr := cc.unmarshaler.Unmarshal(msg)\n\tif err == nil {\n\t\treturn nil\n\t}\n\t// See if the server sent an explicit error in the end-of-stream message.\n\tmergeHeaders(cc.responseTrailer, cc.unmarshaler.Trailer())\n\tif serverErr := cc.unmarshaler.EndStreamError(); serverErr != nil {\n\t\t// This is expected from a protocol perspective, but receiving an\n\t\t// end-of-stream message means that we're _not_ getting a regular message.\n\t\t// For users to realize that the stream has ended, Receive must return an\n\t\t// error.\n\t\tserverErr.meta = cc.responseHeader.Clone()\n\t\tmergeHeaders(serverErr.meta, cc.responseTrailer)\n\t\t_ = cc.duplexCall.CloseWrite()\n\t\treturn serverErr\n\t}\n\t// If the error is EOF but not from a last message, we want to return\n\t// io.ErrUnexpectedEOF instead.\n\tif errors.Is(err, io.EOF) && !errors.Is(err, errSpecialEnvelope) {\n\t\terr = errorf(CodeInternal, \"protocol error: %w\", io.ErrUnexpectedEOF)\n\t}\n\t// There's no error in the trailers, so this was probably an error\n\t// converting the bytes to a message, an error reading from the network, or\n\t// just an EOF. We're going to return it to the user, but we also want to\n\t// close the writer so Send errors out.\n\t_ = cc.duplexCall.CloseWrite()\n\treturn err\n}\n\nfunc (cc *connectStreamingClientConn) ResponseHeader() http.Header {\n\t_ = cc.duplexCall.BlockUntilResponseReady()\n\treturn cc.responseHeader\n}\n\nfunc (cc *connectStreamingClientConn) ResponseTrailer() http.Header {\n\t_ = cc.duplexCall.BlockUntilResponseReady()\n\treturn cc.responseTrailer\n}\n\nfunc (cc *connectStreamingClientConn) CloseResponse() error {\n\treturn cc.duplexCall.CloseRead()\n}\n\nfunc (cc *connectStreamingClientConn) onRequestSend(fn func(*http.Request)) {\n\tcc.duplexCall.onRequestSend = fn\n}\n\nfunc (cc *connectStreamingClientConn) validateResponse(response *http.Response) *Error {\n\tif response.StatusCode != http.StatusOK {\n\t\treturn errorf(httpToCode(response.StatusCode), \"HTTP status %v\", response.Status)\n\t}\n\tif err := connectValidateStreamResponseContentType(\n\t\tcc.codec.Name(),\n\t\tcc.spec.StreamType,\n\t\tgetHeaderCanonical(response.Header, headerContentType),\n\t); err != nil {\n\t\treturn err\n\t}\n\tcompression := getHeaderCanonical(response.Header, connectStreamingHeaderCompression)\n\tif compression != \"\" &&\n\t\tcompression != compressionIdentity &&\n\t\t!cc.compressionPools.Contains(compression) {\n\t\treturn errorf(\n\t\t\tCodeInternal,\n\t\t\t\"unknown encoding %q: accepted encodings are %v\",\n\t\t\tcompression,\n\t\t\tcc.compressionPools.CommaSeparatedNames(),\n\t\t)\n\t}\n\tcc.unmarshaler.compressionPool = cc.compressionPools.Get(compression)\n\tmergeHeaders(cc.responseHeader, response.Header)\n\treturn nil\n}\n\ntype connectUnaryHandlerConn struct {\n\tspec            Spec\n\tpeer            Peer\n\trequest         *http.Request\n\tresponseWriter  http.ResponseWriter\n\tmarshaler       connectUnaryMarshaler\n\tunmarshaler     connectUnaryUnmarshaler\n\tresponseTrailer http.Header\n}\n\nfunc (hc *connectUnaryHandlerConn) Spec() Spec {\n\treturn hc.spec\n}\n\nfunc (hc *connectUnaryHandlerConn) Peer() Peer {\n\treturn hc.peer\n}\n\nfunc (hc *connectUnaryHandlerConn) Receive(msg any) error {\n\tif err := hc.unmarshaler.Unmarshal(msg); err != nil {\n\t\treturn err\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (hc *connectUnaryHandlerConn) RequestHeader() http.Header {\n\treturn hc.request.Header\n}\n\nfunc (hc *connectUnaryHandlerConn) Send(msg any) error {\n\thc.mergeResponseHeader(nil /* error */)\n\tif err := hc.marshaler.Marshal(msg); err != nil {\n\t\treturn err\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (hc *connectUnaryHandlerConn) ResponseHeader() http.Header {\n\treturn hc.responseWriter.Header()\n}\n\nfunc (hc *connectUnaryHandlerConn) ResponseTrailer() http.Header {\n\treturn hc.responseTrailer\n}\n\nfunc (hc *connectUnaryHandlerConn) Close(err error) error {\n\tif !hc.marshaler.wroteHeader {\n\t\thc.mergeResponseHeader(err)\n\t\t// If the handler received a GET request and the resource hasn't changed,\n\t\t// return a 304.\n\t\tif len(hc.peer.Query) > 0 && IsNotModifiedError(err) {\n\t\t\thc.responseWriter.WriteHeader(http.StatusNotModified)\n\t\t\treturn hc.request.Body.Close()\n\t\t}\n\t}\n\tif err == nil || hc.marshaler.wroteHeader {\n\t\treturn hc.request.Body.Close()\n\t}\n\t// In unary Connect, errors always use application/json.\n\tsetHeaderCanonical(hc.responseWriter.Header(), headerContentType, connectUnaryContentTypeJSON)\n\thc.responseWriter.WriteHeader(connectCodeToHTTP(CodeOf(err)))\n\tdata, marshalErr := json.Marshal(newConnectWireError(err))\n\tif marshalErr != nil {\n\t\t_ = hc.request.Body.Close()\n\t\treturn errorf(CodeInternal, \"marshal error: %w\", err)\n\t}\n\tif _, writeErr := hc.responseWriter.Write(data); writeErr != nil {\n\t\t_ = hc.request.Body.Close()\n\t\treturn writeErr\n\t}\n\treturn hc.request.Body.Close()\n}\n\nfunc (hc *connectUnaryHandlerConn) getHTTPMethod() string {\n\treturn hc.request.Method\n}\n\nfunc (hc *connectUnaryHandlerConn) mergeResponseHeader(err error) {\n\theader := hc.responseWriter.Header()\n\tif hc.request.Method == http.MethodGet {\n\t\t// The response content varies depending on the compression that the client\n\t\t// requested (if any). GETs are potentially cacheable, so we should ensure\n\t\t// that the Vary header includes at least Accept-Encoding (and not overwrite any values already set).\n\t\theader[headerVary] = append(header[headerVary], connectUnaryHeaderAcceptCompression)\n\t}\n\tif err != nil {\n\t\tif connectErr, ok := asError(err); ok && !connectErr.wireErr {\n\t\t\tmergeNonProtocolHeaders(header, connectErr.meta)\n\t\t}\n\t}\n\tfor k, v := range hc.responseTrailer {\n\t\theader[connectUnaryTrailerPrefix+k] = v\n\t}\n}\n\ntype connectStreamingHandlerConn struct {\n\tspec            Spec\n\tpeer            Peer\n\trequest         *http.Request\n\tresponseWriter  http.ResponseWriter\n\tmarshaler       connectStreamingMarshaler\n\tunmarshaler     connectStreamingUnmarshaler\n\tresponseTrailer http.Header\n}\n\nfunc (hc *connectStreamingHandlerConn) Spec() Spec {\n\treturn hc.spec\n}\n\nfunc (hc *connectStreamingHandlerConn) Peer() Peer {\n\treturn hc.peer\n}\n\nfunc (hc *connectStreamingHandlerConn) Receive(msg any) error {\n\tif err := hc.unmarshaler.Unmarshal(msg); err != nil {\n\t\t// Clients may not send end-of-stream metadata, so we don't need to handle\n\t\t// errSpecialEnvelope.\n\t\treturn err\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (hc *connectStreamingHandlerConn) RequestHeader() http.Header {\n\treturn hc.request.Header\n}\n\nfunc (hc *connectStreamingHandlerConn) Send(msg any) error {\n\tdefer flushResponseWriter(hc.responseWriter)\n\tif err := hc.marshaler.Marshal(msg); err != nil {\n\t\treturn err\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (hc *connectStreamingHandlerConn) ResponseHeader() http.Header {\n\treturn hc.responseWriter.Header()\n}\n\nfunc (hc *connectStreamingHandlerConn) ResponseTrailer() http.Header {\n\treturn hc.responseTrailer\n}\n\nfunc (hc *connectStreamingHandlerConn) Close(err error) error {\n\tdefer flushResponseWriter(hc.responseWriter)\n\tif err := hc.marshaler.MarshalEndStream(err, hc.responseTrailer); err != nil {\n\t\t_ = hc.request.Body.Close()\n\t\treturn err\n\t}\n\t// We don't want to copy unread portions of the body to /dev/null here: if\n\t// the client hasn't closed the request body, we'll block until the server\n\t// timeout kicks in. This could happen because the client is malicious, but\n\t// a well-intentioned client may just not expect the server to be returning\n\t// an error for a streaming RPC. Better to accept that we can't always reuse\n\t// TCP connections.\n\tif err := hc.request.Body.Close(); err != nil {\n\t\tif connectErr, ok := asError(err); ok {\n\t\t\treturn connectErr\n\t\t}\n\t\treturn NewError(CodeUnknown, err)\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\ntype connectStreamingMarshaler struct {\n\tenvelopeWriter\n}\n\nfunc (m *connectStreamingMarshaler) MarshalEndStream(err error, trailer http.Header) *Error {\n\tend := &connectEndStreamMessage{Trailer: trailer}\n\tif err != nil {\n\t\tend.Error = newConnectWireError(err)\n\t\tif connectErr, ok := asError(err); ok && !connectErr.wireErr {\n\t\t\tmergeNonProtocolHeaders(end.Trailer, connectErr.meta)\n\t\t}\n\t}\n\tdata, marshalErr := json.Marshal(end)\n\tif marshalErr != nil {\n\t\treturn errorf(CodeInternal, \"marshal end stream: %w\", marshalErr)\n\t}\n\traw := bytes.NewBuffer(data)\n\tdefer m.envelopeWriter.bufferPool.Put(raw)\n\treturn m.Write(&envelope{\n\t\tData:  raw,\n\t\tFlags: connectFlagEnvelopeEndStream,\n\t})\n}\n\ntype connectStreamingUnmarshaler struct {\n\tenvelopeReader\n\n\tendStreamErr *Error\n\ttrailer      http.Header\n}\n\nfunc (u *connectStreamingUnmarshaler) Unmarshal(message any) *Error {\n\terr := u.envelopeReader.Unmarshal(message)\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif !errors.Is(err, errSpecialEnvelope) {\n\t\treturn err\n\t}\n\tenv := u.last\n\tdata := env.Data\n\tu.last.Data = nil // don't keep a reference to it\n\tdefer u.bufferPool.Put(data)\n\tif !env.IsSet(connectFlagEnvelopeEndStream) {\n\t\treturn errorf(CodeInternal, \"protocol error: invalid envelope flags %d\", env.Flags)\n\t}\n\tvar end connectEndStreamMessage\n\tif err := json.Unmarshal(data.Bytes(), &end); err != nil {\n\t\treturn errorf(CodeInternal, \"unmarshal end stream message: %w\", err)\n\t}\n\tfor name, value := range end.Trailer {\n\t\tcanonical := http.CanonicalHeaderKey(name)\n\t\tif name != canonical {\n\t\t\tdelHeaderCanonical(end.Trailer, name)\n\t\t\tend.Trailer[canonical] = append(end.Trailer[canonical], value...)\n\t\t}\n\t}\n\tu.trailer = end.Trailer\n\tu.endStreamErr = end.Error.asError()\n\treturn errSpecialEnvelope\n}\n\nfunc (u *connectStreamingUnmarshaler) Trailer() http.Header {\n\treturn u.trailer\n}\n\nfunc (u *connectStreamingUnmarshaler) EndStreamError() *Error {\n\treturn u.endStreamErr\n}\n\ntype connectUnaryMarshaler struct {\n\tctx              context.Context //nolint:containedctx\n\tsender           messageSender\n\tcodec            Codec\n\tcompressMinBytes int\n\tcompressionName  string\n\tcompressionPool  *compressionPool\n\tbufferPool       *bufferPool\n\theader           http.Header\n\tsendMaxBytes     int\n\twroteHeader      bool\n}\n\nfunc (m *connectUnaryMarshaler) Marshal(message any) *Error {\n\tif message == nil {\n\t\treturn m.write(nil)\n\t}\n\tvar data []byte\n\tvar err error\n\tif appender, ok := m.codec.(marshalAppender); ok {\n\t\tdata, err = appender.MarshalAppend(m.bufferPool.Get().Bytes(), message)\n\t} else {\n\t\t// Can't avoid allocating the slice, but we'll reuse it.\n\t\tdata, err = m.codec.Marshal(message)\n\t}\n\tif err != nil {\n\t\treturn errorf(CodeInternal, \"marshal message: %w\", err)\n\t}\n\tuncompressed := bytes.NewBuffer(data)\n\tdefer m.bufferPool.Put(uncompressed)\n\tif len(data) < m.compressMinBytes || m.compressionPool == nil {\n\t\tif m.sendMaxBytes > 0 && len(data) > m.sendMaxBytes {\n\t\t\treturn NewError(CodeResourceExhausted, fmt.Errorf(\"message size %d exceeds sendMaxBytes %d\", len(data), m.sendMaxBytes))\n\t\t}\n\t\treturn m.write(data)\n\t}\n\tcompressed := m.bufferPool.Get()\n\tdefer m.bufferPool.Put(compressed)\n\tif err := m.compressionPool.Compress(compressed, uncompressed); err != nil {\n\t\treturn err\n\t}\n\tif m.sendMaxBytes > 0 && compressed.Len() > m.sendMaxBytes {\n\t\treturn NewError(CodeResourceExhausted, fmt.Errorf(\"compressed message size %d exceeds sendMaxBytes %d\", compressed.Len(), m.sendMaxBytes))\n\t}\n\tsetHeaderCanonical(m.header, connectUnaryHeaderCompression, m.compressionName)\n\treturn m.write(compressed.Bytes())\n}\n\nfunc (m *connectUnaryMarshaler) write(data []byte) *Error {\n\tm.wroteHeader = true\n\tpayload := bytes.NewReader(data)\n\tif _, err := m.sender.Send(payload); err != nil {\n\t\terr = wrapIfContextError(err)\n\t\tif connectErr, ok := asError(err); ok {\n\t\t\treturn connectErr\n\t\t}\n\t\treturn errorf(CodeUnknown, \"write message: %w\", err)\n\t}\n\treturn nil\n}\n\ntype connectUnaryRequestMarshaler struct {\n\tconnectUnaryMarshaler\n\n\tenableGet      bool\n\tgetURLMaxBytes int\n\tgetUseFallback bool\n\tstableCodec    stableCodec\n\tduplexCall     *duplexHTTPCall\n}\n\nfunc (m *connectUnaryRequestMarshaler) Marshal(message any) *Error {\n\tif m.enableGet {\n\t\tif m.stableCodec == nil && !m.getUseFallback {\n\t\t\treturn errorf(CodeInternal, \"codec %s doesn't support stable marshal; can't use get\", m.codec.Name())\n\t\t}\n\t\tif m.stableCodec != nil {\n\t\t\treturn m.marshalWithGet(message)\n\t\t}\n\t}\n\treturn m.connectUnaryMarshaler.Marshal(message)\n}\n\nfunc (m *connectUnaryRequestMarshaler) marshalWithGet(message any) *Error {\n\t// TODO(jchadwick-buf): This function is mostly a superset of\n\t// connectUnaryMarshaler.Marshal. This should be reconciled at some point.\n\tvar data []byte\n\tvar err error\n\tif message != nil {\n\t\tdata, err = m.stableCodec.MarshalStable(message)\n\t\tif err != nil {\n\t\t\treturn errorf(CodeInternal, \"marshal message stable: %w\", err)\n\t\t}\n\t}\n\tisTooBig := m.sendMaxBytes > 0 && len(data) > m.sendMaxBytes\n\tif isTooBig && m.compressionPool == nil {\n\t\treturn NewError(CodeResourceExhausted, fmt.Errorf(\n\t\t\t\"message size %d exceeds sendMaxBytes %d: enabling request compression may help\",\n\t\t\tlen(data),\n\t\t\tm.sendMaxBytes,\n\t\t))\n\t}\n\tif !isTooBig {\n\t\turl := m.buildGetURL(data, false /* compressed */)\n\t\tif m.getURLMaxBytes <= 0 || len(url.String()) < m.getURLMaxBytes {\n\t\t\tm.writeWithGet(url)\n\t\t\treturn nil\n\t\t}\n\t\tif m.compressionPool == nil {\n\t\t\tif m.getUseFallback {\n\t\t\t\treturn m.write(data)\n\t\t\t}\n\t\t\treturn NewError(CodeResourceExhausted, fmt.Errorf(\n\t\t\t\t\"url size %d exceeds getURLMaxBytes %d: enabling request compression may help\",\n\t\t\t\tlen(url.String()),\n\t\t\t\tm.getURLMaxBytes,\n\t\t\t))\n\t\t}\n\t}\n\t// Compress message to try to make it fit in the URL.\n\tuncompressed := bytes.NewBuffer(data)\n\tdefer m.bufferPool.Put(uncompressed)\n\tcompressed := m.bufferPool.Get()\n\tdefer m.bufferPool.Put(compressed)\n\tif err := m.compressionPool.Compress(compressed, uncompressed); err != nil {\n\t\treturn err\n\t}\n\tif m.sendMaxBytes > 0 && compressed.Len() > m.sendMaxBytes {\n\t\treturn NewError(CodeResourceExhausted, fmt.Errorf(\"compressed message size %d exceeds sendMaxBytes %d\", compressed.Len(), m.sendMaxBytes))\n\t}\n\turl := m.buildGetURL(compressed.Bytes(), true /* compressed */)\n\tif m.getURLMaxBytes <= 0 || len(url.String()) < m.getURLMaxBytes {\n\t\tm.writeWithGet(url)\n\t\treturn nil\n\t}\n\tif m.getUseFallback {\n\t\tsetHeaderCanonical(m.header, connectUnaryHeaderCompression, m.compressionName)\n\t\treturn m.write(compressed.Bytes())\n\t}\n\treturn NewError(CodeResourceExhausted, fmt.Errorf(\"compressed url size %d exceeds getURLMaxBytes %d\", len(url.String()), m.getURLMaxBytes))\n}\n\nfunc (m *connectUnaryRequestMarshaler) buildGetURL(data []byte, compressed bool) *url.URL {\n\turl := *m.duplexCall.URL()\n\tquery := url.Query()\n\tquery.Set(connectUnaryConnectQueryParameter, connectUnaryConnectQueryValue)\n\tquery.Set(connectUnaryEncodingQueryParameter, m.codec.Name())\n\tif m.stableCodec.IsBinary() || compressed {\n\t\tquery.Set(connectUnaryMessageQueryParameter, encodeBinaryQueryValue(data))\n\t\tquery.Set(connectUnaryBase64QueryParameter, \"1\")\n\t} else {\n\t\tquery.Set(connectUnaryMessageQueryParameter, string(data))\n\t}\n\tif compressed {\n\t\tquery.Set(connectUnaryCompressionQueryParameter, m.compressionName)\n\t}\n\turl.RawQuery = query.Encode()\n\treturn &url\n}\n\nfunc (m *connectUnaryRequestMarshaler) writeWithGet(url *url.URL) {\n\tdelHeaderCanonical(m.header, connectHeaderProtocolVersion)\n\tdelHeaderCanonical(m.header, headerContentType)\n\tdelHeaderCanonical(m.header, headerContentEncoding)\n\tdelHeaderCanonical(m.header, headerContentLength)\n\tm.duplexCall.SetMethod(http.MethodGet)\n\t*m.duplexCall.URL() = *url\n}\n\ntype connectUnaryUnmarshaler struct {\n\tctx             context.Context //nolint:containedctx\n\treader          io.Reader\n\tcodec           Codec\n\tcompressionPool *compressionPool\n\tbufferPool      *bufferPool\n\talreadyRead     bool\n\treadMaxBytes    int\n}\n\nfunc (u *connectUnaryUnmarshaler) Unmarshal(message any) *Error {\n\treturn u.UnmarshalFunc(message, u.codec.Unmarshal)\n}\n\nfunc (u *connectUnaryUnmarshaler) UnmarshalFunc(message any, unmarshal func([]byte, any) error) *Error {\n\tif u.alreadyRead {\n\t\treturn NewError(CodeInternal, io.EOF)\n\t}\n\tu.alreadyRead = true\n\tdata := u.bufferPool.Get()\n\tdefer u.bufferPool.Put(data)\n\treader := u.reader\n\tif u.readMaxBytes > 0 && int64(u.readMaxBytes) < math.MaxInt64 {\n\t\treader = io.LimitReader(u.reader, int64(u.readMaxBytes)+1)\n\t}\n\t// ReadFrom ignores io.EOF, so any error here is real.\n\tbytesRead, err := data.ReadFrom(reader)\n\tif err != nil {\n\t\terr = wrapIfMaxBytesError(err, \"read first %d bytes of message\", bytesRead)\n\t\terr = wrapIfContextDone(u.ctx, err)\n\t\tif connectErr, ok := asError(err); ok {\n\t\t\treturn connectErr\n\t\t}\n\t\treturn errorf(CodeUnknown, \"read message: %w\", err)\n\t}\n\tif u.readMaxBytes > 0 && bytesRead > int64(u.readMaxBytes) {\n\t\t// Attempt to read to end in order to allow connection re-use\n\t\tdiscardedBytes, err := io.Copy(io.Discard, u.reader)\n\t\tif err != nil {\n\t\t\treturn errorf(CodeResourceExhausted, \"message is larger than configured max %d - unable to determine message size: %w\", u.readMaxBytes, err)\n\t\t}\n\t\treturn errorf(CodeResourceExhausted, \"message size %d is larger than configured max %d\", bytesRead+discardedBytes, u.readMaxBytes)\n\t}\n\tif data.Len() > 0 && u.compressionPool != nil {\n\t\tdecompressed := u.bufferPool.Get()\n\t\tdefer u.bufferPool.Put(decompressed)\n\t\tif err := u.compressionPool.Decompress(decompressed, data, int64(u.readMaxBytes)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdata = decompressed\n\t}\n\tif err := unmarshal(data.Bytes(), message); err != nil {\n\t\treturn errorf(CodeInvalidArgument, \"unmarshal message: %w\", err)\n\t}\n\treturn nil\n}\n\ntype connectWireDetail ErrorDetail\n\nfunc (d *connectWireDetail) MarshalJSON() ([]byte, error) {\n\tif d.wireJSON != \"\" {\n\t\t// If we unmarshaled this detail from JSON, return the original data. This\n\t\t// lets proxies w/o protobuf descriptors preserve human-readable details.\n\t\treturn []byte(d.wireJSON), nil\n\t}\n\twire := struct {\n\t\tType  string          `json:\"type\"`\n\t\tValue string          `json:\"value\"`\n\t\tDebug json.RawMessage `json:\"debug,omitempty\"`\n\t}{\n\t\tType:  typeNameFromURL(d.pbAny.GetTypeUrl()),\n\t\tValue: base64.RawStdEncoding.EncodeToString(d.pbAny.GetValue()),\n\t}\n\t// Try to produce debug info, but expect failure when we don't have\n\t// descriptors.\n\tmsg, err := d.getInner()\n\tif err == nil {\n\t\tvar codec protoJSONCodec\n\t\tdebug, err := codec.Marshal(msg)\n\t\tif err == nil {\n\t\t\twire.Debug = debug\n\t\t}\n\t}\n\treturn json.Marshal(wire)\n}\n\nfunc (d *connectWireDetail) UnmarshalJSON(data []byte) error {\n\tvar wire struct {\n\t\tType  string `json:\"type\"`\n\t\tValue string `json:\"value\"`\n\t}\n\tif err := json.Unmarshal(data, &wire); err != nil {\n\t\treturn err\n\t}\n\tif !strings.Contains(wire.Type, \"/\") {\n\t\twire.Type = defaultAnyResolverPrefix + wire.Type\n\t}\n\tdecoded, err := DecodeBinaryHeader(wire.Value)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"decode base64: %w\", err)\n\t}\n\t*d = connectWireDetail{\n\t\tpbAny: &anypb.Any{\n\t\t\tTypeUrl: wire.Type,\n\t\t\tValue:   decoded,\n\t\t},\n\t\twireJSON: string(data),\n\t}\n\treturn nil\n}\n\nfunc (d *connectWireDetail) getInner() (proto.Message, error) {\n\tif d.pbInner != nil {\n\t\treturn d.pbInner, nil\n\t}\n\treturn d.pbAny.UnmarshalNew()\n}\n\ntype connectWireError struct {\n\tCode    Code                 `json:\"code\"`\n\tMessage string               `json:\"message,omitempty\"`\n\tDetails []*connectWireDetail `json:\"details,omitempty\"`\n}\n\nfunc newConnectWireError(err error) *connectWireError {\n\twire := &connectWireError{\n\t\tCode:    CodeUnknown,\n\t\tMessage: err.Error(),\n\t}\n\tif connectErr, ok := asError(err); ok {\n\t\twire.Code = connectErr.Code()\n\t\twire.Message = connectErr.Message()\n\t\tif len(connectErr.details) > 0 {\n\t\t\twire.Details = make([]*connectWireDetail, len(connectErr.details))\n\t\t\tfor i, detail := range connectErr.details {\n\t\t\t\twire.Details[i] = (*connectWireDetail)(detail)\n\t\t\t}\n\t\t}\n\t}\n\treturn wire\n}\n\nfunc (e *connectWireError) asError() *Error {\n\tif e == nil {\n\t\treturn nil\n\t}\n\tif e.Code < minCode || e.Code > maxCode {\n\t\te.Code = CodeUnknown\n\t}\n\terr := NewWireError(e.Code, errors.New(e.Message))\n\tif len(e.Details) > 0 {\n\t\terr.details = make([]*ErrorDetail, len(e.Details))\n\t\tfor i, detail := range e.Details {\n\t\t\terr.details[i] = (*ErrorDetail)(detail)\n\t\t}\n\t}\n\treturn err\n}\n\nfunc (e *connectWireError) UnmarshalJSON(data []byte) error {\n\t// We want to be lenient if the JSON has an unrecognized or invalid code.\n\t// So if that occurs, we leave the code unset but can still de-serialize\n\t// the other fields from the input JSON.\n\tvar wireError struct {\n\t\tCode    string               `json:\"code\"`\n\t\tMessage string               `json:\"message\"`\n\t\tDetails []*connectWireDetail `json:\"details\"`\n\t}\n\terr := json.Unmarshal(data, &wireError)\n\tif err != nil {\n\t\treturn err\n\t}\n\te.Message = wireError.Message\n\te.Details = wireError.Details\n\t// This will leave e.Code unset if we can't unmarshal the given string.\n\t_ = e.Code.UnmarshalText([]byte(wireError.Code))\n\treturn nil\n}\n\ntype connectEndStreamMessage struct {\n\tError   *connectWireError `json:\"error,omitempty\"`\n\tTrailer http.Header       `json:\"metadata,omitempty\"`\n}\n\nfunc connectCodeToHTTP(code Code) int {\n\t// Return literals rather than named constants from the HTTP package to make\n\t// it easier to compare this function to the Connect specification.\n\tswitch code {\n\tcase CodeCanceled:\n\t\treturn 499\n\tcase CodeUnknown:\n\t\treturn 500\n\tcase CodeInvalidArgument:\n\t\treturn 400\n\tcase CodeDeadlineExceeded:\n\t\treturn 504\n\tcase CodeNotFound:\n\t\treturn 404\n\tcase CodeAlreadyExists:\n\t\treturn 409\n\tcase CodePermissionDenied:\n\t\treturn 403\n\tcase CodeResourceExhausted:\n\t\treturn 429\n\tcase CodeFailedPrecondition:\n\t\treturn 400\n\tcase CodeAborted:\n\t\treturn 409\n\tcase CodeOutOfRange:\n\t\treturn 400\n\tcase CodeUnimplemented:\n\t\treturn 501\n\tcase CodeInternal:\n\t\treturn 500\n\tcase CodeUnavailable:\n\t\treturn 503\n\tcase CodeDataLoss:\n\t\treturn 500\n\tcase CodeUnauthenticated:\n\t\treturn 401\n\tdefault:\n\t\treturn 500 // same as CodeUnknown\n\t}\n}\n\nfunc connectCodecFromContentType(streamType StreamType, contentType string) string {\n\tif streamType == StreamTypeUnary {\n\t\treturn strings.TrimPrefix(contentType, connectUnaryContentTypePrefix)\n\t}\n\treturn strings.TrimPrefix(contentType, connectStreamingContentTypePrefix)\n}\n\nfunc connectContentTypeFromCodecName(streamType StreamType, name string) string {\n\tif streamType == StreamTypeUnary {\n\t\treturn connectUnaryContentTypePrefix + name\n\t}\n\treturn connectStreamingContentTypePrefix + name\n}\n\n// encodeBinaryQueryValue URL-safe base64-encodes data, without padding.\nfunc encodeBinaryQueryValue(data []byte) string {\n\treturn base64.RawURLEncoding.EncodeToString(data)\n}\n\n// binaryQueryValueReader creates a reader that can read either padded or\n// unpadded URL-safe base64 from a string.\nfunc binaryQueryValueReader(data string) io.Reader {\n\tstringReader := strings.NewReader(data)\n\tif len(data)%4 != 0 {\n\t\t// Data definitely isn't padded.\n\t\treturn base64.NewDecoder(base64.RawURLEncoding, stringReader)\n\t}\n\t// Data is padded, or no padding was necessary.\n\treturn base64.NewDecoder(base64.URLEncoding, stringReader)\n}\n\n// queryValueReader creates a reader for a string that may be URL-safe base64\n// encoded.\nfunc queryValueReader(data string, base64Encoded bool) io.Reader {\n\tif base64Encoded {\n\t\treturn binaryQueryValueReader(data)\n\t}\n\treturn strings.NewReader(data)\n}\n\nfunc connectValidateUnaryResponseContentType(\n\trequestCodecName string,\n\thttpMethod string,\n\tstatusCode int,\n\tstatusMsg string,\n\tresponseContentType string,\n) *Error {\n\tif statusCode != http.StatusOK {\n\t\tif statusCode == http.StatusNotModified && httpMethod == http.MethodGet {\n\t\t\treturn NewWireError(CodeUnknown, errNotModifiedClient)\n\t\t}\n\t\t// Error responses must be JSON-encoded.\n\t\tif responseContentType == connectUnaryContentTypePrefix+codecNameJSON ||\n\t\t\tresponseContentType == connectUnaryContentTypePrefix+codecNameJSONCharsetUTF8 {\n\t\t\treturn nil\n\t\t}\n\t\treturn NewError(\n\t\t\thttpToCode(statusCode),\n\t\t\terrors.New(statusMsg),\n\t\t)\n\t}\n\t// Normal responses must have valid content-type that indicates same codec as the request.\n\tif !strings.HasPrefix(responseContentType, connectUnaryContentTypePrefix) {\n\t\t// Doesn't even look like a Connect response? Use code \"unknown\".\n\t\treturn errorf(\n\t\t\tCodeUnknown,\n\t\t\t\"invalid content-type: %q; expecting %q\",\n\t\t\tresponseContentType,\n\t\t\tconnectUnaryContentTypePrefix+requestCodecName,\n\t\t)\n\t}\n\tresponseCodecName := connectCodecFromContentType(\n\t\tStreamTypeUnary,\n\t\tresponseContentType,\n\t)\n\tif responseCodecName == requestCodecName {\n\t\treturn nil\n\t}\n\t// HACK: We likely want a better way to handle the optional \"charset\" parameter\n\t//       for application/json, instead of hard-coding. But this suffices for now.\n\tif (responseCodecName == codecNameJSON && requestCodecName == codecNameJSONCharsetUTF8) ||\n\t\t(responseCodecName == codecNameJSONCharsetUTF8 && requestCodecName == codecNameJSON) {\n\t\t// Both are JSON\n\t\treturn nil\n\t}\n\treturn errorf(\n\t\tCodeInternal,\n\t\t\"invalid content-type: %q; expecting %q\",\n\t\tresponseContentType,\n\t\tconnectUnaryContentTypePrefix+requestCodecName,\n\t)\n}\n\nfunc connectValidateStreamResponseContentType(requestCodecName string, streamType StreamType, responseContentType string) *Error {\n\t// Responses must have valid content-type that indicates same codec as the request.\n\tif !strings.HasPrefix(responseContentType, connectStreamingContentTypePrefix) {\n\t\t// Doesn't even look like a Connect response? Use code \"unknown\".\n\t\treturn errorf(\n\t\t\tCodeUnknown,\n\t\t\t\"invalid content-type: %q; expecting %q\",\n\t\t\tresponseContentType,\n\t\t\tconnectStreamingContentTypePrefix+requestCodecName,\n\t\t)\n\t}\n\tresponseCodecName := connectCodecFromContentType(\n\t\tstreamType,\n\t\tresponseContentType,\n\t)\n\tif responseCodecName != requestCodecName {\n\t\treturn errorf(\n\t\t\tCodeInternal,\n\t\t\t\"invalid content-type: %q; expecting %q\",\n\t\t\tresponseContentType,\n\t\t\tconnectStreamingContentTypePrefix+requestCodecName,\n\t\t)\n\t}\n\treturn nil\n}\n\nfunc connectCheckProtocolVersion(request *http.Request, required bool) *Error {\n\tswitch request.Method {\n\tcase http.MethodGet:\n\t\tversion := request.URL.Query().Get(connectUnaryConnectQueryParameter)\n\t\tif version == \"\" && required {\n\t\t\treturn errorf(CodeInvalidArgument, \"missing required query parameter: set %s to %q\", connectUnaryConnectQueryParameter, connectUnaryConnectQueryValue)\n\t\t} else if version != \"\" && version != connectUnaryConnectQueryValue {\n\t\t\treturn errorf(CodeInvalidArgument, \"%s must be %q: got %q\", connectUnaryConnectQueryParameter, connectUnaryConnectQueryValue, version)\n\t\t}\n\tcase http.MethodPost:\n\t\tversion := getHeaderCanonical(request.Header, connectHeaderProtocolVersion)\n\t\tif version == \"\" && required {\n\t\t\treturn errorf(CodeInvalidArgument, \"missing required header: set %s to %q\", connectHeaderProtocolVersion, connectProtocolVersion)\n\t\t} else if version != \"\" && version != connectProtocolVersion {\n\t\t\treturn errorf(CodeInvalidArgument, \"%s must be %q: got %q\", connectHeaderProtocolVersion, connectProtocolVersion, version)\n\t\t}\n\tdefault:\n\t\treturn errorf(CodeInvalidArgument, \"unsupported method: %q\", request.Method)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "protocol_connect_test.go",
          "type": "blob",
          "size": 10.9150390625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/descriptorpb\"\n\t\"google.golang.org/protobuf/types/known/durationpb\"\n)\n\nfunc TestConnectErrorDetailMarshaling(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tname        string\n\t\terrorDetail proto.Message\n\t\texpectDebug any\n\t}{\n\t\t{\n\t\t\tname: \"normal\",\n\t\t\terrorDetail: &descriptorpb.FieldOptions{\n\t\t\t\tDeprecated: proto.Bool(true),\n\t\t\t\tJstype:     descriptorpb.FieldOptions_JS_STRING.Enum(),\n\t\t\t},\n\t\t\texpectDebug: map[string]any{\n\t\t\t\t\"deprecated\": true,\n\t\t\t\t\"jstype\":     \"JS_STRING\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"well-known type with custom JSON\",\n\t\t\terrorDetail: durationpb.New(time.Second),\n\t\t\texpectDebug: \"1s\", // special JS representation as duration string\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tdetail, err := NewErrorDetail(testCase.errorDetail)\n\t\t\tassert.Nil(t, err)\n\t\t\tdata, err := json.Marshal((*connectWireDetail)(detail))\n\t\t\tassert.Nil(t, err)\n\t\t\tt.Logf(\"marshaled error detail: %s\", string(data))\n\n\t\t\tvar unmarshaled connectWireDetail\n\t\t\tassert.Nil(t, json.Unmarshal(data, &unmarshaled))\n\t\t\tassert.Equal(t, unmarshaled.wireJSON, string(data))\n\t\t\tassert.Equal(t, unmarshaled.pbAny, detail.pbAny)\n\n\t\t\tvar extractDetails struct {\n\t\t\t\tDebug any `json:\"debug\"`\n\t\t\t}\n\t\t\tassert.Nil(t, json.Unmarshal(data, &extractDetails))\n\t\t\tassert.Equal(t, extractDetails.Debug, testCase.expectDebug)\n\t\t})\n\t}\n}\n\nfunc TestConnectErrorDetailMarshalingNoDescriptor(t *testing.T) {\n\tt.Parallel()\n\traw := `{\"type\":\"acme.user.v1.User\",\"value\":\"DEADBF\",` +\n\t\t`\"debug\":{\"email\":\"someone@connectrpc.com\"}}`\n\tvar detail connectWireDetail\n\tassert.Nil(t, json.Unmarshal([]byte(raw), &detail))\n\tassert.Equal(t, detail.pbAny.GetTypeUrl(), defaultAnyResolverPrefix+\"acme.user.v1.User\")\n\n\t_, err := (*ErrorDetail)(&detail).Value()\n\tassert.NotNil(t, err)\n\tassert.True(t, strings.HasSuffix(err.Error(), \"not found\"))\n\n\tencoded, err := json.Marshal(&detail)\n\tassert.Nil(t, err)\n\tassert.Equal(t, string(encoded), raw)\n}\n\nfunc TestConnectEndOfResponseCanonicalTrailers(t *testing.T) {\n\tt.Parallel()\n\n\tbuffer := bytes.Buffer{}\n\tbufferPool := newBufferPool()\n\n\tendStreamMessage := connectEndStreamMessage{Trailer: make(http.Header)}\n\tendStreamMessage.Trailer[\"not-canonical-header\"] = []string{\"a\"}\n\tendStreamMessage.Trailer[\"mixed-Canonical\"] = []string{\"b\"}\n\tendStreamMessage.Trailer[\"Mixed-Canonical\"] = []string{\"b\"}\n\tendStreamMessage.Trailer[\"Canonical-Header\"] = []string{\"c\"}\n\tendStreamData, err := json.Marshal(endStreamMessage)\n\tassert.Nil(t, err)\n\n\twriter := envelopeWriter{\n\t\tsender:     writeSender{writer: &buffer},\n\t\tbufferPool: bufferPool,\n\t}\n\terr = writer.Write(&envelope{\n\t\tFlags: connectFlagEnvelopeEndStream,\n\t\tData:  bytes.NewBuffer(endStreamData),\n\t})\n\tassert.Nil(t, err)\n\n\tunmarshaler := connectStreamingUnmarshaler{\n\t\tenvelopeReader: envelopeReader{\n\t\t\tctx:        context.Background(),\n\t\t\treader:     &buffer,\n\t\t\tbufferPool: bufferPool,\n\t\t},\n\t}\n\terr = unmarshaler.Unmarshal(nil) // parameter won't be used\n\tassert.ErrorIs(t, err, errSpecialEnvelope)\n\tassert.Equal(t, unmarshaler.Trailer().Values(\"Not-Canonical-Header\"), []string{\"a\"})\n\tassert.Equal(t, unmarshaler.Trailer().Values(\"Mixed-Canonical\"), []string{\"b\", \"b\"})\n\tassert.Equal(t, unmarshaler.Trailer().Values(\"Canonical-Header\"), []string{\"c\"})\n}\n\nfunc TestConnectValidateUnaryResponseContentType(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tcodecName            string\n\t\tget                  bool\n\t\tstatusCode           int\n\t\tresponseContentType  string\n\t\texpectCode           Code\n\t\texpectBadContentType bool\n\t\texpectNotModified    bool\n\t}{\n\t\t// Allowed content-types for OK responses.\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tstatusCode:          http.StatusOK,\n\t\t\tresponseContentType: \"application/proto\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tstatusCode:          http.StatusOK,\n\t\t\tresponseContentType: \"application/json\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tstatusCode:          http.StatusOK,\n\t\t\tresponseContentType: \"application/json; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSONCharsetUTF8,\n\t\t\tstatusCode:          http.StatusOK,\n\t\t\tresponseContentType: \"application/json\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSONCharsetUTF8,\n\t\t\tstatusCode:          http.StatusOK,\n\t\t\tresponseContentType: \"application/json; charset=utf-8\",\n\t\t},\n\t\t// Allowed content-types for error responses.\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tstatusCode:          http.StatusNotFound,\n\t\t\tresponseContentType: \"application/json\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tstatusCode:          http.StatusBadRequest,\n\t\t\tresponseContentType: \"application/json; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tstatusCode:          http.StatusInternalServerError,\n\t\t\tresponseContentType: \"application/json\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tstatusCode:          http.StatusPreconditionFailed,\n\t\t\tresponseContentType: \"application/json; charset=utf-8\",\n\t\t},\n\t\t// 304 Not Modified for GET request gets a special error, regardless of content-type\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tget:                 true,\n\t\t\tstatusCode:          http.StatusNotModified,\n\t\t\tresponseContentType: \"application/json\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t\texpectNotModified:   true,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tget:                 true,\n\t\t\tstatusCode:          http.StatusNotModified,\n\t\t\tresponseContentType: \"application/json\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t\texpectNotModified:   true,\n\t\t},\n\t\t// OK status, invalid content-type\n\t\t{\n\t\t\tcodecName:            codecNameProto,\n\t\t\tstatusCode:           http.StatusOK,\n\t\t\tresponseContentType:  \"application/proto; charset=utf-8\",\n\t\t\texpectCode:           CodeInternal,\n\t\t\texpectBadContentType: true,\n\t\t},\n\t\t{\n\t\t\tcodecName:            codecNameProto,\n\t\t\tstatusCode:           http.StatusOK,\n\t\t\tresponseContentType:  \"application/json\",\n\t\t\texpectCode:           CodeInternal,\n\t\t\texpectBadContentType: true,\n\t\t},\n\t\t{\n\t\t\tcodecName:            codecNameJSON,\n\t\t\tstatusCode:           http.StatusOK,\n\t\t\tresponseContentType:  \"application/proto\",\n\t\t\texpectCode:           CodeInternal,\n\t\t\texpectBadContentType: true,\n\t\t},\n\t\t{\n\t\t\tcodecName:            codecNameJSON,\n\t\t\tstatusCode:           http.StatusOK,\n\t\t\tresponseContentType:  \"some/garbage\",\n\t\t\texpectCode:           CodeUnknown, // doesn't even look like it could be connect protocol\n\t\t\texpectBadContentType: true,\n\t\t},\n\t\t// Error status, invalid content-type, returns code based on HTTP status code\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tstatusCode:          http.StatusNotFound,\n\t\t\tresponseContentType: \"application/proto\",\n\t\t\texpectCode:          httpToCode(http.StatusNotFound),\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tstatusCode:          http.StatusBadRequest,\n\t\t\tresponseContentType: \"some/garbage\",\n\t\t\texpectCode:          httpToCode(http.StatusBadRequest),\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tstatusCode:          http.StatusTooManyRequests,\n\t\t\tresponseContentType: \"some/garbage\",\n\t\t\texpectCode:          httpToCode(http.StatusTooManyRequests),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\thttpMethod := http.MethodPost\n\t\tif testCase.get {\n\t\t\thttpMethod = http.MethodGet\n\t\t}\n\t\ttestCaseName := fmt.Sprintf(\"%s_%s->%d_%s\", httpMethod, testCase.codecName, testCase.statusCode, testCase.responseContentType)\n\t\tt.Run(testCaseName, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\terr := connectValidateUnaryResponseContentType(\n\t\t\t\ttestCase.codecName,\n\t\t\t\thttpMethod,\n\t\t\t\ttestCase.statusCode,\n\t\t\t\thttp.StatusText(testCase.statusCode),\n\t\t\t\ttestCase.responseContentType,\n\t\t\t)\n\t\t\tif testCase.expectCode == 0 {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t} else if assert.NotNil(t, err) {\n\t\t\t\tassert.Equal(t, CodeOf(err), testCase.expectCode)\n\t\t\t\tswitch {\n\t\t\t\tcase testCase.expectNotModified:\n\t\t\t\t\tassert.ErrorIs(t, err, errNotModified)\n\t\t\t\tcase testCase.expectBadContentType:\n\t\t\t\t\tassert.True(t, strings.Contains(err.Message(), fmt.Sprintf(\"invalid content-type: %q; expecting\", testCase.responseContentType)))\n\t\t\t\tdefault:\n\t\t\t\t\tassert.Equal(t, err.Message(), http.StatusText(testCase.statusCode))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestConnectValidateStreamResponseContentType(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tcodecName           string\n\t\tresponseContentType string\n\t\texpectCode          Code\n\t}{\n\t\t// Allowed content-types\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"application/connect+proto\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/connect+json\",\n\t\t},\n\t\t// Mismatched response codec\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"application/connect+json\",\n\t\t\texpectCode:          CodeInternal,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/connect+proto\",\n\t\t\texpectCode:          CodeInternal,\n\t\t},\n\t\t// Disallowed content-types\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/connect+json; charset=utf-8\",\n\t\t\texpectCode:          CodeInternal, // *almost* looks right\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"application/proto\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/json\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/json; charset=utf-8\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"some/garbage\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\ttestCaseName := fmt.Sprintf(\"%s->%s\", testCase.codecName, testCase.responseContentType)\n\t\tt.Run(testCaseName, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\terr := connectValidateStreamResponseContentType(\n\t\t\t\ttestCase.codecName,\n\t\t\t\tStreamTypeServer,\n\t\t\t\ttestCase.responseContentType,\n\t\t\t)\n\t\t\tif testCase.expectCode == 0 {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t} else if assert.NotNil(t, err) {\n\t\t\t\tassert.Equal(t, CodeOf(err), testCase.expectCode)\n\t\t\t\tassert.True(t, strings.Contains(err.Message(), fmt.Sprintf(\"invalid content-type: %q; expecting\", testCase.responseContentType)))\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "protocol_grpc.go",
          "type": "blob",
          "size": 31.3994140625,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tstatusv1 \"connectrpc.com/connect/internal/gen/connectext/grpc/status/v1\"\n)\n\nconst (\n\tgrpcHeaderCompression       = \"Grpc-Encoding\"\n\tgrpcHeaderAcceptCompression = \"Grpc-Accept-Encoding\"\n\tgrpcHeaderTimeout           = \"Grpc-Timeout\"\n\tgrpcHeaderStatus            = \"Grpc-Status\"\n\tgrpcHeaderMessage           = \"Grpc-Message\"\n\tgrpcHeaderDetails           = \"Grpc-Status-Details-Bin\"\n\n\tgrpcFlagEnvelopeTrailer = 0b10000000\n\n\tgrpcContentTypeDefault    = \"application/grpc\"\n\tgrpcWebContentTypeDefault = \"application/grpc-web\"\n\tgrpcContentTypePrefix     = grpcContentTypeDefault + \"+\"\n\tgrpcWebContentTypePrefix  = grpcWebContentTypeDefault + \"+\"\n\n\theaderXUserAgent = \"X-User-Agent\"\n\n\tupperhex = \"0123456789ABCDEF\"\n)\n\nvar (\n\terrTrailersWithoutGRPCStatus = fmt.Errorf(\"protocol error: no %s trailer: %w\", grpcHeaderStatus, io.ErrUnexpectedEOF)\n\n\t// defaultGrpcUserAgent follows\n\t// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#user-agents:\n\t//\n\t//\tWhile the protocol does not require a user-agent to function it is recommended\n\t//\tthat clients provide a structured user-agent string that provides a basic\n\t//\tdescription of the calling library, version & platform to facilitate issue diagnosis\n\t//\tin heterogeneous environments. The following structure is recommended to library developers:\n\t//\n\t//\tUser-Agent → \"grpc-\" Language ?(\"-\" Variant) \"/\" Version ?( \" (\"  *(AdditionalProperty \";\") \")\" )\n\t//\n\t//nolint:gochecknoglobals\n\tdefaultGrpcUserAgent = fmt.Sprintf(\"grpc-go-connect/%s (%s)\", Version, runtime.Version())\n\t//nolint:gochecknoglobals\n\tgrpcAllowedMethods = map[string]struct{}{\n\t\thttp.MethodPost: {},\n\t}\n)\n\ntype protocolGRPC struct {\n\tweb bool\n}\n\n// NewHandler implements protocol, so it must return an interface.\nfunc (g *protocolGRPC) NewHandler(params *protocolHandlerParams) protocolHandler {\n\tbare, prefix := grpcContentTypeDefault, grpcContentTypePrefix\n\tif g.web {\n\t\tbare, prefix = grpcWebContentTypeDefault, grpcWebContentTypePrefix\n\t}\n\tcontentTypes := make(map[string]struct{})\n\tfor _, name := range params.Codecs.Names() {\n\t\tcontentTypes[canonicalizeContentType(prefix+name)] = struct{}{}\n\t}\n\tif params.Codecs.Get(codecNameProto) != nil {\n\t\tcontentTypes[bare] = struct{}{}\n\t}\n\treturn &grpcHandler{\n\t\tprotocolHandlerParams: *params,\n\t\tweb:                   g.web,\n\t\taccept:                contentTypes,\n\t}\n}\n\n// NewClient implements protocol, so it must return an interface.\nfunc (g *protocolGRPC) NewClient(params *protocolClientParams) (protocolClient, error) {\n\tpeer := newPeerFromURL(params.URL, ProtocolGRPC)\n\tif g.web {\n\t\tpeer = newPeerFromURL(params.URL, ProtocolGRPCWeb)\n\t}\n\treturn &grpcClient{\n\t\tprotocolClientParams: *params,\n\t\tweb:                  g.web,\n\t\tpeer:                 peer,\n\t}, nil\n}\n\ntype grpcHandler struct {\n\tprotocolHandlerParams\n\n\tweb    bool\n\taccept map[string]struct{}\n}\n\nfunc (g *grpcHandler) Methods() map[string]struct{} {\n\treturn grpcAllowedMethods\n}\n\nfunc (g *grpcHandler) ContentTypes() map[string]struct{} {\n\treturn g.accept\n}\n\nfunc (*grpcHandler) SetTimeout(request *http.Request) (context.Context, context.CancelFunc, error) {\n\ttimeout, err := grpcParseTimeout(getHeaderCanonical(request.Header, grpcHeaderTimeout))\n\tif err != nil && !errors.Is(err, errNoTimeout) {\n\t\t// Errors here indicate that the client sent an invalid timeout header, so\n\t\t// the error text is safe to send back.\n\t\treturn nil, nil, NewError(CodeInvalidArgument, err)\n\t} else if err != nil {\n\t\t// err wraps errNoTimeout, nothing to do.\n\t\treturn request.Context(), nil, nil //nolint:nilerr\n\t}\n\tctx, cancel := context.WithTimeout(request.Context(), timeout)\n\treturn ctx, cancel, nil\n}\n\nfunc (g *grpcHandler) CanHandlePayload(_ *http.Request, contentType string) bool {\n\t_, ok := g.accept[contentType]\n\treturn ok\n}\n\nfunc (g *grpcHandler) NewConn(\n\tresponseWriter http.ResponseWriter,\n\trequest *http.Request,\n) (handlerConnCloser, bool) {\n\tctx := request.Context()\n\t// We need to parse metadata before entering the interceptor stack; we'll\n\t// send the error to the client later on.\n\trequestCompression, responseCompression, failed := negotiateCompression(\n\t\tg.CompressionPools,\n\t\tgetHeaderCanonical(request.Header, grpcHeaderCompression),\n\t\tgetHeaderCanonical(request.Header, grpcHeaderAcceptCompression),\n\t)\n\tif failed == nil {\n\t\tfailed = checkServerStreamsCanFlush(g.Spec, responseWriter)\n\t}\n\n\t// Write any remaining headers here:\n\t// (1) any writes to the stream will implicitly send the headers, so we\n\t// should get all of gRPC's required response headers ready.\n\t// (2) interceptors should be able to see these headers.\n\t//\n\t// Since we know that these header keys are already in canonical form, we can\n\t// skip the normalization in Header.Set.\n\theader := responseWriter.Header()\n\theader[headerContentType] = []string{getHeaderCanonical(request.Header, headerContentType)}\n\theader[grpcHeaderAcceptCompression] = []string{g.CompressionPools.CommaSeparatedNames()}\n\tif responseCompression != compressionIdentity {\n\t\theader[grpcHeaderCompression] = []string{responseCompression}\n\t}\n\n\tcodecName := grpcCodecFromContentType(g.web, getHeaderCanonical(request.Header, headerContentType))\n\tcodec := g.Codecs.Get(codecName) // handler.go guarantees this is not nil\n\tprotocolName := ProtocolGRPC\n\tif g.web {\n\t\tprotocolName = ProtocolGRPCWeb\n\t}\n\tconn := wrapHandlerConnWithCodedErrors(&grpcHandlerConn{\n\t\tspec: g.Spec,\n\t\tpeer: Peer{\n\t\t\tAddr:     request.RemoteAddr,\n\t\t\tProtocol: protocolName,\n\t\t},\n\t\tweb:        g.web,\n\t\tbufferPool: g.BufferPool,\n\t\tprotobuf:   g.Codecs.Protobuf(), // for errors\n\t\tmarshaler: grpcMarshaler{\n\t\t\tenvelopeWriter: envelopeWriter{\n\t\t\t\tctx:              ctx,\n\t\t\t\tsender:           writeSender{writer: responseWriter},\n\t\t\t\tcompressionPool:  g.CompressionPools.Get(responseCompression),\n\t\t\t\tcodec:            codec,\n\t\t\t\tcompressMinBytes: g.CompressMinBytes,\n\t\t\t\tbufferPool:       g.BufferPool,\n\t\t\t\tsendMaxBytes:     g.SendMaxBytes,\n\t\t\t},\n\t\t},\n\t\tresponseWriter:  responseWriter,\n\t\tresponseHeader:  make(http.Header),\n\t\tresponseTrailer: make(http.Header),\n\t\trequest:         request,\n\t\tunmarshaler: grpcUnmarshaler{\n\t\t\tenvelopeReader: envelopeReader{\n\t\t\t\tctx:             ctx,\n\t\t\t\treader:          request.Body,\n\t\t\t\tcodec:           codec,\n\t\t\t\tcompressionPool: g.CompressionPools.Get(requestCompression),\n\t\t\t\tbufferPool:      g.BufferPool,\n\t\t\t\treadMaxBytes:    g.ReadMaxBytes,\n\t\t\t},\n\t\t\tweb: g.web,\n\t\t},\n\t})\n\tif failed != nil {\n\t\t// Negotiation failed, so we can't establish a stream.\n\t\t_ = conn.Close(failed)\n\t\treturn nil, false\n\t}\n\treturn conn, true\n}\n\ntype grpcClient struct {\n\tprotocolClientParams\n\n\tweb  bool\n\tpeer Peer\n}\n\nfunc (g *grpcClient) Peer() Peer {\n\treturn g.peer\n}\n\nfunc (g *grpcClient) WriteRequestHeader(_ StreamType, header http.Header) {\n\t// We know these header keys are in canonical form, so we can bypass all the\n\t// checks in Header.Set.\n\tif getHeaderCanonical(header, headerUserAgent) == \"\" {\n\t\theader[headerUserAgent] = []string{defaultGrpcUserAgent}\n\t}\n\tif g.web && getHeaderCanonical(header, headerXUserAgent) == \"\" {\n\t\t// The gRPC-Web pseudo-specification seems to require X-User-Agent rather\n\t\t// than User-Agent for all clients, even if they're not browser-based. This\n\t\t// is very odd for a backend client, so we'll split the difference and set\n\t\t// both.\n\t\theader[headerXUserAgent] = []string{defaultGrpcUserAgent}\n\t}\n\theader[headerContentType] = []string{grpcContentTypeFromCodecName(g.web, g.Codec.Name())}\n\t// gRPC handles compression on a per-message basis, so we don't want to\n\t// compress the whole stream. By default, http.Client will ask the server\n\t// to gzip the stream if we don't set Accept-Encoding.\n\theader[\"Accept-Encoding\"] = []string{compressionIdentity}\n\tif g.CompressionName != \"\" && g.CompressionName != compressionIdentity {\n\t\theader[grpcHeaderCompression] = []string{g.CompressionName}\n\t}\n\tif acceptCompression := g.CompressionPools.CommaSeparatedNames(); acceptCompression != \"\" {\n\t\theader[grpcHeaderAcceptCompression] = []string{acceptCompression}\n\t}\n\tif !g.web {\n\t\t// The gRPC-HTTP2 specification requires this - it flushes out proxies that\n\t\t// don't support HTTP trailers.\n\t\theader[\"Te\"] = []string{\"trailers\"}\n\t}\n}\n\nfunc (g *grpcClient) NewConn(\n\tctx context.Context,\n\tspec Spec,\n\theader http.Header,\n) streamingClientConn {\n\tif deadline, ok := ctx.Deadline(); ok {\n\t\tencodedDeadline := grpcEncodeTimeout(time.Until(deadline))\n\t\theader[grpcHeaderTimeout] = []string{encodedDeadline}\n\t}\n\tduplexCall := newDuplexHTTPCall(\n\t\tctx,\n\t\tg.HTTPClient,\n\t\tg.URL,\n\t\tspec,\n\t\theader,\n\t)\n\tconn := &grpcClientConn{\n\t\tspec:             spec,\n\t\tpeer:             g.Peer(),\n\t\tduplexCall:       duplexCall,\n\t\tcompressionPools: g.CompressionPools,\n\t\tbufferPool:       g.BufferPool,\n\t\tprotobuf:         g.Protobuf,\n\t\tmarshaler: grpcMarshaler{\n\t\t\tenvelopeWriter: envelopeWriter{\n\t\t\t\tctx:              ctx,\n\t\t\t\tsender:           duplexCall,\n\t\t\t\tcompressionPool:  g.CompressionPools.Get(g.CompressionName),\n\t\t\t\tcodec:            g.Codec,\n\t\t\t\tcompressMinBytes: g.CompressMinBytes,\n\t\t\t\tbufferPool:       g.BufferPool,\n\t\t\t\tsendMaxBytes:     g.SendMaxBytes,\n\t\t\t},\n\t\t},\n\t\tunmarshaler: grpcUnmarshaler{\n\t\t\tenvelopeReader: envelopeReader{\n\t\t\t\tctx:          ctx,\n\t\t\t\treader:       duplexCall,\n\t\t\t\tcodec:        g.Codec,\n\t\t\t\tbufferPool:   g.BufferPool,\n\t\t\t\treadMaxBytes: g.ReadMaxBytes,\n\t\t\t},\n\t\t},\n\t\tresponseHeader:  make(http.Header),\n\t\tresponseTrailer: make(http.Header),\n\t}\n\tduplexCall.SetValidateResponse(conn.validateResponse)\n\tif g.web {\n\t\tconn.unmarshaler.web = true\n\t\tconn.readTrailers = func(unmarshaler *grpcUnmarshaler, _ *duplexHTTPCall) http.Header {\n\t\t\treturn unmarshaler.WebTrailer()\n\t\t}\n\t} else {\n\t\tconn.readTrailers = func(_ *grpcUnmarshaler, call *duplexHTTPCall) http.Header {\n\t\t\t// To access HTTP trailers, we need to read the body to EOF.\n\t\t\t_, _ = discard(call)\n\t\t\treturn call.ResponseTrailer()\n\t\t}\n\t}\n\treturn wrapClientConnWithCodedErrors(conn)\n}\n\n// grpcClientConn works for both gRPC and gRPC-Web.\ntype grpcClientConn struct {\n\tspec             Spec\n\tpeer             Peer\n\tduplexCall       *duplexHTTPCall\n\tcompressionPools readOnlyCompressionPools\n\tbufferPool       *bufferPool\n\tprotobuf         Codec // for errors\n\tmarshaler        grpcMarshaler\n\tunmarshaler      grpcUnmarshaler\n\tresponseHeader   http.Header\n\tresponseTrailer  http.Header\n\treadTrailers     func(*grpcUnmarshaler, *duplexHTTPCall) http.Header\n}\n\nfunc (cc *grpcClientConn) Spec() Spec {\n\treturn cc.spec\n}\n\nfunc (cc *grpcClientConn) Peer() Peer {\n\treturn cc.peer\n}\n\nfunc (cc *grpcClientConn) Send(msg any) error {\n\tif err := cc.marshaler.Marshal(msg); err != nil {\n\t\treturn err\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (cc *grpcClientConn) RequestHeader() http.Header {\n\treturn cc.duplexCall.Header()\n}\n\nfunc (cc *grpcClientConn) CloseRequest() error {\n\treturn cc.duplexCall.CloseWrite()\n}\n\nfunc (cc *grpcClientConn) Receive(msg any) error {\n\tif err := cc.duplexCall.BlockUntilResponseReady(); err != nil {\n\t\treturn err\n\t}\n\terr := cc.unmarshaler.Unmarshal(msg)\n\tif err == nil {\n\t\treturn nil\n\t}\n\tmergeHeaders(\n\t\tcc.responseTrailer,\n\t\tcc.readTrailers(&cc.unmarshaler, cc.duplexCall),\n\t)\n\tif errors.Is(err, io.EOF) && cc.unmarshaler.bytesRead == 0 && len(cc.responseTrailer) == 0 {\n\t\t// No body and no trailers means a trailers-only response.\n\t\t// Note: per the specification, only the HTTP status code and Content-Type\n\t\t// should be treated as headers. The rest should be treated as trailing\n\t\t// metadata. But it would be unsafe to mutate cc.responseHeader at this\n\t\t// point. So we'll leave cc.responseHeader alone but copy the relevant\n\t\t// metadata into cc.responseTrailer.\n\t\tmergeHeaders(cc.responseTrailer, cc.responseHeader)\n\t\tdelHeaderCanonical(cc.responseTrailer, headerContentType)\n\n\t\t// Try to read the status out of the headers.\n\t\tserverErr := grpcErrorFromTrailer(cc.protobuf, cc.responseHeader)\n\t\tif serverErr == nil {\n\t\t\t// Status says \"OK\". So return original error (io.EOF).\n\t\t\treturn err\n\t\t}\n\t\tserverErr.meta = cc.responseHeader.Clone()\n\t\treturn serverErr\n\t}\n\n\t// See if the server sent an explicit error in the HTTP or gRPC-Web trailers.\n\tserverErr := grpcErrorFromTrailer(cc.protobuf, cc.responseTrailer)\n\tif serverErr != nil && (errors.Is(err, io.EOF) || !errors.Is(serverErr, errTrailersWithoutGRPCStatus)) {\n\t\t// We've either:\n\t\t//   - Cleanly read until the end of the response body and *not* received\n\t\t//   gRPC status trailers, which is a protocol error, or\n\t\t//   - Received an explicit error from the server.\n\t\t//\n\t\t// This is expected from a protocol perspective, but receiving trailers\n\t\t// means that we're _not_ getting a message. For users to realize that\n\t\t// the stream has ended, Receive must return an error.\n\t\tserverErr.meta = cc.responseHeader.Clone()\n\t\tmergeHeaders(serverErr.meta, cc.responseTrailer)\n\t\t_ = cc.duplexCall.CloseWrite()\n\t\treturn serverErr\n\t}\n\t// This was probably an error converting the bytes to a message or an error\n\t// reading from the network. We're going to return it to the\n\t// user, but we also want to close writes so Send errors out.\n\t_ = cc.duplexCall.CloseWrite()\n\treturn err\n}\n\nfunc (cc *grpcClientConn) ResponseHeader() http.Header {\n\t_ = cc.duplexCall.BlockUntilResponseReady()\n\treturn cc.responseHeader\n}\n\nfunc (cc *grpcClientConn) ResponseTrailer() http.Header {\n\t_ = cc.duplexCall.BlockUntilResponseReady()\n\treturn cc.responseTrailer\n}\n\nfunc (cc *grpcClientConn) CloseResponse() error {\n\treturn cc.duplexCall.CloseRead()\n}\n\nfunc (cc *grpcClientConn) onRequestSend(fn func(*http.Request)) {\n\tcc.duplexCall.onRequestSend = fn\n}\n\nfunc (cc *grpcClientConn) validateResponse(response *http.Response) *Error {\n\tif err := grpcValidateResponse(\n\t\tresponse,\n\t\tcc.responseHeader,\n\t\tcc.compressionPools,\n\t\tcc.unmarshaler.web,\n\t\tcc.marshaler.codec.Name(),\n\t); err != nil {\n\t\treturn err\n\t}\n\tcompression := getHeaderCanonical(response.Header, grpcHeaderCompression)\n\tcc.unmarshaler.compressionPool = cc.compressionPools.Get(compression)\n\treturn nil\n}\n\ntype grpcHandlerConn struct {\n\tspec            Spec\n\tpeer            Peer\n\tweb             bool\n\tbufferPool      *bufferPool\n\tprotobuf        Codec // for errors\n\tmarshaler       grpcMarshaler\n\tresponseWriter  http.ResponseWriter\n\tresponseHeader  http.Header\n\tresponseTrailer http.Header\n\twroteToBody     bool\n\trequest         *http.Request\n\tunmarshaler     grpcUnmarshaler\n}\n\nfunc (hc *grpcHandlerConn) Spec() Spec {\n\treturn hc.spec\n}\n\nfunc (hc *grpcHandlerConn) Peer() Peer {\n\treturn hc.peer\n}\n\nfunc (hc *grpcHandlerConn) Receive(msg any) error {\n\tif err := hc.unmarshaler.Unmarshal(msg); err != nil {\n\t\treturn err // already coded\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (hc *grpcHandlerConn) RequestHeader() http.Header {\n\treturn hc.request.Header\n}\n\nfunc (hc *grpcHandlerConn) Send(msg any) error {\n\tdefer flushResponseWriter(hc.responseWriter)\n\tif !hc.wroteToBody {\n\t\tmergeHeaders(hc.responseWriter.Header(), hc.responseHeader)\n\t\thc.wroteToBody = true\n\t}\n\tif err := hc.marshaler.Marshal(msg); err != nil {\n\t\treturn err\n\t}\n\treturn nil // must be a literal nil: nil *Error is a non-nil error\n}\n\nfunc (hc *grpcHandlerConn) ResponseHeader() http.Header {\n\treturn hc.responseHeader\n}\n\nfunc (hc *grpcHandlerConn) ResponseTrailer() http.Header {\n\treturn hc.responseTrailer\n}\n\nfunc (hc *grpcHandlerConn) Close(err error) (retErr error) {\n\tdefer func() {\n\t\t// We don't want to copy unread portions of the body to /dev/null here: if\n\t\t// the client hasn't closed the request body, we'll block until the server\n\t\t// timeout kicks in. This could happen because the client is malicious, but\n\t\t// a well-intentioned client may just not expect the server to be returning\n\t\t// an error for a streaming RPC. Better to accept that we can't always reuse\n\t\t// TCP connections.\n\t\tcloseErr := hc.request.Body.Close()\n\t\tif retErr == nil {\n\t\t\tretErr = closeErr\n\t\t}\n\t}()\n\tdefer flushResponseWriter(hc.responseWriter)\n\t// If we haven't written the headers yet, do so.\n\tif !hc.wroteToBody {\n\t\tmergeHeaders(hc.responseWriter.Header(), hc.responseHeader)\n\t}\n\t// gRPC always sends the error's code, message, details, and metadata as\n\t// trailing metadata. The Connect protocol doesn't do this, so we don't want\n\t// to mutate the trailers map that the user sees.\n\tmergedTrailers := make(\n\t\thttp.Header,\n\t\tlen(hc.responseTrailer)+2, // always make space for status & message\n\t)\n\tmergeHeaders(mergedTrailers, hc.responseTrailer)\n\tgrpcErrorToTrailer(mergedTrailers, hc.protobuf, err)\n\tif hc.web && !hc.wroteToBody && len(hc.responseHeader) == 0 {\n\t\t// We're using gRPC-Web, we haven't yet written to the body, and there are no\n\t\t// custom headers. That means we can send a \"trailers-only\" response and send\n\t\t// trailing metadata as HTTP headers (instead of as trailers).\n\t\tmergeHeaders(hc.responseWriter.Header(), mergedTrailers)\n\t\treturn nil\n\t}\n\tif hc.web {\n\t\t// We're using gRPC-Web and we've already sent the headers, so we write\n\t\t// trailing metadata to the HTTP body.\n\t\tif err := hc.marshaler.MarshalWebTrailers(mergedTrailers); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil // must be a literal nil: nil *Error is a non-nil error\n\t}\n\t// We're using standard gRPC. Even if we haven't written to the body and\n\t// we're sending a \"trailers-only\" response, we must send trailing metadata\n\t// as HTTP trailers. (If we had frame-level control of the HTTP/2 layer, we\n\t// could send trailers-only responses as a single HEADER frame and no DATA\n\t// frames, but net/http doesn't expose APIs that low-level.)\n\t//\n\t// In net/http's ResponseWriter API, we send HTTP trailers by writing to the\n\t// headers map with a special prefix. This prefixing is an implementation\n\t// detail, so we should hide it and _not_ mutate the user-visible headers.\n\t//\n\t// Note that this is _very_ finicky and difficult to test with net/http,\n\t// since correctness depends on low-level framing details. Breaking this\n\t// logic breaks Envoy's gRPC-Web translation.\n\tfor key, values := range mergedTrailers {\n\t\tfor _, value := range values {\n\t\t\t// These are potentially user-supplied, so we can't assume they're in\n\t\t\t// canonical form.\n\t\t\thc.responseWriter.Header().Add(http.TrailerPrefix+key, value)\n\t\t}\n\t}\n\treturn nil\n}\n\ntype grpcMarshaler struct {\n\tenvelopeWriter\n}\n\nfunc (m *grpcMarshaler) MarshalWebTrailers(trailer http.Header) *Error {\n\traw := m.envelopeWriter.bufferPool.Get()\n\tdefer m.envelopeWriter.bufferPool.Put(raw)\n\tfor key, values := range trailer {\n\t\t// Per the Go specification, keys inserted during iteration may be produced\n\t\t// later in the iteration or may be skipped. For safety, avoid mutating the\n\t\t// map if the key is already lower-cased.\n\t\tlower := strings.ToLower(key)\n\t\tif key == lower {\n\t\t\tcontinue\n\t\t}\n\t\tdelete(trailer, key)\n\t\ttrailer[lower] = values\n\t}\n\tif err := trailer.Write(raw); err != nil {\n\t\treturn errorf(CodeInternal, \"format trailers: %w\", err)\n\t}\n\treturn m.Write(&envelope{\n\t\tData:  raw,\n\t\tFlags: grpcFlagEnvelopeTrailer,\n\t})\n}\n\ntype grpcUnmarshaler struct {\n\tenvelopeReader\n\n\tweb        bool\n\twebTrailer http.Header\n}\n\nfunc (u *grpcUnmarshaler) Unmarshal(message any) *Error {\n\terr := u.envelopeReader.Unmarshal(message)\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif !errors.Is(err, errSpecialEnvelope) {\n\t\treturn err\n\t}\n\tenv := u.last\n\tdata := env.Data\n\tu.last.Data = nil // don't keep a reference to it\n\tdefer u.bufferPool.Put(data)\n\tif !u.web || !env.IsSet(grpcFlagEnvelopeTrailer) {\n\t\treturn errorf(CodeInternal, \"protocol error: invalid envelope flags %d\", env.Flags)\n\t}\n\n\t// Per the gRPC-Web specification, trailers should be encoded as an HTTP/1\n\t// headers block _without_ the terminating newline. To make the headers\n\t// parseable by net/textproto, we need to add the newline.\n\tif err := data.WriteByte('\\n'); err != nil {\n\t\treturn errorf(CodeInternal, \"unmarshal web trailers: %w\", err)\n\t}\n\tbufferedReader := bufio.NewReader(data)\n\tmimeReader := textproto.NewReader(bufferedReader)\n\tmimeHeader, mimeErr := mimeReader.ReadMIMEHeader()\n\tif mimeErr != nil {\n\t\treturn errorf(\n\t\t\tCodeInternal,\n\t\t\t\"gRPC-Web protocol error: trailers invalid: %w\",\n\t\t\tmimeErr,\n\t\t)\n\t}\n\tu.webTrailer = http.Header(mimeHeader)\n\treturn errSpecialEnvelope\n}\n\nfunc (u *grpcUnmarshaler) WebTrailer() http.Header {\n\treturn u.webTrailer\n}\n\nfunc grpcValidateResponse(\n\tresponse *http.Response,\n\theader http.Header,\n\tavailableCompressors readOnlyCompressionPools,\n\tweb bool,\n\tcodecName string,\n) *Error {\n\tif response.StatusCode != http.StatusOK {\n\t\treturn errorf(httpToCode(response.StatusCode), \"HTTP status %v\", response.Status)\n\t}\n\tif err := grpcValidateResponseContentType(\n\t\tweb,\n\t\tcodecName,\n\t\tgetHeaderCanonical(response.Header, headerContentType),\n\t); err != nil {\n\t\treturn err\n\t}\n\tif compression := getHeaderCanonical(response.Header, grpcHeaderCompression); compression != \"\" &&\n\t\tcompression != compressionIdentity &&\n\t\t!availableCompressors.Contains(compression) {\n\t\t// Per https://github.com/grpc/grpc/blob/master/doc/compression.md, we\n\t\t// should return CodeInternal and specify acceptable compression(s) (in\n\t\t// addition to setting the Grpc-Accept-Encoding header).\n\t\treturn errorf(\n\t\t\tCodeInternal,\n\t\t\t\"unknown encoding %q: accepted encodings are %v\",\n\t\t\tcompression,\n\t\t\tavailableCompressors.CommaSeparatedNames(),\n\t\t)\n\t}\n\t// The response is valid, so we should expose the headers.\n\tmergeHeaders(header, response.Header)\n\treturn nil\n}\n\n// The gRPC wire protocol specifies that errors should be serialized using the\n// binary Protobuf format, even if the messages in the request/response stream\n// use a different codec. Consequently, this function needs a Protobuf codec to\n// unmarshal error information in the headers.\n//\n// A nil error is only returned when a grpc-status key IS present, but it\n// indicates a code of zero (no error). If no grpc-status key is present, this\n// returns a non-nil *Error that wraps errTrailersWithoutGRPCStatus.\nfunc grpcErrorFromTrailer(protobuf Codec, trailer http.Header) *Error {\n\tcodeHeader := getHeaderCanonical(trailer, grpcHeaderStatus)\n\tif codeHeader == \"\" {\n\t\t// If there are no trailers at all, that's an internal error.\n\t\t// But if it's an error determining the status code from the\n\t\t// trailers, it's unknown.\n\t\tcode := CodeUnknown\n\t\tif len(trailer) == 0 {\n\t\t\tcode = CodeInternal\n\t\t}\n\t\treturn NewError(code, errTrailersWithoutGRPCStatus)\n\t}\n\tif codeHeader == \"0\" {\n\t\treturn nil\n\t}\n\n\tcode, err := strconv.ParseUint(codeHeader, 10 /* base */, 32 /* bitsize */)\n\tif err != nil {\n\t\treturn errorf(CodeUnknown, \"protocol error: invalid error code %q\", codeHeader)\n\t}\n\tmessage, err := grpcPercentDecode(getHeaderCanonical(trailer, grpcHeaderMessage))\n\tif err != nil {\n\t\treturn errorf(CodeInternal, \"protocol error: invalid error message %q\", message)\n\t}\n\tretErr := NewWireError(Code(code), errors.New(message))\n\n\tdetailsBinaryEncoded := getHeaderCanonical(trailer, grpcHeaderDetails)\n\tif len(detailsBinaryEncoded) > 0 {\n\t\tdetailsBinary, err := DecodeBinaryHeader(detailsBinaryEncoded)\n\t\tif err != nil {\n\t\t\treturn errorf(CodeInternal, \"server returned invalid grpc-status-details-bin trailer: %w\", err)\n\t\t}\n\t\tvar status statusv1.Status\n\t\tif err := protobuf.Unmarshal(detailsBinary, &status); err != nil {\n\t\t\treturn errorf(CodeInternal, \"server returned invalid protobuf for error details: %w\", err)\n\t\t}\n\t\tfor _, d := range status.GetDetails() {\n\t\t\tretErr.details = append(retErr.details, &ErrorDetail{pbAny: d})\n\t\t}\n\t\t// Prefer the Protobuf-encoded data to the headers (grpc-go does this too).\n\t\tretErr.code = Code(status.GetCode())\n\t\tretErr.err = errors.New(status.GetMessage())\n\t}\n\n\treturn retErr\n}\n\nfunc grpcParseTimeout(timeout string) (time.Duration, error) {\n\tif timeout == \"\" {\n\t\treturn 0, errNoTimeout\n\t}\n\tunit, err := grpcTimeoutUnitLookup(timeout[len(timeout)-1])\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tnum, err := strconv.ParseInt(timeout[:len(timeout)-1], 10 /* base */, 64 /* bitsize */)\n\tif err != nil || num < 0 {\n\t\treturn 0, fmt.Errorf(\"protocol error: invalid timeout %q\", timeout)\n\t}\n\tif num > 99999999 { // timeout must be ASCII string of at most 8 digits\n\t\treturn 0, fmt.Errorf(\"protocol error: timeout %q is too long\", timeout)\n\t}\n\tconst grpcTimeoutMaxHours = math.MaxInt64 / int64(time.Hour) // how many hours fit into a time.Duration?\n\tif unit == time.Hour && num > grpcTimeoutMaxHours {\n\t\t// Timeout is effectively unbounded, so ignore it. The grpc-go\n\t\t// implementation does the same thing.\n\t\treturn 0, errNoTimeout\n\t}\n\treturn time.Duration(num) * unit, nil\n}\n\nfunc grpcEncodeTimeout(timeout time.Duration) string {\n\tif timeout <= 0 {\n\t\treturn \"0n\"\n\t}\n\t// The gRPC protocol limits timeouts to 8 characters (not counting the unit),\n\t// so timeouts must be strictly less than 1e8 of the appropriate unit.\n\tconst grpcTimeoutMaxValue = 1e8\n\tvar (\n\t\tsize time.Duration\n\t\tunit byte\n\t)\n\tswitch {\n\tcase timeout < time.Nanosecond*grpcTimeoutMaxValue:\n\t\tsize, unit = time.Nanosecond, 'n'\n\tcase timeout < time.Microsecond*grpcTimeoutMaxValue:\n\t\tsize, unit = time.Microsecond, 'u'\n\tcase timeout < time.Millisecond*grpcTimeoutMaxValue:\n\t\tsize, unit = time.Millisecond, 'm'\n\tcase timeout < time.Second*grpcTimeoutMaxValue:\n\t\tsize, unit = time.Second, 'S'\n\tcase timeout < time.Minute*grpcTimeoutMaxValue:\n\t\tsize, unit = time.Minute, 'M'\n\tdefault:\n\t\t// time.Duration is an int64 number of nanoseconds, so the largest\n\t\t// expressible duration is less than 1e8 hours.\n\t\tsize, unit = time.Hour, 'H'\n\t}\n\tbuf := make([]byte, 0, 9)\n\tbuf = strconv.AppendInt(buf, int64(timeout/size), 10 /* base */)\n\tbuf = append(buf, unit)\n\treturn string(buf)\n}\n\nfunc grpcTimeoutUnitLookup(unit byte) (time.Duration, error) {\n\tswitch unit {\n\tcase 'n':\n\t\treturn time.Nanosecond, nil\n\tcase 'u':\n\t\treturn time.Microsecond, nil\n\tcase 'm':\n\t\treturn time.Millisecond, nil\n\tcase 'S':\n\t\treturn time.Second, nil\n\tcase 'M':\n\t\treturn time.Minute, nil\n\tcase 'H':\n\t\treturn time.Hour, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"protocol error: timeout has invalid unit %q\", unit)\n\t}\n}\n\nfunc grpcCodecFromContentType(web bool, contentType string) string {\n\tif (!web && contentType == grpcContentTypeDefault) || (web && contentType == grpcWebContentTypeDefault) {\n\t\t// implicitly protobuf\n\t\treturn codecNameProto\n\t}\n\tprefix := grpcContentTypePrefix\n\tif web {\n\t\tprefix = grpcWebContentTypePrefix\n\t}\n\treturn strings.TrimPrefix(contentType, prefix)\n}\n\nfunc grpcContentTypeFromCodecName(web bool, name string) string {\n\tif web {\n\t\treturn grpcWebContentTypePrefix + name\n\t}\n\tif name == codecNameProto {\n\t\t// For compatibility with Google Cloud Platform's frontends, prefer an\n\t\t// implicit default codec. See\n\t\t// https://github.com/connectrpc/connect-go/pull/655#issuecomment-1915754523\n\t\t// for details.\n\t\treturn grpcContentTypeDefault\n\t}\n\treturn grpcContentTypePrefix + name\n}\n\nfunc grpcErrorToTrailer(trailer http.Header, protobuf Codec, err error) {\n\tif err == nil {\n\t\tsetHeaderCanonical(trailer, grpcHeaderStatus, \"0\") // zero is the gRPC OK status\n\t\treturn\n\t}\n\tif connectErr, ok := asError(err); ok && !connectErr.wireErr {\n\t\tmergeNonProtocolHeaders(trailer, connectErr.meta)\n\t}\n\tvar (\n\t\tstatus  = grpcStatusFromError(err)\n\t\tcode    = status.GetCode()\n\t\tmessage = status.GetMessage()\n\t\tbin     []byte\n\t)\n\tif len(status.Details) > 0 {\n\t\tvar binErr error\n\t\tbin, binErr = protobuf.Marshal(status)\n\t\tif binErr != nil {\n\t\t\tcode = int32(CodeInternal)\n\t\t\tmessage = fmt.Sprintf(\"marshal protobuf status: %v\", binErr)\n\t\t}\n\t}\n\tsetHeaderCanonical(trailer, grpcHeaderStatus, strconv.Itoa(int(code)))\n\tsetHeaderCanonical(trailer, grpcHeaderMessage, grpcPercentEncode(message))\n\tif len(bin) > 0 {\n\t\tsetHeaderCanonical(trailer, grpcHeaderDetails, EncodeBinaryHeader(bin))\n\t}\n}\n\nfunc grpcStatusFromError(err error) *statusv1.Status {\n\tstatus := &statusv1.Status{\n\t\tCode:    int32(CodeUnknown),\n\t\tMessage: err.Error(),\n\t}\n\tif connectErr, ok := asError(err); ok {\n\t\tstatus.Code = int32(connectErr.Code())\n\t\tstatus.Message = connectErr.Message()\n\t\tstatus.Details = connectErr.detailsAsAny()\n\t}\n\treturn status\n}\n\n// grpcPercentEncode follows RFC 3986 Section 2.1 and the gRPC HTTP/2 spec.\n// It's a variant of URL-encoding with fewer reserved characters. It's intended\n// to take UTF-8 encoded text and escape non-ASCII bytes so that they're valid\n// HTTP/1 headers, while still maximizing readability of the data on the wire.\n//\n// The grpc-message trailer (used for human-readable error messages) should be\n// percent-encoded.\n//\n// References:\n//\n//\thttps://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#responses\n//\thttps://datatracker.ietf.org/doc/html/rfc3986#section-2.1\nfunc grpcPercentEncode(msg string) string {\n\tvar hexCount int\n\tfor i := 0; i < len(msg); i++ {\n\t\tif grpcShouldEscape(msg[i]) {\n\t\t\thexCount++\n\t\t}\n\t}\n\tif hexCount == 0 {\n\t\treturn msg\n\t}\n\t// We need to escape some characters, so we'll need to allocate a new string.\n\tvar out strings.Builder\n\tout.Grow(len(msg) + 2*hexCount)\n\tfor i := 0; i < len(msg); i++ {\n\t\tswitch char := msg[i]; {\n\t\tcase grpcShouldEscape(char):\n\t\t\tout.WriteByte('%')\n\t\t\tout.WriteByte(upperhex[char>>4])\n\t\t\tout.WriteByte(upperhex[char&15])\n\t\tdefault:\n\t\t\tout.WriteByte(char)\n\t\t}\n\t}\n\treturn out.String()\n}\n\nfunc grpcPercentDecode(input string) (string, error) {\n\tpercentCount := 0\n\tfor i := 0; i < len(input); {\n\t\tswitch input[i] {\n\t\tcase '%':\n\t\t\tpercentCount++\n\t\t\tif err := validateHex(input[i:]); err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\ti += 3\n\t\tdefault:\n\t\t\ti++\n\t\t}\n\t}\n\tif percentCount == 0 {\n\t\treturn input, nil\n\t}\n\t// We need to unescape some characters, so we'll need to allocate a new string.\n\tvar out strings.Builder\n\tout.Grow(len(input) - 2*percentCount)\n\tfor i := 0; i < len(input); i++ {\n\t\tswitch input[i] {\n\t\tcase '%':\n\t\t\tout.WriteByte(unhex(input[i+1])<<4 | unhex(input[i+2]))\n\t\t\ti += 2\n\t\tdefault:\n\t\t\tout.WriteByte(input[i])\n\t\t}\n\t}\n\treturn out.String(), nil\n}\n\n// Characters that need to be escaped are defined in gRPC's HTTP/2 spec.\n// They're different from the generic set defined in RFC 3986.\nfunc grpcShouldEscape(char byte) bool {\n\treturn char < ' ' || char > '~' || char == '%'\n}\n\nfunc unhex(char byte) byte {\n\tswitch {\n\tcase '0' <= char && char <= '9':\n\t\treturn char - '0'\n\tcase 'a' <= char && char <= 'f':\n\t\treturn char - 'a' + 10\n\tcase 'A' <= char && char <= 'F':\n\t\treturn char - 'A' + 10\n\t}\n\treturn 0\n}\n\nfunc isHex(char byte) bool {\n\treturn ('0' <= char && char <= '9') || ('a' <= char && char <= 'f') || ('A' <= char && char <= 'F')\n}\n\nfunc validateHex(input string) error {\n\tif len(input) < 3 || input[0] != '%' || !isHex(input[1]) || !isHex(input[2]) {\n\t\tif len(input) > 3 {\n\t\t\tinput = input[:3]\n\t\t}\n\t\treturn fmt.Errorf(\"invalid percent-encoded string %q\", input)\n\t}\n\treturn nil\n}\n\nfunc grpcValidateResponseContentType(web bool, requestCodecName string, responseContentType string) *Error {\n\t// Responses must have valid content-type that indicates same codec as the request.\n\tbare, prefix := grpcContentTypeDefault, grpcContentTypePrefix\n\tif web {\n\t\tbare, prefix = grpcWebContentTypeDefault, grpcWebContentTypePrefix\n\t}\n\tif responseContentType == prefix+requestCodecName ||\n\t\t(requestCodecName == codecNameProto && responseContentType == bare) {\n\t\treturn nil\n\t}\n\texpectedContentType := bare\n\tif requestCodecName != codecNameProto {\n\t\texpectedContentType = prefix + requestCodecName\n\t}\n\tcode := CodeInternal\n\tif responseContentType != bare && !strings.HasPrefix(responseContentType, prefix) {\n\t\t// Doesn't even look like a gRPC response? Use code \"unknown\".\n\t\tcode = CodeUnknown\n\t}\n\treturn errorf(\n\t\tcode,\n\t\t\"invalid content-type: %q; expecting %q\",\n\t\tresponseContentType,\n\t\texpectedContentType,\n\t)\n}\n"
        },
        {
          "name": "protocol_grpc_test.go",
          "type": "blob",
          "size": 10.7138671875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\t\"testing/quick\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestGRPCHandlerSender(t *testing.T) {\n\tt.Parallel()\n\tnewConn := func(web bool) *grpcHandlerConn {\n\t\tresponseWriter := httptest.NewRecorder()\n\t\tprotobufCodec := &protoBinaryCodec{}\n\t\tbufferPool := newBufferPool()\n\t\trequest, err := http.NewRequest(\n\t\t\thttp.MethodPost,\n\t\t\t\"https://demo.example.com\",\n\t\t\tstrings.NewReader(\"\"),\n\t\t)\n\t\tassert.Nil(t, err)\n\t\treturn &grpcHandlerConn{\n\t\t\tspec:       Spec{},\n\t\t\tweb:        web,\n\t\t\tbufferPool: bufferPool,\n\t\t\tprotobuf:   protobufCodec,\n\t\t\tmarshaler: grpcMarshaler{\n\t\t\t\tenvelopeWriter: envelopeWriter{\n\t\t\t\t\tsender:     writeSender{writer: responseWriter},\n\t\t\t\t\tcodec:      protobufCodec,\n\t\t\t\t\tbufferPool: bufferPool,\n\t\t\t\t},\n\t\t\t},\n\t\t\tresponseWriter:  responseWriter,\n\t\t\tresponseHeader:  make(http.Header),\n\t\t\tresponseTrailer: make(http.Header),\n\t\t\trequest:         request,\n\t\t\tunmarshaler: grpcUnmarshaler{\n\t\t\t\tenvelopeReader: envelopeReader{\n\t\t\t\t\treader:     request.Body,\n\t\t\t\t\tcodec:      protobufCodec,\n\t\t\t\t\tbufferPool: bufferPool,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\tt.Run(\"web\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttestGRPCHandlerConnMetadata(t, newConn(true))\n\t})\n\tt.Run(\"http2\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttestGRPCHandlerConnMetadata(t, newConn(false))\n\t})\n}\n\nfunc testGRPCHandlerConnMetadata(t *testing.T, conn handlerConnCloser) {\n\t// Closing the sender shouldn't unpredictably mutate user-visible headers or\n\t// trailers.\n\tt.Helper()\n\texpectHeaders := conn.ResponseHeader().Clone()\n\texpectTrailers := conn.ResponseTrailer().Clone()\n\tconn.Close(NewError(CodeUnavailable, errors.New(\"oh no\")))\n\tif diff := cmp.Diff(expectHeaders, conn.ResponseHeader()); diff != \"\" {\n\t\tt.Errorf(\"headers changed:\\n%s\", diff)\n\t}\n\tgotTrailers := conn.ResponseTrailer()\n\tif diff := cmp.Diff(expectTrailers, gotTrailers); diff != \"\" {\n\t\tt.Errorf(\"trailers changed:\\n%s\", diff)\n\t}\n}\n\nfunc TestGRPCParseTimeout(t *testing.T) {\n\tt.Parallel()\n\t_, err := grpcParseTimeout(\"\")\n\tassert.True(t, errors.Is(err, errNoTimeout))\n\n\t_, err = grpcParseTimeout(\"foo\")\n\tassert.NotNil(t, err)\n\t_, err = grpcParseTimeout(\"12xS\")\n\tassert.NotNil(t, err)\n\t_, err = grpcParseTimeout(\"999999999n\") // 9 digits\n\tassert.NotNil(t, err)\n\tassert.False(t, errors.Is(err, errNoTimeout))\n\t_, err = grpcParseTimeout(\"99999999H\") // 8 digits but overflows time.Duration\n\tassert.True(t, errors.Is(err, errNoTimeout))\n\n\tduration, err := grpcParseTimeout(\"45S\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, duration, 45*time.Second)\n\n\tconst long = \"99999999S\"\n\tduration, err = grpcParseTimeout(long) // 8 digits, shouldn't overflow\n\tassert.Nil(t, err)\n\tassert.Equal(t, duration, 99999999*time.Second)\n}\n\nfunc TestGRPCEncodeTimeout(t *testing.T) {\n\tt.Parallel()\n\ttimeout := grpcEncodeTimeout(time.Hour + time.Second)\n\tassert.Equal(t, timeout, \"3601000m\") // NB, m is milliseconds\n\n\t// overflow and underflow\n\ttimeout = grpcEncodeTimeout(time.Duration(math.MaxInt64))\n\tassert.Equal(t, timeout, \"2562047H\")\n\ttimeout = grpcEncodeTimeout(-1)\n\tassert.Equal(t, timeout, \"0n\")\n\ttimeout = grpcEncodeTimeout(-1 * time.Hour)\n\tassert.Equal(t, timeout, \"0n\")\n\n\t// unit conversions\n\tconst eightDigitsNanos = 99999999 * time.Nanosecond\n\ttimeout = grpcEncodeTimeout(eightDigitsNanos) // shouldn't need unit conversion\n\tassert.Equal(t, timeout, \"99999999n\")\n\ttimeout = grpcEncodeTimeout(eightDigitsNanos + 1) // 9 digits, convert to micros\n\tassert.Equal(t, timeout, \"100000u\")\n\n\t// rounding\n\ttimeout = grpcEncodeTimeout(10*time.Millisecond + 1) // shouldn't round\n\tassert.Equal(t, timeout, \"10000001n\")\n\ttimeout = grpcEncodeTimeout(10*time.Second + 1) // should round down\n\tassert.Equal(t, timeout, \"10000000u\")\n}\n\nfunc TestGRPCPercentEncodingQuick(t *testing.T) {\n\tt.Parallel()\n\troundtrip := func(input string) bool {\n\t\tif !utf8.ValidString(input) {\n\t\t\treturn true\n\t\t}\n\t\tencoded := grpcPercentEncode(input)\n\t\tdecoded, err := grpcPercentDecode(encoded)\n\t\treturn err == nil && decoded == input\n\t}\n\tif err := quick.Check(roundtrip, nil /* config */); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestGRPCPercentEncoding(t *testing.T) {\n\tt.Parallel()\n\troundtrip := func(input string) {\n\t\tassert.True(t, utf8.ValidString(input), assert.Sprintf(\"input invalid UTF-8\"))\n\t\tencoded := grpcPercentEncode(input)\n\t\tt.Logf(\"%q encoded as %q\", input, encoded)\n\t\tdecoded, err := grpcPercentDecode(encoded)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, decoded, input)\n\t}\n\n\troundtrip(\"foo\")\n\troundtrip(\"foo bar\")\n\troundtrip(`foo%bar`)\n\troundtrip(\"fiancée\")\n}\n\nfunc TestGRPCWebTrailerMarshalling(t *testing.T) {\n\tt.Parallel()\n\tresponseWriter := httptest.NewRecorder()\n\tmarshaler := grpcMarshaler{\n\t\tenvelopeWriter: envelopeWriter{\n\t\t\tsender:     writeSender{writer: responseWriter},\n\t\t\tbufferPool: newBufferPool(),\n\t\t},\n\t}\n\ttrailer := http.Header{}\n\ttrailer.Add(\"grpc-status\", \"0\")\n\ttrailer.Add(\"Grpc-Message\", \"Foo\")\n\ttrailer.Add(\"User-Provided\", \"bar\")\n\terr := marshaler.MarshalWebTrailers(trailer)\n\tassert.Nil(t, err)\n\tresponseWriter.Body.Next(5) // skip flags and message length\n\tmarshalled := responseWriter.Body.String()\n\tassert.Equal(t, marshalled, \"grpc-message: Foo\\r\\ngrpc-status: 0\\r\\nuser-provided: bar\\r\\n\")\n}\nfunc BenchmarkGRPCPercentEncoding(b *testing.B) {\n\tinput := \"Hello, 世界\"\n\twant := \"Hello, %E4%B8%96%E7%95%8C\"\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tgot := grpcPercentEncode(input)\n\t\tif got != want {\n\t\t\tb.Fatalf(\"grpcPercentEncode(%q) = %s, want %s\", input, got, want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkGRPCPercentDecoding(b *testing.B) {\n\tinput := \"Hello, %E4%B8%96%E7%95%8C\"\n\twant := \"Hello, 世界\"\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tgot, _ := grpcPercentDecode(input)\n\t\tif got != want {\n\t\t\tb.Fatalf(\"grpcPercentDecode(%q) = %s, want %s\", input, got, want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkGRPCTimeoutEncoding(b *testing.B) {\n\tinput := time.Second * 45\n\twant := \"45000000u\"\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tgot := grpcEncodeTimeout(input)\n\t\tif got != want {\n\t\t\tb.Fatalf(\"grpcEncodeTimeout(%q) = %s, want %s\", input, got, want)\n\t\t}\n\t}\n}\n\nfunc TestGRPCValidateResponseContentType(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tweb                 bool\n\t\tcodecName           string\n\t\tresponseContentType string\n\t\texpectCode          Code\n\t}{\n\t\t// Allowed content-types\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"application/grpc\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"application/grpc+proto\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/grpc+json\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/grpc-web\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/grpc-web+proto\",\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/grpc-web+json\",\n\t\t},\n\t\t// Mismatched response codec\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"application/grpc+json\",\n\t\t\texpectCode:          CodeInternal,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/grpc\",\n\t\t\texpectCode:          CodeInternal,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/grpc+proto\",\n\t\t\texpectCode:          CodeInternal,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/grpc-web+json\",\n\t\t\texpectCode:          CodeInternal,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/grpc-web\",\n\t\t\texpectCode:          CodeInternal,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/grpc-web+proto\",\n\t\t\texpectCode:          CodeInternal,\n\t\t},\n\t\t// Disallowed content-types\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"application/proto\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"application/grpc-web\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"application/grpc-web+proto\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/json\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tresponseContentType: \"application/grpc-web+json\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/proto\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/grpc\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/grpc+proto\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/json\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameJSON,\n\t\t\tweb:                 true,\n\t\t\tresponseContentType: \"application/grpc+json\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t\t{\n\t\t\tcodecName:           codecNameProto,\n\t\t\tresponseContentType: \"some/garbage\",\n\t\t\texpectCode:          CodeUnknown,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tprotocol := ProtocolGRPC\n\t\tif testCase.web {\n\t\t\tprotocol = ProtocolGRPCWeb\n\t\t}\n\t\ttestCaseName := fmt.Sprintf(\"%s_%s->%s\", protocol, testCase.codecName, testCase.responseContentType)\n\t\tt.Run(testCaseName, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\terr := grpcValidateResponseContentType(\n\t\t\t\ttestCase.web,\n\t\t\t\ttestCase.codecName,\n\t\t\t\ttestCase.responseContentType,\n\t\t\t)\n\t\t\tif testCase.expectCode == 0 {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t} else if assert.NotNil(t, err) {\n\t\t\t\tassert.Equal(t, CodeOf(err), testCase.expectCode)\n\t\t\t\tassert.True(t, strings.Contains(err.Message(), fmt.Sprintf(\"invalid content-type: %q; expecting\", testCase.responseContentType)))\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "protocol_test.go",
          "type": "blob",
          "size": 1.9521484375,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"testing\"\n\n\t\"connectrpc.com/connect/internal/assert\"\n)\n\nfunc TestCanonicalizeContentType(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname string\n\t\targ  string\n\t\twant string\n\t}{\n\t\t{name: \"uppercase should be normalized\", arg: \"APPLICATION/json\", want: \"application/json\"},\n\t\t{name: \"charset param should be treated as lowercase\", arg: \"application/json; charset=UTF-8\", want: \"application/json; charset=utf-8\"},\n\t\t{name: \"non charset param should not be changed\", arg: \"multipart/form-data; boundary=fooBar\", want: \"multipart/form-data; boundary=fooBar\"},\n\t\t{name: \"no parameters should be normalized\", arg: \"APPLICATION/json;  \", want: \"application/json\"},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tassert.Equal(t, canonicalizeContentType(tt.arg), tt.want)\n\t\t})\n\t}\n}\n\nfunc BenchmarkCanonicalizeContentType(b *testing.B) {\n\tb.Run(\"simple\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_ = canonicalizeContentType(\"application/json\")\n\t\t}\n\t\tb.ReportAllocs()\n\t})\n\n\tb.Run(\"with charset\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_ = canonicalizeContentType(\"application/json; charset=utf-8\")\n\t\t}\n\t\tb.ReportAllocs()\n\t})\n\n\tb.Run(\"with other param\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_ = canonicalizeContentType(\"application/json; foo=utf-8\")\n\t\t}\n\t\tb.ReportAllocs()\n\t})\n}\n"
        },
        {
          "name": "recover.go",
          "type": "blob",
          "size": 2.419921875,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect\n\nimport (\n\t\"context\"\n\t\"net/http\"\n)\n\n// recoverHandlerInterceptor lets handlers trap panics, perform side effects\n// (like emitting logs or metrics), and present a friendlier error message to\n// clients.\n//\n// This interceptor uses a somewhat unusual strategy to recover from panics.\n// The standard recovery idiom:\n//\n//\tif r := recover(); r != nil { ... }\n//\n// isn't robust in the face of user error, because it doesn't handle\n// panic(nil). This occasionally happens by mistake, and it's a beast to debug\n// without a more robust idiom. See https://github.com/golang/go/issues/25448\n// for details.\ntype recoverHandlerInterceptor struct {\n\tInterceptor\n\n\thandle func(context.Context, Spec, http.Header, any) error\n}\n\nfunc (i *recoverHandlerInterceptor) WrapUnary(next UnaryFunc) UnaryFunc {\n\treturn func(ctx context.Context, req AnyRequest) (_ AnyResponse, retErr error) {\n\t\tif req.Spec().IsClient {\n\t\t\treturn next(ctx, req)\n\t\t}\n\t\tpanicked := true\n\t\tdefer func() {\n\t\t\tif panicked {\n\t\t\t\tr := recover()\n\t\t\t\t// net/http checks for ErrAbortHandler with ==, so we should too.\n\t\t\t\tif r == http.ErrAbortHandler { //nolint:errorlint,goerr113\n\t\t\t\t\tpanic(r) //nolint:forbidigo\n\t\t\t\t}\n\t\t\t\tretErr = i.handle(ctx, req.Spec(), req.Header(), r)\n\t\t\t}\n\t\t}()\n\t\tres, err := next(ctx, req)\n\t\tpanicked = false\n\t\treturn res, err\n\t}\n}\n\nfunc (i *recoverHandlerInterceptor) WrapStreamingHandler(next StreamingHandlerFunc) StreamingHandlerFunc {\n\treturn func(ctx context.Context, conn StreamingHandlerConn) (retErr error) {\n\t\tpanicked := true\n\t\tdefer func() {\n\t\t\tif panicked {\n\t\t\t\tr := recover()\n\t\t\t\t// net/http checks for ErrAbortHandler with ==, so we should too.\n\t\t\t\tif r == http.ErrAbortHandler { //nolint:errorlint,goerr113\n\t\t\t\t\tpanic(r) //nolint:forbidigo\n\t\t\t\t}\n\t\t\t\tretErr = i.handle(ctx, Spec{}, nil, r)\n\t\t\t}\n\t\t}()\n\t\terr := next(ctx, conn)\n\t\tpanicked = false\n\t\treturn err\n\t}\n}\n"
        },
        {
          "name": "recover_ext_test.go",
          "type": "blob",
          "size": 3.2861328125,
          "content": "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage connect_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\tconnect \"connectrpc.com/connect\"\n\t\"connectrpc.com/connect/internal/assert\"\n\tpingv1 \"connectrpc.com/connect/internal/gen/connect/ping/v1\"\n\t\"connectrpc.com/connect/internal/gen/connect/ping/v1/pingv1connect\"\n\t\"connectrpc.com/connect/internal/memhttp/memhttptest\"\n)\n\ntype panicPingServer struct {\n\tpingv1connect.UnimplementedPingServiceHandler\n\n\tpanicWith any\n}\n\nfunc (s *panicPingServer) Ping(\n\tcontext.Context,\n\t*connect.Request[pingv1.PingRequest],\n) (*connect.Response[pingv1.PingResponse], error) {\n\tpanic(s.panicWith) //nolint:forbidigo\n}\n\nfunc (s *panicPingServer) CountUp(\n\t_ context.Context,\n\t_ *connect.Request[pingv1.CountUpRequest],\n\tstream *connect.ServerStream[pingv1.CountUpResponse],\n) error {\n\tif err := stream.Send(&pingv1.CountUpResponse{}); err != nil {\n\t\treturn err\n\t}\n\tpanic(s.panicWith) //nolint:forbidigo\n}\n\nfunc TestWithRecover(t *testing.T) {\n\tt.Parallel()\n\thandle := func(_ context.Context, _ connect.Spec, _ http.Header, r any) error {\n\t\treturn connect.NewError(connect.CodeFailedPrecondition, fmt.Errorf(\"panic: %v\", r))\n\t}\n\tassertHandled := func(err error) {\n\t\tt.Helper()\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeFailedPrecondition)\n\t}\n\tassertNotHandled := func(err error) {\n\t\tt.Helper()\n\t\t// When HTTP/2 handlers panic, net/http sends an RST_STREAM frame with code\n\t\t// INTERNAL_ERROR. We should be mapping this back to CodeInternal.\n\t\tassert.Equal(t, connect.CodeOf(err), connect.CodeInternal)\n\t}\n\tdrainStream := func(stream *connect.ServerStreamForClient[pingv1.CountUpResponse]) error {\n\t\tt.Helper()\n\t\tdefer stream.Close()\n\t\tassert.True(t, stream.Receive())  // expect one response msg\n\t\tassert.False(t, stream.Receive()) // expect panic before second response msg\n\t\treturn stream.Err()\n\t}\n\tpinger := &panicPingServer{}\n\tmux := http.NewServeMux()\n\tmux.Handle(pingv1connect.NewPingServiceHandler(pinger, connect.WithRecover(handle)))\n\tserver := memhttptest.NewServer(t, mux)\n\tclient := pingv1connect.NewPingServiceClient(\n\t\tserver.Client(),\n\t\tserver.URL(),\n\t)\n\n\tfor _, panicWith := range []any{42, nil} {\n\t\tpinger.panicWith = panicWith\n\n\t\t_, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{}))\n\t\tassertHandled(err)\n\n\t\tstream, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{}))\n\t\tassert.Nil(t, err)\n\t\tassertHandled(drainStream(stream))\n\t}\n\n\tpinger.panicWith = http.ErrAbortHandler\n\n\t_, err := client.Ping(context.Background(), connect.NewRequest(&pingv1.PingRequest{}))\n\tassertNotHandled(err)\n\n\tstream, err := client.CountUp(context.Background(), connect.NewRequest(&pingv1.CountUpRequest{}))\n\tassert.Nil(t, err)\n\tassertNotHandled(drainStream(stream))\n}\n"
        }
      ]
    }
  ]
}