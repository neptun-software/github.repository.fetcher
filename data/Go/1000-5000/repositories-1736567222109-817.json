{
  "metadata": {
    "timestamp": 1736567222109,
    "page": 817,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "AllenDang/giu",
      "stars": 2428,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.345703125,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# vim cache files\n*.swp\n\n# JetBrains idea configuration\n.idea\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\nvendor/\n\n/cmd/gmdeploy/gmdeploy\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 1.4228515625,
          "content": "---\nlinters:\n  disable-all: true\n  enable:\n    - asciicheck\n    - bodyclose\n    - copyloopvar\n    - dogsled\n    - dupl\n    - errcheck\n    - errorlint\n    - forcetypeassert\n    #- funlen\n    #- gci\n    - godot\n    #- gochecknoglobals\n    #- gochecknoinits\n    - gocognit\n    - goconst\n    - gocritic\n    - gocyclo\n    - err113\n    - gofmt\n    - gofumpt\n    - goheader\n    - goimports\n    #- gomnd\n    - goprintffuncname\n    #- gosec\n    - gosimple\n    - govet\n    - importas\n    - ineffassign\n    - makezero\n    - misspell\n    - nakedret\n    - nilerr\n    - nolintlint\n    - prealloc\n    - predeclared\n    - promlinter\n    - reassign\n    - revive\n    - rowserrcheck\n    - staticcheck\n    - stylecheck\n    - tagliatelle\n    - testifylint\n    - typecheck\n    - unconvert\n    - unparam\n    - unused\n    - usestdlibvars\n    - wastedassign\n    - whitespace\n    - wrapcheck\n    - wsl\n\nlinters-settings:\n  dupl:\n    threshold: 100\n  goconst:\n    min-len: 2\n    min-occurrences: 2\n  gocritic:\n    enabled-tags:\n      - diagnostic\n      - experimental\n      - opinionated\n      - performance\n      - style\n    disabled-checks:\n  gocyclo:\n    min-complexity: 15\n  goimports:\n    local-prefixes: github.com/AllenDang/giu\n  govet:\n    shadow: true\n  maligned:\n    suggest-new: true\n  misspell:\n    locale: US\n\nrun:\n  timeout: 5m\n\nissues:\n  exclude-dirs-use-default: false\n  skip-dirs:\n    - .github\n    - build\n    - web\n  max-same-issues: 0\n  exclude-use-default: false\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.169921875,
          "content": "sudo: false\n\naddons:\n  apt_packages:\n    - libgl1-mesa-dev\n    - xorg-dev\n\nlanguage: go\n\ngo:\n  - 1.13.x\n  - tip\n\nmatrix:\n  allow_failures:\n    - go: tip\n  fast_finish: true \n"
        },
        {
          "name": "Alignment.go",
          "type": "blob",
          "size": 5.375,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// These constants holds information about where GetWidgetWidth should proceed their\n// measurements.\n//\n// It should be far away from our working space, -1000 seems to be good choice for now.\nconst (\n\tgetWidgetWidthTestingSpaceX, getWidgetWidthTestingSpaceY = -1000, -1000\n)\n\n// AlignmentType represents a bype of alignment to use with AlignSetter.\ntype AlignmentType byte\n\nconst (\n\t// AlignLeft is here just for clarity.\n\t// if set, no action is taken so don't use it.\n\tAlignLeft AlignmentType = iota\n\t// AlignCenter centers widget.\n\tAlignCenter\n\t// AlignRight aligns a widget to right side of window.\n\tAlignRight\n)\n\n// AlignManually allows to apply alignment manually.\n// As long as AlignSetter is really EXPERIMENTAL feature\n// and may fail randomly, the following method is supposed to\n// always work, as long as you set it up correctly.\n// To use it just pass a single widget with its exact width.\n// be sure to apply widget's size by using \"Size\" method!\n// forceApplyWidth argument allows you to ask giu to force-set width\n// of `widget`\n// NOTE that forcing width doesn't work for each widget type! For example\n// Button won't work because its size is set by argument to imgui call\n// not PushWidth api.\nfunc AlignManually(alignmentType AlignmentType, widget Widget, widgetWidth float32, forceApplyWidth bool) Widget {\n\treturn Custom(func() {\n\t\tspacingX, _ := GetItemSpacing()\n\t\tavailableW, _ := GetAvailableRegion()\n\n\t\tvar dummyX float32\n\n\t\tswitch alignmentType {\n\t\tcase AlignLeft:\n\t\t\twidget.Build()\n\t\t\treturn\n\t\tcase AlignCenter:\n\t\t\tdummyX = (availableW-widgetWidth)/2 - spacingX\n\t\t\tif dummyX < 0 {\n\t\t\t\tdummyX = 0\n\t\t\t}\n\t\tcase AlignRight:\n\t\t\tdummyX = availableW - widgetWidth - spacingX\n\t\t\tif dummyX < 0 {\n\t\t\t\tdummyX = 0\n\t\t\t}\n\t\t}\n\n\t\tDummy(dummyX, 0).Build()\n\n\t\tif forceApplyWidth {\n\t\t\tPushItemWidth(widgetWidth)\n\n\t\t\tdefer PopItemWidth()\n\t\t}\n\n\t\timgui.SameLine()\n\t\twidget.Build()\n\t})\n}\n\nvar _ Widget = &AlignmentSetter{}\n\n// AlignmentSetter allows to align to right / center a widget or widgets group.\n// NOTE: Because of AlignSetter uses experimental GetWidgetWidth,\n// it is experimental too.\n// usage: see examples/align\n//\n// list of known bugs:\n// - BUG: there is some bug with SelectableWidget.\ntype AlignmentSetter struct {\n\talignType AlignmentType\n\tlayout    Layout\n\tid        ID\n}\n\n// Align sets widgets alignment.\nfunc Align(at AlignmentType) *AlignmentSetter {\n\treturn &AlignmentSetter{\n\t\talignType: at,\n\t\tid:        GenAutoID(\"alignSetter\"),\n\t}\n}\n\n// To sets a layout, alignment should be applied to.\nfunc (a *AlignmentSetter) To(widgets ...Widget) *AlignmentSetter {\n\ta.layout = Layout(widgets)\n\treturn a\n}\n\n// ID allows to manually set AlignmentSetter ID\n// NOTE: there isn't any known reason to use this method, however\n// it is here for some random cases. YOU DON'T NEED TO USE IT\n// in normal cases.\nfunc (a *AlignmentSetter) ID(id ID) *AlignmentSetter {\n\ta.id = id\n\treturn a\n}\n\n// Build implements Widget interface.\nfunc (a *AlignmentSetter) Build() {\n\tif a.layout == nil {\n\t\treturn\n\t}\n\n\ta.layout.Range(func(item Widget) {\n\t\t// if item is nil, just skip it\n\t\tif item == nil {\n\t\t\treturn\n\t\t}\n\n\t\tswitch item.(type) {\n\t\t// ok, it doesn't make sense to align again :-)\n\t\tcase *AlignmentSetter:\n\t\t\titem.Build()\n\t\t\treturn\n\t\t// there is a bug with selectables and combos, so skip them for now\n\t\tcase *SelectableWidget, *ComboWidget, *ComboCustomWidget:\n\t\t\titem.Build()\n\t\t\treturn\n\t\t}\n\n\t\tcurrentPos := GetCursorPos()\n\t\tw := GetWidgetWidth(item)\n\t\tavailableW, _ := GetAvailableRegion()\n\n\t\t// set cursor position to align the widget\n\t\tswitch a.alignType {\n\t\tcase AlignLeft:\n\t\t\tSetCursorPos(currentPos)\n\t\tcase AlignCenter:\n\t\t\tSetCursorPos(image.Pt(int(availableW/2-w/2)+currentPos.X, currentPos.Y))\n\t\tcase AlignRight:\n\t\t\tSetCursorPos(image.Pt(int(availableW-w)+currentPos.X, currentPos.Y))\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"giu: (*AlignSetter).Build: unknown align type %d\", a.alignType))\n\t\t}\n\n\t\t// build aligned widget\n\t\titem.Build()\n\t})\n}\n\n// GetWidgetWidth returns a width of widget\n// NOTE: THIS IS A BETA SOLUTION and may contain bugs\n// in most cases, you may want to use supported by imgui GetItemRectSize.\n// There is an upstream issue for this problem:\n// https://github.com/ocornut/imgui/issues/3714\n//\n// This function is just a workaround used in giu.\n//\n// NOTE: user-defined widgets, which contains more than one\n// giu widget will be processed incorrectly (only width of the last built\n// widget will be processed)\n//\n// here is a list of known bugs:\n//\n// if you find anything else, please report it on\n// https://github.com/AllenDang/giu Any contribution is appreciated!\nfunc GetWidgetWidth(w Widget) (result float32) {\n\timgui.PushIDStr(string(GenAutoID(\"GetWidgetWidthMeasurement\")))\n\tdefer imgui.PopID()\n\n\t// save cursor position before doing anything\n\tcurrentPos := GetCursorPos()\n\n\t// set cursor position to something really out of working space\n\tstartPos := image.Pt(getWidgetWidthTestingSpaceX, getWidgetWidthTestingSpaceY)\n\tSetCursorPos(startPos)\n\n\t// render widget in `dry` mode\n\timgui.PushStyleVarFloat(imgui.StyleVarAlpha, 0)\n\tw.Build()\n\timgui.PopStyleVar()\n\n\t// save widget's width\n\t// check cursor position\n\timgui.SameLine()\n\n\tspacingW, _ := GetItemSpacing()\n\tresult = float32(GetCursorPos().X-startPos.X) - spacingW\n\n\t// Undo SameLine (see https://github.com/AllenDang/giu/issues/807)\n\timgui.NewLine()\n\n\t// reset drawing cursor position\n\tSetCursorPos(currentPos)\n\n\treturn result\n}\n"
        },
        {
          "name": "CSS.go",
          "type": "blob",
          "size": 4.8046875,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/mazznoer/csscolorparser\"\n\t\"github.com/napsy/go-css\"\n)\n\n// Code in this file allows to apply style using a CSS stylesheet\n// The intention of the code looks as follows:\n// - The CSS stylesheet is parsed and the resulting rules are stored in giu context\n//   NOTE: more than one CSS stylesheets can be parsed, however the app could panic if the same tag is present twice\n// - CSSTagWidget allows to apply style to a specified layout\n// - main tag allows to apply style to the whole application\n//\n// tools:\n// css parser - for now github.com/napsy/go-css. it is a bit poor, but I don't think we need anything more\n// css colors - github.com/mazznoer/csscolorparser\n//\n// docs: docs/css.md\n\n// ErrCSSParse represents a CSS parsing error and includes details about what is failing.\ntype ErrCSSParse struct {\n\tWhat   string // description of what we are parsing\n\tValue  string // the value which failed\n\tDetail error  // (optional) error to add extra detail (i.e. result of calling another function like strconv.ParseFloat)\n}\n\nfunc (e ErrCSSParse) Error() string {\n\terrStr := fmt.Sprintf(\"unable to parse %s: %q\", e.What, e.Value)\n\n\tif e.Detail != nil {\n\t\terrStr += fmt.Sprintf(\" - %s\", e.Detail.Error())\n\t}\n\n\treturn errStr\n}\n\n// ParseCSSStyleSheet parses CSS stylesheet and stores the rules in giu context.\n//\n//nolint:gocognit // no\nfunc ParseCSSStyleSheet(data []byte) error {\n\t// css does not support windows formatting\n\t// https://github.com/AllenDang/giu/issues/842\n\tdata = []byte(strings.ReplaceAll(string(data), \"\\r\\n\", \"\\n\"))\n\n\tstylesheet, err := css.Unmarshal(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshaling CSS file: %w\", err)\n\t}\n\n\tfor rule, style := range stylesheet {\n\t\tsetter := Style()\n\n\t\tfor styleVarName, styleVarValue := range style {\n\t\t\t// convert style variable name to giu style variable name\n\t\t\tstyleVarID, err := StyleVarIDString(styleVarName)\n\n\t\t\tif err == nil {\n\t\t\t\tif err := parseStyleVar(styleVarValue, func(v float32) {\n\t\t\t\t\tsetter.SetStyleFloat(styleVarID, v)\n\t\t\t\t}, func(x, y float32) {\n\t\t\t\t\tsetter.SetStyle(styleVarID, x, y)\n\t\t\t\t}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstyleColorID, err := StyleColorIDString(styleVarName)\n\t\t\tif err == nil {\n\t\t\t\tcol, err := csscolorparser.Parse(styleVarValue)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn ErrCSSParse{What: \"color\", Value: styleVarValue, Detail: err}\n\t\t\t\t}\n\n\t\t\t\tsetter.SetColor(styleColorID, col)\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstylePlotVarID, err := StylePlotVarIDString(styleVarName)\n\t\t\tif err == nil {\n\t\t\t\tif err := parseStyleVar(styleVarValue, func(v float32) {\n\t\t\t\t\tsetter.SetPlotStyleFloat(stylePlotVarID, v)\n\t\t\t\t}, func(x, y float32) {\n\t\t\t\t\tsetter.SetPlotStyle(stylePlotVarID, x, y)\n\t\t\t\t}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstylePlotColorID, err := StylePlotColorIDString(styleVarName)\n\t\t\tif err == nil {\n\t\t\t\tcol, err := csscolorparser.Parse(styleVarValue)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn ErrCSSParse{What: \"color\", Value: styleVarValue, Detail: err}\n\t\t\t\t}\n\n\t\t\t\tsetter.SetPlotColor(stylePlotColorID, col)\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn ErrCSSParse{What: \"style variable name\", Value: styleVarName}\n\t\t}\n\n\t\tContext.cssStylesheet[string(rule)] = setter\n\t}\n\n\treturn nil\n}\n\nfunc parseStyleVar(styleVarValue string, setFloat func(v float32), setVec2 func(x, y float32)) error {\n\t// the style is StyleVarID - set it\n\tf, err2 := strconv.ParseFloat(styleVarValue, 32)\n\tif err2 == nil {\n\t\tsetFloat(float32(f))\n\t\treturn nil\n\t}\n\n\t// so maybe it is a vec2 value:\n\t// var-name: x, y;\n\tstyleVarValue = strings.ReplaceAll(styleVarValue, \" \", \"\")\n\tvec2 := strings.Split(styleVarValue, \",\")\n\n\tif len(vec2) != 2 {\n\t\treturn ErrCSSParse{What: \"value (not float or vec2)\", Value: styleVarValue}\n\t}\n\n\tx, err2 := strconv.ParseFloat(vec2[0], 32)\n\tif err2 != nil {\n\t\treturn ErrCSSParse{What: \"value (not float)\", Value: vec2[0], Detail: err2}\n\t}\n\n\ty, err2 := strconv.ParseFloat(vec2[1], 32)\n\tif err2 != nil {\n\t\treturn ErrCSSParse{What: \"value (not float)\", Value: vec2[1], Detail: err2}\n\t}\n\n\tsetVec2(float32(x), float32(y))\n\n\treturn nil\n}\n\n// cssStylesheet is a map tag:StyleSetter.\ntype cssStylesheet map[string]*StyleSetter\n\nvar _ Widget = &CSSTagWidget{}\n\n// CSSTagWidget is a widget that allows to apply CSS style to a specified layout.\ntype CSSTagWidget struct {\n\ttag    string\n\tlayout Layout\n}\n\n// CSSTag creates CSSTagWidget.\nfunc CSSTag(tag string) *CSSTagWidget {\n\treturn &CSSTagWidget{tag: tag}\n}\n\n// To specifies a layout to which the style will be applied.\nfunc (c *CSSTagWidget) To(layout ...Widget) *CSSTagWidget {\n\tc.layout = layout\n\treturn c\n}\n\n// Build implements Widget interface.\nfunc (c *CSSTagWidget) Build() {\n\t// get style from context.\n\t// if it doesn't exist Assert.\n\tstyle, exists := Context.cssStylesheet[c.tag]\n\tAssert(exists, \"CSSTagWidget\", \"Build\", \"CSS stylesheet doesn't contain tag: %s\", c.tag)\n\n\tstyle.To(c.layout).Build()\n}\n"
        },
        {
          "name": "Canvas.go",
          "type": "blob",
          "size": 7.7939453125,
          "content": "package giu\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// Canvas represents imgui.DrawList\n// from imgui.h:\n//\n//\tA single draw command list (generally one per window,\n//\tconceptually you may see this as a dynamic \"mesh\" builder)\n//\n// for more details and use cases see examples/canvas.\n// NOTE: GetCanvas() method returns a window-level canvas, however\n// you can convert any imgui.DrawList into this type.\n// The best example could be imgui.GetPlotDrawList()\n//\n//\tc := &Canvas{imgui.GetXXXDrawList()}\ntype Canvas struct {\n\tDrawList *imgui.DrawList\n}\n\n// GetCanvas returns current draw list (for current window).\n// it will fail if called out of window's layout.\nfunc GetCanvas() *Canvas {\n\treturn &Canvas{\n\t\tDrawList: imgui.WindowDrawList(),\n\t}\n}\n\n// AddLine draws a line (from p1 to p2).\nfunc (c *Canvas) AddLine(p1, p2 image.Point, col color.Color, thickness float32) {\n\tc.DrawList.AddLineV(ToVec2(p1), ToVec2(p2), ColorToUint(col), thickness)\n}\n\n// DrawFlags represents imgui.DrawFlags.\ntype DrawFlags imgui.DrawFlags\n\n// draw flags enum:.\nconst (\n\tDrawFlagsNone DrawFlags = DrawFlags(imgui.DrawFlagsNone)\n\t// PathStroke(), AddPolyline(): specify that shape should be closed (note: this is always == 1 for legacy reasons).\n\tDrawFlagsClosed DrawFlags = DrawFlags(imgui.DrawFlagsClosed)\n\t// AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0f, we default to all corners).\n\t// Was 0x01.\n\tDrawFlagsRoundCornersTopLeft DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersTopLeft)\n\t// AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0f, we default to all corners).\n\t// Was 0x02.\n\tDrawFlagsRoundCornersTopRight DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersTopRight)\n\t// AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0f, we default to all corners).\n\t// Was 0x04.\n\tDrawFlagsRoundCornersBottomLeft DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersBottomLeft)\n\t// AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0f,\n\t// we default to all corners). Wax 0x08.\n\tDrawFlagsRoundCornersBottomRight DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersBottomRight)\n\t// AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0f). This is NOT zero, NOT an implicit flag!\n\tDrawFlagsRoundCornersNone   DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersNone)\n\tDrawFlagsRoundCornersTop    DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersTop)\n\tDrawFlagsRoundCornersBottom DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersBottom)\n\tDrawFlagsRoundCornersLeft   DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersLeft)\n\tDrawFlagsRoundCornersRight  DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersRight)\n\tDrawFlagsRoundCornersAll    DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersAll)\n\n\t// Default to ALL corners if none of the RoundCornersXX flags are specified.\n\tDrawFlagsRoundCornersDefault DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersDefault)\n\tDrawFlagsRoundCornersMask    DrawFlags = DrawFlags(imgui.DrawFlagsRoundCornersMask)\n)\n\n// AddRect draws a rectangle.\nfunc (c *Canvas) AddRect(pMin, pMax image.Point, col color.Color, rounding float32, roundingCorners DrawFlags, thickness float32) {\n\tc.DrawList.AddRectV(ToVec2(pMin), ToVec2(pMax), ColorToUint(col), rounding, imgui.DrawFlags(roundingCorners), thickness)\n}\n\n// AddRectFilled draws a rectangle filled with `col`.\nfunc (c *Canvas) AddRectFilled(pMin, pMax image.Point, col color.Color, rounding float32, roundingCorners DrawFlags) {\n\tc.DrawList.AddRectFilledV(ToVec2(pMin), ToVec2(pMax), ColorToUint(col), rounding, imgui.DrawFlags(roundingCorners))\n}\n\n// AddText draws text.\nfunc (c *Canvas) AddText(pos image.Point, col color.Color, text string) {\n\tc.DrawList.AddTextVec2(ToVec2(pos), ColorToUint(col), Context.FontAtlas.RegisterString(text))\n}\n\n// AddBezierCubic draws bezier cubic.\nfunc (c *Canvas) AddBezierCubic(pos0, cp0, cp1, pos1 image.Point, col color.Color, thickness float32, numSegments int32) {\n\tc.DrawList.AddBezierCubicV(ToVec2(pos0), ToVec2(cp0), ToVec2(cp1), ToVec2(pos1), ColorToUint(col), thickness, numSegments)\n}\n\n// AddTriangle draws a triangle.\nfunc (c *Canvas) AddTriangle(p1, p2, p3 image.Point, col color.Color, thickness float32) {\n\tc.DrawList.AddTriangleV(ToVec2(p1), ToVec2(p2), ToVec2(p3), ColorToUint(col), thickness)\n}\n\n// AddTriangleFilled draws a filled triangle.\nfunc (c *Canvas) AddTriangleFilled(p1, p2, p3 image.Point, col color.Color) {\n\tc.DrawList.AddTriangleFilled(ToVec2(p1), ToVec2(p2), ToVec2(p3), ColorToUint(col))\n}\n\n// AddCircle draws a circle.\nfunc (c *Canvas) AddCircle(center image.Point, radius float32, col color.Color, segments int32, thickness float32) {\n\tc.DrawList.AddCircleV(ToVec2(center), radius, ColorToUint(col), segments, thickness)\n}\n\n// AddCircleFilled draws a filled circle.\nfunc (c *Canvas) AddCircleFilled(center image.Point, radius float32, col color.Color) {\n\tc.DrawList.AddCircleFilled(ToVec2(center), radius, ColorToUint(col))\n}\n\n// AddQuad draws a quad.\nfunc (c *Canvas) AddQuad(p1, p2, p3, p4 image.Point, col color.Color, thickness float32) {\n\tc.DrawList.AddQuadV(ToVec2(p1), ToVec2(p2), ToVec2(p3), ToVec2(p4), ColorToUint(col), thickness)\n}\n\n// AddQuadFilled draws a filled quad.\nfunc (c *Canvas) AddQuadFilled(p1, p2, p3, p4 image.Point, col color.Color) {\n\tc.DrawList.AddQuadFilled(ToVec2(p1), ToVec2(p2), ToVec2(p3), ToVec2(p4), ColorToUint(col))\n}\n\n// Stateful path API, add points then finish with PathFillConvex() or PathStroke().\n\n// PathClear clears the current path.\nfunc (c *Canvas) PathClear() {\n\tc.DrawList.PathClear()\n}\n\n// PathLineTo adds a line between the last point and the provided one.\nfunc (c *Canvas) PathLineTo(pos image.Point) {\n\tc.DrawList.PathLineTo(ToVec2(pos))\n}\n\n// PathLineToMergeDuplicate merges with previous if the vertex if very close.\nfunc (c *Canvas) PathLineToMergeDuplicate(pos image.Point) {\n\tc.DrawList.PathLineToMergeDuplicate(ToVec2(pos))\n}\n\n// PathFillConvex fills the current path with the specified color.\nfunc (c *Canvas) PathFillConvex(col color.Color) {\n\tc.DrawList.PathFillConvex(ColorToUint(col))\n}\n\n// PathStroke adds a line between the last point and the provided one.\nfunc (c *Canvas) PathStroke(col color.Color, flags DrawFlags, thickness float32) {\n\tc.DrawList.PathStrokeV(ColorToUint(col), imgui.DrawFlags(flags), thickness)\n}\n\n// PathArcTo adds a cubic bezier curve between the last point and the provided one.\nfunc (c *Canvas) PathArcTo(center image.Point, radius, minV, maxV float32, numSegments int32) {\n\tc.DrawList.PathArcToV(ToVec2(center), radius, minV, maxV, numSegments)\n}\n\n// PathArcToFast is a faster version of PathArcTo() but T=0 and T=1 will not exactly match the arc fast.\nfunc (c *Canvas) PathArcToFast(center image.Point, radius float32, min12, max12 int32) {\n\tc.DrawList.PathArcToFast(ToVec2(center), radius, min12, max12)\n}\n\n// PathBezierCubicCurveTo adds a cubic bezier curve.\nfunc (c *Canvas) PathBezierCubicCurveTo(p1, p2, p3 image.Point, numSegments int32) {\n\tc.DrawList.PathBezierCubicCurveToV(ToVec2(p1), ToVec2(p2), ToVec2(p3), numSegments)\n}\n\n// AddImage draws a textured rectangle.\nfunc (c *Canvas) AddImage(texture *Texture, pMin, pMax image.Point) {\n\tc.DrawList.AddImage(texture.ID(), ToVec2(pMin), ToVec2(pMax))\n}\n\n// AddImageQuad draws a textured on quad.\nfunc (c *Canvas) AddImageQuad(texture *Texture, p1, p2, p3, p4, uv1, uv2, uv3, uv4 image.Point, col color.Color) {\n\tc.DrawList.AddImageQuadV(texture.tex.ID, ToVec2(p1), ToVec2(p2), ToVec2(p3), ToVec2(p4), ToVec2(uv1), ToVec2(uv2), ToVec2(uv3), ToVec2(uv4), ColorToUint(col))\n}\n\n// AddImageV is more flexible version of AddImage.\nfunc (c *Canvas) AddImageV(texture *Texture, pMin, pMax, uvMin, uvMax image.Point, col color.Color) {\n\tc.DrawList.AddImageV(texture.tex.ID, ToVec2(pMin), ToVec2(pMax), ToVec2(uvMin), ToVec2(uvMax), ColorToUint(col))\n}\n"
        },
        {
          "name": "ClickableWidgets.go",
          "type": "blob",
          "size": 14.6435546875,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"golang.org/x/image/colornames\"\n)\n\nvar _ Widget = &ButtonWidget{}\n\n// ButtonWidget represents a ImGui button widget.\ntype ButtonWidget struct {\n\tid       ID\n\twidth    float32\n\theight   float32\n\tdisabled bool\n\tonClick  func()\n}\n\n// Button creates a new button widget.\nfunc Button(label string) *ButtonWidget {\n\treturn &ButtonWidget{\n\t\tid:      GenAutoID(label),\n\t\twidth:   0,\n\t\theight:  0,\n\t\tonClick: nil,\n\t}\n}\n\n// Buttonf creates button with formatted label\n// NOTE: works like fmt.Sprintf (see `go doc fmt`).\nfunc Buttonf(format string, args ...any) *ButtonWidget {\n\treturn Button(fmt.Sprintf(format, args...))\n}\n\n// OnClick sets callback called when button is clicked\n// NOTE: to set double click, see EventHandler.go.\nfunc (b *ButtonWidget) OnClick(onClick func()) *ButtonWidget {\n\tb.onClick = onClick\n\treturn b\n}\n\n// Disabled sets button's disabled state\n// NOTE: same effect as Style().SetDisabled.\nfunc (b *ButtonWidget) Disabled(d bool) *ButtonWidget {\n\tb.disabled = d\n\treturn b\n}\n\n// Size sets button's size.\nfunc (b *ButtonWidget) Size(width, height float32) *ButtonWidget {\n\tb.width, b.height = width, height\n\treturn b\n}\n\n// ID allows to manually set widget's id.\nfunc (b *ButtonWidget) ID(id ID) *ButtonWidget {\n\tb.id = id\n\treturn b\n}\n\n// Build implements Widget interface.\nfunc (b *ButtonWidget) Build() {\n\tif b.disabled {\n\t\timgui.BeginDisabled()\n\t\tdefer imgui.EndDisabled()\n\t}\n\n\tif imgui.ButtonV(Context.FontAtlas.RegisterString(b.id.String()), imgui.Vec2{X: b.width, Y: b.height}) && b.onClick != nil {\n\t\tb.onClick()\n\t}\n}\n\nvar _ Widget = &ArrowButtonWidget{}\n\n// ArrowButtonWidget represents a square button with an arrow.\ntype ArrowButtonWidget struct {\n\tid      ID\n\tdir     Direction\n\tonClick func()\n}\n\n// ArrowButton creates ArrowButtonWidget.\nfunc ArrowButton(dir Direction) *ArrowButtonWidget {\n\treturn &ArrowButtonWidget{\n\t\tid:      GenAutoID(\"ArrowButton\"),\n\t\tdir:     dir,\n\t\tonClick: nil,\n\t}\n}\n\n// OnClick adds callback called when button is clicked.\nfunc (b *ArrowButtonWidget) OnClick(onClick func()) *ArrowButtonWidget {\n\tb.onClick = onClick\n\treturn b\n}\n\n// ID allows to manually set widget's id.\nfunc (b *ArrowButtonWidget) ID(id ID) *ArrowButtonWidget {\n\tb.id = id\n\treturn b\n}\n\n// Build implements Widget interface.\nfunc (b *ArrowButtonWidget) Build() {\n\tif imgui.ArrowButton(b.id.String(), imgui.Dir(b.dir)) && b.onClick != nil {\n\t\tb.onClick()\n\t}\n}\n\nvar _ Widget = &SmallButtonWidget{}\n\n// SmallButtonWidget is like a button but without frame padding.\ntype SmallButtonWidget struct {\n\tid      ID\n\tonClick func()\n}\n\n// SmallButton constructs a new small button widget.\nfunc SmallButton(id string) *SmallButtonWidget {\n\treturn &SmallButtonWidget{\n\t\tid:      GenAutoID(id),\n\t\tonClick: nil,\n\t}\n}\n\n// SmallButtonf allows to set formatted label for small button.\n// It calls SmallButton(fmt.Sprintf(label, args...)).\nfunc SmallButtonf(format string, args ...any) *SmallButtonWidget {\n\treturn SmallButton(fmt.Sprintf(format, args...))\n}\n\n// OnClick adds OnClick event.\nfunc (b *SmallButtonWidget) OnClick(onClick func()) *SmallButtonWidget {\n\tb.onClick = onClick\n\treturn b\n}\n\n// Build implements Widget interface.\nfunc (b *SmallButtonWidget) Build() {\n\tif imgui.SmallButton(Context.FontAtlas.RegisterString(b.id.String())) && b.onClick != nil {\n\t\tb.onClick()\n\t}\n}\n\nvar _ Widget = &InvisibleButtonWidget{}\n\n// InvisibleButtonWidget is a clickable region.\n// NOTE: you may want to display other widgets on this button.\n// to do so, you may move drawing cursor back by Get/SetCursor(Screen)Pos.\ntype InvisibleButtonWidget struct {\n\tid      ID\n\twidth   float32\n\theight  float32\n\tonClick func()\n}\n\n// InvisibleButton constructs a new invisible button widget.\nfunc InvisibleButton() *InvisibleButtonWidget {\n\treturn &InvisibleButtonWidget{\n\t\tid:      GenAutoID(\"InvisibleButton\"),\n\t\twidth:   0,\n\t\theight:  0,\n\t\tonClick: nil,\n\t}\n}\n\n// Size sets button's size.\nfunc (b *InvisibleButtonWidget) Size(width, height float32) *InvisibleButtonWidget {\n\tb.width, b.height = width, height\n\treturn b\n}\n\n// OnClick sets click event.\nfunc (b *InvisibleButtonWidget) OnClick(onClick func()) *InvisibleButtonWidget {\n\tb.onClick = onClick\n\treturn b\n}\n\n// ID allows to manually set widget's id (no need to use in normal conditions).\nfunc (b *InvisibleButtonWidget) ID(id ID) *InvisibleButtonWidget {\n\tb.id = id\n\treturn b\n}\n\n// Build implements Widget interface.\nfunc (b *InvisibleButtonWidget) Build() {\n\tif imgui.InvisibleButton(Context.FontAtlas.RegisterString(b.id.String()), imgui.Vec2{X: b.width, Y: b.height}) && b.onClick != nil {\n\t\tb.onClick()\n\t}\n}\n\nvar _ Widget = &ImageButtonWidget{}\n\n// ImageButtonWidget is similar to ButtonWidget but with image texture instead of text label.\ntype ImageButtonWidget struct {\n\ttexture      *Texture\n\twidth        float32\n\theight       float32\n\tuv0          image.Point\n\tuv1          image.Point\n\tframePadding int\n\tbgColor      color.Color\n\ttintColor    color.Color\n\tonClick      func()\n\tid           ID\n}\n\n// ImageButton  constructs image button widget.\nfunc ImageButton(texture *Texture) *ImageButtonWidget {\n\treturn &ImageButtonWidget{\n\t\ttexture:      texture,\n\t\twidth:        50,\n\t\theight:       50,\n\t\tuv0:          image.Point{X: 0, Y: 0},\n\t\tuv1:          image.Point{X: 1, Y: 1},\n\t\tframePadding: -1,\n\t\tbgColor:      colornames.Black,\n\t\ttintColor:    colornames.White,\n\t\tonClick:      nil,\n\t\tid:           GenAutoID(\"ImageButton\"),\n\t}\n}\n\n// ID allows to manually set widget's id.\nfunc (b *ImageButtonWidget) ID(id ID) *ImageButtonWidget {\n\tb.id = id\n\treturn b\n}\n\n// Build implements Widget interface.\nfunc (b *ImageButtonWidget) Build() {\n\tif b.texture == nil || b.texture.tex == nil {\n\t\treturn\n\t}\n\n\timgui.PushIDStr(b.id.String())\n\n\tif imgui.ImageButtonV(\n\t\tfmt.Sprintf(\"%v\", b.texture.tex.ID),\n\t\tb.texture.tex.ID,\n\t\timgui.Vec2{X: b.width, Y: b.height},\n\t\tToVec2(b.uv0), ToVec2(b.uv1),\n\t\tToVec4Color(b.bgColor),\n\t\tToVec4Color(b.tintColor),\n\t) && b.onClick != nil {\n\t\tb.onClick()\n\t}\n\n\timgui.PopID()\n}\n\n// Size sets BUTTONS size.\n// NOTE: image size is button size - 2 * frame padding.\nfunc (b *ImageButtonWidget) Size(width, height float32) *ImageButtonWidget {\n\tb.width, b.height = width, height\n\treturn b\n}\n\n// OnClick sets click event.\nfunc (b *ImageButtonWidget) OnClick(onClick func()) *ImageButtonWidget {\n\tb.onClick = onClick\n\treturn b\n}\n\n// UV sets image's uv.\nfunc (b *ImageButtonWidget) UV(uv0, uv1 image.Point) *ImageButtonWidget {\n\tb.uv0, b.uv1 = uv0, uv1\n\treturn b\n}\n\n// BgColor sets button's background color.\nfunc (b *ImageButtonWidget) BgColor(bgColor color.Color) *ImageButtonWidget {\n\tb.bgColor = bgColor\n\treturn b\n}\n\n// TintColor sets tit color for image.\nfunc (b *ImageButtonWidget) TintColor(tintColor color.Color) *ImageButtonWidget {\n\tb.tintColor = tintColor\n\treturn b\n}\n\n// FramePadding sets button's frame padding (set 0 to fit image to the frame).\nfunc (b *ImageButtonWidget) FramePadding(padding int) *ImageButtonWidget {\n\tb.framePadding = padding\n\treturn b\n}\n\nvar _ Widget = &ImageButtonWithRgbaWidget{}\n\n// ImageButtonWithRgbaWidget does similar to ImageButtonWidget,\n// but implements image.Image instead of giu.Texture. It is probably\n// more useful than the original ImageButtonWidget.\ntype ImageButtonWithRgbaWidget struct {\n\t*ImageButtonWidget\n\trgba image.Image\n\tid   ID\n}\n\n// ImageButtonWithRgba creates a new widget.\nfunc ImageButtonWithRgba(rgba image.Image) *ImageButtonWithRgbaWidget {\n\treturn &ImageButtonWithRgbaWidget{\n\t\tid:                GenAutoID(\"ImageButtonWithRgba\"),\n\t\tImageButtonWidget: ImageButton(nil),\n\t\trgba:              rgba,\n\t}\n}\n\n// Size sets button's size.\nfunc (b *ImageButtonWithRgbaWidget) Size(width, height float32) *ImageButtonWithRgbaWidget {\n\tb.ImageButtonWidget.Size(width, height)\n\treturn b\n}\n\n// OnClick sets click events.\nfunc (b *ImageButtonWithRgbaWidget) OnClick(onClick func()) *ImageButtonWithRgbaWidget {\n\tb.ImageButtonWidget.OnClick(onClick)\n\treturn b\n}\n\n// UV sets image's uv color.\nfunc (b *ImageButtonWithRgbaWidget) UV(uv0, uv1 image.Point) *ImageButtonWithRgbaWidget {\n\tb.ImageButtonWidget.UV(uv0, uv1)\n\treturn b\n}\n\n// BgColor sets button's background color.\nfunc (b *ImageButtonWithRgbaWidget) BgColor(bgColor color.Color) *ImageButtonWithRgbaWidget {\n\tb.ImageButtonWidget.BgColor(bgColor)\n\treturn b\n}\n\n// TintColor sets image's tint color.\nfunc (b *ImageButtonWithRgbaWidget) TintColor(tintColor color.Color) *ImageButtonWithRgbaWidget {\n\tb.ImageButtonWidget.TintColor(tintColor)\n\treturn b\n}\n\n// FramePadding sets frame padding (see (*ImageButtonWidget).TintColor).\nfunc (b *ImageButtonWithRgbaWidget) FramePadding(padding int) *ImageButtonWithRgbaWidget {\n\tb.ImageButtonWidget.FramePadding(padding)\n\treturn b\n}\n\n// Build implements Widget interface.\nfunc (b *ImageButtonWithRgbaWidget) Build() {\n\tif state := GetState[imageState](Context, b.id); state == nil {\n\t\tSetState(Context, b.id, &imageState{})\n\n\t\tNewTextureFromRgba(b.rgba, func(tex *Texture) {\n\t\t\tSetState(Context, b.id, &imageState{texture: tex})\n\t\t})\n\t} else {\n\t\tb.ImageButtonWidget.texture = state.texture\n\t}\n\n\tb.ImageButtonWidget.Build()\n}\n\nvar _ Widget = &CheckboxWidget{}\n\n// CheckboxWidget adds a checkbox.\ntype CheckboxWidget struct {\n\ttext     ID\n\tselected *bool\n\tonChange func()\n}\n\n// Checkbox creates a new CheckboxWidget.\nfunc Checkbox(text string, selected *bool) *CheckboxWidget {\n\treturn &CheckboxWidget{\n\t\ttext:     GenAutoID(text),\n\t\tselected: selected,\n\t\tonChange: nil,\n\t}\n}\n\n// ID sets widget's id (overrides text).\nfunc (c *CheckboxWidget) ID(id ID) *CheckboxWidget {\n\tc.text = id\n\treturn c\n}\n\n// OnChange adds callback called when checkbox's state was changed.\nfunc (c *CheckboxWidget) OnChange(onChange func()) *CheckboxWidget {\n\tc.onChange = onChange\n\treturn c\n}\n\n// Build implements Widget interface.\nfunc (c *CheckboxWidget) Build() {\n\tif imgui.Checkbox(Context.FontAtlas.RegisterString(c.text.String()), c.selected) && c.onChange != nil {\n\t\tc.onChange()\n\t}\n}\n\nvar _ Widget = &RadioButtonWidget{}\n\n// RadioButtonWidget is a small, round button.\n// It is common to use it for single-choice questions.\n// see examples/widgets.\ntype RadioButtonWidget struct {\n\ttext     ID\n\tactive   bool\n\tonChange func()\n}\n\n// RadioButton creates a radio button.\nfunc RadioButton(text string, active bool) *RadioButtonWidget {\n\treturn &RadioButtonWidget{\n\t\ttext:     GenAutoID(text),\n\t\tactive:   active,\n\t\tonChange: nil,\n\t}\n}\n\n// OnChange adds callback when button's state gets changed.\nfunc (r *RadioButtonWidget) OnChange(onChange func()) *RadioButtonWidget {\n\tr.onChange = onChange\n\treturn r\n}\n\n// Build implements Widget interface.\nfunc (r *RadioButtonWidget) Build() {\n\tif imgui.RadioButtonBool(Context.FontAtlas.RegisterString(r.text.String()), r.active) && r.onChange != nil {\n\t\tr.onChange()\n\t}\n}\n\nvar _ Widget = &SelectableWidget{}\n\n// SelectableWidget is a window-width button with a label which can get selected (highlighted).\n// useful for certain lists.\ntype SelectableWidget struct {\n\tlabel    ID\n\tselected bool\n\tflags    SelectableFlags\n\twidth    float32\n\theight   float32\n\tonClick  func()\n\tonDClick func()\n}\n\n// Selectable constructs a selectable widget.\nfunc Selectable(label string) *SelectableWidget {\n\treturn &SelectableWidget{\n\t\tlabel:    GenAutoID(label),\n\t\tselected: false,\n\t\tflags:    0,\n\t\twidth:    0,\n\t\theight:   0,\n\t\tonClick:  nil,\n\t}\n}\n\n// Selectablef creates a selectable widget with formatted label.\nfunc Selectablef(format string, args ...any) *SelectableWidget {\n\treturn Selectable(fmt.Sprintf(format, args...))\n}\n\n// Selected sets if selectable widget is selected.\nfunc (s *SelectableWidget) Selected(selected bool) *SelectableWidget {\n\ts.selected = selected\n\treturn s\n}\n\n// Flags add flags.\nfunc (s *SelectableWidget) Flags(flags SelectableFlags) *SelectableWidget {\n\ts.flags = flags\n\treturn s\n}\n\n// Size sets selectable's size.\nfunc (s *SelectableWidget) Size(width, height float32) *SelectableWidget {\n\ts.width, s.height = width, height\n\treturn s\n}\n\n// OnClick sets on click event.\nfunc (s *SelectableWidget) OnClick(onClick func()) *SelectableWidget {\n\ts.onClick = onClick\n\treturn s\n}\n\n// OnDClick handles mouse left button's double click event.\n// SelectableFlagsAllowDoubleClick will set once tonDClick callback is notnull.\n// NOTE: IT IS DEPRECATED and could be removed. Use EventHandler instead.\nfunc (s *SelectableWidget) OnDClick(onDClick func()) *SelectableWidget {\n\ts.onDClick = onDClick\n\treturn s\n}\n\n// Build implements Widget interface.\nfunc (s *SelectableWidget) Build() {\n\t// If onDClick is set, check flags and set related flag when necessary\n\tif s.onDClick != nil && s.flags&SelectableFlagsAllowDoubleClick != 0 {\n\t\ts.flags |= SelectableFlagsAllowDoubleClick\n\t}\n\n\tif imgui.SelectableBoolV(Context.FontAtlas.RegisterString(s.label.String()), s.selected, imgui.SelectableFlags(s.flags), imgui.Vec2{X: s.width, Y: s.height}) && s.onClick != nil {\n\t\ts.onClick()\n\t}\n\n\tif s.onDClick != nil && IsItemActive() && IsMouseDoubleClicked(MouseButtonLeft) {\n\t\ts.onDClick()\n\t}\n}\n\nvar _ Widget = &TreeNodeWidget{}\n\n// TreeNodeWidget is a a wide button with open/close state.\n// if is opened, the `layout` is displayed below the widget.\n// It can be used to create certain lists, advanced settings sections e.t.c.\ntype TreeNodeWidget struct {\n\tlabel        string\n\tflags        TreeNodeFlags\n\tlayout       Layout\n\tevent        func()\n\teventHandler *EventHandler\n}\n\n// TreeNode creates a new tree node widget.\nfunc TreeNode(label string) *TreeNodeWidget {\n\treturn &TreeNodeWidget{\n\t\tlabel:        Context.FontAtlas.RegisterString(label),\n\t\tflags:        0,\n\t\tlayout:       nil,\n\t\teventHandler: nil,\n\t}\n}\n\n// TreeNodef adds TreeNode with formatted label.\nfunc TreeNodef(format string, args ...any) *TreeNodeWidget {\n\treturn TreeNode(fmt.Sprintf(format, args...))\n}\n\n// Flags sets flags.\nfunc (t *TreeNodeWidget) Flags(flags TreeNodeFlags) *TreeNodeWidget {\n\tt.flags = flags\n\treturn t\n}\n\n// Event create TreeNode with event handling function.\n// You could detect events (e.g. IsItemClicked IsMouseDoubleClicked etc...) and handle them for TreeNode inside eventHandler.\n// Deprecated: Use (*TreeNodeWidget).EventHandler instead!\nfunc (t *TreeNodeWidget) Event(handler func()) *TreeNodeWidget {\n\tt.event = handler\n\treturn t\n}\n\n// EventHandler allows to set *EventHandler instance for the actual TreeNode.\nfunc (t *TreeNodeWidget) EventHandler(handler *EventHandler) *TreeNodeWidget {\n\tt.eventHandler = handler\n\treturn t\n}\n\n// Layout sets layout to be displayed when tree node is opened.\nfunc (t *TreeNodeWidget) Layout(widgets ...Widget) *TreeNodeWidget {\n\tt.layout = Layout(widgets)\n\treturn t\n}\n\n// Build implements Widget interface.\nfunc (t *TreeNodeWidget) Build() {\n\topen := imgui.TreeNodeExStrV(t.label, imgui.TreeNodeFlags(t.flags))\n\n\tif t.event != nil {\n\t\tt.event()\n\t}\n\n\tif t.eventHandler != nil {\n\t\tt.eventHandler.Build()\n\t}\n\n\tif open {\n\t\tt.layout.Build()\n\n\t\tif (imgui.TreeNodeFlags(t.flags) & imgui.TreeNodeFlagsNoTreePushOnOpen) == 0 {\n\t\t\timgui.TreePop()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "CodeEditor.go",
          "type": "blob",
          "size": 6.4189453125,
          "content": "//nolint:gocritic,govet,revive,wsl // this file is TODO. We don't want commentedOutCode linter issues here yet.\npackage giu\n\nimport (\n\tcte \"github.com/AllenDang/cimgui-go/ImGuiColorTextEdit\"\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// LanguageDefinition represents code editor's language definition.\ntype LanguageDefinition byte\n\n// language definitions:.\nconst (\n\tLanguageDefinitionNone        LanguageDefinition = LanguageDefinition(cte.None)\n\tLanguageDefinitionCPP         LanguageDefinition = LanguageDefinition(cte.Cpp)\n\tLanguageDefinitionC           LanguageDefinition = LanguageDefinition(cte.C)\n\tLanguageDefinitionCs          LanguageDefinition = LanguageDefinition(cte.Cs)\n\tLanguageDefinitionPython      LanguageDefinition = LanguageDefinition(cte.Python)\n\tLanguageDefinitionLua         LanguageDefinition = LanguageDefinition(cte.Lua)\n\tLanguageDefinitionJSON        LanguageDefinition = LanguageDefinition(cte.Json)\n\tLanguageDefinitionSQL         LanguageDefinition = LanguageDefinition(cte.Sql)\n\tLanguageDefinitionAngelScript LanguageDefinition = LanguageDefinition(cte.AngelScript)\n\tLanguageDefinitionGlsl        LanguageDefinition = LanguageDefinition(cte.Glsl)\n\tLanguageDefinitionHlsl        LanguageDefinition = LanguageDefinition(cte.Hlsl)\n)\n\nvar _ Disposable = &codeEditorState{}\n\ntype codeEditorState struct {\n\teditor *cte.TextEditor\n}\n\n// Dispose implements Disposable interface.\nfunc (s *codeEditorState) Dispose() {\n\ts.editor.Destroy()\n}\n\n// static check if code editor implements Widget interface.\nvar _ Widget = &CodeEditorWidget{}\n\n// CodeEditorWidget represents imgui.TextEditor.\ntype CodeEditorWidget struct {\n\ttitle ID\n\twidth,\n\theight float32\n\tborder bool\n}\n\n// CodeEditor creates new code editor widget.\nfunc CodeEditor() *CodeEditorWidget {\n\treturn &CodeEditorWidget{\n\t\ttitle: GenAutoID(\"##CodeEditor\"),\n\t}\n}\n\n// ID allows to manually set editor's ID.\n// It isn't necessary to use it in a normal conditions.\nfunc (ce *CodeEditorWidget) ID(id ID) *CodeEditorWidget {\n\tce.title = id\n\treturn ce\n}\n\n// ShowWhitespaces sets if whitespace is shown in code editor.\nfunc (ce *CodeEditorWidget) ShowWhitespaces(s bool) *CodeEditorWidget {\n\tce.getState().editor.SetShowWhitespacesEnabled(s)\n\treturn ce\n}\n\n// TabSize sets editor's tab size.\nfunc (ce *CodeEditorWidget) TabSize(size int) *CodeEditorWidget {\n\tce.getState().editor.SetTabSize(int32(size))\n\treturn ce\n}\n\n// LanguageDefinition sets code editor language definition.\nfunc (ce *CodeEditorWidget) LanguageDefinition(definition LanguageDefinition) *CodeEditorWidget {\n\ts := ce.getState()\n\ts.editor.SetLanguageDefinition(cte.LanguageDefinitionId(definition))\n\n\treturn ce\n}\n\n// Text sets editor's text.\nfunc (ce *CodeEditorWidget) Text(str string) *CodeEditorWidget {\n\tce.getState().editor.SetText(str)\n\treturn ce\n}\n\n// ErrorMarkers sets error markers.\n// func (ce *CodeEditorWidget) ErrorMarkers(markers imgui.ErrorMarkers) *CodeEditorWidget {\n//\tce.getState().editor.SetErrorMarkers(markers)\n// return ce\n//}\n\n// HandleKeyboardInputs sets if editor should handle keyboard input.\nfunc (ce *CodeEditorWidget) HandleKeyboardInputs(b bool) *CodeEditorWidget {\n\tpanic(\"not implemented\")\n\t// ce.getState().editor.SetHandleKeyboardInputs(b)\n\treturn ce\n}\n\n// Size sets editor's size.\nfunc (ce *CodeEditorWidget) Size(w, h float32) *CodeEditorWidget {\n\tce.width, ce.height = w, h\n\treturn ce\n}\n\n// Border sets editors borders.\nfunc (ce *CodeEditorWidget) Border(border bool) *CodeEditorWidget {\n\tce.border = border\n\treturn ce\n}\n\n// HasSelection returns true if some text is selected.\nfunc (ce *CodeEditorWidget) HasSelection() bool {\n\treturn ce.getState().editor.AnyCursorHasSelection()\n}\n\n// GetSelectedText returns selected text.\nfunc (ce *CodeEditorWidget) GetSelectedText() string {\n\tpanic(\"not implemented\")\n\t// return ce.getState().editor.GetSelectedText()\n\treturn \"\"\n}\n\n// GetText returns whole text from editor.\nfunc (ce *CodeEditorWidget) GetText() string {\n\treturn ce.getState().editor.Text()\n}\n\n// GetCurrentLineText returns current line.\nfunc (ce *CodeEditorWidget) GetCurrentLineText() string {\n\tpanic(\"not implemented\")\n\t//\treturn ce.getState().editor.GetCurrentLineText()\n\treturn \"\"\n}\n\n// GetCursorPos returns cursor position.\n// (in characters).\nfunc (ce *CodeEditorWidget) GetCursorPos() (x, y int) {\n\tvar px, py int32\n\tce.getState().editor.CursorPosition(&px, &py)\n\treturn int(px), int(py)\n}\n\n// GetSelectionStart returns star pos of selection.\nfunc (ce *CodeEditorWidget) GetSelectionStart() (x, y int) {\n\tpanic(\"not implemented\")\n\t//\treturn ce.getState().editor.GetSelectionStart()\n\treturn 0, 0\n}\n\n// InsertText inserts the `text`.\nfunc (ce *CodeEditorWidget) InsertText(text string) {\n\tpanic(\"not implemented\")\n\t//\tce.getState().editor.InsertText(text)\n}\n\n// GetWordUnderCursor returns the word under the cursor.\nfunc (ce *CodeEditorWidget) GetWordUnderCursor() string {\n\tpanic(\"not implemented\")\n\t//\treturn ce.getState().editor.GetWordUnderCursor()\n\treturn \"\"\n}\n\n// SelectWordUnderCursor selects the word under cursor.\nfunc (ce *CodeEditorWidget) SelectWordUnderCursor() {\n\tpanic(\"not implemented\")\n\t// ce.getState().editor.SelectWordUnderCursor()\n}\n\n// IsTextChanged returns true if the editable text was changed in the frame.\nfunc (ce *CodeEditorWidget) IsTextChanged() bool {\n\tpanic(\"not implemented\")\n\t//\treturn ce.getState().editor.IsTextChanged()\n\treturn false\n}\n\n// GetScreenCursorPos returns cursor position on the screen.\n// (in pixels).\nfunc (ce *CodeEditorWidget) GetScreenCursorPos() (x, y int) {\n\tpanic(\"not implemented\")\n\t//\treturn ce.getState().editor.GetScreenCursorPos()\n\treturn 0, 0\n}\n\n// Copy copies selection.\nfunc (ce *CodeEditorWidget) Copy() {\n\tce.getState().editor.Copy()\n}\n\n// Cut cuts selection.\nfunc (ce *CodeEditorWidget) Cut() {\n\tce.getState().editor.Cut()\n}\n\n// Paste does the same as Ctrl+V.\nfunc (ce *CodeEditorWidget) Paste() {\n\tce.getState().editor.Paste()\n}\n\n// Delete deletes the selection.\nfunc (ce *CodeEditorWidget) Delete() {\n\tpanic(\"not implemented\")\n\t// ce.getState().editor.Delete()\n}\n\n// Build implements Widget interface.\nfunc (ce *CodeEditorWidget) Build() {\n\ts := ce.getState()\n\n\t// register text in font atlas\n\tContext.FontAtlas.RegisterString(s.editor.Text())\n\n\t// build editor\n\ts.editor.RenderV(string(ce.title), false, imgui.Vec2{X: ce.width, Y: ce.height}, ce.border)\n}\n\nfunc (ce *CodeEditorWidget) getState() (state *codeEditorState) {\n\tif state = GetState[codeEditorState](Context, ce.title); state == nil {\n\t\tstate = &codeEditorState{\n\t\t\teditor: cte.NewTextEditor(),\n\t\t}\n\n\t\tSetState(Context, ce.title, state)\n\t}\n\n\treturn state\n}\n"
        },
        {
          "name": "Context.go",
          "type": "blob",
          "size": 4.6953125,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\n\t\"github.com/AllenDang/cimgui-go/backend\"\n\t\"github.com/AllenDang/cimgui-go/backend/glfwbackend\"\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"gopkg.in/eapache/queue.v1\"\n)\n\n// GenAutoID automatically generates widget's ID.\n// It returns an unique value each time it is called.\nfunc GenAutoID(id string) ID {\n\tidx := int(0)\n\tidxAny, ok := Context.widgetIndex.Load(id)\n\n\tif ok {\n\t\tidx, ok = idxAny.(int)\n\t\tAssert(ok, \"Context\", \"GenAutoID\", \"unexpected type of widgetIndex value: expected int, instead found %T\", idxAny)\n\n\t\tidx++\n\t}\n\n\tContext.widgetIndex.Store(id, idx)\n\n\treturn ID(fmt.Sprintf(\"%s##%d\", id, idx))\n}\n\n// Context represents a giu context.\nvar Context *GIUContext\n\n// Disposable should be implemented by all states stored in context.\n// Dispose method is called when state is removed from context.\ntype Disposable interface {\n\tDispose()\n}\n\ntype genericDisposable[T any] interface {\n\tDisposable\n\t*T\n}\n\ntype state struct {\n\tvalid bool\n\tdata  Disposable\n}\n\n// GIUContext represents a giu context. (Current context is giu.Context.\n//\n//nolint:revive // I WANT TO CALL THIS GIUContext!\ntype GIUContext struct {\n\tbackend backend.Backend[glfwbackend.GLFWWindowFlags]\n\n\tisRunning bool\n\n\twidgetIndex sync.Map\n\n\t// Indicate whether current application is running\n\tisAlive bool\n\n\t// when dirty is true, flushStates must be called before any GetState use\n\t// when it is false, calling flushStates is noop\n\tdirty bool\n\n\t// States will used by custom widget to store data\n\tstate sync.Map\n\n\tInputHandler InputHandler\n\tFontAtlas    *FontAtlas\n\n\ttextureLoadingQueue *queue.Queue\n\ttextureFreeingQueue *queue.Queue\n\n\tcssStylesheet cssStylesheet\n\n\tm *sync.Mutex\n}\n\n// CreateContext creates a new giu context.\nfunc CreateContext(b backend.Backend[glfwbackend.GLFWWindowFlags]) *GIUContext {\n\tresult := GIUContext{\n\t\tcssStylesheet:       make(cssStylesheet),\n\t\tbackend:             b,\n\t\tFontAtlas:           newFontAtlas(),\n\t\ttextureLoadingQueue: queue.New(),\n\t\ttextureFreeingQueue: queue.New(),\n\t\tm:                   &sync.Mutex{},\n\t}\n\n\t// Create font\n\tif len(result.FontAtlas.defaultFonts) == 0 {\n\t\tfonts := result.IO().Fonts()\n\t\tfonts.AddFontDefault()\n\t\tfontTextureImg, w, h, _ := fonts.GetTextureDataAsRGBA32()\n\t\ttex := result.backend.CreateTexture(fontTextureImg, int(w), int(h))\n\t\tfonts.SetTexID(tex)\n\t\tfonts.SetTexReady(true)\n\t} else {\n\t\tresult.FontAtlas.shouldRebuildFontAtlas = true\n\t}\n\n\treturn &result\n}\n\n// IO returns the imgui.IO object.\nfunc (c *GIUContext) IO() *imgui.IO {\n\treturn imgui.CurrentIO()\n}\n\n// SetDirty permits MasterWindow defering setting dirty states after it's render().\nfunc (c *GIUContext) SetDirty() {\n\tc.dirty = true\n}\n\n// cleanStates removes all states that were not marked as valid during rendering,\n// then reset said flag before new usage\n// should always be called before first Get/Set state use in renderloop\n// since afterRender() and beforeRender() are not waranted to run (see glfw_window_refresh_callback)\n// we call it at the very start of our render()\n// but just in case something happened, we also use the \"dirty\" flag to enforce (or avoid) flushing\n// on critical path.\nfunc (c *GIUContext) cleanStates() {\n\tif !c.dirty {\n\t\treturn\n\t}\n\n\tc.state.Range(func(k, v any) bool {\n\t\tif s, ok := v.(*state); ok {\n\t\t\tc.m.Lock()\n\t\t\tvalid := s.valid\n\t\t\tc.m.Unlock()\n\n\t\t\tif valid {\n\t\t\t\ts.valid = false\n\t\t\t} else {\n\t\t\t\tc.state.Delete(k)\n\t\t\t\ts.data.Dispose()\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t})\n\n\tc.widgetIndex.Clear()\n\tc.dirty = false\n}\n\n// Backend returns the imgui.backend used by the context.\nfunc (c *GIUContext) Backend() backend.Backend[glfwbackend.GLFWWindowFlags] {\n\treturn c.backend\n}\n\n// SetState is a generic version of Context.SetState.\nfunc SetState[T any, PT genericDisposable[T]](c *GIUContext, id ID, data PT) {\n\tc.cleanStates()\n\tc.state.Store(id, &state{valid: true, data: data})\n}\n\n// SetState stores data in context by id.\nfunc (c *GIUContext) SetState(id ID, data Disposable) {\n\tc.cleanStates()\n\tc.state.Store(id, &state{valid: true, data: data})\n}\n\n// GetState is a generic version of Context.GetState.\nfunc GetState[T any, PT genericDisposable[T]](c *GIUContext, id ID) PT {\n\tc.cleanStates()\n\n\tif s, ok := c.load(id); ok {\n\t\tc.m.Lock()\n\t\ts.valid = true\n\t\tc.m.Unlock()\n\n\t\tdata, isOk := s.data.(PT)\n\t\tAssert(isOk, \"Context\", \"GetState\", \"got state of unexpected type: expected %T, instead found %T\", new(T), s.data)\n\n\t\treturn data\n\t}\n\n\treturn nil\n}\n\n// GetState returns previously stored state by id.\nfunc (c *GIUContext) GetState(id ID) any {\n\tc.cleanStates()\n\n\tif s, ok := c.load(id); ok {\n\t\tc.m.Lock()\n\t\ts.valid = true\n\t\tc.m.Unlock()\n\n\t\treturn s.data\n\t}\n\n\treturn nil\n}\n\nfunc (c *GIUContext) load(id any) (*state, bool) {\n\tif v, ok := c.state.Load(id); ok {\n\t\tif s, ok := v.(*state); ok {\n\t\t\treturn s, true\n\t\t}\n\t}\n\n\treturn nil, false\n}\n"
        },
        {
          "name": "Context_test.go",
          "type": "blob",
          "size": 1.982421875,
          "content": "package giu\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype teststate struct{}\n\nfunc (s *teststate) Dispose() {\n\t// noop\n}\n\ntype teststate2 struct{}\n\nfunc (t *teststate2) Dispose() {\n\t// noop\n}\n\nfunc Test_SetGetState(t *testing.T) {\n\ttests := []struct {\n\t\tid   ID\n\t\tdata *teststate\n\t}{\n\t\t{\"nil\", nil},\n\t\t{\"pointer\", &teststate{}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.id.String(), func(t *testing.T) {\n\t\t\tctx := CreateContext(nil)\n\t\t\tSetState(ctx, tc.id, tc.data)\n\t\t\trestored := GetState[teststate](ctx, tc.id)\n\t\t\tassert.Equal(t, tc.data, restored, \"unexpected state restored\")\n\t\t})\n\t}\n}\n\nfunc Test_SetGetStateGeneric(t *testing.T) {\n\ttests := []struct {\n\t\tid   ID\n\t\tdata *teststate\n\t}{\n\t\t{\"nil\", nil},\n\t\t{\"pointer\", &teststate{}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.id.String(), func(t *testing.T) {\n\t\t\tctx := CreateContext(nil)\n\t\t\tSetState(ctx, tc.id, tc.data)\n\t\t\trestored := GetState[teststate](ctx, tc.id)\n\t\t\tassert.Equal(t, tc.data, restored, \"unexpected state restored\")\n\t\t})\n\t}\n}\n\nfunc Test_SetGetWrongStateGeneric(t *testing.T) {\n\tid := ID(\"id\")\n\tdata := &teststate{}\n\tctx := GIUContext{}\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected code to assert to panic, but it didn't\")\n\t\t}\n\t}()\n\n\tSetState(&ctx, id, data)\n\tGetState[teststate2](&ctx, id)\n}\n\nfunc Test_invalidState(t *testing.T) {\n\tctx := CreateContext(nil)\n\n\tstate1ID := ID(\"state1\")\n\tstate2ID := ID(\"state2\")\n\tstates := map[ID]*teststate{\n\t\tstate1ID: {},\n\t\tstate2ID: {},\n\t}\n\n\tfor i, s := range states {\n\t\tSetState(ctx, i, s)\n\t}\n\n\t// SetState set \"valid=true\" so we simulate a first end of frame before tests\n\tctx.SetDirty()\n\n\t_ = GetState[teststate](ctx, state2ID)\n\n\tctx.SetDirty()\n\n\tassert.NotNil(t, GetState[teststate](ctx, state2ID),\n\t\t\"although state has been accessed during the frame, it has ben deleted by invalidAllState/cleanState\")\n\tassert.Nil(t, GetState[teststate](ctx, state1ID),\n\t\t\"although state hasn't been accessed during the frame, it hasn't ben deleted by invalidAllState/cleanState\")\n}\n"
        },
        {
          "name": "Direction.go",
          "type": "blob",
          "size": 0.3232421875,
          "content": "package giu\n\nimport \"github.com/AllenDang/cimgui-go/imgui\"\n\n// Direction represents a ArrowButton direction.\ntype Direction imgui.Dir\n\n// directions.\nconst (\n\tDirectionLeft  = Direction(imgui.DirLeft)\n\tDirectionRight = Direction(imgui.DirRight)\n\tDirectionUp    = Direction(imgui.DirUp)\n\tDirectionDown  = Direction(imgui.DirDown)\n)\n"
        },
        {
          "name": "EventHandler.go",
          "type": "blob",
          "size": 4.234375,
          "content": "package giu\n\nvar _ Disposable = &eventHandlerState{}\n\ntype eventHandlerState struct {\n\tisActive bool\n}\n\n// Dispose implements Disposable interface.\nfunc (s *eventHandlerState) Dispose() {\n\t// noop\n}\n\ntype mouseEvent struct {\n\tmouseButton MouseButton\n\tcallback    func()\n\tcond        func(MouseButton) bool\n}\n\ntype keyEvent struct {\n\tkey      Key\n\tcallback func()\n\tcond     func(Key) bool\n}\n\nvar _ Widget = &EventHandler{}\n\n// EventHandler is a universal event handler for giu widgets.\n// put giu.Event()... after any widget to handle any event.\ntype EventHandler struct {\n\thover       func()\n\tmouseEvents []mouseEvent\n\tkeyEvents   []keyEvent\n\tonActivate,\n\tonDeactivate,\n\tonActive func()\n}\n\n// Event adds a new event to widget above.\nfunc Event() *EventHandler {\n\treturn &EventHandler{\n\t\tmouseEvents: make([]mouseEvent, 0),\n\t\tkeyEvents:   make([]keyEvent, 0),\n\t}\n}\n\n// OnHover sets callback when item gets hovered.\nfunc (eh *EventHandler) OnHover(onHover func()) *EventHandler {\n\teh.hover = onHover\n\treturn eh\n}\n\n// OnActive sets a callback when ite IS ACTIVE (not activated).\nfunc (eh *EventHandler) OnActive(cb func()) *EventHandler {\n\teh.onActive = cb\n\treturn eh\n}\n\n// OnActivate sets callback when item gets activated.\nfunc (eh *EventHandler) OnActivate(cb func()) *EventHandler {\n\teh.onActivate = cb\n\treturn eh\n}\n\n// OnDeactivate sets callback when item gets deactivated.\nfunc (eh *EventHandler) OnDeactivate(cb func()) *EventHandler {\n\teh.onDeactivate = cb\n\treturn eh\n}\n\n// Key events\n\n// OnKeyDown sets callback when key `key` is down.\nfunc (eh *EventHandler) OnKeyDown(key Key, cb func()) *EventHandler {\n\teh.keyEvents = append(eh.keyEvents, keyEvent{key, cb, IsKeyDown})\n\treturn eh\n}\n\n// OnKeyPressed sets callback when key `key` is pressed.\nfunc (eh *EventHandler) OnKeyPressed(key Key, cb func()) *EventHandler {\n\teh.keyEvents = append(eh.keyEvents, keyEvent{key, cb, IsKeyPressed})\n\treturn eh\n}\n\n// OnKeyReleased sets callback when key `key` is released.\nfunc (eh *EventHandler) OnKeyReleased(key Key, cb func()) *EventHandler {\n\teh.keyEvents = append(eh.keyEvents, keyEvent{key, cb, IsKeyReleased})\n\treturn eh\n}\n\n// Mouse events\n\n// OnClick sets callback when mouse button `mouseButton` is clicked.\nfunc (eh *EventHandler) OnClick(mouseButton MouseButton, callback func()) *EventHandler {\n\teh.mouseEvents = append(eh.mouseEvents, mouseEvent{mouseButton, callback, IsMouseClicked})\n\treturn eh\n}\n\n// OnDClick sets callback when mouse button `mouseButton` is double-clicked.\nfunc (eh *EventHandler) OnDClick(mouseButton MouseButton, callback func()) *EventHandler {\n\teh.mouseEvents = append(eh.mouseEvents, mouseEvent{mouseButton, callback, IsMouseDoubleClicked})\n\treturn eh\n}\n\n// OnMouseDown sets callback when mouse button `mouseButton` is down.\nfunc (eh *EventHandler) OnMouseDown(mouseButton MouseButton, callback func()) *EventHandler {\n\teh.mouseEvents = append(eh.mouseEvents, mouseEvent{mouseButton, callback, IsMouseDown})\n\treturn eh\n}\n\n// OnMouseReleased sets callback when mouse button `mouseButton` is released.\nfunc (eh *EventHandler) OnMouseReleased(mouseButton MouseButton, callback func()) *EventHandler {\n\teh.mouseEvents = append(eh.mouseEvents, mouseEvent{mouseButton, callback, IsMouseReleased})\n\treturn eh\n}\n\n// Build implements Widget interface\n//\n//nolint:gocyclo // will fix later\nfunc (eh *EventHandler) Build() {\n\tisActive := IsItemActive()\n\n\tif eh.onActivate != nil || eh.onDeactivate != nil {\n\t\tvar state *eventHandlerState\n\n\t\tstateID := GenAutoID(\"eventHandlerState\")\n\t\tif state = GetState[eventHandlerState](Context, stateID); state == nil {\n\t\t\tstate = &eventHandlerState{}\n\t\t\tSetState(Context, stateID, state)\n\t\t}\n\n\t\tif eh.onActivate != nil && isActive && !state.isActive {\n\t\t\tstate.isActive = true\n\n\t\t\teh.onActivate()\n\t\t}\n\n\t\tif eh.onDeactivate != nil && !isActive && state.isActive {\n\t\t\tstate.isActive = false\n\n\t\t\teh.onDeactivate()\n\t\t}\n\t}\n\n\tif isActive && eh.onActive != nil {\n\t\teh.onActive()\n\t}\n\n\tif !IsItemHovered() {\n\t\treturn\n\t}\n\n\tif eh.hover != nil {\n\t\teh.hover()\n\t}\n\n\tif len(eh.keyEvents) > 0 {\n\t\tfor _, event := range eh.keyEvents {\n\t\t\tif event.callback != nil && event.cond(event.key) {\n\t\t\t\tevent.callback()\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(eh.mouseEvents) > 0 {\n\t\tfor _, event := range eh.mouseEvents {\n\t\t\tif event.callback != nil && event.cond(event.mouseButton) {\n\t\t\t\tevent.callback()\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "Events.go",
          "type": "blob",
          "size": 2.6123046875,
          "content": "package giu\n\nimport \"github.com/AllenDang/cimgui-go/imgui\"\n\n// MouseButton represents imgui.MouseButton.\ntype MouseButton imgui.MouseButton\n\n// mouse buttons.\nconst (\n\tMouseButtonLeft   MouseButton = MouseButton(imgui.MouseButtonLeft)\n\tMouseButtonRight  MouseButton = MouseButton(imgui.MouseButtonRight)\n\tMouseButtonMiddle MouseButton = MouseButton(imgui.MouseButtonMiddle)\n)\n\n// IsItemHovered returns true if mouse is over the item.\nfunc IsItemHovered() bool {\n\treturn imgui.IsItemHovered()\n}\n\n// IsItemClicked returns true if mouse is clicked\n// NOTE: if you're looking for clicking detection, see EventHandler.go.\nfunc IsItemClicked(mouseButton MouseButton) bool {\n\treturn imgui.IsItemClickedV(imgui.MouseButton(mouseButton))\n}\n\n// IsItemActive returns true if item is active.\nfunc IsItemActive() bool {\n\treturn imgui.IsItemActive()\n}\n\n// IsKeyDown returns true if key `key` is down.\nfunc IsKeyDown(key Key) bool {\n\treturn imgui.IsKeyDown(imgui.Key(key))\n}\n\n// IsKeyPressed returns true if key `key` is pressed.\nfunc IsKeyPressed(key Key) bool {\n\treturn imgui.IsKeyPressedBool(imgui.Key(key))\n}\n\n// IsKeyReleased returns true if key `key` is released.\nfunc IsKeyReleased(key Key) bool {\n\treturn imgui.IsKeyReleased(imgui.Key(key))\n}\n\n// IsMouseDown returns true if mouse button `button` is down.\nfunc IsMouseDown(button MouseButton) bool {\n\treturn imgui.IsMouseDown(imgui.MouseButton(button))\n}\n\n// IsMouseClicked returns true if mouse button `button` is clicked\n// NOTE: if you're looking for clicking detection, see EventHandler.go.\nfunc IsMouseClicked(button MouseButton) bool {\n\treturn imgui.IsMouseClickedBool(imgui.MouseButton(button))\n}\n\n// IsMouseReleased returns true if mouse button `button` is released.\nfunc IsMouseReleased(button MouseButton) bool {\n\treturn imgui.IsMouseReleased(imgui.MouseButton(button))\n}\n\n// IsMouseDoubleClicked returns true if mouse button `button` is double clicked.\nfunc IsMouseDoubleClicked(button MouseButton) bool {\n\treturn imgui.IsMouseDoubleClicked(imgui.MouseButton(button))\n}\n\n// IsWindowAppearing returns true if window is appearing.\nfunc IsWindowAppearing() bool {\n\treturn imgui.IsWindowAppearing()\n}\n\n// IsWindowCollapsed returns true if window is disappearing.\nfunc IsWindowCollapsed() bool {\n\treturn imgui.IsWindowCollapsed()\n}\n\n// IsWindowFocused returns true if window is focused\n// NOTE: see also (*Window).HasFocus and (*Window).BringToFront.\nfunc IsWindowFocused(flags FocusedFlags) bool {\n\treturn imgui.IsWindowFocusedV(imgui.FocusedFlags(flags))\n}\n\n// IsWindowHovered returns true if the window is hovered.\nfunc IsWindowHovered(flags HoveredFlags) bool {\n\treturn imgui.IsWindowHoveredV(imgui.HoveredFlags(flags))\n}\n"
        },
        {
          "name": "ExtraWidgets.go",
          "type": "blob",
          "size": 14.576171875,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"time\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\nvar _ Widget = &SplitterWidget{}\n\n// SplitterWidget is a line (vertical or horizontal) that splits layout (child)\n// Int two pieces. It has a tiny button in the middle of that line and its creator\n// takes float pointer so that you can read user's movement of this rect.\n// Generally used by SplitLayoutWidget.\ntype SplitterWidget struct {\n\tid        ID\n\twidth     float32\n\theight    float32\n\tdelta     *float32\n\tdirection SplitDirection\n}\n\n// Splitter creates new SplitterWidget.\nfunc Splitter(direction SplitDirection, delta *float32) *SplitterWidget {\n\treturn &SplitterWidget{\n\t\tid:        GenAutoID(\"Splitter\"),\n\t\twidth:     0,\n\t\theight:    0,\n\t\tdelta:     delta,\n\t\tdirection: direction,\n\t}\n}\n\n// Size sets size of the button aray.\nfunc (h *SplitterWidget) Size(width, height float32) *SplitterWidget {\n\taw, ah := GetAvailableRegion()\n\n\tif width == 0 {\n\t\th.width = aw\n\t} else {\n\t\th.width = width\n\t}\n\n\tif height == 0 {\n\t\th.height = ah\n\t} else {\n\t\th.height = height\n\t}\n\n\treturn h\n}\n\n// ID allows to set widget's ID manually.\nfunc (h *SplitterWidget) ID(id ID) *SplitterWidget {\n\th.id = id\n\treturn h\n}\n\n// Build implements Widget interface.\nfunc (h *SplitterWidget) Build() {\n\t// Calc line position.\n\tvar width, height int\n\n\tswitch h.direction {\n\tcase DirectionHorizontal:\n\t\twidth = 40\n\t\theight = 2\n\tcase DirectionVertical:\n\t\twidth = 2\n\t\theight = 40\n\t}\n\n\tpt := GetCursorScreenPos()\n\n\tcenterX := int(h.width / 2)\n\tcenterY := int(h.height / 2)\n\n\tptMin := image.Pt(centerX-width/2, centerY-height/2)\n\tptMax := image.Pt(centerX+width/2, centerY+height/2)\n\n\tc := Vec4ToRGBA(*imgui.StyleColorVec4(imgui.ColScrollbarGrab))\n\n\t// Place a invisible button to capture event.\n\timgui.InvisibleButton(h.id.String(), imgui.Vec2{X: h.width, Y: h.height})\n\n\tif imgui.IsItemActive() {\n\t\tswitch h.direction {\n\t\tcase DirectionHorizontal:\n\t\t\t*(h.delta) = imgui.CurrentIO().MouseDelta().Y\n\t\tcase DirectionVertical:\n\t\t\t*(h.delta) = imgui.CurrentIO().MouseDelta().X\n\t\t}\n\t} else {\n\t\t*(h.delta) = 0\n\t}\n\n\tif imgui.IsItemHovered() {\n\t\tswitch h.direction {\n\t\tcase DirectionHorizontal:\n\t\t\timgui.SetMouseCursor(imgui.MouseCursorResizeNS)\n\t\tcase DirectionVertical:\n\t\t\timgui.SetMouseCursor(imgui.MouseCursorResizeEW)\n\t\t}\n\n\t\tc = Vec4ToRGBA(*imgui.StyleColorVec4(imgui.ColScrollbarGrabActive))\n\t}\n\n\t// Draw a line in the very center\n\tcanvas := GetCanvas()\n\tcanvas.AddRectFilled(pt.Add(ptMin), pt.Add(ptMax), c, 0, 0)\n}\n\nvar (\n\t_ Widget     = &CustomWidget{}\n\t_ PlotWidget = &CustomWidget{}\n\t_ GizmoI     = &CustomWidget{}\n)\n\n// CustomWidget allows you to do whatever you want.\n// This includes:\n// - using functions from upstream imgui instead of thes from giu\n// - build widgets in loop (see also RangeBuilder)\n// - do any calculations needed in this part of rendering.\ntype CustomWidget struct {\n\tbuilder func()\n}\n\n// Custom creates a new custom widget.\nfunc Custom(builder func()) *CustomWidget {\n\treturn &CustomWidget{\n\t\tbuilder: builder,\n\t}\n}\n\n// Build implements Widget interface.\nfunc (c *CustomWidget) Build() {\n\tif c.builder != nil {\n\t\tc.builder()\n\t}\n}\n\n// Plot implements Plot interface.\nfunc (c *CustomWidget) Plot() {\n\tc.Build()\n}\n\n// Gizmo implements GizmoI interface.\nfunc (c *CustomWidget) Gizmo(_ *ViewMatrix, _ *ProjectionMatrix) {\n\tc.Build()\n}\n\nvar _ Widget = &ConditionWidget{}\n\n// ConditionWidget allows to build if a condition is met\n// it is like:\n//\n//\tif condition {\n//\t   layoutIf.Build()\n//\t} else {\n//\n//\t   layoutElse.Build()\n//\t}\ntype ConditionWidget struct {\n\tcond bool\n\tlayoutIf,\n\tlayoutElse Widget\n}\n\n// Condition creates new COnditionWidget.\nfunc Condition(cond bool, layoutIf, layoutElse Widget) *ConditionWidget {\n\treturn &ConditionWidget{\n\t\tcond:       cond,\n\t\tlayoutIf:   layoutIf,\n\t\tlayoutElse: layoutElse,\n\t}\n}\n\n// Range implements extra abilities (see Splittablle).\nfunc (c *ConditionWidget) Range(rangeFunc func(w Widget)) {\n\tvar l Widget\n\tif c.cond {\n\t\tl = c.layoutIf\n\t} else {\n\t\tl = c.layoutElse\n\t}\n\n\ts, ok := l.(Splitable)\n\tif !ok {\n\t\trangeFunc(l)\n\t\treturn\n\t}\n\n\tif l != nil {\n\t\ts.Range(rangeFunc)\n\t}\n}\n\n// Build implements Widget interface.\nfunc (c *ConditionWidget) Build() {\n\tif c.cond {\n\t\tif c.layoutIf != nil {\n\t\t\tc.layoutIf.Build()\n\t\t}\n\t} else {\n\t\tif c.layoutElse != nil {\n\t\t\tc.layoutElse.Build()\n\t\t}\n\t}\n}\n\n// RangeBuilder batch create widgets and render only which is visible.\nfunc RangeBuilder[S ~[]T, T any](id string, values S, builder func(int, T) Widget) Layout {\n\tvar layout Layout\n\n\tlayout = append(layout, Custom(func() { imgui.PushIDStr(id) }))\n\n\tif len(values) > 0 && builder != nil {\n\t\tfor i, v := range values {\n\t\t\tvalueRef := v\n\t\t\twidget := builder(i, valueRef)\n\t\t\tlayout = append(layout, widget)\n\t\t}\n\t}\n\n\tlayout = append(layout, Custom(func() { imgui.PopID() }))\n\n\treturn layout\n}\n\ntype listBoxState struct {\n\tselectedIndex int32\n}\n\nfunc (s *listBoxState) Dispose() {\n\t// Nothing to do here.\n}\n\nvar _ Widget = &ListBoxWidget{}\n\n// ListBoxWidget is a field with selectable items (Child with Selectables).\ntype ListBoxWidget struct {\n\tselectedIndex *int32\n\tid            ID\n\twidth         float32\n\theight        float32\n\tborder        bool\n\titems         []string\n\tmenus         []string\n\tonChange      func(selectedIndex int)\n\tonDClick      func(selectedIndex int)\n\tonMenu        func(selectedIndex int, menu string)\n}\n\n// ListBox creates new ListBoxWidget.\nfunc ListBox(items []string) *ListBoxWidget {\n\treturn &ListBoxWidget{\n\t\tid:       GenAutoID(\"##ListBox\"),\n\t\twidth:    0,\n\t\theight:   0,\n\t\tborder:   true,\n\t\titems:    items,\n\t\tmenus:    nil,\n\t\tonChange: nil,\n\t\tonDClick: nil,\n\t\tonMenu:   nil,\n\t}\n}\n\n// ID assigns hardcoded ID (baypass GenAutoID mechanism).\nfunc (l *ListBoxWidget) ID(id ID) *ListBoxWidget {\n\tl.id = id\n\treturn l\n}\n\n// SelectedIndex sets a pointer where the selected index will be stored.\nfunc (l *ListBoxWidget) SelectedIndex(i *int32) *ListBoxWidget {\n\tl.selectedIndex = i\n\treturn l\n}\n\n// Size sets size of the box.\nfunc (l *ListBoxWidget) Size(width, height float32) *ListBoxWidget {\n\tl.width, l.height = width, height\n\treturn l\n}\n\n// Border sets whether box should have border (see Child().Border(...).\nfunc (l *ListBoxWidget) Border(b bool) *ListBoxWidget {\n\tl.border = b\n\treturn l\n}\n\n// ContextMenu adds item in context menu which is opened when user right-click on item.\nfunc (l *ListBoxWidget) ContextMenu(menuItems []string) *ListBoxWidget {\n\tl.menus = menuItems\n\treturn l\n}\n\n// OnChange sets callback called when user changes their selection.\nfunc (l *ListBoxWidget) OnChange(onChange func(selectedIndex int)) *ListBoxWidget {\n\tl.onChange = onChange\n\treturn l\n}\n\n// OnDClick sets callback on double click.\nfunc (l *ListBoxWidget) OnDClick(onDClick func(selectedIndex int)) *ListBoxWidget {\n\tl.onDClick = onDClick\n\treturn l\n}\n\n// OnMenu sets callback called when context menu item clicked.\nfunc (l *ListBoxWidget) OnMenu(onMenu func(selectedIndex int, menu string)) *ListBoxWidget {\n\tl.onMenu = onMenu\n\treturn l\n}\n\n// Build implements Widget interface\n//\n//nolint:gocognit // will fix later\nfunc (l *ListBoxWidget) Build() {\n\tselectedIndex := l.selectedIndex\n\tif selectedIndex == nil {\n\t\tvar state *listBoxState\n\t\tif state = GetState[listBoxState](Context, l.id); state == nil {\n\t\t\tstate = &listBoxState{selectedIndex: 0}\n\t\t\tSetState(Context, l.id, state)\n\t\t}\n\n\t\tselectedIndex = &state.selectedIndex\n\t}\n\n\tchild := Child().Border(l.border).Size(l.width, l.height).Layout(Layout{\n\t\tCustom(func() {\n\t\t\tclipper := imgui.NewListClipper()\n\t\t\tdefer clipper.Destroy()\n\n\t\t\tclipper.Begin(int32(len(l.items)))\n\n\t\t\tfor clipper.Step() {\n\t\t\t\tfor i := clipper.DisplayStart(); i < clipper.DisplayEnd(); i++ {\n\t\t\t\t\tselected := i == *selectedIndex\n\t\t\t\t\titem := l.items[i]\n\t\t\t\t\tSelectable(item).Selected(selected).Flags(SelectableFlagsAllowDoubleClick).OnClick(func() {\n\t\t\t\t\t\tif *selectedIndex != i {\n\t\t\t\t\t\t\t*selectedIndex = i\n\t\t\t\t\t\t\tif l.onChange != nil {\n\t\t\t\t\t\t\t\tl.onChange(int(i))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}).Build()\n\n\t\t\t\t\tif IsItemHovered() && IsMouseDoubleClicked(MouseButtonLeft) && l.onDClick != nil {\n\t\t\t\t\t\tl.onDClick(int(*selectedIndex))\n\t\t\t\t\t}\n\n\t\t\t\t\t// Build context menus\n\t\t\t\t\tvar menus Layout\n\t\t\t\t\tfor _, m := range l.menus {\n\t\t\t\t\t\tindex := i\n\t\t\t\t\t\tmenu := m\n\t\t\t\t\t\tmenus = append(menus, MenuItem(fmt.Sprintf(\"%s##%d\", menu, index)).OnClick(func() {\n\t\t\t\t\t\t\tif l.onMenu != nil {\n\t\t\t\t\t\t\t\tl.onMenu(int(index), menu)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}))\n\t\t\t\t\t}\n\n\t\t\t\t\tif len(menus) > 0 {\n\t\t\t\t\t\tContextMenu().Layout(menus).Build()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclipper.End()\n\t\t}),\n\t})\n\n\tchild.Build()\n}\n\nvar _ Widget = &DatePickerWidget{}\n\n// DatePickerLabels represents a label string in date picker.\ntype DatePickerLabels string\n\n// These constants hold strings for translations of day/month/year.\nconst (\n\tDatePickerLabelMonth DatePickerLabels = \"Month:\"\n\tDatePickerLabelYear  DatePickerLabels = \"    Year:\"\n)\n\n// DatePickerWidget is a simple Calender widget.\n// It allow user to select a day and convert it to time.Time go type.\n// It consists of a Combo widget which (after opening) contains\n// a calender-like table.\ntype DatePickerWidget struct {\n\tid           ID\n\tdate         *time.Time\n\twidth        float32\n\tonChange     func()\n\tformat       string\n\tstartOfWeek  time.Weekday\n\ttranslations map[DatePickerLabels]string\n}\n\n// DatePicker creates new DatePickerWidget.\nfunc DatePicker(id string, date *time.Time) *DatePickerWidget {\n\treturn &DatePickerWidget{\n\t\tid:          GenAutoID(id),\n\t\tdate:        date,\n\t\twidth:       100,\n\t\tstartOfWeek: time.Sunday,\n\t\tonChange:    func() {}, // small hack - prevent giu from setting nil cb (skip nil check later)\n\t\ttranslations: map[DatePickerLabels]string{\n\t\t\tDatePickerLabelMonth: string(DatePickerLabelMonth),\n\t\t\tDatePickerLabelYear:  string(DatePickerLabelYear),\n\t\t},\n\t}\n}\n\n// Size sets combo widget's size.\nfunc (d *DatePickerWidget) Size(width float32) *DatePickerWidget {\n\td.width = width\n\treturn d\n}\n\n// OnChange sets callback called when date is changed.\nfunc (d *DatePickerWidget) OnChange(onChange func()) *DatePickerWidget {\n\tif onChange != nil {\n\t\td.onChange = onChange\n\t}\n\n\treturn d\n}\n\n// Format sets date format of displayed (in combo) date.\n// Compatible with (time.Time).Format(...)\n// Default: \"2006-01-02\".\nfunc (d *DatePickerWidget) Format(format string) *DatePickerWidget {\n\td.format = format\n\treturn d\n}\n\n// StartOfWeek sets first day of the week\n// Default: Sunday.\nfunc (d *DatePickerWidget) StartOfWeek(weekday time.Weekday) *DatePickerWidget {\n\td.startOfWeek = weekday\n\treturn d\n}\n\n// Translation sets a translation to specified label type.\nfunc (d *DatePickerWidget) Translation(label DatePickerLabels, value string) *DatePickerWidget {\n\td.translations[label] = value\n\treturn d\n}\n\nfunc (d *DatePickerWidget) getFormat() string {\n\tif d.format == \"\" {\n\t\treturn \"2006-01-02\" // default\n\t}\n\n\treturn d.format\n}\n\nfunc (d *DatePickerWidget) offsetDay(offset int) time.Weekday {\n\tday := (int(d.startOfWeek) + offset) % 7\n\t// offset may be negative, thus day can be negative\n\tday = (day + 7) % 7\n\n\treturn time.Weekday(day)\n}\n\n// Build implements Widget interface.\nfunc (d *DatePickerWidget) Build() {\n\tif d.date == nil {\n\t\treturn\n\t}\n\n\timgui.PushIDStr(d.id.String())\n\tdefer imgui.PopID()\n\n\tif d.width > 0 {\n\t\tPushItemWidth(d.width)\n\n\t\tdefer PopItemWidth()\n\t}\n\n\tif imgui.BeginComboV(d.id.String()+\"##Combo\", d.date.Format(d.getFormat()), imgui.ComboFlagsHeightLargest) {\n\t\t// --- [Build year/month widget] ---\n\t\timgui.AlignTextToFramePadding()\n\n\t\tTable().\n\t\t\tSize(0, 50).\n\t\t\tFlags(0).\n\t\t\tColumns(\n\t\t\t\tTableColumn(\"##\"+d.id.String()+\"col1\").Flags(TableColumnFlags(imgui.TableColumnFlagsNoHeaderLabel)),\n\t\t\t\tTableColumn(\"##\"+d.id.String()+\"col2\").Flags(TableColumnFlags(imgui.TableColumnFlagsNoHeaderLabel)),\n\t\t\t\tTableColumn(\"##\"+d.id.String()+\"col3\").Flags(TableColumnFlags(imgui.TableColumnFlagsNoHeaderLabel)|TableColumnFlagsWidthFixed).InnerWidthOrWeight(100),\n\t\t\t\tTableColumn(\"##\"+d.id.String()+\"col4\").Flags(TableColumnFlags(imgui.TableColumnFlagsNoHeaderLabel)),\n\t\t\t).\n\t\t\tRows(\n\t\t\t\tTableRow(\n\t\t\t\t\tLabel(d.translations[DatePickerLabelYear]),\n\t\t\t\t\tArrowButton(DirectionLeft).ID(d.id+\"year-\").OnClick(func() {\n\t\t\t\t\t\t*d.date = d.date.AddDate(-1, 0, 0)\n\t\t\t\t\t\td.onChange()\n\t\t\t\t\t}),\n\t\t\t\t\tLabelf(\"%d\", d.date.Year()),\n\t\t\t\t\tArrowButton(DirectionRight).ID(d.id+\"year+\").OnClick(func() {\n\t\t\t\t\t\t*d.date = d.date.AddDate(1, 0, 0)\n\t\t\t\t\t\td.onChange()\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t\tTableRow(\n\t\t\t\t\tLabel(d.translations[DatePickerLabelMonth]),\n\t\t\t\t\tArrowButton(DirectionLeft).ID(d.id+\"month-\").OnClick(func() {\n\t\t\t\t\t\t*d.date = d.date.AddDate(0, -1, 0)\n\t\t\t\t\t\td.onChange()\n\t\t\t\t\t}),\n\t\t\t\t\tLabelf(\"%s (%02d)\", d.date.Month().String(), d.date.Month()),\n\t\t\t\t\tArrowButton(DirectionRight).ID(d.id+\"month+\").OnClick(func() {\n\t\t\t\t\t\t*d.date = d.date.AddDate(0, 1, 0)\n\t\t\t\t\t\td.onChange()\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t).Build()\n\n\t\t// --- [Build day widgets] ---\n\t\tdays := d.getDaysGroups()\n\n\t\t// Create calendar (widget)\n\t\tcolumns := make([]*TableColumnWidget, 7)\n\n\t\tfor i := 0; i < 7; i++ {\n\t\t\tfirstChar := d.offsetDay(i).String()[0:1]\n\t\t\tcolumns[i] = TableColumn(firstChar)\n\t\t}\n\n\t\t// Build day widgets\n\t\tvar rows []*TableRowWidget\n\n\t\tfor _, week := range days {\n\t\t\tvar row []Widget\n\n\t\t\tfor _, day := range week {\n\t\t\t\tif day == 0 {\n\t\t\t\t\trow = append(row, Label(\" \"))\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\trow = append(row, d.calendarField(day))\n\t\t\t}\n\n\t\t\trows = append(rows, TableRow(row...))\n\t\t}\n\n\t\tTable().Flags(TableFlagsBorders | TableFlagsSizingStretchSame).Columns(columns...).Rows(rows...).Build()\n\n\t\timgui.EndCombo()\n\t}\n}\n\n// store month days sorted in weeks.\nfunc (d *DatePickerWidget) getDaysGroups() (days [][]int) {\n\tfirstDay := time.Date(d.date.Year(), d.date.Month(), 1, 0, 0, 0, 0, time.Local)\n\tlastDay := firstDay.AddDate(0, 1, 0).Add(time.Nanosecond * -1)\n\n\t// calculate first week\n\tdays = append(days, make([]int, 7))\n\n\tmonthDay := 1\n\temptyDaysInFirstWeek := (int(firstDay.Weekday()) - int(d.startOfWeek) + 7) % 7\n\n\tfor i := emptyDaysInFirstWeek; i < 7; i++ {\n\t\tdays[0][i] = monthDay\n\t\tmonthDay++\n\t}\n\n\t// Build rest rows\n\tfor ; monthDay <= lastDay.Day(); monthDay++ {\n\t\tif len(days[len(days)-1]) == 7 {\n\t\t\tdays = append(days, []int{})\n\t\t}\n\n\t\tdays[len(days)-1] = append(days[len(days)-1], monthDay)\n\t}\n\n\t// Pad last row\n\tlastRowLen := len(days[len(days)-1])\n\tif lastRowLen < 7 {\n\t\tfor i := lastRowLen; i < 7; i++ {\n\t\t\tdays[len(days)-1] = append(days[len(days)-1], 0)\n\t\t}\n\t}\n\n\treturn days\n}\n\nfunc (d *DatePickerWidget) calendarField(day int) Widget {\n\ttoday := time.Now()\n\thighlightColor := imgui.StyleColorVec4(imgui.ColPlotHistogram)\n\n\treturn Custom(func() {\n\t\tisToday := d.date.Year() == today.Year() && d.date.Month() == today.Month() && day == today.Day()\n\t\tif isToday {\n\t\t\timgui.PushStyleColorVec4(imgui.ColText, *highlightColor)\n\t\t}\n\n\t\tSelectable(fmt.Sprintf(\"%02d\", day)).Selected(isToday).OnClick(func() {\n\t\t\t*d.date = time.Date(\n\t\t\t\td.date.Year(), d.date.Month(), day,\n\t\t\t\t0, 0, 0, 0,\n\t\t\t\td.date.Location())\n\t\t\td.onChange()\n\t\t}).Build()\n\n\t\tif isToday {\n\t\t\timgui.PopStyleColor()\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "Flags.go",
          "type": "blob",
          "size": 34.6337890625,
          "content": "package giu\n\nimport (\n\t\"github.com/AllenDang/cimgui-go/backend/glfwbackend\"\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/AllenDang/cimgui-go/implot\"\n)\n\n// InputTextFlags represents input text flags.\ntype InputTextFlags imgui.InputTextFlags\n\n// input text flags.\nconst (\n\t// InputTextFlagsNone sets everything default.\n\tInputTextFlagsNone = InputTextFlags(imgui.InputTextFlagsNone)\n\t// InputTextFlagsCharsDecimal allows 0123456789.+-.\n\tInputTextFlagsCharsDecimal = InputTextFlags(imgui.InputTextFlagsCharsDecimal)\n\t// InputTextFlagsCharsHexadecimal allow 0123456789ABCDEFabcdef.\n\tInputTextFlagsCharsHexadecimal = InputTextFlags(imgui.InputTextFlagsCharsHexadecimal)\n\t// InputTextFlagsCharsUppercase turns a..z into A..Z.\n\tInputTextFlagsCharsUppercase = InputTextFlags(imgui.InputTextFlagsCharsUppercase)\n\t// InputTextFlagsCharsNoBlank filters out spaces, tabs.\n\tInputTextFlagsCharsNoBlank = InputTextFlags(imgui.InputTextFlagsCharsNoBlank)\n\t// InputTextFlagsAutoSelectAll selects entire text when first taking mouse focus.\n\tInputTextFlagsAutoSelectAll = InputTextFlags(imgui.InputTextFlagsAutoSelectAll)\n\t// InputTextFlagsEnterReturnsTrue returns 'true' when Enter is pressed (as opposed to when the value was modified).\n\tInputTextFlagsEnterReturnsTrue = InputTextFlags(imgui.InputTextFlagsEnterReturnsTrue)\n\t// InputTextFlagsCallbackCompletion for callback on pressing TAB (for completion handling).\n\tInputTextFlagsCallbackCompletion = InputTextFlags(imgui.InputTextFlagsCallbackCompletion)\n\t// InputTextFlagsCallbackHistory for callback on pressing Up/Down arrows (for history handling).\n\tInputTextFlagsCallbackHistory = InputTextFlags(imgui.InputTextFlagsCallbackHistory)\n\t// InputTextFlagsCallbackAlways for callback on each iteration. User code may query cursor position, modify text buffer.\n\tInputTextFlagsCallbackAlways = InputTextFlags(imgui.InputTextFlagsCallbackAlways)\n\t// InputTextFlagsCallbackCharFilter for callback on character inputs to replace or discard them.\n\t// Modify 'EventChar' to replace or discard, or return 1 in callback to discard.\n\tInputTextFlagsCallbackCharFilter = InputTextFlags(imgui.InputTextFlagsCallbackCharFilter)\n\t// InputTextFlagsAllowTabInput when pressing TAB to input a '\\t' character into the text field.\n\tInputTextFlagsAllowTabInput = InputTextFlags(imgui.InputTextFlagsAllowTabInput)\n\t// InputTextFlagsCtrlEnterForNewLine in multi-line mode, unfocus with Enter, add new line with Ctrl+Enter\n\t// (default is opposite: unfocus with Ctrl+Enter, add line with Enter).\n\tInputTextFlagsCtrlEnterForNewLine = InputTextFlags(imgui.InputTextFlagsCtrlEnterForNewLine)\n\t// InputTextFlagsNoHorizontalScroll disables following the cursor horizontally.\n\tInputTextFlagsNoHorizontalScroll = InputTextFlags(imgui.InputTextFlagsNoHorizontalScroll)\n\t// InputTextFlagsAlwaysInsertMode sets insert mode.\n\n\t// InputTextFlagsReadOnly sets read-only mode.\n\tInputTextFlagsReadOnly = InputTextFlags(imgui.InputTextFlagsReadOnly)\n\t// InputTextFlagsPassword sets password mode, display all characters as '*'.\n\tInputTextFlagsPassword = InputTextFlags(imgui.InputTextFlagsPassword)\n\t// InputTextFlagsNoUndoRedo disables undo/redo. Note that input text owns the text data while active,\n\t// if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().\n\tInputTextFlagsNoUndoRedo = InputTextFlags(imgui.InputTextFlagsNoUndoRedo)\n\t// InputTextFlagsCharsScientific allows 0123456789.+-*/eE (Scientific notation input).\n\tInputTextFlagsCharsScientific = InputTextFlags(imgui.InputTextFlagsCharsScientific)\n)\n\n// WindowFlags represents a window flags (see (*WindowWidget).Flags.\ntype WindowFlags glfwbackend.GLFWWindowFlags\n\n// window flags.\nconst (\n\t// WindowFlagsNone default = 0.\n\tWindowFlagsNone WindowFlags = WindowFlags(imgui.WindowFlagsNone)\n\t// WindowFlagsNoTitleBar disables title-bar.\n\tWindowFlagsNoTitleBar WindowFlags = WindowFlags(imgui.WindowFlagsNoTitleBar)\n\t// WindowFlagsNoResize disables user resizing with the lower-right grip.\n\tWindowFlagsNoResize WindowFlags = WindowFlags(imgui.WindowFlagsNoResize)\n\t// WindowFlagsNoMove disables user moving the window.\n\tWindowFlagsNoMove WindowFlags = WindowFlags(imgui.WindowFlagsNoMove)\n\t// WindowFlagsNoScrollbar disables scrollbars. Window can still scroll with mouse or programmatically.\n\tWindowFlagsNoScrollbar WindowFlags = WindowFlags(imgui.WindowFlagsNoScrollbar)\n\t// WindowFlagsNoScrollWithMouse disables user vertically scrolling with mouse wheel. On child window, mouse wheel\n\t// will be forwarded to the parent unless NoScrollbar is also set.\n\tWindowFlagsNoScrollWithMouse WindowFlags = WindowFlags(imgui.WindowFlagsNoScrollWithMouse)\n\t// WindowFlagsNoCollapse disables user collapsing window by double-clicking on it.\n\tWindowFlagsNoCollapse WindowFlags = WindowFlags(imgui.WindowFlagsNoCollapse)\n\t// WindowFlagsAlwaysAutoResize resizes every window to its content every frame.\n\tWindowFlagsAlwaysAutoResize WindowFlags = WindowFlags(imgui.WindowFlagsAlwaysAutoResize)\n\t// WindowFlagsNoBackground disables drawing background color (WindowBg, etc.) and outside border. Similar as using\n\t// SetNextWindowBgAlpha(0.0f).\n\tWindowFlagsNoBackground WindowFlags = WindowFlags(imgui.WindowFlagsNoBackground)\n\t// WindowFlagsNoSavedSettings will never load/save settings in .ini file.\n\tWindowFlagsNoSavedSettings WindowFlags = WindowFlags(imgui.WindowFlagsNoSavedSettings)\n\t// WindowFlagsNoMouseInputs disables catching mouse, hovering test with pass through.\n\tWindowFlagsNoMouseInputs WindowFlags = WindowFlags(imgui.WindowFlagsNoMouseInputs)\n\t// WindowFlagsMenuBar has a menu-bar.\n\tWindowFlagsMenuBar WindowFlags = WindowFlags(imgui.WindowFlagsMenuBar)\n\t// WindowFlagsHorizontalScrollbar allows horizontal scrollbar to appear (off by default). You may use\n\t// SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo\n\t// in the \"Horizontal Scrolling\" section.\n\tWindowFlagsHorizontalScrollbar WindowFlags = WindowFlags(imgui.WindowFlagsHorizontalScrollbar)\n\t// WindowFlagsNoFocusOnAppearing disables taking focus when transitioning from hidden to visible state.\n\tWindowFlagsNoFocusOnAppearing WindowFlags = WindowFlags(imgui.WindowFlagsNoFocusOnAppearing)\n\t// WindowFlagsNoBringToFrontOnFocus disables bringing window to front when taking focus. e.g. clicking on it or\n\t// programmatically giving it focus.\n\tWindowFlagsNoBringToFrontOnFocus WindowFlags = WindowFlags(imgui.WindowFlagsNoBringToFrontOnFocus)\n\t// WindowFlagsAlwaysVerticalScrollbar always shows vertical scrollbar, even if ContentSize.y < Size.y .\n\tWindowFlagsAlwaysVerticalScrollbar WindowFlags = WindowFlags(imgui.WindowFlagsAlwaysVerticalScrollbar)\n\t// WindowFlagsAlwaysHorizontalScrollbar always shows horizontal scrollbar, even if ContentSize.x < Size.x .\n\tWindowFlagsAlwaysHorizontalScrollbar WindowFlags = WindowFlags(imgui.WindowFlagsAlwaysHorizontalScrollbar)\n\t// WindowFlagsNoNavInputs has no gamepad/keyboard navigation within the window.\n\tWindowFlagsNoNavInputs WindowFlags = WindowFlags(imgui.WindowFlagsNoNavInputs)\n\t// WindowFlagsNoNavFocus has no focusing toward this window with gamepad/keyboard navigation\n\t// (e.g. skipped by CTRL+TAB).\n\tWindowFlagsNoNavFocus WindowFlags = WindowFlags(imgui.WindowFlagsNoNavFocus)\n\t// WindowFlagsUnsavedDocument appends '*' to title without affecting the ID, as a convenience to avoid using the\n\t// ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one\n\t// frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.\n\tWindowFlagsUnsavedDocument WindowFlags = WindowFlags(imgui.WindowFlagsUnsavedDocument)\n\n\t// WindowFlagsNoNav combines WindowFlagsNoNavInputs and WindowFlagsNoNavFocus.\n\tWindowFlagsNoNav WindowFlags = WindowFlags(imgui.WindowFlagsNoNav)\n\n\t// WindowFlagsNoDocking Disable docking of this window.\n\tWindowFlagsNoDocking WindowFlags = WindowFlags(imgui.WindowFlagsNoDocking)\n\n\t// WindowFlagsNoDecoration combines WindowFlagsNoTitleBar, WindowFlagsNoResize, WindowFlagsNoScrollbar and\n\t// WindowFlagsNoCollapse.\n\tWindowFlagsNoDecoration WindowFlags = WindowFlags(imgui.WindowFlagsNoDecoration)\n\t// WindowFlagsNoInputs combines WindowFlagsNoMouseInputs, WindowFlagsNoNavInputs and WindowFlagsNoNavFocus.\n\tWindowFlagsNoInputs WindowFlags = WindowFlags(imgui.WindowFlagsNoInputs)\n)\n\n// ComboFlags represents imgui.ComboFlags.\ntype ComboFlags imgui.ComboFlags\n\n// combo flags list.\nconst (\n\t// ComboFlagsNone default = 0.\n\tComboFlagsNone = ComboFlags(imgui.ComboFlagsNone)\n\t// ComboFlagsPopupAlignLeft aligns the popup toward the left by default.\n\tComboFlagsPopupAlignLeft = ComboFlags(imgui.ComboFlagsPopupAlignLeft)\n\t// ComboFlagsHeightSmall has maxValue ~4 items visible.\n\t// Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo().\n\tComboFlagsHeightSmall = ComboFlags(imgui.ComboFlagsHeightSmall)\n\t// ComboFlagsHeightRegular has maxValue ~8 items visible (default).\n\tComboFlagsHeightRegular = ComboFlags(imgui.ComboFlagsHeightRegular)\n\t// ComboFlagsHeightLarge has maxValue ~20 items visible.\n\tComboFlagsHeightLarge = ComboFlags(imgui.ComboFlagsHeightLarge)\n\t// ComboFlagsHeightLargest has as many fitting items as possible.\n\tComboFlagsHeightLargest = ComboFlags(imgui.ComboFlagsHeightLargest)\n\t// ComboFlagsNoArrowButton displays on the preview box without the square arrow button.\n\tComboFlagsNoArrowButton = ComboFlags(imgui.ComboFlagsNoArrowButton)\n\t// ComboFlagsNoPreview displays only a square arrow button.\n\tComboFlagsNoPreview = ComboFlags(imgui.ComboFlagsNoPreview)\n)\n\n// SelectableFlags represents imgui.SelectableFlags.\ntype SelectableFlags imgui.SelectableFlags\n\n// selectable flags list.\nconst (\n\t// SelectableFlagsNone default = 0.\n\tSelectableFlagsNone = SelectableFlags(imgui.SelectableFlagsNone)\n\t// SelectableFlagsDontClosePopups makes clicking the selectable not close any parent popup windows.\n\tSelectableFlagsDontClosePopups = SelectableFlags(imgui.SelectableFlagsNoAutoClosePopups)\n\t// SelectableFlagsSpanAllColumns allows the selectable frame to span all columns (text will still fit in current column).\n\tSelectableFlagsSpanAllColumns = SelectableFlags(imgui.SelectableFlagsSpanAllColumns)\n\t// SelectableFlagsAllowDoubleClick generates press events on double clicks too.\n\tSelectableFlagsAllowDoubleClick = SelectableFlags(imgui.SelectableFlagsAllowDoubleClick)\n\t// SelectableFlagsDisabled disallows selection and displays text in a greyed out color.\n\tSelectableFlagsDisabled = SelectableFlags(imgui.SelectableFlagsDisabled)\n)\n\n// TabItemFlags represents tab item flags.\ntype TabItemFlags imgui.TabItemFlags\n\n// tab item flags list.\nconst (\n\t// TabItemFlagsNone default = 0.\n\tTabItemFlagsNone = TabItemFlags(imgui.TabItemFlagsNone)\n\t// TabItemFlagsUnsavedDocument Append '*' to title without affecting the ID, as a convenience to avoid using the\n\t// ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it\n\t// without flicker.\n\tTabItemFlagsUnsavedDocument = TabItemFlags(imgui.TabItemFlagsUnsavedDocument)\n\t// TabItemFlagsSetSelected Trigger flag to programmatically make the tab selected when calling BeginTabItem().\n\tTabItemFlagsSetSelected = TabItemFlags(imgui.TabItemFlagsSetSelected)\n\t// TabItemFlagsNoCloseWithMiddleMouseButton  Disable behavior of closing tabs (that are submitted with\n\t// p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if\n\t// (IsItemHovered() && IsMouseClicked(2)) *p_open = false.\n\tTabItemFlagsNoCloseWithMiddleMouseButton = TabItemFlags(imgui.TabItemFlagsNoCloseWithMiddleMouseButton)\n\t// TabItemFlagsNoPushID Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem().\n\n)\n\n// TabBarFlags represents imgui.TabBarFlags.\ntype TabBarFlags imgui.TabBarFlags\n\n// tab bar flags list.\nconst (\n\t// TabBarFlagsNone default = 0.\n\tTabBarFlagsNone = TabBarFlags(imgui.TabBarFlagsNone)\n\t// TabBarFlagsReorderable Allow manually dragging tabs to re-order them + New tabs are appended at the end of list.\n\tTabBarFlagsReorderable = TabBarFlags(imgui.TabBarFlagsReorderable)\n\t// TabBarFlagsAutoSelectNewTabs Automatically select new tabs when they appear.\n\tTabBarFlagsAutoSelectNewTabs = TabBarFlags(imgui.TabBarFlagsAutoSelectNewTabs)\n\t// TabBarFlagsTabListPopupButton Disable buttons to open the tab list popup.\n\tTabBarFlagsTabListPopupButton = TabBarFlags(imgui.TabBarFlagsTabListPopupButton)\n\t// TabBarFlagsNoCloseWithMiddleMouseButton Disable behavior of closing tabs (that are submitted with p_open != NULL)\n\t// with middle mouse button. You can still repro this behavior on user's side with if\n\t// (IsItemHovered() && IsMouseClicked(2)) *p_open = false.\n\tTabBarFlagsNoCloseWithMiddleMouseButton = TabBarFlags(imgui.TabBarFlagsNoCloseWithMiddleMouseButton)\n\t// TabBarFlagsNoTabListScrollingButtons Disable scrolling buttons (apply when fitting policy is\n\t// TabBarFlagsFittingPolicyScroll).\n\tTabBarFlagsNoTabListScrollingButtons = TabBarFlags(imgui.TabBarFlagsNoTabListScrollingButtons)\n\t// TabBarFlagsNoTooltip Disable tooltips when hovering a tab.\n\tTabBarFlagsNoTooltip = TabBarFlags(imgui.TabBarFlagsNoTooltip)\n\t// TabBarFlagsFittingPolicyResizeDown Resize tabs when they don't fit.\n\tTabBarFlagsFittingPolicyResizeDown = TabBarFlags(imgui.TabBarFlagsFittingPolicyResizeDown)\n\t// TabBarFlagsFittingPolicyScroll Add scroll buttons when tabs don't fit.\n\tTabBarFlagsFittingPolicyScroll = TabBarFlags(imgui.TabBarFlagsFittingPolicyScroll)\n\t// TabBarFlagsFittingPolicyMask combines\n\t// TabBarFlagsFittingPolicyResizeDown and TabBarFlagsFittingPolicyScroll.\n\tTabBarFlagsFittingPolicyMask = TabBarFlags(imgui.TabBarFlagsFittingPolicyMask)\n\t// TabBarFlagsFittingPolicyDefault alias for TabBarFlagsFittingPolicyResizeDown.\n\tTabBarFlagsFittingPolicyDefault = TabBarFlags(imgui.TabBarFlagsFittingPolicyDefault)\n)\n\n// TreeNodeFlags represents tree node widget flags.\ntype TreeNodeFlags imgui.TreeNodeFlags\n\n// tree node flags list.\nconst (\n\t// TreeNodeFlagsNone default = 0.\n\tTreeNodeFlagsNone = TreeNodeFlags(imgui.TreeNodeFlagsNone)\n\t// TreeNodeFlagsSelected draws as selected.\n\tTreeNodeFlagsSelected = TreeNodeFlags(imgui.TreeNodeFlagsSelected)\n\t// TreeNodeFlagsFramed draws full colored frame (e.g. for CollapsingHeader).\n\tTreeNodeFlagsFramed = TreeNodeFlags(imgui.TreeNodeFlagsFramed)\n\t// TreeNodeFlagsAllowItemOverlap hit testing to allow subsequent widgets to overlap this one.\n\tTreeNodeFlagsAllowItemOverlap = TreeNodeFlags(imgui.TreeNodeFlagsAllowOverlap)\n\t// TreeNodeFlagsNoTreePushOnOpen doesn't do a TreePush() when open\n\t// (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack.\n\tTreeNodeFlagsNoTreePushOnOpen = TreeNodeFlags(imgui.TreeNodeFlagsNoTreePushOnOpen)\n\t// TreeNodeFlagsNoAutoOpenOnLog doesn't automatically and temporarily open node when Logging is active\n\t// (by default logging will automatically open tree nodes).\n\tTreeNodeFlagsNoAutoOpenOnLog = TreeNodeFlags(imgui.TreeNodeFlagsNoAutoOpenOnLog)\n\t// TreeNodeFlagsDefaultOpen defaults node to be open.\n\tTreeNodeFlagsDefaultOpen = TreeNodeFlags(imgui.TreeNodeFlagsDefaultOpen)\n\t// TreeNodeFlagsOpenOnDoubleClick needs double-click to open node.\n\tTreeNodeFlagsOpenOnDoubleClick = TreeNodeFlags(imgui.TreeNodeFlagsOpenOnDoubleClick)\n\t// TreeNodeFlagsOpenOnArrow opens only when clicking on the arrow part.\n\t// If TreeNodeFlagsOpenOnDoubleClick is also set, single-click arrow or double-click all box to open.\n\tTreeNodeFlagsOpenOnArrow = TreeNodeFlags(imgui.TreeNodeFlagsOpenOnArrow)\n\t// TreeNodeFlagsLeaf allows no collapsing, no arrow (use as a convenience for leaf nodes).\n\tTreeNodeFlagsLeaf = TreeNodeFlags(imgui.TreeNodeFlagsLeaf)\n\t// TreeNodeFlagsBullet displays a bullet instead of an arrow.\n\tTreeNodeFlagsBullet = TreeNodeFlags(imgui.TreeNodeFlagsBullet)\n\t// TreeNodeFlagsFramePadding uses FramePadding (even for an unframed text node) to\n\t// vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().\n\tTreeNodeFlagsFramePadding = TreeNodeFlags(imgui.TreeNodeFlagsFramePadding)\n\t// TreeNodeFlagsSpanAvailWidth extends hit box to the right-most edge, even if not framed.\n\t// This is not the default in order to allow adding other items on the same line.\n\t// In the future we may refactor the hit system to be front-to-back, allowing natural overlaps\n\t// and then this can become the default.\n\tTreeNodeFlagsSpanAvailWidth = TreeNodeFlags(imgui.TreeNodeFlagsSpanAvailWidth)\n\t// TreeNodeFlagsSpanFullWidth extends hit box to the left-most and right-most edges (bypass the indented area).\n\tTreeNodeFlagsSpanFullWidth = TreeNodeFlags(imgui.TreeNodeFlagsSpanFullWidth)\n\t// TreeNodeFlagsNavLeftJumpsBackHere (WIP) Nav: left direction may move to this TreeNode() from any of its child\n\t// (items submitted between TreeNode and TreePop).\n\tTreeNodeFlagsNavLeftJumpsBackHere = TreeNodeFlags(imgui.TreeNodeFlagsNavLeftJumpsBackHere)\n\t// TreeNodeFlagsCollapsingHeader combines TreeNodeFlagsFramed and TreeNodeFlagsNoAutoOpenOnLog.\n\tTreeNodeFlagsCollapsingHeader = TreeNodeFlags(imgui.TreeNodeFlagsCollapsingHeader)\n)\n\n// FocusedFlags represents imgui.FocusedFlags.\ntype FocusedFlags imgui.FocusedFlags\n\n// focused flags list.\nconst (\n\tFocusedFlagsNone             = (imgui.FocusedFlagsNone)\n\tFocusedFlagsChildWindows     = (imgui.FocusedFlagsChildWindows)   // Return true if any children of the window is focused\n\tFocusedFlagsRootWindow       = (imgui.FocusedFlagsRootWindow)     // Test from root window (top most parent of the current hierarchy)\n\tFocusedFlagsAnyWindow        = (imgui.FocusedFlagsAnyWindow)      // Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs do NOT use this. Use 'io.WantCaptureMouse' instead! Please read the FAQ!\n\tFocusedFlagsNoPopupHierarchy = imgui.FocusedFlagsNoPopupHierarchy // Do not consider popup hierarchy (do not treat popup emitter as parent of popup) (when used with ChildWindows or RootWindow)\n\t// FocusedFlagsDockHierarchy               = 1 << 4   // Consider docking hierarchy (treat dockspace host as parent of docked window) (when used with ChildWindows or RootWindow).\n\tFocusedFlagsRootAndChildWindows = imgui.FocusedFlagsRootAndChildWindows\n)\n\n// HoveredFlags represents a hovered flags.\ntype HoveredFlags imgui.HoveredFlags\n\n// hovered flags list.\nconst (\n\t// HoveredFlagsNone Return true if directly over the item/window, not obstructed by another window,\n\t// not obstructed by an active popup or modal blocking inputs under them.\n\tHoveredFlagsNone = HoveredFlags(imgui.HoveredFlagsNone)\n\t// HoveredFlagsChildWindows IsWindowHovered() only: Return true if any children of the window is hovered.\n\tHoveredFlagsChildWindows = HoveredFlags(imgui.HoveredFlagsChildWindows)\n\t// HoveredFlagsRootWindow IsWindowHovered() only: Test from root window (top most parent of the current hierarchy).\n\tHoveredFlagsRootWindow = HoveredFlags(imgui.HoveredFlagsRootWindow)\n\t// HoveredFlagsAnyWindow IsWindowHovered() only: Return true if any window is hovered.\n\tHoveredFlagsAnyWindow = HoveredFlags(imgui.HoveredFlagsAnyWindow)\n\t// HoveredFlagsAllowWhenBlockedByPopup Return true even if a popup window is normally blocking access to this item/window.\n\tHoveredFlagsAllowWhenBlockedByPopup = HoveredFlags(imgui.HoveredFlagsAllowWhenBlockedByPopup)\n\t// HoveredFlagsAllowWhenBlockedByActiveItem Return true even if an active item is blocking access to this item/window.\n\t// Useful for Drag and Drop patterns.\n\tHoveredFlagsAllowWhenBlockedByActiveItem = HoveredFlags(imgui.HoveredFlagsAllowWhenBlockedByActiveItem)\n\t// HoveredFlagsAllowWhenOverlapped Return true even if the position is overlapped by another window.\n\tHoveredFlagsAllowWhenOverlapped = HoveredFlags(imgui.HoveredFlagsAllowWhenOverlapped)\n\t// HoveredFlagsAllowWhenDisabled Return true even if the item is disabled.\n\tHoveredFlagsAllowWhenDisabled = HoveredFlags(imgui.HoveredFlagsAllowWhenDisabled)\n)\n\n// ColorEditFlags for ColorEdit3V(), etc.\ntype ColorEditFlags int\n\n// list of color edit flags.\nconst (\n\tColorEditFlagsNone ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNone)\n\t//              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).\n\tColorEditFlagsNoAlpha ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoAlpha)\n\t//              // ColorEdit: disable picker when clicking on color square.\n\tColorEditFlagsNoPicker ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoPicker)\n\t//              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.\n\tColorEditFlagsNoOptions ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoOptions)\n\t//              // ColorEdit, ColorPicker: disable color square preview next to the inputs. (e.g. to show only the inputs)\n\tColorEditFlagsNoSmallPreview ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoSmallPreview)\n\t//              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview color square).\n\tColorEditFlagsNoInputs ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoInputs)\n\t//              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.\n\tColorEditFlagsNoTooltip ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoTooltip)\n\t//              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).\n\tColorEditFlagsNoLabel ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoLabel)\n\t//              // ColorPicker: disable bigger color preview on right side of the picker, use small color square preview instead.\n\tColorEditFlagsNoSidePreview ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoSidePreview)\n\t//              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.\n\tColorEditFlagsNoDragDrop ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoDragDrop)\n\t//              // ColorButton: disable border (which is enforced by default)\n\tColorEditFlagsNoBorder ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsNoBorder)\n\t//              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.\n\tColorEditFlagsAlphaBar ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsAlphaBar)\n\t//              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.\n\tColorEditFlagsAlphaPreview ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsAlphaPreview)\n\t//              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.\n\tColorEditFlagsAlphaPreviewHalf ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsAlphaPreviewHalf)\n\t//              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).\n\tColorEditFlagsHDR ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsHDR)\n\t// [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.\n\tColorEditFlagsDisplayRGB ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsDisplayRGB)\n\t// [Display]    // \".\n\tColorEditFlagsDisplayHSV ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsDisplayHSV)\n\t// [Display]    // \".\n\tColorEditFlagsDisplayHex ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsDisplayHex)\n\t// [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.\n\tColorEditFlagsUint8 ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsUint8)\n\t// [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.\n\tColorEditFlagsFloat ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsFloat)\n\t// [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.\n\tColorEditFlagsPickerHueBar ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsPickerHueBar)\n\t// [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.\n\tColorEditFlagsPickerHueWheel ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsPickerHueWheel)\n\t// [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.\n\tColorEditFlagsInputRGB ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsInputRGB)\n\t// [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.\n\tColorEditFlagsInputHSV       ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsInputHSV)\n\tColorEditFlagsDefaultOptions ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsDefaultOptions)\n\tColorEditFlagsDisplayMask    ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsDisplayMask)\n\tColorEditFlagsDataTypeMask   ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsDataTypeMask)\n\tColorEditFlagsPickerMask     ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsPickerMask)\n\tColorEditFlagsInputMask      ColorEditFlags = ColorEditFlags(imgui.ColorEditFlagsInputMask)\n)\n\n// TableFlags represents table flags.\ntype TableFlags imgui.TableFlags\n\n// Table flags enum:.\nconst (\n\tTableFlagsNone                       TableFlags = TableFlags(imgui.TableFlagsNone)\n\tTableFlagsResizable                  TableFlags = TableFlags(imgui.TableFlagsResizable)\n\tTableFlagsReorderable                TableFlags = TableFlags(imgui.TableFlagsReorderable)\n\tTableFlagsHideable                   TableFlags = TableFlags(imgui.TableFlagsHideable)\n\tTableFlagsSortable                   TableFlags = TableFlags(imgui.TableFlagsSortable)\n\tTableFlagsNoSavedSettings            TableFlags = TableFlags(imgui.TableFlagsNoSavedSettings)\n\tTableFlagsContextMenuInBody          TableFlags = TableFlags(imgui.TableFlagsContextMenuInBody)\n\tTableFlagsRowBg                      TableFlags = TableFlags(imgui.TableFlagsRowBg)\n\tTableFlagsBordersInnerH              TableFlags = TableFlags(imgui.TableFlagsBordersInnerH)\n\tTableFlagsBordersOuterH              TableFlags = TableFlags(imgui.TableFlagsBordersOuterH)\n\tTableFlagsBordersInnerV              TableFlags = TableFlags(imgui.TableFlagsBordersInnerV)\n\tTableFlagsBordersOuterV              TableFlags = TableFlags(imgui.TableFlagsBordersOuterV)\n\tTableFlagsBordersH                   TableFlags = TableFlags(imgui.TableFlagsBordersH)\n\tTableFlagsBordersV                   TableFlags = TableFlags(imgui.TableFlagsBordersV)\n\tTableFlagsBordersInner               TableFlags = TableFlags(imgui.TableFlagsBordersInner)\n\tTableFlagsBordersOuter               TableFlags = TableFlags(imgui.TableFlagsBordersOuter)\n\tTableFlagsBorders                    TableFlags = TableFlags(imgui.TableFlagsBorders)\n\tTableFlagsNoBordersInBody            TableFlags = TableFlags(imgui.TableFlagsNoBordersInBody)\n\tTableFlagsNoBordersInBodyUntilResize TableFlags = TableFlags(imgui.TableFlagsNoBordersInBodyUntilResize)\n\tTableFlagsSizingFixedFit             TableFlags = TableFlags(imgui.TableFlagsSizingFixedFit)\n\tTableFlagsSizingFixedSame            TableFlags = TableFlags(imgui.TableFlagsSizingFixedSame)\n\tTableFlagsSizingStretchProp          TableFlags = TableFlags(imgui.TableFlagsSizingStretchProp)\n\tTableFlagsSizingStretchSame          TableFlags = TableFlags(imgui.TableFlagsSizingStretchSame)\n\tTableFlagsNoHostExtendX              TableFlags = TableFlags(imgui.TableFlagsNoHostExtendX)\n\tTableFlagsNoHostExtendY              TableFlags = TableFlags(imgui.TableFlagsNoHostExtendY)\n\tTableFlagsNoKeepColumnsVisible       TableFlags = TableFlags(imgui.TableFlagsNoKeepColumnsVisible)\n\tTableFlagsPreciseWidths              TableFlags = TableFlags(imgui.TableFlagsPreciseWidths)\n\tTableFlagsNoClip                     TableFlags = TableFlags(imgui.TableFlagsNoClip)\n\tTableFlagsPadOuterX                  TableFlags = TableFlags(imgui.TableFlagsPadOuterX)\n\tTableFlagsNoPadOuterX                TableFlags = TableFlags(imgui.TableFlagsNoPadOuterX)\n\tTableFlagsNoPadInnerX                TableFlags = TableFlags(imgui.TableFlagsNoPadInnerX)\n\tTableFlagsScrollX                    TableFlags = TableFlags(imgui.TableFlagsScrollX)\n\tTableFlagsScrollY                    TableFlags = TableFlags(imgui.TableFlagsScrollY)\n\tTableFlagsSortMulti                  TableFlags = TableFlags(imgui.TableFlagsSortMulti)\n\tTableFlagsSortTristate               TableFlags = TableFlags(imgui.TableFlagsSortTristate)\n\tTableFlagsSizingMask                 TableFlags = TableFlags(imgui.TableFlagsSizingMask)\n)\n\n// TableRowFlags represents table row flags.\ntype TableRowFlags imgui.TableRowFlags\n\n// table row flags:.\nconst (\n\tTableRowFlagsNone TableRowFlags = TableRowFlags(imgui.TableRowFlagsNone)\n\t// Identify header row (set default background color + width of its contents accounted different for auto column width).\n\tTableRowFlagsHeaders TableRowFlags = TableRowFlags(imgui.TableRowFlagsHeaders)\n)\n\n// TableColumnFlags represents a flags for table column (see (*TableColumnWidget).Flags()).\ntype TableColumnFlags imgui.TableColumnFlags\n\n// table column flags list.\nconst (\n\t// Input configuration flags.\n\tTableColumnFlagsNone                 TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNone)\n\tTableColumnFlagsDefaultHide          TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsDefaultHide)\n\tTableColumnFlagsDefaultSort          TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsDefaultSort)\n\tTableColumnFlagsWidthStretch         TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsWidthStretch)\n\tTableColumnFlagsWidthFixed           TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsWidthFixed)\n\tTableColumnFlagsNoResize             TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNoResize)\n\tTableColumnFlagsNoReorder            TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNoReorder)\n\tTableColumnFlagsNoHide               TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNoHide)\n\tTableColumnFlagsNoClip               TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNoClip)\n\tTableColumnFlagsNoSort               TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNoSort)\n\tTableColumnFlagsNoSortAscending      TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNoSortAscending)\n\tTableColumnFlagsNoSortDescending     TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNoSortDescending)\n\tTableColumnFlagsNoHeaderWidth        TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNoHeaderWidth)\n\tTableColumnFlagsPreferSortAscending  TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsPreferSortAscending)\n\tTableColumnFlagsPreferSortDescending TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsPreferSortDescending)\n\tTableColumnFlagsIndentEnable         TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsIndentEnable)\n\tTableColumnFlagsIndentDisable        TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsIndentDisable)\n\n\t// Output status flags read-only via TableGetColumnFlags().\n\tTableColumnFlagsIsEnabled TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsIsEnabled)\n\tTableColumnFlagsIsVisible TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsIsVisible)\n\tTableColumnFlagsIsSorted  TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsIsSorted)\n\tTableColumnFlagsIsHovered TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsIsHovered)\n\n\t// [Internal] Combinations and masks.\n\tTableColumnFlagsWidthMask      TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsWidthMask)\n\tTableColumnFlagsIndentMask     TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsIndentMask)\n\tTableColumnFlagsStatusMask     TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsStatusMask)\n\tTableColumnFlagsNoDirectResize TableColumnFlags = TableColumnFlags(imgui.TableColumnFlagsNoDirectResize)\n)\n\n// SliderFlags represents imgui.SliderFlags.\ntype SliderFlags imgui.SliderFlags\n\n// slider flags.\nconst (\n\tSliderFlagsNone = SliderFlags(imgui.SliderFlagsNone)\n\t// Clamp value to minValue/maxValue bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.\n\tSliderFlagsAlwaysClamp = SliderFlags(imgui.SliderFlagsAlwaysClamp)\n\t// Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlagsNoRoundToFormat = SliderFlags(imgui.SliderFlagsNoRoundToFormat)\n\t// a format-string with small amount of digits.\n\tSliderFlagsLogarithmic = SliderFlags(imgui.SliderFlagsLogarithmic)\n\t// Disable rounding underlying value to match precision of the display format string (e.g. %.3f values are rounded to those 3 digits).\n\tSliderFlagsNoRoundToFormat = SliderFlags(imgui.SliderFlagsNoRoundToFormat)\n\t// Disable CTRL+Click or Enter key allowing to input text directly into the widget.\n\tSliderFlagsNoInput = SliderFlags(imgui.SliderFlagsNoInput)\n\t// [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast\n\t// to this enum, and will trigger an assert if needed.\n\tSliderFlagsInvalidMask = SliderFlags(imgui.SliderFlagsInvalidMask)\n)\n\n// PlotFlags represents implot.Flags.\ntype PlotFlags implot.Flags\n\n// plot flags.\nconst (\n\tPlotFlagsNone        = PlotFlags(implot.FlagsNone)\n\tPlotFlagsNoTitle     = PlotFlags(implot.FlagsNoTitle)\n\tPlotFlagsNoLegend    = PlotFlags(implot.FlagsNoLegend)\n\tPlotFlagsNoMenus     = PlotFlags(implot.FlagsNoMenus)\n\tPlotFlagsNoBoxSelect = PlotFlags(implot.FlagsNoBoxSelect)\n\t// \tPlotFlagsNoMousePos  = PlotFlags(implot.FlagsNoMousePos)\n\t// \tPlotFlagsNoHighlight = PlotFlags(implot.FlagsNoHighlight)\n\t// PlotFlagsNoChild = PlotFlags(implot.FlagsNoChild).\n\tPlotFlagsEqual = PlotFlags(implot.FlagsEqual)\n\t// \tPlotFlagsYAxis2      = PlotFlags(implot.FlagsYAxis2)\n\t// \tPlotFlagsYAxis3      = PlotFlags(implot.FlagsYAxis3)\n\t// \tPlotFlagsQuery       = PlotFlags(implot.FlagsQuery)\n\tPlotFlagsCrosshairs = PlotFlags(implot.FlagsCrosshairs)\n\t// \tPlotFlagsAntiAliased = PlotFlags(implot.FlagsAntiAliased)\n\tPlotFlagsCanvasOnly = PlotFlags(implot.FlagsCanvasOnly)\n)\n\n// PlotAxisFlags represents implot.AxisFlags.\ntype PlotAxisFlags implot.AxisFlags\n\n// plot axis flags.\nconst (\n\tPlotAxisFlagsNone         PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsNone)\n\tPlotAxisFlagsNoLabel      PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsNoLabel)\n\tPlotAxisFlagsNoGridLines  PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsNoGridLines)\n\tPlotAxisFlagsNoTickMarks  PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsNoTickMarks)\n\tPlotAxisFlagsNoTickLabels PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsNoTickLabels)\n\tPlotAxisFlagsForeground   PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsForeground)\n\t//\tPlotAxisFlagsLogScale      PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsLogScale)\n\t//\tPlotAxisFlagsTime          PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsTime)\n\tPlotAxisFlagsInvert        PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsInvert)\n\tPlotAxisFlagsNoInitialFit  PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsNoInitialFit)\n\tPlotAxisFlagsAutoFit       PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsAutoFit)\n\tPlotAxisFlagsRangeFit      PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsRangeFit)\n\tPlotAxisFlagsLockMin       PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsLockMin)\n\tPlotAxisFlagsLockMax       PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsLockMax)\n\tPlotAxisFlagsLock          PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsLock)\n\tPlotAxisFlagsNoDecorations PlotAxisFlags = PlotAxisFlags(implot.AxisFlagsNoDecorations)\n)\n"
        },
        {
          "name": "FontAtlasProsessor.go",
          "type": "blob",
          "size": 8.9912109375,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"unsafe\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/AllenDang/cimgui-go/utils\"\n\t\"github.com/AllenDang/go-findfont\"\n)\n\nconst (\n\tpreRegisterString = \" \\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n\twindows           = \"windows\"\n\tdefaultFontSize   = 14\n)\n\n// FontInfo represents a giu implementation of imgui font.\ntype FontInfo struct {\n\tfontName string\n\tfontPath string\n\tfontByte []byte\n\tsize     float32\n}\n\n// String returns a string representation of the FontInfo. It is intended to be unique for each FontInfo.\nfunc (f *FontInfo) String() string {\n\treturn fmt.Sprintf(\"%s:%.2f\", f.fontName, f.size)\n}\n\n// SetSize sets the font size.\nfunc (f *FontInfo) SetSize(size float32) *FontInfo {\n\tresult := *f\n\tresult.size = size\n\n\tfor _, i := range Context.FontAtlas.extraFonts {\n\t\tif i.String() == result.String() {\n\t\t\treturn &result\n\t\t}\n\t}\n\n\tContext.FontAtlas.extraFonts = append(Context.FontAtlas.extraFonts, result)\n\tContext.FontAtlas.shouldRebuildFontAtlas = true\n\n\treturn &result\n}\n\n// FontAtlas is a mechanism to automatically manage fonts in giu.\n// When you add a string in your app, it is registered inside the FontAtlas.\n// Then, font data are built based on the registered strings.\n// for more details, see: https://github.com/ocornut/imgui/blob/master/docs/FONTS.md\n// DefaultFont = font that is used for normal rendering.\n// ExtraFont = font that can be set and then it'll be used for rendering things.\ntype FontAtlas struct {\n\tshouldRebuildFontAtlas bool\n\tstringMap              sync.Map // key is rune, value indicates whether it's a new rune.\n\tdefaultFonts           []FontInfo\n\textraFonts             []FontInfo\n\textraFontMap           map[string]*imgui.Font\n\tfontSize               float32\n}\n\nfunc newFontAtlas() *FontAtlas {\n\tresult := FontAtlas{\n\t\textraFontMap: make(map[string]*imgui.Font),\n\t\tfontSize:     defaultFontSize,\n\t}\n\n\t// Pre register numbers\n\tresult.RegisterString(preRegisterString)\n\n\t// Pre-register fonts\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\t// English font\n\t\tresult.registerDefaultFont(\"Menlo\", result.fontSize)\n\t\t// Chinese font\n\t\tresult.registerDefaultFont(\"STHeiti\", result.fontSize-1)\n\t\t// Jananese font\n\t\tresult.registerDefaultFont(\"ヒラギノ角ゴシック W0\", result.fontSize+3)\n\t\t// Korean font\n\t\tresult.registerDefaultFont(\"AppleSDGothicNeo\", result.fontSize+2)\n\tcase windows:\n\t\t// English font\n\t\tresult.registerDefaultFont(\"Calibri\", result.fontSize+2)\n\t\t// Chinese font\n\t\tresult.registerDefaultFont(\"MSYH\", result.fontSize+2)\n\t\t// Japanese font\n\t\tresult.registerDefaultFont(\"MSGOTHIC\", result.fontSize+2)\n\t\t// Korean font\n\t\tresult.registerDefaultFont(\"MALGUNSL\", result.fontSize+2)\n\tcase \"linux\":\n\t\t// English fonts\n\t\tresult.registerDefaultFonts([]FontInfo{\n\t\t\t{\n\t\t\t\tfontName: \"FreeSans.ttf\",\n\t\t\t\tsize:     result.fontSize + 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tfontName: \"FiraCode-Medium\",\n\t\t\t\tsize:     result.fontSize + 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tfontName: \"sans\",\n\t\t\t\tsize:     result.fontSize + 1,\n\t\t\t},\n\t\t})\n\t\t// Chinese fonts\n\t\tresult.registerDefaultFonts([]FontInfo{\n\t\t\t{\n\t\t\t\tfontName: \"wqy-microhei\",\n\t\t\t\tsize:     result.fontSize + 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tfontName: \"SourceHanSansCN\",\n\t\t\t\tsize:     result.fontSize + 3,\n\t\t\t},\n\t\t})\n\t}\n\n\treturn &result\n}\n\n// SetDefaultFontSize sets the default font size. Invoke this before MasterWindow.NewMasterWindow(..).\nfunc (a *FontAtlas) SetDefaultFontSize(size float32) {\n\ta.fontSize = size\n}\n\n// SetDefaultFont changes default font.\nfunc (a *FontAtlas) SetDefaultFont(fontName string, size float32) {\n\tfontPath, err := findfont.Find(fontName)\n\tif err != nil {\n\t\tlog.Fatalf(\"Cannot find font %s\", fontName)\n\t\treturn\n\t}\n\n\tfontInfo := FontInfo{fontName: fontName, fontPath: fontPath, size: size}\n\ta.defaultFonts = append([]FontInfo{fontInfo}, a.defaultFonts...)\n}\n\n// SetDefaultFontFromBytes changes default font by bytes of the font file.\nfunc (a *FontAtlas) SetDefaultFontFromBytes(fontBytes []byte, size float32) {\n\ta.defaultFonts = append([]FontInfo{\n\t\t{\n\t\t\tfontByte: fontBytes,\n\t\t\tsize:     size,\n\t\t},\n\t}, a.defaultFonts...)\n}\n\n// GetDefaultFonts returns a list of currently loaded default fonts.\nfunc (a *FontAtlas) GetDefaultFonts() []FontInfo {\n\treturn a.defaultFonts\n}\n\n// AddFont adds font by name, if the font is found, return *FontInfo, otherwise return nil.\n// To use added font, use giu.Style().SetFont(...).\nfunc (a *FontAtlas) AddFont(fontName string, size float32) *FontInfo {\n\tfontPath, err := findfont.Find(fontName)\n\tif err != nil {\n\t\tfmt.Printf(\"[Warning]Cannot find font %s at system, related text will not be rendered.\\n\", fontName)\n\t\treturn nil\n\t}\n\n\tfi := FontInfo{\n\t\tfontName: fontName,\n\t\tfontPath: fontPath,\n\t\tsize:     size,\n\t}\n\n\ta.extraFonts = append(a.extraFonts, fi)\n\n\treturn &fi\n}\n\n// AddFontFromBytes does similar to AddFont, but using data from memory.\nfunc (a *FontAtlas) AddFontFromBytes(fontName string, fontBytes []byte, size float32) *FontInfo {\n\tfi := FontInfo{\n\t\tfontName: fontName,\n\t\tfontByte: fontBytes,\n\t\tsize:     size,\n\t}\n\n\ta.extraFonts = append(a.extraFonts, fi)\n\n\treturn &fi\n}\n\nfunc (a *FontAtlas) registerDefaultFont(fontName string, size float32) {\n\tfontPath, err := findfont.Find(fontName)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfontInfo := FontInfo{fontName: fontName, fontPath: fontPath, size: size}\n\ta.defaultFonts = append(a.defaultFonts, fontInfo)\n}\n\nfunc (a *FontAtlas) registerDefaultFonts(fontInfos []FontInfo) {\n\tvar firstFoundFont *FontInfo\n\n\tfor _, fi := range fontInfos {\n\t\tfontPath, err := findfont.Find(fi.fontName)\n\t\tif err == nil {\n\t\t\tfirstFoundFont = &FontInfo{fontName: fi.fontName, fontPath: fontPath, size: fi.size}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif firstFoundFont != nil {\n\t\ta.defaultFonts = append(a.defaultFonts, *firstFoundFont)\n\t}\n}\n\n// RegisterString register string to font atlas builder.\n// Note only register strings that will be displayed on the UI.\nfunc (a *FontAtlas) RegisterString(str string) string {\n\tfor _, s := range str {\n\t\tif _, ok := a.stringMap.Load(s); !ok {\n\t\t\ta.stringMap.Store(s, false)\n\t\t\ta.shouldRebuildFontAtlas = true\n\t\t}\n\t}\n\n\treturn str\n}\n\n// RegisterStringPointer registers string pointer to font atlas builder.\n// Note only register strings that will be displayed on the UI.\nfunc (a *FontAtlas) RegisterStringPointer(str *string) *string {\n\ta.RegisterString(*str)\n\treturn str\n}\n\n// RegisterStringSlice calls RegisterString for each slice element.\nfunc (a *FontAtlas) RegisterStringSlice(str []string) []string {\n\tfor _, s := range str {\n\t\ta.RegisterString(s)\n\t}\n\n\treturn str\n}\n\n// Rebuild font atlas when necessary.\n// The whole magic happens here.\nfunc (a *FontAtlas) rebuildFontAtlas() {\n\tif !a.shouldRebuildFontAtlas {\n\t\treturn\n\t}\n\n\tfonts := Context.IO().Fonts()\n\tfonts.Clear()\n\n\tvar sb strings.Builder\n\n\ta.stringMap.Range(func(k, _ any) bool {\n\t\ta.stringMap.Store(k, true)\n\n\t\tif ks, ok := k.(rune); ok {\n\t\t\tsb.WriteRune(ks)\n\t\t}\n\n\t\treturn true\n\t})\n\n\tranges := imgui.NewGlyphRange()\n\tbuilder := imgui.NewFontGlyphRangesBuilder()\n\n\t// Because we pre-registered numbers, so default string map's length should greater then 11.\n\tif sb.Len() > len(preRegisterString) {\n\t\tbuilder.AddText(sb.String())\n\t} else {\n\t\tbuilder.AddRanges(fonts.GlyphRangesDefault())\n\t}\n\n\tbuilder.BuildRanges(ranges)\n\n\tif len(a.defaultFonts) > 0 {\n\t\tfontConfig := imgui.NewFontConfig()\n\t\tfontConfig.SetOversampleH(2)\n\t\tfontConfig.SetOversampleV(2)\n\t\tfontConfig.SetRasterizerMultiply(1.5)\n\n\t\tfor i, fontInfo := range a.defaultFonts {\n\t\t\tif i > 0 {\n\t\t\t\tfontConfig.SetMergeMode(true)\n\t\t\t}\n\n\t\t\t// Scale font size with DPI scale factor\n\t\t\tif runtime.GOOS == windows {\n\t\t\t\txScale, _ := Context.backend.ContentScale()\n\t\t\t\tfontInfo.size *= xScale\n\t\t\t}\n\n\t\t\tif len(fontInfo.fontByte) == 0 {\n\t\t\t\tfonts.AddFontFromFileTTFV(fontInfo.fontPath, fontInfo.size, fontConfig, ranges.Data())\n\t\t\t} else {\n\t\t\t\tfontConfig.SetFontDataOwnedByAtlas(false)\n\t\t\t\tfonts.AddFontFromMemoryTTFV(\n\t\t\t\t\tuintptr(unsafe.Pointer(utils.SliceToPtr(fontInfo.fontByte))),\n\t\t\t\t\tint32(len(fontInfo.fontByte)),\n\t\t\t\t\tfontInfo.size,\n\t\t\t\t\tfontConfig,\n\t\t\t\t\tranges.Data(),\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\t// Fall back if no font is added\n\t\tif fonts.FontCount() == 0 {\n\t\t\tfonts.AddFontDefault()\n\t\t}\n\t} else {\n\t\tfonts.AddFontDefault()\n\t}\n\n\t// Add extra fonts\n\tfor _, fontInfo := range a.extraFonts {\n\t\t// Scale font size with DPI scale factor\n\t\tif runtime.GOOS == windows {\n\t\t\txScale, _ := Context.backend.ContentScale()\n\t\t\tfontInfo.size *= xScale\n\t\t}\n\n\t\t// Store imgui.Font for PushFont\n\t\tvar f *imgui.Font\n\t\tif len(fontInfo.fontByte) == 0 {\n\t\t\tf = fonts.AddFontFromFileTTFV(\n\t\t\t\tfontInfo.fontPath,\n\t\t\t\tfontInfo.size,\n\t\t\t\timgui.NewFontConfig(),\n\t\t\t\tranges.Data(),\n\t\t\t)\n\t\t} else {\n\t\t\tfontConfig := imgui.NewFontConfig()\n\t\t\tfontConfig.SetFontDataOwnedByAtlas(false)\n\t\t\tf = fonts.AddFontFromMemoryTTFV(\n\t\t\t\tuintptr(unsafe.Pointer(utils.SliceToPtr(fontInfo.fontByte))),\n\t\t\t\tint32(len(fontInfo.fontByte)),\n\t\t\t\tfontInfo.size,\n\t\t\t\tfontConfig,\n\t\t\t\tranges.Data(),\n\t\t\t)\n\t\t}\n\n\t\ta.extraFontMap[fontInfo.String()] = f\n\t}\n\n\tfontTextureImg, w, h, _ := fonts.GetTextureDataAsRGBA32()\n\ttex := Context.backend.CreateTexture(fontTextureImg, int(w), int(h))\n\tfonts.SetTexID(tex)\n\tfonts.SetTexReady(true)\n\n\ta.shouldRebuildFontAtlas = false\n}\n"
        },
        {
          "name": "Gizmo.go",
          "type": "blob",
          "size": 13.1513671875,
          "content": "package giu\n\nimport (\n\t\"image/color\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/AllenDang/cimgui-go/imguizmo\"\n\t\"github.com/AllenDang/cimgui-go/utils\"\n\tglm \"github.com/gucio321/glm-go\"\n)\n\n// GizmoOperation specifies the operation of Gizmo (used by manipulate).\ntype GizmoOperation int\n\n// Possible Operations.\nconst (\n\tOperationTranslateX GizmoOperation = GizmoOperation(imguizmo.TRANSLATEX)\n\tOperationTranslateY GizmoOperation = GizmoOperation(imguizmo.TRANSLATEY)\n\tOperationTranslateZ GizmoOperation = GizmoOperation(imguizmo.TRANSLATEZ)\n\tOperationTranslate  GizmoOperation = GizmoOperation(imguizmo.TRANSLATE)\n\n\tOperationRotateX GizmoOperation = GizmoOperation(imguizmo.ROTATEX)\n\tOperationRotateY GizmoOperation = GizmoOperation(imguizmo.ROTATEY)\n\tOperationRotateZ GizmoOperation = GizmoOperation(imguizmo.ROTATEZ)\n\tOperationRotate  GizmoOperation = GizmoOperation(imguizmo.ROTATE)\n\n\tOperationScaleX GizmoOperation = GizmoOperation(imguizmo.SCALEX)\n\tOperationScaleY GizmoOperation = GizmoOperation(imguizmo.SCALEY)\n\tOperationScaleZ GizmoOperation = GizmoOperation(imguizmo.SCALEZ)\n\tOperationScale  GizmoOperation = GizmoOperation(imguizmo.SCALE)\n\n\tOperationScaleXU GizmoOperation = GizmoOperation(imguizmo.SCALEXU)\n\tOperationScaleYU GizmoOperation = GizmoOperation(imguizmo.SCALEYU)\n\tOperationScaleZU GizmoOperation = GizmoOperation(imguizmo.SCALEZU)\n\tOperationScaleU  GizmoOperation = GizmoOperation(imguizmo.SCALEU)\n\n\tOperationBounds GizmoOperation = GizmoOperation(imguizmo.BOUNDS)\n\n\tOperationRotateScreen GizmoOperation = GizmoOperation(imguizmo.ROTATESCREEN)\n\n\tOperationUniversal GizmoOperation = GizmoOperation(imguizmo.UNIVERSAL)\n)\n\n// GizmoMode specifies the mode of Gizmo (used by manipulate).\ntype GizmoMode int\n\n// values are not explained in source code.\nconst (\n\tModeLocal GizmoMode = GizmoMode(imguizmo.LOCAL)\n\tModeWorld GizmoMode = GizmoMode(imguizmo.WORLD)\n)\n\n// GizmoI should be implemented by every sub-element of GizmoWidget.\ntype GizmoI interface {\n\tGizmo(view *ViewMatrix, projection *ProjectionMatrix)\n}\n\nvar _ Widget = &GizmoWidget{}\n\n// GizmoWidget implements ImGuizmo features.\n// It is designed just like PlotWidget.\n// This structure provides an \"area\" where you can put Gizmos (see (*GizmoWidget).Gizmos).\n// If you want to have more understanding about what is going on here, read this:\n// https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/ (DISCLAIMER: giu authors are not responsible if you go mad or something!)\ntype GizmoWidget struct {\n\tgizmos       []GizmoI\n\tview         *ViewMatrix\n\tprojection   *ProjectionMatrix\n\tid           ID\n\tdisabled     bool\n\torthographic bool\n}\n\n// Gizmo creates a new GizmoWidget.\nfunc Gizmo(view *ViewMatrix, projection *ProjectionMatrix) *GizmoWidget {\n\treturn &GizmoWidget{\n\t\tgizmos:       []GizmoI{},\n\t\tview:         view,\n\t\tprojection:   projection,\n\t\tid:           GenAutoID(\"gizmo\"),\n\t\tdisabled:     false,\n\t\torthographic: false,\n\t}\n}\n\n// ID sets the ID of the GizmoWidget. (useful if you use multiple gizmo widgets. It is set by AutoID anyway).\nfunc (g *GizmoWidget) ID(id ID) *GizmoWidget {\n\tg.id = id\n\treturn g\n}\n\n// Disabled sets GizmoWidget's disabled state.\nfunc (g *GizmoWidget) Disabled(b bool) *GizmoWidget {\n\tg.disabled = b\n\treturn g\n}\n\n// Orthographic sets the projection matrix to orthographic.\nfunc (g *GizmoWidget) Orthographic(b bool) *GizmoWidget {\n\tg.orthographic = b\n\treturn g\n}\n\n// Gizmos adds GizmoI elements to the GizmoWidget area.\nfunc (g *GizmoWidget) Gizmos(gizmos ...GizmoI) *GizmoWidget {\n\tg.gizmos = append(g.gizmos, gizmos...)\n\treturn g\n}\n\n// build is a local build function.\n// Just to separate Global() and Build() methods.\nfunc (g *GizmoWidget) build() {\n\timguizmo.PushIDStr(string(g.id))\n\timguizmo.Enable(!g.disabled)\n\timguizmo.SetOrthographic(g.orthographic)\n\n\tfor _, gizmo := range g.gizmos {\n\t\tgizmo.Gizmo(g.view, g.projection)\n\t}\n\n\timguizmo.PopID()\n}\n\n// Build implements Widget interface.\nfunc (g *GizmoWidget) Build() {\n\timguizmo.SetDrawlist()\n\n\tdisplaySize := imgui.ContentRegionAvail()\n\tpos0 := imgui.CursorScreenPos()\n\n\timguizmo.SetRect(pos0.X, pos0.Y, displaySize.X, displaySize.Y)\n\tg.build()\n}\n\n// Global works like Build() but does not attach the gizmo to the current window.\nfunc (g *GizmoWidget) Global() {\n\tdisplaySize := imgui.CurrentIO().DisplaySize()\n\tpos0 := imgui.MainViewport().Pos()\n\timguizmo.SetRect(pos0.X, pos0.Y, displaySize.X, displaySize.Y)\n\tg.build()\n}\n\n// [Gizmos]\n\nvar _ GizmoI = &GridGizmo{}\n\n// GridGizmo draws a grid in the gizmo area.\ntype GridGizmo struct {\n\t// default to Identity\n\tmatrix    *ViewMatrix\n\tthickness float32\n}\n\n// Grid creates a new GridGizmo.\nfunc Grid() *GridGizmo {\n\treturn &GridGizmo{\n\t\tmatrix:    IdentityMatrix(),\n\t\tthickness: 10,\n\t}\n}\n\n// Thickness sets a thickness of grid lines.\nfunc (g *GridGizmo) Thickness(t float32) *GridGizmo {\n\tg.thickness = t\n\treturn g\n}\n\n// Matrix allows to set grid matrix. Default to IdentityMatrix.\nfunc (g *GridGizmo) Matrix(matrix *ViewMatrix) *GridGizmo {\n\tg.matrix = matrix\n\treturn g\n}\n\n// Gizmo implements GizmoI interface.\nfunc (g *GridGizmo) Gizmo(view *ViewMatrix, projection *ProjectionMatrix) {\n\timguizmo.DrawGrid(\n\t\tview.getMatrix(),\n\t\tprojection.getMatrix(),\n\t\tg.matrix.getMatrix(),\n\t\tg.thickness,\n\t)\n}\n\nvar _ GizmoI = &CubeGizmo{}\n\n// CubeGizmo draws a 3D cube in the gizmo area.\n// View and Projection matrices are provided by GizmoWidget.\ntype CubeGizmo struct {\n\tmatrix     *ViewMatrix\n\tmanipulate bool\n}\n\n// Cube creates a new CubeGizmo.\nfunc Cube(matrix *ViewMatrix) *CubeGizmo {\n\treturn &CubeGizmo{\n\t\tmatrix: matrix,\n\t}\n}\n\n// Manipulate adds ManipulateGizmo to the CubeGizmo.\nfunc (c *CubeGizmo) Manipulate() *CubeGizmo {\n\tc.manipulate = true\n\treturn c\n}\n\n// Gizmo implements GizmoI interface.\nfunc (c *CubeGizmo) Gizmo(view *ViewMatrix, projection *ProjectionMatrix) {\n\timguizmo.DrawCubes(\n\t\tview.getMatrix(),\n\t\tprojection.getMatrix(),\n\t\tc.matrix.getMatrix(),\n\t\t1,\n\t)\n\n\tif c.manipulate {\n\t\tManipulate(c.matrix).Gizmo(view, projection)\n\t}\n}\n\nvar _ GizmoI = &ManipulateGizmo{}\n\n// ManipulateGizmo is a gizmo that allows you to \"visually manipulate a matrix\".\n// It can be attached to another Gizmo (e.g. CubeGizmo) and will allow to move/rotate/scale it.\n// See (*CubeGizmo).Manipulate() method.\ntype ManipulateGizmo struct {\n\tmatrix    *ViewMatrix\n\toperation GizmoOperation\n\tmode      GizmoMode\n}\n\n// Manipulate creates a new ManipulateGizmo.\nfunc Manipulate(matrix *ViewMatrix) *ManipulateGizmo {\n\treturn &ManipulateGizmo{\n\t\tmatrix:    matrix,\n\t\tmode:      GizmoMode(imguizmo.LOCAL),\n\t\toperation: GizmoOperation(imguizmo.TRANSLATE),\n\t}\n}\n\n// Gizmo implements GizmoI interface.\nfunc (m *ManipulateGizmo) Gizmo(view *ViewMatrix, projection *ProjectionMatrix) {\n\timguizmo.ManipulateV(\n\t\tview.getMatrix(),\n\t\tprojection.getMatrix(),\n\t\timguizmo.OPERATION(m.operation),\n\t\timguizmo.MODE(m.mode),\n\t\tm.matrix.getMatrix(),\n\t\tnil, // this is deltaMatrix (Can't see usecase for now)\n\t\tnil, // snap idk what is this\n\t\tnil, // localBounds idk what is this\n\t\tnil) // boundsSnap idk what is this\n}\n\nvar _ GizmoI = &ViewManipulateGizmo{}\n\n// ViewManipulateGizmo is a gizmo that allows you to manipulate world rotation visualy.\ntype ViewManipulateGizmo struct {\n\tposition imgui.Vec2\n\tsize     imgui.Vec2\n\tcolor    uint32\n}\n\n// ViewManipulate creates a new ViewManipulateGizmo.\nfunc ViewManipulate() *ViewManipulateGizmo {\n\treturn &ViewManipulateGizmo{\n\t\tposition: imgui.Vec2{X: 128, Y: 128},\n\t\tsize:     imgui.Vec2{X: 128, Y: 128},\n\t}\n}\n\n// Position sets the position of the gizmo.\nfunc (v *ViewManipulateGizmo) Position(x, y float32) *ViewManipulateGizmo {\n\tv.position = imgui.Vec2{X: x, Y: y}\n\n\treturn v\n}\n\n// Size sets the size of the gizmo.\nfunc (v *ViewManipulateGizmo) Size(x, y float32) *ViewManipulateGizmo {\n\tv.size = imgui.Vec2{X: x, Y: y}\n\n\treturn v\n}\n\n// Color sets the color of the gizmo.\nfunc (v *ViewManipulateGizmo) Color(c color.Color) *ViewManipulateGizmo {\n\tv.color = ColorToUint(c)\n\n\treturn v\n}\n\n// Gizmo implements GizmoI interface.\nfunc (v *ViewManipulateGizmo) Gizmo(view *ViewMatrix, _ *ProjectionMatrix) {\n\timguizmo.ViewManipulateFloat(\n\t\tview.getMatrix(),\n\t\t1,\n\t\tv.position,\n\t\tv.size,\n\t\tv.color,\n\t)\n}\n\n// [Gizmo helpers]\n\n// ViewMatrix allows to generate a \"view\" matrix:\n// - position\n// - rotation\n// - scale\n// NOTE: You are supposed to allocate this with NewViewMatrix (do not use zero value)!!!\ntype ViewMatrix struct {\n\ttransform []float32 // supposed len is 3\n\trotation  []float32 // supposed len is 3\n\tscale     []float32 // supposed len is 3\n\tmatrix    []float32 // supposed len is 16\n\tdirty     bool\n}\n\n// NewViewMatrix creates a new ViewMatrix.\nfunc NewViewMatrix() *ViewMatrix {\n\treturn &ViewMatrix{\n\t\ttransform: make([]float32, 3),\n\t\trotation:  make([]float32, 3),\n\t\tscale:     make([]float32, 3),\n\t\tmatrix:    make([]float32, 16),\n\t\tdirty:     true,\n\t}\n}\n\n// IdentityMatrix creates a new ViewMatrix with identity matrix.\nfunc IdentityMatrix() *ViewMatrix {\n\tr := NewViewMatrix()\n\tr.matrix = []float32{\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1,\n\t}\n\n\tr.decompile()\n\tr.dirty = false\n\n\treturn r\n}\n\n// Transform sets the position of the matrix.\nfunc (m *ViewMatrix) Transform(x, y, z float32) *ViewMatrix {\n\tm.transform[0] = x\n\tm.transform[1] = y\n\tm.transform[2] = z\n\tm.dirty = true\n\n\treturn m\n}\n\n// Rotation sets the rotation of the matrix.\nfunc (m *ViewMatrix) Rotation(x, y, z float32) *ViewMatrix {\n\tm.rotation[0] = x\n\tm.rotation[1] = y\n\tm.rotation[2] = z\n\tm.dirty = true\n\n\treturn m\n}\n\n// Scale sets the scale of the matrix.\nfunc (m *ViewMatrix) Scale(x, y, z float32) *ViewMatrix {\n\tm.scale[0] = x\n\tm.scale[1] = y\n\tm.scale[2] = z\n\tm.dirty = true\n\n\treturn m\n}\n\n// SetMatrix allows you to set the matrix directly.\n// NOTE: f is supposed to be 16 elements long.\n// NOTE: it is not recommended - use components functions.\nfunc (m *ViewMatrix) SetMatrix(f []float32) *ViewMatrix {\n\tm.matrix = f\n\tm.decompile()\n\tm.dirty = false\n\n\treturn m\n}\n\n// Copy copies returns a copy of the matrix.\n// Useful e.g. in exaples/ to duplicate the matrix.\nfunc (m *ViewMatrix) Copy() *ViewMatrix {\n\treturn NewViewMatrix().\n\t\tTransform(m.transform[0], m.transform[1], m.transform[2]).\n\t\tRotation(m.rotation[0], m.rotation[1], m.rotation[2]).\n\t\tScale(m.scale[0], m.scale[1], m.scale[2])\n}\n\n// Compile updates m.matrix\n// NOTE: this supposes matrix was allocated correctly!\nfunc (m *ViewMatrix) compile() {\n\timguizmo.RecomposeMatrixFromComponents(\n\t\tutils.SliceToPtr(m.transform),\n\t\tutils.SliceToPtr(m.rotation),\n\t\tutils.SliceToPtr(m.scale),\n\t\tutils.SliceToPtr(m.matrix),\n\t)\n\n\tm.dirty = false\n}\n\n// decompile updates m.transform, m.rotation, m.scale from m.matrix.\nfunc (m *ViewMatrix) decompile() {\n\timguizmo.DecomposeMatrixToComponents(\n\t\tutils.SliceToPtr(m.matrix),\n\t\tutils.SliceToPtr(m.transform),\n\t\tutils.SliceToPtr(m.rotation),\n\t\tutils.SliceToPtr(m.scale),\n\t)\n}\n\n// matrix returns current matrix compatible with ImGuizmo (pointer to 4x4m).\n// It recompiles as necessary.\nfunc (m *ViewMatrix) getMatrix() *float32 {\n\tif m.dirty {\n\t\tm.compile()\n\t}\n\n\treturn utils.SliceToPtr(m.matrix)\n}\n\n// MatrixSlice returns ViewMatrix as a slice (for debugging purposes).\nfunc (m *ViewMatrix) MatrixSlice() []float32 {\n\tif m.dirty {\n\t\tm.compile()\n\t}\n\n\treturn m.matrix\n}\n\n// ProjectionMatrix represents a matrix for Gizmo projection.\n// ref: https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-projection-matrix\ntype ProjectionMatrix struct {\n\t// The vertical Field of View, in radians: the amount of \"zoom\". Think \"camera lens\". Usually between 90° (extra wide) and 30° (quite zoomed in)\n\t// This value is in radians! See Deg2Rad.\n\tfov float32\n\t// Aspect Ratio. Depends on the size of your window. Notice that 4/3 == 800/600 == 1280/960, sounds familiar?\n\taspect float32\n\t// Near clipping plane. Keep as big as possible, or you'll get precision issues.\n\tnearClipping float32\n\t// Far clipping plane. Keep as little as possible.\n\tfarClipping float32\n\n\tdirty  bool\n\tmatrix []float32\n}\n\n// NewProjectionMatrix creates a new ProjectionMatrix.\nfunc NewProjectionMatrix() *ProjectionMatrix {\n\treturn &ProjectionMatrix{\n\t\tfov:          Deg2Rad(45),\n\t\taspect:       3.0 / 4.0,\n\t\tnearClipping: 0.1,\n\t\tfarClipping:  100.0,\n\t\tdirty:        true,\n\t\tmatrix:       make([]float32, 16),\n\t}\n}\n\n// FOV sets the Field of View.\nfunc (p *ProjectionMatrix) FOV(fov float32) *ProjectionMatrix {\n\tp.fov = fov\n\tp.dirty = true\n\n\treturn p\n}\n\n// Aspect sets the Aspect Ratio.\nfunc (p *ProjectionMatrix) Aspect(aspect float32) *ProjectionMatrix {\n\tp.aspect = aspect\n\tp.dirty = true\n\n\treturn p\n}\n\n// NearClipping sets the Near Clipping plane.\nfunc (p *ProjectionMatrix) NearClipping(near float32) *ProjectionMatrix {\n\tp.nearClipping = near\n\tp.dirty = true\n\n\treturn p\n}\n\n// FarClipping sets the Far Clipping plane.\nfunc (p *ProjectionMatrix) FarClipping(far float32) *ProjectionMatrix {\n\tp.farClipping = far\n\tp.dirty = true\n\n\treturn p\n}\n\n// Copy returns a copy of the matrix.\nfunc (p *ProjectionMatrix) Copy() *ProjectionMatrix {\n\treturn NewProjectionMatrix().\n\t\tFOV(p.fov).\n\t\tAspect(p.aspect).\n\t\tNearClipping(p.nearClipping).\n\t\tFarClipping(p.farClipping)\n}\n\n// getMatrix returns the matrix compatible with ImGuizmo (pointer to 4x4m).\nfunc (p *ProjectionMatrix) getMatrix() *float32 {\n\tif p.dirty {\n\t\tp.compile()\n\t}\n\n\treturn utils.SliceToPtr(p.matrix)\n}\n\n// compile updates p.matrix.\nfunc (p *ProjectionMatrix) compile() {\n\tp.matrix = glm.MatrixPerspective(p.fov, p.aspect, p.nearClipping, p.farClipping)\n\tp.dirty = false\n}\n"
        },
        {
          "name": "ImageWidgets.go",
          "type": "blob",
          "size": 10.123046875,
          "content": "package giu\n\nimport (\n\tctx \"context\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\nvar _ Widget = &ImageWidget{}\n\n// ImageWidget adds an image.\n// The default size is the size of the image,\n// to set a specific size, use .Size(width, height).\n// NOTE: ImageWidget is going to be deprecated. ImageWithRGBAWidget\n// should be used instead, however, because it is a native\n// imgui's solution it is still there.\ntype ImageWidget struct {\n\ttexture                *Texture\n\twidth                  float32\n\theight                 float32\n\tscale                  imgui.Vec2\n\tuv0, uv1               imgui.Vec2\n\ttintColor, borderColor color.Color\n\tonClick                func()\n}\n\n// Image adds an image from giu.Texture.\nfunc Image(texture *Texture) *ImageWidget {\n\treturn &ImageWidget{\n\t\ttexture:     texture,\n\t\twidth:       0,\n\t\theight:      0,\n\t\tscale:       imgui.Vec2{X: 1, Y: 1},\n\t\tuv0:         imgui.Vec2{X: 0, Y: 0},\n\t\tuv1:         imgui.Vec2{X: 1, Y: 1},\n\t\ttintColor:   color.RGBA{255, 255, 255, 255},\n\t\tborderColor: color.RGBA{0, 0, 0, 0},\n\t}\n}\n\n// Uv allows to specify uv parameters.\nfunc (i *ImageWidget) Uv(uv0X, uv0Y, uv1X, uv1Y float32) *ImageWidget {\n\ti.uv0.X, i.uv0.Y, i.uv1.X, i.uv1.Y = uv0X, uv0Y, uv1X, uv1Y\n\treturn i\n}\n\n// TintColor sets image's tint color.\nfunc (i *ImageWidget) TintColor(tintColor color.Color) *ImageWidget {\n\ti.tintColor = tintColor\n\treturn i\n}\n\n// BorderCol sets color of the border.\nfunc (i *ImageWidget) BorderCol(borderColor color.Color) *ImageWidget {\n\ti.borderColor = borderColor\n\treturn i\n}\n\n// OnClick adds on-click-callback.\nfunc (i *ImageWidget) OnClick(cb func()) *ImageWidget {\n\ti.onClick = cb\n\treturn i\n}\n\n// Size sets image size.\nfunc (i *ImageWidget) Size(width, height float32) *ImageWidget {\n\t// Size image with DPI scaling\n\ti.width, i.height = width, height\n\n\treturn i\n}\n\n// Scale multiply dimensions after size.\nfunc (i *ImageWidget) Scale(scaleX, scaleY float32) *ImageWidget {\n\t// Size image with DPI scaling\n\ti.scale = imgui.Vec2{X: scaleX, Y: scaleY}\n\n\treturn i\n}\n\n// Build implements Widget interface.\nfunc (i *ImageWidget) Build() {\n\tif i.width == 0 && i.height == 0 {\n\t\tif i.texture != nil {\n\t\t\ti.width, i.height = float32(i.texture.tex.Width), float32(i.texture.tex.Height)\n\t\t} else {\n\t\t\ti.width, i.height = 100, 100\n\t\t}\n\t}\n\n\tsize := imgui.Vec2{X: i.width, Y: i.height}\n\n\tif size.X == -1 {\n\t\trect := imgui.ContentRegionAvail()\n\t\tsize.X = rect.X\n\t}\n\n\tif size.Y == -1 {\n\t\trect := imgui.ContentRegionAvail()\n\t\tsize.Y = rect.Y\n\t}\n\n\tsize.X *= i.scale.X\n\tsize.Y *= i.scale.Y\n\n\tif i.texture == nil || i.texture.tex == nil {\n\t\tDummy(size.X, size.Y).Build()\n\t\treturn\n\t}\n\n\t// trick: detect click event\n\tif i.onClick != nil && IsMouseClicked(MouseButtonLeft) && IsWindowHovered(0) {\n\t\tcursorPos := GetCursorScreenPos()\n\t\tmousePos := GetMousePos()\n\n\t\tif cursorPos.X <= mousePos.X && cursorPos.Y <= mousePos.Y &&\n\t\t\tcursorPos.X+int(size.X) >= mousePos.X && cursorPos.Y+int(size.Y) >= mousePos.Y {\n\t\t\ti.onClick()\n\t\t}\n\t}\n\n\timgui.ImageV(i.texture.tex.ID, size, i.uv0, i.uv1, ToVec4Color(i.tintColor), ToVec4Color(i.borderColor))\n}\n\ntype imageState struct {\n\tloading bool\n\tfailure bool\n\tcancel  ctx.CancelFunc\n\ttexture *Texture\n\timg     *image.RGBA\n}\n\n// Dispose cleans imageState (implements Disposable interface).\nfunc (is *imageState) Dispose() {\n\tis.texture = nil\n\t// Cancel ongoing image downloading\n\tif is.loading && is.cancel != nil {\n\t\tis.cancel()\n\t}\n}\n\nvar _ Widget = &ImageWithRgbaWidget{}\n\n// ImageWithRgbaWidget wraps ImageWidget.\n// It is more useful because it doesn't make you to care about\n// imgui textures. You can just pass golang-native image.Image and\n// display it in giu.\ntype ImageWithRgbaWidget struct {\n\tid   ID\n\trgba *image.RGBA\n\timg  *ImageWidget\n}\n\n// ImageWithRgba creates ImageWithRgbaWidget.\n// The default size is the size of the image,\n// to set a specific size, use .Size(width, height).\nfunc ImageWithRgba(rgba image.Image) *ImageWithRgbaWidget {\n\treturn &ImageWithRgbaWidget{\n\t\tid:   GenAutoID(\"ImageWithRgba\"),\n\t\trgba: ImageToRgba(rgba),\n\t\timg:  Image(nil),\n\t}\n}\n\n// ID sets the interval id of ImageWithRgba widgets.\nfunc (i *ImageWithRgbaWidget) ID(id ID) *ImageWithRgbaWidget {\n\ti.id = id\n\treturn i\n}\n\n// Size sets image's size.\nfunc (i *ImageWithRgbaWidget) Size(width, height float32) *ImageWithRgbaWidget {\n\ti.img.Size(width, height)\n\treturn i\n}\n\n// OnClick sets click callback.\nfunc (i *ImageWithRgbaWidget) OnClick(cb func()) *ImageWithRgbaWidget {\n\ti.img.OnClick(cb)\n\treturn i\n}\n\n// Build implements Widget interface.\nfunc (i *ImageWithRgbaWidget) Build() {\n\tif i.rgba != nil {\n\t\tvar imgState *imageState\n\t\tif imgState = GetState[imageState](Context, i.id); imgState == nil || !reflect.DeepEqual(i.rgba, imgState.img) {\n\t\t\timgState = &imageState{}\n\t\t\timgState.img = i.rgba\n\t\t\tSetState(Context, i.id, imgState)\n\n\t\t\tNewTextureFromRgba(i.rgba, func(tex *Texture) {\n\t\t\t\timgState.texture = tex\n\t\t\t})\n\t\t}\n\n\t\ti.img.texture = imgState.texture\n\t}\n\n\ti.img.Build()\n}\n\nvar _ Widget = &ImageWithFileWidget{}\n\n// ImageWithFileWidget allows to display an image directly\n// from .png file.\n// NOTE: Be aware that project using this solution may not be portable\n// because files are not included in executable binaries!\n// You may want to use \"embed\" package and ImageWithRgba instead.\ntype ImageWithFileWidget struct {\n\tid      ID\n\timgPath string\n\timg     *ImageWidget\n}\n\n// ImageWithFile constructs a new ImageWithFileWidget.\n// The default size is the size of the image,\n// to set a specific size, use .Size(width, height).\nfunc ImageWithFile(imgPath string) *ImageWithFileWidget {\n\treturn &ImageWithFileWidget{\n\t\tid:      ID(fmt.Sprintf(\"ImageWithFile_%s\", imgPath)),\n\t\timgPath: imgPath,\n\t\timg:     Image(nil),\n\t}\n}\n\n// ID sets the interval id of ImageWithFile widgets.\nfunc (i *ImageWithFileWidget) ID(id ID) *ImageWithFileWidget {\n\ti.id = id\n\treturn i\n}\n\n// Size sets image's size.\nfunc (i *ImageWithFileWidget) Size(width, height float32) *ImageWithFileWidget {\n\ti.img.Size(width, height)\n\treturn i\n}\n\n// OnClick sets click callback.\nfunc (i *ImageWithFileWidget) OnClick(cb func()) *ImageWithFileWidget {\n\ti.img.OnClick(cb)\n\treturn i\n}\n\n// Build implements Widget interface.\nfunc (i *ImageWithFileWidget) Build() {\n\tvar imgState *imageState\n\tif imgState = GetState[imageState](Context, i.id); imgState == nil {\n\t\t// Prevent multiple invocation to LoadImage.\n\t\timgState = &imageState{}\n\t\tSetState(Context, i.id, imgState)\n\n\t\timg, err := LoadImage(i.imgPath)\n\t\tif err == nil {\n\t\t\tNewTextureFromRgba(img, func(tex *Texture) {\n\t\t\t\timgState.texture = tex\n\t\t\t})\n\t\t}\n\t}\n\n\ti.img.texture = imgState.texture\n\ti.img.Build()\n}\n\nvar _ Widget = &ImageWithURLWidget{}\n\n// ImageWithURLWidget allows to display an image using\n// an URL as image source.\ntype ImageWithURLWidget struct {\n\tid              ID\n\timgURL          string\n\tdownloadTimeout time.Duration\n\twhenLoading     Layout\n\twhenFailure     Layout\n\tonReady         func()\n\tonFailure       func(error)\n\timg             *ImageWidget\n}\n\n// ImageWithURL creates ImageWithURLWidget.\n// The default size is the size of the image,\n// to set a specific size, use .Size(width, height).\nfunc ImageWithURL(url string) *ImageWithURLWidget {\n\treturn &ImageWithURLWidget{\n\t\tid:              ID(fmt.Sprintf(\"ImageWithURL_%s\", url)),\n\t\timgURL:          url,\n\t\tdownloadTimeout: 10 * time.Second,\n\t\twhenLoading:     Layout{Dummy(100, 100)},\n\t\twhenFailure:     Layout{Dummy(100, 100)},\n\t\timg:             Image(nil),\n\t}\n}\n\n// OnReady sets event trigger when image is downloaded and ready to display.\nfunc (i *ImageWithURLWidget) OnReady(onReady func()) *ImageWithURLWidget {\n\ti.onReady = onReady\n\treturn i\n}\n\n// OnFailure sets event trigger when image failed to download/load.\nfunc (i *ImageWithURLWidget) OnFailure(onFailure func(error)) *ImageWithURLWidget {\n\ti.onFailure = onFailure\n\treturn i\n}\n\n// OnClick sets click callback.\nfunc (i *ImageWithURLWidget) OnClick(cb func()) *ImageWithURLWidget {\n\ti.img.OnClick(cb)\n\treturn i\n}\n\n// Timeout sets download timeout.\nfunc (i *ImageWithURLWidget) Timeout(downloadTimeout time.Duration) *ImageWithURLWidget {\n\ti.downloadTimeout = downloadTimeout\n\treturn i\n}\n\n// Size sets image's size.\nfunc (i *ImageWithURLWidget) Size(width, height float32) *ImageWithURLWidget {\n\ti.img.Size(width, height)\n\treturn i\n}\n\n// LayoutForLoading allows to set layout rendered while loading an image.\nfunc (i *ImageWithURLWidget) LayoutForLoading(widgets ...Widget) *ImageWithURLWidget {\n\ti.whenLoading = widgets\n\treturn i\n}\n\n// LayoutForFailure allows to specify layout when image failed to download.\nfunc (i *ImageWithURLWidget) LayoutForFailure(widgets ...Widget) *ImageWithURLWidget {\n\ti.whenFailure = widgets\n\treturn i\n}\n\n// Build implements Widget interface.\nfunc (i *ImageWithURLWidget) Build() {\n\tvar imgState *imageState\n\tif imgState = GetState[imageState](Context, i.id); imgState == nil {\n\t\timgState = &imageState{}\n\t\tSetState(Context, i.id, imgState)\n\n\t\t// Prevent multiple invocation to download image.\n\t\tdownloadContext, cancelFunc := ctx.WithCancel(ctx.Background())\n\n\t\tSetState(Context, i.id, &imageState{loading: true, cancel: cancelFunc})\n\n\t\terrorFn := func(err error) {\n\t\t\tSetState(Context, i.id, &imageState{failure: true})\n\n\t\t\t// Trigger onFailure event\n\t\t\tif i.onFailure != nil {\n\t\t\t\ti.onFailure(err)\n\t\t\t}\n\t\t}\n\n\t\tgo func() {\n\t\t\t// Load image from url\n\t\t\tclient := &http.Client{Timeout: i.downloadTimeout}\n\n\t\t\treq, err := http.NewRequestWithContext(downloadContext, http.MethodGet, i.imgURL, http.NoBody)\n\t\t\tif err != nil {\n\t\t\t\terrorFn(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresp, err := client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\terrorFn(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdefer func() {\n\t\t\t\tif closeErr := resp.Body.Close(); closeErr != nil {\n\t\t\t\t\terrorFn(closeErr)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\timg, _, err := image.Decode(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\terrorFn(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trgba := ImageToRgba(img)\n\n\t\t\tEnqueueNewTextureFromRgba(rgba, func(tex *Texture) {\n\t\t\t\tSetState(Context, i.id, &imageState{\n\t\t\t\t\tloading: false,\n\t\t\t\t\tfailure: false,\n\t\t\t\t\ttexture: tex,\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// Trigger onReady event\n\t\t\tif i.onReady != nil {\n\t\t\t\ti.onReady()\n\t\t\t}\n\t\t}()\n\t}\n\n\timgState = GetState[imageState](Context, i.id)\n\n\tswitch {\n\tcase imgState.failure:\n\t\ti.whenFailure.Build()\n\tcase imgState.loading:\n\t\ti.whenLoading.Build()\n\tdefault:\n\t\ti.img.texture = imgState.texture\n\t\ti.img.Build()\n\t}\n}\n"
        },
        {
          "name": "InputHandler.go",
          "type": "blob",
          "size": 2.384765625,
          "content": "package giu\n\n// input manager is used to register a keyboard shortcuts in an app.\n\n// Shortcut represents a keyboard shortcut.\ntype Shortcut struct {\n\tKey      Key\n\tModifier Modifier\n\tCallback func()\n\tIsGlobal ShortcutType\n}\n\n// WindowShortcut represents a window-level shortcut\n// could be used as an argument to (*Window).RegisterKeyboardShortcuts.\ntype WindowShortcut struct {\n\tKey      Key\n\tModifier Modifier\n\tCallback func()\n}\n\n// ShortcutType represents a type of shortcut (global or local).\ntype ShortcutType bool\n\nconst (\n\t// GlobalShortcut is registered for all the app.\n\tGlobalShortcut ShortcutType = true\n\n\t// LocalShortcut is registered for current window only.\n\tLocalShortcut ShortcutType = false\n)\n\n// InputHandlerHandleCallback is a callback which is called when a shortcut is triggered.\ntype InputHandlerHandleCallback func(Key, Modifier, Action)\n\n// InputHandler is an interface which needs to be implemented\n// by user-defined input handlers.\ntype InputHandler interface {\n\t// RegisterKeyboardShortcuts adds a specified shortcuts into input handler\n\tRegisterKeyboardShortcuts(...Shortcut)\n\t// UnregisterKeyboardShortcuts removes window shortcuts from input handler\n\tUnregisterWindowShortcuts()\n\t// Handle handles a shortcut\n\tHandle(Key, Modifier, Action)\n}\n\n// --- Default implementation of giu input manager ---\n\nvar _ InputHandler = &inputHandler{}\n\nfunc newInputHandler() *inputHandler {\n\treturn &inputHandler{\n\t\tshortcuts: make(map[keyCombo]*callbacks),\n\t}\n}\n\ntype inputHandler struct {\n\tshortcuts map[keyCombo]*callbacks\n}\n\nfunc (i *inputHandler) RegisterKeyboardShortcuts(s ...Shortcut) {\n\tfor _, shortcut := range s {\n\t\tcombo := keyCombo{shortcut.Key, shortcut.Modifier}\n\n\t\tcb, isRegistered := i.shortcuts[combo]\n\t\tif !isRegistered {\n\t\t\tcb = &callbacks{}\n\t\t}\n\n\t\tif shortcut.IsGlobal {\n\t\t\tcb.global = shortcut.Callback\n\t\t} else {\n\t\t\tcb.window = shortcut.Callback\n\t\t}\n\n\t\ti.shortcuts[combo] = cb\n\t}\n}\n\nfunc (i *inputHandler) UnregisterWindowShortcuts() {\n\tfor _, s := range i.shortcuts {\n\t\ts.window = nil\n\t}\n}\n\nfunc (i *inputHandler) Handle(key Key, mod Modifier, a Action) {\n\tif a != Press {\n\t\treturn\n\t}\n\n\tfor combo, cb := range i.shortcuts {\n\t\tif combo.key != key || combo.modifier != mod {\n\t\t\tcontinue\n\t\t}\n\n\t\tif cb.window != nil {\n\t\t\tcb.window()\n\t\t} else if cb.global != nil {\n\t\t\tcb.global()\n\t\t}\n\t}\n}\n\ntype keyCombo struct {\n\tkey      Key\n\tmodifier Modifier\n}\n\ntype callbacks struct {\n\tglobal func()\n\twindow func()\n}\n"
        },
        {
          "name": "InputHandler_test.go",
          "type": "blob",
          "size": 2.70703125,
          "content": "package giu\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_InputHandler_new(t *testing.T) {\n\ti := newInputHandler()\n\tassert.NotNil(t, i, \"input handler wasn't created\")\n\tassert.NotNil(t, i.shortcuts, \"input handler wasn't created\")\n}\n\nfunc Test_InputHandle_RegisterKeyboardShortcuts(t *testing.T) {\n\ttests := []struct {\n\t\tid       string\n\t\tkey      Key\n\t\tmod      Modifier\n\t\tisGlobal ShortcutType\n\t\tcb       func()\n\t}{\n\t\t{\"global shortcut\", Key(1), Modifier(2), ShortcutType(true), func() {}},\n\t\t{\"window shortcut\", Key(9), Modifier(3), ShortcutType(false), func() {}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.id, func(lt *testing.T) {\n\t\t\ta := assert.New(lt)\n\t\t\ti := newInputHandler()\n\t\t\ti.RegisterKeyboardShortcuts(Shortcut{\n\t\t\t\tKey:      tt.key,\n\t\t\t\tModifier: tt.mod,\n\t\t\t\tCallback: tt.cb,\n\t\t\t\tIsGlobal: tt.isGlobal,\n\t\t\t})\n\n\t\t\tcombo := keyCombo{\n\t\t\t\tkey:      tt.key,\n\t\t\t\tmodifier: tt.mod,\n\t\t\t}\n\n\t\t\tshortcut, exist := i.shortcuts[combo]\n\n\t\t\ta.True(exist, \"shortcut wasn't registered in input manager\")\n\n\t\t\tif tt.isGlobal {\n\t\t\t\t// TODO: figure out why it doesn't work\n\t\t\t\t// a.Equal(shortcut.global, tt.cb, \"wrong shortcut set in input manager\")\n\t\t\t\ta.NotNil(shortcut.global, \"wrong shortcut set in input manager\")\n\t\t\t\ta.Nil(shortcut.window, \"wrong shortcut set in input manager\")\n\t\t\t} else {\n\t\t\t\t// TODO: figure out why it doesn't work\n\t\t\t\t// a.Equal(shortcut.window, tt.cb, \"wrong shortcut set in input manager\")\n\t\t\t\ta.NotNil(shortcut.window, \"wrong shortcut set in input manager\")\n\t\t\t\ta.Nil(shortcut.global, \"wrong shortcut set in input manager\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_InputHandler_UnregisterWindowShortcuts(t *testing.T) {\n\ti := newInputHandler()\n\tsh := []Shortcut{\n\t\t{Key(5), Modifier(0), func() {}, true},\n\t\t{Key(8), Modifier(2), func() {}, false},\n\t}\n\n\ti.RegisterKeyboardShortcuts(sh...)\n\n\ti.UnregisterWindowShortcuts()\n\n\tfor _, s := range i.shortcuts {\n\t\tassert.Nil(t, s.window, \"some window shortcuts wasn't unregistered\")\n\t}\n}\n\nfunc Test_InputHandler_Handle(t *testing.T) {\n\ta := assert.New(t)\n\ti := newInputHandler()\n\n\tvar shortcut1, shortcut2 bool\n\n\tsh := []Shortcut{\n\t\t{Key(5), Modifier(0), func() { shortcut1 = true }, true},\n\t\t{Key(8), Modifier(2), func() { shortcut2 = true }, false},\n\t}\n\n\ti.RegisterKeyboardShortcuts(sh...)\n\n\ti.Handle(Key(0), Modifier(0), Press)\n\ta.False(shortcut1, \"Shortcut 1 was handled, but shouldn't.\")\n\ta.False(shortcut2, \"Shortcut 2 was handled, but shouldn't.\")\n\ti.Handle(Key(5), Modifier(0), Press)\n\ta.True(shortcut1, \"Shortcut 1 was not handled, but should be.\")\n\ta.False(shortcut2, \"Shortcut 2 was handled, but shouldn't.\")\n\ti.Handle(Key(8), Modifier(2), Press)\n\ta.True(shortcut1, \"Shortcut 1 was not handled, but should be.\")\n\ta.True(shortcut2, \"Shortcut 2 was not handled, but should be.\")\n}\n"
        },
        {
          "name": "Keycode.go",
          "type": "blob",
          "size": 10.3466796875,
          "content": "package giu\n\nimport \"C\"\nimport (\n\t\"log\"\n\n\t\"github.com/AllenDang/cimgui-go/backend/glfwbackend\"\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// Key represents a imgui key.\ntype Key imgui.Key\n\n// These key codes are inspired by the USB HID Usage Tables v1.12 (p. 53-60),\n// but re-arranged to map to 7-bit ASCII for printable keys (function keys are\n// put in the 256+ range).\nconst (\n\tKeyNone           = Key(imgui.KeyNone)\n\tKeySpace          = Key(imgui.KeySpace)\n\tKeyApostrophe     = Key(imgui.KeyApostrophe)\n\tKeyComma          = Key(imgui.KeyComma)\n\tKeyMinus          = Key(imgui.KeyMinus)\n\tKeyPeriod         = Key(imgui.KeyPeriod)\n\tKeySlash          = Key(imgui.KeySlash)\n\tKey0              = Key(imgui.Key0)\n\tKey1              = Key(imgui.Key1)\n\tKey2              = Key(imgui.Key2)\n\tKey3              = Key(imgui.Key3)\n\tKey4              = Key(imgui.Key4)\n\tKey5              = Key(imgui.Key5)\n\tKey6              = Key(imgui.Key6)\n\tKey7              = Key(imgui.Key7)\n\tKey8              = Key(imgui.Key8)\n\tKey9              = Key(imgui.Key9)\n\tKeySemicolon      = Key(imgui.KeySemicolon)\n\tKeyEqual          = Key(imgui.KeyEqual)\n\tKeyA              = Key(imgui.KeyA)\n\tKeyB              = Key(imgui.KeyB)\n\tKeyC              = Key(imgui.KeyC)\n\tKeyD              = Key(imgui.KeyD)\n\tKeyE              = Key(imgui.KeyE)\n\tKeyF              = Key(imgui.KeyF)\n\tKeyG              = Key(imgui.KeyG)\n\tKeyH              = Key(imgui.KeyH)\n\tKeyI              = Key(imgui.KeyI)\n\tKeyJ              = Key(imgui.KeyJ)\n\tKeyK              = Key(imgui.KeyK)\n\tKeyL              = Key(imgui.KeyL)\n\tKeyM              = Key(imgui.KeyM)\n\tKeyN              = Key(imgui.KeyN)\n\tKeyO              = Key(imgui.KeyO)\n\tKeyP              = Key(imgui.KeyP)\n\tKeyQ              = Key(imgui.KeyQ)\n\tKeyR              = Key(imgui.KeyR)\n\tKeyS              = Key(imgui.KeyS)\n\tKeyT              = Key(imgui.KeyT)\n\tKeyU              = Key(imgui.KeyU)\n\tKeyV              = Key(imgui.KeyV)\n\tKeyW              = Key(imgui.KeyW)\n\tKeyX              = Key(imgui.KeyX)\n\tKeyY              = Key(imgui.KeyY)\n\tKeyZ              = Key(imgui.KeyZ)\n\tKeyLeftBracket    = Key(imgui.KeyLeftBracket)\n\tKeyBackslash      = Key(imgui.KeyBackslash)\n\tKeyRightBracket   = Key(imgui.KeyRightBracket)\n\tKeyGraveAccent    = Key(imgui.KeyGraveAccent)\n\tKeyEscape         = Key(imgui.KeyEscape)\n\tKeyEnter          = Key(imgui.KeyEnter)\n\tKeyTab            = Key(imgui.KeyTab)\n\tKeyBackspace      = Key(imgui.KeyBackspace)\n\tKeyInsert         = Key(imgui.KeyInsert)\n\tKeyDelete         = Key(imgui.KeyDelete)\n\tKeyRight          = Key(imgui.KeyRightArrow)\n\tKeyLeft           = Key(imgui.KeyLeftArrow)\n\tKeyDown           = Key(imgui.KeyDownArrow)\n\tKeyUp             = Key(imgui.KeyUpArrow)\n\tKeyPageUp         = Key(imgui.KeyPageUp)\n\tKeyPageDown       = Key(imgui.KeyPageDown)\n\tKeyHome           = Key(imgui.KeyHome)\n\tKeyEnd            = Key(imgui.KeyEnd)\n\tKeyCapsLock       = Key(imgui.KeyCapsLock)\n\tKeyScrollLock     = Key(imgui.KeyScrollLock)\n\tKeyNumLock        = Key(imgui.KeyNumLock)\n\tKeyPrintScreen    = Key(imgui.KeyPrintScreen)\n\tKeyPause          = Key(imgui.KeyPause)\n\tKeyF1             = Key(imgui.KeyF1)\n\tKeyF2             = Key(imgui.KeyF2)\n\tKeyF3             = Key(imgui.KeyF3)\n\tKeyF4             = Key(imgui.KeyF4)\n\tKeyF5             = Key(imgui.KeyF5)\n\tKeyF6             = Key(imgui.KeyF6)\n\tKeyF7             = Key(imgui.KeyF7)\n\tKeyF8             = Key(imgui.KeyF8)\n\tKeyF9             = Key(imgui.KeyF9)\n\tKeyF10            = Key(imgui.KeyF10)\n\tKeyF11            = Key(imgui.KeyF11)\n\tKeyF12            = Key(imgui.KeyF12)\n\tKeyNumPad0        = Key(glfwbackend.GLFWKeyKp0)\n\tKeyNumPad1        = Key(glfwbackend.GLFWKeyKp1)\n\tKeyNumPad2        = Key(glfwbackend.GLFWKeyKp2)\n\tKeyNumPad3        = Key(glfwbackend.GLFWKeyKp3)\n\tKeyNumPad4        = Key(glfwbackend.GLFWKeyKp4)\n\tKeyNumPad5        = Key(glfwbackend.GLFWKeyKp5)\n\tKeyNumPad6        = Key(glfwbackend.GLFWKeyKp6)\n\tKeyNumPad7        = Key(glfwbackend.GLFWKeyKp7)\n\tKeyNumPad8        = Key(glfwbackend.GLFWKeyKp8)\n\tKeyNumPad9        = Key(glfwbackend.GLFWKeyKp9)\n\tKeyNumPadDecimal  = Key(glfwbackend.GLFWKeyKpDecimal)\n\tKeyNumPadDivide   = Key(glfwbackend.GLFWKeyKpDivide)\n\tKeyNumPadMultiply = Key(glfwbackend.GLFWKeyKpMultiply)\n\tKeyNumPadSubtract = Key(glfwbackend.GLFWKeyKpSubtract)\n\tKeyNumPadAdd      = Key(glfwbackend.GLFWKeyKpAdd)\n\tKeyNumPadEnter    = Key(glfwbackend.GLFWKeyKpEnter)\n\tKeyNumPadEqual    = Key(glfwbackend.GLFWKeyKpEqual)\n\tKeyLeftShift      = Key(imgui.KeyLeftShift)\n\tKeyLeftControl    = Key(imgui.KeyLeftCtrl)\n\tKeyLeftAlt        = Key(imgui.KeyLeftAlt)\n\tKeyLeftSuper      = Key(imgui.KeyLeftSuper)\n\tKeyRightShift     = Key(imgui.KeyRightShift)\n\tKeyRightControl   = Key(imgui.KeyRightCtrl)\n\tKeyRightAlt       = Key(imgui.KeyRightAlt)\n\tKeyRightSuper     = Key(imgui.KeyRightSuper)\n\tKeyMenu           = Key(imgui.KeyMenu)\n\tKeyWorld1         = Key(glfwbackend.GLFWKeyWorld1)\n\tKeyWorld2         = Key(glfwbackend.GLFWKeyWorld2)\n\tKeyUnknown        = Key(-1)\n)\n\n// refer glfw3.h.\nfunc keyFromGLFWKey(k glfwbackend.GLFWKey) Key {\n\tdata := map[glfwbackend.GLFWKey]Key{\n\t\tglfwbackend.GLFWKeySpace:        KeySpace,\n\t\tglfwbackend.GLFWKeyApostrophe:   KeyApostrophe,\n\t\tglfwbackend.GLFWKeyComma:        KeyComma,\n\t\tglfwbackend.GLFWKeyMinus:        KeyMinus,\n\t\tglfwbackend.GLFWKeyPeriod:       KeyPeriod,\n\t\tglfwbackend.GLFWKeySlash:        KeySlash,\n\t\tglfwbackend.GLFWKey0:            Key0,\n\t\tglfwbackend.GLFWKey1:            Key1,\n\t\tglfwbackend.GLFWKey2:            Key2,\n\t\tglfwbackend.GLFWKey3:            Key3,\n\t\tglfwbackend.GLFWKey4:            Key4,\n\t\tglfwbackend.GLFWKey5:            Key5,\n\t\tglfwbackend.GLFWKey6:            Key6,\n\t\tglfwbackend.GLFWKey7:            Key7,\n\t\tglfwbackend.GLFWKey8:            Key8,\n\t\tglfwbackend.GLFWKey9:            Key9,\n\t\tglfwbackend.GLFWKeySemicolon:    KeySemicolon,\n\t\tglfwbackend.GLFWKeyEqual:        KeyEqual,\n\t\tglfwbackend.GLFWKeyA:            KeyA,\n\t\tglfwbackend.GLFWKeyB:            KeyB,\n\t\tglfwbackend.GLFWKeyC:            KeyC,\n\t\tglfwbackend.GLFWKeyD:            KeyD,\n\t\tglfwbackend.GLFWKeyE:            KeyE,\n\t\tglfwbackend.GLFWKeyF:            KeyF,\n\t\tglfwbackend.GLFWKeyG:            KeyG,\n\t\tglfwbackend.GLFWKeyH:            KeyH,\n\t\tglfwbackend.GLFWKeyI:            KeyI,\n\t\tglfwbackend.GLFWKeyJ:            KeyJ,\n\t\tglfwbackend.GLFWKeyK:            KeyK,\n\t\tglfwbackend.GLFWKeyL:            KeyL,\n\t\tglfwbackend.GLFWKeyM:            KeyM,\n\t\tglfwbackend.GLFWKeyN:            KeyN,\n\t\tglfwbackend.GLFWKeyO:            KeyO,\n\t\tglfwbackend.GLFWKeyP:            KeyP,\n\t\tglfwbackend.GLFWKeyQ:            KeyQ,\n\t\tglfwbackend.GLFWKeyR:            KeyR,\n\t\tglfwbackend.GLFWKeyS:            KeyS,\n\t\tglfwbackend.GLFWKeyT:            KeyT,\n\t\tglfwbackend.GLFWKeyU:            KeyU,\n\t\tglfwbackend.GLFWKeyV:            KeyV,\n\t\tglfwbackend.GLFWKeyW:            KeyW,\n\t\tglfwbackend.GLFWKeyX:            KeyX,\n\t\tglfwbackend.GLFWKeyY:            KeyY,\n\t\tglfwbackend.GLFWKeyZ:            KeyZ,\n\t\tglfwbackend.GLFWKeyLeftBracket:  KeyLeftBracket,\n\t\tglfwbackend.GLFWKeyBackslash:    KeyBackslash,\n\t\tglfwbackend.GLFWKeyRightBracket: KeyRightBracket,\n\t\tglfwbackend.GLFWKeyGraveAccent:  KeyGraveAccent,\n\t\tglfwbackend.GLFWKeyEscape:       KeyEscape,\n\t\tglfwbackend.GLFWKeyEnter:        KeyEnter,\n\t\tglfwbackend.GLFWKeyTab:          KeyTab,\n\t\tglfwbackend.GLFWKeyBackspace:    KeyBackspace,\n\t\tglfwbackend.GLFWKeyInsert:       KeyInsert,\n\t\tglfwbackend.GLFWKeyDelete:       KeyDelete,\n\t\tglfwbackend.GLFWKeyRight:        KeyRight,\n\t\tglfwbackend.GLFWKeyLeft:         KeyLeft,\n\t\tglfwbackend.GLFWKeyDown:         KeyDown,\n\t\tglfwbackend.GLFWKeyUp:           KeyUp,\n\t\tglfwbackend.GLFWKeyPageUp:       KeyPageUp,\n\t\tglfwbackend.GLFWKeyPageDown:     KeyPageDown,\n\t\tglfwbackend.GLFWKeyHome:         KeyHome,\n\t\tglfwbackend.GLFWKeyEnd:          KeyEnd,\n\t\tglfwbackend.GLFWKeyCapsLock:     KeyCapsLock,\n\t\tglfwbackend.GLFWKeyScrollLock:   KeyScrollLock,\n\t\tglfwbackend.GLFWKeyNumLock:      KeyNumLock,\n\t\tglfwbackend.GLFWKeyPrintScreen:  KeyPrintScreen,\n\t\tglfwbackend.GLFWKeyPause:        KeyPause,\n\t\tglfwbackend.GLFWKeyF1:           KeyF1,\n\t\tglfwbackend.GLFWKeyF2:           KeyF2,\n\t\tglfwbackend.GLFWKeyF3:           KeyF3,\n\t\tglfwbackend.GLFWKeyF4:           KeyF4,\n\t\tglfwbackend.GLFWKeyF5:           KeyF5,\n\t\tglfwbackend.GLFWKeyF6:           KeyF6,\n\t\tglfwbackend.GLFWKeyF7:           KeyF7,\n\t\tglfwbackend.GLFWKeyF8:           KeyF8,\n\t\tglfwbackend.GLFWKeyF9:           KeyF9,\n\t\tglfwbackend.GLFWKeyF10:          KeyF10,\n\t\tglfwbackend.GLFWKeyF11:          KeyF11,\n\t\tglfwbackend.GLFWKeyF12:          KeyF12,\n\t\tglfwbackend.GLFWKeyKp0:          KeyNumPad0,\n\t\tglfwbackend.GLFWKeyKp1:          KeyNumPad1,\n\t\tglfwbackend.GLFWKeyKp2:          KeyNumPad2,\n\t\tglfwbackend.GLFWKeyKp3:          KeyNumPad3,\n\t\tglfwbackend.GLFWKeyKp4:          KeyNumPad4,\n\t\tglfwbackend.GLFWKeyKp5:          KeyNumPad5,\n\t\tglfwbackend.GLFWKeyKp6:          KeyNumPad6,\n\t\tglfwbackend.GLFWKeyKp7:          KeyNumPad7,\n\t\tglfwbackend.GLFWKeyKp8:          KeyNumPad8,\n\t\tglfwbackend.GLFWKeyKp9:          KeyNumPad9,\n\t\tglfwbackend.GLFWKeyKpDecimal:    KeyNumPadDecimal,\n\t\tglfwbackend.GLFWKeyKpDivide:     KeyNumPadDivide,\n\t\tglfwbackend.GLFWKeyKpMultiply:   KeyNumPadMultiply,\n\t\tglfwbackend.GLFWKeyKpSubtract:   KeyNumPadSubtract,\n\t\tglfwbackend.GLFWKeyKpAdd:        KeyNumPadAdd,\n\t\tglfwbackend.GLFWKeyKpEnter:      KeyNumPadEnter,\n\t\tglfwbackend.GLFWKeyKpEqual:      KeyNumPadEqual,\n\t\tglfwbackend.GLFWKeyLeftShift:    KeyLeftShift,\n\t\tglfwbackend.GLFWKeyLeftControl:  KeyLeftControl,\n\t\tglfwbackend.GLFWKeyLeftAlt:      KeyLeftAlt,\n\t\tglfwbackend.GLFWKeyLeftSuper:    KeyLeftSuper,\n\t\tglfwbackend.GLFWKeyRightShift:   KeyRightShift,\n\t\tglfwbackend.GLFWKeyRightControl: KeyRightControl,\n\t\tglfwbackend.GLFWKeyRightAlt:     KeyRightAlt,\n\t\tglfwbackend.GLFWKeyRightSuper:   KeyRightSuper,\n\t\tglfwbackend.GLFWKeyMenu:         KeyMenu,\n\t\tglfwbackend.GLFWKeyWorld1:       KeyWorld1,\n\t\tglfwbackend.GLFWKeyWorld2:       KeyWorld2,\n\t\t-1:                              KeyUnknown,\n\t}\n\n\tif v, ok := data[k]; ok {\n\t\treturn v\n\t}\n\n\tlog.Panicf(\"Unknown key: %v\", k)\n\n\treturn 0\n}\n\n// Modifier represents imgui.Modifier.\ntype Modifier imgui.Key\n\n// modifier keys.\nconst (\n\tModNone     Modifier = 0\n\tModControl           = Modifier(glfwbackend.GLFWModControl)\n\tModAlt               = Modifier(glfwbackend.GLFWModAlt)\n\tModSuper             = Modifier(glfwbackend.GLFWModSuper)\n\tModShift             = Modifier(glfwbackend.GLFWModShift)\n\tModCapsLock          = Modifier(glfwbackend.GLFWModCapsLock)\n\tModNumLock           = Modifier(glfwbackend.GLFWModNumLock)\n)\n\n// Action represents key status change type.\ntype Action int\n\n// Actions.\nconst (\n\tRelease Action = iota\n\tPress\n\tRepeat\n)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2020 Allen Dang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Layout.go",
          "type": "blob",
          "size": 1.0263671875,
          "content": "package giu\n\nconst (\n\t// Auto is used to widget.Size to indicate height or width to occupy available spaces.\n\tAuto float32 = -1\n)\n\n// Widget is a base unit of giu rendering system.\n// each widget just needs to implement Build method which is called,\n// when widget needs to be rendered.\ntype Widget interface {\n\tBuild()\n}\n\nvar (\n\t_ Widget    = Layout{}\n\t_ Splitable = Layout{}\n)\n\n// Layout is a set of widgets. It implements Widget interface so\n// Layout can be used as a widget.\ntype Layout []Widget\n\n// Build implements Widget interface.\nfunc (l Layout) Build() {\n\tfor _, w := range l {\n\t\tif w != nil {\n\t\t\tw.Build()\n\t\t}\n\t}\n}\n\n// Splitable is implemented by widgets, which can be split (ranged)\n// Layout implements Splitable.\ntype Splitable interface {\n\tRange(func(w Widget))\n}\n\n// Range ranges over the Layout, calling rangeFunc\n// on each loop iteration.\nfunc (l Layout) Range(rangeFunc func(Widget)) {\n\tfor _, w := range l {\n\t\tif splitable, canRange := w.(Splitable); canRange {\n\t\t\tsplitable.Range(rangeFunc)\n\t\t\tcontinue\n\t\t}\n\n\t\trangeFunc(w)\n\t}\n}\n"
        },
        {
          "name": "Layout_test.go",
          "type": "blob",
          "size": 1.94140625,
          "content": "package giu\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype testwidget struct {\n\tcounter *int\n}\n\nfunc (w *testwidget) Build() {\n\tif w.counter == nil {\n\t\treturn\n\t}\n\n\t*w.counter++\n}\n\ntype splitablewidget struct {\n\tw1, w2 *testwidget\n}\n\nfunc (w *splitablewidget) Build() {\n\tw.w1.Build()\n\tw.w2.Build()\n}\n\nfunc (w *splitablewidget) Range(r func(w Widget)) {\n\tr(w.w1)\n\tr(w.w2)\n}\n\nfunc Test_Layout_Range(t *testing.T) {\n\ttests := []struct {\n\t\tname                     string\n\t\texpectedTestWidgetsCount int\n\t\tlayout                   Layout\n\t}{\n\t\t{\"standard layout\", 3, Layout{\n\t\t\t&testwidget{},\n\t\t\t&testwidget{},\n\t\t\t&testwidget{},\n\t\t}},\n\t\t{\"layout with splitable widgets\", 4, Layout{\n\t\t\t&testwidget{},\n\t\t\t&splitablewidget{&testwidget{}, &testwidget{}},\n\t\t\t&testwidget{},\n\t\t}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(tt *testing.T) {\n\t\t\tcounter := 0\n\n\t\t\ttest.layout.Range(func(w Widget) {\n\t\t\t\tif _, isTestwidget := w.(*testwidget); isTestwidget {\n\t\t\t\t\tcounter++\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tassert.Equal(tt, test.expectedTestWidgetsCount, counter, \"Layout wasn't ranged correctly\")\n\t\t})\n\t}\n}\n\nfunc Test_Layout_Build(t *testing.T) {\n\ttests := []struct {\n\t\tname                        string\n\t\texpectedNumTestWidgetsBuilt int\n\t\tlayout                      Layout\n\t}{\n\t\t{\"standard layout\", 2, Layout{\n\t\t\t&testwidget{},\n\t\t\t&testwidget{},\n\t\t}},\n\t\t{\"layout with nil widgets\", 2, Layout{\n\t\t\t&testwidget{},\n\t\t\tnil,\n\t\t\t&testwidget{},\n\t\t}},\n\t\t{\"layout with nested layouts\", 5, Layout{\n\t\t\t&testwidget{},\n\t\t\tLayout{\n\t\t\t\t&testwidget{},\n\t\t\t\t&testwidget{},\n\t\t\t\tLayout{\n\t\t\t\t\t&testwidget{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t&testwidget{},\n\t\t}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(tt *testing.T) {\n\t\t\tcounter := 0\n\n\t\t\ttest.layout.Range(func(w Widget) {\n\t\t\t\tif tw, isTestwidget := w.(*testwidget); isTestwidget {\n\t\t\t\t\ttw.counter = &counter\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttest.layout.Build()\n\n\t\t\tassert.Equal(tt, test.expectedNumTestWidgetsBuilt, counter, \"layout wasn't built correctly\")\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "ListClipper.go",
          "type": "blob",
          "size": 1,
          "content": "package giu\n\nimport \"github.com/AllenDang/cimgui-go/imgui\"\n\nvar _ Widget = &ListClipperWrapper{}\n\n// ListClipperWrapper is a ImGuiListClipper implementation.\n// it can be used to display a large, vertical list of items and\n// avoid rendering them.\ntype ListClipperWrapper struct {\n\tlayout Layout\n}\n\n// ListClipper creates list clipper.\nfunc ListClipper() *ListClipperWrapper {\n\treturn &ListClipperWrapper{}\n}\n\n// Layout sets layout for list clipper.\nfunc (l *ListClipperWrapper) Layout(layout ...Widget) *ListClipperWrapper {\n\tl.layout = layout\n\treturn l\n}\n\n// Build implements widget interface.\nfunc (l *ListClipperWrapper) Build() {\n\t// read all the layout widgets and (eventually) split nested layouts\n\tvar layout Layout\n\n\tl.layout.Range(func(w Widget) {\n\t\tlayout = append(layout, w)\n\t})\n\n\tclipper := imgui.NewListClipper()\n\tdefer clipper.Destroy()\n\n\tclipper.Begin(int32(len(layout)))\n\n\tfor clipper.Step() {\n\t\tfor i := clipper.DisplayStart(); i < clipper.DisplayEnd(); i++ {\n\t\t\tlayout[i].Build()\n\t\t}\n\t}\n\n\tclipper.End()\n}\n"
        },
        {
          "name": "Markdown.go",
          "type": "blob",
          "size": 4.8623046875,
          "content": "package giu\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/AllenDang/cimgui-go/backend\"\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/AllenDang/cimgui-go/immarkdown\"\n)\n\ntype markdownState struct {\n\tcfg    immarkdown.MarkdownConfig\n\timages map[string]immarkdown.MarkdownImageData\n}\n\nfunc (m *markdownState) Dispose() {\n\t// noop\n}\n\n// MarkdownWidget implements DearImGui markdown extension\n// https://github.com/juliettef/imgui_markdown\n// It is like LabelWidget but with md formatting.\ntype MarkdownWidget struct {\n\tmd      string\n\tid      ID\n\theaders [3]immarkdown.MarkdownHeadingFormat\n}\n\nfunc (m *MarkdownWidget) getState() *markdownState {\n\tif s := GetState[markdownState](Context, m.id); s != nil {\n\t\treturn s\n\t}\n\n\tnewState := m.newState()\n\tSetState[markdownState](Context, m.id, newState)\n\n\treturn newState\n}\n\nfunc (m *MarkdownWidget) newState() *markdownState {\n\tcfg := immarkdown.NewEmptyMarkdownConfig()\n\tfmtCb := immarkdown.MarkdownFormalCallback(func(data *immarkdown.MarkdownFormatInfo, start bool) {\n\t\timmarkdown.DefaultMarkdownFormatCallback(*data, start)\n\t})\n\n\tcfg.SetFormatCallback(&fmtCb)\n\n\timgCb := immarkdown.MarkdownImageCallback(func(data immarkdown.MarkdownLinkCallbackData) immarkdown.MarkdownImageData {\n\t\tlink := data.Link()[:data.LinkLength()] // this is because imgui_markdown returns the whole text starting on link and returns link length (for some reason)\n\t\tif existing, ok := m.getState().images[link]; ok {\n\t\t\treturn existing\n\t\t}\n\n\t\tresult := mdLoadImage(link)\n\t\tm.getState().images[link] = result\n\n\t\treturn result\n\t})\n\n\tcfg.SetImageCallback(&imgCb)\n\n\treturn &markdownState{\n\t\tcfg:    *cfg,\n\t\timages: make(map[string]immarkdown.MarkdownImageData),\n\t}\n}\n\n// Markdown creates new markdown widget.\nfunc Markdown(md string) *MarkdownWidget {\n\treturn (&MarkdownWidget{\n\t\tmd: md,\n\t\tid: GenAutoID(\"MarkdownWidget\"),\n\t\theaders: [3]immarkdown.MarkdownHeadingFormat{\n\t\t\t*immarkdown.NewEmptyMarkdownHeadingFormat(),\n\t\t\t*immarkdown.NewEmptyMarkdownHeadingFormat(),\n\t\t\t*immarkdown.NewEmptyMarkdownHeadingFormat(),\n\t\t},\n\t}).OnLink(OpenURL)\n}\n\n// OnLink sets another than default link callback.\n// NOTE: due to cimgui-go's limitation https://github.com/AllenDang/cimgui-go?tab=readme-ov-file#callbacks\n// we clear MarkdownLinkCallback pool every frame. No further action from you should be required (just feel informed).\n// ref (*MasterWindow).beforeRender.\nfunc (m *MarkdownWidget) OnLink(cb func(url string)) *MarkdownWidget {\n\tigCb := immarkdown.MarkdownLinkCallback(func(data immarkdown.MarkdownLinkCallbackData) {\n\t\tlink := data.Link()[:data.LinkLength()]\n\t\tcb(link)\n\t})\n\n\tm.getState().cfg.SetLinkCallback(&igCb)\n\n\treturn m\n}\n\n// Header sets header formatting\n// NOTE: level (counting from 0!) is header level. (for instance, header `# H1` will have level 0).\n// NOTE: since cimgui-go there are only 3 levels (so level < 3 here). This will panic if level >= 3!\n// TODO: it actually doesn't work.\nfunc (m *MarkdownWidget) Header(level int, font *FontInfo, separator bool) *MarkdownWidget {\n\t// ensure level is in range\n\tAssert(level < 3, \"MarkdownWidget\", \"Header\", \"Header level must be less than 3!\")\n\n\tm.headers[level] = *immarkdown.NewEmptyMarkdownHeadingFormat()\n\n\tif font != nil {\n\t\tif f, ok := Context.FontAtlas.extraFontMap[font.String()]; ok {\n\t\t\tm.headers[level].SetFont(f)\n\t\t}\n\t}\n\n\tm.headers[level].SetSeparator(separator)\n\n\tstate := m.getState()\n\tstate.cfg.SetHeadingFormats(&m.headers)\n\n\treturn m\n}\n\n// Build implements Widget interface.\nfunc (m *MarkdownWidget) Build() {\n\tstate := m.getState()\n\timmarkdown.Markdown(\n\t\tContext.FontAtlas.RegisterString(m.md),\n\t\tuint64(len(m.md)),\n\t\tstate.cfg,\n\t)\n}\n\nfunc mdLoadImage(path string) immarkdown.MarkdownImageData {\n\tvar (\n\t\timg *image.RGBA\n\t\terr error\n\t)\n\n\tswitch {\n\tcase strings.HasPrefix(path, \"http://\") || strings.HasPrefix(path, \"https://\"):\n\t\t// Load image from url\n\t\tclient := &http.Client{Timeout: 5 * time.Second}\n\n\t\tresp, respErr := client.Get(path)\n\t\tif respErr != nil {\n\t\t\treturn *immarkdown.NewEmptyMarkdownImageData()\n\t\t}\n\n\t\tdefer func() {\n\t\t\tcloseErr := resp.Body.Close()\n\t\t\tAssert((closeErr == nil), \"MarkdownWidget\", \"mdLoadImage\", \"Could not close http request!\")\n\t\t}()\n\n\t\trgba, _, imgErr := image.Decode(resp.Body)\n\t\tif imgErr != nil {\n\t\t\treturn *immarkdown.NewEmptyMarkdownImageData()\n\t\t}\n\n\t\timg = ImageToRgba(rgba)\n\tdefault:\n\t\timg, err = LoadImage(path)\n\t\tif err != nil {\n\t\t\treturn *immarkdown.NewEmptyMarkdownImageData()\n\t\t}\n\t}\n\n\tsize := img.Bounds()\n\tid := backend.NewTextureFromRgba(img).ID\n\n\tresult := immarkdown.NewEmptyMarkdownImageData()\n\tresult.SetUsertextureid(id)\n\tresult.SetSize(imgui.Vec2{\n\t\tX: float32(size.Dx()),\n\t\tY: float32(size.Dy()),\n\t})\n\tresult.SetUseLinkCallback(true)\n\tresult.SetUv0(ToVec2(image.Point{0, 0}))\n\tresult.SetUv1(ToVec2(image.Point{1, 1}))\n\tresult.SetTintcol(ToVec4Color(color.RGBA{255, 255, 255, 255}))\n\tresult.SetBordercol(ToVec4Color(color.RGBA{0, 0, 0, 0}))\n\n\tresult.SetIsValid(true)\n\n\treturn *result\n}\n"
        },
        {
          "name": "MasterWindow.go",
          "type": "blob",
          "size": 15.763671875,
          "content": "package giu\n\nimport (\n\t\"errors\"\n\t\"image\"\n\t\"image/color\"\n\t\"runtime\"\n\n\t\"github.com/AllenDang/cimgui-go/backend\"\n\t\"github.com/AllenDang/cimgui-go/backend/glfwbackend\"\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/AllenDang/cimgui-go/imguizmo\"\n\t\"github.com/AllenDang/cimgui-go/immarkdown\"\n\t\"github.com/AllenDang/cimgui-go/imnodes\"\n\t\"github.com/AllenDang/cimgui-go/implot\"\n\t\"golang.org/x/image/colornames\"\n)\n\n// MasterWindowFlags implements BackendWindowFlags.\ntype MasterWindowFlags int\n\n// master window flags.\nconst (\n\t// Specifies the window will be fixed size.\n\tMasterWindowFlagsNotResizable MasterWindowFlags = 1 << iota\n\t// Specifies whether the window is maximized.\n\tMasterWindowFlagsMaximized\n\t// Specifies whether the window will be always-on-top.\n\tMasterWindowFlagsFloating\n\t// Specifies whether the window will be frameless.\n\tMasterWindowFlagsFrameless\n\t// Specifies whether the window will be transparent.\n\tMasterWindowFlagsTransparent\n\t// Specifies whether the window will be hidden (for use with multiple windows).\n\tMasterWindowFlagsHidden\n)\n\n// parseAndApply converts MasterWindowFlags to appropriate glfwbackend.GLFWWindowFlags.\nfunc (m MasterWindowFlags) parseAndApply(b backend.Backend[glfwbackend.GLFWWindowFlags]) {\n\tdata := map[MasterWindowFlags]struct {\n\t\tf     glfwbackend.GLFWWindowFlags\n\t\tvalue int // value isn't always true (sometimes false). Also WindowHint takes int not bool\n\t}{\n\t\tMasterWindowFlagsNotResizable: {glfwbackend.GLFWWindowFlagsResizable, 0},\n\t\tMasterWindowFlagsMaximized:    {glfwbackend.GLFWWindowFlagsMaximized, 1},\n\t\tMasterWindowFlagsFloating:     {glfwbackend.GLFWWindowFlagsFloating, 1},\n\t\tMasterWindowFlagsFrameless:    {glfwbackend.GLFWWindowFlagsDecorated, 0},\n\t\tMasterWindowFlagsTransparent:  {glfwbackend.GLFWWindowFlagsTransparent, 1},\n\t\tMasterWindowFlagsHidden:       {glfwbackend.GLFWWindowFlagsVisible, 0},\n\t}\n\n\tfor flag, d := range data {\n\t\tif m&flag != 0 {\n\t\t\tb.SetWindowFlags(d.f, d.value)\n\t\t}\n\t}\n}\n\n// TODO(gucio321) implement this in cimgui-go\n// DontCare could be used as an argument to (*MasterWindow).SetSizeLimits.\n// var DontCare int = imgui.GlfwDontCare\n\n// MasterWindow represents a glfw master window\n// It is a base for a windows (see Window.go).\ntype MasterWindow struct {\n\tbackend backend.Backend[glfwbackend.GLFWWindowFlags]\n\n\twidth      int\n\theight     int\n\tclearColor imgui.Vec4\n\ttitle      string\n\tcontext    *imgui.Context\n\tio         *imgui.IO\n\tupdateFunc func()\n\n\t// possibility to expend InputHandler's stuff\n\t// See SetAdditionalInputHandler\n\tadditionalInputCallback InputHandlerHandleCallback\n}\n\n// NewMasterWindow creates a new master window and initializes GLFW.\n// it should be called in main function. For more details and use cases,\n// see examples/helloworld/.\nfunc NewMasterWindow(title string, width, height int, flags MasterWindowFlags) *MasterWindow {\n\timGuiContext := imgui.CreateContext()\n\n\timplot.CreateContext()\n\timnodes.CreateContext()\n\n\tio := imgui.CurrentIO()\n\n\t// TODO: removed ConfigFlagEnablePowerSavingMode\n\t// TODO: removed io.SetConfigFlags(imgui.BackendFlagsRendererHasVtxOffset)\n\tio.SetBackendFlags(imgui.BackendFlagsRendererHasVtxOffset)\n\n\t// Disable imgui.ini\n\tio.SetIniFilename(\"\")\n\n\tcurrentBackend, err := backend.CreateBackend(glfwbackend.NewGLFWBackend())\n\tif err != nil && !errors.Is(err, backend.CExposerError) {\n\t\tpanic(err)\n\t}\n\n\t// Create GIU context\n\tContext = CreateContext(currentBackend)\n\n\tmw := &MasterWindow{\n\t\tclearColor: imgui.Vec4{X: 0, Y: 0, Z: 0, W: 1},\n\t\twidth:      width,\n\t\theight:     height,\n\t\ttitle:      title,\n\t\tio:         io,\n\t\tcontext:    imGuiContext,\n\t\tbackend:    currentBackend,\n\t}\n\n\tcurrentBackend.SetBeforeRenderHook(mw.beforeRender)\n\tcurrentBackend.SetAfterRenderHook(mw.afterRender)\n\tcurrentBackend.SetBeforeDestroyContextHook(mw.beforeDestroy)\n\tflags.parseAndApply(currentBackend)\n\tcurrentBackend.CreateWindow(title, width, height)\n\n\tmw.SetInputHandler(newInputHandler())\n\n\tmw.backend.SetSizeChangeCallback(mw.sizeChange)\n\n\tmw.SetBgColor(colornames.Black)\n\n\t// Scale DPI in windows\n\tif runtime.GOOS == \"windows\" {\n\t\txScale, _ := Context.backend.ContentScale()\n\t\timgui.CurrentStyle().ScaleAllSizes(xScale)\n\t}\n\n\treturn mw\n}\n\nfunc (w *MasterWindow) setTheme() (fin func()) {\n\timgui.PushStyleVarFloat(imgui.StyleVarWindowRounding, 2)\n\timgui.PushStyleVarFloat(imgui.StyleVarFrameRounding, 4)\n\timgui.PushStyleVarFloat(imgui.StyleVarGrabRounding, 4)\n\timgui.PushStyleVarFloat(imgui.StyleVarFrameBorderSize, 1)\n\n\timgui.PushStyleColorVec4(imgui.ColText, imgui.Vec4{X: 0.95, Y: 0.96, Z: 0.98, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColTextDisabled, imgui.Vec4{X: 0.36, Y: 0.42, Z: 0.47, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColWindowBg, imgui.Vec4{X: 0.11, Y: 0.15, Z: 0.17, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColChildBg, imgui.Vec4{X: 0.15, Y: 0.18, Z: 0.22, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColPopupBg, imgui.Vec4{X: 0.08, Y: 0.08, Z: 0.08, W: 0.94})\n\timgui.PushStyleColorVec4(imgui.ColBorder, imgui.Vec4{X: 0.08, Y: 0.10, Z: 0.12, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColBorderShadow, imgui.Vec4{X: 0.00, Y: 0.00, Z: 0.00, W: 0.00})\n\timgui.PushStyleColorVec4(imgui.ColFrameBg, imgui.Vec4{X: 0.20, Y: 0.25, Z: 0.29, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColFrameBgHovered, imgui.Vec4{X: 0.12, Y: 0.20, Z: 0.28, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColFrameBgActive, imgui.Vec4{X: 0.09, Y: 0.12, Z: 0.14, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColTitleBg, imgui.Vec4{X: 0.09, Y: 0.12, Z: 0.14, W: 0.65})\n\timgui.PushStyleColorVec4(imgui.ColTitleBgActive, imgui.Vec4{X: 0.08, Y: 0.10, Z: 0.12, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColTitleBgCollapsed, imgui.Vec4{X: 0.00, Y: 0.00, Z: 0.00, W: 0.51})\n\timgui.PushStyleColorVec4(imgui.ColMenuBarBg, imgui.Vec4{X: 0.15, Y: 0.18, Z: 0.22, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColScrollbarBg, imgui.Vec4{X: 0.02, Y: 0.02, Z: 0.02, W: 0.39})\n\timgui.PushStyleColorVec4(imgui.ColScrollbarGrab, imgui.Vec4{X: 0.20, Y: 0.25, Z: 0.29, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColScrollbarGrabHovered, imgui.Vec4{X: 0.18, Y: 0.22, Z: 0.25, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColScrollbarGrabActive, imgui.Vec4{X: 0.09, Y: 0.21, Z: 0.31, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColCheckMark, imgui.Vec4{X: 0.28, Y: 0.56, Z: 1.00, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColSliderGrab, imgui.Vec4{X: 0.28, Y: 0.56, Z: 1.00, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColSliderGrabActive, imgui.Vec4{X: 0.37, Y: 0.61, Z: 1.00, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColButton, imgui.Vec4{X: 0.20, Y: 0.25, Z: 0.29, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColButtonHovered, imgui.Vec4{X: 0.28, Y: 0.56, Z: 1.00, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColButtonActive, imgui.Vec4{X: 0.06, Y: 0.53, Z: 0.98, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColHeader, imgui.Vec4{X: 0.20, Y: 0.25, Z: 0.29, W: 0.55})\n\timgui.PushStyleColorVec4(imgui.ColHeaderHovered, imgui.Vec4{X: 0.26, Y: 0.59, Z: 0.98, W: 0.80})\n\timgui.PushStyleColorVec4(imgui.ColHeaderActive, imgui.Vec4{X: 0.26, Y: 0.59, Z: 0.98, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColSeparator, imgui.Vec4{X: 0.20, Y: 0.25, Z: 0.29, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColSeparatorHovered, imgui.Vec4{X: 0.10, Y: 0.40, Z: 0.75, W: 0.78})\n\timgui.PushStyleColorVec4(imgui.ColSeparatorActive, imgui.Vec4{X: 0.10, Y: 0.40, Z: 0.75, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColResizeGrip, imgui.Vec4{X: 0.26, Y: 0.59, Z: 0.98, W: 0.25})\n\timgui.PushStyleColorVec4(imgui.ColResizeGripHovered, imgui.Vec4{X: 0.26, Y: 0.59, Z: 0.98, W: 0.67})\n\timgui.PushStyleColorVec4(imgui.ColResizeGripActive, imgui.Vec4{X: 0.26, Y: 0.59, Z: 0.98, W: 0.95})\n\timgui.PushStyleColorVec4(imgui.ColTab, imgui.Vec4{X: 0.11, Y: 0.15, Z: 0.17, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColTabHovered, imgui.Vec4{X: 0.26, Y: 0.59, Z: 0.98, W: 0.80})\n\timgui.PushStyleColorVec4(imgui.ColTabSelected, imgui.Vec4{X: 0.20, Y: 0.25, Z: 0.29, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColTabDimmed, imgui.Vec4{X: 0.11, Y: 0.15, Z: 0.17, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColTabDimmedSelected, imgui.Vec4{X: 0.11, Y: 0.15, Z: 0.17, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColPlotLines, imgui.Vec4{X: 0.61, Y: 0.61, Z: 0.61, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColPlotLinesHovered, imgui.Vec4{X: 1.00, Y: 0.43, Z: 0.35, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColPlotHistogram, imgui.Vec4{X: 0.90, Y: 0.70, Z: 0.00, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColPlotHistogramHovered, imgui.Vec4{X: 1.00, Y: 0.60, Z: 0.00, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColTextSelectedBg, imgui.Vec4{X: 0.26, Y: 0.59, Z: 0.98, W: 0.35})\n\timgui.PushStyleColorVec4(imgui.ColDragDropTarget, imgui.Vec4{X: 1.00, Y: 1.00, Z: 0.00, W: 0.90})\n\timgui.PushStyleColorVec4(imgui.ColNavWindowingHighlight, imgui.Vec4{X: 0.26, Y: 0.59, Z: 0.98, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColNavWindowingHighlight, imgui.Vec4{X: 1.00, Y: 1.00, Z: 1.00, W: 0.70})\n\timgui.PushStyleColorVec4(imgui.ColTableHeaderBg, imgui.Vec4{X: 0.12, Y: 0.20, Z: 0.28, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColTableBorderStrong, imgui.Vec4{X: 0.20, Y: 0.25, Z: 0.29, W: 1.00})\n\timgui.PushStyleColorVec4(imgui.ColTableBorderLight, imgui.Vec4{X: 0.20, Y: 0.25, Z: 0.29, W: 0.70})\n\n\treturn func() {\n\t\timgui.PopStyleColorV(49)\n\t\timgui.PopStyleVarV(4)\n\t}\n}\n\nfunc (w *MasterWindow) sizeChange(_, _ int) {\n\t// noop\n}\n\nfunc (w *MasterWindow) beforeRender() {\n\t// Clean callbacks\n\t// see https://github.com/AllenDang/cimgui-go?tab=readme-ov-file#callbacks\n\timmarkdown.ClearMarkdownLinkCallbackPool()\n\n\tContext.FontAtlas.rebuildFontAtlas()\n\n\t// process texture load requests\n\tif Context.textureLoadingQueue != nil && Context.textureLoadingQueue.Length() > 0 {\n\t\tfor Context.textureLoadingQueue.Length() > 0 {\n\t\t\trequest, ok := Context.textureLoadingQueue.Remove().(textureLoadRequest)\n\t\t\tAssert(ok, \"MasterWindow\", \"Run\", \"processing texture requests: wrong type of texture request\")\n\t\t\tNewTextureFromRgba(request.img, request.cb)\n\t\t}\n\t}\n\n\t// process texture free requests\n\tif Context.textureFreeingQueue != nil && Context.textureFreeingQueue.Length() > 0 {\n\t\tfor Context.textureFreeingQueue.Length() > 0 {\n\t\t\trequest, ok := Context.textureFreeingQueue.Remove().(textureFreeRequest)\n\t\t\tAssert(ok, \"MasterWindow\", \"Run\", \"processing texture requests: wrong type of texture request\")\n\t\t\trequest.tex.tex.Release()\n\t\t}\n\t}\n}\n\nfunc (w *MasterWindow) afterRender() {\n}\n\nfunc (w *MasterWindow) beforeDestroy() {\n\timplot.DestroyContext()\n\timnodes.DestroyContext()\n}\n\nfunc (w *MasterWindow) render() {\n\timguizmo.BeginFrame()\n\n\tContext.cleanStates()\n\tdefer Context.SetDirty()\n\n\tfin := w.setTheme()\n\tdefer fin()\n\n\tmainStylesheet := Style()\n\tif s, found := Context.cssStylesheet[\"main\"]; found {\n\t\tmainStylesheet = s\n\t}\n\n\tmainStylesheet.Push()\n\tw.updateFunc()\n\tmainStylesheet.Pop()\n}\n\n// Run runs the main loop.\n// loopFunc will be used to construct the ui.\n// Run should be called at the end of main function, after setting\n// up the master window.\nfunc (w *MasterWindow) Run(loopFunc func()) {\n\tmainthreadCallPlatform(func() {\n\t\tContext.isRunning = true\n\t\tw.updateFunc = loopFunc\n\n\t\tContext.m.Lock()\n\t\tContext.isAlive = true\n\t\tContext.m.Unlock()\n\n\t\tContext.backend.Run(w.render)\n\n\t\tContext.m.Lock()\n\t\tContext.isAlive = false\n\n\t\tContext.isRunning = false\n\t\tContext.m.Unlock()\n\t})\n}\n\n// GetSize return size of master window.\nfunc (w *MasterWindow) GetSize() (width, height int) {\n\tif w.backend != nil {\n\t\tw, h := w.backend.DisplaySize()\n\t\treturn int(w), int(h)\n\t}\n\n\treturn w.width, w.height\n}\n\n// SetBgColor sets background color of master window.\nfunc (w *MasterWindow) SetBgColor(bgColor color.Color) {\n\tconst mask = 0xffff\n\n\tr, g, b, a := bgColor.RGBA()\n\tw.clearColor = imgui.Vec4{\n\t\tX: float32(r) / mask,\n\t\tY: float32(g) / mask,\n\t\tZ: float32(b) / mask,\n\t\tW: float32(a) / mask,\n\t}\n\n\tw.backend.SetBgColor(w.clearColor)\n}\n\n// SetTargetFPS sets target FPS of master window.\n// Default for GLFW is 30.\nfunc (w *MasterWindow) SetTargetFPS(fps uint) {\n\tw.backend.SetTargetFPS(fps)\n}\n\n// GetPos return position of master window.\nfunc (w *MasterWindow) GetPos() (x, y int) {\n\tvar xResult, yResult int32\n\tif w.backend != nil {\n\t\txResult, yResult = w.backend.GetWindowPos()\n\t}\n\n\treturn int(xResult), int(yResult)\n}\n\n// SetPos sets position of master window.\nfunc (w *MasterWindow) SetPos(x, y int) {\n\tif w.backend != nil {\n\t\tw.backend.SetWindowPos(x, y)\n\t}\n}\n\n// SetSize sets size of master window.\nfunc (w *MasterWindow) SetSize(x, y int) {\n\tif w.backend != nil {\n\t\tw.backend.SetWindowSize(x, y)\n\t}\n}\n\n// SetCloseCallback sets the close callback of the window, which is called when\n// the user attempts to close the window, for example by clicking the close\n// widget in the title bar.\n//\n// The close flag is set before this callback is called, but you can modify it at\n// any time with returned value of callback function.\n//\n// Mac OS X: Selecting Quit from the application menu will trigger the close\n// callback for all windows.\nfunc (w *MasterWindow) SetCloseCallback(cb func() bool) {\n\tw.backend.SetCloseCallback(func() {\n\t\tw.backend.SetShouldClose(cb())\n\t})\n}\n\n// SetDropCallback sets callback when file was dropped into the window.\nfunc (w *MasterWindow) SetDropCallback(cb func([]string)) {\n\tw.backend.SetDropCallback(cb)\n}\n\n// RegisterKeyboardShortcuts registers a global - master window - keyboard shortcuts.\nfunc (w *MasterWindow) RegisterKeyboardShortcuts(s ...WindowShortcut) *MasterWindow {\n\tfor _, shortcut := range s {\n\t\tContext.InputHandler.RegisterKeyboardShortcuts(Shortcut{\n\t\t\tKey:      shortcut.Key,\n\t\t\tModifier: shortcut.Modifier,\n\t\t\tCallback: shortcut.Callback,\n\t\t\tIsGlobal: GlobalShortcut,\n\t\t})\n\t}\n\n\treturn w\n}\n\n// SetIcon sets the icon of the specified window. If passed an array of candidate images,\n// those of or closest to the sizes desired by the system are selected. If no images are\n// specified, the window reverts to its default icon.\n//\n// The image is ideally provided in the form of *image.NRGBA.\n// The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight\n// bits per channel with the red channel first. They are arranged canonically\n// as packed sequential rows, starting from the top-left corner. If the image\n// type is not *image.NRGBA, it will be converted to it.\n//\n// The desired image sizes varies depending on platform and system settings. The selected\n// images will be rescaled as needed. Good sizes include 16x16, 32x32 and 48x48.\nfunc (w *MasterWindow) SetIcon(icons ...image.Image) {\n\tw.backend.SetIcons(icons...)\n}\n\n// SetSizeLimits sets the size limits of the client area of the specified window.\n// If the window is full screen or not resizable, this function does nothing.\n//\n// The size limits are applied immediately and may cause the window to be resized.\n// To specify only a minimum size or only a maximum one, set the other pair to giu.DontCare.\n// To disable size limits for a window, set them all to giu.DontCare.\nfunc (w *MasterWindow) SetSizeLimits(minw, minh, maxw, maxh int) {\n\tw.backend.SetWindowSizeLimits(minw, minh, maxw, maxh)\n}\n\n// SetTitle updates master window's title.\nfunc (w *MasterWindow) SetTitle(title string) {\n\tw.backend.SetWindowTitle(title)\n}\n\n// Close will safely close the master window.\nfunc (w *MasterWindow) Close() {\n\tw.SetShouldClose(true)\n}\n\n// SetShouldClose sets whether master window should be closed.\nfunc (w *MasterWindow) SetShouldClose(v bool) {\n\tw.backend.SetShouldClose(v)\n}\n\n// SetInputHandler allows to change default input handler.\n// see InputHandler.go.\nfunc (w *MasterWindow) SetInputHandler(handler InputHandler) {\n\tContext.InputHandler = handler\n\n\tw.backend.SetKeyCallback(func(key, _, action, modifier int) {\n\t\tk, m, a := keyFromGLFWKey(glfwbackend.GLFWKey(key)), Modifier(modifier), Action(action)\n\t\thandler.Handle(k, m, a)\n\n\t\tif w.additionalInputCallback != nil {\n\t\t\tw.additionalInputCallback(k, m, a)\n\t\t}\n\t})\n}\n\n// SetAdditionalInputHandlerCallback allows to set an input callback to handle more events (not only these from giu.inputHandler).\n// See examples/issue-501.\nfunc (w *MasterWindow) SetAdditionalInputHandlerCallback(cb InputHandlerHandleCallback) {\n\tw.additionalInputCallback = cb\n}\n"
        },
        {
          "name": "MemoryEditor.go",
          "type": "blob",
          "size": 1.5166015625,
          "content": "package giu\n\n//\n// import (\n//\n//\t\"github.com/AllenDang/cimgui-go\"\n//\n// )\n//\n//\ttype memoryEditorState struct {\n//\t\teditor imgui.MemoryEditor\n//\t}\n//\n// // Dispose implements Disposable interface.\n//\n//\tfunc (s *memoryEditorState) Dispose() {\n//\t\t// noop\n//\t}\n//\n// // MemoryEditorWidget - Mini memory editor for Dear ImGui\n// // (to embed in your game/tools)\n// //\n// // Right-click anywhere to access the Options menu!\n// // You can adjust the keyboard repeat delay/rate in ImGuiIO.\n// // The code assume a mono-space font for simplicity!\n// // If you don't use the default font, use ImGui::PushFont()/PopFont() to switch to a mono-space font before calling this.\n//\n//\ttype MemoryEditorWidget struct {\n//\t\tid       string\n//\t\tcontents []byte\n//\t}\n//\n// // MemoryEditor creates nwe memory editor widget.\n//\n//\tfunc MemoryEditor() *MemoryEditorWidget {\n//\t\treturn &MemoryEditorWidget{\n//\t\t\tid: GenAutoID(\"memoryEditor\"),\n//\t\t}\n//\t}\n//\n// // Contents sets editor's contents.\n//\n//\tfunc (me *MemoryEditorWidget) Contents(contents []byte) *MemoryEditorWidget {\n//\t\tme.contents = contents\n//\t\treturn me\n//\t}\n//\n// // Build implements widget interface.\n//\n//\tfunc (me *MemoryEditorWidget) Build() {\n//\t\tme.getState().editor.DrawContents(me.contents)\n//\t}\n//\n//\tfunc (me *MemoryEditorWidget) getState() (state *memoryEditorState) {\n//\t\tif state = GetState[memoryEditorState](Context, me.id); state == nil {\n//\t\t\tstate = &memoryEditorState{\n//\t\t\t\teditor: imgui.NewMemoryEditor(),\n//\t\t\t}\n//\n//\t\t\tSetState(Context, me.id, state)\n//\t\t}\n//\n//\t\treturn state\n//\t}\n"
        },
        {
          "name": "Msgbox.go",
          "type": "blob",
          "size": 4.2119140625,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// DialogResult represents dialog result\n// dialog result is bool. if OK/Yes it is true, else (Cancel/No) - false.\ntype DialogResult bool\n\n// dialog results.\nconst (\n\tDialogResultOK     DialogResult = true\n\tDialogResultCancel DialogResult = false\n\n\tDialogResultYes = DialogResultOK\n\tDialogResultNo  = DialogResultCancel\n)\n\n// MsgboxButtons determines which buttons are in the dialog.\ntype MsgboxButtons uint8\n\n// button sets.\nconst (\n\t// Yes-No question.\n\tMsgboxButtonsYesNo MsgboxButtons = 1 << iota\n\t// Ok / Cancel dialog.\n\tMsgboxButtonsOkCancel\n\t// info.\n\tMsgboxButtonsOk\n)\n\n// DialogResultCallback is a callback for dialogs.\ntype DialogResultCallback func(DialogResult)\n\nvar _ Disposable = &msgboxState{}\n\ntype msgboxState struct {\n\ttitle          string\n\tcontent        string\n\tresultCallback DialogResultCallback\n\tbuttons        MsgboxButtons\n\topen           bool\n\tm              *sync.Mutex\n}\n\n// Dispose implements disposable interface.\nfunc (ms *msgboxState) Dispose() {\n\t// Nothing to do here.\n}\n\nfunc msgboxInvokeCallback(result DialogResult, callback DialogResultCallback) {\n\tCloseCurrentPopup()\n\n\tif callback != nil {\n\t\tcallback(result)\n\t}\n}\n\nfunc buildMsgboxButtons(buttons MsgboxButtons, callback DialogResultCallback) Layout {\n\tswitch buttons {\n\tcase MsgboxButtonsOk:\n\t\treturn Layout{\n\t\t\tButton(\" Ok \").OnClick(func() {\n\t\t\t\tmsgboxInvokeCallback(DialogResultOK, callback)\n\t\t\t}),\n\t\t}\n\tcase MsgboxButtonsOkCancel:\n\t\treturn Layout{\n\t\t\tRow(\n\t\t\t\tButton(\"  Ok  \").OnClick(func() {\n\t\t\t\t\tmsgboxInvokeCallback(DialogResultOK, callback)\n\t\t\t\t}),\n\t\t\t\tButton(\"Cancel\").OnClick(func() {\n\t\t\t\t\tmsgboxInvokeCallback(DialogResultCancel, callback)\n\t\t\t\t}),\n\t\t\t),\n\t\t}\n\tcase MsgboxButtonsYesNo:\n\t\treturn Layout{\n\t\t\tRow(\n\t\t\t\tButton(\" Yes \").OnClick(func() {\n\t\t\t\t\tmsgboxInvokeCallback(DialogResultYes, callback)\n\t\t\t\t}),\n\t\t\t\tButton(\"  No  \").OnClick(func() {\n\t\t\t\t\tmsgboxInvokeCallback(DialogResultNo, callback)\n\t\t\t\t}),\n\t\t\t),\n\t\t}\n\tdefault:\n\t\treturn Layout{\n\t\t\tButton(\"  Ok  \").OnClick(func() {\n\t\t\t\tmsgboxInvokeCallback(DialogResultOK, callback)\n\t\t\t}),\n\t\t}\n\t}\n}\n\nconst msgboxID ID = \"###Msgbox\"\n\n// PrepareMsgbox should be invoked in function in the same layout level where you call g.Msgbox.\n// BUG: calling this more than 1 time per frame causes unexpected\n// merging msgboxes layouts (see https://github.com/AllenDang/giu/issues/290)\nfunc PrepareMsgbox() Layout {\n\treturn Layout{\n\t\tCustom(func() {\n\t\t\tvar state *msgboxState\n\n\t\t\t// Register state.\n\t\t\tif state = GetState[msgboxState](Context, msgboxID); state == nil {\n\t\t\t\tstate = &msgboxState{\n\t\t\t\t\ttitle:          \"Info\",\n\t\t\t\t\tcontent:        \"Content\",\n\t\t\t\t\tbuttons:        MsgboxButtonsOk,\n\t\t\t\t\tresultCallback: nil,\n\t\t\t\t\topen:           false,\n\t\t\t\t\tm:              &sync.Mutex{},\n\t\t\t\t}\n\t\t\t\tSetState(Context, msgboxID, state)\n\t\t\t}\n\n\t\t\tstate.m.Lock()\n\t\t\tif state.open {\n\t\t\t\tOpenPopup(msgboxID.String())\n\t\t\t\tstate.open = false\n\t\t\t}\n\n\t\t\tstate.m.Unlock()\n\n\t\t\tSetNextWindowSize(300, 0)\n\t\t\tPopupModal(fmt.Sprintf(\"%s%s\", state.title, msgboxID)).Layout(\n\t\t\t\tCustom(func() {\n\t\t\t\t\t// Ensure the state is valid.\n\t\t\t\t\tGetState[msgboxState](Context, msgboxID)\n\t\t\t\t}),\n\t\t\t\tLabel(state.content).Wrapped(true),\n\t\t\t\tbuildMsgboxButtons(state.buttons, state.resultCallback),\n\t\t\t).Build()\n\t\t}),\n\t}\n}\n\n// MsgboxWidget represents message dialog.\ntype MsgboxWidget struct{}\n\nfunc (m *MsgboxWidget) getState() *msgboxState {\n\tstate := GetState[msgboxState](Context, msgboxID)\n\tif state == nil {\n\t\tpanic(\"Msgbox is not prepared. Invoke giu.PrepareMsgbox in the end of the layout.\")\n\t}\n\n\treturn state\n}\n\n// Msgbox opens message box.\n// call it whenever you want to open popup with\n// question / info.\nfunc Msgbox(title, content string) *MsgboxWidget {\n\tresult := &MsgboxWidget{}\n\n\tstate := result.getState()\n\tstate.title = title\n\tstate.content = content\n\n\tstate.buttons = MsgboxButtonsOk\n\tstate.resultCallback = nil\n\n\tstate.open = true\n\n\treturn result\n}\n\n// Buttons sets which buttons should be possible.\nfunc (m *MsgboxWidget) Buttons(buttons MsgboxButtons) *MsgboxWidget {\n\ts := m.getState()\n\ts.m.Lock()\n\ts.buttons = buttons\n\ts.m.Unlock()\n\n\treturn m\n}\n\n// ResultCallback sets result callback.\nfunc (m *MsgboxWidget) ResultCallback(cb DialogResultCallback) *MsgboxWidget {\n\ts := m.getState()\n\ts.m.Lock()\n\ts.resultCallback = cb\n\ts.m.Unlock()\n\n\treturn m\n}\n"
        },
        {
          "name": "Plot.go",
          "type": "blob",
          "size": 13.3935546875,
          "content": "package giu\n\nimport (\n\t\"image\"\n\n\t\"github.com/AllenDang/cimgui-go/implot\"\n\t\"github.com/AllenDang/cimgui-go/utils\"\n)\n\ntype (\n\t// PlotXAxis allows to chose X axis.\n\tPlotXAxis = implot.AxisEnum\n\t// PlotYAxis allows to chose Y axis.\n\tPlotYAxis = implot.AxisEnum\n)\n\n// Available axes.\nconst (\n\tAxisX1 = implot.AxisX1\n\tAxisX2 = implot.AxisX2\n\tAxisX3 = implot.AxisX3\n\tAxisY1 = implot.AxisY1\n\tAxisY2 = implot.AxisY2\n\tAxisY3 = implot.AxisY3\n)\n\n// PlotWidget is implemented by all the particular plots, which can be used\n// in (*PlotCanvasWidget).Plots.\ntype PlotWidget interface {\n\tPlot()\n}\n\n// ImPlotYAxis represents y axis settings.\ntype ImPlotYAxis int\n\n// ImPlotYAxis enum:.\nconst (\n\tImPlotYAxisLeft          ImPlotYAxis = 0 // left (default)\n\tImPlotYAxisFirstOnRight  ImPlotYAxis = 1 // first on right side\n\tImPlotYAxisSecondOnRight ImPlotYAxis = 2 // second on right side\n)\n\n// PlotTicker represents axis ticks.\ntype PlotTicker struct {\n\tPosition float64\n\tLabel    string\n}\n\n// PlotCanvasWidget represents a giu plot widget.\ntype PlotCanvasWidget struct {\n\ttitle                            string\n\txLabel                           string\n\tyLabel                           string\n\twidth                            int\n\theight                           int\n\tflags                            PlotFlags\n\txFlags, yFlags, y2Flags, y3Flags PlotAxisFlags\n\ty2Label                          string\n\ty3Label                          string\n\txMin, xMax, yMin, yMax           float64\n\taxisLimitCondition               ExecCondition\n\txTicksValue, yTicksValue         []float64\n\txTicksLabel, yTicksLabel         []string\n\txTicksShowDefault                bool\n\tyTicksShowDefault                bool\n\tyTicksYAxis                      ImPlotYAxis\n\tplots                            []PlotWidget\n}\n\n// Plot adds creates a new plot widget.\nfunc Plot(title string) *PlotCanvasWidget {\n\treturn &PlotCanvasWidget{\n\t\ttitle:              title,\n\t\txLabel:             \"\",\n\t\tyLabel:             \"\",\n\t\twidth:              -1,\n\t\theight:             0,\n\t\tflags:              PlotFlagsNone,\n\t\txFlags:             PlotAxisFlagsNone,\n\t\tyFlags:             PlotAxisFlagsNone,\n\t\ty2Flags:            PlotAxisFlagsNoGridLines,\n\t\ty3Flags:            PlotAxisFlagsNoGridLines,\n\t\ty2Label:            \"\",\n\t\ty3Label:            \"\",\n\t\txMin:               0,\n\t\txMax:               10,\n\t\tyMin:               0,\n\t\tyMax:               10,\n\t\txTicksShowDefault:  true,\n\t\tyTicksShowDefault:  true,\n\t\tyTicksYAxis:        0,\n\t\taxisLimitCondition: ConditionOnce,\n\t}\n}\n\n// SetXAxisLabel sets x axis label.\nfunc (p *PlotCanvasWidget) SetXAxisLabel(axis PlotXAxis, label string) *PlotCanvasWidget {\n\tswitch axis {\n\tcase AxisX1:\n\t\tp.xLabel = label\n\tcase AxisX2:\n\t\tp.y2Label = label\n\tcase AxisX3:\n\t\tp.y3Label = label\n\t}\n\n\treturn p\n}\n\n// SetYAxisLabel sets y axis label.\nfunc (p *PlotCanvasWidget) SetYAxisLabel(axis PlotYAxis, label string) *PlotCanvasWidget {\n\tswitch axis {\n\tcase AxisY1:\n\t\tp.yLabel = label\n\tcase AxisY2:\n\t\tp.y2Label = label\n\tcase AxisY3:\n\t\tp.y3Label = label\n\t}\n\n\treturn p\n}\n\n// AxisLimits sets X and Y axis limits.\nfunc (p *PlotCanvasWidget) AxisLimits(xmin, xmax, ymin, ymax float64, cond ExecCondition) *PlotCanvasWidget {\n\tp.xMin = xmin\n\tp.xMax = xmax\n\tp.yMin = ymin\n\tp.yMax = ymax\n\tp.axisLimitCondition = cond\n\n\treturn p\n}\n\n// XTicks sets x axis ticks.\nfunc (p *PlotCanvasWidget) XTicks(ticks []PlotTicker, showDefault bool) *PlotCanvasWidget {\n\tlength := len(ticks)\n\tif length == 0 {\n\t\treturn p\n\t}\n\n\tvalues := make([]float64, length)\n\tlabels := make([]string, length)\n\n\tfor i, t := range ticks {\n\t\tvalues[i] = t.Position\n\t\tlabels[i] = t.Label\n\t}\n\n\tp.xTicksValue = values\n\tp.xTicksLabel = labels\n\tp.xTicksShowDefault = showDefault\n\n\treturn p\n}\n\n// YTicks sets y axis ticks.\nfunc (p *PlotCanvasWidget) YTicks(ticks []PlotTicker, showDefault bool, yAxis ImPlotYAxis) *PlotCanvasWidget {\n\tlength := len(ticks)\n\tif length == 0 {\n\t\treturn p\n\t}\n\n\tvalues := make([]float64, length)\n\tlabels := make([]string, length)\n\n\tfor i, t := range ticks {\n\t\tvalues[i] = t.Position\n\t\tlabels[i] = t.Label\n\t}\n\n\tp.yTicksValue = values\n\tp.yTicksLabel = labels\n\tp.yTicksShowDefault = showDefault\n\tp.yTicksYAxis = yAxis\n\n\treturn p\n}\n\n// Flags sets plot canvas flags.\nfunc (p *PlotCanvasWidget) Flags(flags PlotFlags) *PlotCanvasWidget {\n\tp.flags = flags\n\treturn p\n}\n\n// XAxeFlags sets x axis fags.\nfunc (p *PlotCanvasWidget) XAxeFlags(flags PlotAxisFlags) *PlotCanvasWidget {\n\tp.xFlags = flags\n\treturn p\n}\n\n// YAxeFlags sets y axis flags.\nfunc (p *PlotCanvasWidget) YAxeFlags(yFlags, y2Flags, y3Flags PlotAxisFlags) *PlotCanvasWidget {\n\tp.yFlags = yFlags\n\tp.y2Flags = y2Flags\n\tp.y3Flags = y3Flags\n\n\treturn p\n}\n\n// Plots adds plots to plot canvas.\nfunc (p *PlotCanvasWidget) Plots(plots ...PlotWidget) *PlotCanvasWidget {\n\tp.plots = plots\n\treturn p\n}\n\n// Size set canvas size.\nfunc (p *PlotCanvasWidget) Size(width, height int) *PlotCanvasWidget {\n\tp.width = width\n\tp.height = height\n\n\treturn p\n}\n\n// Build implements Widget interface.\nfunc (p *PlotCanvasWidget) Build() {\n\tif len(p.plots) == 0 {\n\t\treturn\n\t}\n\n\tif implot.BeginPlotV(\n\t\tContext.FontAtlas.RegisterString(p.title),\n\t\tToVec2(image.Pt(p.width, p.height)),\n\t\timplot.Flags(p.flags),\n\t) {\n\t\timplot.SetupAxisLimitsV(\n\t\t\timplot.AxisX1,\n\t\t\tp.xMin,\n\t\t\tp.xMax,\n\t\t\timplot.Cond(p.axisLimitCondition),\n\t\t)\n\t\timplot.SetupAxisLimitsV(\n\t\t\timplot.AxisY1,\n\t\t\tp.yMin,\n\t\t\tp.yMax,\n\t\t\timplot.Cond(p.axisLimitCondition),\n\t\t)\n\n\t\tif len(p.xTicksValue) > 0 {\n\t\t\timplot.SetupAxisTicksdoublePtrV(\n\t\t\t\timplot.AxisX1,\n\t\t\t\tutils.SliceToPtr(p.xTicksValue),\n\t\t\t\tint32(len(p.xTicksValue)),\n\t\t\t\tp.xTicksLabel,\n\t\t\t\tp.xTicksShowDefault,\n\t\t\t)\n\t\t}\n\n\t\tif len(p.yTicksValue) > 0 {\n\t\t\timplot.SetupAxisTicksdoublePtrV(\n\t\t\t\timplot.AxisY1,\n\t\t\t\tutils.SliceToPtr(p.yTicksValue),\n\t\t\t\tint32(len(p.yTicksValue)),\n\t\t\t\tp.yTicksLabel,\n\t\t\t\tp.yTicksShowDefault,\n\t\t\t)\n\t\t}\n\n\t\timplot.SetupAxisV(\n\t\t\timplot.AxisX1,\n\t\t\tContext.FontAtlas.RegisterString(p.xLabel),\n\t\t\timplot.AxisFlags(p.xFlags),\n\t\t)\n\n\t\timplot.SetupAxisV(\n\t\t\timplot.AxisY1,\n\t\t\tContext.FontAtlas.RegisterString(p.yLabel),\n\t\t\timplot.AxisFlags(p.yFlags),\n\t\t)\n\n\t\tif p.y2Label != \"\" {\n\t\t\timplot.SetupAxisV(\n\t\t\t\timplot.AxisY2,\n\t\t\t\tContext.FontAtlas.RegisterString(p.y2Label),\n\t\t\t\timplot.AxisFlags(p.y2Flags),\n\t\t\t)\n\t\t}\n\n\t\tif p.y3Label != \"\" {\n\t\t\timplot.SetupAxisV(\n\t\t\t\timplot.AxisY3,\n\t\t\t\tContext.FontAtlas.RegisterString(p.y3Label),\n\t\t\t\timplot.AxisFlags(p.y3Flags),\n\t\t\t)\n\t\t}\n\n\t\tfor _, plot := range p.plots {\n\t\t\tplot.Plot()\n\t\t}\n\n\t\timplot.EndPlot()\n\t}\n}\n\n// SwitchPlotAxes switches plot axes.\nfunc SwitchPlotAxes(x PlotXAxis, y PlotYAxis) PlotWidget {\n\treturn Custom(func() {\n\t\timplot.SetAxes(x, y)\n\t})\n}\n\n// BarPlot adds bar plot (column chart) to the canvas.\ntype BarPlot struct {\n\ttitle  string\n\tdata   []float64\n\twidth  float64\n\tshift  float64\n\toffset int\n}\n\n// Bar adds plot bars to the canvas.\nfunc Bar(title string, data []float64) *BarPlot {\n\treturn &BarPlot{\n\t\ttitle:  title,\n\t\tdata:   data,\n\t\twidth:  0.2,\n\t\tshift:  0,\n\t\toffset: 0,\n\t}\n}\n\n// Width sets bar width.\nfunc (p *BarPlot) Width(width float64) *BarPlot {\n\tp.width = width\n\treturn p\n}\n\n// Shift sets shift of the bar.\nfunc (p *BarPlot) Shift(shift float64) *BarPlot {\n\tp.shift = shift\n\treturn p\n}\n\n// Offset sets bar's offset.\nfunc (p *BarPlot) Offset(offset int) *BarPlot {\n\tp.offset = offset\n\treturn p\n}\n\n// Plot implements Plot interface.\nfunc (p *BarPlot) Plot() {\n\timplot.PlotBarsdoublePtrIntV(\n\t\tp.title,\n\t\tutils.SliceToPtr(p.data),\n\t\tint32(len(p.data)),\n\t\tp.width,\n\t\tp.shift,\n\t\t0, // TODO: implement\n\t\tint32(p.offset),\n\t\t8, // in fact this is sizeof(double) = 8\n\t)\n}\n\n// BarHPlot represents a column chart on Y axis.\ntype BarHPlot struct {\n\ttitle  string\n\tdata   []float64\n\theight float64\n\tshift  float64\n\toffset int\n}\n\n// BarH adds plot bars on y axis.\nfunc BarH(title string, data []float64) *BarHPlot {\n\treturn &BarHPlot{\n\t\ttitle:  title,\n\t\tdata:   data,\n\t\theight: 0.2,\n\t\tshift:  0,\n\t\toffset: 0,\n\t}\n}\n\n// Height sets bar height (in fact bars' width).\nfunc (p *BarHPlot) Height(height float64) *BarHPlot {\n\tp.height = height\n\treturn p\n}\n\n// Shift sets shift.\nfunc (p *BarHPlot) Shift(shift float64) *BarHPlot {\n\tp.shift = shift\n\treturn p\n}\n\n// Offset sets offset.\nfunc (p *BarHPlot) Offset(offset int) *BarHPlot {\n\tp.offset = offset\n\treturn p\n}\n\n// Plot implements plot interface.\nfunc (p *BarHPlot) Plot() {\n\timplot.PlotBarsdoublePtrIntV(\n\t\tContext.FontAtlas.RegisterString(p.title),\n\t\tutils.SliceToPtr(p.data),\n\t\tint32(len(p.data)),\n\t\tp.height,\n\t\tp.shift,\n\t\timplot.BarsFlagsHorizontal,\n\t\tint32(p.offset),\n\t\t0,\n\t)\n}\n\n// LinePlot represents a plot line (linear chart).\ntype LinePlot struct {\n\ttitle      string\n\tvalues     []float64\n\txScale, x0 float64\n\toffset     int\n\tyAxis      ImPlotYAxis\n}\n\n// Line adds a new plot line to the canvas.\nfunc Line(title string, values []float64) *LinePlot {\n\treturn &LinePlot{\n\t\ttitle:  title,\n\t\tvalues: values,\n\t\txScale: 1,\n\t\tx0:     0,\n\t\toffset: 0,\n\t}\n}\n\n// SetPlotYAxis sets yAxis parameters.\nfunc (p *LinePlot) SetPlotYAxis(yAxis ImPlotYAxis) *LinePlot {\n\tp.yAxis = yAxis\n\treturn p\n}\n\n// XScale sets x-axis-scale.\nfunc (p *LinePlot) XScale(scale float64) *LinePlot {\n\tp.xScale = scale\n\treturn p\n}\n\n// X0 sets a start position on x axis.\nfunc (p *LinePlot) X0(x0 float64) *LinePlot {\n\tp.x0 = x0\n\treturn p\n}\n\n// Offset sets chart offset.\nfunc (p *LinePlot) Offset(offset int) *LinePlot {\n\tp.offset = offset\n\treturn p\n}\n\n// Plot implements Plot interface.\nfunc (p *LinePlot) Plot() {\n\timplot.SetAxis(\n\t\timplot.AxisEnum(p.yAxis),\n\t)\n\n\timplot.PlotLinedoublePtrIntV(\n\t\tContext.FontAtlas.RegisterString(p.title),\n\t\tutils.SliceToPtr(p.values),\n\t\tint32(len(p.values)),\n\t\tp.xScale,\n\t\tp.x0,\n\t\t0, // flags\n\t\tint32(p.offset),\n\t\t8, // in fact this is sizeof(double) = 8\n\t)\n}\n\n// LineXYPlot adds XY plot line.\ntype LineXYPlot struct {\n\ttitle  string\n\txs, ys []float64\n\toffset int\n\tyAxis  ImPlotYAxis\n}\n\n// LineXY adds XY plot line to canvas.\nfunc LineXY(title string, xvalues, yvalues []float64) *LineXYPlot {\n\treturn &LineXYPlot{\n\t\ttitle:  title,\n\t\txs:     xvalues,\n\t\tys:     yvalues,\n\t\toffset: 0,\n\t}\n}\n\n// SetPlotYAxis sets yAxis parameters.\nfunc (p *LineXYPlot) SetPlotYAxis(yAxis ImPlotYAxis) *LineXYPlot {\n\tp.yAxis = yAxis\n\treturn p\n}\n\n// Offset sets chart's offset.\nfunc (p *LineXYPlot) Offset(offset int) *LineXYPlot {\n\tp.offset = offset\n\treturn p\n}\n\n// Plot implements Plot interface.\nfunc (p *LineXYPlot) Plot() {\n\timplot.SetAxis(implot.AxisEnum(p.yAxis))\n\timplot.PlotLinedoublePtrdoublePtrV(\n\t\tContext.FontAtlas.RegisterString(p.title),\n\t\tutils.SliceToPtr(p.xs),\n\t\tutils.SliceToPtr(p.ys),\n\t\tint32(len(p.xs)),\n\t\t0, // flags\n\t\tint32(p.offset),\n\t\t8, // in fact this is sizeof(double) = 8\n\t)\n}\n\n// PieChartPlot represents a pie chart.\n// TODO: support PlotPieChartFlags.\ntype PieChartPlot struct {\n\tlabels       []string\n\tvalues       []float64\n\tx, y, radius float64\n\tnormalize    bool\n\tlabelFormat  string\n\tangle0       float64\n}\n\n// PieChart adds pie chart to the canvas.\nfunc PieChart(labels []string, values []float64, x, y, radius float64) *PieChartPlot {\n\treturn &PieChartPlot{\n\t\tlabels:      labels,\n\t\tvalues:      values,\n\t\tx:           x,\n\t\ty:           y,\n\t\tradius:      radius,\n\t\tnormalize:   false,\n\t\tlabelFormat: \"%.1f\",\n\t\tangle0:      90,\n\t}\n}\n\n// Normalize sets normalize flag.\nfunc (p *PieChartPlot) Normalize(n bool) *PieChartPlot {\n\tp.normalize = n\n\treturn p\n}\n\n// LabelFormat sets format of labels.\nfunc (p *PieChartPlot) LabelFormat(fmtStr string) *PieChartPlot {\n\tp.labelFormat = fmtStr\n\treturn p\n}\n\n// Angle0 sets start angle.\nfunc (p *PieChartPlot) Angle0(a float64) *PieChartPlot {\n\tp.angle0 = a\n\treturn p\n}\n\n// Plot implements Plot interface.\nfunc (p *PieChartPlot) Plot() {\n\tvar flags implot.PieChartFlags\n\tif p.normalize {\n\t\tflags |= implot.PieChartFlagsNormalize\n\t}\n\n\timplot.PlotPieChartdoublePtrStrV(\n\t\tContext.FontAtlas.RegisterStringSlice(p.labels),\n\t\tutils.SliceToPtr(p.values),\n\t\tint32(len(p.values)),\n\t\tp.x,\n\t\tp.y,\n\t\tp.radius,\n\t\tp.labelFormat,\n\t\tp.angle0,\n\t\tflags,\n\t)\n}\n\n// ScatterPlot represents a scatter plot.\ntype ScatterPlot struct {\n\tlabel      string\n\tvalues     []float64\n\txscale, x0 float64\n\toffset     int\n}\n\n// Scatter adds scatter plot to the canvas.\nfunc Scatter(label string, values []float64) *ScatterPlot {\n\treturn &ScatterPlot{\n\t\tlabel:  label,\n\t\tvalues: values,\n\t\txscale: 1,\n\t\tx0:     0,\n\t\toffset: 0,\n\t}\n}\n\n// XScale sets x-axis scale.\nfunc (p *ScatterPlot) XScale(s float64) *ScatterPlot {\n\tp.xscale = s\n\treturn p\n}\n\n// X0 sets start position on x axis.\nfunc (p *ScatterPlot) X0(x float64) *ScatterPlot {\n\tp.x0 = x\n\treturn p\n}\n\n// Offset sets chart offset.\nfunc (p *ScatterPlot) Offset(offset int) *ScatterPlot {\n\tp.offset = offset\n\treturn p\n}\n\n// Plot implements Plot interface.\nfunc (p *ScatterPlot) Plot() {\n\timplot.PlotScatterdoublePtrIntV(\n\t\tContext.FontAtlas.RegisterString(p.label),\n\t\tutils.SliceToPtr(p.values),\n\t\tint32(len(p.values)),\n\t\tp.xscale,\n\t\tp.x0,\n\t\t0, // TODO: implement flags\n\t\tint32(p.offset),\n\t\t8, // in fact this is sizeof(double) = 8\n\t)\n}\n\n// ScatterXYPlot represents a scatter plot with possibility to set x and y values.\ntype ScatterXYPlot struct {\n\tlabel  string\n\txs, ys []float64\n\toffset int\n}\n\n// ScatterXY adds scatter plot with x and y values.\nfunc ScatterXY(label string, xs, ys []float64) *ScatterXYPlot {\n\treturn &ScatterXYPlot{\n\t\tlabel:  label,\n\t\txs:     xs,\n\t\tys:     ys,\n\t\toffset: 0,\n\t}\n}\n\n// Offset sets chart offset.\nfunc (p *ScatterXYPlot) Offset(offset int) *ScatterXYPlot {\n\tp.offset = offset\n\treturn p\n}\n\n// Plot implements Plot interface.\nfunc (p *ScatterXYPlot) Plot() {\n\timplot.PlotScatterdoublePtrdoublePtrV(\n\t\tContext.FontAtlas.RegisterString(p.label),\n\t\tutils.SliceToPtr(p.xs),\n\t\tutils.SliceToPtr(p.ys),\n\t\tint32(len(p.xs)),\n\t\t0, // TODO: implement\n\t\tint32(p.offset),\n\t\t8, // in fact this is sizeof(double) = 8\n\t)\n}\n"
        },
        {
          "name": "Popups.go",
          "type": "blob",
          "size": 2.44140625,
          "content": "package giu\n\nimport (\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// OpenPopup opens a popup with specified id.\n// NOTE: you need to build this popup first (see Pop(Modal)Widget).\nfunc OpenPopup(name string) {\n\timgui.OpenPopupStr(name)\n}\n\n// CloseCurrentPopup closes currently opened popup.\n// If no popups opened, no action will be taken.\nfunc CloseCurrentPopup() {\n\timgui.CloseCurrentPopup()\n}\n\nvar _ Widget = &PopupWidget{}\n\n// PopupWidget  is a window which appears next to the mouse cursor.\n// For instance it is used to display color palette in ColorSelectWidget.\ntype PopupWidget struct {\n\tname   string\n\tflags  WindowFlags\n\tlayout Layout\n}\n\n// Popup creates new popup widget.\nfunc Popup(name string) *PopupWidget {\n\treturn &PopupWidget{\n\t\tname:   Context.FontAtlas.RegisterString(name),\n\t\tflags:  0,\n\t\tlayout: nil,\n\t}\n}\n\n// Flags sets popup's flags.\nfunc (p *PopupWidget) Flags(flags WindowFlags) *PopupWidget {\n\tp.flags = flags\n\treturn p\n}\n\n// Layout sets popup's layout.\nfunc (p *PopupWidget) Layout(widgets ...Widget) *PopupWidget {\n\tp.layout = Layout(widgets)\n\treturn p\n}\n\n// Build implements Widget interface.\nfunc (p *PopupWidget) Build() {\n\tif imgui.BeginPopupV(p.name, imgui.WindowFlags(p.flags)) {\n\t\tp.layout.Build()\n\t\timgui.EndPopup()\n\t}\n}\n\nvar _ Widget = &PopupModalWidget{}\n\n// PopupModalWidget is a popup window that block every interactions behind it, cannot be closed by\n// user, adds a dimming background, has a title bar.\ntype PopupModalWidget struct {\n\tname   string\n\topen   *bool\n\tflags  WindowFlags\n\tlayout Layout\n}\n\n// PopupModal creates new popup modal widget.\nfunc PopupModal(name string) *PopupModalWidget {\n\treturn &PopupModalWidget{\n\t\tname:   Context.FontAtlas.RegisterString(name),\n\t\topen:   nil,\n\t\tflags:  WindowFlagsNoResize,\n\t\tlayout: nil,\n\t}\n}\n\n// IsOpen allows to control popup's state\n// NOTE: changing opens' value will not result in changing popup's state\n// if OpenPopup(...) wasn't called!\nfunc (p *PopupModalWidget) IsOpen(open *bool) *PopupModalWidget {\n\tp.open = open\n\treturn p\n}\n\n// Flags allows to specify popup's flags.\nfunc (p *PopupModalWidget) Flags(flags WindowFlags) *PopupModalWidget {\n\tp.flags = flags\n\treturn p\n}\n\n// Layout sets layout.\nfunc (p *PopupModalWidget) Layout(widgets ...Widget) *PopupModalWidget {\n\tp.layout = Layout(widgets)\n\treturn p\n}\n\n// Build implements Widget interface.\nfunc (p *PopupModalWidget) Build() {\n\tif imgui.BeginPopupModalV(p.name, p.open, imgui.WindowFlags(p.flags)) {\n\t\tp.layout.Build()\n\t\timgui.EndPopup()\n\t}\n}\n"
        },
        {
          "name": "ProgressIndicator.go",
          "type": "blob",
          "size": 2.69140625,
          "content": "package giu\n\nimport (\n\t\"image\"\n\t\"math\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\nvar _ Disposable = &progressIndicatorState{}\n\ntype progressIndicatorState struct {\n\tangle float64\n\tstop  bool\n\tm     *sync.Mutex\n}\n\nfunc (ps *progressIndicatorState) update() {\n\tticker := time.NewTicker(time.Second / 60)\n\n\tfor {\n\t\tps.m.Lock()\n\t\tif ps.stop {\n\t\t\tps.m.Unlock()\n\t\t\tbreak\n\t\t}\n\n\t\tif ps.angle > 6.2 {\n\t\t\tps.angle = 0\n\t\t}\n\n\t\tps.angle += 0.1\n\n\t\tps.m.Unlock()\n\n\t\tUpdate()\n\t\t<-ticker.C\n\t}\n\n\tticker.Stop()\n}\n\n// Dispose implements Disposable interface.\nfunc (ps *progressIndicatorState) Dispose() {\n\tps.m.Lock()\n\tps.stop = true\n\tps.m.Unlock()\n}\n\n// static check to ensure if ProgressIndicatorWidget implements Widget interface.\nvar _ Widget = &ProgressIndicatorWidget{}\n\n// ProgressIndicatorWidget represents progress indicator widget\n// see examples/extrawidgets/.\ntype ProgressIndicatorWidget struct {\n\tinternalID ID\n\twidth      float32\n\theight     float32\n\tradius     float32\n\tlabel      string\n}\n\n// ProgressIndicator creates a new ProgressIndicatorWidget.\nfunc ProgressIndicator(label string, width, height, radius float32) *ProgressIndicatorWidget {\n\treturn &ProgressIndicatorWidget{\n\t\tinternalID: GenAutoID(\"###giu-progress-indicator\"),\n\t\twidth:      width,\n\t\theight:     height,\n\t\tradius:     radius,\n\t\tlabel:      label,\n\t}\n}\n\n// Build implements Widget interface.\nfunc (p *ProgressIndicatorWidget) Build() {\n\t// State exists\n\tif state := GetState[progressIndicatorState](Context, p.internalID); state == nil {\n\t\t// Register state and start go routine\n\t\tps := progressIndicatorState{\n\t\t\tangle: 0.0,\n\t\t\tstop:  false,\n\t\t\tm:     &sync.Mutex{},\n\t\t}\n\n\t\tSetState(Context, p.internalID, &ps)\n\n\t\tgo ps.update()\n\t} else {\n\t\tchild := Child().Border(false).Size(p.width, p.height).Layout(Layout{\n\t\t\tCustom(func() {\n\t\t\t\t// Process width and height\n\t\t\t\twidth, height := GetAvailableRegion()\n\n\t\t\t\tcanvas := GetCanvas()\n\n\t\t\t\tpos := GetCursorScreenPos()\n\n\t\t\t\tcenterPt := pos.Add(image.Pt(int(width/2), int(height/2)))\n\n\t\t\t\tstate.m.Lock()\n\t\t\t\tangle := state.angle\n\t\t\t\tstate.m.Unlock()\n\n\t\t\t\tcenterPt2 := image.Pt(\n\t\t\t\t\tint(float64(p.radius)*math.Sin(angle)+float64(centerPt.X)),\n\t\t\t\t\tint(float64(p.radius)*math.Cos(angle)+float64(centerPt.Y)),\n\t\t\t\t)\n\n\t\t\t\tcolor := imgui.StyleColorVec4(imgui.ColText)\n\t\t\t\trgba := Vec4ToRGBA(*color)\n\n\t\t\t\tcanvas.AddCircle(centerPt, p.radius, rgba, int32(p.radius), p.radius/20.0)\n\t\t\t\tcanvas.AddCircleFilled(centerPt2, p.radius/5, rgba)\n\n\t\t\t\t// Draw text\n\t\t\t\tif p.label != \"\" {\n\t\t\t\t\tlabelWidth, _ := CalcTextSize(Context.FontAtlas.RegisterString(p.label))\n\t\t\t\t\tlabelPos := centerPt.Add(image.Pt(-1*int(labelWidth/2), int(p.radius+p.radius/5+8)))\n\t\t\t\t\tcanvas.AddText(labelPos, rgba, p.label)\n\t\t\t\t}\n\t\t\t}),\n\t\t})\n\n\t\tchild.Build()\n\t}\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.15625,
          "content": "# giu\n\n<!--[![Join the chat at https://gitter.im/AllenDang-giu/community](https://badges.gitter.im/AllenDang-giu/community.svg)](https://gitter.im/AllenDang-giu/community?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)-->\n[![Go Report Card](https://goreportcard.com/badge/github.com/AllenDang/giu)](https://goreportcard.com/report/github.com/AllenDang/giu)\n![Build Status](https://github.com/AllenDang/giu/actions/workflows/build.yml/badge.svg)\n[![Go Reference](https://pkg.go.dev/badge/github.com/AllenDang/giu.svg)](https://pkg.go.dev/github.com/AllenDang/giu)\n[![Discord Shield](https://discord.com/api/guilds/1306199225616306248/widget.png?style=shield)](https://discord.gg/Tt7eq6YKQS)\n\nA rapid cross-platform GUI framework for Go based on [Dear ImGui](https://github.com/ocornut/imgui) and the great Go binding [imgui-go](https://github.com/inkyblackness/imgui-go).\n\nAny contribution (features, widgets, tutorials, documents, etc...) is appreciated!\n\n## Sponsor\n\n(This library is available under a free and permissive license, but needs financial support to sustain its continued improvements. In addition to maintenance and stability there are many desirable features yet to be added. If you are using giu, please consider reaching out.)\n\nBusinesses: support continued development and maintenance via invoiced technical support, maintenance, sponsoring contracts:\n\nE-mail: <allengnr@gmail.com>\n\nIndividuals: support continued development and maintenance [here](https://patreon.com/AllenDang).\n\n## Documentation\n\nFor documentation refer to [our wiki](https://github.com/AllenDang/giu/wiki),\n[examples](./examples), [GoDoc](https://pkg.go.dev/github.com/AllenDang/giu),\nor just take a look at comments in code.\n\n## Supported Platforms\n\ngiu is built upon GLFW v3.3, so ideally giu could support all platforms that GLFW v3.3 supports.\n\n- Windows (Windows 10 x64 and Windows 11 x64)\n- macOS (macOS v10.15 and macOS Big Sur)\n- Linux (thanks remeh for testing it)\n- Raspberry Pi 3B (thanks sndvaps for testing it)\n\n## Features\n\nCompared to other Dear ImGui golang bindings, giu has the following features:\n\n- Small executable file size (<3MB after UPX compression for the example/helloworld demo).\n- Live-updating during the resizing of the OS window (implemented on GLFW 3.3 and OpenGL 3.2).\n- Support for displaying various languages without any font setting. Giu will rebuild font atlas incrementally according to texts in UI between frames.\n- Redraws only when user event occurs. Costs only 0.5% CPU usage with 60FPS.\n- Declarative UI (see examples for more details).\n- DPI awareness (auto scaling font and UI to adapt to high DPI monitors).\n- Drop in usage; no need to implement render and platform.\n- OS clipboard support.\n\n![Screenshot](https://github.com/AllenDang/giu/raw/master/examples/imguidemo/screenshot.png)\n![Screenshot1](https://github.com/AllenDang/giu/blob/master/screenshots/SqlPower.png)\n![Screenshot2](https://github.com/AllenDang/giu/blob/master/screenshots/Chart.png)\n\n## Hello world\n\n```go\npackage main\n\nimport (\n        \"fmt\"\n\n        g \"github.com/AllenDang/giu\"\n)\n\nfunc onClickMe() {\n        fmt.Println(\"Hello world!\")\n}\n\nfunc onImSoCute() {\n        fmt.Println(\"Im sooooooo cute!!\")\n}\n\nfunc loop() {\n        g.SingleWindow().Layout(\n                g.Label(\"Hello world from giu\"),\n                g.Row(\n                        g.Button(\"Click Me\").OnClick(onClickMe),\n                        g.Button(\"I'm so cute\").OnClick(onImSoCute),\n                ),\n        )\n}\n\nfunc main() {\n        wnd := g.NewMasterWindow(\"Hello world\", 400, 200, g.MasterWindowFlagsNotResizable)\n        wnd.Run(loop)\n}\n```\n\nHere is the result:\n\n![Helloworld](https://github.com/AllenDang/giu/raw/master/examples/helloworld/helloworld.png)\n\n## Quick introduction\n\n### What is immediate mode GUI?\n\nImmediate mode GUI system means the UI control doesn't retain its state and value. For example, calling `giu.InputText(&str)` will display a input text box on screen, and the user entered value will be stored in `&str`. Input text box doesn't know anything about it.\n\nAnd the `loop` method in the _Hello world_ example is in charge of **drawing** all widgets based on the parameters passed into them. This method will be invoked 30 times per second to reflect interactive states (like clicked, hovered, value-changed, etc.). It will be the place you define the UI structure.\n\n### The layout and sizing system\n\nBy default, any widget placed inside a container's `Layout` will be placed vertically.\n\nTo create a row of widgets (i.e. place widgets one by one horizontally), use the `Row()` method. For example `giu.Row(Label(...), Button(...))` will create a Label next to a Button.\n\nTo create a column of widgets (i.e. place widgets one by one vertically) inside a row, use the `Column()` method.\n\nAny widget that has a `Size()` method, can set its size explicitly. Note that you can pass a negative value to `Size()`, which will fill the remaining width/height value. For example, `InputText(...).Size(giu.Auto)` will create an input text box with the longest width that its container has left.\n\n### Containers\n\n#### MasterWindow\n\nA `MasterWindow` means the platform native window implemented by the OS. All subwindows and widgets will be placed inside it.\n\n#### Window\n\nA `Window` is a container with a title bar, and can be collapsed. `SingleWindow` is a special kind of window that will occupy all the available space of `MasterWindow`.\n\n#### Child\n\nA `Child` is like a panel in other GUI frameworks - it can have a background color and border.\n\n### Widgets\n\nCheck `examples/widgets` for all kinds of widgets.\n\n## Install\n\nThe backend of giu depends on OpenGL 3.3, make sure your environment supports it (as far as I know, some Virtual Machines like VirtualBox doesn't support it).\n\n### MacOS\n\n```sh\nxcode-select --install\ngo get github.com/AllenDang/giu\n```\n\n### Windows\n\n1. Install mingw [download here](https://github.com/brechtsanders/winlibs_mingw/releases/latest). Thanks @alchem1ster!\n2. Add the binaries folder of mingw to the path (usually is _\\mingw64\\bin_).\n3. go get github.com/AllenDang/giu\n\n### Linux\n\nFirst you need to install the required dependencies:\n\n```bash\nsudo apt install libx11-dev libxcursor-dev libxrandr-dev libxinerama-dev libxi-dev libglx-dev libgl1-mesa-dev libxxf86vm-dev\n```\n\non Red Hat based distributions:\n\n```bash\nsudo dnf install libX11-devel libXcursor-devel libXrandr-devel libXinerama-devel libXi-devel libGL-devel libXxf86vm-devel\n```\n\nyou may also need to install C/C++ compiler (like g++) if it isn't already installed. Follow go compiler prompts.\n\nThen, a simple `go build` will work.\n\nCross-compiling is a bit more complicated. Let's say that you want to build for arm64. This is what you would need to do:\n\n```bash\nsudo dpkg --add-architecture arm64\nsudo apt update\nsudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu \\\n    libx11-dev:arm64 libxcursor-dev:arm64 libxrandr-dev:arm64 libxinerama-dev:arm64 libxi-dev:arm64 libglx-dev:arm64 libgl1-mesa-dev:arm64 libxxf86vm-dev:arm64\nGOOS=linux GOARCH=arm64 CGO_ENABLED=1 CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ HOST=aarch64-linux-gnu go build -v\n```\n\n## Deploying\n\n### Build MacOS version on MacOS\n\n```sh\ngo build -ldflags \"-s -w\" .\n```\n\n### Build Windows version on Windows\n\n```sh\ngo build -ldflags \"-s -w -H=windowsgui -extldflags=-static\" .\n```\n\n### Build Windows version on MacOS/Linux\n\n1. Install mingw-64.\n\non Mac:\n\n```sh\nbrew install mingw-w64\n```\n\non Linux:\n\n```sh\nsudo dnf install mingw64-gcc mingw64-gcc-c++ mingw64-winpthreads-static\n```\n\n2. Prepare and embed the application icon into the executable and build.\n\n```sh\ncat > YourExeName.rc << EOL\nid ICON \"./res/app_win.ico\"\nGLFW_ICON ICON \"./res/app_win.ico\"\nEOL\n\nx86_64-w64-mingw32-windres YourExeName.rc -O coff -o YourExeName.syso\nGOOS=windows GOARCH=amd64 CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ HOST=x86_64-w64-mingw32 go build -ldflags \"-s -w -H=windowsgui -extldflags=-static\" -p 4 -v -o YourExeName.exe\n\nrm YourExeName.syso\nrm YourExeName.rc\n```\n\n## Contribution\n\nAll kinds of pull requests (document, demo, screenshots, code, etc.) are more than welcome!\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=AllenDang/giu&type=Date)](https://star-history.com/#AllenDang/giu&Date)\n"
        },
        {
          "name": "ReflectiveBoundTexture.go",
          "type": "blob",
          "size": 8.6044921875,
          "content": "package giu\n\nimport (\n\t\"errors\"\n\t\"hash/crc32\"\n\t\"image\"\n\t\"image/color\"\n\t\"sync\"\n\n\t\"github.com/AllenDang/cimgui-go/backend\"\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// ErrNilRGBA is an error that indicates the RGBA surface result is nil.\nvar ErrNilRGBA = errors.New(\"surface RGBA Result is nil\")\n\n// defaultSurface returns a default RGBA surface with a uniform color.\nfunc defaultSurface() *image.RGBA {\n\tsurface, _ := NewUniformLoader(128.0, 128.0, color.RGBA{255, 255, 255, 255}).ServeRGBA()\n\treturn surface\n}\n\n// ReflectiveBoundTexture represents a texture that can be dynamically updated and bound to a GPU.\ntype ReflectiveBoundTexture struct {\n\tSurface *image.RGBA // Surface is the RGBA image data for the texture.\n\ttex     *Texture    // tex is the GPU texture resource.\n\tlastSum uint32      // lastSum is the checksum of the last surface data.\n\tmu      sync.Mutex  // mu is a mutex to protect concurrent access to the texture.\n\tfsroot  string      // fsroot is the root filesystem path for the texture when using file scheme in URL Surface Loader\n}\n\n/* Return a waranted:\n * - Initialized\n * - With proper resources bindings against gpu (free old, bound new)\n * - Up to date Texture.\n */\n\n// commit updates the ReflectiveBoundTexture by checking if the surface has changed,\n// and if so, rebinds the texture to the GPU. It returns the updated ReflectiveBoundTexture\n// and a boolean indicating whether the texture has changed.\n//\n// The method locks the texture for concurrent access, calculates the checksum of the\n// current surface, and compares it with the last stored checksum. If the checksums differ,\n// it unbinds the old texture, binds the new one, and updates the checksum.\n//\n// Returns:\n//   - *ReflectiveBoundTexture: The updated texture object.\n//   - bool: True if the texture has changed, false otherwise.\nfunc (i *ReflectiveBoundTexture) commit() (*ReflectiveBoundTexture, bool) {\n\ti.mu.Lock()\n\tdefer i.mu.Unlock()\n\n\tif i.Surface == nil {\n\t\ti.Surface = defaultSurface()\n\t}\n\n\tvar hasChanged bool\n\tif sum := crc32.ChecksumIEEE(i.Surface.Pix); sum != i.lastSum {\n\t\thasChanged = true\n\n\t\ti.unbind()\n\t\ti.bind()\n\t\ti.lastSum = sum\n\t}\n\n\treturn i, hasChanged\n}\n\n// SetSurfaceFromRGBA sets the surface of the ReflectiveBoundTexture from the provided RGBA image.\n// If the provided image is nil, it returns an error. If the commit flag is true, it commits the changes.\n//\n// Parameters:\n//   - img: The RGBA image to set as the surface.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the provided image is nil, otherwise nil.\nfunc (i *ReflectiveBoundTexture) SetSurfaceFromRGBA(img *image.RGBA, commit bool) error {\n\tif img != nil {\n\t\ti.Surface = img\n\t} else {\n\t\treturn ErrNilRGBA\n\t}\n\n\tif commit {\n\t\ti.commit()\n\t}\n\n\treturn nil\n}\n\n// ToImageWidget converts the ReflectiveBoundTexture to an ImageWidget.\n//\n// Returns:\n//   - *ImageWidget: The ImageWidget representation of the ReflectiveBoundTexture.\nfunc (i *ReflectiveBoundTexture) ToImageWidget() *ImageWidget {\n\treturn Image(i.Texture())\n}\n\n// ImguiImageVOptionStruct represents the options for rendering an image in ImGui.\ntype ImguiImageVOptionStruct struct {\n\tUv0       imgui.Vec2 // The UV coordinate of the top-left corner of the image.\n\tUv1       imgui.Vec2 // The UV coordinate of the bottom-right corner of the image.\n\tTintCol   imgui.Vec4 // The tint color to apply to the image.\n\tBorderCol imgui.Vec4 // The border color to apply to the image.\n}\n\n// GetImGuiImageVDefaultOptionsStruct returns the default options for rendering an image in ImGui.\n//\n// Returns:\n//   - ImguiImageVOptionStruct: The default options for rendering an image.\nfunc (i *ReflectiveBoundTexture) GetImGuiImageVDefaultOptionsStruct() ImguiImageVOptionStruct {\n\treturn ImguiImageVOptionStruct{\n\t\tUv0:       imgui.Vec2{X: 0, Y: 0},\n\t\tUv1:       imgui.Vec2{X: 1, Y: 1},\n\t\tTintCol:   imgui.Vec4{X: 1, Y: 1, Z: 1, W: 1},\n\t\tBorderCol: imgui.Vec4{X: 0, Y: 0, Z: 0, W: 0},\n\t}\n}\n\n// ImguiImage renders the ReflectiveBoundTexture as an image in ImGui.\n//\n// Parameters:\n//   - width: The width of the image. If set to -1, it will use the available content region width.\n//   - height: The height of the image. If set to -1, it will use the available content region height.\n//   - options: The options for rendering the image.\nfunc (i *ReflectiveBoundTexture) ImguiImage(width, height float32) {\n\tsize := imgui.Vec2{X: width, Y: height}\n\n\tif size.X == -1 {\n\t\trect := imgui.ContentRegionAvail()\n\t\tsize.X = rect.X\n\t}\n\n\tif size.Y == -1 {\n\t\trect := imgui.ContentRegionAvail()\n\t\tsize.Y = rect.Y\n\t}\n\n\timgui.Image(i.Texture().ID(), size)\n}\n\n// ImguiImageV renders the ReflectiveBoundTexture as an image in ImGui with additional options.\n//\n// Parameters:\n//   - width: The width of the image. If set to -1, it will use the available content region width.\n//   - height: The height of the image. If set to -1, it will use the available content region height.\n//   - options: The options for rendering the image, including UV coordinates, tint color, and border color.\nfunc (i *ReflectiveBoundTexture) ImguiImageV(width, height float32, options ImguiImageVOptionStruct) {\n\tsize := imgui.Vec2{X: width, Y: height}\n\n\tif size.X == -1 {\n\t\trect := imgui.ContentRegionAvail()\n\t\tsize.X = rect.X\n\t}\n\n\tif size.Y == -1 {\n\t\trect := imgui.ContentRegionAvail()\n\t\tsize.Y = rect.Y\n\t}\n\n\timgui.ImageV(i.Texture().ID(), size, options.Uv0, options.Uv1, options.TintCol, options.BorderCol)\n}\n\n// ImguiImageButtonV renders the ReflectiveBoundTexture as an image button in ImGui with additional options.\n//\n// Parameters:\n//   - id: The ID of the image button.\n//   - width: The width of the image button. If set to -1, it will use the available content region width.\n//   - height: The height of the image button. If set to -1, it will use the available content region height.\n//   - options: The options for rendering the image button, including UV coordinates, tint color, and border color.\nfunc (i *ReflectiveBoundTexture) ImguiImageButtonV(id string, width, height float32, options ImguiImageVOptionStruct) {\n\tsize := imgui.Vec2{X: width, Y: height}\n\n\tif size.X == -1 {\n\t\trect := imgui.ContentRegionAvail()\n\t\tsize.X = rect.X\n\t}\n\n\tif size.Y == -1 {\n\t\trect := imgui.ContentRegionAvail()\n\t\tsize.Y = rect.Y\n\t}\n\n\timgui.ImageButtonV(id, i.Texture().ID(), size, options.Uv0, options.Uv1, options.TintCol, options.BorderCol)\n}\n\n// unbind releases the texture associated with the ReflectiveBoundTexture from the backend.\nfunc (i *ReflectiveBoundTexture) unbind() {\n\tif i.tex != nil {\n\t\tContext.Backend().DeleteTexture(i.tex.ID())\n\t\ti.tex = nil\n\t}\n}\n\n// bind creates a new texture from the RGBA surface and assigns it to the ReflectiveBoundTexture.\n// note it bypasses normal texture management up to cimgui-go to avoid double free from finalizers.\nfunc (i *ReflectiveBoundTexture) bind() {\n\timg := ImageToRgba(i.Surface)\n\ti.tex = &Texture{\n\t\t&backend.Texture{\n\t\t\tID:     backend.TextureManager(Context.backend).CreateTextureRgba(img, img.Bounds().Dx(), img.Bounds().Dy()),\n\t\t\tWidth:  img.Bounds().Dx(),\n\t\t\tHeight: img.Bounds().Dy(),\n\t\t},\n\t}\n}\n\n// GetSurfaceWidth returns the width of the RGBA surface.\nfunc (i *ReflectiveBoundTexture) GetSurfaceWidth() int {\n\treturn i.Surface.Bounds().Dx()\n}\n\n// GetSurfaceHeight returns the height of the RGBA surface.\nfunc (i *ReflectiveBoundTexture) GetSurfaceHeight() int {\n\treturn i.Surface.Bounds().Dy()\n}\n\n// GetSurfaceSize returns the size of the RGBA surface as an image.Point.\nfunc (i *ReflectiveBoundTexture) GetSurfaceSize() image.Point {\n\treturn i.Surface.Bounds().Size()\n}\n\n// Texture commits any pending changes to the RGBA surface and returns the associated texture.\nfunc (i *ReflectiveBoundTexture) Texture() *Texture {\n\ti.commit()\n\treturn i.tex\n}\n\n// TextureID commits any pending changes and returns the ImGui TextureID of the associated texture.\nfunc (i *ReflectiveBoundTexture) TextureID() imgui.TextureID {\n\treturn i.Texture().ID()\n}\n\n// GetRGBA returns the RGBA surface of the ReflectiveBoundTexture.\n// If the commit parameter is true, it commits any pending changes before returning the surface.\n//\n// Parameters:\n//   - commit: A boolean indicating whether to commit any pending changes.\n//\n// Returns:\n//   - *image.RGBA: The RGBA surface of the ReflectiveBoundTexture.\nfunc (i *ReflectiveBoundTexture) GetRGBA(commit bool) *image.RGBA {\n\tif commit {\n\t\ti.commit()\n\t}\n\n\treturn i.Surface\n}\n\n// ForceRelease forces releasing resources against all finalizers,\n// effectively losing the object but ensuring both RAM and VRAM\n// are freed.\nfunc (i *ReflectiveBoundTexture) ForceRelease() {\n\ti.unbind()\n\ti.Surface = nil\n\n\tvar u uint32\n\ti.lastSum = u\n}\n\n// ForceCommit forces committing.\nfunc (i *ReflectiveBoundTexture) ForceCommit() (*ReflectiveBoundTexture, bool) {\n\treturn i.commit()\n}\n"
        },
        {
          "name": "SliderWidgets.go",
          "type": "blob",
          "size": 5.7265625,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\nvar _ Widget = &SliderIntWidget{}\n\n// SliderIntWidget is a slider around int32 values.\ntype SliderIntWidget struct {\n\tlabel    ID\n\tvalue    *int32\n\tminValue int32\n\tmaxValue int32\n\tformat   string\n\twidth    float32\n\tonChange func()\n}\n\n// SliderInt constructs new SliderIntWidget.\nfunc SliderInt(value *int32, minValue, maxValue int32) *SliderIntWidget {\n\treturn &SliderIntWidget{\n\t\tlabel:    GenAutoID(\"##SliderInt\"),\n\t\tvalue:    value,\n\t\tminValue: minValue,\n\t\tmaxValue: maxValue,\n\t\tformat:   \"%d\",\n\t\twidth:    0,\n\t\tonChange: nil,\n\t}\n}\n\n// Format sets data format displayed on the slider\n// NOTE: on C side of imgui, it will be processed like:\n// fmt.Sprintf(format, currentValue) so you can do e.g.\n// SLiderInt(...).Format(\"My age is %d\") and %d will be replaced with current value.\nfunc (s *SliderIntWidget) Format(format string) *SliderIntWidget {\n\ts.format = format\n\treturn s\n}\n\n// Size sets slider's width.\nfunc (s *SliderIntWidget) Size(width float32) *SliderIntWidget {\n\ts.width = width\n\treturn s\n}\n\n// OnChange sets callback when slider's position gets changed.\nfunc (s *SliderIntWidget) OnChange(onChange func()) *SliderIntWidget {\n\ts.onChange = onChange\n\treturn s\n}\n\n// Label sets slider label (id).\nfunc (s *SliderIntWidget) Label(label string) *SliderIntWidget {\n\ts.label = GenAutoID(label)\n\treturn s\n}\n\n// Labelf sets formatted label.\nfunc (s *SliderIntWidget) Labelf(format string, args ...any) *SliderIntWidget {\n\treturn s.Label(fmt.Sprintf(format, args...))\n}\n\n// ID manually sets widget id.\nfunc (s *SliderIntWidget) ID(id ID) *SliderIntWidget {\n\ts.label = id\n\treturn s\n}\n\n// Build implements Widget interface.\nfunc (s *SliderIntWidget) Build() {\n\tif s.width != 0 {\n\t\tPushItemWidth(s.width)\n\n\t\tdefer PopItemWidth()\n\t}\n\n\tif imgui.SliderIntV(Context.FontAtlas.RegisterString(s.label.String()), s.value, s.minValue, s.maxValue, s.format, 0) && s.onChange != nil {\n\t\ts.onChange()\n\t}\n}\n\nvar _ Widget = &VSliderIntWidget{}\n\n// VSliderIntWidget stands from Vertical SliderIntWidget.\ntype VSliderIntWidget struct {\n\tlabel    ID\n\twidth    float32\n\theight   float32\n\tvalue    *int32\n\tminValue int32\n\tmaxValue int32\n\tformat   string\n\tflags    SliderFlags\n\tonChange func()\n}\n\n// VSliderInt creates new vslider int.\nfunc VSliderInt(value *int32, minValue, maxValue int32) *VSliderIntWidget {\n\treturn &VSliderIntWidget{\n\t\tlabel:    GenAutoID(\"##VSliderInt\"),\n\t\twidth:    18,\n\t\theight:   60,\n\t\tvalue:    value,\n\t\tminValue: minValue,\n\t\tmaxValue: maxValue,\n\t\tformat:   \"%d\",\n\t\tflags:    SliderFlagsNone,\n\t}\n}\n\n// Size sets slider's size.\nfunc (vs *VSliderIntWidget) Size(width, height float32) *VSliderIntWidget {\n\tvs.width, vs.height = width, height\n\treturn vs\n}\n\n// Flags sets flags.\nfunc (vs *VSliderIntWidget) Flags(flags SliderFlags) *VSliderIntWidget {\n\tvs.flags = flags\n\treturn vs\n}\n\n// Format sets format (see comment on (*SliderIntWidget).Format).\nfunc (vs *VSliderIntWidget) Format(format string) *VSliderIntWidget {\n\tvs.format = format\n\treturn vs\n}\n\n// OnChange sets callback called when slider's position gets changed.\nfunc (vs *VSliderIntWidget) OnChange(onChange func()) *VSliderIntWidget {\n\tvs.onChange = onChange\n\treturn vs\n}\n\n// Label sets slider's label (id).\nfunc (vs *VSliderIntWidget) Label(label string) *VSliderIntWidget {\n\tvs.label = GenAutoID(label)\n\treturn vs\n}\n\n// Labelf sets formatted label.\nfunc (vs *VSliderIntWidget) Labelf(format string, args ...any) *VSliderIntWidget {\n\treturn vs.Label(fmt.Sprintf(format, args...))\n}\n\n// ID manually sets widget id.\nfunc (vs *VSliderIntWidget) ID(id ID) *VSliderIntWidget {\n\tvs.label = id\n\treturn vs\n}\n\n// Build implements Widget interface.\nfunc (vs *VSliderIntWidget) Build() {\n\tif imgui.VSliderIntV(\n\t\tContext.FontAtlas.RegisterString(vs.label.String()),\n\t\timgui.Vec2{X: vs.width, Y: vs.height},\n\t\tvs.value,\n\t\tvs.minValue,\n\t\tvs.maxValue,\n\t\tvs.format,\n\t\timgui.SliderFlags(vs.flags),\n\t) && vs.onChange != nil {\n\t\tvs.onChange()\n\t}\n}\n\nvar _ Widget = &SliderFloatWidget{}\n\n// SliderFloatWidget does similar to SliderIntWidget but slides around\n// float32 values.\ntype SliderFloatWidget struct {\n\tlabel    ID\n\tvalue    *float32\n\tminValue float32\n\tmaxValue float32\n\tformat   string\n\twidth    float32\n\tonChange func()\n}\n\n// SliderFloat creates new slider float widget.\nfunc SliderFloat(value *float32, minValue, maxValue float32) *SliderFloatWidget {\n\treturn &SliderFloatWidget{\n\t\tlabel:    GenAutoID(\"##SliderFloat\"),\n\t\tvalue:    value,\n\t\tminValue: minValue,\n\t\tmaxValue: maxValue,\n\t\tformat:   \"%.3f\",\n\t\twidth:    0,\n\t\tonChange: nil,\n\t}\n}\n\n// Format sets format of text displayed on the slider.\n// default is %.3f.\nfunc (sf *SliderFloatWidget) Format(format string) *SliderFloatWidget {\n\tsf.format = format\n\treturn sf\n}\n\n// OnChange is callback called when slider's position gets changed.\nfunc (sf *SliderFloatWidget) OnChange(onChange func()) *SliderFloatWidget {\n\tsf.onChange = onChange\n\n\treturn sf\n}\n\n// Size sets slider's width.\nfunc (sf *SliderFloatWidget) Size(width float32) *SliderFloatWidget {\n\tsf.width = width\n\treturn sf\n}\n\n// Label sets slider's label (id).\nfunc (sf *SliderFloatWidget) Label(label string) *SliderFloatWidget {\n\tsf.label = GenAutoID(Context.FontAtlas.RegisterString(label))\n\treturn sf\n}\n\n// Labelf sets formatted label.\nfunc (sf *SliderFloatWidget) Labelf(format string, args ...any) *SliderFloatWidget {\n\treturn sf.Label(fmt.Sprintf(format, args...))\n}\n\n// ID manually sets widget id.\nfunc (sf *SliderFloatWidget) ID(id ID) *SliderFloatWidget {\n\tsf.label = id\n\treturn sf\n}\n\n// Build implements Widget interface.\nfunc (sf *SliderFloatWidget) Build() {\n\tif sf.width != 0 {\n\t\tPushItemWidth(sf.width)\n\n\t\tdefer PopItemWidth()\n\t}\n\n\tif imgui.SliderFloatV(Context.FontAtlas.RegisterString(sf.label.String()), sf.value, sf.minValue, sf.maxValue, sf.format, 1.0) && sf.onChange != nil {\n\t\tsf.onChange()\n\t}\n}\n"
        },
        {
          "name": "SplitLayout.go",
          "type": "blob",
          "size": 5.73828125,
          "content": "package giu\n\nimport (\n\t\"image/color\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// SplitDirection represents a direction (vertical/horizontal) of splitting layout.\ntype SplitDirection uint8\n\nconst (\n\t// DirectionHorizontal is a horizontal line.\n\tDirectionHorizontal SplitDirection = 1 << iota\n\t// DirectionVertical is a vertical line.\n\tDirectionVertical\n)\n\n// SplitRefType describes how sashPos argument to the SplitLayout should be interpreted.\ntype SplitRefType byte\n\nconst (\n\t// SplitRefLeft is the default. Splitter placed counting from left/top layout's edge.\n\tSplitRefLeft SplitRefType = iota\n\t// SplitRefRight splitter placed counting from right/bottom layout's edge.\n\tSplitRefRight\n\t// SplitRefProc sashPos will be clamped in range [0, 1]. Then the position is considered a percent of GetAvailableRegion.\n\tSplitRefProc\n)\n\nvar _ Disposable = &splitLayoutState{}\n\ntype splitLayoutState struct {\n\tdelta float32\n}\n\n// Dispose implements disposable interface.\nfunc (s *splitLayoutState) Dispose() {\n\t// noop\n}\n\n// SplitLayoutWidget creates two children with a line between them.\n// This line can be moved by the user to adjust child sizes.\ntype SplitLayoutWidget struct {\n\tid                  ID\n\tdirection           SplitDirection\n\tlayout1             Widget\n\tlayout2             Widget\n\toriginItemSpacingX  float32\n\toriginItemSpacingY  float32\n\toriginFramePaddingX float32\n\toriginFramePaddingY float32\n\tsashPos             *float32\n\tborder              bool\n\tsplitRefType        SplitRefType\n}\n\n// SplitLayout creates split layout widget.\nfunc SplitLayout(direction SplitDirection, sashPos *float32, layout1, layout2 Widget) *SplitLayoutWidget {\n\treturn &SplitLayoutWidget{\n\t\tdirection: direction,\n\t\tsashPos:   sashPos,\n\t\tlayout1:   layout1,\n\t\tlayout2:   layout2,\n\t\tborder:    true,\n\t\tid:        GenAutoID(\"SplitLayout\"),\n\t}\n}\n\n// Border sets if children should have borders.\nfunc (s *SplitLayoutWidget) Border(b bool) *SplitLayoutWidget {\n\ts.border = b\n\treturn s\n}\n\n// ID allows to manually set splitter's id.\nfunc (s *SplitLayoutWidget) ID(id ID) *SplitLayoutWidget {\n\ts.id = id\n\treturn s\n}\n\n// SplitRefType allows to set how sashPos should be interpreted.\n// Default is counting from left/top layout's edge in px.\nfunc (s *SplitLayoutWidget) SplitRefType(refType SplitRefType) *SplitLayoutWidget {\n\ts.splitRefType = refType\n\treturn s\n}\n\n// Build implements widget interface.\nfunc (s *SplitLayoutWidget) Build() {\n\tsplitLayoutState := s.getState()\n\ts.originItemSpacingX, s.originItemSpacingY = GetItemInnerSpacing()\n\ts.originFramePaddingX, s.originFramePaddingY = GetFramePadding()\n\tavailableW, availableH := GetAvailableRegion()\n\n\tvar layout Layout\n\n\tvar sashPos float32\n\n\tswitch s.splitRefType {\n\tcase SplitRefLeft:\n\t\tsashPos = *s.sashPos\n\tcase SplitRefRight:\n\t\tswitch s.direction {\n\t\tcase DirectionHorizontal:\n\t\t\tsashPos = availableH - *s.sashPos\n\t\tcase DirectionVertical:\n\t\t\tsashPos = availableW - *s.sashPos\n\t\t}\n\tcase SplitRefProc:\n\t\tif *s.sashPos < 0 {\n\t\t\t*s.sashPos = 0\n\t\t} else if *s.sashPos > 1 {\n\t\t\t*s.sashPos = 1\n\t\t}\n\n\t\tswitch s.direction {\n\t\tcase DirectionHorizontal:\n\t\t\tsashPos = availableH * *s.sashPos\n\t\tcase DirectionVertical:\n\t\t\tsashPos = availableW * *s.sashPos\n\t\t}\n\t}\n\n\tsashPos += splitLayoutState.delta\n\tif sashPos < 1 {\n\t\tsashPos = 1\n\t}\n\n\tswitch s.direction {\n\tcase DirectionHorizontal:\n\t\tif sashPos >= availableH {\n\t\t\tsashPos = availableH\n\t\t}\n\n\t\tlayout = Layout{\n\t\t\tColumn(\n\t\t\t\ts.buildChild(Auto, sashPos, s.layout1),\n\t\t\t\tSplitter(DirectionHorizontal, &(splitLayoutState.delta)).Size(0, s.originItemSpacingY),\n\t\t\t\ts.buildChild(Auto, Auto, s.layout2),\n\t\t\t),\n\t\t}\n\tcase DirectionVertical:\n\t\tif sashPos >= availableW {\n\t\t\tsashPos = availableW\n\t\t}\n\n\t\tlayout = Layout{\n\t\t\tRow(\n\t\t\t\ts.buildChild(sashPos, Auto, s.layout1),\n\t\t\t\tSplitter(DirectionVertical, &(splitLayoutState.delta)).Size(s.originItemSpacingX, 0),\n\t\t\t\ts.buildChild(Auto, Auto, s.layout2),\n\t\t\t),\n\t\t}\n\t}\n\n\tPushItemSpacing(0, 0)\n\tlayout.Build()\n\tPopStyle()\n\n\ts.encodeSashPos(sashPos, availableW, availableH)\n}\n\nfunc (s *SplitLayoutWidget) encodeSashPos(sashPos, availableW, availableH float32) {\n\tswitch s.splitRefType {\n\tcase SplitRefLeft:\n\t\t*s.sashPos = sashPos\n\tcase SplitRefRight:\n\t\tswitch s.direction {\n\t\tcase DirectionHorizontal:\n\t\t\t*s.sashPos = availableH - sashPos\n\t\tcase DirectionVertical:\n\t\t\t*s.sashPos = availableW - sashPos\n\t\t}\n\tcase SplitRefProc:\n\t\tswitch s.direction {\n\t\tcase DirectionHorizontal:\n\t\t\t*s.sashPos = sashPos / availableH\n\t\tcase DirectionVertical:\n\t\t\t*s.sashPos = sashPos / availableW\n\t\t}\n\t}\n}\n\nfunc (s *SplitLayoutWidget) restoreItemSpacing(layout Widget) Layout {\n\treturn Layout{\n\t\tCustom(func() {\n\t\t\tPushItemSpacing(s.originItemSpacingX, s.originItemSpacingY)\n\t\t\tPushFramePadding(s.originFramePaddingX, s.originFramePaddingY)\n\t\t\t// Restore Child bg color\n\t\t\tbgColor := imgui.StyleColorVec4(imgui.ColChildBg)\n\t\t\tPushStyleColor(StyleColorChildBg, Vec4ToRGBA(*bgColor))\n\t\t}),\n\t\tlayout,\n\t\tCustom(func() {\n\t\t\tPopStyleColor()\n\t\t\tPopStyleV(2)\n\t\t}),\n\t}\n}\n\n// Build Child panel. If layout is a SplitLayout, set the frame padding to zero.\nfunc (s *SplitLayoutWidget) buildChild(width, height float32, layout Widget) Widget {\n\treturn Layout{\n\t\tCustom(func() {\n\t\t\t_, isSplitLayoutWidget := layout.(*SplitLayoutWidget)\n\t\t\thasFramePadding := isSplitLayoutWidget || !s.border\n\t\t\thasBorder := !isSplitLayoutWidget && s.border\n\n\t\t\tif hasFramePadding {\n\t\t\t\tPushFramePadding(0, 0)\n\t\t\t}\n\n\t\t\tPushStyleColor(StyleColorChildBg, color.RGBA{R: 0, G: 0, B: 0, A: 0})\n\n\t\t\tChild().\n\t\t\t\tBorder(hasBorder).\n\t\t\t\tSize(width, height).\n\t\t\t\tLayout(s.restoreItemSpacing(layout)).\n\t\t\t\tBuild()\n\n\t\t\tPopStyleColor()\n\n\t\t\tif hasFramePadding {\n\t\t\t\tPopStyle()\n\t\t\t}\n\t\t}),\n\t}\n}\n\nfunc (s *SplitLayoutWidget) getState() (state *splitLayoutState) {\n\tif state = GetState[splitLayoutState](Context, s.id); state == nil {\n\t\tstate = &splitLayoutState{delta: 0.0}\n\t\tSetState(Context, s.id, state)\n\t}\n\n\treturn state\n}\n"
        },
        {
          "name": "StackWidget.go",
          "type": "blob",
          "size": 1.28515625,
          "content": "package giu\n\nimport \"github.com/AllenDang/cimgui-go/imgui\"\n\nvar _ Widget = &StackWidget{}\n\n// StackWidget is used to ensure, that the build methods of all\n// the widgets (layouts field) was called, but only the selected\n// (visible field) layout is rendered (visible) in app.\ntype StackWidget struct {\n\tvisible int32\n\tlayouts []Widget\n}\n\n// Stack creates a new StackWidget.\nfunc Stack(visible int32, layouts ...Widget) *StackWidget {\n\treturn &StackWidget{\n\t\tvisible: visible,\n\t\tlayouts: layouts,\n\t}\n}\n\n// Build implements widget interface.\nfunc (s *StackWidget) Build() {\n\t// save visible cursor position\n\tvisiblePos := GetCursorScreenPos()\n\n\t// build visible layout\n\t// NOTE: it is important to build the visible layout before\n\t// building other ones, because the interactive layout widgets\n\t// (e.g. buttons) should be rendered on top of `stack`\n\tlayouts := s.layouts\n\n\tif s.visible >= 0 && s.visible < int32(len(s.layouts)) {\n\t\ts.layouts[s.visible].Build()\n\t\t// remove visible layout from layouts list\n\t\t//nolint:gocritic // remove visible widget\n\t\tlayouts = append(s.layouts[:s.visible], s.layouts[:s.visible+1]...)\n\t}\n\n\t// build invisible layouts with 0 alpha\n\timgui.PushStyleVarFloat(imgui.StyleVarAlpha, 0)\n\n\tfor _, l := range layouts {\n\t\tSetCursorScreenPos(visiblePos)\n\t\tl.Build()\n\t}\n\n\timgui.PopStyleVar()\n}\n"
        },
        {
          "name": "StatefulReflectiveBoundTexture.go",
          "type": "blob",
          "size": 5.1279296875,
          "content": "package giu\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// ErrNeedReset is an error indicating that the surface cannot be loaded without a reset.\n// The method (*StatefulReflectiveBoundTexture).ResetState() should be called.\nvar ErrNeedReset = errors.New(\"cannot load surface without a reset. Should call (*StatefulReflectiveBoundTexture).ResetState()\")\n\n// ErrIsLoading is an error indicating that the surface state cannot be reset while loading.\nvar ErrIsLoading = errors.New(\"cannot reset surface state while loading\")\n\n// SurfaceState represents the state of the surface.\ntype SurfaceState int\n\n//go:generate stringer -type=SurfaceState\nconst (\n\t// SurfaceStateNone indicates that the surface state is none.\n\tSurfaceStateNone SurfaceState = iota\n\t// SurfaceStateLoading indicates that the surface is currently loading.\n\tSurfaceStateLoading\n\t// SurfaceStateFailure indicates that the surface loading has failed.\n\tSurfaceStateFailure\n\t// SurfaceStateSuccess indicates that the surface loading was successful.\n\tSurfaceStateSuccess\n)\n\n// StatefulReflectiveBoundTexture is a ReflectiveBoundTexture with added async, states, and event callbacks.\ntype StatefulReflectiveBoundTexture struct {\n\tReflectiveBoundTexture\n\tstate     SurfaceState\n\tlastError error\n\tonReset   func()\n\tonLoading func()\n\tonSuccess func()\n\tonFailure func(error)\n}\n\n// GetState returns the current state of the surface.\n//\n// Returns:\n//   - SurfaceState: The current state of the surface.\nfunc (s *StatefulReflectiveBoundTexture) GetState() SurfaceState {\n\treturn s.state\n}\n\n// GetLastError returns the last error that occurred during surface loading.\n//\n// Returns:\n//   - error: The last error that occurred, or nil if no error occurred.\nfunc (s *StatefulReflectiveBoundTexture) GetLastError() error {\n\treturn s.lastError\n}\n\n// OnReset sets the callback function to be called when the surface state is reset.\n//\n// Parameters:\n//   - fn: The callback function to be called on reset.\n//\n// Returns:\n//   - *StatefulReflectiveBoundTexture: The current instance of StatefulReflectiveBoundTexture.\nfunc (s *StatefulReflectiveBoundTexture) OnReset(fn func()) *StatefulReflectiveBoundTexture {\n\ts.onReset = fn\n\treturn s\n}\n\n// OnLoading sets the callback function to be called when the surface is loading.\n//\n// Parameters:\n//   - fn: The callback function to be called on loading.\n//\n// Returns:\n//   - *StatefulReflectiveBoundTexture: The current instance of StatefulReflectiveBoundTexture.\nfunc (s *StatefulReflectiveBoundTexture) OnLoading(fn func()) *StatefulReflectiveBoundTexture {\n\ts.onLoading = fn\n\treturn s\n}\n\n// OnSuccess sets the callback function to be called when the surface loading is successful.\n//\n// Parameters:\n//   - fn: The callback function to be called on success.\n//\n// Returns:\n//   - *StatefulReflectiveBoundTexture: The current instance of StatefulReflectiveBoundTexture.\nfunc (s *StatefulReflectiveBoundTexture) OnSuccess(fn func()) *StatefulReflectiveBoundTexture {\n\ts.onSuccess = fn\n\treturn s\n}\n\n// OnFailure sets the callback function to be called when the surface loading fails.\n//\n// Parameters:\n//   - fn: The callback function to be called on failure, with the error as a parameter.\n//\n// Returns:\n//   - *StatefulReflectiveBoundTexture: The current instance of StatefulReflectiveBoundTexture.\nfunc (s *StatefulReflectiveBoundTexture) OnFailure(fn func(error)) *StatefulReflectiveBoundTexture {\n\ts.onFailure = fn\n\treturn s\n}\n\n// ResetState resets the state of the StatefulReflectiveBoundTexture.\n//\n// Returns:\n//   - error: An error if the state is currently loading, otherwise nil.\nfunc (s *StatefulReflectiveBoundTexture) ResetState() error {\n\tswitch s.state {\n\tcase SurfaceStateNone:\n\t\treturn nil\n\tcase SurfaceStateLoading:\n\t\treturn ErrIsLoading\n\tdefault:\n\t\ts.state = SurfaceStateNone\n\t\ts.lastError = nil\n\n\t\tif s.onReset != nil {\n\t\t\tgo s.onReset()\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// LoadSurfaceAsync loads the surface asynchronously using the provided SurfaceLoader.\n// It sets the state to loading, and upon completion, updates the state to success or failure\n// based on the result. It also triggers the appropriate callback functions.\n//\n// Parameters:\n//   - loader: The SurfaceLoader to use for loading the surface.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the state is not SsNone, otherwise nil.\nfunc (s *StatefulReflectiveBoundTexture) LoadSurfaceAsync(loader SurfaceLoader, commit bool) error {\n\tif s.state != SurfaceStateNone {\n\t\treturn ErrNeedReset\n\t}\n\n\ts.state = SurfaceStateLoading\n\tif s.onLoading != nil {\n\t\tgo s.onLoading()\n\t}\n\n\tgo func() {\n\t\timg, err := loader.ServeRGBA()\n\t\tif err != nil {\n\t\t\ts.state = SurfaceStateFailure\n\t\t\ts.lastError = fmt.Errorf(\"in ReflectiveBoundTexture LoadSurface after loader.ServeRGBA: %w\", err)\n\n\t\t\tif s.onFailure != nil {\n\t\t\t\tgo s.onFailure(s.lastError)\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\te := s.SetSurfaceFromRGBA(img, commit)\n\t\tif e != nil {\n\t\t\ts.state = SurfaceStateFailure\n\t\t\ts.lastError = fmt.Errorf(\"in ReflectiveBoundTexture LoadSurface after SetSurfaceFromRGBA: %w\", err)\n\n\t\t\tif s.onFailure != nil {\n\t\t\t\tgo s.onFailure(s.lastError)\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\ts.state = SurfaceStateSuccess\n\n\t\tif s.onSuccess != nil {\n\t\t\tgo s.onSuccess()\n\t\t}\n\t}()\n\n\treturn nil\n}\n"
        },
        {
          "name": "Style.go",
          "type": "blob",
          "size": 8.5224609375,
          "content": "package giu\n\nimport (\n\t\"image/color\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// You may want to use styles in order to make your app looking more beautiful.\n// You have two ways to apply style to a widget:\n// 1. Use the StyleSetter e.g.:\n//    ```golang\n//   \tgiu.Style().\n//  \t\tSetStyle(giu.StyleVarWindowPadding, imgui.Vec2{10, 10})\n//  \t\tSetStyleFloat(giu.StyleVarGrabRounding, 5)\n//  \t\tSetColor(giu.StyleColorButton, colornames.Red).\n// \t\t\tTo(/*your widgets here*/),\n//   ```\n// NOTE/TODO: style variables could be Vec2 or float32 for details see comments\n// 2. use PushStyle/PushStyleColor in giu.Custom widget\n//    NOTE: remember about calling PopStyle/PopStyleColor at the end of styled section!\n//    example:\n//    ```golang\n// \t  \tgiu.Custom(func() {\n// \t\t  \timgui.PushStyleVarFlot(giu.StyleVarFrameRounding, 2)\n//    \t}),\n// \t\t/*your widgets here*/\n//   \tgiu.Custom(func() {\n//   \t\timgui.PopStyleVar()\n//   \t}),\n//    ```\n// below, you can find a few giu wrappers like PushItemSpacing PushColorFrameBG that\n// can be used in a similar way as shown above but without specifying style ID.\n//\n// See also:\n// - examples/setstyle for code example\n// - StyleIDs.go for list of all style/color IDs\n// - StyleSetter.go for user-friendly giu api for styles\n\n// PushFont sets font to \"font\"\n// NOTE: PopFont has to be called\n// NOTE: Don't use PushFont. use StyleSetter instead.\nfunc PushFont(font *FontInfo) bool {\n\tif font == nil {\n\t\treturn false\n\t}\n\n\tif f, ok := Context.FontAtlas.extraFontMap[font.String()]; ok {\n\t\timgui.PushFont(f)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// PopFont pops the font (should be called after PushFont).\nfunc PopFont() {\n\timgui.PopFont()\n}\n\n// PushStyleColor wraps imgui.PushStyleColorVec4\n// NOTE: don't forget to call PopStyleColor()!\nfunc PushStyleColor(id StyleColorID, col color.Color) {\n\timgui.PushStyleColorVec4(imgui.Col(id), ToVec4Color(col))\n}\n\n// PushColorText calls PushStyleColor(StyleColorText,...)\n// NOTE: don't forget to call PopStyleColor()!\nfunc PushColorText(col color.Color) {\n\timgui.PushStyleColorVec4(imgui.ColText, ToVec4Color(col))\n}\n\n// PushColorTextDisabled calls PushStyleColor(StyleColorTextDisabled,...)\n// NOTE: don't forget to call PopStyleColor()!\nfunc PushColorTextDisabled(col color.Color) {\n\timgui.PushStyleColorVec4(imgui.ColTextDisabled, ToVec4Color(col))\n}\n\n// PushColorWindowBg calls PushStyleColor(StyleColorWindowBg,...)\n// NOTE: don't forget to call PopStyleColor()!\nfunc PushColorWindowBg(col color.Color) {\n\timgui.PushStyleColorVec4(imgui.ColWindowBg, ToVec4Color(col))\n}\n\n// PushColorFrameBg calls PushStyleColor(StyleColorFrameBg,...)\n// NOTE: don't forget to call PopStyleColor()!\nfunc PushColorFrameBg(col color.Color) {\n\timgui.PushStyleColorVec4(imgui.ColFrameBg, ToVec4Color(col))\n}\n\n// PushColorButton calls PushStyleColor(StyleColorButton,...)\n// NOTE: don't forget to call PopStyleColor()!\nfunc PushColorButton(col color.Color) {\n\timgui.PushStyleColorVec4(imgui.ColButton, ToVec4Color(col))\n}\n\n// PushColorButtonHovered calls PushStyleColor(StyleColorButtonHovered,...)\n// NOTE: don't forget to call PopStyleColor()!\nfunc PushColorButtonHovered(col color.Color) {\n\timgui.PushStyleColorVec4(imgui.ColButtonHovered, ToVec4Color(col))\n}\n\n// PushColorButtonActive calls PushStyleColor(StyleColorButtonActive,...)\n// NOTE: don't forget to call PopStyleColor()!\nfunc PushColorButtonActive(col color.Color) {\n\timgui.PushStyleColorVec4(imgui.ColButtonActive, ToVec4Color(col))\n}\n\n// PushWindowPadding calls PushStyleVar(StyleWindowPadding,...)\nfunc PushWindowPadding(width, height float32) {\n\timgui.PushStyleVarVec2(imgui.StyleVarWindowPadding, imgui.Vec2{X: width, Y: height})\n}\n\n// PushFramePadding calls PushStyleVar(StyleFramePadding,...)\nfunc PushFramePadding(width, height float32) {\n\timgui.PushStyleVarVec2(imgui.StyleVarFramePadding, imgui.Vec2{X: width, Y: height})\n}\n\n// PushItemSpacing calls PushStyleVar(StyleVarItemSpacing,...)\nfunc PushItemSpacing(width, height float32) {\n\timgui.PushStyleVarVec2(imgui.StyleVarItemSpacing, imgui.Vec2{X: width, Y: height})\n}\n\n// PushButtonTextAlign sets alignment for button text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.\nfunc PushButtonTextAlign(width, height float32) {\n\timgui.PushStyleVarVec2(imgui.StyleVarButtonTextAlign, imgui.Vec2{X: width, Y: height})\n}\n\n// PushSelectableTextAlign sets alignment for selectable text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.\nfunc PushSelectableTextAlign(width, height float32) {\n\timgui.PushStyleVarVec2(imgui.StyleVarSelectableTextAlign, imgui.Vec2{X: width, Y: height})\n}\n\n// PopStyle should be called to stop applying style.\n// It should be called as many times, as you called PushStyle...\n// NOTE: If you don't call PopStyle imgui will panic.\nfunc PopStyle() {\n\timgui.PopStyleVar()\n}\n\n// PopStyleV does similarly to PopStyle, but allows to specify number\n// of styles you're going to pop.\nfunc PopStyleV(count int) {\n\timgui.PopStyleVarV(int32(count))\n}\n\n// PopStyleColor is used to stop applying colors styles.\n// It should be called after each PushStyleColor... (for each push)\n// If PopStyleColor wasn't called after PushColor... or was called\n// improperly, imgui will panic.\nfunc PopStyleColor() {\n\timgui.PopStyleColor()\n}\n\n// PopStyleColorV does similar to PopStyleColor, but allows to specify\n// how much style colors would you like to pop.\nfunc PopStyleColorV(count int) {\n\timgui.PopStyleColorV(int32(count))\n}\n\n// AlignTextToFramePadding vertically aligns upcoming text baseline to\n// FramePadding.y so that it will align properly to regularly framed\n// items. Call if you have text on a line before a framed item.\nfunc AlignTextToFramePadding() {\n\timgui.AlignTextToFramePadding()\n}\n\n// PushItemWidth sets following item's widths\n// NOTE: don't forget to call PopItemWidth! If you don't do so, imgui\n// will panic.\nfunc PushItemWidth(width float32) {\n\timgui.PushItemWidth(width)\n}\n\n// PopItemWidth should be called to stop applying PushItemWidth effect\n// If it isn't called imgui will panic.\nfunc PopItemWidth() {\n\timgui.PopItemWidth()\n}\n\n// PushTextWrapPos adds the position, where the text should be wrapped.\n// use PushTextWrapPos, render text. If text reaches frame end,\n// rendering will be continued at the start pos in line below.\n// NOTE: Don't forget to call PopWrapTextPos\n// NOTE: it is done automatically in LabelWidget (see (*LabelWidget).Wrapped()).\nfunc PushTextWrapPos() {\n\timgui.PushTextWrapPos()\n}\n\n// PopTextWrapPos should be called as many times as PushTextWrapPos\n// on each frame.\nfunc PopTextWrapPos() {\n\timgui.PopTextWrapPos()\n}\n\n// MouseCursorType represents a type (layout) of mouse cursor.\ntype MouseCursorType imgui.MouseCursor\n\n// cursor types.\nconst (\n\t// MouseCursorNone no mouse cursor.\n\tMouseCursorNone = MouseCursorType(imgui.MouseCursorNone)\n\t// MouseCursorArrow standard arrow mouse cursor.\n\tMouseCursorArrow = MouseCursorType(imgui.MouseCursorArrow)\n\t// MouseCursorTextInput when hovering over InputText, etc.\n\tMouseCursorTextInput = MouseCursorType(imgui.MouseCursorTextInput)\n\t// MouseCursorResizeAll (Unused by imgui functions).\n\tMouseCursorResizeAll = MouseCursorType(imgui.MouseCursorResizeAll)\n\t// MouseCursorResizeNS when hovering over an horizontal border.\n\tMouseCursorResizeNS = MouseCursorType(imgui.MouseCursorResizeNS)\n\t// MouseCursorResizeEW when hovering over a vertical border or a column.\n\tMouseCursorResizeEW = MouseCursorType(imgui.MouseCursorResizeEW)\n\t// MouseCursorResizeNESW when hovering over the bottom-left corner of a window.\n\tMouseCursorResizeNESW = MouseCursorType(imgui.MouseCursorResizeNESW)\n\t// MouseCursorResizeNWSE when hovering over the bottom-right corner of a window.\n\tMouseCursorResizeNWSE = MouseCursorType(imgui.MouseCursorResizeNWSE)\n\t// MouseCursorHand (Unused by imgui functions. Use for e.g. hyperlinks).\n\tMouseCursorHand  = MouseCursorType(imgui.MouseCursorHand)\n\tMouseCursorCount = MouseCursorType(imgui.MouseCursorCOUNT)\n)\n\n// SetMouseCursor sets mouse cursor layout.\nfunc SetMouseCursor(cursor MouseCursorType) {\n\timgui.SetMouseCursor(imgui.MouseCursor(cursor))\n}\n\n// GetWindowPadding returns window padding.\nfunc GetWindowPadding() (x, y float32) {\n\tvec2 := imgui.CurrentStyle().WindowPadding()\n\treturn vec2.X, vec2.Y\n}\n\n// GetItemSpacing returns current item spacing.\nfunc GetItemSpacing() (w, h float32) {\n\tvec2 := imgui.CurrentStyle().ItemSpacing()\n\treturn vec2.X, vec2.Y\n}\n\n// GetItemInnerSpacing returns current item inner spacing.\nfunc GetItemInnerSpacing() (w, h float32) {\n\tvec2 := imgui.CurrentStyle().ItemInnerSpacing()\n\treturn vec2.X, vec2.Y\n}\n\n// GetFramePadding returns current frame padding.\nfunc GetFramePadding() (x, y float32) {\n\tvec2 := imgui.CurrentStyle().FramePadding()\n\treturn vec2.X, vec2.Y\n}\n"
        },
        {
          "name": "StyleIDs.go",
          "type": "blob",
          "size": 18.3583984375,
          "content": "package giu\n\nimport (\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/AllenDang/cimgui-go/implot\"\n)\n\n// Here are the style IDs for styling imgui apps.\n// For details about each of attributes read comment above them.\n\n// go-generate String() andStringToEnum methods\n//go:generate go run github.com/dmarkham/enumer@latest -linecomment -type=StyleColorID .\n//go:generate go run github.com/dmarkham/enumer@latest -linecomment -type=StyleVarID .\n//go:generate go run github.com/dmarkham/enumer@latest -linecomment -type=StylePlotColorID .\n//go:generate go run github.com/dmarkham/enumer@latest -linecomment -type=StylePlotVarID .\n\n// StyleColorID identifies a color in the UI style.\ntype StyleColorID imgui.Col\n\n// StyleColor identifier.\n// NOTE: comments are used for CSS conversion and are generated by stringer and string2enum.\nconst (\n\tStyleColorText                  StyleColorID = StyleColorID(imgui.ColText)                  // color\n\tStyleColorTextDisabled          StyleColorID = StyleColorID(imgui.ColTextDisabled)          // disabled-color\n\tStyleColorWindowBg              StyleColorID = StyleColorID(imgui.ColWindowBg)              // background-color\n\tStyleColorChildBg               StyleColorID = StyleColorID(imgui.ColChildBg)               // child-background-color\n\tStyleColorPopupBg               StyleColorID = StyleColorID(imgui.ColPopupBg)               // popup-background-color\n\tStyleColorBorder                StyleColorID = StyleColorID(imgui.ColBorder)                // border-color\n\tStyleColorBorderShadow          StyleColorID = StyleColorID(imgui.ColBorderShadow)          // border-shadow-color\n\tStyleColorFrameBg               StyleColorID = StyleColorID(imgui.ColFrameBg)               // frame-background-color\n\tStyleColorFrameBgHovered        StyleColorID = StyleColorID(imgui.ColFrameBgHovered)        // frame-background-hovered-color\n\tStyleColorFrameBgActive         StyleColorID = StyleColorID(imgui.ColFrameBgActive)         // frame-background-active-color\n\tStyleColorTitleBg               StyleColorID = StyleColorID(imgui.ColTitleBg)               // title-background-color\n\tStyleColorTitleBgActive         StyleColorID = StyleColorID(imgui.ColTitleBgActive)         // title-background-active-color\n\tStyleColorTitleBgCollapsed      StyleColorID = StyleColorID(imgui.ColTitleBgCollapsed)      // title-background-collapsed-color\n\tStyleColorMenuBarBg             StyleColorID = StyleColorID(imgui.ColMenuBarBg)             // menu-bar-background-color\n\tStyleColorScrollbarBg           StyleColorID = StyleColorID(imgui.ColScrollbarBg)           // scrollbar-background-color\n\tStyleColorScrollbarGrab         StyleColorID = StyleColorID(imgui.ColScrollbarGrab)         // scrollbar-grab-color\n\tStyleColorScrollbarGrabHovered  StyleColorID = StyleColorID(imgui.ColScrollbarGrabHovered)  // scrollbar-grab-hovered-color\n\tStyleColorScrollbarGrabActive   StyleColorID = StyleColorID(imgui.ColScrollbarGrabActive)   // scrollbar-grab-active-color\n\tStyleColorCheckMark             StyleColorID = StyleColorID(imgui.ColCheckMark)             // checkmark-color\n\tStyleColorSliderGrab            StyleColorID = StyleColorID(imgui.ColSliderGrab)            // slider-grab-color\n\tStyleColorSliderGrabActive      StyleColorID = StyleColorID(imgui.ColSliderGrabActive)      // slider-grab-active-color\n\tStyleColorButton                StyleColorID = StyleColorID(imgui.ColButton)                // button-color\n\tStyleColorButtonHovered         StyleColorID = StyleColorID(imgui.ColButtonHovered)         // button-hovered-color\n\tStyleColorButtonActive          StyleColorID = StyleColorID(imgui.ColButtonActive)          // button-active-color\n\tStyleColorHeader                StyleColorID = StyleColorID(imgui.ColHeader)                // header-color\n\tStyleColorHeaderHovered         StyleColorID = StyleColorID(imgui.ColHeaderHovered)         // header-hovered-color\n\tStyleColorHeaderActive          StyleColorID = StyleColorID(imgui.ColHeaderActive)          // header-active-color\n\tStyleColorSeparator             StyleColorID = StyleColorID(imgui.ColSeparator)             // separator-color\n\tStyleColorSeparatorHovered      StyleColorID = StyleColorID(imgui.ColSeparatorHovered)      // separator-hovered-color\n\tStyleColorSeparatorActive       StyleColorID = StyleColorID(imgui.ColSeparatorActive)       // separator-active-color\n\tStyleColorResizeGrip            StyleColorID = StyleColorID(imgui.ColResizeGrip)            // resize-grip-color\n\tStyleColorResizeGripHovered     StyleColorID = StyleColorID(imgui.ColResizeGripHovered)     // resize-grip-hovered-color\n\tStyleColorResizeGripActive      StyleColorID = StyleColorID(imgui.ColResizeGripActive)      // resize-grip-active-color\n\tStyleColorTab                   StyleColorID = StyleColorID(imgui.ColTab)                   // tab-color\n\tStyleColorTabHovered            StyleColorID = StyleColorID(imgui.ColTabHovered)            // tab-hovered-color\n\tStyleColorTabActive             StyleColorID = StyleColorID(imgui.ColTabSelected)           // tab-active-color\n\tStyleColorTabUnfocused          StyleColorID = StyleColorID(imgui.ColTabDimmed)             // tab-unfocused-color\n\tStyleColorTabUnfocusedActive    StyleColorID = StyleColorID(imgui.ColTabDimmedSelected)     // tab-unfocused-active-color\n\tStyleColorPlotLines             StyleColorID = StyleColorID(imgui.ColPlotLines)             // plot-lines-color\n\tStyleColorPlotLinesHovered      StyleColorID = StyleColorID(imgui.ColPlotLinesHovered)      // plot-lines-hovered-color\n\tStyleColorProgressBarActive     StyleColorID = StyleColorPlotLinesHovered                   // progress-bar-active-color\n\tStyleColorPlotHistogram         StyleColorID = StyleColorID(imgui.ColPlotHistogram)         // plot-histogram-color\n\tStyleColorPlotHistogramHovered  StyleColorID = StyleColorID(imgui.ColPlotHistogramHovered)  // plot-histogram-hovered-color\n\tStyleColorTableHeaderBg         StyleColorID = StyleColorID(imgui.ColTableHeaderBg)         // table-header-background-color\n\tStyleColorTableBorderStrong     StyleColorID = StyleColorID(imgui.ColTableBorderStrong)     // table-border-strong-color\n\tStyleColorTableBorderLight      StyleColorID = StyleColorID(imgui.ColTableBorderLight)      // table-border-light-color\n\tStyleColorTableRowBg            StyleColorID = StyleColorID(imgui.ColTableRowBg)            // table-row-background-color\n\tStyleColorTableRowBgAlt         StyleColorID = StyleColorID(imgui.ColTableRowBgAlt)         // table-row-alternate-background-color\n\tStyleColorTextSelectedBg        StyleColorID = StyleColorID(imgui.ColTextSelectedBg)        // text-selected-background-color\n\tStyleColorDragDropTarget        StyleColorID = StyleColorID(imgui.ColDragDropTarget)        // drag-drop-target-color\n\tStyleColorNavHighlight          StyleColorID = StyleColorID(imgui.ColNavWindowingHighlight) // navigation-highlight-color\n\tStyleColorNavWindowingHighlight StyleColorID = StyleColorID(imgui.ColNavWindowingHighlight) // windowing-highlight-color\n\tStyleColorNavWindowingDimBg     StyleColorID = StyleColorID(imgui.ColNavWindowingDimBg)     // windowing-dim-background-color\n\tStyleColorModalWindowDimBg      StyleColorID = StyleColorID(imgui.ColModalWindowDimBg)      // modal-window-dim-background-color\n)\n\n// StyleVarID identifies a style variable in the UI style.\ntype StyleVarID imgui.StyleVar\n\n// Style IDs.\n// comments at same line is a CSS name.\nconst (\n\t// StyleVarAlpha is a float.\n\tStyleVarAlpha StyleVarID = StyleVarID(imgui.StyleVarAlpha) // alpha\n\t// StyleVarDisabledAlpha is a float.\n\tStyleVarDisabledAlpha StyleVarID = StyleVarID(imgui.StyleVarDisabledAlpha) // disabled-alpha\n\t// StyleVarWindowPadding is a Vec2.\n\tStyleVarWindowPadding StyleVarID = StyleVarID(imgui.StyleVarWindowPadding) // window-padding\n\t// StyleVarWindowRounding is a float.\n\tStyleVarWindowRounding StyleVarID = StyleVarID(imgui.StyleVarWindowRounding) // window-rounding\n\t// StyleVarWindowBorderSize is a float.\n\tStyleVarWindowBorderSize StyleVarID = StyleVarID(imgui.StyleVarWindowBorderSize) // window-border-size\n\t// StyleVarWindowMinSize is a Vec2.\n\tStyleVarWindowMinSize StyleVarID = StyleVarID(imgui.StyleVarWindowMinSize) // window-minValue-size\n\t// StyleVarWindowTitleAlign is a Vec2.\n\tStyleVarWindowTitleAlign StyleVarID = StyleVarID(imgui.StyleVarWindowTitleAlign) // window-title-align\n\t// StyleVarChildRounding is a float.\n\tStyleVarChildRounding StyleVarID = StyleVarID(imgui.StyleVarChildRounding) // child-rounding\n\t// StyleVarChildBorderSize is a float.\n\tStyleVarChildBorderSize StyleVarID = StyleVarID(imgui.StyleVarChildBorderSize) // child-border-size\n\t// StyleVarPopupRounding is a float.\n\tStyleVarPopupRounding StyleVarID = StyleVarID(imgui.StyleVarPopupRounding) // popup-rounding\n\t// StyleVarPopupBorderSize is a float.\n\tStyleVarPopupBorderSize StyleVarID = StyleVarID(imgui.StyleVarPopupBorderSize) // popup-border-size\n\t// StyleVarFramePadding is a Vec2.\n\tStyleVarFramePadding StyleVarID = StyleVarID(imgui.StyleVarFramePadding) // frame-padding\n\t// StyleVarFrameRounding is a float.\n\tStyleVarFrameRounding StyleVarID = StyleVarID(imgui.StyleVarFrameRounding) // frame-rounding\n\t// StyleVarFrameBorderSize is a float.\n\tStyleVarFrameBorderSize StyleVarID = StyleVarID(imgui.StyleVarFrameBorderSize) // frame-border-size\n\t// StyleVarItemSpacing is a Vec2.\n\tStyleVarItemSpacing StyleVarID = StyleVarID(imgui.StyleVarItemSpacing) // item-spacing\n\t// StyleVarItemInnerSpacing is a Vec2.\n\tStyleVarItemInnerSpacing StyleVarID = StyleVarID(imgui.StyleVarItemInnerSpacing) // item-inner-spacing\n\t// StyleVarIndentSpacing is a float.\n\tStyleVarIndentSpacing StyleVarID = StyleVarID(imgui.StyleVarIndentSpacing) // indent-spacing\n\t// StyleVarCellPadding is a Vec2.\n\tStyleVarCellPadding StyleVarID = StyleVarID(imgui.StyleVarCellPadding)\n\t// StyleVarScrollbarSize is a float.\n\tStyleVarScrollbarSize StyleVarID = StyleVarID(imgui.StyleVarScrollbarSize) // scrollbar-size\n\t// StyleVarScrollbarRounding is a float.\n\tStyleVarScrollbarRounding StyleVarID = StyleVarID(imgui.StyleVarScrollbarRounding) // scrollbar-rounding\n\t// StyleVarGrabMinSize is a float.\n\tStyleVarGrabMinSize StyleVarID = StyleVarID(imgui.StyleVarGrabMinSize) // grab-minValue-size\n\t// StyleVarGrabRounding is a float.\n\tStyleVarGrabRounding StyleVarID = StyleVarID(imgui.StyleVarGrabRounding) // grab-rounding\n\t// StyleVarTabRounding is a float.\n\tStyleVarTabRounding StyleVarID = StyleVarID(imgui.StyleVarTabRounding) // tab-rounding\n\t// StyleVarTabBarBorderSize is a float.\n\tStyleVarTabBarBorderSize StyleVarID = StyleVarID(imgui.StyleVarTabBarBorderSize)\n\t// StyleVarButtonTextAlign is a Vec2.\n\tStyleVarButtonTextAlign StyleVarID = StyleVarID(imgui.StyleVarButtonTextAlign) // button-text-align\n\t// StyleVarSelectableTextAlign is a Vec2.\n\tStyleVarSelectableTextAlign StyleVarID = StyleVarID(imgui.StyleVarSelectableTextAlign) // selectable-text-align\n\t// StyleVarSeparatorTextBorderSize is a float.\n\tStyleVarSeparatorTextBorderSize StyleVarID = StyleVarID(imgui.StyleVarSeparatorTextBorderSize)\n\t// SeparatorTextAlign is an ImVec2.\n\tStyleVarSeparatorTextAlign StyleVarID = StyleVarID(imgui.StyleVarSeparatorTextAlign)\n\t// SeparatorTextPadding is an ImVec2.\n\tStyleVarSeparatorTextPadding StyleVarID = StyleVarID(imgui.StyleVarSeparatorTextPadding)\n\t// DockingSeparatorSize is a float.\n\tStyleVarDockingSeparatorSize StyleVarID = StyleVarID(imgui.StyleVarDockingSeparatorSize)\n)\n\n// IsVec2 returns true if the style var id should be processed as imgui.Vec2\n// if not, it is interpreted as float32.\nfunc (i StyleVarID) IsVec2() bool {\n\tlookup := map[StyleVarID]bool{\n\t\t// StyleVarWindowPadding is a Vec2.\n\t\tStyleVarWindowPadding:    true,\n\t\tStyleVarWindowMinSize:    true,\n\t\tStyleVarWindowTitleAlign: true,\n\t\tStyleVarFramePadding:     true,\n\t\tStyleVarItemSpacing:      true,\n\t\t// StyleVarItemInnerSpacing is a Vec2.\n\t\tStyleVarItemInnerSpacing:    true,\n\t\tStyleVarButtonTextAlign:     true,\n\t\tStyleVarSelectableTextAlign: true,\n\t}\n\n\tresult, ok := lookup[i]\n\n\treturn result && ok\n}\n\n// StylePlotColorID represents an ID of plot color.\ntype StylePlotColorID int\n\n// List of plot color IDs.\nconst (\n\tStylePlotColorLine          StylePlotColorID = StylePlotColorID(implot.ColLine)          // plot-line\n\tStylePlotColorFill          StylePlotColorID = StylePlotColorID(implot.ColFill)          // plot-fill\n\tStylePlotColorMarkerOutline StylePlotColorID = StylePlotColorID(implot.ColMarkerOutline) // plot-marker-outline\n\tStylePlotColorMarkerFill    StylePlotColorID = StylePlotColorID(implot.ColMarkerFill)    // plot-Marker-Fill\n\tStylePlotColorErrorBar      StylePlotColorID = StylePlotColorID(implot.ColErrorBar)      // plot-error-bar\n\tStylePlotColorFrameBg       StylePlotColorID = StylePlotColorID(implot.ColFrameBg)       // plot-frame-bg\n\tStylePlotColorPlotBg        StylePlotColorID = StylePlotColorID(implot.ColPlotBg)        // plot-plot-bg\n\tStylePlotColorPlotBorder    StylePlotColorID = StylePlotColorID(implot.ColPlotBorder)    // plot-plot-border\n\tStylePlotColorLegendBg      StylePlotColorID = StylePlotColorID(implot.ColLegendBg)      // plot-legend-bg\n\tStylePlotColorLegendBorder  StylePlotColorID = StylePlotColorID(implot.ColLegendBorder)  // plot-legend-border\n\tStylePlotColorLegendText    StylePlotColorID = StylePlotColorID(implot.ColLegendText)    // plot-legend-text\n\tStylePlotColorTitleText     StylePlotColorID = StylePlotColorID(implot.ColTitleText)     // plot-title-text\n\tStylePlotColorInlayText     StylePlotColorID = StylePlotColorID(implot.ColInlayText)     // plot-inlay-text\n\tStylePlotColorAxisText      StylePlotColorID = StylePlotColorID(implot.ColAxisText)      // plot-axis-text\n\tStylePlotColorAxisGrid      StylePlotColorID = StylePlotColorID(implot.ColAxisGrid)      // plot-axis-grid\n\tStylePlotColorAxisTick      StylePlotColorID = StylePlotColorID(implot.ColAxisTick)      // plot-axis-tick\n\tStylePlotColorAxisBg        StylePlotColorID = StylePlotColorID(implot.ColAxisBg)        // plot-axis-bg\n\tStylePlotColorAxisBgHovered StylePlotColorID = StylePlotColorID(implot.ColAxisBgHovered) // plot-axis-bg-hovered\n\tStylePlotColorAxisBgActive  StylePlotColorID = StylePlotColorID(implot.ColAxisBgActive)  // plot-axis-bg-active\n\tStylePlotColorSelection     StylePlotColorID = StylePlotColorID(implot.ColSelection)     // plot-selection\n\tStylePlotColorCrosshairs    StylePlotColorID = StylePlotColorID(implot.ColCrosshairs)    // plot-crosshairs\n)\n\n// StylePlotVarID represents an ID of plot style variable.\ntype StylePlotVarID imgui.StyleVar\n\n// List of plot style variable IDs.\nconst (\n\tStylePlotVarLineWeight         StylePlotVarID = StylePlotVarID(implot.StyleVarLineWeight)         // plot-line-weight\n\tStylePlotVarMarker             StylePlotVarID = StylePlotVarID(implot.StyleVarMarker)             // plot-marker\n\tStylePlotVarMarkerSize         StylePlotVarID = StylePlotVarID(implot.StyleVarMarkerSize)         // plot-marker-size\n\tStylePlotVarMarkerWeight       StylePlotVarID = StylePlotVarID(implot.StyleVarMarkerWeight)       // plot-marker-weight\n\tStylePlotVarFillAlpha          StylePlotVarID = StylePlotVarID(implot.StyleVarFillAlpha)          // plot-fill-alpha\n\tStylePlotVarErrorBarSize       StylePlotVarID = StylePlotVarID(implot.StyleVarErrorBarSize)       // plot-error-bar-size\n\tStylePlotVarErrorBarWeight     StylePlotVarID = StylePlotVarID(implot.StyleVarErrorBarWeight)     // plot-error-bar-weight\n\tStylePlotVarDigitalBitHeight   StylePlotVarID = StylePlotVarID(implot.StyleVarDigitalBitHeight)   // plot-digital-bit-height\n\tStylePlotVarDigitalBitGap      StylePlotVarID = StylePlotVarID(implot.StyleVarDigitalBitGap)      // plot-digital-bit-gap\n\tStylePlotVarPlotBorderSize     StylePlotVarID = StylePlotVarID(implot.StyleVarPlotBorderSize)     // plot-border-size\n\tStylePlotVarMinorAlpha         StylePlotVarID = StylePlotVarID(implot.StyleVarMinorAlpha)         // plot-minor-alpha\n\tStylePlotVarMajorTickLen       StylePlotVarID = StylePlotVarID(implot.StyleVarMajorTickLen)       // plot-major-tick-len\n\tStylePlotVarMinorTickLen       StylePlotVarID = StylePlotVarID(implot.StyleVarMinorTickLen)       // plot-minor-tick-len\n\tStylePlotVarMajorTickSize      StylePlotVarID = StylePlotVarID(implot.StyleVarMajorTickSize)      // plot-major-tick-size\n\tStylePlotVarMinorTickSize      StylePlotVarID = StylePlotVarID(implot.StyleVarMinorTickSize)      // plot-minor-tick-size\n\tStylePlotVarMajorGridSize      StylePlotVarID = StylePlotVarID(implot.StyleVarMajorGridSize)      // plot-major-grid-size\n\tStylePlotVarMinorGridSize      StylePlotVarID = StylePlotVarID(implot.StyleVarMinorGridSize)      // plot-minor-grid-size\n\tStylePlotVarPlotPadding        StylePlotVarID = StylePlotVarID(implot.StyleVarPlotPadding)        // plot-padding\n\tStylePlotVarLabelPadding       StylePlotVarID = StylePlotVarID(implot.StyleVarLabelPadding)       // plot-label-padding\n\tStylePlotVarLegendPadding      StylePlotVarID = StylePlotVarID(implot.StyleVarLegendPadding)      // plot-legend-padding\n\tStylePlotVarLegendInnerPadding StylePlotVarID = StylePlotVarID(implot.StyleVarLegendInnerPadding) // plot-legend-inner-padding\n\tStylePlotVarLegendSpacing      StylePlotVarID = StylePlotVarID(implot.StyleVarLegendSpacing)      // plot-legend-spacing\n\tStylePlotVarMousePosPadding    StylePlotVarID = StylePlotVarID(implot.StyleVarMousePosPadding)    // plot-mouse-pos-padding\n\tStylePlotVarAnnotationPadding  StylePlotVarID = StylePlotVarID(implot.StyleVarAnnotationPadding)  // plot-annotation-padding\n\tStylePlotVarFitPadding         StylePlotVarID = StylePlotVarID(implot.StyleVarFitPadding)         // plot-fit-padding\n\tStylePlotVarPlotDefaultSize    StylePlotVarID = StylePlotVarID(implot.StyleVarPlotDefaultSize)    // plot-default-size\n\tStylePlotVarPlotMinSize        StylePlotVarID = StylePlotVarID(implot.StyleVarPlotMinSize)        // plot-min-size\n\tStylePlotVarCOUNT              StylePlotVarID = StylePlotVarID(implot.StyleVarCOUNT)\n)\n\n// IsVec2 returns true if the style plot var id should be processed as imgui.Vec2\n// if not, it is interpreted as float32.\nfunc (i StylePlotVarID) IsVec2() bool {\n\tlookup := map[StylePlotVarID]bool{\n\t\tStylePlotVarMajorTickLen:       true,\n\t\tStylePlotVarMinorTickLen:       true,\n\t\tStylePlotVarMajorTickSize:      true,\n\t\tStylePlotVarMinorTickSize:      true,\n\t\tStylePlotVarMajorGridSize:      true,\n\t\tStylePlotVarMinorGridSize:      true,\n\t\tStylePlotVarPlotPadding:        true,\n\t\tStylePlotVarLabelPadding:       true,\n\t\tStylePlotVarLegendPadding:      true,\n\t\tStylePlotVarLegendInnerPadding: true,\n\t\tStylePlotVarLegendSpacing:      true,\n\t\tStylePlotVarMousePosPadding:    true,\n\t\tStylePlotVarAnnotationPadding:  true,\n\t\tStylePlotVarFitPadding:         true,\n\t\tStylePlotVarPlotDefaultSize:    true,\n\t\tStylePlotVarPlotMinSize:        true,\n\t}\n\n\tresult, ok := lookup[i]\n\n\treturn result && ok\n}\n"
        },
        {
          "name": "StyleSetter.go",
          "type": "blob",
          "size": 6.328125,
          "content": "package giu\n\nimport (\n\t\"image/color\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/AllenDang/cimgui-go/implot\"\n)\n\nvar _ Widget = &StyleSetter{}\n\n// StyleSetter is a user-friendly way to manage imgui styles.\n// For style IDs see StyleIDs.go, for detailed instruction of using styles, see Styles.go.\ntype StyleSetter struct {\n\tcolors     map[StyleColorID]color.Color\n\tstyles     map[StyleVarID]any\n\tplotColors map[StylePlotColorID]color.Color\n\tplotStyles map[StylePlotVarID]any\n\tfont       *FontInfo\n\tdisabled   bool\n\n\tlayout Layout\n\tplots  []PlotWidget\n\n\t// set by imgui.PushFont inside ss.Push() method\n\tisFontPushed bool\n}\n\n// Style initializes a style setter (see examples/setstyle).\nfunc Style() *StyleSetter {\n\tvar ss StyleSetter\n\tss.colors = make(map[StyleColorID]color.Color)\n\tss.plotColors = make(map[StylePlotColorID]color.Color)\n\tss.styles = make(map[StyleVarID]any)\n\tss.plotStyles = make(map[StylePlotVarID]any)\n\n\treturn &ss\n}\n\n// SetColor sets colorID's color.\nfunc (ss *StyleSetter) SetColor(colorID StyleColorID, col color.Color) *StyleSetter {\n\tss.colors[colorID] = col\n\treturn ss\n}\n\n// SetStyle sets styleVarID to width and height.\nfunc (ss *StyleSetter) SetStyle(varID StyleVarID, width, height float32) *StyleSetter {\n\tss.styles[varID] = imgui.Vec2{X: width, Y: height}\n\treturn ss\n}\n\n// SetStyleFloat sets styleVarID to float value.\n// NOTE: for float typed values see above in comments over\n// StyleVarID's comments.\nfunc (ss *StyleSetter) SetStyleFloat(varID StyleVarID, value float32) *StyleSetter {\n\tss.styles[varID] = value\n\treturn ss\n}\n\n// SetPlotColor sets colorID's color.\nfunc (ss *StyleSetter) SetPlotColor(colorID StylePlotColorID, col color.Color) *StyleSetter {\n\tss.plotColors[colorID] = col\n\treturn ss\n}\n\n// SetPlotStyle sets stylePlotVarID to width and height.\nfunc (ss *StyleSetter) SetPlotStyle(varID StylePlotVarID, width, height float32) *StyleSetter {\n\tss.plotStyles[varID] = imgui.Vec2{X: width, Y: height}\n\treturn ss\n}\n\n// SetPlotStyleFloat sets StylePlotVarID to float value.\n// NOTE: for float typed values see above in comments over\n// StyleVarID's comments.\nfunc (ss *StyleSetter) SetPlotStyleFloat(varID StylePlotVarID, value float32) *StyleSetter {\n\tss.plotStyles[varID] = value\n\treturn ss\n}\n\n// SetFont sets font.\nfunc (ss *StyleSetter) SetFont(font *FontInfo) *StyleSetter {\n\tss.font = font\n\treturn ss\n}\n\n// SetFontSize sets size of the font.\n// NOTE: Be aware, that StyleSetter needs to add a new font to font atlas for\n// each font's size.\nfunc (ss *StyleSetter) SetFontSize(size float32) *StyleSetter {\n\tvar font FontInfo\n\tif ss.font != nil {\n\t\tfont = *ss.font\n\t} else {\n\t\tfont = Context.FontAtlas.defaultFonts[0]\n\t}\n\n\tss.font = font.SetSize(size)\n\n\treturn ss\n}\n\n// SetDisabled sets if items are disabled.\nfunc (ss *StyleSetter) SetDisabled(d bool) *StyleSetter {\n\tss.disabled = d\n\treturn ss\n}\n\n// To allows to specify a layout, StyleSetter should apply style for.\nfunc (ss *StyleSetter) To(widgets ...Widget) *StyleSetter {\n\tss.layout = widgets\n\treturn ss\n}\n\n// Plots allows to set plots to apply style for.\nfunc (ss *StyleSetter) Plots(widgets ...PlotWidget) *StyleSetter {\n\tss.plots = widgets\n\treturn ss\n}\n\n// Range implements Splitable interface.\nfunc (ss *StyleSetter) Range(rangeFunc func(w Widget)) {\n\tif ss.layout != nil {\n\t\tvar result Layout\n\n\t\t// need to consider the following cases:\n\t\t// if 0 - return\n\t\t// if 1 - joing push/render/pop in one step\n\t\t// else - join push with first widget, than render another\n\t\t//        widgets and in the end render last widget with pop func\n\t\t// it is, because Push/Pop don't move cursor so\n\t\t// they doesn't exist for imgui in fact.\n\t\t// It leads to problemms with RowWidget\n\t\t//\n\t\t// see: https://github.com/AllenDang/giu/issues/619\n\t\tlayoutLen := len(ss.layout)\n\t\tswitch layoutLen {\n\t\tcase 0:\n\t\t\treturn\n\t\tcase 1:\n\t\t\tresult = Layout{\n\t\t\t\tCustom(func() {\n\t\t\t\t\tss.Push()\n\t\t\t\t\tss.layout.Build()\n\t\t\t\t\tss.Pop()\n\t\t\t\t}),\n\t\t\t}\n\t\tdefault:\n\t\t\tresult = Layout{\n\t\t\t\tCustom(func() {\n\t\t\t\t\tss.Push()\n\t\t\t\t\tss.layout[0].Build()\n\t\t\t\t}),\n\t\t\t\tss.layout[1 : len(ss.layout)-1],\n\t\t\t\tCustom(func() {\n\t\t\t\t\tss.layout[layoutLen-1].Build()\n\t\t\t\t\tss.Pop()\n\t\t\t\t}),\n\t\t\t}\n\t\t}\n\n\t\tresult.Range(rangeFunc)\n\t}\n}\n\n// Build implements Widget.\nfunc (ss *StyleSetter) Build() {\n\tif len(ss.layout) == 0 {\n\t\treturn\n\t}\n\n\tss.Push()\n\n\tss.layout.Build()\n\n\tss.Pop()\n}\n\n// Plot implements PlotWidget.\nfunc (ss *StyleSetter) Plot() {\n\tif len(ss.plots) == 0 {\n\t\treturn\n\t}\n\n\tss.Push()\n\n\tfor _, plot := range ss.plots {\n\t\tplot.Plot()\n\t}\n\n\tss.Pop()\n}\n\n// Push allows to manually activate Styles written inside of StyleSetter\n// it works like imgui.PushXXX() stuff, but for group of style variables,\n// just like StyleSetter.\n// NOTE: DO NOT ORGET to call ss.Pop() at the end of styled layout, because\n// else you'll get ImGui exception!\nfunc (ss *StyleSetter) Push() {\n\t// Push colors\n\tfor k, v := range ss.colors {\n\t\timgui.PushStyleColorVec4(imgui.Col(k), ToVec4Color(v))\n\t}\n\n\t// Push plot colors\n\tfor k, v := range ss.plotColors {\n\t\timplot.PushStyleColorVec4(implot.Col(k), ToVec4Color(v))\n\t}\n\n\t// push style vars\n\tfor k, v := range ss.styles {\n\t\tpushVarID(k.IsVec2(), v, func(value float32) {\n\t\t\timgui.PushStyleVarFloat(imgui.StyleVar(k), value)\n\t\t}, func(value imgui.Vec2) {\n\t\t\timgui.PushStyleVarVec2(imgui.StyleVar(k), value)\n\t\t})\n\t}\n\n\t// Push plot colors\n\tfor k, v := range ss.plotStyles {\n\t\tpushVarID(k.IsVec2(), v, func(value float32) {\n\t\t\timplot.PushStyleVarFloat(implot.StyleVar(k), value)\n\t\t}, func(value imgui.Vec2) {\n\t\t\timplot.PushStyleVarVec2(implot.StyleVar(k), value)\n\t\t})\n\t}\n\n\t// push font\n\tif ss.font != nil {\n\t\tss.isFontPushed = PushFont(ss.font)\n\t}\n\n\tif ss.disabled {\n\t\timgui.BeginDisabled()\n\t}\n}\n\n// Pop allows to manually pop the whole StyleSetter (use after Push!)\nfunc (ss *StyleSetter) Pop() {\n\tif ss.isFontPushed {\n\t\timgui.PopFont()\n\t}\n\n\tif ss.disabled {\n\t\timgui.EndDisabled()\n\t}\n\n\timgui.PopStyleColorV(int32(len(ss.colors)))\n\timplot.PopStyleColorV(int32(len(ss.plotColors)))\n\timgui.PopStyleVarV(int32(len(ss.styles)))\n\timplot.PopStyleVarV(int32(len(ss.plotStyles)))\n}\n\nfunc pushVarID(isVec2 bool, v any, pushFloat func(float32), pushVec2 func(imgui.Vec2)) {\n\tif isVec2 {\n\t\tvar value imgui.Vec2\n\t\tswitch typed := v.(type) {\n\t\tcase imgui.Vec2:\n\t\t\tvalue = typed\n\t\tcase float32:\n\t\t\tvalue = imgui.Vec2{X: typed, Y: typed}\n\t\t}\n\n\t\tpushVec2(value)\n\t} else {\n\t\tvar value float32\n\t\tswitch typed := v.(type) {\n\t\tcase float32:\n\t\t\tvalue = typed\n\t\tcase imgui.Vec2:\n\t\t\tvalue = typed.X\n\t\t}\n\n\t\tpushFloat(value)\n\t}\n}\n"
        },
        {
          "name": "SurfaceLoaders.go",
          "type": "blob",
          "size": 11.1318359375,
          "content": "package giu\n\nimport (\n\tgo_ctx \"context\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/draw\"\n\t\"io/fs\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// SurfaceLoader is an interface that defines a method to serve an RGBA image.\ntype SurfaceLoader interface {\n\t// ServeRGBA serves an RGBA image.\n\t//\n\t// Returns:\n\t//   - *image.RGBA: The RGBA image.\n\t//   - error: An error if the image could not be served.\n\tServeRGBA() (*image.RGBA, error)\n}\n\n// SurfaceLoaderFunc is a function type that serves an RGBA image.\ntype SurfaceLoaderFunc func() (*image.RGBA, error)\n\n// LoadSurfaceFunc loads a surface using a SurfaceLoaderFunc.\n//\n// Parameters:\n//   - fn: The SurfaceLoaderFunc to use for loading the surface.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the surface could not be loaded.\nfunc (i *ReflectiveBoundTexture) LoadSurfaceFunc(fn SurfaceLoaderFunc, commit bool) error {\n\timg, err := fn()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn i.SetSurfaceFromRGBA(img, commit)\n}\n\n// LoadSurface loads a surface using a SurfaceLoader.\n//\n// Parameters:\n//   - loader: The SurfaceLoader to use for loading the surface.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the surface could not be loaded.\nfunc (i *ReflectiveBoundTexture) LoadSurface(loader SurfaceLoader, commit bool) error {\n\timg, err := loader.ServeRGBA()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"in ReflectiveBoundTexture LoadSurface after loader.ServeRGBA: %w\", err)\n\t}\n\n\treturn i.SetSurfaceFromRGBA(img, commit)\n}\n\n// LoadSurface loads a surface asynchronously using a SurfaceLoader.\n//\n// Parameters:\n//   - loader: The SurfaceLoader to use for loading the surface.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the surface could not be loaded.\nfunc (s *StatefulReflectiveBoundTexture) LoadSurface(loader SurfaceLoader, commit bool) error {\n\treturn s.LoadSurfaceAsync(loader, commit)\n}\n\nvar _ SurfaceLoader = &FileLoader{}\n\n// FileLoader is a struct that implements the SurfaceLoader interface for loading images from a file.\ntype FileLoader struct {\n\tpath string\n}\n\n// ServeRGBA loads an RGBA image from the file specified by the path in fileLoader.\n//\n// Returns:\n//   - *image.RGBA: The loaded RGBA image.\n//   - error: An error if the image could not be loaded.\nfunc (f *FileLoader) ServeRGBA() (*image.RGBA, error) {\n\timg, err := LoadImage(f.path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn img, nil\n}\n\n// NewFileLoader creates a new SurfaceLoader that loads images from the specified file path.\n//\n// Parameters:\n//   - path: The path to the file to load the image from.\n//\n// Returns:\n//   - SurfaceLoader: A new SurfaceLoader for loading images from the specified file path.\nfunc NewFileLoader(path string) *FileLoader {\n\treturn &FileLoader{\n\t\tpath: path,\n\t}\n}\n\n// SetSurfaceFromFile loads an image from the specified file path and sets it as the surface of the ReflectiveBoundTexture.\n//\n// Parameters:\n//   - path: The path to the file to load the image from.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the image could not be loaded or set as the surface.\nfunc (i *ReflectiveBoundTexture) SetSurfaceFromFile(path string, commit bool) error {\n\treturn i.LoadSurface(NewFileLoader(path), commit)\n}\n\n// SetSurfaceFromFile loads an image from the specified file path and sets it as the surface of the StatefulReflectiveBoundTexture.\n//\n// Parameters:\n//   - path: The path to the file to load the image from.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the image could not be loaded or set as the surface.\nfunc (s *StatefulReflectiveBoundTexture) SetSurfaceFromFile(path string, commit bool) error {\n\treturn s.LoadSurface(NewFileLoader(path), commit)\n}\n\nvar _ SurfaceLoader = &FsFileLoader{}\n\n// FsFileLoader is a struct that implements the SurfaceLoader interface for loading images from a file and embedded fs.\ntype FsFileLoader struct {\n\tfile fs.File\n}\n\n// ServeRGBA loads an RGBA image from the file specified by the path in fileLoader.\n//\n// Returns:\n//   - *image.RGBA: The loaded RGBA image.\n//   - error: An error if the image could not be loaded.\nfunc (f *FsFileLoader) ServeRGBA() (*image.RGBA, error) {\n\timg, err := PNGToRgba(f.file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn img, nil\n}\n\n// NewFsFileLoader creates a new SurfaceLoader that loads images from the specified file interface.\n//\n// Parameters:\n//   - file: the file interface representing the file\n//\n// Returns:\n//   - SurfaceLoader: A new SurfaceLoader for loading images from the specified file path.\nfunc NewFsFileLoader(file fs.File) *FsFileLoader {\n\treturn &FsFileLoader{\n\t\tfile: file,\n\t}\n}\n\n// SetSurfaceFromFsFile loads an image from the specified file interface and sets it as the surface of the ReflectiveBoundTexture.\n//\n// Parameters:\n//   - file: the file interface representing the file\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the image could not be loaded or set as the surface.\nfunc (i *ReflectiveBoundTexture) SetSurfaceFromFsFile(file fs.File, commit bool) error {\n\treturn i.LoadSurface(NewFsFileLoader(file), commit)\n}\n\n// SetSurfaceFromFsFile loads an image from the specified file interface and sets it as the surface of the StatefulReflectiveBoundTexture.\n//\n// Parameters:\n//   - file: the file interface representing the file\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the image could not be loaded or set as the surface.\nfunc (s *StatefulReflectiveBoundTexture) SetSurfaceFromFsFile(file fs.File, commit bool) error {\n\treturn s.LoadSurface(NewFsFileLoader(file), commit)\n}\n\nvar _ SurfaceLoader = &URLLoader{}\n\n// URLLoader is a SurfaceLoader that loads images from a specified URL.\ntype URLLoader struct {\n\turl     string\n\ttimeout time.Duration\n\thttpdir string\n}\n\n// ServeRGBA loads an image from the URL and returns it as an RGBA image.\n//\n// Returns:\n//   - *image.RGBA: The loaded RGBA image.\n//   - error: An error if the image could not be loaded.\nfunc (u *URLLoader) ServeRGBA() (*image.RGBA, error) {\n\tt := &http.Transport{}\n\tt.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(u.httpdir)))\n\n\tclient := &http.Client{\n\t\tTransport: t,\n\t\tTimeout:   u.timeout,\n\t}\n\n\treq, err := http.NewRequestWithContext(go_ctx.Background(), http.MethodGet, u.url, http.NoBody)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"urlLoader serveRGBA after http.NewRequestWithContext: %w\", err)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"urlLoader serveRGBA after client.Do: %w\", err)\n\t}\n\n\tdefer func() {\n\t\terr := resp.Body.Close()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}()\n\n\timg, _, err := image.Decode(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"urlLoader serveRGBA after image.Decode: %w\", err)\n\t}\n\n\treturn ImageToRgba(img), nil\n}\n\n// NewURLLoader creates a new SurfaceLoader that loads images from the specified URL.\n//\n// Parameters:\n//   - url: The URL to load the image from.\n//   - httpdir: The root directory for file:// URLs.\n//   - timeout: The timeout duration for the HTTP request.\n//\n// Returns:\n//   - SurfaceLoader: A new SurfaceLoader for loading images from the specified URL.\nfunc NewURLLoader(url, httpdir string, timeout time.Duration) *URLLoader {\n\treturn &URLLoader{\n\t\turl:     url,\n\t\ttimeout: timeout,\n\t\thttpdir: httpdir,\n\t}\n}\n\n// SetFSRoot sets the root directory for file:// URLs.\n//\n// Parameters:\n//   - root: The root directory to set.\nfunc (i *ReflectiveBoundTexture) SetFSRoot(root string) {\n\ti.fsroot = root\n}\n\n// GetFSRoot returns the root directory for file:// URLs.\n//\n// Returns:\n//   - string: The root directory.\nfunc (i *ReflectiveBoundTexture) GetFSRoot() string {\n\treturn i.fsroot\n}\n\n// SetSurfaceFromURL loads an image from the specified URL and sets it as the surface of the ReflectiveBoundTexture.\n//\n// Parameters:\n//   - url: The URL to load the image from.\n//   - timeout: The timeout duration for the HTTP request.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the image could not be loaded or set as the surface.\nfunc (i *ReflectiveBoundTexture) SetSurfaceFromURL(url string, timeout time.Duration, commit bool) error {\n\treturn i.LoadSurface(NewURLLoader(url, i.fsroot, timeout), commit)\n}\n\n// SetSurfaceFromURL loads an image from the specified URL and sets it as the surface of the StatefulReflectiveBoundTexture.\n//\n// Parameters:\n//   - url: The URL to load the image from.\n//   - timeout: The timeout duration for the HTTP request.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the image could not be loaded or set as the surface.\nfunc (s *StatefulReflectiveBoundTexture) SetSurfaceFromURL(url string, timeout time.Duration, commit bool) error {\n\treturn s.LoadSurface(NewURLLoader(url, s.fsroot, timeout), commit)\n}\n\nvar _ SurfaceLoader = &UniformLoader{}\n\n// UniformLoader is a SurfaceLoader that creates a uniform color image.\ntype UniformLoader struct {\n\twidth, height int\n\tcolor         color.Color\n}\n\n// ServeRGBA creates a uniform color image and returns it as an RGBA image.\n//\n// Returns:\n//   - *image.RGBA: The created RGBA image.\n//   - error: An error if the image could not be created.\nfunc (u *UniformLoader) ServeRGBA() (*image.RGBA, error) {\n\timg := image.NewRGBA(image.Rect(0, 0, u.width, u.height))\n\tdraw.Draw(img, img.Bounds(), &image.Uniform{u.color}, image.Point{}, draw.Src)\n\n\treturn img, nil\n}\n\n// NewUniformLoader creates a new SurfaceLoader that creates a uniform color image.\n//\n// Parameters:\n//   - width: The width of the image.\n//   - height: The height of the image.\n//   - c: The color of the image.\n//\n// Returns:\n//   - SurfaceLoader: A new SurfaceLoader for creating a uniform color image.\nfunc NewUniformLoader(width, height int, c color.Color) *UniformLoader {\n\treturn &UniformLoader{\n\t\twidth:  width,\n\t\theight: height,\n\t\tcolor:  c,\n\t}\n}\n\n// SetSurfaceUniform creates a uniform color image and sets it as the surface of the ReflectiveBoundTexture.\n//\n// Parameters:\n//   - width: The width of the image.\n//   - height: The height of the image.\n//   - c: The color of the image.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the image could not be created or set as the surface.\nfunc (i *ReflectiveBoundTexture) SetSurfaceUniform(width, height int, c color.Color, commit bool) error {\n\treturn i.LoadSurface(NewUniformLoader(width, height, c), commit)\n}\n\n// SetSurfaceUniform creates a uniform color image and sets it as the surface of the StatefulReflectiveBoundTexture.\n//\n// Parameters:\n//   - width: The width of the image.\n//   - height: The height of the image.\n//   - c: The color of the image.\n//   - commit: A boolean flag indicating whether to commit the changes.\n//\n// Returns:\n//   - error: An error if the image could not be created or set as the surface.\nfunc (s *StatefulReflectiveBoundTexture) SetSurfaceUniform(width, height int, c color.Color, commit bool) error {\n\treturn s.LoadSurface(NewUniformLoader(width, height, c), commit)\n}\n"
        },
        {
          "name": "TableWidgets.go",
          "type": "blob",
          "size": 9.44140625,
          "content": "package giu\n\nimport (\n\t\"image/color\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// TableRowWidget represents a row in a table.\ntype TableRowWidget struct {\n\tflags        TableRowFlags\n\tminRowHeight float64\n\tlayout       Layout\n\tbgColor      color.Color\n}\n\n// TableRow creates a TbleRowWidget.\n// Each widget will be rendered in a separated column.\n// NOTE: if you want to put multiple widgets in one cell, enclose them in Layout{}.\nfunc TableRow(widgets ...Widget) *TableRowWidget {\n\treturn &TableRowWidget{\n\t\tflags:        0,\n\t\tminRowHeight: 0,\n\t\tlayout:       widgets,\n\t\tbgColor:      nil,\n\t}\n}\n\n// BgColor sets the background color of the row.\nfunc (r *TableRowWidget) BgColor(c color.Color) *TableRowWidget {\n\tr.bgColor = c\n\treturn r\n}\n\n// Flags sets the flags of the row.\nfunc (r *TableRowWidget) Flags(flags TableRowFlags) *TableRowWidget {\n\tr.flags = flags\n\treturn r\n}\n\n// MinHeight sets the minimum height of the row.\nfunc (r *TableRowWidget) MinHeight(height float64) *TableRowWidget {\n\tr.minRowHeight = height\n\treturn r\n}\n\n// BuildTableRow executes table row build steps.\nfunc (r *TableRowWidget) BuildTableRow() {\n\timgui.TableNextRowV(imgui.TableRowFlags(r.flags), float32(r.minRowHeight))\n\n\tfor _, w := range r.layout {\n\t\tswitch w.(type) {\n\t\tcase *TooltipWidget,\n\t\t\t*ContextMenuWidget, *PopupModalWidget:\n\t\t\t// noop\n\t\tdefault:\n\t\t\timgui.TableNextColumn()\n\t\t}\n\n\t\tw.Build()\n\t}\n\n\tif r.bgColor != nil {\n\t\timgui.TableSetBgColorV(imgui.TableBgTargetRowBg0, imgui.ColorU32Vec4(ToVec4Color(r.bgColor)), -1)\n\t}\n}\n\n// TableColumnWidget allows to configure table columns headers.\ntype TableColumnWidget struct {\n\tlabel              string\n\tflags              TableColumnFlags\n\tinnerWidthOrWeight float32\n\tuserID             uint32\n}\n\n// TableColumn creates a new TableColumnWidget.\nfunc TableColumn(label string) *TableColumnWidget {\n\treturn &TableColumnWidget{\n\t\tlabel:              Context.FontAtlas.RegisterString(label),\n\t\tflags:              0,\n\t\tinnerWidthOrWeight: 0,\n\t\tuserID:             0,\n\t}\n}\n\n// Flags sets the flags of the column.\nfunc (c *TableColumnWidget) Flags(flags TableColumnFlags) *TableColumnWidget {\n\tc.flags = flags\n\treturn c\n}\n\n// InnerWidthOrWeight sets the inner width or weight of the column.\nfunc (c *TableColumnWidget) InnerWidthOrWeight(w float32) *TableColumnWidget {\n\tc.innerWidthOrWeight = w\n\treturn c\n}\n\n// UserID sets the user id of the column.\nfunc (c *TableColumnWidget) UserID(id uint32) *TableColumnWidget {\n\tc.userID = id\n\treturn c\n}\n\n// BuildTableColumn executes table column build steps.\nfunc (c *TableColumnWidget) BuildTableColumn() {\n\timgui.TableSetupColumnV(c.label, imgui.TableColumnFlags(c.flags), c.innerWidthOrWeight, imgui.ID(c.userID))\n}\n\nvar _ Widget = &TableWidget{}\n\n// TableWidget is a table widget.\n// - Call Table to create new\n// - Then use Rows method to add content\n// - Use Columns method to configure columns (optional).\ntype TableWidget struct {\n\tid           ID\n\tflags        TableFlags\n\tsize         imgui.Vec2\n\tinnerWidth   float64\n\trows         []*TableRowWidget\n\tcolumns      []*TableColumnWidget\n\tfastMode     bool\n\tfreezeRow    int\n\tfreezeColumn int\n\tnoHeader     bool\n}\n\n// Table creates new TableWidget.\nfunc Table() *TableWidget {\n\treturn &TableWidget{\n\t\tid:           GenAutoID(\"Table\"),\n\t\tflags:        TableFlagsResizable | TableFlagsBorders | TableFlagsScrollY,\n\t\trows:         nil,\n\t\tcolumns:      nil,\n\t\tfastMode:     false,\n\t\tfreezeRow:    -1,\n\t\tfreezeColumn: -1,\n\t\tnoHeader:     false,\n\t}\n}\n\n// ID sets the internal id of table widget.\nfunc (t *TableWidget) ID(id ID) *TableWidget {\n\tt.id = id\n\treturn t\n}\n\n// FastMode Displays visible rows only to boost performance.\nfunc (t *TableWidget) FastMode(b bool) *TableWidget {\n\tt.fastMode = b\n\treturn t\n}\n\n// NoHeader indicates that the column header should not be shown. This allows\n// the use of the Columns() function to configure table columns (eg. column\n// width) but without showing the table header.\nfunc (t *TableWidget) NoHeader(b bool) *TableWidget {\n\tt.noHeader = b\n\treturn t\n}\n\n// Freeze columns/rows so they stay visible when scrolled.\nfunc (t *TableWidget) Freeze(col, row int) *TableWidget {\n\tt.freezeColumn = col\n\tt.freezeRow = row\n\n\treturn t\n}\n\n// Columns adds a list of column widgets to be used in the table. Columns added\n// with this function will cause the table header to be shown. If the table\n// header is not required then the NoHeader() function can be used.\nfunc (t *TableWidget) Columns(cols ...*TableColumnWidget) *TableWidget {\n\tt.columns = cols\n\treturn t\n}\n\n// Rows sets the rows of the table.\nfunc (t *TableWidget) Rows(rows ...*TableRowWidget) *TableWidget {\n\tt.rows = rows\n\treturn t\n}\n\n// Size sets the size of the table.\nfunc (t *TableWidget) Size(width, height float32) *TableWidget {\n\tt.size = imgui.Vec2{X: width, Y: height}\n\treturn t\n}\n\n// InnerWidth sets the inner width of the table.\nfunc (t *TableWidget) InnerWidth(width float64) *TableWidget {\n\tt.innerWidth = width\n\treturn t\n}\n\n// Flags sets the flags of the table.\nfunc (t *TableWidget) Flags(flags TableFlags) *TableWidget {\n\tt.flags = flags\n\treturn t\n}\n\n// Build implements Widget interface.\nfunc (t *TableWidget) Build() {\n\tcolCount := len(t.columns)\n\tif colCount == 0 {\n\t\tif len(t.rows) > 0 {\n\t\t\tcolCount = len(t.rows[0].layout)\n\t\t} else {\n\t\t\t// No rows or columns, pass a single column to BeginTable\n\t\t\tcolCount = 1\n\t\t}\n\t}\n\n\tif imgui.BeginTableV(t.id.String(), int32(colCount), imgui.TableFlags(t.flags), t.size, float32(t.innerWidth)) {\n\t\tif t.freezeColumn >= 0 && t.freezeRow >= 0 {\n\t\t\timgui.TableSetupScrollFreeze(int32(t.freezeColumn), int32(t.freezeRow))\n\t\t}\n\n\t\tif len(t.columns) > 0 {\n\t\t\tfor _, col := range t.columns {\n\t\t\t\tcol.BuildTableColumn()\n\t\t\t}\n\n\t\t\tif !t.noHeader {\n\t\t\t\timgui.TableHeadersRow()\n\t\t\t}\n\t\t}\n\n\t\tif t.fastMode {\n\t\t\tclipper := imgui.NewListClipper()\n\t\t\tdefer clipper.Destroy()\n\n\t\t\tclipper.Begin(int32(len(t.rows)))\n\n\t\t\tfor clipper.Step() {\n\t\t\t\tfor i := clipper.DisplayStart(); i < clipper.DisplayEnd(); i++ {\n\t\t\t\t\trow := t.rows[i]\n\t\t\t\t\trow.BuildTableRow()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclipper.End()\n\t\t} else {\n\t\t\tfor _, row := range t.rows {\n\t\t\t\trow.BuildTableRow()\n\t\t\t}\n\t\t}\n\n\t\timgui.EndTable()\n\t}\n}\n\n// TreeTableRowWidget is a row in TreeTableWidget.\ntype TreeTableRowWidget struct {\n\tlabel    ID\n\tflags    TreeNodeFlags\n\tlayout   Layout\n\tchildren []*TreeTableRowWidget\n}\n\n// TreeTableRow creates new TreeTableRowWidget.\nfunc TreeTableRow(label string, widgets ...Widget) *TreeTableRowWidget {\n\treturn &TreeTableRowWidget{\n\t\tlabel:  GenAutoID(label),\n\t\tlayout: widgets,\n\t}\n}\n\n// Children sets child rows of tree row.\nfunc (ttr *TreeTableRowWidget) Children(rows ...*TreeTableRowWidget) *TreeTableRowWidget {\n\tttr.children = rows\n\treturn ttr\n}\n\n// Flags sets row's flags.\nfunc (ttr *TreeTableRowWidget) Flags(flags TreeNodeFlags) *TreeTableRowWidget {\n\tttr.flags = flags\n\treturn ttr\n}\n\n// BuildTreeTableRow executes table row building steps.\nfunc (ttr *TreeTableRowWidget) BuildTreeTableRow() {\n\timgui.TableNextRowV(0, 0)\n\timgui.TableNextColumn()\n\n\topen := false\n\tif len(ttr.children) > 0 {\n\t\topen = imgui.TreeNodeExStrV(Context.FontAtlas.RegisterString(ttr.label.String()), imgui.TreeNodeFlags(ttr.flags))\n\t} else {\n\t\tttr.flags |= TreeNodeFlagsLeaf | TreeNodeFlagsNoTreePushOnOpen\n\t\timgui.TreeNodeExStrV(Context.FontAtlas.RegisterString(ttr.label.String()), imgui.TreeNodeFlags(ttr.flags))\n\t}\n\n\tfor _, w := range ttr.layout {\n\t\tswitch w.(type) {\n\t\tcase *TooltipWidget,\n\t\t\t*ContextMenuWidget, *PopupModalWidget:\n\t\t\t// noop\n\t\tdefault:\n\t\t\timgui.TableNextColumn()\n\t\t}\n\n\t\tw.Build()\n\t}\n\n\tif len(ttr.children) > 0 && open {\n\t\tfor _, c := range ttr.children {\n\t\t\tc.BuildTreeTableRow()\n\t\t}\n\n\t\timgui.TreePop()\n\t}\n}\n\nvar _ Widget = &TreeTableWidget{}\n\n// TreeTableWidget is a table that consists of TreeNodeWidgets.\ntype TreeTableWidget struct {\n\tid           ID\n\tflags        TableFlags\n\tsize         imgui.Vec2\n\tcolumns      []*TableColumnWidget\n\trows         []*TreeTableRowWidget\n\tfreezeRow    int\n\tfreezeColumn int\n}\n\n// TreeTable creates new TreeTableWidget.\nfunc TreeTable() *TreeTableWidget {\n\treturn &TreeTableWidget{\n\t\tid:      GenAutoID(\"TreeTable\"),\n\t\tflags:   TableFlagsBordersV | TableFlagsBordersOuterH | TableFlagsResizable | TableFlagsRowBg | TableFlagsNoBordersInBody,\n\t\trows:    nil,\n\t\tcolumns: nil,\n\t}\n}\n\n// Freeze columns/rows so they stay visible when scrolled.\nfunc (tt *TreeTableWidget) Freeze(col, row int) *TreeTableWidget {\n\ttt.freezeColumn = col\n\ttt.freezeRow = row\n\n\treturn tt\n}\n\n// Size sets size of the table.\nfunc (tt *TreeTableWidget) Size(width, height float32) *TreeTableWidget {\n\ttt.size = imgui.Vec2{X: width, Y: height}\n\treturn tt\n}\n\n// Flags sets table flags.\nfunc (tt *TreeTableWidget) Flags(flags TableFlags) *TreeTableWidget {\n\ttt.flags = flags\n\treturn tt\n}\n\n// Columns sets table's columns.\nfunc (tt *TreeTableWidget) Columns(cols ...*TableColumnWidget) *TreeTableWidget {\n\ttt.columns = cols\n\treturn tt\n}\n\n// Rows sets TreeTable rows.\nfunc (tt *TreeTableWidget) Rows(rows ...*TreeTableRowWidget) *TreeTableWidget {\n\ttt.rows = rows\n\treturn tt\n}\n\n// Build implements Widget interface.\nfunc (tt *TreeTableWidget) Build() {\n\tif len(tt.rows) == 0 {\n\t\treturn\n\t}\n\n\tcolCount := len(tt.columns)\n\tif colCount == 0 {\n\t\tcolCount = len(tt.rows[0].layout) + 1\n\t}\n\n\tif imgui.BeginTableV(tt.id.String(), int32(colCount), imgui.TableFlags(tt.flags), tt.size, 0) {\n\t\tif tt.freezeColumn >= 0 && tt.freezeRow >= 0 {\n\t\t\timgui.TableSetupScrollFreeze(int32(tt.freezeColumn), int32(tt.freezeRow))\n\t\t}\n\n\t\tif len(tt.columns) > 0 {\n\t\t\tfor _, col := range tt.columns {\n\t\t\t\tcol.BuildTableColumn()\n\t\t\t}\n\n\t\t\timgui.TableHeadersRow()\n\t\t}\n\n\t\tfor _, row := range tt.rows {\n\t\t\trow.BuildTreeTableRow()\n\t\t}\n\n\t\timgui.EndTable()\n\t}\n}\n"
        },
        {
          "name": "TextWidgets.go",
          "type": "blob",
          "size": 12.93359375,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\n\t\"golang.org/x/image/colornames\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/sahilm/fuzzy\"\n)\n\nvar _ Widget = &InputTextMultilineWidget{}\n\n// InputTextMultilineWidget is a large (multiline) text input\n// see examples/widgets/.\ntype InputTextMultilineWidget struct {\n\tlabel          ID\n\ttext           *string\n\twidth, height  float32\n\tflags          InputTextFlags\n\tcb             imgui.InputTextCallback\n\tscrollToBottom bool\n\tonChange       func()\n}\n\n// InputTextMultiline creates InputTextMultilineWidget.\nfunc InputTextMultiline(text *string) *InputTextMultilineWidget {\n\treturn &InputTextMultilineWidget{\n\t\ttext:     text,\n\t\twidth:    0,\n\t\theight:   0,\n\t\tflags:    0,\n\t\tcb:       nil,\n\t\tonChange: nil,\n\t\tlabel:    GenAutoID(\"##InputTextMultiline\"),\n\t}\n}\n\n// Label sets input field label.\nfunc (i *InputTextMultilineWidget) Label(label string) *InputTextMultilineWidget {\n\ti.label = GenAutoID(label)\n\treturn i\n}\n\n// Labelf is formatting version of Label.\nfunc (i *InputTextMultilineWidget) Labelf(format string, args ...any) *InputTextMultilineWidget {\n\treturn i.Label(fmt.Sprintf(format, args...))\n}\n\n// ID sets widget's id.\nfunc (i *InputTextMultilineWidget) ID(id ID) *InputTextMultilineWidget {\n\ti.label = id\n\treturn i\n}\n\n// Flags sets InputTextFlags (see Flags.go).\nfunc (i *InputTextMultilineWidget) Flags(flags InputTextFlags) *InputTextMultilineWidget {\n\ti.flags = flags\n\treturn i\n}\n\n// Callback sets imgui.InputTextCallback.\nfunc (i *InputTextMultilineWidget) Callback(cb imgui.InputTextCallback) *InputTextMultilineWidget {\n\ti.cb = cb\n\treturn i\n}\n\n// OnChange set callback called when user action taken on input text field (when text was changed).\nfunc (i *InputTextMultilineWidget) OnChange(onChange func()) *InputTextMultilineWidget {\n\ti.onChange = onChange\n\treturn i\n}\n\n// Size sets input field size.\nfunc (i *InputTextMultilineWidget) Size(width, height float32) *InputTextMultilineWidget {\n\ti.width, i.height = width, height\n\treturn i\n}\n\n// AutoScrollToBottom Enables/Disables auto scroll to bottom.\nfunc (i *InputTextMultilineWidget) AutoScrollToBottom(b bool) *InputTextMultilineWidget {\n\ti.scrollToBottom = b\n\treturn i\n}\n\n// Build implements Widget interface.\nfunc (i *InputTextMultilineWidget) Build() {\n\tif imgui.InputTextMultiline(\n\t\tContext.FontAtlas.RegisterString(i.label.String()),\n\t\tContext.FontAtlas.RegisterStringPointer(i.text),\n\t\timgui.Vec2{\n\t\t\tX: i.width,\n\t\t\tY: i.height,\n\t\t},\n\t\timgui.InputTextFlags(i.flags), i.cb,\n\t) && i.onChange != nil {\n\t\ti.onChange()\n\t}\n\n\tif i.scrollToBottom {\n\t\timgui.BeginChildStr(i.label.String()) // TODO: there is a V version\n\t\timgui.SetScrollHereYV(1.0)\n\t\timgui.EndChild()\n\t}\n}\n\nvar _ Widget = &BulletWidget{}\n\n// BulletWidget adds a small, white dot (bullet).\n// useful in enumerations.\ntype BulletWidget struct{}\n\n// Bullet creates a bullet widget.\nfunc Bullet() *BulletWidget {\n\treturn &BulletWidget{}\n}\n\n// Build implements Widget interface.\nfunc (b *BulletWidget) Build() {\n\timgui.Bullet()\n}\n\nvar _ Widget = &BulletTextWidget{}\n\n// BulletTextWidget does similar to BulletWidget, but allows\n// to add a text after a bullet. Very useful to create lists.\ntype BulletTextWidget struct {\n\ttext string\n}\n\n// BulletText creates bulletTextWidget.\nfunc BulletText(text string) *BulletTextWidget {\n\treturn &BulletTextWidget{\n\t\ttext: Context.FontAtlas.RegisterString(text),\n\t}\n}\n\n// BulletTextf is a formatting version of BulletText.\nfunc BulletTextf(format string, args ...any) *BulletTextWidget {\n\treturn BulletText(fmt.Sprintf(format, args...))\n}\n\n// Build implements Widget interface.\nfunc (bt *BulletTextWidget) Build() {\n\timgui.BulletText(bt.text)\n}\n\nvar _ Disposable = &inputTextState{}\n\ntype inputTextState struct {\n\tautoCompleteCandidates fuzzy.Matches\n\tcurrentIdx             int\n}\n\n// Dispose implements disposable interface.\nfunc (s *inputTextState) Dispose() {\n\ts.autoCompleteCandidates = nil\n\ts.currentIdx = 0\n}\n\nvar _ Widget = &InputTextWidget{}\n\n// InputTextWidget is a single-line text input.\ntype InputTextWidget struct {\n\tlabel      ID\n\thint       string\n\tvalue      *string\n\twidth      float32\n\tcandidates []string\n\tflags      InputTextFlags\n\tcb         imgui.InputTextCallback\n\tonChange   func()\n}\n\n// InputText creates new input text widget.\nfunc InputText(value *string) *InputTextWidget {\n\treturn &InputTextWidget{\n\t\tlabel:    GenAutoID(\"##InputText\"),\n\t\thint:     \"\",\n\t\tvalue:    value,\n\t\twidth:    0,\n\t\tflags:    0,\n\t\tcb:       nil,\n\t\tonChange: nil,\n\t}\n}\n\n// Label adds label (alternatively you can use it to set widget's id).\nfunc (i *InputTextWidget) Label(label string) *InputTextWidget {\n\ti.label = GenAutoID(Context.FontAtlas.RegisterString(label))\n\treturn i\n}\n\n// Labelf adds formatted label.\nfunc (i *InputTextWidget) Labelf(format string, args ...any) *InputTextWidget {\n\treturn i.Label(fmt.Sprintf(format, args...))\n}\n\n// ID sets widget's id.\nfunc (i *InputTextWidget) ID(id ID) *InputTextWidget {\n\ti.label = id\n\treturn i\n}\n\n// AutoComplete enables auto complete popup by using fuzzy search of current value against candidates\n// Press enter to confirm the first candidate.\nfunc (i *InputTextWidget) AutoComplete(candidates []string) *InputTextWidget {\n\ti.candidates = candidates\n\treturn i\n}\n\n// Hint sets hint text.\nfunc (i *InputTextWidget) Hint(hint string) *InputTextWidget {\n\ti.hint = Context.FontAtlas.RegisterString(hint)\n\treturn i\n}\n\n// Size sets field's width.\nfunc (i *InputTextWidget) Size(width float32) *InputTextWidget {\n\ti.width = width\n\treturn i\n}\n\n// Flags sets flags.\nfunc (i *InputTextWidget) Flags(flags InputTextFlags) *InputTextWidget {\n\ti.flags = flags\n\treturn i\n}\n\n// Callback sets input text callback.\nfunc (i *InputTextWidget) Callback(cb imgui.InputTextCallback) *InputTextWidget {\n\ti.cb = cb\n\treturn i\n}\n\n// OnChange sets callback when text was changed.\nfunc (i *InputTextWidget) OnChange(onChange func()) *InputTextWidget {\n\ti.onChange = onChange\n\treturn i\n}\n\n// Build implements Widget interface.\nfunc (i *InputTextWidget) Build() {\n\t// Get state\n\tvar state *inputTextState\n\tif state = GetState[inputTextState](Context, i.label); state == nil {\n\t\tstate = &inputTextState{}\n\t\tSetState(Context, i.label, state)\n\t}\n\n\tif i.width != 0 {\n\t\tPushItemWidth(i.width)\n\n\t\tdefer PopItemWidth()\n\t}\n\n\tisChanged := imgui.InputTextWithHint(i.label.String(), i.hint, Context.FontAtlas.RegisterStringPointer(i.value), imgui.InputTextFlags(i.flags), i.cb)\n\n\tif isChanged && i.onChange != nil {\n\t\ti.onChange()\n\t}\n\n\tif isChanged {\n\t\t// Enable auto complete\n\t\tif len(i.candidates) > 0 {\n\t\t\tmatches := fuzzy.Find(*i.value, i.candidates)\n\t\t\tsize := int(math.Min(5, float64(matches.Len())))\n\t\t\tmatches = matches[:size]\n\n\t\t\tstate.autoCompleteCandidates = matches\n\t\t}\n\t}\n\n\t// Draw autocomplete list\n\tif len(state.autoCompleteCandidates) > 0 && imgui.IsItemFocused() {\n\t\ti.handleAutoComplete(state)\n\t}\n}\n\nfunc (i *InputTextWidget) handleAutoComplete(state *inputTextState) {\n\tif state.currentIdx >= len(state.autoCompleteCandidates) {\n\t\tstate.currentIdx = 0\n\t}\n\n\tlabels := make(Layout, len(state.autoCompleteCandidates))\n\tfor i, m := range state.autoCompleteCandidates {\n\t\tlabels[i] = Label(m.Str)\n\t\tif i == state.currentIdx {\n\t\t\tlabels[i] = Layout{\n\t\t\t\tCustom(func() { PushStyleColor(StyleColorText, colornames.Blue) }),\n\t\t\t\tlabels[i],\n\t\t\t\tCustom(func() { PopStyleColor() }),\n\t\t\t}\n\t\t}\n\t}\n\n\tSetNextWindowPos(imgui.ItemRectMin().X, imgui.ItemRectMax().Y)\n\timgui.BeginTooltip()\n\tlabels.Build()\n\timgui.EndTooltip()\n\n\t// Press enter will replace value string with first match candidate\n\tswitch {\n\tcase IsKeyPressed(KeyEnter) || IsKeyPressed(KeyTab):\n\t\t*i.value = state.autoCompleteCandidates[state.currentIdx].Str\n\t\tstate.autoCompleteCandidates = nil\n\n\t\tif i.onChange != nil {\n\t\t\ti.onChange()\n\t\t}\n\tcase IsKeyPressed(KeyDown):\n\t\tstate.currentIdx++\n\t\tif state.currentIdx >= state.autoCompleteCandidates.Len() {\n\t\t\tstate.currentIdx = 0\n\t\t}\n\tcase IsKeyPressed(KeyUp):\n\t\tstate.currentIdx--\n\t\tif state.currentIdx < 0 {\n\t\t\tstate.currentIdx = len(state.autoCompleteCandidates) - 1\n\t\t}\n\t}\n}\n\nvar _ Widget = &InputIntWidget{}\n\n// InputIntWidget is an input text field accepting integer values only.\ntype InputIntWidget struct {\n\tlabel    ID\n\tvalue    *int32\n\twidth    float32\n\tflags    InputTextFlags\n\tonChange func()\n\tstep     int\n\tstepFast int\n}\n\n// InputInt creates input int widget\n// NOTE: value is int32, so its size is up to 10^32-1.\n// to process greater values, you need to use InputTextWidget\n// with InputTextFlagsCharsDecimal and strconv.ParseInt in OnChange callback.\nfunc InputInt(value *int32) *InputIntWidget {\n\treturn &InputIntWidget{\n\t\tlabel:    GenAutoID(\"##InputInt\"),\n\t\tvalue:    value,\n\t\twidth:    0,\n\t\tflags:    0,\n\t\tonChange: nil,\n\t}\n}\n\n// Label sets label (id).\nfunc (i *InputIntWidget) Label(label string) *InputIntWidget {\n\ti.label = GenAutoID(Context.FontAtlas.RegisterString(label))\n\treturn i\n}\n\n// Labelf sets formatted label.\nfunc (i *InputIntWidget) Labelf(format string, args ...any) *InputIntWidget {\n\treturn i.Label(fmt.Sprintf(format, args...))\n}\n\n// ID sets widget's id.\nfunc (i *InputIntWidget) ID(id ID) *InputIntWidget {\n\ti.label = id\n\treturn i\n}\n\n// Size sets input's width.\nfunc (i *InputIntWidget) Size(width float32) *InputIntWidget {\n\ti.width = width\n\treturn i\n}\n\n// Flags sets flags.\nfunc (i *InputIntWidget) Flags(flags InputTextFlags) *InputIntWidget {\n\ti.flags = flags\n\treturn i\n}\n\n// StepSize sets the step size.\nfunc (i *InputIntWidget) StepSize(step int) *InputIntWidget {\n\ti.step = step\n\treturn i\n}\n\n// StepSizeFast sets the fast step size.\nfunc (i *InputIntWidget) StepSizeFast(stepFast int) *InputIntWidget {\n\ti.stepFast = stepFast\n\treturn i\n}\n\n// OnChange adds on change callback.\nfunc (i *InputIntWidget) OnChange(onChange func()) *InputIntWidget {\n\ti.onChange = onChange\n\treturn i\n}\n\n// Build implements Widget interface.\nfunc (i *InputIntWidget) Build() {\n\tif i.width != 0 {\n\t\tPushItemWidth(i.width)\n\n\t\tdefer PopItemWidth()\n\t}\n\n\tif imgui.InputIntV(\n\t\ti.label.String(),\n\t\ti.value,\n\t\tint32(i.step),\n\t\tint32(i.stepFast),\n\t\timgui.InputTextFlags(i.flags),\n\t) && i.onChange != nil {\n\t\ti.onChange()\n\t}\n}\n\nvar _ Widget = &InputFloatWidget{}\n\n// InputFloatWidget does similar to InputIntWIdget, but accepts float numbers.\ntype InputFloatWidget struct {\n\tlabel    ID\n\tvalue    *float32\n\twidth    float32\n\tflags    InputTextFlags\n\tformat   string\n\tonChange func()\n\tstep     float32\n\tstepFast float32\n}\n\n// InputFloat constructs InputFloatWidget.\nfunc InputFloat(value *float32) *InputFloatWidget {\n\treturn &InputFloatWidget{\n\t\tlabel:    GenAutoID(\"##InputFloatWidget\"),\n\t\twidth:    0,\n\t\tvalue:    value,\n\t\tformat:   \"%.3f\",\n\t\tflags:    0,\n\t\tonChange: nil,\n\t}\n}\n\n// Label sets label of input field.\nfunc (i *InputFloatWidget) Label(label string) *InputFloatWidget {\n\ti.label = GenAutoID(Context.FontAtlas.RegisterString(label))\n\treturn i\n}\n\n// Labelf sets formatted label.\nfunc (i *InputFloatWidget) Labelf(format string, args ...any) *InputFloatWidget {\n\treturn i.Label(fmt.Sprintf(format, args...))\n}\n\n// ID sets widget's id.\nfunc (i *InputFloatWidget) ID(id ID) *InputFloatWidget {\n\ti.label = id\n\treturn i\n}\n\n// Size sets input field's width.\nfunc (i *InputFloatWidget) Size(width float32) *InputFloatWidget {\n\ti.width = width\n\treturn i\n}\n\n// Flags sets flags.\nfunc (i *InputFloatWidget) Flags(flags InputTextFlags) *InputFloatWidget {\n\ti.flags = flags\n\treturn i\n}\n\n// Format sets data format (e.g. %.3f).\nfunc (i *InputFloatWidget) Format(format string) *InputFloatWidget {\n\ti.format = format\n\treturn i\n}\n\n// OnChange sets callback called when text is changed.\nfunc (i *InputFloatWidget) OnChange(onChange func()) *InputFloatWidget {\n\ti.onChange = onChange\n\treturn i\n}\n\n// StepSize sets the step size.\nfunc (i *InputFloatWidget) StepSize(step float32) *InputFloatWidget {\n\ti.step = step\n\treturn i\n}\n\n// StepSizeFast sets the fast step size.\nfunc (i *InputFloatWidget) StepSizeFast(stepFast float32) *InputFloatWidget {\n\ti.stepFast = stepFast\n\treturn i\n}\n\n// Build implements Widget interface.\nfunc (i *InputFloatWidget) Build() {\n\tif i.width != 0 {\n\t\tPushItemWidth(i.width)\n\n\t\tdefer PopItemWidth()\n\t}\n\n\tif imgui.InputFloatV(\n\t\ti.label.String(),\n\t\ti.value,\n\t\ti.step,\n\t\ti.stepFast,\n\t\ti.format,\n\t\timgui.InputTextFlags(i.flags),\n\t) && i.onChange != nil {\n\t\ti.onChange()\n\t}\n}\n\nvar _ Widget = &LabelWidget{}\n\n// LabelWidget is a plain text label.\ntype LabelWidget struct {\n\tlabel    string\n\tfontInfo *FontInfo\n\twrapped  bool\n}\n\n// Label constructs label widget.\nfunc Label(label string) *LabelWidget {\n\treturn &LabelWidget{\n\t\tlabel:   Context.FontAtlas.RegisterString(label),\n\t\twrapped: false,\n\t}\n}\n\n// Labelf allows to add formatted label.\nfunc Labelf(format string, args ...any) *LabelWidget {\n\treturn Label(fmt.Sprintf(format, args...))\n}\n\n// Wrapped determines if label is wrapped.\nfunc (l *LabelWidget) Wrapped(wrapped bool) *LabelWidget {\n\tl.wrapped = wrapped\n\treturn l\n}\n\n// Font sets specific font (does like Style().SetFont).\nfunc (l *LabelWidget) Font(font *FontInfo) *LabelWidget {\n\tl.fontInfo = font\n\treturn l\n}\n\n// Build implements Widget interface.\nfunc (l *LabelWidget) Build() {\n\tif l.wrapped {\n\t\tPushTextWrapPos()\n\n\t\tdefer PopTextWrapPos()\n\t}\n\n\tif l.fontInfo != nil {\n\t\tif PushFont(l.fontInfo) {\n\t\t\tdefer PopFont()\n\t\t}\n\t}\n\n\timgui.TextUnformatted(l.label)\n}\n"
        },
        {
          "name": "Texture.go",
          "type": "blob",
          "size": 1.5107421875,
          "content": "package giu\n\nimport (\n\t\"image\"\n\t\"runtime\"\n\n\t\"github.com/AllenDang/cimgui-go/backend\"\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// Texture represents imgui.TextureID.\n// It is base unit of images in imgui.\ntype Texture struct {\n\ttex *backend.Texture\n}\n\ntype textureLoadRequest struct {\n\timg image.Image\n\tcb  func(*Texture)\n}\n\ntype textureFreeRequest struct {\n\ttex *Texture\n}\n\n// EnqueueNewTextureFromRgba adds loading texture request to loading queue\n// it allows us to run this method in main loop\n// NOTE: remember to call it after NewMasterWindow!\nfunc EnqueueNewTextureFromRgba(rgba image.Image, loadCb func(t *Texture)) {\n\tAssert((Context.textureLoadingQueue != nil), \"\", \"EnqueueNewTextureFromRgba\", \"you need to call EnqueueNewTextureFromRgba after giu.NewMasterWindow call!\")\n\tContext.textureLoadingQueue.Add(textureLoadRequest{rgba, loadCb})\n}\n\n// NewTextureFromRgba creates a new texture from image.Image and, when it is done, calls loadCallback(loadedTexture).\nfunc NewTextureFromRgba(rgba image.Image, loadCallback func(*Texture)) {\n\ttex := backend.NewTextureFromRgba(ImageToRgba(rgba))\n\tgiuTex := &Texture{\n\t\ttex,\n\t}\n\n\truntime.SetFinalizer(giuTex, func(tex *Texture) {\n\t\tContext.textureFreeingQueue.Add(textureFreeRequest{tex})\n\t})\n\n\tloadCallback(giuTex)\n}\n\n// ToTexture converts backend.Texture to Texture.\nfunc ToTexture(texture *backend.Texture) *Texture {\n\treturn &Texture{tex: texture}\n}\n\n// ID returns imgui.TextureID of the texture.\nfunc (t *Texture) ID() imgui.TextureID {\n\tif t.tex != nil {\n\t\treturn t.tex.ID\n\t}\n\n\treturn 0\n}\n"
        },
        {
          "name": "TextureFilters.go",
          "type": "blob",
          "size": 0.2314453125,
          "content": "package giu\n\n// Texture filtering types.\nconst (\n\tTextureFilterNearest = iota\n\tTextureFilterLinear\n\tTextureFilterNearestMipmapNearest\n\tTextureFilterLinearMipmapNearest\n\tTextureFilterNearestMipmapLinear\n\tTextureFilterLinearMipmapLinear\n)\n"
        },
        {
          "name": "Utils.go",
          "type": "blob",
          "size": 6.9765625,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/draw\"\n\t\"image/png\"\n\t\"io/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/pkg/browser\"\n)\n\n// ID is an alias type. If some method uses ID it means, that this string will NOT be proceeded anyhow and will be passed\n// as-is to cimgui-go. This also means that it deffinitly needs to be\n// unique because else it will cause strange UI behavior.\n// see: https://github.com/AllenDang/giu/wiki#id\ntype ID string\n\nfunc (i ID) String() string {\n\treturn string(i)\n}\n\n// PNGToRgba loads image file interface and assume caller takes care of interface proper closing.\nfunc PNGToRgba(file fs.File) (*image.RGBA, error) {\n\timg, err := png.Decode(file)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"LoadImage: error decoding png image: %w\", err)\n\t}\n\n\treturn ImageToRgba(img), nil\n}\n\n// LoadImage loads image from file and returns *image.RGBA.\nfunc LoadImage(imgPath string) (*image.RGBA, error) {\n\timgFile, err := os.Open(filepath.Clean(imgPath))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"LoadImage: error opening image file %s: %w\", imgPath, err)\n\t}\n\n\tdefer func() {\n\t\tif err := imgFile.Close(); err != nil {\n\t\t\tpanic(fmt.Sprintf(\"error closing image file: %s\", imgPath))\n\t\t}\n\t}()\n\n\treturn PNGToRgba(imgFile)\n}\n\n// ImageToRgba converts image.Image to *image.RGBA.\nfunc ImageToRgba(img image.Image) *image.RGBA {\n\tswitch trueImg := img.(type) {\n\tcase *image.RGBA:\n\t\treturn trueImg\n\tdefault:\n\t\trgba := image.NewRGBA(trueImg.Bounds())\n\t\tdraw.Draw(rgba, trueImg.Bounds(), trueImg, image.Pt(0, 0), draw.Src)\n\n\t\treturn rgba\n\t}\n}\n\n// ToVec4Color converts rgba color to imgui.Vec4.\nfunc ToVec4Color(col color.Color) imgui.Vec4 {\n\tconst mask = 0xffff\n\n\tr, g, b, a := col.RGBA()\n\n\treturn imgui.Vec4{\n\t\tX: float32(r) / mask,\n\t\tY: float32(g) / mask,\n\t\tZ: float32(b) / mask,\n\t\tW: float32(a) / mask,\n\t}\n}\n\n// ToVec2 converts image.Point to imgui.Vec2.\nfunc ToVec2(pt image.Point) imgui.Vec2 {\n\treturn imgui.Vec2{\n\t\tX: float32(pt.X),\n\t\tY: float32(pt.Y),\n\t}\n}\n\n// Vec4ToRGBA converts imgui's Vec4 to golang rgba color.\nfunc Vec4ToRGBA(vec4 imgui.Vec4) color.RGBA {\n\treturn color.RGBA{\n\t\tR: uint8(vec4.X * 255),\n\t\tG: uint8(vec4.Y * 255),\n\t\tB: uint8(vec4.Z * 255),\n\t\tA: uint8(vec4.W * 255),\n\t}\n}\n\n// Update updates giu app\n// it is done by default after each frame.\n// However because frames stops rendering, when no user\n// action is done, it may be necessary to\n// Update ui manually at some point.\nfunc Update() {\n\tContext.m.Lock()\n\tdefer Context.m.Unlock()\n\n\tif Context.isAlive {\n\t\tContext.backend.Refresh()\n\t}\n}\n\n// GetCursorScreenPos returns imgui drawing cursor on the screen.\nfunc GetCursorScreenPos() image.Point {\n\tpos := imgui.CursorScreenPos()\n\treturn image.Pt(int(pos.X), int(pos.Y))\n}\n\n// SetCursorScreenPos sets imgui drawing cursor on the screen.\nfunc SetCursorScreenPos(pos image.Point) {\n\timgui.SetCursorScreenPos(imgui.Vec2{X: float32(pos.X), Y: float32(pos.Y)})\n}\n\n// GetCursorPos gets imgui drawing cursor inside of current window.\nfunc GetCursorPos() image.Point {\n\tpos := imgui.CursorPos()\n\treturn image.Pt(int(pos.X), int(pos.Y))\n}\n\n// SetCursorPos sets imgui drawing cursor inside of current window.\nfunc SetCursorPos(pos image.Point) {\n\timgui.SetCursorPos(imgui.Vec2{X: float32(pos.X), Y: float32(pos.Y)})\n}\n\n// GetMousePos returns mouse position.\nfunc GetMousePos() image.Point {\n\tpos := imgui.MousePos()\n\treturn image.Pt(int(pos.X), int(pos.Y))\n}\n\n// GetAvailableRegion returns region available for rendering.\n// it is always WindowSize-WindowPadding*2.\nfunc GetAvailableRegion() (width, height float32) {\n\tregion := imgui.ContentRegionAvail()\n\treturn region.X, region.Y\n}\n\n// CalcTextSize calls CalcTextSizeV(text, false, -1).\nfunc CalcTextSize(text string) (width, height float32) {\n\treturn CalcTextSizeV(text, false, -1)\n}\n\n// CalcTextSizeV calculates text dimensions.\nfunc CalcTextSizeV(text string, hideAfterDoubleHash bool, wrapWidth float32) (w, h float32) {\n\tsize := imgui.CalcTextSizeV(\n\t\ttext,\n\t\thideAfterDoubleHash,\n\t\twrapWidth,\n\t)\n\n\treturn size.X, size.Y\n}\n\n// SetNextWindowSize sets size of the next window.\nfunc SetNextWindowSize(width, height float32) {\n\timgui.SetNextWindowSize(imgui.Vec2{X: width, Y: height})\n}\n\n// ExecCondition represents imgui.Cond.\ntype ExecCondition imgui.Cond\n\n// imgui conditions.\nconst (\n\tConditionAlways       ExecCondition = ExecCondition(imgui.CondAlways)\n\tConditionOnce         ExecCondition = ExecCondition(imgui.CondOnce)\n\tConditionFirstUseEver ExecCondition = ExecCondition(imgui.CondFirstUseEver)\n\tConditionAppearing    ExecCondition = ExecCondition(imgui.CondAppearing)\n)\n\n// SetNextWindowPos sets position of next window.\nfunc SetNextWindowPos(x, y float32) {\n\timgui.SetNextWindowPos(imgui.Vec2{X: x, Y: y})\n}\n\n// SetNextWindowSizeV does similar to SetNextWIndowSize but allows to specify imgui.Cond.\nfunc SetNextWindowSizeV(width, height float32, condition ExecCondition) {\n\timgui.SetNextWindowSizeV(\n\t\timgui.Vec2{\n\t\t\tX: width,\n\t\t\tY: height,\n\t\t},\n\t\timgui.Cond(condition),\n\t)\n}\n\n// SetItemDefaultFocus set the item focused by default.\nfunc SetItemDefaultFocus() {\n\timgui.SetItemDefaultFocus()\n}\n\n// SetKeyboardFocusHere sets keyboard focus at *NEXT* widget.\nfunc SetKeyboardFocusHere() {\n\tSetKeyboardFocusHereV(0)\n}\n\n// SetKeyboardFocusHereV sets keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.\nfunc SetKeyboardFocusHereV(i int) {\n\timgui.SetKeyboardFocusHereV(int32(i))\n}\n\n// PushClipRect pushes a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.\nfunc PushClipRect(clipRectMin, clipRectMax image.Point, intersectWithClipRect bool) {\n\timgui.PushClipRect(ToVec2(clipRectMin), ToVec2(clipRectMax), intersectWithClipRect)\n}\n\n// PopClipRect should be called to end PushClipRect.\nfunc PopClipRect() {\n\timgui.PopClipRect()\n}\n\n// Assert checks if cond. If not cond, it alls golang panic.\nfunc Assert(cond bool, t, method, msg string, args ...any) {\n\tif !cond {\n\t\tfatal(t, method, msg, args...)\n\t}\n}\n\nfunc fatal(widgetName, method, message string, args ...any) {\n\tif widgetName != \"\" {\n\t\twidgetName = fmt.Sprintf(\"(*%s)\", widgetName)\n\t}\n\n\tlog.Panicf(\"giu: %s.%s: %s\", widgetName, method, fmt.Sprintf(message, args...))\n}\n\n// OpenURL opens `url` in default browser.\nfunc OpenURL(url string) {\n\tif err := browser.OpenURL(url); err != nil {\n\t\tlog.Printf(\"Error opening %s: %v\", url, err)\n\t}\n}\n\n// ColorToUint converts GO color into Uint32 color\n// it is 0xRRGGBBAA.\nfunc ColorToUint(col color.Color) uint32 {\n\tr, g, b, a := col.RGBA()\n\tmask := uint32(0xff)\n\n\treturn r&mask +\n\t\tg&mask<<8 +\n\t\tb&mask<<16 +\n\t\ta&mask<<24\n}\n\n// UintToColor converts uint32 of form 0xRRGGBB into color.RGBA.\nfunc UintToColor(col uint32) *color.RGBA {\n\tmask := 0xff\n\tr := byte(col >> 24 & uint32(mask))\n\tg := byte(col >> 16 & uint32(mask))\n\tb := byte(col >> 8 & uint32(mask))\n\ta := byte(col >> 0 & uint32(mask))\n\n\treturn &color.RGBA{\n\t\tR: r,\n\t\tG: g,\n\t\tB: b,\n\t\tA: a,\n\t}\n}\n\n// Deg2Rad converts degrees to radians.\nfunc Deg2Rad(deg float32) float32 {\n\treturn deg * 0.01745329252 // deg * 2pi / 360\n}\n"
        },
        {
          "name": "Utils_test.go",
          "type": "blob",
          "size": 3.0927734375,
          "content": "package giu\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"testing\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_ToVec4(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tsource   color.Color\n\t\texpected imgui.Vec4\n\t}{\n\t\t{\n\t\t\tname:     \"Red - RGBA\",\n\t\t\tsource:   &color.RGBA{R: 255, G: 0, B: 0, A: 255},\n\t\t\texpected: imgui.Vec4{X: 1, Y: 0, Z: 0, W: 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Purple - RGBA\",\n\t\t\tsource:   &color.RGBA{R: 158, G: 0, B: 173, A: 255},\n\t\t\texpected: imgui.Vec4{X: 0.61960787, Y: 0, Z: 0.6784314, W: 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Purple - CMYK\",\n\t\t\tsource:   &color.CMYK{C: 22, M: 255, Y: 0, K: 82},\n\t\t\texpected: imgui.Vec4{X: 0.6198978, Y: 0, Z: 0.6784314, W: 1},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(tt *testing.T) {\n\t\t\tassert.Equal(tt, test.expected, ToVec4Color(test.source), \"Unexpected result\")\n\t\t})\n\t}\n}\n\nfunc Test_ToVec2(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tsource   image.Point\n\t\texpected imgui.Vec2\n\t}{\n\t\t{\"Point 0,0\", image.Pt(0, 0), imgui.Vec2{X: 0, Y: 0}},\n\t\t{\"Random point 1\", image.Pt(80, 209), imgui.Vec2{X: 80, Y: 209}},\n\t\t{\"Random point 2\", image.Pt(200, 128), imgui.Vec2{X: 200, Y: 128}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(tt *testing.T) {\n\t\t\tassert.Equal(tt, test.expected, ToVec2(test.source), \"Unexpected result\")\n\t\t})\n\t}\n}\n\nfunc Test_Vec4ToRGBA(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tsource   imgui.Vec4\n\t\texpected color.RGBA\n\t}{\n\t\t{\n\t\t\tname:     \"Red\",\n\t\t\tsource:   imgui.Vec4{X: 1, Y: 0, Z: 0, W: 1},\n\t\t\texpected: color.RGBA{R: 255, G: 0, B: 0, A: 255},\n\t\t},\n\t\t{\n\t\t\tname:     \"Red - with 20% alpha\",\n\t\t\tsource:   imgui.Vec4{X: 1, Y: 0, Z: 0, W: 0.2},\n\t\t\texpected: color.RGBA{R: 255, G: 0, B: 0, A: 51},\n\t\t},\n\t\t{\n\t\t\tname:     \"Purple - RGBA\",\n\t\t\tsource:   imgui.Vec4{X: 0.61960787, Y: 0, Z: 0.6784314, W: 1},\n\t\t\texpected: color.RGBA{R: 158, G: 0, B: 173, A: 255},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(tt *testing.T) {\n\t\t\tassert.Equal(tt, test.expected, Vec4ToRGBA(test.source), \"Unexpected result\")\n\t\t})\n\t}\n}\n\nfunc Test_Assert(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tcondition   bool\n\t\tshouldPanic bool\n\t}{\n\t\t{\"expected behavior - no panic\", true, false},\n\t\t{\"something happened - panic\", false, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(tt *testing.T) {\n\t\t\tif test.shouldPanic {\n\t\t\t\tassert.Panics(tt, func() { Assert(test.condition, \"somewidget\", \"somemethod\", \"panics\") }, \"unexpected behavior\")\n\t\t\t} else {\n\t\t\t\tassert.NotPanics(tt, func() { Assert(test.condition, \"somewidget\", \"somemethod\", \"panics\") }, \"unexpected behavior\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUintToColor(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tcol  uint32\n\t\twant *color.RGBA\n\t}{\n\t\t{\"full red full alpha\", 0xFF0000FF, &color.RGBA{R: 255, G: 0, B: 0, A: 255}},\n\t\t{\"full red 0 alpha\", 0xFF000000, &color.RGBA{R: 255, G: 0, B: 0, A: 0}},\n\t\t{\"full green\", 0x00FF00FF, &color.RGBA{R: 0, G: 255, B: 0, A: 255}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tassert.Equalf(t, tt.want, UintToColor(tt.col), \"UintToColor(%v)\", tt.col)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "Widgets.go",
          "type": "blob",
          "size": 18.8994140625,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\t\"image/color\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\nvar _ Widget = &RowWidget{}\n\n// RowWidget joins a layout into one line\n// calls imgui.SameLine().\ntype RowWidget struct {\n\twidgets Layout\n}\n\n// Row creates RowWidget.\nfunc Row(widgets ...Widget) *RowWidget {\n\treturn &RowWidget{\n\t\twidgets: widgets,\n\t}\n}\n\n// Build implements Widget interface.\nfunc (l *RowWidget) Build() {\n\tisFirst := true\n\n\tl.widgets.Range(func(w Widget) {\n\t\tswitch w.(type) {\n\t\tcase *TooltipWidget,\n\t\t\t*ContextMenuWidget, *PopupModalWidget,\n\t\t\t*PopupWidget:\n\t\t\t// noop\n\t\tdefault:\n\t\t\tif _, isLabel := w.(*LabelWidget); isLabel {\n\t\t\t\tAlignTextToFramePadding()\n\t\t\t}\n\n\t\t\tif !isFirst {\n\t\t\t\timgui.SameLine()\n\t\t\t} else {\n\t\t\t\tisFirst = false\n\t\t\t}\n\t\t}\n\n\t\tw.Build()\n\t})\n}\n\n// SameLine wraps imgui.SomeLine\n// Don't use if you don't have to (use RowWidget instead).\nfunc SameLine() {\n\timgui.SameLine()\n}\n\nvar _ Widget = &ChildWidget{}\n\n// ChildWidget is a container widget. It will have a separated scroll bar.\n// Use Child if you want to create a layout of e specific size.\ntype ChildWidget struct {\n\tid     ID\n\twidth  float32\n\theight float32\n\tborder bool\n\tflags  WindowFlags\n\tlayout Layout\n}\n\n// Child creates a new ChildWidget.\nfunc Child() *ChildWidget {\n\treturn &ChildWidget{\n\t\tid:     GenAutoID(\"Child\"),\n\t\twidth:  0,\n\t\theight: 0,\n\t\tborder: true,\n\t\tflags:  0,\n\t\tlayout: nil,\n\t}\n}\n\n// Border sets whether child should have border\n// You can use imgui.ChildFlagsBorders as well.\nfunc (c *ChildWidget) Border(border bool) *ChildWidget {\n\tc.border = border\n\treturn c\n}\n\n// Size sets child size.\nfunc (c *ChildWidget) Size(width, height float32) *ChildWidget {\n\tc.width, c.height = width, height\n\treturn c\n}\n\n// Flags allows to specify Child flags.\nfunc (c *ChildWidget) Flags(flags WindowFlags) *ChildWidget {\n\tc.flags = flags\n\treturn c\n}\n\n// Layout sets widgets that will be rendered inside of the Child.\nfunc (c *ChildWidget) Layout(widgets ...Widget) *ChildWidget {\n\tc.layout = Layout(widgets)\n\treturn c\n}\n\n// ID sets the interval id of child widgets.\nfunc (c *ChildWidget) ID(id ID) *ChildWidget {\n\tc.id = id\n\treturn c\n}\n\n// Build makes a Child.\nfunc (c *ChildWidget) Build() {\n\tif imgui.BeginChildStrV(c.id.String(), imgui.Vec2{X: c.width, Y: c.height}, func() imgui.ChildFlags {\n\t\tif c.border {\n\t\t\treturn imgui.ChildFlagsBorders\n\t\t}\n\n\t\treturn 0\n\t}(), imgui.WindowFlags(c.flags)) {\n\t\tc.layout.Build()\n\t}\n\n\timgui.EndChild()\n}\n\nvar _ Widget = &ComboCustomWidget{}\n\n// ComboCustomWidget represents a combo with custom layout when opened.\ntype ComboCustomWidget struct {\n\tlabel        ID\n\tpreviewValue string\n\twidth        float32\n\tflags        ComboFlags\n\tlayout       Layout\n}\n\n// ComboCustom creates a new combo custom widget.\nfunc ComboCustom(label, previewValue string) *ComboCustomWidget {\n\treturn &ComboCustomWidget{\n\t\tlabel:        GenAutoID(label),\n\t\tpreviewValue: Context.FontAtlas.RegisterString(previewValue),\n\t\twidth:        0,\n\t\tflags:        0,\n\t\tlayout:       nil,\n\t}\n}\n\n// Layout add combo's layout.\nfunc (cc *ComboCustomWidget) Layout(widgets ...Widget) *ComboCustomWidget {\n\tcc.layout = Layout(widgets)\n\treturn cc\n}\n\n// Flags allows to set combo flags (see Flags.go).\nfunc (cc *ComboCustomWidget) Flags(flags ComboFlags) *ComboCustomWidget {\n\tcc.flags = flags\n\treturn cc\n}\n\n// Size sets combo preview width.\nfunc (cc *ComboCustomWidget) Size(width float32) *ComboCustomWidget {\n\tcc.width = width\n\treturn cc\n}\n\n// Build implements Widget interface.\nfunc (cc *ComboCustomWidget) Build() {\n\tif cc.width > 0 {\n\t\timgui.PushItemWidth(cc.width)\n\t\tdefer imgui.PopItemWidth()\n\t}\n\n\tif imgui.BeginComboV(Context.FontAtlas.RegisterString(cc.label.String()), cc.previewValue, imgui.ComboFlags(cc.flags)) {\n\t\tcc.layout.Build()\n\t\timgui.EndCombo()\n\t}\n}\n\nvar _ Widget = &ComboWidget{}\n\n// ComboWidget is a wrapper of ComboCustomWidget.\n// It creates a combo of selectables. (it is the most frequently used).\ntype ComboWidget struct {\n\tlabel        ID\n\tpreviewValue string\n\titems        []string\n\tselected     *int32\n\twidth        float32\n\tflags        ComboFlags\n\tonChange     func()\n}\n\n// Combo creates a new ComboWidget.\nfunc Combo(label, previewValue string, items []string, selected *int32) *ComboWidget {\n\treturn &ComboWidget{\n\t\tlabel:        GenAutoID(label),\n\t\tpreviewValue: Context.FontAtlas.RegisterString(previewValue),\n\t\titems:        Context.FontAtlas.RegisterStringSlice(items),\n\t\tselected:     selected,\n\t\tflags:        0,\n\t\twidth:        0,\n\t\tonChange:     nil,\n\t}\n}\n\n// ID sets the interval id of combo. (overrides label).\nfunc (c *ComboWidget) ID(id ID) *ComboWidget {\n\tc.label = id\n\treturn c\n}\n\n// Flags allows to set combo flags (see Flags.go).\nfunc (c *ComboWidget) Flags(flags ComboFlags) *ComboWidget {\n\tc.flags = flags\n\treturn c\n}\n\n// Size sets combo's width.\nfunc (c *ComboWidget) Size(width float32) *ComboWidget {\n\tc.width = width\n\treturn c\n}\n\n// OnChange sets callback when combo value gets changed.\nfunc (c *ComboWidget) OnChange(onChange func()) *ComboWidget {\n\tc.onChange = onChange\n\treturn c\n}\n\n// Build implements Widget interface.\nfunc (c *ComboWidget) Build() {\n\tif c.width > 0 {\n\t\timgui.PushItemWidth(c.width)\n\t\tdefer imgui.PopItemWidth()\n\t}\n\n\tif imgui.BeginComboV(Context.FontAtlas.RegisterString(c.label.String()), c.previewValue, imgui.ComboFlags(c.flags)) {\n\t\tfor i, item := range c.items {\n\t\t\tif imgui.SelectableBool(fmt.Sprintf(\"%s##%d\", item, i)) {\n\t\t\t\t*c.selected = int32(i)\n\t\t\t\tif c.onChange != nil {\n\t\t\t\t\tc.onChange()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\timgui.EndCombo()\n\t}\n}\n\nvar _ Widget = &ContextMenuWidget{}\n\n// ContextMenuWidget is a context menu on another widget. (e.g. right-click menu on button).\ntype ContextMenuWidget struct {\n\tid          ID\n\tmouseButton MouseButton\n\tlayout      Layout\n}\n\n// ContextMenu creates new ContextMenuWidget.\nfunc ContextMenu() *ContextMenuWidget {\n\treturn &ContextMenuWidget{\n\t\tmouseButton: MouseButtonRight,\n\t\tlayout:      nil,\n\t\tid:          GenAutoID(\"ContextMenu\"),\n\t}\n}\n\n// Layout sets layout of the context menu.\nfunc (c *ContextMenuWidget) Layout(widgets ...Widget) *ContextMenuWidget {\n\tc.layout = Layout(widgets)\n\treturn c\n}\n\n// MouseButton sets mouse button that will trigger the context menu.\nfunc (c *ContextMenuWidget) MouseButton(mouseButton MouseButton) *ContextMenuWidget {\n\tc.mouseButton = mouseButton\n\treturn c\n}\n\n// ID sets the interval id of context menu.\nfunc (c *ContextMenuWidget) ID(id ID) *ContextMenuWidget {\n\tc.id = id\n\treturn c\n}\n\n// Build implements Widget interface.\nfunc (c *ContextMenuWidget) Build() {\n\tif imgui.BeginPopupContextItemV(c.id.String(), imgui.PopupFlags(c.mouseButton)) {\n\t\tc.layout.Build()\n\t\timgui.EndPopup()\n\t}\n}\n\nvar _ Widget = &DragIntWidget{}\n\n// DragIntWidget is a widget that allows to drag an integer value.\ntype DragIntWidget struct {\n\tlabel    ID\n\tvalue    *int32\n\tspeed    float32\n\tminValue int32\n\tmaxValue int32\n\tformat   string\n}\n\n// DragInt creates new DragIntWidget.\nfunc DragInt(label string, value *int32, minValue, maxValue int32) *DragIntWidget {\n\treturn &DragIntWidget{\n\t\tlabel:    GenAutoID(label),\n\t\tvalue:    value,\n\t\tspeed:    1.0,\n\t\tminValue: minValue,\n\t\tmaxValue: maxValue,\n\t\tformat:   \"%d\",\n\t}\n}\n\n// Speed sets speed of the dragging.\nfunc (d *DragIntWidget) Speed(speed float32) *DragIntWidget {\n\td.speed = speed\n\treturn d\n}\n\n// Format sets format of the value.\nfunc (d *DragIntWidget) Format(format string) *DragIntWidget {\n\td.format = format\n\treturn d\n}\n\n// Build implements Widget interface.\nfunc (d *DragIntWidget) Build() {\n\timgui.DragIntV(Context.FontAtlas.RegisterString(d.label.String()), d.value, d.speed, d.minValue, d.maxValue, d.format, 0)\n}\n\nvar _ Widget = &ColumnWidget{}\n\n// ColumnWidget will place all widgets one by one vertically.\ntype ColumnWidget struct {\n\twidgets Layout\n}\n\n// Column creates a new ColumnWidget.\nfunc Column(widgets ...Widget) *ColumnWidget {\n\treturn &ColumnWidget{\n\t\twidgets: widgets,\n\t}\n}\n\n// Build implements Widget interface.\nfunc (g *ColumnWidget) Build() {\n\timgui.BeginGroup()\n\n\tg.widgets.Build()\n\n\timgui.EndGroup()\n}\n\nvar _ Widget = &MainMenuBarWidget{}\n\n// MainMenuBarWidget is a widget that creates a main menu bar.\n// Main means that it will be docked to the MasterWindow.\n// Do NOT use with SingleWindow (see MenuBarWidget).\ntype MainMenuBarWidget struct {\n\tlayout Layout\n}\n\n// MainMenuBar creates new MainMenuBarWidget.\nfunc MainMenuBar() *MainMenuBarWidget {\n\treturn &MainMenuBarWidget{\n\t\tlayout: nil,\n\t}\n}\n\n// Layout sets layout of the menu bar. (See MenuWidget).\nfunc (m *MainMenuBarWidget) Layout(widgets ...Widget) *MainMenuBarWidget {\n\tm.layout = Layout(widgets)\n\treturn m\n}\n\n// Build implements Widget interface.\nfunc (m *MainMenuBarWidget) Build() {\n\tif imgui.BeginMainMenuBar() {\n\t\tm.layout.Build()\n\t\timgui.EndMainMenuBar()\n\t}\n}\n\nvar _ Widget = &MenuBarWidget{}\n\n// MenuBarWidget is a widget that creates a menu bar for a window.\n// Use it e.g. with SingleWindowWithMenuBar.\ntype MenuBarWidget struct {\n\tlayout Layout\n}\n\n// MenuBar creates new MenuBarWidget.\nfunc MenuBar() *MenuBarWidget {\n\treturn &MenuBarWidget{\n\t\tlayout: nil,\n\t}\n}\n\n// Layout sets layout of the menu bar. (See MenuWidget).\nfunc (m *MenuBarWidget) Layout(widgets ...Widget) *MenuBarWidget {\n\tm.layout = Layout(widgets)\n\treturn m\n}\n\n// Build implements Widget interface.\nfunc (m *MenuBarWidget) Build() {\n\tif imgui.BeginMenuBar() {\n\t\tm.layout.Build()\n\t\timgui.EndMenuBar()\n\t}\n}\n\nvar _ Widget = &MenuItemWidget{}\n\n// MenuItemWidget is a menu node. Commonly used inside of MenuWidget.\ntype MenuItemWidget struct {\n\tlabel    ID\n\tshortcut string\n\tselected bool\n\tenabled  bool\n\tonClick  func()\n}\n\n// MenuItem creates new MenuItemWidget.\nfunc MenuItem(label string) *MenuItemWidget {\n\treturn &MenuItemWidget{\n\t\tlabel:    GenAutoID(label),\n\t\tshortcut: \"\",\n\t\tselected: false,\n\t\tenabled:  true,\n\t\tonClick:  nil,\n\t}\n}\n\n// MenuItemf creates MenuItem with formated label.\nfunc MenuItemf(format string, args ...any) *MenuItemWidget {\n\treturn MenuItem(fmt.Sprintf(format, args...))\n}\n\n// Shortcut sets shortcut of the item (grayed, right-aligned text). Used for presenting e.g. keyboard shortcuts (e.g. \"Ctrl+S\")\n// NOTE: this is only a visual effect. It has nothing to do with keyboard shortcuts.\nfunc (m *MenuItemWidget) Shortcut(s string) *MenuItemWidget {\n\tm.shortcut = s\n\treturn m\n}\n\n// Selected sets whether the item is selected.\nfunc (m *MenuItemWidget) Selected(s bool) *MenuItemWidget {\n\tm.selected = s\n\treturn m\n}\n\n// Enabled sets whether the item is enabled.\nfunc (m *MenuItemWidget) Enabled(e bool) *MenuItemWidget {\n\tm.enabled = e\n\treturn m\n}\n\n// OnClick sets callback that will be executed when item is clicked.\nfunc (m *MenuItemWidget) OnClick(onClick func()) *MenuItemWidget {\n\tm.onClick = onClick\n\treturn m\n}\n\n// Build implements Widget interface.\nfunc (m *MenuItemWidget) Build() {\n\tif imgui.MenuItemBoolV(Context.FontAtlas.RegisterString(m.label.String()), m.shortcut, m.selected, m.enabled) && m.onClick != nil {\n\t\tm.onClick()\n\t}\n}\n\nvar _ Widget = &MenuWidget{}\n\n// MenuWidget is a node of (Main)MenuBarWidget.\n// See also: MenuItemWidget, MenuBarWidget, MainMenuBarWidget.\ntype MenuWidget struct {\n\tlabel   ID\n\tenabled bool\n\tlayout  Layout\n}\n\n// Menu creates new MenuWidget.\nfunc Menu(label string) *MenuWidget {\n\treturn &MenuWidget{\n\t\tlabel:   GenAutoID(label),\n\t\tenabled: true,\n\t\tlayout:  nil,\n\t}\n}\n\n// Menuf is alias to Menu(fmt.Sprintf(format, args...)).\nfunc Menuf(format string, args ...any) *MenuWidget {\n\treturn Menu(fmt.Sprintf(format, args...))\n}\n\n// Enabled sets whether the menu is enabled.\nfunc (m *MenuWidget) Enabled(e bool) *MenuWidget {\n\tm.enabled = e\n\treturn m\n}\n\n// Layout sets layout of the menu. (See MenuItemWidget).\nfunc (m *MenuWidget) Layout(widgets ...Widget) *MenuWidget {\n\tm.layout = widgets\n\treturn m\n}\n\n// Build implements Widget interface.\nfunc (m *MenuWidget) Build() {\n\tif imgui.BeginMenuV(Context.FontAtlas.RegisterString(m.label.String()), m.enabled) {\n\t\tm.layout.Build()\n\t\timgui.EndMenu()\n\t}\n}\n\nvar _ Widget = &ProgressBarWidget{}\n\n// ProgressBarWidget is a progress bar (like in windows' copy-file dialog).\n// It is a perfect solution to indicate percentage progress of some action.\ntype ProgressBarWidget struct {\n\tfraction float32\n\twidth    float32\n\theight   float32\n\toverlay  string\n}\n\n// ProgressBar creates new ProgressBar.\nfunc ProgressBar(fraction float32) *ProgressBarWidget {\n\treturn &ProgressBarWidget{\n\t\tfraction: fraction,\n\t\twidth:    0,\n\t\theight:   0,\n\t\toverlay:  \"\",\n\t}\n}\n\n// Size sets size of the bar.\nfunc (p *ProgressBarWidget) Size(width, height float32) *ProgressBarWidget {\n\tp.width, p.height = width, height\n\treturn p\n}\n\n// Overlay sets custom overlay displayed on the bar.\nfunc (p *ProgressBarWidget) Overlay(overlay string) *ProgressBarWidget {\n\tp.overlay = Context.FontAtlas.RegisterString(overlay)\n\treturn p\n}\n\n// Overlayf is alias to Overlay(fmt.Sprintf(format, args...)).\nfunc (p *ProgressBarWidget) Overlayf(format string, args ...any) *ProgressBarWidget {\n\treturn p.Overlay(fmt.Sprintf(format, args...))\n}\n\n// Build implements Widget interface.\nfunc (p *ProgressBarWidget) Build() {\n\timgui.ProgressBarV(p.fraction, imgui.Vec2{X: p.width, Y: p.height}, p.overlay)\n}\n\nvar _ Widget = &SeparatorWidget{}\n\n// SeparatorWidget is like <hr> in HTML.\n// Creates a layout-wide line.\ntype SeparatorWidget struct{}\n\n// Separator creates new SeparatorWidget.\nfunc Separator() *SeparatorWidget {\n\treturn &SeparatorWidget{}\n}\n\n// Build implements Widget interface.\nfunc (s *SeparatorWidget) Build() {\n\timgui.Separator()\n}\n\nvar _ Widget = &DummyWidget{}\n\n// DummyWidget creates an empty space (moves drawing cursor by width and height).\ntype DummyWidget struct {\n\twidth  float32\n\theight float32\n}\n\n// Dummy creates new DummyWidget.\nfunc Dummy(width, height float32) *DummyWidget {\n\treturn &DummyWidget{\n\t\twidth:  width,\n\t\theight: height,\n\t}\n}\n\n// Build implements Widget interface.\nfunc (d *DummyWidget) Build() {\n\tw, h := GetAvailableRegion()\n\n\tif d.width < 0 {\n\t\td.width = w + d.width\n\t}\n\n\tif d.height < 0 {\n\t\td.height = h + d.height\n\t}\n\n\timgui.Dummy(imgui.Vec2{X: d.width, Y: d.height})\n}\n\n// TabItemWidget is an item in TabBarWidget.\ntype TabItemWidget struct {\n\tlabel  string\n\topen   *bool\n\tflags  TabItemFlags\n\tlayout Layout\n}\n\n// TabItem creates new TabItem.\nfunc TabItem(label string) *TabItemWidget {\n\treturn &TabItemWidget{\n\t\tlabel:  Context.FontAtlas.RegisterString(label),\n\t\topen:   nil,\n\t\tflags:  0,\n\t\tlayout: nil,\n\t}\n}\n\n// TabItemf creates tab item with formated label.\nfunc TabItemf(format string, args ...any) *TabItemWidget {\n\treturn TabItem(fmt.Sprintf(format, args...))\n}\n\n// IsOpen takes a pointer to a boolean.\n// Value of this pointer indicated whether TabItem is currently selected.\n// NOTE: The item will NOT be opened/closed if this value is changed.\n// It has only one-side effect.\nfunc (t *TabItemWidget) IsOpen(open *bool) *TabItemWidget {\n\tt.open = open\n\treturn t\n}\n\n// Flags allows to set item's flags.\nfunc (t *TabItemWidget) Flags(flags TabItemFlags) *TabItemWidget {\n\tt.flags = flags\n\treturn t\n}\n\n// Layout is a layout displayed when item is opened.\nfunc (t *TabItemWidget) Layout(widgets ...Widget) *TabItemWidget {\n\tt.layout = Layout(widgets)\n\treturn t\n}\n\n// BuildTabItem executes tab item build steps.\nfunc (t *TabItemWidget) BuildTabItem() {\n\tif imgui.BeginTabItemV(t.label, t.open, imgui.TabItemFlags(t.flags)) {\n\t\tt.layout.Build()\n\t\timgui.EndTabItem()\n\t}\n}\n\nvar _ Widget = &TabBarWidget{}\n\n// TabBarWidget is a bar of TabItemWidgets.\ntype TabBarWidget struct {\n\tid       ID\n\tflags    TabBarFlags\n\ttabItems []*TabItemWidget\n}\n\n// TabBar creates new TabBarWidget.\nfunc TabBar() *TabBarWidget {\n\treturn &TabBarWidget{\n\t\tid:    GenAutoID(\"TabBar\"),\n\t\tflags: 0,\n\t}\n}\n\n// Flags allows to set TabBArFlags.\nfunc (t *TabBarWidget) Flags(flags TabBarFlags) *TabBarWidget {\n\tt.flags = flags\n\treturn t\n}\n\n// ID manually sets widget's ID.\nfunc (t *TabBarWidget) ID(id ID) *TabBarWidget {\n\tt.id = id\n\treturn t\n}\n\n// TabItems sets list of TabItemWidgets in the bar.\nfunc (t *TabBarWidget) TabItems(items ...*TabItemWidget) *TabBarWidget {\n\tt.tabItems = items\n\treturn t\n}\n\n// Build implements Widget interface.\nfunc (t *TabBarWidget) Build() {\n\tif imgui.BeginTabBarV(t.id.String(), imgui.TabBarFlags(t.flags)) {\n\t\tfor _, ti := range t.tabItems {\n\t\t\tti.BuildTabItem()\n\t\t}\n\n\t\timgui.EndTabBar()\n\t}\n}\n\nvar _ Widget = &TooltipWidget{}\n\n// TooltipWidget sets a tooltip on the previous widget.\n// The tooltip can be anything.\ntype TooltipWidget struct {\n\ttip    string\n\tlayout Layout\n\tto     Layout\n}\n\n// Tooltip creates new tooltip with given label\n// NOTE: you can set the empty label and use Layout() method.\nfunc Tooltip(tip string) *TooltipWidget {\n\treturn &TooltipWidget{\n\t\ttip:    Context.FontAtlas.RegisterString(tip),\n\t\tlayout: nil,\n\t}\n}\n\n// Tooltipf sets formated label.\nfunc Tooltipf(format string, args ...any) *TooltipWidget {\n\treturn Tooltip(fmt.Sprintf(format, args...))\n}\n\n// Layout sets a custom layout of tooltip.\nfunc (t *TooltipWidget) Layout(widgets ...Widget) *TooltipWidget {\n\tt.layout = Layout(widgets)\n\treturn t\n}\n\n// To sets layout to which the tooltip should be attached.\n// NOTE: This is an optional approach. By default tooltip is attached to the previous widget.\nfunc (t *TooltipWidget) To(layout ...Widget) *TooltipWidget {\n\tt.to = Layout(layout)\n\treturn t\n}\n\n// Build implements Widget interface.\nfunc (t *TooltipWidget) Build() {\n\tif t.to != nil {\n\t\tt.to.Range(func(w Widget) {\n\t\t\tw.Build()\n\t\t\tt.buildTooltip()\n\t\t})\n\n\t\treturn\n\t}\n\n\tt.buildTooltip()\n}\n\nfunc (t *TooltipWidget) buildTooltip() {\n\tif imgui.IsItemHovered() {\n\t\tif t.layout != nil {\n\t\t\timgui.BeginTooltip()\n\t\t\tt.layout.Build()\n\t\t\timgui.EndTooltip()\n\t\t} else {\n\t\t\timgui.SetTooltip(t.tip)\n\t\t}\n\t}\n}\n\nvar _ Widget = &SpacingWidget{}\n\n// SpacingWidget increases a spacing between two widgets a bit.\ntype SpacingWidget struct{}\n\n// Spacing creates new SpacingWidget.\nfunc Spacing() *SpacingWidget {\n\treturn &SpacingWidget{}\n}\n\n// Build implements Widget interface.\nfunc (s *SpacingWidget) Build() {\n\timgui.Spacing()\n}\n\nvar _ Widget = &ColorEditWidget{}\n\n// ColorEditWidget is a widget that provides a color editor.\ntype ColorEditWidget struct {\n\tlabel    ID\n\tcolor    *color.RGBA\n\tflags    ColorEditFlags\n\twidth    float32\n\tonChange func()\n}\n\n// ColorEdit creates new ColorEditWidget.\nfunc ColorEdit(label string, c *color.RGBA) *ColorEditWidget {\n\treturn &ColorEditWidget{\n\t\tlabel: GenAutoID(label),\n\t\tcolor: c,\n\t\t// flags: ColorEditFlagsNone,\n\t}\n}\n\n// OnChange sets callback that will be executed when color is changed.\nfunc (ce *ColorEditWidget) OnChange(cb func()) *ColorEditWidget {\n\tce.onChange = cb\n\treturn ce\n}\n\n// Flags allows to set ColorEditFlags.\nfunc (ce *ColorEditWidget) Flags(f ColorEditFlags) *ColorEditWidget {\n\tce.flags = f\n\treturn ce\n}\n\n// Size sets width of the color editor.\nfunc (ce *ColorEditWidget) Size(width float32) *ColorEditWidget {\n\tce.width = width\n\treturn ce\n}\n\n// Build implements Widget interface.\nfunc (ce *ColorEditWidget) Build() {\n\tc := ToVec4Color(*ce.color)\n\tcol := [4]float32{\n\t\tc.X,\n\t\tc.Y,\n\t\tc.Z,\n\t\tc.W,\n\t}\n\n\tif ce.width > 0 {\n\t\timgui.PushItemWidth(ce.width)\n\t}\n\n\tif imgui.ColorEdit4V(\n\t\tContext.FontAtlas.RegisterString(ce.label.String()),\n\t\t&col,\n\t\timgui.ColorEditFlags(ce.flags),\n\t) {\n\t\t*ce.color = Vec4ToRGBA(imgui.Vec4{\n\t\t\tX: col[0],\n\t\t\tY: col[1],\n\t\t\tZ: col[2],\n\t\t\tW: col[3],\n\t\t})\n\t\tif ce.onChange != nil {\n\t\t\tce.onChange()\n\t\t}\n\t}\n\n\tif ce.width > 0 {\n\t\timgui.PopItemWidth()\n\t}\n}\n"
        },
        {
          "name": "Window.go",
          "type": "blob",
          "size": 5.4365234375,
          "content": "package giu\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/AllenDang/cimgui-go/imgui\"\n)\n\n// SingleWindow creates one window filling all available space\n// in MasterWindow. If SingleWindow is set up, no other windows may be\n// defined.\nfunc SingleWindow() *WindowWidget {\n\tpos := imgui.MainViewport().Pos()\n\tsizeX, sizeY := Context.backend.DisplaySize()\n\ttitle := GenAutoID(\"SingleWindow\")\n\n\treturn Window(title.String()). // TODO: maybe we should implement auto id in Window too?\n\t\t\t\t\tFlags(\n\t\t\tWindowFlags(imgui.WindowFlagsNoTitleBar)|\n\t\t\t\tWindowFlags(imgui.WindowFlagsNoCollapse)|\n\t\t\t\tWindowFlags(imgui.WindowFlagsNoScrollbar)|\n\t\t\t\tWindowFlags(imgui.WindowFlagsNoMove)|\n\t\t\t\tWindowFlags(imgui.WindowFlagsNoResize),\n\t\t).\n\t\tPos(pos.X, pos.Y).Size(float32(sizeX), float32(sizeY))\n}\n\n// SingleWindowWithMenuBar creates a SingleWindow and allows to add menubar on its top.\nfunc SingleWindowWithMenuBar() *WindowWidget {\n\tpos := imgui.MainViewport().Pos()\n\tsizeX, sizeY := Context.backend.DisplaySize()\n\ttitle := GenAutoID(\"SingleWindowWithMenuBar\")\n\n\treturn Window(title.String()). // TODO: maybe we should implement auto id in Window too?\n\t\t\t\t\tFlags(\n\t\t\tWindowFlags(imgui.WindowFlagsNoTitleBar)|\n\t\t\t\tWindowFlags(imgui.WindowFlagsNoCollapse)|\n\t\t\t\tWindowFlags(imgui.WindowFlagsNoScrollbar)|\n\t\t\t\tWindowFlags(imgui.WindowFlagsNoMove)|\n\t\t\t\tWindowFlags(imgui.WindowFlagsMenuBar)|\n\t\t\t\tWindowFlags(imgui.WindowFlagsNoResize),\n\t\t).Size(float32(sizeX), float32(sizeY)).Pos(pos.X, pos.Y)\n}\n\nvar _ Disposable = &windowState{}\n\ntype windowState struct {\n\thasFocus bool\n\tcurrentPosition,\n\tcurrentSize imgui.Vec2\n}\n\n// Dispose implements Disposable interface.\nfunc (s *windowState) Dispose() {\n\t// noop\n}\n\n// WindowWidget represents imgui.Window\n// Windows are used to display ui widgets.\n// They are in second place in the giu hierarchy (after the MasterWindow)\n// NOTE: to disable multiple window, use SingleWindow.\ntype WindowWidget struct {\n\ttitle         string\n\topen          *bool\n\tflags         WindowFlags\n\tx, y          float32\n\twidth, height float32\n\tbringToFront  bool\n}\n\n// Window creates a WindowWidget.\nfunc Window(title string) *WindowWidget {\n\tdefaultPos := imgui.MainViewport().Pos()\n\n\treturn (&WindowWidget{\n\t\ttitle: title,\n\t}).Pos(defaultPos.X, defaultPos.Y)\n}\n\n// IsOpen sets if window widget is `opened` (minimized).\nfunc (w *WindowWidget) IsOpen(open *bool) *WindowWidget {\n\tw.open = open\n\treturn w\n}\n\n// Flags sets window flags.\nfunc (w *WindowWidget) Flags(flags WindowFlags) *WindowWidget {\n\tw.flags = flags\n\treturn w\n}\n\n// Size sets window size\n// NOTE: size can be changed by user, if you want to prevent\n// user from changing window size, use NoResize flag.\nfunc (w *WindowWidget) Size(width, height float32) *WindowWidget {\n\tw.width, w.height = width, height\n\treturn w\n}\n\n// Pos sets the window start position\n// NOTE: The position could be changed by user later.\n// To prevent user from changing window position use\n// WIndowFlagsNoMove.\nfunc (w *WindowWidget) Pos(x, y float32) *WindowWidget {\n\tw.x, w.y = x, y\n\treturn w\n}\n\n// Layout is a final step of the window setup.\n// it should be called to add a layout to the window and build it.\nfunc (w *WindowWidget) Layout(widgets ...Widget) {\n\tif widgets == nil {\n\t\treturn\n\t}\n\n\tws := w.getState()\n\n\tif w.flags&WindowFlags(imgui.WindowFlagsNoMove) != 0 && w.flags&WindowFlags(imgui.WindowFlagsNoResize) != 0 {\n\t\timgui.SetNextWindowPos(imgui.Vec2{X: w.x, Y: w.y})\n\t\timgui.SetNextWindowSize(imgui.Vec2{X: w.width, Y: w.height})\n\t} else {\n\t\timgui.SetNextWindowPosV(imgui.Vec2{X: w.x, Y: w.y}, imgui.CondFirstUseEver, imgui.Vec2{X: 0, Y: 0})\n\t\timgui.SetNextWindowSizeV(imgui.Vec2{X: w.width, Y: w.height}, imgui.CondFirstUseEver)\n\t}\n\n\tif w.bringToFront {\n\t\timgui.SetNextWindowFocus()\n\n\t\tw.bringToFront = false\n\t}\n\n\twidgets = append(widgets,\n\t\tCustom(func() {\n\t\t\thasFocus := IsWindowFocused(0)\n\t\t\tif !hasFocus && ws.hasFocus {\n\t\t\t\tContext.InputHandler.UnregisterWindowShortcuts()\n\t\t\t}\n\n\t\t\tws.hasFocus = hasFocus\n\n\t\t\tws.currentPosition = imgui.WindowPos()\n\t\t\tws.currentSize = imgui.WindowSize()\n\t\t}),\n\t)\n\n\tshowed := imgui.BeginV(Context.FontAtlas.RegisterString(w.title), w.open, imgui.WindowFlags(w.flags))\n\n\tif showed {\n\t\tLayout(widgets).Build()\n\t}\n\n\timgui.End()\n}\n\n// CurrentPosition returns a current position of the window.\nfunc (w *WindowWidget) CurrentPosition() (x, y float32) {\n\tpos := w.getState().currentPosition\n\treturn pos.X, pos.Y\n}\n\n// CurrentSize returns current size of the window.\nfunc (w *WindowWidget) CurrentSize() (width, height float32) {\n\tsize := w.getState().currentSize\n\treturn size.X, size.Y\n}\n\n// BringToFront sets window focused.\nfunc (w *WindowWidget) BringToFront() {\n\tw.bringToFront = true\n}\n\n// HasFocus returns true if window is focused.\nfunc (w *WindowWidget) HasFocus() bool {\n\treturn w.getState().hasFocus\n}\n\n// RegisterKeyboardShortcuts adds local (window-level) keyboard shortcuts\n// see InputHandler.go.\nfunc (w *WindowWidget) RegisterKeyboardShortcuts(s ...WindowShortcut) *WindowWidget {\n\tif w.HasFocus() {\n\t\tfor _, shortcut := range s {\n\t\t\tContext.InputHandler.RegisterKeyboardShortcuts(Shortcut{\n\t\t\t\tKey:      shortcut.Key,\n\t\t\t\tModifier: shortcut.Modifier,\n\t\t\t\tCallback: shortcut.Callback,\n\t\t\t\tIsGlobal: LocalShortcut,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn w\n}\n\nfunc (w *WindowWidget) getStateID() ID {\n\treturn ID(fmt.Sprintf(\"%s_windowState\", w.title))\n}\n\n// returns window state.\nfunc (w *WindowWidget) getState() (state *windowState) {\n\tif state = GetState[windowState](Context, w.getStateID()); state == nil {\n\t\tstate = &windowState{}\n\t\tSetState(Context, w.getStateID(), state)\n\t}\n\n\treturn state\n}\n"
        },
        {
          "name": "build_windows.go",
          "type": "blob",
          "size": 0.0849609375,
          "content": "//go:build windows\n// +build windows\n\npackage giu\n\n// #cgo LDFLAGS: -static\nimport \"C\"\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.181640625,
          "content": "// Package giu - A rapid cross-platform GUI framework for Go based on Dear ImGui\n// and the great Go binding imgui-go.\n//\n// for details and usage see README of the project.\npackage giu\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.8779296875,
          "content": "module github.com/AllenDang/giu\n\ngo 1.23.3\n\nrequire (\n\tgithub.com/AllenDang/cimgui-go v1.3.0\n\tgithub.com/AllenDang/go-findfont v0.0.0-20200702051237-9f180485aeb8\n\tgithub.com/faiface/mainthread v0.0.0-20171120011319-8b78f0a41ae3\n\tgithub.com/gucio321/glm-go v0.0.0-20241029220517-e1b5a3e011c8\n\tgithub.com/mazznoer/csscolorparser v0.1.5\n\tgithub.com/napsy/go-css v0.0.0-20221107082635-4ed403047a64\n\tgithub.com/pkg/browser v0.0.0-20210911075715-681adbf594b8\n\tgithub.com/sahilm/fuzzy v0.1.1\n\tgithub.com/stretchr/testify v1.10.0\n\tgolang.design/x/hotkey v0.4.1\n\tgolang.org/x/image v0.23.0\n\tgopkg.in/eapache/queue.v1 v1.1.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/kylelemons/godebug v1.1.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgolang.design/x/mainthread v0.3.0 // indirect\n\tgolang.org/x/sys v0.25.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.6689453125,
          "content": "github.com/AllenDang/cimgui-go v1.3.0 h1:iFK0SBjfOnd8qCnn8PLMFh/uTceuJGN0hVXRxokMz20=\ngithub.com/AllenDang/cimgui-go v1.3.0/go.mod h1:1i5vebTbRcCAlui+AUn3A3U0V2tu/qImW0NoLr+/Fek=\ngithub.com/AllenDang/go-findfont v0.0.0-20200702051237-9f180485aeb8 h1:dKZMqib/yUDoCFigmz2agG8geZ/e3iRq304/KJXqKyw=\ngithub.com/AllenDang/go-findfont v0.0.0-20200702051237-9f180485aeb8/go.mod h1:b4uuDd0s6KRIPa84cEEchdQ9ICh7K0OryZHbSzMca9k=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/faiface/mainthread v0.0.0-20171120011319-8b78f0a41ae3 h1:baVdMKlASEHrj19iqjARrPbaRisD7EuZEVJj6ZMLl1Q=\ngithub.com/faiface/mainthread v0.0.0-20171120011319-8b78f0a41ae3/go.mod h1:VEPNJUlxl5KdWjDvz6Q1l+rJlxF2i6xqDeGuGAxa87M=\ngithub.com/gucio321/glm-go v0.0.0-20241029220517-e1b5a3e011c8 h1:aczNwZRrReVWrZcqxvDjDmxP1NFISTAu+1Cp+3OCbUg=\ngithub.com/gucio321/glm-go v0.0.0-20241029220517-e1b5a3e011c8/go.mod h1:Z3+NtD1rjXUVZg97dojhs70i5oneOrZ1xcFKfF/c2Ts=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/mazznoer/csscolorparser v0.1.5 h1:Wr4uNIE+pHWN3TqZn2SGpA2nLRG064gB7WdSfSS5cz4=\ngithub.com/mazznoer/csscolorparser v0.1.5/go.mod h1:OQRVvgCyHDCAquR1YWfSwwaDcM0LhnSffGnlbOew/3I=\ngithub.com/napsy/go-css v0.0.0-20221107082635-4ed403047a64 h1:7LWtWY3Ei9ghnamqn8xCu7LOXAKaQrcfbcf0sU33LG4=\ngithub.com/napsy/go-css v0.0.0-20221107082635-4ed403047a64/go.mod h1:HqZYcKcNnv50fgOTdGUn9YbJa2qC9oJ3kLnyrwwVzUI=\ngithub.com/pkg/browser v0.0.0-20210911075715-681adbf594b8 h1:KoWmjvw+nsYOo29YJK9vDA65RGE3NrOnUtO7a+RF9HU=\ngithub.com/pkg/browser v0.0.0-20210911075715-681adbf594b8/go.mod h1:HKlIX3XHQyzLZPlr7++PzdhaXEj94dEiJgZDTsxEqUI=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/sahilm/fuzzy v0.1.1 h1:ceu5RHF8DGgoi+/dR5PsECjCDH1BE3Fnmpo7aVXOdRA=\ngithub.com/sahilm/fuzzy v0.1.1/go.mod h1:VFvziUEIMCrT6A6tw2RFIXPXXmzXbOsSHF0DOI8ZK9Y=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngolang.design/x/hotkey v0.4.1 h1:zLP/2Pztl4WjyxURdW84GoZ5LUrr6hr69CzJFJ5U1go=\ngolang.design/x/hotkey v0.4.1/go.mod h1:M8SGcwFYHnKRa83FpTFQoZvPO5vVT+kWPztFqTQKmXA=\ngolang.design/x/mainthread v0.3.0 h1:UwFus0lcPodNpMOGoQMe87jSFwbSsEY//CA7yVmu4j8=\ngolang.design/x/mainthread v0.3.0/go.mod h1:vYX7cF2b3pTJMGM/hc13NmN6kblKnf4/IyvHeu259L0=\ngolang.org/x/image v0.23.0 h1:HseQ7c2OpPKTPVzNjG5fwJsOTCiiwS4QdsYi5XU6H68=\ngolang.org/x/image v0.23.0/go.mod h1:wJJBTdLfCCf3tiHa1fNxpZmUI4mmoZvwMCPP0ddoNKY=\ngolang.org/x/sys v0.0.0-20201022201747-fb209a7c41cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210616045830-e2b7044e8c71/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=\ngolang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/eapache/queue.v1 v1.1.0 h1:EldqoJEGtXYiVCMRo2C9mePO2UUGnYn2+qLmlQSqPdc=\ngopkg.in/eapache/queue.v1 v1.1.0/go.mod h1:wNtmx1/O7kZSR9zNT1TTOJ7GLpm3Vn7srzlfylFbQwU=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "mainthread_all.go",
          "type": "blob",
          "size": 0.1689453125,
          "content": "//go:build !darwin && !windows\n// +build !darwin,!windows\n\npackage giu\n\nimport \"github.com/faiface/mainthread\"\n\nfunc mainthreadCallPlatform(c func()) {\n\tmainthread.Run(c)\n}\n"
        },
        {
          "name": "mainthread_mac.go",
          "type": "blob",
          "size": 0.1513671875,
          "content": "//go:build darwin\n// +build darwin\n\npackage giu\n\nimport \"golang.design/x/hotkey/mainthread\"\n\nfunc mainthreadCallPlatform(c func()) {\n\tmainthread.Call(c)\n}\n"
        },
        {
          "name": "mainthread_windows.go",
          "type": "blob",
          "size": 0.57421875,
          "content": "//go:build windows\n// +build windows\n\npackage giu\n\nimport \"runtime\"\n\n// according to:\n// https://github.com/AllenDang/giu/issues/881\n// this init solves some windows problems.\n// However I'm not sure about implications of this. Will turn out later.\nfunc init() {\n\truntime.LockOSThread()\n}\n\n// I have no working mainthread library for windows.\n// - this one for macOS crashes app immediately\n// - this for linux (and everything else) freezes after a few seconds\n//\n// this seems to solve an issue: https://github.com/AllenDang/giu/issues/881\nfunc mainthreadCallPlatform(c func()) {\n\tc()\n}\n"
        },
        {
          "name": "migration.txt",
          "type": "blob",
          "size": 0.1181640625,
          "content": "API Changes:\n- remove InputTextFlagsAlwaysInsertMode\n- remove TabItemFlagsNoPushID\n- create: UintToColor and ColorToUint\n"
        },
        {
          "name": "screenshots",
          "type": "tree",
          "content": null
        },
        {
          "name": "stylecolorid_enumer.go",
          "type": "blob",
          "size": 15.7548828125,
          "content": "// Code generated by \"enumer -linecomment -type=StyleColorID .\"; DO NOT EDIT.\n\npackage giu\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nconst (\n\t_StyleColorIDName_0      = \"colordisabled-colorbackground-colorchild-background-colorpopup-background-colorborder-colorborder-shadow-colorframe-background-colorframe-background-hovered-colorframe-background-active-colortitle-background-colortitle-background-active-colortitle-background-collapsed-colormenu-bar-background-colorscrollbar-background-colorscrollbar-grab-colorscrollbar-grab-hovered-colorscrollbar-grab-active-colorcheckmark-colorslider-grab-colorslider-grab-active-colorbutton-colorbutton-hovered-colorbutton-active-colorheader-colorheader-hovered-colorheader-active-colorseparator-colorseparator-hovered-colorseparator-active-colorresize-grip-colorresize-grip-hovered-colorresize-grip-active-colortab-hovered-colortab-colortab-active-color\"\n\t_StyleColorIDLowerName_0 = \"colordisabled-colorbackground-colorchild-background-colorpopup-background-colorborder-colorborder-shadow-colorframe-background-colorframe-background-hovered-colorframe-background-active-colortitle-background-colortitle-background-active-colortitle-background-collapsed-colormenu-bar-background-colorscrollbar-background-colorscrollbar-grab-colorscrollbar-grab-hovered-colorscrollbar-grab-active-colorcheckmark-colorslider-grab-colorslider-grab-active-colorbutton-colorbutton-hovered-colorbutton-active-colorheader-colorheader-hovered-colorheader-active-colorseparator-colorseparator-hovered-colorseparator-active-colorresize-grip-colorresize-grip-hovered-colorresize-grip-active-colortab-hovered-colortab-colortab-active-color\"\n\t_StyleColorIDName_1      = \"tab-unfocused-colortab-unfocused-active-color\"\n\t_StyleColorIDLowerName_1 = \"tab-unfocused-colortab-unfocused-active-color\"\n\t_StyleColorIDName_2      = \"plot-lines-colorplot-lines-hovered-colorplot-histogram-colorplot-histogram-hovered-colortable-header-background-colortable-border-strong-colortable-border-light-colortable-row-background-colortable-row-alternate-background-color\"\n\t_StyleColorIDLowerName_2 = \"plot-lines-colorplot-lines-hovered-colorplot-histogram-colorplot-histogram-hovered-colortable-header-background-colortable-border-strong-colortable-border-light-colortable-row-background-colortable-row-alternate-background-color\"\n\t_StyleColorIDName_3      = \"text-selected-background-colordrag-drop-target-color\"\n\t_StyleColorIDLowerName_3 = \"text-selected-background-colordrag-drop-target-color\"\n\t_StyleColorIDName_4      = \"navigation-highlight-colorwindowing-dim-background-colormodal-window-dim-background-color\"\n\t_StyleColorIDLowerName_4 = \"navigation-highlight-colorwindowing-dim-background-colormodal-window-dim-background-color\"\n)\n\nvar (\n\t_StyleColorIDIndex_0 = [...]uint16{0, 5, 19, 35, 57, 79, 91, 110, 132, 162, 191, 213, 242, 274, 299, 325, 345, 373, 400, 415, 432, 456, 468, 488, 507, 519, 539, 558, 573, 596, 618, 635, 660, 684, 701, 710, 726}\n\t_StyleColorIDIndex_1 = [...]uint8{0, 19, 45}\n\t_StyleColorIDIndex_2 = [...]uint8{0, 16, 40, 60, 88, 117, 142, 166, 192, 228}\n\t_StyleColorIDIndex_3 = [...]uint8{0, 30, 52}\n\t_StyleColorIDIndex_4 = [...]uint8{0, 26, 56, 89}\n)\n\nfunc (i StyleColorID) String() string {\n\tswitch {\n\tcase 0 <= i && i <= 35:\n\t\treturn _StyleColorIDName_0[_StyleColorIDIndex_0[i]:_StyleColorIDIndex_0[i+1]]\n\tcase 37 <= i && i <= 38:\n\t\ti -= 37\n\t\treturn _StyleColorIDName_1[_StyleColorIDIndex_1[i]:_StyleColorIDIndex_1[i+1]]\n\tcase 42 <= i && i <= 50:\n\t\ti -= 42\n\t\treturn _StyleColorIDName_2[_StyleColorIDIndex_2[i]:_StyleColorIDIndex_2[i+1]]\n\tcase 52 <= i && i <= 53:\n\t\ti -= 52\n\t\treturn _StyleColorIDName_3[_StyleColorIDIndex_3[i]:_StyleColorIDIndex_3[i+1]]\n\tcase 55 <= i && i <= 57:\n\t\ti -= 55\n\t\treturn _StyleColorIDName_4[_StyleColorIDIndex_4[i]:_StyleColorIDIndex_4[i+1]]\n\tdefault:\n\t\treturn fmt.Sprintf(\"StyleColorID(%d)\", i)\n\t}\n}\n\n// An \"invalid array index\" compiler error signifies that the constant values have changed.\n// Re-run the stringer command to generate them again.\nfunc _StyleColorIDNoOp() {\n\tvar x [1]struct{}\n\t_ = x[StyleColorText-(0)]\n\t_ = x[StyleColorTextDisabled-(1)]\n\t_ = x[StyleColorWindowBg-(2)]\n\t_ = x[StyleColorChildBg-(3)]\n\t_ = x[StyleColorPopupBg-(4)]\n\t_ = x[StyleColorBorder-(5)]\n\t_ = x[StyleColorBorderShadow-(6)]\n\t_ = x[StyleColorFrameBg-(7)]\n\t_ = x[StyleColorFrameBgHovered-(8)]\n\t_ = x[StyleColorFrameBgActive-(9)]\n\t_ = x[StyleColorTitleBg-(10)]\n\t_ = x[StyleColorTitleBgActive-(11)]\n\t_ = x[StyleColorTitleBgCollapsed-(12)]\n\t_ = x[StyleColorMenuBarBg-(13)]\n\t_ = x[StyleColorScrollbarBg-(14)]\n\t_ = x[StyleColorScrollbarGrab-(15)]\n\t_ = x[StyleColorScrollbarGrabHovered-(16)]\n\t_ = x[StyleColorScrollbarGrabActive-(17)]\n\t_ = x[StyleColorCheckMark-(18)]\n\t_ = x[StyleColorSliderGrab-(19)]\n\t_ = x[StyleColorSliderGrabActive-(20)]\n\t_ = x[StyleColorButton-(21)]\n\t_ = x[StyleColorButtonHovered-(22)]\n\t_ = x[StyleColorButtonActive-(23)]\n\t_ = x[StyleColorHeader-(24)]\n\t_ = x[StyleColorHeaderHovered-(25)]\n\t_ = x[StyleColorHeaderActive-(26)]\n\t_ = x[StyleColorSeparator-(27)]\n\t_ = x[StyleColorSeparatorHovered-(28)]\n\t_ = x[StyleColorSeparatorActive-(29)]\n\t_ = x[StyleColorResizeGrip-(30)]\n\t_ = x[StyleColorResizeGripHovered-(31)]\n\t_ = x[StyleColorResizeGripActive-(32)]\n\t_ = x[StyleColorTabHovered-(33)]\n\t_ = x[StyleColorTab-(34)]\n\t_ = x[StyleColorTabActive-(35)]\n\t_ = x[StyleColorTabUnfocused-(37)]\n\t_ = x[StyleColorTabUnfocusedActive-(38)]\n\t_ = x[StyleColorPlotLines-(42)]\n\t_ = x[StyleColorPlotLinesHovered-(43)]\n\t_ = x[StyleColorPlotHistogram-(44)]\n\t_ = x[StyleColorPlotHistogramHovered-(45)]\n\t_ = x[StyleColorTableHeaderBg-(46)]\n\t_ = x[StyleColorTableBorderStrong-(47)]\n\t_ = x[StyleColorTableBorderLight-(48)]\n\t_ = x[StyleColorTableRowBg-(49)]\n\t_ = x[StyleColorTableRowBgAlt-(50)]\n\t_ = x[StyleColorTextSelectedBg-(52)]\n\t_ = x[StyleColorDragDropTarget-(53)]\n\t_ = x[StyleColorNavHighlight-(55)]\n\t_ = x[StyleColorNavWindowingDimBg-(56)]\n\t_ = x[StyleColorModalWindowDimBg-(57)]\n}\n\nvar _StyleColorIDValues = []StyleColorID{StyleColorText, StyleColorTextDisabled, StyleColorWindowBg, StyleColorChildBg, StyleColorPopupBg, StyleColorBorder, StyleColorBorderShadow, StyleColorFrameBg, StyleColorFrameBgHovered, StyleColorFrameBgActive, StyleColorTitleBg, StyleColorTitleBgActive, StyleColorTitleBgCollapsed, StyleColorMenuBarBg, StyleColorScrollbarBg, StyleColorScrollbarGrab, StyleColorScrollbarGrabHovered, StyleColorScrollbarGrabActive, StyleColorCheckMark, StyleColorSliderGrab, StyleColorSliderGrabActive, StyleColorButton, StyleColorButtonHovered, StyleColorButtonActive, StyleColorHeader, StyleColorHeaderHovered, StyleColorHeaderActive, StyleColorSeparator, StyleColorSeparatorHovered, StyleColorSeparatorActive, StyleColorResizeGrip, StyleColorResizeGripHovered, StyleColorResizeGripActive, StyleColorTabHovered, StyleColorTab, StyleColorTabActive, StyleColorTabUnfocused, StyleColorTabUnfocusedActive, StyleColorPlotLines, StyleColorPlotLinesHovered, StyleColorPlotHistogram, StyleColorPlotHistogramHovered, StyleColorTableHeaderBg, StyleColorTableBorderStrong, StyleColorTableBorderLight, StyleColorTableRowBg, StyleColorTableRowBgAlt, StyleColorTextSelectedBg, StyleColorDragDropTarget, StyleColorNavHighlight, StyleColorNavWindowingDimBg, StyleColorModalWindowDimBg}\n\nvar _StyleColorIDNameToValueMap = map[string]StyleColorID{\n\t_StyleColorIDName_0[0:5]:          StyleColorText,\n\t_StyleColorIDLowerName_0[0:5]:     StyleColorText,\n\t_StyleColorIDName_0[5:19]:         StyleColorTextDisabled,\n\t_StyleColorIDLowerName_0[5:19]:    StyleColorTextDisabled,\n\t_StyleColorIDName_0[19:35]:        StyleColorWindowBg,\n\t_StyleColorIDLowerName_0[19:35]:   StyleColorWindowBg,\n\t_StyleColorIDName_0[35:57]:        StyleColorChildBg,\n\t_StyleColorIDLowerName_0[35:57]:   StyleColorChildBg,\n\t_StyleColorIDName_0[57:79]:        StyleColorPopupBg,\n\t_StyleColorIDLowerName_0[57:79]:   StyleColorPopupBg,\n\t_StyleColorIDName_0[79:91]:        StyleColorBorder,\n\t_StyleColorIDLowerName_0[79:91]:   StyleColorBorder,\n\t_StyleColorIDName_0[91:110]:       StyleColorBorderShadow,\n\t_StyleColorIDLowerName_0[91:110]:  StyleColorBorderShadow,\n\t_StyleColorIDName_0[110:132]:      StyleColorFrameBg,\n\t_StyleColorIDLowerName_0[110:132]: StyleColorFrameBg,\n\t_StyleColorIDName_0[132:162]:      StyleColorFrameBgHovered,\n\t_StyleColorIDLowerName_0[132:162]: StyleColorFrameBgHovered,\n\t_StyleColorIDName_0[162:191]:      StyleColorFrameBgActive,\n\t_StyleColorIDLowerName_0[162:191]: StyleColorFrameBgActive,\n\t_StyleColorIDName_0[191:213]:      StyleColorTitleBg,\n\t_StyleColorIDLowerName_0[191:213]: StyleColorTitleBg,\n\t_StyleColorIDName_0[213:242]:      StyleColorTitleBgActive,\n\t_StyleColorIDLowerName_0[213:242]: StyleColorTitleBgActive,\n\t_StyleColorIDName_0[242:274]:      StyleColorTitleBgCollapsed,\n\t_StyleColorIDLowerName_0[242:274]: StyleColorTitleBgCollapsed,\n\t_StyleColorIDName_0[274:299]:      StyleColorMenuBarBg,\n\t_StyleColorIDLowerName_0[274:299]: StyleColorMenuBarBg,\n\t_StyleColorIDName_0[299:325]:      StyleColorScrollbarBg,\n\t_StyleColorIDLowerName_0[299:325]: StyleColorScrollbarBg,\n\t_StyleColorIDName_0[325:345]:      StyleColorScrollbarGrab,\n\t_StyleColorIDLowerName_0[325:345]: StyleColorScrollbarGrab,\n\t_StyleColorIDName_0[345:373]:      StyleColorScrollbarGrabHovered,\n\t_StyleColorIDLowerName_0[345:373]: StyleColorScrollbarGrabHovered,\n\t_StyleColorIDName_0[373:400]:      StyleColorScrollbarGrabActive,\n\t_StyleColorIDLowerName_0[373:400]: StyleColorScrollbarGrabActive,\n\t_StyleColorIDName_0[400:415]:      StyleColorCheckMark,\n\t_StyleColorIDLowerName_0[400:415]: StyleColorCheckMark,\n\t_StyleColorIDName_0[415:432]:      StyleColorSliderGrab,\n\t_StyleColorIDLowerName_0[415:432]: StyleColorSliderGrab,\n\t_StyleColorIDName_0[432:456]:      StyleColorSliderGrabActive,\n\t_StyleColorIDLowerName_0[432:456]: StyleColorSliderGrabActive,\n\t_StyleColorIDName_0[456:468]:      StyleColorButton,\n\t_StyleColorIDLowerName_0[456:468]: StyleColorButton,\n\t_StyleColorIDName_0[468:488]:      StyleColorButtonHovered,\n\t_StyleColorIDLowerName_0[468:488]: StyleColorButtonHovered,\n\t_StyleColorIDName_0[488:507]:      StyleColorButtonActive,\n\t_StyleColorIDLowerName_0[488:507]: StyleColorButtonActive,\n\t_StyleColorIDName_0[507:519]:      StyleColorHeader,\n\t_StyleColorIDLowerName_0[507:519]: StyleColorHeader,\n\t_StyleColorIDName_0[519:539]:      StyleColorHeaderHovered,\n\t_StyleColorIDLowerName_0[519:539]: StyleColorHeaderHovered,\n\t_StyleColorIDName_0[539:558]:      StyleColorHeaderActive,\n\t_StyleColorIDLowerName_0[539:558]: StyleColorHeaderActive,\n\t_StyleColorIDName_0[558:573]:      StyleColorSeparator,\n\t_StyleColorIDLowerName_0[558:573]: StyleColorSeparator,\n\t_StyleColorIDName_0[573:596]:      StyleColorSeparatorHovered,\n\t_StyleColorIDLowerName_0[573:596]: StyleColorSeparatorHovered,\n\t_StyleColorIDName_0[596:618]:      StyleColorSeparatorActive,\n\t_StyleColorIDLowerName_0[596:618]: StyleColorSeparatorActive,\n\t_StyleColorIDName_0[618:635]:      StyleColorResizeGrip,\n\t_StyleColorIDLowerName_0[618:635]: StyleColorResizeGrip,\n\t_StyleColorIDName_0[635:660]:      StyleColorResizeGripHovered,\n\t_StyleColorIDLowerName_0[635:660]: StyleColorResizeGripHovered,\n\t_StyleColorIDName_0[660:684]:      StyleColorResizeGripActive,\n\t_StyleColorIDLowerName_0[660:684]: StyleColorResizeGripActive,\n\t_StyleColorIDName_0[684:701]:      StyleColorTabHovered,\n\t_StyleColorIDLowerName_0[684:701]: StyleColorTabHovered,\n\t_StyleColorIDName_0[701:710]:      StyleColorTab,\n\t_StyleColorIDLowerName_0[701:710]: StyleColorTab,\n\t_StyleColorIDName_0[710:726]:      StyleColorTabActive,\n\t_StyleColorIDLowerName_0[710:726]: StyleColorTabActive,\n\t_StyleColorIDName_1[0:19]:         StyleColorTabUnfocused,\n\t_StyleColorIDLowerName_1[0:19]:    StyleColorTabUnfocused,\n\t_StyleColorIDName_1[19:45]:        StyleColorTabUnfocusedActive,\n\t_StyleColorIDLowerName_1[19:45]:   StyleColorTabUnfocusedActive,\n\t_StyleColorIDName_2[0:16]:         StyleColorPlotLines,\n\t_StyleColorIDLowerName_2[0:16]:    StyleColorPlotLines,\n\t_StyleColorIDName_2[16:40]:        StyleColorPlotLinesHovered,\n\t_StyleColorIDLowerName_2[16:40]:   StyleColorPlotLinesHovered,\n\t_StyleColorIDName_2[40:60]:        StyleColorPlotHistogram,\n\t_StyleColorIDLowerName_2[40:60]:   StyleColorPlotHistogram,\n\t_StyleColorIDName_2[60:88]:        StyleColorPlotHistogramHovered,\n\t_StyleColorIDLowerName_2[60:88]:   StyleColorPlotHistogramHovered,\n\t_StyleColorIDName_2[88:117]:       StyleColorTableHeaderBg,\n\t_StyleColorIDLowerName_2[88:117]:  StyleColorTableHeaderBg,\n\t_StyleColorIDName_2[117:142]:      StyleColorTableBorderStrong,\n\t_StyleColorIDLowerName_2[117:142]: StyleColorTableBorderStrong,\n\t_StyleColorIDName_2[142:166]:      StyleColorTableBorderLight,\n\t_StyleColorIDLowerName_2[142:166]: StyleColorTableBorderLight,\n\t_StyleColorIDName_2[166:192]:      StyleColorTableRowBg,\n\t_StyleColorIDLowerName_2[166:192]: StyleColorTableRowBg,\n\t_StyleColorIDName_2[192:228]:      StyleColorTableRowBgAlt,\n\t_StyleColorIDLowerName_2[192:228]: StyleColorTableRowBgAlt,\n\t_StyleColorIDName_3[0:30]:         StyleColorTextSelectedBg,\n\t_StyleColorIDLowerName_3[0:30]:    StyleColorTextSelectedBg,\n\t_StyleColorIDName_3[30:52]:        StyleColorDragDropTarget,\n\t_StyleColorIDLowerName_3[30:52]:   StyleColorDragDropTarget,\n\t_StyleColorIDName_4[0:26]:         StyleColorNavHighlight,\n\t_StyleColorIDLowerName_4[0:26]:    StyleColorNavHighlight,\n\t_StyleColorIDName_4[26:56]:        StyleColorNavWindowingDimBg,\n\t_StyleColorIDLowerName_4[26:56]:   StyleColorNavWindowingDimBg,\n\t_StyleColorIDName_4[56:89]:        StyleColorModalWindowDimBg,\n\t_StyleColorIDLowerName_4[56:89]:   StyleColorModalWindowDimBg,\n}\n\nvar _StyleColorIDNames = []string{\n\t_StyleColorIDName_0[0:5],\n\t_StyleColorIDName_0[5:19],\n\t_StyleColorIDName_0[19:35],\n\t_StyleColorIDName_0[35:57],\n\t_StyleColorIDName_0[57:79],\n\t_StyleColorIDName_0[79:91],\n\t_StyleColorIDName_0[91:110],\n\t_StyleColorIDName_0[110:132],\n\t_StyleColorIDName_0[132:162],\n\t_StyleColorIDName_0[162:191],\n\t_StyleColorIDName_0[191:213],\n\t_StyleColorIDName_0[213:242],\n\t_StyleColorIDName_0[242:274],\n\t_StyleColorIDName_0[274:299],\n\t_StyleColorIDName_0[299:325],\n\t_StyleColorIDName_0[325:345],\n\t_StyleColorIDName_0[345:373],\n\t_StyleColorIDName_0[373:400],\n\t_StyleColorIDName_0[400:415],\n\t_StyleColorIDName_0[415:432],\n\t_StyleColorIDName_0[432:456],\n\t_StyleColorIDName_0[456:468],\n\t_StyleColorIDName_0[468:488],\n\t_StyleColorIDName_0[488:507],\n\t_StyleColorIDName_0[507:519],\n\t_StyleColorIDName_0[519:539],\n\t_StyleColorIDName_0[539:558],\n\t_StyleColorIDName_0[558:573],\n\t_StyleColorIDName_0[573:596],\n\t_StyleColorIDName_0[596:618],\n\t_StyleColorIDName_0[618:635],\n\t_StyleColorIDName_0[635:660],\n\t_StyleColorIDName_0[660:684],\n\t_StyleColorIDName_0[684:701],\n\t_StyleColorIDName_0[701:710],\n\t_StyleColorIDName_0[710:726],\n\t_StyleColorIDName_1[0:19],\n\t_StyleColorIDName_1[19:45],\n\t_StyleColorIDName_2[0:16],\n\t_StyleColorIDName_2[16:40],\n\t_StyleColorIDName_2[40:60],\n\t_StyleColorIDName_2[60:88],\n\t_StyleColorIDName_2[88:117],\n\t_StyleColorIDName_2[117:142],\n\t_StyleColorIDName_2[142:166],\n\t_StyleColorIDName_2[166:192],\n\t_StyleColorIDName_2[192:228],\n\t_StyleColorIDName_3[0:30],\n\t_StyleColorIDName_3[30:52],\n\t_StyleColorIDName_4[0:26],\n\t_StyleColorIDName_4[26:56],\n\t_StyleColorIDName_4[56:89],\n}\n\n// StyleColorIDString retrieves an enum value from the enum constants string name.\n// Throws an error if the param is not part of the enum.\nfunc StyleColorIDString(s string) (StyleColorID, error) {\n\tif val, ok := _StyleColorIDNameToValueMap[s]; ok {\n\t\treturn val, nil\n\t}\n\n\tif val, ok := _StyleColorIDNameToValueMap[strings.ToLower(s)]; ok {\n\t\treturn val, nil\n\t}\n\treturn 0, fmt.Errorf(\"%s does not belong to StyleColorID values\", s)\n}\n\n// StyleColorIDValues returns all values of the enum\nfunc StyleColorIDValues() []StyleColorID {\n\treturn _StyleColorIDValues\n}\n\n// StyleColorIDStrings returns a slice of all String values of the enum\nfunc StyleColorIDStrings() []string {\n\tstrs := make([]string, len(_StyleColorIDNames))\n\tcopy(strs, _StyleColorIDNames)\n\treturn strs\n}\n\n// IsAStyleColorID returns \"true\" if the value is listed in the enum definition. \"false\" otherwise\nfunc (i StyleColorID) IsAStyleColorID() bool {\n\tfor _, v := range _StyleColorIDValues {\n\t\tif i == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "styleplotcolorid_enumer.go",
          "type": "blob",
          "size": 7.0732421875,
          "content": "// Code generated by \"enumer -linecomment -type=StylePlotColorID .\"; DO NOT EDIT.\n\npackage giu\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nconst _StylePlotColorIDName = \"plot-lineplot-fillplot-marker-outlineplot-Marker-Fillplot-error-barplot-frame-bgplot-plot-bgplot-plot-borderplot-legend-bgplot-legend-borderplot-legend-textplot-title-textplot-inlay-textplot-axis-textplot-axis-gridplot-axis-tickplot-axis-bgplot-axis-bg-hoveredplot-axis-bg-activeplot-selectionplot-crosshairs\"\n\nvar _StylePlotColorIDIndex = [...]uint16{0, 9, 18, 37, 53, 67, 80, 92, 108, 122, 140, 156, 171, 186, 200, 214, 228, 240, 260, 279, 293, 308}\n\nconst _StylePlotColorIDLowerName = \"plot-lineplot-fillplot-marker-outlineplot-marker-fillplot-error-barplot-frame-bgplot-plot-bgplot-plot-borderplot-legend-bgplot-legend-borderplot-legend-textplot-title-textplot-inlay-textplot-axis-textplot-axis-gridplot-axis-tickplot-axis-bgplot-axis-bg-hoveredplot-axis-bg-activeplot-selectionplot-crosshairs\"\n\nfunc (i StylePlotColorID) String() string {\n\tif i < 0 || i >= StylePlotColorID(len(_StylePlotColorIDIndex)-1) {\n\t\treturn fmt.Sprintf(\"StylePlotColorID(%d)\", i)\n\t}\n\treturn _StylePlotColorIDName[_StylePlotColorIDIndex[i]:_StylePlotColorIDIndex[i+1]]\n}\n\n// An \"invalid array index\" compiler error signifies that the constant values have changed.\n// Re-run the stringer command to generate them again.\nfunc _StylePlotColorIDNoOp() {\n\tvar x [1]struct{}\n\t_ = x[StylePlotColorLine-(0)]\n\t_ = x[StylePlotColorFill-(1)]\n\t_ = x[StylePlotColorMarkerOutline-(2)]\n\t_ = x[StylePlotColorMarkerFill-(3)]\n\t_ = x[StylePlotColorErrorBar-(4)]\n\t_ = x[StylePlotColorFrameBg-(5)]\n\t_ = x[StylePlotColorPlotBg-(6)]\n\t_ = x[StylePlotColorPlotBorder-(7)]\n\t_ = x[StylePlotColorLegendBg-(8)]\n\t_ = x[StylePlotColorLegendBorder-(9)]\n\t_ = x[StylePlotColorLegendText-(10)]\n\t_ = x[StylePlotColorTitleText-(11)]\n\t_ = x[StylePlotColorInlayText-(12)]\n\t_ = x[StylePlotColorAxisText-(13)]\n\t_ = x[StylePlotColorAxisGrid-(14)]\n\t_ = x[StylePlotColorAxisTick-(15)]\n\t_ = x[StylePlotColorAxisBg-(16)]\n\t_ = x[StylePlotColorAxisBgHovered-(17)]\n\t_ = x[StylePlotColorAxisBgActive-(18)]\n\t_ = x[StylePlotColorSelection-(19)]\n\t_ = x[StylePlotColorCrosshairs-(20)]\n}\n\nvar _StylePlotColorIDValues = []StylePlotColorID{StylePlotColorLine, StylePlotColorFill, StylePlotColorMarkerOutline, StylePlotColorMarkerFill, StylePlotColorErrorBar, StylePlotColorFrameBg, StylePlotColorPlotBg, StylePlotColorPlotBorder, StylePlotColorLegendBg, StylePlotColorLegendBorder, StylePlotColorLegendText, StylePlotColorTitleText, StylePlotColorInlayText, StylePlotColorAxisText, StylePlotColorAxisGrid, StylePlotColorAxisTick, StylePlotColorAxisBg, StylePlotColorAxisBgHovered, StylePlotColorAxisBgActive, StylePlotColorSelection, StylePlotColorCrosshairs}\n\nvar _StylePlotColorIDNameToValueMap = map[string]StylePlotColorID{\n\t_StylePlotColorIDName[0:9]:          StylePlotColorLine,\n\t_StylePlotColorIDLowerName[0:9]:     StylePlotColorLine,\n\t_StylePlotColorIDName[9:18]:         StylePlotColorFill,\n\t_StylePlotColorIDLowerName[9:18]:    StylePlotColorFill,\n\t_StylePlotColorIDName[18:37]:        StylePlotColorMarkerOutline,\n\t_StylePlotColorIDLowerName[18:37]:   StylePlotColorMarkerOutline,\n\t_StylePlotColorIDName[37:53]:        StylePlotColorMarkerFill,\n\t_StylePlotColorIDLowerName[37:53]:   StylePlotColorMarkerFill,\n\t_StylePlotColorIDName[53:67]:        StylePlotColorErrorBar,\n\t_StylePlotColorIDLowerName[53:67]:   StylePlotColorErrorBar,\n\t_StylePlotColorIDName[67:80]:        StylePlotColorFrameBg,\n\t_StylePlotColorIDLowerName[67:80]:   StylePlotColorFrameBg,\n\t_StylePlotColorIDName[80:92]:        StylePlotColorPlotBg,\n\t_StylePlotColorIDLowerName[80:92]:   StylePlotColorPlotBg,\n\t_StylePlotColorIDName[92:108]:       StylePlotColorPlotBorder,\n\t_StylePlotColorIDLowerName[92:108]:  StylePlotColorPlotBorder,\n\t_StylePlotColorIDName[108:122]:      StylePlotColorLegendBg,\n\t_StylePlotColorIDLowerName[108:122]: StylePlotColorLegendBg,\n\t_StylePlotColorIDName[122:140]:      StylePlotColorLegendBorder,\n\t_StylePlotColorIDLowerName[122:140]: StylePlotColorLegendBorder,\n\t_StylePlotColorIDName[140:156]:      StylePlotColorLegendText,\n\t_StylePlotColorIDLowerName[140:156]: StylePlotColorLegendText,\n\t_StylePlotColorIDName[156:171]:      StylePlotColorTitleText,\n\t_StylePlotColorIDLowerName[156:171]: StylePlotColorTitleText,\n\t_StylePlotColorIDName[171:186]:      StylePlotColorInlayText,\n\t_StylePlotColorIDLowerName[171:186]: StylePlotColorInlayText,\n\t_StylePlotColorIDName[186:200]:      StylePlotColorAxisText,\n\t_StylePlotColorIDLowerName[186:200]: StylePlotColorAxisText,\n\t_StylePlotColorIDName[200:214]:      StylePlotColorAxisGrid,\n\t_StylePlotColorIDLowerName[200:214]: StylePlotColorAxisGrid,\n\t_StylePlotColorIDName[214:228]:      StylePlotColorAxisTick,\n\t_StylePlotColorIDLowerName[214:228]: StylePlotColorAxisTick,\n\t_StylePlotColorIDName[228:240]:      StylePlotColorAxisBg,\n\t_StylePlotColorIDLowerName[228:240]: StylePlotColorAxisBg,\n\t_StylePlotColorIDName[240:260]:      StylePlotColorAxisBgHovered,\n\t_StylePlotColorIDLowerName[240:260]: StylePlotColorAxisBgHovered,\n\t_StylePlotColorIDName[260:279]:      StylePlotColorAxisBgActive,\n\t_StylePlotColorIDLowerName[260:279]: StylePlotColorAxisBgActive,\n\t_StylePlotColorIDName[279:293]:      StylePlotColorSelection,\n\t_StylePlotColorIDLowerName[279:293]: StylePlotColorSelection,\n\t_StylePlotColorIDName[293:308]:      StylePlotColorCrosshairs,\n\t_StylePlotColorIDLowerName[293:308]: StylePlotColorCrosshairs,\n}\n\nvar _StylePlotColorIDNames = []string{\n\t_StylePlotColorIDName[0:9],\n\t_StylePlotColorIDName[9:18],\n\t_StylePlotColorIDName[18:37],\n\t_StylePlotColorIDName[37:53],\n\t_StylePlotColorIDName[53:67],\n\t_StylePlotColorIDName[67:80],\n\t_StylePlotColorIDName[80:92],\n\t_StylePlotColorIDName[92:108],\n\t_StylePlotColorIDName[108:122],\n\t_StylePlotColorIDName[122:140],\n\t_StylePlotColorIDName[140:156],\n\t_StylePlotColorIDName[156:171],\n\t_StylePlotColorIDName[171:186],\n\t_StylePlotColorIDName[186:200],\n\t_StylePlotColorIDName[200:214],\n\t_StylePlotColorIDName[214:228],\n\t_StylePlotColorIDName[228:240],\n\t_StylePlotColorIDName[240:260],\n\t_StylePlotColorIDName[260:279],\n\t_StylePlotColorIDName[279:293],\n\t_StylePlotColorIDName[293:308],\n}\n\n// StylePlotColorIDString retrieves an enum value from the enum constants string name.\n// Throws an error if the param is not part of the enum.\nfunc StylePlotColorIDString(s string) (StylePlotColorID, error) {\n\tif val, ok := _StylePlotColorIDNameToValueMap[s]; ok {\n\t\treturn val, nil\n\t}\n\n\tif val, ok := _StylePlotColorIDNameToValueMap[strings.ToLower(s)]; ok {\n\t\treturn val, nil\n\t}\n\treturn 0, fmt.Errorf(\"%s does not belong to StylePlotColorID values\", s)\n}\n\n// StylePlotColorIDValues returns all values of the enum\nfunc StylePlotColorIDValues() []StylePlotColorID {\n\treturn _StylePlotColorIDValues\n}\n\n// StylePlotColorIDStrings returns a slice of all String values of the enum\nfunc StylePlotColorIDStrings() []string {\n\tstrs := make([]string, len(_StylePlotColorIDNames))\n\tcopy(strs, _StylePlotColorIDNames)\n\treturn strs\n}\n\n// IsAStylePlotColorID returns \"true\" if the value is listed in the enum definition. \"false\" otherwise\nfunc (i StylePlotColorID) IsAStylePlotColorID() bool {\n\tfor _, v := range _StylePlotColorIDValues {\n\t\tif i == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "styleplotvarid_enumer.go",
          "type": "blob",
          "size": 8.9384765625,
          "content": "// Code generated by \"enumer -linecomment -type=StylePlotVarID .\"; DO NOT EDIT.\n\npackage giu\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nconst _StylePlotVarIDName = \"plot-line-weightplot-markerplot-marker-sizeplot-marker-weightplot-fill-alphaplot-error-bar-sizeplot-error-bar-weightplot-digital-bit-heightplot-digital-bit-gapplot-border-sizeplot-minor-alphaplot-major-tick-lenplot-minor-tick-lenplot-major-tick-sizeplot-minor-tick-sizeplot-major-grid-sizeplot-minor-grid-sizeplot-paddingplot-label-paddingplot-legend-paddingplot-legend-inner-paddingplot-legend-spacingplot-mouse-pos-paddingplot-annotation-paddingplot-fit-paddingplot-default-sizeplot-min-sizeStylePlotVarCOUNT\"\n\nvar _StylePlotVarIDIndex = [...]uint16{0, 16, 27, 43, 61, 76, 95, 116, 139, 159, 175, 191, 210, 229, 249, 269, 289, 309, 321, 339, 358, 383, 402, 424, 447, 463, 480, 493, 510}\n\nconst _StylePlotVarIDLowerName = \"plot-line-weightplot-markerplot-marker-sizeplot-marker-weightplot-fill-alphaplot-error-bar-sizeplot-error-bar-weightplot-digital-bit-heightplot-digital-bit-gapplot-border-sizeplot-minor-alphaplot-major-tick-lenplot-minor-tick-lenplot-major-tick-sizeplot-minor-tick-sizeplot-major-grid-sizeplot-minor-grid-sizeplot-paddingplot-label-paddingplot-legend-paddingplot-legend-inner-paddingplot-legend-spacingplot-mouse-pos-paddingplot-annotation-paddingplot-fit-paddingplot-default-sizeplot-min-sizestyleplotvarcount\"\n\nfunc (i StylePlotVarID) String() string {\n\tif i < 0 || i >= StylePlotVarID(len(_StylePlotVarIDIndex)-1) {\n\t\treturn fmt.Sprintf(\"StylePlotVarID(%d)\", i)\n\t}\n\treturn _StylePlotVarIDName[_StylePlotVarIDIndex[i]:_StylePlotVarIDIndex[i+1]]\n}\n\n// An \"invalid array index\" compiler error signifies that the constant values have changed.\n// Re-run the stringer command to generate them again.\nfunc _StylePlotVarIDNoOp() {\n\tvar x [1]struct{}\n\t_ = x[StylePlotVarLineWeight-(0)]\n\t_ = x[StylePlotVarMarker-(1)]\n\t_ = x[StylePlotVarMarkerSize-(2)]\n\t_ = x[StylePlotVarMarkerWeight-(3)]\n\t_ = x[StylePlotVarFillAlpha-(4)]\n\t_ = x[StylePlotVarErrorBarSize-(5)]\n\t_ = x[StylePlotVarErrorBarWeight-(6)]\n\t_ = x[StylePlotVarDigitalBitHeight-(7)]\n\t_ = x[StylePlotVarDigitalBitGap-(8)]\n\t_ = x[StylePlotVarPlotBorderSize-(9)]\n\t_ = x[StylePlotVarMinorAlpha-(10)]\n\t_ = x[StylePlotVarMajorTickLen-(11)]\n\t_ = x[StylePlotVarMinorTickLen-(12)]\n\t_ = x[StylePlotVarMajorTickSize-(13)]\n\t_ = x[StylePlotVarMinorTickSize-(14)]\n\t_ = x[StylePlotVarMajorGridSize-(15)]\n\t_ = x[StylePlotVarMinorGridSize-(16)]\n\t_ = x[StylePlotVarPlotPadding-(17)]\n\t_ = x[StylePlotVarLabelPadding-(18)]\n\t_ = x[StylePlotVarLegendPadding-(19)]\n\t_ = x[StylePlotVarLegendInnerPadding-(20)]\n\t_ = x[StylePlotVarLegendSpacing-(21)]\n\t_ = x[StylePlotVarMousePosPadding-(22)]\n\t_ = x[StylePlotVarAnnotationPadding-(23)]\n\t_ = x[StylePlotVarFitPadding-(24)]\n\t_ = x[StylePlotVarPlotDefaultSize-(25)]\n\t_ = x[StylePlotVarPlotMinSize-(26)]\n\t_ = x[StylePlotVarCOUNT-(27)]\n}\n\nvar _StylePlotVarIDValues = []StylePlotVarID{StylePlotVarLineWeight, StylePlotVarMarker, StylePlotVarMarkerSize, StylePlotVarMarkerWeight, StylePlotVarFillAlpha, StylePlotVarErrorBarSize, StylePlotVarErrorBarWeight, StylePlotVarDigitalBitHeight, StylePlotVarDigitalBitGap, StylePlotVarPlotBorderSize, StylePlotVarMinorAlpha, StylePlotVarMajorTickLen, StylePlotVarMinorTickLen, StylePlotVarMajorTickSize, StylePlotVarMinorTickSize, StylePlotVarMajorGridSize, StylePlotVarMinorGridSize, StylePlotVarPlotPadding, StylePlotVarLabelPadding, StylePlotVarLegendPadding, StylePlotVarLegendInnerPadding, StylePlotVarLegendSpacing, StylePlotVarMousePosPadding, StylePlotVarAnnotationPadding, StylePlotVarFitPadding, StylePlotVarPlotDefaultSize, StylePlotVarPlotMinSize, StylePlotVarCOUNT}\n\nvar _StylePlotVarIDNameToValueMap = map[string]StylePlotVarID{\n\t_StylePlotVarIDName[0:16]:         StylePlotVarLineWeight,\n\t_StylePlotVarIDLowerName[0:16]:    StylePlotVarLineWeight,\n\t_StylePlotVarIDName[16:27]:        StylePlotVarMarker,\n\t_StylePlotVarIDLowerName[16:27]:   StylePlotVarMarker,\n\t_StylePlotVarIDName[27:43]:        StylePlotVarMarkerSize,\n\t_StylePlotVarIDLowerName[27:43]:   StylePlotVarMarkerSize,\n\t_StylePlotVarIDName[43:61]:        StylePlotVarMarkerWeight,\n\t_StylePlotVarIDLowerName[43:61]:   StylePlotVarMarkerWeight,\n\t_StylePlotVarIDName[61:76]:        StylePlotVarFillAlpha,\n\t_StylePlotVarIDLowerName[61:76]:   StylePlotVarFillAlpha,\n\t_StylePlotVarIDName[76:95]:        StylePlotVarErrorBarSize,\n\t_StylePlotVarIDLowerName[76:95]:   StylePlotVarErrorBarSize,\n\t_StylePlotVarIDName[95:116]:       StylePlotVarErrorBarWeight,\n\t_StylePlotVarIDLowerName[95:116]:  StylePlotVarErrorBarWeight,\n\t_StylePlotVarIDName[116:139]:      StylePlotVarDigitalBitHeight,\n\t_StylePlotVarIDLowerName[116:139]: StylePlotVarDigitalBitHeight,\n\t_StylePlotVarIDName[139:159]:      StylePlotVarDigitalBitGap,\n\t_StylePlotVarIDLowerName[139:159]: StylePlotVarDigitalBitGap,\n\t_StylePlotVarIDName[159:175]:      StylePlotVarPlotBorderSize,\n\t_StylePlotVarIDLowerName[159:175]: StylePlotVarPlotBorderSize,\n\t_StylePlotVarIDName[175:191]:      StylePlotVarMinorAlpha,\n\t_StylePlotVarIDLowerName[175:191]: StylePlotVarMinorAlpha,\n\t_StylePlotVarIDName[191:210]:      StylePlotVarMajorTickLen,\n\t_StylePlotVarIDLowerName[191:210]: StylePlotVarMajorTickLen,\n\t_StylePlotVarIDName[210:229]:      StylePlotVarMinorTickLen,\n\t_StylePlotVarIDLowerName[210:229]: StylePlotVarMinorTickLen,\n\t_StylePlotVarIDName[229:249]:      StylePlotVarMajorTickSize,\n\t_StylePlotVarIDLowerName[229:249]: StylePlotVarMajorTickSize,\n\t_StylePlotVarIDName[249:269]:      StylePlotVarMinorTickSize,\n\t_StylePlotVarIDLowerName[249:269]: StylePlotVarMinorTickSize,\n\t_StylePlotVarIDName[269:289]:      StylePlotVarMajorGridSize,\n\t_StylePlotVarIDLowerName[269:289]: StylePlotVarMajorGridSize,\n\t_StylePlotVarIDName[289:309]:      StylePlotVarMinorGridSize,\n\t_StylePlotVarIDLowerName[289:309]: StylePlotVarMinorGridSize,\n\t_StylePlotVarIDName[309:321]:      StylePlotVarPlotPadding,\n\t_StylePlotVarIDLowerName[309:321]: StylePlotVarPlotPadding,\n\t_StylePlotVarIDName[321:339]:      StylePlotVarLabelPadding,\n\t_StylePlotVarIDLowerName[321:339]: StylePlotVarLabelPadding,\n\t_StylePlotVarIDName[339:358]:      StylePlotVarLegendPadding,\n\t_StylePlotVarIDLowerName[339:358]: StylePlotVarLegendPadding,\n\t_StylePlotVarIDName[358:383]:      StylePlotVarLegendInnerPadding,\n\t_StylePlotVarIDLowerName[358:383]: StylePlotVarLegendInnerPadding,\n\t_StylePlotVarIDName[383:402]:      StylePlotVarLegendSpacing,\n\t_StylePlotVarIDLowerName[383:402]: StylePlotVarLegendSpacing,\n\t_StylePlotVarIDName[402:424]:      StylePlotVarMousePosPadding,\n\t_StylePlotVarIDLowerName[402:424]: StylePlotVarMousePosPadding,\n\t_StylePlotVarIDName[424:447]:      StylePlotVarAnnotationPadding,\n\t_StylePlotVarIDLowerName[424:447]: StylePlotVarAnnotationPadding,\n\t_StylePlotVarIDName[447:463]:      StylePlotVarFitPadding,\n\t_StylePlotVarIDLowerName[447:463]: StylePlotVarFitPadding,\n\t_StylePlotVarIDName[463:480]:      StylePlotVarPlotDefaultSize,\n\t_StylePlotVarIDLowerName[463:480]: StylePlotVarPlotDefaultSize,\n\t_StylePlotVarIDName[480:493]:      StylePlotVarPlotMinSize,\n\t_StylePlotVarIDLowerName[480:493]: StylePlotVarPlotMinSize,\n\t_StylePlotVarIDName[493:510]:      StylePlotVarCOUNT,\n\t_StylePlotVarIDLowerName[493:510]: StylePlotVarCOUNT,\n}\n\nvar _StylePlotVarIDNames = []string{\n\t_StylePlotVarIDName[0:16],\n\t_StylePlotVarIDName[16:27],\n\t_StylePlotVarIDName[27:43],\n\t_StylePlotVarIDName[43:61],\n\t_StylePlotVarIDName[61:76],\n\t_StylePlotVarIDName[76:95],\n\t_StylePlotVarIDName[95:116],\n\t_StylePlotVarIDName[116:139],\n\t_StylePlotVarIDName[139:159],\n\t_StylePlotVarIDName[159:175],\n\t_StylePlotVarIDName[175:191],\n\t_StylePlotVarIDName[191:210],\n\t_StylePlotVarIDName[210:229],\n\t_StylePlotVarIDName[229:249],\n\t_StylePlotVarIDName[249:269],\n\t_StylePlotVarIDName[269:289],\n\t_StylePlotVarIDName[289:309],\n\t_StylePlotVarIDName[309:321],\n\t_StylePlotVarIDName[321:339],\n\t_StylePlotVarIDName[339:358],\n\t_StylePlotVarIDName[358:383],\n\t_StylePlotVarIDName[383:402],\n\t_StylePlotVarIDName[402:424],\n\t_StylePlotVarIDName[424:447],\n\t_StylePlotVarIDName[447:463],\n\t_StylePlotVarIDName[463:480],\n\t_StylePlotVarIDName[480:493],\n\t_StylePlotVarIDName[493:510],\n}\n\n// StylePlotVarIDString retrieves an enum value from the enum constants string name.\n// Throws an error if the param is not part of the enum.\nfunc StylePlotVarIDString(s string) (StylePlotVarID, error) {\n\tif val, ok := _StylePlotVarIDNameToValueMap[s]; ok {\n\t\treturn val, nil\n\t}\n\n\tif val, ok := _StylePlotVarIDNameToValueMap[strings.ToLower(s)]; ok {\n\t\treturn val, nil\n\t}\n\treturn 0, fmt.Errorf(\"%s does not belong to StylePlotVarID values\", s)\n}\n\n// StylePlotVarIDValues returns all values of the enum\nfunc StylePlotVarIDValues() []StylePlotVarID {\n\treturn _StylePlotVarIDValues\n}\n\n// StylePlotVarIDStrings returns a slice of all String values of the enum\nfunc StylePlotVarIDStrings() []string {\n\tstrs := make([]string, len(_StylePlotVarIDNames))\n\tcopy(strs, _StylePlotVarIDNames)\n\treturn strs\n}\n\n// IsAStylePlotVarID returns \"true\" if the value is listed in the enum definition. \"false\" otherwise\nfunc (i StylePlotVarID) IsAStylePlotVarID() bool {\n\tfor _, v := range _StylePlotVarIDValues {\n\t\tif i == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "stylevarid_enumer.go",
          "type": "blob",
          "size": 9.2001953125,
          "content": "// Code generated by \"enumer -linecomment -type=StyleVarID .\"; DO NOT EDIT.\n\npackage giu\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nconst (\n\t_StyleVarIDName_0      = \"alphadisabled-alphawindow-paddingwindow-roundingwindow-border-sizewindow-minValue-sizewindow-title-alignchild-roundingchild-border-sizepopup-roundingpopup-border-sizeframe-paddingframe-roundingframe-border-sizeitem-spacingitem-inner-spacingindent-spacingStyleVarCellPaddingscrollbar-sizescrollbar-roundinggrab-minValue-sizegrab-roundingtab-rounding\"\n\t_StyleVarIDLowerName_0 = \"alphadisabled-alphawindow-paddingwindow-roundingwindow-border-sizewindow-minvalue-sizewindow-title-alignchild-roundingchild-border-sizepopup-roundingpopup-border-sizeframe-paddingframe-roundingframe-border-sizeitem-spacingitem-inner-spacingindent-spacingstylevarcellpaddingscrollbar-sizescrollbar-roundinggrab-minvalue-sizegrab-roundingtab-rounding\"\n\t_StyleVarIDName_1      = \"StyleVarTabBarBorderSize\"\n\t_StyleVarIDLowerName_1 = \"stylevartabbarbordersize\"\n\t_StyleVarIDName_2      = \"button-text-alignselectable-text-alignStyleVarSeparatorTextBorderSizeStyleVarSeparatorTextAlignStyleVarSeparatorTextPaddingStyleVarDockingSeparatorSize\"\n\t_StyleVarIDLowerName_2 = \"button-text-alignselectable-text-alignstylevarseparatortextbordersizestylevarseparatortextalignstylevarseparatortextpaddingstylevardockingseparatorsize\"\n)\n\nvar (\n\t_StyleVarIDIndex_0 = [...]uint16{0, 5, 19, 33, 48, 66, 86, 104, 118, 135, 149, 166, 179, 193, 210, 222, 240, 254, 273, 287, 305, 323, 336, 348}\n\t_StyleVarIDIndex_1 = [...]uint8{0, 24}\n\t_StyleVarIDIndex_2 = [...]uint8{0, 17, 38, 69, 95, 123, 151}\n)\n\nfunc (i StyleVarID) String() string {\n\tswitch {\n\tcase 0 <= i && i <= 22:\n\t\treturn _StyleVarIDName_0[_StyleVarIDIndex_0[i]:_StyleVarIDIndex_0[i+1]]\n\tcase i == 24:\n\t\treturn _StyleVarIDName_1\n\tcase 28 <= i && i <= 33:\n\t\ti -= 28\n\t\treturn _StyleVarIDName_2[_StyleVarIDIndex_2[i]:_StyleVarIDIndex_2[i+1]]\n\tdefault:\n\t\treturn fmt.Sprintf(\"StyleVarID(%d)\", i)\n\t}\n}\n\n// An \"invalid array index\" compiler error signifies that the constant values have changed.\n// Re-run the stringer command to generate them again.\nfunc _StyleVarIDNoOp() {\n\tvar x [1]struct{}\n\t_ = x[StyleVarAlpha-(0)]\n\t_ = x[StyleVarDisabledAlpha-(1)]\n\t_ = x[StyleVarWindowPadding-(2)]\n\t_ = x[StyleVarWindowRounding-(3)]\n\t_ = x[StyleVarWindowBorderSize-(4)]\n\t_ = x[StyleVarWindowMinSize-(5)]\n\t_ = x[StyleVarWindowTitleAlign-(6)]\n\t_ = x[StyleVarChildRounding-(7)]\n\t_ = x[StyleVarChildBorderSize-(8)]\n\t_ = x[StyleVarPopupRounding-(9)]\n\t_ = x[StyleVarPopupBorderSize-(10)]\n\t_ = x[StyleVarFramePadding-(11)]\n\t_ = x[StyleVarFrameRounding-(12)]\n\t_ = x[StyleVarFrameBorderSize-(13)]\n\t_ = x[StyleVarItemSpacing-(14)]\n\t_ = x[StyleVarItemInnerSpacing-(15)]\n\t_ = x[StyleVarIndentSpacing-(16)]\n\t_ = x[StyleVarCellPadding-(17)]\n\t_ = x[StyleVarScrollbarSize-(18)]\n\t_ = x[StyleVarScrollbarRounding-(19)]\n\t_ = x[StyleVarGrabMinSize-(20)]\n\t_ = x[StyleVarGrabRounding-(21)]\n\t_ = x[StyleVarTabRounding-(22)]\n\t_ = x[StyleVarTabBarBorderSize-(24)]\n\t_ = x[StyleVarButtonTextAlign-(28)]\n\t_ = x[StyleVarSelectableTextAlign-(29)]\n\t_ = x[StyleVarSeparatorTextBorderSize-(30)]\n\t_ = x[StyleVarSeparatorTextAlign-(31)]\n\t_ = x[StyleVarSeparatorTextPadding-(32)]\n\t_ = x[StyleVarDockingSeparatorSize-(33)]\n}\n\nvar _StyleVarIDValues = []StyleVarID{StyleVarAlpha, StyleVarDisabledAlpha, StyleVarWindowPadding, StyleVarWindowRounding, StyleVarWindowBorderSize, StyleVarWindowMinSize, StyleVarWindowTitleAlign, StyleVarChildRounding, StyleVarChildBorderSize, StyleVarPopupRounding, StyleVarPopupBorderSize, StyleVarFramePadding, StyleVarFrameRounding, StyleVarFrameBorderSize, StyleVarItemSpacing, StyleVarItemInnerSpacing, StyleVarIndentSpacing, StyleVarCellPadding, StyleVarScrollbarSize, StyleVarScrollbarRounding, StyleVarGrabMinSize, StyleVarGrabRounding, StyleVarTabRounding, StyleVarTabBarBorderSize, StyleVarButtonTextAlign, StyleVarSelectableTextAlign, StyleVarSeparatorTextBorderSize, StyleVarSeparatorTextAlign, StyleVarSeparatorTextPadding, StyleVarDockingSeparatorSize}\n\nvar _StyleVarIDNameToValueMap = map[string]StyleVarID{\n\t_StyleVarIDName_0[0:5]:          StyleVarAlpha,\n\t_StyleVarIDLowerName_0[0:5]:     StyleVarAlpha,\n\t_StyleVarIDName_0[5:19]:         StyleVarDisabledAlpha,\n\t_StyleVarIDLowerName_0[5:19]:    StyleVarDisabledAlpha,\n\t_StyleVarIDName_0[19:33]:        StyleVarWindowPadding,\n\t_StyleVarIDLowerName_0[19:33]:   StyleVarWindowPadding,\n\t_StyleVarIDName_0[33:48]:        StyleVarWindowRounding,\n\t_StyleVarIDLowerName_0[33:48]:   StyleVarWindowRounding,\n\t_StyleVarIDName_0[48:66]:        StyleVarWindowBorderSize,\n\t_StyleVarIDLowerName_0[48:66]:   StyleVarWindowBorderSize,\n\t_StyleVarIDName_0[66:86]:        StyleVarWindowMinSize,\n\t_StyleVarIDLowerName_0[66:86]:   StyleVarWindowMinSize,\n\t_StyleVarIDName_0[86:104]:       StyleVarWindowTitleAlign,\n\t_StyleVarIDLowerName_0[86:104]:  StyleVarWindowTitleAlign,\n\t_StyleVarIDName_0[104:118]:      StyleVarChildRounding,\n\t_StyleVarIDLowerName_0[104:118]: StyleVarChildRounding,\n\t_StyleVarIDName_0[118:135]:      StyleVarChildBorderSize,\n\t_StyleVarIDLowerName_0[118:135]: StyleVarChildBorderSize,\n\t_StyleVarIDName_0[135:149]:      StyleVarPopupRounding,\n\t_StyleVarIDLowerName_0[135:149]: StyleVarPopupRounding,\n\t_StyleVarIDName_0[149:166]:      StyleVarPopupBorderSize,\n\t_StyleVarIDLowerName_0[149:166]: StyleVarPopupBorderSize,\n\t_StyleVarIDName_0[166:179]:      StyleVarFramePadding,\n\t_StyleVarIDLowerName_0[166:179]: StyleVarFramePadding,\n\t_StyleVarIDName_0[179:193]:      StyleVarFrameRounding,\n\t_StyleVarIDLowerName_0[179:193]: StyleVarFrameRounding,\n\t_StyleVarIDName_0[193:210]:      StyleVarFrameBorderSize,\n\t_StyleVarIDLowerName_0[193:210]: StyleVarFrameBorderSize,\n\t_StyleVarIDName_0[210:222]:      StyleVarItemSpacing,\n\t_StyleVarIDLowerName_0[210:222]: StyleVarItemSpacing,\n\t_StyleVarIDName_0[222:240]:      StyleVarItemInnerSpacing,\n\t_StyleVarIDLowerName_0[222:240]: StyleVarItemInnerSpacing,\n\t_StyleVarIDName_0[240:254]:      StyleVarIndentSpacing,\n\t_StyleVarIDLowerName_0[240:254]: StyleVarIndentSpacing,\n\t_StyleVarIDName_0[254:273]:      StyleVarCellPadding,\n\t_StyleVarIDLowerName_0[254:273]: StyleVarCellPadding,\n\t_StyleVarIDName_0[273:287]:      StyleVarScrollbarSize,\n\t_StyleVarIDLowerName_0[273:287]: StyleVarScrollbarSize,\n\t_StyleVarIDName_0[287:305]:      StyleVarScrollbarRounding,\n\t_StyleVarIDLowerName_0[287:305]: StyleVarScrollbarRounding,\n\t_StyleVarIDName_0[305:323]:      StyleVarGrabMinSize,\n\t_StyleVarIDLowerName_0[305:323]: StyleVarGrabMinSize,\n\t_StyleVarIDName_0[323:336]:      StyleVarGrabRounding,\n\t_StyleVarIDLowerName_0[323:336]: StyleVarGrabRounding,\n\t_StyleVarIDName_0[336:348]:      StyleVarTabRounding,\n\t_StyleVarIDLowerName_0[336:348]: StyleVarTabRounding,\n\t_StyleVarIDName_1[0:24]:         StyleVarTabBarBorderSize,\n\t_StyleVarIDLowerName_1[0:24]:    StyleVarTabBarBorderSize,\n\t_StyleVarIDName_2[0:17]:         StyleVarButtonTextAlign,\n\t_StyleVarIDLowerName_2[0:17]:    StyleVarButtonTextAlign,\n\t_StyleVarIDName_2[17:38]:        StyleVarSelectableTextAlign,\n\t_StyleVarIDLowerName_2[17:38]:   StyleVarSelectableTextAlign,\n\t_StyleVarIDName_2[38:69]:        StyleVarSeparatorTextBorderSize,\n\t_StyleVarIDLowerName_2[38:69]:   StyleVarSeparatorTextBorderSize,\n\t_StyleVarIDName_2[69:95]:        StyleVarSeparatorTextAlign,\n\t_StyleVarIDLowerName_2[69:95]:   StyleVarSeparatorTextAlign,\n\t_StyleVarIDName_2[95:123]:       StyleVarSeparatorTextPadding,\n\t_StyleVarIDLowerName_2[95:123]:  StyleVarSeparatorTextPadding,\n\t_StyleVarIDName_2[123:151]:      StyleVarDockingSeparatorSize,\n\t_StyleVarIDLowerName_2[123:151]: StyleVarDockingSeparatorSize,\n}\n\nvar _StyleVarIDNames = []string{\n\t_StyleVarIDName_0[0:5],\n\t_StyleVarIDName_0[5:19],\n\t_StyleVarIDName_0[19:33],\n\t_StyleVarIDName_0[33:48],\n\t_StyleVarIDName_0[48:66],\n\t_StyleVarIDName_0[66:86],\n\t_StyleVarIDName_0[86:104],\n\t_StyleVarIDName_0[104:118],\n\t_StyleVarIDName_0[118:135],\n\t_StyleVarIDName_0[135:149],\n\t_StyleVarIDName_0[149:166],\n\t_StyleVarIDName_0[166:179],\n\t_StyleVarIDName_0[179:193],\n\t_StyleVarIDName_0[193:210],\n\t_StyleVarIDName_0[210:222],\n\t_StyleVarIDName_0[222:240],\n\t_StyleVarIDName_0[240:254],\n\t_StyleVarIDName_0[254:273],\n\t_StyleVarIDName_0[273:287],\n\t_StyleVarIDName_0[287:305],\n\t_StyleVarIDName_0[305:323],\n\t_StyleVarIDName_0[323:336],\n\t_StyleVarIDName_0[336:348],\n\t_StyleVarIDName_1[0:24],\n\t_StyleVarIDName_2[0:17],\n\t_StyleVarIDName_2[17:38],\n\t_StyleVarIDName_2[38:69],\n\t_StyleVarIDName_2[69:95],\n\t_StyleVarIDName_2[95:123],\n\t_StyleVarIDName_2[123:151],\n}\n\n// StyleVarIDString retrieves an enum value from the enum constants string name.\n// Throws an error if the param is not part of the enum.\nfunc StyleVarIDString(s string) (StyleVarID, error) {\n\tif val, ok := _StyleVarIDNameToValueMap[s]; ok {\n\t\treturn val, nil\n\t}\n\n\tif val, ok := _StyleVarIDNameToValueMap[strings.ToLower(s)]; ok {\n\t\treturn val, nil\n\t}\n\treturn 0, fmt.Errorf(\"%s does not belong to StyleVarID values\", s)\n}\n\n// StyleVarIDValues returns all values of the enum\nfunc StyleVarIDValues() []StyleVarID {\n\treturn _StyleVarIDValues\n}\n\n// StyleVarIDStrings returns a slice of all String values of the enum\nfunc StyleVarIDStrings() []string {\n\tstrs := make([]string, len(_StyleVarIDNames))\n\tcopy(strs, _StyleVarIDNames)\n\treturn strs\n}\n\n// IsAStyleVarID returns \"true\" if the value is listed in the enum definition. \"false\" otherwise\nfunc (i StyleVarID) IsAStyleVarID() bool {\n\tfor _, v := range _StyleVarIDValues {\n\t\tif i == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "surfacestate_string.go",
          "type": "blob",
          "size": 0.78515625,
          "content": "// Code generated by \"stringer -type=SurfaceState\"; DO NOT EDIT.\n\npackage giu\n\nimport \"strconv\"\n\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[SurfaceStateNone-0]\n\t_ = x[SurfaceStateLoading-1]\n\t_ = x[SurfaceStateFailure-2]\n\t_ = x[SurfaceStateSuccess-3]\n}\n\nconst _SurfaceState_name = \"SurfaceStateNoneSurfaceStateLoadingSurfaceStateFailureSurfaceStateSuccess\"\n\nvar _SurfaceState_index = [...]uint8{0, 16, 35, 54, 73}\n\nfunc (i SurfaceState) String() string {\n\tif i < 0 || i >= SurfaceState(len(_SurfaceState_index)-1) {\n\t\treturn \"SurfaceState(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _SurfaceState_name[_SurfaceState_index[i]:_SurfaceState_index[i+1]]\n}\n"
        }
      ]
    }
  ]
}