{
  "metadata": {
    "timestamp": 1736566672458,
    "page": 226,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fanpei91/torsniff",
      "stars": 3980,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3056640625,
          "content": "# Binaries for programs and plugins\n*.exe\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n.glide/\ntorsniff\n.idea\nreleases\n.DS_Store\nbin\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 fanpei91@gmail.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README-zh.md",
          "type": "blob",
          "size": 1.947265625,
          "content": "torsniff - 一个 BitTorrent 网络种子嗅探器\n======================================\n\n**简体中文** | [English](./README.md)\n\n## 介绍\n\ntorsniff 是一个种子嗅探器，它从 BitTorrent 网络获取人们下载音乐、电影、游戏、文档等等时所用的种子。\n\n种子含有可用的信息，所以你可用 torsniff 打造属于自己的私人种子库（比如：海盗湾），或者做数据挖掘与分析。\n\n## 安装\n\n直接从 [releases](https://github.com/fanpei91/torsniff/releases) 下载最新版即可. \n\n## 用法\n\n```\n$ ./torsniff -h\n\nUsage:\n  torsniff [flags]\n\nFlags:\n  -a, --addr string        listen on given address (default all, ipv4 and ipv6)\n  -d, --dir string         the directory to store the torrents (default \"$HOME/torrents\")\n  -h, --help               help for torsniff\n  -f, --friends int        max fiends to make with per second (default 500)\n  -e, --peers int          max peers to connect to download torrents (default 400)\n  -p, --port uint16        listen on given port (default 6881)\n  -t, --timeout duration   max time allowed for downloading torrents (default 10s)\n  -v, --verbose            run in verbose mode (default true)\n```\n\n## 快速开始\n使用默认参数:\n\n`./torsniff`\n\n种子默认保存在 `$HOME/torrents` 目录里。\n\n## 环境要求\n* 需要一个有公网 IP 的主机（推荐，最好是国外），如果想在私有内网、NAT 内的主机上运行，需要配置端口转发、映射。\n* 允许 UDP 流量通过防火墙\n* 你的 ISP/主机商允许 BitTorrent 流量（torsniff 在 [vultr.com](https://www.vultr.com/?ref=7172229) 能良好运行）\n\n## 协议\n- [DHT Protocol](http://www.bittorrent.org/beps/bep_0005.html)\n- [The BitTorrent Protocol Specification](http://www.bittorrent.org/beps/bep_0003.html)\n- [BitTorrent  Extension Protocol](http://www.bittorrent.org/beps/bep_0010.html)\n- [Extension for Peers to Send Metadata Files](http://www.bittorrent.org/beps/bep_0009.html)\n\n## 许可证\nMIT\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.8837890625,
          "content": "torsniff - a sniffer that sniffs torrents from BitTorrent network\n======================================\n\n\n**English** | [简体中文](./README-zh.md)\n\n## Introduction\ntorsniff is a torrent sniffer, it sniffs torrents that people are using to download movies, music, docs, games and so on from BitTorrent network.\n\nA torrent has valuable information, so you can use torsniff to build your own torrent database(e.g: The Pirate Bay), or to do data mining and analyzing.\n\n\n## Installation\n\nJust download latest torsniff from [releases](https://github.com/fanpei91/torsniff/releases) directly. \n\n## Usage\n\n```\n$ ./torsniff -h\n\nUsage:\n  torsniff [flags]\n\nFlags:\n  -a, --addr string        listen on given address (default all, ipv4 and ipv6)\n  -d, --dir string         the directory to store the torrents (default \"$HOME/torrents\")\n  -h, --help               help for torsniff\n  -f, --friends int        max fiends to make with per second (default 500)\n  -e, --peers int          max peers to connect to download torrents (default 400)\n  -p, --port uint16        listen on given port (default 6881)\n  -t, --timeout duration   max time allowed for downloading torrents (default 10s)\n  -v, --verbose            run in verbose mode (default true)\n```\n\n## Quick start\nUse default flags:\n\n`./torsniff`\n\n## Requirements\n\n* A host having a public IP(recommended), or UDP port forwarding/port mapping in private network/NAT\n* Allow UDP traffic get through firewall\n* Your ISP/Hosting Provider allows BitTorrent traffic(torsniff works on [vultr.com](https://www.vultr.com/?ref=7172229))\n\n## Protocols\n- [DHT Protocol](http://www.bittorrent.org/beps/bep_0005.html)\n- [The BitTorrent Protocol Specification](http://www.bittorrent.org/beps/bep_0003.html)\n- [BitTorrent  Extension Protocol](http://www.bittorrent.org/beps/bep_0010.html)\n- [Extension for Peers to Send Metadata Files](http://www.bittorrent.org/beps/bep_0009.html)\n\n## License\nMIT\n"
        },
        {
          "name": "blacklist.go",
          "type": "blob",
          "size": 1.3173828125,
          "content": "package main\n\nimport (\n\t\"container/list\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype entry struct {\n\taddr  string\n\tctime time.Time\n}\n\ntype blackList struct {\n\tmu           sync.Mutex\n\tll           *list.List\n\tcache        map[string]*list.Element\n\texpiredAfter time.Duration\n\tlimit        int\n}\n\nfunc newBlackList(expiredAfter time.Duration, limit int) *blackList {\n\treturn &blackList{\n\t\tll:           list.New(),\n\t\tcache:        make(map[string]*list.Element),\n\t\texpiredAfter: expiredAfter,\n\t\tlimit:        limit,\n\t}\n}\n\nfunc (b *blackList) add(addr string) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tb.removeExpiredLocked()\n\n\tif b.ll.Len() >= b.limit {\n\t\treturn\n\t}\n\n\tif _, ok := b.cache[addr]; !ok {\n\t\te := b.ll.PushBack(&entry{\n\t\t\taddr:  addr,\n\t\t\tctime: time.Now(),\n\t\t})\n\t\tb.cache[addr] = e\n\t}\n}\n\nfunc (b *blackList) has(addr string) bool {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tif elem := b.cache[addr]; elem != nil {\n\t\te := elem.Value.(*entry)\n\t\tif time.Now().Sub(e.ctime) < b.expiredAfter {\n\t\t\treturn true\n\t\t}\n\t\tb.ll.Remove(elem)\n\t\tdelete(b.cache, e.addr)\n\t}\n\n\treturn false\n}\n\nfunc (b *blackList) removeExpiredLocked() {\n\tnow := time.Now()\n\tvar next *list.Element\n\tfor elem := b.ll.Front(); elem != nil; elem = next {\n\t\tnext = elem.Next()\n\t\te := elem.Value.(*entry)\n\t\tif now.Sub(e.ctime) < b.expiredAfter {\n\t\t\tbreak\n\t\t}\n\t\tb.ll.Remove(elem)\n\t\tdelete(b.cache, e.addr)\n\t}\n}\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.3994140625,
          "content": "#!/bin/bash\nGOARCH=amd64 GOOS=linux go build -o releases/torsniff-${VERSION}-linux-amd64\nGOARCH=386 GOOS=linux go build -o releases/torsniff-${VERSION}-linux-386\n\nGOARCH=amd64 GOOS=windows go build -o releases/torsniff-${VERSION}-windows-amd64.exe\nGOARCH=386 GOOS=windows go build -o releases/torsniff-${VERSION}-windows-386.exe\n\nGOARCH=amd64 GOOS=darwin go build -o releases/torsniff-${VERSION}-darwin-amd64\n"
        },
        {
          "name": "dht.go",
          "type": "blob",
          "size": 6.904296875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"container/list\"\n\t\"crypto/rand\"\n\t\"crypto/sha1\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/marksamman/bencode\"\n\t\"golang.org/x/time/rate\"\n)\n\nvar seeds = []string{\n\t\"router.bittorrent.com:6881\",\n\t\"dht.transmissionbt.com:6881\",\n\t\"router.utorrent.com:6881\",\n}\n\ntype nodeID []byte\n\ntype node struct {\n\taddr string\n\tid   string\n}\n\ntype announcements struct {\n\tmu    sync.RWMutex\n\tll    *list.List\n\tlimit int\n\tinput chan struct{}\n}\n\nfunc (a *announcements) get() *announcement {\n\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tif elem := a.ll.Front(); elem != nil {\n\t\tac := elem.Value.(*announcement)\n\t\ta.ll.Remove(elem)\n\t\treturn ac\n\t}\n\n\treturn nil\n}\n\nfunc (a *announcements) put(ac *announcement) {\n\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tif a.ll.Len() >= a.limit {\n\t\treturn\n\t}\n\n\ta.ll.PushBack(ac)\n\n\tselect {\n\tcase a.input <- struct{}{}:\n\tdefault:\n\t}\n}\n\nfunc (a *announcements) wait() <-chan struct{} {\n\treturn a.input\n}\n\nfunc (a *announcements) len() int {\n\ta.mu.RLock()\n\tdefer a.mu.RUnlock()\n\n\treturn a.ll.Len()\n}\n\nfunc (a *announcements) full() bool {\n\treturn a.len() >= a.limit\n}\n\ntype announcement struct {\n\traw         map[string]interface{}\n\tfrom        net.UDPAddr\n\tpeer        net.Addr\n\tinfohash    []byte\n\tinfohashHex string\n}\n\nfunc randBytes(n int) []byte {\n\tb := make([]byte, n)\n\trand.Read(b)\n\treturn b\n}\n\nfunc neighborID(target nodeID, local nodeID) nodeID {\n\tconst closeness = 15\n\tid := make([]byte, 20)\n\tcopy(id[:closeness], target[:closeness])\n\tcopy(id[closeness:], local[closeness:])\n\treturn id\n}\n\nfunc makeQuery(tid string, q string, a map[string]interface{}) map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"t\": tid,\n\t\t\"y\": \"q\",\n\t\t\"q\": q,\n\t\t\"a\": a,\n\t}\n}\n\nfunc makeReply(tid string, r map[string]interface{}) map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"t\": tid,\n\t\t\"y\": \"r\",\n\t\t\"r\": r,\n\t}\n}\n\nfunc decodeNodes(s string) (nodes []*node) {\n\tlength := len(s)\n\tif length%26 != 0 {\n\t\treturn\n\t}\n\n\tfor i := 0; i < length; i += 26 {\n\t\tid := s[i : i+20]\n\t\tip := net.IP([]byte(s[i+20 : i+24])).String()\n\t\tport := binary.BigEndian.Uint16([]byte(s[i+24 : i+26]))\n\t\taddr := ip + \":\" + strconv.Itoa(int(port))\n\t\tnodes = append(nodes, &node{id: id, addr: addr})\n\t}\n\n\treturn\n}\n\nfunc per(events int, duration time.Duration) rate.Limit {\n\treturn rate.Every(duration / time.Duration(events))\n}\n\ntype dht struct {\n\tmu             sync.Mutex\n\tannouncements  *announcements\n\tchNode         chan *node\n\tdie            chan struct{}\n\terrDie         error\n\tlocalID        nodeID\n\tconn           *net.UDPConn\n\tqueryTypes     map[string]func(map[string]interface{}, net.UDPAddr)\n\tfriendsLimiter *rate.Limiter\n\tsecret         []byte\n\tseeds          []string\n}\n\nfunc newDHT(laddr string, maxFriendsPerSec int) (*dht, error) {\n\tconn, err := net.ListenPacket(\"udp\", laddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\td := &dht{\n\t\tannouncements: &announcements{\n\t\t\tll:    list.New(),\n\t\t\tlimit: maxFriendsPerSec * 10,\n\t\t\tinput: make(chan struct{}, 1),\n\t\t},\n\t\tlocalID: randBytes(20),\n\t\tconn:    conn.(*net.UDPConn),\n\t\tchNode:  make(chan *node),\n\t\tdie:     make(chan struct{}),\n\t\tsecret:  randBytes(20),\n\t}\n\td.friendsLimiter = rate.NewLimiter(per(maxFriendsPerSec, time.Second), maxFriendsPerSec)\n\td.queryTypes = map[string]func(map[string]interface{}, net.UDPAddr){\n\t\t\"get_peers\":     d.onGetPeersQuery,\n\t\t\"announce_peer\": d.onAnnouncePeerQuery,\n\t}\n\treturn d, nil\n}\n\nfunc (d *dht) run() {\n\tgo d.listen()\n\tgo d.join()\n\tgo d.makeFriends()\n}\n\nfunc (d *dht) listen() {\n\tbuf := make([]byte, 2048)\n\tfor {\n\t\tn, addr, err := d.conn.ReadFromUDP(buf)\n\t\tif err == nil {\n\t\t\td.onMessage(buf[:n], *addr)\n\t\t} else {\n\t\t\td.errDie = err\n\t\t\tclose(d.die)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (d *dht) join() {\n\tconst timesForSure = 3\n\tfor i := 0; i < timesForSure; i++ {\n\t\tfor _, addr := range seeds {\n\t\t\tselect {\n\t\t\tcase d.chNode <- &node{\n\t\t\t\taddr: addr,\n\t\t\t\tid:   string(randBytes(20)),\n\t\t\t}:\n\t\t\tcase <-d.die:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (d *dht) onMessage(data []byte, from net.UDPAddr) {\n\tdict, err := bencode.Decode(bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn\n\t}\n\n\ty, ok := dict[\"y\"].(string)\n\tif !ok {\n\t\treturn\n\t}\n\n\tswitch y {\n\tcase \"q\":\n\t\td.onQuery(dict, from)\n\tcase \"r\", \"e\":\n\t\td.onReply(dict, from)\n\t}\n}\n\nfunc (d *dht) onQuery(dict map[string]interface{}, from net.UDPAddr) {\n\t_, ok := dict[\"t\"].(string)\n\tif !ok {\n\t\treturn\n\t}\n\n\tq, ok := dict[\"q\"].(string)\n\tif !ok {\n\t\treturn\n\t}\n\n\tif handle, ok := d.queryTypes[q]; ok {\n\t\thandle(dict, from)\n\t}\n}\n\nfunc (d *dht) onReply(dict map[string]interface{}, from net.UDPAddr) {\n\tr, ok := dict[\"r\"].(map[string]interface{})\n\tif !ok {\n\t\treturn\n\t}\n\n\tnodes, ok := r[\"nodes\"].(string)\n\tif !ok {\n\t\treturn\n\t}\n\n\tfor _, node := range decodeNodes(nodes) {\n\t\tif !d.friendsLimiter.Allow() {\n\t\t\tcontinue\n\t\t}\n\n\t\td.chNode <- node\n\t}\n}\n\nfunc (d *dht) findNode(to string, target nodeID) {\n\tq := makeQuery(string(randBytes(2)), \"find_node\", map[string]interface{}{\n\t\t\"id\":     string(neighborID(target, d.localID)),\n\t\t\"target\": string(randBytes(20)),\n\t})\n\n\taddr, err := net.ResolveUDPAddr(\"udp\", to)\n\tif err != nil {\n\t\treturn\n\t}\n\n\td.send(q, *addr)\n}\n\nfunc (d *dht) onGetPeersQuery(dict map[string]interface{}, from net.UDPAddr) {\n\ttid, ok := dict[\"t\"].(string)\n\tif !ok {\n\t\treturn\n\t}\n\n\ta, ok := dict[\"a\"].(map[string]interface{})\n\tif !ok {\n\t\treturn\n\t}\n\n\tid, ok := a[\"id\"].(string)\n\tif !ok {\n\t\treturn\n\t}\n\n\tr := makeReply(tid, map[string]interface{}{\n\t\t\"id\":    string(neighborID([]byte(id), d.localID)),\n\t\t\"nodes\": \"\",\n\t\t\"token\": d.makeToken(from),\n\t})\n\td.send(r, from)\n}\n\nfunc (d *dht) onAnnouncePeerQuery(dict map[string]interface{}, from net.UDPAddr) {\n\tif d.announcements.full() {\n\t\treturn\n\t}\n\n\ta, ok := dict[\"a\"].(map[string]interface{})\n\tif !ok {\n\t\treturn\n\t}\n\n\ttoken, ok := a[\"token\"].(string)\n\tif !ok || !d.validateToken(token, from) {\n\t\treturn\n\t}\n\n\tif ac := d.summarize(dict, from); ac != nil {\n\t\td.announcements.put(ac)\n\t}\n}\n\nfunc (d *dht) summarize(dict map[string]interface{}, from net.UDPAddr) *announcement {\n\ta, ok := dict[\"a\"].(map[string]interface{})\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tinfohash, ok := a[\"info_hash\"].(string)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tport := int64(from.Port)\n\tif impliedPort, ok := a[\"implied_port\"].(int64); ok && impliedPort == 0 {\n\t\tif p, ok := a[\"port\"].(int64); ok {\n\t\t\tport = p\n\t\t}\n\t}\n\n\treturn &announcement{\n\t\traw:         dict,\n\t\tfrom:        from,\n\t\tinfohash:    []byte(infohash),\n\t\tinfohashHex: hex.EncodeToString([]byte(infohash)),\n\t\tpeer:        &net.TCPAddr{IP: from.IP, Port: int(port)},\n\t}\n}\n\nfunc (d *dht) send(dict map[string]interface{}, to net.UDPAddr) error {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\td.conn.WriteToUDP(bencode.Encode(dict), &to)\n\treturn nil\n}\n\nfunc (d *dht) makeFriends() {\n\tfor {\n\t\tselect {\n\t\tcase node := <-d.chNode:\n\t\t\td.findNode(node.addr, []byte(node.id))\n\t\tcase <-d.die:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (d *dht) makeToken(from net.UDPAddr) string {\n\ts := sha1.New()\n\ts.Write([]byte(from.String()))\n\ts.Write(d.secret)\n\treturn string(s.Sum(nil))\n}\n\nfunc (d *dht) validateToken(token string, from net.UDPAddr) bool {\n\treturn token == d.makeToken(from)\n}\n"
        },
        {
          "name": "meta.go",
          "type": "blob",
          "size": 6.8740234375,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha1\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/marksamman/bencode\"\n)\n\nconst (\n\tperBlock        = 16384\n\tmaxMetadataSize = perBlock * 1024\n\textended        = 20\n\textHandshake    = 0\n)\n\nvar (\n\terrExtHeader    = errors.New(\"invalid extension header response\")\n\terrInvalidPiece = errors.New(\"invalid piece response\")\n\terrTimeout      = errors.New(\"time out\")\n)\n\nvar metaWirePool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn &metaWire{}\n\t},\n}\n\ntype metaWire struct {\n\tinfohash     string\n\tfrom         string\n\tpeerID       string\n\tconn         *net.TCPConn\n\ttimeout      time.Duration\n\tmetadataSize int\n\tutMetadata   int\n\tnumOfPieces  int\n\tpieces       [][]byte\n\terr          error\n}\n\nfunc newMetaWire(infohash string, from string, timeout time.Duration) *metaWire {\n\tw := metaWirePool.Get().(*metaWire)\n\tw.infohash = infohash\n\tw.from = from\n\tw.peerID = string(randBytes(20))\n\tw.timeout = timeout\n\tw.conn = nil\n\tw.err = nil\n\treturn w\n}\n\nfunc (mw *metaWire) fetch() ([]byte, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), mw.timeout)\n\tdefer cancel()\n\treturn mw.fetchCtx(ctx)\n}\n\nfunc (mw *metaWire) fetchCtx(ctx context.Context) ([]byte, error) {\n\tmw.connect(ctx)\n\tmw.handshake(ctx)\n\tmw.onHandshake(ctx)\n\tmw.extHandshake(ctx)\n\n\tif mw.err != nil {\n\t\tif mw.conn != nil {\n\t\t\tmw.conn.Close()\n\t\t}\n\t\treturn nil, mw.err\n\t}\n\n\tfor {\n\t\tdata, err := mw.next(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif data[0] != extended {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := mw.onExtended(ctx, data[1], data[2:]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif !mw.checkDone() {\n\t\t\tcontinue\n\t\t}\n\n\t\tm := bytes.Join(mw.pieces, []byte(\"\"))\n\t\tsum := sha1.Sum(m)\n\t\tif bytes.Equal(sum[:], []byte(mw.infohash)) {\n\t\t\treturn m, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"metadata checksum mismatch\")\n\t}\n}\n\nfunc (mw *metaWire) connect(ctx context.Context) {\n\tconn, err := net.DialTimeout(\"tcp\", mw.from, mw.timeout)\n\tif err != nil {\n\t\tmw.err = fmt.Errorf(\"connect to remote peer failed: %v\", err)\n\t\treturn\n\t}\n\n\tmw.conn = conn.(*net.TCPConn)\n}\n\nfunc (mw *metaWire) handshake(ctx context.Context) {\n\tif mw.err != nil {\n\t\treturn\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tmw.err = errTimeout\n\t\treturn\n\tdefault:\n\t}\n\n\tbuf := bytes.NewBuffer(nil)\n\tbuf.Write(mw.preHeader())\n\tbuf.WriteString(mw.infohash)\n\tbuf.WriteString(mw.peerID)\n\t_, mw.err = mw.conn.Write(buf.Bytes())\n}\n\nfunc (mw *metaWire) onHandshake(ctx context.Context) {\n\tif mw.err != nil {\n\t\treturn\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tmw.err = errTimeout\n\t\treturn\n\tdefault:\n\t}\n\n\tres, err := mw.read(ctx, 68)\n\tif err != nil {\n\t\tmw.err = err\n\t\treturn\n\t}\n\n\tif !bytes.Equal(res[:20], mw.preHeader()[:20]) {\n\t\tmw.err = errors.New(\"remote peer not supporting bittorrent protocol\")\n\t\treturn\n\t}\n\n\tif res[25]&0x10 != 0x10 {\n\t\tmw.err = errors.New(\"remote peer not supporting extension protocol\")\n\t\treturn\n\t}\n\n\tif !bytes.Equal(res[28:48], []byte(mw.infohash)) {\n\t\tmw.err = errors.New(\"invalid bittorrent header response\")\n\t\treturn\n\t}\n}\n\nfunc (mw *metaWire) extHandshake(ctx context.Context) {\n\tif mw.err != nil {\n\t\treturn\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tmw.err = errTimeout\n\t\treturn\n\tdefault:\n\t}\n\n\tdata := append([]byte{extended, extHandshake}, bencode.Encode(map[string]interface{}{\n\t\t\"m\": map[string]interface{}{\n\t\t\t\"ut_metadata\": 1,\n\t\t},\n\t})...)\n\tif err := mw.write(ctx, data); err != nil {\n\t\tmw.err = err\n\t\treturn\n\t}\n}\n\nfunc (mw *metaWire) onExtHandshake(ctx context.Context, payload []byte) error {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn errTimeout\n\tdefault:\n\t}\n\n\tdict, err := bencode.Decode(bytes.NewBuffer(payload))\n\tif err != nil {\n\t\treturn errExtHeader\n\t}\n\n\tmetadataSize, ok := dict[\"metadata_size\"].(int64)\n\tif !ok {\n\t\treturn errExtHeader\n\t}\n\n\tif metadataSize > maxMetadataSize {\n\t\treturn errors.New(\"metadata_size too long\")\n\t}\n\n\tif metadataSize < 0 {\n\t\treturn errors.New(\"negative metadata_size\")\n\t}\n\n\tm, ok := dict[\"m\"].(map[string]interface{})\n\tif !ok {\n\t\treturn errExtHeader\n\t}\n\n\tutMetadata, ok := m[\"ut_metadata\"].(int64)\n\tif !ok {\n\t\treturn errExtHeader\n\t}\n\n\tmw.metadataSize = int(metadataSize)\n\tmw.utMetadata = int(utMetadata)\n\tmw.numOfPieces = mw.metadataSize / perBlock\n\tif mw.metadataSize%perBlock != 0 {\n\t\tmw.numOfPieces++\n\t}\n\tmw.pieces = make([][]byte, mw.numOfPieces)\n\n\tfor i := 0; i < mw.numOfPieces; i++ {\n\t\tmw.requestPiece(ctx, i)\n\t}\n\n\treturn nil\n}\n\nfunc (mw *metaWire) requestPiece(ctx context.Context, i int) {\n\tbuf := bytes.NewBuffer(nil)\n\tbuf.WriteByte(byte(extended))\n\tbuf.WriteByte(byte(mw.utMetadata))\n\tbuf.Write(bencode.Encode(map[string]interface{}{\n\t\t\"msg_type\": 0,\n\t\t\"piece\":    i,\n\t}))\n\tmw.write(ctx, buf.Bytes())\n}\n\nfunc (mw *metaWire) onExtended(ctx context.Context, ext byte, payload []byte) error {\n\tif ext == 0 {\n\t\tif err := mw.onExtHandshake(ctx, payload); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tpiece, index, err := mw.onPiece(ctx, payload)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmw.pieces[index] = piece\n\t}\n\treturn nil\n}\n\nfunc (mw *metaWire) onPiece(ctx context.Context, payload []byte) ([]byte, int, error) {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, -1, errTimeout\n\tdefault:\n\t}\n\n\ttrailerIndex := bytes.Index(payload, []byte(\"ee\")) + 2\n\tif trailerIndex == 1 {\n\t\treturn nil, 0, errInvalidPiece\n\t}\n\n\tdict, err := bencode.Decode(bytes.NewBuffer(payload[:trailerIndex]))\n\tif err != nil {\n\t\treturn nil, 0, errInvalidPiece\n\t}\n\n\tpieceIndex, ok := dict[\"piece\"].(int64)\n\tif !ok || int(pieceIndex) >= mw.numOfPieces {\n\t\treturn nil, 0, errInvalidPiece\n\t}\n\n\tmsgType, ok := dict[\"msg_type\"].(int64)\n\tif !ok || msgType != 1 {\n\t\treturn nil, 0, errInvalidPiece\n\t}\n\n\treturn payload[trailerIndex:], int(pieceIndex), nil\n}\n\nfunc (mw *metaWire) checkDone() bool {\n\tfor _, b := range mw.pieces {\n\t\tif b == nil {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (mw *metaWire) preHeader() []byte {\n\tbuf := bytes.NewBuffer(nil)\n\tbuf.WriteByte(19)\n\tbuf.WriteString(\"BitTorrent protocol\")\n\tbuf.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01})\n\treturn buf.Bytes()\n}\n\nfunc (mw *metaWire) next(ctx context.Context) ([]byte, error) {\n\tdata, err := mw.read(ctx, 4)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsize := binary.BigEndian.Uint32(data)\n\tdata, err = mw.read(ctx, size)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}\n\nfunc (mw *metaWire) read(ctx context.Context, size uint32) ([]byte, error) {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, errTimeout\n\tdefault:\n\t}\n\n\tbuf := bytes.NewBuffer(nil)\n\t_, err := io.CopyN(buf, mw.conn, int64(size))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"read %d bytes message failed: %v\", size, err)\n\t}\n\n\treturn buf.Bytes(), nil\n}\n\nfunc (mw *metaWire) write(ctx context.Context, data []byte) error {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn errTimeout\n\tdefault:\n\t}\n\n\tbuf := bytes.NewBuffer(nil)\n\tlength := int32(len(data))\n\tbinary.Write(buf, binary.BigEndian, length)\n\tbuf.Write(data)\n\t_, err := mw.conn.Write(buf.Bytes())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"write message failed: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (mw *metaWire) free() {\n\tmetaWirePool.Put(mw)\n}\n"
        },
        {
          "name": "torsniff.go",
          "type": "blob",
          "size": 5.8671875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/marksamman/bencode\"\n\t\"github.com/mitchellh/go-homedir\"\n\t\"github.com/spf13/cobra\"\n\t\"go.etcd.io/etcd/pkg/fileutil\"\n)\n\nconst (\n\tdirectory = \"torrents\"\n)\n\ntype tfile struct {\n\tname   string\n\tlength int64\n}\n\nfunc (t *tfile) String() string {\n\treturn fmt.Sprintf(\"name: %s\\n, size: %d\\n\", t.name, t.length)\n}\n\ntype torrent struct {\n\tinfohashHex string\n\tname        string\n\tlength      int64\n\tfiles       []*tfile\n}\n\nfunc (t *torrent) String() string {\n\treturn fmt.Sprintf(\n\t\t\"link: %s\\nname: %s\\nsize: %d\\nfile: %d\\n\",\n\t\tfmt.Sprintf(\"magnet:?xt=urn:btih:%s\", t.infohashHex),\n\t\tt.name,\n\t\tt.length,\n\t\tlen(t.files),\n\t)\n}\n\nfunc parseTorrent(meta []byte, infohashHex string) (*torrent, error) {\n\tdict, err := bencode.Decode(bytes.NewBuffer(meta))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tt := &torrent{infohashHex: infohashHex}\n\tif name, ok := dict[\"name.utf-8\"].(string); ok {\n\t\tt.name = name\n\t} else if name, ok := dict[\"name\"].(string); ok {\n\t\tt.name = name\n\t}\n\tif length, ok := dict[\"length\"].(int64); ok {\n\t\tt.length = length\n\t}\n\n\tvar totalSize int64\n\tvar extractFiles = func(file map[string]interface{}) {\n\t\tvar filename string\n\t\tvar filelength int64\n\t\tif inter, ok := file[\"path.utf-8\"].([]interface{}); ok {\n\t\t\tname := make([]string, len(inter))\n\t\t\tfor i, v := range inter {\n\t\t\t\tname[i] = fmt.Sprint(v)\n\t\t\t}\n\t\t\tfilename = strings.Join(name, \"/\")\n\t\t} else if inter, ok := file[\"path\"].([]interface{}); ok {\n\t\t\tname := make([]string, len(inter))\n\t\t\tfor i, v := range inter {\n\t\t\t\tname[i] = fmt.Sprint(v)\n\t\t\t}\n\t\t\tfilename = strings.Join(name, \"/\")\n\t\t}\n\t\tif length, ok := file[\"length\"].(int64); ok {\n\t\t\tfilelength = length\n\t\t\ttotalSize += filelength\n\t\t}\n\t\tt.files = append(t.files, &tfile{name: filename, length: filelength})\n\t}\n\n\tif files, ok := dict[\"files\"].([]interface{}); ok {\n\t\tfor _, file := range files {\n\t\t\tif f, ok := file.(map[string]interface{}); ok {\n\t\t\t\textractFiles(f)\n\t\t\t}\n\t\t}\n\t}\n\n\tif t.length == 0 {\n\t\tt.length = totalSize\n\t}\n\tif len(t.files) == 0 {\n\t\tt.files = append(t.files, &tfile{name: t.name, length: t.length})\n\t}\n\n\treturn t, nil\n}\n\ntype torsniff struct {\n\tladdr      string\n\tmaxFriends int\n\tmaxPeers   int\n\tsecret     string\n\ttimeout    time.Duration\n\tblacklist  *blackList\n\tdir        string\n}\n\nfunc (t *torsniff) run() error {\n\ttokens := make(chan struct{}, t.maxPeers)\n\n\tdht, err := newDHT(t.laddr, t.maxFriends)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdht.run()\n\n\tlog.Println(\"running, it may take a few minutes...\")\n\n\tfor {\n\t\tselect {\n\t\tcase <-dht.announcements.wait():\n\t\t\tfor {\n\t\t\t\tif ac := dht.announcements.get(); ac != nil {\n\t\t\t\t\ttokens <- struct{}{}\n\t\t\t\t\tgo t.work(ac, tokens)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase <-dht.die:\n\t\t\treturn dht.errDie\n\t\t}\n\t}\n\n}\n\nfunc (t *torsniff) work(ac *announcement, tokens chan struct{}) {\n\tdefer func() {\n\t\t<-tokens\n\t}()\n\n\tif t.isTorrentExist(ac.infohashHex) {\n\t\treturn\n\t}\n\n\tpeerAddr := ac.peer.String()\n\tif t.blacklist.has(peerAddr) {\n\t\treturn\n\t}\n\n\twire := newMetaWire(string(ac.infohash), peerAddr, t.timeout)\n\tdefer wire.free()\n\n\tmeta, err := wire.fetch()\n\tif err != nil {\n\t\tt.blacklist.add(peerAddr)\n\t\treturn\n\t}\n\n\tif err := t.saveTorrent(ac.infohashHex, meta); err != nil {\n\t\treturn\n\t}\n\n\ttorrent, err := parseTorrent(meta, ac.infohashHex)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlog.Println(torrent)\n}\n\nfunc (t *torsniff) isTorrentExist(infohashHex string) bool {\n\tname, _ := t.torrentPath(infohashHex)\n\t_, err := os.Stat(name)\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn err == nil\n}\n\nfunc (t *torsniff) saveTorrent(infohashHex string, data []byte) error {\n\tname, dir := t.torrentPath(infohashHex)\n\tif err := os.MkdirAll(dir, 0755); err != nil {\n\t\treturn err\n\t}\n\n\td, err := bencode.Decode(bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tf, err := fileutil.TryLockFile(name, os.O_WRONLY|os.O_CREATE, 0755)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\t_, err = f.Write(bencode.Encode(map[string]interface{}{\n\t\t\"info\": d,\n\t}))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (t *torsniff) torrentPath(infohashHex string) (name string, dir string) {\n\tdir = path.Join(t.dir, infohashHex[:2], infohashHex[len(infohashHex)-2:])\n\tname = path.Join(dir, infohashHex+\".torrent\")\n\treturn\n}\n\nfunc main() {\n\tlog.SetFlags(0)\n\n\tvar addr string\n\tvar port uint16\n\tvar peers int\n\tvar timeout time.Duration\n\tvar dir string\n\tvar verbose bool\n\tvar friends int\n\n\thome, err := homedir.Dir()\n\tuserHome := path.Join(home, directory)\n\n\troot := &cobra.Command{\n\t\tUse:          \"torsniff\",\n\t\tShort:        \"torsniff - A sniffer that sniffs torrents from BitTorrent network.\",\n\t\tSilenceUsage: true,\n\t}\n\troot.RunE = func(cmd *cobra.Command, args []string) error {\n\t\tif dir == userHome && err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tabsDir, err := filepath.Abs(dir)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlog.SetOutput(ioutil.Discard)\n\t\tif verbose {\n\t\t\tlog.SetOutput(os.Stdout)\n\t\t}\n\n\t\tp := &torsniff{\n\t\t\tladdr:      net.JoinHostPort(addr, strconv.Itoa(int(port))),\n\t\t\ttimeout:    timeout,\n\t\t\tmaxFriends: friends,\n\t\t\tmaxPeers:   peers,\n\t\t\tsecret:     string(randBytes(20)),\n\t\t\tdir:        absDir,\n\t\t\tblacklist:  newBlackList(5*time.Minute, 50000),\n\t\t}\n\t\treturn p.run()\n\t}\n\n\troot.Flags().StringVarP(&addr, \"addr\", \"a\", \"\", \"listen on given address (default all, ipv4 and ipv6)\")\n\troot.Flags().Uint16VarP(&port, \"port\", \"p\", 6881, \"listen on given port\")\n\troot.Flags().IntVarP(&friends, \"friends\", \"f\", 500, \"max fiends to make with per second\")\n\troot.Flags().IntVarP(&peers, \"peers\", \"e\", 400, \"max peers to connect to download torrents\")\n\troot.Flags().DurationVarP(&timeout, \"timeout\", \"t\", 10*time.Second, \"max time allowed for downloading torrents\")\n\troot.Flags().StringVarP(&dir, \"dir\", \"d\", userHome, \"the directory to store the torrents\")\n\troot.Flags().BoolVarP(&verbose, \"verbose\", \"v\", true, \"run in verbose mode\")\n\n\tif err := root.Execute(); err != nil {\n\t\tfmt.Println(fmt.Errorf(\"could not start: %s\", err))\n\t}\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}