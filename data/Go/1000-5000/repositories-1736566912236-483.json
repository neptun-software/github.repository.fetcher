{
  "metadata": {
    "timestamp": 1736566912236,
    "page": 483,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "soundcloud/roshi",
      "stars": 3156,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3154296875,
          "content": "roshi-server/roshi-server\nroshi-walker/roshi-walker\nroshi-walker/fill\n\n# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.111328125,
          "content": "# Changelog\n\n## 0.0.1 / 2014-01-14\n\n- Initial copy from [peterbourgon/crdt](https://github.com/peterbourgon/crdt)\n"
        },
        {
          "name": "CONTRIBUTORS.md",
          "type": "blob",
          "size": 0.0634765625,
          "content": "- Tomás Senart\n- Peter Bourgon\n- Björn Rabenstein\n- Johan Uhle\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.2607421875,
          "content": "Copyright &copy; 2014, SoundCloud Ltd.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\nRedistributions in binary form must reproduce the above copyright notice, this\nlist of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.1884765625,
          "content": "# roshi [![Build Status](https://travis-ci.org/soundcloud/roshi.png)](https://travis-ci.org/soundcloud/roshi) [![GoDoc](https://godoc.org/github.com/soundcloud/roshi?status.svg)](http://godoc.org/github.com/soundcloud/roshi)\n\nRoshi implements a time-series event storage via a LWW-element-set CRDT with\nlimited inline garbage collection. Roshi is a stateless, distributed layer on\ntop of Redis and is implemented in Go. It is partition tolerant, highly\navailable and eventually consistent.\n\nAt a high level, Roshi maintains sets of values, with each set ordered\naccording to (external) timestamp, newest-first. Roshi provides the following\nAPI:\n\n* Insert(key, timestamp, value)\n* Delete(key, timestamp, value)\n* Select(key, offset, limit) []TimestampValue\n\nRoshi stores a sharded copy of your dataset in multiple independent Redis\ninstances, called a **cluster**. Roshi provides fault tolerance by duplicating\nclusters; multiple identical clusters, normally at least 3, form a **farm**.\nRoshi leverages CRDT semantics to ensure consistency without explicit\nconsensus.\n\n# Use cases\n\nRoshi is basically a high-performance **index** for timestamped data. It's\ndesigned to sit in the critical (request) path of your application or service.\nThe originating use case is the SoundCloud stream; see [this blog post][blog]\nfor details.\n\n[blog]: http://developers.soundcloud.com/blog/roshi-a-crdt-system-for-timestamped-events\n\n# Theory and system properties\n\nRoshi is a distributed system, for two reasons: it's made for datasets that\ndon't fit on one machine, and it's made to be tolerant against node failure.\n\nNext, we will explain the system design.\n\n## CRDT\n\nCRDTs (conflict-free replicated data types) are data types on which the same \nset of operations yields the same outcome, regardless of order of execution \nand duplication of operations. This allows data convergence without the need \nfor consensus between replicas. In turn, this allows for easier implementation \n(no consensus protocol implementation) as well as lower latency (no wait-time \nfor consensus).\n\nOperations on CRDTs need to adhere [to the following rules][mixu]:\n\n- Associativity (a+(b+c)=(a+b)+c), so that grouping doesn't matter.\n- Commutativity (a+b=b+a), so that order of application doesn't matter.\n- Idempotence (a+a=a), so that duplication doesn't matter.\n\nData types as well as operations have to be specifically crafted to meet these\nrules. CRDTs have known implementations for counters, registers, sets, graphs,\nand others. Roshi implements a set data type, specifically the Last Writer\nWins element set (LWW-element-set).\n\nThis is an intuitive description of the LWW-element-set:\n\n- An element is in the set, if its most-recent operation was an add.\n- An element is not in the set, if its most-recent operation was a remove.\n\nA more formal description of a LWW-element-set, as informed by\n[Shapiro][shapiro], is as follows: a set S is represented by two internal\nsets, the add set A and the remove set R. To add an element e to the set S,\nadd a tuple t with the element and the current timestamp t=(e, now()) to A. To\nremove an element from the set S, add a tuple t with the element and the\ncurrent timestamp t=(e, now()) to R. To check if an element e is in the set S,\ncheck if it is in the add set A and not in the remove set R with a higher\ntimestamp.\n\nRoshi implements the above definition, but extends it by applying a sort of\ninstant garbage collection.  When inserting an element E to the logical set S,\ncheck if E is already in the add set A or the remove set R. If so, check the\nexisting timestamp. If the existing timestamp is **lower** than the incoming\ntimestamp, the write succeeds: remove the existing (element, timestamp) tuple\nfrom whichever set it was found in, and add the incoming (element, timestamp)\ntuple to the add set A. If the existing timestamp is higher than the incoming\ntimestamp, the write is a no-op.\n\nBelow are all possible combinations of add and remove operations.\nA(elements...) is the state of the add set. R(elements...) is the state of\nthe remove set. An element is a tuple with (value, timestamp). add(element)\nand remove(element) are the operations.\n\nOriginal state | Operation   | Resulting state\n---------------|-------------|-----------------\nA(a,1) R()     | add(a,0)    | A(a,1) R()\nA(a,1) R()     | add(a,1)    | A(a,1) R()\nA(a,1) R()     | add(a,2)    | A(a,2) R()\nA(a,1) R()     | remove(a,0) | A(a,1) R()\nA(a,1) R()     | remove(a,1) | A(a,1) R()\nA(a,1) R()     | remove(a,2) | A() R(a,2)\nA() R(a,1)     | add(a,0)    | A() R(a,1)\nA() R(a,1)     | add(a,1)    | A() R(a,1)\nA() R(a,1)     | add(a,2)    | A(a,2) R()\nA() R(a,1)     | remove(a,0) | A() R(a,1)\nA() R(a,1)     | remove(a,1) | A() R(a,1)\nA() R(a,1)     | remove(a,2) | A() R(a,2)\n\nFor a Roshi LWW-element-set, an element will always be in either the add or\nthe remove set exclusively, but never in both and never more than once. This\nmeans that the logical set S is the same as the add set A.\n\nEvery key in Roshi represents a set. Each set is its own LWW-element-set.\n\nFor more information on CRDTs, the following resources might be helpful:\n\n- [The chapter on CRDTs][mixu] in \"Distributed Systems for Fun and Profit\" by Mixu\n- \"[A comprehensive study of Convergent and Commutative Replicated Data Types][shapiro]\" by Mark Shapiro et al. 2011\n\n[mixu]: http://book.mixu.net/distsys/eventual.html\n[shapiro]: http://hal.inria.fr/docs/00/55/55/88/PDF/techreport.pdf\n\n## Replication\n\nRoshi replicates data over several non-communicating clusters. A typical\nreplication factor is 3. Roshi has two methods of replicating data: during\nwrite, and during read-repair.\n\nA write (Insert or Delete) is sent to all clusters. The overall operation\nreturns success the moment a user-defined number of clusters return success.\nUnsuccessful clusters might either have been too slow (but still accepted the\nwrite) or failed (due to a network partition or an instance crash). In case of\nfailure, read-repair might be triggered on a later read.\n\nA read (Select) is dependent on the read strategy employed. If the strategy\nqueries several clusters, it might be able to spot disagreement in the\nreturned sets. If so, the unioned set is returned to the client, and in the\nbackground, a read-repair is triggered, which lazily converges the sets across\nall replicas.\n\n[Package farm][farm] explains replication, read strategies, and read-repair\nfurther.\n\n[farm]: http://github.com/soundcloud/roshi/tree/master/farm\n\n## Fault tolerance\n\nRoshi runs as a homogenous distributed system. Each Roshi instance can serve\nall requests (Insert, Delete, Select) for a client, and communicates with all\nRedis instances.\n\nA Roshi instance is effectively stateless, but holds transient state. If a\nRoshi instance crashes, two types of state are lost:\n\n1. Current client connections are lost. Clients can reconnect to another Roshi\n   instance and re-execute their operation.\n2. Unresolved read-repairs are lost. The read-repair might be triggered again\n   during another read.\n\nSince all operations are idempotent, both failure modes do not impede on\nconvergence of the data.\n\nPersistence is delegated to [Redis][redis-persistence]. Data on a\ncrashed-but-recovered Redis instance might be lost between the time it\ncommited to disk, and the time it accepts connections again. The lost data gap\nmight be repaired via read-repair.\n\n[redis-persistence]: http://redis.io/topics/persistence\n\nIf a Redis instance is permanently lost and has to be replaced with a fresh\ninstance, there are two options:\n\n1. Replace it with an empty instance. Keys will be replicated to it via\n   read-repair. As more and more keys are replicated, the read-repair load will\n   decrease and the instance will work normally. This process might result in\n   data loss over the lifetime of a system: if the other replicas are also\n   lost, non-replicated keys (keys that have not been requested and thus did\n   not trigger a read-repair) are lost.\n2. Replace it with a cloned replica. There will be a gap between the time of\n   the last write respected by the replica and the first write respected by the\n   new instance. This gap might be fixed by subsequent read-repairs.\n\nBoth processes can be expedited via a [keyspace walker process][roshi-walker].\nNevertheless, these properties and procedures warrant careful consideration.\n\n## Responses to write operations\n\nWrite operations (insert or delete) return boolean to indicate whether the\noperation was successfully applied to the data layer, respecting the\nconfigured write quorum. Clients should interpret a write response of false to\nmean they should re-submit their operation. A write response of true does\n**not** imply the operation mutated the state in a way that will be visible to\nreaders, merely that it was accepted and processed according to CRDT\nsemantics.\n\nAs an example, all of these write operations would return true.\n\nWrite operation         | Final state           | Operation description\n------------------------|-----------------------|---------------\nInsert(\"foo\", 3, \"bar\") | foo+ bar/3<br/>foo- — | Initial write\nInsert(\"foo\", 3, \"bar\") | foo+ bar/3<br/>foo- — | No-op: incoming score doesn't beat existing score\nDelete(\"foo\", 2, \"bar\") | foo+ bar/3<br/>foo- — | No-op: incoming score doesn't beat existing score\nDelete(\"foo\", 4, \"bar\") | foo+ —<br/>foo- bar/4 | \"bar\" moves from add set to remove set\nDelete(\"foo\", 5, \"bar\") | foo+ —<br/>foo- bar/5 | score of \"bar\" in remove set is incremented\n\n## Considerations\n\n### Elasticity\n\nRoshi does not support elasticity. It is not possible to change the sharding\nconfiguration during operations. Roshi has static service discovery,\nconfigured during startup.\n\n### Data structure\n\nRoshi works with LWW-element-sets only. Clients might choose to model other\ndata types on top of the LWW-element-sets themselves.\n\n### Correct client timestamps\n\nClient timestamps are assumed to correctly represent the physical order of\nevents coming into the system. Incorrect client timestamps might lead to\nvalues of a client either never appearing or always overriding other values in\na set.\n\n### Data loss\n\nAssuming a replication factor of 3, and a write quorum of 2 nodes, Roshi makes\nthe following guarantees in the presence of failures of Redis instances that\nrepresent the same data shard:\n\nFailures | Data loss? | Reads                              | Writes\n---------|------------|------------------------------------|----------\n0        | No         | Succeed                            | Succeed\n1        | No         | Success dependent on read strategy | Succeed\n2        | No         | Success dependent on read strategy | Fail\n3        | Yes        | Fail                               | Fail\n\n[Package farm][farm] explains read strategies further.\n\nFailures of Redis instances over independent data shards don't affect\ninstantaneous data durability. However, over time, independent Redis instance\nfailures can lead to data loss, especially on keys which are not regularly\nread-repaired.\nIn practice, a number of strategies may be used to probabilistically mitigate\nthis concern. For example, walking modified keys after known outages, or the\nwhole keyspace at regular intervals, which will trigger read-repairs for\ninconsistent sets.\nHowever, **Roshi fundamentally does not guarantee perfect data durability**.\nTherefore, Roshi should not be used as a source of truth, but only as an\nintermediate store for performance critical data.\n\n### Authentication, authorization, validation\n\nIn case it's not obvious, Roshi performs no authentication, authorization, or\nany validation of input data. Clients must implement those things themselves.\n\n# Architecture\n\nRoshi has a layered architecture, with each layer performing a specific\njob with a relatively small surface area. From the bottom up...\n\n- **Redis**: Roshi is ultimately implemented on top of Redis instance(s),\n  utilizing the [sorted set][sorted-set] data type. For more details on how\n  the sorted sets are used, see package cluster, below.\n\n- **[Package pool][pool]** performs key-based sharding over one or more Redis\n  instances. It exposes basically a single method, taking a key and yielding a\n  connection to the Redis instance that should hold that key. All Redis\n  interactions go through package pool.\n\n- **[Package cluster][cluster]** implements an Insert/Select/Delete API on top\n  of package pool. To ensure idempotency and [commutativity][commutativity],\n  package cluster expects timestamps to arrive as float64s, and refuses writes\n  with smaller timestamps than what's already been persisted. To ensure\n  information isn't lost via deletes, package cluster maintains two physical\n  Redis sorted sets for every logical (user) key, and manages the transition of\n  key-timestamp-value tuples between those sets.\n\n- **[Package farm][farm]** implements a single Insert/Select/Delete API over\n  multiple underlying clusters. Writes (Inserts and Deletes) are sent to all\n  clusters, and a quorum is required for success. Reads (Selects) abide one of\n  several read strategies. Some read strategies allow for the possibility of\n  read-repair.\n\n- **[roshi-server][roshi-server]** makes a Roshi farm accessible through a\n  REST-ish HTTP interface. It's effectively stateless, and [12-factor][twelve]\n  compliant.\n\n- **[roshi-walker][roshi-walker]** walks the keyspace in semirandom order at a\n  defined rate, making Select requests for each key in order to trigger read\n  repairs.\n\n[sorted-set]: http://redis.io/commands#sorted_set\n[pool]: http://github.com/soundcloud/roshi/tree/master/pool\n[cluster]: http://github.com/soundcloud/roshi/tree/master/cluster\n[commutativity]: http://en.wikipedia.org/wiki/Commutative_property\n[farm]: http://github.com/soundcloud/roshi/tree/master/farm\n[roshi-server]: http://github.com/soundcloud/roshi/tree/master/roshi-server\n[twelve]: http://12factor.net\n[roshi-walker]: http://github.com/soundcloud/roshi/tree/master/roshi-walker\n\n## The big picture\n\n![Overview](http://i.imgur.com/SEeKquW.png)\n\n(Clusters need not have the same number of Redis instances.)\n\n# Development\n\nRoshi is written in [Go](http://golang.org). You'll need a recent version of\nGo installed on your computer to build Roshi. If you're on a Mac and use\n[homebrew](http://brew.sh), `brew install go` should work fine.\n\n## Build\n\n    go build ./...\n\n## Test\n\n    go test ./...\n\n# Running\n\nSee [roshi-server][roshi-server] and [roshi-walker][roshi-walker] for\ninformation about owning and operating your own Roshi.\n"
        },
        {
          "name": "_vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "cluster",
          "type": "tree",
          "content": null
        },
        {
          "name": "common",
          "type": "tree",
          "content": null
        },
        {
          "name": "farm",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.666015625,
          "content": "module github.com/soundcloud/roshi\n\ngo 1.14\n\nrequire (\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/garyburd/redigo v1.6.0\n\tgithub.com/golang/protobuf v1.4.2 // indirect\n\tgithub.com/gorilla/context v1.1.1 // indirect\n\tgithub.com/gorilla/mux v1.7.4 // indirect\n\tgithub.com/gorilla/pat v1.0.1\n\tgithub.com/peterbourgon/g2s v0.0.0-20170223122336-d4e7ad98afea\n\tgithub.com/prometheus/client_golang v0.9.4\n\tgithub.com/prometheus/client_model v0.2.0 // indirect\n\tgithub.com/prometheus/procfs v0.1.3 // indirect\n\tgithub.com/tsenart/tb v0.0.0-20181025101425-0d2499c8b6e9\n\tgolang.org/x/sys v0.0.0-20200615200032-f1bc736245b1 // indirect\n)\n\nreplace github.com/soundcloud/roshi => ./\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 8.421875,
          "content": "github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/garyburd/redigo v1.6.0 h1:0VruCpn7yAIIu7pWVClQC8wxCJEcG3nyzpMSHKi1PQc=\ngithub.com/garyburd/redigo v1.6.0/go.mod h1:NR3MbYisc3/PwhQ00EMzDiPmrwpPxAn5GI05/YaO1SY=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.2 h1:+Z5KGCizgyZCbGh1KZqA0fcLLkwbsjIzS4aV2v7wJX0=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0 h1:xsAVV57WRhGj6kEIi8ReJzQlHHqcBYCElAvkovg3B/4=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=\ngithub.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=\ngithub.com/gorilla/mux v1.7.4 h1:VuZ8uybHlWmqV03+zRzdwKL4tUnIp1MAQtp1mIFE1bc=\ngithub.com/gorilla/mux v1.7.4/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=\ngithub.com/gorilla/pat v1.0.1 h1:OeSoj6sffw4/majibAY2BAUsXjNP7fEE+w30KickaL4=\ngithub.com/gorilla/pat v1.0.1/go.mod h1:YeAe0gNeiNT5hoiZRI4yiOky6jVdNvfO2N6Kav/HmxY=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1 h1:4hp9jkHxhMHkqkrB3Ix0jegS5sx/RkqARlsWZ6pIwiU=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/peterbourgon/g2s v0.0.0-20170223122336-d4e7ad98afea h1:sKwxy1H95npauwu8vtF95vG/syrL0p8fSZo/XlDg5gk=\ngithub.com/peterbourgon/g2s v0.0.0-20170223122336-d4e7ad98afea/go.mod h1:1VcHEd3ro4QMoHfiNl/j7Jkln9+KQuorp0PItHMJYNg=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v0.9.4 h1:Y8E/JaaPbmFSW2V81Ab/d8yZFYQQGbni1b1jPcG9Y6A=\ngithub.com/prometheus/client_golang v0.9.4/go.mod h1:oCXIBxdI62A4cR6aTRJCgetEjecSIYzOEaeAn4iYEpM=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.2.0 h1:uq5h0d+GuxiXLJLNABMgp2qUWDPiLvgCzz2dUR+/W/M=\ngithub.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/common v0.4.1 h1:K0MGApIoQvMw27RTdJkPbr3JZ7DNbtxQNyi5STVM6Kw=\ngithub.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.1.3 h1:F0+tqvhOksq22sc6iCHF5WGlWjdwj92p0udFh1VFBS8=\ngithub.com/prometheus/procfs v0.1.3/go.mod h1:lV6e/gmhEcM9IjHGsFOCxxuZ+z1YqCvr4OA4YeYWdaU=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/tsenart/tb v0.0.0-20181025101425-0d2499c8b6e9 h1:kjbwitOGH46vD01f2s3leBfrMnePQa3NSAIlW35MvY8=\ngithub.com/tsenart/tb v0.0.0-20181025101425-0d2499c8b6e9/go.mod h1:EcGP24b8DY+bWHnpfJDP7fM+o8Nmz4fYH0l2xTtNr3I=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20200106162015-b016eb3dc98e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200615200032-f1bc736245b1 h1:ogLJMz+qpzav7lGMh10LMvAkM/fAoGlaiiHYiFYdm80=\ngolang.org/x/sys v0.0.0-20200615200032-f1bc736245b1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.23.0 h1:4MY060fB1DLGMB/7MBTLnwQUY6+F09GEiz6SsrNqyzM=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n"
        },
        {
          "name": "instrumentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "pool",
          "type": "tree",
          "content": null
        },
        {
          "name": "roshi-server",
          "type": "tree",
          "content": null
        },
        {
          "name": "roshi-walker",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}