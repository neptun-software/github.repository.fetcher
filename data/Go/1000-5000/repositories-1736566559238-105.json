{
  "metadata": {
    "timestamp": 1736566559238,
    "page": 105,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kardianos/service",
      "stars": 4513,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0078125,
          "content": ".vscode/"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3564453125,
          "content": "arch:\n  - ppc64le\n  - amd64\nlanguage: go\ngo_import_path: github.com/kardianos/service\nsudo: required\n\ngo:\n  - 1.12.x\n  - 1.14.x\n  - master\n\nbefore_install:\n  - go get github.com/mattn/goveralls\n  - go get golang.org/x/tools/cmd/cover\n\nscript:\n  - chmod +x linux-test-su.sh\n  - sudo ./linux-test-su.sh $GOPATH `which go`\n  - $GOPATH/bin/goveralls -service=travis-ci\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.849609375,
          "content": "Copyright (c) 2015 Daniel Theophanes\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgment in the product documentation would be\n   appreciated but is not required.\n\n   2. Altered source versions must be plainly marked as such, and must not be\n   misrepresented as being the original software.\n\n   3. This notice may not be removed or altered from any source\n   distribution.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.7353515625,
          "content": "# service [![GoDoc](https://godoc.org/github.com/kardianos/service?status.svg)](https://godoc.org/github.com/kardianos/service)\n\nservice will install / un-install, start / stop, and run a program as a service (daemon).\nCurrently supports Windows XP+, Linux/(systemd | Upstart | SysV), and OSX/Launchd.\n\nWindows controls services by setting up callbacks that is non-trivial. This\nis very different then other systems. This package provides the same API\ndespite the substantial differences.\nIt also can be used to detect how a program is called, from an interactive\nterminal or from a service manager.\n\n## BUGS\n * Dependencies field is not implemented for Linux systems and Launchd.\n * OS X when running as a UserService Interactive will not be accurate.\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.2734375,
          "content": "version: \"{build}\"\n\nplatform:\n  - x86\n  - x64\n\nclone_folder: c:\\gopath\\src\\github.com\\kardianos\\service\n\nenvironment:\n  GOPATH: c:\\gopath\n\ninstall:\n  - go version\n  - go env\n  - go get -v -t ./...\n\nbuild_script:\n  - go install -v ./...\n\ntest_script:\n  - go test -v -tags su ./...\n"
        },
        {
          "name": "console.go",
          "type": "blob",
          "size": 1.095703125,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\n// ConsoleLogger logs to the std err.\nvar ConsoleLogger = consoleLogger{}\n\ntype consoleLogger struct {\n\tinfo, warn, err *log.Logger\n}\n\nfunc init() {\n\tConsoleLogger.info = log.New(os.Stderr, \"I: \", log.Ltime)\n\tConsoleLogger.warn = log.New(os.Stderr, \"W: \", log.Ltime)\n\tConsoleLogger.err = log.New(os.Stderr, \"E: \", log.Ltime)\n}\n\nfunc (c consoleLogger) Error(v ...interface{}) error {\n\tc.err.Print(v...)\n\treturn nil\n}\nfunc (c consoleLogger) Warning(v ...interface{}) error {\n\tc.warn.Print(v...)\n\treturn nil\n}\nfunc (c consoleLogger) Info(v ...interface{}) error {\n\tc.info.Print(v...)\n\treturn nil\n}\nfunc (c consoleLogger) Errorf(format string, a ...interface{}) error {\n\tc.err.Printf(format, a...)\n\treturn nil\n}\nfunc (c consoleLogger) Warningf(format string, a ...interface{}) error {\n\tc.warn.Printf(format, a...)\n\treturn nil\n}\nfunc (c consoleLogger) Infof(format string, a ...interface{}) error {\n\tc.info.Printf(format, a...)\n\treturn nil\n}\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.103515625,
          "content": "module github.com/kardianos/service\n\ngo 1.12\n\nrequire golang.org/x/sys v0.0.0-20201015000850-e3ed0017c211\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.2021484375,
          "content": "golang.org/x/sys v0.0.0-20201015000850-e3ed0017c211 h1:9UQO31fZ+0aKQOFldThf7BKPMJTiBfWycGh/u3UoO88=\ngolang.org/x/sys v0.0.0-20201015000850-e3ed0017c211/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n"
        },
        {
          "name": "linux-test-su.sh",
          "type": "blob",
          "size": 0.349609375,
          "content": "#!/usr/bin/env bash\n# This script is used to run the tests under linux as root\n#\n# Usage:\n#    linux-test-su.sh goPath goBinPath\n#\n# goPath is the standard GOPATH\n# goBinPath is the location of go\n#\n# Typical usage:\n#    sudo ./linux-test-su.sh $GOPATH `which go`\n\nexport GOPATH=$1\nexport GOROOT=`dirname $(dirname $2)`\n$GOROOT/bin/go test -v -tags su ./...\n"
        },
        {
          "name": "linux_test",
          "type": "tree",
          "content": null
        },
        {
          "name": "name_test.go",
          "type": "blob",
          "size": 0.4296875,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestPlatformName(t *testing.T) {\n\tgot := Platform()\n\tt.Logf(\"Platform is %v\", got)\n\twantPrefix := runtime.GOOS + \"-\"\n\tif !strings.HasPrefix(got, wantPrefix) {\n\t\tt.Errorf(\"Platform() want: /^%s.*$/, got: %s\", wantPrefix, got)\n\t}\n}\n"
        },
        {
          "name": "service.go",
          "type": "blob",
          "size": 15.1982421875,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\n// Package service provides a simple way to create a system service.\n// Currently supports Windows, Linux/(systemd | Upstart | SysV | OpenRC), and OSX/Launchd.\n//\n// Windows controls services by setting up callbacks that is non-trivial. This\n// is very different then other systems. This package provides the same API\n// despite the substantial differences.\n// It also can be used to detect how a program is called, from an interactive\n// terminal or from a service manager.\n//\n// Examples in the example/ folder.\n//\n//\tpackage main\n//\n//\timport (\n//\t\t\"log\"\n//\n//\t\t\"github.com/kardianos/service\"\n//\t)\n//\n//\tvar logger service.Logger\n//\n//\ttype program struct{}\n//\n//\tfunc (p *program) Start(s service.Service) error {\n//\t\t// Start should not block. Do the actual work async.\n//\t\tgo p.run()\n//\t\treturn nil\n//\t}\n//\tfunc (p *program) run() {\n//\t\t// Do work here\n//\t}\n//\tfunc (p *program) Stop(s service.Service) error {\n//\t\t// Stop should not block. Return with a few seconds.\n//\t\treturn nil\n//\t}\n//\n//\tfunc main() {\n//\t\tsvcConfig := &service.Config{\n//\t\t\tName:        \"GoServiceTest\",\n//\t\t\tDisplayName: \"Go Service Test\",\n//\t\t\tDescription: \"This is a test Go service.\",\n//\t\t}\n//\n//\t\tprg := &program{}\n//\t\ts, err := service.New(prg, svcConfig)\n//\t\tif err != nil {\n//\t\t\tlog.Fatal(err)\n//\t\t}\n//\t\tlogger, err = s.Logger(nil)\n//\t\tif err != nil {\n//\t\t\tlog.Fatal(err)\n//\t\t}\n//\t\terr = s.Run()\n//\t\tif err != nil {\n//\t\t\tlogger.Error(err)\n//\t\t}\n//\t}\npackage service // import \"github.com/kardianos/service\"\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nconst (\n\toptionKeepAlive            = \"KeepAlive\"\n\toptionKeepAliveDefault     = true\n\toptionRunAtLoad            = \"RunAtLoad\"\n\toptionRunAtLoadDefault     = false\n\toptionUserService          = \"UserService\"\n\toptionUserServiceDefault   = false\n\toptionSessionCreate        = \"SessionCreate\"\n\toptionSessionCreateDefault = false\n\toptionLogOutput            = \"LogOutput\"\n\toptionLogOutputDefault     = false\n\toptionPrefix               = \"Prefix\"\n\toptionPrefixDefault        = \"application\"\n\n\toptionRunWait            = \"RunWait\"\n\toptionReloadSignal       = \"ReloadSignal\"\n\toptionPIDFile            = \"PIDFile\"\n\toptionLimitNOFILE        = \"LimitNOFILE\"\n\toptionLimitNOFILEDefault = -1 // -1 = don't set in configuration\n\toptionRestart            = \"Restart\"\n\n\toptionSuccessExitStatus = \"SuccessExitStatus\"\n\n\toptionSystemdScript = \"SystemdScript\"\n\toptionSysvScript    = \"SysvScript\"\n\toptionRCSScript     = \"RCSScript\"\n\toptionUpstartScript = \"UpstartScript\"\n\toptionLaunchdConfig = \"LaunchdConfig\"\n\toptionOpenRCScript  = \"OpenRCScript\"\n\n\toptionLogDirectory = \"LogDirectory\"\n)\n\n// Status represents service status as an byte value\ntype Status byte\n\n// Status of service represented as an byte\nconst (\n\tStatusUnknown Status = iota // Status is unable to be determined due to an error or it was not installed.\n\tStatusRunning\n\tStatusStopped\n)\n\n// Config provides the setup for a Service. The Name field is required.\ntype Config struct {\n\tName        string   // Required name of the service. No spaces suggested.\n\tDisplayName string   // Display name, spaces allowed.\n\tDescription string   // Long description of service.\n\tUserName    string   // Run as username.\n\tArguments   []string // Run with arguments.\n\n\t// Optional field to specify the executable for service.\n\t// If empty the current executable is used.\n\tExecutable string\n\n\t// Array of service dependencies.\n\t// Not yet fully implemented on Linux or OS X:\n\t//  1. Support linux-systemd dependencies, just put each full line as the\n\t//     element of the string array, such as\n\t//     \"After=network.target syslog.target\"\n\t//     \"Requires=syslog.target\"\n\t//     Note, such lines will be directly appended into the [Unit] of\n\t//     the generated service config file, will not check their correctness.\n\tDependencies []string\n\n\t// The following fields are not supported on Windows.\n\tWorkingDirectory string // Initial working directory.\n\tChRoot           string\n\n\t// System specific options.\n\tOption KeyValue\n\n\tEnvVars map[string]string\n}\n\nvar (\n\tsystem         System\n\tsystemRegistry []System\n)\n\nvar (\n\t// ErrNameFieldRequired is returned when Config.Name is empty.\n\tErrNameFieldRequired = errors.New(\"Config.Name field is required.\")\n\t// ErrNoServiceSystemDetected is returned when no system was detected.\n\tErrNoServiceSystemDetected = errors.New(\"No service system detected.\")\n\t// ErrNotInstalled is returned when the service is not installed.\n\tErrNotInstalled = errors.New(\"the service is not installed\")\n)\n\n// New creates a new service based on a service interface and configuration.\nfunc New(i Interface, c *Config) (Service, error) {\n\tif len(c.Name) == 0 {\n\t\treturn nil, ErrNameFieldRequired\n\t}\n\tif system == nil {\n\t\treturn nil, ErrNoServiceSystemDetected\n\t}\n\treturn system.New(i, c)\n}\n\n// KeyValue provides a list of system specific options.\n//\n//   - OS X\n//\n//   - LaunchdConfig string ()                 - Use custom launchd config.\n//\n//   - KeepAlive     bool   (true)             - Prevent the system from stopping the service automatically.\n//\n//   - RunAtLoad     bool   (false)            - Run the service after its job has been loaded.\n//\n//   - SessionCreate bool   (false)            - Create a full user session.\n//\n//   - Solaris\n//\n//   - Prefix        string (\"application\")    - Service FMRI prefix.\n//\n//   - POSIX\n//\n//   - UserService   bool   (false)            - Install as a current user service.\n//\n//   - SystemdScript string ()                 - Use custom systemd script.\n//\n//   - UpstartScript string ()                 - Use custom upstart script.\n//\n//   - SysvScript    string ()                 - Use custom sysv script.\n//\n//   - OpenRCScript  string ()                 - Use custom OpenRC script.\n//\n//   - RunWait       func() (wait for SIGNAL)  - Do not install signal but wait for this function to return.\n//\n//   - ReloadSignal  string () [USR1, ...]     - Signal to send on reload.\n//\n//   - PIDFile       string () [/run/prog.pid] - Location of the PID file.\n//\n//   - LogOutput     bool   (false)            - Redirect StdErr & StandardOutPath to files.\n//\n//   - Restart       string (always)           - How shall service be restarted.\n//\n//   - SuccessExitStatus string ()             - The list of exit status that shall be considered as successful,\n//     in addition to the default ones.\n//\n//   - LogDirectory string(/var/log)           - The path to the log files directory\n//\n//   - Linux (systemd)\n//\n//   - LimitNOFILE   int    (-1)               - Maximum open files (ulimit -n)\n//     (https://serverfault.com/questions/628610/increasing-nproc-for-processes-launched-by-systemd-on-centos-7)\n//\n//   - Windows\n//\n//   - DelayedAutoStart  bool (false)                - After booting, start this service after some delay.\n//\n//   - Password  string ()                           - Password to use when interfacing with the system service manager.\n//\n//   - Interactive       bool (false)                - The service can interact with the desktop. (more information https://docs.microsoft.com/en-us/windows/win32/services/interactive-services)\n//\n//   - DelayedAutoStart        bool (false)          - after booting start this service after some delay.\n//\n//   - StartType               string (\"automatic\")  - Start service type. (automatic | manual | disabled)\n//\n//   - OnFailure               string (\"restart\" )   - Action to perform on service failure. (restart | reboot | noaction)\n//\n//   - OnFailureDelayDuration  string ( \"1s\" )       - Delay before restarting the service, time.Duration string.\n//\n//   - OnFailureResetPeriod    int ( 10 )            - Reset period for errors, seconds.\ntype KeyValue map[string]interface{}\n\n// bool returns the value of the given name, assuming the value is a boolean.\n// If the value isn't found or is not of the type, the defaultValue is returned.\nfunc (kv KeyValue) bool(name string, defaultValue bool) bool {\n\tif v, found := kv[name]; found {\n\t\tif castValue, is := v.(bool); is {\n\t\t\treturn castValue\n\t\t}\n\t}\n\treturn defaultValue\n}\n\n// int returns the value of the given name, assuming the value is an int.\n// If the value isn't found or is not of the type, the defaultValue is returned.\nfunc (kv KeyValue) int(name string, defaultValue int) int {\n\tif v, found := kv[name]; found {\n\t\tif castValue, is := v.(int); is {\n\t\t\treturn castValue\n\t\t}\n\t}\n\treturn defaultValue\n}\n\n// string returns the value of the given name, assuming the value is a string.\n// If the value isn't found or is not of the type, the defaultValue is returned.\nfunc (kv KeyValue) string(name string, defaultValue string) string {\n\tif v, found := kv[name]; found {\n\t\tif castValue, is := v.(string); is {\n\t\t\treturn castValue\n\t\t}\n\t}\n\treturn defaultValue\n}\n\n// float64 returns the value of the given name, assuming the value is a float64.\n// If the value isn't found or is not of the type, the defaultValue is returned.\nfunc (kv KeyValue) float64(name string, defaultValue float64) float64 {\n\tif v, found := kv[name]; found {\n\t\tif castValue, is := v.(float64); is {\n\t\t\treturn castValue\n\t\t}\n\t}\n\treturn defaultValue\n}\n\n// funcSingle returns the value of the given name, assuming the value is a func().\n// If the value isn't found or is not of the type, the defaultValue is returned.\nfunc (kv KeyValue) funcSingle(name string, defaultValue func()) func() {\n\tif v, found := kv[name]; found {\n\t\tif castValue, is := v.(func()); is {\n\t\t\treturn castValue\n\t\t}\n\t}\n\treturn defaultValue\n}\n\n// Platform returns a description of the system service.\nfunc Platform() string {\n\tif system == nil {\n\t\treturn \"\"\n\t}\n\treturn system.String()\n}\n\n// Interactive returns false if running under the OS service manager\n// and true otherwise.\nfunc Interactive() bool {\n\tif system == nil {\n\t\treturn true\n\t}\n\treturn system.Interactive()\n}\n\nfunc newSystem() System {\n\tfor _, choice := range systemRegistry {\n\t\tif choice.Detect() == false {\n\t\t\tcontinue\n\t\t}\n\t\treturn choice\n\t}\n\treturn nil\n}\n\n// ChooseSystem chooses a system from the given system services.\n// SystemServices are considered in the order they are suggested.\n// Calling this may change what Interactive and Platform return.\nfunc ChooseSystem(a ...System) {\n\tsystemRegistry = a\n\tsystem = newSystem()\n}\n\n// ChosenSystem returns the system that service will use.\nfunc ChosenSystem() System {\n\treturn system\n}\n\n// AvailableSystems returns the list of system services considered\n// when choosing the system service.\nfunc AvailableSystems() []System {\n\treturn systemRegistry\n}\n\n// System represents the service manager that is available.\ntype System interface {\n\t// String returns a description of the system.\n\tString() string\n\n\t// Detect returns true if the system is available to use.\n\tDetect() bool\n\n\t// Interactive returns false if running under the system service manager\n\t// and true otherwise.\n\tInteractive() bool\n\n\t// New creates a new service for this system.\n\tNew(i Interface, c *Config) (Service, error)\n}\n\n// Interface represents the service interface for a program. Start runs before\n// the hosting process is granted control and Stop runs when control is returned.\n//\n//  1. OS service manager executes user program.\n//  2. User program sees it is executed from a service manager (IsInteractive is false).\n//  3. User program calls Service.Run() which blocks.\n//  4. Interface.Start() is called and quickly returns.\n//  5. User program runs.\n//  6. OS service manager signals the user program to stop.\n//  7. Interface.Stop() is called and quickly returns.\n//     - For a successful exit, os.Exit should not be called in Interface.Stop().\n//  8. Service.Run returns.\n//  9. User program should quickly exit.\ntype Interface interface {\n\t// Start provides a place to initiate the service. The service doesn't\n\t// signal a completed start until after this function returns, so the\n\t// Start function must not take more then a few seconds at most.\n\tStart(s Service) error\n\n\t// Stop provides a place to clean up program execution before it is terminated.\n\t// It should not take more then a few seconds to execute.\n\t// Stop should not call os.Exit directly in the function.\n\tStop(s Service) error\n}\n\n// Shutdowner represents a service interface for a program that differentiates between \"stop\" and\n// \"shutdown\". A shutdown is triggered when the whole box (not just the service) is stopped.\ntype Shutdowner interface {\n\tInterface\n\t// Shutdown provides a place to clean up program execution when the system is being shutdown.\n\t// It is essentially the same as Stop but for the case where machine is being shutdown/restarted\n\t// instead of just normally stopping the service. Stop won't be called when Shutdown is.\n\tShutdown(s Service) error\n}\n\n// TODO: Add Configure to Service interface.\n\n// Service represents a service that can be run or controlled.\ntype Service interface {\n\t// Run should be called shortly after the program entry point.\n\t// After Interface.Stop has finished running, Run will stop blocking.\n\t// After Run stops blocking, the program must exit shortly after.\n\tRun() error\n\n\t// Start signals to the OS service manager the given service should start.\n\tStart() error\n\n\t// Stop signals to the OS service manager the given service should stop.\n\tStop() error\n\n\t// Restart signals to the OS service manager the given service should stop then start.\n\tRestart() error\n\n\t// Install setups up the given service in the OS service manager. This may require\n\t// greater rights. Will return an error if it is already installed.\n\tInstall() error\n\n\t// Uninstall removes the given service from the OS service manager. This may require\n\t// greater rights. Will return an error if the service is not present.\n\tUninstall() error\n\n\t// Opens and returns a system logger. If the user program is running\n\t// interactively rather then as a service, the returned logger will write to\n\t// os.Stderr. If errs is non-nil errors will be sent on errs as well as\n\t// returned from Logger's functions.\n\tLogger(errs chan<- error) (Logger, error)\n\n\t// SystemLogger opens and returns a system logger. If errs is non-nil errors\n\t// will be sent on errs as well as returned from Logger's functions.\n\tSystemLogger(errs chan<- error) (Logger, error)\n\n\t// String displays the name of the service. The display name if present,\n\t// otherwise the name.\n\tString() string\n\n\t// Platform displays the name of the system that manages the service.\n\t// In most cases this will be the same as service.Platform().\n\tPlatform() string\n\n\t// Status returns the current service status.\n\tStatus() (Status, error)\n}\n\n// ControlAction list valid string texts to use in Control.\nvar ControlAction = [5]string{\"start\", \"stop\", \"restart\", \"install\", \"uninstall\"}\n\n// Control issues control functions to the service from a given action string.\nfunc Control(s Service, action string) error {\n\tvar err error\n\tswitch action {\n\tcase ControlAction[0]:\n\t\terr = s.Start()\n\tcase ControlAction[1]:\n\t\terr = s.Stop()\n\tcase ControlAction[2]:\n\t\terr = s.Restart()\n\tcase ControlAction[3]:\n\t\terr = s.Install()\n\tcase ControlAction[4]:\n\t\terr = s.Uninstall()\n\tdefault:\n\t\terr = fmt.Errorf(\"Unknown action %s\", action)\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to %s %v: %v\", action, s, err)\n\t}\n\treturn nil\n}\n\n// Logger writes to the system log.\ntype Logger interface {\n\tError(v ...interface{}) error\n\tWarning(v ...interface{}) error\n\tInfo(v ...interface{}) error\n\n\tErrorf(format string, a ...interface{}) error\n\tWarningf(format string, a ...interface{}) error\n\tInfof(format string, a ...interface{}) error\n}\n"
        },
        {
          "name": "service_aix.go",
          "type": "blob",
          "size": 5.1513671875,
          "content": "//go:build aix\n// +build aix\n\n// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"text/template\"\n\t\"time\"\n)\n\nconst maxPathSize = 32 * 1024\n\nconst version = \"aix-ssrc\"\n\ntype aixSystem struct{}\n\nfunc (aixSystem) String() string {\n\treturn version\n}\nfunc (aixSystem) Detect() bool {\n\treturn true\n}\nfunc (aixSystem) Interactive() bool {\n\treturn interactive\n}\nfunc (aixSystem) New(i Interface, c *Config) (Service, error) {\n\ts := &aixService{\n\t\ti:      i,\n\t\tConfig: c,\n\t}\n\n\treturn s, nil\n}\n\nfunc getArgsFromPid(pid int) string {\n\tcmd := exec.Command(\"ps\", \"-o\", \"args\", \"-p\", strconv.Itoa(pid))\n\tvar out bytes.Buffer\n\tcmd.Stdout = &out\n\tif err := cmd.Run(); err == nil {\n\t\tlines := strings.Split(out.String(), \"\\n\")\n\t\tif len(lines) > 1 {\n\t\t\treturn strings.TrimSpace(lines[1])\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc init() {\n\tChooseSystem(aixSystem{})\n}\n\nvar interactive = false\n\nfunc init() {\n\tvar err error\n\tinteractive, err = isInteractive()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc isInteractive() (bool, error) {\n\t// The parent process of a service process should be srcmstr.\n\treturn getArgsFromPid(os.Getppid()) != \"/usr/sbin/srcmstr\", nil\n}\n\ntype aixService struct {\n\ti Interface\n\t*Config\n}\n\nfunc (s *aixService) String() string {\n\tif len(s.DisplayName) > 0 {\n\t\treturn s.DisplayName\n\t}\n\treturn s.Name\n}\n\nfunc (s *aixService) Platform() string {\n\treturn version\n}\n\nfunc (s *aixService) template() *template.Template {\n\tfunctions := template.FuncMap{\n\t\t\"bool\": func(v bool) string {\n\t\t\tif v {\n\t\t\t\treturn \"true\"\n\t\t\t}\n\t\t\treturn \"false\"\n\t\t},\n\t}\n\n\tcustomConfig := s.Option.string(optionSysvScript, \"\")\n\n\tif customConfig != \"\" {\n\t\treturn template.Must(template.New(\"\").Funcs(functions).Parse(customConfig))\n\t} else {\n\t\treturn template.Must(template.New(\"\").Funcs(functions).Parse(svcConfig))\n\t}\n}\n\nfunc (s *aixService) configPath() (cp string, err error) {\n\tcp = \"/etc/rc.d/init.d/\" + s.Config.Name\n\treturn\n}\n\nfunc (s *aixService) Install() error {\n\t// install service\n\tpath, err := s.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = run(\"mkssys\", \"-s\", s.Name, \"-p\", path, \"-u\", \"0\", \"-R\", \"-Q\", \"-S\", \"-n\", \"15\", \"-f\", \"9\", \"-d\", \"-w\", \"30\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// write start script\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = os.Stat(confPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"Init already exists: %s\", confPath)\n\t}\n\n\tf, err := os.Create(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tvar to = &struct {\n\t\t*Config\n\t\tPath string\n\t}{\n\t\ts.Config,\n\t\tpath,\n\t}\n\n\terr = s.template().Execute(f, to)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(confPath, 0755); err != nil {\n\t\treturn err\n\t}\n\trcd := \"/etc/rc\"\n\tif _, err = os.Stat(\"/etc/rc.d/rc2.d\"); err == nil {\n\t\trcd = \"/etc/rc.d/rc\"\n\t}\n\tfor _, i := range [...]string{\"2\", \"3\"} {\n\t\tif err = os.Symlink(confPath, rcd+i+\".d/S50\"+s.Name); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err = os.Symlink(confPath, rcd+i+\".d/K02\"+s.Name); err != nil {\n\t\t\tcontinue\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (s *aixService) Uninstall() error {\n\ts.Stop()\n\n\terr := run(\"rmssys\", \"-s\", s.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(confPath)\n}\n\nfunc (s *aixService) Status() (Status, error) {\n\texitCode, out, err := runWithOutput(\"lssrc\", \"-s\", s.Name)\n\tif exitCode == 0 && err != nil {\n\t\tif !strings.Contains(err.Error(), \"failed with stderr\") {\n\t\t\treturn StatusUnknown, err\n\t\t}\n\t}\n\n\tre := regexp.MustCompile(`\\s+` + s.Name + `\\s+(\\w+\\s+)?(\\d+\\s+)?(\\w+)`)\n\tmatches := re.FindStringSubmatch(out)\n\tif len(matches) == 4 {\n\t\tstatus := string(matches[3])\n\t\tif status == \"inoperative\" {\n\t\t\treturn StatusStopped, nil\n\t\t} else if status == \"active\" {\n\t\t\treturn StatusRunning, nil\n\t\t} else {\n\t\t\tfmt.Printf(\"Got unknown service status %s\\n\", status)\n\t\t\treturn StatusUnknown, err\n\t\t}\n\t}\n\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\n\tif _, err = os.Stat(confPath); err == nil {\n\t\treturn StatusStopped, nil\n\t}\n\n\treturn StatusUnknown, ErrNotInstalled\n}\n\nfunc (s *aixService) Start() error {\n\treturn run(\"startsrc\", \"-s\", s.Name)\n}\nfunc (s *aixService) Stop() error {\n\treturn run(\"stopsrc\", \"-s\", s.Name)\n}\nfunc (s *aixService) Restart() error {\n\terr := s.Stop()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(50 * time.Millisecond)\n\treturn s.Start()\n}\n\nfunc (s *aixService) Run() error {\n\tvar err error\n\n\terr = s.i.Start(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Option.funcSingle(optionRunWait, func() {\n\t\tvar sigChan = make(chan os.Signal, 3)\n\t\tsignal.Notify(sigChan, syscall.SIGTERM, os.Interrupt)\n\t\t<-sigChan\n\t})()\n\n\treturn s.i.Stop(s)\n}\n\nfunc (s *aixService) Logger(errs chan<- error) (Logger, error) {\n\tif interactive {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn s.SystemLogger(errs)\n}\nfunc (s *aixService) SystemLogger(errs chan<- error) (Logger, error) {\n\treturn newSysLogger(s.Name, errs)\n}\n\nvar svcConfig = `#!/bin/ksh\ncase \"$1\" in\nstart )\n        startsrc -s {{.Name}}\n        ;;\nstop )\n        stopsrc -s {{.Name}}\n        ;;\n* )\n        echo \"Usage: $0 (start | stop)\"\n        exit 1\nesac\n`\n"
        },
        {
          "name": "service_darwin.go",
          "type": "blob",
          "size": 7.2099609375,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"syscall\"\n\t\"text/template\"\n\t\"time\"\n)\n\nconst maxPathSize = 32 * 1024\n\nconst (\n\tversion                   = \"darwin-launchd\"\n\tdefaultDarwinLogDirectory = \"/var/log\"\n)\n\ntype darwinSystem struct{}\n\nfunc (darwinSystem) String() string {\n\treturn version\n}\n\nfunc (darwinSystem) Detect() bool {\n\treturn true\n}\n\nfunc (darwinSystem) Interactive() bool {\n\treturn interactive\n}\n\nfunc (darwinSystem) New(i Interface, c *Config) (Service, error) {\n\ts := &darwinLaunchdService{\n\t\ti:      i,\n\t\tConfig: c,\n\n\t\tuserService: c.Option.bool(optionUserService, optionUserServiceDefault),\n\t}\n\n\treturn s, nil\n}\n\nfunc init() {\n\tChooseSystem(darwinSystem{})\n}\n\nvar interactive = false\n\nfunc init() {\n\tvar err error\n\tinteractive, err = isInteractive()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc isInteractive() (bool, error) {\n\t// TODO: The PPID of Launchd is 1. The PPid of a service process should match launchd's PID.\n\treturn os.Getppid() != 1, nil\n}\n\ntype darwinLaunchdService struct {\n\ti Interface\n\t*Config\n\n\tuserService bool\n}\n\nfunc (s *darwinLaunchdService) String() string {\n\tif len(s.DisplayName) > 0 {\n\t\treturn s.DisplayName\n\t}\n\treturn s.Name\n}\n\nfunc (s *darwinLaunchdService) Platform() string {\n\treturn version\n}\n\nfunc (s *darwinLaunchdService) getHomeDir() (string, error) {\n\tu, err := user.Current()\n\tif err == nil {\n\t\treturn u.HomeDir, nil\n\t}\n\n\t// alternate methods\n\thomeDir := os.Getenv(\"HOME\") // *nix\n\tif homeDir == \"\" {\n\t\treturn \"\", errors.New(\"User home directory not found.\")\n\t}\n\treturn homeDir, nil\n}\n\nfunc (s *darwinLaunchdService) getServiceFilePath() (string, error) {\n\tif s.userService {\n\t\thomeDir, err := s.getHomeDir()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn homeDir + \"/Library/LaunchAgents/\" + s.Name + \".plist\", nil\n\t}\n\treturn \"/Library/LaunchDaemons/\" + s.Name + \".plist\", nil\n}\n\nfunc (s *darwinLaunchdService) logDir() (string, error) {\n\tif customDir := s.Option.string(optionLogDirectory, \"\"); customDir != \"\" {\n\t\treturn customDir, nil\n\t}\n\tif !s.userService {\n\t\treturn defaultDarwinLogDirectory, nil\n\t}\n\treturn s.getHomeDir()\n}\n\nfunc (s *darwinLaunchdService) getLogPaths() (string, string, error) {\n\tlogDir, err := s.logDir()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn s.getLogPath(logDir, \"out\"), s.getLogPath(logDir, \"err\"), nil\n}\n\nfunc (s *darwinLaunchdService) getLogPath(logDir, logType string) string {\n\treturn fmt.Sprintf(\"%s/%s.%s.log\", logDir, s.Name, logType)\n}\n\nfunc (s *darwinLaunchdService) template() *template.Template {\n\tfunctions := template.FuncMap{\n\t\t\"bool\": func(v bool) string {\n\t\t\tif v {\n\t\t\t\treturn \"true\"\n\t\t\t}\n\t\t\treturn \"false\"\n\t\t},\n\t}\n\n\tcustomConfig := s.Option.string(optionLaunchdConfig, \"\")\n\n\tif customConfig != \"\" {\n\t\treturn template.Must(template.New(\"\").Funcs(functions).Parse(customConfig))\n\t}\n\treturn template.Must(template.New(\"\").Funcs(functions).Parse(launchdConfig))\n}\n\nfunc (s *darwinLaunchdService) Install() error {\n\tconfPath, err := s.getServiceFilePath()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = os.Stat(confPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"Init already exists: %s\", confPath)\n\t}\n\n\tif s.userService {\n\t\t// Ensure that ~/Library/LaunchAgents exists.\n\t\terr = os.MkdirAll(filepath.Dir(confPath), 0700)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tf, err := os.Create(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tpath, err := s.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstdOutPath, stdErrPath, _ := s.getLogPaths()\n\tvar to = &struct {\n\t\t*Config\n\t\tPath string\n\n\t\tKeepAlive, RunAtLoad bool\n\t\tSessionCreate        bool\n\t\tStandardOutPath      string\n\t\tStandardErrorPath    string\n\t}{\n\t\tConfig:            s.Config,\n\t\tPath:              path,\n\t\tKeepAlive:         s.Option.bool(optionKeepAlive, optionKeepAliveDefault),\n\t\tRunAtLoad:         s.Option.bool(optionRunAtLoad, optionRunAtLoadDefault),\n\t\tSessionCreate:     s.Option.bool(optionSessionCreate, optionSessionCreateDefault),\n\t\tStandardOutPath:   stdOutPath,\n\t\tStandardErrorPath: stdErrPath,\n\t}\n\n\treturn s.template().Execute(f, to)\n}\n\nfunc (s *darwinLaunchdService) Uninstall() error {\n\ts.Stop()\n\n\tconfPath, err := s.getServiceFilePath()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(confPath)\n}\n\nfunc (s *darwinLaunchdService) Status() (Status, error) {\n\texitCode, out, err := runWithOutput(\"launchctl\", \"list\", s.Name)\n\tif exitCode == 0 && err != nil {\n\t\tif !strings.Contains(err.Error(), \"failed with stderr\") {\n\t\t\treturn StatusUnknown, err\n\t\t}\n\t}\n\n\tre := regexp.MustCompile(`\"PID\" = ([0-9]+);`)\n\tmatches := re.FindStringSubmatch(out)\n\tif len(matches) == 2 {\n\t\treturn StatusRunning, nil\n\t}\n\n\tconfPath, err := s.getServiceFilePath()\n\tif err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\n\tif _, err = os.Stat(confPath); err == nil {\n\t\treturn StatusStopped, nil\n\t}\n\n\treturn StatusUnknown, ErrNotInstalled\n}\n\nfunc (s *darwinLaunchdService) Start() error {\n\tconfPath, err := s.getServiceFilePath()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn run(\"launchctl\", \"load\", confPath)\n}\n\nfunc (s *darwinLaunchdService) Stop() error {\n\tconfPath, err := s.getServiceFilePath()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn run(\"launchctl\", \"unload\", confPath)\n}\n\nfunc (s *darwinLaunchdService) Restart() error {\n\terr := s.Stop()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(50 * time.Millisecond)\n\treturn s.Start()\n}\n\nfunc (s *darwinLaunchdService) Run() error {\n\terr := s.i.Start(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Option.funcSingle(optionRunWait, func() {\n\t\tvar sigChan = make(chan os.Signal, 3)\n\t\tsignal.Notify(sigChan, syscall.SIGTERM, os.Interrupt)\n\t\t<-sigChan\n\t})()\n\n\treturn s.i.Stop(s)\n}\n\nfunc (s *darwinLaunchdService) Logger(errs chan<- error) (Logger, error) {\n\tif interactive {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn s.SystemLogger(errs)\n}\n\nfunc (s *darwinLaunchdService) SystemLogger(errs chan<- error) (Logger, error) {\n\treturn newSysLogger(s.Name, errs)\n}\n\nvar launchdConfig = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>Disabled</key>\n\t<false/>\n\t{{- if .EnvVars}}\n\t<key>EnvironmentVariables</key>\n\t<dict>\n\t\t{{- range $k, $v := .EnvVars}}\n\t\t<key>{{html $k}}</key>\n\t\t<string>{{html $v}}</string>\n\t\t{{- end}}\n\t</dict>\n\t{{- end}}\n\t<key>KeepAlive</key>\n\t<{{bool .KeepAlive}}/>\n\t<key>Label</key>\n\t<string>{{html .Name}}</string>\n\t<key>ProgramArguments</key>\n\t<array>\n\t\t<string>{{html .Path}}</string>\n\t\t{{- if .Config.Arguments}}\n\t\t{{- range .Config.Arguments}}\n\t\t<string>{{html .}}</string>\n\t\t{{- end}}\n\t{{- end}}\n\t</array>\n\t{{- if .ChRoot}}\n\t<key>RootDirectory</key>\n\t<string>{{html .ChRoot}}</string>\n\t{{- end}}\n\t<key>RunAtLoad</key>\n\t<{{bool .RunAtLoad}}/>\n\t<key>SessionCreate</key>\n\t<{{bool .SessionCreate}}/>\n\t{{- if .StandardErrorPath}}\n\t<key>StandardErrorPath</key>\n\t<string>{{html .StandardErrorPath}}</string>\n\t{{- end}}\n\t{{- if .StandardOutPath}}\n\t<key>StandardOutPath</key>\n\t<string>{{html .StandardOutPath}}</string>\n\t{{- end}}\n\t{{- if .UserName}}\n\t<key>UserName</key>\n\t<string>{{html .UserName}}</string>\n\t{{- end}}\n\t{{- if .WorkingDirectory}}\n\t<key>WorkingDirectory</key>\n\t<string>{{html .WorkingDirectory}}</string>\n\t{{- end}}\n</dict>\n</plist>\n`\n"
        },
        {
          "name": "service_freebsd.go",
          "type": "blob",
          "size": 4.0498046875,
          "content": "// Copyright 2019 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"text/template\"\n)\n\nconst version = \"freebsd\"\nconst configDir = \"/usr/local/etc/rc.d\"\n\ntype freebsdSystem struct{}\n\nfunc (freebsdSystem) String() string {\n\treturn version\n}\nfunc (freebsdSystem) Detect() bool {\n\treturn true\n}\nfunc (freebsdSystem) Interactive() bool {\n\treturn interactive\n}\nfunc (freebsdSystem) New(i Interface, c *Config) (Service, error) {\n\ts := &freebsdService{\n\t\ti:      i,\n\t\tConfig: c,\n\t}\n\n\treturn s, nil\n}\n\nfunc init() {\n\tChooseSystem(freebsdSystem{})\n}\n\nvar interactive = false\n\nfunc init() {\n\tvar err error\n\tinteractive, err = isInteractive()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc isInteractive() (bool, error) {\n\treturn os.Getenv(\"IS_DAEMON\") != \"1\", nil\n}\n\ntype freebsdService struct {\n\ti Interface\n\t*Config\n}\n\nfunc (s *freebsdService) String() string {\n\tif len(s.DisplayName) > 0 {\n\t\treturn s.DisplayName\n\t}\n\treturn s.Name\n}\n\nfunc (s *freebsdService) Platform() string {\n\treturn version\n}\n\nfunc (s *freebsdService) template() *template.Template {\n\tfunctions := template.FuncMap{\n\t\t\"bool\": func(v bool) string {\n\t\t\tif v {\n\t\t\t\treturn \"true\"\n\t\t\t}\n\t\t\treturn \"false\"\n\t\t},\n\t}\n\n\tcustomConfig := s.Option.string(optionSysvScript, \"\")\n\n\tif customConfig != \"\" {\n\t\treturn template.Must(template.New(\"\").Funcs(functions).Parse(customConfig))\n\t} else {\n\t\treturn template.Must(template.New(\"\").Funcs(functions).Parse(rcScript))\n\t}\n}\n\nfunc (s *freebsdService) configPath() (cp string, err error) {\n\tif oserr := os.MkdirAll(configDir, 0755); oserr != nil {\n\t\terr = oserr\n\t\treturn\n\t}\n\tcp = filepath.Join(configDir, s.Config.Name)\n\treturn\n}\n\nfunc (s *freebsdService) Install() error {\n\tpath, err := s.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// write start script\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = os.Stat(confPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"Init already exists: %s\", confPath)\n\t}\n\n\tf, err := os.Create(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tvar to = &struct {\n\t\t*Config\n\t\tPath string\n\t}{\n\t\ts.Config,\n\t\tpath,\n\t}\n\n\terr = s.template().Execute(f, to)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(confPath, 0755); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *freebsdService) Uninstall() error {\n\tcp, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(cp)\n}\n\nfunc (s *freebsdService) Status() (Status, error) {\n\tcp, err := s.configPath()\n\tif err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\n\tif _, err = os.Stat(cp); os.IsNotExist(err) {\n\t\treturn StatusStopped, ErrNotInstalled\n\t}\n\n\tstatus, _, err := runCommand(\"service\", false, s.Name, \"status\")\n\tif status == 1 {\n\t\treturn StatusStopped, nil\n\t} else if err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\treturn StatusRunning, nil\n}\n\nfunc (s *freebsdService) Start() error {\n\treturn run(\"service\", s.Name, \"start\")\n}\n\nfunc (s *freebsdService) Stop() error {\n\treturn run(\"service\", s.Name, \"stop\")\n}\n\nfunc (s *freebsdService) Restart() error {\n\treturn run(\"service\", s.Name, \"restart\")\n}\n\nfunc (s *freebsdService) Run() error {\n\tvar err error\n\n\terr = s.i.Start(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Option.funcSingle(optionRunWait, func() {\n\t\tvar sigChan = make(chan os.Signal, 3)\n\t\tsignal.Notify(sigChan, syscall.SIGTERM, os.Interrupt)\n\t\t<-sigChan\n\t})()\n\n\treturn s.i.Stop(s)\n}\n\nfunc (s *freebsdService) Logger(errs chan<- error) (Logger, error) {\n\tif interactive {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn s.SystemLogger(errs)\n}\n\nfunc (s *freebsdService) SystemLogger(errs chan<- error) (Logger, error) {\n\treturn newSysLogger(s.Name, errs)\n}\n\nvar rcScript = `#!/bin/sh\n\n# PROVIDE: {{.Name}}\n# REQUIRE: SERVERS\n# KEYWORD: shutdown\n\n. /etc/rc.subr\n\nname=\"{{.Name}}\"\n{{.Name}}_env=\"IS_DAEMON=1\"\npidfile=\"/var/run/${name}.pid\"\ncommand=\"/usr/sbin/daemon\"\ndaemon_args=\"-P ${pidfile} -r -t \\\"${name}: daemon\\\"{{if .WorkingDirectory}} -c {{.WorkingDirectory}}{{end}}\"\ncommand_args=\"${daemon_args} {{.Path}}{{range .Arguments}} {{.}}{{end}}\"\n\nrun_rc_command \"$1\"\n`\n"
        },
        {
          "name": "service_go1.8.go",
          "type": "blob",
          "size": 0.220703125,
          "content": "//go:build go1.8\n// +build go1.8\n\npackage service\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc (c *Config) execPath() (string, error) {\n\tif len(c.Executable) != 0 {\n\t\treturn filepath.Abs(c.Executable)\n\t}\n\treturn os.Executable()\n}\n"
        },
        {
          "name": "service_linux.go",
          "type": "blob",
          "size": 3.080078125,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\nvar cgroupFile = \"/proc/1/cgroup\"\n\ntype linuxSystemService struct {\n\tname        string\n\tdetect      func() bool\n\tinteractive func() bool\n\tnew         func(i Interface, platform string, c *Config) (Service, error)\n}\n\nfunc (sc linuxSystemService) String() string {\n\treturn sc.name\n}\nfunc (sc linuxSystemService) Detect() bool {\n\treturn sc.detect()\n}\nfunc (sc linuxSystemService) Interactive() bool {\n\treturn sc.interactive()\n}\nfunc (sc linuxSystemService) New(i Interface, c *Config) (Service, error) {\n\treturn sc.new(i, sc.String(), c)\n}\n\nfunc init() {\n\tChooseSystem(linuxSystemService{\n\t\tname:   \"linux-systemd\",\n\t\tdetect: isSystemd,\n\t\tinteractive: func() bool {\n\t\t\tis, _ := isInteractive()\n\t\t\treturn is\n\t\t},\n\t\tnew: newSystemdService,\n\t},\n\t\tlinuxSystemService{\n\t\t\tname:   \"linux-upstart\",\n\t\t\tdetect: isUpstart,\n\t\t\tinteractive: func() bool {\n\t\t\t\tis, _ := isInteractive()\n\t\t\t\treturn is\n\t\t\t},\n\t\t\tnew: newUpstartService,\n\t\t},\n\t\tlinuxSystemService{\n\t\t\tname:   \"linux-openrc\",\n\t\t\tdetect: isOpenRC,\n\t\t\tinteractive: func() bool {\n\t\t\t\tis, _ := isInteractive()\n\t\t\t\treturn is\n\t\t\t},\n\t\t\tnew: newOpenRCService,\n\t\t},\n\t\tlinuxSystemService{\n\t\t\tname:   \"linux-rcs\",\n\t\t\tdetect: isRCS,\n\t\t\tinteractive: func() bool {\n\t\t\t\tis, _ := isInteractive()\n\t\t\t\treturn is\n\t\t\t},\n\t\t\tnew: newRCSService,\n\t\t},\n\t\tlinuxSystemService{\n\t\t\tname:   \"unix-systemv\",\n\t\t\tdetect: func() bool { return true },\n\t\t\tinteractive: func() bool {\n\t\t\t\tis, _ := isInteractive()\n\t\t\t\treturn is\n\t\t\t},\n\t\t\tnew: newSystemVService,\n\t\t},\n\t)\n}\n\nfunc binaryName(pid int) (string, error) {\n\tstatPath := fmt.Sprintf(\"/proc/%d/stat\", pid)\n\tdataBytes, err := ioutil.ReadFile(statPath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// First, parse out the image name\n\tdata := string(dataBytes)\n\tbinStart := strings.IndexRune(data, '(') + 1\n\tbinEnd := strings.IndexRune(data[binStart:], ')')\n\treturn data[binStart : binStart+binEnd], nil\n}\n\nfunc isInteractive() (bool, error) {\n\tinContainer, err := isInContainer(cgroupFile)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif inContainer {\n\t\treturn true, nil\n\t}\n\n\tppid := os.Getppid()\n\tif ppid == 1 {\n\t\treturn false, nil\n\t}\n\n\tbinary, _ := binaryName(ppid)\n\treturn binary != \"systemd\", nil\n}\n\n// isInContainer checks if the service is being executed in docker or lxc\n// container.\nfunc isInContainer(cgroupPath string) (bool, error) {\n\tconst maxlines = 5 // maximum lines to scan\n\n\tf, err := os.Open(cgroupPath)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer f.Close()\n\tscan := bufio.NewScanner(f)\n\n\tlines := 0\n\tfor scan.Scan() && !(lines > maxlines) {\n\t\tif strings.Contains(scan.Text(), \"docker\") || strings.Contains(scan.Text(), \"lxc\") {\n\t\t\treturn true, nil\n\t\t}\n\t\tlines++\n\t}\n\tif err := scan.Err(); err != nil {\n\t\treturn false, err\n\t}\n\n\treturn false, nil\n}\n\nvar tf = map[string]interface{}{\n\t\"cmd\": func(s string) string {\n\t\treturn `\"` + strings.Replace(s, `\"`, `\\\"`, -1) + `\"`\n\t},\n\t\"cmdEscape\": func(s string) string {\n\t\treturn strings.Replace(s, \" \", `\\x20`, -1)\n\t},\n}\n"
        },
        {
          "name": "service_linux_test.go",
          "type": "blob",
          "size": 4.2392578125,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\n// createTestCgroupFiles creates mock files for tests\nfunc createTestCgroupFiles() (*os.File, *os.File, error) {\n\t// docker cgroup setup\n\thDockerGrp, err := ioutil.TempFile(\"\", \"*\")\n\tif err != nil {\n\t\treturn nil, nil, errors.New(\"docker tempfile create failed\")\n\t}\n\t_, err = hDockerGrp.Write([]byte(dockerCgroup))\n\tif err != nil {\n\t\treturn nil, nil, errors.New(\"docker tempfile write failed\")\n\t}\n\n\t// linux cgroup setup\n\thLinuxGrp, err := ioutil.TempFile(\"\", \"*\")\n\tif err != nil {\n\t\treturn nil, nil, errors.New(\"\\\"normal\\\" tempfile  create failed\")\n\t}\n\t_, err = hLinuxGrp.Write([]byte(linuxCgroup))\n\tif err != nil {\n\t\treturn nil, nil, errors.New(\"\\\"normal\\\" tempfile write failed\")\n\t}\n\n\treturn hDockerGrp, hLinuxGrp, nil\n}\n\n// removeTestFile closes and removes the provided file\nfunc removeTestFile(hFile *os.File) {\n\thFile.Close()\n\tos.Remove(hFile.Name())\n}\n\nfunc Test_isInContainer(t *testing.T) {\n\n\t// setup\n\thDockerGrp, hLinuxGrp, err := createTestCgroupFiles()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\t// tear down\n\t\tremoveTestFile(hDockerGrp)\n\t\tremoveTestFile(hLinuxGrp)\n\t}()\n\n\t// TEST\n\ttype args struct {\n\t\tcgroupPath string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t{\"docker\", args{hDockerGrp.Name()}, true, false},\n\t\t{\"linux\", args{hLinuxGrp.Name()}, false, false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := isInContainer(tt.args.cgroupPath)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"isInContainer() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"isInContainer() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_isInteractive(t *testing.T) {\n\n\t// setup\n\thDockerGrp, hLinuxGrp, err := createTestCgroupFiles()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\t// tear down\n\t\tremoveTestFile(hDockerGrp)\n\t\tremoveTestFile(hLinuxGrp)\n\t}()\n\n\t// stack emulation for before() and after() for storing global values\n\tstrStack := make(chan string, 4)\n\n\t// TEST\n\ttests := []struct {\n\t\tname    string\n\t\tbefore  func()\n\t\tafter   func()\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t{\"docker\",\n\t\t\tfunc() {\n\t\t\t\tstrStack <- cgroupFile\n\t\t\t\tcgroupFile = hDockerGrp.Name()\n\t\t\t},\n\t\t\tfunc() {\n\t\t\t\tcgroupFile = <-strStack\n\t\t\t},\n\t\t\ttrue, false,\n\t\t},\n\t\t{\"linux\",\n\t\t\tfunc() {\n\t\t\t\tstrStack <- cgroupFile\n\t\t\t\tcgroupFile = hLinuxGrp.Name()\n\t\t\t},\n\t\t\tfunc() {\n\t\t\t\tcgroupFile = <-strStack\n\t\t\t},\n\t\t\ttrue, false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.before()\n\t\t\tgot, err := isInteractive()\n\t\t\ttt.after()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"isInteractive() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"isInteractive() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nconst (\n\tdockerCgroup = `13:name=systemd:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n12:pids:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n11:hugetlb:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n10:net_prio:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n9:perf_event:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n8:net_cls:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n7:freezer:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n6:devices:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n5:memory:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n4:blkio:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n3:cpuacct:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n2:cpu:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee\n1:cpuset:/docker/bc9f0894926991e3064b731c26d86af6df7390c0e6453e6027f9545aba5809ee`\n\n\tlinuxCgroup = `11:cpuset:/\n10:pids:/init.scope\n9:perf_event:/\n8:memory:/init.scope\n7:blkio:/\n6:devices:/init.scope\n5:rdma:/\n4:net_cls,net_prio:/\n3:freezer:/\n2:cpu,cpuacct:/\n1:name=systemd:/init.scope\n0::/init.scope`\n)\n"
        },
        {
          "name": "service_nosu_test.go",
          "type": "blob",
          "size": 0.35546875,
          "content": "// Copyright 2016 Lawrence Woodman <lwoodman@vlifesystems.com>\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\n//go:build !su\n// +build !su\n\npackage service_test\n\nimport \"testing\"\n\nfunc TestInstallRunRestartStopRemove(t *testing.T) {\n\tt.Skip(\"skipping test as not running as root/admin (Build tag: su)\")\n}\n"
        },
        {
          "name": "service_openrc_linux.go",
          "type": "blob",
          "size": 4.888671875,
          "content": "package service\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"syscall\"\n\t\"text/template\"\n\t\"time\"\n)\n\nfunc isOpenRC() bool {\n\tif _, err := exec.LookPath(\"openrc-init\"); err == nil {\n\t\treturn true\n\t}\n\tif _, err := os.Stat(\"/etc/inittab\"); err == nil {\n\t\tfilerc, err := os.Open(\"/etc/inittab\")\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tdefer filerc.Close()\n\n\t\tbuf := new(bytes.Buffer)\n\t\tbuf.ReadFrom(filerc)\n\t\tcontents := buf.String()\n\n\t\tre := regexp.MustCompile(`::sysinit:.*openrc.*sysinit`)\n\t\tmatches := re.FindStringSubmatch(contents)\n\t\tif len(matches) > 0 {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn false\n}\n\ntype openrc struct {\n\ti        Interface\n\tplatform string\n\t*Config\n}\n\nfunc (s *openrc) String() string {\n\tif len(s.DisplayName) > 0 {\n\t\treturn s.DisplayName\n\t}\n\treturn s.Name\n}\n\nfunc (s *openrc) Platform() string {\n\treturn s.platform\n}\n\nfunc (s *openrc) template() *template.Template {\n\tcustomScript := s.Option.string(optionOpenRCScript, \"\")\n\n\tif customScript != \"\" {\n\t\treturn template.Must(template.New(\"\").Funcs(tf).Parse(customScript))\n\t}\n\treturn template.Must(template.New(\"\").Funcs(tf).Parse(openRCScript))\n}\n\nfunc newOpenRCService(i Interface, platform string, c *Config) (Service, error) {\n\ts := &openrc{\n\t\ti:        i,\n\t\tplatform: platform,\n\t\tConfig:   c,\n\t}\n\treturn s, nil\n}\n\nvar errNoUserServiceOpenRC = errors.New(\"user services are not supported on OpenRC\")\n\nfunc (s *openrc) configPath() (cp string, err error) {\n\tif s.Option.bool(optionUserService, optionUserServiceDefault) {\n\t\terr = errNoUserServiceOpenRC\n\t\treturn\n\t}\n\tcp = \"/etc/init.d/\" + s.Config.Name\n\treturn\n}\n\nfunc (s *openrc) Install() error {\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = os.Stat(confPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"Init already exists: %s\", confPath)\n\t}\n\n\tf, err := os.Create(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\terr = os.Chmod(confPath, 0755)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpath, err := s.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar to = &struct {\n\t\t*Config\n\t\tPath         string\n\t\tLogDirectory string\n\t}{\n\t\ts.Config,\n\t\tpath,\n\t\ts.Option.string(optionLogDirectory, defaultLogDirectory),\n\t}\n\n\terr = s.template().Execute(f, to)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// run rc-update\n\treturn s.runAction(\"add\")\n}\n\nfunc (s *openrc) Uninstall() error {\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.Remove(confPath); err != nil {\n\t\treturn err\n\t}\n\treturn s.runAction(\"delete\")\n}\n\nfunc (s *openrc) Logger(errs chan<- error) (Logger, error) {\n\tif system.Interactive() {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn s.SystemLogger(errs)\n}\n\nfunc (s *openrc) SystemLogger(errs chan<- error) (Logger, error) {\n\treturn newSysLogger(s.Name, errs)\n}\n\nfunc (s *openrc) Run() (err error) {\n\terr = s.i.Start(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Option.funcSingle(optionRunWait, func() {\n\t\tvar sigChan = make(chan os.Signal, 3)\n\t\tsignal.Notify(sigChan, syscall.SIGTERM, os.Interrupt)\n\t\t<-sigChan\n\t})()\n\n\treturn s.i.Stop(s)\n}\n\nfunc (s *openrc) Status() (Status, error) {\n\t// rc-service uses the errno library for its exit codes:\n\t// errno 0 = service started\n\t// errno 1 = EPERM 1 Operation not permitted\n\t// errno 2 = ENOENT 2 No such file or directory\n\t// errno 3 = ESRCH 3 No such process\n\t// for more info, see https://man7.org/linux/man-pages/man3/errno.3.html\n\t_, out, err := runWithOutput(\"rc-service\", s.Name, \"status\")\n\tif err != nil {\n\t\tif exiterr, ok := err.(*exec.ExitError); ok {\n\t\t\t// The program has exited with an exit code != 0\n\t\t\texitCode := exiterr.ExitCode()\n\t\t\tswitch {\n\t\t\tcase exitCode == 1:\n\t\t\t\treturn StatusUnknown, err\n\t\t\tcase exitCode == 2:\n\t\t\t\treturn StatusUnknown, ErrNotInstalled\n\t\t\tcase exitCode == 3:\n\t\t\t\treturn StatusStopped, nil\n\t\t\tdefault:\n\t\t\t\treturn StatusUnknown, fmt.Errorf(\"unknown error: %v - %v\", out, err)\n\t\t\t}\n\t\t} else {\n\t\t\treturn StatusUnknown, err\n\t\t}\n\t}\n\treturn StatusRunning, nil\n}\n\nfunc (s *openrc) Start() error {\n\treturn run(\"rc-service\", s.Name, \"start\")\n}\n\nfunc (s *openrc) Stop() error {\n\treturn run(\"rc-service\", s.Name, \"stop\")\n}\n\nfunc (s *openrc) Restart() error {\n\terr := s.Stop()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(50 * time.Millisecond)\n\treturn s.Start()\n}\n\nfunc (s *openrc) runAction(action string) error {\n\treturn s.run(action, s.Name)\n}\n\nfunc (s *openrc) run(action string, args ...string) error {\n\treturn run(\"rc-update\", append([]string{action}, args...)...)\n}\n\nconst openRCScript = `#!/sbin/openrc-run\nsupervisor=supervise-daemon\nname=\"{{.DisplayName}}\"\ndescription=\"{{.Description}}\"\ncommand={{.Path|cmdEscape}}\n{{- if .Arguments }}\ncommand_args=\"{{range .Arguments}}{{.}} {{end}}\"\n{{- end }}\nname=$(basename $(readlink -f $command))\nsupervise_daemon_args=\"--stdout {{.LogDirectory}}/${name}.log --stderr {{.LogDirectory}}/${name}.err\"\n\n{{range $k, $v := .EnvVars -}}\nexport {{$k}}={{$v}}\n{{end -}}\n\n{{- if .Dependencies }}\ndepend() {\n{{- range $i, $dep := .Dependencies}} \n{{\"\\t\"}}{{$dep}}{{end}}\n}\n{{- end}}\n`\n"
        },
        {
          "name": "service_rcs_linux.go",
          "type": "blob",
          "size": 6.09375,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strings\"\n\t\"syscall\"\n\t\"text/template\"\n\t\"time\"\n)\n\ntype rcs struct {\n\ti        Interface\n\tplatform string\n\t*Config\n}\n\nfunc isRCS() bool {\n\tif _, err := os.Stat(\"/etc/init.d/rcS\"); err != nil {\n\t\treturn false\n\t}\n\tif _, err := exec.LookPath(\"service\"); err == nil {\n\t\treturn false\n\t}\n\tif _, err := os.Stat(\"/etc/inittab\"); err == nil {\n\t\tfilerc, err := os.Open(\"/etc/inittab\")\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tdefer filerc.Close()\n\n\t\tbuf := new(bytes.Buffer)\n\t\tbuf.ReadFrom(filerc)\n\t\tcontents := buf.String()\n\n\t\tre := regexp.MustCompile(`::sysinit:.*rcS`)\n\t\tmatches := re.FindStringSubmatch(contents)\n\t\tif len(matches) > 0 {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn false\n}\n\nfunc newRCSService(i Interface, platform string, c *Config) (Service, error) {\n\ts := &rcs{\n\t\ti:        i,\n\t\tplatform: platform,\n\t\tConfig:   c,\n\t}\n\n\treturn s, nil\n}\n\nfunc (s *rcs) String() string {\n\tif len(s.DisplayName) > 0 {\n\t\treturn s.DisplayName\n\t}\n\treturn s.Name\n}\n\nfunc (s *rcs) Platform() string {\n\treturn s.platform\n}\n\n// todo\nvar errNoUserServiceRCS = errors.New(\"User services are not supported on rcS.\")\n\nfunc (s *rcs) configPath() (cp string, err error) {\n\tif s.Option.bool(optionUserService, optionUserServiceDefault) {\n\t\terr = errNoUserServiceRCS\n\t\treturn\n\t}\n\tcp = \"/etc/init.d/\" + s.Config.Name\n\treturn\n}\n\nfunc (s *rcs) template() *template.Template {\n\tcustomScript := s.Option.string(optionRCSScript, \"\")\n\n\tif customScript != \"\" {\n\t\treturn template.Must(template.New(\"\").Funcs(tf).Parse(customScript))\n\t}\n\treturn template.Must(template.New(\"\").Funcs(tf).Parse(rcsScript))\n}\n\nfunc (s *rcs) Install() error {\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = os.Stat(confPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"Init already exists: %s\", confPath)\n\t}\n\n\tf, err := os.Create(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tpath, err := s.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar to = &struct {\n\t\t*Config\n\t\tPath         string\n\t\tLogDirectory string\n\t}{\n\t\ts.Config,\n\t\tpath,\n\t\ts.Option.string(optionLogDirectory, defaultLogDirectory),\n\t}\n\n\terr = s.template().Execute(f, to)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(confPath, 0755); err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Symlink(confPath, \"/etc/rc.d/S50\"+s.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *rcs) Uninstall() error {\n\tcp, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.Remove(cp); err != nil {\n\t\treturn err\n\t}\n\tif err := os.Remove(\"/etc/rc.d/S50\" + s.Name); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *rcs) Logger(errs chan<- error) (Logger, error) {\n\tif system.Interactive() {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn s.SystemLogger(errs)\n}\nfunc (s *rcs) SystemLogger(errs chan<- error) (Logger, error) {\n\treturn newSysLogger(s.Name, errs)\n}\n\nfunc (s *rcs) Run() (err error) {\n\terr = s.i.Start(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Option.funcSingle(optionRunWait, func() {\n\t\tvar sigChan = make(chan os.Signal, 3)\n\t\tsignal.Notify(sigChan, syscall.SIGTERM, os.Interrupt)\n\t\t<-sigChan\n\t})()\n\n\treturn s.i.Stop(s)\n}\n\nfunc (s *rcs) Status() (Status, error) {\n\t_, out, err := runWithOutput(\"/etc/init.d/\"+s.Name, \"status\")\n\tif err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\n\tswitch {\n\tcase strings.HasPrefix(out, \"Running\"):\n\t\treturn StatusRunning, nil\n\tcase strings.HasPrefix(out, \"Stopped\"):\n\t\treturn StatusStopped, nil\n\tdefault:\n\t\treturn StatusUnknown, ErrNotInstalled\n\t}\n}\n\nfunc (s *rcs) Start() error {\n\treturn run(\"/etc/init.d/\"+s.Name, \"start\")\n}\n\nfunc (s *rcs) Stop() error {\n\treturn run(\"/etc/init.d/\"+s.Name, \"stop\")\n}\n\nfunc (s *rcs) Restart() error {\n\terr := s.Stop()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(50 * time.Millisecond)\n\treturn s.Start()\n}\n\nconst rcsScript = `#!/bin/sh\n# For RedHat and cousins:\n# chkconfig: - 99 01\n# description: {{.Description}}\n# processname: {{.Path}}\n\n### BEGIN INIT INFO\n# Provides:          {{.Path}}\n# Required-Start:\n# Required-Stop:\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: {{.DisplayName}}\n# Description:       {{.Description}}\n### END INIT INFO\n\ncmd=\"{{.Path}}{{range .Arguments}} {{.|cmd}}{{end}}\"\n\nname={{.Name}}\npid_file=\"/var/run/$name.pid\"\nstdout_log=\"{{.LogDirectory}}/$name.log\"\nstderr_log=\"{{.LogDirectory}}/$name.err\"\n\n[ -e /etc/sysconfig/$name ] && . /etc/sysconfig/$name\n\nget_pid() {\n    cat \"$pid_file\"\n}\n\nis_running() {\n    [ -f \"$pid_file\" ] && cat /proc/$(get_pid)/stat > /dev/null 2>&1\n}\n\ncase \"$1\" in\n    start)\n        if is_running; then\n            echo \"Already started\"\n        else\n            echo \"Starting $name\"\n            {{if .WorkingDirectory}}cd '{{.WorkingDirectory}}'{{end}}\n            $cmd >> \"$stdout_log\" 2>> \"$stderr_log\" &\n            echo $! > \"$pid_file\"\n            if ! is_running; then\n                echo \"Unable to start, see $stdout_log and $stderr_log\"\n                exit 1\n            fi\n        fi\n    ;;\n    stop)\n        if is_running; then\n            echo -n \"Stopping $name..\"\n            kill $(get_pid)\n            for i in $(seq 1 10)\n            do\n                if ! is_running; then\n                    break\n                fi\n                echo -n \".\"\n                sleep 1\n            done\n            echo\n            if is_running; then\n                echo \"Not stopped; may still be shutting down or shutdown may have failed\"\n                exit 1\n            else\n                echo \"Stopped\"\n                if [ -f \"$pid_file\" ]; then\n                    rm \"$pid_file\"\n                fi\n            fi\n        else\n            echo \"Not running\"\n        fi\n    ;;\n    restart)\n        $0 stop\n        if is_running; then\n            echo \"Unable to stop, will not attempt to start\"\n            exit 1\n        fi\n        $0 start\n    ;;\n    status)\n        if is_running; then\n            echo \"Running\"\n        else\n            echo \"Stopped\"\n            exit 1\n        fi\n    ;;\n    *)\n    echo \"Usage: $0 {start|stop|restart|status}\"\n    exit 1\n    ;;\nesac\nexit 0\n`\n"
        },
        {
          "name": "service_solaris.go",
          "type": "blob",
          "size": 5.84765625,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"syscall\"\n\t\"text/template\"\n\t\"time\"\n)\n\nconst maxPathSize = 32 * 1024\n\nconst version = \"solaris-smf\"\n\ntype solarisSystem struct{}\n\nfunc (solarisSystem) String() string {\n\treturn version\n}\nfunc (solarisSystem) Detect() bool {\n\treturn true\n}\nfunc (solarisSystem) Interactive() bool {\n\treturn interactive\n}\nfunc (solarisSystem) New(i Interface, c *Config) (Service, error) {\n\ts := &solarisService{\n\t\ti:      i,\n\t\tConfig: c,\n\n\t\tPrefix: c.Option.string(optionPrefix, optionPrefixDefault),\n\t}\n\n\treturn s, nil\n}\n\nfunc init() {\n\tChooseSystem(solarisSystem{})\n}\n\nvar interactive = false\n\nfunc init() {\n\tvar err error\n\tinteractive, err = isInteractive()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc isInteractive() (bool, error) {\n\t// The PPid of a service process be 1 / init.\n\treturn os.Getppid() != 1, nil\n}\n\ntype solarisService struct {\n\ti Interface\n\t*Config\n\n\tPrefix string\n}\n\nfunc (s *solarisService) String() string {\n\tif len(s.DisplayName) > 0 {\n\t\treturn s.DisplayName\n\t}\n\treturn s.Name\n}\n\nfunc (s *solarisService) Platform() string {\n\treturn version\n}\n\nfunc (s *solarisService) template() *template.Template {\n\tfunctions := template.FuncMap{\n\t\t\"bool\": func(v bool) string {\n\t\t\tif v {\n\t\t\t\treturn \"true\"\n\t\t\t}\n\t\t\treturn \"false\"\n\t\t},\n\t}\n\n\tcustomConfig := s.Option.string(optionSysvScript, \"\")\n\n\tif customConfig != \"\" {\n\t\treturn template.Must(template.New(\"\").Funcs(functions).Parse(customConfig))\n\t} else {\n\t\treturn template.Must(template.New(\"\").Funcs(functions).Parse(manifest))\n\t}\n}\n\nfunc (s *solarisService) configPath() (string, error) {\n\treturn \"/lib/svc/manifest/\" + s.Prefix + \"/\" + s.Config.Name + \".xml\", nil\n}\n\nfunc (s *solarisService) getFMRI() string {\n\treturn \"svc:/\" + s.Prefix + \"/\" + s.Config.Name + \":default\"\n}\n\nfunc (s *solarisService) Install() error {\n\t// write start script\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = os.Stat(confPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"Manifest already exists: %s\", confPath)\n\t}\n\n\tf, err := os.Create(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tpath, err := s.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\tDisplay := \"\"\n\tescaped := &bytes.Buffer{}\n\tif err := xml.EscapeText(escaped, []byte(s.DisplayName)); err == nil {\n\t\tDisplay = escaped.String()\n\t}\n\tvar to = &struct {\n\t\t*Config\n\t\tPrefix  string\n\t\tDisplay string\n\t\tPath    string\n\t}{\n\t\ts.Config,\n\t\ts.Prefix,\n\t\tDisplay,\n\t\tpath,\n\t}\n\n\terr = s.template().Execute(f, to)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// import service\n\terr = run(\"svcadm\", \"restart\", \"manifest-import\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *solarisService) Uninstall() error {\n\ts.Stop()\n\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = os.Remove(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// unregister service\n\terr = run(\"svcadm\", \"restart\", \"manifest-import\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *solarisService) Status() (Status, error) {\n\tfmri := s.getFMRI()\n\texitCode, out, err := runWithOutput(\"svcs\", fmri)\n\tif exitCode != 0 {\n\t\treturn StatusUnknown, ErrNotInstalled\n\t}\n\n\tre := regexp.MustCompile(`(degraded|disabled|legacy_run|maintenance|offline|online)\\s+\\w+` + fmri)\n\tmatches := re.FindStringSubmatch(out)\n\tif len(matches) == 2 {\n\t\tstatus := string(matches[1])\n\t\tif status == \"online\" {\n\t\t\treturn StatusRunning, nil\n\t\t} else {\n\t\t\treturn StatusStopped, nil\n\t\t}\n\t}\n\treturn StatusUnknown, err\n}\n\nfunc (s *solarisService) Start() error {\n\treturn run(\"/usr/sbin/svcadm\", \"enable\", s.getFMRI())\n}\nfunc (s *solarisService) Stop() error {\n\treturn run(\"/usr/sbin/svcadm\", \"disable\", s.getFMRI())\n}\nfunc (s *solarisService) Restart() error {\n\terr := s.Stop()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(50 * time.Millisecond)\n\treturn s.Start()\n}\n\nfunc (s *solarisService) Run() error {\n\tvar err error\n\n\terr = s.i.Start(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Option.funcSingle(optionRunWait, func() {\n\t\tvar sigChan = make(chan os.Signal, 3)\n\t\tsignal.Notify(sigChan, syscall.SIGTERM, os.Interrupt)\n\t\t<-sigChan\n\t})()\n\n\treturn s.i.Stop(s)\n}\n\nfunc (s *solarisService) Logger(errs chan<- error) (Logger, error) {\n\tif interactive {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn s.SystemLogger(errs)\n}\nfunc (s *solarisService) SystemLogger(errs chan<- error) (Logger, error) {\n\treturn newSysLogger(s.Name, errs)\n}\n\nvar manifest = `<?xml version=\"1.0\"?>\n<!DOCTYPE service_bundle SYSTEM \"/usr/share/lib/xml/dtd/service_bundle.dtd.1\">\n\n<service_bundle type='manifest' name='golang-{{.Name}}'>\n<service\n\tname='{{.Prefix}}/{{.Name}}'\n\ttype='service'\n\tversion='1'>\n\t\n\t<create_default_instance enabled='false' />\n\n\t<single_instance />\n\n\t<!--\n\t  Wait for network interfaces to be initialized.\n\t-->\n\t<dependency name='network'\n\t    grouping='require_all'\n\t    restart_on='restart'\n\t    type='service'>\n\t    <service_fmri value='svc:/milestone/network:default'/>\n\t</dependency>\n\n\t<!--\n\t  Wait for all local filesystems to be mounted.\n\t-->\n\t<dependency name='filesystem-local'\n\t    grouping='require_all'\n\t    restart_on='none'\n\t    type='service'>\n\t    <service_fmri\n\t\tvalue='svc:/system/filesystem/local:default'/>\n\t</dependency>\n\n\t<exec_method\n\t\ttype='method'\n\t\tname='start'\n\t\texec='bash -c {{.Path}} &amp;'\n\t\ttimeout_seconds='10' />\n\n\t<exec_method\n\t\ttype='method'\n\t\tname='stop'\n\t\texec='pkill -TERM -f {{.Path}}'\n\t\ttimeout_seconds='60' />\n\n\t<!--\n\t<property_group name='startd' type='framework'>\n                <propval name='duration' type='astring' value='transient' />\n        </property_group>\n\t-->\n\t\n\t<stability value='Unstable' />\n\n\t<template>\n                <common_name>\n                        <loctext xml:lang='C'>\n                                {{.Display}}\n                        </loctext>\n                </common_name>\n        </template>\n</service>\n\n</service_bundle>\n`\n"
        },
        {
          "name": "service_su_test.go",
          "type": "blob",
          "size": 3.6181640625,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\n// This needs to be run as root/admin hence the reason there is a build tag\n//go:build su\n// +build su\n\npackage service_test\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/kardianos/service\"\n)\n\nconst runAsServiceArg = \"RunThisAsService\"\n\nfunc TestMain(m *testing.M) {\n\treportDir := flag.String(\"su.reportDir\", \"\", \"\")\n\trunAsService := flag.Bool(\"su.runAsService\", false, \"\")\n\tflag.Parse()\n\tif !*runAsService {\n\t\tos.Exit(m.Run())\n\t}\n\tif len(*reportDir) == 0 {\n\t\tlog.Fatal(\"missing su.reportDir argument\")\n\t}\n\twriteReport(*reportDir, \"call\")\n\trunService()\n\twriteReport(*reportDir, \"finished\")\n}\n\nfunc TestInstallRunRestartStopRemove(t *testing.T) {\n\tp := &program{}\n\treportDir := mustTempDir(t)\n\tdefer os.RemoveAll(reportDir)\n\n\ts := mustNewRunAsService(t, p, reportDir)\n\t_ = s.Uninstall()\n\n\tif err := s.Install(); err != nil {\n\t\tt.Fatal(\"Install\", err)\n\t}\n\tdefer s.Uninstall()\n\n\tif err := s.Start(); err != nil {\n\t\tt.Fatal(\"Start\", err)\n\t}\n\tdefer s.Stop()\n\tcheckReport(t, reportDir, \"Start()\", 1, 0)\n\n\tif err := s.Restart(); err != nil {\n\t\tt.Fatal(\"restart\", err)\n\t}\n\n\tcheckReport(t, reportDir, \"Restart()\", 2, 1)\n\tp.numStopped = 0\n\tif err := s.Stop(); err != nil {\n\t\tt.Fatal(\"stop\", err)\n\t}\n\tcheckReport(t, reportDir, \"Stop()\", 2, 2)\n\n\tif err := s.Uninstall(); err != nil {\n\t\tt.Fatal(\"uninstall\", err)\n\t}\n}\n\nfunc runService() {\n\tp := &program{}\n\tsc := &service.Config{\n\t\tName: \"go_service_test\",\n\t}\n\ts, err := service.New(p, sc)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err = s.Run(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc mustTempDir(t *testing.T) string {\n\tdir, err := ioutil.TempDir(\"\", \"servicetest\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn dir\n}\n\nfunc writeReport(reportDir string, action string) {\n\tb := []byte(\"go_test_service_report\")\n\ttimeStamp := time.Now().UnixNano()\n\terr := ioutil.WriteFile(\n\t\tfilepath.Join(reportDir, fmt.Sprintf(\"%d-%s\", timeStamp, action)),\n\t\tb,\n\t\t0644,\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nvar matchActionRegexp = regexp.MustCompile(\"^(\\\\d+-)([a-z]*)$\")\n\nfunc getReport(\n\tt *testing.T,\n\treportDir string,\n) (numCalls int, numFinished int) {\n\tnumCalls = 0\n\tnumFinished = 0\n\tfiles, err := ioutil.ReadDir(reportDir)\n\tif err != nil {\n\t\tt.Fatalf(\"ReadDir(%s) err: %s\", reportDir, err)\n\t}\n\n\tfor _, file := range files {\n\t\tif matchActionRegexp.MatchString(file.Name()) {\n\t\t\taction := matchActionRegexp.ReplaceAllString(file.Name(), \"$2\")\n\t\t\tswitch action {\n\t\t\tcase \"call\":\n\t\t\t\tnumCalls++\n\t\t\tcase \"finished\":\n\t\t\t\tnumFinished++\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"getReport() found report with incorrect action: %s\", action)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc checkReport(\n\tt *testing.T,\n\treportDir string,\n\tmsgPrefix string,\n\twantNumCalled int,\n\twantNumFinished int,\n) {\n\tvar numCalled int\n\tvar numFinished int\n\tfor i := 0; i < 25; i++ {\n\t\tnumCalled, numFinished = getReport(t, reportDir)\n\t\t<-time.After(200 * time.Millisecond)\n\t\tif numCalled == wantNumCalled && numFinished == wantNumFinished {\n\t\t\treturn\n\t\t}\n\t}\n\tif numCalled != wantNumCalled {\n\t\tt.Fatalf(\"%s - numCalled: %d, want %d\",\n\t\t\tmsgPrefix, numCalled, wantNumCalled)\n\t}\n\tif numFinished != wantNumFinished {\n\t\tt.Fatalf(\"%s - numFinished: %d, want %d\",\n\t\t\tmsgPrefix, numFinished, wantNumFinished)\n\t}\n}\n\nfunc mustNewRunAsService(\n\tt *testing.T,\n\tp *program,\n\treportDir string,\n) service.Service {\n\tsc := &service.Config{\n\t\tName:      \"go_service_test\",\n\t\tArguments: []string{\"-test.v=true\", \"-su.runAsService\", \"-su.reportDir\", reportDir},\n\t}\n\ts, err := service.New(p, sc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn s\n}\n"
        },
        {
          "name": "service_systemd_linux.go",
          "type": "blob",
          "size": 7.2744140625,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"text/template\"\n)\n\nfunc isSystemd() bool {\n\tif _, err := os.Stat(\"/run/systemd/system\"); err == nil {\n\t\treturn true\n\t}\n\tif _, err := exec.LookPath(\"systemctl\"); err != nil {\n\t\treturn false\n\t}\n\tif _, err := os.Stat(\"/proc/1/comm\"); err == nil {\n\t\tfilerc, err := os.Open(\"/proc/1/comm\")\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tdefer filerc.Close()\n\n\t\tbuf := new(bytes.Buffer)\n\t\tbuf.ReadFrom(filerc)\n\t\tcontents := buf.String()\n\n\t\tif strings.Trim(contents, \" \\r\\n\") == \"systemd\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\ntype systemd struct {\n\ti        Interface\n\tplatform string\n\t*Config\n}\n\nfunc newSystemdService(i Interface, platform string, c *Config) (Service, error) {\n\ts := &systemd{\n\t\ti:        i,\n\t\tplatform: platform,\n\t\tConfig:   c,\n\t}\n\n\treturn s, nil\n}\n\nfunc (s *systemd) String() string {\n\tif len(s.DisplayName) > 0 {\n\t\treturn s.DisplayName\n\t}\n\treturn s.Name\n}\n\nfunc (s *systemd) Platform() string {\n\treturn s.platform\n}\n\nfunc (s *systemd) configPath() (cp string, err error) {\n\tif !s.isUserService() {\n\t\tcp = \"/etc/systemd/system/\" + s.unitName()\n\t\treturn\n\t}\n\thomeDir, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn\n\t}\n\tsystemdUserDir := filepath.Join(homeDir, \".config/systemd/user\")\n\terr = os.MkdirAll(systemdUserDir, os.ModePerm)\n\tif err != nil {\n\t\treturn\n\t}\n\tcp = filepath.Join(systemdUserDir, s.unitName())\n\treturn\n}\n\nfunc (s *systemd) unitName() string {\n\treturn s.Config.Name + \".service\"\n}\n\nfunc (s *systemd) getSystemdVersion() int64 {\n\t_, out, err := s.runWithOutput(\"systemctl\", \"--version\")\n\tif err != nil {\n\t\treturn -1\n\t}\n\n\tre := regexp.MustCompile(`systemd ([0-9]+)`)\n\tmatches := re.FindStringSubmatch(out)\n\tif len(matches) != 2 {\n\t\treturn -1\n\t}\n\n\tv, err := strconv.ParseInt(matches[1], 10, 64)\n\tif err != nil {\n\t\treturn -1\n\t}\n\n\treturn v\n}\n\nfunc (s *systemd) hasOutputFileSupport() bool {\n\tdefaultValue := true\n\tversion := s.getSystemdVersion()\n\tif version == -1 {\n\t\treturn defaultValue\n\t}\n\n\tif version < 236 {\n\t\treturn false\n\t}\n\n\treturn defaultValue\n}\n\nfunc (s *systemd) template() *template.Template {\n\tcustomScript := s.Option.string(optionSystemdScript, \"\")\n\n\tif customScript != \"\" {\n\t\treturn template.Must(template.New(\"\").Funcs(tf).Parse(customScript))\n\t}\n\treturn template.Must(template.New(\"\").Funcs(tf).Parse(systemdScript))\n}\n\nfunc (s *systemd) isUserService() bool {\n\treturn s.Option.bool(optionUserService, optionUserServiceDefault)\n}\n\nfunc (s *systemd) Install() error {\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = os.Stat(confPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"Init already exists: %s\", confPath)\n\t}\n\n\tf, err := os.OpenFile(confPath, os.O_WRONLY|os.O_CREATE, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tpath, err := s.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar to = &struct {\n\t\t*Config\n\t\tPath                 string\n\t\tHasOutputFileSupport bool\n\t\tReloadSignal         string\n\t\tPIDFile              string\n\t\tLimitNOFILE          int\n\t\tRestart              string\n\t\tSuccessExitStatus    string\n\t\tLogOutput            bool\n\t\tLogDirectory         string\n\t}{\n\t\ts.Config,\n\t\tpath,\n\t\ts.hasOutputFileSupport(),\n\t\ts.Option.string(optionReloadSignal, \"\"),\n\t\ts.Option.string(optionPIDFile, \"\"),\n\t\ts.Option.int(optionLimitNOFILE, optionLimitNOFILEDefault),\n\t\ts.Option.string(optionRestart, \"always\"),\n\t\ts.Option.string(optionSuccessExitStatus, \"\"),\n\t\ts.Option.bool(optionLogOutput, optionLogOutputDefault),\n\t\ts.Option.string(optionLogDirectory, defaultLogDirectory),\n\t}\n\n\terr = s.template().Execute(f, to)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = s.runAction(\"enable\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn s.run(\"daemon-reload\")\n}\n\nfunc (s *systemd) Uninstall() error {\n\terr := s.runAction(\"disable\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tcp, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.Remove(cp); err != nil {\n\t\treturn err\n\t}\n\treturn s.run(\"daemon-reload\")\n}\n\nfunc (s *systemd) Logger(errs chan<- error) (Logger, error) {\n\tif system.Interactive() {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn s.SystemLogger(errs)\n}\nfunc (s *systemd) SystemLogger(errs chan<- error) (Logger, error) {\n\treturn newSysLogger(s.Name, errs)\n}\n\nfunc (s *systemd) Run() (err error) {\n\terr = s.i.Start(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Option.funcSingle(optionRunWait, func() {\n\t\tvar sigChan = make(chan os.Signal, 3)\n\t\tsignal.Notify(sigChan, syscall.SIGTERM, os.Interrupt)\n\t\t<-sigChan\n\t})()\n\n\treturn s.i.Stop(s)\n}\n\nfunc (s *systemd) Status() (Status, error) {\n\texitCode, out, err := s.runWithOutput(\"systemctl\", \"is-active\", s.unitName())\n\tif exitCode == 0 && err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\n\tswitch {\n\tcase strings.HasPrefix(out, \"active\"):\n\t\treturn StatusRunning, nil\n\tcase strings.HasPrefix(out, \"inactive\"):\n\t\t// inactive can also mean its not installed, check unit files\n\t\texitCode, out, err := s.runWithOutput(\"systemctl\", \"list-unit-files\", \"-t\", \"service\", s.unitName())\n\t\tif exitCode == 0 && err != nil {\n\t\t\treturn StatusUnknown, err\n\t\t}\n\t\tif strings.Contains(out, s.Name) {\n\t\t\t// unit file exists, installed but not running\n\t\t\treturn StatusStopped, nil\n\t\t}\n\t\t// no unit file\n\t\treturn StatusUnknown, ErrNotInstalled\n\tcase strings.HasPrefix(out, \"activating\"):\n\t\treturn StatusRunning, nil\n\tcase strings.HasPrefix(out, \"failed\"):\n\t\treturn StatusUnknown, errors.New(\"service in failed state\")\n\tdefault:\n\t\treturn StatusUnknown, ErrNotInstalled\n\t}\n}\n\nfunc (s *systemd) Start() error {\n\treturn s.runAction(\"start\")\n}\n\nfunc (s *systemd) Stop() error {\n\treturn s.runAction(\"stop\")\n}\n\nfunc (s *systemd) Restart() error {\n\treturn s.runAction(\"restart\")\n}\n\nfunc (s *systemd) runWithOutput(command string, arguments ...string) (int, string, error) {\n\tif s.isUserService() {\n\t\targuments = append(arguments, \"--user\")\n\t}\n\treturn runWithOutput(command, arguments...)\n}\n\nfunc (s *systemd) run(action string, args ...string) error {\n\tif s.isUserService() {\n\t\treturn run(\"systemctl\", append([]string{action, \"--user\"}, args...)...)\n\t}\n\treturn run(\"systemctl\", append([]string{action}, args...)...)\n}\n\nfunc (s *systemd) runAction(action string) error {\n\treturn s.run(action, s.unitName())\n}\n\nconst systemdScript = `[Unit]\nDescription={{.Description}}\nConditionFileIsExecutable={{.Path|cmdEscape}}\n{{range $i, $dep := .Dependencies}} \n{{$dep}} {{end}}\n\n[Service]\nStartLimitInterval=5\nStartLimitBurst=10\nExecStart={{.Path|cmdEscape}}{{range .Arguments}} {{.|cmd}}{{end}}\n{{if .ChRoot}}RootDirectory={{.ChRoot|cmd}}{{end}}\n{{if .WorkingDirectory}}WorkingDirectory={{.WorkingDirectory|cmdEscape}}{{end}}\n{{if .UserName}}User={{.UserName}}{{end}}\n{{if .ReloadSignal}}ExecReload=/bin/kill -{{.ReloadSignal}} \"$MAINPID\"{{end}}\n{{if .PIDFile}}PIDFile={{.PIDFile|cmd}}{{end}}\n{{if and .LogOutput .HasOutputFileSupport -}}\nStandardOutput=file:{{.LogDirectory}}/{{.Name}}.out\nStandardError=file:{{.LogDirectory}}/{{.Name}}.err\n{{- end}}\n{{if gt .LimitNOFILE -1 }}LimitNOFILE={{.LimitNOFILE}}{{end}}\n{{if .Restart}}Restart={{.Restart}}{{end}}\n{{if .SuccessExitStatus}}SuccessExitStatus={{.SuccessExitStatus}}{{end}}\nRestartSec=120\nEnvironmentFile=-/etc/sysconfig/{{.Name}}\n\n{{range $k, $v := .EnvVars -}}\nEnvironment={{$k}}={{$v}}\n{{end -}}\n\n[Install]\nWantedBy=multi-user.target\n`\n"
        },
        {
          "name": "service_sysv_linux.go",
          "type": "blob",
          "size": 5.7294921875,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\t\"text/template\"\n\t\"time\"\n)\n\ntype sysv struct {\n\ti        Interface\n\tplatform string\n\t*Config\n}\n\nfunc newSystemVService(i Interface, platform string, c *Config) (Service, error) {\n\ts := &sysv{\n\t\ti:        i,\n\t\tplatform: platform,\n\t\tConfig:   c,\n\t}\n\n\treturn s, nil\n}\n\nfunc (s *sysv) String() string {\n\tif len(s.DisplayName) > 0 {\n\t\treturn s.DisplayName\n\t}\n\treturn s.Name\n}\n\nfunc (s *sysv) Platform() string {\n\treturn s.platform\n}\n\nvar errNoUserServiceSystemV = errors.New(\"User services are not supported on SystemV.\")\n\nfunc (s *sysv) configPath() (cp string, err error) {\n\tif s.Option.bool(optionUserService, optionUserServiceDefault) {\n\t\terr = errNoUserServiceSystemV\n\t\treturn\n\t}\n\tcp = \"/etc/init.d/\" + s.Config.Name\n\treturn\n}\n\nfunc (s *sysv) template() *template.Template {\n\tcustomScript := s.Option.string(optionSysvScript, \"\")\n\n\tif customScript != \"\" {\n\t\treturn template.Must(template.New(\"\").Funcs(tf).Parse(customScript))\n\t}\n\treturn template.Must(template.New(\"\").Funcs(tf).Parse(sysvScript))\n}\n\nfunc (s *sysv) Install() error {\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = os.Stat(confPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"Init already exists: %s\", confPath)\n\t}\n\n\tf, err := os.Create(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tpath, err := s.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar to = &struct {\n\t\t*Config\n\t\tPath         string\n\t\tLogDirectory string\n\t}{\n\t\ts.Config,\n\t\tpath,\n\t\ts.Option.string(optionLogDirectory, defaultLogDirectory),\n\t}\n\n\terr = s.template().Execute(f, to)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(confPath, 0755); err != nil {\n\t\treturn err\n\t}\n\tfor _, i := range [...]string{\"2\", \"3\", \"4\", \"5\"} {\n\t\tif err = os.Symlink(confPath, \"/etc/rc\"+i+\".d/S50\"+s.Name); err != nil {\n\t\t\tcontinue\n\t\t}\n\t}\n\tfor _, i := range [...]string{\"0\", \"1\", \"6\"} {\n\t\tif err = os.Symlink(confPath, \"/etc/rc\"+i+\".d/K02\"+s.Name); err != nil {\n\t\t\tcontinue\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (s *sysv) Uninstall() error {\n\tcp, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.Remove(cp); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *sysv) Logger(errs chan<- error) (Logger, error) {\n\tif system.Interactive() {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn s.SystemLogger(errs)\n}\nfunc (s *sysv) SystemLogger(errs chan<- error) (Logger, error) {\n\treturn newSysLogger(s.Name, errs)\n}\n\nfunc (s *sysv) Run() (err error) {\n\terr = s.i.Start(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Option.funcSingle(optionRunWait, func() {\n\t\tvar sigChan = make(chan os.Signal, 3)\n\t\tsignal.Notify(sigChan, syscall.SIGTERM, os.Interrupt)\n\t\t<-sigChan\n\t})()\n\n\treturn s.i.Stop(s)\n}\n\nfunc (s *sysv) Status() (Status, error) {\n\t_, out, err := runWithOutput(\"service\", s.Name, \"status\")\n\tif err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\n\tswitch {\n\tcase strings.HasPrefix(out, \"Running\"):\n\t\treturn StatusRunning, nil\n\tcase strings.HasPrefix(out, \"Stopped\"):\n\t\treturn StatusStopped, nil\n\tdefault:\n\t\treturn StatusUnknown, ErrNotInstalled\n\t}\n}\n\nfunc (s *sysv) Start() error {\n\treturn run(\"service\", s.Name, \"start\")\n}\n\nfunc (s *sysv) Stop() error {\n\treturn run(\"service\", s.Name, \"stop\")\n}\n\nfunc (s *sysv) Restart() error {\n\terr := s.Stop()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(50 * time.Millisecond)\n\treturn s.Start()\n}\n\nconst sysvScript = `#!/bin/sh\n# For RedHat and cousins:\n# chkconfig: - 99 01\n# description: {{.Description}}\n# processname: {{.Path}}\n\n### BEGIN INIT INFO\n# Provides:          {{.Path}}\n# Required-Start:\n# Required-Stop:\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: {{.DisplayName}}\n# Description:       {{.Description}}\n### END INIT INFO\n\ncmd=\"{{.Path}}{{range .Arguments}} {{.|cmd}}{{end}}\"\n\nname=$(basename $(readlink -f $0))\npid_file=\"/var/run/$name.pid\"\nstdout_log=\"{{.LogDirectory}}/$name.log\"\nstderr_log=\"{{.LogDirectory}}/$name.err\"\n\n{{range $k, $v := .EnvVars -}}\nexport {{$k}}={{$v}}\n{{end -}}\n\n[ -e /etc/sysconfig/$name ] && . /etc/sysconfig/$name\n\nget_pid() {\n    cat \"$pid_file\"\n}\n\nis_running() {\n    [ -f \"$pid_file\" ] && cat /proc/$(get_pid)/stat > /dev/null 2>&1\n}\n\ncase \"$1\" in\n    start)\n        if is_running; then\n            echo \"Already started\"\n        else\n            echo \"Starting $name\"\n            {{if .WorkingDirectory}}cd '{{.WorkingDirectory}}'{{end}}\n            $cmd >> \"$stdout_log\" 2>> \"$stderr_log\" &\n            echo $! > \"$pid_file\"\n            if ! is_running; then\n                echo \"Unable to start, see $stdout_log and $stderr_log\"\n                exit 1\n            fi\n        fi\n    ;;\n    stop)\n        if is_running; then\n            echo -n \"Stopping $name..\"\n            kill $(get_pid)\n            for i in $(seq 1 10)\n            do\n                if ! is_running; then\n                    break\n                fi\n                echo -n \".\"\n                sleep 1\n            done\n            echo\n            if is_running; then\n                echo \"Not stopped; may still be shutting down or shutdown may have failed\"\n                exit 1\n            else\n                echo \"Stopped\"\n                if [ -f \"$pid_file\" ]; then\n                    rm \"$pid_file\"\n                fi\n            fi\n        else\n            echo \"Not running\"\n        fi\n    ;;\n    restart)\n        $0 stop\n        if is_running; then\n            echo \"Unable to stop, will not attempt to start\"\n            exit 1\n        fi\n        $0 start\n    ;;\n    status)\n        if is_running; then\n            echo \"Running\"\n        else\n            echo \"Stopped\"\n            exit 1\n        fi\n    ;;\n    *)\n    echo \"Usage: $0 {start|stop|restart|status}\"\n    exit 1\n    ;;\nesac\nexit 0\n`\n"
        },
        {
          "name": "service_test.go",
          "type": "blob",
          "size": 1.5908203125,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/kardianos/service\"\n)\n\nfunc TestRunInterrupt(t *testing.T) {\n\tp := &program{}\n\tsc := &service.Config{\n\t\tName: \"go_service_test\",\n\t}\n\ts, err := service.New(p, sc)\n\tif err != nil {\n\t\tt.Fatalf(\"New err: %s\", err)\n\t}\n\n\tgo func() {\n\t\t<-time.After(1 * time.Second)\n\t\tinterruptProcess(t)\n\t}()\n\n\tgo func() {\n\t\tfor i := 0; i < 25 && p.numStopped == 0; i++ {\n\t\t\t<-time.After(200 * time.Millisecond)\n\t\t}\n\t\tif p.numStopped == 0 {\n\t\t\tt.Fatal(\"Run() hasn't been stopped\")\n\t\t}\n\t}()\n\n\tif err = s.Run(); err != nil {\n\t\tt.Fatalf(\"Run() err: %s\", err)\n\t}\n}\n\nconst testInstallEnv = \"TEST_USER_INSTALL\"\n\n// Should always run, without asking for any permission\nfunc TestUserRunInterrupt(t *testing.T) {\n\tif os.Getenv(testInstallEnv) != \"1\" {\n\t\tt.Skipf(\"env %q is not set to 1\", testInstallEnv)\n\t}\n\tp := &program{}\n\toptions := make(service.KeyValue)\n\toptions[\"UserService\"] = true\n\tsc := &service.Config{\n\t\tName:   \"go_user_service_test\",\n\t\tOption: options,\n\t}\n\ts, err := service.New(p, sc)\n\tif err != nil {\n\t\tt.Fatalf(\"New err: %s\", err)\n\t}\n\terr = s.Install()\n\tif err != nil {\n\t\tt.Errorf(\"Install err: %s\", err)\n\t}\n\terr = s.Uninstall()\n\tif err != nil {\n\t\tt.Fatalf(\"Uninstall err: %s\", err)\n\t}\n}\n\ntype program struct {\n\tnumStopped int\n}\n\nfunc (p *program) Start(s service.Service) error {\n\tgo p.run()\n\treturn nil\n}\nfunc (p *program) run() {\n\t// Do work here\n}\nfunc (p *program) Stop(s service.Service) error {\n\tp.numStopped++\n\treturn nil\n}\n"
        },
        {
          "name": "service_unix.go",
          "type": "blob",
          "size": 3.4853515625,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\n//go:build linux || darwin || solaris || aix || freebsd\n// +build linux darwin solaris aix freebsd\n\npackage service\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log/syslog\"\n\t\"os/exec\"\n\t\"syscall\"\n)\n\nconst defaultLogDirectory = \"/var/log\"\n\nfunc newSysLogger(name string, errs chan<- error) (Logger, error) {\n\tw, err := syslog.New(syslog.LOG_INFO, name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sysLogger{w, errs}, nil\n}\n\ntype sysLogger struct {\n\t*syslog.Writer\n\terrs chan<- error\n}\n\nfunc (s sysLogger) send(err error) error {\n\tif err != nil && s.errs != nil {\n\t\ts.errs <- err\n\t}\n\treturn err\n}\n\nfunc (s sysLogger) Error(v ...interface{}) error {\n\treturn s.send(s.Writer.Err(fmt.Sprint(v...)))\n}\nfunc (s sysLogger) Warning(v ...interface{}) error {\n\treturn s.send(s.Writer.Warning(fmt.Sprint(v...)))\n}\nfunc (s sysLogger) Info(v ...interface{}) error {\n\treturn s.send(s.Writer.Info(fmt.Sprint(v...)))\n}\nfunc (s sysLogger) Errorf(format string, a ...interface{}) error {\n\treturn s.send(s.Writer.Err(fmt.Sprintf(format, a...)))\n}\nfunc (s sysLogger) Warningf(format string, a ...interface{}) error {\n\treturn s.send(s.Writer.Warning(fmt.Sprintf(format, a...)))\n}\nfunc (s sysLogger) Infof(format string, a ...interface{}) error {\n\treturn s.send(s.Writer.Info(fmt.Sprintf(format, a...)))\n}\n\nfunc run(command string, arguments ...string) error {\n\t_, _, err := runCommand(command, false, arguments...)\n\treturn err\n}\n\nfunc runWithOutput(command string, arguments ...string) (int, string, error) {\n\treturn runCommand(command, true, arguments...)\n}\n\nfunc runCommand(command string, readStdout bool, arguments ...string) (int, string, error) {\n\tcmd := exec.Command(command, arguments...)\n\n\tvar output string\n\tvar stdout io.ReadCloser\n\tvar err error\n\n\tif readStdout {\n\t\t// Connect pipe to read Stdout\n\t\tstdout, err = cmd.StdoutPipe()\n\n\t\tif err != nil {\n\t\t\t// Failed to connect pipe\n\t\t\treturn 0, \"\", fmt.Errorf(\"%q failed to connect stdout pipe: %v\", command, err)\n\t\t}\n\t}\n\n\t// Connect pipe to read Stderr\n\tstderr, err := cmd.StderrPipe()\n\n\tif err != nil {\n\t\t// Failed to connect pipe\n\t\treturn 0, \"\", fmt.Errorf(\"%q failed to connect stderr pipe: %v\", command, err)\n\t}\n\n\t// Do not use cmd.Run()\n\tif err := cmd.Start(); err != nil {\n\t\t// Problem while copying stdin, stdout, or stderr\n\t\treturn 0, \"\", fmt.Errorf(\"%q failed: %v\", command, err)\n\t}\n\n\t// Zero exit status\n\t// Darwin: launchctl can fail with a zero exit status,\n\t// so check for emtpy stderr\n\tif command == \"launchctl\" {\n\t\tslurp, _ := ioutil.ReadAll(stderr)\n\t\tif len(slurp) > 0 && !bytes.HasSuffix(slurp, []byte(\"Operation now in progress\\n\")) {\n\t\t\treturn 0, \"\", fmt.Errorf(\"%q failed with stderr: %s\", command, slurp)\n\t\t}\n\t}\n\n\tif readStdout {\n\t\tout, err := ioutil.ReadAll(stdout)\n\t\tif err != nil {\n\t\t\treturn 0, \"\", fmt.Errorf(\"%q failed while attempting to read stdout: %v\", command, err)\n\t\t} else if len(out) > 0 {\n\t\t\toutput = string(out)\n\t\t}\n\t}\n\n\tif err := cmd.Wait(); err != nil {\n\t\texitStatus, ok := isExitError(err)\n\t\tif ok {\n\t\t\t// Command didn't exit with a zero exit status.\n\t\t\treturn exitStatus, output, err\n\t\t}\n\n\t\t// An error occurred and there is no exit status.\n\t\treturn 0, output, fmt.Errorf(\"%q failed: %v\", command, err)\n\t}\n\n\treturn 0, output, nil\n}\n\nfunc isExitError(err error) (int, bool) {\n\tif exiterr, ok := err.(*exec.ExitError); ok {\n\t\tif status, ok := exiterr.Sys().(syscall.WaitStatus); ok {\n\t\t\treturn status.ExitStatus(), true\n\t\t}\n\t}\n\n\treturn 0, false\n}\n"
        },
        {
          "name": "service_upstart_linux.go",
          "type": "blob",
          "size": 5.7646484375,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strings\"\n\t\"syscall\"\n\t\"text/template\"\n)\n\nfunc isUpstart() bool {\n\tif _, err := os.Stat(\"/sbin/upstart-udev-bridge\"); err == nil {\n\t\treturn true\n\t}\n\tif _, err := os.Stat(\"/sbin/initctl\"); err == nil {\n\t\tif _, out, err := runWithOutput(\"/sbin/initctl\", \"--version\"); err == nil {\n\t\t\tif strings.Contains(out, \"initctl (upstart\") {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\ntype upstart struct {\n\ti        Interface\n\tplatform string\n\t*Config\n}\n\nfunc newUpstartService(i Interface, platform string, c *Config) (Service, error) {\n\ts := &upstart{\n\t\ti:        i,\n\t\tplatform: platform,\n\t\tConfig:   c,\n\t}\n\n\treturn s, nil\n}\n\nfunc (s *upstart) String() string {\n\tif len(s.DisplayName) > 0 {\n\t\treturn s.DisplayName\n\t}\n\treturn s.Name\n}\n\nfunc (s *upstart) Platform() string {\n\treturn s.platform\n}\n\n// Upstart has some support for user services in graphical sessions.\n// Due to the mix of actual support for user services over versions, just don't bother.\n// Upstart will be replaced by systemd in most cases anyway.\nvar errNoUserServiceUpstart = errors.New(\"User services are not supported on Upstart.\")\n\nfunc (s *upstart) configPath() (cp string, err error) {\n\tif s.Option.bool(optionUserService, optionUserServiceDefault) {\n\t\terr = errNoUserServiceUpstart\n\t\treturn\n\t}\n\tcp = \"/etc/init/\" + s.Config.Name + \".conf\"\n\treturn\n}\n\nfunc (s *upstart) hasKillStanza() bool {\n\tdefaultValue := true\n\tversion := s.getUpstartVersion()\n\tif version == nil {\n\t\treturn defaultValue\n\t}\n\n\tmaxVersion := []int{0, 6, 5}\n\tif matches, err := versionAtMost(version, maxVersion); err != nil || matches {\n\t\treturn false\n\t}\n\n\treturn defaultValue\n}\n\nfunc (s *upstart) hasSetUIDStanza() bool {\n\tdefaultValue := true\n\tversion := s.getUpstartVersion()\n\tif version == nil {\n\t\treturn defaultValue\n\t}\n\n\tmaxVersion := []int{1, 4, 0}\n\tif matches, err := versionAtMost(version, maxVersion); err != nil || matches {\n\t\treturn false\n\t}\n\n\treturn defaultValue\n}\n\nfunc (s *upstart) getUpstartVersion() []int {\n\t_, out, err := runWithOutput(\"/sbin/initctl\", \"--version\")\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tre := regexp.MustCompile(`initctl \\(upstart (\\d+.\\d+.\\d+)\\)`)\n\tmatches := re.FindStringSubmatch(out)\n\tif len(matches) != 2 {\n\t\treturn nil\n\t}\n\n\treturn parseVersion(matches[1])\n}\n\nfunc (s *upstart) template() *template.Template {\n\tcustomScript := s.Option.string(optionUpstartScript, \"\")\n\n\tif customScript != \"\" {\n\t\treturn template.Must(template.New(\"\").Funcs(tf).Parse(customScript))\n\t} else {\n\t\treturn template.Must(template.New(\"\").Funcs(tf).Parse(upstartScript))\n\t}\n}\n\nfunc (s *upstart) Install() error {\n\tconfPath, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = os.Stat(confPath)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"Init already exists: %s\", confPath)\n\t}\n\n\tf, err := os.Create(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tpath, err := s.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar to = &struct {\n\t\t*Config\n\t\tPath            string\n\t\tHasKillStanza   bool\n\t\tHasSetUIDStanza bool\n\t\tLogOutput       bool\n\t\tLogDirectory    string\n\t}{\n\t\ts.Config,\n\t\tpath,\n\t\ts.hasKillStanza(),\n\t\ts.hasSetUIDStanza(),\n\t\ts.Option.bool(optionLogOutput, optionLogOutputDefault),\n\t\ts.Option.string(optionLogDirectory, defaultLogDirectory),\n\t}\n\n\treturn s.template().Execute(f, to)\n}\n\nfunc (s *upstart) Uninstall() error {\n\tcp, err := s.configPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.Remove(cp); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *upstart) Logger(errs chan<- error) (Logger, error) {\n\tif system.Interactive() {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn s.SystemLogger(errs)\n}\nfunc (s *upstart) SystemLogger(errs chan<- error) (Logger, error) {\n\treturn newSysLogger(s.Name, errs)\n}\n\nfunc (s *upstart) Run() (err error) {\n\terr = s.i.Start(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Option.funcSingle(optionRunWait, func() {\n\t\tvar sigChan = make(chan os.Signal, 3)\n\t\tsignal.Notify(sigChan, syscall.SIGTERM, os.Interrupt)\n\t\t<-sigChan\n\t})()\n\n\treturn s.i.Stop(s)\n}\n\nfunc (s *upstart) Status() (Status, error) {\n\texitCode, out, err := runWithOutput(\"initctl\", \"status\", s.Name)\n\tif exitCode == 0 && err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\n\tswitch {\n\tcase strings.HasPrefix(out, fmt.Sprintf(\"%s start/running\", s.Name)):\n\t\treturn StatusRunning, nil\n\tcase strings.HasPrefix(out, fmt.Sprintf(\"%s stop/waiting\", s.Name)):\n\t\treturn StatusStopped, nil\n\tdefault:\n\t\treturn StatusUnknown, ErrNotInstalled\n\t}\n}\n\nfunc (s *upstart) Start() error {\n\treturn run(\"initctl\", \"start\", s.Name)\n}\n\nfunc (s *upstart) Stop() error {\n\treturn run(\"initctl\", \"stop\", s.Name)\n}\n\nfunc (s *upstart) Restart() error {\n\treturn run(\"initctl\", \"restart\", s.Name)\n}\n\n// The upstart script should stop with an INT or the Go runtime will terminate\n// the program before the Stop handler can run.\nconst upstartScript = `# {{.Description}}\n\n{{if .DisplayName}}description    \"{{.DisplayName}}\"{{end}}\n\n{{if .HasKillStanza}}kill signal INT{{end}}\n{{if .ChRoot}}chroot {{.ChRoot}}{{end}}\n{{if .WorkingDirectory}}chdir {{.WorkingDirectory}}{{end}}\nstart on filesystem or runlevel [2345]\nstop on runlevel [!2345]\n\n{{if and .UserName .HasSetUIDStanza}}setuid {{.UserName}}{{end}}\n\nrespawn\nrespawn limit 10 5\numask 022\n\nconsole none\n\npre-start script\n    test -x {{.Path}} || { stop; exit 0; }\nend script\n\n# Start\nscript\n\t{{if .LogOutput}}\n\tstdout_log=\"{{.LogDirectory}}/{{.Name}}.out\"\n\tstderr_log=\"{{.LogDirectory}}/{{.Name}}.err\"\n\t{{end}}\n\t\n\tif [ -f \"/etc/sysconfig/{{.Name}}\" ]; then\n\t\tset -a\n\t\tsource /etc/sysconfig/{{.Name}}\n\t\tset +a\n\tfi\n\n\texec {{if and .UserName (not .HasSetUIDStanza)}}sudo -E -u {{.UserName}} {{end}}{{.Path}}{{range .Arguments}} {{.|cmd}}{{end}}{{if .LogOutput}} >> $stdout_log 2>> $stderr_log{{end}}\nend script\n`\n"
        },
        {
          "name": "service_windows.go",
          "type": "blob",
          "size": 12.6572265625,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/sys/windows\"\n\t\"golang.org/x/sys/windows/registry\"\n\t\"golang.org/x/sys/windows/svc\"\n\t\"golang.org/x/sys/windows/svc/eventlog\"\n\t\"golang.org/x/sys/windows/svc/mgr\"\n)\n\nconst (\n\tversion = \"windows-service\"\n\n\tStartType             = \"StartType\"\n\tServiceStartManual    = \"manual\"\n\tServiceStartDisabled  = \"disabled\"\n\tServiceStartAutomatic = \"automatic\"\n\n\tOnFailure              = \"OnFailure\"\n\tOnFailureRestart       = \"restart\"\n\tOnFailureReboot        = \"reboot\"\n\tOnFailureNoAction      = \"noaction\"\n\tOnFailureDelayDuration = \"OnFailureDelayDuration\"\n\tOnFailureResetPeriod   = \"OnFailureResetPeriod\"\n\n\terrnoServiceDoesNotExist syscall.Errno = 1060\n)\n\ntype windowsService struct {\n\ti Interface\n\t*Config\n\n\terrSync      sync.Mutex\n\tstopStartErr error\n}\n\n// WindowsLogger allows using windows specific logging methods.\ntype WindowsLogger struct {\n\tev   *eventlog.Log\n\terrs chan<- error\n}\n\ntype windowsSystem struct{}\n\nfunc (windowsSystem) String() string {\n\treturn version\n}\nfunc (windowsSystem) Detect() bool {\n\treturn true\n}\nfunc (windowsSystem) Interactive() bool {\n\treturn interactive\n}\nfunc (windowsSystem) New(i Interface, c *Config) (Service, error) {\n\tws := &windowsService{\n\t\ti:      i,\n\t\tConfig: c,\n\t}\n\treturn ws, nil\n}\n\nfunc init() {\n\tChooseSystem(windowsSystem{})\n}\n\nfunc (l WindowsLogger) send(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif l.errs != nil {\n\t\tl.errs <- err\n\t}\n\treturn err\n}\n\n// Error logs an error message.\nfunc (l WindowsLogger) Error(v ...interface{}) error {\n\treturn l.send(l.ev.Error(3, fmt.Sprint(v...)))\n}\n\n// Warning logs an warning message.\nfunc (l WindowsLogger) Warning(v ...interface{}) error {\n\treturn l.send(l.ev.Warning(2, fmt.Sprint(v...)))\n}\n\n// Info logs an info message.\nfunc (l WindowsLogger) Info(v ...interface{}) error {\n\treturn l.send(l.ev.Info(1, fmt.Sprint(v...)))\n}\n\n// Errorf logs an error message.\nfunc (l WindowsLogger) Errorf(format string, a ...interface{}) error {\n\treturn l.send(l.ev.Error(3, fmt.Sprintf(format, a...)))\n}\n\n// Warningf logs an warning message.\nfunc (l WindowsLogger) Warningf(format string, a ...interface{}) error {\n\treturn l.send(l.ev.Warning(2, fmt.Sprintf(format, a...)))\n}\n\n// Infof logs an info message.\nfunc (l WindowsLogger) Infof(format string, a ...interface{}) error {\n\treturn l.send(l.ev.Info(1, fmt.Sprintf(format, a...)))\n}\n\n// NError logs an error message and an event ID.\nfunc (l WindowsLogger) NError(eventID uint32, v ...interface{}) error {\n\treturn l.send(l.ev.Error(eventID, fmt.Sprint(v...)))\n}\n\n// NWarning logs an warning message and an event ID.\nfunc (l WindowsLogger) NWarning(eventID uint32, v ...interface{}) error {\n\treturn l.send(l.ev.Warning(eventID, fmt.Sprint(v...)))\n}\n\n// NInfo logs an info message and an event ID.\nfunc (l WindowsLogger) NInfo(eventID uint32, v ...interface{}) error {\n\treturn l.send(l.ev.Info(eventID, fmt.Sprint(v...)))\n}\n\n// NErrorf logs an error message and an event ID.\nfunc (l WindowsLogger) NErrorf(eventID uint32, format string, a ...interface{}) error {\n\treturn l.send(l.ev.Error(eventID, fmt.Sprintf(format, a...)))\n}\n\n// NWarningf logs an warning message and an event ID.\nfunc (l WindowsLogger) NWarningf(eventID uint32, format string, a ...interface{}) error {\n\treturn l.send(l.ev.Warning(eventID, fmt.Sprintf(format, a...)))\n}\n\n// NInfof logs an info message and an event ID.\nfunc (l WindowsLogger) NInfof(eventID uint32, format string, a ...interface{}) error {\n\treturn l.send(l.ev.Info(eventID, fmt.Sprintf(format, a...)))\n}\n\nvar interactive = false\n\nfunc init() {\n\tisService, err := svc.IsWindowsService()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tinteractive = !isService\n}\n\nfunc (ws *windowsService) String() string {\n\tif len(ws.DisplayName) > 0 {\n\t\treturn ws.DisplayName\n\t}\n\treturn ws.Name\n}\n\nfunc (ws *windowsService) Platform() string {\n\treturn version\n}\n\nfunc (ws *windowsService) setError(err error) {\n\tws.errSync.Lock()\n\tdefer ws.errSync.Unlock()\n\tws.stopStartErr = err\n}\nfunc (ws *windowsService) getError() error {\n\tws.errSync.Lock()\n\tdefer ws.errSync.Unlock()\n\treturn ws.stopStartErr\n}\n\nfunc (ws *windowsService) Execute(args []string, r <-chan svc.ChangeRequest, changes chan<- svc.Status) (bool, uint32) {\n\tconst cmdsAccepted = svc.AcceptStop | svc.AcceptShutdown\n\tchanges <- svc.Status{State: svc.StartPending}\n\n\tif err := ws.i.Start(ws); err != nil {\n\t\tws.setError(err)\n\t\treturn true, 1\n\t}\n\n\tchanges <- svc.Status{State: svc.Running, Accepts: cmdsAccepted}\nloop:\n\tfor {\n\t\tc := <-r\n\t\tswitch c.Cmd {\n\t\tcase svc.Interrogate:\n\t\t\tchanges <- c.CurrentStatus\n\t\tcase svc.Stop:\n\t\t\tchanges <- svc.Status{State: svc.StopPending}\n\t\t\tif err := ws.i.Stop(ws); err != nil {\n\t\t\t\tws.setError(err)\n\t\t\t\treturn true, 2\n\t\t\t}\n\t\t\tbreak loop\n\t\tcase svc.Shutdown:\n\t\t\tchanges <- svc.Status{State: svc.StopPending}\n\t\t\tvar err error\n\t\t\tif wsShutdown, ok := ws.i.(Shutdowner); ok {\n\t\t\t\terr = wsShutdown.Shutdown(ws)\n\t\t\t} else {\n\t\t\t\terr = ws.i.Stop(ws)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tws.setError(err)\n\t\t\t\treturn true, 2\n\t\t\t}\n\t\t\tbreak loop\n\t\tdefault:\n\t\t\tcontinue loop\n\t\t}\n\t}\n\n\treturn false, 0\n}\n\nfunc lowPrivMgr() (*mgr.Mgr, error) {\n\th, err := windows.OpenSCManager(nil, nil, windows.SC_MANAGER_CONNECT|windows.SC_MANAGER_ENUMERATE_SERVICE)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &mgr.Mgr{Handle: h}, nil\n}\n\nfunc lowPrivSvc(m *mgr.Mgr, name string) (*mgr.Service, error) {\n\th, err := windows.OpenService(\n\t\tm.Handle, syscall.StringToUTF16Ptr(name),\n\t\twindows.SERVICE_QUERY_CONFIG|windows.SERVICE_QUERY_STATUS|windows.SERVICE_START|windows.SERVICE_STOP)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &mgr.Service{Handle: h, Name: name}, nil\n}\n\nfunc (ws *windowsService) setEnvironmentVariablesInRegistry() error {\n\tif len(ws.EnvVars) == 0 {\n\t\treturn nil\n\t}\n\n\tk, _, err := registry.CreateKey(\n\t\tregistry.LOCAL_MACHINE, `SYSTEM\\CurrentControlSet\\Services\\`+ws.Name,\n\t\tregistry.QUERY_VALUE|registry.SET_VALUE|registry.CREATE_SUB_KEY)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed creating env var registry key, err = %v\", err)\n\t}\n\tenvStrings := make([]string, 0, len(ws.EnvVars))\n\tfor k, v := range ws.EnvVars {\n\t\tenvStrings = append(envStrings, k+\"=\"+v)\n\t}\n\n\tif err := k.SetStringsValue(\"Environment\", envStrings); err != nil {\n\t\treturn fmt.Errorf(\"failed setting env var registry key, err = %v\", err)\n\t}\n\tif err := k.Close(); err != nil {\n\t\treturn fmt.Errorf(\"failed closing env var registry key, err = %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (ws *windowsService) Install() error {\n\texepath, err := ws.execPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tm, err := mgr.Connect()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer m.Disconnect()\n\n\tif err := ws.setEnvironmentVariablesInRegistry(); err != nil {\n\t\treturn err\n\t}\n\n\ts, err := m.OpenService(ws.Name)\n\tif err == nil {\n\t\ts.Close()\n\t\treturn fmt.Errorf(\"service %s already exists\", ws.Name)\n\t}\n\tvar startType int32\n\tswitch ws.Option.string(StartType, ServiceStartAutomatic) {\n\tcase ServiceStartAutomatic:\n\t\tstartType = mgr.StartAutomatic\n\tcase ServiceStartManual:\n\t\tstartType = mgr.StartManual\n\tcase ServiceStartDisabled:\n\t\tstartType = mgr.StartDisabled\n\t}\n\n\tserviceType := windows.SERVICE_WIN32_OWN_PROCESS\n\tif ws.Option.bool(\"Interactive\", false) {\n\t\tserviceType = serviceType | windows.SERVICE_INTERACTIVE_PROCESS\n\t}\n\n\ts, err = m.CreateService(ws.Name, exepath, mgr.Config{\n\t\tDisplayName:      ws.DisplayName,\n\t\tDescription:      ws.Description,\n\t\tStartType:        uint32(startType),\n\t\tServiceStartName: ws.UserName,\n\t\tPassword:         ws.Option.string(\"Password\", \"\"),\n\t\tDependencies:     ws.Dependencies,\n\t\tDelayedAutoStart: ws.Option.bool(\"DelayedAutoStart\", false),\n\t\tServiceType:      uint32(serviceType),\n\t}, ws.Arguments...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif onFailure := ws.Option.string(OnFailure, \"\"); onFailure != \"\" {\n\t\tvar delay = 1 * time.Second\n\t\tif d, err := time.ParseDuration(ws.Option.string(OnFailureDelayDuration, \"1s\")); err == nil {\n\t\t\tdelay = d\n\t\t}\n\t\tvar actionType int\n\t\tswitch onFailure {\n\t\tcase OnFailureReboot:\n\t\t\tactionType = mgr.ComputerReboot\n\t\tcase OnFailureRestart:\n\t\t\tactionType = mgr.ServiceRestart\n\t\tcase OnFailureNoAction:\n\t\t\tactionType = mgr.NoAction\n\t\tdefault:\n\t\t\tactionType = mgr.ServiceRestart\n\t\t}\n\t\tif err := s.SetRecoveryActions([]mgr.RecoveryAction{\n\t\t\t{\n\t\t\t\tType:  actionType,\n\t\t\t\tDelay: delay,\n\t\t\t},\n\t\t}, uint32(ws.Option.int(OnFailureResetPeriod, 10))); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tdefer s.Close()\n\terr = eventlog.InstallAsEventCreate(ws.Name, eventlog.Error|eventlog.Warning|eventlog.Info)\n\tif err != nil {\n\t\tif !strings.Contains(err.Error(), \"exists\") {\n\t\t\ts.Delete()\n\t\t\treturn fmt.Errorf(\"SetupEventLogSource() failed: %s\", err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ws *windowsService) Uninstall() error {\n\tm, err := mgr.Connect()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer m.Disconnect()\n\ts, err := m.OpenService(ws.Name)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"service %s is not installed\", ws.Name)\n\t}\n\tdefer s.Close()\n\terr = s.Delete()\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = eventlog.Remove(ws.Name)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"RemoveEventLogSource() failed: %s\", err)\n\t}\n\treturn nil\n}\n\nfunc (ws *windowsService) Run() error {\n\tws.setError(nil)\n\tif !interactive {\n\t\t// Return error messages from start and stop routines\n\t\t// that get executed in the Execute method.\n\t\t// Guarded with a mutex as it may run a different thread\n\t\t// (callback from windows).\n\t\trunErr := svc.Run(ws.Name, ws)\n\t\tstartStopErr := ws.getError()\n\t\tif startStopErr != nil {\n\t\t\treturn startStopErr\n\t\t}\n\t\tif runErr != nil {\n\t\t\treturn runErr\n\t\t}\n\t\treturn nil\n\t}\n\terr := ws.i.Start(ws)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsigChan := make(chan os.Signal)\n\n\tsignal.Notify(sigChan, os.Interrupt)\n\n\t<-sigChan\n\n\treturn ws.i.Stop(ws)\n}\n\nfunc (ws *windowsService) Status() (Status, error) {\n\tm, err := lowPrivMgr()\n\tif err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\tdefer m.Disconnect()\n\n\ts, err := lowPrivSvc(m, ws.Name)\n\tif err != nil {\n\t\tif errno, ok := err.(syscall.Errno); ok && errno == errnoServiceDoesNotExist {\n\t\t\treturn StatusUnknown, ErrNotInstalled\n\t\t}\n\t\treturn StatusUnknown, err\n\t}\n\tdefer s.Close()\n\n\tstatus, err := s.Query()\n\tif err != nil {\n\t\treturn StatusUnknown, err\n\t}\n\n\tswitch status.State {\n\tcase svc.StartPending:\n\t\tfallthrough\n\tcase svc.Running:\n\t\treturn StatusRunning, nil\n\tcase svc.PausePending:\n\t\tfallthrough\n\tcase svc.Paused:\n\t\tfallthrough\n\tcase svc.ContinuePending:\n\t\tfallthrough\n\tcase svc.StopPending:\n\t\tfallthrough\n\tcase svc.Stopped:\n\t\treturn StatusStopped, nil\n\tdefault:\n\t\treturn StatusUnknown, fmt.Errorf(\"unknown status %v\", status)\n\t}\n}\n\nfunc (ws *windowsService) Start() error {\n\tm, err := lowPrivMgr()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer m.Disconnect()\n\n\ts, err := lowPrivSvc(m, ws.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.Close()\n\treturn s.Start()\n}\n\nfunc (ws *windowsService) Stop() error {\n\tm, err := lowPrivMgr()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer m.Disconnect()\n\n\ts, err := lowPrivSvc(m, ws.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.Close()\n\n\treturn ws.stopWait(s)\n}\n\nfunc (ws *windowsService) Restart() error {\n\tm, err := lowPrivMgr()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer m.Disconnect()\n\n\ts, err := lowPrivSvc(m, ws.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.Close()\n\n\terr = ws.stopWait(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn s.Start()\n}\n\nfunc (ws *windowsService) stopWait(s *mgr.Service) error {\n\t// First stop the service. Then wait for the service to\n\t// actually stop before starting it.\n\tstatus, err := s.Control(svc.Stop)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttimeDuration := time.Millisecond * 50\n\n\ttimeout := time.After(getStopTimeout() + (timeDuration * 2))\n\ttick := time.NewTicker(timeDuration)\n\tdefer tick.Stop()\n\n\tfor status.State != svc.Stopped {\n\t\tselect {\n\t\tcase <-tick.C:\n\t\t\tstatus, err = s.Query()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase <-timeout:\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\n// getStopTimeout fetches the time before windows will kill the service.\nfunc getStopTimeout() time.Duration {\n\t// For default and paths see https://support.microsoft.com/en-us/kb/146092\n\tdefaultTimeout := time.Millisecond * 20000\n\tkey, err := registry.OpenKey(registry.LOCAL_MACHINE, `SYSTEM\\CurrentControlSet\\Control`, registry.READ)\n\tif err != nil {\n\t\treturn defaultTimeout\n\t}\n\tsv, _, err := key.GetStringValue(\"WaitToKillServiceTimeout\")\n\tif err != nil {\n\t\treturn defaultTimeout\n\t}\n\tv, err := strconv.Atoi(sv)\n\tif err != nil {\n\t\treturn defaultTimeout\n\t}\n\treturn time.Millisecond * time.Duration(v)\n}\n\nfunc (ws *windowsService) Logger(errs chan<- error) (Logger, error) {\n\tif interactive {\n\t\treturn ConsoleLogger, nil\n\t}\n\treturn ws.SystemLogger(errs)\n}\nfunc (ws *windowsService) SystemLogger(errs chan<- error) (Logger, error) {\n\tel, err := eventlog.Open(ws.Name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn WindowsLogger{el, errs}, nil\n}\n"
        },
        {
          "name": "service_windows_test.go",
          "type": "blob",
          "size": 0.279296875,
          "content": "// Copyright 2015 Daniel Theophanes.\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTimeout(t *testing.T) {\n\tstopSpan := getStopTimeout()\n\tt.Log(\"Max Stop Duration\", stopSpan)\n}\n"
        },
        {
          "name": "servicetest_unix_test.go",
          "type": "blob",
          "size": 0.59375,
          "content": "// Copyright 2016 Lawrence Woodman <lwoodman@vlifesystems.com>\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\n//go:build darwin || dragonfly || freebsd || linux || nacl || netbsd || openbsd || solaris\n// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris\n\npackage service_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\nfunc interruptProcess(t *testing.T) {\n\tpid := os.Getpid()\n\tp, err := os.FindProcess(pid)\n\tif err != nil {\n\t\tt.Fatalf(\"FindProcess: %s\", err)\n\t}\n\tif err := p.Signal(os.Interrupt); err != nil {\n\t\tt.Fatalf(\"Signal: %s\", err)\n\t}\n}\n"
        },
        {
          "name": "servicetest_windows_test.go",
          "type": "blob",
          "size": 0.8701171875,
          "content": "// Copyright 2016 Lawrence Woodman <lwoodman@vlifesystems.com>\n// Use of this source code is governed by a zlib-style\n// license that can be found in the LICENSE file.\n\npackage service_test\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n)\n\nfunc interruptProcess(t *testing.T) {\n\tdll, err := syscall.LoadDLL(\"kernel32.dll\")\n\tif err != nil {\n\t\tt.Fatalf(\"LoadDLL(\\\"kernel32.dll\\\") err: %s\", err)\n\t}\n\tp, err := dll.FindProc(\"GenerateConsoleCtrlEvent\")\n\tif err != nil {\n\t\tt.Fatalf(\"FindProc(\\\"GenerateConsoleCtrlEvent\\\") err: %s\", err)\n\t}\n\t// Send the CTRL_BREAK_EVENT to a console process group that shares\n\t// the console associated with the calling process.\n\t// https://msdn.microsoft.com/en-us/library/windows/desktop/ms683155(v=vs.85).aspx\n\tpid := os.Getpid()\n\tr1, _, err := p.Call(syscall.CTRL_BREAK_EVENT, uintptr(pid))\n\tif r1 == 0 {\n\t\tt.Fatalf(\"Call(CTRL_BREAK_EVENT, %d) err: %s\", pid, err)\n\t}\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 1.21484375,
          "content": "package service\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// versionAtMost will return true if the provided version is less than or equal to max\nfunc versionAtMost(version, max []int) (bool, error) {\n\tif comp, err := versionCompare(version, max); err != nil {\n\t\treturn false, err\n\t} else if comp == 1 {\n\t\treturn false, nil\n\t}\n\treturn true, nil\n}\n\n// versionCompare take to versions split into integer arrays and attempts to compare them\n// An error will be returned if there is an array length mismatch.\n// Return values are as follows\n// -1 - v1 is less than v2\n// 0  - v1 is equal to v2\n// 1  - v1 is greater than v2\nfunc versionCompare(v1, v2 []int) (int, error) {\n\tif len(v1) != len(v2) {\n\t\treturn 0, errors.New(\"version length mismatch\")\n\t}\n\n\tfor idx, v2S := range v2 {\n\t\tv1S := v1[idx]\n\t\tif v1S > v2S {\n\t\t\treturn 1, nil\n\t\t}\n\n\t\tif v1S < v2S {\n\t\t\treturn -1, nil\n\t\t}\n\t}\n\treturn 0, nil\n}\n\n// parseVersion will parse any integer type version separated by periods.\n// This does not fully support semver style versions.\nfunc parseVersion(v string) []int {\n\tversion := make([]int, 3)\n\n\tfor idx, vStr := range strings.Split(v, \".\") {\n\t\tvS, err := strconv.Atoi(vStr)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tversion[idx] = vS\n\t}\n\n\treturn version\n}\n"
        },
        {
          "name": "version_test.go",
          "type": "blob",
          "size": 3.33203125,
          "content": "package service\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc Test_versionCompare(t *testing.T) {\n\ttype args struct {\n\t\tv1 []int\n\t\tv2 []int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\"segment-mismatch-1\", args{[]int{0, 0, 0, 0}, []int{0, 0, 0}}, 0, true},\n\t\t{\"segment-mismatch-2\", args{[]int{0, 0, 0}, []int{0, 0, 0, 0}}, 0, true},\n\t\t{\"equal-to-1\", args{[]int{0, 0, 0}, []int{0, 0, 0}}, 0, false},\n\t\t{\"equal-to-2\", args{[]int{0, 0, 1}, []int{0, 0, 1}}, 0, false},\n\t\t{\"equal-to-3\", args{[]int{0, 1, 0}, []int{0, 1, 0}}, 0, false},\n\t\t{\"equal-to-4\", args{[]int{1, 0, 0}, []int{1, 0, 0}}, 0, false},\n\t\t{\"equal-to-5\", args{[]int{2, 2, 2}, []int{2, 2, 2}}, 0, false},\n\t\t{\"less-than-1\", args{[]int{0, 0, 0}, []int{0, 0, 1}}, -1, false},\n\t\t{\"less-than-2\", args{[]int{0, 0, 1}, []int{0, 1, 0}}, -1, false},\n\t\t{\"less-than-3\", args{[]int{0, 1, 0}, []int{1, 0, 0}}, -1, false},\n\t\t{\"less-than-4\", args{[]int{0, 1, 0}, []int{1, 0, 0}}, -1, false},\n\t\t{\"less-than-5\", args{[]int{0, 8, 0}, []int{1, 5, 0}}, -1, false},\n\t\t{\"greater-than-1\", args{[]int{0, 0, 1}, []int{0, 0, 0}}, 1, false},\n\t\t{\"greater-than-2\", args{[]int{0, 1, 0}, []int{0, 0, 1}}, 1, false},\n\t\t{\"greater-than-3\", args{[]int{1, 0, 0}, []int{0, 1, 0}}, 1, false},\n\t\t{\"greater-than-4\", args{[]int{1, 0, 0}, []int{0, 1, 0}}, 1, false},\n\t\t{\"greater-than-5\", args{[]int{1, 5, 0}, []int{0, 8, 0}}, 1, false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := versionCompare(tt.args.v1, tt.args.v2)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"versionCompare() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"versionCompare() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseVersion(t *testing.T) {\n\ttype args struct {\n\t\tv string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\"sanity-check\", args{\"0.0.0\"}, []int{0, 0, 0}},\n\t\t{\"should-fail\", args{\"0.zero.0\"}, nil},\n\t\t{\"should-fail-no-semver\", args{\"0.0.0-test+1\"}, nil},\n\t\t{\"double-digits\", args{\"5.200.1\"}, []int{5, 200, 1}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := parseVersion(tt.args.v); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseVersion() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_versionAtMost(t *testing.T) {\n\ttype args struct {\n\t\tversion []int\n\t\tmax     []int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t{\"segment-mismatch-1\", args{[]int{0, 0, 0, 0}, []int{0, 0, 0}}, false, true},\n\t\t{\"segment-mismatch-2\", args{[]int{0, 0, 0}, []int{0, 0, 0, 0}}, false, true},\n\t\t{\"test-1\", args{[]int{0, 0, 0}, []int{0, 0, 1}}, true, false},\n\t\t{\"test-2\", args{[]int{0, 1, 0}, []int{0, 1, 0}}, true, false},\n\t\t{\"test-3\", args{[]int{1, 0, 0}, []int{1, 0, 0}}, true, false},\n\t\t{\"negative-test-1\", args{[]int{0, 0, 1}, []int{0, 0, 0}}, false, false},\n\t\t{\"negative-test-2\", args{[]int{0, 1, 0}, []int{0, 0, 1}}, false, false},\n\t\t{\"negative-test-3\", args{[]int{1, 0, 0}, []int{0, 1, 0}}, false, false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := versionAtMost(tt.args.version, tt.args.max)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"versionAtMost() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"versionAtMost() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}