{
  "metadata": {
    "timestamp": 1736567302166,
    "page": 902,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "alecthomas/kong",
      "stars": 2271,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 1.9326171875,
          "content": "run:\n  tests: true\n\noutput:\n  print-issued-lines: false\n\nlinters:\n  enable-all: true\n  disable:\n    - lll\n    - gochecknoglobals\n    - wsl\n    - funlen\n    - gocognit\n    - gomnd\n    - goprintffuncname\n    - paralleltest\n    - nlreturn\n    - testpackage\n    - wrapcheck\n    - forbidigo\n    - gci\n    - godot\n    - gofumpt\n    - cyclop\n    - errorlint\n    - nestif\n    - tagliatelle\n    - thelper\n    - godox\n    - goconst\n    - varnamelen\n    - ireturn\n    - exhaustruct\n    - nonamedreturns\n    - nilnil\n    - depguard    # nothing to guard against yet\n    - tagalign    # hurts readability of kong tags\n    - mnd\n    - perfsprint\n    - err113\n    - copyloopvar\n    - intrange\n    - execinquery\n\nlinters-settings:\n  govet:\n    # These govet checks are disabled by default, but they're useful.\n    enable:\n      - niliness\n      - sortslice\n      - unusedwrite\n  dupl:\n    threshold: 100\n  gocyclo:\n    min-complexity: 20\n  exhaustive:\n    default-signifies-exhaustive: true\n\nissues:\n  max-per-linter: 0\n  max-same: 0\n  exclude-use-default: false\n  exclude:\n    - '^(G104|G204):'\n    # Very commonly not checked.\n    - 'Error return value of .(.*\\.Help|.*\\.MarkFlagRequired|(os\\.)?std(out|err)\\..*|.*Close|.*Flush|os\\.Remove(All)?|.*printf?|os\\.(Un)?Setenv). is not checked'\n    - 'exported method (.*\\.MarshalJSON|.*\\.UnmarshalJSON) should have comment or be unexported'\n    - 'composite literal uses unkeyed fields'\n    - 'bad syntax for struct tag key'\n    - 'bad syntax for struct tag pair'\n    - 'result .* \\(error\\) is always nil'\n    - 'Error return value of `fmt.Fprintln` is not checked'\n\n  exclude-rules:\n    # Don't warn on unused parameters.\n    # Parameter names are useful for documentation.\n    # Replacing them with '_' hides useful information.\n    - linters: [revive]\n      text: 'unused-parameter: parameter \\S+ seems to be unused, consider removing or renaming it as _'\n\n    # Duplicate words are okay in tests.\n    - linters: [dupword]\n      path: _test\\.go\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.0302734375,
          "content": "Copyright (C) 2018 Alec Thomas\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 34.671875,
          "content": "<!-- markdownlint-disable MD013 MD033 -->\n<p align=\"center\"><img width=\"90%\" src=\"kong.png\" /></p>\n\n# Kong is a command-line parser for Go\n\n[![](https://godoc.org/github.com/alecthomas/kong?status.svg)](http://godoc.org/github.com/alecthomas/kong) [![CircleCI](https://img.shields.io/circleci/project/github/alecthomas/kong.svg)](https://circleci.com/gh/alecthomas/kong) [![Go Report Card](https://goreportcard.com/badge/github.com/alecthomas/kong)](https://goreportcard.com/report/github.com/alecthomas/kong) [![Slack chat](https://img.shields.io/static/v1?logo=slack&style=flat&label=slack&color=green&message=gophers)](https://gophers.slack.com/messages/CN9DS8YF3)\n\n- [Version 1.0.0 Release](#version-100-release)\n- [Introduction](#introduction)\n- [Help](#help)\n  - [Help as a user of a Kong application](#help-as-a-user-of-a-kong-application)\n  - [Defining help in Kong](#defining-help-in-kong)\n- [Command handling](#command-handling)\n  - [Switch on the command string](#switch-on-the-command-string)\n  - [Attach a `Run(...) error` method to each command](#attach-a-run-error-method-to-each-command)\n- [Hooks: BeforeReset(), BeforeResolve(), BeforeApply(), AfterApply() and the Bind() option](#hooks-beforereset-beforeresolve-beforeapply-afterapply-and-the-bind-option)\n- [Flags](#flags)\n- [Commands and sub-commands](#commands-and-sub-commands)\n- [Branching positional arguments](#branching-positional-arguments)\n- [Positional arguments](#positional-arguments)\n- [Slices](#slices)\n- [Maps](#maps)\n- [Pointers](#pointers)\n- [Nested data structure](#nested-data-structure)\n- [Custom named decoders](#custom-named-decoders)\n- [Supported field types](#supported-field-types)\n- [Custom decoders (mappers)](#custom-decoders-mappers)\n- [Supported tags](#supported-tags)\n- [Plugins](#plugins)\n- [Dynamic Commands](#dynamic-commands)\n- [Variable interpolation](#variable-interpolation)\n- [Validation](#validation)\n- [Modifying Kong's behaviour](#modifying-kongs-behaviour)\n  - [`Name(help)` and `Description(help)` - set the application name description](#namehelp-and-descriptionhelp---set-the-application-name-description)\n  - [`Configuration(loader, paths...)` - load defaults from configuration files](#configurationloader-paths---load-defaults-from-configuration-files)\n  - [`Resolver(...)` - support for default values from external sources](#resolver---support-for-default-values-from-external-sources)\n  - [`*Mapper(...)` - customising how the command-line is mapped to Go values](#mapper---customising-how-the-command-line-is-mapped-to-go-values)\n  - [`ConfigureHelp(HelpOptions)` and `Help(HelpFunc)` - customising help](#configurehelphelpoptions-and-helphelpfunc---customising-help)\n  - [Injecting values into `Run()` methods](#injecting-values-into-run-methods)\n  - [Other options](#other-options)\n\n## Version 1.0.0 Release\n\nKong has been stable for a long time, so it seemed appropriate to cut a 1.0 release.\n\nThere is one breaking change, [#436](https://github.com/alecthomas/kong/pull/436), which should effect relatively few users.\n\n## Introduction\n\nKong aims to support arbitrarily complex command-line structures with as little developer effort as possible.\n\nTo achieve that, command-lines are expressed as Go types, with the structure and tags directing how the command line is mapped onto the struct.\n\nFor example, the following command-line:\n\n    shell rm [-f] [-r] <paths> ...\n    shell ls [<paths> ...]\n\nCan be represented by the following command-line structure:\n\n```go\npackage main\n\nimport \"github.com/alecthomas/kong\"\n\nvar CLI struct {\n  Rm struct {\n    Force     bool `help:\"Force removal.\"`\n    Recursive bool `help:\"Recursively remove files.\"`\n\n    Paths []string `arg:\"\" name:\"path\" help:\"Paths to remove.\" type:\"path\"`\n  } `cmd:\"\" help:\"Remove files.\"`\n\n  Ls struct {\n    Paths []string `arg:\"\" optional:\"\" name:\"path\" help:\"Paths to list.\" type:\"path\"`\n  } `cmd:\"\" help:\"List paths.\"`\n}\n\nfunc main() {\n  ctx := kong.Parse(&CLI)\n  switch ctx.Command() {\n  case \"rm <path>\":\n  case \"ls\":\n  default:\n    panic(ctx.Command())\n  }\n}\n```\n\n## Help\n\n### Help as a user of a Kong application\n\nEvery Kong application includes a `--help` flag that will display auto-generated help.\n\neg.\n\n    $ shell --help\n    usage: shell <command>\n\n    A shell-like example app.\n\n    Flags:\n      --help   Show context-sensitive help.\n      --debug  Debug mode.\n\n    Commands:\n      rm <path> ...\n        Remove files.\n\n      ls [<path> ...]\n        List paths.\n\nIf a command is provided, the help will show full detail on the command including all available flags.\n\neg.\n\n    $ shell --help rm\n    usage: shell rm <paths> ...\n\n    Remove files.\n\n    Arguments:\n      <paths> ...  Paths to remove.\n\n    Flags:\n          --debug        Debug mode.\n\n      -f, --force        Force removal.\n      -r, --recursive    Recursively remove files.\n\n### Defining help in Kong\n\nHelp is automatically generated from the command-line structure itself,\nincluding `help:\"\"` and other tags. [Variables](#variable-interpolation) will\nalso be interpolated into the help string.\n\nFinally, any command, or argument type implementing the interface\n`Help() string` will have this function called to retrieve more detail to\naugment the help tag. This allows for much more descriptive text than can\nfit in Go tags. [See \\_examples/shell/help](./_examples/shell/help)\n\n#### Showing the _command_'s detailed help\n\nA command's additional help text is _not_ shown from top-level help, but can be displayed within contextual help:\n\n**Top level help**\n\n```bash\n $ go run ./_examples/shell/help --help\nUsage: help <command>\n\nAn app demonstrating HelpProviders\n\nFlags:\n  -h, --help    Show context-sensitive help.\n      --flag    Regular flag help\n\nCommands:\n  echo    Regular command help\n```\n\n**Contextual**\n\n```bash\n $ go run ./_examples/shell/help echo --help\nUsage: help echo <msg>\n\nRegular command help\n\nðŸš€ additional command help\n\nArguments:\n  <msg>    Regular argument help\n\nFlags:\n  -h, --help    Show context-sensitive help.\n      --flag    Regular flag help\n```\n\n#### Showing an _argument_'s detailed help\n\nCustom help will only be shown for _positional arguments with named fields_ ([see the README section on positional arguments for more details on what that means](../../../README.md#branching-positional-arguments))\n\n**Contextual argument help**\n\n```bash\n $ go run ./_examples/shell/help msg --help\nUsage: help echo <msg>\n\nRegular argument help\n\nðŸ“£ additional argument help\n\nFlags:\n  -h, --help    Show context-sensitive help.\n      --flag    Regular flag help\n```\n\n## Command handling\n\nThere are two ways to handle commands in Kong.\n\n### Switch on the command string\n\nWhen you call `kong.Parse()` it will return a unique string representation of the command. Each command branch in the hierarchy will be a bare word and each branching argument or required positional argument will be the name surrounded by angle brackets. Here's an example:\n\nThere's an example of this pattern [here](https://github.com/alecthomas/kong/blob/master/_examples/shell/commandstring/main.go).\n\neg.\n\n```go\npackage main\n\nimport \"github.com/alecthomas/kong\"\n\nvar CLI struct {\n  Rm struct {\n    Force     bool `help:\"Force removal.\"`\n    Recursive bool `help:\"Recursively remove files.\"`\n\n    Paths []string `arg:\"\" name:\"path\" help:\"Paths to remove.\" type:\"path\"`\n  } `cmd:\"\" help:\"Remove files.\"`\n\n  Ls struct {\n    Paths []string `arg:\"\" optional:\"\" name:\"path\" help:\"Paths to list.\" type:\"path\"`\n  } `cmd:\"\" help:\"List paths.\"`\n}\n\nfunc main() {\n  ctx := kong.Parse(&CLI)\n  switch ctx.Command() {\n  case \"rm <path>\":\n  case \"ls\":\n  default:\n    panic(ctx.Command())\n  }\n}\n```\n\nThis has the advantage that it is convenient, but the downside that if you modify your CLI structure, the strings may change. This can be fragile.\n\n### Attach a `Run(...) error` method to each command\n\nA more robust approach is to break each command out into their own structs:\n\n1. Break leaf commands out into separate structs.\n2. Attach a `Run(...) error` method to all leaf commands.\n3. Call `kong.Kong.Parse()` to obtain a `kong.Context`.\n4. Call `kong.Context.Run(bindings...)` to call the selected parsed command.\n\nOnce a command node is selected by Kong it will search from that node back to the root. Each\nencountered command node with a `Run(...) error` will be called in reverse order. This allows\nsub-trees to be re-used fairly conveniently.\n\nIn addition to values bound with the `kong.Bind(...)` option, any values\npassed through to `kong.Context.Run(...)` are also bindable to the target's\n`Run()` arguments.\n\nFinally, hooks can also contribute bindings via `kong.Context.Bind()` and `kong.Context.BindTo()`.\n\nThere's a full example emulating part of the Docker CLI [here](https://github.com/alecthomas/kong/tree/master/_examples/docker).\n\neg.\n\n```go\ntype Context struct {\n  Debug bool\n}\n\ntype RmCmd struct {\n  Force     bool `help:\"Force removal.\"`\n  Recursive bool `help:\"Recursively remove files.\"`\n\n  Paths []string `arg:\"\" name:\"path\" help:\"Paths to remove.\" type:\"path\"`\n}\n\nfunc (r *RmCmd) Run(ctx *Context) error {\n  fmt.Println(\"rm\", r.Paths)\n  return nil\n}\n\ntype LsCmd struct {\n  Paths []string `arg:\"\" optional:\"\" name:\"path\" help:\"Paths to list.\" type:\"path\"`\n}\n\nfunc (l *LsCmd) Run(ctx *Context) error {\n  fmt.Println(\"ls\", l.Paths)\n  return nil\n}\n\nvar cli struct {\n  Debug bool `help:\"Enable debug mode.\"`\n\n  Rm RmCmd `cmd:\"\" help:\"Remove files.\"`\n  Ls LsCmd `cmd:\"\" help:\"List paths.\"`\n}\n\nfunc main() {\n  ctx := kong.Parse(&cli)\n  // Call the Run() method of the selected parsed command.\n  err := ctx.Run(&Context{Debug: cli.Debug})\n  ctx.FatalIfErrorf(err)\n}\n\n```\n\n## Hooks: BeforeReset(), BeforeResolve(), BeforeApply(), AfterApply() and the Bind() option\n\nIf a node in the CLI, or any of its embedded fields, has a `BeforeReset(...) error`, `BeforeResolve\n(...) error`, `BeforeApply(...) error` and/or `AfterApply(...) error` method, those\nmethods will be called before values are reset, before validation/assignment,\nand after validation/assignment, respectively.\n\nThe `--help` flag is implemented with a `BeforeReset` hook.\n\nArguments to hooks are provided via the `Run(...)` method or `Bind(...)` option. `*Kong`, `*Context` and `*Path` are also bound and finally, hooks can also contribute bindings via `kong.Context.Bind()` and `kong.Context.BindTo()`.\n\neg.\n\n```go\n// A flag with a hook that, if triggered, will set the debug loggers output to stdout.\ntype debugFlag bool\n\nfunc (d debugFlag) BeforeApply(logger *log.Logger) error {\n  logger.SetOutput(os.Stdout)\n  return nil\n}\n\nvar cli struct {\n  Debug debugFlag `help:\"Enable debug logging.\"`\n}\n\nfunc main() {\n  // Debug logger going to discard.\n  logger := log.New(io.Discard, \"\", log.LstdFlags)\n\n  ctx := kong.Parse(&cli, kong.Bind(logger))\n\n  // ...\n}\n```\n\n## Flags\n\nAny [mapped](#mapper---customising-how-the-command-line-is-mapped-to-go-values) field in the command structure _not_ tagged with `cmd` or `arg` will be a flag. Flags are optional by default.\n\neg. The command-line `app [--flag=\"foo\"]` can be represented by the following.\n\n```go\ntype CLI struct {\n  Flag string\n}\n```\n\n## Commands and sub-commands\n\nSub-commands are specified by tagging a struct field with `cmd`. Kong supports arbitrarily nested commands.\n\neg. The following struct represents the CLI structure `command [--flag=\"str\"] sub-command`.\n\n```go\ntype CLI struct {\n  Command struct {\n    Flag string\n\n    SubCommand struct {\n    } `cmd`\n  } `cmd`\n}\n```\n\nIf a sub-command is tagged with `default:\"1\"` it will be selected if there are no further arguments. If a sub-command is tagged with `default:\"withargs\"` it will be selected even if there are further arguments or flags and those arguments or flags are valid for the sub-command. This allows the user to omit the sub-command name on the CLI if its arguments/flags are not ambiguous with the sibling commands or flags.\n\n## Branching positional arguments\n\nIn addition to sub-commands, structs can also be configured as branching positional arguments.\n\nThis is achieved by tagging an [unmapped](#mapper---customising-how-the-command-line-is-mapped-to-go-values) nested struct field with `arg`, then including a positional argument field inside that struct _with the same name_. For example, the following command structure:\n\n    app rename <name> to <name>\n\nCan be represented with the following:\n\n```go\nvar CLI struct {\n  Rename struct {\n    Name struct {\n      Name string `arg` // <-- NOTE: identical name to enclosing struct field.\n      To struct {\n        Name struct {\n          Name string `arg`\n        } `arg`\n      } `cmd`\n    } `arg`\n  } `cmd`\n}\n```\n\nThis looks a little verbose in this contrived example, but typically this will not be the case.\n\n## Positional arguments\n\nIf a field is tagged with `arg:\"\"` it will be treated as the final positional\nvalue to be parsed on the command line. By default positional arguments are\nrequired, but specifying `optional:\"\"` will alter this.\n\nIf a positional argument is a slice, all remaining arguments will be appended\nto that slice.\n\n## Slices\n\nSlice values are treated specially. First the input is split on the `sep:\"<rune>\"` tag (defaults to `,`), then each element is parsed by the slice element type and appended to the slice. If the same value is encountered multiple times, elements continue to be appended.\n\nTo represent the following command-line:\n\n    cmd ls <file> <file> ...\n\nYou would use the following:\n\n```go\nvar CLI struct {\n  Ls struct {\n    Files []string `arg:\"\" type:\"existingfile\"`\n  } `cmd`\n}\n```\n\n## Maps\n\nMaps are similar to slices except that only one key/value pair can be assigned per value, and the `sep` tag denotes the assignment character and defaults to `=`.\n\nTo represent the following command-line:\n\n    cmd config set <key>=<value> <key>=<value> ...\n\nYou would use the following:\n\n```go\nvar CLI struct {\n  Config struct {\n    Set struct {\n      Config map[string]float64 `arg:\"\" type:\"file:\"`\n    } `cmd`\n  } `cmd`\n}\n```\n\nFor flags, multiple key+value pairs should be separated by `mapsep:\"rune\"` tag (defaults to `;`) eg. `--set=\"key1=value1;key2=value2\"`.\n\n## Pointers\n\nPointers work like the underlying type, except that you can differentiate between the presence of the zero value and no value being supplied.\n\nFor example:\n\n```go\nvar CLI struct {\n\tFoo *int\n}\n```\n\nWould produce a nil value for `Foo` if no `--foo` argument is supplied, but would have a pointer to the value 0 if the argument `--foo=0` was supplied.\n\n## Nested data structure\n\nKong support a nested data structure as well with `embed:\"\"`. You can combine `embed:\"\"` with `prefix:\"\"`:\n\n```go\nvar CLI struct {\n  Logging struct {\n    Level string `enum:\"debug,info,warn,error\" default:\"info\"`\n    Type string `enum:\"json,console\" default:\"console\"`\n  } `embed:\"\" prefix:\"logging.\"`\n}\n```\n\nThis configures Kong to accept flags `--logging.level` and `--logging.type`.\n\n## Custom named decoders\n\nKong includes a number of builtin custom type mappers. These can be used by\nspecifying the tag `type:\"<type>\"`. They are registered with the option\nfunction `NamedMapper(name, mapper)`.\n\n| Name           | Description                                                                                                            |\n| -------------- | ---------------------------------------------------------------------------------------------------------------------- |\n| `path`         | A path. ~ expansion is applied. `-` is accepted for stdout, and will be passed unaltered.                              |\n| `existingfile` | An existing file. ~ expansion is applied. `-` is accepted for stdin, and will be passed unaltered.                     |\n| `existingdir`  | An existing directory. ~ expansion is applied.                                                                         |\n| `counter`      | Increment a numeric field. Useful for `-vvv`. Can accept `-s`, `--long` or `--long=N`.                                 |\n| `filecontent`  | Read the file at path into the field. ~ expansion is applied. `-` is accepted for stdin, and will be passed unaltered. |\n\nSlices and maps treat type tags specially. For slices, the `type:\"\"` tag\nspecifies the element type. For maps, the tag has the format\n`tag:\"[<key>]:[<value>]\"` where either may be omitted.\n\n## Supported field types\n\n## Custom decoders (mappers)\n\nAny field implementing `encoding.TextUnmarshaler` or `json.Unmarshaler` will use those interfaces\nfor decoding values. Kong also includes builtin support for many common Go types:\n\n| Type            | Description                                                                                                 |\n| --------------- | ----------------------------------------------------------------------------------------------------------- |\n| `time.Duration` | Populated using `time.ParseDuration()`.                                                                     |\n| `time.Time`     | Populated using `time.Parse()`. Format defaults to RFC3339 but can be overridden with the `format:\"X\"` tag. |\n| `*os.File`      | Path to a file that will be opened, or `-` for `os.Stdin`. File must be closed by the user.                 |\n| `*url.URL`      | Populated with `url.Parse()`.                                                                               |\n\nFor more fine-grained control, if a field implements the\n[MapperValue](https://godoc.org/github.com/alecthomas/kong#MapperValue)\ninterface it will be used to decode arguments into the field.\n\n## Supported tags\n\nTags can be in two forms:\n\n1. Standard Go syntax, eg. `kong:\"required,name='foo'\"`.\n2. Bare tags, eg. `required:\"\" name:\"foo\"`\n\nBoth can coexist with standard Tag parsing.\n\n| Tag                  | Description                                                                                                                                                                                                                                                                                                                    |\n| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `cmd:\"\"`             | If present, struct is a command.                                                                                                                                                                                                                                                                                               |\n| `arg:\"\"`             | If present, field is an argument. Required by default.                                                                                                                                                                                                                                                                         |\n| `env:\"X,Y,...\"`      | Specify envars to use for default value. The envs are resolved in the declared order. The first value found is used.                                                                                                                                                                                                           |\n| `name:\"X\"`           | Long name, for overriding field name.                                                                                                                                                                                                                                                                                          |\n| `help:\"X\"`           | Help text.                                                                                                                                                                                                                                                                                                                     |\n| `type:\"X\"`           | Specify [named types](#custom-named-decoders) to use.                                                                                                                                                                                                                                                                          |\n| `placeholder:\"X\"`    | Placeholder input, if flag. e.g. `` `placeholder:\"<the-placeholder>\"` `` will show `--flag-name=<the-placeholder>` when displaying help.                                                                                                                                                                                       |\n| `default:\"X\"`        | Default value.                                                                                                                                                                                                                                                                                                                 |\n| `default:\"1\"`        | On a command, make it the default.                                                                                                                                                                                                                                                                                             |\n| `default:\"withargs\"` | On a command, make it the default and allow args/flags from that command                                                                                                                                                                                                                                                       |\n| `short:\"X\"`          | Short name, if flag.                                                                                                                                                                                                                                                                                                           |\n| `aliases:\"X,Y\"`      | One or more aliases (for cmd or flag).                                                                                                                                                                                                                                                                                         |\n| `required:\"\"`        | If present, flag/arg is required.                                                                                                                                                                                                                                                                                              |\n| `optional:\"\"`        | If present, flag/arg is optional.                                                                                                                                                                                                                                                                                              |\n| `hidden:\"\"`          | If present, command or flag is hidden.                                                                                                                                                                                                                                                                                         |\n| `negatable:\"\"`       | If present on a `bool` field, supports prefixing a flag with `--no-` to invert the default value                                                                                                                                                                                                                               |\n| `negatable:\"X\"`      | If present on a `bool` field, supports `--X` to invert the default value                                                                                                                                                                                                                                                       |\n| `format:\"X\"`         | Format for parsing input, if supported.                                                                                                                                                                                                                                                                                        |\n| `sep:\"X\"`            | Separator for sequences (defaults to \",\"). May be `none` to disable splitting.                                                                                                                                                                                                                                                 |\n| `mapsep:\"X\"`         | Separator for maps (defaults to \";\"). May be `none` to disable splitting.                                                                                                                                                                                                                                                      |\n| `enum:\"X,Y,...\"`     | Set of valid values allowed for this flag. An enum field must be `required` or have a valid `default`.                                                                                                                                                                                                                         |\n| `group:\"X\"`          | Logical group for a flag or command.                                                                                                                                                                                                                                                                                           |\n| `xor:\"X,Y,...\"`      | Exclusive OR groups for flags. Only one flag in the group can be used which is restricted within the same command. When combined with `required`, at least one of the `xor` group will be required.                                                                                                                            |\n| `and:\"X,Y,...\"`      | AND groups for flags. All flags in the group must be used in the same command. When combined with `required`, all flags in the group will be required.                                                                                                                                                                         |\n| `prefix:\"X\"`         | Prefix for all sub-flags.                                                                                                                                                                                                                                                                                                      |\n| `envprefix:\"X\"`      | Envar prefix for all sub-flags.                                                                                                                                                                                                                                                                                                |\n| `xorprefix:\"X\"`      | Prefix for all sub-flags in XOR/AND groups.                                                                                                                                                                                                                                                                                  |\n| `set:\"K=V\"`          | Set a variable for expansion by child elements. Multiples can occur.                                                                                                                                                                                                                                                           |\n| `embed:\"\"`           | If present, this field's children will be embedded in the parent. Useful for composition.                                                                                                                                                                                                                                      |\n| `passthrough:\"<mode>\"`[^1] | If present on a positional argument, it stops flag parsing when encountered, as if `--` was processed before. Useful for external command wrappers, like `exec`. On a command it requires that the command contains only one argument of type `[]string` which is then filled with everything following the command, unparsed. |\n| `-`                  | Ignore the field. Useful for adding non-CLI fields to a configuration struct. e.g `` `kong:\"-\"` ``                                                                                                                                                                                                                             |\n\n[^1]: `<mode>` can be `partial` or `all` (the default). `all` will pass through all arguments including flags, including\nflags. `partial` will validate flags until the first positional argument is encountered, then pass through all remaining\npositional arguments.\n\n## Plugins\n\nKong CLI's can be extended by embedding the `kong.Plugin` type and populating it with pointers to Kong annotated structs. For example:\n\n```go\nvar pluginOne struct {\n  PluginOneFlag string\n}\nvar pluginTwo struct {\n  PluginTwoFlag string\n}\nvar cli struct {\n  BaseFlag string\n  kong.Plugins\n}\ncli.Plugins = kong.Plugins{&pluginOne, &pluginTwo}\n```\n\nAdditionally if an interface type is embedded, it can also be populated with a Kong annotated struct.\n\n## Dynamic Commands\n\nWhile plugins give complete control over extending command-line interfaces, Kong\nalso supports dynamically adding commands via `kong.DynamicCommand()`.\n\n## Variable interpolation\n\nKong supports limited variable interpolation into help strings, enum lists and\ndefault values.\n\nVariables are in the form:\n\n    ${<name>}\n    ${<name>=<default>}\n\nVariables are set with the `Vars{\"key\": \"value\", ...}` option. Undefined\nvariable references in the grammar without a default will result in an error at\nconstruction time.\n\nVariables can also be set via the `set:\"K=V\"` tag. In this case, those variables will be available for that\nnode and all children. This is useful for composition by allowing the same struct to be reused.\n\nWhen interpolating into flag or argument help strings, some extra variables\nare defined from the value itself:\n\n    ${default}\n    ${enum}\n\nFor flags with associated environment variables, the variable `${env}` can be\ninterpolated into the help string. In the absence of this variable in the\nhelp string, Kong will append `($$${env})` to the help string.\n\neg.\n\n```go\ntype cli struct {\n  Config string `type:\"path\" default:\"${config_file}\"`\n}\n\nfunc main() {\n  kong.Parse(&cli,\n    kong.Vars{\n      \"config_file\": \"~/.app.conf\",\n    })\n}\n```\n\n## Validation\n\nKong does validation on the structure of a command-line, but also supports\nextensible validation. Any node in the tree may implement either of the following interfaces:\n\n```go\ntype Validatable interface {\n    Validate() error\n }\n```\n\n```go\ntype Validatable interface {\n    Validate(kctx *kong.Context) error\n }\n```\n\nIf one of these nodes is in the active command-line it will be called during\nnormal validation.\n\n## Modifying Kong's behaviour\n\nEach Kong parser can be configured via functional options passed to `New(cli any, options...Option)`.\n\nThe full set of options can be found [here](https://godoc.org/github.com/alecthomas/kong#Option).\n\n### `Name(help)` and `Description(help)` - set the application name description\n\nSet the application name and/or description.\n\nThe name of the application will default to the binary name, but can be overridden with `Name(name)`.\n\nAs with all help in Kong, text will be wrapped to the terminal.\n\n### `Configuration(loader, paths...)` - load defaults from configuration files\n\nThis option provides Kong with support for loading defaults from a set of configuration files. Each file is opened, if possible, and the loader called to create a resolver for that file.\n\neg.\n\n```go\nkong.Parse(&cli, kong.Configuration(kong.JSON, \"/etc/myapp.json\", \"~/.myapp.json\"))\n```\n\n[See the tests](https://github.com/alecthomas/kong/blob/master/resolver_test.go#L206) for an example of how the JSON file is structured.\n\n#### List of Configuration Loaders\n\n- [YAML](https://github.com/alecthomas/kong-yaml)\n- [HCL](https://github.com/alecthomas/kong-hcl)\n- [TOML](https://github.com/alecthomas/kong-toml)\n- [JSON](https://github.com/alecthomas/kong)\n\n### `Resolver(...)` - support for default values from external sources\n\nResolvers are Kong's extension point for providing default values from external sources. As an example, support for environment variables via the `env` tag is provided by a resolver. There's also a builtin resolver for JSON configuration files.\n\nExample resolvers can be found in [resolver.go](https://github.com/alecthomas/kong/blob/master/resolver.go).\n\n### `*Mapper(...)` - customising how the command-line is mapped to Go values\n\nCommand-line arguments are mapped to Go values via the Mapper interface:\n\n```go\n// A Mapper represents how a field is mapped from command-line values to Go.\n//\n// Mappers can be associated with concrete fields via pointer, reflect.Type, reflect.Kind, or via a \"type\" tag.\n//\n// Additionally, if a type implements the MapperValue interface, it will be used.\ntype Mapper interface {\n\t// Decode ctx.Value with ctx.Scanner into target.\n\tDecode(ctx *DecodeContext, target reflect.Value) error\n}\n```\n\nAll builtin Go types (as well as a bunch of useful stdlib types like `time.Time`) have mappers registered by default. Mappers for custom types can be added using `kong.??Mapper(...)` options. Mappers are applied to fields in four ways:\n\n1. `NamedMapper(string, Mapper)` and using the tag key `type:\"<name>\"`.\n2. `KindMapper(reflect.Kind, Mapper)`.\n3. `TypeMapper(reflect.Type, Mapper)`.\n4. `ValueMapper(any, Mapper)`, passing in a pointer to a field of the grammar.\n\n### `ConfigureHelp(HelpOptions)` and `Help(HelpFunc)` - customising help\n\nThe default help output is usually sufficient, but if not there are two solutions.\n\n1. Use `ConfigureHelp(HelpOptions)` to configure how help is formatted (see [HelpOptions](https://godoc.org/github.com/alecthomas/kong#HelpOptions) for details).\n2. Custom help can be wired into Kong via the `Help(HelpFunc)` option. The `HelpFunc` is passed a `Context`, which contains the parsed context for the current command-line. See the implementation of `DefaultHelpPrinter` for an example.\n3. Use `ValueFormatter(HelpValueFormatter)` if you want to just customize the help text that is accompanied by flags and arguments.\n4. Use `Groups([]Group)` if you want to customize group titles or add a header.\n\n### Injecting values into `Run()` methods\n\nThere are several ways to inject values into `Run()` methods:\n\n1. Use `Bind()` to bind values directly.\n2. Use `BindTo()` to bind values to an interface type.\n3. Use `BindToProvider()` to bind values to a function that provides the value.\n4. Implement `Provide<Type>() error` methods on the command structure.\n\n### Other options\n\nThe full set of options can be found [here](https://godoc.org/github.com/alecthomas/kong#Option).\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "benchmark_test.go",
          "type": "blob",
          "size": 1.625,
          "content": "package kong\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc BenchmarkKong_interpolate(b *testing.B) {\n\tprepareKong := func(t testing.TB, count int) *Kong {\n\t\tt.Helper()\n\t\tk := &Kong{\n\t\t\tvars:     make(Vars, count),\n\t\t\tregistry: NewRegistry().RegisterDefaults(),\n\t\t}\n\t\tfor i := 0; i < count; i++ {\n\t\t\thelpVar := fmt.Sprintf(\"help_param%d\", i)\n\t\t\tk.vars[helpVar] = strconv.Itoa(i)\n\t\t}\n\t\tgrammar := &struct {\n\t\t\tParam0 string `help:\"${help_param0}\"`\n\t\t}{}\n\t\tmodel, err := build(k, grammar)\n\t\tassert.NoError(t, err)\n\t\tfor i := 0; i < count; i++ {\n\t\t\tmodel.Node.Flags = append(model.Node.Flags, &Flag{\n\t\t\t\tValue: &Value{\n\t\t\t\t\tHelp: fmt.Sprintf(\"${help_param%d}\", i),\n\t\t\t\t\tTag:  newEmptyTag(),\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t\tk.Model = model\n\t\treturn k\n\t}\n\n\tfor _, count := range []int{5, 500, 5000} {\n\t\tcount := count\n\t\tb.Run(strconv.Itoa(count), func(b *testing.B) {\n\t\t\tvar err error\n\t\t\tk := prepareKong(b, count)\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\terr = k.interpolate(k.Model.Node)\n\t\t\t}\n\t\t\tassert.NoError(b, err)\n\t\t\tb.ReportAllocs()\n\t\t})\n\t}\n}\n\nfunc Benchmark_interpolateValue(b *testing.B) {\n\tvarsLen := 10000\n\tk := &Kong{\n\t\tvars:     make(Vars, 10000),\n\t\tregistry: NewRegistry().RegisterDefaults(),\n\t}\n\tfor i := 0; i < varsLen; i++ {\n\t\thelpVar := fmt.Sprintf(\"help_param%d\", i)\n\t\tk.vars[helpVar] = strconv.Itoa(i)\n\t}\n\tgrammar := struct {\n\t\tParam9999 string `kong:\"cmd,help=${help_param9999}\"`\n\t}{}\n\tmodel, err := build(k, &grammar)\n\tif err != nil {\n\t\tb.FailNow()\n\t}\n\tk.Model = model\n\tflag := k.Model.Flags[0]\n\tfor i := 0; i < b.N; i++ {\n\t\terr = k.interpolateValue(flag.Value, k.vars)\n\t\tif err != nil {\n\t\t\tb.FailNow()\n\t\t}\n\t}\n\tb.ReportAllocs()\n}\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.go",
          "type": "blob",
          "size": 10.369140625,
          "content": "package kong\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// Plugins are dynamically embedded command-line structures.\n//\n// Each element in the Plugins list *must* be a pointer to a structure.\ntype Plugins []any\n\nfunc build(k *Kong, ast any) (app *Application, err error) {\n\tv := reflect.ValueOf(ast)\n\tiv := reflect.Indirect(v)\n\tif v.Kind() != reflect.Ptr || iv.Kind() != reflect.Struct {\n\t\treturn nil, fmt.Errorf(\"expected a pointer to a struct but got %T\", ast)\n\t}\n\n\tapp = &Application{}\n\textraFlags := k.extraFlags()\n\tseenFlags := map[string]bool{}\n\tfor _, flag := range extraFlags {\n\t\tseenFlags[flag.Name] = true\n\t}\n\n\tnode, err := buildNode(k, iv, ApplicationNode, newEmptyTag(), seenFlags)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(node.Positional) > 0 && len(node.Children) > 0 {\n\t\treturn nil, fmt.Errorf(\"can't mix positional arguments and branching arguments on %T\", ast)\n\t}\n\tapp.Node = node\n\tapp.Node.Flags = append(extraFlags, app.Node.Flags...)\n\tapp.Tag = newEmptyTag()\n\tapp.Tag.Vars = k.vars\n\treturn app, nil\n}\n\nfunc dashedString(s string) string {\n\treturn strings.Join(camelCase(s), \"-\")\n}\n\ntype flattenedField struct {\n\tfield reflect.StructField\n\tvalue reflect.Value\n\ttag   *Tag\n}\n\nfunc flattenedFields(v reflect.Value, ptag *Tag) (out []flattenedField, err error) {\n\tv = reflect.Indirect(v)\n\tif v.Kind() != reflect.Struct {\n\t\treturn out, nil\n\t}\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tft := v.Type().Field(i)\n\t\tfv := v.Field(i)\n\t\ttag, err := parseTag(v, ft)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif tag.Ignored {\n\t\t\tcontinue\n\t\t}\n\t\t// Assign group if it's not already set.\n\t\tif tag.Group == \"\" {\n\t\t\ttag.Group = ptag.Group\n\t\t}\n\t\t// Accumulate prefixes.\n\t\ttag.Prefix = ptag.Prefix + tag.Prefix\n\t\ttag.EnvPrefix = ptag.EnvPrefix + tag.EnvPrefix\n\t\ttag.XorPrefix = ptag.XorPrefix + tag.XorPrefix\n\t\t// Combine parent vars.\n\t\ttag.Vars = ptag.Vars.CloneWith(tag.Vars)\n\t\t// Command and embedded structs can be pointers, so we hydrate them now.\n\t\tif (tag.Cmd || tag.Embed) && ft.Type.Kind() == reflect.Ptr {\n\t\t\tfv = reflect.New(ft.Type.Elem()).Elem()\n\t\t\tv.FieldByIndex(ft.Index).Set(fv.Addr())\n\t\t}\n\t\tif !ft.Anonymous && !tag.Embed {\n\t\t\tif fv.CanSet() {\n\t\t\t\tfield := flattenedField{field: ft, value: fv, tag: tag}\n\t\t\t\tout = append(out, field)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Embedded type.\n\t\tif fv.Kind() == reflect.Interface {\n\t\t\tfv = fv.Elem()\n\t\t} else if fv.Type() == reflect.TypeOf(Plugins{}) {\n\t\t\tfor i := 0; i < fv.Len(); i++ {\n\t\t\t\tfields, ferr := flattenedFields(fv.Index(i).Elem(), tag)\n\t\t\t\tif ferr != nil {\n\t\t\t\t\treturn nil, ferr\n\t\t\t\t}\n\t\t\t\tout = append(out, fields...)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tsub, err := flattenedFields(fv, tag)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tout = append(out, sub...)\n\t}\n\treturn out, nil\n}\n\n// Build a Node in the Kong data model.\n//\n// \"v\" is the value to create the node from, \"typ\" is the output Node type.\nfunc buildNode(k *Kong, v reflect.Value, typ NodeType, tag *Tag, seenFlags map[string]bool) (*Node, error) { //nolint:gocyclo\n\tnode := &Node{\n\t\tType:   typ,\n\t\tTarget: v,\n\t\tTag:    tag,\n\t}\n\tfields, err := flattenedFields(v, tag)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\nMAIN:\n\tfor _, field := range fields {\n\t\tfor _, r := range k.ignoreFields {\n\t\t\tif r.MatchString(v.Type().Name() + \".\" + field.field.Name) {\n\t\t\t\tcontinue MAIN\n\t\t\t}\n\t\t}\n\n\t\tft := field.field\n\t\tfv := field.value\n\n\t\ttag := field.tag\n\t\tname := tag.Name\n\t\tif name == \"\" {\n\t\t\tname = tag.Prefix + k.flagNamer(ft.Name)\n\t\t} else {\n\t\t\tname = tag.Prefix + name\n\t\t}\n\n\t\tif len(tag.Envs) != 0 {\n\t\t\tfor i := range tag.Envs {\n\t\t\t\ttag.Envs[i] = tag.EnvPrefix + tag.Envs[i]\n\t\t\t}\n\t\t}\n\n\t\tif len(tag.Xor) != 0 {\n\t\t\tfor i := range tag.Xor {\n\t\t\t\ttag.Xor[i] = tag.XorPrefix + tag.Xor[i]\n\t\t\t}\n\t\t}\n\n\t\tif len(tag.And) != 0 {\n\t\t\tfor i := range tag.And {\n\t\t\t\ttag.And[i] = tag.XorPrefix + tag.And[i]\n\t\t\t}\n\t\t}\n\n\t\t// Nested structs are either commands or args, unless they implement the Mapper interface.\n\t\tif field.value.Kind() == reflect.Struct && (tag.Cmd || tag.Arg) && k.registry.ForValue(fv) == nil {\n\t\t\ttyp := CommandNode\n\t\t\tif tag.Arg {\n\t\t\t\ttyp = ArgumentNode\n\t\t\t}\n\t\t\terr = buildChild(k, node, typ, v, ft, fv, tag, name, seenFlags)\n\t\t} else {\n\t\t\terr = buildField(k, node, v, ft, fv, tag, name, seenFlags)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Validate if there are no duplicate names\n\tif err := checkDuplicateNames(node, v); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// \"Unsee\" flags.\n\tfor _, flag := range node.Flags {\n\t\tdelete(seenFlags, \"--\"+flag.Name)\n\t\tif flag.Short != 0 {\n\t\t\tdelete(seenFlags, \"-\"+string(flag.Short))\n\t\t}\n\t\tif negFlag := negatableFlagName(flag.Name, flag.Tag.Negatable); negFlag != \"\" {\n\t\t\tdelete(seenFlags, negFlag)\n\t\t}\n\t\tfor _, aflag := range flag.Aliases {\n\t\t\tdelete(seenFlags, \"--\"+aflag)\n\t\t}\n\t}\n\n\tif err := validatePositionalArguments(node); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn node, nil\n}\n\nfunc validatePositionalArguments(node *Node) error {\n\tvar last *Value\n\tfor i, curr := range node.Positional {\n\t\tif last != nil {\n\t\t\t// Scan through argument positionals to ensure optional is never before a required.\n\t\t\tif !last.Required && curr.Required {\n\t\t\t\treturn fmt.Errorf(\"%s: required %q cannot come after optional %q\", node.FullPath(), curr.Name, last.Name)\n\t\t\t}\n\n\t\t\t// Cumulative argument needs to be last.\n\t\t\tif last.IsCumulative() {\n\t\t\t\treturn fmt.Errorf(\"%s: argument %q cannot come after cumulative %q\", node.FullPath(), curr.Name, last.Name)\n\t\t\t}\n\t\t}\n\n\t\tlast = curr\n\t\tcurr.Position = i\n\t}\n\n\treturn nil\n}\n\nfunc buildChild(k *Kong, node *Node, typ NodeType, v reflect.Value, ft reflect.StructField, fv reflect.Value, tag *Tag, name string, seenFlags map[string]bool) error {\n\tchild, err := buildNode(k, fv, typ, newEmptyTag(), seenFlags)\n\tif err != nil {\n\t\treturn err\n\t}\n\tchild.Name = name\n\tchild.Tag = tag\n\tchild.Parent = node\n\tchild.Help = tag.Help\n\tchild.Hidden = tag.Hidden\n\tchild.Group = buildGroupForKey(k, tag.Group)\n\tchild.Aliases = tag.Aliases\n\n\tif provider, ok := fv.Addr().Interface().(HelpProvider); ok {\n\t\tchild.Detail = provider.Help()\n\t}\n\n\t// A branching argument. This is a bit hairy, as we let buildNode() do the parsing, then check that\n\t// a positional argument is provided to the child, and move it to the branching argument field.\n\tif tag.Arg {\n\t\tif len(child.Positional) == 0 {\n\t\t\treturn failField(v, ft, \"positional branch must have at least one child positional argument named %q\", name)\n\t\t}\n\t\tif child.Positional[0].Name != name {\n\t\t\treturn failField(v, ft, \"first field in positional branch must have the same name as the parent field (%s).\", child.Name)\n\t\t}\n\n\t\tchild.Argument = child.Positional[0]\n\t\tchild.Positional = child.Positional[1:]\n\t\tif child.Help == \"\" {\n\t\t\tchild.Help = child.Argument.Help\n\t\t}\n\t} else {\n\t\tif tag.HasDefault {\n\t\t\tif node.DefaultCmd != nil {\n\t\t\t\treturn failField(v, ft, \"can't have more than one default command under %s\", node.Summary())\n\t\t\t}\n\t\t\tif tag.Default != \"withargs\" && (len(child.Children) > 0 || len(child.Positional) > 0) {\n\t\t\t\treturn failField(v, ft, \"default command %s must not have subcommands or arguments\", child.Summary())\n\t\t\t}\n\t\t\tnode.DefaultCmd = child\n\t\t}\n\t\tif tag.Passthrough {\n\t\t\tif len(child.Children) > 0 || len(child.Flags) > 0 {\n\t\t\t\treturn failField(v, ft, \"passthrough command %s must not have subcommands or flags\", child.Summary())\n\t\t\t}\n\t\t\tif len(child.Positional) != 1 {\n\t\t\t\treturn failField(v, ft, \"passthrough command %s must contain exactly one positional argument\", child.Summary())\n\t\t\t}\n\t\t\tif !checkPassthroughArg(child.Positional[0].Target) {\n\t\t\t\treturn failField(v, ft, \"passthrough command %s must contain exactly one positional argument of []string type\", child.Summary())\n\t\t\t}\n\t\t\tchild.Passthrough = true\n\t\t}\n\t}\n\tnode.Children = append(node.Children, child)\n\n\tif len(child.Positional) > 0 && len(child.Children) > 0 {\n\t\treturn failField(v, ft, \"can't mix positional arguments and branching arguments\")\n\t}\n\n\treturn nil\n}\n\nfunc buildField(k *Kong, node *Node, v reflect.Value, ft reflect.StructField, fv reflect.Value, tag *Tag, name string, seenFlags map[string]bool) error {\n\tmapper := k.registry.ForNamedValue(tag.Type, fv)\n\tif mapper == nil {\n\t\treturn failField(v, ft, \"unsupported field type %s, perhaps missing a cmd:\\\"\\\" tag?\", ft.Type)\n\t}\n\n\tvalue := &Value{\n\t\tName:            name,\n\t\tHelp:            tag.Help,\n\t\tOrigHelp:        tag.Help,\n\t\tHasDefault:      tag.HasDefault,\n\t\tDefault:         tag.Default,\n\t\tDefaultValue:    reflect.New(fv.Type()).Elem(),\n\t\tMapper:          mapper,\n\t\tTag:             tag,\n\t\tTarget:          fv,\n\t\tEnum:            tag.Enum,\n\t\tPassthrough:     tag.Passthrough,\n\t\tPassthroughMode: tag.PassthroughMode,\n\n\t\t// Flags are optional by default, and args are required by default.\n\t\tRequired: (!tag.Arg && tag.Required) || (tag.Arg && !tag.Optional),\n\t\tFormat:   tag.Format,\n\t}\n\n\tif tag.Arg {\n\t\tnode.Positional = append(node.Positional, value)\n\t} else {\n\t\tif seenFlags[\"--\"+value.Name] {\n\t\t\treturn failField(v, ft, \"duplicate flag --%s\", value.Name)\n\t\t}\n\t\tseenFlags[\"--\"+value.Name] = true\n\t\tfor _, alias := range tag.Aliases {\n\t\t\taliasFlag := \"--\" + alias\n\t\t\tif seenFlags[aliasFlag] {\n\t\t\t\treturn failField(v, ft, \"duplicate flag %s\", aliasFlag)\n\t\t\t}\n\t\t\tseenFlags[aliasFlag] = true\n\t\t}\n\t\tif tag.Short != 0 {\n\t\t\tif seenFlags[\"-\"+string(tag.Short)] {\n\t\t\t\treturn failField(v, ft, \"duplicate short flag -%c\", tag.Short)\n\t\t\t}\n\t\t\tseenFlags[\"-\"+string(tag.Short)] = true\n\t\t}\n\t\tif tag.Negatable != \"\" {\n\t\t\tnegFlag := negatableFlagName(value.Name, tag.Negatable)\n\t\t\tif seenFlags[negFlag] {\n\t\t\t\treturn failField(v, ft, \"duplicate negation flag %s\", negFlag)\n\t\t\t}\n\t\t\tseenFlags[negFlag] = true\n\t\t}\n\t\tflag := &Flag{\n\t\t\tValue:       value,\n\t\t\tAliases:     tag.Aliases,\n\t\t\tShort:       tag.Short,\n\t\t\tPlaceHolder: tag.PlaceHolder,\n\t\t\tEnvs:        tag.Envs,\n\t\t\tGroup:       buildGroupForKey(k, tag.Group),\n\t\t\tXor:         tag.Xor,\n\t\t\tAnd:         tag.And,\n\t\t\tHidden:      tag.Hidden,\n\t\t}\n\t\tvalue.Flag = flag\n\t\tnode.Flags = append(node.Flags, flag)\n\t}\n\treturn nil\n}\n\nfunc buildGroupForKey(k *Kong, key string) *Group {\n\tif key == \"\" {\n\t\treturn nil\n\t}\n\tfor _, group := range k.groups {\n\t\tif group.Key == key {\n\t\t\treturn &group\n\t\t}\n\t}\n\n\t// No group provided with kong.ExplicitGroups. We create one ad-hoc for this key.\n\treturn &Group{\n\t\tKey:   key,\n\t\tTitle: key,\n\t}\n}\n\nfunc checkDuplicateNames(node *Node, v reflect.Value) error {\n\tseenNames := make(map[string]struct{})\n\tfor _, node := range node.Children {\n\t\tif _, ok := seenNames[node.Name]; ok {\n\t\t\tname := v.Type().Name()\n\t\t\tif name == \"\" {\n\t\t\t\tname = \"<anonymous struct>\"\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"duplicate command name %q in command %q\", node.Name, name)\n\t\t}\n\n\t\tseenNames[node.Name] = struct{}{}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "callbacks.go",
          "type": "blob",
          "size": 3.7451171875,
          "content": "package kong\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// A map of type to function that returns a value of that type.\n//\n// The function should have the signature func(...) (T, error). Arguments are recursively resolved.\ntype bindings map[reflect.Type]any\n\nfunc (b bindings) String() string {\n\tout := []string{}\n\tfor k := range b {\n\t\tout = append(out, k.String())\n\t}\n\treturn \"bindings{\" + strings.Join(out, \", \") + \"}\"\n}\n\nfunc (b bindings) add(values ...any) bindings {\n\tfor _, v := range values {\n\t\tv := v\n\t\tb[reflect.TypeOf(v)] = func() (any, error) { return v, nil }\n\t}\n\treturn b\n}\n\nfunc (b bindings) addTo(impl, iface any) {\n\tb[reflect.TypeOf(iface).Elem()] = func() (any, error) { return impl, nil }\n}\n\nfunc (b bindings) addProvider(provider any) error {\n\tpv := reflect.ValueOf(provider)\n\tt := pv.Type()\n\tif t.Kind() != reflect.Func || t.NumOut() != 2 || t.Out(1) != reflect.TypeOf((*error)(nil)).Elem() {\n\t\treturn fmt.Errorf(\"%T must be a function with the signature func(...)(T, error)\", provider)\n\t}\n\trt := pv.Type().Out(0)\n\tb[rt] = provider\n\treturn nil\n}\n\n// Clone and add values.\nfunc (b bindings) clone() bindings {\n\tout := make(bindings, len(b))\n\tfor k, v := range b {\n\t\tout[k] = v\n\t}\n\treturn out\n}\n\nfunc (b bindings) merge(other bindings) bindings {\n\tfor k, v := range other {\n\t\tb[k] = v\n\t}\n\treturn b\n}\n\nfunc getMethod(value reflect.Value, name string) reflect.Value {\n\tmethod := value.MethodByName(name)\n\tif !method.IsValid() {\n\t\tif value.CanAddr() {\n\t\t\tmethod = value.Addr().MethodByName(name)\n\t\t}\n\t}\n\treturn method\n}\n\n// Get methods from the given value and any embedded fields.\nfunc getMethods(value reflect.Value, name string) []reflect.Value {\n\t// Collect all possible receivers\n\treceivers := []reflect.Value{value}\n\tif value.Kind() == reflect.Ptr {\n\t\tvalue = value.Elem()\n\t}\n\tif value.Kind() == reflect.Struct {\n\t\tt := value.Type()\n\t\tfor i := 0; i < value.NumField(); i++ {\n\t\t\tfield := value.Field(i)\n\t\t\tfieldType := t.Field(i)\n\t\t\tif fieldType.IsExported() && fieldType.Anonymous {\n\t\t\t\treceivers = append(receivers, field)\n\t\t\t}\n\t\t}\n\t}\n\t// Search all receivers for methods\n\tvar methods []reflect.Value\n\tfor _, receiver := range receivers {\n\t\tif method := getMethod(receiver, name); method.IsValid() {\n\t\t\tmethods = append(methods, method)\n\t\t}\n\t}\n\treturn methods\n}\n\nfunc callFunction(f reflect.Value, bindings bindings) error {\n\tif f.Kind() != reflect.Func {\n\t\treturn fmt.Errorf(\"expected function, got %s\", f.Type())\n\t}\n\tt := f.Type()\n\tif t.NumOut() != 1 || !t.Out(0).Implements(callbackReturnSignature) {\n\t\treturn fmt.Errorf(\"return value of %s must implement \\\"error\\\"\", t)\n\t}\n\tout, err := callAnyFunction(f, bindings)\n\tif err != nil {\n\t\treturn err\n\t}\n\tferr := out[0]\n\tif ferrv := reflect.ValueOf(ferr); !ferrv.IsValid() || ((ferrv.Kind() == reflect.Interface || ferrv.Kind() == reflect.Pointer) && ferrv.IsNil()) {\n\t\treturn nil\n\t}\n\treturn ferr.(error) //nolint:forcetypeassert\n}\n\nfunc callAnyFunction(f reflect.Value, bindings bindings) (out []any, err error) {\n\tif f.Kind() != reflect.Func {\n\t\treturn nil, fmt.Errorf(\"expected function, got %s\", f.Type())\n\t}\n\tin := []reflect.Value{}\n\tt := f.Type()\n\tfor i := 0; i < t.NumIn(); i++ {\n\t\tpt := t.In(i)\n\t\targf, ok := bindings[pt]\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"couldn't find binding of type %s for parameter %d of %s(), use kong.Bind(%s)\", pt, i, t, pt)\n\t\t}\n\t\t// Recursively resolve binding functions.\n\t\targv, err := callAnyFunction(reflect.ValueOf(argf), bindings)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"%s: %w\", pt, err)\n\t\t}\n\t\tif ferrv := reflect.ValueOf(argv[len(argv)-1]); ferrv.IsValid() && !ferrv.IsNil() {\n\t\t\treturn nil, ferrv.Interface().(error) //nolint:forcetypeassert\n\t\t}\n\t\tin = append(in, reflect.ValueOf(argv[0]))\n\t}\n\toutv := f.Call(in)\n\tout = make([]any, len(outv))\n\tfor i, v := range outv {\n\t\tout[i] = v.Interface()\n\t}\n\treturn out, nil\n}\n"
        },
        {
          "name": "camelcase.go",
          "type": "blob",
          "size": 2.775390625,
          "content": "package kong\n\n// NOTE: This code is from https://github.com/fatih/camelcase. MIT license.\n\nimport (\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\n// Split splits the camelcase word and returns a list of words. It also\n// supports digits. Both lower camel case and upper camel case are supported.\n// For more info please check: http://en.wikipedia.org/wiki/CamelCase\n//\n// Examples\n//\n//\t\"\" =>                     [\"\"]\n//\t\"lowercase\" =>            [\"lowercase\"]\n//\t\"Class\" =>                [\"Class\"]\n//\t\"MyClass\" =>              [\"My\", \"Class\"]\n//\t\"MyC\" =>                  [\"My\", \"C\"]\n//\t\"HTML\" =>                 [\"HTML\"]\n//\t\"PDFLoader\" =>            [\"PDF\", \"Loader\"]\n//\t\"AString\" =>              [\"A\", \"String\"]\n//\t\"SimpleXMLParser\" =>      [\"Simple\", \"XML\", \"Parser\"]\n//\t\"vimRPCPlugin\" =>         [\"vim\", \"RPC\", \"Plugin\"]\n//\t\"GL11Version\" =>          [\"GL\", \"11\", \"Version\"]\n//\t\"99Bottles\" =>            [\"99\", \"Bottles\"]\n//\t\"May5\" =>                 [\"May\", \"5\"]\n//\t\"BFG9000\" =>              [\"BFG\", \"9000\"]\n//\t\"BÃ¶seÃœberraschung\" =>     [\"BÃ¶se\", \"Ãœberraschung\"]\n//\t\"Two  spaces\" =>          [\"Two\", \"  \", \"spaces\"]\n//\t\"BadUTF8\\xe2\\xe2\\xa1\" =>  [\"BadUTF8\\xe2\\xe2\\xa1\"]\n//\n// Splitting rules\n//\n//  1. If string is not valid UTF-8, return it without splitting as\n//     single item array.\n//  2. Assign all unicode characters into one of 4 sets: lower case\n//     letters, upper case letters, numbers, and all other characters.\n//  3. Iterate through characters of string, introducing splits\n//     between adjacent characters that belong to different sets.\n//  4. Iterate through array of split strings, and if a given string\n//     is upper case:\n//     if subsequent string is lower case:\n//     move last character of upper case string to beginning of\n//     lower case string\nfunc camelCase(src string) (entries []string) {\n\t// don't split invalid utf8\n\tif !utf8.ValidString(src) {\n\t\treturn []string{src}\n\t}\n\tentries = []string{}\n\tvar runes [][]rune\n\tlastClass := 0\n\t// split into fields based on class of unicode character\n\tfor _, r := range src {\n\t\tvar class int\n\t\tswitch {\n\t\tcase unicode.IsLower(r):\n\t\t\tclass = 1\n\t\tcase unicode.IsUpper(r):\n\t\t\tclass = 2\n\t\tcase unicode.IsDigit(r):\n\t\t\tclass = 3\n\t\tdefault:\n\t\t\tclass = 4\n\t\t}\n\t\tif class == lastClass {\n\t\t\trunes[len(runes)-1] = append(runes[len(runes)-1], r)\n\t\t} else {\n\t\t\trunes = append(runes, []rune{r})\n\t\t}\n\t\tlastClass = class\n\t}\n\t// handle upper case -> lower case sequences, e.g.\n\t// \"PDFL\", \"oader\" -> \"PDF\", \"Loader\"\n\tfor i := 0; i < len(runes)-1; i++ {\n\t\tif unicode.IsUpper(runes[i][0]) && unicode.IsLower(runes[i+1][0]) {\n\t\t\trunes[i+1] = append([]rune{runes[i][len(runes[i])-1]}, runes[i+1]...)\n\t\t\trunes[i] = runes[i][:len(runes[i])-1]\n\t\t}\n\t}\n\t// construct []string from results\n\tfor _, s := range runes {\n\t\tif len(s) > 0 {\n\t\t\tentries = append(entries, string(s))\n\t\t}\n\t}\n\treturn entries\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 1.125,
          "content": "package kong_test\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n\t\"github.com/alecthomas/kong\"\n)\n\nfunc TestMultipleConfigLoading(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `json:\"flag,omitempty\"`\n\t}\n\n\tcli.Flag = \"first\"\n\tfirst, cleanFirst := makeConfig(t, &cli)\n\tdefer cleanFirst()\n\n\tcli.Flag = \"\"\n\tsecond, cleanSecond := makeConfig(t, &cli)\n\tdefer cleanSecond()\n\n\tp := mustNew(t, &cli, kong.Configuration(kong.JSON, first, second))\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"first\", cli.Flag)\n}\n\nfunc TestConfigValidation(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `json:\"flag,omitempty\" enum:\"valid\" required:\"\"`\n\t}\n\n\tcli.Flag = \"invalid\"\n\tconf, cleanConf := makeConfig(t, &cli)\n\tdefer cleanConf()\n\n\tp := mustNew(t, &cli, kong.Configuration(kong.JSON, conf))\n\t_, err := p.Parse(nil)\n\tassert.Error(t, err)\n}\n\nfunc makeConfig(t *testing.T, config any) (path string, cleanup func()) {\n\tt.Helper()\n\tw, err := os.CreateTemp(\"\", \"\")\n\tassert.NoError(t, err)\n\tdefer w.Close()\n\terr = json.NewEncoder(w).Encode(config)\n\tassert.NoError(t, err)\n\treturn w.Name(), func() { os.Remove(w.Name()) }\n}\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 28.193359375,
          "content": "package kong\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Path records the nodes and parsed values from the current command-line.\ntype Path struct {\n\tParent *Node\n\n\t// One of these will be non-nil.\n\tApp        *Application\n\tPositional *Positional\n\tFlag       *Flag\n\tArgument   *Argument\n\tCommand    *Command\n\n\t// Flags added by this node.\n\tFlags []*Flag\n\n\t// True if this Path element was created as the result of a resolver.\n\tResolved bool\n}\n\n// Node returns the Node associated with this Path, or nil if Path is a non-Node.\nfunc (p *Path) Node() *Node {\n\tswitch {\n\tcase p.App != nil:\n\t\treturn p.App.Node\n\n\tcase p.Argument != nil:\n\t\treturn p.Argument\n\n\tcase p.Command != nil:\n\t\treturn p.Command\n\t}\n\treturn nil\n}\n\n// Visitable returns the Visitable for this path element.\nfunc (p *Path) Visitable() Visitable {\n\tswitch {\n\tcase p.App != nil:\n\t\treturn p.App\n\n\tcase p.Argument != nil:\n\t\treturn p.Argument\n\n\tcase p.Command != nil:\n\t\treturn p.Command\n\n\tcase p.Flag != nil:\n\t\treturn p.Flag\n\n\tcase p.Positional != nil:\n\t\treturn p.Positional\n\t}\n\treturn nil\n}\n\n// Context contains the current parse context.\ntype Context struct {\n\t*Kong\n\t// A trace through parsed nodes.\n\tPath []*Path\n\t// Original command-line arguments.\n\tArgs []string\n\t// Error that occurred during trace, if any.\n\tError error\n\n\tvalues    map[*Value]reflect.Value // Temporary values during tracing.\n\tbindings  bindings\n\tresolvers []Resolver // Extra context-specific resolvers.\n\tscan      *Scanner\n}\n\n// Trace path of \"args\" through the grammar tree.\n//\n// The returned Context will include a Path of all commands, arguments, positionals and flags.\n//\n// This just constructs a new trace. To fully apply the trace you must call Reset(), Resolve(),\n// Validate() and Apply().\nfunc Trace(k *Kong, args []string) (*Context, error) {\n\tc := &Context{\n\t\tKong: k,\n\t\tArgs: args,\n\t\tPath: []*Path{\n\t\t\t{App: k.Model, Flags: k.Model.Flags},\n\t\t},\n\t\tvalues:   map[*Value]reflect.Value{},\n\t\tscan:     Scan(args...),\n\t\tbindings: bindings{},\n\t}\n\tc.Error = c.trace(c.Model.Node)\n\treturn c, nil\n}\n\n// Bind adds bindings to the Context.\nfunc (c *Context) Bind(args ...any) {\n\tc.bindings.add(args...)\n}\n\n// BindTo adds a binding to the Context.\n//\n// This will typically have to be called like so:\n//\n//\tBindTo(impl, (*MyInterface)(nil))\nfunc (c *Context) BindTo(impl, iface any) {\n\tc.bindings.addTo(impl, iface)\n}\n\n// BindToProvider allows binding of provider functions.\n//\n// This is useful when the Run() function of different commands require different values that may\n// not all be initialisable from the main() function.\nfunc (c *Context) BindToProvider(provider any) error {\n\treturn c.bindings.addProvider(provider)\n}\n\n// Value returns the value for a particular path element.\nfunc (c *Context) Value(path *Path) reflect.Value {\n\tswitch {\n\tcase path.Positional != nil:\n\t\treturn c.values[path.Positional]\n\tcase path.Flag != nil:\n\t\treturn c.values[path.Flag.Value]\n\tcase path.Argument != nil:\n\t\treturn c.values[path.Argument.Argument]\n\t}\n\tpanic(\"can only retrieve value for flag, argument or positional\")\n}\n\n// Selected command or argument.\nfunc (c *Context) Selected() *Node {\n\tvar selected *Node\n\tfor _, path := range c.Path {\n\t\tswitch {\n\t\tcase path.Command != nil:\n\t\t\tselected = path.Command\n\t\tcase path.Argument != nil:\n\t\t\tselected = path.Argument\n\t\t}\n\t}\n\treturn selected\n}\n\n// Empty returns true if there were no arguments provided.\nfunc (c *Context) Empty() bool {\n\tfor _, path := range c.Path {\n\t\tif !path.Resolved && path.App == nil {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Validate the current context.\nfunc (c *Context) Validate() error { //nolint: gocyclo\n\terr := Visit(c.Model, func(node Visitable, next Next) error {\n\t\tswitch node := node.(type) {\n\t\tcase *Value:\n\t\t\tok := atLeastOneEnvSet(node.Tag.Envs)\n\t\t\tif node.Enum != \"\" && (!node.Required || node.HasDefault || (len(node.Tag.Envs) != 0 && ok)) {\n\t\t\t\tif err := checkEnum(node, node.Target); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase *Flag:\n\t\t\tok := atLeastOneEnvSet(node.Tag.Envs)\n\t\t\tif node.Enum != \"\" && (!node.Required || node.HasDefault || (len(node.Tag.Envs) != 0 && ok)) {\n\t\t\t\tif err := checkEnum(node.Value, node.Target); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next(nil)\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, el := range c.Path {\n\t\tvar (\n\t\t\tvalue reflect.Value\n\t\t\tdesc  string\n\t\t)\n\t\tswitch node := el.Visitable().(type) {\n\t\tcase *Value:\n\t\t\tvalue = node.Target\n\t\t\tdesc = node.ShortSummary()\n\n\t\tcase *Flag:\n\t\t\tvalue = node.Target\n\t\t\tdesc = node.ShortSummary()\n\n\t\tcase *Application:\n\t\t\tvalue = node.Target\n\t\t\tdesc = \"\"\n\n\t\tcase *Node:\n\t\t\tvalue = node.Target\n\t\t\tdesc = node.Path()\n\t\t}\n\t\tif validate := isValidatable(value); validate != nil {\n\t\t\tif err := validate.Validate(c); err != nil {\n\t\t\t\tif desc != \"\" {\n\t\t\t\t\treturn fmt.Errorf(\"%s: %w\", desc, err)\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tfor _, resolver := range c.combineResolvers() {\n\t\tif err := resolver.Validate(c.Model); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, path := range c.Path {\n\t\tvar value *Value\n\t\tswitch {\n\t\tcase path.Flag != nil:\n\t\t\tvalue = path.Flag.Value\n\n\t\tcase path.Positional != nil:\n\t\t\tvalue = path.Positional\n\t\t}\n\t\tif value != nil && value.Tag.Enum != \"\" {\n\t\t\tif err := checkEnum(value, value.Target); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := checkMissingFlags(path.Flags); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Check the terminal node.\n\tnode := c.Selected()\n\tif node == nil {\n\t\tnode = c.Model.Node\n\t}\n\n\t// Find deepest positional argument so we can check if all required positionals have been provided.\n\tpositionals := 0\n\tfor _, path := range c.Path {\n\t\tif path.Positional != nil {\n\t\t\tpositionals = path.Positional.Position + 1\n\t\t}\n\t}\n\n\tif err := checkMissingChildren(node); err != nil {\n\t\treturn err\n\t}\n\tif err := checkMissingPositionals(positionals, node.Positional); err != nil {\n\t\treturn err\n\t}\n\tif err := checkXorDuplicatedAndAndMissing(c.Path); err != nil {\n\t\treturn err\n\t}\n\n\tif node.Type == ArgumentNode {\n\t\tvalue := node.Argument\n\t\tif value.Required && !value.Set {\n\t\t\treturn fmt.Errorf(\"%s is required\", node.Summary())\n\t\t}\n\t}\n\treturn nil\n}\n\n// Flags returns the accumulated available flags.\nfunc (c *Context) Flags() (flags []*Flag) {\n\tfor _, trace := range c.Path {\n\t\tflags = append(flags, trace.Flags...)\n\t}\n\treturn\n}\n\n// Command returns the full command path.\nfunc (c *Context) Command() string {\n\tcommand := []string{}\n\tfor _, trace := range c.Path {\n\t\tswitch {\n\t\tcase trace.Positional != nil:\n\t\t\tcommand = append(command, \"<\"+trace.Positional.Name+\">\")\n\n\t\tcase trace.Argument != nil:\n\t\t\tcommand = append(command, \"<\"+trace.Argument.Name+\">\")\n\n\t\tcase trace.Command != nil:\n\t\t\tcommand = append(command, trace.Command.Name)\n\t\t}\n\t}\n\treturn strings.Join(command, \" \")\n}\n\n// AddResolver adds a context-specific resolver.\n//\n// This is most useful in the BeforeResolve() hook.\nfunc (c *Context) AddResolver(resolver Resolver) {\n\tc.resolvers = append(c.resolvers, resolver)\n}\n\n// FlagValue returns the set value of a flag if it was encountered and exists, or its default value.\nfunc (c *Context) FlagValue(flag *Flag) any {\n\tfor _, trace := range c.Path {\n\t\tif trace.Flag == flag {\n\t\t\tv, ok := c.values[trace.Flag.Value]\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn v.Interface()\n\t\t}\n\t}\n\tif flag.Target.IsValid() {\n\t\treturn flag.Target.Interface()\n\t}\n\treturn flag.DefaultValue.Interface()\n}\n\n// Reset recursively resets values to defaults (as specified in the grammar) or the zero value.\nfunc (c *Context) Reset() error {\n\treturn Visit(c.Model.Node, func(node Visitable, next Next) error {\n\t\tif value, ok := node.(*Value); ok {\n\t\t\treturn next(value.Reset())\n\t\t}\n\t\treturn next(nil)\n\t})\n}\n\nfunc (c *Context) endParsing() {\n\targs := []string{}\n\tfor {\n\t\ttoken := c.scan.Pop()\n\t\tif token.Type == EOLToken {\n\t\t\tbreak\n\t\t}\n\t\targs = append(args, token.String())\n\t}\n\t// Note: tokens must be pushed in reverse order.\n\tfor i := range args {\n\t\tc.scan.PushTyped(args[len(args)-1-i], PositionalArgumentToken)\n\t}\n}\n\n//nolint:maintidx\nfunc (c *Context) trace(node *Node) (err error) { //nolint: gocyclo\n\tpositional := 0\n\tnode.Active = true\n\n\tflags := []*Flag{}\n\tflagNode := node\n\tif node.DefaultCmd != nil && node.DefaultCmd.Tag.Default == \"withargs\" {\n\t\t// Add flags of the default command if the current node has one\n\t\t// and that default command allows args / flags without explicitly\n\t\t// naming the command on the CLI.\n\t\tflagNode = node.DefaultCmd\n\t}\n\tfor _, group := range flagNode.AllFlags(false) {\n\t\tflags = append(flags, group...)\n\t}\n\n\tif node.Passthrough {\n\t\tc.endParsing()\n\t}\n\n\tfor !c.scan.Peek().IsEOL() {\n\t\ttoken := c.scan.Peek()\n\t\tswitch token.Type {\n\t\tcase UntypedToken:\n\t\t\tswitch v := token.Value.(type) {\n\t\t\tcase string:\n\n\t\t\t\tswitch {\n\t\t\t\tcase v == \"-\":\n\t\t\t\t\tfallthrough\n\t\t\t\tdefault: //nolint\n\t\t\t\t\tc.scan.Pop()\n\t\t\t\t\tc.scan.PushTyped(token.Value, PositionalArgumentToken)\n\n\t\t\t\t// Indicates end of parsing. All remaining arguments are treated as positional arguments only.\n\t\t\t\tcase v == \"--\":\n\t\t\t\t\tc.endParsing()\n\n\t\t\t\t\t// Pop the -- token unless the next positional argument accepts passthrough arguments.\n\t\t\t\t\tif !(positional < len(node.Positional) && node.Positional[positional].Passthrough) {\n\t\t\t\t\t\tc.scan.Pop()\n\t\t\t\t\t}\n\n\t\t\t\t// Long flag.\n\t\t\t\tcase strings.HasPrefix(v, \"--\"):\n\t\t\t\t\tc.scan.Pop()\n\t\t\t\t\t// Parse it and push the tokens.\n\t\t\t\t\tparts := strings.SplitN(v[2:], \"=\", 2)\n\t\t\t\t\tif len(parts) > 1 {\n\t\t\t\t\t\tc.scan.PushTyped(parts[1], FlagValueToken)\n\t\t\t\t\t}\n\t\t\t\t\tc.scan.PushTyped(parts[0], FlagToken)\n\n\t\t\t\t// Short flag.\n\t\t\t\tcase strings.HasPrefix(v, \"-\"):\n\t\t\t\t\tc.scan.Pop()\n\t\t\t\t\t// Note: tokens must be pushed in reverse order.\n\t\t\t\t\tif tail := v[2:]; tail != \"\" {\n\t\t\t\t\t\tc.scan.PushTyped(tail, ShortFlagTailToken)\n\t\t\t\t\t}\n\t\t\t\t\tc.scan.PushTyped(v[1:2], ShortFlagToken)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tc.scan.Pop()\n\t\t\t\tc.scan.PushTyped(token.Value, PositionalArgumentToken)\n\t\t\t}\n\n\t\tcase ShortFlagTailToken:\n\t\t\tc.scan.Pop()\n\t\t\t// Note: tokens must be pushed in reverse order.\n\t\t\tif tail := token.String()[1:]; tail != \"\" {\n\t\t\t\tc.scan.PushTyped(tail, ShortFlagTailToken)\n\t\t\t}\n\t\t\tc.scan.PushTyped(token.String()[0:1], ShortFlagToken)\n\n\t\tcase FlagToken:\n\t\t\tif err := c.parseFlag(flags, token.String()); err != nil {\n\t\t\t\tif isUnknownFlagError(err) && positional < len(node.Positional) && node.Positional[positional].PassthroughMode == PassThroughModeAll {\n\t\t\t\t\tc.scan.Pop()\n\t\t\t\t\tc.scan.PushTyped(token.String(), PositionalArgumentToken)\n\t\t\t\t} else {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase ShortFlagToken:\n\t\t\tif err := c.parseFlag(flags, token.String()); err != nil {\n\t\t\t\tif isUnknownFlagError(err) && positional < len(node.Positional) && node.Positional[positional].PassthroughMode == PassThroughModeAll {\n\t\t\t\t\tc.scan.Pop()\n\t\t\t\t\tc.scan.PushTyped(token.String(), PositionalArgumentToken)\n\t\t\t\t} else {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase FlagValueToken:\n\t\t\treturn fmt.Errorf(\"unexpected flag argument %q\", token.Value)\n\n\t\tcase PositionalArgumentToken:\n\t\t\tcandidates := []string{}\n\n\t\t\t// Ensure we've consumed all positional arguments.\n\t\t\tif positional < len(node.Positional) {\n\t\t\t\targ := node.Positional[positional]\n\n\t\t\t\tif arg.Passthrough {\n\t\t\t\t\tc.endParsing()\n\t\t\t\t}\n\n\t\t\t\targ.Active = true\n\t\t\t\terr := arg.Parse(c.scan, c.getValue(arg))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tc.Path = append(c.Path, &Path{\n\t\t\t\t\tParent:     node,\n\t\t\t\t\tPositional: arg,\n\t\t\t\t})\n\t\t\t\tpositional++\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Assign token value to a branch name if tagged as an alias\n\t\t\t// An alias will be ignored in the case of an existing command\n\t\t\tcmds := make(map[string]bool)\n\t\t\tfor _, branch := range node.Children {\n\t\t\t\tif branch.Type == CommandNode {\n\t\t\t\t\tcmds[branch.Name] = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, branch := range node.Children {\n\t\t\t\tfor _, a := range branch.Aliases {\n\t\t\t\t\t_, ok := cmds[a]\n\t\t\t\t\tif token.Value == a && !ok {\n\t\t\t\t\t\ttoken.Value = branch.Name\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// After positional arguments have been consumed, check commands next...\n\t\t\tfor _, branch := range node.Children {\n\t\t\t\tif branch.Type == CommandNode && !branch.Hidden {\n\t\t\t\t\tcandidates = append(candidates, branch.Name)\n\t\t\t\t}\n\t\t\t\tif branch.Type == CommandNode && branch.Name == token.Value {\n\t\t\t\t\tc.scan.Pop()\n\t\t\t\t\tc.Path = append(c.Path, &Path{\n\t\t\t\t\t\tParent:  node,\n\t\t\t\t\t\tCommand: branch,\n\t\t\t\t\t\tFlags:   branch.Flags,\n\t\t\t\t\t})\n\t\t\t\t\treturn c.trace(branch)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Finally, check arguments.\n\t\t\tfor _, branch := range node.Children {\n\t\t\t\tif branch.Type == ArgumentNode {\n\t\t\t\t\targ := branch.Argument\n\t\t\t\t\tif err := arg.Parse(c.scan, c.getValue(arg)); err == nil {\n\t\t\t\t\t\tc.Path = append(c.Path, &Path{\n\t\t\t\t\t\t\tParent:   node,\n\t\t\t\t\t\t\tArgument: branch,\n\t\t\t\t\t\t\tFlags:    branch.Flags,\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn c.trace(branch)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is a default command that allows args and nothing else\n\t\t\t// matches, take the branch of the default command\n\t\t\tif node.DefaultCmd != nil && node.DefaultCmd.Tag.Default == \"withargs\" {\n\t\t\t\tc.Path = append(c.Path, &Path{\n\t\t\t\t\tParent:  node,\n\t\t\t\t\tCommand: node.DefaultCmd,\n\t\t\t\t\tFlags:   node.DefaultCmd.Flags,\n\t\t\t\t})\n\t\t\t\treturn c.trace(node.DefaultCmd)\n\t\t\t}\n\n\t\t\treturn findPotentialCandidates(token.String(), candidates, \"unexpected argument %s\", token)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unexpected token %s\", token)\n\t\t}\n\t}\n\treturn c.maybeSelectDefault(flags, node)\n}\n\n// End of the line, check for a default command, but only if we're not displaying help,\n// otherwise we'd only ever display the help for the default command.\nfunc (c *Context) maybeSelectDefault(flags []*Flag, node *Node) error {\n\tfor _, flag := range flags {\n\t\tif flag.Name == \"help\" && flag.Set {\n\t\t\treturn nil\n\t\t}\n\t}\n\tif node.DefaultCmd != nil {\n\t\tc.Path = append(c.Path, &Path{\n\t\t\tParent:  node.DefaultCmd,\n\t\t\tCommand: node.DefaultCmd,\n\t\t\tFlags:   node.DefaultCmd.Flags,\n\t\t})\n\t}\n\treturn nil\n}\n\n// Resolve walks through the traced path, applying resolvers to any unset flags.\nfunc (c *Context) Resolve() error {\n\tresolvers := c.combineResolvers()\n\tif len(resolvers) == 0 {\n\t\treturn nil\n\t}\n\n\tinserted := []*Path{}\n\tfor _, path := range c.Path {\n\t\tfor _, flag := range path.Flags {\n\t\t\t// Flag has already been set on the command-line.\n\t\t\tif _, ok := c.values[flag.Value]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Pick the last resolved value.\n\t\t\tvar selected any\n\t\t\tfor _, resolver := range resolvers {\n\t\t\t\ts, err := resolver.Resolve(c, path, flag)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"%s: %w\", flag.ShortSummary(), err)\n\t\t\t\t}\n\t\t\t\tif s == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tselected = s\n\t\t\t}\n\n\t\t\tif selected == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tscan := Scan().PushTyped(selected, FlagValueToken)\n\t\t\tdelete(c.values, flag.Value)\n\t\t\terr := flag.Parse(scan, c.getValue(flag.Value))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tinserted = append(inserted, &Path{\n\t\t\t\tFlag:     flag,\n\t\t\t\tResolved: true,\n\t\t\t})\n\t\t}\n\t}\n\tc.Path = append(c.Path, inserted...)\n\treturn nil\n}\n\n// Combine application-level resolvers and context resolvers.\nfunc (c *Context) combineResolvers() []Resolver {\n\tresolvers := []Resolver{}\n\tresolvers = append(resolvers, c.Kong.resolvers...)\n\tresolvers = append(resolvers, c.resolvers...)\n\treturn resolvers\n}\n\nfunc (c *Context) getValue(value *Value) reflect.Value {\n\tv, ok := c.values[value]\n\tif !ok {\n\t\tv = reflect.New(value.Target.Type()).Elem()\n\t\tswitch v.Kind() {\n\t\tcase reflect.Ptr:\n\t\t\tv.Set(reflect.New(v.Type().Elem()))\n\t\tcase reflect.Slice:\n\t\t\tv.Set(reflect.MakeSlice(v.Type(), 0, 0))\n\t\tcase reflect.Map:\n\t\t\tv.Set(reflect.MakeMap(v.Type()))\n\t\tdefault:\n\t\t}\n\t\tc.values[value] = v\n\t}\n\treturn v\n}\n\n// ApplyDefaults if they are not already set.\nfunc (c *Context) ApplyDefaults() error {\n\treturn Visit(c.Model.Node, func(node Visitable, next Next) error {\n\t\tvar value *Value\n\t\tswitch node := node.(type) {\n\t\tcase *Flag:\n\t\t\tvalue = node.Value\n\t\tcase *Node:\n\t\t\tvalue = node.Argument\n\t\tcase *Value:\n\t\t\tvalue = node\n\t\tdefault:\n\t\t}\n\t\tif value != nil {\n\t\t\tif err := value.ApplyDefault(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn next(nil)\n\t})\n}\n\n// Apply traced context to the target grammar.\nfunc (c *Context) Apply() (string, error) {\n\tpath := []string{}\n\n\tfor _, trace := range c.Path {\n\t\tvar value *Value\n\t\tswitch {\n\t\tcase trace.App != nil:\n\t\tcase trace.Argument != nil:\n\t\t\tpath = append(path, \"<\"+trace.Argument.Name+\">\")\n\t\t\tvalue = trace.Argument.Argument\n\t\tcase trace.Command != nil:\n\t\t\tpath = append(path, trace.Command.Name)\n\t\tcase trace.Flag != nil:\n\t\t\tvalue = trace.Flag.Value\n\t\tcase trace.Positional != nil:\n\t\t\tpath = append(path, \"<\"+trace.Positional.Name+\">\")\n\t\t\tvalue = trace.Positional\n\t\tdefault:\n\t\t\tpanic(\"unsupported path ?!\")\n\t\t}\n\t\tif value != nil {\n\t\t\tvalue.Apply(c.getValue(value))\n\t\t}\n\t}\n\n\treturn strings.Join(path, \" \"), nil\n}\n\nfunc flipBoolValue(value reflect.Value) error {\n\tif value.Kind() == reflect.Bool {\n\t\tvalue.SetBool(!value.Bool())\n\t\treturn nil\n\t}\n\n\tif value.Kind() == reflect.Ptr {\n\t\tif !value.IsNil() {\n\t\t\treturn flipBoolValue(value.Elem())\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"cannot negate a value of %s\", value.Type().String())\n}\n\nfunc (c *Context) parseFlag(flags []*Flag, match string) (err error) {\n\tcandidates := []string{}\n\n\tfor _, flag := range flags {\n\t\tlong := \"--\" + flag.Name\n\t\tmatched := long == match\n\t\tcandidates = append(candidates, long)\n\t\tif flag.Short != 0 {\n\t\t\tshort := \"-\" + string(flag.Short)\n\t\t\tmatched = matched || (short == match)\n\t\t\tcandidates = append(candidates, short)\n\t\t}\n\t\tfor _, alias := range flag.Aliases {\n\t\t\talias = \"--\" + alias\n\t\t\tmatched = matched || (alias == match)\n\t\t\tcandidates = append(candidates, alias)\n\t\t}\n\n\t\tneg := negatableFlagName(flag.Name, flag.Tag.Negatable)\n\t\tif !matched && match != neg {\n\t\t\tcontinue\n\t\t}\n\t\t// Found a matching flag.\n\t\tc.scan.Pop()\n\t\tif match == neg && flag.Tag.Negatable != \"\" {\n\t\t\tflag.Negated = true\n\t\t}\n\t\terr := flag.Parse(c.scan, c.getValue(flag.Value))\n\t\tif err != nil {\n\t\t\tvar expected *expectedError\n\t\t\tif errors.As(err, &expected) && expected.token.InferredType().IsAny(FlagToken, ShortFlagToken) {\n\t\t\t\treturn fmt.Errorf(\"%s; perhaps try %s=%q?\", err.Error(), flag.ShortSummary(), expected.token)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif flag.Negated {\n\t\t\tvalue := c.getValue(flag.Value)\n\t\t\terr := flipBoolValue(value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tflag.Value.Apply(value)\n\t\t}\n\t\tc.Path = append(c.Path, &Path{Flag: flag})\n\t\treturn nil\n\t}\n\treturn &unknownFlagError{Cause: findPotentialCandidates(match, candidates, \"unknown flag %s\", match)}\n}\n\nfunc isUnknownFlagError(err error) bool {\n\tvar unknown *unknownFlagError\n\treturn errors.As(err, &unknown)\n}\n\ntype unknownFlagError struct{ Cause error }\n\nfunc (e *unknownFlagError) Unwrap() error { return e.Cause }\nfunc (e *unknownFlagError) Error() string { return e.Cause.Error() }\n\n// Call an arbitrary function filling arguments with bound values.\nfunc (c *Context) Call(fn any, binds ...any) (out []any, err error) {\n\tfv := reflect.ValueOf(fn)\n\tbindings := c.Kong.bindings.clone().add(binds...).add(c).merge(c.bindings)\n\treturn callAnyFunction(fv, bindings)\n}\n\n// RunNode calls the Run() method on an arbitrary node.\n//\n// This is useful in conjunction with Visit(), for dynamically running commands.\n//\n// Any passed values will be bindable to arguments of the target Run() method. Additionally,\n// all parent nodes in the command structure will be bound.\nfunc (c *Context) RunNode(node *Node, binds ...any) (err error) {\n\ttype targetMethod struct {\n\t\tnode   *Node\n\t\tmethod reflect.Value\n\t\tbinds  bindings\n\t}\n\tmethodBinds := c.Kong.bindings.clone().add(binds...).add(c).merge(c.bindings)\n\tmethods := []targetMethod{}\n\tfor i := 0; node != nil; i, node = i+1, node.Parent {\n\t\tmethod := getMethod(node.Target, \"Run\")\n\t\tmethodBinds = methodBinds.clone()\n\t\tfor p := node; p != nil; p = p.Parent {\n\t\t\tmethodBinds = methodBinds.add(p.Target.Addr().Interface())\n\t\t\t// Try value and pointer to value.\n\t\t\tfor _, p := range []reflect.Value{p.Target, p.Target.Addr()} {\n\t\t\t\tt := p.Type()\n\t\t\t\tfor i := 0; i < p.NumMethod(); i++ {\n\t\t\t\t\tmethodt := t.Method(i)\n\t\t\t\t\tif strings.HasPrefix(methodt.Name, \"Provide\") {\n\t\t\t\t\t\tmethod := p.Method(i)\n\t\t\t\t\t\tif err := methodBinds.addProvider(method.Interface()); err != nil {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"%s.%s: %w\", t.Name(), methodt.Name, err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif method.IsValid() {\n\t\t\tmethods = append(methods, targetMethod{node, method, methodBinds})\n\t\t}\n\t}\n\tif len(methods) == 0 {\n\t\treturn fmt.Errorf(\"no Run() method found in hierarchy of %s\", c.Selected().Summary())\n\t}\n\tfor _, method := range methods {\n\t\tif err = callFunction(method.method, method.binds); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Run executes the Run() method on the selected command, which must exist.\n//\n// Any passed values will be bindable to arguments of the target Run() method. Additionally,\n// all parent nodes in the command structure will be bound.\nfunc (c *Context) Run(binds ...any) (err error) {\n\tnode := c.Selected()\n\tif node == nil {\n\t\tif len(c.Path) == 0 {\n\t\t\treturn fmt.Errorf(\"no command selected\")\n\t\t}\n\t\tselected := c.Path[0].Node()\n\t\tif selected.Type == ApplicationNode {\n\t\t\tmethod := getMethod(selected.Target, \"Run\")\n\t\t\tif method.IsValid() {\n\t\t\t\tnode = selected\n\t\t\t}\n\t\t}\n\n\t\tif node == nil {\n\t\t\treturn fmt.Errorf(\"no command selected\")\n\t\t}\n\t}\n\trunErr := c.RunNode(node, binds...)\n\terr = c.Kong.applyHook(c, \"AfterRun\")\n\treturn errors.Join(runErr, err)\n}\n\n// PrintUsage to Kong's stdout.\n//\n// If summary is true, a summarised version of the help will be output.\nfunc (c *Context) PrintUsage(summary bool) error {\n\toptions := c.helpOptions\n\toptions.Summary = summary\n\treturn c.help(options, c)\n}\n\nfunc checkMissingFlags(flags []*Flag) error {\n\txorGroupSet := map[string]bool{}\n\txorGroup := map[string][]string{}\n\tandGroupSet := map[string]bool{}\n\tandGroup := map[string][]string{}\n\tmissing := []string{}\n\tandGroupRequired := getRequiredAndGroupMap(flags)\n\tfor _, flag := range flags {\n\t\tfor _, and := range flag.And {\n\t\t\tflag.Required = andGroupRequired[and]\n\t\t}\n\t\tif flag.Set {\n\t\t\tfor _, xor := range flag.Xor {\n\t\t\t\txorGroupSet[xor] = true\n\t\t\t}\n\t\t\tfor _, and := range flag.And {\n\t\t\t\tandGroupSet[and] = true\n\t\t\t}\n\t\t}\n\t\tif !flag.Required || flag.Set {\n\t\t\tcontinue\n\t\t}\n\t\tif len(flag.Xor) > 0 || len(flag.And) > 0 {\n\t\t\tfor _, xor := range flag.Xor {\n\t\t\t\tif xorGroupSet[xor] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\txorGroup[xor] = append(xorGroup[xor], flag.Summary())\n\t\t\t}\n\t\t\tfor _, and := range flag.And {\n\t\t\t\tandGroup[and] = append(andGroup[and], flag.Summary())\n\t\t\t}\n\t\t} else {\n\t\t\tmissing = append(missing, flag.Summary())\n\t\t}\n\t}\n\tfor xor, flags := range xorGroup {\n\t\tif !xorGroupSet[xor] && len(flags) > 1 {\n\t\t\tmissing = append(missing, strings.Join(flags, \" or \"))\n\t\t}\n\t}\n\tfor _, flags := range andGroup {\n\t\tif len(flags) > 1 {\n\t\t\tmissing = append(missing, strings.Join(flags, \" and \"))\n\t\t}\n\t}\n\n\tif len(missing) == 0 {\n\t\treturn nil\n\t}\n\n\tsort.Strings(missing)\n\n\treturn fmt.Errorf(\"missing flags: %s\", strings.Join(missing, \", \"))\n}\n\nfunc getRequiredAndGroupMap(flags []*Flag) map[string]bool {\n\tandGroupRequired := map[string]bool{}\n\tfor _, flag := range flags {\n\t\tfor _, and := range flag.And {\n\t\t\tif flag.Required {\n\t\t\t\tandGroupRequired[and] = true\n\t\t\t}\n\t\t}\n\t}\n\treturn andGroupRequired\n}\n\nfunc checkMissingChildren(node *Node) error {\n\tmissing := []string{}\n\n\tmissingArgs := []string{}\n\tfor _, arg := range node.Positional {\n\t\tif arg.Required && !arg.Set {\n\t\t\tmissingArgs = append(missingArgs, arg.Summary())\n\t\t}\n\t}\n\tif len(missingArgs) > 0 {\n\t\tmissing = append(missing, strconv.Quote(strings.Join(missingArgs, \" \")))\n\t}\n\n\tfor _, child := range node.Children {\n\t\tif child.Hidden {\n\t\t\tcontinue\n\t\t}\n\t\tif child.Argument != nil {\n\t\t\tif !child.Argument.Required {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmissing = append(missing, strconv.Quote(child.Summary()))\n\t\t} else {\n\t\t\tmissing = append(missing, strconv.Quote(child.Name))\n\t\t}\n\t}\n\tif len(missing) == 0 {\n\t\treturn nil\n\t}\n\n\tif len(missing) > 5 {\n\t\tmissing = append(missing[:5], \"...\")\n\t}\n\tif len(missing) == 1 {\n\t\treturn fmt.Errorf(\"expected %s\", missing[0])\n\t}\n\treturn fmt.Errorf(\"expected one of %s\", strings.Join(missing, \", \"))\n}\n\n// If we're missing any positionals and they're required, return an error.\nfunc checkMissingPositionals(positional int, values []*Value) error {\n\t// All the positionals are in.\n\tif positional >= len(values) {\n\t\treturn nil\n\t}\n\n\t// We're low on supplied positionals, but the missing one is optional.\n\tif !values[positional].Required {\n\t\treturn nil\n\t}\n\n\tmissing := []string{}\n\tfor ; positional < len(values); positional++ {\n\t\targ := values[positional]\n\t\t// TODO(aat): Fix hardcoding of these env checks all over the place :\\\n\t\tif len(arg.Tag.Envs) != 0 {\n\t\t\tif atLeastOneEnvSet(arg.Tag.Envs) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tmissing = append(missing, \"<\"+arg.Name+\">\")\n\t}\n\tif len(missing) == 0 {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"missing positional arguments %s\", strings.Join(missing, \" \"))\n}\n\nfunc checkEnum(value *Value, target reflect.Value) error {\n\tswitch target.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\tfor i := 0; i < target.Len(); i++ {\n\t\t\tif err := checkEnum(value, target.Index(i)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\n\tcase reflect.Map, reflect.Struct:\n\t\treturn errors.New(\"enum can only be applied to a slice or value\")\n\n\tcase reflect.Ptr:\n\t\tif target.IsNil() {\n\t\t\treturn nil\n\t\t}\n\t\treturn checkEnum(value, target.Elem())\n\tdefault:\n\t\tenumSlice := value.EnumSlice()\n\t\tv := fmt.Sprintf(\"%v\", target)\n\t\tenums := []string{}\n\t\tfor _, enum := range enumSlice {\n\t\t\tif enum == v {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tenums = append(enums, fmt.Sprintf(\"%q\", enum))\n\t\t}\n\t\treturn fmt.Errorf(\"%s must be one of %s but got %q\", value.ShortSummary(), strings.Join(enums, \",\"), fmt.Sprintf(\"%v\", target.Interface()))\n\t}\n}\n\nfunc checkPassthroughArg(target reflect.Value) bool {\n\ttyp := target.Type()\n\tswitch typ.Kind() {\n\tcase reflect.Slice:\n\t\treturn typ.Elem().Kind() == reflect.String\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc checkXorDuplicatedAndAndMissing(paths []*Path) error {\n\terrs := []string{}\n\tif err := checkXorDuplicates(paths); err != nil {\n\t\terrs = append(errs, err.Error())\n\t}\n\tif err := checkAndMissing(paths); err != nil {\n\t\terrs = append(errs, err.Error())\n\t}\n\tif len(errs) > 0 {\n\t\treturn errors.New(strings.Join(errs, \", \"))\n\t}\n\treturn nil\n}\n\nfunc checkXorDuplicates(paths []*Path) error {\n\tfor _, path := range paths {\n\t\tseen := map[string]*Flag{}\n\t\tfor _, flag := range path.Flags {\n\t\t\tif !flag.Set {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, xor := range flag.Xor {\n\t\t\t\tif seen[xor] != nil {\n\t\t\t\t\treturn fmt.Errorf(\"--%s and --%s can't be used together\", seen[xor].Name, flag.Name)\n\t\t\t\t}\n\t\t\t\tseen[xor] = flag\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc checkAndMissing(paths []*Path) error {\n\tfor _, path := range paths {\n\t\tmissingMsgs := []string{}\n\t\tandGroups := map[string][]*Flag{}\n\t\tfor _, flag := range path.Flags {\n\t\t\tfor _, and := range flag.And {\n\t\t\t\tandGroups[and] = append(andGroups[and], flag)\n\t\t\t}\n\t\t}\n\t\tfor _, flags := range andGroups {\n\t\t\toneSet := false\n\t\t\tnotSet := []*Flag{}\n\t\t\tflagNames := []string{}\n\t\t\tfor _, flag := range flags {\n\t\t\t\tflagNames = append(flagNames, flag.Name)\n\t\t\t\tif flag.Set {\n\t\t\t\t\toneSet = true\n\t\t\t\t} else {\n\t\t\t\t\tnotSet = append(notSet, flag)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(notSet) > 0 && oneSet {\n\t\t\t\tmissingMsgs = append(missingMsgs, fmt.Sprintf(\"--%s must be used together\", strings.Join(flagNames, \" and --\")))\n\t\t\t}\n\t\t}\n\t\tif len(missingMsgs) > 0 {\n\t\t\treturn fmt.Errorf(\"%s\", strings.Join(missingMsgs, \", \"))\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc findPotentialCandidates(needle string, haystack []string, format string, args ...any) error {\n\tif len(haystack) == 0 {\n\t\treturn fmt.Errorf(format, args...)\n\t}\n\tclosestCandidates := []string{}\n\tfor _, candidate := range haystack {\n\t\tif strings.HasPrefix(candidate, needle) || levenshtein(candidate, needle) <= 2 {\n\t\t\tclosestCandidates = append(closestCandidates, fmt.Sprintf(\"%q\", candidate))\n\t\t}\n\t}\n\tprefix := fmt.Sprintf(format, args...)\n\tif len(closestCandidates) == 1 {\n\t\treturn fmt.Errorf(\"%s, did you mean %s?\", prefix, closestCandidates[0])\n\t} else if len(closestCandidates) > 1 {\n\t\treturn fmt.Errorf(\"%s, did you mean one of %s?\", prefix, strings.Join(closestCandidates, \", \"))\n\t}\n\treturn fmt.Errorf(\"%s\", prefix)\n}\n\ntype validatable interface{ Validate() error }\ntype extendedValidatable interface {\n\tValidate(kctx *Context) error\n}\n\n// Proxy a validatable function to the extendedValidatable interface\ntype validatableFunc func() error\n\nfunc (f validatableFunc) Validate(kctx *Context) error { return f() }\n\nfunc isValidatable(v reflect.Value) extendedValidatable {\n\tif !v.IsValid() || (v.Kind() == reflect.Ptr || v.Kind() == reflect.Slice || v.Kind() == reflect.Map) && v.IsNil() {\n\t\treturn nil\n\t}\n\tif validate, ok := v.Interface().(validatable); ok {\n\t\treturn validatableFunc(validate.Validate)\n\t}\n\tif validate, ok := v.Interface().(extendedValidatable); ok {\n\t\treturn validate\n\t}\n\tif v.CanAddr() {\n\t\treturn isValidatable(v.Addr())\n\t}\n\treturn nil\n}\n\nfunc atLeastOneEnvSet(envs []string) bool {\n\tfor _, env := range envs {\n\t\tif _, ok := os.LookupEnv(env); ok {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "defaults.go",
          "type": "blob",
          "size": 0.3798828125,
          "content": "package kong\n\n// ApplyDefaults if they are not already set.\nfunc ApplyDefaults(target any, options ...Option) error {\n\tapp, err := New(target, options...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx, err := Trace(app, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = ctx.Resolve()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = ctx.ApplyDefaults(); err != nil {\n\t\treturn err\n\t}\n\treturn ctx.Validate()\n}\n"
        },
        {
          "name": "defaults_test.go",
          "type": "blob",
          "size": 0.693359375,
          "content": "package kong\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc TestApplyDefaults(t *testing.T) {\n\ttype CLI struct {\n\t\tStr      string        `default:\"str\"`\n\t\tDuration time.Duration `default:\"30s\"`\n\t}\n\ttests := []struct {\n\t\tname     string\n\t\ttarget   CLI\n\t\texpected CLI\n\t}{\n\t\t{name: \"DefaultsWhenNotSet\",\n\t\t\texpected: CLI{Str: \"str\", Duration: time.Second * 30}},\n\t\t{name: \"PartiallySetDefaults\",\n\t\t\ttarget:   CLI{Duration: time.Second},\n\t\t\texpected: CLI{Str: \"str\", Duration: time.Second}},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := ApplyDefaults(&tt.target)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tt.expected, tt.target)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.8310546875,
          "content": "// Package kong aims to support arbitrarily complex command-line structures with as little developer effort as possible.\n//\n// Here's an example:\n//\n//\tshell rm [-f] [-r] <paths> ...\n//\tshell ls [<paths> ...]\n//\n// This can be represented by the following command-line structure:\n//\n//\tpackage main\n//\n//\timport \"github.com/alecthomas/kong\"\n//\n//\tvar CLI struct {\n//\t  Rm struct {\n//\t    Force     bool `short:\"f\" help:\"Force removal.\"`\n//\t    Recursive bool `short:\"r\" help:\"Recursively remove files.\"`\n//\n//\t    Paths []string `arg help:\"Paths to remove.\" type:\"path\"`\n//\t  } `cmd help:\"Remove files.\"`\n//\n//\t  Ls struct {\n//\t    Paths []string `arg optional help:\"Paths to list.\" type:\"path\"`\n//\t  } `cmd help:\"List paths.\"`\n//\t}\n//\n//\tfunc main() {\n//\t  kong.Parse(&CLI)\n//\t}\n//\n// See https://github.com/alecthomas/kong for details.\npackage kong\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 0.2861328125,
          "content": "package kong\n\n// ParseError is the error type returned by Kong.Parse().\n//\n// It contains the parse Context that triggered the error.\ntype ParseError struct {\n\terror\n\tContext *Context\n}\n\n// Unwrap returns the original cause of the error.\nfunc (p *ParseError) Unwrap() error { return p.error }\n"
        },
        {
          "name": "global.go",
          "type": "blob",
          "size": 0.294921875,
          "content": "package kong\n\nimport (\n\t\"os\"\n)\n\n// Parse constructs a new parser and parses the default command-line.\nfunc Parse(cli any, options ...Option) *Context {\n\tparser, err := New(cli, options...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tctx, err := parser.Parse(os.Args[1:])\n\tparser.FatalIfErrorf(err)\n\treturn ctx\n}\n"
        },
        {
          "name": "global_test.go",
          "type": "blob",
          "size": 0.494140625,
          "content": "package kong\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc TestParseHandlingBadBuild(t *testing.T) {\n\tvar cli struct {\n\t\tEnabled bool `kong:\"fail='\"`\n\t}\n\n\targs := os.Args\n\tdefer func() {\n\t\tos.Args = args\n\t}()\n\n\tos.Args = []string{os.Args[0], \"hi\"}\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tassert.Equal(t, \"fail=' is not quoted properly\", r.(error).Error()) //nolint\n\t\t}\n\t}()\n\n\tParse(&cli, Exit(func(_ int) { panic(\"exiting\") }))\n\n\tt.Fatal(\"we were expecting a panic\")\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1845703125,
          "content": "module github.com/alecthomas/kong\n\nrequire (\n\tgithub.com/alecthomas/assert/v2 v2.11.0\n\tgithub.com/alecthomas/repr v0.4.0\n)\n\nrequire github.com/hexops/gotextdiff v1.0.3 // indirect\n\ngo 1.20\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.5166015625,
          "content": "github.com/alecthomas/assert/v2 v2.11.0 h1:2Q9r3ki8+JYXvGsDyBXwH3LcJ+WK5D0gc5E8vS6K3D0=\ngithub.com/alecthomas/assert/v2 v2.11.0/go.mod h1:Bze95FyfUr7x34QZrjL+XP+0qgp/zg8yS+TtBj1WA3k=\ngithub.com/alecthomas/repr v0.4.0 h1:GhI2A8MACjfegCPVq9f1FLvIBS+DrQ2KQBFZP1iFzXc=\ngithub.com/alecthomas/repr v0.4.0/go.mod h1:Fr0507jx4eOXV7AlPV6AVZLYrLIuIeSOWtW57eE/O/4=\ngithub.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUqJM=\ngithub.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=\n"
        },
        {
          "name": "guesswidth.go",
          "type": "blob",
          "size": 0.2353515625,
          "content": "//go:build appengine || (!linux && !freebsd && !darwin && !dragonfly && !netbsd && !openbsd)\n// +build appengine !linux,!freebsd,!darwin,!dragonfly,!netbsd,!openbsd\n\npackage kong\n\nimport \"io\"\n\nfunc guessWidth(w io.Writer) int {\n\treturn 80\n}\n"
        },
        {
          "name": "guesswidth_unix.go",
          "type": "blob",
          "size": 0.8720703125,
          "content": "//go:build (!appengine && linux) || freebsd || darwin || dragonfly || netbsd || openbsd\n// +build !appengine,linux freebsd darwin dragonfly netbsd openbsd\n\npackage kong\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nfunc guessWidth(w io.Writer) int {\n\t// check if COLUMNS env is set to comply with\n\t// http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap08.html\n\tcolsStr := os.Getenv(\"COLUMNS\")\n\tif colsStr != \"\" {\n\t\tif cols, err := strconv.Atoi(colsStr); err == nil {\n\t\t\treturn cols\n\t\t}\n\t}\n\n\tif t, ok := w.(*os.File); ok {\n\t\tfd := t.Fd()\n\t\tvar dimensions [4]uint16\n\n\t\tif _, _, err := syscall.Syscall6(\n\t\t\tsyscall.SYS_IOCTL,\n\t\t\tuintptr(fd), //nolint: unconvert\n\t\t\tuintptr(syscall.TIOCGWINSZ),\n\t\t\tuintptr(unsafe.Pointer(&dimensions)), //nolint: gas\n\t\t\t0, 0, 0,\n\t\t); err == 0 {\n\t\t\tif dimensions[1] == 0 {\n\t\t\t\treturn 80\n\t\t\t}\n\t\t\treturn int(dimensions[1])\n\t\t}\n\t}\n\treturn 80\n}\n"
        },
        {
          "name": "help.go",
          "type": "blob",
          "size": 13.8896484375,
          "content": "package kong\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"go/doc\"\n\t\"io\"\n\t\"strings\"\n)\n\nconst (\n\tdefaultIndent        = 2\n\tdefaultColumnPadding = 4\n)\n\n// Help flag.\ntype helpValue bool\n\nfunc (h helpValue) BeforeReset(ctx *Context) error {\n\toptions := ctx.Kong.helpOptions\n\toptions.Summary = false\n\terr := ctx.Kong.help(options, ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx.Kong.Exit(0)\n\treturn nil\n}\n\n// HelpOptions for HelpPrinters.\ntype HelpOptions struct {\n\t// Don't print top-level usage summary.\n\tNoAppSummary bool\n\n\t// Write a one-line summary of the context.\n\tSummary bool\n\n\t// Write help in a more compact, but still fully-specified, form.\n\tCompact bool\n\n\t// Tree writes command chains in a tree structure instead of listing them separately.\n\tTree bool\n\n\t// Place the flags after the commands listing.\n\tFlagsLast bool\n\n\t// Indenter modulates the given prefix for the next layer in the tree view.\n\t// The following exported templates can be used: kong.SpaceIndenter, kong.LineIndenter, kong.TreeIndenter\n\t// The kong.SpaceIndenter will be used by default.\n\tIndenter HelpIndenter\n\n\t// Don't show the help associated with subcommands\n\tNoExpandSubcommands bool\n\n\t// Clamp the help wrap width to a value smaller than the terminal width.\n\t// If this is set to a non-positive number, the terminal width is used; otherwise,\n\t// the min of this value or the terminal width is used.\n\tWrapUpperBound int\n}\n\n// Apply options to Kong as a configuration option.\nfunc (h HelpOptions) Apply(k *Kong) error {\n\tk.helpOptions = h\n\treturn nil\n}\n\n// HelpProvider can be implemented by commands/args to provide detailed help.\ntype HelpProvider interface {\n\t// This string is formatted by go/doc and thus has the same formatting rules.\n\tHelp() string\n}\n\n// PlaceHolderProvider can be implemented by mappers to provide custom placeholder text.\ntype PlaceHolderProvider interface {\n\tPlaceHolder(flag *Flag) string\n}\n\n// HelpIndenter is used to indent new layers in the help tree.\ntype HelpIndenter func(prefix string) string\n\n// HelpPrinter is used to print context-sensitive help.\ntype HelpPrinter func(options HelpOptions, ctx *Context) error\n\n// HelpValueFormatter is used to format the help text of flags and positional arguments.\ntype HelpValueFormatter func(value *Value) string\n\n// DefaultHelpValueFormatter is the default HelpValueFormatter.\nfunc DefaultHelpValueFormatter(value *Value) string {\n\tif len(value.Tag.Envs) == 0 || HasInterpolatedVar(value.OrigHelp, \"env\") {\n\t\treturn value.Help\n\t}\n\tsuffix := \"(\" + formatEnvs(value.Tag.Envs) + \")\"\n\tswitch {\n\tcase strings.HasSuffix(value.Help, \".\"):\n\t\treturn value.Help[:len(value.Help)-1] + \" \" + suffix + \".\"\n\tcase value.Help == \"\":\n\t\treturn suffix\n\tdefault:\n\t\treturn value.Help + \" \" + suffix\n\t}\n}\n\n// DefaultShortHelpPrinter is the default HelpPrinter for short help on error.\nfunc DefaultShortHelpPrinter(options HelpOptions, ctx *Context) error {\n\tw := newHelpWriter(ctx, options)\n\tcmd := ctx.Selected()\n\tapp := ctx.Model\n\tif cmd == nil {\n\t\tw.Printf(\"Usage: %s%s\", app.Name, app.Summary())\n\t\tw.Printf(`Run \"%s --help\" for more information.`, app.Name)\n\t} else {\n\t\tw.Printf(\"Usage: %s %s\", app.Name, cmd.Summary())\n\t\tw.Printf(`Run \"%s --help\" for more information.`, cmd.FullPath())\n\t}\n\treturn w.Write(ctx.Stdout)\n}\n\n// DefaultHelpPrinter is the default HelpPrinter.\nfunc DefaultHelpPrinter(options HelpOptions, ctx *Context) error {\n\tif ctx.Empty() {\n\t\toptions.Summary = false\n\t}\n\tw := newHelpWriter(ctx, options)\n\tselected := ctx.Selected()\n\tif selected == nil {\n\t\tprintApp(w, ctx.Model)\n\t} else {\n\t\tprintCommand(w, ctx.Model, selected)\n\t}\n\treturn w.Write(ctx.Stdout)\n}\n\nfunc printApp(w *helpWriter, app *Application) {\n\tif !w.NoAppSummary {\n\t\tw.Printf(\"Usage: %s%s\", app.Name, app.Summary())\n\t}\n\tprintNodeDetail(w, app.Node, true)\n\tcmds := app.Leaves(true)\n\tif len(cmds) > 0 && app.HelpFlag != nil {\n\t\tw.Print(\"\")\n\t\tif w.Summary {\n\t\t\tw.Printf(`Run \"%s --help\" for more information.`, app.Name)\n\t\t} else {\n\t\t\tw.Printf(`Run \"%s <command> --help\" for more information on a command.`, app.Name)\n\t\t}\n\t}\n}\n\nfunc printCommand(w *helpWriter, app *Application, cmd *Command) {\n\tif !w.NoAppSummary {\n\t\tw.Printf(\"Usage: %s %s\", app.Name, cmd.Summary())\n\t}\n\tprintNodeDetail(w, cmd, true)\n\tif w.Summary && app.HelpFlag != nil {\n\t\tw.Print(\"\")\n\t\tw.Printf(`Run \"%s --help\" for more information.`, cmd.FullPath())\n\t}\n}\n\nfunc printNodeDetail(w *helpWriter, node *Node, hide bool) {\n\tif node.Help != \"\" {\n\t\tw.Print(\"\")\n\t\tw.Wrap(node.Help)\n\t}\n\tif w.Summary {\n\t\treturn\n\t}\n\tif node.Detail != \"\" {\n\t\tw.Print(\"\")\n\t\tw.Wrap(node.Detail)\n\t}\n\tif len(node.Positional) > 0 {\n\t\tw.Print(\"\")\n\t\tw.Print(\"Arguments:\")\n\t\twritePositionals(w.Indent(), node.Positional)\n\t}\n\tprintFlags := func() {\n\t\tif flags := node.AllFlags(true); len(flags) > 0 {\n\t\t\tgroupedFlags := collectFlagGroups(flags)\n\t\t\tfor _, group := range groupedFlags {\n\t\t\t\tw.Print(\"\")\n\t\t\t\tif group.Metadata.Title != \"\" {\n\t\t\t\t\tw.Wrap(group.Metadata.Title)\n\t\t\t\t}\n\t\t\t\tif group.Metadata.Description != \"\" {\n\t\t\t\t\tw.Indent().Wrap(group.Metadata.Description)\n\t\t\t\t\tw.Print(\"\")\n\t\t\t\t}\n\t\t\t\twriteFlags(w.Indent(), group.Flags)\n\t\t\t}\n\t\t}\n\t}\n\tif !w.FlagsLast {\n\t\tprintFlags()\n\t}\n\tvar cmds []*Node\n\tif w.NoExpandSubcommands {\n\t\tcmds = node.Children\n\t} else {\n\t\tcmds = node.Leaves(hide)\n\t}\n\tif len(cmds) > 0 {\n\t\tiw := w.Indent()\n\t\tif w.Tree {\n\t\t\tw.Print(\"\")\n\t\t\tw.Print(\"Commands:\")\n\t\t\twriteCommandTree(iw, node)\n\t\t} else {\n\t\t\tgroupedCmds := collectCommandGroups(cmds)\n\t\t\tfor _, group := range groupedCmds {\n\t\t\t\tw.Print(\"\")\n\t\t\t\tif group.Metadata.Title != \"\" {\n\t\t\t\t\tw.Wrap(group.Metadata.Title)\n\t\t\t\t}\n\t\t\t\tif group.Metadata.Description != \"\" {\n\t\t\t\t\tw.Indent().Wrap(group.Metadata.Description)\n\t\t\t\t\tw.Print(\"\")\n\t\t\t\t}\n\n\t\t\t\tif w.Compact {\n\t\t\t\t\twriteCompactCommandList(group.Commands, iw)\n\t\t\t\t} else {\n\t\t\t\t\twriteCommandList(group.Commands, iw)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif w.FlagsLast {\n\t\tprintFlags()\n\t}\n}\n\nfunc writeCommandList(cmds []*Node, iw *helpWriter) {\n\tfor i, cmd := range cmds {\n\t\tif cmd.Hidden {\n\t\t\tcontinue\n\t\t}\n\t\tprintCommandSummary(iw, cmd)\n\t\tif i != len(cmds)-1 {\n\t\t\tiw.Print(\"\")\n\t\t}\n\t}\n}\n\nfunc writeCompactCommandList(cmds []*Node, iw *helpWriter) {\n\trows := [][2]string{}\n\tfor _, cmd := range cmds {\n\t\tif cmd.Hidden {\n\t\t\tcontinue\n\t\t}\n\t\trows = append(rows, [2]string{cmd.Path(), cmd.Help})\n\t}\n\twriteTwoColumns(iw, rows)\n}\n\nfunc writeCommandTree(w *helpWriter, node *Node) {\n\trows := make([][2]string, 0, len(node.Children)*2)\n\tfor i, cmd := range node.Children {\n\t\tif cmd.Hidden {\n\t\t\tcontinue\n\t\t}\n\t\trows = append(rows, w.CommandTree(cmd, \"\")...)\n\t\tif i != len(node.Children)-1 {\n\t\t\trows = append(rows, [2]string{\"\", \"\"})\n\t\t}\n\t}\n\twriteTwoColumns(w, rows)\n}\n\ntype helpFlagGroup struct {\n\tMetadata *Group\n\tFlags    [][]*Flag\n}\n\nfunc collectFlagGroups(flags [][]*Flag) []helpFlagGroup {\n\t// Group keys in order of appearance.\n\tgroups := []*Group{}\n\t// Flags grouped by their group key.\n\tflagsByGroup := map[string][][]*Flag{}\n\n\tfor _, levelFlags := range flags {\n\t\tlevelFlagsByGroup := map[string][]*Flag{}\n\n\t\tfor _, flag := range levelFlags {\n\t\t\tkey := \"\"\n\t\t\tif flag.Group != nil {\n\t\t\t\tkey = flag.Group.Key\n\t\t\t\tgroupAlreadySeen := false\n\t\t\t\tfor _, group := range groups {\n\t\t\t\t\tif key == group.Key {\n\t\t\t\t\t\tgroupAlreadySeen = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !groupAlreadySeen {\n\t\t\t\t\tgroups = append(groups, flag.Group)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlevelFlagsByGroup[key] = append(levelFlagsByGroup[key], flag)\n\t\t}\n\n\t\tfor key, flags := range levelFlagsByGroup {\n\t\t\tflagsByGroup[key] = append(flagsByGroup[key], flags)\n\t\t}\n\t}\n\n\tout := []helpFlagGroup{}\n\t// Ungrouped flags are always displayed first.\n\tif ungroupedFlags, ok := flagsByGroup[\"\"]; ok {\n\t\tout = append(out, helpFlagGroup{\n\t\t\tMetadata: &Group{Title: \"Flags:\"},\n\t\t\tFlags:    ungroupedFlags,\n\t\t})\n\t}\n\tfor _, group := range groups {\n\t\tout = append(out, helpFlagGroup{Metadata: group, Flags: flagsByGroup[group.Key]})\n\t}\n\treturn out\n}\n\ntype helpCommandGroup struct {\n\tMetadata *Group\n\tCommands []*Node\n}\n\nfunc collectCommandGroups(nodes []*Node) []helpCommandGroup {\n\t// Groups in order of appearance.\n\tgroups := []*Group{}\n\t// Nodes grouped by their group key.\n\tnodesByGroup := map[string][]*Node{}\n\n\tfor _, node := range nodes {\n\t\tkey := \"\"\n\t\tif group := node.ClosestGroup(); group != nil {\n\t\t\tkey = group.Key\n\t\t\tif _, ok := nodesByGroup[key]; !ok {\n\t\t\t\tgroups = append(groups, group)\n\t\t\t}\n\t\t}\n\t\tnodesByGroup[key] = append(nodesByGroup[key], node)\n\t}\n\n\tout := []helpCommandGroup{}\n\t// Ungrouped nodes are always displayed first.\n\tif ungroupedNodes, ok := nodesByGroup[\"\"]; ok {\n\t\tout = append(out, helpCommandGroup{\n\t\t\tMetadata: &Group{Title: \"Commands:\"},\n\t\t\tCommands: ungroupedNodes,\n\t\t})\n\t}\n\tfor _, group := range groups {\n\t\tout = append(out, helpCommandGroup{Metadata: group, Commands: nodesByGroup[group.Key]})\n\t}\n\treturn out\n}\n\nfunc printCommandSummary(w *helpWriter, cmd *Command) {\n\tw.Print(cmd.Summary())\n\tif cmd.Help != \"\" {\n\t\tw.Indent().Wrap(cmd.Help)\n\t}\n}\n\ntype helpWriter struct {\n\tindent        string\n\twidth         int\n\tlines         *[]string\n\thelpFormatter HelpValueFormatter\n\tHelpOptions\n}\n\nfunc newHelpWriter(ctx *Context, options HelpOptions) *helpWriter {\n\tlines := []string{}\n\twrapWidth := guessWidth(ctx.Stdout)\n\tif options.WrapUpperBound > 0 && wrapWidth > options.WrapUpperBound {\n\t\twrapWidth = options.WrapUpperBound\n\t}\n\tw := &helpWriter{\n\t\tindent:        \"\",\n\t\twidth:         wrapWidth,\n\t\tlines:         &lines,\n\t\thelpFormatter: ctx.Kong.helpFormatter,\n\t\tHelpOptions:   options,\n\t}\n\treturn w\n}\n\nfunc (h *helpWriter) Printf(format string, args ...any) {\n\th.Print(fmt.Sprintf(format, args...))\n}\n\nfunc (h *helpWriter) Print(text string) {\n\t*h.lines = append(*h.lines, strings.TrimRight(h.indent+text, \" \"))\n}\n\n// Indent returns a new helpWriter indented by two characters.\nfunc (h *helpWriter) Indent() *helpWriter {\n\treturn &helpWriter{indent: h.indent + \"  \", lines: h.lines, width: h.width - 2, HelpOptions: h.HelpOptions, helpFormatter: h.helpFormatter}\n}\n\nfunc (h *helpWriter) String() string {\n\treturn strings.Join(*h.lines, \"\\n\")\n}\n\nfunc (h *helpWriter) Write(w io.Writer) error {\n\tfor _, line := range *h.lines {\n\t\t_, err := io.WriteString(w, line+\"\\n\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (h *helpWriter) Wrap(text string) {\n\tw := bytes.NewBuffer(nil)\n\tdoc.ToText(w, strings.TrimSpace(text), \"\", \"    \", h.width)\n\tfor _, line := range strings.Split(strings.TrimSpace(w.String()), \"\\n\") {\n\t\th.Print(line)\n\t}\n}\n\nfunc writePositionals(w *helpWriter, args []*Positional) {\n\trows := [][2]string{}\n\tfor _, arg := range args {\n\t\trows = append(rows, [2]string{arg.Summary(), w.helpFormatter(arg)})\n\t}\n\twriteTwoColumns(w, rows)\n}\n\nfunc writeFlags(w *helpWriter, groups [][]*Flag) {\n\trows := [][2]string{}\n\thaveShort := false\n\tfor _, group := range groups {\n\t\tfor _, flag := range group {\n\t\t\tif flag.Short != 0 {\n\t\t\t\thaveShort = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tfor i, group := range groups {\n\t\tif i > 0 {\n\t\t\trows = append(rows, [2]string{\"\", \"\"})\n\t\t}\n\t\tfor _, flag := range group {\n\t\t\tif !flag.Hidden {\n\t\t\t\trows = append(rows, [2]string{formatFlag(haveShort, flag), w.helpFormatter(flag.Value)})\n\t\t\t}\n\t\t}\n\t}\n\twriteTwoColumns(w, rows)\n}\n\nfunc writeTwoColumns(w *helpWriter, rows [][2]string) {\n\tmaxLeft := 375 * w.width / 1000\n\tif maxLeft < 30 {\n\t\tmaxLeft = 30\n\t}\n\t// Find size of first column.\n\tleftSize := 0\n\tfor _, row := range rows {\n\t\tif c := len(row[0]); c > leftSize && c < maxLeft {\n\t\t\tleftSize = c\n\t\t}\n\t}\n\n\toffsetStr := strings.Repeat(\" \", leftSize+defaultColumnPadding)\n\n\tfor _, row := range rows {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tdoc.ToText(buf, row[1], \"\", strings.Repeat(\" \", defaultIndent), w.width-leftSize-defaultColumnPadding)\n\t\tlines := strings.Split(strings.TrimRight(buf.String(), \"\\n\"), \"\\n\")\n\n\t\tline := fmt.Sprintf(\"%-*s\", leftSize, row[0])\n\t\tif len(row[0]) < maxLeft {\n\t\t\tline += fmt.Sprintf(\"%*s%s\", defaultColumnPadding, \"\", lines[0])\n\t\t\tlines = lines[1:]\n\t\t}\n\t\tw.Print(line)\n\t\tfor _, line := range lines {\n\t\t\tw.Printf(\"%s%s\", offsetStr, line)\n\t\t}\n\t}\n}\n\n// haveShort will be true if there are short flags present at all in the help. Useful for column alignment.\nfunc formatFlag(haveShort bool, flag *Flag) string {\n\tflagString := \"\"\n\tname := flag.Name\n\tisBool := flag.IsBool()\n\tisCounter := flag.IsCounter()\n\n\tshort := \"\"\n\tif flag.Short != 0 {\n\t\tshort = \"-\" + string(flag.Short) + \", \"\n\t} else if haveShort {\n\t\tshort = \"    \"\n\t}\n\n\tif isBool && flag.Tag.Negatable == negatableDefault {\n\t\tname = \"[no-]\" + name\n\t} else if isBool && flag.Tag.Negatable != \"\" {\n\t\tname += \"/\" + flag.Tag.Negatable\n\t}\n\n\tflagString += fmt.Sprintf(\"%s--%s\", short, name)\n\n\tif !isBool && !isCounter {\n\t\tflagString += fmt.Sprintf(\"=%s\", flag.FormatPlaceHolder())\n\t}\n\treturn flagString\n}\n\n// CommandTree creates a tree with the given node name as root and its children's arguments and sub commands as leaves.\nfunc (h *HelpOptions) CommandTree(node *Node, prefix string) (rows [][2]string) {\n\tvar nodeName string\n\tswitch node.Type {\n\tdefault:\n\t\tnodeName += prefix + node.Name\n\t\tif len(node.Aliases) != 0 {\n\t\t\tnodeName += fmt.Sprintf(\" (%s)\", strings.Join(node.Aliases, \",\"))\n\t\t}\n\tcase ArgumentNode:\n\t\tnodeName += prefix + \"<\" + node.Name + \">\"\n\t}\n\trows = append(rows, [2]string{nodeName, node.Help})\n\tif h.Indenter == nil {\n\t\tprefix = SpaceIndenter(prefix)\n\t} else {\n\t\tprefix = h.Indenter(prefix)\n\t}\n\tfor _, arg := range node.Positional {\n\t\trows = append(rows, [2]string{prefix + arg.Summary(), arg.Help})\n\t}\n\tfor _, subCmd := range node.Children {\n\t\tif subCmd.Hidden {\n\t\t\tcontinue\n\t\t}\n\t\trows = append(rows, h.CommandTree(subCmd, prefix)...)\n\t}\n\treturn\n}\n\n// SpaceIndenter adds a space indent to the given prefix.\nfunc SpaceIndenter(prefix string) string {\n\treturn prefix + strings.Repeat(\" \", defaultIndent)\n}\n\n// LineIndenter adds line points to every new indent.\nfunc LineIndenter(prefix string) string {\n\tif prefix == \"\" {\n\t\treturn \"- \"\n\t}\n\treturn strings.Repeat(\" \", defaultIndent) + prefix\n}\n\n// TreeIndenter adds line points to every new indent and vertical lines to every layer.\nfunc TreeIndenter(prefix string) string {\n\tif prefix == \"\" {\n\t\treturn \"|- \"\n\t}\n\treturn \"|\" + strings.Repeat(\" \", defaultIndent) + prefix\n}\n\nfunc formatEnvs(envs []string) string {\n\tformatted := make([]string, len(envs))\n\tfor i := range envs {\n\t\tformatted[i] = \"$\" + envs[i]\n\t}\n\n\treturn strings.Join(formatted, \", \")\n}\n"
        },
        {
          "name": "help_test.go",
          "type": "blob",
          "size": 22.66015625,
          "content": "package kong_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n\t\"github.com/alecthomas/kong\"\n)\n\nfunc panicsTrue(t *testing.T, f func()) {\n\tdefer func() {\n\t\tif value := recover(); value != nil {\n\t\t\tif boolval, ok := value.(bool); !ok || !boolval {\n\t\t\t\tt.Fatalf(\"expected panic with true but got %v\", value)\n\t\t\t}\n\t\t}\n\t}()\n\tf()\n\tt.Fatal(\"expected panic did not occur\")\n}\n\ntype threeArg struct {\n\tRequiredThree bool   `required`\n\tThree         string `arg`\n}\n\nfunc (threeArg) Help() string {\n\treturn `Detailed help provided through the HelpProvider interface.`\n}\n\nfunc TestHelpOptionalArgs(t *testing.T) {\n\tvar cli struct {\n\t\tOne string `arg:\"\" optional:\"\" help:\"One optional arg.\"`\n\t\tTwo string `arg:\"\" optional:\"\" help:\"Two optional arg.\"`\n\t}\n\tw := bytes.NewBuffer(nil)\n\texited := false\n\tapp := mustNew(t, &cli,\n\t\tkong.Name(\"test-app\"),\n\t\tkong.Writers(w, w),\n\t\tkong.Exit(func(int) {\n\t\t\texited = true\n\t\t\tpanic(true) // Panic to fake \"exit\".\n\t\t}),\n\t)\n\tpanicsTrue(t, func() {\n\t\t_, err := app.Parse([]string{\"--help\"})\n\t\tassert.NoError(t, err)\n\t})\n\tassert.True(t, exited)\n\texpected := `Usage: test-app [<one> [<two>]] [flags]\n\nArguments:\n  [<one>]    One optional arg.\n  [<two>]    Two optional arg.\n\nFlags:\n  -h, --help    Show context-sensitive help.\n`\n\tassert.Equal(t, expected, w.String())\n}\n\nfunc TestHelp(t *testing.T) {\n\tvar cli struct {\n\t\tString   string         `help:\"A string flag.\"`\n\t\tBool     bool           `help:\"A bool flag with very long help that wraps a lot and is verbose and is really verbose.\"`\n\t\tSlice    []string       `help:\"A slice of strings.\" placeholder:\"STR\"`\n\t\tMap      map[string]int `help:\"A map of strings to ints.\"`\n\t\tRequired bool           `required help:\"A required flag.\"`\n\t\tSort     bool           `negatable short:\"s\" help:\"Is sortable or not.\"`\n\t\tApprove  bool           `negatable:\"deny\" help:\"Approve or deny message.\"`\n\n\t\tOne struct {\n\t\t\tFlag string `help:\"Nested flag.\"`\n\t\t} `cmd help:\"A subcommand.\"`\n\n\t\tTwo struct {\n\t\t\tFlag        string `help:\"Nested flag under two.\"`\n\t\t\tRequiredTwo bool   `required`\n\n\t\t\tThree threeArg `arg help:\"Sub-sub-arg.\"`\n\n\t\t\tFour struct {\n\t\t\t} `cmd help:\"Sub-sub-command.\"`\n\t\t} `cmd help:\"Another subcommand.\"`\n\t}\n\n\tw := bytes.NewBuffer(nil)\n\texited := false\n\tapp := mustNew(t, &cli,\n\t\tkong.Name(\"test-app\"),\n\t\tkong.Description(\"A test app.\"),\n\t\tkong.Writers(w, w),\n\t\tkong.Exit(func(int) {\n\t\t\texited = true\n\t\t\tpanic(true) // Panic to fake \"exit\".\n\t\t}),\n\t)\n\n\tt.Run(\"Full\", func(t *testing.T) {\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"--help\"})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tassert.True(t, exited)\n\t\texpected := `Usage: test-app --required <command> [flags]\n\nA test app.\n\nFlags:\n  -h, --help                 Show context-sensitive help.\n      --string=STRING        A string flag.\n      --bool                 A bool flag with very long help that wraps a lot\n                             and is verbose and is really verbose.\n      --slice=STR,...        A slice of strings.\n      --map=KEY=VALUE;...    A map of strings to ints.\n      --required             A required flag.\n  -s, --[no-]sort            Is sortable or not.\n      --approve/deny         Approve or deny message.\n\nCommands:\n  one --required [flags]\n    A subcommand.\n\n  two <three> --required --required-two --required-three [flags]\n    Sub-sub-arg.\n\n  two four --required --required-two [flags]\n    Sub-sub-command.\n\nRun \"test-app <command> --help\" for more information on a command.\n`\n\t\tt.Log(w.String())\n\t\tt.Log(expected)\n\t\tassert.Equal(t, expected, w.String())\n\t})\n\n\tt.Run(\"Selected\", func(t *testing.T) {\n\t\texited = false\n\t\tw.Truncate(0)\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"two\", \"hello\", \"--help\"})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tassert.True(t, exited)\n\t\texpected := `Usage: test-app two <three> --required --required-two --required-three [flags]\n\nSub-sub-arg.\n\nDetailed help provided through the HelpProvider interface.\n\nFlags:\n  -h, --help                 Show context-sensitive help.\n      --string=STRING        A string flag.\n      --bool                 A bool flag with very long help that wraps a lot\n                             and is verbose and is really verbose.\n      --slice=STR,...        A slice of strings.\n      --map=KEY=VALUE;...    A map of strings to ints.\n      --required             A required flag.\n  -s, --[no-]sort            Is sortable or not.\n      --approve/deny         Approve or deny message.\n\n      --flag=STRING          Nested flag under two.\n      --required-two\n\n      --required-three\n`\n\t\tt.Log(expected)\n\t\tt.Log(w.String())\n\t\tassert.Equal(t, expected, w.String())\n\t})\n}\n\nfunc TestFlagsLast(t *testing.T) {\n\tvar cli struct {\n\t\tString   string         `help:\"A string flag.\"`\n\t\tBool     bool           `help:\"A bool flag with very long help that wraps a lot and is verbose and is really verbose.\"`\n\t\tSlice    []string       `help:\"A slice of strings.\" placeholder:\"STR\"`\n\t\tMap      map[string]int `help:\"A map of strings to ints.\"`\n\t\tRequired bool           `required help:\"A required flag.\"`\n\n\t\tOne struct {\n\t\t\tFlag string `help:\"Nested flag.\"`\n\t\t} `cmd help:\"A subcommand.\"`\n\n\t\tTwo struct {\n\t\t\tFlag        string `help:\"Nested flag under two.\"`\n\t\t\tRequiredTwo bool   `required`\n\n\t\t\tThree threeArg `arg help:\"Sub-sub-arg.\"`\n\n\t\t\tFour struct {\n\t\t\t} `cmd help:\"Sub-sub-command.\"`\n\t\t} `cmd help:\"Another subcommand.\"`\n\t}\n\n\tw := bytes.NewBuffer(nil)\n\texited := false\n\tapp := mustNew(t, &cli,\n\t\tkong.Name(\"test-app\"),\n\t\tkong.Description(\"A test app.\"),\n\t\tkong.HelpOptions{\n\t\t\tFlagsLast: true,\n\t\t},\n\t\tkong.Writers(w, w),\n\t\tkong.Exit(func(int) {\n\t\t\texited = true\n\t\t\tpanic(true) // Panic to fake \"exit\".\n\t\t}),\n\t)\n\n\tt.Run(\"Full\", func(t *testing.T) {\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"--help\"})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tassert.True(t, exited)\n\t\texpected := `Usage: test-app --required <command> [flags]\n\nA test app.\n\nCommands:\n  one --required [flags]\n    A subcommand.\n\n  two <three> --required --required-two --required-three [flags]\n    Sub-sub-arg.\n\n  two four --required --required-two [flags]\n    Sub-sub-command.\n\nFlags:\n  -h, --help                 Show context-sensitive help.\n      --string=STRING        A string flag.\n      --bool                 A bool flag with very long help that wraps a lot\n                             and is verbose and is really verbose.\n      --slice=STR,...        A slice of strings.\n      --map=KEY=VALUE;...    A map of strings to ints.\n      --required             A required flag.\n\nRun \"test-app <command> --help\" for more information on a command.\n`\n\t\tt.Log(w.String())\n\t\tt.Log(expected)\n\t\tassert.Equal(t, expected, w.String())\n\t})\n\n\tt.Run(\"Selected\", func(t *testing.T) {\n\t\texited = false\n\t\tw.Truncate(0)\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"two\", \"hello\", \"--help\"})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tassert.True(t, exited)\n\t\texpected := `Usage: test-app two <three> --required --required-two --required-three [flags]\n\nSub-sub-arg.\n\nDetailed help provided through the HelpProvider interface.\n\nFlags:\n  -h, --help                 Show context-sensitive help.\n      --string=STRING        A string flag.\n      --bool                 A bool flag with very long help that wraps a lot\n                             and is verbose and is really verbose.\n      --slice=STR,...        A slice of strings.\n      --map=KEY=VALUE;...    A map of strings to ints.\n      --required             A required flag.\n\n      --flag=STRING          Nested flag under two.\n      --required-two\n\n      --required-three\n`\n\t\tt.Log(expected)\n\t\tt.Log(w.String())\n\t\tassert.Equal(t, expected, w.String())\n\t})\n}\n\nfunc TestHelpTree(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tThing struct {\n\t\t\t\tArg string `arg help:\"argument\"`\n\t\t\t} `cmd help:\"subcommand thing\"`\n\t\t\tOther struct {\n\t\t\t\tOther string `arg help:\"other arg\"`\n\t\t\t} `arg help:\"subcommand other\"`\n\t\t} `cmd help:\"subcommand one\" group:\"Group A\" aliases:\"un,uno\"` // Groups are ignored in trees\n\n\t\tTwo struct {\n\t\t\tThree threeArg `arg help:\"Sub-sub-arg.\"`\n\n\t\t\tFour struct {\n\t\t\t} `cmd help:\"Sub-sub-command.\" aliases:\"for,fore\"`\n\t\t} `cmd help:\"Another subcommand.\"`\n\t}\n\n\tw := bytes.NewBuffer(nil)\n\texited := false\n\tapp := mustNew(t, &cli,\n\t\tkong.Name(\"test-app\"),\n\t\tkong.Description(\"A test app.\"),\n\t\tkong.Writers(w, w),\n\t\tkong.ConfigureHelp(kong.HelpOptions{\n\t\t\tTree:     true,\n\t\t\tIndenter: kong.LineIndenter,\n\t\t}),\n\t\tkong.Exit(func(int) {\n\t\t\texited = true\n\t\t\tpanic(true) // Panic to fake \"exit\".\n\t\t}),\n\t)\n\n\tt.Run(\"Full\", func(t *testing.T) {\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"--help\"})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tassert.True(t, exited)\n\t\texpected := `Usage: test-app <command> [flags]\n\nA test app.\n\nFlags:\n  -h, --help    Show context-sensitive help.\n\nCommands:\n  one (un,uno)         subcommand one\n  - thing              subcommand thing\n    - <arg>            argument\n  - <other>            subcommand other\n\n  two                  Another subcommand.\n  - <three>            Sub-sub-arg.\n  - four (for,fore)    Sub-sub-command.\n\nRun \"test-app <command> --help\" for more information on a command.\n`\n\t\tif expected != w.String() {\n\t\t\tt.Errorf(\"help command returned:\\n%v\\n\\nwant:\\n%v\", w.String(), expected)\n\t\t}\n\t\tassert.Equal(t, expected, w.String())\n\t})\n\n\tt.Run(\"Selected\", func(t *testing.T) {\n\t\texited = false\n\t\tw.Truncate(0)\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"one\", \"--help\"})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tassert.True(t, exited)\n\t\texpected := `Usage: test-app one (un,uno) <command> [flags]\n\nsubcommand one\n\nFlags:\n  -h, --help    Show context-sensitive help.\n\nCommands:\n  thing      subcommand thing\n  - <arg>    argument\n\n  <other>    subcommand other\n`\n\t\tif expected != w.String() {\n\t\t\tt.Errorf(\"help command returned:\\n%v\\n\\nwant:\\n%v\", w.String(), expected)\n\t\t}\n\t\tassert.Equal(t, expected, w.String())\n\t})\n}\n\nfunc TestHelpCompactNoExpand(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tThing struct {\n\t\t\t\tArg string `arg help:\"argument\"`\n\t\t\t} `cmd help:\"subcommand thing\"`\n\t\t\tOther struct {\n\t\t\t\tOther string `arg help:\"other arg\"`\n\t\t\t} `arg help:\"subcommand other\"`\n\t\t} `cmd help:\"subcommand one\" group:\"Group A\" aliases:\"un,uno\"` // Groups are ignored in trees\n\n\t\tTwo struct {\n\t\t\tThree threeArg `arg help:\"Sub-sub-arg.\"`\n\n\t\t\tFour struct {\n\t\t\t} `cmd help:\"Sub-sub-command.\" aliases:\"for,fore\"`\n\t\t} `cmd help:\"Another subcommand.\"`\n\t}\n\n\tw := bytes.NewBuffer(nil)\n\texited := false\n\tapp := mustNew(t, &cli,\n\t\tkong.Name(\"test-app\"),\n\t\tkong.Description(\"A test app.\"),\n\t\tkong.Writers(w, w),\n\t\tkong.ConfigureHelp(kong.HelpOptions{\n\t\t\tCompact:             true,\n\t\t\tNoExpandSubcommands: true,\n\t\t}),\n\t\tkong.Exit(func(int) {\n\t\t\texited = true\n\t\t\tpanic(true) // Panic to fake \"exit\".\n\t\t}),\n\t)\n\n\tt.Run(\"Full\", func(t *testing.T) {\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"--help\"})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tassert.True(t, exited)\n\t\texpected := `Usage: test-app <command> [flags]\n\nA test app.\n\nFlags:\n  -h, --help    Show context-sensitive help.\n\nCommands:\n  two    Another subcommand.\n\nGroup A\n  one (un,uno)    subcommand one\n\nRun \"test-app <command> --help\" for more information on a command.\n`\n\t\tif expected != w.String() {\n\t\t\tt.Errorf(\"help command returned:\\n%v\\n\\nwant:\\n%v\", w.String(), expected)\n\t\t}\n\t\tassert.Equal(t, expected, w.String())\n\t})\n\n\tt.Run(\"Selected\", func(t *testing.T) {\n\t\texited = false\n\t\tw.Truncate(0)\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"one\", \"--help\"})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\tassert.True(t, exited)\n\t\texpected := `Usage: test-app one (un,uno) <command> [flags]\n\nsubcommand one\n\nFlags:\n  -h, --help    Show context-sensitive help.\n\nGroup A\n  one (un,uno) thing      subcommand thing\n  one (un,uno) <other>    subcommand other\n`\n\t\tif expected != w.String() {\n\t\t\tt.Errorf(\"help command returned:\\n%v\\n\\nwant:\\n%v\", w.String(), expected)\n\t\t}\n\t\tassert.Equal(t, expected, w.String())\n\t})\n}\n\nfunc TestEnvarAutoHelp(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `env:\"FLAG\" help:\"A flag.\"`\n\t}\n\tw := &strings.Builder{}\n\tp := mustNew(t, &cli, kong.Writers(w, w), kong.Exit(func(int) {}))\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, w.String(), \"A flag ($FLAG).\")\n}\n\nfunc TestMultipleEnvarAutoHelp(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `env:\"FLAG1,FLAG2\" help:\"A flag.\"`\n\t}\n\tw := &strings.Builder{}\n\tp := mustNew(t, &cli, kong.Writers(w, w), kong.Exit(func(int) {}))\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, w.String(), \"A flag ($FLAG1, $FLAG2).\")\n}\n\n//nolint:dupl // false positive\nfunc TestEnvarAutoHelpWithEnvPrefix(t *testing.T) {\n\ttype Anonymous struct {\n\t\tFlag  string `env:\"FLAG\" help:\"A flag.\"`\n\t\tOther string `help:\"A different flag.\"`\n\t}\n\tvar cli struct {\n\t\tAnonymous `envprefix:\"ANON_\"`\n\t}\n\tw := &strings.Builder{}\n\tp := mustNew(t, &cli, kong.Writers(w, w), kong.Exit(func(int) {}))\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, w.String(), \"A flag ($ANON_FLAG).\")\n\tassert.Contains(t, w.String(), \"A different flag.\")\n}\n\n//nolint:dupl // false positive\nfunc TestMultipleEnvarAutoHelpWithEnvPrefix(t *testing.T) {\n\ttype Anonymous struct {\n\t\tFlag  string `env:\"FLAG1,FLAG2\" help:\"A flag.\"`\n\t\tOther string `help:\"A different flag.\"`\n\t}\n\tvar cli struct {\n\t\tAnonymous `envprefix:\"ANON_\"`\n\t}\n\tw := &strings.Builder{}\n\tp := mustNew(t, &cli, kong.Writers(w, w), kong.Exit(func(int) {}))\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, w.String(), \"A flag ($ANON_FLAG1, $ANON_FLAG2).\")\n\tassert.Contains(t, w.String(), \"A different flag.\")\n}\n\n//nolint:dupl // false positive\nfunc TestCustomValueFormatter(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `env:\"FLAG\" help:\"A flag.\"`\n\t}\n\tw := &strings.Builder{}\n\tp := mustNew(t, &cli,\n\t\tkong.Writers(w, w),\n\t\tkong.Exit(func(int) {}),\n\t\tkong.ValueFormatter(func(value *kong.Value) string {\n\t\t\treturn value.Help\n\t\t}),\n\t)\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, w.String(), \"A flag.\")\n}\n\n//nolint:dupl // false positive\nfunc TestMultipleCustomValueFormatter(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `env:\"FLAG1,FLAG2\" help:\"A flag.\"`\n\t}\n\tw := &strings.Builder{}\n\tp := mustNew(t, &cli,\n\t\tkong.Writers(w, w),\n\t\tkong.Exit(func(int) {}),\n\t\tkong.ValueFormatter(func(value *kong.Value) string {\n\t\t\treturn value.Help\n\t\t}),\n\t)\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, w.String(), \"A flag.\")\n}\n\nfunc TestAutoGroup(t *testing.T) {\n\tvar cli struct {\n\t\tGroupedAString string `help:\"A string flag grouped in A.\"`\n\t\tFreeString     string `help:\"A non grouped string flag.\"`\n\t\tGroupedBString string `help:\"A string flag grouped in B.\"`\n\t\tFreeBool       bool   `help:\"A non grouped bool flag.\"`\n\t\tGroupedABool   bool   `help:\"A bool flag grouped in A.\"`\n\n\t\tOne struct {\n\t\t\tFlag string `help:\"Nested flag.\"`\n\t\t\t// Group is inherited from the parent command\n\t\t\tThing struct {\n\t\t\t\tArg string `arg help:\"argument\"`\n\t\t\t} `cmd help:\"subcommand thing\"`\n\t\t\tOther struct {\n\t\t\t\tOther string `arg help:\"other arg\"`\n\t\t\t} `arg help:\"subcommand other\"`\n\t\t\t// ... but a subcommand can override it\n\t\t\tStuff struct {\n\t\t\t\tStuff string `arg help:\"argument\"`\n\t\t\t} `arg help:\"subcommand stuff\"`\n\t\t} `cmd help:\"A subcommand grouped in A.\"`\n\n\t\tTwo struct {\n\t\t\tGrouped1String  string `help:\"A string flag grouped in 1.\"`\n\t\t\tAFreeString     string `help:\"A non grouped string flag.\"`\n\t\t\tGrouped2String  string `help:\"A string flag grouped in 2.\"`\n\t\t\tAGroupedAString bool   `help:\"A string flag grouped in A.\"`\n\t\t\tGrouped1Bool    bool   `help:\"A bool flag grouped in 1.\"`\n\t\t} `cmd help:\"A non grouped subcommand.\"`\n\n\t\tFour struct {\n\t\t\tFlag string `help:\"Nested flag.\"`\n\t\t} `cmd help:\"Another subcommand grouped in B.\"`\n\n\t\tThree struct {\n\t\t\tFlag string `help:\"Nested flag.\"`\n\t\t} `cmd help:\"Another subcommand grouped in A.\"`\n\t}\n\tw := bytes.NewBuffer(nil)\n\tapp := mustNew(t, &cli,\n\t\tkong.Writers(w, w),\n\t\tkong.Exit(func(int) {}),\n\t\tkong.AutoGroup(func(parent kong.Visitable, flag *kong.Flag) *kong.Group {\n\t\t\tif node, ok := parent.(*kong.Node); ok {\n\t\t\t\treturn &kong.Group{\n\t\t\t\t\tKey:   node.Name,\n\t\t\t\t\tTitle: strings.Title(node.Name) + \" flags:\",\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}),\n\t)\n\t_, _ = app.Parse([]string{\"--help\", \"two\"})\n\tassert.Equal(t, `Usage: test two [flags]\n\nA non grouped subcommand.\n\nFlags:\n  -h, --help                       Show context-sensitive help.\n      --grouped-a-string=STRING    A string flag grouped in A.\n      --free-string=STRING         A non grouped string flag.\n      --grouped-b-string=STRING    A string flag grouped in B.\n      --free-bool                  A non grouped bool flag.\n      --grouped-a-bool             A bool flag grouped in A.\n\nTwo flags:\n  --grouped-1-string=STRING    A string flag grouped in 1.\n  --a-free-string=STRING       A non grouped string flag.\n  --grouped-2-string=STRING    A string flag grouped in 2.\n  --a-grouped-a-string         A string flag grouped in A.\n  --grouped-1-bool             A bool flag grouped in 1.\n`, w.String())\n}\n\nfunc TestHelpGrouping(t *testing.T) {\n\tvar cli struct {\n\t\tGroupedAString string `help:\"A string flag grouped in A.\" group:\"Group A\"`\n\t\tFreeString     string `help:\"A non grouped string flag.\"`\n\t\tGroupedBString string `help:\"A string flag grouped in B.\" group:\"Group B\"`\n\t\tFreeBool       bool   `help:\"A non grouped bool flag.\"`\n\t\tGroupedABool   bool   `help:\"A bool flag grouped in A.\" group:\"Group A\"`\n\n\t\tOne struct {\n\t\t\tFlag string `help:\"Nested flag.\"`\n\t\t\t// Group is inherited from the parent command\n\t\t\tThing struct {\n\t\t\t\tArg string `arg help:\"argument\"`\n\t\t\t} `cmd help:\"subcommand thing\"`\n\t\t\tOther struct {\n\t\t\t\tOther string `arg help:\"other arg\"`\n\t\t\t} `arg help:\"subcommand other\"`\n\t\t\t// ... but a subcommand can override it\n\t\t\tStuff struct {\n\t\t\t\tStuff string `arg help:\"argument\"`\n\t\t\t} `arg help:\"subcommand stuff\" group:\"Group B\"`\n\t\t} `cmd help:\"A subcommand grouped in A.\" group:\"Group A\"`\n\n\t\tTwo struct {\n\t\t\tGrouped1String  string `help:\"A string flag grouped in 1.\" group:\"Group 1\"`\n\t\t\tAFreeString     string `help:\"A non grouped string flag.\"`\n\t\t\tGrouped2String  string `help:\"A string flag grouped in 2.\" group:\"Group 2\"`\n\t\t\tAGroupedAString bool   `help:\"A string flag grouped in A.\" group:\"Group A\"`\n\t\t\tGrouped1Bool    bool   `help:\"A bool flag grouped in 1.\" group:\"Group 1\"`\n\t\t} `cmd help:\"A non grouped subcommand.\"`\n\n\t\tFour struct {\n\t\t\tFlag string `help:\"Nested flag.\"`\n\t\t} `cmd help:\"Another subcommand grouped in B.\" group:\"Group B\"`\n\n\t\tThree struct {\n\t\t\tFlag string `help:\"Nested flag.\"`\n\t\t} `cmd help:\"Another subcommand grouped in A.\" group:\"Group A\"`\n\t}\n\n\tw := bytes.NewBuffer(nil)\n\texited := false\n\tapp := mustNew(t, &cli,\n\t\tkong.Name(\"test-app\"),\n\t\tkong.Description(\"A test app.\"),\n\t\tkong.Groups{\n\t\t\t\"Group A\":     \"Group title taken from the kong.ExplicitGroups option\\nA group header\",\n\t\t\t\"Group 1\":     \"Another group title, this time without header\",\n\t\t\t\"Unknown key\": \"\",\n\t\t},\n\t\tkong.Writers(w, w),\n\t\tkong.Exit(func(int) {\n\t\t\texited = true\n\t\t\tpanic(true) // Panic to fake \"exit\".\n\t\t}),\n\t)\n\n\tt.Run(\"Full\", func(t *testing.T) {\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"--help\"})\n\t\t\tassert.True(t, exited)\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t\texpected := `Usage: test-app <command> [flags]\n\nA test app.\n\nFlags:\n  -h, --help                  Show context-sensitive help.\n      --free-string=STRING    A non grouped string flag.\n      --free-bool             A non grouped bool flag.\n\nGroup title taken from the kong.ExplicitGroups option\n  A group header\n\n  --grouped-a-string=STRING    A string flag grouped in A.\n  --grouped-a-bool             A bool flag grouped in A.\n\nGroup B\n  --grouped-b-string=STRING    A string flag grouped in B.\n\nCommands:\n  two [flags]\n    A non grouped subcommand.\n\nGroup title taken from the kong.ExplicitGroups option\n  A group header\n\n  one thing <arg> [flags]\n    subcommand thing\n\n  one <other> [flags]\n    subcommand other\n\n  three [flags]\n    Another subcommand grouped in A.\n\nGroup B\n  one <stuff> [flags]\n    subcommand stuff\n\n  four [flags]\n    Another subcommand grouped in B.\n\nRun \"test-app <command> --help\" for more information on a command.\n`\n\t\tt.Log(w.String())\n\t\tt.Log(expected)\n\t\tassert.Equal(t, expected, w.String())\n\t})\n\n\tt.Run(\"Selected\", func(t *testing.T) {\n\t\texited = false\n\t\tw.Truncate(0)\n\t\tpanicsTrue(t, func() {\n\t\t\t_, err := app.Parse([]string{\"two\", \"--help\"})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.True(t, exited)\n\t\t})\n\t\texpected := `Usage: test-app two [flags]\n\nA non grouped subcommand.\n\nFlags:\n  -h, --help                    Show context-sensitive help.\n      --free-string=STRING      A non grouped string flag.\n      --free-bool               A non grouped bool flag.\n\n      --a-free-string=STRING    A non grouped string flag.\n\nGroup title taken from the kong.ExplicitGroups option\n  A group header\n\n  --grouped-a-string=STRING    A string flag grouped in A.\n  --grouped-a-bool             A bool flag grouped in A.\n\n  --a-grouped-a-string         A string flag grouped in A.\n\nGroup B\n  --grouped-b-string=STRING    A string flag grouped in B.\n\nAnother group title, this time without header\n  --grouped-1-string=STRING    A string flag grouped in 1.\n  --grouped-1-bool             A bool flag grouped in 1.\n\nGroup 2\n  --grouped-2-string=STRING    A string flag grouped in 2.\n`\n\t\tt.Log(expected)\n\t\tt.Log(w.String())\n\t\tassert.Equal(t, expected, w.String())\n\t})\n}\n\nfunc TestUsageOnError(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `help:\"A required flag.\" required`\n\t}\n\tw := &strings.Builder{}\n\tp := mustNew(t, &cli,\n\t\tkong.Writers(w, w),\n\t\tkong.Description(\"Some description.\"),\n\t\tkong.Exit(func(int) {}),\n\t\tkong.UsageOnError(),\n\t)\n\t_, err := p.Parse([]string{})\n\tp.FatalIfErrorf(err)\n\n\texpected := `Usage: test --flag=STRING [flags]\n\nSome description.\n\nFlags:\n  -h, --help           Show context-sensitive help.\n      --flag=STRING    A required flag.\n\ntest: error: missing flags: --flag=STRING\n`\n\tassert.Equal(t, expected, w.String())\n}\n\nfunc TestShortUsageOnError(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `help:\"A required flag.\" required`\n\t}\n\tw := &strings.Builder{}\n\tp := mustNew(t, &cli,\n\t\tkong.Writers(w, w),\n\t\tkong.Description(\"Some description.\"),\n\t\tkong.Exit(func(int) {}),\n\t\tkong.ShortUsageOnError(),\n\t)\n\t_, err := p.Parse([]string{})\n\tassert.Error(t, err)\n\tp.FatalIfErrorf(err)\n\n\texpected := `Usage: test --flag=STRING [flags]\nRun \"test --help\" for more information.\n\ntest: error: missing flags: --flag=STRING\n`\n\tassert.Equal(t, expected, w.String())\n}\n\nfunc TestCustomShortUsageOnError(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `help:\"A required flag.\" required`\n\t}\n\tw := &strings.Builder{}\n\tshortHelp := func(_ kong.HelpOptions, ctx *kong.Context) error {\n\t\tfmt.Fprintln(ctx.Stdout, \"ðŸ¤· wish I could help\")\n\t\treturn nil\n\t}\n\tp := mustNew(t, &cli,\n\t\tkong.Writers(w, w),\n\t\tkong.Description(\"Some description.\"),\n\t\tkong.Exit(func(int) {}),\n\t\tkong.ShortHelp(shortHelp),\n\t\tkong.ShortUsageOnError(),\n\t)\n\t_, err := p.Parse([]string{})\n\tassert.Error(t, err)\n\tp.FatalIfErrorf(err)\n\n\texpected := `ðŸ¤· wish I could help\n\ntest: error: missing flags: --flag=STRING\n`\n\tassert.Equal(t, expected, w.String())\n}\n"
        },
        {
          "name": "helpwrap1.18_test.go",
          "type": "blob",
          "size": 0.9658203125,
          "content": "//go:build !go1.19\n// +build !go1.19\n\npackage kong_test\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n\t\"github.com/alecthomas/kong\"\n)\n\nfunc TestCustomWrap(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `help:\"A string flag with very long help that wraps a lot and is verbose and is really verbose.\"`\n\t}\n\n\tw := bytes.NewBuffer(nil)\n\tapp := mustNew(t, &cli,\n\t\tkong.Name(\"test-app\"),\n\t\tkong.Description(\"A test app.\"),\n\t\tkong.HelpOptions{\n\t\t\tWrapUpperBound: 50,\n\t\t},\n\t\tkong.Writers(w, w),\n\t\tkong.Exit(func(int) {}),\n\t)\n\n\t_, err := app.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\texpected := `Usage: test-app\n\nA test app.\n\nFlags:\n  -h, --help           Show context-sensitive\n                       help.\n      --flag=STRING    A string flag with very\n                       long help that wraps a lot\n                       and is verbose and is\n                       really verbose.\n`\n\tt.Log(w.String())\n\tt.Log(expected)\n\tassert.Equal(t, expected, w.String())\n}\n"
        },
        {
          "name": "helpwrap1.19_test.go",
          "type": "blob",
          "size": 1.119140625,
          "content": "// Wrapping of text changed in Go1.19 per https://github.com/alecthomas/kong/issues/325\n// The test has been split pre-go1.19 and go1.19 and onwards.\n\n//go:build go1.19\n// +build go1.19\n\npackage kong_test\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n\t\"github.com/alecthomas/kong\"\n)\n\nfunc TestCustomWrap(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `help:\"A string flag with very long help that wraps a lot and is verbose and is really verbose.\"`\n\t}\n\n\tw := bytes.NewBuffer(nil)\n\tapp := mustNew(t, &cli,\n\t\tkong.Name(\"test-app\"),\n\t\tkong.Description(\"A test app.\"),\n\t\tkong.HelpOptions{\n\t\t\tWrapUpperBound: 50,\n\t\t},\n\t\tkong.Writers(w, w),\n\t\tkong.Exit(func(int) {}),\n\t)\n\n\t_, err := app.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\texpected := `Usage: test-app [flags]\n\nA test app.\n\nFlags:\n  -h, --help           Show context-sensitive\n                       help.\n      --flag=STRING    A string flag with very\n                       long help that wraps a\n                       lot and is verbose and is\n                       really verbose.\n`\n\tt.Log(w.String())\n\tt.Log(expected)\n\tassert.Equal(t, expected, w.String())\n}\n"
        },
        {
          "name": "hooks.go",
          "type": "blob",
          "size": 0.9365234375,
          "content": "package kong\n\n// BeforeResolve is a documentation-only interface describing hooks that run before resolvers are applied.\ntype BeforeResolve interface {\n\t// This is not the correct signature - see README for details.\n\tBeforeResolve(args ...any) error\n}\n\n// BeforeApply is a documentation-only interface describing hooks that run before values are set.\ntype BeforeApply interface {\n\t// This is not the correct signature - see README for details.\n\tBeforeApply(args ...any) error\n}\n\n// AfterApply is a documentation-only interface describing hooks that run after values are set.\ntype AfterApply interface {\n\t// This is not the correct signature - see README for details.\n\tAfterApply(args ...any) error\n}\n\n// AfterRun is a documentation-only interface describing hooks that run after Run() returns.\ntype AfterRun interface {\n\t// This is not the correct signature - see README for details.\n\t// AfterRun is called after Run() returns.\n\tAfterRun(args ...any) error\n}\n"
        },
        {
          "name": "interpolate.go",
          "type": "blob",
          "size": 1.2216796875,
          "content": "package kong\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nvar interpolationRegex = regexp.MustCompile(`(\\$\\$)|((?:\\${([[:alpha:]_][[:word:]]*))(?:=([^}]+))?})|(\\$)|([^$]+)`)\n\n// HasInterpolatedVar returns true if the variable \"v\" is interpolated in \"s\".\nfunc HasInterpolatedVar(s string, v string) bool {\n\tmatches := interpolationRegex.FindAllStringSubmatch(s, -1)\n\tfor _, match := range matches {\n\t\tif name := match[3]; name == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Interpolate variables from vars into s for substrings in the form ${var} or ${var=default}.\nfunc interpolate(s string, vars Vars, updatedVars map[string]string) (string, error) {\n\tout := \"\"\n\tmatches := interpolationRegex.FindAllStringSubmatch(s, -1)\n\tif len(matches) == 0 {\n\t\treturn s, nil\n\t}\n\tfor key, val := range updatedVars {\n\t\tif vars[key] != val {\n\t\t\tvars = vars.CloneWith(updatedVars)\n\t\t\tbreak\n\t\t}\n\t}\n\tfor _, match := range matches {\n\t\tif dollar := match[1]; dollar != \"\" {\n\t\t\tout += \"$\"\n\t\t} else if name := match[3]; name != \"\" {\n\t\t\tvalue, ok := vars[name]\n\t\t\tif !ok {\n\t\t\t\t// No default value.\n\t\t\t\tif match[4] == \"\" {\n\t\t\t\t\treturn \"\", fmt.Errorf(\"undefined variable ${%s}\", name)\n\t\t\t\t}\n\t\t\t\tvalue = match[4]\n\t\t\t}\n\t\t\tout += value\n\t\t} else {\n\t\t\tout += match[0]\n\t\t}\n\t}\n\treturn out, nil\n}\n"
        },
        {
          "name": "interpolate_test.go",
          "type": "blob",
          "size": 0.9228515625,
          "content": "package kong\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc TestInterpolate(t *testing.T) {\n\tvars := map[string]string{\n\t\t\"age\":  \"35\",\n\t\t\"city\": \"Melbourne\",\n\t}\n\tupdatedVars := map[string]string{\n\t\t\"height\": \"180\",\n\t}\n\tactual, err := interpolate(\"${name=Bobby Brown} is ${age} years old, ${height} cm tall, lives in ${city=<unknown>}, and likes $${AUD}\", vars, updatedVars)\n\tassert.NoError(t, err)\n\tassert.Equal(t, `Bobby Brown is 35 years old, 180 cm tall, lives in Melbourne, and likes ${AUD}`, actual)\n}\n\nfunc TestHasInterpolatedVar(t *testing.T) {\n\tfor _, tag := range []string{\"name\", \"age\", \"height\", \"city\"} {\n\t\tassert.True(t, HasInterpolatedVar(\"${name=Bobby Brown} is ${age} years old, ${height} cm tall, lives in ${city=<unknown>}, and likes $${AUD}\", tag), tag)\n\t}\n\n\tfor _, tag := range []string{\"name\", \"age\", \"height\", \"AUD\"} {\n\t\tassert.False(t, HasInterpolatedVar(\"$name $$age {height} $${AUD}\", tag), tag)\n\t}\n}\n"
        },
        {
          "name": "kong.go",
          "type": "blob",
          "size": 12.25,
          "content": "package kong\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\tcallbackReturnSignature = reflect.TypeOf((*error)(nil)).Elem()\n)\n\nfunc failField(parent reflect.Value, field reflect.StructField, format string, args ...any) error {\n\tname := parent.Type().Name()\n\tif name == \"\" {\n\t\tname = \"<anonymous struct>\"\n\t}\n\treturn fmt.Errorf(\"%s.%s: %s\", name, field.Name, fmt.Sprintf(format, args...))\n}\n\n// Must creates a new Parser or panics if there is an error.\nfunc Must(ast any, options ...Option) *Kong {\n\tk, err := New(ast, options...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn k\n}\n\ntype usageOnError int\n\nconst (\n\tshortUsage usageOnError = iota + 1\n\tfullUsage\n)\n\n// Kong is the main parser type.\ntype Kong struct {\n\t// Grammar model.\n\tModel *Application\n\n\t// Termination function (defaults to os.Exit)\n\tExit func(int)\n\n\tStdout io.Writer\n\tStderr io.Writer\n\n\tbindings     bindings\n\tloader       ConfigurationLoader\n\tresolvers    []Resolver\n\tregistry     *Registry\n\tignoreFields []*regexp.Regexp\n\n\tnoDefaultHelp bool\n\tusageOnError  usageOnError\n\thelp          HelpPrinter\n\tshortHelp     HelpPrinter\n\thelpFormatter HelpValueFormatter\n\thelpOptions   HelpOptions\n\thelpFlag      *Flag\n\tgroups        []Group\n\tvars          Vars\n\tflagNamer     func(string) string\n\n\t// Set temporarily by Options. These are applied after build().\n\tpostBuildOptions []Option\n\tembedded         []embedded\n\tdynamicCommands  []*dynamicCommand\n}\n\n// New creates a new Kong parser on grammar.\n//\n// See the README (https://github.com/alecthomas/kong) for usage instructions.\nfunc New(grammar any, options ...Option) (*Kong, error) {\n\tk := &Kong{\n\t\tExit:          os.Exit,\n\t\tStdout:        os.Stdout,\n\t\tStderr:        os.Stderr,\n\t\tregistry:      NewRegistry().RegisterDefaults(),\n\t\tvars:          Vars{},\n\t\tbindings:      bindings{},\n\t\thelpFormatter: DefaultHelpValueFormatter,\n\t\tignoreFields:  make([]*regexp.Regexp, 0),\n\t\tflagNamer: func(s string) string {\n\t\t\treturn strings.ToLower(dashedString(s))\n\t\t},\n\t}\n\n\toptions = append(options, Bind(k))\n\n\tfor _, option := range options {\n\t\tif err := option.Apply(k); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif k.help == nil {\n\t\tk.help = DefaultHelpPrinter\n\t}\n\n\tif k.shortHelp == nil {\n\t\tk.shortHelp = DefaultShortHelpPrinter\n\t}\n\n\tmodel, err := build(k, grammar)\n\tif err != nil {\n\t\treturn k, err\n\t}\n\tmodel.Name = filepath.Base(os.Args[0])\n\tk.Model = model\n\tk.Model.HelpFlag = k.helpFlag\n\n\t// Embed any embedded structs.\n\tfor _, embed := range k.embedded {\n\t\ttag, err := parseTagString(strings.Join(embed.tags, \" \"))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttag.Embed = true\n\t\tv := reflect.Indirect(reflect.ValueOf(embed.strct))\n\t\tnode, err := buildNode(k, v, CommandNode, tag, map[string]bool{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, child := range node.Children {\n\t\t\tchild.Parent = k.Model.Node\n\t\t\tk.Model.Children = append(k.Model.Children, child)\n\t\t}\n\t\tk.Model.Flags = append(k.Model.Flags, node.Flags...)\n\t}\n\n\t// Synthesise command nodes.\n\tfor _, dcmd := range k.dynamicCommands {\n\t\ttag, terr := parseTagString(strings.Join(dcmd.tags, \" \"))\n\t\tif terr != nil {\n\t\t\treturn nil, terr\n\t\t}\n\t\ttag.Name = dcmd.name\n\t\ttag.Help = dcmd.help\n\t\ttag.Group = dcmd.group\n\t\ttag.Cmd = true\n\t\tv := reflect.Indirect(reflect.ValueOf(dcmd.cmd))\n\t\terr = buildChild(k, k.Model.Node, CommandNode, reflect.Value{}, reflect.StructField{\n\t\t\tName: dcmd.name,\n\t\t\tType: v.Type(),\n\t\t}, v, tag, dcmd.name, map[string]bool{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tfor _, option := range k.postBuildOptions {\n\t\tif err = option.Apply(k); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tk.postBuildOptions = nil\n\n\tif err = k.interpolate(k.Model.Node); err != nil {\n\t\treturn nil, err\n\t}\n\n\tk.bindings.add(k.vars)\n\n\tif err = checkOverlappingXorAnd(k); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn k, nil\n}\n\nfunc checkOverlappingXorAnd(k *Kong) error {\n\txorGroups := map[string][]string{}\n\tandGroups := map[string][]string{}\n\tfor _, flag := range k.Model.Node.Flags {\n\t\tfor _, xor := range flag.Xor {\n\t\t\txorGroups[xor] = append(xorGroups[xor], flag.Name)\n\t\t}\n\t\tfor _, and := range flag.And {\n\t\t\tandGroups[and] = append(andGroups[and], flag.Name)\n\t\t}\n\t}\n\tfor xor, xorSet := range xorGroups {\n\t\tfor and, andSet := range andGroups {\n\t\t\toverlappingEntries := []string{}\n\t\t\tfor _, xorTag := range xorSet {\n\t\t\t\tfor _, andTag := range andSet {\n\t\t\t\t\tif xorTag == andTag {\n\t\t\t\t\t\toverlappingEntries = append(overlappingEntries, xorTag)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(overlappingEntries) > 1 {\n\t\t\t\treturn fmt.Errorf(\"invalid xor and combination, %s and %s overlap with more than one: %s\", xor, and, overlappingEntries)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\ntype varStack []Vars\n\nfunc (v *varStack) head() Vars { return (*v)[len(*v)-1] }\nfunc (v *varStack) pop()       { *v = (*v)[:len(*v)-1] }\nfunc (v *varStack) push(vars Vars) Vars {\n\tif len(*v) != 0 {\n\t\tvars = (*v)[len(*v)-1].CloneWith(vars)\n\t}\n\t*v = append(*v, vars)\n\treturn vars\n}\n\n// Interpolate variables into model.\nfunc (k *Kong) interpolate(node *Node) (err error) {\n\tstack := varStack{}\n\treturn Visit(node, func(node Visitable, next Next) error {\n\t\tswitch node := node.(type) {\n\t\tcase *Node:\n\t\t\tvars := stack.push(node.Vars())\n\t\t\tnode.Help, err = interpolate(node.Help, vars, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"help for %s: %s\", node.Path(), err)\n\t\t\t}\n\t\t\terr = next(nil)\n\t\t\tstack.pop()\n\t\t\treturn err\n\n\t\tcase *Value:\n\t\t\treturn next(k.interpolateValue(node, stack.head()))\n\t\t}\n\t\treturn next(nil)\n\t})\n}\n\nfunc (k *Kong) interpolateValue(value *Value, vars Vars) (err error) {\n\tif len(value.Tag.Vars) > 0 {\n\t\tvars = vars.CloneWith(value.Tag.Vars)\n\t}\n\tif varsContributor, ok := value.Mapper.(VarsContributor); ok {\n\t\tvars = vars.CloneWith(varsContributor.Vars(value))\n\t}\n\n\tif value.Enum, err = interpolate(value.Enum, vars, nil); err != nil {\n\t\treturn fmt.Errorf(\"enum for %s: %s\", value.Summary(), err)\n\t}\n\n\tif value.Default, err = interpolate(value.Default, vars, nil); err != nil {\n\t\treturn fmt.Errorf(\"default value for %s: %s\", value.Summary(), err)\n\t}\n\tif value.Enum, err = interpolate(value.Enum, vars, nil); err != nil {\n\t\treturn fmt.Errorf(\"enum value for %s: %s\", value.Summary(), err)\n\t}\n\tupdatedVars := map[string]string{\n\t\t\"default\": value.Default,\n\t\t\"enum\":    value.Enum,\n\t}\n\tif value.Flag != nil {\n\t\tfor i, env := range value.Flag.Envs {\n\t\t\tif value.Flag.Envs[i], err = interpolate(env, vars, updatedVars); err != nil {\n\t\t\t\treturn fmt.Errorf(\"env value for %s: %s\", value.Summary(), err)\n\t\t\t}\n\t\t}\n\t\tvalue.Tag.Envs = value.Flag.Envs\n\t\tupdatedVars[\"env\"] = \"\"\n\t\tif len(value.Flag.Envs) != 0 {\n\t\t\tupdatedVars[\"env\"] = value.Flag.Envs[0]\n\t\t}\n\t}\n\tvalue.Help, err = interpolate(value.Help, vars, updatedVars)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"help for %s: %s\", value.Summary(), err)\n\t}\n\treturn nil\n}\n\n// Provide additional builtin flags, if any.\nfunc (k *Kong) extraFlags() []*Flag {\n\tif k.noDefaultHelp {\n\t\treturn nil\n\t}\n\tvar helpTarget helpValue\n\tvalue := reflect.ValueOf(&helpTarget).Elem()\n\thelpFlag := &Flag{\n\t\tShort: 'h',\n\t\tValue: &Value{\n\t\t\tName:         \"help\",\n\t\t\tHelp:         \"Show context-sensitive help.\",\n\t\t\tOrigHelp:     \"Show context-sensitive help.\",\n\t\t\tTarget:       value,\n\t\t\tTag:          &Tag{},\n\t\t\tMapper:       k.registry.ForValue(value),\n\t\t\tDefaultValue: reflect.ValueOf(false),\n\t\t},\n\t}\n\thelpFlag.Flag = helpFlag\n\tk.helpFlag = helpFlag\n\treturn []*Flag{helpFlag}\n}\n\n// Parse arguments into target.\n//\n// The return Context can be used to further inspect the parsed command-line, to format help, to find the\n// selected command, to run command Run() methods, and so on. See Context and README for more information.\n//\n// Will return a ParseError if a *semantically* invalid command-line is encountered (as opposed to a syntactically\n// invalid one, which will report a normal error).\nfunc (k *Kong) Parse(args []string) (ctx *Context, err error) {\n\tctx, err = Trace(k, args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif ctx.Error != nil {\n\t\treturn nil, &ParseError{error: ctx.Error, Context: ctx}\n\t}\n\tif err = k.applyHook(ctx, \"BeforeReset\"); err != nil {\n\t\treturn nil, &ParseError{error: err, Context: ctx}\n\t}\n\tif err = ctx.Reset(); err != nil {\n\t\treturn nil, &ParseError{error: err, Context: ctx}\n\t}\n\tif err = k.applyHook(ctx, \"BeforeResolve\"); err != nil {\n\t\treturn nil, &ParseError{error: err, Context: ctx}\n\t}\n\tif err = ctx.Resolve(); err != nil {\n\t\treturn nil, &ParseError{error: err, Context: ctx}\n\t}\n\tif err = k.applyHook(ctx, \"BeforeApply\"); err != nil {\n\t\treturn nil, &ParseError{error: err, Context: ctx}\n\t}\n\tif _, err = ctx.Apply(); err != nil {\n\t\treturn nil, &ParseError{error: err, Context: ctx}\n\t}\n\tif err = ctx.Validate(); err != nil {\n\t\treturn nil, &ParseError{error: err, Context: ctx}\n\t}\n\tif err = k.applyHook(ctx, \"AfterApply\"); err != nil {\n\t\treturn nil, &ParseError{error: err, Context: ctx}\n\t}\n\treturn ctx, nil\n}\n\nfunc (k *Kong) applyHook(ctx *Context, name string) error {\n\tfor _, trace := range ctx.Path {\n\t\tvar value reflect.Value\n\t\tswitch {\n\t\tcase trace.App != nil:\n\t\t\tvalue = trace.App.Target\n\t\tcase trace.Argument != nil:\n\t\t\tvalue = trace.Argument.Target\n\t\tcase trace.Command != nil:\n\t\t\tvalue = trace.Command.Target\n\t\tcase trace.Positional != nil:\n\t\t\tvalue = trace.Positional.Target\n\t\tcase trace.Flag != nil:\n\t\t\tvalue = trace.Flag.Value.Target\n\t\tdefault:\n\t\t\tpanic(\"unsupported Path\")\n\t\t}\n\t\tfor _, method := range getMethods(value, name) {\n\t\t\tbinds := k.bindings.clone()\n\t\t\tbinds.add(ctx, trace)\n\t\t\tbinds.add(trace.Node().Vars().CloneWith(k.vars))\n\t\t\tbinds.merge(ctx.bindings)\n\t\t\tif err := callFunction(method, binds); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\t// Path[0] will always be the app root.\n\treturn k.applyHookToDefaultFlags(ctx, ctx.Path[0].Node(), name)\n}\n\n// Call hook on any unset flags with default values.\nfunc (k *Kong) applyHookToDefaultFlags(ctx *Context, node *Node, name string) error {\n\tif node == nil {\n\t\treturn nil\n\t}\n\treturn Visit(node, func(n Visitable, next Next) error {\n\t\tnode, ok := n.(*Node)\n\t\tif !ok {\n\t\t\treturn next(nil)\n\t\t}\n\t\tbinds := k.bindings.clone().add(ctx).add(node.Vars().CloneWith(k.vars))\n\t\tfor _, flag := range node.Flags {\n\t\t\tif !flag.HasDefault || ctx.values[flag.Value].IsValid() || !flag.Target.IsValid() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, method := range getMethods(flag.Target, name) {\n\t\t\t\tpath := &Path{Flag: flag}\n\t\t\t\tif err := callFunction(method, binds.clone().add(path)); err != nil {\n\t\t\t\t\treturn next(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn next(nil)\n\t})\n}\n\nfunc formatMultilineMessage(w io.Writer, leaders []string, format string, args ...any) {\n\tlines := strings.Split(strings.TrimRight(fmt.Sprintf(format, args...), \"\\n\"), \"\\n\")\n\tleader := \"\"\n\tfor _, l := range leaders {\n\t\tif l == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tleader += l + \": \"\n\t}\n\tfmt.Fprintf(w, \"%s%s\\n\", leader, lines[0])\n\tfor _, line := range lines[1:] {\n\t\tfmt.Fprintf(w, \"%*s%s\\n\", len(leader), \" \", line)\n\t}\n}\n\n// Printf writes a message to Kong.Stdout with the application name prefixed.\nfunc (k *Kong) Printf(format string, args ...any) *Kong {\n\tformatMultilineMessage(k.Stdout, []string{k.Model.Name}, format, args...)\n\treturn k\n}\n\n// Errorf writes a message to Kong.Stderr with the application name prefixed.\nfunc (k *Kong) Errorf(format string, args ...any) *Kong {\n\tformatMultilineMessage(k.Stderr, []string{k.Model.Name, \"error\"}, format, args...)\n\treturn k\n}\n\n// Fatalf writes a message to Kong.Stderr with the application name prefixed then exits with a non-zero status.\nfunc (k *Kong) Fatalf(format string, args ...any) {\n\tk.Errorf(format, args...)\n\tk.Exit(1)\n}\n\n// FatalIfErrorf terminates with an error message if err != nil.\nfunc (k *Kong) FatalIfErrorf(err error, args ...any) {\n\tif err == nil {\n\t\treturn\n\t}\n\tmsg := err.Error()\n\tif len(args) > 0 {\n\t\tmsg = fmt.Sprintf(args[0].(string), args[1:]...) + \": \" + err.Error() //nolint\n\t}\n\t// Maybe display usage information.\n\tvar parseErr *ParseError\n\tif errors.As(err, &parseErr) {\n\t\tswitch k.usageOnError {\n\t\tcase fullUsage:\n\t\t\t_ = k.help(k.helpOptions, parseErr.Context)\n\t\t\tfmt.Fprintln(k.Stdout)\n\t\tcase shortUsage:\n\t\t\t_ = k.shortHelp(k.helpOptions, parseErr.Context)\n\t\t\tfmt.Fprintln(k.Stdout)\n\t\t}\n\t}\n\tk.Fatalf(\"%s\", msg)\n}\n\n// LoadConfig from path using the loader configured via Configuration(loader).\n//\n// \"path\" will have ~ and any variables expanded.\nfunc (k *Kong) LoadConfig(path string) (Resolver, error) {\n\tvar err error\n\tpath = ExpandPath(path)\n\tpath, err = interpolate(path, k.vars, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tr, err := os.Open(path) //nolint: gas\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer r.Close()\n\n\treturn k.loader(r)\n}\n"
        },
        {
          "name": "kong.png",
          "type": "blob",
          "size": 67.001953125,
          "content": null
        },
        {
          "name": "kong.sketch",
          "type": "blob",
          "size": 158.697265625,
          "content": null
        },
        {
          "name": "kong_test.go",
          "type": "blob",
          "size": 57.26953125,
          "content": "package kong_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n\t\"github.com/alecthomas/repr\"\n\n\t\"github.com/alecthomas/kong\"\n)\n\nfunc mustNew(t *testing.T, cli any, options ...kong.Option) *kong.Kong {\n\tt.Helper()\n\toptions = append([]kong.Option{\n\t\tkong.Name(\"test\"),\n\t\tkong.Exit(func(int) {\n\t\t\tt.Helper()\n\t\t\tt.Fatalf(\"unexpected exit()\")\n\t\t}),\n\t}, options...)\n\tparser, err := kong.New(cli, options...)\n\tassert.NoError(t, err)\n\treturn parser\n}\n\nfunc TestPositionalArguments(t *testing.T) {\n\tvar cli struct {\n\t\tUser struct {\n\t\t\tCreate struct {\n\t\t\t\tID    int    `kong:\"arg\"`\n\t\t\t\tFirst string `kong:\"arg\"`\n\t\t\t\tLast  string `kong:\"arg\"`\n\t\t\t} `kong:\"cmd\"`\n\t\t} `kong:\"cmd\"`\n\t}\n\tp := mustNew(t, &cli)\n\tctx, err := p.Parse([]string{\"user\", \"create\", \"10\", \"Alec\", \"Thomas\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"user create <id> <first> <last>\", ctx.Command())\n\tt.Run(\"Missing\", func(t *testing.T) {\n\t\t_, err := p.Parse([]string{\"user\", \"create\", \"10\"})\n\t\tassert.Error(t, err)\n\t})\n}\n\nfunc TestBranchingArgument(t *testing.T) {\n\t/*\n\t\tapp user create <id> <first> <last>\n\t\tapp\tuser <id> delete\n\t\tapp\tuser <id> rename <to>\n\n\t*/\n\tvar cli struct {\n\t\tUser struct {\n\t\t\tCreate struct {\n\t\t\t\tID    string `kong:\"arg\"`\n\t\t\t\tFirst string `kong:\"arg\"`\n\t\t\t\tLast  string `kong:\"arg\"`\n\t\t\t} `kong:\"cmd\"`\n\n\t\t\t// Branching argument.\n\t\t\tID struct {\n\t\t\t\tID     int `kong:\"arg\"`\n\t\t\t\tFlag   int\n\t\t\t\tDelete struct{} `kong:\"cmd\"`\n\t\t\t\tRename struct {\n\t\t\t\t\tTo string\n\t\t\t\t} `kong:\"cmd\"`\n\t\t\t} `kong:\"arg\"`\n\t\t} `kong:\"cmd,help='User management.'\"`\n\t}\n\tp := mustNew(t, &cli)\n\tctx, err := p.Parse([]string{\"user\", \"10\", \"delete\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 10, cli.User.ID.ID)\n\tassert.Equal(t, \"user <id> delete\", ctx.Command())\n\tt.Run(\"Missing\", func(t *testing.T) {\n\t\t_, err = p.Parse([]string{\"user\"})\n\t\tassert.Error(t, err)\n\t})\n}\n\nfunc TestResetWithDefaults(t *testing.T) {\n\tvar cli struct {\n\t\tFlag            string\n\t\tFlagWithDefault string `kong:\"default='default'\"`\n\t}\n\tcli.Flag = \"BLAH\"\n\tcli.FlagWithDefault = \"BLAH\"\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"\", cli.Flag)\n\tassert.Equal(t, \"default\", cli.FlagWithDefault)\n}\n\nfunc TestFlagSlice(t *testing.T) {\n\tvar cli struct {\n\t\tSlice []int\n\t}\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{\"--slice=1,2,3\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int{1, 2, 3}, cli.Slice)\n}\n\nfunc TestFlagSliceWithSeparator(t *testing.T) {\n\tvar cli struct {\n\t\tSlice []string\n\t}\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{`--slice=a\\,b,c`})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"a,b\", \"c\"}, cli.Slice)\n}\n\nfunc TestArgSlice(t *testing.T) {\n\tvar cli struct {\n\t\tSlice []int `arg`\n\t\tFlag  bool\n\t}\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{\"1\", \"2\", \"3\", \"--flag\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int{1, 2, 3}, cli.Slice)\n\tassert.Equal(t, true, cli.Flag)\n}\n\nfunc TestArgSliceWithSeparator(t *testing.T) {\n\tvar cli struct {\n\t\tSlice []string `arg`\n\t\tFlag  bool\n\t}\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{\"a,b\", \"c\", \"--flag\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"a,b\", \"c\"}, cli.Slice)\n\tassert.Equal(t, true, cli.Flag)\n}\n\nfunc TestUnsupportedFieldErrors(t *testing.T) {\n\tvar cli struct {\n\t\tKeys struct{}\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestMatchingArgField(t *testing.T) {\n\tvar cli struct {\n\t\tID struct {\n\t\t\tNotID int `kong:\"arg\"`\n\t\t} `kong:\"arg\"`\n\t}\n\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestCantMixPositionalAndBranches(t *testing.T) {\n\tvar cli struct {\n\t\tArg     string `kong:\"arg\"`\n\t\tCommand struct {\n\t\t} `kong:\"cmd\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestPropagatedFlags(t *testing.T) {\n\tvar cli struct {\n\t\tFlag1    string\n\t\tCommand1 struct {\n\t\t\tFlag2    bool\n\t\t\tCommand2 struct{} `kong:\"cmd\"`\n\t\t} `kong:\"cmd\"`\n\t}\n\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{\"command-1\", \"command-2\", \"--flag-2\", \"--flag-1=moo\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"moo\", cli.Flag1)\n\tassert.Equal(t, true, cli.Command1.Flag2)\n}\n\nfunc TestRequiredFlag(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `kong:\"required\"`\n\t}\n\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestOptionalArg(t *testing.T) {\n\tvar cli struct {\n\t\tArg string `kong:\"arg,optional\"`\n\t}\n\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n}\n\nfunc TestOptionalArgWithDefault(t *testing.T) {\n\tvar cli struct {\n\t\tArg string `kong:\"arg,optional,default='moo'\"`\n\t}\n\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"moo\", cli.Arg)\n}\n\nfunc TestArgWithDefaultIsOptional(t *testing.T) {\n\tvar cli struct {\n\t\tArg string `kong:\"arg,default='moo'\"`\n\t}\n\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"moo\", cli.Arg)\n}\n\nfunc TestRequiredArg(t *testing.T) {\n\tvar cli struct {\n\t\tArg string `kong:\"arg\"`\n\t}\n\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestInvalidRequiredAfterOptional(t *testing.T) {\n\tvar cli struct {\n\t\tID   int    `kong:\"arg,optional\"`\n\t\tName string `kong:\"arg\"`\n\t}\n\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestOptionalStructArg(t *testing.T) {\n\tvar cli struct {\n\t\tName struct {\n\t\t\tName    string `kong:\"arg,optional\"`\n\t\t\tEnabled bool\n\t\t} `kong:\"arg,optional\"`\n\t}\n\n\tparser := mustNew(t, &cli)\n\n\tt.Run(\"WithFlag\", func(t *testing.T) {\n\t\t_, err := parser.Parse([]string{\"gak\", \"--enabled\"})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"gak\", cli.Name.Name)\n\t\tassert.Equal(t, true, cli.Name.Enabled)\n\t})\n\n\tt.Run(\"WithoutFlag\", func(t *testing.T) {\n\t\t_, err := parser.Parse([]string{\"gak\"})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"gak\", cli.Name.Name)\n\t})\n\n\tt.Run(\"WithNothing\", func(t *testing.T) {\n\t\t_, err := parser.Parse([]string{})\n\t\tassert.NoError(t, err)\n\t})\n}\n\nfunc TestMixedRequiredArgs(t *testing.T) {\n\tvar cli struct {\n\t\tName string `kong:\"arg\"`\n\t\tID   int    `kong:\"arg,optional\"`\n\t}\n\n\tparser := mustNew(t, &cli)\n\n\tt.Run(\"SingleRequired\", func(t *testing.T) {\n\t\t_, err := parser.Parse([]string{\"gak\", \"5\"})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"gak\", cli.Name)\n\t\tassert.Equal(t, 5, cli.ID)\n\t})\n\n\tt.Run(\"ExtraOptional\", func(t *testing.T) {\n\t\t_, err := parser.Parse([]string{\"gak\"})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"gak\", cli.Name)\n\t})\n}\n\nfunc TestInvalidDefaultErrors(t *testing.T) {\n\tvar cli struct {\n\t\tFlag int `kong:\"default='foo'\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.Error(t, err)\n}\n\nfunc TestCommandMissingTagIsInvalid(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct{}\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestDuplicateFlag(t *testing.T) {\n\tvar cli struct {\n\t\tFlag bool\n\t\tCmd  struct {\n\t\t\tFlag bool\n\t\t} `kong:\"cmd\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestDuplicateFlagOnPeerCommandIsOkay(t *testing.T) {\n\tvar cli struct {\n\t\tCmd1 struct {\n\t\t\tFlag bool\n\t\t} `kong:\"cmd\"`\n\t\tCmd2 struct {\n\t\t\tFlag bool\n\t\t} `kong:\"cmd\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.NoError(t, err)\n}\n\nfunc TestTraceErrorPartiallySucceeds(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tTwo struct {\n\t\t\t} `kong:\"cmd\"`\n\t\t} `kong:\"cmd\"`\n\t}\n\tp := mustNew(t, &cli)\n\tctx, err := kong.Trace(p, []string{\"one\", \"bad\"})\n\tassert.NoError(t, err)\n\tassert.Error(t, ctx.Error)\n\tassert.Equal(t, \"one\", ctx.Command())\n}\n\ntype commandWithNegatableFlag struct {\n\tFlag   bool `kong:\"default='true',negatable\"`\n\tCustom bool `kong:\"default='true',negatable='standard'\"`\n\tran    bool\n}\n\nfunc (c *commandWithNegatableFlag) Run() error {\n\tc.ran = true\n\treturn nil\n}\n\nfunc TestNegatableFlag(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\targs           []string\n\t\texpectedFlag   bool\n\t\texpectedCustom bool\n\t}{\n\t\t{\n\t\t\tname:           \"no flag\",\n\t\t\targs:           []string{\"cmd\"},\n\t\t\texpectedFlag:   true,\n\t\t\texpectedCustom: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"boolean flag\",\n\t\t\targs:           []string{\"cmd\", \"--flag\"},\n\t\t\texpectedFlag:   true,\n\t\t\texpectedCustom: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"custom boolean flag\",\n\t\t\targs:           []string{\"cmd\", \"--custom\"},\n\t\t\texpectedFlag:   true,\n\t\t\texpectedCustom: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"inverted boolean flag\",\n\t\t\targs:           []string{\"cmd\", \"--flag=false\"},\n\t\t\texpectedFlag:   false,\n\t\t\texpectedCustom: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"custom inverted boolean flag\",\n\t\t\targs:           []string{\"cmd\", \"--custom=false\"},\n\t\t\texpectedFlag:   true,\n\t\t\texpectedCustom: false,\n\t\t},\n\t\t{\n\t\t\tname:           \"negated boolean flag\",\n\t\t\targs:           []string{\"cmd\", \"--no-flag\"},\n\t\t\texpectedFlag:   false,\n\t\t\texpectedCustom: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"custom negated boolean flag\",\n\t\t\targs:           []string{\"cmd\", \"--standard\"},\n\t\t\texpectedFlag:   true,\n\t\t\texpectedCustom: false,\n\t\t},\n\t\t{\n\t\t\tname:           \"inverted negated boolean flag\",\n\t\t\targs:           []string{\"cmd\", \"--no-flag=false\"},\n\t\t\texpectedFlag:   true,\n\t\t\texpectedCustom: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"inverted custom negated boolean flag\",\n\t\t\targs:           []string{\"cmd\", \"--standard=false\"},\n\t\t\texpectedFlag:   true,\n\t\t\texpectedCustom: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar cli struct {\n\t\t\t\tCmd commandWithNegatableFlag `kong:\"cmd\"`\n\t\t\t}\n\n\t\t\tp := mustNew(t, &cli)\n\t\t\tkctx, err := p.Parse(tt.args)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tt.expectedFlag, cli.Cmd.Flag)\n\t\t\tassert.Equal(t, tt.expectedCustom, cli.Cmd.Custom)\n\n\t\t\terr = kctx.Run()\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tt.expectedFlag, cli.Cmd.Flag)\n\t\t\tassert.Equal(t, tt.expectedCustom, cli.Cmd.Custom)\n\t\t\tassert.True(t, cli.Cmd.ran)\n\t\t})\n\t}\n}\n\nfunc TestDuplicateNegatableLong(t *testing.T) {\n\tcli2 := struct {\n\t\tNoFlag bool\n\t\tFlag   bool `negatable:\"\"` // negation duplicates NoFlag\n\t}{}\n\t_, err := kong.New(&cli2)\n\tassert.EqualError(t, err, \"<anonymous struct>.Flag: duplicate negation flag --no-flag\")\n\n\tcli3 := struct {\n\t\tOne bool\n\t\tTwo bool `negatable:\"one\"` // negation duplicates Flag2\n\t}{}\n\t_, err = kong.New(&cli3)\n\tassert.EqualError(t, err, \"<anonymous struct>.Two: duplicate negation flag --one\")\n}\n\nfunc TestDuplicateNegatableFlagsInSubcommands(t *testing.T) {\n\tcli2 := struct {\n\t\tSub struct {\n\t\t\tNegated bool `negatable:\"nope-\"`\n\t\t} `cmd:\"\"`\n\t\tSub2 struct {\n\t\t\tNegated bool `negatable:\"nope-\"`\n\t\t} `cmd:\"\"`\n\t}{}\n\t_, err := kong.New(&cli2)\n\tassert.NoError(t, err)\n}\n\nfunc TestExistingNoFlag(t *testing.T) {\n\tvar cli struct {\n\t\tCmd struct {\n\t\t\tFlag   bool `kong:\"default='true'\"`\n\t\t\tNoFlag string\n\t\t} `kong:\"cmd\"`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"cmd\", \"--no-flag=none\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, cli.Cmd.Flag)\n\tassert.Equal(t, \"none\", cli.Cmd.NoFlag)\n}\n\nfunc TestInvalidNegatedNonBool(t *testing.T) {\n\tvar cli struct {\n\t\tCmd struct {\n\t\t\tFlag string `kong:\"negatable\"`\n\t\t} `kong:\"cmd\"`\n\t}\n\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\ntype hookContext struct {\n\tcmd    bool\n\tvalues []string\n}\n\ntype hookValue string\n\nfunc (h *hookValue) BeforeApply(ctx *hookContext) error {\n\tctx.values = append(ctx.values, \"before:\"+string(*h))\n\treturn nil\n}\n\nfunc (h *hookValue) AfterApply(ctx *hookContext) error {\n\tctx.values = append(ctx.values, \"after:\"+string(*h))\n\treturn nil\n}\n\ntype hookCmd struct {\n\tTwo   hookValue `kong:\"arg,optional\"`\n\tThree hookValue\n}\n\nfunc (h *hookCmd) BeforeApply(ctx *hookContext) error {\n\tctx.cmd = true\n\treturn nil\n}\n\nfunc (h *hookCmd) AfterApply(ctx *hookContext) error {\n\tctx.cmd = true\n\treturn nil\n}\n\nfunc TestHooks(t *testing.T) {\n\tvar tests = []struct {\n\t\tname   string\n\t\tinput  string\n\t\tvalues hookContext\n\t}{\n\t\t{\"Command\", \"one\", hookContext{true, nil}},\n\t\t{\"Arg\", \"one two\", hookContext{true, []string{\"before:\", \"after:two\"}}},\n\t\t{\"Flag\", \"one --three=THREE\", hookContext{true, []string{\"before:\", \"after:THREE\"}}},\n\t\t{\"ArgAndFlag\", \"one two --three=THREE\", hookContext{true, []string{\"before:\", \"before:\", \"after:two\", \"after:THREE\"}}},\n\t}\n\n\tvar cli struct {\n\t\tOne hookCmd `cmd:\"\"`\n\t}\n\n\tctx := &hookContext{}\n\tp := mustNew(t, &cli, kong.Bind(ctx))\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\t*ctx = hookContext{}\n\t\tcli.One = hookCmd{}\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := p.Parse(strings.Split(test.input, \" \"))\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, &test.values, ctx)\n\t\t})\n\t}\n}\n\nfunc TestShort(t *testing.T) {\n\tvar cli struct {\n\t\tBool   bool   `short:\"b\"`\n\t\tString string `short:\"s\"`\n\t}\n\tapp := mustNew(t, &cli)\n\t_, err := app.Parse([]string{\"-b\", \"-shello\"})\n\tassert.NoError(t, err)\n\tassert.True(t, cli.Bool)\n\tassert.Equal(t, \"hello\", cli.String)\n}\n\nfunc TestAlias(t *testing.T) {\n\tvar cli struct {\n\t\tString string `aliases:\"str\"`\n\t}\n\tapp := mustNew(t, &cli)\n\t_, err := app.Parse([]string{\"--str\", \"hello\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"hello\", cli.String)\n}\n\nfunc TestDuplicateFlagChoosesLast(t *testing.T) {\n\tvar cli struct {\n\t\tFlag int\n\t}\n\n\t_, err := mustNew(t, &cli).Parse([]string{\"--flag=1\", \"--flag=2\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 2, cli.Flag)\n}\n\nfunc TestDuplicateSliceAccumulates(t *testing.T) {\n\tvar cli struct {\n\t\tFlag []int\n\t}\n\n\targs := []string{\"--flag=1,2\", \"--flag=3,4\"}\n\t_, err := mustNew(t, &cli).Parse(args)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int{1, 2, 3, 4}, cli.Flag)\n}\n\nfunc TestMapFlag(t *testing.T) {\n\tvar cli struct {\n\t\tSet map[string]int\n\t}\n\t_, err := mustNew(t, &cli).Parse([]string{\"--set\", \"a=10\", \"--set\", \"b=20\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string]int{\"a\": 10, \"b\": 20}, cli.Set)\n}\n\nfunc TestMapFlagWithSliceValue(t *testing.T) {\n\tvar cli struct {\n\t\tSet map[string][]int\n\t}\n\t_, err := mustNew(t, &cli).Parse([]string{\"--set\", \"a=1,2\", \"--set\", \"b=3\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string][]int{\"a\": {1, 2}, \"b\": {3}}, cli.Set)\n}\n\ntype embeddedFlags struct {\n\tEmbedded string\n}\n\nfunc TestEmbeddedStruct(t *testing.T) {\n\tvar cli struct {\n\t\tembeddedFlags\n\t\tNotEmbedded string\n\t}\n\n\t_, err := mustNew(t, &cli).Parse([]string{\"--embedded=moo\", \"--not-embedded=foo\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"moo\", cli.Embedded)\n\tassert.Equal(t, \"foo\", cli.NotEmbedded)\n}\n\nfunc TestSliceWithDisabledSeparator(t *testing.T) {\n\tvar cli struct {\n\t\tFlag []string `sep:\"none\"`\n\t}\n\t_, err := mustNew(t, &cli).Parse([]string{\"--flag=a,b\", \"--flag=b,c\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"a,b\", \"b,c\"}, cli.Flag)\n}\n\nfunc TestMultilineMessage(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ttext string\n\t\twant string\n\t}{\n\t\t{\"Simple\", \"hello\\nworld\", \"test: hello\\n      world\\n\"},\n\t\t{\"WithNewline\", \"hello\\nworld\\n\", \"test: hello\\n      world\\n\"},\n\t}\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tw := &bytes.Buffer{}\n\t\t\tvar cli struct{}\n\t\t\tp := mustNew(t, &cli, kong.Writers(w, w))\n\t\t\tp.Printf(\"%s\", test.text)\n\t\t\tassert.Equal(t, test.want, w.String())\n\t\t})\n\t}\n}\n\ntype cmdWithRun struct {\n\tArg string `arg:\"\"`\n}\n\nfunc (c *cmdWithRun) Run(key string) error {\n\tc.Arg += key\n\tif key == \"ERROR\" {\n\t\treturn fmt.Errorf(\"ERROR\")\n\t}\n\treturn nil\n}\n\ntype parentCmdWithRun struct {\n\tFlag       string\n\tSubCommand struct {\n\t\tArg string `arg:\"\"`\n\t} `cmd:\"\"`\n}\n\nfunc (p *parentCmdWithRun) Run(key string) error {\n\tp.SubCommand.Arg += key\n\treturn nil\n}\n\ntype grammarWithRun struct {\n\tOne   cmdWithRun       `cmd:\"\"`\n\tTwo   cmdWithRun       `cmd:\"\"`\n\tThree parentCmdWithRun `cmd:\"\"`\n}\n\nfunc TestRun(t *testing.T) {\n\tcli := &grammarWithRun{}\n\tp := mustNew(t, cli)\n\n\tctx, err := p.Parse([]string{\"one\", \"two\"})\n\tassert.NoError(t, err)\n\terr = ctx.Run(\"hello\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"twohello\", cli.One.Arg)\n\n\tctx, err = p.Parse([]string{\"two\", \"three\"})\n\tassert.NoError(t, err)\n\terr = ctx.Run(\"ERROR\")\n\tassert.Error(t, err)\n\n\tctx, err = p.Parse([]string{\"three\", \"sub-command\", \"arg\"})\n\tassert.NoError(t, err)\n\terr = ctx.Run(\"ping\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"argping\", cli.Three.SubCommand.Arg)\n}\n\ntype failCmd struct{}\n\nfunc (f failCmd) Run() error {\n\treturn errors.New(\"this command failed\")\n}\n\nfunc TestPassesThroughOriginalCommandError(t *testing.T) {\n\tvar cli struct {\n\t\tFail failCmd `kong:\"cmd\"`\n\t}\n\tp := mustNew(t, &cli)\n\tctx, _ := p.Parse([]string{\"fail\"})\n\terr := ctx.Run()\n\tassert.Error(t, err)\n\tassert.Equal(t, err.Error(), \"this command failed\")\n}\n\nfunc TestInterpolationIntoModel(t *testing.T) {\n\tvar cli struct {\n\t\tFlag    string `default:\"${default_value}\" help:\"Help, I need ${somebody}\" enum:\"${enum}\"`\n\t\tEnumRef string `enum:\"a,b\" required:\"\" help:\"One of ${enum}\"`\n\t\tEnvRef  string `env:\"${env}\" help:\"God ${env}\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n\tp, err := kong.New(&cli, kong.Vars{\n\t\t\"default_value\": \"Some default value.\",\n\t\t\"somebody\":      \"chickens!\",\n\t\t\"enum\":          \"a,b,c,d\",\n\t\t\"env\":           \"SAVE_THE_QUEEN\",\n\t})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 4, len(p.Model.Flags))\n\tflag := p.Model.Flags[1]\n\tflag2 := p.Model.Flags[2]\n\tflag3 := p.Model.Flags[3]\n\tassert.Equal(t, \"Some default value.\", flag.Default)\n\tassert.Equal(t, \"Help, I need chickens!\", flag.Help)\n\tassert.Equal(t, map[string]bool{\"a\": true, \"b\": true, \"c\": true, \"d\": true}, flag.EnumMap())\n\tassert.Equal(t, []string{\"a\", \"b\", \"c\", \"d\"}, flag.EnumSlice())\n\tassert.Equal(t, \"One of a,b\", flag2.Help)\n\tassert.Equal(t, []string{\"SAVE_THE_QUEEN\"}, flag3.Envs)\n\tassert.Equal(t, \"God SAVE_THE_QUEEN\", flag3.Help)\n}\n\nfunc TestIssue244(t *testing.T) {\n\ttype Config struct {\n\t\tProject string `short:\"p\" env:\"CI_PROJECT_ID\" help:\"Environment variable: ${env}\"`\n\t}\n\tw := &strings.Builder{}\n\tk := mustNew(t, &Config{}, kong.Exit(func(int) {}), kong.Writers(w, w))\n\t_, err := k.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, w.String(), `Environment variable: CI_PROJECT_ID`)\n}\n\nfunc TestErrorMissingArgs(t *testing.T) {\n\tvar cli struct {\n\t\tOne string `arg:\"\"`\n\t\tTwo string `arg:\"\"`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.Error(t, err)\n\tassert.Equal(t, \"expected \\\"<one> <two>\\\"\", err.Error())\n}\n\nfunc TestBoolOverride(t *testing.T) {\n\tvar cli struct {\n\t\tFlag bool `default:\"true\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--flag=false\"})\n\tassert.NoError(t, err)\n\t_, err = p.Parse([]string{\"--flag\", \"false\"})\n\tassert.Error(t, err)\n}\n\nfunc TestAnonymousPrefix(t *testing.T) {\n\ttype Anonymous struct {\n\t\tFlag string\n\t}\n\tvar cli struct {\n\t\tAnonymous `prefix:\"anon-\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--anon-flag=moo\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"moo\", cli.Flag)\n}\n\ntype TestInterface interface {\n\tSomeMethod()\n}\n\ntype TestImpl struct {\n\tFlag string\n}\n\nfunc (t *TestImpl) SomeMethod() {}\n\nfunc TestEmbedInterface(t *testing.T) {\n\ttype CLI struct {\n\t\tSomeFlag string\n\t\tTestInterface\n\t}\n\tcli := &CLI{TestInterface: &TestImpl{}}\n\tp := mustNew(t, cli)\n\t_, err := p.Parse([]string{\"--some-flag=foo\", \"--flag=yes\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foo\", cli.SomeFlag)\n\tassert.Equal(t, \"yes\", cli.TestInterface.(*TestImpl).Flag) //nolint\n}\n\nfunc TestExcludedField(t *testing.T) {\n\tvar cli struct {\n\t\tFlag     string\n\t\tExcluded string `kong:\"-\"`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--flag=foo\"})\n\tassert.NoError(t, err)\n\t_, err = p.Parse([]string{\"--excluded=foo\"})\n\tassert.Error(t, err)\n}\n\nfunc TestUnnamedFieldEmbeds(t *testing.T) {\n\ttype Embed struct {\n\t\tFlag string\n\t}\n\tvar cli struct {\n\t\tOne Embed `prefix:\"one-\" embed:\"\"`\n\t\tTwo Embed `prefix:\"two-\" embed:\"\"`\n\t}\n\tbuf := &strings.Builder{}\n\tp := mustNew(t, &cli, kong.Writers(buf, buf), kong.Exit(func(int) {}))\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, buf.String(), `--one-flag=STRING`)\n\tassert.Contains(t, buf.String(), `--two-flag=STRING`)\n}\n\nfunc TestHooksCalledForDefault(t *testing.T) {\n\tvar cli struct {\n\t\tFlag hookValue `default:\"default\"`\n\t}\n\n\tctx := &hookContext{}\n\t_, err := mustNew(t, &cli, kong.Bind(ctx)).Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"default\", string(cli.Flag))\n\tassert.Equal(t, []string{\"before:default\", \"after:default\"}, ctx.values)\n}\n\nfunc TestEnum(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `enum:\"a,b,c\" required:\"\"`\n\t}\n\t_, err := mustNew(t, &cli).Parse([]string{\"--flag\", \"d\"})\n\tassert.EqualError(t, err, \"--flag must be one of \\\"a\\\",\\\"b\\\",\\\"c\\\" but got \\\"d\\\"\")\n}\n\nfunc TestEnumMeaningfulOrder(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `enum:\"first,second,third,fourth,fifth\" required:\"\"`\n\t}\n\t_, err := mustNew(t, &cli).Parse([]string{\"--flag\", \"sixth\"})\n\tassert.EqualError(t, err, \"--flag must be one of \\\"first\\\",\\\"second\\\",\\\"third\\\",\\\"fourth\\\",\\\"fifth\\\" but got \\\"sixth\\\"\")\n}\n\ntype commandWithHook struct {\n\tvalue string\n}\n\nfunc (c *commandWithHook) AfterApply(cli *cliWithHook) error {\n\tc.value = cli.Flag\n\treturn nil\n}\n\ntype cliWithHook struct {\n\tFlag    string\n\tCommand commandWithHook `cmd:\"\"`\n}\n\nfunc (c *cliWithHook) AfterApply(ctx *kong.Context) error {\n\tctx.Bind(c)\n\treturn nil\n}\n\nfunc TestParentBindings(t *testing.T) {\n\tcli := &cliWithHook{}\n\t_, err := mustNew(t, cli).Parse([]string{\"command\", \"--flag=foo\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foo\", cli.Command.value)\n}\n\nfunc TestNumericParamErrors(t *testing.T) {\n\tvar cli struct {\n\t\tName string\n\t}\n\tparser := mustNew(t, &cli)\n\t_, err := parser.Parse([]string{\"--name\", \"-10\"})\n\tassert.EqualError(t, err, `--name: expected string value but got \"-10\" (short flag); perhaps try --name=\"-10\"?`)\n}\n\nfunc TestDefaultValueIsHyphen(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `default:\"-\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"-\", cli.Flag)\n}\n\nfunc TestDefaultEnumValidated(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `default:\"invalid\" enum:\"valid\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.EqualError(t, err, \"--flag must be one of \\\"valid\\\" but got \\\"invalid\\\"\")\n}\n\nfunc TestEnvarEnumValidated(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `env:\"FLAG\" required:\"\" enum:\"valid\"`\n\t}\n\tp := newEnvParser(t, &cli, envMap{\n\t\t\"FLAG\": \"invalid\",\n\t})\n\t_, err := p.Parse(nil)\n\tassert.EqualError(t, err, \"--flag must be one of \\\"valid\\\" but got \\\"invalid\\\"\")\n}\n\nfunc TestXor(t *testing.T) {\n\tvar cli struct {\n\t\tHello bool   `xor:\"another\"`\n\t\tOne   bool   `xor:\"group\"`\n\t\tTwo   string `xor:\"group\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--hello\", \"--one\", \"--two=hi\"})\n\tassert.EqualError(t, err, \"--one and --two can't be used together\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--one\", \"--hello\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestAnd(t *testing.T) {\n\tvar cli struct {\n\t\tHello bool   `and:\"another\"`\n\t\tOne   bool   `and:\"group\"`\n\t\tTwo   string `and:\"group\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--hello\", \"--one\"})\n\tassert.EqualError(t, err, \"--one and --two must be used together\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--one\", \"--two=hi\", \"--hello\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestXorChild(t *testing.T) {\n\tvar cli struct {\n\t\tOne bool `xor:\"group\"`\n\t\tCmd struct {\n\t\t\tTwo   string `xor:\"group\"`\n\t\t\tThree string `xor:\"group\"`\n\t\t} `cmd`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--one\", \"cmd\", \"--two=hi\"})\n\tassert.NoError(t, err)\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--two=hi\", \"cmd\", \"--three\"})\n\tassert.Error(t, err, \"--two and --three can't be used together\")\n}\n\nfunc TestAndChild(t *testing.T) {\n\tvar cli struct {\n\t\tOne bool `and:\"group\"`\n\t\tCmd struct {\n\t\t\tTwo   string `and:\"group\"`\n\t\t\tThree string `and:\"group\"`\n\t\t} `cmd`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--one\", \"cmd\", \"--two=hi\", \"--three=hello\"})\n\tassert.NoError(t, err)\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--two=hi\", \"cmd\"})\n\tassert.Error(t, err, \"--two and --three must be used together\")\n}\n\nfunc TestMultiXor(t *testing.T) {\n\tvar cli struct {\n\t\tHello bool   `xor:\"one,two\"`\n\t\tOne   bool   `xor:\"one\"`\n\t\tTwo   string `xor:\"two\"`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--hello\", \"--one\"})\n\tassert.EqualError(t, err, \"--hello and --one can't be used together\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--hello\", \"--two=foo\"})\n\tassert.EqualError(t, err, \"--hello and --two can't be used together\")\n}\n\nfunc TestMultiAnd(t *testing.T) {\n\tvar cli struct {\n\t\tHello bool   `and:\"one,two\"`\n\t\tOne   bool   `and:\"one\"`\n\t\tTwo   string `and:\"two\"`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--hello\"})\n\t// Split and combine error so messages always will be in the same order\n\t// when testing\n\tmissingMsgs := strings.Split(err.Error(), \", \")\n\tsort.Strings(missingMsgs)\n\terr = fmt.Errorf(\"%s\", strings.Join(missingMsgs, \", \"))\n\tassert.EqualError(t, err, \"--hello and --one must be used together, --hello and --two must be used together\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--two=foo\"})\n\tassert.EqualError(t, err, \"--hello and --two must be used together\")\n}\n\nfunc TestXorAnd(t *testing.T) {\n\tvar cli struct {\n\t\tHello bool   `xor:\"one\" and:\"two\"`\n\t\tOne   bool   `xor:\"one\"`\n\t\tTwo   string `and:\"two\"`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--hello\"})\n\tassert.EqualError(t, err, \"--hello and --two must be used together\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--one\"})\n\tassert.NoError(t, err)\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--hello\", \"--one\"})\n\tassert.EqualError(t, err, \"--hello and --one can't be used together, --hello and --two must be used together\")\n}\n\nfunc TestOverLappingXorAnd(t *testing.T) {\n\tvar cli struct {\n\t\tHello bool   `xor:\"one\" and:\"two\"`\n\t\tOne   bool   `xor:\"one\" and:\"two\"`\n\t\tTwo   string `xor:\"one\" and:\"two\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"invalid xor and combination, one and two overlap with more than one: [hello one two]\")\n}\n\nfunc TestXorRequired(t *testing.T) {\n\tvar cli struct {\n\t\tOne   bool `xor:\"one,two\" required:\"\"`\n\t\tTwo   bool `xor:\"one\" required:\"\"`\n\t\tThree bool `xor:\"two\" required:\"\"`\n\t\tFour  bool `required:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--one\"})\n\tassert.EqualError(t, err, \"missing flags: --four\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--two\"})\n\tassert.EqualError(t, err, \"missing flags: --four, --one or --three\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{})\n\tassert.EqualError(t, err, \"missing flags: --four, --one or --three, --one or --two\")\n}\n\nfunc TestAndRequired(t *testing.T) {\n\tvar cli struct {\n\t\tOne   bool `and:\"one,two\" required:\"\"`\n\t\tTwo   bool `and:\"one\" required:\"\"`\n\t\tThree bool `and:\"two\"`\n\t\tFour  bool `required:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--one\", \"--two\", \"--three\"})\n\tassert.EqualError(t, err, \"missing flags: --four\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--four\"})\n\tassert.EqualError(t, err, \"missing flags: --one and --three, --one and --two\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{})\n\tassert.EqualError(t, err, \"missing flags: --four, --one and --three, --one and --two\")\n}\n\nfunc TestXorRequiredMany(t *testing.T) {\n\tvar cli struct {\n\t\tOne   bool `xor:\"one\" required:\"\"`\n\t\tTwo   bool `xor:\"one\" required:\"\"`\n\t\tThree bool `xor:\"one\" required:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--one\"})\n\tassert.NoError(t, err)\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--three\"})\n\tassert.NoError(t, err)\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{})\n\tassert.EqualError(t, err, \"missing flags: --one or --two or --three\")\n}\n\nfunc TestAndRequiredMany(t *testing.T) {\n\tvar cli struct {\n\t\tOne   bool `and:\"one\" required:\"\"`\n\t\tTwo   bool `and:\"one\" required:\"\"`\n\t\tThree bool `and:\"one\" required:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{})\n\tassert.EqualError(t, err, \"missing flags: --one and --two and --three\")\n\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--three\"})\n\tassert.EqualError(t, err, \"missing flags: --one and --two\")\n}\n\nfunc TestEnumSequence(t *testing.T) {\n\tvar cli struct {\n\t\tState []string `enum:\"a,b,c\" default:\"a\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"a\"}, cli.State)\n}\n\nfunc TestIssue40EnumAcrossCommands(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tOneArg string `arg:\"\" required:\"\"`\n\t\t} `cmd:\"\"`\n\t\tTwo struct {\n\t\t\tTwoArg string `arg:\"\" enum:\"a,b,c\" required:\"\" env:\"FOO\"`\n\t\t} `cmd:\"\"`\n\t\tThree struct {\n\t\t\tThreeArg string `arg:\"\" optional:\"\" default:\"a\" enum:\"a,b,c\"`\n\t\t} `cmd:\"\"`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"one\", \"two\"})\n\tassert.NoError(t, err)\n\t_, err = p.Parse([]string{\"two\", \"d\"})\n\tassert.Error(t, err)\n\t_, err = p.Parse([]string{\"three\", \"d\"})\n\tassert.Error(t, err)\n\t_, err = p.Parse([]string{\"three\", \"c\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestIssue179(t *testing.T) {\n\ttype A struct {\n\t\tEnum string `required:\"\" enum:\"1,2\"`\n\t}\n\n\ttype B struct{}\n\n\tvar root struct {\n\t\tA A `cmd`\n\t\tB B `cmd`\n\t}\n\n\tp := mustNew(t, &root)\n\t_, err := p.Parse([]string{\"b\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestIssue153(t *testing.T) {\n\ttype LsCmd struct {\n\t\tPaths []string `arg required name:\"path\" help:\"Paths to list.\" env:\"CMD_PATHS\"`\n\t}\n\n\tvar cli struct {\n\t\tDebug bool `help:\"Enable debug mode.\"`\n\n\t\tLs LsCmd `cmd help:\"List paths.\"`\n\t}\n\n\tp := newEnvParser(t, &cli, envMap{\n\t\t\"CMD_PATHS\": \"hello\",\n\t})\n\t_, err := p.Parse([]string{\"ls\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"hello\"}, cli.Ls.Paths)\n}\n\nfunc TestEnumArg(t *testing.T) {\n\tvar cli struct {\n\t\tNested struct {\n\t\t\tOne string `arg:\"\" enum:\"a,b,c\" required:\"\"`\n\t\t\tTwo string `arg:\"\"`\n\t\t} `cmd:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"nested\", \"a\", \"b\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"a\", cli.Nested.One)\n\tassert.Equal(t, \"b\", cli.Nested.Two)\n}\n\nfunc TestDefaultCommand(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct{} `cmd:\"\" default:\"1\"`\n\t\tTwo struct{} `cmd:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\tctx, err := p.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"one\", ctx.Command())\n}\n\nfunc TestMultipleDefaultCommands(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct{} `cmd:\"\" default:\"1\"`\n\t\tTwo struct{} `cmd:\"\" default:\"1\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"<anonymous struct>.Two: can't have more than one default command under  <command>\")\n}\n\nfunc TestDefaultCommandWithSubCommand(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tTwo struct{} `cmd:\"\"`\n\t\t} `cmd:\"\" default:\"1\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"<anonymous struct>.One: default command one <command> must not have subcommands or arguments\")\n}\n\nfunc TestDefaultCommandWithAllowedSubCommand(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tTwo struct{} `cmd:\"\"`\n\t\t} `cmd:\"\" default:\"withargs\"`\n\t}\n\tp := mustNew(t, &cli)\n\tctx, err := p.Parse([]string{\"two\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"one two\", ctx.Command())\n}\n\nfunc TestDefaultCommandWithArgument(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tArg string `arg:\"\"`\n\t\t} `cmd:\"\" default:\"1\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"<anonymous struct>.One: default command one <arg> must not have subcommands or arguments\")\n}\n\nfunc TestDefaultCommandWithAllowedArgument(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tArg  string `arg:\"\"`\n\t\t\tFlag string\n\t\t} `cmd:\"\" default:\"withargs\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"arg\", \"--flag=value\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"arg\", cli.One.Arg)\n\tassert.Equal(t, \"value\", cli.One.Flag)\n}\n\nfunc TestDefaultCommandWithBranchingArgument(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tTwo struct {\n\t\t\t\tTwo string `arg:\"\"`\n\t\t\t} `arg:\"\"`\n\t\t} `cmd:\"\" default:\"1\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"<anonymous struct>.One: default command one <command> must not have subcommands or arguments\")\n}\n\nfunc TestDefaultCommandWithAllowedBranchingArgument(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tTwo struct {\n\t\t\t\tTwo  string `arg:\"\"`\n\t\t\t\tFlag string\n\t\t\t} `arg:\"\"`\n\t\t} `cmd:\"\" default:\"withargs\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"arg\", \"--flag=value\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"arg\", cli.One.Two.Two)\n\tassert.Equal(t, \"value\", cli.One.Two.Flag)\n}\n\nfunc TestDefaultCommandPrecedence(t *testing.T) {\n\tvar cli struct {\n\t\tTwo struct {\n\t\t\tArg  string `arg:\"\"`\n\t\t\tFlag bool\n\t\t} `cmd:\"\" default:\"withargs\"`\n\t\tOne struct{} `cmd:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\n\t// A named command should take precedence over a default command with arg\n\tctx, err := p.Parse([]string{\"one\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"one\", ctx.Command())\n\n\t// An explicitly named command with arg should parse, even if labeled default:\"witharg\"\n\tctx, err = p.Parse([]string{\"two\", \"arg\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"two <arg>\", ctx.Command())\n\n\t// An arg to a default command that does not match another command should select the default\n\tctx, err = p.Parse([]string{\"arg\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"two <arg>\", ctx.Command())\n\n\t// A flag on a default command should not be valid on a sibling command\n\t_, err = p.Parse([]string{\"one\", \"--flag\"})\n\tassert.EqualError(t, err, \"unknown flag --flag\")\n}\n\nfunc TestLoneHpyhen(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string\n\t\tArg  string `arg:\"\" optional:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\n\t_, err := p.Parse([]string{\"-\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"-\", cli.Arg)\n\n\t_, err = p.Parse([]string{\"--flag\", \"-\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"-\", cli.Flag)\n}\n\nfunc TestPlugins(t *testing.T) {\n\tvar pluginOne struct {\n\t\tOne string\n\t}\n\tvar pluginTwo struct {\n\t\tTwo string\n\t}\n\tvar cli struct {\n\t\tBase string\n\t\tkong.Plugins\n\t}\n\tcli.Plugins = kong.Plugins{&pluginOne, &pluginTwo}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--base=base\", \"--one=one\", \"--two=two\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"base\", cli.Base)\n\tassert.Equal(t, \"one\", pluginOne.One)\n\tassert.Equal(t, \"two\", pluginTwo.Two)\n}\n\ntype validateCmd struct{}\n\nfunc (v *validateCmd) Validate() error { return errors.New(\"cmd error\") }\n\ntype validateCli struct {\n\tCmd validateCmd `cmd:\"\"`\n}\n\nfunc (v *validateCli) Validate() error { return errors.New(\"app error\") }\n\ntype validateFlag string\n\nfunc (v *validateFlag) Validate() error { return errors.New(\"flag error\") }\n\nfunc TestValidateApp(t *testing.T) {\n\tcli := validateCli{}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{})\n\tassert.EqualError(t, err, \"app error\")\n}\n\nfunc TestValidateCmd(t *testing.T) {\n\tcli := struct {\n\t\tCmd validateCmd `cmd:\"\"`\n\t}{}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"cmd\"})\n\tassert.EqualError(t, err, \"cmd: cmd error\")\n}\n\nfunc TestValidateFlag(t *testing.T) {\n\tcli := struct {\n\t\tFlag validateFlag\n\t}{}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--flag=one\"})\n\tassert.EqualError(t, err, \"--flag: flag error\")\n}\n\nfunc TestValidateArg(t *testing.T) {\n\tcli := struct {\n\t\tArg validateFlag `arg:\"\"`\n\t}{}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"one\"})\n\tassert.EqualError(t, err, \"<arg>: flag error\")\n}\n\ntype extendedValidateFlag string\n\nfunc (v *extendedValidateFlag) Validate(kctx *kong.Context) error { return errors.New(\"flag error\") }\n\nfunc TestExtendedValidateFlag(t *testing.T) {\n\tcli := struct {\n\t\tFlag extendedValidateFlag\n\t}{}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--flag=one\"})\n\tassert.EqualError(t, err, \"--flag: flag error\")\n}\n\nfunc TestPointers(t *testing.T) {\n\tcli := struct {\n\t\tMapped *mappedValue\n\t\tJSON   *jsonUnmarshalerValue\n\t}{}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--mapped=mapped\", \"--json=\\\"foo\\\"\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.Mapped)\n\tassert.Equal(t, \"mapped\", cli.Mapped.decoded)\n\tassert.NotZero(t, cli.JSON)\n\tassert.Equal(t, \"FOO\", string(*cli.JSON))\n}\n\ntype dynamicCommand struct {\n\tFlag string\n\n\tran bool\n}\n\nfunc (d *dynamicCommand) Run() error {\n\td.ran = true\n\treturn nil\n}\n\ntype commandFunc func() error\n\nfunc (cf commandFunc) Run() error {\n\treturn cf()\n}\n\nfunc TestDynamicCommands(t *testing.T) {\n\tcli := struct {\n\t\tOne struct{} `cmd:\"one\"`\n\t}{}\n\thelp := &strings.Builder{}\n\ttwo := &dynamicCommand{}\n\tthree := &dynamicCommand{}\n\tfourRan := false\n\tfour := commandFunc(func() error { fourRan = true; return nil })\n\tp := mustNew(t, &cli,\n\t\tkong.DynamicCommand(\"two\", \"\", \"\", &two),\n\t\tkong.DynamicCommand(\"three\", \"\", \"\", three, \"hidden\"),\n\t\tkong.DynamicCommand(\"four\", \"\", \"\", &four),\n\t\tkong.Writers(help, help),\n\t\tkong.Exit(func(int) {}))\n\tkctx, err := p.Parse([]string{\"two\", \"--flag=flag\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"flag\", two.Flag)\n\tassert.False(t, two.ran)\n\terr = kctx.Run()\n\tassert.NoError(t, err)\n\tassert.True(t, two.ran)\n\n\tkctx, err = p.Parse([]string{\"four\"})\n\tassert.NoError(t, err)\n\tassert.False(t, fourRan)\n\terr = kctx.Run()\n\tassert.NoError(t, err)\n\tassert.True(t, fourRan)\n\n\t_, err = p.Parse([]string{\"--help\"})\n\tassert.EqualError(t, err, `expected one of \"one\", \"two\", \"four\"`)\n\tassert.NotContains(t, help.String(), \"three\", help.String())\n}\n\nfunc TestDuplicateShortflags(t *testing.T) {\n\tcli := struct {\n\t\tFlag1 bool `short:\"t\"`\n\t\tFlag2 bool `short:\"t\"`\n\t}{}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"<anonymous struct>.Flag2: duplicate short flag -t\")\n}\n\nfunc TestDuplicateAliases(t *testing.T) {\n\tcli1 := struct {\n\t\tFlag1 string `aliases:\"flag\"`\n\t\tFlag2 string `aliases:\"flag\"`\n\t}{}\n\t_, err := kong.New(&cli1)\n\tassert.EqualError(t, err, \"<anonymous struct>.Flag2: duplicate flag --flag\")\n}\n\nfunc TestSubCommandAliases(t *testing.T) {\n\ttype SubC struct {\n\t\tFlag1 string `aliases:\"flag\"`\n\t}\n\n\tcli1 := struct {\n\t\tSub1 SubC `cmd:\"sub1\"`\n\t\tSub2 SubC `cmd:\"sub2\"`\n\t}{}\n\n\t_, err := kong.New(&cli1)\n\tassert.NoError(t, err, \"dupe aliases shouldn't error if they're in separate sub commands\")\n}\n\nfunc TestDuplicateAliasLong(t *testing.T) {\n\tcli2 := struct {\n\t\tFlag  string ``\n\t\tFlag2 string `aliases:\"flag\"` // duplicates Flag\n\t}{}\n\t_, err := kong.New(&cli2)\n\tassert.EqualError(t, err, \"<anonymous struct>.Flag2: duplicate flag --flag\")\n}\n\nfunc TestDuplicateNestedShortFlags(t *testing.T) {\n\tcli := struct {\n\t\tFlag1 bool `short:\"t\"`\n\t\tCmd   struct {\n\t\t\tFlag2 bool `short:\"t\"`\n\t\t} `cmd:\"\"`\n\t}{}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"<anonymous struct>.Flag2: duplicate short flag -t\")\n}\n\nfunc TestHydratePointerCommandsAndEmbeds(t *testing.T) {\n\ttype cmd struct {\n\t\tFlag bool\n\t}\n\n\ttype embed struct {\n\t\tEmbed bool\n\t}\n\n\tvar cli struct {\n\t\tCmd   *cmd   `cmd:\"\"`\n\t\tEmbed *embed `embed:\"\"`\n\t}\n\n\tk := mustNew(t, &cli)\n\t_, err := k.Parse([]string{\"--embed\", \"cmd\", \"--flag\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, &cmd{Flag: true}, cli.Cmd)\n\tassert.Equal(t, &embed{Embed: true}, cli.Embed)\n}\n\n//nolint:revive\ntype testIgnoreFields struct {\n\tFoo struct {\n\t\tBar bool\n\t\tSub struct {\n\t\t\tSubFlag1     bool `kong:\"name=subflag1\"`\n\t\t\tXXX_SubFlag2 bool `kong:\"name=subflag2\"` //nolint:stylecheck\n\t\t} `kong:\"cmd\"`\n\t} `kong:\"cmd\"`\n\tXXX_Baz struct { //nolint:stylecheck\n\t\tBoo bool\n\t} `kong:\"cmd,name=baz\"`\n}\n\nfunc TestIgnoreRegex(t *testing.T) {\n\tcli := testIgnoreFields{}\n\n\tk, err := kong.New(&cli, kong.IgnoreFields(`.*\\.XXX_.+`))\n\tassert.NoError(t, err)\n\n\t_, err = k.Parse([]string{\"foo\", \"sub\"})\n\tassert.NoError(t, err)\n\n\t_, err = k.Parse([]string{\"foo\", \"sub\", \"--subflag1\"})\n\tassert.NoError(t, err)\n\n\t_, err = k.Parse([]string{\"foo\", \"sub\", \"--subflag2\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"unknown flag --subflag2\")\n\n\t_, err = k.Parse([]string{\"baz\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"unexpected argument baz\")\n}\n\n// Verify that passing a nil regex will work\nfunc TestIgnoreRegexEmpty(t *testing.T) {\n\tcli := testIgnoreFields{}\n\n\t_, err := kong.New(&cli, kong.IgnoreFields(\"\"))\n\tassert.Error(t, err)\n\tassert.Contains(t, \"regex input cannot be empty\", err.Error())\n}\n\ntype optionWithErr struct{}\n\nfunc (o *optionWithErr) Apply(k *kong.Kong) error {\n\treturn errors.New(\"option returned err\")\n}\n\nfunc TestOptionReturnsErr(t *testing.T) {\n\tcli := struct {\n\t\tTest bool\n\t}{}\n\n\toptWithError := &optionWithErr{}\n\n\t_, err := kong.New(cli, optWithError)\n\tassert.Error(t, err)\n\tassert.Equal(t, \"option returned err\", err.Error())\n}\n\nfunc TestEnumValidation(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tcli  any\n\t\tfail bool\n\t}{\n\t\t{\n\t\t\t\"Arg\",\n\t\t\t&struct {\n\t\t\t\tEnum string `arg:\"\" enum:\"one,two\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"RequiredArg\",\n\t\t\t&struct {\n\t\t\t\tEnum string `required:\"\" arg:\"\" enum:\"one,two\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"OptionalArg\",\n\t\t\t&struct {\n\t\t\t\tEnum string `optional:\"\" arg:\"\" enum:\"one,two\"`\n\t\t\t}{},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"RepeatedArgs\",\n\t\t\t&struct {\n\t\t\t\tEnum []string `arg:\"\" enum:\"one,two\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"RequiredRepeatedArgs\",\n\t\t\t&struct {\n\t\t\t\tEnum []string `required:\"\" arg:\"\" enum:\"one,two\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"OptionalRepeatedArgs\",\n\t\t\t&struct {\n\t\t\t\tEnum []string `optional:\"\" arg:\"\" enum:\"one,two\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"EnumWithEmptyDefault\",\n\t\t\t&struct {\n\t\t\t\tFlag string `enum:\"one,two,\" default:\"\"`\n\t\t\t}{},\n\t\t\tfalse,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := kong.New(test.cli)\n\t\t\tif test.fail {\n\t\t\t\tassert.Error(t, err, repr.String(test.cli))\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err, repr.String(test.cli))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPassthroughArgs(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\targs    []string\n\t\tflag    string\n\t\tcmdArgs []string\n\t}{\n\t\t{\n\t\t\t\"NoArgs\",\n\t\t\t[]string{},\n\t\t\t\"\",\n\t\t\t[]string(nil),\n\t\t},\n\t\t{\n\t\t\t\"RecognizedFlagAndArgs\",\n\t\t\t[]string{\"--flag\", \"foobar\", \"something\"},\n\t\t\t\"foobar\",\n\t\t\t[]string{\"something\"},\n\t\t},\n\t\t{\n\t\t\t\"DashDashBetweenArgs\",\n\t\t\t[]string{\"foo\", \"--\", \"bar\"},\n\t\t\t\"\",\n\t\t\t[]string{\"foo\", \"--\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\t\"DashDash\",\n\t\t\t[]string{\"--\", \"--flag\", \"foobar\"},\n\t\t\t\"\",\n\t\t\t[]string{\"--\", \"--flag\", \"foobar\"},\n\t\t},\n\t\t{\n\t\t\t\"UnrecognizedFlagAndArgs\",\n\t\t\t[]string{\"--unrecognized-flag\", \"something\"},\n\t\t\t\"\",\n\t\t\t[]string{\"--unrecognized-flag\", \"something\"},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar cli struct {\n\t\t\t\tFlag string\n\t\t\t\tArgs []string `arg:\"\" optional:\"\" passthrough:\"\"`\n\t\t\t}\n\t\t\tp := mustNew(t, &cli)\n\t\t\t_, err := p.Parse(test.args)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, test.flag, cli.Flag)\n\t\t\tassert.Equal(t, test.cmdArgs, cli.Args)\n\t\t})\n\t}\n}\n\nfunc TestPassthroughPartial(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string\n\t\tArgs []string `arg:\"\" optional:\"\" passthrough:\"partial\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--flag\", \"foobar\", \"something\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foobar\", cli.Flag)\n\tassert.Equal(t, []string{\"something\"}, cli.Args)\n\t_, err = p.Parse([]string{\"--invalid\", \"foobar\", \"something\"})\n\tassert.EqualError(t, err, \"unknown flag --invalid\")\n}\n\nfunc TestPassthroughAll(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string\n\t\tArgs []string `arg:\"\" optional:\"\" passthrough:\"all\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--flag\", \"foobar\", \"something\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foobar\", cli.Flag)\n\tassert.Equal(t, []string{\"something\"}, cli.Args)\n\t_, err = p.Parse([]string{\"--invalid\", \"foobar\", \"something\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"--invalid\", \"foobar\", \"something\"}, cli.Args)\n}\n\nfunc TestPassthroughCmd(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\targs    []string\n\t\tflag    string\n\t\tcmdArgs []string\n\t}{\n\t\t{\n\t\t\t\"Simple\",\n\t\t\t[]string{\"--flag\", \"foobar\", \"command\", \"something\"},\n\t\t\t\"foobar\",\n\t\t\t[]string{\"something\"},\n\t\t},\n\t\t{\n\t\t\t\"DashDash\",\n\t\t\t[]string{\"--flag\", \"foobar\", \"command\", \"--\", \"something\"},\n\t\t\t\"foobar\",\n\t\t\t[]string{\"--\", \"something\"},\n\t\t},\n\t\t{\n\t\t\t\"Flag\",\n\t\t\t[]string{\"command\", \"--flag\", \"foobar\"},\n\t\t\t\"\",\n\t\t\t[]string{\"--flag\", \"foobar\"},\n\t\t},\n\t\t{\n\t\t\t\"FlagAndFlag\",\n\t\t\t[]string{\"--flag\", \"foobar\", \"command\", \"--flag\", \"foobar\"},\n\t\t\t\"foobar\",\n\t\t\t[]string{\"--flag\", \"foobar\"},\n\t\t},\n\t\t{\n\t\t\t\"NoArgs\",\n\t\t\t[]string{\"--flag\", \"foobar\", \"command\"},\n\t\t\t\"foobar\",\n\t\t\t[]string(nil),\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar cli struct {\n\t\t\t\tFlag    string\n\t\t\t\tCommand struct {\n\t\t\t\t\tArgs []string `arg:\"\" optional:\"\"`\n\t\t\t\t} `cmd:\"\" passthrough:\"\"`\n\t\t\t}\n\t\t\tp := mustNew(t, &cli)\n\t\t\t_, err := p.Parse(test.args)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, test.flag, cli.Flag)\n\t\t\tassert.Equal(t, test.cmdArgs, cli.Command.Args)\n\t\t})\n\t}\n}\n\nfunc TestPassthroughCmdOnlyArgs(t *testing.T) {\n\tvar cli struct {\n\t\tCommand struct {\n\t\t\tFlag string\n\t\t\tArgs []string `arg:\"\" optional:\"\"`\n\t\t} `cmd:\"\" passthrough:\"\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"<anonymous struct>.Command: passthrough command command [<args> ...] [flags] must not have subcommands or flags\")\n}\n\nfunc TestPassthroughCmdOnlyStringArgs(t *testing.T) {\n\tvar cli struct {\n\t\tCommand struct {\n\t\t\tArgs []int `arg:\"\" optional:\"\"`\n\t\t} `cmd:\"\" passthrough:\"\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"<anonymous struct>.Command: passthrough command command [<args> ...] must contain exactly one positional argument of []string type\")\n}\n\nfunc TestHelpShouldStillWork(t *testing.T) {\n\ttype CLI struct {\n\t\tDir  string `type:\"existingdir\" default:\"missing-dir\"`\n\t\tFile string `type:\"existingfile\" default:\"testdata/missing.txt\"`\n\t}\n\tvar cli CLI\n\tw := &strings.Builder{}\n\tk := mustNew(t, &cli, kong.Writers(w, w))\n\trc := -1 // init nonzero to help assert help hook was called\n\tk.Exit = func(i int) {\n\t\trc = i\n\t}\n\t_, err := k.Parse([]string{\"--help\"})\n\tt.Log(w.String())\n\t// checking return code validates the help hook was called\n\tassert.Zero(t, rc)\n\t// allow for error propagation from other validation (only for the\n\t// sake of this test, due to the exit function not actually exiting the\n\t// program; errors will not propagate in the real world).\n\tassert.Error(t, err)\n}\n\nfunc TestVersionFlagShouldStillWork(t *testing.T) {\n\ttype CLI struct {\n\t\tDir     string `type:\"existingdir\" default:\"missing-dir\"`\n\t\tFile    string `type:\"existingfile\" default:\"testdata/missing.txt\"`\n\t\tVersion kong.VersionFlag\n\t}\n\tvar cli CLI\n\tw := &strings.Builder{}\n\tk := mustNew(t, &cli, kong.Writers(w, w))\n\trc := -1 // init nonzero to help assert help hook was called\n\tk.Exit = func(i int) {\n\t\trc = i\n\t}\n\t_, err := k.Parse([]string{\"--version\"})\n\tt.Log(w.String())\n\t// checking return code validates the help hook was called\n\tassert.Zero(t, rc)\n\t// allow for error propagation from other validation (only for the\n\t// sake of this test, due to the exit function not actually exiting the\n\t// program; errors will not propagate in the real world).\n\tassert.Error(t, err)\n}\n\nfunc TestSliceDecoderHelpfulErrorMsg(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tcli  any\n\t\targs []string\n\t\terr  string\n\t}{\n\t\t{\n\t\t\t\"DefaultRune\",\n\t\t\t&struct {\n\t\t\t\tStuff []string\n\t\t\t}{},\n\t\t\t[]string{\"--stuff\"},\n\t\t\t`--stuff: missing value, expecting \"<arg>,...\"`,\n\t\t},\n\t\t{\n\t\t\t\"SpecifiedRune\",\n\t\t\t&struct {\n\t\t\t\tStuff []string `sep:\",\"`\n\t\t\t}{},\n\t\t\t[]string{\"--stuff\"},\n\t\t\t`--stuff: missing value, expecting \"<arg>,...\"`,\n\t\t},\n\t\t{\n\t\t\t\"SpaceRune\",\n\t\t\t&struct {\n\t\t\t\tStuff []string `sep:\" \"`\n\t\t\t}{},\n\t\t\t[]string{\"--stuff\"},\n\t\t\t`--stuff: missing value, expecting \"<arg> ...\"`,\n\t\t},\n\t\t{\n\t\t\t\"OtherRune\",\n\t\t\t&struct {\n\t\t\t\tStuff []string `sep:\"_\"`\n\t\t\t}{},\n\t\t\t[]string{\"--stuff\"},\n\t\t\t`--stuff: missing value, expecting \"<arg>_...\"`,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tp := mustNew(t, test.cli)\n\t\t\t_, err := p.Parse(test.args)\n\t\t\tassert.EqualError(t, err, test.err)\n\t\t})\n\t}\n}\n\nfunc TestMapDecoderHelpfulErrorMsg(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tcli      any\n\t\targs     []string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"DefaultRune\",\n\t\t\t&struct {\n\t\t\t\tStuff map[string]int\n\t\t\t}{},\n\t\t\t[]string{\"--stuff\"},\n\t\t\t`--stuff: missing value, expecting \"<key>=<value>;...\"`,\n\t\t},\n\t\t{\n\t\t\t\"SpecifiedRune\",\n\t\t\t&struct {\n\t\t\t\tStuff map[string]int `mapsep:\";\"`\n\t\t\t}{},\n\t\t\t[]string{\"--stuff\"},\n\t\t\t`--stuff: missing value, expecting \"<key>=<value>;...\"`,\n\t\t},\n\t\t{\n\t\t\t\"SpaceRune\",\n\t\t\t&struct {\n\t\t\t\tStuff map[string]int `mapsep:\" \"`\n\t\t\t}{},\n\t\t\t[]string{\"--stuff\"},\n\t\t\t`--stuff: missing value, expecting \"<key>=<value> ...\"`,\n\t\t},\n\t\t{\n\t\t\t\"OtherRune\",\n\t\t\t&struct {\n\t\t\t\tStuff map[string]int `mapsep:\",\"`\n\t\t\t}{},\n\t\t\t[]string{\"--stuff\"},\n\t\t\t`--stuff: missing value, expecting \"<key>=<value>,...\"`,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tp := mustNew(t, test.cli)\n\t\t\t_, err := p.Parse(test.args)\n\t\t\tassert.EqualError(t, err, test.expected)\n\t\t})\n\t}\n}\n\nfunc TestDuplicateName(t *testing.T) {\n\tvar cli struct {\n\t\tDupA struct{} `cmd:\"\" name:\"duplicate\"`\n\t\tDupB struct{} `cmd:\"\" name:\"duplicate\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestDuplicateChildName(t *testing.T) {\n\tvar cli struct {\n\t\tA struct {\n\t\t\tDupA struct{} `cmd:\"\" name:\"duplicate\"`\n\t\t\tDupB struct{} `cmd:\"\" name:\"duplicate\"`\n\t\t} `cmd:\"\"`\n\t\tB struct{} `cmd:\"\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestChildNameCanBeDuplicated(t *testing.T) {\n\tvar cli struct {\n\t\tA struct {\n\t\t\tA struct{} `cmd:\"\" name:\"duplicateA\"`\n\t\t\tB struct{} `cmd:\"\" name:\"duplicateB\"`\n\t\t} `cmd:\"\" name:\"duplicateA\"`\n\t\tB struct{} `cmd:\"\" name:\"duplicateB\"`\n\t}\n\tmustNew(t, &cli)\n}\n\nfunc TestCumulativeArgumentLast(t *testing.T) {\n\tvar cli struct {\n\t\tArg1 string   `arg:\"\"`\n\t\tArg2 []string `arg:\"\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.NoError(t, err)\n}\n\nfunc TestCumulativeArgumentNotLast(t *testing.T) {\n\tvar cli struct {\n\t\tArg2 []string `arg:\"\"`\n\t\tArg1 string   `arg:\"\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestStringPointer(t *testing.T) {\n\tvar cli struct {\n\t\tFoo *string\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{\"--foo\", \"wtf\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.Foo)\n\tassert.Equal(t, \"wtf\", *cli.Foo)\n}\n\nfunc TestStringPointerNoValue(t *testing.T) {\n\tvar cli struct {\n\t\tFoo *string\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.Zero(t, cli.Foo)\n}\n\nfunc TestStringPointerDefault(t *testing.T) {\n\tvar cli struct {\n\t\tFoo *string `default:\"stuff\"`\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.Foo)\n\tassert.Equal(t, \"stuff\", *cli.Foo)\n}\n\nfunc TestStringPointerAliasNoValue(t *testing.T) {\n\ttype Foo string\n\tvar cli struct {\n\t\tF *Foo\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.Zero(t, cli.F)\n}\n\nfunc TestStringPointerAlias(t *testing.T) {\n\ttype Foo string\n\tvar cli struct {\n\t\tF *Foo\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{\"--f=value\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.F)\n\tassert.Equal(t, Foo(\"value\"), *cli.F)\n}\n\nfunc TestStringPointerEmptyValue(t *testing.T) {\n\tvar cli struct {\n\t\tF *string\n\t\tG *string\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{\"--f\", \"\", \"--g=\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.F)\n\tassert.NotZero(t, cli.G)\n\tassert.Equal(t, \"\", *cli.F)\n\tassert.Equal(t, \"\", *cli.G)\n}\n\nfunc TestIntPtr(t *testing.T) {\n\tvar cli struct {\n\t\tF *int\n\t\tG *int\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{\"--f=6\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.F)\n\tassert.Zero(t, cli.G)\n\tassert.Equal(t, 6, *cli.F)\n}\n\nfunc TestBoolPtr(t *testing.T) {\n\tvar cli struct {\n\t\tX *bool\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{\"--x\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.X)\n\tassert.Equal(t, true, *cli.X)\n}\n\nfunc TestBoolPtrFalse(t *testing.T) {\n\tvar cli struct {\n\t\tX *bool\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{\"--x=false\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.X)\n\tassert.Equal(t, false, *cli.X)\n}\n\nfunc TestBoolPtrNegated(t *testing.T) {\n\tvar cli struct {\n\t\tX *bool `negatable:\"\"`\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{\"--no-x\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.X)\n\tassert.Equal(t, false, *cli.X)\n}\n\nfunc TestNilNegatableBoolPtr(t *testing.T) {\n\tvar cli struct {\n\t\tX *bool `negatable:\"\"`\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.Zero(t, cli.X)\n}\n\nfunc TestBoolPtrNil(t *testing.T) {\n\tvar cli struct {\n\t\tX *bool\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.Zero(t, cli.X)\n}\n\nfunc TestUnsupportedPtr(t *testing.T) {\n\ttype Foo struct {\n\t\tx int //nolint\n\t\ty int //nolint\n\t}\n\n\tvar cli struct {\n\t\tF *Foo\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{\"--f=whatever\"})\n\tassert.Zero(t, ctx)\n\tassert.Error(t, err)\n\tassert.Equal(t, \"--f: cannot find mapper for kong_test.Foo\", err.Error())\n}\n\nfunc TestEnumPtr(t *testing.T) {\n\tvar cli struct {\n\t\tX *string `enum:\"A,B,C\" default:\"C\"`\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{\"--x=A\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.X)\n\tassert.Equal(t, \"A\", *cli.X)\n}\n\nfunc TestEnumPtrOmitted(t *testing.T) {\n\tvar cli struct {\n\t\tX *string `enum:\"A,B,C\" default:\"C\"`\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.NotZero(t, cli.X)\n\tassert.Equal(t, \"C\", *cli.X)\n}\n\nfunc TestEnumPtrOmittedNoDefault(t *testing.T) {\n\tvar cli struct {\n\t\tX *string `enum:\"A,B,C\"`\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\tassert.NotZero(t, k)\n\tctx, err := k.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, ctx)\n\tassert.Zero(t, cli.X)\n}\n\nfunc TestIntEnum(t *testing.T) {\n\tvar cli struct {\n\t\tEnum int `enum:\"1,2,3\" default:\"1\"`\n\t}\n\tk, err := kong.New(&cli)\n\tassert.NoError(t, err)\n\t_, err = k.Parse([]string{\"--enum=123\"})\n\tassert.EqualError(t, err, `--enum must be one of \"1\",\"2\",\"3\" but got \"123\"`)\n}\n\nfunc TestRecursiveVariableExpansion(t *testing.T) {\n\tvar cli struct {\n\t\tConfig string `type:\"path\" default:\"${config_file}\" help:\"Default: ${default}\"`\n\t}\n\tk := mustNew(t, &cli, kong.Vars{\"config_file\": \"/etc/config\"}, kong.Exit(func(int) {}))\n\tw := &strings.Builder{}\n\tk.Stderr = w\n\tk.Stdout = w\n\t_, err := k.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, w.String(), \"Default: /etc/config\")\n}\n\ntype afterRunCLI struct {\n\trunCalled      bool `kong:\"-\"`\n\tafterRunCalled bool `kong:\"-\"`\n}\n\nfunc (c *afterRunCLI) Run() error {\n\tc.runCalled = true\n\treturn nil\n}\n\nfunc (c *afterRunCLI) AfterRun() error {\n\tc.afterRunCalled = true\n\treturn nil\n}\n\nfunc TestAfterRun(t *testing.T) {\n\tvar cli afterRunCLI\n\tk := mustNew(t, &cli)\n\tkctx, err := k.Parse([]string{})\n\tassert.NoError(t, err)\n\terr = kctx.Run()\n\tassert.NoError(t, err)\n\tassert.Equal(t, afterRunCLI{runCalled: true, afterRunCalled: true}, cli)\n}\n\ntype ProvidedString string\n\ntype providerCLI struct {\n\tSub providerSubCommand `cmd:\"\"`\n}\n\ntype providerSubCommand struct{}\n\nfunc (p *providerCLI) ProvideFoo() (ProvidedString, error) {\n\treturn ProvidedString(\"foo\"), nil\n}\n\nfunc (p *providerSubCommand) Run(t *testing.T, ps ProvidedString) error {\n\tassert.Equal(t, ProvidedString(\"foo\"), ps)\n\treturn nil\n}\n\nfunc TestProviderMethods(t *testing.T) {\n\tk := mustNew(t, &providerCLI{})\n\tkctx, err := k.Parse([]string{\"sub\"})\n\tassert.NoError(t, err)\n\terr = kctx.Run(t)\n\tassert.NoError(t, err)\n}\n\ntype EmbeddedCallback struct {\n\tEmbedded bool\n}\n\nfunc (e *EmbeddedCallback) AfterApply() error {\n\te.Embedded = true\n\treturn nil\n}\n\ntype EmbeddedRoot struct {\n\tEmbeddedCallback\n\tRoot bool\n}\n\nfunc (e *EmbeddedRoot) AfterApply() error {\n\te.Root = true\n\treturn nil\n}\n\nfunc TestEmbeddedCallbacks(t *testing.T) {\n\tactual := &EmbeddedRoot{}\n\tk := mustNew(t, actual)\n\t_, err := k.Parse(nil)\n\tassert.NoError(t, err)\n\texpected := &EmbeddedRoot{\n\t\tEmbeddedCallback: EmbeddedCallback{\n\t\t\tEmbedded: true,\n\t\t},\n\t\tRoot: true,\n\t}\n\tassert.Equal(t, expected, actual)\n}\n\ntype applyCalledOnce struct {\n\tDev bool\n}\n\nfunc (c *applyCalledOnce) AfterApply() error {\n\tc.Dev = false\n\treturn nil\n}\n\nfunc (c applyCalledOnce) Run() error {\n\tif c.Dev {\n\t\treturn fmt.Errorf(\"--dev should not be set\")\n\t}\n\treturn nil\n}\n\nfunc TestApplyCalledOnce(t *testing.T) {\n\tcli := &applyCalledOnce{}\n\tkctx, err := mustNew(t, cli).Parse([]string{\"--dev\"})\n\tassert.NoError(t, err)\n\terr = kctx.Run()\n\tassert.NoError(t, err)\n}\n\nfunc TestCustomTypeNoEllipsis(t *testing.T) {\n\ttype CLI struct {\n\t\tFlag []byte `type:\"existingfile\"`\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli, kong.Exit(func(int) {}))\n\tw := &strings.Builder{}\n\tp.Stderr = w\n\tp.Stdout = w\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\thelp := w.String()\n\tassert.NotContains(t, help, \"...\")\n}\n\nfunc TestPrefixXorIssue343(t *testing.T) {\n\ttype DBConfig struct {\n\t\tPassword        string `help:\"Password\" xor:\"password\" optional:\"\"`\n\t\tPasswordFile    string `help:\"File which content will be used for a password\" xor:\"password\" optional:\"\"`\n\t\tPasswordCommand string `help:\"Command to run to retrieve password\" xor:\"password\" optional:\"\"`\n\t}\n\n\ttype SourceTargetConfig struct {\n\t\tSource DBConfig `help:\"Database config of source to be copied from\" prefix:\"source-\" xorprefix:\"source-\" embed:\"\"`\n\t\tTarget DBConfig `help:\"Database config of source to be copied from\" prefix:\"target-\" xorprefix:\"target-\" embed:\"\"`\n\t}\n\n\tcli := SourceTargetConfig{}\n\tkctx := mustNew(t, &cli)\n\t_, err := kctx.Parse([]string{\"--source-password=foo\", \"--target-password=bar\"})\n\tassert.NoError(t, err)\n\t_, err = kctx.Parse([]string{\"--source-password-file=foo\", \"--source-password=bar\"})\n\tassert.Error(t, err)\n}\n\nfunc TestIssue483EmptyRootNodeNoRun(t *testing.T) {\n\tvar emptyCLI struct{}\n\tparser, err := kong.New(&emptyCLI)\n\tassert.NoError(t, err)\n\n\tkctx, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\n\terr = kctx.Run()\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"no command selected\")\n}\n"
        },
        {
          "name": "levenshtein.go",
          "type": "blob",
          "size": 0.7802734375,
          "content": "package kong\n\nimport \"unicode/utf8\"\n\n// https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#Go\n// License: https://creativecommons.org/licenses/by-sa/3.0/\nfunc levenshtein(a, b string) int {\n\tf := make([]int, utf8.RuneCountInString(b)+1)\n\n\tfor j := range f {\n\t\tf[j] = j\n\t}\n\n\tfor _, ca := range a {\n\t\tj := 1\n\t\tfj1 := f[0] // fj1 is the value of f[j - 1] in last iteration\n\t\tf[0]++\n\t\tfor _, cb := range b {\n\t\t\tmn := min(f[j]+1, f[j-1]+1) // delete & insert\n\t\t\tif cb != ca {\n\t\t\t\tmn = min(mn, fj1+1) // change\n\t\t\t} else {\n\t\t\t\tmn = min(mn, fj1) // matched\n\t\t\t}\n\n\t\t\tfj1, f[j] = f[j], mn // save f[j] to fj1(j is about to increase), update f[j] to mn\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn f[len(f)-1]\n}\n\nfunc min(a, b int) int { //nolint:predeclared\n\tif a <= b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "mapper.go",
          "type": "blob",
          "size": 25.263671875,
          "content": "package kong\n\nimport (\n\t\"encoding\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/bits\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar (\n\tmapperValueType       = reflect.TypeOf((*MapperValue)(nil)).Elem()\n\tboolMapperValueType   = reflect.TypeOf((*BoolMapperValue)(nil)).Elem()\n\tjsonUnmarshalerType   = reflect.TypeOf((*json.Unmarshaler)(nil)).Elem()\n\ttextUnmarshalerType   = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()\n\tbinaryUnmarshalerType = reflect.TypeOf((*encoding.BinaryUnmarshaler)(nil)).Elem()\n)\n\n// DecodeContext is passed to a Mapper's Decode().\n//\n// It contains the Value being decoded into and the Scanner to parse from.\ntype DecodeContext struct {\n\t// Value being decoded into.\n\tValue *Value\n\t// Scan contains the input to scan into Target.\n\tScan *Scanner\n}\n\n// WithScanner creates a clone of this context with a new Scanner.\nfunc (r *DecodeContext) WithScanner(scan *Scanner) *DecodeContext {\n\treturn &DecodeContext{\n\t\tValue: r.Value,\n\t\tScan:  scan,\n\t}\n}\n\n// MapperValue may be implemented by fields in order to provide custom mapping.\n// Mappers may additionally implement PlaceHolderProvider to provide custom placeholder text.\ntype MapperValue interface {\n\tDecode(ctx *DecodeContext) error\n}\n\n// BoolMapperValue may be implemented by fields in order to provide custom mappings for boolean values.\ntype BoolMapperValue interface {\n\tMapperValue\n\tIsBool() bool\n}\n\ntype mapperValueAdapter struct {\n\tisBool bool\n}\n\nfunc (m *mapperValueAdapter) Decode(ctx *DecodeContext, target reflect.Value) error {\n\tif target.Type().Implements(mapperValueType) {\n\t\treturn target.Interface().(MapperValue).Decode(ctx) //nolint\n\t}\n\treturn target.Addr().Interface().(MapperValue).Decode(ctx) //nolint\n}\n\nfunc (m *mapperValueAdapter) IsBool() bool {\n\treturn m.isBool\n}\n\ntype textUnmarshalerAdapter struct{}\n\nfunc (m *textUnmarshalerAdapter) Decode(ctx *DecodeContext, target reflect.Value) error {\n\tvar value string\n\terr := ctx.Scan.PopValueInto(\"value\", &value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif target.Type().Implements(textUnmarshalerType) {\n\t\treturn target.Interface().(encoding.TextUnmarshaler).UnmarshalText([]byte(value)) //nolint\n\t}\n\treturn target.Addr().Interface().(encoding.TextUnmarshaler).UnmarshalText([]byte(value)) //nolint\n}\n\ntype binaryUnmarshalerAdapter struct{}\n\nfunc (m *binaryUnmarshalerAdapter) Decode(ctx *DecodeContext, target reflect.Value) error {\n\tvar value string\n\terr := ctx.Scan.PopValueInto(\"value\", &value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif target.Type().Implements(binaryUnmarshalerType) {\n\t\treturn target.Interface().(encoding.BinaryUnmarshaler).UnmarshalBinary([]byte(value)) //nolint\n\t}\n\treturn target.Addr().Interface().(encoding.BinaryUnmarshaler).UnmarshalBinary([]byte(value)) //nolint\n}\n\ntype jsonUnmarshalerAdapter struct{}\n\nfunc (j *jsonUnmarshalerAdapter) Decode(ctx *DecodeContext, target reflect.Value) error {\n\tvar value string\n\terr := ctx.Scan.PopValueInto(\"value\", &value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif target.Type().Implements(jsonUnmarshalerType) {\n\t\treturn target.Interface().(json.Unmarshaler).UnmarshalJSON([]byte(value)) //nolint\n\t}\n\treturn target.Addr().Interface().(json.Unmarshaler).UnmarshalJSON([]byte(value)) //nolint\n}\n\n// A Mapper represents how a field is mapped from command-line values to Go.\n//\n// Mappers can be associated with concrete fields via pointer, reflect.Type, reflect.Kind, or via a \"type\" tag.\n//\n// Additionally, if a type implements the MapperValue interface, it will be used.\ntype Mapper interface {\n\t// Decode ctx.Value with ctx.Scanner into target.\n\tDecode(ctx *DecodeContext, target reflect.Value) error\n}\n\n// VarsContributor can be implemented by a Mapper to contribute Vars during interpolation.\ntype VarsContributor interface {\n\tVars(ctx *Value) Vars\n}\n\n// A BoolMapper is a Mapper to a value that is a boolean.\n//\n// This is used solely for formatting help.\ntype BoolMapper interface {\n\tMapper\n\tIsBool() bool\n}\n\n// BoolMapperExt allows a Mapper to dynamically determine if a value is a boolean.\ntype BoolMapperExt interface {\n\tMapper\n\tIsBoolFromValue(v reflect.Value) bool\n}\n\n// A MapperFunc is a single function that complies with the Mapper interface.\ntype MapperFunc func(ctx *DecodeContext, target reflect.Value) error\n\nfunc (m MapperFunc) Decode(ctx *DecodeContext, target reflect.Value) error { //nolint: revive\n\treturn m(ctx, target)\n}\n\n// A Registry contains a set of mappers and supporting lookup methods.\ntype Registry struct {\n\tnames  map[string]Mapper\n\ttypes  map[reflect.Type]Mapper\n\tkinds  map[reflect.Kind]Mapper\n\tvalues map[reflect.Value]Mapper\n}\n\n// NewRegistry creates a new (empty) Registry.\nfunc NewRegistry() *Registry {\n\treturn &Registry{\n\t\tnames:  map[string]Mapper{},\n\t\ttypes:  map[reflect.Type]Mapper{},\n\t\tkinds:  map[reflect.Kind]Mapper{},\n\t\tvalues: map[reflect.Value]Mapper{},\n\t}\n}\n\n// ForNamedValue finds a mapper for a value with a user-specified name.\n//\n// Will return nil if a mapper can not be determined.\nfunc (r *Registry) ForNamedValue(name string, value reflect.Value) Mapper {\n\tif mapper, ok := r.names[name]; ok {\n\t\treturn mapper\n\t}\n\treturn r.ForValue(value)\n}\n\n// ForValue looks up the Mapper for a reflect.Value.\nfunc (r *Registry) ForValue(value reflect.Value) Mapper {\n\tif mapper, ok := r.values[value]; ok {\n\t\treturn mapper\n\t}\n\treturn r.ForType(value.Type())\n}\n\n// ForNamedType finds a mapper for a type with a user-specified name.\n//\n// Will return nil if a mapper can not be determined.\nfunc (r *Registry) ForNamedType(name string, typ reflect.Type) Mapper {\n\tif mapper, ok := r.names[name]; ok {\n\t\treturn mapper\n\t}\n\treturn r.ForType(typ)\n}\n\n// ForType finds a mapper from a type, by type, then kind.\n//\n// Will return nil if a mapper can not be determined.\nfunc (r *Registry) ForType(typ reflect.Type) Mapper {\n\t// Check if the type implements MapperValue.\n\tfor _, impl := range []reflect.Type{typ, reflect.PtrTo(typ)} {\n\t\tif impl.Implements(mapperValueType) {\n\t\t\t// FIXME: This should pass in the bool mapper.\n\t\t\treturn &mapperValueAdapter{impl.Implements(boolMapperValueType)}\n\t\t}\n\t}\n\t// Next, try explicitly registered types.\n\tvar mapper Mapper\n\tvar ok bool\n\tif mapper, ok = r.types[typ]; ok {\n\t\treturn mapper\n\t}\n\t// Next try stdlib unmarshaler interfaces.\n\tfor _, impl := range []reflect.Type{typ, reflect.PtrTo(typ)} {\n\t\tswitch {\n\t\tcase impl.Implements(textUnmarshalerType):\n\t\t\treturn &textUnmarshalerAdapter{}\n\t\tcase impl.Implements(binaryUnmarshalerType):\n\t\t\treturn &binaryUnmarshalerAdapter{}\n\t\tcase impl.Implements(jsonUnmarshalerType):\n\t\t\treturn &jsonUnmarshalerAdapter{}\n\t\t}\n\t}\n\t// Finally try registered kinds.\n\tif mapper, ok = r.kinds[typ.Kind()]; ok {\n\t\treturn mapper\n\t}\n\treturn nil\n}\n\n// RegisterKind registers a Mapper for a reflect.Kind.\nfunc (r *Registry) RegisterKind(kind reflect.Kind, mapper Mapper) *Registry {\n\tr.kinds[kind] = mapper\n\treturn r\n}\n\n// RegisterName registers a mapper to be used if the value mapper has a \"type\" tag matching name.\n//\n// eg.\n//\n//\t\t\tMapper string `kong:\"type='colour'`\n//\t  \tregistry.RegisterName(\"colour\", ...)\nfunc (r *Registry) RegisterName(name string, mapper Mapper) *Registry {\n\tr.names[name] = mapper\n\treturn r\n}\n\n// RegisterType registers a Mapper for a reflect.Type.\nfunc (r *Registry) RegisterType(typ reflect.Type, mapper Mapper) *Registry {\n\tr.types[typ] = mapper\n\treturn r\n}\n\n// RegisterValue registers a Mapper by pointer to the field value.\nfunc (r *Registry) RegisterValue(ptr any, mapper Mapper) *Registry {\n\tkey := reflect.ValueOf(ptr)\n\tif key.Kind() != reflect.Ptr {\n\t\tpanic(\"expected a pointer\")\n\t}\n\tkey = key.Elem()\n\tr.values[key] = mapper\n\treturn r\n}\n\n// RegisterDefaults registers Mappers for all builtin supported Go types and some common stdlib types.\nfunc (r *Registry) RegisterDefaults() *Registry {\n\treturn r.RegisterKind(reflect.Int, intDecoder(bits.UintSize)).\n\t\tRegisterKind(reflect.Int8, intDecoder(8)).\n\t\tRegisterKind(reflect.Int16, intDecoder(16)).\n\t\tRegisterKind(reflect.Int32, intDecoder(32)).\n\t\tRegisterKind(reflect.Int64, intDecoder(64)).\n\t\tRegisterKind(reflect.Uint, uintDecoder(bits.UintSize)).\n\t\tRegisterKind(reflect.Uint8, uintDecoder(8)).\n\t\tRegisterKind(reflect.Uint16, uintDecoder(16)).\n\t\tRegisterKind(reflect.Uint32, uintDecoder(32)).\n\t\tRegisterKind(reflect.Uint64, uintDecoder(64)).\n\t\tRegisterKind(reflect.Float32, floatDecoder(32)).\n\t\tRegisterKind(reflect.Float64, floatDecoder(64)).\n\t\tRegisterKind(reflect.String, MapperFunc(func(ctx *DecodeContext, target reflect.Value) error {\n\t\t\treturn ctx.Scan.PopValueInto(\"string\", target.Addr().Interface())\n\t\t})).\n\t\tRegisterKind(reflect.Bool, boolMapper{}).\n\t\tRegisterKind(reflect.Slice, sliceDecoder(r)).\n\t\tRegisterKind(reflect.Map, mapDecoder(r)).\n\t\tRegisterType(reflect.TypeOf(time.Time{}), timeDecoder()).\n\t\tRegisterType(reflect.TypeOf(time.Duration(0)), durationDecoder()).\n\t\tRegisterType(reflect.TypeOf(&url.URL{}), urlMapper()).\n\t\tRegisterType(reflect.TypeOf(&os.File{}), fileMapper(r)).\n\t\tRegisterName(\"path\", pathMapper(r)).\n\t\tRegisterName(\"existingfile\", existingFileMapper(r)).\n\t\tRegisterName(\"existingdir\", existingDirMapper(r)).\n\t\tRegisterName(\"counter\", counterMapper()).\n\t\tRegisterName(\"filecontent\", fileContentMapper(r)).\n\t\tRegisterKind(reflect.Ptr, ptrMapper{r})\n}\n\ntype boolMapper struct{}\n\nfunc (boolMapper) Decode(ctx *DecodeContext, target reflect.Value) error {\n\tif ctx.Scan.Peek().Type == FlagValueToken {\n\t\ttoken := ctx.Scan.Pop()\n\t\tswitch v := token.Value.(type) {\n\t\tcase string:\n\t\t\tv = strings.ToLower(v)\n\t\t\tswitch v {\n\t\t\tcase \"true\", \"1\", \"yes\":\n\t\t\t\ttarget.SetBool(true)\n\n\t\t\tcase \"false\", \"0\", \"no\":\n\t\t\t\ttarget.SetBool(false)\n\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"bool value must be true, 1, yes, false, 0 or no but got %q\", v)\n\t\t\t}\n\n\t\tcase bool:\n\t\t\ttarget.SetBool(v)\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"expected bool but got %q (%T)\", token.Value, token.Value)\n\t\t}\n\t} else {\n\t\ttarget.SetBool(true)\n\t}\n\treturn nil\n}\nfunc (boolMapper) IsBool() bool { return true }\n\nfunc durationDecoder() MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tt, err := ctx.Scan.PopValue(\"duration\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar d time.Duration\n\t\tswitch v := t.Value.(type) {\n\t\tcase string:\n\t\t\td, err = time.ParseDuration(v)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"expected duration but got %q: %v\", v, err)\n\t\t\t}\n\t\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64:\n\t\t\td = reflect.ValueOf(v).Convert(reflect.TypeOf(time.Duration(0))).Interface().(time.Duration) //nolint: forcetypeassert\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"expected duration but got %q\", v)\n\t\t}\n\t\ttarget.Set(reflect.ValueOf(d))\n\t\treturn nil\n\t}\n}\n\nfunc timeDecoder() MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tformat := time.RFC3339\n\t\tif ctx.Value.Format != \"\" {\n\t\t\tformat = ctx.Value.Format\n\t\t}\n\t\tvar value string\n\t\tif err := ctx.Scan.PopValueInto(\"time\", &value); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tt, err := time.Parse(format, value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttarget.Set(reflect.ValueOf(t))\n\t\treturn nil\n\t}\n}\n\nfunc intDecoder(bits int) MapperFunc { //nolint: dupl\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tt, err := ctx.Scan.PopValue(\"int\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar sv string\n\t\tswitch v := t.Value.(type) {\n\t\tcase string:\n\t\t\tsv = v\n\n\t\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n\t\t\tsv = fmt.Sprintf(\"%v\", v)\n\n\t\tcase float32, float64:\n\t\t\tsv = fmt.Sprintf(\"%0.f\", v)\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"expected an int but got %q (%T)\", t, t.Value)\n\t\t}\n\t\tn, err := strconv.ParseInt(sv, 10, bits)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"expected a valid %d bit int but got %q\", bits, sv)\n\t\t}\n\t\ttarget.SetInt(n)\n\t\treturn nil\n\t}\n}\n\nfunc uintDecoder(bits int) MapperFunc { //nolint: dupl\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tt, err := ctx.Scan.PopValue(\"uint\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar sv string\n\t\tswitch v := t.Value.(type) {\n\t\tcase string:\n\t\t\tsv = v\n\n\t\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n\t\t\tsv = fmt.Sprintf(\"%v\", v)\n\n\t\tcase float32, float64:\n\t\t\tsv = fmt.Sprintf(\"%0.f\", v)\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"expected an int but got %q (%T)\", t, t.Value)\n\t\t}\n\t\tn, err := strconv.ParseUint(sv, 10, bits)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"expected a valid %d bit uint but got %q\", bits, sv)\n\t\t}\n\t\ttarget.SetUint(n)\n\t\treturn nil\n\t}\n}\n\nfunc floatDecoder(bits int) MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tt, err := ctx.Scan.PopValue(\"float\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch v := t.Value.(type) {\n\t\tcase string:\n\t\t\tn, err := strconv.ParseFloat(v, bits)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"expected a float but got %q (%T)\", t, t.Value)\n\t\t\t}\n\t\t\ttarget.SetFloat(n)\n\n\t\tcase float32:\n\t\t\ttarget.SetFloat(float64(v))\n\n\t\tcase float64:\n\t\t\ttarget.SetFloat(v)\n\n\t\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n\t\t\ttarget.Set(reflect.ValueOf(v))\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"expected an int but got %q (%T)\", t, t.Value)\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc mapDecoder(r *Registry) MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tif target.IsNil() {\n\t\t\ttarget.Set(reflect.MakeMap(target.Type()))\n\t\t}\n\t\tel := target.Type()\n\t\tmapsep := ctx.Value.Tag.MapSep\n\t\tvar childScanner *Scanner\n\t\tif ctx.Value.Flag != nil {\n\t\t\tt := ctx.Scan.Pop()\n\t\t\t// If decoding a flag, we need an value.\n\t\t\tif t.IsEOL() {\n\t\t\t\treturn fmt.Errorf(\"missing value, expecting \\\"<key>=<value>%c...\\\"\", mapsep)\n\t\t\t}\n\t\t\tswitch v := t.Value.(type) {\n\t\t\tcase string:\n\t\t\t\tchildScanner = ScanAsType(t.Type, SplitEscaped(v, mapsep)...)\n\n\t\t\tcase []map[string]any:\n\t\t\t\tfor _, m := range v {\n\t\t\t\t\terr := jsonTranscode(m, target.Addr().Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\n\t\t\tcase map[string]any:\n\t\t\t\treturn jsonTranscode(v, target.Addr().Interface())\n\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"invalid map value %q (of type %T)\", t, t.Value)\n\t\t\t}\n\t\t} else {\n\t\t\ttokens := ctx.Scan.PopWhile(func(t Token) bool { return t.IsValue() })\n\t\t\tchildScanner = ScanFromTokens(tokens...)\n\t\t}\n\t\tfor !childScanner.Peek().IsEOL() {\n\t\t\tvar token string\n\t\t\terr := childScanner.PopValueInto(\"map\", &token)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tparts := strings.SplitN(token, \"=\", 2)\n\t\t\tif len(parts) != 2 {\n\t\t\t\treturn fmt.Errorf(\"expected \\\"<key>=<value>\\\" but got %q\", token)\n\t\t\t}\n\t\t\tkey, value := parts[0], parts[1]\n\n\t\t\tkeyTypeName, valueTypeName := \"\", \"\"\n\t\t\tif typ := ctx.Value.Tag.Type; typ != \"\" {\n\t\t\t\tparts := strings.Split(typ, \":\")\n\t\t\t\tif len(parts) != 2 {\n\t\t\t\t\treturn errors.New(\"type:\\\"\\\" on map field must be in the form \\\"[<keytype>]:[<valuetype>]\\\"\")\n\t\t\t\t}\n\t\t\t\tkeyTypeName, valueTypeName = parts[0], parts[1]\n\t\t\t}\n\n\t\t\tkeyScanner := ScanAsType(FlagValueToken, key)\n\t\t\tkeyDecoder := r.ForNamedType(keyTypeName, el.Key())\n\t\t\tkeyValue := reflect.New(el.Key()).Elem()\n\t\t\tif err := keyDecoder.Decode(ctx.WithScanner(keyScanner), keyValue); err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid map key %q\", key)\n\t\t\t}\n\n\t\t\tvalueScanner := ScanAsType(FlagValueToken, value)\n\t\t\tvalueDecoder := r.ForNamedType(valueTypeName, el.Elem())\n\t\t\tvalueValue := reflect.New(el.Elem()).Elem()\n\t\t\tif err := valueDecoder.Decode(ctx.WithScanner(valueScanner), valueValue); err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid map value %q\", value)\n\t\t\t}\n\n\t\t\ttarget.SetMapIndex(keyValue, valueValue)\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc sliceDecoder(r *Registry) MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tel := target.Type().Elem()\n\t\tsep := ctx.Value.Tag.Sep\n\t\tvar childScanner *Scanner\n\t\tif ctx.Value.Flag != nil {\n\t\t\tt := ctx.Scan.Pop()\n\t\t\t// If decoding a flag, we need a value.\n\t\t\tif t.IsEOL() {\n\t\t\t\treturn fmt.Errorf(\"missing value, expecting \\\"<arg>%c...\\\"\", sep)\n\t\t\t}\n\t\t\tswitch v := t.Value.(type) {\n\t\t\tcase string:\n\t\t\t\tchildScanner = ScanAsType(t.Type, SplitEscaped(v, sep)...)\n\n\t\t\tcase []any:\n\t\t\t\treturn jsonTranscode(v, target.Addr().Interface())\n\n\t\t\tdefault:\n\t\t\t\tv = []any{v}\n\t\t\t\treturn jsonTranscode(v, target.Addr().Interface())\n\t\t\t}\n\t\t} else {\n\t\t\ttokens := ctx.Scan.PopWhile(func(t Token) bool { return t.IsValue() })\n\t\t\tchildScanner = ScanFromTokens(tokens...)\n\t\t}\n\t\tchildDecoder := r.ForNamedType(ctx.Value.Tag.Type, el)\n\t\tif childDecoder == nil {\n\t\t\treturn fmt.Errorf(\"no mapper for element type of %s\", target.Type())\n\t\t}\n\t\tfor !childScanner.Peek().IsEOL() {\n\t\t\tchildValue := reflect.New(el).Elem()\n\t\t\terr := childDecoder.Decode(ctx.WithScanner(childScanner), childValue)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ttarget.Set(reflect.Append(target, childValue))\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc pathMapper(r *Registry) MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tif target.Kind() == reflect.Slice {\n\t\t\treturn sliceDecoder(r)(ctx, target)\n\t\t}\n\t\tif target.Kind() == reflect.Ptr && target.Elem().Kind() == reflect.String {\n\t\t\tif target.IsNil() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\ttarget = target.Elem()\n\t\t}\n\t\tif target.Kind() != reflect.String {\n\t\t\treturn fmt.Errorf(\"\\\"path\\\" type must be applied to a string not %s\", target.Type())\n\t\t}\n\t\tvar path string\n\t\terr := ctx.Scan.PopValueInto(\"file\", &path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif path != \"-\" {\n\t\t\tpath = ExpandPath(path)\n\t\t}\n\t\ttarget.SetString(path)\n\t\treturn nil\n\t}\n}\n\nfunc fileMapper(r *Registry) MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tif target.Kind() == reflect.Slice {\n\t\t\treturn sliceDecoder(r)(ctx, target)\n\t\t}\n\t\tvar path string\n\t\terr := ctx.Scan.PopValueInto(\"file\", &path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar file *os.File\n\t\tif path == \"-\" {\n\t\t\tfile = os.Stdin\n\t\t} else {\n\t\t\tpath = ExpandPath(path)\n\t\t\tfile, err = os.Open(path) //nolint: gosec\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\ttarget.Set(reflect.ValueOf(file))\n\t\treturn nil\n\t}\n}\n\nfunc existingFileMapper(r *Registry) MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tif target.Kind() == reflect.Slice {\n\t\t\treturn sliceDecoder(r)(ctx, target)\n\t\t}\n\t\tif target.Kind() != reflect.String {\n\t\t\treturn fmt.Errorf(\"\\\"existingfile\\\" type must be applied to a string not %s\", target.Type())\n\t\t}\n\t\tvar path string\n\t\terr := ctx.Scan.PopValueInto(\"file\", &path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !ctx.Value.Active || (ctx.Value.Set && ctx.Value.Target.Type() == target.Type()) {\n\t\t\t// early return to avoid checking extra files that may not exist;\n\t\t\t// this hack only works because the value provided on the cli is\n\t\t\t// checked before the default value is checked (if default is set).\n\t\t\treturn nil\n\t\t}\n\n\t\tif path != \"-\" {\n\t\t\tpath = ExpandPath(path)\n\t\t\tstat, err := os.Stat(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif stat.IsDir() {\n\t\t\t\treturn fmt.Errorf(\"%q exists but is a directory\", path)\n\t\t\t}\n\t\t}\n\t\ttarget.SetString(path)\n\t\treturn nil\n\t}\n}\n\nfunc existingDirMapper(r *Registry) MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tif target.Kind() == reflect.Slice {\n\t\t\treturn sliceDecoder(r)(ctx, target)\n\t\t}\n\t\tif target.Kind() != reflect.String {\n\t\t\treturn fmt.Errorf(\"\\\"existingdir\\\" must be applied to a string not %s\", target.Type())\n\t\t}\n\t\tvar path string\n\t\terr := ctx.Scan.PopValueInto(\"file\", &path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !ctx.Value.Active || (ctx.Value.Set && ctx.Value.Target.Type() == target.Type()) {\n\t\t\t// early return to avoid checking extra dirs that may not exist;\n\t\t\t// this hack only works because the value provided on the cli is\n\t\t\t// checked before the default value is checked (if default is set).\n\t\t\treturn nil\n\t\t}\n\n\t\tpath = ExpandPath(path)\n\t\tstat, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !stat.IsDir() {\n\t\t\treturn fmt.Errorf(\"%q exists but is not a directory\", path)\n\t\t}\n\t\ttarget.SetString(path)\n\t\treturn nil\n\t}\n}\n\nfunc fileContentMapper(r *Registry) MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tif target.Kind() != reflect.Slice && target.Elem().Kind() != reflect.Uint8 {\n\t\t\treturn fmt.Errorf(\"\\\"filecontent\\\" must be applied to []byte not %s\", target.Type())\n\t\t}\n\t\tvar path string\n\t\terr := ctx.Scan.PopValueInto(\"file\", &path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !ctx.Value.Active || ctx.Value.Set {\n\t\t\t// early return to avoid checking extra dirs that may not exist;\n\t\t\t// this hack only works because the value provided on the cli is\n\t\t\t// checked before the default value is checked (if default is set).\n\t\t\treturn nil\n\t\t}\n\n\t\tvar data []byte\n\t\tif path != \"-\" {\n\t\t\tpath = ExpandPath(path)\n\t\t\tdata, err = os.ReadFile(path) //nolint:gosec\n\t\t} else {\n\t\t\tdata, err = io.ReadAll(os.Stdin)\n\t\t}\n\t\tif err != nil {\n\t\t\tif info, statErr := os.Stat(path); statErr == nil && info.IsDir() {\n\t\t\t\treturn fmt.Errorf(\"%q exists but is a directory: %w\", path, err)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\ttarget.SetBytes(data)\n\t\treturn nil\n\t}\n}\n\ntype ptrMapper struct {\n\tr *Registry\n}\n\nvar _ BoolMapperExt = (*ptrMapper)(nil)\n\n// IsBoolFromValue implements BoolMapperExt\nfunc (p ptrMapper) IsBoolFromValue(target reflect.Value) bool {\n\telem := reflect.New(target.Type().Elem()).Elem()\n\tnestedMapper := p.r.ForValue(elem)\n\tif nestedMapper == nil {\n\t\treturn false\n\t}\n\tif bm, ok := nestedMapper.(BoolMapper); ok && bm.IsBool() {\n\t\treturn true\n\t}\n\tif bm, ok := nestedMapper.(BoolMapperExt); ok && bm.IsBoolFromValue(target) {\n\t\treturn true\n\t}\n\treturn target.Kind() == reflect.Ptr && target.Type().Elem().Kind() == reflect.Bool\n}\n\nfunc (p ptrMapper) Decode(ctx *DecodeContext, target reflect.Value) error {\n\telem := reflect.New(target.Type().Elem()).Elem()\n\tnestedMapper := p.r.ForValue(elem)\n\tif nestedMapper == nil {\n\t\treturn fmt.Errorf(\"cannot find mapper for %v\", target.Type().Elem().String())\n\t}\n\terr := nestedMapper.Decode(ctx, elem)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttarget.Set(elem.Addr())\n\treturn nil\n}\n\nfunc counterMapper() MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tif ctx.Scan.Peek().Type == FlagValueToken {\n\t\t\tt, err := ctx.Scan.PopValue(\"counter\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tswitch v := t.Value.(type) {\n\t\t\tcase string:\n\t\t\t\tn, err := strconv.ParseInt(v, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected a counter but got %q (%T)\", t, t.Value)\n\t\t\t\t}\n\t\t\t\ttarget.SetInt(n)\n\n\t\t\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n\t\t\t\ttarget.Set(reflect.ValueOf(v))\n\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"expected a counter but got %q (%T)\", t, t.Value)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch target.Kind() {\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\ttarget.SetInt(target.Int() + 1)\n\n\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\t\ttarget.SetUint(target.Uint() + 1)\n\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\ttarget.SetFloat(target.Float() + 1)\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"type:\\\"counter\\\" must be used with a numeric field\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc urlMapper() MapperFunc {\n\treturn func(ctx *DecodeContext, target reflect.Value) error {\n\t\tvar urlStr string\n\t\terr := ctx.Scan.PopValueInto(\"url\", &urlStr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\turl, err := url.Parse(urlStr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttarget.Set(reflect.ValueOf(url))\n\t\treturn nil\n\t}\n}\n\n// SplitEscaped splits a string on a separator.\n//\n// It differs from strings.Split() in that the separator can exist in a field by escaping it with a \\. eg.\n//\n//\tSplitEscaped(`hello\\,there,bob`, ',') == []string{\"hello,there\", \"bob\"}\nfunc SplitEscaped(s string, sep rune) (out []string) {\n\tif sep == -1 {\n\t\treturn []string{s}\n\t}\n\tescaped := false\n\ttoken := \"\"\n\tfor i, ch := range s {\n\t\tswitch {\n\t\tcase escaped:\n\t\t\tif ch != sep {\n\t\t\t\ttoken += `\\`\n\t\t\t}\n\t\t\ttoken += string(ch)\n\t\t\tescaped = false\n\t\tcase ch == '\\\\' && i < len(s)-1:\n\t\t\tescaped = true\n\t\tcase ch == sep && !escaped:\n\t\t\tout = append(out, token)\n\t\t\ttoken = \"\"\n\t\t\tescaped = false\n\t\tdefault:\n\t\t\ttoken += string(ch)\n\t\t}\n\t}\n\tif token != \"\" {\n\t\tout = append(out, token)\n\t}\n\treturn\n}\n\n// JoinEscaped joins a slice of strings on sep, but also escapes any instances of sep in the fields with \\. eg.\n//\n//\tJoinEscaped([]string{\"hello,there\", \"bob\"}, ',') == `hello\\,there,bob`\nfunc JoinEscaped(s []string, sep rune) string {\n\tescaped := []string{}\n\tfor _, e := range s {\n\t\tescaped = append(escaped, strings.ReplaceAll(e, string(sep), `\\`+string(sep)))\n\t}\n\treturn strings.Join(escaped, string(sep))\n}\n\n// NamedFileContentFlag is a flag value that loads a file's contents and filename into its value.\ntype NamedFileContentFlag struct {\n\tFilename string\n\tContents []byte\n}\n\nfunc (f *NamedFileContentFlag) Decode(ctx *DecodeContext) error { //nolint: revive\n\tvar filename string\n\terr := ctx.Scan.PopValueInto(\"filename\", &filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// This allows unsetting of file content flags.\n\tif filename == \"\" {\n\t\t*f = NamedFileContentFlag{}\n\t\treturn nil\n\t}\n\tfilename = ExpandPath(filename)\n\tdata, err := os.ReadFile(filename) //nolint: gosec\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open %q: %v\", filename, err)\n\t}\n\tf.Contents = data\n\tf.Filename = filename\n\treturn nil\n}\n\n// FileContentFlag is a flag value that loads a file's contents into its value.\ntype FileContentFlag []byte\n\nfunc (f *FileContentFlag) Decode(ctx *DecodeContext) error { //nolint: revive\n\tvar filename string\n\terr := ctx.Scan.PopValueInto(\"filename\", &filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// This allows unsetting of file content flags.\n\tif filename == \"\" {\n\t\t*f = nil\n\t\treturn nil\n\t}\n\tfilename = ExpandPath(filename)\n\tdata, err := os.ReadFile(filename) //nolint: gosec\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open %q: %v\", filename, err)\n\t}\n\t*f = data\n\treturn nil\n}\n\nfunc jsonTranscode(in, out any) error {\n\tdata, err := json.Marshal(in)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = json.Unmarshal(data, out); err != nil {\n\t\treturn fmt.Errorf(\"%#v -> %T: %v\", in, out, err)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "mapper_linux_test.go",
          "type": "blob",
          "size": 0.4375,
          "content": "//go:build !windows\n// +build !windows\n\npackage kong_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc TestPathMapper(t *testing.T) {\n\tvar cli struct {\n\t\tPath string `arg:\"\" type:\"path\"`\n\t}\n\tp := mustNew(t, &cli)\n\n\t_, err := p.Parse([]string{\"/an/absolute/path\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"/an/absolute/path\", cli.Path)\n\n\t_, err = p.Parse([]string{\"-\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"-\", cli.Path)\n}\n"
        },
        {
          "name": "mapper_test.go",
          "type": "blob",
          "size": 19.9384765625,
          "content": "package kong_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alecthomas/assert/v2\"\n\t\"github.com/alecthomas/kong\"\n)\n\nfunc TestValueMapper(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string\n\t}\n\tk := mustNew(t, &cli, kong.ValueMapper(&cli.Flag, testMooMapper{}))\n\t_, err := k.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"\", cli.Flag)\n\t_, err = k.Parse([]string{\"--flag\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"MOO\", cli.Flag)\n}\n\ntype textUnmarshalerValue int\n\nfunc (m *textUnmarshalerValue) UnmarshalText(text []byte) error {\n\ts := string(text)\n\tif s == \"hello\" {\n\t\t*m = 10\n\t} else {\n\t\treturn fmt.Errorf(\"expected \\\"hello\\\"\")\n\t}\n\treturn nil\n}\n\nfunc TestTextUnmarshaler(t *testing.T) {\n\tvar cli struct {\n\t\tValue textUnmarshalerValue\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--value=hello\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 10, int(cli.Value))\n\t_, err = p.Parse([]string{\"--value=other\"})\n\tassert.Error(t, err)\n}\n\ntype jsonUnmarshalerValue string\n\nfunc (j *jsonUnmarshalerValue) UnmarshalJSON(text []byte) error {\n\tvar v string\n\terr := json.Unmarshal(text, &v)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*j = jsonUnmarshalerValue(strings.ToUpper(v))\n\treturn nil\n}\n\nfunc TestJSONUnmarshaler(t *testing.T) {\n\tvar cli struct {\n\t\tValue jsonUnmarshalerValue\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--value=\\\"hello\\\"\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"HELLO\", string(cli.Value))\n}\n\nfunc TestNamedMapper(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `type:\"moo\"`\n\t}\n\tk := mustNew(t, &cli, kong.NamedMapper(\"moo\", testMooMapper{}))\n\t_, err := k.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"\", cli.Flag)\n\t_, err = k.Parse([]string{\"--flag\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"MOO\", cli.Flag)\n}\n\ntype testMooMapper struct {\n\ttext string\n}\n\nfunc (t testMooMapper) Decode(ctx *kong.DecodeContext, target reflect.Value) error {\n\tif t.text == \"\" {\n\t\ttarget.SetString(\"MOO\")\n\t} else {\n\t\ttarget.SetString(t.text)\n\t}\n\treturn nil\n}\nfunc (testMooMapper) IsBool() bool { return true }\n\nfunc TestTimeMapper(t *testing.T) {\n\tvar cli struct {\n\t\tFlag time.Time `format:\"2006\"`\n\t}\n\tk := mustNew(t, &cli)\n\t_, err := k.Parse([]string{\"--flag=2008\"})\n\tassert.NoError(t, err)\n\texpected, err := time.Parse(\"2006\", \"2008\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, 2008, expected.Year())\n\tassert.Equal(t, expected, cli.Flag)\n}\n\nfunc TestDurationMapper(t *testing.T) {\n\tvar cli struct {\n\t\tFlag time.Duration\n\t}\n\tk := mustNew(t, &cli)\n\t_, err := k.Parse([]string{\"--flag=5s\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, time.Second*5, cli.Flag)\n}\n\nfunc TestDurationMapperJSONResolver(t *testing.T) {\n\tvar cli struct {\n\t\tFlag time.Duration\n\t}\n\tresolver, err := kong.JSON(strings.NewReader(`{\"flag\": 5000000000}`))\n\tassert.NoError(t, err)\n\tk := mustNew(t, &cli, kong.Resolvers(resolver))\n\t_, err = k.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, time.Second*5, cli.Flag)\n}\n\nfunc TestSplitEscaped(t *testing.T) {\n\tassert.Equal(t, []string{\"a\", \"b\"}, kong.SplitEscaped(\"a,b\", ','))\n\tassert.Equal(t, []string{\"a,b\", \"c\"}, kong.SplitEscaped(`a\\,b,c`, ','))\n\tassert.Equal(t, []string{\"a,b,c\"}, kong.SplitEscaped(`a,b,c`, -1))\n}\n\nfunc TestJoinEscaped(t *testing.T) {\n\tassert.Equal(t, `a,b`, kong.JoinEscaped([]string{\"a\", \"b\"}, ','))\n\tassert.Equal(t, `a\\,b,c`, kong.JoinEscaped([]string{`a,b`, `c`}, ','))\n\tassert.Equal(t, kong.JoinEscaped(kong.SplitEscaped(`a\\,b,c`, ','), ','), `a\\,b,c`)\n}\n\nfunc TestMapWithNamedTypes(t *testing.T) {\n\tvar cli struct {\n\t\tTypedValue map[string]string `type:\":moo\"`\n\t\tTypedKey   map[string]string `type:\"upper:\"`\n\t}\n\tk := mustNew(t, &cli, kong.NamedMapper(\"moo\", testMooMapper{}), kong.NamedMapper(\"upper\", testUppercaseMapper{}))\n\t_, err := k.Parse([]string{\"--typed-value\", \"first=5s\", \"--typed-value\", \"second=10s\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string]string{\"first\": \"MOO\", \"second\": \"MOO\"}, cli.TypedValue)\n\t_, err = k.Parse([]string{\"--typed-key\", \"first=5s\", \"--typed-key\", \"second=10s\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string]string{\"FIRST\": \"5s\", \"SECOND\": \"10s\"}, cli.TypedKey)\n}\n\nfunc TestMapWithMultipleValues(t *testing.T) {\n\tvar cli struct {\n\t\tValue map[string]string\n\t}\n\tk := mustNew(t, &cli)\n\t_, err := k.Parse([]string{\"--value=a=b;c=d\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string]string{\"a\": \"b\", \"c\": \"d\"}, cli.Value)\n}\n\nfunc TestMapWithDifferentSeparator(t *testing.T) {\n\tvar cli struct {\n\t\tValue map[string]string `mapsep:\",\"`\n\t}\n\tk := mustNew(t, &cli)\n\t_, err := k.Parse([]string{\"--value=a=b,c=d\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string]string{\"a\": \"b\", \"c\": \"d\"}, cli.Value)\n}\n\nfunc TestMapWithNoSeparator(t *testing.T) {\n\tvar cli struct {\n\t\tSlice []string          `sep:\"none\"`\n\t\tValue map[string]string `mapsep:\"none\"`\n\t}\n\tk := mustNew(t, &cli)\n\t_, err := k.Parse([]string{\"--slice=a,n,c\", \"--value=a=b;n=d\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"a,n,c\"}, cli.Slice)\n\tassert.Equal(t, map[string]string{\"a\": \"b;n=d\"}, cli.Value)\n}\n\nfunc TestURLMapper(t *testing.T) {\n\tvar cli struct {\n\t\tURL *url.URL `arg:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"http://w3.org\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"http://w3.org\", cli.URL.String())\n\t_, err = p.Parse([]string{\":foo\"})\n\tassert.Error(t, err)\n}\n\nfunc TestSliceConsumesRemainingPositionalArgs(t *testing.T) {\n\tvar cli struct {\n\t\tRemainder []string `arg:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--\", \"ls\", \"-lart\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"ls\", \"-lart\"}, cli.Remainder)\n}\n\nfunc TestPassthroughStopsParsing(t *testing.T) {\n\ttype cli struct {\n\t\tInteractive bool     `short:\"i\"`\n\t\tImage       string   `arg:\"\"`\n\t\tArgv        []string `arg:\"\" optional:\"\" passthrough:\"\"`\n\t}\n\n\tvar actual cli\n\tp := mustNew(t, &actual)\n\n\t_, err := p.Parse([]string{\"alpine\", \"sudo\", \"-i\", \"true\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, cli{\n\t\tInteractive: false,\n\t\tImage:       \"alpine\",\n\t\tArgv:        []string{\"sudo\", \"-i\", \"true\"},\n\t}, actual)\n\n\t_, err = p.Parse([]string{\"alpine\", \"-i\", \"sudo\", \"-i\", \"true\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, cli{\n\t\tInteractive: true,\n\t\tImage:       \"alpine\",\n\t\tArgv:        []string{\"sudo\", \"-i\", \"true\"},\n\t}, actual)\n}\n\ntype mappedValue struct {\n\tdecoded string\n}\n\nfunc (m *mappedValue) Decode(ctx *kong.DecodeContext) error {\n\terr := ctx.Scan.PopValueInto(\"mapped\", &m.decoded)\n\treturn err\n}\n\nfunc TestMapperValue(t *testing.T) {\n\tvar cli struct {\n\t\tValue mappedValue `arg:\"\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"foo\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foo\", cli.Value.decoded)\n}\n\nfunc TestFileContentFlag(t *testing.T) {\n\tvar cli struct {\n\t\tFile kong.FileContentFlag\n\t}\n\tf, err := os.CreateTemp(\"\", \"\")\n\tassert.NoError(t, err)\n\tdefer os.Remove(f.Name())\n\tfmt.Fprint(f, \"hello world\")\n\tf.Close()\n\t_, err = mustNew(t, &cli).Parse([]string{\"--file\", f.Name()})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []byte(\"hello world\"), []byte(cli.File))\n}\n\nfunc TestNamedFileContentFlag(t *testing.T) {\n\tvar cli struct {\n\t\tFile kong.NamedFileContentFlag\n\t}\n\tf, err := os.CreateTemp(\"\", \"\")\n\tassert.NoError(t, err)\n\tdefer os.Remove(f.Name())\n\tfmt.Fprint(f, \"hello world\")\n\tf.Close()\n\t_, err = mustNew(t, &cli).Parse([]string{\"--file\", f.Name()})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []byte(\"hello world\"), cli.File.Contents)\n\tassert.Equal(t, f.Name(), cli.File.Filename)\n}\n\nfunc TestNamedSliceTypesDontHaveEllipsis(t *testing.T) {\n\tvar cli struct {\n\t\tFile kong.FileContentFlag\n\t}\n\tb := bytes.NewBuffer(nil)\n\tparser := mustNew(t, &cli, kong.Writers(b, b), kong.Exit(func(int) { panic(\"exit\") }))\n\t// Ensure that --help\n\tassert.Panics(t, func() {\n\t\t_, err := parser.Parse([]string{\"--help\"})\n\t\tassert.NoError(t, err)\n\t})\n\tassert.NotContains(t, b.String(), `--file=FILE-CONTENT-FLAG,...`)\n}\n\nfunc TestCounter(t *testing.T) {\n\tvar cli struct {\n\t\tInt   int     `type:\"counter\" short:\"i\"`\n\t\tUint  uint    `type:\"counter\" short:\"u\"`\n\t\tFloat float64 `type:\"counter\" short:\"f\"`\n\t}\n\tp := mustNew(t, &cli)\n\n\t_, err := p.Parse([]string{\"--int\", \"--int\", \"--int\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 3, cli.Int)\n\n\t_, err = p.Parse([]string{\"--int=5\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 5, cli.Int)\n\n\t_, err = p.Parse([]string{\"-iii\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 3, cli.Int)\n\n\t_, err = p.Parse([]string{\"-uuu\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, uint(3), cli.Uint)\n\n\t_, err = p.Parse([]string{\"-fff\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 3., cli.Float)\n}\n\nfunc TestNumbers(t *testing.T) {\n\ttype CLI struct {\n\t\tF32 float32\n\t\tF64 float64\n\t\tI8  int8\n\t\tI16 int16\n\t\tI32 int32\n\t\tI64 int64\n\t\tU8  uint8\n\t\tU16 uint16\n\t\tU32 uint32\n\t\tU64 uint64\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli)\n\tt.Run(\"Max\", func(t *testing.T) {\n\t\t_, err := p.Parse([]string{\n\t\t\t\"--f-32\", fmt.Sprintf(\"%v\", math.MaxFloat32),\n\t\t\t\"--f-64\", fmt.Sprintf(\"%v\", math.MaxFloat64),\n\t\t\t\"--i-8\", fmt.Sprintf(\"%v\", int8(math.MaxInt8)), //nolint:perfsprint // want int8\n\t\t\t\"--i-16\", fmt.Sprintf(\"%v\", int16(math.MaxInt16)), //nolint:perfsprint // want int16\n\t\t\t\"--i-32\", fmt.Sprintf(\"%v\", int32(math.MaxInt32)), //nolint:perfsprint // want int32\n\t\t\t\"--i-64\", fmt.Sprintf(\"%v\", int64(math.MaxInt64)), //nolint:perfsprint // want int64\n\t\t\t\"--u-8\", fmt.Sprintf(\"%v\", uint8(math.MaxUint8)), //nolint:perfsprint // want uint8\n\t\t\t\"--u-16\", fmt.Sprintf(\"%v\", uint16(math.MaxUint16)), //nolint:perfsprint // want uint16\n\t\t\t\"--u-32\", fmt.Sprintf(\"%v\", uint32(math.MaxUint32)), //nolint:perfsprint // want uint32\n\t\t\t\"--u-64\", fmt.Sprintf(\"%v\", uint64(math.MaxUint64)), //nolint:perfsprint // want uint64\n\t\t})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, CLI{\n\t\t\tF32: math.MaxFloat32,\n\t\t\tF64: math.MaxFloat64,\n\t\t\tI8:  math.MaxInt8,\n\t\t\tI16: math.MaxInt16,\n\t\t\tI32: math.MaxInt32,\n\t\t\tI64: math.MaxInt64,\n\t\t\tU8:  math.MaxUint8,\n\t\t\tU16: math.MaxUint16,\n\t\t\tU32: math.MaxUint32,\n\t\t\tU64: math.MaxUint64,\n\t\t}, cli)\n\t})\n\tt.Run(\"Min\", func(t *testing.T) {\n\t\t_, err := p.Parse([]string{\n\t\t\tfmt.Sprintf(\"--i-8=%v\", int8(math.MinInt8)),\n\t\t\tfmt.Sprintf(\"--i-16=%v\", int16(math.MinInt16)),\n\t\t\tfmt.Sprintf(\"--i-32=%v\", int32(math.MinInt32)),\n\t\t\tfmt.Sprintf(\"--i-64=%v\", int64(math.MinInt64)),\n\t\t\tfmt.Sprintf(\"--u-8=%v\", 0),\n\t\t\tfmt.Sprintf(\"--u-16=%v\", 0),\n\t\t\tfmt.Sprintf(\"--u-32=%v\", 0),\n\t\t\tfmt.Sprintf(\"--u-64=%v\", 0),\n\t\t})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, CLI{\n\t\t\tI8:  math.MinInt8,\n\t\t\tI16: math.MinInt16,\n\t\t\tI32: math.MinInt32,\n\t\t\tI64: math.MinInt64,\n\t\t}, cli)\n\t})\n}\n\nfunc TestJSONLargeNumber(t *testing.T) {\n\t// Make sure that large numbers are not internally converted to\n\t// scientific notation when the mapper parses the values.\n\t// (Scientific notation is e.g. `1e+06` instead of `1000000`.)\n\n\t// Large signed integers:\n\t{\n\t\tvar cli struct {\n\t\t\tN int64\n\t\t}\n\t\tjson := `{\"n\": 1000000}`\n\t\tr, err := kong.JSON(strings.NewReader(json))\n\t\tassert.NoError(t, err)\n\t\tparser := mustNew(t, &cli, kong.Resolvers(r))\n\t\t_, err = parser.Parse([]string{})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, int64(1000000), cli.N)\n\t}\n\n\t// Large unsigned integers:\n\t{\n\t\tvar cli struct {\n\t\t\tN uint64\n\t\t}\n\t\tjson := `{\"n\": 1000000}`\n\t\tr, err := kong.JSON(strings.NewReader(json))\n\t\tassert.NoError(t, err)\n\t\tparser := mustNew(t, &cli, kong.Resolvers(r))\n\t\t_, err = parser.Parse([]string{})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, uint64(1000000), cli.N)\n\t}\n\n\t// Large floats:\n\t{\n\t\tvar cli struct {\n\t\t\tN float64\n\t\t}\n\t\tjson := `{\"n\": 1000000.1}`\n\t\tr, err := kong.JSON(strings.NewReader(json))\n\t\tassert.NoError(t, err)\n\t\tparser := mustNew(t, &cli, kong.Resolvers(r))\n\t\t_, err = parser.Parse([]string{})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, float64(1000000.1), cli.N)\n\t}\n}\n\nfunc TestFileMapper(t *testing.T) {\n\ttype CLI struct {\n\t\tFile *os.File `arg:\"\"`\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"testdata/file.txt\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.File)\n\t_ = cli.File.Close()\n\t_, err = p.Parse([]string{\"testdata/missing.txt\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"missing.txt:\")\n\tassert.IsError(t, err, os.ErrNotExist)\n\t_, err = p.Parse([]string{\"-\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, os.Stdin, cli.File)\n}\n\nfunc TestFileContentMapper(t *testing.T) {\n\ttype CLI struct {\n\t\tFile []byte `type:\"filecontent\"`\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--file\", \"testdata/file.txt\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []byte(`Hello world.`), cli.File)\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--file\", \"testdata/missing.txt\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"missing.txt:\")\n\tassert.IsError(t, err, os.ErrNotExist)\n\tp = mustNew(t, &cli)\n\n\t_, err = p.Parse([]string{\"--file\", \"testdata\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"is a directory\")\n}\n\nfunc TestPathMapperUsingStringPointer(t *testing.T) {\n\ttype CLI struct {\n\t\tPath *string `type:\"path\"`\n\t}\n\tvar cli CLI\n\n\tt.Run(\"With value\", func(t *testing.T) {\n\t\tpwd, err := os.Getwd()\n\t\tassert.NoError(t, err)\n\t\tp := mustNew(t, &cli)\n\t\t_, err = p.Parse([]string{\"--path\", \".\"})\n\t\tassert.NoError(t, err)\n\t\tassert.NotZero(t, cli.Path)\n\t\tassert.Equal(t, pwd, *cli.Path)\n\t})\n\n\tt.Run(\"Zero value\", func(t *testing.T) {\n\t\tp := mustNew(t, &cli)\n\t\t_, err := p.Parse([]string{\"--path\", \"\"})\n\t\tassert.NoError(t, err)\n\t\tassert.NotZero(t, cli.Path)\n\t\twd, err := os.Getwd()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, wd, *cli.Path)\n\t})\n\n\tt.Run(\"Without value\", func(t *testing.T) {\n\t\tp := mustNew(t, &cli)\n\t\t_, err := p.Parse([]string{\"--\"})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, nil, cli.Path)\n\t})\n\n\tt.Run(\"Non-string pointer\", func(t *testing.T) {\n\t\ttype CLI struct {\n\t\t\tPath *any `type:\"path\"`\n\t\t}\n\t\tvar cli CLI\n\t\tp := mustNew(t, &cli)\n\t\t_, err := p.Parse([]string{\"--path\", \"\"})\n\t\tassert.Error(t, err)\n\t\tassert.Contains(t, err.Error(), `\"path\" type must be applied to a string`)\n\t})\n}\n\n//nolint:dupl\nfunc TestExistingFileMapper(t *testing.T) {\n\ttype CLI struct {\n\t\tFile string `type:\"existingfile\"`\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--file\", \"testdata/file.txt\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.File)\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--file\", \"testdata/missing.txt\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"missing.txt:\")\n\tassert.IsError(t, err, os.ErrNotExist)\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--file\", \"testdata/\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"exists but is a directory\")\n}\n\nfunc TestExistingFileMapperSlice(t *testing.T) {\n\ttype CLI struct {\n\t\tFiles []string `type:\"existingfile\"`\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--files\", \"testdata/file.txt\", \"--files\", \"testdata/file.txt\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.Files)\n\tpwd, err := os.Getwd()\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{filepath.Join(pwd, \"testdata\", \"file.txt\"), filepath.Join(pwd, \"testdata\", \"file.txt\")}, cli.Files)\n}\n\nfunc TestExistingFileMapperDefaultMissing(t *testing.T) {\n\ttype CLI struct {\n\t\tFile string `type:\"existingfile\" default:\"testdata/missing.txt\"`\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli)\n\tfile := filepath.Join(\"testdata\", \"file.txt\")\n\t_, err := p.Parse([]string{\"--file\", file})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.File)\n\tassert.Contains(t, cli.File, file)\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"missing.txt:\")\n\tassert.IsError(t, err, os.ErrNotExist)\n}\n\nfunc TestExistingFileMapperDefaultMissingCmds(t *testing.T) {\n\ttype CLI struct {\n\t\tCmdA struct {\n\t\t\tFileA string `type:\"existingfile\" default:\"testdata/aaa-missing.txt\"`\n\t\t\tFileB string `type:\"existingfile\" default:\"testdata/bbb-missing.txt\"`\n\t\t} `cmd:\"\"`\n\t\tCmdC struct {\n\t\t\tFileC string `type:\"existingfile\" default:\"testdata/ccc-missing.txt\"`\n\t\t} `cmd:\"\"`\n\t}\n\tvar cli CLI\n\tfile := filepath.Join(\"testdata\", \"file.txt\")\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"cmd-a\", \"--file-a\", file, \"--file-b\", file})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.CmdA.FileA)\n\tassert.Contains(t, cli.CmdA.FileA, file)\n\tassert.NotZero(t, cli.CmdA.FileB)\n\tassert.Contains(t, cli.CmdA.FileB, file)\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"cmd-a\", \"--file-a\", file})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"bbb-missing.txt:\")\n\tassert.IsError(t, err, os.ErrNotExist)\n}\n\n//nolint:dupl\nfunc TestExistingDirMapper(t *testing.T) {\n\ttype CLI struct {\n\t\tDir string `type:\"existingdir\"`\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"--dir\", \"testdata/\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.Dir)\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--dir\", \"missingdata/\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"missingdata:\")\n\tassert.IsError(t, err, os.ErrNotExist)\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"--dir\", \"testdata/file.txt\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"exists but is not a directory\")\n}\n\nfunc TestExistingDirMapperDefaultMissing(t *testing.T) {\n\ttype CLI struct {\n\t\tDir string `type:\"existingdir\" default:\"missing-dir\"`\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli)\n\tdir := \"testdata\"\n\t_, err := p.Parse([]string{\"--dir\", dir})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.Dir)\n\tassert.Contains(t, cli.Dir, dir)\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"missing-dir:\")\n\tassert.IsError(t, err, os.ErrNotExist)\n}\n\nfunc TestExistingDirMapperDefaultMissingCmds(t *testing.T) {\n\ttype CLI struct {\n\t\tCmdA struct {\n\t\t\tDirA string `type:\"existingdir\" default:\"aaa-missing-dir\"`\n\t\t\tDirB string `type:\"existingdir\" default:\"bbb-missing-dir\"`\n\t\t} `cmd:\"\"`\n\t\tCmdC struct {\n\t\t\tDirC string `type:\"existingdir\" default:\"ccc-missing-dir\"`\n\t\t} `cmd:\"\"`\n\t}\n\tvar cli CLI\n\tdir := \"testdata\"\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"cmd-a\", \"--dir-a\", dir, \"--dir-b\", dir})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.CmdA.DirA)\n\tassert.NotZero(t, cli.CmdA.DirB)\n\tassert.Contains(t, cli.CmdA.DirA, dir)\n\tassert.Contains(t, cli.CmdA.DirB, dir)\n\tp = mustNew(t, &cli)\n\t_, err = p.Parse([]string{\"cmd-a\", \"--dir-a\", dir})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"bbb-missing-dir:\")\n\tassert.IsError(t, err, os.ErrNotExist)\n}\n\nfunc TestMapperPlaceHolder(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string\n\t}\n\tb := bytes.NewBuffer(nil)\n\tk := mustNew(\n\t\tt,\n\t\t&cli,\n\t\tkong.Writers(b, b),\n\t\tkong.ValueMapper(&cli.Flag, testMapperWithPlaceHolder{}),\n\t\tkong.Exit(func(int) { panic(\"exit\") }),\n\t)\n\t// Ensure that --help\n\tassert.Panics(t, func() {\n\t\t_, err := k.Parse([]string{\"--help\"})\n\t\tassert.NoError(t, err)\n\t})\n\tassert.Contains(t, b.String(), \"--flag=/a/b/c\")\n}\n\ntype testMapperWithPlaceHolder struct{}\n\nfunc (t testMapperWithPlaceHolder) Decode(ctx *kong.DecodeContext, target reflect.Value) error {\n\ttarget.SetString(\"hi\")\n\treturn nil\n}\n\nfunc (t testMapperWithPlaceHolder) PlaceHolder(flag *kong.Flag) string {\n\treturn \"/a/b/c\"\n}\n\nfunc TestMapperVarsContributor(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `help:\"Some help with ${avar}\"`\n\t}\n\tb := bytes.NewBuffer(nil)\n\tk := mustNew(\n\t\tt,\n\t\t&cli,\n\t\tkong.Writers(b, b),\n\t\tkong.ValueMapper(&cli.Flag, testMapperVarsContributor{}),\n\t\tkong.Exit(func(int) { panic(\"exit\") }),\n\t)\n\t// Ensure that --help\n\tassert.Panics(t, func() {\n\t\t_, err := k.Parse([]string{\"--help\"})\n\t\tassert.NoError(t, err)\n\t})\n\tassert.Contains(t, b.String(), \"--flag=STRING\")\n\tassert.Contains(t, b.String(), \"Some help with a var\", b.String())\n}\n\ntype testMapperVarsContributor struct{}\n\nfunc (t testMapperVarsContributor) Vars(value *kong.Value) kong.Vars {\n\treturn kong.Vars{\"avar\": \"a var\"}\n}\n\nfunc (t testMapperVarsContributor) Decode(ctx *kong.DecodeContext, target reflect.Value) error {\n\ttarget.SetString(\"hi\")\n\treturn nil\n}\n\nfunc TestValuesThatLookLikeFlags(t *testing.T) {\n\tvar cli struct {\n\t\tSlice []string\n\t\tMap   map[string]string\n\t}\n\tk := mustNew(t, &cli)\n\t_, err := k.Parse([]string{\"--slice\", \"-foo\"})\n\tassert.Error(t, err)\n\t_, err = k.Parse([]string{\"--map\", \"-foo=-bar\"})\n\tassert.Error(t, err)\n\t_, err = k.Parse([]string{\"--slice=-foo\", \"--slice=-bar\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"-foo\", \"-bar\"}, cli.Slice)\n\t_, err = k.Parse([]string{\"--map=-foo=-bar\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string]string{\"-foo\": \"-bar\"}, cli.Map)\n}\n"
        },
        {
          "name": "mapper_windows_test.go",
          "type": "blob",
          "size": 1.1552734375,
          "content": "//go:build windows\n// +build windows\n\npackage kong_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc TestWindowsPathMapper(t *testing.T) {\n\tvar cli struct {\n\t\tPath  string   `short:\"p\" type:\"path\"`\n\t\tFiles []string `short:\"f\" type:\"path\"`\n\t}\n\twd, err := os.Getwd()\n\tassert.NoError(t, err, \"Getwd failed\")\n\tp := mustNew(t, &cli)\n\n\t_, err = p.Parse([]string{`-p`, `c:\\an\\absolute\\path`, `-f`, `c:\\second\\absolute\\path\\`, `-f`, `relative\\path\\file`})\n\tassert.NoError(t, err)\n\tassert.Equal(t, `c:\\an\\absolute\\path`, cli.Path)\n\tassert.Equal(t, []string{`c:\\second\\absolute\\path\\`, wd + `\\relative\\path\\file`}, cli.Files)\n}\n\nfunc TestWindowsFileMapper(t *testing.T) {\n\ttype CLI struct {\n\t\tFile *os.File `arg:\"\"`\n\t}\n\tvar cli CLI\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"testdata\\\\file.txt\"})\n\tassert.NoError(t, err)\n\tassert.NotZero(t, cli.File, \"File should not be nil\")\n\t_ = cli.File.Close()\n\t_, err = p.Parse([]string{\"testdata\\\\missing.txt\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"missing.txt:\")\n\tassert.IsError(t, err, os.ErrNotExist)\n\t_, err = p.Parse([]string{\"-\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, os.Stdin, cli.File)\n}\n"
        },
        {
          "name": "model.go",
          "type": "blob",
          "size": 12.734375,
          "content": "package kong\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// A Visitable component in the model.\ntype Visitable interface {\n\tnode()\n}\n\n// Application is the root of the Kong model.\ntype Application struct {\n\t*Node\n\t// Help flag, if the NoDefaultHelp() option is not specified.\n\tHelpFlag *Flag\n}\n\n// Argument represents a branching positional argument.\ntype Argument = Node\n\n// Command represents a command in the CLI.\ntype Command = Node\n\n// NodeType is an enum representing the type of a Node.\ntype NodeType int\n\n// Node type enumerations.\nconst (\n\tApplicationNode NodeType = iota\n\tCommandNode\n\tArgumentNode\n)\n\n// Node is a branch in the CLI. ie. a command or positional argument.\ntype Node struct {\n\tType        NodeType\n\tParent      *Node\n\tName        string\n\tHelp        string // Short help displayed in summaries.\n\tDetail      string // Detailed help displayed when describing command/arg alone.\n\tGroup       *Group\n\tHidden      bool\n\tFlags       []*Flag\n\tPositional  []*Positional\n\tChildren    []*Node\n\tDefaultCmd  *Node\n\tTarget      reflect.Value // Pointer to the value in the grammar that this Node is associated with.\n\tTag         *Tag\n\tAliases     []string\n\tPassthrough bool // Set to true to stop flag parsing when encountered.\n\tActive      bool // Denotes the node is part of an active branch in the CLI.\n\n\tArgument *Value // Populated when Type is ArgumentNode.\n}\n\nfunc (*Node) node() {}\n\n// Leaf returns true if this Node is a leaf node.\nfunc (n *Node) Leaf() bool {\n\treturn len(n.Children) == 0\n}\n\n// Find a command/argument/flag by pointer to its field.\n//\n// Returns nil if not found. Panics if ptr is not a pointer.\nfunc (n *Node) Find(ptr any) *Node {\n\tkey := reflect.ValueOf(ptr)\n\tif key.Kind() != reflect.Ptr {\n\t\tpanic(\"expected a pointer\")\n\t}\n\treturn n.findNode(key)\n}\n\nfunc (n *Node) findNode(key reflect.Value) *Node {\n\tif n.Target == key {\n\t\treturn n\n\t}\n\tfor _, child := range n.Children {\n\t\tif found := child.findNode(key); found != nil {\n\t\t\treturn found\n\t\t}\n\t}\n\treturn nil\n}\n\n// AllFlags returns flags from all ancestor branches encountered.\n//\n// If \"hide\" is true hidden flags will be omitted.\nfunc (n *Node) AllFlags(hide bool) (out [][]*Flag) {\n\tif n.Parent != nil {\n\t\tout = append(out, n.Parent.AllFlags(hide)...)\n\t}\n\tgroup := []*Flag{}\n\tfor _, flag := range n.Flags {\n\t\tif !hide || !flag.Hidden {\n\t\t\tflag.Active = true\n\t\t\tgroup = append(group, flag)\n\t\t}\n\t}\n\tif len(group) > 0 {\n\t\tout = append(out, group)\n\t}\n\treturn\n}\n\n// Leaves returns the leaf commands/arguments under Node.\n//\n// If \"hidden\" is true hidden leaves will be omitted.\nfunc (n *Node) Leaves(hide bool) (out []*Node) {\n\t_ = Visit(n, func(nd Visitable, next Next) error {\n\t\tif nd == n {\n\t\t\treturn next(nil)\n\t\t}\n\t\tif node, ok := nd.(*Node); ok {\n\t\t\tif hide && node.Hidden {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif len(node.Children) == 0 && node.Type != ApplicationNode {\n\t\t\t\tout = append(out, node)\n\t\t\t}\n\t\t}\n\t\treturn next(nil)\n\t})\n\treturn\n}\n\n// Depth of the command from the application root.\nfunc (n *Node) Depth() int {\n\tdepth := 0\n\tp := n.Parent\n\tfor p != nil && p.Type != ApplicationNode {\n\t\tdepth++\n\t\tp = p.Parent\n\t}\n\treturn depth\n}\n\n// Summary help string for the node (not including application name).\nfunc (n *Node) Summary() string {\n\tsummary := n.Path()\n\tif flags := n.FlagSummary(true); flags != \"\" {\n\t\tsummary += \" \" + flags\n\t}\n\targs := []string{}\n\toptional := 0\n\tfor _, arg := range n.Positional {\n\t\targSummary := arg.Summary()\n\t\tif arg.Tag.Optional {\n\t\t\toptional++\n\t\t\targSummary = strings.TrimRight(argSummary, \"]\")\n\t\t}\n\t\targs = append(args, argSummary)\n\t}\n\tif len(args) != 0 {\n\t\tsummary += \" \" + strings.Join(args, \" \") + strings.Repeat(\"]\", optional)\n\t} else if len(n.Children) > 0 {\n\t\tsummary += \" <command>\"\n\t}\n\tallFlags := n.Flags\n\tif n.Parent != nil {\n\t\tallFlags = append(allFlags, n.Parent.Flags...)\n\t}\n\tfor _, flag := range allFlags {\n\t\tif !flag.Required {\n\t\t\tsummary += \" [flags]\"\n\t\t\tbreak\n\t\t}\n\t}\n\treturn summary\n}\n\n// FlagSummary for the node.\nfunc (n *Node) FlagSummary(hide bool) string {\n\trequired := []string{}\n\tcount := 0\n\tfor _, group := range n.AllFlags(hide) {\n\t\tfor _, flag := range group {\n\t\t\tcount++\n\t\t\tif flag.Required {\n\t\t\t\trequired = append(required, flag.Summary())\n\t\t\t}\n\t\t}\n\t}\n\treturn strings.Join(required, \" \")\n}\n\n// FullPath is like Path() but includes the Application root node.\nfunc (n *Node) FullPath() string {\n\troot := n\n\tfor root.Parent != nil {\n\t\troot = root.Parent\n\t}\n\treturn strings.TrimSpace(root.Name + \" \" + n.Path())\n}\n\n// Vars returns the combined Vars defined by all ancestors of this Node.\nfunc (n *Node) Vars() Vars {\n\tif n == nil {\n\t\treturn Vars{}\n\t}\n\treturn n.Parent.Vars().CloneWith(n.Tag.Vars)\n}\n\n// Path through ancestors to this Node.\nfunc (n *Node) Path() (out string) {\n\tif n.Parent != nil {\n\t\tout += \" \" + n.Parent.Path()\n\t}\n\tswitch n.Type {\n\tcase CommandNode:\n\t\tout += \" \" + n.Name\n\t\tif len(n.Aliases) > 0 {\n\t\t\tout += fmt.Sprintf(\" (%s)\", strings.Join(n.Aliases, \",\"))\n\t\t}\n\tcase ArgumentNode:\n\t\tout += \" \" + \"<\" + n.Name + \">\"\n\tdefault:\n\t}\n\treturn strings.TrimSpace(out)\n}\n\n// ClosestGroup finds the first non-nil group in this node and its ancestors.\nfunc (n *Node) ClosestGroup() *Group {\n\tswitch {\n\tcase n.Group != nil:\n\t\treturn n.Group\n\tcase n.Parent != nil:\n\t\treturn n.Parent.ClosestGroup()\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// A Value is either a flag or a variable positional argument.\ntype Value struct {\n\tFlag            *Flag // Nil if positional argument.\n\tName            string\n\tHelp            string\n\tOrigHelp        string // Original help string, without interpolated variables.\n\tHasDefault      bool\n\tDefault         string\n\tDefaultValue    reflect.Value\n\tEnum            string\n\tMapper          Mapper\n\tTag             *Tag\n\tTarget          reflect.Value\n\tRequired        bool\n\tSet             bool            // Set to true when this value is set through some mechanism.\n\tFormat          string          // Formatting directive, if applicable.\n\tPosition        int             // Position (for positional arguments).\n\tPassthrough     bool            // Deprecated: Use PassthroughMode instead. Set to true to stop flag parsing when encountered.\n\tPassthroughMode PassthroughMode //\n\tActive          bool            // Denotes the value is part of an active branch in the CLI.\n}\n\n// EnumMap returns a map of the enums in this value.\nfunc (v *Value) EnumMap() map[string]bool {\n\tparts := strings.Split(v.Enum, \",\")\n\tout := make(map[string]bool, len(parts))\n\tfor _, part := range parts {\n\t\tout[strings.TrimSpace(part)] = true\n\t}\n\treturn out\n}\n\n// EnumSlice returns a slice of the enums in this value.\nfunc (v *Value) EnumSlice() []string {\n\tparts := strings.Split(v.Enum, \",\")\n\tout := make([]string, len(parts))\n\tfor i, part := range parts {\n\t\tout[i] = strings.TrimSpace(part)\n\t}\n\treturn out\n}\n\n// ShortSummary returns a human-readable summary of the value, not including any placeholders/defaults.\nfunc (v *Value) ShortSummary() string {\n\tif v.Flag != nil {\n\t\treturn fmt.Sprintf(\"--%s\", v.Name)\n\t}\n\targText := \"<\" + v.Name + \">\"\n\tif v.IsCumulative() {\n\t\targText += \" ...\"\n\t}\n\tif !v.Required {\n\t\targText = \"[\" + argText + \"]\"\n\t}\n\treturn argText\n}\n\n// Summary returns a human-readable summary of the value.\nfunc (v *Value) Summary() string {\n\tif v.Flag != nil {\n\t\tif v.IsBool() {\n\t\t\treturn fmt.Sprintf(\"--%s\", v.Name)\n\t\t}\n\t\treturn fmt.Sprintf(\"--%s=%s\", v.Name, v.Flag.FormatPlaceHolder())\n\t}\n\targText := \"<\" + v.Name + \">\"\n\tif v.IsCumulative() {\n\t\targText += \" ...\"\n\t}\n\tif !v.Required {\n\t\targText = \"[\" + argText + \"]\"\n\t}\n\treturn argText\n}\n\n// IsCumulative returns true if the type can be accumulated into.\nfunc (v *Value) IsCumulative() bool {\n\treturn v.IsSlice() || v.IsMap()\n}\n\n// IsSlice returns true if the value is a slice.\nfunc (v *Value) IsSlice() bool {\n\treturn v.Target.Type().Name() == \"\" && v.Target.Kind() == reflect.Slice\n}\n\n// IsMap returns true if the value is a map.\nfunc (v *Value) IsMap() bool {\n\treturn v.Target.Kind() == reflect.Map\n}\n\n// IsBool returns true if the underlying value is a boolean.\nfunc (v *Value) IsBool() bool {\n\tif m, ok := v.Mapper.(BoolMapperExt); ok && m.IsBoolFromValue(v.Target) {\n\t\treturn true\n\t}\n\tif m, ok := v.Mapper.(BoolMapper); ok && m.IsBool() {\n\t\treturn true\n\t}\n\treturn v.Target.Kind() == reflect.Bool\n}\n\n// IsCounter returns true if the value is a counter.\nfunc (v *Value) IsCounter() bool {\n\treturn v.Tag.Type == \"counter\"\n}\n\n// Parse tokens into value, parse, and validate, but do not write to the field.\nfunc (v *Value) Parse(scan *Scanner, target reflect.Value) (err error) {\n\tif target.Kind() == reflect.Ptr && target.IsNil() {\n\t\ttarget.Set(reflect.New(target.Type().Elem()))\n\t}\n\terr = v.Mapper.Decode(&DecodeContext{Value: v, Scan: scan}, target)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: %w\", v.ShortSummary(), err)\n\t}\n\tv.Set = true\n\treturn nil\n}\n\n// Apply value to field.\nfunc (v *Value) Apply(value reflect.Value) {\n\tv.Target.Set(value)\n\tv.Set = true\n}\n\n// ApplyDefault value to field if it is not already set.\nfunc (v *Value) ApplyDefault() error {\n\tif reflectValueIsZero(v.Target) {\n\t\treturn v.Reset()\n\t}\n\tv.Set = true\n\treturn nil\n}\n\n// Reset this value to its default, either the zero value or the parsed result of its envar,\n// or its \"default\" tag.\n//\n// Does not include resolvers.\nfunc (v *Value) Reset() error {\n\tv.Target.Set(reflect.Zero(v.Target.Type()))\n\tif len(v.Tag.Envs) != 0 {\n\t\tfor _, env := range v.Tag.Envs {\n\t\t\tenvar, ok := os.LookupEnv(env)\n\t\t\t// Parse the first non-empty ENV in the list\n\t\t\tif ok {\n\t\t\t\terr := v.Parse(ScanFromTokens(Token{Type: FlagValueToken, Value: envar}), v.Target)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"%s (from envar %s=%q)\", err, env, envar)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\tif v.HasDefault {\n\t\treturn v.Parse(ScanFromTokens(Token{Type: FlagValueToken, Value: v.Default}), v.Target)\n\t}\n\treturn nil\n}\n\nfunc (*Value) node() {}\n\n// A Positional represents a non-branching command-line positional argument.\ntype Positional = Value\n\n// A Flag represents a command-line flag.\ntype Flag struct {\n\t*Value\n\tGroup       *Group // Logical grouping when displaying. May also be used by configuration loaders to group options logically.\n\tXor         []string\n\tAnd         []string\n\tPlaceHolder string\n\tEnvs        []string\n\tAliases     []string\n\tShort       rune\n\tHidden      bool\n\tNegated     bool\n}\n\nfunc (f *Flag) String() string {\n\tout := \"--\" + f.Name\n\tif f.Short != 0 {\n\t\tout = fmt.Sprintf(\"-%c, %s\", f.Short, out)\n\t}\n\tif !f.IsBool() && !f.IsCounter() {\n\t\tout += \"=\" + f.FormatPlaceHolder()\n\t}\n\treturn out\n}\n\n// FormatPlaceHolder formats the placeholder string for a Flag.\nfunc (f *Flag) FormatPlaceHolder() string {\n\tplaceholderHelper, ok := f.Value.Mapper.(PlaceHolderProvider)\n\tif ok {\n\t\treturn placeholderHelper.PlaceHolder(f)\n\t}\n\ttail := \"\"\n\tif f.Value.IsSlice() && f.Value.Tag.Sep != -1 && f.Tag.Type == \"\" {\n\t\ttail += string(f.Value.Tag.Sep) + \"...\"\n\t}\n\tif f.PlaceHolder != \"\" {\n\t\treturn f.PlaceHolder + tail\n\t}\n\tif f.HasDefault {\n\t\tif f.Value.Target.Kind() == reflect.String {\n\t\t\treturn strconv.Quote(f.Default) + tail\n\t\t}\n\t\treturn f.Default + tail\n\t}\n\tif f.Value.IsMap() {\n\t\tif f.Value.Tag.MapSep != -1 && f.Tag.Type == \"\" {\n\t\t\ttail = string(f.Value.Tag.MapSep) + \"...\"\n\t\t}\n\t\treturn \"KEY=VALUE\" + tail\n\t}\n\tif f.Tag != nil && f.Tag.TypeName != \"\" {\n\t\treturn strings.ToUpper(dashedString(f.Tag.TypeName)) + tail\n\t}\n\treturn strings.ToUpper(f.Name) + tail\n}\n\n// Group holds metadata about a command or flag group used when printing help.\ntype Group struct {\n\t// Key is the `group` field tag value used to identify this group.\n\tKey string\n\t// Title is displayed above the grouped items.\n\tTitle string\n\t// Description is optional and displayed under the Title when non empty.\n\t// It can be used to introduce the group's purpose to the user.\n\tDescription string\n}\n\n// This is directly from the Go 1.13 source code.\nfunc reflectValueIsZero(v reflect.Value) bool {\n\tswitch v.Kind() {\n\tcase reflect.Bool:\n\t\treturn !v.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn math.Float64bits(v.Float()) == 0\n\tcase reflect.Complex64, reflect.Complex128:\n\t\tc := v.Complex()\n\t\treturn math.Float64bits(real(c)) == 0 && math.Float64bits(imag(c)) == 0\n\tcase reflect.Array:\n\t\tfor i := 0; i < v.Len(); i++ {\n\t\t\tif !reflectValueIsZero(v.Index(i)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:\n\t\treturn v.IsNil()\n\tcase reflect.String:\n\t\treturn v.Len() == 0\n\tcase reflect.Struct:\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\tif !reflectValueIsZero(v.Field(i)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\t// This should never happens, but will act as a safeguard for\n\t\t// later, as a default value doesn't makes sense here.\n\t\tpanic(&reflect.ValueError{\n\t\t\tMethod: \"reflect.Value.IsZero\",\n\t\t\tKind:   v.Kind(),\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "model_test.go",
          "type": "blob",
          "size": 2.4931640625,
          "content": "package kong_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc TestModelApplicationCommands(t *testing.T) {\n\tvar cli struct {\n\t\tOne struct {\n\t\t\tTwo struct {\n\t\t\t} `kong:\"cmd\"`\n\t\t\tThree struct {\n\t\t\t\tFour struct {\n\t\t\t\t\tFour string `kong:\"arg\"`\n\t\t\t\t} `kong:\"arg\"`\n\t\t\t} `kong:\"cmd\"`\n\t\t} `kong:\"cmd\"`\n\t}\n\tp := mustNew(t, &cli)\n\tactual := []string{}\n\tfor _, cmd := range p.Model.Leaves(false) {\n\t\tactual = append(actual, cmd.Path())\n\t}\n\tassert.Equal(t, []string{\"one two\", \"one three <four>\"}, actual)\n}\n\nfunc TestFlagString(t *testing.T) {\n\tvar cli struct {\n\t\tString                  string\n\t\tDefaultInt              int    `default:\"42\"`\n\t\tDefaultStr              string `default:\"hello\"`\n\t\tPlaceholder             string `placeholder:\"world\"`\n\t\tDefaultPlaceholder      string `default:\"hello\" placeholder:\"world\"`\n\t\tSliceSep                []string\n\t\tSliceNoSep              []string `sep:\"none\"`\n\t\tSliceDefault            []string `default:\"hello\"`\n\t\tSlicePlaceholder        []string `placeholder:\"world\"`\n\t\tSliceDefaultPlaceholder []string `default:\"hello\" placeholder:\"world\"`\n\t\tMapSep                  map[string]string\n\t\tMapNoSep                map[string]string `mapsep:\"none\"`\n\t\tMapDefault              map[string]string `mapsep:\"none\" default:\"hello\"`\n\t\tMapPlaceholder          map[string]string `mapsep:\"none\" placeholder:\"world\"`\n\t\tCounter                 int               `type:\"counter\"`\n\t}\n\ttests := map[string]string{\n\t\t\"help\":                      \"-h, --help\",\n\t\t\"string\":                    \"--string=STRING\",\n\t\t\"default-int\":               \"--default-int=42\",\n\t\t\"default-str\":               `--default-str=\"hello\"`,\n\t\t\"placeholder\":               \"--placeholder=world\",\n\t\t\"default-placeholder\":       \"--default-placeholder=world\",\n\t\t\"slice-sep\":                 \"--slice-sep=SLICE-SEP,...\",\n\t\t\"slice-no-sep\":              \"--slice-no-sep=SLICE-NO-SEP\",\n\t\t\"slice-default\":             \"--slice-default=hello,...\",\n\t\t\"slice-placeholder\":         \"--slice-placeholder=world,...\",\n\t\t\"slice-default-placeholder\": \"--slice-default-placeholder=world,...\",\n\t\t\"map-sep\":                   \"--map-sep=KEY=VALUE;...\",\n\t\t\"map-no-sep\":                \"--map-no-sep=KEY=VALUE\",\n\t\t\"map-default\":               \"--map-default=hello\",\n\t\t\"map-placeholder\":           \"--map-placeholder=world\",\n\t\t\"counter\":                   \"--counter\",\n\t}\n\n\tp := mustNew(t, &cli)\n\tfor _, flag := range p.Model.Flags {\n\t\twant, ok := tests[flag.Name]\n\t\tassert.True(t, ok, \"unknown flag name: %s\", flag.Name)\n\t\tassert.Equal(t, want, flag.String())\n\t}\n}\n"
        },
        {
          "name": "negatable.go",
          "type": "blob",
          "size": 0.5498046875,
          "content": "package kong\n\n// negatableDefault is a placeholder value for the Negatable tag to indicate\n// the negated flag is --no-<flag-name>. This is needed as at the time of\n// parsing a tag, the field's flag name is not yet known.\nconst negatableDefault = \"_\"\n\n// negatableFlagName returns the name of the flag for a negatable field, or\n// an empty string if the field is not negatable.\nfunc negatableFlagName(name, negation string) string {\n\tswitch negation {\n\tcase \"\":\n\t\treturn \"\"\n\tcase negatableDefault:\n\t\treturn \"--no-\" + name\n\tdefault:\n\t\treturn \"--\" + negation\n\t}\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 12.8193359375,
          "content": "package kong\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// An Option applies optional changes to the Kong application.\ntype Option interface {\n\tApply(k *Kong) error\n}\n\n// OptionFunc is function that adheres to the Option interface.\ntype OptionFunc func(k *Kong) error\n\nfunc (o OptionFunc) Apply(k *Kong) error { return o(k) } //nolint: revive\n\n// Vars sets the variables to use for interpolation into help strings and default values.\n//\n// See README for details.\ntype Vars map[string]string\n\n// Apply lets Vars act as an Option.\nfunc (v Vars) Apply(k *Kong) error {\n\tfor key, value := range v {\n\t\tk.vars[key] = value\n\t}\n\treturn nil\n}\n\n// CloneWith clones the current Vars and merges \"vars\" onto the clone.\nfunc (v Vars) CloneWith(vars Vars) Vars {\n\tout := make(Vars, len(v)+len(vars))\n\tfor key, value := range v {\n\t\tout[key] = value\n\t}\n\tfor key, value := range vars {\n\t\tout[key] = value\n\t}\n\treturn out\n}\n\n// Exit overrides the function used to terminate. This is useful for testing or interactive use.\nfunc Exit(exit func(int)) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.Exit = exit\n\t\treturn nil\n\t})\n}\n\ntype embedded struct {\n\tstrct any\n\ttags  []string\n}\n\n// Embed a struct into the root of the CLI.\n//\n// \"strct\" must be a pointer to a structure.\nfunc Embed(strct any, tags ...string) Option {\n\tt := reflect.TypeOf(strct)\n\tif t.Kind() != reflect.Ptr || t.Elem().Kind() != reflect.Struct {\n\t\tpanic(\"kong: Embed() must be called with a pointer to a struct\")\n\t}\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.embedded = append(k.embedded, embedded{strct, tags})\n\t\treturn nil\n\t})\n}\n\ntype dynamicCommand struct {\n\tname  string\n\thelp  string\n\tgroup string\n\ttags  []string\n\tcmd   any\n}\n\n// DynamicCommand registers a dynamically constructed command with the root of the CLI.\n//\n// This is useful for command-line structures that are extensible via user-provided plugins.\n//\n// \"tags\" is a list of extra tag strings to parse, in the form <key>:\"<value>\".\nfunc DynamicCommand(name, help, group string, cmd any, tags ...string) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tif run := getMethod(reflect.Indirect(reflect.ValueOf(cmd)), \"Run\"); !run.IsValid() {\n\t\t\treturn fmt.Errorf(\"kong: DynamicCommand %q must be a type with a 'Run' method; got %T\", name, cmd)\n\t\t}\n\n\t\tk.dynamicCommands = append(k.dynamicCommands, &dynamicCommand{\n\t\t\tname:  name,\n\t\t\thelp:  help,\n\t\t\tgroup: group,\n\t\t\tcmd:   cmd,\n\t\t\ttags:  tags,\n\t\t})\n\t\treturn nil\n\t})\n}\n\n// NoDefaultHelp disables the default help flags.\nfunc NoDefaultHelp() Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.noDefaultHelp = true\n\t\treturn nil\n\t})\n}\n\n// PostBuild provides read/write access to kong.Kong after initial construction of the model is complete but before\n// parsing occurs.\n//\n// This is useful for, e.g., adding short options to flags, updating help, etc.\nfunc PostBuild(fn func(*Kong) error) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.postBuildOptions = append(k.postBuildOptions, OptionFunc(fn))\n\t\treturn nil\n\t})\n}\n\n// Name overrides the application name.\nfunc Name(name string) Option {\n\treturn PostBuild(func(k *Kong) error {\n\t\tk.Model.Name = name\n\t\treturn nil\n\t})\n}\n\n// Description sets the application description.\nfunc Description(description string) Option {\n\treturn PostBuild(func(k *Kong) error {\n\t\tk.Model.Help = description\n\t\treturn nil\n\t})\n}\n\n// TypeMapper registers a mapper to a type.\nfunc TypeMapper(typ reflect.Type, mapper Mapper) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.registry.RegisterType(typ, mapper)\n\t\treturn nil\n\t})\n}\n\n// KindMapper registers a mapper to a kind.\nfunc KindMapper(kind reflect.Kind, mapper Mapper) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.registry.RegisterKind(kind, mapper)\n\t\treturn nil\n\t})\n}\n\n// ValueMapper registers a mapper to a field value.\nfunc ValueMapper(ptr any, mapper Mapper) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.registry.RegisterValue(ptr, mapper)\n\t\treturn nil\n\t})\n}\n\n// NamedMapper registers a mapper to a name.\nfunc NamedMapper(name string, mapper Mapper) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.registry.RegisterName(name, mapper)\n\t\treturn nil\n\t})\n}\n\n// Writers overrides the default writers. Useful for testing or interactive use.\nfunc Writers(stdout, stderr io.Writer) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.Stdout = stdout\n\t\tk.Stderr = stderr\n\t\treturn nil\n\t})\n}\n\n// Bind binds values for hooks and Run() function arguments.\n//\n// Any arguments passed will be available to the receiving hook functions, but may be omitted. Additionally, *Kong and\n// the current *Context will also be made available.\n//\n// There are two hook points:\n//\n//\t\t\tBeforeApply(...) error\n//\t  \tAfterApply(...) error\n//\n// Called before validation/assignment, and immediately after validation/assignment, respectively.\nfunc Bind(args ...any) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.bindings.add(args...)\n\t\treturn nil\n\t})\n}\n\n// BindTo allows binding of implementations to interfaces.\n//\n//\tBindTo(impl, (*iface)(nil))\nfunc BindTo(impl, iface any) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.bindings.addTo(impl, iface)\n\t\treturn nil\n\t})\n}\n\n// BindToProvider binds an injected value to a provider function.\n//\n// The provider function must have the signature:\n//\n//\tfunc() (any, error)\n//\n// This is useful when the Run() function of different commands require different values that may\n// not all be initialisable from the main() function.\nfunc BindToProvider(provider any) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\treturn k.bindings.addProvider(provider)\n\t})\n}\n\n// Help printer to use.\nfunc Help(help HelpPrinter) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.help = help\n\t\treturn nil\n\t})\n}\n\n// ShortHelp configures the short usage message.\n//\n// It should be used together with kong.ShortUsageOnError() to display a\n// custom short usage message on errors.\nfunc ShortHelp(shortHelp HelpPrinter) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.shortHelp = shortHelp\n\t\treturn nil\n\t})\n}\n\n// HelpFormatter configures how the help text is formatted.\n//\n// Deprecated: Use ValueFormatter() instead.\nfunc HelpFormatter(helpFormatter HelpValueFormatter) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.helpFormatter = helpFormatter\n\t\treturn nil\n\t})\n}\n\n// ValueFormatter configures how the help text is formatted.\nfunc ValueFormatter(helpFormatter HelpValueFormatter) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.helpFormatter = helpFormatter\n\t\treturn nil\n\t})\n}\n\n// ConfigureHelp sets the HelpOptions to use for printing help.\nfunc ConfigureHelp(options HelpOptions) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.helpOptions = options\n\t\treturn nil\n\t})\n}\n\n// AutoGroup automatically assigns groups to flags.\nfunc AutoGroup(format func(parent Visitable, flag *Flag) *Group) Option {\n\treturn PostBuild(func(kong *Kong) error {\n\t\tparents := []Visitable{kong.Model}\n\t\treturn Visit(kong.Model, func(node Visitable, next Next) error {\n\t\t\tif flag, ok := node.(*Flag); ok && flag.Group == nil {\n\t\t\t\tflag.Group = format(parents[len(parents)-1], flag)\n\t\t\t}\n\t\t\tparents = append(parents, node)\n\t\t\tdefer func() { parents = parents[:len(parents)-1] }()\n\t\t\treturn next(nil)\n\t\t})\n\t})\n}\n\n// Groups associates `group` field tags with group metadata.\n//\n// This option is used to simplify Kong tags while providing\n// rich group information such as title and optional description.\n//\n// Each key in the \"groups\" map corresponds to the value of a\n// `group` Kong tag, while the first line of the value will be\n// the title, and subsequent lines if any will be the description of\n// the group.\n//\n// See also ExplicitGroups for a more structured alternative.\ntype Groups map[string]string\n\nfunc (g Groups) Apply(k *Kong) error { //nolint: revive\n\tfor key, info := range g {\n\t\tlines := strings.Split(info, \"\\n\")\n\t\ttitle := strings.TrimSpace(lines[0])\n\t\tdescription := \"\"\n\t\tif len(lines) > 1 {\n\t\t\tdescription = strings.TrimSpace(strings.Join(lines[1:], \"\\n\"))\n\t\t}\n\t\tk.groups = append(k.groups, Group{\n\t\t\tKey:         key,\n\t\t\tTitle:       title,\n\t\t\tDescription: description,\n\t\t})\n\t}\n\treturn nil\n}\n\n// ExplicitGroups associates `group` field tags with their metadata.\n//\n// It can be used to provide a title or header to a command or flag group.\nfunc ExplicitGroups(groups []Group) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.groups = groups\n\t\treturn nil\n\t})\n}\n\n// UsageOnError configures Kong to display context-sensitive usage if FatalIfErrorf is called with an error.\nfunc UsageOnError() Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.usageOnError = fullUsage\n\t\treturn nil\n\t})\n}\n\n// ShortUsageOnError configures Kong to display context-sensitive short\n// usage if FatalIfErrorf is called with an error. The default short\n// usage message can be overridden with kong.ShortHelp(...).\nfunc ShortUsageOnError() Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.usageOnError = shortUsage\n\t\treturn nil\n\t})\n}\n\n// ClearResolvers clears all existing resolvers.\nfunc ClearResolvers() Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.resolvers = nil\n\t\treturn nil\n\t})\n}\n\n// Resolvers registers flag resolvers.\nfunc Resolvers(resolvers ...Resolver) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.resolvers = append(k.resolvers, resolvers...)\n\t\treturn nil\n\t})\n}\n\n// IgnoreFields will cause kong.New() to skip field names that match any\n// of the provided regex patterns. This is useful if you are not able to add a\n// kong=\"-\" struct tag to a struct/element before the call to New.\n//\n// Example: When referencing protoc generated structs, you will likely want to\n// ignore/skip XXX_* fields.\nfunc IgnoreFields(regexes ...string) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tfor _, r := range regexes {\n\t\t\tif r == \"\" {\n\t\t\t\treturn errors.New(\"regex input cannot be empty\")\n\t\t\t}\n\n\t\t\tre, err := regexp.Compile(r)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to compile regex: %v\", err)\n\t\t\t}\n\n\t\t\tk.ignoreFields = append(k.ignoreFields, re)\n\t\t}\n\n\t\treturn nil\n\t})\n}\n\n// ConfigurationLoader is a function that builds a resolver from a file.\ntype ConfigurationLoader func(r io.Reader) (Resolver, error)\n\n// Configuration provides Kong with support for loading defaults from a set of configuration files.\n//\n// Paths will be opened in order, and \"loader\" will be used to provide a Resolver which is registered with Kong.\n//\n// Note: The JSON function is a ConfigurationLoader.\n//\n// ~ and variable expansion will occur on the provided paths.\nfunc Configuration(loader ConfigurationLoader, paths ...string) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.loader = loader\n\t\tfor _, path := range paths {\n\t\t\tf, err := os.Open(ExpandPath(path))\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) || os.IsPermission(err) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf.Close()\n\n\t\t\tresolver, err := k.LoadConfig(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"%s: %v\", path, err)\n\t\t\t}\n\t\t\tif resolver != nil {\n\t\t\t\tk.resolvers = append(k.resolvers, resolver)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// ExpandPath is a helper function to expand a relative or home-relative path to an absolute path.\n//\n// eg. ~/.someconf -> /home/alec/.someconf\nfunc ExpandPath(path string) string {\n\tif filepath.IsAbs(path) {\n\t\treturn path\n\t}\n\tif strings.HasPrefix(path, \"~/\") {\n\t\tuser, err := user.Current()\n\t\tif err != nil {\n\t\t\treturn path\n\t\t}\n\t\treturn filepath.Join(user.HomeDir, path[2:])\n\t}\n\tabspath, err := filepath.Abs(path)\n\tif err != nil {\n\t\treturn path\n\t}\n\treturn abspath\n}\n\nfunc siftStrings(ss []string, filter func(s string) bool) []string {\n\ti := 0\n\tss = append([]string(nil), ss...)\n\tfor _, s := range ss {\n\t\tif filter(s) {\n\t\t\tss[i] = s\n\t\t\ti++\n\t\t}\n\t}\n\treturn ss[0:i]\n}\n\n// DefaultEnvars option inits environment names for flags.\n// The name will not generate if tag \"env\" is \"-\".\n// Predefined environment variables are skipped.\n//\n// For example:\n//\n//\t--some.value -> PREFIX_SOME_VALUE\nfunc DefaultEnvars(prefix string) Option {\n\tprocessFlag := func(flag *Flag) {\n\t\tswitch env := flag.Envs; {\n\t\tcase flag.Name == \"help\":\n\t\t\treturn\n\t\tcase len(env) == 1 && env[0] == \"-\":\n\t\t\tflag.Envs = nil\n\t\t\treturn\n\t\tcase len(env) > 0:\n\t\t\treturn\n\t\t}\n\t\treplacer := strings.NewReplacer(\"-\", \"_\", \".\", \"_\")\n\t\tnames := append([]string{prefix}, camelCase(replacer.Replace(flag.Name))...)\n\t\tnames = siftStrings(names, func(s string) bool { return !(s == \"_\" || strings.TrimSpace(s) == \"\") })\n\t\tname := strings.ToUpper(strings.Join(names, \"_\"))\n\t\tflag.Envs = append(flag.Envs, name)\n\t\tflag.Value.Tag.Envs = append(flag.Value.Tag.Envs, name)\n\t}\n\n\tvar processNode func(node *Node)\n\tprocessNode = func(node *Node) {\n\t\tfor _, flag := range node.Flags {\n\t\t\tprocessFlag(flag)\n\t\t}\n\t\tfor _, node := range node.Children {\n\t\t\tprocessNode(node)\n\t\t}\n\t}\n\n\treturn PostBuild(func(k *Kong) error {\n\t\tprocessNode(k.Model.Node)\n\t\treturn nil\n\t})\n}\n\n// FlagNamer allows you to override the default kebab-case automated flag name generation.\nfunc FlagNamer(namer func(fieldName string) string) Option {\n\treturn OptionFunc(func(k *Kong) error {\n\t\tk.flagNamer = namer\n\t\treturn nil\n\t})\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 2.9892578125,
          "content": "package kong\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc TestOptions(t *testing.T) {\n\tvar cli struct{}\n\tp, err := New(&cli, Name(\"name\"), Description(\"description\"), Writers(nil, nil), Exit(nil))\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"name\", p.Model.Name)\n\tassert.Equal(t, \"description\", p.Model.Help)\n\tassert.Zero(t, p.Stdout)\n\tassert.Zero(t, p.Stderr)\n\tassert.Zero(t, p.Exit)\n}\n\ntype impl string\n\nfunc (impl) Method() {}\n\nfunc TestBindTo(t *testing.T) {\n\ttype iface interface {\n\t\tMethod()\n\t}\n\n\tsaw := \"\"\n\tmethod := func(i iface) error {\n\t\tsaw = string(i.(impl)) //nolint\n\t\treturn nil\n\t}\n\n\tvar cli struct{}\n\n\tp, err := New(&cli, BindTo(impl(\"foo\"), (*iface)(nil)))\n\tassert.NoError(t, err)\n\terr = callFunction(reflect.ValueOf(method), p.bindings)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foo\", saw)\n}\n\nfunc TestInvalidCallback(t *testing.T) {\n\ttype iface interface {\n\t\tMethod()\n\t}\n\n\tsaw := \"\"\n\tmethod := func(i iface) string {\n\t\tsaw = string(i.(impl)) //nolint\n\t\treturn saw\n\t}\n\n\tvar cli struct{}\n\n\tp, err := New(&cli, BindTo(impl(\"foo\"), (*iface)(nil)))\n\tassert.NoError(t, err)\n\terr = callFunction(reflect.ValueOf(method), p.bindings)\n\tassert.EqualError(t, err, `return value of func(kong.iface) string must implement \"error\"`)\n}\n\ntype zrror struct{}\n\nfunc (*zrror) Error() string {\n\treturn \"error\"\n}\n\nfunc TestCallbackCustomError(t *testing.T) {\n\ttype iface interface {\n\t\tMethod()\n\t}\n\n\tsaw := \"\"\n\tmethod := func(i iface) *zrror {\n\t\tsaw = string(i.(impl)) //nolint\n\t\treturn nil\n\t}\n\n\tvar cli struct{}\n\n\tp, err := New(&cli, BindTo(impl(\"foo\"), (*iface)(nil)))\n\tassert.NoError(t, err)\n\terr = callFunction(reflect.ValueOf(method), p.bindings)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foo\", saw)\n}\n\ntype bindToProviderCLI struct {\n\tFilled bool `default:\"true\"`\n\tCalled bool\n\tCmd    bindToProviderCmd `cmd:\"\"`\n}\n\ntype boundThing struct {\n\tFilled bool\n}\n\ntype bindToProviderCmd struct{}\n\nfunc (*bindToProviderCmd) Run(cli *bindToProviderCLI, b *boundThing) error {\n\tcli.Called = true\n\treturn nil\n}\n\nfunc TestBindToProvider(t *testing.T) {\n\tvar cli bindToProviderCLI\n\tapp, err := New(&cli, BindToProvider(func(cli *bindToProviderCLI) (*boundThing, error) {\n\t\tassert.True(t, cli.Filled, \"CLI struct should have already been populated by Kong\")\n\t\treturn &boundThing{Filled: cli.Filled}, nil\n\t}))\n\tassert.NoError(t, err)\n\tctx, err := app.Parse([]string{\"cmd\"})\n\tassert.NoError(t, err)\n\terr = ctx.Run()\n\tassert.NoError(t, err)\n\tassert.True(t, cli.Called)\n}\n\nfunc TestFlagNamer(t *testing.T) {\n\tvar cli struct {\n\t\tSomeFlag string\n\t}\n\tapp, err := New(&cli, FlagNamer(strings.ToUpper))\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"SOMEFLAG\", app.Model.Flags[1].Name)\n}\n\ntype npError string\n\nfunc (e npError) Error() string {\n\treturn \"ERROR: \" + string(e)\n}\n\nfunc TestCallbackNonPointerError(t *testing.T) {\n\tmethod := func() error {\n\t\treturn npError(\"failed\")\n\t}\n\n\tvar cli struct{}\n\n\tp, err := New(&cli)\n\tassert.NoError(t, err)\n\terr = callFunction(reflect.ValueOf(method), p.bindings)\n\tassert.EqualError(t, err, \"ERROR: failed\")\n}\n"
        },
        {
          "name": "renovate.json5",
          "type": "blob",
          "size": 0.41015625,
          "content": "{\n  $schema: \"https://docs.renovatebot.com/renovate-schema.json\",\n  extends: [\n    \"config:recommended\",\n    \":semanticCommits\",\n    \":semanticCommitTypeAll(chore)\",\n    \":semanticCommitScope(deps)\",\n    \"group:allNonMajor\",\n    \"schedule:earlyMondays\", // Run once a week.\n  ],\n  packageRules: [\n    {\n      \"matchPackageNames\": [\"golangci-lint\"],\n      \"matchManagers\": [\"hermit\"],\n      \"enabled\": false\n    },\n  ]\n}\n"
        },
        {
          "name": "resolver.go",
          "type": "blob",
          "size": 1.8369140625,
          "content": "package kong\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"strings\"\n)\n\n// A Resolver resolves a Flag value from an external source.\ntype Resolver interface {\n\t// Validate configuration against Application.\n\t//\n\t// This can be used to validate that all provided configuration is valid within  this application.\n\tValidate(app *Application) error\n\n\t// Resolve the value for a Flag.\n\tResolve(context *Context, parent *Path, flag *Flag) (any, error)\n}\n\n// ResolverFunc is a convenience type for non-validating Resolvers.\ntype ResolverFunc func(context *Context, parent *Path, flag *Flag) (any, error)\n\nvar _ Resolver = ResolverFunc(nil)\n\nfunc (r ResolverFunc) Resolve(context *Context, parent *Path, flag *Flag) (any, error) { //nolint: revive\n\treturn r(context, parent, flag)\n}\nfunc (r ResolverFunc) Validate(app *Application) error { return nil } //nolint: revive\n\n// JSON returns a Resolver that retrieves values from a JSON source.\n//\n// Flag names are used as JSON keys indirectly, by tring snake_case and camelCase variants.\nfunc JSON(r io.Reader) (Resolver, error) {\n\tvalues := map[string]any{}\n\terr := json.NewDecoder(r).Decode(&values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar f ResolverFunc = func(context *Context, parent *Path, flag *Flag) (any, error) {\n\t\tname := strings.ReplaceAll(flag.Name, \"-\", \"_\")\n\t\tsnakeCaseName := snakeCase(flag.Name)\n\t\traw, ok := values[name]\n\t\tif ok {\n\t\t\treturn raw, nil\n\t\t} else if raw, ok = values[snakeCaseName]; ok {\n\t\t\treturn raw, nil\n\t\t}\n\t\traw = values\n\t\tfor _, part := range strings.Split(name, \".\") {\n\t\t\tif values, ok := raw.(map[string]any); ok {\n\t\t\t\traw, ok = values[part]\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t}\n\t\treturn raw, nil\n\t}\n\n\treturn f, nil\n}\n\nfunc snakeCase(name string) string {\n\tname = strings.Join(strings.Split(strings.Title(name), \"-\"), \"\")\n\treturn strings.ToLower(name[:1]) + name[1:]\n}\n"
        },
        {
          "name": "resolver_test.go",
          "type": "blob",
          "size": 8.390625,
          "content": "package kong_test\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n\t\"github.com/alecthomas/kong\"\n)\n\ntype envMap map[string]string\n\nfunc newEnvParser(t *testing.T, cli any, env envMap, options ...kong.Option) *kong.Kong {\n\tt.Helper()\n\tfor name, value := range env {\n\t\tt.Setenv(name, value)\n\t}\n\tparser := mustNew(t, cli, options...)\n\treturn parser\n}\n\nfunc TestEnvarsFlagBasic(t *testing.T) {\n\tvar cli struct {\n\t\tString string `env:\"KONG_STRING\"`\n\t\tSlice  []int  `env:\"KONG_SLICE\"`\n\t\tInterp string `env:\"${kongInterp}\"`\n\t}\n\tkongInterpEnv := \"KONG_INTERP\"\n\tparser := newEnvParser(t, &cli,\n\t\tenvMap{\n\t\t\t\"KONG_STRING\": \"bye\",\n\t\t\t\"KONG_SLICE\":  \"5,2,9\",\n\t\t\t\"KONG_INTERP\": \"foo\",\n\t\t},\n\t\tkong.Vars{\n\t\t\t\"kongInterp\": kongInterpEnv,\n\t\t},\n\t)\n\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"bye\", cli.String)\n\tassert.Equal(t, []int{5, 2, 9}, cli.Slice)\n\tassert.Equal(t, \"foo\", cli.Interp)\n}\n\nfunc TestEnvarsFlagMultiple(t *testing.T) {\n\tvar cli struct {\n\t\tFirstENVPresent  string `env:\"KONG_TEST1_1,KONG_TEST1_2\"`\n\t\tSecondENVPresent string `env:\"KONG_TEST2_1,KONG_TEST2_2\"`\n\t}\n\tparser := newEnvParser(t, &cli,\n\t\tenvMap{\n\t\t\t\"KONG_TEST1_1\": \"value1.1\",\n\t\t\t\"KONG_TEST1_2\": \"value1.2\",\n\t\t\t\"KONG_TEST2_2\": \"value2.2\",\n\t\t},\n\t)\n\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"value1.1\", cli.FirstENVPresent)\n\tassert.Equal(t, \"value2.2\", cli.SecondENVPresent)\n}\n\nfunc TestEnvarsFlagOverride(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `env:\"KONG_FLAG\"`\n\t}\n\tparser := newEnvParser(t, &cli, envMap{\"KONG_FLAG\": \"bye\"})\n\n\t_, err := parser.Parse([]string{\"--flag=hello\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"hello\", cli.Flag)\n}\n\nfunc TestEnvarsTag(t *testing.T) {\n\tvar cli struct {\n\t\tSlice []int `env:\"KONG_NUMBERS\"`\n\t}\n\tparser := newEnvParser(t, &cli, envMap{\"KONG_NUMBERS\": \"5,2,9\"})\n\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int{5, 2, 9}, cli.Slice)\n}\n\nfunc TestEnvarsEnvPrefix(t *testing.T) {\n\ttype Anonymous struct {\n\t\tSlice []int `env:\"NUMBERS\"`\n\t}\n\tvar cli struct {\n\t\tAnonymous `envprefix:\"KONG_\"`\n\t}\n\tparser := newEnvParser(t, &cli, envMap{\"KONG_NUMBERS\": \"1,2,3\"})\n\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int{1, 2, 3}, cli.Slice)\n}\n\nfunc TestEnvarsEnvPrefixMultiple(t *testing.T) {\n\ttype Anonymous struct {\n\t\tSlice1 []int `env:\"NUMBERS1_1,NUMBERS1_2\"`\n\t\tSlice2 []int `env:\"NUMBERS2_1,NUMBERS2_2\"`\n\t}\n\tvar cli struct {\n\t\tAnonymous `envprefix:\"KONG_\"`\n\t}\n\tparser := newEnvParser(t, &cli, envMap{\"KONG_NUMBERS1_1\": \"1,2,3\", \"KONG_NUMBERS2_2\": \"5,6,7\"})\n\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int{1, 2, 3}, cli.Slice1)\n\tassert.Equal(t, []int{5, 6, 7}, cli.Slice2)\n}\n\nfunc TestEnvarsNestedEnvPrefix(t *testing.T) {\n\ttype NestedAnonymous struct {\n\t\tString string `env:\"STRING\"`\n\t}\n\ttype Anonymous struct {\n\t\tNestedAnonymous `envprefix:\"ANON_\"`\n\t}\n\tvar cli struct {\n\t\tAnonymous `envprefix:\"KONG_\"`\n\t}\n\tparser := newEnvParser(t, &cli, envMap{\"KONG_ANON_STRING\": \"abc\"})\n\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"abc\", cli.String)\n}\n\nfunc TestEnvarsWithDefault(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `env:\"KONG_FLAG\" default:\"default\"`\n\t}\n\tparser := newEnvParser(t, &cli, envMap{})\n\n\t_, err := parser.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"default\", cli.Flag)\n\n\tparser = newEnvParser(t, &cli, envMap{\"KONG_FLAG\": \"moo\"})\n\t_, err = parser.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"moo\", cli.Flag)\n}\n\nfunc TestEnv(t *testing.T) {\n\ttype Embed struct {\n\t\tFlag string\n\t}\n\ttype Cli struct {\n\t\tOne   Embed `prefix:\"one-\" embed:\"\"`\n\t\tTwo   Embed `prefix:\"two.\" embed:\"\"`\n\t\tThree Embed `prefix:\"three_\" embed:\"\"`\n\t\tFour  Embed `prefix:\"four_\" embed:\"\"`\n\t\tFive  bool\n\t\tSix   bool `env:\"-\"`\n\t}\n\n\tvar cli Cli\n\n\texpected := Cli{\n\t\tOne:   Embed{Flag: \"one\"},\n\t\tTwo:   Embed{Flag: \"two\"},\n\t\tThree: Embed{Flag: \"three\"},\n\t\tFour:  Embed{Flag: \"four\"},\n\t\tFive:  true,\n\t}\n\n\t// With the prefix\n\tparser := newEnvParser(t, &cli, envMap{\n\t\t\"KONG_ONE_FLAG\":   \"one\",\n\t\t\"KONG_TWO_FLAG\":   \"two\",\n\t\t\"KONG_THREE_FLAG\": \"three\",\n\t\t\"KONG_FOUR_FLAG\":  \"four\",\n\t\t\"KONG_FIVE\":       \"true\",\n\t\t\"KONG_SIX\":        \"true\",\n\t}, kong.DefaultEnvars(\"KONG\"))\n\n\t_, err := parser.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, cli)\n\n\t// Without the prefix\n\tparser = newEnvParser(t, &cli, envMap{\n\t\t\"ONE_FLAG\":   \"one\",\n\t\t\"TWO_FLAG\":   \"two\",\n\t\t\"THREE_FLAG\": \"three\",\n\t\t\"FOUR_FLAG\":  \"four\",\n\t\t\"FIVE\":       \"true\",\n\t\t\"SIX\":        \"true\",\n\t}, kong.DefaultEnvars(\"\"))\n\n\t_, err = parser.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, cli)\n}\n\nfunc TestJSONBasic(t *testing.T) {\n\ttype Embed struct {\n\t\tString string\n\t}\n\n\tvar cli struct {\n\t\tString          string\n\t\tSlice           []int\n\t\tSliceWithCommas []string\n\t\tBool            bool\n\n\t\tOne Embed `prefix:\"one.\" embed:\"\"`\n\t\tTwo Embed `prefix:\"two.\" embed:\"\"`\n\t}\n\n\tjson := `{\n\t\t\"string\": \"ðŸ•\",\n\t\t\"slice\": [5, 8],\n\t\t\"bool\": true,\n\t\t\"sliceWithCommas\": [\"a,b\", \"c\"],\n\t\t\"one\":{\n\t\t\t\"string\": \"one value\"\n\t\t},\n\t\t\"two.string\": \"two value\"\n\t}`\n\n\tr, err := kong.JSON(strings.NewReader(json))\n\tassert.NoError(t, err)\n\n\tparser := mustNew(t, &cli, kong.Resolvers(r))\n\t_, err = parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"ðŸ•\", cli.String)\n\tassert.Equal(t, []int{5, 8}, cli.Slice)\n\tassert.Equal(t, []string{\"a,b\", \"c\"}, cli.SliceWithCommas)\n\tassert.Equal(t, \"one value\", cli.One.String)\n\tassert.Equal(t, \"two value\", cli.Two.String)\n\tassert.True(t, cli.Bool)\n}\n\ntype testUppercaseMapper struct{}\n\nfunc (testUppercaseMapper) Decode(ctx *kong.DecodeContext, target reflect.Value) error {\n\tvar value string\n\terr := ctx.Scan.PopValueInto(\"lowercase\", &value)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttarget.SetString(strings.ToUpper(value))\n\treturn nil\n}\n\nfunc TestResolversWithMappers(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `env:\"KONG_MOO\" type:\"upper\"`\n\t}\n\n\tt.Setenv(\"KONG_MOO\", \"meow\")\n\n\tparser := newEnvParser(t, &cli,\n\t\tenvMap{\"KONG_MOO\": \"meow\"},\n\t\tkong.NamedMapper(\"upper\", testUppercaseMapper{}),\n\t)\n\t_, err := parser.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"MEOW\", cli.Flag)\n}\n\nfunc TestResolverWithBool(t *testing.T) {\n\tvar cli struct {\n\t\tBool bool\n\t}\n\n\tvar resolver kong.ResolverFunc = func(context *kong.Context, parent *kong.Path, flag *kong.Flag) (any, error) {\n\t\tif flag.Name == \"bool\" {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tp := mustNew(t, &cli, kong.Resolvers(resolver))\n\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.True(t, cli.Bool)\n}\n\nfunc TestLastResolverWins(t *testing.T) {\n\tvar cli struct {\n\t\tInt []int\n\t}\n\n\tvar first kong.ResolverFunc = func(context *kong.Context, parent *kong.Path, flag *kong.Flag) (any, error) {\n\t\tif flag.Name == \"int\" {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tvar second kong.ResolverFunc = func(context *kong.Context, parent *kong.Path, flag *kong.Flag) (any, error) {\n\t\tif flag.Name == \"int\" {\n\t\t\treturn 2, nil\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tp := mustNew(t, &cli, kong.Resolvers(first, second))\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int{2}, cli.Int)\n}\n\nfunc TestResolverSatisfiesRequired(t *testing.T) {\n\tvar cli struct {\n\t\tInt int `required`\n\t}\n\tvar resolver kong.ResolverFunc = func(context *kong.Context, parent *kong.Path, flag *kong.Flag) (any, error) {\n\t\tif flag.Name == \"int\" {\n\t\t\treturn 1, nil\n\t\t}\n\t\treturn nil, nil\n\t}\n\t_, err := mustNew(t, &cli, kong.Resolvers(resolver)).Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, 1, cli.Int)\n}\n\nfunc TestResolverTriggersHooks(t *testing.T) {\n\tctx := &hookContext{}\n\n\tvar cli struct {\n\t\tFlag hookValue\n\t}\n\n\tvar first kong.ResolverFunc = func(context *kong.Context, parent *kong.Path, flag *kong.Flag) (any, error) {\n\t\tif flag.Name == \"flag\" {\n\t\t\treturn \"one\", nil\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\t_, err := mustNew(t, &cli, kong.Bind(ctx), kong.Resolvers(first)).Parse(nil)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, \"one\", string(cli.Flag))\n\tassert.Equal(t, []string{\"before:\", \"after:one\"}, ctx.values)\n}\n\ntype validatingResolver struct {\n\terr error\n}\n\nfunc (v *validatingResolver) Validate(app *kong.Application) error { return v.err }\nfunc (v *validatingResolver) Resolve(context *kong.Context, parent *kong.Path, flag *kong.Flag) (any, error) {\n\treturn nil, nil\n}\n\nfunc TestValidatingResolverErrors(t *testing.T) {\n\tresolver := &validatingResolver{err: errors.New(\"invalid\")}\n\tvar cli struct{}\n\t_, err := mustNew(t, &cli, kong.Resolvers(resolver)).Parse(nil)\n\tassert.EqualError(t, err, \"invalid\")\n}\n"
        },
        {
          "name": "scanner.go",
          "type": "blob",
          "size": 5.2607421875,
          "content": "package kong\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// TokenType is the type of a token.\ntype TokenType int\n\n// Token types.\nconst (\n\tUntypedToken TokenType = iota\n\tEOLToken\n\tFlagToken               // --<flag>\n\tFlagValueToken          // =<value>\n\tShortFlagToken          // -<short>[<tail]\n\tShortFlagTailToken      // <tail>\n\tPositionalArgumentToken // <arg>\n)\n\nfunc (t TokenType) String() string {\n\tswitch t {\n\tcase UntypedToken:\n\t\treturn \"untyped\"\n\tcase EOLToken:\n\t\treturn \"<EOL>\"\n\tcase FlagToken: // --<flag>\n\t\treturn \"long flag\"\n\tcase FlagValueToken: // =<value>\n\t\treturn \"flag value\"\n\tcase ShortFlagToken: // -<short>[<tail]\n\t\treturn \"short flag\"\n\tcase ShortFlagTailToken: // <tail>\n\t\treturn \"short flag remainder\"\n\tcase PositionalArgumentToken: // <arg>\n\t\treturn \"positional argument\"\n\t}\n\tpanic(\"unsupported type\")\n}\n\n// Token created by Scanner.\ntype Token struct {\n\tValue any\n\tType  TokenType\n}\n\nfunc (t Token) String() string {\n\tswitch t.Type {\n\tcase FlagToken:\n\t\treturn fmt.Sprintf(\"--%v\", t.Value)\n\n\tcase ShortFlagToken:\n\t\treturn fmt.Sprintf(\"-%v\", t.Value)\n\n\tcase EOLToken:\n\t\treturn \"EOL\"\n\n\tdefault:\n\t\treturn fmt.Sprintf(\"%v\", t.Value)\n\t}\n}\n\n// IsEOL returns true if this Token is past the end of the line.\nfunc (t Token) IsEOL() bool {\n\treturn t.Type == EOLToken\n}\n\n// IsAny returns true if the token's type is any of those provided.\nfunc (t TokenType) IsAny(types ...TokenType) bool {\n\tfor _, typ := range types {\n\t\tif t == typ {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// InferredType tries to infer the type of a token.\nfunc (t Token) InferredType() TokenType {\n\tif t.Type != UntypedToken {\n\t\treturn t.Type\n\t}\n\tif v, ok := t.Value.(string); ok {\n\t\tif strings.HasPrefix(v, \"--\") { //nolint: gocritic\n\t\t\treturn FlagToken\n\t\t} else if v == \"-\" {\n\t\t\treturn PositionalArgumentToken\n\t\t} else if strings.HasPrefix(v, \"-\") {\n\t\t\treturn ShortFlagToken\n\t\t}\n\t}\n\treturn t.Type\n}\n\n// IsValue returns true if token is usable as a parseable value.\n//\n// A parseable value is either a value typed token, or an untyped token NOT starting with a hyphen.\nfunc (t Token) IsValue() bool {\n\ttt := t.InferredType()\n\treturn tt.IsAny(FlagValueToken, ShortFlagTailToken, PositionalArgumentToken) ||\n\t\t(tt == UntypedToken && !strings.HasPrefix(t.String(), \"-\"))\n}\n\n// Scanner is a stack-based scanner over command-line tokens.\n//\n// Initially all tokens are untyped. As the parser consumes tokens it assigns types, splits tokens, and pushes them back\n// onto the stream.\n//\n// For example, the token \"--foo=bar\" will be split into the following by the parser:\n//\n//\t[{FlagToken, \"foo\"}, {FlagValueToken, \"bar\"}]\ntype Scanner struct {\n\targs []Token\n}\n\n// ScanAsType creates a new Scanner from args with the given type.\nfunc ScanAsType(ttype TokenType, args ...string) *Scanner {\n\ts := &Scanner{}\n\tfor _, arg := range args {\n\t\ts.args = append(s.args, Token{Value: arg, Type: ttype})\n\t}\n\treturn s\n}\n\n// Scan creates a new Scanner from args with untyped tokens.\nfunc Scan(args ...string) *Scanner {\n\treturn ScanAsType(UntypedToken, args...)\n}\n\n// ScanFromTokens creates a new Scanner from a slice of tokens.\nfunc ScanFromTokens(tokens ...Token) *Scanner {\n\treturn &Scanner{args: tokens}\n}\n\n// Len returns the number of input arguments.\nfunc (s *Scanner) Len() int {\n\treturn len(s.args)\n}\n\n// Pop the front token off the Scanner.\nfunc (s *Scanner) Pop() Token {\n\tif len(s.args) == 0 {\n\t\treturn Token{Type: EOLToken}\n\t}\n\targ := s.args[0]\n\ts.args = s.args[1:]\n\treturn arg\n}\n\ntype expectedError struct {\n\tcontext string\n\ttoken   Token\n}\n\nfunc (e *expectedError) Error() string {\n\treturn fmt.Sprintf(\"expected %s value but got %q (%s)\", e.context, e.token, e.token.InferredType())\n}\n\n// PopValue pops a value token, or returns an error.\n//\n// \"context\" is used to assist the user if the value can not be popped, eg. \"expected <context> value but got <type>\"\nfunc (s *Scanner) PopValue(context string) (Token, error) {\n\tt := s.Pop()\n\tif !t.IsValue() {\n\t\treturn t, &expectedError{context, t}\n\t}\n\treturn t, nil\n}\n\n// PopValueInto pops a value token into target or returns an error.\n//\n// \"context\" is used to assist the user if the value can not be popped, eg. \"expected <context> value but got <type>\"\nfunc (s *Scanner) PopValueInto(context string, target any) error {\n\tt, err := s.PopValue(context)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn jsonTranscode(t.Value, target)\n}\n\n// PopWhile predicate returns true.\nfunc (s *Scanner) PopWhile(predicate func(Token) bool) (values []Token) {\n\tfor predicate(s.Peek()) {\n\t\tvalues = append(values, s.Pop())\n\t}\n\treturn\n}\n\n// PopUntil predicate returns true.\nfunc (s *Scanner) PopUntil(predicate func(Token) bool) (values []Token) {\n\tfor !predicate(s.Peek()) {\n\t\tvalues = append(values, s.Pop())\n\t}\n\treturn\n}\n\n// Peek at the next Token or return an EOLToken.\nfunc (s *Scanner) Peek() Token {\n\tif len(s.args) == 0 {\n\t\treturn Token{Type: EOLToken}\n\t}\n\treturn s.args[0]\n}\n\n// Push an untyped Token onto the front of the Scanner.\nfunc (s *Scanner) Push(arg any) *Scanner {\n\ts.PushToken(Token{Value: arg})\n\treturn s\n}\n\n// PushTyped pushes a typed token onto the front of the Scanner.\nfunc (s *Scanner) PushTyped(arg any, typ TokenType) *Scanner {\n\ts.PushToken(Token{Value: arg, Type: typ})\n\treturn s\n}\n\n// PushToken pushes a preconstructed Token onto the front of the Scanner.\nfunc (s *Scanner) PushToken(token Token) *Scanner {\n\ts.args = append([]Token{token}, s.args...)\n\treturn s\n}\n"
        },
        {
          "name": "scanner_test.go",
          "type": "blob",
          "size": 0.6953125,
          "content": "package kong\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc TestScannerTake(t *testing.T) {\n\ts := Scan(\"a\", \"b\", \"c\", \"-\")\n\tassert.Equal(t, \"a\", s.Pop().Value)\n\tassert.Equal(t, \"b\", s.Pop().Value)\n\tassert.Equal(t, \"c\", s.Pop().Value)\n\thyphen := s.Pop()\n\tassert.Equal(t, PositionalArgumentToken, hyphen.InferredType())\n\tassert.Equal(t, EOLToken, s.Pop().Type)\n}\n\nfunc TestScannerPeek(t *testing.T) {\n\ts := Scan(\"a\", \"b\", \"c\")\n\tassert.Equal(t, s.Peek().Value, \"a\")\n\tassert.Equal(t, s.Pop().Value, \"a\")\n\tassert.Equal(t, s.Peek().Value, \"b\")\n\tassert.Equal(t, s.Pop().Value, \"b\")\n\tassert.Equal(t, s.Peek().Value, \"c\")\n\tassert.Equal(t, s.Pop().Value, \"c\")\n\tassert.Equal(t, s.Peek().Type, EOLToken)\n}\n"
        },
        {
          "name": "tag.go",
          "type": "blob",
          "size": 9.853515625,
          "content": "package kong\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// PassthroughMode indicates how parameters are passed through when \"passthrough\" is set.\ntype PassthroughMode int\n\nconst (\n\t// PassThroughModeNone indicates passthrough mode is disabled.\n\tPassThroughModeNone PassthroughMode = iota\n\t// PassThroughModeAll indicates that all parameters, including flags, are passed through. It is the default.\n\tPassThroughModeAll\n\t// PassThroughModePartial will validate flags until the first positional argument is encountered, then pass through all remaining positional arguments.\n\tPassThroughModePartial\n)\n\n// Tag represents the parsed state of Kong tags in a struct field tag.\ntype Tag struct {\n\tIgnored         bool // Field is ignored by Kong. ie. kong:\"-\"\n\tCmd             bool\n\tArg             bool\n\tRequired        bool\n\tOptional        bool\n\tName            string\n\tHelp            string\n\tType            string\n\tTypeName        string\n\tHasDefault      bool\n\tDefault         string\n\tFormat          string\n\tPlaceHolder     string\n\tEnvs            []string\n\tShort           rune\n\tHidden          bool\n\tSep             rune\n\tMapSep          rune\n\tEnum            string\n\tGroup           string\n\tXor             []string\n\tAnd             []string\n\tVars            Vars\n\tPrefix          string // Optional prefix on anonymous structs. All sub-flags will have this prefix.\n\tEnvPrefix       string\n\tXorPrefix       string // Optional prefix on XOR/AND groups.\n\tEmbed           bool\n\tAliases         []string\n\tNegatable       string\n\tPassthrough     bool // Deprecated: use PassthroughMode instead.\n\tPassthroughMode PassthroughMode\n\n\t// Storage for all tag keys for arbitrary lookups.\n\titems map[string][]string\n}\n\nfunc (t *Tag) String() string {\n\tout := []string{}\n\tfor key, list := range t.items {\n\t\tfor _, value := range list {\n\t\t\tout = append(out, fmt.Sprintf(\"%s:%q\", key, value))\n\t\t}\n\t}\n\treturn strings.Join(out, \" \")\n}\n\ntype tagChars struct {\n\tsep, quote, assign rune\n\tneedsUnquote       bool\n}\n\nvar kongChars = tagChars{sep: ',', quote: '\\'', assign: '=', needsUnquote: false}\nvar bareChars = tagChars{sep: ' ', quote: '\"', assign: ':', needsUnquote: true}\n\n//nolint:gocyclo\nfunc parseTagItems(tagString string, chr tagChars) (map[string][]string, error) {\n\td := map[string][]string{}\n\tkey := []rune{}\n\tvalue := []rune{}\n\tquotes := false\n\tinKey := true\n\n\tadd := func() error {\n\t\t// Bare tags are quoted, therefore we need to unquote them in the same fashion reflect.Lookup() (implicitly)\n\t\t// unquotes \"kong tags\".\n\t\ts := string(value)\n\n\t\tif chr.needsUnquote && s != \"\" {\n\t\t\tif unquoted, err := strconv.Unquote(fmt.Sprintf(`\"%s\"`, s)); err == nil {\n\t\t\t\ts = unquoted\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"unquoting tag value `%s`: %w\", s, err)\n\t\t\t}\n\t\t}\n\n\t\td[string(key)] = append(d[string(key)], s)\n\t\tkey = []rune{}\n\t\tvalue = []rune{}\n\t\tinKey = true\n\n\t\treturn nil\n\t}\n\n\trunes := []rune(tagString)\n\tfor idx := 0; idx < len(runes); idx++ {\n\t\tr := runes[idx]\n\t\tnext := rune(0)\n\t\teof := false\n\t\tif idx < len(runes)-1 {\n\t\t\tnext = runes[idx+1]\n\t\t} else {\n\t\t\teof = true\n\t\t}\n\t\tif !quotes && r == chr.sep {\n\t\t\tif err := add(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\t\tif r == chr.assign && inKey {\n\t\t\tinKey = false\n\t\t\tcontinue\n\t\t}\n\t\tif r == '\\\\' {\n\t\t\tif next == chr.quote {\n\t\t\t\tidx++\n\n\t\t\t\t// We need to keep the backslashes, otherwise subsequent unquoting cannot work\n\t\t\t\tif chr.needsUnquote {\n\t\t\t\t\tvalue = append(value, r)\n\t\t\t\t}\n\n\t\t\t\tr = chr.quote\n\t\t\t}\n\t\t} else if r == chr.quote {\n\t\t\tif quotes {\n\t\t\t\tquotes = false\n\t\t\t\tif next == chr.sep || eof {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn nil, fmt.Errorf(\"%v has an unexpected char at pos %v\", tagString, idx)\n\t\t\t}\n\t\t\tquotes = true\n\t\t\tcontinue\n\t\t}\n\t\tif inKey {\n\t\t\tkey = append(key, r)\n\t\t} else {\n\t\t\tvalue = append(value, r)\n\t\t}\n\t}\n\tif quotes {\n\t\treturn nil, fmt.Errorf(\"%v is not quoted properly\", tagString)\n\t}\n\n\tif err := add(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn d, nil\n}\n\nfunc getTagInfo(ft reflect.StructField) (string, tagChars) {\n\ts, ok := ft.Tag.Lookup(\"kong\")\n\tif ok {\n\t\treturn s, kongChars\n\t}\n\n\treturn string(ft.Tag), bareChars\n}\n\nfunc newEmptyTag() *Tag {\n\treturn &Tag{items: map[string][]string{}}\n}\n\nfunc tagSplitFn(r rune) bool {\n\treturn r == ',' || r == ' '\n}\n\nfunc parseTagString(s string) (*Tag, error) {\n\titems, err := parseTagItems(s, bareChars)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tt := &Tag{\n\t\titems: items,\n\t}\n\terr = hydrateTag(t, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"%s: %s\", s, err)\n\t}\n\treturn t, nil\n}\n\nfunc parseTag(parent reflect.Value, ft reflect.StructField) (*Tag, error) {\n\tif ft.Tag.Get(\"kong\") == \"-\" {\n\t\tt := newEmptyTag()\n\t\tt.Ignored = true\n\t\treturn t, nil\n\t}\n\titems, err := parseTagItems(getTagInfo(ft))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tt := &Tag{\n\t\titems: items,\n\t}\n\terr = hydrateTag(t, ft.Type)\n\tif err != nil {\n\t\treturn nil, failField(parent, ft, \"%s\", err)\n\t}\n\treturn t, nil\n}\n\nfunc hydrateTag(t *Tag, typ reflect.Type) error { //nolint: gocyclo\n\tvar typeName string\n\tvar isBool bool\n\tvar isBoolPtr bool\n\tif typ != nil {\n\t\ttypeName = typ.Name()\n\t\tisBool = typ.Kind() == reflect.Bool\n\t\tisBoolPtr = typ.Kind() == reflect.Ptr && typ.Elem().Kind() == reflect.Bool\n\t}\n\tvar err error\n\tt.Cmd = t.Has(\"cmd\")\n\tt.Arg = t.Has(\"arg\")\n\trequired := t.Has(\"required\")\n\toptional := t.Has(\"optional\")\n\tif required && optional {\n\t\treturn fmt.Errorf(\"can't specify both required and optional\")\n\t}\n\tt.Required = required\n\tt.Optional = optional\n\tt.HasDefault = t.Has(\"default\")\n\tt.Default = t.Get(\"default\")\n\t// Arguments with defaults are always optional.\n\tif t.Arg && t.HasDefault {\n\t\tt.Optional = true\n\t} else if t.Arg && !optional { // Arguments are required unless explicitly made optional.\n\t\tt.Required = true\n\t}\n\tt.Name = t.Get(\"name\")\n\tt.Help = t.Get(\"help\")\n\tt.Type = t.Get(\"type\")\n\tt.TypeName = typeName\n\tfor _, env := range t.GetAll(\"env\") {\n\t\tt.Envs = append(t.Envs, strings.FieldsFunc(env, tagSplitFn)...)\n\t}\n\tt.Short, err = t.GetRune(\"short\")\n\tif err != nil && t.Get(\"short\") != \"\" {\n\t\treturn fmt.Errorf(\"invalid short flag name %q: %s\", t.Get(\"short\"), err)\n\t}\n\tt.Hidden = t.Has(\"hidden\")\n\tt.Format = t.Get(\"format\")\n\tt.Sep, _ = t.GetSep(\"sep\", ',')\n\tt.MapSep, _ = t.GetSep(\"mapsep\", ';')\n\tt.Group = t.Get(\"group\")\n\tfor _, xor := range t.GetAll(\"xor\") {\n\t\tt.Xor = append(t.Xor, strings.FieldsFunc(xor, tagSplitFn)...)\n\t}\n\tfor _, and := range t.GetAll(\"and\") {\n\t\tt.And = append(t.And, strings.FieldsFunc(and, tagSplitFn)...)\n\t}\n\tt.Prefix = t.Get(\"prefix\")\n\tt.EnvPrefix = t.Get(\"envprefix\")\n\tt.XorPrefix = t.Get(\"xorprefix\")\n\tt.Embed = t.Has(\"embed\")\n\tif t.Has(\"negatable\") {\n\t\tif !isBool && !isBoolPtr {\n\t\t\treturn fmt.Errorf(\"negatable can only be set on booleans\")\n\t\t}\n\t\tnegatable := t.Get(\"negatable\")\n\t\tif negatable == \"\" {\n\t\t\tnegatable = negatableDefault // placeholder for default negation of --no-<flag>\n\t\t}\n\t\tt.Negatable = negatable\n\t}\n\taliases := t.Get(\"aliases\")\n\tif len(aliases) > 0 {\n\t\tt.Aliases = append(t.Aliases, strings.FieldsFunc(aliases, tagSplitFn)...)\n\t}\n\tt.Vars = Vars{}\n\tfor _, set := range t.GetAll(\"set\") {\n\t\tparts := strings.SplitN(set, \"=\", 2)\n\t\tif len(parts) == 0 {\n\t\t\treturn fmt.Errorf(\"set should be in the form key=value but got %q\", set)\n\t\t}\n\t\tt.Vars[parts[0]] = parts[1]\n\t}\n\tt.PlaceHolder = t.Get(\"placeholder\")\n\tt.Enum = t.Get(\"enum\")\n\tscalarType := typ == nil || !(typ.Kind() == reflect.Slice || typ.Kind() == reflect.Map || typ.Kind() == reflect.Ptr)\n\tif t.Enum != \"\" && !(t.Required || t.HasDefault) && scalarType {\n\t\treturn fmt.Errorf(\"enum value is only valid if it is either required or has a valid default value\")\n\t}\n\tpassthrough := t.Has(\"passthrough\")\n\tif passthrough && !t.Arg && !t.Cmd {\n\t\treturn fmt.Errorf(\"passthrough only makes sense for positional arguments or commands\")\n\t}\n\tt.Passthrough = passthrough\n\tif t.Passthrough {\n\t\tpassthroughMode := t.Get(\"passthrough\")\n\t\tswitch passthroughMode {\n\t\tcase \"partial\":\n\t\t\tt.PassthroughMode = PassThroughModePartial\n\t\tcase \"all\", \"\":\n\t\t\tt.PassthroughMode = PassThroughModeAll\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid passthrough mode %q, must be one of 'partial' or 'all'\", passthroughMode)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Has returns true if the tag contained the given key.\nfunc (t *Tag) Has(k string) bool {\n\t_, ok := t.items[k]\n\treturn ok\n}\n\n// Get returns the value of the given tag.\n//\n// Note that this will return the empty string if the tag is missing.\nfunc (t *Tag) Get(k string) string {\n\tvalues := t.items[k]\n\tif len(values) == 0 {\n\t\treturn \"\"\n\t}\n\treturn values[0]\n}\n\n// GetAll returns all encountered values for a tag, in the case of multiple occurrences.\nfunc (t *Tag) GetAll(k string) []string {\n\treturn t.items[k]\n}\n\n// GetBool returns true if the given tag looks like a boolean truth string.\nfunc (t *Tag) GetBool(k string) (bool, error) {\n\treturn strconv.ParseBool(t.Get(k))\n}\n\n// GetFloat parses the given tag as a float64.\nfunc (t *Tag) GetFloat(k string) (float64, error) {\n\treturn strconv.ParseFloat(t.Get(k), 64)\n}\n\n// GetInt parses the given tag as an int64.\nfunc (t *Tag) GetInt(k string) (int64, error) {\n\treturn strconv.ParseInt(t.Get(k), 10, 64)\n}\n\n// GetRune parses the given tag as a rune.\nfunc (t *Tag) GetRune(k string) (rune, error) {\n\tvalue := t.Get(k)\n\tr, size := utf8.DecodeRuneInString(value)\n\tif r == utf8.RuneError || size < len(value) {\n\t\treturn 0, errors.New(\"invalid rune\")\n\t}\n\treturn r, nil\n}\n\n// GetSep parses the given tag as a rune separator, allowing for a default or none.\n// The separator is returned, or -1 if \"none\" is specified. If the tag value is an\n// invalid utf8 sequence, the default rune is returned as well as an error. If the\n// tag value is more than one rune, the first rune is returned as well as an error.\nfunc (t *Tag) GetSep(k string, dflt rune) (rune, error) {\n\ttv := t.Get(k)\n\tif tv == \"none\" {\n\t\treturn -1, nil\n\t} else if tv == \"\" {\n\t\treturn dflt, nil\n\t}\n\tr, size := utf8.DecodeRuneInString(tv)\n\tif r == utf8.RuneError {\n\t\treturn dflt, fmt.Errorf(`%v:\"%v\" has a rune error`, k, tv)\n\t} else if size != len(tv) {\n\t\treturn r, fmt.Errorf(`%v:\"%v\" is more than a single rune`, k, tv)\n\t}\n\treturn r, nil\n}\n"
        },
        {
          "name": "tag_test.go",
          "type": "blob",
          "size": 4.9677734375,
          "content": "package kong_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n\n\t\"github.com/alecthomas/kong\"\n)\n\nfunc TestDefaultValueForOptionalArg(t *testing.T) {\n\tvar cli struct {\n\t\tArg string `kong:\"arg,optional,default='\\\"\\\\'ðŸ‘Œ\\\\'\\\"'\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"\\\"'ðŸ‘Œ'\\\"\", cli.Arg)\n}\n\nfunc TestNoValueInTag(t *testing.T) {\n\tvar cli struct {\n\t\tEmpty1 string `kong:\"default\"`\n\t\tEmpty2 string `kong:\"default=\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"\", cli.Empty1)\n\tassert.Equal(t, \"\", cli.Empty2)\n}\n\nfunc TestCommaInQuotes(t *testing.T) {\n\tvar cli struct {\n\t\tNumbers string `kong:\"default='1,2'\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"1,2\", cli.Numbers)\n}\n\nfunc TestBadString(t *testing.T) {\n\tvar cli struct {\n\t\tNumbers string `kong:\"default='yay'n\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestNoQuoteEnd(t *testing.T) {\n\tvar cli struct {\n\t\tNumbers string `kong:\"default='yay\"`\n\t}\n\t_, err := kong.New(&cli)\n\tassert.Error(t, err)\n}\n\nfunc TestEscapedQuote(t *testing.T) {\n\tvar cli struct {\n\t\tDoYouKnow string `kong:\"default='i don\\\\'t know'\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"i don't know\", cli.DoYouKnow)\n}\n\nfunc TestEscapingInQuotedTags(t *testing.T) {\n\tvar cli struct {\n\t\tRegex1 string `kong:\"default='\\\\d+\\n'\"`\n\t\tRegex2 string `default:\"\\\\d+\\n\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"\\\\d+\\n\", cli.Regex1)\n\tassert.Equal(t, \"\\\\d+\\n\", cli.Regex2)\n}\n\nfunc TestBareTags(t *testing.T) {\n\tvar cli struct {\n\t\tCmd struct {\n\t\t\tArg  string `arg`\n\t\t\tFlag string `required default:\"ðŸ‘Œ\"`\n\t\t} `cmd`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"cmd\", \"arg\", \"--flag=hi\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"hi\", cli.Cmd.Flag)\n\tassert.Equal(t, \"arg\", cli.Cmd.Arg)\n}\n\nfunc TestBareTagsWithJsonTag(t *testing.T) {\n\tvar cli struct {\n\t\tCmd struct {\n\t\t\tArg  string `json:\"-\" optional arg`\n\t\t\tFlag string `json:\"best_flag\" default:\"\\\"'ðŸ‘Œ'\\\"\"`\n\t\t} `cmd json:\"CMD\"`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"cmd\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"\\\"'ðŸ‘Œ'\\\"\", cli.Cmd.Flag)\n\tassert.Equal(t, \"\", cli.Cmd.Arg)\n}\n\nfunc TestManySeps(t *testing.T) {\n\tvar cli struct {\n\t\tArg string `arg    optional    default:\"hi\"`\n\t}\n\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"hi\", cli.Arg)\n}\n\nfunc TestTagSetOnEmbeddedStruct(t *testing.T) {\n\ttype Embedded struct {\n\t\tKey string `help:\"A key from ${where}.\"`\n\t}\n\tvar cli struct {\n\t\tEmbedded `set:\"where=somewhere\"`\n\t}\n\tbuf := &strings.Builder{}\n\tp := mustNew(t, &cli, kong.Writers(buf, buf), kong.Exit(func(int) {}))\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, buf.String(), `A key from somewhere.`)\n}\n\nfunc TestTagSetOnCommand(t *testing.T) {\n\ttype Command struct {\n\t\tKey string `help:\"A key from ${where}.\"`\n\t}\n\tvar cli struct {\n\t\tCommand Command `set:\"where=somewhere\" cmd:\"\"`\n\t}\n\tbuf := &strings.Builder{}\n\tp := mustNew(t, &cli, kong.Writers(buf, buf), kong.Exit(func(int) {}))\n\t_, err := p.Parse([]string{\"command\", \"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, buf.String(), `A key from somewhere.`)\n}\n\nfunc TestTagSetOnFlag(t *testing.T) {\n\tvar cli struct {\n\t\tFlag string `set:\"where=somewhere\" help:\"A key from ${where}.\"`\n\t}\n\tbuf := &strings.Builder{}\n\tp := mustNew(t, &cli, kong.Writers(buf, buf), kong.Exit(func(int) {}))\n\t_, err := p.Parse([]string{\"--help\"})\n\tassert.NoError(t, err)\n\tassert.Contains(t, buf.String(), `A key from somewhere.`)\n}\n\nfunc TestTagAliases(t *testing.T) {\n\ttype Command struct {\n\t\tArg string `arg help:\"Some arg\"`\n\t}\n\tvar cli struct {\n\t\tCmd Command `cmd aliases:\"alias1, alias2\"`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"alias1\", \"arg\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"arg\", cli.Cmd.Arg)\n\t_, err = p.Parse([]string{\"alias2\", \"arg\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"arg\", cli.Cmd.Arg)\n}\n\nfunc TestTagAliasesConflict(t *testing.T) {\n\ttype Command struct {\n\t\tArg string `arg help:\"Some arg\"`\n\t}\n\tvar cli struct {\n\t\tCmd      Command `cmd hidden aliases:\"other-cmd\"`\n\t\tOtherCmd Command `cmd`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"other-cmd\", \"arg\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"arg\", cli.OtherCmd.Arg)\n}\n\nfunc TestTagAliasesSub(t *testing.T) {\n\ttype SubCommand struct {\n\t\tArg string `arg help:\"Some arg\"`\n\t}\n\ttype Command struct {\n\t\tSubCmd SubCommand `cmd aliases:\"other-sub-cmd\"`\n\t}\n\tvar cli struct {\n\t\tCmd Command `cmd hidden`\n\t}\n\tp := mustNew(t, &cli)\n\t_, err := p.Parse([]string{\"cmd\", \"other-sub-cmd\", \"arg\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"arg\", cli.Cmd.SubCmd.Arg)\n}\n\nfunc TestInvalidRuneErrors(t *testing.T) {\n\tcli := struct {\n\t\tFlag bool `short:\"invalid\"`\n\t}{}\n\t_, err := kong.New(&cli)\n\tassert.EqualError(t, err, \"<anonymous struct>.Flag: invalid short flag name \\\"invalid\\\": invalid rune\")\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 1.69140625,
          "content": "package kong\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n)\n\n// ConfigFlag uses the configured (via kong.Configuration(loader)) configuration loader to load configuration\n// from a file specified by a flag.\n//\n// Use this as a flag value to support loading of custom configuration via a flag.\ntype ConfigFlag string\n\n// BeforeResolve adds a resolver.\nfunc (c ConfigFlag) BeforeResolve(kong *Kong, ctx *Context, trace *Path) error {\n\tif kong.loader == nil {\n\t\treturn fmt.Errorf(\"kong must be configured with kong.Configuration(...)\")\n\t}\n\tpath := string(ctx.FlagValue(trace.Flag).(ConfigFlag)) //nolint\n\tresolver, err := kong.LoadConfig(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx.AddResolver(resolver)\n\treturn nil\n}\n\n// VersionFlag is a flag type that can be used to display a version number, stored in the \"version\" variable.\ntype VersionFlag bool\n\n// BeforeReset writes the version variable and terminates with a 0 exit status.\nfunc (v VersionFlag) BeforeReset(app *Kong, vars Vars) error {\n\tfmt.Fprintln(app.Stdout, vars[\"version\"])\n\tapp.Exit(0)\n\treturn nil\n}\n\n// ChangeDirFlag changes the current working directory to a path specified by a flag\n// early in the parsing process, changing how other flags resolve relative paths.\n//\n// Use this flag to provide a \"git -C\" like functionality.\n//\n// It is not compatible with custom named decoders, e.g., existingdir.\ntype ChangeDirFlag string\n\n// Decode is used to create a side effect of changing the current working directory.\nfunc (c ChangeDirFlag) Decode(ctx *DecodeContext) error {\n\tvar path string\n\terr := ctx.Scan.PopValueInto(\"string\", &path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpath = ExpandPath(path)\n\tctx.Value.Target.Set(reflect.ValueOf(ChangeDirFlag(path)))\n\treturn os.Chdir(path)\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 1.5107421875,
          "content": "package kong\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/assert/v2\"\n)\n\nfunc TestConfigFlag(t *testing.T) {\n\tvar cli struct {\n\t\tConfig ConfigFlag\n\t\tFlag   string\n\t}\n\n\tw, err := os.CreateTemp(\"\", \"\")\n\tassert.NoError(t, err)\n\tdefer os.Remove(w.Name())\n\tw.WriteString(`{\"flag\": \"hello world\"}`) //nolint: errcheck\n\tw.Close()\n\n\tp := Must(&cli, Configuration(JSON))\n\t_, err = p.Parse([]string{\"--config\", w.Name()})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"hello world\", cli.Flag)\n}\n\nfunc TestVersionFlag(t *testing.T) {\n\tvar cli struct {\n\t\tVersion VersionFlag\n\t}\n\tw := &strings.Builder{}\n\tp := Must(&cli, Vars{\"version\": \"0.1.1\"})\n\tp.Stdout = w\n\tcalled := 1\n\tp.Exit = func(s int) { called = s }\n\n\t_, err := p.Parse([]string{\"--version\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"0.1.1\", strings.TrimSpace(w.String()))\n\tassert.Equal(t, 0, called)\n}\n\nfunc TestChangeDirFlag(t *testing.T) {\n\tcwd, err := os.Getwd()\n\tassert.NoError(t, err)\n\tdefer os.Chdir(cwd) //nolint: errcheck\n\n\tdir := t.TempDir()\n\tfile := filepath.Join(dir, \"out.txt\")\n\terr = os.WriteFile(file, []byte(\"foobar\"), 0o600)\n\tassert.NoError(t, err)\n\n\tvar cli struct {\n\t\tChangeDir ChangeDirFlag `short:\"C\"`\n\t\tPath      string        `arg:\"\" type:\"existingfile\"`\n\t}\n\n\tp := Must(&cli)\n\t_, err = p.Parse([]string{\"-C\", dir, \"out.txt\"})\n\tassert.NoError(t, err)\n\tif runtime.GOOS != \"windows\" {\n\t\tfile, err = filepath.EvalSymlinks(file) // Needed because OSX uses a symlinked tmp dir.\n\t\tassert.NoError(t, err)\n\t}\n\tassert.Equal(t, file, cli.Path)\n}\n"
        },
        {
          "name": "visit.go",
          "type": "blob",
          "size": 1.2197265625,
          "content": "package kong\n\nimport (\n\t\"fmt\"\n)\n\n// Next should be called by Visitor to proceed with the walk.\n//\n// The walk will terminate if \"err\" is non-nil.\ntype Next func(err error) error\n\n// Visitor can be used to walk all nodes in the model.\ntype Visitor func(node Visitable, next Next) error\n\n// Visit all nodes.\nfunc Visit(node Visitable, visitor Visitor) error {\n\treturn visitor(node, func(err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch node := node.(type) {\n\t\tcase *Application:\n\t\t\treturn visitNodeChildren(node.Node, visitor)\n\t\tcase *Node:\n\t\t\treturn visitNodeChildren(node, visitor)\n\t\tcase *Value:\n\t\tcase *Flag:\n\t\t\treturn Visit(node.Value, visitor)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"unsupported node type %T\", node))\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc visitNodeChildren(node *Node, visitor Visitor) error {\n\tif node.Argument != nil {\n\t\tif err := Visit(node.Argument, visitor); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, flag := range node.Flags {\n\t\tif err := Visit(flag, visitor); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, pos := range node.Positional {\n\t\tif err := Visit(pos, visitor); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, child := range node.Children {\n\t\tif err := Visit(child, visitor); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        }
      ]
    }
  ]
}