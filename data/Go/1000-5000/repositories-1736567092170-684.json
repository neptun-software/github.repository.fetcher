{
  "metadata": {
    "timestamp": 1736567092170,
    "page": 684,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "FiloSottile/yubikey-agent",
      "stars": 2695,
      "defaultBranch": "main",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4140625,
          "content": "Copyright 2020 Google LLC\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google LLC nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.7705078125,
          "content": "# yubikey-agent\n\nyubikey-agent is a seamless ssh-agent for YubiKeys.\n\n* **Easy to use.** A one-command setup, one environment variable, and it just runs in the background.\n* **Indestructible.** Tolerates unplugging, sleep, and suspend. Never needs restarting.\n* **Compatible.** Provides a public key that works with all services and servers.\n* **Secure.** The key is generated on the YubiKey and can't be extracted. Every session requires the PIN, every login requires a touch. Setup takes care of PUK and management key.\n\nWritten in pure Go, it's based on [github.com/go-piv/piv-go](https://github.com/go-piv/piv-go) and [golang.org/x/crypto/ssh](https://golang.org/x/crypto/ssh).\n\n![](https://user-images.githubusercontent.com/1225294/81489747-63a03b00-9247-11ea-923a-b7434bcf7fd1.png)\n\n## Installation\n\n### macOS\n\n```\nbrew install yubikey-agent\nbrew services start yubikey-agent\nyubikey-agent -setup # generate a new key on the YubiKey\n```\n\nThen add the following line to your `~/.zshrc` and restart the shell.\n\n```\nexport SSH_AUTH_SOCK=\"$(brew --prefix)/var/run/yubikey-agent.sock\"\n```\n\n### Linux\n\n#### Arch\n\nOn Arch, use [the `yubikey-agent` package](https://aur.archlinux.org/packages/yubikey-agent/) from the AUR.\n\n```\ngit clone https://aur.archlinux.org/yubikey-agent.git\ncd yubikey-agent && makepkg -si\n\nsystemctl daemon-reload --user\nsudo systemctl enable --now pcscd.socket\nsystemctl --user enable --now yubikey-agent\n\nexport SSH_AUTH_SOCK=\"${XDG_RUNTIME_DIR}/yubikey-agent/yubikey-agent.sock\"\n```\n\n#### NixOS / nixpkgs\n\nOn NixOS unstable and 20.09 (unreleased at time of writing), you can\nadd this to your `/etc/nixos/configuration.nix`:\n\n```\nservices.yubikey-agent.enable = true;\n```\n\nThis installs `yubikey-agent` and sets up a systemd unit to start\nyubikey-agent for you.\n\nOn other systems using nix, you can also install from nixpkgs:\n\n```\nnix-env -iA nixpkgs.yubikey-agent\n```\n\nThis installs the software but does *not* install a systemd unit.  You\nwill have to set up service management manually (see below).\n\n#### Other systemd-based Linux systems\n\nOn other systemd-based Linux systems, follow [the manual installation instructions](systemd.md).\n\nPackaging contributions are very welcome.\n\n### FreeBSD\n\nInstall the [`yubikey-agent` port](https://svnweb.freebsd.org/ports/head/security/yubikey-agent/).\n\n### Windows\n\nWindows support is currently WIP.\n\n## Advanced topics\n\n### Coexisting with other `ssh-agent`s\n\nIt's possible to configure `ssh-agent`s on a per-host basis.\n\nFor example to only use `yubikey-agent` when connecting to `example.com`, you'd add the following lines to `~/.ssh/config` instead of setting `SSH_AUTH_SOCK`.\n\n```\nHost example.com\n    IdentityAgent /usr/local/var/run/yubikey-agent.sock\n```\n\nTo use `yubikey-agent` for all hosts but one, you'd add the following lines instead. In both cases, you can keep using `ssh-add` to interact with the main `ssh-agent`.\n\n```\nHost example.com\n    IdentityAgent $SSH_AUTH_SOCK\n\nHost *\n    IdentityAgent /usr/local/var/run/yubikey-agent.sock\n```\n\n### Conflicts with `gpg-agent` and Yubikey Manager\n\n`yubikey-agent` takes a persistent transaction so the YubiKey will cache the PIN after first use. Unfortunately, this makes the YubiKey PIV and PGP applets unavailable to any other applications, like `gpg-agent` and Yubikey Manager. Our upstream [is investigating solutions to this annoyance](https://github.com/go-piv/piv-go/issues/47).\n\nIf you need `yubikey-agent` to release its lock on the YubiKey, send it a hangup signal or use `ssh-add`'s \"delete all identities\" flag. Likewise, you might have to kill `gpg-agent` after use for it to release its own lock.\n\n```\nssh-add -D\n```\n\nThis does not affect the FIDO2 functionality.\n\n### Changing PIN and PUK\n\nUse YubiKey Manager to change the PIN and PUK.\n\n`yubikey-agent -setup` sets the PUK to the same value as the PIN.\n\n```\nkillall -HUP yubikey-agent\nykman piv access change-pin\nykman piv access change-puk\n```\n\n### Unblocking the PIN with the PUK\n\nIf the wrong PIN is entered incorrectly three times in a row, YubiKey Manager can be used to unlock it.\n\n`yubikey-agent -setup` sets the PUK to the same value as the PIN.\n\n```\nykman piv access unblock-pin\n```\n\nIf the PUK is also entered incorrectly three times, the key is permanently irrecoverable. The YubiKey PIV applet can be reset with `yubikey-agent --setup --really-delete-all-piv-keys`.\n\n### Manual setup and technical details\n\n`yubikey-agent` only officially supports YubiKeys set up with `yubikey-agent -setup`.\n\nIn practice, any PIV token with an RSA or ECDSA P-256 key and certificate in the Authentication slot should work, with any PIN and touch policy. Simply skip the setup step and use `ssh-add -L` to view the public key.\n\n`yubikey-agent -setup` generates a random Management Key and [stores it in PIN-protected metadata](https://pkg.go.dev/github.com/go-piv/piv-go/piv?tab=doc#YubiKey.SetMetadata).\n\n### Alternatives\n\n#### Native FIDO2\n\nRecent versions of OpenSSH [support using FIDO2 tokens directly](https://buttondown.email/cryptography-dispatches/archive/cryptography-dispatches-openssh-82-just-works/). Since those are their own key type, they require server-side support, which has only recently reached Debian and [GitHub](https://www.yubico.com/blog/github-now-supports-ssh-security-keys/).\n\nFIDO2 SSH keys by default don't require a PIN, and require a private key file, acting more like a second factor. `yubikey-agent` keys always require PINs and can be ported to a different machine simply by plugging in the YubiKey. (With recent enough tokens such as a YubiKey 5, a similar setup can be achieved by using the `verify-required` and `resident` options, after setting a FIDO2 PIN with YubiKey Manager: the private key file will still be required, but it can be regenerated from the YubiKey.)\n\n#### `gpg-agent`\n\n`gpg-agent` can act as an `ssh-agent`, and it can use keys stored on the PGP applet of a YubiKey.\n\nThis requires a finicky setup process dealing with PGP keys and the `gpg` UX, and seems to lose track of the YubiKey and require restarting all the time. Frankly, I've also had enough of PGP and GnuPG.\n\n#### `ssh-agent` and PKCS#11\n\n`ssh-agent` can load PKCS#11 applets to interact with PIV tokens directly. There are two third-party PKCS#11 providers for YubiKeys (OpenSC and ykcs11) and one that ships with macOS (`man 8 ssh-keychain`).\n\nThe UX of this solution is poor: it requires calling `ssh-add` to load the PKCS#11 module and to unlock it with the PIN (as the agent has no way of requesting input from the client during use, a limitation that `yubikey-agent` handles with `pinentry`), and needs manual reloading every time the YubiKey is unplugged or the machine goes to sleep.\n\nThe ssh-agent that ships with macOS (which is pretty cool, as it starts on demand and is preconfigured in the environment) also has restrictions on where the `.so` modules can be loaded from. It can see through symlinks, so a Homebrew-installed `/usr/local/lib/libykcs11.dylib` won't work, while a hard copy at `/usr/local/lib/libykcs11.copy.dylib` will.\n\n`/usr/lib/ssh-keychain.dylib` works out of the box, but only with RSA keys. Key generation is undocumented.\n\n#### Secretive and SeKey\n\n[Secretive](https://github.com/maxgoedjen/secretive) and [SeKey](https://github.com/sekey/sekey) are similar projects that use the Secure Enclave to store the private key and Touch ID for authorization. The Secure Enclave has so far a worse security track record compared to YubiKeys.\n\n#### `pivy-agent`\n\n[`pivy-agent`](https://github.com/joyent/pivy#using-pivy-agent) is part of a suite of tools to work with PIV tokens. It's similar to `yubikey-agent`, and inspired its design.\n\nThe main difference is that it requires unlocking via `ssh-add -X` rather than using a graphical pinentry, and it caches the PIN in memory rather than relying on the device PIN policy. It's also written in C.\n\n`yubikey-agent` also aims to provide an even smoother setup process.\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.255859375,
          "content": "module filippo.io/yubikey-agent\n\ngo 1.19\n\nrequire (\n\tgithub.com/go-piv/piv-go v1.10.0\n\tgithub.com/twpayne/go-pinentry-minimal v0.0.0-20220113210447-2a5dc4396c2a\n\tgolang.org/x/crypto v0.4.0\n\tgolang.org/x/term v0.3.0\n)\n\nrequire golang.org/x/sys v0.3.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.8603515625,
          "content": "github.com/go-piv/piv-go v1.10.0 h1:P1Y1VjBI5DnXW0+YkKmTuh5opWnMIrKriUaIOblee9Q=\ngithub.com/go-piv/piv-go v1.10.0/go.mod h1:NZ2zmjVkfFaL/CF8cVQ/pXdXtuj110zEKGdJM6fJZZM=\ngithub.com/twpayne/go-pinentry-minimal v0.0.0-20220113210447-2a5dc4396c2a h1:a1bRrtgkiv0tytmDVXU5Dqse/WOTws7JvsY2WxPMZ6M=\ngithub.com/twpayne/go-pinentry-minimal v0.0.0-20220113210447-2a5dc4396c2a/go.mod h1:ARJJXqNuaxVS84jX6ST52hQh0TtuQZWABhTe95a6BI4=\ngolang.org/x/crypto v0.4.0 h1:UVQgzMY87xqpKNgb+kDsll2Igd33HszWHFLmpaRMq/8=\ngolang.org/x/crypto v0.4.0/go.mod h1:3quD/ATkf6oY+rnes5c3ExXTbLc8mueNue5/DoinL80=\ngolang.org/x/sys v0.3.0 h1:w8ZOecv6NaNa/zC8944JTU3vz4u6Lagfk4RPQxv92NQ=\ngolang.org/x/sys v0.3.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.3.0 h1:qoo4akIqOcDME5bhc/NgxUdovd6BSS2uMsVjB56q1xI=\ngolang.org/x/term v0.3.0/go.mod h1:q750SLmJuPmVoN1blW3UFBPREJfb1KmY3vwxfr+nFDA=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 9.189453125,
          "content": "// Copyright 2020 Google LLC\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/go-piv/piv-go/piv\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/agent\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\nfunc main() {\n\tflag.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"Usage of yubikey-agent:\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\tyubikey-agent -setup\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\t\\tGenerate a new SSH key on the attached YubiKey.\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\tyubikey-agent -l PATH\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\t\\tRun the agent, listening on the UNIX socket at PATH.\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t}\n\n\tsocketPath := flag.String(\"l\", \"\", \"agent: path of the UNIX socket to listen on\")\n\tresetFlag := flag.Bool(\"really-delete-all-piv-keys\", false, \"setup: reset the PIV applet\")\n\tsetupFlag := flag.Bool(\"setup\", false, \"setup: configure a new YubiKey\")\n\tflag.Parse()\n\n\tif flag.NArg() > 0 {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tif *setupFlag {\n\t\tlog.SetFlags(0)\n\t\tyk := connectForSetup()\n\t\tif *resetFlag {\n\t\t\trunReset(yk)\n\t\t}\n\t\trunSetup(yk)\n\t} else {\n\t\tif *socketPath == \"\" {\n\t\t\tflag.Usage()\n\t\t\tos.Exit(1)\n\t\t}\n\t\trunAgent(*socketPath)\n\t}\n}\n\nfunc runAgent(socketPath string) {\n\tif terminal.IsTerminal(int(os.Stdin.Fd())) {\n\t\tlog.Println(\"Warning: yubikey-agent is meant to run as a background daemon.\")\n\t\tlog.Println(\"Running multiple instances is likely to lead to conflicts.\")\n\t\tlog.Println(\"Consider using the launchd or systemd services.\")\n\t}\n\n\ta := &Agent{}\n\n\tc := make(chan os.Signal)\n\tsignal.Notify(c, syscall.SIGHUP)\n\tgo func() {\n\t\tfor range c {\n\t\t\ta.Close()\n\t\t}\n\t}()\n\n\tos.Remove(socketPath)\n\tif err := os.MkdirAll(filepath.Dir(socketPath), 0777); err != nil {\n\t\tlog.Fatalln(\"Failed to create UNIX socket folder:\", err)\n\t}\n\tl, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to listen on UNIX socket:\", err)\n\t}\n\n\tfor {\n\t\tc, err := l.Accept()\n\t\tif err != nil {\n\t\t\ttype temporary interface {\n\t\t\t\tTemporary() bool\n\t\t\t}\n\t\t\tif err, ok := err.(temporary); ok && err.Temporary() {\n\t\t\t\tlog.Println(\"Temporary Accept error, sleeping 1s:\", err)\n\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Fatalln(\"Failed to accept connections:\", err)\n\t\t}\n\t\tgo a.serveConn(c)\n\t}\n}\n\ntype Agent struct {\n\tmu     sync.Mutex\n\tyk     *piv.YubiKey\n\tserial uint32\n\n\t// touchNotification is armed by Sign to show a notification if waiting for\n\t// more than a few seconds for the touch operation. It is paused and reset\n\t// by getPIN so it won't fire while waiting for the PIN.\n\ttouchNotification *time.Timer\n}\n\nvar _ agent.ExtendedAgent = &Agent{}\n\nfunc (a *Agent) serveConn(c net.Conn) {\n\tif err := agent.ServeAgent(a, c); err != io.EOF {\n\t\tlog.Println(\"Agent client connection ended with error:\", err)\n\t}\n}\n\nfunc healthy(yk *piv.YubiKey) bool {\n\t// We can't use Serial because it locks the session on older firmwares, and\n\t// can't use Retries because it fails when the session is unlocked.\n\t_, err := yk.AttestationCertificate()\n\treturn err == nil\n}\n\nfunc (a *Agent) ensureYK() error {\n\tif a.yk == nil || !healthy(a.yk) {\n\t\tif a.yk != nil {\n\t\t\tlog.Println(\"Reconnecting to the YubiKey...\")\n\t\t\ta.yk.Close()\n\t\t} else {\n\t\t\tlog.Println(\"Connecting to the YubiKey...\")\n\t\t}\n\t\tyk, err := a.connectToYK()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.yk = yk\n\t}\n\treturn nil\n}\n\nfunc (a *Agent) maybeReleaseYK() {\n\t// On macOS, YubiKey 5s persist the PIN cache even across sessions (and even\n\t// processes), so we can release the lock on the key, to let other\n\t// applications like age-plugin-yubikey use it.\n\tif runtime.GOOS != \"darwin\" || a.yk.Version().Major < 5 {\n\t\treturn\n\t}\n\tif err := a.yk.Close(); err != nil {\n\t\tlog.Println(\"Failed to automatically release YubiKey lock:\", err)\n\t}\n\ta.yk = nil\n}\n\nfunc (a *Agent) connectToYK() (*piv.YubiKey, error) {\n\tyk, err := openYK()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Cache the serial number locally because requesting it on older firmwares\n\t// requires switching application, which drops the PIN cache.\n\ta.serial, _ = yk.Serial()\n\treturn yk, nil\n}\n\nfunc openYK() (yk *piv.YubiKey, err error) {\n\tcards, err := piv.Cards()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(cards) == 0 {\n\t\treturn nil, errors.New(\"no YubiKey detected\")\n\t}\n\t// TODO: support multiple YubiKeys. For now, select the first one that opens\n\t// successfully, to skip any internal unused smart card readers.\n\tfor _, card := range cards {\n\t\tyk, err = piv.Open(card)\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\nfunc (a *Agent) Close() error {\n\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\tif a.yk != nil {\n\t\tlog.Println(\"Received HUP, dropping YubiKey transaction...\")\n\t\terr := a.yk.Close()\n\t\ta.yk = nil\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (a *Agent) getPIN() (string, error) {\n\tif a.touchNotification != nil && a.touchNotification.Stop() {\n\t\tdefer a.touchNotification.Reset(5 * time.Second)\n\t}\n\tr, _ := a.yk.Retries()\n\treturn getPIN(a.serial, r)\n}\n\nfunc (a *Agent) List() ([]*agent.Key, error) {\n\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\tif err := a.ensureYK(); err != nil {\n\t\treturn nil, fmt.Errorf(\"could not reach YubiKey: %w\", err)\n\t}\n\tdefer a.maybeReleaseYK()\n\n\tpk, err := getPublicKey(a.yk, piv.SlotAuthentication)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn []*agent.Key{{\n\t\tFormat:  pk.Type(),\n\t\tBlob:    pk.Marshal(),\n\t\tComment: fmt.Sprintf(\"YubiKey #%d PIV Slot 9a\", a.serial),\n\t}}, nil\n}\n\nfunc getPublicKey(yk *piv.YubiKey, slot piv.Slot) (ssh.PublicKey, error) {\n\tcert, err := yk.Certificate(slot)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not get public key: %w\", err)\n\t}\n\tswitch cert.PublicKey.(type) {\n\tcase *ecdsa.PublicKey:\n\tcase *rsa.PublicKey:\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected public key type: %T\", cert.PublicKey)\n\t}\n\tpk, err := ssh.NewPublicKey(cert.PublicKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to process public key: %w\", err)\n\t}\n\treturn pk, nil\n}\n\nfunc (a *Agent) Signers() ([]ssh.Signer, error) {\n\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\tif err := a.ensureYK(); err != nil {\n\t\treturn nil, fmt.Errorf(\"could not reach YubiKey: %w\", err)\n\t}\n\tdefer a.maybeReleaseYK()\n\n\treturn a.signers()\n}\n\nfunc (a *Agent) signers() ([]ssh.Signer, error) {\n\tpk, err := getPublicKey(a.yk, piv.SlotAuthentication)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpriv, err := a.yk.PrivateKey(\n\t\tpiv.SlotAuthentication,\n\t\tpk.(ssh.CryptoPublicKey).CryptoPublicKey(),\n\t\tpiv.KeyAuth{PINPrompt: a.getPIN},\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to prepare private key: %w\", err)\n\t}\n\ts, err := ssh.NewSignerFromKey(priv)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to prepare signer: %w\", err)\n\t}\n\treturn []ssh.Signer{s}, nil\n}\n\nfunc (a *Agent) Sign(key ssh.PublicKey, data []byte) (*ssh.Signature, error) {\n\treturn a.SignWithFlags(key, data, 0)\n}\n\nfunc (a *Agent) SignWithFlags(key ssh.PublicKey, data []byte, flags agent.SignatureFlags) (*ssh.Signature, error) {\n\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\tif err := a.ensureYK(); err != nil {\n\t\treturn nil, fmt.Errorf(\"could not reach YubiKey: %w\", err)\n\t}\n\tdefer a.maybeReleaseYK()\n\n\tsigners, err := a.signers()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, s := range signers {\n\t\tif !bytes.Equal(s.PublicKey().Marshal(), key.Marshal()) {\n\t\t\tcontinue\n\t\t}\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tdefer cancel()\n\t\ta.touchNotification = time.NewTimer(5 * time.Second)\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-a.touchNotification.C:\n\t\t\tcase <-ctx.Done():\n\t\t\t\ta.touchNotification.Stop()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tshowNotification(\"Waiting for YubiKey touch...\")\n\t\t}()\n\n\t\talg := key.Type()\n\t\tswitch {\n\t\tcase alg == ssh.KeyAlgoRSA && flags&agent.SignatureFlagRsaSha256 != 0:\n\t\t\talg = ssh.SigAlgoRSASHA2256\n\t\tcase alg == ssh.KeyAlgoRSA && flags&agent.SignatureFlagRsaSha512 != 0:\n\t\t\talg = ssh.SigAlgoRSASHA2512\n\t\t}\n\t\t// TODO: maybe retry if the PIN is not correct?\n\t\treturn s.(ssh.AlgorithmSigner).SignWithAlgorithm(rand.Reader, data, alg)\n\t}\n\treturn nil, fmt.Errorf(\"no private keys match the requested public key\")\n}\n\nfunc showNotification(message string) {\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\tmessage = strings.ReplaceAll(message, `\\`, `\\\\`)\n\t\tmessage = strings.ReplaceAll(message, `\"`, `\\\"`)\n\t\tappleScript := `display notification \"%s\" with title \"yubikey-agent\"`\n\t\texec.Command(\"osascript\", \"-e\", fmt.Sprintf(appleScript, message)).Run()\n\tcase \"linux\":\n\t\texec.Command(\"notify-send\", \"-i\", \"dialog-password\", \"yubikey-agent\", message).Run()\n\t}\n}\n\nfunc (a *Agent) Extension(extensionType string, contents []byte) ([]byte, error) {\n\treturn nil, agent.ErrExtensionUnsupported\n}\n\nvar ErrOperationUnsupported = errors.New(\"operation unsupported\")\n\nfunc (a *Agent) Add(key agent.AddedKey) error {\n\treturn ErrOperationUnsupported\n}\nfunc (a *Agent) Remove(key ssh.PublicKey) error {\n\treturn ErrOperationUnsupported\n}\nfunc (a *Agent) RemoveAll() error {\n\treturn a.Close()\n}\nfunc (a *Agent) Lock(passphrase []byte) error {\n\treturn ErrOperationUnsupported\n}\nfunc (a *Agent) Unlock(passphrase []byte) error {\n\treturn ErrOperationUnsupported\n}\n"
        },
        {
          "name": "prompt_darwin.go",
          "type": "blob",
          "size": 1.322265625,
          "content": "// Copyright 2020 Google LLC\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"text/template\"\n)\n\nvar scriptTemplate = template.Must(template.New(\"script\").Parse(`\nvar app = Application.currentApplication()\napp.includeStandardAdditions = true\napp.displayDialog(\n\t\"YubiKey serial number: {{ .Serial }} \" +\n\t\"({{ .Tries }} tries remaining)\\n\\n\" +\n\t\"Please enter your PIN:\", {\n    defaultAnswer: \"\",\n\twithTitle: \"yubikey-agent PIN prompt\",\n    buttons: [\"Cancel\", \"OK\"],\n    defaultButton: \"OK\",\n\tcancelButton: \"Cancel\",\n    hiddenAnswer: true,\n})`))\n\nfunc getPIN(serial uint32, retries int) (string, error) {\n\tscript := new(bytes.Buffer)\n\tif err := scriptTemplate.Execute(script, map[string]interface{}{\n\t\t\"Serial\": serial, \"Tries\": retries,\n\t}); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tc := exec.Command(\"osascript\", \"-s\", \"se\", \"-l\", \"JavaScript\")\n\tc.Stdin = script\n\tout, err := c.Output()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to execute osascript: %v\", err)\n\t}\n\tvar x struct {\n\t\tPIN string `json:\"textReturned\"`\n\t}\n\tif err := json.Unmarshal(out, &x); err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to parse osascript output: %v\", err)\n\t}\n\treturn x.PIN, nil\n}\n"
        },
        {
          "name": "prompt_pinentry.go",
          "type": "blob",
          "size": 1.064453125,
          "content": "// Copyright 2020 Google LLC\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\n//go:build !darwin\n// +build !darwin\n\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/twpayne/go-pinentry-minimal/pinentry\"\n)\n\nfunc getPIN(serial uint32, retries int) (string, error) {\n\tclient, err := pinentry.NewClient(\n\t\tpinentry.WithBinaryNameFromGnuPGAgentConf(),\n\t\tpinentry.WithGPGTTY(),\n\t\tpinentry.WithTitle(\"yubikey-agent PIN Prompt\"),\n\t\tpinentry.WithDesc(fmt.Sprintf(\"YubiKey serial number: %d (%d tries remaining)\", serial, retries)),\n\t\tpinentry.WithPrompt(\"Please enter your PIN:\"),\n\t\t// Enable opt-in external PIN caching (in the OS keychain).\n\t\t// https://gist.github.com/mdeguzis/05d1f284f931223624834788da045c65#file-info-pinentry-L324\n\t\tpinentry.WithOption(pinentry.OptionAllowExternalPasswordCache),\n\t\tpinentry.WithKeyInfo(fmt.Sprintf(\"--yubikey-id-%d\", serial)),\n\t)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer client.Close()\n\n\tpin, _, err := client.GetPIN()\n\treturn pin, err\n}\n"
        },
        {
          "name": "setup.go",
          "type": "blob",
          "size": 6.185546875,
          "content": "// Copyright 2020 Google LLC\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"math/big\"\n\t\"os\"\n\t\"runtime/debug\"\n\t\"time\"\n\n\t\"github.com/go-piv/piv-go/piv\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/term\"\n)\n\n// Version can be set at link time to override debug.BuildInfo.Main.Version,\n// which is \"(devel)\" when building from within the module. See\n// golang.org/issue/29814 and golang.org/issue/29228.\nvar Version string\n\nfunc init() {\n\tif Version != \"\" {\n\t\treturn\n\t}\n\tif buildInfo, ok := debug.ReadBuildInfo(); ok {\n\t\tVersion = buildInfo.Main.Version\n\t\treturn\n\t}\n\tVersion = \"(unknown version)\"\n}\n\nfunc connectForSetup() *piv.YubiKey {\n\tyk, err := openYK()\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to connect to the YubiKey:\", err)\n\t}\n\treturn yk\n}\n\nfunc runReset(yk *piv.YubiKey) {\n\tfmt.Print(`Do you want to reset the PIV applet? This will delete all PIV keys. Type \"delete\": `)\n\tvar res string\n\tif _, err := fmt.Scanln(&res); err != nil {\n\t\tlog.Fatalln(\"Failed to read response:\", err)\n\t}\n\tif res != \"delete\" {\n\t\tlog.Fatalln(\"Aborting...\")\n\t}\n\n\tfmt.Println(\"Resetting YubiKey PIV applet...\")\n\tif err := yk.Reset(); err != nil {\n\t\tlog.Fatalln(\"Failed to reset YubiKey:\", err)\n\t}\n}\n\nfunc runSetup(yk *piv.YubiKey) {\n\tif _, err := yk.Certificate(piv.SlotAuthentication); err == nil {\n\t\tlog.Println(\"‼️  This YubiKey looks already setup\")\n\t\tlog.Println(\"\")\n\t\tlog.Println(\"If you want to wipe all PIV keys and start fresh,\")\n\t\tlog.Fatalln(\"use --really-delete-all-piv-keys ⚠️\")\n\t} else if !errors.Is(err, piv.ErrNotFound) {\n\t\tlog.Fatalln(\"Failed to access authentication slot:\", err)\n\t}\n\n\tfmt.Println(\"🔐 The PIN is up to 8 numbers, letters, or symbols. Not just numbers!\")\n\tfmt.Println(\"❌ The key will be lost if the PIN and PUK are locked after 3 incorrect tries.\")\n\tfmt.Println(\"\")\n\tfmt.Print(\"Choose a new PIN/PUK: \")\n\tpin, err := term.ReadPassword(int(os.Stdin.Fd()))\n\tfmt.Print(\"\\n\")\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to read PIN:\", err)\n\t}\n\tif len(pin) < 6 || len(pin) > 8 {\n\t\tlog.Fatalln(\"The PIN needs to be 6-8 characters.\")\n\t}\n\tfmt.Print(\"Repeat PIN/PUK: \")\n\trepeat, err := term.ReadPassword(int(os.Stdin.Fd()))\n\tfmt.Print(\"\\n\")\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to read PIN:\", err)\n\t} else if !bytes.Equal(repeat, pin) {\n\t\tlog.Fatalln(\"PINs don't match!\")\n\t}\n\n\tfmt.Println(\"\")\n\tfmt.Println(\"🧪 Reticulating splines...\")\n\n\tvar key [24]byte\n\tif _, err := rand.Read(key[:]); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := yk.SetManagementKey(piv.DefaultManagementKey, key); err != nil {\n\t\tlog.Println(\"‼️  The default Management Key did not work\")\n\t\tlog.Println(\"\")\n\t\tlog.Println(\"If you know what you're doing, reset PIN, PUK, and\")\n\t\tlog.Println(\"Management Key to the defaults before retrying.\")\n\t\tlog.Println(\"\")\n\t\tlog.Println(\"If you want to wipe all PIV keys and start fresh,\")\n\t\tlog.Fatalln(\"use --really-delete-all-piv-keys ⚠️\")\n\t}\n\tif err := yk.SetMetadata(key, &piv.Metadata{\n\t\tManagementKey: &key,\n\t}); err != nil {\n\t\tlog.Fatalln(\"Failed to store the Management Key on the device:\", err)\n\t}\n\tif err := yk.SetPIN(piv.DefaultPIN, string(pin)); err != nil {\n\t\tlog.Println(\"‼️  The default PIN did not work\")\n\t\tlog.Println(\"\")\n\t\tlog.Println(\"If you know what you're doing, reset PIN, PUK, and\")\n\t\tlog.Println(\"Management Key to the defaults before retrying.\")\n\t\tlog.Println(\"\")\n\t\tlog.Println(\"If you want to wipe all PIV keys and start fresh,\")\n\t\tlog.Fatalln(\"use --really-delete-all-piv-keys ⚠️\")\n\t}\n\tif err := yk.SetPUK(piv.DefaultPUK, string(pin)); err != nil {\n\t\tlog.Println(\"‼️  The default PUK did not work\")\n\t\tlog.Println(\"\")\n\t\tlog.Println(\"If you know what you're doing, reset PIN, PUK, and\")\n\t\tlog.Println(\"Management Key to the defaults before retrying.\")\n\t\tlog.Println(\"\")\n\t\tlog.Println(\"If you want to wipe all PIV keys and start fresh,\")\n\t\tlog.Fatalln(\"use --really-delete-all-piv-keys ⚠️\")\n\t}\n\n\tpub, err := yk.GenerateKey(key, piv.SlotAuthentication, piv.Key{\n\t\tAlgorithm:   piv.AlgorithmEC256,\n\t\tPINPolicy:   piv.PINPolicyOnce,\n\t\tTouchPolicy: piv.TouchPolicyAlways,\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to generate key:\", err)\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to generate parent key:\", err)\n\t}\n\tparent := &x509.Certificate{\n\t\tSubject: pkix.Name{\n\t\t\tOrganization:       []string{\"yubikey-agent\"},\n\t\t\tOrganizationalUnit: []string{Version},\n\t\t},\n\t\tPublicKey: priv.Public(),\n\t}\n\ttemplate := &x509.Certificate{\n\t\tSubject: pkix.Name{\n\t\t\tCommonName: \"SSH key\",\n\t\t},\n\t\tNotAfter:     time.Now().AddDate(42, 0, 0),\n\t\tNotBefore:    time.Now(),\n\t\tSerialNumber: randomSerialNumber(),\n\t\tKeyUsage:     x509.KeyUsageKeyAgreement | x509.KeyUsageDigitalSignature,\n\t}\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, template, parent, pub, priv)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to generate certificate:\", err)\n\t}\n\tcert, err := x509.ParseCertificate(certBytes)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to parse certificate:\", err)\n\t}\n\tif err := yk.SetCertificate(key, piv.SlotAuthentication, cert); err != nil {\n\t\tlog.Fatalln(\"Failed to store certificate:\", err)\n\t}\n\n\tsshKey, err := ssh.NewPublicKey(pub)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to generate public key:\", err)\n\t}\n\n\tfmt.Println(\"\")\n\tfmt.Println(\"✅ Done! This YubiKey is secured and ready to go.\")\n\tfmt.Println(\"🤏 When the YubiKey blinks, touch it to authorize the login.\")\n\tfmt.Println(\"\")\n\tfmt.Println(\"🔑 Here's your new shiny SSH public key:\")\n\tos.Stdout.Write(ssh.MarshalAuthorizedKey(sshKey))\n\tfmt.Println(\"\")\n\tfmt.Println(\"Next steps: ensure yubikey-agent is running via launchd/systemd/...,\")\n\tfmt.Println(`set the SSH_AUTH_SOCK environment variable, and test with \"ssh-add -L\"`)\n\tfmt.Println(\"\")\n\tfmt.Println(\"💭 Remember: everything breaks, have a backup plan for when this YubiKey does.\")\n}\n\nfunc randomSerialNumber() *big.Int {\n\tserialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)\n\tserialNumber, err := rand.Int(rand.Reader, serialNumberLimit)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to generate serial number:\", err)\n\t}\n\treturn serialNumber\n}\n"
        },
        {
          "name": "systemd.md",
          "type": "blob",
          "size": 1.3994140625,
          "content": "# Manual Linux setup with systemd\n\nNote: this is usually only necessary in case your distribution doesn't already\nprovide a yubikey-agent as a package.\n\nRefer to [the README](README.md) for a list of distributions providing packages.\n\nFirst, install Go and the [`piv-go` dependencies](https://github.com/go-piv/piv-go#installation), build `yubikey-agent` and place it in `$PATH`.\n\n```text\n$ git clone https://filippo.io/yubikey-agent && cd yubikey-agent\n$ go build && sudo cp yubikey-agent /usr/local/bin/\n```\n\nMake sure you have a `pinentry` program that works for you (terminal-based or graphical) in `$PATH`.\n\nUse `yubikey-agent -setup` to create a new key on the YubiKey.\n\n```text\n$ yubikey-agent -setup\n```\n\nThen, create a systemd user service at `~/.config/systemd/user/yubikey-agent.service`\nwith the contents of [yubikey-agent.service](contrib/systemd/user/yubikey-agent.service).\n\nDepending on your distribution (`systemd <=239` or no user namespace support),\nyou might need to edit the `ExecStart=` line and some of the sandboxing\noptions.\n\nRefresh systemd, make sure that the PC/SC daemon is available, and start the yubikey-agent.\n\n```text\n$ systemctl daemon-reload --user\n$ sudo systemctl enable --now pcscd.socket\n$ systemctl --user enable --now yubikey-agent\n```\n\nFinally, add the following line to your shell profile and restart it.\n\n```\nexport SSH_AUTH_SOCK=\"${XDG_RUNTIME_DIR}/yubikey-agent/yubikey-agent.sock\"\n```\n"
        }
      ]
    }
  ]
}