{
  "metadata": {
    "timestamp": 1736566490883,
    "page": 37,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "thoas/go-funk",
      "stars": 4846,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2734375,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n#GoLand\n.idea"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1376953125,
          "content": "language: go\nbefore_install:\n  - go get golang.org/x/tools/cmd/cover\n  - go get github.com/stretchr/testify\ngo:\n  - \"1.16\"\nscript: make test\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.8662109375,
          "content": "go-funk changelog\n=================\n\n0.1 (2017-01-18)\n----------------\n\nChanges can be seen [here](https://github.com/thoas/go-funk/compare/73b8ae1f6443c9d4acbdc612bbb2ca804bb39b1d...master)\n\n* Better test suite\n* Better documentation\n* Add typesafe implementations:\n\n  * ``Contains``\n  * ``Sum``\n  * ``Reverse``\n  * ``IndexOf``\n  * ``Uniq``\n  * ``Shuffle``\n* Add benchmarks\n\n  * ``Contains``\n  * ``Uniq``\n  * ``Sum``\n* Fix ``redirectValue`` when using a circular reference\n* Add ``Sum`` generic implementation which computes the sum of values in an array\n* Add ``Tail`` generic implementation to retrieve all but the first element of array\n* Add ``Initial`` generic implementation to retrieve all but the last element of array\n* Add ``Last`` generic implementation to retrieve the last element of an array\n* Add ``Head`` generic implementation to retrieve the first element of an array\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2016 Florent Messa\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1103515625,
          "content": "build:\n\tgo build -v ./...\n\ntest:\n\tgo test -v ./...\n\nlint:\n\tgolangci-lint run\n\nbench:\n\tgo test -benchmem -bench .\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 23.3720703125,
          "content": "go-funk\n=======\n\n.. image:: https://secure.travis-ci.org/thoas/go-funk.svg?branch=master\n    :alt: Build Status\n    :target: http://travis-ci.org/thoas/go-funk\n\n.. image:: https://godoc.org/github.com/thoas/go-funk?status.svg\n    :alt: GoDoc\n    :target: https://pkg.go.dev/github.com/thoas/go-funk\n\n.. image:: https://goreportcard.com/badge/github.com/thoas/go-funk\n    :alt: Go report\n    :target: https://goreportcard.com/report/github.com/thoas/go-funk\n\n``go-funk`` is a modern Go library based on reflect_.\n\nGeneric helpers rely on reflect_, be careful this code runs exclusively on runtime so you must have a good test suite.\n\nThese helpers have started as an experiment to learn reflect_. It may look like lodash_ in some aspects but\nit will have its own roadmap. lodash_ is an awesome library with a lot of work behind it, all features included in\n``go-funk`` come from internal use cases.\n\nYou can also find typesafe implementation in the godoc_.\n\nWhy this name?\n--------------\n\nLong story, short answer because ``func`` is a reserved word in Go, I wanted something similar.\n\nInitially this project was named ``fn`` I don't need to explain why that was a bad idea for french speakers :)\n\nLet's ``funk``!\n\n.. image:: https://media.giphy.com/media/3oEjHQKtDXpeGN9rW0/giphy.gif\n\n<3\n\nInstallation\n------------\n\n.. code-block:: bash\n\n    go get github.com/thoas/go-funk\n\nUsage\n-----\n\n.. code-block:: go\n\n    import \"github.com/thoas/go-funk\"\n\nThese examples will be based on the following data model:\n\n.. code-block:: go\n\n    type Foo struct {\n        ID        int\n        FirstName string `tag_name:\"tag 1\"`\n        LastName  string `tag_name:\"tag 2\"`\n        Age       int    `tag_name:\"tag 3\"`\n    }\n\n    func (f Foo) TableName() string {\n        return \"foo\"\n    }\n\nWith fixtures:\n\n.. code-block:: go\n\n    f := &Foo{\n        ID:        1,\n        FirstName: \"Foo\",\n        LastName:  \"Bar\",\n        Age:       30,\n    }\n\nYou can import ``go-funk`` using a basic statement:\n\n.. code-block:: go\n\n    import \"github.com/thoas/go-funk\"\n\nfunk.Contains\n.............\n\nReturns true if an element is present in a iteratee (slice, map, string).\n\nOne frustrating thing in Go is to implement ``contains`` methods for each type, for example:\n\n.. code-block:: go\n\n    func ContainsInt(s []int, e int) bool {\n        for _, a := range s {\n            if a == e {\n                return true\n            }\n        }\n        return false\n    }\n\nthis can be replaced by ``funk.Contains``:\n\n.. code-block:: go\n\n    // slice of string\n    funk.Contains([]string{\"foo\", \"bar\"}, \"bar\") // true\n\n    // slice of Foo ptr\n    funk.Contains([]*Foo{f}, f) // true\n    funk.Contains([]*Foo{f}, func (foo *Foo) bool {\n        return foo.ID == f.ID\n    }) // true\n    funk.Contains([]*Foo{f}, nil) // false\n\n    b := &Foo{\n        ID:        2,\n        FirstName: \"Florent\",\n        LastName:  \"Messa\",\n        Age:       28,\n    }\n\n    funk.Contains([]*Foo{f}, b) // false\n\n    // string\n    funk.Contains(\"florent\", \"rent\") // true\n    funk.Contains(\"florent\", \"foo\") // false\n\n    // even map\n    funk.Contains(map[int]string{1: \"Florent\"}, 1) // true\n    funk.Contains(map[int]string{1: \"Florent\"}, func(key int, name string) bool {\n        return key == 1 // or `name == \"Florent\"` for the value type\n    }) // true\n\nsee also, typesafe implementations: ContainsInt_, ContainsInt64_, ContainsFloat32_, ContainsFloat64_, ContainsString_\n\n.. _ContainsFloat32: https://godoc.org/github.com/thoas/go-funk#ContainsFloat32\n.. _ContainsFloat64: https://godoc.org/github.com/thoas/go-funk#ContainsFloat64\n.. _ContainsInt: https://godoc.org/github.com/thoas/go-funk#ContainsInt\n.. _ContainsInt64: https://godoc.org/github.com/thoas/go-funk#ContainsInt64\n.. _ContainsString: https://godoc.org/github.com/thoas/go-funk#ContainsString\n\nfunk.Intersect\n..............\n\nReturns the intersection between two collections.\n\n.. code-block:: go\n\n    funk.Intersect([]int{1, 2, 3, 4}, []int{2, 4, 6})  // []int{2, 4}\n    funk.Intersect([]string{\"foo\", \"bar\", \"hello\", \"bar\"}, []string{\"foo\", \"bar\"})  // []string{\"foo\", \"bar\"}\n\nsee also, typesafe implementations: IntersectString\n\n.. IntersectString: https://godoc.org/github.com/thoas/go-funk#IntersectString\n\n\nfunk.Difference\n..............\n\nReturns the difference between two collections.\n\n.. code-block:: go\n\n    funk.Difference([]int{1, 2, 3, 4}, []int{2, 4, 6})  // []int{1, 3}, []int{6}\n    funk.Difference([]string{\"foo\", \"bar\", \"hello\", \"bar\"}, []string{\"foo\", \"bar\"})  // []string{\"hello\"}, []string{}\n\nsee also, typesafe implementations: DifferenceString\n\n.. DifferenceString: https://godoc.org/github.com/thoas/go-funk#DifferenceString\n\n\nfunk.IndexOf\n............\n\nGets the index at which the first occurrence of a value is found in an array or return -1\nif the value cannot be found.\n\n.. code-block:: go\n\n    // slice of string\n    funk.IndexOf([]string{\"foo\", \"bar\"}, \"bar\") // 1\n    funk.IndexOf([]string{\"foo\", \"bar\"}, func(value string) bool {\n        return value == \"bar\"\n    }) // 1\n    funk.IndexOf([]string{\"foo\", \"bar\"}, \"gilles\") // -1\n\nsee also, typesafe implementations: IndexOfInt_, IndexOfInt64_, IndexOfFloat32_, IndexOfFloat64_, IndexOfString_\n\n.. _IndexOfFloat32: https://godoc.org/github.com/thoas/go-funk#IndexOfFloat32\n.. _IndexOfFloat64: https://godoc.org/github.com/thoas/go-funk#IndexOfFloat64\n.. _IndexOfInt: https://godoc.org/github.com/thoas/go-funk#IndexOfInt\n.. _IndexOfInt64: https://godoc.org/github.com/thoas/go-funk#IndexOfInt64\n.. _IndexOfString: https://godoc.org/github.com/thoas/go-funk#IndexOfString\n\nfunk.LastIndexOf\n................\n\nGets the index at which the last occurrence of a value is found in an array or return -1\nif the value cannot be found.\n\n.. code-block:: go\n\n    // slice of string\n    funk.LastIndexOf([]string{\"foo\", \"bar\", \"bar\"}, \"bar\") // 2\n    funk.LastIndexOf([]string{\"foo\", \"bar\", \"bar\"}, func(value string) bool {\n        return value == \"bar\"\n    }) // 2\n    funk.LastIndexOf([]string{\"foo\", \"bar\"}, \"gilles\") // -1\n\nsee also, typesafe implementations: LastIndexOfInt_, LastIndexOfInt64_, LastIndexOfFloat32_, LastIndexOfFloat64_, LastIndexOfString_\n\n.. _LastIndexOfFloat32: https://godoc.org/github.com/thoas/go-funk#LastIndexOfFloat32\n.. _LastIndexOfFloat64: https://godoc.org/github.com/thoas/go-funk#LastIndexOfFloat64\n.. _LastIndexOfInt: https://godoc.org/github.com/thoas/go-funk#LastIndexOfInt\n.. _LastIndexOfInt64: https://godoc.org/github.com/thoas/go-funk#LastIndexOfInt64\n.. _LastIndexOfString: https://godoc.org/github.com/thoas/go-funk#LastIndexOfString\n\nfunk.ToMap\n..........\n\nTransforms a slice or an array of structs to a map based on a ``pivot`` field.\n\n.. code-block:: go\n\n    f := &Foo{\n        ID:        1,\n        FirstName: \"Gilles\",\n        LastName:  \"Fabio\",\n        Age:       70,\n    }\n\n    b := &Foo{\n        ID:        2,\n        FirstName: \"Florent\",\n        LastName:  \"Messa\",\n        Age:       80,\n    }\n\n    results := []*Foo{f, b}\n\n    mapping := funk.ToMap(results, \"ID\") // map[int]*Foo{1: f, 2: b}\n\nfunk.ToSet\n..........\n\nTransforms an array or a slice to a set (a map with zero-size values).\n\n.. code-block:: go\n\n    f := Foo{\n        ID:        1,\n        FirstName: \"Gilles\",\n        LastName:  \"Fabio\",\n        Age:       70,\n    }\n\n    b := Foo{\n        ID:        2,\n        FirstName: \"Florent\",\n        LastName:  \"Messa\",\n        Age:       80,\n    }\n\n    mapping := funk.ToSet([]Foo{f, b}) // map[Foo]stuct{}{f: struct{}{}, b: struct{}{}}\n\n    mapping := funk.ToSet([4]int{1, 1, 2, 2}) // map[int]struct{}{1: struct{}{}, 2: struct{}{}}\n\n\n\nfunk.Filter\n...........\n\nFilters a slice based on a predicate.\n\n.. code-block:: go\n\n    r := funk.Filter([]int{1, 2, 3, 4}, func(x int) bool {\n        return x%2 == 0\n    }) // []int{2, 4}\n\nsee also, typesafe implementations: FilterInt_, FilterInt64_, FilterFloat32_, FilterFloat64_, FilterString_\n\n.. _FilterFloat32: https://godoc.org/github.com/thoas/go-funk#FilterFloat32\n.. _FilterFloat64: https://godoc.org/github.com/thoas/go-funk#FilterFloat64\n.. _FilterInt: https://godoc.org/github.com/thoas/go-funk#FilterInt\n.. _FilterInt64: https://godoc.org/github.com/thoas/go-funk#FilterInt64\n.. _FilterString: https://godoc.org/github.com/thoas/go-funk#FilterString\n\nfunk.Reduce\n...........\n\nReduces an iteratee based on an accumulator function or operation rune for numbers.\n\n.. code-block:: go\n\n    // Using operation runes. '+' and '*' only supported.\n    r := funk.Reduce([]int{1, 2, 3, 4}, '+', float64(0)) // 10\n    r := funk.Reduce([]int{1, 2, 3, 4}, '*', 1) // 24\n\n    // Using accumulator function\n    r := funk.Reduce([]int{1, 2, 3, 4}, func(acc float64, num int) float64 {\n        return acc + float64(num)\n    }, float64(0)) // 10\n\n    r := funk.Reduce([]int{1, 2, 3, 4}, func(acc string, num int) string {\n        return acc + fmt.Sprint(num)\n    }, \"\") // \"1234\"\n\nfunk.Find\n.........\n\nFinds an element in a slice based on a predicate.\n\n.. code-block:: go\n\n    r := funk.Find([]int{1, 2, 3, 4}, func(x int) bool {\n        return x%2 == 0\n    }) // 2\n\nsee also, typesafe implementations: FindInt_, FindInt64_, FindFloat32_, FindFloat64_, FindString_\n\n.. _FindFloat32: https://godoc.org/github.com/thoas/go-funk#FindFloat32\n.. _FindFloat64: https://godoc.org/github.com/thoas/go-funk#FindFloat64\n.. _FindInt: https://godoc.org/github.com/thoas/go-funk#FindInt\n.. _FindInt64: https://godoc.org/github.com/thoas/go-funk#FindInt64\n.. _FindString: https://godoc.org/github.com/thoas/go-funk#FindString\n\nfunk.Map\n........\n\nManipulates an iteratee (map, slice) and transforms it to another type:\n\n* map -> slice\n* map -> map\n* slice -> map\n* slice -> slice\n\n.. code-block:: go\n\n    r := funk.Map([]int{1, 2, 3, 4}, func(x int) int {\n        return x * 2\n    }) // []int{2, 4, 6, 8}\n\n    r := funk.Map([]int{1, 2, 3, 4}, func(x int) string {\n        return \"Hello\"\n    }) // []string{\"Hello\", \"Hello\", \"Hello\", \"Hello\"}\n\n    r = funk.Map([]int{1, 2, 3, 4}, func(x int) (int, int) {\n        return x, x\n    }) // map[int]int{1: 1, 2: 2, 3: 3, 4: 4}\n\n    mapping := map[int]string{\n        1: \"Florent\",\n        2: \"Gilles\",\n    }\n\n    r = funk.Map(mapping, func(k int, v string) int {\n        return k\n    }) // []int{1, 2}\n\n    r = funk.Map(mapping, func(k int, v string) (string, string) {\n        return fmt.Sprintf(\"%d\", k), v\n    }) // map[string]string{\"1\": \"Florent\", \"2\": \"Gilles\"}\n\nfunk.FlatMap\n............\n\nManipulates an iteratee (map, slice) and transforms it to to a flattened collection of another type:\n\n* map -> slice\n* slice -> slice\n\n.. code-block:: go\n\n    r := funk.FlatMap([][]int{{1, 2}, {3, 4}}, func(x []int) []int {\n        return append(x, 0)\n    }) // []int{1, 2, 0, 3, 4, 0}\n\n    mapping := map[string][]int{\n        \"Florent\": {1, 2},\n        \"Gilles\": {3, 4},\n    }\n\n    r = funk.FlatMap(mapping, func(k string, v []int) []int {\n        return v\n    }) // []int{1, 2, 3, 4}\n\nfunk.Get\n........\n\nRetrieves the value at path of struct(s) or map(s).\n\n.. code-block:: go\n\n    var bar *Bar = &Bar{\n        Name: \"Test\",\n        Bars: []*Bar{\n            &Bar{\n                Name: \"Level1-1\",\n                Bar: &Bar{\n                    Name: \"Level2-1\",\n                },\n            },\n            &Bar{\n                Name: \"Level1-2\",\n                Bar: &Bar{\n                    Name: \"Level2-2\",\n                },\n            },\n        },\n    }\n\n    var foo *Foo = &Foo{\n        ID:        1,\n        FirstName: \"Dark\",\n        LastName:  \"Vador\",\n        Age:       30,\n        Bar:       bar,\n        Bars: []*Bar{\n            bar,\n            bar,\n        },\n    }\n\n    funk.Get([]*Foo{foo}, \"Bar.Bars.Bar.Name\") // []string{\"Level2-1\", \"Level2-2\"}\n    funk.Get(foo, \"Bar.Bars.Bar.Name\") // []string{\"Level2-1\", \"Level2-2\"}\n    funk.Get(foo, \"Bar.Name\") // Test\n\n``funk.Get`` also support ``map`` values:\n\n.. code-block:: go\n\n    bar := map[string]interface{}{\n        \"Name\": \"Test\",\n    }\n\n    foo1 := map[string]interface{}{\n        \"ID\":        1,\n        \"FirstName\": \"Dark\",\n        \"LastName\":  \"Vador\",\n        \"Age\":       30,\n        \"Bar\":       bar,\n    }\n\n    foo2 := &map[string]interface{}{\n        \"ID\":        1,\n        \"FirstName\": \"Dark\",\n        \"LastName\":  \"Vador\",\n        \"Age\":       30,\n        \"Labels\": map[string]interface{} {\n            \"example.com/hello\": \"world\",\n        },\n    } // foo2.Bar is nil\n\n    funk.Get(bar, \"Name\") // \"Test\"\n    funk.Get([]map[string]interface{}{foo1, foo2}, \"Bar.Name\") // []string{\"Test\"}\n    funk.Get(foo2, \"Bar.Name\") // nil\n    funk.Get(foo2, `Labels.\"example.com/hello\"`) // world\n\n\n``funk.Get`` also handles ``nil`` values:\n\n.. code-block:: go\n\n    bar := &Bar{\n        Name: \"Test\",\n    }\n\n    foo1 := &Foo{\n        ID:        1,\n        FirstName: \"Dark\",\n        LastName:  \"Vador\",\n        Age:       30,\n        Bar:       bar,\n    }\n\n    foo2 := &Foo{\n        ID:        1,\n        FirstName: \"Dark\",\n        LastName:  \"Vador\",\n        Age:       30,\n    } // foo2.Bar is nil\n\n    funk.Get([]*Foo{foo1, foo2}, \"Bar.Name\") // []string{\"Test\"}\n    funk.Get(foo2, \"Bar.Name\") // nil\n\n\n\nfunk.GetOrElse\n..............\n\nRetrieves the value of the pointer or default.\n\n.. code-block:: go\n\n    str := \"hello world\"\n    GetOrElse(&str, \"foobar\")   // string{\"hello world\"}\n    GetOrElse(str, \"foobar\")    // string{\"hello world\"}\n    GetOrElse(nil, \"foobar\")    // string{\"foobar\"}\n\nfunk.Set\n........\nSet value at a path of a struct\n\n.. code-block:: go\n\n    var bar Bar = Bar{\n        Name: \"level-0\",\n        Bar: &Bar{\n            Name: \"level-1\",\n            Bars: []*Bar{\n                {Name: \"level2-1\"},\n                {Name: \"level2-2\"},\n            },\n        },\n    }\n\n    _ = Set(&bar, \"level-0-new\", \"Name\")\n    fmt.Println(bar.Name) // \"level-0-new\"\n\n    MustSet(&bar, \"level-1-new\", \"Bar.Name\")\n    fmt.Println(bar.Bar.Name) // \"level-1-new\"\n\n    Set(&bar, \"level-2-new\", \"Bar.Bars.Name\")\n    fmt.Println(bar.Bar.Bars[0].Name) // \"level-2-new\"\n    fmt.Println(bar.Bar.Bars[1].Name) // \"level-2-new\"\n\nfunk.MustSet\n............\nShort hand for funk.Set if struct does not contain interface{} field type to discard errors.\n\nfunk.Prune\n..........\nCopy a struct with only selected fields. Slice is handled by pruning all elements.\n\n.. code-block:: go\n\n    bar := &Bar{\n        Name: \"Test\",\n    }\n\n    foo1 := &Foo{\n        ID:        1,\n        FirstName: \"Dark\",\n        LastName:  \"Vador\",\n        Bar:       bar,\n    }\n\n    pruned, _ := Prune(foo1, []string{\"FirstName\", \"Bar.Name\"})\n    // *Foo{\n    //    ID:        0,\n    //    FirstName: \"Dark\",\n    //    LastName:  \"\",\n    //    Bar:       &Bar{Name: \"Test},\n    // }\n\nfunk.PruneByTag\n..........\nSame functionality as funk.Prune, but uses struct tags instead of struct field names.\n\nfunk.Keys\n.........\n\nCreates an array of the own enumerable map keys or struct field names.\n\n.. code-block:: go\n\n    funk.Keys(map[string]int{\"one\": 1, \"two\": 2}) // []string{\"one\", \"two\"} (iteration order is not guaranteed)\n\n    foo := &Foo{\n        ID:        1,\n        FirstName: \"Dark\",\n        LastName:  \"Vador\",\n        Age:       30,\n    }\n\n    funk.Keys(foo) // []string{\"ID\", \"FirstName\", \"LastName\", \"Age\"} (iteration order is not guaranteed)\n\nfunk.Values\n...........\n\nCreates an array of the own enumerable map values or struct field values.\n\n.. code-block:: go\n\n    funk.Values(map[string]int{\"one\": 1, \"two\": 2}) // []int{1, 2} (iteration order is not guaranteed)\n\n    foo := &Foo{\n        ID:        1,\n        FirstName: \"Dark\",\n        LastName:  \"Vador\",\n        Age:       30,\n    }\n\n    funk.Values(foo) // []interface{}{1, \"Dark\", \"Vador\", 30} (iteration order is not guaranteed)\n\nfunk.ForEach\n............\n\nRange over an iteratee (map, slice).\n\nOr update element in slice(Not map, reflect#Value#MapIndex#CanSet is false).\n\n.. code-block:: go\n\n    funk.ForEach([]int{1, 2, 3, 4}, func(x int) {\n        fmt.Println(x)\n    })\n\n    foo := []int{1,2,3}\n    funk.ForEach(foo, func(x *int){ *x = *x * 2})\n    fmt.Println(foo) // []int{2, 4, 6}\n\nfunk.ForEachRight\n............\n\nRange over an iteratee (map, slice) from the right.\n\n.. code-block:: go\n\n    results := []int{}\n\n    funk.ForEachRight([]int{1, 2, 3, 4}, func(x int) {\n        results = append(results, x)\n    })\n\n    fmt.Println(results) // []int{4, 3, 2, 1}\n\nfunk.Chunk\n..........\n\nCreates an array of elements split into groups with the length of the size.\nIf array can't be split evenly, the final chunk will be the remaining element.\n\n.. code-block:: go\n\n    funk.Chunk([]int{1, 2, 3, 4, 5}, 2) // [][]int{[]int{1, 2}, []int{3, 4}, []int{5}}\n\nfunk.FlattenDeep\n................\n\nRecursively flattens an array.\n\n.. code-block:: go\n\n    funk.FlattenDeep([][]int{[]int{1, 2}, []int{3, 4}}) // []int{1, 2, 3, 4}\n\nfunk.Uniq\n.........\n\nCreates an array with unique values.\n\n.. code-block:: go\n\n    funk.Uniq([]int{0, 1, 1, 2, 3, 0, 0, 12}) // []int{0, 1, 2, 3, 12}\n\nsee also, typesafe implementations: UniqInt_, UniqInt64_, UniqFloat32_, UniqFloat64_, UniqString_\n\n.. _UniqFloat32: https://godoc.org/github.com/thoas/go-funk#UniqFloat32\n.. _UniqFloat64: https://godoc.org/github.com/thoas/go-funk#UniqFloat64\n.. _UniqInt: https://godoc.org/github.com/thoas/go-funk#UniqInt\n.. _UniqInt64: https://godoc.org/github.com/thoas/go-funk#UniqInt64\n.. _UniqString: https://godoc.org/github.com/thoas/go-funk#UniqString\n\nfunk.UniqBy\n.........\n\nCreates an array with unique values returned by a callback.\n\n.. code-block:: go\n\n    funk.UniqBy([]int{0, 1, 1, 2, 3, 0, 0, 12}, func(nbr int) int {\n\t\treturn nbr % 3\n\t}) // []int{0, 1, 2}\n\n    foo1 := Foo{\n        ID: 42,\n        FirstName: \"Bob\",\n    }\n    foo2 := Foo{\n        ID: 42,\n        FirstName: \"Bob\",\n    }\n    funk.UniqBy([]Foo{foo1, foo2}, func(f Foo) int {\n\t\treturn f.ID\n\t}) // []Foo{ Foo{ID: 42, Firstname: \"Bob\"} }\n\nfunk.Drop\n.........\n\nCreates an array/slice with `n` elements dropped from the beginning.\n\n.. code-block:: go\n\n    funk.Drop([]int{0, 0, 0, 0}, 3) // []int{0}\n\nsee also, typesafe implementations: DropInt_, DropInt32_, DropInt64_, DropFloat32_, DropFloat64_, DropString_\n\n.. _DropInt: https://godoc.org/github.com/thoas/go-funk#DropInt\n.. _DropInt32: https://godoc.org/github.com/thoas/go-funk#DropInt64\n.. _DropInt64: https://godoc.org/github.com/thoas/go-funk#DropInt64\n.. _DropFloat32: https://godoc.org/github.com/thoas/go-funk#DropFloat32\n.. _DropFloat64: https://godoc.org/github.com/thoas/go-funk#DropFloat64\n.. _DropString: https://godoc.org/github.com/thoas/go-funk#DropString\n\nfunk.Initial\n............\n\nGets all but the last element of array.\n\n.. code-block:: go\n\n    funk.Initial([]int{0, 1, 2, 3, 4}) // []int{0, 1, 2, 3}\n\nfunk.Tail\n.........\n\nGets all but the first element of array.\n\n.. code-block:: go\n\n    funk.Tail([]int{0, 1, 2, 3, 4}) // []int{1, 2, 3, 4}\n\nfunk.Shuffle\n............\n\nCreates an array of shuffled values.\n\n.. code-block:: go\n\n    funk.Shuffle([]int{0, 1, 2, 3, 4}) // []int{2, 1, 3, 4, 0}\n\n\nsee also, typesafe implementations: ShuffleInt_, ShuffleInt64_, ShuffleFloat32_, ShuffleFloat64_, ShuffleString_\n\n.. _ShuffleFloat32: https://godoc.org/github.com/thoas/go-funk#ShuffleFloat32\n.. _ShuffleFloat64: https://godoc.org/github.com/thoas/go-funk#ShuffleFloat64\n.. _ShuffleInt: https://godoc.org/github.com/thoas/go-funk#ShuffleInt\n.. _ShuffleInt64: https://godoc.org/github.com/thoas/go-funk#ShuffleInt64\n.. _ShuffleString: https://godoc.org/github.com/thoas/go-funk#ShuffleString\n\nfunk.Subtract\n.............\n\nReturns the subtraction between two collections. It preserve order.\n\n.. code-block:: go\n\n    funk.Subtract([]int{0, 1, 2, 3, 4}, []int{0, 4}) // []int{1, 2, 3}\n    funk.Subtract([]int{0, 3, 2, 3, 4}, []int{0, 4}) // []int{3, 2, 3}\n\n\nsee also, typesafe implementations: SubtractString_\n\n.. SubtractString: https://godoc.org/github.com/thoas/go-funk#SubtractString\n\nfunk.Sum\n........\n\nComputes the sum of the values in an array.\n\n.. code-block:: go\n\n    funk.Sum([]int{0, 1, 2, 3, 4}) // 10.0\n    funk.Sum([]interface{}{0.5, 1, 2, 3, 4}) // 10.5\n\nsee also, typesafe implementations: SumInt_, SumInt64_, SumFloat32_, SumFloat64_\n\n.. _SumFloat32: https://godoc.org/github.com/thoas/go-funk#SumFloat32\n.. _SumFloat64: https://godoc.org/github.com/thoas/go-funk#SumFloat64\n.. _SumInt: https://godoc.org/github.com/thoas/go-funk#SumInt\n.. _SumInt64: https://godoc.org/github.com/thoas/go-funk#SumInt64\n\nfunk.Reverse\n............\n\nTransforms an array such that the first element will become the last, the second element\nwill become the second to last, etc.\n\n.. code-block:: go\n\n    funk.Reverse([]int{0, 1, 2, 3, 4}) // []int{4, 3, 2, 1, 0}\n\nsee also, typesafe implementations: ReverseInt_, ReverseInt64_, ReverseFloat32_, ReverseFloat64_, ReverseString_, ReverseStrings_\n\n.. _ReverseFloat32: https://godoc.org/github.com/thoas/go-funk#ReverseFloat32\n.. _ReverseFloat64: https://godoc.org/github.com/thoas/go-funk#ReverseFloat64\n.. _ReverseInt: https://godoc.org/github.com/thoas/go-funk#ReverseInt\n.. _ReverseInt64: https://godoc.org/github.com/thoas/go-funk#ReverseInt64\n.. _ReverseString: https://godoc.org/github.com/thoas/go-funk#ReverseString\n.. _ReverseStrings: https://godoc.org/github.com/thoas/go-funk#ReverseStrings\n\nfunk.SliceOf\n............\n\nReturns a slice based on an element.\n\n.. code-block:: go\n\n    funk.SliceOf(f) // will return a []*Foo{f}\n\nfunk.RandomInt\n..............\n\nGenerates a random int, based on a min and max values.\n\n.. code-block:: go\n\n    funk.RandomInt(0, 100) // will be between 0 and 100\n\nfunk.RandomString\n.................\n\nGenerates a random string with a fixed length.\n\n.. code-block:: go\n\n    funk.RandomString(4) // will be a string of 4 random characters\n\nfunk.Shard\n..........\n\nGenerates a sharded string with a fixed length and depth.\n\n.. code-block:: go\n\n    funk.Shard(\"e89d66bdfdd4dd26b682cc77e23a86eb\", 1, 2, false) // []string{\"e\", \"8\", \"e89d66bdfdd4dd26b682cc77e23a86eb\"}\n\n    funk.Shard(\"e89d66bdfdd4dd26b682cc77e23a86eb\", 2, 2, false) // []string{\"e8\", \"9d\", \"e89d66bdfdd4dd26b682cc77e23a86eb\"}\n\n    funk.Shard(\"e89d66bdfdd4dd26b682cc77e23a86eb\", 2, 3, true) // []string{\"e8\", \"9d\", \"66\", \"bdfdd4dd26b682cc77e23a86eb\"}\n\nfunk.Subset\n.............\n\nReturns true if a collection is a subset of another\n\n.. code-block:: go\n\n    funk.Subset([]int{1, 2, 4}, []int{1, 2, 3, 4, 5}) // true\n    funk.Subset([]string{\"foo\", \"bar\"},[]string{\"foo\", \"bar\", \"hello\", \"bar\", \"hi\"}) //true\n\n\nPerformance\n-----------\n\n``go-funk`` currently has an open issue about performance_, don't hesitate to participate in the discussion\nto enhance the generic helpers implementations.\n\nLet's stop beating around the bush, a typesafe implementation in pure Go of ``funk.Contains``, let's say for example:\n\n.. code-block:: go\n\n    func ContainsInt(s []int, e int) bool {\n        for _, a := range s {\n            if a == e {\n                return true\n            }\n        }\n        return false\n    }\n\nwill always outperform an implementation based on reflect_ in terms of speed and allocs because of\nhow it's implemented in the language.\n\nIf you want a similarity, gorm_ will always be slower than sqlx_ (which is very low level btw) and will use more allocs.\n\nYou must not think generic helpers of ``go-funk`` as a replacement when you are dealing with performance in your codebase,\nyou should use typesafe implementations instead.\n\nContributing\n------------\n\n* Ping me on twitter `@thoas <https://twitter.com/thoas>`_ (DMs, mentions, whatever :))\n* Fork the `project <https://github.com/thoas/go-funk>`_\n* Fix `open issues <https://github.com/thoas/go-funk/issues>`_ or request new features\n\nDon't hesitate ;)\n\nAuthors\n-------\n\n* Florent Messa\n* Gilles Fabio\n* Alexey Pokhozhaev\n* Alexandre Nicolaie\n\n.. _reflect: https://golang.org/pkg/reflect/\n.. _lodash: https://lodash.com/\n.. _performance: https://github.com/thoas/go-funk/issues/19\n.. _gorm: https://github.com/jinzhu/gorm\n.. _sqlx: https://github.com/jmoiron/sqlx\n.. _godoc: https://godoc.org/github.com/thoas/go-funk\n"
        },
        {
          "name": "assign.go",
          "type": "blob",
          "size": 4.3515625,
          "content": "package funk\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// Set assigns in at path with value val. i.e. in.path = val\n// in accepts types of ptr to struct, ptr to variable, slice and ptr to slice.\n// Along the path, interface{} is supported and nil ptr is initialized to ptr to zero value\n// of the type until the variable to be set is obtained.\n// It returns errors when encountering along the path unknown types, uninitialized\n// interface{} or interface{} containing struct directly (not ptr to struct).\n//\n// Slice is resolved the same way in funk.Get(), by traversing each element of the slice,\n// so that each element of the slice's corresponding field are going to be set to the same provided val.\n// If Set is called on slice with empty path \"\", it behaves the same as funk.Fill()\n//\n// If in is well formed, i.e. do not expect above descripted errors to happen, funk.MustSet()\n// is a short hand wrapper to discard error return\nfunc Set(in interface{}, val interface{}, path string) error {\n\tif in == nil {\n\t\treturn errors.New(\"cannot set nil\")\n\t}\n\tparts := []string{}\n\tif path != \"\" {\n\t\tparts = strings.Split(path, \".\")\n\t}\n\treturn setByParts(in, val, parts)\n}\n\n// we need this layer to handle interface{} type\nfunc setByParts(in interface{}, val interface{}, parts []string) error {\n\n\tif in == nil {\n\t\t// nil interface can happen during traversing the path\n\t\treturn errors.New(\"cannot traverse nil/uninitialized interface{}\")\n\t}\n\n\tinValue := reflect.ValueOf(in)\n\tinKind := inValue.Type().Kind()\n\n\t// Note: if interface contains a struct (not ptr to struct) then the content of the struct cannot be set.\n\t// I.e. it is not CanAddr() or CanSet()\n\t// So we require in interface{} to be a ptr, slice or array\n\tif inKind == reflect.Ptr {\n\t\tinValue = inValue.Elem() // if it is ptr we set its content not ptr its self\n\t} else if inKind != reflect.Array && inKind != reflect.Slice {\n\t\treturn fmt.Errorf(\"Type %s not supported by Set\", inValue.Type().String())\n\t}\n\n\treturn set(inValue, reflect.ValueOf(val), parts)\n}\n\n// traverse inValue using path in parts and set the dst to be setValue\nfunc set(inValue reflect.Value, setValue reflect.Value, parts []string) error {\n\n\t// traverse the path to get the inValue we need to set\n\ti := 0\n\tfor i < len(parts) {\n\n\t\tkind := inValue.Kind()\n\n\t\tswitch kind {\n\t\tcase reflect.Invalid:\n\t\t\t// do not expect this case to happen\n\t\t\treturn errors.New(\"nil pointer found along the path\")\n\t\tcase reflect.Struct:\n\t\t\tfValue := inValue.FieldByName(parts[i])\n\t\t\tif !fValue.IsValid() {\n\t\t\t\treturn fmt.Errorf(\"field name %v is not found in struct %v\", parts[i], inValue.Type().String())\n\t\t\t}\n\t\t\tif !fValue.CanSet() {\n\t\t\t\treturn fmt.Errorf(\"field name %v is not exported in struct %v\", parts[i], inValue.Type().String())\n\t\t\t}\n\t\t\tinValue = fValue\n\t\t\ti++\n\t\tcase reflect.Slice, reflect.Array:\n\t\t\t// set all its elements\n\t\t\tlength := inValue.Len()\n\t\t\tfor j := 0; j < length; j++ {\n\t\t\t\terr := set(inValue.Index(j), setValue, parts[i:])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\tcase reflect.Ptr:\n\t\t\t// only traverse down one level\n\t\t\tif inValue.IsNil() {\n\t\t\t\t// we initialize nil ptr to ptr to zero value of the type\n\t\t\t\t// and continue traversing\n\t\t\t\tinValue.Set(reflect.New(inValue.Type().Elem()))\n\t\t\t}\n\t\t\t// traverse the ptr until it is not pointer any more or is nil again\n\t\t\tinValue = redirectValue(inValue)\n\t\tcase reflect.Interface:\n\t\t\t// Note: if interface contains a struct (not ptr to struct) then the content of the struct cannot be set.\n\t\t\t// I.e. it is not CanAddr() or CanSet(). This is why setByParts has a nil ptr check.\n\t\t\t// we treat this as a new call to setByParts, and it will do proper check of the types\n\t\t\treturn setByParts(inValue.Interface(), setValue.Interface(), parts[i:])\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"kind %v in path %v is not supported\", kind, parts[i])\n\t\t}\n\n\t}\n\t// here inValue holds the value we need to set\n\n\t// interface{} can be set to any val\n\t// other types we ensure the type matches\n\tif inValue.Kind() != setValue.Kind() && inValue.Kind() != reflect.Interface {\n\t\treturn fmt.Errorf(\"cannot set target of type %v with type %v\", inValue.Kind(), setValue.Kind())\n\t}\n\tinValue.Set(setValue)\n\n\treturn nil\n}\n\n// MustSet is functionally the same as Set.\n// It panics instead of returning error.\n// It is safe to use if the in value is well formed.\nfunc MustSet(in interface{}, val interface{}, path string) {\n\terr := Set(in, val, path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "assign_test.go",
          "type": "blob",
          "size": 10.427734375,
          "content": "package funk\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSet_EmptyPath(t *testing.T) {\n\t// it is supposed to change the var passed in\n\tvar testCases = []struct {\n\t\t// will use path = \"\"\n\t\tOriginal interface{}\n\t\tSetVal   interface{}\n\t}{\n\t\t// int\n\t\t{\n\t\t\tOriginal: 100,\n\t\t\tSetVal:   1,\n\t\t},\n\t\t// string\n\t\t{\n\t\t\tOriginal: \"\",\n\t\t\tSetVal:   \"val\",\n\t\t},\n\t\t// struct\n\t\t{\n\t\t\tOriginal: Bar{Name: \"bar\"},\n\t\t\tSetVal:   Bar{Name: \"val\"},\n\t\t},\n\t\t// slice\n\t\t{\n\t\t\tOriginal: []Bar{{Name: \"bar\"}},\n\t\t\tSetVal:   []Bar{{Name: \"val1\"}, {Name: \"val2\"}},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\t// use empty path\n\t\t\t// must take the addr of the variable to be set\n\t\t\terr := Set(&tc.Original, tc.SetVal, \"\")\n\t\t\tis.NoError(err)\n\t\t\tis.Equal(tc.Original, tc.SetVal) // original should be set to SetVal\n\t\t})\n\t}\n}\n\nfunc TestSet_StructBasicOneLevel(t *testing.T) {\n\tis := assert.New(t)\n\t// we set field one by one of baz with expected value\n\tbaz := Foo{\n\t\tID:        100,\n\t\tFirstName: \"firstname\",\n\t\tLastName:  \"lastname\",\n\t\tAge:       23,\n\t\tBar:       &Bar{Name: \"bar\"},\n\t\tBars:      []*Bar{{Name: \"1\"}},\n\t\tEmptyValue: sql.NullInt64{\n\t\t\tInt64: 64,\n\t\t\tValid: false,\n\t\t},\n\t}\n\texpected := Foo{\n\t\tID:        1,\n\t\tFirstName: \"firstname1\",\n\t\tLastName:  \"lastname1\",\n\t\tAge:       24,\n\t\tBar:       &Bar{Name: \"b1\", Bar: &Bar{Name: \"b2\"}},\n\t\tBars:      []*Bar{{Name: \"1\"}, {Name: \"2\"}},\n\t\tEmptyValue: sql.NullInt64{\n\t\t\tInt64: 11,\n\t\t\tValid: true,\n\t\t},\n\t}\n\terr := Set(&baz, 1, \"ID\")\n\tis.NoError(err)\n\terr = Set(&baz, expected.FirstName, \"FirstName\")\n\tis.NoError(err)\n\terr = Set(&baz, expected.LastName, \"LastName\")\n\tis.NoError(err)\n\terr = Set(&baz, expected.Age, \"Age\")\n\tis.NoError(err)\n\terr = Set(&baz, expected.Bar, \"Bar\")\n\tis.NoError(err)\n\terr = Set(&baz, expected.Bars, \"Bars\")\n\tis.NoError(err)\n\terr = Set(&baz, expected.EmptyValue, \"EmptyValue\")\n\tis.NoError(err)\n\tis.Equal(baz, expected)\n}\n\nfunc TestSetStruct_MultiLevels(t *testing.T) {\n\n\tvar testCases = []struct {\n\t\tOriginal Bar\n\t\tPath     string\n\t\tSetVal   interface{}\n\t\tExpected Bar\n\t}{\n\t\t// Set slice in 4th level\n\t\t{\n\t\t\tOriginal: Bar{\n\t\t\t\tName: \"1\", // name indicates level\n\t\t\t\tBar: &Bar{\n\t\t\t\t\tName: \"2\",\n\t\t\t\t\tBars: []*Bar{\n\t\t\t\t\t\t{Name: \"3-1\", Bars: []*Bar{{Name: \"4-1\"}, {Name: \"4-2\"}, {Name: \"4-3\"}}},\n\t\t\t\t\t\t{Name: \"3-2\", Bars: []*Bar{{Name: \"4-1\"}, {Name: \"4-2\"}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tPath:   \"Bar.Bars.Bars.Name\",\n\t\t\tSetVal: \"val\",\n\t\t\tExpected: Bar{\n\t\t\t\tName: \"1\",\n\t\t\t\tBar: &Bar{\n\t\t\t\t\tName: \"2\",\n\t\t\t\t\tBars: []*Bar{\n\t\t\t\t\t\t{Name: \"3-1\", Bars: []*Bar{{Name: \"val\"}, {Name: \"val\"}, {Name: \"val\"}}},\n\t\t\t\t\t\t{Name: \"3-2\", Bars: []*Bar{{Name: \"val\"}, {Name: \"val\"}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Set multilevel uninitialized ptr\n\t\t{\n\t\t\tOriginal: Bar{\n\t\t\t\tName: \"1\", // name indicates level\n\t\t\t\tBar:  nil,\n\t\t\t},\n\t\t\tPath:   \"Bar.Bar.Bar.Name\",\n\t\t\tSetVal: \"val\",\n\t\t\tExpected: Bar{\n\t\t\t\tName: \"1\",\n\t\t\t\tBar: &Bar{\n\t\t\t\t\tName: \"\", // level 2\n\t\t\t\t\tBar: &Bar{\n\t\t\t\t\t\tBar: &Bar{\n\t\t\t\t\t\t\tName: \"val\", //level 3\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// mix of uninitialized ptr and slices\n\t\t{\n\t\t\tOriginal: Bar{\n\t\t\t\tName: \"1\", // name indicates level\n\t\t\t\tBar: &Bar{\n\t\t\t\t\tName: \"2\",\n\t\t\t\t\tBars: []*Bar{\n\t\t\t\t\t\t{Name: \"3-1\", Bars: []*Bar{{Name: \"4-1\"}, {Name: \"4-2\"}, {Name: \"4-3\"}}},\n\t\t\t\t\t\t{Name: \"3-2\", Bars: []*Bar{{Name: \"4-1\"}, {Name: \"4-2\"}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tPath:   \"Bar.Bars.Bars.Bar.Name\",\n\t\t\tSetVal: \"val\",\n\t\t\tExpected: Bar{\n\t\t\t\tName: \"1\", // name indicates level\n\t\t\t\tBar: &Bar{\n\t\t\t\t\tName: \"2\",\n\t\t\t\t\tBars: []*Bar{\n\t\t\t\t\t\t{Name: \"3-1\", Bars: []*Bar{{Name: \"4-1\", Bar: &Bar{Name: \"val\"}},\n\t\t\t\t\t\t\t{Name: \"4-2\", Bar: &Bar{Name: \"val\"}}, {Name: \"4-3\", Bar: &Bar{Name: \"val\"}}}},\n\t\t\t\t\t\t{Name: \"3-2\", Bars: []*Bar{{Name: \"4-1\", Bar: &Bar{Name: \"val\"}}, {Name: \"4-2\", Bar: &Bar{Name: \"val\"}}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\t// take the addr and then pass it in\n\t\t\terr := Set(&tc.Original, tc.SetVal, tc.Path)\n\t\t\tis.NoError(err)\n\t\t\tis.Equal(tc.Expected, tc.Original)\n\t\t})\n\t}\n}\n\nfunc TestSet_StructWithCyclicStruct(t *testing.T) {\n\tis := assert.New(t)\n\n\ttestBar := Bar{\n\t\tName: \"testBar\",\n\t\tBar:  nil,\n\t}\n\ttestBar.Bar = &testBar\n\n\terr := Set(&testBar, \"val\", \"Bar.Bar.Name\")\n\tis.NoError(err)\n\tis.Equal(\"val\", testBar.Name)\n}\n\nfunc TestSet_StructWithFieldNotInitialized(t *testing.T) {\n\tis := assert.New(t)\n\tmyFoo := &Foo{\n\t\tBar: nil, // we will try to set bar's field\n\t}\n\terr := Set(myFoo, \"name\", \"Bar.Name\")\n\tis.NoError(err)\n\tis.Equal(\"name\", myFoo.Bar.Name)\n}\n\nfunc TestSet_SlicePassByPtr(t *testing.T) {\n\n\tvar testCases = []struct {\n\t\tOriginal interface{} // slice or array\n\t\tPath     string\n\t\tSetVal   interface{}\n\t\tExpected interface{}\n\t}{\n\t\t// Set Slice itself\n\t\t{\n\t\t\tOriginal: []*Bar{},\n\t\t\tPath:     \"\", // empty path means set the passed in ptr itself\n\t\t\tSetVal:   []*Bar{{Name: \"bar\"}},\n\t\t\tExpected: []*Bar{{Name: \"bar\"}},\n\t\t},\n\t\t// empty slice\n\t\t{\n\t\t\tOriginal: []*Bar{},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []*Bar{},\n\t\t},\n\t\t// slice of ptr\n\t\t{\n\t\t\tOriginal: []*Bar{{Name: \"a\"}, {Name: \"b\"}},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []*Bar{{Name: \"val\"}, {Name: \"val\"}},\n\t\t},\n\t\t// slice of struct\n\t\t{\n\t\t\tOriginal: []Bar{{Name: \"a\"}, {Name: \"b\"}},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []Bar{{Name: \"val\"}, {Name: \"val\"}},\n\t\t},\n\t\t// slice of empty ptr\n\t\t{\n\t\t\tOriginal: []*Bar{nil, nil},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []*Bar{{Name: \"val\"}, {Name: \"val\"}},\n\t\t},\n\t\t// mix of init ptr and nil ptr\n\t\t{\n\t\t\tOriginal: []*Bar{{Name: \"bar\"}, nil},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []*Bar{{Name: \"val\"}, {Name: \"val\"}},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\t// take the addr and then pass it in\n\t\t\terr := Set(&tc.Original, tc.SetVal, tc.Path)\n\t\t\tis.NoError(err)\n\t\t\tis.Equal(tc.Expected, tc.Original)\n\t\t})\n\t}\n}\n\nfunc TestSet_SlicePassDirectly(t *testing.T) {\n\tvar testCases = []struct {\n\t\tOriginal interface{} // slice or array\n\t\tPath     string\n\t\tSetVal   interface{}\n\t\tExpected interface{}\n\t}{\n\t\t// Set Slice itself does not work here since not passing by ptr\n\n\t\t// empty slice\n\t\t{\n\t\t\tOriginal: []*Bar{},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []*Bar{},\n\t\t},\n\t\t// slice of ptr\n\t\t{\n\t\t\tOriginal: []*Bar{{Name: \"a\"}, {Name: \"b\"}},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []*Bar{{Name: \"val\"}, {Name: \"val\"}},\n\t\t},\n\t\t// Array of ptr\n\t\t{\n\t\t\tOriginal: [2]*Bar{{Name: \"a\"}, {Name: \"b\"}},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: [2]*Bar{{Name: \"val\"}, {Name: \"val\"}},\n\t\t},\n\t\t// slice of struct\n\t\t{\n\t\t\tOriginal: []Bar{{Name: \"a\"}, {Name: \"b\"}},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []Bar{{Name: \"val\"}, {Name: \"val\"}},\n\t\t},\n\t\t// slice of empty ptr\n\t\t{\n\t\t\tOriginal: []*Bar{nil, nil},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []*Bar{{Name: \"val\"}, {Name: \"val\"}},\n\t\t},\n\t\t// mix of init ptr and nil ptr\n\t\t{\n\t\t\tOriginal: []*Bar{{Name: \"bar\"}, nil},\n\t\t\tPath:     \"Name\",\n\t\t\tSetVal:   \"val\",\n\t\t\tExpected: []*Bar{{Name: \"val\"}, {Name: \"val\"}},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\t// Not take ptr, pass directly\n\t\t\terr := Set(tc.Original, tc.SetVal, tc.Path)\n\t\t\tis.NoError(err)\n\t\t\tis.Equal(tc.Expected, tc.Original)\n\t\t})\n\t}\n}\n\nfunc TestInterface(t *testing.T) {\n\n\tvar testCases = []struct {\n\t\tOriginalFoo Foo\n\t\tPath        string\n\t\tSetVal      interface{}\n\t\tExpectedFoo Foo\n\t}{\n\t\t// set string field\n\t\t{\n\t\t\tFoo{FirstName: \"\"},\n\t\t\t\"FirstName\",\n\t\t\t\"hi\",\n\t\t\tFoo{FirstName: \"hi\"},\n\t\t},\n\t\t// set interface{} field\n\t\t{\n\t\t\tFoo{FirstName: \"\", GeneralInterface: nil},\n\t\t\t\"GeneralInterface\",\n\t\t\t\"str\",\n\t\t\tFoo{FirstName: \"\", GeneralInterface: \"str\"},\n\t\t},\n\t\t// set field of the interface{} field\n\t\t// Note: set uninitialized interface{} should fail\n\t\t// Note: interface of struct (not ptr to struct) should fail\n\t\t{\n\t\t\tFoo{FirstName: \"\", GeneralInterface: &Foo{FirstName: \"\"}}, // if Foo is not ptr this will fail\n\t\t\t\"GeneralInterface.FirstName\",\n\t\t\t\"foo\",\n\t\t\tFoo{FirstName: \"\", GeneralInterface: &Foo{FirstName: \"foo\"}},\n\t\t},\n\t\t// interface two level\n\t\t{\n\t\t\tFoo{FirstName: \"\", GeneralInterface: &Foo{GeneralInterface: nil}},\n\t\t\t\"GeneralInterface.GeneralInterface\",\n\t\t\t\"val\",\n\t\t\tFoo{FirstName: \"\", GeneralInterface: &Foo{GeneralInterface: \"val\"}},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\terr := Set(&tc.OriginalFoo, tc.SetVal, tc.Path)\n\t\t\tis.NoError(err)\n\t\t\tis.Equal(tc.ExpectedFoo, tc.OriginalFoo)\n\t\t})\n\t}\n\n}\n\nfunc TestSet_ErrorCaces(t *testing.T) {\n\n\tvar testCases = []struct {\n\t\tOriginalFoo Foo\n\t\tPath        string\n\t\tSetVal      interface{}\n\t}{\n\t\t// uninit interface\n\t\t// Itf is not initialized so Set cannot properly allocate type\n\t\t{\n\t\t\tFoo{BarInterface: nil},\n\t\t\t\"BarInterface.Name\",\n\t\t\t\"val\",\n\t\t},\n\t\t{\n\t\t\tFoo{GeneralInterface: &Foo{BarInterface: nil}},\n\t\t\t\"GeneralInterface.BarInterface.Name\",\n\t\t\t\"val\",\n\t\t},\n\t\t// type mismatch\n\t\t{\n\t\t\tFoo{FirstName: \"\"},\n\t\t\t\"FirstName\",\n\t\t\t20,\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\terr := Set(&tc.OriginalFoo, tc.SetVal, tc.Path)\n\t\t\tis.Error(err)\n\t\t})\n\t}\n\n\tt.Run(\"not pointer\", func(t *testing.T) {\n\t\tis := assert.New(t)\n\t\tbaz := Bar{Name: \"dummy\"}\n\t\terr := Set(baz, Bar{Name: \"dummy2\"}, \"Name\")\n\t\tis.Error(err)\n\t})\n\n\tt.Run(\"Unexported field\", func(t *testing.T) {\n\t\tis := assert.New(t)\n\t\ts := struct {\n\t\t\tname string\n\t\t}{name: \"dummy\"}\n\t\terr := Set(&s, s, \"name\")\n\t\tis.Error(err)\n\t})\n}\n\nfunc TestMustSet_Basic(t *testing.T) {\n\tt.Run(\"Variable\", func(t *testing.T) {\n\t\tis := assert.New(t)\n\t\ts := 1\n\t\tMustSet(&s, 2, \"\")\n\t\tis.Equal(2, s)\n\t})\n\n\tt.Run(\"Struct\", func(t *testing.T) {\n\t\tis := assert.New(t)\n\t\ts := Bar{Name: \"a\"}\n\t\tMustSet(&s, \"b\", \"Name\")\n\t\tis.Equal(\"b\", s.Name)\n\t})\n}\n\n// Examples\n\nfunc ExampleSet() {\n\n\tvar bar Bar = Bar{\n\t\tName: \"level-0\",\n\t\tBar: &Bar{\n\t\t\tName: \"level-1\",\n\t\t\tBars: []*Bar{\n\t\t\t\t{Name: \"level2-1\"},\n\t\t\t\t{Name: \"level2-2\"},\n\t\t\t},\n\t\t},\n\t}\n\n\t_ = Set(&bar, \"level-0-new\", \"Name\")\n\tfmt.Println(bar.Name)\n\n\t// discard error use MustSet\n\tMustSet(&bar, \"level-1-new\", \"Bar.Name\")\n\tfmt.Println(bar.Bar.Name)\n\n\t_ = Set(&bar, \"level-2-new\", \"Bar.Bars.Name\")\n\tfmt.Println(bar.Bar.Bars[0].Name)\n\tfmt.Println(bar.Bar.Bars[1].Name)\n\n\t// Output:\n\t// level-0-new\n\t// level-1-new\n\t// level-2-new\n\t// level-2-new\n}\n"
        },
        {
          "name": "benchmark_test.go",
          "type": "blob",
          "size": 2.3056640625,
          "content": "package funk\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n)\n\nconst (\n\tseed      = 918234565\n\tsliceSize = 3614562\n)\n\nfunc sliceGenerator(size uint, r *rand.Rand) (out []int64) {\n\tfor i := uint(0); i < size; i++ {\n\t\tout = append(out, rand.Int63())\n\t}\n\treturn\n}\n\nfunc BenchmarkSubtract(b *testing.B) {\n\tr := rand.New(rand.NewSource(seed))\n\ttestData := sliceGenerator(sliceSize, r)\n\twhat := sliceGenerator(sliceSize, r)\n\n\tb.Run(\"Subtract\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tSubtract(testData, what)\n\t\t}\n\t})\n}\n\nfunc BenchmarkContains(b *testing.B) {\n\tr := rand.New(rand.NewSource(seed))\n\ttestData := sliceGenerator(sliceSize, r)\n\twhat := r.Int63()\n\n\tb.Run(\"ContainsInt64\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tContainsInt64(testData, what)\n\t\t}\n\t})\n\n\tb.Run(\"IndexOfInt64\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tIndexOfInt64(testData, what)\n\t\t}\n\t})\n\n\tb.Run(\"Contains\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tContains(testData, what)\n\t\t}\n\t})\n}\n\nfunc BenchmarkUniq(b *testing.B) {\n\tr := rand.New(rand.NewSource(seed))\n\ttestData := sliceGenerator(sliceSize, r)\n\n\tb.Run(\"UniqInt64\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tUniqInt64(testData)\n\t\t}\n\t})\n\n\tb.Run(\"Uniq\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tUniq(testData)\n\t\t}\n\t})\n}\n\nfunc BenchmarkSum(b *testing.B) {\n\tr := rand.New(rand.NewSource(seed))\n\ttestData := sliceGenerator(sliceSize, r)\n\n\tb.Run(\"SumInt64\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tSumInt64(testData)\n\t\t}\n\t})\n\n\tb.Run(\"Sum\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tSum(testData)\n\t\t}\n\t})\n}\n\nfunc BenchmarkDrop(b *testing.B) {\n\tr := rand.New(rand.NewSource(seed))\n\ttestData := sliceGenerator(sliceSize, r)\n\n\tb.Run(\"DropInt64\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tDropInt64(testData, 1)\n\t\t}\n\t})\n\n\tb.Run(\"Drop\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tDrop(testData, 1)\n\t\t}\n\t})\n}\n\nfunc BenchmarkJoin(b *testing.B) {\n\tr := rand.New(rand.NewSource(seed))\n\tfullArr := sliceGenerator(sliceSize, r)\n\tleftArr := fullArr[:sliceSize/3*2]\n\trightArr := fullArr[sliceSize/3*1:]\n\n\tb.Run(\"InnerJoinInt64\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tJoinInt64(leftArr, rightArr, InnerJoinInt64)\n\t\t}\n\t})\n\n\tb.Run(\"InnerJoin\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tJoin(leftArr, rightArr, InnerJoin)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "builder.go",
          "type": "blob",
          "size": 3.2666015625,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Builder contains all tools which can be chained.\ntype Builder interface {\n\tChunk(size int) Builder\n\tCompact() Builder\n\tDrop(n int) Builder\n\tFilter(predicate interface{}) Builder\n\tFlatten() Builder\n\tFlattenDeep() Builder\n\tInitial() Builder\n\tIntersect(y interface{}) Builder\n\tJoin(rarr interface{}, fnc JoinFnc) Builder\n\tMap(mapFunc interface{}) Builder\n\tFlatMap(mapFunc interface{}) Builder\n\tReverse() Builder\n\tShuffle() Builder\n\tTail() Builder\n\tUniq() Builder\n\tWithout(values ...interface{}) Builder\n\n\tAll() bool\n\tAny() bool\n\tContains(elem interface{}) bool\n\tEvery(elements ...interface{}) bool\n\tFind(predicate interface{}) interface{}\n\tForEach(predicate interface{})\n\tForEachRight(predicate interface{})\n\tHead() interface{}\n\tKeys() interface{}\n\tIndexOf(elem interface{}) int\n\tIsEmpty() bool\n\tLast() interface{}\n\tLastIndexOf(elem interface{}) int\n\tNotEmpty() bool\n\tProduct() float64\n\tReduce(reduceFunc, acc interface{}) interface{}\n\tSum() float64\n\tType() reflect.Type\n\tValue() interface{}\n\tValues() interface{}\n}\n\n// Chain creates a simple new go-funk.Builder from a collection. Each method\n// call generate a new builder containing the previous result.\nfunc Chain(v interface{}) Builder {\n\tisNotNil(v, \"Chain\")\n\n\tvalueType := reflect.TypeOf(v)\n\tif isValidBuilderEntry(valueType) ||\n\t\t(valueType.Kind() == reflect.Ptr && isValidBuilderEntry(valueType.Elem())) {\n\t\treturn &chainBuilder{v}\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Chain\", valueType.String()))\n}\n\n// LazyChain creates a lazy go-funk.Builder from a collection. Each method call\n// generate a new builder containing a method generating the previous value.\n// With that, all data are only generated when we call a tailling method like All or Find.\nfunc LazyChain(v interface{}) Builder {\n\tisNotNil(v, \"LazyChain\")\n\n\tvalueType := reflect.TypeOf(v)\n\tif isValidBuilderEntry(valueType) ||\n\t\t(valueType.Kind() == reflect.Ptr && isValidBuilderEntry(valueType.Elem())) {\n\t\treturn &lazyBuilder{func() interface{} { return v }}\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by LazyChain\", valueType.String()))\n}\n\n// LazyChainWith creates a lazy go-funk.Builder from a generator. Like LazyChain, each\n// method call generate a new builder containing a method generating the previous value.\n// But, instead of using a collection, it takes a generator which can generate values.\n// With LazyChainWith, to can create a generic pipeline of collection transformation and,\n// throw the generator, sending different collection.\nfunc LazyChainWith(generator func() interface{}) Builder {\n\tisNotNil(generator, \"LazyChainWith\")\n\treturn &lazyBuilder{func() interface{} {\n\t\tisNotNil(generator, \"LazyChainWith\")\n\n\t\tv := generator()\n\t\tvalueType := reflect.TypeOf(v)\n\t\tif isValidBuilderEntry(valueType) ||\n\t\t\t(valueType.Kind() == reflect.Ptr && isValidBuilderEntry(valueType.Elem())) {\n\t\t\treturn v\n\t\t}\n\n\t\tpanic(fmt.Sprintf(\"Type %s is not supported by LazyChainWith generator\", valueType.String()))\n\t}}\n}\n\nfunc isNotNil(v interface{}, from string) {\n\tif v == nil {\n\t\tpanic(fmt.Sprintf(\"nil value is not supported by %s\", from))\n\t}\n}\n\nfunc isValidBuilderEntry(valueType reflect.Type) bool {\n\treturn valueType.Kind() == reflect.Slice || valueType.Kind() == reflect.Array ||\n\t\tvalueType.Kind() == reflect.Map ||\n\t\tvalueType.Kind() == reflect.String\n}\n"
        },
        {
          "name": "builder_test.go",
          "type": "blob",
          "size": 5.5693359375,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestChain(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn    interface{}\n\t\tPanic string\n\t}{\n\t\t// Check with array types\n\t\t{In: []int{0, 1, 2}},\n\t\t{In: []string{\"aaa\", \"bbb\", \"ccc\"}},\n\t\t{In: []interface{}{0, false, \"___\"}},\n\n\t\t// Check with map types\n\t\t{In: map[int]string{0: \"aaa\", 1: \"bbb\", 2: \"ccc\"}},\n\t\t{In: map[string]string{\"0\": \"aaa\", \"1\": \"bbb\", \"2\": \"ccc\"}},\n\t\t{In: map[int]interface{}{0: 0, 1: false, 2: \"___\"}},\n\n\t\t// Check with invalid types\n\t\t{false, \"Type bool is not supported by Chain\"},\n\t\t{0, \"Type int is not supported by Chain\"},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tif tc.Panic != \"\" {\n\t\t\t\tis.PanicsWithValue(tc.Panic, func() {\n\t\t\t\t\tChain(tc.In)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tchain := Chain(tc.In)\n\t\t\tcollection := chain.(*chainBuilder).collection\n\n\t\t\tis.Equal(collection, tc.In)\n\t\t})\n\t}\n}\n\nfunc TestLazyChain(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn    interface{}\n\t\tPanic string\n\t}{\n\t\t// Check with array types\n\t\t{In: []int{0, 1, 2}},\n\t\t{In: []string{\"aaa\", \"bbb\", \"ccc\"}},\n\t\t{In: []interface{}{0, false, \"___\"}},\n\n\t\t// Check with map types\n\t\t{In: map[int]string{0: \"aaa\", 1: \"bbb\", 2: \"ccc\"}},\n\t\t{In: map[string]string{\"0\": \"aaa\", \"1\": \"bbb\", \"2\": \"ccc\"}},\n\t\t{In: map[int]interface{}{0: 0, 1: false, 2: \"___\"}},\n\n\t\t// Check with invalid types\n\t\t{false, \"Type bool is not supported by LazyChain\"},\n\t\t{0, \"Type int is not supported by LazyChain\"},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tif tc.Panic != \"\" {\n\t\t\t\tis.PanicsWithValue(tc.Panic, func() {\n\t\t\t\t\tLazyChain(tc.In)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tchain := LazyChain(tc.In)\n\t\t\tcollection := chain.(*lazyBuilder).exec()\n\n\t\t\tis.Equal(collection, tc.In)\n\t\t})\n\t}\n}\n\nfunc TestLazyChainWith(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn    func() interface{}\n\t\tPanic string\n\t}{\n\t\t// Check with array types\n\t\t{In: func() interface{} { return []int{0, 1, 2} }},\n\t\t{In: func() interface{} { return []string{\"aaa\", \"bbb\", \"ccc\"} }},\n\t\t{In: func() interface{} { return []interface{}{0, false, \"___\"} }},\n\n\t\t// Check with map types\n\t\t{In: func() interface{} { return map[int]string{0: \"aaa\", 1: \"bbb\", 2: \"ccc\"} }},\n\t\t{In: func() interface{} { return map[string]string{\"0\": \"aaa\", \"1\": \"bbb\", \"2\": \"ccc\"} }},\n\t\t{In: func() interface{} { return map[int]interface{}{0: 0, 1: false, 2: \"___\"} }},\n\n\t\t// Check with invalid types\n\t\t{\n\t\t\tIn:    func() interface{} { return false },\n\t\t\tPanic: \"Type bool is not supported by LazyChainWith generator\",\n\t\t},\n\t\t{\n\t\t\tIn:    func() interface{} { return 0 },\n\t\t\tPanic: \"Type int is not supported by LazyChainWith generator\",\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tif tc.Panic != \"\" {\n\t\t\t\tis.PanicsWithValue(tc.Panic, func() {\n\t\t\t\t\tLazyChainWith(tc.In).(*lazyBuilder).exec()\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tchain := LazyChainWith(tc.In)\n\t\t\tcollection := chain.(*lazyBuilder).exec()\n\n\t\t\tis.Equal(collection, tc.In())\n\t\t})\n\t}\n}\n\nfunc ExampleChain() {\n\tv := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tchain := Chain(v)\n\tlazy := LazyChain(v)\n\n\t// Without builder\n\ta := Filter(v, func(x int) bool { return x%2 == 0 })\n\tb := Map(a, func(x int) int { return x * 2 })\n\tc := Reverse(a)\n\tfmt.Printf(\"funk.Contains(b, 2): %v\\n\", Contains(b, 2)) // false\n\tfmt.Printf(\"funk.Contains(b, 4): %v\\n\", Contains(b, 4)) // true\n\tfmt.Printf(\"funk.Sum(b): %v\\n\", Sum(b))                 // 40\n\tfmt.Printf(\"funk.Head(b): %v\\n\", Head(b))               // 4\n\tfmt.Printf(\"funk.Head(c): %v\\n\\n\", Head(c))             // 8\n\n\t// With simple chain builder\n\tca := chain.Filter(func(x int) bool { return x%2 == 0 })\n\tcb := ca.Map(func(x int) int { return x * 2 })\n\tcc := ca.Reverse()\n\tfmt.Printf(\"chainB.Contains(2): %v\\n\", cb.Contains(2)) // false\n\tfmt.Printf(\"chainB.Contains(4): %v\\n\", cb.Contains(4)) // true\n\tfmt.Printf(\"chainB.Sum(): %v\\n\", cb.Sum())             // 40\n\tfmt.Printf(\"chainB.Head(): %v\\n\", cb.Head())           // 4\n\tfmt.Printf(\"chainC.Head(): %v\\n\\n\", cc.Head())         // 8\n\n\t// With lazy chain builder\n\tla := lazy.Filter(func(x int) bool { return x%2 == 0 })\n\tlb := la.Map(func(x int) int { return x * 2 })\n\tlc := la.Reverse()\n\tfmt.Printf(\"lazyChainB.Contains(2): %v\\n\", lb.Contains(2)) // false\n\tfmt.Printf(\"lazyChainB.Contains(4): %v\\n\", lb.Contains(4)) // true\n\tfmt.Printf(\"lazyChainB.Sum(): %v\\n\", lb.Sum())             // 40\n\tfmt.Printf(\"lazyChainB.Head(): %v\\n\", lb.Head())           // 4\n\tfmt.Printf(\"lazyChainC.Head(): %v\\n\", lc.Head())           // 8\n}\n\ntype updatingStruct struct {\n\tx []int\n}\n\nfunc (us *updatingStruct) Values() interface{} {\n\treturn us.x\n}\n\nfunc ExampleLazyChain() {\n\tus := updatingStruct{}\n\tchain := Chain(us.x).\n\t\tMap(func(x int) float64 { return float64(x) * 2.5 })\n\tlazy := LazyChain(us.x).\n\t\tMap(func(x int) float64 { return float64(x) * 2.5 })\n\tlazyWith := LazyChainWith(us.Values).\n\t\tMap(func(x int) float64 { return float64(x) * 2.5 })\n\n\tfmt.Printf(\"chain.Sum(): %v\\n\", chain.Sum())         // 0\n\tfmt.Printf(\"lazy.Sum(): %v\\n\", lazy.Sum())           // 0\n\tfmt.Printf(\"lazyWith.Sum(): %v\\n\\n\", lazyWith.Sum()) // 0\n\n\tus.x = append(us.x, 2)\n\tfmt.Printf(\"chain.Sum(): %v\\n\", chain.Sum())         // 0\n\tfmt.Printf(\"lazy.Sum(): %v\\n\", lazy.Sum())           // 0\n\tfmt.Printf(\"lazyWith.Sum(): %v\\n\\n\", lazyWith.Sum()) // 5\n\n\tus.x = append(us.x, 10)\n\tfmt.Printf(\"chain.Sum(): %v\\n\", chain.Sum())         // 0\n\tfmt.Printf(\"lazy.Sum(): %v\\n\", lazy.Sum())           // 0\n\tfmt.Printf(\"lazyWith.Sum(): %v\\n\\n\", lazyWith.Sum()) // 30\n}\n"
        },
        {
          "name": "chain_builder.go",
          "type": "blob",
          "size": 3.8662109375,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\ntype chainBuilder struct {\n\tcollection interface{}\n}\n\nfunc (b *chainBuilder) Chunk(size int) Builder {\n\treturn &chainBuilder{Chunk(b.collection, size)}\n}\nfunc (b *chainBuilder) Compact() Builder {\n\treturn &chainBuilder{Compact(b.collection)}\n}\nfunc (b *chainBuilder) Drop(n int) Builder {\n\treturn &chainBuilder{Drop(b.collection, n)}\n}\nfunc (b *chainBuilder) Filter(predicate interface{}) Builder {\n\treturn &chainBuilder{Filter(b.collection, predicate)}\n}\nfunc (b *chainBuilder) Flatten() Builder {\n\treturn &chainBuilder{Flatten(b.collection)}\n}\nfunc (b *chainBuilder) FlattenDeep() Builder {\n\treturn &chainBuilder{FlattenDeep(b.collection)}\n}\nfunc (b *chainBuilder) Initial() Builder {\n\treturn &chainBuilder{Initial(b.collection)}\n}\nfunc (b *chainBuilder) Intersect(y interface{}) Builder {\n\treturn &chainBuilder{Intersect(b.collection, y)}\n}\nfunc (b *chainBuilder) Join(rarr interface{}, fnc JoinFnc) Builder {\n\treturn &chainBuilder{Join(b.collection, rarr, fnc)}\n}\nfunc (b *chainBuilder) Map(mapFunc interface{}) Builder {\n\treturn &chainBuilder{Map(b.collection, mapFunc)}\n}\nfunc (b *chainBuilder) FlatMap(mapFunc interface{}) Builder {\n\treturn &chainBuilder{FlatMap(b.collection, mapFunc)}\n}\nfunc (b *chainBuilder) Reverse() Builder {\n\treturn &chainBuilder{Reverse(b.collection)}\n}\nfunc (b *chainBuilder) Shuffle() Builder {\n\treturn &chainBuilder{Shuffle(b.collection)}\n}\nfunc (b *chainBuilder) Tail() Builder {\n\treturn &chainBuilder{Tail(b.collection)}\n}\nfunc (b *chainBuilder) Uniq() Builder {\n\treturn &chainBuilder{Uniq(b.collection)}\n}\nfunc (b *chainBuilder) Without(values ...interface{}) Builder {\n\treturn &chainBuilder{Without(b.collection, values...)}\n}\n\nfunc (b *chainBuilder) All() bool {\n\tv := reflect.ValueOf(b.collection)\n\tt := v.Type()\n\n\tif t.Kind() != reflect.Array && t.Kind() != reflect.Slice {\n\t\tpanic(fmt.Sprintf(\"Type %s is not supported by Chain.All\", t.String()))\n\t}\n\n\tc := make([]interface{}, v.Len())\n\tfor i := 0; i < v.Len(); i++ {\n\t\tc[i] = v.Index(i).Interface()\n\t}\n\treturn All(c...)\n}\nfunc (b *chainBuilder) Any() bool {\n\tv := reflect.ValueOf(b.collection)\n\tt := v.Type()\n\n\tif t.Kind() != reflect.Array && t.Kind() != reflect.Slice {\n\t\tpanic(fmt.Sprintf(\"Type %s is not supported by Chain.Any\", t.String()))\n\t}\n\n\tc := make([]interface{}, v.Len())\n\tfor i := 0; i < v.Len(); i++ {\n\t\tc[i] = v.Index(i).Interface()\n\t}\n\treturn Any(c...)\n}\nfunc (b *chainBuilder) Contains(elem interface{}) bool {\n\treturn Contains(b.collection, elem)\n}\nfunc (b *chainBuilder) Every(elements ...interface{}) bool {\n\treturn Every(b.collection, elements...)\n}\nfunc (b *chainBuilder) Find(predicate interface{}) interface{} {\n\treturn Find(b.collection, predicate)\n}\nfunc (b *chainBuilder) ForEach(predicate interface{}) {\n\tForEach(b.collection, predicate)\n}\nfunc (b *chainBuilder) ForEachRight(predicate interface{}) {\n\tForEachRight(b.collection, predicate)\n}\nfunc (b *chainBuilder) Head() interface{} {\n\treturn Head(b.collection)\n}\nfunc (b *chainBuilder) Keys() interface{} {\n\treturn Keys(b.collection)\n}\nfunc (b *chainBuilder) IndexOf(elem interface{}) int {\n\treturn IndexOf(b.collection, elem)\n}\nfunc (b *chainBuilder) IsEmpty() bool {\n\treturn IsEmpty(b.collection)\n}\nfunc (b *chainBuilder) Last() interface{} {\n\treturn Last(b.collection)\n}\nfunc (b *chainBuilder) LastIndexOf(elem interface{}) int {\n\treturn LastIndexOf(b.collection, elem)\n}\nfunc (b *chainBuilder) NotEmpty() bool {\n\treturn NotEmpty(b.collection)\n}\nfunc (b *chainBuilder) Product() float64 {\n\treturn Product(b.collection)\n}\nfunc (b *chainBuilder) Reduce(reduceFunc, acc interface{}) interface{} {\n\treturn Reduce(b.collection, reduceFunc, acc)\n}\nfunc (b *chainBuilder) Sum() float64 {\n\treturn Sum(b.collection)\n}\nfunc (b *chainBuilder) Type() reflect.Type {\n\treturn reflect.TypeOf(b.collection)\n}\nfunc (b *chainBuilder) Value() interface{} {\n\treturn b.collection\n}\nfunc (b *chainBuilder) Values() interface{} {\n\treturn Values(b.collection)\n}\n"
        },
        {
          "name": "chain_builder_test.go",
          "type": "blob",
          "size": 23.2138671875,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestChainChunk(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn   interface{}\n\t\tSize int\n\t}{\n\t\t{In: []int{0, 1, 2, 3, 4}, Size: 2},\n\t\t{In: []int{}, Size: 2},\n\t\t{In: []int{1}, Size: 2},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Chunk(tc.In, tc.Size)\n\t\t\tactual := Chain(tc.In).Chunk(tc.Size).Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainCompact(t *testing.T) {\n\tvar emptyFunc func() bool\n\temptyFuncPtr := &emptyFunc\n\n\tnonEmptyFunc := func() bool { return true }\n\tnonEmptyFuncPtr := &nonEmptyFunc\n\n\tnonEmptyMap := map[int]int{1: 2}\n\tnonEmptyMapPtr := &nonEmptyMap\n\n\tvar emptyMap map[int]int\n\temptyMapPtr := &emptyMap\n\n\tvar emptyChan chan bool\n\tnonEmptyChan := make(chan bool, 1)\n\tnonEmptyChan <- true\n\n\temptyChanPtr := &emptyChan\n\tnonEmptyChanPtr := &nonEmptyChan\n\n\tvar emptyString string\n\temptyStringPtr := &emptyString\n\n\tnonEmptyString := \"42\"\n\tnonEmptyStringPtr := &nonEmptyString\n\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []interface{}{42, nil, (*int)(nil)}},\n\t\t{In: []interface{}{42, emptyFuncPtr, emptyFunc, nonEmptyFuncPtr}},\n\t\t{In: []interface{}{42, [2]int{}, map[int]int{}, []string{}, nonEmptyMapPtr, emptyMap, emptyMapPtr, nonEmptyMap, nonEmptyChan, emptyChan, emptyChanPtr, nonEmptyChanPtr}},\n\t\t{In: []interface{}{true, 0, float64(0), \"\", \"42\", emptyStringPtr, nonEmptyStringPtr, false}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Compact(tc.In)\n\t\t\tactual := Chain(tc.In).Compact().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainDrop(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t\tN  int\n\t}{\n\t\t{In: []int{0, 1, 1, 2, 3, 0, 0, 12}, N: 3},\n\t\t// Bug: Issues from go-funk (n parameter can be greater than len(in))\n\t\t// {In: []int{0, 1}, N: 3},\n\t\t// {In: []int{}, N: 3},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Drop(tc.In, tc.N)\n\t\t\tactual := Chain(tc.In).Drop(tc.N).Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainFilter(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn        interface{}\n\t\tPredicate interface{}\n\t}{\n\t\t{\n\t\t\tIn:        []int{1, 2, 3, 4},\n\t\t\tPredicate: func(x int) bool { return x%2 == 0 },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Filter(tc.In, tc.Predicate)\n\t\t\tactual := Chain(tc.In).Filter(tc.Predicate).Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\nfunc TestChainFilter_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tchain := Chain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\n\tfiltered := chain.Filter(func(x *foo) bool {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\treturn x.bar == \"foo\"\n\t})\n\tis.Equal([]*foo{}, filtered.Value())\n\n\t// Side effect: in and chain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestChainFlatten(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: [][]int{{1, 2}, {3, 4}},\n\t\t},\n\t\t{\n\t\t\tIn: [][][]int{{{1, 2}, {3, 4}}, {{5, 6}}},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Flatten(tc.In)\n\t\t\tactual := Chain(tc.In).Flatten().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainFlattenDeep(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: [][]int{{1, 2}, {3, 4}},\n\t\t},\n\t\t{\n\t\t\tIn: [][][]int{{{1, 2}, {3, 4}}, {{5, 6}}},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := FlattenDeep(tc.In)\n\t\t\tactual := Chain(tc.In).FlattenDeep().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainInitial(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{},\n\t\t},\n\t\t{\n\t\t\tIn: []int{0},\n\t\t},\n\t\t{\n\t\t\tIn: []int{0, 1, 2, 3},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Initial(tc.In)\n\t\t\tactual := Chain(tc.In).Initial().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainIntersect(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn  interface{}\n\t\tSec interface{}\n\t}{\n\t\t{\n\t\t\tIn:  []int{1, 2, 3, 4},\n\t\t\tSec: []int{2, 4, 6},\n\t\t},\n\t\t{\n\t\t\tIn:  []string{\"foo\", \"bar\", \"hello\", \"bar\"},\n\t\t\tSec: []string{\"foo\", \"bar\"},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Intersect(tc.In, tc.Sec)\n\t\t\tactual := Chain(tc.In).Intersect(tc.Sec).Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainMap(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn     interface{}\n\t\tMapFnc interface{}\n\t}{\n\t\t{\n\t\t\tIn:     []int{1, 2, 3, 4},\n\t\t\tMapFnc: func(x int) string { return \"Hello\" },\n\t\t},\n\t\t{\n\t\t\tIn:     []int{1, 2, 3, 4},\n\t\t\tMapFnc: func(x int) (int, int) { return x, x },\n\t\t},\n\t\t{\n\t\t\tIn:     map[int]string{1: \"Florent\", 2: \"Gilles\"},\n\t\t\tMapFnc: func(k int, v string) int { return k },\n\t\t},\n\t\t{\n\t\t\tIn:     map[int]string{1: \"Florent\", 2: \"Gilles\"},\n\t\t\tMapFnc: func(k int, v string) (string, string) { return fmt.Sprintf(\"%d\", k), v },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Map(tc.In, tc.MapFnc)\n\t\t\tactual := Chain(tc.In).Map(tc.MapFnc).Value()\n\n\t\t\tif reflect.TypeOf(expected).Kind() == reflect.Map {\n\t\t\t\tis.Equal(expected, actual)\n\t\t\t} else {\n\t\t\t\tis.ElementsMatch(expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestChainFlatMap(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn         interface{}\n\t\tFlatMapFnc interface{}\n\t}{\n\t\t{\n\t\t\tIn:         [][]int{{1}, {2}, {3}, {4}},\n\t\t\tFlatMapFnc: func(x []int) []int { return x },\n\t\t},\n\t\t{\n\t\t\tIn:         map[string][]int{\"Florent\": {1}, \"Gilles\": {2}},\n\t\t\tFlatMapFnc: func(k string, v []int) []int { return v },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := FlatMap(tc.In, tc.FlatMapFnc)\n\t\t\tactual := Chain(tc.In).FlatMap(tc.FlatMapFnc).Value()\n\n\t\t\tis.ElementsMatch(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainMap_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tchain := Chain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\n\tmapped := chain.Map(func(x *foo) (string, bool) {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\treturn x.bar, x.bar == \"foo\"\n\t})\n\tis.Equal(map[string]bool{\"__foo__\": false, \"__bar__\": false}, mapped.Value())\n\n\t// Side effect: in and chain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestChainReverse(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tIn: \"abcdefg\",\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Reverse(tc.In)\n\t\t\tactual := Chain(tc.In).Reverse().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainShuffle(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{0, 1, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Shuffle(tc.In)\n\t\t\tactual := Chain(tc.In).Shuffle().Value()\n\n\t\t\tis.NotEqual(expected, actual)\n\t\t\tis.ElementsMatch(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainTail(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{},\n\t\t},\n\t\t{\n\t\t\tIn: []int{0},\n\t\t},\n\t\t{\n\t\t\tIn: []int{0, 1, 2, 3},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Tail(tc.In)\n\t\t\tactual := Chain(tc.In).Tail().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainUniq(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{0, 1, 1, 2, 3, 0, 0, 12},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Uniq(tc.In)\n\t\t\tactual := Chain(tc.In).Uniq().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainAll(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn []interface{}\n\t}{\n\t\t{In: []interface{}{\"foo\", \"bar\"}},\n\t\t{In: []interface{}{\"foo\", \"\"}},\n\t\t{In: []interface{}{\"\", \"\"}},\n\t\t{In: []interface{}{}},\n\t\t{In: []interface{}{true, \"foo\", 6}},\n\t\t{In: []interface{}{true, \"\", 6}},\n\t\t{In: []interface{}{true, \"foo\", 0}},\n\t\t{In: []interface{}{false, \"foo\", 6}},\n\t\t{In: []interface{}{false, \"\", 0}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := All(tc.In...)\n\t\t\tactual := Chain(tc.In).All()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainAny(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn []interface{}\n\t}{\n\t\t{In: []interface{}{\"foo\", \"bar\"}},\n\t\t{In: []interface{}{\"foo\", \"\"}},\n\t\t{In: []interface{}{\"\", \"\"}},\n\t\t{In: []interface{}{}},\n\t\t{In: []interface{}{true, \"foo\", 6}},\n\t\t{In: []interface{}{true, \"\", 6}},\n\t\t{In: []interface{}{true, \"foo\", 0}},\n\t\t{In: []interface{}{false, \"foo\", 6}},\n\t\t{In: []interface{}{false, \"\", 0}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Any(tc.In...)\n\t\t\tactual := Chain(tc.In).Any()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainContains(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn       interface{}\n\t\tContains interface{}\n\t}{\n\t\t{\n\t\t\tIn:       []string{\"foo\", \"bar\"},\n\t\t\tContains: \"bar\",\n\t\t},\n\t\t{\n\t\t\tIn: []string{\"foo\", \"bar\"},\n\t\t\tContains: func(value string) bool {\n\t\t\t\treturn value == \"bar\"\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: f,\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: nil,\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: b,\n\t\t},\n\t\t{\n\t\t\tIn:       \"florent\",\n\t\t\tContains: \"rent\",\n\t\t},\n\t\t{\n\t\t\tIn:       \"florent\",\n\t\t\tContains: \"gilles\",\n\t\t},\n\t\t{\n\t\t\tIn:       map[int]*Foo{1: f, 3: c},\n\t\t\tContains: 1,\n\t\t},\n\t\t{\n\t\t\tIn:       map[int]*Foo{1: f, 3: c},\n\t\t\tContains: 2,\n\t\t},\n\t\t{\n\t\t\tIn: map[int]*Foo{1: f, 3: c},\n\t\t\tContains: func(key int, foo *Foo) bool {\n\t\t\t\treturn key == 3 && foo.FirstName == \"Harald\"\n\t\t\t},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Contains(tc.In, tc.Contains)\n\t\t\tactual := Chain(tc.In).Contains(tc.Contains)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainEvery(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn       interface{}\n\t\tContains []interface{}\n\t}{\n\t\t{\n\t\t\tIn:       []string{\"foo\", \"bar\", \"baz\"},\n\t\t\tContains: []interface{}{\"bar\", \"foo\"},\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: []interface{}{f, c},\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: []interface{}{nil},\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: []interface{}{f, b},\n\t\t},\n\t\t{\n\t\t\tIn:       \"florent\",\n\t\t\tContains: []interface{}{\"rent\", \"flo\"},\n\t\t},\n\t\t{\n\t\t\tIn:       \"florent\",\n\t\t\tContains: []interface{}{\"rent\", \"gilles\"},\n\t\t},\n\t\t{\n\t\t\tIn:       map[int]*Foo{1: f, 3: c},\n\t\t\tContains: []interface{}{1, 3},\n\t\t},\n\t\t{\n\t\t\tIn:       map[int]*Foo{1: f, 3: c},\n\t\t\tContains: []interface{}{2, 3},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Every(tc.In, tc.Contains...)\n\t\t\tactual := Chain(tc.In).Every(tc.Contains...)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainFind(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn        interface{}\n\t\tPredicate interface{}\n\t}{\n\t\t{\n\t\t\tIn:        []int{1, 2, 3, 4},\n\t\t\tPredicate: func(x int) bool { return x%2 == 0 },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Find(tc.In, tc.Predicate)\n\t\t\tactual := Chain(tc.In).Find(tc.Predicate)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainFind_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tchain := Chain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\n\tresult := chain.Find(func(x *foo) bool {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\treturn x.bar == \"foo\"\n\t})\n\tis.Nil(result)\n\n\t// Side effect: in and chain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestChainForEach(t *testing.T) {\n\tvar expectedAcc, actualAcc []interface{}\n\n\ttestCases := []struct {\n\t\tIn            interface{}\n\t\tFunkIterator  interface{}\n\t\tChainIterator interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{1, 2, 3, 4},\n\t\t\tFunkIterator: func(x int) {\n\t\t\t\tif x%2 == 0 {\n\t\t\t\t\texpectedAcc = append(expectedAcc, x)\n\t\t\t\t}\n\t\t\t},\n\t\t\tChainIterator: func(x int) {\n\t\t\t\tif x%2 == 0 {\n\t\t\t\t\tactualAcc = append(actualAcc, x)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:            map[int]string{1: \"Florent\", 2: \"Gilles\"},\n\t\t\tFunkIterator:  func(k int, v string) { expectedAcc = append(expectedAcc, fmt.Sprintf(\"%d:%s\", k, v)) },\n\t\t\tChainIterator: func(k int, v string) { actualAcc = append(actualAcc, fmt.Sprintf(\"%d:%s\", k, v)) },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\texpectedAcc = []interface{}{}\n\t\t\tactualAcc = []interface{}{}\n\n\t\t\tForEach(tc.In, tc.FunkIterator)\n\t\t\tChain(tc.In).ForEach(tc.ChainIterator)\n\n\t\t\tis.ElementsMatch(expectedAcc, actualAcc)\n\t\t})\n\t}\n}\n\nfunc TestChainForEach_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tvar out []*foo\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tchain := Chain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\n\tchain.ForEach(func(x *foo) {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\tout = append(out, x)\n\t})\n\tis.Equal([]*foo{{\"__foo__\"}, {\"__bar__\"}}, out)\n\n\t// Side effect: in and chain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestChainForEachRight(t *testing.T) {\n\tvar expectedAcc, actualAcc []interface{}\n\n\ttestCases := []struct {\n\t\tIn            interface{}\n\t\tFunkIterator  interface{}\n\t\tChainIterator interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{1, 2, 3, 4},\n\t\t\tFunkIterator: func(x int) {\n\t\t\t\tif x%2 == 0 {\n\t\t\t\t\texpectedAcc = append(expectedAcc, x)\n\t\t\t\t}\n\t\t\t},\n\t\t\tChainIterator: func(x int) {\n\t\t\t\tif x%2 == 0 {\n\t\t\t\t\tactualAcc = append(actualAcc, x)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:            map[int]string{1: \"Florent\", 2: \"Gilles\"},\n\t\t\tFunkIterator:  func(k int, v string) { expectedAcc = append(expectedAcc, fmt.Sprintf(\"%d:%s\", k, v)) },\n\t\t\tChainIterator: func(k int, v string) { actualAcc = append(actualAcc, fmt.Sprintf(\"%d:%s\", k, v)) },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\texpectedAcc = []interface{}{}\n\t\t\tactualAcc = []interface{}{}\n\n\t\t\tForEachRight(tc.In, tc.FunkIterator)\n\t\t\tChain(tc.In).ForEachRight(tc.ChainIterator)\n\n\t\t\tis.ElementsMatch(expectedAcc, actualAcc)\n\t\t})\n\t}\n}\n\nfunc TestChainForEachRight_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tvar out []*foo\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tchain := Chain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\n\tchain.ForEachRight(func(x *foo) {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\tout = append(out, x)\n\t})\n\tis.Equal([]*foo{{\"__bar__\"}, {\"__foo__\"}}, out)\n\n\t// Side effect: in and chain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, chain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestChainHead(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{1, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Head(tc.In)\n\t\t\tactual := Chain(tc.In).Head()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainKeys(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: map[string]int{\"one\": 1, \"two\": 2}},\n\t\t{In: &map[string]int{\"one\": 1, \"two\": 2}},\n\t\t{In: map[int]complex128{5: 1 + 8i, 3: 2}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Keys(tc.In)\n\t\t\tactual := Chain(tc.In).Keys()\n\n\t\t\tis.ElementsMatch(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainIndexOf(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn   interface{}\n\t\tItem interface{}\n\t}{\n\t\t{\n\t\t\tIn:   []string{\"foo\", \"bar\"},\n\t\t\tItem: \"bar\",\n\t\t},\n\t\t{\n\t\t\tIn: []string{\"foo\", \"bar\"},\n\t\t\tItem: func(value string) bool {\n\t\t\t\treturn value == \"bar\"\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:   results,\n\t\t\tItem: f,\n\t\t},\n\t\t{\n\t\t\tIn:   results,\n\t\t\tItem: b,\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := IndexOf(tc.In, tc.Item)\n\t\t\tactual := Chain(tc.In).IndexOf(tc.Item)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainIsEmpty(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: \"\"},\n\t\t{In: [0]interface{}{}},\n\t\t{In: []interface{}(nil)},\n\t\t{In: map[interface{}]interface{}(nil)},\n\t\t{In: \"s\"},\n\t\t{In: [1]interface{}{1}},\n\t\t{In: []interface{}{}},\n\t\t{In: map[interface{}]interface{}{}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := IsEmpty(tc.In)\n\t\t\tactual := Chain(tc.In).IsEmpty()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainLast(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{1, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Last(tc.In)\n\t\t\tactual := Chain(tc.In).Last()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainLastIndexOf(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn   interface{}\n\t\tItem interface{}\n\t}{\n\t\t{\n\t\t\tIn:   []string{\"foo\", \"bar\", \"bar\"},\n\t\t\tItem: \"bar\",\n\t\t},\n\t\t{\n\t\t\tIn: []string{\"foo\", \"bar\", \"bar\"},\n\t\t\tItem: func(value string) bool {\n\t\t\t\treturn value == \"bar\"\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:   []int{1, 2, 2, 3},\n\t\t\tItem: 2,\n\t\t},\n\t\t{\n\t\t\tIn:   []int{1, 2, 2, 3},\n\t\t\tItem: 4,\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := LastIndexOf(tc.In, tc.Item)\n\t\t\tactual := Chain(tc.In).LastIndexOf(tc.Item)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainNotEmpty(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: \"\"},\n\t\t{In: [0]interface{}{}},\n\t\t{In: []interface{}(nil)},\n\t\t{In: map[interface{}]interface{}(nil)},\n\t\t{In: \"s\"},\n\t\t{In: [1]interface{}{1}},\n\t\t{In: []interface{}{}},\n\t\t{In: map[interface{}]interface{}{}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := NotEmpty(tc.In)\n\t\t\tactual := Chain(tc.In).NotEmpty()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainProduct(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []int{0, 1, 2, 3}},\n\t\t{In: &[]int{0, 1, 2, 3}},\n\t\t{In: []interface{}{1, 2, 3, 0.5}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Product(tc.In)\n\t\t\tactual := Chain(tc.In).Product()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainReduce(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn         interface{}\n\t\tReduceFunc interface{}\n\t\tAcc        interface{}\n\t}{\n\t\t{\n\t\t\tIn:         []int{1, 2, 3, 4},\n\t\t\tReduceFunc: func(acc, elem int) int { return acc + elem },\n\t\t\tAcc:        0,\n\t\t},\n\t\t{\n\t\t\tIn:         &[]int16{1, 2, 3, 4},\n\t\t\tReduceFunc: '+',\n\t\t\tAcc:        5,\n\t\t},\n\t\t{\n\t\t\tIn:         []float64{1.1, 2.2, 3.3},\n\t\t\tReduceFunc: '+',\n\t\t\tAcc:        0,\n\t\t},\n\t\t{\n\t\t\tIn:         &[]int{1, 2, 3, 5},\n\t\t\tReduceFunc: func(acc int8, elem int16) int32 { return int32(acc) * int32(elem) },\n\t\t\tAcc:        1,\n\t\t},\n\t\t{\n\t\t\tIn:         []interface{}{1, 2, 3.3, 4},\n\t\t\tReduceFunc: '*',\n\t\t\tAcc:        1,\n\t\t},\n\t\t{\n\t\t\tIn:         []string{\"1\", \"2\", \"3\", \"4\"},\n\t\t\tReduceFunc: func(acc string, elem string) string { return acc + elem },\n\t\t\tAcc:        \"\",\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Reduce(tc.In, tc.ReduceFunc, tc.Acc)\n\t\t\tactual := Chain(tc.In).Reduce(tc.ReduceFunc, tc.Acc)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainSum(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []int{0, 1, 2, 3}},\n\t\t{In: &[]int{0, 1, 2, 3}},\n\t\t{In: []interface{}{1, 2, 3, 0.5}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Sum(tc.In)\n\t\t\tactual := Chain(tc.In).Sum()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainType(t *testing.T) {\n\ttype key string\n\tvar x key\n\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []string{}},\n\t\t{In: []int{}},\n\t\t{In: []bool{}},\n\t\t{In: []interface{}{}},\n\t\t{In: &[]interface{}{}},\n\t\t{In: map[int]string{}},\n\t\t{In: map[complex128]int{}},\n\t\t{In: map[string]string{}},\n\t\t{In: map[int]interface{}{}},\n\t\t{In: map[key]interface{}{}},\n\t\t{In: &map[key]interface{}{}},\n\t\t{In: \"\"},\n\t\t{In: &x},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := Chain(tc.In).Type()\n\n\t\t\tis.Equal(reflect.TypeOf(tc.In), actual)\n\t\t})\n\t}\n}\n\nfunc TestChainValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []int{0, 1, 2, 3}},\n\t\t{In: []string{\"foo\", \"bar\"}},\n\t\t{In: &[]string{\"foo\", \"bar\"}},\n\t\t{In: map[int]string{1: \"foo\", 2: \"bar\"}},\n\t\t{In: map[string]string{\"foo\": \"foo\", \"bar\": \"bar\"}},\n\t\t{In: &map[string]string{\"foo\": \"foo\", \"bar\": \"bar\"}},\n\t\t{In: \"foo\"},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := Chain(tc.In).Value()\n\n\t\t\tis.Equal(tc.In, actual)\n\t\t})\n\t}\n}\n\nfunc TestChainValues(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: map[string]int{\"one\": 1, \"two\": 2}},\n\t\t{In: &map[string]int{\"one\": 1, \"two\": 2}},\n\t\t{In: map[int]complex128{5: 1 + 8i, 3: 2}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Values(tc.In)\n\t\t\tactual := Chain(tc.In).Values()\n\n\t\t\tis.ElementsMatch(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestComplexChaining(t *testing.T) {\n\tis := assert.New(t)\n\n\tin := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tchain := Chain(in)\n\n\t// Without builder\n\tfa := Filter(in, func(x int) bool { return x%2 == 0 })\n\tfb := Map(fa, func(x int) int { return x * 2 })\n\tfc := Reverse(fa)\n\n\t// With simple chaining\n\tca := chain.Filter(func(x int) bool { return x%2 == 0 })\n\tcb := ca.Map(func(x int) int { return x * 2 })\n\tcc := ca.Reverse()\n\n\tis.Equal(fa, ca.Value())\n\tis.Equal(fb, cb.Value())\n\tis.Equal(fc, cc.Value())\n\n\tis.Equal(Contains(fb, 2), cb.Contains(2))\n\tis.Equal(Contains(fb, 4), cb.Contains(4))\n\tis.Equal(Sum(fb), cb.Sum())\n\tis.Equal(Head(fb), cb.Head())\n\tis.Equal(Head(fc), cc.Head())\n}\n"
        },
        {
          "name": "compact.go",
          "type": "blob",
          "size": 1.0966796875,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n)\n\n// Compact creates a slice with all empty/zero values removed.\nfunc Compact(value interface{}) interface{} {\n\tarr := redirectValue(reflect.ValueOf(value))\n\n\tif arr.Kind() != reflect.Slice && arr.Kind() != reflect.Array {\n\t\tpanic(\"First parameter must be array or slice\")\n\t}\n\n\tsliceElemType := sliceElem(arr.Type())\n\tresultSliceType := reflect.SliceOf(sliceElemType)\n\tresult := reflect.MakeSlice(resultSliceType, 0, 0)\n\n\tfor i := 0; i < arr.Len(); i++ {\n\t\telemVal := arr.Index(i)\n\n\t\tif elemVal.Kind() == reflect.Interface {\n\t\t\telemVal = elemVal.Elem()\n\t\t}\n\n\t\tredirectedElemVal := redirectValue(elemVal)\n\n\t\tswitch redirectedElemVal.Kind() {\n\t\tcase reflect.Invalid:\n\t\t\tcontinue\n\t\tcase reflect.Func:\n\t\t\tif redirectedElemVal.IsNil() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase reflect.Map, reflect.Slice, reflect.Chan:\n\t\t\tif redirectedElemVal.Len() == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tdefault:\n\t\t\tdefaultValue := reflect.Zero(redirectedElemVal.Type()).Interface()\n\t\t\tif redirectedElemVal.Interface() == defaultValue {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tresult = reflect.Append(result, elemVal)\n\t}\n\n\treturn result.Interface()\n}\n"
        },
        {
          "name": "compact_test.go",
          "type": "blob",
          "size": 1.6884765625,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCompact(t *testing.T) {\n\tvar emptyFunc func() bool\n\temptyFuncPtr := &emptyFunc\n\n\tnonEmptyFunc := func() bool { return true }\n\tnonEmptyFuncPtr := &nonEmptyFunc\n\n\tnonEmptyMap := map[int]int{1: 2}\n\tnonEmptyMapPtr := &nonEmptyMap\n\n\tvar emptyMap map[int]int\n\temptyMapPtr := &emptyMap\n\n\tvar emptyChan chan bool\n\tnonEmptyChan := make(chan bool, 1)\n\tnonEmptyChan <- true\n\n\temptyChanPtr := &emptyChan\n\tnonEmptyChanPtr := &nonEmptyChan\n\n\tvar emptyString string\n\temptyStringPtr := &emptyString\n\n\tnonEmptyString := \"42\"\n\tnonEmptyStringPtr := &nonEmptyString\n\n\ttestCases := []struct {\n\t\tArr    interface{}\n\t\tResult interface{}\n\t}{\n\t\t// Check with nils\n\t\t{\n\t\t\t[]interface{}{42, nil, (*int)(nil)},\n\t\t\t[]interface{}{42},\n\t\t},\n\n\t\t// Check with functions\n\t\t{\n\t\t\t[]interface{}{42, emptyFuncPtr, emptyFunc, nonEmptyFuncPtr},\n\t\t\t[]interface{}{42, nonEmptyFuncPtr},\n\t\t},\n\n\t\t// Check with slices, maps, arrays and channels\n\t\t{\n\t\t\t[]interface{}{\n\t\t\t\t42, [2]int{}, map[int]int{}, []string{}, nonEmptyMapPtr, emptyMap,\n\t\t\t\temptyMapPtr, nonEmptyMap, nonEmptyChan, emptyChan, emptyChanPtr, nonEmptyChanPtr,\n\t\t\t},\n\t\t\t[]interface{}{42, nonEmptyMapPtr, nonEmptyMap, nonEmptyChan, nonEmptyChanPtr},\n\t\t},\n\n\t\t// Check with strings, numbers and booleans\n\t\t{\n\t\t\t[]interface{}{true, 0, float64(0), \"\", \"42\", emptyStringPtr, nonEmptyStringPtr, false},\n\t\t\t[]interface{}{true, \"42\", nonEmptyStringPtr},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\tresult := Compact(tc.Arr)\n\n\t\t\tif !is.Equal(result, tc.Result) {\n\t\t\t\tt.Errorf(\"%#v doesn't equal to %#v\", result, tc.Result)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "example_presence_test.go",
          "type": "blob",
          "size": 0.2041015625,
          "content": "package funk\n\nimport \"fmt\"\n\nfunc ExampleSome() {\n\ta := []string{\"foo\", \"bar\", \"baz\"}\n\tfmt.Println(Some(a, \"foo\", \"qux\"))\n\n\tb := \"Mark Shaun\"\n\tfmt.Println(Some(b, \"Marc\", \"Sean\"))\n\n\t// Output: true\n\t// false\n}\n"
        },
        {
          "name": "fill.go",
          "type": "blob",
          "size": 0.796875,
          "content": "package funk\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Fill fills elements of array with value\nfunc Fill(in interface{}, fillValue interface{}) (interface{}, error) {\n\tinValue := reflect.ValueOf(in)\n\tinKind := inValue.Type().Kind()\n\tif inKind != reflect.Slice && inKind != reflect.Array {\n\t\treturn nil, errors.New(\"can only fill slices and arrays\")\n\t}\n\n\tinType := reflect.TypeOf(in).Elem()\n\tvalue := reflect.ValueOf(fillValue)\n\tif inType != value.Type() {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"cannot fill '%s' with '%s'\", reflect.TypeOf(in), value.Type(),\n\t\t)\n\t}\n\n\tlength := inValue.Len()\n\tnewSlice := reflect.SliceOf(reflect.TypeOf(fillValue))\n\tin = reflect.MakeSlice(newSlice, length, length).Interface()\n\tinValue = reflect.ValueOf(in)\n\n\tfor i := 0; i < length; i++ {\n\t\tinValue.Index(i).Set(value)\n\t}\n\treturn in, nil\n}\n"
        },
        {
          "name": "fill_test.go",
          "type": "blob",
          "size": 1.0263671875,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestFillMismatchedTypes(t *testing.T) {\n\t_, err := Fill([]string{\"a\", \"b\"}, 1)\n\tassert.EqualError(t, err, \"cannot fill '[]string' with 'int'\")\n}\n\nfunc TestFillUnfillableTypes(t *testing.T) {\n\tvar stringVariable string\n\tvar uint32Variable uint32\n\tvar boolVariable bool\n\n\ttypes := [](interface{}){\n\t\tstringVariable,\n\t\tuint32Variable,\n\t\tboolVariable,\n\t}\n\n\tfor _, unfillable := range types {\n\t\t_, err := Fill(unfillable, 1)\n\t\tassert.EqualError(t, err, \"can only fill slices and arrays\")\n\t}\n}\n\nfunc TestFillSlice(t *testing.T) {\n\tinput := []int{1, 2, 3}\n\tresult, err := Fill(input, 1)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int{1, 1, 1}, result)\n\n\t// Assert that input does not change\n\tassert.Equal(t, []int{1, 2, 3}, input)\n}\n\nfunc TestFillArray(t *testing.T) {\n\tinput := [...]int{1, 2, 3}\n\tresult, err := Fill(input, 2)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int{2, 2, 2}, result)\n\n\t// Assert that input does not change\n\tassert.Equal(t, [...]int{1, 2, 3}, input)\n}\n"
        },
        {
          "name": "funk_test.go",
          "type": "blob",
          "size": 2.068359375,
          "content": "package funk\n\nimport \"database/sql\"\n\ntype Model interface {\n\tTableName() string\n}\n\n// Bar is\ntype Bar struct {\n\tName string `tag_name:\"BarName\"`\n\tBar  *Bar\n\tBars []*Bar\n}\n\nfunc (b Bar) TableName() string {\n\treturn \"bar\"\n}\n\n// Foo is\ntype Foo struct {\n\tID         int\n\tFirstName  string `tag_name:\"tag 1\"`\n\tLastName   string `tag_name:\"tag 2\"`\n\tAge        int    `tag_name:\"tag 3\"`\n\tBar        *Bar   `tag_name:\"tag 4\"`\n\tBars       []*Bar\n\tEmptyValue sql.NullInt64\n\n\tBarInterface     interface{}\n\tBarPointer       interface{}\n\tGeneralInterface interface{}\n\n\tZeroBoolValue   bool\n\tZeroIntValue    int\n\tZeroIntPtrValue *int\n}\n\nfunc (f Foo) TableName() string {\n\treturn \"foo\"\n}\n\nvar bar = &Bar{\n\tName: \"Test\",\n\tBars: []*Bar{\n\t\t{\n\t\t\tName: \"Level1-1\",\n\t\t\tBar: &Bar{\n\t\t\t\tName: \"Level2-1\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"Level1-2\",\n\t\t\tBar: &Bar{\n\t\t\t\tName: \"Level2-2\",\n\t\t\t},\n\t\t},\n\t},\n}\n\nvar foo = &Foo{\n\tID:        1,\n\tFirstName: \"Dark\",\n\tLastName:  \"Vador\",\n\tAge:       30,\n\tBar:       bar,\n\tEmptyValue: sql.NullInt64{\n\t\tValid: true,\n\t\tInt64: 10,\n\t},\n\tBars: []*Bar{\n\t\tbar,\n\t\tbar,\n\t},\n\tBarInterface:    bar,\n\tBarPointer:      &bar,\n\tZeroBoolValue:   false,\n\tZeroIntValue:    0,\n\tZeroIntPtrValue: nil,\n}\n\nvar foo2 = &Foo{\n\tID:        1,\n\tFirstName: \"Dark\",\n\tLastName:  \"Vador\",\n\tAge:       30,\n}\n\nvar m1 = map[string]interface{}{\n\t\"id\":        1,\n\t\"firstname\": \"dark\",\n\t\"lastname\":  \"vador\",\n\t\"age\":       30,\n\t\"bar\": map[string]interface{}{\n\t\t\"name\": \"test\",\n\t\t\"bars\": []map[string]interface{}{\n\t\t\t{\n\t\t\t\t\"name\": \"level1-1\",\n\t\t\t\t\"bar\": map[string]interface{}{\n\t\t\t\t\t\"name\": \"level2-1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"level1-2\",\n\t\t\t\t\"bar\": map[string]interface{}{\n\t\t\t\t\t\"name\": \"level2-2\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n}\n\nvar m2 = map[string]interface{}{\n\t\"id\":        1,\n\t\"firstname\": \"dark\",\n\t\"lastname\":  \"vador\",\n\t\"age\":       30,\n}\n\ntype FooUnexported struct {\n\tunexported bool\n}\n\nvar fooUnexported = &FooUnexported{\n\tunexported: true,\n}\n\ntype EmbeddedStruct struct {\n\tEmbeddedField *string\n}\n\ntype RootStructPointer struct {\n\t*EmbeddedStruct\n\n\tRootField *string\n}\n\ntype RootStructNotPointer struct {\n\tEmbeddedStruct\n\n\tRootField *string\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0830078125,
          "content": "module github.com/thoas/go-funk\n\ngo 1.13\n\nrequire github.com/stretchr/testify v1.4.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.9453125,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 6.3564453125,
          "content": "package funk\n\nimport (\n\t\"bytes\"\n\t\"math/rand\"\n\t\"reflect\"\n)\n\nvar numericZeros = []interface{}{\n\tint(0),\n\tint8(0),\n\tint16(0),\n\tint32(0),\n\tint64(0),\n\tuint(0),\n\tuint8(0),\n\tuint16(0),\n\tuint32(0),\n\tuint64(0),\n\tfloat32(0),\n\tfloat64(0),\n}\n\n// ToFloat64 converts any numeric value to float64.\nfunc ToFloat64(x interface{}) (float64, bool) {\n\tvar xf float64\n\txok := true\n\n\tswitch xn := x.(type) {\n\tcase uint8:\n\t\txf = float64(xn)\n\tcase uint16:\n\t\txf = float64(xn)\n\tcase uint32:\n\t\txf = float64(xn)\n\tcase uint64:\n\t\txf = float64(xn)\n\tcase int:\n\t\txf = float64(xn)\n\tcase int8:\n\t\txf = float64(xn)\n\tcase int16:\n\t\txf = float64(xn)\n\tcase int32:\n\t\txf = float64(xn)\n\tcase int64:\n\t\txf = float64(xn)\n\tcase float32:\n\t\txf = float64(xn)\n\tcase float64:\n\t\txf = float64(xn)\n\tdefault:\n\t\txok = false\n\t}\n\n\treturn xf, xok\n}\n\n// PtrOf makes a copy of the given interface and returns a pointer.\nfunc PtrOf(itf interface{}) interface{} {\n\tt := reflect.TypeOf(itf)\n\n\tcp := reflect.New(t)\n\tcp.Elem().Set(reflect.ValueOf(itf))\n\n\t// Avoid double pointers if itf is a pointer\n\tif t.Kind() == reflect.Ptr {\n\t\treturn cp.Elem().Interface()\n\t}\n\n\treturn cp.Interface()\n}\n\n// IsFunction returns if the argument is a function.\nfunc IsFunction(in interface{}, num ...int) bool {\n\tfuncType := reflect.TypeOf(in)\n\n\tresult := funcType != nil && funcType.Kind() == reflect.Func\n\n\tif len(num) >= 1 {\n\t\tresult = result && funcType.NumIn() == num[0]\n\t}\n\n\tif len(num) == 2 {\n\t\tresult = result && funcType.NumOut() == num[1]\n\t}\n\n\treturn result\n}\n\n// IsPredicate returns if the argument is a predicate function.\nfunc IsPredicate(in interface{}, inTypes ...reflect.Type) bool {\n\tif len(inTypes) == 0 {\n\t\tinTypes = append(inTypes, nil)\n\t}\n\n\tfuncType := reflect.TypeOf(in)\n\n\tresult := funcType != nil && funcType.Kind() == reflect.Func\n\n\tresult = result && funcType.NumOut() == 1 && funcType.Out(0).Kind() == reflect.Bool\n\tresult = result && funcType.NumIn() == len(inTypes)\n\n\tfor i := 0; result && i < len(inTypes); i++ {\n\t\tinType := inTypes[i]\n\t\tresult = inType == nil || inType.ConvertibleTo(funcType.In(i))\n\t}\n\n\treturn result\n}\n\n// IsEqual returns if the two objects are equal\nfunc IsEqual(expected interface{}, actual interface{}) bool {\n\tif expected == nil || actual == nil {\n\t\treturn expected == actual\n\t}\n\n\tif exp, ok := expected.([]byte); ok {\n\t\tact, ok := actual.([]byte)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tif exp == nil || act == nil {\n\t\t\treturn true\n\t\t}\n\n\t\treturn bytes.Equal(exp, act)\n\t}\n\n\treturn reflect.DeepEqual(expected, actual)\n\n}\n\n// IsType returns if the two objects are in the same type\nfunc IsType(expected interface{}, actual interface{}) bool {\n\treturn IsEqual(reflect.TypeOf(expected), reflect.TypeOf(actual))\n}\n\n// Equal returns if the two objects are equal\nfunc Equal(expected interface{}, actual interface{}) bool {\n\treturn IsEqual(expected, actual)\n}\n\n// NotEqual returns if the two objects are not equal\nfunc NotEqual(expected interface{}, actual interface{}) bool {\n\treturn !IsEqual(expected, actual)\n}\n\n// IsIteratee returns if the argument is an iteratee.\nfunc IsIteratee(in interface{}) bool {\n\tif in == nil {\n\t\treturn false\n\t}\n\tarrType := reflect.TypeOf(in)\n\n\tkind := arrType.Kind()\n\n\treturn kind == reflect.Array || kind == reflect.Slice || kind == reflect.Map\n}\n\n// IsCollection returns if the argument is a collection.\nfunc IsCollection(in interface{}) bool {\n\tarrType := reflect.TypeOf(in)\n\n\tkind := arrType.Kind()\n\n\treturn kind == reflect.Array || kind == reflect.Slice\n}\n\n// SliceOf returns a slice which contains the element.\nfunc SliceOf(in interface{}) interface{} {\n\tvalue := reflect.ValueOf(in)\n\n\tsliceType := reflect.SliceOf(reflect.TypeOf(in))\n\tslice := reflect.New(sliceType)\n\tsliceValue := reflect.MakeSlice(sliceType, 0, 0)\n\tsliceValue = reflect.Append(sliceValue, value)\n\tslice.Elem().Set(sliceValue)\n\n\treturn slice.Elem().Interface()\n}\n\n// Any returns true if any element of the iterable is not empty. If the iterable is empty, return False.\nfunc Any(objs ...interface{}) bool {\n\tif len(objs) == 0 {\n\t\treturn false\n\t}\n\n\tfor _, obj := range objs {\n\t\tif !IsEmpty(obj) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// All returns true if all elements of the iterable are not empty (or if the iterable is empty)\nfunc All(objs ...interface{}) bool {\n\tif len(objs) == 0 {\n\t\treturn true\n\t}\n\n\tfor _, obj := range objs {\n\t\tif IsEmpty(obj) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// IsEmpty returns if the object is considered as empty or not.\nfunc IsEmpty(obj interface{}) bool {\n\tif obj == nil || obj == \"\" || obj == false {\n\t\treturn true\n\t}\n\n\tfor _, v := range numericZeros {\n\t\tif obj == v {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tobjValue := reflect.ValueOf(obj)\n\n\tswitch objValue.Kind() {\n\tcase reflect.Map:\n\t\tfallthrough\n\tcase reflect.Slice, reflect.Chan:\n\t\treturn objValue.Len() == 0\n\tcase reflect.Struct:\n\t\treturn reflect.DeepEqual(obj, ZeroOf(obj))\n\tcase reflect.Ptr:\n\t\tif objValue.IsNil() {\n\t\t\treturn true\n\t\t}\n\n\t\tobj = redirectValue(objValue).Interface()\n\n\t\treturn reflect.DeepEqual(obj, ZeroOf(obj))\n\t}\n\n\treturn false\n}\n\n// IsZero returns if the object is considered as zero value\nfunc IsZero(obj interface{}) bool {\n\tif obj == nil || obj == \"\" || obj == false {\n\t\treturn true\n\t}\n\n\tfor _, v := range numericZeros {\n\t\tif obj == v {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn reflect.DeepEqual(obj, ZeroOf(obj))\n}\n\n// NotEmpty returns if the object is considered as non-empty or not.\nfunc NotEmpty(obj interface{}) bool {\n\treturn !IsEmpty(obj)\n}\n\n// ZeroOf returns a zero value of an element.\nfunc ZeroOf(in interface{}) interface{} {\n\tif in == nil {\n\t\treturn nil\n\t}\n\n\treturn reflect.Zero(reflect.TypeOf(in)).Interface()\n}\n\n// RandomInt generates a random int, based on a min and max values\nfunc RandomInt(min, max int) int {\n\treturn min + rand.Intn(max-min)\n}\n\n// Shard will shard a string name\nfunc Shard(str string, width int, depth int, restOnly bool) []string {\n\tvar results []string\n\n\tfor i := 0; i < depth; i++ {\n\t\tresults = append(results, str[(width*i):(width*(i+1))])\n\t}\n\n\tif restOnly {\n\t\tresults = append(results, str[(width*depth):])\n\t} else {\n\t\tresults = append(results, str)\n\t}\n\n\treturn results\n}\n\nvar defaultLetters = []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n\n// RandomString returns a random string with a fixed length\nfunc RandomString(n int, allowedChars ...[]rune) string {\n\tvar letters []rune\n\n\tif len(allowedChars) == 0 {\n\t\tletters = defaultLetters\n\t} else {\n\t\tletters = allowedChars[0]\n\t}\n\n\tb := make([]rune, n)\n\tfor i := range b {\n\t\tb[i] = letters[rand.Intn(len(letters))]\n\t}\n\n\treturn string(b)\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 7.408203125,
          "content": "package funk\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar (\n\ti     interface{}\n\tzeros = []interface{}{\n\t\tfalse,\n\t\tbyte(0),\n\t\tcomplex64(0),\n\t\tcomplex128(0),\n\t\tfloat32(0),\n\t\tfloat64(0),\n\t\tint(0),\n\t\tint8(0),\n\t\tint16(0),\n\t\tint32(0),\n\t\tint64(0),\n\t\trune(0),\n\t\tuint(0),\n\t\tuint8(0),\n\t\tuint16(0),\n\t\tuint32(0),\n\t\tuint64(0),\n\t\tuintptr(0),\n\t\t\"\",\n\t\t[0]interface{}{},\n\t\t[]interface{}(nil),\n\t\tstruct{ x int }{},\n\t\t(*interface{})(nil),\n\t\t(func())(nil),\n\t\tnil,\n\t\tinterface{}(nil),\n\t\tmap[interface{}]interface{}(nil),\n\t\t(chan interface{})(nil),\n\t\t(<-chan interface{})(nil),\n\t\t(chan<- interface{})(nil),\n\t}\n\tnonZeros = []interface{}{\n\t\ttrue,\n\t\tbyte(1),\n\t\tcomplex64(1),\n\t\tcomplex128(1),\n\t\tfloat32(1),\n\t\tfloat64(1),\n\t\tint(1),\n\t\tint8(1),\n\t\tint16(1),\n\t\tint32(1),\n\t\tint64(1),\n\t\trune(1),\n\t\tuint(1),\n\t\tuint8(1),\n\t\tuint16(1),\n\t\tuint32(1),\n\t\tuint64(1),\n\t\tuintptr(1),\n\t\t\"s\",\n\t\t[1]interface{}{1},\n\t\t[]interface{}{},\n\t\tstruct{ x int }{1},\n\t\t(*interface{})(&i),\n\t\t(func())(func() {}),\n\t\tinterface{}(1),\n\t\tmap[interface{}]interface{}{},\n\t\t(chan interface{})(make(chan interface{})),\n\t\t(<-chan interface{})(make(chan interface{})),\n\t\t(chan<- interface{})(make(chan interface{})),\n\t}\n)\n\nfunc TestPtrOf(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype embedType struct {\n\t\tvalue int\n\t}\n\n\ttype anyType struct {\n\t\tvalue    int\n\t\tembed    embedType\n\t\tembedPtr *embedType\n\t}\n\n\tany := anyType{value: 1}\n\tanyPtr := &anyType{value: 1}\n\n\tresults := []interface{}{\n\t\tPtrOf(any),\n\t\tPtrOf(anyPtr),\n\t}\n\n\tfor _, r := range results {\n\t\tis.Equal(1, r.(*anyType).value)\n\t\tis.Equal(reflect.ValueOf(r).Kind(), reflect.Ptr)\n\t\tis.Equal(reflect.ValueOf(r).Type().Elem(), reflect.TypeOf(anyType{}))\n\t}\n\n\tanyWithEmbed := anyType{value: 1, embed: embedType{value: 2}}\n\tanyWithEmbedPtr := anyType{value: 1, embedPtr: &embedType{value: 2}}\n\n\tresults = []interface{}{\n\t\tPtrOf(anyWithEmbed.embed),\n\t\tPtrOf(anyWithEmbedPtr.embedPtr),\n\t}\n\n\tfor _, r := range results {\n\t\tis.Equal(2, r.(*embedType).value)\n\t\tis.Equal(reflect.ValueOf(r).Kind(), reflect.Ptr)\n\t\tis.Equal(reflect.ValueOf(r).Type().Elem(), reflect.TypeOf(embedType{}))\n\t}\n}\n\nfunc TestSliceOf(t *testing.T) {\n\tis := assert.New(t)\n\n\tf := &Foo{\n\t\tID:        1,\n\t\tFirstName: \"Dark\",\n\t\tLastName:  \"Vador\",\n\t\tAge:       30,\n\t\tBar: &Bar{\n\t\t\tName: \"Test\",\n\t\t},\n\t}\n\n\tresult := SliceOf(f)\n\n\tresultType := reflect.TypeOf(result)\n\n\tis.True(resultType.Kind() == reflect.Slice)\n\tis.True(resultType.Elem().Kind() == reflect.Ptr)\n\n\telemType := resultType.Elem().Elem()\n\n\tis.True(elemType.Kind() == reflect.Struct)\n\n\tvalue := reflect.ValueOf(result)\n\n\tis.Equal(value.Len(), 1)\n\n\t_, ok := value.Index(0).Interface().(*Foo)\n\n\tis.True(ok)\n}\n\nfunc TestRandomInt(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(RandomInt(0, 10) <= 10)\n}\n\nfunc TestShard(t *testing.T) {\n\tis := assert.New(t)\n\n\ttokey := \"e89d66bdfdd4dd26b682cc77e23a86eb\"\n\n\tis.Equal(Shard(tokey, 1, 2, false), []string{\"e\", \"8\", \"e89d66bdfdd4dd26b682cc77e23a86eb\"})\n\tis.Equal(Shard(tokey, 2, 2, false), []string{\"e8\", \"9d\", \"e89d66bdfdd4dd26b682cc77e23a86eb\"})\n\tis.Equal(Shard(tokey, 2, 3, true), []string{\"e8\", \"9d\", \"66\", \"bdfdd4dd26b682cc77e23a86eb\"})\n}\n\nfunc TestRandomString(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Len(RandomString(10), 10)\n\n\tresult := RandomString(10, []rune(\"abcdefg\"))\n\n\tis.Len(result, 10)\n\n\tfor _, char := range result {\n\t\tis.True(char >= []rune(\"a\")[0] && char <= []rune(\"g\")[0])\n\t}\n}\n\nfunc TestIsEmpty(t *testing.T) {\n\tis := assert.New(t)\n\n\tchWithValue := make(chan struct{}, 1)\n\tchWithValue <- struct{}{}\n\tvar tiP *time.Time\n\tvar tiNP time.Time\n\tvar s *string\n\tvar f *os.File\n\tptrs := new(string)\n\t*ptrs = \"\"\n\n\tis.True(IsEmpty(ptrs), \"Nil string pointer is empty\")\n\tis.True(IsEmpty(\"\"), \"Empty string is empty\")\n\tis.True(IsEmpty(nil), \"Nil is empty\")\n\tis.True(IsEmpty([]string{}), \"Empty string array is empty\")\n\tis.True(IsEmpty(0), \"Zero int value is empty\")\n\tis.True(IsEmpty(false), \"False value is empty\")\n\tis.True(IsEmpty(make(chan struct{})), \"Channel without values is empty\")\n\tis.True(IsEmpty(s), \"Nil string pointer is empty\")\n\tis.True(IsEmpty(f), \"Nil os.File pointer is empty\")\n\tis.True(IsEmpty(tiP), \"Nil time.Time pointer is empty\")\n\tis.True(IsEmpty(tiNP), \"time.Time is empty\")\n\n\tis.False(NotEmpty(ptrs), \"Nil string pointer is empty\")\n\tis.False(NotEmpty(\"\"), \"Empty string is empty\")\n\tis.False(NotEmpty(nil), \"Nil is empty\")\n\tis.False(NotEmpty([]string{}), \"Empty string array is empty\")\n\tis.False(NotEmpty(0), \"Zero int value is empty\")\n\tis.False(NotEmpty(false), \"False value is empty\")\n\tis.False(NotEmpty(make(chan struct{})), \"Channel without values is empty\")\n\tis.False(NotEmpty(s), \"Nil string pointer is empty\")\n\tis.False(NotEmpty(f), \"Nil os.File pointer is empty\")\n\tis.False(NotEmpty(tiP), \"Nil time.Time pointer is empty\")\n\tis.False(NotEmpty(tiNP), \"time.Time is empty\")\n\n\tis.False(IsEmpty(\"something\"), \"Non Empty string is not empty\")\n\tis.False(IsEmpty(errors.New(\"something\")), \"Non nil object is not empty\")\n\tis.False(IsEmpty([]string{\"something\"}), \"Non empty string array is not empty\")\n\tis.False(IsEmpty(1), \"Non-zero int value is not empty\")\n\tis.False(IsEmpty(true), \"True value is not empty\")\n\tis.False(IsEmpty(chWithValue), \"Channel with values is not empty\")\n\n\tis.True(NotEmpty(\"something\"), \"Non Empty string is not empty\")\n\tis.True(NotEmpty(errors.New(\"something\")), \"Non nil object is not empty\")\n\tis.True(NotEmpty([]string{\"something\"}), \"Non empty string array is not empty\")\n\tis.True(NotEmpty(1), \"Non-zero int value is not empty\")\n\tis.True(NotEmpty(true), \"True value is not empty\")\n\tis.True(NotEmpty(chWithValue), \"Channel with values is not empty\")\n}\n\nfunc TestIsZero(t *testing.T) {\n\tis := assert.New(t)\n\n\tfor _, test := range zeros {\n\t\tis.True(IsZero(test))\n\t}\n\n\tfor _, test := range nonZeros {\n\t\tis.False(IsZero(test))\n\t}\n}\n\nfunc TestAny(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(Any(true, false))\n\tis.True(Any(true, true))\n\tis.False(Any(false, false))\n\tis.False(Any(\"\", nil, false))\n}\n\nfunc TestAll(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.False(All(true, false))\n\tis.True(All(true, true))\n\tis.False(All(false, false))\n\tis.False(All(\"\", nil, false))\n\tis.True(All(\"foo\", true, 3))\n}\n\nfunc TestIsIteratee(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.False(IsIteratee(nil))\n}\n\nfunc TestIsFunction(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.False(IsFunction(nil))\n\tis.False(IsFunction(\"\"))\n\tis.True(IsFunction(func() {}))\n\tis.True(IsFunction(func(string, string, string) bool { return false }, 3))\n\tis.False(IsFunction(func(string, string, string) bool { return false }, 3, 0))\n\tis.True(IsFunction(func(string, string, string) (bool, error) { return false, nil }, 3, 2))\n}\n\nfunc TestIsPredicate(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.False(IsPredicate(nil))\n\tis.False(IsPredicate(\"\"))\n\tis.False(IsPredicate(func() {}))\n\tis.False(IsPredicate(func() bool { return false}))\n\tis.True(IsPredicate(func(int) bool { return false}))\n\tis.True(IsPredicate(func(int) bool { return false}, nil))\n\tis.False(IsPredicate(func(int) bool { return false}, reflect.TypeOf(\"\")))\n\tis.True(IsPredicate(func(int) bool { return false}, reflect.TypeOf(0)))\n\tis.False(IsPredicate(func(int, string) bool { return false}, reflect.TypeOf(\"\")))\n\tis.False(IsPredicate(func(int, string) bool { return false}, reflect.TypeOf(\"\"), reflect.TypeOf(0)))\n\tis.True(IsPredicate(func(int, string) bool { return false}, reflect.TypeOf(0), reflect.TypeOf(\"\")))\n\tis.False(IsPredicate(func(struct{}, string) bool { return false}, reflect.TypeOf(0), reflect.TypeOf(\"\")))\n\tis.True(IsPredicate(func(struct{}, string) bool { return false}, nil, reflect.TypeOf(\"\")))\n}\n"
        },
        {
          "name": "intersection.go",
          "type": "blob",
          "size": 6.064453125,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n)\n\n// Intersect returns the intersection between two collections.\n//\n// Deprecated: use Join(x, y, InnerJoin) instead of Intersect, InnerJoin\n// implements deduplication mechanism, so verify your code behaviour\n// before using it\nfunc Intersect(x interface{}, y interface{}) interface{} {\n\tif !IsCollection(x) {\n\t\tpanic(\"First parameter must be a collection\")\n\t}\n\tif !IsCollection(y) {\n\t\tpanic(\"Second parameter must be a collection\")\n\t}\n\n\thash := map[interface{}]struct{}{}\n\n\txValue := reflect.ValueOf(x)\n\txType := xValue.Type()\n\n\tyValue := reflect.ValueOf(y)\n\tyType := yValue.Type()\n\n\tif NotEqual(xType, yType) {\n\t\tpanic(\"Parameters must have the same type\")\n\t}\n\n\tzType := reflect.SliceOf(xType.Elem())\n\tzSlice := reflect.MakeSlice(zType, 0, 0)\n\n\tfor i := 0; i < xValue.Len(); i++ {\n\t\tv := xValue.Index(i).Interface()\n\t\thash[v] = struct{}{}\n\t}\n\n\tfor i := 0; i < yValue.Len(); i++ {\n\t\tv := yValue.Index(i).Interface()\n\t\t_, ok := hash[v]\n\t\tif ok {\n\t\t\tzSlice = reflect.Append(zSlice, yValue.Index(i))\n\t\t}\n\t}\n\n\treturn zSlice.Interface()\n}\n\n// IntersectString returns the intersection between two collections of string.\nfunc IntersectString(x []string, y []string) []string {\n\tif len(x) == 0 || len(y) == 0 {\n\t\treturn []string{}\n\t}\n\n\tset := []string{}\n\thash := map[string]struct{}{}\n\n\tfor _, v := range x {\n\t\thash[v] = struct{}{}\n\t}\n\n\tfor _, v := range y {\n\t\t_, ok := hash[v]\n\t\tif ok {\n\t\t\tset = append(set, v)\n\t\t}\n\t}\n\n\treturn set\n}\n\n// Difference returns the difference between two collections.\nfunc Difference(x interface{}, y interface{}) (interface{}, interface{}) {\n\tif !IsIteratee(x) {\n\t\tpanic(\"First parameter must be an iteratee\")\n\t}\n\tif !IsIteratee(y) {\n\t\tpanic(\"Second parameter must be an iteratee\")\n\t}\n\n\txValue := reflect.ValueOf(x)\n\txType := xValue.Type()\n\n\tyValue := reflect.ValueOf(y)\n\tyType := yValue.Type()\n\n\tif NotEqual(xType, yType) {\n\t\tpanic(\"Parameters must have the same type\")\n\t}\n\n\tif xType.Kind() == reflect.Map {\n\t\tleftType := reflect.MapOf(xType.Key(), xType.Elem())\n\t\trightType := reflect.MapOf(xType.Key(), xType.Elem())\n\t\tleftMap := reflect.MakeMap(leftType)\n\t\trightMap := reflect.MakeMap(rightType)\n\n\t\txIter := xValue.MapRange()\n\t\tfor xIter.Next() {\n\t\t\tk := xIter.Key()\n\t\t\txv := xIter.Value()\n\t\t\tyv := yValue.MapIndex(k)\n\t\t\tequalTo := equal(xv.Interface(), true)\n\t\t\tif !yv.IsValid() || !equalTo(yv, yv) {\n\t\t\t\tleftMap.SetMapIndex(k, xv)\n\t\t\t}\n\t\t}\n\n\t\tyIter := yValue.MapRange()\n\t\tfor yIter.Next() {\n\t\t\tk := yIter.Key()\n\t\t\tyv := yIter.Value()\n\t\t\txv := xValue.MapIndex(k)\n\t\t\tequalTo := equal(yv.Interface(), true)\n\t\t\tif !xv.IsValid() || !equalTo(xv, xv) {\n\t\t\t\trightMap.SetMapIndex(k, yv)\n\t\t\t}\n\t\t}\n\t\treturn leftMap.Interface(), rightMap.Interface()\n\t} else {\n\t\tleftType := reflect.SliceOf(xType.Elem())\n\t\trightType := reflect.SliceOf(yType.Elem())\n\t\tleftSlice := reflect.MakeSlice(leftType, 0, 0)\n\t\trightSlice := reflect.MakeSlice(rightType, 0, 0)\n\n\t\tfor i := 0; i < xValue.Len(); i++ {\n\t\t\tv := xValue.Index(i).Interface()\n\t\t\tif !Contains(y, v) {\n\t\t\t\tleftSlice = reflect.Append(leftSlice, xValue.Index(i))\n\t\t\t}\n\t\t}\n\n\t\tfor i := 0; i < yValue.Len(); i++ {\n\t\t\tv := yValue.Index(i).Interface()\n\t\t\tif !Contains(x, v) {\n\t\t\t\trightSlice = reflect.Append(rightSlice, yValue.Index(i))\n\t\t\t}\n\t\t}\n\t\treturn leftSlice.Interface(), rightSlice.Interface()\n\t}\n}\n\n// DifferenceString returns the difference between two collections of strings.\nfunc DifferenceString(x []string, y []string) ([]string, []string) {\n\tleftSlice := []string{}\n\trightSlice := []string{}\n\n\tfor _, v := range x {\n\t\tif !ContainsString(y, v) {\n\t\t\tleftSlice = append(leftSlice, v)\n\t\t}\n\t}\n\n\tfor _, v := range y {\n\t\tif !ContainsString(x, v) {\n\t\t\trightSlice = append(rightSlice, v)\n\t\t}\n\t}\n\n\treturn leftSlice, rightSlice\n}\n\n// DifferenceInt64 returns the difference between two collections of int64s.\nfunc DifferenceInt64(x []int64, y []int64) ([]int64, []int64) {\n\tleftSlice := []int64{}\n\trightSlice := []int64{}\n\n\tfor _, v := range x {\n\t\tif !ContainsInt64(y, v) {\n\t\t\tleftSlice = append(leftSlice, v)\n\t\t}\n\t}\n\n\tfor _, v := range y {\n\t\tif !ContainsInt64(x, v) {\n\t\t\trightSlice = append(rightSlice, v)\n\t\t}\n\t}\n\n\treturn leftSlice, rightSlice\n}\n\n// DifferenceInt32 returns the difference between two collections of ints32.\nfunc DifferenceInt32(x []int32, y []int32) ([]int32, []int32) {\n\tleftSlice := []int32{}\n\trightSlice := []int32{}\n\n\tfor _, v := range x {\n\t\tif !ContainsInt32(y, v) {\n\t\t\tleftSlice = append(leftSlice, v)\n\t\t}\n\t}\n\n\tfor _, v := range y {\n\t\tif !ContainsInt32(x, v) {\n\t\t\trightSlice = append(rightSlice, v)\n\t\t}\n\t}\n\n\treturn leftSlice, rightSlice\n}\n\n// DifferenceInt returns the difference between two collections of ints.\nfunc DifferenceInt(x []int, y []int) ([]int, []int) {\n\tleftSlice := []int{}\n\trightSlice := []int{}\n\n\tfor _, v := range x {\n\t\tif !ContainsInt(y, v) {\n\t\t\tleftSlice = append(leftSlice, v)\n\t\t}\n\t}\n\n\tfor _, v := range y {\n\t\tif !ContainsInt(x, v) {\n\t\t\trightSlice = append(rightSlice, v)\n\t\t}\n\t}\n\n\treturn leftSlice, rightSlice\n}\n\n// DifferenceUInt returns the difference between two collections of uints.\nfunc DifferenceUInt(x []uint, y []uint) ([]uint, []uint) {\n\tleftSlice := []uint{}\n\trightSlice := []uint{}\n\n\tfor _, v := range x {\n\t\tif !ContainsUInt(y, v) {\n\t\t\tleftSlice = append(leftSlice, v)\n\t\t}\n\t}\n\n\tfor _, v := range y {\n\t\tif !ContainsUInt(x, v) {\n\t\t\trightSlice = append(rightSlice, v)\n\t\t}\n\t}\n\n\treturn leftSlice, rightSlice\n}\n\n// DifferenceUInt32 returns the difference between two collections of uints32.\nfunc DifferenceUInt32(x []uint32, y []uint32) ([]uint32, []uint32) {\n\tleftSlice := []uint32{}\n\trightSlice := []uint32{}\n\n\tfor _, v := range x {\n\t\tif !ContainsUInt32(y, v) {\n\t\t\tleftSlice = append(leftSlice, v)\n\t\t}\n\t}\n\n\tfor _, v := range y {\n\t\tif !ContainsUInt32(x, v) {\n\t\t\trightSlice = append(rightSlice, v)\n\t\t}\n\t}\n\n\treturn leftSlice, rightSlice\n}\n\n// DifferenceUInt64 returns the difference between two collections of uints64.\nfunc DifferenceUInt64(x []uint64, y []uint64) ([]uint64, []uint64) {\n\tleftSlice := []uint64{}\n\trightSlice := []uint64{}\n\n\tfor _, v := range x {\n\t\tif !ContainsUInt64(y, v) {\n\t\t\tleftSlice = append(leftSlice, v)\n\t\t}\n\t}\n\n\tfor _, v := range y {\n\t\tif !ContainsUInt64(x, v) {\n\t\t\trightSlice = append(rightSlice, v)\n\t\t}\n\t}\n\n\treturn leftSlice, rightSlice\n}\n"
        },
        {
          "name": "intersection_test.go",
          "type": "blob",
          "size": 1.5380859375,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIntersect(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := Intersect([]int{1, 2, 3, 4}, []int{2, 4, 6})\n\tis.Equal(r, []int{2, 4})\n\n\tr = Intersect([]string{\"foo\", \"bar\", \"hello\", \"bar\"}, []string{\"foo\", \"bar\"})\n\tis.Equal(r, []string{\"foo\", \"bar\"})\n\n\tr = Intersect([]string{\"foo\", \"bar\"}, []string{\"foo\", \"bar\", \"hello\", \"bar\"})\n\tis.Equal(r, []string{\"foo\", \"bar\", \"bar\"})\n}\n\nfunc TestIntersectString(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := IntersectString([]string{\"foo\", \"bar\", \"hello\", \"bar\"}, []string{\"foo\", \"bar\"})\n\tis.Equal(r, []string{\"foo\", \"bar\"})\n}\n\nfunc TestDifference(t *testing.T) {\n\tis := assert.New(t)\n\n\tr1, r2 := Difference([]int{1, 2, 3, 4}, []int{2, 4, 6})\n\tis.Equal(r1, []int{1, 3})\n\tis.Equal(r2, []int{6})\n\n\tr1, r2 = Difference([]string{\"foo\", \"bar\", \"hello\", \"bar\"}, []string{\"foo\", \"bar\"})\n\tis.Equal(r1, []string{\"hello\"})\n\tis.Equal(r2, []string{})\n\n\tr1, r2 = Difference(map[string]string{\"foo\": \"bar\", \"hello\": \"baz\"}, map[string]string{\"foo\": \"bar\", \"bar\": \"baz\"})\n\tis.Equal(r1, map[string]string{\"hello\": \"baz\"})\n\tis.Equal(r2, map[string]string{\"bar\": \"baz\"})\n}\n\nfunc TestDifferenceString(t *testing.T) {\n\tis := assert.New(t)\n\n\tr1, r2 := DifferenceString([]string{\"foo\", \"bar\", \"hello\", \"bar\"}, []string{\"foo\", \"bar\"})\n\tis.Equal(r1, []string{\"hello\"})\n\tis.Equal(r2, []string{})\n}\n\nfunc TestDifferenceInt64(t *testing.T) {\n\tis := assert.New(t)\n\n\tr1, r2 := DifferenceInt64([]int64{1, 2, 3, 4}, []int64{4, 6})\n\tis.Equal(r1, []int64{1, 2, 3})\n\tis.Equal(r2, []int64{6})\n}\n"
        },
        {
          "name": "join.go",
          "type": "blob",
          "size": 2.8681640625,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\ntype JoinFnc func(lx, rx reflect.Value) reflect.Value\n\n// Join combines two collections using the given join method.\nfunc Join(larr, rarr interface{}, fnc JoinFnc) interface{} {\n\tif !IsCollection(larr) {\n\t\tpanic(\"First parameter must be a collection\")\n\t}\n\tif !IsCollection(rarr) {\n\t\tpanic(\"Second parameter must be a collection\")\n\t}\n\n\tlvalue := reflect.ValueOf(larr)\n\trvalue := reflect.ValueOf(rarr)\n\tif NotEqual(lvalue.Type(), rvalue.Type()) {\n\t\tpanic(\"Parameters must have the same type\")\n\t}\n\n\treturn fnc(lvalue, rvalue).Interface()\n}\n\n// InnerJoin finds and returns matching data from two collections.\nfunc InnerJoin(lx, rx reflect.Value) reflect.Value {\n\tresult := reflect.MakeSlice(reflect.SliceOf(lx.Type().Elem()), 0, lx.Len()+rx.Len())\n\trhash := hashSlice(rx)\n\tlhash := make(map[interface{}]struct{}, lx.Len())\n\n\tfor i := 0; i < lx.Len(); i++ {\n\t\tv := lx.Index(i)\n\t\t_, ok := rhash[v.Interface()]\n\t\t_, alreadyExists := lhash[v.Interface()]\n\t\tif ok && !alreadyExists {\n\t\t\tlhash[v.Interface()] = struct{}{}\n\t\t\tresult = reflect.Append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// OuterJoin finds and returns dissimilar data from two collections.\nfunc OuterJoin(lx, rx reflect.Value) reflect.Value {\n\tljoin := LeftJoin(lx, rx)\n\trjoin := RightJoin(lx, rx)\n\n\tresult := reflect.MakeSlice(reflect.SliceOf(lx.Type().Elem()), ljoin.Len()+rjoin.Len(), ljoin.Len()+rjoin.Len())\n\tfor i := 0; i < ljoin.Len(); i++ {\n\t\tresult.Index(i).Set(ljoin.Index(i))\n\t}\n\tfor i := 0; i < rjoin.Len(); i++ {\n\t\tresult.Index(ljoin.Len() + i).Set(rjoin.Index(i))\n\t}\n\n\treturn result\n}\n\n// LeftJoin finds and returns dissimilar data from the first collection (left).\nfunc LeftJoin(lx, rx reflect.Value) reflect.Value {\n\tresult := reflect.MakeSlice(reflect.SliceOf(lx.Type().Elem()), 0, lx.Len())\n\trhash := hashSlice(rx)\n\n\tfor i := 0; i < lx.Len(); i++ {\n\t\tv := lx.Index(i)\n\t\t_, ok := rhash[v.Interface()]\n\t\tif !ok {\n\t\t\tresult = reflect.Append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// LeftJoin finds and returns dissimilar data from the second collection (right).\nfunc RightJoin(lx, rx reflect.Value) reflect.Value { return LeftJoin(rx, lx) }\n\nfunc hashSlice(arr reflect.Value) map[interface{}]struct{} {\n\thash := map[interface{}]struct{}{}\n\tfor i := 0; i < arr.Len(); i++ {\n\t\tv := arr.Index(i).Interface()\n\t\thash[v] = struct{}{}\n\t}\n\treturn hash\n}\n\n// StringerJoin joins an array of elements which implement the `String() string` function.\n// Direct copy of strings.Join() with a few tweaks.\nfunc StringerJoin(elems []interface{ String() string }, sep string) string {\n\tswitch len(elems) {\n\tcase 0:\n\t\treturn \"\"\n\tcase 1:\n\t\treturn elems[0].String()\n\t}\n\tn := len(sep) * (len(elems) - 1)\n\tfor i := 0; i < len(elems); i++ {\n\t\tn += len(elems[i].String())\n\t}\n\n\tvar b strings.Builder\n\tb.Grow(n)\n\tb.WriteString(elems[0].String())\n\tfor _, s := range elems[1:] {\n\t\tb.WriteString(sep)\n\t\tb.WriteString(s.String())\n\t}\n\treturn b.String()\n}\n"
        },
        {
          "name": "join_primitives.go",
          "type": "blob",
          "size": 9.6396484375,
          "content": "package funk\n\ntype JoinIntFnc func(lx, rx []int) []int\n\n// JoinInt combines two int collections using the given join method.\nfunc JoinInt(larr, rarr []int, fnc JoinIntFnc) []int {\n\treturn fnc(larr, rarr)\n}\n\n// InnerJoinInt finds and returns matching data from two int collections.\nfunc InnerJoinInt(lx, rx []int) []int {\n\tresult := make([]int, 0, len(lx)+len(rx))\n\trhash := hashSliceInt(rx)\n\tlhash := make(map[int]struct{}, len(lx))\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\t_, alreadyExists := lhash[v]\n\t\tif ok && !alreadyExists {\n\t\t\tlhash[v] = struct{}{}\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// OuterJoinInt finds and returns dissimilar data from two int collections.\nfunc OuterJoinInt(lx, rx []int) []int {\n\tljoin := LeftJoinInt(lx, rx)\n\trjoin := RightJoinInt(lx, rx)\n\n\tresult := make([]int, len(ljoin)+len(rjoin))\n\tcopy(result, ljoin)\n\tfor i, v := range rjoin {\n\t\tresult[len(ljoin)+i] = v\n\t}\n\treturn result\n}\n\n// LeftJoinInt finds and returns dissimilar data from the first int collection (left).\nfunc LeftJoinInt(lx, rx []int) []int {\n\tresult := make([]int, 0, len(lx))\n\trhash := hashSliceInt(rx)\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\tif !ok {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// LeftJoinInt finds and returns dissimilar data from the second int collection (right).\nfunc RightJoinInt(lx, rx []int) []int { return LeftJoinInt(rx, lx) }\n\nfunc hashSliceInt(arr []int) map[int]struct{} {\n\thash := make(map[int]struct{}, len(arr))\n\tfor _, i := range arr {\n\t\thash[i] = struct{}{}\n\t}\n\treturn hash\n}\n\ntype JoinInt32Fnc func(lx, rx []int32) []int32\n\n// JoinInt32 combines two int32 collections using the given join method.\nfunc JoinInt32(larr, rarr []int32, fnc JoinInt32Fnc) []int32 {\n\treturn fnc(larr, rarr)\n}\n\n// InnerJoinInt32 finds and returns matching data from two int32 collections.\nfunc InnerJoinInt32(lx, rx []int32) []int32 {\n\tresult := make([]int32, 0, len(lx)+len(rx))\n\trhash := hashSliceInt32(rx)\n\tlhash := make(map[int32]struct{}, len(lx))\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\t_, alreadyExists := lhash[v]\n\t\tif ok && !alreadyExists {\n\t\t\tlhash[v] = struct{}{}\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// OuterJoinInt32 finds and returns dissimilar data from two int32 collections.\nfunc OuterJoinInt32(lx, rx []int32) []int32 {\n\tljoin := LeftJoinInt32(lx, rx)\n\trjoin := RightJoinInt32(lx, rx)\n\n\tresult := make([]int32, len(ljoin)+len(rjoin))\n\tcopy(result, ljoin)\n\tfor i, v := range rjoin {\n\t\tresult[len(ljoin)+i] = v\n\t}\n\treturn result\n}\n\n// LeftJoinInt32 finds and returns dissimilar data from the first int32 collection (left).\nfunc LeftJoinInt32(lx, rx []int32) []int32 {\n\tresult := make([]int32, 0, len(lx))\n\trhash := hashSliceInt32(rx)\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\tif !ok {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// LeftJoinInt32 finds and returns dissimilar data from the second int32 collection (right).\nfunc RightJoinInt32(lx, rx []int32) []int32 { return LeftJoinInt32(rx, lx) }\n\nfunc hashSliceInt32(arr []int32) map[int32]struct{} {\n\thash := make(map[int32]struct{}, len(arr))\n\tfor _, i := range arr {\n\t\thash[i] = struct{}{}\n\t}\n\treturn hash\n}\n\ntype JoinInt64Fnc func(lx, rx []int64) []int64\n\n// JoinInt64 combines two int64 collections using the given join method.\nfunc JoinInt64(larr, rarr []int64, fnc JoinInt64Fnc) []int64 {\n\treturn fnc(larr, rarr)\n}\n\n// InnerJoinInt64 finds and returns matching data from two int64 collections.\nfunc InnerJoinInt64(lx, rx []int64) []int64 {\n\tresult := make([]int64, 0, len(lx)+len(rx))\n\trhash := hashSliceInt64(rx)\n\tlhash := make(map[int64]struct{}, len(lx))\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\t_, alreadyExists := lhash[v]\n\t\tif ok && !alreadyExists {\n\t\t\tlhash[v] = struct{}{}\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// OuterJoinInt64 finds and returns dissimilar data from two int64 collections.\nfunc OuterJoinInt64(lx, rx []int64) []int64 {\n\tljoin := LeftJoinInt64(lx, rx)\n\trjoin := RightJoinInt64(lx, rx)\n\n\tresult := make([]int64, len(ljoin)+len(rjoin))\n\tcopy(result, ljoin)\n\tfor i, v := range rjoin {\n\t\tresult[len(ljoin)+i] = v\n\t}\n\treturn result\n}\n\n// LeftJoinInt64 finds and returns dissimilar data from the first int64 collection (left).\nfunc LeftJoinInt64(lx, rx []int64) []int64 {\n\tresult := make([]int64, 0, len(lx))\n\trhash := hashSliceInt64(rx)\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\tif !ok {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// LeftJoinInt64 finds and returns dissimilar data from the second int64 collection (right).\nfunc RightJoinInt64(lx, rx []int64) []int64 { return LeftJoinInt64(rx, lx) }\n\nfunc hashSliceInt64(arr []int64) map[int64]struct{} {\n\thash := make(map[int64]struct{}, len(arr))\n\tfor _, i := range arr {\n\t\thash[i] = struct{}{}\n\t}\n\treturn hash\n}\n\ntype JoinStringFnc func(lx, rx []string) []string\n\n// JoinString combines two string collections using the given join method.\nfunc JoinString(larr, rarr []string, fnc JoinStringFnc) []string {\n\treturn fnc(larr, rarr)\n}\n\n// InnerJoinString finds and returns matching data from two string collections.\nfunc InnerJoinString(lx, rx []string) []string {\n\tresult := make([]string, 0, len(lx)+len(rx))\n\trhash := hashSliceString(rx)\n\tlhash := make(map[string]struct{}, len(lx))\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\t_, alreadyExists := lhash[v]\n\t\tif ok && !alreadyExists {\n\t\t\tlhash[v] = struct{}{}\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// OuterJoinString finds and returns dissimilar data from two string collections.\nfunc OuterJoinString(lx, rx []string) []string {\n\tljoin := LeftJoinString(lx, rx)\n\trjoin := RightJoinString(lx, rx)\n\n\tresult := make([]string, len(ljoin)+len(rjoin))\n\tcopy(result, ljoin)\n\tfor i, v := range rjoin {\n\t\tresult[len(ljoin)+i] = v\n\t}\n\treturn result\n}\n\n// LeftJoinString finds and returns dissimilar data from the first string collection (left).\nfunc LeftJoinString(lx, rx []string) []string {\n\tresult := make([]string, 0, len(lx))\n\trhash := hashSliceString(rx)\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\tif !ok {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// LeftJoinString finds and returns dissimilar data from the second string collection (right).\nfunc RightJoinString(lx, rx []string) []string { return LeftJoinString(rx, lx) }\n\nfunc hashSliceString(arr []string) map[string]struct{} {\n\thash := make(map[string]struct{}, len(arr))\n\tfor _, i := range arr {\n\t\thash[i] = struct{}{}\n\t}\n\treturn hash\n}\n\ntype JoinFloat32Fnc func(lx, rx []float32) []float32\n\n// JoinFloat32 combines two float32 collections using the given join method.\nfunc JoinFloat32(larr, rarr []float32, fnc JoinFloat32Fnc) []float32 {\n\treturn fnc(larr, rarr)\n}\n\n// InnerJoinFloat32 finds and returns matching data from two float32 collections.\nfunc InnerJoinFloat32(lx, rx []float32) []float32 {\n\tresult := make([]float32, 0, len(lx)+len(rx))\n\trhash := hashSliceFloat32(rx)\n\tlhash := make(map[float32]struct{}, len(lx))\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\t_, alreadyExists := lhash[v]\n\t\tif ok && !alreadyExists {\n\t\t\tlhash[v] = struct{}{}\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// OuterJoinFloat32 finds and returns dissimilar data from two float32 collections.\nfunc OuterJoinFloat32(lx, rx []float32) []float32 {\n\tljoin := LeftJoinFloat32(lx, rx)\n\trjoin := RightJoinFloat32(lx, rx)\n\n\tresult := make([]float32, len(ljoin)+len(rjoin))\n\tcopy(result, ljoin)\n\tfor i, v := range rjoin {\n\t\tresult[len(ljoin)+i] = v\n\t}\n\treturn result\n}\n\n// LeftJoinFloat32 finds and returns dissimilar data from the first float32 collection (left).\nfunc LeftJoinFloat32(lx, rx []float32) []float32 {\n\tresult := make([]float32, 0, len(lx))\n\trhash := hashSliceFloat32(rx)\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\tif !ok {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// LeftJoinFloat32 finds and returns dissimilar data from the second float32 collection (right).\nfunc RightJoinFloat32(lx, rx []float32) []float32 { return LeftJoinFloat32(rx, lx) }\n\nfunc hashSliceFloat32(arr []float32) map[float32]struct{} {\n\thash := make(map[float32]struct{}, len(arr))\n\tfor _, i := range arr {\n\t\thash[i] = struct{}{}\n\t}\n\treturn hash\n}\n\ntype JoinFloat64Fnc func(lx, rx []float64) []float64\n\n// JoinFloat64 combines two float64 collections using the given join method.\nfunc JoinFloat64(larr, rarr []float64, fnc JoinFloat64Fnc) []float64 {\n\treturn fnc(larr, rarr)\n}\n\n// InnerJoinFloat64 finds and returns matching data from two float64 collections.\nfunc InnerJoinFloat64(lx, rx []float64) []float64 {\n\tresult := make([]float64, 0, len(lx)+len(rx))\n\trhash := hashSliceFloat64(rx)\n\tlhash := make(map[float64]struct{}, len(lx))\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\t_, alreadyExists := lhash[v]\n\t\tif ok && !alreadyExists {\n\t\t\tlhash[v] = struct{}{}\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// OuterJoinFloat64 finds and returns dissimilar data from two float64 collections.\nfunc OuterJoinFloat64(lx, rx []float64) []float64 {\n\tljoin := LeftJoinFloat64(lx, rx)\n\trjoin := RightJoinFloat64(lx, rx)\n\n\tresult := make([]float64, len(ljoin)+len(rjoin))\n\tcopy(result, ljoin)\n\tfor i, v := range rjoin {\n\t\tresult[len(ljoin)+i] = v\n\t}\n\treturn result\n}\n\n// LeftJoinFloat64 finds and returns dissimilar data from the first float64 collection (left).\nfunc LeftJoinFloat64(lx, rx []float64) []float64 {\n\tresult := make([]float64, 0, len(lx))\n\trhash := hashSliceFloat64(rx)\n\n\tfor _, v := range lx {\n\t\t_, ok := rhash[v]\n\t\tif !ok {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\n// LeftJoinFloat64 finds and returns dissimilar data from the second float64 collection (right).\nfunc RightJoinFloat64(lx, rx []float64) []float64 { return LeftJoinFloat64(rx, lx) }\n\nfunc hashSliceFloat64(arr []float64) map[float64]struct{} {\n\thash := make(map[float64]struct{}, len(arr))\n\tfor _, i := range arr {\n\t\thash[i] = struct{}{}\n\t}\n\treturn hash\n}\n"
        },
        {
          "name": "join_test.go",
          "type": "blob",
          "size": 3.1123046875,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestJoin_InnerJoin(t *testing.T) {\n\ttestCases := []struct {\n\t\tLeftArr  interface{}\n\t\tRightArr interface{}\n\t\tExpect   interface{}\n\t}{\n\t\t{[]string{\"foo\", \"bar\"}, []string{\"bar\", \"baz\"}, []string{\"bar\"}},\n\t\t{[]string{\"foo\", \"bar\", \"bar\"}, []string{\"bar\", \"baz\"}, []string{\"bar\"}},\n\t\t{[]string{\"foo\", \"bar\"}, []string{\"bar\", \"bar\", \"baz\"}, []string{\"bar\"}},\n\t\t{[]string{\"foo\", \"bar\", \"bar\"}, []string{\"bar\", \"bar\", \"baz\"}, []string{\"bar\"}},\n\t\t{[]int{0, 1, 2, 3, 4}, []int{3, 4, 5, 6, 7}, []int{3, 4}},\n\t\t{[]*Foo{f, b}, []*Foo{b, c}, []*Foo{b}},\n\t}\n\n\tfor idx, tt := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := Join(tt.LeftArr, tt.RightArr, InnerJoin)\n\t\t\tis.Equal(tt.Expect, actual)\n\t\t})\n\t}\n}\n\nfunc TestJoin_OuterJoin(t *testing.T) {\n\ttestCases := []struct {\n\t\tLeftArr  interface{}\n\t\tRightArr interface{}\n\t\tExpect   interface{}\n\t}{\n\t\t{[]string{\"foo\", \"bar\"}, []string{\"bar\", \"baz\"}, []string{\"foo\", \"baz\"}},\n\t\t{[]int{0, 1, 2, 3, 4}, []int{3, 4, 5, 6, 7}, []int{0, 1, 2, 5, 6, 7}},\n\t\t{[]*Foo{f, b}, []*Foo{b, c}, []*Foo{f, c}},\n\t}\n\n\tfor idx, tt := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := Join(tt.LeftArr, tt.RightArr, OuterJoin)\n\t\t\tis.Equal(tt.Expect, actual)\n\t\t})\n\t}\n}\n\nfunc TestJoin_LeftJoin(t *testing.T) {\n\ttestCases := []struct {\n\t\tLeftArr  interface{}\n\t\tRightArr interface{}\n\t\tExpect   interface{}\n\t}{\n\t\t{[]string{\"foo\", \"bar\"}, []string{\"bar\", \"baz\"}, []string{\"foo\"}},\n\t\t{[]int{0, 1, 2, 3, 4}, []int{3, 4, 5, 6, 7}, []int{0, 1, 2}},\n\t\t{[]*Foo{f, b}, []*Foo{b, c}, []*Foo{f}},\n\t}\n\n\tfor idx, tt := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := Join(tt.LeftArr, tt.RightArr, LeftJoin)\n\t\t\tis.Equal(tt.Expect, actual)\n\t\t})\n\t}\n}\n\nfunc TestJoin_RightJoin(t *testing.T) {\n\ttestCases := []struct {\n\t\tLeftArr  interface{}\n\t\tRightArr interface{}\n\t\tExpect   interface{}\n\t}{\n\t\t{[]string{\"foo\", \"bar\"}, []string{\"bar\", \"baz\"}, []string{\"baz\"}},\n\t\t{[]int{0, 1, 2, 3, 4}, []int{3, 4, 5, 6, 7}, []int{5, 6, 7}},\n\t\t{[]*Foo{f, b}, []*Foo{b, c}, []*Foo{c}},\n\t}\n\n\tfor idx, tt := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := Join(tt.LeftArr, tt.RightArr, RightJoin)\n\t\t\tis.Equal(tt.Expect, actual)\n\t\t})\n\t}\n}\n\n// Struct which implements the String() method to test StringerJoin().\ntype S struct {\n\tValue string\n}\n\nfunc (s S) String() string {\n\treturn s.Value\n}\n\nfunc TestJoin_StringerJoin(t *testing.T) {\n\ttestCases := []struct {\n\t\tArr    []interface{ String() string }\n\t\tSep    string\n\t\tExpect string\n\t}{\n\t\t{[]interface{ String() string }{}, \", \", \"\"},\n\t\t{[]interface{ String() string }{S{\"foo\"}}, \", \", \"foo\"},\n\t\t{[]interface{ String() string }{S{\"foo\"}, S{\"bar\"}, S{\"baz\"}}, \", \", \"foo, bar, baz\"},\n\t}\n\n\tfor idx, tt := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := StringerJoin(tt.Arr, tt.Sep)\n\t\t\tis.Equal(tt.Expect, actual)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "lazy_builder.go",
          "type": "blob",
          "size": 3.6103515625,
          "content": "package funk\n\nimport \"reflect\"\n\ntype lazyBuilder struct {\n\texec func() interface{}\n}\n\nfunc (b *lazyBuilder) Chunk(size int) Builder {\n\treturn &lazyBuilder{func() interface{} { return Chunk(b.exec(), size) }}\n}\nfunc (b *lazyBuilder) Compact() Builder {\n\treturn &lazyBuilder{func() interface{} { return Compact(b.exec()) }}\n}\nfunc (b *lazyBuilder) Drop(n int) Builder {\n\treturn &lazyBuilder{func() interface{} { return Drop(b.exec(), n) }}\n}\nfunc (b *lazyBuilder) Filter(predicate interface{}) Builder {\n\treturn &lazyBuilder{func() interface{} { return Filter(b.exec(), predicate) }}\n}\nfunc (b *lazyBuilder) Flatten() Builder {\n\treturn &lazyBuilder{func() interface{} { return Flatten(b.exec()) }}\n}\nfunc (b *lazyBuilder) FlattenDeep() Builder {\n\treturn &lazyBuilder{func() interface{} { return FlattenDeep(b.exec()) }}\n}\nfunc (b *lazyBuilder) Initial() Builder {\n\treturn &lazyBuilder{func() interface{} { return Initial(b.exec()) }}\n}\nfunc (b *lazyBuilder) Intersect(y interface{}) Builder {\n\treturn &lazyBuilder{func() interface{} { return Intersect(b.exec(), y) }}\n}\nfunc (b *lazyBuilder) Join(rarr interface{}, fnc JoinFnc) Builder {\n\treturn &lazyBuilder{func() interface{} { return Join(b.exec(), rarr, fnc) }}\n}\nfunc (b *lazyBuilder) Map(mapFunc interface{}) Builder {\n\treturn &lazyBuilder{func() interface{} { return Map(b.exec(), mapFunc) }}\n}\nfunc (b *lazyBuilder) FlatMap(mapFunc interface{}) Builder {\n\treturn &lazyBuilder{func() interface{} { return FlatMap(b.exec(), mapFunc) }}\n}\nfunc (b *lazyBuilder) Reverse() Builder {\n\treturn &lazyBuilder{func() interface{} { return Reverse(b.exec()) }}\n}\nfunc (b *lazyBuilder) Shuffle() Builder {\n\treturn &lazyBuilder{func() interface{} { return Shuffle(b.exec()) }}\n}\nfunc (b *lazyBuilder) Tail() Builder {\n\treturn &lazyBuilder{func() interface{} { return Tail(b.exec()) }}\n}\nfunc (b *lazyBuilder) Uniq() Builder {\n\treturn &lazyBuilder{func() interface{} { return Uniq(b.exec()) }}\n}\nfunc (b *lazyBuilder) Without(values ...interface{}) Builder {\n\treturn &lazyBuilder{func() interface{} { return Without(b.exec(), values...) }}\n}\n\nfunc (b *lazyBuilder) All() bool {\n\treturn (&chainBuilder{b.exec()}).All()\n}\nfunc (b *lazyBuilder) Any() bool {\n\treturn (&chainBuilder{b.exec()}).Any()\n}\nfunc (b *lazyBuilder) Contains(elem interface{}) bool {\n\treturn Contains(b.exec(), elem)\n}\nfunc (b *lazyBuilder) Every(elements ...interface{}) bool {\n\treturn Every(b.exec(), elements...)\n}\nfunc (b *lazyBuilder) Find(predicate interface{}) interface{} {\n\treturn Find(b.exec(), predicate)\n}\nfunc (b *lazyBuilder) ForEach(predicate interface{}) {\n\tForEach(b.exec(), predicate)\n}\nfunc (b *lazyBuilder) ForEachRight(predicate interface{}) {\n\tForEachRight(b.exec(), predicate)\n}\nfunc (b *lazyBuilder) Head() interface{} {\n\treturn Head(b.exec())\n}\nfunc (b *lazyBuilder) Keys() interface{} {\n\treturn Keys(b.exec())\n}\nfunc (b *lazyBuilder) IndexOf(elem interface{}) int {\n\treturn IndexOf(b.exec(), elem)\n}\nfunc (b *lazyBuilder) IsEmpty() bool {\n\treturn IsEmpty(b.exec())\n}\nfunc (b *lazyBuilder) Last() interface{} {\n\treturn Last(b.exec())\n}\nfunc (b *lazyBuilder) LastIndexOf(elem interface{}) int {\n\treturn LastIndexOf(b.exec(), elem)\n}\nfunc (b *lazyBuilder) NotEmpty() bool {\n\treturn NotEmpty(b.exec())\n}\nfunc (b *lazyBuilder) Product() float64 {\n\treturn Product(b.exec())\n}\nfunc (b *lazyBuilder) Reduce(reduceFunc, acc interface{}) interface{} {\n\treturn Reduce(b.exec(), reduceFunc, acc)\n}\nfunc (b *lazyBuilder) Sum() float64 {\n\treturn Sum(b.exec())\n}\nfunc (b *lazyBuilder) Type() reflect.Type {\n\treturn reflect.TypeOf(b.exec())\n}\nfunc (b *lazyBuilder) Value() interface{} {\n\treturn b.exec()\n}\nfunc (b *lazyBuilder) Values() interface{} {\n\treturn Values(b.exec())\n}\n"
        },
        {
          "name": "lazy_builder_test.go",
          "type": "blob",
          "size": 23.9697265625,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestLazyChunk(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn   interface{}\n\t\tSize int\n\t}{\n\t\t{In: []int{0, 1, 2, 3, 4}, Size: 2},\n\t\t{In: []int{}, Size: 2},\n\t\t{In: []int{1}, Size: 2},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Chunk(tc.In, tc.Size)\n\t\t\tactual := LazyChain(tc.In).Chunk(tc.Size).Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyCompact(t *testing.T) {\n\tvar emptyFunc func() bool\n\temptyFuncPtr := &emptyFunc\n\n\tnonEmptyFunc := func() bool { return true }\n\tnonEmptyFuncPtr := &nonEmptyFunc\n\n\tnonEmptyMap := map[int]int{1: 2}\n\tnonEmptyMapPtr := &nonEmptyMap\n\n\tvar emptyMap map[int]int\n\temptyMapPtr := &emptyMap\n\n\tvar emptyChan chan bool\n\tnonEmptyChan := make(chan bool, 1)\n\tnonEmptyChan <- true\n\n\temptyChanPtr := &emptyChan\n\tnonEmptyChanPtr := &nonEmptyChan\n\n\tvar emptyString string\n\temptyStringPtr := &emptyString\n\n\tnonEmptyString := \"42\"\n\tnonEmptyStringPtr := &nonEmptyString\n\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []interface{}{42, nil, (*int)(nil)}},\n\t\t{In: []interface{}{42, emptyFuncPtr, emptyFunc, nonEmptyFuncPtr}},\n\t\t{In: []interface{}{42, [2]int{}, map[int]int{}, []string{}, nonEmptyMapPtr, emptyMap, emptyMapPtr, nonEmptyMap, nonEmptyChan, emptyChan, emptyChanPtr, nonEmptyChanPtr}},\n\t\t{In: []interface{}{true, 0, float64(0), \"\", \"42\", emptyStringPtr, nonEmptyStringPtr, false}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Compact(tc.In)\n\t\t\tactual := LazyChain(tc.In).Compact().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyDrop(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t\tN  int\n\t}{\n\t\t{In: []int{0, 1, 1, 2, 3, 0, 0, 12}, N: 3},\n\t\t// Bug: Issues from go-funk (n parameter can be greater than len(in))\n\t\t// {In: []int{0, 1}, N: 3},\n\t\t// {In: []int{}, N: 3},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Drop(tc.In, tc.N)\n\t\t\tactual := LazyChain(tc.In).Drop(tc.N).Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyFilter(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn        interface{}\n\t\tPredicate interface{}\n\t}{\n\t\t{\n\t\t\tIn:        []int{1, 2, 3, 4},\n\t\t\tPredicate: func(x int) bool { return x%2 == 0 },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Filter(tc.In, tc.Predicate)\n\t\t\tactual := LazyChain(tc.In).Filter(tc.Predicate).Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\nfunc TestLazyFilter_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tLazyChain := LazyChain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\n\tfiltered := LazyChain.Filter(func(x *foo) bool {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\treturn x.bar == \"foo\"\n\t})\n\tis.Equal([]*foo{}, filtered.Value())\n\n\t// Side effect: in and LazyChain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestLazyFlatten(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: [][]int{{1, 2}, {3, 4}},\n\t\t},\n\t\t{\n\t\t\tIn: [][][]int{{{1, 2}, {3, 4}}, {{5, 6}}},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Flatten(tc.In)\n\t\t\tactual := LazyChain(tc.In).Flatten().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyFlattenDeep(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: [][]int{{1, 2}, {3, 4}},\n\t\t},\n\t\t{\n\t\t\tIn: [][][]int{{{1, 2}, {3, 4}}, {{5, 6}}},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := FlattenDeep(tc.In)\n\t\t\tactual := LazyChain(tc.In).FlattenDeep().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyInitial(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{},\n\t\t},\n\t\t{\n\t\t\tIn: []int{0},\n\t\t},\n\t\t{\n\t\t\tIn: []int{0, 1, 2, 3},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Initial(tc.In)\n\t\t\tactual := LazyChain(tc.In).Initial().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyIntersect(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn  interface{}\n\t\tSec interface{}\n\t}{\n\t\t{\n\t\t\tIn:  []int{1, 2, 3, 4},\n\t\t\tSec: []int{2, 4, 6},\n\t\t},\n\t\t{\n\t\t\tIn:  []string{\"foo\", \"bar\", \"hello\", \"bar\"},\n\t\t\tSec: []string{\"foo\", \"bar\"},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Intersect(tc.In, tc.Sec)\n\t\t\tactual := LazyChain(tc.In).Intersect(tc.Sec).Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyMap(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn     interface{}\n\t\tMapFnc interface{}\n\t}{\n\t\t{\n\t\t\tIn:     []int{1, 2, 3, 4},\n\t\t\tMapFnc: func(x int) string { return \"Hello\" },\n\t\t},\n\t\t{\n\t\t\tIn:     []int{1, 2, 3, 4},\n\t\t\tMapFnc: func(x int) (int, int) { return x, x },\n\t\t},\n\t\t{\n\t\t\tIn:     map[int]string{1: \"Florent\", 2: \"Gilles\"},\n\t\t\tMapFnc: func(k int, v string) int { return k },\n\t\t},\n\t\t{\n\t\t\tIn:     map[int]string{1: \"Florent\", 2: \"Gilles\"},\n\t\t\tMapFnc: func(k int, v string) (string, string) { return fmt.Sprintf(\"%d\", k), v },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Map(tc.In, tc.MapFnc)\n\t\t\tactual := LazyChain(tc.In).Map(tc.MapFnc).Value()\n\n\t\t\tif reflect.TypeOf(expected).Kind() == reflect.Map {\n\t\t\t\tis.Equal(expected, actual)\n\t\t\t} else {\n\t\t\t\tis.ElementsMatch(expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLazyFlatMap(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn         interface{}\n\t\tFlatMapFnc interface{}\n\t}{\n\t\t{\n\t\t\tIn:         [][]int{{1}, {2}, {3}, {4}},\n\t\t\tFlatMapFnc: func(x []int) []int { return x },\n\t\t},\n\t\t{\n\t\t\tIn:         map[string][]int{\"Florent\": {1}, \"Gilles\": {2}},\n\t\t\tFlatMapFnc: func(k string, v []int) []int { return v },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Map(tc.In, tc.FlatMapFnc)\n\t\t\tactual := LazyChain(tc.In).Map(tc.FlatMapFnc).Value()\n\n\t\t\tis.ElementsMatch(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyMap_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tLazyChain := LazyChain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\n\tmapped := LazyChain.Map(func(x *foo) (string, bool) {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\treturn x.bar, x.bar == \"foo\"\n\t})\n\tis.Equal(map[string]bool{\"__foo__\": false, \"__bar__\": false}, mapped.Value())\n\n\t// Side effect: in and LazyChain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestLazyReverse(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tIn: \"abcdefg\",\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Reverse(tc.In)\n\t\t\tactual := LazyChain(tc.In).Reverse().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyShuffle(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{0, 1, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Shuffle(tc.In)\n\t\t\tactual := LazyChain(tc.In).Shuffle().Value()\n\n\t\t\tis.NotEqual(expected, actual)\n\t\t\tis.ElementsMatch(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyTail(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{},\n\t\t},\n\t\t{\n\t\t\tIn: []int{0},\n\t\t},\n\t\t{\n\t\t\tIn: []int{0, 1, 2, 3},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Tail(tc.In)\n\t\t\tactual := LazyChain(tc.In).Tail().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyUniq(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{0, 1, 1, 2, 3, 0, 0, 12},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Uniq(tc.In)\n\t\t\tactual := LazyChain(tc.In).Uniq().Value()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyAll(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn []interface{}\n\t}{\n\t\t{In: []interface{}{\"foo\", \"bar\"}},\n\t\t{In: []interface{}{\"foo\", \"\"}},\n\t\t{In: []interface{}{\"\", \"\"}},\n\t\t{In: []interface{}{}},\n\t\t{In: []interface{}{true, \"foo\", 6}},\n\t\t{In: []interface{}{true, \"\", 6}},\n\t\t{In: []interface{}{true, \"foo\", 0}},\n\t\t{In: []interface{}{false, \"foo\", 6}},\n\t\t{In: []interface{}{false, \"\", 0}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := All(tc.In...)\n\t\t\tactual := LazyChain(tc.In).All()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyAny(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn []interface{}\n\t}{\n\t\t{In: []interface{}{\"foo\", \"bar\"}},\n\t\t{In: []interface{}{\"foo\", \"\"}},\n\t\t{In: []interface{}{\"\", \"\"}},\n\t\t{In: []interface{}{}},\n\t\t{In: []interface{}{true, \"foo\", 6}},\n\t\t{In: []interface{}{true, \"\", 6}},\n\t\t{In: []interface{}{true, \"foo\", 0}},\n\t\t{In: []interface{}{false, \"foo\", 6}},\n\t\t{In: []interface{}{false, \"\", 0}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Any(tc.In...)\n\t\t\tactual := LazyChain(tc.In).Any()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyContains(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn       interface{}\n\t\tContains interface{}\n\t}{\n\t\t{\n\t\t\tIn:       []string{\"foo\", \"bar\"},\n\t\t\tContains: \"bar\",\n\t\t},\n\t\t{\n\t\t\tIn: []string{\"foo\", \"bar\"},\n\t\t\tContains: func(value string) bool {\n\t\t\t\treturn value == \"bar\"\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: f,\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: nil,\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: b,\n\t\t},\n\t\t{\n\t\t\tIn:       \"florent\",\n\t\t\tContains: \"rent\",\n\t\t},\n\t\t{\n\t\t\tIn:       \"florent\",\n\t\t\tContains: \"gilles\",\n\t\t},\n\t\t{\n\t\t\tIn:       map[int]*Foo{1: f, 3: c},\n\t\t\tContains: 1,\n\t\t},\n\t\t{\n\t\t\tIn:       map[int]*Foo{1: f, 3: c},\n\t\t\tContains: 2,\n\t\t},\n\t\t{\n\t\t\tIn: map[int]*Foo{1: f, 3: c},\n\t\t\tContains: func(key int, foo *Foo) bool {\n\t\t\t\treturn key == 3 && foo.FirstName == \"Harald\"\n\t\t\t},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Contains(tc.In, tc.Contains)\n\t\t\tactual := LazyChain(tc.In).Contains(tc.Contains)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyEvery(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn       interface{}\n\t\tContains []interface{}\n\t}{\n\t\t{\n\t\t\tIn:       []string{\"foo\", \"bar\", \"baz\"},\n\t\t\tContains: []interface{}{\"bar\", \"foo\"},\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: []interface{}{f, c},\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: []interface{}{nil},\n\t\t},\n\t\t{\n\t\t\tIn:       results,\n\t\t\tContains: []interface{}{f, b},\n\t\t},\n\t\t{\n\t\t\tIn:       \"florent\",\n\t\t\tContains: []interface{}{\"rent\", \"flo\"},\n\t\t},\n\t\t{\n\t\t\tIn:       \"florent\",\n\t\t\tContains: []interface{}{\"rent\", \"gilles\"},\n\t\t},\n\t\t{\n\t\t\tIn:       map[int]*Foo{1: f, 3: c},\n\t\t\tContains: []interface{}{1, 3},\n\t\t},\n\t\t{\n\t\t\tIn:       map[int]*Foo{1: f, 3: c},\n\t\t\tContains: []interface{}{2, 3},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Every(tc.In, tc.Contains...)\n\t\t\tactual := LazyChain(tc.In).Every(tc.Contains...)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyFind(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn        interface{}\n\t\tPredicate interface{}\n\t}{\n\t\t{\n\t\t\tIn:        []int{1, 2, 3, 4},\n\t\t\tPredicate: func(x int) bool { return x%2 == 0 },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Find(tc.In, tc.Predicate)\n\t\t\tactual := LazyChain(tc.In).Find(tc.Predicate)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyFind_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tLazyChain := LazyChain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\n\tresult := LazyChain.Find(func(x *foo) bool {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\treturn x.bar == \"foo\"\n\t})\n\tis.Nil(result)\n\n\t// Side effect: in and LazyChain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestLazyForEach(t *testing.T) {\n\tvar expectedAcc, actualAcc []interface{}\n\n\ttestCases := []struct {\n\t\tIn                interface{}\n\t\tFunkIterator      interface{}\n\t\tLazyChainIterator interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{1, 2, 3, 4},\n\t\t\tFunkIterator: func(x int) {\n\t\t\t\tif x%2 == 0 {\n\t\t\t\t\texpectedAcc = append(expectedAcc, x)\n\t\t\t\t}\n\t\t\t},\n\t\t\tLazyChainIterator: func(x int) {\n\t\t\t\tif x%2 == 0 {\n\t\t\t\t\tactualAcc = append(actualAcc, x)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:                map[int]string{1: \"Florent\", 2: \"Gilles\"},\n\t\t\tFunkIterator:      func(k int, v string) { expectedAcc = append(expectedAcc, fmt.Sprintf(\"%d:%s\", k, v)) },\n\t\t\tLazyChainIterator: func(k int, v string) { actualAcc = append(actualAcc, fmt.Sprintf(\"%d:%s\", k, v)) },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\texpectedAcc = []interface{}{}\n\t\t\tactualAcc = []interface{}{}\n\n\t\t\tForEach(tc.In, tc.FunkIterator)\n\t\t\tLazyChain(tc.In).ForEach(tc.LazyChainIterator)\n\n\t\t\tis.ElementsMatch(expectedAcc, actualAcc)\n\t\t})\n\t}\n}\n\nfunc TestLazyForEach_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tvar out []*foo\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tLazyChain := LazyChain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\n\tLazyChain.ForEach(func(x *foo) {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\tout = append(out, x)\n\t})\n\tis.Equal([]*foo{{\"__foo__\"}, {\"__bar__\"}}, out)\n\n\t// Side effect: in and LazyChain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestLazyForEachRight(t *testing.T) {\n\tvar expectedAcc, actualAcc []interface{}\n\n\ttestCases := []struct {\n\t\tIn                interface{}\n\t\tFunkIterator      interface{}\n\t\tLazyChainIterator interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{1, 2, 3, 4},\n\t\t\tFunkIterator: func(x int) {\n\t\t\t\tif x%2 == 0 {\n\t\t\t\t\texpectedAcc = append(expectedAcc, x)\n\t\t\t\t}\n\t\t\t},\n\t\t\tLazyChainIterator: func(x int) {\n\t\t\t\tif x%2 == 0 {\n\t\t\t\t\tactualAcc = append(actualAcc, x)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:                map[int]string{1: \"Florent\", 2: \"Gilles\"},\n\t\t\tFunkIterator:      func(k int, v string) { expectedAcc = append(expectedAcc, fmt.Sprintf(\"%d:%s\", k, v)) },\n\t\t\tLazyChainIterator: func(k int, v string) { actualAcc = append(actualAcc, fmt.Sprintf(\"%d:%s\", k, v)) },\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\texpectedAcc = []interface{}{}\n\t\t\tactualAcc = []interface{}{}\n\n\t\t\tForEachRight(tc.In, tc.FunkIterator)\n\t\t\tLazyChain(tc.In).ForEachRight(tc.LazyChainIterator)\n\n\t\t\tis.ElementsMatch(expectedAcc, actualAcc)\n\t\t})\n\t}\n}\n\nfunc TestLazyForEachRight_SideEffect(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar string\n\t}\n\tvar out []*foo\n\tin := []*foo{{\"foo\"}, {\"bar\"}}\n\n\tLazyChain := LazyChain(in)\n\tis.Equal([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\n\tLazyChain.ForEachRight(func(x *foo) {\n\t\tx.bar = \"__\" + x.bar + \"__\"\n\t\tout = append(out, x)\n\t})\n\tis.Equal([]*foo{{\"__bar__\"}, {\"__foo__\"}}, out)\n\n\t// Side effect: in and LazyChain.Value modified\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, LazyChain.Value())\n\tis.NotEqual([]*foo{{\"foo\"}, {\"bar\"}}, in)\n}\n\nfunc TestLazyHead(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{1, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Head(tc.In)\n\t\t\tactual := LazyChain(tc.In).Head()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyKeys(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: map[string]int{\"one\": 1, \"two\": 2}},\n\t\t{In: &map[string]int{\"one\": 1, \"two\": 2}},\n\t\t{In: map[int]complex128{5: 1 + 8i, 3: 2}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Keys(tc.In)\n\t\t\tactual := LazyChain(tc.In).Keys()\n\n\t\t\tis.ElementsMatch(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyIndexOf(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn   interface{}\n\t\tItem interface{}\n\t}{\n\t\t{\n\t\t\tIn:   []string{\"foo\", \"bar\"},\n\t\t\tItem: \"bar\",\n\t\t},\n\t\t{\n\t\t\tIn: []string{\"foo\", \"bar\"},\n\t\t\tItem: func(value string) bool {\n\t\t\t\treturn value == \"bar\"\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:   results,\n\t\t\tItem: f,\n\t\t},\n\t\t{\n\t\t\tIn:   results,\n\t\t\tItem: b,\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := IndexOf(tc.In, tc.Item)\n\t\t\tactual := LazyChain(tc.In).IndexOf(tc.Item)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyIsEmpty(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: \"\"},\n\t\t{In: [0]interface{}{}},\n\t\t{In: []interface{}(nil)},\n\t\t{In: map[interface{}]interface{}(nil)},\n\t\t{In: \"s\"},\n\t\t{In: [1]interface{}{1}},\n\t\t{In: []interface{}{}},\n\t\t{In: map[interface{}]interface{}{}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := IsEmpty(tc.In)\n\t\t\tactual := LazyChain(tc.In).IsEmpty()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyLast(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{\n\t\t\tIn: []int{1, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Last(tc.In)\n\t\t\tactual := LazyChain(tc.In).Last()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyLastIndexOf(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn   interface{}\n\t\tItem interface{}\n\t}{\n\t\t{\n\t\t\tIn:   []string{\"foo\", \"bar\", \"bar\"},\n\t\t\tItem: \"bar\",\n\t\t},\n\t\t{\n\t\t\tIn: []string{\"foo\", \"bar\", \"bar\"},\n\t\t\tItem: func(value string) bool {\n\t\t\t\treturn value == \"bar\"\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tIn:   []int{1, 2, 2, 3},\n\t\t\tItem: 2,\n\t\t},\n\t\t{\n\t\t\tIn:   []int{1, 2, 2, 3},\n\t\t\tItem: 4,\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := LastIndexOf(tc.In, tc.Item)\n\t\t\tactual := LazyChain(tc.In).LastIndexOf(tc.Item)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyNotEmpty(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: \"\"},\n\t\t{In: [0]interface{}{}},\n\t\t{In: []interface{}(nil)},\n\t\t{In: map[interface{}]interface{}(nil)},\n\t\t{In: \"s\"},\n\t\t{In: [1]interface{}{1}},\n\t\t{In: []interface{}{}},\n\t\t{In: map[interface{}]interface{}{}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := NotEmpty(tc.In)\n\t\t\tactual := LazyChain(tc.In).NotEmpty()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyProduct(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []int{0, 1, 2, 3}},\n\t\t{In: &[]int{0, 1, 2, 3}},\n\t\t{In: []interface{}{1, 2, 3, 0.5}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Product(tc.In)\n\t\t\tactual := LazyChain(tc.In).Product()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyReduce(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn         interface{}\n\t\tReduceFunc interface{}\n\t\tAcc        interface{}\n\t}{\n\t\t{\n\t\t\tIn:         []int{1, 2, 3, 4},\n\t\t\tReduceFunc: func(acc, elem int) int { return acc + elem },\n\t\t\tAcc:        0,\n\t\t},\n\t\t{\n\t\t\tIn:         &[]int16{1, 2, 3, 4},\n\t\t\tReduceFunc: '+',\n\t\t\tAcc:        5,\n\t\t},\n\t\t{\n\t\t\tIn:         []float64{1.1, 2.2, 3.3},\n\t\t\tReduceFunc: '+',\n\t\t\tAcc:        0,\n\t\t},\n\t\t{\n\t\t\tIn:         &[]int{1, 2, 3, 5},\n\t\t\tReduceFunc: func(acc int8, elem int16) int32 { return int32(acc) * int32(elem) },\n\t\t\tAcc:        1,\n\t\t},\n\t\t{\n\t\t\tIn:         []interface{}{1, 2, 3.3, 4},\n\t\t\tReduceFunc: '*',\n\t\t\tAcc:        1,\n\t\t},\n\t\t{\n\t\t\tIn:         []string{\"1\", \"2\", \"3\", \"4\"},\n\t\t\tReduceFunc: func(acc string, elem string) string { return acc + elem },\n\t\t\tAcc:        \"\",\n\t\t},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Reduce(tc.In, tc.ReduceFunc, tc.Acc)\n\t\t\tactual := LazyChain(tc.In).Reduce(tc.ReduceFunc, tc.Acc)\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazySum(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []int{0, 1, 2, 3}},\n\t\t{In: &[]int{0, 1, 2, 3}},\n\t\t{In: []interface{}{1, 2, 3, 0.5}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Sum(tc.In)\n\t\t\tactual := LazyChain(tc.In).Sum()\n\n\t\t\tis.Equal(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyType(t *testing.T) {\n\ttype key string\n\tvar x key\n\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []string{}},\n\t\t{In: []int{}},\n\t\t{In: []bool{}},\n\t\t{In: []interface{}{}},\n\t\t{In: &[]interface{}{}},\n\t\t{In: map[int]string{}},\n\t\t{In: map[complex128]int{}},\n\t\t{In: map[string]string{}},\n\t\t{In: map[int]interface{}{}},\n\t\t{In: map[key]interface{}{}},\n\t\t{In: &map[key]interface{}{}},\n\t\t{In: \"\"},\n\t\t{In: &x},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := LazyChain(tc.In).Type()\n\n\t\t\tis.Equal(reflect.TypeOf(tc.In), actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: []int{0, 1, 2, 3}},\n\t\t{In: []string{\"foo\", \"bar\"}},\n\t\t{In: &[]string{\"foo\", \"bar\"}},\n\t\t{In: map[int]string{1: \"foo\", 2: \"bar\"}},\n\t\t{In: map[string]string{\"foo\": \"foo\", \"bar\": \"bar\"}},\n\t\t{In: &map[string]string{\"foo\": \"foo\", \"bar\": \"bar\"}},\n\t\t{In: \"foo\"},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := LazyChain(tc.In).Value()\n\n\t\t\tis.Equal(tc.In, actual)\n\t\t})\n\t}\n}\n\nfunc TestLazyValues(t *testing.T) {\n\ttestCases := []struct {\n\t\tIn interface{}\n\t}{\n\t\t{In: map[string]int{\"one\": 1, \"two\": 2}},\n\t\t{In: &map[string]int{\"one\": 1, \"two\": 2}},\n\t\t{In: map[int]complex128{5: 1 + 8i, 3: 2}},\n\t}\n\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\texpected := Values(tc.In)\n\t\t\tactual := LazyChain(tc.In).Values()\n\n\t\t\tis.ElementsMatch(expected, actual)\n\t\t})\n\t}\n}\n\nfunc TestComplexLazyChaining(t *testing.T) {\n\tis := assert.New(t)\n\n\tin := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tlazy := LazyChain(in)\n\tlazyWith := LazyChainWith(func() interface{} { return in })\n\n\t// Without builder\n\tfa := Filter(in, func(x int) bool { return x%2 == 0 })\n\tfb := Map(fa, func(x int) int { return x * 2 })\n\tfc := Reverse(fa)\n\n\t// With lazy chaining\n\tla := lazy.Filter(func(x int) bool { return x%2 == 0 })\n\tlb := la.Map(func(x int) int { return x * 2 })\n\tlc := la.Reverse()\n\n\t// With lazy chaining with generator\n\tlwa := lazyWith.Filter(func(x int) bool { return x%2 == 0 })\n\tlwb := lwa.Map(func(x int) int { return x * 2 })\n\tlwc := lwa.Reverse()\n\n\tis.Equal(fa, la.Value())\n\tis.Equal(fb, lb.Value())\n\tis.Equal(fc, lc.Value())\n\tis.Equal(fa, lwa.Value())\n\tis.Equal(fb, lwb.Value())\n\tis.Equal(fc, lwc.Value())\n\n\tis.Equal(Contains(fb, 2), lb.Contains(2))\n\tis.Equal(Contains(fb, 4), lb.Contains(4))\n\tis.Equal(Sum(fb), lb.Sum())\n\tis.Equal(Head(fb), lb.Head())\n\tis.Equal(Head(fc), lc.Head())\n\tis.Equal(Contains(fb, 2), lwb.Contains(2))\n\tis.Equal(Contains(fb, 4), lwb.Contains(4))\n\tis.Equal(Sum(fb), lwb.Sum())\n\tis.Equal(Head(fb), lwb.Head())\n\tis.Equal(Head(fc), lwc.Head())\n}\n"
        },
        {
          "name": "map.go",
          "type": "blob",
          "size": 1.5595703125,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Keys creates an array of the own enumerable map keys or struct field names.\nfunc Keys(out interface{}) interface{} {\n\tvalue := redirectValue(reflect.ValueOf(out))\n\tvalueType := value.Type()\n\n\tif value.Kind() == reflect.Map {\n\t\tkeys := value.MapKeys()\n\n\t\tlength := len(keys)\n\n\t\tresultSlice := reflect.MakeSlice(reflect.SliceOf(valueType.Key()), length, length)\n\n\t\tfor i, key := range keys {\n\t\t\tresultSlice.Index(i).Set(key)\n\t\t}\n\n\t\treturn resultSlice.Interface()\n\t}\n\n\tif value.Kind() == reflect.Struct {\n\t\tlength := value.NumField()\n\n\t\tresultSlice := make([]string, length)\n\n\t\tfor i := 0; i < length; i++ {\n\t\t\tresultSlice[i] = valueType.Field(i).Name\n\t\t}\n\n\t\treturn resultSlice\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Keys\", valueType.String()))\n}\n\n// Values creates an array of the own enumerable map values or struct field values.\nfunc Values(out interface{}) interface{} {\n\tvalue := redirectValue(reflect.ValueOf(out))\n\tvalueType := value.Type()\n\n\tif value.Kind() == reflect.Map {\n\t\tkeys := value.MapKeys()\n\n\t\tlength := len(keys)\n\n\t\tresultSlice := reflect.MakeSlice(reflect.SliceOf(valueType.Elem()), length, length)\n\n\t\tfor i, key := range keys {\n\t\t\tresultSlice.Index(i).Set(value.MapIndex(key))\n\t\t}\n\n\t\treturn resultSlice.Interface()\n\t}\n\n\tif value.Kind() == reflect.Struct {\n\t\tlength := value.NumField()\n\n\t\tresultSlice := make([]interface{}, length)\n\n\t\tfor i := 0; i < length; i++ {\n\t\t\tresultSlice[i] = value.Field(i).Interface()\n\t\t}\n\n\t\treturn resultSlice\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Keys\", valueType.String()))\n}\n"
        },
        {
          "name": "map_test.go",
          "type": "blob",
          "size": 0.7392578125,
          "content": "package funk\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestKeys(t *testing.T) {\n\tis := assert.New(t)\n\n\tresults := Keys(map[string]int{\"one\": 1, \"two\": 2}).([]string)\n\tsort.Strings(results)\n\n\tis.Equal(results, []string{\"one\", \"two\"})\n\n\tfields := Keys(foo).([]string)\n\n\tsort.Strings(fields)\n\n\tis.Equal(fields, []string{\"Age\", \"Bar\", \"BarInterface\", \"BarPointer\", \"Bars\", \"EmptyValue\", \"FirstName\", \"GeneralInterface\", \"ID\", \"LastName\", \"ZeroBoolValue\", \"ZeroIntPtrValue\", \"ZeroIntValue\"})\n}\n\nfunc TestValues(t *testing.T) {\n\tis := assert.New(t)\n\n\tresults := Values(map[string]int{\"one\": 1, \"two\": 2}).([]int)\n\tsort.Ints(results)\n\n\tis.Equal(results, []int{1, 2})\n\n\tvalues := Values(foo).([]interface{})\n\n\tis.Len(values, 13)\n}\n"
        },
        {
          "name": "max.go",
          "type": "blob",
          "size": 3.5146484375,
          "content": "package funk\n\nimport \"strings\"\n\n// MaxInt validates the input, compares the elements and returns the maximum element in an array/slice.\n// It accepts []int\n// It returns int\nfunc MaxInt(i []int) int {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar max int\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmax = item\n\t\t\tcontinue\n\t\t}\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t}\n\treturn max\n}\n\n// MaxInt8 validates the input, compares the elements and returns the maximum element in an array/slice.\n// It accepts []int8\n// It returns int8\nfunc MaxInt8(i []int8) int8 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar max int8\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmax = item\n\t\t\tcontinue\n\t\t}\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t}\n\treturn max\n}\n\n// MaxInt16 validates the input, compares the elements and returns the maximum element in an array/slice.\n// It accepts []int16\n// It returns int16\nfunc MaxInt16(i []int16) int16 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar max int16\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmax = item\n\t\t\tcontinue\n\t\t}\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t}\n\treturn max\n}\n\n// MaxInt32 validates the input, compares the elements and returns the maximum element in an array/slice.\n// It accepts []int32\n// It returns int32\nfunc MaxInt32(i []int32) int32 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar max int32\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmax = item\n\t\t\tcontinue\n\t\t}\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t}\n\treturn max\n}\n\n// MaxInt64 validates the input, compares the elements and returns the maximum element in an array/slice.\n// It accepts []int64\n// It returns int64\nfunc MaxInt64(i []int64) int64 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar max int64\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmax = item\n\t\t\tcontinue\n\t\t}\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t}\n\treturn max\n}\n\n// MaxFloat32 validates the input, compares the elements and returns the maximum element in an array/slice.\n// It accepts []float32\n// It returns float32\nfunc MaxFloat32(i []float32) float32 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar max float32\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmax = item\n\t\t\tcontinue\n\t\t}\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t}\n\treturn max\n}\n\n// MaxFloat64 validates the input, compares the elements and returns the maximum element in an array/slice.\n// It accepts []float64\n// It returns float64\nfunc MaxFloat64(i []float64) float64 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar max float64\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmax = item\n\t\t\tcontinue\n\t\t}\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t}\n\treturn max\n}\n\n// MaxString validates the input, compares the elements and returns the maximum element in an array/slice.\n// It accepts []string\n// It returns string\nfunc MaxString(i []string) string {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar max string\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmax = item\n\t\t\tcontinue\n\t\t}\n\t\tmax = compareStringsMax(max, item)\n\t}\n\treturn max\n}\n\n// compareStrings uses the strings.Compare method to compare two strings, and returns the greater one.\nfunc compareStringsMax(max, current string) string {\n\tr := strings.Compare(strings.ToLower(max), strings.ToLower(current))\n\tif r > 0 {\n\t\treturn max\n\t}\n\treturn current\n}\n"
        },
        {
          "name": "max_test.go",
          "type": "blob",
          "size": 2.4560546875,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMaxWithArrayNumericInput(t *testing.T) {\n\t//Test Data\n\td1 := []int{8, 3, 4, 44, 0}\n\tn1 := []int{}\n\td2 := []int8{3, 3, 5, 9, 1}\n\tn2 := []int8{}\n\td3 := []int16{4, 5, 4, 33, 2}\n\tn3 := []int16{}\n\td4 := []int32{5, 3, 21, 15, 3}\n\tn4 := []int32{}\n\td5 := []int64{9, 3, 9, 1, 2}\n\tn5 := []int64{}\n\t//Calls\n\tr1 := MaxInt(d1)\n\tr2 := MaxInt8(d2)\n\tr3 := MaxInt16(d3)\n\tr4 := MaxInt32(d4)\n\tr5 := MaxInt64(d5)\n\t// Assertions\n\tassert.Equal(t, int(44), r1, \"It should return the max value in array\")\n\tassert.Panics(t, func() { MaxInt(n1) }, \"It should panic\")\n\tassert.Equal(t, int8(9), r2, \"It should return the max value in array\")\n\tassert.Panics(t, func() { MaxInt8(n2) }, \"It should panic\")\n\tassert.Equal(t, int16(33), r3, \"It should return the max value in array\")\n\tassert.Panics(t, func() { MaxInt16(n3) }, \"It should panic\")\n\tassert.Equal(t, int32(21), r4, \"It should return the max value in array\")\n\tassert.Panics(t, func() { MaxInt32(n4) }, \"It should panic\")\n\tassert.Equal(t, int64(9), r5, \"It should return the max value in array\")\n\tassert.Panics(t, func() { MaxInt64(n5) }, \"It should panic\")\n\n}\n\nfunc TestMaxWithArrayFloatInput(t *testing.T) {\n\t//Test Data\n\td1 := []float64{2, 38.3, 4, 4.4, 4}\n\tn1 := []float64{}\n\td2 := []float32{2.9, 1.3, 4.23, 4.4, 7.7}\n\tn2 := []float32{}\n\t//Calls\n\tr1 := MaxFloat64(d1)\n\tr2 := MaxFloat32(d2)\n\t// Assertions\n\tassert.Equal(t, float64(38.3), r1, \"It should return the max value in array\")\n\tassert.Panics(t, func() { MaxFloat64(n1) }, \"It should panic\")\n\tassert.Equal(t, float32(7.7), r2, \"It should return the max value in array\")\n\tassert.Panics(t, func() { MaxFloat32(n2) }, \"It should panic\")\n}\n\nfunc TestMaxWithArrayInputWithStrings(t *testing.T) {\n\t//Test Data\n\td1 := []string{\"abc\", \"abd\", \"cbd\"}\n\td2 := []string{\"abc\", \"abd\", \"abe\"}\n\td3 := []string{\"abc\", \"foo\", \" \"}\n\td4 := []string{\"abc\", \"abc\", \"aaa\"}\n\tn1 := []string{}\n\t//Calls\n\tr1 := MaxString(d1)\n\tr2 := MaxString(d2)\n\tr3 := MaxString(d3)\n\tr4 := MaxString(d4)\n\t// Assertions\n\tassert.Equal(t, \"cbd\", r1, \"It should print cbd because its first char is max in the list\")\n\tassert.Equal(t, \"abe\", r2, \"It should print abe because its first different char is max in the list\")\n\tassert.Equal(t, \"foo\", r3, \"It should print foo because its first different char is max in the list\")\n\tassert.Equal(t, \"abc\", r4, \"It should print abc because its first different char is max in the list\")\n\tassert.Panics(t, func() { MaxString(n1) }, \"It should panic\")\n}\n"
        },
        {
          "name": "min.go",
          "type": "blob",
          "size": 3.4140625,
          "content": "package funk\n\nimport \"strings\"\n\n// MinInt validates the input, compares the elements and returns the minimum element in an array/slice.\n// It accepts []int\n// It returns int\nfunc MinInt(i []int) int {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar min int\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmin = item\n\t\t\tcontinue\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\treturn min\n}\n\n// MinInt8 validates the input, compares the elements and returns the minimum element in an array/slice.\n// It accepts []int8\n// It returns int8\nfunc MinInt8(i []int8) int8 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar min int8\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmin = item\n\t\t\tcontinue\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\treturn min\n}\n\n// MinInt16 validates the input, compares the elements and returns the minimum element in an array/slice.\n// It accepts []int16\n// It returns int16\nfunc MinInt16(i []int16) int16 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar min int16\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmin = item\n\t\t\tcontinue\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\treturn min\n}\n\n// MinInt32 validates the input, compares the elements and returns the minimum element in an array/slice.\n// It accepts []int32\n// It returns int32\nfunc MinInt32(i []int32) int32 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar min int32\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmin = item\n\t\t\tcontinue\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\treturn min\n}\n\n// MinInt64 validates the input, compares the elements and returns the minimum element in an array/slice.\n// It accepts []int64\n// It returns int64\nfunc MinInt64(i []int64) int64 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar min int64\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmin = item\n\t\t\tcontinue\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\treturn min\n}\n\n// MinFloat32 validates the input, compares the elements and returns the minimum element in an array/slice.\n// It accepts []float32\n// It returns float32\nfunc MinFloat32(i []float32) float32 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar min float32\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmin = item\n\t\t\tcontinue\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\treturn min\n}\n\n// MinFloat64 validates the input, compares the elements and returns the minimum element in an array/slice.\n// It accepts []float64\n// It returns float64\nfunc MinFloat64(i []float64) float64 {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar min float64\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmin = item\n\t\t\tcontinue\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\treturn min\n}\n\n// MinString validates the input, compares the elements and returns the minimum element in an array/slice.\n// It accepts []string\n// It returns string\nfunc MinString(i []string) string {\n\tif len(i) == 0 {\n\t\tpanic(\"arg is an empty array/slice\")\n\t}\n\tvar min string\n\tfor idx := 0; idx < len(i); idx++ {\n\t\titem := i[idx]\n\t\tif idx == 0 {\n\t\t\tmin = item\n\t\t\tcontinue\n\t\t}\n\t\tmin = compareStringsMin(min, item)\n\t}\n\treturn min\n}\n\nfunc compareStringsMin(min, current string) string {\n\tr := strings.Compare(strings.ToLower(min), strings.ToLower(current))\n\tif r < 0 {\n\t\treturn min\n\t}\n\treturn current\n}\n"
        },
        {
          "name": "min_test.go",
          "type": "blob",
          "size": 2.4482421875,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMinWithArrayNumericInput(t *testing.T) {\n\t//Test Data\n\td1 := []int{8, 3, 4, 44, 0}\n\tn1 := []int{}\n\td2 := []int8{3, 3, 5, 9, 1}\n\tn2 := []int8{}\n\td3 := []int16{4, 5, 4, 33, 2}\n\tn3 := []int16{}\n\td4 := []int32{5, 3, 21, 15, 3}\n\tn4 := []int32{}\n\td5 := []int64{9, 3, 9, 1, 2}\n\tn5 := []int64{}\n\t//Calls\n\tr1 := MinInt(d1)\n\tr2 := MinInt8(d2)\n\tr3 := MinInt16(d3)\n\tr4 := MinInt32(d4)\n\tr5 := MinInt64(d5)\n\t// Assertions\n\tassert.Equal(t, int(0), r1, \"It should return the min value in array\")\n\tassert.Panics(t, func() { MinInt(n1) }, \"It should panic\")\n\tassert.Equal(t, int8(1), r2, \"It should return the min value in array\")\n\tassert.Panics(t, func() { MinInt8(n2) }, \"It should panic\")\n\tassert.Equal(t, int16(2), r3, \"It should return the min value in array\")\n\tassert.Panics(t, func() { MinInt16(n3) }, \"It should panic\")\n\tassert.Equal(t, int32(3), r4, \"It should return the min value in array\")\n\tassert.Panics(t, func() { MinInt32(n4) }, \"It should panic\")\n\tassert.Equal(t, int64(1), r5, \"It should return the min value in array\")\n\tassert.Panics(t, func() { MinInt64(n5) }, \"It should panic\")\n\n}\n\nfunc TestMinWithArrayFloatInput(t *testing.T) {\n\t//Test Data\n\td1 := []float64{2, 38.3, 4, 4.4, 4}\n\tn1 := []float64{}\n\td2 := []float32{2.9, 1.3, 4.23, 4.4, 7.7}\n\tn2 := []float32{}\n\t//Calls\n\tr1 := MinFloat64(d1)\n\tr2 := MinFloat32(d2)\n\t// Assertions\n\tassert.Equal(t, float64(2), r1, \"It should return the min value in array\")\n\tassert.Panics(t, func() { MinFloat64(n1) }, \"It should panic\")\n\tassert.Equal(t, float32(1.3), r2, \"It should return the min value in array\")\n\tassert.Panics(t, func() { MinFloat32(n2) }, \"It should panic\")\n}\n\nfunc TestMinWithArrayInputWithStrings(t *testing.T) {\n\t//Test Data\n\td1 := []string{\"abc\", \"abd\", \"cbd\"}\n\td2 := []string{\"abc\", \"abd\", \"abe\"}\n\td3 := []string{\"abc\", \"foo\", \" \"}\n\td4 := []string{\"abc\", \"abc\", \"aaa\"}\n\tn1 := []string{}\n\t//Calls\n\tr1 := MinString(d1)\n\tr2 := MinString(d2)\n\tr3 := MinString(d3)\n\tr4 := MinString(d4)\n\t// Assertions\n\tassert.Equal(t, \"abc\", r1, \"It should print cbd because its first char is min in the list\")\n\tassert.Equal(t, \"abc\", r2, \"It should print abe because its first different char is min in the list\")\n\tassert.Equal(t, \" \", r3, \"It should print foo because its first different char is min in the list\")\n\tassert.Equal(t, \"aaa\", r4, \"It should print abc because its first different char is min in the list\")\n\tassert.Panics(t, func() { MinString(n1) }, \"It should panic\")\n}\n"
        },
        {
          "name": "operation.go",
          "type": "blob",
          "size": 1.2265625,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc calculate(arr interface{}, name string, operation rune) float64 {\n\tvalue := redirectValue(reflect.ValueOf(arr))\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tlength := value.Len()\n\n\t\tif length == 0 {\n\t\t\treturn 0\n\t\t}\n\n\t\tresult := map[rune]float64{\n\t\t\t'+': 0.0,\n\t\t\t'*': 1,\n\t\t}[operation]\n\n\t\tfor i := 0; i < length; i++ {\n\t\t\telem := redirectValue(value.Index(i)).Interface()\n\n\t\t\tvar value float64\n\t\t\tswitch e := elem.(type) {\n\t\t\tcase int:\n\t\t\t\tvalue = float64(e)\n\t\t\tcase int8:\n\t\t\t\tvalue = float64(e)\n\t\t\tcase int16:\n\t\t\t\tvalue = float64(e)\n\t\t\tcase int32:\n\t\t\t\tvalue = float64(e)\n\t\t\tcase int64:\n\t\t\t\tvalue = float64(e)\n\t\t\tcase float32:\n\t\t\t\tvalue = float64(e)\n\t\t\tcase float64:\n\t\t\t\tvalue = e\n\t\t\t}\n\n\t\t\tswitch operation {\n\t\t\tcase '+':\n\t\t\t\tresult += value\n\t\t\tcase '*':\n\t\t\t\tresult *= value\n\t\t\t}\n\t\t}\n\n\t\treturn result\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by %s\", valueType.String(), name))\n}\n\n// Sum computes the sum of the values in array.\nfunc Sum(arr interface{}) float64 {\n\treturn calculate(arr, \"Sum\", '+')\n}\n\n// Product computes the product of the values in array.\nfunc Product(arr interface{}) float64 {\n\treturn calculate(arr, \"Product\", '*')\n}\n"
        },
        {
          "name": "operation_test.go",
          "type": "blob",
          "size": 0.435546875,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSum(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Sum([]int{1, 2, 3}), 6.0)\n\tis.Equal(Sum(&[]int{1, 2, 3}), 6.0)\n\tis.Equal(Sum([]interface{}{1, 2, 3, 0.5}), 6.5)\n}\n\nfunc TestProduct(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Product([]int{2, 3, 4}), 24.0)\n\tis.Equal(Product(&[]int{2, 3, 4}), 24.0)\n\tis.Equal(Product([]interface{}{2, 3, 4, 0.5}), 12.0)\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 0.3525390625,
          "content": "package funk\n\ntype options struct {\n\tallowZero bool\n}\n\ntype option func(*options)\n\nfunc newOptions(values ...option) *options {\n\topts := &options{\n\t\tallowZero: false,\n\t}\n\tfor _, o := range values {\n\t\to(opts)\n\t}\n\treturn opts\n}\n\n// WithAllowZero allows zero values.\nfunc WithAllowZero() func(*options) {\n\treturn func(opts *options) {\n\t\topts.allowZero = true\n\t}\n}\n"
        },
        {
          "name": "permutation.go",
          "type": "blob",
          "size": 0.484375,
          "content": "package funk\n\nimport \"errors\"\n\n// NextPermutation Implement next permutation,\n// which rearranges numbers into the lexicographically next greater permutation of numbers.\nfunc NextPermutation(nums []int) error {\n\tn := len(nums)\n\tif n == 0 {\n\t\treturn errors.New(\"nums is empty\")\n\t}\n\n\ti := n - 2\n\n\tfor i >= 0 && nums[i] >= nums[i+1] {\n\t\ti--\n\t}\n\n\tif i >= 0 {\n\t\tj := n - 1\n\t\tfor j >= 0 && nums[i] >= nums[j] {\n\t\t\tj--\n\t\t}\n\t\tnums[i], nums[j] = nums[j], nums[i]\n\t}\n\n\tReverseInt(nums[i+1:])\n\treturn nil\n}\n"
        },
        {
          "name": "permutation_test.go",
          "type": "blob",
          "size": 0.5458984375,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestNextPermutation(t *testing.T) {\n\ttype args struct {\n\t\tnums []int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"case1\",\n\t\t\targs: args{\n\t\t\t\tnums: []int{1, 2, 3},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := NextPermutation(tt.args.nums); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"NextPermutation() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t} else {\n\t\t\t\tfmt.Println(tt.args.nums)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "predicate.go",
          "type": "blob",
          "size": 1.4501953125,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n)\n\n// predicatesImpl contains the common implementation of AnyPredicates and AllPredicates.\nfunc predicatesImpl(value interface{}, wantedAnswer bool, predicates interface{}) bool {\n\tif !IsCollection(predicates) {\n\t\tpanic(\"Predicates parameter must be an iteratee\")\n\t}\n\n\tpredicatesValue := reflect.ValueOf(predicates)\n\tinputValue := reflect.ValueOf(value)\n\n\tfor i := 0; i < predicatesValue.Len(); i++ {\n\t\tfuncValue := predicatesValue.Index(i)\n\t\tif !IsFunction(funcValue.Interface()) {\n\t\t\tpanic(\"Got non function as predicate\")\n\t\t}\n\n\t\tfuncType := funcValue.Type()\n\t\tif !IsPredicate(funcValue.Interface()) {\n\t\t\tpanic(\"Predicate function must have 1 parameter and must return boolean\")\n\t\t}\n\n\t\tif !inputValue.Type().ConvertibleTo(funcType.In(0)) {\n\t\t\tpanic(\"Given value is not compatible with type of parameter for the predicate.\")\n\t\t}\n\t\tif result := funcValue.Call([]reflect.Value{inputValue}); wantedAnswer == result[0].Bool() {\n\t\t\treturn wantedAnswer\n\t\t}\n\t}\n\n\treturn !wantedAnswer\n}\n\n// AnyPredicates gets a value and a series of predicates, and return true if at least one of the predicates\n// is true.\nfunc AnyPredicates(value interface{}, predicates interface{}) bool {\n\treturn predicatesImpl(value, true, predicates)\n}\n\n// AllPredicates gets a value and a series of predicates, and return true if all of the predicates are true.\nfunc AllPredicates(value interface{}, predicates interface{}) bool {\n\treturn predicatesImpl(value, false, predicates)\n}\n"
        },
        {
          "name": "predicate_test.go",
          "type": "blob",
          "size": 4.12109375,
          "content": "package funk\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestAllPredicates(t *testing.T) {\n\ttype args struct {\n\t\tvalue      interface{}\n\t\tpredicates interface{}\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Sanity string predicates\",\n\t\t\targs: args{\n\t\t\t\tvalue: \"test\",\n\t\t\t\tpredicates: []func(string) bool{\n\t\t\t\t\tfunc(v string) bool { return strings.Contains(v, \"est\") },\n\t\t\t\t\tfunc(v string) bool { return len(v) < 10 },\n\t\t\t\t\tfunc(v string) bool { return len(v) > 2 },\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Sanity int predicates\",\n\t\t\targs: args{\n\t\t\t\tvalue: 4,\n\t\t\t\tpredicates: []func(int) bool{\n\t\t\t\t\tfunc(v int) bool { return v < 5 },\n\t\t\t\t\tfunc(v int) bool { return v > 2 },\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Failed predicate\",\n\t\t\targs: args{\n\t\t\t\tvalue: \"test\",\n\t\t\t\tpredicates: []func(string) bool{\n\t\t\t\t\tfunc(v string) bool { return strings.Contains(v, \"est\") },\n\t\t\t\t\tfunc(v string) bool { return len(v) > 10 },\n\t\t\t\t\tfunc(v string) bool { return len(v) > 2 },\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AllPredicates(tt.args.value, tt.args.predicates); got != tt.want {\n\t\t\t\tt.Errorf(\"AllPredicates() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAnyPredicates(t *testing.T) {\n\ttype args struct {\n\t\tvalue      interface{}\n\t\tpredicates interface{}\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Sanity string predicates\",\n\t\t\targs: args{\n\t\t\t\tvalue: \"test\",\n\t\t\t\tpredicates: []func(string) bool{\n\t\t\t\t\tfunc(v string) bool { return strings.Contains(v, \"est\") },\n\t\t\t\t\tfunc(v string) bool { return len(v) > 10 },\n\t\t\t\t\tfunc(v string) bool { return len(v) < 2 },\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Sanity int predicates\",\n\t\t\targs: args{\n\t\t\t\tvalue: 4,\n\t\t\t\tpredicates: []func(int) bool{\n\t\t\t\t\tfunc(v int) bool { return v > 5 },\n\t\t\t\t\tfunc(v int) bool { return v > 2 },\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"All failed predicate\",\n\t\t\targs: args{\n\t\t\t\tvalue: \"test\",\n\t\t\t\tpredicates: []func(string) bool{\n\t\t\t\t\tfunc(v string) bool { return !strings.Contains(v, \"est\") },\n\t\t\t\t\tfunc(v string) bool { return len(v) > 10 },\n\t\t\t\t\tfunc(v string) bool { return len(v) < 2 },\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AnyPredicates(tt.args.value, tt.args.predicates); got != tt.want {\n\t\t\t\tt.Errorf(\"AnyPredicates() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPredicatesImplPanics(t *testing.T) {\n\ttype args struct {\n\t\tvalue        interface{}\n\t\twantedAnswer bool\n\t\tpredicates   interface{}\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t{\n\t\t\tname: \"predicates are not collection\",\n\t\t\targs: args{\n\t\t\t\tvalue:        nil,\n\t\t\t\twantedAnswer: false,\n\t\t\t\tpredicates:   nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"predicates are collection of strings\",\n\t\t\targs: args{\n\t\t\t\tvalue:        nil,\n\t\t\t\twantedAnswer: false,\n\t\t\t\tpredicates:   []string{\"hey\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"predicate has 2 out parameters\",\n\t\t\targs: args{\n\t\t\t\tvalue:        nil,\n\t\t\t\twantedAnswer: false,\n\t\t\t\tpredicates:   []func(string) (bool, error){ func(string) (bool, error){return true, nil}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"predicate has out parameter of type string\",\n\t\t\targs: args{\n\t\t\t\tvalue:        nil,\n\t\t\t\twantedAnswer: false,\n\t\t\t\tpredicates:   []func(string) string{ func(string) string{return \"\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"predicate has 2 in parameters\",\n\t\t\targs: args{\n\t\t\t\tvalue:        nil,\n\t\t\t\twantedAnswer: false,\n\t\t\t\tpredicates:   []func(string, bool) bool{ func(string, bool) bool{return true}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"predicate has 0 in parameters\",\n\t\t\targs: args{\n\t\t\t\tvalue:        nil,\n\t\t\t\twantedAnswer: false,\n\t\t\t\tpredicates:   []func() bool{ func() bool{return true}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"value is not convertible to in parameter\",\n\t\t\targs: args{\n\t\t\t\tvalue:        1,\n\t\t\t\twantedAnswer: false,\n\t\t\t\tpredicates:   []func(string) bool{ func(string) bool{return true}},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\trequire.Panics(t, func() {predicatesImpl(tt.args.value, tt.args.wantedAnswer, tt.args.predicates)})\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "presence.go",
          "type": "blob",
          "size": 4.75,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// Filter iterates over elements of collection, returning an array of\n// all elements predicate returns truthy for.\nfunc Filter(arr interface{}, predicate interface{}) interface{} {\n\tif !IsIteratee(arr) {\n\t\tpanic(\"First parameter must be an iteratee\")\n\t}\n\n\tif !IsFunction(predicate, 1, 1) {\n\t\tpanic(\"Second argument must be function\")\n\t}\n\n\tfuncValue := reflect.ValueOf(predicate)\n\n\tfuncType := funcValue.Type()\n\n\tif funcType.Out(0).Kind() != reflect.Bool {\n\t\tpanic(\"Return argument should be a boolean\")\n\t}\n\n\tarrValue := reflect.ValueOf(arr)\n\n\tarrType := arrValue.Type()\n\n\t// Get slice type corresponding to array type\n\tresultSliceType := reflect.SliceOf(arrType.Elem())\n\n\t// MakeSlice takes a slice kind type, and makes a slice.\n\tresultSlice := reflect.MakeSlice(resultSliceType, 0, 0)\n\n\tfor i := 0; i < arrValue.Len(); i++ {\n\t\telem := arrValue.Index(i)\n\n\t\tresult := funcValue.Call([]reflect.Value{elem})[0].Interface().(bool)\n\n\t\tif result {\n\t\t\tresultSlice = reflect.Append(resultSlice, elem)\n\t\t}\n\t}\n\n\treturn resultSlice.Interface()\n}\n\n// Find iterates over elements of collection, returning the first\n// element predicate returns truthy for.\nfunc Find(arr interface{}, predicate interface{}) interface{} {\n\t_, val := FindKey(arr, predicate)\n\treturn val\n}\n\n// Find iterates over elements of collection, returning the first\n// element of an array and random of a map which predicate returns truthy for.\nfunc FindKey(arr interface{}, predicate interface{}) (matchKey, matchEle interface{}) {\n\tif !IsIteratee(arr) {\n\t\tpanic(\"First parameter must be an iteratee\")\n\t}\n\n\tif !IsFunction(predicate, 1, 1) {\n\t\tpanic(\"Second argument must be function\")\n\t}\n\n\tfuncValue := reflect.ValueOf(predicate)\n\n\tfuncType := funcValue.Type()\n\n\tif funcType.Out(0).Kind() != reflect.Bool {\n\t\tpanic(\"Return argument should be a boolean\")\n\t}\n\n\tarrValue := reflect.ValueOf(arr)\n\tvar keyArrs []reflect.Value\n\n\tisMap := arrValue.Kind() == reflect.Map\n\tif isMap {\n\t\tkeyArrs = arrValue.MapKeys()\n\t}\n\tfor i := 0; i < arrValue.Len(); i++ {\n\t\tvar (\n\t\t\telem reflect.Value\n\t\t\tkey  reflect.Value\n\t\t)\n\t\tif isMap {\n\t\t\tkey = keyArrs[i]\n\t\t\telem = arrValue.MapIndex(key)\n\t\t} else {\n\t\t\tkey = reflect.ValueOf(i)\n\t\t\telem = arrValue.Index(i)\n\t\t}\n\n\t\tresult := funcValue.Call([]reflect.Value{elem})[0].Interface().(bool)\n\n\t\tif result {\n\t\t\treturn key.Interface(), elem.Interface()\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n\n// IndexOf gets the index at which the first occurrence of value is found in array or return -1\n// if the value cannot be found\nfunc IndexOf(in interface{}, elem interface{}) int {\n\tinValue := reflect.ValueOf(in)\n\n\telemValue := reflect.ValueOf(elem)\n\n\tinType := inValue.Type()\n\n\tif inType.Kind() == reflect.String {\n\t\treturn strings.Index(inValue.String(), elemValue.String())\n\t}\n\n\tif inType.Kind() == reflect.Slice {\n\t\tequalTo := equal(elem)\n\t\tfor i := 0; i < inValue.Len(); i++ {\n\t\t\tif equalTo(reflect.Value{}, inValue.Index(i)) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1\n}\n\n// LastIndexOf gets the index at which the last occurrence of value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOf(in interface{}, elem interface{}) int {\n\tinValue := reflect.ValueOf(in)\n\n\telemValue := reflect.ValueOf(elem)\n\n\tinType := inValue.Type()\n\n\tif inType.Kind() == reflect.String {\n\t\treturn strings.LastIndex(inValue.String(), elemValue.String())\n\t}\n\n\tif inType.Kind() == reflect.Slice {\n\t\tlength := inValue.Len()\n\n\t\tequalTo := equal(elem)\n\t\tfor i := length - 1; i >= 0; i-- {\n\t\t\tif equalTo(reflect.Value{}, inValue.Index(i)) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1\n}\n\n// Contains returns true if an element is present in a iteratee.\nfunc Contains(in interface{}, elem interface{}) bool {\n\tinValue := reflect.ValueOf(in)\n\telemValue := reflect.ValueOf(elem)\n\tinType := inValue.Type()\n\n\tswitch inType.Kind() {\n\tcase reflect.String:\n\t\treturn strings.Contains(inValue.String(), elemValue.String())\n\tcase reflect.Map:\n\t\tequalTo := equal(elem, true)\n\t\tfor _, key := range inValue.MapKeys() {\n\t\t\tif equalTo(key, inValue.MapIndex(key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase reflect.Slice, reflect.Array:\n\t\tequalTo := equal(elem)\n\t\tfor i := 0; i < inValue.Len(); i++ {\n\t\t\tif equalTo(reflect.Value{}, inValue.Index(i)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Type %s is not supported by Contains, supported types are String, Map, Slice, Array\", inType.String()))\n\t}\n\n\treturn false\n}\n\n// Every returns true if every element is present in a iteratee.\nfunc Every(in interface{}, elements ...interface{}) bool {\n\tfor _, elem := range elements {\n\t\tif !Contains(in, elem) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Some returns true if atleast one element is present in an iteratee.\nfunc Some(in interface{}, elements ...interface{}) bool {\n\tfor _, elem := range elements {\n\t\tif Contains(in, elem) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "presence_test.go",
          "type": "blob",
          "size": 3.611328125,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar f = &Foo{\n\tID:        1,\n\tFirstName: \"Dark\",\n\tLastName:  \"Vador\",\n\tAge:       30,\n\tBar: &Bar{\n\t\tName: \"Test\",\n\t},\n}\n\nvar b = &Foo{\n\tID:        2,\n\tFirstName: \"Florent\",\n\tLastName:  \"Messa\",\n\tAge:       28,\n}\nvar c = &Foo{\n\tID:        3,\n\tFirstName: \"Harald\",\n\tLastName:  \"Nordgren\",\n\tAge:       27,\n}\n\nvar results = []*Foo{f, c}\n\ntype Person struct {\n\tname string\n\tage  int\n}\n\nfunc TestContains(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(Contains([]string{\"foo\", \"bar\"}, \"bar\"))\n\tis.True(Contains([...]string{\"foo\", \"bar\"}, \"bar\"))\n\tis.Panics(func() { Contains(1, 2) })\n\n\tis.True(Contains(results, f))\n\tis.False(Contains(results, nil))\n\tis.False(Contains(results, b))\n\n\tis.True(Contains(\"florent\", \"rent\"))\n\tis.False(Contains(\"florent\", \"gilles\"))\n\n\tmapping := ToMap(results, \"ID\")\n\n\tis.True(Contains(mapping, 1))\n\tis.False(Contains(mapping, 2))\n\n\tis.False(Contains(mapping, func(key int, val *Foo) bool {\n\t\treturn key == 4\n\t}))\n\tis.True(Contains(mapping, func(key int, val *Foo) bool {\n\t\treturn key == 1\n\t}))\n\n\tis.False(Contains(mapping, func(_ int, val *Foo) bool {\n\t\treturn val.FirstName == \"NotPresent\"\n\t}))\n\tis.True(Contains(mapping, func(_ int, val *Foo) bool {\n\t\treturn val.FirstName == \"Harald\"\n\t}))\n}\n\nfunc TestEvery(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(Every([]string{\"foo\", \"bar\", \"baz\"}, \"bar\", \"foo\"))\n\n\tis.True(Every(results, f, c))\n\tis.False(Every(results, nil))\n\tis.False(Every(results, f, b))\n\n\tis.True(Every(\"florent\", \"rent\", \"flo\"))\n\tis.False(Every(\"florent\", \"rent\", \"gilles\"))\n\n\tmapping := ToMap(results, \"ID\")\n\n\tis.True(Every(mapping, 1, 3))\n\tis.False(Every(mapping, 2, 3))\n}\n\nfunc TestSome(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(Some([]string{\"foo\", \"bar\", \"baz\"}, \"foo\"))\n\tis.True(Some([]string{\"foo\", \"bar\", \"baz\"}, \"foo\", \"qux\"))\n\n\tis.True(Some(results, f))\n\tis.False(Some(results, b))\n\tis.False(Some(results, nil))\n\tis.True(Some(results, f, b))\n\n\tis.True(Some(\"zeeshan\", \"zee\", \"tam\"))\n\tis.False(Some(\"zeeshan\", \"zi\", \"tam\"))\n\n\tpersons := []Person{\n\t\t{\n\t\t\tname: \"Zeeshan\",\n\t\t\tage:  23,\n\t\t},\n\t\t{\n\t\t\tname: \"Bob\",\n\t\t\tage:  26,\n\t\t},\n\t}\n\n\tperson := Person{\"Zeeshan\", 23}\n\tperson2 := Person{\"Alice\", 23}\n\tperson3 := Person{\"John\", 26}\n\n\tis.True(Some(persons, person, person2))\n\tis.False(Some(persons, person2, person3))\n\n\tmapping := ToMap(results, \"ID\")\n\n\tis.True(Some(mapping, 1, 2))\n\tis.True(Some(mapping, 4, 1))\n\tis.False(Some(mapping, 4, 5))\n}\n\nfunc TestIndexOf(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(IndexOf([]string{\"foo\", \"bar\"}, \"bar\"), 1)\n\tis.Equal(IndexOf([]string{\"foo\", \"bar\"}, func(value string) bool {\n\t\treturn value == \"bar\"\n\t}), 1)\n\n\tis.Equal(IndexOf(results, f), 0)\n\tis.Equal(IndexOf(results, b), -1)\n}\n\nfunc TestLastIndexOf(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(LastIndexOf([]string{\"foo\", \"bar\", \"bar\"}, \"bar\"), 2)\n\tis.Equal(LastIndexOf([]string{\"foo\", \"bar\", \"bar\"}, func(value string) bool {\n\t\treturn value == \"bar\"\n\t}), 2)\n\tis.Equal(LastIndexOf([]int{1, 2, 2, 3}, 2), 2)\n\tis.Equal(LastIndexOf([]int{1, 2, 2, 3}, 4), -1)\n}\n\nfunc TestFilter(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := Filter([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(r, []int{2, 4})\n}\n\nfunc TestFind(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := Find([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(r, 2)\n\n}\nfunc TestFindKey(t *testing.T) {\n\tis := assert.New(t)\n\n\tk, r := FindKey(map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4}, func(x int) bool {\n\t\treturn x == 2\n\t})\n\n\tis.Equal(r, 2)\n\tis.Equal(k, \"b\")\n\n\tk1, r1 := FindKey([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x%2 == 0\n\t})\n\tis.Equal(r1, 2)\n\tis.Equal(k1, 1)\n}\n"
        },
        {
          "name": "reduce.go",
          "type": "blob",
          "size": 2.22265625,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n)\n\n// Reduce takes a collection and reduces it to a single value using a reduction\n// function (or a valid symbol) and an accumulator value.\nfunc Reduce(arr, reduceFunc, acc interface{}) interface{} {\n\tarrValue := redirectValue(reflect.ValueOf(arr))\n\n\tif !IsIteratee(arrValue.Interface()) {\n\t\tpanic(\"First parameter must be an iteratee\")\n\t}\n\n\treturnType := reflect.TypeOf(Reduce).Out(0)\n\n\tisFunc := IsFunction(reduceFunc, 2, 1)\n\tisRune := reflect.TypeOf(reduceFunc).Kind() == reflect.Int32\n\n\tif !(isFunc || isRune) {\n\t\tpanic(\"Second argument must be a valid function or rune\")\n\t}\n\n\taccValue := reflect.ValueOf(acc)\n\tsliceElemType := sliceElem(arrValue.Type())\n\n\tif isRune {\n\t\tif arrValue.Kind() == reflect.Slice && sliceElemType.Kind() == reflect.Interface {\n\t\t\taccValue = accValue.Convert(returnType)\n\t\t} else {\n\t\t\taccValue = accValue.Convert(sliceElemType)\n\t\t}\n\t} else {\n\t\taccValue = accValue.Convert(reflect.TypeOf(reduceFunc).In(0))\n\t}\n\n\taccType := accValue.Type()\n\n\t// Generate reduce function if was passed as rune\n\tif isRune {\n\t\treduceSign := reduceFunc.(int32)\n\n\t\tif ok := map[rune]bool{'+': true, '*': true}[reduceSign]; !ok {\n\t\t\tpanic(\"Invalid reduce sign, allowed: '+' and '*'\")\n\t\t}\n\n\t\tin := []reflect.Type{accType, sliceElemType}\n\t\tout := []reflect.Type{accType}\n\t\tfuncType := reflect.FuncOf(in, out, false)\n\n\t\treduceFunc = reflect.MakeFunc(funcType, func(args []reflect.Value) []reflect.Value {\n\t\t\tacc := args[0].Interface()\n\t\t\telem := args[1].Interface()\n\n\t\t\tvar result float64\n\t\t\tparams := []interface{}{acc, elem}\n\t\t\tswitch reduceSign {\n\t\t\tcase '+':\n\t\t\t\tresult = Sum(params)\n\t\t\tcase '*':\n\t\t\t\tresult = Product(params)\n\t\t\t}\n\n\t\t\treturn []reflect.Value{reflect.ValueOf(result).Convert(accType)}\n\t\t}).Interface()\n\t}\n\n\tfuncValue := reflect.ValueOf(reduceFunc)\n\tfuncType := funcValue.Type()\n\n\tfor i := 0; i < arrValue.Len(); i++ {\n\t\tif accType.ConvertibleTo(funcType.In(0)) {\n\t\t\taccValue = accValue.Convert(funcType.In(0))\n\t\t}\n\n\t\tarrElementValue := arrValue.Index(i)\n\t\tif sliceElemType.ConvertibleTo(funcType.In(1)) {\n\t\t\tarrElementValue = arrElementValue.Convert(funcType.In(1))\n\t\t}\n\n\t\tresult := funcValue.Call([]reflect.Value{accValue, arrElementValue})\n\t\taccValue = result[0]\n\t}\n\n\treturn accValue.Convert(returnType).Interface()\n}\n"
        },
        {
          "name": "reduce_test.go",
          "type": "blob",
          "size": 1.060546875,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestReduce(t *testing.T) {\n\ttestCases := []struct {\n\t\tArr    interface{}\n\t\tFunc   interface{}\n\t\tAcc    interface{}\n\t\tResult interface{}\n\t}{\n\t\t{\n\t\t\t[]int{1, 2, 3, 4},\n\t\t\tfunc(acc, elem float64) float64 { return acc + elem },\n\t\t\t0,\n\t\t\tfloat64(10),\n\t\t},\n\t\t{\n\t\t\t&[]int16{1, 2, 3, 4},\n\t\t\t'+',\n\t\t\t5,\n\t\t\tint16(15),\n\t\t},\n\t\t{\n\t\t\t[]float64{1.1, 2.2, 3.3},\n\t\t\t'+',\n\t\t\t0,\n\t\t\tfloat64(6.6),\n\t\t},\n\t\t{\n\t\t\t&[]int{1, 2, 3, 5},\n\t\t\tfunc(acc int8, elem int16) int32 { return int32(acc) * int32(elem) },\n\t\t\t1,\n\t\t\tint32(30),\n\t\t},\n\t\t{\n\t\t\t[]interface{}{1, 2, 3.3, 4},\n\t\t\t'*',\n\t\t\t1,\n\t\t\tfloat64(26.4),\n\t\t},\n\t\t{\n\t\t\t[]string{\"1\", \"2\", \"3\", \"4\"},\n\t\t\tfunc(acc string, elem string) string { return acc + elem },\n\t\t\t\"\",\n\t\t\t\"1234\",\n\t\t},\n\t}\n\n\tfor idx, test := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\tresult := Reduce(test.Arr, test.Func, test.Acc)\n\t\t\tif !is.Equal(result, test.Result) {\n\t\t\t\tt.Errorf(\"%#v doesn't eqal to %#v\", result, test.Result)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "retrieve.go",
          "type": "blob",
          "size": 3.400390625,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\n// Get retrieves the value from given path, retriever can be modified with available RetrieverOptions\nfunc Get(out interface{}, path string, opts ...option) interface{} {\n\toptions := newOptions(opts...)\n\n\tresult := get(reflect.ValueOf(out), path, opts...)\n\t// valid kind and we can return a result.Interface() without panic\n\tif result.Kind() != reflect.Invalid && result.CanInterface() {\n\t\t// if we don't allow zero and the result is a zero value return nil\n\t\tif !options.allowZero && result.IsZero() {\n\t\t\treturn nil\n\t\t}\n\t\t// if the result kind is a pointer and its nil return nil\n\t\tif result.Kind() == reflect.Ptr && result.IsNil() {\n\t\t\treturn nil\n\t\t}\n\t\t// return the result interface (i.e the zero value of it)\n\t\treturn result.Interface()\n\t}\n\n\treturn nil\n}\n\n// GetOrElse retrieves the value of the pointer or default.\nfunc GetOrElse(v interface{}, def interface{}) interface{} {\n\tval := reflect.ValueOf(v)\n\tif v == nil || (val.Kind() == reflect.Ptr && val.IsNil()) {\n\t\treturn def\n\t} else if val.Kind() != reflect.Ptr {\n\t\treturn v\n\t}\n\treturn val.Elem().Interface()\n}\n\nfunc get(value reflect.Value, path string, opts ...option) reflect.Value {\n\toptions := newOptions(opts...)\n\n\tif value.Kind() == reflect.Slice || value.Kind() == reflect.Array {\n\t\tvar resultSlice reflect.Value\n\n\t\tlength := value.Len()\n\n\t\tif length == 0 {\n\t\t\tzeroElement := reflect.Zero(value.Type().Elem())\n\t\t\tpathValue := get(zeroElement, path)\n\t\t\tvalue = reflect.MakeSlice(reflect.SliceOf(pathValue.Type()), 0, 0)\n\n\t\t\treturn value\n\t\t}\n\n\t\tfor i := 0; i < length; i++ {\n\t\t\titem := value.Index(i)\n\n\t\t\tresultValue := get(item, path)\n\n\t\t\tif resultValue.Kind() == reflect.Invalid || (resultValue.IsZero() && !options.allowZero) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tresultType := resultValue.Type()\n\n\t\t\tif resultSlice.Kind() == reflect.Invalid {\n\t\t\t\tresultType := reflect.SliceOf(resultType)\n\n\t\t\t\tresultSlice = reflect.MakeSlice(resultType, 0, 0)\n\t\t\t}\n\n\t\t\tresultSlice = reflect.Append(resultSlice, resultValue)\n\t\t}\n\n\t\t// if the result is a slice of a slice, we need to flatten it\n\t\tif resultSlice.Kind() != reflect.Invalid && resultSlice.Type().Elem().Kind() == reflect.Slice {\n\t\t\treturn flattenDeep(resultSlice)\n\t\t}\n\n\t\treturn resultSlice\n\t}\n\n\tquoted := false\n\tparts := strings.FieldsFunc(path, func(r rune) bool {\n\t\tif r == '\"' {\n\t\t\tquoted = !quoted\n\t\t}\n\t\treturn !quoted && r == '.'\n\t})\n\n\tfor i, part := range parts {\n\t\tparts[i] = strings.Trim(part, \"\\\"\")\n\t}\n\n\tfor _, part := range parts {\n\t\tvalue = redirectValue(value)\n\t\tkind := value.Kind()\n\n\t\tswitch kind {\n\t\tcase reflect.Invalid:\n\t\t\tcontinue\n\t\tcase reflect.Struct:\n\t\t\tif isNilIndirection(value, part) {\n\t\t\t\treturn reflect.ValueOf(nil)\n\t\t\t}\n\t\t\tvalue = value.FieldByName(part)\n\t\tcase reflect.Map:\n\t\t\tvalue = value.MapIndex(reflect.ValueOf(part))\n\t\tcase reflect.Slice, reflect.Array:\n\t\t\tvalue = get(value, part)\n\t\tdefault:\n\t\t\treturn reflect.ValueOf(nil)\n\t\t}\n\t}\n\n\treturn value\n}\n\nfunc isNilIndirection(v reflect.Value, name string) bool {\n\tvType := v.Type()\n\tfor i := 0; i < vType.NumField(); i++ {\n\t\tfield := vType.Field(i)\n\t\tif !isEmbeddedStructPointerField(field) {\n\t\t\treturn false\n\t\t}\n\n\t\tfieldType := field.Type.Elem()\n\n\t\t_, found := fieldType.FieldByName(name)\n\t\tif found {\n\t\t\treturn v.Field(i).IsNil()\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc isEmbeddedStructPointerField(field reflect.StructField) bool {\n\tif !field.Anonymous {\n\t\treturn false\n\t}\n\n\treturn field.Type.Kind() == reflect.Ptr && field.Type.Elem().Kind() == reflect.Struct\n}\n"
        },
        {
          "name": "retrieve_test.go",
          "type": "blob",
          "size": 3.705078125,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetSlice(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Get(SliceOf(foo), \"ID\"), []int{1})\n\tis.Equal(Get(SliceOf(foo), \"Bar.Name\"), []string{\"Test\"})\n\tis.Equal(Get(SliceOf(foo), \"Bar\"), []*Bar{bar})\n\tis.Equal(Get(([]Foo)(nil), \"Bar.Name\"), []string{})\n\tis.Equal(Get([]Foo{}, \"Bar.Name\"), []string{})\n\tis.Equal(Get([]*Foo{}, \"Bar.Name\"), []string{})\n}\n\nfunc TestGetSliceMultiLevel(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Get(foo, \"Bar.Bars.Bar.Name\"), []string{\"Level2-1\", \"Level2-2\"})\n\tis.Equal(Get(SliceOf(foo), \"Bar.Bars.Bar.Name\"), []string{\"Level2-1\", \"Level2-2\"})\n}\n\nfunc TestGetNull(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Get(foo, \"EmptyValue.Int64\"), int64(10))\n\tis.Equal(Get(foo, \"ZeroValue\"), nil)\n\tis.Equal(false, Get(foo, \"ZeroBoolValue\", WithAllowZero()))\n\tis.Equal(nil, Get(fooUnexported, \"unexported\", WithAllowZero()))\n\tis.Equal(nil, Get(fooUnexported, \"unexported\", WithAllowZero()))\n\tis.Equal(Get(foo, \"ZeroIntValue\", WithAllowZero()), 0)\n\tis.Equal(Get(foo, \"ZeroIntPtrValue\", WithAllowZero()), nil)\n\tis.Equal(Get(foo, \"EmptyValue.Int64\", WithAllowZero()), int64(10))\n\tis.Equal(Get(SliceOf(foo), \"EmptyValue.Int64\"), []int64{10})\n}\n\nfunc TestGetNil(t *testing.T) {\n\tis := assert.New(t)\n\tis.Equal(Get(foo2, \"Bar.Name\"), nil)\n\tis.Equal(Get(foo2, \"Bar.Name\", WithAllowZero()), \"\")\n\tis.Equal(Get([]*Foo{foo, foo2}, \"Bar.Name\"), []string{\"Test\"})\n\tis.Equal(Get([]*Foo{foo, foo2}, \"Bar\"), []*Bar{bar})\n}\n\nfunc TestGetMap(t *testing.T) {\n\tis := assert.New(t)\n\tm := map[string]interface{}{\n\t\t\"bar\": map[string]interface{}{\n\t\t\t\"name\":              \"foobar\",\n\t\t\t\"example.com/hello\": \"world\",\n\t\t},\n\t}\n\n\tis.Equal(\"foobar\", Get(m, \"bar.name\"))\n\tis.Equal(\"world\", Get(m, `bar.\"example.com/hello\"`))\n\tis.Equal(nil, Get(m, \"foo.name\"))\n\tis.Equal(nil, Get(m, `foo.\"example.com/hello\"`))\n\tis.Equal([]interface{}{\"dark\", \"dark\"}, Get([]map[string]interface{}{m1, m2}, \"firstname\"))\n\tis.Equal([]interface{}{\"test\"}, Get([]map[string]interface{}{m1, m2}, \"bar.name\"))\n}\n\nfunc TestGetThroughInterface(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Get(foo, \"BarInterface.Bars.Bar.Name\"), []string{\"Level2-1\", \"Level2-2\"})\n\tis.Equal(Get(foo, \"BarPointer.Bars.Bar.Name\"), []string{\"Level2-1\", \"Level2-2\"})\n}\n\nfunc TestGetWithAllowZero(t *testing.T) {\n\tis := assert.New(t)\n\n\tvar test []struct {\n\t\tAge int\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\ttest = append(test, struct{ Age int }{Age: i})\n\t}\n\n\tis.Equal(Get(test, \"Age\").([]int), []int{1, 2, 3, 4, 5, 6, 7, 8, 9})\n\tis.Equal(Get(test, \"Age\", WithAllowZero()).([]int), []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9})\n}\n\nfunc TestGetNotFound(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(nil, Get(foo, \"id\"))\n\tis.Equal(nil, Get(foo, \"id.id\"))\n\tis.Equal(nil, Get(foo, \"Bar.id\"))\n\tis.Equal(nil, Get(foo, \"Bars.id\"))\n}\n\nfunc TestGetSimple(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Get(foo, \"ID\"), 1)\n\n\tis.Equal(Get(foo, \"Bar.Name\"), \"Test\")\n\n\tresult := Get(foo, \"Bar.Bars.Name\")\n\n\tis.Equal(result, []string{\"Level1-1\", \"Level1-2\"})\n}\n\nfunc TestGetOrElse(t *testing.T) {\n\tis := assert.New(t)\n\n\tstr := \"hello world\"\n\tis.Equal(\"hello world\", GetOrElse(&str, \"foobar\"))\n\tis.Equal(\"hello world\", GetOrElse(str, \"foobar\"))\n\tis.Equal(\"foobar\", GetOrElse(nil, \"foobar\"))\n\n\tt.Run(\"nil with type\", func(t *testing.T) {\n\t\t// test GetOrElse covers this case\n\t\tis.Equal(\"foobar\", GetOrElse((*string)(nil), \"foobar\"))\n\t})\n}\n\nfunc TestEmbeddedStructPointer(t *testing.T) {\n\tis := assert.New(t)\n\n\troot := RootStructPointer{}\n\tis.Equal(Get(root, \"EmbeddedField\"), nil)\n\tis.Equal(Get(root, \"EmbeddedStruct.EmbeddedField\"), nil)\n}\n\nfunc TestEmbeddedStructNotPointer(t *testing.T) {\n\tis := assert.New(t)\n\n\troot := RootStructNotPointer{}\n\tis.Equal(Get(root, \"EmbeddedField\"), nil)\n}\n"
        },
        {
          "name": "scan.go",
          "type": "blob",
          "size": 5.2783203125,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// ForEach iterates over elements of collection and invokes iteratee\n// for each element.\nfunc ForEach(arr interface{}, predicate interface{}) {\n\tif !IsIteratee(arr) {\n\t\tpanic(\"First parameter must be an iteratee\")\n\t}\n\n\tvar (\n\t\tfuncValue = reflect.ValueOf(predicate)\n\t\tarrValue  = reflect.ValueOf(arr)\n\t\tarrType   = arrValue.Type()\n\t\tfuncType  = funcValue.Type()\n\t)\n\n\tif arrType.Kind() == reflect.Slice || arrType.Kind() == reflect.Array {\n\t\tif !IsFunction(predicate, 1, 0) {\n\t\t\tpanic(\"Second argument must be a function with one parameter\")\n\t\t}\n\n\t\tarrElemType := arrValue.Type().Elem()\n\t\tarrElemPointerType := reflect.New(arrElemType).Type()\n\t\tusePointer := arrElemPointerType.ConvertibleTo(funcType.In(0))\n\n\t\t// Checking whether element type is convertible to function's first argument's type.\n\t\tif !arrElemType.ConvertibleTo(funcType.In(0)) && !usePointer {\n\t\t\tpanic(\"Map function's argument is not compatible with type of array.\")\n\t\t}\n\n\t\tfor i := 0; i < arrValue.Len(); i++ {\n\t\t\tif usePointer {\n\t\t\t\tfuncValue.Call([]reflect.Value{arrValue.Index(i).Addr()})\n\t\t\t} else {\n\t\t\t\tfuncValue.Call([]reflect.Value{arrValue.Index(i)})\n\t\t\t}\n\t\t}\n\t}\n\n\tif arrType.Kind() == reflect.Map {\n\t\tif !IsFunction(predicate, 2, 0) {\n\t\t\tpanic(\"Second argument must be a function with two parameters\")\n\t\t}\n\n\t\t// Type checking for Map<key, value> = (key, value)\n\t\tkeyType := arrType.Key()\n\t\tvalueType := arrType.Elem()\n\n\t\tif !keyType.ConvertibleTo(funcType.In(0)) {\n\t\t\tpanic(fmt.Sprintf(\"function first argument is not compatible with %s\", keyType.String()))\n\t\t}\n\n\t\tif !valueType.ConvertibleTo(funcType.In(1)) {\n\t\t\tpanic(fmt.Sprintf(\"function second argument is not compatible with %s\", valueType.String()))\n\t\t}\n\n\t\tfor _, key := range arrValue.MapKeys() {\n\t\t\tfuncValue.Call([]reflect.Value{key, arrValue.MapIndex(key)})\n\t\t}\n\t}\n}\n\n// ForEachRight iterates over elements of collection from the right and invokes iteratee\n// for each element.\nfunc ForEachRight(arr interface{}, predicate interface{}) {\n\tif !IsIteratee(arr) {\n\t\tpanic(\"First parameter must be an iteratee\")\n\t}\n\n\tvar (\n\t\tfuncValue = reflect.ValueOf(predicate)\n\t\tarrValue  = reflect.ValueOf(arr)\n\t\tarrType   = arrValue.Type()\n\t\tfuncType  = funcValue.Type()\n\t)\n\n\tif arrType.Kind() == reflect.Slice || arrType.Kind() == reflect.Array {\n\t\tif !IsFunction(predicate, 1, 0) {\n\t\t\tpanic(\"Second argument must be a function with one parameter\")\n\t\t}\n\n\t\tarrElemType := arrValue.Type().Elem()\n\t\tarrElemPointerType := reflect.New(arrElemType).Type()\n\t\tusePointer := arrElemPointerType.ConvertibleTo(funcType.In(0))\n\n\t\t// Checking whether element type is convertible to function's first argument's type.\n\t\tif !arrElemType.ConvertibleTo(funcType.In(0)) && !usePointer {\n\t\t\tpanic(\"Map function's argument is not compatible with type of array.\")\n\t\t}\n\n\t\tfor i := arrValue.Len() - 1; i >= 0; i-- {\n\t\t\tif usePointer {\n\t\t\t\tfuncValue.Call([]reflect.Value{arrValue.Index(i).Addr()})\n\t\t\t} else {\n\t\t\t\tfuncValue.Call([]reflect.Value{arrValue.Index(i)})\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif arrType.Kind() == reflect.Map {\n\t\tif !IsFunction(predicate, 2, 0) {\n\t\t\tpanic(\"Second argument must be a function with two parameters\")\n\t\t}\n\n\t\t// Type checking for Map<key, value> = (key, value)\n\t\tkeyType := arrType.Key()\n\t\tvalueType := arrType.Elem()\n\n\t\tif !keyType.ConvertibleTo(funcType.In(0)) {\n\t\t\tpanic(fmt.Sprintf(\"function first argument is not compatible with %s\", keyType.String()))\n\t\t}\n\n\t\tif !valueType.ConvertibleTo(funcType.In(1)) {\n\t\t\tpanic(fmt.Sprintf(\"function second argument is not compatible with %s\", valueType.String()))\n\t\t}\n\n\t\tkeys := Reverse(arrValue.MapKeys()).([]reflect.Value)\n\n\t\tfor _, key := range keys {\n\t\t\tfuncValue.Call([]reflect.Value{key, arrValue.MapIndex(key)})\n\t\t}\n\t}\n}\n\n// Head gets the first element of array.\nfunc Head(arr interface{}) interface{} {\n\tvalue := redirectValue(reflect.ValueOf(arr))\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tif value.Len() == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn value.Index(0).Interface()\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Head\", valueType.String()))\n}\n\n// Last gets the last element of array.\nfunc Last(arr interface{}) interface{} {\n\tvalue := redirectValue(reflect.ValueOf(arr))\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tif value.Len() == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn value.Index(value.Len() - 1).Interface()\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Last\", valueType.String()))\n}\n\n// Initial gets all but the last element of array.\nfunc Initial(arr interface{}) interface{} {\n\tvalue := redirectValue(reflect.ValueOf(arr))\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tlength := value.Len()\n\n\t\tif length <= 1 {\n\t\t\treturn arr\n\t\t}\n\n\t\treturn value.Slice(0, length-1).Interface()\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Initial\", valueType.String()))\n}\n\n// Tail gets all but the first element of array.\nfunc Tail(arr interface{}) interface{} {\n\tvalue := redirectValue(reflect.ValueOf(arr))\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tlength := value.Len()\n\n\t\tif length <= 1 {\n\t\t\treturn arr\n\t\t}\n\n\t\treturn value.Slice(1, length).Interface()\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Initial\", valueType.String()))\n}\n"
        },
        {
          "name": "scan_test.go",
          "type": "blob",
          "size": 2.0732421875,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestForEach(t *testing.T) {\n\tis := assert.New(t)\n\n\tresults := []int{}\n\n\tForEach([]int{1, 2, 3, 4}, func(x int) {\n\t\tif x%2 == 0 {\n\t\t\tresults = append(results, x)\n\t\t}\n\t})\n\n\tis.Equal(results, []int{2, 4})\n\n\ttoModify := []int{1, 2, 3}\n\tForEach(toModify, func(x *int) { *x = *x * 2 })\n\n\tis.Equal(toModify, []int{2, 4, 6})\n\n\ttoModify = []int{}\n\tForEach(toModify, func(x *int) {})\n\n\tis.Equal(toModify, []int{})\n\n\tstrModify := []string{\"a\", \"b\"}\n\tForEach(strModify, func(s *string) {\n\t\t*s = *s + *s\n\t})\n\n\tis.Equal(strModify, []string{\"aa\", \"bb\"})\n\n\tmapping := map[int]string{\n\t\t1: \"Florent\",\n\t\t2: \"Gilles\",\n\t}\n\n\tForEach(mapping, func(k int, v string) {\n\t\tis.Equal(v, mapping[k])\n\t})\n}\n\nfunc TestForEachRight(t *testing.T) {\n\tis := assert.New(t)\n\n\tresults := []int{}\n\n\tForEachRight([]int{1, 2, 3, 4}, func(x int) {\n\t\tresults = append(results, x*2)\n\t})\n\n\tis.Equal(results, []int{8, 6, 4, 2})\n\n\ttoModify := []int{1, 2, 3}\n\tForEach(toModify, func(x *int) { *x = *x * 2 })\n\n\tis.Equal(toModify, []int{2, 4, 6})\n\n\ttoModify = []int{}\n\tForEach(toModify, func(x *int) {})\n\n\tis.Equal(toModify, []int{})\n\n\tstrModify := []string{\"a\", \"b\"}\n\tForEach(strModify, func(s *string) {\n\t\t*s = *s + *s\n\t})\n\n\tis.Equal(strModify, []string{\"aa\", \"bb\"})\n\n\tmapping := map[int]string{\n\t\t1: \"Florent\",\n\t\t2: \"Gilles\",\n\t}\n\n\tmapKeys := []int{}\n\n\tForEachRight(mapping, func(k int, v string) {\n\t\tis.Equal(v, mapping[k])\n\t\tmapKeys = append(mapKeys, k)\n\t})\n\n\tis.Equal(len(mapKeys), 2)\n\tis.Contains(mapKeys, 1)\n\tis.Contains(mapKeys, 2)\n}\n\nfunc TestHead(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Head([]int{1, 2, 3, 4}), 1)\n}\n\nfunc TestLast(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Last([]int{1, 2, 3, 4}), 4)\n}\n\nfunc TestTail(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Tail([]int{}), []int{})\n\tis.Equal(Tail([]int{1}), []int{1})\n\tis.Equal(Tail([]int{1, 2, 3, 4}), []int{2, 3, 4})\n}\n\nfunc TestInitial(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Initial([]int{}), []int{})\n\tis.Equal(Initial([]int{1}), []int{1})\n\tis.Equal(Initial([]int{1, 2, 3, 4}), []int{1, 2, 3})\n}\n"
        },
        {
          "name": "short_if.go",
          "type": "blob",
          "size": 0.1259765625,
          "content": "package funk\n\nfunc ShortIf(condition bool, a interface{}, b interface{}) interface{} {\n\tif condition {\n\t\treturn a\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "short_if_test.go",
          "type": "blob",
          "size": 0.509765625,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestShortIf(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := ShortIf(10 > 5, 10, 5)\n\tis.Equal(r, 10)\n\n\tr = ShortIf(10.0 == 10, \"yes\", \"no\")\n\tis.Equal(r, \"yes\")\n\n\tr = ShortIf('a' == 'b', \"equal chars\", \"unequal chars\")\n\tis.Equal(r, \"unequal chars\")\n\n\tr = ShortIf(true, \"Same string\", \"Different strings\")\n\tis.Equal(r, \"Same string\")\n\n\ttype testStruct struct{}\n\ta := testStruct{}\n\tb := testStruct{}\n\tr = ShortIf(a == b, &a, &b)\n\tis.Equal(r, &b)\n\n}\n"
        },
        {
          "name": "subset.go",
          "type": "blob",
          "size": 0.7255859375,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n)\n\n// Subset returns true if collection x is a subset of y.\nfunc Subset(x interface{}, y interface{}) bool {\n\tif !IsCollection(x) {\n\t\tpanic(\"First parameter must be a collection\")\n\t}\n\tif !IsCollection(y) {\n\t\tpanic(\"Second parameter must be a collection\")\n\t}\n\n\txValue := reflect.ValueOf(x)\n\txType := xValue.Type()\n\n\tyValue := reflect.ValueOf(y)\n\tyType := yValue.Type()\n\n\tif NotEqual(xType, yType) {\n\t\tpanic(\"Parameters must have the same type\")\n\t}\n\n\tif xValue.Len() == 0 {\n\t\treturn true\n\t}\n\n\tif yValue.Len() == 0 || yValue.Len() < xValue.Len() {\n\t\treturn false\n\t}\n\n\tfor i := 0; i < xValue.Len(); i++ {\n\t\tif !Contains(yValue.Interface(), xValue.Index(i).Interface()) {\n\t\t\treturn false\n\t\t}\n\t}\n\n    return true\n}\n"
        },
        {
          "name": "subset_test.go",
          "type": "blob",
          "size": 0.77734375,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubset(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := Subset([]int{1, 2, 4}, []int{1, 2, 3, 4, 5})\n\tis.True(r)\n\n\tr = Subset([]string{\"foo\", \"bar\"},[]string{\"foo\", \"bar\", \"hello\", \"bar\", \"hi\"})\n\tis.True(r)\n\n\tr = Subset([]string{\"foo\", \"bar\",\"extra\"},[]string{\"foo\", \"bar\", \"hello\", \"bar\", \"hi\"})\n\tis.False(r)\n\n\tr = Subset([]string{\"hello\", \"foo\", \"bar\", \"hello\", \"bar\", \"hi\"}, []string{})\n\tis.False(r)\n  \n        r = Subset([]string{}, []string{\"hello\", \"foo\", \"bar\", \"hello\", \"bar\", \"hi\"})\n\tis.True(r)\n\n\tr = Subset([]string{}, []string{})\n\tis.True(r)\n\n\tr = Subset([]string{}, []string{\"hello\"})\n\tis.True(r)\n\n\tr = Subset([]string{\"hello\", \"foo\", \"bar\", \"hello\", \"bar\", \"hi\"}, []string{\"foo\", \"bar\"} )\n\tis.False(r)\n}\n"
        },
        {
          "name": "subtraction.go",
          "type": "blob",
          "size": 1.4892578125,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n)\n\n// Subtract returns the subtraction between two collections.\nfunc Subtract(x interface{}, y interface{}) interface{} {\n\tif !IsCollection(x) {\n\t\tpanic(\"First parameter must be a collection\")\n\t}\n\tif !IsCollection(y) {\n\t\tpanic(\"Second parameter must be a collection\")\n\t}\n\n\thash := map[interface{}]struct{}{}\n\n\txValue := reflect.ValueOf(x)\n\txType := xValue.Type()\n\n\tyValue := reflect.ValueOf(y)\n\tyType := yValue.Type()\n\n\tif NotEqual(xType, yType) {\n\t\tpanic(\"Parameters must have the same type\")\n\t}\n\n\tzType := reflect.SliceOf(xType.Elem())\n\tzSlice := reflect.MakeSlice(zType, 0, 0)\n\n\tfor i := 0; i < xValue.Len(); i++ {\n\t\tv := xValue.Index(i).Interface()\n\t\thash[v] = struct{}{}\n\t}\n\n\tfor i := 0; i < yValue.Len(); i++ {\n\t\tv := yValue.Index(i).Interface()\n\t\t_, ok := hash[v]\n\t\tif ok {\n\t\t\tdelete(hash, v)\n\t\t}\n\t}\n\n\tfor i := 0; i < xValue.Len(); i++ {\n\t\tv := xValue.Index(i).Interface()\n\t\t_, ok := hash[v]\n\t\tif ok {\n\t\t\tzSlice = reflect.Append(zSlice, xValue.Index(i))\n\t\t}\n\t}\n\n\treturn zSlice.Interface()\n}\n\n// SubtractString returns the subtraction between two collections of string\nfunc SubtractString(x []string, y []string) []string {\n\tif len(x) == 0 {\n\t\treturn []string{}\n\t}\n\n\tif len(y) == 0 {\n\t\treturn x\n\t}\n\n\tslice := []string{}\n\thash := map[string]struct{}{}\n\n\tfor _, v := range x {\n\t\thash[v] = struct{}{}\n\t}\n\n\tfor _, v := range y {\n\t\t_, ok := hash[v]\n\t\tif ok {\n\t\t\tdelete(hash, v)\n\t\t}\n\t}\n\n\tfor _, v := range x {\n\t\t_, ok := hash[v]\n\t\tif ok {\n\t\t\tslice = append(slice, v)\n\t\t}\n\t}\n\n\treturn slice\n}\n"
        },
        {
          "name": "subtraction_test.go",
          "type": "blob",
          "size": 1.1328125,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubtract(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := Subtract([]int{1, 2, 3, 4, 5}, []int{2, 4, 6})\n\tis.Equal([]int{1, 3, 5}, r)\n\n\tr = Subtract([]string{\"foo\", \"bar\", \"hello\", \"bar\", \"hi\"}, []string{\"foo\", \"bar\"})\n\tis.Equal([]string{\"hello\", \"hi\"}, r)\n\n\tr = Subtract([]string{\"hello\", \"foo\", \"bar\", \"hello\", \"bar\", \"hi\"}, []string{\"foo\", \"bar\"})\n\tis.Equal([]string{\"hello\", \"hello\", \"hi\"}, r)\n\n\tr = Subtract([]int{1, 2, 3, 4, 5}, []int{})\n\tis.Equal([]int{1, 2, 3, 4, 5}, r)\n\n\tr = Subtract([]string{\"bar\", \"bar\"}, []string{})\n\tis.Equal([]string{\"bar\", \"bar\"}, r)\n}\n\nfunc TestSubtractString(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := SubtractString([]string{\"foo\", \"bar\", \"hello\", \"bar\"}, []string{\"foo\", \"bar\"})\n\tis.Equal([]string{\"hello\"}, r)\n\n\tr = SubtractString([]string{\"foo\", \"bar\", \"hello\", \"bar\", \"world\", \"world\"}, []string{\"foo\", \"bar\"})\n\tis.Equal([]string{\"hello\", \"world\", \"world\"}, r)\n\n\tr = SubtractString([]string{\"bar\", \"bar\"}, []string{})\n\tis.Equal([]string{\"bar\", \"bar\"}, r)\n\n\tr = SubtractString([]string{}, []string{\"bar\", \"bar\"})\n\tis.Equal([]string{}, r)\n}\n"
        },
        {
          "name": "transform.go",
          "type": "blob",
          "size": 15.1611328125,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// Chunk creates an array of elements split into groups with the length of size.\n// If array can't be split evenly, the final chunk will be\n// the remaining element.\nfunc Chunk(arr interface{}, size int) interface{} {\n\tif !IsIteratee(arr) {\n\t\tpanic(\"First parameter must be neither array nor slice\")\n\t}\n\n\tif size == 0 {\n\t\treturn arr\n\t}\n\n\tarrValue := reflect.ValueOf(arr)\n\n\tarrType := arrValue.Type()\n\n\tresultSliceType := reflect.SliceOf(arrType)\n\n\t// Initialize final result slice which will contains slice\n\tresultSlice := reflect.MakeSlice(resultSliceType, 0, 0)\n\n\titemType := arrType.Elem()\n\n\tvar itemSlice reflect.Value\n\n\titemSliceType := reflect.SliceOf(itemType)\n\n\tlength := arrValue.Len()\n\n\tfor i := 0; i < length; i++ {\n\t\tif i%size == 0 || i == 0 {\n\t\t\tif itemSlice.Kind() != reflect.Invalid {\n\t\t\t\tresultSlice = reflect.Append(resultSlice, itemSlice)\n\t\t\t}\n\n\t\t\titemSlice = reflect.MakeSlice(itemSliceType, 0, 0)\n\t\t}\n\n\t\titemSlice = reflect.Append(itemSlice, arrValue.Index(i))\n\n\t\tif i == length-1 {\n\t\t\tresultSlice = reflect.Append(resultSlice, itemSlice)\n\t\t}\n\t}\n\n\treturn resultSlice.Interface()\n}\n\n// ToMap transforms a collection of instances to a Map.\n// []T => map[type of T.<pivot>]T\nfunc ToMap(in interface{}, pivot string) interface{} {\n\t// input value must be a collection\n\tif !IsCollection(in) {\n\t\tpanic(fmt.Sprintf(\"%v must be a slict or an array\", in))\n\t}\n\n\tvalue := reflect.ValueOf(in)\n\n\tinType := value.Type()\n\tstructType := inType.Elem()\n\n\t// retrieve the struct in the slice to deduce key type\n\tif structType.Kind() == reflect.Ptr {\n\t\tstructType = structType.Elem()\n\t}\n\n\tfield, ok := structType.FieldByName(pivot)\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"`%s` must be a field of the struct %s\", pivot, structType.Name()))\n\t}\n\n\t// value of the map will be the input type\n\tcollectionType := reflect.MapOf(field.Type, inType.Elem())\n\n\t// create a map from scratch\n\tcollection := reflect.MakeMap(collectionType)\n\n\tfor i := 0; i < value.Len(); i++ {\n\t\tinstance := value.Index(i)\n\t\tvar field reflect.Value\n\n\t\tif instance.Kind() == reflect.Ptr {\n\t\t\tfield = instance.Elem().FieldByName(pivot)\n\t\t} else {\n\t\t\tfield = instance.FieldByName(pivot)\n\t\t}\n\n\t\tcollection.SetMapIndex(field, instance)\n\t}\n\n\treturn collection.Interface()\n}\n\n// ToSet transforms a collection of instances to a Set.\n// []T => map[T]struct{}\nfunc ToSet(in interface{}) interface{} {\n\t// input value must be a collection\n\tif !IsCollection(in) {\n\t\tpanic(fmt.Sprintf(\"%v must be a slice or an array\", in))\n\t}\n\n\tvar (\n\t\tempty      = struct{}{}\n\t\temptyType  = reflect.TypeOf(empty)\n\t\temptyValue = reflect.ValueOf(empty)\n\t)\n\n\tvalue := reflect.ValueOf(in)\n\telemType := value.Type().Elem()\n\n\t// key of the set will be the input type\n\tcollection := reflect.MakeMap(reflect.MapOf(elemType, emptyType))\n\n\tfor i := 0; i < value.Len(); i++ {\n\t\tcollection.SetMapIndex(value.Index(i), emptyValue)\n\t}\n\n\treturn collection.Interface()\n}\n\nfunc mapSlice(arrValue reflect.Value, funcValue reflect.Value) reflect.Value {\n\tfuncType := funcValue.Type()\n\n\tif funcType.NumIn() != 1 || funcType.NumOut() == 0 || funcType.NumOut() > 2 {\n\t\tpanic(\"Map function with an array must have one parameter and must return one or two parameters\")\n\t}\n\n\tarrElemType := arrValue.Type().Elem()\n\n\t// Checking whether element type is convertible to function's first argument's type.\n\tif !arrElemType.ConvertibleTo(funcType.In(0)) {\n\t\tpanic(\"Map function's argument is not compatible with type of array.\")\n\t}\n\n\tif funcType.NumOut() == 1 {\n\t\t// Get slice type corresponding to function's return value's type.\n\t\tresultSliceType := reflect.SliceOf(funcType.Out(0))\n\n\t\t// MakeSlice takes a slice kind type, and makes a slice.\n\t\tresultSlice := reflect.MakeSlice(resultSliceType, 0, 0)\n\n\t\tfor i := 0; i < arrValue.Len(); i++ {\n\t\t\tresult := funcValue.Call([]reflect.Value{arrValue.Index(i)})[0]\n\n\t\t\tresultSlice = reflect.Append(resultSlice, result)\n\t\t}\n\n\t\treturn resultSlice\n\t}\n\n\tif funcType.NumOut() == 2 {\n\t\t// value of the map will be the input type\n\t\tcollectionType := reflect.MapOf(funcType.Out(0), funcType.Out(1))\n\n\t\t// create a map from scratch\n\t\tcollection := reflect.MakeMap(collectionType)\n\n\t\tfor i := 0; i < arrValue.Len(); i++ {\n\t\t\tresults := funcValue.Call([]reflect.Value{arrValue.Index(i)})\n\n\t\t\tcollection.SetMapIndex(results[0], results[1])\n\t\t}\n\n\t\treturn collection\n\t}\n\n\treturn reflect.Value{}\n}\n\nfunc mapMap(arrValue reflect.Value, funcValue reflect.Value) reflect.Value {\n\tfuncType := funcValue.Type()\n\n\tif funcType.NumIn() != 2 || funcType.NumOut() == 0 || funcType.NumOut() > 2 {\n\t\tpanic(\"Map function with a map must have two parameters and must return one or two parameters\")\n\t}\n\n\t// Only one returned parameter, should be a slice\n\tif funcType.NumOut() == 1 {\n\t\t// Get slice type corresponding to function's return value's type.\n\t\tresultSliceType := reflect.SliceOf(funcType.Out(0))\n\n\t\t// MakeSlice takes a slice kind type, and makes a slice.\n\t\tresultSlice := reflect.MakeSlice(resultSliceType, 0, 0)\n\n\t\tfor _, key := range arrValue.MapKeys() {\n\t\t\tresults := funcValue.Call([]reflect.Value{key, arrValue.MapIndex(key)})\n\n\t\t\tresult := results[0]\n\n\t\t\tresultSlice = reflect.Append(resultSlice, result)\n\t\t}\n\n\t\treturn resultSlice\n\t}\n\n\t// two parameters, should be a map\n\tif funcType.NumOut() == 2 {\n\t\t// value of the map will be the input type\n\t\tcollectionType := reflect.MapOf(funcType.Out(0), funcType.Out(1))\n\n\t\t// create a map from scratch\n\t\tcollection := reflect.MakeMap(collectionType)\n\n\t\tfor _, key := range arrValue.MapKeys() {\n\t\t\tresults := funcValue.Call([]reflect.Value{key, arrValue.MapIndex(key)})\n\n\t\t\tcollection.SetMapIndex(results[0], results[1])\n\n\t\t}\n\n\t\treturn collection\n\t}\n\n\treturn reflect.Value{}\n}\n\n// Map manipulates an iteratee and transforms it to another type.\nfunc Map(arr interface{}, mapFunc interface{}) interface{} {\n\tresult := mapFn(arr, mapFunc, \"Map\")\n\n\tif result.IsValid() {\n\t\treturn result.Interface()\n\t}\n\n\treturn nil\n}\n\nfunc mapFn(arr interface{}, mapFunc interface{}, funcName string) reflect.Value {\n\tif !IsIteratee(arr) {\n\t\tpanic(\"First parameter must be an iteratee\")\n\t}\n\n\tif !IsFunction(mapFunc) {\n\t\tpanic(\"Second argument must be function\")\n\t}\n\n\tvar (\n\t\tfuncValue = reflect.ValueOf(mapFunc)\n\t\tarrValue  = reflect.ValueOf(arr)\n\t\tarrType   = arrValue.Type()\n\t)\n\n\tkind := arrType.Kind()\n\n\tif kind == reflect.Slice || kind == reflect.Array {\n\t\treturn mapSlice(arrValue, funcValue)\n\t} else if kind == reflect.Map {\n\t\treturn mapMap(arrValue, funcValue)\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by \"+funcName, arrType.String()))\n}\n\n// FlatMap manipulates an iteratee and transforms it to a flattened collection of another type.\nfunc FlatMap(arr interface{}, mapFunc interface{}) interface{} {\n\tresult := mapFn(arr, mapFunc, \"FlatMap\")\n\n\tif result.IsValid() {\n\t\treturn flatten(result).Interface()\n\t}\n\n\treturn nil\n}\n\n// Flatten flattens a two-dimensional array.\nfunc Flatten(out interface{}) interface{} {\n\treturn flatten(reflect.ValueOf(out)).Interface()\n}\n\nfunc flatten(value reflect.Value) reflect.Value {\n\tsliceType := value.Type()\n\n\tif (value.Kind() != reflect.Slice && value.Kind() != reflect.Array) ||\n\t\t(sliceType.Elem().Kind() != reflect.Slice && sliceType.Elem().Kind() != reflect.Array) {\n\t\tpanic(\"Argument must be an array or slice of at least two dimensions\")\n\t}\n\n\tresultSliceType := sliceType.Elem().Elem()\n\n\tresultSlice := reflect.MakeSlice(reflect.SliceOf(resultSliceType), 0, 0)\n\n\tlength := value.Len()\n\n\tfor i := 0; i < length; i++ {\n\t\titem := value.Index(i)\n\n\t\tresultSlice = reflect.AppendSlice(resultSlice, item)\n\t}\n\n\treturn resultSlice\n}\n\n// FlattenDeep recursively flattens array.\nfunc FlattenDeep(out interface{}) interface{} {\n\treturn flattenDeep(reflect.ValueOf(out)).Interface()\n}\n\nfunc flattenDeep(value reflect.Value) reflect.Value {\n\tsliceType := sliceElem(value.Type())\n\n\tresultSlice := reflect.MakeSlice(reflect.SliceOf(sliceType), 0, 0)\n\n\treturn flattenRecursive(value, resultSlice)\n}\n\nfunc flattenRecursive(value reflect.Value, result reflect.Value) reflect.Value {\n\tlength := value.Len()\n\n\tfor i := 0; i < length; i++ {\n\t\titem := value.Index(i)\n\t\tkind := item.Kind()\n\n\t\tif kind == reflect.Slice || kind == reflect.Array {\n\t\t\tresult = flattenRecursive(item, result)\n\t\t} else {\n\t\t\tresult = reflect.Append(result, item)\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Shuffle creates an array of shuffled values\nfunc Shuffle(in interface{}) interface{} {\n\tvalue := reflect.ValueOf(in)\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tlength := value.Len()\n\n\t\tresultSlice := makeSlice(value, length)\n\n\t\tfor i, v := range rand.Perm(length) {\n\t\t\tresultSlice.Index(i).Set(value.Index(v))\n\t\t}\n\n\t\treturn resultSlice.Interface()\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Shuffle\", valueType.String()))\n}\n\n// Reverse transforms an array the first element will become the last,\n// the second element will become the second to last, etc.\nfunc Reverse(in interface{}) interface{} {\n\tvalue := reflect.ValueOf(in)\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tif kind == reflect.String {\n\t\treturn ReverseString(in.(string))\n\t}\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tlength := value.Len()\n\n\t\tresultSlice := makeSlice(value, length)\n\n\t\tj := 0\n\t\tfor i := length - 1; i >= 0; i-- {\n\t\t\tresultSlice.Index(j).Set(value.Index(i))\n\t\t\tj++\n\t\t}\n\n\t\treturn resultSlice.Interface()\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Reverse\", valueType.String()))\n}\n\n// Uniq creates an array with unique values.\nfunc Uniq(in interface{}) interface{} {\n\tvalue := reflect.ValueOf(in)\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tlength := value.Len()\n\n\t\tresult := makeSlice(value, 0)\n\n\t\tseen := make(map[interface{}]bool, length)\n\n\t\tfor i := 0; i < length; i++ {\n\t\t\tval := value.Index(i)\n\t\t\tv := val.Interface()\n\n\t\t\tif _, ok := seen[v]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tseen[v] = true\n\t\t\tresult = reflect.Append(result, val)\n\t\t}\n\n\t\treturn result.Interface()\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Uniq\", valueType.String()))\n}\n\n// Uniq creates an array with unique values.\nfunc UniqBy(in interface{}, mapFunc interface{}) interface{} {\n\tif !IsFunction(mapFunc) {\n\t\tpanic(\"Second argument must be function\")\n\t}\n\n\tvalue := reflect.ValueOf(in)\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tfuncValue := reflect.ValueOf(mapFunc)\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tlength := value.Len()\n\n\t\tresult := makeSlice(value, 0)\n\n\t\tseen := make(map[interface{}]bool, length)\n\n\t\tfor i := 0; i < length; i++ {\n\t\t\tval := value.Index(i)\n\t\t\tv := funcValue.Call([]reflect.Value{val})[0].Interface()\n\n\t\t\tif _, ok := seen[v]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tseen[v] = true\n\t\t\tresult = reflect.Append(result, val)\n\t\t}\n\n\t\treturn result.Interface()\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Uniq\", valueType.String()))\n}\n\n// ConvertSlice converts a slice type to another,\n// a perfect example would be to convert a slice of struct to a slice of interface.\nfunc ConvertSlice(in interface{}, out interface{}) {\n\tsrcValue := reflect.ValueOf(in)\n\n\tdstValue := reflect.ValueOf(out)\n\n\tif dstValue.Kind() != reflect.Ptr {\n\t\tpanic(\"Second argument must be a pointer\")\n\t}\n\n\tdstValue = dstValue.Elem()\n\n\tif srcValue.Kind() != reflect.Slice && srcValue.Kind() != reflect.Array {\n\t\tpanic(\"First argument must be an array or slice\")\n\t}\n\n\tif dstValue.Kind() != reflect.Slice && dstValue.Kind() != reflect.Array {\n\t\tpanic(\"Second argument must be an array or slice\")\n\t}\n\n\t// returns value that points to dstValue\n\tdirect := reflect.Indirect(dstValue)\n\n\tlength := srcValue.Len()\n\n\tfor i := 0; i < length; i++ {\n\t\tdstValue = reflect.Append(dstValue, srcValue.Index(i))\n\t}\n\n\tdirect.Set(dstValue)\n}\n\n// Drop creates an array/slice with `n` elements dropped from the beginning.\nfunc Drop(in interface{}, n int) interface{} {\n\tvalue := reflect.ValueOf(in)\n\tvalueType := value.Type()\n\n\tkind := value.Kind()\n\n\tif kind == reflect.Array || kind == reflect.Slice {\n\t\tlength := value.Len()\n\n\t\tresultSlice := makeSlice(value, length-n)\n\n\t\tj := 0\n\t\tfor i := n; i < length; i++ {\n\t\t\tresultSlice.Index(j).Set(value.Index(i))\n\t\t\tj++\n\t\t}\n\n\t\treturn resultSlice.Interface()\n\n\t}\n\n\tpanic(fmt.Sprintf(\"Type %s is not supported by Drop\", valueType.String()))\n}\n\n// Prune returns a copy of \"in\" that only contains fields in \"paths\"\n// which are looked up using struct field name.\n// For lookup paths by field tag instead, use funk.PruneByTag()\nfunc Prune(in interface{}, paths []string) (interface{}, error) {\n\treturn pruneByTag(in, paths, nil /*tag*/)\n}\n\n// pruneByTag returns a copy of \"in\" that only contains fields in \"paths\"\n// which are looked up using struct field Tag \"tag\".\nfunc PruneByTag(in interface{}, paths []string, tag string) (interface{}, error) {\n\treturn pruneByTag(in, paths, &tag)\n}\n\n// pruneByTag returns a copy of \"in\" that only contains fields in \"paths\"\n// which are looked up using struct field Tag \"tag\". If tag is nil,\n// traverse paths using struct field name\nfunc pruneByTag(in interface{}, paths []string, tag *string) (interface{}, error) {\n\tinValue := reflect.ValueOf(in)\n\n\tret := reflect.New(inValue.Type()).Elem()\n\n\tfor _, path := range paths {\n\t\tparts := strings.Split(path, \".\")\n\t\tif err := prune(inValue, ret, parts, tag); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn ret.Interface(), nil\n}\n\nfunc prune(inValue reflect.Value, ret reflect.Value, parts []string, tag *string) error {\n\tif len(parts) == 0 {\n\t\t// we reached the location that ret needs to hold inValue\n\t\t// Note: The value at the end of the path is not copied, maybe we need to change.\n\t\t// ret and the original data holds the same reference to this value\n\t\tret.Set(inValue)\n\t\treturn nil\n\t}\n\n\tinKind := inValue.Kind()\n\n\tswitch inKind {\n\tcase reflect.Ptr:\n\t\tif inValue.IsNil() {\n\t\t\t// TODO validate\n\t\t\treturn nil\n\t\t}\n\t\tif ret.IsNil() {\n\t\t\t// init ret and go to next level\n\t\t\tret.Set(reflect.New(inValue.Type().Elem()))\n\t\t}\n\t\treturn prune(inValue.Elem(), ret.Elem(), parts, tag)\n\tcase reflect.Struct:\n\t\tpart := parts[0]\n\t\tvar fValue reflect.Value\n\t\tvar fRet reflect.Value\n\t\tif tag == nil {\n\t\t\t// use field name\n\t\t\tfValue = inValue.FieldByName(part)\n\t\t\tif !fValue.IsValid() {\n\t\t\t\treturn fmt.Errorf(\"field name %v is not found in struct %v\", part, inValue.Type().String())\n\t\t\t}\n\t\t\tfRet = ret.FieldByName(part)\n\t\t} else {\n\t\t\t// search tag that has key equal to part\n\t\t\tfound := false\n\t\t\tfor i := 0; i < inValue.NumField(); i++ {\n\t\t\t\tf := inValue.Type().Field(i)\n\t\t\t\tif key, ok := f.Tag.Lookup(*tag); ok {\n\t\t\t\t\tif key == part {\n\t\t\t\t\t\tfValue = inValue.Field(i)\n\t\t\t\t\t\tfRet = ret.Field(i)\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\treturn fmt.Errorf(\"struct tag %v is not found with key %v\", *tag, part)\n\t\t\t}\n\t\t}\n\t\t// init Ret is zero and go down one more level\n\t\tif fRet.IsZero() {\n\t\t\tfRet.Set(reflect.New(fValue.Type()).Elem())\n\t\t}\n\t\treturn prune(fValue, fRet, parts[1:], tag)\n\tcase reflect.Array, reflect.Slice:\n\t\t// set all its elements\n\t\tlength := inValue.Len()\n\t\t// init ret\n\t\tif ret.IsZero() {\n\t\t\tif inKind == reflect.Slice {\n\t\t\t\tret.Set(reflect.MakeSlice(inValue.Type(), length /*len*/, length /*cap*/))\n\t\t\t} else { // array\n\t\t\t\tret.Set(reflect.New(inValue.Type()).Elem())\n\t\t\t}\n\t\t}\n\t\tfor j := 0; j < length; j++ {\n\t\t\tif err := prune(inValue.Index(j), ret.Index(j), parts, tag); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"path %v cannot be looked up on kind of %v\", strings.Join(parts, \".\"), inValue.Kind())\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "transform_test.go",
          "type": "blob",
          "size": 11.7646484375,
          "content": "package funk\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestMap(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := Map([]int{1, 2, 3, 4}, func(x int) string {\n\t\treturn \"Hello\"\n\t})\n\n\tresult, ok := r.([]string)\n\n\tis.True(ok)\n\tis.Equal(len(result), 4)\n\n\tr = Map([]int{1, 2, 3, 4}, func(x int) (int, int) {\n\t\treturn x, x\n\t})\n\n\tresultType := reflect.TypeOf(r)\n\n\tis.True(resultType.Kind() == reflect.Map)\n\tis.True(resultType.Key().Kind() == reflect.Int)\n\tis.True(resultType.Elem().Kind() == reflect.Int)\n\n\tmapping := map[int]string{\n\t\t1: \"Florent\",\n\t\t2: \"Gilles\",\n\t}\n\n\tr = Map(mapping, func(k int, v string) int {\n\t\treturn k\n\t})\n\n\tis.True(reflect.TypeOf(r).Kind() == reflect.Slice)\n\tis.True(reflect.TypeOf(r).Elem().Kind() == reflect.Int)\n\n\tr = Map(mapping, func(k int, v string) (string, string) {\n\t\treturn fmt.Sprintf(\"%d\", k), v\n\t})\n\n\tresultType = reflect.TypeOf(r)\n\n\tis.True(resultType.Kind() == reflect.Map)\n\tis.True(resultType.Key().Kind() == reflect.String)\n\tis.True(resultType.Elem().Kind() == reflect.String)\n}\n\nfunc TestFlatMap(t *testing.T) {\n\tis := assert.New(t)\n\n\tx := reflect.Value{}.IsValid()\n\tfmt.Println(x)\n\n\tr := FlatMap([][]int{{1}, {2}, {3}, {4}}, func(x []int) []int {\n\t\treturn x\n\t})\n\n\tresult, ok := r.([]int)\n\n\tis.True(ok)\n\tis.ElementsMatch(result, []int{1, 2, 3, 4})\n\n\tmapping := map[string][]int{\n\t\t\"a\": {1},\n\t\t\"b\": {2},\n\t}\n\n\tr = FlatMap(mapping, func(k string, v []int) []int {\n\t\treturn v\n\t})\n\n\tresult, ok = r.([]int)\n\n\tis.True(ok)\n\tis.ElementsMatch(result, []int{1, 2})\n}\n\nfunc TestToMap(t *testing.T) {\n\tis := assert.New(t)\n\n\tf1 := Foo{\n\t\tID:        1,\n\t\tFirstName: \"Dark\",\n\t\tLastName:  \"Vador\",\n\t\tAge:       30,\n\t\tBar: &Bar{\n\t\t\tName: \"Test\",\n\t\t},\n\t}\n\n\tf2 := Foo{\n\t\tID:        1,\n\t\tFirstName: \"Light\",\n\t\tLastName:  \"Vador\",\n\t\tAge:       30,\n\t\tBar: &Bar{\n\t\t\tName: \"Test\",\n\t\t},\n\t}\n\n\t// []*Foo -> Map<int, *Foo>\n\tsliceResults := []*Foo{&f1, &f2}\n\n\tinstanceMapByID := ToMap(sliceResults, \"ID\")\n\tis.True(reflect.TypeOf(instanceMapByID).Kind() == reflect.Map)\n\n\tmappingByID, ok := instanceMapByID.(map[int]*Foo)\n\tis.True(ok)\n\tis.True(len(mappingByID) == 1)\n\n\tfor _, result := range sliceResults {\n\t\titem, ok := mappingByID[result.ID]\n\n\t\tis.True(ok)\n\t\tis.True(reflect.TypeOf(item).Kind() == reflect.Ptr)\n\t\tis.True(reflect.TypeOf(item).Elem().Kind() == reflect.Struct)\n\n\t\tis.Equal(item.ID, result.ID)\n\t}\n\n\t// Array<Foo> -> Map<string, Foo>\n\tarrayResults := [4]Foo{f1, f1, f2, f2}\n\n\tinstanceMapByFirstName := ToMap(arrayResults, \"FirstName\")\n\tis.True(reflect.TypeOf(instanceMapByFirstName).Kind() == reflect.Map)\n\n\tmappingByFirstName, ok := instanceMapByFirstName.(map[string]Foo)\n\tis.True(ok)\n\tis.True(len(mappingByFirstName) == 2)\n\n\tfor _, result := range arrayResults {\n\t\titem, ok := mappingByFirstName[result.FirstName]\n\n\t\tis.True(ok)\n\t\tis.True(reflect.TypeOf(item).Kind() == reflect.Struct)\n\n\t\tis.Equal(item.FirstName, result.FirstName)\n\t}\n}\n\nfunc TestToSet(t *testing.T) {\n\tis := assert.New(t)\n\n\ttype Foo struct {\n\t\tID   int\n\t\tName string\n\t}\n\n\tvar (\n\t\tf1 = Foo{ID: 1, Name: \"hello\"}\n\t\tf2 = Foo{ID: 1, Name: \"hello\"}\n\t)\n\n\t// [2]Foo -> map[Foo]struct{}\n\tarray := [2]Foo{f1, f2}\n\n\tresultOfArray := ToSet(array)\n\tis.True(reflect.TypeOf(resultOfArray).Kind() == reflect.Map)\n\n\tsetFromArray, ok := resultOfArray.(map[Foo]struct{})\n\tis.True(ok)\n\tis.True(len(setFromArray) == 1)\n\n\tfor k, v := range setFromArray {\n\t\tis.True(reflect.TypeOf(v).Size() == 0)\n\t\tis.True(k == f1)\n\t}\n\n\t// []*Foo -> map[*Foo]struct{}\n\tslice := []*Foo{&f1, &f2, &f1, &f2}\n\n\tresultOfSlice := ToSet(slice)\n\tis.True(reflect.TypeOf(resultOfSlice).Kind() == reflect.Map)\n\n\tsetFromSlice, ok := resultOfSlice.(map[*Foo]struct{})\n\tis.True(ok)\n\tis.True(len(setFromSlice) == 2)\n\n\tfor k, v := range setFromSlice {\n\t\tis.True(reflect.TypeOf(v).Size() == 0)\n\t\tis.True(k == &f1 || k == &f2)\n\t}\n}\n\nfunc TestChunk(t *testing.T) {\n\tis := assert.New(t)\n\n\tresults := Chunk([]int{0, 1, 2, 3, 4}, 2).([][]int)\n\n\tis.Len(results, 3)\n\tis.Len(results[0], 2)\n\tis.Len(results[1], 2)\n\tis.Len(results[2], 1)\n\n\tis.Len(Chunk([]int{}, 2), 0)\n\tis.Len(Chunk([]int{1}, 2), 1)\n\tis.Len(Chunk([]int{1, 2, 3}, 0), 3)\n}\n\nfunc TestFlatten(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Flatten([][][]int{{{1, 2}}, {{3, 4}}}), [][]int{{1, 2}, {3, 4}})\n}\n\nfunc TestFlattenDeep(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(FlattenDeep([][][]int{{{1, 2}}, {{3, 4}}}), []int{1, 2, 3, 4})\n}\n\nfunc TestShuffle(t *testing.T) {\n\tinitial := []int{0, 1, 2, 3, 4}\n\n\tresults := Shuffle(initial)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 5)\n\n\tfor _, entry := range initial {\n\t\tis.True(Contains(results, entry))\n\t}\n}\n\nfunc TestReverse(t *testing.T) {\n\tresults := Reverse([]int{0, 1, 2, 3, 4})\n\n\tis := assert.New(t)\n\n\tis.Equal(Reverse(\"abcdefg\"), \"gfedcba\")\n\tis.Len(results, 5)\n\n\tis.Equal(results, []int{4, 3, 2, 1, 0})\n}\n\nfunc TestUniq(t *testing.T) {\n\tis := assert.New(t)\n\n\tresults := Uniq([]int{0, 1, 1, 2, 3, 0, 0, 12})\n\tis.Len(results, 5)\n\tis.Equal(results, []int{0, 1, 2, 3, 12})\n\n\tresults = Uniq([]string{\"foo\", \"bar\", \"foo\", \"bar\", \"bar\"})\n\tis.Len(results, 2)\n\tis.Equal(results, []string{\"foo\", \"bar\"})\n}\n\nfunc TestUniqBy(t *testing.T) {\n\tis := assert.New(t)\n\n\tresults := UniqBy([]int{0, 1, 1, 2, 3, 0, 0, 12}, func(nbr int) int {\n\t\treturn nbr % 3\n\t})\n\tfmt.Println(results)\n\tis.Len(results, 3)\n\tis.Equal(results, []int{0, 1, 2})\n\n\ttype foobar struct {\n\t\tfoo string\n\t\tbar string\n\t}\n\n\tfoobar1 := foobar{\n\t\tfoo: \"foo\",\n\t\tbar: \"bar\",\n\t}\n\tfoobar2 := foobar{\n\t\tfoo: \"foo\",\n\t\tbar: \"baz\",\n\t}\n\tfoobar3 := foobar{\n\t\tfoo: \"foo\",\n\t\tbar: \"bar\",\n\t}\n\n\tresults = UniqBy([]foobar{foobar1, foobar2, foobar3}, func(f foobar) string {\n\t\treturn f.foo + f.bar\n\t})\n\tis.Len(results, 2)\n\tis.Equal(results, []foobar{foobar1, foobar2})\n}\n\nfunc TestConvertSlice(t *testing.T) {\n\tinstances := []*Foo{foo, foo2}\n\n\tvar raw []Model\n\n\tConvertSlice(instances, &raw)\n\n\tis := assert.New(t)\n\n\tis.Len(raw, len(instances))\n}\n\nfunc TestDrop(t *testing.T) {\n\tresults := Drop([]int{0, 1, 1, 2, 3, 0, 0, 12}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 5)\n\n\tis.Equal([]int{2, 3, 0, 0, 12}, results)\n}\n\nfunc TestPrune(t *testing.T) {\n\ttestCases := []struct {\n\t\tOriginalFoo *Foo\n\t\tPaths       []string\n\t\tExpectedFoo *Foo\n\t}{\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"FirstName\"},\n\t\t\t&Foo{\n\t\t\t\tFirstName: foo.FirstName,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"FirstName\", \"ID\"},\n\t\t\t&Foo{\n\t\t\t\tFirstName: foo.FirstName,\n\t\t\t\tID:        foo.ID,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"EmptyValue.Int64\"},\n\t\t\t&Foo{\n\t\t\t\tEmptyValue: sql.NullInt64{\n\t\t\t\t\tInt64: foo.EmptyValue.Int64,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"FirstName\", \"ID\", \"EmptyValue.Int64\"},\n\t\t\t&Foo{\n\t\t\t\tFirstName: foo.FirstName,\n\t\t\t\tID:        foo.ID,\n\t\t\t\tEmptyValue: sql.NullInt64{\n\t\t\t\t\tInt64: foo.EmptyValue.Int64,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"FirstName\", \"ID\", \"EmptyValue.Int64\"},\n\t\t\t&Foo{\n\t\t\t\tFirstName: foo.FirstName,\n\t\t\t\tID:        foo.ID,\n\t\t\t\tEmptyValue: sql.NullInt64{\n\t\t\t\t\tInt64: foo.EmptyValue.Int64,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"FirstName\", \"ID\", \"Bar\"},\n\t\t\t&Foo{\n\t\t\t\tFirstName: foo.FirstName,\n\t\t\t\tID:        foo.ID,\n\t\t\t\tBar:       foo.Bar,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"Bar\", \"Bars\"},\n\t\t\t&Foo{\n\t\t\t\tBar:  foo.Bar,\n\t\t\t\tBars: foo.Bars,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"FirstName\", \"Bars.Name\"},\n\t\t\t&Foo{\n\t\t\t\tFirstName: foo.FirstName,\n\t\t\t\tBars: []*Bar{\n\t\t\t\t\t{Name: bar.Name},\n\t\t\t\t\t{Name: bar.Name},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"Bars.Name\", \"Bars.Bars.Name\"},\n\t\t\t&Foo{\n\t\t\t\tBars: []*Bar{\n\t\t\t\t\t{Name: bar.Name, Bars: []*Bar{{Name: \"Level1-1\"}, {Name: \"Level1-2\"}}},\n\t\t\t\t\t{Name: bar.Name, Bars: []*Bar{{Name: \"Level1-1\"}, {Name: \"Level1-2\"}}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"BarInterface\", \"BarPointer\"},\n\t\t\t&Foo{\n\t\t\t\tBarInterface: bar,\n\t\t\t\tBarPointer:   &bar,\n\t\t\t},\n\t\t},\n\t}\n\n\t// pass to prune by pointer to struct\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Prune pointer test case #%v\", idx), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\tres, err := Prune(tc.OriginalFoo, tc.Paths)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tfooPrune := res.(*Foo)\n\t\t\tis.Equal(tc.ExpectedFoo, fooPrune)\n\t\t})\n\t}\n\n\t// pass to prune by struct directly\n\tfor idx, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Prune non pointer test case #%v\", idx), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\tfooNonPtr := *tc.OriginalFoo\n\t\t\tres, err := Prune(fooNonPtr, tc.Paths)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tfooPrune := res.(Foo)\n\t\t\tis.Equal(*tc.ExpectedFoo, fooPrune)\n\t\t})\n\t}\n\n\t// test PruneByTag\n\tTagTestCases := []struct {\n\t\tOriginalFoo *Foo\n\t\tPaths       []string\n\t\tExpectedFoo *Foo\n\t\tTag         string\n\t}{\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"tag 1\", \"tag 4.BarName\"},\n\t\t\t&Foo{\n\t\t\t\tFirstName: foo.FirstName,\n\t\t\t\tBar: &Bar{\n\t\t\t\t\tName: bar.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"tag_name\",\n\t\t},\n\t}\n\n\tfor idx, tc := range TagTestCases {\n\t\tt.Run(fmt.Sprintf(\"PruneByTag test case #%v\", idx), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\tfooNonPtr := *tc.OriginalFoo\n\t\t\tres, err := PruneByTag(fooNonPtr, tc.Paths, tc.Tag)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tfooPrune := res.(Foo)\n\t\t\tis.Equal(*tc.ExpectedFoo, fooPrune)\n\t\t})\n\t}\n\n\tt.Run(\"Bar Slice\", func(t *testing.T) {\n\t\tbarSlice := []*Bar{bar, bar}\n\t\tbarSlicePruned, err := pruneByTag(barSlice, []string{\"Name\"}, nil /*tag*/)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, []*Bar{{Name: bar.Name}, {Name: bar.Name}}, barSlicePruned)\n\t})\n\n\tt.Run(\"Bar Array\", func(t *testing.T) {\n\t\tbarArr := [2]*Bar{bar, bar}\n\t\tbarArrPruned, err := pruneByTag(barArr, []string{\"Name\"}, nil /*tag*/)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, [2]*Bar{{Name: bar.Name}, {Name: bar.Name}}, barArrPruned)\n\t})\n\n\t// test values are copied and not referenced in return result\n\t// NOTE: pointers at the end of path are referenced. Maybe we need to make a copy\n\tt.Run(\"Copy Value Str\", func(t *testing.T) {\n\t\tis := assert.New(t)\n\t\tfooTest := &Foo{\n\t\t\tBar: &Bar{\n\t\t\t\tName: \"bar\",\n\t\t\t},\n\t\t}\n\t\tres, err := pruneByTag(fooTest, []string{\"Bar.Name\"}, nil)\n\t\trequire.NoError(t, err)\n\t\tfooTestPruned := res.(*Foo)\n\t\tis.Equal(fooTest, fooTestPruned)\n\n\t\t// change pruned\n\t\tfooTestPruned.Bar.Name = \"changed bar\"\n\t\t// check original is unchanged\n\t\tis.Equal(fooTest.Bar.Name, \"bar\")\n\t})\n\n\t// error cases\n\terrCases := []struct {\n\t\tInputFoo *Foo\n\t\tPaths    []string\n\t\tTagName  *string\n\t}{\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"NotExist\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"FirstName.NotExist\", \"LastName\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"LastName\", \"FirstName.NotExist\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"LastName\", \"Bars.NotExist\"},\n\t\t\tnil,\n\t\t},\n\t\t// tags\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"tag 999\"},\n\t\t\t&[]string{\"tag_name\"}[0],\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"tag 1.NotExist\"},\n\t\t\t&[]string{\"tag_name\"}[0],\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"tag 4.NotExist\"},\n\t\t\t&[]string{\"tag_name\"}[0],\n\t\t},\n\t\t{\n\t\t\tfoo,\n\t\t\t[]string{\"FirstName\"},\n\t\t\t&[]string{\"tag_name_not_exist\"}[0],\n\t\t},\n\t}\n\n\tfor idx, errTC := range errCases {\n\t\tt.Run(fmt.Sprintf(\"error test case #%v\", idx), func(t *testing.T) {\n\t\t\t_, err := pruneByTag(errTC.InputFoo, errTC.Paths, errTC.TagName)\n\t\t\tassert.Error(t, err)\n\t\t})\n\t}\n}\n\nfunc ExamplePrune() {\n\ttype ExampleFoo struct {\n\t\tExampleFooPtr *ExampleFoo `json:\"example_foo_ptr\"`\n\t\tName          string      `json:\"name\"`\n\t\tNumber        int         `json:\"number\"`\n\t}\n\n\texampleFoo := ExampleFoo{\n\t\tExampleFooPtr: &ExampleFoo{\n\t\t\tName:   \"ExampleFooPtr\",\n\t\t\tNumber: 2,\n\t\t},\n\t\tName:   \"ExampleFoo\",\n\t\tNumber: 1,\n\t}\n\n\t// prune using struct field name\n\tres, _ := Prune(exampleFoo, []string{\"ExampleFooPtr.Name\", \"Number\"})\n\tprunedFoo := res.(ExampleFoo)\n\tfmt.Println(prunedFoo.ExampleFooPtr.Name)\n\tfmt.Println(prunedFoo.ExampleFooPtr.Number)\n\tfmt.Println(prunedFoo.Name)\n\tfmt.Println(prunedFoo.Number)\n\n\t// prune using struct json tag\n\tres2, _ := PruneByTag(exampleFoo, []string{\"example_foo_ptr.name\", \"number\"}, \"json\")\n\tprunedByTagFoo := res2.(ExampleFoo)\n\tfmt.Println(prunedByTagFoo.ExampleFooPtr.Name)\n\tfmt.Println(prunedByTagFoo.ExampleFooPtr.Number)\n\tfmt.Println(prunedByTagFoo.Name)\n\tfmt.Println(prunedByTagFoo.Number)\n\t// output:\n\t// ExampleFooPtr\n\t// 0\n\t//\n\t// 1\n\t// ExampleFooPtr\n\t// 0\n\t//\n\t// 1\n}\n"
        },
        {
          "name": "typesafe.go",
          "type": "blob",
          "size": 26.9755859375,
          "content": "package funk\n\nimport (\n\t\"math/rand\"\n)\n\n// InBools is an alias of ContainsBool, returns true if a bool is present in a iteratee.\nfunc InBools(s []bool, v bool) bool {\n\treturn ContainsBool(s, v)\n}\n\n// InInts is an alias of ContainsInt, returns true if an int is present in a iteratee.\nfunc InInts(s []int, v int) bool {\n\treturn ContainsInt(s, v)\n}\n\n// InInt32s is an alias of ContainsInt32, returns true if an int32 is present in a iteratee.\nfunc InInt32s(s []int32, v int32) bool {\n\treturn ContainsInt32(s, v)\n}\n\n// InInt64s is an alias of ContainsInt64, returns true if an int64 is present in a iteratee.\nfunc InInt64s(s []int64, v int64) bool {\n\treturn ContainsInt64(s, v)\n}\n\n// InUInts is an alias of ContainsUInt, returns true if an uint is present in a iteratee.\nfunc InUInts(s []uint, v uint) bool {\n\treturn ContainsUInt(s, v)\n}\n\n// InUInt32s is an alias of ContainsUInt32, returns true if an uint32 is present in a iteratee.\nfunc InUInt32s(s []uint32, v uint32) bool {\n\treturn ContainsUInt32(s, v)\n}\n\n// InUInt64s is an alias of ContainsUInt64, returns true if an uint64 is present in a iteratee.\nfunc InUInt64s(s []uint64, v uint64) bool {\n\treturn ContainsUInt64(s, v)\n}\n\n// InStrings is an alias of ContainsString, returns true if a string is present in a iteratee.\nfunc InStrings(s []string, v string) bool {\n\treturn ContainsString(s, v)\n}\n\n// InFloat32s is an alias of ContainsFloat32, returns true if a float32 is present in a iteratee.\nfunc InFloat32s(s []float32, v float32) bool {\n\treturn ContainsFloat32(s, v)\n}\n\n// InFloat64s is an alias of ContainsFloat64, returns true if a float64 is present in a iteratee.\nfunc InFloat64s(s []float64, v float64) bool {\n\treturn ContainsFloat64(s, v)\n}\n\n// FindFloat64 iterates over a collection of float64, returning an array of\n// all float64 elements predicate returns truthy for.\nfunc FindFloat64(s []float64, cb func(s float64) bool) (float64, bool) {\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn 0.0, false\n}\n\n// FindFloat32 iterates over a collection of float32, returning the first\n// float32 element predicate returns truthy for.\nfunc FindFloat32(s []float32, cb func(s float32) bool) (float32, bool) {\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn 0.0, false\n}\n\n// FindInt iterates over a collection of int, returning the first\n// int element predicate returns truthy for.\nfunc FindInt(s []int, cb func(s int) bool) (int, bool) {\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn 0, false\n}\n\n// FindInt32 iterates over a collection of int32, returning the first\n// int32 element predicate returns truthy for.\nfunc FindInt32(s []int32, cb func(s int32) bool) (int32, bool) {\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn 0, false\n}\n\n// FindInt64 iterates over a collection of int64, returning the first\n// int64 element predicate returns truthy for.\nfunc FindInt64(s []int64, cb func(s int64) bool) (int64, bool) {\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn 0, false\n}\n\n// FindString iterates over a collection of string, returning the first\n// string element predicate returns truthy for.\nfunc FindString(s []string, cb func(s string) bool) (string, bool) {\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\treturn i, true\n\t\t}\n\t}\n\n\treturn \"\", false\n}\n\n// FilterBool iterates over a collection of bool, returning an array of\n// all bool elements predicate returns truthy for.\nfunc FilterBool(s []bool, cb func(s bool) bool) []bool {\n\tresults := []bool{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// FilterFloat64 iterates over a collection of float64, returning an array of\n// all float64 elements predicate returns truthy for.\nfunc FilterFloat64(s []float64, cb func(s float64) bool) []float64 {\n\tresults := []float64{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// FilterFloat32 iterates over a collection of float32, returning an array of\n// all float32 elements predicate returns truthy for.\nfunc FilterFloat32(s []float32, cb func(s float32) bool) []float32 {\n\tresults := []float32{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// FilterInt iterates over a collection of int, returning an array of\n// all int elements predicate returns truthy for.\nfunc FilterInt(s []int, cb func(s int) bool) []int {\n\tresults := []int{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// FilterInt32 iterates over a collection of int32, returning an array of\n// all int32 elements predicate returns truthy for.\nfunc FilterInt32(s []int32, cb func(s int32) bool) []int32 {\n\tresults := []int32{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// FilterInt64 iterates over a collection of int64, returning an array of\n// all int64 elements predicate returns truthy for.\nfunc FilterInt64(s []int64, cb func(s int64) bool) []int64 {\n\tresults := []int64{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// FilterUInt iterates over a collection of uint, returning an array of\n// all uint elements predicate returns truthy for.\nfunc FilterUInt(s []uint, cb func(s uint) bool) []uint {\n\tresults := []uint{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// FilterUInt32 iterates over a collection of uint32, returning an array of\n// all uint32 elements predicate returns truthy for.\nfunc FilterUInt32(s []uint32, cb func(s uint32) bool) []uint32 {\n\tresults := []uint32{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// FilterUInt64 iterates over a collection of uint64, returning an array of\n// all uint64 elements predicate returns truthy for.\nfunc FilterUInt64(s []uint64, cb func(s uint64) bool) []uint64 {\n\tresults := []uint64{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// FilterString iterates over a collection of string, returning an array of\n// all string elements predicate returns truthy for.\nfunc FilterString(s []string, cb func(s string) bool) []string {\n\tresults := []string{}\n\n\tfor _, i := range s {\n\t\tresult := cb(i)\n\n\t\tif result {\n\t\t\tresults = append(results, i)\n\t\t}\n\t}\n\n\treturn results\n}\n\n// ContainsBool returns true if a boolean is present in a iteratee.\nfunc ContainsBool(s []bool, v bool) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ContainsInt returns true if an int is present in a iteratee.\nfunc ContainsInt(s []int, v int) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ContainsInt32 returns true if an int32 is present in a iteratee.\nfunc ContainsInt32(s []int32, v int32) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ContainsInt64 returns true if an int64 is present in a iteratee.\nfunc ContainsInt64(s []int64, v int64) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ContainsUInt returns true if an uint is present in a iteratee.\nfunc ContainsUInt(s []uint, v uint) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ContainsUInt32 returns true if an uint32 is present in a iteratee.\nfunc ContainsUInt32(s []uint32, v uint32) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ContainsUInt64 returns true if an uint64 is present in a iteratee.\nfunc ContainsUInt64(s []uint64, v uint64) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ContainsString returns true if a string is present in a iteratee.\nfunc ContainsString(s []string, v string) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ContainsFloat32 returns true if a float32 is present in a iteratee.\nfunc ContainsFloat32(s []float32, v float32) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ContainsFloat64 returns true if a float64 is present in a iteratee.\nfunc ContainsFloat64(s []float64, v float64) bool {\n\tfor _, vv := range s {\n\t\tif vv == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// SumInt32 sums a int32 iteratee and returns the sum of all elements\nfunc SumInt32(s []int32) (sum int32) {\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn\n}\n\n// SumInt64 sums a int64 iteratee and returns the sum of all elements\nfunc SumInt64(s []int64) (sum int64) {\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn\n}\n\n// SumInt sums a int iteratee and returns the sum of all elements\nfunc SumInt(s []int) (sum int) {\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn\n}\n\n// SumUInt32 sums a uint32 iteratee and returns the sum of all elements\nfunc SumUInt32(s []uint32) (sum uint32) {\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn\n}\n\n// SumUInt64 sums a uint64 iteratee and returns the sum of all elements\nfunc SumUInt64(s []uint64) (sum uint64) {\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn\n}\n\n// SumUInt sums a uint iteratee and returns the sum of all elements\nfunc SumUInt(s []uint) (sum uint) {\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn\n}\n\n// SumFloat64 sums a float64 iteratee and returns the sum of all elements\nfunc SumFloat64(s []float64) (sum float64) {\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn\n}\n\n// SumFloat32 sums a float32 iteratee and returns the sum of all elements\nfunc SumFloat32(s []float32) (sum float32) {\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn\n}\n\n// ReverseBools reverses an array of bool\nfunc ReverseBools(s []bool) []bool {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseStrings reverses an array of string\nfunc ReverseStrings(s []string) []string {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseInt reverses an array of int\nfunc ReverseInt(s []int) []int {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseInt32 reverses an array of int32\nfunc ReverseInt32(s []int32) []int32 {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseInt64 reverses an array of int64\nfunc ReverseInt64(s []int64) []int64 {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseUInt reverses an array of int\nfunc ReverseUInt(s []uint) []uint {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseUInt32 reverses an array of uint32\nfunc ReverseUInt32(s []uint32) []uint32 {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseUInt64 reverses an array of uint64\nfunc ReverseUInt64(s []uint64) []uint64 {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseFloat64 reverses an array of float64\nfunc ReverseFloat64(s []float64) []float64 {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseFloat32 reverses an array of float32\nfunc ReverseFloat32(s []float32) []float32 {\n\tfor i, j := 0, len(s)-1; i < len(s)/2; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\n// ReverseString reverses a string\nfunc ReverseString(s string) string {\n\tr := []rune(s)\n\tfor i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n\t\tr[i], r[j] = r[j], r[i]\n\t}\n\treturn string(r)\n}\n\nfunc indexOf(n int, f func(int) bool) int {\n\tfor i := 0; i < n; i++ {\n\t\tif f(i) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// IndexOfBool gets the index at which the first occurrence of a bool value is found in array or return -1\n// if the value cannot be found\nfunc IndexOfBool(a []bool, x bool) int {\n\treturn indexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// IndexOfInt gets the index at which the first occurrence of an int value is found in array or return -1\n// if the value cannot be found\nfunc IndexOfInt(a []int, x int) int {\n\treturn indexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// IndexOfInt32 gets the index at which the first occurrence of an int32 value is found in array or return -1\n// if the value cannot be found\nfunc IndexOfInt32(a []int32, x int32) int {\n\treturn indexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// IndexOfInt64 gets the index at which the first occurrence of an int64 value is found in array or return -1\n// if the value cannot be found\nfunc IndexOfInt64(a []int64, x int64) int {\n\treturn indexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// IndexOfUInt gets the index at which the first occurrence of an uint value is found in array or return -1\n// if the value cannot be found\nfunc IndexOfUInt(a []uint, x uint) int {\n\treturn indexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// IndexOfUInt32 gets the index at which the first occurrence of an uint32 value is found in array or return -1\n// if the value cannot be found\nfunc IndexOfUInt32(a []uint32, x uint32) int {\n\treturn indexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// IndexOfUInt64 gets the index at which the first occurrence of an uint64 value is found in array or return -1\n// if the value cannot be found\nfunc IndexOfUInt64(a []uint64, x uint64) int {\n\treturn indexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// IndexOfFloat64 gets the index at which the first occurrence of an float64 value is found in array or return -1\n// if the value cannot be found\nfunc IndexOfFloat64(a []float64, x float64) int {\n\treturn indexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// IndexOfString gets the index at which the first occurrence of a string value is found in array or return -1\n// if the value cannot be found\nfunc IndexOfString(a []string, x string) int {\n\treturn indexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\nfunc lastIndexOf(n int, f func(int) bool) int {\n\tfor i := n - 1; i >= 0; i-- {\n\t\tif f(i) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// LastIndexOfBool gets the index at which the first occurrence of a bool value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfBool(a []bool, x bool) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// LastIndexOfInt gets the index at which the first occurrence of an int value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfInt(a []int, x int) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// LastIndexOfInt32 gets the index at which the first occurrence of an int32 value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfInt32(a []int32, x int32) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// LastIndexOfInt64 gets the index at which the first occurrence of an int64 value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfInt64(a []int64, x int64) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// LastIndexOfUInt gets the index at which the first occurrence of an uint value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfUInt(a []uint, x uint) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// LastIndexOfUInt32 gets the index at which the first occurrence of an uint32 value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfUInt32(a []uint32, x uint32) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// LastIndexOfUInt64 gets the index at which the first occurrence of an uint64 value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfUInt64(a []uint64, x uint64) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// LastIndexOfFloat64 gets the index at which the first occurrence of an float64 value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfFloat64(a []float64, x float64) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// LastIndexOfFloat32 gets the index at which the first occurrence of an float32 value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfFloat32(a []float32, x float32) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// LastIndexOfString gets the index at which the first occurrence of a string value is found in array or return -1\n// if the value cannot be found\nfunc LastIndexOfString(a []string, x string) int {\n\treturn lastIndexOf(len(a), func(i int) bool { return a[i] == x })\n}\n\n// UniqBool creates an array of bool with unique values.\nfunc UniqBool(a []bool) []bool {\n\tresults := []bool{}\n\tfor _, value := range a {\n\t\t// If results is not empty, there is at most 1 value in it\n\t\tif len(results) == 0 || results[0] != value {\n\t\t\tresults = append(results, value)\n\t\t}\n\t\t// At most 2 unique values\n\t\tif len(results) == 2 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn results\n}\n\n// UniqInt32 creates an array of int32 with unique values.\nfunc UniqInt32(a []int32) []int32 {\n\tvar (\n\t\tlength  = len(a)\n\t\tseen    = make(map[int32]struct{}, length)\n\t\tresults = make([]int32, 0)\n\t)\n\n\tfor i := 0; i < length; i++ {\n\t\tv := a[i]\n\n\t\tif _, ok := seen[v]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[v] = struct{}{}\n\t\tresults = append(results, v)\n\t}\n\n\treturn results\n}\n\n// UniqInt64 creates an array of int64 with unique values.\nfunc UniqInt64(a []int64) []int64 {\n\tvar (\n\t\tlength  = len(a)\n\t\tseen    = make(map[int64]struct{}, length)\n\t\tresults = make([]int64, 0)\n\t)\n\n\tfor i := 0; i < length; i++ {\n\t\tv := a[i]\n\n\t\tif _, ok := seen[v]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[v] = struct{}{}\n\t\tresults = append(results, v)\n\t}\n\n\treturn results\n}\n\n// UniqInt creates an array of int with unique values.\nfunc UniqInt(a []int) []int {\n\tvar (\n\t\tlength  = len(a)\n\t\tseen    = make(map[int]struct{}, length)\n\t\tresults = make([]int, 0)\n\t)\n\n\tfor i := 0; i < length; i++ {\n\t\tv := a[i]\n\n\t\tif _, ok := seen[v]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[v] = struct{}{}\n\t\tresults = append(results, v)\n\t}\n\n\treturn results\n}\n\n// UniqUInt32 creates an array of uint32 with unique values.\nfunc UniqUInt32(a []uint32) []uint32 {\n\tvar (\n\t\tlength  = len(a)\n\t\tseen    = make(map[uint32]struct{}, length)\n\t\tresults = make([]uint32, 0)\n\t)\n\n\tfor i := 0; i < length; i++ {\n\t\tv := a[i]\n\n\t\tif _, ok := seen[v]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[v] = struct{}{}\n\t\tresults = append(results, v)\n\t}\n\n\treturn results\n}\n\n// UniqUInt64 creates an array of uint64 with unique values.\nfunc UniqUInt64(a []uint64) []uint64 {\n\tvar (\n\t\tlength  = len(a)\n\t\tseen    = make(map[uint64]struct{}, length)\n\t\tresults = make([]uint64, 0)\n\t)\n\n\tfor i := 0; i < length; i++ {\n\t\tv := a[i]\n\n\t\tif _, ok := seen[v]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[v] = struct{}{}\n\t\tresults = append(results, v)\n\t}\n\n\treturn results\n}\n\n// UniqUInt creates an array of uint with unique values.\nfunc UniqUInt(a []uint) []uint {\n\tvar (\n\t\tlength  = len(a)\n\t\tseen    = make(map[uint]struct{}, length)\n\t\tresults = make([]uint, 0)\n\t)\n\n\tfor i := 0; i < length; i++ {\n\t\tv := a[i]\n\n\t\tif _, ok := seen[v]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[v] = struct{}{}\n\t\tresults = append(results, v)\n\t}\n\n\treturn results\n}\n\n// UniqString creates an array of string with unique values.\nfunc UniqString(a []string) []string {\n\tvar (\n\t\tlength  = len(a)\n\t\tseen    = make(map[string]struct{}, length)\n\t\tresults = make([]string, 0)\n\t)\n\n\tfor i := 0; i < length; i++ {\n\t\tv := a[i]\n\n\t\tif _, ok := seen[v]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[v] = struct{}{}\n\t\tresults = append(results, v)\n\t}\n\n\treturn results\n}\n\n// UniqFloat64 creates an array of float64 with unique values.\nfunc UniqFloat64(a []float64) []float64 {\n\tvar (\n\t\tlength  = len(a)\n\t\tseen    = make(map[float64]struct{}, length)\n\t\tresults = make([]float64, 0)\n\t)\n\n\tfor i := 0; i < length; i++ {\n\t\tv := a[i]\n\n\t\tif _, ok := seen[v]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[v] = struct{}{}\n\t\tresults = append(results, v)\n\t}\n\n\treturn results\n}\n\n// UniqFloat32 creates an array of float32 with unique values.\nfunc UniqFloat32(a []float32) []float32 {\n\tvar (\n\t\tlength  = len(a)\n\t\tseen    = make(map[float32]struct{}, length)\n\t\tresults = make([]float32, 0)\n\t)\n\n\tfor i := 0; i < length; i++ {\n\t\tv := a[i]\n\n\t\tif _, ok := seen[v]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[v] = struct{}{}\n\t\tresults = append(results, v)\n\t}\n\n\treturn results\n}\n\n// ShuffleBool creates an array of bool shuffled values using Fisher–Yates algorithm\nfunc ShuffleBool(a []bool) []bool {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// ShuffleInt creates an array of int shuffled values using Fisher–Yates algorithm\nfunc ShuffleInt(a []int) []int {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// ShuffleInt32 creates an array of int32 shuffled values using Fisher–Yates algorithm\nfunc ShuffleInt32(a []int32) []int32 {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// ShuffleInt64 creates an array of int64 shuffled values using Fisher–Yates algorithm\nfunc ShuffleInt64(a []int64) []int64 {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// ShuffleUInt creates an array of int shuffled values using Fisher–Yates algorithm\nfunc ShuffleUInt(a []uint) []uint {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// ShuffleUInt32 creates an array of uint32 shuffled values using Fisher–Yates algorithm\nfunc ShuffleUInt32(a []uint32) []uint32 {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// ShuffleUInt64 creates an array of uint64 shuffled values using Fisher–Yates algorithm\nfunc ShuffleUInt64(a []uint64) []uint64 {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// ShuffleString creates an array of string shuffled values using Fisher–Yates algorithm\nfunc ShuffleString(a []string) []string {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// ShuffleFloat32 creates an array of float32 shuffled values using Fisher–Yates algorithm\nfunc ShuffleFloat32(a []float32) []float32 {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// ShuffleFloat64 creates an array of float64 shuffled values using Fisher–Yates algorithm\nfunc ShuffleFloat64(a []float64) []float64 {\n\tfor i := range a {\n\t\tj := rand.Intn(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\n\treturn a\n}\n\n// DropBool creates a slice with `n` bools dropped from the beginning.\nfunc DropBool(s []bool, n int) []bool {\n\treturn s[n:]\n}\n\n// DropString creates a slice with `n` strings dropped from the beginning.\nfunc DropString(s []string, n int) []string {\n\treturn s[n:]\n}\n\n// DropInt creates a slice with `n` ints dropped from the beginning.\nfunc DropInt(s []int, n int) []int {\n\treturn s[n:]\n}\n\n// DropInt32 creates a slice with `n` int32s dropped from the beginning.\nfunc DropInt32(s []int32, n int) []int32 {\n\treturn s[n:]\n}\n\n// DropInt64 creates a slice with `n` int64s dropped from the beginning.\nfunc DropInt64(s []int64, n int) []int64 {\n\treturn s[n:]\n}\n\n// DropUInt creates a slice with `n` ints dropped from the beginning.\nfunc DropUInt(s []uint, n uint) []uint {\n\treturn s[n:]\n}\n\n// DropUInt32 creates a slice with `n` int32s dropped from the beginning.\nfunc DropUInt32(s []uint32, n int) []uint32 {\n\treturn s[n:]\n}\n\n// DropUInt64 creates a slice with `n` int64s dropped from the beginning.\nfunc DropUInt64(s []uint64, n int) []uint64 {\n\treturn s[n:]\n}\n\n// DropFloat32 creates a slice with `n` float32s dropped from the beginning.\nfunc DropFloat32(s []float32, n int) []float32 {\n\treturn s[n:]\n}\n\n// DropFloat64 creates a slice with `n` float64s dropped from the beginning.\nfunc DropFloat64(s []float64, n int) []float64 {\n\treturn s[n:]\n}\n\n// ChunkStrings creates an array of strings split into groups with the length of size.\n// If array can't be split evenly, the final chunk will be\n// the remaining element.\nfunc ChunkStrings(arr []string, size int) [][]string {\n\tvar results [][]string\n\n\tfor i := 0; i < len(arr); i += size {\n\t\tend := i + size\n\n\t\tif end > len(arr) {\n\t\t\tend = len(arr)\n\t\t}\n\n\t\tresults = append(results, arr[i:end])\n\t}\n\n\treturn results\n}\n\n// ChunkInts creates an array of ints split into groups with the length of size.\n// If array can't be split evenly, the final chunk will be\n// the remaining element.\nfunc ChunkInts(arr []int, size int) [][]int {\n\tvar results [][]int\n\n\tfor i := 0; i < len(arr); i += size {\n\t\tend := i + size\n\n\t\tif end > len(arr) {\n\t\t\tend = len(arr)\n\t\t}\n\n\t\tresults = append(results, arr[i:end])\n\t}\n\n\treturn results\n}\n\n// ChunkInt32s creates an array of int32s split into groups with the length of size.\n// If array can't be split evenly, the final chunk will be\n// the remaining element.\nfunc ChunkInt32s(arr []int32, size int) [][]int32 {\n\tvar results [][]int32\n\n\tfor i := 0; i < len(arr); i += size {\n\t\tend := i + size\n\n\t\tif end > len(arr) {\n\t\t\tend = len(arr)\n\t\t}\n\n\t\tresults = append(results, arr[i:end])\n\t}\n\n\treturn results\n}\n\n// ChunkInt64s creates an array of int64s split into groups with the length of size.\n// If array can't be split evenly, the final chunk will be\n// the remaining element.\nfunc ChunkInt64s(arr []int64, size int) [][]int64 {\n\tvar results [][]int64\n\n\tfor i := 0; i < len(arr); i += size {\n\t\tend := i + size\n\n\t\tif end > len(arr) {\n\t\t\tend = len(arr)\n\t\t}\n\n\t\tresults = append(results, arr[i:end])\n\t}\n\n\treturn results\n}\n\n// ChunkUInts creates an array of uints split into groups with the length of size.\n// If array can't be split evenly, the final chunk will be\n// the remaining element.\nfunc ChunkUInts(arr []uint, size int) [][]uint {\n\tvar results [][]uint\n\n\tfor i := 0; i < len(arr); i += size {\n\t\tend := i + size\n\n\t\tif end > len(arr) {\n\t\t\tend = len(arr)\n\t\t}\n\n\t\tresults = append(results, arr[i:end])\n\t}\n\n\treturn results\n}\n\n// ChunkUInt32s creates an array of uint32s split into groups with the length of size.\n// If array can't be split evenly, the final chunk will be\n// the remaining element.\nfunc ChunkUInt32s(arr []uint32, size int) [][]uint32 {\n\tvar results [][]uint32\n\n\tfor i := 0; i < len(arr); i += size {\n\t\tend := i + size\n\n\t\tif end > len(arr) {\n\t\t\tend = len(arr)\n\t\t}\n\n\t\tresults = append(results, arr[i:end])\n\t}\n\n\treturn results\n}\n\n// ChunkUInt64s creates an array of uint64s split into groups with the length of size.\n// If array can't be split evenly, the final chunk will be\n// the remaining element.\nfunc ChunkUInt64s(arr []uint64, size int) [][]uint64 {\n\tvar results [][]uint64\n\n\tfor i := 0; i < len(arr); i += size {\n\t\tend := i + size\n\n\t\tif end > len(arr) {\n\t\t\tend = len(arr)\n\t\t}\n\n\t\tresults = append(results, arr[i:end])\n\t}\n\n\treturn results\n}\n\n// ChunkFloat64s creates an array of float64s split into groups with the length of size.\n// If array can't be split evenly, the final chunk will be\n// the remaining element.\nfunc ChunkFloat64s(arr []float64, size int) [][]float64 {\n\tvar results [][]float64\n\n\tfor i := 0; i < len(arr); i += size {\n\t\tend := i + size\n\n\t\tif end > len(arr) {\n\t\t\tend = len(arr)\n\t\t}\n\n\t\tresults = append(results, arr[i:end])\n\t}\n\n\treturn results\n}\n"
        },
        {
          "name": "typesafe_test.go",
          "type": "blob",
          "size": 8.087890625,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestContainsBool(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(ContainsBool([]bool{true, false}, true))\n\tis.False(ContainsBool([]bool{true}, false))\n}\n\nfunc TestContainsInt(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(ContainsInt([]int{1, 2, 3, 4}, 4))\n\tis.False(ContainsInt([]int{1, 2, 3, 4}, 5))\n\n\tis.True(ContainsInt32([]int32{1, 2, 3, 4}, 4))\n\tis.False(ContainsInt32([]int32{1, 2, 3, 4}, 5))\n\n\tis.True(ContainsInt64([]int64{1, 2, 3, 4}, 4))\n\tis.False(ContainsInt64([]int64{1, 2, 3, 4}, 5))\n\n\tis.True(ContainsUInt([]uint{1, 2, 3, 4}, 4))\n\tis.False(ContainsUInt([]uint{1, 2, 3, 4}, 5))\n\n\tis.True(ContainsUInt32([]uint32{1, 2, 3, 4}, 4))\n\tis.False(ContainsUInt32([]uint32{1, 2, 3, 4}, 5))\n\n\tis.True(ContainsUInt64([]uint64{1, 2, 3, 4}, 4))\n\tis.False(ContainsUInt64([]uint64{1, 2, 3, 4}, 5))\n}\n\nfunc TestContainsString(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(ContainsString([]string{\"flo\", \"gilles\"}, \"flo\"))\n\tis.False(ContainsString([]string{\"flo\", \"gilles\"}, \"alex\"))\n}\n\nfunc TestFilterBool(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterBool([]bool{true, true, false, true}, func(x bool) bool {\n\t\treturn x == true\n\t})\n\n\tis.Equal(r, []bool{true, true, true})\n}\n\nfunc TestFilterString(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterString([]string{\"a\", \"b\", \"c\", \"d\"}, func(x string) bool {\n\t\treturn x >= \"c\"\n\t})\n\n\tis.Equal(r, []string{\"c\", \"d\"})\n}\n\nfunc TestFilterInt(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterInt([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(r, []int{2, 4})\n}\n\nfunc TestFilterInt32(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterInt32([]int32{1, 2, 3, 4}, func(x int32) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(r, []int32{2, 4})\n}\n\nfunc TestFilterInt64(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterInt64([]int64{1, 2, 3, 4}, func(x int64) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(r, []int64{2, 4})\n}\n\nfunc TestFilterUInt(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterUInt([]uint{1, 2, 3, 4}, func(x uint) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(r, []uint{2, 4})\n}\n\nfunc TestFilterUInt32(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterUInt32([]uint32{1, 2, 3, 4}, func(x uint32) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(r, []uint32{2, 4})\n}\n\nfunc TestFilterUInt64(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterUInt64([]uint64{1, 2, 3, 4}, func(x uint64) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(r, []uint64{2, 4})\n}\n\nfunc TestFilterFloat64(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterFloat64([]float64{1.0, 2.0, 3.0, 4.0}, func(x float64) bool {\n\t\treturn int(x)%2 == 0\n\t})\n\n\tis.Equal(r, []float64{2.0, 4.0})\n}\n\nfunc TestFilterFloat32(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := FilterFloat32([]float32{1.0, 2.0, 3.0, 4.0}, func(x float32) bool {\n\t\treturn int(x)%2 == 0\n\t})\n\n\tis.Equal(r, []float32{2.0, 4.0})\n}\n\nfunc TestContainsFloat(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(ContainsFloat64([]float64{0.1, 0.2}, 0.1))\n\tis.False(ContainsFloat64([]float64{0.1, 0.2}, 0.3))\n\n\tis.True(ContainsFloat32([]float32{0.1, 0.2}, 0.1))\n\tis.False(ContainsFloat32([]float32{0.1, 0.2}, 0.3))\n}\n\nfunc TestSumNumeral(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(SumInt([]int{1, 2, 3}), 6)\n\tis.Equal(SumInt64([]int64{1, 2, 3}), int64(6))\n\n\tis.Equal(SumUInt([]uint{1, 2, 3}), uint(6))\n\tis.Equal(SumUInt64([]uint64{1, 2, 3}), uint64(6))\n\n\tis.Equal(SumFloat32([]float32{0.1, 0.2, 0.1}), float32(0.4))\n\tis.Equal(SumFloat64([]float64{0.1, 0.2, 0.1}), float64(0.4))\n}\n\nfunc TestTypesafeReverse(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(ReverseBools([]bool{true, false, false}), []bool{false, false, true})\n\tis.Equal(ReverseString(\"abcdefg\"), \"gfedcba\")\n\tis.Equal(ReverseInt([]int{1, 2, 3, 4}), []int{4, 3, 2, 1})\n\tis.Equal(ReverseInt64([]int64{1, 2, 3, 4}), []int64{4, 3, 2, 1})\n\tis.Equal(ReverseUInt([]uint{1, 2, 3, 4}), []uint{4, 3, 2, 1})\n\tis.Equal(ReverseUInt64([]uint64{1, 2, 3, 4}), []uint64{4, 3, 2, 1})\n\tis.Equal(ReverseStrings([]string{\"flo\", \"gilles\"}), []string{\"gilles\", \"flo\"})\n\tis.Equal(ReverseFloat64([]float64{0.1, 0.2, 0.3}), []float64{0.3, 0.2, 0.1})\n\tis.Equal(ReverseFloat32([]float32{0.1, 0.2, 0.3}), []float32{0.3, 0.2, 0.1})\n}\n\nfunc TestTypesafeIndexOf(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(IndexOfBool([]bool{true, false}, false), 1)\n\tis.Equal(IndexOfBool([]bool{true}, false), -1)\n\n\tis.Equal(IndexOfString([]string{\"foo\", \"bar\"}, \"bar\"), 1)\n\tis.Equal(IndexOfString([]string{\"foo\", \"bar\"}, \"flo\"), -1)\n\n\tis.Equal(IndexOfInt([]int{0, 1, 2}, 1), 1)\n\tis.Equal(IndexOfInt([]int{0, 1, 2}, 3), -1)\n\n\tis.Equal(IndexOfInt64([]int64{0, 1, 2}, 1), 1)\n\tis.Equal(IndexOfInt64([]int64{0, 1, 2}, 3), -1)\n\n\tis.Equal(IndexOfUInt64([]uint64{0, 1, 2}, 1), 1)\n\tis.Equal(IndexOfUInt64([]uint64{0, 1, 2}, 3), -1)\n\n\tis.Equal(IndexOfFloat64([]float64{0.1, 0.2, 0.3}, 0.2), 1)\n\tis.Equal(IndexOfFloat64([]float64{0.1, 0.2, 0.3}, 0.4), -1)\n}\n\nfunc TestTypesafeLastIndexOf(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(LastIndexOfBool([]bool{true, true, false, true}, true), 3)\n\tis.Equal(LastIndexOfString([]string{\"foo\", \"bar\", \"bar\"}, \"bar\"), 2)\n\tis.Equal(LastIndexOfInt([]int{1, 2, 2, 3}, 2), 2)\n\tis.Equal(LastIndexOfInt64([]int64{1, 2, 2, 3}, 4), -1)\n\tis.Equal(LastIndexOfUInt([]uint{1, 2, 2, 3}, 2), 2)\n\tis.Equal(LastIndexOfUInt64([]uint64{1, 2, 2, 3}, 4), -1)\n}\n\nfunc TestTypesafeUniq(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(UniqBool([]bool{true, false, false, true, false}), []bool{true, false})\n\tis.Equal(UniqInt64([]int64{0, 1, 1, 2, 3, 0, 0, 12}), []int64{0, 1, 2, 3, 12})\n\tis.Equal(UniqInt([]int{0, 1, 1, 2, 3, 0, 0, 12}), []int{0, 1, 2, 3, 12})\n\tis.Equal(UniqUInt([]uint{0, 1, 1, 2, 3, 0, 0, 12}), []uint{0, 1, 2, 3, 12})\n\tis.Equal(UniqUInt64([]uint64{0, 1, 1, 2, 3, 0, 0, 12}), []uint64{0, 1, 2, 3, 12})\n\tis.Equal(UniqFloat64([]float64{0.0, 0.1, 0.1, 0.2, 0.3, 0.0, 0.0, 0.12}), []float64{0.0, 0.1, 0.2, 0.3, 0.12})\n\tis.Equal(UniqString([]string{\"foo\", \"bar\", \"foo\", \"bar\"}), []string{\"foo\", \"bar\"})\n}\n\nfunc TestTypesafeShuffle(t *testing.T) {\n\tis := assert.New(t)\n\n\tinitial := []int{1, 2, 3, 5}\n\n\tresults := ShuffleInt(initial)\n\n\tis.Len(results, 4)\n\n\tfor _, entry := range initial {\n\t\tis.True(ContainsInt(results, entry))\n\t}\n}\n\nfunc TestDropBool(t *testing.T) {\n\tresults := DropBool([]bool{true, false, false, true, true}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 2)\n\n\tis.Equal([]bool{true, true}, results)\n}\n\nfunc TestDropString(t *testing.T) {\n\tresults := DropString([]string{\"the\", \"quick\", \"brown\", \"fox\", \"jumps\", \"...\"}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 3)\n\n\tis.Equal([]string{\"fox\", \"jumps\", \"...\"}, results)\n}\n\nfunc TestDropInt(t *testing.T) {\n\tresults := DropInt([]int{0, 0, 0, 0}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 1)\n\n\tis.Equal([]int{0}, results)\n}\n\nfunc TestDropInt32(t *testing.T) {\n\tresults := DropInt32([]int32{1, 2, 3, 4}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 1)\n\n\tis.Equal([]int32{4}, results)\n}\n\nfunc TestDropInt64(t *testing.T) {\n\tresults := DropInt64([]int64{1, 2, 3, 4}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 1)\n\n\tis.Equal([]int64{4}, results)\n}\n\nfunc TestDropUInt(t *testing.T) {\n\tresults := DropUInt([]uint{0, 0, 0, 0}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 1)\n\n\tis.Equal([]uint{0}, results)\n}\n\nfunc TestDropUInt32(t *testing.T) {\n\tresults := DropUInt32([]uint32{1, 2, 3, 4}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 1)\n\n\tis.Equal([]uint32{4}, results)\n}\n\nfunc TestDropUInt64(t *testing.T) {\n\tresults := DropUInt64([]uint64{1, 2, 3, 4}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 1)\n\n\tis.Equal([]uint64{4}, results)\n}\n\nfunc TestDropFloat32(t *testing.T) {\n\tresults := DropFloat32([]float32{1.1, 2.2, 3.3, 4.4}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 1)\n\n\tis.Equal([]float32{4.4}, results)\n}\n\nfunc TestDropFloat64(t *testing.T) {\n\tresults := DropFloat64([]float64{1.1, 2.2, 3.3, 4.4}, 3)\n\n\tis := assert.New(t)\n\n\tis.Len(results, 1)\n\n\tis.Equal([]float64{4.4}, results)\n}\n\nfunc TestChunkStrings(t *testing.T) {\n\tis := assert.New(t)\n\n\tresults := ChunkStrings([]string{\"foo\", \"bar\", \"foo\", \"bar\", \"bar\"}, 2)\n\n\tis.Len(results, 3)\n\tis.Len(results[0], 2)\n\tis.Len(results[1], 2)\n\tis.Len(results[2], 1)\n\tis.Equal([]string{\"foo\", \"bar\"}, results[0])\n\tis.Equal([]string{\"foo\", \"bar\"}, results[1])\n\tis.Equal([]string{\"bar\"}, results[2])\n}\n"
        },
        {
          "name": "union.go",
          "type": "blob",
          "size": 1.3857421875,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n)\n\n// Union returns the union between two collections.\nfunc Union(collections ...interface{}) interface{} {\n\t// shortcut zero/single argument\n\tif len(collections) == 0 {\n\t\treturn nil\n\t} else if len(collections) == 1 {\n\t\treturn collections[0]\n\t}\n\n\tif !IsIteratee(collections[0]) {\n\t\tpanic(\"Parameter must be a collection\")\n\t}\n\n\tcType := reflect.TypeOf(collections[0])\n\tzLen := 0\n\n\tfor i, x := range collections {\n\t\txValue := reflect.ValueOf(x)\n\t\txType := xValue.Type()\n\t\tif i > 0 && NotEqual(cType, xType) {\n\t\t\tpanic(\"Parameters must have the same type\")\n\t\t}\n\n\t\tzLen += xValue.Len()\n\t}\n\n\tif cType.Kind() == reflect.Map {\n\t\tzType := reflect.MapOf(cType.Key(), cType.Elem())\n\t\tzMap := reflect.MakeMap(zType)\n\n\t\tfor _, x := range collections {\n\t\t\txIter := reflect.ValueOf(x).MapRange()\n\t\t\tfor xIter.Next() {\n\t\t\t\tzMap.SetMapIndex(xIter.Key(), xIter.Value())\n\t\t\t}\n\t\t}\n\n\t\treturn zMap.Interface()\n\t} else {\n\t\tzType := reflect.SliceOf(cType.Elem())\n\t\tzSlice := reflect.MakeSlice(zType, 0, 0)\n\n\t\tfor _, x := range collections {\n\t\t\txValue := reflect.ValueOf(x)\n\t\t\tzSlice = reflect.AppendSlice(zSlice, xValue)\n\t\t}\n\n\t\treturn zSlice.Interface()\n\t}\n}\n\n// UnionStringMap returns the union between multiple string maps\nfunc UnionStringMap(x ...map[string]string) map[string]string {\n\tzMap := map[string]string{}\n\tfor _, xMap := range x {\n\t\tfor k, v := range xMap {\n\t\t\tzMap[k] = v\n\t\t}\n\t}\n\treturn zMap\n}\n"
        },
        {
          "name": "union_test.go",
          "type": "blob",
          "size": 0.697265625,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestUnion(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := Union([]int{1, 2, 3, 4}, []int{2, 4, 6})\n\tis.Equal(r, []int{1, 2, 3, 4, 2, 4, 6})\n\n\tr = Union(map[int]int{1: 1, 2: 2}, map[int]int{1: 0, 3: 3})\n\tis.Equal(r, map[int]int{1: 0, 2: 2, 3: 3})\n}\n\nfunc TestUnionShortcut(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := Union(nil)\n\tis.Nil(r)\n\n\tr = Union([]int{1, 2})\n\tis.Equal(r, []int{1, 2})\n}\n\nfunc TestUnionStringMap(t *testing.T) {\n\tis := assert.New(t)\n\n\tr := Union(map[string]string{\"a\": \"a\", \"b\": \"b\"}, map[string]string{\"a\": \"z\", \"z\": \"a\"}, map[string]string{\"z\": \"z\"})\n\tis.Equal(r, map[string]string{\"a\": \"z\", \"b\": \"b\", \"z\": \"z\"})\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 2.416015625,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc equal(expectedOrPredicate interface{}, optionalIsMap ...bool) func(keyValueIfMap, actualValue reflect.Value) bool {\n\tisMap := append(optionalIsMap, false)[0]\n\n\tif IsFunction(expectedOrPredicate) {\n\t\tinTypes := []reflect.Type{nil}; if isMap {\n\t\t\tinTypes = append(inTypes, nil)\n\t\t}\n\n\t\tif !IsPredicate(expectedOrPredicate, inTypes...) {\n\t\t\tpanic(fmt.Sprintf(\"Predicate function must have %d parameter and must return boolean\", len(inTypes)))\n\t\t}\n\n\t\tpredicateValue := reflect.ValueOf(expectedOrPredicate)\n\n\t\treturn func(keyValueIfMap, actualValue reflect.Value) bool {\n\n\t\t\tif isMap && !keyValueIfMap.Type().ConvertibleTo(predicateValue.Type().In(0)) {\n\t\t\t\tpanic(\"Given key is not compatible with type of parameter for the predicate.\")\n\t\t\t}\n\n\t\t\tif (isMap && !actualValue.Type().ConvertibleTo(predicateValue.Type().In(1))) ||\n\t\t\t\t(!isMap && !actualValue.Type().ConvertibleTo(predicateValue.Type().In(0))) {\n\t\t\t\tpanic(\"Given value is not compatible with type of parameter for the predicate.\")\n\t\t\t}\n\n\t\t\targs := []reflect.Value{actualValue}\n\t\t\tif isMap {\n\t\t\t\targs = append([]reflect.Value{keyValueIfMap}, args...)\n\t\t\t}\n\n\t\t\treturn predicateValue.Call(args)[0].Bool()\n\t\t}\n\t}\n\n\texpected := expectedOrPredicate\n\n\treturn func(keyValueIfMap, actualValue reflect.Value) bool {\n\t\tif isMap {\n\t\t\tactualValue = keyValueIfMap\n\t\t}\n\n\t\tif expected == nil || actualValue.IsZero() {\n\t\t\treturn actualValue.Interface() == expected\n\t\t}\n\n\t\treturn reflect.DeepEqual(actualValue.Interface(), expected)\n\t}\n}\n\nfunc sliceElem(rtype reflect.Type) reflect.Type {\n\tfor {\n\t\tif rtype.Kind() != reflect.Slice && rtype.Kind() != reflect.Array {\n\t\t\treturn rtype\n\t\t}\n\n\t\trtype = rtype.Elem()\n\t}\n}\n\nfunc redirectValue(value reflect.Value) reflect.Value {\n\tfor {\n\t\tif !value.IsValid() || (value.Kind() != reflect.Ptr && value.Kind() != reflect.Interface) {\n\t\t\treturn value\n\t\t}\n\n\t\tres := value.Elem()\n\n\t\t// Test for a circular type.\n\t\tif res.Kind() == reflect.Ptr && value.Kind() == reflect.Ptr && value.Pointer() == res.Pointer() {\n\t\t\treturn value\n\t\t}\n\n\t\tif !res.IsValid() && value.Kind() == reflect.Ptr {\n\t\t\treturn reflect.Zero(value.Type().Elem())\n\t\t}\n\n\t\tvalue = res\n\t}\n}\n\nfunc makeSlice(value reflect.Value, values ...int) reflect.Value {\n\tsliceType := sliceElem(value.Type())\n\n\tsize := value.Len()\n\tcap := size\n\n\tif len(values) > 0 {\n\t\tsize = values[0]\n\t}\n\n\tif len(values) > 1 {\n\t\tcap = values[1]\n\t}\n\n\treturn reflect.MakeSlice(reflect.SliceOf(sliceType), size, cap)\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 0.21875,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRedirectValue(t *testing.T) {\n\tis := assert.New(t)\n\n\tval := 1\n\n\tis.Equal(redirectValue(reflect.ValueOf(&val)).Interface(), 1)\n}\n"
        },
        {
          "name": "without.go",
          "type": "blob",
          "size": 0.4609375,
          "content": "package funk\n\nimport \"reflect\"\n\n// Without creates an array excluding all given values.\nfunc Without(in interface{}, values ...interface{}) interface{} {\n\tif !IsCollection(in) {\n\t\tpanic(\"First parameter must be a collection\")\n\t}\n\n\tinValue := reflect.ValueOf(in)\n\tfor _, value := range values {\n\t\tif NotEqual(inValue.Type().Elem(), reflect.TypeOf(value)) {\n\t\t\tpanic(\"Values must have the same type\")\n\t\t}\n\t}\n\n\treturn LeftJoin(inValue, reflect.ValueOf(values)).Interface()\n}\n"
        },
        {
          "name": "without_test.go",
          "type": "blob",
          "size": 0.587890625,
          "content": "package funk\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestWithout(t *testing.T) {\n\ttestCases := []struct {\n\t\tArr    interface{}\n\t\tValues []interface{}\n\t\tExpect interface{}\n\t}{\n\t\t{[]string{\"foo\", \"bar\"}, []interface{}{\"bar\"}, []string{\"foo\"}},\n\t\t{[]int{0, 1, 2, 3, 4}, []interface{}{3, 4}, []int{0, 1, 2}},\n\t\t{[]*Foo{f, b}, []interface{}{b, c}, []*Foo{f}},\n\t}\n\n\tfor idx, tt := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case #%d\", idx+1), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\n\t\t\tactual := Without(tt.Arr, tt.Values...)\n\t\t\tis.Equal(tt.Expect, actual)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "zip.go",
          "type": "blob",
          "size": 0.9580078125,
          "content": "package funk\n\nimport (\n\t\"reflect\"\n)\n\n// Tuple is the return type of Zip\ntype Tuple struct {\n\tElement1 interface{}\n\tElement2 interface{}\n}\n\n// Zip returns a list of tuples, where the i-th tuple contains the i-th element\n// from each of the input iterables. The returned list is truncated in length\n// to the length of the shortest input iterable.\nfunc Zip(slice1 interface{}, slice2 interface{}) []Tuple {\n\tif !IsCollection(slice1) || !IsCollection(slice2) {\n\t\tpanic(\"First parameter must be a collection\")\n\t}\n\n\tvar (\n\t\tminLength int\n\t\tinValue1  = reflect.ValueOf(slice1)\n\t\tinValue2  = reflect.ValueOf(slice2)\n\t\tresult    = []Tuple{}\n\t\tlength1   = inValue1.Len()\n\t\tlength2   = inValue2.Len()\n\t)\n\n\tif length1 <= length2 {\n\t\tminLength = length1\n\t} else {\n\t\tminLength = length2\n\t}\n\n\tfor i := 0; i < minLength; i++ {\n\t\tnewTuple := Tuple{\n\t\t\tElement1: inValue1.Index(i).Interface(),\n\t\t\tElement2: inValue2.Index(i).Interface(),\n\t\t}\n\t\tresult = append(result, newTuple)\n\t}\n\treturn result\n}\n"
        },
        {
          "name": "zip_test.go",
          "type": "blob",
          "size": 2.20703125,
          "content": "package funk\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestZipEmptyResult(t *testing.T) {\n\tmap1 := map[string]int{\"a\": 1, \"b\": 2}\n\tarray1 := []int{21, 22, 23}\n\temptySlice := []int{}\n\n\tt.Run(\"NonSliceOrArray\", func(t *testing.T) {\n\t\tassert.Panics(t, func() { Zip(map1, array1) }, \"It should panic\")\n\t})\n\n\tt.Run(\"ZerosSized\", func(t *testing.T) {\n\t\texpected := []Tuple{}\n\t\tresult := Zip(emptySlice, array1)\n\t\tassert.Equal(t, result, expected)\n\t})\n}\n\nfunc zipIntsAndAssert(t *testing.T, data1, data2 interface{}) {\n\tt.Run(\"FirstOneShorter\", func(t *testing.T) {\n\t\texpected := []Tuple{\n\t\t\t{Element1: 11, Element2: 21},\n\t\t\t{Element1: 12, Element2: 22},\n\t\t\t{Element1: 13, Element2: 23},\n\t\t}\n\t\tresult := Zip(data1, data2)\n\t\tassert.Equal(t, result, expected)\n\t})\n\n\tt.Run(\"SecondOneShorter\", func(t *testing.T) {\n\t\texpected := []Tuple{\n\t\t\t{Element1: 21, Element2: 11},\n\t\t\t{Element1: 22, Element2: 12},\n\t\t\t{Element1: 23, Element2: 13},\n\t\t}\n\t\tresult := Zip(data2, data1)\n\t\tassert.Equal(t, result, expected)\n\t})\n}\n\nfunc TestZipSlices(t *testing.T) {\n\tslice1 := []int{11, 12, 13}\n\tslice2 := []int{21, 22, 23, 24, 25}\n\tzipIntsAndAssert(t, slice1, slice2)\n}\n\nfunc TestZipArrays(t *testing.T) {\n\tarray1 := [...]int{11, 12, 13}\n\tarray2 := [...]int{21, 22, 23, 24, 25}\n\tzipIntsAndAssert(t, array1, array2)\n}\n\nfunc TestZipStructs(t *testing.T) {\n\ttype struct1 struct {\n\t\tMember1 uint16\n\t\tMember2 string\n\t}\n\ttype struct2 struct {\n\t\tMember3 bool\n\t}\n\ttype struct3 struct {\n\t\tMember4 int\n\t\tMember5 struct2\n\t}\n\n\tslice1 := []struct1{\n\t\t{\n\t\t\tMember1: 11,\n\t\t\tMember2: \"a\",\n\t\t},\n\t\t{\n\t\t\tMember1: 12,\n\t\t\tMember2: \"b\",\n\t\t},\n\t\t{\n\t\t\tMember1: 13,\n\t\t\tMember2: \"c\",\n\t\t},\n\t}\n\tslice2 := []struct3{\n\t\t{\n\t\t\tMember4: 21,\n\t\t\tMember5: struct2{\n\t\t\t\tMember3: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tMember4: 22,\n\t\t\tMember5: struct2{\n\t\t\t\tMember3: true,\n\t\t\t},\n\t\t},\n\t}\n\n\texpected := []Tuple{\n\t\t{\n\t\t\tElement1: struct1{\n\t\t\t\tMember1: 11,\n\t\t\t\tMember2: \"a\",\n\t\t\t},\n\t\t\tElement2: struct3{\n\t\t\t\tMember4: 21,\n\t\t\t\tMember5: struct2{\n\t\t\t\t\tMember3: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tElement1: struct1{\n\t\t\t\tMember1: 12,\n\t\t\t\tMember2: \"b\",\n\t\t\t},\n\t\t\tElement2: struct3{\n\t\t\t\tMember4: 22,\n\t\t\t\tMember5: struct2{\n\t\t\t\t\tMember3: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tresult := Zip(slice1, slice2)\n\tassert.Equal(t, expected, result)\n}\n"
        }
      ]
    }
  ]
}