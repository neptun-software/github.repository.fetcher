{
  "metadata": {
    "timestamp": 1736566720223,
    "page": 273,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Knetic/govaluate",
      "stars": 3796,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3203125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\r\n*.o\r\n*.a\r\n*.so\r\n\r\n# Folders\r\n_obj\r\n_test\r\n\r\n# Architecture specific extensions/prefixes\r\n*.[568vq]\r\n[568vq].out\r\n\r\n*.cgo1.go\r\n*.cgo2.c\r\n_cgo_defun.c\r\n_cgo_gotypes.go\r\n_cgo_export.*\r\n\r\n_testmain.go\r\n\r\n*.exe\r\n*.test\r\ncoverage.out\r\n\r\nmanual_test.go\r\n*.out\r\n*.err\r\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0849609375,
          "content": "language: go\r\n\r\nscript: ./test.sh\r\n\r\ngo:\r\n  - 1.2\r\n  - 1.3\r\n  - 1.4\r\n  - 1.5\r\n  - 1.6\r\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.6865234375,
          "content": "This library was authored by George Lester, and contains contributions from:\n\nvjeantet (regex support)\niasci (ternary operator)\noxtoacart (parameter structures, deferred parameter retrieval)\nwmiller848 (bitwise operators)\nprashantv (optimization of bools)\ndpaolella (exposure of variables used in an expression)\nbenpaxton (fix for missing type checks during literal elide process)\nabrander (panic-finding testing tool, float32 conversions)\nxfennec (fix for dates being parsed in the current Location)\nbgaifullin (lifting restriction on complex/struct types)\ngautambt (hexadecimal literals)\nfelixonmars (fix multiple typos in test names)\nsambonfire (automatic type conversion for accessor function calls)"
        },
        {
          "name": "EvaluableExpression.go",
          "type": "blob",
          "size": 6.744140625,
          "content": "package govaluate\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nconst isoDateFormat string = \"2006-01-02T15:04:05.999999999Z0700\"\nconst shortCircuitHolder int = -1\n\nvar DUMMY_PARAMETERS = MapParameters(map[string]interface{}{})\n\n/*\n\tEvaluableExpression represents a set of ExpressionTokens which, taken together,\n\tare an expression that can be evaluated down into a single value.\n*/\ntype EvaluableExpression struct {\n\n\t/*\n\t\tRepresents the query format used to output dates. Typically only used when creating SQL or Mongo queries from an expression.\n\t\tDefaults to the complete ISO8601 format, including nanoseconds.\n\t*/\n\tQueryDateFormat string\n\n\t/*\n\t\tWhether or not to safely check types when evaluating.\n\t\tIf true, this library will return error messages when invalid types are used.\n\t\tIf false, the library will panic when operators encounter types they can't use.\n\n\t\tThis is exclusively for users who need to squeeze every ounce of speed out of the library as they can,\n\t\tand you should only set this to false if you know exactly what you're doing.\n\t*/\n\tChecksTypes bool\n\n\ttokens           []ExpressionToken\n\tevaluationStages *evaluationStage\n\tinputExpression  string\n}\n\n/*\n\tParses a new EvaluableExpression from the given [expression] string.\n\tReturns an error if the given expression has invalid syntax.\n*/\nfunc NewEvaluableExpression(expression string) (*EvaluableExpression, error) {\n\n\tfunctions := make(map[string]ExpressionFunction)\n\treturn NewEvaluableExpressionWithFunctions(expression, functions)\n}\n\n/*\n\tSimilar to [NewEvaluableExpression], except that instead of a string, an already-tokenized expression is given.\n\tThis is useful in cases where you may be generating an expression automatically, or using some other parser (e.g., to parse from a query language)\n*/\nfunc NewEvaluableExpressionFromTokens(tokens []ExpressionToken) (*EvaluableExpression, error) {\n\n\tvar ret *EvaluableExpression\n\tvar err error\n\n\tret = new(EvaluableExpression)\n\tret.QueryDateFormat = isoDateFormat\n\n\terr = checkBalance(tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = checkExpressionSyntax(tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret.tokens, err = optimizeTokens(tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret.evaluationStages, err = planStages(ret.tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret.ChecksTypes = true\n\treturn ret, nil\n}\n\n/*\n\tSimilar to [NewEvaluableExpression], except enables the use of user-defined functions.\n\tFunctions passed into this will be available to the expression.\n*/\nfunc NewEvaluableExpressionWithFunctions(expression string, functions map[string]ExpressionFunction) (*EvaluableExpression, error) {\n\n\tvar ret *EvaluableExpression\n\tvar err error\n\n\tret = new(EvaluableExpression)\n\tret.QueryDateFormat = isoDateFormat\n\tret.inputExpression = expression\n\n\tret.tokens, err = parseTokens(expression, functions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = checkBalance(ret.tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = checkExpressionSyntax(ret.tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret.tokens, err = optimizeTokens(ret.tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret.evaluationStages, err = planStages(ret.tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret.ChecksTypes = true\n\treturn ret, nil\n}\n\n/*\n\tSame as `Eval`, but automatically wraps a map of parameters into a `govalute.Parameters` structure.\n*/\nfunc (this EvaluableExpression) Evaluate(parameters map[string]interface{}) (interface{}, error) {\n\n\tif parameters == nil {\n\t\treturn this.Eval(nil)\n\t}\n\n\treturn this.Eval(MapParameters(parameters))\n}\n\n/*\n\tRuns the entire expression using the given [parameters].\n\te.g., If the expression contains a reference to the variable \"foo\", it will be taken from `parameters.Get(\"foo\")`.\n\n\tThis function returns errors if the combination of expression and parameters cannot be run,\n\tsuch as if a variable in the expression is not present in [parameters].\n\n\tIn all non-error circumstances, this returns the single value result of the expression and parameters given.\n\te.g., if the expression is \"1 + 1\", this will return 2.0.\n\te.g., if the expression is \"foo + 1\" and parameters contains \"foo\" = 2, this will return 3.0\n*/\nfunc (this EvaluableExpression) Eval(parameters Parameters) (interface{}, error) {\n\n\tif this.evaluationStages == nil {\n\t\treturn nil, nil\n\t}\n\n\tif parameters != nil {\n\t\tparameters = &sanitizedParameters{parameters}\n\t} else {\n\t\tparameters = DUMMY_PARAMETERS\n\t}\n\n\treturn this.evaluateStage(this.evaluationStages, parameters)\n}\n\nfunc (this EvaluableExpression) evaluateStage(stage *evaluationStage, parameters Parameters) (interface{}, error) {\n\n\tvar left, right interface{}\n\tvar err error\n\n\tif stage.leftStage != nil {\n\t\tleft, err = this.evaluateStage(stage.leftStage, parameters)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif stage.isShortCircuitable() {\n\t\tswitch stage.symbol {\n\t\tcase AND:\n\t\t\tif left == false {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\tcase OR:\n\t\t\tif left == true {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\tcase COALESCE:\n\t\t\tif left != nil {\n\t\t\t\treturn left, nil\n\t\t\t}\n\n\t\tcase TERNARY_TRUE:\n\t\t\tif left == false {\n\t\t\t\tright = shortCircuitHolder\n\t\t\t}\n\t\tcase TERNARY_FALSE:\n\t\t\tif left != nil {\n\t\t\t\tright = shortCircuitHolder\n\t\t\t}\n\t\t}\n\t}\n\n\tif right != shortCircuitHolder && stage.rightStage != nil {\n\t\tright, err = this.evaluateStage(stage.rightStage, parameters)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif this.ChecksTypes {\n\t\tif stage.typeCheck == nil {\n\n\t\t\terr = typeCheck(stage.leftTypeCheck, left, stage.symbol, stage.typeErrorFormat)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\terr = typeCheck(stage.rightTypeCheck, right, stage.symbol, stage.typeErrorFormat)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\t// special case where the type check needs to know both sides to determine if the operator can handle it\n\t\t\tif !stage.typeCheck(left, right) {\n\t\t\t\terrorMsg := fmt.Sprintf(stage.typeErrorFormat, left, stage.symbol.String())\n\t\t\t\treturn nil, errors.New(errorMsg)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stage.operator(left, right, parameters)\n}\n\nfunc typeCheck(check stageTypeCheck, value interface{}, symbol OperatorSymbol, format string) error {\n\n\tif check == nil {\n\t\treturn nil\n\t}\n\n\tif check(value) {\n\t\treturn nil\n\t}\n\n\terrorMsg := fmt.Sprintf(format, value, symbol.String())\n\treturn errors.New(errorMsg)\n}\n\n/*\n\tReturns an array representing the ExpressionTokens that make up this expression.\n*/\nfunc (this EvaluableExpression) Tokens() []ExpressionToken {\n\n\treturn this.tokens\n}\n\n/*\n\tReturns the original expression used to create this EvaluableExpression.\n*/\nfunc (this EvaluableExpression) String() string {\n\n\treturn this.inputExpression\n}\n\n/*\n\tReturns an array representing the variables contained in this EvaluableExpression.\n*/\nfunc (this EvaluableExpression) Vars() []string {\n\tvar varlist []string\n\tfor _, val := range this.Tokens() {\n\t\tif val.Kind == VARIABLE {\n\t\t\tvarlist = append(varlist, val.Value.(string))\n\t\t}\n\t}\n\treturn varlist\n}\n"
        },
        {
          "name": "EvaluableExpression_sql.go",
          "type": "blob",
          "size": 3.50390625,
          "content": "package govaluate\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"time\"\n)\n\n/*\n\tReturns a string representing this expression as if it were written in SQL.\n\tThis function assumes that all parameters exist within the same table, and that the table essentially represents\n\ta serialized object of some sort (e.g., hibernate).\n\tIf your data model is more normalized, you may need to consider iterating through each actual token given by `Tokens()`\n\tto create your query.\n\n\tBoolean values are considered to be \"1\" for true, \"0\" for false.\n\n\tTimes are formatted according to this.QueryDateFormat.\n*/\nfunc (this EvaluableExpression) ToSQLQuery() (string, error) {\n\n\tvar stream *tokenStream\n\tvar transactions *expressionOutputStream\n\tvar transaction string\n\tvar err error\n\n\tstream = newTokenStream(this.tokens)\n\ttransactions = new(expressionOutputStream)\n\n\tfor stream.hasNext() {\n\n\t\ttransaction, err = this.findNextSQLString(stream, transactions)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\ttransactions.add(transaction)\n\t}\n\n\treturn transactions.createString(\" \"), nil\n}\n\nfunc (this EvaluableExpression) findNextSQLString(stream *tokenStream, transactions *expressionOutputStream) (string, error) {\n\n\tvar token ExpressionToken\n\tvar ret string\n\n\ttoken = stream.next()\n\n\tswitch token.Kind {\n\n\tcase STRING:\n\t\tret = fmt.Sprintf(\"'%v'\", token.Value)\n\tcase PATTERN:\n\t\tret = fmt.Sprintf(\"'%s'\", token.Value.(*regexp.Regexp).String())\n\tcase TIME:\n\t\tret = fmt.Sprintf(\"'%s'\", token.Value.(time.Time).Format(this.QueryDateFormat))\n\n\tcase LOGICALOP:\n\t\tswitch logicalSymbols[token.Value.(string)] {\n\n\t\tcase AND:\n\t\t\tret = \"AND\"\n\t\tcase OR:\n\t\t\tret = \"OR\"\n\t\t}\n\n\tcase BOOLEAN:\n\t\tif token.Value.(bool) {\n\t\t\tret = \"1\"\n\t\t} else {\n\t\t\tret = \"0\"\n\t\t}\n\n\tcase VARIABLE:\n\t\tret = fmt.Sprintf(\"[%s]\", token.Value.(string))\n\n\tcase NUMERIC:\n\t\tret = fmt.Sprintf(\"%g\", token.Value.(float64))\n\n\tcase COMPARATOR:\n\t\tswitch comparatorSymbols[token.Value.(string)] {\n\n\t\tcase EQ:\n\t\t\tret = \"=\"\n\t\tcase NEQ:\n\t\t\tret = \"<>\"\n\t\tcase REQ:\n\t\t\tret = \"RLIKE\"\n\t\tcase NREQ:\n\t\t\tret = \"NOT RLIKE\"\n\t\tdefault:\n\t\t\tret = fmt.Sprintf(\"%s\", token.Value.(string))\n\t\t}\n\n\tcase TERNARY:\n\n\t\tswitch ternarySymbols[token.Value.(string)] {\n\n\t\tcase COALESCE:\n\n\t\t\tleft := transactions.rollback()\n\t\t\tright, err := this.findNextSQLString(stream, transactions)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tret = fmt.Sprintf(\"COALESCE(%v, %v)\", left, right)\n\t\tcase TERNARY_TRUE:\n\t\t\tfallthrough\n\t\tcase TERNARY_FALSE:\n\t\t\treturn \"\", errors.New(\"Ternary operators are unsupported in SQL output\")\n\t\t}\n\tcase PREFIX:\n\t\tswitch prefixSymbols[token.Value.(string)] {\n\n\t\tcase INVERT:\n\t\t\tret = fmt.Sprintf(\"NOT\")\n\t\tdefault:\n\n\t\t\tright, err := this.findNextSQLString(stream, transactions)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tret = fmt.Sprintf(\"%s%s\", token.Value.(string), right)\n\t\t}\n\tcase MODIFIER:\n\n\t\tswitch modifierSymbols[token.Value.(string)] {\n\n\t\tcase EXPONENT:\n\n\t\t\tleft := transactions.rollback()\n\t\t\tright, err := this.findNextSQLString(stream, transactions)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tret = fmt.Sprintf(\"POW(%s, %s)\", left, right)\n\t\tcase MODULUS:\n\n\t\t\tleft := transactions.rollback()\n\t\t\tright, err := this.findNextSQLString(stream, transactions)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tret = fmt.Sprintf(\"MOD(%s, %s)\", left, right)\n\t\tdefault:\n\t\t\tret = fmt.Sprintf(\"%s\", token.Value.(string))\n\t\t}\n\tcase CLAUSE:\n\t\tret = \"(\"\n\tcase CLAUSE_CLOSE:\n\t\tret = \")\"\n\tcase SEPARATOR:\n\t\tret = \",\"\n\n\tdefault:\n\t\terrorMsg := fmt.Sprintf(\"Unrecognized query token '%s' of kind '%s'\", token.Value, token.Kind)\n\t\treturn \"\", errors.New(errorMsg)\n\t}\n\n\treturn ret, nil\n}\n"
        },
        {
          "name": "ExpressionToken.go",
          "type": "blob",
          "size": 0.125,
          "content": "package govaluate\n\n/*\n\tRepresents a single parsed token.\n*/\ntype ExpressionToken struct {\n\tKind  TokenKind\n\tValue interface{}\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.080078125,
          "content": "The MIT License (MIT)\r\n\r\nCopyright (c) 2014-2016 George Lester\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n"
        },
        {
          "name": "MANUAL.md",
          "type": "blob",
          "size": 8.4814453125,
          "content": "govaluate\n====\n\nThis library contains quite a lot of functionality, this document is meant to be formal documentation on the operators and features of it.\nSome of this documentation may duplicate what's in README.md, but should never conflict.\n\n# Types\n\nThis library only officially deals with four types; `float64`, `bool`, `string`, and arrays.\n\nAll numeric literals, with or without a radix, will be converted to `float64` for evaluation. For instance; in practice, there is no difference between the literals \"1.0\" and \"1\", they both end up as `float64`. This matters to users because if you intend to return numeric values from your expressions, then the returned value will be `float64`, not any other numeric type.\n\nAny string _literal_ (not parameter) which is interpretable as a date will be converted to a `float64` representation of that date's unix time. Any `time.Time` parameters will not be operable with these date literals; such parameters will need to use the `time.Time.Unix()` method to get a numeric representation.\n\nArrays are untyped, and can be mixed-type. Internally they're all just `interface{}`. Only two operators can interact with arrays, `IN` and `,`. All other operators will refuse to operate on arrays.\n\n# Operators\n\n## Modifiers\n\n### Addition, concatenation `+`\n\nIf either left or right sides of the `+` operator are a `string`, then this operator will perform string concatenation and return that result. If neither are string, then both must be numeric, and this will return a numeric result.\n\nAny other case is invalid.\n\n### Arithmetic `-` `*` `/` `**` `%`\n\n`**` refers to \"take to the power of\". For instance, `3 ** 4` == 81.\n\n* _Left side_: numeric\n* _Right side_: numeric\n* _Returns_: numeric\n\n### Bitwise shifts, masks `>>` `<<` `|` `&` `^`\n\nAll of these operators convert their `float64` left and right sides to `int64`, perform their operation, and then convert back.\nGiven how this library assumes numeric are represented (as `float64`), it is unlikely that this behavior will change, even though it may cause havoc with extremely large or small numbers.\n\n* _Left side_: numeric\n* _Right side_: numeric\n* _Returns_: numeric\n\n### Negation `-`\n\nPrefix only. This can never have a left-hand value.\n\n* _Right side_: numeric\n* _Returns_: numeric\n\n### Inversion `!`\n\nPrefix only. This can never have a left-hand value.\n\n* _Right side_: bool\n* _Returns_: bool\n\n### Bitwise NOT `~`\n\nPrefix only. This can never have a left-hand value.\n\n* _Right side_: numeric\n* _Returns_: numeric\n\n## Logical Operators\n\nFor all logical operators, this library will short-circuit the operation if the left-hand side is sufficient to determine what to do. For instance, `true || expensiveOperation()` will not actually call `expensiveOperation()`, since it knows the left-hand side is `true`.\n\n### Logical AND/OR `&&` `||`\n\n* _Left side_: bool\n* _Right side_: bool\n* _Returns_: bool\n\n### Ternary true `?`\n\nChecks if the left side is `true`. If so, returns the right side. If the left side is `false`, returns `nil`.\nIn practice, this is commonly used with the other ternary operator.\n\n* _Left side_: bool\n* _Right side_: Any type.\n* _Returns_: Right side or `nil`\n\n### Ternary false `:`\n\nChecks if the left side is `nil`. If so, returns the right side. If the left side is non-nil, returns the left side.\nIn practice, this is commonly used with the other ternary operator.\n\n* _Left side_: Any type.\n* _Right side_: Any type.\n* _Returns_: Right side or `nil`\n\n### Null coalescence `??`\n\nSimilar to the C# operator. If the left value is non-nil, it returns that. If not, then the right-value is returned.\n\n* _Left side_: Any type.\n* _Right side_: Any type.\n* _Returns_: No specific type - whichever is passed to it.\n\n## Comparators\n\n### Numeric/lexicographic comparators `>` `<` `>=` `<=`\n\nIf both sides are numeric, this returns the usual greater/lesser behavior that would be expected.\nIf both sides are string, this returns the lexicographic comparison of the strings. This uses Go's standard lexicographic compare.\n\n* _Accepts_: Left and right side must either be both string, or both numeric.\n* _Returns_: bool\n\n### Regex comparators `=~` `!~`\n\nThese use go's standard `regexp` flavor of regex. The left side is expected to be the candidate string, the right side is the pattern. `=~` returns whether or not the candidate string matches the regex pattern given on the right. `!~` is the inverted version of the same logic.\n\n* _Left side_: string\n* _Right side_: string\n* _Returns_: bool\n\n## Arrays\n\n### Separator `,`\n\nThe separator, always paired with parenthesis, creates arrays. It must always have both a left and right-hand value, so for instance `(, 0)` and `(0,)` are invalid uses of it.\n\nAgain, this should always be used with parenthesis; like `(1, 2, 3, 4)`.\n\n### Membership `IN`\n\nThe only operator with a text name, this operator checks the right-hand side array to see if it contains a value that is equal to the left-side value.\nEquality is determined by the use of the `==` operator, and this library doesn't check types between the values. Any two values, when cast to `interface{}`, and can still be checked for equality with `==` will act as expected.\n\nNote that you can use a parameter for the array, but it must be an `[]interface{}`.\n\n* _Left side_: Any type.\n* _Right side_: array\n* _Returns_: bool\n\n# Parameters\n\nParameters must be passed in every time the expression is evaluated. Parameters can be of any type, but will not cause errors unless actually used in an erroneous way. There is no difference in behavior for any of the above operators for parameters - they are type checked when used.\n\nAll `int` and `float` values of any width will be converted to `float64` before use.\n\nAt no point is the parameter structure, or any value thereof, modified by this library.\n\n## Alternates to maps\n\nThe default form of parameters as a map may not serve your use case. You may have parameters in some other structure, you may want to change the no-parameter-found behavior, or maybe even just have some debugging print statements invoked when a parameter is accessed.\n\nTo do this, define a type that implements the `govaluate.Parameters` interface. When you want to evaluate, instead call `EvaluableExpression.Eval` and pass your parameter structure.\n\n# Functions\n\nDuring expression parsing (_not_ evaluation), a map of functions can be given to `govaluate.NewEvaluableExpressionWithFunctions` (the lengthiest and finest of function names). The resultant expression will be able to invoke those functions during evaluation. Once parsed, an expression cannot have functions added or removed - a new expression will need to be created if you want to change the functions, or behavior of said functions.\n\nFunctions always take the form `<name>(<parameters>)`, including parens. Functions can have an empty list of parameters, like `<name>()`, but still must have parens.\n\nIf the expression contains something that looks like it ought to be a function (such as `foo()`), but no such function was given to it, it will error on parsing.\n\nFunctions must be of type `map[string]govaluate.ExpressionFunction`. `ExpressionFunction`, for brevity, has the following signature:\n\n`func(args ...interface{}) (interface{}, error)`\n\nWhere `args` is whatever is passed to the function when called. If a non-nil error is returned from a function during evaluation, the evaluation stops and ultimately returns that error to the caller of `Evaluate()` or `Eval()`.\n\n## Built-in functions\n\nThere aren't any builtin functions. The author is opposed to maintaining a standard library of functions to be used.\n\nEvery use case of this library is different, and even in simple use cases (such as parameters, see above) different users need different behavior, naming, or even functionality. The author prefers that users make their own decisions about what functions they need, and how they operate.\n\n# Equality\n\nThe `==` and `!=` operators involve a moderately complex workflow. They use [`reflect.DeepEqual`](https://golang.org/pkg/reflect/#DeepEqual). This is for complicated reasons, but there are some types in Go that cannot be compared with the native `==` operator. Arrays, in particular, cannot be compared - Go will panic if you try. One might assume this could be handled with the type checking system in `govaluate`, but unfortunately without reflection there is no way to know if a variable is a slice/array. Worse, structs can be incomparable if they _contain incomparable types_.\n\nIt's all very complicated. Fortunately, Go includes the `reflect.DeepEqual` function to handle all the edge cases. Currently, `govaluate` uses that for all equality/inequality.\n"
        },
        {
          "name": "OperatorSymbol.go",
          "type": "blob",
          "size": 5.04296875,
          "content": "package govaluate\n\n/*\n\tRepresents the valid symbols for operators.\n\n*/\ntype OperatorSymbol int\n\nconst (\n\tVALUE OperatorSymbol = iota\n\tLITERAL\n\tNOOP\n\tEQ\n\tNEQ\n\tGT\n\tLT\n\tGTE\n\tLTE\n\tREQ\n\tNREQ\n\tIN\n\n\tAND\n\tOR\n\n\tPLUS\n\tMINUS\n\tBITWISE_AND\n\tBITWISE_OR\n\tBITWISE_XOR\n\tBITWISE_LSHIFT\n\tBITWISE_RSHIFT\n\tMULTIPLY\n\tDIVIDE\n\tMODULUS\n\tEXPONENT\n\n\tNEGATE\n\tINVERT\n\tBITWISE_NOT\n\n\tTERNARY_TRUE\n\tTERNARY_FALSE\n\tCOALESCE\n\n\tFUNCTIONAL\n\tACCESS\n\tSEPARATE\n)\n\ntype operatorPrecedence int\n\nconst (\n\tnoopPrecedence operatorPrecedence = iota\n\tvaluePrecedence\n\tfunctionalPrecedence\n\tprefixPrecedence\n\texponentialPrecedence\n\tadditivePrecedence\n\tbitwisePrecedence\n\tbitwiseShiftPrecedence\n\tmultiplicativePrecedence\n\tcomparatorPrecedence\n\tternaryPrecedence\n\tlogicalAndPrecedence\n\tlogicalOrPrecedence\n\tseparatePrecedence\n)\n\nfunc findOperatorPrecedenceForSymbol(symbol OperatorSymbol) operatorPrecedence {\n\n\tswitch symbol {\n\tcase NOOP:\n\t\treturn noopPrecedence\n\tcase VALUE:\n\t\treturn valuePrecedence\n\tcase EQ:\n\t\tfallthrough\n\tcase NEQ:\n\t\tfallthrough\n\tcase GT:\n\t\tfallthrough\n\tcase LT:\n\t\tfallthrough\n\tcase GTE:\n\t\tfallthrough\n\tcase LTE:\n\t\tfallthrough\n\tcase REQ:\n\t\tfallthrough\n\tcase NREQ:\n\t\tfallthrough\n\tcase IN:\n\t\treturn comparatorPrecedence\n\tcase AND:\n\t\treturn logicalAndPrecedence\n\tcase OR:\n\t\treturn logicalOrPrecedence\n\tcase BITWISE_AND:\n\t\tfallthrough\n\tcase BITWISE_OR:\n\t\tfallthrough\n\tcase BITWISE_XOR:\n\t\treturn bitwisePrecedence\n\tcase BITWISE_LSHIFT:\n\t\tfallthrough\n\tcase BITWISE_RSHIFT:\n\t\treturn bitwiseShiftPrecedence\n\tcase PLUS:\n\t\tfallthrough\n\tcase MINUS:\n\t\treturn additivePrecedence\n\tcase MULTIPLY:\n\t\tfallthrough\n\tcase DIVIDE:\n\t\tfallthrough\n\tcase MODULUS:\n\t\treturn multiplicativePrecedence\n\tcase EXPONENT:\n\t\treturn exponentialPrecedence\n\tcase BITWISE_NOT:\n\t\tfallthrough\n\tcase NEGATE:\n\t\tfallthrough\n\tcase INVERT:\n\t\treturn prefixPrecedence\n\tcase COALESCE:\n\t\tfallthrough\n\tcase TERNARY_TRUE:\n\t\tfallthrough\n\tcase TERNARY_FALSE:\n\t\treturn ternaryPrecedence\n\tcase ACCESS:\n\t\tfallthrough\n\tcase FUNCTIONAL:\n\t\treturn functionalPrecedence\n\tcase SEPARATE:\n\t\treturn separatePrecedence\n\t}\n\n\treturn valuePrecedence\n}\n\n/*\n\tMap of all valid comparators, and their string equivalents.\n\tUsed during parsing of expressions to determine if a symbol is, in fact, a comparator.\n\tAlso used during evaluation to determine exactly which comparator is being used.\n*/\nvar comparatorSymbols = map[string]OperatorSymbol{\n\t\"==\": EQ,\n\t\"!=\": NEQ,\n\t\">\":  GT,\n\t\">=\": GTE,\n\t\"<\":  LT,\n\t\"<=\": LTE,\n\t\"=~\": REQ,\n\t\"!~\": NREQ,\n\t\"in\": IN,\n}\n\nvar logicalSymbols = map[string]OperatorSymbol{\n\t\"&&\": AND,\n\t\"||\": OR,\n}\n\nvar bitwiseSymbols = map[string]OperatorSymbol{\n\t\"^\": BITWISE_XOR,\n\t\"&\": BITWISE_AND,\n\t\"|\": BITWISE_OR,\n}\n\nvar bitwiseShiftSymbols = map[string]OperatorSymbol{\n\t\">>\": BITWISE_RSHIFT,\n\t\"<<\": BITWISE_LSHIFT,\n}\n\nvar additiveSymbols = map[string]OperatorSymbol{\n\t\"+\": PLUS,\n\t\"-\": MINUS,\n}\n\nvar multiplicativeSymbols = map[string]OperatorSymbol{\n\t\"*\": MULTIPLY,\n\t\"/\": DIVIDE,\n\t\"%\": MODULUS,\n}\n\nvar exponentialSymbolsS = map[string]OperatorSymbol{\n\t\"**\": EXPONENT,\n}\n\nvar prefixSymbols = map[string]OperatorSymbol{\n\t\"-\": NEGATE,\n\t\"!\": INVERT,\n\t\"~\": BITWISE_NOT,\n}\n\nvar ternarySymbols = map[string]OperatorSymbol{\n\t\"?\":  TERNARY_TRUE,\n\t\":\":  TERNARY_FALSE,\n\t\"??\": COALESCE,\n}\n\n// this is defined separately from additiveSymbols et al because it's needed for parsing, not stage planning.\nvar modifierSymbols = map[string]OperatorSymbol{\n\t\"+\":  PLUS,\n\t\"-\":  MINUS,\n\t\"*\":  MULTIPLY,\n\t\"/\":  DIVIDE,\n\t\"%\":  MODULUS,\n\t\"**\": EXPONENT,\n\t\"&\":  BITWISE_AND,\n\t\"|\":  BITWISE_OR,\n\t\"^\":  BITWISE_XOR,\n\t\">>\": BITWISE_RSHIFT,\n\t\"<<\": BITWISE_LSHIFT,\n}\n\nvar separatorSymbols = map[string]OperatorSymbol{\n\t\",\": SEPARATE,\n}\n\n/*\n\tReturns true if this operator is contained by the given array of candidate symbols.\n\tFalse otherwise.\n*/\nfunc (this OperatorSymbol) IsModifierType(candidate []OperatorSymbol) bool {\n\n\tfor _, symbolType := range candidate {\n\t\tif this == symbolType {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/*\n\tGenerally used when formatting type check errors.\n\tWe could store the stringified symbol somewhere else and not require a duplicated codeblock to translate\n\tOperatorSymbol to string, but that would require more memory, and another field somewhere.\n\tAdding operators is rare enough that we just stringify it here instead.\n*/\nfunc (this OperatorSymbol) String() string {\n\n\tswitch this {\n\tcase NOOP:\n\t\treturn \"NOOP\"\n\tcase VALUE:\n\t\treturn \"VALUE\"\n\tcase EQ:\n\t\treturn \"=\"\n\tcase NEQ:\n\t\treturn \"!=\"\n\tcase GT:\n\t\treturn \">\"\n\tcase LT:\n\t\treturn \"<\"\n\tcase GTE:\n\t\treturn \">=\"\n\tcase LTE:\n\t\treturn \"<=\"\n\tcase REQ:\n\t\treturn \"=~\"\n\tcase NREQ:\n\t\treturn \"!~\"\n\tcase AND:\n\t\treturn \"&&\"\n\tcase OR:\n\t\treturn \"||\"\n\tcase IN:\n\t\treturn \"in\"\n\tcase BITWISE_AND:\n\t\treturn \"&\"\n\tcase BITWISE_OR:\n\t\treturn \"|\"\n\tcase BITWISE_XOR:\n\t\treturn \"^\"\n\tcase BITWISE_LSHIFT:\n\t\treturn \"<<\"\n\tcase BITWISE_RSHIFT:\n\t\treturn \">>\"\n\tcase PLUS:\n\t\treturn \"+\"\n\tcase MINUS:\n\t\treturn \"-\"\n\tcase MULTIPLY:\n\t\treturn \"*\"\n\tcase DIVIDE:\n\t\treturn \"/\"\n\tcase MODULUS:\n\t\treturn \"%\"\n\tcase EXPONENT:\n\t\treturn \"**\"\n\tcase NEGATE:\n\t\treturn \"-\"\n\tcase INVERT:\n\t\treturn \"!\"\n\tcase BITWISE_NOT:\n\t\treturn \"~\"\n\tcase TERNARY_TRUE:\n\t\treturn \"?\"\n\tcase TERNARY_FALSE:\n\t\treturn \":\"\n\tcase COALESCE:\n\t\treturn \"??\"\n\t}\n\treturn \"\"\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.7255859375,
          "content": "govaluate\n====\n\n[![Build Status](https://travis-ci.org/Knetic/govaluate.svg?branch=master)](https://travis-ci.org/Knetic/govaluate)\n[![Godoc](https://img.shields.io/badge/godoc-reference-5272B4.svg)](https://godoc.org/github.com/Knetic/govaluate)\n[![Go Report Card](https://goreportcard.com/badge/github.com/Knetic/govaluate)](https://goreportcard.com/report/github.com/Knetic/govaluate) \n[![Gocover](https://gocover.io/_badge/github.com/Knetic/govaluate)](https://gocover.io/github.com/Knetic/govaluate)\n\nProvides support for evaluating arbitrary C-like artithmetic/string expressions.\n\nWhy can't you just write these expressions in code?\n--\n\nSometimes, you can't know ahead-of-time what an expression will look like, or you want those expressions to be configurable.\nPerhaps you've got a set of data running through your application, and you want to allow your users to specify some validations to run on it before committing it to a database. Or maybe you've written a monitoring framework which is capable of gathering a bunch of metrics, then evaluating a few expressions to see if any metrics should be alerted upon, but the conditions for alerting are different for each monitor.\n\nA lot of people wind up writing their own half-baked style of evaluation language that fits their needs, but isn't complete. Or they wind up baking the expression into the actual executable, even if they know it's subject to change. These strategies may work, but they take time to implement, time for users to learn, and induce technical debt as requirements change. This library is meant to cover all the normal C-like expressions, so that you don't have to reinvent one of the oldest wheels on a computer.\n\nHow do I use it?\n--\n\nYou create a new EvaluableExpression, then call \"Evaluate\" on it.\n\n```go\n\texpression, err := govaluate.NewEvaluableExpression(\"10 > 0\");\n\tresult, err := expression.Evaluate(nil);\n\t// result is now set to \"true\", the bool value.\n```\n\nCool, but how about with parameters?\n\n```go\n\texpression, err := govaluate.NewEvaluableExpression(\"foo > 0\");\n\n\tparameters := make(map[string]interface{}, 8)\n\tparameters[\"foo\"] = -1;\n\n\tresult, err := expression.Evaluate(parameters);\n\t// result is now set to \"false\", the bool value.\n```\n\nThat's cool, but we can almost certainly have done all that in code. What about a complex use case that involves some math?\n\n```go\n\texpression, err := govaluate.NewEvaluableExpression(\"(requests_made * requests_succeeded / 100) >= 90\");\n\n\tparameters := make(map[string]interface{}, 8)\n\tparameters[\"requests_made\"] = 100;\n\tparameters[\"requests_succeeded\"] = 80;\n\n\tresult, err := expression.Evaluate(parameters);\n\t// result is now set to \"false\", the bool value.\n```\n\nOr maybe you want to check the status of an alive check (\"smoketest\") page, which will be a string?\n\n```go\n\texpression, err := govaluate.NewEvaluableExpression(\"http_response_body == 'service is ok'\");\n\n\tparameters := make(map[string]interface{}, 8)\n\tparameters[\"http_response_body\"] = \"service is ok\";\n\n\tresult, err := expression.Evaluate(parameters);\n\t// result is now set to \"true\", the bool value.\n```\n\nThese examples have all returned boolean values, but it's equally possible to return numeric ones.\n\n```go\n\texpression, err := govaluate.NewEvaluableExpression(\"(mem_used / total_mem) * 100\");\n\n\tparameters := make(map[string]interface{}, 8)\n\tparameters[\"total_mem\"] = 1024;\n\tparameters[\"mem_used\"] = 512;\n\n\tresult, err := expression.Evaluate(parameters);\n\t// result is now set to \"50.0\", the float64 value.\n```\n\nYou can also do date parsing, though the formats are somewhat limited. Stick to RF3339, ISO8061, unix date, or ruby date formats. If you're having trouble getting a date string to parse, check the list of formats actually used: [parsing.go:248](https://github.com/Knetic/govaluate/blob/0580e9b47a69125afa0e4ebd1cf93c49eb5a43ec/parsing.go#L258).\n\n```go\n\texpression, err := govaluate.NewEvaluableExpression(\"'2014-01-02' > '2014-01-01 23:59:59'\");\n\tresult, err := expression.Evaluate(nil);\n\n\t// result is now set to true\n```\n\nExpressions are parsed once, and can be re-used multiple times. Parsing is the compute-intensive phase of the process, so if you intend to use the same expression with different parameters, just parse it once. Like so;\n\n```go\n\texpression, err := govaluate.NewEvaluableExpression(\"response_time <= 100\");\n\tparameters := make(map[string]interface{}, 8)\n\n\tfor {\n\t\tparameters[\"response_time\"] = pingSomething();\n\t\tresult, err := expression.Evaluate(parameters)\n\t}\n```\n\nThe normal C-standard order of operators is respected. When writing an expression, be sure that you either order the operators correctly, or use parenthesis to clarify which portions of an expression should be run first.\n\nEscaping characters\n--\n\nSometimes you'll have parameters that have spaces, slashes, pluses, ampersands or some other character\nthat this library interprets as something special. For example, the following expression will not\nact as one might expect:\n\n\t\"response-time < 100\"\n\nAs written, the library will parse it as \"[response] minus [time] is less than 100\". In reality,\n\"response-time\" is meant to be one variable that just happens to have a dash in it.\n\nThere are two ways to work around this. First, you can escape the entire parameter name:\n\n \t\"[response-time] < 100\"\n\nOr you can use backslashes to escape only the minus sign.\n\n\t\"response\\\\-time < 100\"\n\nBackslashes can be used anywhere in an expression to escape the very next character. Square bracketed parameter names can be used instead of plain parameter names at any time.\n\nFunctions\n--\n\nYou may have cases where you want to call a function on a parameter during execution of the expression. Perhaps you want to aggregate some set of data, but don't know the exact aggregation you want to use until you're writing the expression itself. Or maybe you have a mathematical operation you want to perform, for which there is no operator; like `log` or `tan` or `sqrt`. For cases like this, you can provide a map of functions to `NewEvaluableExpressionWithFunctions`, which will then be able to use them during execution. For instance;\n\n```go\n\tfunctions := map[string]govaluate.ExpressionFunction {\n\t\t\"strlen\": func(args ...interface{}) (interface{}, error) {\n\t\t\tlength := len(args[0].(string))\n\t\t\treturn (float64)(length), nil\n\t\t},\n\t}\n\n\texpString := \"strlen('someReallyLongInputString') <= 16\"\n\texpression, _ := govaluate.NewEvaluableExpressionWithFunctions(expString, functions)\n\n\tresult, _ := expression.Evaluate(nil)\n\t// result is now \"false\", the boolean value\n```\n\nFunctions can accept any number of arguments, correctly handles nested functions, and arguments can be of any type (even if none of this library's operators support evaluation of that type). For instance, each of these usages of functions in an expression are valid (assuming that the appropriate functions and parameters are given):\n\n```go\n\"sqrt(x1 ** y1, x2 ** y2)\"\n\"max(someValue, abs(anotherValue), 10 * lastValue)\"\n```\n\nFunctions cannot be passed as parameters, they must be known at the time when the expression is parsed, and are unchangeable after parsing.\n\nAccessors\n--\n\nIf you have structs in your parameters, you can access their fields and methods in the usual way. For instance, given a struct that has a method \"Echo\", present in the parameters as `foo`, the following is valid:\n\n\t\"foo.Echo('hello world')\"\n\nFields are accessed in a similar way. Assuming `foo` has a field called \"Length\":\n\n\t\"foo.Length > 9000\"\n\nAccessors can be nested to any depth, like the following\n\n\t\"foo.Bar.Baz.SomeFunction()\"\n\nHowever it is not _currently_ supported to access values in `map`s. So the following will not work\n\n\t\"foo.SomeMap['key']\"\n\nThis may be convenient, but note that using accessors involves a _lot_ of reflection. This makes the expression about four times slower than just using a parameter (consult the benchmarks for more precise measurements on your system).\nIf at all reasonable, the author recommends extracting the values you care about into a parameter map beforehand, or defining a struct that implements the `Parameters` interface, and which grabs fields as required. If there are functions you want to use, it's better to pass them as expression functions (see the above section). These approaches use no reflection, and are designed to be fast and clean.\n\nWhat operators and types does this support?\n--\n\n* Modifiers: `+` `-` `/` `*` `&` `|` `^` `**` `%` `>>` `<<`\n* Comparators: `>` `>=` `<` `<=` `==` `!=` `=~` `!~`\n* Logical ops: `||` `&&`\n* Numeric constants, as 64-bit floating point (`12345.678`)\n* String constants (single quotes: `'foobar'`)\n* Date constants (single quotes, using any permutation of RFC3339, ISO8601, ruby date, or unix date; date parsing is automatically tried with any string constant)\n* Boolean constants: `true` `false`\n* Parenthesis to control order of evaluation `(` `)`\n* Arrays (anything separated by `,` within parenthesis: `(1, 2, 'foo')`)\n* Prefixes: `!` `-` `~`\n* Ternary conditional: `?` `:`\n* Null coalescence: `??`\n\nSee [MANUAL.md](https://github.com/Knetic/govaluate/blob/master/MANUAL.md) for exacting details on what types each operator supports.\n\nTypes\n--\n\nSome operators don't make sense when used with some types. For instance, what does it mean to get the modulo of a string? What happens if you check to see if two numbers are logically AND'ed together?\n\nEveryone has a different intuition about the answers to these questions. To prevent confusion, this library will _refuse to operate_ upon types for which there is not an unambiguous meaning for the operation. See [MANUAL.md](https://github.com/Knetic/govaluate/blob/master/MANUAL.md) for details about what operators are valid for which types.\n\nBenchmarks\n--\n\nIf you're concerned about the overhead of this library, a good range of benchmarks are built into this repo. You can run them with `go test -bench=.`. The library is built with an eye towards being quick, but has not been aggressively profiled and optimized. For most applications, though, it is completely fine.\n\nFor a very rough idea of performance, here are the results output from a benchmark run on a 3rd-gen Macbook Pro (Linux Mint 17.1).\n\n```\nBenchmarkSingleParse-12                          1000000              1382 ns/op\nBenchmarkSimpleParse-12                           200000             10771 ns/op\nBenchmarkFullParse-12                              30000             49383 ns/op\nBenchmarkEvaluationSingle-12                    50000000                30.1 ns/op\nBenchmarkEvaluationNumericLiteral-12            10000000               119 ns/op\nBenchmarkEvaluationLiteralModifiers-12          10000000               236 ns/op\nBenchmarkEvaluationParameters-12                 5000000               260 ns/op\nBenchmarkEvaluationParametersModifiers-12        3000000               547 ns/op\nBenchmarkComplexExpression-12                    2000000               963 ns/op\nBenchmarkRegexExpression-12                       100000             20357 ns/op\nBenchmarkConstantRegexExpression-12              1000000              1392 ns/op\nok\n```\n\nAPI Breaks\n--\n\nWhile this library has very few cases which will ever result in an API break, it can (and [has](https://github.com/Knetic/govaluate/releases/tag/v2.0.0)) happened. If you are using this in production, vendor the commit you've tested against, or use gopkg.in to redirect your import (e.g., `import \"gopkg.in/Knetic/govaluate.v2\"`). Master branch (while infrequent) _may_ at some point contain API breaking changes, and the author will have no way to communicate these to downstreams, other than creating a new major release.\n\nReleases will explicitly state when an API break happens, and if they do not specify an API break it should be safe to upgrade.\n\nLicense\n--\n\nThis project is licensed under the MIT general use license. You're free to integrate, fork, and play with this code as you feel fit without consulting the author, as long as you provide proper credit to the author in your works.\n"
        },
        {
          "name": "TokenKind.go",
          "type": "blob",
          "size": 1.07421875,
          "content": "package govaluate\n\n/*\n\tRepresents all valid types of tokens that a token can be.\n*/\ntype TokenKind int\n\nconst (\n\tUNKNOWN TokenKind = iota\n\n\tPREFIX\n\tNUMERIC\n\tBOOLEAN\n\tSTRING\n\tPATTERN\n\tTIME\n\tVARIABLE\n\tFUNCTION\n\tSEPARATOR\n\tACCESSOR\n\n\tCOMPARATOR\n\tLOGICALOP\n\tMODIFIER\n\n\tCLAUSE\n\tCLAUSE_CLOSE\n\n\tTERNARY\n)\n\n/*\n\tGetTokenKindString returns a string that describes the given TokenKind.\n\te.g., when passed the NUMERIC TokenKind, this returns the string \"NUMERIC\".\n*/\nfunc (kind TokenKind) String() string {\n\n\tswitch kind {\n\n\tcase PREFIX:\n\t\treturn \"PREFIX\"\n\tcase NUMERIC:\n\t\treturn \"NUMERIC\"\n\tcase BOOLEAN:\n\t\treturn \"BOOLEAN\"\n\tcase STRING:\n\t\treturn \"STRING\"\n\tcase PATTERN:\n\t\treturn \"PATTERN\"\n\tcase TIME:\n\t\treturn \"TIME\"\n\tcase VARIABLE:\n\t\treturn \"VARIABLE\"\n\tcase FUNCTION:\n\t\treturn \"FUNCTION\"\n\tcase SEPARATOR:\n\t\treturn \"SEPARATOR\"\n\tcase COMPARATOR:\n\t\treturn \"COMPARATOR\"\n\tcase LOGICALOP:\n\t\treturn \"LOGICALOP\"\n\tcase MODIFIER:\n\t\treturn \"MODIFIER\"\n\tcase CLAUSE:\n\t\treturn \"CLAUSE\"\n\tcase CLAUSE_CLOSE:\n\t\treturn \"CLAUSE_CLOSE\"\n\tcase TERNARY:\n\t\treturn \"TERNARY\"\n\tcase ACCESSOR:\n\t\treturn \"ACCESSOR\"\n\t}\n\n\treturn \"UNKNOWN\"\n}\n"
        },
        {
          "name": "benchmarks_test.go",
          "type": "blob",
          "size": 6.1259765625,
          "content": "package govaluate\n\nimport (\n\t\"testing\"\n)\n\n/*\n  Serves as a \"water test\" to give an idea of the general overhead of parsing\n*/\nfunc BenchmarkSingleParse(bench *testing.B) {\n\n\tfor i := 0; i < bench.N; i++ {\n\t\tNewEvaluableExpression(\"1\")\n\t}\n}\n\n/*\n  The most common use case, a single variable, modified slightly, compared to a constant.\n  This is the \"expected\" use case of govaluate.\n*/\nfunc BenchmarkSimpleParse(bench *testing.B) {\n\n\tfor i := 0; i < bench.N; i++ {\n\t\tNewEvaluableExpression(\"(requests_made * requests_succeeded / 100) >= 90\")\n\t}\n}\n\n/*\n  Benchmarks all syntax possibilities in one expression.\n*/\nfunc BenchmarkFullParse(bench *testing.B) {\n\n\tvar expression string\n\n\t// represents all the major syntax possibilities.\n\texpression = \"2 > 1 &&\" +\n\t\t\"'something' != 'nothing' || \" +\n\t\t\"'2014-01-20' < 'Wed Jul  8 23:07:35 MDT 2015' && \" +\n\t\t\"[escapedVariable name with spaces] <= unescaped\\\\-variableName &&\" +\n\t\t\"modifierTest + 1000 / 2 > (80 * 100 % 2)\"\n\n\tfor i := 0; i < bench.N; i++ {\n\t\tNewEvaluableExpression(expression)\n\t}\n}\n\n/*\n  Benchmarks the bare-minimum evaluation time\n*/\nfunc BenchmarkEvaluationSingle(bench *testing.B) {\n\n\texpression, _ := NewEvaluableExpression(\"1\")\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(nil)\n\t}\n}\n\n/*\n  Benchmarks evaluation times of literals (no variables, no modifiers)\n*/\nfunc BenchmarkEvaluationNumericLiteral(bench *testing.B) {\n\n\texpression, _ := NewEvaluableExpression(\"(2) > (1)\")\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(nil)\n\t}\n}\n\n/*\n  Benchmarks evaluation times of literals with modifiers\n*/\nfunc BenchmarkEvaluationLiteralModifiers(bench *testing.B) {\n\n\texpression, _ := NewEvaluableExpression(\"(2) + (2) == (4)\")\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(nil)\n\t}\n}\n\nfunc BenchmarkEvaluationParameter(bench *testing.B) {\n\n\texpression, _ := NewEvaluableExpression(\"requests_made\")\n\tparameters := map[string]interface{}{\n\t\t\"requests_made\": 99.0,\n\t}\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(parameters)\n\t}\n}\n\n/*\n  Benchmarks evaluation times of parameters\n*/\nfunc BenchmarkEvaluationParameters(bench *testing.B) {\n\n\texpression, _ := NewEvaluableExpression(\"requests_made > requests_succeeded\")\n\tparameters := map[string]interface{}{\n\t\t\"requests_made\":      99.0,\n\t\t\"requests_succeeded\": 90.0,\n\t}\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(parameters)\n\t}\n}\n\n/*\n  Benchmarks evaluation times of parameters + literals with modifiers\n*/\nfunc BenchmarkEvaluationParametersModifiers(bench *testing.B) {\n\n\texpression, _ := NewEvaluableExpression(\"(requests_made * requests_succeeded / 100) >= 90\")\n\tparameters := map[string]interface{}{\n\t\t\"requests_made\":      99.0,\n\t\t\"requests_succeeded\": 90.0,\n\t}\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(parameters)\n\t}\n}\n\n/*\n  Benchmarks the ludicrously-unlikely worst-case expression,\n  one which uses all features.\n  This is largely a canary benchmark to make sure that any syntax additions don't\n  unnecessarily bloat the evaluation time.\n*/\nfunc BenchmarkComplexExpression(bench *testing.B) {\n\n\tvar expressionString string\n\n\texpressionString = \"2 > 1 &&\" +\n\t\t\"'something' != 'nothing' || \" +\n\t\t\"'2014-01-20' < 'Wed Jul  8 23:07:35 MDT 2015' && \" +\n\t\t\"[escapedVariable name with spaces] <= unescaped\\\\-variableName &&\" +\n\t\t\"modifierTest + 1000 / 2 > (80 * 100 % 2)\"\n\n\texpression, _ := NewEvaluableExpression(expressionString)\n\tparameters := map[string]interface{}{\n\t\t\"escapedVariable name with spaces\": 99.0,\n\t\t\"unescaped\\\\-variableName\":         90.0,\n\t\t\"modifierTest\":                     5.0,\n\t}\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(parameters)\n\t}\n}\n\n/*\n  Benchmarks uncompiled parameter regex operators, which are the most expensive of the lot.\n  Note that regex compilation times are unpredictable and wily things. The regex engine has a lot of edge cases\n  and possible performance pitfalls. This test doesn't aim to be comprehensive against all possible regex scenarios,\n  it is primarily concerned with tracking how much longer it takes to compile a regex at evaluation-time than during parse-time.\n*/\nfunc BenchmarkRegexExpression(bench *testing.B) {\n\n\tvar expressionString string\n\n\texpressionString = \"(foo !~ bar) && (foobar =~ oba)\"\n\n\texpression, _ := NewEvaluableExpression(expressionString)\n\tparameters := map[string]interface{}{\n\t\t\"foo\": \"foo\",\n\t\t\"bar\": \"bar\",\n\t\t\"baz\": \"baz\",\n\t\t\"oba\": \".*oba.*\",\n\t}\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(parameters)\n\t}\n}\n\n/*\n\tBenchmarks pre-compilable regex patterns. Meant to serve as a sanity check that constant strings used as regex patterns\n\tare actually being precompiled.\n\tAlso demonstrates that (generally) compiling a regex at evaluation-time takes an order of magnitude more time than pre-compiling.\n*/\nfunc BenchmarkConstantRegexExpression(bench *testing.B) {\n\n\texpressionString := \"(foo !~ '[bB]az') && (bar =~ '[bB]ar')\"\n\texpression, _ := NewEvaluableExpression(expressionString)\n\n\tparameters := map[string]interface{}{\n\t\t\"foo\": \"foo\",\n\t\t\"bar\": \"bar\",\n\t}\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(parameters)\n\t}\n}\n\nfunc BenchmarkAccessors(bench *testing.B) {\n\n\texpressionString := \"foo.Int\"\n\texpression, _ := NewEvaluableExpression(expressionString)\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(fooFailureParameters)\n\t}\n}\n\nfunc BenchmarkAccessorMethod(bench *testing.B) {\n\n\texpressionString := \"foo.Func()\"\n\texpression, _ := NewEvaluableExpression(expressionString)\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(fooFailureParameters)\n\t}\n}\n\nfunc BenchmarkAccessorMethodParams(bench *testing.B) {\n\n\texpressionString := \"foo.FuncArgStr('bonk')\"\n\texpression, _ := NewEvaluableExpression(expressionString)\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(fooFailureParameters)\n\t}\n}\n\nfunc BenchmarkNestedAccessors(bench *testing.B) {\n\n\texpressionString := \"foo.Nested.Funk\"\n\texpression, _ := NewEvaluableExpression(expressionString)\n\n\tbench.ResetTimer()\n\tfor i := 0; i < bench.N; i++ {\n\t\texpression.Evaluate(fooFailureParameters)\n\t}\n}\n"
        },
        {
          "name": "dummies_test.go",
          "type": "blob",
          "size": 1.68359375,
          "content": "package govaluate\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n/*\n\tStruct used to test \"parameter calls\".\n*/\ntype dummyParameter struct {\n\tString    string\n\tInt       int\n\tBoolFalse bool\n\tNil       interface{}\n\tNested    dummyNestedParameter\n}\n\nfunc (this dummyParameter) Func() string {\n\treturn \"funk\"\n}\n\nfunc (this dummyParameter) Func2() (string, error) {\n\treturn \"frink\", nil\n}\n\nfunc (this *dummyParameter) Func3() string {\n\treturn \"fronk\"\n}\n\nfunc (this dummyParameter) FuncArgStr(arg1 string) string {\n\treturn arg1\n}\n\nfunc (this dummyParameter) TestArgs(str string, ui uint, ui8 uint8, ui16 uint16, ui32 uint32, ui64 uint64, i int, i8 int8, i16 int16, i32 int32, i64 int64, f32 float32, f64 float64, b bool) string {\n\t\n\tvar sum float64\n\t\n\tsum = float64(ui) + float64(ui8) + float64(ui16) + float64(ui32) + float64(ui64)\n\tsum += float64(i) + float64(i8) + float64(i16) + float64(i32) + float64(i64)\n\tsum += float64(f32)\n\n\tif b {\n\t\tsum += f64\n\t}\n\n\treturn fmt.Sprintf(\"%v: %v\", str, sum)\n}\n\nfunc (this dummyParameter) AlwaysFail() (interface{}, error) {\n\treturn nil, errors.New(\"function should always fail\")\n}\n\ntype dummyNestedParameter struct {\n\tFunk string\n}\n\nfunc (this dummyNestedParameter) Dunk(arg1 string) string {\n\treturn arg1 + \"dunk\"\n}\n\nvar dummyParameterInstance = dummyParameter{\n\tString:    \"string!\",\n\tInt:       101,\n\tBoolFalse: false,\n\tNil:       nil,\n\tNested: dummyNestedParameter{\n\t\tFunk: \"funkalicious\",\n\t},\n}\n\nvar fooParameter = EvaluationParameter{\n\tName:  \"foo\",\n\tValue: dummyParameterInstance,\n}\n\nvar fooPtrParameter = EvaluationParameter{\n\tName:  \"fooptr\",\n\tValue: &dummyParameterInstance,\n}\n\nvar fooFailureParameters = map[string]interface{}{\n\t\"foo\":    fooParameter.Value,\n\t\"fooptr\": &fooPtrParameter.Value,\n}\n"
        },
        {
          "name": "evaluationFailure_test.go",
          "type": "blob",
          "size": 12.7353515625,
          "content": "package govaluate\n\n/*\n  Tests to make sure evaluation fails in the expected ways.\n*/\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype DebugStruct struct {\n\tx int\n}\n\n/*\n\tRepresents a test for parsing failures\n*/\ntype EvaluationFailureTest struct {\n\tName       string\n\tInput      string\n\tFunctions  map[string]ExpressionFunction\n\tParameters map[string]interface{}\n\tExpected   string\n}\n\nconst (\n\tINVALID_MODIFIER_TYPES   string = \"cannot be used with the modifier\"\n\tINVALID_COMPARATOR_TYPES        = \"cannot be used with the comparator\"\n\tINVALID_LOGICALOP_TYPES         = \"cannot be used with the logical operator\"\n\tINVALID_TERNARY_TYPES           = \"cannot be used with the ternary operator\"\n\tABSENT_PARAMETER                = \"No parameter\"\n\tINVALID_REGEX                   = \"Unable to compile regexp pattern\"\n\tINVALID_PARAMETER_CALL          = \"No method or field\"\n\tTOO_FEW_ARGS                    = \"Too few arguments to parameter call\"\n\tTOO_MANY_ARGS                   = \"Too many arguments to parameter call\"\n\tMISMATCHED_PARAMETERS           = \"Argument type conversion failed\"\n)\n\n// preset parameter map of types that can be used in an evaluation failure test to check typing.\nvar EVALUATION_FAILURE_PARAMETERS = map[string]interface{}{\n\t\"number\": 1,\n\t\"string\": \"foo\",\n\t\"bool\":   true,\n}\n\nfunc TestComplexParameter(test *testing.T) {\n\n\tvar expression *EvaluableExpression\n\tvar err error\n\tvar v interface{}\n\n\tparameters := map[string]interface{}{\n\t\t\"complex64\":  complex64(0),\n\t\t\"complex128\": complex128(0),\n\t}\n\n\texpression, _ = NewEvaluableExpression(\"complex64\")\n\tv, err = expression.Evaluate(parameters)\n\tif err != nil {\n\t\ttest.Errorf(\"Expected no error, but have %s\", err)\n\t}\n\tif v.(complex64) != complex64(0) {\n\t\ttest.Errorf(\"Expected %v == %v\", v, complex64(0))\n\t}\n\n\texpression, _ = NewEvaluableExpression(\"complex128\")\n\tv, err = expression.Evaluate(parameters)\n\tif err != nil {\n\t\ttest.Errorf(\"Expected no error, but have %s\", err)\n\t}\n\tif v.(complex128) != complex128(0) {\n\t\ttest.Errorf(\"Expected %v == %v\", v, complex128(0))\n\t}\n}\n\nfunc TestStructParameter(t *testing.T) {\n\texpected := DebugStruct{}\n\texpression, _ := NewEvaluableExpression(\"foo\")\n\tparameters := map[string]interface{}{\"foo\": expected}\n\tv, err := expression.Evaluate(parameters)\n\tif err != nil {\n\t\tt.Errorf(\"Expected no error, but have %s\", err)\n\t} else if v.(DebugStruct) != expected {\n\t\tt.Errorf(\"Values mismatch: %v != %v\", expected, v)\n\t}\n}\n\nfunc TestNilParameterUsage(test *testing.T) {\n\n\texpression, err := NewEvaluableExpression(\"2 > 1\")\n\t_, err = expression.Evaluate(nil)\n\n\tif err != nil {\n\t\ttest.Errorf(\"Expected no error from nil parameter evaluation, got %v\\n\", err)\n\t\treturn\n\t}\n}\n\nfunc TestModifierTyping(test *testing.T) {\n\n\tevaluationTests := []EvaluationFailureTest{\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"PLUS literal number to literal bool\",\n\t\t\tInput:    \"1 + true\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"PLUS number to bool\",\n\t\t\tInput:    \"number + bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"MINUS number to bool\",\n\t\t\tInput:    \"number - bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"MINUS number to bool\",\n\t\t\tInput:    \"number - bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"MULTIPLY number to bool\",\n\t\t\tInput:    \"number * bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"DIVIDE number to bool\",\n\t\t\tInput:    \"number / bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"EXPONENT number to bool\",\n\t\t\tInput:    \"number ** bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"MODULUS number to bool\",\n\t\t\tInput:    \"number % bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"XOR number to bool\",\n\t\t\tInput:    \"number % bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"BITWISE_OR number to bool\",\n\t\t\tInput:    \"number | bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"BITWISE_AND number to bool\",\n\t\t\tInput:    \"number & bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"BITWISE_XOR number to bool\",\n\t\t\tInput:    \"number ^ bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"BITWISE_LSHIFT number to bool\",\n\t\t\tInput:    \"number << bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"BITWISE_RSHIFT number to bool\",\n\t\t\tInput:    \"number >> bool\",\n\t\t\tExpected: INVALID_MODIFIER_TYPES,\n\t\t},\n\t}\n\n\trunEvaluationFailureTests(evaluationTests, test)\n}\n\nfunc TestLogicalOperatorTyping(test *testing.T) {\n\n\tevaluationTests := []EvaluationFailureTest{\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"AND number to number\",\n\t\t\tInput:    \"number && number\",\n\t\t\tExpected: INVALID_LOGICALOP_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"OR number to number\",\n\t\t\tInput:    \"number || number\",\n\t\t\tExpected: INVALID_LOGICALOP_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"AND string to string\",\n\t\t\tInput:    \"string && string\",\n\t\t\tExpected: INVALID_LOGICALOP_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"OR string to string\",\n\t\t\tInput:    \"string || string\",\n\t\t\tExpected: INVALID_LOGICALOP_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"AND number to string\",\n\t\t\tInput:    \"number && string\",\n\t\t\tExpected: INVALID_LOGICALOP_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"OR number to string\",\n\t\t\tInput:    \"number || string\",\n\t\t\tExpected: INVALID_LOGICALOP_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"AND bool to string\",\n\t\t\tInput:    \"bool && string\",\n\t\t\tExpected: INVALID_LOGICALOP_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"OR string to bool\",\n\t\t\tInput:    \"string || bool\",\n\t\t\tExpected: INVALID_LOGICALOP_TYPES,\n\t\t},\n\t}\n\n\trunEvaluationFailureTests(evaluationTests, test)\n}\n\n/*\n\tWhile there is type-safe transitions checked at parse-time, tested in the \"parsing_test\" and \"parsingFailure_test\" files,\n\twe also need to make sure that we receive type mismatch errors during evaluation.\n*/\nfunc TestComparatorTyping(test *testing.T) {\n\n\tevaluationTests := []EvaluationFailureTest{\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"GT literal bool to literal bool\",\n\t\t\tInput:    \"true > true\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"GT bool to bool\",\n\t\t\tInput:    \"bool > bool\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"GTE bool to bool\",\n\t\t\tInput:    \"bool >= bool\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"LT bool to bool\",\n\t\t\tInput:    \"bool < bool\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"LTE bool to bool\",\n\t\t\tInput:    \"bool <= bool\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"GT number to string\",\n\t\t\tInput:    \"number > string\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"GTE number to string\",\n\t\t\tInput:    \"number >= string\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"LT number to string\",\n\t\t\tInput:    \"number < string\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"REQ number to string\",\n\t\t\tInput:    \"number =~ string\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"REQ number to bool\",\n\t\t\tInput:    \"number =~ bool\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"REQ bool to number\",\n\t\t\tInput:    \"bool =~ number\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"REQ bool to string\",\n\t\t\tInput:    \"bool =~ string\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"NREQ number to string\",\n\t\t\tInput:    \"number !~ string\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"NREQ number to bool\",\n\t\t\tInput:    \"number !~ bool\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"NREQ bool to number\",\n\t\t\tInput:    \"bool !~ number\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"NREQ bool to string\",\n\t\t\tInput:    \"bool !~ string\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"IN non-array numeric\",\n\t\t\tInput:    \"1 in 2\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"IN non-array string\",\n\t\t\tInput:    \"1 in 'foo'\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"IN non-array boolean\",\n\t\t\tInput:    \"1 in true\",\n\t\t\tExpected: INVALID_COMPARATOR_TYPES,\n\t\t},\n\t}\n\n\trunEvaluationFailureTests(evaluationTests, test)\n}\n\nfunc TestTernaryTyping(test *testing.T) {\n\n\tevaluationTests := []EvaluationFailureTest{\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"Ternary with number\",\n\t\t\tInput:    \"10 ? true\",\n\t\t\tExpected: INVALID_TERNARY_TYPES,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:     \"Ternary with string\",\n\t\t\tInput:    \"'foo' ? true\",\n\t\t\tExpected: INVALID_TERNARY_TYPES,\n\t\t},\n\t}\n\n\trunEvaluationFailureTests(evaluationTests, test)\n}\n\nfunc TestRegexParameterCompilation(test *testing.T) {\n\n\tevaluationTests := []EvaluationFailureTest{\n\t\tEvaluationFailureTest{\n\n\t\t\tName:  \"Regex equality runtime parsing\",\n\t\t\tInput: \"'foo' =~ foo\",\n\t\t\tParameters: map[string]interface{}{\n\t\t\t\t\"foo\": \"[foo\",\n\t\t\t},\n\t\t\tExpected: INVALID_REGEX,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:  \"Regex inequality runtime parsing\",\n\t\t\tInput: \"'foo' =~ foo\",\n\t\t\tParameters: map[string]interface{}{\n\t\t\t\t\"foo\": \"[foo\",\n\t\t\t},\n\t\t\tExpected: INVALID_REGEX,\n\t\t},\n\t}\n\n\trunEvaluationFailureTests(evaluationTests, test)\n}\n\nfunc TestFunctionExecution(test *testing.T) {\n\n\tevaluationTests := []EvaluationFailureTest{\n\t\tEvaluationFailureTest{\n\n\t\t\tName:  \"Function error bubbling\",\n\t\t\tInput: \"error()\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"error\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn nil, errors.New(\"Huge problems\")\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: \"Huge problems\",\n\t\t},\n\t}\n\n\trunEvaluationFailureTests(evaluationTests, test)\n}\n\nfunc TestInvalidParameterCalls(test *testing.T) {\n\n\tevaluationTests := []EvaluationFailureTest{\n\t\tEvaluationFailureTest{\n\n\t\t\tName:       \"Missing parameter field reference\",\n\t\t\tInput:      \"foo.NotExists\",\n\t\t\tParameters: fooFailureParameters,\n\t\t\tExpected:   INVALID_PARAMETER_CALL,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:       \"Parameter method call on missing function\",\n\t\t\tInput:      \"foo.NotExist()\",\n\t\t\tParameters: fooFailureParameters,\n\t\t\tExpected:   INVALID_PARAMETER_CALL,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:       \"Nested missing parameter field reference\",\n\t\t\tInput:      \"foo.Nested.NotExists\",\n\t\t\tParameters: fooFailureParameters,\n\t\t\tExpected:   INVALID_PARAMETER_CALL,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:       \"Parameter method call returns error\",\n\t\t\tInput:      \"foo.AlwaysFail()\",\n\t\t\tParameters: fooFailureParameters,\n\t\t\tExpected:   \"function should always fail\",\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:       \"Too few arguments to parameter call\",\n\t\t\tInput:      \"foo.FuncArgStr()\",\n\t\t\tParameters: fooFailureParameters,\n\t\t\tExpected:   TOO_FEW_ARGS,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:       \"Too many arguments to parameter call\",\n\t\t\tInput:      \"foo.FuncArgStr('foo', 'bar', 15)\",\n\t\t\tParameters: fooFailureParameters,\n\t\t\tExpected:   TOO_MANY_ARGS,\n\t\t},\n\t\tEvaluationFailureTest{\n\n\t\t\tName:       \"Mismatched parameters\",\n\t\t\tInput:      \"foo.FuncArgStr(5)\",\n\t\t\tParameters: fooFailureParameters,\n\t\t\tExpected:   MISMATCHED_PARAMETERS,\n\t\t},\n\t}\n\n\trunEvaluationFailureTests(evaluationTests, test)\n}\n\nfunc runEvaluationFailureTests(evaluationTests []EvaluationFailureTest, test *testing.T) {\n\n\tvar expression *EvaluableExpression\n\tvar err error\n\n\tfmt.Printf(\"Running %d negative parsing test cases...\\n\", len(evaluationTests))\n\n\tfor _, testCase := range evaluationTests {\n\n\t\tif len(testCase.Functions) > 0 {\n\t\t\texpression, err = NewEvaluableExpressionWithFunctions(testCase.Input, testCase.Functions)\n\t\t} else {\n\t\t\texpression, err = NewEvaluableExpression(testCase.Input)\n\t\t}\n\n\t\tif err != nil {\n\n\t\t\ttest.Logf(\"Test '%s' failed\", testCase.Name)\n\t\t\ttest.Logf(\"Expected evaluation error, but got parsing error: '%s'\", err)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\n\t\tif testCase.Parameters == nil {\n\t\t\ttestCase.Parameters = EVALUATION_FAILURE_PARAMETERS\n\t\t}\n\n\t\t_, err = expression.Evaluate(testCase.Parameters)\n\n\t\tif err == nil {\n\n\t\t\ttest.Logf(\"Test '%s' failed\", testCase.Name)\n\t\t\ttest.Logf(\"Expected error, received none.\")\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\n\t\tif !strings.Contains(err.Error(), testCase.Expected) {\n\n\t\t\ttest.Logf(\"Test '%s' failed\", testCase.Name)\n\t\t\ttest.Logf(\"Got error: '%s', expected '%s'\", err.Error(), testCase.Expected)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "evaluationStage.go",
          "type": "blob",
          "size": 14.05078125,
          "content": "package govaluate\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nconst (\n\tlogicalErrorFormat    string = \"Value '%v' cannot be used with the logical operator '%v', it is not a bool\"\n\tmodifierErrorFormat   string = \"Value '%v' cannot be used with the modifier '%v', it is not a number\"\n\tcomparatorErrorFormat string = \"Value '%v' cannot be used with the comparator '%v', it is not a number\"\n\tternaryErrorFormat    string = \"Value '%v' cannot be used with the ternary operator '%v', it is not a bool\"\n\tprefixErrorFormat     string = \"Value '%v' cannot be used with the prefix '%v'\"\n)\n\ntype evaluationOperator func(left interface{}, right interface{}, parameters Parameters) (interface{}, error)\ntype stageTypeCheck func(value interface{}) bool\ntype stageCombinedTypeCheck func(left interface{}, right interface{}) bool\n\ntype evaluationStage struct {\n\tsymbol OperatorSymbol\n\n\tleftStage, rightStage *evaluationStage\n\n\t// the operation that will be used to evaluate this stage (such as adding [left] to [right] and return the result)\n\toperator evaluationOperator\n\n\t// ensures that both left and right values are appropriate for this stage. Returns an error if they aren't operable.\n\tleftTypeCheck  stageTypeCheck\n\trightTypeCheck stageTypeCheck\n\n\t// if specified, will override whatever is used in \"leftTypeCheck\" and \"rightTypeCheck\".\n\t// primarily used for specific operators that don't care which side a given type is on, but still requires one side to be of a given type\n\t// (like string concat)\n\ttypeCheck stageCombinedTypeCheck\n\n\t// regardless of which type check is used, this string format will be used as the error message for type errors\n\ttypeErrorFormat string\n}\n\nvar (\n\t_true  = interface{}(true)\n\t_false = interface{}(false)\n)\n\nfunc (this *evaluationStage) swapWith(other *evaluationStage) {\n\n\ttemp := *other\n\tother.setToNonStage(*this)\n\tthis.setToNonStage(temp)\n}\n\nfunc (this *evaluationStage) setToNonStage(other evaluationStage) {\n\n\tthis.symbol = other.symbol\n\tthis.operator = other.operator\n\tthis.leftTypeCheck = other.leftTypeCheck\n\tthis.rightTypeCheck = other.rightTypeCheck\n\tthis.typeCheck = other.typeCheck\n\tthis.typeErrorFormat = other.typeErrorFormat\n}\n\nfunc (this *evaluationStage) isShortCircuitable() bool {\n\n\tswitch this.symbol {\n\tcase AND:\n\t\tfallthrough\n\tcase OR:\n\t\tfallthrough\n\tcase TERNARY_TRUE:\n\t\tfallthrough\n\tcase TERNARY_FALSE:\n\t\tfallthrough\n\tcase COALESCE:\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc noopStageRight(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn right, nil\n}\n\nfunc addStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\n\t// string concat if either are strings\n\tif isString(left) || isString(right) {\n\t\treturn fmt.Sprintf(\"%v%v\", left, right), nil\n\t}\n\n\treturn left.(float64) + right.(float64), nil\n}\nfunc subtractStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn left.(float64) - right.(float64), nil\n}\nfunc multiplyStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn left.(float64) * right.(float64), nil\n}\nfunc divideStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn left.(float64) / right.(float64), nil\n}\nfunc exponentStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn math.Pow(left.(float64), right.(float64)), nil\n}\nfunc modulusStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn math.Mod(left.(float64), right.(float64)), nil\n}\nfunc gteStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\tif isString(left) && isString(right) {\n\t\treturn boolIface(left.(string) >= right.(string)), nil\n\t}\n\treturn boolIface(left.(float64) >= right.(float64)), nil\n}\nfunc gtStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\tif isString(left) && isString(right) {\n\t\treturn boolIface(left.(string) > right.(string)), nil\n\t}\n\treturn boolIface(left.(float64) > right.(float64)), nil\n}\nfunc lteStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\tif isString(left) && isString(right) {\n\t\treturn boolIface(left.(string) <= right.(string)), nil\n\t}\n\treturn boolIface(left.(float64) <= right.(float64)), nil\n}\nfunc ltStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\tif isString(left) && isString(right) {\n\t\treturn boolIface(left.(string) < right.(string)), nil\n\t}\n\treturn boolIface(left.(float64) < right.(float64)), nil\n}\nfunc equalStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn boolIface(reflect.DeepEqual(left, right)), nil\n}\nfunc notEqualStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn boolIface(!reflect.DeepEqual(left, right)), nil\n}\nfunc andStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn boolIface(left.(bool) && right.(bool)), nil\n}\nfunc orStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn boolIface(left.(bool) || right.(bool)), nil\n}\nfunc negateStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn -right.(float64), nil\n}\nfunc invertStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn boolIface(!right.(bool)), nil\n}\nfunc bitwiseNotStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn float64(^int64(right.(float64))), nil\n}\nfunc ternaryIfStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\tif left.(bool) {\n\t\treturn right, nil\n\t}\n\treturn nil, nil\n}\nfunc ternaryElseStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\tif left != nil {\n\t\treturn left, nil\n\t}\n\treturn right, nil\n}\n\nfunc regexStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\n\tvar pattern *regexp.Regexp\n\tvar err error\n\n\tswitch right.(type) {\n\tcase string:\n\t\tpattern, err = regexp.Compile(right.(string))\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(fmt.Sprintf(\"Unable to compile regexp pattern '%v': %v\", right, err))\n\t\t}\n\tcase *regexp.Regexp:\n\t\tpattern = right.(*regexp.Regexp)\n\t}\n\n\treturn pattern.Match([]byte(left.(string))), nil\n}\n\nfunc notRegexStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\n\tret, err := regexStage(left, right, parameters)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn !(ret.(bool)), nil\n}\n\nfunc bitwiseOrStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn float64(int64(left.(float64)) | int64(right.(float64))), nil\n}\nfunc bitwiseAndStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn float64(int64(left.(float64)) & int64(right.(float64))), nil\n}\nfunc bitwiseXORStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn float64(int64(left.(float64)) ^ int64(right.(float64))), nil\n}\nfunc leftShiftStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn float64(uint64(left.(float64)) << uint64(right.(float64))), nil\n}\nfunc rightShiftStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\treturn float64(uint64(left.(float64)) >> uint64(right.(float64))), nil\n}\n\nfunc makeParameterStage(parameterName string) evaluationOperator {\n\n\treturn func(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\t\tvalue, err := parameters.Get(parameterName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn value, nil\n\t}\n}\n\nfunc makeLiteralStage(literal interface{}) evaluationOperator {\n\treturn func(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\t\treturn literal, nil\n\t}\n}\n\nfunc makeFunctionStage(function ExpressionFunction) evaluationOperator {\n\n\treturn func(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\n\t\tif right == nil {\n\t\t\treturn function()\n\t\t}\n\n\t\tswitch right.(type) {\n\t\tcase []interface{}:\n\t\t\treturn function(right.([]interface{})...)\n\t\tdefault:\n\t\t\treturn function(right)\n\t\t}\n\t}\n}\n\nfunc typeConvertParam(p reflect.Value, t reflect.Type) (ret reflect.Value, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terrorMsg := fmt.Sprintf(\"Argument type conversion failed: failed to convert '%s' to '%s'\", p.Kind().String(), t.Kind().String())\n\t\t\terr = errors.New(errorMsg)\n\t\t\tret = p\n\t\t}\n\t}()\n\n\treturn p.Convert(t), nil\n}\n\nfunc typeConvertParams(method reflect.Value, params []reflect.Value) ([]reflect.Value, error) {\n\n\tmethodType := method.Type()\n\tnumIn := methodType.NumIn()\n\tnumParams := len(params)\n\n\tif numIn != numParams {\n\t\tif numIn > numParams {\n\t\t\treturn nil, fmt.Errorf(\"Too few arguments to parameter call: got %d arguments, expected %d\", len(params), numIn)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"Too many arguments to parameter call: got %d arguments, expected %d\", len(params), numIn)\n\t}\n\n\tfor i := 0; i < numIn; i++ {\n\t\tt := methodType.In(i)\n\t\tp := params[i]\n\t\tpt := p.Type()\n\n\t\tif t.Kind() != pt.Kind() {\n\t\t\tnp, err := typeConvertParam(p, t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tparams[i] = np\n\t\t}\n\t}\n\n\treturn params, nil\n}\n\nfunc makeAccessorStage(pair []string) evaluationOperator {\n\n\treconstructed := strings.Join(pair, \".\")\n\n\treturn func(left interface{}, right interface{}, parameters Parameters) (ret interface{}, err error) {\n\n\t\tvar params []reflect.Value\n\n\t\tvalue, err := parameters.Get(pair[0])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// while this library generally tries to handle panic-inducing cases on its own,\n\t\t// accessors are a sticky case which have a lot of possible ways to fail.\n\t\t// therefore every call to an accessor sets up a defer that tries to recover from panics, converting them to errors.\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\terrorMsg := fmt.Sprintf(\"Failed to access '%s': %v\", reconstructed, r.(string))\n\t\t\t\terr = errors.New(errorMsg)\n\t\t\t\tret = nil\n\t\t\t}\n\t\t}()\n\n\t\tfor i := 1; i < len(pair); i++ {\n\n\t\t\tcoreValue := reflect.ValueOf(value)\n\n\t\t\tvar corePtrVal reflect.Value\n\n\t\t\t// if this is a pointer, resolve it.\n\t\t\tif coreValue.Kind() == reflect.Ptr {\n\t\t\t\tcorePtrVal = coreValue\n\t\t\t\tcoreValue = coreValue.Elem()\n\t\t\t}\n\n\t\t\tif coreValue.Kind() != reflect.Struct {\n\t\t\t\treturn nil, errors.New(\"Unable to access '\" + pair[i] + \"', '\" + pair[i-1] + \"' is not a struct\")\n\t\t\t}\n\n\t\t\tfield := coreValue.FieldByName(pair[i])\n\t\t\tif field != (reflect.Value{}) {\n\t\t\t\tvalue = field.Interface()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmethod := coreValue.MethodByName(pair[i])\n\t\t\tif method == (reflect.Value{}) {\n\t\t\t\tif corePtrVal.IsValid() {\n\t\t\t\t\tmethod = corePtrVal.MethodByName(pair[i])\n\t\t\t\t}\n\t\t\t\tif method == (reflect.Value{}) {\n\t\t\t\t\treturn nil, errors.New(\"No method or field '\" + pair[i] + \"' present on parameter '\" + pair[i-1] + \"'\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch right.(type) {\n\t\t\tcase []interface{}:\n\n\t\t\t\tgivenParams := right.([]interface{})\n\t\t\t\tparams = make([]reflect.Value, len(givenParams))\n\t\t\t\tfor idx, _ := range givenParams {\n\t\t\t\t\tparams[idx] = reflect.ValueOf(givenParams[idx])\n\t\t\t\t}\n\n\t\t\tdefault:\n\n\t\t\t\tif right == nil {\n\t\t\t\t\tparams = []reflect.Value{}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tparams = []reflect.Value{reflect.ValueOf(right.(interface{}))}\n\t\t\t}\n\n\t\t\tparams, err = typeConvertParams(method, params)\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.New(\"Method call failed - '\" + pair[0] + \".\" + pair[1] + \"': \" + err.Error())\n\t\t\t}\n\n\t\t\treturned := method.Call(params)\n\t\t\tretLength := len(returned)\n\n\t\t\tif retLength == 0 {\n\t\t\t\treturn nil, errors.New(\"Method call '\" + pair[i-1] + \".\" + pair[i] + \"' did not return any values.\")\n\t\t\t}\n\n\t\t\tif retLength == 1 {\n\n\t\t\t\tvalue = returned[0].Interface()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif retLength == 2 {\n\n\t\t\t\terrIface := returned[1].Interface()\n\t\t\t\terr, validType := errIface.(error)\n\n\t\t\t\tif validType && errIface != nil {\n\t\t\t\t\treturn returned[0].Interface(), err\n\t\t\t\t}\n\n\t\t\t\tvalue = returned[0].Interface()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn nil, errors.New(\"Method call '\" + pair[0] + \".\" + pair[1] + \"' did not return either one value, or a value and an error. Cannot interpret meaning.\")\n\t\t}\n\n\t\tvalue = castToFloat64(value)\n\t\treturn value, nil\n\t}\n}\n\nfunc separatorStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\n\tvar ret []interface{}\n\n\tswitch left.(type) {\n\tcase []interface{}:\n\t\tret = append(left.([]interface{}), right)\n\tdefault:\n\t\tret = []interface{}{left, right}\n\t}\n\n\treturn ret, nil\n}\n\nfunc inStage(left interface{}, right interface{}, parameters Parameters) (interface{}, error) {\n\n\tfor _, value := range right.([]interface{}) {\n\t\tif left == value {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\n//\n\nfunc isString(value interface{}) bool {\n\n\tswitch value.(type) {\n\tcase string:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isRegexOrString(value interface{}) bool {\n\n\tswitch value.(type) {\n\tcase string:\n\t\treturn true\n\tcase *regexp.Regexp:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isBool(value interface{}) bool {\n\tswitch value.(type) {\n\tcase bool:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isFloat64(value interface{}) bool {\n\tswitch value.(type) {\n\tcase float64:\n\t\treturn true\n\t}\n\treturn false\n}\n\n/*\n\tAddition usually means between numbers, but can also mean string concat.\n\tString concat needs one (or both) of the sides to be a string.\n*/\nfunc additionTypeCheck(left interface{}, right interface{}) bool {\n\n\tif isFloat64(left) && isFloat64(right) {\n\t\treturn true\n\t}\n\tif !isString(left) && !isString(right) {\n\t\treturn false\n\t}\n\treturn true\n}\n\n/*\n\tComparison can either be between numbers, or lexicographic between two strings,\n\tbut never between the two.\n*/\nfunc comparatorTypeCheck(left interface{}, right interface{}) bool {\n\n\tif isFloat64(left) && isFloat64(right) {\n\t\treturn true\n\t}\n\tif isString(left) && isString(right) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isArray(value interface{}) bool {\n\tswitch value.(type) {\n\tcase []interface{}:\n\t\treturn true\n\t}\n\treturn false\n}\n\n/*\n\tConverting a boolean to an interface{} requires an allocation.\n\tWe can use interned bools to avoid this cost.\n*/\nfunc boolIface(b bool) interface{} {\n\tif b {\n\t\treturn _true\n\t}\n\treturn _false\n}\n"
        },
        {
          "name": "evaluation_test.go",
          "type": "blob",
          "size": 31.78515625,
          "content": "package govaluate\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"testing\"\n\t\"time\"\n)\n\n/*\n\tRepresents a test of expression evaluation\n*/\ntype EvaluationTest struct {\n\tName       string\n\tInput      string\n\tFunctions  map[string]ExpressionFunction\n\tParameters []EvaluationParameter\n\tExpected   interface{}\n}\n\ntype EvaluationParameter struct {\n\tName  string\n\tValue interface{}\n}\n\nfunc TestNoParameterEvaluation(test *testing.T) {\n\n\tevaluationTests := []EvaluationTest{\n\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single PLUS\",\n\t\t\tInput:    \"51 + 49\",\n\t\t\tExpected: 100.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single MINUS\",\n\t\t\tInput:    \"100 - 51\",\n\t\t\tExpected: 49.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single BITWISE AND\",\n\t\t\tInput:    \"100 & 50\",\n\t\t\tExpected: 32.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single BITWISE OR\",\n\t\t\tInput:    \"100 | 50\",\n\t\t\tExpected: 118.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single BITWISE XOR\",\n\t\t\tInput:    \"100 ^ 50\",\n\t\t\tExpected: 86.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single shift left\",\n\t\t\tInput:    \"2 << 1\",\n\t\t\tExpected: 4.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single shift right\",\n\t\t\tInput:    \"2 >> 1\",\n\t\t\tExpected: 1.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single BITWISE NOT\",\n\t\t\tInput:    \"~10\",\n\t\t\tExpected: -11.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single MULTIPLY\",\n\t\t\tInput:    \"5 * 20\",\n\t\t\tExpected: 100.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single DIVIDE\",\n\t\t\tInput:    \"100 / 20\",\n\t\t\tExpected: 5.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single even MODULUS\",\n\t\t\tInput:    \"100 % 2\",\n\t\t\tExpected: 0.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single odd MODULUS\",\n\t\t\tInput:    \"101 % 2\",\n\t\t\tExpected: 1.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Single EXPONENT\",\n\t\t\tInput:    \"10 ** 2\",\n\t\t\tExpected: 100.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Compound PLUS\",\n\t\t\tInput:    \"20 + 30 + 50\",\n\t\t\tExpected: 100.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Compound BITWISE AND\",\n\t\t\tInput:    \"20 & 30 & 50\",\n\t\t\tExpected: 16.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Mutiple operators\",\n\t\t\tInput:    \"20 * 5 - 49\",\n\t\t\tExpected: 51.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Parenthesis usage\",\n\t\t\tInput:    \"100 - (5 * 10)\",\n\t\t\tExpected: 50.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Nested parentheses\",\n\t\t\tInput:    \"50 + (5 * (15 - 5))\",\n\t\t\tExpected: 100.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Nested parentheses with bitwise\",\n\t\t\tInput:    \"100 ^ (23 * (2 | 5))\",\n\t\t\tExpected: 197.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Logical OR operation of two clauses\",\n\t\t\tInput:    \"(1 == 1) || (true == true)\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Logical AND operation of two clauses\",\n\t\t\tInput:    \"(1 == 1) && (true == true)\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Implicit boolean\",\n\t\t\tInput:    \"2 > 1\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Compound boolean\",\n\t\t\tInput:    \"5 < 10 && 1 < 5\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Evaluated true && false operation (for issue #8)\",\n\t\t\tInput:    \"1 > 10 && 11 > 10\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Evaluated true && false operation (for issue #8)\",\n\t\t\tInput:    \"true == true && false == true\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Parenthesis boolean\",\n\t\t\tInput:    \"10 < 50 && (1 != 2 && 1 > 0)\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Comparison of string constants\",\n\t\t\tInput:    \"'foo' == 'foo'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"NEQ comparison of string constants\",\n\t\t\tInput:    \"'foo' != 'bar'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"REQ comparison of string constants\",\n\t\t\tInput:    \"'foobar' =~ 'oba'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"NREQ comparison of string constants\",\n\t\t\tInput:    \"'foo' !~ 'bar'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Multiplicative/additive order\",\n\t\t\tInput:    \"5 + 10 * 2\",\n\t\t\tExpected: 25.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Multiple constant multiplications\",\n\t\t\tInput:    \"10 * 10 * 10\",\n\t\t\tExpected: 1000.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Multiple adds/multiplications\",\n\t\t\tInput:    \"10 * 10 * 10 + 1 * 10 * 10\",\n\t\t\tExpected: 1100.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Modulus precedence\",\n\t\t\tInput:    \"1 + 101 % 2 * 5\",\n\t\t\tExpected: 6.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Exponent precedence\",\n\t\t\tInput:    \"1 + 5 ** 3 % 2 * 5\",\n\t\t\tExpected: 6.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Bit shift precedence\",\n\t\t\tInput:    \"50 << 1 & 90\",\n\t\t\tExpected: 64.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Bit shift precedence\",\n\t\t\tInput:    \"90 & 50 << 1\",\n\t\t\tExpected: 64.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Bit shift precedence amongst non-bitwise\",\n\t\t\tInput:    \"90 + 50 << 1 * 5\",\n\t\t\tExpected: 4480.0,\n\t\t},\n\t\tEvaluationTest{\n\t\t\tName:     \"Order of non-commutative same-precedence operators (additive)\",\n\t\t\tInput:    \"1 - 2 - 4 - 8\",\n\t\t\tExpected: -13.0,\n\t\t},\n\t\tEvaluationTest{\n\t\t\tName:     \"Order of non-commutative same-precedence operators (multiplicative)\",\n\t\t\tInput:    \"1 * 4 / 2 * 8\",\n\t\t\tExpected: 16.0,\n\t\t},\n\t\tEvaluationTest{\n\t\t\tName:     \"Null coalesce precedence\",\n\t\t\tInput:    \"true ?? true ? 100 + 200 : 400\",\n\t\t\tExpected: 300.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Identical date equivalence\",\n\t\t\tInput:    \"'2014-01-02 14:12:22' == '2014-01-02 14:12:22'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Positive date GT\",\n\t\t\tInput:    \"'2014-01-02 14:12:22' > '2014-01-02 12:12:22'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Negative date GT\",\n\t\t\tInput:    \"'2014-01-02 14:12:22' > '2014-01-02 16:12:22'\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Positive date GTE\",\n\t\t\tInput:    \"'2014-01-02 14:12:22' >= '2014-01-02 12:12:22'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Negative date GTE\",\n\t\t\tInput:    \"'2014-01-02 14:12:22' >= '2014-01-02 16:12:22'\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Positive date LT\",\n\t\t\tInput:    \"'2014-01-02 14:12:22' < '2014-01-02 16:12:22'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Negative date LT\",\n\t\t\tInput:    \"'2014-01-02 14:12:22' < '2014-01-02 11:12:22'\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Positive date LTE\",\n\t\t\tInput:    \"'2014-01-02 09:12:22' <= '2014-01-02 12:12:22'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Negative date LTE\",\n\t\t\tInput:    \"'2014-01-02 14:12:22' <= '2014-01-02 11:12:22'\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Sign prefix comparison\",\n\t\t\tInput:    \"-1 < 0\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Lexicographic LT\",\n\t\t\tInput:    \"'ab' < 'abc'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Lexicographic LTE\",\n\t\t\tInput:    \"'ab' <= 'abc'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Lexicographic GT\",\n\t\t\tInput:    \"'aba' > 'abc'\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Lexicographic GTE\",\n\t\t\tInput:    \"'aba' >= 'abc'\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Boolean sign prefix comparison\",\n\t\t\tInput:    \"!true == false\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Inversion of clause\",\n\t\t\tInput:    \"!(10 < 0)\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Negation after modifier\",\n\t\t\tInput:    \"10 * -10\",\n\t\t\tExpected: -100.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary with single boolean\",\n\t\t\tInput:    \"true ? 10\",\n\t\t\tExpected: 10.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary nil with single boolean\",\n\t\t\tInput:    \"false ? 10\",\n\t\t\tExpected: nil,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary with comparator boolean\",\n\t\t\tInput:    \"10 > 5 ? 35.50\",\n\t\t\tExpected: 35.50,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary nil with comparator boolean\",\n\t\t\tInput:    \"1 > 5 ? 35.50\",\n\t\t\tExpected: nil,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary with parentheses\",\n\t\t\tInput:    \"(5 * (15 - 5)) > 5 ? 35.50\",\n\t\t\tExpected: 35.50,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary precedence\",\n\t\t\tInput:    \"true ? 35.50 > 10\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary-else\",\n\t\t\tInput:    \"false ? 35.50 : 50\",\n\t\t\tExpected: 50.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary-else inside clause\",\n\t\t\tInput:    \"(false ? 5 : 35.50) > 10\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary-else (true-case) inside clause\",\n\t\t\tInput:    \"(true ? 1 : 5) < 10\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Ternary-else before comparator (negative case)\",\n\t\t\tInput:    \"true ? 1 : 5 > 10\",\n\t\t\tExpected: 1.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Nested ternaries (#32)\",\n\t\t\tInput:    \"(2 == 2) ? 1 : (true ? 2 : 3)\",\n\t\t\tExpected: 1.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Nested ternaries, right case (#32)\",\n\t\t\tInput:    \"false ? 1 : (true ? 2 : 3)\",\n\t\t\tExpected: 2.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Doubly-nested ternaries (#32)\",\n\t\t\tInput:    \"true ? (false ? 1 : (false ? 2 : 3)) : (false ? 4 : 5)\",\n\t\t\tExpected: 3.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"String to string concat\",\n\t\t\tInput:    \"'foo' + 'bar' == 'foobar'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"String to float64 concat\",\n\t\t\tInput:    \"'foo' + 123 == 'foo123'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Float64 to string concat\",\n\t\t\tInput:    \"123 + 'bar' == '123bar'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"String to date concat\",\n\t\t\tInput:    \"'foo' + '02/05/1970' == 'foobar'\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"String to bool concat\",\n\t\t\tInput:    \"'foo' + true == 'footrue'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Bool to string concat\",\n\t\t\tInput:    \"true + 'bar' == 'truebar'\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Null coalesce left\",\n\t\t\tInput:    \"1 ?? 2\",\n\t\t\tExpected: 1.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Array membership literals\",\n\t\t\tInput:    \"1 in (1, 2, 3)\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Array membership literal with inversion\",\n\t\t\tInput:    \"!(1 in (1, 2, 3))\",\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Logical operator reordering (#30)\",\n\t\t\tInput:    \"(true && true) || (true && false)\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Logical operator reordering without parens (#30)\",\n\t\t\tInput:    \"true && true || true && false\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Logical operator reordering with multiple OR (#30)\",\n\t\t\tInput:    \"false || true && true || false\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Left-side multiple consecutive (should be reordered) operators\",\n\t\t\tInput:    \"(10 * 10 * 10) > 10\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Three-part non-paren logical op reordering (#44)\",\n\t\t\tInput:    \"false && true || true\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Three-part non-paren logical op reordering (#44), second one\",\n\t\t\tInput:    \"true || false && true\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Logical operator reordering without parens (#45)\",\n\t\t\tInput:    \"true && true || false && false\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Single function\",\n\t\t\tInput: \"foo()\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"foo\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn true, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Function with argument\",\n\t\t\tInput: \"passthrough(1)\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"passthrough\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn arguments[0], nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: 1.0,\n\t\t},\n\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Function with arguments\",\n\t\t\tInput: \"passthrough(1, 2)\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"passthrough\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn arguments[0].(float64) + arguments[1].(float64), nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: 3.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Nested function with precedence\",\n\t\t\tInput: \"sum(1, sum(2, 3), 2 + 2, true ? 4 : 5)\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"sum\": func(arguments ...interface{}) (interface{}, error) {\n\n\t\t\t\t\tsum := 0.0\n\t\t\t\t\tfor _, v := range arguments {\n\t\t\t\t\t\tsum += v.(float64)\n\t\t\t\t\t}\n\t\t\t\t\treturn sum, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: 14.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Empty function and modifier, compared\",\n\t\t\tInput: \"numeric()-1 > 0\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"numeric\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn 2.0, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Empty function comparator\",\n\t\t\tInput: \"numeric() > 0\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"numeric\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn 2.0, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Empty function logical operator\",\n\t\t\tInput: \"success() && !false\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"success\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn true, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Empty function ternary\",\n\t\t\tInput: \"nope() ? 1 : 2.0\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"nope\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn false, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: 2.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Empty function null coalesce\",\n\t\t\tInput: \"null() ?? 2\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"null\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: 2.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Empty function with prefix\",\n\t\t\tInput: \"-ten()\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"ten\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn 10.0, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: -10.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Empty function as part of chain\",\n\t\t\tInput: \"10 - numeric() - 2\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"numeric\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn 5.0, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: 3.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Empty function near separator\",\n\t\t\tInput: \"10 in (1, 2, 3, ten(), 8)\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"ten\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn 10.0, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Enclosed empty function with modifier and comparator (#28)\",\n\t\t\tInput: \"(ten() - 1) > 3\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"ten\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn 10.0, nil\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\t\t\t\n\t\t\tName:  \"Ternary/Java EL ambiguity\",\n\t\t\tInput: \"false ? foo:length()\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"length\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn 1.0, nil\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 1.0,\n\t\t},\n\t}\n\n\trunEvaluationTests(evaluationTests, test)\n}\n\nfunc TestParameterizedEvaluation(test *testing.T) {\n\n\tevaluationTests := []EvaluationTest{\n\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Single parameter modified by constant\",\n\t\t\tInput: \"foo + 2\",\n\t\t\tParameters: []EvaluationParameter{\n\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 4.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Single parameter modified by variable\",\n\t\t\tInput: \"foo * bar\",\n\t\t\tParameters: []EvaluationParameter{\n\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 5.0,\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 10.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Multiple multiplications of the same parameter\",\n\t\t\tInput: \"foo * foo * foo\",\n\t\t\tParameters: []EvaluationParameter{\n\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 10.0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 1000.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Multiple additions of the same parameter\",\n\t\t\tInput: \"foo + foo + foo\",\n\t\t\tParameters: []EvaluationParameter{\n\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 10.0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 30.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Parameter name sensitivity\",\n\t\t\tInput: \"foo + FoO + FOO\",\n\t\t\tParameters: []EvaluationParameter{\n\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 8.0,\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"FoO\",\n\t\t\t\t\tValue: 4.0,\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"FOO\",\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 14.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Sign prefix comparison against prefixed variable\",\n\t\t\tInput: \"-1 < -foo\",\n\t\t\tParameters: []EvaluationParameter{\n\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: -8.0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Fixed-point parameter\",\n\t\t\tInput: \"foo > 1\",\n\t\t\tParameters: []EvaluationParameter{\n\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 2,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Modifier after closing clause\",\n\t\t\tInput:    \"(2 + 2) + 2 == 6\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:     \"Comparator after closing clause\",\n\t\t\tInput:    \"(2 + 2) >= 4\",\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Two-boolean logical operation (for issue #8)\",\n\t\t\tInput: \"(foo == true) || (bar == true)\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\tValue: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Two-variable integer logical operation (for issue #8)\",\n\t\t\tInput: \"foo > 10 && bar > 10\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 1,\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\tValue: 11,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Regex against right-hand parameter\",\n\t\t\tInput: \"'foobar' =~ foo\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"obar\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Not-regex against right-hand parameter\",\n\t\t\tInput: \"'foobar' !~ foo\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Regex against two parameters\",\n\t\t\tInput: \"foo =~ bar\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"foobar\",\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\tValue: \"oba\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Not-regex against two parameters\",\n\t\t\tInput: \"foo !~ bar\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"foobar\",\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\tValue: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Pre-compiled regex\",\n\t\t\tInput: \"foo =~ bar\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"foobar\",\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\tValue: regexp.MustCompile(\"[fF][oO]+\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Pre-compiled not-regex\",\n\t\t\tInput: \"foo !~ bar\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"foobar\",\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\tValue: regexp.MustCompile(\"[fF][oO]+\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Single boolean parameter\",\n\t\t\tInput: \"commission ? 10\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"commission\",\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 10.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"True comparator with a parameter\",\n\t\t\tInput: \"partner == 'amazon' ? 10\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"partner\",\n\t\t\t\t\tValue: \"amazon\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 10.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"False comparator with a parameter\",\n\t\t\tInput: \"partner == 'amazon' ? 10\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"partner\",\n\t\t\t\t\tValue: \"ebay\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: nil,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"True comparator with multiple parameters\",\n\t\t\tInput: \"theft && period == 24 ? 60\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"theft\",\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"period\",\n\t\t\t\t\tValue: 24,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 60.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"False comparator with multiple parameters\",\n\t\t\tInput: \"theft && period == 24 ? 60\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"theft\",\n\t\t\t\t\tValue: false,\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"period\",\n\t\t\t\t\tValue: 24,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: nil,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"String concat with single string parameter\",\n\t\t\tInput: \"foo + 'bar'\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: \"bazbar\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"String concat with multiple string parameter\",\n\t\t\tInput: \"foo + bar\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"baz\",\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\tValue: \"quux\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: \"bazquux\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"String concat with float parameter\",\n\t\t\tInput: \"foo + bar\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"baz\",\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\tValue: 123.0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: \"baz123\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Mixed multiple string concat\",\n\t\t\tInput: \"foo + 123 + 'bar' + true\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: \"baz123bartrue\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Integer width spectrum\",\n\t\t\tInput: \"uint8 + uint16 + uint32 + uint64 + int8 + int16 + int32 + int64\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"uint8\",\n\t\t\t\t\tValue: uint8(0),\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"uint16\",\n\t\t\t\t\tValue: uint16(0),\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"uint32\",\n\t\t\t\t\tValue: uint32(0),\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"uint64\",\n\t\t\t\t\tValue: uint64(0),\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"int8\",\n\t\t\t\t\tValue: int8(0),\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"int16\",\n\t\t\t\t\tValue: int16(0),\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"int32\",\n\t\t\t\t\tValue: int32(0),\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"int64\",\n\t\t\t\t\tValue: int64(0),\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 0.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Floats\",\n\t\t\tInput: \"float32 + float64\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"float32\",\n\t\t\t\t\tValue: float32(0.0),\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"float64\",\n\t\t\t\t\tValue: float64(0.0),\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 0.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Null coalesce right\",\n\t\t\tInput: \"foo ?? 1.0\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 1.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Multiple comparator/logical operators (#30)\",\n\t\t\tInput: \"(foo >= 2887057408 && foo <= 2887122943) || (foo >= 168100864 && foo <= 168118271)\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 2887057409,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Multiple comparator/logical operators, opposite order (#30)\",\n\t\t\tInput: \"(foo >= 168100864 && foo <= 168118271) || (foo >= 2887057408 && foo <= 2887122943)\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 2887057409,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Multiple comparator/logical operators, small value (#30)\",\n\t\t\tInput: \"(foo >= 2887057408 && foo <= 2887122943) || (foo >= 168100864 && foo <= 168118271)\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 168100865,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Multiple comparator/logical operators, small value, opposite order (#30)\",\n\t\t\tInput: \"(foo >= 168100864 && foo <= 168118271) || (foo >= 2887057408 && foo <= 2887122943)\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\tValue: 168100865,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Incomparable array equality comparison\",\n\t\t\tInput: \"arr == arr\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"arr\",\n\t\t\t\t\tValue: []int{0, 0, 0},\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Incomparable array not-equality comparison\",\n\t\t\tInput: \"arr != arr\",\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"arr\",\n\t\t\t\t\tValue: []int{0, 0, 0},\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Mixed function and parameters\",\n\t\t\tInput: \"sum(1.2, amount) + name\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"sum\": func(arguments ...interface{}) (interface{}, error) {\n\n\t\t\t\t\tsum := 0.0\n\t\t\t\t\tfor _, v := range arguments {\n\t\t\t\t\t\tsum += v.(float64)\n\t\t\t\t\t}\n\t\t\t\t\treturn sum, nil\n\t\t\t\t},\n\t\t\t},\n\t\t\tParameters: []EvaluationParameter{\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"amount\",\n\t\t\t\t\tValue: .8,\n\t\t\t\t},\n\t\t\t\tEvaluationParameter{\n\t\t\t\t\tName:  \"name\",\n\t\t\t\t\tValue: \"awesome\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tExpected: \"2awesome\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Short-circuit OR\",\n\t\t\tInput: \"true || fail()\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"fail\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn nil, errors.New(\"Did not short-circuit\")\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: true,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Short-circuit AND\",\n\t\t\tInput: \"false && fail()\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"fail\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn nil, errors.New(\"Did not short-circuit\")\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Short-circuit ternary\",\n\t\t\tInput: \"true ? 1 : fail()\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"fail\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn nil, errors.New(\"Did not short-circuit\")\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: 1.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:  \"Short-circuit coalesce\",\n\t\t\tInput: \"'foo' ?? fail()\",\n\t\t\tFunctions: map[string]ExpressionFunction{\n\t\t\t\t\"fail\": func(arguments ...interface{}) (interface{}, error) {\n\t\t\t\t\treturn nil, errors.New(\"Did not short-circuit\")\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: \"foo\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter call\",\n\t\t\tInput:      \"foo.String\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   fooParameter.Value.(dummyParameter).String,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter function call\",\n\t\t\tInput:      \"foo.Func()\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   \"funk\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter call from pointer\",\n\t\t\tInput:      \"fooptr.String\",\n\t\t\tParameters: []EvaluationParameter{fooPtrParameter},\n\t\t\tExpected:   fooParameter.Value.(dummyParameter).String,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter function call from pointer\",\n\t\t\tInput:      \"fooptr.Func()\",\n\t\t\tParameters: []EvaluationParameter{fooPtrParameter},\n\t\t\tExpected:   \"funk\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter function call from pointer\",\n\t\t\tInput:      \"fooptr.Func3()\",\n\t\t\tParameters: []EvaluationParameter{fooPtrParameter},\n\t\t\tExpected:   \"fronk\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter call\",\n\t\t\tInput:      \"foo.String == 'hi'\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter call with modifier\",\n\t\t\tInput:      \"foo.String + 'hi'\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   fooParameter.Value.(dummyParameter).String + \"hi\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter function call, two-arg return\",\n\t\t\tInput:      \"foo.Func2()\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   \"frink\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Parameter function call with all argument types\",\n\t\t\tInput:      \"foo.TestArgs(\\\"hello\\\", 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1.0, 2.0, true)\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   \"hello: 33\",\n\t\t},\n\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter function call, one arg\",\n\t\t\tInput:      \"foo.FuncArgStr('boop')\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   \"boop\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Simple parameter function call, one arg\",\n\t\t\tInput:      \"foo.FuncArgStr('boop') + 'hi'\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   \"boophi\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Nested parameter function call\",\n\t\t\tInput:      \"foo.Nested.Dunk('boop')\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   \"boopdunk\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Nested parameter call\",\n\t\t\tInput:      \"foo.Nested.Funk\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   \"funkalicious\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Parameter call with + modifier\",\n\t\t\tInput:      \"1 + foo.Int\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   102.0,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Parameter string call with + modifier\",\n\t\t\tInput:      \"'woop' + (foo.String)\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   \"woopstring!\",\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Parameter call with && operator\",\n\t\t\tInput:      \"true && foo.BoolFalse\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   false,\n\t\t},\n\t\tEvaluationTest{\n\n\t\t\tName:       \"Null coalesce nested parameter\",\n\t\t\tInput:      \"foo.Nil ?? false\",\n\t\t\tParameters: []EvaluationParameter{fooParameter},\n\t\t\tExpected:   false,\n\t\t},\n\t}\n\n\trunEvaluationTests(evaluationTests, test)\n}\n\n/*\n\tTests the behavior of a nil set of parameters.\n*/\nfunc TestNilParameters(test *testing.T) {\n\n\texpression, _ := NewEvaluableExpression(\"true\")\n\t_, err := expression.Evaluate(nil)\n\n\tif err != nil {\n\t\ttest.Fail()\n\t}\n}\n\n/*\n\tTests functionality related to using functions with a struct method receiver.\n\tCreated to test #54.\n*/\nfunc TestStructFunctions(test *testing.T) {\n\n\tparseFormat := \"2006\"\n\ty2k, _ := time.Parse(parseFormat, \"2000\")\n\ty2k1, _ := time.Parse(parseFormat, \"2001\")\n\n\tfunctions := map[string]ExpressionFunction{\n\t\t\"func1\": func(args ...interface{}) (interface{}, error) {\n\t\t\treturn float64(y2k.Year()), nil\n\t\t},\n\t\t\"func2\": func(args ...interface{}) (interface{}, error) {\n\t\t\treturn float64(y2k1.Year()), nil\n\t\t},\n\t}\n\n\texp, _ := NewEvaluableExpressionWithFunctions(\"func1() + func2()\", functions)\n\tresult, _ := exp.Evaluate(nil)\n\n\tif result != 4001.0 {\n\t\ttest.Logf(\"Function calling method did not return the right value. Got: %v, expected %d\\n\", result, 4001)\n\t\ttest.Fail()\n\t}\n}\n\nfunc runEvaluationTests(evaluationTests []EvaluationTest, test *testing.T) {\n\n\tvar expression *EvaluableExpression\n\tvar result interface{}\n\tvar parameters map[string]interface{}\n\tvar err error\n\n\tfmt.Printf(\"Running %d evaluation test cases...\\n\", len(evaluationTests))\n\n\t// Run the test cases.\n\tfor _, evaluationTest := range evaluationTests {\n\n\t\tif evaluationTest.Functions != nil {\n\t\t\texpression, err = NewEvaluableExpressionWithFunctions(evaluationTest.Input, evaluationTest.Functions)\n\t\t} else {\n\t\t\texpression, err = NewEvaluableExpression(evaluationTest.Input)\n\t\t}\n\n\t\tif err != nil {\n\n\t\t\ttest.Logf(\"Test '%s' failed to parse: '%s'\", evaluationTest.Name, err)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\n\t\tparameters = make(map[string]interface{}, 8)\n\n\t\tfor _, parameter := range evaluationTest.Parameters {\n\t\t\tparameters[parameter.Name] = parameter.Value\n\t\t}\n\n\t\tresult, err = expression.Evaluate(parameters)\n\n\t\tif err != nil {\n\n\t\t\ttest.Logf(\"Test '%s' failed\", evaluationTest.Name)\n\t\t\ttest.Logf(\"Encountered error: %s\", err.Error())\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\n\t\tif result != evaluationTest.Expected {\n\n\t\t\ttest.Logf(\"Test '%s' failed\", evaluationTest.Name)\n\t\t\ttest.Logf(\"Evaluation result '%v' does not match expected: '%v'\", result, evaluationTest.Expected)\n\t\t\ttest.Fail()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "expressionFunctions.go",
          "type": "blob",
          "size": 0.330078125,
          "content": "package govaluate\n\n/*\n\tRepresents a function that can be called from within an expression.\n\tThis method must return an error if, for any reason, it is unable to produce exactly one unambiguous result.\n\tAn error returned will halt execution of the expression.\n*/\ntype ExpressionFunction func(arguments ...interface{}) (interface{}, error)\n"
        },
        {
          "name": "expressionOutputStream.go",
          "type": "blob",
          "size": 1.158203125,
          "content": "package govaluate\n\nimport (\n\t\"bytes\"\n)\n\n/*\n\tHolds a series of \"transactions\" which represent each token as it is output by an outputter (such as ToSQLQuery()).\n\tSome outputs (such as SQL) require a function call or non-c-like syntax to represent an expression.\n\tTo accomplish this, this struct keeps track of each translated token as it is output, and can return and rollback those transactions.\n*/\ntype expressionOutputStream struct {\n\ttransactions []string\n}\n\nfunc (this *expressionOutputStream) add(transaction string) {\n\tthis.transactions = append(this.transactions, transaction)\n}\n\nfunc (this *expressionOutputStream) rollback() string {\n\n\tindex := len(this.transactions) - 1\n\tret := this.transactions[index]\n\n\tthis.transactions = this.transactions[:index]\n\treturn ret\n}\n\nfunc (this *expressionOutputStream) createString(delimiter string) string {\n\n\tvar retBuffer bytes.Buffer\n\tvar transaction string\n\n\tpenultimate := len(this.transactions) - 1\n\n\tfor i := 0; i < penultimate; i++ {\n\n\t\ttransaction = this.transactions[i]\n\n\t\tretBuffer.WriteString(transaction)\n\t\tretBuffer.WriteString(delimiter)\n\t}\n\tretBuffer.WriteString(this.transactions[penultimate])\n\n\treturn retBuffer.String()\n}\n"
        },
        {
          "name": "lexerState.go",
          "type": "blob",
          "size": 5.478515625,
          "content": "package govaluate\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype lexerState struct {\n\tisEOF          bool\n\tisNullable     bool\n\tkind           TokenKind\n\tvalidNextKinds []TokenKind\n}\n\n// lexer states.\n// Constant for all purposes except compiler.\nvar validLexerStates = []lexerState{\n\n\tlexerState{\n\t\tkind:       UNKNOWN,\n\t\tisEOF:      false,\n\t\tisNullable: true,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tPREFIX,\n\t\t\tNUMERIC,\n\t\t\tBOOLEAN,\n\t\t\tVARIABLE,\n\t\t\tPATTERN,\n\t\t\tFUNCTION,\n\t\t\tACCESSOR,\n\t\t\tSTRING,\n\t\t\tTIME,\n\t\t\tCLAUSE,\n\t\t},\n\t},\n\n\tlexerState{\n\n\t\tkind:       CLAUSE,\n\t\tisEOF:      false,\n\t\tisNullable: true,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tPREFIX,\n\t\t\tNUMERIC,\n\t\t\tBOOLEAN,\n\t\t\tVARIABLE,\n\t\t\tPATTERN,\n\t\t\tFUNCTION,\n\t\t\tACCESSOR,\n\t\t\tSTRING,\n\t\t\tTIME,\n\t\t\tCLAUSE,\n\t\t\tCLAUSE_CLOSE,\n\t\t},\n\t},\n\n\tlexerState{\n\n\t\tkind:       CLAUSE_CLOSE,\n\t\tisEOF:      true,\n\t\tisNullable: true,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tCOMPARATOR,\n\t\t\tMODIFIER,\n\t\t\tNUMERIC,\n\t\t\tBOOLEAN,\n\t\t\tVARIABLE,\n\t\t\tSTRING,\n\t\t\tPATTERN,\n\t\t\tTIME,\n\t\t\tCLAUSE,\n\t\t\tCLAUSE_CLOSE,\n\t\t\tLOGICALOP,\n\t\t\tTERNARY,\n\t\t\tSEPARATOR,\n\t\t},\n\t},\n\n\tlexerState{\n\n\t\tkind:       NUMERIC,\n\t\tisEOF:      true,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tMODIFIER,\n\t\t\tCOMPARATOR,\n\t\t\tLOGICALOP,\n\t\t\tCLAUSE_CLOSE,\n\t\t\tTERNARY,\n\t\t\tSEPARATOR,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       BOOLEAN,\n\t\tisEOF:      true,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tMODIFIER,\n\t\t\tCOMPARATOR,\n\t\t\tLOGICALOP,\n\t\t\tCLAUSE_CLOSE,\n\t\t\tTERNARY,\n\t\t\tSEPARATOR,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       STRING,\n\t\tisEOF:      true,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tMODIFIER,\n\t\t\tCOMPARATOR,\n\t\t\tLOGICALOP,\n\t\t\tCLAUSE_CLOSE,\n\t\t\tTERNARY,\n\t\t\tSEPARATOR,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       TIME,\n\t\tisEOF:      true,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tMODIFIER,\n\t\t\tCOMPARATOR,\n\t\t\tLOGICALOP,\n\t\t\tCLAUSE_CLOSE,\n\t\t\tSEPARATOR,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       PATTERN,\n\t\tisEOF:      true,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tMODIFIER,\n\t\t\tCOMPARATOR,\n\t\t\tLOGICALOP,\n\t\t\tCLAUSE_CLOSE,\n\t\t\tSEPARATOR,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       VARIABLE,\n\t\tisEOF:      true,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tMODIFIER,\n\t\t\tCOMPARATOR,\n\t\t\tLOGICALOP,\n\t\t\tCLAUSE_CLOSE,\n\t\t\tTERNARY,\n\t\t\tSEPARATOR,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       MODIFIER,\n\t\tisEOF:      false,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tPREFIX,\n\t\t\tNUMERIC,\n\t\t\tVARIABLE,\n\t\t\tFUNCTION,\n\t\t\tACCESSOR,\n\t\t\tSTRING,\n\t\t\tBOOLEAN,\n\t\t\tCLAUSE,\n\t\t\tCLAUSE_CLOSE,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       COMPARATOR,\n\t\tisEOF:      false,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tPREFIX,\n\t\t\tNUMERIC,\n\t\t\tBOOLEAN,\n\t\t\tVARIABLE,\n\t\t\tFUNCTION,\n\t\t\tACCESSOR,\n\t\t\tSTRING,\n\t\t\tTIME,\n\t\t\tCLAUSE,\n\t\t\tCLAUSE_CLOSE,\n\t\t\tPATTERN,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       LOGICALOP,\n\t\tisEOF:      false,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tPREFIX,\n\t\t\tNUMERIC,\n\t\t\tBOOLEAN,\n\t\t\tVARIABLE,\n\t\t\tFUNCTION,\n\t\t\tACCESSOR,\n\t\t\tSTRING,\n\t\t\tTIME,\n\t\t\tCLAUSE,\n\t\t\tCLAUSE_CLOSE,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       PREFIX,\n\t\tisEOF:      false,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tNUMERIC,\n\t\t\tBOOLEAN,\n\t\t\tVARIABLE,\n\t\t\tFUNCTION,\n\t\t\tACCESSOR,\n\t\t\tCLAUSE,\n\t\t\tCLAUSE_CLOSE,\n\t\t},\n\t},\n\n\tlexerState{\n\n\t\tkind:       TERNARY,\n\t\tisEOF:      false,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tPREFIX,\n\t\t\tNUMERIC,\n\t\t\tBOOLEAN,\n\t\t\tSTRING,\n\t\t\tTIME,\n\t\t\tVARIABLE,\n\t\t\tFUNCTION,\n\t\t\tACCESSOR,\n\t\t\tCLAUSE,\n\t\t\tSEPARATOR,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       FUNCTION,\n\t\tisEOF:      false,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\t\t\tCLAUSE,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       ACCESSOR,\n\t\tisEOF:      true,\n\t\tisNullable: false,\n\t\tvalidNextKinds: []TokenKind{\n\t\t\tCLAUSE,\n\t\t\tMODIFIER,\n\t\t\tCOMPARATOR,\n\t\t\tLOGICALOP,\n\t\t\tCLAUSE_CLOSE,\n\t\t\tTERNARY,\n\t\t\tSEPARATOR,\n\t\t},\n\t},\n\tlexerState{\n\n\t\tkind:       SEPARATOR,\n\t\tisEOF:      false,\n\t\tisNullable: true,\n\t\tvalidNextKinds: []TokenKind{\n\n\t\t\tPREFIX,\n\t\t\tNUMERIC,\n\t\t\tBOOLEAN,\n\t\t\tSTRING,\n\t\t\tTIME,\n\t\t\tVARIABLE,\n\t\t\tFUNCTION,\n\t\t\tACCESSOR,\n\t\t\tCLAUSE,\n\t\t},\n\t},\n}\n\nfunc (this lexerState) canTransitionTo(kind TokenKind) bool {\n\n\tfor _, validKind := range this.validNextKinds {\n\n\t\tif validKind == kind {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc checkExpressionSyntax(tokens []ExpressionToken) error {\n\n\tvar state lexerState\n\tvar lastToken ExpressionToken\n\tvar err error\n\n\tstate = validLexerStates[0]\n\n\tfor _, token := range tokens {\n\n\t\tif !state.canTransitionTo(token.Kind) {\n\n\t\t\t// call out a specific error for tokens looking like they want to be functions.\n\t\t\tif lastToken.Kind == VARIABLE && token.Kind == CLAUSE {\n\t\t\t\treturn errors.New(\"Undefined function \" + lastToken.Value.(string))\n\t\t\t}\n\n\t\t\tfirstStateName := fmt.Sprintf(\"%s [%v]\", state.kind.String(), lastToken.Value)\n\t\t\tnextStateName := fmt.Sprintf(\"%s [%v]\", token.Kind.String(), token.Value)\n\n\t\t\treturn errors.New(\"Cannot transition token types from \" + firstStateName + \" to \" + nextStateName)\n\t\t}\n\n\t\tstate, err = getLexerStateForToken(token.Kind)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !state.isNullable && token.Value == nil {\n\n\t\t\terrorMsg := fmt.Sprintf(\"Token kind '%v' cannot have a nil value\", token.Kind.String())\n\t\t\treturn errors.New(errorMsg)\n\t\t}\n\n\t\tlastToken = token\n\t}\n\n\tif !state.isEOF {\n\t\treturn errors.New(\"Unexpected end of expression\")\n\t}\n\treturn nil\n}\n\nfunc getLexerStateForToken(kind TokenKind) (lexerState, error) {\n\n\tfor _, possibleState := range validLexerStates {\n\n\t\tif possibleState.kind == kind {\n\t\t\treturn possibleState, nil\n\t\t}\n\t}\n\n\terrorMsg := fmt.Sprintf(\"No lexer state found for token kind '%v'\\n\", kind.String())\n\treturn validLexerStates[0], errors.New(errorMsg)\n}\n"
        },
        {
          "name": "lexerStream.go",
          "type": "blob",
          "size": 0.6328125,
          "content": "package govaluate\n\ntype lexerStream struct {\n\tsource   []rune\n\tposition int\n\tlength   int\n}\n\nfunc newLexerStream(source string) *lexerStream {\n\n\tvar ret *lexerStream\n\tvar runes []rune\n\n\tfor _, character := range source {\n\t\trunes = append(runes, character)\n\t}\n\n\tret = new(lexerStream)\n\tret.source = runes\n\tret.length = len(runes)\n\treturn ret\n}\n\nfunc (this *lexerStream) readCharacter() rune {\n\n\tvar character rune\n\n\tcharacter = this.source[this.position]\n\tthis.position += 1\n\treturn character\n}\n\nfunc (this *lexerStream) rewind(amount int) {\n\tthis.position -= amount\n}\n\nfunc (this lexerStream) canRead() bool {\n\treturn this.position < this.length\n}\n"
        },
        {
          "name": "parameters.go",
          "type": "blob",
          "size": 0.697265625,
          "content": "package govaluate\n\nimport (\n\t\"errors\"\n)\n\n/*\n\tParameters is a collection of named parameters that can be used by an EvaluableExpression to retrieve parameters\n\twhen an expression tries to use them.\n*/\ntype Parameters interface {\n\n\t/*\n\t\tGet gets the parameter of the given name, or an error if the parameter is unavailable.\n\t\tFailure to find the given parameter should be indicated by returning an error.\n\t*/\n\tGet(name string) (interface{}, error)\n}\n\ntype MapParameters map[string]interface{}\n\nfunc (p MapParameters) Get(name string) (interface{}, error) {\n\n\tvalue, found := p[name]\n\n\tif !found {\n\t\terrorMessage := \"No parameter '\" + name + \"' found.\"\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn value, nil\n}\n"
        },
        {
          "name": "parsing.go",
          "type": "blob",
          "size": 11.0283203125,
          "content": "package govaluate\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n)\n\nfunc parseTokens(expression string, functions map[string]ExpressionFunction) ([]ExpressionToken, error) {\n\n\tvar ret []ExpressionToken\n\tvar token ExpressionToken\n\tvar stream *lexerStream\n\tvar state lexerState\n\tvar err error\n\tvar found bool\n\n\tstream = newLexerStream(expression)\n\tstate = validLexerStates[0]\n\n\tfor stream.canRead() {\n\n\t\ttoken, err, found = readToken(stream, state, functions)\n\n\t\tif err != nil {\n\t\t\treturn ret, err\n\t\t}\n\n\t\tif !found {\n\t\t\tbreak\n\t\t}\n\n\t\tstate, err = getLexerStateForToken(token.Kind)\n\t\tif err != nil {\n\t\t\treturn ret, err\n\t\t}\n\n\t\t// append this valid token\n\t\tret = append(ret, token)\n\t}\n\n\terr = checkBalance(ret)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ret, nil\n}\n\nfunc readToken(stream *lexerStream, state lexerState, functions map[string]ExpressionFunction) (ExpressionToken, error, bool) {\n\n\tvar function ExpressionFunction\n\tvar ret ExpressionToken\n\tvar tokenValue interface{}\n\tvar tokenTime time.Time\n\tvar tokenString string\n\tvar kind TokenKind\n\tvar character rune\n\tvar found bool\n\tvar completed bool\n\tvar err error\n\n\t// numeric is 0-9, or . or 0x followed by digits\n\t// string starts with '\n\t// variable is alphanumeric, always starts with a letter\n\t// bracket always means variable\n\t// symbols are anything non-alphanumeric\n\t// all others read into a buffer until they reach the end of the stream\n\tfor stream.canRead() {\n\n\t\tcharacter = stream.readCharacter()\n\n\t\tif unicode.IsSpace(character) {\n\t\t\tcontinue\n\t\t}\n\n\t\tkind = UNKNOWN\n\n\t\t// numeric constant\n\t\tif isNumeric(character) {\n\n\t\t\tif stream.canRead() && character == '0' {\n\t\t\t\tcharacter = stream.readCharacter()\n\n\t\t\t\tif stream.canRead() && character == 'x' {\n\t\t\t\t\ttokenString, _ = readUntilFalse(stream, false, true, true, isHexDigit)\n\t\t\t\t\ttokenValueInt, err := strconv.ParseUint(tokenString, 16, 64)\n\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\terrorMsg := fmt.Sprintf(\"Unable to parse hex value '%v' to uint64\\n\", tokenString)\n\t\t\t\t\t\treturn ExpressionToken{}, errors.New(errorMsg), false\n\t\t\t\t\t}\n\n\t\t\t\t\tkind = NUMERIC\n\t\t\t\t\ttokenValue = float64(tokenValueInt)\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tstream.rewind(1)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttokenString = readTokenUntilFalse(stream, isNumeric)\n\t\t\ttokenValue, err = strconv.ParseFloat(tokenString, 64)\n\n\t\t\tif err != nil {\n\t\t\t\terrorMsg := fmt.Sprintf(\"Unable to parse numeric value '%v' to float64\\n\", tokenString)\n\t\t\t\treturn ExpressionToken{}, errors.New(errorMsg), false\n\t\t\t}\n\t\t\tkind = NUMERIC\n\t\t\tbreak\n\t\t}\n\n\t\t// comma, separator\n\t\tif character == ',' {\n\n\t\t\ttokenValue = \",\"\n\t\t\tkind = SEPARATOR\n\t\t\tbreak\n\t\t}\n\n\t\t// escaped variable\n\t\tif character == '[' {\n\n\t\t\ttokenValue, completed = readUntilFalse(stream, true, false, true, isNotClosingBracket)\n\t\t\tkind = VARIABLE\n\n\t\t\tif !completed {\n\t\t\t\treturn ExpressionToken{}, errors.New(\"Unclosed parameter bracket\"), false\n\t\t\t}\n\n\t\t\t// above method normally rewinds us to the closing bracket, which we want to skip.\n\t\t\tstream.rewind(-1)\n\t\t\tbreak\n\t\t}\n\n\t\t// regular variable - or function?\n\t\tif unicode.IsLetter(character) {\n\n\t\t\ttokenString = readTokenUntilFalse(stream, isVariableName)\n\n\t\t\ttokenValue = tokenString\n\t\t\tkind = VARIABLE\n\n\t\t\t// boolean?\n\t\t\tif tokenValue == \"true\" {\n\n\t\t\t\tkind = BOOLEAN\n\t\t\t\ttokenValue = true\n\t\t\t} else {\n\n\t\t\t\tif tokenValue == \"false\" {\n\n\t\t\t\t\tkind = BOOLEAN\n\t\t\t\t\ttokenValue = false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// textual operator?\n\t\t\tif tokenValue == \"in\" || tokenValue == \"IN\" {\n\n\t\t\t\t// force lower case for consistency\n\t\t\t\ttokenValue = \"in\"\n\t\t\t\tkind = COMPARATOR\n\t\t\t}\n\n\t\t\t// function?\n\t\t\tfunction, found = functions[tokenString]\n\t\t\tif found {\n\t\t\t\tkind = FUNCTION\n\t\t\t\ttokenValue = function\n\t\t\t}\n\n\t\t\t// accessor?\n\t\t\taccessorIndex := strings.Index(tokenString, \".\")\n\t\t\tif accessorIndex > 0 {\n\n\t\t\t\t// check that it doesn't end with a hanging period\n\t\t\t\tif tokenString[len(tokenString)-1] == '.' {\n\t\t\t\t\terrorMsg := fmt.Sprintf(\"Hanging accessor on token '%s'\", tokenString)\n\t\t\t\t\treturn ExpressionToken{}, errors.New(errorMsg), false\n\t\t\t\t}\n\n\t\t\t\tkind = ACCESSOR\n\t\t\t\tsplits := strings.Split(tokenString, \".\")\n\t\t\t\ttokenValue = splits\n\n\t\t\t\t// check that none of them are unexported\n\t\t\t\tfor i := 1; i < len(splits); i++ {\n\n\t\t\t\t\tfirstCharacter := getFirstRune(splits[i])\n\n\t\t\t\t\tif unicode.ToUpper(firstCharacter) != firstCharacter {\n\t\t\t\t\t\terrorMsg := fmt.Sprintf(\"Unable to access unexported field '%s' in token '%s'\", splits[i], tokenString)\n\t\t\t\t\t\treturn ExpressionToken{}, errors.New(errorMsg), false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tif !isNotQuote(character) {\n\t\t\ttokenValue, completed = readUntilFalse(stream, true, false, true, isNotQuote)\n\n\t\t\tif !completed {\n\t\t\t\treturn ExpressionToken{}, errors.New(\"Unclosed string literal\"), false\n\t\t\t}\n\n\t\t\t// advance the stream one position, since reading until false assumes the terminator is a real token\n\t\t\tstream.rewind(-1)\n\n\t\t\t// check to see if this can be parsed as a time.\n\t\t\ttokenTime, found = tryParseTime(tokenValue.(string))\n\t\t\tif found {\n\t\t\t\tkind = TIME\n\t\t\t\ttokenValue = tokenTime\n\t\t\t} else {\n\t\t\t\tkind = STRING\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tif character == '(' {\n\t\t\ttokenValue = character\n\t\t\tkind = CLAUSE\n\t\t\tbreak\n\t\t}\n\n\t\tif character == ')' {\n\t\t\ttokenValue = character\n\t\t\tkind = CLAUSE_CLOSE\n\t\t\tbreak\n\t\t}\n\n\t\t// must be a known symbol\n\t\ttokenString = readTokenUntilFalse(stream, isNotAlphanumeric)\n\t\ttokenValue = tokenString\n\n\t\t// quick hack for the case where \"-\" can mean \"prefixed negation\" or \"minus\", which are used\n\t\t// very differently.\n\t\tif state.canTransitionTo(PREFIX) {\n\t\t\t_, found = prefixSymbols[tokenString]\n\t\t\tif found {\n\n\t\t\t\tkind = PREFIX\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t_, found = modifierSymbols[tokenString]\n\t\tif found {\n\n\t\t\tkind = MODIFIER\n\t\t\tbreak\n\t\t}\n\n\t\t_, found = logicalSymbols[tokenString]\n\t\tif found {\n\n\t\t\tkind = LOGICALOP\n\t\t\tbreak\n\t\t}\n\n\t\t_, found = comparatorSymbols[tokenString]\n\t\tif found {\n\n\t\t\tkind = COMPARATOR\n\t\t\tbreak\n\t\t}\n\n\t\t_, found = ternarySymbols[tokenString]\n\t\tif found {\n\n\t\t\tkind = TERNARY\n\t\t\tbreak\n\t\t}\n\n\t\terrorMessage := fmt.Sprintf(\"Invalid token: '%s'\", tokenString)\n\t\treturn ret, errors.New(errorMessage), false\n\t}\n\n\tret.Kind = kind\n\tret.Value = tokenValue\n\n\treturn ret, nil, (kind != UNKNOWN)\n}\n\nfunc readTokenUntilFalse(stream *lexerStream, condition func(rune) bool) string {\n\n\tvar ret string\n\n\tstream.rewind(1)\n\tret, _ = readUntilFalse(stream, false, true, true, condition)\n\treturn ret\n}\n\n/*\n\tReturns the string that was read until the given [condition] was false, or whitespace was broken.\n\tReturns false if the stream ended before whitespace was broken or condition was met.\n*/\nfunc readUntilFalse(stream *lexerStream, includeWhitespace bool, breakWhitespace bool, allowEscaping bool, condition func(rune) bool) (string, bool) {\n\n\tvar tokenBuffer bytes.Buffer\n\tvar character rune\n\tvar conditioned bool\n\n\tconditioned = false\n\n\tfor stream.canRead() {\n\n\t\tcharacter = stream.readCharacter()\n\n\t\t// Use backslashes to escape anything\n\t\tif allowEscaping && character == '\\\\' {\n\n\t\t\tcharacter = stream.readCharacter()\n\t\t\ttokenBuffer.WriteString(string(character))\n\t\t\tcontinue\n\t\t}\n\n\t\tif unicode.IsSpace(character) {\n\n\t\t\tif breakWhitespace && tokenBuffer.Len() > 0 {\n\t\t\t\tconditioned = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif !includeWhitespace {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif condition(character) {\n\t\t\ttokenBuffer.WriteString(string(character))\n\t\t} else {\n\t\t\tconditioned = true\n\t\t\tstream.rewind(1)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn tokenBuffer.String(), conditioned\n}\n\n/*\n\tChecks to see if any optimizations can be performed on the given [tokens], which form a complete, valid expression.\n\tThe returns slice will represent the optimized (or unmodified) list of tokens to use.\n*/\nfunc optimizeTokens(tokens []ExpressionToken) ([]ExpressionToken, error) {\n\n\tvar token ExpressionToken\n\tvar symbol OperatorSymbol\n\tvar err error\n\tvar index int\n\n\tfor index, token = range tokens {\n\n\t\t// if we find a regex operator, and the right-hand value is a constant, precompile and replace with a pattern.\n\t\tif token.Kind != COMPARATOR {\n\t\t\tcontinue\n\t\t}\n\n\t\tsymbol = comparatorSymbols[token.Value.(string)]\n\t\tif symbol != REQ && symbol != NREQ {\n\t\t\tcontinue\n\t\t}\n\n\t\tindex++\n\t\ttoken = tokens[index]\n\t\tif token.Kind == STRING {\n\n\t\t\ttoken.Kind = PATTERN\n\t\t\ttoken.Value, err = regexp.Compile(token.Value.(string))\n\n\t\t\tif err != nil {\n\t\t\t\treturn tokens, err\n\t\t\t}\n\n\t\t\ttokens[index] = token\n\t\t}\n\t}\n\treturn tokens, nil\n}\n\n/*\n\tChecks the balance of tokens which have multiple parts, such as parenthesis.\n*/\nfunc checkBalance(tokens []ExpressionToken) error {\n\n\tvar stream *tokenStream\n\tvar token ExpressionToken\n\tvar parens int\n\n\tstream = newTokenStream(tokens)\n\n\tfor stream.hasNext() {\n\n\t\ttoken = stream.next()\n\t\tif token.Kind == CLAUSE {\n\t\t\tparens++\n\t\t\tcontinue\n\t\t}\n\t\tif token.Kind == CLAUSE_CLOSE {\n\t\t\tparens--\n\t\t\tcontinue\n\t\t}\n\t}\n\n\tif parens != 0 {\n\t\treturn errors.New(\"Unbalanced parenthesis\")\n\t}\n\treturn nil\n}\n\nfunc isDigit(character rune) bool {\n\treturn unicode.IsDigit(character)\n}\n\nfunc isHexDigit(character rune) bool {\n\n\tcharacter = unicode.ToLower(character)\n\n\treturn unicode.IsDigit(character) ||\n\t\tcharacter == 'a' ||\n\t\tcharacter == 'b' ||\n\t\tcharacter == 'c' ||\n\t\tcharacter == 'd' ||\n\t\tcharacter == 'e' ||\n\t\tcharacter == 'f'\n}\n\nfunc isNumeric(character rune) bool {\n\n\treturn unicode.IsDigit(character) || character == '.'\n}\n\nfunc isNotQuote(character rune) bool {\n\n\treturn character != '\\'' && character != '\"'\n}\n\nfunc isNotAlphanumeric(character rune) bool {\n\n\treturn !(unicode.IsDigit(character) ||\n\t\tunicode.IsLetter(character) ||\n\t\tcharacter == '(' ||\n\t\tcharacter == ')' ||\n\t\tcharacter == '[' ||\n\t\tcharacter == ']' || // starting to feel like there needs to be an `isOperation` func (#59)\n\t\t!isNotQuote(character))\n}\n\nfunc isVariableName(character rune) bool {\n\n\treturn unicode.IsLetter(character) ||\n\t\tunicode.IsDigit(character) ||\n\t\tcharacter == '_' ||\n\t\tcharacter == '.'\n}\n\nfunc isNotClosingBracket(character rune) bool {\n\n\treturn character != ']'\n}\n\n/*\n\tAttempts to parse the [candidate] as a Time.\n\tTries a series of standardized date formats, returns the Time if one applies,\n\totherwise returns false through the second return.\n*/\nfunc tryParseTime(candidate string) (time.Time, bool) {\n\n\tvar ret time.Time\n\tvar found bool\n\n\ttimeFormats := [...]string{\n\t\ttime.ANSIC,\n\t\ttime.UnixDate,\n\t\ttime.RubyDate,\n\t\ttime.Kitchen,\n\t\ttime.RFC3339,\n\t\ttime.RFC3339Nano,\n\t\t\"2006-01-02\",                         // RFC 3339\n\t\t\"2006-01-02 15:04\",                   // RFC 3339 with minutes\n\t\t\"2006-01-02 15:04:05\",                // RFC 3339 with seconds\n\t\t\"2006-01-02 15:04:05-07:00\",          // RFC 3339 with seconds and timezone\n\t\t\"2006-01-02T15Z0700\",                 // ISO8601 with hour\n\t\t\"2006-01-02T15:04Z0700\",              // ISO8601 with minutes\n\t\t\"2006-01-02T15:04:05Z0700\",           // ISO8601 with seconds\n\t\t\"2006-01-02T15:04:05.999999999Z0700\", // ISO8601 with nanoseconds\n\t}\n\n\tfor _, format := range timeFormats {\n\n\t\tret, found = tryParseExactTime(candidate, format)\n\t\tif found {\n\t\t\treturn ret, true\n\t\t}\n\t}\n\n\treturn time.Now(), false\n}\n\nfunc tryParseExactTime(candidate string, format string) (time.Time, bool) {\n\n\tvar ret time.Time\n\tvar err error\n\n\tret, err = time.ParseInLocation(format, candidate, time.Local)\n\tif err != nil {\n\t\treturn time.Now(), false\n\t}\n\n\treturn ret, true\n}\n\nfunc getFirstRune(candidate string) rune {\n\n\tfor _, character := range candidate {\n\t\treturn character\n\t}\n\n\treturn 0\n}\n"
        },
        {
          "name": "parsingFailure_test.go",
          "type": "blob",
          "size": 5.494140625,
          "content": "package govaluate\n\nimport (\n\t\"fmt\"\n\t\"regexp/syntax\"\n\t\"strings\"\n\t\"testing\"\n)\n\nconst (\n\tUNEXPECTED_END           string = \"Unexpected end of expression\"\n\tINVALID_TOKEN_TRANSITION        = \"Cannot transition token types\"\n\tINVALID_TOKEN_KIND              = \"Invalid token\"\n\tUNCLOSED_QUOTES                 = \"Unclosed string literal\"\n\tUNCLOSED_BRACKETS               = \"Unclosed parameter bracket\"\n\tUNBALANCED_PARENTHESIS          = \"Unbalanced parenthesis\"\n\tINVALID_NUMERIC                 = \"Unable to parse numeric value\"\n\tUNDEFINED_FUNCTION              = \"Undefined function\"\n\tHANGING_ACCESSOR                = \"Hanging accessor on token\"\n\tUNEXPORTED_ACCESSOR             = \"Unable to access unexported\"\n\tINVALID_HEX                     = \"Unable to parse hex value\"\n)\n\n/*\n\tRepresents a test for parsing failures\n*/\ntype ParsingFailureTest struct {\n\tName     string\n\tInput    string\n\tExpected string\n}\n\nfunc TestParsingFailure(test *testing.T) {\n\n\tparsingTests := []ParsingFailureTest{\n\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Invalid equality comparator\",\n\t\t\tInput:    \"1 = 1\",\n\t\t\tExpected: INVALID_TOKEN_KIND,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Invalid equality comparator\",\n\t\t\tInput:    \"1 === 1\",\n\t\t\tExpected: INVALID_TOKEN_KIND,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Too many characters for logical operator\",\n\t\t\tInput:    \"true &&& false\",\n\t\t\tExpected: INVALID_TOKEN_KIND,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Too many characters for logical operator\",\n\t\t\tInput:    \"true ||| false\",\n\t\t\tExpected: INVALID_TOKEN_KIND,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Premature end to expression, via modifier\",\n\t\t\tInput:    \"10 > 5 +\",\n\t\t\tExpected: UNEXPECTED_END,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Premature end to expression, via comparator\",\n\t\t\tInput:    \"10 + 5 >\",\n\t\t\tExpected: UNEXPECTED_END,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Premature end to expression, via logical operator\",\n\t\t\tInput:    \"10 > 5 &&\",\n\t\t\tExpected: UNEXPECTED_END,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Premature end to expression, via ternary operator\",\n\t\t\tInput:    \"true ?\",\n\t\t\tExpected: UNEXPECTED_END,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Hanging REQ\",\n\t\t\tInput:    \"'wat' =~\",\n\t\t\tExpected: UNEXPECTED_END,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Invalid operator change to REQ\",\n\t\t\tInput:    \" / =~\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Invalid starting token, comparator\",\n\t\t\tInput:    \"> 10\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Invalid starting token, modifier\",\n\t\t\tInput:    \"+ 5\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Invalid starting token, logical operator\",\n\t\t\tInput:    \"&& 5 < 10\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Invalid NUMERIC transition\",\n\t\t\tInput:    \"10 10\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Invalid STRING transition\",\n\t\t\tInput:    \"'foo' 'foo'\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Invalid operator transition\",\n\t\t\tInput:    \"10 > < 10\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Starting with unbalanced parens\",\n\t\t\tInput:    \" ) ( arg2\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Unclosed bracket\",\n\t\t\tInput:    \"[foo bar\",\n\t\t\tExpected: UNCLOSED_BRACKETS,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Unclosed quote\",\n\t\t\tInput:    \"foo == 'responseTime\",\n\t\t\tExpected: UNCLOSED_QUOTES,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Constant regex pattern fail to compile\",\n\t\t\tInput:    \"foo =~ '[abc'\",\n\t\t\tExpected: string(syntax.ErrMissingBracket),\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Unbalanced parenthesis\",\n\t\t\tInput:    \"10 > (1 + 50\",\n\t\t\tExpected: UNBALANCED_PARENTHESIS,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Multiple radix\",\n\t\t\tInput:    \"127.0.0.1\",\n\t\t\tExpected: INVALID_NUMERIC,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Undefined function\",\n\t\t\tInput:    \"foobar()\",\n\t\t\tExpected: UNDEFINED_FUNCTION,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\tName:     \"Hanging accessor\",\n\t\t\tInput:    \"foo.Bar.\",\n\t\t\tExpected: HANGING_ACCESSOR,\n\t\t},\n\t\tParsingFailureTest{\n\n\t\t\t// this is expected to change once there are structtags in place that allow aliasing of fields\n\t\t\tName:     \"Unexported parameter access\",\n\t\t\tInput:    \"foo.bar\",\n\t\t\tExpected: UNEXPORTED_ACCESSOR,\n\t\t},\n\t\tParsingFailureTest{\n\t\t\tName:     \"Incomplete Hex\",\n\t\t\tInput:    \"0x\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\t\t\tName:     \"Invalid Hex literal\",\n\t\t\tInput:    \"0x > 0\",\n\t\t\tExpected: INVALID_HEX,\n\t\t},\n\t\tParsingFailureTest{\n\t\t\tName:     \"Hex float (Unsupported)\",\n\t\t\tInput:    \"0x1.1\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t\tParsingFailureTest{\n\t\t\tName:     \"Hex invalid letter\",\n\t\t\tInput:    \"0x12g1\",\n\t\t\tExpected: INVALID_TOKEN_TRANSITION,\n\t\t},\n\t}\n\n\trunParsingFailureTests(parsingTests, test)\n}\n\nfunc runParsingFailureTests(parsingTests []ParsingFailureTest, test *testing.T) {\n\n\tvar err error\n\n\tfmt.Printf(\"Running %d parsing test cases...\\n\", len(parsingTests))\n\n\tfor _, testCase := range parsingTests {\n\n\t\t_, err = NewEvaluableExpression(testCase.Input)\n\n\t\tif err == nil {\n\n\t\t\ttest.Logf(\"Test '%s' failed\", testCase.Name)\n\t\t\ttest.Logf(\"Expected a parsing error, found no error.\")\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\n\t\tif !strings.Contains(err.Error(), testCase.Expected) {\n\n\t\t\ttest.Logf(\"Test '%s' failed\", testCase.Name)\n\t\t\ttest.Logf(\"Got error: '%s', expected '%s'\", err.Error(), testCase.Expected)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "parsing_test.go",
          "type": "blob",
          "size": 31.203125,
          "content": "package govaluate\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\t\"unicode\"\n)\n\n/*\n\tRepresents a test of parsing all tokens correctly from a string\n*/\ntype TokenParsingTest struct {\n\tName      string\n\tInput     string\n\tFunctions map[string]ExpressionFunction\n\tExpected  []ExpressionToken\n}\n\nfunc TestConstantParsing(test *testing.T) {\n\n\ttokenParsingTests := []TokenParsingTest{\n\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single numeric\",\n\t\t\tInput: \"1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single two-digit numeric\",\n\t\t\tInput: \"50\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 50.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Zero\",\n\t\t\tInput: \"0\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 0.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:  \"One digit hex\",\n\t\t\tInput: \"0x1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:  \"Two digit hex\",\n\t\t\tInput: \"0x10\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 16.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:  \"Hex with lowercase\",\n\t\t\tInput: \"0xabcdef\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 11259375.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:  \"Hex with uppercase\",\n\t\t\tInput: \"0xABCDEF\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 11259375.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single string\",\n\t\t\tInput: \"'foo'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single time, RFC3339, only date\",\n\t\t\tInput: \"'2014-01-02'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  TIME,\n\t\t\t\t\tValue: time.Date(2014, time.January, 2, 0, 0, 0, 0, time.Local),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single time, RFC3339, with hh:mm\",\n\t\t\tInput: \"'2014-01-02 14:12'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  TIME,\n\t\t\t\t\tValue: time.Date(2014, time.January, 2, 14, 12, 0, 0, time.Local),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single time, RFC3339, with hh:mm:ss\",\n\t\t\tInput: \"'2014-01-02 14:12:22'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  TIME,\n\t\t\t\t\tValue: time.Date(2014, time.January, 2, 14, 12, 22, 0, time.Local),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single boolean\",\n\t\t\tInput: \"true\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single large numeric\",\n\t\t\tInput: \"1234567890\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1234567890.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single floating-point\",\n\t\t\tInput: \"0.5\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 0.5,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single large floating point\",\n\t\t\tInput: \"3.14567471\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 3.14567471,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single false boolean\",\n\t\t\tInput: \"false\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:  \"Single internationalized string\",\n\t\t\tInput: \"'ÆŦǽഈᚥஇคٸ'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"ÆŦǽഈᚥஇคٸ\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:  \"Single internationalized parameter\",\n\t\t\tInput: \"ÆŦǽഈᚥஇคٸ\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"ÆŦǽഈᚥஇคٸ\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:      \"Parameterless function\",\n\t\t\tInput:     \"foo()\",\n\t\t\tFunctions: map[string]ExpressionFunction{\"foo\": noop},\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  FUNCTION,\n\t\t\t\t\tValue: noop,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:      \"Single parameter function\",\n\t\t\tInput:     \"foo('bar')\",\n\t\t\tFunctions: map[string]ExpressionFunction{\"foo\": noop},\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  FUNCTION,\n\t\t\t\t\tValue: noop,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"bar\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:      \"Multiple parameter function\",\n\t\t\tInput:     \"foo('bar', 1.0)\",\n\t\t\tFunctions: map[string]ExpressionFunction{\"foo\": noop},\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  FUNCTION,\n\t\t\t\t\tValue: noop,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"bar\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: SEPARATOR,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:      \"Nested function\",\n\t\t\tInput:     \"foo(foo('bar'), 1.0, foo(2.0))\",\n\t\t\tFunctions: map[string]ExpressionFunction{\"foo\": noop},\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  FUNCTION,\n\t\t\t\t\tValue: noop,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  FUNCTION,\n\t\t\t\t\tValue: noop,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"bar\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: SEPARATOR,\n\t\t\t\t},\n\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: SEPARATOR,\n\t\t\t\t},\n\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  FUNCTION,\n\t\t\t\t\tValue: noop,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:      \"Function with modifier afterwards (#28)\",\n\t\t\tInput:     \"foo() + 1\",\n\t\t\tFunctions: map[string]ExpressionFunction{\"foo\": noop},\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  FUNCTION,\n\t\t\t\t\tValue: noop,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"+\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:      \"Function with modifier afterwards and comparator\",\n\t\t\tInput:     \"(foo()-1) > 3\",\n\t\t\tFunctions: map[string]ExpressionFunction{\"foo\": noop},\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  FUNCTION,\n\t\t\t\t\tValue: noop,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"-\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \">\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 3.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:  \"Double-quoted string added to square-brackted param (#59)\",\n\t\t\tInput: \"\\\"a\\\" + [foo]\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"a\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"+\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:  \"Accessor variable\",\n\t\t\tInput: \"foo.Var\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  ACCESSOR,\n\t\t\t\t\tValue: []string{\"foo\", \"Var\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\t\t\tName:  \"Accessor function\",\n\t\t\tInput: \"foo.Operation()\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  ACCESSOR,\n\t\t\t\t\tValue: []string{\"foo\", \"Operation\"},\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\ttokenParsingTests = combineWhitespaceExpressions(tokenParsingTests)\n\trunTokenParsingTest(tokenParsingTests, test)\n}\n\nfunc TestLogicalOperatorParsing(test *testing.T) {\n\n\ttokenParsingTests := []TokenParsingTest{\n\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Boolean AND\",\n\t\t\tInput: \"true && false\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  LOGICALOP,\n\t\t\t\t\tValue: \"&&\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Boolean OR\",\n\t\t\tInput: \"true || false\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  LOGICALOP,\n\t\t\t\t\tValue: \"||\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Multiple logical operators\",\n\t\t\tInput: \"true || false && true\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  LOGICALOP,\n\t\t\t\t\tValue: \"||\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: false,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  LOGICALOP,\n\t\t\t\t\tValue: \"&&\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\ttokenParsingTests = combineWhitespaceExpressions(tokenParsingTests)\n\trunTokenParsingTest(tokenParsingTests, test)\n}\n\nfunc TestComparatorParsing(test *testing.T) {\n\n\ttokenParsingTests := []TokenParsingTest{\n\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric EQ\",\n\t\t\tInput: \"1 == 2\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"==\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric NEQ\",\n\t\t\tInput: \"1 != 2\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"!=\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric GT\",\n\t\t\tInput: \"1 > 0\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \">\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 0.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric LT\",\n\t\t\tInput: \"1 < 2\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"<\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric GTE\",\n\t\t\tInput: \"1 >= 2\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \">=\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric LTE\",\n\t\t\tInput: \"1 <= 2\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"<=\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"String LT\",\n\t\t\tInput: \"'ab.cd' < 'abc.def'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"ab.cd\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"<\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"abc.def\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"String LTE\",\n\t\t\tInput: \"'ab.cd' <= 'abc.def'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"ab.cd\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"<=\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"abc.def\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"String GT\",\n\t\t\tInput: \"'ab.cd' > 'abc.def'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"ab.cd\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \">\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"abc.def\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"String GTE\",\n\t\t\tInput: \"'ab.cd' >= 'abc.def'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"ab.cd\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \">=\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"abc.def\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"String REQ\",\n\t\t\tInput: \"'foobar' =~ 'bar'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foobar\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"=~\",\n\t\t\t\t},\n\n\t\t\t\t// it's not particularly clean to test for the contents of a pattern, (since it means modifying the harness below)\n\t\t\t\t// so pattern contents are left untested.\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: PATTERN,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"String NREQ\",\n\t\t\tInput: \"'foobar' !~ 'bar'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foobar\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"!~\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: PATTERN,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Comparator against modifier string additive (#22)\",\n\t\t\tInput: \"'foo' == '+'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"==\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"+\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Comparator against modifier string multiplicative (#22)\",\n\t\t\tInput: \"'foo' == '/'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"==\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"/\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Comparator against modifier string exponential (#22)\",\n\t\t\tInput: \"'foo' == '**'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"==\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"**\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Comparator against modifier string bitwise (#22)\",\n\t\t\tInput: \"'foo' == '^'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"==\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"^\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Comparator against modifier string shift (#22)\",\n\t\t\tInput: \"'foo' == '>>'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"==\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \">>\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Comparator against modifier string ternary (#22)\",\n\t\t\tInput: \"'foo' == '?'\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"==\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"?\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Array membership lowercase\",\n\t\t\tInput: \"'foo' in ('foo', 'bar')\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"in\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: SEPARATOR,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"bar\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Array membership uppercase\",\n\t\t\tInput: \"'foo' IN ('foo', 'bar')\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"in\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: SEPARATOR,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"bar\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: CLAUSE_CLOSE,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\ttokenParsingTests = combineWhitespaceExpressions(tokenParsingTests)\n\trunTokenParsingTest(tokenParsingTests, test)\n}\n\nfunc TestModifierParsing(test *testing.T) {\n\n\ttokenParsingTests := []TokenParsingTest{\n\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric PLUS\",\n\t\t\tInput: \"1 + 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"+\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric MINUS\",\n\t\t\tInput: \"1 - 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"-\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric MULTIPLY\",\n\t\t\tInput: \"1 * 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"*\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric DIVIDE\",\n\t\t\tInput: \"1 / 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"/\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric MODULUS\",\n\t\t\tInput: \"1 % 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"%\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric BITWISE_AND\",\n\t\t\tInput: \"1 & 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"&\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric BITWISE_OR\",\n\t\t\tInput: \"1 | 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"|\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric BITWISE_XOR\",\n\t\t\tInput: \"1 ^ 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"^\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric BITWISE_LSHIFT\",\n\t\t\tInput: \"1 << 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \"<<\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Numeric BITWISE_RSHIFT\",\n\t\t\tInput: \"1 >> 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  MODIFIER,\n\t\t\t\t\tValue: \">>\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\ttokenParsingTests = combineWhitespaceExpressions(tokenParsingTests)\n\trunTokenParsingTest(tokenParsingTests, test)\n}\n\nfunc TestPrefixParsing(test *testing.T) {\n\n\ttestCases := []TokenParsingTest{\n\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Sign prefix\",\n\t\t\tInput: \"-1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  PREFIX,\n\t\t\t\t\tValue: \"-\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Sign prefix on variable\",\n\t\t\tInput: \"-foo\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  PREFIX,\n\t\t\t\t\tValue: \"-\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Boolean prefix\",\n\t\t\tInput: \"!true\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  PREFIX,\n\t\t\t\t\tValue: \"!\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Boolean prefix on variable\",\n\t\t\tInput: \"!foo\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  PREFIX,\n\t\t\t\t\tValue: \"!\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Bitwise not prefix\",\n\t\t\tInput: \"~1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  PREFIX,\n\t\t\t\t\tValue: \"~\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Bitwise not prefix on variable\",\n\t\t\tInput: \"~foo\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  PREFIX,\n\t\t\t\t\tValue: \"~\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\ttestCases = combineWhitespaceExpressions(testCases)\n\trunTokenParsingTest(testCases, test)\n}\n\nfunc TestEscapedParameters(test *testing.T) {\n\n\ttestCases := []TokenParsingTest{\n\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single escaped parameter\",\n\t\t\tInput: \"[foo]\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single escaped parameter with whitespace\",\n\t\t\tInput: \"[foo bar]\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Single escaped parameter with escaped closing bracket\",\n\t\t\tInput: \"[foo[bar\\\\]]\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo[bar]\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Escaped parameters and unescaped parameters\",\n\t\t\tInput: \"[foo] > bar\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \">\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Unescaped parameter with space\",\n\t\t\tInput: \"foo\\\\ bar > bar\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo bar\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \">\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Unescaped parameter with space\",\n\t\t\tInput: \"response\\\\-time > bar\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"response-time\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \">\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Parameters with snake_case\",\n\t\t\tInput: \"foo_bar > baz_quux\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"foo_bar\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \">\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  VARIABLE,\n\t\t\t\t\tValue: \"baz_quux\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"String literal uses backslash to escape\",\n\t\t\tInput: \"\\\"foo\\\\'bar\\\"\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  STRING,\n\t\t\t\t\tValue: \"foo'bar\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trunTokenParsingTest(testCases, test)\n}\n\nfunc TestTernaryParsing(test *testing.T) {\n\ttokenParsingTests := []TokenParsingTest{\n\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Ternary after Boolean\",\n\t\t\tInput: \"true ? 1\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  TERNARY,\n\t\t\t\t\tValue: \"?\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Ternary after Comperator\",\n\t\t\tInput: \"1 == 0 ? true\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  COMPARATOR,\n\t\t\t\t\tValue: \"==\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 0.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  TERNARY,\n\t\t\t\t\tValue: \"?\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenParsingTest{\n\n\t\t\tName:  \"Null coalesce left\",\n\t\t\tInput: \"1 ?? 2\",\n\t\t\tExpected: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  TERNARY,\n\t\t\t\t\tValue: \"??\",\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 2.0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trunTokenParsingTest(tokenParsingTests, test)\n}\n\n/*\n\tTests to make sure that the String() reprsentation of an expression exactly matches what is given to the parse function.\n*/\nfunc TestOriginalString(test *testing.T) {\n\n\t// include all the token types, to be sure there's no shenaniganery going on.\n\texpressionString := \"2 > 1 &&\" +\n\t\t\"'something' != 'nothing' || \" +\n\t\t\"'2014-01-20' < 'Wed Jul  8 23:07:35 MDT 2015' && \" +\n\t\t\"[escapedVariable name with spaces] <= unescaped\\\\-variableName &&\" +\n\t\t\"modifierTest + 1000 / 2 > (80 * 100 % 2) && true ? true : false\"\n\n\texpression, err := NewEvaluableExpression(expressionString)\n\tif err != nil {\n\n\t\ttest.Logf(\"failed to parse original string test: %v\", err)\n\t\ttest.Fail()\n\t\treturn\n\t}\n\n\tif expression.String() != expressionString {\n\t\ttest.Logf(\"String() did not give the same expression as given to parse\")\n\t\ttest.Fail()\n\t}\n}\n\n/*\n\tTests to make sure that the Vars() reprsentation of an expression identifies all variables contained within the expression.\n*/\nfunc TestOriginalVars(test *testing.T) {\n\n\t// include all the token types, to be sure there's no shenaniganery going on.\n\texpressionString := \"2 > 1 &&\" +\n\t\t\"'something' != 'nothing' || \" +\n\t\t\"'2014-01-20' < 'Wed Jul  8 23:07:35 MDT 2015' && \" +\n\t\t\"[escapedVariable name with spaces] <= unescaped\\\\-variableName &&\" +\n\t\t\"modifierTest + 1000 / 2 > (80 * 100 % 2) && true ? true : false\"\n\n\texpectedVars := [3]string{\"escapedVariable name with spaces\",\n\t\t\"modifierTest\",\n\t\t\"unescaped-variableName\"}\n\n\texpression, err := NewEvaluableExpression(expressionString)\n\tif err != nil {\n\n\t\ttest.Logf(\"failed to parse original var test: %v\", err)\n\t\ttest.Fail()\n\t\treturn\n\t}\n\n\tif len(expression.Vars()) == len(expectedVars) {\n\t\tvariableMap := make(map[string]string)\n\t\tfor _, v := range expression.Vars() {\n\t\t\tvariableMap[v] = v\n\t\t}\n\t\tfor _, v := range expectedVars {\n\t\t\tif _, ok := variableMap[v]; !ok {\n\t\t\t\ttest.Logf(\"Vars() did not correctly identify all variables contained within the expression\")\n\t\t\t\ttest.Fail()\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttest.Logf(\"Vars() did not correctly identify all variables contained within the expression\")\n\t\ttest.Fail()\n\t}\n}\n\nfunc combineWhitespaceExpressions(testCases []TokenParsingTest) []TokenParsingTest {\n\n\tvar currentCase, strippedCase TokenParsingTest\n\tvar caseLength int\n\n\tcaseLength = len(testCases)\n\n\tfor i := 0; i < caseLength; i++ {\n\n\t\tcurrentCase = testCases[i]\n\n\t\tstrippedCase = TokenParsingTest{\n\n\t\t\tName:      (currentCase.Name + \" (without whitespace)\"),\n\t\t\tInput:     stripUnquotedWhitespace(currentCase.Input),\n\t\t\tExpected:  currentCase.Expected,\n\t\t\tFunctions: currentCase.Functions,\n\t\t}\n\n\t\ttestCases = append(testCases, strippedCase, currentCase)\n\t}\n\n\treturn testCases\n}\n\nfunc stripUnquotedWhitespace(expression string) string {\n\n\tvar expressionBuffer bytes.Buffer\n\tvar quoted bool\n\n\tfor _, character := range expression {\n\n\t\tif !quoted && unicode.IsSpace(character) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif character == '\\'' {\n\t\t\tquoted = !quoted\n\t\t}\n\n\t\texpressionBuffer.WriteString(string(character))\n\t}\n\n\treturn expressionBuffer.String()\n}\n\nfunc runTokenParsingTest(tokenParsingTests []TokenParsingTest, test *testing.T) {\n\n\tvar parsingTest TokenParsingTest\n\tvar expression *EvaluableExpression\n\tvar actualTokens []ExpressionToken\n\tvar actualToken ExpressionToken\n\tvar expectedTokenKindString, actualTokenKindString string\n\tvar expectedTokenLength, actualTokenLength int\n\tvar err error\n\n\tfmt.Printf(\"Running %d parsing test cases...\\n\", len(tokenParsingTests))\n\t// defer func() {\n\t//     if r := recover(); r != nil {\n\t//         test.Logf(\"Panic in test '%s': %v\", parsingTest.Name, r)\n\t// \t\ttest.Fail()\n\t//     }\n\t// }()\n\n\t// Run the test cases.\n\tfor _, parsingTest = range tokenParsingTests {\n\n\t\tif parsingTest.Functions != nil {\n\t\t\texpression, err = NewEvaluableExpressionWithFunctions(parsingTest.Input, parsingTest.Functions)\n\t\t} else {\n\t\t\texpression, err = NewEvaluableExpression(parsingTest.Input)\n\t\t}\n\n\t\tif err != nil {\n\n\t\t\ttest.Logf(\"Test '%s' failed to parse: %s\", parsingTest.Name, err)\n\t\t\ttest.Logf(\"Expression: '%s'\", parsingTest.Input)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\n\t\tactualTokens = expression.Tokens()\n\n\t\texpectedTokenLength = len(parsingTest.Expected)\n\t\tactualTokenLength = len(actualTokens)\n\n\t\tif actualTokenLength != expectedTokenLength {\n\n\t\t\ttest.Logf(\"Test '%s' failed:\", parsingTest.Name)\n\t\t\ttest.Logf(\"Expected %d tokens, actually found %d\", expectedTokenLength, actualTokenLength)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i, expectedToken := range parsingTest.Expected {\n\n\t\t\tactualToken = actualTokens[i]\n\t\t\tif actualToken.Kind != expectedToken.Kind {\n\n\t\t\t\tactualTokenKindString = actualToken.Kind.String()\n\t\t\t\texpectedTokenKindString = expectedToken.Kind.String()\n\n\t\t\t\ttest.Logf(\"Test '%s' failed:\", parsingTest.Name)\n\t\t\t\ttest.Logf(\"Expected token kind '%v' does not match '%v'\", expectedTokenKindString, actualTokenKindString)\n\t\t\t\ttest.Fail()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif expectedToken.Value == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treflectedKind := reflect.TypeOf(expectedToken.Value).Kind()\n\t\t\tif reflectedKind == reflect.Func {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// gotta be an accessor\n\t\t\tif reflectedKind == reflect.Slice {\n\n\t\t\t\tif actualToken.Value == nil {\n\t\t\t\t\ttest.Logf(\"Test '%s' failed:\", parsingTest.Name)\n\t\t\t\t\ttest.Logf(\"Expected token value '%v' does not match nil\", expectedToken.Value)\n\t\t\t\t\ttest.Fail()\n\t\t\t\t}\n\n\t\t\t\tfor z, actual := range actualToken.Value.([]string) {\n\n\t\t\t\t\tif actual != expectedToken.Value.([]string)[z] {\n\n\t\t\t\t\t\ttest.Logf(\"Test '%s' failed:\", parsingTest.Name)\n\t\t\t\t\t\ttest.Logf(\"Expected token value '%v' does not match '%v'\", expectedToken.Value, actualToken.Value)\n\t\t\t\t\t\ttest.Fail()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif actualToken.Value != expectedToken.Value {\n\n\t\t\t\ttest.Logf(\"Test '%s' failed:\", parsingTest.Name)\n\t\t\t\ttest.Logf(\"Expected token value '%v' does not match '%v'\", expectedToken.Value, actualToken.Value)\n\t\t\t\ttest.Fail()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc noop(arguments ...interface{}) (interface{}, error) {\n\treturn nil, nil\n}\n"
        },
        {
          "name": "readme_test.go",
          "type": "blob",
          "size": 3.75390625,
          "content": "package govaluate\n\n/*\n  Contains test cases for all the expression examples given in the README.\n  While all of the functionality for these cases should be covered in other tests,\n  this is really just a sanity check.\n*/\nimport (\n\t\"testing\"\n)\n\nfunc TestBasicEvaluation(test *testing.T) {\n\n\texpression, err := NewEvaluableExpression(\"10 > 0\")\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tresult, err := expression.Evaluate(nil)\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tif result != true {\n\t\ttest.Logf(\"Expected 'true', got '%v'\\n\", result)\n\t\ttest.Fail()\n\t}\n}\n\nfunc TestParameterEvaluation(test *testing.T) {\n\n\texpression, err := NewEvaluableExpression(\"foo > 0\")\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tparameters := make(map[string]interface{}, 8)\n\tparameters[\"foo\"] = -1\n\n\tresult, err := expression.Evaluate(parameters)\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tif result != false {\n\t\ttest.Logf(\"Expected 'false', got '%v'\\n\", result)\n\t\ttest.Fail()\n\t}\n}\n\nfunc TestModifierEvaluation(test *testing.T) {\n\n\texpression, err := NewEvaluableExpression(\"(requests_made * requests_succeeded / 100) >= 90\")\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tparameters := make(map[string]interface{}, 8)\n\tparameters[\"requests_made\"] = 100\n\tparameters[\"requests_succeeded\"] = 80\n\n\tresult, err := expression.Evaluate(parameters)\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tif result != false {\n\t\ttest.Logf(\"Expected 'false', got '%v'\\n\", result)\n\t\ttest.Fail()\n\t}\n}\n\nfunc TestStringEvaluation(test *testing.T) {\n\n\texpression, err := NewEvaluableExpression(\"http_response_body == 'service is ok'\")\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tparameters := make(map[string]interface{}, 8)\n\tparameters[\"http_response_body\"] = \"service is ok\"\n\n\tresult, err := expression.Evaluate(parameters)\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tif result != true {\n\t\ttest.Logf(\"Expected 'false', got '%v'\\n\", result)\n\t\ttest.Fail()\n\t}\n}\n\nfunc TestFloatEvaluation(test *testing.T) {\n\n\texpression, err := NewEvaluableExpression(\"(mem_used / total_mem) * 100\")\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tparameters := make(map[string]interface{}, 8)\n\tparameters[\"total_mem\"] = 1024\n\tparameters[\"mem_used\"] = 512\n\n\tresult, err := expression.Evaluate(parameters)\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tif result != 50.0 {\n\t\ttest.Logf(\"Expected '50.0', got '%v'\\n\", result)\n\t\ttest.Fail()\n\t}\n}\n\nfunc TestDateComparison(test *testing.T) {\n\n\texpression, err := NewEvaluableExpression(\"'2014-01-02' > '2014-01-01 23:59:59'\")\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tresult, err := expression.Evaluate(nil)\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tif result != true {\n\t\ttest.Logf(\"Expected 'true', got '%v'\\n\", result)\n\t\ttest.Fail()\n\t}\n}\n\nfunc TestMultipleEvaluation(test *testing.T) {\n\texpression, _ := NewEvaluableExpression(\"response_time <= 100\")\n\tparameters := make(map[string]interface{}, 8)\n\n\tfor i := 0; i < 64; i++ {\n\t\tparameters[\"response_time\"] = i\n\t\tresult, err := expression.Evaluate(parameters)\n\t\tif err != nil {\n\t\t\ttest.Log(err)\n\t\t\ttest.Fail()\n\t\t}\n\n\t\tif result != true {\n\t\t\ttest.Logf(\"Expected 'true', got '%v'\\n\", result)\n\t\t\ttest.Fail()\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc TestStrlenFunction(test *testing.T) {\n\n\tfunctions := map[string]ExpressionFunction{\n\t\t\"strlen\": func(args ...interface{}) (interface{}, error) {\n\t\t\tlength := len(args[0].(string))\n\t\t\treturn (float64)(length), nil\n\t\t},\n\t}\n\n\texpString := \"strlen('someReallyLongInputString') <= 16\"\n\texpression, err := NewEvaluableExpressionWithFunctions(expString, functions)\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tresult, err := expression.Evaluate(nil)\n\tif err != nil {\n\t\ttest.Log(err)\n\t\ttest.Fail()\n\t}\n\n\tif result != false {\n\t\ttest.Logf(\"Expected 'false', got '%v'\\n\", result)\n\t\ttest.Fail()\n\t}\n}\n"
        },
        {
          "name": "sanitizedParameters.go",
          "type": "blob",
          "size": 0.880859375,
          "content": "package govaluate\n\n// sanitizedParameters is a wrapper for Parameters that does sanitization as\n// parameters are accessed.\ntype sanitizedParameters struct {\n\torig Parameters\n}\n\nfunc (p sanitizedParameters) Get(key string) (interface{}, error) {\n\tvalue, err := p.orig.Get(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn castToFloat64(value), nil\n}\n\nfunc castToFloat64(value interface{}) interface{} {\n\tswitch value.(type) {\n\tcase uint8:\n\t\treturn float64(value.(uint8))\n\tcase uint16:\n\t\treturn float64(value.(uint16))\n\tcase uint32:\n\t\treturn float64(value.(uint32))\n\tcase uint64:\n\t\treturn float64(value.(uint64))\n\tcase int8:\n\t\treturn float64(value.(int8))\n\tcase int16:\n\t\treturn float64(value.(int16))\n\tcase int32:\n\t\treturn float64(value.(int32))\n\tcase int64:\n\t\treturn float64(value.(int64))\n\tcase int:\n\t\treturn float64(value.(int))\n\tcase float32:\n\t\treturn float64(value.(float32))\n\t}\n\n\treturn value\n}\n"
        },
        {
          "name": "sql_test.go",
          "type": "blob",
          "size": 4.4208984375,
          "content": "package govaluate\n\nimport (\n\t\"testing\"\n)\n\n/*\n\tRepresents a test of correctly creating a SQL query string from an expression.\n*/\ntype QueryTest struct {\n\tName     string\n\tInput    string\n\tExpected string\n}\n\nfunc TestSQLSerialization(test *testing.T) {\n\n\ttestCases := []QueryTest{\n\n\t\tQueryTest{\n\n\t\t\tName:     \"Single GT\",\n\t\t\tInput:    \"1 > 0\",\n\t\t\tExpected: \"1 > 0\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single LT\",\n\t\t\tInput:    \"0 < 1\",\n\t\t\tExpected: \"0 < 1\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single GTE\",\n\t\t\tInput:    \"1 >= 0\",\n\t\t\tExpected: \"1 >= 0\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single LTE\",\n\t\t\tInput:    \"0 <= 1\",\n\t\t\tExpected: \"0 <= 1\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single EQ\",\n\t\t\tInput:    \"1 == 0\",\n\t\t\tExpected: \"1 = 0\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single NEQ\",\n\t\t\tInput:    \"1 != 0\",\n\t\t\tExpected: \"1 <> 0\",\n\t\t},\n\n\t\tQueryTest{\n\n\t\t\tName:     \"Parameter names\",\n\t\t\tInput:    \"foo == bar\",\n\t\t\tExpected: \"[foo] = [bar]\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Strings\",\n\t\t\tInput:    \"'foo'\",\n\t\t\tExpected: \"'foo'\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Date format\",\n\t\t\tInput:    \"'2014-07-04T00:00:00Z'\",\n\t\t\tExpected: \"'2014-07-04T00:00:00Z'\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single PLUS\",\n\t\t\tInput:    \"10 + 10\",\n\t\t\tExpected: \"10 + 10\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single MINUS\",\n\t\t\tInput:    \"10 - 10\",\n\t\t\tExpected: \"10 - 10\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single MULTIPLY\",\n\t\t\tInput:    \"10 * 10\",\n\t\t\tExpected: \"10 * 10\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single DIVIDE\",\n\t\t\tInput:    \"10 / 10\",\n\t\t\tExpected: \"10 / 10\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single true bool\",\n\t\t\tInput:    \"true\",\n\t\t\tExpected: \"1\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single false bool\",\n\t\t\tInput:    \"false\",\n\t\t\tExpected: \"0\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single AND\",\n\t\t\tInput:    \"true && true\",\n\t\t\tExpected: \"1 AND 1\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Single OR\",\n\t\t\tInput:    \"true || true\",\n\t\t\tExpected: \"1 OR 1\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Clauses\",\n\t\t\tInput:    \"10 + (foo + bar)\",\n\t\t\tExpected: \"10 + ( [foo] + [bar] )\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Negate prefix\",\n\t\t\tInput:    \"foo < -1\",\n\t\t\tExpected: \"[foo] < -1\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Invert prefix\",\n\t\t\tInput:    \"!(foo > 1)\",\n\t\t\tExpected: \"NOT ( [foo] > 1 )\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Exponent\",\n\t\t\tInput:    \"1 ** 2\",\n\t\t\tExpected: \"POW(1, 2)\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Modulus\",\n\t\t\tInput:    \"10 % 2\",\n\t\t\tExpected: \"MOD(10, 2)\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Membership operator\",\n\t\t\tInput:    \"foo IN (1, 2, 3)\",\n\t\t\tExpected: \"[foo] in ( 1 , 2 , 3 )\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Null coalescence\",\n\t\t\tInput:    \"foo ?? bar\",\n\t\t\tExpected: \"COALESCE([foo], [bar])\",\n\t\t},\n\t\t/*\n\t\t\t// Ternaries don't work yet, because the outputter is not yet sophisticated enough to produce them.\n\t\t\tQueryTest{\n\n\t\t\t\tName:     \"Full ternary\",\n\t\t\t\tInput:    \"[foo] == 5 ? 1 : 2\",\n\t\t\t\tExpected: \"IF([foo] = 5, 1, 2)\",\n\t\t\t},\n\t\t\tQueryTest{\n\n\t\t\t\tName:     \"Half ternary\",\n\t\t\t\tInput:    \"[foo] == 5 ? 1\",\n\t\t\t\tExpected: \"IF([foo] = 5, 1)\",\n\t\t\t},\n\t\t\tQueryTest{\n\n\t\t\t\tName:     \"Full ternary with implicit bool\",\n\t\t\t\tInput:    \"[foo] ? 1 : 2\",\n\t\t\t\tExpected: \"IF([foo] = 0, 1, 2)\",\n\t\t\t},\n\t\t\tQueryTest{\n\n\t\t\t\tName:     \"Half ternary with implicit bool\",\n\t\t\t\tInput:    \"[foo] ? 1\",\n\t\t\t\tExpected: \"IF([foo] = 0, 1)\",\n\t\t\t},*/\n\t\tQueryTest{\n\n\t\t\tName:     \"Regex equals\",\n\t\t\tInput:    \"'foo' =~ '[fF][oO]+'\",\n\t\t\tExpected: \"'foo' RLIKE '[fF][oO]+'\",\n\t\t},\n\t\tQueryTest{\n\n\t\t\tName:     \"Regex not-equals\",\n\t\t\tInput:    \"'foo' !~ '[fF][oO]+'\",\n\t\t\tExpected: \"'foo' NOT RLIKE '[fF][oO]+'\",\n\t\t},\n\t}\n\n\trunQueryTests(testCases, test)\n}\n\nfunc runQueryTests(testCases []QueryTest, test *testing.T) {\n\n\tvar expression *EvaluableExpression\n\tvar actualQuery string\n\tvar err error\n\n\ttest.Logf(\"Running %d SQL translation test cases\", len(testCases))\n\n\t// Run the test cases.\n\tfor _, testCase := range testCases {\n\n\t\texpression, err = NewEvaluableExpression(testCase.Input)\n\n\t\tif err != nil {\n\n\t\t\ttest.Logf(\"Test '%s' failed to parse: %s\", testCase.Name, err)\n\t\t\ttest.Logf(\"Expression: '%s'\", testCase.Input)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\n\t\tactualQuery, err = expression.ToSQLQuery()\n\n\t\tif err != nil {\n\n\t\t\ttest.Logf(\"Test '%s' failed to create query: %s\", testCase.Name, err)\n\t\t\ttest.Logf(\"Expression: '%s'\", testCase.Input)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\n\t\tif actualQuery != testCase.Expected {\n\n\t\t\ttest.Logf(\"Test '%s' did not create expected query.\", testCase.Name)\n\t\t\ttest.Logf(\"Actual: '%s', expected '%s'\", actualQuery, testCase.Expected)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "stagePlanner.go",
          "type": "blob",
          "size": 17.583984375,
          "content": "package govaluate\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\nvar stageSymbolMap = map[OperatorSymbol]evaluationOperator{\n\tEQ:             equalStage,\n\tNEQ:            notEqualStage,\n\tGT:             gtStage,\n\tLT:             ltStage,\n\tGTE:            gteStage,\n\tLTE:            lteStage,\n\tREQ:            regexStage,\n\tNREQ:           notRegexStage,\n\tAND:            andStage,\n\tOR:             orStage,\n\tIN:             inStage,\n\tBITWISE_OR:     bitwiseOrStage,\n\tBITWISE_AND:    bitwiseAndStage,\n\tBITWISE_XOR:    bitwiseXORStage,\n\tBITWISE_LSHIFT: leftShiftStage,\n\tBITWISE_RSHIFT: rightShiftStage,\n\tPLUS:           addStage,\n\tMINUS:          subtractStage,\n\tMULTIPLY:       multiplyStage,\n\tDIVIDE:         divideStage,\n\tMODULUS:        modulusStage,\n\tEXPONENT:       exponentStage,\n\tNEGATE:         negateStage,\n\tINVERT:         invertStage,\n\tBITWISE_NOT:    bitwiseNotStage,\n\tTERNARY_TRUE:   ternaryIfStage,\n\tTERNARY_FALSE:  ternaryElseStage,\n\tCOALESCE:       ternaryElseStage,\n\tSEPARATE:       separatorStage,\n}\n\n/*\n\tA \"precedent\" is a function which will recursively parse new evaluateionStages from a given stream of tokens.\n\tIt's called a `precedent` because it is expected to handle exactly what precedence of operator,\n\tand defer to other `precedent`s for other operators.\n*/\ntype precedent func(stream *tokenStream) (*evaluationStage, error)\n\n/*\n\tA convenience function for specifying the behavior of a `precedent`.\n\tMost `precedent` functions can be described by the same function, just with different type checks, symbols, and error formats.\n\tThis struct is passed to `makePrecedentFromPlanner` to create a `precedent` function.\n*/\ntype precedencePlanner struct {\n\tvalidSymbols map[string]OperatorSymbol\n\tvalidKinds   []TokenKind\n\n\ttypeErrorFormat string\n\n\tnext      precedent\n\tnextRight precedent\n}\n\nvar planPrefix precedent\nvar planExponential precedent\nvar planMultiplicative precedent\nvar planAdditive precedent\nvar planBitwise precedent\nvar planShift precedent\nvar planComparator precedent\nvar planLogicalAnd precedent\nvar planLogicalOr precedent\nvar planTernary precedent\nvar planSeparator precedent\n\nfunc init() {\n\n\t// all these stages can use the same code (in `planPrecedenceLevel`) to execute,\n\t// they simply need different type checks, symbols, and recursive precedents.\n\t// While not all precedent phases are listed here, most can be represented this way.\n\tplanPrefix = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    prefixSymbols,\n\t\tvalidKinds:      []TokenKind{PREFIX},\n\t\ttypeErrorFormat: prefixErrorFormat,\n\t\tnextRight:       planFunction,\n\t})\n\tplanExponential = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    exponentialSymbolsS,\n\t\tvalidKinds:      []TokenKind{MODIFIER},\n\t\ttypeErrorFormat: modifierErrorFormat,\n\t\tnext:            planFunction,\n\t})\n\tplanMultiplicative = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    multiplicativeSymbols,\n\t\tvalidKinds:      []TokenKind{MODIFIER},\n\t\ttypeErrorFormat: modifierErrorFormat,\n\t\tnext:            planExponential,\n\t})\n\tplanAdditive = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    additiveSymbols,\n\t\tvalidKinds:      []TokenKind{MODIFIER},\n\t\ttypeErrorFormat: modifierErrorFormat,\n\t\tnext:            planMultiplicative,\n\t})\n\tplanShift = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    bitwiseShiftSymbols,\n\t\tvalidKinds:      []TokenKind{MODIFIER},\n\t\ttypeErrorFormat: modifierErrorFormat,\n\t\tnext:            planAdditive,\n\t})\n\tplanBitwise = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    bitwiseSymbols,\n\t\tvalidKinds:      []TokenKind{MODIFIER},\n\t\ttypeErrorFormat: modifierErrorFormat,\n\t\tnext:            planShift,\n\t})\n\tplanComparator = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    comparatorSymbols,\n\t\tvalidKinds:      []TokenKind{COMPARATOR},\n\t\ttypeErrorFormat: comparatorErrorFormat,\n\t\tnext:            planBitwise,\n\t})\n\tplanLogicalAnd = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    map[string]OperatorSymbol{\"&&\": AND},\n\t\tvalidKinds:      []TokenKind{LOGICALOP},\n\t\ttypeErrorFormat: logicalErrorFormat,\n\t\tnext:            planComparator,\n\t})\n\tplanLogicalOr = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    map[string]OperatorSymbol{\"||\": OR},\n\t\tvalidKinds:      []TokenKind{LOGICALOP},\n\t\ttypeErrorFormat: logicalErrorFormat,\n\t\tnext:            planLogicalAnd,\n\t})\n\tplanTernary = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols:    ternarySymbols,\n\t\tvalidKinds:      []TokenKind{TERNARY},\n\t\ttypeErrorFormat: ternaryErrorFormat,\n\t\tnext:            planLogicalOr,\n\t})\n\tplanSeparator = makePrecedentFromPlanner(&precedencePlanner{\n\t\tvalidSymbols: separatorSymbols,\n\t\tvalidKinds:   []TokenKind{SEPARATOR},\n\t\tnext:         planTernary,\n\t})\n}\n\n/*\n\tGiven a planner, creates a function which will evaluate a specific precedence level of operators,\n\tand link it to other `precedent`s which recurse to parse other precedence levels.\n*/\nfunc makePrecedentFromPlanner(planner *precedencePlanner) precedent {\n\n\tvar generated precedent\n\tvar nextRight precedent\n\n\tgenerated = func(stream *tokenStream) (*evaluationStage, error) {\n\t\treturn planPrecedenceLevel(\n\t\t\tstream,\n\t\t\tplanner.typeErrorFormat,\n\t\t\tplanner.validSymbols,\n\t\t\tplanner.validKinds,\n\t\t\tnextRight,\n\t\t\tplanner.next,\n\t\t)\n\t}\n\n\tif planner.nextRight != nil {\n\t\tnextRight = planner.nextRight\n\t} else {\n\t\tnextRight = generated\n\t}\n\n\treturn generated\n}\n\n/*\n\tCreates a `evaluationStageList` object which represents an execution plan (or tree)\n\twhich is used to completely evaluate a set of tokens at evaluation-time.\n\tThe three stages of evaluation can be thought of as parsing strings to tokens, then tokens to a stage list, then evaluation with parameters.\n*/\nfunc planStages(tokens []ExpressionToken) (*evaluationStage, error) {\n\n\tstream := newTokenStream(tokens)\n\n\tstage, err := planTokens(stream)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// while we're now fully-planned, we now need to re-order same-precedence operators.\n\t// this could probably be avoided with a different planning method\n\treorderStages(stage)\n\n\tstage = elideLiterals(stage)\n\treturn stage, nil\n}\n\nfunc planTokens(stream *tokenStream) (*evaluationStage, error) {\n\n\tif !stream.hasNext() {\n\t\treturn nil, nil\n\t}\n\n\treturn planSeparator(stream)\n}\n\n/*\n\tThe most usual method of parsing an evaluation stage for a given precedence.\n\tMost stages use the same logic\n*/\nfunc planPrecedenceLevel(\n\tstream *tokenStream,\n\ttypeErrorFormat string,\n\tvalidSymbols map[string]OperatorSymbol,\n\tvalidKinds []TokenKind,\n\trightPrecedent precedent,\n\tleftPrecedent precedent) (*evaluationStage, error) {\n\n\tvar token ExpressionToken\n\tvar symbol OperatorSymbol\n\tvar leftStage, rightStage *evaluationStage\n\tvar checks typeChecks\n\tvar err error\n\tvar keyFound bool\n\n\tif leftPrecedent != nil {\n\n\t\tleftStage, err = leftPrecedent(stream)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tfor stream.hasNext() {\n\n\t\ttoken = stream.next()\n\n\t\tif len(validKinds) > 0 {\n\n\t\t\tkeyFound = false\n\t\t\tfor _, kind := range validKinds {\n\t\t\t\tif kind == token.Kind {\n\t\t\t\t\tkeyFound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !keyFound {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif validSymbols != nil {\n\n\t\t\tif !isString(token.Value) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tsymbol, keyFound = validSymbols[token.Value.(string)]\n\t\t\tif !keyFound {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif rightPrecedent != nil {\n\t\t\trightStage, err = rightPrecedent(stream)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tchecks = findTypeChecks(symbol)\n\n\t\treturn &evaluationStage{\n\n\t\t\tsymbol:     symbol,\n\t\t\tleftStage:  leftStage,\n\t\t\trightStage: rightStage,\n\t\t\toperator:   stageSymbolMap[symbol],\n\n\t\t\tleftTypeCheck:   checks.left,\n\t\t\trightTypeCheck:  checks.right,\n\t\t\ttypeCheck:       checks.combined,\n\t\t\ttypeErrorFormat: typeErrorFormat,\n\t\t}, nil\n\t}\n\n\tstream.rewind()\n\treturn leftStage, nil\n}\n\n/*\n\tA special case where functions need to be of higher precedence than values, and need a special wrapped execution stage operator.\n*/\nfunc planFunction(stream *tokenStream) (*evaluationStage, error) {\n\n\tvar token ExpressionToken\n\tvar rightStage *evaluationStage\n\tvar err error\n\n\ttoken = stream.next()\n\n\tif token.Kind != FUNCTION {\n\t\tstream.rewind()\n\t\treturn planAccessor(stream)\n\t}\n\n\trightStage, err = planAccessor(stream)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &evaluationStage{\n\n\t\tsymbol:          FUNCTIONAL,\n\t\trightStage:      rightStage,\n\t\toperator:        makeFunctionStage(token.Value.(ExpressionFunction)),\n\t\ttypeErrorFormat: \"Unable to run function '%v': %v\",\n\t}, nil\n}\n\nfunc planAccessor(stream *tokenStream) (*evaluationStage, error) {\n\n\tvar token, otherToken ExpressionToken\n\tvar rightStage *evaluationStage\n\tvar err error\n\n\tif !stream.hasNext() {\n\t\treturn nil, nil\n\t}\n\n\ttoken = stream.next()\n\n\tif token.Kind != ACCESSOR {\n\t\tstream.rewind()\n\t\treturn planValue(stream)\n\t}\n\n\t// check if this is meant to be a function or a field.\n\t// fields have a clause next to them, functions do not.\n\t// if it's a function, parse the arguments. Otherwise leave the right stage null.\n\tif stream.hasNext() {\n\n\t\totherToken = stream.next()\n\t\tif otherToken.Kind == CLAUSE {\n\n\t\t\tstream.rewind()\n\n\t\t\trightStage, err = planTokens(stream)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tstream.rewind()\n\t\t}\n\t}\n\n\treturn &evaluationStage{\n\n\t\tsymbol:          ACCESS,\n\t\trightStage:      rightStage,\n\t\toperator:        makeAccessorStage(token.Value.([]string)),\n\t\ttypeErrorFormat: \"Unable to access parameter field or method '%v': %v\",\n\t}, nil\n}\n\n/*\n\tA truly special precedence function, this handles all the \"lowest-case\" errata of the process, including literals, parmeters,\n\tclauses, and prefixes.\n*/\nfunc planValue(stream *tokenStream) (*evaluationStage, error) {\n\n\tvar token ExpressionToken\n\tvar symbol OperatorSymbol\n\tvar ret *evaluationStage\n\tvar operator evaluationOperator\n\tvar err error\n\n\tif !stream.hasNext() {\n\t\treturn nil, nil\n\t}\n\n\ttoken = stream.next()\n\n\tswitch token.Kind {\n\n\tcase CLAUSE:\n\n\t\tret, err = planTokens(stream)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// advance past the CLAUSE_CLOSE token. We know that it's a CLAUSE_CLOSE, because at parse-time we check for unbalanced parens.\n\t\tstream.next()\n\n\t\t// the stage we got represents all of the logic contained within the parens\n\t\t// but for technical reasons, we need to wrap this stage in a \"noop\" stage which breaks long chains of precedence.\n\t\t// see github #33.\n\t\tret = &evaluationStage{\n\t\t\trightStage: ret,\n\t\t\toperator:   noopStageRight,\n\t\t\tsymbol:     NOOP,\n\t\t}\n\n\t\treturn ret, nil\n\n\tcase CLAUSE_CLOSE:\n\n\t\t// when functions have empty params, this will be hit. In this case, we don't have any evaluation stage to do,\n\t\t// so we just return nil so that the stage planner continues on its way.\n\t\tstream.rewind()\n\t\treturn nil, nil\n\n\tcase VARIABLE:\n\t\toperator = makeParameterStage(token.Value.(string))\n\n\tcase NUMERIC:\n\t\tfallthrough\n\tcase STRING:\n\t\tfallthrough\n\tcase PATTERN:\n\t\tfallthrough\n\tcase BOOLEAN:\n\t\tsymbol = LITERAL\n\t\toperator = makeLiteralStage(token.Value)\n\tcase TIME:\n\t\tsymbol = LITERAL\n\t\toperator = makeLiteralStage(float64(token.Value.(time.Time).Unix()))\n\n\tcase PREFIX:\n\t\tstream.rewind()\n\t\treturn planPrefix(stream)\n\t}\n\n\tif operator == nil {\n\t\terrorMsg := fmt.Sprintf(\"Unable to plan token kind: '%s', value: '%v'\", token.Kind.String(), token.Value)\n\t\treturn nil, errors.New(errorMsg)\n\t}\n\n\treturn &evaluationStage{\n\t\tsymbol:   symbol,\n\t\toperator: operator,\n\t}, nil\n}\n\n/*\n\tConvenience function to pass a triplet of typechecks between `findTypeChecks` and `planPrecedenceLevel`.\n\tEach of these members may be nil, which indicates that type does not matter for that value.\n*/\ntype typeChecks struct {\n\tleft     stageTypeCheck\n\tright    stageTypeCheck\n\tcombined stageCombinedTypeCheck\n}\n\n/*\n\tMaps a given [symbol] to a set of typechecks to be used during runtime.\n*/\nfunc findTypeChecks(symbol OperatorSymbol) typeChecks {\n\n\tswitch symbol {\n\tcase GT:\n\t\tfallthrough\n\tcase LT:\n\t\tfallthrough\n\tcase GTE:\n\t\tfallthrough\n\tcase LTE:\n\t\treturn typeChecks{\n\t\t\tcombined: comparatorTypeCheck,\n\t\t}\n\tcase REQ:\n\t\tfallthrough\n\tcase NREQ:\n\t\treturn typeChecks{\n\t\t\tleft:  isString,\n\t\t\tright: isRegexOrString,\n\t\t}\n\tcase AND:\n\t\tfallthrough\n\tcase OR:\n\t\treturn typeChecks{\n\t\t\tleft:  isBool,\n\t\t\tright: isBool,\n\t\t}\n\tcase IN:\n\t\treturn typeChecks{\n\t\t\tright: isArray,\n\t\t}\n\tcase BITWISE_LSHIFT:\n\t\tfallthrough\n\tcase BITWISE_RSHIFT:\n\t\tfallthrough\n\tcase BITWISE_OR:\n\t\tfallthrough\n\tcase BITWISE_AND:\n\t\tfallthrough\n\tcase BITWISE_XOR:\n\t\treturn typeChecks{\n\t\t\tleft:  isFloat64,\n\t\t\tright: isFloat64,\n\t\t}\n\tcase PLUS:\n\t\treturn typeChecks{\n\t\t\tcombined: additionTypeCheck,\n\t\t}\n\tcase MINUS:\n\t\tfallthrough\n\tcase MULTIPLY:\n\t\tfallthrough\n\tcase DIVIDE:\n\t\tfallthrough\n\tcase MODULUS:\n\t\tfallthrough\n\tcase EXPONENT:\n\t\treturn typeChecks{\n\t\t\tleft:  isFloat64,\n\t\t\tright: isFloat64,\n\t\t}\n\tcase NEGATE:\n\t\treturn typeChecks{\n\t\t\tright: isFloat64,\n\t\t}\n\tcase INVERT:\n\t\treturn typeChecks{\n\t\t\tright: isBool,\n\t\t}\n\tcase BITWISE_NOT:\n\t\treturn typeChecks{\n\t\t\tright: isFloat64,\n\t\t}\n\tcase TERNARY_TRUE:\n\t\treturn typeChecks{\n\t\t\tleft: isBool,\n\t\t}\n\n\t// unchecked cases\n\tcase EQ:\n\t\tfallthrough\n\tcase NEQ:\n\t\treturn typeChecks{}\n\tcase TERNARY_FALSE:\n\t\tfallthrough\n\tcase COALESCE:\n\t\tfallthrough\n\tdefault:\n\t\treturn typeChecks{}\n\t}\n}\n\n/*\n\tDuring stage planning, stages of equal precedence are parsed such that they'll be evaluated in reverse order.\n\tFor commutative operators like \"+\" or \"-\", it's no big deal. But for order-specific operators, it ruins the expected result.\n*/\nfunc reorderStages(rootStage *evaluationStage) {\n\n\t// traverse every rightStage until we find multiples in a row of the same precedence.\n\tvar identicalPrecedences []*evaluationStage\n\tvar currentStage, nextStage *evaluationStage\n\tvar precedence, currentPrecedence operatorPrecedence\n\n\tnextStage = rootStage\n\tprecedence = findOperatorPrecedenceForSymbol(rootStage.symbol)\n\n\tfor nextStage != nil {\n\n\t\tcurrentStage = nextStage\n\t\tnextStage = currentStage.rightStage\n\n\t\t// left depth first, since this entire method only looks for precedences down the right side of the tree\n\t\tif currentStage.leftStage != nil {\n\t\t\treorderStages(currentStage.leftStage)\n\t\t}\n\n\t\tcurrentPrecedence = findOperatorPrecedenceForSymbol(currentStage.symbol)\n\n\t\tif currentPrecedence == precedence {\n\t\t\tidenticalPrecedences = append(identicalPrecedences, currentStage)\n\t\t\tcontinue\n\t\t}\n\n\t\t// precedence break.\n\t\t// See how many in a row we had, and reorder if there's more than one.\n\t\tif len(identicalPrecedences) > 1 {\n\t\t\tmirrorStageSubtree(identicalPrecedences)\n\t\t}\n\n\t\tidenticalPrecedences = []*evaluationStage{currentStage}\n\t\tprecedence = currentPrecedence\n\t}\n\n\tif len(identicalPrecedences) > 1 {\n\t\tmirrorStageSubtree(identicalPrecedences)\n\t}\n}\n\n/*\n\tPerforms a \"mirror\" on a subtree of stages.\n\tThis mirror functionally inverts the order of execution for all members of the [stages] list.\n\tThat list is assumed to be a root-to-leaf (ordered) list of evaluation stages, where each is a right-hand stage of the last.\n*/\nfunc mirrorStageSubtree(stages []*evaluationStage) {\n\n\tvar rootStage, inverseStage, carryStage, frontStage *evaluationStage\n\n\tstagesLength := len(stages)\n\n\t// reverse all right/left\n\tfor _, frontStage = range stages {\n\n\t\tcarryStage = frontStage.rightStage\n\t\tfrontStage.rightStage = frontStage.leftStage\n\t\tfrontStage.leftStage = carryStage\n\t}\n\n\t// end left swaps with root right\n\trootStage = stages[0]\n\tfrontStage = stages[stagesLength-1]\n\n\tcarryStage = frontStage.leftStage\n\tfrontStage.leftStage = rootStage.rightStage\n\trootStage.rightStage = carryStage\n\n\t// for all non-root non-end stages, right is swapped with inverse stage right in list\n\tfor i := 0; i < (stagesLength-2)/2+1; i++ {\n\n\t\tfrontStage = stages[i+1]\n\t\tinverseStage = stages[stagesLength-i-1]\n\n\t\tcarryStage = frontStage.rightStage\n\t\tfrontStage.rightStage = inverseStage.rightStage\n\t\tinverseStage.rightStage = carryStage\n\t}\n\n\t// swap all other information with inverse stages\n\tfor i := 0; i < stagesLength/2; i++ {\n\n\t\tfrontStage = stages[i]\n\t\tinverseStage = stages[stagesLength-i-1]\n\t\tfrontStage.swapWith(inverseStage)\n\t}\n}\n\n/*\n\tRecurses through all operators in the entire tree, eliding operators where both sides are literals.\n*/\nfunc elideLiterals(root *evaluationStage) *evaluationStage {\n\n\tif root.leftStage != nil {\n\t\troot.leftStage = elideLiterals(root.leftStage)\n\t}\n\n\tif root.rightStage != nil {\n\t\troot.rightStage = elideLiterals(root.rightStage)\n\t}\n\n\treturn elideStage(root)\n}\n\n/*\n\tElides a specific stage, if possible.\n\tReturns the unmodified [root] stage if it cannot or should not be elided.\n\tOtherwise, returns a new stage representing the condensed value from the elided stages.\n*/\nfunc elideStage(root *evaluationStage) *evaluationStage {\n\n\tvar leftValue, rightValue, result interface{}\n\tvar err error\n\n\t// right side must be a non-nil value. Left side must be nil or a value.\n\tif root.rightStage == nil ||\n\t\troot.rightStage.symbol != LITERAL ||\n\t\troot.leftStage == nil ||\n\t\troot.leftStage.symbol != LITERAL {\n\t\treturn root\n\t}\n\n\t// don't elide some operators\n\tswitch root.symbol {\n\tcase SEPARATE:\n\t\tfallthrough\n\tcase IN:\n\t\treturn root\n\t}\n\n\t// both sides are values, get their actual values.\n\t// errors should be near-impossible here. If we encounter them, just abort this optimization.\n\tleftValue, err = root.leftStage.operator(nil, nil, nil)\n\tif err != nil {\n\t\treturn root\n\t}\n\n\trightValue, err = root.rightStage.operator(nil, nil, nil)\n\tif err != nil {\n\t\treturn root\n\t}\n\n\t// typcheck, since the grammar checker is a bit loose with which operator symbols go together.\n\terr = typeCheck(root.leftTypeCheck, leftValue, root.symbol, root.typeErrorFormat)\n\tif err != nil {\n\t\treturn root\n\t}\n\n\terr = typeCheck(root.rightTypeCheck, rightValue, root.symbol, root.typeErrorFormat)\n\tif err != nil {\n\t\treturn root\n\t}\n\n\tif root.typeCheck != nil && !root.typeCheck(leftValue, rightValue) {\n\t\treturn root\n\t}\n\n\t// pre-calculate, and return a new stage representing the result.\n\tresult, err = root.operator(leftValue, rightValue, nil)\n\tif err != nil {\n\t\treturn root\n\t}\n\n\treturn &evaluationStage{\n\t\tsymbol:   LITERAL,\n\t\toperator: makeLiteralStage(result),\n\t}\n}\n"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 0.7421875,
          "content": "#!/bin/bash\n\n# Script that runs tests, code coverage, and benchmarks all at once.\n# Builds a symlink in /tmp, mostly to avoid messing with GOPATH at the user's shell level.\n\nTEMPORARY_PATH=\"/tmp/govaluate_test\"\nSRC_PATH=\"${TEMPORARY_PATH}/src\"\nFULL_PATH=\"${TEMPORARY_PATH}/src/govaluate\"\n\n# set up temporary directory\nrm -rf \"${FULL_PATH}\"\nmkdir -p \"${SRC_PATH}\"\n\nln -s $(pwd) \"${FULL_PATH}\"\nexport GOPATH=\"${TEMPORARY_PATH}\"\n\npushd \"${TEMPORARY_PATH}/src/govaluate\"\n\n# run the actual tests.\nexport GOVALUATE_TORTURE_TEST=\"true\"\ngo test -bench=. -benchmem #-coverprofile coverage.out\nstatus=$?\n\nif [ \"${status}\" != 0 ];\nthen\n\texit $status\nfi\n\n# coverage\n# disabled because travis go1.4 seems not to support it suddenly?\n#go tool cover -func=coverage.out\n\npopd\n"
        },
        {
          "name": "tokenExpressionFailure_test.go",
          "type": "blob",
          "size": 4.1015625,
          "content": "package govaluate\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nconst (\n\tEXPERR_NIL_VALUE string = \"cannot have a nil value\"\n)\n\n/*\n\tContains a single test case for the EvaluableExpression.NewEvaluableExpressionFromTokens() method.\n\n\tThese tests, and the ones in `tokenExpressionFailure_test` will be fairly incomplete.\n\tCreating an expression from a string and from tokens _must_ both perform the same syntax checks.\n\tSo all the checks in `parsing_test` will follow the same logic as the ones here.\n\n\tThese tests check some corner cases - such as tokens having nil values when they must have something.\n\tCases that cannot occur through the normal parser, but may occur in other parsers.\n*/\ntype ExpressionTokenSyntaxTest struct {\n\tName     string\n\tInput    []ExpressionToken\n\tExpected string\n}\n\nfunc TestNilValues(test *testing.T) {\n\n\tcases := []ExpressionTokenSyntaxTest{\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil numeric\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: NUMERIC,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil string\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: STRING,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil bool\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: BOOLEAN,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil time\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: TIME,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil pattern\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: PATTERN,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil variable\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: VARIABLE,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil prefix\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: PREFIX,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil comparator\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: COMPARATOR,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil logicalop\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: LOGICALOP,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil modifer\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: MODIFIER,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  NUMERIC,\n\t\t\t\t\tValue: 1.0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t\tExpressionTokenSyntaxTest{\n\t\t\tName: \"Nil ternary\",\n\t\t\tInput: []ExpressionToken{\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind: TERNARY,\n\t\t\t\t},\n\t\t\t\tExpressionToken{\n\t\t\t\t\tKind:  BOOLEAN,\n\t\t\t\t\tValue: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpected: EXPERR_NIL_VALUE,\n\t\t},\n\t}\n\n\trunExpressionFromTokenTests(cases, true, test)\n}\n\nfunc runExpressionFromTokenTests(cases []ExpressionTokenSyntaxTest, expectFail bool, test *testing.T) {\n\n\tvar err error\n\n\tfmt.Printf(\"Running %d expression from expression token tests...\\n\", len(cases))\n\n\tfor _, testCase := range cases {\n\n\t\t_, err = NewEvaluableExpressionFromTokens(testCase.Input)\n\n\t\tif err != nil {\n\t\t\tif expectFail {\n\n\t\t\t\tif !strings.Contains(err.Error(), testCase.Expected) {\n\n\t\t\t\t\ttest.Logf(\"Test '%s' failed\", testCase.Name)\n\t\t\t\t\ttest.Logf(\"Got error: '%s', expected '%s'\", err.Error(), testCase.Expected)\n\t\t\t\t\ttest.Fail()\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttest.Logf(\"Test '%s' failed\", testCase.Name)\n\t\t\ttest.Logf(\"Got error: '%s'\", err)\n\t\t\ttest.Fail()\n\t\t\tcontinue\n\t\t} else {\n\t\t\tif expectFail {\n\n\t\t\t\ttest.Logf(\"Test '%s' failed\", testCase.Name)\n\t\t\t\ttest.Logf(\"Expected error, found none\\n\")\n\t\t\t\ttest.Fail()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "tokenKind_test.go",
          "type": "blob",
          "size": 0.841796875,
          "content": "package govaluate\n\nimport (\n\t\"testing\"\n)\n\n/*\n\tTests to make sure that all the different token kinds have different string representations\n\tGotta get that 95% code coverage yall. That's why tests like this get written; over-reliance on bad metrics.\n*/\nfunc TestTokenKindStrings(test *testing.T) {\n\n\tvar kindStrings []string\n\tvar kindString string\n\n\tkinds := []TokenKind{\n\t\tUNKNOWN,\n\t\tPREFIX,\n\t\tNUMERIC,\n\t\tBOOLEAN,\n\t\tSTRING,\n\t\tPATTERN,\n\t\tTIME,\n\t\tVARIABLE,\n\t\tCOMPARATOR,\n\t\tLOGICALOP,\n\t\tMODIFIER,\n\t\tCLAUSE,\n\t\tCLAUSE_CLOSE,\n\t\tTERNARY,\n\t}\n\n\tfor _, kind := range kinds {\n\n\t\tkindString = kind.String()\n\n\t\tfor _, extantKind := range kindStrings {\n\t\t\tif extantKind == kindString {\n\t\t\t\ttest.Logf(\"Token kind test found duplicate string for token kind %v ('%v')\\n\", kind, kindString)\n\t\t\t\ttest.Fail()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tkindStrings = append(kindStrings, kindString)\n\t}\n}\n"
        },
        {
          "name": "tokenStream.go",
          "type": "blob",
          "size": 0.560546875,
          "content": "package govaluate\n\ntype tokenStream struct {\n\ttokens      []ExpressionToken\n\tindex       int\n\ttokenLength int\n}\n\nfunc newTokenStream(tokens []ExpressionToken) *tokenStream {\n\n\tvar ret *tokenStream\n\n\tret = new(tokenStream)\n\tret.tokens = tokens\n\tret.tokenLength = len(tokens)\n\treturn ret\n}\n\nfunc (this *tokenStream) rewind() {\n\tthis.index -= 1\n}\n\nfunc (this *tokenStream) next() ExpressionToken {\n\n\tvar token ExpressionToken\n\n\ttoken = this.tokens[this.index]\n\n\tthis.index += 1\n\treturn token\n}\n\nfunc (this tokenStream) hasNext() bool {\n\n\treturn this.index < this.tokenLength\n}\n"
        },
        {
          "name": "torture_test.go",
          "type": "blob",
          "size": 2.22265625,
          "content": "package govaluate\n\n/*\n\tCourtesy of abrander\n\tref: https://gist.github.com/abrander/fa05ae9b181b48ffe7afb12c961b6e90\n*/\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar (\n\thello  = \"hello\"\n\tempty  struct{}\n\tempty2 *string\n\tempty3 *int\n\n\tvalues = []interface{}{\n\t\t-1,\n\t\t0,\n\t\t12,\n\t\t13,\n\t\t\"\",\n\t\t\"hello\",\n\t\t&hello,\n\t\tnil,\n\t\t\"nil\",\n\t\tempty,\n\t\tempty2,\n\t\ttrue,\n\t\tfalse,\n\t\ttime.Now(),\n\t\trune('r'),\n\t\tint64(34),\n\t\ttime.Duration(0),\n\t\t\"true\",\n\t\t\"false\",\n\t\t\"\\ntrue\\n\",\n\t\t\"\\nfalse\\n\",\n\t\t\"12\",\n\t\t\"nil\",\n\t\t\"arg1\",\n\t\t\"arg2\",\n\t\tint(12),\n\t\tint32(12),\n\t\tint64(12),\n\t\tcomplex(1.0, 1.0),\n\t\t[]byte{0, 0, 0},\n\t\t[]int{0, 0, 0},\n\t\t[]string{},\n\t\t\"[]\",\n\t\t\"{}\",\n\t\t\"\\\"\\\"\",\n\t\t\"\\\"12\\\"\",\n\t\t\"\\\"hello\\\"\",\n\t\t\".*\",\n\t\t\"==\",\n\t\t\"!=\",\n\t\t\">\",\n\t\t\">=\",\n\t\t\"<\",\n\t\t\"<=\",\n\t\t\"=~\",\n\t\t\"!~\",\n\t\t\"in\",\n\t\t\"&&\",\n\t\t\"||\",\n\t\t\"^\",\n\t\t\"&\",\n\t\t\"|\",\n\t\t\">>\",\n\t\t\"<<\",\n\t\t\"+\",\n\t\t\"-\",\n\t\t\"*\",\n\t\t\"/\",\n\t\t\"%\",\n\t\t\"**\",\n\t\t\"-\",\n\t\t\"!\",\n\t\t\"~\",\n\t\t\"?\",\n\t\t\":\",\n\t\t\"??\",\n\t\t\"+\",\n\t\t\"-\",\n\t\t\"*\",\n\t\t\"/\",\n\t\t\"%\",\n\t\t\"**\",\n\t\t\"&\",\n\t\t\"|\",\n\t\t\"^\",\n\t\t\">>\",\n\t\t\"<<\",\n\t\t\",\",\n\t\t\"(\",\n\t\t\")\",\n\t\t\"[\",\n\t\t\"]\",\n\t\t\"\\n\",\n\t\t\"\\000\",\n\t}\n\n\tpanics = 0\n)\n\nconst (\n\tITERATIONS = 10000000\n\tSEED       = 1487873697990155515\n)\n\nfunc init() {\n\trand.Seed(SEED)\n}\n\nfunc TestPanics(test *testing.T) {\n\n\tif os.Getenv(\"GOVALUATE_TORTURE_TEST\") == \"\" {\n\t\ttest.Logf(\"'GOVALUATE_TORTURE_TEST' env var not set - skipping torture test.\")\n\t\ttest.Skip()\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Running %d torture test cases...\\n\", ITERATIONS)\n\n\tfor i := 0; i < ITERATIONS; i++ {\n\n\t\tnum := rand.Intn(3) + 2\n\t\texpression := \"\"\n\n\t\tfor n := 0; n < num; n++ {\n\t\t\texpression += fmt.Sprintf(\" %s\", getRandom(values))\n\t\t}\n\n\t\tcheckPanic(expression, test)\n\t}\n\n\ttest.Logf(\"Done. %d/%d panics.\\n\", panics, ITERATIONS)\n\tif panics > 0 {\n\t\ttest.Fail()\n\t}\n}\n\nfunc checkPanic(expression string, test *testing.T) {\n\n\tparameters := make(map[string]interface{})\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\ttest.Logf(\"Panic: \\\"%s\\\". Expression: \\\"%s\\\". Parameters: %+v\\n\", r, expression, parameters)\n\t\t\tpanics++\n\t\t}\n\t}()\n\n\teval, _ := NewEvaluableExpression(expression)\n\tif eval == nil {\n\t\treturn\n\t}\n\n\tvars := eval.Vars()\n\tfor _, v := range vars {\n\t\tparameters[v] = getRandom(values)\n\t}\n\n\teval.Evaluate(parameters)\n}\n\nfunc getRandom(haystack []interface{}) interface{} {\n\n\ti := rand.Intn(len(haystack))\n\treturn haystack[i]\n}\n"
        }
      ]
    }
  ]
}