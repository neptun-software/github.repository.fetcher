{
  "metadata": {
    "timestamp": 1736566845918,
    "page": 416,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "antonmedv/walk",
      "stars": 3319,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2021 Anton Medvedev\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.9423828125,
          "content": "# ðŸ¥¾ walk\n\n<p align=\"center\">\n  <br>\n  <img src=\".github/images/demo.gif\" width=\"600\" alt=\"walk demo\">\n  <br>\n</p>\n\n**Walk** â€” a terminal navigator.\n\nWhy another terminal navigator? I wanted something simple and minimalistic.\nSomething to help me with faster navigation in the filesystem; a `cd` and `ls`\nreplacement. So I build **walk**. It allows for quick navigation with fuzzy\nsearching, `cd` integration is quite simple. And you can open `vim` right from\nthe walk. That's it.\n\n## Install\n\n```\nbrew install walk\n```\n\n```\npkg_add walk\n```\n\n```\ngo install github.com/antonmedv/walk@latest\n```\n\nOr download [prebuild binaries](https://github.com/antonmedv/walk/releases).\n\nPut the next function into the **.bashrc** or a similar config:\n\n<table>\n<tr>\n  <th> Bash/Zsh </th>\n  <th> Fish </th>\n  <th> PowerShell </th>\n</tr>\n<tr>\n<td>\n\n```bash\nfunction lk {\n  cd \"$(walk \"$@\")\"\n}\n```\n\n</td>\n<td>\n\n```fish\nfunction lk\n  set loc (walk $argv); and cd $loc;\nend\n```\n\n</td>\n<td>\n\n```powershell\nfunction lk() {\n  cd $(walk $args)\n}\n```\n\n</td>\n</tr>\n</table>\n\n\nNow use `lk` command to start walking.\n\n### Preview mode\n\nPress `Space` to toggle preview mode.\n\n<img src=\".github/images/preview-mode.gif\" width=\"600\" alt=\"Walk Preview Mode\">\n\n### Delete file or directory\n\nPress `dd` to delete file or directory. Press `u` to undo.\n\n<img src=\".github/images/rm-demo.gif\" width=\"600\" alt=\"Walk Deletes a File\">\n\n### Display icons\n\nInstall [Nerd Fonts](https://www.nerdfonts.com) and add `--icons` flag.\n\n<img src=\".github/images/demo-icons.gif\" width=\"600\" alt=\"Walk Icons Support\">\n\n### Image preview\n\nNo additional setup is required.\n\n<img src=\".github/images/images-mode.gif\" width=\"600\" alt=\"Walk Image Preview\">\n\n## Usage\n\n| Key binding      | Description        |\n|------------------|--------------------|\n| `arrows`, `hjkl` | Move cursor        |\n| `shift+arrows`   | Jump to start/end  |\n| `enter`          | Enter directory    |\n| `backspace`      | Exit directory     |\n| `space`          | Toggle preview     |\n| `esc`, `q`       | Exit with cd       |\n| `ctrl+c`         | Exit without cd    |\n| `/`              | Fuzzy search       |\n| `d`, `delete`    | Delete file or dir |\n| `y`              | yank current dir   |\n| `.`              | Hide hidden files  |\n\n## Configuration\n\nThe `EDITOR` or `WALK_EDITOR` environment variable used for opening files from\nthe walk.\n\n```bash\nexport EDITOR=vim\n```\n\nThe `WALK_REMOVE_CMD` environment variable can be used to specify a command to\nbe used to remove files. This is useful if you want to use a different\ncommand to remove files than the default `rm`.\n\n```bash\nexport WALK_REMOVE_CMD=trash\n```\n\nFlags can be used to change the default behavior of the program.\n\n| Flag         | Description                |\n|--------------|----------------------------|\n| `--icons`    | Show icons                 |\n| `--dir-only` | Show dirs only             |\n| `--preview`  | Start with preview mode on |\n| `--fuzzy`    | Start with fuzzy search on |\n\n## License\n\n[MIT](LICENSE)\n"
        },
        {
          "name": "etc",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.2255859375,
          "content": "module github.com/antonmedv/walk\n\ngo 1.21\n\nrequire (\n\tgithub.com/antonmedv/clipboard v1.0.1\n\tgithub.com/charmbracelet/bubbles v0.18.0\n\tgithub.com/charmbracelet/bubbletea v0.26.5\n\tgithub.com/charmbracelet/lipgloss v0.11.0\n\tgithub.com/mattn/go-runewidth v0.0.15\n\tgithub.com/muesli/termenv v0.15.2\n\tgithub.com/nfnt/resize v0.0.0-20180221191011-83c6a9932646\n\tgithub.com/sahilm/fuzzy v0.1.1\n)\n\nrequire (\n\tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n\tgithub.com/charmbracelet/x/ansi v0.1.2 // indirect\n\tgithub.com/charmbracelet/x/input v0.1.2 // indirect\n\tgithub.com/charmbracelet/x/term v0.1.1 // indirect\n\tgithub.com/charmbracelet/x/windows v0.1.2 // indirect\n\tgithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-localereader v0.0.1 // indirect\n\tgithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect\n\tgithub.com/muesli/cancelreader v0.2.2 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgithub.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect\n\tgolang.org/x/sync v0.7.0 // indirect\n\tgolang.org/x/sys v0.21.0 // indirect\n\tgolang.org/x/text v0.16.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.9501953125,
          "content": "github.com/antonmedv/clipboard v1.0.1 h1:z9rRBhSKt4lDb6uNcMykUmNbspk/6v07JeiTaOfYYOY=\ngithub.com/antonmedv/clipboard v1.0.1/go.mod h1:3jcOUCdraVHehZaOsMaJZoE92MxURt5fovC1gDAiZ2s=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=\ngithub.com/charmbracelet/bubbles v0.18.0 h1:PYv1A036luoBGroX6VWjQIE9Syf2Wby2oOl/39KLfy0=\ngithub.com/charmbracelet/bubbles v0.18.0/go.mod h1:08qhZhtIwzgrtBjAcJnij1t1H0ZRjwHyGsy6AL11PSw=\ngithub.com/charmbracelet/bubbletea v0.26.5 h1:90pqTPElAReb/qQUgSMUresTkfwVr0Wx+zczeHHOgxk=\ngithub.com/charmbracelet/bubbletea v0.26.5/go.mod h1:dz8CWPlfCCGLFbBlTY4N7bjLiyOGDJEnd2Muu7pOWhk=\ngithub.com/charmbracelet/lipgloss v0.11.0 h1:UoAcbQ6Qml8hDwSWs0Y1cB5TEQuZkDPH/ZqwWWYTG4g=\ngithub.com/charmbracelet/lipgloss v0.11.0/go.mod h1:1UdRTH9gYgpcdNN5oBtjbu/IzNKtzVtb7sqN1t9LNn8=\ngithub.com/charmbracelet/x/ansi v0.1.2 h1:6+LR39uG8DE6zAmbu023YlqjJHkYXDF1z36ZwzO4xZY=\ngithub.com/charmbracelet/x/ansi v0.1.2/go.mod h1:dk73KoMTT5AX5BsX0KrqhsTqAnhZZoCBjs7dGWp4Ktw=\ngithub.com/charmbracelet/x/input v0.1.2 h1:QJAZr33eOhDowkkEQ24rsJy4Llxlm+fRDf/cQrmqJa0=\ngithub.com/charmbracelet/x/input v0.1.2/go.mod h1:LGBim0maUY4Pitjn/4fHnuXb4KirU3DODsyuHuXdOyA=\ngithub.com/charmbracelet/x/term v0.1.1 h1:3cosVAiPOig+EV4X9U+3LDgtwwAoEzJjNdwbXDjF6yI=\ngithub.com/charmbracelet/x/term v0.1.1/go.mod h1:wB1fHt5ECsu3mXYusyzcngVWWlu1KKUmmLhfgr/Flxw=\ngithub.com/charmbracelet/x/windows v0.1.2 h1:Iumiwq2G+BRmgoayww/qfcvof7W/3uLoelhxojXlRWg=\ngithub.com/charmbracelet/x/windows v0.1.2/go.mod h1:GLEO/l+lizvFDBPLIOk+49gdX49L9YWMB5t+DZd0jkQ=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=\ngithub.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=\ngithub.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=\ngithub.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=\ngithub.com/muesli/termenv v0.15.2 h1:GohcuySI0QmI3wN8Ok9PtKGkgkFIk7y6Vpb5PvrY+Wo=\ngithub.com/muesli/termenv v0.15.2/go.mod h1:Epx+iuz8sNs7mNKhxzH4fWXGNpZwUaJKRS1noLXviQ8=\ngithub.com/nfnt/resize v0.0.0-20180221191011-83c6a9932646 h1:zYyBkD/k9seD2A7fsi6Oo2LfFZAehjjQMERAvZLEDnQ=\ngithub.com/nfnt/resize v0.0.0-20180221191011-83c6a9932646/go.mod h1:jpp1/29i3P1S/RLdc7JQKbRpFeM1dOBd8T9ki5s+AY8=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/sahilm/fuzzy v0.1.1 h1:ceu5RHF8DGgoi+/dR5PsECjCDH1BE3Fnmpo7aVXOdRA=\ngithub.com/sahilm/fuzzy v0.1.1/go.mod h1:VFvziUEIMCrT6A6tw2RFIXPXXmzXbOsSHF0DOI8ZK9Y=\ngithub.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=\ngithub.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=\ngolang.org/x/exp v0.0.0-20220909182711-5c715a9e8561 h1:MDc5xs78ZrZr3HMQugiXOAkSZtfTpbJLDr/lwfgO53E=\ngolang.org/x/exp v0.0.0-20220909182711-5c715a9e8561/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=\ngolang.org/x/sync v0.7.0 h1:YsImfSBoP9QPYL0xyKJPq0gcaJdG3rInoqxTWbfQu9M=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.21.0 h1:rF+pYz3DAGSQAxAu1CbC7catZg4ebC4UIeIhKxBZvws=\ngolang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.16.0 h1:a94ExnEXNtEwYLGJSIUxnWoxoRz/ZcCsV63ROupILh4=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\n"
        },
        {
          "name": "icons.go",
          "type": "blob",
          "size": 3.3583984375,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"embed\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"unicode\"\n)\n\ntype iconMap map[string]string\n\nvar icons iconMap\n\nfunc parseIcons() {\n\ticons = make(iconMap)\n\ticons.parse()\n}\n\n//go:embed etc/icons\nvar f embed.FS\n\nfunc (im iconMap) parse() {\n\ticons, _ := f.Open(\"etc/icons\")\n\tpairs, err := readPairs(icons)\n\tif err != nil {\n\t\tlog.Printf(\"reading icons file: %s\", err)\n\t\treturn\n\t}\n\tfor _, pair := range pairs {\n\t\tkey, val := pair[0], pair[1]\n\t\tkey = replaceTilde(key)\n\t\tif filepath.IsAbs(key) {\n\t\t\tkey = filepath.Clean(key)\n\t\t}\n\t\tim[key] = val\n\t}\n}\n\nfunc (im iconMap) getIcon(f os.FileInfo) string {\n\tif f.IsDir() {\n\t\tif val, ok := im[f.Name()+\"/\"]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\tvar key string\n\tswitch {\n\tcase f.IsDir() && f.Mode()&os.ModeSticky != 0 && f.Mode()&0002 != 0:\n\t\tkey = \"tw\"\n\tcase f.IsDir() && f.Mode()&0002 != 0:\n\t\tkey = \"ow\"\n\tcase f.IsDir() && f.Mode()&os.ModeSticky != 0:\n\t\tkey = \"st\"\n\tcase f.IsDir():\n\t\tkey = \"di\"\n\tcase f.Mode()&os.ModeNamedPipe != 0:\n\t\tkey = \"pi\"\n\tcase f.Mode()&os.ModeSocket != 0:\n\t\tkey = \"so\"\n\tcase f.Mode()&os.ModeDevice != 0:\n\t\tkey = \"bd\"\n\tcase f.Mode()&os.ModeCharDevice != 0:\n\t\tkey = \"cd\"\n\tcase f.Mode()&os.ModeSetuid != 0:\n\t\tkey = \"su\"\n\tcase f.Mode()&os.ModeSetgid != 0:\n\t\tkey = \"sg\"\n\t}\n\tif val, ok := im[key]; ok {\n\t\treturn val\n\t}\n\tif val, ok := im[f.Name()+\"*\"]; ok {\n\t\treturn val\n\t}\n\tif val, ok := im[\"*\"+f.Name()]; ok {\n\t\treturn val\n\t}\n\tif val, ok := im[filepath.Base(f.Name())+\".*\"]; ok {\n\t\treturn val\n\t}\n\text := filepath.Ext(f.Name())\n\tif val, ok := im[\"*\"+strings.ToLower(ext)]; ok {\n\t\treturn val\n\t}\n\tif f.Mode()&0111 != 0 {\n\t\tif val, ok := im[\"ex\"]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\tif val, ok := im[\"fi\"]; ok {\n\t\treturn val\n\t}\n\treturn \" \"\n}\n\nfunc replaceTilde(s string) string {\n\tu, err := user.Current()\n\tif err != nil {\n\t\tlog.Printf(\"user: %s\", err)\n\t}\n\tif strings.HasPrefix(s, \"~\") {\n\t\ts = strings.Replace(s, \"~\", u.HomeDir, 1)\n\t}\n\treturn s\n}\n\n// This function reads whitespace separated string pairs at each line. Single\n// or double quotes can be used to escape whitespaces. Hash characters can be\n// used to add a comment until the end of line. Leading and trailing space is\n// trimmed. Empty lines are skipped.\nfunc readPairs(r io.Reader) ([][]string, error) {\n\tvar pairs [][]string\n\ts := bufio.NewScanner(r)\n\tfor s.Scan() {\n\t\tline := s.Text()\n\n\t\tsquote, dquote := false, false\n\t\tfor i := 0; i < len(line); i++ {\n\t\t\tif line[i] == '\\'' && !dquote {\n\t\t\t\tsquote = !squote\n\t\t\t} else if line[i] == '\"' && !squote {\n\t\t\t\tdquote = !dquote\n\t\t\t}\n\t\t\tif !squote && !dquote && line[i] == '#' {\n\t\t\t\tline = line[:i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tline = strings.TrimSpace(line)\n\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsquote, dquote = false, false\n\t\tpair := strings.FieldsFunc(line, func(r rune) bool {\n\t\t\tif r == '\\'' && !dquote {\n\t\t\t\tsquote = !squote\n\t\t\t} else if r == '\"' && !squote {\n\t\t\t\tdquote = !dquote\n\t\t\t}\n\t\t\treturn !squote && !dquote && unicode.IsSpace(r)\n\t\t})\n\n\t\tif len(pair) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"expected pair but found: %s\", s.Text())\n\t\t}\n\n\t\tfor i := 0; i < len(pair); i++ {\n\t\t\tsquote, dquote = false, false\n\t\t\tbuf := make([]rune, 0, len(pair[i]))\n\t\t\tfor _, r := range pair[i] {\n\t\t\t\tif r == '\\'' && !dquote {\n\t\t\t\t\tsquote = !squote\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif r == '\"' && !squote {\n\t\t\t\t\tdquote = !dquote\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbuf = append(buf, r)\n\t\t\t}\n\t\t\tpair[i] = string(buf)\n\t\t}\n\n\t\tpairs = append(pairs, pair)\n\t}\n\n\treturn pairs, nil\n}\n"
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 1.3388671875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image\"\n\t_ \"image/gif\"\n\t_ \"image/jpeg\"\n\t_ \"image/png\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/nfnt/resize\"\n)\n\nfunc isImageExt(filePath string) bool {\n\text := filepath.Ext(filePath)\n\treturn ext == \".png\" || ext == \".jpg\" || ext == \".jpeg\" || ext == \".gif\"\n}\n\nfunc drawImage(path string, width, height int) (string, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\timg, _, err := image.Decode(file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\timg = resize.Resize(uint(width), uint(height)*2, img, resize.Lanczos3)\n\tbounds := img.Bounds()\n\n\tvar buffer bytes.Buffer\n\tfor y := bounds.Min.Y + 1; y < bounds.Max.Y-1; y += 2 {\n\t\tfor x := bounds.Min.X + 1; x < bounds.Max.X-1; x++ {\n\t\t\tr1, g1, b1, a1 := img.At(x, y).RGBA()\n\t\t\tr2, g2, b2, a2 := img.At(x, y+1).RGBA()\n\n\t\t\t// If both pixels are transparent, print a space.\n\t\t\tif a1 < 6553 && a2 < 6553 {\n\t\t\t\tbuffer.WriteString(\" \")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcolorStr1 := fmt.Sprintf(\"#%02X%02X%02X\", r1>>8, g1>>8, b1>>8)\n\t\t\tcolorStr2 := fmt.Sprintf(\"#%02X%02X%02X\", r2>>8, g2>>8, b2>>8)\n\n\t\t\tblock := lipgloss.NewStyle().\n\t\t\t\tForeground(lipgloss.Color(colorStr1)).\n\t\t\t\tBackground(lipgloss.Color(colorStr2)).\n\t\t\t\tRender(\"â–„\")\n\n\t\t\tbuffer.WriteString(block)\n\t\t}\n\t\tbuffer.WriteString(\"\\n\")\n\t}\n\treturn buffer.String(), nil\n}\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 24.8173828125,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"math\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t. \"strings\"\n\t\"sync\"\n\t\"text/tabwriter\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"github.com/antonmedv/clipboard\"\n\t\"github.com/charmbracelet/bubbles/key\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/mattn/go-runewidth\"\n\t\"github.com/muesli/termenv\"\n\t\"github.com/sahilm/fuzzy\"\n)\n\nvar Version = \"v1.10.0\"\n\nconst separator = \"    \" // Separator between columns.\n\nvar (\n\tbold             = lipgloss.NewStyle().Bold(true)\n\twarning          = lipgloss.NewStyle().Border(lipgloss.RoundedBorder()).PaddingLeft(1).PaddingRight(1)\n\tpreview          = lipgloss.NewStyle().PaddingLeft(2)\n\tcursor           = lipgloss.NewStyle().Background(lipgloss.Color(\"#825DF2\")).Foreground(lipgloss.Color(\"#FFFFFF\"))\n\tbar              = lipgloss.NewStyle().Background(lipgloss.Color(\"#5C5C5C\")).Foreground(lipgloss.Color(\"#FFFFFF\"))\n\tsearch           = lipgloss.NewStyle().Background(lipgloss.Color(\"#499F1C\")).Foreground(lipgloss.Color(\"#FFFFFF\"))\n\tdanger           = lipgloss.NewStyle().Background(lipgloss.Color(\"#FF0000\")).Foreground(lipgloss.Color(\"#FFFFFF\"))\n\tfileSeparator    = string(filepath.Separator)\n\tshowIcons        = false\n\tdirOnly          = false\n\tstartPreviewMode = false\n\tfuzzyByDefault   = false\n\tstrlen           = runewidth.StringWidth\n)\n\nvar (\n\tkeyForceQuit = key.NewBinding(key.WithKeys(\"ctrl+c\"))\n\tkeyQuit      = key.NewBinding(key.WithKeys(\"esc\"))\n\tkeyQuitQ     = key.NewBinding(key.WithKeys(\"q\"))\n\tkeyOpen      = key.NewBinding(key.WithKeys(\"enter\"))\n\tkeyBack      = key.NewBinding(key.WithKeys(\"backspace\"))\n\tkeyFnDelete  = key.NewBinding(key.WithKeys(\"delete\"))\n\tkeyUp        = key.NewBinding(key.WithKeys(\"up\"))\n\tkeyDown      = key.NewBinding(key.WithKeys(\"down\"))\n\tkeyLeft      = key.NewBinding(key.WithKeys(\"left\"))\n\tkeyRight     = key.NewBinding(key.WithKeys(\"right\"))\n\tkeyTop       = key.NewBinding(key.WithKeys(\"shift+up\"))\n\tkeyBottom    = key.NewBinding(key.WithKeys(\"shift+down\"))\n\tkeyLeftmost  = key.NewBinding(key.WithKeys(\"shift+left\"))\n\tkeyRightmost = key.NewBinding(key.WithKeys(\"shift+right\"))\n\tkeyPageUp    = key.NewBinding(key.WithKeys(\"pgup\"))\n\tkeyPageDown  = key.NewBinding(key.WithKeys(\"pgdown\"))\n\tkeyHome      = key.NewBinding(key.WithKeys(\"home\"))\n\tkeyEnd       = key.NewBinding(key.WithKeys(\"end\"))\n\tkeyVimUp     = key.NewBinding(key.WithKeys(\"k\"))\n\tkeyVimDown   = key.NewBinding(key.WithKeys(\"j\"))\n\tkeyVimLeft   = key.NewBinding(key.WithKeys(\"h\"))\n\tkeyVimRight  = key.NewBinding(key.WithKeys(\"l\"))\n\tkeyVimTop    = key.NewBinding(key.WithKeys(\"g\"))\n\tkeyVimBottom = key.NewBinding(key.WithKeys(\"G\"))\n\tkeySearch    = key.NewBinding(key.WithKeys(\"/\"))\n\tkeyPreview   = key.NewBinding(key.WithKeys(\" \"))\n\tkeyDelete    = key.NewBinding(key.WithKeys(\"d\"))\n\tkeyUndo      = key.NewBinding(key.WithKeys(\"u\"))\n\tkeyYank      = key.NewBinding(key.WithKeys(\"y\"))\n\tkeyHidden    = key.NewBinding(key.WithKeys(\".\"))\n)\n\nfunc main() {\n\tgo emitCO2(time.Second)\n\n\tstartPath, err := os.Getwd()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\targsWithoutFlags := make([]string, 0)\n\tfor i := 1; i < len(os.Args); i++ {\n\t\tif os.Args[i] == \"--help\" || os.Args[1] == \"-h\" {\n\t\t\tusage()\n\t\t}\n\t\tif os.Args[i] == \"--version\" || os.Args[1] == \"-v\" {\n\t\t\tversion()\n\t\t}\n\t\tif os.Args[i] == \"--icons\" {\n\t\t\tshowIcons = true\n\t\t\tparseIcons()\n\t\t\tcontinue\n\t\t}\n\t\tif os.Args[i] == \"--dir-only\" {\n\t\t\tdirOnly = true\n\t\t\tcontinue\n\t\t}\n\t\tif os.Args[i] == \"--preview\" {\n\t\t\tstartPreviewMode = true\n\t\t\tcontinue\n\t\t}\n\t\tif os.Args[i] == \"--fuzzy\" {\n\t\t\tfuzzyByDefault = true\n\t\t\tcontinue\n\t\t}\n\t\targsWithoutFlags = append(argsWithoutFlags, os.Args[i])\n\t}\n\n\tif len(argsWithoutFlags) > 0 {\n\t\tstartPath, err = filepath.Abs(argsWithoutFlags[0])\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\toutput := termenv.NewOutput(os.Stderr)\n\tlipgloss.SetColorProfile(output.ColorProfile())\n\n\tm := &model{\n\t\tpath:        startPath,\n\t\twidth:       80,\n\t\theight:      60,\n\t\tpositions:   make(map[string]position),\n\t\tpreviewMode: startPreviewMode,\n\t}\n\tm.list()\n\n\tp := tea.NewProgram(m, tea.WithOutput(os.Stderr))\n\tif _, err := p.Run(); err != nil {\n\t\tpanic(err)\n\t}\n\tos.Exit(m.exitCode)\n}\n\ntype model struct {\n\tpath              string              // Current dir path we are looking at.\n\tfiles             []fs.DirEntry       // Files we are looking at.\n\terr               error               // Error while listing files.\n\tc, r              int                 // Selector position in columns and rows.\n\tcolumns, rows     int                 // Displayed amount of rows and columns.\n\twidth, height     int                 // Terminal size.\n\toffset            int                 // Scroll position.\n\tpositions         map[string]position // Map of cursor positions per path.\n\tsearch            string              // Type to select files with this value.\n\tsearchMode        bool                // Whether type-to-select is active.\n\tsearchId          int                 // Search id to indicate what search we are currently on.\n\tmatchedIndexes    []int               // List of char found indexes.\n\tprevName          string              // Base name of previous directory before \"up\".\n\tfindPrevName      bool                // On View(), set c&r to point to prevName.\n\texitCode          int                 // Exit code.\n\tpreviewMode       bool                // Whether preview is active.\n\tpreviewContent    string              // Content of preview.\n\tdeleteCurrentFile bool                // Whether to delete current file.\n\ttoBeDeleted       []toDelete          // Map of files to be deleted.\n\tyankSuccess       bool                // Show yank info\n\thideHidden        bool                // Hide hidden files\n}\n\ntype position struct {\n\tc, r   int\n\toffset int\n}\n\ntype toDelete struct {\n\tpath string\n\tat   time.Time\n}\n\ntype (\n\tclearSearchMsg int\n\ttoBeDeletedMsg int\n)\n\nfunc (m *model) Init() tea.Cmd {\n\treturn nil\n}\n\nfunc (m *model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.WindowSizeMsg:\n\t\tm.width = msg.Width\n\t\tm.height = msg.Height\n\t\tif m.height < 3 {\n\t\t\tm.height = 3\n\t\t}\n\t\t// Reset position history as c&r changes.\n\t\tm.positions = make(map[string]position)\n\t\t// Keep cursor at same place.\n\t\tfileName, ok := m.fileName()\n\t\tif ok {\n\t\t\tm.prevName = fileName\n\t\t\tm.findPrevName = true\n\t\t}\n\t\t// Also, m.c&r no longer point to the correct indexes.\n\t\tm.c = 0\n\t\tm.r = 0\n\t\treturn m, nil\n\n\tcase tea.KeyMsg:\n\t\t// Make undo work even if we are in fuzzy mode.\n\t\tif key.Matches(msg, keyUndo) && len(m.toBeDeleted) > 0 {\n\t\t\tm.toBeDeleted = m.toBeDeleted[:len(m.toBeDeleted)-1]\n\t\t\tm.list()\n\t\t\tm.previewContent = \"\"\n\t\t\treturn m, nil\n\t\t}\n\n\t\tif fuzzyByDefault {\n\t\t\tif key.Matches(msg, keyBack) {\n\t\t\t\tif len(m.search) > 0 {\n\t\t\t\t\tm.search = m.search[:strlen(m.search)-1]\n\t\t\t\t\treturn m, nil\n\t\t\t\t}\n\t\t\t} else if msg.Type == tea.KeyRunes {\n\t\t\t\tm.updateSearch(msg)\n\t\t\t\t// Save search id to clear only current search after delay.\n\t\t\t\t// User may have already started typing next search.\n\t\t\t\tm.searchId++\n\t\t\t\tsearchId := m.searchId\n\t\t\t\treturn m, tea.Tick(2*time.Second, func(time.Time) tea.Msg {\n\t\t\t\t\treturn clearSearchMsg(searchId)\n\t\t\t\t})\n\t\t\t}\n\t\t} else if m.searchMode {\n\t\t\tif key.Matches(msg, keySearch) {\n\t\t\t\tm.searchMode = false\n\t\t\t\treturn m, nil\n\t\t\t} else if key.Matches(msg, keyBack) {\n\t\t\t\tif len(m.search) > 0 {\n\t\t\t\t\tm.search = m.search[:strlen(m.search)-1]\n\t\t\t\t} else {\n\t\t\t\t\tm.searchMode = false\n\t\t\t\t}\n\t\t\t\treturn m, nil\n\t\t\t} else if msg.Type == tea.KeyRunes {\n\t\t\t\tm.updateSearch(msg)\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t}\n\n\t\tswitch {\n\t\tcase key.Matches(msg, keyForceQuit):\n\t\t\t_, _ = fmt.Fprintln(os.Stderr) // Keep last item visible after prompt.\n\t\t\tm.exitCode = 2\n\t\t\tm.dontDoPendingDeletions()\n\t\t\treturn m, tea.Quit\n\n\t\tcase key.Matches(msg, keyQuit, keyQuitQ):\n\t\t\t_, _ = fmt.Fprintln(os.Stderr) // Keep last item visible after prompt.\n\t\t\tfmt.Println(m.path)            // Write to cd.\n\t\t\tm.exitCode = 0\n\t\t\tm.performPendingDeletions()\n\t\t\treturn m, tea.Quit\n\n\t\tcase key.Matches(msg, keyOpen):\n\t\t\tm.search = \"\"\n\t\t\tm.searchMode = false\n\t\t\tfilePath, ok := m.filePath()\n\t\t\tif !ok {\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t\tif fi := fileInfo(filePath); fi.IsDir() {\n\t\t\t\t// Enter subdirectory.\n\t\t\t\tm.path = filePath\n\t\t\t\tif p, ok := m.positions[m.path]; ok {\n\t\t\t\t\tm.c = p.c\n\t\t\t\t\tm.r = p.r\n\t\t\t\t\tm.offset = p.offset\n\t\t\t\t} else {\n\t\t\t\t\tm.c = 0\n\t\t\t\t\tm.r = 0\n\t\t\t\t\tm.offset = 0\n\t\t\t\t}\n\t\t\t\tm.list()\n\t\t\t} else {\n\t\t\t\t// Open file. This will block until complete.\n\t\t\t\treturn m, m.openEditor()\n\t\t\t}\n\n\t\tcase key.Matches(msg, keyBack):\n\t\t\tm.search = \"\"\n\t\t\tm.searchMode = false\n\t\t\tm.prevName = filepath.Base(m.path)\n\t\t\tm.path = filepath.Join(m.path, \"..\")\n\t\t\tif p, ok := m.positions[m.path]; ok {\n\t\t\t\tm.c = p.c\n\t\t\t\tm.r = p.r\n\t\t\t\tm.offset = p.offset\n\t\t\t} else {\n\t\t\t\tm.findPrevName = true\n\t\t\t}\n\t\t\tm.list()\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, keyUp):\n\t\t\tm.moveUp()\n\n\t\tcase key.Matches(msg, keyTop, keyPageUp, keyVimTop):\n\t\t\tm.moveTop()\n\n\t\tcase key.Matches(msg, keyBottom, keyPageDown, keyVimBottom):\n\t\t\tm.moveBottom()\n\n\t\tcase key.Matches(msg, keyLeftmost):\n\t\t\tm.moveLeftmost()\n\n\t\tcase key.Matches(msg, keyRightmost):\n\t\t\tm.moveRightmost()\n\n\t\tcase key.Matches(msg, keyHome):\n\t\t\tm.moveStart()\n\n\t\tcase key.Matches(msg, keyEnd):\n\t\t\tm.moveEnd()\n\n\t\tcase key.Matches(msg, keyVimUp):\n\t\t\tm.moveUp()\n\n\t\tcase key.Matches(msg, keyDown):\n\t\t\tm.moveDown()\n\n\t\tcase key.Matches(msg, keyVimDown):\n\t\t\tm.moveDown()\n\n\t\tcase key.Matches(msg, keyLeft):\n\t\t\tm.moveLeft()\n\n\t\tcase key.Matches(msg, keyVimLeft):\n\t\t\tm.moveLeft()\n\n\t\tcase key.Matches(msg, keyRight):\n\t\t\tm.moveRight()\n\n\t\tcase key.Matches(msg, keyVimRight):\n\t\t\tm.moveRight()\n\n\t\tcase key.Matches(msg, keySearch):\n\t\t\tm.searchMode = true\n\t\t\tm.searchId++\n\t\t\tm.search = \"\"\n\n\t\tcase key.Matches(msg, keyPreview):\n\t\t\tm.previewMode = !m.previewMode\n\t\t\t// Reset position history as c&r changes.\n\t\t\tm.positions = make(map[string]position)\n\t\t\t// Keep cursor at same place.\n\t\t\tfileName, ok := m.fileName()\n\t\t\tif !ok {\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t\tm.prevName = fileName\n\t\t\tm.findPrevName = true\n\n\t\t\tif m.previewMode {\n\t\t\t\treturn m, tea.EnterAltScreen\n\t\t\t} else {\n\t\t\t\tm.previewContent = \"\"\n\t\t\t\treturn m, tea.ExitAltScreen\n\t\t\t}\n\n\t\tcase key.Matches(msg, keyDelete, keyFnDelete):\n\t\t\tfilePathToDelete, ok := m.filePath()\n\t\t\tif ok {\n\t\t\t\tif m.deleteCurrentFile {\n\t\t\t\t\tm.deleteCurrentFile = false\n\t\t\t\t\tm.toBeDeleted = append(m.toBeDeleted, toDelete{\n\t\t\t\t\t\tpath: filePathToDelete,\n\t\t\t\t\t\tat:   time.Now().Add(6 * time.Second),\n\t\t\t\t\t})\n\t\t\t\t\tm.list()\n\t\t\t\t\tm.previewContent = \"\"\n\t\t\t\t\treturn m, tea.Tick(time.Second, func(time.Time) tea.Msg {\n\t\t\t\t\t\treturn toBeDeletedMsg(0)\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tm.deleteCurrentFile = true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, keyYank):\n\t\t\t// copy path to clipboard\n\t\t\tclipboard.WriteAll(m.path)\n\t\t\tm.yankSuccess = true\n\t\t\treturn m, nil\n\n\t\tcase key.Matches(msg, keyHidden):\n\t\t\tm.hideHidden = !m.hideHidden\n\t\t\tm.list()\n\t\t} // End of switch statement for key presses.\n\n\t\tm.deleteCurrentFile = false\n\t\tm.yankSuccess = false\n\t\tm.updateOffset()\n\t\tm.saveCursorPosition()\n\n\tcase clearSearchMsg:\n\t\tif m.searchId == int(msg) {\n\t\t\tm.search = \"\"\n\t\t\tm.searchMode = false\n\t\t}\n\n\tcase toBeDeletedMsg:\n\t\ttoBeDeleted := make([]toDelete, 0)\n\t\tfor _, td := range m.toBeDeleted {\n\t\t\tif td.at.After(time.Now()) {\n\t\t\t\ttoBeDeleted = append(toBeDeleted, td)\n\t\t\t} else {\n\t\t\t\tremove(td.path)\n\t\t\t}\n\t\t}\n\t\tm.toBeDeleted = toBeDeleted\n\t\tif len(m.toBeDeleted) > 0 {\n\t\t\treturn m, tea.Tick(time.Second, func(time.Time) tea.Msg {\n\t\t\t\treturn toBeDeletedMsg(0)\n\t\t\t})\n\t\t}\n\t}\n\n\treturn m, nil\n}\n\nfunc (m *model) updateSearch(msg tea.KeyMsg) {\n\tm.search += string(msg.Runes)\n\tnames := make([]string, len(m.files))\n\tfor i, fi := range m.files {\n\t\tnames[i] = fi.Name()\n\t}\n\tmatches := fuzzy.Find(m.search, names)\n\tif len(matches) > 0 {\n\t\tm.matchedIndexes = matches[0].MatchedIndexes\n\t\tindex := matches[0].Index\n\t\tm.c = index / m.rows\n\t\tm.r = index % m.rows\n\t}\n\tm.updateOffset()\n\tm.saveCursorPosition()\n}\n\nfunc (m *model) View() string {\n\twidth := m.width\n\tif m.previewMode {\n\t\twidth = m.width / 2\n\t}\n\theight := m.listHeight()\n\n\tvar names [][]string\n\tnames, m.rows, m.columns = wrap(m.files, width, height, func(name string, i, j int) {\n\t\tif m.findPrevName && m.prevName == name {\n\t\t\tm.c = i\n\t\t\tm.r = j\n\t\t}\n\t})\n\n\t// If we need to select previous directory on \"up\".\n\tif m.findPrevName {\n\t\tm.findPrevName = false\n\t\tm.updateOffset()\n\t\tm.saveCursorPosition()\n\t}\n\n\t// After we have updated offset and saved cursor position, we can\n\t// preview currently selected file.\n\tm.preview()\n\n\t// Get output rows width before coloring.\n\toutputWidth := strlen(path.Base(m.path)) // Use current dir name as default.\n\tif m.previewMode {\n\t\trow := make([]string, m.columns)\n\t\tfor i := 0; i < m.columns; i++ {\n\t\t\tif len(names[i]) > 0 {\n\t\t\t\trow[i] = names[i][0]\n\t\t\t} else {\n\t\t\t\toutputWidth = width\n\t\t\t}\n\t\t}\n\t\toutputWidth = max(outputWidth, strlen(Join(row, separator)))\n\t} else {\n\t\toutputWidth = width\n\t}\n\n\t// Let's add colors to file names.\n\toutput := make([]string, m.rows)\n\tfor j := 0; j < m.rows; j++ {\n\t\trow := make([]string, m.columns)\n\t\tfor i := 0; i < m.columns; i++ {\n\t\t\tif i == m.c && j == m.r {\n\t\t\t\tif m.deleteCurrentFile {\n\t\t\t\t\trow[i] = danger.Render(names[i][j])\n\t\t\t\t} else {\n\t\t\t\t\trow[i] = cursor.Render(names[i][j])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trow[i] = names[i][j]\n\t\t\t}\n\t\t}\n\t\toutput[j] = Join(row, separator)\n\t}\n\n\tif len(output) >= m.offset+height {\n\t\toutput = output[m.offset : m.offset+height]\n\t}\n\n\t// Preview pane.\n\tfileName, _ := m.fileName()\n\tpreviewPane := bar.Render(fileName) + \"\\n\"\n\tpreviewPane += m.previewContent\n\n\t// Location bar (grey).\n\tlocation := m.path\n\tif userHomeDir, err := os.UserHomeDir(); err == nil {\n\t\tlocation = Replace(m.path, userHomeDir, \"~\", 1)\n\t}\n\tif runtime.GOOS == \"windows\" {\n\t\tlocation = ReplaceAll(Replace(location, \"\\\\/\", fileSeparator, 1), \"/\", fileSeparator)\n\t}\n\n\t// Filter bar (green).\n\tfilter := \"\"\n\tif m.searchMode || fuzzyByDefault {\n\t\tfilter = fileSeparator + m.search\n\n\t\t// If fuzzy is on and search is empty, don't show filter.\n\t\tif fuzzyByDefault && m.search == \"\" {\n\t\t\tfilter = \"\"\n\t\t}\n\t}\n\tbarLen := strlen(location) + strlen(filter)\n\tif barLen > outputWidth {\n\t\tlocation = location[min(barLen-outputWidth, strlen(location)):]\n\t}\n\tbarStr := bar.Render(location) + search.Render(filter)\n\n\tmain := barStr + \"\\n\" + Join(output, \"\\n\")\n\n\tif m.err != nil {\n\t\tmain = barStr + \"\\n\" + warning.Render(m.err.Error())\n\t} else if len(m.files) == 0 {\n\t\tmain = barStr + \"\\n\" + warning.Render(\"No files\")\n\t}\n\n\t// Delete bar.\n\tif len(m.toBeDeleted) > 0 {\n\t\ttoDelete := m.toBeDeleted[len(m.toBeDeleted)-1]\n\t\ttimeLeft := int(toDelete.at.Sub(time.Now()).Seconds())\n\t\tdeleteBar := fmt.Sprintf(\"%v deleted. (u)ndo %v\", path.Base(toDelete.path), timeLeft)\n\t\tmain += \"\\n\" + danger.Render(deleteBar)\n\t}\n\n\t// Yank success.\n\tif m.yankSuccess {\n\t\tyankBar := fmt.Sprintf(\"yanked path to clipboard: %v\", m.path)\n\t\tmain += \"\\n\" + bar.Render(yankBar)\n\t}\n\n\tif m.previewMode {\n\t\treturn lipgloss.JoinHorizontal(\n\t\t\tlipgloss.Top,\n\t\t\tmain,\n\t\t\tpreview.\n\t\t\t\tMaxHeight(m.height).\n\t\t\t\tRender(previewPane),\n\t\t)\n\t} else {\n\t\treturn main\n\t}\n}\n\nfunc (m *model) moveUp() {\n\tm.r--\n\tif m.r < 0 {\n\t\tm.r = m.rows - 1\n\t\tm.c--\n\t}\n\tif m.c < 0 {\n\t\tm.r = m.rows - 1 - (m.columns*m.rows - len(m.files))\n\t\tm.c = m.columns - 1\n\t}\n}\n\nfunc (m *model) moveDown() {\n\tm.r++\n\tif m.r >= m.rows {\n\t\tm.r = 0\n\t\tm.c++\n\t}\n\tif m.c >= m.columns {\n\t\tm.c = 0\n\t}\n\tif m.c == m.columns-1 && (m.columns-1)*m.rows+m.r >= len(m.files) {\n\t\tm.r = 0\n\t\tm.c = 0\n\t}\n}\n\nfunc (m *model) moveLeft() {\n\tm.c--\n\tif m.c < 0 {\n\t\tm.c = m.columns - 1\n\t}\n\tif m.c == m.columns-1 && (m.columns-1)*m.rows+m.r >= len(m.files) {\n\t\tm.r = m.rows - 1 - (m.columns*m.rows - len(m.files))\n\t\tm.c = m.columns - 1\n\t}\n}\n\nfunc (m *model) moveRight() {\n\tm.c++\n\tif m.c >= m.columns {\n\t\tm.c = 0\n\t}\n\tif m.c == m.columns-1 && (m.columns-1)*m.rows+m.r >= len(m.files) {\n\t\tm.r = m.rows - 1 - (m.columns*m.rows - len(m.files))\n\t\tm.c = m.columns - 1\n\t}\n}\n\nfunc (m *model) moveTop() {\n\tm.r = 0\n}\n\nfunc (m *model) moveBottom() {\n\tm.r = m.rows - 1\n\tif m.c == m.columns-1 && (m.columns-1)*m.rows+m.r >= len(m.files) {\n\t\tm.r = m.rows - 1 - (m.columns*m.rows - len(m.files))\n\t}\n}\n\nfunc (m *model) moveLeftmost() {\n\tm.c = 0\n}\n\nfunc (m *model) moveRightmost() {\n\tm.c = m.columns - 1\n\tif (m.columns-1)*m.rows+m.r >= len(m.files) {\n\t\tm.r = m.rows - 1 - (m.columns*m.rows - len(m.files))\n\t}\n}\n\nfunc (m *model) moveStart() {\n\tm.moveLeftmost()\n\tm.moveTop()\n}\n\nfunc (m *model) moveEnd() {\n\tm.moveRightmost()\n\tm.moveBottom()\n}\n\nfunc (m *model) list() {\n\tvar err error\n\tm.files = nil\n\n\t// ReadDir already returns files and dirs sorted by filename.\n\tfiles, err := os.ReadDir(m.path)\n\tif err != nil {\n\t\tm.err = err\n\t\treturn\n\t} else {\n\t\tm.err = nil\n\t}\n\nfiles:\n\tfor _, file := range files {\n\t\tif m.hideHidden && HasPrefix(file.Name(), \".\") {\n\t\t\tcontinue files\n\t\t}\n\t\tif dirOnly && !file.IsDir() {\n\t\t\tcontinue files\n\t\t}\n\t\tfor _, toDelete := range m.toBeDeleted {\n\t\t\tif path.Join(m.path, file.Name()) == toDelete.path {\n\t\t\t\tcontinue files\n\t\t\t}\n\t\t}\n\t\tm.files = append(m.files, file)\n\t}\n}\n\nfunc (m *model) listHeight() int {\n\th := m.height - 1 // Subtract 1 for location bar.\n\tif len(m.toBeDeleted) > 0 {\n\t\th-- // Subtract 1 for delete bar.\n\t}\n\treturn h\n}\n\nfunc (m *model) updateOffset() {\n\theight := m.listHeight()\n\t// Scrolling down.\n\tif m.r >= m.offset+height {\n\t\tm.offset = m.r - height + 1\n\t}\n\t// Scrolling up.\n\tif m.r < m.offset {\n\t\tm.offset = m.r\n\t}\n\t// Don't scroll more than there are rows.\n\tif m.offset > m.rows-height && m.rows > height {\n\t\tm.offset = m.rows - height\n\t}\n\tif m.offset < 0 {\n\t\tm.offset = 0\n\t}\n}\n\nfunc (m *model) saveCursorPosition() {\n\tm.positions[m.path] = position{\n\t\tc:      m.c,\n\t\tr:      m.r,\n\t\toffset: m.offset,\n\t}\n}\n\nfunc (m *model) fileName() (string, bool) {\n\ti := m.c*m.rows + m.r\n\tif i >= len(m.files) || i < 0 {\n\t\treturn \"\", false\n\t}\n\treturn m.files[i].Name(), true\n}\n\nfunc (m *model) filePath() (string, bool) {\n\tfileName, ok := m.fileName()\n\tif !ok {\n\t\treturn fileName, false\n\t}\n\treturn path.Join(m.path, fileName), true\n}\n\nfunc (m *model) openEditor() tea.Cmd {\n\tfilePath, ok := m.filePath()\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tcmdline := Split(lookup([]string{\"WALK_EDITOR\", \"EDITOR\"}, \"less\"), \" \")\n\tcmdline = append(cmdline, filePath)\n\n\texecCmd := exec.Command(cmdline[0], cmdline[1:]...)\n\treturn tea.ExecProcess(execCmd, func(err error) tea.Msg {\n\t\t// Note: we could return a message here indicating that editing is\n\t\t// finished and altering our application about any errors. For now,\n\t\t// however, that's not necessary.\n\t\treturn nil\n\t})\n}\n\nfunc (m *model) preview() {\n\tif !m.previewMode {\n\t\treturn\n\t}\n\tfilePath, ok := m.filePath()\n\tif !ok {\n\t\t// Normally this should not happen\n\t\tm.previewContent = warning.Render(\"Invalid file to preview\")\n\t\treturn\n\t}\n\n\tfileInfo, err := os.Stat(filePath)\n\tif err != nil {\n\t\tm.previewContent = warning.Render(err.Error())\n\t\treturn\n\t}\n\n\twidth := m.width / 2\n\theight := m.height - 1 // Subtract 1 for name bar.\n\n\tif fileInfo.IsDir() {\n\t\tfiles, err := os.ReadDir(filePath)\n\t\tif err != nil {\n\t\t\tm.previewContent = warning.Render(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif len(files) == 0 {\n\t\t\tm.previewContent = warning.Render(\"No files\")\n\t\t\treturn\n\t\t}\n\n\t\tnames, rows, columns := wrap(files, width, height, nil)\n\n\t\toutput := make([]string, rows)\n\t\tfor j := 0; j < rows; j++ {\n\t\t\trow := make([]string, columns)\n\t\t\tfor i := 0; i < columns; i++ {\n\t\t\t\trow[i] = names[i][j]\n\t\t\t}\n\t\t\toutput[j] = Join(row, separator)\n\t\t}\n\t\tif len(output) >= height {\n\t\t\toutput = output[0:height]\n\t\t}\n\t\tm.previewContent = Join(output, \"\\n\")\n\t\treturn\n\t}\n\n\tif isImageExt(filePath) {\n\t\timg, err := drawImage(filePath, width, height)\n\t\tif err != nil {\n\t\t\tm.previewContent = warning.Render(\"No image preview available\")\n\t\t\treturn\n\t\t}\n\t\tm.previewContent = img\n\t\treturn\n\t}\n\n\tvar content []byte\n\t// If file is too big (> 100kb), read only first 100kb.\n\tif fileInfo.Size() > 100*1024 {\n\t\tfile, err := os.Open(filePath)\n\t\tif err != nil {\n\t\t\tm.previewContent = err.Error()\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\t\tcontent = make([]byte, 100*1024)\n\t\t_, err = file.Read(content)\n\t\tif err != nil {\n\t\t\tm.previewContent = err.Error()\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tcontent, err = os.ReadFile(filePath)\n\t\tif err != nil {\n\t\t\tm.previewContent = err.Error()\n\t\t\treturn\n\t\t}\n\t}\n\n\tswitch {\n\tcase utf8.Valid(content):\n\t\tm.previewContent = leaveOnlyAscii(content)\n\tdefault:\n\t\tm.previewContent = warning.Render(\"No preview available\")\n\t}\n}\n\nfunc leaveOnlyAscii(content []byte) string {\n\tvar result []byte\n\n\tfor _, b := range content {\n\t\tif b == '\\t' {\n\t\t\tresult = append(result, ' ', ' ', ' ', ' ')\n\t\t} else if b == '\\r' {\n\t\t\tcontinue\n\t\t} else if (b >= 32 && b <= 127) || b == '\\n' { // '\\n' is kept if newline needs to be retained\n\t\t\tresult = append(result, b)\n\t\t}\n\t}\n\n\treturn string(result)\n}\n\n// TODO: Write tests for this function.\nfunc wrap(files []os.DirEntry, width int, height int, callback func(name string, i, j int)) ([][]string, int, int) {\n\t// If the directory is empty, return no names, rows and columns.\n\tif len(files) == 0 {\n\t\treturn nil, 0, 0\n\t}\n\n\t// If it's possible to fit all files in one column on a third of the screen,\n\t// just use one column. Otherwise, let's squeeze listing in half of screen.\n\tcolumns := len(files) / max(1, height/3)\n\tif columns <= 0 {\n\t\tcolumns = 1\n\t}\n\n\t// Max number of files to display in one column is 10 or 4 columns in total.\n\tcolumnsEstimate := int(math.Ceil(float64(len(files)) / 10))\n\tcolumns = max(columns, min(columnsEstimate, 4))\n\n\t// For large lists, don't use more than 2 columns.\n\tif len(files) > 100 {\n\t\tcolumns = 2\n\t}\n\n\t// Fifteenth column is enough for everyone.\n\tif columns > 15 {\n\t\tcolumns = 15\n\t}\n\nstart:\n\t// Let's try to fit everything in terminal width with this many columns.\n\t// If we are not able to do it, decrease column number and goto start.\n\trows := int(math.Ceil(float64(len(files)) / float64(columns)))\n\tnames := make([][]string, columns)\n\tn := 0\n\n\tfor i := 0; i < columns; i++ {\n\t\tnames[i] = make([]string, rows)\n\t\tmaxNameSize := 0 // We will use this to determine max name size, and pad names in column with spaces.\n\t\tfor j := 0; j < rows; j++ {\n\t\t\tif n >= len(files) {\n\t\t\t\tbreak // No more files to display.\n\t\t\t}\n\t\t\tname := \"\"\n\t\t\tif showIcons {\n\t\t\t\tinfo, err := files[n].Info()\n\t\t\t\tif err == nil {\n\t\t\t\t\ticon := icons.getIcon(info)\n\t\t\t\t\tif icon != \"\" {\n\t\t\t\t\t\tname += icon + \" \"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tname += files[n].Name()\n\t\t\tif callback != nil {\n\t\t\t\tcallback(files[n].Name(), i, j)\n\t\t\t}\n\t\t\tif files[n].IsDir() {\n\t\t\t\t// Dirs should have a slash at the end.\n\t\t\t\tname += fileSeparator\n\t\t\t}\n\n\t\t\tn++ // Next file.\n\n\t\t\tif maxNameSize < strlen(name) {\n\t\t\t\tmaxNameSize = strlen(name)\n\t\t\t}\n\t\t\tnames[i][j] = name\n\t\t}\n\n\t\t// Append spaces to make all names in one column of same size.\n\t\tfor j := 0; j < rows; j++ {\n\t\t\tnames[i][j] += Repeat(\" \", maxNameSize-strlen(names[i][j]))\n\t\t}\n\t}\n\n\t// Let's verify was all columns have at least one file.\n\tfor i := 0; i < columns; i++ {\n\t\tif names[i] == nil {\n\t\t\tcolumns--\n\t\t\tgoto start\n\t\t}\n\t\tcolumnHaveAtLeastOneFile := false\n\t\tfor j := 0; j < rows; j++ {\n\t\t\tif names[i][j] != \"\" {\n\t\t\t\tcolumnHaveAtLeastOneFile = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !columnHaveAtLeastOneFile {\n\t\t\tcolumns--\n\t\t\tgoto start\n\t\t}\n\t}\n\n\tfor j := 0; j < rows; j++ {\n\t\trow := make([]string, columns)\n\t\tfor i := 0; i < columns; i++ {\n\t\t\trow[i] = names[i][j]\n\t\t}\n\t\tif strlen(Join(row, separator)) > width && columns > 1 {\n\t\t\t// Yep. No luck, let's decrease number of columns and try one more time.\n\t\t\tcolumns--\n\t\t\tgoto start\n\t\t}\n\t}\n\treturn names, rows, columns\n}\n\nfunc emitCO2(duration time.Duration) {\n\tctx, cancel := context.WithTimeout(context.Background(), duration)\n\tdefer cancel()\n\n\tnumCPU := runtime.NumCPU()\n\truntime.GOMAXPROCS(numCPU)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < numCPU; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\twg.Wait()\n}\n\nfunc (m *model) dontDoPendingDeletions() {\n\tfor _, toDelete := range m.toBeDeleted {\n\t\tfmt.Fprintf(os.Stderr, \"Was not deleted: %v\\n\", toDelete.path)\n\t}\n}\n\nfunc (m *model) performPendingDeletions() {\n\tfor _, toDelete := range m.toBeDeleted {\n\t\tremove(toDelete.path)\n\t}\n\tm.toBeDeleted = nil\n}\n\nfunc fileInfo(path string) os.FileInfo {\n\tfi, err := os.Stat(path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn fi\n}\n\nfunc lookup(names []string, val string) string {\n\tfor _, name := range names {\n\t\tval, ok := os.LookupEnv(name)\n\t\tif ok && val != \"\" {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn val\n}\n\nfunc remove(path string) {\n\tgo func() {\n\t\tcmd, ok := os.LookupEnv(\"WALK_REMOVE_CMD\")\n\t\tif !ok {\n\t\t\t_ = os.RemoveAll(path)\n\t\t} else {\n\t\t\t_ = exec.Command(cmd, path).Run()\n\t\t}\n\t}()\n}\n\nfunc usage() {\n\t_, _ = fmt.Fprintf(os.Stderr, \"\\n  \"+bold.Render(\"walk \"+Version)+\"\\n\\n  Usage: walk [path]\\n\\n\")\n\tw := tabwriter.NewWriter(os.Stderr, 0, 8, 2, ' ', 0)\n\tput := func(s string) {\n\t\t_, _ = fmt.Fprintln(w, s)\n\t}\n\tput(\"    arrows, hjkl\\tMove cursor\")\n\tput(\"    enter\\tEnter directory\")\n\tput(\"    backspace\\tExit directory\")\n\tput(\"    space\\tToggle preview\")\n\tput(\"    esc, q\\tExit with cd\")\n\tput(\"    ctrl+c\\tExit without cd\")\n\tput(\"    /\\tFuzzy search\")\n\tput(\"    d, delete\\tDelete file or dir\")\n\tput(\"    y\\tYank current directory path to clipboard\")\n\tput(\"    .\\tHide hidden files\")\n\tput(\"\\n  Flags:\\n\")\n\tput(\"    --icons\\tdisplay icons\")\n\tput(\"    --dir-only\\tshow dirs only\")\n\tput(\"    --preview\\tdisplay preview\")\n\tput(\"    --fuzzy\\tfuzzy mode\")\n\t_ = w.Flush()\n\t_, _ = fmt.Fprintf(os.Stderr, \"\\n\")\n\tos.Exit(1)\n}\n\nfunc version() {\n\tfmt.Printf(\"%s\\n\", Version)\n\tos.Exit(0)\n}\n"
        }
      ]
    }
  ]
}