{
  "metadata": {
    "timestamp": 1736567123976,
    "page": 719,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "aerokube/selenoid",
      "stars": 2617,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0537109375,
          "content": ".idea\n*.iml\nselenoid\nselenoid.exe\ncoverage.*\n.DS_Store\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.1416015625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at support@aerokube.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.328125,
          "content": "FROM --platform=$BUILDPLATFORM alpine:3\n\nRUN apk add -U ca-certificates tzdata mailcap && rm -Rf /var/cache/apk/*\n\nARG TARGETARCH\nCOPY dist/selenoid_linux_$TARGETARCH /usr/bin/selenoid\n\nEXPOSE 4444\nENTRYPOINT [\"/usr/bin/selenoid\", \"-listen\", \":4444\", \"-conf\", \"/etc/selenoid/browsers.json\", \"-video-output-dir\", \"/opt/selenoid/video/\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 21.5478515625,
          "content": "Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2016+ Alexander Andryashin and collaborators\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.1533203125,
          "content": "# Selenoid\n[![Build Status](https://github.com/aerokube/selenoid/workflows/build/badge.svg)](https://github.com/aerokube/selenoid/actions?query=workflow%3Abuild)\n[![Coverage](https://codecov.io/github/aerokube/selenoid/coverage.svg)](https://codecov.io/gh/aerokube/selenoid)\n[![Go Report Card](https://goreportcard.com/badge/github.com/aerokube/selenoid)](https://goreportcard.com/report/github.com/aerokube/selenoid)\n[![Release](https://img.shields.io/github/release/aerokube/selenoid.svg)](https://github.com/aerokube/selenoid/releases/latest)\n[![Docker Pulls](https://img.shields.io/docker/pulls/aerokube/selenoid.svg)](https://hub.docker.com/r/aerokube/selenoid)\n[![StackOverflow Tag](https://img.shields.io/badge/stackoverflow-selenoid-orange.svg?style=flat)](https://stackoverflow.com/questions/tagged/selenoid)\n\n**UNMAINTAINED**. Consider https://aerokube.com/moon/latest as alternative.\n\nSelenoid is a powerful implementation of [Selenium](http://github.com/SeleniumHQ/selenium) hub using [Docker](https://docker.com/) containers to launch browsers.\n![Selenoid Animation](docs/img/selenoid-animation.gif)\n\n## Features\n\n### One-command Installation\nStart browser automation in minutes by downloading [Configuration Manager](https://github.com/aerokube/cm/releases) binary and running just **one command**:\n```\n$ ./cm selenoid start --vnc --tmpfs 128\n```\n**That's it!** You can now use Selenoid instead of Selenium server. Specify the following Selenium URL in tests:\n```\nhttp://localhost:4444/wd/hub\n```\n\n### Ready to use Browser Images\nNo need to manually install browsers or dive into WebDriver documentation. Available images:\n![Browsers List](docs/img/browsers-list.gif)\n\nNew images are added right after official releases. You can create your custom images with browsers. \n\n### Live Browser Screen and Logs\nNew **[rich user interface]((https://github.com/aerokube/selenoid-ui))** showing browser screen and Selenium session logs:\n![Selenoid UI](docs/img/selenoid-ui.png)\n\n### Video Recording\n* Any browser session can be saved to [H.264](https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC) video ([example](https://www.youtube.com/watch?v=maB298oO5cI))\n* An API to list, download and delete recorded video files\n\n### Convenient Logging\n\n* Any browser session logs are automatically saved to files - one per session\n* An API to list, download and delete saved log files\n\n### Lightweight and Lightning Fast\nSuitable for personal usage and in big clusters:\n* Consumes **10 times** less memory than Java-based Selenium server under the same load\n* **Small 6 Mb binary** with no external dependencies (no need to install Java)\n* **Browser consumption API** working out of the box\n* Ability to send browser logs to **centralized log storage** (e.g. to the [ELK-stack](https://logz.io/learn/complete-guide-elk-stack/))\n* Fully **isolated** and **reproducible** environment\n\n### Detailed Documentation and Free Support\nMaintained by a growing community:\n* Detailed [documentation](http://aerokube.com/selenoid/latest/)\n* Telegram [support channel](https://t.me/aerokube)\n* Support by [email](mailto:support@aerokube.com)\n* StackOverflow [tag](https://stackoverflow.com/questions/tagged/selenoid)\n* YouTube [channel](https://www.youtube.com/channel/UC9HvE3FNfTvftzpvXi9c69g)\n\n## Complete Guide & Build Instructions\n\nComplete reference guide (including building instructions) can be found at: http://aerokube.com/selenoid/latest/\n\n## Selenoid in Kubernetes\n\nSelenoid was initially created to be deployed on hardware servers or virtual machines and is not suitable for Kubernetes. Detailed motivation is described [here](https://aerokube.com/selenoid/latest/#_selenoid_in_kubernetes). If you still need running Selenium tests in Kubernetes, then take a look at [Moon](https://github.com/aerokube/moon/) - our dedicated solution for Kubernetes. \n\n## Known Users\n\n[![JetBrains](docs/img/logo/jetbrains.png)](http://jetbrains.com/) [![Yandex](docs/img/logo/yandex.png)](https://yandex.com/company/) [![Sberbank Technology](docs/img/logo/sbertech.png)](http://sber-tech.com/) [![ThoughtWorks](docs/img/logo/thoughtworks.png)](https://thoughtworks.com/) [![VK.com](docs/img/logo/vk.png)](https://vk.com/) [![SuperJob](docs/img/logo/superjob.png)](http://superjob.ru/) [![PropellerAds](docs/img/logo/propellerads.png)](http://propellerads.com/) [![AlfaBank](docs/img/logo/alfabank.png)](https://alfabank.com/) [![3CX](docs/img/logo/3cx.png)](https://www.3cx.com/) [![IQ Option](docs/img/logo/iq_option.png)](https://iqoption.com/) [![Mail.Ru Group](docs/img/logo/mail_ru.png)](https://corp.mail.ru/en/) [![Newegg.Com](docs/img/logo/newegg.png)](https://newegg.com/) [![Badoo](docs/img/logo/badoo.png)](https://badoo.com/team/) [![BCS](docs/img/logo/bcs.png)](https://bcs.ru/) [![Quality Lab](docs/img/logo/quality-lab.png)](https://quality-lab.ru) [![AT Consulting](docs/img/logo/at-consulting.png)](https://www.at-consulting.ru/) [![Royal Caribbean International](docs/img/logo/royal-caribbean.png)](https://www.royalcaribbean.com/) [![Sixt](docs/img/logo/sixt.png)](https://sixt.com/) [![Testjar](docs/img/logo/testjar.png)](http://www.testjar.com/) [![Flipdish](docs/img/logo/flipdish.png)](https://www.flipdish.com/) [![RiAdvice](docs/img/logo/riadvice.png)](https://riadvice.tn/)\n\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 7.0693359375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/aerokube/selenoid/config\"\n\t\"github.com/aerokube/selenoid/session\"\n\tassert \"github.com/stretchr/testify/require\"\n)\n\nconst testLogConf = \"config/container-logs.json\"\n\nfunc configfile(s string) string {\n\ttmp, err := os.CreateTemp(\"\", \"config\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = tmp.Write([]byte(s))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\terr = tmp.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn tmp.Name()\n}\n\nfunc TestConfig(t *testing.T) {\n\tconfFile := configfile(`{}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\terr := conf.Load(confFile, testLogConf)\n\tassert.NoError(t, err)\n}\n\nfunc TestConfigError(t *testing.T) {\n\tconfFile := configfile(`{}`)\n\t_ = os.Remove(confFile)\n\tconf := config.NewConfig()\n\terr := conf.Load(confFile, testLogConf)\n\tassert.Error(t, err)\n\tassert.Equal(t, err.Error(), fmt.Sprintf(\"browsers config: read error: open %s: no such file or directory\", confFile))\n}\n\nfunc TestLogConfigError(t *testing.T) {\n\tconfFile := configfile(`{}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\terr := conf.Load(confFile, \"some-missing-file\")\n\tassert.Error(t, err)\n}\n\nfunc TestConfigParseError(t *testing.T) {\n\tconfFile := configfile(`{`)\n\tdefer os.Remove(confFile)\n\tvar conf config.Config\n\terr := conf.Load(confFile, testLogConf)\n\tassert.Error(t, err)\n\tassert.Equal(t, err.Error(), \"browsers config: parse error: unexpected end of JSON input\")\n}\n\nfunc TestConfigEmptyState(t *testing.T) {\n\tconfFile := configfile(`{}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\tconf.Load(confFile, testLogConf)\n\n\tstate := conf.State(session.NewMap(), 0, 0, 0)\n\tassert.Equal(t, state.Total, 0)\n\tassert.Equal(t, state.Queued, 0)\n\tassert.Equal(t, state.Pending, 0)\n\tassert.Equal(t, state.Used, 0)\n}\n\nfunc TestConfigNonEmptyState(t *testing.T) {\n\tconfFile := configfile(`{}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\t_ = conf.Load(confFile, testLogConf)\n\n\tsessions := session.NewMap()\n\tsessions.Put(\"0\", &session.Session{Caps: session.Caps{Name: \"firefox\", Version: \"49.0\"}, Quota: \"unknown\"})\n\tstate := conf.State(sessions, 1, 0, 0)\n\tassert.Equal(t, state.Total, 1)\n\tassert.Equal(t, state.Queued, 0)\n\tassert.Equal(t, state.Pending, 0)\n\tassert.Equal(t, state.Used, 1)\n\tassert.Equal(t, state.Browsers[\"firefox\"][\"49.0\"][\"unknown\"].Count, 1)\n}\n\nfunc TestConfigEmptyVersions(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\t_ = conf.Load(confFile, testLogConf)\n\n\tsessions := session.NewMap()\n\tsessions.Put(\"0\", &session.Session{Caps: session.Caps{Name: \"firefox\", Version: \"49.0\"}, Quota: \"unknown\"})\n\tstate := conf.State(sessions, 1, 0, 0)\n\tassert.Equal(t, state.Total, 1)\n\tassert.Equal(t, state.Queued, 0)\n\tassert.Equal(t, state.Pending, 0)\n\tassert.Equal(t, state.Used, 1)\n\tassert.Equal(t, state.Browsers[\"firefox\"][\"49.0\"][\"unknown\"].Count, 1)\n}\n\nfunc TestConfigNonEmptyVersions(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"49.0\",\"versions\":{\"49.0\":{}}}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\tconf.Load(confFile, testLogConf)\n\n\tsessions := session.NewMap()\n\tsessions.Put(\"0\", &session.Session{Caps: session.Caps{Name: \"firefox\", Version: \"49.0\"}, Quota: \"unknown\"})\n\tstate := conf.State(sessions, 1, 0, 0)\n\tassert.Equal(t, state.Total, 1)\n\tassert.Equal(t, state.Queued, 0)\n\tassert.Equal(t, state.Pending, 0)\n\tassert.Equal(t, state.Used, 1)\n\tassert.Equal(t, state.Browsers[\"firefox\"][\"49.0\"][\"unknown\"].Count, 1)\n}\n\nfunc TestConfigFindMissingBrowser(t *testing.T) {\n\tconfFile := configfile(`{}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\tconf.Load(confFile, testLogConf)\n\n\t_, _, ok := conf.Find(\"firefox\", \"\")\n\tassert.False(t, ok)\n}\n\nfunc TestConfigFindDefaultVersionError(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"\"}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\tconf.Load(confFile, testLogConf)\n\n\t_, _, ok := conf.Find(\"firefox\", \"\")\n\tassert.False(t, ok)\n}\n\nfunc TestConfigFindDefaultVersion(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"49.0\"}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\terr := conf.Load(confFile, testLogConf)\n\tassert.NoError(t, err)\n\n\t_, v, ok := conf.Find(\"firefox\", \"\")\n\tassert.False(t, ok)\n\tassert.Equal(t, v, \"49.0\")\n}\n\nfunc TestConfigFindFoundByEmptyPrefix(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"49.0\",\"versions\":{\"49.0\":{}}}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\terr := conf.Load(confFile, testLogConf)\n\tassert.NoError(t, err)\n\n\t_, v, ok := conf.Find(\"firefox\", \"\")\n\tassert.True(t, ok)\n\tassert.Equal(t, v, \"49.0\")\n}\n\nfunc TestConfigFindFoundByPrefix(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"49.0\",\"versions\":{\"49.0\":{}}}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\terr := conf.Load(confFile, testLogConf)\n\tassert.NoError(t, err)\n\n\t_, v, ok := conf.Find(\"firefox\", \"49\")\n\tassert.True(t, ok)\n\tassert.Equal(t, v, \"49.0\")\n}\n\nfunc TestConfigFindFoundByMatch(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"49.0\",\"versions\":{\"49.0\":{}}}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\terr := conf.Load(confFile, testLogConf)\n\tassert.NoError(t, err)\n\n\t_, v, ok := conf.Find(\"firefox\", \"49.0\")\n\tassert.True(t, ok)\n\tassert.Equal(t, v, \"49.0\")\n}\n\nfunc TestConfigFindImage(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"49.0\",\"versions\":{\"49.0\":{\"image\":\"image\",\"port\":\"5555\", \"path\":\"/\"}}}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\terr := conf.Load(confFile, testLogConf)\n\tassert.NoError(t, err)\n\n\tb, v, ok := conf.Find(\"firefox\", \"49.0\")\n\tassert.True(t, ok)\n\tassert.Equal(t, v, \"49.0\")\n\tassert.Equal(t, b.Image, \"image\")\n\tassert.Equal(t, b.Port, \"5555\")\n\tassert.Equal(t, b.Path, \"/\")\n}\n\nfunc TestConfigConcurrentLoad(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"\"}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\t_ = conf.Load(confFile, testLogConf)\n\t\tdone <- struct{}{}\n\t}()\n\t_ = conf.Load(confFile, testLogConf)\n\t<-done\n}\n\nfunc TestConfigConcurrentLoadAndRead(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"49.0\",\"versions\":{\"49.0\":{\"image\":\"image\",\"port\":\"5555\", \"path\":\"/\", \"tmpfs\": {\"/tmp\":\"size=64k\"}}}}}`)\n\tdefer os.Remove(confFile)\n\tconf := config.NewConfig()\n\terr := conf.Load(confFile, testLogConf)\n\tassert.NoError(t, err)\n\tdone := make(chan string)\n\tgo func() {\n\t\tbrowser, _, _ := conf.Find(\"firefox\", \"\")\n\t\tdone <- browser.Tmpfs[\"/tmp\"]\n\t}()\n\terr = conf.Load(confFile, testLogConf)\n\tassert.NoError(t, err)\n\t<-done\n}\n\nfunc TestConfigConcurrentRead(t *testing.T) {\n\tconfFile := configfile(`{\"firefox\":{\"default\":\"49.0\",\"versions\":{\"49.0\":{\"image\":\"image\",\"port\":\"5555\", \"path\":\"/\", \"tmpfs\": {\"/tmp\":\"size=64k\"}}}}}`)\n\tdefer os.Remove(confFile)\n\tvar conf config.Config\n\terr := conf.Load(confFile, testLogConf)\n\tassert.NoError(t, err)\n\tdone := make(chan string)\n\tgo func() {\n\t\tbrowser, _, _ := conf.Find(\"firefox\", \"\")\n\t\tdone <- browser.Tmpfs[\"/tmp\"]\n\t}()\n\tgo func() {\n\t\tbrowser, _, _ := conf.Find(\"firefox\", \"\")\n\t\tdone <- browser.Tmpfs[\"/tmp\"]\n\t}()\n\t<-done\n\t<-done\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.2109375,
          "content": "/*\nSelenoid is a powerful implementation of Selenium Hub using Docker or standalone web driver binaries to start and launch browsers. Documentation has moved to: https://aerokube.com/selenoid/latest.\n*/\npackage main\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "event",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.9140625,
          "content": "module github.com/aerokube/selenoid\n\ngo 1.22\n\nrequire (\n\tgithub.com/aerokube/ggr v0.0.0-20240420103110-fc913c480489\n\tgithub.com/aws/aws-sdk-go v1.53.5\n\tgithub.com/docker/docker v26.1.5+incompatible\n\tgithub.com/docker/go-connections v0.5.0\n\tgithub.com/docker/go-units v0.5.0\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/gorilla/websocket v1.5.1\n\tgithub.com/imdario/mergo v0.3.15\n\tgithub.com/mafredri/cdp v0.34.1\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/stretchr/testify v1.9.0\n\tgolang.org/x/net v0.25.0\n)\n\nrequire (\n\tgithub.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 // indirect\n\tgithub.com/Microsoft/go-winio v0.6.1 // indirect\n\tgithub.com/containerd/log v0.1.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/distribution/reference v0.5.0 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.4 // indirect\n\tgithub.com/go-logr/logr v1.4.1 // indirect\n\tgithub.com/go-logr/stdr v1.2.2 // indirect\n\tgithub.com/gogo/protobuf v1.3.2 // indirect\n\tgithub.com/jmespath/go-jmespath v0.4.0 // indirect\n\tgithub.com/moby/docker-image-spec v1.3.1 // indirect\n\tgithub.com/moby/term v0.5.0 // indirect\n\tgithub.com/morikuni/aec v1.0.0 // indirect\n\tgithub.com/opencontainers/go-digest v1.0.0 // indirect\n\tgithub.com/opencontainers/image-spec v1.0.2 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.47.0 // indirect\n\tgo.opentelemetry.io/otel v1.22.0 // indirect\n\tgo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.22.0 // indirect\n\tgo.opentelemetry.io/otel/metric v1.22.0 // indirect\n\tgo.opentelemetry.io/otel/sdk v1.22.0 // indirect\n\tgo.opentelemetry.io/otel/trace v1.22.0 // indirect\n\tgolang.org/x/mod v0.17.0 // indirect\n\tgolang.org/x/sync v0.7.0 // indirect\n\tgolang.org/x/sys v0.20.0 // indirect\n\tgolang.org/x/time v0.5.0 // indirect\n\tgolang.org/x/tools v0.21.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n\tgotest.tools/v3 v3.5.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 16.7626953125,
          "content": "github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 h1:L/gRVlceqvL25UVaW/CKtUDjefjrs0SPonmDGUVOYP0=\ngithub.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=\ngithub.com/Microsoft/go-winio v0.6.1 h1:9/kr64B9VUZrLm5YYwbGtUJnMgqWVOdUAXu6Migciow=\ngithub.com/Microsoft/go-winio v0.6.1/go.mod h1:LRdKpFKfdobln8UmuiYcKPot9D2v6svN5+sAH+4kjUM=\ngithub.com/aerokube/ggr v0.0.0-20240420103110-fc913c480489 h1:o921DQC1wmxmYftt6xpDmoIlEOUqxPh9bLi5uB25Nps=\ngithub.com/aerokube/ggr v0.0.0-20240420103110-fc913c480489/go.mod h1:soFdGlpMBKP88KMnnCranonPRqNw9O0FasvXvaO8IGs=\ngithub.com/aws/aws-sdk-go v1.53.5 h1:1OcVWMjGlwt7EU5OWmmEEXqaYfmX581EK317QJZXItM=\ngithub.com/aws/aws-sdk-go v1.53.5/go.mod h1:LF8svs817+Nz+DmiMQKTO3ubZ/6IaTpq3TjupRn3Eqk=\ngithub.com/cenkalti/backoff/v4 v4.2.1 h1:y4OZtCnogmCPw98Zjyt5a6+QwPLGkiQsYW5oUqylYbM=\ngithub.com/cenkalti/backoff/v4 v4.2.1/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/containerd/log v0.1.0 h1:TCJt7ioM2cr/tfR8GPbGf9/VRAX8D2B4PjzCpfX540I=\ngithub.com/containerd/log v0.1.0/go.mod h1:VRRf09a7mHDIRezVKTRCrOq78v577GXq3bSa3EhrzVo=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/distribution/reference v0.5.0 h1:/FUIFXtfc/x2gpa5/VGfiGLuOIdYa1t65IKK2OFGvA0=\ngithub.com/distribution/reference v0.5.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=\ngithub.com/docker/docker v26.1.5+incompatible h1:NEAxTwEjxV6VbBMBoGG3zPqbiJosIApZjxlbrG9q3/g=\ngithub.com/docker/docker v26.1.5+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=\ngithub.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=\ngithub.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=\ngithub.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=\ngithub.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=\ngithub.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=\ngithub.com/gin-gonic/gin v1.6.3/go.mod h1:75u5sXoLsGZoRN5Sgbi1eraJ4GU3++wFwWzhwvtwp4M=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.4.1 h1:pKouT5E8xu9zeFC39JXRDukb6JFQPXM5p5I91188VAQ=\ngithub.com/go-logr/logr v1.4.1/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/go-playground/assert/v2 v2.0.1/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=\ngithub.com/go-playground/locales v0.13.0/go.mod h1:taPMhCMXrRLJO55olJkUXHZBHCxTMfnGwq/HNwmWNS8=\ngithub.com/go-playground/universal-translator v0.17.0/go.mod h1:UkSxE5sNxxRwHyU+Scu5vgOQjsIJAF8j9muTVoKLVtA=\ngithub.com/go-playground/validator/v10 v10.2.0/go.mod h1:uOYAAleCW8F/7oMFd6aG0GOhaH6EGOAJShg8Id5JGkI=\ngithub.com/gobwas/httphead v0.0.0-20180130184737-2c6c146eadee/go.mod h1:L0fX3K22YWvt/FAX9NnzrNzcI4wNYi9Yku4O0LKYflo=\ngithub.com/gobwas/pool v0.2.0/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=\ngithub.com/gobwas/ws v1.0.2/go.mod h1:szmBTxLgaFppYjEmNtny/v3w89xOydFnnZMcgRRu/EM=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/gorilla/websocket v1.4.1/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/gorilla/websocket v1.5.1 h1:gmztn0JnHVt9JZquRuzLw3g4wouNVzKL15iLr/zn/QY=\ngithub.com/gorilla/websocket v1.5.1/go.mod h1:x3kM2JMyaluk02fnUJpQuwD2dCS5NDG2ZHL0uE0tcaY=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.16.0 h1:YBftPWNWd4WwGqtY2yeZL2ef8rHAxPBD8KFhJpmcqms=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.16.0/go.mod h1:YN5jB8ie0yfIUg6VvR9Kz84aCaG7AsGZnLjhHbUqwPg=\ngithub.com/imdario/mergo v0.3.15 h1:M8XP7IuFNsqUx6VPK2P9OSmsYsI/YFaGil0uD21V3dM=\ngithub.com/imdario/mergo v0.3.15/go.mod h1:WBLT9ZmE3lPoWsEzCh9LPo3TiwVN+ZKEjmz+hD27ysY=\ngithub.com/jmespath/go-jmespath v0.4.0 h1:BEgLn5cpjn8UN1mAw4NjwDrS35OdebyEtFe+9YPoQUg=\ngithub.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=\ngithub.com/jmespath/go-jmespath/internal/testify v1.5.1 h1:shLQSRRSCCPj3f2gpwzGwWFoC7ycTf1rcQZHOlsJ6N8=\ngithub.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=\ngithub.com/json-iterator/go v1.1.9/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.10.3 h1:OP96hzwJVBIHYU52pVTI6CczrxPvrGfgqF9N5eTO0Q8=\ngithub.com/klauspost/compress v1.10.3/go.mod h1:aoV0uJVorq1K+umq18yTdKaF57EivdYsUV+/s2qKfXs=\ngithub.com/leodido/go-urn v1.2.0/go.mod h1:+8+nEpDfqqsY+g338gtMEUOtuK+4dEMhiQEgxpxOKII=\ngithub.com/mafredri/cdp v0.34.1 h1:EeLNc+6pkDx2hrAm1arIjiofoH0fM5On1uAFzcuUn+o=\ngithub.com/mafredri/cdp v0.34.1/go.mod h1:Dbsh7eY/zhQlsddEDWzZGOztv9Jf2gzKq47M7a2P3C4=\ngithub.com/mafredri/go-lint v0.0.0-20180911205320-920981dfc79e/go.mod h1:k/zdyxI3q6dup24o8xpYjJKTCf2F7rfxLp6w/efTiWs=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=\ngithub.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=\ngithub.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=\ngithub.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=\ngithub.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=\ngithub.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=\ngithub.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=\ngithub.com/opencontainers/image-spec v1.0.2 h1:9yCKha/T5XdGtO0q9Q9a6T5NUCsTn/DrBg0D7ufOcFM=\ngithub.com/opencontainers/image-spec v1.0.2/go.mod h1:BtxoFyWECRxE4U/7sNtV5W15zMzWCbyJoFRP3s7yZA0=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=\ngithub.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/ugorji/go v1.1.7/go.mod h1:kZn38zHttfInRq0xu/PH0az30d+z6vm202qpg1oXVMw=\ngithub.com/ugorji/go/codec v1.1.7/go.mod h1:Ax+UKWsSmolVDwsd+7N3ZtXu+yMGCf907BLYF3GoBXY=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.47.0 h1:sv9kVfal0MK0wBMCOGr+HeJm9v803BkJxGrk2au7j08=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.47.0/go.mod h1:SK2UL73Zy1quvRPonmOmRDiWk1KBV3LyIeeIxcEApWw=\ngo.opentelemetry.io/otel v1.22.0 h1:xS7Ku+7yTFvDfDraDIJVpw7XPyuHlB9MCiqqX5mcJ6Y=\ngo.opentelemetry.io/otel v1.22.0/go.mod h1:eoV4iAi3Ea8LkAEI9+GFT44O6T/D0GWAVFyZVCC6pMI=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace v1.22.0 h1:9M3+rhx7kZCIQQhQRYaZCdNu1V73tm4TvXs2ntl98C4=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace v1.22.0/go.mod h1:noq80iT8rrHP1SfybmPiRGc9dc5M8RPmGvtwo7Oo7tc=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.22.0 h1:FyjCyI9jVEfqhUh2MoSkmolPjfh5fp2hnV0b0irxH4Q=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.22.0/go.mod h1:hYwym2nDEeZfG/motx0p7L7J1N1vyzIThemQsb4g2qY=\ngo.opentelemetry.io/otel/metric v1.22.0 h1:lypMQnGyJYeuYPhOM/bgjbFM6WE44W1/T45er4d8Hhg=\ngo.opentelemetry.io/otel/metric v1.22.0/go.mod h1:evJGjVpZv0mQ5QBRJoBF64yMuOf4xCWdXjK8pzFvliY=\ngo.opentelemetry.io/otel/sdk v1.22.0 h1:6coWHw9xw7EfClIC/+O31R8IY3/+EiRFHevmHafB2Gw=\ngo.opentelemetry.io/otel/sdk v1.22.0/go.mod h1:iu7luyVGYovrRpe2fmj3CVKouQNdTOkxtLzPvPz1DOc=\ngo.opentelemetry.io/otel/trace v1.22.0 h1:Hg6pPujv0XG9QaVbGOBVHunyuLcCC3jN7WEhPx83XD0=\ngo.opentelemetry.io/otel/trace v1.22.0/go.mod h1:RbbHXVqKES9QhzZq/fE5UnOSILqRt40a21sPw2He1xo=\ngo.opentelemetry.io/proto/otlp v1.0.0 h1:T0TX0tmXU8a3CbNXzEKGeU5mIVOdf0oykP+u2lIVU/I=\ngo.opentelemetry.io/proto/otlp v1.0.0/go.mod h1:Sy6pihPLfYHkr3NkUbEhGHFhINUSI/v80hjKIs5JXpM=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.17.0 h1:zY54UmvipHiNd+pm+m0x9KhZ9hl1/7QNMyxXbc6ICqA=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.25.0 h1:d/OCCoBEUq33pjydKrGQhw7IlUPI2Oylr+8qLx49kac=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.7.0 h1:YsImfSBoP9QPYL0xyKJPq0gcaJdG3rInoqxTWbfQu9M=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210319071255-635bc2c9138d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.20.0 h1:Od9JTbYCk261bKm4M/mw7AklTlFYIa0bIp9BgSm1S8Y=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.15.0 h1:h1V/4gjBv8v9cjcR6+AR5+/cIYK5N/WAgiv4xlsEtAk=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=\ngolang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=\ngolang.org/x/tools v0.21.0 h1:qc0xYgIbsSDt9EyWz05J5wfa7LOVW0YTLOXrqdLAWIw=\ngolang.org/x/tools v0.21.0/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20231002182017-d307bd883b97 h1:W18sezcAYs+3tDZX4F80yctqa12jcP1PUS2gQu1zTPU=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20231002182017-d307bd883b97/go.mod h1:iargEX0SFPm3xcfMI0d1domjg0ZF4Aa0p2awqyxhvF0=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20231002182017-d307bd883b97 h1:6GQBEOdGkX6MMTLT9V+TjtIRZCw9VPD5Z+yHY9wMgS0=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20231002182017-d307bd883b97/go.mod h1:v7nGkzlmW8P3n/bKmWBn2WpBjpOEx8Q6gMueudAmKfY=\ngoogle.golang.org/grpc v1.60.1 h1:26+wFr+cNqSGFcOXcabYC0lUVJVRa2Sb2ortSK7VrEU=\ngoogle.golang.org/grpc v1.60.1/go.mod h1:OlCHIeLYqSSsLi6i49B5QGdzaMZK9+M7LXN2FKz4eGM=\ngoogle.golang.org/protobuf v1.32.0 h1:pPC6BG5ex8PDFnkbrGU3EixyhKcQ2aDuBS36lqK/C7I=\ngoogle.golang.org/protobuf v1.32.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.8 h1:obN1ZagJSUGI0Ek/LBmuj4SNLPfIny3KsKFopxRdj10=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngotest.tools/v3 v3.5.1 h1:EENdUnS3pdur5nybKYIh2Vfgc8IUNBjxDPSjtiJcOzU=\ngotest.tools/v3 v3.5.1/go.mod h1:isy3WKz7GK6uNw/sbHzfKBLvlvXwUyV06n6brMxxopU=\nnhooyr.io/websocket v1.8.7 h1:usjR2uOr/zjjkVMy0lW+PPohFok7PCow5sDjLgX4P4g=\nnhooyr.io/websocket v1.8.7/go.mod h1:B70DZP8IakI65RVQ51MsWP/8jndNma26DVA/nFSCgW0=\n"
        },
        {
          "name": "info",
          "type": "tree",
          "content": null
        },
        {
          "name": "jsonerror",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 14.53515625,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/aerokube/selenoid/info\"\n\t\"github.com/docker/docker/api\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\tggr \"github.com/aerokube/ggr/config\"\n\t\"github.com/aerokube/selenoid/config\"\n\t\"github.com/aerokube/selenoid/jsonerror\"\n\t\"github.com/aerokube/selenoid/protect\"\n\t\"github.com/aerokube/selenoid/service\"\n\t\"github.com/aerokube/selenoid/session\"\n\t\"github.com/aerokube/selenoid/upload\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/websocket\"\n)\n\nvar (\n\thostname                 string\n\tdisableDocker            bool\n\tdisableQueue             bool\n\tenableFileUpload         bool\n\tlisten                   string\n\ttimeout                  time.Duration\n\tmaxTimeout               time.Duration\n\tnewSessionAttemptTimeout time.Duration\n\tsessionDeleteTimeout     time.Duration\n\tserviceStartupTimeout    time.Duration\n\tgracefulPeriod           time.Duration\n\tlimit                    int\n\tretryCount               int\n\tcontainerNetwork         string\n\tsessions                 = session.NewMap()\n\tconfPath                 string\n\tlogConfPath              string\n\tcaptureDriverLogs        bool\n\tdisablePrivileged        bool\n\tvideoOutputDir           string\n\tvideoRecorderImage       string\n\tlogOutputDir             string\n\tsaveAllLogs              bool\n\tggrHost                  *ggr.Host\n\tconf                     *config.Config\n\tqueue                    *protect.Queue\n\tmanager                  service.Manager\n\tcli                      *client.Client\n\n\tstartTime = time.Now()\n\n\tversion     bool\n\tgitRevision = \"HEAD\"\n\tbuildStamp  = \"unknown\"\n)\n\nfunc init() {\n\tvar mem service.MemLimit\n\tvar cpu service.CpuLimit\n\tflag.BoolVar(&disableDocker, \"disable-docker\", false, \"Disable docker support\")\n\tflag.BoolVar(&disableQueue, \"disable-queue\", false, \"Disable wait queue\")\n\tflag.BoolVar(&enableFileUpload, \"enable-file-upload\", false, \"File upload support\")\n\tflag.StringVar(&listen, \"listen\", \":4444\", \"Network address to accept connections\")\n\tflag.StringVar(&confPath, \"conf\", \"config/browsers.json\", \"Browsers configuration file\")\n\tflag.StringVar(&logConfPath, \"log-conf\", \"\", \"Container logging configuration file\")\n\tflag.IntVar(&limit, \"limit\", 5, \"Simultaneous container runs\")\n\tflag.IntVar(&retryCount, \"retry-count\", 1, \"New session attempts retry count\")\n\tflag.DurationVar(&timeout, \"timeout\", 60*time.Second, \"Session idle timeout in time.Duration format\")\n\tflag.DurationVar(&maxTimeout, \"max-timeout\", 1*time.Hour, \"Maximum valid session idle timeout in time.Duration format\")\n\tflag.DurationVar(&newSessionAttemptTimeout, \"session-attempt-timeout\", 30*time.Second, \"New session attempt timeout in time.Duration format\")\n\tflag.DurationVar(&sessionDeleteTimeout, \"session-delete-timeout\", 30*time.Second, \"Session delete timeout in time.Duration format\")\n\tflag.DurationVar(&serviceStartupTimeout, \"service-startup-timeout\", 30*time.Second, \"Service startup timeout in time.Duration format\")\n\tflag.BoolVar(&version, \"version\", false, \"Show version and exit\")\n\tflag.Var(&mem, \"mem\", \"Containers memory limit e.g. 128m or 1g\")\n\tflag.Var(&cpu, \"cpu\", \"Containers cpu limit as float e.g. 0.2 or 1.0\")\n\tflag.StringVar(&containerNetwork, \"container-network\", service.DefaultContainerNetwork, \"Network to be used for containers\")\n\tflag.BoolVar(&captureDriverLogs, \"capture-driver-logs\", false, \"Whether to add driver process logs to Selenoid output\")\n\tflag.BoolVar(&disablePrivileged, \"disable-privileged\", false, \"Whether to disable privileged container mode\")\n\tflag.StringVar(&videoOutputDir, \"video-output-dir\", \"video\", \"Directory to save recorded video to\")\n\tflag.StringVar(&videoRecorderImage, \"video-recorder-image\", \"selenoid/video-recorder:latest-release\", \"Image to use as video recorder\")\n\tflag.StringVar(&logOutputDir, \"log-output-dir\", \"\", \"Directory to save session log to\")\n\tflag.BoolVar(&saveAllLogs, \"save-all-logs\", false, \"Whether to save all logs without considering capabilities\")\n\tflag.DurationVar(&gracefulPeriod, \"graceful-period\", 300*time.Second, \"graceful shutdown period in time.Duration format, e.g. 300s or 500ms\")\n\tflag.Parse()\n\n\tif version {\n\t\tshowVersion()\n\t\tos.Exit(0)\n\t}\n\n\tvar err error\n\thostname, err = os.Hostname()\n\tif err != nil {\n\t\tlog.Fatalf(\"[-] [INIT] [%s: %v]\", os.Args[0], err)\n\t}\n\tif ggrHostEnv := os.Getenv(\"GGR_HOST\"); ggrHostEnv != \"\" {\n\t\tggrHost = parseGgrHost(ggrHostEnv)\n\t}\n\tqueue = protect.New(limit, disableQueue)\n\tconf = config.NewConfig()\n\terr = conf.Load(confPath, logConfPath)\n\tif err != nil {\n\t\tlog.Fatalf(\"[-] [INIT] [%s: %v]\", os.Args[0], err)\n\t}\n\tonSIGHUP(func() {\n\t\terr := conf.Load(confPath, logConfPath)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[-] [INIT] [%s: %v]\", os.Args[0], err)\n\t\t}\n\t})\n\tinDocker := false\n\t_, err = os.Stat(\"/.dockerenv\")\n\tif err == nil {\n\t\tinDocker = true\n\t}\n\n\tif !disableDocker {\n\t\tvideoOutputDir, err = filepath.Abs(videoOutputDir)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"[-] [INIT] [Invalid video output dir %s: %v]\", videoOutputDir, err)\n\t\t}\n\t\terr = os.MkdirAll(videoOutputDir, os.FileMode(0644))\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"[-] [INIT] [Failed to create video output dir %s: %v]\", videoOutputDir, err)\n\t\t}\n\t\tlog.Printf(\"[-] [INIT] [Video Dir: %s]\", videoOutputDir)\n\t}\n\tif logOutputDir != \"\" {\n\t\tlogOutputDir, err = filepath.Abs(logOutputDir)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"[-] [INIT] [Invalid log output dir %s: %v]\", logOutputDir, err)\n\t\t}\n\t\terr = os.MkdirAll(logOutputDir, os.FileMode(0644))\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"[-] [INIT] [Failed to create log output dir %s: %v]\", logOutputDir, err)\n\t\t}\n\t\tlog.Printf(\"[-] [INIT] [Logs Dir: %s]\", logOutputDir)\n\t\tif saveAllLogs {\n\t\t\tlog.Printf(\"[-] [INIT] [Saving all logs]\")\n\t\t}\n\t}\n\n\tupload.Init()\n\n\tenvironment := service.Environment{\n\t\tInDocker:             inDocker,\n\t\tCPU:                  int64(cpu),\n\t\tMemory:               int64(mem),\n\t\tNetwork:              containerNetwork,\n\t\tStartupTimeout:       serviceStartupTimeout,\n\t\tSessionDeleteTimeout: sessionDeleteTimeout,\n\t\tCaptureDriverLogs:    captureDriverLogs,\n\t\tVideoOutputDir:       videoOutputDir,\n\t\tVideoContainerImage:  videoRecorderImage,\n\t\tLogOutputDir:         logOutputDir,\n\t\tSaveAllLogs:          saveAllLogs,\n\t\tPrivileged:           !disablePrivileged,\n\t}\n\tif disableDocker {\n\t\tmanager = &service.DefaultManager{Environment: &environment, Config: conf}\n\t\tif logOutputDir != \"\" && captureDriverLogs {\n\t\t\tlog.Fatalf(\"[-] [INIT] [In drivers mode only one of -capture-driver-logs and -log-output-dir flags is allowed]\")\n\t\t}\n\t\treturn\n\t}\n\tdockerHost := os.Getenv(\"DOCKER_HOST\")\n\tif dockerHost == \"\" {\n\t\tdockerHost = client.DefaultDockerHost\n\t}\n\tu, err := client.ParseHostURL(dockerHost)\n\tif err != nil {\n\t\tlog.Fatalf(\"[-] [INIT] [%v]\", err)\n\t}\n\tip, _, _ := net.SplitHostPort(u.Host)\n\tenvironment.IP = ip\n\tcli, err = createCompatibleDockerClient(\n\t\tfunc(specifiedApiVersion string) {\n\t\t\tlog.Printf(\"[-] [INIT] [Using Docker API version: %s]\", specifiedApiVersion)\n\t\t},\n\t\tfunc(determinedApiVersion string) {\n\t\t\tlog.Printf(\"[-] [INIT] [Your Docker API version is %s]\", determinedApiVersion)\n\t\t},\n\t\tfunc(defaultApiVersion string) {\n\t\t\tlog.Printf(\"[-] [INIT] [Did not manage to determine your Docker API version - using default version: %s]\", defaultApiVersion)\n\t\t},\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"[-] [INIT] [New docker client: %v]\", err)\n\t}\n\tmanager = &service.DefaultManager{Environment: &environment, Client: cli, Config: conf}\n}\n\nfunc createCompatibleDockerClient(onVersionSpecified, onVersionDetermined, onUsingDefaultVersion func(string)) (*client.Client, error) {\n\tconst dockerApiVersion = \"DOCKER_API_VERSION\"\n\tdockerApiVersionEnv := os.Getenv(dockerApiVersion)\n\tif dockerApiVersionEnv != \"\" {\n\t\tonVersionSpecified(dockerApiVersionEnv)\n\t} else {\n\t\tmaxMajorVersion, maxMinorVersion := parseVersion(api.DefaultVersion)\n\t\tminMajorVersion, minMinorVersion := parseVersion(\"1.24\")\n\t\tfor majorVersion := maxMajorVersion; majorVersion >= minMajorVersion; majorVersion-- {\n\t\t\tfor minorVersion := maxMinorVersion; minorVersion >= minMinorVersion; minorVersion-- {\n\t\t\t\tapiVersion := fmt.Sprintf(\"%d.%d\", majorVersion, minorVersion)\n\t\t\t\t_ = os.Setenv(dockerApiVersion, apiVersion)\n\t\t\t\tdocker, err := client.NewClientWithOpts(client.FromEnv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif isDockerAPIVersionCorrect(docker) {\n\t\t\t\t\tonVersionDetermined(apiVersion)\n\t\t\t\t\treturn docker, nil\n\t\t\t\t}\n\t\t\t\t_ = docker.Close()\n\t\t\t}\n\t\t}\n\t\tonUsingDefaultVersion(api.DefaultVersion)\n\t}\n\treturn client.NewClientWithOpts(client.FromEnv)\n}\n\nfunc parseVersion(ver string) (int, int) {\n\tconst point = \".\"\n\tpieces := strings.Split(ver, point)\n\tmajor, err := strconv.Atoi(pieces[0])\n\tif err != nil {\n\t\treturn 0, 0\n\t}\n\tminor, err := strconv.Atoi(pieces[1])\n\tif err != nil {\n\t\treturn 0, 0\n\t}\n\treturn major, minor\n}\n\nfunc isDockerAPIVersionCorrect(docker *client.Client) bool {\n\tctx := context.Background()\n\tapiInfo, err := docker.ServerVersion(ctx)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn apiInfo.APIVersion == docker.ClientVersion()\n}\n\nfunc parseGgrHost(s string) *ggr.Host {\n\th, p, err := net.SplitHostPort(s)\n\tif err != nil {\n\t\tlog.Fatalf(\"[-] [INIT] [Invalid Ggr host: %v]\", err)\n\t}\n\tggrPort, err := strconv.Atoi(p)\n\tif err != nil {\n\t\tlog.Fatalf(\"[-] [INIT] [Invalid Ggr host: %v]\", err)\n\t}\n\thost := &ggr.Host{\n\t\tName: h,\n\t\tPort: ggrPort,\n\t}\n\tlog.Printf(\"[-] [INIT] [Will prefix all session IDs with a hash-sum: %s]\", host.Sum())\n\treturn host\n}\n\nfunc onSIGHUP(fn func()) {\n\tsig := make(chan os.Signal)\n\tsignal.Notify(sig, syscall.SIGHUP)\n\tgo func() {\n\t\tfor {\n\t\t\t<-sig\n\t\t\tfn()\n\t\t}\n\t}()\n}\n\nvar seleniumPaths = struct {\n\tCreateSession, ProxySession string\n}{\n\tCreateSession: \"/session\",\n\tProxySession:  \"/session/\",\n}\n\nfunc selenium() http.Handler {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(seleniumPaths.CreateSession, post(queue.Try(queue.Check(queue.Protect(create)))))\n\tmux.HandleFunc(seleniumPaths.ProxySession, proxy)\n\tmux.HandleFunc(paths.Status, status)\n\tmux.HandleFunc(paths.Welcome, welcome)\n\treturn mux\n}\n\nfunc post(next http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n\nfunc ping(w http.ResponseWriter, _ *http.Request) {\n\tw.Header().Add(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(struct {\n\t\tUptime         string `json:\"uptime\"`\n\t\tLastReloadTime string `json:\"lastReloadTime\"`\n\t\tNumRequests    uint64 `json:\"numRequests\"`\n\t\tVersion        string `json:\"version\"`\n\t}{time.Since(startTime).String(), conf.LastReloadTime.Format(time.RFC3339), getSerial(), gitRevision})\n}\n\nfunc video(w http.ResponseWriter, r *http.Request) {\n\trequestId := serial()\n\tif r.Method == http.MethodDelete {\n\t\tdeleteFileIfExists(requestId, w, r, videoOutputDir, paths.Video, \"DELETED_VIDEO_FILE\")\n\t\treturn\n\t}\n\tuser, remote := info.RequestInfo(r)\n\tif _, ok := r.URL.Query()[jsonParam]; ok {\n\t\tlistFilesAsJson(requestId, w, videoOutputDir, \"VIDEO_ERROR\")\n\t\treturn\n\t}\n\tlog.Printf(\"[%d] [VIDEO_LISTING] [%s] [%s]\", requestId, user, remote)\n\tfileServer := http.StripPrefix(paths.Video, http.FileServer(http.Dir(videoOutputDir)))\n\tfileServer.ServeHTTP(w, r)\n}\n\nfunc deleteFileIfExists(requestId uint64, w http.ResponseWriter, r *http.Request, dir string, prefix string, status string) {\n\tuser, remote := info.RequestInfo(r)\n\tfileName := strings.TrimPrefix(r.URL.Path, prefix)\n\tfilePath := filepath.Join(dir, fileName)\n\t_, err := os.Stat(filePath)\n\tif err != nil {\n\t\thttp.Error(w, fmt.Sprintf(\"Unknown file %s\", filePath), http.StatusNotFound)\n\t\treturn\n\t}\n\terr = os.Remove(filePath)\n\tif err != nil {\n\t\thttp.Error(w, fmt.Sprintf(\"Failed to delete file %s: %v\", filePath, err), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tlog.Printf(\"[%d] [%s] [%s] [%s] [%s]\", requestId, status, user, remote, fileName)\n}\n\nvar paths = struct {\n\tVideo, VNC, Logs, Devtools, Download, Clipboard, File, Ping, Status, Error, WdHub, Welcome string\n}{\n\tVideo:     \"/video/\",\n\tVNC:       \"/vnc/\",\n\tLogs:      \"/logs/\",\n\tDevtools:  \"/devtools/\",\n\tDownload:  \"/download/\",\n\tClipboard: \"/clipboard/\",\n\tStatus:    \"/status\",\n\tFile:      \"/file\",\n\tPing:      \"/ping\",\n\tError:     \"/error\",\n\tWdHub:     \"/wd/hub\",\n\tWelcome:   \"/\",\n}\n\nfunc handler() http.Handler {\n\troot := http.NewServeMux()\n\troot.HandleFunc(paths.WdHub+\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Add(\"Content-Type\", \"application/json\")\n\t\tr.URL.Scheme = \"http\"\n\t\tr.URL.Host = (&request{r}).localaddr()\n\t\tr.URL.Path = strings.TrimPrefix(r.URL.Path, paths.WdHub)\n\t\tselenium().ServeHTTP(w, r)\n\t})\n\troot.HandleFunc(paths.Error, func(w http.ResponseWriter, r *http.Request) {\n\t\tjsonerror.InvalidSessionID(errors.New(\"session timed out or not found\")).Encode(w)\n\t})\n\troot.HandleFunc(paths.Status, func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Add(\"Content-Type\", \"application/json\")\n\t\t_ = json.NewEncoder(w).Encode(conf.State(sessions, limit, queue.Queued(), queue.Pending()))\n\t})\n\troot.HandleFunc(paths.Ping, ping)\n\troot.Handle(paths.VNC, websocket.Handler(vnc))\n\troot.HandleFunc(paths.Logs, logs)\n\troot.HandleFunc(paths.Video, video)\n\troot.HandleFunc(paths.Download, reverseProxy(func(sess *session.Session) string { return sess.HostPort.Fileserver }, \"DOWNLOADING_FILE\"))\n\troot.HandleFunc(paths.Clipboard, reverseProxy(func(sess *session.Session) string { return sess.HostPort.Clipboard }, \"CLIPBOARD\"))\n\troot.HandleFunc(paths.Devtools, reverseProxy(func(sess *session.Session) string { return sess.HostPort.Devtools }, \"DEVTOOLS\"))\n\tif enableFileUpload {\n\t\troot.HandleFunc(paths.File, fileUpload)\n\t}\n\troot.HandleFunc(paths.Welcome, welcome)\n\treturn root\n}\n\nfunc showVersion() {\n\tfmt.Printf(\"Git Revision: %s\\n\", gitRevision)\n\tfmt.Printf(\"UTC Build Time: %s\\n\", buildStamp)\n}\n\nfunc main() {\n\tlog.Printf(\"[-] [INIT] [Timezone: %s]\", time.Local)\n\tlog.Printf(\"[-] [INIT] [Listening on %s]\", listen)\n\n\tstop := make(chan os.Signal)\n\tsignal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)\n\n\tserver := &http.Server{\n\t\tAddr:    listen,\n\t\tHandler: handler(),\n\t}\n\te := make(chan error)\n\tgo func() {\n\t\te <- server.ListenAndServe()\n\t}()\n\tselect {\n\tcase err := <-e:\n\t\tlog.Fatalf(\"[-] [INIT] [Failed to start: %v]\", err)\n\tcase <-stop:\n\t}\n\n\tlog.Printf(\"[-] [SHUTTING_DOWN] [%s]\", gracefulPeriod)\n\tctx, cancel := context.WithTimeout(context.Background(), gracefulPeriod)\n\tdefer cancel()\n\tif err := server.Shutdown(ctx); err != nil {\n\t\tlog.Fatalf(\"[-] [SHUTTING_DOWN] [Failed to shut down: %v]\", err)\n\t}\n\n\tsessions.Each(func(k string, s *session.Session) {\n\t\tif enableFileUpload {\n\t\t\t_ = os.RemoveAll(path.Join(os.TempDir(), k))\n\t\t}\n\t\ts.Cancel()\n\t})\n\n\tif !disableDocker {\n\t\terr := cli.Close()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"[-] [SHUTTING_DOWN] [Error closing Docker client: %v]\", err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "metadata.go",
          "type": "blob",
          "size": 1.443359375,
          "content": "//go:build metadata\n// +build metadata\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/aerokube/selenoid/event\"\n\t\"github.com/aerokube/selenoid/session\"\n)\n\nconst metadataFileExtension = \".json\"\n\nfunc init() {\n\tmp := &MetadataProcessor{}\n\tevent.AddSessionStoppedListener(mp)\n\tlog.Println(\"[-] [INIT] [Will save sessions metadata]\")\n}\n\ntype MetadataProcessor struct {\n}\n\nfunc (mp *MetadataProcessor) OnSessionStopped(stoppedSession event.StoppedSession) {\n\tif logOutputDir != \"\" {\n\t\tmeta := session.Metadata{\n\t\t\tID:           stoppedSession.SessionId,\n\t\t\tStarted:      stoppedSession.Session.Started,\n\t\t\tFinished:     time.Now(),\n\t\t\tCapabilities: stoppedSession.Session.Caps,\n\t\t}\n\t\tdata, err := json.MarshalIndent(meta, \"\", \"    \")\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[%d] [METADATA] [%s] [Failed to marshal: %v]\", stoppedSession.RequestId, stoppedSession.SessionId, err)\n\t\t\treturn\n\t\t}\n\t\tfilename := filepath.Join(logOutputDir, stoppedSession.SessionId+metadataFileExtension)\n\t\terr = os.WriteFile(filename, data, 0644)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[%d] [METADATA] [%s] [Failed to save to %s: %v]\", stoppedSession.RequestId, stoppedSession.SessionId, filename, err)\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"[%d] [METADATA] [%s] [%s]\", stoppedSession.RequestId, stoppedSession.SessionId, filename)\n\t\tcreatedFile := event.CreatedFile{\n\t\t\tEvent: stoppedSession.Event,\n\t\t\tName:  filename,\n\t\t\tType:  \"metadata\",\n\t\t}\n\t\tevent.FileCreated(createdFile)\n\t}\n}\n"
        },
        {
          "name": "protect",
          "type": "tree",
          "content": null
        },
        {
          "name": "s3_test.go",
          "type": "blob",
          "size": 3.466796875,
          "content": "//go:build s3\n// +build s3\n\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aerokube/selenoid/event\"\n\t\"github.com/aerokube/selenoid/session\"\n\t\"github.com/aerokube/selenoid/upload\"\n\tassert \"github.com/stretchr/testify/require\"\n)\n\nvar (\n\ts3Srv *httptest.Server\n)\n\nfunc init() {\n\ts3Srv = httptest.NewServer(s3Mux())\n\tdialer := &net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 30 * time.Second,\n\t\tDualStack: true,\n\t}\n\thttp.DefaultTransport.(*http.Transport).DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\tif strings.Contains(addr, \"s3-mock.example.com\") {\n\t\t\taddr = s3Srv.Listener.Addr().String()\n\t\t}\n\t\treturn dialer.DialContext(ctx, network, addr)\n\t}\n}\n\nfunc s3Mux() http.Handler {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(_ http.ResponseWriter, _ *http.Request) {})\n\treturn mux\n}\n\nvar testSession = &session.Session{\n\tQuota: \"some-user\",\n\tCaps: session.Caps{\n\t\tName:     \"internet explorer\",\n\t\tVersion:  \"11\",\n\t\tPlatform: \"WINDOWS\",\n\t},\n}\n\nfunc TestS3Uploader(t *testing.T) {\n\tuploader := &upload.S3Uploader{\n\t\tEndpoint:          \"http://s3-mock.example.com\",\n\t\tRegion:            \"us-west-1\",\n\t\tAccessKey:         \"some-access-key\",\n\t\tSecretKey:         \"some-secret-key\",\n\t\tBucketName:        \"test-bucket\",\n\t\tKeyPattern:        \"$fileName\",\n\t\tReducedRedundancy: true,\n\t}\n\tuploader.Init()\n\tf, _ := os.CreateTemp(\"\", \"some-file\")\n\tinput := event.CreatedFile{\n\t\tEvent: event.Event{\n\t\t\tRequestId: 4342,\n\t\t\tSessionId: \"some-session-id\",\n\t\t\tSession:   testSession,\n\t\t},\n\t\tName: f.Name(),\n\t\tType: \"log\",\n\t}\n\tuploaded, err := uploader.Upload(input)\n\tassert.NoError(t, err)\n\tassert.True(t, uploaded)\n}\n\nfunc TestGetKey(t *testing.T) {\n\tconst testPattern = \"$quota/$sessionId_$browserName_$browserVersion_$platformName/$fileType$fileExtension\"\n\tinput := event.CreatedFile{\n\t\tEvent: event.Event{\n\t\t\tSessionId: \"some-Session-id\",\n\t\t\tSession:   testSession,\n\t\t\tRequestId: 12345,\n\t\t},\n\n\t\tName: \"/path/to/Some-File.txt\",\n\t\tType: \"log\",\n\t}\n\n\tkey := upload.GetS3Key(testPattern, input)\n\tassert.Equal(t, key, \"some-user/some-Session-id_internet-explorer_11_windows/log.txt\")\n\n\tinput.Session.Caps.Name = \"\"\n\tinput.Session.Caps.DeviceName = \"internet explorer\"\n\tkey = upload.GetS3Key(testPattern, input)\n\tassert.Equal(t, key, \"some-user/some-Session-id_internet-explorer_11_windows/log.txt\")\n\n\tinput.Session.Caps.S3KeyPattern = \"$quota/$fileType$fileExtension\"\n\tkey = upload.GetS3Key(testPattern, input)\n\tassert.Equal(t, key, \"some-user/log.txt\")\n\n\tinput.Session.Caps.S3KeyPattern = \"$fileName\"\n\tkey = upload.GetS3Key(testPattern, input)\n\tassert.Equal(t, key, \"Some-File.txt\")\n}\n\nfunc TestFileMatches(t *testing.T) {\n\tmatches, err := upload.FileMatches(\"\", \"\", \"any-file-name\")\n\tassert.NoError(t, err)\n\tassert.True(t, matches)\n\n\tmatches, err = upload.FileMatches(\"[\", \"\", \"/path/to/file.mp4\")\n\tassert.Error(t, err)\n\tassert.False(t, matches)\n\n\tmatches, err = upload.FileMatches(\"\", \"[\", \"/path/to/file.mp4\")\n\tassert.Error(t, err)\n\tassert.False(t, matches)\n\n\tmatches, err = upload.FileMatches(\"*.mp4\", \"\", \"/path/to/file.mp4\")\n\tassert.NoError(t, err)\n\tassert.True(t, matches)\n\n\tmatches, err = upload.FileMatches(\"*.mp4\", \"\", \"/path/to/file.log\")\n\tassert.NoError(t, err)\n\tassert.False(t, matches)\n\n\tmatches, err = upload.FileMatches(\"*.mp4\", \"\", \"/path/to/file.log\")\n\tassert.NoError(t, err)\n\tassert.False(t, matches)\n\n\tmatches, err = upload.FileMatches(\"\", \"*.log\", \"/path/to/file.log\")\n\tassert.NoError(t, err)\n\tassert.False(t, matches)\n}\n"
        },
        {
          "name": "selenoid.go",
          "type": "blob",
          "size": 22.2568359375,
          "content": "package main\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/aerokube/selenoid/info\"\n\n\t\"github.com/aerokube/selenoid/event\"\n\t\"github.com/aerokube/selenoid/jsonerror\"\n\t\"github.com/aerokube/selenoid/service\"\n\t\"github.com/aerokube/selenoid/session\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/pkg/stdcopy\"\n\t\"github.com/imdario/mergo\"\n\t\"golang.org/x/net/websocket\"\n)\n\nconst slash = \"/\"\n\nvar (\n\thttpClient = &http.Client{\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\treturn http.ErrUseLastResponse\n\t\t},\n\t}\n\tnum     uint64\n\tnumLock sync.RWMutex\n)\n\ntype request struct {\n\t*http.Request\n}\n\ntype sess struct {\n\taddr string\n\tid   string\n}\n\n// TODO There is simpler way to do this\nfunc (r request) localaddr() string {\n\taddr := r.Context().Value(http.LocalAddrContextKey).(net.Addr).String()\n\t_, port, _ := net.SplitHostPort(addr)\n\treturn net.JoinHostPort(\"127.0.0.1\", port)\n}\n\nfunc (r request) session(id string) *sess {\n\treturn &sess{r.localaddr(), id}\n}\n\nfunc (s *sess) url() string {\n\treturn fmt.Sprintf(\"http://%s/wd/hub/session/%s\", s.addr, s.id)\n}\n\nfunc (s *sess) Delete(requestId uint64) {\n\tlog.Printf(\"[%d] [SESSION_TIMED_OUT] [%s]\", requestId, s.id)\n\tr, err := http.NewRequest(http.MethodDelete, s.url(), nil)\n\tif err != nil {\n\t\tlog.Printf(\"[%d] [DELETE_FAILED] [%s] [%v]\", requestId, s.id, err)\n\t\treturn\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), sessionDeleteTimeout)\n\tdefer cancel()\n\tresp, err := httpClient.Do(r.WithContext(ctx))\n\tif resp != nil {\n\t\tdefer resp.Body.Close()\n\t}\n\tif err == nil && resp.StatusCode == http.StatusOK {\n\t\treturn\n\t}\n\tif err != nil {\n\t\tlog.Printf(\"[%d] [DELETE_FAILED] [%s] [%v]\", requestId, s.id, err)\n\t} else {\n\t\tlog.Printf(\"[%d] [DELETE_FAILED] [%s] [%s]\", requestId, s.id, resp.Status)\n\t}\n}\n\nfunc serial() uint64 {\n\tnumLock.Lock()\n\tdefer numLock.Unlock()\n\tid := num\n\tnum++\n\treturn id\n}\n\nfunc getSerial() uint64 {\n\tnumLock.RLock()\n\tdefer numLock.RUnlock()\n\treturn num\n}\n\nfunc create(w http.ResponseWriter, r *http.Request) {\n\tsessionStartTime := time.Now()\n\trequestId := serial()\n\tuser, remote := info.RequestInfo(r)\n\tbody, err := io.ReadAll(r.Body)\n\t_ = r.Body.Close()\n\tif err != nil {\n\t\tlog.Printf(\"[%d] [ERROR_READING_REQUEST] [%v]\", requestId, err)\n\t\tjsonerror.InvalidArgument(err).Encode(w)\n\t\tqueue.Drop()\n\t\treturn\n\t}\n\tvar browser struct {\n\t\tCaps    session.Caps `json:\"desiredCapabilities\"`\n\t\tW3CCaps struct {\n\t\t\tCaps       session.Caps    `json:\"alwaysMatch\"`\n\t\t\tFirstMatch []*session.Caps `json:\"firstMatch\"`\n\t\t} `json:\"capabilities\"`\n\t}\n\terr = json.Unmarshal(body, &browser)\n\tif err != nil {\n\t\tlog.Printf(\"[%d] [BAD_JSON_FORMAT] [%v]\", requestId, err)\n\t\tjsonerror.InvalidArgument(err).Encode(w)\n\t\tqueue.Drop()\n\t\treturn\n\t}\n\tif browser.W3CCaps.Caps.BrowserName() != \"\" && browser.Caps.BrowserName() == \"\" {\n\t\tbrowser.Caps = browser.W3CCaps.Caps\n\t}\n\tfirstMatchCaps := browser.W3CCaps.FirstMatch\n\tif len(firstMatchCaps) == 0 {\n\t\tfirstMatchCaps = append(firstMatchCaps, &session.Caps{})\n\t}\n\tvar caps session.Caps\n\tvar starter service.Starter\n\tvar ok bool\n\tvar sessionTimeout time.Duration\n\tvar finalVideoName, finalLogName string\n\tfor _, fmc := range firstMatchCaps {\n\t\tcaps = browser.Caps\n\t\t_ = mergo.Merge(&caps, *fmc)\n\t\tcaps.ProcessExtensionCapabilities()\n\t\tsessionTimeout, err = getSessionTimeout(caps.SessionTimeout, maxTimeout, timeout)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[%d] [BAD_SESSION_TIMEOUT] [%s]\", requestId, caps.SessionTimeout)\n\t\t\tjsonerror.InvalidArgument(err).Encode(w)\n\t\t\tqueue.Drop()\n\t\t\treturn\n\t\t}\n\t\tresolution, err := getScreenResolution(caps.ScreenResolution)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[%d] [BAD_SCREEN_RESOLUTION] [%s]\", requestId, caps.ScreenResolution)\n\t\t\tjsonerror.InvalidArgument(err).Encode(w)\n\t\t\tqueue.Drop()\n\t\t\treturn\n\t\t}\n\t\tcaps.ScreenResolution = resolution\n\t\tvideoScreenSize, err := getVideoScreenSize(caps.VideoScreenSize, resolution)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[%d] [BAD_VIDEO_SCREEN_SIZE] [%s]\", requestId, caps.VideoScreenSize)\n\t\t\tjsonerror.InvalidArgument(err).Encode(w)\n\t\t\tqueue.Drop()\n\t\t\treturn\n\t\t}\n\t\tcaps.VideoScreenSize = videoScreenSize\n\t\tfinalVideoName = caps.VideoName\n\t\tif caps.Video && !disableDocker {\n\t\t\tcaps.VideoName = getTemporaryFileName(videoOutputDir, videoFileExtension)\n\t\t}\n\t\tfinalLogName = caps.LogName\n\t\tif logOutputDir != \"\" && (saveAllLogs || caps.Log) {\n\t\t\tcaps.LogName = getTemporaryFileName(logOutputDir, logFileExtension)\n\t\t}\n\t\tstarter, ok = manager.Find(caps, requestId)\n\t\tif ok {\n\t\t\tbreak\n\t\t}\n\t}\n\tif !ok {\n\t\tlog.Printf(\"[%d] [ENVIRONMENT_NOT_AVAILABLE] [%s] [%s]\", requestId, caps.BrowserName(), caps.Version)\n\t\tjsonerror.InvalidArgument(errors.New(\"Requested environment is not available\")).Encode(w)\n\t\tqueue.Drop()\n\t\treturn\n\t}\n\tstartedService, err := starter.StartWithCancel()\n\tif err != nil {\n\t\tlog.Printf(\"[%d] [SERVICE_STARTUP_FAILED] [%v]\", requestId, err)\n\t\tjsonerror.SessionNotCreated(err).Encode(w)\n\t\tqueue.Drop()\n\t\treturn\n\t}\n\tu := startedService.Url\n\tcancel := startedService.Cancel\n\thost := \"localhost\"\n\tif startedService.Origin != \"\" {\n\t\thost = startedService.Origin\n\t}\n\n\tvar resp *http.Response\n\ti := 1\n\tfor ; ; i++ {\n\t\tr.URL.Host, r.URL.Path = u.Host, path.Join(u.Path, r.URL.Path)\n\t\tnewBody := removeSelenoidOptions(body)\n\t\treq, _ := http.NewRequest(http.MethodPost, r.URL.String(), bytes.NewReader(newBody))\n\t\tcontentType := r.Header.Get(\"Content-Type\")\n\t\tif len(contentType) > 0 {\n\t\t\treq.Header.Set(\"Content-Type\", contentType)\n\t\t}\n\t\treq.Host = host\n\t\tctx, done := context.WithTimeout(r.Context(), newSessionAttemptTimeout)\n\t\tdefer done()\n\t\tlog.Printf(\"[%d] [SESSION_ATTEMPTED] [%s] [%d]\", requestId, u.String(), i)\n\t\trsp, err := httpClient.Do(req.WithContext(ctx))\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tif rsp != nil {\n\t\t\t\t_ = rsp.Body.Close()\n\t\t\t}\n\t\t\tswitch ctx.Err() {\n\t\t\tcase context.DeadlineExceeded:\n\t\t\t\tlog.Printf(\"[%d] [SESSION_ATTEMPT_TIMED_OUT] [%s]\", requestId, newSessionAttemptTimeout)\n\t\t\t\tif i < retryCount {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\terr := fmt.Errorf(\"New session attempts retry count exceeded\")\n\t\t\t\tlog.Printf(\"[%d] [SESSION_FAILED] [%s] [%s]\", requestId, u.String(), err)\n\t\t\t\tjsonerror.UnknownError(err).Encode(w)\n\t\t\tcase context.Canceled:\n\t\t\t\tlog.Printf(\"[%d] [CLIENT_DISCONNECTED] [%s] [%s] [%.2fs]\", requestId, user, remote, info.SecondsSince(sessionStartTime))\n\t\t\t}\n\t\t\tqueue.Drop()\n\t\t\tcancel()\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t\tif err != nil {\n\t\t\tif rsp != nil {\n\t\t\t\t_ = rsp.Body.Close()\n\t\t\t}\n\t\t\tlog.Printf(\"[%d] [SESSION_FAILED] [%s] [%s]\", requestId, u.String(), err)\n\t\t\tjsonerror.SessionNotCreated(err).Encode(w)\n\t\t\tqueue.Drop()\n\t\t\tcancel()\n\t\t\treturn\n\t\t}\n\t\tif rsp.StatusCode == http.StatusNotFound && u.Path == \"\" {\n\t\t\tu.Path = \"/wd/hub\"\n\t\t\tcontinue\n\t\t}\n\t\tresp = rsp\n\t\tbreak\n\t}\n\tdefer resp.Body.Close()\n\tvar s struct {\n\t\tValue struct {\n\t\t\tID string `json:\"sessionId\"`\n\t\t}\n\t\tID string `json:\"sessionId\"`\n\t}\n\tlocation := resp.Header.Get(\"Location\")\n\tif location != \"\" {\n\t\tl, err := url.Parse(location)\n\t\tif err == nil {\n\t\t\tfragments := strings.Split(l.Path, slash)\n\t\t\ts.ID = fragments[len(fragments)-1]\n\t\t\tu := &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   hostname,\n\t\t\t\tPath:   path.Join(\"/wd/hub/session\", s.ID),\n\t\t\t}\n\t\t\tw.Header().Add(\"Location\", u.String())\n\t\t\tw.WriteHeader(resp.StatusCode)\n\t\t}\n\t} else {\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[%d] [ERROR_READING_RESPONSE] [%v]\", requestId, err)\n\t\t\tqueue.Drop()\n\t\t\tcancel()\n\t\t\tw.WriteHeader(resp.StatusCode)\n\t\t\treturn\n\t\t}\n\t\tnewBody, sessionId, err := processBody(body, r.Host)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[%d] [ERROR_PROCESSING_RESPONSE] [%v]\", requestId, err)\n\t\t\tqueue.Drop()\n\t\t\tcancel()\n\t\t\tw.WriteHeader(resp.StatusCode)\n\t\t\treturn\n\t\t}\n\t\tresp.Body = io.NopCloser(bytes.NewReader(newBody))\n\t\tresp.ContentLength = int64(len(newBody))\n\t\tw.WriteHeader(resp.StatusCode)\n\t\t_, _ = w.Write(newBody)\n\t\ts.ID = sessionId\n\t}\n\tif s.ID == \"\" {\n\t\tlog.Printf(\"[%d] [SESSION_FAILED] [%s] [%s]\", requestId, u.String(), resp.Status)\n\t\tqueue.Drop()\n\t\tcancel()\n\t\treturn\n\t}\n\tsess := &session.Session{\n\t\tQuota:     user,\n\t\tCaps:      caps,\n\t\tURL:       u,\n\t\tContainer: startedService.Container,\n\t\tHostPort:  startedService.HostPort,\n\t\tOrigin:    startedService.Origin,\n\t\tTimeout:   sessionTimeout,\n\t\tTimeoutCh: onTimeout(sessionTimeout, func() {\n\t\t\trequest{r}.session(s.ID).Delete(requestId)\n\t\t}),\n\t\tStarted: time.Now()}\n\tcancelAndRenameFiles := func() {\n\t\tcancel()\n\t\tsessionId := preprocessSessionId(s.ID)\n\t\te := event.Event{\n\t\t\tRequestId: requestId,\n\t\t\tSessionId: sessionId,\n\t\t\tSession:   sess,\n\t\t}\n\t\tif caps.Video && !disableDocker {\n\t\t\toldVideoName := filepath.Join(videoOutputDir, caps.VideoName)\n\t\t\tif finalVideoName == \"\" {\n\t\t\t\tfinalVideoName = sessionId + videoFileExtension\n\t\t\t\te.Session.Caps.VideoName = finalVideoName\n\t\t\t}\n\t\t\tnewVideoName := filepath.Join(videoOutputDir, finalVideoName)\n\t\t\terr := os.Rename(oldVideoName, newVideoName)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"[%d] [VIDEO_ERROR] [%s]\", requestId, fmt.Sprintf(\"Failed to rename %s to %s: %v\", oldVideoName, newVideoName, err))\n\t\t\t} else {\n\t\t\t\tcreatedFile := event.CreatedFile{\n\t\t\t\t\tEvent: e,\n\t\t\t\t\tName:  newVideoName,\n\t\t\t\t\tType:  \"video\",\n\t\t\t\t}\n\t\t\t\tevent.FileCreated(createdFile)\n\t\t\t}\n\t\t}\n\t\tif logOutputDir != \"\" && (saveAllLogs || caps.Log) {\n\t\t\t//The following logic will fail if -capture-driver-logs is enabled and a session is requested in driver mode.\n\t\t\t//Specifying both -log-output-dir and -capture-driver-logs in that case is considered a misconfiguration.\n\t\t\toldLogName := filepath.Join(logOutputDir, caps.LogName)\n\t\t\tif finalLogName == \"\" {\n\t\t\t\tfinalLogName = sessionId + logFileExtension\n\t\t\t\te.Session.Caps.LogName = finalLogName\n\t\t\t}\n\t\t\tnewLogName := filepath.Join(logOutputDir, finalLogName)\n\t\t\terr := os.Rename(oldLogName, newLogName)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"[%d] [LOG_ERROR] [%s]\", requestId, fmt.Sprintf(\"Failed to rename %s to %s: %v\", oldLogName, newLogName, err))\n\t\t\t} else {\n\t\t\t\tcreatedFile := event.CreatedFile{\n\t\t\t\t\tEvent: e,\n\t\t\t\t\tName:  newLogName,\n\t\t\t\t\tType:  \"log\",\n\t\t\t\t}\n\t\t\t\tevent.FileCreated(createdFile)\n\t\t\t}\n\t\t}\n\t\tevent.SessionStopped(event.StoppedSession{e})\n\t}\n\tsess.Cancel = cancelAndRenameFiles\n\tsessions.Put(s.ID, sess)\n\tqueue.Create()\n\tlog.Printf(\"[%d] [SESSION_CREATED] [%s] [%d] [%.2fs]\", requestId, s.ID, i, info.SecondsSince(sessionStartTime))\n}\n\nfunc removeSelenoidOptions(input []byte) []byte {\n\tbody := make(map[string]interface{})\n\t_ = json.Unmarshal(input, &body)\n\tconst selenoidOptions = \"selenoid:options\"\n\tif raw, ok := body[\"desiredCapabilities\"]; ok {\n\t\tif dc, ok := raw.(map[string]interface{}); ok {\n\t\t\tdelete(dc, selenoidOptions)\n\t\t}\n\t}\n\tif raw, ok := body[\"capabilities\"]; ok {\n\t\tif c, ok := raw.(map[string]interface{}); ok {\n\t\t\tif raw, ok := c[\"alwaysMatch\"]; ok {\n\t\t\t\tif am, ok := raw.(map[string]interface{}); ok {\n\t\t\t\t\tdelete(am, selenoidOptions)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif raw, ok := c[\"firstMatch\"]; ok {\n\t\t\t\tif fm, ok := raw.([]interface{}); ok {\n\t\t\t\t\tfor _, raw := range fm {\n\t\t\t\t\t\tif c, ok := raw.(map[string]interface{}); ok {\n\t\t\t\t\t\t\tdelete(c, selenoidOptions)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret, _ := json.Marshal(body)\n\treturn ret\n}\n\nfunc processBody(input []byte, host string) ([]byte, string, error) {\n\tbody := make(map[string]interface{})\n\tsessionId := \"\"\n\terr := json.Unmarshal(input, &body)\n\tif err != nil {\n\t\treturn nil, sessionId, fmt.Errorf(\"parse body response: %v\", err)\n\t}\n\t// handle jsonwp response from older browsers (chrome < 75)\n\tif rawId, ok := body[\"sessionId\"]; ok {\n\t\tif si, ok := rawId.(string); ok {\n\t\t\tsessionId = si\n\t\t}\n\t} else {\n\t\tif raw, ok := body[\"value\"]; ok {\n\t\t\tif v, ok := raw.(map[string]interface{}); ok {\n\t\t\t\tif raw, ok := v[\"capabilities\"]; ok {\n\t\t\t\t\tif c, ok := raw.(map[string]interface{}); ok {\n\t\t\t\t\t\tsessionId = v[\"sessionId\"].(string)\n\t\t\t\t\t\tc[\"se:cdp\"] = fmt.Sprintf(\"ws://%s/devtools/%s/\", host, sessionId)\n\t\t\t\t\t\tif rbv, ok := c[\"browserVersion\"]; ok {\n\t\t\t\t\t\t\tif bv, ok := rbv.(string); ok {\n\t\t\t\t\t\t\t\tc[\"se:cdpVersion\"] = bv\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, sessionId, fmt.Errorf(\"marshal response: %v\", err)\n\t}\n\treturn ret, sessionId, nil\n}\n\nfunc preprocessSessionId(sid string) string {\n\tif ggrHost != nil {\n\t\treturn ggrHost.Sum() + sid\n\t}\n\treturn sid\n}\n\nconst (\n\tvideoFileExtension = \".mp4\"\n\tlogFileExtension   = \".log\"\n)\n\nvar (\n\tfullFormat  = regexp.MustCompile(`^([0-9]+x[0-9]+)x(8|16|24)$`)\n\tshortFormat = regexp.MustCompile(`^[0-9]+x[0-9]+$`)\n)\n\nfunc getScreenResolution(input string) (string, error) {\n\tif input == \"\" {\n\t\treturn \"1920x1080x24\", nil\n\t}\n\tif fullFormat.MatchString(input) {\n\t\treturn input, nil\n\t}\n\tif shortFormat.MatchString(input) {\n\t\treturn fmt.Sprintf(\"%sx24\", input), nil\n\t}\n\treturn \"\", fmt.Errorf(\n\t\t\"malformed screenResolution capability: %s, correct format is WxH (1920x1080) or WxHxD (1920x1080x24)\",\n\t\tinput,\n\t)\n}\n\nfunc shortenScreenResolution(screenResolution string) string {\n\treturn fullFormat.FindStringSubmatch(screenResolution)[1]\n}\n\nfunc getVideoScreenSize(videoScreenSize string, screenResolution string) (string, error) {\n\tif videoScreenSize != \"\" {\n\t\tif shortFormat.MatchString(videoScreenSize) {\n\t\t\treturn videoScreenSize, nil\n\t\t}\n\t\treturn \"\", fmt.Errorf(\n\t\t\t\"malformed videoScreenSize capability: %s, correct format is WxH (1920x1080)\",\n\t\t\tvideoScreenSize,\n\t\t)\n\t}\n\treturn shortenScreenResolution(screenResolution), nil\n}\n\nfunc getSessionTimeout(sessionTimeout string, maxTimeout time.Duration, defaultTimeout time.Duration) (time.Duration, error) {\n\tif sessionTimeout != \"\" {\n\t\tst, err := time.ParseDuration(sessionTimeout)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"invalid sessionTimeout capability: %v\", err)\n\t\t}\n\t\tif st <= maxTimeout {\n\t\t\treturn st, nil\n\t\t}\n\t\treturn maxTimeout, nil\n\t}\n\treturn defaultTimeout, nil\n}\n\nfunc getTemporaryFileName(dir string, extension string) string {\n\tfilename := \"\"\n\tfor {\n\t\tfilename = generateRandomFileName(extension)\n\t\t_, err := os.Stat(filepath.Join(dir, filename))\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn filename\n}\n\nfunc generateRandomFileName(extension string) string {\n\trandBytes := make([]byte, 16)\n\t_, _ = rand.Read(randBytes)\n\treturn \"selenoid\" + hex.EncodeToString(randBytes) + extension\n}\n\nconst vendorPrefix = \"aerokube\"\n\nfunc proxy(w http.ResponseWriter, r *http.Request) {\n\tdone := make(chan func())\n\tgo func() {\n\t\t(<-done)()\n\t}()\n\tcancel := func() {}\n\tdefer func() {\n\t\tdone <- cancel\n\t}()\n\trequestId := serial()\n\t(&httputil.ReverseProxy{\n\t\tDirector: func(r *http.Request) {\n\t\t\tfragments := strings.Split(r.URL.Path, slash)\n\t\t\tid := fragments[2]\n\t\t\tsess, ok := sessions.Get(id)\n\t\t\tif ok {\n\t\t\t\tif len(fragments) >= 4 && fragments[3] == vendorPrefix {\n\t\t\t\t\tnewFragments := []string{\"\", fragments[4], id}\n\t\t\t\t\tif len(fragments) >= 5 {\n\t\t\t\t\t\tnewFragments = append(newFragments, fragments[5:]...)\n\t\t\t\t\t}\n\t\t\t\t\tr.URL.Host = (&request{r}).localaddr()\n\t\t\t\t\tr.URL.Path = path.Clean(strings.Join(newFragments, slash))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tsess.Lock.Lock()\n\t\t\t\tdefer sess.Lock.Unlock()\n\t\t\t\tselect {\n\t\t\t\tcase <-sess.TimeoutCh:\n\t\t\t\tdefault:\n\t\t\t\t\tclose(sess.TimeoutCh)\n\t\t\t\t}\n\t\t\t\tif r.Method == http.MethodDelete && len(fragments) == 3 {\n\t\t\t\t\tif enableFileUpload {\n\t\t\t\t\t\t_ = os.RemoveAll(filepath.Join(os.TempDir(), id))\n\t\t\t\t\t}\n\t\t\t\t\tcancel = sess.Cancel\n\t\t\t\t\tsessions.Remove(id)\n\t\t\t\t\tqueue.Release()\n\t\t\t\t\tlog.Printf(\"[%d] [SESSION_DELETED] [%s]\", requestId, id)\n\t\t\t\t} else {\n\t\t\t\t\tsess.TimeoutCh = onTimeout(sess.Timeout, func() {\n\t\t\t\t\t\trequest{r}.session(id).Delete(requestId)\n\t\t\t\t\t})\n\t\t\t\t\tif len(fragments) == 4 && fragments[len(fragments)-1] == \"file\" && enableFileUpload {\n\t\t\t\t\t\tr.Header.Set(\"X-Selenoid-File\", filepath.Join(os.TempDir(), id))\n\t\t\t\t\t\tr.URL.Path = \"/file\"\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseUploadPath, uploadPath := \"/se/file\", \"/file\"\n\t\t\t\tif strings.HasSuffix(r.URL.Path, seUploadPath) {\n\t\t\t\t\tr.URL.Path = strings.TrimSuffix(r.URL.Path, seUploadPath) + uploadPath\n\t\t\t\t}\n\t\t\t\tr.URL.Host, r.URL.Path = sess.URL.Host, path.Clean(sess.URL.Path+r.URL.Path)\n\t\t\t\tr.Host = \"localhost\"\n\t\t\t\tif sess.Origin != \"\" {\n\t\t\t\t\tr.Host = sess.Origin\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tr.URL.Path = paths.Error\n\t\t},\n\t\tErrorHandler: defaultErrorHandler(requestId),\n\t}).ServeHTTP(w, r)\n}\n\nfunc defaultErrorHandler(requestId uint64) func(http.ResponseWriter, *http.Request, error) {\n\treturn func(w http.ResponseWriter, r *http.Request, err error) {\n\t\tuser, remote := info.RequestInfo(r)\n\t\tlog.Printf(\"[%d] [CLIENT_DISCONNECTED] [%s] [%s] [Error: %v]\", requestId, user, remote, err)\n\t\tw.WriteHeader(http.StatusBadGateway)\n\t}\n}\n\nfunc reverseProxy(hostFn func(sess *session.Session) string, status string) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\trequestId := serial()\n\t\tsid, remainingPath := splitRequestPath(r.URL.Path)\n\t\tsess, ok := sessions.Get(sid)\n\t\tif ok {\n\t\t\tselect {\n\t\t\tcase <-sess.TimeoutCh:\n\t\t\tdefault:\n\t\t\t\tclose(sess.TimeoutCh)\n\t\t\t}\n\t\t\tsess.TimeoutCh = onTimeout(sess.Timeout, func() {\n\t\t\t\trequest{r}.session(sid).Delete(requestId)\n\t\t\t})\n\t\t\t(&httputil.ReverseProxy{\n\t\t\t\tDirector: func(r *http.Request) {\n\t\t\t\t\tr.URL.Scheme = \"http\"\n\t\t\t\t\tr.URL.Host = hostFn(sess)\n\t\t\t\t\tr.URL.Path = remainingPath\n\t\t\t\t\tlog.Printf(\"[%d] [%s] [%s] [%s]\", requestId, status, sid, remainingPath)\n\t\t\t\t},\n\t\t\t\tErrorHandler: defaultErrorHandler(requestId),\n\t\t\t}).ServeHTTP(w, r)\n\t\t} else {\n\t\t\tjsonerror.InvalidSessionID(fmt.Errorf(\"unknown session %s\", sid)).Encode(w)\n\t\t\tlog.Printf(\"[%d] [SESSION_NOT_FOUND] [%s]\", requestId, sid)\n\t\t}\n\t}\n}\n\nfunc splitRequestPath(p string) (string, string) {\n\tfragments := strings.Split(p, slash)\n\treturn fragments[2], slash + strings.Join(fragments[3:], slash)\n}\n\nfunc fileUpload(w http.ResponseWriter, r *http.Request) {\n\tvar jsonRequest struct {\n\t\tFile []byte `json:\"file\"`\n\t}\n\terr := json.NewDecoder(r.Body).Decode(&jsonRequest)\n\tif err != nil {\n\t\tjsonerror.InvalidArgument(err).Encode(w)\n\t\treturn\n\t}\n\tz, err := zip.NewReader(bytes.NewReader(jsonRequest.File), int64(len(jsonRequest.File)))\n\tif err != nil {\n\t\tjsonerror.InvalidArgument(err).Encode(w)\n\t\treturn\n\t}\n\tif len(z.File) != 1 {\n\t\terr := fmt.Errorf(\"expected there to be only 1 file. There were: %d\", len(z.File))\n\t\tjsonerror.InvalidArgument(err).Encode(w)\n\t\treturn\n\t}\n\tfile := z.File[0]\n\tsrc, err := file.Open()\n\tif err != nil {\n\t\tjsonerror.InvalidArgument(err).Encode(w)\n\t\treturn\n\t}\n\tdefer src.Close()\n\tdir := r.Header.Get(\"X-Selenoid-File\")\n\terr = os.MkdirAll(dir, 0755)\n\tif err != nil {\n\t\tjsonerror.UnknownError(err).Encode(w)\n\t\treturn\n\t}\n\tfileName := filepath.Join(dir, file.Name)\n\tdst, err := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE, 0644)\n\tif err != nil {\n\t\tjsonerror.UnknownError(err).Encode(w)\n\t\treturn\n\t}\n\tdefer dst.Close()\n\t_, err = io.Copy(dst, src)\n\tif err != nil {\n\t\tjsonerror.UnknownError(err).Encode(w)\n\t\treturn\n\t}\n\n\treply := struct {\n\t\tV string `json:\"value\"`\n\t}{\n\t\tV: fileName,\n\t}\n\t_ = json.NewEncoder(w).Encode(reply)\n}\n\nfunc vnc(wsconn *websocket.Conn) {\n\tdefer wsconn.Close()\n\trequestId := serial()\n\tsid, _ := splitRequestPath(wsconn.Request().URL.Path)\n\tsess, ok := sessions.Get(sid)\n\tif ok {\n\t\tvncHostPort := sess.HostPort.VNC\n\t\tif vncHostPort != \"\" {\n\t\t\tlog.Printf(\"[%d] [VNC_ENABLED] [%s]\", requestId, sid)\n\t\t\tvar d net.Dialer\n\t\t\tconn, err := d.DialContext(wsconn.Request().Context(), \"tcp\", vncHostPort)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"[%d] [VNC_ERROR] [%v]\", requestId, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer conn.Close()\n\t\t\twsconn.PayloadType = websocket.BinaryFrame\n\t\t\tgo func() {\n\t\t\t\t_, _ = io.Copy(wsconn, conn)\n\t\t\t\t_ = wsconn.Close()\n\t\t\t\tlog.Printf(\"[%d] [VNC_SESSION_CLOSED] [%s]\", requestId, sid)\n\t\t\t}()\n\t\t\t_, _ = io.Copy(conn, wsconn)\n\t\t\tlog.Printf(\"[%d] [VNC_CLIENT_DISCONNECTED] [%s]\", requestId, sid)\n\t\t} else {\n\t\t\tlog.Printf(\"[%d] [VNC_NOT_ENABLED] [%s]\", requestId, sid)\n\t\t}\n\t} else {\n\t\tlog.Printf(\"[%d] [SESSION_NOT_FOUND] [%s]\", requestId, sid)\n\t}\n}\n\nconst (\n\tjsonParam = \"json\"\n)\n\nfunc logs(w http.ResponseWriter, r *http.Request) {\n\trequestId := serial()\n\tfileNameOrSessionID := strings.TrimPrefix(r.URL.Path, paths.Logs)\n\tif logOutputDir != \"\" && (fileNameOrSessionID == \"\" || strings.HasSuffix(fileNameOrSessionID, logFileExtension)) {\n\t\tif r.Method == http.MethodDelete {\n\t\t\tdeleteFileIfExists(requestId, w, r, logOutputDir, paths.Logs, \"DELETED_LOG_FILE\")\n\t\t\treturn\n\t\t}\n\t\tuser, remote := info.RequestInfo(r)\n\t\tif _, ok := r.URL.Query()[jsonParam]; ok {\n\t\t\tlistFilesAsJson(requestId, w, logOutputDir, \"LOG_ERROR\")\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"[%d] [LOG_LISTING] [%s] [%s]\", requestId, user, remote)\n\t\tfileServer := http.StripPrefix(paths.Logs, http.FileServer(http.Dir(logOutputDir)))\n\t\tfileServer.ServeHTTP(w, r)\n\t\treturn\n\t}\n\twebsocket.Handler(streamLogs).ServeHTTP(w, r)\n}\n\nfunc listFilesAsJson(requestId uint64, w http.ResponseWriter, dir string, errStatus string) {\n\tfiles, err := os.ReadDir(dir)\n\tif err != nil {\n\t\tlog.Printf(\"[%d] [%s] [%s]\", requestId, errStatus, fmt.Sprintf(\"Failed to list directory %s: %v\", logOutputDir, err))\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tvar ret []string\n\tfor _, f := range files {\n\t\tret = append(ret, f.Name())\n\t}\n\tw.Header().Add(\"Content-Type\", \"application/json\")\n\t_ = json.NewEncoder(w).Encode(ret)\n}\n\nfunc streamLogs(wsconn *websocket.Conn) {\n\tdefer wsconn.Close()\n\trequestId := serial()\n\tsid, _ := splitRequestPath(wsconn.Request().URL.Path)\n\tsess, ok := sessions.Get(sid)\n\tif ok && sess.Container != nil {\n\t\tlog.Printf(\"[%d] [CONTAINER_LOGS] [%s]\", requestId, sess.Container.ID)\n\t\tr, err := cli.ContainerLogs(wsconn.Request().Context(), sess.Container.ID, container.LogsOptions{\n\t\t\tShowStdout: true,\n\t\t\tShowStderr: true,\n\t\t\tFollow:     true,\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[%d] [CONTAINER_LOGS_ERROR] [%v]\", requestId, err)\n\t\t\treturn\n\t\t}\n\t\tdefer r.Close()\n\t\twsconn.PayloadType = websocket.BinaryFrame\n\t\t_, _ = stdcopy.StdCopy(wsconn, wsconn, r)\n\t\tlog.Printf(\"[%d] [CONTAINER_LOGS_DISCONNECTED] [%s]\", requestId, sid)\n\t} else {\n\t\tlog.Printf(\"[%d] [SESSION_NOT_FOUND] [%s]\", requestId, sid)\n\t}\n}\n\nfunc status(w http.ResponseWriter, _ *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tready := limit > sessions.Len()\n\t_ = json.NewEncoder(w).Encode(\n\t\tmap[string]interface{}{\n\t\t\t\"value\": map[string]interface{}{\n\t\t\t\t\"message\": fmt.Sprintf(\"Selenoid %s built at %s\", gitRevision, buildStamp),\n\t\t\t\t\"ready\":   ready,\n\t\t\t},\n\t\t})\n}\n\nfunc welcome(w http.ResponseWriter, _ *http.Request) {\n\tw.WriteHeader(http.StatusOK)\n\t_, _ = w.Write([]byte(fmt.Sprintf(\"You are using Selenoid %s!\", gitRevision)))\n}\n\nfunc onTimeout(t time.Duration, f func()) chan struct{} {\n\tcancel := make(chan struct{})\n\tgo func(cancel chan struct{}) {\n\t\tselect {\n\t\tcase <-time.After(t):\n\t\t\tf()\n\t\tcase <-cancel:\n\t\t}\n\t}(cancel)\n\treturn cancel\n}\n"
        },
        {
          "name": "selenoid.png",
          "type": "blob",
          "size": 30.6328125,
          "content": null
        },
        {
          "name": "selenoid_test.go",
          "type": "blob",
          "size": 32.0244140625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\tggr \"github.com/aerokube/ggr/config\"\n\t\"github.com/aerokube/selenoid/config\"\n\t\"github.com/mafredri/cdp\"\n\t\"github.com/mafredri/cdp/rpcc\"\n\tassert \"github.com/stretchr/testify/require\"\n)\n\nvar _ = func() bool {\n\ttesting.Init()\n\treturn true\n}()\n\nvar (\n\tsrv *httptest.Server\n)\n\nfunc init() {\n\tenableFileUpload = true\n\tvideoOutputDir, _ = os.MkdirTemp(\"\", \"selenoid-test\")\n\tlogOutputDir, _ = os.MkdirTemp(\"\", \"selenoid-test\")\n\tsaveAllLogs = true\n\tgitRevision = \"test-revision\"\n\tggrHost = &ggr.Host{\n\t\tName: \"some-host.example.com\",\n\t\tPort: 4444,\n\t}\n\tsrv = httptest.NewServer(handler())\n}\n\nfunc TestNewSessionWithGet(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\trsp, err := http.Get(With(srv.URL).Path(\"/wd/hub/session\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusMethodNotAllowed)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestBadJsonFormat(t *testing.T) {\n\trsp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusBadRequest)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestServiceStartupFailure(t *testing.T) {\n\tmanager = &StartupError{}\n\n\trsp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusInternalServerError)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestBrowserNotFound(t *testing.T) {\n\tmanager = &BrowserNotFound{}\n\n\trsp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusBadRequest)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestGetDefaultScreenResolution(t *testing.T) {\n\tres, err := getScreenResolution(\"\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, res, \"1920x1080x24\")\n}\n\nfunc TestGetFullScreenResolution(t *testing.T) {\n\tres, err := getScreenResolution(\"1024x768x24\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, res, \"1024x768x24\")\n}\n\nfunc TestGetShortScreenResolution(t *testing.T) {\n\tres, err := getScreenResolution(\"1024x768\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, res, \"1024x768x24\")\n}\n\nfunc TestTooBigSessionTimeoutCapability(t *testing.T) {\n\ttestBadSessionTimeoutCapability(t, \"1h1m\")\n}\n\nfunc TestInvalidSessionTimeoutCapability(t *testing.T) {\n\ttestBadSessionTimeoutCapability(t, \"wrong-value\")\n}\n\nfunc testBadSessionTimeoutCapability(t *testing.T, timeoutValue string) {\n\tmanager = &BrowserNotFound{}\n\n\trsp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(fmt.Sprintf(`{\"desiredCapabilities\":{\"sessionTimeout\":\"%s\"}}`, timeoutValue))))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusBadRequest)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestMalformedScreenResolutionCapability(t *testing.T) {\n\tmanager = &BrowserNotFound{}\n\n\trsp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(`{\"desiredCapabilities\":{\"screenResolution\":\"bad-resolution\"}}`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusBadRequest)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestGetVideoScreenSizeFromCapability(t *testing.T) {\n\tres, err := getVideoScreenSize(\"1024x768\", \"anything\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, res, \"1024x768\")\n}\n\nfunc TestDetermineVideoScreenSizeFromScreenResolution(t *testing.T) {\n\tres, err := getVideoScreenSize(\"\", \"1024x768x24\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, res, \"1024x768\")\n}\n\nfunc TestMalformedVideoScreenSizeCapability(t *testing.T) {\n\tmanager = &BrowserNotFound{}\n\n\trsp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(`{\"desiredCapabilities\":{\"videoScreenSize\":\"bad-size\"}}`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusBadRequest)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestNewSessionNotFound(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\trsp, err := http.Get(With(srv.URL).Path(\"/wd/hub/session/123\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusNotFound)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestNewSessionHostDown(t *testing.T) {\n\tcanceled := false\n\tch := make(chan bool)\n\tmanager = &HTTPTest{\n\t\tHandler: Selenium(),\n\t\tAction: func(s *httptest.Server) {\n\t\t\tlog.Println(\"Host is going down...\")\n\t\t\ts.Close()\n\t\t\tlog.Println(\"Now Host is down...\")\n\t\t},\n\t\tCancel: ch,\n\t}\n\n\trsp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusInternalServerError)\n\n\tcanceled = <-ch\n\tassert.True(t, canceled)\n\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestNewSessionBadHostResponse(t *testing.T) {\n\tcanceled := false\n\tch := make(chan bool)\n\tmanager = &HTTPTest{\n\t\tHandler: HTTPResponse(\"Bad Request\", http.StatusBadRequest),\n\t\tCancel:  ch,\n\t}\n\n\trsp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusBadRequest)\n\n\tcanceled = <-ch\n\tassert.True(t, canceled)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestSessionCreated(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\ttimeout = 5 * time.Second\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(`{\"desiredCapabilities\": {\"enableVideo\": true, \"enableVNC\": true, \"sessionTimeout\": \"3s\"}}`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tresp, err = http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 1)\n\tassert.Equal(t, queue.Used(), 1)\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestSessionCreatedW3C(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(`{\"capabilities\":{\"alwaysMatch\":{\"acceptInsecureCerts\":true, \"browserName\":\"firefox\", \"browserVersion\":\"latest\", \"selenoid:options\":{\"enableVNC\": true}}}}`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tresp, err = http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 1)\n\tassert.Equal(t, queue.Used(), 1)\n\n\tversions, firefoxPresent := state.Browsers[\"firefox\"]\n\tassert.True(t, firefoxPresent)\n\tusers, versionPresent := versions[\"latest\"]\n\tassert.True(t, versionPresent)\n\tuserInfo, userPresent := users[\"unknown\"]\n\tassert.True(t, userPresent)\n\tassert.NotNil(t, userInfo)\n\tassert.Len(t, userInfo.Sessions, 1)\n\tassert.True(t, userInfo.Sessions[0].VNC)\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestSessionCreatedFirstMatchOnly(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(`{\"capabilities\":{\"firstMatch\":[{\"browserName\":\"firefox\", \"browserVersion\":\"latest\", \"selenoid:options\":{\"enableVNC\": true}}]}}`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tresp, err = http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 1)\n\tassert.Equal(t, queue.Used(), 1)\n\n\tversions, firefoxPresent := state.Browsers[\"firefox\"]\n\tassert.True(t, firefoxPresent)\n\tusers, versionPresent := versions[\"latest\"]\n\tassert.True(t, versionPresent)\n\tuserInfo, userPresent := users[\"unknown\"]\n\tassert.True(t, userPresent)\n\tassert.NotNil(t, userInfo)\n\tassert.Len(t, userInfo.Sessions, 1)\n\tassert.True(t, userInfo.Sessions[0].VNC)\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestSessionCreatedWdHub(t *testing.T) {\n\troot := http.NewServeMux()\n\troot.Handle(\"/wd/hub/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tr.URL.Path = strings.TrimPrefix(r.URL.Path, \"/wd/hub\")\n\t\tSelenium().ServeHTTP(w, r)\n\t}))\n\tmanager = &HTTPTest{Handler: root}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tresp, err = http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 1)\n\tassert.Equal(t, queue.Used(), 1)\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestSessionWithContentTypeCreatedWdHub(t *testing.T) {\n\troot := http.NewServeMux()\n\troot.Handle(\"/wd/hub/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tr.URL.Path = strings.TrimPrefix(r.URL.Path, \"/wd/hub\")\n\t\tassert.Equal(t, r.Header.Get(\"Content-Type\"), \"application/json; charset=utf-8\")\n\t\tSelenium().ServeHTTP(w, r)\n\t}))\n\tmanager = &HTTPTest{Handler: root}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"application/json; charset=utf-8\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tresp, err = http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 1)\n\tassert.Equal(t, queue.Used(), 1)\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestSessionFailedAfterTimeout(t *testing.T) {\n\tnewSessionAttemptTimeout = 10 * time.Millisecond\n\tmanager = &HTTPTest{Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t<-time.After(100 * time.Millisecond)\n\t})}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusInternalServerError)\n\n\tresp, err = http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 0)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestClientDisconnected(t *testing.T) {\n\tmanager = &HTTPTest{Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t<-time.After(1000 * time.Millisecond)\n\t})}\n\n\treq, _ := http.NewRequest(http.MethodPost, With(srv.URL).Path(\"/wd/hub/session\"), bytes.NewReader([]byte(\"{}\")))\n\tctx, cancel := context.WithCancel(req.Context())\n\tgo http.DefaultClient.Do(req.WithContext(ctx))\n\t<-time.After(10 * time.Millisecond)\n\tcancel()\n\n\tresp, err := http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 0)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestSessionFailedAfterTwoTimeout(t *testing.T) {\n\tretryCount = 2\n\tnewSessionAttemptTimeout = 10 * time.Millisecond\n\tmanager = &HTTPTest{Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t<-time.After(100 * time.Millisecond)\n\t})}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusInternalServerError)\n\n\tresp, err = http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 0)\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestSessionCreatedRedirect(t *testing.T) {\n\thttpClient := &http.Client{\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\treturn http.ErrUseLastResponse\n\t\t},\n\t}\n\troot := http.NewServeMux()\n\troot.Handle(\"/wd/hub/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, With(srv.URL).Path(\"/wd/hub/session/123\"), http.StatusFound)\n\t}))\n\tmanager = &HTTPTest{Handler: root}\n\n\tresp, err := httpClient.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusFound)\n\tlocation := resp.Header.Get(\"Location\")\n\tfragments := strings.Split(location, \"/\")\n\tsid := fragments[len(fragments)-1]\n\n\tresp, err = http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 1)\n\tassert.Equal(t, queue.Used(), 1)\n\tsessions.Remove(sid)\n\tqueue.Release()\n}\n\nfunc TestSessionCreatedRemoveExtensionCapabilities(t *testing.T) {\n\tdesiredCapabilitiesPresent := true\n\talwaysMatchPresent := true\n\tfirstMatchPresent := true\n\tchromeOptionsPresent := true\n\n\tvar browser struct {\n\t\tCaps    map[string]interface{} `json:\"desiredCapabilities\"`\n\t\tW3CCaps struct {\n\t\t\tAlwaysMatch map[string]interface{}   `json:\"alwaysMatch\"`\n\t\t\tFirstMatch  []map[string]interface{} `json:\"firstMatch\"`\n\t\t} `json:\"capabilities\"`\n\t}\n\n\troot := http.NewServeMux()\n\troot.Handle(\"/wd/hub/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\terr := json.NewDecoder(r.Body).Decode(&browser)\n\t\tassert.NoError(t, err)\n\t\t_, desiredCapabilitiesPresent = browser.Caps[\"selenoid:options\"]\n\t\t_, alwaysMatchPresent = browser.W3CCaps.AlwaysMatch[\"selenoid:options\"]\n\t\t_, chromeOptionsPresent = browser.W3CCaps.AlwaysMatch[\"goog:chromeOptions\"]\n\t\tassert.Len(t, browser.W3CCaps.FirstMatch, 1)\n\t\t_, firstMatchPresent = browser.W3CCaps.FirstMatch[0][\"selenoid:options\"]\n\t}))\n\tmanager = &HTTPTest{Handler: root}\n\n\tresp, err := httpClient.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(`{\"desiredCapabilities\": {\"browserName\": \"chrome\", \"selenoid:options\": {\"enableVNC\": true}}, \"capabilities\":{\"alwaysMatch\":{\"browserName\": \"chrome\", \"goog:chromeOptions\": {\"args\": [\"headless\"]}, \"selenoid:options\":{\"enableVNC\": true}}, \"firstMatch\": [{\"platform\": \"linux\", \"selenoid:options\": {\"enableVideo\": true}}]}}`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tassert.False(t, desiredCapabilitiesPresent)\n\tassert.False(t, alwaysMatchPresent)\n\tassert.True(t, chromeOptionsPresent)\n\tassert.False(t, firstMatchPresent)\n}\n\nfunc TestProxySession(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tresp, err = http.Get(With(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/url\", sess[\"sessionId\"])))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\n\tassert.Equal(t, queue.Used(), 1)\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestProxySessionPanicOnAbortHandler(t *testing.T) {\n\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\treq, _ := http.NewRequest(http.MethodGet, With(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/url?abort-handler=true\", sess[\"sessionId\"])), nil)\n\tresp, err = http.DefaultClient.Do(req)\n\tassert.Error(t, err)\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestSessionDeleted(t *testing.T) {\n\tcanceled := false\n\tch := make(chan bool)\n\tmanager = &HTTPTest{\n\t\tHandler: Selenium(),\n\t\tCancel:  ch,\n\t}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(`{\"desiredCapabilities\": {\"enableVideo\": true}}`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\treq, _ := http.NewRequest(http.MethodDelete,\n\t\tWith(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s\", sess[\"sessionId\"])), nil)\n\t_, err = http.DefaultClient.Do(req)\n\tassert.NoError(t, err)\n\n\tresp, err = http.Get(With(srv.URL).Path(\"/status\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar state config.State\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&state))\n\tassert.Equal(t, state.Used, 0)\n\n\tcanceled = <-ch\n\tassert.True(t, canceled)\n\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestSessionOnClose(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\treq, _ := http.NewRequest(http.MethodDelete,\n\t\tWith(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/window\", sess[\"sessionId\"])), nil)\n\t_, _ = http.DefaultClient.Do(req)\n\n\tassert.Equal(t, queue.Used(), 1)\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestProxySessionCanceled(t *testing.T) {\n\tcanceled := false\n\tch := make(chan bool)\n\tmanager = &HTTPTest{\n\t\tHandler: Selenium(),\n\t\tCancel:  ch,\n\t}\n\n\ttimeout = 100 * time.Millisecond\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\t_, ok := sessions.Get(sess[\"sessionId\"])\n\tassert.True(t, ok)\n\n\treq, _ := http.NewRequest(http.MethodGet, With(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/url?timeout=1s\", sess[\"sessionId\"])), nil)\n\tctx, cancel := context.WithCancel(context.Background())\n\treq = req.WithContext(ctx)\n\tgo func() {\n\t\t_, _ = http.DefaultClient.Do(req)\n\t}()\n\t<-time.After(50 * time.Millisecond)\n\tcancel()\n\t<-time.After(100 * time.Millisecond)\n\t_, ok = sessions.Get(sess[\"sessionId\"])\n\tassert.False(t, ok)\n\n\tcanceled = <-ch\n\tassert.True(t, canceled)\n\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestNewSessionTimeout(t *testing.T) {\n\tcanceled := false\n\tch := make(chan bool)\n\tmanager = &HTTPTest{\n\t\tHandler: Selenium(),\n\t\tCancel:  ch,\n\t}\n\n\ttimeout = 30 * time.Millisecond\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\t_, ok := sessions.Get(sess[\"sessionId\"])\n\tassert.True(t, ok)\n\n\t<-time.After(50 * time.Millisecond)\n\t_, ok = sessions.Get(sess[\"sessionId\"])\n\tassert.False(t, ok)\n\n\tcanceled = <-ch\n\tassert.True(t, canceled)\n\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestProxySessionTimeout(t *testing.T) {\n\tcanceled := false\n\tch := make(chan bool)\n\tmanager = &HTTPTest{\n\t\tHandler: Selenium(),\n\t\tCancel:  ch,\n\t}\n\n\ttimeout = 30 * time.Millisecond\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\t_, ok := sessions.Get(sess[\"sessionId\"])\n\tassert.True(t, ok)\n\n\t<-time.After(20 * time.Millisecond)\n\t_, ok = sessions.Get(sess[\"sessionId\"])\n\tassert.True(t, ok)\n\t_, _ = http.Get(With(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/url\", sess[\"sessionId\"])))\n\n\t<-time.After(20 * time.Millisecond)\n\t_, ok = sessions.Get(sess[\"sessionId\"])\n\tassert.True(t, ok)\n\n\t<-time.After(50 * time.Millisecond)\n\t_, ok = sessions.Get(sess[\"sessionId\"])\n\tassert.False(t, ok)\n\n\tcanceled = <-ch\n\tassert.True(t, canceled)\n\n\tassert.Equal(t, queue.Used(), 0)\n}\n\nfunc TestFileUpload(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tfileContents := []byte(`{\"file\":\"UEsDBBQACAgIAJiC4koAAAAAAAAAAAAAAAAJAAAAaGVsbG8udHh080jNyclXCM8vyklRBABQSwcIoxwpHA4AAAAMAAAAUEsBAhQAFAAICAgAmILiSqMcKRwOAAAADAAAAAkAAAAAAAAAAAAAAAAAAAAAAGhlbGxvLnR4dFBLBQYAAAAAAQABADcAAABFAAAAAAA=\"}`)\n\n\t//Doing two times to test sequential upload\n\tresp, err = http.Post(With(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/file\", sess[\"sessionId\"])), \"\", bytes.NewReader(fileContents))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\n\tresp, err = http.Post(With(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/file\", sess[\"sessionId\"])), \"\", bytes.NewReader(fileContents))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\n\tvar jsonResponse map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&jsonResponse))\n\n\tf, err := os.Open(jsonResponse[\"value\"])\n\tassert.NoError(t, err)\n\n\tcontent, err := io.ReadAll(f)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, string(content), \"Hello World!\")\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestFileUploadBadJson(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tresp, err = http.Post(With(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/file\", sess[\"sessionId\"])), \"\", bytes.NewReader([]byte(`malformed json`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusBadRequest)\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestFileUploadNoFile(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tresp, err = http.Post(With(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/file\", sess[\"sessionId\"])), \"\", bytes.NewReader([]byte(`{}`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusBadRequest)\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestFileUploadTwoFiles(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tresp, err = http.Post(With(srv.URL).Path(fmt.Sprintf(\"/wd/hub/session/%s/file\", sess[\"sessionId\"])), \"\", bytes.NewReader([]byte(`{\"file\":\"UEsDBAoAAAAAAKGJ4koAAAAAAAAAAAAAAAAHABwAb25lLnR4dFVUCQADbv9YWZT/WFl1eAsAAQT1AQAABBQAAABQSwMECgAAAAAApIniSgAAAAAAAAAAAAAAAAcAHAB0d28udHh0VVQJAANz/1hZc/9YWXV4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAAKGJ4koAAAAAAAAAAAAAAAAHABgAAAAAAAAAAACkgQAAAABvbmUudHh0VVQFAANu/1hZdXgLAAEE9QEAAAQUAAAAUEsBAh4DCgAAAAAApIniSgAAAAAAAAAAAAAAAAcAGAAAAAAAAAAAAKSBQQAAAHR3by50eHRVVAUAA3P/WFl1eAsAAQT1AQAABBQAAABQSwUGAAAAAAIAAgCaAAAAggAAAAAA\"}`)))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusBadRequest)\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestPing(t *testing.T) {\n\trsp, err := http.Get(With(srv.URL).Path(\"/ping\"))\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n\tassert.NotNil(t, rsp.Body)\n\n\tvar data map[string]interface{}\n\tbt, readErr := io.ReadAll(rsp.Body)\n\tassert.NoError(t, readErr)\n\tjsonErr := json.Unmarshal(bt, &data)\n\tassert.NoError(t, jsonErr)\n\t_, hasUptime := data[\"uptime\"]\n\tassert.True(t, hasUptime)\n\t_, hasLastReloadTime := data[\"lastReloadTime\"]\n\tassert.True(t, hasLastReloadTime)\n\t_, hasNumRequests := data[\"numRequests\"]\n\tassert.True(t, hasNumRequests)\n\tversion, hasVersion := data[\"version\"]\n\tassert.True(t, hasVersion)\n\tassert.Equal(t, version, \"test-revision\")\n}\n\nfunc TestStatus(t *testing.T) {\n\trsp, err := http.Get(With(srv.URL).Path(\"/wd/hub/status\"))\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n\tassert.NotNil(t, rsp.Body)\n\n\tvar data map[string]interface{}\n\tbt, readErr := io.ReadAll(rsp.Body)\n\tassert.NoError(t, readErr)\n\tjsonErr := json.Unmarshal(bt, &data)\n\tassert.NoError(t, jsonErr)\n\tvalue, hasValue := data[\"value\"]\n\tassert.True(t, hasValue)\n\tvalueMap := value.(map[string]interface{})\n\tready, hasReady := valueMap[\"ready\"]\n\tassert.True(t, hasReady)\n\tassert.Equal(t, ready, true)\n\t_, hasMessage := valueMap[\"message\"]\n\tassert.True(t, hasMessage)\n}\n\nfunc TestServeAndDeleteVideoFile(t *testing.T) {\n\tfileName := \"testfile\"\n\tfilePath := filepath.Join(videoOutputDir, fileName)\n\t_ = os.WriteFile(filePath, []byte(\"test-data\"), 0644)\n\n\trsp, err := http.Get(With(srv.URL).Path(\"/video/testfile\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n\n\trsp, err = http.Get(With(srv.URL).Path(\"/video/?json\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n\tvar files []string\n\tassert.NoError(t, json.NewDecoder(rsp.Body).Decode(&files))\n\tassert.Equal(t, files, []string{\"testfile\"})\n\n\tdeleteReq, _ := http.NewRequest(http.MethodDelete, With(srv.URL).Path(\"/video/testfile\"), nil)\n\trsp, err = http.DefaultClient.Do(deleteReq)\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n\n\t//Deleting already deleted file\n\trsp, err = http.DefaultClient.Do(deleteReq)\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusNotFound)\n}\n\nfunc TestServeAndDeleteLogFile(t *testing.T) {\n\tfileName := \"logfile.log\"\n\tfilePath := filepath.Join(logOutputDir, fileName)\n\t_ = os.WriteFile(filePath, []byte(\"test-data\"), 0644)\n\n\trsp, err := http.Get(With(srv.URL).Path(\"/logs/logfile.log\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n\n\trsp, err = http.Get(With(srv.URL).Path(\"/logs/?json\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n\tvar files []string\n\tassert.NoError(t, json.NewDecoder(rsp.Body).Decode(&files))\n\tassert.True(t, len(files) > 0)\n\n\tdeleteReq, _ := http.NewRequest(http.MethodDelete, With(srv.URL).Path(\"/logs/logfile.log\"), nil)\n\trsp, err = http.DefaultClient.Do(deleteReq)\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n\n\trsp, err = http.DefaultClient.Do(deleteReq)\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusNotFound)\n}\n\nfunc TestFileDownload(t *testing.T) {\n\ttestFileDownload(t, func(sessionId string) string {\n\t\treturn fmt.Sprintf(\"/download/%s/testfile\", sessionId)\n\t})\n}\n\nfunc TestFileDownloadProtocolExtension(t *testing.T) {\n\ttestFileDownload(t, func(sessionId string) string {\n\t\treturn fmt.Sprintf(\"/wd/hub/session/%s/aerokube/download/testfile\", sessionId)\n\t})\n}\n\nfunc testFileDownload(t *testing.T, path func(string) string) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\trsp, err := http.Get(With(srv.URL).Path(path(sess[\"sessionId\"])))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tdata, err := io.ReadAll(rsp.Body)\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(data), \"test-data\")\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestFileDownloadMissingSession(t *testing.T) {\n\trsp, err := http.Get(With(srv.URL).Path(\"/download/missing-session/testfile\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusNotFound)\n}\n\nfunc TestClipboard(t *testing.T) {\n\ttestClipboard(t, func(sessionId string) string {\n\t\treturn fmt.Sprintf(\"/clipboard/%s\", sessionId)\n\t})\n}\n\nfunc TestClipboardProtocolExtension(t *testing.T) {\n\ttestClipboard(t, func(sessionId string) string {\n\t\treturn fmt.Sprintf(\"/wd/hub/session/%s/aerokube/clipboard\", sessionId)\n\t})\n}\n\nfunc testClipboard(t *testing.T, path func(string) string) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\trsp, err := http.Get(With(srv.URL).Path(path(sess[\"sessionId\"])))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tdata, err := io.ReadAll(rsp.Body)\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(data), \"test-clipboard-value\")\n\n\trsp, err = http.Post(With(srv.URL).Path(path(sess[\"sessionId\"])), \"text/plain\", bytes.NewReader([]byte(\"any-data\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestClipboardMissingSession(t *testing.T) {\n\trsp, err := http.Get(With(srv.URL).Path(\"/clipboard/missing-session\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusNotFound)\n}\n\nfunc TestDevtools(t *testing.T) {\n\tmanager = &HTTPTest{Handler: Selenium()}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]string\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tu := fmt.Sprintf(\"ws://%s/devtools/%s\", srv.Listener.Addr().String(), sess[\"sessionId\"])\n\n\tctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)\n\tdefer cancel()\n\n\tconn, err := rpcc.DialContext(ctx, u)\n\tassert.NoError(t, err)\n\tdefer conn.Close()\n\n\tc := cdp.NewClient(conn)\n\terr = c.Page.Enable(ctx)\n\tassert.NoError(t, err)\n\n\tsessions.Remove(sess[\"sessionId\"])\n\tqueue.Release()\n}\n\nfunc TestAddedSeCdpCapability(t *testing.T) {\n\tfn := func(input map[string]interface{}) {\n\t\tinput[\"value\"] = map[string]interface{}{\n\t\t\t\"sessionId\":    input[\"sessionId\"],\n\t\t\t\"capabilities\": map[string]interface{}{\"browserVersion\": \"some-version\"},\n\t\t}\n\t\tdelete(input, \"sessionId\")\n\t}\n\tmanager = &HTTPTest{Handler: Selenium(fn)}\n\n\tresp, err := http.Post(With(srv.URL).Path(\"/wd/hub/session\"), \"\", bytes.NewReader([]byte(\"{}\")))\n\tassert.NoError(t, err)\n\tassert.Equal(t, resp.StatusCode, http.StatusOK)\n\tvar sess map[string]interface{}\n\tassert.NoError(t, json.NewDecoder(resp.Body).Decode(&sess))\n\n\tctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)\n\tdefer cancel()\n\n\trv, ok := sess[\"value\"]\n\tassert.True(t, ok)\n\tvalue, ok := rv.(map[string]interface{})\n\tassert.True(t, ok)\n\trc, ok := value[\"capabilities\"]\n\tassert.True(t, ok)\n\trs, ok := value[\"sessionId\"]\n\tassert.True(t, ok)\n\tsessionId, ok := rs.(string)\n\tassert.True(t, ok)\n\tcapabilities, ok := rc.(map[string]interface{})\n\tassert.True(t, ok)\n\trcv, ok := capabilities[\"se:cdpVersion\"]\n\tassert.True(t, ok)\n\tcv, ok := rcv.(string)\n\tassert.True(t, ok)\n\tassert.NotEmpty(t, cv)\n\trws, ok := capabilities[\"se:cdp\"]\n\tassert.True(t, ok)\n\tws, ok := rws.(string)\n\tassert.True(t, ok)\n\tassert.NotEmpty(t, ws)\n\tconn, err := rpcc.DialContext(ctx, ws)\n\tassert.NoError(t, err)\n\tdefer conn.Close()\n\n\tc := cdp.NewClient(conn)\n\terr = c.Page.Enable(ctx)\n\tassert.NoError(t, err)\n\n\tsessions.Remove(sessionId)\n\tqueue.Release()\n}\n\nfunc TestParseGgrHost(t *testing.T) {\n\th := parseGgrHost(\"some-host.example.com:4444\")\n\tassert.Equal(t, h.Name, \"some-host.example.com\")\n\tassert.Equal(t, h.Port, 4444)\n}\n\nfunc TestWelcomeScreen(t *testing.T) {\n\trsp, err := http.Get(With(srv.URL).Path(\"/\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n\n\trsp, err = http.Get(With(srv.URL).Path(\"/wd/hub\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, rsp.StatusCode, http.StatusOK)\n}\n"
        },
        {
          "name": "service",
          "type": "tree",
          "content": null
        },
        {
          "name": "service_test.go",
          "type": "blob",
          "size": 10.5234375,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aerokube/selenoid/config\"\n\t\"github.com/aerokube/selenoid/service\"\n\t\"github.com/aerokube/selenoid/session\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/client\"\n\tassert \"github.com/stretchr/testify/require\"\n\t\"golang.org/x/net/websocket\"\n)\n\nvar (\n\tmockServer *httptest.Server\n\tlock       sync.Mutex\n)\n\nfunc init() {\n\tupdateMux(testMux())\n\ttimeout = 2 * time.Second\n\tserviceStartupTimeout = 1 * time.Second\n\tnewSessionAttemptTimeout = 1 * time.Second\n\tsessionDeleteTimeout = 1 * time.Second\n}\n\nfunc updateMux(mux http.Handler) {\n\tlock.Lock()\n\tdefer lock.Unlock()\n\tmockServer = httptest.NewServer(mux)\n\t_ = os.Setenv(\"DOCKER_HOST\", \"tcp://\"+hostPort(mockServer.URL))\n\t_ = os.Setenv(\"DOCKER_API_VERSION\", \"1.29\")\n\tcli, _ = client.NewClientWithOpts(client.FromEnv)\n}\n\nfunc testMux() http.Handler {\n\tmux := http.NewServeMux()\n\n\t//Selenium Hub mock\n\tmux.HandleFunc(\"/wd/hub\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t},\n\t))\n\n\t//Docker API mock\n\tmux.HandleFunc(\"/v1.29/containers/create\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusCreated)\n\t\t\toutput := `{\"id\": \"e90e34656806\", \"warnings\": []}`\n\t\t\t_, _ = w.Write([]byte(output))\n\t\t},\n\t))\n\tmux.HandleFunc(\"/v1.29/containers/e90e34656806/start\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusNoContent)\n\t\t},\n\t))\n\tmux.HandleFunc(\"/v1.29/containers/e90e34656806/kill\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusNoContent)\n\t\t},\n\t))\n\tmux.HandleFunc(\"/v1.29/containers/e90e34656806/logs\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Header().Add(\"Content-Type\", \"text/plain; charset=utf-8\")\n\t\t\tw.Header().Add(\"Transfer-Encoding\", \"chunked\")\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tconst streamTypeStderr = 2\n\t\t\theader := []byte{streamTypeStderr, 0, 0, 0, 0, 0, 0, 9}\n\t\t\t_, _ = w.Write(header)\n\t\t\tdata := []byte(\"test-data\")\n\t\t\t_, _ = w.Write(data)\n\t\t},\n\t))\n\tmux.HandleFunc(\"/v%s/containers/e90e34656806\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusNoContent)\n\t\t},\n\t))\n\tmux.HandleFunc(\"/v1.29/containers/e90e34656806/json\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tp := port(mockServer.URL)\n\t\t\toutput := fmt.Sprintf(`\t\t\t\n\t\t\t{\n\t\t\t  \"Id\": \"e90e34656806\",\n\t\t\t  \"Created\": \"2015-01-06T15:47:31.485331387Z\",\n\t\t\t  \"Driver\": \"aufs\",\n\t\t\t  \"HostConfig\": {},\n\t\t\t  \"NetworkSettings\": {\n\t\t\t    \"Ports\": {\n\t\t\t\t\t\"4444/tcp\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\"HostIp\": \"0.0.0.0\",\n\t\t\t\t\t\t\"HostPort\": \"%s\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"7070/tcp\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\"HostIp\": \"0.0.0.0\",\n\t\t\t\t\t\t\"HostPort\": \"%s\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"8080/tcp\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\"HostIp\": \"0.0.0.0\",\n\t\t\t\t\t\t\"HostPort\": \"%s\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"9090/tcp\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\"HostIp\": \"0.0.0.0\",\n\t\t\t\t\t\t\"HostPort\": \"%s\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"5900/tcp\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\"HostIp\": \"0.0.0.0\",\n\t\t\t\t\t\t\"HostPort\": \"5900\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"%s/tcp\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\"HostIp\": \"0.0.0.0\",\n\t\t\t\t\t\t\"HostPort\": \"%s\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t    },\n\t\t\t\t\"Networks\": {\n\t\t\t\t\t\"bridge\": {\n\t\t\t\t\t\t\"IPAMConfig\": null,\n\t\t\t\t\t\t\"Links\": null,\n\t\t\t\t\t\t\"Aliases\": null,\n\t\t\t\t\t\t\"NetworkID\": \"0152391a00ed79360bcf69401f7e2659acfab9553615726dbbcfc08b4f367b25\",\n\t\t\t\t\t\t\"EndpointID\": \"6a36b6f58b37490666329fd0fd74b21aa4eba939dd1ce466bdb6e0f826d56f98\",\n\t\t\t\t\t\t\"Gateway\": \"127.0.0.1\",\n\t\t\t\t\t\t\"IPAddress\": \"127.0.0.1\",\n\t\t\t\t\t\t\"IPPrefixLen\": 16,\n\t\t\t\t\t\t\"IPv6Gateway\": \"\",\n\t\t\t\t\t\t\"GlobalIPv6Address\": \"\",\n\t\t\t\t\t\t\"GlobalIPv6PrefixLen\": 0,\n\t\t\t\t\t\t\"MacAddress\": \"02:42:ac:11:00:02\"\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t  },\n\t\t\t  \"State\": {},\n\t\t\t  \"Mounts\": []\n\t\t\t}\n\t\t\t`, p, p, p, p, p, p)\n\t\t\t_, _ = w.Write([]byte(output))\n\t\t},\n\t))\n\tmux.HandleFunc(\"/v1.29/networks/net-1/connect\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t},\n\t))\n\treturn mux\n}\n\nfunc parseUrl(input string) *url.URL {\n\tu, err := url.Parse(input)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn u\n}\n\nfunc hostPort(input string) string {\n\treturn parseUrl(input).Host\n}\n\nfunc port(input string) string {\n\treturn parseUrl(input).Port()\n}\n\nfunc testConfig(env *service.Environment) *config.Config {\n\tconf := config.NewConfig()\n\tp := \"4444\"\n\tif env.InDocker {\n\t\tp = port(mockServer.URL)\n\t}\n\tconf.Browsers[\"firefox\"] = config.Versions{\n\t\tDefault: \"33.0\",\n\t\tVersions: map[string]*config.Browser{\n\t\t\t\"33.0\": {\n\t\t\t\tImage:   \"selenoid/firefox:33.0\",\n\t\t\t\tTmpfs:   map[string]string{\"/tmp\": \"size=128m\"},\n\t\t\t\tPort:    p,\n\t\t\t\tVolumes: []string{\"/test:/test\"},\n\t\t\t\tLabels:  map[string]string{\"key\": \"value\"},\n\t\t\t\tSysctl:  map[string]string{\"sysctl net.ipv4.tcp_timestamps\": \"2\"},\n\t\t\t\tMem:     \"512m\",\n\t\t\t\tCpu:     \"1.0\",\n\t\t\t},\n\t\t},\n\t}\n\tconf.Browsers[\"internet explorer\"] = config.Versions{\n\t\tDefault: \"11\",\n\t\tVersions: map[string]*config.Browser{\n\t\t\t\"11\": {\n\t\t\t\tImage: []interface{}{\n\t\t\t\t\t\"/usr/bin/test-command\", \"-arg\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\treturn conf\n}\n\nfunc testEnvironment() *service.Environment {\n\tlogOutputDir, _ = os.MkdirTemp(\"\", \"selenoid-test\")\n\treturn &service.Environment{\n\t\tCPU:                 int64(0),\n\t\tMemory:              int64(0),\n\t\tNetwork:             containerNetwork,\n\t\tStartupTimeout:      serviceStartupTimeout,\n\t\tCaptureDriverLogs:   captureDriverLogs,\n\t\tVideoContainerImage: \"aerokube/video-recorder\",\n\t\tVideoOutputDir:      \"/some/dir\",\n\t\tLogOutputDir:        logOutputDir,\n\t\tPrivileged:          false,\n\t}\n}\n\nfunc TestFindOutsideOfDocker(t *testing.T) {\n\tenv := testEnvironment()\n\tenv.InDocker = false\n\ttestDocker(t, env, testConfig(env))\n}\n\nfunc TestFindInsideOfDocker(t *testing.T) {\n\tenv := testEnvironment()\n\tenv.InDocker = true\n\tcfg := testConfig(env)\n\tlogConfig := make(map[string]string)\n\tcfg.ContainerLogs = &container.LogConfig{\n\t\tType:   \"rsyslog\",\n\t\tConfig: logConfig,\n\t}\n\ttestDocker(t, env, cfg)\n}\n\nfunc TestFindDockerIPSpecified(t *testing.T) {\n\tenv := testEnvironment()\n\tenv.IP = \"127.0.0.1\"\n\ttestDocker(t, env, testConfig(env))\n}\n\nfunc testDocker(t *testing.T, env *service.Environment, cfg *config.Config) {\n\tstarter := createDockerStarter(t, env, cfg)\n\tstartedService, err := starter.StartWithCancel()\n\tassert.NoError(t, err)\n\tassert.NotNil(t, startedService.Url)\n\tassert.NotNil(t, startedService.Container)\n\tassert.Equal(t, startedService.Container.ID, \"e90e34656806\")\n\tassert.Equal(t, startedService.HostPort.VNC, \"127.0.0.1:5900\")\n\tassert.NotNil(t, startedService.Cancel)\n\tstartedService.Cancel()\n}\n\nfunc createDockerStarter(t *testing.T, env *service.Environment, cfg *config.Config) service.Starter {\n\tcli, err := client.NewClientWithOpts(client.FromEnv)\n\tassert.NoError(t, err)\n\tmanager := service.DefaultManager{Environment: env, Client: cli, Config: cfg}\n\tcaps := session.Caps{\n\t\tDeviceName:            \"firefox\",\n\t\tVersion:               \"33.0\",\n\t\tScreenResolution:      \"1024x768\",\n\t\tSkin:                  \"WXGA800\",\n\t\tVNC:                   true,\n\t\tVideo:                 true,\n\t\tVideoScreenSize:       \"1024x768\",\n\t\tVideoFrameRate:        25,\n\t\tVideoCodec:            \"libx264\",\n\t\tLog:                   true,\n\t\tLogName:               \"testfile\",\n\t\tEnv:                   []string{\"LANG=ru_RU.UTF-8\", \"LANGUAGE=ru:en\"},\n\t\tHostsEntries:          []string{\"example.com:192.168.0.1\", \"test.com:192.168.0.2\"},\n\t\tDNSServers:            []string{\"192.168.0.1\", \"192.168.0.2\"},\n\t\tLabels:                map[string]string{\"label1\": \"some-value\", \"label2\": \"\"},\n\t\tApplicationContainers: []string{\"one\", \"two\"},\n\t\tAdditionalNetworks:    []string{\"net-1\"},\n\t\tTimeZone:              \"Europe/Moscow\",\n\t\tContainerHostname:     \"some-hostname\",\n\t\tTestName:              \"my-cool-test\",\n\t}\n\tstarter, success := manager.Find(caps, 42)\n\tassert.True(t, success)\n\tassert.NotNil(t, starter)\n\treturn starter\n}\n\nfunc failingMux(numDeleteRequests *int) http.Handler {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/v1.29/containers/create\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusCreated)\n\t\t\toutput := `{\"id\": \"e90e34656806\", \"warnings\": []}`\n\t\t\t_, _ = w.Write([]byte(output))\n\t\t},\n\t))\n\tmux.HandleFunc(\"/v1.29/containers/e90e34656806/start\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t},\n\t))\n\tmux.HandleFunc(\"/v1.29/containers/e90e34656806\", http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t*numDeleteRequests++\n\t\t\tw.WriteHeader(http.StatusNoContent)\n\t\t},\n\t))\n\treturn mux\n}\n\nfunc TestDeleteContainerOnStartupError(t *testing.T) {\n\tnumDeleteRequests := 0\n\tupdateMux(failingMux(&numDeleteRequests))\n\tdefer updateMux(testMux())\n\tenv := testEnvironment()\n\tstarter := createDockerStarter(t, env, testConfig(env))\n\t_, err := starter.StartWithCancel()\n\tassert.Error(t, err)\n\tassert.Equal(t, numDeleteRequests, 1)\n}\n\nfunc TestFindDriver(t *testing.T) {\n\tenv := testEnvironment()\n\tmanager := service.DefaultManager{Environment: env, Config: testConfig(env)}\n\tcaps := session.Caps{\n\t\tName:             \"internet explorer\", //Using default version\n\t\tScreenResolution: \"1024x768\",\n\t\tVNC:              true,\n\t}\n\tstarter, success := manager.Find(caps, 42)\n\tassert.True(t, success)\n\tassert.NotNil(t, starter)\n}\n\nfunc TestGetVNC(t *testing.T) {\n\n\tsrv := httptest.NewServer(handler())\n\tdefer srv.Close()\n\n\ttestTcpServer := testTCPServer(\"test-data\")\n\tsessions.Put(\"test-session\", &session.Session{\n\t\tHostPort: session.HostPort{\n\t\t\tVNC: testTcpServer.Addr().String(),\n\t\t},\n\t})\n\tdefer sessions.Remove(\"test-session\")\n\n\tu := fmt.Sprintf(\"ws://%s/vnc/test-session\", hostPort(srv.URL))\n\tassert.Equal(t, readDataFromWebSocket(t, u), \"test-data\")\n}\n\nfunc testTCPServer(data string) net.Listener {\n\tl, _ := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tgo func() {\n\t\tfor {\n\t\t\tconn, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t_, _ = io.WriteString(conn, data)\n\t\t\t_ = conn.Close()\n\t\t\treturn\n\t\t}\n\t}()\n\treturn l\n}\n\nfunc readDataFromWebSocket(t *testing.T, wsURL string) string {\n\tws, err := websocket.Dial(wsURL, \"\", \"http://localhost\")\n\tassert.NoError(t, err)\n\n\tvar msg = make([]byte, 512)\n\t_, err = ws.Read(msg)\n\tmsg = bytes.Trim(msg, \"\\x00\")\n\t//assert.NoError(t, err)\n\treturn string(msg)\n}\n\nfunc TestGetLogs(t *testing.T) {\n\n\tsrv := httptest.NewServer(handler())\n\tdefer srv.Close()\n\n\tsessions.Put(\"test-session\", &session.Session{\n\t\tContainer: &session.Container{\n\t\t\tID:        \"e90e34656806\",\n\t\t\tIPAddress: \"127.0.0.1\",\n\t\t},\n\t})\n\tdefer sessions.Remove(\"test-session\")\n\n\tu := fmt.Sprintf(\"ws://%s/logs/test-session\", hostPort(srv.URL))\n\tassert.Equal(t, readDataFromWebSocket(t, u), \"test-data\")\n}\n"
        },
        {
          "name": "session",
          "type": "tree",
          "content": null
        },
        {
          "name": "upload",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 6.8115234375,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aerokube/selenoid/protect\"\n\t\"github.com/aerokube/selenoid/service\"\n\t\"github.com/aerokube/selenoid/session\"\n\t\"github.com/google/uuid\"\n\t\"github.com/gorilla/websocket\"\n\tassert \"github.com/stretchr/testify/require\"\n)\n\ntype HTTPTest struct {\n\tHandler http.Handler\n\tAction  func(s *httptest.Server)\n\tCancel  chan bool\n}\n\nfunc HTTPResponse(msg string, status int) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Error(w, msg, status)\n\t})\n}\n\nfunc (m *HTTPTest) StartWithCancel() (*service.StartedService, error) {\n\tlog.Println(\"Starting HTTPTest Service...\")\n\ts := httptest.NewServer(m.Handler)\n\tu, err := url.Parse(s.URL)\n\tif err != nil {\n\t\tlog.Println(\"Failed to start HTTPTest Service...\")\n\t\treturn nil, err\n\t}\n\tlog.Println(\"HTTPTest Service started...\")\n\tif m.Action != nil {\n\t\tm.Action(s)\n\t}\n\tss := service.StartedService{\n\t\tUrl: u,\n\t\tHostPort: session.HostPort{\n\t\t\tFileserver: u.Host,\n\t\t\tClipboard:  u.Host,\n\t\t\tVNC:        u.Host,\n\t\t\tDevtools:   u.Host,\n\t\t},\n\t\tCancel: func() {\n\t\t\tlog.Println(\"Stopping HTTPTest Service...\")\n\t\t\ts.Close()\n\t\t\tlog.Println(\"HTTPTest Service stopped...\")\n\t\t\tif m.Cancel != nil {\n\t\t\t\tgo func() {\n\t\t\t\t\tm.Cancel <- true\n\t\t\t\t}()\n\t\t\t}\n\t\t},\n\t}\n\treturn &ss, nil\n}\n\nfunc (m *HTTPTest) Find(caps session.Caps, requestId uint64) (service.Starter, bool) {\n\treturn m, true\n}\n\ntype StartupError struct{}\n\nfunc (m *StartupError) StartWithCancel() (*service.StartedService, error) {\n\tlog.Println(\"Starting StartupError Service...\")\n\tlog.Println(\"Failed to start StartupError Service...\")\n\treturn nil, errors.New(\"failed to start Service\")\n}\n\nfunc (m *StartupError) Find(caps session.Caps, requestId uint64) (service.Starter, bool) {\n\treturn m, true\n}\n\ntype BrowserNotFound struct{}\n\nfunc (m *BrowserNotFound) Find(caps session.Caps, requestId uint64) (service.Starter, bool) {\n\treturn nil, false\n}\n\ntype With string\n\nfunc (r With) Path(p string) string {\n\treturn fmt.Sprintf(\"%s%s\", r, p)\n}\n\nfunc Selenium(nsp ...func(map[string]interface{})) http.Handler {\n\tvar lock sync.RWMutex\n\tsessions := make(map[string]struct{})\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/session\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\t\tu := uuid.NewString()\n\t\tlock.Lock()\n\t\tsessions[u] = struct{}{}\n\t\tlock.Unlock()\n\t\tret := map[string]interface{}{\n\t\t\t\"sessionId\": u,\n\t\t}\n\t\tfor _, n := range nsp {\n\t\t\tn(ret)\n\t\t}\n\t\t_ = json.NewEncoder(w).Encode(&ret)\n\t})\n\tmux.HandleFunc(\"/session/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tu := strings.Split(r.URL.Path, \"/\")[2]\n\t\tlock.RLock()\n\t\t_, ok := sessions[u]\n\t\tlock.RUnlock()\n\t\tif !ok {\n\t\t\thttp.Error(w, \"Session not found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tif r.FormValue(\"abort-handler\") != \"\" {\n\t\t\tout := \"this call was relayed by the reverse proxy\"\n\t\t\t// Setting wrong Content-Length leads to abort handler error\n\t\t\tw.Header().Add(\"Content-Length\", strconv.Itoa(2*len(out)))\n\t\t\t_, _ = fmt.Fprintln(w, out)\n\t\t\treturn\n\t\t}\n\t\td, _ := time.ParseDuration(r.FormValue(\"timeout\"))\n\t\tif r.Method != http.MethodDelete {\n\t\t\t<-time.After(d)\n\t\t\treturn\n\t\t}\n\t\tlock.Lock()\n\t\tdelete(sessions, u)\n\t\tlock.Unlock()\n\t})\n\tmux.HandleFunc(\"/testfile\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = w.Write([]byte(\"test-data\"))\n\t})\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(_ *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Upgrade\") != \"\" {\n\t\t\tc, err := upgrader.Upgrade(w, r, nil)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tdefer c.Close()\n\t\t\tfor {\n\t\t\t\tmt, message, err := c.ReadMessage()\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttype req struct {\n\t\t\t\t\tID uint64 `json:\"id\"`\n\t\t\t\t}\n\t\t\t\tvar r req\n\t\t\t\terr = json.Unmarshal(message, &r)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\toutput, err := json.Marshal(r)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\terr = c.WriteMessage(mt, output)\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = w.Write([]byte(\"test-clipboard-value\"))\n\t})\n\treturn mux\n}\n\nfunc TestProcessExtensionCapabilities(t *testing.T) {\n\tcapsJson := `{\n\t\t\"version\": \"57.0\",\n\t\t\"browserName\": \"firefox\",\n\t\t\"appium:deviceName\": \"android\",\n\t\t\"selenoid:options\": {\n\t\t\t\"name\": \"ExampleTestName\",\n\t\t\t\"enableVNC\": true,\n\t\t\t\"videoFrameRate\": 24,\n\t\t\t\"env\": [\"LANG=de_DE.UTF-8\"],\n\t\t\t\"labels\": {\"key\": \"value\"}\n\t\t}\n\t}`\n\tvar caps session.Caps\n\terr := json.Unmarshal([]byte(capsJson), &caps)\n\tassert.NoError(t, err)\n\tassert.Equal(t, caps.Name, \"firefox\")\n\tassert.Equal(t, caps.Version, \"57.0\")\n\tassert.Equal(t, caps.TestName, \"\")\n\n\tcaps.ProcessExtensionCapabilities()\n\tassert.Equal(t, caps.Name, \"firefox\")\n\tassert.Equal(t, caps.Version, \"57.0\")\n\tassert.Equal(t, caps.DeviceName, \"android\")\n\tassert.Equal(t, caps.TestName, \"ExampleTestName\")\n\tassert.True(t, caps.VNC)\n\tassert.Equal(t, caps.VideoFrameRate, uint16(24))\n\tassert.Equal(t, caps.Env, []string{\"LANG=de_DE.UTF-8\"})\n\tassert.Equal(t, caps.Labels, map[string]string{\"key\": \"value\"})\n}\n\nfunc TestSumUsedTotalGreaterThanPending(t *testing.T) {\n\tqueue := protect.New(2, false)\n\n\thf := func(_ http.ResponseWriter, _ *http.Request) {\n\t\ttime.Sleep(50 * time.Millisecond)\n\t}\n\tqueuedHandlerFunc := queue.Try(queue.Check(queue.Protect(hf)))\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", queuedHandlerFunc)\n\n\tsrv := httptest.NewServer(mux)\n\tdefer srv.Close()\n\tu := srv.URL + \"/\"\n\n\t_, err := http.Get(u)\n\tassert.NoError(t, err)\n\tassert.Equal(t, queue.Pending(), 1)\n\tqueue.Create()\n\tassert.Equal(t, queue.Pending(), 0)\n\tassert.Equal(t, queue.Used(), 1)\n\n\t_, err = http.Get(u)\n\tassert.NoError(t, err)\n\tassert.Equal(t, queue.Pending(), 1)\n\tqueue.Create()\n\tassert.Equal(t, queue.Pending(), 0)\n\tassert.Equal(t, queue.Used(), 2)\n\n\treq, _ := http.NewRequest(http.MethodGet, u, nil)\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\treq = req.WithContext(ctx)\n\n\t_, err = http.DefaultClient.Do(req)\n\tassert.Error(t, err)\n\tassert.Equal(t, queue.Pending(), 0)\n\tassert.Equal(t, queue.Used(), 2)\n}\n\nfunc TestBrowserName(t *testing.T) {\n\tvar caps session.Caps\n\n\tvar capsJson = `{\n\t\t\"appium:deviceName\": \"iPhone 7\"\n\t}`\n\terr := json.Unmarshal([]byte(capsJson), &caps)\n\tassert.NoError(t, err)\n\tassert.Equal(t, caps.BrowserName(), \"iPhone 7\")\n\n\tcapsJson = `{\n\t\t\"deviceName\": \"android 11\"\n\t}`\n\terr = json.Unmarshal([]byte(capsJson), &caps)\n\tassert.NoError(t, err)\n\tassert.Equal(t, caps.BrowserName(), \"android 11\")\n\n\tcapsJson = `{\n\t\t\"deviceName\": \"android 11\",\n\t\t\"appium:deviceName\": \"iPhone 7\",\n\t\t\"browserName\": \"firefox\"\n\t}`\n\terr = json.Unmarshal([]byte(capsJson), &caps)\n\tassert.NoError(t, err)\n\tassert.Equal(t, caps.BrowserName(), \"firefox\")\n}\n"
        }
      ]
    }
  ]
}