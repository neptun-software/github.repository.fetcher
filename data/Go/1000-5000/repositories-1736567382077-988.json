{
  "metadata": {
    "timestamp": 1736567382077,
    "page": 988,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "constabulary/gb",
      "stars": 2145,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 1.2060546875,
          "content": "version: build-{build}.{branch}\n\nclone_folder: C:\\gopath\\src\\github.com\\constabulary\\gb\nshallow_clone: true # for startup speed\n\nenvironment:\n  GOPATH: C:\\gopath\n  matrix:\n  - environment:\n    GOVERSION: 1.6.3\n  - environment:\n    GOVERSION: 1.7.5\n  - environment:\n    GOVERSION: 1.8.1\n\nplatform:\n  - x64\n  #- x86\n# the \"x86\" platform still gives us GOARCH=amd64 :/\n# TODO(tianon) we have 32bit Go installed at C:\\go-x86 and 32bit mingw at both C:\\msys64\\mingw32 and C:\\MinGW, so we could do something\n\n# http://www.appveyor.com/docs/installed-software\ninstall:\n  # some helpful output for debugging builds\n  - go version\n  - go env\n  # pre-installed MinGW at C:\\MinGW is 32bit only\n  # but MSYS2 at C:\\msys64 has mingw64\n  - set PATH=C:\\msys64\\mingw64\\bin;%PATH%\n  - gcc --version\n  - g++ --version\n  # need bzr for several tests\n  - choco install -y --force bzr\n  - set PATH=C:\\Program Files (x86)\\Bazaar;%PATH%\n  - bzr --version\n  # TODO(tianon) - git clone --depth 1 https://github.com/constabulary/integration-tests.git\n\nbuild_script:\n  - go get github.com/pkg/errors\n  - go install -v ./...\n\ntest_script:\n  - set PATH=C:\\gopath\\bin;%PATH%\n  - gb help\n  - go test -v ./...\n\n#artifacts:\n#  - path: '%GOPATH%\\bin\\*.exe'\ndeploy: off\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0166015625,
          "content": "!*\ntestdata/bin/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.791015625,
          "content": "language: go\ngo_import_path: github.com/constabulary/gb\ngo:\n  - 1.6.x\n  - 1.7.x\n  - 1.8.x\n  - tip\n\nsudo: false\n\naddons:\n  apt:\n    packages:\n      - libcap-dev # integration-tests/service.v1\n  ssh_known_hosts:\n      - bitbucket.org\n\ninstall:\n  - go get -t -v ./...\n  - git clone --quiet --single-branch --depth 1 https://github.com/constabulary/integration-tests.git ../integration-tests\n  - if [[ $TRAVIS_GO_VERSION == 1.4* ]]; then go get -u golang.org/x/tools/cmd/cover; fi\n  - echo '#!/bin/bash' > \"$GOPATH/bin/sudo\"\n    && echo 'echo >&2 attempted sudo \"$@\"' >> \"$GOPATH/bin/sudo\"\n    && chmod +x \"$GOPATH/bin/sudo\"\n\nscript:\n  - go install -v ./...\n    && bin/coverage.sh\n    && go build\n    && gb test \n    && ../integration-tests/run-all.bash\n\nafter_success:\n  - bash <(curl -s https://codecov.io/bash)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 constabulary\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.2265625,
          "content": "# gb\n\n### Build status\nUnix:\n[![travis-cs status](https://travis-ci.org/constabulary/gb.svg \"travis-ci status\")](https://travis-ci.org/constabulary/gb)\n\nWindows:\n[![Build status](https://ci.appveyor.com/api/projects/status/rjttg1agmp2sra3h/branch/master?svg=true)](https://ci.appveyor.com/project/davecheney/gb/branch/master)\n\n[![codecov.io](https://codecov.io/github/constabulary/gb/branch/master/graph/badge.svg)](https://codecov.io/github/constabulary/gb)\n\n`gb` is a proof of concept replacement build tool for the [Go programming language](https://golang.org).\n\nI gave a talk about `gb` and the rational for its creation at GDG Berlin in April 2015, [video](https://www.youtube.com/watch?v=c3dW80eO88I) and [slides](http://go-talks.appspot.com/github.com/davecheney/presentations/reproducible-builds.slide#1).\n\n## Project based\n\n`gb` operates on the concept of a project. A gb project is a workspace for all the Go code that is required to build your project.\n\nA gb project is a folder on disk that contains a subdirectory named <code>src/</code>. That's it, no environment variables to set. For the rest of this document we'll refer to your <code>gb</code> project as <code>$PROJECT</code>.\n\nYou can create as many projects as you like and move between them simply by changing directories.\n\n## Installation\n\n    go get github.com/constabulary/gb/...\n\n## Read more\n\ngb has its own site, [getgb.io](http://getgb.io/), head over there for more information.\n\n## Contributing\n\n### Contribution guidelines\n\nWe welcome pull requests, bug fixes and issue reports.\n\nBefore proposing a large change, please discuss your change by raising an issue.\n\n### Road map\n\n#### Completed\n\n- [Cross Compilation](https://github.com/constabulary/gb/milestones/cross-compilation)\n- Tag handling, unify -tags, ENVVARS and GOOS/GOARCH into a single format for binary names and pkg cache\n- gb test improvements, test output, test flag handling\n- [Race detector support](https://github.com/constabulary/gb/issues/96)\n\n#### Todo\n\n- 0.4 series: gb vendor updates and bug fixes\n- 0.5 series: new package resolver (replace go/build)\n\n### Big ticket items \n\nBig ticket items that are not on the road map yet\n\n- Package BuildID support (make stale detection work like the Go 1.5)\n- `gccgo` toolchain support.\n"
        },
        {
          "name": "action_test.go",
          "type": "blob",
          "size": 2.2119140625,
          "content": "package gb\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestBuildAction(t *testing.T) {\n\tvar tests = []struct {\n\t\tpkg    string\n\t\taction *Action\n\t\terr    error\n\t}{{\n\t\tpkg: \"a\",\n\t\taction: &Action{\n\t\t\tName: \"build: a\",\n\t\t\tDeps: []*Action{{Name: \"compile: a\"}},\n\t\t},\n\t}, {\n\t\tpkg: \"b\",\n\t\taction: &Action{\n\t\t\tName: \"build: b\",\n\t\t\tDeps: []*Action{\n\t\t\t\t{\n\t\t\t\t\tName: \"link: b\",\n\t\t\t\t\tDeps: []*Action{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"compile: b\",\n\t\t\t\t\t\t\tDeps: []*Action{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName: \"compile: a\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}, {\n\t\tpkg: \"c\",\n\t\taction: &Action{\n\t\t\tName: \"build: c\",\n\t\t\tDeps: []*Action{\n\t\t\t\t{\n\t\t\t\t\tName: \"compile: c\",\n\t\t\t\t\tDeps: []*Action{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"compile: a\",\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tName: \"compile: d.v1\",\n\t\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t},\n\t}}\n\tfor _, tt := range tests {\n\t\tctx := testContext(t)\n\t\tdefer ctx.Destroy()\n\t\tpkg, err := ctx.ResolvePackage(tt.pkg)\n\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"ctx.ResolvePackage(%v): want %v, got %v\", tt.pkg, tt.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tgot, err := BuildPackages(pkg)\n\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"BuildAction(%v): want %v, got %v\", tt.pkg, tt.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tdeleteTasks(got)\n\n\t\tif !reflect.DeepEqual(tt.action, got) {\n\t\t\tt.Errorf(\"BuildAction(%v): want %#+v, got %#+v\", tt.pkg, tt.action, got)\n\t\t}\n\n\t\t// double underpants\n\t\tsameAction(t, got, tt.action)\n\t}\n}\n\nfunc sameAction(t *testing.T, want, got *Action) {\n\tif want.Name != got.Name {\n\t\tt.Errorf(\"sameAction: names do not match, want: %v, got %v\", want.Name, got.Name)\n\t\treturn\n\t}\n\tif len(want.Deps) != len(got.Deps) {\n\t\tt.Errorf(\"sameAction(%v, %v): deps: len(want): %v, len(got): %v\", want.Name, got.Name, len(want.Deps), len(got.Deps))\n\t\treturn\n\t}\n\tw, g := make(map[string]*Action), make(map[string]*Action)\n\tfor _, a := range want.Deps {\n\t\tw[a.Name] = a\n\t}\n\tfor _, a := range got.Deps {\n\t\tg[a.Name] = a\n\t}\n\tvar wk []string\n\tfor k := range w {\n\t\twk = append(wk, k)\n\t}\n\tsort.Strings(wk)\n\tfor _, a := range wk {\n\t\tg, ok := g[a]\n\t\tif !ok {\n\t\t\tt.Errorf(\"sameAction(%v, %v): deps: want %v, got nil\", want.Name, got.Name, a)\n\t\t\tcontinue\n\t\t}\n\t\tsameAction(t, w[a], g)\n\t}\n}\n\nfunc deleteTasks(a *Action) {\n\tfor _, d := range a.Deps {\n\t\tdeleteTasks(d)\n\t}\n\ta.Run = nil\n}\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.go",
          "type": "blob",
          "size": 7.3291015625,
          "content": "package gb\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/constabulary/gb/internal/fileutils\"\n\t\"github.com/constabulary/gb/internal/version\"\n)\n\n// Build builds each of pkgs in succession. If pkg is a command, then the results of build include\n// linking the final binary into pkg.Context.Bindir().\nfunc Build(pkgs ...*Package) error {\n\tbuild, err := BuildPackages(pkgs...)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ExecuteConcurrent(build, runtime.NumCPU(), nil)\n}\n\n// BuildPackages produces a tree of *Actions that can be executed to build\n// a *Package.\n// BuildPackages walks the tree of *Packages and returns a corresponding\n// tree of *Actions representing the steps required to build *Package\n// and any of its dependencies\nfunc BuildPackages(pkgs ...*Package) (*Action, error) {\n\tif len(pkgs) < 1 {\n\t\treturn nil, errors.New(\"no packages supplied\")\n\t}\n\n\ttargets := make(map[string]*Action) // maps package importpath to build action\n\n\tnames := func(pkgs []*Package) []string {\n\t\tvar names []string\n\t\tfor _, pkg := range pkgs {\n\t\t\tnames = append(names, pkg.ImportPath)\n\t\t}\n\t\treturn names\n\t}\n\n\t// create top level build action to unify all packages\n\tt0 := time.Now()\n\tbuild := Action{\n\t\tName: fmt.Sprintf(\"build: %s\", strings.Join(names(pkgs), \",\")),\n\t\tRun: func() error {\n\t\t\tpkgs[0].debug(\"build duration: %v %v\", time.Since(t0), pkgs[0].Statistics.String())\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tfor _, pkg := range pkgs {\n\t\tif len(pkg.GoFiles)+len(pkg.CgoFiles) == 0 {\n\t\t\tpkg.debug(\"skipping %v: no go files\", pkg.ImportPath)\n\t\t\tcontinue\n\t\t}\n\t\ta, err := BuildPackage(targets, pkg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif a == nil {\n\t\t\t// nothing to do\n\t\t\tcontinue\n\t\t}\n\t\tbuild.Deps = append(build.Deps, a)\n\t}\n\treturn &build, nil\n}\n\n// BuildPackage returns an Action representing the steps required to\n// build this package.\nfunc BuildPackage(targets map[string]*Action, pkg *Package) (*Action, error) {\n\n\t// if this action is already present in the map, return it\n\t// rather than creating a new action.\n\tif a, ok := targets[pkg.ImportPath]; ok {\n\t\treturn a, nil\n\t}\n\n\t// step 0. are we stale ?\n\t// if this package is not stale, then by definition none of its\n\t// dependencies are stale, so ignore this whole tree.\n\tif pkg.NotStale {\n\t\treturn nil, nil\n\t}\n\n\t// step 1. build dependencies\n\tdeps, err := BuildDependencies(targets, pkg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// step 2. build this package\n\tbuild, err := Compile(pkg, deps...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif build == nil {\n\t\tpanic(\"build action was nil\") // shouldn't happen\n\t}\n\n\t// record the final action as the action that represents\n\t// building this package.\n\ttargets[pkg.ImportPath] = build\n\treturn build, nil\n}\n\n// Compile returns an Action representing the steps required to compile this package.\nfunc Compile(pkg *Package, deps ...*Action) (*Action, error) {\n\tvar gofiles []string\n\tgofiles = append(gofiles, pkg.GoFiles...)\n\n\t// step 1. are there any .c files that we have to run cgo on ?\n\tvar ofiles []string // additional ofiles to pack\n\tif len(pkg.CgoFiles) > 0 {\n\t\tcgoACTION, cgoOFILES, cgoGOFILES, err := cgo(pkg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tgofiles = append(gofiles, cgoGOFILES...)\n\t\tofiles = append(ofiles, cgoOFILES...)\n\t\tdeps = append(deps, cgoACTION)\n\t}\n\n\tif len(gofiles) == 0 {\n\t\treturn nil, fmt.Errorf(\"compile %q: no go files supplied\", pkg.ImportPath)\n\t}\n\n\t// step 2. compile all the go files for this package, including pkg.CgoFiles\n\tcompile := Action{\n\t\tName: fmt.Sprintf(\"compile: %s\", pkg.ImportPath),\n\t\tDeps: deps,\n\t\tRun:  func() error { return gc(pkg, gofiles) },\n\t}\n\n\t// step 3. are there any .s files to assemble.\n\tvar assemble []*Action\n\tfor _, sfile := range pkg.SFiles {\n\t\tsfile := sfile\n\t\tofile := filepath.Join(pkg.Context.Workdir(), pkg.ImportPath, stripext(sfile)+\".6\")\n\t\tassemble = append(assemble, &Action{\n\t\t\tName: fmt.Sprintf(\"asm: %s/%s\", pkg.ImportPath, sfile),\n\t\t\tRun: func() error {\n\t\t\t\tt0 := time.Now()\n\t\t\t\terr := pkg.tc.Asm(pkg, ofile, filepath.Join(pkg.Dir, sfile))\n\t\t\t\tpkg.Record(\"asm\", time.Since(t0))\n\t\t\t\treturn err\n\t\t\t},\n\t\t\t// asm depends on compile because compile will generate the local go_asm.h\n\t\t\tDeps: []*Action{&compile},\n\t\t})\n\t\tofiles = append(ofiles, ofile)\n\t}\n\n\t// step 4. add system object files.\n\tfor _, syso := range pkg.SysoFiles {\n\t\tofiles = append(ofiles, filepath.Join(pkg.Dir, syso))\n\t}\n\n\tbuild := &compile\n\n\t// Do we need to pack ? Yes, replace build action with pack.\n\tif len(ofiles) > 0 {\n\t\tpack := Action{\n\t\t\tName: fmt.Sprintf(\"pack: %s\", pkg.ImportPath),\n\t\t\tDeps: []*Action{\n\t\t\t\t&compile,\n\t\t\t},\n\t\t\tRun: func() error {\n\t\t\t\t// collect .o files, ofiles always starts with the gc compiled object.\n\t\t\t\t// TODO(dfc) objfile(pkg) should already be at the top of this set\n\t\t\t\tofiles = append(\n\t\t\t\t\t[]string{pkg.objfile()},\n\t\t\t\t\tofiles...,\n\t\t\t\t)\n\n\t\t\t\t// pack\n\t\t\t\tt0 := time.Now()\n\t\t\t\terr := pkg.tc.Pack(pkg, ofiles...)\n\t\t\t\tpkg.Record(\"pack\", time.Since(t0))\n\t\t\t\treturn err\n\t\t\t},\n\t\t}\n\t\tpack.Deps = append(pack.Deps, assemble...)\n\t\tbuild = &pack\n\t}\n\n\t// should this package be cached\n\tif pkg.Install && !pkg.TestScope {\n\t\tbuild = &Action{\n\t\t\tName: fmt.Sprintf(\"install: %s\", pkg.ImportPath),\n\t\t\tDeps: []*Action{build},\n\t\t\tRun:  func() error { return fileutils.Copyfile(pkg.installpath(), pkg.objfile()) },\n\t\t}\n\t}\n\n\t// if this is a main package, add a link stage\n\tif pkg.Main {\n\t\tbuild = &Action{\n\t\t\tName: fmt.Sprintf(\"link: %s\", pkg.ImportPath),\n\t\t\tDeps: []*Action{build},\n\t\t\tRun:  func() error { return pkg.link() },\n\t\t}\n\t}\n\tif !pkg.TestScope {\n\t\t// if this package is not compiled in test scope, then\n\t\t// log the name of the package when complete.\n\t\tbuild.Run = logInfoFn(build.Run, pkg.ImportPath)\n\t}\n\treturn build, nil\n}\n\nfunc logInfoFn(fn func() error, s string) func() error {\n\treturn func() error {\n\t\terr := fn()\n\t\tfmt.Println(s)\n\t\treturn err\n\t}\n}\n\n// BuildDependencies returns a slice of Actions representing the steps required\n// to build all dependant packages of this package.\nfunc BuildDependencies(targets map[string]*Action, pkg *Package) ([]*Action, error) {\n\tvar deps []*Action\n\tpkgs := pkg.Imports\n\n\tvar extra []string\n\tswitch {\n\tcase pkg.Main:\n\t\t// all binaries depend on runtime, even if they do not\n\t\t// explicitly import it.\n\t\textra = append(extra, \"runtime\")\n\t\tif pkg.race {\n\t\t\t// race binaries have extra implicit depdendenceis.\n\t\t\textra = append(extra, \"runtime/race\")\n\t\t}\n\tcase len(pkg.CgoFiles) > 0 && pkg.ImportPath != \"runtime/cgo\":\n\t\t// anything that uses cgo has a dependency on runtime/cgo which is\n\t\t// only visible after cgo file generation.\n\t\t// TODO(dfc) what about pkg.Main && pkg.CgoFiles > 0 ??\n\t\textra = append(extra, \"runtime/cgo\")\n\t}\n\tif pkg.TestScope {\n\t\textra = append(extra, \"regexp\")\n\t\tif version.Version > 1.7 {\n\t\t\t// since Go 1.8 tests have additional implicit dependencies\n\t\t\textra = append(extra, \"testing/internal/testdeps\")\n\t\t}\n\t}\n\tfor _, i := range extra {\n\t\tp, err := pkg.ResolvePackage(i)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpkgs = append(pkgs, p)\n\t}\n\tfor _, i := range pkgs {\n\t\ta, err := BuildPackage(targets, i)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif a == nil {\n\t\t\t// no action required for this Package\n\t\t\tcontinue\n\t\t}\n\t\tdeps = append(deps, a)\n\t}\n\treturn deps, nil\n}\n\nfunc gc(pkg *Package, gofiles []string) error {\n\tt0 := time.Now()\n\terr := pkg.tc.Gc(pkg, gofiles)\n\tpkg.Record(\"gc\", time.Since(t0))\n\treturn err\n}\n\nfunc (pkg *Package) link() error {\n\tt0 := time.Now()\n\terr := pkg.tc.Ld(pkg)\n\tpkg.Record(\"link\", time.Since(t0))\n\treturn err\n}\n"
        },
        {
          "name": "build_test.go",
          "type": "blob",
          "size": 7.650390625,
          "content": "package gb\n\nimport (\n\t\"errors\"\n\t\"go/build\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestBuild(t *testing.T) {\n\topts := func(o ...func(*Context) error) []func(*Context) error { return o }\n\ttests := []struct {\n\t\tpkg  string\n\t\topts []func(*Context) error\n\t\terr  error\n\t}{{\n\t\tpkg: \"a\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"b\", // actually command\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"c\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"d.v1\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"x\",\n\t\terr: errors.New(\"import cycle detected: x -> y -> x\"),\n\t}, {\n\t\tpkg: \"cgomain\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"cgotest\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"notestfiles\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"cgoonlynotest\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"testonly\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"extestonly\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"mainnoruntime\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"h\", // imports \"blank\", which is blank, see issue #131\n\t\terr: &build.NoGoError{Dir: filepath.Join(getwd(t), \"testdata\", \"src\", \"blank\")},\n\t}, {\n\t\tpkg: \"cppmain\",\n\t}, {\n\t\tpkg:  \"tags1\",\n\t\topts: opts(Tags(\"x\")), // excludes the test file in package\n\t\terr:  nogoerr(filepath.Join(getwd(t), \"testdata\", \"src\", \"tags1\")),\n\t}, {\n\t\tpkg: \"tags2\",\n\t\terr: nogoerr(filepath.Join(getwd(t), \"testdata\", \"src\", \"tags2\")),\n\t}, {\n\t\tpkg:  \"tags2\",\n\t\topts: opts(Tags(\"x\")),\n\t}, {\n\t\tpkg: \"nosource\",\n\t\terr: &build.NoGoError{Dir: filepath.Join(getwd(t), \"testdata\", \"src\", \"nosource\")},\n\t}}\n\n\tproj := testProject(t)\n\tfor _, tt := range tests {\n\t\tctx, err := NewContext(proj, tt.opts...)\n\t\tctx.Force = true\n\t\tdefer ctx.Destroy()\n\t\tpkg, err := ctx.ResolvePackage(tt.pkg)\n\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"ctx.ResolvePackage(%v): want %v, got %v\", tt.pkg, tt.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := Build(pkg); !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"ctx.Build(%v): want %v, got %v\", tt.pkg, tt.err, err)\n\t\t}\n\t}\n}\n\nfunc TestBuildPackage(t *testing.T) {\n\ttests := []struct {\n\t\tpkg string\n\t\terr error\n\t}{{\n\t\tpkg: \"a\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"b\", // actually command\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"c\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"d.v1\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"cgomain\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"cgotest\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"notestfiles\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"cgoonlynotest\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"testonly\",\n\t\terr: errors.New(`compile \"testonly\": no go files supplied`),\n\t}, {\n\t\tpkg: \"extestonly\",\n\t\terr: errors.New(`compile \"extestonly\": no go files supplied`),\n\t}}\n\n\tfor _, tt := range tests {\n\t\tctx := testContext(t)\n\t\tdefer ctx.Destroy()\n\t\tpkg, err := ctx.ResolvePackage(tt.pkg)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"ctx.ResolvePackage(%v):  %v\", tt.pkg, err)\n\t\t\tcontinue\n\t\t}\n\t\ttargets := make(map[string]*Action)\n\t\tif _, err := BuildPackage(targets, pkg); !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"ctx.BuildPackage(%v): want %v, got %v\", tt.pkg, tt.err, err)\n\t\t}\n\t}\n}\n\nfunc TestBuildPackages(t *testing.T) {\n\ttests := []struct {\n\t\tpkgs    []string\n\t\tactions []string\n\t\toptions []func(*Context) error // set of options to apply to the test context\n\t\terr     error\n\t}{{\n\t\tpkgs:    []string{\"a\", \"b\", \"c\"},\n\t\tactions: []string{\"compile: a\", \"compile: c\", \"link: b\"},\n\t}, {\n\t\tpkgs:    []string{\"cgotest\", \"cgomain\", \"notestfiles\", \"cgoonlynotest\", \"testonly\", \"extestonly\"},\n\t\tactions: []string{\"compile: notestfiles\", \"link: cgomain\", \"pack: cgoonlynotest\", \"pack: cgotest\"},\n\t}, {\n\t\tpkgs:    []string{\"a\", \"b\", \"c\"},\n\t\toptions: []func(*Context) error{WithRace},\n\t\tactions: []string{\"compile: a\", \"compile: c\", \"link: b\"},\n\t}}\n\n\tfor _, tt := range tests {\n\t\tctx := testContext(t, tt.options...)\n\t\tdefer ctx.Destroy()\n\t\tvar pkgs []*Package\n\t\tfor _, pkg := range tt.pkgs {\n\t\t\tpkg, err := ctx.ResolvePackage(pkg)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ctx.ResolvePackage(%v):  %v\", pkg, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpkgs = append(pkgs, pkg)\n\t\t}\n\t\ta, err := BuildPackages(pkgs...)\n\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"ctx.BuildPackages(%v): want %v, got %v\", pkgs, tt.err, err)\n\t\t}\n\t\tvar names []string\n\t\tfor _, a := range a.Deps {\n\t\t\tnames = append(names, a.Name)\n\t\t}\n\t\tsort.Strings(names)\n\t\tif !reflect.DeepEqual(tt.actions, names) {\n\t\t\tt.Errorf(\"ctx.BuildPackages(%v): want %v, got %v\", pkgs, tt.actions, names)\n\t\t}\n\t}\n}\n\nfunc TestObjfile(t *testing.T) {\n\tvar tests = []struct {\n\t\tpkg  string // package name\n\t\twant string // objfile result\n\t}{\n\t\t{pkg: \"b\", want: \"b.a\"},\n\t\t{pkg: \"nested/a\", want: \"nested/a.a\"},\n\t\t{pkg: \"nested/b\", want: \"nested/b.a\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tctx := testContext(t)\n\t\tdefer ctx.Destroy()\n\t\tpkg, err := ctx.ResolvePackage(tt.pkg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tgot := pkg.objfile()\n\t\twant := filepath.Join(ctx.Workdir(), tt.want)\n\t\tif want != got {\n\t\t\tt.Errorf(\"(%s).Objdir(): want %s, got %s\", tt.pkg, want, got)\n\t\t}\n\t}\n}\n\nfunc TestCgoobjdir(t *testing.T) {\n\tvar tests = []struct {\n\t\tpkg  string // package name\n\t\twant string // objdir result\n\t}{\n\t\t{pkg: \"b\", want: \"b/_cgo\"},\n\t\t{pkg: \"nested/a\", want: \"nested/a/_cgo\"},\n\t\t{pkg: \"nested/b\", want: \"nested/b/_cgo\"},\n\t}\n\n\tctx := testContext(t)\n\tdefer ctx.Destroy()\n\tfor _, tt := range tests {\n\t\tpkg, err := ctx.ResolvePackage(tt.pkg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tgot := cgoworkdir(pkg)\n\t\twant := filepath.Join(ctx.Workdir(), tt.want)\n\t\tif want != got {\n\t\t\tt.Errorf(\"(%s).cgoobjdir(): want %s, got %s\", tt.pkg, want, got)\n\t\t}\n\t}\n}\n\nfunc TestWorkdir(t *testing.T) {\n\tvar tests = []struct {\n\t\tpkg  string // package name\n\t\twant string // objdir result\n\t}{\n\t\t{pkg: \"b\", want: \"\"},\n\t\t{pkg: \"nested/a\", want: \"nested\"},\n\t\t{pkg: \"nested/b\", want: \"nested\"},\n\t}\n\n\tctx := testContext(t)\n\tdefer ctx.Destroy()\n\tfor _, tt := range tests {\n\t\tpkg, err := ctx.ResolvePackage(tt.pkg)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tgot := pkg.Workdir()\n\t\twant := filepath.Join(ctx.Workdir(), tt.want)\n\t\tif want != got {\n\t\t\tt.Errorf(\"Workdir(Package{Name: %v, ImportPath: %v, TestScope: %v}): want %s, got %s\", pkg.Name, pkg.ImportPath, pkg.TestScope, want, got)\n\t\t}\n\t}\n}\n\nfunc TestPkgname(t *testing.T) {\n\tvar tests = []struct {\n\t\tpkg  *Package\n\t\twant string\n\t}{{\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"main\",\n\t\t\t\tImportPath: \"main\",\n\t\t\t},\n\t\t},\n\t\twant: \"main\",\n\t}, {\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"a\",\n\t\t\t\tImportPath: \"main\",\n\t\t\t},\n\t\t},\n\t\twant: \"main\",\n\t}, {\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"main\",\n\t\t\t\tImportPath: \"a\",\n\t\t\t},\n\t\t},\n\t\twant: \"a\",\n\t}, {\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"main\",\n\t\t\t\tImportPath: \"testmain\",\n\t\t\t},\n\t\t},\n\t\twant: \"testmain\",\n\t}, {\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"main\",\n\t\t\t\tImportPath: \"main\",\n\t\t\t},\n\t\t\tTestScope: true,\n\t\t},\n\t\twant: \"main\",\n\t}, {\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"a\",\n\t\t\t\tImportPath: \"main\",\n\t\t\t},\n\t\t\tTestScope: true,\n\t\t},\n\t\twant: \"main\",\n\t}, {\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"main\",\n\t\t\t\tImportPath: \"a\",\n\t\t\t},\n\t\t\tTestScope: true,\n\t\t},\n\t\twant: \"a\",\n\t}, {\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"main\",\n\t\t\t\tImportPath: \"a/a\",\n\t\t\t},\n\t\t\tTestScope: true,\n\t\t},\n\t\twant: \"a\",\n\t}, {\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"main\",\n\t\t\t\tImportPath: \"testmain\",\n\t\t\t},\n\t\t\tTestScope: true,\n\t\t},\n\t\twant: \"testmain\",\n\t}}\n\n\tfor _, tt := range tests {\n\t\tgot := tt.pkg.pkgname()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"pkgname(Package{Name:%q, ImportPath: %q, TestScope:%v}): got %v, want %v\", tt.pkg.Name, tt.pkg.ImportPath, tt.pkg.TestScope, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc getwd(t *testing.T) string {\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn cwd\n}\n\nfunc mktemp(t *testing.T) string {\n\ts, err := mktmp()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn s\n}\n\nfunc mktmp() (string, error) {\n\treturn ioutil.TempDir(\"\", \"gb-test-\")\n}\n\nfunc nogoerr(dir string) error {\n\treturn &build.NoGoError{Dir: dir}\n}\n"
        },
        {
          "name": "cgo.go",
          "type": "blob",
          "size": 14.875,
          "content": "package gb\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/constabulary/gb/internal/version\"\n\t\"github.com/pkg/errors\"\n)\n\nfunc cgo(pkg *Package) (*Action, []string, []string, error) {\n\tswitch {\n\tcase version.Version > 1.5:\n\t\treturn cgo15(pkg)\n\tdefault:\n\t\treturn nil, nil, nil, errors.Errorf(\"unsupported Go version: %v\", runtime.Version())\n\t}\n}\n\n// cgo produces a an Action representing the cgo steps\n// an ofile representing the result of the cgo steps\n// a set of .go files for compilation, and an error.\nfunc cgo14(pkg *Package) (*Action, []string, []string, error) {\n\n\t// collect cflags and ldflags from the package\n\t// the environment, and pkg-config.\n\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoLDFLAGS := cflags(pkg, false)\n\tpcCFLAGS, pcLDFLAGS, err := pkgconfig(pkg)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\tcgoCFLAGS = append(cgoCFLAGS, pcCFLAGS...)\n\tcgoLDFLAGS = append(cgoLDFLAGS, pcLDFLAGS...)\n\n\truncgo1 := []*Action{\n\t\t&Action{\n\t\t\tName: \"runcgo1: \" + pkg.ImportPath,\n\t\t\tRun:  func() error { return runcgo1(pkg, cgoCFLAGS, cgoLDFLAGS) },\n\t\t}}\n\n\tworkdir := cgoworkdir(pkg)\n\tdefun := filepath.Join(workdir, \"_cgo_defun.o\")\n\trundefun := Action{\n\t\tName: \"cc: \" + pkg.ImportPath + \": _cgo_defun_c\",\n\t\tDeps: runcgo1,\n\t\tRun:  func() error { return pkg.tc.Cc(pkg, defun, filepath.Join(workdir, \"_cgo_defun.c\")) },\n\t}\n\n\tcgofiles := []string{filepath.Join(workdir, \"_cgo_gotypes.go\")}\n\tfor _, f := range pkg.CgoFiles {\n\t\tcgofiles = append(cgofiles, filepath.Join(workdir, stripext(f)+\".cgo1.go\"))\n\t}\n\tcfiles := []string{\n\t\tfilepath.Join(workdir, \"_cgo_main.c\"),\n\t\tfilepath.Join(workdir, \"_cgo_export.c\"),\n\t}\n\tcfiles = append(cfiles, pkg.CFiles...)\n\n\tfor _, f := range pkg.CgoFiles {\n\t\tcfiles = append(cfiles, filepath.Join(workdir, stripext(f)+\".cgo2.c\"))\n\t}\n\n\tcflags := append(cgoCPPFLAGS, cgoCFLAGS...)\n\tcxxflags := append(cgoCPPFLAGS, cgoCXXFLAGS...)\n\tgcc1, ofiles := cgocc(pkg, cflags, cxxflags, cfiles, pkg.CXXFiles, runcgo1...)\n\tofiles = append(ofiles, pkg.SysoFiles...)\n\tofile := filepath.Join(filepath.Dir(ofiles[0]), \"_cgo_.o\")\n\tgcc2 := Action{\n\t\tName: \"gccld: \" + pkg.ImportPath + \": _cgo_.o\",\n\t\tDeps: gcc1,\n\t\tRun:  func() error { return gccld(pkg, cgoCFLAGS, cgoLDFLAGS, ofile, ofiles) },\n\t}\n\n\tdynout := filepath.Join(workdir, \"_cgo_import.c\")\n\timports := stripext(dynout) + \".o\"\n\truncgo2 := Action{\n\t\tName: \"runcgo2: \" + pkg.ImportPath,\n\t\tDeps: []*Action{&gcc2},\n\t\tRun: func() error {\n\t\t\tif err := runcgo2(pkg, dynout, ofile); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn pkg.tc.Cc(pkg, imports, dynout)\n\t\t},\n\t}\n\n\tallo := filepath.Join(filepath.Dir(ofiles[0]), \"_all.o\")\n\taction := Action{\n\t\tName: \"rungcc3: \" + pkg.ImportPath,\n\t\tDeps: []*Action{&runcgo2, &rundefun},\n\t\tRun: func() error {\n\t\t\treturn rungcc3(pkg, pkg.Dir, allo, ofiles[1:]) // skip _cgo_main.o\n\t\t},\n\t}\n\treturn &action, []string{defun, imports, allo}, cgofiles, nil\n}\n\n// cgo produces a an Action representing the cgo steps\n// an ofile representing the result of the cgo steps\n// a set of .go files for compilation, and an error.\nfunc cgo15(pkg *Package) (*Action, []string, []string, error) {\n\n\t// collect cflags and ldflags from the package\n\t// the environment, and pkg-config.\n\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoLDFLAGS := cflags(pkg, false)\n\tpcCFLAGS, pcLDFLAGS, err := pkgconfig(pkg)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\tcgoCFLAGS = append(cgoCFLAGS, pcCFLAGS...)\n\tcgoLDFLAGS = append(cgoLDFLAGS, pcLDFLAGS...)\n\n\truncgo1 := []*Action{\n\t\t&Action{\n\t\t\tName: \"runcgo1: \" + pkg.ImportPath,\n\t\t\tRun:  func() error { return runcgo1(pkg, cgoCFLAGS, cgoLDFLAGS) },\n\t\t},\n\t}\n\n\tworkdir := cgoworkdir(pkg)\n\tcgofiles := []string{filepath.Join(workdir, \"_cgo_gotypes.go\")}\n\tfor _, f := range pkg.CgoFiles {\n\t\tcgofiles = append(cgofiles, filepath.Join(workdir, stripext(f)+\".cgo1.go\"))\n\t}\n\tcfiles := []string{\n\t\tfilepath.Join(workdir, \"_cgo_main.c\"),\n\t\tfilepath.Join(workdir, \"_cgo_export.c\"),\n\t}\n\tcfiles = append(cfiles, pkg.CFiles...)\n\n\tfor _, f := range pkg.CgoFiles {\n\t\tcfiles = append(cfiles, filepath.Join(workdir, stripext(f)+\".cgo2.c\"))\n\t}\n\n\tcflags := append(cgoCPPFLAGS, cgoCFLAGS...)\n\tcxxflags := append(cgoCPPFLAGS, cgoCXXFLAGS...)\n\tgcc1, ofiles := cgocc(pkg, cflags, cxxflags, cfiles, pkg.CXXFiles, runcgo1...)\n\tofiles = append(ofiles, pkg.SysoFiles...)\n\tofile := filepath.Join(filepath.Dir(ofiles[0]), \"_cgo_.o\")\n\tgcc2 := Action{\n\t\tName: \"gccld: \" + pkg.ImportPath + \": _cgo_.o\",\n\t\tDeps: gcc1,\n\t\tRun:  func() error { return gccld(pkg, cgoCFLAGS, cgoLDFLAGS, ofile, ofiles) },\n\t}\n\n\tdynout := filepath.Join(workdir, \"_cgo_import.go\")\n\truncgo2 := Action{\n\t\tName: \"runcgo2: \" + pkg.ImportPath,\n\t\tDeps: []*Action{&gcc2},\n\t\tRun:  func() error { return runcgo2(pkg, dynout, ofile) },\n\t}\n\tcgofiles = append(cgofiles, dynout)\n\n\tallo := filepath.Join(filepath.Dir(ofiles[0]), \"_all.o\")\n\taction := Action{\n\t\tName: \"rungcc3: \" + pkg.ImportPath,\n\t\tDeps: []*Action{&runcgo2},\n\t\tRun: func() error {\n\t\t\treturn rungcc3(pkg, pkg.Dir, allo, ofiles[1:]) // skip _cgo_main.o\n\t\t},\n\t}\n\n\treturn &action, []string{allo}, cgofiles, nil\n}\n\n// cgocc compiles all .c files.\n// TODO(dfc) cxx not done\nfunc cgocc(pkg *Package, cflags, cxxflags, cfiles, cxxfiles []string, deps ...*Action) ([]*Action, []string) {\n\tworkdir := cgoworkdir(pkg)\n\tvar cc []*Action\n\tvar ofiles []string\n\tfor _, cfile := range cfiles {\n\t\tcfile := cfile\n\t\tofile := filepath.Join(workdir, stripext(filepath.Base(cfile))+\".o\")\n\t\tofiles = append(ofiles, ofile)\n\t\tcc = append(cc, &Action{\n\t\t\tName: \"rungcc1: \" + pkg.ImportPath + \": \" + cfile,\n\t\t\tDeps: deps,\n\t\t\tRun:  func() error { return rungcc1(pkg, cflags, ofile, cfile) },\n\t\t})\n\t}\n\n\tfor _, cxxfile := range cxxfiles {\n\t\tcxxfile := cxxfile\n\t\tofile := filepath.Join(workdir, stripext(filepath.Base(cxxfile))+\".o\")\n\t\tofiles = append(ofiles, ofile)\n\t\tcc = append(cc, &Action{\n\t\t\tName: \"rung++1: \" + pkg.ImportPath + \": \" + cxxfile,\n\t\t\tDeps: deps,\n\t\t\tRun:  func() error { return rungpp1(pkg, cxxflags, ofile, cxxfile) },\n\t\t})\n\t}\n\n\treturn cc, ofiles\n}\n\n// rungcc1 invokes gcc to compile cfile into ofile\nfunc rungcc1(pkg *Package, cgoCFLAGS []string, ofile, cfile string) error {\n\targs := []string{\"-g\", \"-O2\",\n\t\t\"-I\", pkg.Dir,\n\t\t\"-I\", filepath.Dir(ofile),\n\t}\n\targs = append(args, cgoCFLAGS...)\n\targs = append(args,\n\t\t\"-o\", ofile,\n\t\t\"-c\", cfile,\n\t)\n\tt0 := time.Now()\n\tgcc := gccCmd(pkg, pkg.Dir)\n\tvar buf bytes.Buffer\n\terr := runOut(&buf, pkg.Dir, nil, gcc[0], append(gcc[1:], args...)...)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t}\n\tpkg.Record(gcc[0], time.Since(t0))\n\treturn err\n}\n\n// rungpp1 invokes g++ to compile cfile into ofile\nfunc rungpp1(pkg *Package, cgoCFLAGS []string, ofile, cfile string) error {\n\targs := []string{\"-g\", \"-O2\",\n\t\t\"-I\", pkg.Dir,\n\t\t\"-I\", filepath.Dir(ofile),\n\t}\n\targs = append(args, cgoCFLAGS...)\n\targs = append(args,\n\t\t\"-o\", ofile,\n\t\t\"-c\", cfile,\n\t)\n\tt0 := time.Now()\n\tgxx := gxxCmd(pkg, pkg.Dir)\n\tvar buf bytes.Buffer\n\terr := runOut(&buf, pkg.Dir, nil, gxx[0], append(gxx[1:], args...)...)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t}\n\tpkg.Record(gxx[0], time.Since(t0))\n\treturn err\n}\n\n// gccld links the o files from rungcc1 into a single _cgo_.o.\nfunc gccld(pkg *Package, cgoCFLAGS, cgoLDFLAGS []string, ofile string, ofiles []string) error {\n\targs := []string{}\n\targs = append(args, \"-o\", ofile)\n\targs = append(args, ofiles...)\n\targs = append(args, cgoLDFLAGS...) // this has to go at the end, because reasons!\n\tt0 := time.Now()\n\n\tvar cmd []string\n\tif len(pkg.CXXFiles) > 0 || len(pkg.SwigCXXFiles) > 0 {\n\t\tcmd = gxxCmd(pkg, pkg.Dir)\n\t} else {\n\t\tcmd = gccCmd(pkg, pkg.Dir)\n\t}\n\tvar buf bytes.Buffer\n\terr := runOut(&buf, pkg.Dir, nil, cmd[0], append(cmd[1:], args...)...)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t}\n\tpkg.Record(\"gccld\", time.Since(t0))\n\treturn err\n}\n\n// rungcc3 links all previous ofiles together with libgcc into a single _all.o.\nfunc rungcc3(pkg *Package, dir string, ofile string, ofiles []string) error {\n\targs := []string{}\n\targs = append(args, \"-o\", ofile)\n\targs = append(args, ofiles...)\n\targs = append(args, \"-Wl,-r\", \"-nostdlib\")\n\tif gccSupportsNoPie(pkg) {\n\t\targs = append(args, \"-no-pie\")\n\t}\n\tvar cmd []string\n\tif len(pkg.CXXFiles) > 0 || len(pkg.SwigCXXFiles) > 0 {\n\t\tcmd = gxxCmd(pkg, dir)\n\t} else {\n\t\tcmd = gccCmd(pkg, dir)\n\t}\n\tif !strings.HasPrefix(cmd[0], \"clang\") {\n\t\tlibgcc, err := libgcc(pkg.Context)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\targs = append(args, libgcc)\n\t}\n\tt0 := time.Now()\n\tvar buf bytes.Buffer\n\terr := runOut(&buf, dir, nil, cmd[0], append(cmd[1:], args...)...)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t}\n\tpkg.Record(\"gcc3\", time.Since(t0))\n\treturn err\n}\n\n// libgcc returns the value of gcc -print-libgcc-file-name.\nfunc libgcc(ctx *Context) (string, error) {\n\targs := []string{\n\t\t\"-print-libgcc-file-name\",\n\t}\n\tvar buf bytes.Buffer\n\tcmd := gccCmd(&Package{Context: ctx}, \"\") // TODO(dfc) hack\n\terr := runOut(&buf, \".\", nil, cmd[0], args...)\n\treturn strings.TrimSpace(buf.String()), err\n}\n\n// gccSupportsNoPie check if the -no-pie option is supported. On systems with\n// PIE (position independent executables) enabled by default, -no-pie must be\n// passed when doing a partial link with -Wl,-r.\nfunc gccSupportsNoPie(pkg *Package) bool {\n\tcmd := gccCmd(pkg, \"\")\n\targs := []string{\n\t\t\"-no-pie\",\n\t\t\"-fsyntax-only\",\n\t\t\"-xc\",\n\t\t\"-\",\n\t}\n\treturn exec.Command(cmd[0], append(cmd[1:], args...)...).Run() == nil\n}\n\nfunc cgotool(ctx *Context) string {\n\treturn filepath.Join(runtime.GOROOT(), \"pkg\", \"tool\", ctx.gohostos+\"_\"+ctx.gohostarch, \"cgo\")\n}\n\n// envList returns the value of the given environment variable broken\n// into fields, using the default value when the variable is empty.\nfunc envList(key, def string) []string {\n\tv := os.Getenv(key)\n\tif v == \"\" {\n\t\tv = def\n\t}\n\treturn strings.Fields(v)\n}\n\n// Return the flags to use when invoking the C or C++ compilers, or cgo.\nfunc cflags(p *Package, def bool) (cppflags, cflags, cxxflags, ldflags []string) {\n\tvar defaults string\n\tif def {\n\t\tdefaults = \"-g -O2\"\n\t}\n\n\tcppflags = stringList(envList(\"CGO_CPPFLAGS\", \"\"), p.CgoCPPFLAGS)\n\tcflags = stringList(envList(\"CGO_CFLAGS\", defaults), p.CgoCFLAGS)\n\tcxxflags = stringList(envList(\"CGO_CXXFLAGS\", defaults), p.CgoCXXFLAGS)\n\tldflags = stringList(envList(\"CGO_LDFLAGS\", defaults), p.CgoLDFLAGS)\n\treturn\n}\n\n// call pkg-config and return the cflags and ldflags.\nfunc pkgconfig(p *Package) ([]string, []string, error) {\n\tif len(p.CgoPkgConfig) == 0 {\n\t\treturn nil, nil, nil // nothing to do\n\t}\n\targs := []string{\n\t\t\"--cflags\",\n\t}\n\targs = append(args, p.CgoPkgConfig...)\n\tvar out bytes.Buffer\n\terr := runOut(&out, p.Dir, nil, \"pkg-config\", args...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tcflags := strings.Fields(out.String())\n\n\targs = []string{\n\t\t\"--libs\",\n\t}\n\targs = append(args, p.CgoPkgConfig...)\n\tout.Reset()\n\terr = runOut(&out, p.Dir, nil, \"pkg-config\", args...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tldflags := strings.Fields(out.String())\n\treturn cflags, ldflags, nil\n}\n\nfunc quoteFlags(flags []string) []string {\n\tquoted := make([]string, len(flags))\n\tfor i, f := range flags {\n\t\tquoted[i] = strconv.Quote(f)\n\t}\n\treturn quoted\n}\n\n// runcgo1 invokes the cgo tool to process pkg.CgoFiles.\nfunc runcgo1(pkg *Package, cflags, ldflags []string) error {\n\tcgo := cgotool(pkg.Context)\n\tworkdir := cgoworkdir(pkg)\n\tif err := mkdir(workdir); err != nil {\n\t\treturn err\n\t}\n\n\targs := []string{\"-objdir\", workdir}\n\tswitch {\n\tcase version.Version > 1.5:\n\t\targs = append(args,\n\t\t\t\"-importpath\", pkg.ImportPath,\n\t\t\t\"--\",\n\t\t\t\"-I\", workdir,\n\t\t\t\"-I\", pkg.Dir,\n\t\t)\n\tdefault:\n\t\treturn errors.Errorf(\"unsupported Go version: %v\", runtime.Version())\n\t}\n\targs = append(args, cflags...)\n\targs = append(args, pkg.CgoFiles...)\n\n\tcgoenv := []string{\n\t\t\"CGO_CFLAGS=\" + strings.Join(quoteFlags(cflags), \" \"),\n\t\t\"CGO_LDFLAGS=\" + strings.Join(quoteFlags(ldflags), \" \"),\n\t}\n\tvar buf bytes.Buffer\n\terr := runOut(&buf, pkg.Dir, cgoenv, cgo, args...)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t}\n\treturn err\n}\n\n// runcgo2 invokes the cgo tool to create _cgo_import.go\nfunc runcgo2(pkg *Package, dynout, ofile string) error {\n\tcgo := cgotool(pkg.Context)\n\tworkdir := cgoworkdir(pkg)\n\n\targs := []string{\n\t\t\"-objdir\", workdir,\n\t}\n\tswitch {\n\tcase version.Version > 1.5:\n\t\targs = append(args,\n\t\t\t\"-dynpackage\", pkg.Name,\n\t\t\t\"-dynimport\", ofile,\n\t\t\t\"-dynout\", dynout,\n\t\t)\n\tdefault:\n\t\treturn errors.Errorf(\"unsuppored Go version: %v\", runtime.Version())\n\t}\n\tvar buf bytes.Buffer\n\terr := runOut(&buf, pkg.Dir, nil, cgo, args...)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t}\n\treturn err\n}\n\n// cgoworkdir returns the cgo working directory for this package.\nfunc cgoworkdir(pkg *Package) string {\n\treturn filepath.Join(pkg.Workdir(), pkg.pkgname(), \"_cgo\")\n}\n\n// gccCmd returns a gcc command line prefix.\nfunc gccCmd(pkg *Package, objdir string) []string {\n\treturn ccompilerCmd(pkg, \"CC\", defaultCC, objdir)\n}\n\n// gxxCmd returns a g++ command line prefix.\nfunc gxxCmd(pkg *Package, objdir string) []string {\n\treturn ccompilerCmd(pkg, \"CXX\", defaultCXX, objdir)\n}\n\n// ccompilerCmd returns a command line prefix for the given environment\n// variable and using the default command when the variable is empty.\nfunc ccompilerCmd(pkg *Package, envvar, defcmd, objdir string) []string {\n\tcompiler := envList(envvar, defcmd)\n\ta := []string{compiler[0]}\n\tif objdir != \"\" {\n\t\ta = append(a, \"-I\", objdir)\n\t}\n\ta = append(a, compiler[1:]...)\n\n\t// Definitely want -fPIC but on Windows gcc complains\n\t// \"-fPIC ignored for target (all code is position independent)\"\n\tif pkg.gotargetos != \"windows\" {\n\t\ta = append(a, \"-fPIC\")\n\t}\n\ta = append(a, gccArchArgs(pkg.gotargetarch)...)\n\t// gcc-4.5 and beyond require explicit \"-pthread\" flag\n\t// for multithreading with pthread library.\n\tswitch pkg.gotargetos {\n\tcase \"windows\":\n\t\ta = append(a, \"-mthreads\")\n\tdefault:\n\t\ta = append(a, \"-pthread\")\n\t}\n\n\tif strings.Contains(a[0], \"clang\") {\n\t\t// disable ASCII art in clang errors, if possible\n\t\ta = append(a, \"-fno-caret-diagnostics\")\n\t\t// clang is too smart about command-line arguments\n\t\ta = append(a, \"-Qunused-arguments\")\n\t}\n\n\t// disable word wrapping in error messages\n\ta = append(a, \"-fmessage-length=0\")\n\n\t// On OS X, some of the compilers behave as if -fno-common\n\t// is always set, and the Mach-O linker in 6l/8l assumes this.\n\t// See https://golang.org/issue/3253.\n\tif pkg.gotargetos == \"darwin\" {\n\t\ta = append(a, \"-fno-common\")\n\t}\n\n\treturn a\n}\n\n// linkCmd returns the name of the binary to use for linking for the given\n// environment variable and using the default command when the variable is\n// empty.\nfunc linkCmd(pkg *Package, envvar, defcmd string) string {\n\tcompiler := envList(envvar, defcmd)\n\treturn compiler[0]\n}\n\n// gccArchArgs returns arguments to pass to gcc based on the architecture.\nfunc gccArchArgs(goarch string) []string {\n\tswitch goarch {\n\tcase \"386\":\n\t\treturn []string{\"-m32\"}\n\tcase \"amd64\", \"amd64p32\":\n\t\treturn []string{\"-m64\"}\n\tcase \"arm\":\n\t\treturn []string{\"-marm\"} // not thumb\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 11.0546875,
          "content": "package gb\n\nimport (\n\t\"fmt\"\n\t\"go/build\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// enables sh style -e output\nconst eMode = false\n\n// Importer resolves package import paths to *importer.Packages.\ntype Importer interface {\n\n\t// Import attempts to resolve the package import path, path,\n\t// to an *importer.Package.\n\tImport(path string) (*build.Package, error)\n}\n\n// Context represents an execution of one or more Targets inside a Project.\ntype Context struct {\n\tProject\n\n\timporter Importer\n\n\tpkgs map[string]*Package // map of package paths to resolved packages\n\n\tworkdir string\n\n\ttc Toolchain\n\n\tgohostos, gohostarch     string // GOOS and GOARCH for this host\n\tgotargetos, gotargetarch string // GOOS and GOARCH for the target\n\n\tStatistics\n\n\tForce   bool // force rebuild of packages\n\tInstall bool // copy packages into $PROJECT/pkg\n\tVerbose bool // verbose output\n\tNope    bool // command specific flag, under test it skips the execute action.\n\trace    bool // race detector requested\n\n\tgcflags []string // flags passed to the compiler\n\tldflags []string // flags passed to the linker\n\n\tlinkmode, buildmode string // link and build modes\n\n\tbuildtags []string // build tags\n\n\tdebug func(string, ...interface{})\n}\n\n// GOOS configures the Context to use goos as the target os.\nfunc GOOS(goos string) func(*Context) error {\n\treturn func(c *Context) error {\n\t\tif goos == \"\" {\n\t\t\treturn fmt.Errorf(\"GOOS cannot be blank\")\n\t\t}\n\t\tc.gotargetos = goos\n\t\treturn nil\n\t}\n}\n\n// GOARCH configures the Context to use goarch as the target arch.\nfunc GOARCH(goarch string) func(*Context) error {\n\treturn func(c *Context) error {\n\t\tif goarch == \"\" {\n\t\t\treturn fmt.Errorf(\"GOARCH cannot be blank\")\n\t\t}\n\t\tc.gotargetarch = goarch\n\t\treturn nil\n\t}\n}\n\n// Tags configured the context to use these additional build tags\nfunc Tags(tags ...string) func(*Context) error {\n\treturn func(c *Context) error {\n\t\tc.buildtags = append(c.buildtags, tags...)\n\t\treturn nil\n\t}\n}\n\n// Gcflags appends flags to the list passed to the compiler.\nfunc Gcflags(flags ...string) func(*Context) error {\n\treturn func(c *Context) error {\n\t\tc.gcflags = append(c.gcflags, flags...)\n\t\treturn nil\n\t}\n}\n\n// Ldflags appends flags to the list passed to the linker.\nfunc Ldflags(flags ...string) func(*Context) error {\n\treturn func(c *Context) error {\n\t\tc.ldflags = append(c.ldflags, flags...)\n\t\treturn nil\n\t}\n}\n\nfunc WithDebug(w io.Writer) func(*Context) error {\n\treturn func(c *Context) error {\n\t\tl := log.New(w, \"\", log.Ldate|log.Ltime|log.Lshortfile)\n\t\tc.debug = func(format string, args ...interface{}) {\n\t\t\tl.Output(2, fmt.Sprintf(format, args...))\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithRace enables the race detector and adds the tag \"race\" to\n// the Context build tags.\nfunc WithRace(c *Context) error {\n\tc.race = true\n\tTags(\"race\")(c)\n\tGcflags(\"-race\")(c)\n\tLdflags(\"-race\")(c)\n\treturn nil\n}\n\n// NewContext returns a new build context from this project.\n// By default this context will use the gc toolchain with the\n// host's GOOS and GOARCH values.\nfunc NewContext(p Project, opts ...func(*Context) error) (*Context, error) {\n\tenvOr := func(key, def string) string {\n\t\tif v := os.Getenv(key); v != \"\" {\n\t\t\treturn v\n\t\t}\n\t\treturn def\n\t}\n\n\tdefaults := []func(*Context) error{\n\t\t// must come before GcToolchain()\n\t\tfunc(c *Context) error {\n\t\t\tc.gohostos = runtime.GOOS\n\t\t\tc.gohostarch = runtime.GOARCH\n\t\t\tc.gotargetos = envOr(\"GOOS\", runtime.GOOS)\n\t\t\tc.gotargetarch = envOr(\"GOARCH\", runtime.GOARCH)\n\t\t\tc.debug = func(string, ...interface{}) {} // null logger\n\t\t\treturn nil\n\t\t},\n\t\tGcToolchain(),\n\t}\n\tworkdir, err := ioutil.TempDir(\"\", \"gb\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx := Context{\n\t\tProject:   p,\n\t\tworkdir:   workdir,\n\t\tbuildmode: \"exe\",\n\t\tpkgs:      make(map[string]*Package),\n\t}\n\n\tfor _, opt := range append(defaults, opts...) {\n\t\terr := opt(&ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// sort build tags to ensure the ctxSring and Suffix is stable\n\tsort.Strings(ctx.buildtags)\n\n\tbc := build.Default\n\tbc.GOOS = ctx.gotargetos\n\tbc.GOARCH = ctx.gotargetarch\n\tbc.CgoEnabled = cgoEnabled(ctx.gohostos, ctx.gohostarch, ctx.gotargetos, ctx.gotargetarch)\n\tbc.ReleaseTags = releaseTags\n\tbc.BuildTags = ctx.buildtags\n\n\ti, err := buildImporter(&bc, &ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx.importer = i\n\n\t// C and unsafe are fake packages synthesised by the compiler.\n\t// Insert fake packages into the package cache.\n\tfor _, name := range []string{\"C\", \"unsafe\"} {\n\t\tpkg, err := ctx.newPackage(&build.Package{\n\t\t\tName:       name,\n\t\t\tImportPath: name,\n\t\t\tDir:        name, // fake, but helps diagnostics\n\t\t\tGoroot:     true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpkg.NotStale = true\n\t\tctx.pkgs[pkg.ImportPath] = pkg\n\t}\n\n\treturn &ctx, err\n}\n\n// IncludePaths returns the include paths visible in this context.\nfunc (c *Context) includePaths() []string {\n\treturn []string{\n\t\tc.workdir,\n\t\tc.Pkgdir(),\n\t}\n}\n\n// NewPackage creates a resolved Package for p.\nfunc (c *Context) NewPackage(p *build.Package) (*Package, error) {\n\tpkg, err := c.newPackage(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpkg.NotStale = !pkg.isStale()\n\treturn pkg, nil\n}\n\n// Pkgdir returns the path to precompiled packages.\nfunc (c *Context) Pkgdir() string {\n\treturn filepath.Join(c.Project.Pkgdir(), c.ctxString())\n}\n\n// Suffix returns the suffix (if any) for binaries produced\n// by this context.\nfunc (c *Context) Suffix() string {\n\tsuffix := c.ctxString()\n\tif suffix != \"\" {\n\t\tsuffix = \"-\" + suffix\n\t}\n\treturn suffix\n}\n\n// Workdir returns the path to this Context's working directory.\nfunc (c *Context) Workdir() string { return c.workdir }\n\n// ResolvePackage resolves the package at path using the current context.\nfunc (c *Context) ResolvePackage(path string) (*Package, error) {\n\tif path == \".\" {\n\t\treturn nil, errors.Errorf(\"%q is not a package\", filepath.Join(c.Projectdir(), \"src\"))\n\t}\n\tpath, err := relImportPath(filepath.Join(c.Projectdir(), \"src\"), path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif path == \".\" || path == \"..\" || strings.HasPrefix(path, \"./\") || strings.HasPrefix(path, \"../\") {\n\t\treturn nil, errors.Errorf(\"import %q: relative import not supported\", path)\n\t}\n\treturn c.loadPackage(nil, path)\n}\n\n// loadPackage recursively resolves path as a package. If successful loadPackage\n// records the package in the Context's internal package cache.\nfunc (c *Context) loadPackage(stack []string, path string) (*Package, error) {\n\tif pkg, ok := c.pkgs[path]; ok {\n\t\t// already loaded, just return\n\t\treturn pkg, nil\n\t}\n\n\tp, err := c.importer.Import(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstack = append(stack, p.ImportPath)\n\tvar stale bool\n\tfor i, im := range p.Imports {\n\t\tfor _, p := range stack {\n\t\t\tif p == im {\n\t\t\t\treturn nil, fmt.Errorf(\"import cycle detected: %s\", strings.Join(append(stack, im), \" -> \"))\n\t\t\t}\n\t\t}\n\t\tpkg, err := c.loadPackage(stack, im)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// update the import path as the import may have been discovered via vendoring.\n\t\tp.Imports[i] = pkg.ImportPath\n\t\tstale = stale || !pkg.NotStale\n\t}\n\n\tpkg, err := c.newPackage(p)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"loadPackage(%q)\", path)\n\t}\n\tpkg.Main = pkg.Name == \"main\"\n\tpkg.NotStale = !(stale || pkg.isStale())\n\tc.pkgs[p.ImportPath] = pkg\n\treturn pkg, nil\n}\n\n// Destroy removes the temporary working files of this context.\nfunc (c *Context) Destroy() error {\n\tc.debug(\"removing work directory: %v\", c.workdir)\n\treturn os.RemoveAll(c.workdir)\n}\n\n// ctxString returns a string representation of the unique properties\n// of the context.\nfunc (c *Context) ctxString() string {\n\tv := []string{\n\t\tc.gotargetos,\n\t\tc.gotargetarch,\n\t}\n\tv = append(v, c.buildtags...)\n\treturn strings.Join(v, \"-\")\n}\n\nfunc (c *Context) Debug(format string, args ...interface{}) {\n\tc.debug(format, args...)\n}\n\nfunc runOut(output io.Writer, dir string, env []string, command string, args ...string) error {\n\tcmd := exec.Command(command, args...)\n\tcmd.Dir = dir\n\tcmd.Stdout = output\n\tcmd.Stderr = os.Stderr\n\tcmd.Env = mergeEnvLists(env, envForDir(cmd.Dir))\n\tif eMode {\n\t\tfmt.Fprintln(os.Stderr, \"+\", strings.Join(cmd.Args, \" \"))\n\t}\n\terr := cmd.Run()\n\treturn err\n}\n\n// Statistics records the various Durations\ntype Statistics struct {\n\tsync.Mutex\n\tstats map[string]time.Duration\n}\n\nfunc (s *Statistics) Record(name string, d time.Duration) {\n\ts.Lock()\n\tdefer s.Unlock()\n\tif s.stats == nil {\n\t\ts.stats = make(map[string]time.Duration)\n\t}\n\ts.stats[name] += d\n}\n\nfunc (s *Statistics) Total() time.Duration {\n\ts.Lock()\n\tdefer s.Unlock()\n\tvar d time.Duration\n\tfor _, v := range s.stats {\n\t\td += v\n\t}\n\treturn d\n}\n\nfunc (s *Statistics) String() string {\n\ts.Lock()\n\tdefer s.Unlock()\n\treturn fmt.Sprintf(\"%v\", s.stats)\n}\n\nfunc (c *Context) isCrossCompile() bool {\n\treturn c.gohostos != c.gotargetos || c.gohostarch != c.gotargetarch\n}\n\n// envForDir returns a copy of the environment\n// suitable for running in the given directory.\n// The environment is the current process's environment\n// but with an updated $PWD, so that an os.Getwd in the\n// child will be faster.\nfunc envForDir(dir string) []string {\n\tenv := os.Environ()\n\t// Internally we only use rooted paths, so dir is rooted.\n\t// Even if dir is not rooted, no harm done.\n\treturn mergeEnvLists([]string{\"PWD=\" + dir}, env)\n}\n\n// mergeEnvLists merges the two environment lists such that\n// variables with the same name in \"in\" replace those in \"out\".\nfunc mergeEnvLists(in, out []string) []string {\nNextVar:\n\tfor _, inkv := range in {\n\t\tk := strings.SplitAfterN(inkv, \"=\", 2)[0]\n\t\tfor i, outkv := range out {\n\t\t\tif strings.HasPrefix(outkv, k) {\n\t\t\t\tout[i] = inkv\n\t\t\t\tcontinue NextVar\n\t\t\t}\n\t\t}\n\t\tout = append(out, inkv)\n\t}\n\treturn out\n}\n\nfunc cgoEnabled(gohostos, gohostarch, gotargetos, gotargetarch string) bool {\n\tswitch os.Getenv(\"CGO_ENABLED\") {\n\tcase \"1\":\n\t\treturn true\n\tcase \"0\":\n\t\treturn false\n\tdefault:\n\t\t// cgo must be explicitly enabled for cross compilation builds\n\t\tif gohostos == gotargetos && gohostarch == gotargetarch {\n\t\t\tswitch gotargetos + \"/\" + gotargetarch {\n\t\t\tcase \"darwin/386\", \"darwin/amd64\", \"darwin/arm\", \"darwin/arm64\":\n\t\t\t\treturn true\n\t\t\tcase \"dragonfly/amd64\":\n\t\t\t\treturn true\n\t\t\tcase \"freebsd/386\", \"freebsd/amd64\", \"freebsd/arm\":\n\t\t\t\treturn true\n\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\":\n\t\t\t\treturn true\n\t\t\tcase \"android/386\", \"android/amd64\", \"android/arm\":\n\t\t\t\treturn true\n\t\t\tcase \"netbsd/386\", \"netbsd/amd64\", \"netbsd/arm\":\n\t\t\t\treturn true\n\t\t\tcase \"openbsd/386\", \"openbsd/amd64\":\n\t\t\t\treturn true\n\t\t\tcase \"solaris/amd64\":\n\t\t\t\treturn true\n\t\t\tcase \"windows/386\", \"windows/amd64\":\n\t\t\t\treturn true\n\t\t\tdefault:\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\nfunc buildImporter(bc *build.Context, ctx *Context) (Importer, error) {\n\ti, err := addDepfileDeps(bc, ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// construct importer stack in reverse order, vendor at the bottom, GOROOT on the top.\n\ti = &_importer{\n\t\tImporter: i,\n\t\tim: importer{\n\t\t\tContext: bc,\n\t\t\tRoot:    filepath.Join(ctx.Projectdir(), \"vendor\"),\n\t\t},\n\t}\n\n\ti = &srcImporter{\n\t\ti,\n\t\timporter{\n\t\t\tContext: bc,\n\t\t\tRoot:    ctx.Projectdir(),\n\t\t},\n\t}\n\n\ti = &_importer{\n\t\ti,\n\t\timporter{\n\t\t\tContext: bc,\n\t\t\tRoot:    runtime.GOROOT(),\n\t\t},\n\t}\n\n\ti = &fixupImporter{\n\t\tImporter: i,\n\t}\n\n\treturn i, nil\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 5.658203125,
          "content": "package gb\n\nimport (\n\t\"fmt\"\n\t\"go/build\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc testImportCycle(pkg string, t *testing.T) {\n\tctx := testContext(t)\n\n\tdebug.SetMaxStack(1 << 18)\n\n\t_, err := ctx.ResolvePackage(pkg)\n\tif strings.Index(err.Error(), \"cycle detected\") == -1 {\n\t\tt.Errorf(\"ctx.ResolvePackage returned wrong error. Expected cycle detection, got: %v\", err)\n\t}\n\n\tif err == nil {\n\t\tt.Errorf(\"ctx.ResolvePackage should have returned an error for cycle, returned nil\")\n\t}\n}\n\nfunc TestOneElementCycleDetection(t *testing.T) {\n\ttestImportCycle(\"cycle0\", t)\n}\n\nfunc TestSimpleCycleDetection(t *testing.T) {\n\ttestImportCycle(\"cycle1/a\", t)\n}\n\nfunc TestLongCycleDetection(t *testing.T) {\n\ttestImportCycle(\"cycle2/a\", t)\n}\n\nfunc TestContextCtxString(t *testing.T) {\n\topts := func(o ...func(*Context) error) []func(*Context) error { return o }\n\tjoin := func(s ...string) string { return strings.Join(s, \"-\") }\n\ttests := []struct {\n\t\topts []func(*Context) error\n\t\twant string\n\t}{\n\t\t{nil, join(runtime.GOOS, runtime.GOARCH)},\n\t\t{opts(GOOS(\"windows\")), join(\"windows\", runtime.GOARCH)},\n\t\t{opts(GOARCH(\"arm64\")), join(runtime.GOOS, \"arm64\")},\n\t\t{opts(GOARCH(\"arm64\"), GOOS(\"plan9\")), join(\"plan9\", \"arm64\")},\n\t\t{opts(Tags()), join(runtime.GOOS, runtime.GOARCH)},\n\t\t{opts(Tags(\"sphinx\", \"leon\")), join(runtime.GOOS, runtime.GOARCH, \"leon\", \"sphinx\")},\n\t\t{opts(Tags(\"sphinx\", \"leon\"), GOARCH(\"ppc64le\")), join(runtime.GOOS, \"ppc64le\", \"leon\", \"sphinx\")},\n\t}\n\n\tproj := testProject(t)\n\tfor _, tt := range tests {\n\t\tctx, err := NewContext(proj, tt.opts...)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer ctx.Destroy()\n\t\tgot := ctx.ctxString()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NewContext(%q).ctxString(): got %v, want %v\", tt.opts, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestContextOptions(t *testing.T) {\n\tmatches := func(want Context) func(t *testing.T, got *Context) {\n\t\treturn func(t *testing.T, got *Context) {\n\t\t\tif !reflect.DeepEqual(got, &want) {\n\t\t\t\tt.Errorf(\"got %#v, want %#v\", got, &want)\n\t\t\t}\n\t\t}\n\t}\n\n\ttests := []struct {\n\t\tctx    Context\n\t\tfn     func(*Context) error\n\t\terr    error\n\t\texpect func(*testing.T, *Context)\n\t}{{\n\t\t// assert that an zero context is not altered by the test rig.\n\t\tfn:     func(*Context) error { return nil },\n\t\texpect: matches(Context{}),\n\t}, {\n\t\t// test blank GOOS is an error\n\t\tfn:  GOOS(\"\"),\n\t\terr: fmt.Errorf(\"GOOS cannot be blank\"),\n\t}, {\n\t\t// test blank GOARCH is an error\n\t\tfn:  GOARCH(\"\"),\n\t\terr: fmt.Errorf(\"GOARCH cannot be blank\"),\n\t}, {\n\t\tctx: Context{\n\t\t\tgotargetos:   \"bar\",\n\t\t\tgotargetarch: \"baz\",\n\t\t},\n\t\tfn: GOOS(\"foo\"),\n\t\texpect: matches(Context{\n\t\t\tgotargetos:   \"foo\",\n\t\t\tgotargetarch: \"baz\",\n\t\t}),\n\t}, {\n\t\tctx: Context{\n\t\t\tgotargetos:   \"bar\",\n\t\t\tgotargetarch: \"baz\",\n\t\t},\n\t\tfn: GOARCH(\"foo\"),\n\t\texpect: matches(Context{\n\t\t\tgotargetos:   \"bar\",\n\t\t\tgotargetarch: \"foo\",\n\t\t}),\n\t}, {\n\t\tfn:     Tags(),\n\t\texpect: matches(Context{}),\n\t}, {\n\t\tfn:     Tags(\"foo\"),\n\t\texpect: matches(Context{buildtags: []string{\"foo\"}}),\n\t}, {\n\t\tctx:    Context{buildtags: []string{\"foo\"}},\n\t\tfn:     Tags(\"bar\"),\n\t\texpect: matches(Context{buildtags: []string{\"foo\", \"bar\"}}),\n\t}, {\n\t\tfn:     Gcflags(\"foo\"),\n\t\texpect: matches(Context{gcflags: []string{\"foo\"}}),\n\t}, {\n\t\tctx:    Context{gcflags: []string{\"foo\"}},\n\t\tfn:     Gcflags(\"bar\"),\n\t\texpect: matches(Context{gcflags: []string{\"foo\", \"bar\"}}),\n\t}, {\n\t\tfn:     Ldflags(\"foo\"),\n\t\texpect: matches(Context{ldflags: []string{\"foo\"}}),\n\t}, {\n\t\tctx:    Context{ldflags: []string{\"foo\"}},\n\t\tfn:     Ldflags(\"bar\"),\n\t\texpect: matches(Context{ldflags: []string{\"foo\", \"bar\"}}),\n\t}, {\n\t\tfn: WithRace,\n\t\texpect: matches(Context{\n\t\t\tbuildtags: []string{\"race\"},\n\t\t\trace:      true,\n\t\t\tgcflags:   []string{\"-race\"},\n\t\t\tldflags:   []string{\"-race\"},\n\t\t}),\n\t}, {\n\t\tctx: Context{buildtags: []string{\"zzz\"}},\n\t\tfn:  WithRace,\n\t\texpect: matches(Context{\n\t\t\tbuildtags: []string{\"zzz\", \"race\"},\n\t\t\trace:      true,\n\t\t\tgcflags:   []string{\"-race\"},\n\t\t\tldflags:   []string{\"-race\"},\n\t\t}),\n\t}}\n\n\tfor i, tt := range tests {\n\t\tctx := tt.ctx\n\t\terr := tt.fn(&ctx)\n\t\tswitch {\n\t\tcase !reflect.DeepEqual(err, tt.err):\n\t\t\tt.Errorf(\"test %d: expected err: %v, got %v\", i+1, tt.err, err)\n\t\tcase err == nil:\n\t\t\ttt.expect(t, &ctx)\n\t\t}\n\t}\n}\n\nfunc TestContextLoadPackage(t *testing.T) {\n\ttests := []struct {\n\t\topts []func(*Context) error\n\t\tpath string\n\t}{\n\t\t{path: \"errors\"},\n\t\t{path: \"net/http\"}, // triggers vendor logic on go 1.6+\n\t}\n\n\tproj := testProject(t)\n\tfor _, tt := range tests {\n\t\tctx, err := NewContext(proj, tt.opts...)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer ctx.Destroy()\n\t\t_, err = ctx.loadPackage(nil, tt.path)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"loadPackage(%q): %v\", tt.path, err)\n\t\t}\n\t}\n}\n\nfunc TestCgoEnabled(t *testing.T) {\n\ttests := []struct {\n\t\tgohostos, gohostarch     string\n\t\tgotargetos, gotargetarch string\n\t\twant                     bool\n\t}{{\n\t\t\"linux\", \"amd64\", \"linux\", \"amd64\", true,\n\t}, {\n\t\t\"linux\", \"amd64\", \"linux\", \"386\", false,\n\t}}\n\n\tfor _, tt := range tests {\n\t\tgot := cgoEnabled(tt.gohostos, tt.gohostarch, tt.gotargetos, tt.gotargetarch)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"cgoEnabled(%q, %q, %q, %q): got %v, want %v\", tt.gohostos, tt.gohostarch, tt.gotargetos, tt.gotargetarch, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestContextImportPackage(t *testing.T) {\n\tproj := testProject(t)\n\ttests := []struct {\n\t\tpath string\n\t\terr  error\n\t}{{\n\t\tpath: \"a\",\n\t}, {\n\t\tpath: \"cgomain\",\n\t}, {\n\t\tpath: \"net/http\", // loaded from GOROOT\n\t}, {\n\t\tpath: \"cmd\",\n\t\terr:  &build.NoGoError{Dir: filepath.Join(proj.Projectdir(), \"src\", \"cmd\")},\n\t}}\n\n\tfor _, tt := range tests {\n\t\tctx, err := NewContext(proj)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t_, err = ctx.importer.Import(tt.path)\n\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"importPackage(%q): got %v, want %v\", tt.path, err, tt.err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "defaultcc.go",
          "type": "blob",
          "size": 0.0869140625,
          "content": "// +build !darwin,!freebsd\n\npackage gb\n\nconst defaultCC = \"gcc\"\nconst defaultCXX = \"g++\"\n"
        },
        {
          "name": "defaultcc_bsd.go",
          "type": "blob",
          "size": 0.0908203125,
          "content": "// +build darwin freebsd\n\npackage gb\n\nconst defaultCC = \"clang\"\nconst defaultCXX = \"clang++\"\n"
        },
        {
          "name": "depfile.go",
          "type": "blob",
          "size": 5.044921875,
          "content": "package gb\n\nimport (\n\t\"compress/gzip\"\n\t\"crypto/sha1\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/constabulary/gb/internal/depfile\"\n\t\"github.com/constabulary/gb/internal/untar\"\n\t\"github.com/pkg/errors\"\n)\n\nconst semverRegex = `^([0-9]+)\\.([0-9]+)\\.([0-9]+)(?:(\\-[0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?(?:\\+[0-9A-Za-z-\\-\\.]+)?$`\n\n// addDepfileDeps inserts into the Context's importer list\n// a set of importers for entries in the depfile.\nfunc addDepfileDeps(bc *build.Context, ctx *Context) (Importer, error) {\n\ti := Importer(new(nullImporter))\n\tdf, err := readDepfile(ctx)\n\tif err != nil {\n\t\tif !os.IsNotExist(errors.Cause(err)) {\n\t\t\treturn nil, errors.Wrap(err, \"could not parse depfile\")\n\t\t}\n\t\tctx.debug(\"no depfile, nothing to do.\")\n\t\treturn i, nil\n\t}\n\tre := regexp.MustCompile(semverRegex)\n\tfor prefix, kv := range df {\n\t\tif version, ok := kv[\"version\"]; ok {\n\t\t\tif !re.MatchString(version) {\n\t\t\t\treturn nil, errors.Errorf(\"%s: %q is not a valid SemVer 2.0.0 version\", prefix, version)\n\t\t\t}\n\t\t\troot := filepath.Join(cachePath(), hash(prefix, version))\n\t\t\tdest := filepath.Join(root, \"src\", filepath.FromSlash(prefix))\n\t\t\tfi, err := os.Stat(dest)\n\t\t\tif err == nil {\n\t\t\t\tif !fi.IsDir() {\n\t\t\t\t\treturn nil, errors.Errorf(\"%s is not a directory\", dest)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tif !os.IsNotExist(err) {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif err := fetchVersion(root, dest, prefix, version); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = &_importer{\n\t\t\t\tImporter: i,\n\t\t\t\tim: importer{\n\t\t\t\t\tContext: bc,\n\t\t\t\t\tRoot:    root,\n\t\t\t\t},\n\t\t\t}\n\t\t\tctx.debug(\"add importer for %q: %v\", prefix+\" \"+version, root)\n\t\t}\n\n\t\tif tag, ok := kv[\"tag\"]; ok {\n\t\t\troot := filepath.Join(cachePath(), hash(prefix, tag))\n\t\t\tdest := filepath.Join(root, \"src\", filepath.FromSlash(prefix))\n\t\t\tfi, err := os.Stat(dest)\n\t\t\tif err == nil {\n\t\t\t\tif !fi.IsDir() {\n\t\t\t\t\treturn nil, errors.Errorf(\"%s is not a directory\", dest)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tif !os.IsNotExist(err) {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif err := fetchTag(root, dest, prefix, tag); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = &_importer{\n\t\t\t\tImporter: i,\n\t\t\t\tim: importer{\n\t\t\t\t\tContext: bc,\n\t\t\t\t\tRoot:    root,\n\t\t\t\t},\n\t\t\t}\n\t\t\tctx.debug(\"add importer for %q: %v\", prefix+\" \"+tag, root)\n\t\t}\n\t}\n\treturn i, nil\n}\n\nfunc fetchVersion(root, dest, prefix, version string) error {\n\tif !strings.HasPrefix(prefix, \"github.com\") {\n\t\treturn errors.Errorf(\"unable to fetch %v\", prefix)\n\t}\n\n\tfmt.Printf(\"fetching %v (%v)\\n\", prefix, version)\n\n\trc, err := fetchRelease(prefix, \"v\"+version)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rc.Close()\n\treturn unpackReleaseTarball(dest, rc)\n}\n\nfunc fetchTag(root, dest, prefix, tag string) error {\n\tif !strings.HasPrefix(prefix, \"github.com\") {\n\t\treturn errors.Errorf(\"unable to fetch %v\", prefix)\n\t}\n\n\tfmt.Printf(\"fetching %v (%v)\\n\", prefix, tag)\n\n\trc, err := fetchRelease(prefix, tag)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rc.Close()\n\treturn unpackReleaseTarball(dest, rc)\n}\n\nfunc unpackReleaseTarball(dest string, r io.Reader) error {\n\tgzr, err := gzip.NewReader(r)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"unable to construct gzip reader\")\n\t}\n\n\tparent, pkg := filepath.Split(dest)\n\tif err := os.MkdirAll(parent, 0755); err != nil {\n\t\treturn err\n\t}\n\ttmpdir, err := ioutil.TempDir(parent, \"tmp\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer os.RemoveAll(tmpdir)\n\n\ttmpdir = filepath.Join(tmpdir, pkg)\n\n\tif err := untar.Untar(tmpdir, gzr); err != nil {\n\t\treturn err\n\t}\n\n\tdents, err := ioutil.ReadDir(tmpdir)\n\tif err != nil {\n\t\tos.RemoveAll(tmpdir)\n\t\treturn errors.Wrap(err, \"cannot read download directory\")\n\t}\n\tre := regexp.MustCompile(`\\w+-\\w+-[a-z0-9]+`)\n\tfor _, dent := range dents {\n\t\tif re.MatchString(dent.Name()) {\n\t\t\tif err := os.Rename(filepath.Join(tmpdir, dent.Name()), dest); err != nil {\n\t\t\t\tos.RemoveAll(tmpdir)\n\t\t\t\treturn errors.Wrap(err, \"unable to rename final cache dir\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\tos.RemoveAll(tmpdir)\n\treturn errors.New(\"release directory not found in tarball\")\n}\n\nfunc fetchRelease(prefix, tag string) (io.ReadCloser, error) {\n\tconst format = \"https://api.github.com/repos/%s/tarball/%s\"\n\tprefix = prefix[len(\"github.com/\"):]\n\turl := fmt.Sprintf(format, prefix, tag)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to fetch %q\", url)\n\t}\n\tif resp.StatusCode != 200 {\n\t\treturn nil, errors.Errorf(\"failed to fetch %q: expected 200, got %d\", url, resp.StatusCode)\n\t}\n\treturn resp.Body, nil\n}\n\nfunc readDepfile(ctx *Context) (map[string]map[string]string, error) {\n\tfile := filepath.Join(ctx.Projectdir(), \"depfile\")\n\tctx.debug(\"loading depfile at %q\", file)\n\treturn depfile.ParseFile(file)\n}\n\nfunc hash(arg string, args ...string) string {\n\th := sha1.New()\n\tio.WriteString(h, arg)\n\tfor _, arg := range args {\n\t\tio.WriteString(h, arg)\n\t}\n\treturn fmt.Sprintf(\"%x\", string(h.Sum(nil)))\n}\n\nfunc cachePath() string {\n\treturn filepath.Join(gbhome(), \"cache\")\n}\n\nfunc gbhome() string {\n\treturn envOr(\"GB_HOME\", filepath.Join(envOr(\"HOME\", \"/tmp\"), \".gb\"))\n}\n\nfunc envOr(key, def string) string {\n\tv := os.Getenv(key)\n\tif v == \"\" {\n\t\tv = def\n\t}\n\treturn v\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 0.6640625,
          "content": "package gb_test\n\nimport (\n\t\"log\"\n\t\"path/filepath\"\n\n\t\"github.com/constabulary/gb\"\n)\n\nfunc ExampleNewProject() {\n\n\t// Every project begins with a project root.\n\t// Normally you'd check this out of source control.\n\troot := filepath.Join(\"home\", \"dfc\", \"devel\", \"demo\")\n\n\t// Create a new Project passing in the source directories\n\t// under this project's root.\n\tproj := gb.NewProject(root)\n\n\t// Create a new Context from the Project. A Context holds\n\t// the state of a specific compilation or test within the Project.\n\tctx, err := gb.NewContext(proj)\n\tif err != nil {\n\t\tlog.Fatal(\"Could not create new context:\", err)\n\t}\n\n\t// Always remember to clean up your Context\n\tctx.Destroy()\n}\n"
        },
        {
          "name": "executor.go",
          "type": "blob",
          "size": 2.115234375,
          "content": "package gb\n\nimport (\n\t\"sync\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// Execute executes a tree of *Actions sequentually in depth first order.\nfunc Execute(a *Action) error {\n\tseen := make(map[*Action]error)\n\treturn execute(seen, a)\n}\n\nfunc execute(seen map[*Action]error, a *Action) error {\n\t// step 0, have we been here before\n\tif err, ok := seen[a]; ok {\n\t\treturn err\n\t}\n\n\t// step 1, build all dependencies\n\tfor _, d := range a.Deps {\n\t\tif err := execute(seen, d); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// step 2, now execute ourselves\n\terr := a.Run()\n\tseen[a] = err\n\treturn err\n}\n\n// ExecuteConcurrent executes all actions in a tree concurrently.\n// Each Action will wait until its dependant actions are complete.\nfunc ExecuteConcurrent(a *Action, n int, interrupt <-chan struct{}) error {\n\tvar mu sync.Mutex // protects seen\n\tseen := make(map[*Action]chan error)\n\n\tget := func(result chan error) error {\n\t\terr := <-result\n\t\tresult <- err\n\t\treturn err\n\t}\n\n\tpermits := make(chan bool, n)\n\tfor i := 0; i < cap(permits); i++ {\n\t\tpermits <- true\n\t}\n\n\t// wg tracks all the outstanding actions\n\tvar wg sync.WaitGroup\n\n\tvar execute func(map[*Action]chan error, *Action) chan error\n\texecute = func(seen map[*Action]chan error, a *Action) chan error {\n\n\t\t// step 0, have we seen this action before ?\n\t\tmu.Lock()\n\t\tif result, ok := seen[a]; ok {\n\t\t\t// yes! return the result channel so others can wait\n\t\t\t//  on our action\n\t\t\tmu.Unlock()\n\t\t\treturn result\n\t\t}\n\n\t\t// step 1, we're the first to run this action\n\t\tresult := make(chan error, 1)\n\t\tseen[a] = result\n\t\tmu.Unlock()\n\n\t\t// queue all dependant actions.\n\t\tvar results []chan error\n\t\tfor _, dep := range a.Deps {\n\t\t\tresults = append(results, execute(seen, dep))\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t// wait for dependant actions\n\t\t\tfor _, r := range results {\n\t\t\t\tif err := get(r); err != nil {\n\t\t\t\t\tresult <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\t// wait for a permit and execute our action\n\t\t\tselect {\n\t\t\tcase <-permits:\n\t\t\t\tresult <- a.Run()\n\t\t\t\tpermits <- true\n\t\t\tcase <-interrupt:\n\t\t\t\tresult <- errors.New(\"interrupted\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\n\t\treturn result\n\n\t}\n\terr := get(execute(seen, a))\n\twg.Wait()\n\treturn err\n}\n"
        },
        {
          "name": "executor_test.go",
          "type": "blob",
          "size": 3.9345703125,
          "content": "package gb\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"io\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestExecuteBuildAction(t *testing.T) {\n\ttests := []struct {\n\t\tpkg string\n\t\terr error\n\t}{{\n\t\tpkg: \"a\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"b\", // actually command\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"c\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"d.v1\",\n\t\terr: nil,\n\t}, {\n\t\tpkg: \"x\",\n\t\terr: errors.New(\"import cycle detected: x -> y -> x\"),\n\t}, {\n\t\tpkg: \"h\", // imports \"blank\", which is blank, see issue #131\n\t\terr: &build.NoGoError{Dir: filepath.Join(getwd(t), \"testdata\", \"src\", \"blank\")},\n\t}}\n\n\tfor _, tt := range tests {\n\t\tctx := testContext(t)\n\t\tdefer ctx.Destroy()\n\t\tpkg, err := ctx.ResolvePackage(tt.pkg)\n\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"ctx.ResolvePackage(%v): want %v, got %v\", tt.pkg, tt.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\taction, err := BuildPackages(pkg)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"BuildAction(%v): %v\", tt.pkg, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err := Execute(action); !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"Execute(%v): want: %v, got %v\", action.Name, tt.err, err)\n\t\t}\n\t}\n}\n\nfunc niltask() error { return nil }\n\nvar executorTests = []struct {\n\taction *Action // root action\n\terr    error   // expected error\n}{{\n\taction: &Action{\n\t\tName: \"no error\",\n\t\tRun:  niltask,\n\t},\n}, {\n\taction: &Action{\n\t\tName: \"root error\",\n\t\tRun:  func() error { return io.EOF },\n\t},\n\terr: io.EOF,\n}, {\n\taction: &Action{\n\t\tName: \"child, child, error\",\n\t\tRun:  func() error { return fmt.Errorf(\"I should not have been called\") },\n\t\tDeps: []*Action{{\n\t\t\tName: \"child, error\",\n\t\t\tRun:  niltask,\n\t\t\tDeps: []*Action{{\n\t\t\t\tName: \"error\",\n\t\t\t\tRun:  func() error { return io.EOF },\n\t\t\t}},\n\t\t}},\n\t},\n\terr: io.EOF,\n}, {\n\taction: &Action{\n\t\tName: \"once only\",\n\t\tRun: func() error {\n\t\t\tif c1 != 1 || c2 != 1 || c3 != 1 {\n\t\t\t\treturn fmt.Errorf(\"unexpected count, c1: %v, c2: %v, c3: %v\", c1, c2, c3)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tDeps: []*Action{createDag()},\n\t},\n}, {\n\taction: &Action{\n\t\tName: \"failure count\",\n\t\tRun:  func() error { return fmt.Errorf(\"I should not have been called\") },\n\t\tDeps: []*Action{createFailDag()},\n\t},\n\terr: fmt.Errorf(\"task3 called 1 time\"),\n}}\n\nfunc createDag() *Action {\n\ttask1 := func() error { c1++; return nil }\n\ttask2 := func() error { c2++; return nil }\n\ttask3 := func() error { c3++; return nil }\n\n\taction1 := Action{Name: \"c1\", Run: task1}\n\taction2 := Action{Name: \"c2\", Run: task2}\n\taction3 := Action{Name: \"c3\", Run: task3}\n\n\taction1.Deps = append(action1.Deps, &action2, &action3)\n\taction2.Deps = append(action2.Deps, &action3)\n\treturn &action1\n}\n\nfunc createFailDag() *Action {\n\ttask1 := func() error { c1++; return nil }\n\ttask2 := func() error { c2++; return fmt.Errorf(\"task2 called %v time\", c2) }\n\ttask3 := func() error { c3++; return fmt.Errorf(\"task3 called %v time\", c3) }\n\n\taction1 := Action{Name: \"c1\", Run: task1}\n\taction2 := Action{Name: \"c2\", Run: task2}\n\taction3 := Action{Name: \"c3\", Run: task3}\n\n\taction1.Deps = append(action1.Deps, &action2, &action3)\n\taction2.Deps = append(action2.Deps, &action3)\n\treturn &action1\n}\n\nvar c1, c2, c3 int\n\nfunc executeReset() {\n\tc1 = 0\n\tc2 = 0\n\tc3 = 0\n\t// reset executor test variables\n}\n\nfunc TestExecute(t *testing.T) {\n\tfor _, tt := range executorTests {\n\t\texecuteReset()\n\t\tgot := Execute(tt.action)\n\t\tif !reflect.DeepEqual(got, tt.err) {\n\t\t\tt.Errorf(\"Execute: %v: want err: %v, got err %v\", tt.action.Name, tt.err, got)\n\t\t}\n\t}\n}\n\nfunc testExecuteConcurrentN(t *testing.T, n int) {\n\tfor _, tt := range executorTests {\n\t\texecuteReset()\n\t\tgot := ExecuteConcurrent(tt.action, n, nil) // no interrupt ch\n\t\tif !reflect.DeepEqual(got, tt.err) {\n\t\t\tt.Errorf(\"ExecuteConcurrent(%v): %v: want err: %v, got err %v\", n, tt.action.Name, tt.err, got)\n\t\t}\n\t}\n}\n\nfunc TestExecuteConcurrent1(t *testing.T) { testExecuteConcurrentN(t, 1) }\nfunc TestExecuteConcurrent2(t *testing.T) { testExecuteConcurrentN(t, 2) }\nfunc TestExecuteConcurrent4(t *testing.T) { testExecuteConcurrentN(t, 4) }\nfunc TestExecuteConcurrent7(t *testing.T) { testExecuteConcurrentN(t, 7) }\n"
        },
        {
          "name": "gb.go",
          "type": "blob",
          "size": 2.5244140625,
          "content": "// Package gb is a tool kit for building Go packages and programs.\n//\n// The executable, cmd/gb, is located in the respective subdirectory\n// along with several plugin programs.\npackage gb\n\nimport (\n\t\"go/build\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nvar releaseTags = build.Default.ReleaseTags\n\n// Toolchain represents a standardised set of command line tools\n// used to build and test Go programs.\ntype Toolchain interface {\n\tGc(pkg *Package, files []string) error\n\tAsm(pkg *Package, ofile, sfile string) error\n\tPack(pkg *Package, afiles ...string) error\n\tLd(*Package) error\n\tCc(pkg *Package, ofile string, cfile string) error\n\n\t// compiler returns the location of the compiler for .go source code\n\tcompiler() string\n\n\t// linker returns the location of the linker for this toolchain\n\tlinker() string\n}\n\n// Actions and Tasks.\n//\n// Actions and Tasks allow gb to separate the role of describing the\n// order in which work will be done, from the work itself.\n// Actions are the former, they describe the graph of dependencies\n// between actions, and thus the work to be done. By traversing the action\n// graph, we can do the work, executing Tasks in a sane order.\n//\n// Tasks describe the work to be done, without being concerned with\n// the order in which the work is done -- that is up to the code that\n// places Tasks into actions. Tasks also know more intimate details about\n// filesystems, processes, file lists, etc, that Actions do not.\n//\n// Action graphs (they are not strictly trees as branchs converge on base actions)\n// contain only work to be performed, there are no Actions with empty Tasks\n// or Tasks which do no work.\n//\n// Actions are executed by Executors, but can also be transformed, mutated,\n// or even graphed.\n\n// An Action describes a task to be performed and a set\n// of Actions that the task depends on.\ntype Action struct {\n\n\t// Name describes the action.\n\tName string\n\n\t// Deps identifies the Actions that this Action depends.\n\tDeps []*Action\n\n\t// Run identifies the task that this action represents.\n\tRun func() error\n}\n\nfunc mkdir(path string) error {\n\treturn os.MkdirAll(path, 0755)\n}\n\n// stripext strips the extension from a filename.\n// The extension is defined by filepath.Ext.\nfunc stripext(path string) string {\n\treturn path[:len(path)-len(filepath.Ext(path))]\n}\n\nfunc relImportPath(root, path string) (string, error) {\n\tif isRel(path) {\n\t\treturn filepath.Rel(root, path)\n\t}\n\treturn path, nil\n}\n\n// isRel returns if an import path is relative or absolute.\nfunc isRel(path string) bool {\n\t// TODO(dfc) should this be strings.StartsWith(\".\")\n\treturn path == \".\"\n}\n"
        },
        {
          "name": "gb_test.go",
          "type": "blob",
          "size": 1.1279296875,
          "content": "package gb\n\nimport \"testing\"\n\nfunc TestStripext(t *testing.T) {\n\ttests := []struct {\n\t\tpath, want string\n\t}{\n\t\t{\"a.txt\", \"a\"},\n\t\t{\"a.a.txt\", \"a.a\"},\n\t\t{\"Makefile\", \"Makefile\"},\n\t\t{\"\", \"\"},\n\t\t{\"/\", \"/\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := stripext(tt.path)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"stripext(%q): want: %v, got: %v\", tt.path, tt.want, got)\n\t\t}\n\t}\n}\n\nfunc TestRelImportPath(t *testing.T) {\n\ttests := []struct {\n\t\troot, path, want string\n\t}{\n\t\t{\"/project/src\", \"a\", \"a\"},\n\t\t// { \"/project/src\", \"./a\", \"a\"}, // TODO(dfc) this is relative\n\t\t// { \"/project/src\", \"a/../b\", \"a\"}, // TODO(dfc) so is this\n\t}\n\n\tfor _, tt := range tests {\n\n\t\tgot, _ := relImportPath(tt.root, tt.path)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"relImportPath(%q, %q): want: %v, got: %v\", tt.root, tt.path, tt.want, got)\n\t\t}\n\t}\n}\n\nfunc TestIsRel(t *testing.T) {\n\ttests := []struct {\n\t\tpath string\n\t\twant bool\n\t}{\n\t\t{\".\", true},\n\t\t{\"..\", false},     // TODO(dfc) this is relative\n\t\t{\"a/../b\", false}, // TODO(dfc) this too\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := isRel(tt.path)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"isRel(%q): want: %v, got: %v\", tt.path, tt.want, got)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "gc.go",
          "type": "blob",
          "size": 4.501953125,
          "content": "package gb\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/constabulary/gb/internal/version\"\n\t\"github.com/pkg/errors\"\n)\n\n// gc toolchain\n\ntype gcToolchain struct {\n\tgc, cc, ld, as, pack string\n}\n\nfunc GcToolchain() func(c *Context) error {\n\treturn func(c *Context) error {\n\t\t// TODO(dfc) this should come from the context, not the runtime.\n\t\tgoroot := runtime.GOROOT()\n\n\t\ttooldir := filepath.Join(goroot, \"pkg\", \"tool\", c.gohostos+\"_\"+c.gohostarch)\n\t\texe := \"\"\n\t\tif c.gohostos == \"windows\" {\n\t\t\texe += \".exe\"\n\t\t}\n\t\tswitch {\n\t\tcase version.Version > 1.5:\n\t\t\tc.tc = &gcToolchain{\n\t\t\t\tgc:   filepath.Join(tooldir, \"compile\"+exe),\n\t\t\t\tld:   filepath.Join(tooldir, \"link\"+exe),\n\t\t\t\tas:   filepath.Join(tooldir, \"asm\"+exe),\n\t\t\t\tpack: filepath.Join(tooldir, \"pack\"+exe),\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\treturn errors.Errorf(\"unsupported Go version: %v\", runtime.Version())\n\t\t}\n\t}\n}\n\nfunc (t *gcToolchain) Asm(pkg *Package, ofile, sfile string) error {\n\targs := []string{\"-o\", ofile, \"-D\", \"GOOS_\" + pkg.gotargetos, \"-D\", \"GOARCH_\" + pkg.gotargetarch}\n\tswitch {\n\tcase version.Version > 1.5:\n\t\todir := filepath.Join(filepath.Dir(ofile))\n\t\tincludedir := filepath.Join(runtime.GOROOT(), \"pkg\", \"include\")\n\t\targs = append(args, \"-I\", odir, \"-I\", includedir)\n\tdefault:\n\t\treturn errors.Errorf(\"unsupported Go version: %v\", runtime.Version())\n\t}\n\targs = append(args, sfile)\n\tif err := mkdir(filepath.Dir(ofile)); err != nil {\n\t\treturn errors.Errorf(\"gc:asm: %v\", err)\n\t}\n\tvar buf bytes.Buffer\n\terr := runOut(&buf, pkg.Dir, nil, t.as, args...)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t}\n\treturn err\n}\n\nfunc (t *gcToolchain) Ld(pkg *Package) error {\n\t// to ensure we don't write a partial binary, link the binary to a temporary file in\n\t// in the target directory, then rename.\n\tdir := pkg.bindir()\n\tif err := mkdir(dir); err != nil {\n\t\treturn err\n\t}\n\ttmp, err := ioutil.TempFile(dir, \".gb-link\")\n\tif err != nil {\n\t\treturn err\n\t}\n\ttmp.Close()\n\n\targs := append(pkg.ldflags, \"-o\", tmp.Name())\n\tfor _, d := range pkg.includePaths() {\n\t\targs = append(args, \"-L\", d)\n\t}\n\targs = append(args, \"-extld\", linkCmd(pkg, \"CC\", defaultCC))\n\targs = append(args, \"-buildmode\", pkg.buildmode)\n\targs = append(args, pkg.objfile())\n\n\tvar buf bytes.Buffer\n\tif err = runOut(&buf, \".\", nil, t.ld, args...); err != nil {\n\t\tos.Remove(tmp.Name()) // remove partial file\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t\treturn err\n\t}\n\treturn os.Rename(tmp.Name(), pkg.Binfile())\n}\n\nfunc (t *gcToolchain) Cc(pkg *Package, ofile, cfile string) error {\n\treturn errors.Errorf(\"gc %f does not support cc\", version.Version)\n}\n\nfunc (t *gcToolchain) Pack(pkg *Package, afiles ...string) error {\n\targs := []string{\"r\"}\n\targs = append(args, afiles...)\n\tdir := filepath.Dir(afiles[0])\n\tvar buf bytes.Buffer\n\terr := runOut(&buf, dir, nil, t.pack, args...)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t}\n\treturn err\n}\n\nfunc (t *gcToolchain) compiler() string { return t.gc }\nfunc (t *gcToolchain) linker() string   { return t.ld }\n\nfunc (t *gcToolchain) Gc(pkg *Package, files []string) error {\n\toutfile := pkg.objfile()\n\targs := append(pkg.gcflags, \"-p\", pkg.ImportPath, \"-pack\")\n\targs = append(args, \"-o\", outfile)\n\tfor _, d := range pkg.includePaths() {\n\t\targs = append(args, \"-I\", d)\n\t}\n\tif pkg.Goroot && pkg.ImportPath == \"runtime\" {\n\t\t// runtime compiles with a special gc flag to emit\n\t\t// additional reflect type data.\n\t\targs = append(args, \"-+\")\n\t}\n\n\tif pkg.complete() {\n\t\targs = append(args, \"-complete\")\n\t} else {\n\t\tasmhdr := filepath.Join(filepath.Dir(outfile), pkg.Name, \"go_asm.h\")\n\t\targs = append(args, \"-asmhdr\", asmhdr)\n\t}\n\n\t// If there are vendored components, create an -importmap to map the import statement\n\t// to the vendored import path. The possibilities for abusing this flag are endless.\n\tif pkg.Goroot {\n\t\tfor _, path := range pkg.Package.Imports {\n\t\t\tif i := strings.LastIndex(path, \"/vendor/\"); i >= 0 {\n\t\t\t\targs = append(args, \"-importmap\", path[i+len(\"/vendor/\"):]+\"=\"+path)\n\t\t\t} else if strings.HasPrefix(path, \"vendor/\") {\n\t\t\t\targs = append(args, \"-importmap\", path[len(\"vendor/\"):]+\"=\"+path)\n\t\t\t}\n\t\t}\n\t}\n\n\targs = append(args, files...)\n\tif err := mkdir(filepath.Join(filepath.Dir(outfile), pkg.Name)); err != nil {\n\t\treturn errors.Wrap(err, \"mkdir\")\n\t}\n\tvar buf bytes.Buffer\n\terr := runOut(&buf, pkg.Dir, nil, t.gc, args...)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"# %s\\n\", pkg.ImportPath)\n\t\tio.Copy(os.Stderr, &buf)\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.go",
          "type": "blob",
          "size": 7.7626953125,
          "content": "package gb\n\nimport (\n\t\"fmt\"\n\t\"go/build\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// Package represents a resolved package from the Project with respect to the Context.\ntype Package struct {\n\t*Context\n\t*build.Package\n\tTestScope bool\n\tNotStale  bool // this package _and_ all its dependencies are not stale\n\tMain      bool // is this a command\n\tImports   []*Package\n}\n\n// newPackage creates a resolved Package without setting pkg.Stale.\nfunc (ctx *Context) newPackage(p *build.Package) (*Package, error) {\n\tpkg := &Package{\n\t\tContext: ctx,\n\t\tPackage: p,\n\t}\n\tfor _, i := range p.Imports {\n\t\tdep, ok := ctx.pkgs[i]\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"newPackage(%q): could not locate dependant package %q \", p.Name, i)\n\t\t}\n\t\tpkg.Imports = append(pkg.Imports, dep)\n\t}\n\treturn pkg, nil\n}\n\nfunc (p *Package) String() string {\n\treturn fmt.Sprintf(\"%s {Name:%s, Dir:%s}\", p.ImportPath, p.Name, p.Dir)\n}\n\nfunc (p *Package) includePaths() []string {\n\tincludes := p.Context.includePaths()\n\tswitch {\n\tcase p.TestScope && p.Main:\n\t\tip := filepath.Dir(filepath.FromSlash(p.ImportPath))\n\t\treturn append([]string{filepath.Join(p.Context.Workdir(), ip, \"_test\")}, includes...)\n\tcase p.TestScope:\n\t\tip := strings.TrimSuffix(filepath.FromSlash(p.ImportPath), \"_test\")\n\t\treturn append([]string{filepath.Join(p.Context.Workdir(), ip, \"_test\")}, includes...)\n\tdefault:\n\t\treturn includes\n\t}\n}\n\n// complete indicates if this is a pure Go package\nfunc (p *Package) complete() bool {\n\t// If we're giving the compiler the entire package (no C etc files), tell it that,\n\t// so that it can give good error messages about forward declarations.\n\t// Exceptions: a few standard packages have forward declarations for\n\t// pieces supplied behind-the-scenes by package runtime.\n\textFiles := len(p.CgoFiles) + len(p.CFiles) + len(p.CXXFiles) + len(p.MFiles) + len(p.SFiles) + len(p.SysoFiles) + len(p.SwigFiles) + len(p.SwigCXXFiles)\n\tif p.Goroot {\n\t\tswitch p.ImportPath {\n\t\tcase \"bytes\", \"internal/poll\", \"net\", \"os\", \"runtime/pprof\", \"sync\", \"syscall\", \"time\":\n\t\t\textFiles++\n\t\t}\n\t}\n\treturn extFiles == 0\n}\n\n// Binfile returns the destination of the compiled target of this command.\nfunc (pkg *Package) Binfile() string {\n\ttarget := filepath.Join(pkg.bindir(), pkg.binname())\n\n\t// if this is a cross compile or GOOS/GOARCH are both defined or there are build tags, add ctxString.\n\tif pkg.isCrossCompile() || (os.Getenv(\"GOOS\") != \"\" && os.Getenv(\"GOARCH\") != \"\") {\n\t\ttarget += \"-\" + pkg.ctxString()\n\t} else if len(pkg.buildtags) > 0 {\n\t\ttarget += \"-\" + strings.Join(pkg.buildtags, \"-\")\n\t}\n\n\tif pkg.gotargetos == \"windows\" {\n\t\ttarget += \".exe\"\n\t}\n\treturn target\n}\n\nfunc (pkg *Package) bindir() string {\n\tswitch {\n\tcase pkg.TestScope:\n\t\treturn filepath.Join(pkg.Context.Workdir(), filepath.FromSlash(pkg.ImportPath), \"_test\")\n\tdefault:\n\t\treturn pkg.Context.bindir()\n\t}\n}\n\nfunc (pkg *Package) Workdir() string {\n\tpath := filepath.FromSlash(pkg.ImportPath)\n\tdir := filepath.Dir(path)\n\tswitch {\n\tcase pkg.TestScope:\n\t\tip := strings.TrimSuffix(path, \"_test\")\n\t\treturn filepath.Join(pkg.Context.Workdir(), ip, \"_test\", dir)\n\tdefault:\n\t\treturn filepath.Join(pkg.Context.Workdir(), dir)\n\t}\n}\n\n// objfile returns the name of the object file for this package\nfunc (pkg *Package) objfile() string {\n\treturn filepath.Join(pkg.Workdir(), pkg.objname())\n}\n\nfunc (pkg *Package) objname() string {\n\treturn pkg.pkgname() + \".a\"\n}\n\nfunc (pkg *Package) pkgname() string {\n\t// TODO(dfc) use pkg path instead?\n\treturn filepath.Base(filepath.FromSlash(pkg.ImportPath))\n}\n\nfunc (pkg *Package) binname() string {\n\tif !pkg.Main {\n\t\tpanic(\"binname called with non main package: \" + pkg.ImportPath)\n\t}\n\t// TODO(dfc) use pkg path instead?\n\treturn filepath.Base(filepath.FromSlash(pkg.ImportPath))\n}\n\n// installpath returns the distination to cache this package's compiled .a file.\n// pkgpath and installpath differ in that the former returns the location where you will find\n// a previously cached .a file, the latter returns the location where an installed file\n// will be placed.\n//\n// The difference is subtle. pkgpath must deal with the possibility that the file is from the\n// standard library and is previously compiled. installpath will always return a path for the\n// project's pkg/ directory in the case that the stdlib is out of date, or not compiled for\n// a specific architecture.\nfunc (pkg *Package) installpath() string {\n\tif pkg.TestScope {\n\t\tpanic(\"installpath called with test scope\")\n\t}\n\treturn filepath.Join(pkg.Pkgdir(), filepath.FromSlash(pkg.ImportPath)+\".a\")\n}\n\n// pkgpath returns the destination for object cached for this Package.\nfunc (pkg *Package) pkgpath() string {\n\timportpath := filepath.FromSlash(pkg.ImportPath) + \".a\"\n\tswitch {\n\tcase pkg.isCrossCompile():\n\t\treturn filepath.Join(pkg.Pkgdir(), importpath)\n\tcase pkg.Goroot && pkg.race:\n\t\t// race enabled standard lib\n\t\treturn filepath.Join(runtime.GOROOT(), \"pkg\", pkg.gotargetos+\"_\"+pkg.gotargetarch+\"_race\", importpath)\n\tcase pkg.Goroot:\n\t\t// standard lib\n\t\treturn filepath.Join(runtime.GOROOT(), \"pkg\", pkg.gotargetos+\"_\"+pkg.gotargetarch, importpath)\n\tdefault:\n\t\treturn filepath.Join(pkg.Pkgdir(), importpath)\n\t}\n}\n\n// isStale returns true if the source pkg is considered to be stale with\n// respect to its installed version.\nfunc (pkg *Package) isStale() bool {\n\tswitch pkg.ImportPath {\n\tcase \"C\", \"unsafe\":\n\t\t// synthetic packages are never stale\n\t\treturn false\n\t}\n\n\tif !pkg.Goroot && pkg.Force {\n\t\treturn true\n\t}\n\n\t// tests are always stale, they are never installed\n\tif pkg.TestScope {\n\t\treturn true\n\t}\n\n\t// Package is stale if completely unbuilt.\n\tvar built time.Time\n\tif fi, err := os.Stat(pkg.pkgpath()); err == nil {\n\t\tbuilt = fi.ModTime()\n\t}\n\n\tif built.IsZero() {\n\t\tpkg.debug(\"%s is missing\", pkg.pkgpath())\n\t\treturn true\n\t}\n\n\tolderThan := func(file string) bool {\n\t\tfi, err := os.Stat(file)\n\t\treturn err != nil || fi.ModTime().After(built)\n\t}\n\n\tnewerThan := func(file string) bool {\n\t\tfi, err := os.Stat(file)\n\t\treturn err != nil || fi.ModTime().Before(built)\n\t}\n\n\t// As a courtesy to developers installing new versions of the compiler\n\t// frequently, define that packages are stale if they are\n\t// older than the compiler, and commands if they are older than\n\t// the linker.  This heuristic will not work if the binaries are\n\t// back-dated, as some binary distributions may do, but it does handle\n\t// a very common case.\n\tif !pkg.Goroot {\n\t\tif olderThan(pkg.tc.compiler()) {\n\t\t\tpkg.debug(\"%s is older than %s\", pkg.pkgpath(), pkg.tc.compiler())\n\t\t\treturn true\n\t\t}\n\t\tif pkg.Main && olderThan(pkg.tc.linker()) {\n\t\t\tpkg.debug(\"%s is older than %s\", pkg.pkgpath(), pkg.tc.compiler())\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif pkg.Goroot && !pkg.isCrossCompile() {\n\t\t// if this is a standard lib package, and we are not cross compiling\n\t\t// then assume the package is up to date. This also works around\n\t\t// golang/go#13769.\n\t\treturn false\n\t}\n\n\t// Package is stale if a dependency is newer.\n\tfor _, p := range pkg.Imports {\n\t\tif p.ImportPath == \"C\" || p.ImportPath == \"unsafe\" {\n\t\t\tcontinue // ignore stale imports of synthetic packages\n\t\t}\n\t\tif olderThan(p.pkgpath()) {\n\t\t\tpkg.debug(\"%s is older than %s\", pkg.pkgpath(), p.pkgpath())\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// if the main package is up to date but _newer_ than the binary (which\n\t// could have been removed), then consider it stale.\n\tif pkg.Main && newerThan(pkg.Binfile()) {\n\t\tpkg.debug(\"%s is newer than %s\", pkg.pkgpath(), pkg.Binfile())\n\t\treturn true\n\t}\n\n\tsrcs := stringList(pkg.GoFiles, pkg.CFiles, pkg.CXXFiles, pkg.MFiles, pkg.HFiles, pkg.SFiles, pkg.CgoFiles, pkg.SysoFiles, pkg.SwigFiles, pkg.SwigCXXFiles)\n\n\tfor _, src := range srcs {\n\t\tif olderThan(filepath.Join(pkg.Dir, src)) {\n\t\t\tpkg.debug(\"%s is older than %s\", pkg.pkgpath(), filepath.Join(pkg.Dir, src))\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc stringList(args ...[]string) []string {\n\tvar l []string\n\tfor _, arg := range args {\n\t\tl = append(l, arg...)\n\t}\n\treturn l\n}\n"
        },
        {
          "name": "package_test.go",
          "type": "blob",
          "size": 9.439453125,
          "content": "package gb\n\nimport (\n\t\"fmt\"\n\t\"go/build\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/pkg/errors\"\n)\n\nfunc testContext(t *testing.T, opts ...func(*Context) error) *Context {\n\tctx, err := NewContext(testProject(t), opts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tctx.Force = true\n\treturn ctx\n}\n\nfunc TestResolvePackage(t *testing.T) {\n\tvar tests = []struct {\n\t\tpkg  string // package name\n\t\topts []func(*Context) error\n\t\terr  error\n\t}{{\n\t\tpkg: \"a\",\n\t}, {\n\t\tpkg: \"localimport\",\n\t\terr: &importErr{path: \"../localimport\", msg: \"relative import not supported\"},\n\t}}\n\tproj := testProject(t)\n\tfor _, tt := range tests {\n\t\tctx, err := NewContext(proj, tt.opts...)\n\t\tdefer ctx.Destroy()\n\t\t_, err = ctx.ResolvePackage(tt.pkg)\n\t\terr = errors.Cause(err)\n\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"ResolvePackage(%q): want: %v, got %v\", tt.pkg, tt.err, err)\n\t\t}\n\t}\n}\n\nfunc TestPackageBinfile(t *testing.T) {\n\topts := func(o ...func(*Context) error) []func(*Context) error { return o }\n\tgotargetos := \"windows\"\n\tif runtime.GOOS == \"windows\" {\n\t\tgotargetos = \"linux\"\n\t}\n\tgotargetarch := \"386\"\n\tif runtime.GOARCH == \"386\" {\n\t\tgotargetarch = \"amd64\"\n\t}\n\tvar tests = []struct {\n\t\tpkg  string // package name\n\t\topts []func(*Context) error\n\t\twant string // binfile result\n\t}{{\n\t\tpkg:  \"b\",\n\t\twant: \"b\",\n\t}, {\n\t\tpkg:  \"b\",\n\t\topts: opts(GOOS(gotargetos)),\n\t\twant: fmt.Sprintf(\"b-%v-%v\", gotargetos, runtime.GOARCH),\n\t}, {\n\t\tpkg:  \"b\",\n\t\topts: opts(GOARCH(gotargetarch)),\n\t\twant: fmt.Sprintf(\"b-%v-%v\", runtime.GOOS, gotargetarch),\n\t}, {\n\t\tpkg:  \"b\",\n\t\topts: opts(GOARCH(gotargetarch), GOOS(gotargetos)),\n\t\twant: fmt.Sprintf(\"b-%v-%v\", gotargetos, gotargetarch),\n\t}, {\n\t\tpkg:  \"b\",\n\t\topts: opts(Tags(\"lol\")),\n\t\twant: \"b-lol\",\n\t}, {\n\t\tpkg:  \"b\",\n\t\topts: opts(GOARCH(gotargetarch), GOOS(gotargetos), Tags(\"lol\")),\n\t\twant: fmt.Sprintf(\"b-%v-%v-lol\", gotargetos, gotargetarch),\n\t}}\n\n\tproj := testProject(t)\n\tfor i, tt := range tests {\n\t\tctx, _ := NewContext(proj, tt.opts...)\n\t\tdefer ctx.Destroy()\n\t\tpkg, err := ctx.ResolvePackage(tt.pkg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tgot := pkg.Binfile()\n\t\twant := filepath.Join(ctx.bindir(), tt.want)\n\t\tif pkg.gotargetos == \"windows\" {\n\t\t\twant += \".exe\"\n\t\t}\n\t\tif want != got {\n\t\t\tt.Errorf(\"test %v: (%s).Binfile(): want %s, got %s\", i+1, tt.pkg, want, got)\n\t\t}\n\t}\n}\n\nfunc TestPackageBindir(t *testing.T) {\n\tctx := testContext(t)\n\tdefer ctx.Destroy()\n\ttests := []struct {\n\t\tpkg  *Package\n\t\twant string\n\t}{{\n\t\tpkg: &Package{\n\t\t\tContext: ctx,\n\t\t},\n\t\twant: ctx.bindir(),\n\t}, {\n\t\tpkg: &Package{\n\t\t\tPackage: &build.Package{\n\t\t\t\tName:       \"testpkg\",\n\t\t\t\tImportPath: \"github.com/constabulary/gb/testpkg\",\n\t\t\t},\n\t\t\tContext:   ctx,\n\t\t\tTestScope: true,\n\t\t},\n\t\twant: filepath.Join(ctx.Workdir(), \"github.com\", \"constabulary\", \"gb\", \"testpkg\", \"_test\"),\n\t}}\n\n\tfor i, tt := range tests {\n\t\tgot := tt.pkg.bindir()\n\t\twant := tt.want\n\t\tif got != want {\n\t\t\tt.Errorf(\"test %v: Bindir: got %v want %v\", i+1, got, want)\n\t\t}\n\t}\n}\n\nfunc TestNewPackage(t *testing.T) {\n\ttests := []struct {\n\t\tpkg  build.Package\n\t\twant Package\n\t}{{\n\t\tpkg: build.Package{\n\t\t\tName:       \"C\",\n\t\t\tImportPath: \"C\",\n\t\t\tGoroot:     true,\n\t\t},\n\t\twant: Package{\n\t\t\tNotStale: true,\n\t\t},\n\t}}\n\tproj := testProject(t)\n\tfor i, tt := range tests {\n\t\tctx, _ := NewContext(proj)\n\t\tdefer ctx.Destroy()\n\n\t\tgot, err := ctx.NewPackage(&tt.pkg)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\twant := tt.want // deep copy\n\t\twant.Package = &tt.pkg\n\t\twant.Context = ctx\n\n\t\tif !reflect.DeepEqual(got, &want) {\n\t\t\tt.Errorf(\"%d: pkg: %s: expected %#v, got %#v\", i+1, tt.pkg.ImportPath, &want, got)\n\t\t}\n\t}\n}\n\nfunc TestStale(t *testing.T) {\n\tvar tests = []struct {\n\t\tpkgs  []string\n\t\tstale map[string]bool\n\t}{{\n\t\tpkgs: []string{\"a\"},\n\t\tstale: map[string]bool{\n\t\t\t\"a\": false,\n\t\t},\n\t}, {\n\t\tpkgs: []string{\"a\", \"b\"},\n\t\tstale: map[string]bool{\n\t\t\t\"a\": true,\n\t\t\t\"b\": false,\n\t\t},\n\t}, {\n\t\tpkgs: []string{\"a\", \"b\"},\n\t\tstale: map[string]bool{\n\t\t\t\"a\": true,\n\t\t\t\"b\": true,\n\t\t},\n\t}}\n\n\tproj := tempProject(t)\n\tdefer os.RemoveAll(proj.rootdir)\n\tproj.tempfile(\"src/a/a.go\", `package a\n\nconst A = \"A\"\n`)\n\n\tproj.tempfile(\"src/b/b.go\", `package main\n\nimport \"a\"\n\nfunc main() {\n        println(a.A)\n}\n`)\n\n\tnewctx := func() *Context {\n\t\tctx, err := NewContext(proj,\n\t\t\tGcToolchain(),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn ctx\n\t}\n\n\tresolve := func(ctx *Context, pkg string) *Package {\n\t\tp, err := ctx.ResolvePackage(pkg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn p\n\t}\n\n\tfor _, tt := range tests {\n\t\tctx := newctx()\n\t\tctx.Install = true\n\t\tdefer ctx.Destroy()\n\t\tfor _, pkg := range tt.pkgs {\n\t\t\tresolve(ctx, pkg)\n\t\t}\n\n\t\tfor p, s := range tt.stale {\n\t\t\tpkg := resolve(ctx, p)\n\t\t\tif pkg.NotStale != s {\n\t\t\t\tt.Errorf(\"%q.NotStale: got %v, want %v\", pkg.Name, pkg.NotStale, s)\n\t\t\t}\n\t\t}\n\n\t\tfor _, pkg := range tt.pkgs {\n\t\t\tif err := Build(resolve(ctx, pkg)); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestInstallpath(t *testing.T) {\n\tctx := testContext(t)\n\tdefer ctx.Destroy()\n\n\ttests := []struct {\n\t\tpkg         string\n\t\tinstallpath string\n\t}{{\n\t\tpkg:         \"a\", // from testdata\n\t\tinstallpath: filepath.Join(ctx.Pkgdir(), \"a.a\"),\n\t}, {\n\t\tpkg:         \"runtime\", // from stdlib\n\t\tinstallpath: filepath.Join(ctx.Pkgdir(), \"runtime.a\"),\n\t}, {\n\t\tpkg:         \"unsafe\", // synthetic\n\t\tinstallpath: filepath.Join(ctx.Pkgdir(), \"unsafe.a\"),\n\t}}\n\n\tresolve := func(pkg string) *Package {\n\t\tp, err := ctx.ResolvePackage(pkg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn p\n\t}\n\n\tfor _, tt := range tests {\n\t\tpkg := resolve(tt.pkg)\n\t\tgot := pkg.installpath()\n\t\tif got != tt.installpath {\n\t\t\tt.Errorf(\"installpath(%q): expected: %v, got %v\", tt.pkg, tt.installpath, got)\n\t\t}\n\t}\n}\n\nfunc TestPkgpath(t *testing.T) {\n\topts := func(o ...func(*Context) error) []func(*Context) error { return o }\n\tgotargetos := \"windows\"\n\tif runtime.GOOS == gotargetos {\n\t\tgotargetos = \"linux\"\n\t}\n\tgotargetarch := \"arm64\"\n\tif runtime.GOARCH == \"arm64\" {\n\t\tgotargetarch = \"amd64\"\n\t}\n\ttests := []struct {\n\t\topts    []func(*Context) error\n\t\tpkg     string\n\t\tpkgpath func(*Context) string\n\t}{{\n\t\tpkg:     \"a\", // from testdata\n\t\tpkgpath: func(ctx *Context) string { return filepath.Join(ctx.Pkgdir(), \"a.a\") },\n\t}, {\n\t\topts:    opts(GOOS(gotargetos), GOARCH(gotargetarch)),\n\t\tpkg:     \"a\", // from testdata\n\t\tpkgpath: func(ctx *Context) string { return filepath.Join(ctx.Pkgdir(), \"a.a\") },\n\t}, {\n\t\topts:    opts(WithRace),\n\t\tpkg:     \"a\", // from testdata\n\t\tpkgpath: func(ctx *Context) string { return filepath.Join(ctx.Pkgdir(), \"a.a\") },\n\t}, {\n\t\topts:    opts(Tags(\"foo\", \"bar\")),\n\t\tpkg:     \"a\", // from testdata\n\t\tpkgpath: func(ctx *Context) string { return filepath.Join(ctx.Pkgdir(), \"a.a\") },\n\t}, {\n\t\tpkg: \"runtime\", // from stdlib\n\t\tpkgpath: func(ctx *Context) string {\n\t\t\treturn filepath.Join(runtime.GOROOT(), \"pkg\", ctx.gohostos+\"_\"+ctx.gohostarch, \"runtime.a\")\n\t\t},\n\t}, {\n\t\topts: opts(Tags(\"foo\", \"bar\")),\n\t\tpkg:  \"runtime\", // from stdlib\n\t\tpkgpath: func(ctx *Context) string {\n\t\t\treturn filepath.Join(runtime.GOROOT(), \"pkg\", ctx.gohostos+\"_\"+ctx.gohostarch, \"runtime.a\")\n\t\t},\n\t}, {\n\t\topts: opts(WithRace),\n\t\tpkg:  \"runtime\", // from stdlib\n\t\tpkgpath: func(ctx *Context) string {\n\t\t\treturn filepath.Join(runtime.GOROOT(), \"pkg\", ctx.gohostos+\"_\"+ctx.gohostarch+\"_race\", \"runtime.a\")\n\t\t},\n\t}, {\n\t\topts: opts(WithRace, Tags(\"foo\", \"bar\")),\n\t\tpkg:  \"runtime\", // from stdlib\n\t\tpkgpath: func(ctx *Context) string {\n\t\t\treturn filepath.Join(runtime.GOROOT(), \"pkg\", ctx.gohostos+\"_\"+ctx.gohostarch+\"_race\", \"runtime.a\")\n\t\t},\n\t}, {\n\t\topts: opts(GOOS(gotargetos), GOARCH(gotargetarch)),\n\t\tpkg:  \"runtime\", // from stdlib\n\t\tpkgpath: func(ctx *Context) string {\n\t\t\treturn filepath.Join(ctx.Pkgdir(), \"runtime.a\")\n\t\t},\n\t}, {\n\t\tpkg: \"unsafe\", // synthetic\n\t\tpkgpath: func(ctx *Context) string {\n\t\t\treturn filepath.Join(runtime.GOROOT(), \"pkg\", ctx.gohostos+\"_\"+ctx.gohostarch, \"unsafe.a\")\n\t\t},\n\t}, {\n\t\tpkg:  \"unsafe\", // synthetic\n\t\topts: opts(GOOS(gotargetos), GOARCH(gotargetarch), WithRace),\n\t\tpkgpath: func(ctx *Context) string {\n\t\t\treturn filepath.Join(ctx.Pkgdir(), \"unsafe.a\")\n\t\t},\n\t}}\n\n\tfor _, tt := range tests {\n\t\tctx := testContext(t, tt.opts...)\n\t\tdefer ctx.Destroy()\n\t\tpkg, err := ctx.ResolvePackage(tt.pkg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tgot := pkg.pkgpath()\n\t\twant := tt.pkgpath(ctx)\n\t\tif got != want {\n\t\t\tt.Errorf(\"pkgpath(%q): expected: %v, got %v\", tt.pkg, want, got)\n\t\t}\n\t}\n}\n\nfunc TestPackageIncludePaths(t *testing.T) {\n\tctx := testContext(t)\n\ttests := []struct {\n\t\tpkg  *Package\n\t\twant []string\n\t}{{\n\t\tpkg: &Package{\n\t\t\tContext: ctx,\n\t\t\tPackage: &build.Package{\n\t\t\t\tImportPath: \"github.com/foo/bar\",\n\t\t\t},\n\t\t},\n\t\twant: []string{\n\t\t\tctx.Workdir(),\n\t\t\tctx.Pkgdir(),\n\t\t},\n\t}, {\n\t\tpkg: &Package{\n\t\t\tContext: ctx,\n\t\t\tPackage: &build.Package{\n\t\t\t\tImportPath: \"github.com/foo/bar\",\n\t\t\t},\n\t\t\tMain: true,\n\t\t},\n\t\twant: []string{\n\t\t\tctx.Workdir(),\n\t\t\tctx.Pkgdir(),\n\t\t},\n\t}, {\n\t\tpkg: &Package{\n\t\t\tContext: ctx,\n\t\t\tPackage: &build.Package{\n\t\t\t\tImportPath: \"github.com/foo/bar\",\n\t\t\t},\n\t\t\tTestScope: true,\n\t\t},\n\t\twant: []string{\n\t\t\tfilepath.Join(ctx.Workdir(), \"github.com\", \"foo\", \"bar\", \"_test\"),\n\t\t\tctx.Workdir(),\n\t\t\tctx.Pkgdir(),\n\t\t},\n\t}, {\n\t\tpkg: &Package{\n\t\t\tContext: ctx,\n\t\t\tPackage: &build.Package{\n\t\t\t\tImportPath: \"github.com/foo/bar\",\n\t\t\t},\n\t\t\tTestScope: true,\n\t\t\tMain:      true,\n\t\t},\n\t\twant: []string{\n\t\t\tfilepath.Join(ctx.Workdir(), \"github.com\", \"foo\", \"_test\"), // TODO(dfc) WTF\n\t\t\tctx.Workdir(),\n\t\t\tctx.Pkgdir(),\n\t\t},\n\t}}\n\n\tfor i, tt := range tests {\n\t\tgot := tt.pkg.includePaths()\n\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\tt.Errorf(\"%d: Package: ImportPath: %v, TestScope: %v, Main: %v: got %v, want %v\", i, tt.pkg.ImportPath, tt.pkg.TestScope, tt.pkg.Main, got, tt.want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "project.go",
          "type": "blob",
          "size": 1.2021484375,
          "content": "package gb\n\nimport (\n\t\"path/filepath\"\n)\n\n// Project represents a gb project. A gb project has a simlar layout to\n// a $GOPATH workspace. Each gb project has a standard directory layout\n// starting at the project root, which we'll refer too as $PROJECT.\n//\n//     $PROJECT/                       - the project root\n//     $PROJECT/src/                   - base directory for the source of packages\n//     $PROJECT/bin/                   - base directory for the compiled binaries\ntype Project interface {\n\n\t// Projectdir returns the path root of this project.\n\tProjectdir() string\n\n\t// Pkgdir returns the path to precompiled packages.\n\tPkgdir() string\n\n\t// Bindir returns the path for compiled programs.\n\tbindir() string\n}\n\ntype project struct {\n\trootdir string\n}\n\nfunc NewProject(root string) Project {\n\tproj := project{\n\t\trootdir: root,\n\t}\n\treturn &proj\n}\n\n// Pkgdir returns the path to precompiled packages.\nfunc (p *project) Pkgdir() string {\n\treturn filepath.Join(p.rootdir, \"pkg\")\n}\n\n// Projectdir returns the path root of this project.\nfunc (p *project) Projectdir() string {\n\treturn p.rootdir\n}\n\n// Bindir returns the path for compiled programs.\nfunc (p *project) bindir() string {\n\treturn filepath.Join(p.rootdir, \"bin\")\n}\n"
        },
        {
          "name": "project_test.go",
          "type": "blob",
          "size": 0.8271484375,
          "content": "package gb\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\ntype testproject struct {\n\t*testing.T\n\tproject\n}\n\nfunc testProject(t *testing.T) Project {\n\tcwd := getwd(t)\n\troot := filepath.Join(cwd, \"testdata\")\n\treturn &testproject{\n\t\tt,\n\t\tproject{\n\t\t\trootdir: root,\n\t\t},\n\t}\n}\n\nfunc tempProject(t *testing.T) *testproject {\n\treturn &testproject{\n\t\tt,\n\t\tproject{\n\t\t\trootdir: mktemp(t),\n\t\t},\n\t}\n}\n\nfunc (t *testproject) tempfile(path, contents string) string {\n\tdir, file := filepath.Split(path)\n\tdir = filepath.Join(t.rootdir, dir)\n\tif err := os.MkdirAll(dir, 0755); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpath = filepath.Join(dir, file)\n\tf, err := os.Create(path)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := io.WriteString(f, contents); err != nil {\n\t\tf.Close()\n\t\tt.Fatal(err)\n\t}\n\tif err := f.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn path\n}\n"
        },
        {
          "name": "resolver.go",
          "type": "blob",
          "size": 2.716796875,
          "content": "package gb\n\nimport (\n\t\"fmt\"\n\t\"go/build\"\n\t\"os\"\n\tpathpkg \"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n)\n\ntype nullImporter struct{}\n\nfunc (i *nullImporter) Import(path string) (*build.Package, error) {\n\treturn nil, errors.Errorf(\"import %q not found\", path)\n}\n\ntype srcImporter struct {\n\tImporter\n\tim importer\n}\n\nfunc (i *srcImporter) Import(path string) (*build.Package, error) {\n\tpkg, err := i.im.Import(path)\n\tif err == nil {\n\t\treturn pkg, nil\n\t}\n\n\t// gb expects, when there is a failure to resolve packages that\n\t// live in $PROJECT/src that the importer for that directory\n\t// will report them.\n\n\tpkg, err2 := i.Importer.Import(path)\n\tif err2 == nil {\n\t\treturn pkg, nil\n\t}\n\treturn nil, err\n}\n\ntype _importer struct {\n\tImporter\n\tim importer\n}\n\nfunc (i *_importer) Import(path string) (*build.Package, error) {\n\tpkg, err := i.im.Import(path)\n\tif err != nil {\n\t\treturn i.Importer.Import(path)\n\t}\n\treturn pkg, nil\n}\n\ntype fixupImporter struct {\n\tImporter\n}\n\nfunc (i *fixupImporter) Import(path string) (*build.Package, error) {\n\tpkg, err := i.Importer.Import(path)\n\tswitch err.(type) {\n\tcase *os.PathError:\n\t\treturn nil, errors.Wrapf(err, \"import %q: not found\", path)\n\tdefault:\n\t\treturn pkg, err\n\t}\n}\n\ntype importer struct {\n\t*build.Context\n\tRoot string // root directory\n}\n\ntype importErr struct {\n\tpath string\n\tmsg  string\n}\n\nfunc (e *importErr) Error() string {\n\treturn fmt.Sprintf(\"import %q: %v\", e.path, e.msg)\n}\n\nfunc (i *importer) Import(path string) (*build.Package, error) {\n\tif path == \"\" {\n\t\treturn nil, errors.WithStack(&importErr{path: path, msg: \"invalid import path\"})\n\t}\n\n\tif path == \".\" || path == \"..\" || strings.HasPrefix(path, \"./\") || strings.HasPrefix(path, \"../\") {\n\t\treturn nil, errors.WithStack(&importErr{path: path, msg: \"relative import not supported\"})\n\t}\n\n\tif strings.HasPrefix(path, \"/\") {\n\t\treturn nil, errors.WithStack(&importErr{path: path, msg: \"cannot import absolute path\"})\n\t}\n\n\tvar p *build.Package\n\n\tloadPackage := func(importpath, dir string) error {\n\t\tpkg, err := i.ImportDir(dir, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp = pkg\n\t\tp.ImportPath = importpath\n\t\treturn nil\n\t}\n\n\t// if this is the stdlib, then search vendor first.\n\t// this isn't real vendor support, just enough to make net/http compile.\n\tif i.Root == runtime.GOROOT() {\n\t\tpath := pathpkg.Join(\"vendor\", path)\n\t\tdir := filepath.Join(i.Root, \"src\", filepath.FromSlash(path))\n\t\tfi, err := os.Stat(dir)\n\t\tif err == nil && fi.IsDir() {\n\t\t\terr := loadPackage(path, dir)\n\t\t\treturn p, err\n\t\t}\n\t}\n\n\tdir := filepath.Join(i.Root, \"src\", filepath.FromSlash(path))\n\tfi, err := os.Stat(dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !fi.IsDir() {\n\t\treturn nil, errors.Errorf(\"import %q: not a directory\", path)\n\t}\n\terr = loadPackage(path, dir)\n\treturn p, err\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}